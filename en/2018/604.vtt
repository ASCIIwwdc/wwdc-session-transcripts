WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ Music ]

00:00:21.516 --> 00:00:27.776 A:middle
[ Applause ]

00:00:28.276 --> 00:00:28.666 A:middle
&gt;&gt; Thank you.

00:00:29.326 --> 00:00:30.746 A:middle
My name is Dan Omachi, I'm an

00:00:30.746 --> 00:00:32.036 A:middle
engineer in Apple's Metal

00:00:32.086 --> 00:00:32.946 A:middle
Ecosystem Team.

00:00:33.606 --> 00:00:35.536 A:middle
Now my main role on that team is

00:00:35.536 --> 00:00:37.136 A:middle
to help developers learn Metal

00:00:37.136 --> 00:00:38.346 A:middle
and have a great experience

00:00:38.346 --> 00:00:38.766 A:middle
using it.

00:00:39.476 --> 00:00:41.326 A:middle
But prior to this I worked on

00:00:41.326 --> 00:00:43.456 A:middle
Apple's OpenGL and OpenGL ES

00:00:43.636 --> 00:00:44.686 A:middle
frameworks for many years.

00:00:45.086 --> 00:00:46.716 A:middle
And even before joining Apple I

00:00:46.716 --> 00:00:47.746 A:middle
worked on a couple of other

00:00:47.746 --> 00:00:48.936 A:middle
OpenGL implementations.

00:00:50.926 --> 00:00:53.286 A:middle
So I'm really proud of what

00:00:53.446 --> 00:00:55.576 A:middle
we've accomplished with OpenGL

00:00:55.736 --> 00:00:57.866 A:middle
over the past years, but I'm

00:00:57.866 --> 00:00:59.976 A:middle
also really excited about the

00:00:59.976 --> 00:01:02.166 A:middle
direction Metal's taking us.


00:00:59.976 --> 00:01:02.166 A:middle
direction Metal's taking us.

00:01:02.936 --> 00:01:04.726 A:middle
Today my colleague Sukanya

00:01:04.726 --> 00:01:05.906 A:middle
Sudugu and I are going to give

00:01:05.906 --> 00:01:07.556 A:middle
you a brief introduction to

00:01:07.556 --> 00:01:10.066 A:middle
Metal and provide some guidance

00:01:10.456 --> 00:01:12.526 A:middle
about how you can easily port

00:01:12.526 --> 00:01:15.156 A:middle
your OpenGL apps over.

00:01:15.386 --> 00:01:16.906 A:middle
Now this is particularly

00:01:16.906 --> 00:01:19.016 A:middle
important this year because as

00:01:19.016 --> 00:01:20.876 A:middle
announced in yesterday's state

00:01:20.876 --> 00:01:23.466 A:middle
of the union OpenGL, openGL ES

00:01:23.676 --> 00:01:25.366 A:middle
and OpenCL are deprecated.

00:01:26.336 --> 00:01:28.206 A:middle
Now existing and soon-to-be

00:01:28.206 --> 00:01:30.346 A:middle
launched apps can still use

00:01:30.716 --> 00:01:35.006 A:middle
OpenGL ES on tvOS and iOS12 and

00:01:35.636 --> 00:01:40.706 A:middle
OpenGL and OpenCL on macOS 10.14

00:01:40.706 --> 00:01:43.326 A:middle
Mojave and this will remain so

00:01:43.926 --> 00:01:44.626 A:middle
for some time.

00:01:45.476 --> 00:01:48.286 A:middle
However, new projects should

00:01:48.286 --> 00:01:49.906 A:middle
target Metal from their

00:01:49.906 --> 00:01:50.486 A:middle
inception.

00:01:51.026 --> 00:01:51.886 A:middle
So if you're not already

00:01:51.886 --> 00:01:53.446 A:middle
familiar with Metal, then it's

00:01:53.446 --> 00:01:54.156 A:middle
time to get started.

00:01:55.806 --> 00:01:56.886 A:middle
Before you rip out all of your

00:01:56.886 --> 00:01:58.416 A:middle
OpenGL code and start porting it

00:01:58.416 --> 00:01:59.526 A:middle
all to Metal you've got a few

00:01:59.526 --> 00:02:00.446 A:middle
options to consider.


00:01:59.526 --> 00:02:00.446 A:middle
options to consider.

00:02:01.376 --> 00:02:03.156 A:middle
Apple offers several high-level

00:02:03.226 --> 00:02:04.906 A:middle
frameworks that do rendering,

00:02:05.466 --> 00:02:06.446 A:middle
different kinds of rendering,

00:02:06.836 --> 00:02:08.846 A:middle
SpriteKit for 2D games, SceneKit

00:02:08.846 --> 00:02:10.756 A:middle
for some 3D, Core Image for

00:02:10.756 --> 00:02:11.966 A:middle
great effects.

00:02:13.526 --> 00:02:15.456 A:middle
Also, each of the major

00:02:15.566 --> 00:02:17.366 A:middle
third-party game engines already

00:02:17.366 --> 00:02:19.176 A:middle
use Metal as their primary

00:02:19.176 --> 00:02:19.596 A:middle
renderer.

00:02:20.776 --> 00:02:22.886 A:middle
But you may decide that these

00:02:22.886 --> 00:02:24.426 A:middle
approaches just aren't for you

00:02:24.756 --> 00:02:25.866 A:middle
and the path forward is to do it

00:02:25.866 --> 00:02:28.086 A:middle
yourself in Metal, that's what

00:02:28.086 --> 00:02:30.416 A:middle
we'll talk about today.

00:02:30.566 --> 00:02:31.746 A:middle
So let's start out with Metal

00:02:31.746 --> 00:02:33.416 A:middle
design and some fundamental

00:02:33.416 --> 00:02:33.966 A:middle
concepts.

00:02:35.536 --> 00:02:37.246 A:middle
So OpenGL was originally

00:02:37.246 --> 00:02:39.326 A:middle
designed 25 years ago and its

00:02:39.366 --> 00:02:41.286 A:middle
core reflects the origins of

00:02:41.286 --> 00:02:42.736 A:middle
hardware accelerated 3D

00:02:42.736 --> 00:02:43.226 A:middle
graphics.

00:02:44.696 --> 00:02:46.676 A:middle
So updates with new versions and

00:02:46.676 --> 00:02:48.266 A:middle
extensions have really served us

00:02:48.266 --> 00:02:49.766 A:middle
well by exposing new GPU

00:02:49.836 --> 00:02:51.146 A:middle
features and performance

00:02:51.146 --> 00:02:51.666 A:middle
techniques.

00:02:52.806 --> 00:02:54.436 A:middle
However, there are still some

00:02:54.436 --> 00:02:56.276 A:middle
fundamental design choices that

00:02:56.276 --> 00:02:58.016 A:middle
no longer apply to current

00:02:58.016 --> 00:02:58.396 A:middle
hardware.


00:03:00.856 --> 00:03:02.326 A:middle
The OpenGL pipeline was

00:03:02.326 --> 00:03:03.826 A:middle
originally an entirely fixed

00:03:03.826 --> 00:03:05.746 A:middle
function and although today

00:03:05.746 --> 00:03:07.526 A:middle
OpenGL supports a programmable

00:03:07.526 --> 00:03:09.726 A:middle
pipeline it doesn't neatly match

00:03:09.786 --> 00:03:12.826 A:middle
that of modern GPUs.

00:03:13.036 --> 00:03:15.356 A:middle
Also, asynchronous processing is

00:03:15.356 --> 00:03:16.726 A:middle
not a core feature of the API,

00:03:17.476 --> 00:03:18.436 A:middle
there are a number of features

00:03:18.436 --> 00:03:19.576 A:middle
which allude to the fact that

00:03:19.576 --> 00:03:20.656 A:middle
the GPU works in parallel with

00:03:20.656 --> 00:03:22.076 A:middle
your app but much of this is

00:03:22.076 --> 00:03:22.586 A:middle
implicit.

00:03:23.046 --> 00:03:26.586 A:middle
And 25 years ago only the most

00:03:26.586 --> 00:03:27.766 A:middle
expensive workstations and

00:03:27.766 --> 00:03:29.186 A:middle
servers had multiple cores.

00:03:29.676 --> 00:03:30.956 A:middle
So designing an efficient

00:03:30.956 --> 00:03:32.716 A:middle
multithreading model wasn't a

00:03:32.716 --> 00:03:33.216 A:middle
priority.

00:03:33.216 --> 00:03:37.516 A:middle
So back in 2014, it was clear to

00:03:37.516 --> 00:03:39.116 A:middle
us that a new application

00:03:39.116 --> 00:03:40.286 A:middle
interface for the GPU was

00:03:40.286 --> 00:03:40.836 A:middle
necessary.

00:03:41.696 --> 00:03:42.856 A:middle
Obviously, we needed an

00:03:42.856 --> 00:03:44.176 A:middle
interface that could efficiently

00:03:44.176 --> 00:03:45.406 A:middle
harness the GPU's power.

00:03:46.576 --> 00:03:48.076 A:middle
To do that the app needed the

00:03:48.076 --> 00:03:49.826 A:middle
CPU out of the way so the GPU

00:03:49.826 --> 00:03:51.946 A:middle
could do its thing.

00:03:52.146 --> 00:03:53.836 A:middle
But when an app needs the CPU

00:03:53.836 --> 00:03:54.976 A:middle
for rendering it needs to be

00:03:54.976 --> 00:03:56.466 A:middle
able to use all of the CPU,

00:03:56.906 --> 00:03:58.176 A:middle
including its multiple cores.

00:03:59.626 --> 00:04:01.146 A:middle
If the interface needed to be


00:03:59.626 --> 00:04:01.146 A:middle
If the interface needed to be

00:04:01.146 --> 00:04:02.416 A:middle
predictable to prevent

00:04:02.716 --> 00:04:04.056 A:middle
developers from falling into

00:04:04.136 --> 00:04:08.586 A:middle
hidden pitfalls in the API every

00:04:08.586 --> 00:04:09.926 A:middle
call should have an obvious

00:04:09.926 --> 00:04:12.146 A:middle
consequence and few operations

00:04:12.206 --> 00:04:13.846 A:middle
should be performed implicitly.

00:04:14.336 --> 00:04:16.476 A:middle
Part of this predictability

00:04:16.576 --> 00:04:17.805 A:middle
would be the need to control

00:04:17.805 --> 00:04:19.916 A:middle
where resources were placed and

00:04:19.956 --> 00:04:21.826 A:middle
if and when synchronization was

00:04:21.826 --> 00:04:22.376 A:middle
necessary.

00:04:22.966 --> 00:04:26.156 A:middle
Now Apple had a few other

00:04:26.156 --> 00:04:26.686 A:middle
requirements.

00:04:27.896 --> 00:04:29.456 A:middle
We wanted this interface to be

00:04:29.456 --> 00:04:31.416 A:middle
approachable, it needed to have

00:04:31.416 --> 00:04:32.536 A:middle
the right balance between

00:04:32.536 --> 00:04:34.306 A:middle
low-level control and clear

00:04:34.306 --> 00:04:36.436 A:middle
usage because the easier it is

00:04:36.436 --> 00:04:37.556 A:middle
for you to understand something

00:04:37.876 --> 00:04:39.156 A:middle
the more effectively and

00:04:39.206 --> 00:04:40.566 A:middle
efficiently you can use it.

00:04:41.976 --> 00:04:43.766 A:middle
And of course, we designed Metal

00:04:43.766 --> 00:04:46.516 A:middle
to map well to all modern GPUs.

00:04:46.516 --> 00:04:49.486 A:middle
In particular, we knew that

00:04:49.486 --> 00:04:50.446 A:middle
hardware coming down the

00:04:50.496 --> 00:04:52.666 A:middle
pipeline needed software that

00:04:52.666 --> 00:04:53.216 A:middle
could push it.

00:04:53.906 --> 00:04:55.556 A:middle
This included the Apple designed

00:04:55.696 --> 00:04:58.486 A:middle
GPU of the A11 bionic.

00:04:59.956 --> 00:05:01.326 A:middle
So how is Metal different than


00:04:59.956 --> 00:05:01.326 A:middle
So how is Metal different than

00:05:01.326 --> 00:05:01.736 A:middle
OpenGL?

00:05:02.196 --> 00:05:03.556 A:middle
Well you perform the most

00:05:03.626 --> 00:05:06.036 A:middle
expensive operations less often.

00:05:07.046 --> 00:05:08.236 A:middle
Objects are designed in such a

00:05:08.236 --> 00:05:09.916 A:middle
way that API state can be

00:05:09.916 --> 00:05:12.226 A:middle
translated and prepackaged into

00:05:12.226 --> 00:05:13.926 A:middle
GPU commands at creation.

00:05:15.726 --> 00:05:17.406 A:middle
This way, there's much less cost

00:05:17.406 --> 00:05:18.556 A:middle
to use them later on when

00:05:18.556 --> 00:05:19.266 A:middle
actually rendering.

00:05:20.576 --> 00:05:21.656 A:middle
The graphics pipeline with

00:05:21.686 --> 00:05:23.286 A:middle
Vertex and fragment shaders also

00:05:23.286 --> 00:05:24.756 A:middle
reflects the modern GPU.

00:05:25.716 --> 00:05:27.396 A:middle
So it's less costly to translate

00:05:27.516 --> 00:05:29.526 A:middle
the API's configuration to GP

00:05:29.526 --> 00:05:29.986 A:middle
commands.

00:05:31.236 --> 00:05:32.926 A:middle
This doesn't mean the pipeline

00:05:32.926 --> 00:05:34.296 A:middle
is entirely different or

00:05:34.296 --> 00:05:35.666 A:middle
requires some whole new way of

00:05:35.666 --> 00:05:36.026 A:middle
thinking.

00:05:36.946 --> 00:05:38.256 A:middle
The main difference in Metal is

00:05:38.256 --> 00:05:39.406 A:middle
that the grouping of the

00:05:39.436 --> 00:05:41.686 A:middle
pipeline stages into objects is

00:05:41.686 --> 00:05:43.326 A:middle
more efficient, not that the

00:05:43.326 --> 00:05:45.396 A:middle
pipeline itself is changed.

00:05:46.816 --> 00:05:49.366 A:middle
Metal also has a clear model for

00:05:49.366 --> 00:05:50.616 A:middle
multithreaded execution.

00:05:51.496 --> 00:05:52.356 A:middle
There are a number of different

00:05:52.356 --> 00:05:53.976 A:middle
ways for applications to drive

00:05:53.976 --> 00:05:55.796 A:middle
the GPU from different threads,

00:05:56.286 --> 00:05:57.906 A:middle
but for each there are explicit

00:05:57.996 --> 00:05:59.456 A:middle
but unconstraining rules to do

00:05:59.456 --> 00:05:59.686 A:middle
this.


00:06:01.036 --> 00:06:02.546 A:middle
Additionally, the most commonly

00:06:02.546 --> 00:06:03.836 A:middle
used objects like textures,

00:06:03.936 --> 00:06:05.936 A:middle
buffers and shaders can safely

00:06:05.936 --> 00:06:07.346 A:middle
and efficiently be used across

00:06:07.406 --> 00:06:07.726 A:middle
threads.

00:06:08.526 --> 00:06:10.156 A:middle
Metal does not need to perform

00:06:10.326 --> 00:06:11.776 A:middle
any expensive internal logging

00:06:11.776 --> 00:06:13.306 A:middle
operations to prevent these

00:06:13.306 --> 00:06:14.546 A:middle
objects from getting into some

00:06:14.546 --> 00:06:15.456 A:middle
invalid state.

00:06:17.516 --> 00:06:19.616 A:middle
Finally, the execution model

00:06:19.616 --> 00:06:21.036 A:middle
reflects what really goes on

00:06:21.076 --> 00:06:22.696 A:middle
between software and the GPU.

00:06:23.266 --> 00:06:24.926 A:middle
Many of the implicit operations

00:06:25.046 --> 00:06:26.406 A:middle
performed by OpenGL are

00:06:26.406 --> 00:06:28.116 A:middle
explicitly performed by an

00:06:28.116 --> 00:06:29.886 A:middle
application using Metal.

00:06:30.636 --> 00:06:31.836 A:middle
This allows you to make

00:06:31.836 --> 00:06:33.666 A:middle
intelligent decisions as to when

00:06:33.666 --> 00:06:35.966 A:middle
and how your app uses the GPU.

00:06:36.946 --> 00:06:37.966 A:middle
It also means there's less

00:06:37.966 --> 00:06:39.036 A:middle
software between your

00:06:39.036 --> 00:06:40.586 A:middle
application and the GPU.

00:06:41.216 --> 00:06:43.286 A:middle
Most Metal calls go directly to

00:06:43.286 --> 00:06:45.096 A:middle
the GPU driver and that driver

00:06:45.096 --> 00:06:46.726 A:middle
also needs to do less processing

00:06:46.726 --> 00:06:48.746 A:middle
to translate from API calls to

00:06:48.746 --> 00:06:49.526 A:middle
GPU commands.

00:06:51.216 --> 00:06:52.216 A:middle
So let's dive in and see how

00:06:52.216 --> 00:06:52.636 A:middle
this works.

00:06:53.256 --> 00:06:56.466 A:middle
All GL calls are performed on an

00:06:56.466 --> 00:06:57.506 A:middle
OpenGL context.

00:06:57.916 --> 00:06:59.846 A:middle
The context does a ton of

00:06:59.846 --> 00:07:01.966 A:middle
things, it tracks API state, it


00:06:59.846 --> 00:07:01.966 A:middle
things, it tracks API state, it

00:07:02.166 --> 00:07:03.766 A:middle
manages OpenGL objects and other

00:07:03.766 --> 00:07:05.246 A:middle
memory, and translates and

00:07:05.246 --> 00:07:06.506 A:middle
submits GPU commands.

00:07:07.366 --> 00:07:09.066 A:middle
Metal splits all of these jobs

00:07:09.066 --> 00:07:10.626 A:middle
of an OpenGL context into a

00:07:10.626 --> 00:07:12.956 A:middle
number of smaller objects.

00:07:14.056 --> 00:07:16.336 A:middle
The first object that creates is

00:07:16.336 --> 00:07:18.616 A:middle
a Metal device which is an

00:07:18.716 --> 00:07:20.626 A:middle
abstract representation of a

00:07:20.776 --> 00:07:21.686 A:middle
physical GPU.

00:07:22.256 --> 00:07:26.286 A:middle
The device creates objects such

00:07:26.286 --> 00:07:27.646 A:middle
as textures, buffers and

00:07:27.646 --> 00:07:29.216 A:middle
pipeline objects which contain

00:07:29.216 --> 00:07:29.906 A:middle
shaders.

00:07:31.026 --> 00:07:32.886 A:middle
It also creates a key object

00:07:33.136 --> 00:07:34.636 A:middle
called a Metal command queue.

00:07:35.196 --> 00:07:37.816 A:middle
The command queue really only

00:07:37.816 --> 00:07:39.796 A:middle
has one job, to create a

00:07:39.796 --> 00:07:41.176 A:middle
sequence of command buffers.

00:07:41.956 --> 00:07:43.506 A:middle
Here we've created one command

00:07:43.506 --> 00:07:44.856 A:middle
buffer and a command buffer is

00:07:44.856 --> 00:07:46.706 A:middle
simply a list of GPU commands

00:07:46.956 --> 00:07:48.956 A:middle
that your app will fill and send

00:07:48.956 --> 00:07:50.146 A:middle
to the GPU for execution.

00:07:51.166 --> 00:07:52.836 A:middle
Typically your app will create a

00:07:52.836 --> 00:07:54.926 A:middle
single command buffer per frame,

00:07:55.016 --> 00:07:55.866 A:middle
however, there are some

00:07:55.866 --> 00:07:57.566 A:middle
situations where it makes sense

00:07:57.696 --> 00:08:00.166 A:middle
to create two or three in a


00:07:57.696 --> 00:08:00.166 A:middle
to create two or three in a

00:08:00.696 --> 00:08:00.886 A:middle
frame.

00:08:01.026 --> 00:08:02.256 A:middle
But an app doesn't write these

00:08:02.256 --> 00:08:03.606 A:middle
commands directly to the command

00:08:03.606 --> 00:08:05.216 A:middle
buffer, instead it creates a

00:08:05.216 --> 00:08:06.586 A:middle
Metal command encoder.

00:08:07.886 --> 00:08:09.356 A:middle
The command encoder translates

00:08:09.446 --> 00:08:11.686 A:middle
API calls into GPU instructions

00:08:11.906 --> 00:08:13.006 A:middle
and writes them to the command

00:08:13.006 --> 00:08:13.266 A:middle
buffer.

00:08:14.336 --> 00:08:15.666 A:middle
After a series of commands have

00:08:15.666 --> 00:08:17.426 A:middle
been encoded your app will end

00:08:17.426 --> 00:08:18.916 A:middle
encoding and release the encoder

00:08:18.916 --> 00:08:19.336 A:middle
object.

00:08:20.536 --> 00:08:21.586 A:middle
There are actually a couple

00:08:21.586 --> 00:08:22.756 A:middle
different kind of encoders and

00:08:22.756 --> 00:08:24.146 A:middle
your app can create new encoders

00:08:24.146 --> 00:08:25.106 A:middle
from the command buffer to

00:08:25.146 --> 00:08:25.876 A:middle
encode more commands.

00:08:31.156 --> 00:08:32.616 A:middle
Now it's important to note that

00:08:32.616 --> 00:08:34.346 A:middle
up until now on this diagram the

00:08:34.346 --> 00:08:36.186 A:middle
GPU hasn't done any work.

00:08:37.106 --> 00:08:38.666 A:middle
Metal has created objects and

00:08:38.666 --> 00:08:40.726 A:middle
encoded commands all with the

00:08:40.775 --> 00:08:41.145 A:middle
CPU.

00:08:41.876 --> 00:08:43.166 A:middle
It's only after your app has

00:08:43.216 --> 00:08:45.356 A:middle
finished encoding commands and

00:08:45.356 --> 00:08:46.356 A:middle
committed the command buffer

00:08:47.446 --> 00:08:49.226 A:middle
that the GPU begins to work and

00:08:49.226 --> 00:08:51.376 A:middle
executes those commands.

00:08:52.576 --> 00:08:54.566 A:middle
You can also encode commands to

00:08:54.566 --> 00:08:56.226 A:middle
multiple command buffers in

00:08:56.266 --> 00:08:57.816 A:middle
parallel on separate threads.

00:08:58.466 --> 00:09:02.056 A:middle
Now I've already spoken about


00:08:58.466 --> 00:09:02.056 A:middle
Now I've already spoken about

00:09:02.056 --> 00:09:03.876 A:middle
how the command queue produces a

00:09:03.876 --> 00:09:06.276 A:middle
sequence of command buffers and

00:09:06.276 --> 00:09:07.606 A:middle
that you create a command

00:09:07.606 --> 00:09:09.286 A:middle
encoder from a command buffer.

00:09:10.196 --> 00:09:11.216 A:middle
Let's take a closer look at

00:09:11.216 --> 00:09:13.096 A:middle
these encoder objects used to

00:09:13.096 --> 00:09:14.466 A:middle
write to our command buffers.

00:09:15.726 --> 00:09:17.036 A:middle
There are three main types.

00:09:18.096 --> 00:09:18.986 A:middle
There's the Render Command

00:09:18.986 --> 00:09:20.606 A:middle
Encoder whose commands resemble

00:09:20.606 --> 00:09:22.266 A:middle
that of an OpenGL command string

00:09:22.356 --> 00:09:23.776 A:middle
where you set state, bind

00:09:23.776 --> 00:09:25.316 A:middle
objects, and issue draw calls.

00:09:26.446 --> 00:09:27.736 A:middle
There's the Blit Command Encoder

00:09:27.906 --> 00:09:29.306 A:middle
with which you can issue texture

00:09:29.306 --> 00:09:31.246 A:middle
and buffer copy operations.

00:09:31.576 --> 00:09:32.786 A:middle
You can also use it to generate

00:09:32.786 --> 00:09:34.526 A:middle
Mipmap for textures and transfer

00:09:34.566 --> 00:09:36.156 A:middle
pixel data from buffers similar

00:09:36.156 --> 00:09:38.076 A:middle
to how glReadPixels operates

00:09:38.076 --> 00:09:39.656 A:middle
with OpenGL's pixel buffer

00:09:39.656 --> 00:09:40.266 A:middle
objects.

00:09:40.806 --> 00:09:43.496 A:middle
And then there's the Compute

00:09:43.756 --> 00:09:46.076 A:middle
Command Encoder which allows you

00:09:46.076 --> 00:09:48.466 A:middle
to dispatch commute kernels.

00:09:49.316 --> 00:09:50.826 A:middle
The Render Command Encoder is

00:09:50.826 --> 00:09:51.746 A:middle
probably the encoder you'll

00:09:51.746 --> 00:09:53.356 A:middle
become most familiar with as

00:09:53.356 --> 00:09:54.346 A:middle
it's responsible for the

00:09:54.346 --> 00:09:56.206 A:middle
majority of operations that a

00:09:56.206 --> 00:09:57.976 A:middle
graphic centric app needs.

00:09:59.306 --> 00:10:00.816 A:middle
The set of commands encoded into


00:09:59.306 --> 00:10:00.816 A:middle
The set of commands encoded into

00:10:00.816 --> 00:10:01.966 A:middle
a Render Command Encoder is

00:10:02.006 --> 00:10:03.686 A:middle
often referred to as a Render

00:10:03.686 --> 00:10:03.836 A:middle
Pass.

00:10:05.406 --> 00:10:06.576 A:middle
In a Render Pass you set up

00:10:06.576 --> 00:10:08.016 A:middle
render objects for the graphics

00:10:08.016 --> 00:10:10.236 A:middle
pipeline and issue draw commands

00:10:10.676 --> 00:10:11.586 A:middle
with those objects.

00:10:12.226 --> 00:10:13.726 A:middle
This includes operations similar

00:10:13.726 --> 00:10:15.946 A:middle
to glDrawArrays and

00:10:15.946 --> 00:10:18.696 A:middle
glDrawElements and other OpenGL

00:10:18.816 --> 00:10:19.566 A:middle
draw commands.

00:10:21.006 --> 00:10:22.416 A:middle
Each Render Command Encoder is

00:10:22.416 --> 00:10:24.156 A:middle
strongly associated with a set

00:10:24.306 --> 00:10:25.126 A:middle
of render targets.

00:10:26.976 --> 00:10:28.806 A:middle
And the render target is simply

00:10:28.806 --> 00:10:30.306 A:middle
a texture that can be drawn to.

00:10:30.846 --> 00:10:32.636 A:middle
This includes color, depth and

00:10:32.666 --> 00:10:34.166 A:middle
stencil textures, as well as

00:10:34.166 --> 00:10:35.356 A:middle
multi-sample textures.

00:10:36.436 --> 00:10:37.606 A:middle
You specify a set of render

00:10:37.606 --> 00:10:38.976 A:middle
targets when you create a render

00:10:38.976 --> 00:10:40.686 A:middle
command encoder from a command

00:10:42.196 --> 00:10:42.336 A:middle
buffer.

00:10:42.516 --> 00:10:43.906 A:middle
And all draw commands are

00:10:43.906 --> 00:10:45.596 A:middle
directed to these targets for

00:10:45.596 --> 00:10:47.036 A:middle
the lifetime of the encoder.

00:10:48.506 --> 00:10:49.826 A:middle
To direct commands to a new set

00:10:49.826 --> 00:10:51.396 A:middle
of targets you end encoding with

00:10:51.396 --> 00:10:52.886 A:middle
a current render command encoder

00:10:53.116 --> 00:10:55.536 A:middle
and create a new encoder with

00:10:55.536 --> 00:10:56.256 A:middle
new targets.

00:10:57.216 --> 00:10:58.836 A:middle
This creates a very clear

00:10:58.836 --> 00:11:01.076 A:middle
delineation between commands


00:10:58.836 --> 00:11:01.076 A:middle
delineation between commands

00:11:01.126 --> 00:11:02.916 A:middle
directed to different sets of

00:11:02.916 --> 00:11:03.506 A:middle
render targets.

00:11:04.186 --> 00:11:06.196 A:middle
Let's talk a little bit about

00:11:06.506 --> 00:11:07.896 A:middle
the object you'll use for

00:11:07.896 --> 00:11:08.256 A:middle
rendering.

00:11:09.446 --> 00:11:10.476 A:middle
Metal has a number of similar

00:11:10.476 --> 00:11:11.276 A:middle
objects to OpenGL.

00:11:11.276 --> 00:11:14.346 A:middle
There are textures, buffers,

00:11:15.136 --> 00:11:17.846 A:middle
samplers and pipeline state

00:11:17.846 --> 00:11:19.666 A:middle
objects which resemble OpenGL's

00:11:19.696 --> 00:11:22.086 A:middle
program objects, and also depth

00:11:22.206 --> 00:11:23.766 A:middle
stencil state objects which

00:11:23.766 --> 00:11:24.966 A:middle
don't really exists in OpenGL

00:11:25.176 --> 00:11:26.706 A:middle
but are just the containers for

00:11:26.706 --> 00:11:28.156 A:middle
the same depth and stencil state

00:11:28.396 --> 00:11:29.346 A:middle
that OpenGL's got.

00:11:31.496 --> 00:11:32.996 A:middle
One significant difference

00:11:33.076 --> 00:11:35.556 A:middle
between OpenGL and Metal objects

00:11:35.906 --> 00:11:37.616 A:middle
are how they are created and

00:11:37.616 --> 00:11:37.866 A:middle
managed.

00:11:39.176 --> 00:11:40.336 A:middle
The objects are all created from

00:11:40.336 --> 00:11:41.756 A:middle
a device object so they're

00:11:41.756 --> 00:11:43.426 A:middle
associated with a single GPU.

00:11:44.716 --> 00:11:46.156 A:middle
You set most of an object state

00:11:46.276 --> 00:11:48.316 A:middle
when you create it by specifying

00:11:48.646 --> 00:11:50.186 A:middle
properties in a descriptor

00:11:50.186 --> 00:11:50.656 A:middle
object.

00:11:51.936 --> 00:11:53.656 A:middle
All states set when the object

00:11:53.656 --> 00:11:55.166 A:middle
is created is fixed and

00:11:55.166 --> 00:11:55.596 A:middle
immutable.

00:11:56.946 --> 00:11:58.306 A:middle
Although the state of textures

00:11:58.306 --> 00:11:59.856 A:middle
and buffers are fixed upon

00:11:59.856 --> 00:12:02.226 A:middle
creation, data contained by


00:11:59.856 --> 00:12:02.226 A:middle
creation, data contained by

00:12:02.226 --> 00:12:03.976 A:middle
these objects can be changed.

00:12:04.626 --> 00:12:07.296 A:middle
Metal can do all the expensive

00:12:07.446 --> 00:12:09.016 A:middle
setup for an object once when

00:12:09.016 --> 00:12:09.596 A:middle
it's created.

00:12:10.396 --> 00:12:12.146 A:middle
OpenGL's mutable model makes it

00:12:12.176 --> 00:12:13.766 A:middle
completely possible that if your

00:12:13.766 --> 00:12:15.186 A:middle
app touches a little piece of

00:12:15.186 --> 00:12:18.176 A:middle
state the recompilation of that

00:12:18.176 --> 00:12:19.206 A:middle
object may occur.

00:12:19.946 --> 00:12:21.256 A:middle
And even if your app doesn't

00:12:21.256 --> 00:12:23.846 A:middle
change an object state OpenGL

00:12:23.846 --> 00:12:25.176 A:middle
needs to check a hierarchy of

00:12:25.226 --> 00:12:26.856 A:middle
flags to confirm this before

00:12:26.856 --> 00:12:27.326 A:middle
drawing.

00:12:28.186 --> 00:12:30.596 A:middle
So with this immutable model

00:12:30.596 --> 00:12:32.176 A:middle
Metal never needs to check for

00:12:32.176 --> 00:12:34.106 A:middle
object state changes make draw

00:12:34.106 --> 00:12:36.016 A:middle
calls much faster.

00:12:37.556 --> 00:12:39.166 A:middle
Additionally, objects can be

00:12:39.256 --> 00:12:41.106 A:middle
efficiently used across threads,

00:12:41.516 --> 00:12:42.756 A:middle
Metal never needs to lock an

00:12:42.756 --> 00:12:43.746 A:middle
object to prevent it from

00:12:43.746 --> 00:12:44.996 A:middle
getting into an invalid state

00:12:45.146 --> 00:12:45.956 A:middle
from a change on another thread.

00:12:51.306 --> 00:12:52.826 A:middle
So let's talk about porting.

00:12:52.826 --> 00:12:57.256 A:middle
Here is the typical phase, here

00:12:57.256 --> 00:12:59.286 A:middle
are typical phases of a

00:12:59.286 --> 00:13:00.226 A:middle
rendering application.


00:12:59.286 --> 00:13:00.226 A:middle
rendering application.

00:13:01.046 --> 00:13:02.166 A:middle
You build the app compiling

00:13:02.166 --> 00:13:03.746 A:middle
source and bundling your assets.

00:13:04.696 --> 00:13:05.926 A:middle
Start up and initializing it.

00:13:06.306 --> 00:13:07.796 A:middle
Loading the assets and

00:13:07.796 --> 00:13:09.666 A:middle
initializing objects that will

00:13:09.666 --> 00:13:11.386 A:middle
persist for the lifetime of your

00:13:11.386 --> 00:13:11.986 A:middle
application.

00:13:13.236 --> 00:13:14.966 A:middle
And you repeatedly render

00:13:15.456 --> 00:13:16.976 A:middle
setting up state, issuing many

00:13:16.976 --> 00:13:19.336 A:middle
draw calls, and presenting frame

00:13:19.486 --> 00:13:19.986 A:middle
after frame.

00:13:20.676 --> 00:13:23.816 A:middle
I'll talk about developing for

00:13:23.816 --> 00:13:25.686 A:middle
Metal in the earlier stages of

00:13:25.686 --> 00:13:26.796 A:middle
the application's lifetime,

00:13:28.316 --> 00:13:29.806 A:middle
including building shaders

00:13:29.806 --> 00:13:31.176 A:middle
offline and creating object's

00:13:31.176 --> 00:13:32.136 A:middle
initialization.

00:13:33.256 --> 00:13:34.666 A:middle
And Sukanya will describe how to

00:13:34.666 --> 00:13:36.396 A:middle
port your per frame rendering

00:13:36.396 --> 00:13:36.656 A:middle
code.

00:13:38.676 --> 00:13:39.936 A:middle
So let's start out with

00:13:39.936 --> 00:13:41.706 A:middle
application build time which is

00:13:41.706 --> 00:13:43.166 A:middle
where shaders are typically

00:13:43.226 --> 00:13:43.736 A:middle
compiled.

00:13:44.896 --> 00:13:46.246 A:middle
We'll begin with a look at the

00:13:46.246 --> 00:13:47.006 A:middle
shading language.

00:13:47.866 --> 00:13:49.006 A:middle
The Metal shading language is

00:13:49.126 --> 00:13:50.476 A:middle
based on C++.

00:13:50.936 --> 00:13:53.316 A:middle
So just like C++ you can create

00:13:53.386 --> 00:13:55.206 A:middle
classes, templates, structures,

00:13:55.606 --> 00:13:57.336 A:middle
define enums and namespaces.

00:13:58.466 --> 00:14:00.156 A:middle
Like GLSL there are built-in


00:13:58.466 --> 00:14:00.156 A:middle
Like GLSL there are built-in

00:14:00.156 --> 00:14:02.796 A:middle
vector and matrix types, and

00:14:02.796 --> 00:14:04.176 A:middle
numerous built-in functions and

00:14:04.176 --> 00:14:05.856 A:middle
operators commonly used for

00:14:05.856 --> 00:14:06.436 A:middle
graphics.

00:14:06.486 --> 00:14:09.236 A:middle
And there are classes to specify

00:14:09.316 --> 00:14:11.006 A:middle
sampler state and operate on

00:14:11.006 --> 00:14:11.426 A:middle
textures.

00:14:12.966 --> 00:14:13.986 A:middle
The best way to describe the

00:14:13.986 --> 00:14:15.166 A:middle
language is just to show you.

00:14:15.396 --> 00:14:17.166 A:middle
So here is a vertex and fragment

00:14:17.166 --> 00:14:17.846 A:middle
shader pair.

00:14:19.336 --> 00:14:20.966 A:middle
The vertex keyword at the

00:14:20.966 --> 00:14:22.516 A:middle
function at the top specifies

00:14:22.586 --> 00:14:24.196 A:middle
that that function is a vertex

00:14:24.196 --> 00:14:25.886 A:middle
shader, likewise for the

00:14:25.886 --> 00:14:27.496 A:middle
fragment keyword for the

00:14:27.496 --> 00:14:28.306 A:middle
function at the bottom.

00:14:29.706 --> 00:14:31.366 A:middle
Note that they have custom names

00:14:31.426 --> 00:14:33.226 A:middle
unlike GLSL where every shader

00:14:33.266 --> 00:14:34.116 A:middle
is just called main.

00:14:34.756 --> 00:14:35.726 A:middle
This is important because it

00:14:35.726 --> 00:14:37.166 A:middle
allows you to build large

00:14:37.166 --> 00:14:38.976 A:middle
libraries of unique shaders

00:14:39.206 --> 00:14:40.966 A:middle
using names to indicate what

00:14:41.026 --> 00:14:41.506 A:middle
they do.

00:14:41.936 --> 00:14:44.446 A:middle
Anything passed from your

00:14:44.446 --> 00:14:46.176 A:middle
application is an argument to

00:14:46.176 --> 00:14:47.266 A:middle
one of these shaders.

00:14:48.026 --> 00:14:49.316 A:middle
There aren't any loose variables

00:14:49.316 --> 00:14:50.486 A:middle
outside of functions as there

00:14:50.486 --> 00:14:51.416 A:middle
are with GLSL.

00:14:52.486 --> 00:14:53.786 A:middle
As you can see, there are these

00:14:53.846 --> 00:14:55.216 A:middle
bracketed symbols next to each

00:14:55.216 --> 00:14:55.646 A:middle
parameter.

00:14:56.226 --> 00:14:58.136 A:middle
These are attribute specifiers

00:14:58.386 --> 00:14:59.946 A:middle
which extend upon the C++

00:14:59.946 --> 00:15:01.656 A:middle
language to indicate special


00:14:59.946 --> 00:15:01.656 A:middle
language to indicate special

00:15:01.656 --> 00:15:02.236 A:middle
variables.

00:15:03.456 --> 00:15:05.666 A:middle
So this vertex ID attribute

00:15:05.746 --> 00:15:07.446 A:middle
indicates that this VID

00:15:07.446 --> 00:15:08.576 A:middle
parameter should contain the

00:15:08.666 --> 00:15:11.126 A:middle
index of the current vertex when

00:15:11.126 --> 00:15:12.826 A:middle
this vertex executes.

00:15:13.196 --> 00:15:14.906 A:middle
It's used down here in two

00:15:14.906 --> 00:15:17.166 A:middle
places to index into an array of

00:15:17.166 --> 00:15:17.676 A:middle
vertices.

00:15:18.226 --> 00:15:20.636 A:middle
These parameters here with a

00:15:20.636 --> 00:15:22.866 A:middle
buffer attribute specifier these

00:15:22.866 --> 00:15:24.186 A:middle
indicate that these variables

00:15:24.226 --> 00:15:26.106 A:middle
are filled by buffer's objects

00:15:26.246 --> 00:15:27.436 A:middle
set in the Metal API.

00:15:27.436 --> 00:15:29.596 A:middle
I'll talk more about how the

00:15:29.596 --> 00:15:31.106 A:middle
Metal API relates to these in

00:15:31.106 --> 00:15:31.596 A:middle
just a minute.

00:15:32.266 --> 00:15:33.626 A:middle
But first let's take a closer

00:15:33.626 --> 00:15:34.926 A:middle
look at some of the types used

00:15:34.926 --> 00:15:35.136 A:middle
here.

00:15:36.056 --> 00:15:37.776 A:middle
Now these are all custom types

00:15:38.366 --> 00:15:39.386 A:middle
that you would define.

00:15:40.406 --> 00:15:41.656 A:middle
The vertices parameter here is

00:15:41.656 --> 00:15:43.606 A:middle
defined as a pointer to a vertex

00:15:43.606 --> 00:15:45.656 A:middle
type and its definition is right

00:15:45.656 --> 00:15:45.886 A:middle
here.

00:15:46.706 --> 00:15:48.836 A:middle
The structure has two members, a

00:15:48.836 --> 00:15:50.586 A:middle
model position member and a

00:15:50.586 --> 00:15:51.736 A:middle
texture coordinate member.

00:15:52.446 --> 00:15:54.116 A:middle
It defines the layout and memory

00:15:54.146 --> 00:15:56.186 A:middle
of each vertex in a vertex array

00:15:56.526 --> 00:15:58.096 A:middle
passed into this vertex shader.

00:15:59.836 --> 00:16:01.336 A:middle
Let's look at this vertex output


00:15:59.836 --> 00:16:01.336 A:middle
Let's look at this vertex output

00:16:01.336 --> 00:16:02.946 A:middle
type returned by our vertex

00:16:02.946 --> 00:16:03.186 A:middle
shader.

00:16:03.776 --> 00:16:06.506 A:middle
Its definition here specifies

00:16:06.506 --> 00:16:07.736 A:middle
what's passed down for the

00:16:07.736 --> 00:16:09.186 A:middle
rasterization stage and

00:16:09.186 --> 00:16:10.466 A:middle
eventually to the fragment

00:16:10.466 --> 00:16:10.806 A:middle
program.

00:16:11.336 --> 00:16:13.756 A:middle
The four-component

00:16:13.756 --> 00:16:15.146 A:middle
floating-point member named

00:16:15.186 --> 00:16:17.396 A:middle
clipPos has this position

00:16:17.396 --> 00:16:18.766 A:middle
attribute specifier next to it.

00:16:19.336 --> 00:16:20.756 A:middle
This indicates that this member

00:16:20.756 --> 00:16:22.096 A:middle
will serve as the output

00:16:22.136 --> 00:16:23.746 A:middle
position of our vertex shader.

00:16:25.116 --> 00:16:26.376 A:middle
This texCoord member which

00:16:26.376 --> 00:16:27.326 A:middle
doesn't have an attribute

00:16:27.326 --> 00:16:30.096 A:middle
specifier defaults to a variable

00:16:30.306 --> 00:16:31.656 A:middle
that will be interpolated with

00:16:31.656 --> 00:16:34.986 A:middle
the texture coordinate values of

00:16:34.986 --> 00:16:36.726 A:middle
other vertices defining the

00:16:36.726 --> 00:16:38.616 A:middle
rasterized triangle much like a

00:16:38.616 --> 00:16:39.986 A:middle
varying in GLSL.

00:16:41.616 --> 00:16:42.616 A:middle
Let's take a look at some of the

00:16:42.616 --> 00:16:43.786 A:middle
parameters of our fragment

00:16:43.786 --> 00:16:44.046 A:middle
shader.

00:16:45.146 --> 00:16:46.796 A:middle
So we're using this vertexOutput

00:16:46.796 --> 00:16:48.966 A:middle
struct that we just looked at

00:16:49.406 --> 00:16:50.846 A:middle
down here as an input to our

00:16:51.076 --> 00:16:51.716 A:middle
fragment shader.

00:16:52.336 --> 00:16:53.966 A:middle
And it gives us the interpolated

00:16:54.006 --> 00:16:55.446 A:middle
texture coordinate that we

00:16:55.716 --> 00:16:57.346 A:middle
constructed in the vertex shader

00:16:58.486 --> 00:17:00.206 A:middle
and we use it here to sample


00:16:58.486 --> 00:17:00.206 A:middle
and we use it here to sample

00:17:00.366 --> 00:17:02.966 A:middle
from a texture.

00:17:03.086 --> 00:17:04.586 A:middle
In our application code which is

00:17:04.586 --> 00:17:06.486 A:middle
written in Objective-C we use a

00:17:06.486 --> 00:17:08.316 A:middle
Render Command Encoder to map

00:17:08.406 --> 00:17:10.226 A:middle
objects to shader parameters.

00:17:12.915 --> 00:17:15.016 A:middle
The index argument with each of

00:17:15.016 --> 00:17:16.396 A:middle
these calls are similar to

00:17:16.396 --> 00:17:18.316 A:middle
OpenGL's attribute indices,

00:17:18.366 --> 00:17:19.935 A:middle
vertex attribute indices, and

00:17:19.935 --> 00:17:20.715 A:middle
textured units.

00:17:21.336 --> 00:17:23.415 A:middle
They specify indices which map

00:17:23.526 --> 00:17:25.296 A:middle
to indices in our shader

00:17:25.296 --> 00:17:25.836 A:middle
parameters.

00:17:27.026 --> 00:17:29.056 A:middle
So by calling the encoder's set

00:17:29.106 --> 00:17:30.526 A:middle
fragment buffer method with an

00:17:30.526 --> 00:17:33.046 A:middle
index of three we map this my

00:17:33.046 --> 00:17:35.346 A:middle
uniform buffer object to the

00:17:35.346 --> 00:17:37.446 A:middle
uniform's parameter of our

00:17:37.446 --> 00:17:38.936 A:middle
encoder, of our shader.

00:17:39.536 --> 00:17:42.326 A:middle
We make similar calls to set our

00:17:42.326 --> 00:17:44.836 A:middle
texture and sampler objects.

00:17:50.396 --> 00:17:52.096 A:middle
Now I want to talk about one

00:17:52.096 --> 00:17:53.996 A:middle
library that's incredibly useful

00:17:54.106 --> 00:17:55.606 A:middle
for shader development.

00:17:57.236 --> 00:17:58.576 A:middle
This is called SIMD.

00:17:58.896 --> 00:18:00.666 A:middle
Now SIMD is actually a library


00:17:58.896 --> 00:18:00.666 A:middle
Now SIMD is actually a library

00:18:00.966 --> 00:18:02.616 A:middle
that's separate from Metal and

00:18:03.126 --> 00:18:04.656 A:middle
is used in many orthogonal

00:18:04.716 --> 00:18:05.246 A:middle
frameworks.

00:18:05.836 --> 00:18:07.366 A:middle
But it was built with Metal in

00:18:07.366 --> 00:18:07.686 A:middle
mind.

00:18:08.936 --> 00:18:10.886 A:middle
SIMD defines vector and matrix

00:18:10.886 --> 00:18:12.786 A:middle
types commonly used to implement

00:18:13.286 --> 00:18:15.056 A:middle
graphics algorithms, so this

00:18:15.056 --> 00:18:16.036 A:middle
includes three and four

00:18:16.036 --> 00:18:17.846 A:middle
component vector types and three

00:18:17.846 --> 00:18:19.796 A:middle
by three and four by four matrix

00:18:19.796 --> 00:18:19.976 A:middle
types.

00:18:24.046 --> 00:18:24.906 A:middle
One of the nicest features of

00:18:24.906 --> 00:18:26.676 A:middle
this library is that you can use

00:18:26.676 --> 00:18:30.496 A:middle
it to share code between your

00:18:30.496 --> 00:18:33.306 A:middle
application code and your

00:18:33.306 --> 00:18:34.966 A:middle
shading language code.

00:18:35.596 --> 00:18:37.216 A:middle
This is really useful because

00:18:37.216 --> 00:18:38.856 A:middle
you can define the layout of

00:18:38.926 --> 00:18:39.986 A:middle
data passed from your

00:18:39.986 --> 00:18:42.066 A:middle
application to your shaders with

00:18:42.066 --> 00:18:43.426 A:middle
structures using these types.

00:18:44.046 --> 00:18:44.766 A:middle
Here's how it works.

00:18:45.996 --> 00:18:47.276 A:middle
You create a structure with data

00:18:47.346 --> 00:18:48.216 A:middle
you'd like to pass from your

00:18:48.216 --> 00:18:49.516 A:middle
application to your shaders.

00:18:49.836 --> 00:18:51.396 A:middle
So for instance, if you want to

00:18:51.396 --> 00:18:52.536 A:middle
pass down a model view

00:18:52.536 --> 00:18:55.206 A:middle
projection matrix to the and the

00:18:55.206 --> 00:18:56.646 A:middle
position of the SIMD primary

00:18:56.646 --> 00:18:58.696 A:middle
light source you can use SIMD

00:18:58.696 --> 00:19:00.856 A:middle
types in your structure to do


00:18:58.696 --> 00:19:00.856 A:middle
types in your structure to do

00:19:01.376 --> 00:19:01.546 A:middle
this.

00:19:01.976 --> 00:19:02.746 A:middle
You put the structure's

00:19:02.746 --> 00:19:05.106 A:middle
definition and a header which

00:19:05.106 --> 00:19:06.366 A:middle
you would include in both your

00:19:06.366 --> 00:19:08.466 A:middle
application code and Metal

00:19:08.466 --> 00:19:08.796 A:middle
files.

00:19:09.116 --> 00:19:10.756 A:middle
This way the data layout used by

00:19:10.756 --> 00:19:12.566 A:middle
your shaders matches what you've

00:19:12.566 --> 00:19:14.036 A:middle
set in your code because they're

00:19:14.036 --> 00:19:15.286 A:middle
using the same types.

00:19:16.686 --> 00:19:18.296 A:middle
This makes bugs due to layout

00:19:18.296 --> 00:19:19.976 A:middle
mismatches much less common.

00:19:24.046 --> 00:19:25.556 A:middle
One of the key ways in which

00:19:25.556 --> 00:19:27.716 A:middle
Metal achieves its efficiency is

00:19:27.716 --> 00:19:29.976 A:middle
by doing work earlier and less

00:19:30.026 --> 00:19:30.456 A:middle
frequently.

00:19:31.376 --> 00:19:33.426 A:middle
So you'll use Xcode to compile

00:19:33.426 --> 00:19:34.896 A:middle
Metal shader files when you

00:19:34.896 --> 00:19:35.856 A:middle
build your application.

00:19:36.986 --> 00:19:38.206 A:middle
This runs a front-end

00:19:38.206 --> 00:19:39.866 A:middle
compilation performing string

00:19:39.866 --> 00:19:41.826 A:middle
parsing, shader analysis, and

00:19:41.826 --> 00:19:43.226 A:middle
some basic optimizations.

00:19:43.986 --> 00:19:45.526 A:middle
It converts your code into a

00:19:45.526 --> 00:19:46.796 A:middle
binary intermediate

00:19:46.796 --> 00:19:48.856 A:middle
representation that is usable on

00:19:48.856 --> 00:19:49.456 A:middle
any hardware.

00:19:50.456 --> 00:19:52.566 A:middle
Actual GPU machine code isn't

00:19:52.566 --> 00:19:54.156 A:middle
built until your app runs on the

00:19:54.156 --> 00:19:54.976 A:middle
user's system.

00:19:55.516 --> 00:19:56.726 A:middle
But this removes half the

00:19:56.726 --> 00:19:58.796 A:middle
compiled time needed when your

00:19:58.796 --> 00:19:58.976 A:middle
app runs.

00:19:59.996 --> 00:20:02.886 A:middle
The built intermediate


00:19:59.996 --> 00:20:02.886 A:middle
The built intermediate

00:20:02.886 --> 00:20:05.286 A:middle
representation binary is

00:20:05.376 --> 00:20:07.656 A:middle
archived into a Metal library

00:20:07.656 --> 00:20:07.926 A:middle
file.

00:20:08.576 --> 00:20:10.376 A:middle
Xcode will compile all the Metal

00:20:10.376 --> 00:20:11.656 A:middle
shader source files into a

00:20:11.776 --> 00:20:13.856 A:middle
default Metal library, placing

00:20:13.856 --> 00:20:16.256 A:middle
it into your app bundle for

00:20:16.256 --> 00:20:17.276 A:middle
retrieval at runtime.

00:20:17.936 --> 00:20:20.686 A:middle
In addition to having Xcode

00:20:20.686 --> 00:20:23.286 A:middle
built shaders you also can build

00:20:23.286 --> 00:20:24.266 A:middle
shaders during your app's

00:20:24.266 --> 00:20:24.726 A:middle
runtime.

00:20:26.126 --> 00:20:27.436 A:middle
Some OpenGL apps construct

00:20:27.436 --> 00:20:28.446 A:middle
shaders at runtime by

00:20:28.546 --> 00:20:30.096 A:middle
concatenating strings or running

00:20:30.096 --> 00:20:31.286 A:middle
a source code generator of some

00:20:31.286 --> 00:20:31.616 A:middle
kind.

00:20:32.646 --> 00:20:33.846 A:middle
For those gathering all of the

00:20:33.846 --> 00:20:35.376 A:middle
shaders at build time can be a

00:20:35.376 --> 00:20:35.826 A:middle
challenge.

00:20:36.846 --> 00:20:38.756 A:middle
But for bring up purposes or if

00:20:38.856 --> 00:20:40.476 A:middle
built time compilation just

00:20:40.476 --> 00:20:41.486 A:middle
isn't possible for your app

00:20:41.876 --> 00:20:43.486 A:middle
Metal is able to compile shaders

00:20:43.486 --> 00:20:45.326 A:middle
from source at runtime just like

00:20:45.326 --> 00:20:45.836 A:middle
OpenGL.

00:20:46.386 --> 00:20:49.346 A:middle
However, there are a number of

00:20:49.346 --> 00:20:50.896 A:middle
disadvantages to this, most

00:20:50.896 --> 00:20:52.416 A:middle
obviously you give up on the

00:20:52.416 --> 00:20:53.636 A:middle
performance savings of keeping

00:20:53.636 --> 00:20:54.986 A:middle
this work off the user's system.

00:20:56.216 --> 00:20:57.206 A:middle
You won't see any shader

00:20:57.206 --> 00:20:58.546 A:middle
compilation errors at built time

00:20:58.546 --> 00:20:59.716 A:middle
so you'll only find out about

00:20:59.716 --> 00:21:00.776 A:middle
them when you run your app.


00:20:59.716 --> 00:21:00.776 A:middle
them when you run your app.

00:21:01.896 --> 00:21:03.436 A:middle
Finally, if you compile at

00:21:03.436 --> 00:21:04.766 A:middle
runtime you can't include

00:21:04.766 --> 00:21:06.246 A:middle
headers in your shaders, so you

00:21:06.246 --> 00:21:07.526 A:middle
can't share types between your

00:21:07.526 --> 00:21:09.396 A:middle
shaders or your application

00:21:09.396 --> 00:21:09.686 A:middle
code.

00:21:10.236 --> 00:21:12.776 A:middle
If you use runtime share

00:21:12.776 --> 00:21:14.546 A:middle
compilation to get your app up

00:21:14.546 --> 00:21:16.066 A:middle
and running quickly I strongly

00:21:16.066 --> 00:21:18.146 A:middle
encourage you to spend some time

00:21:18.146 --> 00:21:19.086 A:middle
getting your shaders to build

00:21:19.086 --> 00:21:19.966 A:middle
within Xcode.

00:21:20.586 --> 00:21:21.676 A:middle
This way you can benefit from

00:21:21.676 --> 00:21:23.056 A:middle
not only the runtime performance

00:21:23.056 --> 00:21:24.246 A:middle
savings but also these

00:21:24.246 --> 00:21:25.546 A:middle
conveniences in shader

00:21:25.546 --> 00:21:26.046 A:middle
development.

00:21:26.526 --> 00:21:29.426 A:middle
Let's move onto the steps your

00:21:29.426 --> 00:21:30.646 A:middle
app will need to take to

00:21:30.646 --> 00:21:31.946 A:middle
initialize your Metal renderer,

00:21:32.186 --> 00:21:33.376 A:middle
so this includes creating a

00:21:33.376 --> 00:21:34.246 A:middle
number of objects.

00:21:34.746 --> 00:21:36.286 A:middle
I'll start out with the devices

00:21:36.286 --> 00:21:37.666 A:middle
and command queues and then I'll

00:21:37.666 --> 00:21:39.826 A:middle
describe how to create objects

00:21:39.826 --> 00:21:40.966 A:middle
for your assets, including

00:21:40.966 --> 00:21:42.936 A:middle
textures, buffers and pipeline

00:21:42.936 --> 00:21:43.426 A:middle
objects.

00:21:45.046 --> 00:21:47.566 A:middle
So devices and queues.

00:21:47.726 --> 00:21:49.246 A:middle
These are the first objects

00:21:49.366 --> 00:21:50.016 A:middle
you'll create.

00:21:50.636 --> 00:21:53.506 A:middle
The device is an abstract

00:21:53.506 --> 00:21:54.866 A:middle
representation of a GPU.

00:21:56.226 --> 00:21:57.346 A:middle
It's responsible for creating

00:21:57.346 --> 00:21:58.436 A:middle
objects that are used for

00:21:58.436 --> 00:21:59.416 A:middle
rendering including these

00:21:59.456 --> 00:22:00.956 A:middle
textures, buffers and pipeline


00:21:59.456 --> 00:22:00.956 A:middle
textures, buffers and pipeline

00:22:00.956 --> 00:22:01.386 A:middle
objects.

00:22:02.846 --> 00:22:04.506 A:middle
In iOS since there's only ever

00:22:04.506 --> 00:22:06.826 A:middle
one GPU there's only one device

00:22:06.826 --> 00:22:08.626 A:middle
you can get, but on macOS

00:22:08.916 --> 00:22:10.356 A:middle
systems can have multiple

00:22:10.356 --> 00:22:12.216 A:middle
devices since there may be both

00:22:12.216 --> 00:22:14.126 A:middle
an integrated and discrete GPU

00:22:14.126 --> 00:22:16.026 A:middle
and even multiple eGPUs.

00:22:17.236 --> 00:22:18.286 A:middle
Usually though, getting the

00:22:18.286 --> 00:22:20.146 A:middle
default device is sufficient for

00:22:20.146 --> 00:22:21.126 A:middle
most applications.

00:22:21.886 --> 00:22:23.776 A:middle
And getting this device is

00:22:23.826 --> 00:22:25.216 A:middle
really simple, you call

00:22:25.276 --> 00:22:26.876 A:middle
MTLCreateSystem

00:22:26.876 --> 00:22:27.616 A:middle
DefaultDevice.

00:22:28.296 --> 00:22:31.136 A:middle
One of the first things you'll

00:22:31.136 --> 00:22:33.396 A:middle
do with this device is create a

00:22:33.396 --> 00:22:33.966 A:middle
command queue.

00:22:35.746 --> 00:22:37.416 A:middle
The queue is used mostly in your

00:22:37.416 --> 00:22:38.736 A:middle
applications render loop to

00:22:38.736 --> 00:22:40.036 A:middle
obtain command buffers each

00:22:40.086 --> 00:22:41.536 A:middle
frame, but you want to create

00:22:41.536 --> 00:22:42.836 A:middle
the command queue at

00:22:42.996 --> 00:22:43.826 A:middle
initialization.

00:22:45.036 --> 00:22:46.176 A:middle
Typically, a single queue is

00:22:46.176 --> 00:22:48.006 A:middle
sufficient but more complex apps

00:22:48.276 --> 00:22:49.926 A:middle
that execute many tasks in

00:22:49.926 --> 00:22:51.566 A:middle
parallel may need multiple

00:22:51.596 --> 00:22:51.986 A:middle
queues.

00:22:53.206 --> 00:22:54.696 A:middle
Creating a queue is also really

00:22:54.696 --> 00:22:56.666 A:middle
simple, you call newCommandQueue

00:22:56.906 --> 00:22:57.936 A:middle
with the device you just

00:22:57.936 --> 00:22:58.336 A:middle
created.

00:22:58.956 --> 00:22:59.996 A:middle
And once you've got your queue


00:23:00.276 --> 00:23:01.716 A:middle
you can get command buffers for

00:23:01.716 --> 00:23:02.306 A:middle
your render loop.

00:23:02.806 --> 00:23:06.846 A:middle
Let's move on building your

00:23:06.846 --> 00:23:07.546 A:middle
render objects.

00:23:08.216 --> 00:23:10.546 A:middle
I'm going to talk about creating

00:23:10.736 --> 00:23:12.106 A:middle
three types of objects used for

00:23:12.106 --> 00:23:13.936 A:middle
rendering, textures, buffers and

00:23:13.936 --> 00:23:14.426 A:middle
pipelines.

00:23:15.496 --> 00:23:17.846 A:middle
Let's start with textures.

00:23:18.106 --> 00:23:19.466 A:middle
As mentioned earlier, you create

00:23:19.466 --> 00:23:20.726 A:middle
render objects from a device

00:23:20.726 --> 00:23:21.066 A:middle
object.

00:23:22.416 --> 00:23:23.756 A:middle
You'll use a descriptor object

00:23:23.756 --> 00:23:24.836 A:middle
to create most of these.

00:23:25.546 --> 00:23:26.916 A:middle
Descriptors are really simple

00:23:26.916 --> 00:23:28.356 A:middle
objects without any true

00:23:28.356 --> 00:23:28.756 A:middle
methods.

00:23:29.296 --> 00:23:30.586 A:middle
They only contain properties

00:23:30.586 --> 00:23:31.856 A:middle
needed for object setup.

00:23:33.146 --> 00:23:34.526 A:middle
So for example, to create a

00:23:34.526 --> 00:23:35.836 A:middle
texture you'd use a texture

00:23:35.836 --> 00:23:36.326 A:middle
descriptor.

00:23:37.076 --> 00:23:38.306 A:middle
You specify the properties that

00:23:38.306 --> 00:23:39.386 A:middle
you'd like the created texture

00:23:39.386 --> 00:23:39.666 A:middle
to have.

00:23:40.186 --> 00:23:41.406 A:middle
So things like the type of

00:23:41.436 --> 00:23:43.396 A:middle
texture, 2D, 3D, cubeMap.

00:23:44.146 --> 00:23:45.296 A:middle
The texture's dimensions and the

00:23:45.296 --> 00:23:46.486 A:middle
number of Mipmaps you'd like it

00:23:46.486 --> 00:23:47.286 A:middle
to have.

00:23:47.286 --> 00:23:49.746 A:middle
And the pixel format of data in

00:23:50.676 --> 00:23:51.576 A:middle
the texture.

00:23:51.706 --> 00:23:53.416 A:middle
Once you've set the desired

00:23:53.416 --> 00:23:54.346 A:middle
values for each of the

00:23:54.346 --> 00:23:56.076 A:middle
properties you call a method on

00:23:56.076 --> 00:23:58.026 A:middle
the device to create a usable

00:23:58.026 --> 00:23:58.856 A:middle
texture object.


00:24:00.816 --> 00:24:03.156 A:middle
This also allocates the memory

00:24:03.266 --> 00:24:04.726 A:middle
backing the texture image.

00:24:06.086 --> 00:24:07.166 A:middle
Once you've created the object

00:24:07.166 --> 00:24:07.946 A:middle
you no longer need the

00:24:07.946 --> 00:24:09.286 A:middle
descriptor as it's only used for

00:24:09.286 --> 00:24:10.126 A:middle
object creation.

00:24:11.256 --> 00:24:12.296 A:middle
And properties you set in the

00:24:12.296 --> 00:24:13.506 A:middle
descriptor are locked and can no

00:24:13.506 --> 00:24:14.396 A:middle
longer be changed.

00:24:15.766 --> 00:24:17.056 A:middle
However, the contents of the

00:24:17.056 --> 00:24:18.726 A:middle
texture image can be modified.

00:24:18.756 --> 00:24:21.816 A:middle
So I want to talk about one

00:24:21.816 --> 00:24:22.816 A:middle
property you'll set in the

00:24:22.816 --> 00:24:24.096 A:middle
texture descriptor and you'll

00:24:24.096 --> 00:24:25.876 A:middle
also use when creating a buffer.

00:24:26.626 --> 00:24:28.166 A:middle
This is called the storage mode.

00:24:29.286 --> 00:24:30.366 A:middle
As mentioned, when you create a

00:24:30.366 --> 00:24:31.966 A:middle
texture object Metal allocates

00:24:31.966 --> 00:24:33.366 A:middle
memory for it right then and

00:24:33.366 --> 00:24:33.596 A:middle
there.

00:24:34.106 --> 00:24:35.276 A:middle
The storage mode property tells

00:24:35.276 --> 00:24:36.696 A:middle
Metal in which pool memory it

00:24:36.696 --> 00:24:37.406 A:middle
should be allocated.

00:24:38.576 --> 00:24:40.056 A:middle
The simplest option shared

00:24:40.056 --> 00:24:42.436 A:middle
storage mode gives both the CPU

00:24:42.876 --> 00:24:44.046 A:middle
and the GPU access.

00:24:44.656 --> 00:24:46.076 A:middle
For buffers this means you get a

00:24:46.076 --> 00:24:47.666 A:middle
pointer to the memory backing

00:24:47.666 --> 00:24:48.156 A:middle
the object.

00:24:48.996 --> 00:24:50.166 A:middle
Protectors, this means you can

00:24:50.166 --> 00:24:51.926 A:middle
call certain easy-to-use methods

00:24:52.196 --> 00:24:53.806 A:middle
to set and retrieve data from

00:24:53.806 --> 00:24:54.196 A:middle
the texture.

00:24:54.736 --> 00:24:57.246 A:middle
You can use private storage mode

00:24:57.246 --> 00:24:58.836 A:middle
which only gives the GPU access

00:24:58.926 --> 00:25:00.486 A:middle
to the data, this allows the


00:24:58.926 --> 00:25:00.486 A:middle
to the data, this allows the

00:25:00.486 --> 00:25:01.356 A:middle
Metal to apply some

00:25:01.356 --> 00:25:03.906 A:middle
optimizations it would be unable

00:25:03.906 --> 00:25:05.786 A:middle
to if the CPU also had access to

00:25:05.786 --> 00:25:06.206 A:middle
that data.

00:25:06.896 --> 00:25:08.776 A:middle
But only the GPU can directly

00:25:08.886 --> 00:25:10.636 A:middle
fill the contents of this type

00:25:10.636 --> 00:25:11.096 A:middle
of texture.

00:25:12.606 --> 00:25:14.016 A:middle
You can indirectly fill data

00:25:14.206 --> 00:25:15.996 A:middle
from the CPU using a blit

00:25:15.996 --> 00:25:17.786 A:middle
encoder to copy from a second

00:25:18.076 --> 00:25:19.526 A:middle
intermediate resource using

00:25:19.526 --> 00:25:21.026 A:middle
shared storage.

00:25:22.446 --> 00:25:23.966 A:middle
On devices with dedicated video

00:25:23.966 --> 00:25:25.656 A:middle
memory setting the resource to

00:25:25.656 --> 00:25:27.306 A:middle
use private storage allocates it

00:25:27.306 --> 00:25:28.396 A:middle
in video memory only.

00:25:30.396 --> 00:25:32.776 A:middle
Finally, on macOS you can use a

00:25:32.866 --> 00:25:34.056 A:middle
third storage mode called

00:25:34.056 --> 00:25:34.756 A:middle
managed storage.

00:25:35.696 --> 00:25:37.796 A:middle
This allows both the GPU and CPU

00:25:37.826 --> 00:25:39.066 A:middle
to access the object data.

00:25:39.776 --> 00:25:40.946 A:middle
And on systems with dedicated

00:25:40.946 --> 00:25:43.226 A:middle
video memory Metal may create a

00:25:43.226 --> 00:25:44.476 A:middle
mirrored memory backing for

00:25:44.476 --> 00:25:46.056 A:middle
efficient access by both

00:25:46.056 --> 00:25:46.696 A:middle
processors.

00:25:47.926 --> 00:25:49.396 A:middle
Because of this, explicit calls

00:25:49.396 --> 00:25:51.166 A:middle
are necessary to ensure data is

00:25:51.236 --> 00:25:53.476 A:middle
synchronized for GPU and CPU

00:25:53.476 --> 00:25:53.876 A:middle
access.

00:25:58.126 --> 00:25:59.486 A:middle
Here's an example of creating a

00:25:59.486 --> 00:26:00.376 A:middle
texture object.


00:25:59.486 --> 00:26:00.376 A:middle
texture object.

00:26:00.816 --> 00:26:04.256 A:middle
First you create a texture

00:26:04.256 --> 00:26:06.126 A:middle
descriptor and set a number of

00:26:06.126 --> 00:26:07.966 A:middle
properties in it, including the

00:26:07.966 --> 00:26:08.586 A:middle
storage mode.

00:26:09.106 --> 00:26:12.836 A:middle
And then we create a texture

00:26:13.586 --> 00:26:14.556 A:middle
using the device.

00:26:15.916 --> 00:26:17.166 A:middle
To fill a texture's image data

00:26:17.316 --> 00:26:18.936 A:middle
we calculate the bytes per row

00:26:19.886 --> 00:26:21.336 A:middle
and just like with GLText

00:26:21.336 --> 00:26:23.056 A:middle
[inaudible] we specify a region

00:26:23.056 --> 00:26:23.466 A:middle
to load.

00:26:26.196 --> 00:26:27.536 A:middle
And then we call the texture

00:26:27.536 --> 00:26:29.506 A:middle
object's replace region method

00:26:29.756 --> 00:26:31.596 A:middle
which copies the data into the

00:26:31.596 --> 00:26:32.676 A:middle
texture from a pointer we

00:26:32.676 --> 00:26:32.926 A:middle
supply.

00:26:37.046 --> 00:26:38.266 A:middle
Now there are a few notable

00:26:38.266 --> 00:26:39.396 A:middle
differences between OpenGL and

00:26:39.396 --> 00:26:40.446 A:middle
Metal texture objects.

00:26:40.816 --> 00:26:42.556 A:middle
While OpenGL does have a sampler

00:26:42.556 --> 00:26:43.886 A:middle
object they are optional.

00:26:44.406 --> 00:26:45.576 A:middle
Wrap modes and filters can be

00:26:45.576 --> 00:26:46.826 A:middle
set in the texture's object

00:26:46.826 --> 00:26:47.886 A:middle
itself in OpenGL.

00:26:48.276 --> 00:26:49.736 A:middle
In Metal you need to create a

00:26:49.816 --> 00:26:51.376 A:middle
separate sampler object or

00:26:51.376 --> 00:26:53.576 A:middle
specify sampler parameters in

00:26:54.206 --> 00:26:55.096 A:middle
your shaders.

00:26:55.786 --> 00:26:57.336 A:middle
Texture image data is not

00:26:57.416 --> 00:26:57.946 A:middle
flipped in Metal.

00:26:58.496 --> 00:27:00.996 A:middle
OpenGL uses a bottom-left origin


00:26:58.496 --> 00:27:00.996 A:middle
OpenGL uses a bottom-left origin

00:27:01.306 --> 00:27:02.826 A:middle
while Metal uses a top-left

00:27:02.826 --> 00:27:03.196 A:middle
origin.

00:27:03.196 --> 00:27:04.426 A:middle
So make sure you're aware of the

00:27:04.426 --> 00:27:05.736 A:middle
difference when loading your

00:27:05.736 --> 00:27:06.266 A:middle
textures.

00:27:06.686 --> 00:27:09.696 A:middle
Desktop OpenGL also performs

00:27:09.796 --> 00:27:10.866 A:middle
conversions when the data

00:27:10.916 --> 00:27:13.376 A:middle
supplied is in a different

00:27:13.376 --> 00:27:15.016 A:middle
format than the internal format.

00:27:16.456 --> 00:27:18.106 A:middle
However Metal similar to OpenGL

00:27:18.206 --> 00:27:20.346 A:middle
ES does not, so you'll need to

00:27:20.346 --> 00:27:21.406 A:middle
make sure your assets are

00:27:21.436 --> 00:27:23.436 A:middle
already in the proper format or

00:27:23.696 --> 00:27:25.146 A:middle
implement paths to perform

00:27:25.176 --> 00:27:25.696 A:middle
conversions.

00:27:29.066 --> 00:27:32.316 A:middle
Let's move on to buffers.

00:27:32.456 --> 00:27:34.266 A:middle
Metal uses buffers for all

00:27:34.266 --> 00:27:34.976 A:middle
unstructured data.

00:27:41.456 --> 00:27:42.406 A:middle
They're really similar to

00:27:42.406 --> 00:27:44.716 A:middle
OpenGL's vertex, element and

00:27:44.816 --> 00:27:45.646 A:middle
uniform buffers.

00:27:45.926 --> 00:27:47.076 A:middle
So if you're already using these

00:27:47.076 --> 00:27:48.456 A:middle
buffers in OpenGL you'll have an

00:27:48.506 --> 00:27:50.126 A:middle
easier time with your port.

00:27:51.506 --> 00:27:52.686 A:middle
Creating a buffer is pretty

00:27:52.686 --> 00:27:54.456 A:middle
simple with a device you call

00:27:54.516 --> 00:27:55.986 A:middle
newBufferWithLength specifying

00:27:55.986 --> 00:27:57.146 A:middle
the size of the buffer you want.

00:27:57.826 --> 00:27:59.626 A:middle
You also specify a storage mode.


00:28:00.986 --> 00:28:01.996 A:middle
You load a buffer through the

00:28:02.036 --> 00:28:03.506 A:middle
contents property, which is

00:28:03.506 --> 00:28:05.026 A:middle
simply a void pointer to the

00:28:05.026 --> 00:28:06.186 A:middle
memory backing the buffer.

00:28:07.276 --> 00:28:08.706 A:middle
To Metal's core the data is

00:28:08.706 --> 00:28:10.076 A:middle
completely unstructured, so it's

00:28:10.076 --> 00:28:11.896 A:middle
up to you to define the layout

00:28:12.196 --> 00:28:14.066 A:middle
in your application and share

00:28:14.066 --> 00:28:14.296 A:middle
your code.

00:28:15.086 --> 00:28:16.746 A:middle
Here we're casting the contents

00:28:16.826 --> 00:28:18.486 A:middle
pointer to a structure which

00:28:18.486 --> 00:28:20.546 A:middle
uses some of the SIMD types I

00:28:20.546 --> 00:28:21.236 A:middle
mentioned earlier.

00:28:21.236 --> 00:28:23.796 A:middle
We set the members of the

00:28:23.796 --> 00:28:25.466 A:middle
structure which fills in the

00:28:25.466 --> 00:28:26.936 A:middle
buffer's data using the layout

00:28:26.936 --> 00:28:28.286 A:middle
or application as is defined

00:28:28.606 --> 00:28:29.816 A:middle
with the structure's definition.

00:28:31.306 --> 00:28:32.506 A:middle
As mentioned earlier, you can

00:28:32.506 --> 00:28:34.026 A:middle
share a structure's definition

00:28:34.276 --> 00:28:35.406 A:middle
between your application and

00:28:35.406 --> 00:28:36.736 A:middle
share code which ensures the

00:28:36.736 --> 00:28:38.216 A:middle
layouts match between these two

00:28:38.216 --> 00:28:38.886 A:middle
components.

00:28:39.466 --> 00:28:44.846 A:middle
A common mistake is a mismatch

00:28:44.886 --> 00:28:46.456 A:middle
between buffer data and how it's

00:28:46.456 --> 00:28:48.226 A:middle
interpreted in the shader due to

00:28:48.356 --> 00:28:49.556 A:middle
an assumption or due to

00:28:49.556 --> 00:28:51.196 A:middle
assumptions about alignment.

00:28:52.136 --> 00:28:53.476 A:middle
For instance, you might assume

00:28:53.476 --> 00:28:54.496 A:middle
that the shading language's

00:28:54.826 --> 00:28:57.256 A:middle
float3 type consumes only 12

00:28:57.296 --> 00:28:57.576 A:middle
bytes.

00:28:58.266 --> 00:29:00.506 A:middle
Three 4 byte components is 12


00:28:58.266 --> 00:29:00.506 A:middle
Three 4 byte components is 12

00:29:00.506 --> 00:29:01.096 A:middle
bytes right.

00:29:01.936 --> 00:29:03.436 A:middle
Well if you pack your data that

00:29:03.436 --> 00:29:04.716 A:middle
way you'll run into trouble

00:29:05.356 --> 00:29:06.586 A:middle
because the shading language

00:29:06.666 --> 00:29:08.296 A:middle
actually interprets a float3 as

00:29:08.296 --> 00:29:09.586 A:middle
consuming 16 bytes.

00:29:10.336 --> 00:29:11.236 A:middle
That's because the types are

00:29:11.236 --> 00:29:12.936 A:middle
kept as stricter alignments for

00:29:12.936 --> 00:29:16.366 A:middle
CPU and GPU optimal CPU and GPU

00:29:16.366 --> 00:29:16.816 A:middle
usage.

00:29:18.026 --> 00:29:19.626 A:middle
Similar problems often occur

00:29:19.996 --> 00:29:21.176 A:middle
with three by three matrices.

00:29:22.316 --> 00:29:23.936 A:middle
If you really want to tack, if

00:29:23.936 --> 00:29:26.046 A:middle
you really want to pack data

00:29:26.186 --> 00:29:28.996 A:middle
tightly there are pack types

00:29:28.996 --> 00:29:30.416 A:middle
available in the Metal shading

00:29:30.416 --> 00:29:30.776 A:middle
language.

00:29:31.246 --> 00:29:33.126 A:middle
After passing a pack data in a

00:29:33.126 --> 00:29:34.596 A:middle
buffer your shader code would

00:29:34.596 --> 00:29:37.356 A:middle
need to pack data, would you

00:29:37.356 --> 00:29:38.846 A:middle
need to pass that packed data to

00:29:38.846 --> 00:29:40.686 A:middle
a regular vector before it can

00:29:40.686 --> 00:29:42.236 A:middle
perform operations on that data.

00:29:43.716 --> 00:29:45.436 A:middle
So when you're bringing up your

00:29:45.436 --> 00:29:48.446 A:middle
application I recommend using

00:29:48.756 --> 00:29:49.956 A:middle
the most convenient storage

00:29:49.956 --> 00:29:50.376 A:middle
modes.

00:29:51.396 --> 00:29:53.436 A:middle
This makes it more easy to

00:29:53.466 --> 00:29:55.486 A:middle
access the data in those

00:29:55.486 --> 00:29:55.976 A:middle
resources.

00:29:57.006 --> 00:29:58.676 A:middle
So in iOS create all textures

00:29:58.676 --> 00:29:59.696 A:middle
and buffers with


00:30:00.086 --> 00:30:00.976 A:middle
StorageModeShared.

00:30:02.386 --> 00:30:03.726 A:middle
On macOS you can't use

00:30:03.726 --> 00:30:05.076 A:middle
StorageModeShared with textures,

00:30:05.246 --> 00:30:07.146 A:middle
but StorageModeManaged does make

00:30:07.146 --> 00:30:08.526 A:middle
image data access easier,

00:30:08.856 --> 00:30:10.426 A:middle
although private storage is most

00:30:10.426 --> 00:30:10.846 A:middle
optimal.

00:30:16.046 --> 00:30:16.996 A:middle
You can use StorageModeShared

00:30:16.996 --> 00:30:19.216 A:middle
with buffers on macOS, but be

00:30:19.216 --> 00:30:19.906 A:middle
careful with this.

00:30:20.526 --> 00:30:22.456 A:middle
If you mix data that both the

00:30:22.576 --> 00:30:26.066 A:middle
CPU and GPU needs access to with

00:30:26.066 --> 00:30:28.336 A:middle
data only the GPU needs access

00:30:28.376 --> 00:30:29.456 A:middle
to it can be difficult to

00:30:29.456 --> 00:30:31.246 A:middle
detangle these two types of data

00:30:31.246 --> 00:30:33.046 A:middle
later on and put them in

00:30:33.046 --> 00:30:34.286 A:middle
separate memory pools.

00:30:34.906 --> 00:30:37.816 A:middle
Now that I've described a little

00:30:37.816 --> 00:30:39.166 A:middle
bit about creating textures and

00:30:39.166 --> 00:30:41.186 A:middle
buffer objects directly I'd like

00:30:41.186 --> 00:30:42.106 A:middle
to mention the MetalKit

00:30:42.156 --> 00:30:43.526 A:middle
framework which can easily

00:30:43.526 --> 00:30:44.676 A:middle
create textures and vertex

00:30:44.676 --> 00:30:46.156 A:middle
buffers from common file

00:30:46.216 --> 00:30:46.606 A:middle
formats.

00:30:47.146 --> 00:30:48.336 A:middle
There's a texture loading class

00:30:48.626 --> 00:30:50.286 A:middle
and some functionality to create

00:30:50.286 --> 00:30:52.216 A:middle
Metal buffer backed meshes

00:30:52.376 --> 00:30:53.936 A:middle
loaded by Model I/O.

00:30:58.046 --> 00:30:59.106 A:middle
Let's talk about shaders and the

00:30:59.106 --> 00:31:00.506 A:middle
render pipeline objects that


00:30:59.106 --> 00:31:00.506 A:middle
render pipeline objects that

00:31:00.506 --> 00:31:02.036 A:middle
contain them.

00:31:02.776 --> 00:31:04.046 A:middle
You create one of these pipeline

00:31:04.046 --> 00:31:05.766 A:middle
state objects using a render

00:31:05.766 --> 00:31:07.096 A:middle
pipeline descriptor object.

00:31:08.466 --> 00:31:10.116 A:middle
The object contains a vertex and

00:31:10.116 --> 00:31:11.066 A:middle
fragment shader pair.

00:31:12.446 --> 00:31:13.886 A:middle
It also specifies the layout of

00:31:13.886 --> 00:31:15.516 A:middle
vertices feeding the vertex

00:31:16.286 --> 00:31:16.416 A:middle
shader.

00:31:17.066 --> 00:31:19.506 A:middle
And also blend state and the

00:31:19.586 --> 00:31:21.586 A:middle
pixel formats of render targets

00:31:21.866 --> 00:31:23.706 A:middle
that the fragment and shader can

00:31:23.706 --> 00:31:24.136 A:middle
render to.

00:31:25.666 --> 00:31:27.206 A:middle
Just like with the texture

00:31:27.206 --> 00:31:28.556 A:middle
object you call method on the

00:31:28.556 --> 00:31:30.136 A:middle
device which will produce an

00:31:30.136 --> 00:31:31.996 A:middle
immutable render state pipeline

00:31:31.996 --> 00:31:32.406 A:middle
object.

00:31:33.706 --> 00:31:34.926 A:middle
And also like a texture object

00:31:35.056 --> 00:31:36.306 A:middle
you only need the descriptor to

00:31:36.306 --> 00:31:37.546 A:middle
create that object.

00:31:38.156 --> 00:31:40.456 A:middle
Here's some code showing how to

00:31:40.456 --> 00:31:41.726 A:middle
build these pipeline state

00:31:41.726 --> 00:31:42.226 A:middle
objects.

00:31:43.536 --> 00:31:44.916 A:middle
Before you create the pipeline,

00:31:45.096 --> 00:31:47.456 A:middle
you'll need to get the shaders

00:31:47.456 --> 00:31:48.686 A:middle
out of a Metal library.

00:31:49.256 --> 00:31:51.446 A:middle
This line here loads the default

00:31:51.446 --> 00:31:53.816 A:middle
Metal library that we built in

00:31:54.416 --> 00:31:54.586 A:middle
Xcode.

00:31:54.726 --> 00:31:56.616 A:middle
For this library you can obtain

00:31:56.616 --> 00:31:58.316 A:middle
your vertex and fragment shader

00:31:59.116 --> 00:32:00.726 A:middle
using their function names.


00:31:59.116 --> 00:32:00.726 A:middle
using their function names.

00:32:01.906 --> 00:32:03.146 A:middle
You create a render pipeline

00:32:03.146 --> 00:32:05.316 A:middle
descriptor object where you set

00:32:05.316 --> 00:32:06.866 A:middle
these shading functions and also

00:32:06.866 --> 00:32:08.826 A:middle
specify render target pixel

00:32:08.826 --> 00:32:09.356 A:middle
formats.

00:32:10.306 --> 00:32:12.336 A:middle
Finally, you use the device with

00:32:12.336 --> 00:32:13.726 A:middle
the descriptor object we've set

00:32:13.726 --> 00:32:16.176 A:middle
up to produce a pipeline state

00:32:16.826 --> 00:32:17.026 A:middle
object.

00:32:18.136 --> 00:32:19.836 A:middle
The most significant difference

00:32:19.866 --> 00:32:21.906 A:middle
between the OpenGL and Metal

00:32:21.936 --> 00:32:25.316 A:middle
graphics pipelines is that while

00:32:25.316 --> 00:32:26.856 A:middle
an OpenGL program object

00:32:26.896 --> 00:32:28.196 A:middle
contains just a vertex and

00:32:28.226 --> 00:32:29.906 A:middle
fragment shader pair Metal

00:32:29.946 --> 00:32:31.816 A:middle
pipeline objects also include a

00:32:31.816 --> 00:32:33.536 A:middle
vertex layout, blend state, and

00:32:33.536 --> 00:32:34.726 A:middle
render target pixel format.

00:32:35.566 --> 00:32:36.776 A:middle
So you need to know all of these

00:32:36.816 --> 00:32:38.886 A:middle
things before you build a

00:32:39.696 --> 00:32:39.896 A:middle
pipeline.

00:32:40.016 --> 00:32:41.576 A:middle
Having these extra pieces of

00:32:41.646 --> 00:32:43.166 A:middle
state in the pipeline enables

00:32:43.166 --> 00:32:44.886 A:middle
Metal to fully compile shaders

00:32:44.886 --> 00:32:46.746 A:middle
into GPU machine code upon

00:32:46.816 --> 00:32:47.576 A:middle
object creation.

00:32:48.116 --> 00:32:49.006 A:middle
This is something that's not

00:32:49.006 --> 00:32:50.326 A:middle
possible with OpenGL's program

00:32:50.326 --> 00:32:50.836 A:middle
objects.

00:32:51.706 --> 00:32:52.796 A:middle
Now you'll need to build a

00:32:52.796 --> 00:32:54.146 A:middle
system that allows you to create

00:32:54.146 --> 00:32:55.896 A:middle
pipelines when you initialize

00:32:55.896 --> 00:32:56.086 A:middle
your app.

00:32:57.266 --> 00:32:58.236 A:middle
It helps if you can choose a

00:32:58.236 --> 00:32:59.816 A:middle
canonical vertex layout and a

00:32:59.816 --> 00:33:01.546 A:middle
limited set of render targets.


00:32:59.816 --> 00:33:01.546 A:middle
limited set of render targets.

00:33:02.156 --> 00:33:03.766 A:middle
This reduces the combinations of

00:33:03.766 --> 00:33:05.486 A:middle
state your app uses and the

00:33:05.486 --> 00:33:07.116 A:middle
number of pipeline objects

00:33:07.556 --> 00:33:07.706 A:middle
needed.

00:33:08.976 --> 00:33:10.786 A:middle
However, not everyone knows up

00:33:10.846 --> 00:33:12.286 A:middle
front which pipelines their app

00:33:12.286 --> 00:33:12.656 A:middle
will need.

00:33:13.286 --> 00:33:14.666 A:middle
A common first step in porting

00:33:14.666 --> 00:33:16.306 A:middle
an app to Metal is to keep a

00:33:16.306 --> 00:33:17.786 A:middle
dictionary of pipelines you've

00:33:17.786 --> 00:33:18.396 A:middle
already made.

00:33:19.326 --> 00:33:20.566 A:middle
As your app encounters new

00:33:20.566 --> 00:33:22.196 A:middle
combinations of state it can

00:33:22.196 --> 00:33:23.836 A:middle
build and store pipelines using

00:33:23.836 --> 00:33:25.326 A:middle
the descriptors as keys.

00:33:26.626 --> 00:33:28.206 A:middle
Keep in mind this solution I

00:33:28.206 --> 00:33:30.326 A:middle
mentioned is kind of a hack and

00:33:30.326 --> 00:33:31.406 A:middle
you want to avoid shipping your

00:33:31.406 --> 00:33:31.856 A:middle
app with it.

00:33:32.426 --> 00:33:33.856 A:middle
This is because creating any of

00:33:33.856 --> 00:33:35.316 A:middle
these objects is expensive.

00:33:36.346 --> 00:33:37.196 A:middle
When you create a pipeline

00:33:37.196 --> 00:33:39.336 A:middle
object the GPU compiler kicks in

00:33:39.336 --> 00:33:41.396 A:middle
and translates and optimizes the

00:33:41.396 --> 00:33:42.786 A:middle
shader's binary intermediate

00:33:42.786 --> 00:33:44.636 A:middle
representation to machine code.

00:33:45.386 --> 00:33:46.356 A:middle
If your app creates these

00:33:46.386 --> 00:33:47.986 A:middle
just-in-time during its render

00:33:47.986 --> 00:33:51.046 A:middle
loop you're likely to see stalls

00:33:51.356 --> 00:33:53.046 A:middle
and a reduced frame rate for a

00:33:53.046 --> 00:33:55.786 A:middle
short period of time.

00:33:55.986 --> 00:33:57.366 A:middle
Allocating memory for textures

00:33:57.366 --> 00:33:58.906 A:middle
and buffers is also an expensive

00:33:58.906 --> 00:34:00.526 A:middle
operation, that's not even


00:33:58.906 --> 00:34:00.526 A:middle
operation, that's not even

00:34:00.526 --> 00:34:01.586 A:middle
accounting for the processing

00:34:01.586 --> 00:34:02.896 A:middle
required to fill in these

00:34:02.896 --> 00:34:03.726 A:middle
resources with data.

00:34:04.946 --> 00:34:06.076 A:middle
However, once you've created

00:34:06.076 --> 00:34:07.866 A:middle
these objects using them in your

00:34:07.866 --> 00:34:09.646 A:middle
render loop requires very little

00:34:09.746 --> 00:34:11.045 A:middle
CPU over [inaudible] since so

00:34:11.045 --> 00:34:12.966 A:middle
much is done up front.

00:34:14.176 --> 00:34:15.485 A:middle
With that I'd like to hand it

00:34:15.485 --> 00:34:16.716 A:middle
over to Sukanya who will talk

00:34:16.716 --> 00:34:17.735 A:middle
about porting your render loop.

00:34:18.516 --> 00:34:22.545 A:middle
[ Applause ]

00:34:23.045 --> 00:34:24.065 A:middle
&gt;&gt; Good evening everyone, I am

00:34:24.065 --> 00:34:25.886 A:middle
Sukanya Sudugu, GPU software

00:34:25.886 --> 00:34:26.856 A:middle
engineer at Apple.

00:34:27.646 --> 00:34:29.696 A:middle
I am super excited to share some

00:34:29.696 --> 00:34:31.496 A:middle
of our porting experience with

00:34:31.496 --> 00:34:32.976 A:middle
you, so let's continue porting.

00:34:35.876 --> 00:34:37.096 A:middle
Dan already talked about

00:34:37.096 --> 00:34:39.496 A:middle
application setup, so by now you

00:34:39.496 --> 00:34:40.795 A:middle
would have built all your

00:34:40.795 --> 00:34:43.596 A:middle
shaders and also created all

00:34:43.596 --> 00:34:45.216 A:middle
persistent objects needed for

00:34:45.216 --> 00:34:46.275 A:middle
frame generation.

00:34:47.196 --> 00:34:48.656 A:middle
So now let's dive into your

00:34:48.656 --> 00:34:50.795 A:middle
application's render loop which

00:34:50.795 --> 00:34:52.516 A:middle
is the code that runs for every

00:34:52.516 --> 00:34:52.926 A:middle
frame.

00:34:53.186 --> 00:34:55.996 A:middle
With Metal you will explicitly

00:34:55.996 --> 00:34:57.616 A:middle
manage the asynchronous nature

00:34:57.616 --> 00:34:59.556 A:middle
of GPU's execution in your

00:34:59.556 --> 00:35:00.196 A:middle
render loop.


00:34:59.556 --> 00:35:00.196 A:middle
render loop.

00:35:00.876 --> 00:35:03.156 A:middle
So this includes obtaining and

00:35:03.206 --> 00:35:04.826 A:middle
submitting command buffers to

00:35:04.826 --> 00:35:06.426 A:middle
GPU with the list of GPU

00:35:06.426 --> 00:35:06.736 A:middle
commands.

00:35:06.736 --> 00:35:10.046 A:middle
And updating your resources in

00:35:10.046 --> 00:35:12.206 A:middle
such a way that allows the GPU

00:35:12.206 --> 00:35:13.926 A:middle
to asynchronously read from it

00:35:14.566 --> 00:35:16.086 A:middle
which you have written in your

00:35:16.176 --> 00:35:16.726 A:middle
render loop.

00:35:17.266 --> 00:35:19.526 A:middle
And encoding render passes by

00:35:19.526 --> 00:35:20.686 A:middle
creating render command

00:35:20.686 --> 00:35:21.326 A:middle
encoders.

00:35:21.936 --> 00:35:24.636 A:middle
And finally, presenting your

00:35:24.636 --> 00:35:25.776 A:middle
frames to the display.

00:35:25.776 --> 00:35:29.196 A:middle
So let's first talk about this

00:35:29.196 --> 00:35:30.356 A:middle
command buffer object.

00:35:32.396 --> 00:35:34.066 A:middle
One of the key changes from

00:35:34.066 --> 00:35:36.536 A:middle
OpenGL is that Metal provides

00:35:36.606 --> 00:35:38.196 A:middle
explicit control over command

00:35:38.196 --> 00:35:40.366 A:middle
buffers, which means it's up to

00:35:40.366 --> 00:35:42.396 A:middle
you to create these command

00:35:42.396 --> 00:35:44.106 A:middle
buffers and you can decide when

00:35:44.106 --> 00:35:45.766 A:middle
to commit them to GPU for its

00:35:45.766 --> 00:35:46.486 A:middle
execution.

00:35:47.306 --> 00:35:49.496 A:middle
So the straightforward thing to

00:35:49.496 --> 00:35:51.056 A:middle
do is to create one command

00:35:51.056 --> 00:35:52.476 A:middle
buffer which will render your

00:35:52.476 --> 00:35:53.236 A:middle
whole frame.

00:35:53.946 --> 00:35:55.796 A:middle
And once your application is up

00:35:55.796 --> 00:35:57.916 A:middle
and running and if you perhaps

00:35:57.916 --> 00:35:59.816 A:middle
see some idle time on GPU, then

00:35:59.816 --> 00:36:01.976 A:middle
you might want to consider


00:35:59.816 --> 00:36:01.976 A:middle
you might want to consider

00:36:02.146 --> 00:36:03.396 A:middle
splitting your frame across

00:36:03.396 --> 00:36:04.606 A:middle
multiple command buffers.

00:36:05.006 --> 00:36:08.086 A:middle
And then the GPU can get started

00:36:08.086 --> 00:36:09.796 A:middle
executing one command buffer

00:36:10.086 --> 00:36:11.486 A:middle
while CPU is encoding the

00:36:11.486 --> 00:36:11.886 A:middle
others.

00:36:13.346 --> 00:36:15.106 A:middle
Alternatively, splitting your

00:36:15.106 --> 00:36:17.386 A:middle
frame encoding across multiple

00:36:17.386 --> 00:36:19.136 A:middle
threads requires you to create

00:36:19.136 --> 00:36:20.436 A:middle
one command buffer per thread.

00:36:20.436 --> 00:36:23.196 A:middle
But keep in mind that there is

00:36:23.196 --> 00:36:25.056 A:middle
some additional CPU cost

00:36:25.056 --> 00:36:26.666 A:middle
associated with each command

00:36:26.666 --> 00:36:27.056 A:middle
buffer.

00:36:27.496 --> 00:36:29.446 A:middle
So you should be using as few as

00:36:29.516 --> 00:36:30.066 A:middle
possible.

00:36:32.216 --> 00:36:34.306 A:middle
Metal also provides an API to

00:36:34.356 --> 00:36:36.436 A:middle
register a completion callback,

00:36:37.136 --> 00:36:38.846 A:middle
which will be involved when GPU

00:36:38.846 --> 00:36:41.006 A:middle
completes executing this command

00:36:41.006 --> 00:36:41.386 A:middle
buffer.

00:36:41.986 --> 00:36:43.686 A:middle
So let me show you all these

00:36:43.686 --> 00:36:44.766 A:middle
APIs in action.

00:36:45.216 --> 00:36:48.316 A:middle
So you will have created command

00:36:48.316 --> 00:36:49.516 A:middle
queue in your application

00:36:49.516 --> 00:36:50.856 A:middle
initialization method.

00:36:51.356 --> 00:36:53.246 A:middle
Now in render loop you will use

00:36:53.246 --> 00:36:55.676 A:middle
it to obtain command buffer by

00:36:55.676 --> 00:36:56.876 A:middle
calling its command buffer

00:36:56.876 --> 00:36:57.386 A:middle
method.

00:36:57.946 --> 00:37:00.156 A:middle
Now you will encode commands


00:36:57.946 --> 00:37:00.156 A:middle
Now you will encode commands

00:37:00.156 --> 00:37:01.156 A:middle
into this command buffer.

00:37:01.156 --> 00:37:03.086 A:middle
I'll talk more about this

00:37:03.146 --> 00:37:04.616 A:middle
encoder shortly.

00:37:05.936 --> 00:37:06.936 A:middle
But when you are finished

00:37:06.936 --> 00:37:08.846 A:middle
encoding you will call commit

00:37:08.846 --> 00:37:11.446 A:middle
method so that this command

00:37:11.446 --> 00:37:13.136 A:middle
buffer will be submitted to GPU

00:37:13.386 --> 00:37:14.366 A:middle
for its execution.

00:37:14.366 --> 00:37:17.846 A:middle
Now you have two options for

00:37:17.916 --> 00:37:19.686 A:middle
what to do while this command

00:37:19.686 --> 00:37:21.806 A:middle
buffer is being executed on GPU.

00:37:22.316 --> 00:37:25.526 A:middle
You can wait by calling this

00:37:25.526 --> 00:37:27.436 A:middle
waitUntilCompleted method which

00:37:27.436 --> 00:37:29.256 A:middle
is similar to glFinish in

00:37:29.256 --> 00:37:29.956 A:middle
OpenGL.

00:37:30.896 --> 00:37:33.026 A:middle
This method will synchronously

00:37:33.026 --> 00:37:35.456 A:middle
wait and only returns when all

00:37:35.456 --> 00:37:36.636 A:middle
the commands in the command

00:37:36.636 --> 00:37:38.296 A:middle
buffer has been executed by the

00:37:38.296 --> 00:37:38.806 A:middle
GPU.

00:37:40.916 --> 00:37:44.816 A:middle
Alternatively, before you commit

00:37:44.816 --> 00:37:46.206 A:middle
this command buffer to GPU you

00:37:46.206 --> 00:37:48.566 A:middle
can add a completion handler,

00:37:49.406 --> 00:37:51.286 A:middle
which will be invoked when GPU

00:37:51.286 --> 00:37:52.916 A:middle
is done executing this command

00:37:52.916 --> 00:37:53.296 A:middle
buffer.

00:37:53.946 --> 00:37:56.476 A:middle
This allows CPU and GPU to

00:37:56.476 --> 00:37:57.576 A:middle
execute in parallel.

00:37:58.456 --> 00:38:00.486 A:middle
Also this allows us to track and


00:37:58.456 --> 00:38:00.486 A:middle
Also this allows us to track and

00:38:00.486 --> 00:38:02.116 A:middle
efficiently update shared

00:38:02.116 --> 00:38:04.236 A:middle
resources whose data is changing

00:38:04.236 --> 00:38:05.076 A:middle
every frame.

00:38:05.556 --> 00:38:08.676 A:middle
Since we are here let's talk

00:38:08.676 --> 00:38:09.876 A:middle
more about these resource

00:38:09.876 --> 00:38:12.486 A:middle
updates and see how we can make

00:38:12.486 --> 00:38:13.796 A:middle
them efficient using this

00:38:13.796 --> 00:38:14.656 A:middle
completion handler.

00:38:14.656 --> 00:38:18.626 A:middle
So almost all applications will

00:38:18.626 --> 00:38:21.066 A:middle
be pushing new data to GPU every

00:38:21.066 --> 00:38:21.436 A:middle
frame.

00:38:21.926 --> 00:38:24.206 A:middle
For example, new shaded uniforms

00:38:24.316 --> 00:38:25.716 A:middle
needed for animations.

00:38:26.256 --> 00:38:29.146 A:middle
In Metal CPU can write to this

00:38:29.146 --> 00:38:31.776 A:middle
shared resources anytime even if

00:38:31.886 --> 00:38:33.966 A:middle
GP is accessing the same memory

00:38:35.206 --> 00:38:36.276 A:middle
at the same time.

00:38:37.376 --> 00:38:38.876 A:middle
Metal does not protect you

00:38:38.876 --> 00:38:40.456 A:middle
against these data-races.

00:38:41.256 --> 00:38:44.176 A:middle
This compares to OpenGL which by

00:38:44.176 --> 00:38:45.666 A:middle
default prevents these

00:38:45.666 --> 00:38:48.056 A:middle
data-races either by waiting for

00:38:48.056 --> 00:38:50.676 A:middle
the GPU workloads to finish or

00:38:50.676 --> 00:38:53.166 A:middle
by doing extra copies, which may

00:38:53.166 --> 00:38:54.586 A:middle
not be optimal for your

00:38:54.586 --> 00:38:55.376 A:middle
application.

00:38:56.256 --> 00:38:58.756 A:middle
With Metal you can implement any

00:38:58.756 --> 00:39:01.546 A:middle
optimal synchronization strategy


00:38:58.756 --> 00:39:01.546 A:middle
optimal synchronization strategy

00:39:01.546 --> 00:39:02.566 A:middle
which suits best for your

00:39:02.566 --> 00:39:03.376 A:middle
applications.

00:39:04.256 --> 00:39:06.966 A:middle
So in most cases, best approach

00:39:07.026 --> 00:39:08.686 A:middle
is to multi-buffer your shared

00:39:08.686 --> 00:39:11.706 A:middle
resources so that CPU and GPU

00:39:11.706 --> 00:39:13.286 A:middle
are never trying to access the

00:39:13.286 --> 00:39:15.136 A:middle
same buffer simultaneously.

00:39:17.436 --> 00:39:19.916 A:middle
So let's see an example, you

00:39:19.916 --> 00:39:22.126 A:middle
have an OpenGL application and

00:39:22.126 --> 00:39:24.676 A:middle
you just ported it to Metal and

00:39:24.736 --> 00:39:26.296 A:middle
it is using single buffer for

00:39:26.296 --> 00:39:28.956 A:middle
these dynamic data updates and

00:39:28.956 --> 00:39:30.386 A:middle
you did not implement any

00:39:30.386 --> 00:39:32.766 A:middle
synchronization method yet in

00:39:32.766 --> 00:39:34.306 A:middle
your application, then here's

00:39:34.306 --> 00:39:36.356 A:middle
what will happen.

00:39:36.906 --> 00:39:38.316 A:middle
Your application will write to

00:39:38.316 --> 00:39:39.956 A:middle
that buffer while generating

00:39:39.956 --> 00:39:41.866 A:middle
commands for the first frame and

00:39:41.866 --> 00:39:43.336 A:middle
then submits this command buffer

00:39:43.336 --> 00:39:45.426 A:middle
to GPU.

00:39:45.426 --> 00:39:47.406 A:middle
Then GPU when it is executing

00:39:47.406 --> 00:39:48.876 A:middle
this command buffer will try to

00:39:48.876 --> 00:39:49.896 A:middle
read from this buffer.

00:39:50.436 --> 00:39:53.796 A:middle
And while you're updating the

00:39:53.796 --> 00:39:55.446 A:middle
same buffer for the next frame

00:39:55.686 --> 00:39:57.486 A:middle
GPU is still reading from this

00:39:57.486 --> 00:39:57.816 A:middle
buffer.

00:39:58.076 --> 00:40:01.266 A:middle
So this is clearly a race


00:39:58.076 --> 00:40:01.266 A:middle
So this is clearly a race

00:40:01.266 --> 00:40:03.236 A:middle
condition and the results are

00:40:03.236 --> 00:40:03.806 A:middle
undefined.

00:40:03.806 --> 00:40:06.826 A:middle
There are a few potential fixes

00:40:07.356 --> 00:40:09.066 A:middle
which you can implement in your

00:40:09.066 --> 00:40:09.806 A:middle
application.

00:40:10.396 --> 00:40:13.386 A:middle
The simplest is to call the

00:40:13.386 --> 00:40:14.396 A:middle
command buffer's

00:40:14.396 --> 00:40:16.736 A:middle
waitUntilCompleted method after

00:40:16.736 --> 00:40:17.306 A:middle
every frame.

00:40:18.516 --> 00:40:22.556 A:middle
But this waits for the GPU to

00:40:22.556 --> 00:40:24.246 A:middle
finish reading before you

00:40:24.246 --> 00:40:25.706 A:middle
override this buffer for the

00:40:25.706 --> 00:40:26.296 A:middle
next frame.

00:40:27.096 --> 00:40:30.936 A:middle
But as you can see, here this is

00:40:30.936 --> 00:40:32.866 A:middle
a very poor utilization of both

00:40:33.036 --> 00:40:35.606 A:middle
CPU and GPU, so this is not

00:40:35.606 --> 00:40:37.376 A:middle
something you want to do in your

00:40:37.466 --> 00:40:38.166 A:middle
shipping code.

00:40:38.936 --> 00:40:40.756 A:middle
But it is very useful to get

00:40:40.756 --> 00:40:42.426 A:middle
your Metal application up and

00:40:42.426 --> 00:40:42.856 A:middle
running.

00:40:43.746 --> 00:40:45.976 A:middle
And even to detect that if your

00:40:45.976 --> 00:40:47.766 A:middle
application really indeed has

00:40:47.766 --> 00:40:49.716 A:middle
these kind of data conflicts.

00:40:51.756 --> 00:40:54.366 A:middle
The efficient way to synchronize

00:40:54.366 --> 00:40:55.926 A:middle
your resource updates is to use

00:40:55.926 --> 00:40:56.826 A:middle
multiple buffers.

00:40:57.546 --> 00:40:58.906 A:middle
So in this case we will use

00:40:58.956 --> 00:41:00.526 A:middle
three buffers to triple buffer


00:40:58.956 --> 00:41:00.526 A:middle
three buffers to triple buffer

00:41:00.526 --> 00:41:02.126 A:middle
our dynamic data updates.

00:41:02.816 --> 00:41:04.756 A:middle
So in frame 1 we will write to a

00:41:04.756 --> 00:41:06.846 A:middle
buffer and then the GPU will

00:41:06.846 --> 00:41:07.516 A:middle
read from it.

00:41:08.206 --> 00:41:10.166 A:middle
And in frame 2 we will write to

00:41:10.166 --> 00:41:11.856 A:middle
another buffer avoiding this

00:41:11.856 --> 00:41:12.666 A:middle
race condition.

00:41:13.326 --> 00:41:15.246 A:middle
Similarly, in frame 3 we will

00:41:15.246 --> 00:41:18.146 A:middle
write the third buffer.

00:41:18.346 --> 00:41:20.176 A:middle
But now we have used up all

00:41:20.176 --> 00:41:21.836 A:middle
three buffers and exhausted our

00:41:21.836 --> 00:41:22.406 A:middle
buffer pool.

00:41:23.526 --> 00:41:25.246 A:middle
We need to wait for the GPU to

00:41:25.246 --> 00:41:27.166 A:middle
finish the frame 1 so that we

00:41:27.166 --> 00:41:28.616 A:middle
can reuse it for frame 4.

00:41:29.186 --> 00:41:33.736 A:middle
Now this completion handler will

00:41:33.736 --> 00:41:35.906 A:middle
come handy, it will let us know

00:41:35.906 --> 00:41:38.046 A:middle
when GPU has done executing this

00:41:38.096 --> 00:41:38.406 A:middle
frame.

00:41:39.096 --> 00:41:41.396 A:middle
So when frame 1 is done we can

00:41:41.396 --> 00:41:43.586 A:middle
reuse its buffer for frame 4 and

00:41:44.396 --> 00:41:44.916 A:middle
so on.

00:41:44.916 --> 00:41:48.696 A:middle
So let's look at a sample.

00:41:49.226 --> 00:41:52.916 A:middle
For triple buffer implementation

00:41:53.326 --> 00:41:55.316 A:middle
outside your render loop first

00:41:55.316 --> 00:41:56.996 A:middle
we will create a FIFO queue of

00:41:57.086 --> 00:41:57.726 A:middle
three buffers.

00:41:58.286 --> 00:42:01.006 A:middle
And we also need a


00:41:58.286 --> 00:42:01.006 A:middle
And we also need a

00:42:01.006 --> 00:42:02.616 A:middle
frameBoundarySemaphore which is

00:42:02.616 --> 00:42:04.466 A:middle
initialized to start value as 3.

00:42:05.096 --> 00:42:06.906 A:middle
So this says semaphore will be

00:42:06.906 --> 00:42:09.276 A:middle
signaled at each frame boundary,

00:42:09.576 --> 00:42:11.246 A:middle
that is when GPU finishes

00:42:11.246 --> 00:42:14.046 A:middle
executing a frame allowing the

00:42:14.046 --> 00:42:17.466 A:middle
CPU to reuse its buffer.

00:42:17.466 --> 00:42:19.826 A:middle
Also initialize buffer index to

00:42:19.826 --> 00:42:22.706 A:middle
point to the current frame's

00:42:23.336 --> 00:42:23.466 A:middle
buffer.

00:42:23.806 --> 00:42:26.386 A:middle
And in our render loop before we

00:42:26.386 --> 00:42:28.006 A:middle
write to a buffer we need to

00:42:28.006 --> 00:42:30.006 A:middle
first ensure that its

00:42:30.006 --> 00:42:31.276 A:middle
corresponding frame has

00:42:31.326 --> 00:42:33.176 A:middle
completed its execution on the

00:42:33.376 --> 00:42:33.926 A:middle
GPU.

00:42:34.366 --> 00:42:35.836 A:middle
So at the beginning of the frame

00:42:36.236 --> 00:42:37.386 A:middle
we wait on our

00:42:37.386 --> 00:42:38.656 A:middle
frameBoundarySemaphore.

00:42:39.696 --> 00:42:41.386 A:middle
Once the semaphore is signaled

00:42:41.506 --> 00:42:42.786 A:middle
indicating that the current

00:42:42.786 --> 00:42:44.166 A:middle
frame has completed its

00:42:44.166 --> 00:42:46.126 A:middle
execution on GPU now it's safe

00:42:47.536 --> 00:42:50.846 A:middle
to grab its buffer and reuse for

00:42:50.846 --> 00:42:51.716 A:middle
new frame data.

00:42:52.406 --> 00:42:55.426 A:middle
And we will now encode some

00:42:55.426 --> 00:42:57.846 A:middle
commands to bind this buffer to

00:42:58.886 --> 00:42:59.176 A:middle
GPU.

00:42:59.176 --> 00:43:01.186 A:middle
And before we commit this


00:42:59.176 --> 00:43:01.186 A:middle
And before we commit this

00:43:01.186 --> 00:43:03.066 A:middle
command buffer to GPU we will

00:43:03.066 --> 00:43:05.156 A:middle
add a completion handler to this

00:43:05.156 --> 00:43:06.556 A:middle
command buffer for this frame.

00:43:07.186 --> 00:43:10.066 A:middle
After adding completion handler

00:43:10.066 --> 00:43:11.166 A:middle
we will commit this command

00:43:11.166 --> 00:43:12.026 A:middle
buffer to GPU.

00:43:12.926 --> 00:43:16.036 A:middle
Now once GPU finishes executing

00:43:16.036 --> 00:43:17.806 A:middle
this frame our completion

00:43:17.806 --> 00:43:19.846 A:middle
handler will be invoked which

00:43:19.846 --> 00:43:21.486 A:middle
will then signal this frame

00:43:21.486 --> 00:43:22.006 A:middle
semaphore.

00:43:23.766 --> 00:43:26.156 A:middle
This allows CPU to reuse its

00:43:26.186 --> 00:43:27.986 A:middle
buffer for new frame encoding.

00:43:28.786 --> 00:43:30.666 A:middle
So this was a simple triple

00:43:30.666 --> 00:43:32.196 A:middle
buffer implementation which you

00:43:32.196 --> 00:43:33.846 A:middle
can adopt for handling any

00:43:33.846 --> 00:43:35.996 A:middle
dynamic data resource updates.

00:43:36.476 --> 00:43:39.376 A:middle
Now that we have our command

00:43:39.376 --> 00:43:41.426 A:middle
buffer and also, we have handled

00:43:41.726 --> 00:43:44.246 A:middle
our resource updates let's talk

00:43:44.246 --> 00:43:46.136 A:middle
more about render pass encoders

00:43:46.626 --> 00:43:48.306 A:middle
which you will use to encode

00:43:48.306 --> 00:43:49.796 A:middle
your draw calls.

00:43:50.276 --> 00:43:52.496 A:middle
As Dan mentioned earlier,

00:43:52.496 --> 00:43:56.906 A:middle
command encoders translate API

00:43:57.146 --> 00:43:59.046 A:middle
calls into GPU hardware commands

00:43:59.046 --> 00:43:59.926 A:middle
in a command buffer.

00:43:59.926 --> 00:44:02.936 A:middle
I will be talking about render


00:43:59.926 --> 00:44:02.936 A:middle
I will be talking about render

00:44:02.936 --> 00:44:04.626 A:middle
command encoders which provides

00:44:04.626 --> 00:44:06.656 A:middle
APIs for typical graphics,

00:44:06.816 --> 00:44:08.216 A:middle
operations like setting your

00:44:08.216 --> 00:44:10.186 A:middle
pipelines, texture buffer

00:44:10.186 --> 00:44:11.696 A:middle
objects, and also issuing the

00:44:11.696 --> 00:44:12.276 A:middle
draw calls.

00:44:12.786 --> 00:44:16.816 A:middle
So when creating your encoder

00:44:16.966 --> 00:44:18.336 A:middle
you need to first set the render

00:44:18.336 --> 00:44:18.906 A:middle
targets.

00:44:18.936 --> 00:44:20.756 A:middle
So here is a render pass

00:44:20.756 --> 00:44:22.396 A:middle
descriptor where you will set

00:44:22.396 --> 00:44:24.746 A:middle
the render targets and then ask

00:44:24.746 --> 00:44:26.586 A:middle
the command buffer to create a

00:44:26.586 --> 00:44:28.256 A:middle
new encoder for this render

00:44:28.256 --> 00:44:28.706 A:middle
pass.

00:44:29.366 --> 00:44:31.186 A:middle
And now you can use this encoder

00:44:31.186 --> 00:44:33.256 A:middle
to encode your draw calls.

00:44:35.136 --> 00:44:37.946 A:middle
One key change from OpenGL is in

00:44:38.106 --> 00:44:40.666 A:middle
Metal once the encoder is

00:44:40.666 --> 00:44:42.736 A:middle
created you cannot change its

00:44:42.736 --> 00:44:45.606 A:middle
render targets because GPU

00:44:45.696 --> 00:44:47.646 A:middle
performs much better when it

00:44:47.646 --> 00:44:49.776 A:middle
sees a largest span of draw

00:44:49.776 --> 00:44:51.436 A:middle
calls which are rendering to the

00:44:51.436 --> 00:44:53.106 A:middle
same set of render targets.

00:44:54.046 --> 00:44:56.906 A:middle
So Metal API reflects this by

00:44:57.246 --> 00:44:59.876 A:middle
giving an explicit start and end

00:44:59.956 --> 00:45:00.906 A:middle
to a render pass.


00:44:59.956 --> 00:45:00.906 A:middle
to a render pass.

00:45:01.316 --> 00:45:03.636 A:middle
Now all the draws issued by this

00:45:03.636 --> 00:45:05.596 A:middle
encoder will be rendering to

00:45:05.596 --> 00:45:06.936 A:middle
these render targets.

00:45:08.566 --> 00:45:09.816 A:middle
When you want to draw to a

00:45:09.816 --> 00:45:11.406 A:middle
different set of render targets

00:45:11.576 --> 00:45:13.246 A:middle
then you end this render pass

00:45:13.246 --> 00:45:14.226 A:middle
and start a new one.

00:45:14.756 --> 00:45:18.936 A:middle
And here is where we are

00:45:18.936 --> 00:45:20.286 A:middle
creating a render pass

00:45:20.286 --> 00:45:22.916 A:middle
descriptor and binding color and

00:45:22.916 --> 00:45:23.876 A:middle
depth attachments.

00:45:25.166 --> 00:45:27.036 A:middle
Now you can use that descriptor

00:45:27.086 --> 00:45:29.026 A:middle
and create a render command

00:45:29.026 --> 00:45:29.716 A:middle
encoder.

00:45:30.436 --> 00:45:33.116 A:middle
Now all the draws issued by this

00:45:33.116 --> 00:45:34.506 A:middle
encoder will be rendering to

00:45:34.506 --> 00:45:34.966 A:middle
these targets.

00:45:37.216 --> 00:45:39.426 A:middle
Additionally, in Metal you can

00:45:39.426 --> 00:45:41.856 A:middle
also provide load and store

00:45:41.856 --> 00:45:43.546 A:middle
actions for these attachments

00:45:43.786 --> 00:45:45.526 A:middle
for optional GPU bandwidth

00:45:45.526 --> 00:45:46.126 A:middle
usage.

00:45:48.236 --> 00:45:50.076 A:middle
So these load and store actions

00:45:50.076 --> 00:45:52.086 A:middle
allow you to control how the

00:45:52.086 --> 00:45:53.796 A:middle
texture contents will be handled

00:45:53.956 --> 00:45:55.486 A:middle
before and after a rendered

00:45:55.526 --> 00:45:55.876 A:middle
pass.

00:45:56.266 --> 00:45:59.016 A:middle
So here we have color and depth

00:45:59.016 --> 00:46:01.856 A:middle
attachments for a render pass.


00:45:59.016 --> 00:46:01.856 A:middle
attachments for a render pass.

00:46:02.066 --> 00:46:03.856 A:middle
If it specified the load action

00:46:03.856 --> 00:46:05.906 A:middle
as clear for both of these

00:46:05.906 --> 00:46:08.346 A:middle
render targets the GPU will

00:46:08.386 --> 00:46:09.836 A:middle
first clear their contents.

00:46:10.266 --> 00:46:13.246 A:middle
Then the GPU will execute

00:46:13.246 --> 00:46:14.556 A:middle
commands in this encoder

00:46:14.556 --> 00:46:15.686 A:middle
rendering to these render

00:46:15.686 --> 00:46:16.346 A:middle
targets.

00:46:16.886 --> 00:46:19.616 A:middle
Now you can specify the store

00:46:19.616 --> 00:46:21.026 A:middle
actions to be performed at the

00:46:21.136 --> 00:46:22.176 A:middle
end of the render pass.

00:46:22.536 --> 00:46:24.486 A:middle
Here for the color buffer since

00:46:24.486 --> 00:46:25.996 A:middle
the store action is store it

00:46:25.996 --> 00:46:28.656 A:middle
will preserve the contents of

00:46:28.686 --> 00:46:30.256 A:middle
this color buffer at the end of

00:46:30.256 --> 00:46:30.966 A:middle
the render pass.

00:46:31.576 --> 00:46:33.006 A:middle
And for the depth attachment,

00:46:33.006 --> 00:46:35.286 A:middle
since we said store action as

00:46:35.286 --> 00:46:37.176 A:middle
don't care it will discard its

00:46:37.176 --> 00:46:37.786 A:middle
contents.

00:46:39.006 --> 00:46:40.876 A:middle
So these texture load and stores

00:46:40.876 --> 00:46:42.806 A:middle
are expensive GPU operations

00:46:42.806 --> 00:46:44.376 A:middle
that consumes memory bandwidth.

00:46:44.946 --> 00:46:47.346 A:middle
So choose clear and don't care

00:46:47.346 --> 00:46:48.416 A:middle
wherever possible.

00:46:48.976 --> 00:46:51.816 A:middle
And here is how you set your

00:46:51.896 --> 00:46:52.246 A:middle
action.

00:46:52.526 --> 00:46:54.876 A:middle
In this example we specify clear

00:46:54.876 --> 00:46:57.246 A:middle
as a load action and set the

00:46:57.286 --> 00:46:57.966 A:middle
clear color.

00:46:59.186 --> 00:47:00.806 A:middle
And here we specify store action


00:46:59.186 --> 00:47:00.806 A:middle
And here we specify store action

00:47:00.806 --> 00:47:01.236 A:middle
as store.

00:47:01.806 --> 00:47:03.656 A:middle
Similarly, you can specify load

00:47:03.656 --> 00:47:05.636 A:middle
and store action for each of the

00:47:05.636 --> 00:47:07.196 A:middle
render targets you set in this

00:47:07.196 --> 00:47:08.326 A:middle
render pass descriptor.

00:47:08.926 --> 00:47:11.936 A:middle
So that's how we configured our

00:47:11.936 --> 00:47:12.896 A:middle
render targets.

00:47:12.946 --> 00:47:16.596 A:middle
Now you can create the encoder

00:47:16.596 --> 00:47:19.076 A:middle
from this descriptor and we can

00:47:19.076 --> 00:47:20.526 A:middle
start encoding draw calls.

00:47:21.886 --> 00:47:23.606 A:middle
But before that I want to show

00:47:23.606 --> 00:47:25.756 A:middle
you some OpenGL commands and

00:47:25.756 --> 00:47:27.326 A:middle
they will show you their Metal

00:47:27.326 --> 00:47:28.146 A:middle
equivalents.

00:47:28.686 --> 00:47:31.976 A:middle
So this is a typical OpenGL draw

00:47:31.976 --> 00:47:32.626 A:middle
sequence.

00:47:33.156 --> 00:47:36.526 A:middle
In this segment first we bind a

00:47:36.526 --> 00:47:38.776 A:middle
frame buffer which will set all

00:47:38.776 --> 00:47:39.826 A:middle
the render targets.

00:47:41.096 --> 00:47:42.966 A:middle
Then we bind our program which

00:47:42.966 --> 00:47:45.056 A:middle
contains vertex and fragment

00:47:45.536 --> 00:47:45.676 A:middle
shader.

00:47:46.226 --> 00:47:48.206 A:middle
And we bind vertex buffer

00:47:48.206 --> 00:47:49.676 A:middle
containing vertex data.

00:47:50.136 --> 00:47:53.036 A:middle
And then we bind another buffer

00:47:53.036 --> 00:47:54.576 A:middle
containing all the uniforms.

00:47:55.416 --> 00:47:57.686 A:middle
And then we'll set a texture to

00:47:57.686 --> 00:47:58.536 A:middle
sample from.

00:47:59.776 --> 00:48:00.916 A:middle
And finally, we draw.


00:47:59.776 --> 00:48:00.916 A:middle
And finally, we draw.

00:48:01.546 --> 00:48:03.956 A:middle
So here is the Metal equivalent,

00:48:04.566 --> 00:48:05.956 A:middle
it's a few more lines of code

00:48:05.996 --> 00:48:07.936 A:middle
since it's explicit but it's

00:48:07.936 --> 00:48:09.766 A:middle
actually very similar to OpenGL.

00:48:10.586 --> 00:48:11.866 A:middle
First, we create a render

00:48:11.866 --> 00:48:13.336 A:middle
command encoder using render

00:48:13.336 --> 00:48:15.456 A:middle
pass descriptor which has our

00:48:15.456 --> 00:48:16.346 A:middle
render targets.

00:48:17.696 --> 00:48:19.296 A:middle
Then we set a pipeline object

00:48:19.296 --> 00:48:20.506 A:middle
which has our shaders.

00:48:21.836 --> 00:48:24.606 A:middle
Then we set a buffer for

00:48:24.606 --> 00:48:26.276 A:middle
accessing our vertex shader and

00:48:26.676 --> 00:48:27.836 A:middle
this happens to contain the

00:48:27.836 --> 00:48:29.226 A:middle
vertices we will draw with.

00:48:30.436 --> 00:48:32.316 A:middle
Note that the Metal doesn't

00:48:32.316 --> 00:48:33.846 A:middle
distinguish between buffers

00:48:33.846 --> 00:48:36.026 A:middle
containing uniforms or those

00:48:36.026 --> 00:48:37.176 A:middle
containing vertices.

00:48:37.816 --> 00:48:40.276 A:middle
So we will use the same API to

00:48:40.276 --> 00:48:41.386 A:middle
set uniform buffer.

00:48:41.386 --> 00:48:44.026 A:middle
So here the first call will give

00:48:44.026 --> 00:48:46.026 A:middle
buffer access to vertex shader

00:48:46.026 --> 00:48:47.236 A:middle
while the second call will give

00:48:47.236 --> 00:48:48.746 A:middle
access to the fragment shader.

00:48:49.286 --> 00:48:52.166 A:middle
Next, we set a texture for our

00:48:52.166 --> 00:48:54.026 A:middle
fragment shader to sample from.

00:48:54.516 --> 00:48:56.556 A:middle
And then we draw.

00:48:57.076 --> 00:48:59.846 A:middle
And once we are done encoding

00:48:59.846 --> 00:49:01.456 A:middle
commands we will indicate this


00:48:59.846 --> 00:49:01.456 A:middle
commands we will indicate this

00:49:01.456 --> 00:49:03.396 A:middle
to Metal by calling endEncoding

00:49:03.396 --> 00:49:05.376 A:middle
on the encoder object.

00:49:06.196 --> 00:49:07.916 A:middle
So this was a simple example of

00:49:07.916 --> 00:49:09.406 A:middle
a metal render pass.

00:49:09.926 --> 00:49:12.926 A:middle
Now that we have a complete

00:49:12.926 --> 00:49:14.696 A:middle
render pass let's see how to get

00:49:14.696 --> 00:49:16.286 A:middle
these renderings onto the

00:49:16.286 --> 00:49:16.806 A:middle
display.

00:49:17.336 --> 00:49:21.526 A:middle
With OpenGL you present your

00:49:21.526 --> 00:49:23.156 A:middle
rendered frame onto the screen

00:49:23.436 --> 00:49:25.336 A:middle
but you don't explicitly manage

00:49:25.336 --> 00:49:27.996 A:middle
the system's render buffers also

00:49:27.996 --> 00:49:29.006 A:middle
known as drawables.

00:49:30.336 --> 00:49:32.126 A:middle
But with Metal to get your

00:49:32.126 --> 00:49:34.476 A:middle
content displayed on the screen

00:49:34.906 --> 00:49:36.186 A:middle
first you need to obtain the

00:49:36.186 --> 00:49:37.516 A:middle
special textures called

00:49:37.516 --> 00:49:39.116 A:middle
drawables from the system.

00:49:39.746 --> 00:49:41.676 A:middle
So you can use a MetalKit view

00:49:41.816 --> 00:49:42.756 A:middle
which will provide you a

00:49:42.756 --> 00:49:44.846 A:middle
drawable texture for each frame.

00:49:45.426 --> 00:49:46.886 A:middle
And once you obtain this

00:49:46.886 --> 00:49:49.276 A:middle
drawable you can encode render

00:49:49.276 --> 00:49:51.226 A:middle
passes and render to these

00:49:51.226 --> 00:49:53.096 A:middle
drawables just like you would

00:49:53.096 --> 00:49:54.586 A:middle
render to any other texture.

00:49:55.126 --> 00:49:57.766 A:middle
However, unlike other textures

00:49:57.766 --> 00:49:59.236 A:middle
now you can present this

00:49:59.236 --> 00:49:59.976 A:middle
drawable to your view.


00:50:00.096 --> 00:50:02.506 A:middle
So let me show you a code

00:50:02.506 --> 00:50:02.996 A:middle
sample.

00:50:03.516 --> 00:50:06.196 A:middle
First, I want to mention that

00:50:06.196 --> 00:50:07.886 A:middle
these drawables are limited

00:50:08.166 --> 00:50:10.696 A:middle
shade system resources, so you

00:50:10.696 --> 00:50:12.206 A:middle
should hold on to them as

00:50:12.206 --> 00:50:13.536 A:middle
briefly as possible.

00:50:14.236 --> 00:50:15.776 A:middle
This means that you should

00:50:15.776 --> 00:50:18.096 A:middle
encode all your offscreen render

00:50:18.126 --> 00:50:20.016 A:middle
passes before you acquire a

00:50:20.016 --> 00:50:20.606 A:middle
drawable.

00:50:21.906 --> 00:50:23.626 A:middle
Then you can create a MetalKit

00:50:23.626 --> 00:50:26.856 A:middle
view for either a fully

00:50:26.856 --> 00:50:29.206 A:middle
populated render pass descriptor

00:50:29.466 --> 00:50:30.926 A:middle
which you can directly use to

00:50:30.926 --> 00:50:33.836 A:middle
create encoders, which is what

00:50:33.836 --> 00:50:36.336 A:middle
you see here or you can ask for

00:50:36.336 --> 00:50:37.746 A:middle
a specific texture using

00:50:37.976 --> 00:50:41.626 A:middle
view.currentDrawable property.

00:50:41.626 --> 00:50:42.706 A:middle
And then you can build your own

00:50:42.706 --> 00:50:44.276 A:middle
render pass descriptor around

00:50:45.016 --> 00:50:45.086 A:middle
it.

00:50:47.136 --> 00:50:48.846 A:middle
Once you are finished encoding

00:50:48.846 --> 00:50:50.496 A:middle
your frame you can call the

00:50:50.496 --> 00:50:51.896 A:middle
command buffer's present

00:50:51.896 --> 00:50:53.456 A:middle
drawable method which puts your

00:50:53.456 --> 00:50:55.626 A:middle
drawable onto the screen when

00:50:55.626 --> 00:50:57.466 A:middle
GPU finishes executing this

00:50:57.466 --> 00:50:58.166 A:middle
command buffer.

00:50:58.986 --> 00:51:00.946 A:middle
So now once GPU is done


00:50:58.986 --> 00:51:00.946 A:middle
So now once GPU is done

00:51:00.946 --> 00:51:02.586 A:middle
executing this frame you should

00:51:02.586 --> 00:51:04.116 A:middle
see your frame on the display.

00:51:04.646 --> 00:51:07.606 A:middle
So that was our quick tour to

00:51:07.606 --> 00:51:09.286 A:middle
get your renderings onto the

00:51:09.286 --> 00:51:10.596 A:middle
display with Metal.

00:51:11.156 --> 00:51:13.856 A:middle
But I have a few more tips to

00:51:13.856 --> 00:51:14.166 A:middle
share.

00:51:15.366 --> 00:51:17.296 A:middle
It is possible to port one

00:51:17.966 --> 00:51:19.596 A:middle
render pass at a time into

00:51:19.596 --> 00:51:19.936 A:middle
Metal.

00:51:19.936 --> 00:51:21.436 A:middle
The IOSurface and CVPixelBuffer

00:51:21.436 --> 00:51:25.696 A:middle
APIs can be used to create a

00:51:25.726 --> 00:51:27.596 A:middle
texture which can be shared

00:51:27.596 --> 00:51:29.266 A:middle
between OpenGL and Metal.

00:51:30.376 --> 00:51:32.586 A:middle
This will allow you to render to

00:51:32.586 --> 00:51:34.596 A:middle
a texture in OpenGL and then

00:51:34.596 --> 00:51:36.746 A:middle
read from it in Metal or vice

00:51:36.746 --> 00:51:36.926 A:middle
versa.

00:51:36.926 --> 00:51:39.876 A:middle
So some of the applications can

00:51:39.876 --> 00:51:41.616 A:middle
leverage this to port

00:51:41.616 --> 00:51:43.476 A:middle
incrementally, especially with

00:51:43.756 --> 00:51:45.076 A:middle
plugin architectures which are

00:51:45.076 --> 00:51:46.466 A:middle
built around OpenGL.

00:51:47.206 --> 00:51:49.546 A:middle
So there is a sample code linked

00:51:49.686 --> 00:51:51.796 A:middle
to this session showing exactly

00:51:51.796 --> 00:51:52.846 A:middle
on how to do this.

00:51:55.416 --> 00:51:56.796 A:middle
Now that you have a Metal

00:51:56.796 --> 00:51:58.806 A:middle
application you can adopt all

00:51:58.806 --> 00:51:59.906 A:middle
new Metal features.


00:52:01.076 --> 00:52:03.046 A:middle
If your application is CPU bound

00:52:03.046 --> 00:52:05.436 A:middle
then multithreading your CPU

00:52:05.436 --> 00:52:07.006 A:middle
encoding work can help.

00:52:07.746 --> 00:52:09.636 A:middle
You can encode multiple command

00:52:09.636 --> 00:52:11.316 A:middle
buffers simultaneously on

00:52:11.316 --> 00:52:12.346 A:middle
separate threads.

00:52:12.926 --> 00:52:14.776 A:middle
You can even split single

00:52:14.776 --> 00:52:16.556 A:middle
command buffer encoding across

00:52:16.556 --> 00:52:18.346 A:middle
multiple threads using parallel

00:52:18.346 --> 00:52:18.976 A:middle
render command encoder.

00:52:25.046 --> 00:52:26.926 A:middle
Also, GPUs compute by planned

00:52:26.926 --> 00:52:29.236 A:middle
processing APIs is built right

00:52:29.236 --> 00:52:30.186 A:middle
into Metal.

00:52:30.776 --> 00:52:32.946 A:middle
You can use GPU in whole new

00:52:32.946 --> 00:52:33.536 A:middle
ways.

00:52:34.046 --> 00:52:36.666 A:middle
To start with instead of CPU you

00:52:36.666 --> 00:52:38.976 A:middle
can leverage compute pipeline to

00:52:38.976 --> 00:52:40.746 A:middle
generate graphics GPU data.

00:52:41.336 --> 00:52:43.616 A:middle
By letting GPU to generate its

00:52:43.616 --> 00:52:45.346 A:middle
own data you're not only

00:52:45.346 --> 00:52:47.846 A:middle
reducing the CPU utilization and

00:52:47.846 --> 00:52:49.776 A:middle
synchronization points now you

00:52:49.776 --> 00:52:50.796 A:middle
are freeing up the data

00:52:50.796 --> 00:52:52.106 A:middle
bandwidth to GPU.

00:52:53.176 --> 00:52:54.946 A:middle
Now with this high bandwidth

00:52:55.246 --> 00:52:56.846 A:middle
compute processor you can

00:52:56.846 --> 00:52:58.456 A:middle
implement many more complex

00:52:58.456 --> 00:52:58.966 A:middle
algorithms like these.


00:53:03.356 --> 00:53:05.256 A:middle
Metal supports many more great

00:53:05.296 --> 00:53:07.216 A:middle
features which you can adopt in

00:53:07.216 --> 00:53:08.886 A:middle
your application to improve its

00:53:08.886 --> 00:53:09.706 A:middle
performance.

00:53:10.256 --> 00:53:13.556 A:middle
In addition, as part of your

00:53:13.596 --> 00:53:15.186 A:middle
porting process we highly

00:53:15.186 --> 00:53:17.406 A:middle
encourage to use our Metal

00:53:17.406 --> 00:53:19.096 A:middle
powerful debugging and

00:53:19.096 --> 00:53:21.226 A:middle
optimization tools which are

00:53:21.256 --> 00:53:23.456 A:middle
integrated right into Xcode.

00:53:24.446 --> 00:53:26.476 A:middle
So Metal has a great API

00:53:26.476 --> 00:53:28.536 A:middle
validation layer that will print

00:53:28.796 --> 00:53:30.816 A:middle
detailed information about any

00:53:30.816 --> 00:53:33.176 A:middle
improper API usage and also

00:53:33.176 --> 00:53:34.756 A:middle
suggests some potential fixes.

00:53:36.316 --> 00:53:38.826 A:middle
This is a GPU debugger which

00:53:38.826 --> 00:53:40.536 A:middle
gives you a capability to step

00:53:40.596 --> 00:53:42.706 A:middle
through your Metal calls and

00:53:42.706 --> 00:53:44.466 A:middle
view how your frame is being

00:53:44.466 --> 00:53:45.816 A:middle
rendered step-by-step.

00:53:46.726 --> 00:53:48.796 A:middle
You can view all the resources

00:53:48.796 --> 00:53:50.246 A:middle
associated with your frame.

00:53:50.926 --> 00:53:53.116 A:middle
It also provides the GPU expert

00:53:53.166 --> 00:53:54.436 A:middle
tips based on your resource

00:53:54.436 --> 00:53:55.036 A:middle
usage.

00:53:55.586 --> 00:53:58.916 A:middle
For this year we have also added

00:53:58.916 --> 00:54:00.556 A:middle
shader debugging capability


00:53:58.916 --> 00:54:00.556 A:middle
shader debugging capability

00:54:00.916 --> 00:54:02.326 A:middle
where you can debug your shader

00:54:02.326 --> 00:54:03.486 A:middle
functions just like other

00:54:03.486 --> 00:54:04.006 A:middle
functions.

00:54:04.516 --> 00:54:07.686 A:middle
We also added a shader profiler

00:54:07.956 --> 00:54:09.646 A:middle
which showing a rich set of

00:54:09.646 --> 00:54:11.266 A:middle
performance metrics related to

00:54:11.266 --> 00:54:11.936 A:middle
your shaders.

00:54:12.046 --> 00:54:15.556 A:middle
And also, a dependency viewer

00:54:15.556 --> 00:54:17.156 A:middle
which allows you to evaluate

00:54:17.156 --> 00:54:18.626 A:middle
dependencies between the render

00:54:18.626 --> 00:54:22.096 A:middle
passes and you can potentially

00:54:22.096 --> 00:54:24.336 A:middle
merge any redundant render

00:54:24.336 --> 00:54:26.726 A:middle
passes to improve your

00:54:26.726 --> 00:54:27.976 A:middle
application's performance.

00:54:30.216 --> 00:54:32.166 A:middle
And finally, the Metal system

00:54:32.166 --> 00:54:33.966 A:middle
trace tool in instruments will

00:54:33.966 --> 00:54:36.696 A:middle
give you a complete view of your

00:54:36.736 --> 00:54:38.486 A:middle
application's behavior and

00:54:38.486 --> 00:54:40.276 A:middle
performance so we highly

00:54:40.276 --> 00:54:42.396 A:middle
recommend using these tools to

00:54:42.396 --> 00:54:44.146 A:middle
ease your porting effort.

00:54:45.296 --> 00:54:47.906 A:middle
Wrapping it up, OpenGL and

00:54:47.906 --> 00:54:49.536 A:middle
OpenCL are deprecated.

00:54:49.536 --> 00:54:52.656 A:middle
They are still around but we are

00:54:52.656 --> 00:54:54.466 A:middle
discouraging their future use.

00:54:54.826 --> 00:54:56.526 A:middle
It is time to adopt Metal.

00:54:57.216 --> 00:54:59.106 A:middle
We have full suite of developer

00:54:59.106 --> 00:55:00.806 A:middle
tools, a lot of experience


00:54:59.106 --> 00:55:00.806 A:middle
tools, a lot of experience

00:55:00.806 --> 00:55:02.896 A:middle
helping many teams successfully

00:55:02.896 --> 00:55:04.616 A:middle
go through this effort and come

00:55:04.616 --> 00:55:06.376 A:middle
out with substantially improved

00:55:06.376 --> 00:55:07.006 A:middle
performance.

00:55:07.736 --> 00:55:09.236 A:middle
I'm hoping the information we

00:55:09.236 --> 00:55:10.846 A:middle
shared today will give you

00:55:10.846 --> 00:55:12.356 A:middle
smooth porting experience.

00:55:12.866 --> 00:55:15.846 A:middle
And we are very happy to talk to

00:55:15.846 --> 00:55:17.376 A:middle
you about your applications and

00:55:17.376 --> 00:55:18.836 A:middle
how to get them up and running

00:55:18.836 --> 00:55:19.406 A:middle
with Metal.

00:55:20.006 --> 00:55:21.776 A:middle
So we will be available tomorrow

00:55:21.776 --> 00:55:23.506 A:middle
afternoon at OpenGL to Metal

00:55:23.666 --> 00:55:25.736 A:middle
porting lab and there are many

00:55:25.736 --> 00:55:27.696 A:middle
upcoming sessions on Metal.

00:55:28.006 --> 00:55:29.426 A:middle
I recommend attending these

00:55:29.426 --> 00:55:31.546 A:middle
sessions to learn more about how

00:55:31.546 --> 00:55:33.106 A:middle
to debug and optimize your

00:55:33.106 --> 00:55:34.466 A:middle
applications with Metal.

00:55:36.106 --> 00:55:37.866 A:middle
With that I thank you all for

00:55:37.866 --> 00:55:39.706 A:middle
attending and I hope you enjoy

00:55:39.706 --> 00:55:40.716 A:middle
the rest of your week.

00:55:41.516 --> 00:55:44.500 A:middle
[ Applause ]
