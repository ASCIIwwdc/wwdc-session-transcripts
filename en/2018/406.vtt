WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ Music ]

00:00:27.516 --> 00:00:34.116 A:middle
[ Applause ]

00:00:34.616 --> 00:00:36.876 A:middle
Hi, everybody, I'm Ben.

00:00:37.016 --> 00:00:37.986 A:middle
I work on the Swift standard

00:00:37.986 --> 00:00:38.306 A:middle
library.

00:00:38.386 --> 00:00:39.686 A:middle
And together with my colleague

00:00:39.686 --> 00:00:40.816 A:middle
Doug, from the compiler team.

00:00:40.946 --> 00:00:42.326 A:middle
We're going to talk to you about

00:00:42.326 --> 00:00:43.136 A:middle
Swift generics.

00:00:43.726 --> 00:00:46.416 A:middle
So the recent releases of Swift

00:00:46.416 --> 00:00:47.536 A:middle
have added some important new

00:00:47.536 --> 00:00:48.056 A:middle
features.

00:00:48.826 --> 00:00:49.916 A:middle
Including conditional

00:00:49.916 --> 00:00:51.506 A:middle
conformance and recursive

00:00:51.506 --> 00:00:52.446 A:middle
protocol constraints.

00:00:53.536 --> 00:00:55.186 A:middle
And, in fact, with every release

00:00:55.186 --> 00:00:56.876 A:middle
of Swift, we've been refining

00:00:56.876 --> 00:00:58.506 A:middle
the generic system, making it

00:00:58.506 --> 00:00:59.266 A:middle
more expressive.

00:00:59.396 --> 00:01:01.926 A:middle
And we feel that the 4.2 release

00:00:59.396 --> 00:01:01.926 A:middle
And we feel that the 4.2 release

00:01:01.926 --> 00:01:03.166 A:middle
marks an important point.

00:01:04.296 --> 00:01:05.756 A:middle
It's the point where we can

00:01:05.756 --> 00:01:08.056 A:middle
finally fully implement a number

00:01:08.056 --> 00:01:09.226 A:middle
of designs that have always been

00:01:09.226 --> 00:01:10.096 A:middle
envisioned for the standard

00:01:10.096 --> 00:01:10.746 A:middle
library.

00:01:10.936 --> 00:01:12.196 A:middle
Something that's critical for us

00:01:12.626 --> 00:01:14.106 A:middle
in achieving our goal of API

00:01:14.106 --> 00:01:15.176 A:middle
stability for Swift.

00:01:16.696 --> 00:01:18.226 A:middle
So, we've given a lot of talks

00:01:18.226 --> 00:01:19.406 A:middle
about generics in the past, but

00:01:19.406 --> 00:01:20.516 A:middle
we haven't taken a step back.

00:01:20.546 --> 00:01:22.016 A:middle
And talked about generics as a

00:01:22.016 --> 00:01:22.756 A:middle
whole for a while.

00:01:23.496 --> 00:01:24.686 A:middle
So today, we're going to take

00:01:24.686 --> 00:01:26.306 A:middle
you through a few different

00:01:26.306 --> 00:01:27.436 A:middle
features of the generics system.

00:01:27.436 --> 00:01:29.626 A:middle
Both new and old, to help

00:01:29.626 --> 00:01:30.716 A:middle
understand how they fit

00:01:30.716 --> 00:01:31.026 A:middle
together.

00:01:31.026 --> 00:01:34.006 A:middle
I'm going to briefly recap the

00:01:34.006 --> 00:01:35.426 A:middle
motivation for generics.

00:01:37.076 --> 00:01:38.186 A:middle
We're going to talk about

00:01:38.186 --> 00:01:39.356 A:middle
designing protocols, given a

00:01:39.356 --> 00:01:41.116 A:middle
number of concrete types, using

00:01:41.116 --> 00:01:42.576 A:middle
examples taken from the standard

00:01:42.576 --> 00:01:43.236 A:middle
library.

00:01:44.016 --> 00:01:45.526 A:middle
We're going to review protocol

00:01:45.526 --> 00:01:47.146 A:middle
inheritance, and talk about the

00:01:47.146 --> 00:01:48.626 A:middle
new feature of conditional

00:01:48.626 --> 00:01:49.206 A:middle
conformance.

00:01:49.206 --> 00:01:50.186 A:middle
And how it interacts with

00:01:50.226 --> 00:01:51.176 A:middle
protocol inheritance.

00:01:51.996 --> 00:01:53.356 A:middle
And finally, we're going to wrap

00:01:53.356 --> 00:01:55.486 A:middle
up with a discussion of classes

00:01:55.486 --> 00:01:56.216 A:middle
and generics.

00:01:58.556 --> 00:01:59.796 A:middle
So why are generics such an

00:01:59.796 --> 00:02:01.026 A:middle
important part of Swift?

00:01:59.796 --> 00:02:01.026 A:middle
important part of Swift?

00:02:01.836 --> 00:02:03.236 A:middle
Well one way of seeing their

00:02:03.236 --> 00:02:05.486 A:middle
impact is by designing a simple

00:02:05.486 --> 00:02:06.606 A:middle
collection, like type.

00:02:08.205 --> 00:02:09.666 A:middle
We'll call it buffer, and it's

00:02:09.666 --> 00:02:10.536 A:middle
going to be similar to the

00:02:10.536 --> 00:02:11.816 A:middle
standard library's array type.

00:02:12.876 --> 00:02:14.586 A:middle
Now, the simplest possible API

00:02:14.586 --> 00:02:15.856 A:middle
for the reading part of a buffer

00:02:15.856 --> 00:02:17.276 A:middle
might include a count of the

00:02:17.276 --> 00:02:18.096 A:middle
number of elements.

00:02:18.366 --> 00:02:20.046 A:middle
And a way to fetch each element

00:02:20.046 --> 00:02:21.026 A:middle
to the given position in the

00:02:21.026 --> 00:02:21.516 A:middle
index.

00:02:22.086 --> 00:02:23.376 A:middle
But, what do we make of that

00:02:23.376 --> 00:02:24.016 A:middle
return type?

00:02:24.916 --> 00:02:26.336 A:middle
Now, if we didn't have generics,

00:02:26.336 --> 00:02:28.136 A:middle
we'd have to make it some kind

00:02:28.136 --> 00:02:29.126 A:middle
of type that could represent

00:02:29.126 --> 00:02:30.556 A:middle
anything that we'd want to put

00:02:30.556 --> 00:02:31.376 A:middle
inside the buffer.

00:02:32.096 --> 00:02:33.966 A:middle
You can call that type ID or

00:02:33.966 --> 00:02:35.226 A:middle
object or void star.

00:02:35.506 --> 00:02:38.006 A:middle
In Swift we call it Any, which

00:02:38.006 --> 00:02:39.566 A:middle
is a type that can stand in for

00:02:39.566 --> 00:02:40.936 A:middle
any different kind of type in

00:02:40.936 --> 00:02:41.306 A:middle
Swift.

00:02:44.006 --> 00:02:45.106 A:middle
So if you wanted to handle

00:02:45.106 --> 00:02:45.996 A:middle
anything in the buffer, you

00:02:45.996 --> 00:02:47.356 A:middle
could have subscript return an

00:02:47.356 --> 00:02:47.706 A:middle
Any.

00:02:48.086 --> 00:02:49.496 A:middle
But, of course, you probably

00:02:49.496 --> 00:02:50.466 A:middle
know that that leads to a really

00:02:50.466 --> 00:02:51.906 A:middle
unpleasant user experience.

00:02:52.136 --> 00:02:53.186 A:middle
At some point, you've got to get

00:02:53.186 --> 00:02:55.086 A:middle
out that type from inside the

00:02:55.086 --> 00:02:55.566 A:middle
box.

00:02:56.076 --> 00:02:57.906 A:middle
In order to actually use it.

00:03:00.576 --> 00:03:03.106 A:middle
And this isn't just annoying,

00:03:03.106 --> 00:03:04.406 A:middle
it's also error-prone.

00:03:04.826 --> 00:03:05.856 A:middle
What if somewhere in your code,

00:03:05.856 --> 00:03:07.806 A:middle
maybe by accident, you put an

00:03:07.806 --> 00:03:09.226 A:middle
integer into what was supposed

00:03:09.226 --> 00:03:10.286 A:middle
to be a buffer of strings?

00:03:11.226 --> 00:03:13.926 A:middle
But it's not just about ease of

00:03:13.926 --> 00:03:14.246 A:middle
use.

00:03:14.246 --> 00:03:15.246 A:middle
We also want to solve some

00:03:15.246 --> 00:03:16.856 A:middle
problems relating to how these

00:03:16.856 --> 00:03:18.506 A:middle
values are represented in

00:03:18.506 --> 00:03:18.876 A:middle
memory.

00:03:19.666 --> 00:03:23.106 A:middle
Now, the ideal representation

00:03:23.326 --> 00:03:24.986 A:middle
for a buffer of strings, would

00:03:24.986 --> 00:03:26.716 A:middle
be a contiguous block of memory.

00:03:27.146 --> 00:03:28.936 A:middle
With every element held in line

00:03:28.936 --> 00:03:29.626 A:middle
next to each other.

00:03:30.626 --> 00:03:32.566 A:middle
But with an untyped approach,

00:03:33.016 --> 00:03:34.076 A:middle
this doesn't work out quite so

00:03:34.076 --> 00:03:34.336 A:middle
well.

00:03:34.336 --> 00:03:35.646 A:middle
Because the buffer doesn't know

00:03:35.646 --> 00:03:37.856 A:middle
in advance what kind of type

00:03:37.856 --> 00:03:38.766 A:middle
it's going to contain.

00:03:38.766 --> 00:03:40.696 A:middle
And so it has to use a type like

00:03:40.746 --> 00:03:42.126 A:middle
Any that can account for any of

00:03:42.126 --> 00:03:42.936 A:middle
the possibilities.

00:03:43.236 --> 00:03:44.536 A:middle
And, there's a lot of overhead

00:03:44.776 --> 00:03:46.086 A:middle
in tracking, boxing, and

00:03:46.086 --> 00:03:49.146 A:middle
unboxing the types in that Any.

00:03:50.296 --> 00:03:52.436 A:middle
Here, I might have just wanted a

00:03:52.436 --> 00:03:54.056 A:middle
buffer of integers, but I have

00:03:54.186 --> 00:03:55.686 A:middle
no way of expressing that to the

00:03:55.686 --> 00:03:56.626 A:middle
compiler.

00:03:56.626 --> 00:03:57.616 A:middle
And so, I'm paying for

00:03:57.616 --> 00:03:59.176 A:middle
flexibility, even though I'm not

00:03:59.176 --> 00:04:01.266 A:middle
interested in it.

00:03:59.176 --> 00:04:01.266 A:middle
interested in it.

00:04:01.586 --> 00:04:02.976 A:middle
What's more, because Any has to

00:04:02.976 --> 00:04:04.526 A:middle
account for any different kind

00:04:04.526 --> 00:04:04.896 A:middle
of type.

00:04:05.466 --> 00:04:06.566 A:middle
Including types that are too

00:04:06.566 --> 00:04:08.686 A:middle
large to fit inside its own

00:04:08.686 --> 00:04:10.666 A:middle
internal storage, it has to

00:04:10.666 --> 00:04:11.866 A:middle
sometimes use indirection.

00:04:11.866 --> 00:04:13.456 A:middle
It has to hold a pointer to the

00:04:13.456 --> 00:04:14.886 A:middle
values, and that value could be

00:04:14.886 --> 00:04:16.565 A:middle
located all over memory.

00:04:17.886 --> 00:04:18.875 A:middle
And so we really want to solve

00:04:18.875 --> 00:04:20.136 A:middle
these problems, not just for

00:04:20.136 --> 00:04:21.526 A:middle
ease of use and correctness, but

00:04:21.526 --> 00:04:23.556 A:middle
also for performance reasons.

00:04:24.146 --> 00:04:26.126 A:middle
And, we do it using a technique

00:04:26.816 --> 00:04:28.556 A:middle
called parametric polymorphism.

00:04:29.376 --> 00:04:30.606 A:middle
Which is just another term for

00:04:30.606 --> 00:04:32.776 A:middle
what we in Swift refer to as

00:04:32.776 --> 00:04:33.446 A:middle
generics.

00:04:34.716 --> 00:04:36.476 A:middle
With a generic approach, we put

00:04:36.476 --> 00:04:38.346 A:middle
more information on the buffer,

00:04:38.346 --> 00:04:39.466 A:middle
to represent the type that the

00:04:39.466 --> 00:04:40.596 A:middle
buffer is going to contain.

00:04:41.746 --> 00:04:42.836 A:middle
We'll call that type Element.

00:04:44.196 --> 00:04:45.826 A:middle
Element is a generic parameter

00:04:45.826 --> 00:04:47.436 A:middle
of the type, hence the term of

00:04:47.436 --> 00:04:48.896 A:middle
parametric polymorphism.

00:04:49.096 --> 00:04:50.726 A:middle
You can think of it kind of like

00:04:50.726 --> 00:04:52.626 A:middle
a compile-time argument that

00:04:52.626 --> 00:04:53.926 A:middle
tells the buffer what it's going

00:04:53.926 --> 00:04:54.396 A:middle
to contain.

00:04:55.716 --> 00:04:56.946 A:middle
Now it has a way of referring to

00:04:56.946 --> 00:04:57.706 A:middle
that element type.

00:04:57.976 --> 00:04:59.106 A:middle
It can use it wherever it was

00:04:59.146 --> 00:05:00.316 A:middle
previously using Any.

00:04:59.146 --> 00:05:00.316 A:middle
previously using Any.

00:05:03.336 --> 00:05:04.216 A:middle
And, that means that there's no

00:05:04.216 --> 00:05:05.476 A:middle
need to do conversions when

00:05:05.476 --> 00:05:06.416 A:middle
you're getting a type out of the

00:05:06.416 --> 00:05:06.746 A:middle
buffer.

00:05:06.746 --> 00:05:09.106 A:middle
And if you make an accidental

00:05:09.296 --> 00:05:10.456 A:middle
assignment of the wrong kind of

00:05:10.456 --> 00:05:12.086 A:middle
type, or some issue similar to

00:05:12.086 --> 00:05:12.306 A:middle
that.

00:05:12.526 --> 00:05:13.566 A:middle
The compiler will catch you.

00:05:15.216 --> 00:05:17.136 A:middle
Now, now there's no such type as

00:05:17.136 --> 00:05:19.406 A:middle
buffer without an associated

00:05:19.406 --> 00:05:20.116 A:middle
element type.

00:05:20.836 --> 00:05:22.216 A:middle
If you try to declare a type

00:05:22.216 --> 00:05:23.646 A:middle
like that, you'll get a

00:05:23.646 --> 00:05:24.326 A:middle
compilation error.

00:05:26.176 --> 00:05:26.956 A:middle
You might find that slightly

00:05:26.956 --> 00:05:27.636 A:middle
surprising.

00:05:27.636 --> 00:05:29.106 A:middle
Because sometimes you'll see

00:05:29.106 --> 00:05:30.456 A:middle
that you can declare types like

00:05:30.516 --> 00:05:32.386 A:middle
buffer without any element type.

00:05:33.206 --> 00:05:33.926 A:middle
But, that's just because the

00:05:33.926 --> 00:05:35.716 A:middle
compiler is able to infer what

00:05:35.716 --> 00:05:36.896 A:middle
the element type ought to be

00:05:37.206 --> 00:05:38.126 A:middle
from the context.

00:05:38.546 --> 00:05:39.716 A:middle
In this case, from the literals

00:05:39.716 --> 00:05:40.676 A:middle
on the right-hand side here.

00:05:41.686 --> 00:05:43.846 A:middle
The element is still there, it's

00:05:43.846 --> 00:05:44.576 A:middle
just implicit.

00:05:46.356 --> 00:05:48.046 A:middle
This knowledge of exactly what

00:05:48.126 --> 00:05:50.506 A:middle
type a buff-- a type like buffer

00:05:50.506 --> 00:05:52.326 A:middle
contains is carried all the way

00:05:52.326 --> 00:05:54.276 A:middle
through both compile and

00:05:54.276 --> 00:05:54.886 A:middle
runtime.

00:05:55.596 --> 00:05:57.926 A:middle
And this means that we can

00:05:58.076 --> 00:05:59.576 A:middle
achieve our goal of holding all

00:05:59.576 --> 00:06:01.266 A:middle
of the elements in a contiguous

00:05:59.576 --> 00:06:01.266 A:middle
of the elements in a contiguous

00:06:01.306 --> 00:06:02.416 A:middle
block of memory, with no

00:06:02.416 --> 00:06:02.936 A:middle
overhead.

00:06:03.966 --> 00:06:05.476 A:middle
Even if those types are

00:06:05.476 --> 00:06:06.526 A:middle
arbitrarily large.

00:06:08.196 --> 00:06:09.866 A:middle
And because the compiler has

00:06:10.816 --> 00:06:12.416 A:middle
direct knowledge at all times of

00:06:12.416 --> 00:06:14.546 A:middle
exactly what element type the

00:06:14.546 --> 00:06:15.376 A:middle
buffer contains.

00:06:15.956 --> 00:06:16.976 A:middle
It has optimization

00:06:16.976 --> 00:06:18.356 A:middle
opportunities available to it

00:06:18.356 --> 00:06:19.646 A:middle
that it wouldn't otherwise have.

00:06:20.586 --> 00:06:21.796 A:middle
So, in the case here, where I've

00:06:21.796 --> 00:06:23.436 A:middle
declared a buffer of integers.

00:06:24.296 --> 00:06:25.686 A:middle
A loop like this ought to be

00:06:25.686 --> 00:06:27.366 A:middle
compiled down to just a handful

00:06:27.366 --> 00:06:28.766 A:middle
of very efficient CPU

00:06:28.766 --> 00:06:29.436 A:middle
instructions.

00:06:31.936 --> 00:06:32.876 A:middle
Now, if you were writing a loop

00:06:32.876 --> 00:06:36.186 A:middle
like this, on a regular basis.

00:06:36.546 --> 00:06:37.826 A:middle
To sum up a buffer of integers,

00:06:38.006 --> 00:06:39.336 A:middle
it might make sense to extract

00:06:39.336 --> 00:06:40.776 A:middle
it out into a method.

00:06:40.876 --> 00:06:44.086 A:middle
An extension on buffer that's

00:06:44.086 --> 00:06:45.526 A:middle
more unit-testable, and more

00:06:45.526 --> 00:06:46.966 A:middle
readable when you actually call

00:06:47.026 --> 00:06:47.206 A:middle
it.

00:06:48.356 --> 00:06:49.326 A:middle
But, you probably know that if

00:06:49.326 --> 00:06:50.306 A:middle
you've written code like this,

00:06:50.706 --> 00:06:52.026 A:middle
you'll get a compilation issue,

00:06:52.516 --> 00:06:54.466 A:middle
because not all element types

00:06:54.466 --> 00:06:57.366 A:middle
can be summed up like this.

00:06:57.666 --> 00:06:58.916 A:middle
We need to tell the compiler

00:06:59.126 --> 00:07:01.506 A:middle
more about the capabilities the

00:06:59.126 --> 00:07:01.506 A:middle
more about the capabilities the

00:07:01.506 --> 00:07:03.646 A:middle
element needs to have, in order

00:07:03.646 --> 00:07:05.636 A:middle
to make this method available on

00:07:05.636 --> 00:07:06.356 A:middle
a buffer.

00:07:07.136 --> 00:07:08.816 A:middle
Now, the easiest way to do that

00:07:08.816 --> 00:07:10.626 A:middle
is by constraining the element

00:07:10.626 --> 00:07:12.386 A:middle
type to be a specific type like

00:07:12.386 --> 00:07:13.856 A:middle
the Int from our original loop.

00:07:14.676 --> 00:07:18.366 A:middle
If you take this easy approach

00:07:18.366 --> 00:07:19.396 A:middle
to get up and running with your

00:07:19.396 --> 00:07:20.656 A:middle
extension, it's easy to

00:07:20.656 --> 00:07:21.726 A:middle
generalize it later.

00:07:22.176 --> 00:07:22.926 A:middle
When you find that you need to

00:07:22.926 --> 00:07:23.676 A:middle
do something different.

00:07:23.676 --> 00:07:25.296 A:middle
Like sum up a buffer of doubles,

00:07:25.296 --> 00:07:25.906 A:middle
or floats.

00:07:26.966 --> 00:07:28.256 A:middle
Just look at the type that

00:07:28.256 --> 00:07:29.226 A:middle
you've constrained to.

00:07:29.226 --> 00:07:31.006 A:middle
Look at the protocols it

00:07:31.006 --> 00:07:31.656 A:middle
conforms to.

00:07:31.846 --> 00:07:33.116 A:middle
And follow them up until you get

00:07:33.116 --> 00:07:34.816 A:middle
the most general protocol that

00:07:34.816 --> 00:07:35.736 A:middle
gives you everything that you

00:07:35.736 --> 00:07:36.626 A:middle
need to do your work.

00:07:37.686 --> 00:07:39.206 A:middle
In this case, the numeric

00:07:39.206 --> 00:07:40.646 A:middle
protocol, which gives us the two

00:07:40.646 --> 00:07:41.756 A:middle
things we're relying on here.

00:07:42.486 --> 00:07:44.876 A:middle
The ability to create a new

00:07:44.876 --> 00:07:46.596 A:middle
element with a value of zero,

00:07:46.596 --> 00:07:48.096 A:middle
and the ability to add elements

00:07:48.096 --> 00:07:48.476 A:middle
to it.

00:07:49.076 --> 00:07:49.876 A:middle
Which come as part of the

00:07:49.876 --> 00:07:50.676 A:middle
numeric protocol.

00:07:53.696 --> 00:07:54.776 A:middle
Now, let's talk about that

00:07:54.776 --> 00:07:56.156 A:middle
process of factoring out

00:07:56.246 --> 00:07:58.496 A:middle
protocols from various types.

00:07:59.456 --> 00:08:01.226 A:middle
So we've been talking about this

00:07:59.456 --> 00:08:01.226 A:middle
So we've been talking about this

00:08:01.226 --> 00:08:03.366 A:middle
buffer type, and we can make it

00:08:03.366 --> 00:08:04.336 A:middle
generic across different

00:08:04.336 --> 00:08:04.856 A:middle
elements.

00:08:04.856 --> 00:08:06.176 A:middle
But what about writing generic

00:08:06.176 --> 00:08:07.936 A:middle
code that's generic in a

00:08:07.936 --> 00:08:08.596 A:middle
different direction?

00:08:09.156 --> 00:08:10.356 A:middle
Or writing code that works on

00:08:10.356 --> 00:08:11.236 A:middle
any different kind of

00:08:11.236 --> 00:08:11.716 A:middle
collection?

00:08:13.236 --> 00:08:14.946 A:middle
Such as an array that's very

00:08:14.946 --> 00:08:16.136 A:middle
similar to our buffer type.

00:08:16.886 --> 00:08:18.766 A:middle
But also more varied types, like

00:08:18.906 --> 00:08:20.506 A:middle
a dictionary that's a collection

00:08:20.506 --> 00:08:23.226 A:middle
of key value pairs.

00:08:23.226 --> 00:08:24.806 A:middle
Or maybe types that aren't

00:08:24.806 --> 00:08:25.766 A:middle
generic or are the different

00:08:25.766 --> 00:08:27.656 A:middle
element types, like data or

00:08:27.656 --> 00:08:29.086 A:middle
string that returns specific

00:08:29.086 --> 00:08:29.746 A:middle
element types.

00:08:30.286 --> 00:08:33.256 A:middle
We want to create a protocol

00:08:33.256 --> 00:08:34.876 A:middle
that captures all of their

00:08:34.876 --> 00:08:36.025 A:middle
common capabilities.

00:08:36.635 --> 00:08:38.466 A:middle
We're going to create a, a cut

00:08:38.525 --> 00:08:40.236 A:middle
down, simplified version of the

00:08:40.236 --> 00:08:41.236 A:middle
standard library's own

00:08:41.236 --> 00:08:41.976 A:middle
collection protocol.

00:08:45.126 --> 00:08:46.926 A:middle
So notice that we considered a

00:08:46.926 --> 00:08:49.266 A:middle
varied number of concrete types

00:08:49.266 --> 00:08:49.906 A:middle
first.

00:08:49.906 --> 00:08:51.806 A:middle
And now, we're thinking about a

00:08:51.806 --> 00:08:53.546 A:middle
kind of protocol that could join

00:08:53.546 --> 00:08:54.076 A:middle
them all together.

00:08:54.196 --> 00:08:55.656 A:middle
And, it's important to think of

00:08:55.656 --> 00:08:56.966 A:middle
things as this way around.

00:08:57.226 --> 00:08:58.726 A:middle
To start with some concrete

00:08:58.726 --> 00:09:00.566 A:middle
types, and then try and unify

00:08:58.726 --> 00:09:00.566 A:middle
types, and then try and unify

00:09:00.566 --> 00:09:01.816 A:middle
them with a protocol.

00:09:03.336 --> 00:09:04.176 A:middle
What do those types have in

00:09:04.176 --> 00:09:04.566 A:middle
common?

00:09:05.186 --> 00:09:06.456 A:middle
What don't they have in common?

00:09:07.356 --> 00:09:08.706 A:middle
When you're designing a protocol

00:09:08.706 --> 00:09:09.886 A:middle
like this, you can think of it

00:09:09.886 --> 00:09:11.246 A:middle
kind of like a contract

00:09:11.246 --> 00:09:11.966 A:middle
negotiation.

00:09:13.316 --> 00:09:14.686 A:middle
There's a natural push and pull

00:09:14.686 --> 00:09:16.426 A:middle
here, between conforming types

00:09:16.426 --> 00:09:17.086 A:middle
on the one hand.

00:09:17.526 --> 00:09:19.386 A:middle
That want as much flexibility as

00:09:19.386 --> 00:09:20.896 A:middle
possible in fulfilling that

00:09:20.896 --> 00:09:21.376 A:middle
contract.

00:09:22.636 --> 00:09:24.636 A:middle
And users of the protocol, that

00:09:24.636 --> 00:09:25.856 A:middle
want a really nice, tight,

00:09:26.086 --> 00:09:28.546 A:middle
simple protocol in order to do

00:09:28.546 --> 00:09:29.246 A:middle
their extensions.

00:09:30.306 --> 00:09:32.196 A:middle
That's why it's really important

00:09:32.226 --> 00:09:33.776 A:middle
to have both a variety of

00:09:33.776 --> 00:09:35.006 A:middle
different possible conforming

00:09:35.006 --> 00:09:35.396 A:middle
types.

00:09:35.916 --> 00:09:37.226 A:middle
And a number of different use

00:09:37.226 --> 00:09:38.616 A:middle
cases in mind when you're

00:09:38.616 --> 00:09:39.626 A:middle
designing your protocol.

00:09:40.276 --> 00:09:42.246 A:middle
Because it's a balancing act.

00:09:43.076 --> 00:09:45.716 A:middle
So, let's start to flesh out the

00:09:45.716 --> 00:09:46.546 A:middle
collection protocol.

00:09:46.726 --> 00:09:47.896 A:middle
So, first we need to represent

00:09:47.896 --> 00:09:48.616 A:middle
the element type.

00:09:49.036 --> 00:09:50.236 A:middle
Now, in protocols, we use an

00:09:50.236 --> 00:09:52.556 A:middle
associated type for that.

00:09:52.956 --> 00:09:54.356 A:middle
Each conforming type needs to

00:09:54.356 --> 00:09:55.906 A:middle
set element to be something

00:09:55.906 --> 00:09:56.476 A:middle
appropriate.

00:09:56.556 --> 00:09:59.096 A:middle
In the case of buffer, or array,

00:09:59.096 --> 00:10:01.726 A:middle
as of Swift 4.2, this happens

00:09:59.096 --> 00:10:01.726 A:middle
as of Swift 4.2, this happens

00:10:01.846 --> 00:10:02.516 A:middle
automatically.

00:10:03.256 --> 00:10:04.416 A:middle
Because we also named their

00:10:04.416 --> 00:10:06.016 A:middle
generic parameters to be element

00:10:06.016 --> 00:10:06.416 A:middle
as well.

00:10:07.706 --> 00:10:09.136 A:middle
This is a nice side benefit of

00:10:09.136 --> 00:10:10.356 A:middle
giving your generic arguments

00:10:10.466 --> 00:10:11.856 A:middle
meaningful names that follow

00:10:11.856 --> 00:10:13.816 A:middle
common conventions like the word

00:10:13.816 --> 00:10:14.226 A:middle
element.

00:10:15.726 --> 00:10:16.406 A:middle
Rather than giving them

00:10:16.406 --> 00:10:17.856 A:middle
something arbitrary like T that

00:10:17.856 --> 00:10:19.256 A:middle
you'd have to separately state

00:10:19.256 --> 00:10:20.116 A:middle
was the element type.

00:10:22.096 --> 00:10:23.296 A:middle
For other data types, you might

00:10:23.296 --> 00:10:24.186 A:middle
need to do something slightly

00:10:24.186 --> 00:10:24.816 A:middle
more specific.

00:10:24.816 --> 00:10:26.186 A:middle
For example, a dictionary needs

00:10:26.186 --> 00:10:27.466 A:middle
to set the element type to be

00:10:27.466 --> 00:10:28.986 A:middle
the pair of its key and value

00:10:29.066 --> 00:10:29.266 A:middle
type.

00:10:29.746 --> 00:10:33.486 A:middle
Next, let's talk about adding

00:10:33.486 --> 00:10:34.646 A:middle
the subscript operation.

00:10:35.896 --> 00:10:37.026 A:middle
Now, if we were talking about

00:10:37.156 --> 00:10:38.566 A:middle
just a protocol for types like

00:10:38.626 --> 00:10:40.376 A:middle
array, we might be tempted to

00:10:40.376 --> 00:10:42.576 A:middle
have subscripts take an Int as

00:10:42.576 --> 00:10:43.146 A:middle
its argument.

00:10:45.036 --> 00:10:47.256 A:middle
But making subscript take an Int

00:10:47.476 --> 00:10:49.006 A:middle
would imply a very strong

00:10:49.006 --> 00:10:50.456 A:middle
contract.

00:10:50.936 --> 00:10:52.466 A:middle
Every conforming type would have

00:10:52.586 --> 00:10:54.536 A:middle
to supply the ability to fetch

00:10:54.536 --> 00:10:55.756 A:middle
an element's given position that

00:10:55.756 --> 00:10:57.396 A:middle
was represented by an integer.

00:10:57.916 --> 00:10:59.836 A:middle
And, that works great for types

00:11:00.086 --> 00:11:00.716 A:middle
like array.

00:11:01.596 --> 00:11:03.526 A:middle
It's also definitely easy for

00:11:03.526 --> 00:11:04.586 A:middle
users of the protocol to

00:11:04.586 --> 00:11:05.116 A:middle
understand.

00:11:06.186 --> 00:11:07.296 A:middle
But is it flexible enough for a

00:11:07.296 --> 00:11:08.526 A:middle
slightly more complicated type,

00:11:08.626 --> 00:11:09.506 A:middle
like a dictionary?

00:11:11.136 --> 00:11:13.636 A:middle
Now no matter how you model it,

00:11:13.866 --> 00:11:15.256 A:middle
a dictionary's probably going to

00:11:15.256 --> 00:11:16.406 A:middle
be backed by some fairly

00:11:16.406 --> 00:11:17.746 A:middle
complicated internal data

00:11:17.746 --> 00:11:18.176 A:middle
structure.

00:11:18.666 --> 00:11:19.866 A:middle
That has specific logic for

00:11:19.866 --> 00:11:21.466 A:middle
moving from one element to the

00:11:21.466 --> 00:11:21.916 A:middle
next.

00:11:22.586 --> 00:11:24.146 A:middle
For example, it could be backed

00:11:24.276 --> 00:11:26.046 A:middle
by an internal buffer of some

00:11:26.046 --> 00:11:29.096 A:middle
kind, and it could use an index

00:11:29.096 --> 00:11:30.736 A:middle
type that stored an offset into

00:11:30.736 --> 00:11:31.266 A:middle
that buffer.

00:11:31.266 --> 00:11:33.166 A:middle
That it could then take as the

00:11:33.166 --> 00:11:34.526 A:middle
argument to subscript in order

00:11:34.526 --> 00:11:35.366 A:middle
to fetch an element to the

00:11:35.366 --> 00:11:37.346 A:middle
position, using that offset.

00:11:38.166 --> 00:11:39.776 A:middle
But it would be critical that

00:11:39.776 --> 00:11:41.496 A:middle
the dictionary's index type be

00:11:41.496 --> 00:11:43.116 A:middle
an opaque type that only the

00:11:43.116 --> 00:11:44.416 A:middle
dictionary can control.

00:11:45.206 --> 00:11:45.866 A:middle
You wouldn't want somebody

00:11:45.866 --> 00:11:47.506 A:middle
necessarily just adding one to

00:11:47.506 --> 00:11:48.036 A:middle
your offset.

00:11:48.306 --> 00:11:49.176 A:middle
That wouldn't necessarily move

00:11:49.176 --> 00:11:50.076 A:middle
to the next element in the

00:11:50.076 --> 00:11:50.576 A:middle
dictionary.

00:11:51.056 --> 00:11:52.466 A:middle
It could move some arbitrary,

00:11:52.466 --> 00:11:54.206 A:middle
maybe uninitialized part of the

00:11:54.206 --> 00:11:55.706 A:middle
dictionary's internal storage.

00:11:56.826 --> 00:11:57.936 A:middle
So instead we want the

00:11:57.936 --> 00:12:00.486 A:middle
dictionary to control moving

00:11:57.936 --> 00:12:00.486 A:middle
dictionary to control moving

00:12:00.486 --> 00:12:02.126 A:middle
forward through the collection

00:12:02.126 --> 00:12:03.346 A:middle
by advancing the index.

00:12:04.096 --> 00:12:05.356 A:middle
And so to do that, we add

00:12:05.356 --> 00:12:05.986 A:middle
another method.

00:12:06.926 --> 00:12:08.756 A:middle
That given an index, gives you

00:12:08.756 --> 00:12:09.706 A:middle
the index that marks the

00:12:09.706 --> 00:12:12.256 A:middle
position after it.

00:12:12.506 --> 00:12:13.386 A:middle
Once you take this step, you

00:12:13.386 --> 00:12:14.376 A:middle
need a couple more things.

00:12:14.376 --> 00:12:15.806 A:middle
You need a start index property,

00:12:16.126 --> 00:12:17.706 A:middle
and an end index property.

00:12:18.226 --> 00:12:19.356 A:middle
Because a simple count isn't

00:12:19.356 --> 00:12:20.356 A:middle
going to work anymore in order

00:12:20.356 --> 00:12:21.346 A:middle
to tell us that we've reached

00:12:21.346 --> 00:12:21.766 A:middle
the end.

00:12:22.076 --> 00:12:24.056 A:middle
Now that we're not using Ints as

00:12:24.056 --> 00:12:24.696 A:middle
our index type.

00:12:26.376 --> 00:12:27.586 A:middle
So let's bring those back to the

00:12:27.586 --> 00:12:28.466 A:middle
collection protocol.

00:12:30.086 --> 00:12:31.606 A:middle
So we've got a subscript that

00:12:31.606 --> 00:12:33.136 A:middle
takes some index type to

00:12:33.136 --> 00:12:34.396 A:middle
represent a position, and gives

00:12:34.396 --> 00:12:35.056 A:middle
you an element there.

00:12:35.636 --> 00:12:36.956 A:middle
And, we've got a way of moving

00:12:36.956 --> 00:12:37.916 A:middle
that position forward.

00:12:39.076 --> 00:12:41.176 A:middle
But we also need types to supply

00:12:41.176 --> 00:12:42.206 A:middle
what kind of type they're going

00:12:42.206 --> 00:12:43.576 A:middle
to use for their index.

00:12:43.816 --> 00:12:44.946 A:middle
We do that with another

00:12:44.946 --> 00:12:45.916 A:middle
associated type.

00:12:47.886 --> 00:12:49.436 A:middle
Conforming types would supply

00:12:50.046 --> 00:12:50.736 A:middle
the appropriate types.

00:12:50.736 --> 00:12:52.946 A:middle
So an array or a data would give

00:12:53.156 --> 00:12:54.536 A:middle
an Int as their index type.

00:12:55.206 --> 00:12:56.406 A:middle
Whereas a dictionary would give

00:12:56.406 --> 00:12:58.096 A:middle
its own custom implementation

00:12:58.176 --> 00:12:59.426 A:middle
that handles its own internal

00:12:59.426 --> 00:12:59.756 A:middle
logic.

00:13:04.306 --> 00:13:05.956 A:middle
So let's go back to count that

00:13:05.956 --> 00:13:07.456 A:middle
we dropped a minute ago in order

00:13:07.456 --> 00:13:09.106 A:middle
to generalize our indexing

00:13:09.106 --> 00:13:09.386 A:middle
model.

00:13:09.536 --> 00:13:10.636 A:middle
It's still a really useful

00:13:10.636 --> 00:13:11.396 A:middle
property to have.

00:13:11.396 --> 00:13:12.916 A:middle
So we probably want to add it

00:13:12.916 --> 00:13:15.396 A:middle
back as an extension on

00:13:15.396 --> 00:13:15.856 A:middle
collection.

00:13:16.656 --> 00:13:18.816 A:middle
Something that walks over the

00:13:18.816 --> 00:13:20.296 A:middle
collection, moving the index

00:13:20.296 --> 00:13:22.246 A:middle
forward, incrementing a counter

00:13:22.296 --> 00:13:23.376 A:middle
that it then returns.

00:13:23.376 --> 00:13:27.426 A:middle
Now, if we try and implement

00:13:27.426 --> 00:13:28.886 A:middle
this, we hit another missing

00:13:28.886 --> 00:13:29.406 A:middle
requirement.

00:13:30.346 --> 00:13:31.886 A:middle
Since we moved off of Int to a

00:13:31.886 --> 00:13:33.746 A:middle
general index type, we can no

00:13:33.746 --> 00:13:35.626 A:middle
longer assume that the index

00:13:35.626 --> 00:13:36.596 A:middle
type was equatable.

00:13:37.526 --> 00:13:39.286 A:middle
Ints are, but arbitrary index

00:13:39.286 --> 00:13:40.306 A:middle
types aren't necessarily.

00:13:40.306 --> 00:13:42.646 A:middle
And, we need that in order to

00:13:42.646 --> 00:13:43.936 A:middle
know that we've reached the end.

00:13:45.226 --> 00:13:47.216 A:middle
Now, we could solve this in the

00:13:47.216 --> 00:13:48.846 A:middle
same way that we did earlier, of

00:13:49.316 --> 00:13:50.636 A:middle
constraining our extension.

00:13:50.706 --> 00:13:52.096 A:middle
Say that it only works when the

00:13:52.096 --> 00:13:53.486 A:middle
index type is equatable.

00:13:54.706 --> 00:13:55.976 A:middle
But, that doesn't feel right.

00:13:57.456 --> 00:13:59.006 A:middle
We want a protocol to be easy to

00:13:59.006 --> 00:13:59.456 A:middle
use.

00:13:59.766 --> 00:14:01.556 A:middle
And it's going to get really

00:13:59.766 --> 00:14:01.556 A:middle
And it's going to get really

00:14:01.556 --> 00:14:02.736 A:middle
irritating, if we have to

00:14:02.736 --> 00:14:04.276 A:middle
always, on every extension we

00:14:04.276 --> 00:14:06.696 A:middle
write, put this constraint on

00:14:06.696 --> 00:14:06.886 A:middle
there.

00:14:06.886 --> 00:14:07.666 A:middle
Because we're nearly always

00:14:07.666 --> 00:14:08.396 A:middle
going to need to be able to

00:14:08.396 --> 00:14:09.396 A:middle
compare two indexes.

00:14:10.316 --> 00:14:11.296 A:middle
Instead, it's probably better

00:14:11.296 --> 00:14:13.556 A:middle
expressed as a requirement of

00:14:13.556 --> 00:14:14.196 A:middle
the protocol.

00:14:14.196 --> 00:14:17.816 A:middle
As a constraint on our

00:14:17.816 --> 00:14:19.016 A:middle
index-associated type.

00:14:20.386 --> 00:14:21.406 A:middle
Putting this constraint on the

00:14:21.406 --> 00:14:23.246 A:middle
protocol means that all types

00:14:23.246 --> 00:14:24.226 A:middle
that conform to the protocol

00:14:24.226 --> 00:14:26.266 A:middle
need to supply an equatable type

00:14:26.266 --> 00:14:27.036 A:middle
for their index.

00:14:28.626 --> 00:14:30.026 A:middle
That way you don't have to

00:14:30.076 --> 00:14:31.426 A:middle
specify it every time you write

00:14:31.426 --> 00:14:32.046 A:middle
the extension.

00:14:33.476 --> 00:14:35.806 A:middle
This is another example of

00:14:35.806 --> 00:14:36.936 A:middle
negotiating the protocol

00:14:36.936 --> 00:14:37.386 A:middle
contract.

00:14:38.806 --> 00:14:39.946 A:middle
Users of the protocol had a

00:14:39.946 --> 00:14:41.306 A:middle
requirement that they really

00:14:41.306 --> 00:14:42.406 A:middle
needed to be able to compare

00:14:42.406 --> 00:14:42.926 A:middle
indexes.

00:14:43.666 --> 00:14:45.876 A:middle
And, conforming types, they did

00:14:45.876 --> 00:14:47.226 A:middle
a check that they can reasonably

00:14:47.226 --> 00:14:48.186 A:middle
accommodate that without giving

00:14:48.186 --> 00:14:49.566 A:middle
up too much flexibility.

00:14:50.726 --> 00:14:52.116 A:middle
In this case, they definitely

00:14:52.116 --> 00:14:52.506 A:middle
can.

00:14:53.556 --> 00:14:54.976 A:middle
Ints, the data, and array are

00:14:54.976 --> 00:14:56.236 A:middle
using are already equatable.

00:14:56.296 --> 00:14:57.986 A:middle
And, with Swift 4.2's new

00:14:57.986 --> 00:14:59.646 A:middle
automatic synthesis of equatable

00:14:59.646 --> 00:15:00.316 A:middle
conformance.

00:14:59.646 --> 00:15:00.316 A:middle
conformance.

00:15:01.336 --> 00:15:02.536 A:middle
It's easy for dictionary to make

00:15:02.536 --> 00:15:03.736 A:middle
its index type equatable as

00:15:03.736 --> 00:15:03.976 A:middle
well.

00:15:07.346 --> 00:15:08.106 A:middle
Next, let's talk about

00:15:08.226 --> 00:15:10.246 A:middle
optimizing this count operation

00:15:10.426 --> 00:15:12.256 A:middle
with a customization point.

00:15:14.416 --> 00:15:16.456 A:middle
So, we've written a version of

00:15:16.456 --> 00:15:19.126 A:middle
count, that calculates the

00:15:19.126 --> 00:15:19.886 A:middle
number of elements in the

00:15:19.886 --> 00:15:21.446 A:middle
collection by walking over the

00:15:21.446 --> 00:15:22.356 A:middle
entire collection.

00:15:22.356 --> 00:15:23.176 A:middle
But, obviously a lot of

00:15:23.176 --> 00:15:24.846 A:middle
collections can probably do that

00:15:24.846 --> 00:15:25.476 A:middle
a lot faster.

00:15:25.476 --> 00:15:27.596 A:middle
For example, supposing a

00:15:27.596 --> 00:15:29.736 A:middle
dictionary kept internally a

00:15:29.736 --> 00:15:30.946 A:middle
count of the number of elements

00:15:30.946 --> 00:15:32.516 A:middle
it held, for its own purposes.

00:15:33.256 --> 00:15:34.946 A:middle
If it has this information, it

00:15:34.946 --> 00:15:36.376 A:middle
can just serve it up in its own

00:15:36.376 --> 00:15:37.416 A:middle
implementation of count.

00:15:38.386 --> 00:15:40.396 A:middle
That means that when people call

00:15:40.396 --> 00:15:41.806 A:middle
count on a dictionary, they're

00:15:42.036 --> 00:15:43.676 A:middle
getting fast constant time.

00:15:44.096 --> 00:15:45.416 A:middle
Instead of the linear time that

00:15:45.416 --> 00:15:47.116 A:middle
our original version that works

00:15:47.116 --> 00:15:48.256 A:middle
with any collection takes.

00:15:49.116 --> 00:15:51.296 A:middle
But, when adding optimizations

00:15:51.296 --> 00:15:52.196 A:middle
like this, there's something you

00:15:52.196 --> 00:15:52.796 A:middle
need to be aware of.

00:15:52.796 --> 00:15:54.386 A:middle
Which is the difference between

00:15:54.386 --> 00:15:55.476 A:middle
fulfilling protocol

00:15:55.476 --> 00:15:57.486 A:middle
requirements, and just adding

00:15:57.486 --> 00:15:59.546 A:middle
lots of overloads onto specific

00:15:59.546 --> 00:16:00.076 A:middle
types.

00:15:59.546 --> 00:16:00.076 A:middle
types.

00:16:00.856 --> 00:16:03.526 A:middle
Up until now, this new version

00:16:03.526 --> 00:16:04.976 A:middle
of count on dictionary is just

00:16:05.066 --> 00:16:05.686 A:middle
an overload.

00:16:05.686 --> 00:16:07.626 A:middle
That means that when you have a

00:16:07.626 --> 00:16:09.436 A:middle
dictionary, and you know it's a

00:16:09.436 --> 00:16:09.866 A:middle
dictionary.

00:16:10.526 --> 00:16:11.656 A:middle
You'll get the newer, better

00:16:11.656 --> 00:16:12.446 A:middle
version of count.

00:16:13.226 --> 00:16:14.326 A:middle
But, what about calling it

00:16:14.326 --> 00:16:15.886 A:middle
inside a generic algorithm?

00:16:17.816 --> 00:16:19.806 A:middle
So supposing we wanted, for

00:16:19.806 --> 00:16:21.206 A:middle
example, to write a version of

00:16:21.206 --> 00:16:22.486 A:middle
the standard library's map?

00:16:23.116 --> 00:16:24.086 A:middle
If you're not already familiar

00:16:24.086 --> 00:16:25.656 A:middle
with it, it's a really useful

00:16:25.656 --> 00:16:28.186 A:middle
operation that transforms each

00:16:28.226 --> 00:16:29.476 A:middle
element in the collection.

00:16:29.526 --> 00:16:30.946 A:middle
And gives it back to you as a

00:16:30.946 --> 00:16:31.526 A:middle
new array.

00:16:32.596 --> 00:16:34.216 A:middle
The implementation's pretty

00:16:34.216 --> 00:16:34.566 A:middle
simple.

00:16:35.036 --> 00:16:36.686 A:middle
It just creates a new array,

00:16:37.486 --> 00:16:38.466 A:middle
moves over the collection,

00:16:39.056 --> 00:16:40.106 A:middle
transforms each element.

00:16:40.386 --> 00:16:42.846 A:middle
And then appends it to the

00:16:42.846 --> 00:16:42.913 A:middle
array.

00:16:42.913 --> 00:16:44.566 A:middle
Now, as you append elements to

00:16:44.566 --> 00:16:46.606 A:middle
an array like this, the array

00:16:46.606 --> 00:16:47.846 A:middle
automatically grows.

00:16:48.626 --> 00:16:50.466 A:middle
And, as it grows, it needs

00:16:50.466 --> 00:16:52.196 A:middle
sometimes to re-allocate its

00:16:52.196 --> 00:16:53.116 A:middle
internal storage.

00:16:53.216 --> 00:16:54.456 A:middle
In order to make more room to

00:16:54.456 --> 00:16:55.586 A:middle
accommodate the new elements.

00:16:56.256 --> 00:16:57.586 A:middle
In a loop like this, it might

00:16:57.586 --> 00:16:59.276 A:middle
have to do that multiple times

00:16:59.276 --> 00:17:00.356 A:middle
over, depending on how big it

00:16:59.276 --> 00:17:00.356 A:middle
over, depending on how big it

00:17:00.356 --> 00:17:00.606 A:middle
gets.

00:17:00.606 --> 00:17:02.696 A:middle
And, doing that takes time.

00:17:02.926 --> 00:17:04.715 A:middle
Allocating memory can be fairly

00:17:04.715 --> 00:17:05.256 A:middle
expensive.

00:17:05.346 --> 00:17:07.996 A:middle
There is a nice optimization

00:17:07.996 --> 00:17:09.106 A:middle
trick we can do with this

00:17:09.106 --> 00:17:09.766 A:middle
implementation.

00:17:10.606 --> 00:17:12.336 A:middle
We already know exactly how big

00:17:12.636 --> 00:17:13.986 A:middle
the final array is going to be.

00:17:14.016 --> 00:17:15.396 A:middle
It's going to be exactly the

00:17:15.396 --> 00:17:16.945 A:middle
same size as our original

00:17:16.945 --> 00:17:17.425 A:middle
collection.

00:17:18.445 --> 00:17:20.836 A:middle
So we could reserve exactly the

00:17:20.836 --> 00:17:22.766 A:middle
right amount of space in the

00:17:22.766 --> 00:17:24.486 A:middle
array up front, before we start

00:17:24.486 --> 00:17:26.435 A:middle
appending to it, which is a nice

00:17:26.435 --> 00:17:26.816 A:middle
speed-up.

00:17:26.906 --> 00:17:29.106 A:middle
And to do this, we're calling

00:17:29.196 --> 00:17:29.576 A:middle
count.

00:17:30.726 --> 00:17:32.466 A:middle
But, we're calling count here,

00:17:32.466 --> 00:17:34.226 A:middle
in what's referred to as a

00:17:34.226 --> 00:17:35.466 A:middle
generic context.

00:17:35.886 --> 00:17:37.976 A:middle
That is, a context where the

00:17:37.976 --> 00:17:39.266 A:middle
collection type is completely

00:17:39.266 --> 00:17:40.626 A:middle
generic, not specific.

00:17:40.626 --> 00:17:41.816 A:middle
It could be an array, or a

00:17:41.816 --> 00:17:43.296 A:middle
dictionary, or a link list, or

00:17:43.296 --> 00:17:43.686 A:middle
anything.

00:17:44.486 --> 00:17:46.286 A:middle
So, we can't know that it

00:17:46.286 --> 00:17:48.156 A:middle
necessarily has a better

00:17:48.156 --> 00:17:49.396 A:middle
implementation of count

00:17:49.396 --> 00:17:50.036 A:middle
available to it.

00:17:50.236 --> 00:17:51.646 A:middle
When the compiler compiles this

00:17:51.646 --> 00:17:51.976 A:middle
code.

00:17:52.726 --> 00:17:55.326 A:middle
And so, in this case, the

00:17:55.326 --> 00:17:56.376 A:middle
version of count that's going to

00:17:56.376 --> 00:17:57.966 A:middle
be called is actually the

00:17:57.966 --> 00:17:59.046 A:middle
general version of count.

00:17:59.246 --> 00:18:01.086 A:middle
That works on any collection and

00:17:59.246 --> 00:18:01.086 A:middle
That works on any collection and

00:18:01.086 --> 00:18:02.256 A:middle
iterates over the entire

00:18:02.256 --> 00:18:02.766 A:middle
collection.

00:18:03.466 --> 00:18:04.536 A:middle
If you called map on a

00:18:04.536 --> 00:18:06.496 A:middle
dictionary, it wouldn't call the

00:18:06.496 --> 00:18:07.436 A:middle
better version of count that

00:18:07.436 --> 00:18:08.606 A:middle
we've just written yet.

00:18:11.156 --> 00:18:13.316 A:middle
In order for customized method

00:18:13.316 --> 00:18:15.386 A:middle
or property like this to be

00:18:15.386 --> 00:18:17.526 A:middle
called in a gen-- in a generic

00:18:17.526 --> 00:18:18.066 A:middle
context.

00:18:18.476 --> 00:18:19.886 A:middle
It needs to be declared as a

00:18:19.886 --> 00:18:21.446 A:middle
requirement on the protocol

00:18:21.446 --> 00:18:22.026 A:middle
itself.

00:18:22.516 --> 00:18:24.256 A:middle
We've established that there's

00:18:24.256 --> 00:18:26.166 A:middle
definitely a way in which

00:18:26.166 --> 00:18:27.576 A:middle
certain collections could

00:18:27.576 --> 00:18:28.826 A:middle
provide an optimized version of

00:18:28.826 --> 00:18:30.806 A:middle
count, so it makes sense to add

00:18:30.806 --> 00:18:32.566 A:middle
it as a requirement on the

00:18:32.566 --> 00:18:33.086 A:middle
protocol.

00:18:34.446 --> 00:18:36.396 A:middle
Now, even though we've made it a

00:18:36.396 --> 00:18:40.036 A:middle
requirement to implement it, all

00:18:40.036 --> 00:18:41.346 A:middle
collections don't have to

00:18:41.346 --> 00:18:42.066 A:middle
provide their own

00:18:42.066 --> 00:18:42.716 A:middle
implementation.

00:18:42.926 --> 00:18:44.086 A:middle
Because we've already provided

00:18:44.086 --> 00:18:45.976 A:middle
one via our extension that will

00:18:45.976 --> 00:18:47.076 A:middle
work on any collection.

00:18:48.306 --> 00:18:49.776 A:middle
Adding a requirement to the

00:18:49.776 --> 00:18:51.856 A:middle
protocol, and alongside it

00:18:51.856 --> 00:18:53.516 A:middle
adding a default implementation

00:18:53.736 --> 00:18:55.576 A:middle
via an extension is what we

00:18:55.576 --> 00:18:57.706 A:middle
refer to as a customization

00:18:57.706 --> 00:18:57.996 A:middle
point.

00:18:58.666 --> 00:19:01.456 A:middle
With a customization point, the

00:18:58.666 --> 00:19:01.456 A:middle
With a customization point, the

00:19:01.456 --> 00:19:03.126 A:middle
compiler can know that there's

00:19:03.126 --> 00:19:04.286 A:middle
potentially a better

00:19:04.286 --> 00:19:06.026 A:middle
implementation of a method or

00:19:06.026 --> 00:19:07.036 A:middle
property available to it.

00:19:07.296 --> 00:19:09.956 A:middle
And so, in a generic context, it

00:19:09.956 --> 00:19:11.896 A:middle
dynamically dispatches to that

00:19:11.896 --> 00:19:13.416 A:middle
implementation through the

00:19:13.416 --> 00:19:13.926 A:middle
protocol.

00:19:15.336 --> 00:19:17.406 A:middle
So now, if you call map on a

00:19:17.406 --> 00:19:18.856 A:middle
dictionary, even though it's a

00:19:18.856 --> 00:19:19.876 A:middle
completely generic function.

00:19:20.596 --> 00:19:21.406 A:middle
You will get the better

00:19:21.406 --> 00:19:22.456 A:middle
implementation of count.

00:19:24.596 --> 00:19:26.086 A:middle
Adding customization points like

00:19:26.086 --> 00:19:27.736 A:middle
this, alongside default

00:19:27.736 --> 00:19:28.756 A:middle
implementations through

00:19:28.756 --> 00:19:29.286 A:middle
extensions.

00:19:30.376 --> 00:19:31.516 A:middle
Is a really powerful way of

00:19:31.516 --> 00:19:32.906 A:middle
getting the same kind of benefit

00:19:32.976 --> 00:19:34.396 A:middle
that you can also get with

00:19:34.396 --> 00:19:35.966 A:middle
classes, implementation

00:19:35.966 --> 00:19:37.086 A:middle
inheritance, and method

00:19:37.086 --> 00:19:37.626 A:middle
overwriting.

00:19:38.366 --> 00:19:39.676 A:middle
But, this technique works on

00:19:39.676 --> 00:19:41.916 A:middle
structs and enums, as well as

00:19:41.916 --> 00:19:42.326 A:middle
classes.

00:19:45.356 --> 00:19:47.386 A:middle
Now, not every method can be

00:19:47.386 --> 00:19:48.476 A:middle
optimized like this.

00:19:49.026 --> 00:19:51.016 A:middle
And, customization points have a

00:19:51.016 --> 00:19:53.146 A:middle
small but non-zero impact on

00:19:53.146 --> 00:19:55.006 A:middle
your binary size, your compiler

00:19:55.056 --> 00:19:55.996 A:middle
runtime performance.

00:19:56.406 --> 00:19:57.656 A:middle
So, it only makes sense to add

00:19:57.656 --> 00:19:59.506 A:middle
customization points when

00:19:59.506 --> 00:20:00.036 A:middle
there's definitely an

00:19:59.506 --> 00:20:00.036 A:middle
there's definitely an

00:20:00.036 --> 00:20:01.306 A:middle
opportunity for customization.

00:20:02.256 --> 00:20:03.596 A:middle
For example, in the map

00:20:03.596 --> 00:20:05.006 A:middle
operation that we just wrote.

00:20:05.446 --> 00:20:06.826 A:middle
There's no reasonable way in

00:20:06.826 --> 00:20:08.026 A:middle
which any different kind of

00:20:08.026 --> 00:20:09.496 A:middle
collection could actually

00:20:09.496 --> 00:20:11.436 A:middle
provide a better implementation.

00:20:12.046 --> 00:20:13.216 A:middle
And so, it doesn't make sense to

00:20:13.216 --> 00:20:14.636 A:middle
add it as a customization point.

00:20:14.996 --> 00:20:16.376 A:middle
It can just stay as an

00:20:16.376 --> 00:20:16.926 A:middle
extension.

00:20:18.396 --> 00:20:19.756 A:middle
So, we've created this

00:20:19.756 --> 00:20:20.966 A:middle
collection type, and it's

00:20:20.966 --> 00:20:21.976 A:middle
actually pretty fully-featured

00:20:21.976 --> 00:20:22.166 A:middle
now.

00:20:22.166 --> 00:20:23.016 A:middle
It has lots of different

00:20:23.696 --> 00:20:24.926 A:middle
conforming types possible.

00:20:25.236 --> 00:20:26.456 A:middle
And various different useful

00:20:26.456 --> 00:20:28.356 A:middle
algorithms you can write for it.

00:20:28.616 --> 00:20:30.016 A:middle
But, sometimes you need more

00:20:30.016 --> 00:20:31.696 A:middle
than just a single protocol in

00:20:31.696 --> 00:20:33.116 A:middle
order to categorize your family

00:20:33.116 --> 00:20:33.696 A:middle
of types.

00:20:34.646 --> 00:20:36.356 A:middle
You need protocol inheritance.

00:20:36.656 --> 00:20:37.726 A:middle
And, to talk to you more about

00:20:37.726 --> 00:20:38.936 A:middle
that, here's Doug.

00:20:40.516 --> 00:20:45.586 A:middle
[ Applause ]

00:20:46.086 --> 00:20:46.706 A:middle
&gt;&gt; Thank you, Ben.

00:20:47.936 --> 00:20:49.846 A:middle
So, protocol inheritance has

00:20:49.896 --> 00:20:50.976 A:middle
been around since the beginning

00:20:50.976 --> 00:20:51.396 A:middle
of Swift.

00:20:52.336 --> 00:20:53.766 A:middle
And, to think about where we

00:20:53.766 --> 00:20:54.956 A:middle
need protocol inheritance.

00:20:55.026 --> 00:20:56.446 A:middle
Let's go look at this collection

00:20:56.446 --> 00:20:57.206 A:middle
protocol that we've been

00:20:57.206 --> 00:20:57.596 A:middle
building.

00:20:58.276 --> 00:20:59.126 A:middle
It's a nice protocol.

00:20:59.126 --> 00:20:59.906 A:middle
It's well-designed.

00:21:00.566 --> 00:21:02.136 A:middle
It describes a set of conforming

00:21:02.136 --> 00:21:03.966 A:middle
types, and gives you the ability

00:21:03.966 --> 00:21:05.136 A:middle
to write interesting generic

00:21:05.136 --> 00:21:05.996 A:middle
algorithms on them.

00:21:06.726 --> 00:21:07.756 A:middle
But, we don't have to reach very

00:21:07.756 --> 00:21:09.316 A:middle
far to find other

00:21:09.316 --> 00:21:10.906 A:middle
collection-like algorithms that

00:21:10.906 --> 00:21:12.896 A:middle
we cannot implement in terms of

00:21:12.896 --> 00:21:14.186 A:middle
the collection protocol thus

00:21:14.186 --> 00:21:14.556 A:middle
far.

00:21:15.226 --> 00:21:16.466 A:middle
For example, if we want to find

00:21:16.466 --> 00:21:18.416 A:middle
the index of the last element in

00:21:18.416 --> 00:21:20.026 A:middle
a collection, that matches some

00:21:20.026 --> 00:21:20.626 A:middle
predicate.

00:21:20.826 --> 00:21:22.136 A:middle
The best way to do that would be

00:21:22.136 --> 00:21:23.736 A:middle
to start at the end, and walk

00:21:23.786 --> 00:21:24.426 A:middle
backwards.

00:21:25.096 --> 00:21:26.086 A:middle
Collection protocol doesn't let

00:21:26.086 --> 00:21:26.636 A:middle
us do that.

00:21:27.916 --> 00:21:29.256 A:middle
Or say we want to build a

00:21:29.256 --> 00:21:30.616 A:middle
shuffle operation to randomly

00:21:30.616 --> 00:21:31.716 A:middle
shuffle around the elements in a

00:21:31.716 --> 00:21:32.246 A:middle
collection.

00:21:32.856 --> 00:21:34.146 A:middle
Well, that requires mutation,

00:21:34.146 --> 00:21:35.316 A:middle
and collection doesn't do that.

00:21:35.716 --> 00:21:37.016 A:middle
Now it's not that the collection

00:21:37.016 --> 00:21:38.426 A:middle
protocol is wrong.

00:21:39.876 --> 00:21:41.206 A:middle
But it's that we need something

00:21:41.206 --> 00:21:42.496 A:middle
more to describe these

00:21:42.496 --> 00:21:44.246 A:middle
additional generic algorithms,

00:21:44.636 --> 00:21:45.866 A:middle
and that is the point of

00:21:45.866 --> 00:21:46.956 A:middle
protocol inheritance.

00:21:47.376 --> 00:21:47.806 A:middle
So, here the

00:21:47.806 --> 00:21:49.816 A:middle
bidirectionalCollection protocol

00:21:50.056 --> 00:21:51.856 A:middle
inherits from, or is a

00:21:52.426 --> 00:21:52.876 A:middle
collection.

00:21:53.726 --> 00:21:55.026 A:middle
What that means is that any type

00:21:55.066 --> 00:21:56.236 A:middle
that conforms to the

00:21:56.236 --> 00:21:57.866 A:middle
bidirectionalCollection protocol

00:21:58.376 --> 00:21:59.816 A:middle
also conforms to collection, and

00:21:59.816 --> 00:22:00.776 A:middle
you can use those collection

00:21:59.816 --> 00:22:00.776 A:middle
you can use those collection

00:22:00.776 --> 00:22:01.426 A:middle
algorithms.

00:22:02.186 --> 00:22:03.596 A:middle
But bidirectionalCollection adds

00:22:03.596 --> 00:22:04.976 A:middle
this additional requirement, of

00:22:05.016 --> 00:22:07.226 A:middle
being able to step backwards in

00:22:07.226 --> 00:22:07.836 A:middle
the collection.

00:22:08.276 --> 00:22:09.866 A:middle
An important thing to note is

00:22:10.006 --> 00:22:11.216 A:middle
not every collection can

00:22:11.216 --> 00:22:12.386 A:middle
actually implement this

00:22:12.436 --> 00:22:13.636 A:middle
particular requirement.

00:22:13.976 --> 00:22:15.476 A:middle
Think of a singlyLinkedList,

00:22:15.476 --> 00:22:16.936 A:middle
where you only have these

00:22:17.496 --> 00:22:18.826 A:middle
pointers hopping from one

00:22:18.826 --> 00:22:19.856 A:middle
location to the next.

00:22:20.156 --> 00:22:21.486 A:middle
There's no efficient way to walk

00:22:21.486 --> 00:22:22.786 A:middle
backward through this sequence,

00:22:22.926 --> 00:22:24.346 A:middle
so it cannot be a

00:22:24.346 --> 00:22:25.406 A:middle
bidirectionalCollection.

00:22:25.776 --> 00:22:26.566 A:middle
So, once we've introduced

00:22:26.566 --> 00:22:28.046 A:middle
inheritance, you've restricted

00:22:28.046 --> 00:22:29.356 A:middle
the set of conforming types.

00:22:29.916 --> 00:22:32.096 A:middle
But you've allowed yourself to

00:22:32.306 --> 00:22:33.346 A:middle
implement more interesting

00:22:33.346 --> 00:22:34.006 A:middle
algorithms.

00:22:34.246 --> 00:22:35.456 A:middle
So, here's the code behind this

00:22:35.566 --> 00:22:37.136 A:middle
last index where operation.

00:22:37.356 --> 00:22:37.976 A:middle
It's fairly simple.

00:22:37.976 --> 00:22:39.876 A:middle
We're just walking backwards

00:22:39.876 --> 00:22:41.496 A:middle
through the collection, using

00:22:41.496 --> 00:22:43.276 A:middle
this new requirement from the

00:22:43.276 --> 00:22:44.166 A:middle
bidirectionalCollection

00:22:44.166 --> 00:22:44.576 A:middle
protocol.

00:22:46.606 --> 00:22:47.996 A:middle
Let's look at a more interesting

00:22:47.996 --> 00:22:48.516 A:middle
algorithm.

00:22:48.826 --> 00:22:50.346 A:middle
So here's a shuffle operation.

00:22:50.516 --> 00:22:51.756 A:middle
So, it was introduced for, for

00:22:51.756 --> 00:22:53.526 A:middle
collections in Swift 4.2.

00:22:53.666 --> 00:22:54.506 A:middle
You don't have to implement it

00:22:54.506 --> 00:22:55.646 A:middle
yourself, but we're going to

00:22:55.646 --> 00:22:56.816 A:middle
look at the algorithm itself to

00:22:56.816 --> 00:22:58.306 A:middle
see what kinds of requirements

00:22:58.306 --> 00:23:00.136 A:middle
it introduces to figure out how

00:22:58.306 --> 00:23:00.136 A:middle
it introduces to figure out how

00:23:00.136 --> 00:23:01.566 A:middle
to categorize those into

00:23:01.566 --> 00:23:02.656 A:middle
protocols meaningfully.

00:23:03.396 --> 00:23:04.446 A:middle
So the Fisher-Yates shuffle

00:23:04.446 --> 00:23:05.276 A:middle
algorithm's a pretty old

00:23:05.276 --> 00:23:05.706 A:middle
algorithm.

00:23:06.186 --> 00:23:07.216 A:middle
It's also fairly simple.

00:23:07.546 --> 00:23:09.256 A:middle
You start with an index to the

00:23:09.256 --> 00:23:10.666 A:middle
first element in the collection.

00:23:11.586 --> 00:23:13.836 A:middle
And then, you select randomly

00:23:14.186 --> 00:23:15.376 A:middle
some other element in the

00:23:15.376 --> 00:23:17.196 A:middle
collection, and swap those two.

00:23:18.556 --> 00:23:20.666 A:middle
In the next iteration, you move

00:23:21.016 --> 00:23:22.596 A:middle
the left index forward one.

00:23:23.476 --> 00:23:24.716 A:middle
Randomly select between there

00:23:24.716 --> 00:23:25.996 A:middle
and the end, swap those

00:23:25.996 --> 00:23:26.556 A:middle
elements.

00:23:26.916 --> 00:23:28.196 A:middle
And so, the algorithm is pretty

00:23:28.196 --> 00:23:28.466 A:middle
simple.

00:23:28.466 --> 00:23:29.886 A:middle
It's just this linear march

00:23:30.146 --> 00:23:32.446 A:middle
through the collection, randomly

00:23:32.446 --> 00:23:33.636 A:middle
selecting another element to

00:23:33.636 --> 00:23:34.196 A:middle
swap with.

00:23:34.576 --> 00:23:36.206 A:middle
And, at the end of this, you end

00:23:36.206 --> 00:23:37.516 A:middle
up with a nicely shuffled

00:23:37.886 --> 00:23:38.406 A:middle
collection.

00:23:39.326 --> 00:23:40.676 A:middle
So, we can actually look at the

00:23:40.676 --> 00:23:41.116 A:middle
code here.

00:23:41.306 --> 00:23:42.446 A:middle
It's a little bit involved.

00:23:42.446 --> 00:23:43.236 A:middle
Don't worry about that.

00:23:43.626 --> 00:23:44.996 A:middle
And, we're going to implement it

00:23:44.996 --> 00:23:46.366 A:middle
on some kind of collection.

00:23:46.896 --> 00:23:47.646 A:middle
So, we'll look at the core

00:23:47.646 --> 00:23:48.576 A:middle
operations in here.

00:23:48.906 --> 00:23:49.966 A:middle
So, first we need to be able to

00:23:49.966 --> 00:23:51.896 A:middle
grab a random number between

00:23:51.896 --> 00:23:53.156 A:middle
where we are in the collection

00:23:53.156 --> 00:23:54.206 A:middle
and the end of the collection,

00:23:54.396 --> 00:23:55.626 A:middle
using this, this random

00:23:55.626 --> 00:23:56.086 A:middle
facility.

00:23:56.446 --> 00:23:57.206 A:middle
But, that's an integer.

00:23:57.366 --> 00:23:58.586 A:middle
And what we need is an index

00:23:58.586 --> 00:23:59.316 A:middle
into the collection.

00:23:59.316 --> 00:24:00.226 A:middle
We know those are different.

00:23:59.316 --> 00:24:00.226 A:middle
We know those are different.

00:24:00.526 --> 00:24:02.066 A:middle
So we need some operation.

00:24:02.116 --> 00:24:03.706 A:middle
Let's call it index offsetBy.

00:24:04.506 --> 00:24:06.106 A:middle
To jump from the start index

00:24:06.516 --> 00:24:07.606 A:middle
quickly over to whatever

00:24:07.606 --> 00:24:08.816 A:middle
position we've selected.

00:24:10.106 --> 00:24:11.926 A:middle
The other operation we need is

00:24:11.926 --> 00:24:13.276 A:middle
the ability to swap two

00:24:13.276 --> 00:24:13.816 A:middle
elements.

00:24:14.916 --> 00:24:17.116 A:middle
Great. We have two operations

00:24:17.116 --> 00:24:18.086 A:middle
that we need to add to the

00:24:18.086 --> 00:24:19.596 A:middle
notion of a collection to be

00:24:19.596 --> 00:24:21.026 A:middle
able to implement shuffle.

00:24:21.336 --> 00:24:22.456 A:middle
Therefore, we have a new

00:24:22.456 --> 00:24:23.686 A:middle
shuffleCollection protocol.

00:24:25.976 --> 00:24:27.606 A:middle
Please don't do this.

00:24:28.096 --> 00:24:29.396 A:middle
So this is an anti-pattern that

00:24:29.396 --> 00:24:29.836 A:middle
we see.

00:24:30.466 --> 00:24:32.106 A:middle
And the anti-pattern here is we

00:24:32.106 --> 00:24:33.096 A:middle
had one algorithm.

00:24:33.276 --> 00:24:34.956 A:middle
We found its requirements, and

00:24:34.956 --> 00:24:36.236 A:middle
then we packaged it up into a

00:24:36.236 --> 00:24:38.366 A:middle
protocol that is just that one--

00:24:39.316 --> 00:24:40.296 A:middle
just describes that one

00:24:40.296 --> 00:24:40.856 A:middle
algorithm.

00:24:41.116 --> 00:24:42.556 A:middle
If you do this, you have lots

00:24:42.626 --> 00:24:44.236 A:middle
and lots and lots of protocols

00:24:44.236 --> 00:24:45.756 A:middle
around that don't have any

00:24:45.756 --> 00:24:46.526 A:middle
interesting meaning.

00:24:46.526 --> 00:24:47.656 A:middle
You're not learning anything

00:24:47.656 --> 00:24:48.526 A:middle
from those protocols.

00:24:49.026 --> 00:24:51.486 A:middle
So what you should do is notice

00:24:51.486 --> 00:24:52.956 A:middle
that we actually have distinct

00:24:52.956 --> 00:24:53.956 A:middle
capabilities here.

00:24:54.436 --> 00:24:55.536 A:middle
So shuffle is using random

00:24:55.536 --> 00:24:57.496 A:middle
access, and it's using mutation.

00:24:57.956 --> 00:24:58.806 A:middle
But, these are, these are

00:24:58.806 --> 00:25:00.076 A:middle
separate, and we can categorize

00:24:58.806 --> 00:25:00.076 A:middle
separate, and we can categorize

00:25:00.076 --> 00:25:01.546 A:middle
them in separate protocols.

00:25:02.056 --> 00:25:02.946 A:middle
So, for example, the

00:25:02.946 --> 00:25:04.576 A:middle
randomAccessCollection protocol

00:25:04.976 --> 00:25:06.686 A:middle
is something where it allows us

00:25:06.686 --> 00:25:08.516 A:middle
to jump around the collection,

00:25:08.596 --> 00:25:09.756 A:middle
moving indices quickly.

00:25:10.466 --> 00:25:11.476 A:middle
And there are types like

00:25:11.476 --> 00:25:12.886 A:middle
unsafeBufferPointer that can

00:25:12.886 --> 00:25:13.986 A:middle
give you random access.

00:25:14.326 --> 00:25:16.616 A:middle
But, do not allow any mutation.

00:25:16.736 --> 00:25:18.096 A:middle
That's a separate capability.

00:25:19.036 --> 00:25:19.826 A:middle
So, we also have the

00:25:19.826 --> 00:25:21.436 A:middle
mutableCollection protocol here.

00:25:22.366 --> 00:25:23.536 A:middle
And, we can think of types here

00:25:23.536 --> 00:25:24.976 A:middle
that allow mutation, but not

00:25:24.976 --> 00:25:25.896 A:middle
random access, like the

00:25:25.896 --> 00:25:27.186 A:middle
singlyLinkedList that we talked

00:25:27.186 --> 00:25:27.826 A:middle
about earlier.

00:25:28.556 --> 00:25:29.446 A:middle
Now, you notice that we've

00:25:29.446 --> 00:25:30.686 A:middle
essentially split the

00:25:30.686 --> 00:25:31.946 A:middle
inheritance hierarchy here.

00:25:33.246 --> 00:25:34.616 A:middle
We've got the access side for

00:25:34.616 --> 00:25:35.846 A:middle
random access, bidirectional,

00:25:35.846 --> 00:25:36.356 A:middle
and so on.

00:25:36.616 --> 00:25:37.446 A:middle
And then, we've got this

00:25:37.446 --> 00:25:38.266 A:middle
mutation side.

00:25:38.746 --> 00:25:39.816 A:middle
That's perfectly fine, because

00:25:39.816 --> 00:25:41.396 A:middle
clients themselves can compose

00:25:41.396 --> 00:25:43.736 A:middle
multiple protocols to implement

00:25:43.736 --> 00:25:44.776 A:middle
whatever generic algorithm

00:25:44.776 --> 00:25:45.246 A:middle
they're doing.

00:25:45.666 --> 00:25:46.876 A:middle
So, we go back to our shuffle

00:25:46.876 --> 00:25:47.406 A:middle
algorithm.

00:25:47.466 --> 00:25:49.466 A:middle
And it can be written as an

00:25:49.466 --> 00:25:50.396 A:middle
extension on

00:25:50.396 --> 00:25:52.056 A:middle
randomAccessCollection, with a

00:25:52.056 --> 00:25:52.666 A:middle
self-type.

00:25:52.666 --> 00:25:53.756 A:middle
So this is the type that

00:25:53.756 --> 00:25:54.246 A:middle
conforms to

00:25:54.246 --> 00:25:56.096 A:middle
randomAccessCollection also

00:25:56.096 --> 00:25:56.756 A:middle
conforms to the

00:25:56.756 --> 00:25:58.096 A:middle
mutableCollection protocol.

00:25:58.536 --> 00:25:59.516 A:middle
And now, we've pulled together

00:25:59.516 --> 00:26:00.556 A:middle
the capabilities of both of

00:25:59.516 --> 00:26:00.556 A:middle
the capabilities of both of

00:26:00.556 --> 00:26:00.886 A:middle
these.

00:26:02.416 --> 00:26:04.556 A:middle
Now, when you have a bunch of

00:26:04.556 --> 00:26:06.216 A:middle
conforming types, and a bunch of

00:26:06.216 --> 00:26:07.986 A:middle
generic algorithms, you tend to

00:26:07.986 --> 00:26:09.806 A:middle
get protocol hierarchies

00:26:09.806 --> 00:26:10.196 A:middle
forming.

00:26:10.666 --> 00:26:12.156 A:middle
Now, these hierarchies, they

00:26:12.156 --> 00:26:13.046 A:middle
shouldn't be too big.

00:26:13.176 --> 00:26:14.026 A:middle
They should not be too

00:26:14.026 --> 00:26:14.956 A:middle
fine-grained.

00:26:15.926 --> 00:26:17.046 A:middle
Because you really want a small

00:26:17.046 --> 00:26:18.066 A:middle
number of protocols that really

00:26:18.066 --> 00:26:19.776 A:middle
describe the kinds of types that

00:26:19.776 --> 00:26:21.426 A:middle
show up in the domain, right?

00:26:21.876 --> 00:26:23.766 A:middle
And now, there's things, things

00:26:23.766 --> 00:26:25.016 A:middle
that you notice when you do

00:26:25.016 --> 00:26:25.846 A:middle
build these protocol

00:26:25.846 --> 00:26:26.446 A:middle
hierarchies.

00:26:26.626 --> 00:26:27.826 A:middle
So, as you go from the bottom of

00:26:27.826 --> 00:26:29.646 A:middle
the hierarchy to the top, you're

00:26:29.646 --> 00:26:30.956 A:middle
going to protocols that have

00:26:30.956 --> 00:26:32.176 A:middle
fewer requirements.

00:26:32.306 --> 00:26:33.576 A:middle
And therefore, there are more

00:26:33.576 --> 00:26:35.306 A:middle
conforming types that can

00:26:35.306 --> 00:26:36.626 A:middle
implement those requirements.

00:26:37.566 --> 00:26:38.336 A:middle
Now, on the other hand, as

00:26:38.336 --> 00:26:39.416 A:middle
you're moving down the

00:26:39.466 --> 00:26:41.666 A:middle
hierarchy, and combining

00:26:41.666 --> 00:26:42.646 A:middle
different protocols from the

00:26:42.696 --> 00:26:43.176 A:middle
hierarchy.

00:26:43.626 --> 00:26:44.746 A:middle
You get to implement more

00:26:44.746 --> 00:26:46.076 A:middle
intricate, more specialized

00:26:46.076 --> 00:26:47.676 A:middle
algorithms that require more

00:26:47.676 --> 00:26:48.686 A:middle
advanced capabilities.

00:26:48.896 --> 00:26:50.006 A:middle
But naturally work with fewer

00:26:50.006 --> 00:26:50.836 A:middle
conforming types.

00:26:54.556 --> 00:26:56.306 A:middle
Okay. So let's talk about

00:26:56.306 --> 00:26:57.246 A:middle
conditional conformance.

00:26:57.306 --> 00:26:58.376 A:middle
This is, of course, a newer

00:26:58.376 --> 00:27:00.396 A:middle
feature in, in Swift.

00:26:58.376 --> 00:27:00.396 A:middle
feature in, in Swift.

00:27:00.646 --> 00:27:02.216 A:middle
And, let's start by looking at

00:27:02.216 --> 00:27:02.946 A:middle
slices again.

00:27:03.516 --> 00:27:04.796 A:middle
So for any collection that you

00:27:04.796 --> 00:27:07.276 A:middle
have, you can form a slice of

00:27:07.276 --> 00:27:09.136 A:middle
that collection by subscripting

00:27:09.356 --> 00:27:12.236 A:middle
with a particular range of

00:27:12.236 --> 00:27:12.856 A:middle
indices.

00:27:13.326 --> 00:27:14.696 A:middle
And, that slice is essentially a

00:27:14.696 --> 00:27:16.256 A:middle
view into some part of the

00:27:16.256 --> 00:27:16.796 A:middle
collection.

00:27:17.986 --> 00:27:20.366 A:middle
Now these are default type that

00:27:20.366 --> 00:27:21.366 A:middle
you get from slicing a

00:27:21.366 --> 00:27:23.696 A:middle
collection, is called slice.

00:27:24.486 --> 00:27:26.146 A:middle
And slice is a generic adaptor

00:27:26.146 --> 00:27:26.376 A:middle
type.

00:27:27.366 --> 00:27:30.066 A:middle
So it is parameterized on a base

00:27:30.106 --> 00:27:32.016 A:middle
collection type, and it is

00:27:32.016 --> 00:27:33.216 A:middle
itself a collection.

00:27:33.936 --> 00:27:36.466 A:middle
So our expectation on a slice is

00:27:36.466 --> 00:27:37.636 A:middle
that you can do anything to a

00:27:37.636 --> 00:27:38.676 A:middle
slice that you can do to the

00:27:38.676 --> 00:27:39.826 A:middle
underlying collection.

00:27:40.146 --> 00:27:41.266 A:middle
It's a reasonable thing to want.

00:27:41.966 --> 00:27:43.636 A:middle
And so, certainly we can go and

00:27:43.636 --> 00:27:44.496 A:middle
use the forward search

00:27:44.496 --> 00:27:46.376 A:middle
operations like indexwhere, to

00:27:46.376 --> 00:27:47.406 A:middle
go find something matching a

00:27:47.406 --> 00:27:47.786 A:middle
predicate.

00:27:47.786 --> 00:27:49.226 A:middle
And that works on the collection

00:27:49.326 --> 00:27:50.226 A:middle
and any slice of that

00:27:50.226 --> 00:27:50.696 A:middle
collection.

00:27:51.576 --> 00:27:52.676 A:middle
So, we'd like to do the same

00:27:52.676 --> 00:27:54.506 A:middle
thing with backwards search, but

00:27:54.506 --> 00:27:55.456 A:middle
here we're going to run into a

00:27:55.456 --> 00:27:55.886 A:middle
problem.

00:27:55.886 --> 00:27:57.096 A:middle
So even if the buffer is a

00:27:57.276 --> 00:27:59.756 A:middle
bidirectionalCollection, nothing

00:27:59.756 --> 00:28:00.946 A:middle
has said that the slice is a

00:27:59.756 --> 00:28:00.946 A:middle
has said that the slice is a

00:28:00.946 --> 00:28:01.976 A:middle
bidirectionalCollection.

00:28:02.636 --> 00:28:05.966 A:middle
We can fix that.

00:28:05.966 --> 00:28:07.606 A:middle
Let's extend slice to make it

00:28:07.606 --> 00:28:08.156 A:middle
conform to the

00:28:08.156 --> 00:28:09.156 A:middle
bidirectionalCollection

00:28:09.156 --> 00:28:09.596 A:middle
protocol.

00:28:10.536 --> 00:28:11.676 A:middle
We need to implement this index

00:28:11.676 --> 00:28:13.026 A:middle
before operation, which we can

00:28:13.026 --> 00:28:14.486 A:middle
implement in terms of the

00:28:14.486 --> 00:28:16.176 A:middle
underlying base collection.

00:28:17.146 --> 00:28:18.086 A:middle
Except the compiler's going to

00:28:18.086 --> 00:28:18.666 A:middle
complain here.

00:28:19.736 --> 00:28:21.016 A:middle
The only thing we knew about

00:28:21.016 --> 00:28:22.676 A:middle
that base collection is that

00:28:22.676 --> 00:28:23.516 A:middle
it's a collection.

00:28:23.666 --> 00:28:25.366 A:middle
It doesn't have an index before

00:28:25.366 --> 00:28:26.286 A:middle
operation on it.

00:28:27.806 --> 00:28:28.966 A:middle
We know how to fix this.

00:28:29.516 --> 00:28:31.176 A:middle
All we need to do is introduce a

00:28:31.176 --> 00:28:32.646 A:middle
requirement into this extension

00:28:32.646 --> 00:28:33.766 A:middle
to say that well, base needs to

00:28:33.766 --> 00:28:35.016 A:middle
be a bidirectionalCollection.

00:28:35.786 --> 00:28:37.186 A:middle
This is conditional conformance.

00:28:38.146 --> 00:28:40.216 A:middle
All it is, is extensions that

00:28:40.216 --> 00:28:41.836 A:middle
declare conformance to a

00:28:41.836 --> 00:28:42.366 A:middle
protocol.

00:28:42.796 --> 00:28:44.016 A:middle
And then the constraints under

00:28:44.016 --> 00:28:45.416 A:middle
which that conformance actually

00:28:45.416 --> 00:28:46.136 A:middle
makes sense.

00:28:46.966 --> 00:28:48.006 A:middle
And the wonderful thing about

00:28:48.006 --> 00:28:49.146 A:middle
conditional conformance, is it

00:28:49.146 --> 00:28:50.326 A:middle
stacks nicely when you have

00:28:50.326 --> 00:28:51.516 A:middle
these protocol hierarchies.

00:28:51.836 --> 00:28:54.146 A:middle
So we can also state that slice

00:28:54.146 --> 00:28:55.656 A:middle
is a randomAccessCollection.

00:28:56.026 --> 00:28:58.056 A:middle
When its underlying base type is

00:28:58.056 --> 00:28:59.286 A:middle
a randomAccessCollection.

00:29:00.486 --> 00:29:01.456 A:middle
Now, notice that I've written

00:29:01.556 --> 00:29:02.806 A:middle
two different extensions here.

00:29:03.806 --> 00:29:05.086 A:middle
Now, it's generally good Swift

00:29:05.086 --> 00:29:05.546 A:middle
style.

00:29:06.066 --> 00:29:07.026 A:middle
Write an extension, have it

00:29:07.026 --> 00:29:08.616 A:middle
conform to one protocol, so you

00:29:08.616 --> 00:29:10.066 A:middle
know what that extension is for,

00:29:10.066 --> 00:29:10.966 A:middle
you know its meaning.

00:29:11.466 --> 00:29:13.546 A:middle
It's particularly important with

00:29:13.796 --> 00:29:15.106 A:middle
conditional requirements,

00:29:15.456 --> 00:29:17.526 A:middle
conformances, because you have

00:29:17.586 --> 00:29:19.006 A:middle
different requirements on these

00:29:19.006 --> 00:29:19.796 A:middle
extensions.

00:29:20.376 --> 00:29:22.036 A:middle
And, this allows for

00:29:22.036 --> 00:29:22.836 A:middle
composability.

00:29:22.896 --> 00:29:24.436 A:middle
Whatever the underlying base

00:29:24.466 --> 00:29:26.316 A:middle
collection can do, the slice

00:29:26.316 --> 00:29:27.326 A:middle
type can also do.

00:29:28.796 --> 00:29:31.346 A:middle
So let's look at another

00:29:31.346 --> 00:29:32.326 A:middle
application of conditional

00:29:32.326 --> 00:29:33.556 A:middle
conformance, also in the

00:29:33.556 --> 00:29:34.866 A:middle
standard library, and these are

00:29:34.866 --> 00:29:35.366 A:middle
ranges.

00:29:35.526 --> 00:29:36.646 A:middle
So, ranges have been around

00:29:36.856 --> 00:29:37.666 A:middle
forever in Swift.

00:29:37.666 --> 00:29:38.806 A:middle
And, you can form a range with,

00:29:38.896 --> 00:29:40.156 A:middle
for example, these dot-dot less

00:29:40.156 --> 00:29:40.936 A:middle
than operations.

00:29:41.426 --> 00:29:43.106 A:middle
And so you can form ranges of

00:29:43.106 --> 00:29:44.506 A:middle
doubles, you can form ranges of

00:29:44.506 --> 00:29:45.346 A:middle
integers.

00:29:45.946 --> 00:29:47.086 A:middle
But some ranges are more

00:29:47.086 --> 00:29:48.156 A:middle
powerful than others.

00:29:48.416 --> 00:29:49.786 A:middle
So, you can iterate over the

00:29:49.786 --> 00:29:52.316 A:middle
elements in a range of integers.

00:29:52.926 --> 00:29:53.876 A:middle
Well, why can you do that?

00:29:53.876 --> 00:29:55.066 A:middle
It was because an intRange

00:29:55.576 --> 00:29:56.806 A:middle
conforms to collection.

00:29:58.266 --> 00:29:59.276 A:middle
Now, if you're actually look at

00:29:59.276 --> 00:30:00.606 A:middle
the type, it's reduced by that

00:29:59.276 --> 00:30:00.606 A:middle
the type, it's reduced by that

00:30:00.646 --> 00:30:01.996 A:middle
dot-dot less-than operator.

00:30:02.346 --> 00:30:04.306 A:middle
It is aptly named the range

00:30:04.306 --> 00:30:04.556 A:middle
type.

00:30:05.346 --> 00:30:07.096 A:middle
Again, it's generic over the

00:30:07.096 --> 00:30:08.126 A:middle
underlying bound type.

00:30:08.126 --> 00:30:09.256 A:middle
So in this case, we have a range

00:30:09.256 --> 00:30:11.126 A:middle
of doubles, and it merely stores

00:30:11.126 --> 00:30:12.456 A:middle
the lower and upper bounds.

00:30:12.646 --> 00:30:13.456 A:middle
That's fairly simple.

00:30:14.286 --> 00:30:16.806 A:middle
But, prior to Swift 4.2, you

00:30:16.806 --> 00:30:18.816 A:middle
would get from an integer range,

00:30:18.876 --> 00:30:20.036 A:middle
an actually different type.

00:30:20.466 --> 00:30:22.176 A:middle
This is the countableRange type.

00:30:23.126 --> 00:30:24.466 A:middle
Now, notice it's structurally

00:30:24.466 --> 00:30:26.056 A:middle
the same as the range type.

00:30:26.056 --> 00:30:27.236 A:middle
It has one type parameter.

00:30:27.236 --> 00:30:28.696 A:middle
It has lower and upperBound.

00:30:29.246 --> 00:30:31.126 A:middle
But it adds a couple additional

00:30:31.126 --> 00:30:32.686 A:middle
requirements onto that bound

00:30:32.686 --> 00:30:32.886 A:middle
type.

00:30:33.286 --> 00:30:34.876 A:middle
That the bound be stridable,

00:30:35.286 --> 00:30:35.416 A:middle
right?

00:30:35.416 --> 00:30:36.446 A:middle
Meaning you can walk through and

00:30:36.446 --> 00:30:37.436 A:middle
enumerate all the elements.

00:30:37.866 --> 00:30:39.286 A:middle
Now that's the ability you need

00:30:39.446 --> 00:30:40.056 A:middle
so that you can make

00:30:40.056 --> 00:30:41.316 A:middle
countableRange conform to

00:30:41.316 --> 00:30:42.456 A:middle
randomAccessCollection.

00:30:43.676 --> 00:30:45.136 A:middle
That enables the forEach, the

00:30:45.136 --> 00:30:46.246 A:middle
forEach iteration loop, and

00:30:46.246 --> 00:30:46.826 A:middle
other things.

00:30:48.076 --> 00:30:48.706 A:middle
But with conditional

00:30:48.706 --> 00:30:49.986 A:middle
conformance, of course, we can

00:30:49.986 --> 00:30:50.736 A:middle
do better.

00:30:51.516 --> 00:30:53.836 A:middle
So let's turn the basic range

00:30:53.836 --> 00:30:57.306 A:middle
type into a collection, when the

00:30:57.306 --> 00:30:59.086 A:middle
bound type conforms this-- has

00:30:59.086 --> 00:31:00.586 A:middle
these extra stridable

00:30:59.086 --> 00:31:00.586 A:middle
these extra stridable

00:31:00.586 --> 00:31:01.376 A:middle
requirements on it.

00:31:01.736 --> 00:31:02.736 A:middle
It's a simple application of

00:31:02.736 --> 00:31:03.706 A:middle
conditional conformance.

00:31:04.166 --> 00:31:05.746 A:middle
But it makes the range type more

00:31:05.816 --> 00:31:08.186 A:middle
powerful when used with better

00:31:08.236 --> 00:31:09.266 A:middle
type parameters.

00:31:10.806 --> 00:31:13.206 A:middle
Now, notice that I'm just

00:31:13.206 --> 00:31:13.696 A:middle
conforming to

00:31:13.696 --> 00:31:14.876 A:middle
randomAccessCollection.

00:31:15.496 --> 00:31:17.686 A:middle
I have not actually mentioned

00:31:17.746 --> 00:31:18.236 A:middle
collection or

00:31:18.236 --> 00:31:19.326 A:middle
bidirectionalCollection.

00:31:20.366 --> 00:31:21.876 A:middle
With unconditional performances,

00:31:21.876 --> 00:31:22.546 A:middle
this is okay.

00:31:23.036 --> 00:31:24.356 A:middle
Declaring conformance to

00:31:24.356 --> 00:31:26.446 A:middle
randomAccessCollection implies

00:31:26.446 --> 00:31:28.276 A:middle
conformances to any protocols

00:31:28.276 --> 00:31:29.526 A:middle
that it inherits.

00:31:29.586 --> 00:31:30.286 A:middle
In this case,

00:31:30.366 --> 00:31:31.416 A:middle
bidirectionalCollection and

00:31:31.416 --> 00:31:31.946 A:middle
collection.

00:31:32.626 --> 00:31:34.016 A:middle
However, with conditional

00:31:34.016 --> 00:31:35.326 A:middle
conformance, this is actually an

00:31:35.326 --> 00:31:35.586 A:middle
error.

00:31:36.576 --> 00:31:37.636 A:middle
Now, if you think back to the

00:31:37.636 --> 00:31:39.666 A:middle
slice example, we needed to have

00:31:39.776 --> 00:31:41.686 A:middle
different constraints for those,

00:31:41.926 --> 00:31:43.186 A:middle
for those different levels of

00:31:43.186 --> 00:31:44.466 A:middle
the hierarchy for collection.

00:31:44.466 --> 00:31:45.746 A:middle
Versus bidirectionalCollection

00:31:45.746 --> 00:31:47.176 A:middle
versus randomAccessCollection.

00:31:47.756 --> 00:31:49.416 A:middle
And so, compiler's enforcing

00:31:49.416 --> 00:31:50.636 A:middle
that you've thought about this,

00:31:50.636 --> 00:31:52.096 A:middle
and made sure that you have the

00:31:52.146 --> 00:31:53.426 A:middle
right set of constraints for

00:31:53.736 --> 00:31:54.776 A:middle
conditional conformance.

00:31:55.906 --> 00:31:57.406 A:middle
In this case, the constraints

00:31:57.406 --> 00:31:58.596 A:middle
across the entire hierarchy are

00:31:58.596 --> 00:31:59.076 A:middle
the same.

00:31:59.416 --> 00:32:00.506 A:middle
So, we can just write out

00:31:59.416 --> 00:32:00.506 A:middle
So, we can just write out

00:32:00.506 --> 00:32:01.646 A:middle
explicitly collection and

00:32:01.646 --> 00:32:02.756 A:middle
bidirectionalCollection.

00:32:03.346 --> 00:32:05.066 A:middle
To assert that this is where all

00:32:05.066 --> 00:32:06.056 A:middle
these conformances are.

00:32:06.506 --> 00:32:07.936 A:middle
Or we can do the stylistically

00:32:07.936 --> 00:32:09.616 A:middle
better thing, and split out the

00:32:09.616 --> 00:32:10.556 A:middle
different conformances.

00:32:12.486 --> 00:32:13.726 A:middle
Now at this point, our range

00:32:13.726 --> 00:32:15.346 A:middle
type is pretty powerful.

00:32:15.346 --> 00:32:15.946 A:middle
It does everything the

00:32:15.946 --> 00:32:17.016 A:middle
countableRange does.

00:32:17.296 --> 00:32:17.976 A:middle
So what should we do with

00:32:17.976 --> 00:32:18.686 A:middle
countableRange?

00:32:19.536 --> 00:32:20.206 A:middle
We could throw it away.

00:32:20.726 --> 00:32:21.496 A:middle
In this case we're talking about

00:32:21.496 --> 00:32:23.066 A:middle
the standard library, and

00:32:23.066 --> 00:32:23.936 A:middle
there's a lot of code that

00:32:23.936 --> 00:32:25.706 A:middle
actually uses countableRange.

00:32:25.986 --> 00:32:28.176 A:middle
So we can keep it around as a

00:32:28.176 --> 00:32:29.586 A:middle
generic type alias.

00:32:30.886 --> 00:32:32.476 A:middle
This is a really nice solution.

00:32:32.476 --> 00:32:34.466 A:middle
So the generic type alias adds

00:32:34.546 --> 00:32:35.886 A:middle
all of those extra requirements

00:32:35.886 --> 00:32:37.306 A:middle
you need to make the range

00:32:37.306 --> 00:32:37.806 A:middle
countable.

00:32:38.066 --> 00:32:39.276 A:middle
The requirements you need to

00:32:39.276 --> 00:32:42.056 A:middle
turn it into a collection, but

00:32:42.056 --> 00:32:43.366 A:middle
it's just an alternate name for

00:32:43.366 --> 00:32:44.706 A:middle
the underlying range type.

00:32:46.826 --> 00:32:47.806 A:middle
Again, this is great for source

00:32:47.806 --> 00:32:49.166 A:middle
compatibility, because code can

00:32:49.166 --> 00:32:50.846 A:middle
still use countableRange.

00:32:51.116 --> 00:32:52.416 A:middle
On the other hand, it's also

00:32:52.466 --> 00:32:54.466 A:middle
really nice to give a name to

00:32:54.466 --> 00:32:56.046 A:middle
those ranges that have

00:32:56.046 --> 00:32:57.856 A:middle
additional capabilities of being

00:32:57.856 --> 00:32:59.286 A:middle
a randomAccessCollection.

00:32:59.916 --> 00:33:01.276 A:middle
In fact, we can use this to

00:32:59.916 --> 00:33:01.276 A:middle
In fact, we can use this to

00:33:01.276 --> 00:33:02.206 A:middle
clean up other code.

00:33:02.206 --> 00:33:03.466 A:middle
To say, well, we know what a

00:33:03.466 --> 00:33:04.476 A:middle
countableRange is.

00:33:04.876 --> 00:33:06.876 A:middle
It's a range with this extra

00:33:06.876 --> 00:33:09.106 A:middle
striding capability, so we can

00:33:09.106 --> 00:33:10.616 A:middle
go extend countableRanges.

00:33:10.916 --> 00:33:12.776 A:middle
And that is a case in which we

00:33:12.776 --> 00:33:14.466 A:middle
have randomAccessCollection

00:33:14.466 --> 00:33:14.996 A:middle
conformance.

00:33:16.446 --> 00:33:17.426 A:middle
So, we've introduced this in

00:33:17.426 --> 00:33:19.866 A:middle
Swift 4.2 to help simplify the

00:33:19.866 --> 00:33:20.906 A:middle
set of types that we're dealing

00:33:20.906 --> 00:33:21.136 A:middle
with.

00:33:21.136 --> 00:33:22.706 A:middle
And make the existing core types

00:33:22.706 --> 00:33:24.656 A:middle
like range more composable and

00:33:24.656 --> 00:33:25.346 A:middle
more flexible.

00:33:27.756 --> 00:33:28.966 A:middle
&gt;&gt; Recursive constraints

00:33:28.966 --> 00:33:30.726 A:middle
describe relationships among

00:33:30.726 --> 00:33:32.316 A:middle
protocols and their associated

00:33:32.316 --> 00:33:32.756 A:middle
types.

00:33:33.336 --> 00:33:34.836 A:middle
This is a topic that we didn't

00:33:34.836 --> 00:33:36.616 A:middle
cover in the WWDC version of

00:33:36.616 --> 00:33:37.136 A:middle
this talk.

00:33:37.416 --> 00:33:38.776 A:middle
But it's an important part of

00:33:38.776 --> 00:33:40.436 A:middle
the standard library's use of

00:33:40.436 --> 00:33:41.666 A:middle
Swift's generic system.

00:33:42.216 --> 00:33:43.006 A:middle
Let's jump right in.

00:33:43.936 --> 00:33:45.556 A:middle
A recursive constraint is

00:33:45.556 --> 00:33:47.046 A:middle
nothing more than a constraint

00:33:47.076 --> 00:33:48.856 A:middle
within a protocol that mentions

00:33:48.886 --> 00:33:50.336 A:middle
that same protocol.

00:33:51.036 --> 00:33:52.616 A:middle
Here, collection has an

00:33:52.616 --> 00:33:53.986 A:middle
associated type named

00:33:53.986 --> 00:33:54.886 A:middle
subsequence.

00:33:55.196 --> 00:33:57.136 A:middle
That is itself a collection.

00:33:57.726 --> 00:33:58.786 A:middle
Why would you need this?

00:33:59.316 --> 00:34:00.886 A:middle
Well, let's look at a generic

00:33:59.316 --> 00:34:00.886 A:middle
Well, let's look at a generic

00:34:00.886 --> 00:34:02.566 A:middle
algorithm that relies on it.

00:34:03.086 --> 00:34:05.386 A:middle
So here, given an already sorted

00:34:05.386 --> 00:34:06.006 A:middle
collection.

00:34:06.316 --> 00:34:07.906 A:middle
We want to find the index at

00:34:07.906 --> 00:34:09.496 A:middle
which we should insert a new

00:34:09.496 --> 00:34:10.065 A:middle
value.

00:34:10.335 --> 00:34:12.076 A:middle
To maintain that sort order.

00:34:12.456 --> 00:34:13.255 A:middle
We're going to compute the

00:34:13.255 --> 00:34:14.656 A:middle
sorted insertion point for the

00:34:14.656 --> 00:34:15.585 A:middle
value 11.

00:34:16.335 --> 00:34:17.985 A:middle
When we go ahead and insert 11

00:34:17.985 --> 00:34:19.936 A:middle
at that index, the result is

00:34:19.936 --> 00:34:21.406 A:middle
still a sorted array.

00:34:22.036 --> 00:34:23.315 A:middle
The sorted insertion point of

00:34:23.315 --> 00:34:25.386 A:middle
function is implemented in terms

00:34:25.386 --> 00:34:26.846 A:middle
of a binary search.

00:34:27.536 --> 00:34:28.806 A:middle
Binary search is a classic

00:34:28.806 --> 00:34:30.716 A:middle
divide-and-conquer algorithm.

00:34:31.005 --> 00:34:32.766 A:middle
Meaning that at each step, it

00:34:32.766 --> 00:34:34.646 A:middle
makes a decision that allows it

00:34:34.646 --> 00:34:35.985 A:middle
to significantly reduce the

00:34:35.985 --> 00:34:37.056 A:middle
problem size.

00:34:37.196 --> 00:34:38.876 A:middle
For the next step to consider.

00:34:38.876 --> 00:34:41.476 A:middle
For binary search, we first look

00:34:41.476 --> 00:34:43.216 A:middle
at the middle element, 8.

00:34:43.735 --> 00:34:44.966 A:middle
And compare it against the value

00:34:44.966 --> 00:34:45.755 A:middle
that we want to insert.

00:34:45.976 --> 00:34:46.545 A:middle
That's 11.

00:34:47.226 --> 00:34:49.085 A:middle
And because 11 is greater than

00:34:49.085 --> 00:34:51.085 A:middle
8, we know that 11 needs to be

00:34:51.085 --> 00:34:53.476 A:middle
inserted somewhere after the 8.

00:34:53.585 --> 00:34:54.556 A:middle
In the latter half of the

00:34:54.556 --> 00:34:55.136 A:middle
collection.

00:34:55.626 --> 00:34:57.136 A:middle
So we restrict our search space

00:34:57.236 --> 00:34:57.826 A:middle
by half.

00:34:59.096 --> 00:35:00.726 A:middle
In our next step, we find the

00:34:59.096 --> 00:35:00.726 A:middle
In our next step, we find the

00:35:00.726 --> 00:35:02.956 A:middle
new middle, 14, and compare it

00:35:02.956 --> 00:35:03.856 A:middle
against the value we want to

00:35:03.856 --> 00:35:04.246 A:middle
insert.

00:35:05.196 --> 00:35:07.546 A:middle
Eleven is less than 14, so the

00:35:07.546 --> 00:35:09.326 A:middle
insertion point has to come

00:35:09.556 --> 00:35:10.776 A:middle
before the middle.

00:35:11.246 --> 00:35:12.526 A:middle
Divide the remaining collection

00:35:12.526 --> 00:35:13.676 A:middle
in half again.

00:35:14.586 --> 00:35:15.876 A:middle
Continue dividing collection

00:35:15.876 --> 00:35:16.976 A:middle
we're looking at in half.

00:35:17.096 --> 00:35:18.306 A:middle
Until we're pointing at the

00:35:18.306 --> 00:35:19.626 A:middle
proper insertion point.

00:35:19.966 --> 00:35:20.986 A:middle
That's our solution.

00:35:22.546 --> 00:35:23.616 A:middle
Divide-and-conquer algorithms

00:35:23.616 --> 00:35:25.216 A:middle
like this are fantastic.

00:35:25.556 --> 00:35:27.316 A:middle
Because they're extremely fast.

00:35:27.806 --> 00:35:30.056 A:middle
Binary search takes logarithmic

00:35:30.056 --> 00:35:30.486 A:middle
time.

00:35:30.726 --> 00:35:32.076 A:middle
Which means that doubling your

00:35:32.076 --> 00:35:33.616 A:middle
input size doesn't make the

00:35:33.616 --> 00:35:35.426 A:middle
algorithm run twice as slowly

00:35:35.496 --> 00:35:36.436 A:middle
like it would for a linear

00:35:36.436 --> 00:35:36.906 A:middle
algorithm.

00:35:37.416 --> 00:35:38.716 A:middle
With a logarithmic algorithm

00:35:38.716 --> 00:35:40.646 A:middle
like binary search, it only has

00:35:40.646 --> 00:35:42.726 A:middle
to perform one additional step

00:35:43.206 --> 00:35:44.906 A:middle
to cut the problem size in half

00:35:44.906 --> 00:35:45.336 A:middle
again.

00:35:45.876 --> 00:35:47.646 A:middle
So let's turn that into code.

00:35:48.226 --> 00:35:50.146 A:middle
The first thing we need to do is

00:35:50.146 --> 00:35:51.996 A:middle
find the index of the middle

00:35:51.996 --> 00:35:52.506 A:middle
element.

00:35:52.706 --> 00:35:53.566 A:middle
Which we can do using

00:35:53.566 --> 00:35:55.446 A:middle
randomAccessCollections index

00:35:55.446 --> 00:35:56.746 A:middle
offset by a function.

00:35:57.616 --> 00:35:59.526 A:middle
Next, we check whether our value

00:35:59.526 --> 00:36:01.716 A:middle
comes before the middle element.

00:35:59.526 --> 00:36:01.716 A:middle
comes before the middle element.

00:36:01.956 --> 00:36:03.166 A:middle
So we know which half of the

00:36:03.166 --> 00:36:04.696 A:middle
collection contains our

00:36:04.696 --> 00:36:05.516 A:middle
insertion point.

00:36:06.516 --> 00:36:08.396 A:middle
Now in our example, the value to

00:36:08.396 --> 00:36:09.626 A:middle
insert is greater than the

00:36:09.626 --> 00:36:10.316 A:middle
middle element.

00:36:10.656 --> 00:36:11.846 A:middle
So we take a slice of the

00:36:11.846 --> 00:36:13.766 A:middle
collection from the index after

00:36:13.766 --> 00:36:14.316 A:middle
the middle.

00:36:14.576 --> 00:36:16.036 A:middle
All the way until the end.

00:36:16.556 --> 00:36:18.106 A:middle
And recursively call sort and

00:36:18.106 --> 00:36:19.616 A:middle
insertion point of on that

00:36:19.616 --> 00:36:20.266 A:middle
slice.

00:36:20.686 --> 00:36:21.466 A:middle
This is common of

00:36:21.466 --> 00:36:22.936 A:middle
divide-and-conquer algorithms.

00:36:23.126 --> 00:36:24.236 A:middle
Where you reduce the problem

00:36:24.236 --> 00:36:26.036 A:middle
space and then recurse.

00:36:26.036 --> 00:36:28.706 A:middle
Now to make this work, we need

00:36:28.706 --> 00:36:30.116 A:middle
that slicing syntax.

00:36:30.116 --> 00:36:31.636 A:middle
Provide a suitable slice of a

00:36:31.636 --> 00:36:32.316 A:middle
collection.

00:36:33.076 --> 00:36:34.356 A:middle
We can do this for all

00:36:34.356 --> 00:36:35.966 A:middle
collections by introducing a

00:36:35.966 --> 00:36:37.846 A:middle
general operation that takes a

00:36:37.846 --> 00:36:40.496 A:middle
range of indices and produces a

00:36:40.496 --> 00:36:40.966 A:middle
slice.

00:36:41.296 --> 00:36:41.816 A:middle
Like this.

00:36:42.966 --> 00:36:44.386 A:middle
Now remember that the slice

00:36:44.386 --> 00:36:46.086 A:middle
adapter we discussed earlier

00:36:46.126 --> 00:36:47.896 A:middle
works on any collection.

00:36:48.116 --> 00:36:50.066 A:middle
Providing a view of the elements

00:36:50.066 --> 00:36:51.576 A:middle
of the underlying collection

00:36:51.866 --> 00:36:53.956 A:middle
that is itself a collection.

00:36:54.616 --> 00:36:55.166 A:middle
This makes our

00:36:55.166 --> 00:36:56.286 A:middle
divide-and-conquer algorithm

00:36:56.286 --> 00:36:57.776 A:middle
work for any collection.

00:36:58.196 --> 00:36:59.916 A:middle
As well as providing slicing

00:36:59.916 --> 00:37:02.186 A:middle
syntax to all collections.

00:36:59.916 --> 00:37:02.186 A:middle
syntax to all collections.

00:37:02.766 --> 00:37:03.966 A:middle
That's great, but there's just

00:37:03.966 --> 00:37:04.776 A:middle
one problem.

00:37:05.536 --> 00:37:07.296 A:middle
Some collections don't want this

00:37:07.296 --> 00:37:08.786 A:middle
particular slice type.

00:37:09.306 --> 00:37:10.456 A:middle
They really want to provide

00:37:10.456 --> 00:37:12.226 A:middle
their own slicing operations

00:37:12.466 --> 00:37:14.056 A:middle
that produce a different type.

00:37:14.606 --> 00:37:16.086 A:middle
String is the most common

00:37:16.086 --> 00:37:16.626 A:middle
example.

00:37:17.016 --> 00:37:19.106 A:middle
When you slice a string, you get

00:37:19.106 --> 00:37:20.406 A:middle
back a substring.

00:37:21.516 --> 00:37:22.466 A:middle
And so if you apply our

00:37:22.466 --> 00:37:24.056 A:middle
divide-and-conquer algorithms to

00:37:24.236 --> 00:37:25.436 A:middle
the string collection.

00:37:25.666 --> 00:37:26.776 A:middle
You really want those to be in

00:37:26.776 --> 00:37:27.786 A:middle
terms of substring.

00:37:27.966 --> 00:37:29.196 A:middle
Rather than some other type like

00:37:29.196 --> 00:37:30.086 A:middle
the slice of a string.

00:37:30.836 --> 00:37:32.526 A:middle
Range is another interesting

00:37:32.526 --> 00:37:33.176 A:middle
example.

00:37:33.406 --> 00:37:35.146 A:middle
Because its slicing operation

00:37:35.376 --> 00:37:37.436 A:middle
returns an instance of the exact

00:37:37.436 --> 00:37:39.766 A:middle
same range type just with the

00:37:39.766 --> 00:37:40.626 A:middle
new bounds.

00:37:41.306 --> 00:37:43.126 A:middle
So to capture this variation

00:37:43.246 --> 00:37:44.766 A:middle
among different types that

00:37:44.766 --> 00:37:46.676 A:middle
conform to collection, we can

00:37:46.676 --> 00:37:48.796 A:middle
introduce new requirements into

00:37:48.796 --> 00:37:49.896 A:middle
the collection protocol.

00:37:50.066 --> 00:37:51.486 A:middle
Specifically for slicing.

00:37:52.396 --> 00:37:54.176 A:middle
So here we've pulled the slicing

00:37:54.176 --> 00:37:55.606 A:middle
subscript into the collection

00:37:55.606 --> 00:37:57.536 A:middle
protocol itself as a

00:37:57.536 --> 00:37:58.316 A:middle
requirement.

00:37:59.136 --> 00:38:00.686 A:middle
Now note that the result type of

00:37:59.136 --> 00:38:00.686 A:middle
Now note that the result type of

00:38:00.686 --> 00:38:02.846 A:middle
this subscript is described by a

00:38:02.846 --> 00:38:04.216 A:middle
new associated type:

00:38:04.676 --> 00:38:05.426 A:middle
subsequence.

00:38:06.886 --> 00:38:09.446 A:middle
Now both string and range meet

00:38:09.446 --> 00:38:10.656 A:middle
these new requirements of

00:38:10.656 --> 00:38:11.296 A:middle
collection.

00:38:11.976 --> 00:38:13.736 A:middle
With string, the subsequence

00:38:13.736 --> 00:38:15.256 A:middle
type is substring.

00:38:16.506 --> 00:38:18.606 A:middle
For range, the subsequence type

00:38:18.606 --> 00:38:20.166 A:middle
is going to be the range itself.

00:38:20.166 --> 00:38:22.766 A:middle
Now this works well for, for

00:38:22.766 --> 00:38:23.596 A:middle
string and range.

00:38:23.736 --> 00:38:25.326 A:middle
But for all the other collection

00:38:25.326 --> 00:38:26.856 A:middle
types that don't want to

00:38:26.856 --> 00:38:28.646 A:middle
customize the actual subsequence

00:38:28.646 --> 00:38:28.926 A:middle
type.

00:38:29.346 --> 00:38:30.536 A:middle
We can provide default

00:38:30.536 --> 00:38:31.736 A:middle
limitations of slicing.

00:38:32.396 --> 00:38:33.326 A:middle
So the authors of these

00:38:33.326 --> 00:38:34.646 A:middle
collection type don't actually

00:38:34.646 --> 00:38:36.536 A:middle
have to do any extra work to

00:38:36.536 --> 00:38:37.666 A:middle
conform to collection.

00:38:37.906 --> 00:38:38.996 A:middle
They get all the slicing

00:38:38.996 --> 00:38:40.126 A:middle
behavior for free.

00:38:41.056 --> 00:38:42.366 A:middle
So we're going to start with

00:38:42.366 --> 00:38:43.206 A:middle
subsequence.

00:38:44.006 --> 00:38:46.066 A:middle
Associated types themselves can

00:38:46.066 --> 00:38:47.706 A:middle
have default values.

00:38:48.176 --> 00:38:50.036 A:middle
Written after the equals sign.

00:38:50.436 --> 00:38:52.576 A:middle
For subsequence, the slice

00:38:52.576 --> 00:38:54.156 A:middle
adaptor type is a perfect

00:38:54.156 --> 00:38:56.076 A:middle
default because it works for all

00:38:56.076 --> 00:38:56.906 A:middle
collections.

00:38:57.026 --> 00:38:58.806 A:middle
So this default will be used for

00:38:58.806 --> 00:39:00.736 A:middle
any conforming type that doesn't

00:38:58.806 --> 00:39:00.736 A:middle
any conforming type that doesn't

00:39:00.736 --> 00:39:02.626 A:middle
provide its own subsequence

00:39:02.626 --> 00:39:02.946 A:middle
type.

00:39:04.106 --> 00:39:05.576 A:middle
This pairs well with the

00:39:05.576 --> 00:39:06.896 A:middle
implementation of the slicing

00:39:06.896 --> 00:39:08.446 A:middle
subscript we started with

00:39:08.446 --> 00:39:09.066 A:middle
earlier.

00:39:09.566 --> 00:39:11.246 A:middle
Written in extension on the

00:39:11.246 --> 00:39:12.326 A:middle
collection protocol.

00:39:12.756 --> 00:39:14.476 A:middle
And it can act as a default

00:39:14.476 --> 00:39:16.336 A:middle
implementation, providing the

00:39:16.336 --> 00:39:17.896 A:middle
slicing subscript operation that

00:39:17.896 --> 00:39:18.946 A:middle
returns a slice.

00:39:19.886 --> 00:39:21.736 A:middle
We can even go one step further

00:39:21.946 --> 00:39:23.986 A:middle
and limit the applicability of

00:39:23.986 --> 00:39:25.426 A:middle
our default slicing subscript

00:39:25.426 --> 00:39:27.506 A:middle
implementation to those cases

00:39:27.606 --> 00:39:29.046 A:middle
where we picked the default

00:39:29.046 --> 00:39:30.306 A:middle
subsequence type.

00:39:30.996 --> 00:39:32.706 A:middle
So this pattern prevents the

00:39:32.706 --> 00:39:34.546 A:middle
default implementation from

00:39:34.546 --> 00:39:36.706 A:middle
showing up as an overload on

00:39:36.706 --> 00:39:38.016 A:middle
collection types that have

00:39:38.016 --> 00:39:39.486 A:middle
customized their subsequence.

00:39:39.486 --> 00:39:41.256 A:middle
Like string and range.

00:39:41.806 --> 00:39:42.776 A:middle
So this is all great for

00:39:42.776 --> 00:39:43.666 A:middle
conforming types.

00:39:43.916 --> 00:39:45.766 A:middle
They get slicing for free, or

00:39:45.766 --> 00:39:46.946 A:middle
they can customize it if they

00:39:46.946 --> 00:39:47.446 A:middle
want to.

00:39:48.606 --> 00:39:49.896 A:middle
But remember our goal here.

00:39:50.256 --> 00:39:51.526 A:middle
We're trying to write our

00:39:51.526 --> 00:39:52.926 A:middle
divide-and-conquer algorithms

00:39:52.926 --> 00:39:54.416 A:middle
against the collection protocol.

00:39:55.016 --> 00:39:57.146 A:middle
So we have to answer one really

00:39:57.146 --> 00:39:58.116 A:middle
important question.

00:39:58.706 --> 00:40:00.596 A:middle
What does subsequence do?

00:39:58.706 --> 00:40:00.596 A:middle
What does subsequence do?

00:40:01.266 --> 00:40:02.686 A:middle
All we know about subsequence

00:40:02.686 --> 00:40:04.296 A:middle
right now is that it's the

00:40:04.296 --> 00:40:05.456 A:middle
result type of the slicing

00:40:05.456 --> 00:40:06.656 A:middle
subscript operation.

00:40:07.146 --> 00:40:08.666 A:middle
But we need more to actually use

00:40:08.666 --> 00:40:08.966 A:middle
it.

00:40:09.286 --> 00:40:10.816 A:middle
So to answer this question, we

00:40:10.816 --> 00:40:11.896 A:middle
have to go back to the

00:40:11.896 --> 00:40:13.856 A:middle
algorithms that we want to write

00:40:13.856 --> 00:40:15.196 A:middle
in terms of subsequence.

00:40:15.776 --> 00:40:17.666 A:middle
Our algorithm is recursive.

00:40:18.186 --> 00:40:20.016 A:middle
It forms a slice which is now a

00:40:20.016 --> 00:40:22.186 A:middle
value of the subsequence type.

00:40:22.186 --> 00:40:24.796 A:middle
And then recursively calls sort

00:40:24.796 --> 00:40:26.856 A:middle
insertion point of on that

00:40:26.856 --> 00:40:27.386 A:middle
slice.

00:40:27.926 --> 00:40:30.236 A:middle
Now this only makes sense if the

00:40:30.236 --> 00:40:32.176 A:middle
subsequence type you get back is

00:40:32.176 --> 00:40:33.696 A:middle
itself a collection.

00:40:34.436 --> 00:40:35.716 A:middle
Now when it performs that call,

00:40:35.916 --> 00:40:37.356 A:middle
we're going to pass a value of

00:40:37.356 --> 00:40:39.076 A:middle
the collection's element type.

00:40:39.666 --> 00:40:41.226 A:middle
But the recursive call itself is

00:40:41.226 --> 00:40:43.216 A:middle
going to expect a value of this

00:40:43.216 --> 00:40:45.126 A:middle
subsequence's element type.

00:40:45.816 --> 00:40:47.546 A:middle
The only way this can possibly

00:40:47.546 --> 00:40:49.716 A:middle
make sense is if those element

00:40:49.716 --> 00:40:51.396 A:middle
types are identical.

00:40:51.396 --> 00:40:54.416 A:middle
Now the same issue comes up when

00:40:54.416 --> 00:40:56.196 A:middle
returning an index from the

00:40:56.196 --> 00:40:57.066 A:middle
recursive call.

00:40:57.666 --> 00:40:58.766 A:middle
Which is going to be computed in

00:40:58.766 --> 00:41:00.216 A:middle
terms of the subsequence.

00:40:58.766 --> 00:41:00.216 A:middle
terms of the subsequence.

00:41:00.616 --> 00:41:02.206 A:middle
But that index that's returned

00:41:02.656 --> 00:41:04.786 A:middle
also needs to be a valid index

00:41:04.936 --> 00:41:06.406 A:middle
for the current collection.

00:41:06.766 --> 00:41:08.276 A:middle
So we can capture all of these

00:41:08.276 --> 00:41:10.246 A:middle
requirements in the collection

00:41:10.246 --> 00:41:11.456 A:middle
protocol itself.

00:41:11.456 --> 00:41:13.416 A:middle
Now the first thing we want to

00:41:13.416 --> 00:41:15.376 A:middle
do is say that the subsequence

00:41:15.376 --> 00:41:17.076 A:middle
of a collection is itself a

00:41:17.076 --> 00:41:17.696 A:middle
collection.

00:41:18.046 --> 00:41:19.606 A:middle
This is a so-called recursive

00:41:19.606 --> 00:41:20.256 A:middle
constraint.

00:41:20.446 --> 00:41:21.676 A:middle
Because the associated type

00:41:21.676 --> 00:41:23.626 A:middle
conforms to its own enclosing

00:41:23.626 --> 00:41:24.156 A:middle
protocol.

00:41:24.996 --> 00:41:27.176 A:middle
We can then use associated type

00:41:27.176 --> 00:41:29.036 A:middle
where clauses to further

00:41:29.036 --> 00:41:30.736 A:middle
constrain our subsequence.

00:41:31.356 --> 00:41:33.386 A:middle
As we talked about earlier, it

00:41:33.386 --> 00:41:34.576 A:middle
has an element type.

00:41:34.576 --> 00:41:36.086 A:middle
And that element type needs to

00:41:36.086 --> 00:41:38.006 A:middle
be the same as that of the

00:41:38.006 --> 00:41:39.136 A:middle
original collection.

00:41:39.376 --> 00:41:40.606 A:middle
So we can express that here with

00:41:40.606 --> 00:41:41.656 A:middle
the same type constraint.

00:41:41.856 --> 00:41:43.416 A:middle
Subsequent element is the same

00:41:43.416 --> 00:41:44.136 A:middle
as element.

00:41:45.006 --> 00:41:46.436 A:middle
We can do exactly the same thing

00:41:46.436 --> 00:41:47.466 A:middle
for the index type.

00:41:48.266 --> 00:41:49.776 A:middle
Now, these cover all the

00:41:49.776 --> 00:41:51.696 A:middle
properties that we discovered by

00:41:51.696 --> 00:41:53.416 A:middle
looking at the implementation of

00:41:53.416 --> 00:41:54.926 A:middle
the sorted insertion point of

00:41:55.076 --> 00:41:55.776 A:middle
algorithm.

00:41:57.076 --> 00:41:58.886 A:middle
This leads us to an interesting

00:41:58.886 --> 00:41:59.466 A:middle
question.

00:41:59.776 --> 00:42:01.666 A:middle
Can you slice a subsequence?

00:41:59.776 --> 00:42:01.666 A:middle
Can you slice a subsequence?

00:42:02.416 --> 00:42:03.936 A:middle
Well, every subsequence is a

00:42:03.936 --> 00:42:05.856 A:middle
collection and every collection

00:42:05.856 --> 00:42:07.126 A:middle
has a slice operation.

00:42:07.396 --> 00:42:08.866 A:middle
So of course you can slice a

00:42:08.866 --> 00:42:09.706 A:middle
subsequence.

00:42:09.986 --> 00:42:11.796 A:middle
And the result is going to be a

00:42:11.796 --> 00:42:14.146 A:middle
subsequence of the subsequence.

00:42:15.156 --> 00:42:17.036 A:middle
Now you can do this again and

00:42:17.036 --> 00:42:18.166 A:middle
get a subsequence of a

00:42:18.166 --> 00:42:19.996 A:middle
subsequence of a subsequence.

00:42:20.566 --> 00:42:22.956 A:middle
And keep on going on and on and

00:42:22.956 --> 00:42:23.326 A:middle
on.

00:42:24.786 --> 00:42:26.466 A:middle
Now interestingly, at each point

00:42:26.556 --> 00:42:28.226 A:middle
we could have a brand-new type.

00:42:28.226 --> 00:42:29.746 A:middle
And so we have this potentially

00:42:29.776 --> 00:42:31.376 A:middle
infinite tower of types.

00:42:31.906 --> 00:42:33.156 A:middle
That's actually okay.

00:42:33.896 --> 00:42:35.106 A:middle
Each recursive step in our

00:42:35.106 --> 00:42:36.546 A:middle
generic algorithm could

00:42:36.546 --> 00:42:38.946 A:middle
conceivably create a new type.

00:42:39.666 --> 00:42:41.236 A:middle
Based on the current collection

00:42:41.236 --> 00:42:41.536 A:middle
type.

00:42:42.136 --> 00:42:43.246 A:middle
So long as the recursion

00:42:43.246 --> 00:42:44.336 A:middle
eventually terminates at

00:42:44.336 --> 00:42:46.166 A:middle
runtime, there's no problem with

00:42:46.166 --> 00:42:46.566 A:middle
this.

00:42:47.306 --> 00:42:49.116 A:middle
However, it's often the case

00:42:49.166 --> 00:42:50.676 A:middle
divide-and-conquer algorithms

00:42:50.676 --> 00:42:51.646 A:middle
can be implemented more

00:42:51.646 --> 00:42:53.376 A:middle
efficiently by making them

00:42:53.376 --> 00:42:54.396 A:middle
nonrecursive.

00:42:55.876 --> 00:42:58.146 A:middle
So here is the nonrecursive

00:42:58.146 --> 00:42:59.846 A:middle
implementation of the sort and

00:42:59.846 --> 00:43:01.496 A:middle
insertion point of algorithm.

00:42:59.846 --> 00:43:01.496 A:middle
insertion point of algorithm.

00:43:02.096 --> 00:43:03.066 A:middle
We're going to walk through it.

00:43:03.066 --> 00:43:04.356 A:middle
Because the core algorithm is

00:43:04.356 --> 00:43:05.056 A:middle
the same.

00:43:05.406 --> 00:43:07.256 A:middle
But it's expressed iteratively

00:43:07.256 --> 00:43:09.086 A:middle
with this while loop rather than

00:43:09.086 --> 00:43:09.816 A:middle
recursively.

00:43:10.536 --> 00:43:11.626 A:middle
So the first thing we're going

00:43:11.626 --> 00:43:13.366 A:middle
to do is take a slice of the

00:43:13.366 --> 00:43:14.546 A:middle
whole collection.

00:43:15.306 --> 00:43:17.446 A:middle
This slice variable is going to

00:43:17.446 --> 00:43:18.546 A:middle
represent the part of the

00:43:18.546 --> 00:43:19.846 A:middle
collection that we're looking at

00:43:19.996 --> 00:43:21.196 A:middle
in each iteration.

00:43:21.986 --> 00:43:23.316 A:middle
And now we see the familiar

00:43:23.316 --> 00:43:24.726 A:middle
divide-and-conquer pattern.

00:43:25.226 --> 00:43:26.766 A:middle
Find the middle of the slice.

00:43:27.206 --> 00:43:29.066 A:middle
And then compare the value to

00:43:29.066 --> 00:43:30.686 A:middle
insert against the middle

00:43:30.686 --> 00:43:31.836 A:middle
element in the slice.

00:43:32.616 --> 00:43:34.536 A:middle
We then narrow the search base

00:43:34.846 --> 00:43:37.046 A:middle
by slicing the slice before we

00:43:37.046 --> 00:43:37.986 A:middle
go in loop again.

00:43:39.286 --> 00:43:41.246 A:middle
However, here we have a problem.

00:43:41.556 --> 00:43:43.416 A:middle
We're performing an assignment

00:43:43.696 --> 00:43:45.146 A:middle
to the slice variable.

00:43:45.396 --> 00:43:46.566 A:middle
Which is of the subsequence

00:43:46.566 --> 00:43:46.876 A:middle
type.

00:43:47.866 --> 00:43:48.576 A:middle
On the other hand, the

00:43:48.576 --> 00:43:50.526 A:middle
right-hand side is a slice of a

00:43:50.526 --> 00:43:51.126 A:middle
slice.

00:43:51.286 --> 00:43:52.646 A:middle
And as we talked about before,

00:43:53.006 --> 00:43:54.146 A:middle
this is a subsequence of the

00:43:54.146 --> 00:43:55.856 A:middle
subsequence and could be a

00:43:55.856 --> 00:43:57.216 A:middle
completely different type.

00:43:57.636 --> 00:43:58.556 A:middle
So we're going to get a compiler

00:43:58.556 --> 00:43:59.956 A:middle
error telling us that these two

00:43:59.956 --> 00:44:01.496 A:middle
types are not necessarily the

00:43:59.956 --> 00:44:01.496 A:middle
types are not necessarily the

00:44:01.496 --> 00:44:01.956 A:middle
same.

00:44:02.566 --> 00:44:04.296 A:middle
That's really inconvenient here

00:44:04.296 --> 00:44:05.356 A:middle
because it prevents us from

00:44:05.356 --> 00:44:06.646 A:middle
writing this nonrecursive

00:44:06.646 --> 00:44:07.116 A:middle
algorithm.

00:44:07.116 --> 00:44:09.326 A:middle
And it doesn't really reflect

00:44:09.386 --> 00:44:10.996 A:middle
how specific collection types

00:44:10.996 --> 00:44:11.506 A:middle
behave.

00:44:11.506 --> 00:44:12.706 A:middle
Think about string.

00:44:13.266 --> 00:44:15.376 A:middle
If you slice a string, you get a

00:44:15.376 --> 00:44:15.996 A:middle
substring.

00:44:16.446 --> 00:44:18.276 A:middle
If you slice a substring, you

00:44:18.276 --> 00:44:20.586 A:middle
don't get a sub-substring.

00:44:21.256 --> 00:44:23.286 A:middle
You just get another instance of

00:44:23.286 --> 00:44:24.296 A:middle
the substring type.

00:44:25.206 --> 00:44:27.196 A:middle
So let's go back to how this

00:44:27.196 --> 00:44:28.646 A:middle
slice adapter works to

00:44:28.646 --> 00:44:29.816 A:middle
generalize this notion.

00:44:30.306 --> 00:44:31.426 A:middle
We have a collection.

00:44:31.426 --> 00:44:32.426 A:middle
We're going to call it Self,

00:44:32.776 --> 00:44:34.606 A:middle
that we've sliced from I to J.

00:44:35.536 --> 00:44:36.576 A:middle
Now that's going to build

00:44:36.736 --> 00:44:37.996 A:middle
something of the type slice of

00:44:37.996 --> 00:44:38.506 A:middle
Self.

00:44:38.746 --> 00:44:40.676 A:middle
Which is just a view on the

00:44:40.676 --> 00:44:42.146 A:middle
underlying Self collection.

00:44:42.686 --> 00:44:45.276 A:middle
If we then slice the slice, we

00:44:45.276 --> 00:44:47.676 A:middle
get a slice of slice of self.

00:44:47.866 --> 00:44:50.586 A:middle
Which is a view of a view on

00:44:50.586 --> 00:44:52.576 A:middle
that same underlying Self

00:44:52.576 --> 00:44:53.246 A:middle
collection.

00:44:53.906 --> 00:44:55.646 A:middle
So this is our infinite tower of

00:44:55.646 --> 00:44:56.876 A:middle
types in practice.

00:44:57.346 --> 00:44:58.956 A:middle
However, it doesn't have to be

00:44:58.956 --> 00:44:59.446 A:middle
this way.

00:45:00.076 --> 00:45:01.736 A:middle
Remember that the slice types

00:45:01.966 --> 00:45:04.246 A:middle
use the same indices as their

00:45:04.246 --> 00:45:05.576 A:middle
underlying collection.

00:45:05.976 --> 00:45:07.546 A:middle
And they also know about their

00:45:07.546 --> 00:45:08.846 A:middle
underlying basic collection.

00:45:09.356 --> 00:45:11.686 A:middle
So when we slice the slice, we

00:45:11.686 --> 00:45:13.436 A:middle
can take those new indices, I2

00:45:13.436 --> 00:45:14.286 A:middle
and J2.

00:45:14.286 --> 00:45:16.566 A:middle
Bring them back to the original

00:45:16.566 --> 00:45:18.766 A:middle
base collection and form the new

00:45:18.766 --> 00:45:19.936 A:middle
slice from there.

00:45:19.936 --> 00:45:22.486 A:middle
And what this does is it means

00:45:22.486 --> 00:45:23.946 A:middle
that when you slice a slice, you

00:45:23.946 --> 00:45:25.436 A:middle
get something back of the same

00:45:25.436 --> 00:45:26.146 A:middle
slice type.

00:45:26.316 --> 00:45:28.746 A:middle
Effectively tying off the

00:45:28.746 --> 00:45:29.466 A:middle
recursion.

00:45:29.906 --> 00:45:31.206 A:middle
This is exactly the same

00:45:31.206 --> 00:45:32.946 A:middle
behavior we saw with substring.

00:45:33.246 --> 00:45:34.846 A:middle
And it's completely reasonable

00:45:34.846 --> 00:45:36.616 A:middle
to expect that all subsequence

00:45:36.616 --> 00:45:38.706 A:middle
types behave in this way.

00:45:39.026 --> 00:45:41.246 A:middle
So let's model it as an explicit

00:45:41.246 --> 00:45:42.456 A:middle
part of the collection's

00:45:42.456 --> 00:45:43.746 A:middle
protocol requirements.

00:45:44.416 --> 00:45:46.436 A:middle
So here we're saying that the

00:45:46.436 --> 00:45:48.616 A:middle
subsequence of a subsequence is

00:45:48.616 --> 00:45:49.976 A:middle
the same type as the

00:45:49.976 --> 00:45:50.766 A:middle
subsequence.

00:45:51.086 --> 00:45:52.326 A:middle
In other words, when you slice a

00:45:52.326 --> 00:45:54.786 A:middle
slice, you get back the same

00:45:54.786 --> 00:45:55.356 A:middle
slice.

00:45:56.326 --> 00:45:57.976 A:middle
This makes our nonrecursive

00:45:57.976 --> 00:45:59.256 A:middle
divide-and-conquer algorithm

00:45:59.336 --> 00:45:59.836 A:middle
work.

00:46:00.006 --> 00:46:01.286 A:middle
And simplifies the use of the

00:46:01.286 --> 00:46:02.276 A:middle
collection protocol.

00:46:02.566 --> 00:46:04.316 A:middle
There's no more need to reason

00:46:04.356 --> 00:46:06.226 A:middle
about infinite tower of types.

00:46:06.226 --> 00:46:08.736 A:middle
Now there's one last issue here

00:46:08.736 --> 00:46:10.276 A:middle
involving subsequence.

00:46:10.616 --> 00:46:11.906 A:middle
We've said it's required to be a

00:46:11.906 --> 00:46:12.656 A:middle
collection.

00:46:12.926 --> 00:46:14.546 A:middle
But we need the subsequence type

00:46:14.546 --> 00:46:16.426 A:middle
to be a random access collection

00:46:16.616 --> 00:46:18.826 A:middle
to perform this index offset by

00:46:18.826 --> 00:46:19.676 A:middle
operation.

00:46:20.806 --> 00:46:22.556 A:middle
To describe this, we can use

00:46:22.766 --> 00:46:24.456 A:middle
protocol where clauses.

00:46:24.846 --> 00:46:26.656 A:middle
So when bidirectionalCollection

00:46:26.826 --> 00:46:28.116 A:middle
inherits from collection.

00:46:28.386 --> 00:46:30.026 A:middle
It can add a new constraint on

00:46:30.026 --> 00:46:32.056 A:middle
subsequence, requiring it to

00:46:32.056 --> 00:46:33.246 A:middle
conform to that

00:46:33.246 --> 00:46:34.346 A:middle
bidirectionalCollection

00:46:34.346 --> 00:46:34.936 A:middle
protocol.

00:46:35.346 --> 00:46:37.136 A:middle
This again is a recursive

00:46:37.136 --> 00:46:38.496 A:middle
constraint but now it's

00:46:38.496 --> 00:46:39.156 A:middle
expressed on the

00:46:39.156 --> 00:46:40.156 A:middle
bidirectionalCollection

00:46:40.156 --> 00:46:40.606 A:middle
protocol.

00:46:40.966 --> 00:46:42.806 A:middle
We can do the exact same thing

00:46:42.806 --> 00:46:44.736 A:middle
for randomAccessCollections.

00:46:44.856 --> 00:46:46.146 A:middle
Such as the subsequence of a

00:46:46.146 --> 00:46:47.876 A:middle
random access collection, itself

00:46:47.876 --> 00:46:48.716 A:middle
conforms to

00:46:48.896 --> 00:46:50.156 A:middle
randomAccessCollection.

00:46:50.706 --> 00:46:52.176 A:middle
Note how the constraints on

00:46:52.176 --> 00:46:54.566 A:middle
subsequence follow the enclosing

00:46:54.566 --> 00:46:55.196 A:middle
protocol.

00:46:55.476 --> 00:46:57.106 A:middle
This might sound a little bit

00:46:57.106 --> 00:46:57.796 A:middle
familiar.

00:46:58.586 --> 00:47:00.436 A:middle
Both recursive constraints and

00:46:58.586 --> 00:47:00.436 A:middle
Both recursive constraints and

00:47:00.436 --> 00:47:02.076 A:middle
conditional conformance tend to

00:47:02.076 --> 00:47:03.726 A:middle
track the protocol hierarchy

00:47:03.726 --> 00:47:04.526 A:middle
like this.

00:47:04.526 --> 00:47:05.646 A:middle
And the features support each

00:47:05.646 --> 00:47:05.976 A:middle
other.

00:47:06.236 --> 00:47:07.926 A:middle
This is particularly important

00:47:07.926 --> 00:47:09.126 A:middle
because we want the default

00:47:09.126 --> 00:47:10.876 A:middle
associated type for subsequence,

00:47:11.186 --> 00:47:13.256 A:middle
the slice of Self, to work at

00:47:13.256 --> 00:47:14.666 A:middle
every level of the collection

00:47:14.666 --> 00:47:15.176 A:middle
hierarchy.

00:47:15.676 --> 00:47:17.356 A:middle
Slice is always a collection.

00:47:18.116 --> 00:47:19.106 A:middle
When we go ahead and create the

00:47:19.106 --> 00:47:20.386 A:middle
bidirectionalCollection

00:47:20.386 --> 00:47:20.966 A:middle
protocol.

00:47:21.336 --> 00:47:22.676 A:middle
It now requires that the

00:47:22.676 --> 00:47:25.016 A:middle
subsequence type also conform to

00:47:25.016 --> 00:47:26.136 A:middle
bidirectionalCollection.

00:47:26.996 --> 00:47:28.476 A:middle
The slice adapter's conditional

00:47:28.476 --> 00:47:29.026 A:middle
conformance to

00:47:29.026 --> 00:47:30.746 A:middle
bidirectionalCollection which

00:47:30.806 --> 00:47:32.976 A:middle
kicks in anytime itself is known

00:47:32.976 --> 00:47:34.296 A:middle
to be a bidirectionalCollection.

00:47:34.716 --> 00:47:36.356 A:middle
Satisfies that requirement.

00:47:36.986 --> 00:47:38.696 A:middle
RandomAccessCollection works the

00:47:38.696 --> 00:47:39.296 A:middle
same way.

00:47:39.796 --> 00:47:40.956 A:middle
Subsequence gains a

00:47:40.956 --> 00:47:42.116 A:middle
randomAccessCollection

00:47:42.116 --> 00:47:42.876 A:middle
requirement.

00:47:43.236 --> 00:47:44.446 A:middle
And slices conditional

00:47:44.446 --> 00:47:45.036 A:middle
conformance to

00:47:45.036 --> 00:47:47.146 A:middle
randomAccessCollection satisfies

00:47:47.146 --> 00:47:47.866 A:middle
that requirement.

00:47:48.246 --> 00:47:49.916 A:middle
Now itself is known to be a

00:47:49.916 --> 00:47:51.186 A:middle
randomAccessCollection.

00:47:51.756 --> 00:47:53.236 A:middle
This behavior where an

00:47:53.236 --> 00:47:54.836 A:middle
associated type default works

00:47:54.946 --> 00:47:56.376 A:middle
for every protocol within the

00:47:56.376 --> 00:47:58.726 A:middle
hierarchy is a good indicator of

00:47:58.726 --> 00:47:59.906 A:middle
a cohesive design.

00:48:00.726 --> 00:48:01.976 A:middle
If you find yourself needing

00:48:02.076 --> 00:48:03.256 A:middle
different associated type

00:48:03.256 --> 00:48:04.896 A:middle
defaults at different points in

00:48:04.896 --> 00:48:05.896 A:middle
the collection hierarchy.

00:48:06.216 --> 00:48:07.146 A:middle
You might have a problem with

00:48:07.146 --> 00:48:07.686 A:middle
your design.

00:48:08.316 --> 00:48:09.396 A:middle
Recursive restraints are a

00:48:09.396 --> 00:48:10.426 A:middle
powerful tool.

00:48:10.646 --> 00:48:12.286 A:middle
Used with associated type and

00:48:12.286 --> 00:48:13.916 A:middle
protocol where clauses, they

00:48:13.916 --> 00:48:14.996 A:middle
help us write the protocol

00:48:14.996 --> 00:48:17.016 A:middle
requirements we need to express

00:48:17.016 --> 00:48:18.336 A:middle
divide-and-conquer algorithms

00:48:18.336 --> 00:48:20.116 A:middle
naturally in generic code.

00:48:20.596 --> 00:48:22.266 A:middle
And now we return to the final

00:48:22.266 --> 00:48:23.606 A:middle
portion of the WWDC talk.

00:48:25.026 --> 00:48:26.506 A:middle
So, Swift is a multi-paradigm

00:48:26.506 --> 00:48:26.906 A:middle
language.

00:48:27.036 --> 00:48:28.426 A:middle
We've been talking exclusively

00:48:28.426 --> 00:48:29.636 A:middle
about generics right now.

00:48:29.636 --> 00:48:30.876 A:middle
But of course, Swift also

00:48:30.876 --> 00:48:32.136 A:middle
supports object-oriented

00:48:32.136 --> 00:48:32.716 A:middle
programming.

00:48:33.756 --> 00:48:34.866 A:middle
And so, I'd like to take a few

00:48:34.866 --> 00:48:35.906 A:middle
moments to talk about the

00:48:35.906 --> 00:48:37.686 A:middle
interaction between those two

00:48:37.686 --> 00:48:38.276 A:middle
features.

00:48:38.376 --> 00:48:39.846 A:middle
How they work together in the

00:48:39.846 --> 00:48:40.646 A:middle
Swift language.

00:48:41.166 --> 00:48:43.696 A:middle
So with class inheritance, we

00:48:43.696 --> 00:48:44.546 A:middle
know how class inheritance

00:48:44.576 --> 00:48:44.906 A:middle
works.

00:48:45.076 --> 00:48:45.866 A:middle
It's fairly simple.

00:48:46.386 --> 00:48:47.716 A:middle
You can declare a superclass,

00:48:47.716 --> 00:48:48.386 A:middle
like Vehicle.

00:48:48.536 --> 00:48:50.156 A:middle
You can declare some subclasses,

00:48:50.156 --> 00:48:51.616 A:middle
like Taxi and PoliceCar that

00:48:51.616 --> 00:48:52.786 A:middle
both inherit from Vehicle.

00:48:53.606 --> 00:48:55.126 A:middle
And, once you do this, you have

00:48:55.126 --> 00:48:56.466 A:middle
this object-oriented hierarchy.

00:48:56.956 --> 00:48:58.506 A:middle
You have some expectations about

00:48:58.506 --> 00:48:59.636 A:middle
where you can use those

00:48:59.636 --> 00:49:00.516 A:middle
subclasses.

00:48:59.636 --> 00:49:00.516 A:middle
subclasses.

00:49:00.986 --> 00:49:02.926 A:middle
So if I were to extend Vehicle

00:49:02.926 --> 00:49:04.376 A:middle
with a new method, to go let it

00:49:04.376 --> 00:49:07.066 A:middle
drive, I fully expect that I can

00:49:07.166 --> 00:49:08.736 A:middle
call that method on one of my

00:49:08.736 --> 00:49:10.086 A:middle
subclasses, Taxi.

00:49:11.016 --> 00:49:13.746 A:middle
So, this is a fundamental aspect

00:49:13.816 --> 00:49:15.426 A:middle
of object-oriented programming.

00:49:15.756 --> 00:49:17.356 A:middle
And, Barbara Liskov, actually

00:49:17.356 --> 00:49:18.836 A:middle
described this really well in a

00:49:18.836 --> 00:49:20.106 A:middle
lecture back in the '80s.

00:49:20.846 --> 00:49:21.726 A:middle
Since then, we've referred to

00:49:21.726 --> 00:49:23.656 A:middle
this as the Liskov substitution

00:49:23.656 --> 00:49:24.156 A:middle
principle.

00:49:24.516 --> 00:49:25.856 A:middle
And, the idea's actually fairly

00:49:25.856 --> 00:49:26.286 A:middle
simple.

00:49:26.886 --> 00:49:28.986 A:middle
So, if you have someplace in

00:49:28.986 --> 00:49:30.906 A:middle
your program that refers to a

00:49:30.906 --> 00:49:34.246 A:middle
supertype, or superclass, like

00:49:34.376 --> 00:49:34.796 A:middle
Vehicle.

00:49:35.956 --> 00:49:37.316 A:middle
You should be able to take an

00:49:37.316 --> 00:49:39.056 A:middle
instance of any of its subtypes,

00:49:39.056 --> 00:49:41.896 A:middle
or subclasses, like Taxi or

00:49:41.896 --> 00:49:44.346 A:middle
PoliceCar, and use that instead.

00:49:44.806 --> 00:49:45.966 A:middle
And the program should still

00:49:45.966 --> 00:49:47.436 A:middle
continue to type check and run

00:49:47.436 --> 00:49:47.996 A:middle
correctly.

00:49:48.746 --> 00:49:50.046 A:middle
So, the substitution here is an

00:49:50.046 --> 00:49:51.226 A:middle
instance of a subclass should be

00:49:51.226 --> 00:49:52.356 A:middle
able to go in anywhere that the

00:49:52.356 --> 00:49:53.756 A:middle
superclass was expected and

00:49:53.756 --> 00:49:54.156 A:middle
tested.

00:49:54.156 --> 00:49:56.476 A:middle
And, this is a really simple

00:49:56.476 --> 00:49:56.896 A:middle
principle.

00:49:56.896 --> 00:49:58.396 A:middle
We've all internalized it, but

00:49:58.396 --> 00:50:00.026 A:middle
it's also really powerful.

00:49:58.396 --> 00:50:00.026 A:middle
it's also really powerful.

00:50:00.586 --> 00:50:01.646 A:middle
If you think about it.

00:50:02.026 --> 00:50:03.346 A:middle
And at any point in your program

00:50:03.346 --> 00:50:04.546 A:middle
think well, what happens if I

00:50:04.546 --> 00:50:05.906 A:middle
get a different subclass, maybe

00:50:05.906 --> 00:50:07.086 A:middle
a subclass I haven't thought

00:50:07.086 --> 00:50:07.616 A:middle
about here.

00:50:09.086 --> 00:50:11.786 A:middle
So, getting back to generics,

00:50:12.756 --> 00:50:14.386 A:middle
what are our expectations when

00:50:14.386 --> 00:50:15.906 A:middle
applying Liskov substitution

00:50:15.906 --> 00:50:18.326 A:middle
principle to the generic system?

00:50:18.976 --> 00:50:19.996 A:middle
Well, maybe we add a new

00:50:20.066 --> 00:50:21.126 A:middle
protocol, Drivable.

00:50:21.426 --> 00:50:24.296 A:middle
Whatever. And extend Vehicle to

00:50:24.296 --> 00:50:25.146 A:middle
make it Drivable.

00:50:25.496 --> 00:50:26.786 A:middle
What do we expect to happen?

00:50:26.786 --> 00:50:29.066 A:middle
Well, we expect that you can use

00:50:29.066 --> 00:50:30.286 A:middle
that protocol, conformance of

00:50:30.286 --> 00:50:32.436 A:middle
Vehicle to Drivable, for some of

00:50:32.436 --> 00:50:33.626 A:middle
its subclasses as well.

00:50:34.616 --> 00:50:36.866 A:middle
Say, you add a simple generic

00:50:36.866 --> 00:50:38.316 A:middle
algorithm to the Drivable

00:50:38.316 --> 00:50:39.176 A:middle
protocol to go for a

00:50:39.176 --> 00:50:39.966 A:middle
sundayDrive.

00:50:40.386 --> 00:50:41.646 A:middle
Well, now you should be able to

00:50:41.646 --> 00:50:44.476 A:middle
use that API on a PoliceCar,

00:50:44.956 --> 00:50:46.116 A:middle
even if that might not be the

00:50:46.116 --> 00:50:46.716 A:middle
best idea.

00:50:48.346 --> 00:50:50.636 A:middle
So, the protocol conformance

00:50:50.636 --> 00:50:52.096 A:middle
here is effectively being

00:50:52.306 --> 00:50:53.846 A:middle
inherited by subclasses.

00:50:54.876 --> 00:50:55.906 A:middle
And this puts a constraint on

00:50:55.906 --> 00:50:56.566 A:middle
the conformance.

00:50:56.826 --> 00:50:58.206 A:middle
The one conformance that you

00:50:58.206 --> 00:50:59.446 A:middle
write, the thing that makes

00:50:59.866 --> 00:51:00.976 A:middle
Vehicle Drivable.

00:50:59.866 --> 00:51:00.976 A:middle
Vehicle Drivable.

00:51:01.266 --> 00:51:02.956 A:middle
Has to work for all of the

00:51:02.956 --> 00:51:05.146 A:middle
subclasses of Vehicle now and

00:51:05.186 --> 00:51:06.416 A:middle
anyone that comes up with it

00:51:06.416 --> 00:51:06.766 A:middle
later.

00:51:07.886 --> 00:51:09.916 A:middle
Most of the time, that just

00:51:09.916 --> 00:51:10.276 A:middle
works.

00:51:11.256 --> 00:51:12.586 A:middle
However, there are some cases

00:51:12.586 --> 00:51:13.976 A:middle
where this actually adds new

00:51:13.976 --> 00:51:16.086 A:middle
requirements on the subclasses.

00:51:16.726 --> 00:51:19.096 A:middle
The most common one is when

00:51:19.096 --> 00:51:20.266 A:middle
dealing with initializer

00:51:20.266 --> 00:51:20.996 A:middle
requirements.

00:51:22.216 --> 00:51:22.886 A:middle
So, if you've looked at the

00:51:22.886 --> 00:51:25.316 A:middle
decodable protocol, it has one

00:51:25.316 --> 00:51:26.286 A:middle
interesting requirement.

00:51:26.286 --> 00:51:27.606 A:middle
Which is the initializer

00:51:27.606 --> 00:51:29.596 A:middle
requirement to create a new

00:51:29.596 --> 00:51:31.036 A:middle
instance of the conforming type

00:51:31.616 --> 00:51:32.606 A:middle
from a decoder.

00:51:33.236 --> 00:51:35.156 A:middle
How do we use this?

00:51:35.506 --> 00:51:36.756 A:middle
Well, let's go add a convenience

00:51:36.756 --> 00:51:37.746 A:middle
method to the decodable

00:51:37.746 --> 00:51:38.246 A:middle
protocol.

00:51:38.716 --> 00:51:40.366 A:middle
It's a static method decode that

00:51:40.516 --> 00:51:41.646 A:middle
creates a new instance from a

00:51:41.646 --> 00:51:43.086 A:middle
decoder, essentially a wrapper

00:51:43.086 --> 00:51:44.166 A:middle
for the initializer, making it

00:51:44.166 --> 00:51:44.766 A:middle
easier to use.

00:51:45.976 --> 00:51:47.606 A:middle
And, there's two interesting

00:51:47.606 --> 00:51:49.376 A:middle
things to notice about this

00:51:49.376 --> 00:51:50.516 A:middle
particular method.

00:51:50.856 --> 00:51:52.776 A:middle
First, is it returns Self with a

00:51:52.776 --> 00:51:53.456 A:middle
capital S.

00:51:53.456 --> 00:51:54.736 A:middle
Remember this is the conforming

00:51:54.766 --> 00:51:55.036 A:middle
type.

00:51:55.436 --> 00:51:56.856 A:middle
It's the same type that you're

00:51:56.856 --> 00:51:58.526 A:middle
calling the static method on.

00:52:00.136 --> 00:52:01.176 A:middle
Now, the second interesting

00:52:01.176 --> 00:52:03.006 A:middle
thing is, how are we

00:52:03.006 --> 00:52:03.746 A:middle
implementing this?

00:52:03.806 --> 00:52:04.956 A:middle
Well, we're calling to that

00:52:04.956 --> 00:52:07.206 A:middle
initializer above to create a

00:52:07.206 --> 00:52:10.146 A:middle
brand-new instance of whatever

00:52:10.146 --> 00:52:12.516 A:middle
decodable type we have, and then

00:52:12.516 --> 00:52:13.746 A:middle
return it.

00:52:14.456 --> 00:52:15.326 A:middle
Fair enough.

00:52:16.146 --> 00:52:17.256 A:middle
We can go ahead and make our

00:52:17.256 --> 00:52:18.466 A:middle
Vehicle type Decodable.

00:52:19.426 --> 00:52:21.586 A:middle
And then, what we expect, when

00:52:21.586 --> 00:52:22.776 A:middle
applying the Liskov substitution

00:52:22.776 --> 00:52:24.586 A:middle
principle, is we can use any

00:52:24.586 --> 00:52:26.426 A:middle
subclass of Vehicle.

00:52:27.146 --> 00:52:28.346 A:middle
With these new API's that we've

00:52:28.346 --> 00:52:29.176 A:middle
built through the protocol

00:52:29.176 --> 00:52:29.716 A:middle
conformance.

00:52:29.816 --> 00:52:32.246 A:middle
So, we can call Decode on a

00:52:32.246 --> 00:52:32.806 A:middle
Taxi.

00:52:33.486 --> 00:52:34.726 A:middle
And what we get back is not a

00:52:34.726 --> 00:52:35.726 A:middle
Vehicle not some arbitrary

00:52:35.726 --> 00:52:37.366 A:middle
Vehicle instance, but the Taxi,

00:52:37.456 --> 00:52:39.076 A:middle
an instance of Taxi.

00:52:40.476 --> 00:52:41.846 A:middle
This is great, but how does it

00:52:41.846 --> 00:52:42.016 A:middle
work?

00:52:43.156 --> 00:52:45.496 A:middle
So let's take a look at what

00:52:45.496 --> 00:52:46.256 A:middle
Taxi might have.

00:52:46.256 --> 00:52:47.296 A:middle
Maybe there's an hourly rate

00:52:47.356 --> 00:52:48.636 A:middle
here, and when we call

00:52:48.636 --> 00:52:51.496 A:middle
Taxi.decode from, we're going

00:52:51.496 --> 00:52:52.506 A:middle
through the protocol, going

00:52:52.506 --> 00:52:53.856 A:middle
through the protocol initializer

00:52:53.856 --> 00:52:54.366 A:middle
requirement.

00:52:55.176 --> 00:52:56.366 A:middle
There's only one initializer

00:52:56.366 --> 00:52:58.096 A:middle
this can actually call, and

00:52:58.096 --> 00:52:59.806 A:middle
that's the initializer that's

00:52:59.836 --> 00:53:02.266 A:middle
declared inside the Vehicle

00:52:59.836 --> 00:53:02.266 A:middle
declared inside the Vehicle

00:53:03.176 --> 00:53:04.956 A:middle
class, in the superclass here.

00:53:06.476 --> 00:53:08.306 A:middle
So that initializer, it knows

00:53:08.306 --> 00:53:09.746 A:middle
how to decode all of the state

00:53:09.866 --> 00:53:10.636 A:middle
of a Vehicle.

00:53:11.186 --> 00:53:12.366 A:middle
But it knows nothing about the

00:53:12.366 --> 00:53:13.446 A:middle
Taxi subclass.

00:53:14.396 --> 00:53:15.636 A:middle
And so, if we were to use this

00:53:15.636 --> 00:53:16.786 A:middle
initializer directly, we would

00:53:16.786 --> 00:53:18.126 A:middle
actually have a problem that the

00:53:18.126 --> 00:53:19.656 A:middle
hourly rate would be completely

00:53:19.656 --> 00:53:21.116 A:middle
uninitialized, which could lead

00:53:21.116 --> 00:53:22.296 A:middle
to some rather unfortunate

00:53:22.296 --> 00:53:23.556 A:middle
misunderstandings when you get

00:53:23.556 --> 00:53:24.316 A:middle
your bill at the end.

00:53:26.346 --> 00:53:27.476 A:middle
So, how do we address this?

00:53:27.626 --> 00:53:28.996 A:middle
Well, it turns out Swift doesn't

00:53:28.996 --> 00:53:30.626 A:middle
let you get into this problem.

00:53:31.416 --> 00:53:33.006 A:middle
It's going to diagnose at the

00:53:33.096 --> 00:53:34.426 A:middle
point where you try to make

00:53:34.426 --> 00:53:36.016 A:middle
Vehicle conform to the decodable

00:53:36.016 --> 00:53:37.466 A:middle
protocol that there's actually a

00:53:37.466 --> 00:53:38.776 A:middle
problem with this initializer.

00:53:38.866 --> 00:53:41.006 A:middle
It needs to be marked required.

00:53:42.836 --> 00:53:44.966 A:middle
Now, a required initializer has

00:53:44.966 --> 00:53:46.306 A:middle
to be implemented in all

00:53:46.306 --> 00:53:47.226 A:middle
subclasses.

00:53:47.516 --> 00:53:49.306 A:middle
Not just the direct subclasses,

00:53:49.556 --> 00:53:52.276 A:middle
but any subclasses of those, any

00:53:52.276 --> 00:53:53.916 A:middle
future subclasses you don't know

00:53:53.916 --> 00:53:54.426 A:middle
about now.

00:53:55.846 --> 00:53:57.196 A:middle
Now by adding that requirement,

00:53:57.516 --> 00:53:59.936 A:middle
it means that when Taxi inherits

00:53:59.996 --> 00:54:02.186 A:middle
from Vehicle, it also needs to

00:53:59.996 --> 00:54:02.186 A:middle
from Vehicle, it also needs to

00:54:02.186 --> 00:54:05.086 A:middle
introduce an initializer with

00:54:05.086 --> 00:54:05.806 A:middle
the same name.

00:54:06.616 --> 00:54:07.966 A:middle
Now, this is important because

00:54:07.966 --> 00:54:09.566 A:middle
this initializer's responsible

00:54:09.786 --> 00:54:11.556 A:middle
for decoding the hourly rate.

00:54:11.556 --> 00:54:12.696 A:middle
And then chaining up to the

00:54:12.696 --> 00:54:14.846 A:middle
superclass initializer to decode

00:54:15.046 --> 00:54:16.886 A:middle
the rest of the Vehicle type.

00:54:18.746 --> 00:54:21.006 A:middle
Okay. Now, if you're reading

00:54:21.006 --> 00:54:22.756 A:middle
those red boxes really quickly,

00:54:22.916 --> 00:54:23.776 A:middle
you may have noticed the

00:54:23.776 --> 00:54:26.006 A:middle
subphrase non-final.

00:54:26.836 --> 00:54:28.886 A:middle
So, by definition, final classes

00:54:29.056 --> 00:54:30.456 A:middle
have no subclasses.

00:54:30.456 --> 00:54:32.106 A:middle
So, it essentially exempts them

00:54:32.106 --> 00:54:33.866 A:middle
from being substituted later on.

00:54:35.046 --> 00:54:37.486 A:middle
That means that there's no sense

00:54:37.486 --> 00:54:39.056 A:middle
in having a required initializer

00:54:39.056 --> 00:54:40.136 A:middle
because you know there are no

00:54:40.136 --> 00:54:40.886 A:middle
subclasses.

00:54:41.046 --> 00:54:42.516 A:middle
And so final classes are in a

00:54:42.516 --> 00:54:43.896 A:middle
sense a little easier to work

00:54:43.896 --> 00:54:44.776 A:middle
with when dealing with things

00:54:44.776 --> 00:54:45.806 A:middle
like decodable or other

00:54:45.806 --> 00:54:47.136 A:middle
initializer requirements.

00:54:47.486 --> 00:54:48.446 A:middle
Because they're exempt from

00:54:48.446 --> 00:54:49.776 A:middle
these rules of having required

00:54:49.776 --> 00:54:50.666 A:middle
initializers.

00:54:51.406 --> 00:54:53.766 A:middle
So when you're using classes,

00:54:53.766 --> 00:54:54.826 A:middle
for reference semantics,

00:54:56.026 --> 00:54:57.936 A:middle
consider using final when you no

00:54:57.936 --> 00:54:59.316 A:middle
longer need to customize your

00:54:59.316 --> 00:55:01.236 A:middle
class through the inheritance

00:54:59.316 --> 00:55:01.236 A:middle
class through the inheritance

00:55:01.236 --> 00:55:01.856 A:middle
mechanism.

00:55:02.266 --> 00:55:03.866 A:middle
Now, this doesn't mean that you

00:55:04.246 --> 00:55:05.336 A:middle
can't customize your class

00:55:05.336 --> 00:55:05.676 A:middle
later.

00:55:05.856 --> 00:55:07.046 A:middle
You can still write an extension

00:55:07.046 --> 00:55:07.316 A:middle
on it.

00:55:07.626 --> 00:55:08.796 A:middle
The same way you can extend a

00:55:08.796 --> 00:55:09.776 A:middle
struct or an enum.

00:55:10.626 --> 00:55:11.976 A:middle
You can also add conformances to

00:55:11.976 --> 00:55:13.066 A:middle
it, to get more dynamic

00:55:13.066 --> 00:55:13.626 A:middle
dispatch.

00:55:14.996 --> 00:55:16.226 A:middle
But final can simplify the

00:55:16.226 --> 00:55:17.156 A:middle
interaction with the generic

00:55:17.156 --> 00:55:18.576 A:middle
system, and also unlock

00:55:18.576 --> 00:55:19.886 A:middle
optimization opportunities for

00:55:19.886 --> 00:55:20.836 A:middle
the compiler in runtime.

00:55:24.396 --> 00:55:25.286 A:middle
So we've talked a bit about

00:55:25.286 --> 00:55:26.196 A:middle
Swift generics today.

00:55:26.486 --> 00:55:27.966 A:middle
The idea behind Swift generics

00:55:27.966 --> 00:55:29.706 A:middle
is to provide the ability to

00:55:29.706 --> 00:55:31.606 A:middle
reuse code while maintaining

00:55:31.606 --> 00:55:32.856 A:middle
static type information.

00:55:33.176 --> 00:55:34.256 A:middle
To make it easier to write

00:55:34.296 --> 00:55:36.076 A:middle
correct programs, and compile

00:55:36.076 --> 00:55:37.006 A:middle
those down into efficient,

00:55:37.086 --> 00:55:38.976 A:middle
efficiently executing programs.

00:55:39.726 --> 00:55:41.266 A:middle
When you're designing protocols,

00:55:41.666 --> 00:55:43.826 A:middle
let this push and pull between

00:55:43.826 --> 00:55:45.036 A:middle
the generic algorithms you want

00:55:45.036 --> 00:55:46.246 A:middle
to write against a protocol.

00:55:46.246 --> 00:55:48.046 A:middle
And the conforming types that

00:55:48.046 --> 00:55:49.466 A:middle
need to implement that protocol

00:55:49.736 --> 00:55:51.576 A:middle
guide your design to meaningful

00:55:51.576 --> 00:55:52.506 A:middle
extractions.

00:55:53.636 --> 00:55:55.266 A:middle
Introduce protocol inheritance

00:55:55.516 --> 00:55:56.706 A:middle
when you need some more

00:55:56.706 --> 00:55:58.256 A:middle
specialized capabilities to

00:55:58.256 --> 00:55:59.996 A:middle
implement new generic algorithms

00:56:00.216 --> 00:56:01.986 A:middle
that are only supportable on a

00:56:01.986 --> 00:56:03.626 A:middle
subset of the conforming types.

00:56:04.726 --> 00:56:06.116 A:middle
And, conditional conformance

00:56:06.446 --> 00:56:07.716 A:middle
when you're writing generic

00:56:07.816 --> 00:56:11.046 A:middle
types, so that they can compose

00:56:11.046 --> 00:56:12.576 A:middle
nicely, especially when working

00:56:12.576 --> 00:56:13.686 A:middle
with protocol hierarchies.

00:56:14.456 --> 00:56:15.276 A:middle
And finally, when you're

00:56:15.336 --> 00:56:16.656 A:middle
reasoning about the tricky

00:56:16.656 --> 00:56:18.126 A:middle
interaction between class

00:56:18.126 --> 00:56:19.506 A:middle
inheritance and the generic

00:56:19.506 --> 00:56:19.976 A:middle
system.

00:56:20.536 --> 00:56:21.786 A:middle
Go back to the Liskov

00:56:21.786 --> 00:56:23.306 A:middle
substitution principle, and

00:56:23.306 --> 00:56:26.036 A:middle
think about what happens here if

00:56:26.036 --> 00:56:27.866 A:middle
I introduce a subclass rather

00:56:27.866 --> 00:56:29.546 A:middle
than a superclass at which I

00:56:29.546 --> 00:56:30.406 A:middle
wrote the conformance.

00:56:32.576 --> 00:56:34.626 A:middle
Well, thank you very much.

00:56:34.866 --> 00:56:35.776 A:middle
There's a couple of related

00:56:35.776 --> 00:56:37.536 A:middle
sessions on embracing algorithms

00:56:37.536 --> 00:56:38.596 A:middle
and understanding how they can

00:56:38.596 --> 00:56:39.706 A:middle
help you build better code.

00:56:39.976 --> 00:56:41.276 A:middle
As well as using Swift

00:56:41.276 --> 00:56:43.296 A:middle
collections effectively in your

00:56:43.296 --> 00:56:44.126 A:middle
everyday programming.

00:56:45.026 --> 00:56:45.536 A:middle
Thank you.

00:56:46.508 --> 00:56:48.508 A:middle
[ Applause ]
