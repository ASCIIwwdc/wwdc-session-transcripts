WEBVTT

00:00:07.016 --> 00:00:15.500 A:middle
[ Music ]

00:00:25.516 --> 00:00:28.586 A:middle
[ Applause ]

00:00:29.086 --> 00:00:31.526 A:middle
&gt;&gt; Good morning and welcome to

00:00:31.526 --> 00:00:32.836 A:middle
What's New in Swift.

00:00:33.546 --> 00:00:35.316 A:middle
This has been an exciting year

00:00:35.396 --> 00:00:36.986 A:middle
for Swift and the Swift

00:00:37.046 --> 00:00:37.596 A:middle
Community.

00:00:37.966 --> 00:00:39.076 A:middle
And over the next 40 minutes

00:00:39.136 --> 00:00:40.606 A:middle
Slava and I are thrilled to give

00:00:40.606 --> 00:00:41.746 A:middle
you an update on the major

00:00:41.746 --> 00:00:42.526 A:middle
developments there.

00:00:43.696 --> 00:00:44.956 A:middle
The session is roughly broken in

00:00:44.956 --> 00:00:45.346 A:middle
to two parts.

00:00:46.126 --> 00:00:47.296 A:middle
First I'm going to give an

00:00:47.296 --> 00:00:48.606 A:middle
update on the Swift open source

00:00:48.646 --> 00:00:51.006 A:middle
project and the community around

00:00:51.006 --> 00:00:51.126 A:middle
it.

00:00:51.606 --> 00:00:52.796 A:middle
And then we'll dive into Swift

00:00:52.796 --> 00:00:54.666 A:middle
4.2, which is available as a

00:00:54.666 --> 00:00:56.646 A:middle
preview today in the Xcode 10

00:00:58.046 --> 00:00:58.206 A:middle
beta.

00:00:58.756 --> 00:01:00.786 A:middle
Since late 2015, Swift has been

00:00:58.756 --> 00:01:00.786 A:middle
Since late 2015, Swift has been

00:01:00.786 --> 00:01:02.476 A:middle
an open source project on

00:01:02.476 --> 00:01:02.946 A:middle
GitHub.

00:01:04.546 --> 00:01:06.476 A:middle
With a vibrant community of

00:01:06.476 --> 00:01:10.226 A:middle
users who discuss, propose, and

00:01:10.226 --> 00:01:11.556 A:middle
review all changes to the

00:01:11.556 --> 00:01:13.366 A:middle
language and standard library.

00:01:15.726 --> 00:01:17.476 A:middle
In that time over 600

00:01:17.476 --> 00:01:18.776 A:middle
individuals have contributed

00:01:18.776 --> 00:01:20.926 A:middle
code to GitHub as Swift open

00:01:20.926 --> 00:01:21.706 A:middle
source project.

00:01:22.576 --> 00:01:23.686 A:middle
And together they have merged

00:01:23.686 --> 00:01:26.046 A:middle
over 18,000 pull requests.

00:01:27.316 --> 00:01:29.386 A:middle
Since Swift.org was launched

00:01:29.386 --> 00:01:31.326 A:middle
Swift has been available for

00:01:31.326 --> 00:01:33.966 A:middle
download on Swift.org both for

00:01:33.966 --> 00:01:35.136 A:middle
downloadable tool chains for

00:01:35.166 --> 00:01:36.956 A:middle
Xcode, as well as various

00:01:36.996 --> 00:01:38.216 A:middle
version of Ubuntu.

00:01:38.646 --> 00:01:39.536 A:middle
These are both development

00:01:39.536 --> 00:01:43.536 A:middle
snapshots and official releases.

00:01:45.016 --> 00:01:46.106 A:middle
Now we want Swift to be

00:01:46.106 --> 00:01:48.646 A:middle
supported on all platforms so

00:01:48.796 --> 00:01:50.396 A:middle
everyone can use it.

00:01:50.396 --> 00:01:53.086 A:middle
And a critical part of that is

00:01:53.086 --> 00:01:54.766 A:middle
extending the testing support

00:01:55.116 --> 00:01:56.586 A:middle
provided to the community.

00:01:57.046 --> 00:01:58.476 A:middle
Various folks in the open source

00:01:58.506 --> 00:02:00.336 A:middle
project are working on bringing

00:01:58.506 --> 00:02:00.336 A:middle
project are working on bringing

00:02:00.376 --> 00:02:01.506 A:middle
Swift support to other

00:02:01.506 --> 00:02:02.106 A:middle
platforms.

00:02:02.476 --> 00:02:03.786 A:middle
And we'd like to support those

00:02:03.786 --> 00:02:04.166 A:middle
efforts.

00:02:05.396 --> 00:02:07.726 A:middle
About a month ago we extended

00:02:07.726 --> 00:02:08.545 A:middle
the public continuous

00:02:08.545 --> 00:02:10.006 A:middle
integration systems to support

00:02:10.006 --> 00:02:12.066 A:middle
community hosted CI notes.

00:02:12.566 --> 00:02:13.576 A:middle
So if you are a member of the

00:02:13.576 --> 00:02:14.796 A:middle
community interested in bringing

00:02:14.796 --> 00:02:16.386 A:middle
Swift to another platform or

00:02:16.436 --> 00:02:18.046 A:middle
effort, you can now seamlessly

00:02:18.046 --> 00:02:19.266 A:middle
plug in your own hardware

00:02:19.266 --> 00:02:20.726 A:middle
support to bring testing there.

00:02:21.146 --> 00:02:22.776 A:middle
This is a nice prerequisite for

00:02:22.776 --> 00:02:23.956 A:middle
supporting Swift in other

00:02:23.956 --> 00:02:24.566 A:middle
places.

00:02:26.826 --> 00:02:28.816 A:middle
We've also invested tremendously

00:02:29.056 --> 00:02:31.056 A:middle
in the community around the

00:02:31.106 --> 00:02:32.716 A:middle
Swift open source project.

00:02:33.056 --> 00:02:34.036 A:middle
This is the community that

00:02:34.036 --> 00:02:35.476 A:middle
discusses all changes to the

00:02:35.476 --> 00:02:35.966 A:middle
language.

00:02:36.966 --> 00:02:38.936 A:middle
About six months ago we moved

00:02:38.936 --> 00:02:40.196 A:middle
from using mailing lists, which

00:02:40.196 --> 00:02:42.016 A:middle
were very high traffic to

00:02:42.146 --> 00:02:42.556 A:middle
forums.

00:02:42.986 --> 00:02:44.096 A:middle
This was at the behest of the

00:02:44.096 --> 00:02:44.746 A:middle
community.

00:02:45.366 --> 00:02:47.046 A:middle
Various people were concerned

00:02:47.046 --> 00:02:48.776 A:middle
that they wanted to be able to

00:02:48.776 --> 00:02:50.446 A:middle
engage in the project at a level

00:02:50.446 --> 00:02:52.386 A:middle
that worked well for them but

00:02:52.386 --> 00:02:54.126 A:middle
found it difficult to do so.

00:02:54.666 --> 00:02:55.586 A:middle
With the forums you can now

00:02:55.586 --> 00:02:57.656 A:middle
engage the level that works well

00:02:57.656 --> 00:02:58.066 A:middle
for you.

00:02:59.496 --> 00:03:00.926 A:middle
The forums have also worked so

00:02:59.496 --> 00:03:00.926 A:middle
The forums have also worked so

00:03:00.926 --> 00:03:02.476 A:middle
well that we wanted to extend

00:03:02.476 --> 00:03:04.586 A:middle
their utility out to supporting

00:03:04.586 --> 00:03:06.746 A:middle
the general open source project.

00:03:07.476 --> 00:03:10.196 A:middle
If you maintain a Swift open

00:03:10.196 --> 00:03:11.696 A:middle
source project such as a popular

00:03:11.696 --> 00:03:13.526 A:middle
Swift library, you can now use

00:03:13.526 --> 00:03:14.906 A:middle
the forums for use to discuss

00:03:15.186 --> 00:03:16.436 A:middle
things on that project such as

00:03:16.436 --> 00:03:18.506 A:middle
discussions with your users or

00:03:18.506 --> 00:03:19.286 A:middle
development.

00:03:20.986 --> 00:03:22.376 A:middle
We've also looked at ways to

00:03:22.376 --> 00:03:24.386 A:middle
continue to extend Swift.org to

00:03:24.426 --> 00:03:26.016 A:middle
be of general use the community.

00:03:26.566 --> 00:03:27.876 A:middle
This week we've moved to hosting

00:03:27.876 --> 00:03:28.936 A:middle
the Swift programming language

00:03:29.006 --> 00:03:30.486 A:middle
book to swift.org.

00:03:31.486 --> 00:03:33.706 A:middle
Located at docs.swift.org, this

00:03:33.706 --> 00:03:35.146 A:middle
will be a natural place for us

00:03:35.186 --> 00:03:37.716 A:middle
to extend more documentation for

00:03:37.716 --> 00:03:39.026 A:middle
use by the community.

00:03:39.606 --> 00:03:42.876 A:middle
Now the really exciting thing

00:03:42.876 --> 00:03:45.006 A:middle
about Swift is that people are

00:03:45.006 --> 00:03:46.776 A:middle
really thrilled about using it.

00:03:46.776 --> 00:03:48.406 A:middle
And they're talking about it in

00:03:48.406 --> 00:03:49.376 A:middle
a variety of places.

00:03:49.606 --> 00:03:51.246 A:middle
At Podcasts, Meetups,

00:03:51.696 --> 00:03:52.556 A:middle
conferences.

00:03:53.126 --> 00:03:54.916 A:middle
And we, Apple, thought it was

00:03:54.916 --> 00:03:56.726 A:middle
very important for us to engage

00:03:56.996 --> 00:03:58.166 A:middle
in those places because that's

00:03:58.196 --> 00:03:59.496 A:middle
where a lot of the discussion is

00:03:59.496 --> 00:03:59.966 A:middle
happening.

00:04:00.736 --> 00:04:02.696 A:middle
Over the last year we have made

00:04:02.696 --> 00:04:04.116 A:middle
a very conscious effort to

00:04:04.116 --> 00:04:06.046 A:middle
engage in those conferences and

00:04:06.046 --> 00:04:09.016 A:middle
present technical presentations

00:04:09.406 --> 00:04:10.826 A:middle
on things that we're doing with

00:04:10.826 --> 00:04:13.026 A:middle
Swift, or how does Swift work,

00:04:13.026 --> 00:04:14.386 A:middle
or how you can get involved in

00:04:14.386 --> 00:04:15.376 A:middle
the open source project.

00:04:16.375 --> 00:04:17.576 A:middle
And this is something we're very

00:04:17.576 --> 00:04:19.156 A:middle
committed to continuing going

00:04:19.245 --> 00:04:19.616 A:middle
forward.

00:04:21.466 --> 00:04:22.466 A:middle
One of these efforts I'd like to

00:04:22.466 --> 00:04:25.096 A:middle
talk about is a event co-located

00:04:25.166 --> 00:04:26.896 A:middle
next to WWDC on Friday and that

00:04:26.896 --> 00:04:27.266 A:middle
is the try!

00:04:27.336 --> 00:04:29.226 A:middle
Swift San Jose Conference.

00:04:29.866 --> 00:04:31.596 A:middle
There there will be a workshop

00:04:31.836 --> 00:04:33.256 A:middle
with members from the community

00:04:33.256 --> 00:04:34.806 A:middle
to help on board people who are

00:04:34.806 --> 00:04:36.326 A:middle
interested in contributing to

00:04:36.326 --> 00:04:38.196 A:middle
the Swift open source project.

00:04:38.626 --> 00:04:39.916 A:middle
And there will be members from

00:04:39.916 --> 00:04:41.836 A:middle
Apple's compiler team there to

00:04:42.046 --> 00:04:43.646 A:middle
also facilitate those

00:04:43.696 --> 00:04:44.416 A:middle
conversations.

00:04:45.146 --> 00:04:47.896 A:middle
So that's all about the

00:04:47.896 --> 00:04:48.446 A:middle
community update.

00:04:49.066 --> 00:04:50.166 A:middle
Let's talk about Swift 4.2.

00:04:50.166 --> 00:04:52.086 A:middle
I think the natural place to

00:04:52.126 --> 00:04:53.346 A:middle
start is well, what is this

00:04:53.346 --> 00:04:54.536 A:middle
release about and how does it

00:04:54.536 --> 00:04:55.466 A:middle
fit into the bigger picture?

00:04:58.276 --> 00:04:59.786 A:middle
Swift updates occur -- some

00:04:59.856 --> 00:05:01.906 A:middle
major updates occur about twice

00:04:59.856 --> 00:05:01.906 A:middle
major updates occur about twice

00:05:01.906 --> 00:05:02.386 A:middle
a year.

00:05:02.996 --> 00:05:04.926 A:middle
And Swift 4.2 is a major update

00:05:04.956 --> 00:05:07.026 A:middle
over Swift 4.1 and 4.0.

00:05:08.246 --> 00:05:10.116 A:middle
Now there are in broad strokes

00:05:10.216 --> 00:05:11.736 A:middle
two themes to this release.

00:05:12.316 --> 00:05:14.686 A:middle
One is a huge focus on developer

00:05:14.686 --> 00:05:15.386 A:middle
productivity.

00:05:15.826 --> 00:05:16.946 A:middle
You can see this in a variety of

00:05:16.946 --> 00:05:17.136 A:middle
ways.

00:05:17.686 --> 00:05:19.186 A:middle
The faster builds for projects.

00:05:19.546 --> 00:05:20.826 A:middle
But also just through and

00:05:20.826 --> 00:05:22.876 A:middle
through massive improvement to

00:05:22.876 --> 00:05:24.676 A:middle
the core tooling experience from

00:05:24.676 --> 00:05:26.106 A:middle
the Debugger through the Editor.

00:05:26.186 --> 00:05:28.306 A:middle
And the community has also

00:05:28.306 --> 00:05:30.216 A:middle
focused on language improvements

00:05:30.616 --> 00:05:32.206 A:middle
that aim to improve common

00:05:32.206 --> 00:05:33.796 A:middle
developer workflows, remove

00:05:33.796 --> 00:05:34.386 A:middle
boilerplate.

00:05:34.926 --> 00:05:36.936 A:middle
And Apple has continued invested

00:05:36.936 --> 00:05:39.406 A:middle
improvements to the SDK so that

00:05:39.406 --> 00:05:41.646 A:middle
the Objective-C APIs better

00:05:41.686 --> 00:05:44.226 A:middle
reflect into Swift making better

00:05:44.386 --> 00:05:45.456 A:middle
use of the language and

00:05:45.456 --> 00:05:47.006 A:middle
improving your use of our APIs.

00:05:48.266 --> 00:05:49.626 A:middle
And the other side there's been

00:05:49.626 --> 00:05:51.766 A:middle
a massive effort on under the

00:05:51.846 --> 00:05:53.736 A:middle
hood improvements and changes to

00:05:53.736 --> 00:05:55.636 A:middle
the runtime towards this binary

00:05:55.636 --> 00:05:58.156 A:middle
compatibility goal, which

00:05:58.156 --> 00:06:01.946 A:middle
culminates in Swift 5, which

00:05:58.156 --> 00:06:01.946 A:middle
culminates in Swift 5, which

00:06:01.946 --> 00:06:04.916 A:middle
will be released in early 2019.

00:06:05.926 --> 00:06:07.486 A:middle
So what is binary compatibility?

00:06:08.406 --> 00:06:09.806 A:middle
Binary compatibility means that

00:06:09.806 --> 00:06:11.536 A:middle
you can build your Swift code

00:06:11.576 --> 00:06:12.996 A:middle
with the Swift 5 compiler and

00:06:12.996 --> 00:06:13.286 A:middle
layer.

00:06:13.286 --> 00:06:15.036 A:middle
And at the binary level it will

00:06:15.036 --> 00:06:16.626 A:middle
be able to interoperate with

00:06:16.696 --> 00:06:17.866 A:middle
other code built with that

00:06:17.866 --> 00:06:19.686 A:middle
compiler or any other compiler

00:06:19.686 --> 00:06:20.016 A:middle
layer.

00:06:20.496 --> 00:06:22.266 A:middle
This is a very important

00:06:22.266 --> 00:06:23.966 A:middle
milestone for the maturity of

00:06:23.966 --> 00:06:24.506 A:middle
the language.

00:06:25.146 --> 00:06:26.606 A:middle
And what this will enable is

00:06:26.606 --> 00:06:28.436 A:middle
Apple to shift the Swift runtime

00:06:28.586 --> 00:06:30.746 A:middle
in the operating system, which

00:06:30.746 --> 00:06:32.156 A:middle
means apps can directly use it,

00:06:32.576 --> 00:06:33.496 A:middle
meaning that they no longer need

00:06:33.496 --> 00:06:34.666 A:middle
it included in the application

00:06:34.666 --> 00:06:34.976 A:middle
bundle.

00:06:35.346 --> 00:06:37.446 A:middle
So this is a code size win but

00:06:37.446 --> 00:06:38.966 A:middle
it's also important that it

00:06:38.966 --> 00:06:40.146 A:middle
impacts things like startup

00:06:40.146 --> 00:06:42.286 A:middle
time, memory usage, it's an

00:06:42.286 --> 00:06:43.646 A:middle
overall huge win for the

00:06:43.646 --> 00:06:44.056 A:middle
community.

00:06:44.056 --> 00:06:46.876 A:middle
If you're -- we've been very

00:06:46.876 --> 00:06:48.046 A:middle
transparent on the progress

00:06:48.286 --> 00:06:50.196 A:middle
towards ABI stability or binary

00:06:50.196 --> 00:06:50.906 A:middle
compatibility.

00:06:51.286 --> 00:06:52.826 A:middle
You can follow along on the ABI

00:06:52.826 --> 00:06:54.366 A:middle
stability dashboard on

00:06:54.406 --> 00:06:55.806 A:middle
Swift.org.

00:06:57.696 --> 00:07:00.186 A:middle
Today's focus is on Swift 4.2,

00:06:57.696 --> 00:07:00.186 A:middle
Today's focus is on Swift 4.2,

00:07:00.186 --> 00:07:01.596 A:middle
which is an important waypoint

00:07:01.916 --> 00:07:02.696 A:middle
toward Swift 5.

00:07:03.426 --> 00:07:05.446 A:middle
Let's talk about source

00:07:05.446 --> 00:07:06.166 A:middle
compatibility.

00:07:07.526 --> 00:07:10.106 A:middle
So just like in Xcode 9, Xcode

00:07:10.166 --> 00:07:12.026 A:middle
10 shifts with one Swift

00:07:12.226 --> 00:07:12.696 A:middle
compiler.

00:07:13.686 --> 00:07:15.086 A:middle
So if you're using Xcode 10, you

00:07:15.086 --> 00:07:16.256 A:middle
are using Swift 4.2.

00:07:17.226 --> 00:07:19.716 A:middle
However, just like in Xcode 9,

00:07:20.276 --> 00:07:21.746 A:middle
the compiler also supports

00:07:22.236 --> 00:07:23.896 A:middle
multiple language compatibility

00:07:23.896 --> 00:07:24.366 A:middle
modes.

00:07:25.256 --> 00:07:27.026 A:middle
Now in all the modes you can use

00:07:27.116 --> 00:07:27.906 A:middle
all the new APIs.

00:07:28.676 --> 00:07:29.926 A:middle
You can use all the new language

00:07:29.926 --> 00:07:30.476 A:middle
features.

00:07:30.856 --> 00:07:31.676 A:middle
What these gate are

00:07:31.676 --> 00:07:33.476 A:middle
source-impacting changes.

00:07:34.036 --> 00:07:37.286 A:middle
The first two are ones that

00:07:37.286 --> 00:07:39.026 A:middle
existed previously in Xcode 9.

00:07:39.426 --> 00:07:40.676 A:middle
They're there to provide an out

00:07:40.676 --> 00:07:41.776 A:middle
of the box experience that you

00:07:41.776 --> 00:07:43.046 A:middle
can build your Swift 3 and Swift

00:07:43.046 --> 00:07:44.926 A:middle
4 code without modifications.

00:07:45.656 --> 00:07:47.206 A:middle
The Swift 4.2 mode is almost

00:07:47.206 --> 00:07:49.586 A:middle
identical to the 4 mode except

00:07:49.586 --> 00:07:51.216 A:middle
it gates those SDK improvements

00:07:51.476 --> 00:07:52.266 A:middle
that are talked about.

00:07:53.426 --> 00:07:54.346 A:middle
That's it.

00:07:54.976 --> 00:07:57.026 A:middle
Just some previous versions of

00:07:57.086 --> 00:07:58.526 A:middle
Xcode, there's Migrator Support

00:07:58.526 --> 00:07:59.436 A:middle
that you can find in the edit

00:07:59.436 --> 00:08:01.116 A:middle
menu to mechanize most of your

00:07:59.436 --> 00:08:01.116 A:middle
menu to mechanize most of your

00:08:01.116 --> 00:08:01.556 A:middle
changes.

00:08:02.806 --> 00:08:03.876 A:middle
I want to give an important

00:08:03.876 --> 00:08:06.166 A:middle
disclaimer about the Swift 4.2

00:08:06.306 --> 00:08:07.146 A:middle
SDK changes.

00:08:07.496 --> 00:08:09.436 A:middle
Later Xcode 10 betas will likely

00:08:09.436 --> 00:08:11.036 A:middle
have further SDK improvements.

00:08:11.416 --> 00:08:13.206 A:middle
This is to provide opportunities

00:08:13.206 --> 00:08:14.916 A:middle
to incorporate you feedback from

00:08:14.916 --> 00:08:16.976 A:middle
the betas of how these APIs

00:08:16.976 --> 00:08:18.676 A:middle
should be improved and how they

00:08:18.676 --> 00:08:19.626 A:middle
reflect into Swift.

00:08:20.236 --> 00:08:22.246 A:middle
This means if you migrate to 4.2

00:08:22.416 --> 00:08:23.926 A:middle
early, you should expect there

00:08:23.926 --> 00:08:24.806 A:middle
are going to be some changes

00:08:24.806 --> 00:08:25.096 A:middle
later.

00:08:25.576 --> 00:08:27.166 A:middle
Or you can hold off and migrate

00:08:27.196 --> 00:08:27.446 A:middle
later.

00:08:27.836 --> 00:08:28.816 A:middle
It's completely up to you.

00:08:30.616 --> 00:08:32.176 A:middle
Now with Swift 4.2 we think we

00:08:32.176 --> 00:08:34.126 A:middle
are rapidly converging on what

00:08:34.166 --> 00:08:35.476 A:middle
Swift code is going to look like

00:08:35.876 --> 00:08:36.635 A:middle
going forward.

00:08:36.666 --> 00:08:39.155 A:middle
This is an important phase in

00:08:39.155 --> 00:08:40.716 A:middle
the maturation of the language.

00:08:41.506 --> 00:08:43.046 A:middle
And thus we really think it's

00:08:43.046 --> 00:08:44.596 A:middle
important for everyone to move

00:08:44.596 --> 00:08:47.486 A:middle
off of Swift 3 and embrace using

00:08:47.486 --> 00:08:48.086 A:middle
Swift 4.2.

00:08:48.086 --> 00:08:49.216 A:middle
There are important code size

00:08:49.216 --> 00:08:50.456 A:middle
improvements there and just

00:08:50.456 --> 00:08:51.396 A:middle
overall improvements to the

00:08:51.396 --> 00:08:52.006 A:middle
language.

00:08:52.836 --> 00:08:54.106 A:middle
And this is Xcode 10 is going to

00:08:54.156 --> 00:08:55.636 A:middle
be the last release to support

00:08:55.636 --> 00:08:58.916 A:middle
that Swift 3 compatibility mode.

00:08:59.586 --> 00:09:00.506 A:middle
So let's talk about some

00:08:59.586 --> 00:09:00.506 A:middle
So let's talk about some

00:09:00.506 --> 00:09:01.446 A:middle
improvements to the tooling.

00:09:02.536 --> 00:09:04.076 A:middle
In the State of the Union we

00:09:04.076 --> 00:09:05.006 A:middle
mentioned that there are some

00:09:05.106 --> 00:09:06.206 A:middle
significant improvements to

00:09:06.206 --> 00:09:07.416 A:middle
build improvement for Swift

00:09:07.416 --> 00:09:09.366 A:middle
projects over Xcode 9.

00:09:10.176 --> 00:09:12.176 A:middle
And so these numbers are run on

00:09:12.176 --> 00:09:13.516 A:middle
a 4-Core MacBook Pro i7.

00:09:13.516 --> 00:09:16.946 A:middle
Let's look a little bit closer

00:09:16.946 --> 00:09:17.416 A:middle
at one of them.

00:09:18.896 --> 00:09:20.456 A:middle
This project is a mix and match

00:09:20.456 --> 00:09:21.776 A:middle
of Objective-C in Swift.

00:09:22.066 --> 00:09:23.406 A:middle
It started out as an Objective-C

00:09:23.406 --> 00:09:24.666 A:middle
project and started

00:09:24.666 --> 00:09:25.526 A:middle
incorporating Swift.

00:09:26.216 --> 00:09:27.786 A:middle
This is a very common scenario.

00:09:28.756 --> 00:09:29.576 A:middle
Now what this Build time

00:09:29.576 --> 00:09:32.156 A:middle
improvement doesn't really

00:09:32.156 --> 00:09:33.826 A:middle
underscore is how much faster

00:09:33.876 --> 00:09:34.736 A:middle
building this Swift Code

00:09:34.736 --> 00:09:35.536 A:middle
actually became.

00:09:36.356 --> 00:09:37.526 A:middle
So if we just focus on how much

00:09:37.526 --> 00:09:39.826 A:middle
faster the Swift code built, it

00:09:39.826 --> 00:09:41.146 A:middle
actually builds three times

00:09:41.226 --> 00:09:42.896 A:middle
faster than it did before.

00:09:43.386 --> 00:09:44.776 A:middle
And so that's why the project

00:09:45.046 --> 00:09:47.086 A:middle
has that more modest 1.6x

00:09:47.186 --> 00:09:47.536 A:middle
speedup.

00:09:49.656 --> 00:09:51.096 A:middle
And what you will see is that

00:09:51.096 --> 00:09:52.216 A:middle
the overall build improvements

00:09:52.216 --> 00:09:53.706 A:middle
will depend on the nature of

00:09:53.706 --> 00:09:54.766 A:middle
your project, how much Swift

00:09:54.766 --> 00:09:56.816 A:middle
code it's using, the number of

00:09:56.816 --> 00:09:58.606 A:middle
cores on your machine, but we've

00:09:58.766 --> 00:10:00.146 A:middle
in practice have seen from many

00:09:58.766 --> 00:10:00.146 A:middle
in practice have seen from many

00:10:00.146 --> 00:10:01.476 A:middle
projects it's a 2x speedup.

00:10:02.416 --> 00:10:04.366 A:middle
And the win comes from observing

00:10:04.366 --> 00:10:06.326 A:middle
that because within a Swift

00:10:06.326 --> 00:10:08.286 A:middle
target you have cross-file

00:10:08.286 --> 00:10:09.846 A:middle
visibility, right, that's one of

00:10:09.846 --> 00:10:10.896 A:middle
the great features of Swift

00:10:10.896 --> 00:10:11.626 A:middle
where you don't need header

00:10:11.696 --> 00:10:11.946 A:middle
files.

00:10:12.606 --> 00:10:13.976 A:middle
There was a lot of redundant

00:10:13.976 --> 00:10:15.586 A:middle
work being done by the compiler.

00:10:15.586 --> 00:10:17.056 A:middle
And what we've done is we've

00:10:17.056 --> 00:10:18.346 A:middle
retooled the compilation

00:10:18.346 --> 00:10:20.136 A:middle
pipeline to reduce a lot of this

00:10:20.136 --> 00:10:21.626 A:middle
redundant work and make better

00:10:21.626 --> 00:10:22.516 A:middle
use of the cores on your

00:10:22.516 --> 00:10:22.936 A:middle
machine.

00:10:23.096 --> 00:10:23.996 A:middle
And that's where these speedups

00:10:24.076 --> 00:10:24.466 A:middle
come from.

00:10:25.206 --> 00:10:26.116 A:middle
If you're interested in more

00:10:26.116 --> 00:10:27.616 A:middle
details there's these two great

00:10:27.616 --> 00:10:28.886 A:middle
talks later this week that dive

00:10:28.886 --> 00:10:30.346 A:middle
into how the build process works

00:10:30.396 --> 00:10:31.846 A:middle
under the book including more

00:10:31.846 --> 00:10:32.906 A:middle
details about where this

00:10:32.946 --> 00:10:34.146 A:middle
performance win comes from.

00:10:36.356 --> 00:10:37.906 A:middle
Now this big win comes from

00:10:38.606 --> 00:10:40.526 A:middle
debug builds.

00:10:41.566 --> 00:10:44.776 A:middle
I want to focus on how this is

00:10:44.776 --> 00:10:47.336 A:middle
surfacing in the Xcode build

00:10:47.396 --> 00:10:47.846 A:middle
settings.

00:10:48.746 --> 00:10:49.926 A:middle
Recently we separated out

00:10:49.926 --> 00:10:51.386 A:middle
compilation mode from

00:10:51.386 --> 00:10:52.506 A:middle
optimization level.

00:10:53.206 --> 00:10:55.286 A:middle
Compilation mode is how your

00:10:55.286 --> 00:10:56.726 A:middle
project builds.

00:10:57.256 --> 00:10:58.566 A:middle
So for release builds the

00:10:58.566 --> 00:10:59.566 A:middle
default is whole module

00:10:59.566 --> 00:11:01.446 A:middle
compilation that means all the

00:10:59.566 --> 00:11:01.446 A:middle
compilation that means all the

00:11:01.446 --> 00:11:02.906 A:middle
files within your target are

00:11:02.906 --> 00:11:04.226 A:middle
always built together.

00:11:04.386 --> 00:11:05.836 A:middle
This is to enable maximum

00:11:05.836 --> 00:11:07.326 A:middle
opportunities for optimization.

00:11:07.326 --> 00:11:08.676 A:middle
It's not the amount of

00:11:08.676 --> 00:11:09.756 A:middle
optimization done but the

00:11:09.756 --> 00:11:11.366 A:middle
opportunities for optimization.

00:11:12.166 --> 00:11:14.146 A:middle
And for Debug builds the default

00:11:14.146 --> 00:11:15.176 A:middle
is incremental.

00:11:15.386 --> 00:11:16.486 A:middle
That means not all the files are

00:11:16.486 --> 00:11:18.256 A:middle
all built, re-built always all

00:11:18.256 --> 00:11:18.626 A:middle
together.

00:11:19.616 --> 00:11:20.506 A:middle
So this is a tradeoff in

00:11:20.506 --> 00:11:22.536 A:middle
performance for build times.

00:11:23.516 --> 00:11:24.826 A:middle
Optimization level for Debug

00:11:24.826 --> 00:11:25.746 A:middle
builds continues to be no

00:11:25.746 --> 00:11:26.966 A:middle
optimization by default.

00:11:26.966 --> 00:11:27.946 A:middle
This is for faster builds and

00:11:27.946 --> 00:11:29.806 A:middle
better Debug information and the

00:11:29.806 --> 00:11:31.816 A:middle
release builds are optimized for

00:11:31.816 --> 00:11:32.096 A:middle
speed.

00:11:32.636 --> 00:11:33.186 A:middle
We'll get back to the

00:11:33.186 --> 00:11:35.076 A:middle
optimization level in a few

00:11:35.076 --> 00:11:35.306 A:middle
minutes.

00:11:38.436 --> 00:11:41.886 A:middle
All right so this separation of

00:11:41.886 --> 00:11:42.696 A:middle
compilation mode and

00:11:42.696 --> 00:11:45.296 A:middle
optimization level nicely

00:11:45.356 --> 00:11:46.516 A:middle
highlights and interesting

00:11:46.516 --> 00:11:48.096 A:middle
stopgap measure that various

00:11:48.096 --> 00:11:50.176 A:middle
folds discovered that when they

00:11:50.176 --> 00:11:51.126 A:middle
combined whole module

00:11:51.126 --> 00:11:53.946 A:middle
compilation with no optimization

00:11:53.946 --> 00:11:54.876 A:middle
that they sometimes would get

00:11:55.036 --> 00:11:56.026 A:middle
faster Debug builds.

00:11:56.966 --> 00:11:58.786 A:middle
And this is because that

00:11:58.786 --> 00:12:00.756 A:middle
combination reduces a lot of

00:11:58.786 --> 00:12:00.756 A:middle
combination reduces a lot of

00:12:00.756 --> 00:12:02.246 A:middle
that redundant work that I

00:12:02.246 --> 00:12:04.136 A:middle
talked about before that we have

00:12:04.136 --> 00:12:05.986 A:middle
no made great efforts to

00:12:06.126 --> 00:12:08.336 A:middle
eliminate or significantly

00:12:08.336 --> 00:12:08.666 A:middle
reduce.

00:12:10.036 --> 00:12:10.926 A:middle
The problem with this

00:12:10.926 --> 00:12:12.496 A:middle
combination is, is it impedes

00:12:12.496 --> 00:12:13.296 A:middle
incremental builds.

00:12:13.506 --> 00:12:14.716 A:middle
So anytime you touch a file

00:12:14.716 --> 00:12:16.206 A:middle
within a target the whole target

00:12:16.206 --> 00:12:16.806 A:middle
gets rebuilt.

00:12:17.496 --> 00:12:18.836 A:middle
Now with the improvements in

00:12:18.836 --> 00:12:20.406 A:middle
Xcode 10 to Debug builds, we

00:12:20.406 --> 00:12:21.936 A:middle
feel you no longer need to use

00:12:21.986 --> 00:12:24.416 A:middle
the stopgap measure and we have

00:12:24.416 --> 00:12:25.626 A:middle
observed that the default

00:12:25.626 --> 00:12:27.316 A:middle
incremental builds are at least

00:12:27.316 --> 00:12:29.036 A:middle
as good as this combination or

00:12:29.036 --> 00:12:29.356 A:middle
better.

00:12:29.356 --> 00:12:30.406 A:middle
Especially since they support

00:12:30.406 --> 00:12:30.976 A:middle
incremental builds.

00:12:34.696 --> 00:12:35.826 A:middle
Let's talk about some important

00:12:35.826 --> 00:12:37.006 A:middle
under the hood runtime

00:12:37.006 --> 00:12:38.256 A:middle
optimizations and this is all

00:12:38.256 --> 00:12:39.356 A:middle
part of that march towards

00:12:39.406 --> 00:12:40.586 A:middle
binary compatibility.

00:12:43.436 --> 00:12:45.126 A:middle
Swift uses automatic memory

00:12:45.126 --> 00:12:47.726 A:middle
management and it uses reference

00:12:47.726 --> 00:12:49.236 A:middle
counting just like Objective-C

00:12:49.386 --> 00:12:51.026 A:middle
for managing object instances.

00:12:51.916 --> 00:12:53.526 A:middle
On this slide I've illustrated

00:12:53.526 --> 00:12:54.786 A:middle
in comments where the compiler

00:12:54.786 --> 00:12:56.426 A:middle
inserts, retains, and releases.

00:12:57.516 --> 00:12:58.786 A:middle
This is how it behaved in Swift

00:12:58.786 --> 00:13:02.116 A:middle
4.1.

00:12:58.786 --> 00:13:02.116 A:middle
4.1.

00:13:02.316 --> 00:13:03.276 A:middle
When an object is created

00:13:03.276 --> 00:13:04.716 A:middle
there's a +1 reference account

00:13:04.716 --> 00:13:05.896 A:middle
associated with it.

00:13:05.896 --> 00:13:08.176 A:middle
What the convention was if the

00:13:08.176 --> 00:13:09.596 A:middle
object is passed off as an

00:13:09.596 --> 00:13:10.806 A:middle
argument to another function,

00:13:11.286 --> 00:13:12.406 A:middle
it's the obligation of that

00:13:12.466 --> 00:13:14.046 A:middle
function call to release the

00:13:14.046 --> 00:13:14.526 A:middle
object.

00:13:14.986 --> 00:13:16.626 A:middle
So it's basically you're passing

00:13:16.626 --> 00:13:18.036 A:middle
off the responsibility to the

00:13:18.036 --> 00:13:19.406 A:middle
call to release it.

00:13:20.376 --> 00:13:21.556 A:middle
This provided some performance

00:13:21.556 --> 00:13:22.926 A:middle
opportunities to shrink the

00:13:22.926 --> 00:13:25.156 A:middle
lifetime of some objects to like

00:13:25.156 --> 00:13:26.936 A:middle
their smallest range of use.

00:13:27.806 --> 00:13:29.976 A:middle
However, code often looks more

00:13:30.056 --> 00:13:32.076 A:middle
like this where you're passing

00:13:32.076 --> 00:13:33.886 A:middle
the object off several times to

00:13:34.276 --> 00:13:35.236 A:middle
different APIs.

00:13:35.906 --> 00:13:37.096 A:middle
And because you have this

00:13:37.136 --> 00:13:38.856 A:middle
calling convention, you still

00:13:38.856 --> 00:13:40.226 A:middle
have this dance where the

00:13:40.226 --> 00:13:41.316 A:middle
initial reference count is

00:13:41.366 --> 00:13:42.466 A:middle
balanced out with the final

00:13:42.516 --> 00:13:43.066 A:middle
call.

00:13:43.466 --> 00:13:44.666 A:middle
But the intermediate calls are

00:13:44.666 --> 00:13:45.776 A:middle
expected to have these extra

00:13:45.776 --> 00:13:48.246 A:middle
retains and releases because

00:13:48.246 --> 00:13:49.956 A:middle
that's what a convention is.

00:13:50.876 --> 00:13:52.406 A:middle
This is really wasteful because

00:13:52.626 --> 00:13:53.886 A:middle
the object is really just going

00:13:53.886 --> 00:13:55.156 A:middle
to be alive during the entire

00:13:55.156 --> 00:13:57.106 A:middle
duration of this function.

00:13:57.816 --> 00:13:59.876 A:middle
So in Swift 4.2 we changed the

00:13:59.876 --> 00:14:01.396 A:middle
calling convention so that it

00:13:59.876 --> 00:14:01.396 A:middle
calling convention so that it

00:14:01.396 --> 00:14:02.606 A:middle
was no longer the callee's

00:14:02.606 --> 00:14:04.296 A:middle
obligation to release the

00:14:04.296 --> 00:14:04.806 A:middle
object.

00:14:05.206 --> 00:14:06.526 A:middle
This means all these retains and

00:14:06.526 --> 00:14:10.366 A:middle
releases go away, which is a

00:14:10.606 --> 00:14:12.066 A:middle
significant reduction in

00:14:12.066 --> 00:14:13.016 A:middle
retained release traffic.

00:14:13.936 --> 00:14:15.076 A:middle
This has two implications.

00:14:15.546 --> 00:14:16.916 A:middle
It's both a code size win

00:14:16.986 --> 00:14:19.026 A:middle
because those calls are gone and

00:14:19.026 --> 00:14:20.336 A:middle
it has a runtime improvement.

00:14:21.776 --> 00:14:24.746 A:middle
Another important optimization

00:14:24.746 --> 00:14:25.746 A:middle
we did was to string.

00:14:26.186 --> 00:14:28.506 A:middle
And Swift 4.2 string is now 16

00:14:28.506 --> 00:14:29.746 A:middle
bytes big where it as previously

00:14:29.746 --> 00:14:30.316 A:middle
24.

00:14:30.756 --> 00:14:31.976 A:middle
We feel this is a good tradeoff

00:14:31.976 --> 00:14:33.266 A:middle
between memory usage and

00:14:33.266 --> 00:14:33.936 A:middle
performance.

00:14:35.346 --> 00:14:37.356 A:middle
It's also, however, still large

00:14:37.356 --> 00:14:38.936 A:middle
enough to do an important small

00:14:38.936 --> 00:14:40.026 A:middle
string optimization.

00:14:40.706 --> 00:14:42.746 A:middle
If the string fits within 15

00:14:42.746 --> 00:14:45.226 A:middle
bytes then the actual string is

00:14:45.226 --> 00:14:46.636 A:middle
represented directly in the

00:14:46.636 --> 00:14:48.246 A:middle
string type without going to the

00:14:48.246 --> 00:14:49.306 A:middle
heap to allocate a separate

00:14:49.306 --> 00:14:50.806 A:middle
buffer to represent the string.

00:14:51.436 --> 00:14:53.456 A:middle
This is obviously also a memory

00:14:53.456 --> 00:14:55.066 A:middle
win and a performance win.

00:14:55.716 --> 00:14:56.546 A:middle
This is as similar to an

00:14:56.546 --> 00:14:57.866 A:middle
optimization that exists within

00:14:57.866 --> 00:14:58.286 A:middle
a string.

00:14:58.586 --> 00:14:59.986 A:middle
We can actually represent larger

00:14:59.986 --> 00:15:00.516 A:middle
strings.

00:14:59.986 --> 00:15:00.516 A:middle
strings.

00:15:03.396 --> 00:15:05.096 A:middle
Finally before I hand it off to

00:15:05.156 --> 00:15:06.126 A:middle
Slava we'll talk about the

00:15:06.126 --> 00:15:07.086 A:middle
language improvements.

00:15:07.086 --> 00:15:08.576 A:middle
I want to talk a little bit more

00:15:08.576 --> 00:15:10.216 A:middle
about the efforts to reduce code

00:15:10.216 --> 00:15:10.636 A:middle
size.

00:15:12.176 --> 00:15:13.146 A:middle
I talked a little bit about that

00:15:13.146 --> 00:15:14.586 A:middle
calling convention change, which

00:15:14.586 --> 00:15:15.826 A:middle
reduces code size.

00:15:15.826 --> 00:15:17.546 A:middle
But we've also introduced a new

00:15:17.546 --> 00:15:19.936 A:middle
optimization level, Optimize for

00:15:19.936 --> 00:15:20.256 A:middle
Size.

00:15:21.466 --> 00:15:22.366 A:middle
This can be useful for

00:15:22.366 --> 00:15:23.986 A:middle
applications that care very much

00:15:24.056 --> 00:15:25.966 A:middle
about app size limits such as

00:15:25.966 --> 00:15:27.216 A:middle
from cellular over the air

00:15:27.216 --> 00:15:28.056 A:middle
download limits.

00:15:29.146 --> 00:15:30.626 A:middle
Swift is a very powerful

00:15:30.696 --> 00:15:33.656 A:middle
language with static knowledge

00:15:33.656 --> 00:15:34.846 A:middle
about what your program does.

00:15:35.306 --> 00:15:36.306 A:middle
And so compiler has many

00:15:36.306 --> 00:15:38.626 A:middle
opportunities to do performance

00:15:38.626 --> 00:15:40.016 A:middle
optimizations such as function

00:15:40.016 --> 00:15:41.596 A:middle
call inlining, speculative

00:15:41.596 --> 00:15:43.126 A:middle
devirtualization, which trade

00:15:43.126 --> 00:15:44.326 A:middle
off a little bit of code size

00:15:44.326 --> 00:15:45.846 A:middle
for more performance, but

00:15:45.846 --> 00:15:46.936 A:middle
sometimes that more performance

00:15:47.226 --> 00:15:49.346 A:middle
isn't really needed in practice.

00:15:49.956 --> 00:15:51.726 A:middle
This is the result of applying

00:15:51.786 --> 00:15:52.846 A:middle
Osize to the Swift Source

00:15:52.846 --> 00:15:54.466 A:middle
Compatibility Suite, which

00:15:54.466 --> 00:15:55.546 A:middle
contains an assortment of

00:15:55.546 --> 00:15:57.446 A:middle
projects from GitHub, frameworks

00:15:57.446 --> 00:15:58.266 A:middle
and applications.

00:15:59.156 --> 00:16:00.176 A:middle
And what you'll see is a wide

00:15:59.156 --> 00:16:00.176 A:middle
And what you'll see is a wide

00:16:00.176 --> 00:16:01.626 A:middle
range depending on what language

00:16:01.626 --> 00:16:03.456 A:middle
features are used about 10% to

00:16:03.456 --> 00:16:05.136 A:middle
30% reduction in code size.

00:16:05.826 --> 00:16:07.206 A:middle
Now this, when I talk about code

00:16:07.206 --> 00:16:07.896 A:middle
size I'm talking about the

00:16:07.896 --> 00:16:09.636 A:middle
machine code that is generated

00:16:09.636 --> 00:16:11.046 A:middle
as a result of compiling your

00:16:11.046 --> 00:16:12.316 A:middle
Swift code, not the overall app

00:16:12.386 --> 00:16:12.676 A:middle
size.

00:16:12.906 --> 00:16:14.206 A:middle
The overall app size depends on

00:16:14.206 --> 00:16:15.466 A:middle
assets and all sorts of other

00:16:15.466 --> 00:16:15.766 A:middle
stuff.

00:16:17.576 --> 00:16:19.416 A:middle
In practice we observe that

00:16:19.416 --> 00:16:20.626 A:middle
runtime performance is usually

00:16:20.626 --> 00:16:21.836 A:middle
about 5% slower.

00:16:21.836 --> 00:16:23.056 A:middle
So you're trading off for a

00:16:23.056 --> 00:16:23.776 A:middle
little bit of performance.

00:16:24.336 --> 00:16:25.766 A:middle
For many applications this is

00:16:25.766 --> 00:16:26.496 A:middle
totally fine.

00:16:26.926 --> 00:16:28.406 A:middle
So it really depends on your use

00:16:28.466 --> 00:16:28.716 A:middle
case.

00:16:29.216 --> 00:16:30.096 A:middle
But if this is something you're

00:16:30.096 --> 00:16:31.516 A:middle
interested in we encourage you

00:16:31.516 --> 00:16:33.956 A:middle
to give it a try.

00:16:34.456 --> 00:16:35.476 A:middle
With that I'd like to hand it

00:16:35.476 --> 00:16:36.916 A:middle
off to Slava who will talk about

00:16:36.916 --> 00:16:37.806 A:middle
all the great language and

00:16:37.806 --> 00:16:39.826 A:middle
improvements with Swift 4.2

00:16:40.516 --> 00:16:45.546 A:middle
[ Applause ]

00:16:46.046 --> 00:16:47.356 A:middle
&gt;&gt; Hey everybody, I'm Slava

00:16:47.356 --> 00:16:47.856 A:middle
Pestov.

00:16:47.896 --> 00:16:49.586 A:middle
I work on the Swift Compiler and

00:16:49.586 --> 00:16:50.886 A:middle
today I'm going to talk about

00:16:50.886 --> 00:16:52.366 A:middle
how the new language features in

00:16:52.366 --> 00:16:54.216 A:middle
Swift 4.2 allow you to write

00:16:54.216 --> 00:16:55.666 A:middle
simpler and more maintainable

00:16:55.666 --> 00:16:55.956 A:middle
code.

00:16:57.556 --> 00:16:59.156 A:middle
So before we start talking about

00:16:59.196 --> 00:17:00.766 A:middle
the new language changes, let's

00:16:59.196 --> 00:17:00.766 A:middle
the new language changes, let's

00:17:00.766 --> 00:17:02.576 A:middle
review the process for making

00:17:02.576 --> 00:17:03.886 A:middle
improvements to the language.

00:17:04.516 --> 00:17:06.506 A:middle
So as Ted mentioned, Swift is an

00:17:06.506 --> 00:17:08.506 A:middle
open source project, but it also

00:17:08.506 --> 00:17:09.556 A:middle
has an open design.

00:17:10.165 --> 00:17:11.435 A:middle
This means that if you have an

00:17:11.435 --> 00:17:13.066 A:middle
idea for improving the language,

00:17:13.386 --> 00:17:14.636 A:middle
you can go and pitch it on the

00:17:14.715 --> 00:17:16.826 A:middle
forums and if the idea gains

00:17:16.826 --> 00:17:18.536 A:middle
enough traction and crystalizes

00:17:18.606 --> 00:17:20.465 A:middle
into draft proposal, you can

00:17:20.465 --> 00:17:21.606 A:middle
submit it together with

00:17:21.606 --> 00:17:23.435 A:middle
implementation to the core team

00:17:23.506 --> 00:17:24.286 A:middle
for review.

00:17:24.626 --> 00:17:26.165 A:middle
At this point a formal review

00:17:26.165 --> 00:17:27.596 A:middle
period allows members of the

00:17:27.626 --> 00:17:28.946 A:middle
community to give additional

00:17:29.016 --> 00:17:30.726 A:middle
feedback and then the core team

00:17:30.726 --> 00:17:32.486 A:middle
makes a decision as to whether

00:17:32.486 --> 00:17:33.606 A:middle
to accept the proposal.

00:17:34.796 --> 00:17:36.196 A:middle
If you go to the Swift Evolution

00:17:36.196 --> 00:17:38.346 A:middle
website, you can see a list of

00:17:38.346 --> 00:17:39.596 A:middle
all the proposals that were

00:17:39.596 --> 00:17:41.286 A:middle
accepted and implemented in

00:17:41.286 --> 00:17:42.406 A:middle
Swift 4.2.

00:17:43.396 --> 00:17:44.976 A:middle
And if you look at this list of

00:17:44.976 --> 00:17:46.646 A:middle
proposals there's a lot here.

00:17:46.646 --> 00:17:47.946 A:middle
There's more than I can cover

00:17:47.946 --> 00:17:48.316 A:middle
today.

00:17:48.776 --> 00:17:50.046 A:middle
But one thing I really wanted to

00:17:50.046 --> 00:17:51.776 A:middle
emphasize was the large number

00:17:51.776 --> 00:17:53.086 A:middle
of proposals that were both

00:17:53.086 --> 00:17:55.476 A:middle
designed and implemented by the

00:17:55.476 --> 00:17:56.136 A:middle
community.

00:17:56.566 --> 00:17:58.066 A:middle
What this means is that these

00:17:58.066 --> 00:17:59.626 A:middle
proposals address common

00:17:59.666 --> 00:18:01.406 A:middle
pinpoints in the language that

00:17:59.666 --> 00:18:01.406 A:middle
pinpoints in the language that

00:18:01.406 --> 00:18:03.276 A:middle
came up in the real world and

00:18:03.276 --> 00:18:05.756 A:middle
you came up with the idea for

00:18:05.756 --> 00:18:07.636 A:middle
fixing these pinpoints and you

00:18:07.636 --> 00:18:09.246 A:middle
contributed these improvements

00:18:09.286 --> 00:18:11.126 A:middle
back to Swift so that everybody

00:18:11.126 --> 00:18:11.766 A:middle
benefits.

00:18:12.166 --> 00:18:12.516 A:middle
Thank you.

00:18:14.516 --> 00:18:19.016 A:middle
[ Applause ]

00:18:19.516 --> 00:18:20.936 A:middle
So for the first improvement

00:18:21.126 --> 00:18:22.226 A:middle
we're going to see how to

00:18:22.226 --> 00:18:23.636 A:middle
eliminate a common source of

00:18:23.636 --> 00:18:25.226 A:middle
boilerplate when working with

00:18:25.226 --> 00:18:25.486 A:middle
enum's.

00:18:26.566 --> 00:18:27.896 A:middle
So let's say I have to find an

00:18:27.896 --> 00:18:28.196 A:middle
enum.

00:18:28.616 --> 00:18:30.486 A:middle
And I want to print every

00:18:30.486 --> 00:18:32.096 A:middle
possible value that this data

00:18:32.096 --> 00:18:32.846 A:middle
type can have.

00:18:33.376 --> 00:18:36.286 A:middle
So in Swift 4, I had to define a

00:18:36.286 --> 00:18:38.636 A:middle
property perhaps with a list of

00:18:39.026 --> 00:18:40.386 A:middle
all the possible cases.

00:18:41.056 --> 00:18:44.656 A:middle
And if I add a new case then I

00:18:44.656 --> 00:18:46.016 A:middle
have to remember to update that

00:18:46.086 --> 00:18:48.376 A:middle
property, otherwise I just get

00:18:48.376 --> 00:18:49.706 A:middle
incorrect behavior or runtime.

00:18:50.976 --> 00:18:53.536 A:middle
And this is just not very good

00:18:53.536 --> 00:18:54.936 A:middle
because you're repeating

00:18:54.936 --> 00:18:56.406 A:middle
yourself to the compiler.

00:18:56.986 --> 00:18:59.296 A:middle
So in Swift 4.2 we've added a

00:18:59.296 --> 00:19:01.966 A:middle
new CaseIterable protocol and if

00:18:59.296 --> 00:19:01.966 A:middle
new CaseIterable protocol and if

00:19:01.966 --> 00:19:03.346 A:middle
you state a conformance to this

00:19:03.406 --> 00:19:04.726 A:middle
protocol, the compiler will

00:19:04.726 --> 00:19:06.676 A:middle
synthesize an all cases property

00:19:06.676 --> 00:19:07.096 A:middle
for you.

00:19:07.096 --> 00:19:08.976 A:middle
OK, that was short and sweet.

00:19:09.516 --> 00:19:12.546 A:middle
[ Applause ]

00:19:13.046 --> 00:19:15.216 A:middle
For the next improvement we're

00:19:15.216 --> 00:19:16.476 A:middle
going to see how to eliminate

00:19:16.476 --> 00:19:17.806 A:middle
another source of boilerplate.

00:19:18.016 --> 00:19:19.216 A:middle
This time it's when you're

00:19:19.306 --> 00:19:20.436 A:middle
unable to make your code

00:19:20.626 --> 00:19:21.786 A:middle
sufficiently generic.

00:19:22.726 --> 00:19:24.916 A:middle
So in Swift 4 we have this

00:19:24.956 --> 00:19:26.596 A:middle
contains method on sequence.

00:19:27.006 --> 00:19:28.506 A:middle
And this requires that the

00:19:28.506 --> 00:19:30.106 A:middle
element type of the sequence is

00:19:30.106 --> 00:19:32.186 A:middle
Equatable so that it can find

00:19:32.186 --> 00:19:33.376 A:middle
the element that it's looking

00:19:33.446 --> 00:19:33.666 A:middle
for.

00:19:34.636 --> 00:19:36.736 A:middle
And of course I could call this

00:19:36.736 --> 00:19:37.966 A:middle
within an array of strings

00:19:38.236 --> 00:19:39.616 A:middle
because string is Equatable.

00:19:39.616 --> 00:19:41.516 A:middle
But what if I call it within an

00:19:41.516 --> 00:19:42.346 A:middle
array of arrays.

00:19:43.226 --> 00:19:45.736 A:middle
Well array of Int, the element

00:19:45.736 --> 00:19:47.756 A:middle
type here is not equitable,

00:19:48.126 --> 00:19:49.486 A:middle
which meant that I would just

00:19:49.486 --> 00:19:50.596 A:middle
get a compile time error.

00:19:51.796 --> 00:19:53.796 A:middle
And you might ask, well why

00:19:53.796 --> 00:19:55.106 A:middle
doesn't the standard library

00:19:55.196 --> 00:19:56.796 A:middle
make all arrays Equatable.

00:19:57.136 --> 00:19:58.316 A:middle
But that doesn't make sense

00:19:58.316 --> 00:20:00.666 A:middle
either because if the element

00:19:58.316 --> 00:20:00.666 A:middle
either because if the element

00:20:00.666 --> 00:20:01.836 A:middle
type of the array is not

00:20:01.836 --> 00:20:03.366 A:middle
Equatable, like a function

00:20:03.396 --> 00:20:05.056 A:middle
perhaps, then you can't really

00:20:05.056 --> 00:20:06.566 A:middle
make the array Equatable either.

00:20:07.956 --> 00:20:09.286 A:middle
But certainly if the element

00:20:09.326 --> 00:20:10.846 A:middle
type of the array is Equatable

00:20:10.846 --> 00:20:12.726 A:middle
then I can define an equality

00:20:12.726 --> 00:20:14.516 A:middle
operation on arrays that just

00:20:14.516 --> 00:20:16.376 A:middle
compares the elements pair wise.

00:20:17.116 --> 00:20:18.516 A:middle
And this is what conditional

00:20:18.516 --> 00:20:20.116 A:middle
conformance allows a standard

00:20:20.116 --> 00:20:21.286 A:middle
library to do.

00:20:21.376 --> 00:20:23.076 A:middle
So now array gets an

00:20:23.076 --> 00:20:24.916 A:middle
implementation of Equatable for

00:20:24.916 --> 00:20:26.246 A:middle
the case where the element type

00:20:26.246 --> 00:20:27.056 A:middle
is equitable.

00:20:27.416 --> 00:20:29.776 A:middle
And in Swift 4.2 this example we

00:20:29.776 --> 00:20:31.366 A:middle
saw earlier now works.

00:20:31.856 --> 00:20:34.776 A:middle
And in addition to arrays being

00:20:34.776 --> 00:20:36.146 A:middle
Equatable the standard library

00:20:36.146 --> 00:20:37.636 A:middle
defines a number of other

00:20:37.636 --> 00:20:38.896 A:middle
conditional conformance.

00:20:39.436 --> 00:20:41.026 A:middle
For example, optional and

00:20:41.026 --> 00:20:42.726 A:middle
dictionaries are now Equatable

00:20:42.726 --> 00:20:44.126 A:middle
when their element type is

00:20:44.126 --> 00:20:46.486 A:middle
Equatable and the same works for

00:20:46.536 --> 00:20:49.576 A:middle
Hashable, Encodable, and

00:20:49.576 --> 00:20:51.306 A:middle
Decodable conformances.

00:20:52.516 --> 00:20:57.576 A:middle
[ Applause ]

00:20:58.076 --> 00:20:59.746 A:middle
And this allows you to compose

00:20:59.746 --> 00:21:01.156 A:middle
collections in ways that were

00:20:59.746 --> 00:21:01.156 A:middle
collections in ways that were

00:21:01.156 --> 00:21:02.256 A:middle
not possible before.

00:21:02.986 --> 00:21:05.886 A:middle
So here I have a set of arrays

00:21:05.886 --> 00:21:08.166 A:middle
of optional integers and

00:21:09.176 --> 00:21:10.366 A:middle
everything just works.

00:21:10.916 --> 00:21:13.416 A:middle
If you want to learn more

00:21:13.416 --> 00:21:14.656 A:middle
there's a session later this

00:21:14.656 --> 00:21:17.026 A:middle
week where you can learn about

00:21:17.026 --> 00:21:18.476 A:middle
conditional conformance and some

00:21:18.476 --> 00:21:19.946 A:middle
other generics improvements in

00:21:19.946 --> 00:21:21.256 A:middle
Swift 4.2 that I won't be

00:21:21.256 --> 00:21:22.536 A:middle
covering today.

00:21:23.896 --> 00:21:25.756 A:middle
So what about defining your own

00:21:25.756 --> 00:21:26.776 A:middle
Equatable and Hashable

00:21:26.776 --> 00:21:27.606 A:middle
conformances.

00:21:28.596 --> 00:21:30.376 A:middle
Well, a common pattern in Swift

00:21:30.446 --> 00:21:32.446 A:middle
is that I have a struct with a

00:21:32.446 --> 00:21:34.516 A:middle
bunch of stored properties and

00:21:34.516 --> 00:21:36.006 A:middle
all those stored properties are

00:21:36.006 --> 00:21:37.096 A:middle
themselves Equatable.

00:21:37.436 --> 00:21:38.546 A:middle
And then I want to make the

00:21:38.546 --> 00:21:40.656 A:middle
struct Equatable just by

00:21:40.656 --> 00:21:42.156 A:middle
comparing those properties of

00:21:42.156 --> 00:21:43.056 A:middle
the two values.

00:21:43.516 --> 00:21:45.616 A:middle
In Swift 4 previously you had to

00:21:45.616 --> 00:21:46.726 A:middle
write this out by hand.

00:21:47.166 --> 00:21:48.486 A:middle
And this is just boilerplate.

00:21:48.706 --> 00:21:50.276 A:middle
If I add a new stored property

00:21:50.276 --> 00:21:51.836 A:middle
to my struct, I have to remember

00:21:51.836 --> 00:21:53.286 A:middle
to update this implementation of

00:21:53.286 --> 00:21:54.926 A:middle
Equatable and it's easy to make

00:21:54.926 --> 00:21:56.466 A:middle
a copy and paste error or some

00:21:56.466 --> 00:21:57.166 A:middle
other mistake.

00:21:57.796 --> 00:21:59.676 A:middle
So in Swift 4.1 we introduce

00:21:59.676 --> 00:22:01.536 A:middle
this ability to synthesize the

00:21:59.676 --> 00:22:01.536 A:middle
this ability to synthesize the

00:22:01.536 --> 00:22:02.926 A:middle
implementation of equality.

00:22:03.386 --> 00:22:04.966 A:middle
If you emit the implementation

00:22:05.186 --> 00:22:06.326 A:middle
than the compiler will fill it

00:22:06.326 --> 00:22:08.046 A:middle
in for you as long as all those

00:22:08.046 --> 00:22:09.556 A:middle
stored properties are themselves

00:22:09.556 --> 00:22:10.036 A:middle
Equatable.

00:22:11.076 --> 00:22:12.626 A:middle
This also works for Hashable.

00:22:13.996 --> 00:22:15.726 A:middle
Now what about generic types?

00:22:16.266 --> 00:22:17.986 A:middle
So here I have a data type whose

00:22:17.986 --> 00:22:19.556 A:middle
values are either instances of

00:22:19.556 --> 00:22:21.706 A:middle
the left type or instances of

00:22:21.706 --> 00:22:22.316 A:middle
the right type.

00:22:22.936 --> 00:22:24.586 A:middle
And I might now want to make

00:22:24.586 --> 00:22:26.216 A:middle
left and right constrained to

00:22:26.216 --> 00:22:27.776 A:middle
Equatable because again, I want

00:22:27.776 --> 00:22:28.876 A:middle
to be able to use this either

00:22:28.876 --> 00:22:31.046 A:middle
type with functions, errors, and

00:22:31.046 --> 00:22:32.446 A:middle
other non Equatable types.

00:22:32.916 --> 00:22:34.326 A:middle
But certainly I can define a

00:22:34.326 --> 00:22:36.226 A:middle
conditional conformance so that

00:22:36.226 --> 00:22:37.506 A:middle
if left and right are both

00:22:37.506 --> 00:22:39.146 A:middle
Equatable then either is

00:22:39.146 --> 00:22:39.726 A:middle
Equatable.

00:22:40.116 --> 00:22:41.386 A:middle
But I can do even better than

00:22:41.386 --> 00:22:41.696 A:middle
this.

00:22:42.166 --> 00:22:43.666 A:middle
Notice how the implementation of

00:22:43.666 --> 00:22:45.576 A:middle
equality here there's only

00:22:45.576 --> 00:22:47.206 A:middle
really one obviously correct way

00:22:47.206 --> 00:22:47.616 A:middle
to do it.

00:22:47.946 --> 00:22:49.186 A:middle
You have to check that both

00:22:49.186 --> 00:22:51.416 A:middle
values have the same case and if

00:22:51.416 --> 00:22:53.286 A:middle
they do you check their payloads

00:22:53.286 --> 00:22:53.996 A:middle
for equality.

00:22:54.776 --> 00:22:56.396 A:middle
So you might guess, well the

00:22:56.396 --> 00:22:57.426 A:middle
compiler should be able to

00:22:57.426 --> 00:22:58.926 A:middle
synthesize this for you and it

00:22:58.926 --> 00:23:00.256 A:middle
can in Swift 4.2.

00:22:58.926 --> 00:23:00.256 A:middle
can in Swift 4.2.

00:23:01.176 --> 00:23:02.666 A:middle
And this also works for

00:23:02.666 --> 00:23:03.186 A:middle
Hashable.

00:23:04.676 --> 00:23:07.166 A:middle
So now I can have a set of

00:23:07.356 --> 00:23:09.256 A:middle
either Int's or strings as one

00:23:09.256 --> 00:23:09.786 A:middle
example.

00:23:11.546 --> 00:23:11.656 A:middle
OK.

00:23:12.516 --> 00:23:15.676 A:middle
[ Applause ]

00:23:16.176 --> 00:23:18.146 A:middle
Now, there are cases where you

00:23:18.146 --> 00:23:19.526 A:middle
really do have to implement

00:23:19.586 --> 00:23:22.766 A:middle
equality and Hashing by hand.

00:23:23.436 --> 00:23:25.216 A:middle
So let's look at one example of

00:23:25.216 --> 00:23:25.456 A:middle
that.

00:23:26.616 --> 00:23:27.866 A:middle
Let's say I have a data type

00:23:28.006 --> 00:23:30.796 A:middle
that represents a city and it's

00:23:30.796 --> 00:23:32.166 A:middle
got a name, it's got the state

00:23:32.166 --> 00:23:33.456 A:middle
that it's located in, and it has

00:23:33.456 --> 00:23:34.296 A:middle
the population.

00:23:34.706 --> 00:23:35.556 A:middle
And let's say that for the

00:23:35.556 --> 00:23:38.006 A:middle
purposes of this example I only

00:23:38.006 --> 00:23:39.536 A:middle
have to compare the name and the

00:23:39.536 --> 00:23:41.456 A:middle
state for equality and if I know

00:23:41.456 --> 00:23:42.826 A:middle
those are equal I don't have to

00:23:42.826 --> 00:23:43.926 A:middle
check the population.

00:23:44.616 --> 00:23:46.446 A:middle
So if I let the compiler

00:23:46.446 --> 00:23:48.056 A:middle
synthesize the implementation of

00:23:48.056 --> 00:23:49.706 A:middle
equality here it's going to do

00:23:49.706 --> 00:23:51.046 A:middle
unnecessary work because it's

00:23:51.046 --> 00:23:52.006 A:middle
going to be comparing that

00:23:52.006 --> 00:23:53.046 A:middle
population field.

00:23:53.776 --> 00:23:55.436 A:middle
But I certainly write it out by

00:23:55.436 --> 00:23:56.976 A:middle
hand and maybe in this case it's

00:23:56.976 --> 00:23:57.636 A:middle
not too bad.

00:23:58.556 --> 00:23:59.796 A:middle
But what about Hashable?

00:24:01.286 --> 00:24:02.796 A:middle
So if I want to calculate the

00:24:02.836 --> 00:24:04.566 A:middle
Hash code of the city object,

00:24:05.066 --> 00:24:06.986 A:middle
then I'm going to calculate the

00:24:07.016 --> 00:24:08.336 A:middle
Hash code of the name and the

00:24:08.336 --> 00:24:09.636 A:middle
Hash code of the state and I

00:24:09.636 --> 00:24:11.086 A:middle
have to combine them somehow.

00:24:11.646 --> 00:24:12.686 A:middle
But how do I do that?

00:24:13.296 --> 00:24:15.286 A:middle
Well, I can use an exclusive or

00:24:15.286 --> 00:24:18.246 A:middle
operation or I could use some

00:24:18.246 --> 00:24:20.196 A:middle
random math formula that I found

00:24:20.196 --> 00:24:21.866 A:middle
on the Internet or just came up

00:24:21.866 --> 00:24:22.656 A:middle
with myself.

00:24:23.246 --> 00:24:24.976 A:middle
But neither one of these is very

00:24:24.976 --> 00:24:27.306 A:middle
satisfying and it feels like

00:24:27.306 --> 00:24:28.896 A:middle
these Hash combining functions

00:24:29.176 --> 00:24:30.556 A:middle
have a lot of magic to them.

00:24:30.876 --> 00:24:32.336 A:middle
And the cost of getting it wrong

00:24:32.336 --> 00:24:34.376 A:middle
is pretty high because the

00:24:34.376 --> 00:24:35.846 A:middle
performance properties that you

00:24:35.846 --> 00:24:37.526 A:middle
expect to get from a dictionary

00:24:37.526 --> 00:24:39.716 A:middle
or a set really rely on having a

00:24:39.716 --> 00:24:41.416 A:middle
good high-quality Hash function.

00:24:42.146 --> 00:24:43.956 A:middle
There's also a security angle

00:24:44.016 --> 00:24:44.266 A:middle
here.

00:24:44.636 --> 00:24:46.966 A:middle
So if an attacker is able to

00:24:46.966 --> 00:24:49.336 A:middle
craft inputs that all Hash to

00:24:49.336 --> 00:24:51.086 A:middle
the same value and send them to

00:24:51.086 --> 00:24:52.336 A:middle
your app over the Internet

00:24:52.396 --> 00:24:54.286 A:middle
somehow, then it might slow your

00:24:54.286 --> 00:24:55.466 A:middle
app down to the point where it

00:24:55.466 --> 00:24:56.906 A:middle
becomes unusable creating a

00:24:56.906 --> 00:24:58.056 A:middle
denial of service attack.

00:24:58.536 --> 00:25:01.066 A:middle
So in Swift 4.2 we've added a

00:24:58.536 --> 00:25:01.066 A:middle
So in Swift 4.2 we've added a

00:25:01.066 --> 00:25:02.476 A:middle
better API for this.

00:25:03.316 --> 00:25:05.396 A:middle
Now recall the Hashable protocol

00:25:05.396 --> 00:25:06.896 A:middle
in Swift 4 and 4.1.

00:25:07.486 --> 00:25:09.076 A:middle
It has a single Hash value

00:25:09.076 --> 00:25:10.446 A:middle
requirement that produces a

00:25:10.446 --> 00:25:11.696 A:middle
single integer value.

00:25:12.446 --> 00:25:14.676 A:middle
In Swift 4.2 we've redesigned

00:25:14.676 --> 00:25:16.936 A:middle
the Hashable protocol so now

00:25:17.296 --> 00:25:19.116 A:middle
there's a different Hash into

00:25:19.116 --> 00:25:19.746 A:middle
requirement.

00:25:20.126 --> 00:25:21.346 A:middle
And instead of producing a

00:25:21.346 --> 00:25:23.466 A:middle
single Hash code value, Hash

00:25:23.466 --> 00:25:26.146 A:middle
into takes a Hasher instance and

00:25:26.146 --> 00:25:27.636 A:middle
then you can feed multiple

00:25:27.636 --> 00:25:29.616 A:middle
values into the Hasher, which

00:25:29.616 --> 00:25:31.126 A:middle
will combine them into one Hash

00:25:31.126 --> 00:25:31.376 A:middle
code.

00:25:32.306 --> 00:25:34.096 A:middle
So going back to our example of

00:25:34.096 --> 00:25:36.076 A:middle
the city data type, all we have

00:25:36.076 --> 00:25:38.226 A:middle
to do is implement Hash into by

00:25:38.226 --> 00:25:40.546 A:middle
recursively calling Hash into on

00:25:40.546 --> 00:25:42.576 A:middle
the name and the state passing

00:25:42.576 --> 00:25:44.596 A:middle
in the Hasher object instance

00:25:44.596 --> 00:25:45.316 A:middle
that we were given.

00:25:46.486 --> 00:25:49.786 A:middle
And the Hash combining algorithm

00:25:49.786 --> 00:25:51.726 A:middle
in the Hasher, it does a good

00:25:51.726 --> 00:25:53.526 A:middle
job of balancing the quality of

00:25:53.526 --> 00:25:55.146 A:middle
the Hash code with performance

00:25:55.476 --> 00:25:56.556 A:middle
and as an added layer of

00:25:56.606 --> 00:25:57.816 A:middle
protection against denial of

00:25:57.816 --> 00:25:59.686 A:middle
service attacks, it uses a

00:25:59.686 --> 00:26:01.616 A:middle
random preprocess seed, which is

00:25:59.686 --> 00:26:01.616 A:middle
random preprocess seed, which is

00:26:01.616 --> 00:26:03.346 A:middle
generated when your app starts.

00:26:05.136 --> 00:26:07.236 A:middle
And we think that it should be

00:26:07.316 --> 00:26:09.136 A:middle
pretty easy to migrate your code

00:26:09.136 --> 00:26:10.746 A:middle
to using the new Hashable

00:26:10.746 --> 00:26:12.256 A:middle
protocol and we encourage you to

00:26:12.256 --> 00:26:12.756 A:middle
do so.

00:26:13.206 --> 00:26:15.016 A:middle
The one caveat to watch out for

00:26:15.016 --> 00:26:16.936 A:middle
is you might have some code

00:26:16.936 --> 00:26:18.746 A:middle
where you're expecting that Hash

00:26:18.746 --> 00:26:20.426 A:middle
values remain constant from

00:26:20.426 --> 00:26:22.296 A:middle
different runs of your app or

00:26:22.296 --> 00:26:23.566 A:middle
that if you iterate over a

00:26:23.566 --> 00:26:25.416 A:middle
dictionary or a set you're going

00:26:25.416 --> 00:26:26.636 A:middle
to get the elements in the same

00:26:26.636 --> 00:26:26.976 A:middle
order.

00:26:27.256 --> 00:26:28.726 A:middle
And this is no longer the case

00:26:28.726 --> 00:26:29.656 A:middle
because of that random

00:26:29.656 --> 00:26:30.676 A:middle
preprocess seed.

00:26:30.746 --> 00:26:31.816 A:middle
So you will need to fix your

00:26:31.816 --> 00:26:32.116 A:middle
code.

00:26:32.916 --> 00:26:35.096 A:middle
And to make this easier we've

00:26:35.096 --> 00:26:37.336 A:middle
added a build setting, the Swift

00:26:37.336 --> 00:26:38.426 A:middle
Deterministic Hashing

00:26:38.426 --> 00:26:39.996 A:middle
Environment Variable, which you

00:26:39.996 --> 00:26:41.666 A:middle
can enable in the scheme editor

00:26:42.246 --> 00:26:43.736 A:middle
to temporarily disable that

00:26:43.786 --> 00:26:45.256 A:middle
preprocess random seed.

00:26:45.796 --> 00:26:49.466 A:middle
OK, so let's talk about

00:26:49.606 --> 00:26:51.096 A:middle
generating random numbers.

00:26:52.396 --> 00:26:53.656 A:middle
So how do you generate random

00:26:53.656 --> 00:26:54.706 A:middle
numbers in Swift today?

00:26:55.356 --> 00:26:57.916 A:middle
Well, you have to use imported C

00:26:57.916 --> 00:26:58.376 A:middle
APIs.

00:26:58.446 --> 00:26:59.876 A:middle
And this is really not ideal

00:26:59.876 --> 00:27:01.446 A:middle
because they are different

00:26:59.876 --> 00:27:01.446 A:middle
because they are different

00:27:01.446 --> 00:27:03.866 A:middle
between platforms and they have

00:27:03.866 --> 00:27:04.876 A:middle
different names, different

00:27:04.876 --> 00:27:06.586 A:middle
behavior, so you have to use

00:27:06.666 --> 00:27:08.156 A:middle
build configuration checks.

00:27:08.566 --> 00:27:10.486 A:middle
But also they're quite low level

00:27:10.486 --> 00:27:12.806 A:middle
and these common operations that

00:27:12.806 --> 00:27:14.156 A:middle
are not quite so obvious to

00:27:14.156 --> 00:27:14.566 A:middle
implement.

00:27:15.316 --> 00:27:16.886 A:middle
For example, if I want to get a

00:27:16.886 --> 00:27:19.016 A:middle
random number between 1 and 6,

00:27:19.406 --> 00:27:21.446 A:middle
then I might think to just call

00:27:21.446 --> 00:27:23.716 A:middle
this Darwin arc4random function

00:27:23.826 --> 00:27:25.366 A:middle
and then calculate the remainder

00:27:25.366 --> 00:27:26.556 A:middle
of dividing by 6.

00:27:26.836 --> 00:27:27.916 A:middle
But that actually gives you a

00:27:27.916 --> 00:27:29.476 A:middle
result that is not uniformly

00:27:29.476 --> 00:27:31.566 A:middle
distributed between 1 and 6.

00:27:32.346 --> 00:27:35.386 A:middle
So in Swift 4.2 we've added a

00:27:35.386 --> 00:27:37.236 A:middle
new set of APIs to make this

00:27:37.236 --> 00:27:38.086 A:middle
kind of thing easier.

00:27:39.146 --> 00:27:41.186 A:middle
First of all, all the numeric

00:27:41.186 --> 00:27:43.296 A:middle
types now define a random method

00:27:43.486 --> 00:27:45.576 A:middle
that takes a range and returns a

00:27:45.576 --> 00:27:47.326 A:middle
number uniformly distributed in

00:27:47.326 --> 00:27:47.986 A:middle
that range.

00:27:48.196 --> 00:27:49.816 A:middle
This uses the correct algorithm

00:27:49.816 --> 00:27:51.316 A:middle
and it even works for floats.

00:27:52.516 --> 00:27:58.596 A:middle
[ Applause ]

00:27:59.096 --> 00:28:00.676 A:middle
For higher level code we've

00:27:59.096 --> 00:28:00.676 A:middle
For higher level code we've

00:28:00.676 --> 00:28:03.076 A:middle
added a random element method to

00:28:03.076 --> 00:28:04.196 A:middle
the collection protocol.

00:28:04.786 --> 00:28:07.026 A:middle
And just like min and max this

00:28:07.026 --> 00:28:08.636 A:middle
returns an optional so that if

00:28:08.636 --> 00:28:10.376 A:middle
you pass in an empty collection

00:28:10.526 --> 00:28:11.506 A:middle
you get back no.

00:28:12.596 --> 00:28:14.326 A:middle
And finally there's a shuffled

00:28:14.326 --> 00:28:17.116 A:middle
method on collection where this

00:28:17.116 --> 00:28:18.926 A:middle
gives you an array with a random

00:28:18.926 --> 00:28:20.876 A:middle
permutation of the elements of

00:28:20.876 --> 00:28:21.616 A:middle
that collection.

00:28:22.146 --> 00:28:25.216 A:middle
And we think the default Random

00:28:25.216 --> 00:28:26.636 A:middle
Number Generator is a good

00:28:26.636 --> 00:28:27.996 A:middle
choice for most apps.

00:28:28.296 --> 00:28:29.816 A:middle
But you can also implement your

00:28:29.816 --> 00:28:29.883 A:middle
own.

00:28:30.676 --> 00:28:31.836 A:middle
So there's a random number

00:28:31.836 --> 00:28:34.206 A:middle
generator protocol and once you

00:28:34.206 --> 00:28:35.606 A:middle
write a type that conforms to

00:28:35.606 --> 00:28:37.826 A:middle
this protocol you can pass it to

00:28:37.826 --> 00:28:39.326 A:middle
all these APIs that I talked

00:28:39.326 --> 00:28:40.846 A:middle
about which have an additional

00:28:40.846 --> 00:28:43.416 A:middle
overload with a using parameter

00:28:43.576 --> 00:28:44.706 A:middle
that takes a random number

00:28:44.706 --> 00:28:45.236 A:middle
generator.

00:28:46.746 --> 00:28:49.456 A:middle
OK, so we saw these build

00:28:49.456 --> 00:28:51.446 A:middle
configuration checks earlier.

00:28:51.526 --> 00:28:54.346 A:middle
Let's talk some more about them.

00:28:54.566 --> 00:28:55.896 A:middle
Well, this is a pretty common

00:28:55.896 --> 00:28:56.806 A:middle
pattern in Swift.

00:28:57.026 --> 00:28:58.356 A:middle
You have a little piece of Swift

00:28:58.356 --> 00:29:00.796 A:middle
code that is shared between iOS

00:28:58.356 --> 00:29:00.796 A:middle
code that is shared between iOS

00:29:00.796 --> 00:29:03.836 A:middle
and macOS and on iOS you want to

00:29:03.836 --> 00:29:05.206 A:middle
do something with UIKit.

00:29:05.586 --> 00:29:06.776 A:middle
On macOS you want to do

00:29:06.776 --> 00:29:08.156 A:middle
something similar in AppKit.

00:29:08.896 --> 00:29:10.466 A:middle
So if you want to do this today

00:29:10.466 --> 00:29:11.816 A:middle
you're going to write a #if

00:29:12.236 --> 00:29:14.186 A:middle
compile time condition check and

00:29:14.186 --> 00:29:15.386 A:middle
then you have to list out those

00:29:15.386 --> 00:29:17.216 A:middle
operating systems where UIKit is

00:29:17.216 --> 00:29:17.736 A:middle
available.

00:29:18.566 --> 00:29:20.046 A:middle
So but what you really care

00:29:20.046 --> 00:29:21.836 A:middle
about is not that you're running

00:29:21.836 --> 00:29:23.016 A:middle
on this particular operating

00:29:23.016 --> 00:29:24.606 A:middle
system, but that you can import

00:29:24.606 --> 00:29:25.096 A:middle
UIKit.

00:29:25.626 --> 00:29:27.956 A:middle
So on Swift 4.2 we've added a

00:29:27.956 --> 00:29:30.086 A:middle
has import Build Configuration

00:29:30.086 --> 00:29:32.486 A:middle
Directive so you can better

00:29:32.486 --> 00:29:33.476 A:middle
express your intent.

00:29:34.171 --> 00:29:36.171 A:middle
[ Applause ]

00:29:36.326 --> 00:29:38.026 A:middle
And with the new features of

00:29:38.026 --> 00:29:39.686 A:middle
Swift 4.2, I can actually

00:29:39.686 --> 00:29:40.766 A:middle
improve this code further.

00:29:41.246 --> 00:29:43.326 A:middle
So let's say that I'm also going

00:29:43.326 --> 00:29:44.966 A:middle
to explicitly check for AppKit

00:29:45.306 --> 00:29:47.036 A:middle
and then if neither UIKit nor

00:29:47.036 --> 00:29:48.866 A:middle
AppKit is available, for example

00:29:48.866 --> 00:29:50.576 A:middle
if I'm building on Linux, I'm

00:29:50.576 --> 00:29:52.356 A:middle
going to use the new #error

00:29:52.546 --> 00:29:53.916 A:middle
build directive to produce a

00:29:53.916 --> 00:29:55.306 A:middle
friendly compile time error

00:29:55.306 --> 00:29:55.796 A:middle
message.

00:29:57.206 --> 00:29:59.376 A:middle
OK, now here's another similar

00:29:59.376 --> 00:30:00.416 A:middle
source of boilerplate.

00:29:59.376 --> 00:30:00.416 A:middle
source of boilerplate.

00:30:01.616 --> 00:30:03.126 A:middle
So if I want to compile

00:30:03.126 --> 00:30:05.066 A:middle
something conditionally when I'm

00:30:05.066 --> 00:30:06.476 A:middle
in the simulator environment,

00:30:06.776 --> 00:30:09.266 A:middle
then today in Swift 4 I have to

00:30:09.266 --> 00:30:11.546 A:middle
copy and paste this ugly thing

00:30:11.546 --> 00:30:12.686 A:middle
everywhere I want to perform

00:30:12.686 --> 00:30:13.176 A:middle
that check.

00:30:14.056 --> 00:30:16.456 A:middle
In Swift 4.2 you can use the new

00:30:16.456 --> 00:30:18.596 A:middle
hasTargetEnvironment condition,

00:30:18.906 --> 00:30:21.216 A:middle
to again better state your

00:30:21.216 --> 00:30:23.006 A:middle
intent and just explicitly ask

00:30:23.006 --> 00:30:25.026 A:middle
the compiler, am I compiling for

00:30:25.026 --> 00:30:26.106 A:middle
the simulator or not?

00:30:26.876 --> 00:30:28.826 A:middle
And while we're at it, let's

00:30:28.826 --> 00:30:30.566 A:middle
replace that FIXME with a

00:30:30.656 --> 00:30:32.036 A:middle
#warning build directive to

00:30:32.076 --> 00:30:33.986 A:middle
produce a message or compile

00:30:34.046 --> 00:30:35.856 A:middle
time so that I don't forget to

00:30:35.856 --> 00:30:38.126 A:middle
fix my FIXME.

00:30:38.126 --> 00:30:40.916 A:middle
OK, so that about wraps up all

00:30:40.916 --> 00:30:42.306 A:middle
the features that I'm going to

00:30:42.306 --> 00:30:43.516 A:middle
discuss today, but I have a

00:30:43.516 --> 00:30:44.656 A:middle
couple more things to talk

00:30:44.656 --> 00:30:44.936 A:middle
about.

00:30:46.026 --> 00:30:47.646 A:middle
Let's unwrap, Implicitly

00:30:47.646 --> 00:30:48.586 A:middle
Unwrapped Optionals.

00:30:48.806 --> 00:30:49.646 A:middle
That's a horrible pun.

00:30:50.296 --> 00:30:52.986 A:middle
OK, so Implicitly Unwrapped

00:30:52.986 --> 00:30:54.326 A:middle
Optionals can be a little bit

00:30:54.326 --> 00:30:57.686 A:middle
confusing and let's first review

00:30:57.686 --> 00:30:59.246 A:middle
the mental model for Implicitly

00:30:59.246 --> 00:31:00.196 A:middle
Unwrapped Optionals.

00:30:59.246 --> 00:31:00.196 A:middle
Unwrapped Optionals.

00:31:00.196 --> 00:31:01.266 A:middle
How do I think about them?

00:31:01.966 --> 00:31:04.426 A:middle
Well, so since Swift 3 they're

00:31:04.426 --> 00:31:06.326 A:middle
not the type of an expression.

00:31:06.816 --> 00:31:08.006 A:middle
Don't think of it as a type.

00:31:08.446 --> 00:31:09.856 A:middle
Instead, think of Implicitly

00:31:09.856 --> 00:31:11.256 A:middle
Unwrapped Optionals as an

00:31:11.256 --> 00:31:13.096 A:middle
attribute of a declaration.

00:31:13.996 --> 00:31:15.756 A:middle
And what the compiler does when

00:31:15.756 --> 00:31:17.526 A:middle
you reference such a declaration

00:31:17.846 --> 00:31:19.186 A:middle
is it will first try to type

00:31:19.186 --> 00:31:21.536 A:middle
check it as a plain optional and

00:31:21.536 --> 00:31:23.006 A:middle
then if that doesn't make sense

00:31:23.006 --> 00:31:24.556 A:middle
in the context where it's used,

00:31:24.746 --> 00:31:26.916 A:middle
it goes ahead and unwraps it and

00:31:26.916 --> 00:31:28.096 A:middle
then type checks it as the

00:31:28.096 --> 00:31:28.876 A:middle
underlined type.

00:31:30.296 --> 00:31:31.746 A:middle
So let's look at an example of

00:31:31.746 --> 00:31:32.506 A:middle
the first case.

00:31:33.236 --> 00:31:34.886 A:middle
So here I have two functions,

00:31:34.966 --> 00:31:36.596 A:middle
the first of which produces and

00:31:36.596 --> 00:31:37.906 A:middle
implicitly unwrapped optional

00:31:37.906 --> 00:31:39.656 A:middle
integer and the second of which

00:31:39.656 --> 00:31:41.226 A:middle
takes a value of any type.

00:31:41.836 --> 00:31:43.306 A:middle
And I'm going to call the second

00:31:43.306 --> 00:31:44.516 A:middle
function with the result of the

00:31:44.516 --> 00:31:45.256 A:middle
first function.

00:31:45.916 --> 00:31:47.966 A:middle
Now in this case I can store an

00:31:47.966 --> 00:31:50.506 A:middle
optional Int inside of an Any

00:31:50.856 --> 00:31:52.696 A:middle
and so no forced unwrapping is

00:31:52.696 --> 00:31:53.206 A:middle
performed.

00:31:53.466 --> 00:31:55.456 A:middle
The value simply becomes a plain

00:31:55.456 --> 00:31:55.896 A:middle
optional.

00:31:55.896 --> 00:31:59.156 A:middle
Let's look at an example of the

00:31:59.156 --> 00:31:59.966 A:middle
second case now.

00:32:00.876 --> 00:32:02.856 A:middle
Here, the first function now

00:32:02.856 --> 00:32:05.486 A:middle
produces -- sorry, the second

00:32:05.486 --> 00:32:07.086 A:middle
function now takes an integer.

00:32:07.516 --> 00:32:09.066 A:middle
So when I call the second

00:32:09.066 --> 00:32:10.646 A:middle
function with the result of the

00:32:10.706 --> 00:32:13.006 A:middle
first function then I cannot

00:32:13.086 --> 00:32:14.986 A:middle
pass an optional Int where an

00:32:14.986 --> 00:32:16.126 A:middle
Int was expected.

00:32:16.596 --> 00:32:18.246 A:middle
So the compiler has to insert a

00:32:18.246 --> 00:32:21.296 A:middle
force unwrap and then it all

00:32:21.296 --> 00:32:22.656 A:middle
works because now I have an Int

00:32:22.836 --> 00:32:26.266 A:middle
and an Int And this mental model

00:32:26.346 --> 00:32:27.626 A:middle
makes Implicitly Unwrapped

00:32:27.626 --> 00:32:29.176 A:middle
Optionals very easy to reason

00:32:29.176 --> 00:32:29.506 A:middle
about.

00:32:30.206 --> 00:32:32.566 A:middle
But until recently the compiler

00:32:32.776 --> 00:32:34.166 A:middle
had some edge cases where it did

00:32:34.166 --> 00:32:35.636 A:middle
not always follow this model.

00:32:36.316 --> 00:32:38.956 A:middle
So recall that you cannot have

00:32:38.956 --> 00:32:40.386 A:middle
an implicitly unwrapped optional

00:32:40.386 --> 00:32:41.696 A:middle
that is part of another type.

00:32:42.416 --> 00:32:43.706 A:middle
And this is still the case in

00:32:43.706 --> 00:32:44.646 A:middle
Swift 4.2.

00:32:44.816 --> 00:32:46.616 A:middle
I cannot have an array of

00:32:46.676 --> 00:32:48.296 A:middle
implicitly unwrapped Int's.

00:32:49.136 --> 00:32:51.566 A:middle
However, in Swift 4 previously,

00:32:51.876 --> 00:32:53.136 A:middle
there is some edge cases like

00:32:53.186 --> 00:32:53.536 A:middle
this.

00:32:53.536 --> 00:32:55.606 A:middle
I could define a type alias

00:32:55.796 --> 00:32:57.596 A:middle
where the underlying type was

00:32:57.776 --> 00:32:59.606 A:middle
implicitly unwrapped Int and

00:32:59.606 --> 00:33:00.956 A:middle
then I could make an array of

00:32:59.606 --> 00:33:00.956 A:middle
then I could make an array of

00:33:01.016 --> 00:33:03.166 A:middle
this type alias and I would get

00:33:03.166 --> 00:33:04.756 A:middle
very confusing behavior from the

00:33:04.756 --> 00:33:06.296 A:middle
compiler that made code hard to

00:33:06.296 --> 00:33:06.906 A:middle
understand.

00:33:07.596 --> 00:33:09.516 A:middle
So in Swift 4.2 we've

00:33:09.516 --> 00:33:10.816 A:middle
re-implemented Implicitly

00:33:10.816 --> 00:33:12.556 A:middle
Unwrapped Optional so that it

00:33:12.666 --> 00:33:14.736 A:middle
exactly matches the mental model

00:33:14.736 --> 00:33:17.186 A:middle
I outlined earlier and this

00:33:17.386 --> 00:33:19.226 A:middle
confusing code example now

00:33:19.226 --> 00:33:20.986 A:middle
generates a compile time warning

00:33:21.306 --> 00:33:23.586 A:middle
and the compiler parses that as

00:33:23.946 --> 00:33:25.816 A:middle
if it was just a plain array of

00:33:25.816 --> 00:33:27.576 A:middle
integers, of optional integers.

00:33:28.546 --> 00:33:30.836 A:middle
Now, most code will not be

00:33:30.836 --> 00:33:32.266 A:middle
affected by this change to

00:33:32.266 --> 00:33:33.626 A:middle
Implicitly Unwrapped Optional,

00:33:34.036 --> 00:33:35.436 A:middle
but if you were accidentally

00:33:35.436 --> 00:33:37.426 A:middle
relying on these edge cases I

00:33:37.426 --> 00:33:38.696 A:middle
encourage you to check out this

00:33:38.746 --> 00:33:41.096 A:middle
blog post on Swift.org that goes

00:33:41.096 --> 00:33:42.486 A:middle
into a lot of detail and has a

00:33:42.486 --> 00:33:44.736 A:middle
lot of examples about what

00:33:44.736 --> 00:33:47.136 A:middle
changed and how.

00:33:47.376 --> 00:33:49.756 A:middle
OK, now there's only one more

00:33:49.756 --> 00:33:50.566 A:middle
thing here today.

00:33:50.986 --> 00:33:52.566 A:middle
Let's talk about memory

00:33:52.566 --> 00:33:53.866 A:middle
exclusivity checking.

00:33:55.196 --> 00:33:57.946 A:middle
So if you recall, in Swift 4 we

00:33:57.946 --> 00:33:59.896 A:middle
introduced something called

00:33:59.896 --> 00:34:01.386 A:middle
Memory Exclusivity Checking,

00:33:59.896 --> 00:34:01.386 A:middle
Memory Exclusivity Checking,

00:34:01.646 --> 00:34:02.896 A:middle
which was a combination of

00:34:02.956 --> 00:34:05.186 A:middle
compile time and runtime checks

00:34:05.436 --> 00:34:06.696 A:middle
that restricted certain

00:34:06.696 --> 00:34:08.856 A:middle
operations from being performed.

00:34:09.315 --> 00:34:10.976 A:middle
In particular we banned

00:34:11.286 --> 00:34:13.376 A:middle
overlapping access to the same

00:34:13.376 --> 00:34:14.356 A:middle
memory location.

00:34:14.856 --> 00:34:15.656 A:middle
What does this mean?

00:34:15.815 --> 00:34:17.096 A:middle
Well, let's look at an example.

00:34:17.666 --> 00:34:20.085 A:middle
So here's a piece of code that

00:34:20.085 --> 00:34:21.706 A:middle
implements a data type for

00:34:21.896 --> 00:34:23.246 A:middle
operating system paths.

00:34:23.766 --> 00:34:25.446 A:middle
And this is represented as an

00:34:25.565 --> 00:34:27.005 A:middle
array of path components.

00:34:27.576 --> 00:34:28.815 A:middle
And there's a withAppended

00:34:28.815 --> 00:34:29.206 A:middle
method.

00:34:30.216 --> 00:34:31.946 A:middle
This method adds an element to

00:34:31.946 --> 00:34:33.735 A:middle
the array, then in calls a

00:34:33.735 --> 00:34:35.806 A:middle
closure that you pass in and

00:34:35.806 --> 00:34:37.036 A:middle
then it removes that element

00:34:37.076 --> 00:34:37.626 A:middle
from the array.

00:34:38.295 --> 00:34:40.036 A:middle
And this code is totally fine,

00:34:40.036 --> 00:34:41.726 A:middle
it's a valid Swift 4 code.

00:34:42.755 --> 00:34:44.505 A:middle
But let's look at this usage of

00:34:44.505 --> 00:34:45.536 A:middle
our path data type.

00:34:46.545 --> 00:34:47.976 A:middle
So here I have a path that's

00:34:47.976 --> 00:34:49.746 A:middle
stored and a local variable and

00:34:50.056 --> 00:34:51.806 A:middle
then I call withAppended on it

00:34:52.295 --> 00:34:54.856 A:middle
and inside the closure I access

00:34:54.856 --> 00:34:56.306 A:middle
that local variable again

00:34:56.536 --> 00:34:57.056 A:middle
printing it.

00:34:57.556 --> 00:34:58.696 A:middle
So what the problem here?

00:34:59.436 --> 00:35:01.076 A:middle
Well, it turns out this code is

00:34:59.436 --> 00:35:01.076 A:middle
Well, it turns out this code is

00:35:01.076 --> 00:35:03.756 A:middle
actually ambiguous because when

00:35:03.756 --> 00:35:05.866 A:middle
I access that local variable

00:35:06.136 --> 00:35:08.436 A:middle
inside the closure, it's already

00:35:08.436 --> 00:35:10.086 A:middle
being modified by this

00:35:10.086 --> 00:35:11.686 A:middle
withAppended method, which is a

00:35:11.686 --> 00:35:12.586 A:middle
mutating method.

00:35:13.306 --> 00:35:16.136 A:middle
So the ambiguity is that do I

00:35:16.136 --> 00:35:18.466 A:middle
mean the original value of path

00:35:18.806 --> 00:35:20.556 A:middle
as it was before I called

00:35:20.556 --> 00:35:22.706 A:middle
withAppended or do I mean the

00:35:22.706 --> 00:35:24.106 A:middle
current value that is being

00:35:24.106 --> 00:35:25.926 A:middle
modified whatever that means.

00:35:26.756 --> 00:35:28.636 A:middle
Well, in Swift 4 this was a

00:35:28.636 --> 00:35:30.396 A:middle
compile time error because it

00:35:30.396 --> 00:35:32.226 A:middle
was an exclusivity violation.

00:35:32.756 --> 00:35:34.716 A:middle
And one way to address this is

00:35:34.716 --> 00:35:35.976 A:middle
to resolve the ambiguity by

00:35:35.976 --> 00:35:37.926 A:middle
telling the complier, hey I

00:35:37.926 --> 00:35:40.496 A:middle
really want the new value so I'm

00:35:40.496 --> 00:35:41.766 A:middle
going to just pass it in as a

00:35:41.766 --> 00:35:43.636 A:middle
parameter to the closure instead

00:35:43.636 --> 00:35:44.986 A:middle
of capturing it.

00:35:45.586 --> 00:35:47.366 A:middle
OK, but now look at this

00:35:47.366 --> 00:35:47.936 A:middle
example.

00:35:48.266 --> 00:35:49.586 A:middle
So this is almost the same

00:35:49.586 --> 00:35:51.376 A:middle
function except that it's

00:35:51.376 --> 00:35:53.326 A:middle
generic, it's prioritized by the

00:35:53.326 --> 00:35:54.646 A:middle
return type of the closure.

00:35:55.306 --> 00:35:57.436 A:middle
And in this case we can have the

00:35:57.436 --> 00:35:59.286 A:middle
same kind of ambiguity by

00:35:59.286 --> 00:36:01.246 A:middle
accessing the path value from

00:35:59.286 --> 00:36:01.246 A:middle
accessing the path value from

00:36:01.246 --> 00:36:02.166 A:middle
inside the closure.

00:36:02.496 --> 00:36:04.766 A:middle
But previously Swift 4 did not

00:36:04.766 --> 00:36:06.556 A:middle
catch this error at compile

00:36:06.616 --> 00:36:06.866 A:middle
time.

00:36:08.286 --> 00:36:10.436 A:middle
In Swift 4.2 we've improved the

00:36:10.436 --> 00:36:12.526 A:middle
static exclusivity checking to

00:36:12.526 --> 00:36:14.446 A:middle
catch ambiguities like this in

00:36:14.446 --> 00:36:15.256 A:middle
more cases.

00:36:16.386 --> 00:36:18.546 A:middle
And in addition to improving --

00:36:19.146 --> 00:36:20.526 A:middle
OK, and you can also fix the

00:36:20.526 --> 00:36:22.236 A:middle
ambiguity in the same way by

00:36:22.236 --> 00:36:23.566 A:middle
passing it as a parameter to the

00:36:23.566 --> 00:36:24.026 A:middle
closure.

00:36:24.576 --> 00:36:26.876 A:middle
In addition to improving the

00:36:26.876 --> 00:36:28.986 A:middle
static checks, we've also added

00:36:28.986 --> 00:36:30.796 A:middle
the ability to use the runtime

00:36:30.796 --> 00:36:32.456 A:middle
exclusivity checks and release

00:36:32.456 --> 00:36:32.906 A:middle
builds.

00:36:33.336 --> 00:36:35.166 A:middle
And this has some overhead but

00:36:35.166 --> 00:36:36.606 A:middle
if your app is not performance

00:36:36.606 --> 00:36:38.096 A:middle
critical, we encourage you to

00:36:38.096 --> 00:36:39.746 A:middle
try this out and leave it on all

00:36:39.746 --> 00:36:40.216 A:middle
the time.

00:36:40.686 --> 00:36:42.386 A:middle
In the future, we will get the

00:36:42.386 --> 00:36:44.236 A:middle
overhead of these dynamic checks

00:36:44.306 --> 00:36:46.276 A:middle
down to the point where we can

00:36:46.276 --> 00:36:48.126 A:middle
leave this enabled all the time

00:36:48.186 --> 00:36:49.226 A:middle
and it will give you an extra

00:36:49.226 --> 00:36:50.846 A:middle
level of protection just like

00:36:50.896 --> 00:36:53.296 A:middle
array bounce checking or integer

00:36:53.296 --> 00:36:54.596 A:middle
overflow checking today.

00:36:55.166 --> 00:36:58.316 A:middle
And there's a lot more in Swift

00:36:58.316 --> 00:37:00.426 A:middle
4.2 that I didn't talk about

00:36:58.316 --> 00:37:00.426 A:middle
4.2 that I didn't talk about

00:37:01.236 --> 00:37:01.576 A:middle
today.

00:37:02.096 --> 00:37:03.716 A:middle
And we encourage you to try it

00:37:03.716 --> 00:37:05.496 A:middle
out on your existing apps.

00:37:05.546 --> 00:37:06.776 A:middle
We also want you to try out the

00:37:06.776 --> 00:37:08.536 A:middle
new features and if you have any

00:37:08.536 --> 00:37:10.056 A:middle
questions please come to the

00:37:10.056 --> 00:37:11.966 A:middle
labs and ask us.

00:37:12.556 --> 00:37:12.956 A:middle
Thank you.

00:37:14.516 --> 00:37:19.500 A:middle
[ Applause ]
