WEBVTT

00:00:07.516 --> 00:00:16.500 A:middle
[ Music ]

00:00:18.516 --> 00:00:23.500 A:middle
[ Applause ]

00:00:24.106 --> 00:00:25.606 A:middle
&gt;&gt; Hello, everybody.

00:00:26.116 --> 00:00:27.516 A:middle
Welcome to Image and Graphics

00:00:27.556 --> 00:00:28.366 A:middle
Best Practices.

00:00:28.906 --> 00:00:29.626 A:middle
My name's Kyle.

00:00:29.896 --> 00:00:30.806 A:middle
I work on UIKit.

00:00:30.916 --> 00:00:32.235 A:middle
And today, I'm going to be

00:00:32.235 --> 00:00:33.796 A:middle
sharing with you some techniques

00:00:33.836 --> 00:00:35.066 A:middle
and some strategies for

00:00:35.066 --> 00:00:36.056 A:middle
efficiently working with

00:00:36.056 --> 00:00:37.866 A:middle
graphical content in your

00:00:37.866 --> 00:00:38.596 A:middle
applications.

00:00:39.156 --> 00:00:40.516 A:middle
We're going to take a tour of

00:00:40.516 --> 00:00:41.456 A:middle
the framework stack.

00:00:41.716 --> 00:00:43.146 A:middle
First, we're going to start with

00:00:43.146 --> 00:00:45.646 A:middle
UIImage and UIImageView, which

00:00:45.646 --> 00:00:48.146 A:middle
are UIKit's high level tools for

00:00:48.146 --> 00:00:49.446 A:middle
working with graphical content

00:00:49.446 --> 00:00:51.076 A:middle
in your app.

00:00:51.076 --> 00:00:52.316 A:middle
Then, we're going to focus on

00:00:52.726 --> 00:00:54.236 A:middle
how you can best do custom

00:00:54.236 --> 00:00:55.666 A:middle
drawing inside of your

00:00:55.666 --> 00:00:56.946 A:middle
applications with UIKit.

00:00:57.466 --> 00:00:58.996 A:middle
And finally, we're going to

00:00:58.996 --> 00:01:00.786 A:middle
touch, briefly, on integrating

00:00:58.996 --> 00:01:00.786 A:middle
touch, briefly, on integrating

00:01:00.786 --> 00:01:02.806 A:middle
advanced CPU and GPU

00:01:02.806 --> 00:01:04.516 A:middle
technologies into your

00:01:04.516 --> 00:01:05.296 A:middle
applications.

00:01:06.466 --> 00:01:07.626 A:middle
And throughout this talk we're

00:01:07.626 --> 00:01:09.336 A:middle
going to be focusing primarily

00:01:09.336 --> 00:01:11.706 A:middle
on our use of two scarce

00:01:11.706 --> 00:01:14.116 A:middle
resources on the device; memory

00:01:14.516 --> 00:01:15.336 A:middle
and CPU.

00:01:16.026 --> 00:01:17.216 A:middle
And we tend to think of these

00:01:17.216 --> 00:01:19.296 A:middle
things as separate quantities.

00:01:19.636 --> 00:01:20.716 A:middle
They have their own tracks in

00:01:20.716 --> 00:01:21.746 A:middle
the debug navigator.

00:01:22.116 --> 00:01:23.966 A:middle
They have their own instruments

00:01:23.966 --> 00:01:25.336 A:middle
in the instruments application.

00:01:25.886 --> 00:01:27.406 A:middle
But really, they're intricately

00:01:27.406 --> 00:01:27.786 A:middle
linked.

00:01:28.906 --> 00:01:31.736 A:middle
And it might be apparent that as

00:01:31.906 --> 00:01:34.206 A:middle
your application uses more CPU,

00:01:34.346 --> 00:01:36.406 A:middle
that has a negative impact on

00:01:36.406 --> 00:01:38.116 A:middle
the battery life and the

00:01:38.116 --> 00:01:39.076 A:middle
responsiveness of your

00:01:39.076 --> 00:01:39.706 A:middle
application.

00:01:39.986 --> 00:01:42.146 A:middle
But what might be less obvious

00:01:42.466 --> 00:01:44.876 A:middle
is that as your application and

00:01:44.876 --> 00:01:46.426 A:middle
other applications on the system

00:01:46.726 --> 00:01:49.306 A:middle
consume more memory, that also

00:01:49.306 --> 00:01:51.236 A:middle
causes more CPU utilization.

00:01:51.656 --> 00:01:52.966 A:middle
Which, has further detrimental

00:01:52.966 --> 00:01:55.046 A:middle
effects on battery life and

00:01:55.046 --> 00:01:55.546 A:middle
performance.

00:01:55.546 --> 00:01:57.216 A:middle
So, we're going to focus on how

00:01:57.216 --> 00:01:58.406 A:middle
to improve our use of these

00:01:58.406 --> 00:01:59.006 A:middle
resources.

00:01:59.876 --> 00:02:03.006 A:middle
What better context for

00:01:59.876 --> 00:02:03.006 A:middle
What better context for

00:02:03.006 --> 00:02:04.066 A:middle
discussing this problem than an

00:02:04.066 --> 00:02:05.956 A:middle
application that works pretty

00:02:05.956 --> 00:02:07.566 A:middle
extensively with photographic

00:02:07.566 --> 00:02:09.946 A:middle
content, like the Photos app?

00:02:10.186 --> 00:02:11.346 A:middle
You see, we're editing a photo

00:02:11.346 --> 00:02:11.636 A:middle
here.

00:02:11.916 --> 00:02:13.626 A:middle
And as I mentioned previously,

00:02:13.626 --> 00:02:16.256 A:middle
UIImages, UIKits, high level

00:02:16.386 --> 00:02:18.166 A:middle
class for dealing with image

00:02:18.166 --> 00:02:18.516 A:middle
data.

00:02:18.696 --> 00:02:19.936 A:middle
So, we have a UIImage

00:02:20.296 --> 00:02:22.436 A:middle
representing this rich content.

00:02:23.306 --> 00:02:24.986 A:middle
And we tend to divide graphical

00:02:24.986 --> 00:02:26.336 A:middle
content in our applications into

00:02:26.336 --> 00:02:28.166 A:middle
two categories; rich content

00:02:28.166 --> 00:02:29.686 A:middle
like this photograph and

00:02:29.686 --> 00:02:30.606 A:middle
iconography.

00:02:31.346 --> 00:02:33.726 A:middle
UIImage is also the data type in

00:02:33.726 --> 00:02:35.296 A:middle
UIKit that we use to represent

00:02:35.296 --> 00:02:37.186 A:middle
things like the icon displayed

00:02:37.186 --> 00:02:37.746 A:middle
in this button.

00:02:38.266 --> 00:02:41.616 A:middle
And as I mentioned previously,

00:02:42.356 --> 00:02:44.786 A:middle
UIImageView is the class that

00:02:44.786 --> 00:02:46.396 A:middle
UIKit provides for displaying a

00:02:46.396 --> 00:02:47.076 A:middle
UIImage.

00:02:47.386 --> 00:02:51.976 A:middle
Now, in classical MVC style

00:02:52.536 --> 00:02:54.356 A:middle
UIImage can be thought of as a

00:02:54.356 --> 00:02:55.106 A:middle
model object.

00:02:55.406 --> 00:02:57.146 A:middle
And UIImageView, of course, as

00:02:57.146 --> 00:02:58.586 A:middle
the name implies, is a view.

00:02:58.926 --> 00:03:01.286 A:middle
And these objects in their roles

00:02:58.926 --> 00:03:01.286 A:middle
And these objects in their roles

00:03:01.286 --> 00:03:02.726 A:middle
as model and view, have

00:03:02.726 --> 00:03:04.236 A:middle
traditional responsibilities.

00:03:04.926 --> 00:03:06.736 A:middle
UIImage is responsible for

00:03:06.736 --> 00:03:07.816 A:middle
loading image content.

00:03:08.016 --> 00:03:09.856 A:middle
And UIImageView is responsible

00:03:09.856 --> 00:03:11.586 A:middle
for displaying it, for rendering

00:03:12.976 --> 00:03:13.066 A:middle
it.

00:03:13.486 --> 00:03:14.336 A:middle
Now, we can think of this as a

00:03:14.336 --> 00:03:15.836 A:middle
simple relationship that we

00:03:15.836 --> 00:03:16.866 A:middle
establish once.

00:03:17.066 --> 00:03:18.336 A:middle
It's a one-way relationship.

00:03:19.176 --> 00:03:20.956 A:middle
Bu the actual story is a little

00:03:20.956 --> 00:03:21.896 A:middle
bit more complicated.

00:03:23.106 --> 00:03:25.146 A:middle
In addition to rendering being a

00:03:25.146 --> 00:03:26.476 A:middle
continuous process, rather than

00:03:26.476 --> 00:03:28.706 A:middle
a one-time event, there's this

00:03:28.706 --> 00:03:29.706 A:middle
hidden phase.

00:03:30.026 --> 00:03:31.786 A:middle
It's really important to

00:03:31.786 --> 00:03:33.096 A:middle
understand in order to measure

00:03:33.096 --> 00:03:33.826 A:middle
the performance of your

00:03:33.826 --> 00:03:34.416 A:middle
application.

00:03:34.516 --> 00:03:35.916 A:middle
And this phase is called

00:03:35.916 --> 00:03:36.476 A:middle
decoding.

00:03:37.816 --> 00:03:38.576 A:middle
But in order to discuss

00:03:38.606 --> 00:03:40.326 A:middle
decoding, I first need to

00:03:40.326 --> 00:03:41.646 A:middle
discuss a concept called a

00:03:41.646 --> 00:03:42.016 A:middle
buffer.

00:03:42.856 --> 00:03:44.976 A:middle
A buffer is just a contiguous

00:03:44.976 --> 00:03:45.866 A:middle
region of memory.

00:03:46.386 --> 00:03:47.476 A:middle
But we tend to use the term

00:03:47.476 --> 00:03:49.036 A:middle
buffer when we're discussing

00:03:49.036 --> 00:03:50.696 A:middle
memory that's composed of a

00:03:50.696 --> 00:03:53.196 A:middle
sequence of elements of the same

00:03:53.196 --> 00:03:55.286 A:middle
size, usually, of the same

00:03:55.286 --> 00:03:56.446 A:middle
internal construction.

00:03:57.506 --> 00:03:59.366 A:middle
And for our purposes, one really

00:03:59.366 --> 00:04:01.266 A:middle
important kind of buffer is an

00:03:59.366 --> 00:04:01.266 A:middle
important kind of buffer is an

00:04:01.266 --> 00:04:01.946 A:middle
image buffer.

00:04:02.156 --> 00:04:03.896 A:middle
This is a term we use for buffer

00:04:04.276 --> 00:04:05.486 A:middle
that holds the in-memory

00:04:05.486 --> 00:04:07.796 A:middle
representation of some image.

00:04:08.826 --> 00:04:10.136 A:middle
Each element of this buffer

00:04:10.596 --> 00:04:12.226 A:middle
describes the color and

00:04:12.226 --> 00:04:14.586 A:middle
transparency of a single pixel

00:04:15.136 --> 00:04:15.886 A:middle
in our image.

00:04:16.136 --> 00:04:19.476 A:middle
And consequently, the size of

00:04:19.476 --> 00:04:20.766 A:middle
this buffer in memory is

00:04:20.766 --> 00:04:22.706 A:middle
proportional to the size of the

00:04:22.756 --> 00:04:23.856 A:middle
image that it contains.

00:04:25.366 --> 00:04:26.856 A:middle
One particularly important

00:04:26.856 --> 00:04:29.636 A:middle
example of a buffer is called

00:04:29.636 --> 00:04:30.256 A:middle
the frame buffer.

00:04:31.186 --> 00:04:32.566 A:middle
And the frame buffer is what

00:04:32.566 --> 00:04:34.616 A:middle
holds the actual rendered output

00:04:34.776 --> 00:04:35.646 A:middle
of your application.

00:04:36.916 --> 00:04:38.516 A:middle
So, as your application updates

00:04:38.516 --> 00:04:41.186 A:middle
its view hierarchy UIKit will

00:04:41.186 --> 00:04:43.446 A:middle
render the application's window

00:04:43.446 --> 00:04:45.516 A:middle
and all of its subviews into the

00:04:45.516 --> 00:04:46.116 A:middle
frame buffer.

00:04:46.916 --> 00:04:48.556 A:middle
And that frame buffer provides

00:04:48.786 --> 00:04:50.806 A:middle
per pixel color information that

00:04:50.806 --> 00:04:52.786 A:middle
the display hardware will read

00:04:52.786 --> 00:04:53.856 A:middle
in order to illuminate the

00:04:53.856 --> 00:04:55.106 A:middle
pixels on the display.

00:04:58.246 --> 00:04:59.936 A:middle
Now, that last part happens at a

00:04:59.936 --> 00:05:00.616 A:middle
fixed interval.

00:04:59.936 --> 00:05:00.616 A:middle
fixed interval.

00:05:00.866 --> 00:05:03.376 A:middle
It can happen at 60 fps.

00:05:03.456 --> 00:05:05.836 A:middle
So, every 1/60th of a second.

00:05:05.836 --> 00:05:08.006 A:middle
Or on an iPad with ProMotion

00:05:08.006 --> 00:05:09.496 A:middle
Display, it can happen as fast

00:05:09.646 --> 00:05:11.936 A:middle
as every 1/120th of a second.

00:05:12.406 --> 00:05:15.156 A:middle
And if nothing's changed in your

00:05:15.156 --> 00:05:16.586 A:middle
application, the display

00:05:16.586 --> 00:05:17.976 A:middle
hardware will get the same data

00:05:17.976 --> 00:05:19.546 A:middle
back out of the frame buffer

00:05:19.786 --> 00:05:20.926 A:middle
that it saw, previously.

00:05:21.836 --> 00:05:25.326 A:middle
But as you change the content of

00:05:25.326 --> 00:05:26.456 A:middle
the views in your application,

00:05:26.456 --> 00:05:28.226 A:middle
for example, you assign a new

00:05:28.226 --> 00:05:29.906 A:middle
UIImage to our image view, here.

00:05:31.066 --> 00:05:32.826 A:middle
UIKit will re-render your

00:05:32.826 --> 00:05:34.366 A:middle
application's window into the

00:05:34.366 --> 00:05:34.986 A:middle
frame buffer.

00:05:34.986 --> 00:05:36.786 A:middle
And the next time the display

00:05:36.786 --> 00:05:37.926 A:middle
hardware pulls from the frame

00:05:37.926 --> 00:05:39.406 A:middle
buffer it'll get your new

00:05:39.406 --> 00:05:39.946 A:middle
content.

00:05:40.516 --> 00:05:43.036 A:middle
Now, you can contrast an image

00:05:43.036 --> 00:05:44.606 A:middle
buffer to another kind of

00:05:44.606 --> 00:05:46.376 A:middle
buffer, a data buffer, which is

00:05:46.376 --> 00:05:47.896 A:middle
just a buffer that contains a

00:05:47.896 --> 00:05:48.846 A:middle
sequence of bytes.

00:05:49.926 --> 00:05:51.116 A:middle
In our case, we're concerned

00:05:51.116 --> 00:05:53.026 A:middle
about data buffers that contain

00:05:53.356 --> 00:05:54.306 A:middle
image files.

00:05:54.646 --> 00:05:55.606 A:middle
Perhaps, we've downloaded them

00:05:55.606 --> 00:05:57.366 A:middle
from the network or we've loaded

00:05:57.366 --> 00:05:58.586 A:middle
them from disk.

00:05:59.356 --> 00:06:00.976 A:middle
A data buffer that contains an

00:05:59.356 --> 00:06:00.976 A:middle
A data buffer that contains an

00:06:00.976 --> 00:06:02.576 A:middle
image file, typically, begins

00:06:02.716 --> 00:06:04.496 A:middle
with some metadata describing

00:06:04.496 --> 00:06:05.586 A:middle
the size of the image that's

00:06:05.586 --> 00:06:06.746 A:middle
stored in that data buffer.

00:06:07.856 --> 00:06:09.066 A:middle
And then, contains the image

00:06:09.066 --> 00:06:11.086 A:middle
data itself, which is encoded in

00:06:11.086 --> 00:06:13.556 A:middle
some form like JPEG compression

00:06:13.636 --> 00:06:13.916 A:middle
or PNG.

00:06:13.916 --> 00:06:17.356 A:middle
Which means that the bytes

00:06:17.666 --> 00:06:19.026 A:middle
subsequent to that metadata

00:06:19.626 --> 00:06:20.876 A:middle
don't, actually, directly

00:06:20.876 --> 00:06:22.536 A:middle
describe anything about the

00:06:22.536 --> 00:06:26.686 A:middle
pixels in the image.

00:06:27.006 --> 00:06:28.856 A:middle
So, we can take a deeper look at

00:06:28.856 --> 00:06:30.576 A:middle
this pipeline that we've set up.

00:06:31.086 --> 00:06:32.866 A:middle
We have a UIImageView here and

00:06:32.866 --> 00:06:34.086 A:middle
we've highlighted the region of

00:06:34.086 --> 00:06:35.596 A:middle
the frame buffer that will be

00:06:35.996 --> 00:06:37.546 A:middle
populated by the image view's

00:06:37.546 --> 00:06:38.036 A:middle
rendering.

00:06:38.396 --> 00:06:40.156 A:middle
And we've assigned a UIImage to

00:06:40.156 --> 00:06:40.786 A:middle
this image view.

00:06:41.316 --> 00:06:43.486 A:middle
It's got a data buffer that

00:06:43.486 --> 00:06:44.916 A:middle
represents the content of an

00:06:44.916 --> 00:06:45.606 A:middle
image file.

00:06:45.606 --> 00:06:46.786 A:middle
Perhaps, downloaded from the

00:06:46.786 --> 00:06:48.306 A:middle
network or read from disk.

00:06:49.196 --> 00:06:50.326 A:middle
But we need to be able to

00:06:50.326 --> 00:06:52.886 A:middle
populate the frame buffer with

00:06:52.956 --> 00:06:54.146 A:middle
per pixel data.

00:06:55.436 --> 00:06:58.176 A:middle
So, in order to do that UIImage

00:06:58.256 --> 00:06:59.986 A:middle
will allocate an image buffer

00:07:00.606 --> 00:07:02.386 A:middle
whose size is equal to the size

00:07:02.386 --> 00:07:03.976 A:middle
of the image that is contained

00:07:03.976 --> 00:07:04.706 A:middle
in the data buffer.

00:07:04.746 --> 00:07:06.936 A:middle
And perform an operation called

00:07:06.936 --> 00:07:09.876 A:middle
decoding that will convert the

00:07:10.306 --> 00:07:12.396 A:middle
JPEG or PNG or other encoded

00:07:12.396 --> 00:07:15.776 A:middle
image data into per pixel image

00:07:15.806 --> 00:07:16.436 A:middle
information.

00:07:17.056 --> 00:07:18.436 A:middle
And then, depending on the

00:07:18.436 --> 00:07:19.876 A:middle
content mode of our image view.

00:07:20.766 --> 00:07:22.266 A:middle
When UIKit asks the image view

00:07:22.266 --> 00:07:25.546 A:middle
to render it will copy and scale

00:07:26.096 --> 00:07:27.626 A:middle
the image data from the image

00:07:27.626 --> 00:07:29.326 A:middle
buffer as it copies it into the

00:07:29.326 --> 00:07:29.896 A:middle
frame buffer.

00:07:30.396 --> 00:07:34.986 A:middle
Now, that decoding phase can be

00:07:35.096 --> 00:07:37.166 A:middle
CPU intensive, particularly, for

00:07:37.166 --> 00:07:37.976 A:middle
large images.

00:07:38.426 --> 00:07:40.316 A:middle
So, rather than do that work

00:07:40.316 --> 00:07:42.176 A:middle
every time UIKit asks the image

00:07:42.176 --> 00:07:44.726 A:middle
view to render, UIImage will

00:07:44.726 --> 00:07:46.606 A:middle
hang onto that image buffer, so

00:07:46.826 --> 00:07:48.056 A:middle
that it only does that work

00:07:48.056 --> 00:07:48.506 A:middle
once.

00:07:49.476 --> 00:07:51.096 A:middle
Consequently, your application,

00:07:51.456 --> 00:07:52.536 A:middle
for every image that gets

00:07:52.536 --> 00:07:54.556 A:middle
decoded, could have a persistent

00:07:54.556 --> 00:07:56.086 A:middle
and large memory allocation

00:07:56.086 --> 00:07:56.606 A:middle
hanging out.

00:07:57.416 --> 00:07:59.236 A:middle
And this allocation, as I

00:07:59.236 --> 00:08:00.446 A:middle
mentioned earlier, is

00:07:59.236 --> 00:08:00.446 A:middle
mentioned earlier, is

00:08:00.446 --> 00:08:01.956 A:middle
proportional to the size of the

00:08:02.036 --> 00:08:02.786 A:middle
input image.

00:08:03.116 --> 00:08:04.616 A:middle
Not necessarily, the size of the

00:08:04.616 --> 00:08:05.946 A:middle
image view that's actually

00:08:05.946 --> 00:08:07.006 A:middle
rendered in the frame buffer.

00:08:07.196 --> 00:08:09.196 A:middle
And this can have some pretty

00:08:09.196 --> 00:08:10.346 A:middle
negative consequences on

00:08:10.346 --> 00:08:11.026 A:middle
performance.

00:08:12.416 --> 00:08:14.806 A:middle
The large allocation that is in

00:08:14.806 --> 00:08:16.356 A:middle
your application's address space

00:08:16.706 --> 00:08:18.356 A:middle
could force other related

00:08:18.356 --> 00:08:20.896 A:middle
content apart from content that

00:08:20.896 --> 00:08:21.876 A:middle
it wants to reference.

00:08:21.916 --> 00:08:23.436 A:middle
This is called fragmentation.

00:08:25.596 --> 00:08:27.476 A:middle
Eventually, if your application

00:08:27.476 --> 00:08:29.116 A:middle
starts accumulating a lot of

00:08:29.116 --> 00:08:30.956 A:middle
memory usage the operating

00:08:30.956 --> 00:08:32.326 A:middle
system will step in and start

00:08:32.326 --> 00:08:34.006 A:middle
transparently compressing the

00:08:34.006 --> 00:08:35.586 A:middle
content of physical memory.

00:08:36.736 --> 00:08:38.126 A:middle
Now, the CPU needs to be

00:08:38.126 --> 00:08:39.946 A:middle
involved in this operation so in

00:08:39.946 --> 00:08:41.576 A:middle
addition to any CPU usage in

00:08:41.576 --> 00:08:42.936 A:middle
your own application.

00:08:43.356 --> 00:08:45.326 A:middle
You could be increasing global

00:08:45.326 --> 00:08:46.676 A:middle
CPU usage that you have no

00:08:46.676 --> 00:08:47.336 A:middle
control over.

00:08:48.986 --> 00:08:50.346 A:middle
Eventually, your application

00:08:50.626 --> 00:08:51.956 A:middle
could start consuming so much

00:08:51.956 --> 00:08:53.706 A:middle
physical memory that the OS

00:08:53.706 --> 00:08:55.036 A:middle
needs to start terminating

00:08:55.036 --> 00:08:55.816 A:middle
processes.

00:08:56.426 --> 00:08:57.756 A:middle
And it'll start with background

00:08:57.756 --> 00:08:59.186 A:middle
processes of low priority.

00:08:59.546 --> 00:09:01.676 A:middle
And, eventually, if your

00:08:59.546 --> 00:09:01.676 A:middle
And, eventually, if your

00:09:01.676 --> 00:09:02.776 A:middle
application consumes enough

00:09:02.776 --> 00:09:04.736 A:middle
memory, your application itself

00:09:04.736 --> 00:09:05.556 A:middle
could get terminated.

00:09:06.266 --> 00:09:07.306 A:middle
And some of those background

00:09:07.306 --> 00:09:08.536 A:middle
processes are doing important

00:09:08.536 --> 00:09:09.586 A:middle
work on behalf of the user.

00:09:09.906 --> 00:09:10.986 A:middle
So, they might get started up

00:09:10.986 --> 00:09:11.906 A:middle
again as soon as they get

00:09:11.906 --> 00:09:12.456 A:middle
terminated.

00:09:13.586 --> 00:09:15.086 A:middle
So, even though your application

00:09:15.396 --> 00:09:16.666 A:middle
might only be consuming memory

00:09:16.666 --> 00:09:18.546 A:middle
for a short period of time, it

00:09:18.546 --> 00:09:20.456 A:middle
can have this really long-tail

00:09:20.456 --> 00:09:22.996 A:middle
effect on CPU utilization.

00:09:24.106 --> 00:09:25.626 A:middle
So, we want to reduce the amount

00:09:25.626 --> 00:09:26.876 A:middle
of memory that our application

00:09:26.876 --> 00:09:27.436 A:middle
uses.

00:09:27.556 --> 00:09:28.596 A:middle
And we can get ahead of the

00:09:28.596 --> 00:09:30.406 A:middle
curve with a technique called

00:09:30.406 --> 00:09:31.146 A:middle
downsampling.

00:09:32.336 --> 00:09:34.236 A:middle
Now, here we see a little bit

00:09:34.416 --> 00:09:35.726 A:middle
more detail about our image

00:09:35.726 --> 00:09:36.606 A:middle
rendering pipeline.

00:09:37.006 --> 00:09:38.346 A:middle
Including the fact that the

00:09:38.346 --> 00:09:39.236 A:middle
image view we're going to

00:09:39.236 --> 00:09:41.206 A:middle
display our image in is actually

00:09:41.206 --> 00:09:42.906 A:middle
smaller than the image we're

00:09:42.906 --> 00:09:44.366 A:middle
going to display inside of it.

00:09:44.996 --> 00:09:47.096 A:middle
Normally, the core animation

00:09:47.376 --> 00:09:48.656 A:middle
framework would be responsible

00:09:48.656 --> 00:09:50.346 A:middle
for shrinking that image down

00:09:50.346 --> 00:09:52.326 A:middle
during the rendering phase, but

00:09:52.326 --> 00:09:54.226 A:middle
we can save some memory by using

00:09:54.226 --> 00:09:55.526 A:middle
this downsampling technique.

00:09:55.666 --> 00:09:56.906 A:middle
And what we're going to do,

00:09:56.906 --> 00:09:58.596 A:middle
essentially, is capture that

00:09:58.596 --> 00:10:01.106 A:middle
shrinking operation into an

00:09:58.596 --> 00:10:01.106 A:middle
shrinking operation into an

00:10:01.106 --> 00:10:02.166 A:middle
object called the thumbnail.

00:10:03.046 --> 00:10:04.986 A:middle
And we're going to wind up with

00:10:04.986 --> 00:10:08.486 A:middle
a lower total memory usage,

00:10:08.656 --> 00:10:09.586 A:middle
because we're going to have a

00:10:09.586 --> 00:10:11.166 A:middle
smaller decoded image buffer.

00:10:12.286 --> 00:10:14.596 A:middle
So, we set up an image source,

00:10:14.746 --> 00:10:16.656 A:middle
create a thumbnail, and then

00:10:16.656 --> 00:10:18.446 A:middle
capture that decoded image

00:10:18.446 --> 00:10:19.796 A:middle
buffer into UIImage.

00:10:19.946 --> 00:10:22.026 A:middle
And assign that UIImage to our

00:10:22.026 --> 00:10:22.476 A:middle
image view.

00:10:22.976 --> 00:10:24.606 A:middle
And then, we can discard the

00:10:24.606 --> 00:10:25.726 A:middle
original data buffer that

00:10:25.726 --> 00:10:26.646 A:middle
contained our image.

00:10:26.916 --> 00:10:28.176 A:middle
And we're left with a much

00:10:28.256 --> 00:10:29.726 A:middle
smaller long-term memory

00:10:29.726 --> 00:10:31.086 A:middle
footprint for our application.

00:10:31.646 --> 00:10:33.236 A:middle
The code to do that has a few

00:10:33.236 --> 00:10:33.546 A:middle
steps.

00:10:33.546 --> 00:10:34.636 A:middle
So, I'm going to walk you

00:10:34.636 --> 00:10:34.966 A:middle
through them.

00:10:34.966 --> 00:10:36.926 A:middle
I'm not going to do extremely

00:10:36.926 --> 00:10:37.896 A:middle
low-level detail.

00:10:37.896 --> 00:10:39.076 A:middle
But I'll highlight the important

00:10:39.076 --> 00:10:39.446 A:middle
bits.

00:10:40.316 --> 00:10:41.336 A:middle
First, we're going to create a

00:10:41.336 --> 00:10:42.556 A:middle
CGImageSource object.

00:10:43.206 --> 00:10:46.426 A:middle
And CGImageSourceCreate can take

00:10:46.426 --> 00:10:47.786 A:middle
an option dictionary.

00:10:47.786 --> 00:10:48.786 A:middle
And the important option we're

00:10:48.786 --> 00:10:50.346 A:middle
going to pass here, is this

00:10:50.466 --> 00:10:51.666 A:middle
ShouldCache flag.

00:10:52.076 --> 00:10:53.596 A:middle
And this tells the Core Graphics

00:10:53.596 --> 00:10:54.986 A:middle
framework that we're just

00:10:54.986 --> 00:10:56.696 A:middle
creating an object to represent

00:10:57.386 --> 00:10:59.276 A:middle
the information stored in the

00:10:59.276 --> 00:11:00.366 A:middle
file at this URL.

00:10:59.276 --> 00:11:00.366 A:middle
file at this URL.

00:11:01.746 --> 00:11:03.546 A:middle
Don't go ahead and decode this

00:11:03.546 --> 00:11:04.476 A:middle
image immediately.

00:11:04.586 --> 00:11:05.716 A:middle
Just create an object that

00:11:05.716 --> 00:11:06.236 A:middle
represents.

00:11:06.236 --> 00:11:07.676 A:middle
We're going to need information

00:11:07.676 --> 00:11:08.636 A:middle
from this URL.

00:11:09.146 --> 00:11:12.336 A:middle
Then, we're going to calculate

00:11:12.916 --> 00:11:14.076 A:middle
on the horizontal and vertical

00:11:14.076 --> 00:11:14.676 A:middle
axis.

00:11:14.976 --> 00:11:16.166 A:middle
Based on the scale that we're

00:11:16.166 --> 00:11:18.116 A:middle
going and point size we're going

00:11:18.116 --> 00:11:20.356 A:middle
to render at, which is the

00:11:20.356 --> 00:11:21.756 A:middle
larger dimension in pixels.

00:11:22.656 --> 00:11:24.806 A:middle
Calculate that information, and

00:11:24.806 --> 00:11:25.706 A:middle
then create an options

00:11:25.706 --> 00:11:27.386 A:middle
dictionary for our thumbnail.

00:11:28.286 --> 00:11:29.186 A:middle
There are a couple of options

00:11:29.186 --> 00:11:29.806 A:middle
listed here.

00:11:30.116 --> 00:11:30.646 A:middle
You can look in the

00:11:30.646 --> 00:11:32.246 A:middle
documentation for exactly what

00:11:32.246 --> 00:11:32.886 A:middle
these options do.

00:11:32.886 --> 00:11:34.856 A:middle
But the very important one is

00:11:34.856 --> 00:11:37.026 A:middle
this CacheImmediately option.

00:11:37.546 --> 00:11:39.936 A:middle
By passing this option here,

00:11:40.246 --> 00:11:41.946 A:middle
we're telling Core Graphics that

00:11:42.126 --> 00:11:43.456 A:middle
when I ask you to create the

00:11:43.456 --> 00:11:45.376 A:middle
thumbnail that's the exact

00:11:45.376 --> 00:11:47.126 A:middle
moment you should create the

00:11:47.126 --> 00:11:48.446 A:middle
decoded image buffer for me.

00:11:49.626 --> 00:11:51.186 A:middle
So, we have exact control over

00:11:51.186 --> 00:11:52.616 A:middle
when we take that CPU hit for

00:11:52.616 --> 00:11:53.076 A:middle
decoding.

00:11:55.516 --> 00:11:57.746 A:middle
Then, we create the thumbnail,

00:11:57.746 --> 00:11:59.856 A:middle
which is a CGImage, that we get

00:11:59.856 --> 00:12:00.166 A:middle
back.

00:11:59.856 --> 00:12:00.166 A:middle
back.

00:12:00.716 --> 00:12:01.886 A:middle
Wrap that in the UIImage and

00:12:01.886 --> 00:12:02.806 A:middle
return it from our helper

00:12:02.806 --> 00:12:03.656 A:middle
function that we've written

00:12:03.656 --> 00:12:03.826 A:middle
here.

00:12:04.366 --> 00:12:06.866 A:middle
So, to give you an idea of the

00:12:06.866 --> 00:12:08.346 A:middle
magnitude of savings that this

00:12:08.346 --> 00:12:10.086 A:middle
technique gives us, we're just

00:12:10.086 --> 00:12:11.216 A:middle
displaying the full screen image

00:12:11.216 --> 00:12:11.386 A:middle
here.

00:12:11.846 --> 00:12:12.586 A:middle
This is a photograph.

00:12:12.586 --> 00:12:14.286 A:middle
It's 3,000 by 2,000 pixels.

00:12:14.626 --> 00:12:16.136 A:middle
If we do no optimization, just

00:12:16.136 --> 00:12:17.536 A:middle
throw UIImageView in the

00:12:17.536 --> 00:12:19.216 A:middle
storyboard and assign our image

00:12:19.216 --> 00:12:20.996 A:middle
to it, this application takes

00:12:20.996 --> 00:12:23.606 A:middle
31.5 megabytes just sitting

00:12:23.606 --> 00:12:24.116 A:middle
doing nothing.

00:12:24.116 --> 00:12:27.006 A:middle
Now, using this downsampling

00:12:27.006 --> 00:12:29.266 A:middle
technique and only producing an

00:12:29.266 --> 00:12:30.406 A:middle
image buffer that's the size of

00:12:30.406 --> 00:12:32.616 A:middle
the actual display, we can get

00:12:32.616 --> 00:12:33.526 A:middle
the memory usage of this

00:12:33.526 --> 00:12:35.816 A:middle
application down to 18.4

00:12:35.816 --> 00:12:36.376 A:middle
megabytes.

00:12:36.536 --> 00:12:38.786 A:middle
And that is a huge reduction in

00:12:38.786 --> 00:12:39.486 A:middle
memory usage.

00:12:41.508 --> 00:12:43.508 A:middle
[ Applause ]

00:12:44.366 --> 00:12:45.846 A:middle
Thanks for the applause, but you

00:12:45.846 --> 00:12:46.806 A:middle
should all get the applause for

00:12:46.806 --> 00:12:47.666 A:middle
implementing this technique in

00:12:47.666 --> 00:12:48.336 A:middle
your applications.

00:12:48.966 --> 00:12:51.336 A:middle
You can imagine how much of a

00:12:51.336 --> 00:12:52.856 A:middle
big deal this is for an app

00:12:52.856 --> 00:12:54.276 A:middle
that's displaying a lot of

00:12:54.276 --> 00:12:56.286 A:middle
potentially large input images

00:12:56.866 --> 00:12:58.726 A:middle
in a small space on screen.

00:12:59.446 --> 00:13:02.606 A:middle
For example, the Camera Roll.

00:12:59.446 --> 00:13:02.606 A:middle
For example, the Camera Roll.

00:13:02.666 --> 00:13:03.936 A:middle
You might implement such a view

00:13:04.136 --> 00:13:05.326 A:middle
using UICollectionView.

00:13:05.576 --> 00:13:06.986 A:middle
So, here we've implemented cell

00:13:06.986 --> 00:13:08.326 A:middle
for item at indexPath.

00:13:08.396 --> 00:13:10.426 A:middle
And we're using our helper

00:13:10.506 --> 00:13:11.666 A:middle
function that we wrote earlier

00:13:11.946 --> 00:13:13.916 A:middle
to downsample the images to the

00:13:13.916 --> 00:13:14.826 A:middle
size that they're going to be

00:13:14.826 --> 00:13:16.676 A:middle
displayed at when the cell is

00:13:16.676 --> 00:13:18.126 A:middle
actually put on the screen.

00:13:19.416 --> 00:13:21.376 A:middle
So, you think this is a pretty

00:13:21.376 --> 00:13:22.196 A:middle
good thing to do, right?

00:13:22.196 --> 00:13:23.736 A:middle
Like rather than having these

00:13:23.736 --> 00:13:24.856 A:middle
large allocations hanging

00:13:24.856 --> 00:13:26.056 A:middle
around, we're reducing our

00:13:26.056 --> 00:13:26.846 A:middle
memory usage.

00:13:27.416 --> 00:13:29.306 A:middle
Unfortunately, that doesn't save

00:13:29.306 --> 00:13:30.776 A:middle
us from another problem that's

00:13:30.776 --> 00:13:32.846 A:middle
common in scrollable views like

00:13:32.846 --> 00:13:33.986 A:middle
table views and collection

00:13:33.986 --> 00:13:34.206 A:middle
views.

00:13:35.196 --> 00:13:36.836 A:middle
It's a, probably seen this

00:13:36.836 --> 00:13:37.176 A:middle
before.

00:13:37.176 --> 00:13:37.706 A:middle
You scroll through an

00:13:37.706 --> 00:13:39.246 A:middle
application and it starts

00:13:39.246 --> 00:13:40.606 A:middle
hitching as you scroll.

00:13:41.186 --> 00:13:44.276 A:middle
What's happening here is that as

00:13:44.276 --> 00:13:46.726 A:middle
we're scrolling the CPU is

00:13:46.726 --> 00:13:49.546 A:middle
relatively idle, or the work

00:13:49.546 --> 00:13:50.996 A:middle
that it does can be done before

00:13:50.996 --> 00:13:52.376 A:middle
the display hardware needs the

00:13:52.376 --> 00:13:54.716 A:middle
next copy of the frame buffer.

00:13:55.576 --> 00:13:57.886 A:middle
So, we see fluid motion as the

00:13:58.196 --> 00:13:59.786 A:middle
frame buffer is updated and the

00:13:59.786 --> 00:14:00.986 A:middle
display hardware is able to get

00:13:59.786 --> 00:14:00.986 A:middle
display hardware is able to get

00:14:00.986 --> 00:14:02.256 A:middle
the new frame on time.

00:14:03.146 --> 00:14:04.776 A:middle
But now, we're about to display

00:14:04.776 --> 00:14:05.776 A:middle
another row of images.

00:14:06.116 --> 00:14:07.636 A:middle
And we're about to ask Core

00:14:07.636 --> 00:14:09.476 A:middle
Graphics to decode those images

00:14:10.386 --> 00:14:11.646 A:middle
before we hand the cells back to

00:14:11.646 --> 00:14:12.466 A:middle
UICollectionView.

00:14:13.096 --> 00:14:14.896 A:middle
And that could take a lot of CPU

00:14:14.896 --> 00:14:15.236 A:middle
time.

00:14:16.346 --> 00:14:17.456 A:middle
So much so, that we don't get

00:14:17.456 --> 00:14:19.396 A:middle
around to re-rendering the frame

00:14:19.396 --> 00:14:19.736 A:middle
buffer.

00:14:20.716 --> 00:14:21.726 A:middle
But the display hardware is

00:14:21.726 --> 00:14:22.906 A:middle
operating on a fixed interval.

00:14:23.846 --> 00:14:25.546 A:middle
So, from the user's perspective

00:14:26.036 --> 00:14:27.436 A:middle
the application has just

00:14:28.976 --> 00:14:29.216 A:middle
stuttered.

00:14:29.306 --> 00:14:30.366 A:middle
Now, we're done decoding these

00:14:30.366 --> 00:14:31.466 A:middle
images, we're able to provide

00:14:31.466 --> 00:14:32.436 A:middle
those cells back to

00:14:32.656 --> 00:14:33.656 A:middle
UICollectionView.

00:14:34.006 --> 00:14:36.316 A:middle
And animation continues on, as

00:14:36.316 --> 00:14:36.766 A:middle
before.

00:14:37.856 --> 00:14:39.126 A:middle
Just saw a visual hitch, there.

00:14:40.486 --> 00:14:42.196 A:middle
Now, in addition to the obvious

00:14:42.196 --> 00:14:44.386 A:middle
responsiveness consequences of

00:14:44.386 --> 00:14:46.766 A:middle
this behavior, there's a more

00:14:46.766 --> 00:14:48.846 A:middle
subtle detrimental effect on

00:14:48.846 --> 00:14:49.706 A:middle
battery life.

00:14:50.366 --> 00:14:52.026 A:middle
Because iOS is very good at

00:14:52.026 --> 00:14:54.246 A:middle
managing the power demand on the

00:14:54.246 --> 00:14:56.966 A:middle
batter when there is a smooth

00:14:57.006 --> 00:14:59.316 A:middle
constant demand on the CPUs.

00:14:59.646 --> 00:15:00.876 A:middle
And what we have here are

00:14:59.646 --> 00:15:00.876 A:middle
And what we have here are

00:15:00.876 --> 00:15:01.596 A:middle
spikes.

00:15:01.596 --> 00:15:03.486 A:middle
As new rows are about to come

00:15:03.486 --> 00:15:04.906 A:middle
into view on the scroll view,

00:15:05.966 --> 00:15:07.886 A:middle
we're spiking the CPU usage.

00:15:08.046 --> 00:15:09.566 A:middle
And then, returning back down to

00:15:09.566 --> 00:15:10.316 A:middle
a low level.

00:15:10.746 --> 00:15:13.456 A:middle
So, there are two techniques we

00:15:13.456 --> 00:15:16.336 A:middle
can use to smooth out our CPU

00:15:16.396 --> 00:15:16.806 A:middle
usage.

00:15:17.566 --> 00:15:18.846 A:middle
The first one is prefetching.

00:15:19.766 --> 00:15:21.876 A:middle
And if you want to know a whole

00:15:21.876 --> 00:15:24.036 A:middle
lot about prefetching check out

00:15:24.146 --> 00:15:25.096 A:middle
the A Tour of CollectionView

00:15:25.096 --> 00:15:26.856 A:middle
Talk from this year's WWDC.

00:15:27.466 --> 00:15:29.096 A:middle
But the general ideas here, is

00:15:29.096 --> 00:15:30.856 A:middle
that prefetching allows

00:15:30.856 --> 00:15:32.396 A:middle
CollectionView to inform our

00:15:32.396 --> 00:15:34.616 A:middle
data source that it doesn't need

00:15:34.616 --> 00:15:36.726 A:middle
a cell right now, but it will in

00:15:36.726 --> 00:15:37.696 A:middle
the very near future.

00:15:37.976 --> 00:15:39.106 A:middle
So, if you have any work to do,

00:15:39.416 --> 00:15:40.556 A:middle
maybe, you can get a head start.

00:15:40.976 --> 00:15:42.836 A:middle
That allows us spread out CPU

00:15:42.836 --> 00:15:44.006 A:middle
usage out over time.

00:15:45.276 --> 00:15:46.476 A:middle
So, we've reduced the maximum

00:15:46.476 --> 00:15:47.836 A:middle
size of the CPU usage.

00:15:48.236 --> 00:15:51.436 A:middle
Another technique we can use is

00:15:51.436 --> 00:15:52.106 A:middle
performing work in the

00:15:52.106 --> 00:15:52.646 A:middle
background.

00:15:53.286 --> 00:15:54.156 A:middle
So, now that we've spread out

00:15:54.156 --> 00:15:55.686 A:middle
work over time we can, also,

00:15:55.686 --> 00:15:57.206 A:middle
spread it out over available

00:15:57.206 --> 00:15:57.786 A:middle
CPUs.

00:15:58.296 --> 00:16:03.076 A:middle
The consequences of this are

00:15:58.296 --> 00:16:03.076 A:middle
The consequences of this are

00:16:03.076 --> 00:16:04.526 A:middle
that your application is more

00:16:04.526 --> 00:16:07.056 A:middle
responsive and the device has a

00:16:07.056 --> 00:16:07.956 A:middle
longer battery life.

00:16:08.466 --> 00:16:10.816 A:middle
So, to put this in action here,

00:16:11.476 --> 00:16:13.626 A:middle
we've got a implementation of

00:16:13.626 --> 00:16:15.086 A:middle
the prefetch method on our data

00:16:15.086 --> 00:16:15.516 A:middle
source.

00:16:16.496 --> 00:16:17.436 A:middle
And it's going to call our

00:16:17.436 --> 00:16:19.726 A:middle
helper function to produce a

00:16:19.986 --> 00:16:23.086 A:middle
downsampled version of the image

00:16:23.086 --> 00:16:24.096 A:middle
that we're about to display in

00:16:24.096 --> 00:16:25.396 A:middle
this CollectionView cell.

00:16:25.826 --> 00:16:28.926 A:middle
And it does this by dispatching

00:16:28.926 --> 00:16:30.916 A:middle
work to one of the global

00:16:30.916 --> 00:16:31.856 A:middle
asynchronous queues.

00:16:33.706 --> 00:16:34.006 A:middle
Great.

00:16:34.006 --> 00:16:34.716 A:middle
Our work is happening in the

00:16:34.716 --> 00:16:35.166 A:middle
background.

00:16:35.266 --> 00:16:36.466 A:middle
This is what we wanted to do.

00:16:37.506 --> 00:16:39.786 A:middle
But there is a potential flaw

00:16:39.786 --> 00:16:40.056 A:middle
here.

00:16:40.516 --> 00:16:42.486 A:middle
And it's a phenomenon that we

00:16:42.486 --> 00:16:43.616 A:middle
like to call thread explosion.

00:16:44.296 --> 00:16:46.046 A:middle
And this is what happens when we

00:16:46.046 --> 00:16:47.656 A:middle
ask the system to do more work

00:16:47.886 --> 00:16:50.486 A:middle
than there are CPUs available to

00:16:50.846 --> 00:16:51.376 A:middle
do it.

00:16:51.436 --> 00:16:52.326 A:middle
If we're going to display a

00:16:52.326 --> 00:16:54.246 A:middle
whole number of images, like 6-8

00:16:54.246 --> 00:16:55.836 A:middle
images at a time, but we're

00:16:55.836 --> 00:16:56.956 A:middle
running on a device that only

00:16:57.016 --> 00:16:59.746 A:middle
has 2 CPUs, we can't do all of

00:16:59.746 --> 00:17:00.966 A:middle
that work at once.

00:16:59.746 --> 00:17:00.966 A:middle
that work at once.

00:17:00.966 --> 00:17:02.396 A:middle
We can't parallelize over CPUs

00:17:02.396 --> 00:17:03.346 A:middle
that don't exist.

00:17:03.906 --> 00:17:07.445 A:middle
Now, to avoid deadlock when we

00:17:07.445 --> 00:17:08.896 A:middle
dispatch asynchronously to a

00:17:08.896 --> 00:17:11.556 A:middle
global queue, GCD is going to

00:17:11.556 --> 00:17:14.016 A:middle
create new threads to capture

00:17:14.016 --> 00:17:15.215 A:middle
the work we're asking it to do.

00:17:15.215 --> 00:17:17.046 A:middle
And then, the CPUs are going to

00:17:17.046 --> 00:17:18.915 A:middle
spend a lot of time moving

00:17:18.915 --> 00:17:20.726 A:middle
between those threads to try and

00:17:20.726 --> 00:17:22.886 A:middle
make incremental progress on all

00:17:22.886 --> 00:17:23.856 A:middle
of the work we asked the

00:17:23.856 --> 00:17:25.175 A:middle
operating system to do for us.

00:17:25.506 --> 00:17:26.695 A:middle
And switching between those

00:17:26.695 --> 00:17:28.086 A:middle
threads, actually, has a pretty

00:17:28.086 --> 00:17:28.966 A:middle
significant overhead.

00:17:29.456 --> 00:17:33.796 A:middle
We'd do a lot better if one or

00:17:33.796 --> 00:17:35.146 A:middle
more of the CPUs just got a

00:17:35.146 --> 00:17:37.606 A:middle
chance to get images out the

00:17:37.606 --> 00:17:38.066 A:middle
door.

00:17:39.196 --> 00:17:39.906 A:middle
So, we're going to borrow a

00:17:39.906 --> 00:17:42.446 A:middle
technique that was presented

00:17:42.446 --> 00:17:44.556 A:middle
last year in the Modernizing

00:17:44.556 --> 00:17:45.856 A:middle
Grand Central Dispatch Usage

00:17:45.856 --> 00:17:46.216 A:middle
talk.

00:17:46.326 --> 00:17:47.586 A:middle
And we're going to synchronize

00:17:47.586 --> 00:17:48.526 A:middle
some work, or I'm sorry.

00:17:48.526 --> 00:17:49.396 A:middle
Not synchronize, we're going to

00:17:49.396 --> 00:17:51.326 A:middle
serialize some work.

00:17:52.456 --> 00:17:54.746 A:middle
So, rather than simply

00:17:54.746 --> 00:17:55.936 A:middle
dispatching work to one of the

00:17:55.936 --> 00:17:57.176 A:middle
global asynchronous queues,

00:17:58.146 --> 00:17:59.526 A:middle
we're going to create a serial

00:17:59.526 --> 00:17:59.826 A:middle
queue.

00:18:01.166 --> 00:18:02.646 A:middle
And inside of our implementation

00:18:02.696 --> 00:18:05.436 A:middle
of the prefetch method we're

00:18:05.436 --> 00:18:06.906 A:middle
going to asynchronously dispatch

00:18:06.906 --> 00:18:07.416 A:middle
to that queue.

00:18:07.416 --> 00:18:09.216 A:middle
Now, it does mean that an

00:18:09.216 --> 00:18:10.876 A:middle
individual image might not start

00:18:10.876 --> 00:18:12.316 A:middle
making progress until later than

00:18:12.316 --> 00:18:12.776 A:middle
before.

00:18:13.576 --> 00:18:15.006 A:middle
But it also means that the CPU

00:18:15.006 --> 00:18:16.356 A:middle
is going to spend less time

00:18:17.086 --> 00:18:18.506 A:middle
switching between bits of work

00:18:18.506 --> 00:18:21.356 A:middle
that it can do.

00:18:21.496 --> 00:18:22.376 A:middle
Now, these images that we're

00:18:22.376 --> 00:18:23.316 A:middle
displaying can come from a

00:18:23.316 --> 00:18:24.326 A:middle
number of places.

00:18:25.086 --> 00:18:26.416 A:middle
They might come with our

00:18:26.416 --> 00:18:28.706 A:middle
application, in which case they

00:18:28.706 --> 00:18:29.686 A:middle
might be stored in an image

00:18:29.686 --> 00:18:30.126 A:middle
asset.

00:18:30.566 --> 00:18:31.456 A:middle
Or they might be stored in a

00:18:31.456 --> 00:18:32.776 A:middle
file instead of our application

00:18:32.776 --> 00:18:33.146 A:middle
wrapper.

00:18:33.746 --> 00:18:34.696 A:middle
Or they could come from the

00:18:34.696 --> 00:18:35.146 A:middle
network.

00:18:35.936 --> 00:18:37.586 A:middle
Or they could be in a document

00:18:37.766 --> 00:18:39.436 A:middle
that's stored in the application

00:18:39.486 --> 00:18:40.446 A:middle
documents directory.

00:18:40.726 --> 00:18:42.646 A:middle
They could be stored in a cache.

00:18:43.666 --> 00:18:45.086 A:middle
But for artwork that comes with

00:18:45.086 --> 00:18:47.506 A:middle
your application, we strongly

00:18:47.506 --> 00:18:49.416 A:middle
encourage you to use image

00:18:49.416 --> 00:18:49.986 A:middle
assets.

00:18:50.916 --> 00:18:52.016 A:middle
And there are a number of

00:18:52.016 --> 00:18:52.736 A:middle
reasons why.

00:18:54.526 --> 00:18:56.436 A:middle
Image assets are optimized for

00:18:56.436 --> 00:18:57.836 A:middle
name based and trait-based

00:18:57.836 --> 00:18:58.226 A:middle
lookup.

00:18:58.606 --> 00:19:00.006 A:middle
It's faster to look up an image

00:18:58.606 --> 00:19:00.006 A:middle
It's faster to look up an image

00:19:00.006 --> 00:19:01.756 A:middle
asset in the asset catalog, than

00:19:01.756 --> 00:19:03.146 A:middle
it is to search for files on

00:19:03.146 --> 00:19:04.286 A:middle
disk that have a certain naming

00:19:04.286 --> 00:19:04.636 A:middle
scheme.

00:19:05.096 --> 00:19:08.246 A:middle
The asset catalog runtime has,

00:19:08.246 --> 00:19:10.046 A:middle
also, got some really good

00:19:10.046 --> 00:19:11.556 A:middle
smarts in it for managing buffer

00:19:11.556 --> 00:19:12.096 A:middle
sizes.

00:19:12.386 --> 00:19:14.566 A:middle
And there are, also, some

00:19:14.566 --> 00:19:16.026 A:middle
features unrelated to runtime

00:19:16.026 --> 00:19:17.876 A:middle
performance that are exclusive

00:19:17.876 --> 00:19:18.766 A:middle
to image assets.

00:19:19.086 --> 00:19:20.326 A:middle
Including features like per

00:19:20.326 --> 00:19:21.776 A:middle
device thinning, which mean that

00:19:21.776 --> 00:19:23.306 A:middle
your application only downloads

00:19:23.616 --> 00:19:24.626 A:middle
image resources that are

00:19:24.626 --> 00:19:25.876 A:middle
relevant to the device that it's

00:19:25.876 --> 00:19:27.886 A:middle
going to run on and vector

00:19:27.886 --> 00:19:28.396 A:middle
artwork.

00:19:30.416 --> 00:19:32.076 A:middle
The vector artwork was a feature

00:19:32.076 --> 00:19:33.546 A:middle
that was introduced in iOS 11.

00:19:33.616 --> 00:19:34.876 A:middle
And you enable it by checking

00:19:34.876 --> 00:19:36.196 A:middle
the Preserve Vector Data

00:19:36.616 --> 00:19:38.576 A:middle
checkbox in the editor for your

00:19:38.576 --> 00:19:39.246 A:middle
image asset.

00:19:39.246 --> 00:19:41.896 A:middle
And the upshot of this is that

00:19:42.046 --> 00:19:43.496 A:middle
if your image gets rendered in

00:19:43.496 --> 00:19:45.236 A:middle
an image view that is larger or

00:19:45.236 --> 00:19:46.476 A:middle
smaller than the native size of

00:19:46.476 --> 00:19:48.266 A:middle
the image it doesn't get blurry.

00:19:49.376 --> 00:19:50.456 A:middle
The image is, actually,

00:19:50.456 --> 00:19:51.966 A:middle
re-rasterized from the vector

00:19:51.966 --> 00:19:53.586 A:middle
artwork so that it has nice

00:19:53.586 --> 00:19:54.416 A:middle
crisp edges.

00:19:55.686 --> 00:19:57.076 A:middle
One place that we use this in

00:19:57.076 --> 00:19:57.956 A:middle
the operating system.

00:19:58.266 --> 00:20:00.386 A:middle
If you turn on dynamic type to a

00:19:58.266 --> 00:20:00.386 A:middle
If you turn on dynamic type to a

00:20:00.386 --> 00:20:01.956 A:middle
very large size in the

00:20:01.956 --> 00:20:02.976 A:middle
Accessibility settings.

00:20:03.246 --> 00:20:05.596 A:middle
And then you tap and hold on an

00:20:05.596 --> 00:20:07.606 A:middle
item in the tab bar a little HUD

00:20:07.606 --> 00:20:10.286 A:middle
shows up as a magnified view of

00:20:10.286 --> 00:20:11.886 A:middle
the item that you're currently

00:20:11.886 --> 00:20:12.786 A:middle
holding your finger over.

00:20:14.086 --> 00:20:16.056 A:middle
So, if you want your artwork to

00:20:16.056 --> 00:20:18.086 A:middle
look good in places like this

00:20:18.756 --> 00:20:19.856 A:middle
check the Preserve Vector

00:20:19.856 --> 00:20:21.716 A:middle
Artwork checkbox in.

00:20:21.716 --> 00:20:22.056 A:middle
I'm sorry.

00:20:22.056 --> 00:20:22.866 A:middle
The Preserve Vector Data

00:20:22.866 --> 00:20:24.846 A:middle
checkbox in the image asset

00:20:25.326 --> 00:20:25.886 A:middle
inspector.

00:20:26.536 --> 00:20:27.786 A:middle
Now, the way this works is very

00:20:27.786 --> 00:20:29.486 A:middle
similar to the pipeline we saw

00:20:29.486 --> 00:20:29.936 A:middle
before.

00:20:29.936 --> 00:20:32.726 A:middle
Rather than a decode phase, we

00:20:32.726 --> 00:20:34.686 A:middle
have a rasterize phase that's

00:20:34.686 --> 00:20:35.796 A:middle
responsible for taking the

00:20:35.796 --> 00:20:38.586 A:middle
vector data and turning it into

00:20:38.586 --> 00:20:39.976 A:middle
bitmap data that can be copied

00:20:39.976 --> 00:20:40.786 A:middle
to the frame buffer.

00:20:45.046 --> 00:20:46.036 A:middle
Now, if we had to do this for

00:20:46.036 --> 00:20:47.026 A:middle
all of the vector artwork in

00:20:47.026 --> 00:20:48.786 A:middle
your application we would be

00:20:49.046 --> 00:20:50.586 A:middle
consuming a lot more CPU.

00:20:50.856 --> 00:20:52.006 A:middle
So, there's an optimization we

00:20:52.006 --> 00:20:52.476 A:middle
make here.

00:20:53.156 --> 00:20:55.096 A:middle
If you have an image that has

00:20:55.096 --> 00:20:56.456 A:middle
Preserve Vector Data checked,

00:20:57.266 --> 00:20:58.906 A:middle
but you render it at the normal

00:20:58.906 --> 00:20:59.386 A:middle
size.

00:20:59.386 --> 00:21:02.686 A:middle
The asset catalog compiler has,

00:20:59.386 --> 00:21:02.686 A:middle
The asset catalog compiler has,

00:21:02.686 --> 00:21:05.266 A:middle
actually, already produced a

00:21:05.266 --> 00:21:06.906 A:middle
pre-rasterized version of that

00:21:06.906 --> 00:21:08.396 A:middle
image and stored it in the asset

00:21:08.396 --> 00:21:08.936 A:middle
catalog.

00:21:09.426 --> 00:21:10.766 A:middle
So, rather than doing the

00:21:10.766 --> 00:21:12.926 A:middle
complicated math of rasterizing

00:21:12.926 --> 00:21:14.156 A:middle
your vector artwork into a

00:21:14.156 --> 00:21:17.026 A:middle
bitmap, we can just decode that

00:21:17.026 --> 00:21:18.276 A:middle
image that's stored in the asset

00:21:18.276 --> 00:21:21.296 A:middle
catalog and render it directly

00:21:21.296 --> 00:21:22.106 A:middle
into the frame buffer.

00:21:24.156 --> 00:21:26.716 A:middle
If you're planning on rendering

00:21:27.106 --> 00:21:29.576 A:middle
artwork at a few fixed sizes.

00:21:29.576 --> 00:21:31.056 A:middle
Maybe, you have a small version

00:21:31.056 --> 00:21:33.206 A:middle
and a large version of an icon.

00:21:33.816 --> 00:21:35.096 A:middle
Rather than relying on the

00:21:35.096 --> 00:21:37.136 A:middle
Preserve Vector Data checkbox,

00:21:37.736 --> 00:21:39.686 A:middle
create two image assets that

00:21:39.686 --> 00:21:41.506 A:middle
have the two sizes that you know

00:21:41.506 --> 00:21:42.356 A:middle
you're going to render your

00:21:42.356 --> 00:21:43.386 A:middle
image at.

00:21:44.696 --> 00:21:46.826 A:middle
That will allow the optimization

00:21:47.746 --> 00:21:49.816 A:middle
to take the CPU hit of

00:21:49.816 --> 00:21:51.176 A:middle
rasterizing your artwork at

00:21:51.176 --> 00:21:53.536 A:middle
compile time, rather than every

00:21:53.536 --> 00:21:55.576 A:middle
time the image is drawn into the

00:21:56.016 --> 00:21:57.926 A:middle
frame buffer.

00:21:58.266 --> 00:21:59.646 A:middle
So, we've seen how to work with

00:22:00.016 --> 00:22:01.596 A:middle
UIImage and UIImageView.

00:22:02.846 --> 00:22:04.176 A:middle
But that's not all of the

00:22:04.176 --> 00:22:05.256 A:middle
graphical work that your

00:22:05.256 --> 00:22:06.006 A:middle
application does.

00:22:06.006 --> 00:22:07.316 A:middle
Sometimes, your application

00:22:07.616 --> 00:22:09.496 A:middle
draws content at runtime.

00:22:12.016 --> 00:22:13.586 A:middle
The example of this happening

00:22:14.256 --> 00:22:15.956 A:middle
might be seen in something like

00:22:16.006 --> 00:22:18.856 A:middle
this editing view in the Photos

00:22:18.856 --> 00:22:19.446 A:middle
application.

00:22:20.996 --> 00:22:23.236 A:middle
The UIButton that's displaying

00:22:23.536 --> 00:22:26.146 A:middle
an icon and UIButton can use

00:22:26.146 --> 00:22:27.176 A:middle
UIImageView directly.

00:22:28.376 --> 00:22:29.726 A:middle
But UIButton doesn't support the

00:22:29.726 --> 00:22:32.056 A:middle
style of this Live button, here,

00:22:32.056 --> 00:22:33.396 A:middle
that you can tap to enable or

00:22:33.396 --> 00:22:35.216 A:middle
disable the Live Photo.

00:22:36.256 --> 00:22:37.136 A:middle
So, we're going to have to do

00:22:37.136 --> 00:22:38.346 A:middle
some work here, ourselves.

00:22:38.486 --> 00:22:41.326 A:middle
And one implementation of this

00:22:41.326 --> 00:22:43.606 A:middle
might be to subclass UIView and

00:22:43.606 --> 00:22:44.606 A:middle
implement the draw method.

00:22:45.096 --> 00:22:47.226 A:middle
And this implementation here

00:22:47.586 --> 00:22:49.716 A:middle
draws a yellow roundRect, draws

00:22:49.716 --> 00:22:51.276 A:middle
some text, and an image on top

00:22:51.916 --> 00:22:53.366 A:middle
of it.

00:22:53.626 --> 00:22:55.036 A:middle
Don't recommend this approach

00:22:55.866 --> 00:22:57.156 A:middle
for a couple of reasons.

00:22:58.066 --> 00:23:01.256 A:middle
Let's compare this view subclass

00:22:58.066 --> 00:23:01.256 A:middle
Let's compare this view subclass

00:23:02.006 --> 00:23:03.366 A:middle
to our UIImageView.

00:23:03.366 --> 00:23:05.116 A:middle
Now, as you may already be

00:23:05.116 --> 00:23:07.556 A:middle
aware, every UIView is,

00:23:07.556 --> 00:23:09.446 A:middle
actually, backed by a CALayer in

00:23:09.446 --> 00:23:10.546 A:middle
the Core Animation runtime.

00:23:11.496 --> 00:23:13.426 A:middle
And for our image view, the

00:23:13.426 --> 00:23:15.416 A:middle
image view creates the, asks the

00:23:15.416 --> 00:23:17.096 A:middle
image to create the decoded

00:23:17.096 --> 00:23:17.736 A:middle
image buffer.

00:23:18.476 --> 00:23:20.366 A:middle
And then, hands that decoded

00:23:20.366 --> 00:23:23.216 A:middle
image over to CALayer to use as

00:23:23.216 --> 00:23:24.366 A:middle
the content of its layer.

00:23:25.556 --> 00:23:27.296 A:middle
For our custom view that

00:23:27.296 --> 00:23:30.546 A:middle
overrode draw, it's similar, but

00:23:30.706 --> 00:23:31.476 A:middle
slightly different.

00:23:31.686 --> 00:23:32.886 A:middle
The layers responsible for

00:23:32.886 --> 00:23:34.876 A:middle
creating an image buffer to hold

00:23:34.876 --> 00:23:36.636 A:middle
the contents of our draw method,

00:23:36.766 --> 00:23:39.586 A:middle
and then our view, excuses draw

00:23:39.586 --> 00:23:42.176 A:middle
function and populates the

00:23:42.176 --> 00:23:43.266 A:middle
contents of that image buffer.

00:23:43.636 --> 00:23:45.116 A:middle
Which is then, copied into the

00:23:45.116 --> 00:23:47.256 A:middle
frame buffer as needed by the

00:23:47.256 --> 00:23:47.906 A:middle
display hardware.

00:23:54.046 --> 00:23:56.116 A:middle
In order to understand how much

00:23:56.116 --> 00:23:57.376 A:middle
this is costing us and why we

00:23:57.376 --> 00:23:58.306 A:middle
should, perhaps, pursue

00:23:58.306 --> 00:23:59.746 A:middle
alternative ways of implementing

00:23:59.746 --> 00:24:00.336 A:middle
this UI.

00:23:59.746 --> 00:24:00.336 A:middle
this UI.

00:24:01.556 --> 00:24:02.676 A:middle
The backing store that we're

00:24:02.676 --> 00:24:04.746 A:middle
using here, the image buffer

00:24:04.746 --> 00:24:06.506 A:middle
that's attached to the CALayer,

00:24:06.886 --> 00:24:08.216 A:middle
the size of that is proportional

00:24:08.576 --> 00:24:09.256 A:middle
to the view that we're

00:24:09.256 --> 00:24:09.826 A:middle
displaying.

00:24:11.146 --> 00:24:12.266 A:middle
Now, one new feature and

00:24:12.266 --> 00:24:13.746 A:middle
optimization that we have in iOS

00:24:13.746 --> 00:24:16.786 A:middle
12 is that the size of the

00:24:16.786 --> 00:24:18.976 A:middle
elements in that backing store

00:24:19.406 --> 00:24:21.206 A:middle
will, actually, grow dynamically

00:24:21.596 --> 00:24:22.456 A:middle
depending on whether you're

00:24:22.456 --> 00:24:24.006 A:middle
drawing any color content.

00:24:24.206 --> 00:24:25.596 A:middle
And whether that color content

00:24:25.596 --> 00:24:27.286 A:middle
is within or outside of the

00:24:27.286 --> 00:24:28.426 A:middle
standard color range.

00:24:28.926 --> 00:24:30.356 A:middle
So, if you're drawing wide color

00:24:30.356 --> 00:24:32.516 A:middle
content using extended SRGB

00:24:32.516 --> 00:24:34.856 A:middle
colors, the backing store will,

00:24:34.856 --> 00:24:37.586 A:middle
actually, be larger than the

00:24:37.586 --> 00:24:38.896 A:middle
backing store would be if you

00:24:38.896 --> 00:24:41.276 A:middle
used only colors within the zero

00:24:41.276 --> 00:24:42.036 A:middle
to one range.

00:24:42.516 --> 00:24:45.766 A:middle
Now, in previous versions of

00:24:45.766 --> 00:24:47.626 A:middle
iOS, you could set the contents

00:24:47.626 --> 00:24:49.876 A:middle
format property on CALayer as a

00:24:49.876 --> 00:24:51.416 A:middle
hint to Core Animation saying,

00:24:51.416 --> 00:24:52.836 A:middle
''I know I am not going to need

00:24:53.096 --> 00:24:54.496 A:middle
to support wide color content in

00:24:54.496 --> 00:24:56.026 A:middle
this view'', or, ''I know I am

00:24:56.026 --> 00:24:57.136 A:middle
going to need to support wide

00:24:57.136 --> 00:24:58.256 A:middle
color content in this view''.

00:24:58.586 --> 00:25:00.206 A:middle
Now, if you do this, you're

00:24:58.586 --> 00:25:00.206 A:middle
Now, if you do this, you're

00:25:00.206 --> 00:25:01.556 A:middle
actually going to be disabling

00:25:02.146 --> 00:25:03.726 A:middle
the optimization that we

00:25:03.726 --> 00:25:04.906 A:middle
introduced in iOS 12.

00:25:05.426 --> 00:25:07.456 A:middle
So, check your implementations

00:25:07.456 --> 00:25:08.456 A:middle
of layerWillDraw.

00:25:08.806 --> 00:25:10.016 A:middle
Make sure you're not going to

00:25:10.016 --> 00:25:10.926 A:middle
accidentally defeat an

00:25:10.926 --> 00:25:12.236 A:middle
optimization that could benefit

00:25:12.236 --> 00:25:13.916 A:middle
your code when running on iOS

00:25:13.916 --> 00:25:14.236 A:middle
12.

00:25:16.696 --> 00:25:19.376 A:middle
But we can do better than just

00:25:19.646 --> 00:25:21.786 A:middle
hinting at whether we need a

00:25:21.786 --> 00:25:23.106 A:middle
wide color capable backing

00:25:23.106 --> 00:25:23.446 A:middle
store.

00:25:23.836 --> 00:25:25.146 A:middle
We can, actually, reduce the

00:25:25.146 --> 00:25:26.386 A:middle
total amount of backing storage

00:25:26.386 --> 00:25:27.636 A:middle
that our application needs.

00:25:27.636 --> 00:25:29.616 A:middle
We can do that by refactoring

00:25:29.676 --> 00:25:31.526 A:middle
this larger view into smaller

00:25:31.526 --> 00:25:32.206 A:middle
subviews.

00:25:32.926 --> 00:25:34.586 A:middle
And reducing or eliminating

00:25:34.656 --> 00:25:36.026 A:middle
places that override the draw

00:25:36.026 --> 00:25:36.496 A:middle
function.

00:25:37.016 --> 00:25:39.306 A:middle
This will help us eliminate

00:25:39.306 --> 00:25:40.806 A:middle
duplicate copies of image data

00:25:41.076 --> 00:25:42.016 A:middle
that exist in memory.

00:25:42.166 --> 00:25:43.966 A:middle
And it will allow us to use

00:25:43.966 --> 00:25:46.256 A:middle
optimized properties of UIView

00:25:46.256 --> 00:25:47.336 A:middle
that don't require a backing

00:25:47.336 --> 00:25:47.706 A:middle
store.

00:25:48.236 --> 00:25:52.246 A:middle
So, as I mentioned, overriding

00:25:52.246 --> 00:25:53.776 A:middle
the draw method will require

00:25:53.776 --> 00:25:55.206 A:middle
creating a backing store to go

00:25:55.206 --> 00:25:56.056 A:middle
with your CALayer.

00:25:56.526 --> 00:25:58.286 A:middle
But some of the properties in

00:25:58.286 --> 00:26:00.236 A:middle
UIView can still work, even if

00:25:58.286 --> 00:26:00.236 A:middle
UIView can still work, even if

00:26:00.236 --> 00:26:01.336 A:middle
you don't override draw.

00:26:01.766 --> 00:26:03.026 A:middle
For example, setting the

00:26:03.026 --> 00:26:04.546 A:middle
background color of a UIView

00:26:04.796 --> 00:26:06.196 A:middle
doesn't require creating a

00:26:06.196 --> 00:26:08.036 A:middle
backing store, unless you're

00:26:08.036 --> 00:26:09.026 A:middle
using a pattern color.

00:26:09.486 --> 00:26:10.716 A:middle
So, I recommend not using

00:26:10.716 --> 00:26:11.536 A:middle
patterned colors with a

00:26:11.536 --> 00:26:12.736 A:middle
background color property on

00:26:12.736 --> 00:26:13.296 A:middle
UIView.

00:26:14.836 --> 00:26:17.176 A:middle
Instead, create a UIImageView.

00:26:17.746 --> 00:26:19.316 A:middle
Assign your image to that image

00:26:19.316 --> 00:26:19.536 A:middle
view.

00:26:20.056 --> 00:26:21.256 A:middle
And use the functions on

00:26:21.256 --> 00:26:23.466 A:middle
UIImageView to set your tiling

00:26:23.466 --> 00:26:24.576 A:middle
parameters appropriately.

00:26:25.086 --> 00:26:29.466 A:middle
When we want to clip the corners

00:26:29.796 --> 00:26:32.466 A:middle
of that rounded rectangle, we

00:26:32.466 --> 00:26:33.836 A:middle
want to use the CALayer

00:26:33.836 --> 00:26:34.986 A:middle
cornerRadius property.

00:26:35.776 --> 00:26:37.536 A:middle
Because Core Animation is able

00:26:37.536 --> 00:26:39.886 A:middle
to render clipped corners

00:26:40.206 --> 00:26:41.626 A:middle
without taking any extra memory

00:26:41.626 --> 00:26:42.426 A:middle
allocations.

00:26:43.416 --> 00:26:44.556 A:middle
If we, instead, use the more

00:26:44.556 --> 00:26:46.966 A:middle
powerful maskView or maskLayer

00:26:46.966 --> 00:26:49.176 A:middle
properties we'd wind up taking

00:26:49.176 --> 00:26:50.666 A:middle
in extra allocation to store

00:26:50.666 --> 00:26:51.986 A:middle
that mask.

00:26:53.216 --> 00:26:55.006 A:middle
If you have a more complicated

00:26:55.006 --> 00:26:56.996 A:middle
background that has transparent

00:26:56.996 --> 00:26:59.246 A:middle
areas that can't be expressed by

00:26:59.246 --> 00:27:00.346 A:middle
the cornerRadius property,

00:26:59.246 --> 00:27:00.346 A:middle
the cornerRadius property,

00:27:00.726 --> 00:27:01.876 A:middle
again, consider using a

00:27:01.876 --> 00:27:02.686 A:middle
UIImageView.

00:27:03.876 --> 00:27:05.346 A:middle
Store that information in your

00:27:05.346 --> 00:27:07.236 A:middle
asset catalog or render it at

00:27:07.236 --> 00:27:07.856 A:middle
runtime.

00:27:08.266 --> 00:27:09.906 A:middle
And provide that as an image to

00:27:09.906 --> 00:27:11.016 A:middle
the image view, rather than

00:27:11.016 --> 00:27:12.476 A:middle
using maskView or maskLayer.

00:27:14.556 --> 00:27:17.296 A:middle
Finally, for that icon, the Live

00:27:17.626 --> 00:27:20.706 A:middle
Photo icon, UIImageView is

00:27:20.706 --> 00:27:23.556 A:middle
capable of colorizing monochrome

00:27:23.556 --> 00:27:25.856 A:middle
artwork without taking any extra

00:27:25.856 --> 00:27:26.636 A:middle
allocations.

00:27:27.876 --> 00:27:29.336 A:middle
The first thing you want to do

00:27:29.336 --> 00:27:31.116 A:middle
is either check the, not check

00:27:31.116 --> 00:27:32.276 A:middle
the checkbox, but set the

00:27:32.276 --> 00:27:33.856 A:middle
property in the image asset

00:27:33.856 --> 00:27:36.016 A:middle
editor, the render mode property

00:27:36.016 --> 00:27:36.986 A:middle
to always template.

00:27:37.666 --> 00:27:39.166 A:middle
Or use the withRenderingMode

00:27:39.166 --> 00:27:41.326 A:middle
function on UIImageView to

00:27:41.326 --> 00:27:42.626 A:middle
create a UIImage whose rendering

00:27:42.626 --> 00:27:43.726 A:middle
mode is always template.

00:27:44.886 --> 00:27:45.986 A:middle
Then, assign that image to an

00:27:45.986 --> 00:27:47.736 A:middle
image view and set the tintColor

00:27:47.736 --> 00:27:49.366 A:middle
of that image view to the color

00:27:49.366 --> 00:27:51.006 A:middle
you want the image to render in.

00:27:52.156 --> 00:27:53.826 A:middle
UIImage, as it's rendering your

00:27:53.826 --> 00:27:55.886 A:middle
image to the frame buffer, will

00:27:55.886 --> 00:27:58.826 A:middle
apply that solid color during

00:27:58.826 --> 00:28:00.026 A:middle
that copy operation.

00:27:58.826 --> 00:28:00.026 A:middle
that copy operation.

00:28:00.536 --> 00:28:02.046 A:middle
Rather than having to hold on to

00:28:02.046 --> 00:28:03.476 A:middle
a separate copy of your image

00:28:03.886 --> 00:28:06.036 A:middle
with your solid color applied to

00:28:07.666 --> 00:28:07.746 A:middle
it.

00:28:08.006 --> 00:28:09.246 A:middle
Another optimization built into

00:28:09.246 --> 00:28:12.626 A:middle
UIKit provided view, UILabel is

00:28:12.626 --> 00:28:16.046 A:middle
able to use 75% less memory when

00:28:16.046 --> 00:28:18.486 A:middle
displaying monochrome text than

00:28:18.486 --> 00:28:19.756 A:middle
when displaying color text or

00:28:19.756 --> 00:28:20.336 A:middle
emojis.

00:28:21.496 --> 00:28:22.786 A:middle
If you want to know more about

00:28:22.786 --> 00:28:24.136 A:middle
how this optimization works in

00:28:24.136 --> 00:28:25.936 A:middle
detail and how to apply it to

00:28:25.936 --> 00:28:27.306 A:middle
your custom subclasses of

00:28:27.306 --> 00:28:29.736 A:middle
UIView, check out the iOS Memory

00:28:29.736 --> 00:28:30.786 A:middle
Deep Dive session.

00:28:31.356 --> 00:28:32.616 A:middle
Goes into great detail about

00:28:32.616 --> 00:28:34.636 A:middle
this backing store format called

00:28:35.186 --> 00:28:35.253 A:middle
A8.

00:28:38.306 --> 00:28:39.646 A:middle
Sometimes, you want to render

00:28:41.096 --> 00:28:44.256 A:middle
artwork offscreen stored in an

00:28:44.356 --> 00:28:45.506 A:middle
image buffer in memory.

00:28:45.736 --> 00:28:47.536 A:middle
And the class UIKit provides to

00:28:47.536 --> 00:28:48.376 A:middle
do that is

00:28:48.376 --> 00:28:49.826 A:middle
UIGraphicsImageRenderer.

00:28:50.796 --> 00:28:52.036 A:middle
There's another function that's

00:28:52.036 --> 00:28:52.456 A:middle
older;

00:28:53.156 --> 00:28:55.116 A:middle
UIGraphicsBeginImageContext.

00:28:55.446 --> 00:28:56.656 A:middle
But please, don't use that.

00:28:57.076 --> 00:28:58.386 A:middle
Because only Graphics Image

00:28:58.386 --> 00:29:00.186 A:middle
Renderer is capable of correctly

00:28:58.386 --> 00:29:00.186 A:middle
Renderer is capable of correctly

00:29:00.186 --> 00:29:02.146 A:middle
rendering wide color content.

00:29:02.186 --> 00:29:04.646 A:middle
What you can do in your

00:29:04.646 --> 00:29:05.716 A:middle
applications is use

00:29:05.716 --> 00:29:07.466 A:middle
UIGraphicsImageRenderer to

00:29:07.466 --> 00:29:08.946 A:middle
render to an offscreen place.

00:29:09.216 --> 00:29:10.586 A:middle
And then, use UIImageView to

00:29:10.586 --> 00:29:12.446 A:middle
display that, efficiently, on

00:29:12.446 --> 00:29:12.886 A:middle
the screen.

00:29:14.756 --> 00:29:16.496 A:middle
Similarly, to the optimization

00:29:16.496 --> 00:29:19.406 A:middle
that we've introduced in CALayer

00:29:19.406 --> 00:29:20.336 A:middle
backing stores.

00:29:20.626 --> 00:29:22.126 A:middle
We've, also, made

00:29:22.126 --> 00:29:24.246 A:middle
UIGraphicsImageRenderer capable

00:29:24.246 --> 00:29:25.946 A:middle
of dynamically growing the size

00:29:26.166 --> 00:29:27.456 A:middle
of its image buffer, depending

00:29:27.516 --> 00:29:30.076 A:middle
on the actions you perform in

00:29:30.076 --> 00:29:30.976 A:middle
the actions block.

00:29:33.656 --> 00:29:35.876 A:middle
If you are running your code on

00:29:35.916 --> 00:29:37.436 A:middle
a operating system prior to iOS

00:29:37.436 --> 00:29:38.846 A:middle
12, you can use the

00:29:38.846 --> 00:29:41.166 A:middle
prefersExtendedRange property on

00:29:41.166 --> 00:29:43.666 A:middle
UIGraphicsImageRendererFormat to

00:29:43.666 --> 00:29:45.256 A:middle
tell UIKit whether you plan on

00:29:45.256 --> 00:29:46.906 A:middle
drawing wide color content or

00:29:47.386 --> 00:29:47.486 A:middle
not.

00:29:50.196 --> 00:29:52.036 A:middle
But there's a medium middle

00:29:52.036 --> 00:29:52.646 A:middle
ground here.

00:29:53.356 --> 00:29:55.256 A:middle
If you're primarily rendering an

00:29:55.256 --> 00:29:56.956 A:middle
image in to a graphic image

00:29:56.956 --> 00:29:59.456 A:middle
renderer, that image may use a

00:29:59.456 --> 00:30:02.456 A:middle
color space that required values

00:29:59.456 --> 00:30:02.456 A:middle
color space that required values

00:30:02.456 --> 00:30:04.786 A:middle
outside of the range of SRGB.

00:30:05.666 --> 00:30:07.906 A:middle
But doesn't, actually, require a

00:30:07.906 --> 00:30:09.676 A:middle
larger element size to store

00:30:09.676 --> 00:30:10.456 A:middle
that information.

00:30:10.936 --> 00:30:13.776 A:middle
So, UIImage has a image renderer

00:30:13.776 --> 00:30:15.726 A:middle
format property that you can use

00:30:15.766 --> 00:30:16.106 A:middle
to get a

00:30:16.106 --> 00:30:17.986 A:middle
UIGraphicsImageRendererFormat

00:30:17.986 --> 00:30:19.826 A:middle
object preconstructed for

00:30:19.826 --> 00:30:21.916 A:middle
optimal storage of re-rendering

00:30:21.916 --> 00:30:22.436 A:middle
that image.

00:30:27.046 --> 00:30:27.836 A:middle
Lastly, we're going to talk a

00:30:27.836 --> 00:30:28.876 A:middle
little bit about how to

00:30:28.876 --> 00:30:31.276 A:middle
integrate advanced CPU and GPU

00:30:31.396 --> 00:30:32.726 A:middle
technologies that we provide in

00:30:32.726 --> 00:30:35.046 A:middle
iOS into your applications.

00:30:36.416 --> 00:30:38.876 A:middle
So, if you've got a lot of

00:30:38.876 --> 00:30:40.586 A:middle
advanced processing to do to

00:30:40.586 --> 00:30:42.416 A:middle
your images, perhaps, in real

00:30:42.416 --> 00:30:44.786 A:middle
time, consider using Core Image.

00:30:46.016 --> 00:30:48.426 A:middle
Core Image is a framework that

00:30:48.426 --> 00:30:49.826 A:middle
allows you to create a recipe

00:30:49.826 --> 00:30:51.826 A:middle
for processing an image and

00:30:51.826 --> 00:30:53.966 A:middle
handle that on the CPU or on the

00:30:53.966 --> 00:30:54.516 A:middle
GPU.

00:30:55.736 --> 00:30:57.226 A:middle
If you create a UIImage from a

00:30:57.226 --> 00:30:59.366 A:middle
CIImage and hand that to

00:30:59.366 --> 00:31:01.666 A:middle
UIImageView, UIImageView will

00:30:59.366 --> 00:31:01.666 A:middle
UIImageView, UIImageView will

00:31:01.666 --> 00:31:04.006 A:middle
take care to execute that recipe

00:31:04.416 --> 00:31:05.256 A:middle
on the GPU.

00:31:05.726 --> 00:31:08.286 A:middle
This is efficient and it keeps

00:31:08.286 --> 00:31:09.606 A:middle
the CPU free for doing other

00:31:09.606 --> 00:31:10.646 A:middle
work in your application.

00:31:11.176 --> 00:31:13.686 A:middle
In order to use it create your

00:31:13.686 --> 00:31:15.736 A:middle
CIImage as normal, and then use

00:31:15.736 --> 00:31:17.606 A:middle
the UIImage ciImage initializer.

00:31:19.296 --> 00:31:20.816 A:middle
There are other advanced

00:31:20.816 --> 00:31:23.066 A:middle
frameworks for processing and

00:31:23.066 --> 00:31:25.426 A:middle
rendering graphical content that

00:31:25.426 --> 00:31:27.276 A:middle
are available on iOS, including

00:31:27.606 --> 00:31:29.796 A:middle
Metal, Vison, and Accelerate.

00:31:30.696 --> 00:31:32.406 A:middle
And one of the data types that

00:31:32.406 --> 00:31:33.756 A:middle
is common among these frameworks

00:31:33.966 --> 00:31:35.186 A:middle
is CVPixelBuffer.

00:31:35.506 --> 00:31:37.526 A:middle
And this is a data type that

00:31:37.526 --> 00:31:39.986 A:middle
represents a buffer that can be

00:31:39.986 --> 00:31:42.436 A:middle
in use or not in use on the CPU

00:31:42.676 --> 00:31:43.476 A:middle
or on the GPU.

00:31:44.436 --> 00:31:45.566 A:middle
When constructing one of these

00:31:45.566 --> 00:31:47.416 A:middle
pixel buffers make sure to use

00:31:47.416 --> 00:31:48.546 A:middle
the best initializer.

00:31:48.646 --> 00:31:49.816 A:middle
The one that's closest to the

00:31:49.816 --> 00:31:51.566 A:middle
representation you have at hand.

00:31:52.766 --> 00:31:54.696 A:middle
Don't unwind any of the decoding

00:31:54.696 --> 00:31:54.926 A:middle
work.

00:31:55.226 --> 00:31:57.006 A:middle
It's already been done by the

00:31:57.006 --> 00:31:58.836 A:middle
existing UIImage or CGImage

00:31:59.116 --> 00:32:00.146 A:middle
representations.

00:31:59.116 --> 00:32:00.146 A:middle
representations.

00:32:01.156 --> 00:32:02.946 A:middle
And be careful when moving data

00:32:02.946 --> 00:32:04.816 A:middle
between the CPU and the GPU, so

00:32:04.866 --> 00:32:05.996 A:middle
that you don't just wind up

00:32:06.046 --> 00:32:07.116 A:middle
trading off work between the

00:32:07.116 --> 00:32:07.466 A:middle
two.

00:32:07.506 --> 00:32:08.816 A:middle
You can, actually, get them to

00:32:08.816 --> 00:32:10.026 A:middle
execute in parallel.

00:32:11.216 --> 00:32:12.726 A:middle
Finally, check out the

00:32:12.726 --> 00:32:14.846 A:middle
Accelerate and simd session for

00:32:14.846 --> 00:32:16.186 A:middle
information on how to properly

00:32:16.186 --> 00:32:18.116 A:middle
format your buffers for being

00:32:18.116 --> 00:32:19.636 A:middle
processed by the Accelerator

00:32:19.636 --> 00:32:20.036 A:middle
framework.

00:32:20.506 --> 00:32:24.116 A:middle
So, to summarize a few key

00:32:24.116 --> 00:32:24.736 A:middle
points.

00:32:25.936 --> 00:32:27.346 A:middle
Implement prefetch in your table

00:32:27.346 --> 00:32:28.466 A:middle
views and collection views, so

00:32:28.666 --> 00:32:29.866 A:middle
that you can get some work done

00:32:29.866 --> 00:32:31.346 A:middle
in advance and avoid hitching.

00:32:33.116 --> 00:32:34.096 A:middle
Make sure that you're not

00:32:34.096 --> 00:32:36.356 A:middle
defeating any optimizations that

00:32:36.356 --> 00:32:38.706 A:middle
UIKit is providing to reduce the

00:32:38.706 --> 00:32:40.006 A:middle
size of the backing stores

00:32:40.006 --> 00:32:41.346 A:middle
associated with your views.

00:32:43.356 --> 00:32:45.096 A:middle
If you're bundling artwork with

00:32:45.096 --> 00:32:46.976 A:middle
your applications store it in

00:32:46.976 --> 00:32:47.936 A:middle
the asset catalog.

00:32:49.126 --> 00:32:50.886 A:middle
Don't store it in files that are

00:32:50.886 --> 00:32:52.426 A:middle
associated with your app.

00:32:53.536 --> 00:32:55.036 A:middle
And finally, if you're rendering

00:32:55.036 --> 00:32:56.256 A:middle
the same icons at different

00:32:56.256 --> 00:32:58.856 A:middle
sizes don't over-rely on the

00:32:58.856 --> 00:33:00.466 A:middle
Preserve Vector Data checkbox.

00:32:58.856 --> 00:33:00.466 A:middle
Preserve Vector Data checkbox.

00:33:02.686 --> 00:33:04.806 A:middle
For more information there is a

00:33:04.806 --> 00:33:06.256 A:middle
couple of related sessions,

00:33:06.436 --> 00:33:08.816 A:middle
including one about actually

00:33:08.816 --> 00:33:11.396 A:middle
investigating your performance

00:33:11.396 --> 00:33:11.956 A:middle
problems.

00:33:12.066 --> 00:33:13.976 A:middle
And we'll also have labs,

00:33:14.576 --> 00:33:15.846 A:middle
tomorrow and Friday.

00:33:15.896 --> 00:33:17.126 A:middle
And if you have any questions,

00:33:17.416 --> 00:33:18.486 A:middle
come see us in the labs.

00:33:18.486 --> 00:33:20.566 A:middle
Thanks for watching.

00:33:21.516 --> 00:33:24.506 A:middle
[ Applause ]
