WEBVTT

00:00:07.516 --> 00:00:15.500 A:middle
[ Music ]

00:00:17.516 --> 00:00:22.500 A:middle
[ Applause ]

00:00:23.526 --> 00:00:24.226 A:middle
&gt;&gt; Hi, everybody.

00:00:25.096 --> 00:00:26.716 A:middle
My name is Sean James and I'm a

00:00:26.716 --> 00:00:27.806 A:middle
GPU Software Engineer.

00:00:28.696 --> 00:00:30.096 A:middle
Today, I'm going to talk about

00:00:30.096 --> 00:00:30.766 A:middle
Ray Tracing.

00:00:31.076 --> 00:00:32.426 A:middle
So, you may have seen our Ray

00:00:32.426 --> 00:00:33.966 A:middle
Tracing demo in the State of the

00:00:33.966 --> 00:00:35.636 A:middle
Union and want to learn more.

00:00:36.666 --> 00:00:37.706 A:middle
Or you may be interested in

00:00:37.706 --> 00:00:38.956 A:middle
using Ray Tracing in your own

00:00:38.956 --> 00:00:39.376 A:middle
apps.

00:00:40.006 --> 00:00:41.746 A:middle
Today, I'll talk about how you

00:00:41.746 --> 00:00:43.026 A:middle
can use Ray Tracing in your

00:00:43.026 --> 00:00:44.816 A:middle
applications and how you can

00:00:44.816 --> 00:00:47.036 A:middle
accelerate it on the GPU using

00:00:47.036 --> 00:00:47.386 A:middle
METAL.

00:00:48.576 --> 00:00:50.116 A:middle
Specifically, using METAL

00:00:50.116 --> 00:00:51.036 A:middle
Performance Shaders.

00:00:51.906 --> 00:00:53.956 A:middle
METAL Performance Shaders is a

00:00:53.956 --> 00:00:55.546 A:middle
collection of GPU Compute

00:00:55.546 --> 00:00:57.476 A:middle
Primitives optimized for all of

00:00:57.476 --> 00:00:59.546 A:middle
our iOS and macOS devices.


00:01:00.996 --> 00:01:02.536 A:middle
MPS includes support for image

00:01:02.536 --> 00:01:04.855 A:middle
processing, linear algebra, and

00:01:04.855 --> 00:01:05.586 A:middle
machine learning.

00:01:06.796 --> 00:01:08.036 A:middle
We've talk extensively about

00:01:08.036 --> 00:01:09.676 A:middle
these topics in previous

00:01:09.676 --> 00:01:10.156 A:middle
sessions.

00:01:11.316 --> 00:01:12.666 A:middle
This year, we've also added

00:01:12.666 --> 00:01:14.136 A:middle
support for training.

00:01:14.626 --> 00:01:16.066 A:middle
And there's an entire session

00:01:16.066 --> 00:01:17.306 A:middle
about this topic tomorrow.

00:01:17.796 --> 00:01:19.966 A:middle
For today, I'll talk about the

00:01:19.966 --> 00:01:21.576 A:middle
new support we've added this

00:01:21.576 --> 00:01:22.786 A:middle
year for Ray Tracing.

00:01:23.796 --> 00:01:25.856 A:middle
So first, what is Ray Tracing?

00:01:27.856 --> 00:01:29.286 A:middle
Ray Tracing applications are

00:01:29.286 --> 00:01:30.966 A:middle
based on following the paths

00:01:30.966 --> 00:01:32.846 A:middle
that Rays take as they interact

00:01:32.846 --> 00:01:33.456 A:middle
with the scene.

00:01:34.596 --> 00:01:36.776 A:middle
Rays can model light, sound, or

00:01:36.776 --> 00:01:37.746 A:middle
other forms of energy.

00:01:38.576 --> 00:01:40.166 A:middle
So, Ray Tracing has applications

00:01:40.546 --> 00:01:43.036 A:middle
in rendering, audio, and physics

00:01:43.036 --> 00:01:43.546 A:middle
simulation.

00:01:44.586 --> 00:01:46.196 A:middle
But rays can, also, represent

00:01:46.196 --> 00:01:48.136 A:middle
more abstract concepts, like

00:01:48.136 --> 00:01:49.356 A:middle
whether or not one point is

00:01:49.356 --> 00:01:50.266 A:middle
visible from another.

00:01:51.326 --> 00:01:52.366 A:middle
So, Ray Tracing also has

00:01:52.366 --> 00:01:53.506 A:middle
applications in collision

00:01:53.506 --> 00:01:54.786 A:middle
detection, artificial

00:01:54.786 --> 00:01:56.696 A:middle
intelligence, and pathfinding.

00:01:57.606 --> 00:01:59.396 A:middle
For today, though, I'll focus on

00:01:59.396 --> 00:02:01.006 A:middle
rendering as an example of how


00:01:59.396 --> 00:02:01.006 A:middle
rendering as an example of how

00:02:01.006 --> 00:02:02.266 A:middle
you can use Ray Tracing in your

00:02:02.266 --> 00:02:02.956 A:middle
applications.

00:02:04.476 --> 00:02:06.206 A:middle
So, you may be familiar with the

00:02:06.206 --> 00:02:07.496 A:middle
rasterization pipeline.

00:02:08.216 --> 00:02:09.895 A:middle
The rasterizer works by

00:02:09.895 --> 00:02:11.216 A:middle
projecting one triangle at a

00:02:11.216 --> 00:02:13.686 A:middle
time onto the screen and shading

00:02:13.686 --> 00:02:14.796 A:middle
the corresponding pixels.

00:02:15.726 --> 00:02:16.876 A:middle
This can be implemented very

00:02:16.876 --> 00:02:19.066 A:middle
quickly in GPU hardware, which

00:02:19.066 --> 00:02:20.296 A:middle
makes this the method of choice

00:02:20.296 --> 00:02:21.756 A:middle
for games and other real time

00:02:21.756 --> 00:02:22.446 A:middle
applications.

00:02:23.476 --> 00:02:25.626 A:middle
But the rasterization model

00:02:25.996 --> 00:02:27.356 A:middle
makes it difficult to simulate

00:02:27.356 --> 00:02:28.646 A:middle
certain physical behaviors of

00:02:28.646 --> 00:02:28.946 A:middle
light.

00:02:30.746 --> 00:02:32.176 A:middle
One example is reflections.

00:02:33.076 --> 00:02:34.806 A:middle
With the rasterizer, reflections

00:02:34.806 --> 00:02:35.886 A:middle
are, typically, implemented

00:02:35.946 --> 00:02:37.566 A:middle
using approximations, such as

00:02:37.566 --> 00:02:38.956 A:middle
cube maps and screen space

00:02:38.956 --> 00:02:39.536 A:middle
reflections.

00:02:40.136 --> 00:02:41.956 A:middle
But with the Ray Tracer we can

00:02:41.956 --> 00:02:43.636 A:middle
compute accurate reflections,

00:02:43.636 --> 00:02:44.176 A:middle
directly.

00:02:45.926 --> 00:02:47.316 A:middle
Another example is shadows.

00:02:48.186 --> 00:02:49.816 A:middle
With the rasterizer, shadows are

00:02:49.816 --> 00:02:51.046 A:middle
typically implemented using

00:02:51.046 --> 00:02:51.826 A:middle
shadow maps.

00:02:52.516 --> 00:02:53.456 A:middle
But these can be tricky to

00:02:53.456 --> 00:02:55.066 A:middle
implement without suffering from

00:02:55.066 --> 00:02:56.786 A:middle
aliasing and resolution issues.

00:02:57.756 --> 00:02:59.746 A:middle
Furthermore, soft shadow mapping

00:02:59.746 --> 00:03:00.956 A:middle
techniques tend to produce


00:02:59.746 --> 00:03:00.956 A:middle
techniques tend to produce

00:03:00.956 --> 00:03:02.346 A:middle
uniformly soft shadows.

00:03:03.286 --> 00:03:05.376 A:middle
With the Ray Tracer we can

00:03:05.376 --> 00:03:06.646 A:middle
directly compute whether or not

00:03:06.646 --> 00:03:08.306 A:middle
a point if in shadow.

00:03:08.856 --> 00:03:09.766 A:middle
So, we can produce clean

00:03:09.766 --> 00:03:11.756 A:middle
shadows, including realistic

00:03:11.756 --> 00:03:13.246 A:middle
transitions from hard to soft

00:03:13.246 --> 00:03:14.996 A:middle
shadows as the distance between

00:03:14.996 --> 00:03:15.946 A:middle
objects increases.

00:03:16.506 --> 00:03:19.546 A:middle
One final example is global

00:03:19.546 --> 00:03:20.736 A:middle
elimination.

00:03:22.216 --> 00:03:23.526 A:middle
This simulates light bouncing of

00:03:23.526 --> 00:03:24.806 A:middle
off surfaces in the scene.

00:03:25.606 --> 00:03:27.526 A:middle
Global elimination can be very

00:03:27.526 --> 00:03:28.586 A:middle
difficult to model with the

00:03:28.586 --> 00:03:29.256 A:middle
rasterizer.

00:03:29.536 --> 00:03:30.946 A:middle
But it's actually modeled quite

00:03:30.946 --> 00:03:32.306 A:middle
naturally with the Ray Tracer.

00:03:33.026 --> 00:03:34.716 A:middle
In fact, many games and real

00:03:34.716 --> 00:03:36.146 A:middle
time applications that include a

00:03:36.146 --> 00:03:37.566 A:middle
global elimination component,

00:03:38.026 --> 00:03:39.596 A:middle
actually, precompute it using a

00:03:39.596 --> 00:03:41.446 A:middle
Ray Tracer and store the result

00:03:41.446 --> 00:03:42.306 A:middle
into textures.

00:03:42.606 --> 00:03:43.816 A:middle
Which are then mapped back onto

00:03:43.856 --> 00:03:45.076 A:middle
the geometry at run time.

00:03:45.656 --> 00:03:48.746 A:middle
Of course, there are many other

00:03:48.746 --> 00:03:49.796 A:middle
effects that we can simulate

00:03:49.796 --> 00:03:51.216 A:middle
with the Ray Tracer, such as

00:03:51.216 --> 00:03:53.176 A:middle
ambient occlusion, refraction,

00:03:53.316 --> 00:03:54.576 A:middle
and area light sources.

00:03:54.956 --> 00:03:56.576 A:middle
As well as camera effects, such

00:03:56.576 --> 00:03:57.836 A:middle
as depth of field and motion

00:03:57.836 --> 00:03:58.076 A:middle
blur.

00:03:59.606 --> 00:04:00.616 A:middle
This makes Ray Tracing the


00:03:59.606 --> 00:04:00.616 A:middle
This makes Ray Tracing the

00:04:00.616 --> 00:04:01.586 A:middle
method of choice for

00:04:01.586 --> 00:04:03.596 A:middle
photorealistic offline rendering

00:04:03.596 --> 00:04:04.346 A:middle
applications.

00:04:05.886 --> 00:04:07.366 A:middle
The tradeoff is that Ray Tracing

00:04:07.366 --> 00:04:08.376 A:middle
is significantly more

00:04:08.376 --> 00:04:09.766 A:middle
computationally expensive than

00:04:09.766 --> 00:04:11.476 A:middle
rasterization because we're

00:04:11.476 --> 00:04:12.506 A:middle
doing so much more work to

00:04:12.506 --> 00:04:13.526 A:middle
simulate these effects.

00:04:14.856 --> 00:04:16.226 A:middle
So, let's first take a closer

00:04:16.226 --> 00:04:17.606 A:middle
look at how rendering works with

00:04:17.606 --> 00:04:18.956 A:middle
the Ray Tracer, and then we'll

00:04:18.956 --> 00:04:20.245 A:middle
see how we can accelerate is

00:04:20.245 --> 00:04:20.786 A:middle
with METAL.

00:04:21.386 --> 00:04:24.606 A:middle
So, we use an algorithm called

00:04:24.636 --> 00:04:25.436 A:middle
Path Tracing.

00:04:26.516 --> 00:04:27.856 A:middle
In the real world, photons are

00:04:27.856 --> 00:04:29.696 A:middle
emitted from light sources and

00:04:29.696 --> 00:04:30.886 A:middle
they bounce around until they

00:04:30.886 --> 00:04:32.586 A:middle
enter the camera or your eye.

00:04:33.316 --> 00:04:35.176 A:middle
But most of those photons

00:04:35.416 --> 00:04:36.486 A:middle
actually never make it to the

00:04:36.486 --> 00:04:36.866 A:middle
camera.

00:04:37.406 --> 00:04:38.326 A:middle
So, this would be very

00:04:38.326 --> 00:04:39.466 A:middle
inefficient to simulate.

00:04:39.956 --> 00:04:42.516 A:middle
Fortunately, due to properties

00:04:42.516 --> 00:04:44.116 A:middle
of light we can, actually, work

00:04:44.176 --> 00:04:45.476 A:middle
backwards, starting from the

00:04:45.476 --> 00:04:45.866 A:middle
camera.

00:04:47.206 --> 00:04:49.536 A:middle
We start by casting primary rays

00:04:49.776 --> 00:04:51.816 A:middle
from the camera into the scene.

00:04:53.446 --> 00:04:54.886 A:middle
We then compute shading at the

00:04:54.886 --> 00:04:55.776 A:middle
intersection points.

00:04:56.836 --> 00:04:58.256 A:middle
Shading consists of figuring out

00:04:58.296 --> 00:04:59.896 A:middle
how much light is arriving at

00:04:59.896 --> 00:05:01.556 A:middle
the shading point and what


00:04:59.896 --> 00:05:01.556 A:middle
the shading point and what

00:05:01.556 --> 00:05:02.696 A:middle
fraction of that light is

00:05:02.696 --> 00:05:04.146 A:middle
reflected back towards the

00:05:04.146 --> 00:05:04.496 A:middle
camera.

00:05:05.516 --> 00:05:06.826 A:middle
There are, actually, two sources

00:05:06.826 --> 00:05:08.086 A:middle
of light, which we'll handle

00:05:08.086 --> 00:05:08.656 A:middle
separately.

00:05:10.176 --> 00:05:12.186 A:middle
The first source is direct

00:05:12.186 --> 00:05:12.466 A:middle
light.

00:05:13.246 --> 00:05:14.406 A:middle
This is light that arrives

00:05:14.646 --> 00:05:15.946 A:middle
directly at the shading point

00:05:15.946 --> 00:05:16.936 A:middle
from the light source.

00:05:18.236 --> 00:05:19.946 A:middle
We can easily compute how much

00:05:19.946 --> 00:05:21.716 A:middle
light is arriving directly and

00:05:21.716 --> 00:05:22.946 A:middle
what fraction of that light is

00:05:22.946 --> 00:05:23.966 A:middle
reflected back towards the

00:05:23.966 --> 00:05:24.306 A:middle
camera.

00:05:25.186 --> 00:05:26.836 A:middle
All we need to do is check that

00:05:26.836 --> 00:05:27.866 A:middle
the shading point is not,

00:05:27.866 --> 00:05:29.656 A:middle
actually, in shadow, before

00:05:29.656 --> 00:05:30.486 A:middle
adding the lighting to the

00:05:30.486 --> 00:05:30.916 A:middle
image.

00:05:32.106 --> 00:05:34.146 A:middle
To do this, we can cast

00:05:34.146 --> 00:05:35.836 A:middle
additional shadow rays from the

00:05:35.836 --> 00:05:37.046 A:middle
shading point towards the light

00:05:37.046 --> 00:05:37.536 A:middle
source.

00:05:38.386 --> 00:05:40.266 A:middle
If the shadow ray doesn't make

00:05:40.266 --> 00:05:41.126 A:middle
it all the way to the light

00:05:41.126 --> 00:05:42.436 A:middle
source, then the original

00:05:42.436 --> 00:05:43.776 A:middle
shading point was in shadow.

00:05:44.316 --> 00:05:45.196 A:middle
So, we shouldn't add the

00:05:45.196 --> 00:05:48.646 A:middle
lighting to the image.

00:05:48.936 --> 00:05:50.386 A:middle
The other source of light is

00:05:50.386 --> 00:05:51.126 A:middle
indirect light.

00:05:52.116 --> 00:05:53.516 A:middle
This is light that bounces off

00:05:53.516 --> 00:05:55.016 A:middle
of other surfaces in the scene

00:05:55.276 --> 00:05:56.446 A:middle
before reaching the shading

00:05:56.446 --> 00:05:56.786 A:middle
point.

00:05:57.386 --> 00:05:59.696 A:middle
To collect indirect light, we

00:05:59.696 --> 00:06:01.486 A:middle
can cast secondary rays in


00:05:59.696 --> 00:06:01.486 A:middle
can cast secondary rays in

00:06:01.486 --> 00:06:02.596 A:middle
random directions from the

00:06:02.596 --> 00:06:03.256 A:middle
shading point.

00:06:04.686 --> 00:06:05.786 A:middle
We then, repeat the shading

00:06:05.786 --> 00:06:07.126 A:middle
process at the secondary

00:06:07.126 --> 00:06:08.106 A:middle
intersection points.

00:06:09.896 --> 00:06:11.046 A:middle
We'll first compute how much

00:06:11.046 --> 00:06:13.176 A:middle
light is arriving directly at

00:06:13.176 --> 00:06:14.596 A:middle
the second intersection point

00:06:15.066 --> 00:06:16.366 A:middle
and what fraction of that light

00:06:16.636 --> 00:06:17.876 A:middle
is reflected back towards the

00:06:17.876 --> 00:06:19.236 A:middle
previous intersection point.

00:06:19.236 --> 00:06:21.186 A:middle
And, ultimately, back into the

00:06:21.186 --> 00:06:21.616 A:middle
camera.

00:06:22.566 --> 00:06:24.186 A:middle
We'll also need to cast another

00:06:24.186 --> 00:06:25.806 A:middle
shadow ray from the secondary

00:06:25.806 --> 00:06:26.706 A:middle
intersection point.

00:06:26.706 --> 00:06:30.346 A:middle
And we can repeat this process

00:06:30.346 --> 00:06:31.946 A:middle
however many times we'd like to

00:06:31.946 --> 00:06:33.836 A:middle
simulate light bouncing around

00:06:34.356 --> 00:06:36.336 A:middle
the scene.

00:06:37.006 --> 00:06:38.446 A:middle
Now, in order to get these nice

00:06:38.446 --> 00:06:39.906 A:middle
soft shadow and bounced lighting

00:06:39.906 --> 00:06:41.746 A:middle
effects we, actually, need to

00:06:41.746 --> 00:06:43.256 A:middle
cast many shadow and secondary

00:06:43.256 --> 00:06:46.326 A:middle
rays per point along the path.

00:06:46.546 --> 00:06:47.516 A:middle
This means that the number of

00:06:47.516 --> 00:06:48.916 A:middle
rays, actually, grows

00:06:48.916 --> 00:06:50.206 A:middle
exponentially with the number of

00:06:50.206 --> 00:06:50.716 A:middle
bounces.

00:06:51.946 --> 00:06:53.436 A:middle
To avoid this exponential growth

00:06:54.346 --> 00:06:55.666 A:middle
we'll, instead, choose just one

00:06:55.666 --> 00:06:57.446 A:middle
shadow ray and one secondary ray

00:06:57.446 --> 00:06:58.636 A:middle
direction at each bounce.


00:07:00.106 --> 00:07:01.396 A:middle
This will result in a noisy

00:07:01.396 --> 00:07:03.366 A:middle
image but we can average the

00:07:03.366 --> 00:07:04.826 A:middle
results together over multiple

00:07:04.826 --> 00:07:05.316 A:middle
frames.

00:07:06.256 --> 00:07:07.446 A:middle
Each frame will, also, generate

00:07:07.446 --> 00:07:09.386 A:middle
its own set of primary rays, so

00:07:09.386 --> 00:07:10.616 A:middle
this, also, gives us the

00:07:10.616 --> 00:07:12.046 A:middle
opportunity to implement camera

00:07:12.046 --> 00:07:13.446 A:middle
effects such as depth of field

00:07:13.446 --> 00:07:14.176 A:middle
and motion blur.

00:07:14.686 --> 00:07:17.536 A:middle
So, let's translate this all

00:07:17.536 --> 00:07:18.346 A:middle
into a diagram.

00:07:19.446 --> 00:07:21.286 A:middle
First, we'll generate primary

00:07:21.286 --> 00:07:21.616 A:middle
rays.

00:07:22.346 --> 00:07:23.476 A:middle
Then, we'll find the

00:07:23.476 --> 00:07:24.686 A:middle
intersections with the scene.

00:07:25.316 --> 00:07:27.606 A:middle
Then, we'll compute shading at

00:07:27.606 --> 00:07:28.676 A:middle
the intersection points.

00:07:28.946 --> 00:07:30.086 A:middle
And remember, that this is an

00:07:30.086 --> 00:07:31.546 A:middle
iterative process, which will

00:07:31.546 --> 00:07:33.046 A:middle
generate additional shadow and

00:07:33.046 --> 00:07:34.616 A:middle
secondary rays, which will be

00:07:34.616 --> 00:07:35.566 A:middle
intersected with the scene,

00:07:35.566 --> 00:07:36.006 A:middle
again.

00:07:36.036 --> 00:07:37.946 A:middle
And finally, we'll write the

00:07:37.946 --> 00:07:39.366 A:middle
shaded color into our image.

00:07:40.986 --> 00:07:42.036 A:middle
So, this is describing a

00:07:42.066 --> 00:07:43.126 A:middle
rendering application.

00:07:43.456 --> 00:07:44.746 A:middle
But a significant fraction of

00:07:44.746 --> 00:07:46.526 A:middle
the time is, actually, spent on

00:07:46.526 --> 00:07:47.606 A:middle
ray triangle intersection

00:07:47.606 --> 00:07:48.126 A:middle
testing.

00:07:49.446 --> 00:07:50.556 A:middle
This means that the performance

00:07:50.556 --> 00:07:52.306 A:middle
of the intersector has a huge

00:07:52.306 --> 00:07:53.826 A:middle
impact on the overall rendering

00:07:53.826 --> 00:07:55.246 A:middle
performance, even though, it has

00:07:55.246 --> 00:07:56.376 A:middle
nothing to do with the actual

00:07:56.376 --> 00:07:57.336 A:middle
lighting and shading.

00:07:58.496 --> 00:08:00.066 A:middle
This core intersection problem


00:07:58.496 --> 00:08:00.066 A:middle
This core intersection problem

00:08:00.386 --> 00:08:01.716 A:middle
is, also, common to all Ray

00:08:01.716 --> 00:08:02.766 A:middle
Tracing applications.

00:08:04.836 --> 00:08:06.026 A:middle
So, we decided to solve this

00:08:06.026 --> 00:08:07.456 A:middle
core intersection problem for

00:08:07.456 --> 00:08:09.176 A:middle
you, so that you can start with

00:08:09.176 --> 00:08:10.766 A:middle
a high performance intersector

00:08:11.126 --> 00:08:12.556 A:middle
and just focus on the details of

00:08:12.556 --> 00:08:12.996 A:middle
you app.

00:08:14.206 --> 00:08:16.576 A:middle
So, this year, we're introducing

00:08:16.576 --> 00:08:18.276 A:middle
the MPSRayIntersector API.

00:08:19.676 --> 00:08:21.306 A:middle
This is an API which accelerates

00:08:21.306 --> 00:08:22.386 A:middle
ray triangle intersection

00:08:22.386 --> 00:08:25.136 A:middle
testing on the GPU on all of our

00:08:25.136 --> 00:08:26.786 A:middle
macOS and iOS devices.

00:08:28.116 --> 00:08:29.626 A:middle
We wanted to make it easy to

00:08:29.626 --> 00:08:30.806 A:middle
integrate his into existing

00:08:30.806 --> 00:08:32.676 A:middle
apps, so we simply take in rays

00:08:32.726 --> 00:08:33.606 A:middle
through a METAL buffer.

00:08:34.666 --> 00:08:35.966 A:middle
MPS will find the closest

00:08:35.966 --> 00:08:38.035 A:middle
intersection along each ray and

00:08:38.035 --> 00:08:39.166 A:middle
return the results in another

00:08:39.166 --> 00:08:39.796 A:middle
METAL buffer.

00:08:40.686 --> 00:08:42.885 A:middle
All you need to do is provide a

00:08:42.885 --> 00:08:44.326 A:middle
METAL command buffer at the

00:08:44.326 --> 00:08:45.566 A:middle
point in your application where

00:08:45.566 --> 00:08:46.436 A:middle
you'd like to perform

00:08:46.436 --> 00:08:47.426 A:middle
intersection testing.

00:08:47.826 --> 00:08:49.016 A:middle
And we'll encode all of the

00:08:49.016 --> 00:08:50.096 A:middle
intersection work into the

00:08:50.096 --> 00:08:51.126 A:middle
command buffer for you.

00:08:52.346 --> 00:08:53.936 A:middle
So, let's take a closer look at

00:08:53.936 --> 00:08:54.796 A:middle
the problem that we're trying to

00:08:54.796 --> 00:08:55.156 A:middle
solve.

00:08:55.816 --> 00:09:02.916 A:middle
Oh. Okay. So, 3D models are,


00:08:55.816 --> 00:09:02.916 A:middle
Oh. Okay. So, 3D models are,

00:09:02.916 --> 00:09:04.276 A:middle
usually, represented as arrays

00:09:04.276 --> 00:09:04.916 A:middle
of triangles.

00:09:05.966 --> 00:09:07.756 A:middle
What we need to do is search

00:09:07.756 --> 00:09:09.306 A:middle
through those triangles and

00:09:09.306 --> 00:09:10.986 A:middle
figure out which ones intersect

00:09:10.986 --> 00:09:11.486 A:middle
each ray.

00:09:11.576 --> 00:09:13.926 A:middle
And furthermore, we need to

00:09:13.926 --> 00:09:15.526 A:middle
figure out which intersection

00:09:15.526 --> 00:09:16.956 A:middle
point is closest to the ray's

00:09:16.956 --> 00:09:17.346 A:middle
origin.

00:09:17.586 --> 00:09:20.516 A:middle
And the simplest way to do this

00:09:20.996 --> 00:09:22.116 A:middle
would be to just loop through

00:09:22.116 --> 00:09:23.506 A:middle
all the triangles and check for

00:09:23.506 --> 00:09:24.506 A:middle
intersection with the ray.

00:09:25.376 --> 00:09:26.226 A:middle
But for anything but the

00:09:26.226 --> 00:09:27.776 A:middle
smallest scenes, this would be

00:09:27.776 --> 00:09:28.646 A:middle
far too slow.

00:09:29.666 --> 00:09:31.416 A:middle
So instead, we built a data

00:09:31.416 --> 00:09:32.516 A:middle
structure that we call an

00:09:32.516 --> 00:09:33.606 A:middle
Acceleration Structure.

00:09:34.156 --> 00:09:36.056 A:middle
The acceleration structure works

00:09:36.096 --> 00:09:37.336 A:middle
by recursively dividing the

00:09:37.336 --> 00:09:39.186 A:middle
scene into groups of triangles

00:09:39.216 --> 00:09:40.426 A:middle
that are located nearby in

00:09:40.426 --> 00:09:40.826 A:middle
space.

00:09:42.496 --> 00:09:43.696 A:middle
When you want to intersect a ray

00:09:43.696 --> 00:09:45.796 A:middle
with a scene, we intersect the

00:09:45.796 --> 00:09:47.086 A:middle
ray with the bounding boxes in

00:09:47.086 --> 00:09:47.486 A:middle
the tree.

00:09:48.386 --> 00:09:50.016 A:middle
If a ray misses a bounding box,

00:09:50.136 --> 00:09:51.276 A:middle
then we can skip the entire

00:09:51.276 --> 00:09:51.806 A:middle
subtree.

00:09:53.136 --> 00:09:54.226 A:middle
In the end, we're left with just

00:09:54.226 --> 00:09:55.456 A:middle
a fraction of the triangles that

00:09:55.456 --> 00:09:56.636 A:middle
we actually need to check for

00:09:56.636 --> 00:09:57.586 A:middle
intersection with the ray.

00:09:58.746 --> 00:10:00.356 A:middle
So, this is the main way that we


00:09:58.746 --> 00:10:00.356 A:middle
So, this is the main way that we

00:10:00.356 --> 00:10:01.346 A:middle
speed up ray triangle

00:10:01.346 --> 00:10:01.996 A:middle
intersection.

00:10:03.336 --> 00:10:04.876 A:middle
Of course, this is a simplified

00:10:04.876 --> 00:10:05.386 A:middle
example.

00:10:06.156 --> 00:10:07.846 A:middle
In a real scene the acceleration

00:10:07.846 --> 00:10:08.906 A:middle
structure can be quite a bit

00:10:08.906 --> 00:10:09.646 A:middle
more complicated.

00:10:09.646 --> 00:10:12.236 A:middle
We can see from this

00:10:12.236 --> 00:10:13.566 A:middle
visualization that the

00:10:13.566 --> 00:10:14.756 A:middle
acceleration structure is

00:10:14.756 --> 00:10:16.176 A:middle
adapting to the complexity of

00:10:16.176 --> 00:10:16.866 A:middle
the geometry.

00:10:17.236 --> 00:10:19.106 A:middle
This means that we spend most of

00:10:19.106 --> 00:10:20.356 A:middle
our time searching for

00:10:20.356 --> 00:10:22.226 A:middle
intersections only in areas of

00:10:22.226 --> 00:10:24.226 A:middle
high geometric complexity, which

00:10:24.226 --> 00:10:24.926 A:middle
is what we want.

00:10:26.156 --> 00:10:27.586 A:middle
Now, I'm describing this to give

00:10:27.586 --> 00:10:29.486 A:middle
you an intuition for what the

00:10:29.486 --> 00:10:31.086 A:middle
acceleration structure is and

00:10:31.086 --> 00:10:31.816 A:middle
how it works.

00:10:32.516 --> 00:10:33.436 A:middle
But you, actually, don't need to

00:10:33.436 --> 00:10:34.546 A:middle
worry about this, too much,

00:10:35.026 --> 00:10:36.116 A:middle
because MPS will take care of

00:10:36.116 --> 00:10:36.806 A:middle
all of this for you.

00:10:36.806 --> 00:10:39.976 A:middle
Remember that we'll model our

00:10:39.976 --> 00:10:41.316 A:middle
scene using triangles.

00:10:41.686 --> 00:10:42.756 A:middle
And those triangles will

00:10:42.756 --> 00:10:43.986 A:middle
themselves be represented by

00:10:43.986 --> 00:10:45.656 A:middle
vertices in a vertex buffer.

00:10:46.736 --> 00:10:48.616 A:middle
All you need to do is call MPS

00:10:48.616 --> 00:10:50.416 A:middle
to build an acceleration

00:10:50.416 --> 00:10:51.506 A:middle
structure from your vertex

00:10:51.536 --> 00:10:51.896 A:middle
buffer.

00:10:52.576 --> 00:10:54.286 A:middle
When you're ready to search for

00:10:54.286 --> 00:10:55.666 A:middle
intersections, you simply

00:10:55.666 --> 00:10:56.786 A:middle
provide this acceleration

00:10:56.786 --> 00:10:57.626 A:middle
structure back to the

00:10:57.626 --> 00:10:58.256 A:middle
intersector.

00:10:59.276 --> 00:11:00.646 A:middle
So, let's see how we can use


00:10:59.276 --> 00:11:00.646 A:middle
So, let's see how we can use

00:11:00.646 --> 00:11:01.486 A:middle
this to build a real

00:11:01.486 --> 00:11:02.026 A:middle
application.

00:11:03.426 --> 00:11:04.736 A:middle
We'll break this app into three

00:11:04.736 --> 00:11:05.286 A:middle
stages.

00:11:05.656 --> 00:11:07.396 A:middle
First, we'll generate primary

00:11:07.396 --> 00:11:09.186 A:middle
rays, find the intersections

00:11:09.186 --> 00:11:10.556 A:middle
with the scene, and compute

00:11:10.556 --> 00:11:11.126 A:middle
shading.

00:11:11.996 --> 00:11:13.006 A:middle
This will be equivalent to what

00:11:13.006 --> 00:11:13.836 A:middle
we could have done with the

00:11:13.836 --> 00:11:15.626 A:middle
rasterizer, but we'll take it

00:11:15.626 --> 00:11:16.616 A:middle
further in the next steps.

00:11:17.336 --> 00:11:19.426 A:middle
So next, we'll add shadows.

00:11:20.046 --> 00:11:21.436 A:middle
MPS has special support for

00:11:21.436 --> 00:11:23.156 A:middle
shadow rays, which can make this

00:11:23.156 --> 00:11:24.426 A:middle
application even faster.

00:11:24.576 --> 00:11:27.626 A:middle
And finally, we'll simulate

00:11:27.626 --> 00:11:29.076 A:middle
light bouncing around the scene

00:11:29.306 --> 00:11:30.406 A:middle
using secondary rays.

00:11:31.426 --> 00:11:32.616 A:middle
This would be very difficult to

00:11:32.616 --> 00:11:33.806 A:middle
do with the rasterizer, but

00:11:33.806 --> 00:11:34.916 A:middle
we'll see that it's, actually, a

00:11:34.916 --> 00:11:36.036 A:middle
straightforward extension with

00:11:36.036 --> 00:11:36.476 A:middle
Ray Tracing.

00:11:37.226 --> 00:11:39.906 A:middle
So, let's start with primary

00:11:41.276 --> 00:11:41.396 A:middle
rays.

00:11:41.686 --> 00:11:42.706 A:middle
There are five things that we

00:11:42.706 --> 00:11:43.186 A:middle
need to do.

00:11:44.156 --> 00:11:45.726 A:middle
First, we'll create a ray

00:11:45.726 --> 00:11:46.756 A:middle
triangle intersector.

00:11:48.076 --> 00:11:49.096 A:middle
Then, we'll create an

00:11:49.096 --> 00:11:50.376 A:middle
acceleration structure from our

00:11:50.376 --> 00:11:51.186 A:middle
vertex buffer.

00:11:51.646 --> 00:11:54.766 A:middle
Next, we'll generate primary

00:11:54.766 --> 00:11:56.276 A:middle
rays and write them into our ray

00:11:56.276 --> 00:11:56.716 A:middle
buffer.

00:11:58.706 --> 00:11:59.406 A:middle
We'll then, find the

00:11:59.406 --> 00:12:01.156 A:middle
intersections between those rays


00:11:59.406 --> 00:12:01.156 A:middle
intersections between those rays

00:12:01.156 --> 00:12:02.276 A:middle
and the scene, using the

00:12:02.276 --> 00:12:02.966 A:middle
intersector.

00:12:03.256 --> 00:12:05.506 A:middle
And finally, we'll use the

00:12:05.506 --> 00:12:07.136 A:middle
intersection results to compute

00:12:07.136 --> 00:12:07.656 A:middle
shading.

00:12:08.766 --> 00:12:09.876 A:middle
So, let's start with the

00:12:09.876 --> 00:12:10.506 A:middle
intersector.

00:12:11.136 --> 00:12:14.556 A:middle
The MPSRayIntersector class

00:12:14.786 --> 00:12:15.806 A:middle
coordinates all of the ray

00:12:15.806 --> 00:12:17.186 A:middle
triangle intersection testing.

00:12:18.256 --> 00:12:19.736 A:middle
All we need to do to create one

00:12:19.826 --> 00:12:21.136 A:middle
is provide the METAL device that

00:12:21.136 --> 00:12:22.436 A:middle
we want to use for intersection

00:12:22.436 --> 00:12:22.806 A:middle
testing.

00:12:23.426 --> 00:12:26.106 A:middle
Next, we'll create the

00:12:26.106 --> 00:12:27.156 A:middle
acceleration structure.

00:12:28.416 --> 00:12:30.416 A:middle
This is represented by the

00:12:30.416 --> 00:12:31.966 A:middle
MPSTriangleAccelerationStructure

00:12:31.966 --> 00:12:32.366 A:middle
class.

00:12:33.136 --> 00:12:34.306 A:middle
Again, all we need to do to

00:12:34.306 --> 00:12:35.936 A:middle
create one is provide the same

00:12:35.936 --> 00:12:37.196 A:middle
METAL device we used to create

00:12:37.196 --> 00:12:37.926 A:middle
the intersector.

00:12:38.536 --> 00:12:41.716 A:middle
We then, attach our vertexBuffer

00:12:41.716 --> 00:12:43.186 A:middle
and specify the triangleCount.

00:12:43.356 --> 00:12:45.786 A:middle
And finally, we build the

00:12:45.786 --> 00:12:46.846 A:middle
acceleration structure.

00:12:47.536 --> 00:12:48.986 A:middle
We only need to do this once.

00:12:48.986 --> 00:12:50.066 A:middle
And then, we can reuse the

00:12:50.066 --> 00:12:51.746 A:middle
acceleration structure as many

00:12:51.746 --> 00:12:52.536 A:middle
times as we'd like.

00:12:56.616 --> 00:12:57.976 A:middle
So next, we'll generate primary

00:12:57.976 --> 00:12:59.386 A:middle
rays and write them into our ray

00:12:59.386 --> 00:12:59.796 A:middle
buffer.


00:13:01.176 --> 00:13:02.236 A:middle
To do this, we'll launch a

00:13:02.236 --> 00:13:03.766 A:middle
two-dimensional compute kernel

00:13:04.146 --> 00:13:05.466 A:middle
with one thread per pixel.

00:13:06.506 --> 00:13:08.166 A:middle
Each thread will write this ray

00:13:08.166 --> 00:13:09.636 A:middle
struct into the ray buffer.

00:13:10.756 --> 00:13:12.676 A:middle
We can think about our output

00:13:12.676 --> 00:13:14.686 A:middle
image as floating on a plane in

00:13:14.686 --> 00:13:15.356 A:middle
front of the camera.

00:13:17.396 --> 00:13:18.846 A:middle
Primary rays are emitted from

00:13:18.846 --> 00:13:20.196 A:middle
the camera, so we'll simply set

00:13:20.196 --> 00:13:21.226 A:middle
the origin to the camera

00:13:21.226 --> 00:13:21.636 A:middle
position.

00:13:22.746 --> 00:13:24.626 A:middle
To compute the direction, we'll

00:13:24.626 --> 00:13:25.866 A:middle
find the direction from the

00:13:25.866 --> 00:13:27.346 A:middle
camera position through the

00:13:27.346 --> 00:13:28.906 A:middle
corresponding pixel on the image

00:13:28.906 --> 00:13:29.226 A:middle
plan.

00:13:29.406 --> 00:13:33.406 A:middle
Now that we have our primary

00:13:33.406 --> 00:13:35.066 A:middle
rays, we'll use the intersector

00:13:35.066 --> 00:13:36.166 A:middle
to find the intersections of the

00:13:36.166 --> 00:13:36.546 A:middle
scene.

00:13:37.776 --> 00:13:40.286 A:middle
The encodeIntersection call will

00:13:40.286 --> 00:13:41.366 A:middle
tie together everything we've

00:13:41.366 --> 00:13:42.216 A:middle
created, so far.

00:13:43.436 --> 00:13:44.306 A:middle
First, remember that we'll

00:13:44.306 --> 00:13:46.236 A:middle
encode into a METAL command

00:13:46.236 --> 00:13:46.586 A:middle
buffer.

00:13:47.346 --> 00:13:48.816 A:middle
We, actually, have a couple of

00:13:48.816 --> 00:13:49.856 A:middle
options for what type of

00:13:49.856 --> 00:13:51.046 A:middle
intersection search we'd like to

00:13:51.046 --> 00:13:51.306 A:middle
do.

00:13:52.056 --> 00:13:53.106 A:middle
In this case, we'll just use

00:13:53.106 --> 00:13:54.226 A:middle
nearest, which will find the

00:13:54.226 --> 00:13:55.906 A:middle
closest intersection along each

00:13:55.906 --> 00:13:56.176 A:middle
ray.

00:13:56.766 --> 00:13:59.046 A:middle
We'll then, provide the ray

00:13:59.046 --> 00:14:00.276 A:middle
buffer, which contains the


00:13:59.046 --> 00:14:00.276 A:middle
buffer, which contains the

00:14:00.276 --> 00:14:03.596 A:middle
primary rays we just created, as

00:14:03.596 --> 00:14:04.806 A:middle
well as an intersection buffer,

00:14:04.806 --> 00:14:05.486 A:middle
which will contain the

00:14:05.486 --> 00:14:06.496 A:middle
intersection results.

00:14:07.866 --> 00:14:08.816 A:middle
We, also, need to provide the

00:14:08.816 --> 00:14:10.616 A:middle
rayCount, which in this case, is

00:14:10.616 --> 00:14:11.896 A:middle
just the image width times the

00:14:11.896 --> 00:14:12.456 A:middle
image height.

00:14:12.456 --> 00:14:15.096 A:middle
And finally, we'll provide our

00:14:15.096 --> 00:14:16.106 A:middle
accelerationStructure.

00:14:17.756 --> 00:14:18.986 A:middle
MPS will find the closest

00:14:18.986 --> 00:14:20.716 A:middle
intersection along each ray and

00:14:20.716 --> 00:14:21.766 A:middle
return the results in the

00:14:21.766 --> 00:14:22.666 A:middle
intersection buffer.

00:14:23.316 --> 00:14:24.706 A:middle
So, all that's left is to use

00:14:24.706 --> 00:14:26.106 A:middle
the intersection data to compute

00:14:26.106 --> 00:14:26.546 A:middle
shading.

00:14:27.166 --> 00:14:29.956 A:middle
To do this, we'll launch another

00:14:29.956 --> 00:14:30.686 A:middle
compute kernel.

00:14:31.266 --> 00:14:32.816 A:middle
We can apply lighting and

00:14:32.816 --> 00:14:34.426 A:middle
textures similar to the way that

00:14:34.426 --> 00:14:35.616 A:middle
we would in a fragment shader.

00:14:36.066 --> 00:14:37.626 A:middle
Most of the standard texture and

00:14:37.626 --> 00:14:38.846 A:middle
math functions that are

00:14:38.846 --> 00:14:40.356 A:middle
available in a fragment shader

00:14:40.756 --> 00:14:41.656 A:middle
are, also, available in a

00:14:41.656 --> 00:14:42.336 A:middle
compute kernel.

00:14:43.246 --> 00:14:45.126 A:middle
But shading, typically, depends

00:14:45.126 --> 00:14:46.586 A:middle
on both the intersection point

00:14:46.856 --> 00:14:48.226 A:middle
and vertex attributes, such as

00:14:48.266 --> 00:14:49.356 A:middle
colors and normals.

00:14:50.076 --> 00:14:52.076 A:middle
In a fragment shader the GPU

00:14:52.076 --> 00:14:53.426 A:middle
would interpolate these for us.

00:14:53.566 --> 00:14:54.966 A:middle
But we'll need to interpolate

00:14:54.966 --> 00:14:56.256 A:middle
them ourselves based on the

00:14:56.256 --> 00:14:57.086 A:middle
intersection data.

00:14:58.036 --> 00:14:59.946 A:middle
So, let's first look at how we

00:14:59.946 --> 00:15:01.016 A:middle
can compute the intersection


00:14:59.946 --> 00:15:01.016 A:middle
can compute the intersection

00:15:01.016 --> 00:15:01.346 A:middle
point.

00:15:01.776 --> 00:15:04.776 A:middle
Remember that a ray is defined

00:15:04.776 --> 00:15:06.306 A:middle
by its origin and direction.

00:15:07.736 --> 00:15:11.096 A:middle
This is the intersection struct

00:15:11.226 --> 00:15:12.066 A:middle
returned to us by the

00:15:12.066 --> 00:15:12.666 A:middle
intersector.

00:15:13.226 --> 00:15:15.186 A:middle
The distance field will tell us

00:15:15.256 --> 00:15:16.726 A:middle
how far we would need to go in

00:15:16.726 --> 00:15:18.396 A:middle
the ray direction to get from

00:15:18.396 --> 00:15:19.456 A:middle
the ray origin to the

00:15:19.456 --> 00:15:20.386 A:middle
intersection point.

00:15:20.386 --> 00:15:21.946 A:middle
And this distance will be

00:15:21.946 --> 00:15:23.276 A:middle
negative if the ray doesn't

00:15:23.276 --> 00:15:24.166 A:middle
intersect anything.

00:15:25.396 --> 00:15:28.086 A:middle
The primitiveIndex tells us

00:15:28.086 --> 00:15:29.096 A:middle
which triangle we hit.

00:15:29.696 --> 00:15:31.526 A:middle
And the last field is what we'll

00:15:31.526 --> 00:15:32.886 A:middle
use to interpolate vertex

00:15:32.886 --> 00:15:33.496 A:middle
attributes.

00:15:34.776 --> 00:15:36.566 A:middle
This field contains the first

00:15:36.566 --> 00:15:38.356 A:middle
barycentric coordinates called U

00:15:38.356 --> 00:15:38.796 A:middle
and V.

00:15:39.036 --> 00:15:40.476 A:middle
And these correspond to the

00:15:40.476 --> 00:15:41.676 A:middle
location of the intersection

00:15:41.676 --> 00:15:43.436 A:middle
point relative to the vertices

00:15:43.436 --> 00:15:44.076 A:middle
of the triangle.

00:15:45.306 --> 00:15:46.426 A:middle
There are, actually, three

00:15:46.426 --> 00:15:47.926 A:middle
barycentric coordinates, but

00:15:47.926 --> 00:15:48.836 A:middle
they add up to one.

00:15:49.076 --> 00:15:50.316 A:middle
So, we can compute the third

00:15:50.316 --> 00:15:52.706 A:middle
coordinate W by subtracting the

00:15:52.706 --> 00:15:53.706 A:middle
first two from one.

00:15:55.006 --> 00:15:56.916 A:middle
If we have a vertex attribute

00:15:56.986 --> 00:15:58.356 A:middle
defined at each vertex of our

00:15:58.356 --> 00:16:00.296 A:middle
triangle, then the interpolated


00:15:58.356 --> 00:16:00.296 A:middle
triangle, then the interpolated

00:16:00.296 --> 00:16:03.346 A:middle
vertex attribute is just the sum

00:16:03.346 --> 00:16:05.466 A:middle
of the attributes at each vertex

00:16:05.696 --> 00:16:06.876 A:middle
weighted by the barycentric

00:16:06.876 --> 00:16:07.396 A:middle
coordinates.

00:16:07.956 --> 00:16:09.766 A:middle
For example, if we have a color

00:16:09.766 --> 00:16:11.466 A:middle
defined at each vertex, then the

00:16:11.466 --> 00:16:13.226 A:middle
interpolated color is just the

00:16:13.226 --> 00:16:14.526 A:middle
weighted sum of the colors at

00:16:14.526 --> 00:16:15.176 A:middle
each vertex.

00:16:15.846 --> 00:16:19.366 A:middle
So, at this point we've created

00:16:19.366 --> 00:16:21.296 A:middle
a ray intersector and an

00:16:21.296 --> 00:16:22.396 A:middle
acceleration structure.

00:16:23.616 --> 00:16:25.226 A:middle
We then, generated primary rays

00:16:25.756 --> 00:16:26.846 A:middle
and found the intersections with

00:16:26.876 --> 00:16:27.356 A:middle
the scene.

00:16:28.336 --> 00:16:29.456 A:middle
We computed shading at the

00:16:29.456 --> 00:16:30.736 A:middle
intersection points, and then

00:16:30.736 --> 00:16:32.156 A:middle
wrote the shaded color into our

00:16:32.156 --> 00:16:32.536 A:middle
image.

00:16:33.026 --> 00:16:33.736 A:middle
So, let's take a look at the

00:16:33.736 --> 00:16:34.176 A:middle
image.

00:16:34.736 --> 00:16:37.156 A:middle
We can see the geometry

00:16:37.156 --> 00:16:38.506 A:middle
represented by the acceleration

00:16:38.506 --> 00:16:39.906 A:middle
structure, as well as the

00:16:39.906 --> 00:16:41.486 A:middle
interpolated vertex colors and

00:16:41.486 --> 00:16:42.586 A:middle
lighting we just computed.

00:16:43.596 --> 00:16:44.736 A:middle
Now that we have an image on

00:16:44.736 --> 00:16:46.186 A:middle
screen we're ready to add some

00:16:46.186 --> 00:16:46.926 A:middle
additional effects.

00:16:48.406 --> 00:16:49.796 A:middle
So, we'll start by adding

00:16:49.796 --> 00:16:50.896 A:middle
shadows to our image.

00:16:51.516 --> 00:16:55.376 A:middle
To do this, we need to check if

00:16:55.376 --> 00:16:57.406 A:middle
the light can actually reach the

00:16:57.406 --> 00:16:59.126 A:middle
shading point before adding it

00:16:59.126 --> 00:16:59.746 A:middle
to the image.


00:17:00.906 --> 00:17:02.106 A:middle
To do this we can cast

00:17:02.106 --> 00:17:03.976 A:middle
additional shadow rays from the

00:17:04.026 --> 00:17:05.296 A:middle
intersection points towards the

00:17:05.296 --> 00:17:05.996 A:middle
light source.

00:17:07.175 --> 00:17:08.965 A:middle
If a shadow ray doesn't make it

00:17:08.965 --> 00:17:10.156 A:middle
all the way to the light source,

00:17:10.215 --> 00:17:11.626 A:middle
then the original shaded point

00:17:11.626 --> 00:17:12.306 A:middle
wasn't shadow.

00:17:12.665 --> 00:17:13.796 A:middle
So, we shouldn't add its color

00:17:13.796 --> 00:17:14.415 A:middle
to the image.

00:17:17.076 --> 00:17:19.106 A:middle
We'll modify our shading kernel

00:17:19.806 --> 00:17:21.185 A:middle
to write out additional shadow

00:17:21.185 --> 00:17:22.695 A:middle
rays into another METAL buffer.

00:17:24.415 --> 00:17:25.445 A:middle
We'll then, find the

00:17:25.445 --> 00:17:26.486 A:middle
intersections with the scene,

00:17:26.486 --> 00:17:26.935 A:middle
again.

00:17:27.526 --> 00:17:29.366 A:middle
And then, we'll launch one final

00:17:29.366 --> 00:17:30.996 A:middle
kernel which will conditionally

00:17:30.996 --> 00:17:32.466 A:middle
write the shaded color into the

00:17:32.466 --> 00:17:34.136 A:middle
image based on whether or not

00:17:34.136 --> 00:17:35.216 A:middle
the shadow rays intersect at

00:17:35.216 --> 00:17:35.486 A:middle
anything.

00:17:36.646 --> 00:17:38.116 A:middle
So, let's start with the changes

00:17:38.116 --> 00:17:38.946 A:middle
to the shading kernel.

00:17:39.546 --> 00:17:42.106 A:middle
Now, shadow rays are a little

00:17:42.106 --> 00:17:43.366 A:middle
different than primary rays.

00:17:43.886 --> 00:17:45.876 A:middle
First, we need to provide a

00:17:45.876 --> 00:17:48.096 A:middle
maximum intersection distance so

00:17:48.096 --> 00:17:49.166 A:middle
that our shadow rays don't

00:17:49.166 --> 00:17:50.306 A:middle
overshoot the light source.

00:17:50.916 --> 00:17:54.106 A:middle
We also don't need to know which

00:17:54.106 --> 00:17:55.396 A:middle
triangle we hit or what the

00:17:55.396 --> 00:17:56.666 A:middle
barycentric coordinates were.

00:17:57.016 --> 00:17:58.146 A:middle
So, there are some optimizations

00:17:58.146 --> 00:17:58.576 A:middle
we can do.

00:17:58.886 --> 00:18:01.876 A:middle
And finally, remember that we


00:17:58.886 --> 00:18:01.876 A:middle
And finally, remember that we

00:18:01.876 --> 00:18:03.186 A:middle
can't write the shaded color

00:18:03.186 --> 00:18:04.736 A:middle
into the image until we know

00:18:04.736 --> 00:18:05.816 A:middle
whether or not the original

00:18:05.816 --> 00:18:07.106 A:middle
shading point was in shadow.

00:18:07.886 --> 00:18:09.386 A:middle
So, we need a way to pass the

00:18:09.386 --> 00:18:10.856 A:middle
color from the shading kernel

00:18:11.146 --> 00:18:12.806 A:middle
through the intersector, all the

00:18:12.806 --> 00:18:14.416 A:middle
way into the final kernel, which

00:18:14.416 --> 00:18:15.346 A:middle
will update the image.

00:18:16.356 --> 00:18:17.806 A:middle
To do this, we can customize our

00:18:17.806 --> 00:18:18.366 A:middle
ray struct.

00:18:20.716 --> 00:18:23.496 A:middle
So, first we have several

00:18:23.496 --> 00:18:24.726 A:middle
options for what data we

00:18:24.726 --> 00:18:25.686 A:middle
actually provide to the

00:18:25.686 --> 00:18:26.316 A:middle
intersector.

00:18:27.166 --> 00:18:28.626 A:middle
In this case, we'll use a data

00:18:28.626 --> 00:18:30.026 A:middle
type which includes minimum and

00:18:30.026 --> 00:18:31.276 A:middle
maximum distance fields.

00:18:32.416 --> 00:18:33.626 A:middle
MPS will ignore any

00:18:33.626 --> 00:18:34.996 A:middle
intersections outside of this

00:18:34.996 --> 00:18:36.356 A:middle
range, which will prevent our

00:18:36.356 --> 00:18:37.876 A:middle
shadow rays from overshooting

00:18:37.956 --> 00:18:39.676 A:middle
the light source.

00:18:40.146 --> 00:18:41.796 A:middle
Second, if you have

00:18:41.796 --> 00:18:43.256 A:middle
application-specific data

00:18:43.306 --> 00:18:45.246 A:middle
associated with your rays you

00:18:45.246 --> 00:18:46.536 A:middle
can append that data at the end

00:18:46.536 --> 00:18:47.946 A:middle
of the ray struct and provide a

00:18:47.946 --> 00:18:48.776 A:middle
rayStride.

00:18:49.766 --> 00:18:51.346 A:middle
MPS will skip past this data

00:18:51.346 --> 00:18:52.306 A:middle
when reading from your ray

00:18:52.306 --> 00:18:52.706 A:middle
buffer.

00:18:53.896 --> 00:18:55.176 A:middle
In this case, we'll add the

00:18:55.176 --> 00:18:56.466 A:middle
shade of color to the end of the

00:18:56.466 --> 00:18:58.096 A:middle
ray, so that we can propagate it

00:18:58.096 --> 00:18:59.546 A:middle
from the shading kernel through

00:18:59.546 --> 00:19:00.386 A:middle
to the final kernel.


00:18:59.546 --> 00:19:00.386 A:middle
to the final kernel.

00:19:00.956 --> 00:19:03.526 A:middle
We configure these options on

00:19:03.526 --> 00:19:04.406 A:middle
the ray intersector.

00:19:04.966 --> 00:19:07.496 A:middle
First, we'll set the rayDataType

00:19:07.496 --> 00:19:09.166 A:middle
to match our struct type.

00:19:10.056 --> 00:19:12.056 A:middle
Then, we'll set a rayStride to

00:19:12.056 --> 00:19:13.606 A:middle
skip past the color at the end

00:19:13.606 --> 00:19:16.166 A:middle
of the struct.

00:19:16.606 --> 00:19:17.726 A:middle
Next, we'll run the shadow rays

00:19:17.766 --> 00:19:18.626 A:middle
through the intersector.

00:19:19.106 --> 00:19:22.036 A:middle
This was our original call to

00:19:22.036 --> 00:19:22.816 A:middle
the intersector.

00:19:23.566 --> 00:19:24.756 A:middle
Remember that shadow rays are

00:19:24.756 --> 00:19:26.256 A:middle
only checking for visibility

00:19:26.256 --> 00:19:27.556 A:middle
between the original shading

00:19:27.556 --> 00:19:28.586 A:middle
point and the light source.

00:19:28.956 --> 00:19:30.086 A:middle
So, there are two optimizations

00:19:30.086 --> 00:19:30.486 A:middle
we can do.

00:19:31.596 --> 00:19:32.946 A:middle
First, just like we can

00:19:32.946 --> 00:19:35.076 A:middle
customize the rayDataType, we

00:19:35.076 --> 00:19:36.146 A:middle
can also customize the

00:19:36.146 --> 00:19:38.346 A:middle
intersection data type or what

00:19:38.346 --> 00:19:39.586 A:middle
data is returned to us by the

00:19:39.586 --> 00:19:40.206 A:middle
intersector.

00:19:41.516 --> 00:19:43.136 A:middle
In this case, we only need to

00:19:43.136 --> 00:19:44.416 A:middle
know if the distance is positive

00:19:44.416 --> 00:19:46.236 A:middle
or negative, indicating a hit or

00:19:46.236 --> 00:19:46.546 A:middle
a miss.

00:19:47.046 --> 00:19:48.726 A:middle
So, we can set the intersection

00:19:48.726 --> 00:19:50.196 A:middle
data type to just distance.

00:19:50.746 --> 00:19:51.756 A:middle
This will save some memory

00:19:51.756 --> 00:19:53.406 A:middle
bandwidth reading from and

00:19:53.406 --> 00:19:54.626 A:middle
writing to the intersection

00:19:54.626 --> 00:19:54.996 A:middle
buffer.

00:19:55.366 --> 00:19:58.946 A:middle
Second, because we don't,

00:19:58.946 --> 00:19:59.906 A:middle
actually, need to know which

00:19:59.906 --> 00:20:01.676 A:middle
triangle we hit, we can end the


00:19:59.906 --> 00:20:01.676 A:middle
triangle we hit, we can end the

00:20:01.676 --> 00:20:03.086 A:middle
intersection search as soon as

00:20:03.086 --> 00:20:03.976 A:middle
we hit any triangle.

00:20:04.736 --> 00:20:06.466 A:middle
This is, typically, much faster

00:20:06.466 --> 00:20:07.546 A:middle
than searching for the closest

00:20:07.546 --> 00:20:08.206 A:middle
intersection.

00:20:09.186 --> 00:20:10.926 A:middle
MPS has a special mode for this,

00:20:11.056 --> 00:20:12.786 A:middle
which we can turn on by passing

00:20:12.786 --> 00:20:14.906 A:middle
the any intersectionType instead

00:20:15.676 --> 00:20:17.936 A:middle
of nearest.

00:20:18.406 --> 00:20:19.936 A:middle
Finally, we can launch our last

00:20:19.936 --> 00:20:21.386 A:middle
kernel, which will add the color

00:20:21.386 --> 00:20:23.756 A:middle
to the image.

00:20:24.236 --> 00:20:25.886 A:middle
Each thread will read in one

00:20:25.886 --> 00:20:27.906 A:middle
shadow ray and the corresponding

00:20:27.906 --> 00:20:28.756 A:middle
intersection data.

00:20:29.896 --> 00:20:31.526 A:middle
If the intersection distance was

00:20:31.566 --> 00:20:33.216 A:middle
positive, then the original

00:20:33.216 --> 00:20:34.286 A:middle
intersection point was in

00:20:34.286 --> 00:20:34.796 A:middle
shadow.

00:20:35.156 --> 00:20:36.456 A:middle
So, there's nothing more to do.

00:20:37.576 --> 00:20:38.616 A:middle
Otherwise, the intersection

00:20:38.616 --> 00:20:39.766 A:middle
point wasn't in shadow.

00:20:40.716 --> 00:20:42.396 A:middle
So, we should read in the ray

00:20:42.396 --> 00:20:43.896 A:middle
color and write it into the

00:20:43.896 --> 00:20:44.546 A:middle
output image.

00:20:45.456 --> 00:20:46.936 A:middle
And that's all we need to do to

00:20:46.936 --> 00:20:48.096 A:middle
add shadows to our image.

00:20:48.716 --> 00:20:52.016 A:middle
We can see that each shaded

00:20:52.056 --> 00:20:53.476 A:middle
point is now checking whether or

00:20:53.476 --> 00:20:54.826 A:middle
not the light source is visible

00:20:54.826 --> 00:20:56.136 A:middle
before adding the lighting to

00:20:56.136 --> 00:20:56.616 A:middle
the image.

00:20:57.626 --> 00:20:59.056 A:middle
Because we're using a ray tracer

00:20:59.686 --> 00:21:01.026 A:middle
we can, also, randomly sample


00:20:59.686 --> 00:21:01.026 A:middle
we can, also, randomly sample

00:21:01.026 --> 00:21:02.336 A:middle
the surface of the light source,

00:21:02.516 --> 00:21:03.766 A:middle
which gives us these nice soft

00:21:03.766 --> 00:21:04.236 A:middle
shadows.

00:21:06.756 --> 00:21:09.156 A:middle
So last, we'll look at secondary

00:21:09.786 --> 00:21:09.926 A:middle
rays.

00:21:10.636 --> 00:21:12.626 A:middle
Remember that secondary rays

00:21:12.626 --> 00:21:14.136 A:middle
simulate light bouncing around

00:21:14.136 --> 00:21:14.636 A:middle
the scene.

00:21:15.646 --> 00:21:16.666 A:middle
All we need to do to add

00:21:16.666 --> 00:21:18.626 A:middle
secondary rays is move all of

00:21:18.626 --> 00:21:19.716 A:middle
our kernels into a loop.

00:21:20.136 --> 00:21:21.986 A:middle
In each iteration we'll choose a

00:21:21.986 --> 00:21:23.966 A:middle
new random direction to continue

00:21:23.966 --> 00:21:24.656 A:middle
they ray's path.

00:21:29.756 --> 00:21:31.716 A:middle
So, modify the shading kernel to

00:21:31.716 --> 00:21:33.206 A:middle
produce the rays for the next

00:21:33.406 --> 00:21:34.066 A:middle
iteration.

00:21:35.206 --> 00:21:36.356 A:middle
Once we finish updating our

00:21:36.356 --> 00:21:38.536 A:middle
image we can simply loop back to

00:21:38.536 --> 00:21:39.896 A:middle
the first intersection test.

00:21:40.766 --> 00:21:41.946 A:middle
And we can repeat this loop

00:21:41.946 --> 00:21:43.486 A:middle
however many times we want rays

00:21:43.486 --> 00:21:44.046 A:middle
to bounce.

00:21:46.576 --> 00:21:48.506 A:middle
So, let's look at the changes to

00:21:48.506 --> 00:21:49.236 A:middle
the shading kernel.

00:21:51.276 --> 00:21:53.946 A:middle
In each iteration we'll move the

00:21:53.946 --> 00:21:55.366 A:middle
ray origin to the intersection

00:21:55.366 --> 00:21:55.686 A:middle
point.

00:21:56.256 --> 00:21:58.536 A:middle
We'll then, choose a random

00:21:58.536 --> 00:21:59.916 A:middle
direction to continue the path.


00:22:01.076 --> 00:22:03.646 A:middle
And finally, we'll multiply the

00:22:03.646 --> 00:22:04.936 A:middle
ray color by the interpolated

00:22:04.936 --> 00:22:05.676 A:middle
vertex color.

00:22:06.906 --> 00:22:07.916 A:middle
This will cause the light to

00:22:07.916 --> 00:22:09.406 A:middle
take on the color of whatever

00:22:09.406 --> 00:22:10.806 A:middle
surface it bounces off of.

00:22:11.266 --> 00:22:13.326 A:middle
In a more advanced application,

00:22:13.506 --> 00:22:14.546 A:middle
this would be a much more

00:22:14.546 --> 00:22:15.926 A:middle
complicated calculation.

00:22:16.406 --> 00:22:17.616 A:middle
But by choosing the random ray

00:22:17.616 --> 00:22:19.196 A:middle
directions, carefully, we can

00:22:19.196 --> 00:22:20.076 A:middle
actually get the rest of the

00:22:20.076 --> 00:22:21.306 A:middle
math to cancel out.

00:22:21.866 --> 00:22:23.666 A:middle
And this works even though we're

00:22:23.666 --> 00:22:24.606 A:middle
working backwards from the

00:22:24.606 --> 00:22:26.366 A:middle
camera as long as we're careful

00:22:26.366 --> 00:22:28.196 A:middle
to tint the direct lighting by

00:22:28.196 --> 00:22:29.166 A:middle
the ray color at each

00:22:29.166 --> 00:22:29.976 A:middle
intersection point.

00:22:30.526 --> 00:22:32.736 A:middle
So, that's all we need to do for

00:22:32.736 --> 00:22:33.496 A:middle
secondary rays.

00:22:34.756 --> 00:22:36.446 A:middle
So, we can see that light has

00:22:36.446 --> 00:22:37.506 A:middle
started to bounce off of the

00:22:37.506 --> 00:22:39.256 A:middle
walls and onto the sides of the

00:22:39.256 --> 00:22:40.426 A:middle
boxes and ceiling.

00:22:40.996 --> 00:22:43.396 A:middle
So, that's it for our example

00:22:43.686 --> 00:22:44.596 A:middle
app.

00:22:44.906 --> 00:22:46.026 A:middle
We started by getting an image

00:22:46.026 --> 00:22:48.076 A:middle
on screen with primary rays and

00:22:48.076 --> 00:22:48.596 A:middle
shading.

00:22:49.696 --> 00:22:50.866 A:middle
Then, we added shadows.

00:22:51.376 --> 00:22:53.266 A:middle
And finally, we simulated light

00:22:53.266 --> 00:22:54.256 A:middle
bouncing around the scene with

00:22:54.256 --> 00:22:55.046 A:middle
secondary rays.

00:22:56.226 --> 00:22:58.246 A:middle
So, let's switch to the demo and

00:22:58.246 --> 00:22:59.226 A:middle
take a look at this running

00:22:59.226 --> 00:22:59.536 A:middle
live.


00:23:04.076 --> 00:23:05.106 A:middle
So, here's the application we

00:23:05.106 --> 00:23:06.796 A:middle
just wrote up and running on the

00:23:06.796 --> 00:23:08.546 A:middle
12.9-inch iPad Pro.

00:23:09.466 --> 00:23:10.736 A:middle
We've, actually, extended this

00:23:10.736 --> 00:23:12.656 A:middle
application to support more

00:23:12.656 --> 00:23:14.366 A:middle
advanced lighting, shading,

00:23:14.366 --> 00:23:15.486 A:middle
textures, and more.

00:23:16.126 --> 00:23:17.326 A:middle
So, let's switch to a more

00:23:17.326 --> 00:23:19.326 A:middle
complicated scene, which used

00:23:19.326 --> 00:23:20.236 A:middle
many of these features.

00:23:26.046 --> 00:23:27.296 A:middle
Here's the Amazon Lumberyard

00:23:27.296 --> 00:23:29.086 A:middle
Bistro scene you saw running in

00:23:29.086 --> 00:23:31.146 A:middle
the State of the Union on four

00:23:31.146 --> 00:23:31.836 A:middle
GPUs.

00:23:32.756 --> 00:23:34.346 A:middle
The scene has almost one million

00:23:34.346 --> 00:23:34.976 A:middle
triangles.

00:23:35.506 --> 00:23:36.516 A:middle
But, even with these advanced

00:23:36.516 --> 00:23:37.736 A:middle
lighting and shading techniques

00:23:38.096 --> 00:23:39.346 A:middle
we're still able to achieve

00:23:39.346 --> 00:23:40.666 A:middle
almost 20 million rays per

00:23:40.666 --> 00:23:41.916 A:middle
second on an iPad Pro.

00:23:42.166 --> 00:23:43.216 A:middle
And that's a combined

00:23:43.216 --> 00:23:45.046 A:middle
measurement including primary,

00:23:45.246 --> 00:23:46.636 A:middle
shadow, and secondary rays.

00:23:48.406 --> 00:23:49.676 A:middle
So, we've created what we think

00:23:49.956 --> 00:23:51.986 A:middle
is an easy to use API that you

00:23:51.986 --> 00:23:53.276 A:middle
can use to start implementing

00:23:53.276 --> 00:23:54.296 A:middle
these types of applications

00:23:54.366 --> 00:23:54.696 A:middle
today.

00:23:56.106 --> 00:23:57.166 A:middle
So, that's if for our demo, for

00:23:57.166 --> 00:23:57.416 A:middle
now.

00:23:58.766 --> 00:23:59.546 A:middle
Thank you.


00:24:00.516 --> 00:24:03.026 A:middle
[ Applause ]

00:24:03.526 --> 00:24:04.346 A:middle
So, don't worry if you didn't

00:24:04.346 --> 00:24:05.896 A:middle
catch all of that because this

00:24:05.896 --> 00:24:07.096 A:middle
application will be available

00:24:07.096 --> 00:24:08.416 A:middle
for download as a sample.

00:24:09.156 --> 00:24:10.086 A:middle
The sample demonstrates

00:24:10.086 --> 00:24:11.106 A:middle
everything I've talked about

00:24:11.106 --> 00:24:11.946 A:middle
today and more.

00:24:12.716 --> 00:24:13.686 A:middle
We recommend that you get

00:24:13.686 --> 00:24:14.776 A:middle
started by downloading the

00:24:14.776 --> 00:24:16.246 A:middle
sample and adding your own

00:24:16.246 --> 00:24:18.266 A:middle
geometry, lighting, shading, and

00:24:18.266 --> 00:24:18.716 A:middle
so on.

00:24:19.576 --> 00:24:20.746 A:middle
There's, also, a lot more to the

00:24:20.746 --> 00:24:22.446 A:middle
API that I didn't have time to

00:24:22.446 --> 00:24:23.236 A:middle
talk about, today.

00:24:23.826 --> 00:24:24.766 A:middle
So, we, also, recommend that you

00:24:24.766 --> 00:24:26.296 A:middle
take a look at the documentation

00:24:26.296 --> 00:24:26.776 A:middle
and headers.

00:24:27.896 --> 00:24:29.216 A:middle
And with that, I'll hand it off

00:24:29.216 --> 00:24:30.906 A:middle
to my colleague, Wayne, who will

00:24:30.906 --> 00:24:32.086 A:middle
talk about how we can extend

00:24:32.086 --> 00:24:33.366 A:middle
this to multiple GPUs.

00:24:35.396 --> 00:24:35.886 A:middle
Thank you.

00:24:36.516 --> 00:24:41.666 A:middle
[ Applause ]

00:24:42.166 --> 00:24:42.566 A:middle
&gt;&gt; Thanks, Sean.

00:24:43.076 --> 00:24:44.000 A:middle
Hi, everyone.

00:24:48.046 --> 00:24:49.306 A:middle
So, say you're working on your

00:24:49.306 --> 00:24:49.566 A:middle
Mac.

00:24:50.456 --> 00:24:51.996 A:middle
It has an internal GPU.

00:24:52.556 --> 00:24:53.726 A:middle
But you've, also, plugged in a

00:24:53.726 --> 00:24:54.666 A:middle
couple or really high

00:24:54.666 --> 00:24:56.116 A:middle
performance eGPUs.

00:24:56.586 --> 00:24:58.436 A:middle
And what we'd like to be able to

00:24:58.436 --> 00:25:00.646 A:middle
do is use all of these GPUs


00:24:58.436 --> 00:25:00.646 A:middle
do is use all of these GPUs

00:25:00.646 --> 00:25:02.356 A:middle
together to make Ray Tracing go

00:25:02.356 --> 00:25:05.336 A:middle
as fast as we possibly can.

00:25:05.336 --> 00:25:06.626 A:middle
So, how are we going to do this?

00:25:06.886 --> 00:25:08.506 A:middle
Well, there's three things we

00:25:08.506 --> 00:25:09.136 A:middle
need to think about.

00:25:10.026 --> 00:25:11.956 A:middle
First of all, how are we going

00:25:11.956 --> 00:25:13.806 A:middle
to divide up the work between

00:25:15.056 --> 00:25:15.176 A:middle
GPUs?

00:25:15.786 --> 00:25:18.586 A:middle
Secondly, at some point the GPUs

00:25:18.586 --> 00:25:19.486 A:middle
are going to need a way to

00:25:19.486 --> 00:25:20.216 A:middle
exchange data.

00:25:20.766 --> 00:25:22.066 A:middle
So, how are we going to deal

00:25:22.066 --> 00:25:23.316 A:middle
with that?

00:25:23.846 --> 00:25:25.346 A:middle
And finally, we need a way to

00:25:25.346 --> 00:25:26.596 A:middle
keep everything synchronized.

00:25:27.046 --> 00:25:28.676 A:middle
Now, for this, I'll show you how

00:25:28.676 --> 00:25:29.756 A:middle
to use the new METAL Events

00:25:29.756 --> 00:25:31.056 A:middle
feature that we're introducing

00:25:31.056 --> 00:25:31.616 A:middle
here, this week.

00:25:32.706 --> 00:25:33.426 A:middle
So, let's get started.

00:25:34.146 --> 00:25:36.676 A:middle
So, to divide up the work we're

00:25:36.676 --> 00:25:37.626 A:middle
going to use something called

00:25:37.626 --> 00:25:38.816 A:middle
Split Frame Rendering.

00:25:39.846 --> 00:25:41.756 A:middle
The idea here is to partition

00:25:41.756 --> 00:25:42.976 A:middle
our frame into regions.

00:25:43.086 --> 00:25:44.576 A:middle
And then, we'll assign each of

00:25:44.576 --> 00:25:45.806 A:middle
these regions to a different

00:25:45.806 --> 00:25:47.386 A:middle
GPU, so that they can be

00:25:47.386 --> 00:25:48.276 A:middle
rendered in parallel.

00:25:49.926 --> 00:25:51.696 A:middle
Now, each GPU will run the full

00:25:51.736 --> 00:25:52.936 A:middle
rendering pipeline that Sean

00:25:52.936 --> 00:25:53.586 A:middle
described earlier.

00:25:54.216 --> 00:25:55.426 A:middle
So, that's everything from

00:25:55.426 --> 00:25:57.156 A:middle
initial ray generation right

00:25:57.156 --> 00:25:58.336 A:middle
through to shadow rays and

00:25:58.336 --> 00:25:58.666 A:middle
shading.


00:26:00.376 --> 00:26:01.956 A:middle
Now, once all GPUs have finished

00:26:02.296 --> 00:26:03.686 A:middle
we'll pick whichever one is

00:26:03.686 --> 00:26:06.006 A:middle
connected to the display and

00:26:06.006 --> 00:26:07.116 A:middle
we'll copy across all of our

00:26:07.116 --> 00:26:08.196 A:middle
completed regions for

00:26:08.196 --> 00:26:08.746 A:middle
composition.

00:26:09.346 --> 00:26:12.136 A:middle
Now, composition could just be

00:26:12.136 --> 00:26:13.656 A:middle
stitching the regions together

00:26:13.656 --> 00:26:15.116 A:middle
into one frame buffer.

00:26:16.046 --> 00:26:17.226 A:middle
Or you might want to combine

00:26:17.226 --> 00:26:18.416 A:middle
them with the results of a

00:26:18.416 --> 00:26:20.076 A:middle
previous render to refine the

00:26:20.076 --> 00:26:21.366 A:middle
image and remove noise.

00:26:21.926 --> 00:26:24.816 A:middle
Now, before we can render

00:26:24.816 --> 00:26:26.346 A:middle
anything, we need to make sure

00:26:26.346 --> 00:26:27.846 A:middle
that each GPU has a complete

00:26:27.846 --> 00:26:28.696 A:middle
copy of the scene.

00:26:30.166 --> 00:26:31.936 A:middle
Assets, such as your vertex

00:26:31.936 --> 00:26:33.476 A:middle
buffers and your textures need

00:26:33.476 --> 00:26:35.316 A:middle
to be replicated on all GPUs.

00:26:36.576 --> 00:26:37.516 A:middle
And so, do the triangle

00:26:37.516 --> 00:26:38.656 A:middle
acceleration structures that

00:26:38.656 --> 00:26:41.086 A:middle
Sean introduced earlier.

00:26:42.126 --> 00:26:44.086 A:middle
Now, for the acceleration

00:26:44.086 --> 00:26:45.906 A:middle
structures, we really wanted to

00:26:45.906 --> 00:26:47.106 A:middle
avoid you having to build them

00:26:47.106 --> 00:26:48.626 A:middle
from scratch for each GPU.

00:26:49.546 --> 00:26:51.876 A:middle
So, we added an API that enables

00:26:51.876 --> 00:26:52.906 A:middle
you to take an existing

00:26:52.906 --> 00:26:54.866 A:middle
acceleration structure and make

00:26:54.866 --> 00:26:56.226 A:middle
a copy for each GPU that you

00:26:56.226 --> 00:26:56.776 A:middle
want to use.

00:26:58.156 --> 00:27:00.386 A:middle
Now, this copy is nonrecursive.


00:26:58.156 --> 00:27:00.386 A:middle
Now, this copy is nonrecursive.

00:27:01.086 --> 00:27:02.146 A:middle
So, any buffers that you have

00:27:02.146 --> 00:27:03.446 A:middle
attached to your acceleration

00:27:03.446 --> 00:27:04.966 A:middle
structure, for example, your

00:27:04.966 --> 00:27:06.556 A:middle
vertex and your index buffers,

00:27:07.626 --> 00:27:08.406 A:middle
you'll need to copy those

00:27:08.406 --> 00:27:08.896 A:middle
separately.

00:27:09.196 --> 00:27:10.446 A:middle
And then, attach them to the

00:27:10.446 --> 00:27:11.706 A:middle
acceleration structure that we

00:27:11.706 --> 00:27:12.286 A:middle
just created.

00:27:12.286 --> 00:27:17.596 A:middle
So, now that the data is

00:27:17.596 --> 00:27:19.076 A:middle
replicated on all GPUs we're

00:27:19.136 --> 00:27:20.116 A:middle
ready to start rendering.

00:27:21.996 --> 00:27:23.286 A:middle
Now, the interesting thing for

00:27:23.286 --> 00:27:25.176 A:middle
our multi-GPU perspective is

00:27:25.256 --> 00:27:26.886 A:middle
that this part of the pipeline

00:27:26.886 --> 00:27:28.376 A:middle
is virtually unchanged from what

00:27:28.376 --> 00:27:29.206 A:middle
Sean described earlier.

00:27:30.246 --> 00:27:31.376 A:middle
The only difference we need to

00:27:31.376 --> 00:27:33.416 A:middle
make for multi-GPU is to

00:27:33.416 --> 00:27:34.816 A:middle
restrict regeneration to

00:27:34.816 --> 00:27:36.156 A:middle
whichever part of the screen a

00:27:36.156 --> 00:27:37.636 A:middle
particular GPU is working on.

00:27:38.486 --> 00:27:39.586 A:middle
Everything else is the same.

00:27:40.466 --> 00:27:42.516 A:middle
So, for that reason, let's move

00:27:42.516 --> 00:27:44.096 A:middle
straight on to what's, probably,

00:27:44.256 --> 00:27:45.176 A:middle
the trickiest stage for

00:27:45.176 --> 00:27:47.416 A:middle
multi-GPU, and that's its final

00:27:47.416 --> 00:27:50.426 A:middle
composition phase here.

00:27:51.396 --> 00:27:53.326 A:middle
Now, for best performance on

00:27:53.326 --> 00:27:55.616 A:middle
macOS, each GPU will render into

00:27:55.616 --> 00:27:56.846 A:middle
its own private buffer.

00:27:57.146 --> 00:27:59.446 A:middle
And once rendering has finished

00:27:59.866 --> 00:28:01.456 A:middle
we need to copy that buffer over


00:27:59.866 --> 00:28:01.456 A:middle
we need to copy that buffer over

00:28:01.456 --> 00:28:03.136 A:middle
to whichever GPU we're using for

00:28:03.136 --> 00:28:03.636 A:middle
composition.

00:28:04.656 --> 00:28:06.216 A:middle
Now, we can't copy between the

00:28:06.216 --> 00:28:07.886 A:middle
buffers, directly, because METAL

00:28:07.886 --> 00:28:09.346 A:middle
resources can only be used on

00:28:09.346 --> 00:28:10.096 A:middle
the device that they were

00:28:10.096 --> 00:28:10.886 A:middle
created on.

00:28:11.036 --> 00:28:12.776 A:middle
So, you can't create a buffer on

00:28:12.776 --> 00:28:14.416 A:middle
one GPU, and then try and attach

00:28:14.416 --> 00:28:15.576 A:middle
it to a Blit encoder on a

00:28:15.576 --> 00:28:16.296 A:middle
different GPU.

00:28:16.296 --> 00:28:17.416 A:middle
That's just not going to work.

00:28:18.136 --> 00:28:19.986 A:middle
So, this means that our copies

00:28:19.986 --> 00:28:20.986 A:middle
will need to go through system

00:28:20.986 --> 00:28:21.296 A:middle
memory.

00:28:21.906 --> 00:28:24.806 A:middle
Now, to make this as efficient

00:28:24.806 --> 00:28:26.286 A:middle
as we can, we use the buffer

00:28:26.286 --> 00:28:27.506 A:middle
arrangement that you see here.

00:28:28.136 --> 00:28:30.516 A:middle
We're going to create two METAL

00:28:30.516 --> 00:28:32.796 A:middle
buffers; one on each device that

00:28:32.796 --> 00:28:34.686 A:middle
wrap a common CPU allocation.

00:28:35.726 --> 00:28:37.576 A:middle
And as the buffers wrap the same

00:28:37.576 --> 00:28:39.676 A:middle
underlying memory anything that

00:28:39.676 --> 00:28:40.906 A:middle
is written into the METAL buffer

00:28:40.906 --> 00:28:43.456 A:middle
on device A is, also, visible to

00:28:43.456 --> 00:28:44.996 A:middle
the METAL buffer on device B.

00:28:45.586 --> 00:28:48.586 A:middle
Now, as I mentioned earlier, for

00:28:49.096 --> 00:28:51.296 A:middle
performance reasons on macOS all

00:28:51.296 --> 00:28:52.866 A:middle
of the actual rendering work is

00:28:52.906 --> 00:28:54.106 A:middle
done using private buffers.

00:28:55.166 --> 00:28:56.626 A:middle
And then, we Blit our completed

00:28:56.626 --> 00:28:58.016 A:middle
regions through system memory

00:28:58.296 --> 00:28:59.426 A:middle
when it's time to copy them to a

00:28:59.426 --> 00:29:00.126 A:middle
different GPU.


00:28:59.426 --> 00:29:00.126 A:middle
different GPU.

00:29:00.566 --> 00:29:03.136 A:middle
So, here's a quick look at how

00:29:03.136 --> 00:29:03.766 A:middle
to set this up.

00:29:04.556 --> 00:29:06.266 A:middle
First, we create our buffer on

00:29:06.266 --> 00:29:07.976 A:middle
device A, using METAL shared

00:29:07.976 --> 00:29:08.616 A:middle
storage mode.

00:29:08.896 --> 00:29:11.036 A:middle
And this allocates system

00:29:11.036 --> 00:29:11.916 A:middle
memory, internally.

00:29:11.916 --> 00:29:13.786 A:middle
And we can get appointed to it

00:29:13.896 --> 00:29:15.196 A:middle
using the .contents method.

00:29:15.736 --> 00:29:19.646 A:middle
We, then create a buffer on

00:29:19.646 --> 00:29:22.596 A:middle
device B using the NoCopy API to

00:29:22.596 --> 00:29:23.706 A:middle
wrap the memory that we just

00:29:23.706 --> 00:29:25.606 A:middle
allocated to buffer A.

00:29:26.726 --> 00:29:28.096 A:middle
Now, something to be aware of

00:29:28.146 --> 00:29:30.116 A:middle
for this API is that the buffer

00:29:30.516 --> 00:29:31.686 A:middle
needs to be a multiple of page

00:29:31.686 --> 00:29:31.976 A:middle
size.

00:29:31.976 --> 00:29:33.626 A:middle
So, you'll need to pad the

00:29:33.626 --> 00:29:34.626 A:middle
length when you create the

00:29:34.626 --> 00:29:35.186 A:middle
original buffer.

00:29:35.986 --> 00:29:39.996 A:middle
So, now that we're able to share

00:29:39.996 --> 00:29:41.686 A:middle
memory between devices we need

00:29:41.686 --> 00:29:42.966 A:middle
to think about synchronization.

00:29:43.956 --> 00:29:45.286 A:middle
Now, to help with this we have

00:29:45.286 --> 00:29:46.746 A:middle
an example timeline here to help

00:29:46.746 --> 00:29:48.356 A:middle
us visualize two GPUs running in

00:29:48.356 --> 00:29:48.776 A:middle
parallel.

00:29:49.206 --> 00:29:51.156 A:middle
The dark boxes represent command

00:29:51.156 --> 00:29:53.096 A:middle
buffers and the green boxes

00:29:53.096 --> 00:29:54.046 A:middle
represent work that we've

00:29:54.046 --> 00:29:55.416 A:middle
encoded into those command

00:29:55.416 --> 00:29:55.806 A:middle
buffers.

00:29:56.266 --> 00:29:57.766 A:middle
For example, using a compute

00:29:57.766 --> 00:29:58.476 A:middle
command encoder.

00:29:59.466 --> 00:30:01.966 A:middle
So, the GPU at the top there, is


00:29:59.466 --> 00:30:01.966 A:middle
So, the GPU at the top there, is

00:30:01.966 --> 00:30:02.786 A:middle
going to do some rendering.

00:30:03.416 --> 00:30:05.046 A:middle
And when it's finished, it'll

00:30:05.046 --> 00:30:06.616 A:middle
Blit its completed region into

00:30:06.616 --> 00:30:07.546 A:middle
the shared buffers that we were

00:30:07.546 --> 00:30:08.826 A:middle
just talking about.

00:30:09.626 --> 00:30:12.486 A:middle
Now, while that's going on GPU B

00:30:12.486 --> 00:30:13.626 A:middle
is, also, doing some rendering.

00:30:15.096 --> 00:30:16.326 A:middle
Now, this is the GPU that we're

00:30:16.326 --> 00:30:17.476 A:middle
going to use for composition.

00:30:18.146 --> 00:30:19.716 A:middle
So, at some point it's going to

00:30:19.716 --> 00:30:20.866 A:middle
need the buffer that was

00:30:20.866 --> 00:30:21.886 A:middle
produced by GPU A.

00:30:21.886 --> 00:30:23.876 A:middle
Now, we can see here that we

00:30:23.876 --> 00:30:24.676 A:middle
have a problem.

00:30:25.466 --> 00:30:27.396 A:middle
There's no synchronization in

00:30:27.396 --> 00:30:28.036 A:middle
this area, here.

00:30:28.306 --> 00:30:30.196 A:middle
So, there's nothing to prevent

00:30:30.196 --> 00:30:31.616 A:middle
GPU B from trying to read the

00:30:31.676 --> 00:30:33.496 A:middle
buffer before GPU A has finished

00:30:33.496 --> 00:30:34.006 A:middle
writing to it.

00:30:35.696 --> 00:30:37.046 A:middle
Now, to deal with this we can

00:30:37.046 --> 00:30:37.846 A:middle
use METAL Events.

00:30:39.116 --> 00:30:40.426 A:middle
With METAL Events, we'll insert

00:30:40.506 --> 00:30:41.956 A:middle
a wait into the command buffer.

00:30:43.066 --> 00:30:44.576 A:middle
So, while the GPU is executing,

00:30:44.646 --> 00:30:46.116 A:middle
it'll reach the wait, and then

00:30:46.116 --> 00:30:47.186 A:middle
it's just going to stop.

00:30:47.186 --> 00:30:50.096 A:middle
And what it's waiting for is a

00:30:50.096 --> 00:30:51.526 A:middle
signal from the other GPU.

00:30:51.976 --> 00:30:55.516 A:middle
Once that signal is received we

00:30:55.516 --> 00:30:56.936 A:middle
know that GPU A has finished

00:30:56.936 --> 00:30:58.376 A:middle
writing to the buffer and it's

00:30:58.376 --> 00:31:00.766 A:middle
now safe for GPU B to access it.


00:30:58.376 --> 00:31:00.766 A:middle
now safe for GPU B to access it.

00:31:01.816 --> 00:31:04.096 A:middle
So, this is an elegant way to

00:31:04.096 --> 00:31:05.446 A:middle
fix our synchronization problem.

00:31:06.826 --> 00:31:08.696 A:middle
But, clearly, having a GPU,

00:31:08.856 --> 00:31:10.496 A:middle
potentially, a very powerful GPU

00:31:10.496 --> 00:31:11.936 A:middle
just sitting there waiting is

00:31:12.206 --> 00:31:12.746 A:middle
not good.

00:31:13.706 --> 00:31:15.106 A:middle
So, we need to make this wait as

00:31:15.106 --> 00:31:17.056 A:middle
short as possible and, ideally,

00:31:17.056 --> 00:31:18.626 A:middle
we want the GPU working instead

00:31:18.626 --> 00:31:19.006 A:middle
of waiting.

00:31:19.056 --> 00:31:21.726 A:middle
So, what I'm talking about,

00:31:21.776 --> 00:31:22.946 A:middle
here, is load balancing.

00:31:23.586 --> 00:31:25.916 A:middle
So currently, we just split the

00:31:25.916 --> 00:31:27.756 A:middle
screen equally between GPUs.

00:31:27.916 --> 00:31:29.126 A:middle
And there's a couple of problems

00:31:29.126 --> 00:31:29.526 A:middle
with this.

00:31:30.376 --> 00:31:31.846 A:middle
Firstly, it doesn't take into

00:31:31.846 --> 00:31:33.116 A:middle
account that you might be using

00:31:33.116 --> 00:31:34.466 A:middle
GPUs of different performance.

00:31:35.676 --> 00:31:37.276 A:middle
If one GPU is much faster than

00:31:37.276 --> 00:31:38.156 A:middle
the other, then it stands to

00:31:38.156 --> 00:31:39.206 A:middle
reason that, yeah, it's going to

00:31:39.206 --> 00:31:39.926 A:middle
finish first.

00:31:41.086 --> 00:31:43.386 A:middle
And the other problem is that

00:31:43.666 --> 00:31:44.696 A:middle
some parts of the screen are

00:31:44.696 --> 00:31:45.936 A:middle
more complicated to render than

00:31:45.936 --> 00:31:46.216 A:middle
others.

00:31:46.216 --> 00:31:46.766 A:middle
They take longer.

00:31:47.536 --> 00:31:48.586 A:middle
They might have more complex

00:31:48.586 --> 00:31:50.006 A:middle
geometry or more complex

00:31:50.006 --> 00:31:50.596 A:middle
materials.

00:31:52.316 --> 00:31:53.966 A:middle
So, to fix this, we need to

00:31:53.966 --> 00:31:55.246 A:middle
adjust our region sizes

00:31:55.246 --> 00:31:55.846 A:middle
adaptively.

00:31:56.866 --> 00:31:58.406 A:middle
Now, the aim here is for each

00:31:58.406 --> 00:32:00.056 A:middle
GPU to take, approximately, the


00:31:58.406 --> 00:32:00.056 A:middle
GPU to take, approximately, the

00:32:00.056 --> 00:32:01.796 A:middle
same amount of time to render

00:32:01.796 --> 00:32:04.176 A:middle
its part of the scene.

00:32:04.306 --> 00:32:05.736 A:middle
Now, the way we do this is we

00:32:05.736 --> 00:32:07.326 A:middle
start with the fixed partitions

00:32:07.326 --> 00:32:09.096 A:middle
that you see here, and we render

00:32:09.096 --> 00:32:09.426 A:middle
a frame.

00:32:09.716 --> 00:32:12.296 A:middle
And we time how long each GPU is

00:32:12.296 --> 00:32:12.956 A:middle
working for.

00:32:12.956 --> 00:32:14.836 A:middle
And then, we use that to decide

00:32:14.836 --> 00:32:16.166 A:middle
how big a region to give each

00:32:16.166 --> 00:32:17.236 A:middle
GPU the next time around.

00:32:17.366 --> 00:32:21.276 A:middle
And we do this the whole time

00:32:21.276 --> 00:32:22.246 A:middle
your application is running.

00:32:23.166 --> 00:32:24.756 A:middle
So, it constantly adapts to the

00:32:24.756 --> 00:32:26.036 A:middle
performance of the GPUs that you

00:32:26.036 --> 00:32:26.676 A:middle
have connected.

00:32:27.206 --> 00:32:28.686 A:middle
And wherever you are and

00:32:28.686 --> 00:32:29.596 A:middle
wherever you're looking in your

00:32:29.596 --> 00:32:29.886 A:middle
scene.

00:32:30.446 --> 00:32:34.876 A:middle
So, to measure how hard a GPU is

00:32:34.876 --> 00:32:36.346 A:middle
working, we use command buffer

00:32:36.346 --> 00:32:37.236 A:middle
completion handlers.

00:32:38.746 --> 00:32:40.426 A:middle
Now, completion handler is a

00:32:40.516 --> 00:32:42.206 A:middle
block of CPU code that you can

00:32:42.206 --> 00:32:43.686 A:middle
have run after the GPU has

00:32:43.686 --> 00:32:44.916 A:middle
finished executing your command

00:32:44.916 --> 00:32:45.146 A:middle
buffer.

00:32:46.826 --> 00:32:49.776 A:middle
Now, on iOS command buffers have

00:32:49.776 --> 00:32:50.986 A:middle
a couple of useful properties

00:32:50.986 --> 00:32:52.576 A:middle
that you can read to find out

00:32:52.576 --> 00:32:53.936 A:middle
how long it took to run on the

00:32:53.936 --> 00:32:54.266 A:middle
GPU.

00:32:55.616 --> 00:32:56.726 A:middle
But these aren't available on

00:32:56.726 --> 00:32:57.366 A:middle
macOS.

00:32:57.436 --> 00:32:58.616 A:middle
So, we need to come up with an

00:32:58.616 --> 00:32:59.276 A:middle
approximation.

00:32:59.456 --> 00:33:02.186 A:middle
And the way we do this is we


00:32:59.456 --> 00:33:02.186 A:middle
And the way we do this is we

00:33:02.186 --> 00:33:03.846 A:middle
store the host time when each

00:33:03.846 --> 00:33:04.776 A:middle
command buffer completion

00:33:04.776 --> 00:33:05.456 A:middle
handler was called.

00:33:05.526 --> 00:33:07.366 A:middle
And if you do this for every

00:33:07.366 --> 00:33:09.256 A:middle
command buffer, you can then use

00:33:09.256 --> 00:33:10.346 A:middle
the differences between these

00:33:10.346 --> 00:33:11.456 A:middle
times to figure out how long the

00:33:11.456 --> 00:33:12.376 A:middle
GPU was running for.

00:33:13.416 --> 00:33:15.976 A:middle
So, for example, to estimate how

00:33:15.976 --> 00:33:17.106 A:middle
long the three command buffers

00:33:17.106 --> 00:33:19.096 A:middle
shown here took execute, we've

00:33:19.096 --> 00:33:20.266 A:middle
measured the time between the

00:33:20.266 --> 00:33:21.386 A:middle
completion handler was called

00:33:21.386 --> 00:33:23.356 A:middle
for command buffer 3 and command

00:33:23.356 --> 00:33:23.816 A:middle
buffer 0.

00:33:25.276 --> 00:33:27.996 A:middle
So, that's the theory.

00:33:28.286 --> 00:33:29.586 A:middle
And now, let's see it in action.

00:33:42.126 --> 00:33:42.326 A:middle
All right.

00:33:42.326 --> 00:33:43.436 A:middle
So, this is the Amazon

00:33:43.436 --> 00:33:44.836 A:middle
Lumberyard Bistro scene that

00:33:44.836 --> 00:33:46.586 A:middle
Sean was showing you earlier.

00:33:47.586 --> 00:33:48.776 A:middle
And this time, it's running on a

00:33:48.776 --> 00:33:49.456 A:middle
MacBook Pro.

00:33:49.456 --> 00:33:52.126 A:middle
And you can see in the top left

00:33:52.126 --> 00:33:53.176 A:middle
of the screen here, we have a

00:33:53.176 --> 00:33:54.376 A:middle
rays per second metric.

00:33:54.896 --> 00:33:56.176 A:middle
As you can get an idea for how

00:33:56.176 --> 00:33:56.566 A:middle
it's running.

00:33:57.156 --> 00:33:59.566 A:middle
So, this includes the primary

00:33:59.566 --> 00:34:01.266 A:middle
rays, secondary rays, and the


00:33:59.566 --> 00:34:01.266 A:middle
rays, secondary rays, and the

00:34:01.266 --> 00:34:01.756 A:middle
shadow rays.

00:34:01.756 --> 00:34:02.766 A:middle
They're all included in this

00:34:02.766 --> 00:34:03.166 A:middle
metric.

00:34:03.646 --> 00:34:05.396 A:middle
So, you can see, we're getting

00:34:05.396 --> 00:34:06.796 A:middle
about 30 million rays per

00:34:06.796 --> 00:34:07.226 A:middle
second.

00:34:07.376 --> 00:34:09.126 A:middle
And it'd be nice if we were

00:34:09.126 --> 00:34:10.456 A:middle
going a little faster.

00:34:10.505 --> 00:34:12.016 A:middle
So, I'm going to enable one of

00:34:12.016 --> 00:34:13.606 A:middle
the eGPUs that I have connected,

00:34:13.606 --> 00:34:13.755 A:middle
here.

00:34:13.886 --> 00:34:18.056 A:middle
So, you can see from the text

00:34:18.056 --> 00:34:19.206 A:middle
there, we're now running on an

00:34:19.206 --> 00:34:21.266 A:middle
RX 580, as well as the internal

00:34:21.266 --> 00:34:21.926 A:middle
GPU, here.

00:34:22.646 --> 00:34:24.045 A:middle
And performance has doubled to

00:34:24.045 --> 00:34:25.416 A:middle
about 60 million rays per

00:34:25.416 --> 00:34:25.806 A:middle
second.

00:34:26.846 --> 00:34:27.916 A:middle
And you can also see the green

00:34:27.916 --> 00:34:29.005 A:middle
lines here that we're using to

00:34:29.005 --> 00:34:30.366 A:middle
help visualize how the load is

00:34:30.366 --> 00:34:31.576 A:middle
split between GPUs.

00:34:32.196 --> 00:34:33.795 A:middle
So, one GPU is rendering

00:34:33.795 --> 00:34:34.886 A:middle
everything above the line.

00:34:35.176 --> 00:34:36.476 A:middle
And one GPU is rendering

00:34:36.476 --> 00:34:37.085 A:middle
everything below.

00:34:37.545 --> 00:34:39.996 A:middle
So, with the eGPU we're now

00:34:39.996 --> 00:34:41.585 A:middle
going about twice as fast as we

00:34:41.585 --> 00:34:42.156 A:middle
were before.

00:34:42.755 --> 00:34:44.906 A:middle
I was kind of hoping for a bit

00:34:44.906 --> 00:34:45.275 A:middle
more, there.

00:34:45.826 --> 00:34:47.835 A:middle
And so, the problem is the eGPU

00:34:47.835 --> 00:34:49.326 A:middle
is sitting there waiting.

00:34:50.136 --> 00:34:51.016 A:middle
And that's because we're using

00:34:51.016 --> 00:34:52.045 A:middle
these fixed partitions.

00:34:52.906 --> 00:34:54.545 A:middle
So, if we switch on the adaptive

00:34:54.545 --> 00:34:56.286 A:middle
load balancing, here, you see

00:34:56.366 --> 00:34:58.226 A:middle
the RX 580 just grabs a big

00:34:58.226 --> 00:34:59.096 A:middle
chunk of the work, now.

00:34:59.256 --> 00:35:00.676 A:middle
And we're going much faster than


00:34:59.256 --> 00:35:00.676 A:middle
And we're going much faster than

00:35:00.676 --> 00:35:01.426 A:middle
we were, previously.

00:35:03.396 --> 00:35:05.626 A:middle
So, the scene here has

00:35:05.626 --> 00:35:06.606 A:middle
approximately one million

00:35:06.606 --> 00:35:07.266 A:middle
triangles.

00:35:07.266 --> 00:35:08.716 A:middle
And we're now going to switch to

00:35:09.026 --> 00:35:09.816 A:middle
an outside view.

00:35:09.816 --> 00:35:11.166 A:middle
It's the same Amazon Lumberyard

00:35:11.166 --> 00:35:13.016 A:middle
scene but we're outside, now.

00:35:13.336 --> 00:35:14.666 A:middle
And this scene has approximately

00:35:14.666 --> 00:35:16.306 A:middle
3 million triangles.

00:35:17.516 --> 00:35:19.516 A:middle
And I have another GPU sitting

00:35:19.516 --> 00:35:19.706 A:middle
here.

00:35:19.706 --> 00:35:20.696 A:middle
So, we'll turn that one on, too.

00:35:21.046 --> 00:35:24.016 A:middle
And, this time, it's a Vega 64.

00:35:24.356 --> 00:35:26.026 A:middle
So, you see the Vega grabbing a

00:35:26.116 --> 00:35:27.036 A:middle
big chunk of the work, there.

00:35:28.266 --> 00:35:30.006 A:middle
And what's interesting about

00:35:30.006 --> 00:35:31.296 A:middle
this configuration is we have

00:35:31.296 --> 00:35:32.766 A:middle
three very different GPUs

00:35:32.766 --> 00:35:33.396 A:middle
working together.

00:35:33.716 --> 00:35:34.966 A:middle
They're different architectures

00:35:35.576 --> 00:35:36.376 A:middle
and they're very different

00:35:36.376 --> 00:35:37.046 A:middle
performance, too.

00:35:37.046 --> 00:35:38.056 A:middle
But they're all working together

00:35:38.056 --> 00:35:39.416 A:middle
to help produce this great

00:35:39.886 --> 00:35:40.000 A:middle
image.

00:35:43.516 --> 00:35:48.500 A:middle
[ Applause ]

00:35:51.046 --> 00:35:52.666 A:middle
So, today we introduced the

00:35:52.666 --> 00:35:54.606 A:middle
MPSRayIntersector, a new API

00:35:54.606 --> 00:35:56.066 A:middle
that you can use to accelerate

00:35:56.066 --> 00:35:57.636 A:middle
ray triangle intersections on

00:35:57.636 --> 00:35:58.156 A:middle
the GPU.

00:35:58.276 --> 00:36:01.346 A:middle
As you saw from my demos, it's


00:35:58.276 --> 00:36:01.346 A:middle
As you saw from my demos, it's

00:36:01.346 --> 00:36:03.166 A:middle
available on all of our iOS and

00:36:03.166 --> 00:36:04.246 A:middle
macOS platforms.

00:36:04.676 --> 00:36:06.196 A:middle
And it scales really well as you

00:36:06.196 --> 00:36:09.426 A:middle
add multiple GPUs on macOS.

00:36:09.786 --> 00:36:11.386 A:middle
Now, we're really excited to see

00:36:11.386 --> 00:36:12.726 A:middle
how you use Ray Tracing in your

00:36:12.726 --> 00:36:13.466 A:middle
applications.

00:36:14.126 --> 00:36:15.936 A:middle
We used Path Tracing in our

00:36:15.936 --> 00:36:16.636 A:middle
example, today.

00:36:17.116 --> 00:36:18.216 A:middle
But there's also hybrid

00:36:18.216 --> 00:36:18.576 A:middle
rendering.

00:36:18.816 --> 00:36:20.316 A:middle
You might want to incorporate

00:36:20.316 --> 00:36:21.576 A:middle
Ray Tracing to do really nice

00:36:21.576 --> 00:36:22.966 A:middle
looking shadows or ambient

00:36:22.966 --> 00:36:24.246 A:middle
occlusion or reflections.

00:36:25.176 --> 00:36:26.566 A:middle
And there's also non-rendering

00:36:26.566 --> 00:36:27.346 A:middle
in cases.

00:36:27.456 --> 00:36:29.056 A:middle
For example, autosimulation,

00:36:29.056 --> 00:36:30.846 A:middle
physics, AI collisionless

00:36:30.846 --> 00:36:31.196 A:middle
action.

00:36:31.196 --> 00:36:32.246 A:middle
There's a ton of stuff you can

00:36:32.246 --> 00:36:33.226 A:middle
do with this.

00:36:34.916 --> 00:36:37.156 A:middle
So, to help you get started you

00:36:38.626 --> 00:36:40.236 A:middle
can find sample code on

00:36:40.236 --> 00:36:41.596 A:middle
developer.apple.com.

00:36:41.596 --> 00:36:42.896 A:middle
So, be sure to check that out.

00:36:43.476 --> 00:36:45.086 A:middle
Also, the header files are full

00:36:45.086 --> 00:36:47.476 A:middle
of documentation and information

00:36:47.476 --> 00:36:48.966 A:middle
on some additional features that

00:36:48.966 --> 00:36:50.036 A:middle
we weren't able to cover today.

00:36:51.326 --> 00:36:52.696 A:middle
And finally, we have our lab

00:36:52.696 --> 00:36:53.786 A:middle
session tomorrow from 12.

00:36:53.956 --> 00:36:55.736 A:middle
Sean and I will be on hand to

00:36:55.736 --> 00:36:57.436 A:middle
talk more about the API and to

00:36:57.656 --> 00:36:58.796 A:middle
help you get started with Ray

00:36:58.796 --> 00:37:00.086 A:middle
Tracing in your application.


00:36:58.796 --> 00:37:00.086 A:middle
Tracing in your application.

00:37:00.086 --> 00:37:01.456 A:middle
So, we hope you can join us for

00:37:02.656 --> 00:37:03.266 A:middle
that.

00:37:03.266 --> 00:37:04.336 A:middle
So, thank you, for coming to our

00:37:04.336 --> 00:37:04.646 A:middle
talk.

00:37:04.646 --> 00:37:06.796 A:middle
And enjoy the rest of WWDC.

00:37:07.516 --> 00:37:12.506 A:middle
[ Applause ]
