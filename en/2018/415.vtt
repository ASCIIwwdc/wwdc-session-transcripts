WEBVTT

00:00:07.016 --> 00:00:15.500 A:middle
[ Music ]

00:00:30.516 --> 00:00:35.816 A:middle
[ Applause ]

00:00:36.316 --> 00:00:37.416 A:middle
&gt;&gt; Good afternoon, everyone!

00:00:38.186 --> 00:00:39.896 A:middle
Welcome to Behind the Scenes of

00:00:39.896 --> 00:00:41.176 A:middle
the Xcode Build Process.

00:00:41.896 --> 00:00:43.356 A:middle
My name is Jake Petroules, and

00:00:43.356 --> 00:00:44.606 A:middle
I'm an engineer on the Xcode

00:00:44.606 --> 00:00:45.486 A:middle
Build System Team.

00:00:45.916 --> 00:00:46.746 A:middle
And today we're going to be

00:00:46.746 --> 00:00:48.666 A:middle
exploring the Xcode build

00:00:48.666 --> 00:00:49.196 A:middle
process.

00:00:49.196 --> 00:00:52.326 A:middle
I'll start by telling you all

00:00:52.326 --> 00:00:53.666 A:middle
about Xcode 10's new build

00:00:53.666 --> 00:00:54.746 A:middle
system which is written from

00:00:54.746 --> 00:00:55.666 A:middle
scratch in Swift.

00:00:55.886 --> 00:00:56.806 A:middle
And provides improved

00:00:56.806 --> 00:00:58.246 A:middle
performance and reliability.

00:00:58.986 --> 00:01:00.426 A:middle
We'll answer questions like what

00:00:58.986 --> 00:01:00.426 A:middle
We'll answer questions like what

00:01:00.426 --> 00:01:01.686 A:middle
exactly happens when you press

00:01:01.686 --> 00:01:02.236 A:middle
Command B?

00:01:02.576 --> 00:01:03.566 A:middle
How is the build process

00:01:03.566 --> 00:01:04.075 A:middle
structured?

00:01:04.275 --> 00:01:05.336 A:middle
And how does Xcode use the

00:01:05.336 --> 00:01:06.666 A:middle
information in your project file

00:01:06.946 --> 00:01:08.706 A:middle
to determine how to model and

00:01:08.706 --> 00:01:10.006 A:middle
orchestrate the build process?

00:01:11.176 --> 00:01:12.936 A:middle
Next we'll venture into the

00:01:12.936 --> 00:01:13.696 A:middle
compiler realm.

00:01:14.236 --> 00:01:16.116 A:middle
And find out about Clang and

00:01:16.116 --> 00:01:17.396 A:middle
Swift builds your source code

00:01:17.486 --> 00:01:18.416 A:middle
into object files.

00:01:19.246 --> 00:01:20.366 A:middle
We'll show how headers and

00:01:20.366 --> 00:01:21.216 A:middle
modules work.

00:01:21.586 --> 00:01:22.686 A:middle
See how the compilers find

00:01:22.686 --> 00:01:24.496 A:middle
declarations in your code, and

00:01:24.496 --> 00:01:25.826 A:middle
how the Swift compilation model

00:01:25.826 --> 00:01:27.116 A:middle
fundamentally differs from that

00:01:27.116 --> 00:01:29.506 A:middle
of C, C++ and Objective-C.

00:01:30.126 --> 00:01:32.076 A:middle
Finally, we'll land at the

00:01:32.076 --> 00:01:33.836 A:middle
linker which performs one of the

00:01:33.836 --> 00:01:35.126 A:middle
final steps in the build

00:01:35.126 --> 00:01:35.706 A:middle
process.

00:01:36.416 --> 00:01:37.836 A:middle
We'll explain what symbols are

00:01:37.836 --> 00:01:38.596 A:middle
and how they relate to your

00:01:38.596 --> 00:01:39.276 A:middle
source code.

00:01:39.556 --> 00:01:40.496 A:middle
And how the linker takes the

00:01:40.496 --> 00:01:41.756 A:middle
object files produced by the

00:01:41.756 --> 00:01:43.076 A:middle
compilers and glues them

00:01:43.076 --> 00:01:44.236 A:middle
together to produce the final

00:01:44.236 --> 00:01:45.786 A:middle
executable for your application

00:01:45.786 --> 00:01:46.306 A:middle
or framework.

00:01:47.046 --> 00:01:49.426 A:middle
By the way, we're going to use a

00:01:49.426 --> 00:01:50.996 A:middle
small sample app called PetWall

00:01:50.996 --> 00:01:52.256 A:middle
as a running example throughout

00:01:52.256 --> 00:01:52.766 A:middle
this talk.

00:01:53.066 --> 00:01:54.486 A:middle
It's just a small iOS app that

00:01:54.486 --> 00:01:58.986 A:middle
displays photos of our pets.

00:01:59.166 --> 00:02:00.986 A:middle
So let's first understand what

00:01:59.166 --> 00:02:00.986 A:middle
So let's first understand what

00:02:00.986 --> 00:02:02.726 A:middle
the build process is and how it

00:02:02.726 --> 00:02:03.916 A:middle
works when building a typical

00:02:03.916 --> 00:02:05.466 A:middle
app like PetWall in Xcode.

00:02:05.836 --> 00:02:07.136 A:middle
You can see here we've got an

00:02:07.136 --> 00:02:08.936 A:middle
app target, a framework, a bunch

00:02:08.936 --> 00:02:10.175 A:middle
of different source code files

00:02:10.175 --> 00:02:11.526 A:middle
in Swift and Objective-C.

00:02:11.896 --> 00:02:13.176 A:middle
And maybe this looks a bit like

00:02:13.176 --> 00:02:13.786 A:middle
your own project.

00:02:15.356 --> 00:02:18.036 A:middle
So when you build an app,

00:02:19.166 --> 00:02:20.116 A:middle
there's a number of steps

00:02:20.116 --> 00:02:21.586 A:middle
involved to go from the source

00:02:21.586 --> 00:02:22.956 A:middle
code and resources in your

00:02:22.956 --> 00:02:24.686 A:middle
project to the package that

00:02:24.686 --> 00:02:26.086 A:middle
you're shipping to customers or

00:02:26.136 --> 00:02:27.476 A:middle
uploading to the App Store for

00:02:27.476 --> 00:02:28.086 A:middle
distribution.

00:02:28.086 --> 00:02:30.486 A:middle
You have to compile and link

00:02:30.486 --> 00:02:31.576 A:middle
source code.

00:02:31.906 --> 00:02:33.916 A:middle
Copy and process resources like

00:02:33.916 --> 00:02:35.756 A:middle
headers, asset catalogues and

00:02:35.756 --> 00:02:36.676 A:middle
storyboards.

00:02:37.276 --> 00:02:39.066 A:middle
And finally code sign and maybe

00:02:39.066 --> 00:02:40.166 A:middle
even do some custom work in a

00:02:40.166 --> 00:02:41.776 A:middle
shell script or a make file like

00:02:41.896 --> 00:02:43.516 A:middle
building API documentation for

00:02:43.516 --> 00:02:45.706 A:middle
your framework or running code

00:02:45.706 --> 00:02:47.036 A:middle
linting and validation tools.

00:02:48.466 --> 00:02:49.996 A:middle
Now most of these tasks in the

00:02:49.996 --> 00:02:51.396 A:middle
build process are performed by

00:02:51.396 --> 00:02:52.456 A:middle
running command line tools.

00:02:52.456 --> 00:02:54.956 A:middle
Like Clang, LD, AC tool, IB

00:02:54.956 --> 00:02:56.676 A:middle
tool, Code sign, and so on.

00:02:57.446 --> 00:02:59.036 A:middle
These tools have to be executed

00:02:59.196 --> 00:03:00.216 A:middle
with a very specific set of

00:02:59.196 --> 00:03:00.216 A:middle
with a very specific set of

00:03:00.216 --> 00:03:02.316 A:middle
arguments and in a particular

00:03:02.396 --> 00:03:03.746 A:middle
order based on the configuration

00:03:03.826 --> 00:03:04.866 A:middle
of your Xcode project.

00:03:05.386 --> 00:03:07.936 A:middle
So what the build system does

00:03:07.936 --> 00:03:09.226 A:middle
for you is to automate the

00:03:09.226 --> 00:03:10.506 A:middle
orchestration and execution of

00:03:10.506 --> 00:03:11.946 A:middle
these tasks each time you

00:03:11.946 --> 00:03:12.736 A:middle
perform a build.

00:03:13.526 --> 00:03:14.876 A:middle
And since there can be tens of

00:03:14.876 --> 00:03:16.926 A:middle
thousands of tasks or even more

00:03:16.926 --> 00:03:18.436 A:middle
involved in a build process with

00:03:18.436 --> 00:03:19.386 A:middle
a complex graph of

00:03:19.386 --> 00:03:20.346 A:middle
interdependencies.

00:03:20.616 --> 00:03:21.616 A:middle
It's definitely not something

00:03:21.616 --> 00:03:22.626 A:middle
you want to be manually typing

00:03:22.626 --> 00:03:23.776 A:middle
into the terminal 110 times a

00:03:23.776 --> 00:03:24.056 A:middle
day.

00:03:24.056 --> 00:03:27.176 A:middle
Let the build system do that for

00:03:27.176 --> 00:03:27.316 A:middle
you.

00:03:29.476 --> 00:03:31.276 A:middle
Now I mentioned that the tasks

00:03:31.276 --> 00:03:32.446 A:middle
in the build process are

00:03:32.446 --> 00:03:33.976 A:middle
executed in a particular order.

00:03:34.456 --> 00:03:35.506 A:middle
Let's talk about how that

00:03:35.506 --> 00:03:37.226 A:middle
ordering is determined and why

00:03:37.226 --> 00:03:37.836 A:middle
it's important.

00:03:38.866 --> 00:03:40.036 A:middle
The order in which build tasks

00:03:40.036 --> 00:03:42.116 A:middle
are executed is determined from

00:03:42.116 --> 00:03:43.456 A:middle
the dependency information that

00:03:43.456 --> 00:03:45.476 A:middle
is the tasks, the inputs that a

00:03:45.476 --> 00:03:47.426 A:middle
task consumes, and the outputs

00:03:47.426 --> 00:03:48.096 A:middle
that it produces.

00:03:49.386 --> 00:03:51.166 A:middle
For example, a compilation task

00:03:51.236 --> 00:03:52.976 A:middle
consumes a source code file like

00:03:52.976 --> 00:03:55.636 A:middle
PetController.m as input and

00:03:55.636 --> 00:03:57.146 A:middle
produces an object file like

00:03:57.146 --> 00:03:59.146 A:middle
PetController.o as output.

00:04:00.176 --> 00:04:01.916 A:middle
Similarly, a linker task

00:04:01.946 --> 00:04:03.536 A:middle
consumes a number of object

00:04:03.536 --> 00:04:04.986 A:middle
files produced by the compiler

00:04:04.986 --> 00:04:06.096 A:middle
in previous tasks.

00:04:06.456 --> 00:04:07.966 A:middle
And produces and executable or

00:04:07.966 --> 00:04:08.806 A:middle
library output.

00:04:09.026 --> 00:04:10.426 A:middle
Like the PetWall executable that

00:04:10.426 --> 00:04:11.616 A:middle
will go into our .app bundle.

00:04:12.286 --> 00:04:13.306 A:middle
And hopefully you're starting to

00:04:13.306 --> 00:04:14.756 A:middle
see a bit of a pattern emerge

00:04:14.756 --> 00:04:14.976 A:middle
here.

00:04:16.055 --> 00:04:17.046 A:middle
You can see how the dependency

00:04:17.046 --> 00:04:18.736 A:middle
information flows through this

00:04:18.736 --> 00:04:20.706 A:middle
graph structure which ultimately

00:04:20.706 --> 00:04:22.276 A:middle
informs the order of execution.

00:04:23.016 --> 00:04:24.246 A:middle
Now if you look at the

00:04:24.246 --> 00:04:26.036 A:middle
compilation tasks in the graph

00:04:26.036 --> 00:04:27.676 A:middle
as sort of like lanes of

00:04:27.866 --> 00:04:28.316 A:middle
traffic.

00:04:28.656 --> 00:04:29.836 A:middle
You can see hoe the compilation

00:04:29.836 --> 00:04:31.656 A:middle
tasks are totally independent in

00:04:31.656 --> 00:04:32.866 A:middle
their own lanes and can

00:04:32.866 --> 00:04:34.206 A:middle
therefore run in parallel.

00:04:34.256 --> 00:04:36.526 A:middle
And because the linker task

00:04:36.576 --> 00:04:37.716 A:middle
takes everything else's input,

00:04:38.106 --> 00:04:39.946 A:middle
we know that has to come last.

00:04:41.016 --> 00:04:42.826 A:middle
So the build system uses

00:04:42.826 --> 00:04:44.206 A:middle
dependency information to

00:04:44.206 --> 00:04:45.266 A:middle
determine the order in which

00:04:45.266 --> 00:04:47.126 A:middle
tasks should be run and which

00:04:47.126 --> 00:04:49.136 A:middle
tasks can be run in parallel and

00:04:49.256 --> 00:04:50.896 A:middle
we call this dependency order.

00:04:51.756 --> 00:04:52.606 A:middle
Now that we've covered what the

00:04:52.606 --> 00:04:54.526 A:middle
build process is, let's go into

00:04:54.526 --> 00:04:56.276 A:middle
a little more detail on how it

00:04:56.276 --> 00:04:56.616 A:middle
works.

00:04:57.476 --> 00:04:58.966 A:middle
What happens when you press

00:04:58.966 --> 00:04:59.316 A:middle
build?

00:05:00.496 --> 00:05:01.826 A:middle
So the first step is for the

00:05:01.826 --> 00:05:02.826 A:middle
build system to take the build

00:05:02.826 --> 00:05:04.546 A:middle
description, your Xcode project

00:05:04.546 --> 00:05:04.906 A:middle
file.

00:05:05.316 --> 00:05:07.256 A:middle
Parse it, take into account all

00:05:07.256 --> 00:05:09.096 A:middle
the files in your project, your

00:05:09.156 --> 00:05:10.326 A:middle
targets and the dependency

00:05:10.326 --> 00:05:11.216 A:middle
relationships.

00:05:11.216 --> 00:05:13.276 A:middle
Your build settings, and turn it

00:05:13.276 --> 00:05:14.326 A:middle
into a tree-like structure

00:05:14.326 --> 00:05:15.646 A:middle
called a directed graph.

00:05:16.306 --> 00:05:17.516 A:middle
And this represents all the

00:05:17.516 --> 00:05:19.136 A:middle
dependencies between the input

00:05:19.136 --> 00:05:20.536 A:middle
and output files in your project

00:05:20.976 --> 00:05:22.216 A:middle
and the tasks that will be

00:05:22.216 --> 00:05:23.886 A:middle
executed to process them.

00:05:24.316 --> 00:05:27.856 A:middle
Next the low-level execution

00:05:27.856 --> 00:05:29.356 A:middle
engine processes this graph,

00:05:29.706 --> 00:05:30.946 A:middle
looks at the dependency

00:05:30.946 --> 00:05:32.756 A:middle
specifications and figures out

00:05:32.806 --> 00:05:34.136 A:middle
which tasks to execute.

00:05:34.676 --> 00:05:35.756 A:middle
The sequence or order in which

00:05:35.756 --> 00:05:37.676 A:middle
they must be run and which tasks

00:05:37.756 --> 00:05:39.416 A:middle
can be run in parallel.

00:05:39.416 --> 00:05:41.406 A:middle
Then proceeds to execute them.

00:05:42.266 --> 00:05:43.746 A:middle
And by the way, our low-level

00:05:43.746 --> 00:05:44.956 A:middle
build execution engine for the

00:05:44.956 --> 00:05:45.936 A:middle
new build system is called

00:05:45.936 --> 00:05:46.436 A:middle
llbuild.

00:05:46.436 --> 00:05:47.566 A:middle
And it's open source and

00:05:47.566 --> 00:05:48.396 A:middle
developed on GitHub.

00:05:48.766 --> 00:05:49.606 A:middle
If you're interested in build

00:05:49.606 --> 00:05:50.996 A:middle
systems development, feel free

00:05:50.996 --> 00:05:52.086 A:middle
to check it out and see how it

00:05:52.086 --> 00:05:52.446 A:middle
works.

00:05:52.906 --> 00:05:53.806 A:middle
We'll have a link to this and

00:05:53.806 --> 00:05:54.966 A:middle
other open source components

00:05:54.966 --> 00:05:56.316 A:middle
related to the build process at

00:05:56.316 --> 00:05:56.986 A:middle
the end of the talk.

00:05:57.856 --> 00:05:59.856 A:middle
Okay, let's talk about

00:05:59.856 --> 00:06:00.936 A:middle
discovered dependencies.

00:05:59.856 --> 00:06:00.936 A:middle
discovered dependencies.

00:06:01.526 --> 00:06:02.886 A:middle
Now since you can never have too

00:06:02.886 --> 00:06:04.686 A:middle
much dependency information, the

00:06:04.686 --> 00:06:06.026 A:middle
build system might actually

00:06:06.126 --> 00:06:07.546 A:middle
discover more information during

00:06:07.546 --> 00:06:08.936 A:middle
the task execution process.

00:06:09.726 --> 00:06:11.466 A:middle
For example, when Clang compiles

00:06:11.466 --> 00:06:13.496 A:middle
an Objective-C file, it produces

00:06:13.496 --> 00:06:15.066 A:middle
and object file as you'd expect.

00:06:15.616 --> 00:06:17.056 A:middle
But it can also produce another

00:06:17.056 --> 00:06:19.936 A:middle
file that contains a listing of

00:06:19.936 --> 00:06:21.186 A:middle
which header files were included

00:06:21.186 --> 00:06:22.086 A:middle
by that source file.

00:06:22.776 --> 00:06:24.446 A:middle
Then the next time you build,

00:06:24.736 --> 00:06:25.696 A:middle
the build system uses the

00:06:25.696 --> 00:06:27.226 A:middle
information from this file to

00:06:27.226 --> 00:06:28.426 A:middle
make sure that it recompiles the

00:06:28.426 --> 00:06:30.396 A:middle
source file if you change any of

00:06:30.396 --> 00:06:31.706 A:middle
the header files that it

00:06:31.706 --> 00:06:32.146 A:middle
includes.

00:06:32.146 --> 00:06:33.676 A:middle
And you can see the dependency

00:06:33.676 --> 00:06:35.746 A:middle
path through PetController.h,

00:06:35.746 --> 00:06:37.916 A:middle
PetController.d, .n, all the way

00:06:37.916 --> 00:06:38.786 A:middle
to the .o file.

00:06:40.376 --> 00:06:42.236 A:middle
Now we've been talking a lot

00:06:42.236 --> 00:06:44.326 A:middle
about how the build system's

00:06:44.326 --> 00:06:47.036 A:middle
main job is to execute tasks.

00:06:47.966 --> 00:06:49.086 A:middle
And of course the bigger your

00:06:49.086 --> 00:06:50.646 A:middle
project, the longer the build

00:06:50.646 --> 00:06:51.586 A:middle
process will take.

00:06:51.586 --> 00:06:53.286 A:middle
So you don't want to run all of

00:06:53.286 --> 00:06:54.886 A:middle
these tasks every single time

00:06:54.926 --> 00:06:55.366 A:middle
you build.

00:06:56.116 --> 00:06:57.666 A:middle
Instead, the build system might

00:06:57.666 --> 00:06:59.796 A:middle
only execute a subset of the

00:06:59.796 --> 00:07:02.606 A:middle
tasks on the graph.

00:06:59.796 --> 00:07:02.606 A:middle
tasks on the graph.

00:07:02.786 --> 00:07:03.916 A:middle
Depending on the changes you've

00:07:03.916 --> 00:07:05.496 A:middle
made to your project since the

00:07:05.496 --> 00:07:06.276 A:middle
previous build.

00:07:07.166 --> 00:07:08.806 A:middle
We refer to this as an

00:07:08.806 --> 00:07:10.306 A:middle
incremental build and having

00:07:10.336 --> 00:07:11.826 A:middle
accurate dependency information

00:07:12.036 --> 00:07:13.306 A:middle
is very important in order for

00:07:13.306 --> 00:07:14.636 A:middle
incremental builds to work

00:07:14.636 --> 00:07:15.976 A:middle
correctly and efficiently.

00:07:15.976 --> 00:07:19.306 A:middle
Now we talked about how changes

00:07:19.306 --> 00:07:20.476 A:middle
affect the build system, and how

00:07:20.476 --> 00:07:21.356 A:middle
they relate to incremental

00:07:21.356 --> 00:07:21.736 A:middle
builds.

00:07:22.146 --> 00:07:23.396 A:middle
So how does the build system

00:07:23.396 --> 00:07:24.576 A:middle
actually detect changes?

00:07:24.946 --> 00:07:27.466 A:middle
Each task in the build process

00:07:27.466 --> 00:07:29.366 A:middle
has an associate signature which

00:07:29.366 --> 00:07:30.506 A:middle
is the sort of hash that's

00:07:30.506 --> 00:07:31.406 A:middle
computed from various

00:07:31.406 --> 00:07:32.756 A:middle
information related to that

00:07:33.556 --> 00:07:33.686 A:middle
task.

00:07:34.516 --> 00:07:36.086 A:middle
This information includes the

00:07:36.086 --> 00:07:37.796 A:middle
stat infor of the task's inputs

00:07:37.796 --> 00:07:39.416 A:middle
like file paths and modification

00:07:39.416 --> 00:07:40.136 A:middle
time stamps.

00:07:40.576 --> 00:07:42.066 A:middle
The command line indication used

00:07:42.066 --> 00:07:43.556 A:middle
to actually perform the command.

00:07:43.656 --> 00:07:45.516 A:middle
And other task-specific metadata

00:07:45.516 --> 00:07:46.466 A:middle
such as the version of the

00:07:46.466 --> 00:07:47.776 A:middle
compiler that's being used.

00:07:49.296 --> 00:07:50.716 A:middle
The build system keeps track of

00:07:50.716 --> 00:07:52.486 A:middle
the signatures of tasks in both

00:07:52.486 --> 00:07:53.556 A:middle
the current and the previous

00:07:53.556 --> 00:07:53.876 A:middle
build.

00:07:54.126 --> 00:07:55.266 A:middle
So that it knows whether to

00:07:55.266 --> 00:07:56.976 A:middle
rerun a task each time a build

00:07:56.976 --> 00:07:57.696 A:middle
is performed.

00:07:59.106 --> 00:08:00.236 A:middle
If the signature of any given

00:07:59.106 --> 00:08:00.236 A:middle
If the signature of any given

00:08:00.236 --> 00:08:01.196 A:middle
task is different than the

00:08:01.196 --> 00:08:02.136 A:middle
signature that it had in the

00:08:02.256 --> 00:08:03.916 A:middle
previous build, then the build

00:08:03.916 --> 00:08:05.096 A:middle
system reruns that task.

00:08:06.096 --> 00:08:07.716 A:middle
If they're the same, then it's

00:08:07.716 --> 00:08:08.046 A:middle
skipped.

00:08:08.166 --> 00:08:10.316 A:middle
That's the basic idea behind how

00:08:10.316 --> 00:08:11.336 A:middle
incremental builds work.

00:08:12.596 --> 00:08:14.766 A:middle
So now that we have an idea of

00:08:14.766 --> 00:08:16.346 A:middle
what the build process is and

00:08:16.396 --> 00:08:18.066 A:middle
how it works, how can you help

00:08:18.066 --> 00:08:19.366 A:middle
the build system do its job?

00:08:19.906 --> 00:08:22.146 A:middle
Let's go back to basics for a

00:08:22.146 --> 00:08:22.466 A:middle
moment.

00:08:23.046 --> 00:08:24.596 A:middle
A build process is a series of

00:08:24.596 --> 00:08:26.746 A:middle
tasks executed in a particular

00:08:26.806 --> 00:08:27.096 A:middle
order.

00:08:27.096 --> 00:08:28.826 A:middle
But remember that the build is

00:08:28.826 --> 00:08:30.606 A:middle
represented as a directed graph.

00:08:31.936 --> 00:08:33.155 A:middle
So we don't want to think about

00:08:33.206 --> 00:08:34.366 A:middle
the order in which these tasks

00:08:34.366 --> 00:08:35.666 A:middle
should be executed because

00:08:35.666 --> 00:08:36.916 A:middle
that's the build system's job.

00:08:37.796 --> 00:08:39.756 A:middle
Instead, as developers, we need

00:08:39.756 --> 00:08:41.316 A:middle
to think about dependencies

00:08:41.316 --> 00:08:43.025 A:middle
between tasks and let the build

00:08:43.025 --> 00:08:44.236 A:middle
system figure out how to best

00:08:44.236 --> 00:08:45.316 A:middle
execute them according to the

00:08:45.316 --> 00:08:46.226 A:middle
graph's structure.

00:08:46.936 --> 00:08:48.266 A:middle
This lets the build system order

00:08:48.266 --> 00:08:50.146 A:middle
tasks correctly and parallelize

00:08:50.146 --> 00:08:51.616 A:middle
where possible in order to take

00:08:51.616 --> 00:08:53.076 A:middle
full advantage of multicore

00:08:53.076 --> 00:08:53.496 A:middle
hardware.

00:08:54.966 --> 00:08:56.506 A:middle
So where do dependencies come

00:08:56.506 --> 00:08:56.796 A:middle
from?

00:08:56.916 --> 00:08:58.726 A:middle
For certain tasks, dependency

00:08:58.726 --> 00:09:00.326 A:middle
information comes from knowledge

00:08:58.726 --> 00:09:00.326 A:middle
information comes from knowledge

00:09:00.366 --> 00:09:01.396 A:middle
built into the build system.

00:09:01.876 --> 00:09:02.836 A:middle
The build system ships with

00:09:02.876 --> 00:09:04.346 A:middle
rules for the compiler, the

00:09:04.346 --> 00:09:06.336 A:middle
linker, the asset catalogue and

00:09:06.336 --> 00:09:08.046 A:middle
story board processors and so

00:09:08.046 --> 00:09:08.186 A:middle
on.

00:09:08.496 --> 00:09:09.966 A:middle
And these rules define what kind

00:09:09.966 --> 00:09:11.376 A:middle
of files are accepted as inputs

00:09:11.746 --> 00:09:13.016 A:middle
as well as what outputs are

00:09:13.016 --> 00:09:13.576 A:middle
produced.

00:09:15.176 --> 00:09:17.186 A:middle
There's also target dependencies

00:09:17.256 --> 00:09:18.226 A:middle
which roughly determine the

00:09:18.226 --> 00:09:19.186 A:middle
order in which targets are

00:09:19.186 --> 00:09:19.466 A:middle
built.

00:09:20.246 --> 00:09:21.696 A:middle
And in some cases, the build

00:09:21.696 --> 00:09:23.066 A:middle
system can compile sources of

00:09:23.066 --> 00:09:24.276 A:middle
different targets and parallel.

00:09:24.836 --> 00:09:26.046 A:middle
Previously in Xcode, when a

00:09:26.046 --> 00:09:27.626 A:middle
target was built, it required

00:09:27.626 --> 00:09:28.816 A:middle
the compilation of the entire

00:09:28.816 --> 00:09:30.246 A:middle
dependent target to be completed

00:09:30.446 --> 00:09:31.406 A:middle
before it could start.

00:09:32.136 --> 00:09:33.726 A:middle
In Xcode X's new build system,

00:09:33.986 --> 00:09:34.966 A:middle
targets can start building

00:09:34.966 --> 00:09:35.346 A:middle
sooner.

00:09:35.876 --> 00:09:36.906 A:middle
This means that your compile

00:09:36.906 --> 00:09:38.336 A:middle
sources phase can start earlier

00:09:38.336 --> 00:09:39.036 A:middle
providing your some

00:09:39.036 --> 00:09:40.536 A:middle
parallelization for free.

00:09:41.166 --> 00:09:42.196 A:middle
However, note that if you're

00:09:42.196 --> 00:09:43.416 A:middle
making use of any run script

00:09:43.416 --> 00:09:45.026 A:middle
phases, those script phases will

00:09:45.026 --> 00:09:46.216 A:middle
need to complete before this

00:09:46.216 --> 00:09:48.446 A:middle
parallelization can take effect.

00:09:49.056 --> 00:09:50.496 A:middle
Somewhat related to target

00:09:50.496 --> 00:09:51.956 A:middle
dependencies are implicit

00:09:51.956 --> 00:09:52.556 A:middle
dependencies.

00:09:53.296 --> 00:09:54.416 A:middle
For example, if you list a

00:09:54.416 --> 00:09:55.826 A:middle
target in your link library with

00:09:55.826 --> 00:09:57.586 A:middle
binaries build phase and

00:09:57.586 --> 00:09:58.736 A:middle
implicit dependencies are

00:09:58.736 --> 00:09:59.856 A:middle
enabled in the scheme editor,

00:10:00.116 --> 00:10:01.046 A:middle
that's on by default, by the

00:10:01.046 --> 00:10:02.416 A:middle
way, the build system will

00:10:02.416 --> 00:10:03.716 A:middle
establish an implicit dependency

00:10:03.716 --> 00:10:05.326 A:middle
on that target even if it's not

00:10:05.326 --> 00:10:06.626 A:middle
listed in target dependencies.

00:10:08.116 --> 00:10:09.766 A:middle
Next up are build phase

00:10:09.766 --> 00:10:10.376 A:middle
dependencies.

00:10:10.976 --> 00:10:12.136 A:middle
In the target editor, you'll

00:10:12.136 --> 00:10:13.046 A:middle
notice that there's a number of

00:10:13.046 --> 00:10:13.646 A:middle
build phases.

00:10:14.026 --> 00:10:16.406 A:middle
Copy headers, compile sources,

00:10:16.526 --> 00:10:18.446 A:middle
copy bundle resources and so on.

00:10:19.166 --> 00:10:20.466 A:middle
The tasks associated with each

00:10:20.466 --> 00:10:22.056 A:middle
of these phrases are usually

00:10:22.056 --> 00:10:23.156 A:middle
running groups according to the

00:10:23.156 --> 00:10:24.186 A:middle
order in which the phases are

00:10:24.186 --> 00:10:24.726 A:middle
listed.

00:10:25.086 --> 00:10:25.996 A:middle
But the build system might

00:10:26.076 --> 00:10:27.226 A:middle
ignore that order if it knows

00:10:27.256 --> 00:10:27.526 A:middle
better.

00:10:27.626 --> 00:10:28.916 A:middle
Like if you have a link library,

00:10:29.236 --> 00:10:30.716 A:middle
linked binary with library space

00:10:30.966 --> 00:10:32.456 A:middle
ordered before compile sources.

00:10:32.876 --> 00:10:34.016 A:middle
And note that there's cases

00:10:34.016 --> 00:10:34.866 A:middle
where having the wrong build

00:10:34.866 --> 00:10:36.186 A:middle
phase order can cause build

00:10:36.186 --> 00:10:37.656 A:middle
issues or failures, so make sure

00:10:37.656 --> 00:10:38.796 A:middle
to understand your dependencies

00:10:38.796 --> 00:10:39.956 A:middle
and verify that your build

00:10:39.956 --> 00:10:40.826 A:middle
phases are in the right

00:10:40.826 --> 00:10:41.386 A:middle
sequence.

00:10:42.696 --> 00:10:44.166 A:middle
There's also scheme order

00:10:44.166 --> 00:10:44.786 A:middle
dependencies.

00:10:45.406 --> 00:10:46.436 A:middle
If you have the parallelize

00:10:46.486 --> 00:10:47.666 A:middle
build check box enabled in your

00:10:47.666 --> 00:10:49.236 A:middle
scheme settings, you get better

00:10:49.236 --> 00:10:50.806 A:middle
build performance and the order

00:10:50.806 --> 00:10:51.916 A:middle
of your targets in your scheme

00:10:52.016 --> 00:10:52.546 A:middle
doesn't matter.

00:10:53.026 --> 00:10:54.726 A:middle
However, if you turn parallelize

00:10:54.776 --> 00:10:56.546 A:middle
build off, Xcode will attempt to

00:10:56.546 --> 00:10:58.186 A:middle
build their, your targets in the

00:10:58.186 --> 00:10:59.246 A:middle
order you listed them in the

00:10:59.246 --> 00:11:00.876 A:middle
build action of the scheme one

00:10:59.246 --> 00:11:00.876 A:middle
build action of the scheme one

00:11:00.876 --> 00:11:01.406 A:middle
by one.

00:11:02.026 --> 00:11:03.196 A:middle
Target dependencies still have

00:11:03.196 --> 00:11:04.686 A:middle
higher priority in determining

00:11:04.686 --> 00:11:05.706 A:middle
which targets build first.

00:11:05.936 --> 00:11:07.086 A:middle
But otherwise, Xcode will

00:11:07.086 --> 00:11:07.986 A:middle
respect that ordering.

00:11:08.636 --> 00:11:10.436 A:middle
Now it might be tempting to use

00:11:10.436 --> 00:11:11.256 A:middle
this as it gives you a

00:11:11.256 --> 00:11:12.666 A:middle
predictable build order even if

00:11:12.666 --> 00:11:13.366 A:middle
you haven't set your

00:11:13.366 --> 00:11:14.336 A:middle
dependencies correctly.

00:11:14.786 --> 00:11:15.856 A:middle
But you're sacrificing a lot of

00:11:15.856 --> 00:11:17.406 A:middle
parallelization when you do this

00:11:17.796 --> 00:11:18.766 A:middle
and slowing down your build.

00:11:19.176 --> 00:11:20.186 A:middle
So we recommend that you leave

00:11:20.186 --> 00:11:21.556 A:middle
the parallelize builds checkbox

00:11:21.556 --> 00:11:22.886 A:middle
enabled, set up your target

00:11:22.886 --> 00:11:24.126 A:middle
dependencies correctly and don't

00:11:24.126 --> 00:11:24.946 A:middle
rely on ordering.

00:11:27.296 --> 00:11:29.256 A:middle
Lastly, dependency information

00:11:29.336 --> 00:11:30.956 A:middle
comes from you, the developers.

00:11:31.586 --> 00:11:33.926 A:middle
If you're creating custom shell

00:11:33.926 --> 00:11:35.256 A:middle
script build phases or build

00:11:35.256 --> 00:11:36.636 A:middle
rules, make sure to tell the

00:11:36.636 --> 00:11:38.016 A:middle
build system what its inputs and

00:11:38.016 --> 00:11:38.546 A:middle
outputs are.

00:11:39.086 --> 00:11:40.386 A:middle
This lets the build system avoid

00:11:40.386 --> 00:11:41.626 A:middle
rerunning the script tasks

00:11:41.626 --> 00:11:42.396 A:middle
unnecessarily.

00:11:42.596 --> 00:11:43.786 A:middle
And can help make sure that they

00:11:43.786 --> 00:11:45.316 A:middle
are executed in the right order.

00:11:45.796 --> 00:11:46.906 A:middle
You can define the inputs and

00:11:46.906 --> 00:11:48.286 A:middle
outputs in the run script phase

00:11:48.286 --> 00:11:48.716 A:middle
editor.

00:11:48.716 --> 00:11:50.236 A:middle
And the paths of these files

00:11:50.236 --> 00:11:51.256 A:middle
will be made available to your

00:11:51.256 --> 00:11:52.816 A:middle
script as environment variables.

00:11:54.456 --> 00:11:56.336 A:middle
Don't rely on auto-link for

00:11:56.336 --> 00:11:57.506 A:middle
target dependencies in your

00:11:57.506 --> 00:11:57.976 A:middle
project.

00:11:58.736 --> 00:11:59.676 A:middle
The client compiler has a

00:11:59.676 --> 00:12:01.006 A:middle
feature called auto-link which

00:11:59.676 --> 00:12:01.006 A:middle
feature called auto-link which

00:12:01.006 --> 00:12:02.126 A:middle
can be enabled using the link

00:12:02.126 --> 00:12:03.526 A:middle
frameworks automatically build

00:12:03.526 --> 00:12:03.866 A:middle
setting.

00:12:04.586 --> 00:12:05.826 A:middle
This setting allows the compiler

00:12:05.826 --> 00:12:06.846 A:middle
to automatically link to the

00:12:06.846 --> 00:12:08.206 A:middle
frameworks corresponding to any

00:12:08.206 --> 00:12:09.746 A:middle
modules you import without

00:12:09.746 --> 00:12:11.016 A:middle
having to explicitly link them

00:12:11.366 --> 00:12:12.496 A:middle
in your link library's build

00:12:12.496 --> 00:12:12.816 A:middle
phase.

00:12:13.396 --> 00:12:14.616 A:middle
However, it's important to note

00:12:14.616 --> 00:12:15.666 A:middle
that auto-link does not

00:12:15.726 --> 00:12:17.236 A:middle
establish dependency on that

00:12:17.236 --> 00:12:18.346 A:middle
framework at the build system

00:12:18.346 --> 00:12:18.616 A:middle
level.

00:12:18.946 --> 00:12:20.186 A:middle
So it won't guarantee that the

00:12:20.186 --> 00:12:21.746 A:middle
target you depend on is actually

00:12:21.746 --> 00:12:23.306 A:middle
built before you try to link

00:12:23.306 --> 00:12:24.386 A:middle
against it.

00:12:25.016 --> 00:12:26.716 A:middle
So you should rely on this

00:12:26.716 --> 00:12:28.286 A:middle
feature only for frameworks from

00:12:28.286 --> 00:12:29.436 A:middle
the platform STK.

00:12:29.436 --> 00:12:31.326 A:middle
Like Foundation and UIKit since

00:12:31.326 --> 00:12:32.706 A:middle
we know those will already exist

00:12:32.816 --> 00:12:34.136 A:middle
before the build even starts.

00:12:34.636 --> 00:12:35.546 A:middle
For targets in your own

00:12:35.546 --> 00:12:36.976 A:middle
projects, make sure to add

00:12:36.976 --> 00:12:38.416 A:middle
explicit library dependencies.

00:12:40.196 --> 00:12:41.566 A:middle
You might also need to create

00:12:41.566 --> 00:12:42.926 A:middle
project references by dragging

00:12:42.926 --> 00:12:44.066 A:middle
and dropping another Xcode

00:12:44.066 --> 00:12:45.506 A:middle
project into your project's file

00:12:45.506 --> 00:12:47.546 A:middle
navigator in order to reveal the

00:12:47.546 --> 00:12:48.926 A:middle
targets of other projects you

00:12:48.926 --> 00:12:49.406 A:middle
depend on.

00:12:49.996 --> 00:12:53.376 A:middle
In conclusion, with accurate

00:12:53.376 --> 00:12:54.676 A:middle
dependency information, the

00:12:54.676 --> 00:12:55.646 A:middle
build system can better

00:12:55.646 --> 00:12:56.936 A:middle
parallelize your builds, and

00:12:57.046 --> 00:12:58.136 A:middle
help ensure that you get

00:12:58.136 --> 00:13:00.106 A:middle
consistent results every time so

00:12:58.136 --> 00:13:00.106 A:middle
consistent results every time so

00:13:00.106 --> 00:13:01.176 A:middle
that you can spend less time

00:13:01.176 --> 00:13:02.326 A:middle
building and more time

00:13:02.526 --> 00:13:03.156 A:middle
developing.

00:13:04.286 --> 00:13:05.386 A:middle
For more information on how to

00:13:05.386 --> 00:13:06.436 A:middle
speed up your builds and make

00:13:06.436 --> 00:13:07.516 A:middle
the most of all those cores in

00:13:07.516 --> 00:13:09.186 A:middle
your shiny new iMac Pro, we'd

00:13:09.186 --> 00:13:10.196 A:middle
recommend that you check out

00:13:10.196 --> 00:13:11.536 A:middle
Building Faster in Xcode

00:13:11.536 --> 00:13:11.966 A:middle
Session.

00:13:12.346 --> 00:13:13.836 A:middle
And with that, I'm going to hand

00:13:13.836 --> 00:13:14.966 A:middle
it over to Jurgen, who's going

00:13:14.966 --> 00:13:16.246 A:middle
to take you into the realm of

00:13:16.246 --> 00:13:16.806 A:middle
the compiler.

00:13:17.516 --> 00:13:22.836 A:middle
[ Applause ]

00:13:23.336 --> 00:13:23.776 A:middle
&gt;&gt; Thank you, Jake.

00:13:24.726 --> 00:13:27.206 A:middle
And now we're going to talk

00:13:27.206 --> 00:13:28.666 A:middle
about what happens behind the

00:13:28.666 --> 00:13:31.216 A:middle
scenes when Xcode build system

00:13:31.296 --> 00:13:32.466 A:middle
invokes the Clang compiler.

00:13:33.976 --> 00:13:34.896 A:middle
Hello, everyone.

00:13:35.286 --> 00:13:36.956 A:middle
My name is Jurgen, and I'm a

00:13:36.956 --> 00:13:38.446 A:middle
Compiler Engineer on a Clang

00:13:38.446 --> 00:13:39.016 A:middle
Frontend Team.

00:13:40.096 --> 00:13:41.356 A:middle
Today I'm going to talk about

00:13:41.356 --> 00:13:43.256 A:middle
two features you might not know

00:13:43.256 --> 00:13:43.496 A:middle
about.

00:13:44.366 --> 00:13:45.966 A:middle
The first feature is called

00:13:46.136 --> 00:13:48.366 A:middle
header maps and how we use them

00:13:48.406 --> 00:13:50.446 A:middle
to communicate information from

00:13:50.446 --> 00:13:52.116 A:middle
the Xcode build system to the

00:13:52.116 --> 00:13:52.756 A:middle
Clang compiler.

00:13:54.146 --> 00:13:55.496 A:middle
The second feature is called

00:13:55.836 --> 00:13:57.856 A:middle
Clang modules and how we use

00:13:57.856 --> 00:14:00.956 A:middle
them to speed up your builds.

00:13:57.856 --> 00:14:00.956 A:middle
them to speed up your builds.

00:14:01.126 --> 00:14:03.526 A:middle
Some of you might only use Swift

00:14:03.556 --> 00:14:03.906 A:middle
by now.

00:14:04.756 --> 00:14:06.656 A:middle
But I want to tell you, Swift

00:14:06.656 --> 00:14:08.236 A:middle
uses Clang behind the scenes.

00:14:08.936 --> 00:14:09.896 A:middle
So there might be something

00:14:09.896 --> 00:14:12.086 A:middle
interesting for you here, too.

00:14:14.646 --> 00:14:15.446 A:middle
So what is Clang?

00:14:17.086 --> 00:14:18.906 A:middle
Clang is Apple's official C

00:14:18.906 --> 00:14:22.756 A:middle
compiler and all the other C

00:14:22.926 --> 00:14:25.696 A:middle
language family such as C, C++,

00:14:25.956 --> 00:14:28.356 A:middle
and of course Objective-C which

00:14:28.356 --> 00:14:29.906 A:middle
is used for the majority of all

00:14:29.906 --> 00:14:30.536 A:middle
frameworks.

00:14:31.056 --> 00:14:33.296 A:middle
As Jake mentioned in the

00:14:33.296 --> 00:14:36.806 A:middle
beginning, the compilers invoked

00:14:36.806 --> 00:14:38.126 A:middle
[inaudible] for every input file

00:14:38.126 --> 00:14:39.536 A:middle
and it creates exactly one

00:14:39.536 --> 00:14:41.166 A:middle
output file which is then later

00:14:41.166 --> 00:14:42.136 A:middle
consumed by the linker.

00:14:43.496 --> 00:14:45.796 A:middle
If you want to access APIs from

00:14:46.546 --> 00:14:49.436 A:middle
the iOS, or you want to access

00:14:49.946 --> 00:14:52.576 A:middle
implementations from your own

00:14:52.666 --> 00:14:54.386 A:middle
code, you usually have to

00:14:54.386 --> 00:14:55.446 A:middle
include something what is called

00:14:55.446 --> 00:14:56.036 A:middle
a header file.

00:14:56.686 --> 00:14:59.476 A:middle
A header file is a promise.

00:15:00.506 --> 00:15:03.306 A:middle
You promise somewhere else this

00:15:03.306 --> 00:15:04.536 A:middle
implementation exists.

00:15:04.876 --> 00:15:05.946 A:middle
And they usually match.

00:15:06.616 --> 00:15:08.586 A:middle
Of course if you update only the

00:15:08.656 --> 00:15:09.506 A:middle
header file-- only the

00:15:09.506 --> 00:15:11.436 A:middle
implementation file and forget

00:15:11.436 --> 00:15:13.036 A:middle
the header file, you broke your

00:15:13.846 --> 00:15:14.076 A:middle
promise.

00:15:14.446 --> 00:15:16.716 A:middle
Very often this doesn't break

00:15:16.716 --> 00:15:18.296 A:middle
the compile time because the

00:15:18.296 --> 00:15:19.626 A:middle
compiler trusts your promise.

00:15:20.496 --> 00:15:22.726 A:middle
Usually this breaks during link

00:15:22.756 --> 00:15:23.016 A:middle
time.

00:15:23.576 --> 00:15:25.986 A:middle
The compiler usually does

00:15:26.286 --> 00:15:27.566 A:middle
include more than one header

00:15:27.566 --> 00:15:30.586 A:middle
file, and this is done for all

00:15:30.586 --> 00:15:31.566 A:middle
compiler invocation.

00:15:32.376 --> 00:15:34.916 A:middle
So let's have a look at our

00:15:34.916 --> 00:15:37.076 A:middle
example application and see how

00:15:37.076 --> 00:15:38.166 A:middle
we deal with header files.

00:15:39.806 --> 00:15:42.506 A:middle
This is PetWall, it's a

00:15:42.616 --> 00:15:44.076 A:middle
mixed-language application.

00:15:44.956 --> 00:15:46.736 A:middle
The application itself is

00:15:46.736 --> 00:15:47.446 A:middle
written in Swift.

00:15:48.656 --> 00:15:51.256 A:middle
And it uses a framework that's

00:15:51.256 --> 00:15:52.706 A:middle
written in Objective-C.

00:15:52.706 --> 00:15:54.286 A:middle
And it has a support library

00:15:54.376 --> 00:15:56.376 A:middle
aesthetic archive that use--

00:15:56.376 --> 00:16:00.056 A:middle
that's written in C++.

00:15:56.376 --> 00:16:00.056 A:middle
that's written in C++.

00:16:00.246 --> 00:16:02.806 A:middle
Over time, our application grew.

00:16:03.016 --> 00:16:06.266 A:middle
And we start to reorganize it so

00:16:06.266 --> 00:16:07.616 A:middle
we can find things easier.

00:16:08.166 --> 00:16:10.486 A:middle
For example, we moved all the

00:16:10.616 --> 00:16:12.036 A:middle
cat-related files into a

00:16:12.036 --> 00:16:12.606 A:middle
subfolder.

00:16:13.216 --> 00:16:18.376 A:middle
We didn't have to change any of

00:16:18.376 --> 00:16:19.876 A:middle
our implementation files.

00:16:20.676 --> 00:16:22.246 A:middle
And it still works.

00:16:23.046 --> 00:16:26.866 A:middle
So it makes you wonder how does

00:16:26.866 --> 00:16:29.206 A:middle
Clang find your header files?

00:16:29.206 --> 00:16:33.856 A:middle
Let's look at a simple example.

00:16:34.696 --> 00:16:35.356 A:middle
This is one of our

00:16:35.356 --> 00:16:38.146 A:middle
implementation files we use in

00:16:38.146 --> 00:16:40.236 A:middle
our code and we include our

00:16:40.236 --> 00:16:43.406 A:middle
header file called cat.h. How

00:16:43.406 --> 00:16:45.836 A:middle
can we figure out what Clang

00:16:45.836 --> 00:16:46.066 A:middle
does?

00:16:46.946 --> 00:16:48.466 A:middle
Once thing you could do is you

00:16:48.466 --> 00:16:51.076 A:middle
can go into the build logs, look

00:16:51.436 --> 00:16:53.896 A:middle
what the Xcode build system did

00:16:54.486 --> 00:16:55.996 A:middle
to compile this particular file.

00:16:55.996 --> 00:16:57.276 A:middle
And copy and paste that

00:16:57.276 --> 00:16:57.956 A:middle
invocation.

00:16:59.196 --> 00:17:01.196 A:middle
You drop it into a terminal and

00:16:59.196 --> 00:17:01.196 A:middle
You drop it into a terminal and

00:17:01.546 --> 00:17:02.816 A:middle
add the -v option.

00:17:03.796 --> 00:17:05.205 A:middle
Dash-v is symbol for verbose.

00:17:05.935 --> 00:17:07.266 A:middle
And then Clang will tell you

00:17:07.476 --> 00:17:08.576 A:middle
lots of information.

00:17:09.476 --> 00:17:11.036 A:middle
But let's just concentrate on

00:17:11.036 --> 00:17:12.986 A:middle
the one that matter which is the

00:17:14.016 --> 00:17:15.226 A:middle
search paths.

00:17:15.276 --> 00:17:17.846 A:middle
I say search paths and many of

00:17:17.945 --> 00:17:19.836 A:middle
you might expect to see now here

00:17:20.106 --> 00:17:22.526 A:middle
search paths that point back to

00:17:22.526 --> 00:17:24.346 A:middle
your source code.

00:17:24.965 --> 00:17:26.646 A:middle
But it's not how this works.

00:17:27.415 --> 00:17:29.546 A:middle
Instead you will see something

00:17:29.546 --> 00:17:30.476 A:middle
called headermaps.

00:17:32.116 --> 00:17:34.426 A:middle
Headermaps are used [inaudible]

00:17:34.806 --> 00:17:36.856 A:middle
by the Xcode build system to

00:17:36.856 --> 00:17:38.656 A:middle
communicate where those header

00:17:38.656 --> 00:17:39.566 A:middle
files are.

00:17:40.546 --> 00:17:41.646 A:middle
So let's have a look at those.

00:17:41.646 --> 00:17:42.846 A:middle
Let's have a look the most

00:17:42.846 --> 00:17:44.626 A:middle
important two file-- headermap

00:17:44.626 --> 00:17:46.086 A:middle
files we care about.

00:17:47.656 --> 00:17:50.946 A:middle
The first two entries simply

00:17:51.686 --> 00:17:55.066 A:middle
append the framework name to

00:17:55.066 --> 00:17:55.586 A:middle
your header.

00:17:56.286 --> 00:17:57.126 A:middle
Those two headers in the

00:17:57.126 --> 00:17:58.916 A:middle
beginning are public headers.

00:18:02.416 --> 00:18:04.556 A:middle
I say you shouldn't rely on this

00:18:04.556 --> 00:18:04.876 A:middle
feature.

00:18:05.466 --> 00:18:08.406 A:middle
The reason is we keep this there

00:18:08.406 --> 00:18:10.226 A:middle
to keep existing projects

00:18:10.226 --> 00:18:13.076 A:middle
working but there might be

00:18:13.076 --> 00:18:14.356 A:middle
issues down the road with Clang

00:18:14.356 --> 00:18:17.476 A:middle
modules so we suggest that you

00:18:17.726 --> 00:18:20.396 A:middle
always specify the framework

00:18:20.396 --> 00:18:22.416 A:middle
name when you include a public

00:18:22.556 --> 00:18:24.336 A:middle
or private header file from your

00:18:24.376 --> 00:18:25.306 A:middle
own framework.

00:18:27.136 --> 00:18:29.576 A:middle
Third entry is a project header.

00:18:30.196 --> 00:18:31.376 A:middle
In this case, this is not

00:18:31.416 --> 00:18:31.856 A:middle
required.

00:18:32.806 --> 00:18:35.006 A:middle
And the whole purpose of the

00:18:35.006 --> 00:18:37.276 A:middle
headermap is to point back to

00:18:37.496 --> 00:18:38.296 A:middle
your source code.

00:18:38.296 --> 00:18:41.376 A:middle
As you can see, we do the same

00:18:41.466 --> 00:18:42.936 A:middle
thing for the public and private

00:18:42.986 --> 00:18:43.246 A:middle
headers.

00:18:44.296 --> 00:18:45.986 A:middle
We always point back to your

00:18:45.986 --> 00:18:47.076 A:middle
source code.

00:18:47.076 --> 00:18:49.656 A:middle
We do this so that Clang can

00:18:49.716 --> 00:18:52.126 A:middle
produce useful error and warning

00:18:52.126 --> 00:18:54.526 A:middle
messages for the files in your

00:18:54.526 --> 00:18:56.376 A:middle
source directory and not a

00:18:56.376 --> 00:18:57.746 A:middle
potential copy that might be

00:18:57.746 --> 00:19:00.606 A:middle
somewhere else in the build

00:18:57.746 --> 00:19:00.606 A:middle
somewhere else in the build

00:19:02.956 --> 00:19:03.176 A:middle
directory.

00:19:03.266 --> 00:19:05.176 A:middle
Since many people were not aware

00:19:05.176 --> 00:19:06.806 A:middle
that we use headermaps, you run

00:19:06.906 --> 00:19:08.106 A:middle
into certain issues.

00:19:08.426 --> 00:19:11.246 A:middle
A very common one is that we

00:19:11.246 --> 00:19:13.536 A:middle
forgot to add the header to the

00:19:13.536 --> 00:19:13.996 A:middle
project.

00:19:14.786 --> 00:19:16.756 A:middle
It is in the source directory,

00:19:16.916 --> 00:19:18.616 A:middle
but it is not in the project

00:19:18.616 --> 00:19:19.056 A:middle
itself.

00:19:19.366 --> 00:19:21.546 A:middle
So always add your headers to

00:19:21.546 --> 00:19:22.036 A:middle
the project.

00:19:23.046 --> 00:19:26.756 A:middle
Another issue is that if you

00:19:26.756 --> 00:19:28.366 A:middle
have headers with the same name,

00:19:28.646 --> 00:19:29.816 A:middle
they might shadow each other.

00:19:31.216 --> 00:19:32.966 A:middle
So always try to use unique

00:19:32.966 --> 00:19:33.846 A:middle
names for your headers.

00:19:34.806 --> 00:19:36.876 A:middle
This also applies to system

00:19:36.876 --> 00:19:37.336 A:middle
headers.

00:19:37.816 --> 00:19:39.306 A:middle
If you have a local header in

00:19:39.306 --> 00:19:40.816 A:middle
your project that has the name

00:19:40.816 --> 00:19:42.546 A:middle
as a system header, it will

00:19:42.546 --> 00:19:44.756 A:middle
shadow the system header so you

00:19:44.756 --> 00:19:46.116 A:middle
should try to avoid this.

00:19:47.096 --> 00:19:48.296 A:middle
Talking about system headers.

00:19:48.706 --> 00:19:52.866 A:middle
How do we find those?

00:19:53.066 --> 00:19:54.546 A:middle
Another example from our

00:19:54.546 --> 00:19:54.836 A:middle
PetWall.

00:19:55.926 --> 00:19:57.576 A:middle
Here in this case we include

00:19:57.616 --> 00:19:59.536 A:middle
Foundation.h header file which

00:19:59.536 --> 00:20:00.256 A:middle
is in our SDK.

00:19:59.536 --> 00:20:00.256 A:middle
is in our SDK.

00:20:00.296 --> 00:20:03.086 A:middle
We can do the same thing we did

00:20:03.086 --> 00:20:05.526 A:middle
before when you were looking for

00:20:05.526 --> 00:20:06.296 A:middle
our own header files.

00:20:06.416 --> 00:20:07.246 A:middle
But now we're looking for the

00:20:07.246 --> 00:20:07.786 A:middle
system header.

00:20:08.866 --> 00:20:11.386 A:middle
It's just that headermaps are

00:20:11.386 --> 00:20:13.486 A:middle
only for your own headers.

00:20:13.956 --> 00:20:15.076 A:middle
So we can ignore them.

00:20:16.086 --> 00:20:17.976 A:middle
Let's focus on the include path

00:20:18.056 --> 00:20:18.256 A:middle
[inaudible] matter.

00:20:18.756 --> 00:20:21.716 A:middle
So at default, we always look in

00:20:21.816 --> 00:20:23.466 A:middle
two directories in the SDK.

00:20:23.966 --> 00:20:25.746 A:middle
the first one is user include,

00:20:26.516 --> 00:20:28.616 A:middle
the second one is system library

00:20:28.616 --> 00:20:29.176 A:middle
frameworks.

00:20:29.866 --> 00:20:31.346 A:middle
Let's have a look at the first

00:20:31.346 --> 00:20:31.486 A:middle
one.

00:20:31.966 --> 00:20:34.276 A:middle
It's a regular include

00:20:34.376 --> 00:20:35.056 A:middle
directory.

00:20:35.416 --> 00:20:36.746 A:middle
So the only thing we have to do

00:20:36.746 --> 00:20:38.426 A:middle
is we have to append the search

00:20:38.426 --> 00:20:38.726 A:middle
term.

00:20:38.816 --> 00:20:39.476 A:middle
In this case,

00:20:39.476 --> 00:20:43.026 A:middle
Foundation/Foundation.h. And we

00:20:43.026 --> 00:20:44.166 A:middle
won't find the header because

00:20:44.166 --> 00:20:44.516 A:middle
it's not there.

00:20:45.556 --> 00:20:46.076 A:middle
But it's okay.

00:20:46.216 --> 00:20:47.436 A:middle
Let's try the next entry.

00:20:48.616 --> 00:20:50.126 A:middle
Let's look into system library

00:20:50.126 --> 00:20:50.746 A:middle
frameworks.

00:20:52.196 --> 00:20:53.276 A:middle
This one is a frameworks

00:20:53.326 --> 00:20:55.506 A:middle
directory that means Clang has

00:20:55.536 --> 00:20:56.746 A:middle
to behave a little bit

00:20:56.796 --> 00:20:57.216 A:middle
different.

00:20:57.456 --> 00:21:00.026 A:middle
First of all, it has to identify

00:20:57.456 --> 00:21:00.026 A:middle
First of all, it has to identify

00:21:00.506 --> 00:21:02.466 A:middle
what is the framework and check

00:21:02.466 --> 00:21:03.676 A:middle
if the framework exists.

00:21:04.146 --> 00:21:07.826 A:middle
After that, it has to look in

00:21:07.826 --> 00:21:09.336 A:middle
the headers directory for the

00:21:09.336 --> 00:21:09.806 A:middle
header file.

00:21:10.666 --> 00:21:12.376 A:middle
This case, it finds it so it's

00:21:12.376 --> 00:21:12.646 A:middle
fine.

00:21:13.736 --> 00:21:16.046 A:middle
But what happens if we don't

00:21:16.046 --> 00:21:16.656 A:middle
find the header?

00:21:17.066 --> 00:21:18.886 A:middle
For example, we have a bogus

00:21:18.886 --> 00:21:20.126 A:middle
header that doesn't exist.

00:21:21.726 --> 00:21:23.366 A:middle
It obviously fails to find it in

00:21:23.366 --> 00:21:24.256 A:middle
the headers directory.

00:21:24.846 --> 00:21:27.306 A:middle
But the next, it will also look

00:21:27.306 --> 00:21:28.296 A:middle
in the private headers

00:21:28.336 --> 00:21:28.836 A:middle
directory.

00:21:30.316 --> 00:21:32.676 A:middle
Apple doesn't ship any private

00:21:32.676 --> 00:21:34.736 A:middle
headers in its SDK.

00:21:35.046 --> 00:21:36.776 A:middle
but your project, your

00:21:36.776 --> 00:21:38.586 A:middle
frameworks might have public and

00:21:38.586 --> 00:21:39.206 A:middle
private headers.

00:21:39.826 --> 00:21:41.046 A:middle
So we always will look there

00:21:41.166 --> 00:21:41.396 A:middle
too.

00:21:42.476 --> 00:21:44.696 A:middle
Since it's a bogus header, it's

00:21:45.506 --> 00:21:46.666 A:middle
not there either.

00:21:46.756 --> 00:21:48.786 A:middle
Interesting now, we actually

00:21:48.786 --> 00:21:49.846 A:middle
will abort the search now.

00:21:50.446 --> 00:21:51.886 A:middle
We will not keep searching in

00:21:51.946 --> 00:21:52.996 A:middle
other search directories.

00:21:53.496 --> 00:21:56.026 A:middle
The reason is we already found

00:21:56.536 --> 00:21:57.716 A:middle
the head-- we already found the

00:21:57.716 --> 00:21:58.176 A:middle
framework.

00:21:59.076 --> 00:22:00.506 A:middle
Once you find the framework, we

00:21:59.076 --> 00:22:00.506 A:middle
Once you find the framework, we

00:22:00.506 --> 00:22:01.906 A:middle
expect to find the header in

00:22:01.906 --> 00:22:02.856 A:middle
this framework directory.

00:22:03.496 --> 00:22:04.326 A:middle
If you don't find it, we

00:22:04.326 --> 00:22:05.466 A:middle
complete abort the search.

00:22:06.036 --> 00:22:09.656 A:middle
If you're curious how your

00:22:09.656 --> 00:22:11.016 A:middle
implementation file looks like,

00:22:11.016 --> 00:22:13.196 A:middle
after all those headers got

00:22:13.196 --> 00:22:14.566 A:middle
imported and preprocessed.

00:22:15.236 --> 00:22:18.576 A:middle
You can ask Xcode to create a

00:22:18.576 --> 00:22:21.206 A:middle
preprocessed file for you, for

00:22:21.206 --> 00:22:22.136 A:middle
your implementation file.

00:22:22.686 --> 00:22:26.476 A:middle
This will create a very large

00:22:27.566 --> 00:22:28.496 A:middle
output file.

00:22:28.636 --> 00:22:32.736 A:middle
So how big is that file?

00:22:32.916 --> 00:22:34.766 A:middle
Let's use a very simple example.

00:22:35.606 --> 00:22:39.306 A:middle
Foundation.h is a very

00:22:39.306 --> 00:22:40.806 A:middle
fundamental header, fundamental

00:22:40.806 --> 00:22:42.106 A:middle
header to our system.

00:22:42.696 --> 00:22:44.686 A:middle
It is-- you are very likely to

00:22:44.686 --> 00:22:46.036 A:middle
import this header either

00:22:46.036 --> 00:22:48.126 A:middle
directly or indirectly for some

00:22:48.156 --> 00:22:48.896 A:middle
other header file.

00:22:49.556 --> 00:22:51.396 A:middle
That means every compiler

00:22:51.396 --> 00:22:52.746 A:middle
invocation you're most likely

00:22:52.866 --> 00:22:54.156 A:middle
going to have to find this

00:22:54.156 --> 00:22:54.376 A:middle
header.

00:22:55.796 --> 00:22:58.386 A:middle
At the end of the day, Clang has

00:22:58.436 --> 00:23:01.466 A:middle
to find and process over 800

00:22:58.436 --> 00:23:01.466 A:middle
to find and process over 800

00:23:01.466 --> 00:23:03.296 A:middle
header files for the single

00:23:03.296 --> 00:23:04.106 A:middle
include statement.

00:23:05.576 --> 00:23:07.406 A:middle
That's over 9 megabyte of source

00:23:07.406 --> 00:23:10.056 A:middle
code that has to be parsed and

00:23:10.056 --> 00:23:10.596 A:middle
verified.

00:23:11.666 --> 00:23:13.706 A:middle
And that happens for every

00:23:13.706 --> 00:23:14.926 A:middle
compiler invocation.

00:23:15.556 --> 00:23:17.176 A:middle
That's a lot of work, and it's

00:23:17.376 --> 00:23:17.886 A:middle
redundant.

00:23:19.076 --> 00:23:21.976 A:middle
So can we do better?

00:23:24.066 --> 00:23:25.076 A:middle
One of the features you might be

00:23:25.076 --> 00:23:26.936 A:middle
aware of is called precompiled

00:23:26.936 --> 00:23:27.576 A:middle
header files.

00:23:28.196 --> 00:23:29.816 A:middle
That's one way to improve this.

00:23:30.596 --> 00:23:31.886 A:middle
But we have something better.

00:23:31.996 --> 00:23:34.106 A:middle
A few years back, we introduced

00:23:34.236 --> 00:23:34.866 A:middle
Clang modules.

00:23:36.366 --> 00:23:38.806 A:middle
Clang modules allow us to only

00:23:39.006 --> 00:23:40.626 A:middle
find and parse the headers once

00:23:41.216 --> 00:23:43.306 A:middle
per framework and then store

00:23:43.306 --> 00:23:45.276 A:middle
that information on disk so it's

00:23:45.706 --> 00:23:47.256 A:middle
cached and can be reused.

00:23:48.366 --> 00:23:50.316 A:middle
This should have improved your

00:23:50.316 --> 00:23:50.776 A:middle
build times.

00:23:53.946 --> 00:23:55.666 A:middle
In order to do that, Clang

00:23:55.666 --> 00:23:57.136 A:middle
modules must have certain

00:23:57.136 --> 00:23:57.716 A:middle
properties.

00:23:58.386 --> 00:24:00.216 A:middle
One of them, one of the most

00:23:58.386 --> 00:24:00.216 A:middle
One of them, one of the most

00:24:00.286 --> 00:24:02.966 A:middle
important one is context-free.

00:24:03.516 --> 00:24:04.846 A:middle
What do I mean by context-free?

00:24:05.446 --> 00:24:08.306 A:middle
You can see here two code

00:24:08.306 --> 00:24:08.896 A:middle
snippets.

00:24:09.276 --> 00:24:11.626 A:middle
In both cases we import the

00:24:11.706 --> 00:24:12.766 A:middle
PetKit module.

00:24:13.966 --> 00:24:16.686 A:middle
But we have two different macro

00:24:16.686 --> 00:24:17.826 A:middle
definitions beforehand.

00:24:19.456 --> 00:24:20.976 A:middle
If you would use a traditional

00:24:20.976 --> 00:24:22.536 A:middle
model of importing those

00:24:22.536 --> 00:24:23.716 A:middle
headers, that means they're

00:24:24.106 --> 00:24:24.696 A:middle
[inaudible] included.

00:24:25.376 --> 00:24:27.496 A:middle
The preprocessor would honor

00:24:27.496 --> 00:24:29.396 A:middle
this definition and apply it to

00:24:29.396 --> 00:24:30.516 A:middle
the header file.

00:24:31.266 --> 00:24:32.546 A:middle
But if you would do that, that

00:24:32.546 --> 00:24:33.826 A:middle
means the modules would be

00:24:33.826 --> 00:24:35.786 A:middle
different for each header case,

00:24:35.786 --> 00:24:37.486 A:middle
and we couldn't reuse it.

00:24:37.726 --> 00:24:40.136 A:middle
So if you want to use modules,

00:24:40.336 --> 00:24:41.306 A:middle
you cannot do that.

00:24:41.926 --> 00:24:44.016 A:middle
Instead, the module will ignore

00:24:44.016 --> 00:24:45.746 A:middle
all those context-related

00:24:45.886 --> 00:24:48.036 A:middle
information that allows us to

00:24:48.036 --> 00:24:49.716 A:middle
be, that allows it to be reused

00:24:50.186 --> 00:24:52.246 A:middle
across all implementation files.

00:24:53.816 --> 00:24:57.106 A:middle
Another requirement is modules

00:24:57.106 --> 00:24:58.226 A:middle
have to be self-contained.

00:24:59.006 --> 00:25:01.126 A:middle
That means they have to specify

00:24:59.006 --> 00:25:01.126 A:middle
That means they have to specify

00:25:01.666 --> 00:25:02.836 A:middle
all the dependencies.

00:25:03.736 --> 00:25:05.496 A:middle
Which also has a nice advantage

00:25:05.876 --> 00:25:08.186 A:middle
for you because it means once

00:25:08.186 --> 00:25:10.846 A:middle
you import a module, it will

00:25:10.846 --> 00:25:11.636 A:middle
just work.

00:25:11.636 --> 00:25:12.926 A:middle
You don't have to worry about

00:25:12.926 --> 00:25:14.016 A:middle
adding any additional header

00:25:14.016 --> 00:25:16.346 A:middle
files to make that import work.

00:25:18.956 --> 00:25:22.056 A:middle
So how do we know or how does

00:25:22.056 --> 00:25:23.996 A:middle
Clang know it should build a

00:25:23.996 --> 00:25:24.426 A:middle
module?

00:25:26.046 --> 00:25:27.976 A:middle
Let's look at a simple example

00:25:27.976 --> 00:25:31.556 A:middle
here NSString.h. First Clang has

00:25:31.556 --> 00:25:33.126 A:middle
to find this particular header

00:25:33.566 --> 00:25:34.456 A:middle
in the framework.

00:25:35.056 --> 00:25:37.936 A:middle
And we already know how to do

00:25:37.936 --> 00:25:38.116 A:middle
that.

00:25:38.756 --> 00:25:39.576 A:middle
And it's the

00:25:39.796 --> 00:25:41.116 A:middle
Foundation.framework directory.

00:25:42.166 --> 00:25:43.666 A:middle
Next the Clang compiler will

00:25:43.706 --> 00:25:46.116 A:middle
look for a modules directory and

00:25:46.116 --> 00:25:47.996 A:middle
a Module Map relative to the

00:25:47.996 --> 00:25:49.706 A:middle
header's directory and it's

00:25:49.766 --> 00:25:49.936 A:middle
there.

00:25:51.606 --> 00:25:52.926 A:middle
So what is a Module Map?

00:25:53.486 --> 00:25:55.566 A:middle
A Module Map describes how a

00:25:55.566 --> 00:25:57.406 A:middle
certain set of header files

00:25:57.796 --> 00:25:59.556 A:middle
translate onto your module.

00:26:01.026 --> 00:26:02.646 A:middle
So let's have a look.

00:26:03.596 --> 00:26:05.606 A:middle
The Module Map is actually very

00:26:05.606 --> 00:26:06.066 A:middle
simple.

00:26:06.196 --> 00:26:07.876 A:middle
This is the whole Module Map for

00:26:07.876 --> 00:26:08.426 A:middle
foundation.

00:26:08.626 --> 00:26:08.966 A:middle
That's it.

00:26:09.996 --> 00:26:12.256 A:middle
It obviously describes what is

00:26:12.296 --> 00:26:13.446 A:middle
the name of the module which is,

00:26:13.446 --> 00:26:13.936 A:middle
Foundation.

00:26:14.436 --> 00:26:17.636 A:middle
And then it also specifies what

00:26:17.746 --> 00:26:19.616 A:middle
headers are part of this module.

00:26:20.716 --> 00:26:22.746 A:middle
You'll notice there's only one

00:26:22.746 --> 00:26:24.036 A:middle
header file here, only

00:26:24.036 --> 00:26:26.236 A:middle
Foundation.h. But this is a

00:26:26.236 --> 00:26:27.166 A:middle
special header file.

00:26:27.616 --> 00:26:28.646 A:middle
This is the umbrella header

00:26:29.086 --> 00:26:30.496 A:middle
which is also marked by the

00:26:30.496 --> 00:26:31.476 A:middle
special keyword umbrella.

00:26:32.496 --> 00:26:34.806 A:middle
That means Clang has also to

00:26:34.806 --> 00:26:36.286 A:middle
look into this particular header

00:26:36.286 --> 00:26:39.816 A:middle
file to figure out if NSString.h

00:26:39.816 --> 00:26:40.806 A:middle
is part of the module.

00:26:42.356 --> 00:26:44.716 A:middle
And yeah, it's there, okay.

00:26:45.236 --> 00:26:46.766 A:middle
So now we have found out

00:26:47.096 --> 00:26:48.926 A:middle
NSString.h is part of the

00:26:48.926 --> 00:26:49.876 A:middle
foundation module.

00:26:50.666 --> 00:26:52.726 A:middle
Now Clang, now Clang can upgrade

00:26:52.966 --> 00:26:55.036 A:middle
this textual import to a module

00:26:55.036 --> 00:26:57.386 A:middle
import and we know we have to

00:26:57.476 --> 00:26:58.816 A:middle
build the foundation module to

00:26:59.616 --> 00:27:00.946 A:middle
do that.

00:26:59.616 --> 00:27:00.946 A:middle
do that.

00:27:01.116 --> 00:27:02.086 A:middle
So how do we build the

00:27:02.086 --> 00:27:02.966 A:middle
foundation module?

00:27:03.916 --> 00:27:05.916 A:middle
First of all, we create a

00:27:05.986 --> 00:27:07.126 A:middle
separate Clang location for

00:27:07.126 --> 00:27:07.306 A:middle
that.

00:27:08.186 --> 00:27:10.466 A:middle
And that Clang location contains

00:27:10.646 --> 00:27:12.076 A:middle
all the header files from the

00:27:12.076 --> 00:27:12.826 A:middle
foundation module.

00:27:13.476 --> 00:27:17.216 A:middle
We don't transfer any of the

00:27:17.216 --> 00:27:19.626 A:middle
existing context from the

00:27:19.626 --> 00:27:21.136 A:middle
original compiler invocation.

00:27:21.586 --> 00:27:23.256 A:middle
Hence, it's context-free.

00:27:24.126 --> 00:27:25.896 A:middle
The thing we actually transfer

00:27:25.896 --> 00:27:27.346 A:middle
are the command line arguments

00:27:27.346 --> 00:27:28.176 A:middle
you passed to Clang.

00:27:28.446 --> 00:27:31.966 A:middle
Those are passed on.

00:27:32.226 --> 00:27:33.586 A:middle
While we build the foundation

00:27:33.586 --> 00:27:36.496 A:middle
module, we mod-- the module

00:27:36.496 --> 00:27:37.816 A:middle
itself or the framework, the

00:27:37.816 --> 00:27:40.176 A:middle
framework itself will include

00:27:40.316 --> 00:27:41.776 A:middle
additional frameworks.

00:27:42.086 --> 00:27:43.866 A:middle
That means we have to build

00:27:43.866 --> 00:27:44.836 A:middle
those modules too.

00:27:45.616 --> 00:27:48.226 A:middle
And we have to keep going

00:27:48.226 --> 00:27:50.156 A:middle
because those might also include

00:27:50.156 --> 00:27:51.256 A:middle
additional frameworks.

00:27:52.346 --> 00:27:53.536 A:middle
But we already can see there is

00:27:53.536 --> 00:27:54.266 A:middle
a benefit here.

00:27:55.296 --> 00:27:56.676 A:middle
Some of those imports might be

00:27:56.676 --> 00:27:57.266 A:middle
the same.

00:27:57.706 --> 00:27:59.586 A:middle
So we can always start reusing

00:27:59.586 --> 00:28:00.256 A:middle
that module.

00:27:59.586 --> 00:28:00.256 A:middle
that module.

00:28:00.896 --> 00:28:03.896 A:middle
All those modules are

00:28:04.036 --> 00:28:05.566 A:middle
[inaudible] to disk into

00:28:05.566 --> 00:28:06.916 A:middle
something called a module cache.

00:28:07.466 --> 00:28:12.166 A:middle
As I mentioned, the command line

00:28:12.166 --> 00:28:14.076 A:middle
arguments are passed on when you

00:28:14.196 --> 00:28:15.006 A:middle
create that module.

00:28:15.806 --> 00:28:18.536 A:middle
That means, that means those

00:28:18.536 --> 00:28:21.236 A:middle
arguments can affect the content

00:28:21.236 --> 00:28:21.936 A:middle
of your module.

00:28:22.806 --> 00:28:25.336 A:middle
As a result, we have to hash all

00:28:25.336 --> 00:28:27.816 A:middle
those arguments and store the

00:28:27.816 --> 00:28:29.036 A:middle
modules we created for this

00:28:29.036 --> 00:28:30.536 A:middle
particular compiler invocation

00:28:30.886 --> 00:28:33.406 A:middle
in a directory matching that

00:28:34.296 --> 00:28:34.456 A:middle
hash.

00:28:34.616 --> 00:28:36.366 A:middle
If you change the compiler

00:28:36.366 --> 00:28:37.796 A:middle
arguments for different

00:28:37.796 --> 00:28:39.906 A:middle
limitation file, for example

00:28:40.116 --> 00:28:43.196 A:middle
you'd say enable cat, that is a

00:28:43.196 --> 00:28:45.586 A:middle
different hash and that requires

00:28:45.966 --> 00:28:48.026 A:middle
Clang to rebuild all the

00:28:48.026 --> 00:28:50.156 A:middle
module's inputs into that

00:28:50.156 --> 00:28:52.146 A:middle
directory matching that hash.

00:28:53.366 --> 00:28:55.246 A:middle
So in order to get the maximum

00:28:55.246 --> 00:28:57.216 A:middle
reuse out of the module cache,

00:28:57.716 --> 00:29:00.026 A:middle
you should try to keep the

00:28:57.716 --> 00:29:00.026 A:middle
you should try to keep the

00:29:00.026 --> 00:29:02.086 A:middle
arguments the same, if possible.

00:29:02.646 --> 00:29:07.746 A:middle
So this is how we find and build

00:29:07.746 --> 00:29:09.456 A:middle
modules for system frameworks

00:29:10.426 --> 00:29:12.436 A:middle
but what about your frameworks?

00:29:12.876 --> 00:29:14.316 A:middle
How do we build modules for

00:29:14.316 --> 00:29:14.706 A:middle
those?

00:29:15.246 --> 00:29:18.106 A:middle
Let's go back to our original

00:29:18.106 --> 00:29:20.156 A:middle
cat example, and this time we

00:29:20.156 --> 00:29:20.986 A:middle
turn on modules.

00:29:21.676 --> 00:29:24.826 A:middle
If we would use a headermap

00:29:24.826 --> 00:29:27.256 A:middle
again, the headermap will point

00:29:27.256 --> 00:29:29.906 A:middle
us back to the source directory.

00:29:30.506 --> 00:29:32.876 A:middle
But if you look at that source

00:29:32.876 --> 00:29:34.016 A:middle
directory, we have a problem

00:29:34.016 --> 00:29:34.336 A:middle
now.

00:29:34.906 --> 00:29:36.956 A:middle
Theirs is no modules directory.

00:29:38.246 --> 00:29:39.496 A:middle
It doesn't look like a framework

00:29:39.496 --> 00:29:42.946 A:middle
at all and Clang doesn't know

00:29:42.946 --> 00:29:44.606 A:middle
how to do this in this case.

00:29:45.526 --> 00:29:47.476 A:middle
So we introduced a new concept

00:29:47.606 --> 00:29:49.846 A:middle
to solve this, and it's called

00:29:50.126 --> 00:29:51.676 A:middle
Clang's Virtual File System.

00:29:52.606 --> 00:29:54.556 A:middle
It basically creates a virtual

00:29:54.556 --> 00:29:57.016 A:middle
abstraction of a framework that

00:29:57.016 --> 00:29:58.656 A:middle
allows Clang to build the

00:29:58.656 --> 00:29:59.216 A:middle
module.

00:30:00.006 --> 00:30:02.356 A:middle
But the abstraction basically

00:30:02.356 --> 00:30:04.076 A:middle
only points to the files back in

00:30:04.076 --> 00:30:04.696 A:middle
your directory.

00:30:05.406 --> 00:30:07.726 A:middle
So again, Clang will be able to

00:30:07.726 --> 00:30:08.996 A:middle
produce [inaudible] and errors

00:30:09.106 --> 00:30:10.036 A:middle
for your source code.

00:30:10.646 --> 00:30:13.406 A:middle
And that's how we build modules

00:30:13.986 --> 00:30:15.726 A:middle
for, when you have frameworks.

00:30:16.256 --> 00:30:19.186 A:middle
As you remember, in the

00:30:19.186 --> 00:30:20.926 A:middle
beginning I mentioned there

00:30:20.926 --> 00:30:23.046 A:middle
might be issues if you don't

00:30:23.046 --> 00:30:24.906 A:middle
specify the framework name.

00:30:25.496 --> 00:30:27.286 A:middle
So let me give you an example

00:30:27.326 --> 00:30:28.426 A:middle
where this can go wrong.

00:30:28.976 --> 00:30:31.186 A:middle
This is a very simple-- very

00:30:31.186 --> 00:30:31.966 A:middle
simple code example.

00:30:31.966 --> 00:30:33.646 A:middle
We only have two imports.

00:30:34.036 --> 00:30:36.316 A:middle
The first import imports the

00:30:36.316 --> 00:30:37.456 A:middle
pet, PetKit module.

00:30:38.896 --> 00:30:41.786 A:middle
The second import, you and I

00:30:41.786 --> 00:30:43.586 A:middle
know this is also part of the

00:30:43.586 --> 00:30:46.116 A:middle
PetKit module, but Clang might

00:30:46.116 --> 00:30:47.336 A:middle
now be able to figure that out

00:30:48.116 --> 00:30:49.486 A:middle
because you didn't specify the

00:30:49.486 --> 00:30:50.156 A:middle
framework name.

00:30:50.716 --> 00:30:53.846 A:middle
In this case, it might be

00:30:53.916 --> 00:30:56.076 A:middle
possible you get duplicate

00:30:56.076 --> 00:30:56.886 A:middle
definition errors.

00:30:56.886 --> 00:30:58.876 A:middle
That's basically, that basically

00:30:58.876 --> 00:31:00.176 A:middle
happens when you import the same

00:30:58.876 --> 00:31:00.176 A:middle
happens when you import the same

00:31:00.176 --> 00:31:01.036 A:middle
header twice.

00:31:03.216 --> 00:31:05.246 A:middle
Clang works very hard behind the

00:31:05.246 --> 00:31:07.556 A:middle
scenes to fix the most common

00:31:07.596 --> 00:31:09.176 A:middle
issues that happen like this.

00:31:10.616 --> 00:31:12.116 A:middle
But it cannot fix all of them.

00:31:13.286 --> 00:31:14.156 A:middle
And this is just a simple

00:31:14.156 --> 00:31:14.686 A:middle
example.

00:31:15.506 --> 00:31:18.396 A:middle
Let's just make a little tweak.

00:31:18.606 --> 00:31:19.956 A:middle
Let's change the context.

00:31:21.436 --> 00:31:24.296 A:middle
Now the module import won't be

00:31:24.296 --> 00:31:26.046 A:middle
affected by this at all because

00:31:26.046 --> 00:31:27.336 A:middle
as I said, we ignore the

00:31:27.336 --> 00:31:27.946 A:middle
context.

00:31:28.476 --> 00:31:32.086 A:middle
The cat import is still a

00:31:32.086 --> 00:31:33.606 A:middle
textual inclusion of the header

00:31:33.946 --> 00:31:35.596 A:middle
which will observe this change.

00:31:36.386 --> 00:31:38.586 A:middle
So now you might not even have

00:31:38.666 --> 00:31:39.736 A:middle
duplicate definitions.

00:31:40.006 --> 00:31:40.616 A:middle
You might even have

00:31:40.866 --> 00:31:42.206 A:middle
contradictory definitions.

00:31:42.526 --> 00:31:43.966 A:middle
Which can mean we cannot fix,

00:31:44.766 --> 00:31:46.096 A:middle
Clang cannot fix this for you.

00:31:47.036 --> 00:31:48.796 A:middle
So as I recommended in the

00:31:48.796 --> 00:31:51.126 A:middle
beginning, always specify the

00:31:51.126 --> 00:31:53.526 A:middle
framework name when you import

00:31:53.746 --> 00:31:55.316 A:middle
your public or private headers.

00:31:56.676 --> 00:31:57.636 A:middle
And now I'm handing it over to

00:31:57.636 --> 00:31:59.726 A:middle
Devin who's going to talk about

00:31:59.726 --> 00:32:01.656 A:middle
Swift and how Swift uses Clang

00:31:59.726 --> 00:32:01.656 A:middle
Swift and how Swift uses Clang

00:32:01.656 --> 00:32:01.976 A:middle
modules.

00:32:02.516 --> 00:32:08.606 A:middle
[ Applause ]

00:32:09.106 --> 00:32:09.846 A:middle
&gt;&gt; Thanks, Jurgen.

00:32:10.406 --> 00:32:12.696 A:middle
We're now going to dive into the

00:32:12.696 --> 00:32:14.746 A:middle
details of how Swift and the

00:32:14.746 --> 00:32:17.216 A:middle
build system work together to

00:32:17.216 --> 00:32:18.906 A:middle
find declarations across your

00:32:18.966 --> 00:32:19.966 A:middle
project.

00:32:21.216 --> 00:32:22.946 A:middle
To recap some of what Jurgen

00:32:22.946 --> 00:32:24.936 A:middle
told you, Clang compiles each

00:32:24.936 --> 00:32:26.946 A:middle
Objective-C file separately.

00:32:27.856 --> 00:32:29.406 A:middle
This means if you want to refer

00:32:29.406 --> 00:32:31.156 A:middle
to a class to find in another

00:32:31.156 --> 00:32:33.476 A:middle
file, you have to import a

00:32:33.476 --> 00:32:37.406 A:middle
header that declares that class.

00:32:37.516 --> 00:32:39.396 A:middle
But Swift was designed to not

00:32:39.396 --> 00:32:41.006 A:middle
require you to write headers.

00:32:41.626 --> 00:32:42.606 A:middle
This makes it easier for

00:32:42.606 --> 00:32:43.916 A:middle
beginners to get started with

00:32:43.916 --> 00:32:44.526 A:middle
the language.

00:32:44.946 --> 00:32:46.606 A:middle
And avoids you having to repeat

00:32:46.686 --> 00:32:48.506 A:middle
a declaration in a separate

00:32:48.506 --> 00:32:48.856 A:middle
file.

00:32:50.116 --> 00:32:51.636 A:middle
However this does mean that the

00:32:51.636 --> 00:32:53.156 A:middle
compiler has to perform some

00:32:53.156 --> 00:32:54.196 A:middle
additional bookkeeping.

00:32:55.036 --> 00:32:56.196 A:middle
I'm going to tell you how that

00:32:56.236 --> 00:32:57.186 A:middle
bookkeeping works.

00:32:57.646 --> 00:33:01.066 A:middle
Let's return to our example,

00:32:57.646 --> 00:33:01.066 A:middle
Let's return to our example,

00:33:01.136 --> 00:33:01.796 A:middle
PetWall app.

00:33:02.956 --> 00:33:04.266 A:middle
The app has a view in

00:33:04.266 --> 00:33:05.356 A:middle
ViewCcontroller, written in

00:33:05.406 --> 00:33:05.846 A:middle
Swift.

00:33:06.936 --> 00:33:08.476 A:middle
An Objective-C app delegate.

00:33:09.076 --> 00:33:10.506 A:middle
And Swift unit tests.

00:33:11.686 --> 00:33:13.256 A:middle
In order to compile even just

00:33:13.256 --> 00:33:15.036 A:middle
this top PetViewController part

00:33:15.076 --> 00:33:17.316 A:middle
of the file, the compiler has to

00:33:17.316 --> 00:33:18.446 A:middle
perform four different

00:33:18.446 --> 00:33:19.276 A:middle
operations.

00:33:20.426 --> 00:33:21.836 A:middle
First, it has to find

00:33:21.936 --> 00:33:22.576 A:middle
declarations.

00:33:23.396 --> 00:33:25.806 A:middle
Both within the Swift target and

00:33:25.836 --> 00:33:27.556 A:middle
also coming from Objective-C.

00:33:29.016 --> 00:33:30.706 A:middle
Further, it has to generate

00:33:30.706 --> 00:33:31.986 A:middle
interfaces describing the

00:33:31.986 --> 00:33:33.106 A:middle
contents of the file.

00:33:33.516 --> 00:33:35.096 A:middle
So that its declarations can be

00:33:35.096 --> 00:33:37.326 A:middle
found and used in Objective-C

00:33:37.796 --> 00:33:39.606 A:middle
and in other Swift targets.

00:33:40.836 --> 00:33:41.906 A:middle
In the rest of this section of

00:33:41.906 --> 00:33:43.156 A:middle
the talk, I'm going to walk

00:33:43.156 --> 00:33:44.746 A:middle
through this example to

00:33:44.746 --> 00:33:46.186 A:middle
illustrate each of these four

00:33:46.186 --> 00:33:46.836 A:middle
tasks.

00:33:47.766 --> 00:33:48.786 A:middle
Let's start with finding

00:33:48.786 --> 00:33:50.386 A:middle
declarations within a Swift

00:33:50.386 --> 00:33:50.776 A:middle
target.

00:33:55.296 --> 00:33:56.326 A:middle
When compiling

00:33:56.376 --> 00:33:58.936 A:middle
PetViewController.swift, the

00:33:58.936 --> 00:34:00.616 A:middle
compiler will look up the type

00:33:58.936 --> 00:34:00.616 A:middle
compiler will look up the type

00:34:00.786 --> 00:34:03.046 A:middle
of PetView's initializer so that

00:34:03.046 --> 00:34:03.926 A:middle
it can check the call.

00:34:05.496 --> 00:34:07.526 A:middle
But before it can do that, it

00:34:07.526 --> 00:34:10.426 A:middle
needs to parse PetView.swift and

00:34:10.426 --> 00:34:11.106 A:middle
validate it.

00:34:11.676 --> 00:34:12.356 A:middle
To make sure that the

00:34:12.356 --> 00:34:13.835 A:middle
declaration of the initializer

00:34:13.946 --> 00:34:14.826 A:middle
is well formed.

00:34:15.835 --> 00:34:17.386 A:middle
Now, the compiler's smart enough

00:34:17.386 --> 00:34:19.366 A:middle
to know that it doesn't need to

00:34:19.366 --> 00:34:20.326 A:middle
check the body of the

00:34:20.326 --> 00:34:21.295 A:middle
initializer here.

00:34:22.156 --> 00:34:23.335 A:middle
But it does still need to do

00:34:23.335 --> 00:34:24.985 A:middle
some work just to process the

00:34:24.985 --> 00:34:26.556 A:middle
interface parts of the file.

00:34:30.045 --> 00:34:31.926 A:middle
What this means is that unlike

00:34:32.065 --> 00:34:34.416 A:middle
Clang, when compiling one Swift

00:34:34.416 --> 00:34:36.815 A:middle
file, the compiler will parse

00:34:36.906 --> 00:34:38.606 A:middle
all the other Swift files in the

00:34:38.606 --> 00:34:39.065 A:middle
target.

00:34:39.446 --> 00:34:40.666 A:middle
To examine the parts of them

00:34:40.876 --> 00:34:41.886 A:middle
that are relevant to the

00:34:41.886 --> 00:34:42.696 A:middle
interfaces.

00:34:48.335 --> 00:34:50.255 A:middle
IN Xcode 9, this resulted in

00:34:50.255 --> 00:34:52.096 A:middle
some repeated work in repeated

00:34:52.096 --> 00:34:53.536 A:middle
build-- in incremental debug

00:34:53.576 --> 00:34:54.045 A:middle
builds.

00:34:54.096 --> 00:34:55.936 A:middle
Because the compiler compiled

00:34:56.025 --> 00:34:57.416 A:middle
each file separately.

00:34:58.396 --> 00:34:59.656 A:middle
This enabled the files to be

00:34:59.656 --> 00:35:01.446 A:middle
compiled in parallel, but it

00:34:59.656 --> 00:35:01.446 A:middle
compiled in parallel, but it

00:35:01.446 --> 00:35:02.716 A:middle
forced the compiler to

00:35:02.716 --> 00:35:04.286 A:middle
repeatedly parse each file.

00:35:05.386 --> 00:35:07.006 A:middle
Once as an implementation to

00:35:07.006 --> 00:35:09.536 A:middle
produce a .o, and multiple times

00:35:09.736 --> 00:35:11.626 A:middle
as an interface to find

00:35:11.626 --> 00:35:12.486 A:middle
declarations.

00:35:13.976 --> 00:35:16.636 A:middle
Xcode 10 reduces this overhead.

00:35:17.546 --> 00:35:19.296 A:middle
It does so by combining the

00:35:19.296 --> 00:35:21.556 A:middle
files into groups that share as

00:35:21.556 --> 00:35:23.056 A:middle
much work as possible.

00:35:23.646 --> 00:35:26.206 A:middle
While still allowing maximum

00:35:26.206 --> 00:35:26.996 A:middle
parallelism.

00:35:27.956 --> 00:35:29.796 A:middle
This reuses parsing within a

00:35:29.796 --> 00:35:32.656 A:middle
group and only repeats work

00:35:32.656 --> 00:35:33.666 A:middle
across groups.

00:35:34.596 --> 00:35:36.186 A:middle
Since the number of groups is

00:35:36.186 --> 00:35:38.656 A:middle
typically relatively low, this

00:35:38.656 --> 00:35:41.066 A:middle
can significantly speed up your

00:35:41.066 --> 00:35:41.976 A:middle
incremental debug builds.

00:35:45.876 --> 00:35:48.096 A:middle
Now, Swift code doesn't only

00:35:48.096 --> 00:35:49.636 A:middle
call other Swift code.

00:35:50.156 --> 00:35:53.406 A:middle
It can also call Objective-C.

00:35:53.656 --> 00:35:55.216 A:middle
Returning to our PetWall example

00:35:55.216 --> 00:35:57.586 A:middle
app, we can see that, that this

00:35:57.586 --> 00:35:59.316 A:middle
is crucial since the system

00:35:59.316 --> 00:36:01.496 A:middle
frameworks such as UIKit are

00:35:59.316 --> 00:36:01.496 A:middle
frameworks such as UIKit are

00:36:01.496 --> 00:36:02.766 A:middle
written in Objective-C.

00:36:06.696 --> 00:36:08.396 A:middle
Swift takes a different approach

00:36:08.676 --> 00:36:10.126 A:middle
than many other languages.

00:36:10.326 --> 00:36:11.886 A:middle
And it doesn't require you to

00:36:12.186 --> 00:36:13.316 A:middle
provide a foreign function

00:36:13.316 --> 00:36:14.036 A:middle
interface.

00:36:15.576 --> 00:36:17.086 A:middle
This is where you would have to,

00:36:17.086 --> 00:36:18.416 A:middle
for example, write a Swift

00:36:18.416 --> 00:36:20.536 A:middle
declaration for each Objective-C

00:36:20.536 --> 00:36:21.846 A:middle
API you want to use.

00:36:23.056 --> 00:36:25.066 A:middle
Instead, the compiler embeds a

00:36:25.066 --> 00:36:27.556 A:middle
large part of Clang inside of it

00:36:28.316 --> 00:36:29.566 A:middle
and uses it as a library.

00:36:30.556 --> 00:36:32.326 A:middle
This makes it possible to import

00:36:32.326 --> 00:36:34.136 A:middle
Objective-C frameworks directly.

00:36:36.896 --> 00:36:38.196 A:middle
So where do Objective-C

00:36:38.196 --> 00:36:39.306 A:middle
declarations come from?

00:36:40.376 --> 00:36:41.566 A:middle
The compile-- the importer will

00:36:41.566 --> 00:36:43.066 A:middle
look in headers depending on the

00:36:43.146 --> 00:36:44.076 A:middle
type of the target.

00:36:45.596 --> 00:36:47.926 A:middle
In any target, when you import

00:36:47.926 --> 00:36:50.166 A:middle
an Objective-C framework, the

00:36:50.166 --> 00:36:51.796 A:middle
importer finds declarations in

00:36:51.796 --> 00:36:53.726 A:middle
the headers exposing Clang's

00:36:53.726 --> 00:36:55.256 A:middle
module map for that framework.

00:36:56.716 --> 00:36:58.396 A:middle
Within a framework that mixes

00:36:58.396 --> 00:37:00.656 A:middle
Swift and Objective-C code, the

00:36:58.396 --> 00:37:00.656 A:middle
Swift and Objective-C code, the

00:37:00.656 --> 00:37:02.436 A:middle
importer finds declarations in

00:37:02.436 --> 00:37:03.226 A:middle
the umbrella header.

00:37:04.646 --> 00:37:05.936 A:middle
This is the header that defines

00:37:05.976 --> 00:37:07.176 A:middle
the public interface.

00:37:08.316 --> 00:37:10.156 A:middle
In this way, Swift code inside

00:37:10.186 --> 00:37:11.876 A:middle
the framework can call public

00:37:11.876 --> 00:37:13.926 A:middle
Objective-C code in the same

00:37:14.036 --> 00:37:14.466 A:middle
framework.

00:37:16.636 --> 00:37:18.496 A:middle
Finally, within your app and

00:37:18.496 --> 00:37:20.466 A:middle
unit tests, you can add imports

00:37:20.466 --> 00:37:21.876 A:middle
to the target's bridging header.

00:37:22.256 --> 00:37:23.766 A:middle
To allow declarations from them

00:37:24.156 --> 00:37:25.486 A:middle
to be called from Swift.

00:37:25.906 --> 00:37:30.786 A:middle
Now when the importer brings in

00:37:30.786 --> 00:37:32.856 A:middle
declarations, it often changes

00:37:32.856 --> 00:37:34.076 A:middle
them to make them more

00:37:34.076 --> 00:37:34.636 A:middle
idiomatic.

00:37:35.666 --> 00:37:36.906 A:middle
For example, it will import

00:37:36.906 --> 00:37:38.546 A:middle
Objective-C methods that use the

00:37:38.546 --> 00:37:41.146 A:middle
NSError idiom as throwing

00:37:41.146 --> 00:37:43.286 A:middle
methods using Swift's built-in

00:37:43.286 --> 00:37:44.596 A:middle
error handling language feature.

00:37:45.256 --> 00:37:49.286 A:middle
In particular, it will drop

00:37:49.436 --> 00:37:51.276 A:middle
parameter type names following

00:37:51.276 --> 00:37:52.606 A:middle
verbs and prepositions.

00:37:53.976 --> 00:37:56.006 A:middle
For example, the drawPet atPoint

00:37:56.046 --> 00:37:57.846 A:middle
method has the word pet.

00:37:58.636 --> 00:38:00.146 A:middle
For a parameter of type pet

00:37:58.636 --> 00:38:00.146 A:middle
For a parameter of type pet

00:38:00.826 --> 00:38:02.046 A:middle
following the verb draw.

00:38:03.096 --> 00:38:06.456 A:middle
And similarly the word point for

00:38:06.456 --> 00:38:08.206 A:middle
a parameter of type CGPoint

00:38:08.776 --> 00:38:10.606 A:middle
following the preposition at.

00:38:11.736 --> 00:38:13.946 A:middle
These words are omitted in Swift

00:38:14.236 --> 00:38:15.886 A:middle
when the method is imported as

00:38:15.886 --> 00:38:18.326 A:middle
simply draw at.

00:38:19.156 --> 00:38:20.266 A:middle
So how does this work?

00:38:21.126 --> 00:38:22.806 A:middle
Well, you might be surprised to

00:38:22.806 --> 00:38:24.996 A:middle
know that the compiler contains

00:38:24.996 --> 00:38:26.946 A:middle
a list of common English verbs

00:38:26.946 --> 00:38:27.836 A:middle
and prepositions.

00:38:29.416 --> 00:38:31.346 A:middle
Because it is just a hard-coded

00:38:31.346 --> 00:38:32.656 A:middle
list and human language is

00:38:32.656 --> 00:38:34.416 A:middle
messy, sometimes it's missing

00:38:34.416 --> 00:38:34.936 A:middle
words.

00:38:35.796 --> 00:38:37.376 A:middle
Furthermore, in order to match

00:38:37.376 --> 00:38:39.126 A:middle
Swift's naming conventions, the

00:38:39.126 --> 00:38:40.826 A:middle
importer will also rename

00:38:40.826 --> 00:38:43.116 A:middle
methods to remove words based on

00:38:43.116 --> 00:38:43.996 A:middle
the part of speech.

00:38:45.206 --> 00:38:47.316 A:middle
For example the verb feed is not

00:38:47.366 --> 00:38:49.376 A:middle
in the list, and so feedPet is

00:38:49.376 --> 00:38:51.646 A:middle
not imported as feed as we might

00:38:51.646 --> 00:38:52.096 A:middle
expect.

00:38:53.546 --> 00:38:55.246 A:middle
When this happens, you can use

00:38:55.246 --> 00:38:57.686 A:middle
the NS Swift Name annotation to

00:38:57.686 --> 00:38:59.416 A:middle
have the compiler import the

00:38:59.416 --> 00:39:01.966 A:middle
method exactly as you want.

00:38:59.416 --> 00:39:01.966 A:middle
method exactly as you want.

00:39:06.146 --> 00:39:07.326 A:middle
Now if you want to check to see

00:39:07.326 --> 00:39:08.636 A:middle
how your Objective-C header will

00:39:08.636 --> 00:39:10.586 A:middle
be imported into Swift, you can

00:39:10.586 --> 00:39:12.276 A:middle
always go to Xcode's related

00:39:12.276 --> 00:39:13.066 A:middle
items popup.

00:39:13.546 --> 00:39:14.646 A:middle
This is in the upper left-hand

00:39:14.646 --> 00:39:15.906 A:middle
corner of the source editor.

00:39:16.606 --> 00:39:17.756 A:middle
If you select generated

00:39:17.756 --> 00:39:19.916 A:middle
interfaces, it will show you how

00:39:19.916 --> 00:39:21.506 A:middle
the interface will look in

00:39:21.506 --> 00:39:23.346 A:middle
different versions of Swift.

00:39:25.216 --> 00:39:26.696 A:middle
So that's how Swift imports

00:39:26.696 --> 00:39:27.446 A:middle
Objective-C.

00:39:28.366 --> 00:39:29.056 A:middle
But what about the other

00:39:29.056 --> 00:39:29.526 A:middle
direction?

00:39:30.246 --> 00:39:32.146 A:middle
How does Objective-C import

00:39:32.146 --> 00:39:33.486 A:middle
Swift?

00:39:35.076 --> 00:39:36.626 A:middle
The answer is that Swift

00:39:36.736 --> 00:39:38.426 A:middle
generates a header that you can

00:39:38.426 --> 00:39:39.096 A:middle
pound import.

00:39:39.986 --> 00:39:41.626 A:middle
This allows you to write classes

00:39:41.626 --> 00:39:43.636 A:middle
in Swift and call them from

00:39:43.636 --> 00:39:44.366 A:middle
Objective-C.

00:39:45.696 --> 00:39:46.726 A:middle
Let's see how this works.

00:39:47.206 --> 00:39:49.746 A:middle
The compiler will generate

00:39:49.746 --> 00:39:51.536 A:middle
Objective-C declarations for

00:39:51.536 --> 00:39:53.766 A:middle
Swift classes extending NSObject

00:39:54.156 --> 00:39:56.566 A:middle
and methods marked at obc.

00:39:57.156 --> 00:39:59.066 A:middle
For apps in unit tests, the

00:39:59.066 --> 00:40:00.856 A:middle
header will include both public

00:39:59.066 --> 00:40:00.856 A:middle
header will include both public

00:40:00.856 --> 00:40:02.476 A:middle
and internal declarations.

00:40:03.056 --> 00:40:04.516 A:middle
This allows you to use internal

00:40:04.516 --> 00:40:06.416 A:middle
Swift from the Objective-C parts

00:40:06.456 --> 00:40:07.626 A:middle
of your app.

00:40:08.416 --> 00:40:10.296 A:middle
For frameworks, however, the

00:40:10.296 --> 00:40:11.846 A:middle
generated header provides only

00:40:11.846 --> 00:40:13.126 A:middle
public declarations.

00:40:13.456 --> 00:40:14.736 A:middle
Since it's included in your

00:40:14.736 --> 00:40:16.386 A:middle
build products and it's part of

00:40:16.386 --> 00:40:17.316 A:middle
the framework's public

00:40:17.316 --> 00:40:17.986 A:middle
interface.

00:40:18.516 --> 00:40:22.286 A:middle
On the right, you can see that

00:40:22.286 --> 00:40:23.426 A:middle
the compiler ties the

00:40:23.426 --> 00:40:25.646 A:middle
Objective-C class to the mangled

00:40:25.646 --> 00:40:27.956 A:middle
name of the Swift class which

00:40:27.956 --> 00:40:29.336 A:middle
includes the name of the module,

00:40:29.806 --> 00:40:30.276 A:middle
PetWall.

00:40:30.896 --> 00:40:33.066 A:middle
Now I'm going to tell you about

00:40:33.066 --> 00:40:35.346 A:middle
modules in a bit, and Louis will

00:40:35.346 --> 00:40:36.426 A:middle
tell you about mangling.

00:40:36.966 --> 00:40:38.316 A:middle
But for now, the thing to know

00:40:38.646 --> 00:40:40.296 A:middle
is that this prevents a conflict

00:40:40.296 --> 00:40:41.786 A:middle
in the runtime when the two

00:40:41.786 --> 00:40:43.736 A:middle
modules define a class with the

00:40:43.736 --> 00:40:44.416 A:middle
same name.

00:40:44.926 --> 00:40:47.646 A:middle
You can tell Swift to use a

00:40:47.646 --> 00:40:49.176 A:middle
different name for the class in

00:40:49.176 --> 00:40:51.066 A:middle
Objective-C by passing an

00:40:51.066 --> 00:40:53.476 A:middle
identifier to the obc attribute.

00:40:54.266 --> 00:40:55.746 A:middle
But if you do this, you're

00:40:55.746 --> 00:40:57.436 A:middle
responsible for making sure the

00:40:57.436 --> 00:40:58.586 A:middle
names don't conflict.

00:40:59.966 --> 00:41:02.776 A:middle
Here I've used the PWL prefix so

00:40:59.966 --> 00:41:02.776 A:middle
Here I've used the PWL prefix so

00:41:02.876 --> 00:41:04.286 A:middle
to reduce the likelihood of a

00:41:04.286 --> 00:41:04.836 A:middle
conflict.

00:41:05.696 --> 00:41:07.246 A:middle
With this change, I can refer to

00:41:07.246 --> 00:41:10.436 A:middle
the class as PWLPetCollar in

00:41:10.436 --> 00:41:11.196 A:middle
Objective-C.

00:41:13.836 --> 00:41:15.396 A:middle
The compiler takes a similar

00:41:15.396 --> 00:41:16.696 A:middle
approach to generating

00:41:16.696 --> 00:41:18.456 A:middle
interfaces to other Swift

00:41:18.456 --> 00:41:19.066 A:middle
targets.

00:41:19.626 --> 00:41:23.496 A:middle
To do this, Swift builds on

00:41:23.496 --> 00:41:25.076 A:middle
Clang's concept of a module,

00:41:25.436 --> 00:41:26.596 A:middle
which Jurgen told you about.

00:41:27.326 --> 00:41:28.656 A:middle
And more deeply integrates it

00:41:28.656 --> 00:41:29.556 A:middle
into the language.

00:41:30.756 --> 00:41:32.396 A:middle
In Swift, a module is a

00:41:32.396 --> 00:41:33.656 A:middle
distributable unit of

00:41:33.656 --> 00:41:34.516 A:middle
declarations.

00:41:34.916 --> 00:41:36.216 A:middle
And to be able to use those

00:41:36.216 --> 00:41:38.386 A:middle
declarations you have to import

00:41:38.556 --> 00:41:39.146 A:middle
the module.

00:41:40.406 --> 00:41:42.056 A:middle
You can import Objective-C

00:41:42.056 --> 00:41:42.666 A:middle
modules.

00:41:43.006 --> 00:41:44.346 A:middle
XEtest, for example.

00:41:45.366 --> 00:41:47.626 A:middle
And in Xcode each Swift target

00:41:47.756 --> 00:41:49.486 A:middle
produces a separate module.

00:41:50.126 --> 00:41:51.226 A:middle
Including your app target.

00:41:52.546 --> 00:41:53.876 A:middle
This is why you have to import

00:41:53.876 --> 00:41:55.726 A:middle
your app's main module in order

00:41:55.726 --> 00:42:00.536 A:middle
to test it from your unit tests.

00:41:55.726 --> 00:42:00.536 A:middle
to test it from your unit tests.

00:42:00.696 --> 00:42:02.246 A:middle
When importing a module, the

00:42:02.246 --> 00:42:04.596 A:middle
compiler deserializes a special

00:42:04.596 --> 00:42:06.876 A:middle
Swift module file to check the

00:42:06.876 --> 00:42:07.966 A:middle
types when you use them.

00:42:09.196 --> 00:42:10.896 A:middle
For example, in this unit test,

00:42:10.896 --> 00:42:12.066 A:middle
the compiler will load the

00:42:12.066 --> 00:42:14.426 A:middle
PetViewController parts of the

00:42:14.426 --> 00:42:16.496 A:middle
PetWall Swift module to make

00:42:16.496 --> 00:42:17.456 A:middle
sure that you're creating the

00:42:17.456 --> 00:42:18.506 A:middle
controller correctly.

00:42:19.836 --> 00:42:20.956 A:middle
This is similar to how the

00:42:20.956 --> 00:42:22.716 A:middle
compiler finds declarations

00:42:22.916 --> 00:42:24.516 A:middle
within a target as I showed you

00:42:24.516 --> 00:42:24.936 A:middle
earlier.

00:42:26.026 --> 00:42:27.816 A:middle
Except that here, the compiler

00:42:27.816 --> 00:42:29.356 A:middle
loads a file summarizing the

00:42:29.356 --> 00:42:31.826 A:middle
module rather than parsing Swift

00:42:31.826 --> 00:42:32.976 A:middle
files directly.

00:42:36.096 --> 00:42:38.006 A:middle
The compiler produces this Swift

00:42:38.006 --> 00:42:40.006 A:middle
module file a lot like a

00:42:40.006 --> 00:42:41.576 A:middle
generated Objective-C header.

00:42:42.386 --> 00:42:43.786 A:middle
But instead of text, it's a

00:42:43.786 --> 00:42:45.096 A:middle
binary representation.

00:42:46.116 --> 00:42:47.266 A:middle
It includes the bodies of

00:42:47.266 --> 00:42:48.976 A:middle
inlineable functions much like

00:42:48.976 --> 00:42:50.206 A:middle
static inline functions in

00:42:50.206 --> 00:42:51.726 A:middle
Objective-C or header

00:42:51.726 --> 00:42:53.756 A:middle
implementations in C++.

00:42:54.906 --> 00:42:56.756 A:middle
However, one thing to be aware

00:42:56.756 --> 00:42:58.876 A:middle
of is that it does include the

00:42:58.876 --> 00:43:00.546 A:middle
names and types of private

00:42:58.876 --> 00:43:00.546 A:middle
names and types of private

00:43:00.546 --> 00:43:01.426 A:middle
declarations.

00:43:02.186 --> 00:43:03.496 A:middle
This allows you to refer to them

00:43:03.496 --> 00:43:05.006 A:middle
in the debugger which is really

00:43:05.006 --> 00:43:05.706 A:middle
handy.

00:43:06.306 --> 00:43:07.426 A:middle
But it does mean that for

00:43:07.426 --> 00:43:09.376 A:middle
example, you shouldn't name a

00:43:09.376 --> 00:43:10.756 A:middle
private variable after your

00:43:10.756 --> 00:43:12.156 A:middle
deepest, darkest secret.

00:43:15.596 --> 00:43:17.456 A:middle
For incremental builds, the

00:43:17.456 --> 00:43:19.256 A:middle
compiler produces partial Swift

00:43:19.256 --> 00:43:21.436 A:middle
module files and then merges

00:43:21.436 --> 00:43:23.666 A:middle
them into a single file that

00:43:23.666 --> 00:43:25.086 A:middle
represents the contents of the

00:43:25.086 --> 00:43:25.836 A:middle
entire module.

00:43:27.046 --> 00:43:28.686 A:middle
This merging process also makes

00:43:28.686 --> 00:43:31.316 A:middle
it possible to produce a single

00:43:31.396 --> 00:43:32.646 A:middle
Objective-C header.

00:43:34.296 --> 00:43:36.366 A:middle
In many ways, this is similar to

00:43:36.366 --> 00:43:37.636 A:middle
what the linker does when it

00:43:37.636 --> 00:43:39.066 A:middle
smooshes together your object

00:43:39.066 --> 00:43:41.526 A:middle
files into a single executable.

00:43:42.306 --> 00:43:43.506 A:middle
And to tell you more about that,

00:43:43.646 --> 00:43:45.726 A:middle
I'll hand it off to Louis and

00:43:45.726 --> 00:43:46.186 A:middle
the linker.

00:43:46.906 --> 00:43:47.766 A:middle
Louis?

00:43:48.176 --> 00:43:48.976 A:middle
&gt;&gt; Thank you, Devin.

00:43:49.516 --> 00:43:54.136 A:middle
[ Applause ]

00:43:54.636 --> 00:43:56.206 A:middle
Hi, I'm Louis Gerbarg.

00:43:56.206 --> 00:43:57.516 A:middle
I work on the linker.

00:43:57.956 --> 00:43:59.046 A:middle
Which is one of the final steps

00:43:59.046 --> 00:44:00.336 A:middle
in the Xcode build process.

00:43:59.046 --> 00:44:00.336 A:middle
in the Xcode build process.

00:44:00.706 --> 00:44:02.906 A:middle
So let's get to it.

00:44:03.166 --> 00:44:04.636 A:middle
So first off I want to go over

00:44:04.636 --> 00:44:05.666 A:middle
what we're going to talk about.

00:44:06.746 --> 00:44:07.996 A:middle
We're going to talk about what a

00:44:07.996 --> 00:44:08.786 A:middle
linker is.

00:44:09.646 --> 00:44:10.526 A:middle
We're going to talk about the

00:44:10.526 --> 00:44:11.626 A:middle
input that it takes which are

00:44:11.626 --> 00:44:13.236 A:middle
dylibs and object files and what

00:44:13.236 --> 00:44:13.776 A:middle
they are.

00:44:13.776 --> 00:44:15.476 A:middle
And we're also going to talk

00:44:15.476 --> 00:44:17.276 A:middle
about symbols which are what

00:44:17.276 --> 00:44:17.936 A:middle
those contain.

00:44:18.996 --> 00:44:20.646 A:middle
So at the end of this, I'm going

00:44:20.646 --> 00:44:21.486 A:middle
to tie this together with an

00:44:21.486 --> 00:44:22.746 A:middle
act-- with an example because

00:44:22.746 --> 00:44:24.716 A:middle
this is pretty dense stuff.

00:44:25.206 --> 00:44:26.356 A:middle
So if it seems a little

00:44:26.356 --> 00:44:27.116 A:middle
confusing.

00:44:27.566 --> 00:44:28.906 A:middle
Hold on, and hopefully we'll

00:44:28.906 --> 00:44:31.386 A:middle
make it clearer.

00:44:31.506 --> 00:44:33.616 A:middle
So what is the linker?

00:44:33.616 --> 00:44:34.636 A:middle
It's like I said, it's one of

00:44:34.636 --> 00:44:36.756 A:middle
the final processes in the

00:44:36.756 --> 00:44:37.076 A:middle
build.

00:44:37.076 --> 00:44:39.746 A:middle
And what we do is we combine all

00:44:39.746 --> 00:44:42.486 A:middle
of these .o files that have been

00:44:42.486 --> 00:44:44.376 A:middle
built by the two compilers into

00:44:44.376 --> 00:44:45.666 A:middle
an executable.

00:44:47.146 --> 00:44:49.076 A:middle
All it does is move and patch

00:44:49.156 --> 00:44:49.406 A:middle
code.

00:44:49.406 --> 00:44:50.816 A:middle
It cannot create code, and this

00:44:50.816 --> 00:44:52.486 A:middle
is important and I will show

00:44:52.486 --> 00:44:54.486 A:middle
that in the example.

00:44:55.416 --> 00:44:56.996 A:middle
But we take these two kinds of

00:44:56.996 --> 00:44:57.876 A:middle
input files.

00:44:58.326 --> 00:45:00.306 A:middle
The first one being dylibs or

00:44:58.326 --> 00:45:00.306 A:middle
The first one being dylibs or

00:45:00.306 --> 00:45:01.146 A:middle
being libraries.

00:45:01.556 --> 00:45:03.316 A:middle
There are multiple-- the first

00:45:03.316 --> 00:45:04.616 A:middle
one being object files.

00:45:04.876 --> 00:45:06.476 A:middle
Which are what come out of your

00:45:06.476 --> 00:45:06.996 A:middle
build process.

00:45:06.996 --> 00:45:07.756 A:middle
And the second one being

00:45:07.756 --> 00:45:09.486 A:middle
libraries which consist of

00:45:09.486 --> 00:45:11.026 A:middle
several types including dylibs,

00:45:11.326 --> 00:45:13.746 A:middle
tbd's, and .a files or static

00:45:13.746 --> 00:45:14.366 A:middle
archives.

00:45:16.136 --> 00:45:17.936 A:middle
So what are symbols?

00:45:18.556 --> 00:45:20.426 A:middle
A symbol is just a name to refer

00:45:20.426 --> 00:45:23.746 A:middle
to a fragment of code or data.

00:45:24.706 --> 00:45:26.626 A:middle
These fragments may refer to

00:45:26.626 --> 00:45:28.816 A:middle
other symbols which you would

00:45:28.816 --> 00:45:30.036 A:middle
see if you write a function that

00:45:30.106 --> 00:45:30.986 A:middle
calls another function.

00:45:33.376 --> 00:45:35.176 A:middle
Symbols can have attributes on

00:45:35.176 --> 00:45:36.566 A:middle
them that affect how the linker

00:45:36.566 --> 00:45:37.076 A:middle
behaves.

00:45:37.076 --> 00:45:38.026 A:middle
And there are a lot of these.

00:45:38.486 --> 00:45:39.546 A:middle
I'm just going to give you one

00:45:39.546 --> 00:45:41.826 A:middle
example which is a weak symbol.

00:45:42.336 --> 00:45:43.516 A:middle
So a weak symbol is an

00:45:43.516 --> 00:45:44.896 A:middle
annotation on a symbol that says

00:45:44.896 --> 00:45:48.026 A:middle
it might not be there when we

00:45:48.026 --> 00:45:49.726 A:middle
run the syst-- when we build

00:45:49.726 --> 00:45:51.396 A:middle
the, when we run the executable

00:45:51.896 --> 00:45:52.706 A:middle
on the system.

00:45:53.376 --> 00:45:54.106 A:middle
This is what all the

00:45:54.106 --> 00:45:55.896 A:middle
availability markup that says

00:45:56.336 --> 00:45:59.106 A:middle
this API is available on iOS 12.

00:45:59.106 --> 00:46:00.606 A:middle
And this API's available on the

00:45:59.106 --> 00:46:00.606 A:middle
And this API's available on the

00:46:00.606 --> 00:46:01.196 A:middle
iOS 11.

00:46:01.686 --> 00:46:03.156 A:middle
This, that's what it all boils

00:46:03.156 --> 00:46:04.536 A:middle
down to by the time it gets to

00:46:04.536 --> 00:46:05.106 A:middle
the linker.

00:46:05.376 --> 00:46:06.626 A:middle
So the linker can determine what

00:46:06.626 --> 00:46:07.656 A:middle
symbols are definitely going to

00:46:07.656 --> 00:46:08.856 A:middle
be there versus what symbols it

00:46:08.856 --> 00:46:11.606 A:middle
may have to, it may have to deal

00:46:11.606 --> 00:46:12.856 A:middle
with at runtime.

00:46:14.756 --> 00:46:16.776 A:middle
Languages can also encode data

00:46:16.776 --> 00:46:18.426 A:middle
into the symbol by mangling it,

00:46:18.426 --> 00:46:19.786 A:middle
as Devin mentioned earlier.

00:46:19.786 --> 00:46:25.066 A:middle
And you'll see that in both C++

00:46:25.506 --> 00:46:27.186 A:middle
and Swift.

00:46:27.326 --> 00:46:29.346 A:middle
So we have symbols which are

00:46:29.346 --> 00:46:32.506 A:middle
these names referring to code

00:46:32.506 --> 00:46:33.136 A:middle
and data.

00:46:33.476 --> 00:46:35.866 A:middle
So the compilers generate object

00:46:35.866 --> 00:46:36.076 A:middle
files.

00:46:36.076 --> 00:46:37.256 A:middle
And those object files are just

00:46:37.286 --> 00:46:40.996 A:middle
collections of those code and

00:46:40.996 --> 00:46:41.296 A:middle
data.

00:46:41.296 --> 00:46:43.956 A:middle
They are not executable.

00:46:43.956 --> 00:46:45.496 A:middle
While they are compiled code,

00:46:46.026 --> 00:46:47.436 A:middle
they aren't finished.

00:46:47.816 --> 00:46:49.446 A:middle
There are bits missing which is

00:46:49.446 --> 00:46:50.486 A:middle
what the linker's going to glue

00:46:50.486 --> 00:46:53.946 A:middle
together and fix up.

00:46:54.226 --> 00:46:55.986 A:middle
Each fragment in one of those

00:46:55.986 --> 00:46:56.976 A:middle
files is represented by a

00:46:56.976 --> 00:46:57.336 A:middle
symbol.

00:46:57.336 --> 00:47:00.956 A:middle
So for the printf function,

00:46:57.336 --> 00:47:00.956 A:middle
So for the printf function,

00:47:01.396 --> 00:47:02.646 A:middle
there's code represented by a

00:47:02.646 --> 00:47:03.096 A:middle
symbol.

00:47:03.496 --> 00:47:04.756 A:middle
For any of the functions in

00:47:04.756 --> 00:47:06.176 A:middle
PetKit which we're going to see

00:47:06.176 --> 00:47:09.716 A:middle
in a second, the same thing.

00:47:09.936 --> 00:47:11.206 A:middle
And fragments may reference

00:47:11.206 --> 00:47:12.406 A:middle
undefined symbols.

00:47:12.406 --> 00:47:16.476 A:middle
So if your .o file refers to a

00:47:16.476 --> 00:47:18.166 A:middle
function in another .o file,

00:47:18.166 --> 00:47:20.586 A:middle
that .o file's undefined.

00:47:20.626 --> 00:47:22.276 A:middle
And the linker will go and find

00:47:22.276 --> 00:47:23.936 A:middle
those undefined symbols and link

00:47:24.426 --> 00:47:26.146 A:middle
them up.

00:47:26.406 --> 00:47:28.746 A:middle
So I said that object files are

00:47:28.746 --> 00:47:30.236 A:middle
the output of your compiler

00:47:30.236 --> 00:47:30.686 A:middle
actions.

00:47:30.686 --> 00:47:31.726 A:middle
So what are libraries?

00:47:32.576 --> 00:47:34.496 A:middle
Libraries are files that define

00:47:34.496 --> 00:47:36.026 A:middle
symbols that are not part of the

00:47:36.026 --> 00:47:37.426 A:middle
target you are building.

00:47:38.516 --> 00:47:40.896 A:middle
So we have dynamic libraries,

00:47:41.726 --> 00:47:44.316 A:middle
and those are Mach-O files that

00:47:44.316 --> 00:47:46.376 A:middle
expose code and data fragments

00:47:46.696 --> 00:47:48.526 A:middle
for executables to use.

00:47:49.546 --> 00:47:52.336 A:middle
Those are distributed as part of

00:47:52.336 --> 00:47:52.676 A:middle
the system.

00:47:52.676 --> 00:47:53.636 A:middle
That's what our frameworks are.

00:47:53.636 --> 00:47:54.916 A:middle
And a number of you also use

00:47:54.916 --> 00:47:55.956 A:middle
your own frameworks.

00:47:55.956 --> 00:48:00.256 A:middle
There are also TBD files, or

00:47:55.956 --> 00:48:00.256 A:middle
There are also TBD files, or

00:48:00.346 --> 00:48:02.156 A:middle
text-based dylib stubs.

00:48:02.156 --> 00:48:03.286 A:middle
So what are those?

00:48:04.036 --> 00:48:08.286 A:middle
Well, when we made the SDKs for

00:48:08.286 --> 00:48:10.256 A:middle
iOS and macOS, we had all these

00:48:10.296 --> 00:48:11.336 A:middle
dylibs with all these great

00:48:11.336 --> 00:48:13.146 A:middle
functions like MapKit and WebKit

00:48:13.146 --> 00:48:14.296 A:middle
that you may want to use.

00:48:14.816 --> 00:48:15.966 A:middle
But we don't want to ship the

00:48:15.966 --> 00:48:17.326 A:middle
entire copy of those with the

00:48:17.326 --> 00:48:18.856 A:middle
SDK because it would be large.

00:48:18.856 --> 00:48:21.096 A:middle
Ant the compiler and linker

00:48:21.096 --> 00:48:21.606 A:middle
don't need.

00:48:21.606 --> 00:48:22.826 A:middle
It's only needed to run the

00:48:22.826 --> 00:48:23.236 A:middle
program.

00:48:23.236 --> 00:48:24.106 A:middle
So instead we create what's

00:48:24.106 --> 00:48:25.356 A:middle
called a stub dylib where we

00:48:25.356 --> 00:48:27.156 A:middle
delete the bodies of all of the

00:48:27.156 --> 00:48:27.966 A:middle
symbols and we just have the

00:48:27.966 --> 00:48:28.716 A:middle
names.

00:48:29.456 --> 00:48:31.176 A:middle
And then once we did that, we've

00:48:31.176 --> 00:48:32.526 A:middle
made a textual representation of

00:48:32.526 --> 00:48:33.576 A:middle
them that are easier for us to

00:48:33.576 --> 00:48:33.866 A:middle
use.

00:48:33.866 --> 00:48:35.536 A:middle
Currently, they are only used

00:48:35.766 --> 00:48:38.056 A:middle
for distributing the SDKs to

00:48:38.056 --> 00:48:38.876 A:middle
reduce size.

00:48:40.246 --> 00:48:41.566 A:middle
So you may see them in your

00:48:41.566 --> 00:48:42.596 A:middle
project, but you don't have to

00:48:42.596 --> 00:48:43.246 A:middle
worry about them.

00:48:43.246 --> 00:48:45.016 A:middle
And they only contain symbols.

00:48:46.226 --> 00:48:47.166 A:middle
Finally, we have static

00:48:47.166 --> 00:48:48.106 A:middle
archives.

00:48:48.526 --> 00:48:53.086 A:middle
So static archives are just

00:48:53.086 --> 00:48:54.626 A:middle
collections of .o files that

00:48:54.626 --> 00:48:56.746 A:middle
have been built with the AR tool

00:48:56.746 --> 00:48:59.226 A:middle
or in some cases the lib the lib

00:48:59.226 --> 00:49:00.156 A:middle
tool which is a wrapper for

00:48:59.226 --> 00:49:00.156 A:middle
tool which is a wrapper for

00:49:00.156 --> 00:49:00.396 A:middle
that.

00:49:00.396 --> 00:49:02.206 A:middle
And according to the AR

00:49:02.206 --> 00:49:04.556 A:middle
[inaudible] page, the AR utility

00:49:04.556 --> 00:49:06.366 A:middle
creates and maintains groups of

00:49:06.366 --> 00:49:08.246 A:middle
files combined into an archive.

00:49:09.396 --> 00:49:10.956 A:middle
Now that may sound a lot like a

00:49:10.956 --> 00:49:13.096 A:middle
TAR file or a ZIP file, and

00:49:13.096 --> 00:49:14.156 A:middle
that's exactly what it is.

00:49:14.156 --> 00:49:16.256 A:middle
In fact, the .a format was the

00:49:16.256 --> 00:49:17.666 A:middle
original archive format used by

00:49:17.776 --> 00:49:19.496 A:middle
UNIX before more powerful tools

00:49:19.496 --> 00:49:20.156 A:middle
came around.

00:49:20.926 --> 00:49:23.726 A:middle
But the compilers of the time

00:49:23.726 --> 00:49:24.476 A:middle
and the linkers of the time

00:49:24.476 --> 00:49:25.536 A:middle
natively understood them, and

00:49:25.536 --> 00:49:26.536 A:middle
they've just kept using them.

00:49:27.006 --> 00:49:28.456 A:middle
So it really is just an archive

00:49:28.456 --> 00:49:28.806 A:middle
file.

00:49:32.046 --> 00:49:33.386 A:middle
One thing worth noting is they

00:49:33.386 --> 00:49:35.506 A:middle
also prenate dynamic linking so

00:49:35.506 --> 00:49:36.826 A:middle
back in those days, all of the

00:49:36.826 --> 00:49:38.196 A:middle
code would be consid-- would be

00:49:38.196 --> 00:49:39.236 A:middle
distributed as archives.

00:49:39.846 --> 00:49:41.776 A:middle
Because of that, you might not

00:49:41.776 --> 00:49:43.896 A:middle
want to include all of the C

00:49:43.896 --> 00:49:45.046 A:middle
library if you're using one

00:49:45.046 --> 00:49:45.676 A:middle
function.

00:49:46.096 --> 00:49:48.976 A:middle
So the behavior is if there's a

00:49:49.096 --> 00:49:50.936 A:middle
symbol in a .o file, we would

00:49:50.936 --> 00:49:52.326 A:middle
pull that whole .o file out of

00:49:52.326 --> 00:49:52.846 A:middle
the archive.

00:49:52.846 --> 00:49:54.616 A:middle
But the other .o files would not

00:49:54.616 --> 00:49:55.246 A:middle
be brought in.

00:49:55.696 --> 00:49:57.696 A:middle
If you're referencing symbols

00:49:57.696 --> 00:49:58.756 A:middle
between them, everything you

00:49:58.756 --> 00:49:59.946 A:middle
need will be brought in.

00:49:59.946 --> 00:50:00.996 A:middle
If you're using some sort of

00:49:59.946 --> 00:50:00.996 A:middle
If you're using some sort of

00:50:00.996 --> 00:50:02.376 A:middle
non-symbol behavior like a

00:50:02.376 --> 00:50:04.486 A:middle
static initializer, or you're

00:50:04.486 --> 00:50:05.616 A:middle
re-exporting them as part of

00:50:05.616 --> 00:50:06.916 A:middle
your own dylib, you may need to

00:50:06.916 --> 00:50:08.286 A:middle
explicitly use something like

00:50:09.096 --> 00:50:11.276 A:middle
force load or all load to the

00:50:11.416 --> 00:50:12.446 A:middle
linker to tell it bring in

00:50:12.446 --> 00:50:13.266 A:middle
everything.

00:50:13.266 --> 00:50:14.256 A:middle
Or these files, even though

00:50:14.256 --> 00:50:15.106 A:middle
there's no linkage.

00:50:15.666 --> 00:50:19.786 A:middle
So let's go through an example

00:50:19.786 --> 00:50:20.776 A:middle
to try to tie this altogether.

00:50:23.236 --> 00:50:25.686 A:middle
So up on stage we have an

00:50:25.686 --> 00:50:28.136 A:middle
example of a playSound function

00:50:28.136 --> 00:50:29.186 A:middle
because what fun would be

00:50:29.186 --> 00:50:29.996 A:middle
looking at pets without

00:50:29.996 --> 00:50:32.076 A:middle
listening to them?

00:50:32.296 --> 00:50:35.896 A:middle
And you know it calls playSound.

00:50:35.896 --> 00:50:36.906 A:middle
You know, there's a function on

00:50:36.906 --> 00:50:37.956 A:middle
cat that calls playSound.

00:50:37.956 --> 00:50:38.926 A:middle
That seems pretty simple.

00:50:38.926 --> 00:50:40.576 A:middle
So let's look at the assembly

00:50:40.576 --> 00:50:41.176 A:middle
that generates.

00:50:41.176 --> 00:50:45.476 A:middle
So here's cat.o that comes out

00:50:45.476 --> 00:50:46.966 A:middle
of it.

00:50:46.966 --> 00:50:49.766 A:middle
Now if we look, we can see we

00:50:49.766 --> 00:50:53.116 A:middle
have the string purr.aac which

00:50:53.116 --> 00:50:54.846 A:middle
would be our AAC sound file.

00:50:54.916 --> 00:50:57.406 A:middle
And that gets copied into cat.o.

00:50:57.406 --> 00:50:58.856 A:middle
You'll note that the name purr

00:50:58.856 --> 00:51:00.196 A:middle
file does not appear in there

00:50:58.856 --> 00:51:00.196 A:middle
file does not appear in there

00:51:00.196 --> 00:51:00.756 A:middle
anywhere.

00:51:01.176 --> 00:51:02.816 A:middle
The reason is, that's a static.

00:51:02.816 --> 00:51:03.836 A:middle
And those of you who are

00:51:03.836 --> 00:51:04.836 A:middle
familiar with C, that means it's

00:51:04.836 --> 00:51:06.166 A:middle
a nonexported name.

00:51:06.166 --> 00:51:07.386 A:middle
Nobody else can refer to it.

00:51:07.386 --> 00:51:08.806 A:middle
Since nobody else can refer to

00:51:08.806 --> 00:51:10.016 A:middle
it, we don't need it.

00:51:10.016 --> 00:51:10.856 A:middle
It's not included.

00:51:14.326 --> 00:51:17.286 A:middle
And then we see Cat purr becomes

00:51:17.286 --> 00:51:19.536 A:middle
an actual symbol: dash, open

00:51:19.536 --> 00:51:20.976 A:middle
bracket, Cat purr, close

00:51:20.976 --> 00:51:22.746 A:middle
bracket.

00:51:23.596 --> 00:51:24.686 A:middle
Pretty much what you'd expect.

00:51:24.686 --> 00:51:27.946 A:middle
And then we see we actually have

00:51:27.946 --> 00:51:29.446 A:middle
to get this variable we're going

00:51:29.446 --> 00:51:30.746 A:middle
to pass into playSound.

00:51:30.746 --> 00:51:32.196 A:middle
And you'll note there are two

00:51:32.196 --> 00:51:33.556 A:middle
instructions referring to that.

00:51:33.556 --> 00:51:36.476 A:middle
And that's because we don't know

00:51:36.476 --> 00:51:38.206 A:middle
where this string is going to

00:51:38.206 --> 00:51:39.406 A:middle
end up in the final executable.

00:51:39.406 --> 00:51:40.866 A:middle
We don't have a concrete address

00:51:40.866 --> 00:51:41.386 A:middle
for it.

00:51:41.616 --> 00:51:43.646 A:middle
But we know that on RM64 which

00:51:43.646 --> 00:51:45.046 A:middle
is what this assembly is, it

00:51:45.586 --> 00:51:46.386 A:middle
could take at most two

00:51:46.386 --> 00:51:46.936 A:middle
instructions.

00:51:46.936 --> 00:51:48.116 A:middle
So the compiler leaves us with

00:51:48.116 --> 00:51:48.866 A:middle
two instructions.

00:51:49.126 --> 00:51:50.426 A:middle
And it leaves the symbolic

00:51:50.426 --> 00:51:52.636 A:middle
offset, the symbolic values page

00:51:52.636 --> 00:51:53.986 A:middle
and page off that the linker

00:51:53.986 --> 00:51:55.176 A:middle
will come in and fix up later.

00:51:56.206 --> 00:51:59.406 A:middle
Finally, now that we've loaded

00:51:59.406 --> 00:52:03.096 A:middle
that string into x0, we can call

00:51:59.406 --> 00:52:03.096 A:middle
that string into x0, we can call

00:52:03.096 --> 00:52:04.886 A:middle
playSound except for we're not

00:52:04.886 --> 00:52:05.836 A:middle
calling playSound.

00:52:05.836 --> 00:52:07.466 A:middle
We're calling underbar underbar

00:52:07.466 --> 00:52:11.606 A:middle
z9playSound PKc.

00:52:11.606 --> 00:52:12.446 A:middle
Now what is that?

00:52:12.746 --> 00:52:14.456 A:middle
That's a mangled symbol because

00:52:14.456 --> 00:52:16.276 A:middle
if you note, it says cat.mm.

00:52:16.276 --> 00:52:17.866 A:middle
This is Objective-C++.

00:52:18.466 --> 00:52:20.956 A:middle
And playSound is actually a C++

00:52:20.956 --> 00:52:21.336 A:middle
function.

00:52:22.146 --> 00:52:23.806 A:middle
So if you're not familiar with

00:52:23.806 --> 00:52:27.116 A:middle
those, you can go to terminal

00:52:27.116 --> 00:52:28.606 A:middle
and you can actually use tools.

00:52:28.606 --> 00:52:31.626 A:middle
So if you run Swift-demangle and

00:52:31.626 --> 00:52:32.616 A:middle
pass in a symbol, it will

00:52:32.616 --> 00:52:33.386 A:middle
attempt to demangle it.

00:52:33.386 --> 00:52:34.606 A:middle
It didn't work.

00:52:34.606 --> 00:52:35.686 A:middle
It's not a Swift symbol.

00:52:35.686 --> 00:52:38.456 A:middle
But C++ filts, which is the C++

00:52:38.456 --> 00:52:40.126 A:middle
demangler shows us that this is

00:52:40.126 --> 00:52:42.626 A:middle
in fact a symbol for playSound.

00:52:42.626 --> 00:52:44.126 A:middle
But not only is it playSound, we

00:52:44.126 --> 00:52:45.136 A:middle
know it takes one argument.

00:52:45.136 --> 00:52:46.736 A:middle
And that one argument is a const

00:52:46.736 --> 00:52:49.456 A:middle
char star because C++ encoded

00:52:49.456 --> 00:52:51.556 A:middle
that extra data into the mangled

00:52:51.556 --> 00:52:51.906 A:middle
symbol.

00:52:52.536 --> 00:52:55.716 A:middle
Okay, so now we have a .o. In

00:52:55.716 --> 00:52:56.836 A:middle
fact, we're building a project,

00:52:56.836 --> 00:52:58.956 A:middle
we'll have a lot of them.

00:52:58.996 --> 00:53:00.186 A:middle
So what are we going to do with

00:52:58.996 --> 00:53:00.186 A:middle
So what are we going to do with

00:53:00.186 --> 00:53:00.516 A:middle
that?

00:53:00.516 --> 00:53:03.496 A:middle
Well, first off, the build

00:53:03.496 --> 00:53:05.166 A:middle
system is going to pass all of

00:53:05.166 --> 00:53:06.366 A:middle
the .o's in as inputs to the

00:53:06.366 --> 00:53:06.796 A:middle
linker.

00:53:06.796 --> 00:53:07.766 A:middle
And the linker's going to start

00:53:07.766 --> 00:53:08.986 A:middle
by creating a file to put them

00:53:08.986 --> 00:53:09.196 A:middle
in.

00:53:09.196 --> 00:53:10.656 A:middle
In this case we're building

00:53:10.656 --> 00:53:11.886 A:middle
PetKit which is an embedded

00:53:11.886 --> 00:53:13.066 A:middle
framework inside of PetWall.

00:53:13.066 --> 00:53:15.906 A:middle
And so we'll just start by

00:53:15.906 --> 00:53:16.626 A:middle
copying.

00:53:16.626 --> 00:53:17.846 A:middle
We'll create what's called a

00:53:17.896 --> 00:53:18.506 A:middle
text segment.

00:53:19.366 --> 00:53:20.696 A:middle
Which is where we keep all of

00:53:20.696 --> 00:53:21.836 A:middle
the code for an application.

00:53:21.896 --> 00:53:24.226 A:middle
And we'll take the cat.o and

00:53:24.226 --> 00:53:25.026 A:middle
we'll copy it in.

00:53:25.026 --> 00:53:25.846 A:middle
But we're going to split it into

00:53:25.846 --> 00:53:26.596 A:middle
two sections.

00:53:26.966 --> 00:53:28.366 A:middle
One for that string, and one for

00:53:28.366 --> 00:53:29.316 A:middle
the executable code.

00:53:29.316 --> 00:53:32.176 A:middle
But we now know the absolute

00:53:32.496 --> 00:53:33.816 A:middle
addresses of these things so the

00:53:33.816 --> 00:53:37.406 A:middle
linker can go and rewrite cat.o

00:53:37.616 --> 00:53:40.196 A:middle
to load from a specific offset.

00:53:40.796 --> 00:53:42.186 A:middle
You'll notice that the second

00:53:42.186 --> 00:53:43.796 A:middle
instruction just went away.

00:53:43.796 --> 00:53:45.456 A:middle
We replaced it with what, with a

00:53:45.456 --> 00:53:46.496 A:middle
null instruction that does

00:53:46.496 --> 00:53:46.906 A:middle
nothing.

00:53:47.866 --> 00:53:49.916 A:middle
But we cannot remove the

00:53:49.916 --> 00:53:51.756 A:middle
instruction because we can't

00:53:51.756 --> 00:53:52.816 A:middle
create or remove code.

00:53:52.816 --> 00:53:55.116 A:middle
It would mess up all of the

00:53:55.116 --> 00:53:56.226 A:middle
sizing that we've already done.

00:53:56.586 --> 00:53:58.706 A:middle
So instead it just is removed.

00:53:59.336 --> 00:54:01.556 A:middle
It, it's just replaced with a no

00:53:59.336 --> 00:54:01.556 A:middle
It, it's just replaced with a no

00:54:01.556 --> 00:54:02.046 A:middle
operation.

00:54:02.666 --> 00:54:03.636 A:middle
Finally we branch.

00:54:04.916 --> 00:54:10.276 A:middle
Okay, but we branch and what are

00:54:10.276 --> 00:54:11.366 A:middle
we going to do?

00:54:11.366 --> 00:54:12.456 A:middle
Because we have this undefined

00:54:12.456 --> 00:54:12.816 A:middle
symbol?

00:54:12.876 --> 00:54:14.146 A:middle
Well, we're going to go and keep

00:54:14.146 --> 00:54:15.696 A:middle
looking through, and all of our

00:54:15.696 --> 00:54:16.616 A:middle
.o's have been included at this

00:54:16.666 --> 00:54:17.326 A:middle
point.

00:54:18.416 --> 00:54:19.186 A:middle
So we'll start looking at the

00:54:19.186 --> 00:54:20.496 A:middle
static archives [inaudible] and

00:54:20.596 --> 00:54:22.376 A:middle
PetSupport.a is there.

00:54:22.376 --> 00:54:24.436 A:middle
And inside of PetSupport.a, we

00:54:24.436 --> 00:54:27.286 A:middle
have a couple of files including

00:54:27.286 --> 00:54:30.666 A:middle
PetSounds.o. And if we look, we

00:54:30.666 --> 00:54:31.966 A:middle
see that matching file-- that

00:54:31.966 --> 00:54:33.376 A:middle
matching symbol for playSound.

00:54:34.806 --> 00:54:38.216 A:middle
So we pull it in.

00:54:38.446 --> 00:54:39.796 A:middle
We'll note that we do not pull

00:54:39.796 --> 00:54:42.496 A:middle
in PetCare.o. Because that .o

00:54:42.496 --> 00:54:44.026 A:middle
file did not have any symbols

00:54:44.026 --> 00:54:45.236 A:middle
that were referred to by any of

00:54:45.236 --> 00:54:46.326 A:middle
the other portions of the

00:54:46.326 --> 00:54:46.966 A:middle
application.

00:54:47.536 --> 00:54:49.786 A:middle
Okay, so we pulled that in, but

00:54:49.786 --> 00:54:52.536 A:middle
now that needs, open which we

00:54:52.536 --> 00:54:53.316 A:middle
didn't define.

00:54:53.316 --> 00:54:56.256 A:middle
You'll see in the, in the, the

00:54:56.256 --> 00:54:57.096 A:middle
conversion we copied in.

00:54:57.096 --> 00:54:57.916 A:middle
We actually replaced it with

00:54:57.916 --> 00:54:59.626 A:middle
something called open$stub.

00:54:59.846 --> 00:55:01.306 A:middle
Now why did we do that?

00:54:59.846 --> 00:55:01.306 A:middle
Now why did we do that?

00:55:01.826 --> 00:55:03.326 A:middle
Well we kept looking, and we

00:55:03.326 --> 00:55:04.416 A:middle
found a copy of open.

00:55:04.416 --> 00:55:07.896 A:middle
And that copy of open is in the

00:55:07.896 --> 00:55:09.876 A:middle
lib system TBD file.

00:55:11.256 --> 00:55:13.306 A:middle
And so we said I know this is

00:55:13.306 --> 00:55:14.416 A:middle
part of the system library.

00:55:14.416 --> 00:55:15.456 A:middle
I'm not going to copy this into

00:55:15.456 --> 00:55:16.146 A:middle
my application.

00:55:16.146 --> 00:55:18.336 A:middle
But I need to put enough

00:55:18.336 --> 00:55:19.516 A:middle
information in the information

00:55:19.516 --> 00:55:20.836 A:middle
to make it so that it can call

00:55:20.836 --> 00:55:21.166 A:middle
this.

00:55:21.506 --> 00:55:23.556 A:middle
So we create a fake function

00:55:23.556 --> 00:55:25.626 A:middle
that's just a template where we

00:55:25.626 --> 00:55:26.656 A:middle
replaced a function with

00:55:26.656 --> 00:55:27.606 A:middle
whatever we're pulling out of

00:55:27.606 --> 00:55:28.726 A:middle
lib system which is open in this

00:55:28.726 --> 00:55:29.046 A:middle
case.

00:55:29.216 --> 00:55:30.426 A:middle
And if you look in that

00:55:30.426 --> 00:55:32.876 A:middle
function, it actually loads from

00:55:32.876 --> 00:55:35.036 A:middle
a pointer, open$ pointer.

00:55:36.186 --> 00:55:37.416 A:middle
And jumps to it.

00:55:37.416 --> 00:55:38.686 A:middle
So we just need a function

00:55:38.716 --> 00:55:39.996 A:middle
pointer, just like any normal C

00:55:39.996 --> 00:55:40.636 A:middle
function pointer.

00:55:41.256 --> 00:55:44.796 A:middle
And we'll create that down in

00:55:44.796 --> 00:55:46.186 A:middle
the data segment which is where

00:55:46.186 --> 00:55:47.636 A:middle
global variables would be if you

00:55:47.636 --> 00:55:48.396 A:middle
had any globals.

00:55:49.406 --> 00:55:50.966 A:middle
But it's just set to zero.

00:55:51.426 --> 00:55:53.226 A:middle
So if we dereference null and

00:55:53.226 --> 00:55:54.436 A:middle
jump to it we're going to crash.

00:55:56.036 --> 00:55:57.536 A:middle
So we then add what's called a

00:55:57.536 --> 00:55:58.606 A:middle
link edit segment.

00:55:58.606 --> 00:56:01.096 A:middle
And the link edit is metadata

00:55:58.606 --> 00:56:01.096 A:middle
And the link edit is metadata

00:56:01.096 --> 00:56:03.946 A:middle
that the linker tool uses to

00:56:03.946 --> 00:56:05.966 A:middle
leave information for the

00:56:05.966 --> 00:56:06.996 A:middle
operating system and what's

00:56:06.996 --> 00:56:08.816 A:middle
called the dynamic linker to fix

00:56:08.816 --> 00:56:09.836 A:middle
this up at runtime.

00:56:09.836 --> 00:56:12.196 A:middle
And for more information on that

00:56:12.196 --> 00:56:13.266 A:middle
you should look at the

00:56:13.266 --> 00:56:14.546 A:middle
Optimizing App Startup Time

00:56:14.546 --> 00:56:19.126 A:middle
session from 2016.

00:56:19.196 --> 00:56:22.346 A:middle
So I just want to go back over

00:56:22.346 --> 00:56:23.456 A:middle
what we went through today.

00:56:23.456 --> 00:56:25.056 A:middle
So Jake talked about the build

00:56:25.056 --> 00:56:26.376 A:middle
system and how you can use

00:56:26.376 --> 00:56:29.076 A:middle
dependencies to optimize your

00:56:29.076 --> 00:56:32.856 A:middle
built process for multi-core.

00:56:33.086 --> 00:56:35.666 A:middle
Jurgen walked through Clang and

00:56:35.666 --> 00:56:36.936 A:middle
how it finds headers for you.

00:56:36.936 --> 00:56:37.986 A:middle
And what you can do to optimize

00:56:37.986 --> 00:56:39.196 A:middle
your build-through modules.

00:56:40.636 --> 00:56:42.926 A:middle
Devin walked through how Swift

00:56:42.926 --> 00:56:45.846 A:middle
expand modules and all of the

00:56:45.846 --> 00:56:47.146 A:middle
things that we've implemented

00:56:47.146 --> 00:56:47.426 A:middle
this year like [inaudible]

00:56:47.426 --> 00:56:48.756 A:middle
processing to speed up your

00:56:48.756 --> 00:56:49.176 A:middle
builds.

00:56:49.176 --> 00:56:51.006 A:middle
And then finally the linker

00:56:51.006 --> 00:56:52.206 A:middle
takes the outputs of both

00:56:52.206 --> 00:56:53.866 A:middle
compilers and builds them into

00:56:53.866 --> 00:56:54.916 A:middle
your application.

00:56:54.916 --> 00:56:56.586 A:middle
At which point Xcode will go

00:56:56.586 --> 00:56:57.646 A:middle
and, and code [inaudible] and

00:56:57.646 --> 00:56:59.416 A:middle
package it up with other parts

00:57:00.376 --> 00:57:02.116 A:middle
of your application for

00:57:02.116 --> 00:57:02.726 A:middle
distribution.

00:57:04.026 --> 00:57:08.026 A:middle
So most of this is open source,

00:57:08.026 --> 00:57:08.756 A:middle
available if you're really

00:57:08.756 --> 00:57:09.306 A:middle
curious.

00:57:09.306 --> 00:57:10.926 A:middle
You can look at Swift or Clang

00:57:10.926 --> 00:57:13.646 A:middle
or the llbuild execution engine

00:57:14.916 --> 00:57:15.826 A:middle
at these URLs.

00:57:16.626 --> 00:57:18.046 A:middle
And I just want to thank you all

00:57:18.046 --> 00:57:18.926 A:middle
for coming.

00:57:19.266 --> 00:57:21.416 A:middle
And I hope you've had a great

00:57:21.416 --> 00:57:21.576 A:middle
WWDC.

00:57:21.576 --> 00:57:23.346 A:middle
And we'll be in the labs.

00:57:23.346 --> 00:57:23.836 A:middle
Thank you.

00:57:24.016 --> 00:57:26.000 A:middle
[ Applause ]
