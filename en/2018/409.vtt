WEBVTT

00:00:07.516 --> 00:00:20.516 A:middle
[ Music ]

00:00:21.516 --> 00:00:27.546 A:middle
[ Applause ]

00:00:28.046 --> 00:00:29.076 A:middle
&gt;&gt; Good morning, welcome to

00:00:29.116 --> 00:00:30.116 A:middle
What's New in LLVM.

00:00:31.136 --> 00:00:32.406 A:middle
I'm Jim Grosbach, your friendly

00:00:32.406 --> 00:00:33.766 A:middle
neighborhood pointy hair boss.

00:00:34.036 --> 00:00:35.536 A:middle
I'm here to tell you a little

00:00:35.536 --> 00:00:37.966 A:middle
bit of background about the LLVM

00:00:37.966 --> 00:00:40.066 A:middle
project before we dive into the

00:00:40.066 --> 00:00:41.296 A:middle
deep technical details of all

00:00:41.296 --> 00:00:43.296 A:middle
the exciting new things that we

00:00:43.296 --> 00:00:44.306 A:middle
have for you today.

00:00:45.426 --> 00:00:48.276 A:middle
Start off, LLVM is more than

00:00:48.276 --> 00:00:50.916 A:middle
just the compiler, it is the

00:00:50.916 --> 00:00:52.736 A:middle
background for the Clang

00:00:52.736 --> 00:00:54.096 A:middle
compiler, for the C family of

00:00:54.096 --> 00:00:55.706 A:middle
languages that we all use every

00:00:55.706 --> 00:00:57.596 A:middle
day, but it also powers the

00:00:57.596 --> 00:01:00.316 A:middle
Static Analyzer, the sanitizers,

00:00:57.596 --> 00:01:00.316 A:middle
Static Analyzer, the sanitizers,

00:01:00.316 --> 00:01:03.216 A:middle
the LLDB debugger, and is the

00:01:03.216 --> 00:01:04.726 A:middle
optimization code generation

00:01:04.726 --> 00:01:06.616 A:middle
framework underneath the GPU

00:01:06.616 --> 00:01:08.576 A:middle
shader compilers for all of

00:01:08.576 --> 00:01:11.166 A:middle
Apple's mobile platforms.

00:01:12.016 --> 00:01:13.396 A:middle
In addition to this, it also

00:01:13.396 --> 00:01:15.806 A:middle
powers one additional little

00:01:15.806 --> 00:01:17.726 A:middle
project that you may have heard

00:01:17.726 --> 00:01:19.036 A:middle
of from time to time called

00:01:19.036 --> 00:01:19.676 A:middle
Swift.

00:01:21.016 --> 00:01:23.906 A:middle
And like Swift LLVM is an open

00:01:23.906 --> 00:01:24.906 A:middle
source project.

00:01:26.456 --> 00:01:27.696 A:middle
We all operate under the

00:01:27.696 --> 00:01:30.276 A:middle
watchful eye of our LLVM wyvern

00:01:30.276 --> 00:01:31.916 A:middle
here, he's normally a very

00:01:31.916 --> 00:01:33.586 A:middle
friendly fellow, though I do

00:01:33.586 --> 00:01:34.776 A:middle
have to caution you he gets a

00:01:34.776 --> 00:01:36.456 A:middle
little bit cranky if you call

00:01:36.456 --> 00:01:38.176 A:middle
him a dragon so don't do that.

00:01:39.596 --> 00:01:42.296 A:middle
As an open source project LLVM

00:01:42.296 --> 00:01:44.996 A:middle
is a partnership, we work with

00:01:44.996 --> 00:01:47.186 A:middle
industry partners, academics,

00:01:47.246 --> 00:01:49.356 A:middle
researchers and hobbyists from

00:01:49.596 --> 00:01:51.166 A:middle
all over the world and in

00:01:51.166 --> 00:01:53.106 A:middle
different parts of the industry

00:01:53.756 --> 00:01:55.826 A:middle
and many more all over the

00:01:55.866 --> 00:01:56.396 A:middle
place.

00:01:56.646 --> 00:01:58.036 A:middle
This is really fantastic, we

00:01:58.396 --> 00:01:59.576 A:middle
work together to build the

00:01:59.576 --> 00:02:01.646 A:middle
greatest tools that we possibly

00:01:59.576 --> 00:02:01.646 A:middle
greatest tools that we possibly

00:02:01.646 --> 00:02:03.806 A:middle
can to move technology forward.

00:02:04.906 --> 00:02:07.686 A:middle
And if you ever have a compiler

00:02:07.686 --> 00:02:08.895 A:middle
itch that you would like to

00:02:08.895 --> 00:02:10.735 A:middle
scratch we would like to invite

00:02:10.735 --> 00:02:13.396 A:middle
you to participate with us and

00:02:13.396 --> 00:02:15.146 A:middle
go to the LLVM website here at

00:02:15.146 --> 00:02:17.986 A:middle
llvm.org or you can come talk to

00:02:17.986 --> 00:02:19.716 A:middle
us later today later today in

00:02:19.716 --> 00:02:21.906 A:middle
the LLVM labs and many of our

00:02:21.906 --> 00:02:23.446 A:middle
compiler engineers from Apple

00:02:23.446 --> 00:02:25.066 A:middle
will be there and I'm sure will

00:02:25.066 --> 00:02:27.506 A:middle
be more than happy to talk your

00:02:27.506 --> 00:02:28.786 A:middle
ear off about anything and

00:02:28.786 --> 00:02:30.136 A:middle
everything compiler related

00:02:30.476 --> 00:02:31.646 A:middle
you've ever wanted to know.

00:02:32.666 --> 00:02:36.096 A:middle
So for today we have a great set

00:02:36.096 --> 00:02:37.306 A:middle
of things that we want to share

00:02:37.306 --> 00:02:37.656 A:middle
with you.

00:02:37.656 --> 00:02:39.476 A:middle
We have updates on automated

00:02:39.476 --> 00:02:40.766 A:middle
reference counting that makes it

00:02:40.766 --> 00:02:42.826 A:middle
even easier for the compiler to

00:02:42.826 --> 00:02:43.876 A:middle
help you with your memory

00:02:43.876 --> 00:02:44.466 A:middle
management.

00:02:44.786 --> 00:02:47.146 A:middle
We have new diagnostics in Xcode

00:02:47.206 --> 00:02:49.266 A:middle
10 and new checks in the Static

00:02:49.266 --> 00:02:51.536 A:middle
Analyzer to help catch bugs in

00:02:51.536 --> 00:02:53.536 A:middle
your project sooner at build

00:02:53.536 --> 00:02:55.646 A:middle
time to improve the quality of

00:02:55.646 --> 00:02:56.376 A:middle
your code.

00:02:56.786 --> 00:02:58.116 A:middle
We have compiler features that

00:02:58.116 --> 00:02:59.526 A:middle
improve security, both of

00:02:59.526 --> 00:03:01.446 A:middle
Apple's platforms and of your

00:02:59.526 --> 00:03:01.446 A:middle
Apple's platforms and of your

00:03:01.446 --> 00:03:01.966 A:middle
apps.

00:03:02.336 --> 00:03:04.506 A:middle
And new features to allow you to

00:03:04.506 --> 00:03:06.446 A:middle
take advantage of all of the

00:03:06.446 --> 00:03:08.186 A:middle
really great new things on the

00:03:08.186 --> 00:03:09.866 A:middle
hardware architectures to get

00:03:09.866 --> 00:03:11.696 A:middle
the performance that we all want

00:03:12.026 --> 00:03:13.276 A:middle
out of our platforms and

00:03:13.276 --> 00:03:14.016 A:middle
architectures.

00:03:14.786 --> 00:03:16.126 A:middle
So with that I would like to

00:03:16.126 --> 00:03:18.366 A:middle
invite my colleague Alex up to

00:03:18.646 --> 00:03:19.806 A:middle
talk about ARC.

00:03:20.476 --> 00:03:20.886 A:middle
Alex.

00:03:21.516 --> 00:03:27.546 A:middle
[ Applause ]

00:03:28.046 --> 00:03:28.676 A:middle
&gt;&gt; Thank you, Jim.

00:03:29.696 --> 00:03:31.736 A:middle
Automatic reference counting has

00:03:31.736 --> 00:03:33.956 A:middle
greatly simplified Objective-C

00:03:33.956 --> 00:03:36.196 A:middle
program since we introduced it a

00:03:36.196 --> 00:03:37.216 A:middle
couple of years ago.

00:03:38.106 --> 00:03:40.016 A:middle
A couple of restrictions made it

00:03:40.016 --> 00:03:42.066 A:middle
harder to migrate from the old

00:03:42.376 --> 00:03:44.416 A:middle
manual retain release mode over

00:03:44.416 --> 00:03:44.926 A:middle
to ARC.

00:03:45.576 --> 00:03:46.866 A:middle
I'm happy to say that we've now

00:03:46.866 --> 00:03:48.416 A:middle
lifted one such restriction.

00:03:49.056 --> 00:03:50.496 A:middle
Xcode 10 has support for ARC

00:03:50.536 --> 00:03:51.706 A:middle
object pointer fields in C

00:03:51.736 --> 00:03:51.976 A:middle
structures.

00:03:52.516 --> 00:04:00.616 A:middle
[ Applause ]

00:03:52.516 --> 00:04:00.616 A:middle
[ Applause ]

00:04:01.116 --> 00:04:02.166 A:middle
Let's take a look at an example

00:04:02.336 --> 00:04:03.506 A:middle
let's say we'd like to write a

00:04:03.506 --> 00:04:05.846 A:middle
food ordering app and we'd like

00:04:05.876 --> 00:04:07.676 A:middle
to create a data structure which

00:04:07.676 --> 00:04:09.176 A:middle
represents a menu item.

00:04:09.736 --> 00:04:13.226 A:middle
In Xcode 9 and earlier it would

00:04:13.226 --> 00:04:14.716 A:middle
have been impossible for us to

00:04:14.716 --> 00:04:17.055 A:middle
actually use a C structure with

00:04:17.055 --> 00:04:19.505 A:middle
ARC object pointer fields, so we

00:04:19.536 --> 00:04:21.546 A:middle
would have had to use a C, an

00:04:21.546 --> 00:04:24.506 A:middle
Objective-C class here.

00:04:24.506 --> 00:04:26.516 A:middle
Xcode 10 now allows us to

00:04:26.516 --> 00:04:27.926 A:middle
actually create a C structure

00:04:27.926 --> 00:04:29.616 A:middle
that has ARC object pointer

00:04:29.726 --> 00:04:29.976 A:middle
fields.

00:04:35.066 --> 00:04:35.906 A:middle
Let's keep going and keep

00:04:35.906 --> 00:04:38.176 A:middle
writing our food ordering app.

00:04:38.176 --> 00:04:39.546 A:middle
Let's create a function that

00:04:39.606 --> 00:04:41.236 A:middle
orders free food for us.

00:04:41.696 --> 00:04:43.246 A:middle
In the function let's create a

00:04:43.246 --> 00:04:45.736 A:middle
variable item of type menu item

00:04:45.976 --> 00:04:46.996 A:middle
with a price of zero.

00:04:48.416 --> 00:04:50.436 A:middle
Then let's pass this item into

00:04:50.436 --> 00:04:52.096 A:middle
another function that actually

00:04:52.376 --> 00:04:53.416 A:middle
orders the food for us.

00:04:54.846 --> 00:04:57.276 A:middle
When the item is created the

00:04:57.276 --> 00:04:59.716 A:middle
compiler has to synthesize code

00:05:00.086 --> 00:05:02.096 A:middle
which retains the ARC object

00:05:02.176 --> 00:05:03.796 A:middle
pointer fields in the item.

00:05:05.066 --> 00:05:06.766 A:middle
The code comments on the slide

00:05:07.106 --> 00:05:08.936 A:middle
demonstrate the code that the

00:05:08.936 --> 00:05:10.306 A:middle
compiler synthesizes.

00:05:11.056 --> 00:05:13.386 A:middle
This code ensures the name and

00:05:13.386 --> 00:05:15.586 A:middle
the price of the item are not

00:05:15.586 --> 00:05:17.346 A:middle
released prematurely before the

00:05:17.346 --> 00:05:18.726 A:middle
item is actually used.

00:05:18.726 --> 00:05:23.076 A:middle
Now at the end of the function

00:05:23.286 --> 00:05:25.706 A:middle
item goes out of scope and is

00:05:25.706 --> 00:05:27.666 A:middle
deallocated from the stack so

00:05:27.666 --> 00:05:30.256 A:middle
the compiler has to synthesize

00:05:30.256 --> 00:05:32.686 A:middle
code which releases the ARC

00:05:32.686 --> 00:05:34.116 A:middle
object pointer fields in the

00:05:34.116 --> 00:05:34.536 A:middle
item.

00:05:35.596 --> 00:05:37.306 A:middle
This ensures that the name and

00:05:37.306 --> 00:05:39.536 A:middle
the price are not leaked when

00:05:39.536 --> 00:05:40.756 A:middle
the item is released.

00:05:42.986 --> 00:05:44.676 A:middle
Previously it was possible to

00:05:44.676 --> 00:05:46.546 A:middle
use Objective-C object pointer

00:05:46.546 --> 00:05:48.916 A:middle
fields when using manual

00:05:48.976 --> 00:05:51.076 A:middle
retained release mode, but you

00:05:51.076 --> 00:05:53.246 A:middle
had to write the retains and

00:05:53.276 --> 00:05:54.506 A:middle
releases yourself.

00:05:55.206 --> 00:05:57.856 A:middle
With ARC the compiler hides all

00:05:57.856 --> 00:05:59.826 A:middle
of this complexity for you and

00:05:59.826 --> 00:06:01.646 A:middle
synthesizes code that retains

00:05:59.826 --> 00:06:01.646 A:middle
synthesizes code that retains

00:06:01.646 --> 00:06:02.826 A:middle
and releases the fields.

00:06:03.676 --> 00:06:04.956 A:middle
So the compiler is really your

00:06:04.956 --> 00:06:07.056 A:middle
friend here and it does the

00:06:07.056 --> 00:06:09.116 A:middle
correct job of managing memory

00:06:09.286 --> 00:06:12.056 A:middle
for variables on the stack and

00:06:12.056 --> 00:06:13.846 A:middle
also for fields in other

00:06:13.846 --> 00:06:16.156 A:middle
structures, and also instance

00:06:16.156 --> 00:06:17.916 A:middle
variables inside Objective-C

00:06:17.916 --> 00:06:18.436 A:middle
classes.

00:06:19.686 --> 00:06:21.756 A:middle
But there is one place we have

00:06:21.816 --> 00:06:23.346 A:middle
to put in a little bit of extra

00:06:23.346 --> 00:06:25.126 A:middle
work to support structures with

00:06:25.126 --> 00:06:27.996 A:middle
ARC object pointer fields and

00:06:27.996 --> 00:06:29.386 A:middle
that place is heap.

00:06:30.656 --> 00:06:31.926 A:middle
Let's go back to our structure,

00:06:32.216 --> 00:06:33.126 A:middle
let's say you would like to

00:06:33.126 --> 00:06:35.366 A:middle
allocate an array of menu items

00:06:35.366 --> 00:06:36.046 A:middle
on the heap.

00:06:36.796 --> 00:06:38.526 A:middle
Now if this was an Objective-C

00:06:38.526 --> 00:06:40.836 A:middle
interface we could have used an

00:06:40.946 --> 00:06:43.366 A:middle
NSArray here, but it's not so

00:06:43.366 --> 00:06:45.196 A:middle
let's use malloc and free.

00:06:46.166 --> 00:06:48.416 A:middle
Now this code actually has two

00:06:48.596 --> 00:06:49.176 A:middle
issues.

00:06:49.766 --> 00:06:52.176 A:middle
First issue, the memory is not

00:06:52.176 --> 00:06:53.956 A:middle
zero initialized when it's

00:06:53.956 --> 00:06:56.146 A:middle
allocated, which means that

00:06:56.146 --> 00:06:58.106 A:middle
their pointers will be invalid

00:06:58.646 --> 00:07:00.396 A:middle
which will cause undesired

00:06:58.646 --> 00:07:00.396 A:middle
which will cause undesired

00:07:00.696 --> 00:07:02.156 A:middle
runtime behavior for your

00:07:02.156 --> 00:07:03.316 A:middle
program at runtime.

00:07:04.896 --> 00:07:07.996 A:middle
The second issue is that the ARC

00:07:07.996 --> 00:07:09.406 A:middle
object pointer fields are not

00:07:09.516 --> 00:07:11.116 A:middle
cleared before the memory is

00:07:11.166 --> 00:07:14.666 A:middle
deallocated which will cause

00:07:14.876 --> 00:07:16.496 A:middle
runtime memory leaks in your

00:07:16.496 --> 00:07:17.076 A:middle
program.

00:07:17.656 --> 00:07:21.916 A:middle
Now to fix the first issue you

00:07:21.916 --> 00:07:23.916 A:middle
can replace the call to malloc

00:07:23.976 --> 00:07:25.106 A:middle
with a call to calloc.

00:07:25.816 --> 00:07:27.526 A:middle
This will ensure that your

00:07:27.526 --> 00:07:29.346 A:middle
memory is zero initialized,

00:07:30.126 --> 00:07:32.386 A:middle
which will remove all of those

00:07:32.546 --> 00:07:34.666 A:middle
nasty unexpected runtime issues.

00:07:35.796 --> 00:07:38.076 A:middle
To fix the second issue you can

00:07:38.076 --> 00:07:40.516 A:middle
write a loop before it's

00:07:40.516 --> 00:07:42.086 A:middle
allocated in your memory to

00:07:42.086 --> 00:07:43.976 A:middle
clear out all of the ARC object

00:07:44.036 --> 00:07:45.396 A:middle
pointer fields in your items.

00:07:46.326 --> 00:07:48.226 A:middle
This will ensure that the name

00:07:48.226 --> 00:07:50.076 A:middle
and the price in the items are

00:07:50.076 --> 00:07:51.836 A:middle
not leaked when the items are

00:07:51.836 --> 00:07:51.976 A:middle
freed.

00:07:56.086 --> 00:07:57.836 A:middle
Now this is an exciting new

00:07:57.906 --> 00:08:00.586 A:middle
feature and if any of you were

00:07:57.906 --> 00:08:00.586 A:middle
feature and if any of you were

00:08:00.586 --> 00:08:02.896 A:middle
put off from migrates over to

00:08:02.896 --> 00:08:05.746 A:middle
ARC because of lack of features

00:08:05.746 --> 00:08:07.906 A:middle
like that I hope that support

00:08:07.906 --> 00:08:09.486 A:middle
from ARC object pointer fields

00:08:09.486 --> 00:08:11.596 A:middle
in Xcode 10 will help you

00:08:11.596 --> 00:08:12.816 A:middle
reconsider your choice.

00:08:14.076 --> 00:08:15.526 A:middle
Now let's take a look at

00:08:16.356 --> 00:08:17.636 A:middle
Objective-C pointers and

00:08:17.636 --> 00:08:19.476 A:middle
structures in general and see

00:08:19.856 --> 00:08:22.646 A:middle
where and how can the structures

00:08:22.686 --> 00:08:25.066 A:middle
be used in different language

00:08:25.066 --> 00:08:26.286 A:middle
modes in Xcode 10.

00:08:27.506 --> 00:08:30.966 A:middle
So in Xcode 10 you can use

00:08:31.146 --> 00:08:33.056 A:middle
structures that have Objective-C

00:08:33.056 --> 00:08:35.015 A:middle
object pointer fields across

00:08:35.015 --> 00:08:36.086 A:middle
different language modes.

00:08:36.576 --> 00:08:38.426 A:middle
For example, you can use the

00:08:38.496 --> 00:08:41.785 A:middle
same structure in C Objective-C

00:08:41.926 --> 00:08:43.796 A:middle
or even Objective-C++.

00:08:44.806 --> 00:08:47.046 A:middle
And it will work correctly even

00:08:47.246 --> 00:08:49.316 A:middle
when you're compiling your code

00:08:49.646 --> 00:08:51.956 A:middle
in ARC or in the manual retain

00:08:51.956 --> 00:08:52.606 A:middle
release mode.

00:08:54.176 --> 00:08:56.446 A:middle
In Xcode 10 we actually unified

00:08:56.796 --> 00:08:59.746 A:middle
the Objective-C++ ABI between

00:08:59.746 --> 00:09:02.596 A:middle
calls to functions that took in

00:08:59.746 --> 00:09:02.596 A:middle
calls to functions that took in

00:09:02.666 --> 00:09:05.126 A:middle
or returned structures that had

00:09:05.126 --> 00:09:06.676 A:middle
ARC object pointer fields in

00:09:06.676 --> 00:09:07.916 A:middle
Objective-C++.

00:09:08.316 --> 00:09:10.756 A:middle
And this was done through an ABI

00:09:11.056 --> 00:09:14.046 A:middle
change in Xcode 10 and ABI

00:09:14.226 --> 00:09:16.016 A:middle
change affects functions in

00:09:16.016 --> 00:09:19.166 A:middle
Objective C++ which return or

00:09:19.166 --> 00:09:21.206 A:middle
take in a structure by value

00:09:21.606 --> 00:09:23.516 A:middle
that has ARC object pointer

00:09:23.516 --> 00:09:26.006 A:middle
fields and no special member

00:09:26.006 --> 00:09:27.726 A:middle
functions like constructors or

00:09:27.726 --> 00:09:28.626 A:middle
destructors.

00:09:30.126 --> 00:09:31.776 A:middle
Now if you are not sure what

00:09:31.896 --> 00:09:33.656 A:middle
this means for you or whether

00:09:33.946 --> 00:09:35.676 A:middle
your code is affected by this

00:09:35.716 --> 00:09:38.146 A:middle
ABI change please take a look at

00:09:38.276 --> 00:09:40.286 A:middle
Xcode's release notes where we

00:09:40.286 --> 00:09:42.526 A:middle
describe in more details the

00:09:42.526 --> 00:09:44.296 A:middle
effects and the impact of this

00:09:44.296 --> 00:09:44.886 A:middle
ABI change.

00:09:49.046 --> 00:09:50.676 A:middle
Now there is one caveat when it

00:09:50.676 --> 00:09:53.176 A:middle
comes to the ARC object pointer

00:09:53.176 --> 00:09:55.866 A:middle
fields and C structures, they're

00:09:55.866 --> 00:09:56.976 A:middle
not supported in Swift.

00:09:57.766 --> 00:09:59.546 A:middle
So if you try to use a structure

00:10:00.046 --> 00:10:01.386 A:middle
that has ARC object pointer

00:10:01.386 --> 00:10:03.766 A:middle
fields from Swift you will just

00:10:03.766 --> 00:10:05.346 A:middle
get a compilation error because

00:10:05.676 --> 00:10:06.976 A:middle
the structure will not be found.

00:10:14.046 --> 00:10:16.286 A:middle
In addition to new features like

00:10:16.696 --> 00:10:18.356 A:middle
support for ARC object pointer

00:10:18.356 --> 00:10:22.306 A:middle
fields Xcode 10 comes with a lot

00:10:22.306 --> 00:10:24.356 A:middle
of new compiler diagnostics.

00:10:24.896 --> 00:10:26.426 A:middle
We actually have over a hundred

00:10:26.556 --> 00:10:28.986 A:middle
new warnings in Xcode 10 and

00:10:28.986 --> 00:10:30.566 A:middle
today I'd like to talk about two

00:10:30.566 --> 00:10:30.846 A:middle
of them.

00:10:31.986 --> 00:10:33.326 A:middle
The first warning might be of

00:10:33.556 --> 00:10:36.036 A:middle
interest to those of you who

00:10:36.036 --> 00:10:38.676 A:middle
have mixed Swift and Objective-C

00:10:38.676 --> 00:10:39.036 A:middle
code.

00:10:39.906 --> 00:10:42.466 A:middle
So as you know Swift code can be

00:10:42.466 --> 00:10:45.786 A:middle
imported into Objective-C and

00:10:46.316 --> 00:10:48.586 A:middle
Xcode allows you to do that by

00:10:48.586 --> 00:10:50.356 A:middle
generating a header file that

00:10:50.356 --> 00:10:52.826 A:middle
describes the Swift interface

00:10:53.086 --> 00:10:54.836 A:middle
using Objective-C declarations.

00:10:55.266 --> 00:10:57.856 A:middle
And you can import this header

00:10:57.856 --> 00:10:59.476 A:middle
file into your own Objective-C

00:10:59.476 --> 00:11:01.736 A:middle
code to get access to the

00:10:59.476 --> 00:11:01.736 A:middle
code to get access to the

00:11:01.736 --> 00:11:03.816 A:middle
underlying Swift declarations.

00:11:04.756 --> 00:11:06.546 A:middle
Now let's get more specific and

00:11:06.546 --> 00:11:08.396 A:middle
let's talk about how Swift's

00:11:08.546 --> 00:11:10.486 A:middle
closure parameters are important

00:11:10.486 --> 00:11:11.436 A:middle
to Objective-C.

00:11:12.226 --> 00:11:14.296 A:middle
So right now on the screen you

00:11:14.296 --> 00:11:16.186 A:middle
see an example of a Swift

00:11:16.356 --> 00:11:17.846 A:middle
protocol called Executor.

00:11:18.796 --> 00:11:20.796 A:middle
This protocol defines a function

00:11:20.796 --> 00:11:22.726 A:middle
member called performOperation

00:11:22.976 --> 00:11:24.536 A:middle
which takes in a closure

00:11:24.536 --> 00:11:25.926 A:middle
parameter called handler.

00:11:27.246 --> 00:11:29.506 A:middle
Now in Swift closure parameters

00:11:29.506 --> 00:11:31.236 A:middle
are non-escaping by default,

00:11:31.576 --> 00:11:33.496 A:middle
which means that they should not

00:11:33.496 --> 00:11:35.896 A:middle
be retained or called after the

00:11:35.896 --> 00:11:37.056 A:middle
function returns.

00:11:38.596 --> 00:11:40.366 A:middle
Now it can be easy for the

00:11:40.366 --> 00:11:42.486 A:middle
program and to forget that this

00:11:42.486 --> 00:11:44.826 A:middle
contract exists when conforming

00:11:44.826 --> 00:11:46.446 A:middle
to the executive protocol in

00:11:46.446 --> 00:11:47.356 A:middle
Objective-C.

00:11:48.156 --> 00:11:50.316 A:middle
For example, as you see right

00:11:50.316 --> 00:11:52.096 A:middle
now on the slide we have a

00:11:52.096 --> 00:11:54.406 A:middle
dispatch Executor interface in

00:11:54.406 --> 00:11:56.566 A:middle
Objective-C and conforms to the

00:11:56.566 --> 00:11:58.676 A:middle
Executor protocol, so it

00:11:58.676 --> 00:12:00.416 A:middle
provides the performOperation

00:11:58.676 --> 00:12:00.416 A:middle
provides the performOperation

00:12:00.416 --> 00:12:02.146 A:middle
method which takes in the

00:12:02.146 --> 00:12:03.616 A:middle
handler block parameter that

00:12:03.656 --> 00:12:05.726 A:middle
corresponds to Swift's handler

00:12:05.726 --> 00:12:06.766 A:middle
closure parameter.

00:12:07.516 --> 00:12:08.736 A:middle
But just by looking at the

00:12:08.736 --> 00:12:11.406 A:middle
Objective-C code we have no way

00:12:11.406 --> 00:12:12.786 A:middle
of knowing whether the handler

00:12:12.786 --> 00:12:14.486 A:middle
parameter can escape or not.

00:12:15.986 --> 00:12:19.046 A:middle
Xcode 10 now provides a warning

00:12:19.366 --> 00:12:21.976 A:middle
that helps us to remember that

00:12:21.976 --> 00:12:23.656 A:middle
this parameter is actually

00:12:23.926 --> 00:12:24.866 A:middle
non-escaping.

00:12:25.456 --> 00:12:29.346 A:middle
To fix this this warning you can

00:12:29.486 --> 00:12:31.196 A:middle
annotate your block parameter

00:12:31.196 --> 00:12:33.596 A:middle
with the NS NOESCAPE annotation.

00:12:34.676 --> 00:12:36.056 A:middle
You should also annotate the

00:12:36.056 --> 00:12:38.416 A:middle
implementation of the method or

00:12:38.416 --> 00:12:39.456 A:middle
the parameter in the

00:12:39.456 --> 00:12:40.716 A:middle
implementation of the method

00:12:40.786 --> 00:12:42.816 A:middle
with NS NOESCAPE annotation.

00:12:44.246 --> 00:12:46.466 A:middle
Now the NS NOESCAPE annotation

00:12:46.636 --> 00:12:48.976 A:middle
is simply a reminder for you the

00:12:48.976 --> 00:12:51.656 A:middle
programmer to ensure that you

00:12:51.656 --> 00:12:54.516 A:middle
don't store or call the handler

00:12:54.516 --> 00:12:55.756 A:middle
block after they perform

00:12:55.756 --> 00:12:57.466 A:middle
operation method returns.

00:12:58.756 --> 00:13:01.866 A:middle
So it's there for you to help

00:12:58.756 --> 00:13:01.866 A:middle
So it's there for you to help

00:13:01.866 --> 00:13:03.196 A:middle
you remember that there is this

00:13:03.196 --> 00:13:05.686 A:middle
contract that exists between

00:13:05.686 --> 00:13:09.926 A:middle
your Swift and Objective-C code.

00:13:10.146 --> 00:13:11.616 A:middle
Now the second warning might be

00:13:11.616 --> 00:13:14.326 A:middle
of interest to those of you who

00:13:14.326 --> 00:13:16.056 A:middle
work with more low-level code

00:13:16.056 --> 00:13:18.296 A:middle
and who care about the way that

00:13:18.296 --> 00:13:20.156 A:middle
structures are laid out in

00:13:20.156 --> 00:13:20.566 A:middle
memory.

00:13:21.846 --> 00:13:22.886 A:middle
Let's take a look at one

00:13:22.886 --> 00:13:23.406 A:middle
structure.

00:13:23.866 --> 00:13:25.776 A:middle
So in C structures have to

00:13:25.776 --> 00:13:27.766 A:middle
follow strict layout and

00:13:27.766 --> 00:13:28.816 A:middle
alignment rules.

00:13:29.866 --> 00:13:31.126 A:middle
In this particular structure

00:13:31.126 --> 00:13:32.096 A:middle
that you see right now on the

00:13:32.096 --> 00:13:34.606 A:middle
slide the compiler has to insert

00:13:34.646 --> 00:13:36.706 A:middle
a 2-byte pattern between the

00:13:36.706 --> 00:13:38.666 A:middle
second and the third field of

00:13:38.666 --> 00:13:39.246 A:middle
the structure.

00:13:40.776 --> 00:13:42.066 A:middle
Sometimes you might want to

00:13:42.066 --> 00:13:44.386 A:middle
relax these rules and the

00:13:44.386 --> 00:13:46.956 A:middle
compiler provides a pragma pack

00:13:47.066 --> 00:13:48.906 A:middle
directive that you can use to

00:13:48.906 --> 00:13:50.446 A:middle
control the layout and the

00:13:50.446 --> 00:13:51.846 A:middle
alignment of your structures.

00:13:54.196 --> 00:13:56.956 A:middle
Now in this example we use the

00:13:56.956 --> 00:13:59.906 A:middle
pragma pack push, 1 directive to

00:13:59.906 --> 00:14:03.556 A:middle
remove this fixated layout and

00:13:59.906 --> 00:14:03.556 A:middle
remove this fixated layout and

00:14:03.556 --> 00:14:05.346 A:middle
to ensure that our structure is

00:14:05.436 --> 00:14:05.956 A:middle
tightly packed.

00:14:07.436 --> 00:14:08.766 A:middle
This can be useful when

00:14:09.446 --> 00:14:11.146 A:middle
serializing your structures or

00:14:11.146 --> 00:14:12.296 A:middle
when transferring your

00:14:12.296 --> 00:14:13.576 A:middle
structures over the network.

00:14:14.836 --> 00:14:16.976 A:middle
Now pragma pack is typically

00:14:16.976 --> 00:14:19.036 A:middle
used with a push and a pop

00:14:19.136 --> 00:14:21.386 A:middle
directive, but it can be easy

00:14:21.386 --> 00:14:23.526 A:middle
for the programmer to forget to

00:14:23.526 --> 00:14:25.416 A:middle
insert the pop into the code.

00:14:27.246 --> 00:14:29.346 A:middle
Xcode 10 will now warn about

00:14:29.376 --> 00:14:31.526 A:middle
code that doesn't have a

00:14:31.526 --> 00:14:33.526 A:middle
corresponding pragma pack pop

00:14:33.526 --> 00:14:36.036 A:middle
directive and to point you to

00:14:36.036 --> 00:14:37.516 A:middle
the location of the push.

00:14:38.146 --> 00:14:41.426 A:middle
So to fix this warning you

00:14:41.426 --> 00:14:42.866 A:middle
should take a look at the

00:14:42.866 --> 00:14:44.586 A:middle
location of your push directive

00:14:45.156 --> 00:14:47.716 A:middle
and insert the pop directive at

00:14:47.716 --> 00:14:49.706 A:middle
the corresponding location in

00:14:49.706 --> 00:14:50.376 A:middle
your code.

00:14:51.806 --> 00:14:53.426 A:middle
So in our case we can insert the

00:14:53.426 --> 00:14:55.296 A:middle
pop directly after the packed

00:14:55.376 --> 00:14:55.836 A:middle
structure.

00:14:57.186 --> 00:15:00.986 A:middle
Once we do that the new layout

00:14:57.186 --> 00:15:00.986 A:middle
Once we do that the new layout

00:15:00.986 --> 00:15:02.546 A:middle
rules will apply only to the

00:15:02.546 --> 00:15:05.006 A:middle
packed structure so they won't

00:15:05.296 --> 00:15:06.676 A:middle
affect any other structures in

00:15:06.676 --> 00:15:06.976 A:middle
our program.

00:15:12.046 --> 00:15:13.596 A:middle
These two new warnings that I

00:15:13.596 --> 00:15:16.026 A:middle
mentioned are enabled by default

00:15:16.026 --> 00:15:18.936 A:middle
in Xcode 10 and they are there

00:15:18.936 --> 00:15:21.186 A:middle
to help you write more correct

00:15:21.346 --> 00:15:22.606 A:middle
and more robust code.

00:15:23.306 --> 00:15:24.766 A:middle
And to talk more about more

00:15:24.766 --> 00:15:27.066 A:middle
correct and more robust code I'd

00:15:27.066 --> 00:15:28.646 A:middle
like to invite George up on

00:15:28.646 --> 00:15:30.126 A:middle
stage who will talk about the

00:15:30.126 --> 00:15:31.556 A:middle
new static analyzing

00:15:31.556 --> 00:15:33.126 A:middle
improvements in Xcode 10.

00:15:33.376 --> 00:15:33.536 A:middle
George.

00:15:34.516 --> 00:15:39.500 A:middle
[ Applause ]

00:15:42.056 --> 00:15:43.426 A:middle
&gt;&gt; Thanks Alex, so I would like

00:15:43.426 --> 00:15:44.836 A:middle
to tell you about some of the

00:15:44.836 --> 00:15:46.706 A:middle
improvements we have done for

00:15:46.986 --> 00:15:48.896 A:middle
Xcode 10 for the Clang Static

00:15:48.896 --> 00:15:49.456 A:middle
Analyzer.

00:15:50.356 --> 00:15:52.086 A:middle
So the Clang Static Analyzer is

00:15:52.086 --> 00:15:53.566 A:middle
a great tool for finding HK

00:15:53.566 --> 00:15:55.936 A:middle
hard-to-reproduce bugs in your

00:15:55.936 --> 00:15:56.486 A:middle
program.

00:15:56.736 --> 00:15:58.656 A:middle
And not only the Static Analyzer

00:15:58.656 --> 00:16:00.726 A:middle
finds the bug for you it also

00:15:58.656 --> 00:16:00.726 A:middle
finds the bug for you it also

00:16:00.726 --> 00:16:02.416 A:middle
displays the visualization in

00:16:02.496 --> 00:16:04.336 A:middle
Xcode of the paths which

00:16:04.386 --> 00:16:04.936 A:middle
[inaudible] the bug.

00:16:05.636 --> 00:16:07.546 A:middle
So here nil is added to

00:16:07.636 --> 00:16:09.566 A:middle
NSMutableArray which can cause a

00:16:09.566 --> 00:16:10.596 A:middle
crash later on.

00:16:10.636 --> 00:16:12.626 A:middle
And Static Analyzer shows you

00:16:12.626 --> 00:16:14.566 A:middle
the path for this crash so you

00:16:14.566 --> 00:16:16.026 A:middle
can see how the application can

00:16:16.026 --> 00:16:16.516 A:middle
be fixed.

00:16:17.686 --> 00:16:19.536 A:middle
And I would like to tell you

00:16:19.536 --> 00:16:20.916 A:middle
about three of the new

00:16:20.916 --> 00:16:22.166 A:middle
improvements we have done.

00:16:22.816 --> 00:16:25.346 A:middle
Firstly, we have a new check for

00:16:25.346 --> 00:16:27.266 A:middle
detecting Grand Central Dispatch

00:16:27.266 --> 00:16:29.146 A:middle
anti-patterning, which can cause

00:16:29.146 --> 00:16:30.876 A:middle
poor performance and hangs of

00:16:30.876 --> 00:16:31.666 A:middle
your replication.

00:16:32.346 --> 00:16:34.286 A:middle
Secondly, we have a new check

00:16:34.286 --> 00:16:36.066 A:middle
for detecting a misuse of

00:16:36.066 --> 00:16:38.146 A:middle
autoreleasing variables inside

00:16:38.146 --> 00:16:39.866 A:middle
autorelease pools which can

00:16:39.866 --> 00:16:41.136 A:middle
cause crashes with [inaudible].

00:16:41.136 --> 00:16:44.876 A:middle
And finally, we have improved

00:16:44.916 --> 00:16:46.556 A:middle
performance and visualizations

00:16:46.556 --> 00:16:47.916 A:middle
for the Clang Static Analyzer.

00:16:49.116 --> 00:16:51.486 A:middle
So let's start with a new check

00:16:51.486 --> 00:16:52.836 A:middle
for detecting Grand Central

00:16:52.836 --> 00:16:54.086 A:middle
Dispatch anti-pattern.

00:16:54.986 --> 00:16:57.226 A:middle
So many APIs on our platforms

00:16:57.656 --> 00:17:00.076 A:middle
are asynchronous, but sometimes

00:16:57.656 --> 00:17:00.076 A:middle
are asynchronous, but sometimes

00:17:00.076 --> 00:17:01.606 A:middle
developers would like to use

00:17:01.606 --> 00:17:03.296 A:middle
them in a synchronous way for

00:17:03.296 --> 00:17:04.476 A:middle
one reason or another.

00:17:05.526 --> 00:17:06.796 A:middle
Maybe because their code is

00:17:06.796 --> 00:17:07.796 A:middle
already running on the

00:17:07.796 --> 00:17:09.915 A:middle
background queue or maybe

00:17:09.915 --> 00:17:11.036 A:middle
because the function cannot

00:17:11.036 --> 00:17:12.415 A:middle
proceed at all until the

00:17:12.415 --> 00:17:13.915 A:middle
required value is available.

00:17:14.306 --> 00:17:16.415 A:middle
And the tempting solution there

00:17:16.415 --> 00:17:18.606 A:middle
is to use a semaphore to ensure

00:17:18.606 --> 00:17:19.486 A:middle
synchronization.

00:17:20.536 --> 00:17:21.965 A:middle
So that's what's happening in

00:17:21.965 --> 00:17:24.685 A:middle
this example, so here there is

00:17:24.906 --> 00:17:27.336 A:middle
an SXPC object self.connection

00:17:27.826 --> 00:17:29.186 A:middle
and we use its property

00:17:29.186 --> 00:17:32.046 A:middle
remoteObjectProxy to call, to

00:17:32.046 --> 00:17:33.846 A:middle
get the current task name

00:17:33.996 --> 00:17:35.866 A:middle
asynchronously from a different

00:17:35.866 --> 00:17:36.606 A:middle
process.

00:17:37.566 --> 00:17:39.506 A:middle
And then we wait on a semaphore

00:17:40.076 --> 00:17:41.666 A:middle
which is signal to inside the

00:17:41.926 --> 00:17:42.546 A:middle
callback.

00:17:43.286 --> 00:17:45.126 A:middle
And that helps to ensure that by

00:17:45.126 --> 00:17:46.696 A:middle
the time the function returns

00:17:47.376 --> 00:17:48.996 A:middle
the task name is available.

00:17:49.256 --> 00:17:51.966 A:middle
So this approach works but has

00:17:51.966 --> 00:17:53.566 A:middle
known performance implications.

00:17:54.466 --> 00:17:56.536 A:middle
So the main problem here is when

00:17:56.536 --> 00:17:58.956 A:middle
you wait using a semaphore on

00:17:58.956 --> 00:18:01.016 A:middle
some asynchronous process you

00:17:58.956 --> 00:18:01.016 A:middle
some asynchronous process you

00:18:01.016 --> 00:18:02.736 A:middle
might be waiting on a queue with

00:18:02.736 --> 00:18:04.776 A:middle
a much lower priority than yours

00:18:05.156 --> 00:18:07.256 A:middle
costing prior inversion which

00:18:07.756 --> 00:18:08.516 A:middle
[inaudible] performance and

00:18:08.516 --> 00:18:09.176 A:middle
cause hangs.

00:18:09.816 --> 00:18:12.876 A:middle
And moreover using a semaphore

00:18:12.876 --> 00:18:14.956 A:middle
in such a way also spawns

00:18:14.956 --> 00:18:16.426 A:middle
useless threads which further

00:18:16.426 --> 00:18:17.616 A:middle
degrades the performance.

00:18:18.426 --> 00:18:20.706 A:middle
And to help you address this

00:18:20.706 --> 00:18:23.016 A:middle
issue now Static Analyzer warns

00:18:23.386 --> 00:18:27.966 A:middle
on such cases helping to see

00:18:27.966 --> 00:18:29.096 A:middle
where the issue occurs.

00:18:29.096 --> 00:18:32.846 A:middle
Now let's see how the issue can

00:18:32.846 --> 00:18:33.446 A:middle
be fixed.

00:18:34.066 --> 00:18:35.776 A:middle
In the best-case scenario there

00:18:35.836 --> 00:18:38.406 A:middle
is a synchronous API available

00:18:38.446 --> 00:18:39.646 A:middle
which can be used in stat.

00:18:40.286 --> 00:18:42.966 A:middle
So for an SXPC connection there

00:18:42.966 --> 00:18:44.146 A:middle
is an [inaudible] API

00:18:44.576 --> 00:18:47.116 A:middle
synchronousRemoteObjectProxy

00:18:47.736 --> 00:18:49.526 A:middle
which when used in start

00:18:49.526 --> 00:18:50.536 A:middle
eliminates the need for the

00:18:50.536 --> 00:18:53.016 A:middle
semaphore and runs much foster.

00:18:55.196 --> 00:18:57.306 A:middle
Alternatively, if no such

00:18:57.306 --> 00:18:59.976 A:middle
synchronous API is available you

00:18:59.976 --> 00:19:00.836 A:middle
could restructure your

00:18:59.976 --> 00:19:00.836 A:middle
could restructure your

00:19:00.836 --> 00:19:02.586 A:middle
application to use continuations

00:19:02.586 --> 00:19:04.176 A:middle
in stat and just calls the

00:19:04.176 --> 00:19:05.586 A:middle
required function inside the

00:19:05.586 --> 00:19:06.176 A:middle
callback.

00:19:08.876 --> 00:19:10.706 A:middle
So this check is not enabled by

00:19:10.706 --> 00:19:12.516 A:middle
default but we encourage you to

00:19:12.516 --> 00:19:14.576 A:middle
enable it in build settings in

00:19:14.576 --> 00:19:16.276 A:middle
order to make sure no such

00:19:16.316 --> 00:19:17.256 A:middle
problem securing your

00:19:17.256 --> 00:19:18.956 A:middle
application and it runs as fast

00:19:18.956 --> 00:19:19.526 A:middle
as possible.

00:19:19.526 --> 00:19:23.076 A:middle
Now let's talk about the second

00:19:23.076 --> 00:19:24.746 A:middle
check for detecting the

00:19:24.746 --> 00:19:25.976 A:middle
autoreleasing variables

00:19:25.976 --> 00:19:27.646 A:middle
outliving the lifetime of the

00:19:27.646 --> 00:19:28.566 A:middle
autorelease pool.

00:19:29.166 --> 00:19:32.336 A:middle
So the autoreleasing qualifier

00:19:32.626 --> 00:19:34.526 A:middle
specifies that the value has to

00:19:34.526 --> 00:19:36.356 A:middle
be released once the control

00:19:36.356 --> 00:19:37.886 A:middle
exits the autorelease pool.

00:19:38.606 --> 00:19:41.156 A:middle
So here we have an example where

00:19:41.216 --> 00:19:42.786 A:middle
we create an error variable

00:19:43.076 --> 00:19:44.956 A:middle
inside the autorelease pool and

00:19:44.956 --> 00:19:46.326 A:middle
once the control is outside of

00:19:46.326 --> 00:19:47.596 A:middle
the autorelease pool the

00:19:47.596 --> 00:19:49.336 A:middle
variable is released and

00:19:49.336 --> 00:19:50.456 A:middle
subsequently destroyed.

00:19:51.176 --> 00:19:53.516 A:middle
And autoreleasing pools are a

00:19:53.516 --> 00:19:55.556 A:middle
useful feature of Objective-C to

00:19:55.556 --> 00:19:56.976 A:middle
help contain the big memory

00:19:56.976 --> 00:19:58.586 A:middle
footprint of your applications

00:19:58.586 --> 00:19:59.986 A:middle
and to ensure that thumbprints

00:19:59.986 --> 00:20:00.946 A:middle
are destroyed where necessary.

00:19:59.986 --> 00:20:00.946 A:middle
are destroyed where necessary.

00:20:02.756 --> 00:20:05.576 A:middle
However, it can cause unexpected

00:20:05.576 --> 00:20:08.276 A:middle
crashes and they're even more

00:20:08.276 --> 00:20:10.096 A:middle
unexpected because you don't

00:20:10.096 --> 00:20:11.546 A:middle
even need to write the word

00:20:11.626 --> 00:20:12.756 A:middle
autoreleasing in your

00:20:12.756 --> 00:20:14.036 A:middle
application to have those

00:20:14.036 --> 00:20:14.576 A:middle
crashes.

00:20:15.126 --> 00:20:16.896 A:middle
So for instance, there is a

00:20:16.896 --> 00:20:19.336 A:middle
validation function here and it

00:20:19.336 --> 00:20:21.586 A:middle
takes in out parameter NSError.

00:20:22.336 --> 00:20:24.366 A:middle
And out parameters are actually

00:20:24.366 --> 00:20:25.996 A:middle
autoreleasing in Objective-C

00:20:25.996 --> 00:20:27.436 A:middle
under ARC by default.

00:20:28.126 --> 00:20:30.456 A:middle
So when we write to this out

00:20:30.506 --> 00:20:32.326 A:middle
parameter inside the autorelease

00:20:32.326 --> 00:20:36.956 A:middle
pool and then the function exits

00:20:37.206 --> 00:20:38.706 A:middle
the error value is actually

00:20:38.706 --> 00:20:39.196 A:middle
released.

00:20:39.926 --> 00:20:41.556 A:middle
And then if the caller tries to

00:20:41.556 --> 00:20:42.966 A:middle
read the value of this error

00:20:42.966 --> 00:20:45.086 A:middle
variable they might crash with

00:20:45.086 --> 00:20:45.976 A:middle
use-after-free.

00:20:51.046 --> 00:20:53.046 A:middle
That pattern is already hard to

00:20:53.046 --> 00:20:54.936 A:middle
detect, but it actually gets

00:20:54.996 --> 00:20:56.896 A:middle
even worse when you don't even

00:20:56.896 --> 00:20:57.986 A:middle
control the part of the

00:20:57.986 --> 00:20:59.106 A:middle
application which has the

00:20:59.106 --> 00:21:00.016 A:middle
autorelease pool.

00:20:59.106 --> 00:21:00.016 A:middle
autorelease pool.

00:21:00.776 --> 00:21:02.416 A:middle
So here is a similar function

00:21:02.666 --> 00:21:04.676 A:middle
which [inaudible] and out

00:21:04.676 --> 00:21:06.696 A:middle
parameter error and then it

00:21:06.696 --> 00:21:07.176 A:middle
calls an

00:21:07.176 --> 00:21:10.236 A:middle
enumerateObjectsUsingBlock which

00:21:10.236 --> 00:21:12.476 A:middle
is a popular foundation API

00:21:12.616 --> 00:21:14.126 A:middle
which calls a block on every

00:21:14.126 --> 00:21:15.676 A:middle
element of a collection.

00:21:16.486 --> 00:21:17.046 A:middle
However

00:21:17.316 --> 00:21:19.246 A:middle
enumerateObjectsUsingBlock

00:21:19.476 --> 00:21:21.156 A:middle
actually calls [inaudible] given

00:21:21.156 --> 00:21:22.576 A:middle
block inside the autorelease

00:21:22.576 --> 00:21:23.486 A:middle
pool of return.

00:21:24.096 --> 00:21:25.906 A:middle
So a similar problem occurs here

00:21:26.386 --> 00:21:28.066 A:middle
that when we create an error

00:21:28.066 --> 00:21:30.726 A:middle
value inside the block and write

00:21:30.726 --> 00:21:32.916 A:middle
it to the out parameter it will

00:21:32.916 --> 00:21:34.666 A:middle
actually get released by the

00:21:34.666 --> 00:21:36.386 A:middle
time the control reaches out of

00:21:36.436 --> 00:21:38.126 A:middle
enumerateObjectsUsingBlock.

00:21:39.356 --> 00:21:41.106 A:middle
And then when the caller tries

00:21:41.816 --> 00:21:44.126 A:middle
to read it they also can crash

00:21:44.126 --> 00:21:45.186 A:middle
with the use-after-free.

00:21:45.666 --> 00:21:49.416 A:middle
And previously we have

00:21:49.416 --> 00:21:51.056 A:middle
introduced the compiler warning

00:21:51.456 --> 00:21:53.436 A:middle
which warns when an implicitly

00:21:53.436 --> 00:21:55.376 A:middle
autoreleasing out parameter is

00:21:55.376 --> 00:21:56.466 A:middle
captured in the block.

00:21:57.046 --> 00:21:58.206 A:middle
And the compiler warning

00:21:58.206 --> 00:21:59.436 A:middle
suggested to make such

00:21:59.476 --> 00:22:00.636 A:middle
parameters explicitly

00:21:59.476 --> 00:22:00.636 A:middle
parameters explicitly

00:22:00.636 --> 00:22:01.346 A:middle
autoreleasing.

00:22:02.156 --> 00:22:03.486 A:middle
But we have noticed that such

00:22:03.486 --> 00:22:06.486 A:middle
issue kept occurring, so in

00:22:06.486 --> 00:22:08.026 A:middle
Xcode 10 we introduced a more

00:22:08.026 --> 00:22:10.356 A:middle
powerful Clang Static Analyzer

00:22:10.356 --> 00:22:13.906 A:middle
warning which knows which APIs

00:22:14.956 --> 00:22:16.866 A:middle
call the provided block inside

00:22:16.866 --> 00:22:18.846 A:middle
the autorelease pool and warns

00:22:18.846 --> 00:22:19.966 A:middle
about such cases.

00:22:24.066 --> 00:22:24.956 A:middle
So now let's see how this issue

00:22:24.956 --> 00:22:25.676 A:middle
can be fixed.

00:22:26.286 --> 00:22:28.316 A:middle
And the simplest fix here is

00:22:28.316 --> 00:22:29.796 A:middle
just to introduce a strong local

00:22:29.796 --> 00:22:32.376 A:middle
variable and then when you're

00:22:32.376 --> 00:22:34.836 A:middle
inside the block write a value

00:22:34.836 --> 00:22:36.296 A:middle
into the strong variable in

00:22:36.296 --> 00:22:36.806 A:middle
stat.

00:22:37.646 --> 00:22:39.456 A:middle
And then only copy to the out

00:22:39.516 --> 00:22:41.646 A:middle
parameter once the control is

00:22:41.646 --> 00:22:43.286 A:middle
outside of the block and you

00:22:43.286 --> 00:22:44.666 A:middle
know it's not inside the

00:22:44.666 --> 00:22:46.216 A:middle
autorelease pool and it's safe

00:22:46.276 --> 00:22:47.696 A:middle
to write into the autoreleasing

00:22:47.696 --> 00:22:47.976 A:middle
variable.

00:22:53.236 --> 00:22:55.206 A:middle
And finally, we also have

00:22:55.206 --> 00:22:56.306 A:middle
improved performance and

00:22:56.306 --> 00:22:57.706 A:middle
visualizations of the Clang

00:22:57.706 --> 00:22:58.566 A:middle
Static Analyzer.

00:22:59.676 --> 00:23:02.736 A:middle
So in Xcode 10 we have improved

00:22:59.676 --> 00:23:02.736 A:middle
So in Xcode 10 we have improved

00:23:02.736 --> 00:23:03.966 A:middle
the analyzer to explore your

00:23:03.966 --> 00:23:05.536 A:middle
program in a more efficient way

00:23:05.766 --> 00:23:08.386 A:middle
so now it finds up to 15% more

00:23:09.096 --> 00:23:10.666 A:middle
bugs during the same analysis

00:23:10.666 --> 00:23:11.006 A:middle
time.

00:23:11.896 --> 00:23:14.226 A:middle
And not only it finds more bugs

00:23:14.786 --> 00:23:16.556 A:middle
the bug report it now generates

00:23:17.006 --> 00:23:19.116 A:middle
tend to be smaller and more

00:23:19.116 --> 00:23:19.906 A:middle
understandable.

00:23:20.116 --> 00:23:22.006 A:middle
And what I mean by that is

00:23:22.006 --> 00:23:25.026 A:middle
sometimes in Xcode 10 you would

00:23:25.026 --> 00:23:26.646 A:middle
get examples which have a lot of

00:23:26.646 --> 00:23:28.866 A:middle
steps and a lot of arrows and

00:23:28.866 --> 00:23:30.016 A:middle
which would be somewhat hard to

00:23:30.016 --> 00:23:30.686 A:middle
comprehend.

00:23:31.246 --> 00:23:33.976 A:middle
And in many of those examples in

00:23:33.976 --> 00:23:36.256 A:middle
your version of Xcode we give

00:23:36.256 --> 00:23:38.196 A:middle
you a much smaller error path

00:23:38.196 --> 00:23:40.116 A:middle
which is much easier to see and

00:23:40.116 --> 00:23:41.146 A:middle
you can see the issue much

00:23:41.146 --> 00:23:41.656 A:middle
faster.

00:23:43.116 --> 00:23:45.346 A:middle
So in order to use Static

00:23:45.346 --> 00:23:47.566 A:middle
Analyzer on your projects you

00:23:47.566 --> 00:23:51.256 A:middle
can use Product, Analyze or you

00:23:51.256 --> 00:23:53.396 A:middle
can even enable Analyze During

00:23:53.396 --> 00:23:55.456 A:middle
Build to make sure no analyzer

00:23:55.456 --> 00:23:56.626 A:middle
issue gets unnoticed.

00:23:56.666 --> 00:23:58.676 A:middle
So I encourage you to use the

00:23:58.676 --> 00:24:00.336 A:middle
Static Analyzer, it's a great

00:23:58.676 --> 00:24:00.336 A:middle
Static Analyzer, it's a great

00:24:00.336 --> 00:24:01.726 A:middle
tool to find your bugs before

00:24:01.726 --> 00:24:02.366 A:middle
users do.

00:24:02.706 --> 00:24:04.996 A:middle
And now my colleague Ahmed will

00:24:04.996 --> 00:24:06.376 A:middle
talk about low-level

00:24:06.376 --> 00:24:07.026 A:middle
improvements.

00:24:07.936 --> 00:24:10.916 A:middle
&gt;&gt; Thank you George.

00:24:11.016 --> 00:24:13.000 A:middle
[ Applause ]

00:24:15.046 --> 00:24:16.176 A:middle
So as Alex and George told you,

00:24:16.176 --> 00:24:18.486 A:middle
we have lots of warnings and

00:24:18.776 --> 00:24:20.326 A:middle
Static Analyzer checks in the

00:24:20.326 --> 00:24:22.496 A:middle
compiler, but you also have the

00:24:22.496 --> 00:24:24.186 A:middle
sanitizer and all of these tools

00:24:24.186 --> 00:24:25.476 A:middle
help you find lots of bugs,

00:24:25.576 --> 00:24:26.586 A:middle
including security bugs.

00:24:27.146 --> 00:24:29.606 A:middle
So I'm sure you all have lots of

00:24:29.606 --> 00:24:30.866 A:middle
tests and use all these great

00:24:30.866 --> 00:24:33.766 A:middle
tools to find all the bugs in

00:24:33.766 --> 00:24:34.366 A:middle
these tests.

00:24:35.066 --> 00:24:36.126 A:middle
But for some of the most

00:24:36.126 --> 00:24:38.496 A:middle
egregious security bugs we want

00:24:38.496 --> 00:24:39.546 A:middle
to make sure that they don't

00:24:39.546 --> 00:24:41.566 A:middle
happen in release builds if

00:24:41.566 --> 00:24:43.126 A:middle
somehow they snuck past all the

00:24:43.126 --> 00:24:43.516 A:middle
testing.

00:24:44.116 --> 00:24:48.246 A:middle
So for those we have mitigations

00:24:48.246 --> 00:24:49.516 A:middle
in the code generator that are

00:24:49.516 --> 00:24:50.856 A:middle
always emitted even in release

00:24:50.886 --> 00:24:51.216 A:middle
builds.

00:24:52.146 --> 00:24:54.326 A:middle
So I'm Ahmed, I work on the code

00:24:54.326 --> 00:24:55.616 A:middle
generator and today I'm going to

00:24:55.616 --> 00:24:57.486 A:middle
tell you about a new mitigation

00:24:57.486 --> 00:24:58.316 A:middle
in Xcode 10.

00:24:58.906 --> 00:25:01.226 A:middle
So to see how that works we need

00:24:58.906 --> 00:25:01.226 A:middle
So to see how that works we need

00:25:01.226 --> 00:25:02.536 A:middle
to understand how the stack

00:25:02.536 --> 00:25:02.936 A:middle
works.

00:25:03.546 --> 00:25:06.896 A:middle
So here I have a simple C

00:25:06.896 --> 00:25:09.706 A:middle
function called dlog and I use

00:25:09.706 --> 00:25:11.196 A:middle
it to print a string that I'm

00:25:11.196 --> 00:25:13.666 A:middle
passed into a dlog bug.

00:25:14.496 --> 00:25:16.306 A:middle
So in this case it's called with

00:25:16.306 --> 00:25:17.286 A:middle
a string hello.

00:25:17.376 --> 00:25:20.016 A:middle
And the way this works is we

00:25:20.016 --> 00:25:22.646 A:middle
need to allocate some memory to

00:25:22.646 --> 00:25:23.976 A:middle
keep track of this call.

00:25:25.816 --> 00:25:27.766 A:middle
So we allocate that into a

00:25:27.766 --> 00:25:28.936 A:middle
region called the stack.

00:25:29.776 --> 00:25:31.946 A:middle
So the stack grows down towards

00:25:31.946 --> 00:25:33.146 A:middle
the null pointer or address

00:25:33.146 --> 00:25:33.436 A:middle
zero.

00:25:34.066 --> 00:25:37.746 A:middle
So when we do our dlog hello

00:25:37.746 --> 00:25:39.586 A:middle
call this allocates what's

00:25:39.586 --> 00:25:41.566 A:middle
called the stack frame and the

00:25:41.566 --> 00:25:43.166 A:middle
stack frame contains things like

00:25:43.166 --> 00:25:44.626 A:middle
the return address so that we

00:25:44.626 --> 00:25:46.486 A:middle
know to go back to main.

00:25:47.306 --> 00:25:48.746 A:middle
But it also contains other

00:25:48.746 --> 00:25:50.286 A:middle
things like parameters and local

00:25:50.286 --> 00:25:50.876 A:middle
variables.

00:25:51.746 --> 00:25:53.686 A:middle
So for instance if I have a log

00:25:53.686 --> 00:25:55.076 A:middle
file [inaudible] local variable

00:25:56.106 --> 00:25:57.606 A:middle
that lives in the stack frame.

00:25:58.206 --> 00:26:01.846 A:middle
So now if I try to make another

00:25:58.206 --> 00:26:01.846 A:middle
So now if I try to make another

00:26:01.846 --> 00:26:03.796 A:middle
function call to this dlog file

00:26:03.796 --> 00:26:06.636 A:middle
function that in turn will

00:26:06.636 --> 00:26:07.846 A:middle
allocate its own stack frame.

00:26:08.226 --> 00:26:11.226 A:middle
And when it's done it's going to

00:26:11.226 --> 00:26:12.856 A:middle
deallocate the stack frame and

00:26:12.856 --> 00:26:14.056 A:middle
return back to the caller.

00:26:14.666 --> 00:26:18.766 A:middle
So now let's look at this stack

00:26:18.766 --> 00:26:20.006 A:middle
frame in more details.

00:26:21.256 --> 00:26:23.046 A:middle
So let's say I change my

00:26:23.046 --> 00:26:25.436 A:middle
function to have a local buffer,

00:26:25.436 --> 00:26:27.336 A:middle
so it's a 4 bytes character

00:26:27.916 --> 00:26:28.006 A:middle
array.

00:26:29.556 --> 00:26:31.136 A:middle
And I'm trying to prepare my

00:26:31.136 --> 00:26:34.166 A:middle
debug string by first doing a

00:26:34.166 --> 00:26:35.466 A:middle
strcpy of the string that I'm

00:26:35.466 --> 00:26:38.466 A:middle
passed into that buffer.

00:26:38.596 --> 00:26:40.696 A:middle
So this does the obvious copy by

00:26:40.916 --> 00:26:44.546 A:middle
[inaudible], so it does H-E-L-L.

00:26:44.546 --> 00:26:47.496 A:middle
But then there's a problem at

00:26:47.496 --> 00:26:48.866 A:middle
this point we already wrote 4

00:26:48.866 --> 00:26:50.786 A:middle
bytes and that we already

00:26:50.786 --> 00:26:52.766 A:middle
exhausted all 4 bytes available

00:26:52.766 --> 00:26:53.276 A:middle
in our buffer.

00:26:54.206 --> 00:26:56.066 A:middle
So if we keep going which is

00:26:56.066 --> 00:26:57.876 A:middle
what strcpy will do then we're

00:26:57.876 --> 00:26:59.276 A:middle
going to override the return

00:26:59.276 --> 00:27:01.536 A:middle
address and this is a big

00:26:59.276 --> 00:27:01.536 A:middle
address and this is a big

00:27:01.536 --> 00:27:02.386 A:middle
security problem.

00:27:02.956 --> 00:27:04.826 A:middle
So if an attacker controls the

00:27:04.826 --> 00:27:06.446 A:middle
string that I'm copying which is

00:27:06.716 --> 00:27:08.496 A:middle
not that hard, then it can

00:27:08.496 --> 00:27:09.776 A:middle
control the return address.

00:27:10.276 --> 00:27:11.496 A:middle
If it can control the return

00:27:11.496 --> 00:27:12.626 A:middle
address then they control

00:27:12.626 --> 00:27:13.806 A:middle
basically what the program does

00:27:13.806 --> 00:27:14.706 A:middle
next, so it's a big security

00:27:14.706 --> 00:27:14.976 A:middle
problem.

00:27:19.076 --> 00:27:21.446 A:middle
So if you had a test that caught

00:27:21.506 --> 00:27:23.586 A:middle
this and you ran the address

00:27:23.586 --> 00:27:26.376 A:middle
sanitizer, then you will have

00:27:26.446 --> 00:27:27.886 A:middle
had an easy way to fix this.

00:27:28.436 --> 00:27:29.266 A:middle
And really what I should have

00:27:29.266 --> 00:27:32.686 A:middle
done here is strncpy that knows

00:27:32.686 --> 00:27:34.546 A:middle
about the size or even better

00:27:34.546 --> 00:27:35.876 A:middle
use a higher-level API like

00:27:35.876 --> 00:27:36.886 A:middle
NSString or [inaudible] string.

00:27:37.406 --> 00:27:40.736 A:middle
But still sometimes these bugs

00:27:40.736 --> 00:27:42.236 A:middle
can survive into release builds

00:27:43.156 --> 00:27:46.566 A:middle
and we avoid these by using

00:27:46.566 --> 00:27:48.366 A:middle
what's called the Stack

00:27:49.496 --> 00:27:49.766 A:middle
Protector.

00:27:49.766 --> 00:27:51.086 A:middle
So the Stack Protector changes

00:27:51.086 --> 00:27:52.176 A:middle
the layout of the stack frame to

00:27:52.176 --> 00:27:54.716 A:middle
add a new field the canary so

00:27:55.416 --> 00:27:58.616 A:middle
that when we do our write we

00:27:58.616 --> 00:28:00.136 A:middle
have a little bit of code right

00:27:58.616 --> 00:28:00.136 A:middle
have a little bit of code right

00:28:00.136 --> 00:28:01.256 A:middle
before the return of the

00:28:01.256 --> 00:28:02.796 A:middle
function that checks whether the

00:28:02.796 --> 00:28:04.406 A:middle
canary is still valid.

00:28:05.916 --> 00:28:07.676 A:middle
So if we keep writing in strcpy

00:28:07.676 --> 00:28:08.826 A:middle
we're going to override the

00:28:08.826 --> 00:28:12.666 A:middle
canary first and then we're

00:28:12.666 --> 00:28:14.126 A:middle
going to check the canary first

00:28:14.126 --> 00:28:16.246 A:middle
before returning and that's

00:28:16.246 --> 00:28:16.866 A:middle
going to abort.

00:28:17.686 --> 00:28:19.076 A:middle
So we turned ad potentially

00:28:19.076 --> 00:28:20.276 A:middle
exploitable security

00:28:20.426 --> 00:28:22.516 A:middle
vulnerability into a reliable

00:28:22.516 --> 00:28:24.366 A:middle
crash and that's not good for an

00:28:24.366 --> 00:28:24.766 A:middle
attacker.

00:28:25.386 --> 00:28:27.506 A:middle
So this is what's called the

00:28:27.506 --> 00:28:27.966 A:middle
Stack Protector.

00:28:33.416 --> 00:28:34.896 A:middle
It defects certain kinds of

00:28:34.896 --> 00:28:36.306 A:middle
stack buffer overflows, which is

00:28:36.306 --> 00:28:37.346 A:middle
the attack that we just saw.

00:28:37.406 --> 00:28:39.466 A:middle
And it's already enabled by

00:28:39.466 --> 00:28:41.096 A:middle
default in many versions of

00:28:41.096 --> 00:28:41.416 A:middle
Xcode.

00:28:41.976 --> 00:28:45.856 A:middle
So next I'm going to talk about

00:28:45.856 --> 00:28:47.596 A:middle
a trickier case where we

00:28:47.676 --> 00:28:48.866 A:middle
introduced a new mitigation.

00:28:48.986 --> 00:28:52.346 A:middle
So let's say I took my function,

00:28:52.986 --> 00:28:55.346 A:middle
again my dlog function and I

00:28:55.346 --> 00:28:56.616 A:middle
changed the buffer so that now

00:28:56.616 --> 00:28:57.776 A:middle
it's a variable length array.

00:28:58.856 --> 00:29:00.426 A:middle
And the length comes from a

00:28:58.856 --> 00:29:00.426 A:middle
And the length comes from a

00:29:00.426 --> 00:29:02.186 A:middle
parameter called len.

00:29:03.756 --> 00:29:07.186 A:middle
So let's say len in a specific

00:29:07.186 --> 00:29:09.046 A:middle
call is something big like

00:29:09.046 --> 00:29:12.006 A:middle
15,000, so now the stack frame

00:29:12.006 --> 00:29:13.826 A:middle
has to be at least 15,000 bytes

00:29:13.826 --> 00:29:14.056 A:middle
long.

00:29:16.696 --> 00:29:18.816 A:middle
But memory is not all

00:29:18.816 --> 00:29:20.636 A:middle
immediately available, so memory

00:29:20.636 --> 00:29:23.216 A:middle
is split into pages and the

00:29:23.216 --> 00:29:25.696 A:middle
stack grows only when necessary.

00:29:26.656 --> 00:29:28.176 A:middle
So for instance, when we try to

00:29:28.176 --> 00:29:30.866 A:middle
access by 10,000 of the buffer

00:29:30.926 --> 00:29:32.136 A:middle
that's in the next page of the

00:29:32.136 --> 00:29:35.066 A:middle
stack that's not yet available

00:29:35.566 --> 00:29:36.716 A:middle
so it's going to do a page fault

00:29:36.716 --> 00:29:37.966 A:middle
in the CPU that talks to the

00:29:37.966 --> 00:29:39.556 A:middle
opening system, the operating

00:29:39.556 --> 00:29:40.586 A:middle
system sees that we have the

00:29:40.586 --> 00:29:42.306 A:middle
right to grow the stack, and it

00:29:42.306 --> 00:29:43.706 A:middle
grows it and we can continue

00:29:43.706 --> 00:29:44.016 A:middle
writing.

00:29:44.936 --> 00:29:46.926 A:middle
So this all happens under the

00:29:48.816 --> 00:29:48.926 A:middle
hood.

00:29:49.146 --> 00:29:51.736 A:middle
But say an attacker controls the

00:29:51.736 --> 00:29:54.296 A:middle
length and it makes it huge, big

00:29:54.296 --> 00:29:56.256 A:middle
enough that it spans many pages.

00:29:57.556 --> 00:29:58.876 A:middle
So now there's a new problem,

00:29:59.896 --> 00:30:02.626 A:middle
the memory is not infinite so if

00:29:59.896 --> 00:30:02.626 A:middle
the memory is not infinite so if

00:30:02.626 --> 00:30:04.176 A:middle
we keep allocating in this stack

00:30:04.366 --> 00:30:05.906 A:middle
eventually we'll hit another

00:30:05.906 --> 00:30:07.026 A:middle
region of memory that's already

00:30:07.026 --> 00:30:10.646 A:middle
allocated and usually that's the

00:30:10.646 --> 00:30:10.736 A:middle
heap.

00:30:10.736 --> 00:30:12.116 A:middle
And when we do that then we're

00:30:12.116 --> 00:30:13.226 A:middle
going to clash with the heap,

00:30:13.806 --> 00:30:15.256 A:middle
with whatever is already used in

00:30:15.256 --> 00:30:16.316 A:middle
there, so that's usually things

00:30:16.316 --> 00:30:17.776 A:middle
like malloc and new.

00:30:20.276 --> 00:30:22.016 A:middle
So if we try to see what would

00:30:22.016 --> 00:30:23.816 A:middle
happen with our strcpy example

00:30:24.616 --> 00:30:26.826 A:middle
then we will try to write the

00:30:26.826 --> 00:30:27.696 A:middle
bytes one by one.

00:30:28.406 --> 00:30:32.766 A:middle
So we do H-E-L, etcetera.

00:30:32.816 --> 00:30:34.616 A:middle
And from the standpoint of the

00:30:34.616 --> 00:30:37.026 A:middle
CPU, the code that's generated

00:30:37.026 --> 00:30:38.156 A:middle
and the operating system this is

00:30:38.156 --> 00:30:39.856 A:middle
all fine because we're just

00:30:39.856 --> 00:30:41.586 A:middle
writing into a page that's

00:30:41.586 --> 00:30:43.526 A:middle
already available and allocated.

00:30:44.556 --> 00:30:47.006 A:middle
But it really isn't because this

00:30:47.006 --> 00:30:48.216 A:middle
is part of the heap, this is not

00:30:48.216 --> 00:30:50.046 A:middle
part of our local stack

00:30:50.046 --> 00:30:50.796 A:middle
allocated array.

00:30:51.186 --> 00:30:52.606 A:middle
So when we do our writes we're

00:30:52.606 --> 00:30:53.576 A:middle
actually overriding some

00:30:53.576 --> 00:30:55.586 A:middle
completely unrelated piece of

00:30:55.586 --> 00:30:57.416 A:middle
information like I don't know a

00:30:57.416 --> 00:30:58.496 A:middle
Boolean that checks whether we

00:30:58.496 --> 00:30:59.356 A:middle
should check a password.

00:31:00.126 --> 00:31:01.496 A:middle
So this is another important

00:31:01.496 --> 00:31:01.926 A:middle
security flaw.

00:31:07.046 --> 00:31:08.346 A:middle
So this is something that we

00:31:08.346 --> 00:31:11.026 A:middle
mitigated with a new feature and

00:31:11.026 --> 00:31:13.056 A:middle
the future works by emitting

00:31:13.056 --> 00:31:15.196 A:middle
some new codes at the entry of

00:31:15.196 --> 00:31:17.926 A:middle
the function that checks whether

00:31:17.926 --> 00:31:20.056 A:middle
it's okay to have the stack

00:31:20.056 --> 00:31:20.286 A:middle
frame.

00:31:21.446 --> 00:31:22.806 A:middle
So it asks the operating system

00:31:22.806 --> 00:31:23.976 A:middle
above the maximum size of the

00:31:23.976 --> 00:31:26.146 A:middle
stack and if you try to make an

00:31:26.146 --> 00:31:27.256 A:middle
allocation that's bigger than

00:31:27.256 --> 00:31:29.456 A:middle
that then it actually aborts.

00:31:29.836 --> 00:31:33.106 A:middle
And again, this turns a

00:31:33.106 --> 00:31:34.726 A:middle
potentially exploitable security

00:31:34.726 --> 00:31:37.586 A:middle
bug into a reliable crash and

00:31:37.586 --> 00:31:41.176 A:middle
that's no good for an attacker.

00:31:41.176 --> 00:31:43.076 A:middle
So this is Stack Checking, it

00:31:43.076 --> 00:31:44.116 A:middle
detects something that you might

00:31:44.116 --> 00:31:46.206 A:middle
have heard of called Stack Clash

00:31:46.806 --> 00:31:48.226 A:middle
and it's enabled by default in

00:31:48.226 --> 00:31:48.806 A:middle
Xcode 10.

00:31:53.056 --> 00:31:55.246 A:middle
So next I want to talk about a

00:31:55.246 --> 00:31:56.836 A:middle
new set of features we added in

00:31:56.836 --> 00:31:58.906 A:middle
Xcode 10 and that's support for

00:31:58.906 --> 00:32:00.796 A:middle
new extension, sect extensions.

00:31:58.906 --> 00:32:00.796 A:middle
new extension, sect extensions.

00:32:01.646 --> 00:32:04.386 A:middle
So as you all know we have lots

00:32:04.386 --> 00:32:07.046 A:middle
of great Apple devices and one

00:32:07.046 --> 00:32:08.536 A:middle
of the great things about Xcode

00:32:08.536 --> 00:32:10.326 A:middle
is that with just a few build

00:32:10.326 --> 00:32:11.856 A:middle
settings you can target your

00:32:11.856 --> 00:32:13.596 A:middle
code for each of these devices.

00:32:13.966 --> 00:32:17.356 A:middle
And so under the hood in macOS,

00:32:17.356 --> 00:32:20.456 A:middle
iOS, watchOS, etcetera we tweak

00:32:20.826 --> 00:32:22.966 A:middle
every OS so that it uses

00:32:22.966 --> 00:32:24.766 A:middle
everything that's available on a

00:32:24.766 --> 00:32:25.986 A:middle
specific piece of hardware.

00:32:26.476 --> 00:32:27.516 A:middle
So it guarantees maximum

00:32:27.516 --> 00:32:29.146 A:middle
performance no matter where we

00:32:29.146 --> 00:32:29.436 A:middle
run.

00:32:29.796 --> 00:32:32.856 A:middle
And so if you an app with

00:32:33.206 --> 00:32:34.736 A:middle
extremely high-performance

00:32:34.736 --> 00:32:35.966 A:middle
requirements that's something

00:32:35.966 --> 00:32:37.156 A:middle
that you might want to do as

00:32:37.156 --> 00:32:37.356 A:middle
well.

00:32:39.516 --> 00:32:41.146 A:middle
So we have three features to

00:32:41.146 --> 00:32:42.916 A:middle
talk about that are available in

00:32:42.916 --> 00:32:44.656 A:middle
the iMac Pro and the iPhone 8

00:32:44.696 --> 00:32:45.946 A:middle
Plus and X.

00:32:46.836 --> 00:32:49.046 A:middle
And let's start with the iMac

00:32:50.996 --> 00:32:51.106 A:middle
Pro.

00:32:51.316 --> 00:32:53.186 A:middle
So the iMac Pro has the Intel

00:32:53.186 --> 00:32:58.006 A:middle
Xeon CPU which has a set of new

00:32:58.006 --> 00:32:59.886 A:middle
features called AVX-512.

00:32:59.886 --> 00:33:03.536 A:middle
So AVX-512 is a set of new

00:32:59.886 --> 00:33:03.536 A:middle
So AVX-512 is a set of new

00:33:03.536 --> 00:33:05.326 A:middle
instructions with vector

00:33:05.326 --> 00:33:05.846 A:middle
registers.

00:33:08.476 --> 00:33:12.106 A:middle
And these provide benefits over

00:33:12.386 --> 00:33:16.466 A:middle
X86-64, so in X86-64 we can only

00:33:16.466 --> 00:33:18.546 A:middle
assume that we have 128-bit

00:33:18.546 --> 00:33:20.536 A:middle
vectors available, so that's

00:33:20.536 --> 00:33:21.976 A:middle
guaranteed on any Mac ever

00:33:22.036 --> 00:33:23.836 A:middle
that's Intel powered.

00:33:25.156 --> 00:33:26.886 A:middle
Now it happens that any new Mac

00:33:26.886 --> 00:33:28.946 A:middle
today has more than that, but

00:33:28.946 --> 00:33:30.366 A:middle
the iMac Pro is the first that

00:33:30.366 --> 00:33:32.836 A:middle
has 512-bit registers.

00:33:35.456 --> 00:33:37.246 A:middle
And with the Auto-Vectorizer

00:33:37.246 --> 00:33:39.136 A:middle
that's enabled in the Xcode

00:33:39.136 --> 00:33:41.826 A:middle
Clang this is great because it

00:33:41.826 --> 00:33:43.736 A:middle
means that we can have many more

00:33:43.736 --> 00:33:45.186 A:middle
elements in the vector.

00:33:46.136 --> 00:33:47.676 A:middle
So this can greatly improve

00:33:47.676 --> 00:33:48.246 A:middle
throughputs.

00:33:48.786 --> 00:33:52.346 A:middle
But there are other benefits

00:33:52.346 --> 00:33:55.826 A:middle
with AVX-512, so for instance we

00:33:55.916 --> 00:33:58.086 A:middle
not only have bigger vectors we

00:33:58.086 --> 00:33:59.326 A:middle
also have more of them.

00:33:59.916 --> 00:34:02.546 A:middle
So on X86-64 we only have 16 now

00:33:59.916 --> 00:34:02.546 A:middle
So on X86-64 we only have 16 now

00:34:02.546 --> 00:34:04.526 A:middle
we have 32, so this is a lot of

00:34:04.526 --> 00:34:07.196 A:middle
data to process.

00:34:07.326 --> 00:34:09.085 A:middle
And even if for some reason the

00:34:09.085 --> 00:34:10.735 A:middle
auto-vectorizer is not able to

00:34:11.176 --> 00:34:13.786 A:middle
make use of these vectors then

00:34:13.786 --> 00:34:15.806 A:middle
we still have ore skill

00:34:15.806 --> 00:34:17.235 A:middle
registers or even for code that

00:34:17.235 --> 00:34:18.696 A:middle
just does float or double.

00:34:19.556 --> 00:34:21.166 A:middle
There are lots of performance

00:34:21.166 --> 00:34:22.985 A:middle
benefits in AVX-512.

00:34:23.916 --> 00:34:25.636 A:middle
So let's look at how we can

00:34:26.246 --> 00:34:28.206 A:middle
exploit it in my compute

00:34:28.235 --> 00:34:29.525 A:middle
[inaudible] expensive function.

00:34:30.106 --> 00:34:32.886 A:middle
So the first thing I'm going to

00:34:32.886 --> 00:34:35.065 A:middle
do is to keep around my existing

00:34:35.065 --> 00:34:36.676 A:middle
function because that's going to

00:34:36.676 --> 00:34:38.646 A:middle
be the fallback that I have that

00:34:38.646 --> 00:34:39.896 A:middle
runs on all Macs.

00:34:40.326 --> 00:34:43.275 A:middle
Next, I can try to specialize my

00:34:43.275 --> 00:34:43.696 A:middle
function.

00:34:44.025 --> 00:34:45.815 A:middle
So one way to do that is using

00:34:45.815 --> 00:34:46.806 A:middle
the target attributes.

00:34:47.306 --> 00:34:50.826 A:middle
And that tells the compiler that

00:34:50.826 --> 00:34:52.666 A:middle
it's okay to assume that this

00:34:52.666 --> 00:34:54.516 A:middle
function has AVX-512, so it only

00:34:54.516 --> 00:34:57.206 A:middle
runs on an iMac Pro.

00:34:57.416 --> 00:34:58.926 A:middle
So if you use simd.h, for

00:34:58.926 --> 00:35:01.126 A:middle
instance the simd float4 128-bit

00:34:58.926 --> 00:35:01.126 A:middle
instance the simd float4 128-bit

00:35:01.126 --> 00:35:03.336 A:middle
vector type then now we might

00:35:03.336 --> 00:35:04.696 A:middle
have better performance than the

00:35:04.696 --> 00:35:06.466 A:middle
AVX-512 version using the same

00:35:06.466 --> 00:35:06.716 A:middle
code.

00:35:07.216 --> 00:35:10.906 A:middle
And if you use the even larger

00:35:10.906 --> 00:35:12.026 A:middle
vector types, so for instance

00:35:12.026 --> 00:35:14.336 A:middle
simd float16, then now you have

00:35:14.366 --> 00:35:15.606 A:middle
much better performance than the

00:35:15.606 --> 00:35:17.506 A:middle
AVX-512 version where the

00:35:17.506 --> 00:35:19.406 A:middle
512-bit vector is actually

00:35:19.996 --> 00:35:20.146 A:middle
native.

00:35:21.776 --> 00:35:23.146 A:middle
And if you go all the way down

00:35:23.146 --> 00:35:25.206 A:middle
to X86 intrinsics, then now you

00:35:25.206 --> 00:35:27.256 A:middle
can start using the new AVX-512

00:35:27.256 --> 00:35:29.636 A:middle
variance, as well as the M512

00:35:30.306 --> 00:35:30.436 A:middle
types.

00:35:32.536 --> 00:35:34.316 A:middle
So if you want to specialize

00:35:34.496 --> 00:35:35.836 A:middle
larger units of codes, so not

00:35:35.836 --> 00:35:37.166 A:middle
just individual functions but

00:35:37.836 --> 00:35:40.706 A:middle
files, targets, libraries, then

00:35:40.706 --> 00:35:42.936 A:middle
you can use the new AVX-512

00:35:42.936 --> 00:35:45.156 A:middle
value of the additional vector

00:35:45.156 --> 00:35:46.116 A:middle
extensions build setting.

00:35:46.666 --> 00:35:50.236 A:middle
So when you do that there are

00:35:50.236 --> 00:35:52.176 A:middle
some things to keep in mind and

00:35:52.176 --> 00:35:53.776 A:middle
if you're familiar with AVX-1

00:35:53.776 --> 00:35:56.246 A:middle
and AVX-2 these are very similar

00:35:56.386 --> 00:35:56.816 A:middle
issues.

00:35:58.516 --> 00:36:00.286 A:middle
So you can only pass large

00:35:58.516 --> 00:36:00.286 A:middle
So you can only pass large

00:36:00.286 --> 00:36:03.666 A:middle
vectors, so 256 bits and up from

00:36:03.666 --> 00:36:05.296 A:middle
and to AVX-512 functions.

00:36:05.626 --> 00:36:07.766 A:middle
So the ABI is different from the

00:36:07.766 --> 00:36:09.016 A:middle
generic and a specialized

00:36:09.016 --> 00:36:10.516 A:middle
variance, so you cannot pass

00:36:10.516 --> 00:36:13.966 A:middle
them between those.

00:36:14.166 --> 00:36:16.376 A:middle
Additionally, these vectors are

00:36:16.376 --> 00:36:18.236 A:middle
large and they're large enough

00:36:18.236 --> 00:36:19.856 A:middle
that their natural alignment is

00:36:20.106 --> 00:36:21.966 A:middle
too big for what's guaranteed by

00:36:21.966 --> 00:36:22.746 A:middle
things like malloc.

00:36:22.746 --> 00:36:24.216 A:middle
So you have to take that into

00:36:24.216 --> 00:36:25.596 A:middle
account when allocating these

00:36:26.526 --> 00:36:30.316 A:middle
anywhere other than the stack.

00:36:30.316 --> 00:36:31.876 A:middle
And so in general all of these

00:36:31.956 --> 00:36:33.406 A:middle
things are things that we are

00:36:33.406 --> 00:36:34.396 A:middle
already go through lots of

00:36:34.536 --> 00:36:36.056 A:middle
things in the opening system.

00:36:36.536 --> 00:36:37.936 A:middle
So for instance, if you can at

00:36:37.936 --> 00:36:40.056 A:middle
all use accelerate.framework and

00:36:40.056 --> 00:36:41.326 A:middle
it's much easier to do so

00:36:41.656 --> 00:36:42.976 A:middle
because we already specialized

00:36:42.976 --> 00:36:44.506 A:middle
all the functions for every

00:36:44.506 --> 00:36:45.696 A:middle
single microarchitecture.

00:36:46.346 --> 00:36:49.806 A:middle
So this is AVX-512.

00:36:50.406 --> 00:36:53.576 A:middle
Now we also have new features on

00:36:53.576 --> 00:36:56.936 A:middle
the iPhone 8, 8 Plus and X.

00:36:59.016 --> 00:37:01.716 A:middle
So one of the first feature is

00:36:59.016 --> 00:37:01.716 A:middle
So one of the first feature is

00:37:02.196 --> 00:37:05.476 A:middle
ARM v8.1 Atomics and that's

00:37:05.626 --> 00:37:07.066 A:middle
thanks to one of the great

00:37:07.066 --> 00:37:09.566 A:middle
things about the iPhone X and

00:37:09.706 --> 00:37:11.976 A:middle
that's the A11 Bionic chip.

00:37:16.426 --> 00:37:19.786 A:middle
So the A11 Bionic chip has one

00:37:20.176 --> 00:37:22.426 A:middle
great new feature compared to

00:37:22.466 --> 00:37:24.616 A:middle
the A10 which is its support for

00:37:24.956 --> 00:37:27.636 A:middle
six CPUs, six cores running all

00:37:27.636 --> 00:37:29.326 A:middle
at the same time and that's a

00:37:29.326 --> 00:37:30.786 A:middle
first in iOS.

00:37:32.196 --> 00:37:34.386 A:middle
And since you have more cores

00:37:34.386 --> 00:37:35.326 A:middle
than you probably have more

00:37:35.326 --> 00:37:37.376 A:middle
threads all at the same time and

00:37:37.376 --> 00:37:38.616 A:middle
with more threads you might need

00:37:38.616 --> 00:37:40.376 A:middle
more synchronization to make

00:37:40.376 --> 00:37:41.326 A:middle
these threads cooperate.

00:37:42.256 --> 00:37:43.876 A:middle
And that's implemented using

00:37:43.876 --> 00:37:44.426 A:middle
atomics.

00:37:45.756 --> 00:37:47.636 A:middle
So the A11 chip also introduces

00:37:47.636 --> 00:37:48.826 A:middle
a new family of atomic

00:37:48.826 --> 00:37:51.116 A:middle
instructions that are better

00:37:51.116 --> 00:37:54.346 A:middle
optimized for the new extra

00:37:54.346 --> 00:37:54.796 A:middle
cores.

00:37:55.366 --> 00:37:58.386 A:middle
So let's look at how that works.

00:37:58.386 --> 00:38:02.536 A:middle
So the way atomics work is

00:37:58.386 --> 00:38:02.536 A:middle
So the way atomics work is

00:38:03.546 --> 00:38:04.746 A:middle
through a small sequence of

00:38:04.796 --> 00:38:05.096 A:middle
codes.

00:38:05.776 --> 00:38:08.116 A:middle
So suppose I have a thread and

00:38:08.116 --> 00:38:09.156 A:middle
it's trying to access main

00:38:09.156 --> 00:38:11.856 A:middle
memory, so it has an atomic

00:38:11.856 --> 00:38:13.826 A:middle
shared variable in there and

00:38:13.826 --> 00:38:14.996 A:middle
it's just trying to increment

00:38:15.656 --> 00:38:15.726 A:middle
it.

00:38:17.216 --> 00:38:18.716 A:middle
So under the hood the code

00:38:18.716 --> 00:38:20.176 A:middle
generator will emit a small

00:38:20.176 --> 00:38:23.026 A:middle
sequence of codes that first

00:38:23.276 --> 00:38:24.946 A:middle
takes exclusive excess of a

00:38:24.946 --> 00:38:26.816 A:middle
cache line and that's a small

00:38:26.816 --> 00:38:28.766 A:middle
region of memory that contains

00:38:28.766 --> 00:38:30.836 A:middle
completely this atomic variable.

00:38:31.426 --> 00:38:34.816 A:middle
Now that we have exclusive

00:38:34.816 --> 00:38:36.186 A:middle
access we can load from the

00:38:36.186 --> 00:38:38.046 A:middle
variable, then we can do our

00:38:38.046 --> 00:38:39.326 A:middle
increment on the temporary

00:38:39.436 --> 00:38:41.756 A:middle
loaded value and store the

00:38:41.756 --> 00:38:43.026 A:middle
result back.

00:38:44.636 --> 00:38:46.186 A:middle
And we know that this is safe

00:38:46.186 --> 00:38:47.066 A:middle
because we have exclusive

00:38:47.066 --> 00:38:48.766 A:middle
access, so no other thread could

00:38:48.766 --> 00:38:50.376 A:middle
have changed the value while

00:38:50.376 --> 00:38:51.936 A:middle
we're computing our temporary

00:38:51.936 --> 00:38:52.346 A:middle
results.

00:38:53.696 --> 00:38:55.496 A:middle
But now suppose another thread

00:38:55.496 --> 00:38:57.446 A:middle
does access either the same

00:38:57.446 --> 00:38:58.906 A:middle
variable or another variable in

00:38:58.906 --> 00:39:02.536 A:middle
the same cache line.

00:38:58.906 --> 00:39:02.536 A:middle
the same cache line.

00:39:02.776 --> 00:39:04.366 A:middle
So both are going to try to have

00:39:04.366 --> 00:39:05.876 A:middle
exclusive access over this

00:39:06.126 --> 00:39:08.616 A:middle
variable and that is not

00:39:08.616 --> 00:39:09.846 A:middle
possible, that's what it means

00:39:09.886 --> 00:39:12.196 A:middle
to be exclusive.

00:39:12.246 --> 00:39:14.346 A:middle
So both of them are going to

00:39:14.346 --> 00:39:16.636 A:middle
fail their exclusive access and

00:39:16.636 --> 00:39:17.726 A:middle
they're going to have to try

00:39:17.726 --> 00:39:18.656 A:middle
again until one of them

00:39:18.656 --> 00:39:19.146 A:middle
succeeds.

00:39:19.796 --> 00:39:23.086 A:middle
And this is not ideal for

00:39:23.086 --> 00:39:23.706 A:middle
performance.

00:39:24.286 --> 00:39:27.896 A:middle
So in ARM v8.1 which is the

00:39:28.536 --> 00:39:31.546 A:middle
architecture in the A10 CPU we

00:39:31.546 --> 00:39:32.636 A:middle
have new instructions that do

00:39:32.636 --> 00:39:34.626 A:middle
this all in a single step and in

00:39:34.626 --> 00:39:35.756 A:middle
some cases, that can greatly

00:39:35.756 --> 00:39:36.566 A:middle
improve performance.

00:39:37.126 --> 00:39:39.676 A:middle
So again, this is something that

00:39:39.676 --> 00:39:41.216 A:middle
you can specialize code for

00:39:41.526 --> 00:39:43.796 A:middle
using the per function

00:39:43.796 --> 00:39:45.426 A:middle
specialization or for entire

00:39:45.426 --> 00:39:45.996 A:middle
targets.

00:39:46.246 --> 00:39:48.086 A:middle
And this is something that's

00:39:48.086 --> 00:39:49.606 A:middle
only really useful when you have

00:39:49.606 --> 00:39:52.106 A:middle
your own C11 or C++ 11 atomics.

00:39:53.086 --> 00:39:54.486 A:middle
So in general, it's much easier

00:39:54.486 --> 00:39:55.736 A:middle
to use the higher-level

00:39:56.146 --> 00:39:58.376 A:middle
libraries like GCD or PThread or

00:39:58.376 --> 00:39:58.976 A:middle
os unfair lock, etcetera.

00:39:59.106 --> 00:40:02.096 A:middle
So these are already tweaked for

00:39:59.106 --> 00:40:02.096 A:middle
So these are already tweaked for

00:40:02.096 --> 00:40:03.976 A:middle
ARM v8.1, but they also

00:40:03.976 --> 00:40:04.976 A:middle
cooperate to the operating

00:40:04.976 --> 00:40:06.236 A:middle
system to have even better

00:40:06.236 --> 00:40:06.856 A:middle
performance.

00:40:11.216 --> 00:40:13.446 A:middle
So another feature in the A11

00:40:13.506 --> 00:40:15.356 A:middle
CPU is 16-bit floating points.

00:40:16.346 --> 00:40:18.186 A:middle
So you are all familiar with the

00:40:18.616 --> 00:40:20.366 A:middle
two standard floating point

00:40:20.366 --> 00:40:21.966 A:middle
types, so we have double which

00:40:21.966 --> 00:40:24.596 A:middle
is 64 bits and float which is 32

00:40:24.596 --> 00:40:24.956 A:middle
bits.

00:40:26.186 --> 00:40:27.456 A:middle
So on A11 we also have the

00:40:27.456 --> 00:40:31.756 A:middle
16-bit float16, this has much

00:40:31.756 --> 00:40:34.436 A:middle
less range and precision so it's

00:40:34.966 --> 00:40:37.126 A:middle
not as useful for as many cases.

00:40:37.916 --> 00:40:39.066 A:middle
But in some cases like machine

00:40:39.066 --> 00:40:39.856 A:middle
learning or when you're trying

00:40:39.856 --> 00:40:41.986 A:middle
to talk to GPU via Metal this is

00:40:41.986 --> 00:40:43.236 A:middle
great because it's smaller and

00:40:43.236 --> 00:40:44.176 A:middle
it's faster to compute.

00:40:45.256 --> 00:40:46.726 A:middle
And that's even more true if you

00:40:46.726 --> 00:40:48.166 A:middle
put them in vectors where you

00:40:48.166 --> 00:40:49.626 A:middle
can put more of them in the same

00:40:49.866 --> 00:40:50.456 A:middle
ARM vector.

00:40:51.086 --> 00:40:54.476 A:middle
So this is also something that

00:40:54.476 --> 00:40:56.966 A:middle
you can specialize code for and

00:40:56.966 --> 00:40:58.426 A:middle
in general something to keep in

00:40:58.426 --> 00:40:59.966 A:middle
mind with all of these features

00:41:00.586 --> 00:41:01.716 A:middle
is that they're not available

00:41:01.716 --> 00:41:02.106 A:middle
everywhere.

00:41:03.516 --> 00:41:05.166 A:middle
So when you want to use them you

00:41:05.166 --> 00:41:06.666 A:middle
have to always make sure that

00:41:06.666 --> 00:41:08.246 A:middle
they're actually dynamically

00:41:08.246 --> 00:41:09.246 A:middle
available on the device you're

00:41:09.246 --> 00:41:11.096 A:middle
running and you can do that

00:41:11.096 --> 00:41:12.236 A:middle
using sysctlbyname.

00:41:12.436 --> 00:41:15.326 A:middle
And so in general we already do

00:41:15.326 --> 00:41:16.736 A:middle
all this in system framework, so

00:41:16.736 --> 00:41:18.546 A:middle
it's much easier to just rely on

00:41:18.546 --> 00:41:18.966 A:middle
those.

00:41:19.546 --> 00:41:22.776 A:middle
So these are three new

00:41:22.776 --> 00:41:24.666 A:middle
instruction set extensions, we

00:41:24.666 --> 00:41:26.786 A:middle
have on the iMac Pro AVX-512 and

00:41:26.856 --> 00:41:28.606 A:middle
on iPhone X, 8, and 8 Plus we

00:41:28.606 --> 00:41:30.526 A:middle
have Atomics and 16-bit floating

00:41:30.526 --> 00:41:30.836 A:middle
points.

00:41:31.256 --> 00:41:35.306 A:middle
So that's just part of all the

00:41:35.306 --> 00:41:36.556 A:middle
new features in Xcode.

00:41:37.306 --> 00:41:39.356 A:middle
So from ARC object pointers in C

00:41:39.356 --> 00:41:41.026 A:middle
Structs to the improved static

00:41:41.026 --> 00:41:42.756 A:middle
analyzer there are lots of great

00:41:42.796 --> 00:41:43.696 A:middle
things in Xcode 10.

00:41:44.286 --> 00:41:45.986 A:middle
And there are also some things

00:41:45.986 --> 00:41:47.176 A:middle
that we didn't even talk about

00:41:47.516 --> 00:41:48.616 A:middle
like for instance, over a

00:41:48.616 --> 00:41:50.446 A:middle
hundred new warnings and support

00:41:50.446 --> 00:41:53.186 A:middle
for C++ 17 standard library

00:41:53.186 --> 00:41:53.586 A:middle
function.

00:41:55.496 --> 00:41:57.636 A:middle
So if you want to learn more we

00:41:57.636 --> 00:41:59.226 A:middle
have the video and the slides

00:41:59.226 --> 00:42:00.466 A:middle
available on the website soon.

00:41:59.226 --> 00:42:00.466 A:middle
available on the website soon.

00:42:01.006 --> 00:42:01.826 A:middle
And if you're here at the

00:42:01.826 --> 00:42:03.296 A:middle
conference come join us at the

00:42:03.296 --> 00:42:04.146 A:middle
lab this afternoon.

00:42:04.146 --> 00:42:04.756 A:middle
Thank you.

00:42:05.516 --> 00:42:11.500 A:middle
[ Applause ]
