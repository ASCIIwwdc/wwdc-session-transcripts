WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:27.016 --> 00:00:27.236 A:middle
[ Applause ]

00:00:27.236 --> 00:00:30.866 A:middle
&gt;&gt; Good afternoon, everyone.

00:00:31.776 --> 00:00:34.206 A:middle
And welcome to Visual
Debugging with Xcode.

00:00:35.226 --> 00:00:38.106 A:middle
I'm Chris, and I work
on Xcode's debugger UI.

00:00:39.426 --> 00:00:43.136 A:middle
You know, debugging tools
have come a long way.

00:00:44.676 --> 00:00:46.076 A:middle
It wasn't all that long ago

00:00:46.306 --> 00:00:48.766 A:middle
when our debugging tools
looked something like this.

00:00:50.436 --> 00:00:53.356 A:middle
A little while later,
with advancements in UI,

00:00:53.356 --> 00:00:56.826 A:middle
our debugging tools began
to look more like this.

00:00:58.976 --> 00:01:00.386 A:middle
But fast-forward to today,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:58.976 --> 00:01:00.386 A:middle
But fast-forward to today,

00:01:00.386 --> 00:01:03.866 A:middle
and our debugging tools have
become much more powerful while

00:01:03.866 --> 00:01:06.136 A:middle
at the same time becoming
much easier to use.

00:01:06.626 --> 00:01:08.876 A:middle
A big part of this is because
the tools are becoming more

00:01:08.876 --> 00:01:11.626 A:middle
visual, which helps us
to solve problems faster

00:01:11.976 --> 00:01:12.936 A:middle
and more intuitively.

00:01:13.966 --> 00:01:16.196 A:middle
Today, my colleagues and
I are going to tell you

00:01:16.196 --> 00:01:18.866 A:middle
about the latest in Xcode's
visual debugging tools.

00:01:21.496 --> 00:01:24.156 A:middle
First, a quick overview
of what we'll cover.

00:01:24.926 --> 00:01:27.746 A:middle
We're going to tell you about a
new feature of Xcode to be able

00:01:27.746 --> 00:01:31.396 A:middle
to report on issues detected
by the tools at runtime.

00:01:32.226 --> 00:01:35.356 A:middle
We're going to tell you
about the latest enhancements

00:01:35.356 --> 00:01:36.926 A:middle
that we've made to
Xcode's view debugger

00:01:37.256 --> 00:01:39.746 A:middle
and how we've made auto
layout debugging easier

00:01:39.746 --> 00:01:40.486 A:middle
than ever before.

00:01:41.366 --> 00:01:43.706 A:middle
We're going to tell you about
a new feature to be able

00:01:43.706 --> 00:01:47.816 A:middle
to visually debug state machines
and enhancements we've made

00:01:47.816 --> 00:01:51.896 A:middle
to the FPS performance gauge to
help with debugging SpriteKit

00:01:51.956 --> 00:01:53.586 A:middle
and SceneKit frame rate issues.

00:01:54.606 --> 00:01:58.076 A:middle
Finally, we're going to tell you
about a new feature of Xcode --

00:01:58.306 --> 00:01:59.826 A:middle
a visual memory graph debugger.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:03.916 --> 00:02:05.936 A:middle
Let's get started by
talking about issues.

00:02:08.936 --> 00:02:10.765 A:middle
We all know that
build time issues

00:02:10.765 --> 00:02:12.456 A:middle
such as compiler
warnings, errors,

00:02:12.456 --> 00:02:15.456 A:middle
and static analysis
issues are well-supported

00:02:15.606 --> 00:02:18.086 A:middle
by Xcode's user interface,
similarly

00:02:18.246 --> 00:02:20.286 A:middle
for our issues detected
while testing.

00:02:21.466 --> 00:02:24.216 A:middle
However, the same can't be
said for issues detected

00:02:24.216 --> 00:02:25.596 A:middle
by our expanding suite

00:02:25.596 --> 00:02:27.756 A:middle
of runtime debugging
and analysis tools.

00:02:28.406 --> 00:02:32.256 A:middle
These tools have
been left behind

00:02:32.596 --> 00:02:36.836 A:middle
with their best option being to
log their output to the console.

00:02:37.176 --> 00:02:38.346 A:middle
Not the best experience.

00:02:38.856 --> 00:02:40.506 A:middle
We thought we could
do much better.

00:02:42.446 --> 00:02:45.126 A:middle
In Xcode 8, we're
introducing runtime issues.

00:02:46.516 --> 00:02:51.796 A:middle
[ Applause ]

00:02:52.296 --> 00:02:55.316 A:middle
Runtime issues elevates the
issues detected by the tools

00:02:55.316 --> 00:02:58.276 A:middle
at runtime to the
same status in the UI

00:02:58.276 --> 00:03:00.576 A:middle
as traditional build
time issues.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.276 --> 00:03:00.576 A:middle
as traditional build
time issues.

00:03:03.016 --> 00:03:05.346 A:middle
The Activity Viewer will
display this indicator

00:03:05.346 --> 00:03:07.356 A:middle
when any runtime
issues are detected,

00:03:07.686 --> 00:03:09.586 A:middle
along with the number
of issues reported.

00:03:10.836 --> 00:03:13.496 A:middle
We've enhanced the
Issue Navigator

00:03:13.496 --> 00:03:15.146 A:middle
with a new runtime scope.

00:03:15.426 --> 00:03:17.726 A:middle
This separates the
issues detected at runtime

00:03:17.786 --> 00:03:19.546 A:middle
from the traditional
build time issues

00:03:19.676 --> 00:03:21.216 A:middle
such as compiler
warnings, errors,

00:03:21.216 --> 00:03:22.696 A:middle
and static analysis issues.

00:03:26.496 --> 00:03:29.876 A:middle
So what issues will you expect
to see reported at runtime?

00:03:30.546 --> 00:03:33.026 A:middle
In Xcode 8, we're
tackling three areas.

00:03:33.656 --> 00:03:36.396 A:middle
The first -- threading issues.

00:03:37.096 --> 00:03:39.466 A:middle
Our brand-new Thread
Sanitizer is able

00:03:39.466 --> 00:03:43.316 A:middle
to detect threading issues in
your application at runtime.

00:03:45.756 --> 00:03:46.946 A:middle
UI layout issues.

00:03:47.046 --> 00:03:49.516 A:middle
We've expanded Xcode's
view debugger to be able

00:03:49.516 --> 00:03:52.166 A:middle
to automatically detect
ambiguous layout issues

00:03:52.346 --> 00:03:53.606 A:middle
in your app at runtime.

00:03:55.966 --> 00:03:56.616 A:middle
And memory.

00:03:57.316 --> 00:03:59.256 A:middle
Our brand-new memory
graph debugger,

00:03:59.256 --> 00:04:01.146 A:middle
which we'll talk a lot more
about in a few moments,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.256 --> 00:04:01.146 A:middle
which we'll talk a lot more
about in a few moments,

00:04:01.146 --> 00:04:03.916 A:middle
is able to automatically
detect leaked memory

00:04:04.126 --> 00:04:05.446 A:middle
in your application at runtime.

00:04:10.046 --> 00:04:11.286 A:middle
So, as you heard
about on Monday,

00:04:11.286 --> 00:04:14.486 A:middle
Xcode's latest runtime sanitizer
is the Thread Sanitizer.

00:04:15.486 --> 00:04:17.906 A:middle
Thread Sanitizer
helps us to detect

00:04:17.906 --> 00:04:19.986 A:middle
and better understand
threading issues

00:04:20.026 --> 00:04:21.676 A:middle
in your applications at runtime.

00:04:22.696 --> 00:04:24.776 A:middle
It can detect such
issues as data races,

00:04:25.176 --> 00:04:28.426 A:middle
uses of uninitialized mutexes,
unlocks from the wrong thread,

00:04:28.896 --> 00:04:31.286 A:middle
thread leaks, and unsafe
calls in signal handlers.

00:04:32.226 --> 00:04:33.736 A:middle
If any of these issues
are detected,

00:04:33.966 --> 00:04:36.076 A:middle
they'll be reported
as runtime issues.

00:04:37.336 --> 00:04:39.906 A:middle
Thread Sanitizer is a powerful
new runtime analysis tool.

00:04:40.316 --> 00:04:43.096 A:middle
You can learn all about it by
watching the Thread Sanitizer

00:04:43.186 --> 00:04:44.606 A:middle
and Static Analysis session.

00:04:51.056 --> 00:04:52.686 A:middle
View debugging is
a great example

00:04:52.686 --> 00:04:55.476 A:middle
of Xcode's debugging tools
becoming more visual.

00:04:56.146 --> 00:05:01.046 A:middle
Only in the last couple of
years for debugging UI issues,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:56.146 --> 00:05:01.046 A:middle
Only in the last couple of
years for debugging UI issues,

00:05:01.046 --> 00:05:04.196 A:middle
we've gone from having
to read debug output

00:05:04.196 --> 00:05:07.676 A:middle
in a console like this to this.

00:05:08.086 --> 00:05:11.296 A:middle
Xcode's visual view debugger
is a much better experience

00:05:11.526 --> 00:05:14.496 A:middle
for debugging and
understanding visual UI issues.

00:05:15.506 --> 00:05:16.866 A:middle
If you haven't used it before,

00:05:17.546 --> 00:05:19.176 A:middle
while Xcode is running
your application,

00:05:20.106 --> 00:05:22.616 A:middle
just tap the Debug
View Hierarchy button

00:05:22.946 --> 00:05:24.466 A:middle
down in the Debug Bar.

00:05:25.486 --> 00:05:27.506 A:middle
Xcode will snapshot
your application,

00:05:28.356 --> 00:05:30.676 A:middle
snapshot your view
hierarchy, and explode it

00:05:30.676 --> 00:05:32.826 A:middle
out in an interactive 3D scene.

00:05:33.656 --> 00:05:36.926 A:middle
From there, you can inspect the
structure of the view hierarchy

00:05:36.986 --> 00:05:40.556 A:middle
in the 3D canvas and
in the outline view.

00:05:40.906 --> 00:05:43.506 A:middle
And you can inspect the
properties of all of the views

00:05:43.506 --> 00:05:45.746 A:middle
and constraints using
the inspectors.

00:05:48.966 --> 00:05:54.316 A:middle
In Xcode 8, we've made view
debugging -- can you guess?

00:05:54.316 --> 00:05:54.756 A:middle
Better than ever.

00:05:55.516 --> 00:06:02.546 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:55.516 --> 00:06:02.546 A:middle
[ Applause ]

00:06:03.046 --> 00:06:05.226 A:middle
Snapshots are now
up to 70% faster.

00:06:05.226 --> 00:06:07.086 A:middle
So you can go from
running your application

00:06:07.376 --> 00:06:08.976 A:middle
to debugging UI issues
quicker than ever before.

00:06:09.516 --> 00:06:14.656 A:middle
[ Applause ]

00:06:15.156 --> 00:06:17.246 A:middle
The rendering of complex layouts

00:06:17.246 --> 00:06:20.256 A:middle
and transformed views is much
more accurate in Xcode 8.

00:06:20.256 --> 00:06:24.316 A:middle
And speaking of accuracy, Xcode
can now render blurred view,

00:06:24.316 --> 00:06:27.066 A:middle
such as visual effect views with
high fidelity in the canvas.

00:06:27.696 --> 00:06:30.506 A:middle
So what you see in Xcode's
view debugger more accurately

00:06:30.506 --> 00:06:32.786 A:middle
reflects what you see on device.

00:06:33.106 --> 00:06:35.206 A:middle
You'll see the blur rendering
improvement land in beta 2.

00:06:36.986 --> 00:06:39.266 A:middle
We've added conveniences, such
as being able to jump directly

00:06:39.266 --> 00:06:40.906 A:middle
to the source code
from a view class.

00:06:40.906 --> 00:06:43.576 A:middle
Just tap the Jump button
in the Object Inspector.

00:06:44.496 --> 00:06:48.506 A:middle
And navigator filtering is
much more powerful, too.

00:06:48.916 --> 00:06:50.936 A:middle
You can filter by
any text in a label

00:06:51.336 --> 00:06:53.586 A:middle
or text in a button's title.

00:06:54.506 --> 00:06:56.656 A:middle
Or you can filter
by class names,

00:06:56.656 --> 00:06:58.786 A:middle
and that will include
super class names.

00:06:58.916 --> 00:07:02.796 A:middle
For example, if you filter by
UI label, you'll get back all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:58.916 --> 00:07:02.796 A:middle
For example, if you filter by
UI label, you'll get back all

00:07:02.796 --> 00:07:05.616 A:middle
of the subclasses of UI
label in your view hierarchy.

00:07:06.296 --> 00:07:07.856 A:middle
You can even filter
by memory address.

00:07:08.146 --> 00:07:10.576 A:middle
So you can quickly find
that particular view just

00:07:10.576 --> 00:07:11.936 A:middle
by knowing its address
and memory.

00:07:17.316 --> 00:07:18.586 A:middle
We've got some great
improvements

00:07:18.586 --> 00:07:20.236 A:middle
for auto layout debugging
as well.

00:07:20.806 --> 00:07:23.486 A:middle
We show many more properties
related to auto layout

00:07:23.486 --> 00:07:24.366 A:middle
in the inspectors,

00:07:25.146 --> 00:07:27.906 A:middle
and constraints are better
represented in the canvas.

00:07:28.656 --> 00:07:30.596 A:middle
We now render badges
on constraints

00:07:30.626 --> 00:07:33.716 A:middle
to represent inequality or
aspect ratio relationships.

00:07:34.096 --> 00:07:36.936 A:middle
And we render non-required
constraints with dash lines

00:07:36.936 --> 00:07:39.246 A:middle
so you can easily
differentiate between required

00:07:39.406 --> 00:07:41.256 A:middle
and non-required
constraints in the canvas.

00:07:42.776 --> 00:07:45.716 A:middle
But my favorite new feature
for auto layout debugging is

00:07:45.716 --> 00:07:47.546 A:middle
in conjunction with
runtime issues.

00:07:49.506 --> 00:07:50.556 A:middle
Xcode is now able

00:07:50.556 --> 00:07:52.916 A:middle
to automatically detect
ambiguous layout issues

00:07:52.916 --> 00:07:54.876 A:middle
in your view hierarchy
at runtime.

00:07:57.516 --> 00:08:01.636 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:57.516 --> 00:08:01.636 A:middle
[ Applause ]

00:08:02.136 --> 00:08:03.266 A:middle
So how does this work?

00:08:03.266 --> 00:08:05.156 A:middle
While snapshotting
your view hierarchy,

00:08:05.156 --> 00:08:07.576 A:middle
Xcode will inspect every
single view and is able

00:08:07.576 --> 00:08:09.846 A:middle
to accurately determine if any

00:08:09.846 --> 00:08:11.736 A:middle
of those views have
ambiguous layouts,

00:08:11.896 --> 00:08:13.816 A:middle
along with the reason
for the ambiguity.

00:08:14.666 --> 00:08:16.846 A:middle
If any layout issues
are detected,

00:08:16.846 --> 00:08:20.496 A:middle
they'll be reported
as runtime issues.

00:08:21.186 --> 00:08:23.056 A:middle
So you'll see them indicated
in the Activity Viewer,

00:08:23.186 --> 00:08:24.636 A:middle
and you'll see them listed

00:08:24.636 --> 00:08:26.436 A:middle
in the Issue Navigator
under runtime.

00:08:28.156 --> 00:08:31.716 A:middle
Furthermore, the view hierarchy
outline will badge any views

00:08:31.766 --> 00:08:34.926 A:middle
that have layout issues,
so you can easily spot them

00:08:34.966 --> 00:08:36.996 A:middle
in the context of the
whole view hierarchy.

00:08:39.376 --> 00:08:43.096 A:middle
For a selected view, the Size
Inspector will contain details

00:08:43.096 --> 00:08:46.456 A:middle
of any layout issues, along
with all of the constraints

00:08:46.456 --> 00:08:48.586 A:middle
that participated in the
layout for that view.

00:08:49.906 --> 00:08:52.126 A:middle
We're really excited about
Xcode's new ability to be able

00:08:52.126 --> 00:08:54.366 A:middle
to automatically detect
ambiguous layout issues

00:08:54.366 --> 00:08:54.776 A:middle
at runtime.

00:08:54.776 --> 00:08:56.266 A:middle
And I'd love to give you a demo.

00:08:59.416 --> 00:09:00.636 A:middle
So I have an iPhone here,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.416 --> 00:09:00.636 A:middle
So I have an iPhone here,

00:09:00.876 --> 00:09:02.386 A:middle
and I've got it connected
to this Mac.

00:09:02.386 --> 00:09:05.736 A:middle
We've got Xcode up and running
a project called DemoBots.

00:09:06.176 --> 00:09:07.816 A:middle
That's one of our
sample code projects

00:09:07.816 --> 00:09:10.456 A:middle
that we've updated
to Swift 3 this year.

00:09:11.456 --> 00:09:13.186 A:middle
On the right, I'm just
using QuickTime Player

00:09:13.436 --> 00:09:14.946 A:middle
to stream the device's
screen back

00:09:14.946 --> 00:09:16.246 A:middle
to the desktop so
we can all see it.

00:09:16.246 --> 00:09:20.146 A:middle
Our team was tasked with adding
an in-game instruction manual

00:09:20.146 --> 00:09:22.696 A:middle
to DemoBots, so we implemented
a How To Play screen.

00:09:23.276 --> 00:09:26.366 A:middle
However, we had some issues that
we found before the session.

00:09:26.456 --> 00:09:28.926 A:middle
So now is a great opportunity
to debug those issues.

00:09:29.686 --> 00:09:30.456 A:middle
I'll tap How To Play.

00:09:30.496 --> 00:09:32.246 A:middle
And this is our How
To Play screen.

00:09:32.886 --> 00:09:33.686 A:middle
Not so great is it?

00:09:34.426 --> 00:09:36.726 A:middle
Obviously, we have some
issues, so let's take a look.

00:09:36.726 --> 00:09:40.196 A:middle
We can see the DemoBots logo at
the back, and there's some sort

00:09:40.196 --> 00:09:41.666 A:middle
of mangled text rendered on top.

00:09:42.056 --> 00:09:43.616 A:middle
So we need to debug this.

00:09:43.616 --> 00:09:44.246 A:middle
Where do we start?

00:09:44.246 --> 00:09:46.196 A:middle
I'll give you some clues.

00:09:46.936 --> 00:09:49.806 A:middle
DemoBots is a little arcade
game written in SpriteKit,

00:09:49.806 --> 00:09:53.326 A:middle
but this screen has been laid
out using UIKit and auto layout.

00:09:53.726 --> 00:09:56.226 A:middle
So a good place to start
is to look under the hood

00:09:56.226 --> 00:09:59.896 A:middle
at the structure of the view
hierarchy and all the layouts.

00:09:59.986 --> 00:10:00.826 A:middle
So let's do that now.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.986 --> 00:10:00.826 A:middle
So let's do that now.

00:10:01.916 --> 00:10:05.226 A:middle
If I return to Xcode,
down on the bottom,

00:10:05.476 --> 00:10:08.056 A:middle
we can use the Debug
View Hierarchy button,

00:10:08.626 --> 00:10:10.446 A:middle
which I'll click now.

00:10:10.526 --> 00:10:12.116 A:middle
And that pauses the application

00:10:12.236 --> 00:10:13.916 A:middle
and snapshots the
entire view hierarchy.

00:10:15.006 --> 00:10:18.556 A:middle
In the editor, we now get back
an accurate representation

00:10:18.556 --> 00:10:19.716 A:middle
of what we were seeing
on screen.

00:10:20.776 --> 00:10:23.016 A:middle
And then to look under
the hood at the structure,

00:10:23.076 --> 00:10:24.776 A:middle
all we need to do is
drag in the canvas

00:10:24.776 --> 00:10:27.046 A:middle
and we get the whole
view hierarchy exploited

00:10:27.046 --> 00:10:28.796 A:middle
out for us in the 3D view.

00:10:29.516 --> 00:10:33.546 A:middle
[ Applause ]

00:10:34.046 --> 00:10:35.886 A:middle
Here, we can see all
of the views that make

00:10:35.886 --> 00:10:38.776 A:middle
up this particular screen
-- the window at the back,

00:10:38.776 --> 00:10:41.566 A:middle
container views, visual
effects view, and then the views

00:10:41.566 --> 00:10:43.536 A:middle
that make up the How
To Play instructions.

00:10:44.016 --> 00:10:44.966 A:middle
Let's zoom in on those.

00:10:45.736 --> 00:10:47.396 A:middle
We see the DemoBots
logo at the back,

00:10:47.396 --> 00:10:49.256 A:middle
and then a bunch of
labels and images.

00:10:49.786 --> 00:10:53.226 A:middle
And we quickly get some insight
by panning around the reason

00:10:53.266 --> 00:10:55.036 A:middle
for the mess we see on screen.

00:10:55.436 --> 00:10:56.466 A:middle
All of these views
have been laid

00:10:56.466 --> 00:10:58.026 A:middle
out one on top of the other.

00:10:58.336 --> 00:10:59.296 A:middle
So we've got a layout issue.

00:10:59.796 --> 00:11:03.106 A:middle
Now our traditional workflow
would be to inspect each


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.796 --> 00:11:03.106 A:middle
Now our traditional workflow
would be to inspect each

00:11:03.106 --> 00:11:05.006 A:middle
of these views and their
constraints and try

00:11:05.006 --> 00:11:06.836 A:middle
and determine the reason
for the layout issue.

00:11:06.836 --> 00:11:09.226 A:middle
But in Xcode 8, we
have some additional

00:11:09.226 --> 00:11:10.166 A:middle
information available.

00:11:10.976 --> 00:11:14.046 A:middle
Notice up here in the Activity
Viewer Xcode is reporting

00:11:14.046 --> 00:11:15.656 A:middle
that we have some
runtime issues.

00:11:16.666 --> 00:11:20.396 A:middle
We could click on that
one, and that would take us

00:11:20.426 --> 00:11:21.396 A:middle
to the issue navigator.

00:11:22.076 --> 00:11:25.126 A:middle
But you may also notice
that over here on the left

00:11:25.126 --> 00:11:27.606 A:middle
in the Debug Navigator,

00:11:27.606 --> 00:11:29.466 A:middle
Xcode has badged some
of the views for us.

00:11:29.736 --> 00:11:31.966 A:middle
And that's telling us that
these views have layout issues.

00:11:31.966 --> 00:11:32.996 A:middle
So let's go straight to here.

00:11:34.296 --> 00:11:35.736 A:middle
If I select the first view,

00:11:36.316 --> 00:11:38.356 A:middle
that highlights the view
in the canvas for us.

00:11:38.356 --> 00:11:40.776 A:middle
And let's open the Size
Inspector for that view

00:11:40.776 --> 00:11:41.586 A:middle
over here on the right.

00:11:43.066 --> 00:11:43.756 A:middle
Here, we can see

00:11:43.756 --> 00:11:46.136 A:middle
under constraints the
reason for the layout issue.

00:11:46.546 --> 00:11:49.396 A:middle
This view has an
ambiguous vertical position.

00:11:50.136 --> 00:11:52.526 A:middle
Now that means that auto layout
doesn't have enough information

00:11:52.716 --> 00:11:54.746 A:middle
to be able to unambiguously
position this view

00:11:54.906 --> 00:11:56.136 A:middle
in the vertical dimension.

00:11:57.036 --> 00:11:58.566 A:middle
Typically, constraints
are missing.

00:11:59.456 --> 00:12:01.496 A:middle
Let's have a look
at the next view.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.456 --> 00:12:01.496 A:middle
Let's have a look
at the next view.

00:12:02.306 --> 00:12:04.656 A:middle
That has the same issue --
vertical position is ambiguous.

00:12:05.356 --> 00:12:06.966 A:middle
And so does the next one.

00:12:06.966 --> 00:12:08.226 A:middle
If I randomly click
on a few more,

00:12:08.226 --> 00:12:09.626 A:middle
it looks like they all
have the same problem.

00:12:10.396 --> 00:12:12.556 A:middle
What I find curious is
the very first sub-view

00:12:12.826 --> 00:12:15.066 A:middle
in this list is not
badged with an issue.

00:12:15.246 --> 00:12:17.206 A:middle
So that could be a clue when
we get to the layout code.

00:12:17.966 --> 00:12:18.746 A:middle
Let's go to that now.

00:12:19.306 --> 00:12:22.316 A:middle
If I select the Parent
View, which has a class name

00:12:22.316 --> 00:12:25.006 A:middle
of InstructionsLayoutView,
this is the view responsible

00:12:25.006 --> 00:12:26.636 A:middle
for laying out this
How To Play screen.

00:12:27.696 --> 00:12:29.676 A:middle
So let's jump to the
source code for that.

00:12:29.936 --> 00:12:32.816 A:middle
An easy way to do that
is to select the view.

00:12:32.816 --> 00:12:34.936 A:middle
And over here on the
right, we will find

00:12:35.026 --> 00:12:38.246 A:middle
in the Object Inspector a button
where we can jump directly

00:12:38.246 --> 00:12:39.996 A:middle
to the source code
for that view.

00:12:40.686 --> 00:12:41.396 A:middle
So we'll do that now.

00:12:41.546 --> 00:12:43.546 A:middle
We'll close the Inspector
to give us some room.

00:12:44.096 --> 00:12:45.246 A:middle
And let's take a
look at the source

00:12:45.246 --> 00:12:46.456 A:middle
for InstructionsLayoutView.

00:12:48.256 --> 00:12:50.976 A:middle
It starts by iterating
over each of the parts

00:12:50.976 --> 00:12:53.156 A:middle
of the instructions, which
are just model objects

00:12:53.276 --> 00:12:57.746 A:middle
which describe section headers,
section paragraphs, and images.

00:12:58.286 --> 00:13:00.996 A:middle
And the code lays these
out top-to-bottom.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.286 --> 00:13:00.996 A:middle
And the code lays these
out top-to-bottom.

00:13:01.576 --> 00:13:03.896 A:middle
So for each part, we fix
the view and we add it

00:13:03.896 --> 00:13:04.716 A:middle
to the view hierarchy.

00:13:05.256 --> 00:13:07.066 A:middle
Then we have some code
for the horizontal layout.

00:13:07.096 --> 00:13:09.446 A:middle
But we didn't notice any
issues with horizontal layout,

00:13:09.446 --> 00:13:11.716 A:middle
so let's skip over that
to the vertical layout.

00:13:12.606 --> 00:13:13.566 A:middle
Here, we have two paths.

00:13:13.566 --> 00:13:17.276 A:middle
The first is for the very
first sub-view to constrain it

00:13:17.276 --> 00:13:18.276 A:middle
to the top of the container.

00:13:18.926 --> 00:13:22.866 A:middle
Well, we already noted that the
first sub-view wasn't reported

00:13:22.866 --> 00:13:23.816 A:middle
as having any issues.

00:13:24.156 --> 00:13:26.566 A:middle
So, that constraint we
assume is set up correctly.

00:13:26.566 --> 00:13:28.456 A:middle
So let's jump to the other
side of the conditional.

00:13:28.956 --> 00:13:32.616 A:middle
Here, we're evaluating an
optional previousPartView.

00:13:32.656 --> 00:13:35.906 A:middle
And if we have it, we assign it
to the local variable above you.

00:13:36.476 --> 00:13:39.966 A:middle
And then we can constrain each
view to the view above it.

00:13:40.106 --> 00:13:41.736 A:middle
It looks like this is the
constraint that's missing.

00:13:42.486 --> 00:13:44.556 A:middle
So let's have a look at
why this conditional is not

00:13:44.966 --> 00:13:46.986 A:middle
becoming true.

00:13:47.556 --> 00:13:50.596 A:middle
If we select previousPartView
-- we'll start with that one --

00:13:50.596 --> 00:13:53.356 A:middle
I'll use Command-E to
select it for search

00:13:53.646 --> 00:13:55.286 A:middle
and Command-F to
get the Find Bar.

00:13:56.156 --> 00:13:57.706 A:middle
Let's look for instances
of this variable.

00:13:58.366 --> 00:13:59.996 A:middle
We see it's defined at the top.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:00.206 --> 00:14:02.606 A:middle
It's set to "nil" before
answering the fore loop.

00:14:02.956 --> 00:14:04.186 A:middle
We evaluate it down here,

00:14:04.756 --> 00:14:06.826 A:middle
and then we evaluate it
again outside of the loop

00:14:06.876 --> 00:14:08.596 A:middle
to handle the bottom constraint.

00:14:08.636 --> 00:14:10.836 A:middle
But it looks like we're
never assigning to it.

00:14:11.026 --> 00:14:11.836 A:middle
So let's quickly fix that.

00:14:11.836 --> 00:14:15.356 A:middle
So at the end of the loop,
we can set previousPartView

00:14:16.136 --> 00:14:16.986 A:middle
to the current partView.

00:14:17.066 --> 00:14:18.976 A:middle
And then on each iteration,

00:14:19.426 --> 00:14:21.206 A:middle
we'll have the previous
view available,

00:14:21.206 --> 00:14:23.676 A:middle
which will be assigned
to aboveView.

00:14:23.676 --> 00:14:27.036 A:middle
And we'll set up the constraint
from a view to the one above it.

00:14:27.336 --> 00:14:29.016 A:middle
Let's stop and rerun
it and check our work.

00:14:29.016 --> 00:14:31.286 A:middle
And I'll bring QuickTime
to the front.

00:14:32.206 --> 00:14:34.416 A:middle
Just note how much
information Xcode was able

00:14:34.416 --> 00:14:36.476 A:middle
to give us before
we even got to code.

00:14:37.066 --> 00:14:39.436 A:middle
We use view debugger to look
under the hood at the structure

00:14:39.436 --> 00:14:40.876 A:middle
and get some insight
into the problem.

00:14:41.266 --> 00:14:43.526 A:middle
But more than that,
Xcode proactively told us

00:14:43.526 --> 00:14:46.466 A:middle
about some layout issues
in our application,

00:14:46.916 --> 00:14:47.946 A:middle
which views had issues,

00:14:47.946 --> 00:14:50.116 A:middle
and specifically what
those issues were.

00:14:50.586 --> 00:14:53.186 A:middle
So that gave us a lot of insight
before we even got to the code,

00:14:53.186 --> 00:14:55.406 A:middle
so we could quickly
zero-in on the part

00:14:55.406 --> 00:14:56.386 A:middle
of the code that we needed to.

00:14:57.796 --> 00:14:59.916 A:middle
Now that our application is
running, I can tap How To Play.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:00.006 --> 00:15:02.076 A:middle
And there, it looks much better.

00:15:02.386 --> 00:15:03.806 A:middle
We have a nice-looking
instructions screen.

00:15:05.516 --> 00:15:10.796 A:middle
[ Applause ]

00:15:11.296 --> 00:15:15.256 A:middle
So Xcode is now able to
report on issues detected

00:15:15.256 --> 00:15:19.366 A:middle
at runtime using the same UI as
we did for build time issues.

00:15:20.636 --> 00:15:23.376 A:middle
Xcode's view debugger has
great enhancements this year,

00:15:23.876 --> 00:15:27.636 A:middle
including faster snapshotting
and more accurate rendering

00:15:27.676 --> 00:15:30.296 A:middle
of complex layouts
and blurred views.

00:15:31.696 --> 00:15:32.946 A:middle
We've got some great enhancement

00:15:32.946 --> 00:15:34.396 A:middle
for auto layout debugging
as well.

00:15:34.676 --> 00:15:36.536 A:middle
In particular, Xcode is now able

00:15:36.536 --> 00:15:39.046 A:middle
to automatically detect
ambiguous layout issues

00:15:39.276 --> 00:15:39.956 A:middle
at runtime.

00:15:40.716 --> 00:15:43.146 A:middle
Xcode's view debugger
supports debugging UIs

00:15:43.146 --> 00:15:45.486 A:middle
on macOS, iOS, and tvOS.

00:15:46.186 --> 00:15:47.816 A:middle
Give it a try with your
projects, and we'd love

00:15:47.816 --> 00:15:49.286 A:middle
to hear feedback
on how it helps you

00:15:49.286 --> 00:15:50.836 A:middle
with your debugging workflow.

00:15:51.866 --> 00:15:55.476 A:middle
And with that, I'd like to
hand over to Tyler who's going

00:15:55.476 --> 00:15:58.676 A:middle
to tell us about debugging state
machines and frame rate issues.

00:15:59.006 --> 00:15:59.256 A:middle
Thanks.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.516 --> 00:16:04.546 A:middle
[ Applause ]

00:16:05.046 --> 00:16:05.696 A:middle
&gt;&gt; Thanks, Chris.

00:16:06.566 --> 00:16:08.356 A:middle
Today, I'll be showing you a
new way you can enhance your

00:16:08.356 --> 00:16:10.636 A:middle
debugging experience with
the State Machine Quick Look,

00:16:10.886 --> 00:16:13.476 A:middle
as well as some additions made
inside the FPS performance gauge

00:16:13.566 --> 00:16:14.326 A:middle
for Xcode 8.

00:16:15.976 --> 00:16:16.716 A:middle
Today, we have a number

00:16:16.716 --> 00:16:19.436 A:middle
of useful Quick Looks already
available inside of Xcode 7,

00:16:19.436 --> 00:16:22.246 A:middle
and these provide you the
ability to view a wide variety

00:16:22.246 --> 00:16:24.116 A:middle
of objects live during
your debugging.

00:16:24.116 --> 00:16:26.746 A:middle
And you can even provide
your own custom Quick Look

00:16:27.146 --> 00:16:28.946 A:middle
to view objects within your app.

00:16:29.736 --> 00:16:30.856 A:middle
And now in Xcode 8,

00:16:31.136 --> 00:16:32.876 A:middle
we're extending our
built-in Quick Looks

00:16:32.876 --> 00:16:34.196 A:middle
to include state machines.

00:16:34.646 --> 00:16:37.536 A:middle
So let's first dive into what
exactly a state machine is

00:16:37.536 --> 00:16:40.246 A:middle
and how you could use
it within your app.

00:16:41.246 --> 00:16:43.886 A:middle
So, many of you may already be
familiar with GKStateMachine,

00:16:43.886 --> 00:16:46.106 A:middle
which was part of our release
of GameplayKit last year.

00:16:46.246 --> 00:16:49.066 A:middle
And it's available on
macOS, iOS, and tvOS.

00:16:50.376 --> 00:16:53.276 A:middle
State machines allow you to more
easily define complex behavior

00:16:53.276 --> 00:16:55.966 A:middle
by structuring it
as a directed graph.

00:16:55.966 --> 00:16:57.146 A:middle
And within a state machine,

00:16:57.146 --> 00:16:59.566 A:middle
you provide discrete
behavior for each state.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.276 --> 00:17:02.866 A:middle
This could be something
as simple as an animation

00:17:02.866 --> 00:17:05.406 A:middle
that will play, or something
more complex like an AI.

00:17:06.536 --> 00:17:09.046 A:middle
And then for each state,
you define the conditions

00:17:09.046 --> 00:17:10.886 A:middle
by which the state
machine will transition

00:17:10.886 --> 00:17:12.276 A:middle
from one state to another.

00:17:13.915 --> 00:17:16.336 A:middle
Once assembled, state
machines can produce remarkably

00:17:16.336 --> 00:17:17.556 A:middle
sophisticated behavior.

00:17:17.806 --> 00:17:21.205 A:middle
However, they can quickly become
difficult to visualize in code

00:17:21.455 --> 00:17:22.996 A:middle
as they expand in complexity.

00:17:23.455 --> 00:17:25.546 A:middle
And simple state machines
can quickly evolve

00:17:25.546 --> 00:17:26.986 A:middle
into far more elaborate ones.

00:17:27.546 --> 00:17:30.036 A:middle
In Xcode 7.3, our support

00:17:30.036 --> 00:17:32.706 A:middle
for debugging state machines was
limited to the current state,

00:17:32.706 --> 00:17:34.096 A:middle
as well as its transitions.

00:17:34.506 --> 00:17:36.086 A:middle
However, now in Xcode 8,

00:17:36.256 --> 00:17:38.546 A:middle
we're able to visualize
the entire state machine

00:17:38.546 --> 00:17:40.476 A:middle
so that you can see
exactly what's going on.

00:17:41.506 --> 00:17:43.906 A:middle
This is incredibly useful
whether you're operating

00:17:43.906 --> 00:17:46.896 A:middle
with very simple state machines
or whether you're working

00:17:46.896 --> 00:17:49.436 A:middle
with much more complex
state machines.

00:17:50.056 --> 00:17:53.176 A:middle
With Quick Look, you're able to
quickly debug potential issues

00:17:53.446 --> 00:17:55.116 A:middle
and evaluate exactly
what's happening

00:17:55.206 --> 00:17:56.356 A:middle
within your state machines.

00:17:56.926 --> 00:18:01.446 A:middle
So, now, let's shift our
focus over to performance.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:56.926 --> 00:18:01.446 A:middle
So, now, let's shift our
focus over to performance.

00:18:02.336 --> 00:18:04.806 A:middle
Any time you're creating any
sort of game or visual app,

00:18:04.936 --> 00:18:06.546 A:middle
maintaining good
performance is key.

00:18:07.056 --> 00:18:09.836 A:middle
And in Xcode 8, we've expanded
the FPS performance gauge

00:18:09.836 --> 00:18:12.356 A:middle
to help you with this.

00:18:12.586 --> 00:18:14.156 A:middle
Many of you may already
be familiar with parts

00:18:14.156 --> 00:18:16.596 A:middle
of the FPS performance
gauge from Xcode 7.

00:18:16.906 --> 00:18:19.216 A:middle
And at the top of the report,
you're provided a number

00:18:19.216 --> 00:18:20.566 A:middle
of real-time statistics.

00:18:21.586 --> 00:18:23.726 A:middle
This includes your frame rate,
which is the current number

00:18:23.726 --> 00:18:25.146 A:middle
of frames being rendered
per second,

00:18:26.076 --> 00:18:28.496 A:middle
as well as your GPU
utilization to see which parts

00:18:28.496 --> 00:18:31.626 A:middle
of your GPU are being used
the most, and your frame time

00:18:31.626 --> 00:18:33.486 A:middle
for both the CPU and the GPU.

00:18:34.226 --> 00:18:35.026 A:middle
This helps indicate

00:18:35.026 --> 00:18:37.586 A:middle
to you whether you may be
CPU-bound or GPU-bound.

00:18:40.016 --> 00:18:41.976 A:middle
Now, in addition to
real-time statistics,

00:18:42.056 --> 00:18:44.676 A:middle
Xcode 8 now provides
you a timeline history

00:18:44.936 --> 00:18:47.326 A:middle
of your SpriteKit and
SceneKit's frame time

00:18:47.416 --> 00:18:49.076 A:middle
for both the CPU and the GPU.

00:18:49.076 --> 00:18:51.586 A:middle
This is available
on iOS and watchOS.

00:18:52.216 --> 00:18:53.276 A:middle
And what's great about this is

00:18:53.276 --> 00:18:56.496 A:middle
that we breakdown your CPU frame
time and its individual parts

00:18:56.496 --> 00:18:59.086 A:middle
so you're able to see
exactly how much time is spent

00:18:59.086 --> 00:19:01.276 A:middle
rendering, or running
your update loop,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.086 --> 00:19:01.276 A:middle
rendering, or running
your update loop,

00:19:01.276 --> 00:19:02.926 A:middle
or evaluating actions
and physics,

00:19:03.076 --> 00:19:04.576 A:middle
and even how much
time is spent idle.

00:19:05.126 --> 00:19:08.576 A:middle
And when your app is
paused, you're able to scroll

00:19:08.576 --> 00:19:10.316 A:middle
through the history of
your app's performance

00:19:10.316 --> 00:19:11.766 A:middle
so that you can see
how it evolves

00:19:11.766 --> 00:19:13.006 A:middle
as you progress through
your app.

00:19:13.006 --> 00:19:15.976 A:middle
And if there's a particular
sample you're interested in,

00:19:16.256 --> 00:19:18.916 A:middle
you can dive deeper to
examine finer details on it

00:19:19.486 --> 00:19:21.256 A:middle
and get some exact timings.

00:19:21.446 --> 00:19:25.976 A:middle
So let's take a look at how we
can use these within our app.

00:19:43.186 --> 00:19:45.906 A:middle
So now that we've addressed the
layout issues that we've got.

00:19:46.026 --> 00:19:47.626 A:middle
In our How To Play
menu, let's go ahead

00:19:47.626 --> 00:19:48.946 A:middle
and dive into the game itself.

00:19:51.136 --> 00:19:53.246 A:middle
The objective of our
game is to convert all

00:19:53.246 --> 00:19:56.916 A:middle
of the corrupted robots within
our computer into good robots.

00:19:57.136 --> 00:19:59.616 A:middle
And to do this, I have
a beam that can zap them

00:19:59.616 --> 00:20:02.096 A:middle
and reconfigure them
into good robots.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.616 --> 00:20:02.096 A:middle
and reconfigure them
into good robots.

00:20:02.266 --> 00:20:04.906 A:middle
Now we see here I've already
got a bad robot trying to come

00:20:04.906 --> 00:20:06.976 A:middle
after me, so I'll use
my beam to zap him.

00:20:11.236 --> 00:20:12.756 A:middle
So you see he's been converted

00:20:12.756 --> 00:20:14.686 A:middle
to a good robot --
indicated with green.

00:20:15.496 --> 00:20:18.346 A:middle
But I see that we still have
a part of our beam present

00:20:18.346 --> 00:20:20.726 A:middle
above our character, and
this shouldn't be the case.

00:20:21.466 --> 00:20:23.986 A:middle
Now since we're using a state
machine to manage the behavior

00:20:23.986 --> 00:20:26.766 A:middle
of our beam, this
is a good candidate

00:20:26.766 --> 00:20:28.666 A:middle
to use the State Machine
Quick Look to figure

00:20:28.666 --> 00:20:29.606 A:middle
out what's going on here.

00:20:30.476 --> 00:20:34.176 A:middle
So I'll go ahead and pause
our app while I navigate

00:20:34.176 --> 00:20:35.226 A:middle
to our BeamComponent.

00:20:36.276 --> 00:20:38.186 A:middle
Now our BeamComponent
is where we create

00:20:38.186 --> 00:20:39.616 A:middle
and update our state machine

00:20:39.616 --> 00:20:41.586 A:middle
that manages the
behavior of our beam.

00:20:42.036 --> 00:20:44.156 A:middle
And I'll add a breakpoint
here on our update loop

00:20:44.406 --> 00:20:45.746 A:middle
and resume our game
so that we hit

00:20:45.746 --> 00:20:46.906 A:middle
that break point immediately.

00:20:47.446 --> 00:20:50.596 A:middle
So now that we're paused,
I can go into debug area

00:20:50.596 --> 00:20:52.626 A:middle
and find our instance
of the state machine,

00:20:53.026 --> 00:20:53.986 A:middle
and we can Quick Look it.

00:20:54.196 --> 00:20:57.396 A:middle
And from here, we can see
the entire state machine.

00:20:58.126 --> 00:21:00.416 A:middle
In blue, we see the
current state that we're in,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.126 --> 00:21:00.416 A:middle
In blue, we see the
current state that we're in,

00:21:00.466 --> 00:21:01.956 A:middle
which is the BeamFiringState.

00:21:02.016 --> 00:21:04.436 A:middle
And in gray, we see all
of the additional states

00:21:04.436 --> 00:21:05.916 A:middle
that comprise our state machine.

00:21:06.836 --> 00:21:09.486 A:middle
Now we also see the transitions
between each of the states.

00:21:09.646 --> 00:21:11.346 A:middle
And one thing that I've
immediately noticed is

00:21:11.346 --> 00:21:12.876 A:middle
that we have a number
of transitions

00:21:12.876 --> 00:21:16.206 A:middle
into our BeamFiringState but we
have no transitions out of it.

00:21:16.206 --> 00:21:18.736 A:middle
So this means, as soon as we
get into our firing state,

00:21:18.736 --> 00:21:19.886 A:middle
we have no way of leaving it.

00:21:20.186 --> 00:21:22.856 A:middle
So let's go ahead and take a
look at our BeamFiringState

00:21:22.856 --> 00:21:23.876 A:middle
to see what's going on here.

00:21:24.406 --> 00:21:27.766 A:middle
So I'll remove our breakpoint
and close our debug area

00:21:27.866 --> 00:21:29.506 A:middle
and switch to our
BeamFiringState.

00:21:30.246 --> 00:21:33.256 A:middle
Now we'll take a look
at the update loop.

00:21:33.256 --> 00:21:36.246 A:middle
And I see here we have some
logic to transition both

00:21:36.246 --> 00:21:38.666 A:middle
into the CoolingState as
well as the IdleState.

00:21:39.586 --> 00:21:40.806 A:middle
But down here in our method

00:21:40.806 --> 00:21:42.896 A:middle
where we're checking whether the
state we're trying to transition

00:21:42.896 --> 00:21:45.806 A:middle
to is valid, we're
always returning false,

00:21:45.946 --> 00:21:48.056 A:middle
which shouldn't be the case
because we want to transition

00:21:48.056 --> 00:21:49.256 A:middle
to either cooling or idle.

00:21:50.256 --> 00:21:52.656 A:middle
So I'll go ahead and fix that by
checking whether the state we're

00:21:52.656 --> 00:21:55.466 A:middle
trying to transition to is
either of the two valid ones.

00:21:55.886 --> 00:21:57.296 A:middle
And we'll go ahead
and rerun our game

00:21:57.336 --> 00:21:58.876 A:middle
and check whether this
has addressed the issue

00:21:58.876 --> 00:21:59.556 A:middle
that we were seeing.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.816 --> 00:22:02.866 A:middle
Now when we transition
to the FiringState

00:22:02.866 --> 00:22:05.856 A:middle
and meet the conditions to exit
it, we should properly be able

00:22:05.856 --> 00:22:07.886 A:middle
to transition back
into our IdleState.

00:22:09.236 --> 00:22:12.566 A:middle
So I'll jump back into the
game and go ahead and fire

00:22:12.566 --> 00:22:15.776 A:middle
at the corrupted robot to
convert him into a good one.

00:22:16.186 --> 00:22:19.996 A:middle
And we'll see the beam is no
longer present above our player,

00:22:20.116 --> 00:22:21.706 A:middle
so it looks like we've
addressed the issue.

00:22:22.526 --> 00:22:24.936 A:middle
So now we've also noticed
a performance issue

00:22:24.936 --> 00:22:26.086 A:middle
within our game.

00:22:26.086 --> 00:22:28.686 A:middle
We have a number of ground
robots here on the bottom.

00:22:28.686 --> 00:22:30.836 A:middle
And I notice that when
we get attacked by them,

00:22:31.096 --> 00:22:32.906 A:middle
our performance drops
dramatically.

00:22:33.966 --> 00:22:35.896 A:middle
So I'll switch to our
FPS performance gauge

00:22:35.896 --> 00:22:38.426 A:middle
so that we can see our
performance live while

00:22:38.426 --> 00:22:39.116 A:middle
we're running.

00:22:39.746 --> 00:22:41.406 A:middle
And you can see on the
right here we indicate

00:22:41.406 --> 00:22:43.016 A:middle
to you your target frame time.

00:22:43.346 --> 00:22:47.006 A:middle
And in our case, it's 16.6
milliseconds, which corresponds

00:22:47.006 --> 00:22:49.376 A:middle
to maintaining a frame rate
of 60 frames per second.

00:22:50.306 --> 00:22:52.226 A:middle
We can also see that
a good amount

00:22:52.226 --> 00:22:53.796 A:middle
of our time is spent rendering,

00:22:53.796 --> 00:22:55.506 A:middle
as well as running
our client update,

00:22:55.856 --> 00:22:58.426 A:middle
and we've got a good amount of
wiggle room of CPU idle time.

00:22:58.986 --> 00:23:02.236 A:middle
So I'll go into our game
and move to the right here


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.986 --> 00:23:02.236 A:middle
So I'll go into our game
and move to the right here

00:23:02.236 --> 00:23:04.996 A:middle
where we have an enemy robot,
and I'll let him hit me

00:23:04.996 --> 00:23:07.036 A:middle
so that we can try to reproduce
this performance issue.

00:23:07.286 --> 00:23:09.996 A:middle
So now I'll switch back
to our performance gauge

00:23:09.996 --> 00:23:11.806 A:middle
to see what's going on
within our update loop.

00:23:12.386 --> 00:23:13.706 A:middle
And I'm noticing
that quite a bit

00:23:13.706 --> 00:23:15.536 A:middle
of time is spent
evaluating actions.

00:23:15.536 --> 00:23:18.196 A:middle
In fact, now our frame rate is
dropping quite dramatically.

00:23:18.976 --> 00:23:20.516 A:middle
So I'll go ahead
and pause our app

00:23:20.516 --> 00:23:22.616 A:middle
so that we can take a closer
look at what's going on.

00:23:23.306 --> 00:23:26.446 A:middle
Now that we're paused, I
can scroll back in time

00:23:26.446 --> 00:23:27.956 A:middle
within our frame breakdown

00:23:27.956 --> 00:23:30.316 A:middle
to see our frame time
previously within our app.

00:23:30.776 --> 00:23:32.356 A:middle
In fact, here we can see
the time that we were

00:23:32.356 --> 00:23:35.246 A:middle
in the main menu where we spent
a little bit of time rendering

00:23:35.246 --> 00:23:36.566 A:middle
but most of it was spent idle,

00:23:36.596 --> 00:23:39.056 A:middle
as well as the breakdown we
were seeing within our game.

00:23:39.666 --> 00:23:42.406 A:middle
And now when we are seeing
performance issues, I can click

00:23:42.406 --> 00:23:44.246 A:middle
and hold to examine details

00:23:44.246 --> 00:23:46.676 A:middle
for the performance
issue we were seeing.

00:23:47.306 --> 00:23:51.286 A:middle
Here, I see we're getting
36.2 millisecond frame time,

00:23:51.286 --> 00:23:54.676 A:middle
and 71% of that is spent
evaluating actions.

00:23:54.676 --> 00:23:57.196 A:middle
So what that tells me
is there may be one

00:23:57.196 --> 00:23:58.906 A:middle
of two issues present
within our game.

00:23:59.526 --> 00:24:00.746 A:middle
We could have a single action


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.526 --> 00:24:00.746 A:middle
We could have a single action

00:24:00.746 --> 00:24:03.426 A:middle
within our scene that's taking
an exceedingly large amount

00:24:03.426 --> 00:24:05.926 A:middle
of time to evaluate, or we
could have a large number

00:24:05.926 --> 00:24:08.026 A:middle
of actions that's
bottlenecking our update loop.

00:24:08.226 --> 00:24:12.306 A:middle
So now I know where within our
update loop we're having issues.

00:24:15.816 --> 00:24:18.276 A:middle
So we've seen how we can use
the State Machine Quick Look

00:24:18.336 --> 00:24:20.696 A:middle
to debug an issue we were
seeing within our game,

00:24:21.046 --> 00:24:23.206 A:middle
as well as how the FPS
performance gauge can show us

00:24:23.206 --> 00:24:25.936 A:middle
where exactly within our update
loop we're having issues.

00:24:26.856 --> 00:24:28.756 A:middle
I'd like to now invite
up Daniel Delwood

00:24:28.756 --> 00:24:31.686 A:middle
who will show you a new memory
graph debugger that we can use

00:24:31.686 --> 00:24:34.336 A:middle
to determine where our issue
with actions originates

00:24:34.336 --> 00:24:35.866 A:middle
from so we can fix it.

00:24:36.516 --> 00:24:42.966 A:middle
[ Applause ]

00:24:43.466 --> 00:24:43.986 A:middle
&gt;&gt; Thank you, Tyler.

00:24:45.066 --> 00:24:46.216 A:middle
So I'm very excited to tell you

00:24:46.216 --> 00:24:48.536 A:middle
about the new memory
graph debugger in Xcode 8.

00:24:48.846 --> 00:24:51.466 A:middle
And like the view debugger,

00:24:51.696 --> 00:24:54.036 A:middle
it's a tool for understanding
your applications better.

00:24:54.186 --> 00:24:57.216 A:middle
So just as the view debugger
understands your view hierarchy,

00:24:57.216 --> 00:25:00.496 A:middle
the memory graph debugger helps
you understand your memory


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.216 --> 00:25:00.496 A:middle
the memory graph debugger helps
you understand your memory

00:25:00.496 --> 00:25:02.006 A:middle
and how it's referencing
each other.

00:25:02.576 --> 00:25:05.976 A:middle
The core question though that
it's trying to answer is -

00:25:06.396 --> 00:25:09.126 A:middle
why does a certain object
still exist on your heap?

00:25:10.096 --> 00:25:12.296 A:middle
Now objects reference
each other.

00:25:12.296 --> 00:25:16.726 A:middle
And, you know, this is more and
more a question of references

00:25:16.726 --> 00:25:17.956 A:middle
and annotation these days

00:25:18.306 --> 00:25:19.896 A:middle
in an automatic
reference-guiding world.

00:25:20.686 --> 00:25:24.936 A:middle
So where can we go from
having this problem of objects

00:25:24.936 --> 00:25:27.356 A:middle
that we don't want, objects
that are leaked, or abandoned?

00:25:28.266 --> 00:25:29.346 A:middle
Well, there's some
command-line tools

00:25:29.346 --> 00:25:31.466 A:middle
that can help, such as Heap.

00:25:32.146 --> 00:25:34.916 A:middle
And what Heap does is it
snapshots your process,

00:25:35.256 --> 00:25:37.876 A:middle
looks through it for a
summary of the different types

00:25:37.946 --> 00:25:41.256 A:middle
and the counts of objects
that are in your process.

00:25:41.256 --> 00:25:43.816 A:middle
And you can even use the
"addresses" flag to look

00:25:43.816 --> 00:25:45.706 A:middle
for a specific type of object

00:25:45.706 --> 00:25:47.806 A:middle
and get a list of
those instances.

00:25:48.366 --> 00:25:50.736 A:middle
Once you have an instance
you're interested in,

00:25:51.316 --> 00:25:53.366 A:middle
leaks is where you go
for the connectivity kind

00:25:53.366 --> 00:25:55.746 A:middle
of information of, well,
is it unreferenced?

00:25:55.746 --> 00:25:56.346 A:middle
Is it leaked?

00:25:56.846 --> 00:25:59.956 A:middle
Or is there some path
from a global location

00:25:59.996 --> 00:26:03.906 A:middle
in your application that goes
all the way down to your object?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.996 --> 00:26:03.906 A:middle
in your application that goes
all the way down to your object?

00:26:05.136 --> 00:26:07.156 A:middle
Now, at any point in
this investigation,

00:26:07.156 --> 00:26:08.946 A:middle
you might need some
further detail,

00:26:08.946 --> 00:26:10.496 A:middle
such as the allocation
stack trace.

00:26:10.856 --> 00:26:12.176 A:middle
And, that, you can get
with malloc-history.

00:26:12.986 --> 00:26:15.586 A:middle
And this is all not a
very visual experience,

00:26:15.586 --> 00:26:18.006 A:middle
and that's why we pulled all of
these three tools into the IDE

00:26:18.006 --> 00:26:20.066 A:middle
for the memory graph debugger.

00:26:20.066 --> 00:26:24.146 A:middle
And so just a quick overview of,
you know, how this is laid out.

00:26:24.646 --> 00:26:26.986 A:middle
On the left, the Navigator is
where you get that heap-type

00:26:26.986 --> 00:26:29.306 A:middle
of information to
start your analysis.

00:26:30.036 --> 00:26:31.476 A:middle
The center editor area is

00:26:31.476 --> 00:26:33.786 A:middle
where the connectivity
information gets presented.

00:26:34.406 --> 00:26:37.526 A:middle
And on the right -- that's
what we're showing you now --

00:26:37.606 --> 00:26:40.446 A:middle
the allocation stack
trace via the Inspector.

00:26:40.976 --> 00:26:43.396 A:middle
So with that, I'd just like to
jump right back into the demo

00:26:44.156 --> 00:26:46.646 A:middle
where Tyler left off and
see if we can take a look

00:26:46.646 --> 00:26:48.466 A:middle
at those action problems
that he was seeing.

00:26:48.916 --> 00:26:49.306 A:middle
All right.

00:26:49.506 --> 00:26:55.456 A:middle
So here we are with the FPS
performance gauge, looking at,

00:26:55.696 --> 00:26:57.236 A:middle
you know, actions
that are probably

00:26:57.236 --> 00:26:59.576 A:middle
at fault here in
our application.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:00.036 --> 00:27:01.446 A:middle
So I'm just going to jump right

00:27:01.446 --> 00:27:04.646 A:middle
in by choosing the Memory
Graph Debugger button

00:27:05.136 --> 00:27:07.506 A:middle
in the Debug Menu Bar.

00:27:08.136 --> 00:27:09.806 A:middle
And on the left here,

00:27:10.006 --> 00:27:14.386 A:middle
the Navigator shows me
my application with all

00:27:14.386 --> 00:27:17.086 A:middle
of the different types
that are allocated in it.

00:27:17.316 --> 00:27:20.206 A:middle
And so they're broken
down by a hierarchy

00:27:20.206 --> 00:27:21.896 A:middle
of module and then type.

00:27:21.896 --> 00:27:24.256 A:middle
And then under each of
these, there's an instance.

00:27:25.136 --> 00:27:28.266 A:middle
And so, in this case, I'm kind

00:27:28.266 --> 00:27:30.056 A:middle
of interested in
searching my heap.

00:27:30.256 --> 00:27:31.386 A:middle
And it's very easy to do.

00:27:31.386 --> 00:27:34.616 A:middle
I can just type into the filter,
and I'll look for actions.

00:27:35.906 --> 00:27:36.976 A:middle
So here we are.

00:27:37.036 --> 00:27:38.946 A:middle
We've got types in SpriteKit.

00:27:38.946 --> 00:27:42.846 A:middle
And we see that, yeah, we
have a lot of actions -- 559.

00:27:43.336 --> 00:27:46.296 A:middle
So it's probably that we
have too many actions and not

00:27:46.296 --> 00:27:49.086 A:middle
that we have some
long-running single actions.

00:27:50.776 --> 00:27:52.666 A:middle
So let me select one
of these objects.

00:27:53.116 --> 00:27:57.566 A:middle
And the editor changes to show
me the answer to the question

00:27:57.566 --> 00:27:59.696 A:middle
of why this object
is still around.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:00.116 --> 00:28:02.296 A:middle
In this case, it's showing
me a root analysis graph

00:28:02.296 --> 00:28:07.146 A:middle
which allows me to trace the
object I've selected back

00:28:07.186 --> 00:28:09.416 A:middle
to the left, back to the
roots of my application.

00:28:09.946 --> 00:28:11.316 A:middle
So I can see that
it's referenced

00:28:11.316 --> 00:28:14.136 A:middle
by an SKC sequence by repeat.

00:28:14.196 --> 00:28:15.776 A:middle
There's an array
holding onto this.

00:28:15.876 --> 00:28:19.346 A:middle
And I can even disclose
further to see

00:28:19.346 --> 00:28:22.046 A:middle
that here we've got an
SKNode with some actions.

00:28:22.356 --> 00:28:25.086 A:middle
So, OK, it's part of
this SKNode actions list.

00:28:25.516 --> 00:28:29.346 A:middle
I can click on this and
try Quick Looking it.

00:28:29.346 --> 00:28:33.886 A:middle
If I want to take some
more looks at this action,

00:28:34.316 --> 00:28:37.056 A:middle
I can select it and
pull in the Inspector.

00:28:38.186 --> 00:28:41.036 A:middle
Now the Inspector shows
me some memory details,

00:28:41.036 --> 00:28:44.746 A:middle
such as the class name,
the address, the hierarchy

00:28:44.746 --> 00:28:47.786 A:middle
if it is a sub-class
of some other objects.

00:28:48.306 --> 00:28:50.736 A:middle
What I'm interested in is
where this action was created

00:28:50.736 --> 00:28:51.976 A:middle
so I can jump to there.

00:28:52.446 --> 00:28:57.876 A:middle
I can go ahead and collapse this
stack trace and jump to my code.

00:28:58.016 --> 00:29:02.036 A:middle
And here, we see I've got this
function -- refreshHurtAction.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.016 --> 00:29:02.036 A:middle
And here, we see I've got this
function -- refreshHurtAction.

00:29:03.066 --> 00:29:06.166 A:middle
All right, so it's
running a HurtAction.

00:29:06.346 --> 00:29:11.696 A:middle
I can use the Quick Help to
see that this action is added

00:29:11.696 --> 00:29:13.986 A:middle
to the list of actions
on the node.

00:29:14.816 --> 00:29:18.616 A:middle
But I actually wanted to only
have a single-player action

00:29:18.616 --> 00:29:20.916 A:middle
and make sure that this was
replacing my previous actions.

00:29:21.376 --> 00:29:22.676 A:middle
So it's a pretty simple fix.

00:29:22.676 --> 00:29:25.406 A:middle
I'm just going to use
the withKey variant here

00:29:25.506 --> 00:29:27.886 A:middle
and replace the player action.

00:29:28.526 --> 00:29:33.206 A:middle
And the Quick Help
will show me that, yes,

00:29:33.286 --> 00:29:35.036 A:middle
this is actually the
one I was wanting.

00:29:35.166 --> 00:29:37.296 A:middle
If an action using the same
key is already running,

00:29:37.296 --> 00:29:38.766 A:middle
it is removed before
the action is added.

00:29:39.066 --> 00:29:44.926 A:middle
Great. So that's a pretty simple
way to jump to an investigation

00:29:44.926 --> 00:29:46.286 A:middle
about a specific type.

00:29:46.346 --> 00:29:48.006 A:middle
But one of the other
things I noticed

00:29:48.006 --> 00:29:51.106 A:middle
when I hit the Memory
Graph Debugging button is

00:29:51.106 --> 00:29:54.416 A:middle
that the Runtime Issues
Navigator alerted me

00:29:54.416 --> 00:29:55.116 A:middle
to some issues.

00:29:55.376 --> 00:29:56.606 A:middle
So I can click on that.

00:29:56.606 --> 00:30:00.336 A:middle
And now I'm taken to the
new Runtime Issues Navigator


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:56.606 --> 00:30:00.336 A:middle
And now I'm taken to the
new Runtime Issues Navigator

00:30:00.926 --> 00:30:04.226 A:middle
which has a bunch of leaks that
were reported in my application.

00:30:05.256 --> 00:30:09.226 A:middle
So I'll start out with a type
that is defined in my module --

00:30:09.336 --> 00:30:11.266 A:middle
say, this LoadSceneOperation.

00:30:12.626 --> 00:30:15.096 A:middle
If I select it, now the
graph isn't showing me

00:30:15.096 --> 00:30:16.166 A:middle
that same style.

00:30:16.396 --> 00:30:18.666 A:middle
It's showing me a
reference cycle,

00:30:19.296 --> 00:30:22.006 A:middle
which is because this
is a leaked object.

00:30:22.006 --> 00:30:25.166 A:middle
It's not reachable from those
locations in my application.

00:30:25.426 --> 00:30:28.116 A:middle
And I need to find
out what objects

00:30:28.186 --> 00:30:30.806 A:middle
in the leaked set are
referencing each other.

00:30:31.846 --> 00:30:35.546 A:middle
So looking at this
quickly, I have an operation

00:30:35.546 --> 00:30:36.876 A:middle
with some internal state.

00:30:37.156 --> 00:30:39.186 A:middle
It's referencing a
completion block.

00:30:39.676 --> 00:30:44.026 A:middle
And then this has some
captures as part of that block

00:30:44.086 --> 00:30:46.196 A:middle
that strongly referenced
my LoadSceneOperation.

00:30:46.746 --> 00:30:47.086 A:middle
Interesting.

00:30:48.366 --> 00:30:51.546 A:middle
So if I click on the block,
I can see the back trace

00:30:51.546 --> 00:30:54.686 A:middle
and go immediately there.

00:30:54.916 --> 00:30:56.706 A:middle
And here we are --

00:30:56.706 --> 00:30:58.596 A:middle
my LoadSceneOperation
completion block.

00:30:58.596 --> 00:31:01.516 A:middle
I'm even using a capture
list for "unowned self".


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.596 --> 00:31:01.516 A:middle
I'm even using a capture
list for "unowned self".

00:31:02.096 --> 00:31:04.756 A:middle
But the graph showed me that
"self" wasn't the problem.

00:31:04.756 --> 00:31:08.806 A:middle
It was the LoadSceneOperation
capturing itself right there

00:31:09.036 --> 00:31:09.836 A:middle
within the block.

00:31:11.536 --> 00:31:13.486 A:middle
So it's a pretty
easy fix to make.

00:31:13.736 --> 00:31:17.466 A:middle
I just need to capture
it unowned

00:31:18.296 --> 00:31:21.826 A:middle
and I can get going again.

00:31:23.296 --> 00:31:26.626 A:middle
But, unfortunately, that's
not quite the solution here.

00:31:27.056 --> 00:31:28.756 A:middle
Because, since it's
a completion block,

00:31:28.756 --> 00:31:31.166 A:middle
my LoadSceneOperation
is just about done.

00:31:31.616 --> 00:31:33.836 A:middle
And so once it executes
this block here,

00:31:34.266 --> 00:31:36.816 A:middle
the LoadSceneOperation is
going to end its lifecycle

00:31:36.956 --> 00:31:38.556 A:middle
and it won't be around
for much longer.

00:31:39.036 --> 00:31:41.366 A:middle
This means that when I dispatch
async back to the main queue,

00:31:42.616 --> 00:31:45.106 A:middle
this LoadSceneOperation
may no longer be valid

00:31:45.106 --> 00:31:46.066 A:middle
and I'm going to get a crash.

00:31:46.876 --> 00:31:50.466 A:middle
So it just goes to show that
these captures can be tricky

00:31:50.466 --> 00:31:54.266 A:middle
at times and require a
little bit of investigation.

00:31:54.636 --> 00:31:57.166 A:middle
And hopefully the memory
graph debugger will help you

00:31:57.736 --> 00:31:58.836 A:middle
in your investigations as well.

00:31:59.516 --> 00:32:05.996 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.516 --> 00:32:05.996 A:middle
[ Applause ]

00:32:06.496 --> 00:32:08.436 A:middle
So, let's talk a little bit more

00:32:08.436 --> 00:32:10.936 A:middle
about leaked and
abandoned memory.

00:32:11.146 --> 00:32:15.606 A:middle
The memory graph debugger is a
debugger mode, and so it pauses

00:32:15.606 --> 00:32:17.466 A:middle
to inspect your target
application.

00:32:17.826 --> 00:32:19.526 A:middle
This is so your application
doesn't keep going

00:32:19.526 --> 00:32:22.026 A:middle
and changing its state, and
you can get a consistent view

00:32:22.026 --> 00:32:22.586 A:middle
of the world.

00:32:22.986 --> 00:32:24.696 A:middle
It also lets you do
things like Quick Look

00:32:24.696 --> 00:32:27.686 A:middle
or PO different objects as you
go through your investigation,

00:32:27.776 --> 00:32:30.226 A:middle
and it's available on
all of our platforms.

00:32:31.146 --> 00:32:32.516 A:middle
Now, as I showed in the demo,

00:32:32.516 --> 00:32:33.596 A:middle
there's two different
graph styles.

00:32:34.136 --> 00:32:37.266 A:middle
And the first one is that
root paths graph style

00:32:37.646 --> 00:32:39.276 A:middle
which shows you for
referenced memory --

00:32:39.566 --> 00:32:40.496 A:middle
maybe you've abandoned it --

00:32:41.116 --> 00:32:45.416 A:middle
how are different roots in
your application like globals

00:32:45.456 --> 00:32:47.806 A:middle
and currently-running threads
referencing that memory.

00:32:48.606 --> 00:32:50.286 A:middle
Now with the progressive
disclosure model,

00:32:50.286 --> 00:32:52.506 A:middle
it lets you work back
from your objecst

00:32:52.636 --> 00:32:55.846 A:middle
to different intermediate
objects and find the reference

00:32:55.926 --> 00:32:57.356 A:middle
that should no longer be there.

00:32:58.466 --> 00:33:00.806 A:middle
For unreferenced
memory or leaked memory,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.466 --> 00:33:00.806 A:middle
For unreferenced
memory or leaked memory,

00:33:01.196 --> 00:33:02.586 A:middle
that's when you see
the cycles view.

00:33:02.896 --> 00:33:07.716 A:middle
And the goal there is to help
show you what is strongly

00:33:07.716 --> 00:33:09.146 A:middle
referencing itself.

00:33:09.146 --> 00:33:11.986 A:middle
And it'll let you figure out,
again, a reference problem.

00:33:13.826 --> 00:33:17.156 A:middle
So, for stack logging
integration that you saw

00:33:17.156 --> 00:33:22.486 A:middle
in the Inspector, it's not
quite free to record all

00:33:22.486 --> 00:33:24.356 A:middle
of the mallocs and frees
in your application.

00:33:24.606 --> 00:33:26.916 A:middle
And so this is a diagnostic
that you'll need to opt into.

00:33:27.706 --> 00:33:32.036 A:middle
Just going to the Scheme Editor
and selecting MallocStackLogging

00:33:32.036 --> 00:33:34.906 A:middle
in the Diagnostics Tab
is enough to enable it.

00:33:34.906 --> 00:33:38.006 A:middle
And it will record, again, all
of the mallocs and frees to disk

00:33:38.286 --> 00:33:39.596 A:middle
so you can look them up later.

00:33:40.626 --> 00:33:43.576 A:middle
But for memory graph debugging,
you don't really need all

00:33:43.576 --> 00:33:44.766 A:middle
of the malloc and frees.

00:33:44.766 --> 00:33:46.306 A:middle
And previous lifetimes

00:33:46.306 --> 00:33:49.336 A:middle
of a malloc block just
aren't usually that useful.

00:33:49.886 --> 00:33:56.206 A:middle
So, new in our current OSs is
a Live Allocations Only Mode.

00:33:56.246 --> 00:34:00.986 A:middle
And so this has a lower
overhead, and it also allows you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:56.246 --> 00:34:00.986 A:middle
And so this has a lower
overhead, and it also allows you

00:34:01.056 --> 00:34:03.616 A:middle
to get this rich information
while you're memory

00:34:03.616 --> 00:34:04.226 A:middle
graph debugging.

00:34:04.736 --> 00:34:09.116 A:middle
So this will set the "lite"
flag to MallocStackLogging

00:34:09.525 --> 00:34:10.985 A:middle
in target environment.

00:34:13.436 --> 00:34:17.005 A:middle
So one other thing
that you may enjoy

00:34:17.005 --> 00:34:18.906 A:middle
about memory graph debugging is

00:34:18.956 --> 00:34:21.386 A:middle
that we've introduced a
.memgraph file format.

00:34:21.876 --> 00:34:24.005 A:middle
Now, sometimes you'll
be debugging an issue

00:34:24.005 --> 00:34:26.956 A:middle
and you won't have the time
to really dive into it.

00:34:27.326 --> 00:34:30.056 A:middle
And so you may want to save
this off or have other engineers

00:34:30.056 --> 00:34:31.545 A:middle
on your team take
a look as well.

00:34:31.826 --> 00:34:35.116 A:middle
So, from Xcode, you can
actually go to the File menu

00:34:35.286 --> 00:34:37.376 A:middle
and select Export Memory Graph.

00:34:37.806 --> 00:34:39.406 A:middle
And what it'll do
is save out all

00:34:39.406 --> 00:34:41.786 A:middle
of the connectivity information
and heap information,

00:34:42.005 --> 00:34:43.496 A:middle
as well as some VM statistics

00:34:43.496 --> 00:34:45.686 A:middle
about your application
to a file.

00:34:45.956 --> 00:34:47.976 A:middle
Then at some later time,
you can just double-click,

00:34:48.116 --> 00:34:52.366 A:middle
load that file in the Xcode, and
take a look at the memory graph.

00:34:53.056 --> 00:34:55.216 A:middle
Now this does mean that there's
no process in the debugger.

00:34:55.216 --> 00:34:59.326 A:middle
So you can't get back traces,
or Quick Look or PO the objects.

00:34:59.326 --> 00:35:00.996 A:middle
But it's still a very
powerful technique


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.326 --> 00:35:00.996 A:middle
But it's still a very
powerful technique

00:35:00.996 --> 00:35:03.506 A:middle
for analyzing
after the fact.

00:35:04.736 --> 00:35:06.466 A:middle
Now if you want to build this

00:35:06.466 --> 00:35:08.576 A:middle
into your continuous
integration,

00:35:09.546 --> 00:35:11.656 A:middle
we've actually got some
options from the command line.

00:35:12.366 --> 00:35:16.216 A:middle
So you can just run
leaks-outputGraph, pick a path,

00:35:16.516 --> 00:35:18.826 A:middle
and save out a .memgraph
file for later.

00:35:20.106 --> 00:35:23.896 A:middle
So leaks, vmmap, and heap have
all been enhanced to read this.

00:35:24.516 --> 00:35:31.006 A:middle
[ Applause ]

00:35:31.506 --> 00:35:33.346 A:middle
All right, now the fun part.

00:35:33.346 --> 00:35:36.006 A:middle
Let's talk about some usage tips
here because this is all built

00:35:36.006 --> 00:35:37.786 A:middle
on the leaks infrastructure.

00:35:38.446 --> 00:35:40.526 A:middle
Now what this means is
the graph is conservative.

00:35:41.286 --> 00:35:45.356 A:middle
We're trying very, very
hard not to report things

00:35:45.356 --> 00:35:46.366 A:middle
as leaked when they're not.

00:35:46.366 --> 00:35:50.266 A:middle
And so in that attempt
to avoid false positives,

00:35:51.026 --> 00:35:52.566 A:middle
there may be some
extraneous references

00:35:52.606 --> 00:35:53.476 A:middle
that you see in the graph.

00:35:54.486 --> 00:35:59.136 A:middle
Now these references will show
up gray for being unknown.

00:35:59.206 --> 00:36:01.156 A:middle
They may be valid
references, they may not.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.206 --> 00:36:01.156 A:middle
They may be valid
references, they may not.

00:36:01.476 --> 00:36:04.456 A:middle
We may not just have metadata
available to the tool.

00:36:04.846 --> 00:36:08.986 A:middle
And so take them
with a grain of salt

00:36:08.986 --> 00:36:10.276 A:middle
as you're reading these graphs.

00:36:10.786 --> 00:36:13.486 A:middle
Now one thing you can do
to improve the accuracy is

00:36:13.486 --> 00:36:14.456 A:middle
to enable Malloc Scribble,

00:36:14.586 --> 00:36:16.926 A:middle
which is another
diagnostic in this scheme.

00:36:17.406 --> 00:36:20.456 A:middle
And this will mean that
on allocation or free,

00:36:20.816 --> 00:36:23.716 A:middle
it will write over the
memory so that you don't have

00:36:23.976 --> 00:36:27.766 A:middle
that uninitialized
memory in that new block.

00:36:29.156 --> 00:36:32.146 A:middle
So for references that are known
to be strong, these will show

00:36:32.146 --> 00:36:33.526 A:middle
up as bold in the graph.

00:36:33.626 --> 00:36:37.736 A:middle
And Swift 3 actually has
a lot more reflection

00:36:37.736 --> 00:36:39.206 A:middle
metadata available.

00:36:39.686 --> 00:36:43.896 A:middle
And so I encourage
you to use this

00:36:43.996 --> 00:36:47.436 A:middle
because it definitely is a
lot more accurate in terms

00:36:47.436 --> 00:36:49.566 A:middle
of understanding
captures and references.

00:36:50.616 --> 00:36:51.986 A:middle
And finally, I should put

00:36:51.986 --> 00:36:53.636 A:middle
out that the memory
graph debugger requires

00:36:53.636 --> 00:36:55.736 A:middle
that you temporarily
turn off sanitizers

00:36:55.886 --> 00:36:58.426 A:middle
like Address Sanitizer
or Thread Sanitizer.

00:36:59.716 --> 00:37:01.516 A:middle
So this is a lot of information.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.716 --> 00:37:01.516 A:middle
So this is a lot of information.

00:37:02.316 --> 00:37:04.386 A:middle
Where is a great place to get
started with your application?

00:37:05.186 --> 00:37:07.146 A:middle
Well, validate your
expectations.

00:37:07.326 --> 00:37:10.676 A:middle
Are there more objects of a
certain type than you expect?

00:37:11.266 --> 00:37:13.896 A:middle
Are objects being
deallocated when you expect?

00:37:14.506 --> 00:37:18.016 A:middle
Are there any leaks
in your types as well?

00:37:18.766 --> 00:37:20.546 A:middle
Once you find an object
that you're interested

00:37:20.546 --> 00:37:23.176 A:middle
in investigating, then
the goal is to find a path

00:37:23.506 --> 00:37:25.646 A:middle
that shouldn't be there
holding onto your object.

00:37:26.166 --> 00:37:29.076 A:middle
And two very common patterns

00:37:29.076 --> 00:37:32.036 A:middle
that you'll find are
strong captures from blocks

00:37:32.036 --> 00:37:37.396 A:middle
and closures, or potentially
even references upward

00:37:37.436 --> 00:37:41.246 A:middle
in your graph that need to be
marked as "weak" or "unowned".

00:37:42.496 --> 00:37:45.426 A:middle
So, that's a lot of information.

00:37:46.056 --> 00:37:50.886 A:middle
But I just want to thank
you very much for listening

00:37:50.886 --> 00:37:52.266 A:middle
to our information about new

00:37:52.266 --> 00:37:54.746 A:middle
and improved visual
tools in Xcode 8.

00:37:54.926 --> 00:37:56.256 A:middle
We're really excited
about things

00:37:56.306 --> 00:38:00.146 A:middle
like the better visual debugging
with the view debugger,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:56.306 --> 00:38:00.146 A:middle
like the better visual debugging
with the view debugger,

00:38:00.416 --> 00:38:03.746 A:middle
with FPS gauge, and
memory graph debugging.

00:38:04.126 --> 00:38:06.736 A:middle
So go out, try them
out in your app today,

00:38:06.736 --> 00:38:08.396 A:middle
and solve a lot of issues.

00:38:09.516 --> 00:38:12.500 A:middle
[ Applause ]

