WEBVTT

00:00:07.516 --> 00:00:17.500 A:middle
[ Music ]

00:00:22.616 --> 00:00:23.686 A:middle
&gt;&gt; Good morning.

00:00:29.216 --> 00:00:31.776 A:middle
Welcome to Leveraging
Touch Input on iOS.

00:00:32.076 --> 00:00:34.286 A:middle
My name is Dominik
Wagner, and I'm an engineer

00:00:34.286 --> 00:00:36.566 A:middle
on the UIKit Team,
and I will tell you

00:00:36.566 --> 00:00:39.336 A:middle
about how you can make the
most out of our advances

00:00:39.336 --> 00:00:42.016 A:middle
in Multi-Touch and
of Apple Pencil.

00:00:42.916 --> 00:00:46.136 A:middle
First, let's go over our new
and recent hardware releases.

00:00:46.136 --> 00:00:50.406 A:middle
Since last WWDC, we
released a lot of stuff.

00:00:50.916 --> 00:00:54.776 A:middle
For example, 3D Touch with
the iPhone 6s and 6s plus,

00:00:55.106 --> 00:00:57.736 A:middle
which gives you access to
the force for each touch.

00:00:58.636 --> 00:01:00.356 A:middle
I won't talk much about this,

00:00:58.636 --> 00:01:00.356 A:middle
I won't talk much about this,

00:01:00.616 --> 00:01:05.046 A:middle
but you can have all the great
experience for Peek and Pop

00:01:05.536 --> 00:01:07.906 A:middle
in the session at A Peek
at 3D Touch later today.

00:01:09.466 --> 00:01:11.576 A:middle
We introduced faster
touch scanning beginning

00:01:11.576 --> 00:01:13.396 A:middle
with iPad Air 2 and iPad Pro,

00:01:13.396 --> 00:01:15.006 A:middle
giving you a temporary
resolution

00:01:15.006 --> 00:01:16.946 A:middle
of twice the refresh
[inaudible] display.

00:01:18.166 --> 00:01:21.296 A:middle
We also introduced Apple
Pencil for Apple iPad Pro,

00:01:21.786 --> 00:01:26.776 A:middle
and this amazing device, thank
you, gives you precise location

00:01:26.856 --> 00:01:28.856 A:middle
at a [inaudible] accuracy
for your drawings.

00:01:29.596 --> 00:01:33.136 A:middle
It has an even higher temporary
resolution of 240 hertz.

00:01:34.926 --> 00:01:38.086 A:middle
It gives you access to its
tilt and orientation, and,

00:01:38.086 --> 00:01:39.716 A:middle
of course, all the force.

00:01:41.046 --> 00:01:44.866 A:middle
And our algorithms team did an
amazing job of palm rejection.

00:01:45.236 --> 00:01:47.886 A:middle
So you can rest your palm
while you are drawing

00:01:47.886 --> 00:01:50.346 A:middle
and don't have to
think about it.

00:01:50.836 --> 00:01:53.706 A:middle
We also released Apple
TV with the Siri remote,

00:01:54.926 --> 00:01:58.116 A:middle
and its track mainly
drives the UIFocusEngine

00:01:58.116 --> 00:02:00.056 A:middle
and your interactions
with Apple TV.

00:01:58.116 --> 00:02:00.056 A:middle
and your interactions
with Apple TV.

00:02:00.786 --> 00:02:03.156 A:middle
But you can also access the
track pad using the Game

00:02:03.156 --> 00:02:07.066 A:middle
Controller framework for both
acting as a Game Controller

00:02:07.216 --> 00:02:10.295 A:middle
or also getting the absolute
position of the track pad.

00:02:10.866 --> 00:02:14.476 A:middle
And, finally, you can
also handle the track pad

00:02:14.476 --> 00:02:17.976 A:middle
in indirect touches in our
UIKit touch handling methods.

00:02:18.546 --> 00:02:20.666 A:middle
I won't talk much
about this either,

00:02:20.666 --> 00:02:22.876 A:middle
but there are the great
Apple TV tech talks,

00:02:23.206 --> 00:02:28.036 A:middle
and there's also Game Controller
Input for Apple TV yesterday.

00:02:28.956 --> 00:02:30.466 A:middle
What am I going to talk about?

00:02:30.766 --> 00:02:33.526 A:middle
I'm going to talk about how
you build a drawing app.

00:02:34.346 --> 00:02:37.886 A:middle
We will build a drawing app from
the ground up, and I will talk

00:02:37.886 --> 00:02:40.246 A:middle
about all the new
API for Apple Pencil

00:02:40.246 --> 00:02:42.886 A:middle
so you can access all
these great new data.

00:02:43.706 --> 00:02:46.536 A:middle
We will talk you
through it step by step,

00:02:47.086 --> 00:02:51.206 A:middle
and show you all the different
steps you can take depending

00:02:51.206 --> 00:02:54.426 A:middle
on what you see,
and the sample code

00:02:54.426 --> 00:02:56.546 A:middle
of this app is completely
available.

00:02:56.546 --> 00:02:59.136 A:middle
So you can just relax
on the code slides

00:02:59.526 --> 00:03:00.936 A:middle
and play with it later.

00:02:59.526 --> 00:03:00.936 A:middle
and play with it later.

00:03:01.846 --> 00:03:04.176 A:middle
So say hello to SpeedSketch.

00:03:04.176 --> 00:03:05.226 A:middle
This is our sample.

00:03:06.626 --> 00:03:09.466 A:middle
SpeedSketch is one sheet
of paper you can draw on.

00:03:09.466 --> 00:03:12.526 A:middle
It has full support for
Apple Pencil on iPad Pro

00:03:13.086 --> 00:03:16.356 A:middle
and 3D Touch on iPhone 6S.

00:03:16.486 --> 00:03:19.246 A:middle
It also works on all
previous iOS devices.

00:03:20.556 --> 00:03:22.386 A:middle
So let's first talk
about the model.

00:03:25.696 --> 00:03:30.976 A:middle
So this is a stroke, and this
is how UIKit sees the samples.

00:03:31.116 --> 00:03:35.036 A:middle
Each of those points is one
instance, the same instance

00:03:35.036 --> 00:03:36.396 A:middle
of a mutable UI touch.

00:03:36.816 --> 00:03:39.146 A:middle
You get handed down in
the touch handing methods.

00:03:39.756 --> 00:03:43.616 A:middle
And we will model our data
as a series of strokes.

00:03:45.356 --> 00:03:50.986 A:middle
And because of the UI touch
being a mutable representation

00:03:50.986 --> 00:03:54.876 A:middle
of one touch sequence,
we need to copy the data

00:03:54.876 --> 00:03:57.626 A:middle
out of this UI touch in
the touch handing methods

00:03:57.906 --> 00:03:59.246 A:middle
into something more static.

00:04:01.306 --> 00:04:04.766 A:middle
So we will build a stroke sample
as being the innermost element

00:04:04.766 --> 00:04:08.976 A:middle
of our data structure, which
for now will just contain the

00:04:08.976 --> 00:04:11.666 A:middle
location of this, of the
UI touch, but later on,

00:04:11.666 --> 00:04:14.186 A:middle
we will fill in all the
additional data parts.

00:04:15.776 --> 00:04:19.526 A:middle
And we will put those
samples into a stroke.

00:04:19.706 --> 00:04:21.516 A:middle
Let's just an array
of stroke samples,

00:04:21.516 --> 00:04:25.106 A:middle
and we have a little bit
of methods to add them.

00:04:25.926 --> 00:04:28.126 A:middle
And because we want
to use the stroke

00:04:28.516 --> 00:04:33.246 A:middle
as our main data capture
structure, it also has a stage.

00:04:34.026 --> 00:04:37.126 A:middle
So it can be active while
the user is drawing, is done,

00:04:37.126 --> 00:04:39.396 A:middle
when the user is done,
and it can be cancelled

00:04:39.396 --> 00:04:42.916 A:middle
if a different user interaction
causes it to be cancelled.

00:04:42.916 --> 00:04:45.276 A:middle
So we can throw it away
instead of keeping it around.

00:04:47.626 --> 00:04:49.996 A:middle
And, lastly, we put this
into a stroke collection,

00:04:49.996 --> 00:04:53.686 A:middle
which will just be an array of
strokes, and we will add the

00:04:53.686 --> 00:04:57.346 A:middle
down strokes, and to make it a
complete data model for our app,

00:04:57.346 --> 00:05:00.226 A:middle
we will have the active
stroke as an optional in this.

00:04:57.346 --> 00:05:00.226 A:middle
we will have the active
stroke as an optional in this.

00:05:00.226 --> 00:05:02.006 A:middle
So we can use the
stroke collection

00:05:02.006 --> 00:05:05.606 A:middle
as our data model
for a complete app.

00:05:06.026 --> 00:05:08.536 A:middle
So next up is where to
capture those strokes.

00:05:09.356 --> 00:05:12.276 A:middle
So, essentially, you have
three places to do so.

00:05:12.526 --> 00:05:15.346 A:middle
The first one, is a
UIGestureRecognizer,

00:05:15.346 --> 00:05:17.936 A:middle
a custom UIGestureRecognizer
[inaudible] plus.

00:05:19.046 --> 00:05:23.216 A:middle
The next place to look
for is a UIView subclass

00:05:24.126 --> 00:05:28.506 A:middle
where the touch goes down, and
you can handle it all on the way

00:05:28.506 --> 00:05:31.346 A:middle
up the responder chain,
and I want to think,

00:05:31.346 --> 00:05:33.266 A:middle
I want you to think
about this in this order.

00:05:33.266 --> 00:05:36.156 A:middle
If you can do a
UIGestureRecognizer,

00:05:36.156 --> 00:05:37.656 A:middle
or a custom subclass do that.

00:05:38.286 --> 00:05:43.246 A:middle
Second, do a UIView as close as
to the events as you can get,

00:05:43.246 --> 00:05:46.206 A:middle
and only if you have to
go up the responder chain.

00:05:46.886 --> 00:05:50.186 A:middle
So this is what we going to do.

00:05:50.746 --> 00:05:53.386 A:middle
We are building a stroke
gesture recognizer accustomed

00:05:53.386 --> 00:05:54.246 A:middle
to a subclass.

00:05:54.686 --> 00:05:56.886 A:middle
We will target our
main view controller,

00:05:58.636 --> 00:06:02.736 A:middle
and then in the action methods,
we will trigger a redraw

00:05:58.636 --> 00:06:02.736 A:middle
and then in the action methods,
we will trigger a redraw

00:06:02.736 --> 00:06:04.096 A:middle
of our view with a stroke.

00:06:06.006 --> 00:06:08.616 A:middle
So let's start building this
gesture recognizer subclass.

00:06:08.616 --> 00:06:10.106 A:middle
The first thing you
have to do is

00:06:10.146 --> 00:06:12.976 A:middle
to import the
UIGestureRecognizer subclass.

00:06:13.336 --> 00:06:16.706 A:middle
This exposes the internals of
a UIGestureRecognizer to you

00:06:16.956 --> 00:06:18.806 A:middle
so you can do subclassing.

00:06:19.296 --> 00:06:22.666 A:middle
Be aware, though, that these
internals should not be used

00:06:22.666 --> 00:06:24.696 A:middle
outside of a
UIGestureRecognizer.

00:06:25.086 --> 00:06:29.626 A:middle
For example, the state setter
is exposed if you import this,

00:06:29.806 --> 00:06:32.836 A:middle
and you shouldn't use
it outside the subclass.

00:06:32.836 --> 00:06:37.516 A:middle
Otherwise, the gesture system
will act in not so nice ways,

00:06:37.516 --> 00:06:39.366 A:middle
and you will have
several issues to debug.

00:06:40.546 --> 00:06:43.676 A:middle
So let's add our stroke
as our main data structure

00:06:43.676 --> 00:06:45.856 A:middle
in our gesture recognizer
to capture the stroke

00:06:46.666 --> 00:06:48.446 A:middle
and implement the
touch handing methods.

00:06:49.456 --> 00:06:52.376 A:middle
And since we do various
similar things

00:06:52.376 --> 00:06:54.996 A:middle
in all the four touch
handing methods,

00:06:54.996 --> 00:06:57.846 A:middle
we will have a helper
method actually looking

00:06:57.846 --> 00:06:59.976 A:middle
into the set of UITouches.

00:07:00.276 --> 00:07:04.066 A:middle
Determining if we are interested
in one of those touches.

00:07:04.806 --> 00:07:07.926 A:middle
Adding that to our data model
just by copying the location

00:07:08.026 --> 00:07:11.146 A:middle
as a sample at the
moment, and return to us

00:07:11.416 --> 00:07:12.936 A:middle
if you were interested in those.

00:07:13.226 --> 00:07:16.906 A:middle
We will use this helper
method in the touchesBegan

00:07:16.906 --> 00:07:18.596 A:middle
and set our state to begin.

00:07:19.486 --> 00:07:23.566 A:middle
For UIGestureRecognizer, that
is unusual because the time

00:07:23.566 --> 00:07:27.556 A:middle
between the state possible and
the state began is the time

00:07:27.556 --> 00:07:29.886 A:middle
that different gesture
recognizers can compete

00:07:29.886 --> 00:07:32.326 A:middle
about have, handing
this touch sequence.

00:07:32.756 --> 00:07:36.466 A:middle
However, for our stroke, we
really want to begin immediately

00:07:36.466 --> 00:07:37.596 A:middle
when the touch goes down.

00:07:37.596 --> 00:07:40.926 A:middle
So this is exactly
what we want to do.

00:07:41.316 --> 00:07:44.586 A:middle
In touchesMoved, we do the same
and switch the state to changed.

00:07:44.976 --> 00:07:46.596 A:middle
Note that in a gesture
recognizer,

00:07:46.596 --> 00:07:48.916 A:middle
each state change
triggers an action method,

00:07:48.916 --> 00:07:50.126 A:middle
even if it's for the same.

00:07:50.126 --> 00:07:55.706 A:middle
And we do the same for
touchesEnded and Cancelled.

00:07:56.026 --> 00:07:59.256 A:middle
And, finally, we have to
reset our gesture recognizer

00:07:59.476 --> 00:08:02.286 A:middle
and replace the previous
stroke with a new one

00:07:59.476 --> 00:08:02.286 A:middle
and replace the previous
stroke with a new one

00:08:02.286 --> 00:08:03.676 A:middle
so we can catch on the next one.

00:08:03.906 --> 00:08:06.766 A:middle
And as a good citizen, we
always call super.reset.

00:08:06.766 --> 00:08:12.346 A:middle
Let's use this in
our ViewController.

00:08:14.466 --> 00:08:17.746 A:middle
In our viewDidLoad, we set up
our stroke gesture recognizer,

00:08:18.186 --> 00:08:22.506 A:middle
ourselves as the target with
the action strokeUpdated,

00:08:22.506 --> 00:08:24.446 A:middle
and then we add it
to our main view.

00:08:25.126 --> 00:08:29.926 A:middle
And in the update callback,
we just take the stroke

00:08:29.926 --> 00:08:32.596 A:middle
from the gesture, and
set it on our view.

00:08:32.596 --> 00:08:33.746 A:middle
That's all for now.

00:08:34.535 --> 00:08:36.846 A:middle
I told you about the
stroke collection before,

00:08:37.126 --> 00:08:39.926 A:middle
but just to bring up, I
like to keep it simple.

00:08:41.256 --> 00:08:44.046 A:middle
So let's see what this gives us.

00:08:45.426 --> 00:08:46.866 A:middle
I always like this moment

00:08:46.866 --> 00:08:48.996 A:middle
when the first time
something will run.

00:08:50.726 --> 00:08:53.976 A:middle
So what you see is
this is the position

00:08:53.976 --> 00:08:55.846 A:middle
of the pencil on the display.

00:08:56.486 --> 00:09:00.726 A:middle
Let's have a look.

00:08:56.486 --> 00:09:00.726 A:middle
Let's have a look.

00:09:00.726 --> 00:09:06.656 A:middle
Oh. That doesn't look good.

00:09:07.926 --> 00:09:08.626 A:middle
What happened?

00:09:09.306 --> 00:09:11.766 A:middle
Let's have a closer
look in slow motion.

00:09:13.796 --> 00:09:18.586 A:middle
That's really not
what we want to do.

00:09:18.846 --> 00:09:20.916 A:middle
So let's, what did we see?

00:09:20.916 --> 00:09:22.606 A:middle
We have the position
of the pencil.

00:09:23.356 --> 00:09:25.506 A:middle
We have a really,
really big distance

00:09:25.536 --> 00:09:27.026 A:middle
to the last line we drew,

00:09:27.476 --> 00:09:31.376 A:middle
and the lines we drew were
really long and choppy.

00:09:31.516 --> 00:09:33.656 A:middle
That is not what I,
what I was expecting.

00:09:33.656 --> 00:09:36.226 A:middle
We have a really good
temporary resolution.

00:09:36.226 --> 00:09:37.316 A:middle
Why does it look this way?

00:09:38.216 --> 00:09:40.326 A:middle
So, obviously, we
missed some events,

00:09:41.066 --> 00:09:43.696 A:middle
and we missed some events
because of multiple reasons.

00:09:43.696 --> 00:09:45.866 A:middle
One of them is our drawing
engine is implemented

00:09:45.866 --> 00:09:46.626 A:middle
very naively.

00:09:47.086 --> 00:09:50.856 A:middle
It is drawing a complete bit map
every time, and event comes in,

00:09:50.856 --> 00:09:55.436 A:middle
and that is not quick enough to
keep up with the display rate.

00:09:56.216 --> 00:09:57.916 A:middle
And we will talk about
this a little bit later.

00:09:58.556 --> 00:10:01.136 A:middle
And the most, more important
thing is we did not use the new

00:09:58.556 --> 00:10:01.136 A:middle
And the most, more important
thing is we did not use the new

00:10:01.206 --> 00:10:03.436 A:middle
iOS 9 API that we have

00:10:03.436 --> 00:10:05.546 A:middle
to actually get to
the missed events.

00:10:05.976 --> 00:10:08.906 A:middle
And for that, I want to look a
little bit closer at a stroke.

00:10:08.906 --> 00:10:11.826 A:middle
So let's see that again.

00:10:12.986 --> 00:10:18.056 A:middle
Here are all the rich samples
we want to have and see.

00:10:18.056 --> 00:10:22.376 A:middle
And in our touch handing
methods, we always get the began

00:10:22.376 --> 00:10:28.556 A:middle
and the ended, but in
between, we get touchesMoved.

00:10:29.046 --> 00:10:34.636 A:middle
And we don't get all of
the touchesMoved that came

00:10:34.636 --> 00:10:37.796 A:middle
in as a sample, and
that's for reason.

00:10:37.796 --> 00:10:41.436 A:middle
If we would deliver to you
all the touchesMoved even

00:10:41.436 --> 00:10:42.956 A:middle
if you would block
the main thread,

00:10:43.366 --> 00:10:45.726 A:middle
you would see something
akin to a replay

00:10:45.726 --> 00:10:48.266 A:middle
of the touch interaction, and
if you do live interaction,

00:10:48.566 --> 00:10:50.076 A:middle
that's not at all what you want.

00:10:50.226 --> 00:10:52.426 A:middle
You want the most recent
position delivered to you,

00:10:53.026 --> 00:10:54.606 A:middle
and that's what we do generally,

00:10:54.606 --> 00:10:56.946 A:middle
and that's what we
did before OS 9.

00:10:56.946 --> 00:10:58.746 A:middle
We actually dropped
all the other events.

00:10:58.746 --> 00:11:02.176 A:middle
If you weren't quick
enough in the main run loop,

00:10:58.746 --> 00:11:02.176 A:middle
If you weren't quick
enough in the main run loop,

00:11:02.846 --> 00:11:06.596 A:middle
then you just didn't see any of
them, but beginning with iOS 9,

00:11:06.596 --> 00:11:09.066 A:middle
we give you access
to the previous ones.

00:11:09.466 --> 00:11:13.856 A:middle
And the other reason is as
our digitizer is now faster

00:11:13.856 --> 00:11:18.786 A:middle
than the display, we don't
want to give you each an event

00:11:18.786 --> 00:11:21.416 A:middle
for each datapoint we have.

00:11:22.036 --> 00:11:23.976 A:middle
So you do too much work.

00:11:23.976 --> 00:11:26.086 A:middle
So we try to coalesce
them together

00:11:26.686 --> 00:11:30.026 A:middle
into one delivery per
[inaudible] refresh.

00:11:32.596 --> 00:11:36.416 A:middle
So what you can do
now is in the,

00:11:36.416 --> 00:11:38.536 A:middle
using the life touch
you get in our API,

00:11:39.286 --> 00:11:41.996 A:middle
ask for the touches you missed,

00:11:42.316 --> 00:11:44.826 A:middle
and that includes the touch
you currently asking for.

00:11:44.826 --> 00:11:46.746 A:middle
So you have a complete
consistent picture.

00:11:47.296 --> 00:11:49.526 A:middle
And those touches are
called Coalesce Touches.

00:11:49.906 --> 00:11:52.426 A:middle
And you do that for
all your touch events.

00:11:53.906 --> 00:11:57.936 A:middle
And you do that also
for begin and ended.

00:11:58.916 --> 00:12:01.076 A:middle
Because you have to
stay in the same area.

00:11:58.916 --> 00:12:01.076 A:middle
Because you have to
stay in the same area.

00:12:01.076 --> 00:12:03.156 A:middle
Either you handle
your life touches

00:12:03.206 --> 00:12:04.956 A:middle
or you handle the
coalesce touches.

00:12:05.376 --> 00:12:08.386 A:middle
Because there are methods
like previous location in view

00:12:08.596 --> 00:12:11.626 A:middle
that reference the previous
touch, and if you mix and match,

00:12:11.766 --> 00:12:13.256 A:middle
then you into problems there.

00:12:14.486 --> 00:12:17.126 A:middle
So now that we know how,
how we can get them,

00:12:17.126 --> 00:12:18.236 A:middle
let's do this in code.

00:12:19.606 --> 00:12:23.556 A:middle
The method is coalescedTouches
for touch on UIEvent,

00:12:23.556 --> 00:12:25.956 A:middle
and you get the event in
the touch handing callbacks.

00:12:27.576 --> 00:12:32.436 A:middle
And now that the optional
of this result is not

00:12:32.436 --> 00:12:34.176 A:middle
because we will give you nil.

00:12:35.236 --> 00:12:36.926 A:middle
Anytime if you only
have one touch,

00:12:36.926 --> 00:12:38.266 A:middle
and we don't have
Coalesced Touches,

00:12:38.806 --> 00:12:42.696 A:middle
it's because you could ask for
any UI test that is not part

00:12:42.696 --> 00:12:44.236 A:middle
of the event, and then
you would get nil.

00:12:44.626 --> 00:12:47.076 A:middle
You're guaranteed to
always get UI touches,

00:12:47.076 --> 00:12:50.126 A:middle
at least the one you put in
even if we didn't coalesce more.

00:12:50.526 --> 00:12:54.376 A:middle
So you don't have to do an
if statement around this.

00:12:55.116 --> 00:12:59.006 A:middle
So let's use this in our code.

00:12:59.006 --> 00:13:01.286 A:middle
In our code where we look at
the touch we're interested in,

00:12:59.006 --> 00:13:01.286 A:middle
In our code where we look at
the touch we're interested in,

00:13:01.566 --> 00:13:04.626 A:middle
we did appendTouch, and all
we have to do is to loop

00:13:04.626 --> 00:13:07.636 A:middle
over the Coalesce Touches
instead and append those.

00:13:08.086 --> 00:13:10.876 A:middle
That gives us all the data.

00:13:10.876 --> 00:13:15.136 A:middle
Let's have a look
at how that looks.

00:13:15.136 --> 00:13:17.676 A:middle
Nice. Now we really
have all the data.

00:13:18.496 --> 00:13:20.146 A:middle
Let's have a comparison.

00:13:20.146 --> 00:13:28.286 A:middle
And, again, in slow
motion with a stop.

00:13:30.616 --> 00:13:32.076 A:middle
So what are you seeing here?

00:13:32.076 --> 00:13:34.346 A:middle
This is in [inaudible]
the Pencil's location

00:13:34.346 --> 00:13:35.596 A:middle
on the glass currently.

00:13:36.936 --> 00:13:41.096 A:middle
These are the Coalesce Touches
in gray, colored in gray.

00:13:41.096 --> 00:13:43.426 A:middle
Now debugging drawing engine.

00:13:44.236 --> 00:13:45.996 A:middle
The black one is also
a Coalesce Touch,

00:13:45.996 --> 00:13:48.086 A:middle
but the one corresponding
to the live touch.

00:13:49.236 --> 00:13:50.776 A:middle
And what you also see is

00:13:50.776 --> 00:13:52.836 A:middle
that you see too many
Coalesce Touches.

00:13:53.546 --> 00:13:55.756 A:middle
If our digitizer is running
at four times the speed

00:13:55.756 --> 00:13:56.736 A:middle
of the display, you see,

00:13:57.166 --> 00:14:01.156 A:middle
you should see an average three
gray ones among black ones.

00:13:57.166 --> 00:14:01.156 A:middle
you should see an average three
gray ones among black ones.

00:14:01.576 --> 00:14:02.516 A:middle
These are way too many.

00:14:04.166 --> 00:14:06.626 A:middle
And we still have this
excessive gap at the end,

00:14:06.626 --> 00:14:10.176 A:middle
which leads to lag,
visible lag for users.

00:14:10.176 --> 00:14:13.406 A:middle
So what did we see?

00:14:13.846 --> 00:14:15.756 A:middle
The speed is still lagging
of our drawing engine.

00:14:15.756 --> 00:14:19.396 A:middle
We didn't address this up
to now, but UIkit helped

00:14:19.396 --> 00:14:20.686 A:middle
by coalescing the touches,

00:14:20.746 --> 00:14:24.346 A:middle
and the final drawing really has
all the data it needs already.

00:14:24.766 --> 00:14:28.096 A:middle
So if you only take
one thing of the sort,

00:14:28.096 --> 00:14:30.306 A:middle
then use Coalesce
Touches if you really want

00:14:30.306 --> 00:14:32.366 A:middle
to have the rich
data of your Pencil.

00:14:32.676 --> 00:14:39.696 A:middle
So what is the problem
with the drawing?

00:14:39.696 --> 00:14:41.576 A:middle
You should not draw
on every touch event

00:14:42.046 --> 00:14:44.366 A:middle
because the display
refresh rate is 60 hertz.

00:14:44.806 --> 00:14:48.136 A:middle
Although we try to actually
deliver only one event per

00:14:48.136 --> 00:14:51.546 A:middle
frame, you can draw, that
sometimes is impossible

00:14:51.546 --> 00:14:54.626 A:middle
because if you mix
fingers and the Pencil

00:14:54.626 --> 00:14:56.886 A:middle
or have other events coming in,

00:14:56.886 --> 00:14:58.226 A:middle
we need to deliver
them in order.

00:14:58.516 --> 00:15:01.756 A:middle
And so you need to be
prepared to receive more events

00:14:58.516 --> 00:15:01.756 A:middle
And so you need to be
prepared to receive more events

00:15:01.756 --> 00:15:04.296 A:middle
than you can, than
[inaudible] refresh rate.

00:15:05.206 --> 00:15:07.026 A:middle
And do not try to draw faster

00:15:07.026 --> 00:15:11.496 A:middle
because this is just costing
performance and adding lag

00:15:11.496 --> 00:15:14.466 A:middle
and doing work that doesn't even
get displayed on the screen.

00:15:14.816 --> 00:15:16.406 A:middle
So when should you render?

00:15:16.586 --> 00:15:19.466 A:middle
In our example, we are using
a regular [inaudible] core

00:15:19.466 --> 00:15:21.646 A:middle
graphics, and in that case,

00:15:21.706 --> 00:15:24.156 A:middle
you should just use setsNeeds
display on that view,

00:15:24.926 --> 00:15:28.316 A:middle
marking that view is needing
update and giving the work to CA

00:15:28.316 --> 00:15:31.796 A:middle
to actually call the draw method
you need to implement instead

00:15:31.796 --> 00:15:33.326 A:middle
of your custom bit drawing.

00:15:34.066 --> 00:15:39.896 A:middle
If you're using a GLKView or
a MetalView you can also opt

00:15:39.896 --> 00:15:42.546 A:middle
into this behavior
instead of a steady update

00:15:42.986 --> 00:15:46.426 A:middle
by setting the enableSetsNeeds
display property to true.

00:15:47.016 --> 00:15:50.626 A:middle
That way those views behave in
the same way if you want to.

00:15:51.776 --> 00:15:54.506 A:middle
If you need to draw at a
steady pace, then please draw

00:15:54.506 --> 00:15:57.266 A:middle
at a steady pace and not
based on the events coming in,

00:15:57.626 --> 00:15:59.246 A:middle
and you can do so
using the Metal

00:15:59.246 --> 00:16:03.396 A:middle
and GLViews internal
mechanisms, or you can do

00:15:59.246 --> 00:16:03.396 A:middle
and GLViews internal
mechanisms, or you can do

00:16:03.396 --> 00:16:06.676 A:middle
so using a CADisplayLink
and calling display

00:16:06.676 --> 00:16:08.056 A:middle
in the wake of your DisplayLink.

00:16:08.646 --> 00:16:10.526 A:middle
What we did was we had

00:16:10.526 --> 00:16:14.706 A:middle
in our strokes [inaudible] just
a did set on the stroke to draw

00:16:14.706 --> 00:16:15.956 A:middle
with drawImageAndUpdate.

00:16:16.426 --> 00:16:18.436 A:middle
This created the
[inaudible] this was bad.

00:16:18.916 --> 00:16:21.046 A:middle
So let's just do
setsNeedsDisplay,

00:16:21.726 --> 00:16:25.416 A:middle
and move the drawing code
into the draw method.

00:16:26.396 --> 00:16:29.256 A:middle
If you're using a regular
UFU, you can do even better.

00:16:29.546 --> 00:16:33.276 A:middle
You can only mark the changed
areas a setDisplayInRect

00:16:33.906 --> 00:16:38.366 A:middle
that also needs some kind
of bookkeeping in the touch

00:16:38.366 --> 00:16:41.726 A:middle
because your drawing might,
might be a little bit bigger

00:16:41.726 --> 00:16:42.846 A:middle
than the changed touches,

00:16:42.846 --> 00:16:45.406 A:middle
and the touches change
in our samples.

00:16:45.796 --> 00:16:48.696 A:middle
You can look at the sample
code to have one example

00:16:48.696 --> 00:16:50.956 A:middle
of how you could do this
kind of bookkeeping.

00:16:52.796 --> 00:16:55.926 A:middle
And even further, you can
activate drawsAsynchronously

00:16:56.586 --> 00:16:57.636 A:middle
on the layer.

00:16:57.906 --> 00:17:02.036 A:middle
This puts all the drawing you
do in the draw rect up to CG,

00:16:57.906 --> 00:17:02.036 A:middle
This puts all the drawing you
do in the draw rect up to CG,

00:17:02.036 --> 00:17:06.046 A:middle
up to CA, and CA draws it
outside of the main thread

00:17:06.185 --> 00:17:09.185 A:middle
which opens your main thread
for quicker event handling,

00:17:09.726 --> 00:17:13.896 A:middle
and you do so by simply setting
drawsAsynchronously to true

00:17:13.896 --> 00:17:14.996 A:middle
or your diffuse layer.

00:17:16.046 --> 00:17:17.976 A:middle
Let's see how far this got us.

00:17:24.976 --> 00:17:26.366 A:middle
Again in slow motion.

00:17:28.856 --> 00:17:33.786 A:middle
So now we have the steady amount

00:17:33.786 --> 00:17:36.556 A:middle
of Coalesce Touches
I was talking about,

00:17:36.556 --> 00:17:39.106 A:middle
about three Coalesce
Touches and one black one.

00:17:39.106 --> 00:17:42.366 A:middle
But we still have some lag.

00:17:42.606 --> 00:17:46.486 A:middle
It however, it's way smaller
because now we really draw

00:17:46.486 --> 00:17:51.146 A:middle
at the display speed, and we
just have the remaining lag.

00:17:51.146 --> 00:17:53.236 A:middle
And how can we improve that?

00:17:53.956 --> 00:17:58.546 A:middle
So we have a facility called
Predicted Touches since iOS 9,

00:17:58.886 --> 00:18:02.416 A:middle
and Predicted Touches give
you a glimpse into the future.

00:17:58.886 --> 00:18:02.416 A:middle
and Predicted Touches give
you a glimpse into the future.

00:18:02.416 --> 00:18:06.956 A:middle
You use the same way as Coalesce
Touches, and you ask your event

00:18:06.956 --> 00:18:10.206 A:middle
for the Predicted Touches for
touch, and you get an array

00:18:11.086 --> 00:18:13.596 A:middle
of touches that are
in the future.

00:18:13.596 --> 00:18:17.606 A:middle
And what do you do
with those touches?

00:18:17.606 --> 00:18:20.386 A:middle
You add them to your data
structure but temporarily.

00:18:20.446 --> 00:18:22.326 A:middle
They change on every
event callback.

00:18:22.606 --> 00:18:25.096 A:middle
So you really have to do
them just temporarily.

00:18:25.956 --> 00:18:28.026 A:middle
And you choose their appearance,
depending on your app.

00:18:28.026 --> 00:18:33.896 A:middle
I highly recommend that you make
them appear like actual touches,

00:18:34.956 --> 00:18:39.256 A:middle
and look at the result, and
only if our prediction is off

00:18:39.256 --> 00:18:42.056 A:middle
by too much, then tone it down.

00:18:42.056 --> 00:18:43.486 A:middle
It makes them appears tentative

00:18:43.846 --> 00:18:48.506 A:middle
to still get the closer
look to the Pencil.

00:18:49.636 --> 00:18:51.206 A:middle
Let's look over that in code.

00:18:52.346 --> 00:18:53.786 A:middle
So now in our touch
setting methods,

00:18:53.786 --> 00:18:55.596 A:middle
after you added the
Coalesce Touches,

00:18:55.786 --> 00:19:02.816 A:middle
you add the Predicted Touches
temporarily, and you need

00:18:55.786 --> 00:19:02.816 A:middle
you add the Predicted Touches
temporarily, and you need

00:19:02.816 --> 00:19:06.076 A:middle
to make sure that you remove
the temporary touches before.

00:19:07.406 --> 00:19:10.676 A:middle
So I will show you a video of
how that looks with the opposite

00:19:10.676 --> 00:19:11.496 A:middle
of what you should do.

00:19:11.496 --> 00:19:15.276 A:middle
I will highlight the Predicted
Touches in red so we can see

00:19:15.576 --> 00:19:18.046 A:middle
if they are good
enough for our example.

00:19:18.216 --> 00:19:22.976 A:middle
And, again, in slow motion
because this was so quick.

00:19:29.856 --> 00:19:32.956 A:middle
So these are the Predictive
Touches, and they get you closer

00:19:32.956 --> 00:19:36.806 A:middle
to the actual Pencil position,
which is really, really helpful

00:19:36.806 --> 00:19:39.896 A:middle
for perceived lag
on the display.

00:19:40.296 --> 00:19:42.516 A:middle
And as you can see
in this example,

00:19:42.516 --> 00:19:43.946 A:middle
this really worked out fine.

00:19:43.946 --> 00:19:45.246 A:middle
So we will just use them

00:19:45.246 --> 00:19:47.666 A:middle
and draw them the same way
we draw regular touches.

00:19:47.666 --> 00:19:50.816 A:middle
So have we seen so far?

00:19:51.226 --> 00:19:53.976 A:middle
We have seen how to collect
the input using an custom

00:19:53.976 --> 00:19:58.046 A:middle
UIGestureRecognizer, how to
access the Coalesce Touches,

00:19:59.096 --> 00:20:04.786 A:middle
how to make the rendering faster
and efficient, and, finally,

00:19:59.096 --> 00:20:04.786 A:middle
how to make the rendering faster
and efficient, and, finally,

00:20:04.786 --> 00:20:05.976 A:middle
how to use the Predictive
Touches.

00:20:06.686 --> 00:20:10.746 A:middle
All of those techniques work
on, across all iOS devices.

00:20:10.796 --> 00:20:13.626 A:middle
We used them for the Pencil
right now in our examples,

00:20:13.976 --> 00:20:15.416 A:middle
but they work overall.

00:20:15.746 --> 00:20:20.456 A:middle
Now let's go on to the
actual new Apple Pencil API.

00:20:21.426 --> 00:20:24.006 A:middle
So let's begin with touch types.

00:20:24.856 --> 00:20:29.886 A:middle
With Apple Pencil UITouch
added a new method called type,

00:20:30.246 --> 00:20:33.376 A:middle
and UITouch type can
be one of three values.

00:20:34.326 --> 00:20:37.556 A:middle
It can be direct, which would
be all your previous touches you

00:20:37.556 --> 00:20:38.566 A:middle
know about.

00:20:39.756 --> 00:20:43.436 A:middle
There's indirect only for
the Siri remote touches,

00:20:43.926 --> 00:20:46.836 A:middle
and there's stylus
for Apple Pencil.

00:20:47.736 --> 00:20:52.676 A:middle
And the first thing
you can access

00:20:52.676 --> 00:20:54.556 A:middle
with Apple Pencil is
the higher precision,

00:20:55.026 --> 00:20:57.976 A:middle
and you do so by using
precise location in view,

00:20:58.946 --> 00:21:01.756 A:middle
and you also have the precise
previous location in view.

00:20:58.946 --> 00:21:01.756 A:middle
and you also have the precise
previous location in view.

00:21:02.426 --> 00:21:05.256 A:middle
You should use those whenever
you want the precise location

00:21:05.256 --> 00:21:06.436 A:middle
for something like a drawing.

00:21:06.826 --> 00:21:08.236 A:middle
If you want to do hit testing,

00:21:08.346 --> 00:21:13.046 A:middle
you should still use the
previous ones called location in

00:21:13.046 --> 00:21:15.126 A:middle
and previous location in.

00:21:15.266 --> 00:21:17.176 A:middle
But for drawing, this
really makes a difference.

00:21:17.486 --> 00:21:19.036 A:middle
Without the precise locations,

00:21:19.036 --> 00:21:22.796 A:middle
you will add some staircase
patterns to your drawing,

00:21:22.796 --> 00:21:23.816 A:middle
which you don't want to see.

00:21:24.626 --> 00:21:27.706 A:middle
And you can ask all kind of
touches for precise location.

00:21:27.706 --> 00:21:30.806 A:middle
You will just get
the regular one.

00:21:31.386 --> 00:21:33.176 A:middle
Next up, there's force.

00:21:33.416 --> 00:21:36.216 A:middle
Force is exposed as a
property called force

00:21:36.596 --> 00:21:38.496 A:middle
and a maximum possible force.

00:21:38.836 --> 00:21:42.606 A:middle
Those are CG floats, and they
are in the range from zero

00:21:42.606 --> 00:21:44.126 A:middle
to the maximum possible force

00:21:44.656 --> 00:21:47.676 A:middle
where 1.0 represents
an average touch.

00:21:47.676 --> 00:21:50.116 A:middle
So these are not
really physical values.

00:21:50.386 --> 00:21:52.396 A:middle
So you shouldn't do
anything that relates

00:21:52.396 --> 00:21:57.036 A:middle
to the actual force,
but you use this value

00:21:57.466 --> 00:21:59.076 A:middle
to affect your drawing.

00:21:59.076 --> 00:22:04.936 A:middle
And on all previous devices
and for regular finger touches,

00:21:59.076 --> 00:22:04.936 A:middle
And on all previous devices
and for regular finger touches,

00:22:05.236 --> 00:22:06.616 A:middle
it will always return zero.

00:22:07.206 --> 00:22:11.126 A:middle
A quick note on force.

00:22:11.126 --> 00:22:15.256 A:middle
Since we added force to
UITouch, there's one difference

00:22:15.256 --> 00:22:18.486 A:middle
in touch handing, and that
is touchesMoved gets called

00:22:18.486 --> 00:22:19.106 A:middle
more often.

00:22:19.476 --> 00:22:21.576 A:middle
Because you want to
be able to discern

00:22:21.576 --> 00:22:23.366 A:middle
if the force value changed.

00:22:23.786 --> 00:22:26.756 A:middle
We will send you
touchesMoved now all the time.

00:22:26.806 --> 00:22:29.896 A:middle
Previously, we were
trying very hard

00:22:29.896 --> 00:22:31.616 A:middle
to only send you touchesMoved

00:22:31.616 --> 00:22:33.446 A:middle
when the location
actually changed,

00:22:33.976 --> 00:22:36.446 A:middle
and that is through
regular location,

00:22:36.446 --> 00:22:37.816 A:middle
not even the precise location.

00:22:38.996 --> 00:22:40.836 A:middle
And that has implications
for you.

00:22:41.456 --> 00:22:44.376 A:middle
So, for example, we've seen
a lot of this in the wild.

00:22:44.376 --> 00:22:46.046 A:middle
If you did in touchesMoved,

00:22:46.476 --> 00:22:51.786 A:middle
if you just cancel a tap
willingly, that is bad.

00:22:51.786 --> 00:22:53.966 A:middle
That doesn't work anymore.

00:22:53.966 --> 00:22:57.946 A:middle
And what you see is that
on a, on an iPhone 6s

00:22:57.996 --> 00:23:00.456 A:middle
or with the Pencil,
if you have to really,

00:22:57.996 --> 00:23:00.456 A:middle
or with the Pencil,
if you have to really,

00:23:00.456 --> 00:23:03.006 A:middle
really just slightly
touch your display,

00:23:03.006 --> 00:23:05.726 A:middle
then this is what you're running
into, and you should have a look

00:23:05.726 --> 00:23:07.116 A:middle
at your touch handing code.

00:23:07.546 --> 00:23:08.346 A:middle
What should you do?

00:23:09.046 --> 00:23:11.276 A:middle
You should actually use a
UITouchGesturesRecognizer

00:23:11.276 --> 00:23:13.396 A:middle
if you can because
it encapsulates all

00:23:13.396 --> 00:23:17.116 A:middle
of our knowledge there, or the
least thing you have to do is

00:23:17.176 --> 00:23:19.636 A:middle
to remember the location
where the touches began

00:23:19.876 --> 00:23:24.246 A:middle
and only cancel it if you
moved enough distance away

00:23:24.246 --> 00:23:25.446 A:middle
from the original location.

00:23:26.906 --> 00:23:30.576 A:middle
So let's add our force to the
model, to our stroke sample,

00:23:31.156 --> 00:23:34.486 A:middle
and we just do that by an
optional force variable.

00:23:34.646 --> 00:23:38.686 A:middle
We will add all the other
things in there later, too,

00:23:38.686 --> 00:23:41.406 A:middle
and I won't show
this slide again.

00:23:41.706 --> 00:23:46.566 A:middle
So let's see how the force
looks in our drawing.

00:23:48.046 --> 00:23:49.496 A:middle
Nice. What did we do?

00:23:50.116 --> 00:23:53.176 A:middle
We just changed the
width space of the force.

00:23:55.126 --> 00:23:56.866 A:middle
So next up is tilt.

00:23:57.946 --> 00:24:01.546 A:middle
Apple Pencil gives you access
to its tilt towards the device,

00:23:57.946 --> 00:24:01.546 A:middle
Apple Pencil gives you access
to its tilt towards the device,

00:24:01.896 --> 00:24:05.196 A:middle
and this is measured in an
angle between the Pencil

00:24:05.196 --> 00:24:08.396 A:middle
and the device which
we call altitude.

00:24:09.146 --> 00:24:12.546 A:middle
And the altitude angle is
exposed as altitude angle.

00:24:12.586 --> 00:24:14.696 A:middle
It's a CG float.

00:24:15.496 --> 00:24:18.976 A:middle
It reported at angle at
a radian from the range

00:24:18.976 --> 00:24:21.076 A:middle
from about 10 degrees
to 90 degrees.

00:24:21.656 --> 00:24:27.686 A:middle
And that second part
is the orientation.

00:24:27.686 --> 00:24:32.036 A:middle
The orientation is measured
[inaudible] to your device,

00:24:32.036 --> 00:24:35.796 A:middle
and it's measured between
the positive x direction

00:24:36.356 --> 00:24:38.846 A:middle
and the direction the
Pencil is coming from.

00:24:39.486 --> 00:24:42.206 A:middle
And this is called azimuth.

00:24:43.856 --> 00:24:48.066 A:middle
Together, azimuth and tilt form
the full location of the Pencil,

00:24:48.066 --> 00:24:50.886 A:middle
and you can drive your
UI or your datapoints

00:24:50.886 --> 00:24:51.806 A:middle
for your drawing with it.

00:24:52.316 --> 00:24:56.066 A:middle
So azimuth is depending on
your orientation of the device.

00:24:56.316 --> 00:25:00.186 A:middle
So you have to call a method
called azimuthAngleInIvew,

00:24:56.316 --> 00:25:00.186 A:middle
So you have to call a method
called azimuthAngleInIvew,

00:25:00.616 --> 00:25:02.486 A:middle
and most of the time
you probably want

00:25:02.486 --> 00:25:03.986 A:middle
to use a vector anyways.

00:25:04.196 --> 00:25:07.166 A:middle
So we exposed the azimuth
unit vector in view to you

00:25:07.496 --> 00:25:08.916 A:middle
which will be a vector pointing

00:25:08.916 --> 00:25:10.576 A:middle
in the direction
the Pencil is coming

00:25:10.576 --> 00:25:15.036 A:middle
from with a magnitude of one.

00:25:15.756 --> 00:25:16.826 A:middle
Next up, force.

00:25:17.546 --> 00:25:20.586 A:middle
So force, for the Pencil
behaves a little bit differently

00:25:20.586 --> 00:25:25.896 A:middle
than 3D Touch force, and that is
the force is measured along the

00:25:25.896 --> 00:25:27.186 A:middle
axis of the Pencil.

00:25:27.986 --> 00:25:30.486 A:middle
With 3D Touch, the force
is measured on the display

00:25:30.486 --> 00:25:32.616 A:middle
and perpendicular to
the device surface.

00:25:33.186 --> 00:25:36.916 A:middle
That makes for some difference,
and I really urge you to try

00:25:36.916 --> 00:25:39.786 A:middle
out if you want to
have the actual force,

00:25:39.946 --> 00:25:43.166 A:middle
all the perpendicular
force in your drawing tools

00:25:43.216 --> 00:25:45.156 A:middle
because it really, it
really feels different.

00:25:45.766 --> 00:25:48.556 A:middle
Luckily, it's easy to
calculate this component,

00:25:49.296 --> 00:25:50.846 A:middle
and here's the code for that.

00:25:51.506 --> 00:25:54.896 A:middle
So you can get the perpendicular
force by dividing the force

00:25:55.056 --> 00:25:58.626 A:middle
through the sign of the altitude
angle and to make sure you stay

00:25:58.626 --> 00:26:00.656 A:middle
in the same range, you
should also clamp it

00:25:58.626 --> 00:26:00.656 A:middle
in the same range, you
should also clamp it

00:26:00.656 --> 00:26:02.276 A:middle
to the maximumPossibleForce.

00:26:02.816 --> 00:26:07.056 A:middle
And there's finally
another tidbit

00:26:07.276 --> 00:26:08.746 A:middle
for Apple Pencil with the force.

00:26:08.986 --> 00:26:12.736 A:middle
It's measured inside the
Pencil, and then transmitted

00:26:12.816 --> 00:26:16.666 A:middle
over the air to the iPad, and
this is all the properties

00:26:16.666 --> 00:26:17.976 A:middle
of over-the-air transmissions.

00:26:18.056 --> 00:26:20.366 A:middle
That means they take
a little bit

00:26:20.366 --> 00:26:22.826 A:middle
of time, and data can be lost.

00:26:23.546 --> 00:26:25.176 A:middle
So instead of making you wait

00:26:25.176 --> 00:26:27.206 A:middle
for the over-the-air
transmission of the force,

00:26:27.456 --> 00:26:30.296 A:middle
we decided to give you
estimated properties at first

00:26:31.316 --> 00:26:35.316 A:middle
and update them later so you
can have the best experience.

00:26:36.126 --> 00:26:40.876 A:middle
So for that, we exposed
estimated properties on UITouch,

00:26:41.476 --> 00:26:43.536 A:middle
which is of the type
UITouchProperties.

00:26:44.496 --> 00:26:51.086 A:middle
So estimated properties
can have a value of force,

00:26:51.466 --> 00:26:53.416 A:middle
which for Apple Pencil
will always be true

00:26:53.416 --> 00:26:55.516 A:middle
for the first event you get.

00:26:57.906 --> 00:27:00.406 A:middle
But also the azimuth

00:26:57.906 --> 00:27:00.406 A:middle
But also the azimuth

00:27:00.406 --> 00:27:03.776 A:middle
and altitude can be
marked as estimated.

00:27:04.216 --> 00:27:06.216 A:middle
That happens when you
come in from the sides,

00:27:06.216 --> 00:27:09.656 A:middle
and we not hundred percent
sure what the values will be

00:27:09.656 --> 00:27:11.646 A:middle
or if you draw very
closely to your fingers

00:27:11.646 --> 00:27:15.516 A:middle
because our senses can't really
detect them super-accurately.

00:27:15.816 --> 00:27:17.866 A:middle
And we tell you that
they are estimated

00:27:17.866 --> 00:27:19.076 A:middle
so you can do something with it.

00:27:19.076 --> 00:27:21.006 A:middle
For example, when
coming in from the sides,

00:27:21.386 --> 00:27:24.466 A:middle
you could back fill them
with the first solid value,

00:27:24.506 --> 00:27:29.906 A:middle
and in the sample I gave to
you, that is what I did just

00:27:29.906 --> 00:27:31.436 A:middle
as to illustrate that point.

00:27:32.366 --> 00:27:34.036 A:middle
And there's also the location,

00:27:34.036 --> 00:27:36.946 A:middle
which is an estimated property
only for the Predicted Touches,

00:27:37.146 --> 00:27:38.426 A:middle
which gives you an easy way

00:27:38.426 --> 00:27:40.736 A:middle
to determine Predicted
Touches from regular ones.

00:27:43.706 --> 00:27:47.766 A:middle
And for the updates, we also
have the estimated properties

00:27:47.766 --> 00:27:49.176 A:middle
expecting updates.

00:27:50.296 --> 00:27:52.626 A:middle
This is also of type
UITouch properties,

00:27:52.626 --> 00:27:54.016 A:middle
and currently it's only force.

00:27:54.016 --> 00:27:57.076 A:middle
It might be in the future also
as an azimuth altitude, but,

00:27:57.076 --> 00:28:00.956 A:middle
currently, it's only the force
value, and if that is set,

00:27:57.076 --> 00:28:00.956 A:middle
currently, it's only the force
value, and if that is set,

00:28:01.026 --> 00:28:04.656 A:middle
we will send you updates in
the future, and we will do

00:28:04.656 --> 00:28:07.546 A:middle
so in our new responder
called touchesEstimated

00:28:07.546 --> 00:28:10.876 A:middle
PropertiesUpdated, and we
will do so after the fact.

00:28:10.876 --> 00:28:13.376 A:middle
So we will send you
touches when touches begin,

00:28:13.376 --> 00:28:15.356 A:middle
and then send you updates later.

00:28:16.966 --> 00:28:18.126 A:middle
Let's walk through this.

00:28:19.026 --> 00:28:20.506 A:middle
So what do you do?

00:28:20.506 --> 00:28:22.126 A:middle
[Inaudible] touches
began or moved,

00:28:22.126 --> 00:28:23.966 A:middle
you check the
estimatedProperties

00:28:23.966 --> 00:28:27.806 A:middle
ExpectedUpdates on your touch,
and if that is not [inaudible],

00:28:29.286 --> 00:28:32.616 A:middle
you use the property
estimation updated [inaudible]

00:28:32.616 --> 00:28:35.286 A:middle
on the UITouch, which is
[inaudible] and is only set

00:28:35.786 --> 00:28:39.786 A:middle
for touches that either expect
updates or represent an update,

00:28:40.276 --> 00:28:43.546 A:middle
and use that to store your
thing you want to update,

00:28:43.546 --> 00:28:46.016 A:middle
your current touch
sample in a dictionary

00:28:46.306 --> 00:28:47.396 A:middle
so you can look it up later.

00:28:47.396 --> 00:28:51.746 A:middle
In the touchesEstimated
PropertiesUpdated, then you look

00:28:51.746 --> 00:28:55.996 A:middle
up your sample, and using the
estimation updates of the touch,

00:28:55.996 --> 00:28:58.836 A:middle
you get an update
just the values

00:28:58.836 --> 00:29:00.226 A:middle
that were expecting updates.

00:28:58.836 --> 00:29:00.226 A:middle
that were expecting updates.

00:29:01.526 --> 00:29:04.026 A:middle
Note, though, that some
of the updates will arrive

00:29:04.086 --> 00:29:05.346 A:middle
after touch has ended.

00:29:06.266 --> 00:29:08.326 A:middle
That's a life cycle thing
you have to be aware.

00:29:08.326 --> 00:29:10.796 A:middle
If you don't keep
your data structure

00:29:10.796 --> 00:29:15.396 A:middle
around after touch has ended,
you will see estimated force

00:29:15.586 --> 00:29:20.396 A:middle
at the end of your stroke,
and it will look weird.

00:29:20.586 --> 00:29:22.266 A:middle
So let's go with that in code.

00:29:23.296 --> 00:29:26.196 A:middle
So we have touchesEstimated
PropertiesUpdated,

00:29:26.196 --> 00:29:28.526 A:middle
and we go through our touches.

00:29:29.306 --> 00:29:32.246 A:middle
We look up the estimation index
because we are in this method.

00:29:32.246 --> 00:29:34.206 A:middle
We can just implicitly
unwrap it.

00:29:34.936 --> 00:29:37.756 A:middle
We find our sample
in the sample index.

00:29:37.976 --> 00:29:40.196 A:middle
We update the sample,
and as I told you,

00:29:40.196 --> 00:29:42.626 A:middle
we update only the
values in that method

00:29:43.026 --> 00:29:44.886 A:middle
that we're expecting
updates before.

00:29:45.126 --> 00:29:50.946 A:middle
And then we update our
stroke, and to be future-proof,

00:29:50.946 --> 00:29:53.666 A:middle
we check if this touch
still expects updates,

00:29:53.826 --> 00:29:56.776 A:middle
and only if it doesn't we
remove it from our set.

00:29:57.346 --> 00:29:58.956 A:middle
So let's see this in action.

00:30:04.986 --> 00:30:07.406 A:middle
So I tried to use
the azimuth angle

00:30:07.686 --> 00:30:10.236 A:middle
to do a calligraphy
pen simulation.

00:30:11.436 --> 00:30:15.696 A:middle
And now that we have all the
data we want, let's look at this

00:30:15.696 --> 00:30:17.486 A:middle
without the debugging mode.

00:30:21.336 --> 00:30:22.986 A:middle
Doesn't that look nice?

00:30:22.986 --> 00:30:27.156 A:middle
And that's literally just me
connecting all the dots we got

00:30:27.156 --> 00:30:27.866 A:middle
from the hardware.

00:30:27.866 --> 00:30:29.956 A:middle
That is not interpolating
anything

00:30:29.956 --> 00:30:31.196 A:middle
or doing something fancy

00:30:31.196 --> 00:30:32.526 A:middle
like your drawing
engines [inaudible].

00:30:37.826 --> 00:30:39.886 A:middle
So with that, let's add
some finishing touches

00:30:40.326 --> 00:30:41.436 A:middle
to the final app.

00:30:41.776 --> 00:30:45.396 A:middle
Up to now, we just drew
a whole screen full.

00:30:45.676 --> 00:30:48.586 A:middle
We don't want to be
restricted to that.

00:30:48.586 --> 00:30:51.816 A:middle
So let's support our
arbitrary canvas sizes.

00:30:52.146 --> 00:30:56.426 A:middle
For that, we include our stroke
view into a container view,

00:30:56.426 --> 00:30:58.376 A:middle
add a little bit of
shadow, and put them

00:30:58.766 --> 00:31:01.896 A:middle
that into a [inaudible] draw
view, and we're done, right.

00:30:58.766 --> 00:31:01.896 A:middle
that into a [inaudible] draw
view, and we're done, right.

00:31:03.136 --> 00:31:04.266 A:middle
Not quite.

00:31:04.516 --> 00:31:09.686 A:middle
So now we have to think about
how to handle our gestures

00:31:10.046 --> 00:31:13.116 A:middle
because the [inaudible]
recognizes now conflicts

00:31:13.116 --> 00:31:14.626 A:middle
with our stroke gesture
recognizer.

00:31:15.476 --> 00:31:18.546 A:middle
If we change nothing, then
we will always draw a stroke,

00:31:18.546 --> 00:31:19.846 A:middle
and we can never scroll.

00:31:20.036 --> 00:31:21.066 A:middle
This is not what we want.

00:31:21.766 --> 00:31:23.226 A:middle
So one way around this is

00:31:23.286 --> 00:31:25.266 A:middle
to disable scrolling
with Apple Pencil.

00:31:25.616 --> 00:31:28.266 A:middle
This would be useful for
something like an annotation app

00:31:28.266 --> 00:31:31.376 A:middle
where you would always like to
just annotate with the Pencil

00:31:31.646 --> 00:31:33.566 A:middle
and specifically disable that.

00:31:33.746 --> 00:31:37.006 A:middle
You can do that because
we added allow touch types

00:31:37.006 --> 00:31:38.406 A:middle
to UIGestureRecognizer.

00:31:38.996 --> 00:31:44.346 A:middle
UITouch types is an array of
NSNumber of the touch types,

00:31:44.576 --> 00:31:47.276 A:middle
and it defaults to all
of the touch types.

00:31:47.716 --> 00:31:49.396 A:middle
So what we are going to do here

00:31:49.396 --> 00:31:52.556 A:middle
in this example is we would
get the pan GestureRecognizer

00:31:52.556 --> 00:31:56.686 A:middle
from our scroll view, we will
set the allow touch types

00:31:56.686 --> 00:32:00.456 A:middle
to only allow direct touches
so it only reacts to fingers,

00:31:56.686 --> 00:32:00.456 A:middle
to only allow direct touches
so it only reacts to fingers,

00:32:01.706 --> 00:32:05.436 A:middle
and we will change our stroke
recognizer to only allow stylus.

00:32:06.416 --> 00:32:08.606 A:middle
So this obviously is
not the full picture.

00:32:08.606 --> 00:32:10.866 A:middle
In the sample code, you
can see one implementation

00:32:10.866 --> 00:32:13.196 A:middle
but switches dynamically
depending on the usage

00:32:13.466 --> 00:32:14.876 A:middle
and is a little bit
more complicated,

00:32:15.216 --> 00:32:16.486 A:middle
but it illustrates the point

00:32:16.486 --> 00:32:19.736 A:middle
that you can restrict
your touch handling

00:32:19.736 --> 00:32:22.636 A:middle
to either the Pencil
or regular touches.

00:32:23.186 --> 00:32:28.116 A:middle
And one final note on this.

00:32:29.546 --> 00:32:32.136 A:middle
There's also a new property
on UIGestureRecognizer

00:32:32.136 --> 00:32:34.406 A:middle
that is called
requiresExclusiveTouchType,

00:32:35.306 --> 00:32:39.776 A:middle
and although our gesture
recognizers are defaulting

00:32:39.776 --> 00:32:44.446 A:middle
to all the touch types, if
they see one touch and begin

00:32:44.446 --> 00:32:47.026 A:middle
to recognize, they are
stuck in that touch type.

00:32:47.766 --> 00:32:50.526 A:middle
That is so you don't
accidentally pinch

00:32:50.526 --> 00:32:51.846 A:middle
with a Pencil and a finger.

00:32:51.846 --> 00:32:55.796 A:middle
This is the regularly what you
want from a UIGestureRecognizer.

00:32:56.026 --> 00:32:59.386 A:middle
If you don't want this, you set
the requiresExclusiveTouchTest,

00:32:59.536 --> 00:33:03.046 A:middle
type to force, and then
you can do recognition

00:32:59.536 --> 00:33:03.046 A:middle
type to force, and then
you can do recognition

00:33:03.046 --> 00:33:04.756 A:middle
between fingers and the Pencil.

00:33:05.436 --> 00:33:08.766 A:middle
So to summarize, I showed
you all the new properties

00:33:08.766 --> 00:33:12.646 A:middle
of UITouch so you can
make out of Apple Pencil.

00:33:13.166 --> 00:33:16.296 A:middle
I showed you how to use the
Coalesce and Predicted Touches

00:33:16.586 --> 00:33:20.206 A:middle
to both have the richest data
available to your drawing

00:33:20.466 --> 00:33:22.226 A:middle
and to have the least latency.

00:33:23.346 --> 00:33:26.316 A:middle
I told you about property
estimation, why we do it,

00:33:26.546 --> 00:33:28.856 A:middle
and how you actually
update your data to get

00:33:28.896 --> 00:33:34.116 A:middle
to the full rich data the Pencil
provides, and I showed you how

00:33:34.116 --> 00:33:39.316 A:middle
to adjust gestures to either
react to Pencil or finger only.

00:33:40.886 --> 00:33:45.336 A:middle
And this is a screenshot of the
sample app that is available

00:33:45.336 --> 00:33:48.616 A:middle
that does the nice
calligraphy pen as a default,

00:33:48.946 --> 00:33:50.856 A:middle
and more interesting to you,

00:33:51.006 --> 00:33:54.096 A:middle
it also has the debug mode
you have seen the videos made

00:33:54.096 --> 00:33:54.486 A:middle
of them.

00:33:54.726 --> 00:33:57.326 A:middle
So you can see how your
Coalesce Touches behave,

00:33:57.626 --> 00:34:02.046 A:middle
how they are estimated at
the edges, and see the tilt

00:33:57.626 --> 00:34:02.046 A:middle
how they are estimated at
the edges, and see the tilt

00:34:02.046 --> 00:34:07.106 A:middle
and azimuth, and just play
around with it to see how all

00:34:07.106 --> 00:34:08.416 A:middle
of our touch handling works.

00:34:09.016 --> 00:34:13.356 A:middle
So the full information of
this session is available

00:34:14.416 --> 00:34:15.386 A:middle
at this URL.

00:34:16.036 --> 00:34:19.335 A:middle
We have controlling game
input for Apple TV yesterday

00:34:19.335 --> 00:34:21.156 A:middle
for Siri remote handling.

00:34:21.686 --> 00:34:25.806 A:middle
A peek at 3D Touch will show you
all the higher level interaction

00:34:26.076 --> 00:34:30.826 A:middle
with the force in 3D Touch to a
Peek and Pop-like experiences,

00:34:31.295 --> 00:34:35.596 A:middle
and to get, to know more about
touch-to-display latency,

00:34:36.076 --> 00:34:38.295 A:middle
you should have a look
at advanced touch input

00:34:38.295 --> 00:34:39.886 A:middle
on iOS from last year.

00:34:40.606 --> 00:34:42.606 A:middle
And with that, that's it.

00:34:42.795 --> 00:34:43.536 A:middle
Thank you very much.
