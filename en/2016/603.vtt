WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:24.516 --> 00:00:30.326 A:middle
[ Applause ]

00:00:30.826 --> 00:00:33.046 A:middle
&gt;&gt; Hi, everyone,
and welcome to WWDC.

00:00:33.256 --> 00:00:34.766 A:middle
I hope you're all
having a good time so far

00:00:34.766 --> 00:00:36.376 A:middle
and you've had some nice
sessions you've seen.

00:00:36.376 --> 00:00:38.446 A:middle
We've got a great
week for you guys.

00:00:38.446 --> 00:00:39.456 A:middle
It's going to be really fun.

00:00:39.926 --> 00:00:40.656 A:middle
I'm Matt Collins.

00:00:40.656 --> 00:00:43.176 A:middle
This is my colleague Jared
Marsau and we're here

00:00:43.176 --> 00:00:45.206 A:middle
to talk Adopting Metal, Part 2.

00:00:45.456 --> 00:00:47.526 A:middle
This is Section 603.

00:00:48.066 --> 00:00:50.626 A:middle
So if you're in the wrong place,
you get to see some graphics.

00:00:53.506 --> 00:00:54.616 A:middle
So let's recap.

00:00:55.236 --> 00:00:56.676 A:middle
We have two Adopting
Metal Sessions.

00:00:56.676 --> 00:00:57.546 A:middle
Hopefully you were here

00:00:57.546 --> 00:00:59.816 A:middle
for Warren's presentation a
little bit ago, where we talked

00:00:59.816 --> 00:01:03.306 A:middle
about the fundamental concepts:
Basic drawing, lighting,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.816 --> 00:01:03.306 A:middle
about the fundamental concepts:
Basic drawing, lighting,

00:01:03.416 --> 00:01:04.995 A:middle
texturing, good stuff like that.

00:01:05.596 --> 00:01:06.776 A:middle
And in this presentation
we're going

00:01:06.776 --> 00:01:07.956 A:middle
to take it to the next level.

00:01:08.186 --> 00:01:09.786 A:middle
We're going to draw
many objects.

00:01:09.786 --> 00:01:12.436 A:middle
We're going to talk about
managing dynamic data,

00:01:12.436 --> 00:01:15.906 A:middle
large amounts of dynamic
data, GPU-CPU synchronization,

00:01:16.436 --> 00:01:19.206 A:middle
and we'll cap it off with
some multithreaded encoding.

00:01:20.136 --> 00:01:22.146 A:middle
Tomorrow we've got some
great presentations.

00:01:22.916 --> 00:01:24.716 A:middle
We'll talk about
what's new in Metal.

00:01:25.096 --> 00:01:28.816 A:middle
We'll have the first session,
tessellation, resource heaps,

00:01:28.816 --> 00:01:31.176 A:middle
memoryless frame
buffers, and some stuff

00:01:31.176 --> 00:01:32.336 A:middle
about our improved tools

00:01:32.436 --> 00:01:34.446 A:middle
to really help you guys get
the best out of your apps.

00:01:35.106 --> 00:01:37.696 A:middle
Part 2, we'll talk about
function specialization

00:01:37.696 --> 00:01:40.926 A:middle
and function resource
read-writes, wide color

00:01:40.926 --> 00:01:43.416 A:middle
and texture assets,
and additions

00:01:43.416 --> 00:01:44.796 A:middle
to Metal performance shaders.

00:01:45.526 --> 00:01:47.856 A:middle
And if you really
want to dig in heavy,

00:01:47.856 --> 00:01:50.676 A:middle
we'll have an awesome talk about
advanced shader optimization,

00:01:51.056 --> 00:01:53.956 A:middle
shader performance fundamentals,
tuning shader code,

00:01:54.266 --> 00:01:56.046 A:middle
more detailed about
how the hardware works.

00:01:56.076 --> 00:01:56.706 A:middle
It'll be great.

00:01:56.736 --> 00:01:59.096 A:middle
So if you're really interested
in tuning your shaders

00:01:59.096 --> 00:02:01.736 A:middle
to make them to best they can
be, check out that tomorrow.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.096 --> 00:02:01.736 A:middle
to make them to best they can
be, check out that tomorrow.

00:02:04.166 --> 00:02:08.056 A:middle
So this is Part 2 of Adopting
Metal and we're going to build

00:02:08.056 --> 00:02:09.476 A:middle
on what we learned in Part 1.

00:02:09.476 --> 00:02:11.486 A:middle
We figured out how to
get up and running.

00:02:12.266 --> 00:02:13.946 A:middle
So let's take a look at
the concepts that you need

00:02:14.076 --> 00:02:16.466 A:middle
to get the most out of Metal
in a real-world situation.

00:02:17.336 --> 00:02:20.546 A:middle
We've got a demo that will draw
a ton of stuff in a simple scene

00:02:20.726 --> 00:02:23.846 A:middle
and we'll use that demo for
context during today's session

00:02:23.846 --> 00:02:26.006 A:middle
as we discuss and learn
a couple lessons from it.

00:02:27.156 --> 00:02:30.056 A:middle
We'll talk about the ideal
organization flow of your data,

00:02:30.056 --> 00:02:33.076 A:middle
how to manage large chunks of
dynamic data, the importance

00:02:33.076 --> 00:02:36.456 A:middle
of synchronization between
the CPU and the GPU, and,

00:02:36.456 --> 00:02:38.866 A:middle
like I said before, some
multithreaded encoding.

00:02:38.906 --> 00:02:41.566 A:middle
So hopefully you're familiar
with the fundamentals of Metal

00:02:41.566 --> 00:02:42.976 A:middle
because we won't be
going over them again.

00:02:43.046 --> 00:02:46.226 A:middle
So we expect that you understand
how to create a Metal queue,

00:02:46.446 --> 00:02:50.336 A:middle
a Metal command buffer, how to
encode commands, and we'll build

00:02:50.336 --> 00:02:51.556 A:middle
on that to go forward.

00:02:52.886 --> 00:02:55.166 A:middle
So let's start with
the demo itself

00:02:55.906 --> 00:02:56.986 A:middle
and see what we're
aiming towards.

00:02:58.606 --> 00:03:01.116 A:middle
So right now we've
got 10,000 cubes


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.606 --> 00:03:01.116 A:middle
So right now we've
got 10,000 cubes

00:03:01.576 --> 00:03:04.316 A:middle
and they're all spinning
around, loading in space.

00:03:04.316 --> 00:03:05.576 A:middle
It's an interesting scene.

00:03:06.696 --> 00:03:08.706 A:middle
Metal allows us to issue
a ton of draw calls

00:03:08.706 --> 00:03:09.906 A:middle
with very low overhead.

00:03:10.236 --> 00:03:13.296 A:middle
So here we have 10,000
cubes and 10,000 draw calls.

00:03:14.066 --> 00:03:15.996 A:middle
You can see on the bottom
there's a little shadow.

00:03:15.996 --> 00:03:18.376 A:middle
We're using a shadow map,
playing on the bottom,

00:03:18.426 --> 00:03:21.056 A:middle
some nice anti-aliased lines
give you some depth cues,

00:03:21.696 --> 00:03:24.356 A:middle
and of course all of our cubes.

00:03:25.276 --> 00:03:27.486 A:middle
So what goes into
rendering a scene like this?

00:03:27.486 --> 00:03:29.856 A:middle
As you can see, we've got
a lot of objects and each

00:03:29.856 --> 00:03:33.036 A:middle
of these objects has its own
associated piece of unique data.

00:03:33.416 --> 00:03:36.506 A:middle
We need the position,
rotation, and color.

00:03:37.106 --> 00:03:38.356 A:middle
And this has to update
every frame

00:03:38.356 --> 00:03:39.386 A:middle
because we're animating them.

00:03:39.486 --> 00:03:42.026 A:middle
So this is a bunch of data
that we're constantly changing,

00:03:42.576 --> 00:03:44.956 A:middle
constantly have to reinform
the GPU what we're drawing.

00:03:46.156 --> 00:03:49.806 A:middle
We can also draw a few more
objects, maybe a little more.

00:03:50.956 --> 00:03:52.786 A:middle
You can spin it around
a little bit and see

00:03:52.786 --> 00:03:54.296 A:middle
that we're actually
floating in space.

00:03:54.296 --> 00:04:00.456 A:middle
So we have a draw call for cube
and a bunch of data for cube


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:54.296 --> 00:04:00.456 A:middle
So we have a draw call for cube
and a bunch of data for cube

00:04:00.656 --> 00:04:02.566 A:middle
and we have to think about
the best way to think

00:04:02.566 --> 00:04:04.346 A:middle
about this data,
how to manage it,

00:04:04.716 --> 00:04:07.976 A:middle
and how to communicate
it to the GPU.

00:04:08.236 --> 00:04:09.116 A:middle
So let's dive right in.

00:04:09.116 --> 00:04:09.976 A:middle
Thanks, Jared.

00:04:14.716 --> 00:04:17.315 A:middle
Managing Dynamic Data:
This is a huge chunk

00:04:17.315 --> 00:04:18.726 A:middle
of data that's changing
every frame.

00:04:18.966 --> 00:04:21.136 A:middle
And as you can imagine in
a modern app like a game,

00:04:21.516 --> 00:04:22.956 A:middle
you also have a bunch of data

00:04:22.956 --> 00:04:24.426 A:middle
that every frame
needs to be updated.

00:04:25.386 --> 00:04:27.346 A:middle
So our draw basically
looks like this.

00:04:27.656 --> 00:04:29.376 A:middle
We want to go through all
the objects we're interested

00:04:29.376 --> 00:04:30.766 A:middle
in drawing and update them.

00:04:31.756 --> 00:04:34.356 A:middle
Then we want to encode
draw calls for every object

00:04:34.956 --> 00:04:36.856 A:middle
and then we have to submit
all these GPU commands.

00:04:37.666 --> 00:04:38.916 A:middle
We have a lot of objects.

00:04:39.136 --> 00:04:40.856 A:middle
We started at 10,000
and we were cranking it

00:04:40.856 --> 00:04:43.316 A:middle
up to up to 100, 200,000.

00:04:44.086 --> 00:04:47.046 A:middle
Each of these objects has its
own set of data and we have

00:04:47.046 --> 00:04:48.746 A:middle
to figure out the best
way to update this.

00:04:49.146 --> 00:04:53.196 A:middle
Now in the past, you might've
done something like this.

00:04:54.226 --> 00:04:56.796 A:middle
You push updated data to
the GPU, maybe uniforms

00:04:56.796 --> 00:04:59.626 A:middle
or something, you bind
a shader, some buffers,

00:04:59.806 --> 00:05:01.106 A:middle
some textures, and you draw.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.806 --> 00:05:01.106 A:middle
some textures, and you draw.

00:05:01.886 --> 00:05:03.496 A:middle
And you push some more data up.

00:05:03.696 --> 00:05:05.416 A:middle
You bind shader,
buffers, textures.

00:05:05.416 --> 00:05:06.456 A:middle
You draw your next object.

00:05:07.016 --> 00:05:09.846 A:middle
In our scene we repeat
this 10,000, 20,000 times,

00:05:09.846 --> 00:05:12.346 A:middle
but we really want to get away
from this sort of paradigm

00:05:12.446 --> 00:05:13.356 A:middle
and try something new.

00:05:15.696 --> 00:05:17.996 A:middle
What if we could just
load all our data upfront

00:05:18.536 --> 00:05:20.866 A:middle
and have every command that
we issue reference the data

00:05:20.866 --> 00:05:21.646 A:middle
that was already there.

00:05:22.636 --> 00:05:24.886 A:middle
The GPU is a massively
powerful processer

00:05:24.956 --> 00:05:26.066 A:middle
and it does not like to wait.

00:05:27.086 --> 00:05:30.326 A:middle
So if all our data in already in
place, we can just point the GPU

00:05:30.326 --> 00:05:32.406 A:middle
to it and it will go
happily crunch away

00:05:32.526 --> 00:05:34.486 A:middle
and do all our rendering for us.

00:05:36.266 --> 00:05:40.016 A:middle
And each draw call we make then
references the appropriate data

00:05:40.016 --> 00:05:40.756 A:middle
that's already there.

00:05:41.786 --> 00:05:43.546 A:middle
In our sample, it's
very straightforward.

00:05:43.726 --> 00:05:46.046 A:middle
We have one draw that
references one chunk of data.

00:05:46.546 --> 00:05:48.506 A:middle
So the first draw call
references the first chunk

00:05:48.506 --> 00:05:51.706 A:middle
of data, the second, the
second chunk, and so on.

00:05:51.706 --> 00:05:53.736 A:middle
But it doesn't have
to be that way

00:05:53.966 --> 00:05:55.596 A:middle
and we can actually reuse data.

00:05:56.386 --> 00:05:58.786 A:middle
We have some data, like at
the front here, frame data,

00:05:59.706 --> 00:06:01.236 A:middle
that we can reference
from all our draw calls


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.706 --> 00:06:01.236 A:middle
that we can reference
from all our draw calls

00:06:02.066 --> 00:06:04.286 A:middle
or we could have a draw call
that references two pieces

00:06:04.286 --> 00:06:05.306 A:middle
of data in different places.

00:06:05.706 --> 00:06:07.416 A:middle
If you're familiar
with instancing,

00:06:07.416 --> 00:06:08.616 A:middle
it's a very similar idea.

00:06:09.166 --> 00:06:12.026 A:middle
All your data will be in place
before you start rendering.

00:06:12.556 --> 00:06:16.396 A:middle
So how do we do this in Metal?

00:06:16.696 --> 00:06:20.676 A:middle
In our application, we create
one single Metal buffer

00:06:20.966 --> 00:06:22.176 A:middle
and this is our constant buffer.

00:06:22.636 --> 00:06:24.836 A:middle
It holds all the data that
we need to render our frame.

00:06:25.146 --> 00:06:28.816 A:middle
We want to create this upfront,
outside of the rendering loop,

00:06:28.816 --> 00:06:30.286 A:middle
and reuse it every time we draw.

00:06:31.046 --> 00:06:32.306 A:middle
We don't duplicate any data.

00:06:32.866 --> 00:06:35.406 A:middle
Again, any draw call can
reference any piece of data,

00:06:36.006 --> 00:06:37.256 A:middle
so there's no need
for duplication.

00:06:38.486 --> 00:06:41.126 A:middle
Each draw call will reference
an offset into the buffer.

00:06:41.126 --> 00:06:43.006 A:middle
It'll do a little bit
of tracking to know

00:06:43.006 --> 00:06:44.806 A:middle
which draw represents
which offset.

00:06:45.306 --> 00:06:47.386 A:middle
And then you'll just
draw with everything

00:06:47.386 --> 00:06:48.436 A:middle
and everything will be in place.

00:06:49.136 --> 00:06:53.016 A:middle
Let's take a look at
the code for this.

00:06:53.216 --> 00:06:54.026 A:middle
Here's the code from the app.

00:06:54.806 --> 00:06:56.776 A:middle
You can think of us as
having two sets of data.

00:06:56.776 --> 00:06:59.206 A:middle
Like I mentioned before,
there's a set of frame data

00:06:59.206 --> 00:07:04.346 A:middle
that will update here
and there's a set of data


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.206 --> 00:07:04.346 A:middle
that will update here
and there's a set of data

00:07:04.346 --> 00:07:05.756 A:middle
that will change per object.

00:07:06.246 --> 00:07:08.506 A:middle
This is the unique rotation
position, et cetera.

00:07:09.146 --> 00:07:11.646 A:middle
So we need to put both
sets of data in place.

00:07:16.516 --> 00:07:18.706 A:middle
Now what do I mean
by per-frame data?

00:07:19.396 --> 00:07:20.846 A:middle
Well this is data
that is consistent

00:07:20.846 --> 00:07:22.306 A:middle
across every draw call we make.

00:07:23.306 --> 00:07:26.446 A:middle
For example, in our sample we
have a ViewProjection matrix.

00:07:26.496 --> 00:07:29.096 A:middle
It's a 4 by 4 matrix,
very straightforward,

00:07:29.096 --> 00:07:30.326 A:middle
if you're familiar
with graphics.

00:07:30.326 --> 00:07:32.736 A:middle
It represents the camera
transform and the projection.

00:07:33.446 --> 00:07:35.206 A:middle
This is not going to
change throughout our frame,

00:07:35.306 --> 00:07:36.676 A:middle
so we only need one copy of it.

00:07:37.496 --> 00:07:39.866 A:middle
And we'd like to reuse
data as much as we can

00:07:40.906 --> 00:07:44.366 A:middle
so we can create one copy
and put it into our buffer.

00:07:44.366 --> 00:07:46.946 A:middle
Let's start filling this out.

00:07:47.196 --> 00:07:50.046 A:middle
So here, we have
our constant buffer,

00:07:50.046 --> 00:07:51.676 A:middle
which is just a Metal
buffer we've created.

00:07:52.076 --> 00:07:54.526 A:middle
And with the Contents function,
we have a pointer to it.

00:07:58.546 --> 00:08:01.426 A:middle
Our app has a helper function,
which is GetFrameData,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.546 --> 00:08:01.426 A:middle
Our app has a helper function,
which is GetFrameData,

00:08:01.516 --> 00:08:04.046 A:middle
and this returns that main pass
structure I just showed you

00:08:04.476 --> 00:08:05.906 A:middle
that has the view
transform in it,

00:08:06.126 --> 00:08:07.496 A:middle
the ViewProjection transform.

00:08:07.496 --> 00:08:07.956 A:middle
Excuse me.

00:08:08.416 --> 00:08:11.266 A:middle
And then we simply just
copy this into the start

00:08:11.266 --> 00:08:13.706 A:middle
of our buffer and
then we're in place.

00:08:15.086 --> 00:08:16.416 A:middle
So our buffer will
look like this.

00:08:16.536 --> 00:08:19.176 A:middle
We'll have a MainPass with the
appropriate data for our frame

00:08:20.056 --> 00:08:22.246 A:middle
and we'll put it at the start
of our giant constant buffer.

00:08:23.546 --> 00:08:25.656 A:middle
So now we have all this
empty space afterwards.

00:08:25.986 --> 00:08:29.486 A:middle
And like we saw, we need to
do 10,000, 20,000 draw calls,

00:08:29.826 --> 00:08:31.926 A:middle
so we need to start filling this
out with a ton of information.

00:08:32.436 --> 00:08:36.976 A:middle
So then we have a set
of per-object data

00:08:37.556 --> 00:08:40.086 A:middle
and this is the unique data we
need to draw a single object.

00:08:40.905 --> 00:08:43.626 A:middle
In our case, we have a single
LocalToWorld transform,

00:08:43.626 --> 00:08:46.136 A:middle
which is the concatenation of
the position and the rotation

00:08:46.686 --> 00:08:47.426 A:middle
and we have the color.

00:08:47.426 --> 00:08:51.336 A:middle
So this is the set of data
we need per draw call.

00:08:56.086 --> 00:08:58.606 A:middle
So we'll walk through every
object we want to render.

00:08:59.596 --> 00:09:01.306 A:middle
We'll keep track of the
offset into the buffer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.596 --> 00:09:01.306 A:middle
We'll keep track of the
offset into the buffer.

00:09:02.306 --> 00:09:04.196 A:middle
We have our updateData
utility function,

00:09:04.196 --> 00:09:06.416 A:middle
which will do our little
update for our rotation,

00:09:06.486 --> 00:09:07.866 A:middle
and then we'll update
the offset.

00:09:07.866 --> 00:09:09.736 A:middle
This will pack our data tightly

00:09:09.736 --> 00:09:11.086 A:middle
and we'll fill it
out as we go through.

00:09:11.786 --> 00:09:14.326 A:middle
Let's take a closer look at
what updateData looks like.

00:09:14.856 --> 00:09:17.156 A:middle
It's quite simple.

00:09:19.036 --> 00:09:22.256 A:middle
Now, animation is kind of out
of the scope of this talk,

00:09:23.016 --> 00:09:24.546 A:middle
so I have a little helper
function here that's

00:09:24.546 --> 00:09:26.266 A:middle
updateAnimation with
a deltaTime.

00:09:26.866 --> 00:09:28.986 A:middle
This could be whatever you
want in your own application

00:09:28.986 --> 00:09:31.056 A:middle
and indeed you should but
depending on what sort

00:09:31.056 --> 00:09:31.866 A:middle
of animation you need.

00:09:32.396 --> 00:09:35.886 A:middle
But it my case it returns
an objectData object

00:09:36.346 --> 00:09:38.366 A:middle
which has the LocalToWorld
transform and the color.

00:09:39.456 --> 00:09:42.976 A:middle
And just as I did before, I
copy it into my constant buffer.

00:09:48.446 --> 00:09:49.756 A:middle
So here's what that looks like.

00:09:50.436 --> 00:09:55.856 A:middle
I've got my frame data in place.

00:09:56.036 --> 00:10:01.446 A:middle
I have my other data, another
piece, and another piece.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:56.036 --> 00:10:01.446 A:middle
I have my other data, another
piece, and another piece.

00:10:02.646 --> 00:10:05.346 A:middle
So all our data is in place
and we're ready for rendering.

00:10:05.996 --> 00:10:06.976 A:middle
But are we missing anything?

00:10:10.376 --> 00:10:12.766 A:middle
Turns out that we are and I want
to bring your attention to this.

00:10:13.286 --> 00:10:14.496 A:middle
We have one constant buffer.

00:10:14.786 --> 00:10:17.386 A:middle
I mentioned I created one Metal
buffer and I was reusing it.

00:10:17.876 --> 00:10:19.686 A:middle
Now there's a problem with this.

00:10:19.806 --> 00:10:23.726 A:middle
The CPU and the GPU are actually
two unique parallel processors.

00:10:24.096 --> 00:10:26.256 A:middle
They can read and write the
same memory at the same time.

00:10:27.156 --> 00:10:29.726 A:middle
So what happens when you have
something reading to a piece

00:10:29.726 --> 00:10:31.966 A:middle
of memory while something
else is writing to it?

00:10:35.216 --> 00:10:35.976 A:middle
Resource contention.

00:10:38.706 --> 00:10:40.286 A:middle
So it looks a little like this.

00:10:40.936 --> 00:10:43.846 A:middle
The CPU prepares a frame
and writes it to a buffer.

00:10:45.496 --> 00:10:50.406 A:middle
The GPU starts working on this
and reads from the buffer.

00:10:51.426 --> 00:10:53.076 A:middle
The CPU doesn't know
anything about this,

00:10:53.436 --> 00:10:55.326 A:middle
so it decides I'm going
to prepare the next frame

00:10:55.416 --> 00:10:57.066 A:middle
and it starts overwriting
the same data.

00:10:59.286 --> 00:11:01.056 A:middle
And now our results
are undefined.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.286 --> 00:11:01.056 A:middle
And now our results
are undefined.

00:11:01.116 --> 00:11:03.556 A:middle
We don't actually know what
we're reading to, reading from,

00:11:03.556 --> 00:11:05.596 A:middle
or writing to or what
the data state will be.

00:11:08.486 --> 00:11:10.276 A:middle
So it's important
to realize in Metal,

00:11:10.276 --> 00:11:11.946 A:middle
this is not handled
for you implicitly.

00:11:12.516 --> 00:11:14.366 A:middle
The CPU and GPU can
write the same data

00:11:14.366 --> 00:11:16.486 A:middle
at the same time
however they'd like.

00:11:16.986 --> 00:11:18.756 A:middle
You must synchronize
access yourself.

00:11:19.596 --> 00:11:21.876 A:middle
It's just like writing CPU
code that's multithreaded.

00:11:22.646 --> 00:11:24.706 A:middle
You have to ensure you're
not stomping yourself.

00:11:28.306 --> 00:11:31.616 A:middle
And that brings us to
CPU-GPU synchronization.

00:11:32.206 --> 00:11:33.016 A:middle
Let's start simple.

00:11:34.856 --> 00:11:38.056 A:middle
The easiest way to do this
would to just be to wait

00:11:38.206 --> 00:11:40.076 A:middle
after you've submitted
commands to the GPU.

00:11:41.016 --> 00:11:42.976 A:middle
Your CPU draw function
does all of its work,

00:11:43.106 --> 00:11:45.176 A:middle
submits the commands,
and then just sits there

00:11:45.176 --> 00:11:47.386 A:middle
until it's ensured the
GPU is done working.

00:11:48.746 --> 00:11:50.596 A:middle
That way we know we
won't ever override it

00:11:50.596 --> 00:11:52.766 A:middle
because the GPU will be
idle by the time we try

00:11:52.766 --> 00:11:53.796 A:middle
to generate our next frame.

00:11:55.066 --> 00:11:56.856 A:middle
This won't be fast
but it's safe.

00:11:57.306 --> 00:11:59.416 A:middle
So we need some sort of
mechanism for the GPU

00:11:59.416 --> 00:12:04.156 A:middle
to let us know, hey, I'm done
with this, go do your thing.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.416 --> 00:12:04.156 A:middle
to let us know, hey, I'm done
with this, go do your thing.

00:12:04.376 --> 00:12:06.296 A:middle
Metal provides this in
the form of callbacks.

00:12:06.896 --> 00:12:08.666 A:middle
We call them handlers
and there are two of them

00:12:08.666 --> 00:12:11.756 A:middle
that are interesting,
addScheduledHandler

00:12:12.206 --> 00:12:15.346 A:middle
and that executes when a command
buffer has been scheduled

00:12:15.346 --> 00:12:16.636 A:middle
to run on the GPU.

00:12:17.176 --> 00:12:20.956 A:middle
And for us, an even more
interesting one is the

00:12:20.956 --> 00:12:23.706 A:middle
completion handler
and this is called

00:12:23.706 --> 00:12:26.056 A:middle
when the GPU has finished
executing a command buffer.

00:12:26.496 --> 00:12:29.476 A:middle
The command buffer is completely
retired and we're ensured

00:12:29.476 --> 00:12:31.986 A:middle
at this point it's safe to
modify whatever resources

00:12:31.986 --> 00:12:32.856 A:middle
that we were using there.

00:12:33.356 --> 00:12:34.856 A:middle
So this is perfect.

00:12:34.976 --> 00:12:37.406 A:middle
We just need some way to
signal ourselves that, hey,

00:12:37.406 --> 00:12:38.946 A:middle
we're done, we can go forward.

00:12:39.326 --> 00:12:44.486 A:middle
Now how many of you are familiar
with the concept of a semaphore?

00:12:45.266 --> 00:12:47.736 A:middle
Anyone? Pretty good.

00:12:48.806 --> 00:12:50.086 A:middle
Quick background on semaphores.

00:12:50.086 --> 00:12:52.296 A:middle
They are synchronization
primitive and they're used

00:12:52.296 --> 00:12:54.196 A:middle
to control access to
a limited resource

00:12:54.436 --> 00:12:55.966 A:middle
and that fits us perfectly here.

00:12:56.506 --> 00:12:59.976 A:middle
We have one constant buffer
and that's a limited resource,

00:12:59.976 --> 00:13:01.336 A:middle
so we'll have a semaphore


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.976 --> 00:13:01.336 A:middle
so we'll have a semaphore

00:13:01.336 --> 00:13:03.046 A:middle
and we'll create it
with a value of 1.

00:13:03.446 --> 00:13:05.796 A:middle
The count on a semaphore
represents how many resources

00:13:05.796 --> 00:13:06.506 A:middle
we're trying to protect.

00:13:08.286 --> 00:13:09.696 A:middle
So we'll create our semaphore.

00:13:09.696 --> 00:13:10.536 A:middle
And again, this is something

00:13:10.536 --> 00:13:12.326 A:middle
that should be created
outside of your render loop.

00:13:13.286 --> 00:13:14.726 A:middle
And the first thing
we do once we start

00:13:14.726 --> 00:13:17.546 A:middle
to draw is we wait
on the semaphore.

00:13:19.006 --> 00:13:21.176 A:middle
Now in Apple semaphore,
we call it waiting.

00:13:21.256 --> 00:13:22.436 A:middle
Some people call this taking.

00:13:22.476 --> 00:13:23.346 A:middle
Some people call it downing.

00:13:23.346 --> 00:13:24.146 A:middle
It doesn't really matter.

00:13:24.836 --> 00:13:27.546 A:middle
The idea is that you wait
on it and our timeout we set

00:13:27.546 --> 00:13:28.346 A:middle
to distant future,

00:13:28.796 --> 00:13:30.416 A:middle
which effectively means
we'll wait forever.

00:13:30.636 --> 00:13:32.716 A:middle
Our thread will go to sleep
if there's nothing available

00:13:32.856 --> 00:13:34.506 A:middle
and wait for something to do.

00:13:36.176 --> 00:13:37.136 A:middle
When we're done,

00:13:37.796 --> 00:13:39.936 A:middle
in our completion handler we
will signal the semaphore.

00:13:40.956 --> 00:13:43.816 A:middle
That'll tell us that it's safe
to modify the resources again.

00:13:44.036 --> 00:13:47.376 A:middle
We're completely done with
it and we can go forward.

00:13:47.836 --> 00:13:52.536 A:middle
So this is sort of a naive
approach to synchronization

00:13:52.536 --> 00:13:55.026 A:middle
but it looks a little like this.

00:13:55.316 --> 00:13:56.766 A:middle
Frame 0 we'll write
into the buffer.

00:13:57.316 --> 00:14:00.906 A:middle
And on the GPU, we'll
read from the buffer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.316 --> 00:14:00.906 A:middle
And on the GPU, we'll
read from the buffer.

00:14:01.126 --> 00:14:02.066 A:middle
The CPU will wait.

00:14:02.686 --> 00:14:04.756 A:middle
When the GPU is done
processing Fame 0,

00:14:05.196 --> 00:14:08.626 A:middle
it will send the completion
handler and frame 1 will work

00:14:09.716 --> 00:14:11.446 A:middle
and create another
frame on the CPU.

00:14:11.966 --> 00:14:14.816 A:middle
And that will process
on the GPU and so on.

00:14:16.016 --> 00:14:18.076 A:middle
So this works but,
as you can see here,

00:14:18.076 --> 00:14:20.596 A:middle
we have all these
waits and both the CPU

00:14:20.596 --> 00:14:22.426 A:middle
and GPU are actually
idle half the time.

00:14:22.696 --> 00:14:24.946 A:middle
It doesn't seem like a good
use of our computing resources.

00:14:27.256 --> 00:14:30.586 A:middle
What we'd like to do is overlap
the CPU and the GPU work.

00:14:31.316 --> 00:14:33.226 A:middle
That way we can actually
leverage the parallelism that's

00:14:33.226 --> 00:14:35.546 A:middle
inherent in this
system, but we still need

00:14:35.546 --> 00:14:37.116 A:middle
to somehow avoid
stomping our data.

00:14:39.986 --> 00:14:42.336 A:middle
So we'd like our ideal
workload to look like this.

00:14:43.956 --> 00:14:47.196 A:middle
Frame 0 would be prepared on
the CPU, pushed to the GPU.

00:14:47.626 --> 00:14:50.136 A:middle
While the GPU is processing
it, the CPU then gets

00:14:50.136 --> 00:14:54.466 A:middle
to work creating frame
1 and so on, and again.

00:14:56.256 --> 00:14:58.696 A:middle
So one thing to keep
in mind here is

00:14:58.696 --> 00:15:01.476 A:middle
that the CPU is actually getting
a little ahead of the GPU.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.696 --> 00:15:01.476 A:middle
that the CPU is actually getting
a little ahead of the GPU.

00:15:01.686 --> 00:15:03.866 A:middle
If you notice where
frame 2 is on the CPU,

00:15:05.266 --> 00:15:07.676 A:middle
frame 0 is the only thing
that's done on the GPU.

00:15:07.676 --> 00:15:09.366 A:middle
So we're a little bit ahead
and I want you to keep

00:15:09.366 --> 00:15:11.026 A:middle
that in mind for a little later.

00:15:12.476 --> 00:15:13.776 A:middle
But first let's talk
about our solution

00:15:13.776 --> 00:15:15.356 A:middle
in the demo and what we do here.

00:15:16.686 --> 00:15:19.796 A:middle
We'd like to overlap our CPU and
GPU but we know we can't do it

00:15:19.796 --> 00:15:21.586 A:middle
with one constant buffer
without waiting a lot.

00:15:22.046 --> 00:15:24.456 A:middle
So our solution is to
create a pool of buffers.

00:15:24.996 --> 00:15:30.036 A:middle
So when we create a frame,
we write into one buffer

00:15:30.036 --> 00:15:32.276 A:middle
and then our CPU proceeds

00:15:32.276 --> 00:15:35.066 A:middle
to create the next frame while
writing into another buffer.

00:15:36.296 --> 00:15:38.646 A:middle
While it's doing this, the GPU
is free to read from the buffer

00:15:38.646 --> 00:15:40.106 A:middle
that was produced before.

00:15:40.656 --> 00:15:43.476 A:middle
Now we don't have an
infinite number of buffers

00:15:43.476 --> 00:15:44.786 A:middle
because we don't
have infinite memory.

00:15:45.116 --> 00:15:46.376 A:middle
So our pool has to have a limit.

00:15:47.026 --> 00:15:48.516 A:middle
On our application,
we've chosen three.

00:15:49.356 --> 00:15:51.156 A:middle
This is something that you
need to decide for yourself.

00:15:51.156 --> 00:15:53.856 A:middle
We can't tell you what to
do because there are a lot

00:15:53.856 --> 00:15:55.996 A:middle
of things that go into
the latency consideration,

00:15:56.286 --> 00:15:57.596 A:middle
how much memory you want to use.

00:15:58.196 --> 00:16:00.826 A:middle
So we recommend you experiment
with your app what fits for you.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.196 --> 00:16:00.826 A:middle
So we recommend you experiment
with your app what fits for you.

00:16:01.846 --> 00:16:03.536 A:middle
For this example,
we've chosen three.

00:16:05.696 --> 00:16:08.666 A:middle
So here, you can see
we've exhausted our pool.

00:16:08.666 --> 00:16:10.236 A:middle
We have three frames
that have been prepared

00:16:10.236 --> 00:16:11.746 A:middle
but only one is finished
on the GPU.

00:16:12.046 --> 00:16:15.406 A:middle
So we need to wait a little bit.

00:16:15.606 --> 00:16:18.526 A:middle
But by now, frame 0 is done,
so we can reuse the buffer

00:16:18.526 --> 00:16:20.676 A:middle
from the pool and so on.

00:16:28.026 --> 00:16:29.426 A:middle
So let's look at this in code.

00:16:30.436 --> 00:16:32.406 A:middle
Here's synchronizing
access to constant buffers.

00:16:32.796 --> 00:16:35.006 A:middle
We've already got a
semaphore and they're great

00:16:35.006 --> 00:16:37.096 A:middle
for controlling access
to limited resources.

00:16:37.146 --> 00:16:38.406 A:middle
In this case our limit is three

00:16:38.856 --> 00:16:40.106 A:middle
but it can be whatever
you'd like.

00:16:41.296 --> 00:16:43.526 A:middle
So here we create our
semaphore with our count.

00:16:44.306 --> 00:16:46.296 A:middle
And instead of creating
one constant buffer,

00:16:46.686 --> 00:16:50.196 A:middle
we now create an array of them.

00:16:50.346 --> 00:16:54.846 A:middle
And lastly, we need an index
and we'll use this index

00:16:54.846 --> 00:16:56.926 A:middle
to represent the currently
available constant buffer

00:16:56.926 --> 00:16:57.856 A:middle
for us to use.

00:16:58.326 --> 00:17:00.336 A:middle
We can walk through the
array and wrap around


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.326 --> 00:17:00.336 A:middle
We can walk through the
array and wrap around

00:17:00.526 --> 00:17:03.036 A:middle
and the semaphore will control
our access and protect us.

00:17:06.856 --> 00:17:09.596 A:middle
So in our draw function,
we'll immediately wait

00:17:09.596 --> 00:17:11.996 A:middle
on the semaphore, and if
there's nothing available,

00:17:11.996 --> 00:17:12.726 A:middle
we'll go to sleep.

00:17:14.086 --> 00:17:16.496 A:middle
Once we've taken the semaphore
and proceeded, we know it's safe

00:17:16.496 --> 00:17:19.276 A:middle
for us to grab the
current constant buffer.

00:17:19.276 --> 00:17:21.266 A:middle
In our index, current
constant buffer is tracking

00:17:21.266 --> 00:17:22.036 A:middle
which one's available.

00:17:23.406 --> 00:17:26.205 A:middle
Then we fill out our frame as
normal, encode all our commands,

00:17:26.546 --> 00:17:29.126 A:middle
do all our updates, add
the completion handler,

00:17:29.746 --> 00:17:32.346 A:middle
and then we'll signal the
semaphore, saying, hey,

00:17:32.346 --> 00:17:33.186 A:middle
we're done with this frame.

00:17:33.536 --> 00:17:34.256 A:middle
You can go forward.

00:17:34.996 --> 00:17:38.146 A:middle
And the last thing we need
to do is update the index.

00:17:39.216 --> 00:17:39.916 A:middle
We'll add one.

00:17:39.966 --> 00:17:41.416 A:middle
We'll use modulo to wrap around.

00:17:42.106 --> 00:17:43.346 A:middle
And don't worry, we
don't have to worry

00:17:43.346 --> 00:17:44.396 A:middle
about overwriting ourselves

00:17:44.396 --> 00:17:48.546 A:middle
because the semaphore
will protect us.

00:17:48.796 --> 00:17:50.386 A:middle
So constant buffers in the demo.

00:17:51.076 --> 00:17:52.646 A:middle
The demo has an array
of three buffers

00:17:53.336 --> 00:17:55.506 A:middle
and I've seen some
applications track buffers

00:17:55.506 --> 00:17:57.286 A:middle
by marking them as,
oh, this is being read

00:17:57.286 --> 00:17:59.626 A:middle
from in frame number
7, this is written

00:17:59.626 --> 00:18:00.636 A:middle
to you in frame number 5.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.626 --> 00:18:00.636 A:middle
to you in frame number 5.

00:18:00.636 --> 00:18:03.116 A:middle
But with this model you don't
actually have to do that.

00:18:03.346 --> 00:18:05.696 A:middle
The semaphore takes care of all
the synchronization for you.

00:18:07.016 --> 00:18:09.126 A:middle
And if you can take the
semaphore, you're guaranteed

00:18:09.126 --> 00:18:10.956 A:middle
that the last frame that
was using that was done,

00:18:11.166 --> 00:18:12.276 A:middle
otherwise you'd still be asleep.

00:18:14.406 --> 00:18:17.616 A:middle
So now all our data is in
place and it's protected.

00:18:17.946 --> 00:18:22.086 A:middle
And we'd like to start
issuing a bunch of draw calls

00:18:22.246 --> 00:18:23.306 A:middle
to get some stuff on the screen.

00:18:26.806 --> 00:18:29.446 A:middle
So here's the basic
rendering loop for our demo.

00:18:29.986 --> 00:18:33.476 A:middle
We have two passes: One
pass that draws a shadow map

00:18:33.916 --> 00:18:36.596 A:middle
and one pass that reads the
shadow map, and we've decided

00:18:36.596 --> 00:18:38.636 A:middle
to split these into two
separate command buffers.

00:18:39.266 --> 00:18:40.396 A:middle
There's a good reason for this.

00:18:40.866 --> 00:18:42.816 A:middle
It lets us have two
encoding functions

00:18:43.136 --> 00:18:44.446 A:middle
that are independent and unique.

00:18:45.056 --> 00:18:46.156 A:middle
They don't depend on each other.

00:18:46.786 --> 00:18:47.906 A:middle
You encode the shadow pass.

00:18:47.906 --> 00:18:50.466 A:middle
You pass that to command
buffer and the constant buffer

00:18:50.466 --> 00:18:53.096 A:middle
that you've already filled out
and it encodes all the commands

00:18:53.096 --> 00:18:54.446 A:middle
to render the shadow map.

00:18:55.216 --> 00:18:56.766 A:middle
And then you have a
separate encoding function

00:18:56.766 --> 00:18:57.956 A:middle
that encodes the main pass.

00:18:58.366 --> 00:19:00.916 A:middle
You pass it to mainCommandBuffer
and the other data you need


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.366 --> 00:19:00.916 A:middle
You pass it to mainCommandBuffer
and the other data you need

00:19:00.916 --> 00:19:02.476 A:middle
and it encodes all
those other commands.

00:19:03.126 --> 00:19:05.826 A:middle
When the encoding is all
done, you call commit

00:19:06.246 --> 00:19:08.756 A:middle
on your two command
buffers, push them off,

00:19:08.996 --> 00:19:10.316 A:middle
and then you've got your frame.

00:19:13.866 --> 00:19:16.496 A:middle
So what goes into actually
encoding drawing one

00:19:16.496 --> 00:19:17.216 A:middle
of our cubes?

00:19:17.756 --> 00:19:20.506 A:middle
We need a bunch of data and
not just the rotation data.

00:19:21.296 --> 00:19:23.006 A:middle
We need some geometric
data for the cubes,

00:19:23.456 --> 00:19:26.006 A:middle
which is quite simple, you know,
think about a cube is what,

00:19:26.006 --> 00:19:27.836 A:middle
eight vertices, maybe
an index buffer.

00:19:28.466 --> 00:19:31.526 A:middle
And in our sample, we don't
really have complex materials

00:19:31.526 --> 00:19:33.946 A:middle
or anything, just some very
simple Lambert shading.

00:19:34.416 --> 00:19:36.696 A:middle
So we could reuse that
pipeline state object

00:19:36.816 --> 00:19:37.956 A:middle
across all of our cubes.

00:19:38.526 --> 00:19:40.666 A:middle
We mentioned the
per-frame data earlier.

00:19:40.666 --> 00:19:41.796 A:middle
We need one copy of that.

00:19:42.256 --> 00:19:42.996 A:middle
So we'll update it.

00:19:43.116 --> 00:19:44.006 A:middle
Stick it in place.

00:19:44.466 --> 00:19:46.576 A:middle
And then of course we
need the per-object data,

00:19:47.096 --> 00:19:49.196 A:middle
that LocalToWorld and
the color information

00:19:49.196 --> 00:19:49.946 A:middle
that we're animating.

00:19:50.126 --> 00:19:54.016 A:middle
So when we issue our draw calls,

00:19:54.386 --> 00:19:56.556 A:middle
we want to make sure we
reference the correct data.

00:19:57.336 --> 00:19:59.326 A:middle
So our encoder will
produce commands,

00:19:59.446 --> 00:20:00.656 A:middle
put them into our
command buffer,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.446 --> 00:20:00.656 A:middle
put them into our
command buffer,

00:20:01.186 --> 00:20:04.986 A:middle
draw call 0 will reference both
the frame data and the object

00:20:04.986 --> 00:20:05.756 A:middle
that we're interested in.

00:20:06.876 --> 00:20:09.416 A:middle
Draw call 1, similarly, will
reference the frame data

00:20:10.386 --> 00:20:13.906 A:middle
and the object 1 data and so on.

00:20:14.196 --> 00:20:15.366 A:middle
This way everything's in place.

00:20:15.366 --> 00:20:18.416 A:middle
We issue our calls and the
GPU will start crunching away.

00:20:20.556 --> 00:20:22.526 A:middle
Now we have a ton of
draw calls to issue.

00:20:22.526 --> 00:20:25.466 A:middle
You know, in our demo,
it was minimal, 10,000,

00:20:26.276 --> 00:20:28.526 A:middle
and we want to issue these
as efficiently as possible.

00:20:28.766 --> 00:20:31.256 A:middle
So we'd like to avoid
doing redundant work.

00:20:31.716 --> 00:20:33.516 A:middle
We don't want to reset
everything every draw.

00:20:33.926 --> 00:20:37.086 A:middle
Anything that's shared,
geometry, pipeline states,

00:20:37.446 --> 00:20:40.066 A:middle
we'd like to set that once
and leave that in place.

00:20:40.936 --> 00:20:42.776 A:middle
So avoid redundant state updates

00:20:42.976 --> 00:20:45.116 A:middle
and avoid redundant
argument table updates.

00:20:46.116 --> 00:20:48.456 A:middle
It's also worth keeping
in mind that the vertex

00:20:48.456 --> 00:20:51.136 A:middle
and fragment stage argument
tables are completely separate.

00:20:52.036 --> 00:20:54.446 A:middle
You can bind a buffer to
the vertex stage and not

00:20:54.446 --> 00:20:55.906 A:middle
to the fragment stage
or vice-versa.

00:20:56.526 --> 00:20:58.336 A:middle
But if you have to bind
everything to both stages,

00:20:58.336 --> 00:21:01.226 A:middle
this can potentially double
the calls you call the


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.336 --> 00:21:01.226 A:middle
this can potentially double
the calls you call the

00:21:01.226 --> 00:21:02.916 A:middle
setVertexBuffer,
setFragmentBuffer.

00:21:03.626 --> 00:21:06.496 A:middle
This is one reason we didn't use
set vertex bytes in our example.

00:21:07.286 --> 00:21:10.406 A:middle
You can imagine we have
50,000 objects and we had

00:21:10.406 --> 00:21:14.036 A:middle
to make a copy of all that data
twice, once for the vertex stage

00:21:14.036 --> 00:21:15.166 A:middle
and once for the fragment stage.

00:21:15.446 --> 00:21:16.716 A:middle
That would quickly
get really big.

00:21:17.606 --> 00:21:19.536 A:middle
But if we kept it all in one
buffer and just referenced it,

00:21:19.886 --> 00:21:21.066 A:middle
we wouldn't have to
worry about that.

00:21:21.706 --> 00:21:23.556 A:middle
And the last guideline
I want to point

00:21:23.556 --> 00:21:25.786 A:middle
out is using a new function,

00:21:26.836 --> 00:21:30.036 A:middle
setVertexBufferOffset/
setFragmentBufferOffset.

00:21:31.066 --> 00:21:34.276 A:middle
This merely changes the pointer
into one of your buffers.

00:21:36.556 --> 00:21:38.396 A:middle
So you can see here
when you call these,

00:21:38.786 --> 00:21:40.926 A:middle
they actually don't take a
reference to a Metal buffer.

00:21:41.396 --> 00:21:44.376 A:middle
They take an offset
and an index.

00:21:45.116 --> 00:21:47.086 A:middle
This is because you must
have already set the buffer

00:21:47.086 --> 00:21:49.996 A:middle
to that specific point and
this just changes the pointer

00:21:49.996 --> 00:21:52.206 A:middle
within it and that's
perfect for what we want.

00:21:52.736 --> 00:21:55.156 A:middle
We have one constant buffer and
we're just walking through it.

00:21:55.736 --> 00:21:57.316 A:middle
So we can set it
once in the beginning

00:21:57.746 --> 00:22:00.916 A:middle
and then every time we draw,
we call setVertexBufferOffset


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.746 --> 00:22:00.916 A:middle
and then every time we draw,
we call setVertexBufferOffset

00:22:01.426 --> 00:22:02.866 A:middle
and just point the
next draw call

00:22:02.866 --> 00:22:04.336 A:middle
to the current spot
in our buffer.

00:22:04.826 --> 00:22:06.376 A:middle
It looks a little
something like this.

00:22:07.296 --> 00:22:08.636 A:middle
We bind this constant buffer

00:22:09.286 --> 00:22:11.196 A:middle
and then we call
setVertexBufferOffset

00:22:12.296 --> 00:22:12.976 A:middle
with this offset.

00:22:14.376 --> 00:22:16.806 A:middle
Then we call it again
striding it forward

00:22:18.046 --> 00:22:19.546 A:middle
and again striding it forward.

00:22:20.186 --> 00:22:22.716 A:middle
We're not changing the buffer
that we've set to this index.

00:22:22.876 --> 00:22:24.856 A:middle
We're just changing the
offset within that buffer.

00:22:27.856 --> 00:22:29.376 A:middle
With these guidelines in mind,

00:22:29.736 --> 00:22:31.496 A:middle
our encoding is actually
pretty simple.

00:22:33.416 --> 00:22:35.216 A:middle
We have a bunch of data
we can set up front.

00:22:35.646 --> 00:22:37.406 A:middle
The per-frame constants
is pretty obvious

00:22:37.466 --> 00:22:38.926 A:middle
because we know we're
not going to change it.

00:22:39.136 --> 00:22:41.246 A:middle
So we'll set that.

00:22:41.376 --> 00:22:43.966 A:middle
We'll set the constant buffer
once because we know it has

00:22:43.966 --> 00:22:47.086 A:middle
to be in place for us to use the
setVertexBufferOffset function.

00:22:47.166 --> 00:22:51.616 A:middle
We'll set the geometry
buffer and the pipeline state

00:22:51.736 --> 00:22:53.636 A:middle
because we know they're shared
across all of our cubes.

00:22:55.376 --> 00:22:57.046 A:middle
Then finally we can
start looping

00:22:57.046 --> 00:22:58.476 A:middle
through all the objects
we want to draw.

00:22:58.796 --> 00:23:01.936 A:middle
We'll set the offset
into the constant buffer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.796 --> 00:23:01.936 A:middle
We'll set the offset
into the constant buffer

00:23:01.936 --> 00:23:02.766 A:middle
for our current draw.

00:23:03.276 --> 00:23:06.386 A:middle
And then we'll actually
issue the draw.

00:23:11.076 --> 00:23:13.946 A:middle
And here's the code from the
encode main pass function

00:23:14.236 --> 00:23:14.786 A:middle
in the sample.

00:23:16.176 --> 00:23:18.316 A:middle
We'll start off by
setting the vertex buffer

00:23:18.316 --> 00:23:20.826 A:middle
that is our geometry and
the render pipeline state,

00:23:21.196 --> 00:23:22.766 A:middle
which is our
litShadowedPipeline.

00:23:23.256 --> 00:23:26.256 A:middle
We'll set the constant buffer

00:23:26.306 --> 00:23:28.276 A:middle
so we can use
setVertexBufferOffset later.

00:23:28.556 --> 00:23:30.916 A:middle
In this case we're setting
it to both the vertex

00:23:30.916 --> 00:23:32.016 A:middle
and the fragment stages.

00:23:32.606 --> 00:23:38.196 A:middle
And then we'll set
the per-frame data.

00:23:38.366 --> 00:23:40.276 A:middle
Now you'll notice here that
I've set the constant buffer

00:23:40.276 --> 00:23:43.236 A:middle
to two separate indices
with different offsets.

00:23:43.336 --> 00:23:45.246 A:middle
And Metal allows you to do
this as much as you want.

00:23:45.836 --> 00:23:48.376 A:middle
You could set the same
constant buffer to every index

00:23:48.566 --> 00:23:51.036 A:middle
at a different offset if you'd
like, completely up to you.

00:23:53.616 --> 00:23:55.296 A:middle
And then we dive
right into our loop.

00:23:56.416 --> 00:23:58.526 A:middle
We need to track the
offset because we know

00:23:58.526 --> 00:23:59.876 A:middle
that we're not starting
right at the beginning

00:23:59.876 --> 00:24:00.716 A:middle
of our constant buffer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.876 --> 00:24:00.716 A:middle
of our constant buffer.

00:24:00.716 --> 00:24:01.946 A:middle
There's some frame
data in there.

00:24:02.556 --> 00:24:04.786 A:middle
So the offset will be pushed
back past the frame data.

00:24:06.436 --> 00:24:08.536 A:middle
Then we'll call
setVertexBufferOffset

00:24:08.536 --> 00:24:11.716 A:middle
and setFragmentBufferOffset
to point this draw

00:24:11.716 --> 00:24:15.306 A:middle
to the correct data that
we want to draw with.

00:24:15.416 --> 00:24:16.466 A:middle
We'll issue the draw call

00:24:16.466 --> 00:24:20.756 A:middle
and then we'll set the offset
again just striding one object

00:24:20.756 --> 00:24:21.956 A:middle
data struct at a time.

00:24:24.796 --> 00:24:26.156 A:middle
So our draws are in place.

00:24:27.146 --> 00:24:28.376 A:middle
This is still very linear.

00:24:28.586 --> 00:24:30.076 A:middle
And I promised you
some multithreading

00:24:30.606 --> 00:24:33.026 A:middle
and Warren mentioned that, hey,
you can actually encode a bunch

00:24:33.026 --> 00:24:34.096 A:middle
of stuff in parallel in Metal.

00:24:34.816 --> 00:24:35.876 A:middle
So how would you do this?

00:24:36.116 --> 00:24:39.006 A:middle
An ideal frame might
look like this.

00:24:39.006 --> 00:24:41.876 A:middle
Our render threat is chugging
along and it realizes, hey,

00:24:41.876 --> 00:24:43.376 A:middle
I need to render a
shadow map and I need

00:24:43.376 --> 00:24:44.396 A:middle
to render a main pass.

00:24:44.806 --> 00:24:46.496 A:middle
It'd be great if I could
code this in parallel.

00:24:46.886 --> 00:24:48.426 A:middle
I've got multiple CPUs.

00:24:48.756 --> 00:24:51.916 A:middle
So what if I dispatch this
work out, encoded some stuff,

00:24:53.196 --> 00:24:54.736 A:middle
then I rejoin back
to the render thread

00:24:54.736 --> 00:24:57.316 A:middle
and the render thread
pushed this over to the GPU

00:24:57.316 --> 00:24:58.296 A:middle
to do a bunch of work.

00:24:58.936 --> 00:24:59.526 A:middle
This would look great.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:03.286 --> 00:25:05.426 A:middle
How many of you have used GCD?

00:25:06.756 --> 00:25:09.066 A:middle
This is a great fit for
Grand Central Dispatch.

00:25:09.146 --> 00:25:10.036 A:middle
If you're not familiar,

00:25:10.036 --> 00:25:12.566 A:middle
Grand Central Dispatch is
Apple's multiprocessing API.

00:25:13.246 --> 00:25:15.116 A:middle
This is an API that
lets you create queues

00:25:15.576 --> 00:25:17.666 A:middle
and these queues manage
computing resources

00:25:17.796 --> 00:25:18.876 A:middle
on your machine.

00:25:19.616 --> 00:25:21.126 A:middle
There are two types of
queues you can create.

00:25:21.576 --> 00:25:22.536 A:middle
There's a serial queue.

00:25:22.536 --> 00:25:25.886 A:middle
When you dispatch work through a
serial queue, you're guaranteed

00:25:25.886 --> 00:25:27.506 A:middle
that all that work
will happen in order.

00:25:27.926 --> 00:25:31.756 A:middle
But what's more interesting
for us is the concurrent queue.

00:25:32.836 --> 00:25:35.806 A:middle
When you dispatch work to the
concurrent queue, GCD will look

00:25:35.806 --> 00:25:37.466 A:middle
at your system and
figure out the best way

00:25:37.466 --> 00:25:38.456 A:middle
to schedule this for you.

00:25:39.496 --> 00:25:40.266 A:middle
And that's perfect.

00:25:40.266 --> 00:25:42.196 A:middle
We have two jobs we
need to do in parallel.

00:25:42.786 --> 00:25:45.696 A:middle
So if we created this one queue
and just pushed the work to it,

00:25:46.196 --> 00:25:47.116 A:middle
it would do that for us.

00:25:48.166 --> 00:25:51.006 A:middle
This is another object you
want to create once and reuse.

00:25:51.316 --> 00:25:53.606 A:middle
So here's some code to create
a concurrent dispatch queue.

00:25:54.156 --> 00:25:55.626 A:middle
You should always a
label on your queues.

00:25:55.856 --> 00:25:57.836 A:middle
I've used the very
creative label queue here

00:25:58.556 --> 00:25:59.806 A:middle
but you might want to
call it something else.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:03.406 --> 00:26:05.406 A:middle
So we made some modifications
to the code.

00:26:06.556 --> 00:26:08.326 A:middle
We still create the command
buffers at the start.

00:26:09.526 --> 00:26:13.296 A:middle
But since we were smart enough
to use two command buffers

00:26:13.656 --> 00:26:15.176 A:middle
and separate our
encoding functions

00:26:15.176 --> 00:26:17.686 A:middle
into two unique things,
there isn't much else for us

00:26:17.686 --> 00:26:19.486 A:middle
to do other than
dispatch the work.

00:26:20.446 --> 00:26:23.606 A:middle
So dispatchQueue.async
is the main call you use

00:26:23.606 --> 00:26:25.446 A:middle
to dispatch work
to a queue in GCD.

00:26:25.816 --> 00:26:27.056 A:middle
This is an asynchronous call.

00:26:27.456 --> 00:26:30.226 A:middle
It'll push the work on and
your thread will keep going.

00:26:31.426 --> 00:26:34.156 A:middle
So here we dispatch
the shadow pass

00:26:34.646 --> 00:26:39.186 A:middle
and then we dispatch
the main pass.

00:26:39.186 --> 00:26:40.766 A:middle
We'll want to commit
this work somehow

00:26:41.526 --> 00:26:44.406 A:middle
so we call dispatch barrier
sync and this makes sure

00:26:44.406 --> 00:26:46.956 A:middle
that all the work is done by
the time we get to this point.

00:26:47.446 --> 00:26:51.936 A:middle
And then finally we've rejoined
and we can commit our work.

00:26:52.556 --> 00:26:54.126 A:middle
Now the ordering
is important here.

00:26:54.806 --> 00:26:57.326 A:middle
The shadow map has to be done
by the time we reference it.

00:26:57.926 --> 00:27:00.036 A:middle
So we have to commit the
shadow command buffer first


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.926 --> 00:27:00.036 A:middle
So we have to commit the
shadow command buffer first

00:27:00.236 --> 00:27:01.816 A:middle
and then the main
command buffer later.

00:27:04.616 --> 00:27:06.396 A:middle
There's something else
I want to bring up here.

00:27:07.386 --> 00:27:09.446 A:middle
How many of you are familiar
with the concept of a closure?

00:27:11.896 --> 00:27:15.376 A:middle
Great. How many of you
have ever had an issue

00:27:15.376 --> 00:27:16.826 A:middle
where closures captures self

00:27:16.826 --> 00:27:18.596 A:middle
and you thought you were
referencing something else?

00:27:19.226 --> 00:27:21.136 A:middle
You can be honest.

00:27:21.136 --> 00:27:21.976 A:middle
It's happened to all of us.

00:27:22.036 --> 00:27:24.006 A:middle
I just wanted to call this out.

00:27:24.396 --> 00:27:25.756 A:middle
Closures capture self.

00:27:25.886 --> 00:27:28.596 A:middle
So if you're referencing a
member variable or an iVar

00:27:28.596 --> 00:27:31.936 A:middle
within them and you're not
explicitly saying self.iVar,

00:27:32.246 --> 00:27:34.386 A:middle
it's still actually going
to reference that variable.

00:27:35.146 --> 00:27:37.466 A:middle
So if you want to
make sure you're going

00:27:37.466 --> 00:27:40.136 A:middle
to reference the correct
data, it's a good idea

00:27:40.136 --> 00:27:42.646 A:middle
to capture it outside and
I'll show you what I mean

00:27:42.646 --> 00:27:43.186 A:middle
in a second.

00:27:45.386 --> 00:27:47.556 A:middle
These two things don't
do the same thing.

00:27:48.516 --> 00:27:50.606 A:middle
So in the first one where
I encode the shadow pass,

00:27:50.606 --> 00:27:53.436 A:middle
you can see the constant buffer
I'm grabbing is dependent

00:27:53.436 --> 00:27:55.186 A:middle
on self.constantBufferSlot.

00:27:55.186 --> 00:27:58.566 A:middle
I don't actually know what that
will be at the time it executes.

00:27:59.036 --> 00:28:00.746 A:middle
This is really asynchronous
programming.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.036 --> 00:28:00.746 A:middle
This is really asynchronous
programming.

00:28:00.746 --> 00:28:03.966 A:middle
So by the time my dispatch
is actually running,

00:28:04.346 --> 00:28:05.636 A:middle
this could've changed
behind my back.

00:28:06.276 --> 00:28:07.976 A:middle
It may be right but
it may not be.

00:28:08.026 --> 00:28:09.516 A:middle
I can't guarantee it.

00:28:12.926 --> 00:28:15.066 A:middle
So keep that in mind and
don't do it that way.

00:28:16.026 --> 00:28:17.796 A:middle
Instead, we'd like to
capture a reference

00:28:17.796 --> 00:28:19.496 A:middle
to the constant buffer
we're interested in.

00:28:20.186 --> 00:28:21.916 A:middle
So here we just say
let constant buffer

00:28:22.366 --> 00:28:23.516 A:middle
and grab it out of the array.

00:28:24.676 --> 00:28:26.286 A:middle
But then when we
issue our dispatch,

00:28:27.016 --> 00:28:29.256 A:middle
we reference the specific one
that we've already grabbed.

00:28:29.606 --> 00:28:31.976 A:middle
That makes sure we know exactly
what data we're reading from.

00:28:37.246 --> 00:28:38.946 A:middle
So this is some multithreading
fun.

00:28:39.376 --> 00:28:42.766 A:middle
The actual code in the
sample looks like this.

00:28:42.956 --> 00:28:44.136 A:middle
We capture the constant buffer.

00:28:44.666 --> 00:28:50.226 A:middle
And when we use it, we make sure
we're using the correct one,

00:28:50.346 --> 00:28:51.716 A:middle
the one that we've
captured already,

00:28:52.416 --> 00:28:54.236 A:middle
to know that we're using
this frame's constant buffer.

00:28:54.236 --> 00:28:57.356 A:middle
Now I had mentioned
the ordering earlier

00:28:57.466 --> 00:28:58.486 A:middle
and how this was important.

00:28:59.686 --> 00:29:03.526 A:middle
When you create a command buffer
and you commit it, the ordering


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.686 --> 00:29:03.526 A:middle
When you create a command buffer
and you commit it, the ordering

00:29:03.526 --> 00:29:07.076 A:middle
that this executes on
your GPU is implied

00:29:07.076 --> 00:29:08.116 A:middle
by the order you commit it in.

00:29:08.436 --> 00:29:10.376 A:middle
So if I commit the shadow
command buffer first

00:29:10.616 --> 00:29:13.276 A:middle
and the main command buffer
second, I'm guaranteed

00:29:13.276 --> 00:29:16.086 A:middle
that the shadow one will happen
first on the GPU followed

00:29:16.086 --> 00:29:17.026 A:middle
by the main command buffer.

00:29:17.776 --> 00:29:18.646 A:middle
Sometimes we refer to this

00:29:18.646 --> 00:29:20.186 A:middle
as implicit command
buffer ordering.

00:29:22.196 --> 00:29:25.796 A:middle
But you can be a little
more explicit about it.

00:29:25.796 --> 00:29:27.416 A:middle
Metal provides an
enqueue function

00:29:27.736 --> 00:29:29.296 A:middle
that enforces command
buffer ordering.

00:29:29.886 --> 00:29:32.686 A:middle
If you have a set of command
buffers, you can enqueue them

00:29:33.106 --> 00:29:34.496 A:middle
and you're guaranteed
that they will execute

00:29:34.496 --> 00:29:36.576 A:middle
in that order regardless
of how you commit them

00:29:36.606 --> 00:29:37.486 A:middle
or when you commit them.

00:29:38.596 --> 00:29:40.586 A:middle
This is something really
cool because it allows you

00:29:40.586 --> 00:29:43.336 A:middle
to commit command buffers from
multiple threads, in any order,

00:29:43.336 --> 00:29:45.226 A:middle
and you don't have
to worry about it.

00:29:45.566 --> 00:29:48.266 A:middle
The runtime will ensure you're
executing in the correct order.

00:29:49.536 --> 00:29:51.616 A:middle
So let's see how to
apply this to our code.

00:29:52.326 --> 00:29:53.986 A:middle
A couple new additions here.

00:29:54.596 --> 00:29:56.136 A:middle
Now when we create
our command buffers,

00:29:56.136 --> 00:29:57.766 A:middle
we immediately enqueue
them in the order.

00:29:58.306 --> 00:29:59.976 A:middle
Again, the order
matters, so we still have

00:29:59.976 --> 00:30:01.816 A:middle
to enqueue shadowCommandBuffer
first


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.976 --> 00:30:01.816 A:middle
to enqueue shadowCommandBuffer
first

00:30:02.436 --> 00:30:03.826 A:middle
and then mainCommandBuffer
second.

00:30:05.236 --> 00:30:08.416 A:middle
But now when we dispatch,
we can actually commit

00:30:08.416 --> 00:30:09.606 A:middle
from within our other thread.

00:30:10.256 --> 00:30:13.586 A:middle
Again, the runtime is going
to ensure the ordering.

00:30:13.956 --> 00:30:15.476 A:middle
So we don't actually
have to worry about it.

00:30:16.266 --> 00:30:18.996 A:middle
This actually lets us remove
that barrier we had before

00:30:19.326 --> 00:30:20.716 A:middle
because we have no
need to rejoin

00:30:20.716 --> 00:30:22.036 A:middle
and commit the command buffers.

00:30:22.116 --> 00:30:26.336 A:middle
They're already committed
for us.

00:30:26.536 --> 00:30:27.836 A:middle
But I seem to have
skipped over all

00:30:27.836 --> 00:30:30.086 A:middle
that synchronization stuff
I talked about a second ago

00:30:30.446 --> 00:30:32.286 A:middle
and we still need it
because we're still going

00:30:32.286 --> 00:30:34.136 A:middle
to be overriding ourselves
if we don't have it.

00:30:34.816 --> 00:30:37.526 A:middle
So can we apply these same
synchronization lessons

00:30:37.886 --> 00:30:39.786 A:middle
to this sort of multithreaded
world?

00:30:40.296 --> 00:30:45.036 A:middle
It turns out we can and it's
actually quite straightforward.

00:30:46.236 --> 00:30:47.576 A:middle
We bring back our
friendly semaphore

00:30:47.716 --> 00:30:49.206 A:middle
and our array of
constant buffers.

00:30:49.296 --> 00:30:51.586 A:middle
And again, don't forget to grab
the correct one that you want.

00:30:51.906 --> 00:30:55.126 A:middle
At the start, we'll wait
on the semaphore and sleep

00:30:55.126 --> 00:30:56.046 A:middle
if nothing's available.

00:30:57.406 --> 00:31:03.206 A:middle
We've enforced our ordering with
enqueue and we push it through.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:57.406 --> 00:31:03.206 A:middle
We've enforced our ordering with
enqueue and we push it through.

00:31:03.416 --> 00:31:04.186 A:middle
Now we know

00:31:04.186 --> 00:31:06.266 A:middle
that mainCommandBuffer is
the final command buffer

00:31:06.266 --> 00:31:06.796 A:middle
in our frame.

00:31:07.296 --> 00:31:09.996 A:middle
And we know that we want to
signal that our frame is done.

00:31:11.146 --> 00:31:14.456 A:middle
So we should add our completion
handler to the mainCommandBuffer

00:31:14.566 --> 00:31:16.616 A:middle
and you could do this
from within the dispatch.

00:31:18.316 --> 00:31:20.696 A:middle
So the mainCommandBuffer is
the final command buffer.

00:31:20.946 --> 00:31:23.516 A:middle
We add the completion handler
to it, to signal our semaphore,

00:31:24.086 --> 00:31:25.656 A:middle
and we commit it from
within the dispatch,

00:31:25.746 --> 00:31:26.656 A:middle
just like we did before.

00:31:27.826 --> 00:31:30.976 A:middle
Now you may notice here that
I'm referencing self.semaphore

00:31:31.306 --> 00:31:33.436 A:middle
and a second ago I just told
you to watch out for that.

00:31:33.956 --> 00:31:34.686 A:middle
So what's going on?

00:31:35.536 --> 00:31:38.586 A:middle
Well it turns out a semaphore
is a synchronization primitive

00:31:39.166 --> 00:31:41.506 A:middle
and we do actually want to
be looking at the same one

00:31:41.506 --> 00:31:42.646 A:middle
as all of our other threads.

00:31:43.436 --> 00:31:45.166 A:middle
So we want the value
of the semaphore

00:31:45.166 --> 00:31:46.756 A:middle
at the time the thread
is executing.

00:31:47.556 --> 00:31:50.716 A:middle
So in this case, we
actually want self.semaphore,

00:31:50.996 --> 00:31:52.416 A:middle
something to keep aware of.

00:31:55.956 --> 00:31:58.516 A:middle
And here's the recipe
for our rendering.

00:31:59.196 --> 00:32:00.736 A:middle
At the start of our
render function,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.196 --> 00:32:00.736 A:middle
At the start of our
render function,

00:32:01.046 --> 00:32:02.056 A:middle
we wait on the semaphore.

00:32:03.366 --> 00:32:05.086 A:middle
We select the current
constant buffer.

00:32:06.406 --> 00:32:08.586 A:middle
We write the data into
our constant buffer

00:32:08.586 --> 00:32:10.616 A:middle
that represents all
of our objects.

00:32:11.576 --> 00:32:13.646 A:middle
We encode the commands
into command buffers.

00:32:13.796 --> 00:32:15.046 A:middle
We can do the single-threaded,

00:32:15.346 --> 00:32:16.836 A:middle
multithreaded, however
you'd like.

00:32:17.746 --> 00:32:20.566 A:middle
We add a completion handler
onto our final command buffer

00:32:20.916 --> 00:32:23.736 A:middle
and we use it to signal the
semaphore to let us know

00:32:23.736 --> 00:32:26.256 A:middle
when we're done and we
commit our command buffers.

00:32:26.726 --> 00:32:28.776 A:middle
And the GPU takes all this

00:32:28.776 --> 00:32:30.916 A:middle
and starts chugging
away at our frame.

00:32:32.706 --> 00:32:34.976 A:middle
So let's look at the demo
again and see what this got us.

00:32:38.286 --> 00:32:40.436 A:middle
So here you can see
in the top left,

00:32:40.436 --> 00:32:42.026 A:middle
this is single-threaded
encode mode

00:32:42.356 --> 00:32:44.776 A:middle
and you can see how many
draws we're issuing, 10,000.

00:32:45.656 --> 00:32:48.416 A:middle
And the top right, you can
see the time it takes us

00:32:48.416 --> 00:32:49.226 A:middle
to encode a frame.

00:32:50.096 --> 00:32:54.476 A:middle
So here we've got 5 milliseconds
and we can crank the number

00:32:54.476 --> 00:32:57.226 A:middle
of draws up and see that
it starts costing more

00:32:57.226 --> 00:32:58.776 A:middle
and more as we draw things.

00:32:59.486 --> 00:33:01.346 A:middle
Now this is single-threaded
mode.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.486 --> 00:33:01.346 A:middle
Now this is single-threaded
mode.

00:33:01.606 --> 00:33:04.746 A:middle
And when you think about it,
we're drawing a shadow map,

00:33:04.816 --> 00:33:08.996 A:middle
which means we have to issue
40,000 draws in the shadow map,

00:33:09.306 --> 00:33:11.126 A:middle
and then we're drawing the
main pass, which means we have

00:33:11.126 --> 00:33:14.266 A:middle
to issue another 40,000
draws to reference that.

00:33:15.426 --> 00:33:17.096 A:middle
But again, we can
do this in parallel,

00:33:17.566 --> 00:33:19.366 A:middle
so we've added a parallel
mode to this demo.

00:33:19.926 --> 00:33:23.976 A:middle
And you can see how it's
faster to go through.

00:33:25.596 --> 00:33:27.496 A:middle
Now take a look at
everything that's going on.

00:33:27.976 --> 00:33:29.976 A:middle
You can fly around a little bit.

00:33:36.296 --> 00:33:40.546 A:middle
So here we have 40,000
cubes, unique, independent.

00:33:40.726 --> 00:33:41.816 A:middle
They're all being updated.

00:33:42.686 --> 00:33:46.156 A:middle
We're using GCD to encode a
bunch of stuff in parallel.

00:33:47.326 --> 00:33:49.616 A:middle
We have two command buffers:
One to generate the shadow map

00:33:49.616 --> 00:33:52.616 A:middle
on the ground and one to render
all of the cubes in color.

00:33:53.986 --> 00:33:56.356 A:middle
The lighting is quite
simple, Lambert shadowing,

00:33:56.356 --> 00:33:58.496 A:middle
which is basically
what Warren talked

00:33:58.496 --> 00:33:59.896 A:middle
about earlier, the N.L lighting.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:02.686 --> 00:34:03.736 A:middle
And that's our demo.

00:34:03.736 --> 00:34:05.446 A:middle
This will be available
as sample code

00:34:05.446 --> 00:34:06.646 A:middle
for you guys to take a look at.

00:34:07.086 --> 00:34:09.466 A:middle
Hopefully you can rip it
apart, take some of the ideas

00:34:09.466 --> 00:34:11.565 A:middle
and the thoughts in it and
apply them to your own code.

00:34:11.966 --> 00:34:13.866 A:middle
So what did we talk about today?

00:34:15.235 --> 00:34:17.505 A:middle
When you walked in
here, hopefully you came

00:34:17.505 --> 00:34:19.525 A:middle
to Warren's session earlier
and maybe you knew a little bit

00:34:19.525 --> 00:34:22.085 A:middle
about graphics or had done
some programming before,

00:34:22.456 --> 00:34:25.036 A:middle
but we took you through
everything in Metal.

00:34:25.646 --> 00:34:28.436 A:middle
The conceptual overview
of Metal, the reasoning

00:34:28.436 --> 00:34:32.266 A:middle
around it is to use an API
that is close to the hardware

00:34:32.396 --> 00:34:33.426 A:middle
and close to the driver.

00:34:35.036 --> 00:34:37.525 A:middle
We learned about the Metal
device, which is the root object

00:34:37.525 --> 00:34:39.206 A:middle
in Metal that everything
comes from.

00:34:40.755 --> 00:34:42.786 A:middle
We talked a bit about
loading data into Metal

00:34:42.786 --> 00:34:45.636 A:middle
and the different resource
types and how you use them,

00:34:46.706 --> 00:34:49.545 A:middle
the Metal shading language,
which is the C++ variant you use

00:34:49.545 --> 00:34:50.916 A:middle
to write programs on the GPU.

00:34:51.016 --> 00:34:54.346 A:middle
We talked about building
pipeline states,

00:34:54.466 --> 00:34:58.486 A:middle
prevalidated objects that
contain your two functions,

00:34:58.676 --> 00:35:00.746 A:middle
vertex and fragment
or a compute function,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:58.676 --> 00:35:00.746 A:middle
vertex and fragment
or a compute function,

00:35:01.216 --> 00:35:03.466 A:middle
and a bunch of other
baked-in, prevalidated state

00:35:03.466 --> 00:35:04.636 A:middle
to save you time at runtime.

00:35:06.026 --> 00:35:07.846 A:middle
Then we went into
issuing GPU commands,

00:35:07.926 --> 00:35:11.066 A:middle
creating a Metal queue, creating
command buffers off that queue,

00:35:11.736 --> 00:35:13.896 A:middle
and creating encoders to
fill the command buffer in,

00:35:13.896 --> 00:35:17.446 A:middle
and then issuing that work and
sending it over to the GPU.

00:35:17.926 --> 00:35:20.226 A:middle
We walked you through
animation and texturing

00:35:20.996 --> 00:35:24.096 A:middle
and using set vertex bytes
to send small bits of data

00:35:24.096 --> 00:35:25.216 A:middle
to do your animation in.

00:35:26.716 --> 00:35:28.656 A:middle
Then when the small bits
of data weren't enough,

00:35:28.856 --> 00:35:31.246 A:middle
we talked about managing
large chunks of dynamic data

00:35:31.546 --> 00:35:33.856 A:middle
and using one big constant
buffer and referencing it

00:35:33.856 --> 00:35:37.976 A:middle
in multiple places to get some
data reuse out of the system.

00:35:38.916 --> 00:35:41.816 A:middle
We talked about CPU-GPU
synchronization, the importance

00:35:41.816 --> 00:35:45.236 A:middle
of making sure your CPU and your
GPU aren't overriding each other

00:35:45.806 --> 00:35:46.636 A:middle
and playing nicely.

00:35:46.916 --> 00:35:49.666 A:middle
And then lastly, we
talked a little bit

00:35:49.666 --> 00:35:53.066 A:middle
about multithreaded encoding,
how you can use GCD with Metal

00:35:53.066 --> 00:35:55.226 A:middle
to encode multiple
command buffers

00:35:55.306 --> 00:35:57.026 A:middle
on your queues at the same time.

00:35:57.546 --> 00:36:00.166 A:middle
And that's adopting Metal.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:57.546 --> 00:36:00.166 A:middle
And that's adopting Metal.

00:36:00.946 --> 00:36:03.186 A:middle
Hopefully you enjoyed the talk
and you can apply some of these

00:36:03.186 --> 00:36:04.786 A:middle
to your apps and make
your apps even better

00:36:04.786 --> 00:36:05.596 A:middle
than they already are.

00:36:06.306 --> 00:36:08.776 A:middle
If you'd like some more
information, you can check

00:36:08.776 --> 00:36:14.246 A:middle
out this website,
developer.apple.com/wwdc/603.

00:36:15.556 --> 00:36:17.336 A:middle
We have a few more
sessions tomorrow

00:36:17.336 --> 00:36:18.576 A:middle
that I recommend
you go check out.

00:36:18.576 --> 00:36:20.916 A:middle
At 11:00 o'clock, we
have What's New in Metal,

00:36:20.916 --> 00:36:23.546 A:middle
Part 1 and then a
little later at 1:40,

00:36:23.546 --> 00:36:24.936 A:middle
we have What's New
in Metal, Part 2.

00:36:24.936 --> 00:36:27.186 A:middle
That'll tell us everything
that's new in the world

00:36:27.186 --> 00:36:28.896 A:middle
of Metal, awesome
stuff you can add

00:36:28.896 --> 00:36:30.396 A:middle
to your applications
to make them better.

00:36:30.496 --> 00:36:33.986 A:middle
And then for you hardcore
shader heads out there,

00:36:34.256 --> 00:36:37.176 A:middle
we have Advanced Metal
Shader Optimization at 3:00.

00:36:37.596 --> 00:36:38.876 A:middle
So if you want to know
how to get the best

00:36:38.876 --> 00:36:41.066 A:middle
out of your shaders, I recommend
you go check out that talk.

00:36:41.066 --> 00:36:41.696 A:middle
It's really great.

00:36:42.906 --> 00:36:44.156 A:middle
Thanks for coming
to hear us talk.

00:36:44.496 --> 00:36:45.646 A:middle
Welcome to WWDC.

00:36:45.646 --> 00:36:47.096 A:middle
Have a good rest of the week.

00:36:47.916 --> 00:36:48.486 A:middle
Thanks again.

