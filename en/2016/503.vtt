WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:17.500 A:middle
[ Music ]

00:00:21.136 --> 00:00:21.586 A:middle
&gt;&gt; Good morning.

00:00:22.516 --> 00:00:26.676 A:middle
[ Applause ]

00:00:27.176 --> 00:00:29.166 A:middle
Welcome to our session
on Advances

00:00:29.166 --> 00:00:30.596 A:middle
in AVFoundation Playback.

00:00:32.445 --> 00:00:33.246 A:middle
My name is Sam Bushell.

00:00:34.566 --> 00:00:38.206 A:middle
Today we're going to talk
about some new enhancements

00:00:38.376 --> 00:00:41.326 A:middle
that we've added to try and
smooth over some rough edges

00:00:41.326 --> 00:00:43.036 A:middle
that some developers
have found challenging.

00:00:43.816 --> 00:00:46.316 A:middle
So AVFoundation provides APIs
for a very broad selection

00:00:46.316 --> 00:00:49.506 A:middle
of multimedia activities,
including playback, capture,

00:00:49.506 --> 00:00:51.236 A:middle
export, and many
kinds of editing.

00:00:51.236 --> 00:00:53.276 A:middle
I'll be focusing
mostly on playback.

00:00:54.476 --> 00:00:57.746 A:middle
AVFoundation supports playback
from a very wide selection

00:00:57.746 --> 00:01:01.016 A:middle
of media formats
from local storage.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.746 --> 00:01:01.016 A:middle
of media formats
from local storage.

00:01:01.516 --> 00:01:03.596 A:middle
And in most cases you
can take the same file,

00:01:03.786 --> 00:01:05.016 A:middle
and you can put it
on a web server

00:01:05.586 --> 00:01:08.866 A:middle
and then AVFoundation can
play that over the network.

00:01:09.106 --> 00:01:10.916 A:middle
The file format in
this case is the same,

00:01:11.096 --> 00:01:12.456 A:middle
but the IO is over the network.

00:01:13.336 --> 00:01:15.886 A:middle
We call this progressive
download playback.

00:01:16.866 --> 00:01:18.586 A:middle
Once we start downloading
that file,

00:01:18.996 --> 00:01:21.286 A:middle
even if the network
characteristics change,

00:01:21.316 --> 00:01:22.846 A:middle
we will continue
with the same file.

00:01:24.266 --> 00:01:26.926 A:middle
HTTP Live Streaming
is more dynamic.

00:01:27.906 --> 00:01:30.956 A:middle
Generally, the base URL
refers to a master playlist

00:01:31.656 --> 00:01:34.256 A:middle
which introduces multiple
playlists for the same content

00:01:34.496 --> 00:01:37.666 A:middle
but varying in bit rate and
format and maybe in language.

00:01:39.116 --> 00:01:42.956 A:middle
And each of these playlists
references segments containing

00:01:42.956 --> 00:01:44.056 A:middle
the actual compressed media.

00:01:44.516 --> 00:01:47.736 A:middle
So let's talk about what we're
going to talk about today.

00:01:48.696 --> 00:01:52.216 A:middle
We're going to discuss
the playback changes to do

00:01:52.216 --> 00:01:54.076 A:middle
with the pre-playback
buffering period.

00:01:54.796 --> 00:01:56.266 A:middle
We're going to introduce
a new API

00:01:57.056 --> 00:01:59.066 A:middle
to simplify looping
playback of a single file.

00:01:59.936 --> 00:02:02.206 A:middle
We're going to discuss some
playback refinements we've made


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.936 --> 00:02:02.206 A:middle
We're going to discuss some
playback refinements we've made

00:02:02.316 --> 00:02:05.366 A:middle
under the hood.

00:02:05.576 --> 00:02:07.586 A:middle
We're going to discuss
getting your application ready

00:02:07.586 --> 00:02:08.795 A:middle
for wide color video.

00:02:09.756 --> 00:02:10.675 A:middle
And then we'll spend the rest

00:02:10.675 --> 00:02:13.346 A:middle
of our time discussing a
popular topic optimization

00:02:13.346 --> 00:02:15.466 A:middle
of static time in playback apps.

00:02:16.566 --> 00:02:18.996 A:middle
Let's start by waiting
for the network.

00:02:20.006 --> 00:02:23.036 A:middle
Because when we play media
playback over the Internet,

00:02:23.326 --> 00:02:24.576 A:middle
we're at the mercy
of the network.

00:02:24.816 --> 00:02:27.176 A:middle
We don't want to start too
soon or playback my stall.

00:02:27.176 --> 00:02:29.986 A:middle
We don't want to start too late
or the user may give up on us.

00:02:30.476 --> 00:02:32.846 A:middle
We want to start at
that Goldilocks moment

00:02:33.096 --> 00:02:35.726 A:middle
and start playback when we have
enough data that we'll be able

00:02:35.726 --> 00:02:37.496 A:middle
to play consistently
and not stall.

00:02:38.396 --> 00:02:40.036 A:middle
Here is the existing API.

00:02:40.606 --> 00:02:43.796 A:middle
AVPlayerItem provides
three Boolean properties.

00:02:44.646 --> 00:02:47.256 A:middle
playbackLikelyToKeepUp,
playbackBufferFull,

00:02:47.466 --> 00:02:48.646 A:middle
and playbackBufferEmpty.

00:02:49.636 --> 00:02:53.226 A:middle
playbackBuffer -- sorry --
playbackLikelyToKeepUp is true

00:02:53.226 --> 00:02:56.146 A:middle
if AVFoundation's algorithm
believes that if you were

00:02:56.146 --> 00:02:59.136 A:middle
to stop playing now, you could
keep on playing without stalling

00:02:59.136 --> 00:03:00.016 A:middle
until you got to the end.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.136 --> 00:03:00.016 A:middle
until you got to the end.

00:03:01.026 --> 00:03:04.196 A:middle
playbackBufferFull is
true if the buffer does

00:03:04.196 --> 00:03:06.256 A:middle
as much as it's going to.

00:03:06.256 --> 00:03:07.886 A:middle
So if you haven't
started playing back yet,

00:03:07.886 --> 00:03:08.616 A:middle
you might as well.

00:03:09.586 --> 00:03:11.896 A:middle
playbackBufferEmpty means
that you are stalling

00:03:12.216 --> 00:03:13.316 A:middle
or you're about to stall.

00:03:13.806 --> 00:03:19.466 A:middle
So for progressive download
playback in iOS 9 and earlier,

00:03:19.886 --> 00:03:22.936 A:middle
AVFoundation clients must
monitor these properties

00:03:22.936 --> 00:03:26.656 A:middle
themselves and wait until
playbackLikelyToKeepUp is true

00:03:26.716 --> 00:03:30.706 A:middle
or playbackBufferFull is true
before setting the AVPlayer's

00:03:30.706 --> 00:03:31.796 A:middle
rate property to 1.

00:03:32.906 --> 00:03:35.226 A:middle
For HTTP Live Streaming,
the rules are simpler.

00:03:35.776 --> 00:03:38.856 A:middle
You can set AVPlayer's
rate property to 1 as soon

00:03:38.856 --> 00:03:42.196 A:middle
as the user chooses to play,
and it will automatically wait

00:03:42.876 --> 00:03:45.366 A:middle
to buffer sufficient media
before playback begins.

00:03:45.896 --> 00:03:49.436 A:middle
We are streamlining the
default API contract

00:03:49.436 --> 00:03:51.906 A:middle
in the 2016 iOS releases.

00:03:51.956 --> 00:03:54.236 A:middle
iOS, Mac OS, tvOS.

00:03:54.996 --> 00:03:59.316 A:middle
For apps linked on or after
iOS 10, Mac OS Sierra, tvOS 10,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.356 --> 00:04:02.616 A:middle
the same rules for
HLS will also apply

00:04:02.616 --> 00:04:04.046 A:middle
to progressive download
playback.

00:04:04.796 --> 00:04:06.126 A:middle
When the user clicks play,

00:04:06.126 --> 00:04:09.466 A:middle
you can immediately set
AVPlayer's rate property to 1

00:04:09.636 --> 00:04:11.656 A:middle
or call the play method,
which is the same thing.

00:04:12.456 --> 00:04:14.376 A:middle
And AVFoundation will
automatically wait

00:04:14.376 --> 00:04:16.185 A:middle
to buffer enough
to avoid stalling.

00:04:17.255 --> 00:04:20.116 A:middle
If the network drops out during
playback and playback stalls,

00:04:20.676 --> 00:04:23.486 A:middle
the rate property
will stay set to 1.

00:04:23.936 --> 00:04:27.006 A:middle
And so it will again buffer
and automatically resume

00:04:27.046 --> 00:04:28.526 A:middle
when sufficiently buffered.

00:04:29.116 --> 00:04:34.376 A:middle
If you're using the AVKit
or MediaPlayer framework

00:04:34.796 --> 00:04:36.696 A:middle
to present your playback UI,

00:04:37.536 --> 00:04:40.886 A:middle
it already supports automatic
waiting for buffering,

00:04:40.886 --> 00:04:41.856 A:middle
and it will continue to.

00:04:42.616 --> 00:04:45.106 A:middle
If your application uses
AVFoundation directly

00:04:45.416 --> 00:04:47.506 A:middle
and you build your own
playback UI, you may need

00:04:47.506 --> 00:04:48.596 A:middle
to make some adjustments.

00:04:49.416 --> 00:04:51.526 A:middle
So what should we
call this new API?

00:04:52.136 --> 00:04:56.966 A:middle
Well, the word Autoplay has
been used in QTKit and also

00:04:56.966 --> 00:04:59.586 A:middle
in HTML 5, but we
came to the conclusion

00:04:59.586 --> 00:05:02.556 A:middle
that from the perspective
of this AVPlayer API,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.586 --> 00:05:02.556 A:middle
that from the perspective
of this AVPlayer API,

00:05:03.136 --> 00:05:05.436 A:middle
the playback is not
the automatic part.

00:05:05.846 --> 00:05:06.476 A:middle
It's the waiting.

00:05:07.726 --> 00:05:10.876 A:middle
So the formal name for
this API is automatically

00:05:10.876 --> 00:05:12.376 A:middle
WaitsToMinimizeStalling.

00:05:12.646 --> 00:05:14.116 A:middle
But you can call it
Autoplay if you like.

00:05:15.936 --> 00:05:17.616 A:middle
The network playback now looks

00:05:17.616 --> 00:05:19.286 A:middle
like a state machine
with three states.

00:05:20.236 --> 00:05:22.196 A:middle
Paused, waiting, and playing.

00:05:23.036 --> 00:05:25.596 A:middle
We start in the pause state
until the user chooses to play.

00:05:25.976 --> 00:05:28.876 A:middle
And then the app calls play, and
we move to the waiting state.

00:05:29.346 --> 00:05:32.856 A:middle
When the playback likelyToKeepUp
property becomes true,

00:05:33.276 --> 00:05:35.146 A:middle
the player progresses
to the playing state.

00:05:35.946 --> 00:05:37.746 A:middle
Now, if the buffer
should become empty,

00:05:38.426 --> 00:05:40.116 A:middle
the player will switch
back to the waiting state

00:05:40.166 --> 00:05:41.366 A:middle
until we're likely
to keep up again.

00:05:42.196 --> 00:05:45.316 A:middle
Should the user pause, we'll
return to the pause state.

00:05:45.936 --> 00:05:47.716 A:middle
Now there's one further
transition available.

00:05:48.296 --> 00:05:51.596 A:middle
Recall that in iOS 9 and
earlier before this change,

00:05:51.936 --> 00:05:55.056 A:middle
you could call play before
playback was likely to keep up

00:05:55.286 --> 00:05:57.706 A:middle
and playback would
start immediately even

00:05:57.706 --> 00:05:58.456 A:middle
if it might stall.

00:05:58.826 --> 00:06:01.956 A:middle
So we preserved this semantic
by providing another method,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.826 --> 00:06:01.956 A:middle
So we preserved this semantic
by providing another method,

00:06:02.256 --> 00:06:04.896 A:middle
playImmediately (atRate:)
which jumps you straight

00:06:04.896 --> 00:06:07.136 A:middle
into the playing state
from either the paused

00:06:07.136 --> 00:06:08.156 A:middle
or the waiting states.

00:06:09.106 --> 00:06:11.406 A:middle
Be aware that this
may lead to a stall

00:06:11.606 --> 00:06:14.606 A:middle
that the patient waiting
state would avoid.

00:06:15.266 --> 00:06:17.866 A:middle
So be careful.

00:06:18.156 --> 00:06:20.756 A:middle
AVPlayer's rate property might
not mean what you thought

00:06:20.756 --> 00:06:21.106 A:middle
it meant.

00:06:21.476 --> 00:06:22.966 A:middle
Let's recap so everyone's clear.

00:06:24.136 --> 00:06:28.146 A:middle
The player's rate property
is the app's requested

00:06:28.146 --> 00:06:28.806 A:middle
playback rate.

00:06:29.436 --> 00:06:31.526 A:middle
Not to be confused with
the time-based rate

00:06:31.776 --> 00:06:33.466 A:middle
of the player item
which is the rate

00:06:33.466 --> 00:06:35.056 A:middle
at which playback is
actually occurring.

00:06:35.646 --> 00:06:42.256 A:middle
We've added two new
properties in this release

00:06:43.476 --> 00:06:44.376 A:middle
to give you more detail.

00:06:44.686 --> 00:06:47.316 A:middle
One is the timeControlStatus,
which tells you

00:06:47.316 --> 00:06:49.986 A:middle
which of these states you're
in, paused, waiting or playing.

00:06:50.386 --> 00:06:51.876 A:middle
And if you're in
the waiting state,

00:06:52.896 --> 00:06:55.726 A:middle
the reasonForWaitingToPlay
property tells you why.

00:06:56.476 --> 00:06:59.226 A:middle
For example, you could
be in the waiting state,

00:06:59.226 --> 00:07:03.146 A:middle
so the AVPlayer's rate
property could be 1.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.226 --> 00:07:03.146 A:middle
so the AVPlayer's rate
property could be 1.

00:07:03.806 --> 00:07:06.746 A:middle
The timebased.rate would be
0 because you're waiting.

00:07:06.876 --> 00:07:08.956 A:middle
The timeControlStatus
would again say I'm

00:07:08.956 --> 00:07:10.366 A:middle
WaitingToPlayAtSpcifiedRate.

00:07:10.876 --> 00:07:12.436 A:middle
And the reasonForWaitingToPlay
could be

00:07:12.756 --> 00:07:14.146 A:middle
WaitingToMinimizeStallsReason.

00:07:15.556 --> 00:07:16.446 A:middle
So with that background,

00:07:16.756 --> 00:07:18.926 A:middle
I'd like to introduce my
friend Moritz Wittenhagen

00:07:18.926 --> 00:07:20.996 A:middle
who is much braver
than me, as he is going

00:07:20.996 --> 00:07:24.856 A:middle
to attempt a network
playback demo live on stage.

00:07:24.856 --> 00:07:26.446 A:middle
So everyone cross your
fingers and give him a hand.

00:07:27.516 --> 00:07:30.546 A:middle
[ Applause ]

00:07:31.046 --> 00:07:32.516 A:middle
&gt;&gt; Well, good morning everyone.

00:07:32.516 --> 00:07:36.166 A:middle
I want to start by
showing you a little bit

00:07:36.306 --> 00:07:37.826 A:middle
of the setup we have
on stage here.

00:07:38.126 --> 00:07:40.476 A:middle
And I have my iPad which
you can see mirrored

00:07:40.476 --> 00:07:41.326 A:middle
on the screen there.

00:07:41.886 --> 00:07:44.096 A:middle
And that iPad is
joining a network

00:07:44.096 --> 00:07:45.316 A:middle
that is hosted by my Mac.

00:07:45.316 --> 00:07:48.846 A:middle
And what that allows me to do
is I can use the network link

00:07:48.846 --> 00:07:51.666 A:middle
conditioner to actually
limit the network connection

00:07:51.666 --> 00:07:53.096 A:middle
that this iPad has available.

00:07:53.766 --> 00:07:55.526 A:middle
Can do that using the
network link conditioner

00:07:55.526 --> 00:07:56.166 A:middle
preference pane.

00:07:56.166 --> 00:07:58.556 A:middle
Sam will tell you in a
minute where to find that.

00:07:58.556 --> 00:08:02.596 A:middle
And I've set up a profile called
Slow Server that limits this


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.556 --> 00:08:02.596 A:middle
And I've set up a profile called
Slow Server that limits this

00:08:02.596 --> 00:08:05.826 A:middle
to a mediocre network connection
that's a little slower

00:08:05.826 --> 00:08:09.276 A:middle
than the media bitrate that
we actually want to play.

00:08:09.396 --> 00:08:11.196 A:middle
It's currently turned off.

00:08:11.396 --> 00:08:14.156 A:middle
And we'll leave it off, and
let's look at what the iPad does

00:08:14.716 --> 00:08:16.796 A:middle
in a decent network situation.

00:08:17.426 --> 00:08:20.036 A:middle
So what I have here
is just a selection,

00:08:20.036 --> 00:08:21.766 A:middle
and I can just select one video.

00:08:21.946 --> 00:08:22.616 A:middle
Let me do that.

00:08:22.616 --> 00:08:26.296 A:middle
And what you see is that
the video immediately loads,

00:08:26.586 --> 00:08:32.015 A:middle
and we see that we're
currently not playing.

00:08:32.336 --> 00:08:34.645 A:middle
You see this wonderful
engineering UI underneath

00:08:34.645 --> 00:08:37.405 A:middle
that gives us all the properties

00:08:37.405 --> 00:08:39.535 A:middle
and functionality involved
in automatic waiting.

00:08:39.956 --> 00:08:43.346 A:middle
This is really just taken from
AVPlayer and AVPlayer items.

00:08:43.346 --> 00:08:46.796 A:middle
So these are the properties that
you have available if you need

00:08:46.796 --> 00:08:48.726 A:middle
to know what automatic
waiting is doing.

00:08:49.326 --> 00:08:51.826 A:middle
So right now we are paused,
so the rates are all zero.

00:08:51.826 --> 00:08:52.836 A:middle
Current time is at zero.

00:08:52.836 --> 00:08:56.436 A:middle
But the interesting thing is
since we're in a fast network,

00:08:56.436 --> 00:08:58.486 A:middle
we've loaded 39 seconds
of the video,

00:08:58.526 --> 00:08:59.856 A:middle
which is actually
the whole video.

00:08:59.856 --> 00:09:02.746 A:middle
And we're currently
likely to keep up.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.856 --> 00:09:02.746 A:middle
And we're currently
likely to keep up.

00:09:03.056 --> 00:09:06.046 A:middle
What that means is that
when I just hit play now,

00:09:06.516 --> 00:09:09.756 A:middle
the video just starts
playing without any problem.

00:09:10.516 --> 00:09:12.556 A:middle
Now we wanted to
see what happens

00:09:12.636 --> 00:09:14.806 A:middle
in a bad network situation.

00:09:14.806 --> 00:09:17.476 A:middle
So let's turn on the network
link condition on the Mac.

00:09:18.496 --> 00:09:19.126 A:middle
Here we go.

00:09:19.126 --> 00:09:22.076 A:middle
And now not much
changed for this video.

00:09:22.076 --> 00:09:24.346 A:middle
Because as I said, it
was already buffered.

00:09:24.586 --> 00:09:26.326 A:middle
It had already buffered
the whole video.

00:09:26.966 --> 00:09:29.956 A:middle
So when I go back
and load this again,

00:09:29.956 --> 00:09:32.346 A:middle
I want you to pay
attention to loadedTimeRanges

00:09:32.346 --> 00:09:34.186 A:middle
and isPlaybackLIkelyToKeepUp
again.

00:09:34.826 --> 00:09:35.536 A:middle
So let's do it.

00:09:36.616 --> 00:09:37.426 A:middle
Relaod the video.

00:09:37.426 --> 00:09:39.816 A:middle
And now what we see is

00:09:39.816 --> 00:09:42.406 A:middle
that loadedTimeRange is
only slowly increase.

00:09:42.656 --> 00:09:45.126 A:middle
And isPlaybackLIkelyToKeepUp
is false.

00:09:45.236 --> 00:09:47.636 A:middle
Eventually it will become true.

00:09:47.806 --> 00:09:50.876 A:middle
And at that moment we're at the
same state that we were before

00:09:50.876 --> 00:09:55.656 A:middle
where now ready to play and
playback will just start.

00:09:55.656 --> 00:09:57.706 A:middle
Now let's try this
one more time,

00:09:57.706 --> 00:10:00.546 A:middle
and this time I will hit play
right after I loaded the video.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:57.706 --> 00:10:00.546 A:middle
and this time I will hit play
right after I loaded the video.

00:10:01.026 --> 00:10:03.926 A:middle
So this time we don't
have enough data,

00:10:03.926 --> 00:10:05.606 A:middle
and we go into this
waiting state.

00:10:05.606 --> 00:10:07.466 A:middle
And you see the spinner
telling the user

00:10:07.466 --> 00:10:08.986 A:middle
that playback is waiting.

00:10:08.986 --> 00:10:10.866 A:middle
Eventually we will
become ready to play

00:10:10.866 --> 00:10:11.886 A:middle
and playback just starts.

00:10:12.516 --> 00:10:14.266 A:middle
There's one more
thing we can do.

00:10:14.566 --> 00:10:16.056 A:middle
And that is immediate playback.

00:10:16.286 --> 00:10:17.196 A:middle
So let's also try this.

00:10:17.936 --> 00:10:20.416 A:middle
I go into the video

00:10:20.416 --> 00:10:22.606 A:middle
and immediately click
play immediately.

00:10:22.966 --> 00:10:25.926 A:middle
And we see that playback
starts but then we quickly run

00:10:25.926 --> 00:10:28.216 A:middle
into a stall because we
didn't have enough buffer

00:10:28.216 --> 00:10:28.966 A:middle
to play to the end.

00:10:29.366 --> 00:10:32.926 A:middle
In that case, we'll go into
the waiting state and re-buffer

00:10:32.926 --> 00:10:35.566 A:middle
until we have enough
to play through.

00:10:35.566 --> 00:10:39.836 A:middle
And with that, it was a short
demo of automatic waiting.

00:10:40.656 --> 00:10:41.846 A:middle
Go back to Sam and the slides.

00:10:42.516 --> 00:10:48.036 A:middle
[ Applause ]

00:10:48.536 --> 00:10:49.106 A:middle
Thanks, Moritz.

00:10:49.766 --> 00:10:51.496 A:middle
Let's recap what was
happening in the middle there.

00:10:52.156 --> 00:10:55.596 A:middle
So when we set a slower network
speed, close to the data rate

00:10:55.596 --> 00:10:58.636 A:middle
of the movie, the movie
started out paused.

00:10:59.356 --> 00:11:03.206 A:middle
When he hit play, it went
into the waiting state.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.356 --> 00:11:03.206 A:middle
When he hit play, it went
into the waiting state.

00:11:04.646 --> 00:11:07.456 A:middle
Because playback was not
yet likely to keep up.

00:11:08.396 --> 00:11:11.346 A:middle
Notice that at this time,
the player's rate was 1,

00:11:11.346 --> 00:11:12.786 A:middle
but the timebase rate was 0.

00:11:13.806 --> 00:11:16.676 A:middle
After a few seconds,
AVFoundation determined

00:11:17.476 --> 00:11:19.566 A:middle
that playback was
likely to keep up

00:11:19.686 --> 00:11:21.986 A:middle
and so it set the
time control --

00:11:22.446 --> 00:11:26.186 A:middle
it set the state into
playing, and now you see

00:11:26.186 --> 00:11:28.426 A:middle
that the player rate and the
timebase rate are both 1.

00:11:29.616 --> 00:11:32.156 A:middle
It may have occurred to you

00:11:32.156 --> 00:11:34.176 A:middle
that there's a little
bit more detail available

00:11:34.176 --> 00:11:36.696 A:middle
in the timeControlStatus than
in the player's rate property.

00:11:37.276 --> 00:11:39.556 A:middle
Remember the player's rate
property tells you the app's

00:11:39.556 --> 00:11:40.606 A:middle
desired playback rate.

00:11:40.846 --> 00:11:42.406 A:middle
The timeControlStatus also takes

00:11:42.406 --> 00:11:43.676 A:middle
into account what's
actually happening.

00:11:44.056 --> 00:11:45.826 A:middle
So that might be something
you want to take into account

00:11:45.826 --> 00:11:46.806 A:middle
when you build a playback UI.

00:11:47.576 --> 00:11:51.336 A:middle
In case you want to try this at
home, you might like to know how

00:11:51.336 --> 00:11:52.726 A:middle
to find the network
link conditioner.

00:11:52.726 --> 00:11:55.506 A:middle
It's not something we
invented in my time at least.

00:11:55.946 --> 00:11:59.816 A:middle
It is part of the
hardware IO tools download.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:00.316 --> 00:12:03.466 A:middle
To get it, the easiest way
is to follow Xcode's menu

00:12:03.466 --> 00:12:04.856 A:middle
to More Developer Tools.

00:12:05.456 --> 00:12:07.756 A:middle
And after you log in, you'll
find it something like here.

00:12:09.066 --> 00:12:15.686 A:middle
Okay, so on the 2016 SDKs if
you link on or after that,

00:12:16.206 --> 00:12:19.056 A:middle
your app will act as though
you had set this property

00:12:19.176 --> 00:12:21.366 A:middle
automatically
WaitsToMinimizeStalling to true.

00:12:21.896 --> 00:12:24.856 A:middle
You can set that property
to false if you want

00:12:24.856 --> 00:12:25.806 A:middle
to go back to the old behavior.

00:12:25.906 --> 00:12:27.566 A:middle
And there's a few reasons why
you might want to do this.

00:12:27.896 --> 00:12:33.276 A:middle
In particular, if you use the
setRate time atHostTime call

00:12:33.566 --> 00:12:36.286 A:middle
to synchronize playback
with external timeline,

00:12:36.816 --> 00:12:39.476 A:middle
then you must opt out by
setting the automatically

00:12:39.476 --> 00:12:41.406 A:middle
WaitsToMinimizeStalling
property to false.

00:12:41.796 --> 00:12:43.576 A:middle
Otherwise, you will meet
a friendly exception.

00:12:44.386 --> 00:12:45.136 A:middle
Your helpful reminder.

00:12:46.776 --> 00:12:49.826 A:middle
Finally, a reminder never
use the player's rate

00:12:49.826 --> 00:12:51.896 A:middle
to extrapolate current
timeout in the future.

00:12:52.436 --> 00:12:54.976 A:middle
If you want to do that, use
the item's timebase rate

00:12:54.976 --> 00:12:55.676 A:middle
for that instead.

00:12:56.016 --> 00:12:57.816 A:middle
Or use the other APIs
in the timebase object.

00:12:57.816 --> 00:12:58.486 A:middle
That's what they're for.

00:12:59.356 --> 00:13:00.766 A:middle
All right, that's
it for buffering.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.356 --> 00:13:00.766 A:middle
All right, that's
it for buffering.

00:13:01.136 --> 00:13:02.566 A:middle
Let's move along to
the topic of looping.

00:13:02.976 --> 00:13:03.976 A:middle
I have a question for you.

00:13:04.846 --> 00:13:07.406 A:middle
What's the best way to loop
playback of a single item?

00:13:07.946 --> 00:13:09.646 A:middle
Well, one idea would
be to set up a listener

00:13:09.646 --> 00:13:11.056 A:middle
for the notification that fires

00:13:11.256 --> 00:13:12.616 A:middle
when playback has
reached the end.

00:13:12.916 --> 00:13:13.876 A:middle
And when you get called,

00:13:14.256 --> 00:13:16.176 A:middle
seek back to the
beginning and start again.

00:13:16.846 --> 00:13:18.906 A:middle
Well, this idea is a good start.

00:13:19.166 --> 00:13:21.176 A:middle
But unfortunately,
it will lead to a gap

00:13:21.216 --> 00:13:22.876 A:middle
between the playbacks
for two reasons.

00:13:23.416 --> 00:13:25.196 A:middle
The first reason is that
there will be latency due

00:13:25.396 --> 00:13:27.246 A:middle
to the time it takes
for the notification

00:13:27.246 --> 00:13:30.506 A:middle
to reach your program and for
your second player requests

00:13:30.506 --> 00:13:31.916 A:middle
to get back to the
playback system.

00:13:32.706 --> 00:13:35.746 A:middle
The second more significant
reason is the time needed

00:13:35.926 --> 00:13:36.846 A:middle
for prerolling.

00:13:37.536 --> 00:13:38.506 A:middle
It's not actually possible

00:13:38.506 --> 00:13:40.976 A:middle
to start media playback
instantaneously

00:13:40.976 --> 00:13:41.946 A:middle
without some preparation.

00:13:42.386 --> 00:13:45.696 A:middle
It's necessary to load
media data and decode some

00:13:45.696 --> 00:13:47.686 A:middle
of it before you can
actually start playing it out.

00:13:48.276 --> 00:13:49.526 A:middle
This process of filling

00:13:49.526 --> 00:13:52.496 A:middle
up the playback pipelines
before playback starts is

00:13:52.496 --> 00:13:53.256 A:middle
called preroll.

00:13:54.666 --> 00:13:57.766 A:middle
So what we'd like to
be able to do here is

00:13:57.766 --> 00:14:00.136 A:middle
to have AVFoundation
be in on the plan.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.766 --> 00:14:00.136 A:middle
to have AVFoundation
be in on the plan.

00:14:00.796 --> 00:14:03.616 A:middle
If AVFoundation knows
about playback item B

00:14:03.876 --> 00:14:07.276 A:middle
but early enough, then
it can begin prerolling

00:14:07.446 --> 00:14:10.436 A:middle
and decoding before item A
has finished playing out.

00:14:10.716 --> 00:14:13.196 A:middle
And so it can optimize the
transition from A to B.

00:14:14.126 --> 00:14:18.056 A:middle
If item B is super short, then
AVFoundation may even start work

00:14:18.056 --> 00:14:19.466 A:middle
on the transition to item C.

00:14:20.986 --> 00:14:24.586 A:middle
AVFoundation's tool for
achieving this is AVQueuePlayer.

00:14:25.326 --> 00:14:28.856 A:middle
AVQueuePlayer is a subclass of
AVPlayer, which has an array

00:14:28.856 --> 00:14:30.836 A:middle
of AVPlayer items
called the play queue.

00:14:31.526 --> 00:14:34.586 A:middle
The current item is the one in
the first position of the array.

00:14:36.036 --> 00:14:38.296 A:middle
Now you can use AVQueuePlayer
to optimize transitions

00:14:38.296 --> 00:14:40.416 A:middle
between items that are
different, but for the case

00:14:40.416 --> 00:14:43.106 A:middle
of looping, you can create
multiple AVPlayer items

00:14:43.106 --> 00:14:44.656 A:middle
from the same AVAsset.

00:14:45.016 --> 00:14:46.496 A:middle
This is just another
optimization,

00:14:46.826 --> 00:14:48.746 A:middle
since AVFoundation
does not have to load

00:14:48.746 --> 00:14:51.126 A:middle
and pause the media
file multiple times.

00:14:52.146 --> 00:14:56.516 A:middle
And just a reminder, the
play queue is not a playlist.

00:14:57.116 --> 00:14:59.786 A:middle
Please do not load
the next 10,000 items

00:14:59.786 --> 00:15:02.426 A:middle
that you think you might like
to play into the play queue.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.786 --> 00:15:02.426 A:middle
that you think you might like
to play into the play queue.

00:15:02.426 --> 00:15:03.516 A:middle
That's not going
to be efficient.

00:15:03.896 --> 00:15:06.456 A:middle
The purpose of the play queue
is to provide information

00:15:06.456 --> 00:15:08.366 A:middle
about items to be
played in the near future

00:15:08.366 --> 00:15:11.406 A:middle
so that AVFoundation can
optimize transitions.

00:15:12.656 --> 00:15:15.106 A:middle
The design patent when you want

00:15:15.106 --> 00:15:17.666 A:middle
to loop a single media
file indefinitely is

00:15:17.666 --> 00:15:20.706 A:middle
to make a small number of
AVPlayer items and put them

00:15:20.706 --> 00:15:21.966 A:middle
in the AVQueuePlayer's queue

00:15:22.286 --> 00:15:25.046 A:middle
with the action item end
property set to advance.

00:15:26.566 --> 00:15:29.816 A:middle
When playback reaches the end
of one item, it will be removed

00:15:29.816 --> 00:15:32.586 A:middle
from the play queue as playback
advances to the next one.

00:15:33.426 --> 00:15:34.716 A:middle
And when you get
the notification

00:15:34.716 --> 00:15:36.986 A:middle
that that has happened, you
can take that finished item,

00:15:37.306 --> 00:15:40.066 A:middle
set its current time back to
the start, and put it on the end

00:15:40.066 --> 00:15:41.616 A:middle
of the play queue to reuse it.

00:15:42.656 --> 00:15:44.276 A:middle
We call this patent
the treadmill.

00:15:45.906 --> 00:15:48.216 A:middle
And you can implement the
treadmill patent yourself

00:15:48.216 --> 00:15:49.116 A:middle
using AVQueuePlayer.

00:15:49.246 --> 00:15:50.506 A:middle
We have sample code to help.

00:15:51.046 --> 00:15:53.166 A:middle
The slightly tricky detail
is that you have to set

00:15:53.166 --> 00:15:56.396 A:middle
up key value observing to
watch when the item is removed

00:15:56.866 --> 00:15:58.236 A:middle
and then seek it
back to the start.

00:15:58.706 --> 00:16:01.866 A:middle
And then add it to the end
of the play queue again.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.706 --> 00:16:01.866 A:middle
And then add it to the end
of the play queue again.

00:16:02.866 --> 00:16:07.076 A:middle
As you can see, in this code
we are deactivating our KVO

00:16:07.076 --> 00:16:08.866 A:middle
observer while we
change the play queue

00:16:09.206 --> 00:16:10.626 A:middle
to avoid any chance
of recursion.

00:16:11.346 --> 00:16:12.716 A:middle
So this is clearly doable.

00:16:12.716 --> 00:16:13.976 A:middle
It's just a little fiddley.

00:16:14.946 --> 00:16:16.326 A:middle
And the feedback
that we received was

00:16:16.366 --> 00:16:20.886 A:middle
that it would be awful swell
if we could make this easier.

00:16:20.976 --> 00:16:22.856 A:middle
So we're introducing
AVPlayerLooper,

00:16:23.126 --> 00:16:24.816 A:middle
which implements the
treadmill patent for you.

00:16:25.286 --> 00:16:26.556 A:middle
You give it an AVQueuePlayer.

00:16:27.516 --> 00:16:30.596 A:middle
[ Applause ]

00:16:31.096 --> 00:16:33.726 A:middle
You give it an AVQueue Player
and a template AVPlayerItem,

00:16:33.916 --> 00:16:36.476 A:middle
and it constructs a small number
of copies of that AVPlayerItem,

00:16:36.706 --> 00:16:38.306 A:middle
which it then cycles
through the play queue

00:16:38.306 --> 00:16:41.866 A:middle
until you tell it to stop.

00:16:41.866 --> 00:16:43.036 A:middle
Adopting AVPlayerLooper,

00:16:43.036 --> 00:16:45.856 A:middle
the code for the symbol
case is really much simpler.

00:16:47.006 --> 00:16:48.446 A:middle
So I want to give
you a demo of this

00:16:49.286 --> 00:16:50.556 A:middle
on an iPad I have over here.

00:16:51.016 --> 00:16:52.586 A:middle
So here's a piece
of sample code.

00:16:52.986 --> 00:16:54.576 A:middle
Video Looper, I'm
going to launch that.

00:16:54.946 --> 00:16:57.776 A:middle
And I have added a media file
of my own here and we're going

00:16:57.776 --> 00:16:58.946 A:middle
to play it with AVPlayerLooper.

00:16:59.516 --> 00:17:07.546 A:middle
[ Music ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.516 --> 00:17:07.546 A:middle
[ Music ]

00:17:08.046 --> 00:17:09.726 A:middle
Don't you feel mellow?

00:17:09.836 --> 00:17:12.646 A:middle
Okay, this is clearly looping,

00:17:12.646 --> 00:17:15.306 A:middle
and the code is pretty
much what I pointed out.

00:17:15.306 --> 00:17:16.226 A:middle
It's fairly simple.

00:17:16.726 --> 00:17:19.415 A:middle
This would be an appropriate
tool to use, for example,

00:17:19.746 --> 00:17:21.776 A:middle
if you have a tvOS app and you'd

00:17:21.776 --> 00:17:24.806 A:middle
like to loop background
video behind a title menu.

00:17:25.256 --> 00:17:32.686 A:middle
All right, let's
return to slides.

00:17:33.396 --> 00:17:37.546 A:middle
We've talked a bit
about how to loop.

00:17:37.686 --> 00:17:41.706 A:middle
I want to spend a
moment on what to loop.

00:17:42.916 --> 00:17:45.636 A:middle
Ideally, if you have both
audio and video tracks,

00:17:45.956 --> 00:17:47.556 A:middle
they should be precisely
the same length.

00:17:48.046 --> 00:17:52.366 A:middle
Why? Well, if the audio track
is longer, then that means

00:17:52.366 --> 00:17:54.236 A:middle
that near the end
there's period of time

00:17:54.236 --> 00:17:56.496 A:middle
when audio should be
playing but video should not.

00:17:57.426 --> 00:17:59.096 A:middle
We have an empty
segment of video,

00:17:59.176 --> 00:18:00.546 A:middle
so what should the video do?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.176 --> 00:18:00.546 A:middle
so what should the video do?

00:18:00.546 --> 00:18:01.656 A:middle
Should it go away?

00:18:01.756 --> 00:18:03.256 A:middle
Should you freeze on one frame?

00:18:04.206 --> 00:18:06.996 A:middle
Conversely, if the video track
is longer, then there's a period

00:18:06.996 --> 00:18:08.986 A:middle
of time when the audio
should be silent.

00:18:09.936 --> 00:18:13.466 A:middle
So when you build media assets
for looping, take the time

00:18:13.466 --> 00:18:15.316 A:middle
to make sure that the
track durations match up.

00:18:15.676 --> 00:18:16.796 A:middle
In QuickTime Movie files,

00:18:17.006 --> 00:18:18.956 A:middle
the track duration is
defined by the edit list.

00:18:19.546 --> 00:18:22.616 A:middle
Now if the media asset
to loop is not entirely

00:18:22.616 --> 00:18:24.836 A:middle
under your control,
another possibility is

00:18:24.836 --> 00:18:27.216 A:middle
that you could set the
AVPlayerItems forward playback

00:18:27.216 --> 00:18:30.176 A:middle
end time to the length
of the shortest track.

00:18:30.726 --> 00:18:31.606 A:middle
This will have the effect

00:18:31.606 --> 00:18:33.176 A:middle
of trimming back the
other tracks to match.

00:18:35.756 --> 00:18:38.826 A:middle
All right, next look at an
optimization that we've made

00:18:39.086 --> 00:18:40.186 A:middle
in the playback pipeline

00:18:40.446 --> 00:18:42.516 A:middle
that may have an impact
on your applications.

00:18:43.716 --> 00:18:46.636 A:middle
Suppose that we are currently
playing, and the lists

00:18:46.636 --> 00:18:48.386 A:middle
of playing tracks changes.

00:18:48.756 --> 00:18:52.786 A:middle
For example, we could
change the subtitle language

00:18:53.136 --> 00:18:54.146 A:middle
or the audio language.

00:18:54.666 --> 00:18:55.936 A:middle
Audio from English to French.

00:18:56.436 --> 00:18:57.766 A:middle
Here I'll change the
subtitle language

00:18:57.766 --> 00:18:58.826 A:middle
from English to Spanish.

00:18:59.396 --> 00:19:02.646 A:middle
Or we could remove
the AVPlayerLayer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.396 --> 00:19:02.646 A:middle
Or we could remove
the AVPlayerLayer

00:19:02.646 --> 00:19:03.706 A:middle
that was displaying the video.

00:19:05.716 --> 00:19:08.926 A:middle
Or we could add an AVPlayerLayer
and begin displaying video.

00:19:09.486 --> 00:19:13.716 A:middle
Well, in all of these
cases in iOS 9,

00:19:14.036 --> 00:19:16.216 A:middle
AVFoundation will
pause playback,

00:19:16.496 --> 00:19:19.616 A:middle
adjust the playback pipelines to
match the list of enables tracks

00:19:19.866 --> 00:19:20.946 A:middle
and then resume playback.

00:19:21.426 --> 00:19:23.546 A:middle
In some cases, this
even causes video

00:19:23.546 --> 00:19:24.846 A:middle
to snap back to a key frame.

00:19:25.366 --> 00:19:28.666 A:middle
Well, I will say we have
received constructive feedback

00:19:28.786 --> 00:19:30.416 A:middle
from users and developers
about this.

00:19:31.346 --> 00:19:37.066 A:middle
And so I'm happy to
say that in iOS 10

00:19:37.066 --> 00:19:38.746 A:middle
and its other 2016 siblings,

00:19:38.996 --> 00:19:41.946 A:middle
these changes will no longer
cause playback to pause.

00:19:42.326 --> 00:19:44.806 A:middle
Adding or removing
the only AVPlayerLayer

00:19:44.806 --> 00:19:47.986 A:middle
on a playing AVPlayer,
changing the subtitle language

00:19:47.986 --> 00:19:49.956 A:middle
or the audio language
on a playing AVPlayer

00:19:49.956 --> 00:19:52.376 A:middle
or manually disabling
or enabling tracks.

00:19:52.996 --> 00:19:56.626 A:middle
We think that this
is an enhancement

00:19:56.626 --> 00:19:57.786 A:middle
for users and developers.

00:19:57.786 --> 00:20:00.796 A:middle
However, it's a significant
change in API behavior,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:57.786 --> 00:20:00.796 A:middle
However, it's a significant
change in API behavior,

00:20:00.916 --> 00:20:06.436 A:middle
and so I would ask you please
take a look in the seeds and see

00:20:06.436 --> 00:20:08.656 A:middle
if it leads to any
complications in your apps.

00:20:09.026 --> 00:20:11.286 A:middle
If you find an issue with this
that looks like it's a bug

00:20:11.286 --> 00:20:13.416 A:middle
on our side, then
please provide feedback

00:20:13.416 --> 00:20:15.556 A:middle
by filing a bug using the
Apple Bug Reporter System.

00:20:15.866 --> 00:20:17.506 A:middle
And as always when filing a bug,

00:20:17.806 --> 00:20:19.956 A:middle
please try to give us
everything we need in order

00:20:19.956 --> 00:20:21.376 A:middle
to reproduce the
problem ourselves.

00:20:25.296 --> 00:20:30.116 A:middle
Our industry is undergoing a
transition to wider color gamuts

00:20:30.416 --> 00:20:32.366 A:middle
for digital photography
and digital video.

00:20:32.856 --> 00:20:36.846 A:middle
Many developers on iOS have
never had to deal with video

00:20:36.846 --> 00:20:40.186 A:middle
that wasn't using the standard
recommendation 709 color space.

00:20:40.486 --> 00:20:42.686 A:middle
Since that's the standard
for high-definition video

00:20:42.686 --> 00:20:45.016 A:middle
and that's what we've been
shooting since the iPhone 4.

00:20:45.646 --> 00:20:47.846 A:middle
But wider gamut color
spaces are coming.

00:20:48.766 --> 00:20:51.486 A:middle
As you may have seen
with the newest iPad Pro

00:20:51.746 --> 00:20:56.976 A:middle
when running iOS 10, you can
capture and display photographs

00:20:57.296 --> 00:20:58.986 A:middle
in the P3 color space.

00:20:59.716 --> 00:21:03.236 A:middle
Some third party products are
capturing video in P3 also.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.716 --> 00:21:03.236 A:middle
Some third party products are
capturing video in P3 also.

00:21:03.886 --> 00:21:07.046 A:middle
So I wanted to give you pointers
to the APIs you can adopt

00:21:07.046 --> 00:21:09.086 A:middle
in your apps to be prepared

00:21:09.086 --> 00:21:11.896 A:middle
for making your apps
wide color video aware.

00:21:12.716 --> 00:21:16.056 A:middle
But I need to give you a
little bit of background first.

00:21:16.236 --> 00:21:18.966 A:middle
In media files, color
space information is part

00:21:18.966 --> 00:21:20.806 A:middle
of the metadata of video tracks.

00:21:21.176 --> 00:21:23.996 A:middle
In QuickTime Movie files, it's
stored in sample descriptions.

00:21:24.276 --> 00:21:27.266 A:middle
In several Codecs also store
it in Codec specific places.

00:21:27.706 --> 00:21:29.716 A:middle
There are three principle
parts to this information.

00:21:30.466 --> 00:21:33.906 A:middle
Color Primaries, which specific
what the 100 percent red,

00:21:33.906 --> 00:21:36.686 A:middle
100 percent green, and 100
percent blue colors are

00:21:36.836 --> 00:21:37.826 A:middle
and also the white point.

00:21:39.016 --> 00:21:40.236 A:middle
Transfer Characteristics,

00:21:40.736 --> 00:21:42.356 A:middle
which you may have heard
called gamma curves

00:21:42.756 --> 00:21:43.616 A:middle
or transfer function.

00:21:44.586 --> 00:21:48.506 A:middle
These define the mapping from
pixel values to light levels

00:21:49.206 --> 00:21:52.966 A:middle
and answer the question is that
a straight line or is it a curve

00:21:52.966 --> 00:21:55.126 A:middle
that gives you more
detail in the dark areas

00:21:55.126 --> 00:21:56.276 A:middle
where our eyes are
more sensitive.

00:21:57.166 --> 00:22:00.446 A:middle
And the YCbCr Matrix,
the coordinate transform


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.166 --> 00:22:00.446 A:middle
And the YCbCr Matrix,
the coordinate transform

00:22:00.676 --> 00:22:03.246 A:middle
from their RGB space
into the space used

00:22:03.246 --> 00:22:04.836 A:middle
for efficient compression.

00:22:06.376 --> 00:22:08.306 A:middle
So up here I have some examples.

00:22:08.726 --> 00:22:11.166 A:middle
Now if you haven't heard of
it, Recommendation 709 is

00:22:11.166 --> 00:22:12.826 A:middle
like the video equivalent
of SIGB.

00:22:12.826 --> 00:22:14.636 A:middle
SIGB is actually based on Rec.

00:22:14.636 --> 00:22:17.426 A:middle
709. Wide color can be achieved

00:22:17.816 --> 00:22:19.996 A:middle
by using a different
set of color primaries.

00:22:20.596 --> 00:22:26.216 A:middle
The P3 color primaries specify
values for 100 percent red,

00:22:26.216 --> 00:22:28.466 A:middle
100 percent green,
and 100 percent blue

00:22:28.636 --> 00:22:31.326 A:middle
that are more vivid then
Recommendation 709s.

00:22:31.876 --> 00:22:35.536 A:middle
One more point I want to make.

00:22:36.306 --> 00:22:39.346 A:middle
In our APIs, we generally
represent these choices

00:22:39.916 --> 00:22:42.076 A:middle
through the use of enumerated
strings, since they're easier

00:22:42.076 --> 00:22:43.596 A:middle
to print and display and debug.

00:22:44.086 --> 00:22:47.266 A:middle
But in media files, these
are represented by numbers.

00:22:47.576 --> 00:22:49.476 A:middle
And these standard tag
numbers are defined

00:22:49.476 --> 00:22:52.576 A:middle
in an MPEG specification called
coding independent code points.

00:22:52.966 --> 00:22:54.296 A:middle
That sounds like a
paradox, doesn't it?

00:22:54.326 --> 00:22:56.486 A:middle
How can you be coding
independent code points?

00:22:56.486 --> 00:22:59.996 A:middle
Well, it's less than a
paradox if you read it

00:22:59.996 --> 00:23:01.886 A:middle
as Codec independent
code points.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.996 --> 00:23:01.886 A:middle
as Codec independent
code points.

00:23:02.376 --> 00:23:04.856 A:middle
The job of the spec is to
make sure that the assignment

00:23:04.856 --> 00:23:06.226 A:middle
of these tag numbers
is done in a manner

00:23:06.226 --> 00:23:08.976 A:middle
that is harmonious all
Codecs and file formats.

00:23:09.246 --> 00:23:11.056 A:middle
So the interpretation of
numbers will be the same

00:23:11.276 --> 00:23:14.296 A:middle
in QuickTime Movie,
MPEG-4, H264 and so forth.

00:23:14.296 --> 00:23:17.546 A:middle
All right, with that background,
let's look at a few new APIs.

00:23:18.346 --> 00:23:21.596 A:middle
We have introduced a new media
characteristic that tells you

00:23:21.596 --> 00:23:24.076 A:middle
that at video track is tagged
with wider color primaries,

00:23:24.076 --> 00:23:24.986 A:middle
something wider than the Rec.

00:23:24.986 --> 00:23:25.936 A:middle
709 primaries.

00:23:26.486 --> 00:23:28.796 A:middle
If your app finds that
there is wide gamut video,

00:23:29.256 --> 00:23:30.946 A:middle
it might be appropriate
for your app to take steps

00:23:30.946 --> 00:23:33.986 A:middle
to preserve it, so it isn't
clamped back into the 709 space.

00:23:34.936 --> 00:23:37.326 A:middle
If not, it's actually generally
best to stay within Rec.

00:23:37.326 --> 00:23:38.916 A:middle
709 for processing.

00:23:39.466 --> 00:23:43.196 A:middle
So you can specify a working
color space when you set

00:23:43.196 --> 00:23:46.356 A:middle
up an AVPlayerItemVideoOutput
or an AVAssetReaderOutput.

00:23:47.266 --> 00:23:49.236 A:middle
And you will then receive
buffers that have been converted

00:23:49.236 --> 00:23:50.346 A:middle
into that color space.

00:23:50.876 --> 00:23:53.776 A:middle
You can also specify a target
color space when setting

00:23:53.776 --> 00:23:55.156 A:middle
up an AVAssetWriterInput,

00:23:55.536 --> 00:23:56.856 A:middle
in which case the
source image buffers

00:23:56.856 --> 00:23:58.576 A:middle
that you provide
will be converted

00:23:58.576 --> 00:24:00.196 A:middle
into that color space
prior to compression.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.576 --> 00:24:00.196 A:middle
into that color space
prior to compression.

00:24:00.716 --> 00:24:05.936 A:middle
With AVPlayerItemVideoOutput
or AVAssetReaderOutput

00:24:06.266 --> 00:24:08.336 A:middle
if you don't want image
buffers to be converted

00:24:08.336 --> 00:24:09.626 A:middle
into a common color space,

00:24:09.886 --> 00:24:13.076 A:middle
then you should set the
AVVideoAllowWideColorKey to true

00:24:13.706 --> 00:24:16.016 A:middle
and then you'll receive buffers
in their original color space.

00:24:16.336 --> 00:24:19.626 A:middle
This is effectively a promise
that whatever software receives

00:24:19.626 --> 00:24:22.326 A:middle
and processes those buffers,
whether it's ours or yours,

00:24:22.576 --> 00:24:24.686 A:middle
it will examine and honor
their color space tags.

00:24:25.186 --> 00:24:27.776 A:middle
There are analogous properties

00:24:27.836 --> 00:24:29.626 A:middle
for configuring video
compositions.

00:24:29.936 --> 00:24:32.366 A:middle
First, you can specify
a working color space

00:24:32.366 --> 00:24:33.896 A:middle
for entire video compositions.

00:24:34.766 --> 00:24:36.866 A:middle
Alternatively, if you have
a custom video compositor,

00:24:37.086 --> 00:24:38.756 A:middle
you may choose to make
it wide color aware.

00:24:39.286 --> 00:24:42.436 A:middle
You can declare that your custom
video compositor is wide color

00:24:42.436 --> 00:24:45.376 A:middle
aware and that it examines
and honors color space tags

00:24:45.376 --> 00:24:47.026 A:middle
on every single source
frame buffer

00:24:47.376 --> 00:24:50.186 A:middle
by implementing the optional
supportsWideColorSourceFrames

00:24:50.186 --> 00:24:51.456 A:middle
property and returning true.

00:24:51.556 --> 00:24:54.926 A:middle
Running it out with a reminder,

00:24:56.386 --> 00:24:58.556 A:middle
if you create picture
buffers manually, for example,

00:24:58.556 --> 00:24:59.926 A:middle
using a pixel buffer
pool in metal,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:00.376 --> 00:25:02.476 A:middle
then you should explicitly
set the color space tags

00:25:02.476 --> 00:25:04.626 A:middle
on every buffer by
calling core videos APIs.

00:25:05.176 --> 00:25:06.706 A:middle
Most developers won't
need to do this.

00:25:06.936 --> 00:25:09.446 A:middle
In most cases when you're
using a color space aware API

00:25:09.446 --> 00:25:12.366 A:middle
for source buffers, that'll take
care of tagging them for you.

00:25:12.666 --> 00:25:14.206 A:middle
By popular request, I'm
going to spend the rest

00:25:14.206 --> 00:25:16.696 A:middle
of our time discussing
some best practices

00:25:16.696 --> 00:25:18.576 A:middle
for optimizing playback
startup time.

00:25:18.966 --> 00:25:21.886 A:middle
I'll talk about local
file playback first.

00:25:21.986 --> 00:25:23.696 A:middle
And then we'll move on
to HTTP Live Streaming.

00:25:24.586 --> 00:25:26.916 A:middle
Now some of these
optimization techniques may be

00:25:26.916 --> 00:25:28.206 A:middle
counterintuitive at first.

00:25:28.486 --> 00:25:29.976 A:middle
They require you
to consider things

00:25:29.976 --> 00:25:32.326 A:middle
from the perspective
of AVFoundation.

00:25:32.796 --> 00:25:35.526 A:middle
And to think about when it
gets the information it needs

00:25:35.666 --> 00:25:37.286 A:middle
to do what your app
is asking it to do.

00:25:37.656 --> 00:25:40.446 A:middle
For example, here is a
straightforward piece of code

00:25:40.586 --> 00:25:42.446 A:middle
for setting up playback
of a local file.

00:25:43.086 --> 00:25:44.536 A:middle
We start with the
URL to the file.

00:25:44.536 --> 00:25:47.796 A:middle
We create an AVURLAsset
representing the product

00:25:47.796 --> 00:25:48.756 A:middle
depositing that file.

00:25:49.476 --> 00:25:52.266 A:middle
We then create an AVPlayerItem
to hold the mutable state

00:25:52.266 --> 00:25:54.706 A:middle
for playback, and an AVPlayer
item to host playback.

00:25:55.126 --> 00:25:56.646 A:middle
And then we create
an AVPlayerLayer

00:25:57.056 --> 00:25:59.206 A:middle
to connect video playback
into our display hierarchy.

00:25:59.766 --> 00:26:02.476 A:middle
Now this code is correct,
but it has a small flaw,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.766 --> 00:26:02.476 A:middle
Now this code is correct,
but it has a small flaw,

00:26:02.476 --> 00:26:04.316 A:middle
which maybe you may
not initially see.

00:26:05.066 --> 00:26:06.456 A:middle
As soon as the player
item is set

00:26:06.456 --> 00:26:09.106 A:middle
as the player's current item,
the player starts setting

00:26:09.106 --> 00:26:10.046 A:middle
up the playback pipeline.

00:26:10.076 --> 00:26:11.396 A:middle
Now it doesn't know the future.

00:26:11.396 --> 00:26:12.546 A:middle
It doesn't know that
you're going

00:26:12.546 --> 00:26:14.676 A:middle
to set an AVPlayerLayout later.

00:26:15.706 --> 00:26:18.286 A:middle
So it sets things up
for audio only playback.

00:26:18.586 --> 00:26:22.326 A:middle
And then when the AVPlayerLayer
is added, now AVFoundation knows

00:26:22.356 --> 00:26:23.916 A:middle
that the video needs
to be decoded too.

00:26:23.916 --> 00:26:25.746 A:middle
And so now it can
reconfigure things

00:26:25.946 --> 00:26:27.246 A:middle
for audio and video playback.

00:26:28.616 --> 00:26:33.026 A:middle
Now, as I said earlier,
we have made enhancements

00:26:33.026 --> 00:26:38.386 A:middle
in this year's OS releases
to mean that minor changes

00:26:38.516 --> 00:26:40.176 A:middle
to the list of playback
to the list

00:26:40.176 --> 00:26:42.396 A:middle
of enabled tracks do
not necessarily cause

00:26:42.396 --> 00:26:43.166 A:middle
an interruption.

00:26:43.656 --> 00:26:46.976 A:middle
But it still ideal to
start with the information

00:26:46.976 --> 00:26:49.596 A:middle
that AVFoundation needs in order
to get things right first time.

00:26:49.596 --> 00:26:51.366 A:middle
So I'm going to change
this code a little bit.

00:26:51.366 --> 00:26:53.776 A:middle
I'm going to watch where the
AVPlayerItem is connected

00:26:54.166 --> 00:26:55.066 A:middle
to the AVPlayer.

00:26:57.346 --> 00:27:00.176 A:middle
So now the player is
created with no current item,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.346 --> 00:27:00.176 A:middle
So now the player is
created with no current item,

00:27:00.176 --> 00:27:02.696 A:middle
which means it has no reason to
build playback pipelines yet.

00:27:03.106 --> 00:27:05.436 A:middle
And that doesn't change when
you add the AVPlayerLayer.

00:27:06.296 --> 00:27:07.686 A:middle
Playback pipelines
don't get built

00:27:07.846 --> 00:27:09.586 A:middle
until the player item
becomes the current item.

00:27:09.736 --> 00:27:12.246 A:middle
And by that point, the
player know what it needs

00:27:12.246 --> 00:27:14.026 A:middle
to get things right first time.

00:27:14.966 --> 00:27:15.936 A:middle
We can generalize this.

00:27:16.226 --> 00:27:19.316 A:middle
First, create the AVPlayerLayer,
so first create the AVPlayer

00:27:19.316 --> 00:27:20.746 A:middle
and AVPlayerItem objects.

00:27:20.966 --> 00:27:22.396 A:middle
And set whatever
properties you need

00:27:22.396 --> 00:27:25.966 A:middle
to on them including connecting
the AVPlayer to an AVPlayerLayer

00:27:25.966 --> 00:27:28.826 A:middle
or an AVPlayerItem to an
AVPlayerItemVideoOutput.

00:27:30.846 --> 00:27:33.106 A:middle
Now this might seem crazy,
but if you just want playback

00:27:33.326 --> 00:27:34.946 A:middle
to start right away,
you can tell the player

00:27:34.946 --> 00:27:36.776 A:middle
to play before you give
it the item to play.

00:27:37.236 --> 00:27:37.986 A:middle
Why would you do this?

00:27:38.656 --> 00:27:39.806 A:middle
Well, if you do it
the other way around,

00:27:40.086 --> 00:27:41.486 A:middle
the player initially
thinks that you wanted

00:27:41.486 --> 00:27:43.436 A:middle
to display the still frame
at the start of the video.

00:27:43.936 --> 00:27:46.566 A:middle
And it might waste some time on
that before it gets the message

00:27:46.566 --> 00:27:48.066 A:middle
that actually you
just want playback.

00:27:48.536 --> 00:27:50.746 A:middle
Again, starting with the
actual goal may shave off a

00:27:50.746 --> 00:27:51.536 A:middle
few milliseconds.

00:27:51.606 --> 00:27:53.476 A:middle
Let's move on to HLS.

00:27:53.476 --> 00:27:57.576 A:middle
The timeframes we're trying to
optimize with HLS are longer

00:27:57.876 --> 00:28:00.216 A:middle
because they're donated by
network IO which is much slower


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:57.876 --> 00:28:00.216 A:middle
because they're donated by
network IO which is much slower

00:28:00.216 --> 00:28:01.436 A:middle
than local file storage.

00:28:01.906 --> 00:28:02.846 A:middle
So the potential benefits

00:28:02.846 --> 00:28:04.926 A:middle
of optimizations are
much more noticeable.

00:28:05.726 --> 00:28:07.576 A:middle
The network IO breaks
down into four pieces.

00:28:07.786 --> 00:28:10.096 A:middle
Retrieving the master playlist
that's the URL you passed

00:28:10.096 --> 00:28:10.826 A:middle
to AVURLAsset.

00:28:11.326 --> 00:28:13.256 A:middle
If the content is protected
with fair play streaming,

00:28:13.646 --> 00:28:15.186 A:middle
retrieving content keys,

00:28:15.886 --> 00:28:17.556 A:middle
retrieving the selected
variant playlists

00:28:17.556 --> 00:28:20.636 A:middle
for the appropriate bitrate
and format of video and audio,

00:28:21.066 --> 00:28:22.566 A:middle
and retrieving some
media segments

00:28:22.826 --> 00:28:23.976 A:middle
that are referenced
in that playlist.

00:28:24.226 --> 00:28:25.986 A:middle
Now the media segments
will be the highest amount

00:28:25.986 --> 00:28:28.636 A:middle
of actual data transfer but
with network IO we need to think

00:28:28.636 --> 00:28:29.716 A:middle
about round-trip latency.

00:28:30.506 --> 00:28:32.086 A:middle
Some of these stages
are serialized.

00:28:32.636 --> 00:28:35.226 A:middle
You can't download
things from playlist

00:28:35.576 --> 00:28:37.256 A:middle
until you've received
the playlist.

00:28:38.836 --> 00:28:42.196 A:middle
So a thing to think about
then is can we do any

00:28:42.196 --> 00:28:44.326 A:middle
of these things before
the user chooses to play?

00:28:44.866 --> 00:28:49.356 A:middle
For example, maybe in your
app you display a title card

00:28:49.356 --> 00:28:52.516 A:middle
when content is first selected,
and that gets the user to say,

00:28:52.516 --> 00:28:53.946 A:middle
is this actually the
one I wanted to play?

00:28:53.946 --> 00:28:55.286 A:middle
Or do I want to read some
information about it.

00:28:56.036 --> 00:28:59.456 A:middle
So the question is, could
we do some small amount

00:28:59.456 --> 00:29:00.956 A:middle
of network IO speculatively


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.456 --> 00:29:00.956 A:middle
of network IO speculatively

00:29:01.826 --> 00:29:04.326 A:middle
when the user has identified
the content they probably want

00:29:04.326 --> 00:29:05.556 A:middle
to play before they
make it official?

00:29:06.476 --> 00:29:09.676 A:middle
Well, AVURLAsset is a lazy API.

00:29:10.256 --> 00:29:11.946 A:middle
It doesn't begin loading
or pausing any data

00:29:11.946 --> 00:29:13.026 A:middle
until someone asks it to.

00:29:13.026 --> 00:29:15.996 A:middle
To trigger it to load data
from the master playlist,

00:29:16.046 --> 00:29:18.576 A:middle
we need to ask it to load a
value that would derive from it

00:29:18.626 --> 00:29:22.256 A:middle
like duration or available
media characteristics

00:29:22.256 --> 00:29:23.376 A:middle
with media selection options.

00:29:23.786 --> 00:29:24.936 A:middle
Duration is easy to type.

00:29:25.706 --> 00:29:27.606 A:middle
You don't have to provide a
completion handler here unless

00:29:27.746 --> 00:29:31.136 A:middle
you're actually going to do
something with that value.

00:29:31.136 --> 00:29:33.506 A:middle
Speaking of playlists, they
can press really easily,

00:29:33.506 --> 00:29:36.206 A:middle
and we've supported compressing
them with gzip for many years.

00:29:36.596 --> 00:29:37.626 A:middle
So make sure you're doing that.

00:29:38.066 --> 00:29:40.556 A:middle
Possibly it's just a matter
of configuring your server.

00:29:41.196 --> 00:29:43.796 A:middle
If your content is protected
using fair play streaming,

00:29:43.796 --> 00:29:44.836 A:middle
then there's round-trip involved

00:29:44.836 --> 00:29:47.116 A:middle
in negotiating content
keys with your server.

00:29:47.456 --> 00:29:48.766 A:middle
And you can trigger
that to happen sooner

00:29:48.986 --> 00:29:51.346 A:middle
by setting the
preloadsEligibleContentKeys

00:29:51.346 --> 00:29:53.636 A:middle
property of the
asset.resourceLoader to true.

00:29:53.866 --> 00:29:56.256 A:middle
For this to work, the
master playlist must contain

00:29:56.256 --> 00:29:57.496 A:middle
SESSION-KEY declarations.

00:29:58.046 --> 00:30:00.106 A:middle
So how are we doing so far?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:58.046 --> 00:30:00.106 A:middle
So how are we doing so far?

00:30:00.286 --> 00:30:02.186 A:middle
With these techniques,
we can start --

00:30:02.296 --> 00:30:05.176 A:middle
they can get the master playlist
and the content keys downloaded,

00:30:05.476 --> 00:30:06.746 A:middle
while we're still
on the title card.

00:30:06.746 --> 00:30:07.486 A:middle
Now that's pretty cool.

00:30:08.036 --> 00:30:10.046 A:middle
The variant playlists
and the segments

00:30:10.046 --> 00:30:12.146 A:middle
of data will still
load after we hit play.

00:30:12.656 --> 00:30:13.836 A:middle
So you might be asking
yourselves,

00:30:14.076 --> 00:30:16.426 A:middle
can we push this
technique even further?

00:30:17.146 --> 00:30:19.456 A:middle
Well, there is a new
API in 2016 called

00:30:19.456 --> 00:30:20.946 A:middle
preferredForwardBufferDuration.

00:30:21.626 --> 00:30:23.076 A:middle
Setting it to something low

00:30:23.076 --> 00:30:25.296 A:middle
like five seconds will
buffer the minimum amount

00:30:25.296 --> 00:30:27.796 A:middle
that AVFoundation thinks
you need to get started.

00:30:28.436 --> 00:30:31.516 A:middle
But once playback begins,
set the override back to zero

00:30:31.696 --> 00:30:34.546 A:middle
to allow normal buffering
algorithms to take over again.

00:30:35.016 --> 00:30:38.666 A:middle
Here's a list of video variance

00:30:38.766 --> 00:30:40.326 A:middle
that might be in
a master playlist.

00:30:40.826 --> 00:30:42.576 A:middle
They vary in dimensions
and bitrate.

00:30:43.156 --> 00:30:46.156 A:middle
For an Apple TV on a fast
connection with a big TV,

00:30:46.156 --> 00:30:47.846 A:middle
the 1080p variant
might be ideal.

00:30:48.516 --> 00:30:52.706 A:middle
For an iPhone SE, even with
a superfast Wi-Fi connection,

00:30:52.706 --> 00:30:54.756 A:middle
the 720p variant
is the best choice.

00:30:54.966 --> 00:30:57.596 A:middle
It's already higher resolution
than the iPhone SE screen,

00:30:57.816 --> 00:30:59.756 A:middle
so going bigger probably
won't improve any quality.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.636 --> 00:31:03.996 A:middle
On a giant iPad Pro, there are
a lot of pixels, so we could go

00:31:03.996 --> 00:31:05.936 A:middle
up to a big variant
for full screen.

00:31:06.336 --> 00:31:07.576 A:middle
But if we play
picture-and-picture,

00:31:07.916 --> 00:31:09.606 A:middle
we don't need such a
high resolution anymore.

00:31:09.796 --> 00:31:13.076 A:middle
And a lower bitrate variant
could reduce the size

00:31:13.076 --> 00:31:15.466 A:middle
of our cache and help us
make more memory available

00:31:15.466 --> 00:31:16.256 A:middle
for other apps.

00:31:17.266 --> 00:31:19.506 A:middle
If the network connection
is slow on any device,

00:31:19.736 --> 00:31:20.926 A:middle
then that's going to
be the limiting factor.

00:31:21.386 --> 00:31:23.566 A:middle
So what this means is that
AVFoundation needs to take

00:31:23.566 --> 00:31:25.516 A:middle
into account both the
display dimensions

00:31:25.756 --> 00:31:27.826 A:middle
and the network bitrate
when choosing the variant.

00:31:28.846 --> 00:31:31.846 A:middle
AVFoundation uses the
AVPlayerLayer size on the screen

00:31:31.846 --> 00:31:32.906 A:middle
to evaluate the dimensions.

00:31:33.366 --> 00:31:36.826 A:middle
So set up your AVPlayerLayer at
the correct size and connect it

00:31:36.826 --> 00:31:38.386 A:middle
to the AVPlayer as
early as you can.

00:31:38.966 --> 00:31:40.436 A:middle
It can be hidden behind other UI

00:31:40.526 --> 00:31:41.876 A:middle
if you're not ready
to show video yet.

00:31:42.636 --> 00:31:45.436 A:middle
On a retina iOS device,
it's currently necessary

00:31:45.436 --> 00:31:47.076 A:middle
to set contentsScale manually.

00:31:47.436 --> 00:31:51.866 A:middle
As for bitrate, well
AVFoundation is in a bit

00:31:51.866 --> 00:31:53.556 A:middle
of a chicken and egg
situation when it comes

00:31:54.006 --> 00:31:55.426 A:middle
to playback first beginning.

00:31:56.066 --> 00:31:57.336 A:middle
It has to choose some variant,

00:31:57.876 --> 00:31:59.976 A:middle
but it does not know what
bitrate it's going to get.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:00.926 --> 00:32:02.636 A:middle
Once it's begun downloading
segments,

00:32:02.716 --> 00:32:04.846 A:middle
it can use the statistics
from those downloads

00:32:04.846 --> 00:32:06.066 A:middle
to adjust the choice of variant.

00:32:06.586 --> 00:32:07.816 A:middle
But for that first variant,

00:32:08.056 --> 00:32:09.536 A:middle
it hasn't gathered
any statistics yet.

00:32:10.416 --> 00:32:12.676 A:middle
So AVFoundation's
base algorithm is

00:32:12.676 --> 00:32:15.676 A:middle
to pick the first applicable
variant in the master playlist.

00:32:16.056 --> 00:32:18.286 A:middle
If that's a low bitrate
option, the user will start

00:32:18.286 --> 00:32:19.346 A:middle
out seeing something blurry,

00:32:19.746 --> 00:32:22.056 A:middle
but AVFoundation will soon
decide what the actual network

00:32:22.056 --> 00:32:24.126 A:middle
bitrate is and switch up
to the appropriate variant.

00:32:24.546 --> 00:32:27.706 A:middle
Well, the question is, what
if you would like to try

00:32:27.706 --> 00:32:29.426 A:middle
to improve that initial choice?

00:32:29.966 --> 00:32:33.426 A:middle
Well, remember, there is a
tradeoff you have to make

00:32:33.426 --> 00:32:35.586 A:middle
between initial quality
and startup time.

00:32:36.216 --> 00:32:39.246 A:middle
A higher bitrate first segment
takes longer to download.

00:32:39.616 --> 00:32:41.186 A:middle
And that means it will
take longer to start.

00:32:41.706 --> 00:32:43.906 A:middle
You might decide that
it's best to start

00:32:44.076 --> 00:32:47.166 A:middle
with a lower bitrate variant
in order to start faster.

00:32:47.876 --> 00:32:49.866 A:middle
Well one way to make the
tradeoff is to figure

00:32:49.866 --> 00:32:52.486 A:middle
out a minimum acceptable
quality level you'd like to see

00:32:52.736 --> 00:32:55.236 A:middle
on a particular size of
screen and start there.

00:32:55.886 --> 00:32:58.356 A:middle
Then AVFoundation will
switch to a higher quality

00:32:58.646 --> 00:33:01.196 A:middle
after playback begins
as the network allows.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.646 --> 00:33:01.196 A:middle
after playback begins
as the network allows.

00:33:01.496 --> 00:33:04.906 A:middle
And maybe you know one thing
that AVFoundation doesn't.

00:33:05.406 --> 00:33:07.966 A:middle
Maybe your app just played a
different piece of content.

00:33:08.546 --> 00:33:10.926 A:middle
And maybe you can use
that playback's access log

00:33:11.286 --> 00:33:13.126 A:middle
to make a better guess
about the bitrate

00:33:13.126 --> 00:33:16.416 A:middle
that the next playback
station is going to get.

00:33:16.636 --> 00:33:18.866 A:middle
So let's suppose that you come
up with a hero stick based

00:33:18.866 --> 00:33:21.256 A:middle
on startup quality and
recent bitrate statistics.

00:33:21.656 --> 00:33:23.756 A:middle
And you decide on
a way to choose

00:33:23.806 --> 00:33:25.466 A:middle
which variant you
want to start with.

00:33:25.716 --> 00:33:28.296 A:middle
Well, how do we plug that
choice into AVFoundation?

00:33:28.546 --> 00:33:30.726 A:middle
There are two techniques
that have been used.

00:33:31.186 --> 00:33:32.036 A:middle
Here's the first technique.

00:33:32.646 --> 00:33:35.106 A:middle
On the server, you have
to sort your variance

00:33:35.266 --> 00:33:36.496 A:middle
from highest to lowest.

00:33:37.086 --> 00:33:39.146 A:middle
Like that.

00:33:39.146 --> 00:33:42.066 A:middle
And then in your app, you need

00:33:42.066 --> 00:33:45.036 A:middle
to set the player items
preferredPeakBitRate

00:33:46.156 --> 00:33:47.006 A:middle
to you bitrate guess.

00:33:47.956 --> 00:33:50.536 A:middle
This will eliminate the
higher bitrate variance

00:33:50.536 --> 00:33:51.836 A:middle
from initial selection.

00:33:52.506 --> 00:33:54.756 A:middle
Shortly after playback
starts, you should reset

00:33:54.756 --> 00:33:58.306 A:middle
that control back to zero, which
will allow AVFoundation to move

00:33:58.306 --> 00:34:00.626 A:middle
up to a higher bitrate variance
if the network improves.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.306 --> 00:34:00.626 A:middle
up to a higher bitrate variance
if the network improves.

00:34:02.686 --> 00:34:04.236 A:middle
The second technique is

00:34:04.236 --> 00:34:06.556 A:middle
to dynamically rewrite the
master playlist in your app

00:34:07.046 --> 00:34:09.016 A:middle
and move your preferred
choice to the top of the list.

00:34:10.235 --> 00:34:14.585 A:middle
To do this, use a custom URL
scheme for the AVURLAsset

00:34:15.716 --> 00:34:19.335 A:middle
and implement the AV asset
resource loader delegate

00:34:19.335 --> 00:34:23.206 A:middle
protocol in which you can
supply that rewritten playlist

00:34:23.206 --> 00:34:25.866 A:middle
in response to the load request
for that custom URL scheme.

00:34:26.936 --> 00:34:29.786 A:middle
I want to remind you to
profile your code too.

00:34:30.156 --> 00:34:32.636 A:middle
Look for any delays before
you call AVFoundation.

00:34:33.126 --> 00:34:36.616 A:middle
In particular, you do not need
to wait for likelyToKeepUp

00:34:36.775 --> 00:34:39.085 A:middle
to become true before
you set the player rate.

00:34:39.616 --> 00:34:43.076 A:middle
You don't need to now, and in
fact, you never have for HLS.

00:34:44.246 --> 00:34:46.746 A:middle
Make sure that you release
AVPlayers and AVPlayerItems

00:34:46.746 --> 00:34:47.996 A:middle
from old playback sessions

00:34:48.386 --> 00:34:50.646 A:middle
so that they do not waste
bandwidth in the background.

00:34:51.005 --> 00:34:53.676 A:middle
You can use the Allocations
Instrument in Instruments

00:34:53.946 --> 00:34:55.576 A:middle
to check the lifespans
of AVPlayer

00:34:55.576 --> 00:34:57.256 A:middle
and AVPlayerItem objects.

00:34:57.866 --> 00:34:59.136 A:middle
And if you have an application

00:34:59.136 --> 00:35:00.336 A:middle
that does other network
activity,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.136 --> 00:35:00.336 A:middle
that does other network
activity,

00:35:00.636 --> 00:35:02.996 A:middle
consider whether you should
suspend it during network

00:35:02.996 --> 00:35:05.476 A:middle
playback so that the user
can take full advantage

00:35:05.626 --> 00:35:07.496 A:middle
of available bandwidth
for playback.

00:35:09.316 --> 00:35:14.226 A:middle
All right, in conclusion,
automaticallyWaits

00:35:14.336 --> 00:35:17.396 A:middle
to minimize stalling,
Autoplay, Autowait.

00:35:17.756 --> 00:35:20.966 A:middle
It's set to true by default
if your app is linked on

00:35:21.076 --> 00:35:22.376 A:middle
or after this year's SDKs.

00:35:22.376 --> 00:35:25.386 A:middle
And it provides uniform
buffering rules

00:35:25.666 --> 00:35:28.346 A:middle
for progressive download
and HLS playback.

00:35:28.936 --> 00:35:32.756 A:middle
We've introduced a new
API called AVPlayerLooper

00:35:33.206 --> 00:35:34.996 A:middle
to simplify using
the treadmill patent

00:35:35.246 --> 00:35:36.966 A:middle
to loop playback
of a single item.

00:35:38.816 --> 00:35:42.486 A:middle
Changing the set of enable
tracks during playback no longer

00:35:42.486 --> 00:35:44.076 A:middle
always causes a brief pause.

00:35:44.956 --> 00:35:47.306 A:middle
And we've looked at
the AVFoundation APIs

00:35:47.386 --> 00:35:50.126 A:middle
that you can use to prepare
your app for wide color video.

00:35:51.416 --> 00:35:54.566 A:middle
Finally, we talked about
optimizing playback startup

00:35:54.566 --> 00:35:57.036 A:middle
for local files and for HLS.

00:35:57.186 --> 00:36:00.346 A:middle
In short, avoid accidentally
asking for work you don't need.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:57.186 --> 00:36:00.346 A:middle
In short, avoid accidentally
asking for work you don't need.

00:36:00.746 --> 00:36:04.476 A:middle
And for the work you do need,
see if you can do it earlier.

00:36:04.696 --> 00:36:07.466 A:middle
We'll have more information at
this URL about this session,

00:36:07.756 --> 00:36:09.336 A:middle
including sample code
that we've shown.

00:36:10.706 --> 00:36:13.186 A:middle
We have some related sessions
that you might like to catch

00:36:13.186 --> 00:36:16.066 A:middle
up to see in person
or catch up online.

00:36:16.396 --> 00:36:18.536 A:middle
The bottom one is an
on-demand only one

00:36:18.536 --> 00:36:19.486 A:middle
that you can watch in the app.

00:36:20.186 --> 00:36:21.046 A:middle
Thank you for attention.

00:36:21.046 --> 00:36:21.626 A:middle
It's been a pleasure.

00:36:21.626 --> 00:36:23.926 A:middle
I hope you have a great week.

