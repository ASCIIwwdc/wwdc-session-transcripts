WEBVTT

00:00:07.516 --> 00:00:17.500 A:middle
[ Music ]

00:00:21.556 --> 00:00:22.146 A:middle
&gt;&gt; Good morning.

00:00:25.746 --> 00:00:27.556 A:middle
My name is Steve Breen.

00:00:27.756 --> 00:00:31.026 A:middle
&gt;&gt; And my name is Peter Hajas,
and we're both engineers

00:00:31.026 --> 00:00:32.836 A:middle
on the UIKit Frameworks Team.

00:00:34.016 --> 00:00:35.426 A:middle
&gt;&gt; We're really excited to share

00:00:35.426 --> 00:00:37.266 A:middle
with what we're working
on in CollectionView.

00:00:37.926 --> 00:00:39.846 A:middle
So let's get right into it.

00:00:41.176 --> 00:00:43.446 A:middle
We've got three big topics
to talk about this morning.

00:00:43.876 --> 00:00:47.356 A:middle
Our first topic is going
to be smooth scrolling.

00:00:48.396 --> 00:00:50.736 A:middle
Now, every iOS app expects

00:00:50.736 --> 00:00:52.536 A:middle
to have great scrolling
performance,

00:00:52.896 --> 00:00:55.026 A:middle
and we got some great
additions to CollectionView

00:00:55.026 --> 00:00:58.536 A:middle
to help your apps scroll better
than ever, and the best part

00:00:58.536 --> 00:01:00.976 A:middle
about this is many of these
additions require little

00:00:58.536 --> 00:01:00.976 A:middle
about this is many of these
additions require little

00:01:01.216 --> 00:01:03.196 A:middle
to no work in your applications.

00:01:03.636 --> 00:01:06.416 A:middle
Next, we're going to talk

00:01:06.416 --> 00:01:09.056 A:middle
about improvements
to self-sizing cells.

00:01:09.636 --> 00:01:12.556 A:middle
Now this API was
introduced in iOS 8,

00:01:12.556 --> 00:01:15.396 A:middle
and we're bringing some great
improvements to it in iOS X

00:01:15.396 --> 00:01:17.256 A:middle
to make it easier to adopt.

00:01:18.266 --> 00:01:22.586 A:middle
And, finally, we're going to
go over interactive reordering.

00:01:23.196 --> 00:01:26.126 A:middle
This API was introduced
last year in iOS 9,

00:01:26.526 --> 00:01:27.866 A:middle
and we've got some
great enhancements

00:01:27.866 --> 00:01:30.236 A:middle
that we're going to
go over for iOS X.

00:01:30.886 --> 00:01:33.156 A:middle
&gt;&gt; Let's start off
with smooth scrolling.

00:01:33.726 --> 00:01:39.326 A:middle
A hallmark of the iOS device
experience is responding

00:01:39.326 --> 00:01:44.226 A:middle
immediately to the user's
touch, and a big part

00:01:44.226 --> 00:01:47.966 A:middle
of this responsive user
experience is making sure

00:01:48.636 --> 00:01:51.366 A:middle
that as I scroll my
finger across the screen,

00:01:51.746 --> 00:01:53.546 A:middle
the objects onscreen move

00:01:53.546 --> 00:01:55.696 A:middle
as if they're moving
in the real world.

00:01:56.486 --> 00:01:59.686 A:middle
This is really important
to keep your users immersed

00:01:59.996 --> 00:02:01.036 A:middle
in their applications.

00:01:59.996 --> 00:02:01.036 A:middle
in their applications.

00:02:01.936 --> 00:02:03.946 A:middle
We're going to talk
through smooth scrolling

00:02:04.136 --> 00:02:07.076 A:middle
and some enhancements we've
made to UI CollectionView

00:02:07.836 --> 00:02:10.866 A:middle
by talking through a demo app.

00:02:10.866 --> 00:02:14.376 A:middle
As you'll see, this application
starts off not scrolling

00:02:14.376 --> 00:02:15.056 A:middle
that great.

00:02:15.056 --> 00:02:17.466 A:middle
We wanted to scroll like
butter, but right now,

00:02:17.466 --> 00:02:20.006 A:middle
it's scrolling a lot more
like chunky peanut butter.

00:02:20.436 --> 00:02:21.476 A:middle
So let's go to the iPad.

00:02:25.516 --> 00:02:26.986 A:middle
I'm going to switch
over to the iPad.

00:02:29.196 --> 00:02:32.786 A:middle
Just to clarify, blue squares
are usually pretty cheap,

00:02:32.816 --> 00:02:34.866 A:middle
but we've intentionally
made these slow.

00:02:35.506 --> 00:02:36.996 A:middle
So imagine they're
more complicated.

00:02:36.996 --> 00:02:39.026 A:middle
For example, maybe they
have two colors in them.

00:02:40.336 --> 00:02:44.416 A:middle
Anyways, we've got this
CollectionView, and we can see

00:02:44.416 --> 00:02:47.346 A:middle
that scrolling already
loaded content is nice

00:02:47.346 --> 00:02:50.096 A:middle
and fast, but check this out.

00:02:50.096 --> 00:02:51.346 A:middle
Steve, watch closely.

00:02:51.946 --> 00:02:53.416 A:middle
When I scroll a little bit more.

00:02:54.586 --> 00:02:55.576 A:middle
&gt;&gt; Ooh, ouch.

00:02:56.016 --> 00:02:59.186 A:middle
One star, do not buy.

00:02:59.406 --> 00:03:00.916 A:middle
&gt;&gt; I wouldn't buy it either.

00:02:59.406 --> 00:03:00.916 A:middle
&gt;&gt; I wouldn't buy it either.

00:03:01.066 --> 00:03:04.266 A:middle
This type of user experience
is something we really want

00:03:04.266 --> 00:03:04.706 A:middle
to avoid.

00:03:05.236 --> 00:03:06.206 A:middle
So what's going on here?

00:03:06.906 --> 00:03:10.236 A:middle
Well, we said before that these
are some really expensive blue

00:03:10.236 --> 00:03:13.896 A:middle
squares to simulate to really
expensive complicated cell

00:03:14.096 --> 00:03:17.576 A:middle
in your app, and that's running
up against CollectionView

00:03:18.266 --> 00:03:21.226 A:middle
and the fact that it loads cells
exactly when they're required.

00:03:21.336 --> 00:03:22.636 A:middle
Let me show you what I mean.

00:03:24.046 --> 00:03:26.316 A:middle
We'll reload our data
here, and I'm going to turn

00:03:26.316 --> 00:03:29.096 A:middle
on a view that's going to show
all the cells that are loaded

00:03:29.096 --> 00:03:29.876 A:middle
in the CollectionView.

00:03:30.906 --> 00:03:33.456 A:middle
So you can see those bottom
cells are just peaking

00:03:33.456 --> 00:03:35.086 A:middle
up beyond the visible bounds.

00:03:35.806 --> 00:03:37.726 A:middle
Now watch what happens
when I scroll.

00:03:39.596 --> 00:03:42.916 A:middle
We're bringing in an
entire row of cells at once.

00:03:43.346 --> 00:03:46.316 A:middle
This is what's leading to that
stuttery scrolling performance.

00:03:47.316 --> 00:03:50.326 A:middle
In performance terminology,
we would say

00:03:50.406 --> 00:03:52.806 A:middle
that the app is dropping frames.

00:03:53.446 --> 00:03:55.616 A:middle
Let's switch back to slides
to hear a little bit more.

00:03:56.016 --> 00:03:57.996 A:middle
&gt;&gt; So what exactly do
we mean when we talk

00:03:57.996 --> 00:03:59.836 A:middle
about dropping frames.

00:04:00.386 --> 00:04:02.206 A:middle
Now, in your applications,

00:04:02.466 --> 00:04:04.836 A:middle
the users expect a smooth
scrolling performance,

00:04:04.836 --> 00:04:07.606 A:middle
which means your app wants
to hit that magical number

00:04:07.876 --> 00:04:09.376 A:middle
of 60 frames per second.

00:04:10.546 --> 00:04:11.586 A:middle
Now if we do the math,

00:04:11.736 --> 00:04:15.026 A:middle
that means that for every time
we refresh the display we need

00:04:15.026 --> 00:04:17.466 A:middle
to hit that window
in 16 milliseconds.

00:04:18.495 --> 00:04:20.406 A:middle
OK. So let's look
at a couple frames.

00:04:20.406 --> 00:04:23.756 A:middle
Here we have a diagram that
shows three distinct frames.

00:04:24.276 --> 00:04:29.506 A:middle
In our first frame, we got
very little work to do.

00:04:29.836 --> 00:04:33.406 A:middle
Now as Peter mentioned before,
we're moving existing content

00:04:33.406 --> 00:04:34.536 A:middle
up and down the display.

00:04:34.956 --> 00:04:37.126 A:middle
It's a highly optimized
situation on iOS.

00:04:37.126 --> 00:04:38.416 A:middle
So it's superfast.

00:04:38.416 --> 00:04:41.656 A:middle
Not much work to hit, and
we've got this great five-star

00:04:41.656 --> 00:04:42.646 A:middle
scrolling performance.

00:04:43.086 --> 00:04:43.846 A:middle
That's a good frame.

00:04:45.836 --> 00:04:48.996 A:middle
However, in the demo, it
wasn't always so great.

00:04:50.436 --> 00:04:52.236 A:middle
Occasionally, we'd
have this situation

00:04:52.346 --> 00:04:54.136 A:middle
where we have a lot
of work to do.

00:04:54.356 --> 00:04:56.786 A:middle
Not only do we fill
up our current frame,

00:04:57.136 --> 00:04:58.906 A:middle
we went into the next frame.

00:05:00.456 --> 00:05:02.386 A:middle
This is our ad frame.

00:05:02.386 --> 00:05:04.166 A:middle
We drop a frame, one star.

00:05:04.166 --> 00:05:08.266 A:middle
Let's look at this in a
little bit different light.

00:05:08.856 --> 00:05:12.626 A:middle
Now on this graph, we can see
we've got two distinct regions.

00:05:13.196 --> 00:05:14.666 A:middle
We have the region on the top,

00:05:14.666 --> 00:05:16.386 A:middle
which we're going to
call the red zone.

00:05:16.386 --> 00:05:19.896 A:middle
This is the area where we miss
a frame, and we're up above

00:05:19.896 --> 00:05:21.956 A:middle
that magical 16 millisecond
line.

00:05:23.236 --> 00:05:25.116 A:middle
Let's check out the labels
that we have on the axes.

00:05:25.756 --> 00:05:29.046 A:middle
So on our y-axis, we're
going to graph the CPU time

00:05:29.046 --> 00:05:31.786 A:middle
on the main thread,
and on the x,

00:05:32.096 --> 00:05:36.186 A:middle
this is the display fresh events
as the scrolling's occurring.

00:05:36.486 --> 00:05:38.136 A:middle
OK. So let's look at a graph.

00:05:39.396 --> 00:05:40.626 A:middle
Alright. So in this graph,

00:05:40.986 --> 00:05:43.066 A:middle
this shows what Peter was
demonstrating a second ago

00:05:43.066 --> 00:05:45.546 A:middle
where we have these visits
up into that red zone

00:05:45.546 --> 00:05:48.246 A:middle
where we're dropping
frames, but most importantly,

00:05:48.246 --> 00:05:49.706 A:middle
look at these quiet times

00:05:49.996 --> 00:05:52.186 A:middle
where the CollectionView's
doing very little work,

00:05:53.066 --> 00:05:54.066 A:middle
but then we have
this other visit

00:05:54.066 --> 00:05:55.046 A:middle
to the red zone at the end.

00:05:55.176 --> 00:05:59.596 A:middle
So what if we could change this
behavior a little bit and smooth

00:05:59.596 --> 00:06:02.546 A:middle
out the amount of work we're
doing as the user's scrolling.

00:05:59.596 --> 00:06:02.546 A:middle
out the amount of work we're
doing as the user's scrolling.

00:06:02.986 --> 00:06:05.166 A:middle
OK, cool. Look at this.

00:06:05.166 --> 00:06:08.776 A:middle
So now instead of these
visits up into that red zone

00:06:09.586 --> 00:06:12.826 A:middle
and those periods of quiescence,
we've got a nice even amount

00:06:12.826 --> 00:06:14.976 A:middle
of work, and we're spreading
the work out across time.

00:06:16.336 --> 00:06:18.136 A:middle
&gt;&gt; To help talk through
how we're going

00:06:18.136 --> 00:06:20.866 A:middle
to flatten these peaks
and bring up this valley

00:06:21.176 --> 00:06:24.876 A:middle
to create this nice, consistent
line of work, I'd like to talk

00:06:24.876 --> 00:06:29.106 A:middle
through the life cycle of a
cell as it existed on iOS 9.

00:06:29.756 --> 00:06:32.516 A:middle
We're going to go through the
whole circle of life of a cell.

00:06:32.956 --> 00:06:33.586 A:middle
It's beautiful.

00:06:34.466 --> 00:06:36.036 A:middle
Let's bring our CollectionView
cells,

00:06:37.116 --> 00:06:39.106 A:middle
and we're scrolling along,
and let's say we need

00:06:39.106 --> 00:06:40.356 A:middle
to bring in a new cell.

00:06:41.706 --> 00:06:43.086 A:middle
We'll take it out
of the reuse queue,

00:06:43.086 --> 00:06:45.246 A:middle
and we'll call prepareForReuse
on it.

00:06:46.246 --> 00:06:49.306 A:middle
This gives the cell an
opportunity to reset itself

00:06:49.506 --> 00:06:53.326 A:middle
to its default state, ready to
receive new data from your app.

00:06:54.246 --> 00:06:58.496 A:middle
Next, we'll continue calling the
rest of cellForItemAtIndexPath.

00:06:59.376 --> 00:07:01.336 A:middle
This is where you should
be doing the majority

00:06:59.376 --> 00:07:01.336 A:middle
This is where you should
be doing the majority

00:07:01.336 --> 00:07:02.886 A:middle
of your work populating
the cell.

00:07:03.356 --> 00:07:05.996 A:middle
You'll access your data
models, set them on the cell,

00:07:06.226 --> 00:07:07.936 A:middle
and return them back
to the system.

00:07:09.006 --> 00:07:11.956 A:middle
Now, right before that
cell's about to go on screen,

00:07:12.246 --> 00:07:14.266 A:middle
we'll call willDisplayCell.

00:07:15.476 --> 00:07:16.946 A:middle
This will give your app a chance

00:07:17.236 --> 00:07:20.906 A:middle
to do any other last-minute
work it needs to do before

00:07:20.906 --> 00:07:22.216 A:middle
that cell goes on screen.

00:07:23.086 --> 00:07:26.456 A:middle
And for any outgoing cells,
we'll call didEndDisplayingCell.

00:07:26.516 --> 00:07:31.636 A:middle
&gt;&gt; OK. So that's the life
cycle of the cell before iOS X.

00:07:32.676 --> 00:07:35.066 A:middle
Now let's check out what
this looks like in iOS X.

00:07:35.886 --> 00:07:37.456 A:middle
So here we have the
same type of layout

00:07:37.456 --> 00:07:38.506 A:middle
that Peter just talked about.

00:07:38.806 --> 00:07:39.626 A:middle
The single column.

00:07:39.626 --> 00:07:41.496 A:middle
It's simple for demonstration
purposes.

00:07:42.426 --> 00:07:44.706 A:middle
So now as the user scrolls up,

00:07:44.776 --> 00:07:47.556 A:middle
notice here that well
before this cell is needed

00:07:47.556 --> 00:07:49.796 A:middle
to be displayed on screen,
we're going to bring it

00:07:49.796 --> 00:07:50.906 A:middle
in from the reuse queue.

00:07:51.036 --> 00:07:54.166 A:middle
And then following that familiar
pattern Peter was talking about,

00:07:54.476 --> 00:07:56.306 A:middle
we're going to send
it a prepareForReuse,

00:07:56.736 --> 00:07:59.646 A:middle
and then construct the rest
of the content in your cell

00:07:59.646 --> 00:08:01.116 A:middle
with cellForItemAtIndexPath.

00:07:59.646 --> 00:08:01.116 A:middle
with cellForItemAtIndexPath.

00:08:01.536 --> 00:08:05.236 A:middle
Now as the user continues to
scroll, here's what's different.

00:08:06.026 --> 00:08:08.016 A:middle
Now we didn't call
willDisplayCell right

00:08:08.016 --> 00:08:09.066 A:middle
when we created this cell.

00:08:09.066 --> 00:08:12.476 A:middle
We have a hesitant, hesitation,
and then right when it displays,

00:08:12.596 --> 00:08:14.426 A:middle
we're going to call
willDisplayCell.

00:08:15.526 --> 00:08:17.696 A:middle
OK. So now the user
continues to scroll.

00:08:18.976 --> 00:08:20.756 A:middle
We're going to fade away
those other cells to focus

00:08:20.756 --> 00:08:23.706 A:middle
on the lifetime of this
cell, and now the cell is

00:08:23.706 --> 00:08:26.226 A:middle
about to exit the visible
bounds from the CollectionView.

00:08:26.666 --> 00:08:29.606 A:middle
So we'll send it the
expected didEndDisplayingCell.

00:08:30.166 --> 00:08:33.285 A:middle
Now what Peter was talking
about iOS 9, at this point,

00:08:33.405 --> 00:08:36.086 A:middle
the cell entered the reuse
queue, and we'd be done with it.

00:08:36.616 --> 00:08:39.126 A:middle
To display the data in
this particular cell again,

00:08:39.446 --> 00:08:41.206 A:middle
we'd have to go through the
beginning of the life cycle

00:08:41.206 --> 00:08:43.905 A:middle
to cell and call
cellForItemAtIndexPath.

00:08:44.686 --> 00:08:46.606 A:middle
But in iOS X, we're
going to hold

00:08:46.606 --> 00:08:48.266 A:middle
onto that cell just
a little bit longer.

00:08:49.086 --> 00:08:50.536 A:middle
So if the user scrolls
up a little bit,

00:08:50.536 --> 00:08:51.576 A:middle
and then says, "Oh,
wait a minute.

00:08:51.576 --> 00:08:53.336 A:middle
That was a picture of
my sister's new kid.

00:08:53.336 --> 00:08:55.676 A:middle
I'm going to scroll back
down," we're going to hang

00:08:55.676 --> 00:08:58.836 A:middle
onto that cell, and send
it a willDisplayCell again.

00:08:59.016 --> 00:09:01.826 A:middle
Now the content will
continue on in the cell.

00:08:59.016 --> 00:09:01.826 A:middle
Now the content will
continue on in the cell.

00:09:02.516 --> 00:09:07.500 A:middle
[ Applause ]

00:09:21.096 --> 00:09:24.446 A:middle
&gt;&gt; So notice as Steve's showing
you here, this also applies

00:09:24.446 --> 00:09:26.006 A:middle
to multicolumn layouts.

00:09:26.786 --> 00:09:29.926 A:middle
We're going to be bringing in
the cells one at a time instead

00:09:29.926 --> 00:09:32.386 A:middle
of all at once to get better
scrolling performance.

00:09:32.386 --> 00:09:33.976 A:middle
&gt;&gt; That's right,
Peter, and notice here,

00:09:33.976 --> 00:09:36.476 A:middle
these cells aren't actually
displayed on screen quite yet.

00:09:36.696 --> 00:09:37.986 A:middle
They're still off the screen.

00:09:38.156 --> 00:09:40.846 A:middle
And now that we sent the
second cell that we DQ'd,

00:09:41.096 --> 00:09:44.706 A:middle
the cellForItemIndexPath,
and scroll up both cells,

00:09:44.796 --> 00:09:47.726 A:middle
now we're going to send
the willDisplayCellMessage

00:09:47.726 --> 00:09:50.226 A:middle
to both right before
they appear on screen.

00:09:51.416 --> 00:09:53.616 A:middle
&gt;&gt; While this may seem
like a subtle change,

00:09:53.756 --> 00:09:55.786 A:middle
it's actually a lot
bigger than that.

00:09:56.176 --> 00:09:59.066 A:middle
By adopting this new
life cycle in iOS X,

00:09:59.416 --> 00:10:01.976 A:middle
we get automatic faster
scrolling performance.

00:09:59.416 --> 00:10:01.976 A:middle
we get automatic faster
scrolling performance.

00:10:02.296 --> 00:10:03.166 A:middle
Let's go back to iPad.

00:10:03.166 --> 00:10:11.656 A:middle
So I'm going to switch back
to the iPad, and here you see

00:10:11.656 --> 00:10:15.076 A:middle
that same CollectionView we
were just looking at in iOS 9.

00:10:15.696 --> 00:10:19.456 A:middle
Remember, scrolling existing
content is nice and fast,

00:10:19.686 --> 00:10:21.186 A:middle
but when we have to
bring in more cells,

00:10:22.436 --> 00:10:23.696 A:middle
that's when things get choppy.

00:10:24.276 --> 00:10:26.196 A:middle
Now, while preparing
this CollectionView,

00:10:26.416 --> 00:10:29.326 A:middle
we also prepared one in the
oven cooking under iOS X.

00:10:29.326 --> 00:10:31.136 A:middle
So I'm going to switch
over to that,

00:10:32.856 --> 00:10:35.746 A:middle
and here we've got the
exact same CollectionView

00:10:35.976 --> 00:10:40.206 A:middle
with those same really expensive
blue squares running on iOS X.

00:10:41.536 --> 00:10:45.496 A:middle
We can see that scrolling
existing content is still nice,

00:10:45.496 --> 00:10:48.506 A:middle
fast, and fluid, but
watch closely, Steve.

00:10:48.696 --> 00:10:48.976 A:middle
&gt;&gt; Alright.

00:10:48.976 --> 00:10:50.546 A:middle
&gt;&gt; When I scroll
a little bit more.

00:10:51.586 --> 00:10:52.766 A:middle
&gt;&gt; Oh, that's great.

00:10:52.766 --> 00:10:53.616 A:middle
Five stars.

00:10:54.176 --> 00:10:54.976 A:middle
&gt;&gt; That's exactly right.

00:10:55.516 --> 00:11:00.766 A:middle
[ Applause ]

00:10:55.516 --> 00:11:00.766 A:middle
[ Applause ]

00:11:01.266 --> 00:11:04.316 A:middle
This is because we're using
this new cell life cycle.

00:11:04.606 --> 00:11:06.356 A:middle
The application hasn't
changed at all.

00:11:06.356 --> 00:11:09.186 A:middle
I'm going to turn on that
same view, which is going

00:11:09.186 --> 00:11:11.556 A:middle
to show you all the cells
that CollectionView's loaded

00:11:11.556 --> 00:11:13.176 A:middle
to help highlight
this difference.

00:11:14.676 --> 00:11:15.866 A:middle
So let me turn that on.

00:11:16.666 --> 00:11:18.456 A:middle
So here you can see
that bottom row

00:11:18.456 --> 00:11:20.386 A:middle
of cells is just peaking above,

00:11:20.436 --> 00:11:22.606 A:middle
but watch what happens
when I scroll faster.

00:11:23.326 --> 00:11:25.716 A:middle
Instead of bringing in a
row of cells at a time,

00:11:26.606 --> 00:11:28.936 A:middle
we're now spreading that
work out during the scroll.

00:11:29.226 --> 00:11:32.276 A:middle
This is what leads to that much
smoother scrolling performance.

00:11:32.276 --> 00:11:33.056 A:middle
Isn't that great?

00:11:38.816 --> 00:11:41.176 A:middle
To learn more about this,
let's go back to slides.

00:11:44.836 --> 00:11:46.066 A:middle
&gt;&gt; So this is pretty great.

00:11:46.586 --> 00:11:48.156 A:middle
So today we're very pleased

00:11:48.156 --> 00:11:51.366 A:middle
to announce UI CollectionView
Cell Pre-Fetching.

00:11:51.816 --> 00:11:54.136 A:middle
Now this is enabled by default

00:11:54.136 --> 00:11:56.096 A:middle
when you compile
your apps on iOS X.

00:11:57.576 --> 00:11:59.766 A:middle
There's no step one.

00:11:59.946 --> 00:12:01.796 A:middle
Now for any reason you need

00:11:59.946 --> 00:12:01.796 A:middle
Now for any reason you need

00:12:01.796 --> 00:12:05.256 A:middle
to use the old life
cycle behavior pre-iOS X,

00:12:05.306 --> 00:12:06.586 A:middle
opting out is easy.

00:12:07.136 --> 00:12:09.546 A:middle
Just set the new property
on UICollectionView

00:12:09.546 --> 00:12:11.926 A:middle
to isPrefetchingEnabled
defaults.

00:12:11.926 --> 00:12:16.246 A:middle
Now we've got some
best practices

00:12:16.246 --> 00:12:17.806 A:middle
for adopting this
new technology.

00:12:19.066 --> 00:12:21.116 A:middle
The first thing we want
to talk about is we want

00:12:21.116 --> 00:12:23.796 A:middle
to do all the heavy lifting
in cellForItemAtIndexPath.

00:12:23.796 --> 00:12:25.966 A:middle
All the, all the content
creation for your cell.

00:12:25.966 --> 00:12:28.886 A:middle
Everything should be centered
in cellForItemAtIndexPath.

00:12:30.746 --> 00:12:33.396 A:middle
Additionally, we want to
make sure we do minimal work

00:12:33.726 --> 00:12:36.516 A:middle
willDisplayCell in
didEndDisplayCell.

00:12:38.336 --> 00:12:40.666 A:middle
And, finally, it's
important to note

00:12:41.296 --> 00:12:44.486 A:middle
that cellForItemaAtIndexPath
may prepare a cell that's never

00:12:44.486 --> 00:12:45.566 A:middle
actually displayed.

00:12:45.696 --> 00:12:48.766 A:middle
The user may scroll away before
the cell has an opportunity

00:12:48.766 --> 00:12:49.606 A:middle
to be displayed.

00:12:51.016 --> 00:12:52.726 A:middle
&gt;&gt; So this is great.

00:12:53.376 --> 00:12:55.076 A:middle
By just recompiling in iOS X

00:12:55.076 --> 00:12:58.246 A:middle
and doing what you're likely
already doing with the majority

00:12:58.246 --> 00:13:00.636 A:middle
of your work in
cellForItemAtIndexPath,

00:12:58.246 --> 00:13:00.636 A:middle
of your work in
cellForItemAtIndexPath,

00:13:01.056 --> 00:13:04.456 A:middle
you automatically get better
scrolling performance for free.

00:13:05.646 --> 00:13:07.656 A:middle
But we wanted to
go a step further.

00:13:08.236 --> 00:13:10.346 A:middle
We understand that there's
a class of application

00:13:10.666 --> 00:13:13.666 A:middle
which has a simple question for
preparing their CollectionViews.

00:13:13.976 --> 00:13:17.276 A:middle
What do I do about my
expensive data models?

00:13:18.406 --> 00:13:19.796 A:middle
The fact of the matter is

00:13:19.986 --> 00:13:23.436 A:middle
that many CollectionView cells
require expensive data model

00:13:23.436 --> 00:13:25.156 A:middle
access to create.

00:13:25.606 --> 00:13:28.526 A:middle
I'm talking about things
like decoding images,

00:13:28.876 --> 00:13:30.916 A:middle
talking to your database,
or loading things

00:13:30.916 --> 00:13:32.196 A:middle
out of your core data store.

00:13:32.336 --> 00:13:35.536 A:middle
And we understand that for
this class of application,

00:13:36.116 --> 00:13:37.156 A:middle
we don't want to show things

00:13:37.156 --> 00:13:40.196 A:middle
like template cells while we do
an asynchronous network request.

00:13:41.376 --> 00:13:44.346 A:middle
To help solve this problem,
we're introducing new API

00:13:44.536 --> 00:13:48.946 A:middle
in iOS X to help inform how
your data model loads content.

00:13:50.136 --> 00:13:51.466 A:middle
Since its introduction,

00:13:51.606 --> 00:13:55.416 A:middle
UI CollectionView has always
had two companion objects:

00:13:56.056 --> 00:13:58.036 A:middle
The data source and
the delegate.

00:13:58.476 --> 00:14:02.286 A:middle
And new in iOS X we have
this third companion object.

00:13:58.476 --> 00:14:02.286 A:middle
And new in iOS X we have
this third companion object.

00:14:02.596 --> 00:14:05.796 A:middle
It's optional, and it's
called the prefetchDataSource.

00:14:06.716 --> 00:14:08.696 A:middle
There's just one
required method.

00:14:08.976 --> 00:14:10.696 A:middle
It's really easy to implement.

00:14:11.476 --> 00:14:14.546 A:middle
ColletionView prefetchItemsAt
indexPaths.

00:14:15.676 --> 00:14:18.456 A:middle
This will be called on
your prefetch data source

00:14:18.756 --> 00:14:21.256 A:middle
when it's time for
you to preload content

00:14:21.366 --> 00:14:22.936 A:middle
from your asynchronous model.

00:14:23.866 --> 00:14:28.036 A:middle
That argument index paths is
an ordered array of index paths

00:14:28.646 --> 00:14:31.676 A:middle
so earlier items in that
array are coming up sooner.

00:14:32.386 --> 00:14:35.856 A:middle
You can use this to influence
your asynchronous model reads.

00:14:36.756 --> 00:14:39.216 A:middle
There's a second optional
method in this protocol.

00:14:39.676 --> 00:14:42.706 A:middle
CollectionView
cancelPrefetcingForItemsAt

00:14:42.706 --> 00:14:43.536 A:middle
indexPaths.

00:14:45.356 --> 00:14:48.216 A:middle
This will be called on
your prefetch data source

00:14:49.366 --> 00:14:52.686 A:middle
when we determine that we're no
longer scrolling towards a set

00:14:52.896 --> 00:14:53.656 A:middle
of index paths.

00:14:54.586 --> 00:14:56.386 A:middle
You can use this to cancel

00:14:56.806 --> 00:15:00.436 A:middle
or lower the priority
of any pending loads.

00:14:56.806 --> 00:15:00.436 A:middle
or lower the priority
of any pending loads.

00:15:00.436 --> 00:15:03.346 A:middle
Now there's something really
important about this API

00:15:03.346 --> 00:15:04.776 A:middle
that I want to highlight.

00:15:05.696 --> 00:15:07.816 A:middle
This is not a replacement
for the data model

00:15:07.816 --> 00:15:08.866 A:middle
that you've already written.

00:15:09.396 --> 00:15:13.646 A:middle
Instead, it works alongside your
existing asynchronous solution

00:15:13.646 --> 00:15:16.386 A:middle
that you've built for
loading data in your app.

00:15:17.766 --> 00:15:21.376 A:middle
What you'll do is use this as
an additional hint for when

00:15:21.376 --> 00:15:23.146 A:middle
to load content in
your CollectionView.

00:15:26.036 --> 00:15:28.466 A:middle
&gt;&gt; So let's tie all this
together with a demo

00:15:28.466 --> 00:15:31.606 A:middle
that shows all of the concepts
we've talked about so far,

00:15:31.696 --> 00:15:36.176 A:middle
and we're going to introduce
a little science, too.

00:15:36.396 --> 00:15:36.996 A:middle
&gt;&gt; Check this out.

00:15:36.996 --> 00:15:38.686 A:middle
Steve's about to
do some real magic.

00:15:39.496 --> 00:15:40.256 A:middle
&gt;&gt; Science, man.

00:15:44.056 --> 00:15:46.646 A:middle
Alright. We're going to
switch back to our demo app,

00:15:46.646 --> 00:15:47.546 A:middle
which we showed before.

00:15:48.046 --> 00:15:53.036 A:middle
OK. So here's the demo app
we've been looking at so far,

00:15:53.036 --> 00:15:55.326 A:middle
but we've hidden this really
great feature we call the

00:15:55.326 --> 00:15:56.246 A:middle
science panel.

00:15:56.866 --> 00:15:58.456 A:middle
Alright, so I'm going
to turn that on now.

00:15:59.436 --> 00:16:02.506 A:middle
OK. So we have these two
distinct regions, right.

00:15:59.436 --> 00:16:02.506 A:middle
OK. So we have these two
distinct regions, right.

00:16:02.506 --> 00:16:03.516 A:middle
We've got that red zone.

00:16:03.516 --> 00:16:05.406 A:middle
That's the one star bad
zone, and then we've got

00:16:05.406 --> 00:16:07.316 A:middle
that nice fat green
zone at the bottom

00:16:07.576 --> 00:16:10.436 A:middle
where we get the super
smooth scrolling performance.

00:16:11.396 --> 00:16:13.226 A:middle
So what I'm going to do
now is I'm going to run

00:16:13.226 --> 00:16:17.466 A:middle
through with the iOS 9 version
of the app, and I'm going

00:16:17.466 --> 00:16:20.466 A:middle
to play back a scrolling
session that I recorded earlier

00:16:20.466 --> 00:16:22.936 A:middle
to show you what this looks
like and do the science.

00:16:24.126 --> 00:16:25.116 A:middle
OK. So here we go.

00:16:26.196 --> 00:16:28.176 A:middle
Scrolling along,
doing our science.

00:16:29.586 --> 00:16:30.106 A:middle
Chop, chop.

00:16:30.106 --> 00:16:32.456 A:middle
OK. What do we have here?

00:16:33.446 --> 00:16:34.696 A:middle
So check out this graph.

00:16:35.166 --> 00:16:37.256 A:middle
We got eight visits
up into that red zone.

00:16:37.716 --> 00:16:38.836 A:middle
Eight dropped frames.

00:16:40.076 --> 00:16:42.526 A:middle
But also we can see that
we've got these long periods

00:16:42.526 --> 00:16:44.176 A:middle
of quiescence like we
talked about earlier.

00:16:44.846 --> 00:16:47.136 A:middle
So the area on the graph
is this big spiky thing,

00:16:47.136 --> 00:16:48.916 A:middle
and then going back
down to the valley.

00:16:49.456 --> 00:16:50.986 A:middle
Let's see what this
looks like in iOS X.

00:16:51.396 --> 00:16:55.656 A:middle
OK. I'm going to switch
back to that iOS X mode

00:16:55.656 --> 00:16:57.896 A:middle
that Peter was talking about
earlier, and now I'm going

00:16:57.896 --> 00:17:01.496 A:middle
to playback that same scrolling
session with [inaudible].

00:16:57.896 --> 00:17:01.496 A:middle
to playback that same scrolling
session with [inaudible].

00:17:01.596 --> 00:17:02.186 A:middle
Check it out, Peter.

00:17:02.186 --> 00:17:03.666 A:middle
&gt;&gt; It's a lot smoother, Steve.

00:17:03.666 --> 00:17:05.026 A:middle
&gt;&gt; Yeah, that definitely
looks better.

00:17:05.606 --> 00:17:06.626 A:middle
See what we get.

00:17:07.116 --> 00:17:08.185 A:middle
Hey, look at that.

00:17:08.626 --> 00:17:09.776 A:middle
No missed frames.

00:17:13.205 --> 00:17:13.646 A:middle
Pretty great.

00:17:16.106 --> 00:17:18.016 A:middle
Now check out what we've
got under the curve

00:17:18.016 --> 00:17:19.386 A:middle
on this particular graph.

00:17:19.866 --> 00:17:22.646 A:middle
Instead of those peaks way up in
the air and the quiet periods,

00:17:22.945 --> 00:17:24.406 A:middle
we've blended those together,

00:17:24.406 --> 00:17:26.276 A:middle
and now we have this
smooth amount of work

00:17:26.576 --> 00:17:29.276 A:middle
that makes your app much more
responsive on the main thread.

00:17:29.986 --> 00:17:32.286 A:middle
OK. You ready for this, Peter?

00:17:32.766 --> 00:17:33.456 A:middle
&gt;&gt; I'm set.

00:17:33.456 --> 00:17:34.256 A:middle
&gt;&gt; Let's do it.

00:17:35.216 --> 00:17:38.136 A:middle
OK. So now we're going to
look at the iOS X version,

00:17:38.136 --> 00:17:40.046 A:middle
but we're going to have
the API, pre-fetch API's

00:17:40.046 --> 00:17:41.876 A:middle
that Peter talked about earlier.

00:17:41.876 --> 00:17:43.806 A:middle
We're going to adopt
those in this application.

00:17:44.056 --> 00:17:46.396 A:middle
Alright. So I'm all
set in the demo app.

00:17:46.596 --> 00:17:48.596 A:middle
I'm going to play back that
same scrolling session.

00:17:49.616 --> 00:17:50.816 A:middle
Whoa, Peter, look at that.

00:17:50.816 --> 00:17:51.956 A:middle
&gt;&gt; Now that's butter, Steve.

00:17:52.046 --> 00:17:52.816 A:middle
&gt;&gt; That's looking pretty good.

00:17:53.806 --> 00:17:54.476 A:middle
Five stars.

00:17:54.506 --> 00:17:56.976 A:middle
And the science agrees.

00:17:57.516 --> 00:18:03.586 A:middle
[ Applause ]

00:17:57.516 --> 00:18:03.586 A:middle
[ Applause ]

00:18:04.086 --> 00:18:06.716 A:middle
OK. So, but, Peter, something's
different here, right.

00:18:06.716 --> 00:18:09.906 A:middle
The area on the curve between
this main queue activity

00:18:10.206 --> 00:18:11.776 A:middle
and the prior version
don't match.

00:18:11.776 --> 00:18:12.596 A:middle
This is a lot lower.

00:18:12.596 --> 00:18:13.376 A:middle
What's going on here?

00:18:14.066 --> 00:18:17.176 A:middle
&gt;&gt; So if we're adopting the
pre-fetch API correctly,

00:18:17.486 --> 00:18:19.516 A:middle
we're probably moving
that data model read

00:18:19.676 --> 00:18:22.306 A:middle
onto a background queue
to free up the main queue.

00:18:23.256 --> 00:18:24.106 A:middle
&gt;&gt; That's exactly right.

00:18:24.986 --> 00:18:25.796 A:middle
That's what's going on.

00:18:25.796 --> 00:18:28.136 A:middle
So now we've moved all that
work onto a background queue,

00:18:28.276 --> 00:18:30.906 A:middle
and we no longer have to
clutter up the main thread.

00:18:31.426 --> 00:18:32.726 A:middle
Let's switch back the slides.

00:18:39.696 --> 00:18:41.486 A:middle
So next I'd like to
talk a little bit

00:18:41.486 --> 00:18:45.106 A:middle
about some pre-fetching API tips
to make your apps adopt this API

00:18:45.106 --> 00:18:47.046 A:middle
in the best possible way.

00:18:48.176 --> 00:18:51.066 A:middle
The first, when you
get the pre-fetch call,

00:18:51.186 --> 00:18:52.546 A:middle
you want to make sure
you do all the work

00:18:52.546 --> 00:18:54.116 A:middle
on the background
[inaudible] right away.

00:18:54.276 --> 00:18:57.026 A:middle
Now we've got two great
technologies for this:

00:18:57.346 --> 00:18:59.966 A:middle
GCD and NSOperationQueue.

00:19:00.466 --> 00:19:05.196 A:middle
Now it's also important
to remember

00:19:05.196 --> 00:19:07.666 A:middle
that pre-fetch is an
adaptive technology.

00:19:07.666 --> 00:19:09.656 A:middle
Now what do I mean by
adaptive technology?

00:19:10.276 --> 00:19:12.876 A:middle
Well, remember when we talked
about those quiet periods

00:19:12.876 --> 00:19:14.706 A:middle
and how pre-fetch takes
advantage of those

00:19:14.966 --> 00:19:16.066 A:middle
by doing additional work.

00:19:17.316 --> 00:19:19.136 A:middle
There are times in
an application

00:19:19.396 --> 00:19:21.256 A:middle
where the user's
scrolling so fast

00:19:21.296 --> 00:19:22.696 A:middle
that there's no quiet times.

00:19:23.216 --> 00:19:24.526 A:middle
During these times when we have

00:19:24.526 --> 00:19:25.916 A:middle
to update the display
very often,

00:19:25.986 --> 00:19:29.296 A:middle
we will not do pre-fetching.

00:19:30.796 --> 00:19:34.456 A:middle
[Inaudible] And, finally,
use the cancelPrefetchingAPI

00:19:34.456 --> 00:19:36.906 A:middle
to adapt to your
user's shifting focus.

00:19:37.046 --> 00:19:39.196 A:middle
Now it's possible that
the user is moving

00:19:39.196 --> 00:19:41.216 A:middle
up in their CollectionView,
and they're scrolling along

00:19:41.216 --> 00:19:43.016 A:middle
with the content, but then
they change their mind

00:19:43.016 --> 00:19:44.066 A:middle
and move in another direction.

00:19:44.676 --> 00:19:47.216 A:middle
We will notify you of this
event with a cancel message

00:19:47.536 --> 00:19:50.496 A:middle
so you can deprioritize
those prior ones and focus

00:19:50.496 --> 00:19:54.636 A:middle
on the new content that
the views are scrolling to.

00:19:54.866 --> 00:19:57.126 A:middle
&gt;&gt; So this is really
great for CollectionView.

00:19:57.626 --> 00:20:01.026 A:middle
By doing no work at all, you get
better scrolling performance,

00:19:57.626 --> 00:20:01.026 A:middle
By doing no work at all, you get
better scrolling performance,

00:20:01.266 --> 00:20:03.136 A:middle
and by doing just a
little bit of work

00:20:03.436 --> 00:20:05.486 A:middle
and using the classes
you've already written,

00:20:05.696 --> 00:20:07.646 A:middle
you get even better
scrolling performance.

00:20:08.166 --> 00:20:10.546 A:middle
And if you're using
UITableView, don't worry.

00:20:10.586 --> 00:20:11.556 A:middle
You're not chopped liver.

00:20:11.936 --> 00:20:14.676 A:middle
We've brought the exact
same API to TableView, too.

00:20:15.516 --> 00:20:21.646 A:middle
[ Applause ]

00:20:22.146 --> 00:20:26.206 A:middle
It's got a very similar optional
pre-fetch data source companion

00:20:26.206 --> 00:20:30.456 A:middle
object with a similar
required method, just one.

00:20:31.336 --> 00:20:34.216 A:middle
TableView prefetchRowsAt
indexPaths.

00:20:34.776 --> 00:20:39.226 A:middle
Again, index paths is an array
ordered by their proximity

00:20:39.226 --> 00:20:40.986 A:middle
to the table's visible area.

00:20:41.416 --> 00:20:43.926 A:middle
So earlier index paths
are coming up sooner.

00:20:44.786 --> 00:20:46.296 A:middle
Just like with the
CollectionView API,

00:20:46.296 --> 00:20:50.656 A:middle
you can use this to inform your
asynchronous data model reads.

00:20:51.246 --> 00:20:54.776 A:middle
And it's got that same second
optional delegate method.

00:20:55.596 --> 00:20:58.216 A:middle
TableView
cancelPrefetchingForRowsAt

00:20:58.216 --> 00:20:58.886 A:middle
indexPaths.

00:20:59.006 --> 00:21:02.896 A:middle
As Steve just mentioned to
you earlier, you can use this

00:20:59.006 --> 00:21:02.896 A:middle
As Steve just mentioned to
you earlier, you can use this

00:21:03.136 --> 00:21:07.646 A:middle
to cancel or deprioritize
any pending data model loads.

00:21:08.516 --> 00:21:10.256 A:middle
And this is what's really great.

00:21:10.716 --> 00:21:12.626 A:middle
Just like with the
CollectionView API,

00:21:13.136 --> 00:21:16.116 A:middle
this works alongside your
existing asynchronous

00:21:16.116 --> 00:21:16.976 A:middle
model solution.

00:21:17.426 --> 00:21:18.836 A:middle
You don't have to
throw anything away.

00:21:19.216 --> 00:21:22.776 A:middle
Instead, use this to inform the
loads that you're already doing.

00:21:23.376 --> 00:21:25.976 A:middle
So that's it for cell
pre-fetching in iOS X.

00:21:26.516 --> 00:21:32.016 A:middle
[ Applause ]

00:21:32.516 --> 00:21:34.626 A:middle
&gt;&gt; So we're really excited about
bringing this technology, guys.

00:21:34.626 --> 00:21:36.356 A:middle
I mean, we can't wait
to see the actual build

00:21:36.356 --> 00:21:37.876 A:middle
with the smoother
scrolling experience.

00:21:37.876 --> 00:21:41.896 A:middle
So next up, we're going
to talk a little bit

00:21:41.896 --> 00:21:45.286 A:middle
about improvements we've made
this year to self-sizing cells.

00:21:45.996 --> 00:21:47.946 A:middle
This API was introduced in iOS 8

00:21:47.946 --> 00:21:50.046 A:middle
and we're bringing some
additional enhancements this

00:21:50.046 --> 00:21:52.616 A:middle
year to make it easier
to adopt in your apps.

00:21:53.546 --> 00:21:55.496 A:middle
Now, before we get
into this, I want to go

00:21:55.496 --> 00:22:00.966 A:middle
over the existing API,
chat a little bit about it.

00:21:55.496 --> 00:22:00.966 A:middle
over the existing API,
chat a little bit about it.

00:22:01.206 --> 00:22:04.246 A:middle
So we shift a concrete
layout class

00:22:04.246 --> 00:22:07.256 A:middle
in CollectionView called
UICollectionViewFlowLayout,

00:22:07.256 --> 00:22:08.976 A:middle
and we have full support

00:22:08.976 --> 00:22:10.946 A:middle
for self-sizing cells
with this class.

00:22:11.996 --> 00:22:15.366 A:middle
To enable this, we just need
to set estimated item size

00:22:15.366 --> 00:22:18.806 A:middle
to some non-zero CG size,
and this tells Collection

00:22:18.806 --> 00:22:21.886 A:middle
that you want to, you want to
calculate the layout dynamically

00:22:21.946 --> 00:22:23.416 A:middle
as content is displayed.

00:22:23.416 --> 00:22:27.876 A:middle
Now as far as getting the
actual sizes of your cells,

00:22:27.876 --> 00:22:30.026 A:middle
there's three different
methods for doing this.

00:22:30.966 --> 00:22:33.136 A:middle
The first method is
using auto layout.

00:22:33.136 --> 00:22:37.346 A:middle
If you can fully constrain the
content view of your hierarchy

00:22:37.346 --> 00:22:39.376 A:middle
to the content view of
the CollectionView cell,

00:22:39.746 --> 00:22:41.836 A:middle
we'll ask the auto
layout system how large

00:22:41.836 --> 00:22:44.226 A:middle
that cell should be
and use that value.

00:22:44.336 --> 00:22:47.356 A:middle
Now if you don't
use auto layout,

00:22:47.356 --> 00:22:51.816 A:middle
or you need more manual control,
you can override sizeThatFits.

00:22:52.326 --> 00:22:55.646 A:middle
And, finally, for
the ultimate control,

00:22:56.166 --> 00:22:58.296 A:middle
you can override
preferredLayoutAttributes

00:22:58.516 --> 00:23:01.566 A:middle
FittingAttributes, and provide
not only the size information

00:22:58.516 --> 00:23:01.566 A:middle
FittingAttributes, and provide
not only the size information

00:23:01.796 --> 00:23:03.206 A:middle
but also you can
tweak the attributes

00:23:03.206 --> 00:23:04.826 A:middle
like alpha and transform.

00:23:06.216 --> 00:23:08.836 A:middle
&gt;&gt; So specifying the
cell size using one

00:23:08.836 --> 00:23:11.326 A:middle
of these three mechanisms,
it's pretty easy.

00:23:11.806 --> 00:23:14.816 A:middle
Most apps will use auto layout,
but for those that don't,

00:23:14.816 --> 00:23:16.746 A:middle
they can take on
more manual control

00:23:16.976 --> 00:23:18.476 A:middle
with the second two
mechanisms there.

00:23:19.266 --> 00:23:22.186 A:middle
But we found that
for types of layouts,

00:23:22.576 --> 00:23:24.956 A:middle
picking a good estimated
item size turns

00:23:24.956 --> 00:23:26.406 A:middle
out to be really challenging

00:23:27.026 --> 00:23:29.056 A:middle
because sometimes it's
just hard to guess.

00:23:30.006 --> 00:23:32.086 A:middle
I mean, sometimes
what do you use?

00:23:32.336 --> 00:23:35.216 A:middle
50 by 50, 100 by 100, even more.

00:23:35.446 --> 00:23:36.376 A:middle
It's hard to say.

00:23:37.386 --> 00:23:40.966 A:middle
For these types of layouts,
what would be really cool is

00:23:40.966 --> 00:23:45.006 A:middle
if flow layout could adapt
its estimate and do the math

00:23:45.006 --> 00:23:48.706 A:middle
on your behalf and instead
compute that estimated size

00:23:48.886 --> 00:23:51.746 A:middle
from actual sizes of
content that we've sized.

00:23:53.016 --> 00:23:56.596 A:middle
So in iOS X, we've got new
API on flow layout to do that.

00:23:57.866 --> 00:24:01.016 A:middle
All you have to do is set your
flow layout.EstimatedItemSize

00:23:57.866 --> 00:24:01.016 A:middle
All you have to do is set your
flow layout.EstimatedItemSize

00:24:01.016 --> 00:24:01.916 A:middle
to a new constant,

00:24:02.356 --> 00:24:05.386 A:middle
UICollectionViewFlowLayout
AutomaticSize.

00:24:11.836 --> 00:24:15.266 A:middle
By setting your estimated
item size to automatic size,

00:24:15.546 --> 00:24:17.626 A:middle
you'll indicate to the
CollectionViewFlowLayout

00:24:17.776 --> 00:24:19.296 A:middle
that it should do
the math for you.

00:24:19.806 --> 00:24:22.376 A:middle
It'll keep a running
tally of all the cells

00:24:22.376 --> 00:24:24.416 A:middle
that it's already sized, and use

00:24:24.416 --> 00:24:27.486 A:middle
that to influence its
future sizing estimates.

00:24:28.106 --> 00:24:29.106 A:middle
As we'll see in a minute,

00:24:29.506 --> 00:24:32.576 A:middle
this makes the flow layout much
more accurate while it's sizing

00:24:32.576 --> 00:24:35.346 A:middle
your CollectionView cells
leading to better performance

00:24:35.476 --> 00:24:38.006 A:middle
and a more accurate
layout while we're sizing.

00:24:38.746 --> 00:24:42.276 A:middle
So we're going to do a demo
to show you the benefits

00:24:42.276 --> 00:24:45.566 A:middle
of UICollectionViewFlowLayout
automatic size.

00:24:50.196 --> 00:24:51.966 A:middle
So I'm going to switch
back to the iPad.

00:25:00.096 --> 00:25:02.956 A:middle
Now here we've got a
CollectionView using a

00:25:02.956 --> 00:25:03.496 A:middle
flow layout.

00:25:04.186 --> 00:25:07.556 A:middle
Each cell represents a
word in a run of text.

00:25:08.476 --> 00:25:10.436 A:middle
Just to clarify,
we're not recommending

00:25:10.436 --> 00:25:13.516 A:middle
that you build a text viewer or
editor using UICollectionView,

00:25:14.376 --> 00:25:15.906 A:middle
but this does make
a really good demo.

00:25:17.106 --> 00:25:18.976 A:middle
I'm going to put
the app into a mode

00:25:19.396 --> 00:25:21.746 A:middle
where we can watch
the flow layout

00:25:21.746 --> 00:25:24.086 A:middle
as it sizes each
individual cell.

00:25:24.836 --> 00:25:27.626 A:middle
No user would ever see
this, but it's really great

00:25:27.626 --> 00:25:30.436 A:middle
for visualizing the
advantages of this new API.

00:25:31.376 --> 00:25:33.786 A:middle
Let's start out with
fixed estimates

00:25:33.906 --> 00:25:35.516 A:middle
like we'd use on iOS 9.

00:25:35.516 --> 00:25:37.646 A:middle
So I'm going to turn
on the simulation.

00:25:38.936 --> 00:25:41.786 A:middle
Here, you can see that
we've seeded each cell

00:25:41.946 --> 00:25:45.616 A:middle
with that initial estimated
item size where we just guessed.

00:25:45.616 --> 00:25:50.426 A:middle
And I'm going to size the first
word in this run of text, Lorem,

00:25:51.026 --> 00:25:52.066 A:middle
and watch what happens.

00:25:54.276 --> 00:25:57.726 A:middle
So we size Lorem, and now
it's the correct size,

00:25:58.056 --> 00:26:01.316 A:middle
but notice the CollectionView
is really no closer

00:25:58.056 --> 00:26:01.316 A:middle
but notice the CollectionView
is really no closer

00:26:01.316 --> 00:26:03.846 A:middle
to what its destination
layout size will be.

00:26:04.396 --> 00:26:07.246 A:middle
We didn't use that estimate
to influence anything else,

00:26:07.616 --> 00:26:10.576 A:middle
and everything else is still
this large initial estimate

00:26:10.576 --> 00:26:11.306 A:middle
that we passed in.

00:26:11.836 --> 00:26:17.376 A:middle
Now this continues as we
size each cell individually

00:26:17.576 --> 00:26:18.416 A:middle
in this CollectionView.

00:26:19.786 --> 00:26:23.126 A:middle
Notice how we're not actually
adopting, adapting any

00:26:23.126 --> 00:26:25.736 A:middle
of the other cell sizes
to account for the sizes

00:26:25.736 --> 00:26:26.876 A:middle
that we've already computed.

00:26:27.766 --> 00:26:31.066 A:middle
This is especially obvious
when we size the last word

00:26:31.066 --> 00:26:35.336 A:middle
in this run of text, Fusce,
and as we go to size this word,

00:26:36.516 --> 00:26:39.396 A:middle
you'll notice that we slide
up all the other cells,

00:26:39.396 --> 00:26:41.096 A:middle
invalidating their y-positions,

00:26:42.026 --> 00:26:44.556 A:middle
and we haven't used the
information from that first line

00:26:44.556 --> 00:26:48.276 A:middle
of text to influence the sizes
of any of the other cells.

00:26:49.536 --> 00:26:51.066 A:middle
So now I'm going
to turn the device

00:26:51.096 --> 00:26:55.386 A:middle
into iOS X mode using
UICollectionViewFlowLayout

00:26:55.826 --> 00:26:56.726 A:middle
automatic size.

00:26:56.726 --> 00:26:58.136 A:middle
So let's switch over.

00:26:59.396 --> 00:27:00.136 A:middle
OK, great.

00:26:59.396 --> 00:27:00.136 A:middle
OK, great.

00:27:00.206 --> 00:27:02.896 A:middle
So we've seeded this with
the same initial size

00:27:03.236 --> 00:27:04.796 A:middle
to help you visualize
the difference.

00:27:05.516 --> 00:27:07.826 A:middle
I'm going to size the
first word, Lorem,

00:27:08.246 --> 00:27:09.526 A:middle
and watch what happens.

00:27:10.836 --> 00:27:15.816 A:middle
Wow. So we size that first
cell, and use that cell size

00:27:16.126 --> 00:27:19.456 A:middle
as a running estimate for all
the other CollectionView cells.

00:27:20.076 --> 00:27:22.216 A:middle
Now the layout's not
totally accurate yet,

00:27:22.676 --> 00:27:25.626 A:middle
but notice how it's a lot closer
to what it will eventually be.

00:27:26.046 --> 00:27:27.366 A:middle
In fact, the heights

00:27:27.366 --> 00:27:29.736 A:middle
in y-positions are
pretty much spot on.

00:27:30.636 --> 00:27:34.346 A:middle
And notice that as I size this
run of text, we're adapting

00:27:34.346 --> 00:27:37.426 A:middle
that estimated size, making
it more and more accurate

00:27:37.806 --> 00:27:39.896 A:middle
for your CollectionView
cells holistically.

00:27:41.796 --> 00:27:44.896 A:middle
And notice when we size the
last word in this run of text,

00:27:45.756 --> 00:27:47.996 A:middle
we're no longer invalidating
the y-positions

00:27:48.096 --> 00:27:49.506 A:middle
of all the other cells.

00:27:49.936 --> 00:27:52.436 A:middle
This is really great
and can help out a lot

00:27:52.436 --> 00:27:55.296 A:middle
when you're doing things like
scrollToItemAt indexPath.

00:27:55.796 --> 00:27:59.616 A:middle
Now due to the nature of this
API, you'll get the most bang

00:27:59.616 --> 00:28:01.796 A:middle
for your buck using
automatic size

00:27:59.616 --> 00:28:01.796 A:middle
for your buck using
automatic size

00:28:02.266 --> 00:28:05.376 A:middle
if your cells have
similar widths or heights.

00:28:06.046 --> 00:28:08.636 A:middle
So that's it for self-sizing
improvements in iOS X.

00:28:08.636 --> 00:28:09.976 A:middle
Let's go back to slides.

00:28:10.516 --> 00:28:15.596 A:middle
[ Applause ]

00:28:16.096 --> 00:28:20.586 A:middle
So that wraps up our
self-sizing cell segment,

00:28:20.586 --> 00:28:22.176 A:middle
and now we're going
to talk a little bit

00:28:22.176 --> 00:28:26.336 A:middle
about an API we introduced last
year, interactive reordering.

00:28:27.716 --> 00:28:30.126 A:middle
Now, this is a familiar
user experience

00:28:30.126 --> 00:28:31.646 A:middle
to users of TableView cells.

00:28:31.646 --> 00:28:34.886 A:middle
They like to, users might grab
a piece of content and move it

00:28:34.886 --> 00:28:37.586 A:middle
and rearrange it
vertically in your TableView.

00:28:38.066 --> 00:28:41.036 A:middle
So we brought this technology
to CollectionView last year

00:28:41.356 --> 00:28:43.226 A:middle
with a new interactive
reordering API.

00:28:43.646 --> 00:28:44.956 A:middle
Let's run back over to the iPad

00:28:44.956 --> 00:28:46.966 A:middle
and see what this might
look like in the demo.

00:28:57.296 --> 00:28:58.656 A:middle
Switch back over to the iPad.

00:28:58.846 --> 00:28:59.236 A:middle
&gt;&gt; Alright.

00:28:59.236 --> 00:28:59.656 A:middle
&gt;&gt; Here we are.

00:29:00.316 --> 00:29:03.026 A:middle
OK. So we've got this really
pretty looking custom layout.

00:29:03.026 --> 00:29:05.766 A:middle
Oh, man, look at
that scroll, Peter.

00:29:05.766 --> 00:29:08.196 A:middle
&gt;&gt; We probably adapted
pre-fetching,

00:29:08.236 --> 00:29:09.256 A:middle
which is really easy.

00:29:09.476 --> 00:29:10.316 A:middle
&gt;&gt; That's probably it.

00:29:10.636 --> 00:29:11.666 A:middle
OK. So check it out.

00:29:11.666 --> 00:29:13.766 A:middle
So let's say the user
loves this content,

00:29:13.766 --> 00:29:14.916 A:middle
but they want to rearrange it.

00:29:15.346 --> 00:29:18.986 A:middle
Might drag their finger around
and move the content smoothly

00:29:18.986 --> 00:29:20.116 A:middle
around the CollectionView,

00:29:20.116 --> 00:29:22.396 A:middle
and notice how it
reflows automatically.

00:29:22.456 --> 00:29:24.846 A:middle
And not only that, if
we change to an item

00:29:24.846 --> 00:29:27.416 A:middle
that has a different
size, let's you be able

00:29:27.416 --> 00:29:27.986 A:middle
to do the right thing.

00:29:28.466 --> 00:29:31.286 A:middle
Now when the user's done
reordering, they might let go.

00:29:31.686 --> 00:29:34.246 A:middle
Smoothly animates into
place, and that's it.

00:29:35.066 --> 00:29:37.056 A:middle
Let's switch back to slides, and
let Peter go through that API.

00:29:37.056 --> 00:29:41.586 A:middle
&gt;&gt; So that's interactive
reordering as it existed

00:29:41.586 --> 00:29:44.896 A:middle
on iOS 9, and this
API is really simple.

00:29:46.266 --> 00:29:48.606 A:middle
To start an interactive
movement, you're going

00:29:48.606 --> 00:29:51.066 A:middle
to call CollectionViews
beginInteractive

00:29:51.066 --> 00:29:53.056 A:middle
MovementForItemat indexPath

00:29:53.696 --> 00:29:57.366 A:middle
where index path represents
the index path of the cell

00:29:57.536 --> 00:29:58.796 A:middle
that we'd like to move around.

00:29:59.626 --> 00:30:01.616 A:middle
If you're doing this in
response to a gesture,

00:29:59.626 --> 00:30:01.616 A:middle
If you're doing this in
response to a gesture,

00:30:01.946 --> 00:30:05.866 A:middle
you can hit test the
CollectionView using index path

00:30:06.126 --> 00:30:07.216 A:middle
for item at location.

00:30:08.056 --> 00:30:11.536 A:middle
Next, each time the gesture
updates, we're going to want

00:30:11.536 --> 00:30:14.786 A:middle
to update the cell's position
in response to our finger.

00:30:15.136 --> 00:30:18.116 A:middle
For this, we're going to call
updateInteractiveMovement

00:30:18.506 --> 00:30:19.386 A:middle
TargetPosition.

00:30:20.006 --> 00:30:22.016 A:middle
Passing in the location
of the gesture

00:30:22.196 --> 00:30:24.096 A:middle
in the CollectionView's
coordinate space.

00:30:24.506 --> 00:30:28.766 A:middle
Next, when we'd like to end
the interactive movement

00:30:28.946 --> 00:30:30.216 A:middle
and confirm the reorder,

00:30:30.526 --> 00:30:33.066 A:middle
we're going to call
endInteractiveMovement

00:30:33.066 --> 00:30:33.896 A:middle
on the CollectionView.

00:30:35.136 --> 00:30:37.346 A:middle
CollectionView will
put the cell down,

00:30:37.626 --> 00:30:39.676 A:middle
handling all the layout
attributes correctly,

00:30:40.016 --> 00:30:42.336 A:middle
and then message back to
your app's data source

00:30:42.406 --> 00:30:45.416 A:middle
so that you could do the
actual rearrange in your model.

00:30:47.136 --> 00:30:49.836 A:middle
Now, if the gesture cancels,

00:30:49.836 --> 00:30:52.126 A:middle
or if you'd like to not allow
reordering at this time,

00:30:52.626 --> 00:30:55.606 A:middle
you can call CollectionView's
cancelInteractiveMovement.

00:30:56.396 --> 00:30:58.876 A:middle
Here, we'll put everything
back to where it was before,

00:30:59.446 --> 00:31:01.326 A:middle
and we won't call
your data source.

00:30:59.446 --> 00:31:01.326 A:middle
and we won't call
your data source.

00:31:02.396 --> 00:31:05.306 A:middle
Now for those of you using
UICollectionViewController,

00:31:05.696 --> 00:31:07.576 A:middle
this is even easier
for you to use.

00:31:08.296 --> 00:31:10.686 A:middle
You just have to set the
install standard gesture

00:31:10.686 --> 00:31:13.266 A:middle
for interactive movement
property to true,

00:31:14.016 --> 00:31:16.826 A:middle
and CollectionViewController
will add a gesture

00:31:16.936 --> 00:31:19.816 A:middle
that will call these
methods on your behalf.

00:31:20.126 --> 00:31:23.106 A:middle
All you have to do is
implement the data source parts.

00:31:23.436 --> 00:31:27.896 A:middle
&gt;&gt; So that's the API that we
shipped last year in iOS 9.

00:31:29.266 --> 00:31:31.476 A:middle
This year we're very proud
to announce we're going

00:31:31.476 --> 00:31:33.276 A:middle
to add paging support to this.

00:31:33.326 --> 00:31:37.216 A:middle
Now there's no new API, which
is the best kind of API,

00:31:37.216 --> 00:31:39.976 A:middle
and since CollectionView is
derived from UIScrollView,

00:31:40.426 --> 00:31:44.346 A:middle
all you need to do is set
the isPagingEnabled property

00:31:44.346 --> 00:31:46.776 A:middle
of the ScrollView's
inheritive property to true,

00:31:46.776 --> 00:31:48.446 A:middle
and that'll enable the support.

00:31:48.446 --> 00:31:51.026 A:middle
Let's switch back to the iPad
and check this out in a demo.

00:31:52.036 --> 00:31:53.846 A:middle
&gt;&gt; And here, we've
got a horizontal

00:31:53.846 --> 00:31:55.326 A:middle
scrolling CollectionView.

00:31:56.496 --> 00:31:59.006 A:middle
This is currently
not using paging.

00:31:59.006 --> 00:32:00.636 A:middle
It's just continuous, and look

00:31:59.006 --> 00:32:00.636 A:middle
It's just continuous, and look

00:32:00.636 --> 00:32:02.706 A:middle
at that smooth scrolling
performance.

00:32:02.706 --> 00:32:04.086 A:middle
&gt;&gt; Hey, hey.

00:32:04.286 --> 00:32:07.916 A:middle
&gt;&gt; So in reordering when
we're scrolling continuously,

00:32:08.556 --> 00:32:11.326 A:middle
we pick up the CollectionView
cell and move it to the edge

00:32:11.326 --> 00:32:14.656 A:middle
of the screen, and then we
get this really nice auto

00:32:14.656 --> 00:32:15.516 A:middle
scrolling behavior.

00:32:15.866 --> 00:32:17.816 A:middle
This is familiar to users

00:32:17.946 --> 00:32:19.866 A:middle
of many CollectionView
based applications.

00:32:19.866 --> 00:32:24.496 A:middle
Now I'm going to turn on
paging support, and we'll see

00:32:24.496 --> 00:32:27.746 A:middle
that CollectionView now advances
in page size increments.

00:32:28.236 --> 00:32:31.296 A:middle
This is really natural for
some types of CollectionViews.

00:32:31.906 --> 00:32:33.086 A:middle
Now here's what's new.

00:32:34.176 --> 00:32:35.916 A:middle
We're calling the
same reordering API,

00:32:36.586 --> 00:32:38.006 A:middle
but new in iOS X,

00:32:38.006 --> 00:32:41.006 A:middle
that reordering works
alongside paging.

00:32:41.676 --> 00:32:43.996 A:middle
So as I move my cell to
the edge of the screen,

00:32:44.496 --> 00:32:49.516 A:middle
we're going to automatically
scroll in page size increments.

00:32:50.846 --> 00:32:53.546 A:middle
This can give your app a
really home screen style

00:32:53.546 --> 00:32:54.736 A:middle
reordering experience.

00:32:54.966 --> 00:32:56.876 A:middle
I'm going to let
go, and that's it.

00:32:57.516 --> 00:33:03.306 A:middle
[ Applause ]

00:32:57.516 --> 00:33:03.306 A:middle
[ Applause ]

00:33:03.806 --> 00:33:04.946 A:middle
Let's go back to slides.

00:33:10.696 --> 00:33:12.476 A:middle
&gt;&gt; So they're a little
[inaudible].

00:33:12.636 --> 00:33:15.816 A:middle
So while we were developing
iOS X in the early phases,

00:33:16.246 --> 00:33:19.096 A:middle
Pete would often come to my
office very enthusiastic.

00:33:19.856 --> 00:33:22.006 A:middle
"Steve, I'm working
on this great feature.

00:33:22.006 --> 00:33:23.796 A:middle
Developers are going to flip."

00:33:24.286 --> 00:33:24.846 A:middle
He's like that.

00:33:25.316 --> 00:33:27.856 A:middle
And I agree, it's
a great feature.

00:33:27.856 --> 00:33:29.736 A:middle
I can't wait to show it
to developers everywhere.

00:33:30.536 --> 00:33:33.996 A:middle
So during the run up to WWDC,
now he's looking for a place

00:33:33.996 --> 00:33:36.696 A:middle
to land this particular
slide so we can talk about it

00:33:36.696 --> 00:33:37.566 A:middle
and share it to people.

00:33:38.636 --> 00:33:40.396 A:middle
So even a couple days ago,

00:33:40.546 --> 00:33:42.366 A:middle
he made the pitch again,
"We've got to do it."

00:33:43.076 --> 00:33:44.206 A:middle
So I said, "OK, fine."

00:33:44.766 --> 00:33:47.096 A:middle
Two slides, ninety
seconds, Peter.

00:33:47.336 --> 00:33:48.466 A:middle
Can you get it done?

00:33:48.466 --> 00:33:49.076 A:middle
&gt;&gt; Thanks, Steve.

00:33:49.076 --> 00:33:50.216 A:middle
It'll just take a minute.

00:33:50.736 --> 00:33:53.816 A:middle
Another feature that I'm
really excited about that's new

00:33:53.816 --> 00:33:57.376 A:middle
in CollectionView in iOS
X is UIRefreshControl!

00:33:58.026 --> 00:33:58.676 A:middle
That's right!

00:33:58.716 --> 00:34:01.726 A:middle
UIRefreshControl is now
directly supported inside

00:33:58.716 --> 00:34:01.726 A:middle
UIRefreshControl is now
directly supported inside

00:34:01.726 --> 00:34:02.456 A:middle
of CollectionView.

00:34:05.866 --> 00:34:08.956 A:middle
But not only that, it's also
directly supported inside

00:34:08.956 --> 00:34:12.346 A:middle
of UITableView without
using UITableViewController!

00:34:12.346 --> 00:34:16.446 A:middle
And not only that, it's also
supported inside of UIScrollView

00:34:16.616 --> 00:34:19.795 A:middle
because RefreshControl is now
just a ScrollView property!

00:34:21.545 --> 00:34:27.436 A:middle
It's really easy to use, too.

00:34:27.916 --> 00:34:30.795 A:middle
All you have to use, do is
create the RefreshControl,

00:34:31.496 --> 00:34:33.876 A:middle
add yourself as a target
to it with an action,

00:34:34.436 --> 00:34:35.835 A:middle
and set it on your
CollectionView,

00:34:36.106 --> 00:34:38.416 A:middle
and you'll be pulling
to refresh in no time.

00:34:38.726 --> 00:34:39.556 A:middle
Thanks a lot, Steve.

00:34:39.556 --> 00:34:40.246 A:middle
It means a lot to me.

00:34:40.246 --> 00:34:40.976 A:middle
&gt;&gt; Hey, great job.

00:34:41.686 --> 00:34:42.106 A:middle
Great job.

00:34:42.106 --> 00:34:48.726 A:middle
It's like the summarizer
we talked about today.

00:34:48.726 --> 00:34:51.166 A:middle
We went over the brand
new UICollectionView cell

00:34:51.166 --> 00:34:53.226 A:middle
pre-fetching stuff,
and we can't wait

00:34:53.226 --> 00:34:55.235 A:middle
to see what you guys are going
to do in your apps with this.

00:34:55.775 --> 00:34:58.846 A:middle
And then we covered the new
pre-fetch data source API

00:34:58.846 --> 00:35:00.866 A:middle
for Collection and TableView.

00:34:58.846 --> 00:35:00.866 A:middle
for Collection and TableView.

00:35:02.416 --> 00:35:04.066 A:middle
Next, we covered
the improvements

00:35:04.066 --> 00:35:07.226 A:middle
to self-sizing cells with the
new automatic size constant.

00:35:07.706 --> 00:35:10.116 A:middle
And then we chatted a little bit

00:35:10.116 --> 00:35:13.196 A:middle
about the iOS 9 introduced
API interactive reordering

00:35:13.196 --> 00:35:16.526 A:middle
and the new paging
support we have in iOS X.

00:35:17.196 --> 00:35:19.506 A:middle
You want to check out the
sample code and other resources

00:35:19.506 --> 00:35:22.476 A:middle
for this app, for this session,
we can see the address there

00:35:22.476 --> 00:35:24.046 A:middle
on the developer website.

00:35:24.756 --> 00:35:26.706 A:middle
We got some great
related sessions

00:35:26.706 --> 00:35:27.626 A:middle
with these technologies
[inaudible].

00:35:27.626 --> 00:35:29.896 A:middle
We want to thank you
very much for coming out.

00:35:29.896 --> 00:35:30.536 A:middle
Have a great --

00:35:30.676 --> 00:35:31.446 A:middle
&gt;&gt; Thank you so much.
