WEBVTT

00:00:07.516 --> 00:00:25.926 A:middle
[ Music ]

00:00:26.426 --> 00:00:26.946 A:middle
&gt;&gt; Good morning.

00:00:28.006 --> 00:00:29.016 A:middle
My name is Ali Ozer.

00:00:29.396 --> 00:00:30.506 A:middle
I and my colleagues [applause].

00:00:31.496 --> 00:00:31.786 A:middle
Thank you.

00:00:35.336 --> 00:00:37.926 A:middle
I and my colleagues Raleigh
Ledet and Taylor Kelly

00:00:37.926 --> 00:00:40.206 A:middle
from the Cocoa Frameworks
team will be talking

00:00:40.206 --> 00:00:41.866 A:middle
about what's new
in Cocoa this year.

00:00:42.856 --> 00:00:44.006 A:middle
Our agenda is pretty simple.

00:00:44.006 --> 00:00:47.016 A:middle
First, API updates
followed by new features

00:00:47.016 --> 00:00:48.246 A:middle
in AppKit and Foundation.

00:00:49.776 --> 00:00:54.116 A:middle
And in the area of API updates,
we have two main categories

00:00:54.116 --> 00:00:55.726 A:middle
of API updates I
want to talk about.

00:00:55.726 --> 00:00:59.046 A:middle
One, the API changes due to
the new Swift API guidelines

00:00:59.476 --> 00:01:01.866 A:middle
and secondly, the general API
refinements we've been doing.

00:00:59.476 --> 00:01:01.866 A:middle
and secondly, the general API
refinements we've been doing.

00:01:02.296 --> 00:01:03.306 A:middle
So let's get started.

00:01:04.436 --> 00:01:07.746 A:middle
Now as you heard probably
yesterday or if not,

00:01:07.786 --> 00:01:11.636 A:middle
this morning, we have new API
design guidelines in Swift.

00:01:11.636 --> 00:01:13.936 A:middle
And these guidelines still
embrace Cocoa conventions

00:01:13.936 --> 00:01:16.176 A:middle
and practices and
I'll just remind you

00:01:16.176 --> 00:01:17.356 A:middle
of what some of these are.

00:01:18.176 --> 00:01:20.346 A:middle
Using clear and consistent
naming,

00:01:20.936 --> 00:01:24.486 A:middle
striving for fluent usage, you
know, where a call site reads

00:01:24.486 --> 00:01:27.016 A:middle
as an English phrase,
naming mutating

00:01:27.016 --> 00:01:30.406 A:middle
and non-muting method pairs
consistently, sort and sorted,

00:01:30.626 --> 00:01:33.876 A:middle
append and appending, and
avoiding abbreviations.

00:01:33.876 --> 00:01:36.606 A:middle
These are just of the
main guidelines we've had

00:01:36.636 --> 00:01:39.236 A:middle
for many years and
we've documented these

00:01:39.236 --> 00:01:41.296 A:middle
and we've talked about
them in previous WWDCs,

00:01:41.296 --> 00:01:42.796 A:middle
as you see in this session here.

00:01:43.496 --> 00:01:45.566 A:middle
And now we updated
the guidelines

00:01:45.956 --> 00:01:48.956 A:middle
to utilize Swift features
such as strong typing,

00:01:49.216 --> 00:01:51.526 A:middle
type inference, and overloading,

00:01:51.776 --> 00:01:54.756 A:middle
and to make sure our APIs
shine through in Swift.

00:01:54.756 --> 00:01:57.146 A:middle
And let me talk about some of
the key differences in our APIs

00:01:57.146 --> 00:01:58.626 A:middle
as a result of these changes.

00:01:59.096 --> 00:02:02.466 A:middle
For one thing, we're eliminating
repeated and needless words,

00:01:59.096 --> 00:02:02.466 A:middle
For one thing, we're eliminating
repeated and needless words,

00:02:02.666 --> 00:02:05.636 A:middle
which of course makes
our APIs more swifty,

00:02:05.666 --> 00:02:06.906 A:middle
as you might have
heard yesterday.

00:02:06.906 --> 00:02:09.545 A:middle
You saw an example yesterday in
Chris Lattner's section of state

00:02:09.545 --> 00:02:11.256 A:middle
of the union with an example.

00:02:11.256 --> 00:02:14.526 A:middle
Here's another example,
contacts.arrayByAddingObject.

00:02:14.896 --> 00:02:19.056 A:middle
In a method call like this, both
the words "array" and the words

00:02:19.056 --> 00:02:21.426 A:middle
"object" don't really
add much to that call.

00:02:21.766 --> 00:02:25.176 A:middle
So such a name now comes across
as contacts.adding(person).

00:02:26.486 --> 00:02:30.046 A:middle
Here's another example
on the NSColor class.

00:02:30.046 --> 00:02:33.616 A:middle
NSColor.blueColor, now
we're on the NSColor class.

00:02:33.616 --> 00:02:35.076 A:middle
Blue is already a color,

00:02:35.076 --> 00:02:37.516 A:middle
so the word color really
doesn't add much to this call.

00:02:37.876 --> 00:02:39.496 A:middle
So in the new guidelines,
it actually comes

00:02:39.496 --> 00:02:41.056 A:middle
across as NSColor.blue.

00:02:41.836 --> 00:02:44.386 A:middle
But note that we're still
striving for clarity.

00:02:44.576 --> 00:02:47.986 A:middle
Here's another method from
NSColor, NSColor.textColor.

00:02:49.016 --> 00:02:51.756 A:middle
Text is not inherently
a color and, in fact,

00:02:51.756 --> 00:02:55.086 A:middle
talking about the text of
a color could be confusing.

00:02:55.506 --> 00:02:59.006 A:middle
Is it the text that represents
the color's RGB values or what?

00:02:59.516 --> 00:03:01.866 A:middle
So in a case like this, we've
actually left the method alone

00:02:59.516 --> 00:03:01.866 A:middle
So in a case like this, we've
actually left the method alone

00:03:01.866 --> 00:03:04.136 A:middle
and it comes across
as NSColor.textColor,

00:03:04.266 --> 00:03:06.676 A:middle
like it used to be.

00:03:08.506 --> 00:03:13.616 A:middle
Now some of the other key
changes to making use of types,

00:03:13.756 --> 00:03:18.376 A:middle
here's an example,
document.readFromURL ofType,

00:03:18.606 --> 00:03:22.506 A:middle
now this API comes across
as document.readFrom ofType.

00:03:22.856 --> 00:03:26.636 A:middle
You'll note that we've
dropped the word URL

00:03:26.736 --> 00:03:27.886 A:middle
from our method signature.

00:03:28.076 --> 00:03:31.376 A:middle
It's because the type of
the first argument is URL

00:03:31.656 --> 00:03:34.146 A:middle
and with type inference, Swift
knows enough to handle that.

00:03:34.346 --> 00:03:35.496 A:middle
And by dropping that word,

00:03:35.496 --> 00:03:38.246 A:middle
we actually now have three
read methods on an NSDocument

00:03:38.916 --> 00:03:42.256 A:middle
that are all named exactly the
same thing read from ofType

00:03:42.256 --> 00:03:45.626 A:middle
and it's that first argument,
the type of that first argument,

00:03:45.626 --> 00:03:48.036 A:middle
URL data or FileWrapper

00:03:48.036 --> 00:03:50.406 A:middle
that distinguishes
these from each other.

00:03:51.706 --> 00:03:54.576 A:middle
Now another thing to note
here is making use of label

00:03:54.576 --> 00:03:56.556 A:middle
on the first argument.

00:03:57.066 --> 00:04:00.526 A:middle
From here has now been
pulled into the parens.

00:03:57.066 --> 00:04:00.526 A:middle
From here has now been
pulled into the parens.

00:04:00.526 --> 00:04:02.066 A:middle
We do this in a number of cases.

00:04:02.066 --> 00:04:03.896 A:middle
For instance, when the
first argument performs part

00:04:03.896 --> 00:04:05.066 A:middle
of a prepositional phrase,

00:04:05.376 --> 00:04:08.706 A:middle
we pull that phrase inside the
parens, as you can see here.

00:04:08.706 --> 00:04:10.306 A:middle
And you'll probably
see a lot more examples

00:04:10.306 --> 00:04:12.366 A:middle
of this throughout out APIs.

00:04:12.766 --> 00:04:15.616 A:middle
Now you'll also notice that
second argument ofType.

00:04:16.076 --> 00:04:18.305 A:middle
Here we haven't dropped
the word type from the API

00:04:18.856 --> 00:04:20.786 A:middle
because that argument
is a string

00:04:21.065 --> 00:04:22.446 A:middle
and strings are weakly typed.

00:04:22.516 --> 00:04:24.806 A:middle
So we really need a word
to describe their role

00:04:24.806 --> 00:04:26.746 A:middle
and the role here is
that this is the type

00:04:26.746 --> 00:04:27.846 A:middle
of file we're opening.

00:04:28.076 --> 00:04:32.036 A:middle
So there, we keep the
word type in the API.

00:04:35.116 --> 00:04:38.406 A:middle
Now many framework and standard
library APIs have changed

00:04:38.406 --> 00:04:39.936 A:middle
as a result of these
new guidelines

00:04:40.376 --> 00:04:43.756 A:middle
and the importer whose job
is to map Objective-C APIs

00:04:43.756 --> 00:04:46.716 A:middle
into Swift now does it
using these new guidelines,

00:04:47.036 --> 00:04:49.726 A:middle
but you'll note that some
APIs may need further tuning.

00:04:49.996 --> 00:04:53.056 A:middle
We've done that in our APIs,
such as the API textColor,

00:04:53.056 --> 00:04:54.956 A:middle
which I showed earlier,
which is an exception.

00:04:55.146 --> 00:04:57.776 A:middle
And if you yourself have
Objective-C APIs you're exposing

00:04:57.776 --> 00:05:00.726 A:middle
in Swift, you may need to do
so as well by using something

00:04:57.776 --> 00:05:00.726 A:middle
in Swift, you may need to do
so as well by using something

00:05:00.726 --> 00:05:04.526 A:middle
like NS Swift Name, which lets
you override the default choice

00:05:04.526 --> 00:05:05.326 A:middle
the importer is doing.

00:05:06.136 --> 00:05:08.376 A:middle
You also know that the
migrator converts your --

00:05:08.376 --> 00:05:10.696 A:middle
There's a migrator that converts
your existing Swift 2 code

00:05:10.696 --> 00:05:14.666 A:middle
to Swift 3 and it will help
you with all this new naming

00:05:14.666 --> 00:05:16.086 A:middle
in your existing
code, of course.

00:05:16.416 --> 00:05:18.886 A:middle
And the Swift API
Design Guidelines talk,

00:05:18.886 --> 00:05:21.286 A:middle
which took place just before
this one, you can catch this

00:05:21.286 --> 00:05:22.716 A:middle
on video for a lot more details

00:05:22.766 --> 00:05:25.916 A:middle
on these guidelines
and their impact.

00:05:26.046 --> 00:05:29.086 A:middle
Now we have a number of
general APIs refinements,

00:05:29.366 --> 00:05:31.206 A:middle
that some of which
we've done for a while

00:05:31.206 --> 00:05:32.536 A:middle
and others we're
continuing to do.

00:05:32.536 --> 00:05:33.726 A:middle
Let me quickly go through these.

00:05:34.246 --> 00:05:35.816 A:middle
Nullability is something

00:05:35.816 --> 00:05:38.696 A:middle
that we've already
done much of last year.

00:05:38.926 --> 00:05:42.006 A:middle
It's basically declaring whether
arguments, return values,

00:05:42.006 --> 00:05:44.666 A:middle
properties can be nil or
can be optional or not

00:05:45.006 --> 00:05:47.136 A:middle
and we've continued to
refine this, this year.

00:05:47.466 --> 00:05:51.236 A:middle
For instance, here's a method
which in 10.11 was marked

00:05:51.236 --> 00:05:52.766 A:middle
as returning an optional value.

00:05:52.816 --> 00:05:56.736 A:middle
This is addItem on NSMenu
but in 10.12 it's not marked

00:05:56.736 --> 00:05:59.746 A:middle
as returning a non-optional
value because we determined

00:05:59.746 --> 00:06:01.926 A:middle
that this can never really
return nil and it's better

00:05:59.746 --> 00:06:01.926 A:middle
that this can never really
return nil and it's better

00:06:01.926 --> 00:06:03.756 A:middle
to reflect that properly
which makes your code,

00:06:03.756 --> 00:06:06.476 A:middle
of course, a little simpler.

00:06:06.476 --> 00:06:09.636 A:middle
We've been doing properties,
converting getter, setter pairs

00:06:09.636 --> 00:06:11.426 A:middle
into formal properties all along

00:06:11.836 --> 00:06:14.736 A:middle
and this year we're also
actually using Swift's ability

00:06:14.736 --> 00:06:16.146 A:middle
to declare properties
on classes.

00:06:16.146 --> 00:06:19.326 A:middle
For instance, here is a
new property on NSWindow.

00:06:19.386 --> 00:06:20.896 A:middle
You'll hear about this
later in the talk,

00:06:20.896 --> 00:06:22.576 A:middle
allowsAutomaticWindowTabbing.

00:06:23.216 --> 00:06:26.026 A:middle
This is reflected as an actual
class property in Swift.

00:06:27.236 --> 00:06:28.836 A:middle
You'll also note that
we have an ability now

00:06:28.836 --> 00:06:30.006 A:middle
to do this in Objective-C.

00:06:30.296 --> 00:06:32.446 A:middle
You can actually declare class
properties in Objective-C

00:06:32.446 --> 00:06:34.446 A:middle
with this syntax
@property class.

00:06:34.786 --> 00:06:37.216 A:middle
So the same feature comes
across in Objective-C

00:06:37.216 --> 00:06:38.286 A:middle
as well, which is pretty cool.

00:06:38.736 --> 00:06:42.856 A:middle
Here's a Core Data example
NSPersistentStoreCoordinator.

00:06:43.106 --> 00:06:45.936 A:middle
It had this method,
registeredStoreTypes in 10.11.

00:06:46.176 --> 00:06:48.006 A:middle
It's now declared
as a class property.

00:06:48.006 --> 00:06:49.176 A:middle
It's a read-only property,

00:06:49.176 --> 00:06:51.226 A:middle
so it only has a get,
as you can see here.

00:06:51.526 --> 00:06:53.196 A:middle
And in Objective-C,
it also comes

00:06:53.196 --> 00:06:57.486 A:middle
across as property
class, as you can see.

00:06:58.186 --> 00:07:00.016 A:middle
Now generics, we've
been applying them

00:06:58.186 --> 00:07:00.016 A:middle
Now generics, we've
been applying them

00:07:00.016 --> 00:07:02.476 A:middle
to our collections' classes
but they're really, you know,

00:07:02.476 --> 00:07:03.576 A:middle
not just for collections

00:07:03.576 --> 00:07:05.486 A:middle
but they have many
other uses everywhere,

00:07:05.486 --> 00:07:07.036 A:middle
I'm sure as you're aware.

00:07:07.436 --> 00:07:10.326 A:middle
Here's an example from
Core Data, NSFetchRequest.

00:07:11.686 --> 00:07:14.376 A:middle
Here's the way it's declared
in 10.11, pretty simple.

00:07:14.456 --> 00:07:16.606 A:middle
In 10.12, we just went ahead

00:07:16.606 --> 00:07:19.016 A:middle
and added a parameterized
type ResultType.

00:07:19.376 --> 00:07:23.436 A:middle
We also touched a few other
APIs and we added some,

00:07:23.436 --> 00:07:24.786 A:middle
such as this execute method

00:07:24.786 --> 00:07:27.686 A:middle
which returns an array
of that result type.

00:07:28.076 --> 00:07:30.986 A:middle
As a result of this, the use
case now becomes something

00:07:30.986 --> 00:07:31.556 A:middle
like this.

00:07:31.916 --> 00:07:34.906 A:middle
You have a request which you
get from a managed object,

00:07:34.906 --> 00:07:38.016 A:middle
such as employee, and then when
you go ahead and execute that,

00:07:38.236 --> 00:07:40.176 A:middle
your return now is
automatically inferred

00:07:40.176 --> 00:07:42.096 A:middle
to be an array of employee.

00:07:42.716 --> 00:07:45.086 A:middle
Now this is the case
right now but we're hoping

00:07:45.086 --> 00:07:47.816 A:middle
that in upcoming seeds we'll
actually reflect this a little

00:07:47.816 --> 00:07:50.476 A:middle
cleaner like so, which
is actually pretty cool.

00:07:50.476 --> 00:07:53.986 A:middle
So from those two lines, the
compiler is able to infer

00:07:53.986 --> 00:07:56.126 A:middle
that the return type is an
array of that managed object.

00:07:56.616 --> 00:07:59.966 A:middle
We've been improving
our enumeration names.

00:08:00.366 --> 00:08:03.936 A:middle
An example that we've done this
time around is NSColorPanelMode.

00:08:04.366 --> 00:08:07.266 A:middle
The change -- And here's a
use case for it in Swift.

00:08:07.446 --> 00:08:08.966 A:middle
You'll see that's
not very swifty

00:08:09.806 --> 00:08:12.836 A:middle
because .NSCrayonModeColorPanel
is fairly wordy.

00:08:13.646 --> 00:08:17.396 A:middle
The change we've done is to take
the common suffix and pull it

00:08:17.396 --> 00:08:19.306 A:middle
in as a prefix, which
allows the Swift names

00:08:19.306 --> 00:08:20.716 A:middle
to come across a lot cleaner.

00:08:20.786 --> 00:08:22.676 A:middle
You know, where the
point just comes through,

00:08:23.036 --> 00:08:25.026 A:middle
and the use case is .crayon.

00:08:25.076 --> 00:08:27.006 A:middle
Again, this is what
it looked like before

00:08:27.516 --> 00:08:30.786 A:middle
and this is what it looks
like now, fairly clean.

00:08:31.506 --> 00:08:34.895 A:middle
Now in the enumerations area,
we've also now taking advantage

00:08:34.895 --> 00:08:35.895 A:middle
of string enumerations.

00:08:35.895 --> 00:08:37.895 A:middle
Swift supports string-valued
enumerations

00:08:38.206 --> 00:08:41.275 A:middle
and in many cases Cocoa APIs
expose groups of strings

00:08:41.275 --> 00:08:44.526 A:middle
as opened or closed sets of
APIs that we use in our APIs.

00:08:44.526 --> 00:08:47.756 A:middle
And let's look at an example
using string transforms.

00:08:48.946 --> 00:08:51.476 A:middle
In Swift 2 we had a bunch
of global constants.

00:08:52.026 --> 00:08:54.486 A:middle
NSStringTransformLatinToGreek
and so on.

00:08:54.626 --> 00:08:57.066 A:middle
And then we have an API,
stringByApplyingTransform

00:08:57.066 --> 00:08:59.356 A:middle
that took those strings
as its first argument.

00:08:59.876 --> 00:09:02.116 A:middle
In Swift 3 we've actually
added a new type called

00:08:59.876 --> 00:09:02.116 A:middle
In Swift 3 we've actually
added a new type called

00:09:02.116 --> 00:09:05.526 A:middle
StringTransform and then an
extension we declared various

00:09:05.526 --> 00:09:07.766 A:middle
values for that,
such as LatinToGreek.

00:09:08.056 --> 00:09:10.916 A:middle
And the API that takes
that is applyingTransform,

00:09:10.916 --> 00:09:15.456 A:middle
where the first argument is now
an official StringTransform.

00:09:15.586 --> 00:09:19.256 A:middle
So the string argument has
now become StringTransform,

00:09:19.256 --> 00:09:20.586 A:middle
a little more type safe.

00:09:21.126 --> 00:09:24.876 A:middle
Now note that this is an
open-ended enumeration

00:09:25.066 --> 00:09:26.866 A:middle
in that you can declare
your own values.

00:09:27.406 --> 00:09:31.906 A:middle
Let me show you how you do that.

00:09:32.086 --> 00:09:33.406 A:middle
You can go ahead
and add an extension

00:09:33.406 --> 00:09:35.866 A:middle
to StringTransform yourself
and define your own type.

00:09:36.216 --> 00:09:39.896 A:middle
Now the values here are the
values ICU Library accepts

00:09:39.896 --> 00:09:41.266 A:middle
for doing transforms.

00:09:41.266 --> 00:09:44.496 A:middle
So you can use any valid
ID that ICU provides.

00:09:44.856 --> 00:09:47.316 A:middle
It turns out Any to
Publishing is one ICU has

00:09:47.316 --> 00:09:49.456 A:middle
that we don't expose
on our APIs.

00:09:49.456 --> 00:09:52.826 A:middle
So again, go ahead and define
your own publishing transform

00:09:53.106 --> 00:09:55.706 A:middle
and pass it to the APIs just
as if it's a built-in one.

00:09:57.916 --> 00:10:00.686 A:middle
And string enumerations are
also available in Objective-C

00:09:57.916 --> 00:10:00.686 A:middle
And string enumerations are
also available in Objective-C

00:10:00.686 --> 00:10:03.916 A:middle
by using of these two macros
for open or close-ended sets.

00:10:04.376 --> 00:10:06.796 A:middle
And here's the way the string
transform declaration was

00:10:06.796 --> 00:10:07.456 A:middle
in fact added.

00:10:07.456 --> 00:10:09.046 A:middle
In 10.11, this is what we had.

00:10:09.046 --> 00:10:11.436 A:middle
And in 10.12, we have a
new type string transform

00:10:11.436 --> 00:10:16.096 A:middle
which is decorated as NS
Extensible String Enum.

00:10:17.066 --> 00:10:19.776 A:middle
And we're also taking
advantage of Swift's ability

00:10:19.776 --> 00:10:24.246 A:middle
to nest declarations related
about a type, into that type.

00:10:24.726 --> 00:10:26.996 A:middle
An example here from NSData.

00:10:26.996 --> 00:10:29.756 A:middle
We had a option set,
NSDataWritingOptions

00:10:30.266 --> 00:10:34.396 A:middle
and class NSData with an API
writeToURL that used that value.

00:10:34.896 --> 00:10:37.926 A:middle
In Swift 3, this comes
across as class NSData

00:10:38.266 --> 00:10:40.796 A:middle
with a nested WritingOptions,
as you can see here.

00:10:42.056 --> 00:10:45.346 A:middle
And the API that uses
it actually just refers

00:10:45.346 --> 00:10:46.226 A:middle
to WritingOptions, which is

00:10:46.226 --> 00:10:48.226 A:middle
of course much more
cleaner, much better scoped.

00:10:48.816 --> 00:10:51.056 A:middle
Now unrelated to
this nesting change,

00:10:51.056 --> 00:10:52.196 A:middle
you'll note a few more things.

00:10:53.436 --> 00:10:55.766 A:middle
So that's the change
in the type.

00:10:56.056 --> 00:11:00.426 A:middle
You'll also you might note that
we now provide default values

00:10:56.056 --> 00:11:00.426 A:middle
You'll also you might note that
we now provide default values

00:11:00.426 --> 00:11:03.636 A:middle
of an empty set most cases
where we pass options in,

00:11:03.636 --> 00:11:04.716 A:middle
which means you actually
don't have

00:11:04.776 --> 00:11:06.366 A:middle
to pass the options
argument anymore.

00:11:07.116 --> 00:11:10.006 A:middle
You might've also noticed that
NSURL has become URL here.

00:11:10.066 --> 00:11:11.716 A:middle
You might've already heard
about this but we'll talk

00:11:11.716 --> 00:11:13.386 A:middle
about this more later
in the talk.

00:11:15.016 --> 00:11:17.296 A:middle
Now my last topic
before I escape the stage

00:11:17.296 --> 00:11:20.396 A:middle
for now is noescape.

00:11:20.896 --> 00:11:24.136 A:middle
Okay. So noescape indicates

00:11:24.186 --> 00:11:27.496 A:middle
that a closure's execution will
not escape the function call.

00:11:28.006 --> 00:11:28.966 A:middle
What do I mean by that?

00:11:29.076 --> 00:11:29.656 A:middle
Here's a method

00:11:29.656 --> 00:11:31.976 A:middle
from NSCollection view
performBatchUpdates.

00:11:32.186 --> 00:11:33.836 A:middle
It takes two closure arguments.

00:11:34.856 --> 00:11:37.466 A:middle
You'll note that the first
one is marked with noescape.

00:11:37.526 --> 00:11:38.756 A:middle
This means that the execution

00:11:38.756 --> 00:11:42.596 A:middle
of this closure will
finish before this API

00:11:42.796 --> 00:11:44.256 A:middle
performBatchUpdates returns.

00:11:44.566 --> 00:11:46.906 A:middle
The second argument is
not labeled noescape,

00:11:46.936 --> 00:11:50.866 A:middle
which means that the execution
of this closure might happen

00:11:51.166 --> 00:11:52.606 A:middle
after this function returns.

00:11:52.826 --> 00:11:54.626 A:middle
So it's a good hint to
you and so a good hint

00:11:54.626 --> 00:11:55.646 A:middle
for the compiler as well.

00:11:56.006 --> 00:11:58.096 A:middle
This facility is also
available in Objective-C

00:11:58.316 --> 00:12:00.706 A:middle
where we can decorate
closures with NS NOESCAPE

00:11:58.316 --> 00:12:00.706 A:middle
where we can decorate
closures with NS NOESCAPE

00:12:00.796 --> 00:12:01.686 A:middle
to get the same effect.

00:12:02.616 --> 00:12:05.506 A:middle
So that's it for our quick
overview of general API changes.

00:12:05.826 --> 00:12:07.466 A:middle
Now note in the seed you have,

00:12:07.746 --> 00:12:09.296 A:middle
we haven't done everything
we want to do yet,

00:12:09.296 --> 00:12:11.636 A:middle
so there will be some
string enumeration changes,

00:12:11.636 --> 00:12:14.026 A:middle
class property changes coming
in other seeds as well.

00:12:14.396 --> 00:12:16.646 A:middle
So we're going to
apply to more APIs.

00:12:20.046 --> 00:12:22.026 A:middle
So with that, let's talk
about AppKit and I'm going

00:12:22.026 --> 00:12:24.936 A:middle
to invite Raleigh Ledet
on stage to kick that off.

00:12:25.206 --> 00:12:25.456 A:middle
Thank you.

00:12:26.516 --> 00:12:30.036 A:middle
[ Applause ]

00:12:30.536 --> 00:12:31.046 A:middle
&gt;&gt; Thank you, Ali.

00:12:31.046 --> 00:12:32.226 A:middle
Good morning, everyone.

00:12:33.336 --> 00:12:36.326 A:middle
As you can see, we've been very
busy this past year in AppKit.

00:12:36.826 --> 00:12:40.076 A:middle
So let's dive right on in and
talk about window snapping.

00:12:41.526 --> 00:12:45.116 A:middle
So when you're dragging
a window in macOS Sierra,

00:12:45.266 --> 00:12:47.556 A:middle
as you bump up against the
edges will stick at the edges

00:12:47.746 --> 00:12:49.786 A:middle
and as you get along the
top edge of another window

00:12:49.786 --> 00:12:51.046 A:middle
and even during resizing.

00:12:51.406 --> 00:12:55.046 A:middle
So it's now much easier for
you to align windows together

00:12:55.216 --> 00:12:57.926 A:middle
and resize them just the
way you really want to do.

00:12:58.516 --> 00:13:01.616 A:middle
And we spent a lot of effort
here in providing heuristics

00:12:58.516 --> 00:13:01.616 A:middle
And we spent a lot of effort
here in providing heuristics

00:13:01.616 --> 00:13:03.906 A:middle
to make sure that we only
provide the snapping behavior

00:13:04.276 --> 00:13:06.006 A:middle
when that is what
you are trying to do

00:13:06.006 --> 00:13:07.366 A:middle
with your windows
in the first place.

00:13:08.366 --> 00:13:10.956 A:middle
The way you get snapping
behavior in your application is

00:13:10.956 --> 00:13:14.036 A:middle
to just let the system do the
dragging of the window for you.

00:13:14.916 --> 00:13:16.746 A:middle
If you track the mouse yourself

00:13:16.746 --> 00:13:19.156 A:middle
and manually position
the window, you're going

00:13:19.156 --> 00:13:21.816 A:middle
to bypass window snapping and
we will put the window exactly

00:13:21.816 --> 00:13:24.596 A:middle
where you ask us to put it, just
as we have in previous releases.

00:13:25.156 --> 00:13:29.416 A:middle
As you've seen in the keynote,
we now have window tabbing.

00:13:29.416 --> 00:13:34.006 A:middle
This is an example of TextEdit
with three document tabs open.

00:13:34.606 --> 00:13:37.366 A:middle
And the thing about
window tabbing is they are

00:13:37.366 --> 00:13:38.296 A:middle
just windows.

00:13:38.876 --> 00:13:42.916 A:middle
So this example of TextEdit with
three tabs is actually backed

00:13:42.976 --> 00:13:44.676 A:middle
by three different NS windows.

00:13:46.146 --> 00:13:50.586 A:middle
So what we do is every one of
these windows, as long as one

00:13:50.586 --> 00:13:52.386 A:middle
of the tabs is visible,
is considered visible.

00:13:52.996 --> 00:13:55.306 A:middle
So if you check the
NSWindow's .visible property,

00:13:55.366 --> 00:13:56.586 A:middle
it's going to return true.

00:13:57.446 --> 00:13:59.906 A:middle
But only the visible tab
is actually being rendered

00:13:59.906 --> 00:14:00.636 A:middle
to the screen.

00:13:59.906 --> 00:14:00.636 A:middle
to the screen.

00:14:00.866 --> 00:14:03.666 A:middle
We hide all the other windows
at the windows server level

00:14:04.056 --> 00:14:05.316 A:middle
so they aren't rendered
and aren't taking

00:14:05.316 --> 00:14:06.216 A:middle
up resources that way.

00:14:06.816 --> 00:14:10.486 A:middle
And we handle this
all automatically.

00:14:11.436 --> 00:14:13.726 A:middle
So how do you add a
new tab to your window?

00:14:14.736 --> 00:14:17.076 A:middle
You create a new window
and you just order it front

00:14:17.076 --> 00:14:19.886 A:middle
and we will go ahead and create
a tab appropriately for you

00:14:20.196 --> 00:14:21.676 A:middle
and place it in the window.

00:14:22.216 --> 00:14:25.546 A:middle
If you want to remove a tab,
you order your window out

00:14:25.876 --> 00:14:27.406 A:middle
and we'll go ahead
and remove the tab.

00:14:27.666 --> 00:14:29.006 A:middle
This is all done automatically.

00:14:29.496 --> 00:14:33.086 A:middle
Now if the user resizes the
window, we're only going

00:14:33.086 --> 00:14:35.126 A:middle
to resize the window
associated with the active tab.

00:14:36.236 --> 00:14:38.046 A:middle
We don't want to take
the processing time

00:14:38.046 --> 00:14:39.666 A:middle
to manage the other windows

00:14:39.666 --> 00:14:41.276 A:middle
when the users might
not switch to them.

00:14:41.596 --> 00:14:43.826 A:middle
But when the user does switch
to one of the other tabs,

00:14:43.876 --> 00:14:45.686 A:middle
at that point AppKit goes ahead

00:14:45.686 --> 00:14:48.616 A:middle
and resizes the windows
appropriately, re-renders it,

00:14:48.836 --> 00:14:50.806 A:middle
and then changes the
hidden properties

00:14:50.806 --> 00:14:51.956 A:middle
at the window server level,

00:14:52.016 --> 00:14:54.566 A:middle
and so the user gets
the seamless experience

00:14:54.566 --> 00:14:57.946 A:middle
of one window with multiple tabs
even though behind the scenes

00:14:57.946 --> 00:14:59.766 A:middle
we're just dealing
with three windows.

00:15:02.286 --> 00:15:05.236 A:middle
So I want to cover some
areas of what you need to do

00:15:05.236 --> 00:15:07.206 A:middle
in your applications
to adopt tabs

00:15:07.486 --> 00:15:09.706 A:middle
into your applications
depending on what style

00:15:09.706 --> 00:15:10.626 A:middle
of application you have.

00:15:11.216 --> 00:15:14.216 A:middle
If you have for example an
NSDocument based application

00:15:14.656 --> 00:15:17.316 A:middle
or a non-NSDocument
based application.

00:15:17.746 --> 00:15:18.646 A:middle
What you might want to do

00:15:18.646 --> 00:15:21.026 A:middle
if you already have an
existing tab implementation,

00:15:21.336 --> 00:15:24.886 A:middle
and I'll round the section out
with some API that you can use

00:15:25.096 --> 00:15:27.276 A:middle
to customize tabs
in your application.

00:15:28.366 --> 00:15:30.406 A:middle
If you're in an NSDocument
based app,

00:15:30.526 --> 00:15:31.466 A:middle
there's nothing for you to do.

00:15:31.516 --> 00:15:34.966 A:middle
This is fully automatic and,
in fact, in TextEdit here,

00:15:34.966 --> 00:15:38.206 A:middle
we made exactly zero lines
of code changes in TextEdit.

00:15:38.446 --> 00:15:41.426 A:middle
It fully supports tabs and it
just works right out the box.

00:15:42.596 --> 00:15:46.106 A:middle
If you're a non-NSDocument
based app, it's mostly automatic

00:15:46.106 --> 00:15:48.366 A:middle
but what you'll probably
need to do is enable

00:15:48.366 --> 00:15:51.776 A:middle
to New Tab button
in your application.

00:15:52.236 --> 00:15:54.816 A:middle
The New Tab button is
this plus button over here

00:15:55.056 --> 00:15:56.216 A:middle
to the right of all the tabs.

00:15:57.546 --> 00:15:59.096 A:middle
To enable that button, you need

00:15:59.096 --> 00:16:02.266 A:middle
to implement this
newWindowForTab NSResponder

00:15:59.096 --> 00:16:02.266 A:middle
to implement this
newWindowForTab NSResponder

00:16:02.266 --> 00:16:05.856 A:middle
override in your NSWindow
subclass or somewhere higher

00:16:05.856 --> 00:16:06.746 A:middle
up the responder chain.

00:16:06.816 --> 00:16:08.786 A:middle
For example, your
NSWindow delegate

00:16:09.136 --> 00:16:12.176 A:middle
or your NSWindow controller
or your NSWindow document.

00:16:12.306 --> 00:16:14.986 A:middle
If you implement this override
in any one of those places,

00:16:14.986 --> 00:16:17.066 A:middle
AppKit will see it
and will go ahead

00:16:17.066 --> 00:16:19.506 A:middle
and enable the New Tab
button for you automatically.

00:16:20.146 --> 00:16:24.756 A:middle
If you have your own
existing tab implementation,

00:16:25.046 --> 00:16:25.736 A:middle
then you probably want

00:16:25.736 --> 00:16:28.746 A:middle
to disable AppKit's automatic
window tabbing behavior.

00:16:29.626 --> 00:16:30.986 A:middle
There's this class property

00:16:30.986 --> 00:16:33.296 A:middle
on NSWindow
allowsAutomaticWindowTabbing.

00:16:34.196 --> 00:16:36.556 A:middle
This is a class property
early in the bring-up

00:16:36.556 --> 00:16:38.106 A:middle
of your application
called NSWindow.

00:16:38.106 --> 00:16:42.026 A:middle
allowsAutomaticWindowTabbing
equal false

00:16:42.196 --> 00:16:44.586 A:middle
and this will turn off
AppKit's tabbing behavior

00:16:44.896 --> 00:16:48.006 A:middle
and then you can continue using
your own tabbing implementation.

00:16:48.416 --> 00:16:50.646 A:middle
It's important that you call
this early in the bring-up

00:16:50.646 --> 00:16:55.116 A:middle
of your application before you
start ordering windows front.

00:16:56.126 --> 00:16:57.576 A:middle
That's all you really need to do

00:16:57.576 --> 00:16:59.666 A:middle
to adopt tabs in
your application.

00:16:59.666 --> 00:17:00.776 A:middle
It works mostly automatically.

00:16:59.666 --> 00:17:00.776 A:middle
It works mostly automatically.

00:17:00.776 --> 00:17:03.516 A:middle
But here's some of the API that
you can use to customize things.

00:17:04.146 --> 00:17:07.205 A:middle
First off, the user can
define some of the behavior

00:17:07.205 --> 00:17:10.086 A:middle
on how they want tabbing
to work on their system

00:17:10.215 --> 00:17:11.915 A:middle
and they can do this in
the System Preferences

00:17:11.915 --> 00:17:13.906 A:middle
and you can find out what
the user preference is

00:17:13.935 --> 00:17:17.826 A:middle
by the class property user
tabbing preferences on NSWindow

00:17:17.886 --> 00:17:21.445 A:middle
and they can set it to manual,
always or to only do tabbing

00:17:21.445 --> 00:17:23.165 A:middle
when they're in full screen.

00:17:25.056 --> 00:17:27.146 A:middle
The rest of these properties
and functions from here

00:17:27.146 --> 00:17:29.726 A:middle
on out I'm going to discuss
are instance properties

00:17:29.726 --> 00:17:30.896 A:middle
and functions on NSWindow.

00:17:31.626 --> 00:17:33.836 A:middle
So once you have an
instance of an NSWindow,

00:17:34.066 --> 00:17:35.346 A:middle
you can set it to tabbing mode.

00:17:35.776 --> 00:17:37.666 A:middle
By default, this tabbing
mode is automatic,

00:17:37.666 --> 00:17:38.506 A:middle
which means we're just going

00:17:38.506 --> 00:17:40.546 A:middle
to follow what the user
tabbing preferences are,

00:17:40.546 --> 00:17:43.396 A:middle
but you can set it to
preferred or disallowed,

00:17:43.396 --> 00:17:44.996 A:middle
depending on your window
type and your needs.

00:17:45.876 --> 00:17:50.516 A:middle
When we group windows together
into a set of tabs, we only want

00:17:50.516 --> 00:17:52.796 A:middle
to group windows that are
similar and the way we do

00:17:52.796 --> 00:17:54.676 A:middle
that is by looking at
the tabbing identifier.

00:17:54.956 --> 00:17:57.266 A:middle
So windows that have the same
tabbing identifier can be

00:17:57.266 --> 00:17:58.596 A:middle
grouped together into tabs.

00:17:59.296 --> 00:18:01.926 A:middle
By default, AppKit will use
a heuristic and try and come

00:17:59.296 --> 00:18:01.926 A:middle
By default, AppKit will use
a heuristic and try and come

00:18:01.926 --> 00:18:03.816 A:middle
up with a tabbing
identifier on your behalf.

00:18:04.106 --> 00:18:07.436 A:middle
We look at things such as
the windows subclass name,

00:18:07.806 --> 00:18:11.046 A:middle
the properties of the
window, the document,

00:18:11.046 --> 00:18:13.336 A:middle
and various few other
properties to try and come

00:18:13.336 --> 00:18:15.906 A:middle
up with the appropriate
tabbing identifier.

00:18:16.516 --> 00:18:17.576 A:middle
This works really well,

00:18:17.986 --> 00:18:20.606 A:middle
but if it doesn't quite work
well enough for your application

00:18:20.606 --> 00:18:23.696 A:middle
or if you want to have
more control over it,

00:18:23.696 --> 00:18:25.596 A:middle
you can set the tabbing
identifier manually

00:18:25.826 --> 00:18:27.346 A:middle
and AppKit will respect that.

00:18:28.556 --> 00:18:31.086 A:middle
You can find out what are the
windows are grouped together

00:18:31.086 --> 00:18:34.386 A:middle
with some instance of a
window together in tabs

00:18:34.386 --> 00:18:35.896 A:middle
by asking for the tab windows.

00:18:36.506 --> 00:18:38.586 A:middle
Note this returns
an optional array.

00:18:38.976 --> 00:18:41.326 A:middle
It can return nil and
it will return nil

00:18:41.326 --> 00:18:42.736 A:middle
if the tab bar isn't even shown

00:18:42.736 --> 00:18:44.946 A:middle
and there are no tabs
associated at all.

00:18:46.106 --> 00:18:50.516 A:middle
And you can manually add
another tab window together

00:18:50.516 --> 00:18:51.116 A:middle
to the group.

00:18:51.236 --> 00:18:53.836 A:middle
Since these are just windows
that explains the API name

00:18:53.836 --> 00:18:56.746 A:middle
where you add a tab window,
instead of adding a tab itself,

00:18:56.746 --> 00:18:58.946 A:middle
you add the tab window
and you order it using

00:18:58.946 --> 00:19:01.456 A:middle
NSWindowOrderingMode and
that will order the tab

00:18:58.946 --> 00:19:01.456 A:middle
NSWindowOrderingMode and
that will order the tab

00:19:01.916 --> 00:19:03.316 A:middle
in relation to the other tabs.

00:19:05.446 --> 00:19:08.686 A:middle
AppKit will add a few
new items to your menu.

00:19:09.136 --> 00:19:12.306 A:middle
Namely in the windows menu,
we add some items to go ahead

00:19:12.306 --> 00:19:15.016 A:middle
and help the user
navigate the tabs,

00:19:15.196 --> 00:19:17.216 A:middle
such as selecting the
next or previous tab.

00:19:17.696 --> 00:19:20.876 A:middle
These are just IB actions on
NSWindow and you can wire them

00:19:20.876 --> 00:19:23.266 A:middle
up to your own user
interface items as well.

00:19:23.266 --> 00:19:25.396 A:middle
For example, you might
want to have a button

00:19:25.396 --> 00:19:26.576 A:middle
that toggles the tab bar.

00:19:26.876 --> 00:19:28.866 A:middle
You just wire that
button up to the window,

00:19:30.196 --> 00:19:31.986 A:middle
toggleTabBar IBAction

00:19:32.556 --> 00:19:35.766 A:middle
and NSWindow will handle
toggling the tab bar for you.

00:19:36.896 --> 00:19:39.606 A:middle
So that's everything about
window snapping and tabbing.

00:19:40.196 --> 00:19:42.926 A:middle
Let's move ahead and talk
about right-to-left support.

00:19:42.926 --> 00:19:44.656 A:middle
We've done a lot
of work in AppKit

00:19:44.656 --> 00:19:47.156 A:middle
to enhance our already
existing right-to-left support.

00:19:47.766 --> 00:19:50.956 A:middle
In the screenshot you can
see here's TextEdit running

00:19:50.956 --> 00:19:51.516 A:middle
in Arabic.

00:19:51.956 --> 00:19:54.166 A:middle
The title bar is flipped.

00:19:54.386 --> 00:19:56.336 A:middle
The scrollers are
flipped to the other side.

00:19:56.336 --> 00:19:58.156 A:middle
Even the new tab button is
flipped to the other side.

00:19:58.416 --> 00:20:00.016 A:middle
And all the little attributes

00:19:58.416 --> 00:20:00.016 A:middle
And all the little attributes

00:20:00.016 --> 00:20:02.176 A:middle
and the various title bar
buttons are all flipped

00:20:02.176 --> 00:20:04.586 A:middle
appropriately as a
right-to-left user would expect.

00:20:06.046 --> 00:20:08.146 A:middle
I want to talk about
right-to-left support

00:20:08.146 --> 00:20:09.166 A:middle
at three different levels.

00:20:09.476 --> 00:20:10.926 A:middle
What's going on at
the system level,

00:20:10.926 --> 00:20:13.166 A:middle
where the user sets
their localization

00:20:13.166 --> 00:20:14.286 A:middle
in the system preference pane,

00:20:15.196 --> 00:20:17.266 A:middle
how that impacts your
application, and what goes

00:20:17.266 --> 00:20:18.486 A:middle
on in your application depending

00:20:18.486 --> 00:20:20.306 A:middle
on the localizations
that you support.

00:20:20.836 --> 00:20:22.536 A:middle
And then finally down
to the content level,

00:20:22.536 --> 00:20:23.916 A:middle
which is at the NSView level

00:20:24.256 --> 00:20:26.666 A:middle
where you can override
things further if needed

00:20:26.666 --> 00:20:28.326 A:middle
with the user interface
layout direction.

00:20:28.906 --> 00:20:30.566 A:middle
And then I'm going
wrap this whole section

00:20:30.566 --> 00:20:33.696 A:middle
up with a really nice
development tip to help you work

00:20:34.006 --> 00:20:36.376 A:middle
on right-to-left support
in your application.

00:20:37.576 --> 00:20:39.886 A:middle
To start off with, let's
talk about the system level.

00:20:41.206 --> 00:20:42.916 A:middle
The key here is consistency.

00:20:43.156 --> 00:20:45.356 A:middle
We want to have a
consistent appearance

00:20:45.356 --> 00:20:47.466 A:middle
to the user who's running
in a right-to-left system.

00:20:47.986 --> 00:20:51.056 A:middle
So regardless of what
localization you may support

00:20:51.056 --> 00:20:53.866 A:middle
in your application,
we want all menu bars

00:20:54.136 --> 00:20:57.746 A:middle
on a right-to-left system
to start off with the apple

00:20:57.746 --> 00:21:00.276 A:middle
over here on the right
side followed with the rest

00:20:57.746 --> 00:21:00.276 A:middle
over here on the right
side followed with the rest

00:21:00.276 --> 00:21:03.716 A:middle
of the menu items
and this likewise

00:21:03.716 --> 00:21:05.076 A:middle
for the windows title bar.

00:21:06.076 --> 00:21:07.556 A:middle
So the traffic lights
are going to be flipped

00:21:07.556 --> 00:21:09.126 A:middle
over to the other side
and anything that's not

00:21:09.126 --> 00:21:10.446 A:middle
in the content area
is going to be flipped

00:21:10.446 --> 00:21:11.336 A:middle
over to the other side,

00:21:11.746 --> 00:21:14.076 A:middle
regardless of what localization
you have in your application,

00:21:14.296 --> 00:21:16.526 A:middle
providing a consistent
experience to the user.

00:21:17.376 --> 00:21:18.896 A:middle
Now we can't automatically
do this

00:21:18.896 --> 00:21:22.166 A:middle
down into the application
level, because we don't want

00:21:22.166 --> 00:21:23.006 A:middle
to break any assumptions

00:21:23.006 --> 00:21:24.356 A:middle
that your application
might be having.

00:21:24.846 --> 00:21:28.616 A:middle
So it's highly recommended that
you add right-to-left support

00:21:28.616 --> 00:21:31.996 A:middle
in your application, add Hebrew
and Arabic localizations.

00:21:32.646 --> 00:21:35.896 A:middle
And once you have those
localizations in place

00:21:36.316 --> 00:21:37.826 A:middle
at an application level,

00:21:37.826 --> 00:21:40.196 A:middle
all your scroll views will
automatically flip the vertical

00:21:40.196 --> 00:21:41.196 A:middle
scroller and rulers

00:21:41.456 --> 00:21:43.736 A:middle
and NSBrowser will automatically
be flipped as well.

00:21:44.096 --> 00:21:47.116 A:middle
At this level, again we want
consistency so regardless

00:21:47.116 --> 00:21:50.816 A:middle
of what content views user
interface layout direction may

00:21:50.816 --> 00:21:53.576 A:middle
be, we want the scroll
bars to always be

00:21:53.576 --> 00:21:55.686 A:middle
on the same side
for consistency.

00:21:55.686 --> 00:21:58.766 A:middle
Moving down to the
content level,

00:21:59.286 --> 00:22:01.366 A:middle
by default the user interface
layout direction is going

00:21:59.286 --> 00:22:01.366 A:middle
by default the user interface
layout direction is going

00:22:01.366 --> 00:22:04.116 A:middle
to match what your
application is set to.

00:22:05.416 --> 00:22:08.616 A:middle
This is exactly what you
want for almost all cases

00:22:08.616 --> 00:22:10.986 A:middle
but there are a few exceptions,
namely if you have something

00:22:10.986 --> 00:22:15.126 A:middle
like media controls or spatial
controls or time controls

00:22:15.126 --> 00:22:19.696 A:middle
where it is always laid out
the same way left to right

00:22:19.696 --> 00:22:22.396 A:middle
for both left-to-right users
and right-to-left users.

00:22:23.086 --> 00:22:25.836 A:middle
So you can modify the user
interface layout direction.

00:22:26.556 --> 00:22:29.016 A:middle
And the following controls
in AppKit support that.

00:22:29.406 --> 00:22:31.986 A:middle
So auto layout will
not in this seed

00:22:31.986 --> 00:22:37.516 A:middle
but in the upcoming seed two
we'll start using the parent

00:22:37.686 --> 00:22:44.776 A:middle
container to determine what is
the trailing and leading edges.

00:22:46.036 --> 00:22:47.656 A:middle
And already in the
seed, table view

00:22:47.656 --> 00:22:50.246 A:middle
and outline view will flip
their columns appropriately.

00:22:50.246 --> 00:22:54.746 A:middle
NSPageController switches its
animations and the list goes on.

00:22:54.746 --> 00:22:57.996 A:middle
We have a lot of support in
AppKit for right-to-left.

00:22:57.996 --> 00:23:00.016 A:middle
Let AppKit do the heavy
lifting where you can

00:22:57.996 --> 00:23:00.016 A:middle
Let AppKit do the heavy
lifting where you can

00:23:00.476 --> 00:23:04.486 A:middle
and provide your right-to-left
users a great experience.

00:23:05.086 --> 00:23:08.596 A:middle
I promised you a
development tip.

00:23:08.596 --> 00:23:10.076 A:middle
I've been using this
tip all year.

00:23:10.156 --> 00:23:11.876 A:middle
I found it incredibly useful.

00:23:12.246 --> 00:23:14.786 A:middle
In Xcode, you can modify
the scheme of your projects

00:23:14.986 --> 00:23:17.606 A:middle
in the Options section, change
your application language

00:23:17.606 --> 00:23:19.046 A:middle
to right-to-left pseudolanguage.

00:23:19.626 --> 00:23:21.526 A:middle
This allows you to
run your application

00:23:21.526 --> 00:23:24.086 A:middle
in your development language,
and for me that's English,

00:23:24.436 --> 00:23:26.216 A:middle
and so you can see
TextEdit running in English,

00:23:26.706 --> 00:23:30.916 A:middle
but it is all using
right-to-left flipped controls

00:23:30.916 --> 00:23:31.116 A:middle
in it.

00:23:31.336 --> 00:23:34.326 A:middle
So the window title
bar is flipped.

00:23:34.576 --> 00:23:36.386 A:middle
The scroller for the
scroll view is flipped

00:23:36.486 --> 00:23:39.386 A:middle
and you can see all the little
subitems and all the buttons

00:23:39.386 --> 00:23:40.356 A:middle
of the title bar are flipped.

00:23:40.536 --> 00:23:44.066 A:middle
So it's a much easier
way for you to work

00:23:44.066 --> 00:23:44.936 A:middle
on right-to-left support

00:23:44.936 --> 00:23:46.646 A:middle
and make sure everything
is working properly

00:23:46.886 --> 00:23:47.856 A:middle
in your native language.

00:23:48.596 --> 00:23:52.076 A:middle
Now I've just covered what
we're doing in AppKit here.

00:23:53.126 --> 00:23:55.966 A:middle
There's a lot more to
talk about in the What New

00:23:55.966 --> 00:23:58.626 A:middle
in International User Interfaces
talk in Nob Hill on Friday

00:23:58.626 --> 00:24:01.326 A:middle
at 9:00 a.m. They cover
more things on the desktop

00:23:58.626 --> 00:24:01.326 A:middle
at 9:00 a.m. They cover
more things on the desktop

00:24:01.326 --> 00:24:06.096 A:middle
such as WebKit, text
layout, asset management,

00:24:06.096 --> 00:24:09.056 A:middle
and they also cover
right-to-left support in iOS.

00:24:09.056 --> 00:24:11.176 A:middle
So I highly recommend that you
check out this talk as well.

00:24:14.176 --> 00:24:15.936 A:middle
Let's now talk about
promise drags.

00:24:16.296 --> 00:24:18.336 A:middle
If you're not familiar,
a promise drag is

00:24:18.336 --> 00:24:21.376 A:middle
when the user is dragging a
file from your application

00:24:22.306 --> 00:24:25.826 A:middle
but you don't have this
file on disc anywhere yet.

00:24:26.216 --> 00:24:27.436 A:middle
But you're just going to promise

00:24:27.436 --> 00:24:29.496 A:middle
that you'll write it wherever
the user wants to drop it.

00:24:29.966 --> 00:24:31.086 A:middle
That's a file promise drag.

00:24:31.086 --> 00:24:32.756 A:middle
We've supported file
promise drags

00:24:33.186 --> 00:24:34.616 A:middle
in OS X since the beginning.

00:24:35.876 --> 00:24:38.746 A:middle
In macOS Sierra, we're
updating our file promise drag

00:24:38.806 --> 00:24:41.976 A:middle
to be more modern with the
new NSFilePromiseProvider

00:24:41.976 --> 00:24:44.226 A:middle
and NSFilePromiseReciever
objects.

00:24:45.006 --> 00:24:47.456 A:middle
Now these objects allow
file promise drags

00:24:47.456 --> 00:24:48.826 A:middle
to support drag flocking.

00:24:49.256 --> 00:24:50.596 A:middle
If you're not familiar
with drag flocking,

00:24:50.596 --> 00:24:52.136 A:middle
it's when you're
dragging number of items

00:24:52.386 --> 00:24:54.466 A:middle
and they can change
their formation mid-drag,

00:24:54.466 --> 00:24:56.606 A:middle
depending on the
destination application

00:24:56.606 --> 00:24:57.466 A:middle
and what's going on there.

00:24:59.376 --> 00:25:02.316 A:middle
So file promise drags with
these two new classes support

00:24:59.376 --> 00:25:02.316 A:middle
So file promise drags with
these two new classes support

00:25:02.486 --> 00:25:03.216 A:middle
drag flocking.

00:25:03.286 --> 00:25:04.246 A:middle
They're UTI based.

00:25:04.596 --> 00:25:07.086 A:middle
They're completely pasteboard
writer and reader compliant,

00:25:07.086 --> 00:25:10.916 A:middle
which means you can use the
item-based API on NSPasteboard

00:25:10.916 --> 00:25:12.476 A:middle
to work with these objects,

00:25:13.366 --> 00:25:15.096 A:middle
and they're file
coordinated when possible.

00:25:15.096 --> 00:25:16.976 A:middle
So you don't need to worry
about file coordination.

00:25:16.976 --> 00:25:19.366 A:middle
We'll automatically wrap
up a file coordinated read

00:25:19.366 --> 00:25:21.526 A:middle
or write on your behalf.

00:25:21.776 --> 00:25:23.376 A:middle
And they're backwards
compatible.

00:25:24.226 --> 00:25:25.036 A:middle
They're backwards compatible

00:25:25.036 --> 00:25:27.696 A:middle
with the non-item
based file promise API.

00:25:28.426 --> 00:25:30.846 A:middle
And what this means is you only
need to worry about one API.

00:25:31.276 --> 00:25:33.776 A:middle
If you implement an
NSFilePromiseProvider,

00:25:33.826 --> 00:25:35.376 A:middle
you can now provide
a file promise

00:25:35.646 --> 00:25:38.996 A:middle
to anybody that's using the
new NSFilePromiseReciever API

00:25:39.516 --> 00:25:42.206 A:middle
or somebody that an existing
application that's using the

00:25:42.206 --> 00:25:43.286 A:middle
non-item-based API.

00:25:43.736 --> 00:25:45.686 A:middle
They will still be able to
accept your promised file

00:25:46.106 --> 00:25:49.336 A:middle
and likewise with
NSFilePromiseReciever.

00:25:49.386 --> 00:25:51.356 A:middle
You will be able to
accept file promises

00:25:51.386 --> 00:25:54.396 A:middle
from anybody using an
NSFilePromiseProvider

00:25:54.586 --> 00:25:56.926 A:middle
or using the non-item-based
API as well.

00:25:57.906 --> 00:26:03.646 A:middle
So you want to provide a
file promise in your drag,

00:25:57.906 --> 00:26:03.646 A:middle
So you want to provide a
file promise in your drag,

00:26:03.646 --> 00:26:06.016 A:middle
so as the user starts to drag,
you need to create your promises

00:26:06.306 --> 00:26:08.246 A:middle
and you do that by
creating an instance

00:26:08.246 --> 00:26:09.746 A:middle
of NSFilePromiseProvider.

00:26:10.096 --> 00:26:13.306 A:middle
You want to create an instance
for each one of the files

00:26:13.306 --> 00:26:15.116 A:middle
that you are going to
promise and you need

00:26:15.116 --> 00:26:17.266 A:middle
to provide an
NSFilePromiseProvider delegate.

00:26:17.706 --> 00:26:19.696 A:middle
This delegate is what's
going to do the heavy lifting

00:26:19.696 --> 00:26:21.226 A:middle
of writing the files to disc.

00:26:22.066 --> 00:26:24.646 A:middle
At some point the destination
is going to call in this promise

00:26:24.776 --> 00:26:26.846 A:middle
and you'll be asked to
provide the file name

00:26:26.846 --> 00:26:27.676 A:middle
for the destination.

00:26:27.676 --> 00:26:29.386 A:middle
Now you know where the
destination is, you can figure

00:26:29.386 --> 00:26:31.836 A:middle
out the appropriate file name,
but do not write the file

00:26:31.836 --> 00:26:33.376 A:middle
at this point because
it's not wrapped

00:26:33.376 --> 00:26:35.736 A:middle
up with file coordination
yet and we're still figuring

00:26:35.736 --> 00:26:37.636 A:middle
out some of the remaining
items of the drag.

00:26:38.316 --> 00:26:39.256 A:middle
When the drag is completed

00:26:39.256 --> 00:26:40.826 A:middle
and we know all the
information we need to know,

00:26:40.826 --> 00:26:43.386 A:middle
we'll call your delegate back
and ask you to write the promise

00:26:43.386 --> 00:26:46.436 A:middle
to URL and provide a
completion handler.

00:26:46.436 --> 00:26:50.606 A:middle
At this point, it's all wrapped
up with file coordination write.

00:26:51.046 --> 00:26:53.526 A:middle
So just write the file
out to the supplied URL

00:26:53.526 --> 00:26:56.056 A:middle
and call the completion handler
to let file coordination know

00:26:56.056 --> 00:26:56.906 A:middle
that you're finished writing.

00:26:58.136 --> 00:27:00.606 A:middle
If you want to receive
a file promise,

00:26:58.136 --> 00:27:00.606 A:middle
If you want to receive
a file promise,

00:27:00.916 --> 00:27:02.806 A:middle
the first thing you need to
do is register with the view

00:27:02.806 --> 00:27:04.736 A:middle
that you want to allow
the job to occur on.

00:27:04.736 --> 00:27:07.746 A:middle
And this is normally done with
view.register forDraggedTypes

00:27:08.016 --> 00:27:08.856 A:middle
and the drag types you need

00:27:08.856 --> 00:27:11.366 A:middle
to add are the
NSFilePromiseReceiver.

00:27:11.366 --> 00:27:12.526 A:middle
readableDrappedTypes.

00:27:12.636 --> 00:27:13.996 A:middle
It's fairly straightforward.

00:27:15.156 --> 00:27:17.926 A:middle
Now once the user is dragging
a file promise over that view,

00:27:17.926 --> 00:27:19.786 A:middle
you'll start getting dragging
messages and you'll want

00:27:19.786 --> 00:27:21.376 A:middle
to get the promise objects.

00:27:22.346 --> 00:27:26.186 A:middle
So you can use the pasteboard
item-based API and just ask it

00:27:26.186 --> 00:27:29.626 A:middle
to read the objects forClasses
NSFilePromiseReceiver.self

00:27:29.626 --> 00:27:32.386 A:middle
and you'll get an array of
NSFilePromiseReceiver objects.

00:27:33.436 --> 00:27:35.456 A:middle
Once you have an
NSFilePromiseReceiver object,

00:27:35.806 --> 00:27:37.006 A:middle
you can call in the promise

00:27:37.236 --> 00:27:40.316 A:middle
by calling receivePromisedFiles
atDestination options

00:27:40.406 --> 00:27:41.396 A:middle
operationQueue reader.

00:27:41.396 --> 00:27:44.426 A:middle
And it will return pretty
quickly from this function

00:27:44.626 --> 00:27:46.496 A:middle
and your reader block will
not have been called yet.

00:27:46.496 --> 00:27:47.736 A:middle
We're going to call
that back later.

00:27:48.976 --> 00:27:51.036 A:middle
Once the source file has
finished writing all the

00:27:51.036 --> 00:27:54.466 A:middle
promises, now we go ahead and
we call your reader block back

00:27:54.466 --> 00:27:56.356 A:middle
on the operation queue
that you specified.

00:27:56.986 --> 00:28:01.786 A:middle
Now it's important that you do
not specify NSMainOperationQueue

00:27:56.986 --> 00:28:01.786 A:middle
Now it's important that you do
not specify NSMainOperationQueue

00:28:01.786 --> 00:28:03.696 A:middle
for the operation queue
or else you're going

00:28:03.696 --> 00:28:07.596 A:middle
to block your application while
waiting for the source process

00:28:07.696 --> 00:28:08.706 A:middle
to finish writing the files.

00:28:08.896 --> 00:28:10.626 A:middle
And this can take some
time and you don't want

00:28:10.626 --> 00:28:12.436 A:middle
to block your application
during that whole time.

00:28:14.916 --> 00:28:18.256 A:middle
And that's all there is to
do with file promise drags.

00:28:18.296 --> 00:28:22.356 A:middle
It's much simpler API to use
and it works with drag flocking

00:28:22.356 --> 00:28:24.776 A:middle
and supports the item-based
API with pasteboard.

00:28:25.556 --> 00:28:27.876 A:middle
So let's move on and talk
about some improvements we made

00:28:27.876 --> 00:28:29.256 A:middle
to our various container views.

00:28:29.576 --> 00:28:30.926 A:middle
We'll start off with
collection view.

00:28:31.896 --> 00:28:34.796 A:middle
With collection view, previously
when you would scroll,

00:28:35.266 --> 00:28:38.526 A:middle
your contents would scroll
on top of any background view

00:28:38.526 --> 00:28:39.346 A:middle
that you might've had.

00:28:39.686 --> 00:28:41.476 A:middle
Well, now you can tell the
background view to scroll

00:28:41.476 --> 00:28:43.276 A:middle
with your contexts by
setting backgroundViews

00:28:43.276 --> 00:28:45.936 A:middle
ScrollsWithContent to true
and they scroll together.

00:28:47.126 --> 00:28:48.056 A:middle
We also have support

00:28:48.056 --> 00:28:50.276 A:middle
for optional floating
headers and footers.

00:28:50.276 --> 00:28:52.796 A:middle
So you can see the documents
header here becomes floating

00:28:52.796 --> 00:28:54.296 A:middle
and the content scrolls
underneath it.

00:28:56.036 --> 00:28:58.826 A:middle
This is real easy to do with the
NSCollectionView float layout.

00:28:59.106 --> 00:29:01.256 A:middle
Just set the
sectionHeadersPinToVisible true

00:28:59.106 --> 00:29:01.256 A:middle
Just set the
sectionHeadersPinToVisible true

00:29:01.256 --> 00:29:04.206 A:middle
or the
sectionFootersPinToVisibleBounds

00:29:04.206 --> 00:29:05.876 A:middle
true if you want
the footers to float

00:29:06.166 --> 00:29:07.796 A:middle
and NSCollectionView
will then take care

00:29:07.796 --> 00:29:09.996 A:middle
of doing everything
appropriately on your behalf.

00:29:11.236 --> 00:29:13.526 A:middle
You can also optionally
collapse any section

00:29:13.916 --> 00:29:16.176 A:middle
into a single horizontally
scrollable row,

00:29:16.176 --> 00:29:19.106 A:middle
as you can see here, and you get
this nice little carousel effect

00:29:19.106 --> 00:29:20.416 A:middle
whenever you scroll
horizontally.

00:29:21.346 --> 00:29:25.816 A:middle
This is real easy to do with the
toggleSectionCollapse IBAction

00:29:25.906 --> 00:29:27.116 A:middle
on NSCollectionView.

00:29:27.726 --> 00:29:31.976 A:middle
Now the sender of this message
needs to be a view that is

00:29:31.976 --> 00:29:34.206 A:middle
at your section header
or a descendent

00:29:34.206 --> 00:29:35.246 A:middle
of your section header view

00:29:35.516 --> 00:29:38.616 A:middle
and that is how NSCollectionView
can determine exactly

00:29:38.616 --> 00:29:41.226 A:middle
which section needs to toggle
the collapse state for.

00:29:42.556 --> 00:29:47.246 A:middle
Since you have your button in
your header view or descendent,

00:29:47.676 --> 00:29:49.466 A:middle
you should have your
section header

00:29:49.616 --> 00:29:51.056 A:middle
implement NSCollectionView

00:29:51.056 --> 00:29:53.956 A:middle
SectionHeaderView protocol
and that's just to wire

00:29:53.956 --> 00:29:56.646 A:middle
up your button to the
sectionCollapseButton outlet.

00:29:57.206 --> 00:29:59.596 A:middle
Then NSCollectionView will now
be able to find your button

00:29:59.596 --> 00:30:01.056 A:middle
and automatically
hide and show it,

00:29:59.596 --> 00:30:01.056 A:middle
and automatically
hide and show it,

00:30:01.276 --> 00:30:05.206 A:middle
depending on if there
is enough data inside

00:30:05.206 --> 00:30:08.686 A:middle
that section to collapse.

00:30:09.046 --> 00:30:11.786 A:middle
NSTableView will now
reload full width cells

00:30:12.336 --> 00:30:13.976 A:middle
when the column index
is negative 1.

00:30:13.976 --> 00:30:17.326 A:middle
Negative 1 is our magic
number to say a column

00:30:17.746 --> 00:30:22.576 A:middle
that expands all the way across
your table, across all columns.

00:30:22.936 --> 00:30:24.096 A:middle
So when you call reloadData

00:30:24.096 --> 00:30:26.386 A:middle
and columnIndexes includes
the negative 1 in there,

00:30:26.386 --> 00:30:27.786 A:middle
we will automatically reload

00:30:27.786 --> 00:30:29.496 A:middle
that full width cell
on your behalf.

00:30:29.976 --> 00:30:33.666 A:middle
This only works for 10.12 and
later linked applications.

00:30:34.606 --> 00:30:37.186 A:middle
Likewise on 10.12 linked
applications or later,

00:30:37.186 --> 00:30:40.546 A:middle
NSOutlineView will also
automatically reload its cell

00:30:40.546 --> 00:30:44.416 A:middle
views associated with the item
you pass in to reload item.

00:30:44.646 --> 00:30:48.526 A:middle
Additionally, OutlineView now
strongly references the items

00:30:48.526 --> 00:30:50.696 A:middle
you return to it
via the data source.

00:30:51.796 --> 00:30:56.736 A:middle
This is really useful but if
your application really wants

00:30:56.736 --> 00:30:59.996 A:middle
to maintain the original
assigned behavior

00:30:59.996 --> 00:31:03.216 A:middle
that we had previously, you
can set stronglyReferencesItems

00:30:59.996 --> 00:31:03.216 A:middle
that we had previously, you
can set stronglyReferencesItems

00:31:03.216 --> 00:31:07.416 A:middle
to false and return to
the pre-10.12 behavior.

00:31:07.986 --> 00:31:13.896 A:middle
And with that, I'd like to bring
up Taylor Kelly to go ahead

00:31:13.896 --> 00:31:15.726 A:middle
and talk to you about
grid views.

00:31:16.516 --> 00:31:22.126 A:middle
[ Applause ]

00:31:22.626 --> 00:31:23.106 A:middle
&gt;&gt; Thanks, Raleigh.

00:31:24.026 --> 00:31:26.636 A:middle
So the first thing I'd like to
tell you about is NSGridView.

00:31:27.166 --> 00:31:30.246 A:middle
This is a new container view
class, similar to NSStackView

00:31:30.276 --> 00:31:31.396 A:middle
where we completely create

00:31:31.396 --> 00:31:33.906 A:middle
and manage the constraints
necessary to build your layout.

00:31:33.966 --> 00:31:37.446 A:middle
But where StackView creates
a linear distribution of use,

00:31:37.706 --> 00:31:40.576 A:middle
NSGridView creates these
intersecting rows and columns.

00:31:41.116 --> 00:31:42.576 A:middle
You very commonly
see this in something

00:31:42.576 --> 00:31:43.536 A:middle
like a preference pane UI.

00:31:43.536 --> 00:31:46.606 A:middle
Right, there are these
distinct columns and rows

00:31:46.606 --> 00:31:48.916 A:middle
of aligned content
that are self-sizing

00:31:49.136 --> 00:31:50.566 A:middle
and pretty statically defined.

00:31:51.376 --> 00:31:55.616 A:middle
It supports alignment such as
baseline, leading, and trailing.

00:31:55.616 --> 00:31:59.686 A:middle
It supports spacing of the
GridView as a whole as well

00:31:59.686 --> 00:32:02.766 A:middle
as its padding on an
individual row and column basis.

00:31:59.686 --> 00:32:02.766 A:middle
as its padding on an
individual row and column basis.

00:32:04.126 --> 00:32:05.496 A:middle
Similar to a spreadsheet
application,

00:32:05.496 --> 00:32:06.646 A:middle
it supports cell merging.

00:32:06.896 --> 00:32:09.116 A:middle
So a single view can
span multiple rows

00:32:09.116 --> 00:32:10.186 A:middle
or multiple columns.

00:32:11.186 --> 00:32:13.786 A:middle
So for instance these
separators do just that.

00:32:15.226 --> 00:32:18.016 A:middle
It also supports dynamic hiding
and showing of rows and columns

00:32:18.126 --> 00:32:19.996 A:middle
without changing the
GridView's own structure.

00:32:20.556 --> 00:32:23.386 A:middle
So for instance, when we click
on this checkbox, we might want

00:32:23.386 --> 00:32:24.926 A:middle
to hide the Display
Preference button.

00:32:25.726 --> 00:32:28.376 A:middle
And we can do that by getting
the row containing that button

00:32:28.376 --> 00:32:30.266 A:middle
and just setting its
hidden property to true.

00:32:30.876 --> 00:32:32.396 A:middle
GridView will take
care of the rest.

00:32:34.066 --> 00:32:35.746 A:middle
There are several other
improvements we've made

00:32:35.746 --> 00:32:36.416 A:middle
to Auto Layout.

00:32:37.126 --> 00:32:40.676 A:middle
One is a cleanup of overall
AppKit layout cycle meaning

00:32:40.676 --> 00:32:42.876 A:middle
that a view no longer needs
to be using auto layout

00:32:42.876 --> 00:32:44.746 A:middle
or layer backing in
order to participate.

00:32:45.496 --> 00:32:47.646 A:middle
Just by setting needsLayout
to true on that view,

00:32:47.936 --> 00:32:50.776 A:middle
during the next display pass
it'll receive a call to layout.

00:32:52.136 --> 00:32:53.086 A:middle
One implication of this is

00:32:53.086 --> 00:32:55.616 A:middle
that layout is no longer
called twice per display pass

00:32:55.616 --> 00:32:59.246 A:middle
for layer-backed views and we
have less implicit dirtying

00:32:59.246 --> 00:33:02.646 A:middle
of that layout and less
layout passes because of that,

00:32:59.246 --> 00:33:02.646 A:middle
of that layout and less
layout passes because of that,

00:33:02.926 --> 00:33:04.206 A:middle
which is great for performance.

00:33:04.676 --> 00:33:06.506 A:middle
But if you notice that
layout isn't getting called

00:33:06.506 --> 00:33:07.696 A:middle
on your view when you expect,

00:33:07.976 --> 00:33:10.166 A:middle
make sure you're explicitly
setting needsLayout.

00:33:11.356 --> 00:33:12.586 A:middle
All of this makes it easier

00:33:12.586 --> 00:33:14.246 A:middle
to do manual layout
of your subviews.

00:33:14.246 --> 00:33:17.276 A:middle
So you can overwrite
layout without calling super

00:33:17.576 --> 00:33:19.086 A:middle
and instead just
calculate the frames

00:33:19.086 --> 00:33:21.326 A:middle
of your subviews,
set them, and return.

00:33:22.626 --> 00:33:24.816 A:middle
You do want to be sure
that you don't dirty

00:33:24.816 --> 00:33:26.386 A:middle
that view's layout
or other views.

00:33:26.736 --> 00:33:29.256 A:middle
This can happen if during a
view's layout it sets its own

00:33:29.256 --> 00:33:30.926 A:middle
frame or the frame
of an ancestor.

00:33:31.396 --> 00:33:32.666 A:middle
This will dirty that
view's layout

00:33:32.666 --> 00:33:36.226 A:middle
and cause an additional
layout pass.

00:33:36.616 --> 00:33:39.836 A:middle
If this continues, this is
what we call a layout loop

00:33:40.326 --> 00:33:41.846 A:middle
and these are pretty
difficult to debug.

00:33:42.316 --> 00:33:44.176 A:middle
So on macOS and iOS,

00:33:44.176 --> 00:33:46.356 A:middle
we've introduced new layout
loop debugging support

00:33:46.356 --> 00:33:49.006 A:middle
so you can better understand
what view is dirtying layout

00:33:49.006 --> 00:33:49.686 A:middle
and why.

00:33:51.266 --> 00:33:54.366 A:middle
There's changes to the layout
constraint API adding anchor

00:33:54.366 --> 00:33:55.846 A:middle
properties so you
know what anchors

00:33:55.846 --> 00:33:57.086 A:middle
that constraint refers to.

00:33:57.646 --> 00:34:00.216 A:middle
These apply even when you're
not using the anchor-based API.

00:33:57.646 --> 00:34:00.216 A:middle
These apply even when you're
not using the anchor-based API.

00:34:02.536 --> 00:34:04.576 A:middle
In addition with that first
time it is now nullable,

00:34:04.576 --> 00:34:05.756 A:middle
so if you are reading
that property,

00:34:05.806 --> 00:34:07.166 A:middle
be sure to handle the nil case.

00:34:08.186 --> 00:34:10.275 A:middle
In addition, Interface
Builder has new support

00:34:10.275 --> 00:34:12.146 A:middle
for incremental adoption
of auto layout.

00:34:12.505 --> 00:34:14.096 A:middle
So within a single
document or even

00:34:14.096 --> 00:34:16.496 A:middle
within a single view hierarchy
you can partially adopt

00:34:16.496 --> 00:34:19.846 A:middle
constants, which
is pretty great.

00:34:19.846 --> 00:34:22.196 A:middle
NSGridView, the layout
loop debugging and more,

00:34:22.196 --> 00:34:24.686 A:middle
is talked about in Friday's,
What's New in Auto Layout talk.

00:34:25.545 --> 00:34:27.946 A:middle
At this point I'd like
to talk about colors,

00:34:27.946 --> 00:34:30.246 A:middle
specifically wide gamut colors.

00:34:30.886 --> 00:34:33.636 A:middle
So sRGB is a pretty
popular color space.

00:34:33.636 --> 00:34:37.856 A:middle
Usually it's the implied color
space of otherwise unspecified

00:34:38.146 --> 00:34:40.676 A:middle
and most of our displays
have an sRGB color gamut.

00:34:41.585 --> 00:34:44.686 A:middle
The new 5K iMac and
iPad Pro 9.7 inch,

00:34:45.025 --> 00:34:46.806 A:middle
both contain these
updated displays

00:34:46.906 --> 00:34:48.815 A:middle
that can display
more vivid colors.

00:34:49.436 --> 00:34:51.966 A:middle
Specifically, they're
using the P3 color gamut

00:34:52.596 --> 00:34:55.166 A:middle
and this is what we call a wide
color gamut because compared

00:34:55.166 --> 00:34:58.656 A:middle
to sRGB, it can display much
more vibrant greens and reds.

00:34:59.536 --> 00:35:02.726 A:middle
So your applications can display
photos much more accurately

00:34:59.536 --> 00:35:02.726 A:middle
So your applications can display
photos much more accurately

00:35:02.726 --> 00:35:05.866 A:middle
to their original color and they
can display these more vibrant

00:35:05.866 --> 00:35:08.086 A:middle
colors to make UI
elements really pop.

00:35:09.046 --> 00:35:11.856 A:middle
An example of such a color
would be this emerald green,

00:35:11.856 --> 00:35:14.946 A:middle
which happens to be Pantone's
2013 color of the year.

00:35:14.946 --> 00:35:18.166 A:middle
It's outside of sRGB.

00:35:18.166 --> 00:35:19.916 A:middle
So previous displays
couldn't represent this

00:35:19.966 --> 00:35:23.236 A:middle
but it is fully representable
using P3.

00:35:24.136 --> 00:35:27.326 A:middle
Your photos also contain
these more vibrant colors,

00:35:27.326 --> 00:35:29.206 A:middle
especially these
reds and oranges.

00:35:29.786 --> 00:35:33.236 A:middle
A note of irony here is that
the projector and even the video

00:35:33.236 --> 00:35:35.686 A:middle
at home are not actually going
to reproduce these colors,

00:35:35.686 --> 00:35:38.636 A:middle
so you'll kind of have to take
my word that they're special.

00:35:40.646 --> 00:35:41.896 A:middle
If you want to work
with these colors,

00:35:41.896 --> 00:35:44.366 A:middle
there's a new color
space displayP3,

00:35:44.506 --> 00:35:45.376 A:middle
which lets you work with this.

00:35:45.376 --> 00:35:47.766 A:middle
This joins sRGB and
other color spaces.

00:35:48.516 --> 00:35:49.696 A:middle
There's also a new constructor

00:35:49.696 --> 00:35:53.786 A:middle
on NSColor displayP3 red green
blue alpha which allows you

00:35:53.786 --> 00:35:55.516 A:middle
to create a color
in that color space.

00:35:55.896 --> 00:35:58.786 A:middle
UIColor has the same constructor
with the same semantics.

00:35:59.846 --> 00:36:02.486 A:middle
Another way of working with wide
colors is using something we're

00:35:59.846 --> 00:36:02.486 A:middle
Another way of working with wide
colors is using something we're

00:36:02.486 --> 00:36:05.086 A:middle
calling extended range sRGB.

00:36:06.516 --> 00:36:08.906 A:middle
And so when working
with a color space,

00:36:08.986 --> 00:36:10.016 A:middle
you're typically constrained

00:36:10.016 --> 00:36:11.976 A:middle
with component values
from 0 to 1.

00:36:12.496 --> 00:36:14.446 A:middle
And you can pick any color
within that color gamut,

00:36:14.446 --> 00:36:16.796 A:middle
such as this blue,
with those values.

00:36:17.356 --> 00:36:19.276 A:middle
But you can't represent
a color that's outside

00:36:19.276 --> 00:36:20.076 A:middle
of that color gamut.

00:36:20.286 --> 00:36:22.576 A:middle
So sRGB cannot represent
this green color.

00:36:23.676 --> 00:36:26.526 A:middle
Well extended range sRGB
uses the same color primaries

00:36:26.526 --> 00:36:29.566 A:middle
and the same white point as
sRGB but allows the components

00:36:29.566 --> 00:36:32.156 A:middle
to take on values less
than 0 or greater than 1.

00:36:32.856 --> 00:36:35.466 A:middle
So it can represent this
green with a negative red

00:36:35.466 --> 00:36:38.066 A:middle
and blue value and a
greater than 1 green value.

00:36:39.166 --> 00:36:42.246 A:middle
It happens to also be the P3
green primary, so you can see

00:36:42.246 --> 00:36:45.266 A:middle
that with extended range sRGB,
you can represent the full range

00:36:45.266 --> 00:36:47.296 A:middle
of colors necessary
for these displays.

00:36:48.646 --> 00:36:51.396 A:middle
This also has a color
space extendedSRGB

00:36:51.976 --> 00:36:53.546 A:middle
and the existing NSColor

00:36:53.546 --> 00:36:55.726 A:middle
and UIColor constructors
you're already using

00:36:55.896 --> 00:36:58.036 A:middle
that previously gave
you colors using sRGB.

00:36:58.326 --> 00:37:01.446 A:middle
Will now accept values less
than 0 or greater than 1

00:36:58.326 --> 00:37:01.446 A:middle
Will now accept values less
than 0 or greater than 1

00:37:01.446 --> 00:37:04.006 A:middle
and give you back an
extended range sRGB color,

00:37:04.506 --> 00:37:05.326 A:middle
which is pretty convenient.

00:37:07.566 --> 00:37:08.816 A:middle
One important thing to consider

00:37:08.816 --> 00:37:11.376 A:middle
with these wider color
gamuts is color depth.

00:37:12.236 --> 00:37:14.636 A:middle
So sRGB can theoretically
represent any color

00:37:14.636 --> 00:37:17.316 A:middle
within its gamut, but
with 8 bits per component,

00:37:17.316 --> 00:37:20.426 A:middle
you can only address a finite
number of those, right.

00:37:20.566 --> 00:37:23.286 A:middle
The black space here are simply
un-addressable colors using

00:37:23.286 --> 00:37:24.436 A:middle
those 8 bits per component.

00:37:25.826 --> 00:37:28.606 A:middle
When you widen the color gamut,
right, increase the volume

00:37:28.606 --> 00:37:30.756 A:middle
of that gamut but keep
the same bit depth,

00:37:31.246 --> 00:37:33.616 A:middle
you're addressable
color density goes down.

00:37:34.206 --> 00:37:37.436 A:middle
Your ability to specify
a color loses precision.

00:37:37.436 --> 00:37:39.776 A:middle
So this is why we
recommend when working

00:37:39.776 --> 00:37:41.876 A:middle
with these wider color
spaces, such as P3,

00:37:41.876 --> 00:37:45.256 A:middle
that you use 16 bits
per component instead.

00:37:46.326 --> 00:37:48.276 A:middle
It doubles the amount
of memory and storage

00:37:48.276 --> 00:37:50.936 A:middle
but gives you exponentially
more addressable colors.

00:37:50.936 --> 00:37:52.696 A:middle
So we think that
tradeoff is worth it.

00:37:54.466 --> 00:37:56.236 A:middle
What API do you need
to use in order

00:37:56.236 --> 00:37:58.036 A:middle
to consider these deeper colors?

00:37:58.516 --> 00:38:00.796 A:middle
Well, the great news is that
most of it is automatic.

00:37:58.516 --> 00:38:00.796 A:middle
Well, the great news is that
most of it is automatic.

00:38:01.086 --> 00:38:04.236 A:middle
So NSWindow will automatically
use deeper backing stores

00:38:04.356 --> 00:38:07.266 A:middle
with these higher bit depths
on wide gamut displays,

00:38:07.486 --> 00:38:09.186 A:middle
even as you drag
it across screens.

00:38:10.086 --> 00:38:12.126 A:middle
If there's a reason you need
to explicitly control that,

00:38:12.126 --> 00:38:13.566 A:middle
you can set the depth
limit property

00:38:13.656 --> 00:38:15.136 A:middle
to some value of your choice.

00:38:16.096 --> 00:38:19.136 A:middle
Views and layers within that
window will automatically

00:38:19.136 --> 00:38:22.286 A:middle
inherit that bit depth with the
exception being OpenGL view.

00:38:22.726 --> 00:38:24.826 A:middle
There you should use the
associated pixel format API.

00:38:26.616 --> 00:38:30.796 A:middle
CALayer on both macOS and iOS
has a new contents format API

00:38:31.136 --> 00:38:32.856 A:middle
property that allows you

00:38:32.856 --> 00:38:35.446 A:middle
to again explicitly control
the bit depth it uses.

00:38:36.336 --> 00:38:37.756 A:middle
So this is how you
can take advantage

00:38:37.756 --> 00:38:39.116 A:middle
of wide color in
your application.

00:38:39.436 --> 00:38:42.296 A:middle
We've also enhanced part of the
system to better take advantage

00:38:42.296 --> 00:38:43.256 A:middle
of these wider colors.

00:38:43.896 --> 00:38:45.166 A:middle
One example is the color panel.

00:38:45.816 --> 00:38:47.036 A:middle
So on the iMac on the left here,

00:38:47.486 --> 00:38:51.846 A:middle
the color wheel will
actually display, there we go.

00:38:51.846 --> 00:38:53.746 A:middle
It will actually
display and allow picking

00:38:53.746 --> 00:38:58.556 A:middle
from the full range of
P3 colors beyond the sRGB

00:38:58.556 --> 00:38:59.786 A:middle
that normal color wheels allow.

00:39:00.486 --> 00:39:03.706 A:middle
However, you can also
right click the color wheel

00:39:03.836 --> 00:39:06.246 A:middle
and explicitly choose
the working color space.

00:39:06.776 --> 00:39:08.156 A:middle
So even on these
previous displays

00:39:08.156 --> 00:39:09.736 A:middle
that can't render P3 colors,

00:39:09.936 --> 00:39:11.756 A:middle
you can still allow
picking from them.

00:39:14.046 --> 00:39:16.146 A:middle
The RGB color picker
has always allowed you

00:39:16.146 --> 00:39:17.776 A:middle
to choose the color
space you're working in,

00:39:18.036 --> 00:39:20.046 A:middle
but it also allows you to
change the representation

00:39:20.046 --> 00:39:24.136 A:middle
from 8-bit values from 0
to 255 to floating point.

00:39:24.616 --> 00:39:26.566 A:middle
So again you can get this
higher precision when working

00:39:26.566 --> 00:39:28.016 A:middle
with these wider color spaces.

00:39:28.806 --> 00:39:30.826 A:middle
These color panel changes comes

00:39:30.826 --> 00:39:32.826 A:middle
to all applications
completely for free.

00:39:32.826 --> 00:39:34.546 A:middle
No API is needed for those.

00:39:36.396 --> 00:39:38.976 A:middle
The Working with Wide Color
talk on Thursday covers this

00:39:38.976 --> 00:39:41.746 A:middle
and more, such as asset catalog
support and WebKit support.

00:39:41.906 --> 00:39:44.766 A:middle
I'd recommend checking that out
if this stuff interests you.

00:39:45.426 --> 00:39:49.226 A:middle
So the next topic is
status item enhancements.

00:39:49.226 --> 00:39:50.866 A:middle
So status items are
the things that live

00:39:50.866 --> 00:39:52.596 A:middle
in the upper trailing
corner of the menu bar

00:39:52.976 --> 00:39:54.966 A:middle
and these are things that
previously required the use

00:39:54.966 --> 00:39:57.966 A:middle
of private API to achieve
but now come mostly for free.

00:39:59.016 --> 00:40:00.456 A:middle
First is reordering.

00:39:59.016 --> 00:40:00.456 A:middle
First is reordering.

00:40:00.536 --> 00:40:03.856 A:middle
You can now command click and
drag on any item and reorder it

00:40:03.856 --> 00:40:05.716 A:middle
within and beyond
the system items.

00:40:06.556 --> 00:40:09.356 A:middle
You can also use keyboard
focus to navigate to your item

00:40:09.546 --> 00:40:11.646 A:middle
and even activate
menu items within.

00:40:12.866 --> 00:40:14.106 A:middle
The best part of all of this is

00:40:14.106 --> 00:40:16.026 A:middle
that this comes completely
automatically

00:40:16.026 --> 00:40:17.896 A:middle
with no API opt-in
or link check.

00:40:18.596 --> 00:40:20.906 A:middle
So all items are command-click
and drag to reorderable,

00:40:21.306 --> 00:40:23.816 A:middle
and any items with a
menu set will participate

00:40:23.816 --> 00:40:24.826 A:middle
in keyboard navigation.

00:40:25.306 --> 00:40:26.666 A:middle
If they have a custom
target action,

00:40:26.666 --> 00:40:27.746 A:middle
they'll just be skipped over.

00:40:28.996 --> 00:40:31.166 A:middle
The next is hiding and removal.

00:40:31.746 --> 00:40:33.326 A:middle
You can now command-click
and drag an item

00:40:33.326 --> 00:40:36.516 A:middle
out of the status bar, remove
it, get notified of that change,

00:40:36.516 --> 00:40:38.136 A:middle
and even programmatically
restore it.

00:40:39.396 --> 00:40:41.806 A:middle
Unlike reordering, this
does require opt-in.

00:40:41.806 --> 00:40:44.426 A:middle
No status items will be
automatically removable

00:40:44.996 --> 00:40:47.446 A:middle
and you can do that by setting
the behavior of the status item

00:40:47.446 --> 00:40:48.686 A:middle
to include removalAllowed.

00:40:49.796 --> 00:40:51.436 A:middle
You can programmatically
read/set

00:40:51.436 --> 00:40:52.866 A:middle
and even get KVO notified

00:40:52.866 --> 00:40:55.046 A:middle
of this change using
the isVisible property.

00:40:55.686 --> 00:40:57.586 A:middle
And if your application
is a status bar app,

00:40:57.656 --> 00:41:00.286 A:middle
meaning its only representation
is that icon in the status bar,

00:40:57.656 --> 00:41:00.286 A:middle
meaning its only representation
is that icon in the status bar,

00:41:00.286 --> 00:41:03.766 A:middle
there's no doc icon or other
way to quit it, you can set it

00:41:03.766 --> 00:41:05.556 A:middle
to automatically quit on removal

00:41:05.736 --> 00:41:07.636 A:middle
by setting the
terminationOnRemoval behavior.

00:41:09.456 --> 00:41:11.906 A:middle
All of this gets autosaved
for you, the location

00:41:11.906 --> 00:41:13.966 A:middle
and the visible state so you
don't have to worry about trying

00:41:13.966 --> 00:41:16.306 A:middle
to preserve that using
the autosave name.

00:41:16.966 --> 00:41:19.516 A:middle
We automatically generate
this based on the item index

00:41:19.516 --> 00:41:20.906 A:middle
that you created in
your application,

00:41:21.566 --> 00:41:23.876 A:middle
but if you create them in
some non-deterministic order

00:41:23.876 --> 00:41:25.466 A:middle
or just want to have
more explicit control,

00:41:25.806 --> 00:41:27.046 A:middle
you can set that autosave name

00:41:27.046 --> 00:41:28.886 A:middle
to some identifier
of your choice.

00:41:29.796 --> 00:41:31.716 A:middle
So that's status
item enhancements.

00:41:31.716 --> 00:41:33.796 A:middle
A lot of it comes for free, and
with a little bit of tweaking,

00:41:34.046 --> 00:41:35.916 A:middle
you can really make them
great in your application.

00:41:37.206 --> 00:41:39.216 A:middle
Next are control constructors.

00:41:39.636 --> 00:41:42.796 A:middle
So these are new constructors
on existing NS Controls

00:41:42.796 --> 00:41:45.896 A:middle
that make it really easy to
get standard look and feels.

00:41:46.596 --> 00:41:50.376 A:middle
Examples are different types
of buttons, segmented controls,

00:41:51.036 --> 00:41:55.416 A:middle
image views, sliders, and
labels, and text fields.

00:41:56.226 --> 00:41:57.896 A:middle
So these are the types of
things you're already working

00:41:57.896 --> 00:41:59.696 A:middle
with in the Interface
Builder object library

00:41:59.816 --> 00:42:01.226 A:middle
and it makes it just as easily

00:41:59.816 --> 00:42:01.226 A:middle
and it makes it just as easily

00:42:01.226 --> 00:42:03.096 A:middle
to use these right
out of the box.

00:42:03.726 --> 00:42:05.306 A:middle
They come with the
standard system setup,

00:42:05.306 --> 00:42:07.066 A:middle
the right font size,
and text color,

00:42:07.386 --> 00:42:08.836 A:middle
and they support
different contexts.

00:42:09.336 --> 00:42:13.016 A:middle
So the label here looks
great in aqua, vibrant light

00:42:13.016 --> 00:42:15.446 A:middle
and even a vibrant dark
all right out of the box.

00:42:15.566 --> 00:42:16.826 A:middle
There's no additional
setup needed.

00:42:17.576 --> 00:42:19.936 A:middle
I'd love to show you an example
of what this does to your code.

00:42:19.936 --> 00:42:22.686 A:middle
So this is creating
a checkbox before.

00:42:22.766 --> 00:42:24.266 A:middle
There's quite a few
properties to set

00:42:24.266 --> 00:42:26.456 A:middle
and the unfortunate thing is
we really only care about three

00:42:26.456 --> 00:42:28.536 A:middle
of those; the title,
target, and action.

00:42:28.996 --> 00:42:32.426 A:middle
Well with checkbox, title,
target, action, it's distilled

00:42:32.426 --> 00:42:34.436 A:middle
down to just that,
which is pretty great.

00:42:35.716 --> 00:42:39.536 A:middle
A bit more of a --
Oh [applause].

00:42:42.306 --> 00:42:42.896 A:middle
Just wait.

00:42:43.636 --> 00:42:45.756 A:middle
So this is creating just
a static label, right,

00:42:45.756 --> 00:42:47.386 A:middle
just some text on the screen.

00:42:47.536 --> 00:42:50.186 A:middle
And here, we care about
just the string value.

00:42:51.056 --> 00:42:54.026 A:middle
Well, with labelWithString,
it again is just that.

00:42:54.906 --> 00:42:57.056 A:middle
So, this is pretty great.

00:42:57.056 --> 00:42:58.536 A:middle
It comes out of the box --

00:42:59.516 --> 00:43:03.016 A:middle
[ Applause ]

00:42:59.516 --> 00:43:03.016 A:middle
[ Applause ]

00:43:03.516 --> 00:43:05.596 A:middle
It comes out of the box
ready to be used with

00:43:05.596 --> 00:43:06.716 A:middle
or without auto layout.

00:43:06.846 --> 00:43:08.866 A:middle
So if you are going to be
positioning with constraints,

00:43:09.056 --> 00:43:11.186 A:middle
you still need to set
translatesAutoresizingMask

00:43:11.186 --> 00:43:14.316 A:middle
IntoConstaints to false,
like all of your other views.

00:43:14.806 --> 00:43:16.826 A:middle
And so if you already have
categories doing these kinds

00:43:16.826 --> 00:43:18.166 A:middle
of things, we still
recommend moving

00:43:18.166 --> 00:43:20.256 A:middle
over to these new system
ones because you'll ensure

00:43:20.466 --> 00:43:21.876 A:middle
that your controls
have the standard look

00:43:21.876 --> 00:43:23.906 A:middle
and feel both now
and in the future.

00:43:24.096 --> 00:43:28.116 A:middle
The last thing I'd like to
talk about are API refinements.

00:43:28.116 --> 00:43:29.906 A:middle
I only covered a number of
these that applied to all

00:43:29.906 --> 00:43:31.946 A:middle
of our frameworks and these
apply to AppKit as well

00:43:31.946 --> 00:43:34.026 A:middle
but there's two more that I
want to talk about that apply

00:43:34.026 --> 00:43:35.046 A:middle
to AppKit specifically.

00:43:36.116 --> 00:43:37.766 A:middle
The first is weak delegates.

00:43:38.436 --> 00:43:40.756 A:middle
So we've added new zeroing
weak delegate support

00:43:40.756 --> 00:43:44.066 A:middle
for various delegates and data
sources for different classes,

00:43:44.806 --> 00:43:47.396 A:middle
so you no longer need to clear
these properties once the

00:43:47.396 --> 00:43:48.466 A:middle
delegates is deallocated.

00:43:49.786 --> 00:43:52.136 A:middle
It still supports non-weak
referenceable objects

00:43:52.326 --> 00:43:54.676 A:middle
in which case it'll fall
back to the existing assign

00:43:54.676 --> 00:43:56.626 A:middle
or unsafe, unretained semantics.

00:43:57.886 --> 00:43:59.456 A:middle
We've also gone through
and made sure that all

00:43:59.456 --> 00:44:01.446 A:middle
of our classes explicitly
did declare their

00:43:59.456 --> 00:44:01.446 A:middle
of our classes explicitly
did declare their

00:44:01.446 --> 00:44:02.886 A:middle
designated initializers.

00:44:03.466 --> 00:44:05.626 A:middle
These are the same as what they
effectively were previously

00:44:05.786 --> 00:44:07.866 A:middle
but now are just
declared in the actual API

00:44:08.696 --> 00:44:10.386 A:middle
with the one exception
being NSCursor.

00:44:10.756 --> 00:44:12.286 A:middle
So if you are subclassing
NSCursor,

00:44:12.286 --> 00:44:13.266 A:middle
please see the release notes

00:44:13.266 --> 00:44:16.136 A:middle
for how you should
properly deal with that.

00:44:16.416 --> 00:44:18.736 A:middle
As with all newly declared
designated initializers,

00:44:19.156 --> 00:44:21.906 A:middle
you should make sure that
you're properly dealing

00:44:21.906 --> 00:44:23.186 A:middle
with that in your subclass.

00:44:24.286 --> 00:44:25.846 A:middle
And so if you weren't
previously,

00:44:25.846 --> 00:44:27.726 A:middle
you potentially had these
incorrectness issues

00:44:27.726 --> 00:44:29.226 A:middle
that maybe were subtle bugs.

00:44:29.546 --> 00:44:31.676 A:middle
In Objective-C, you'll now
see build warnings for this.

00:44:31.866 --> 00:44:33.676 A:middle
And in Swift, you're going
to get build failures.

00:44:33.676 --> 00:44:35.026 A:middle
So you want to make sure

00:44:35.026 --> 00:44:37.026 A:middle
that you're properly handling
these different cases.

00:44:37.366 --> 00:44:39.386 A:middle
So that's it for
what's new in AppKit.

00:44:39.386 --> 00:44:41.886 A:middle
At this point, I'd like to turn
it back over to Ali to tell you

00:44:41.886 --> 00:44:43.056 A:middle
about what's new in Foundation.

00:44:44.516 --> 00:44:50.076 A:middle
[ Applause ]

00:44:50.576 --> 00:44:51.196 A:middle
&gt;&gt; Thank you, Taylor.

00:44:53.946 --> 00:44:56.166 A:middle
So here are some of the things
that are new in Foundation

00:44:56.636 --> 00:44:58.536 A:middle
and let me just dive right in.

00:44:59.396 --> 00:45:02.486 A:middle
Now earlier you saw
NSURL becoming URL

00:44:59.396 --> 00:45:02.486 A:middle
Now earlier you saw
NSURL becoming URL

00:45:02.486 --> 00:45:04.706 A:middle
and I think we also talked
about it a bit yesterday.

00:45:05.026 --> 00:45:10.226 A:middle
We are dropping NS prefix in
key Foundation types in Swift.

00:45:10.506 --> 00:45:12.316 A:middle
Now, as you might
know, large subset

00:45:12.316 --> 00:45:16.586 A:middle
of Foundation actually ships
with the Swift Core Libraries

00:45:16.586 --> 00:45:19.026 A:middle
as a part of Swift Core
Libraries and is available

00:45:19.026 --> 00:45:20.576 A:middle
in other platforms,
such as Linux.

00:45:21.436 --> 00:45:25.506 A:middle
And we want to match the naming
style of this part of Foundation

00:45:25.686 --> 00:45:28.206 A:middle
with the convention established
by the Swift Standard Library

00:45:28.206 --> 00:45:29.736 A:middle
which does not use prefixes.

00:45:30.756 --> 00:45:35.126 A:middle
As a result, a lot of our
types drop their NS prefixes

00:45:35.166 --> 00:45:37.136 A:middle
in Foundation and
Swift, as you can see.

00:45:37.136 --> 00:45:39.076 A:middle
NSFormatter becomes
Formatter and so on.

00:45:39.136 --> 00:45:41.906 A:middle
Now the last two here,
NSData and NSURL are part

00:45:41.906 --> 00:45:45.906 A:middle
of a special category and I'll
mention these in a little bit.

00:45:46.016 --> 00:45:48.356 A:middle
Now, this is happening
in Foundation only.

00:45:48.356 --> 00:45:49.516 A:middle
It's not something
we're applying

00:45:49.516 --> 00:45:52.036 A:middle
to our other frameworks,
and even in Foundation,

00:45:52.276 --> 00:45:53.676 A:middle
it's only applying to some APIs.

00:45:53.676 --> 00:45:56.926 A:middle
We do not apply this
NS dropping to APIs

00:45:56.926 --> 00:45:59.176 A:middle
that are inherently
tied to Objective-C.

00:45:59.466 --> 00:46:03.206 A:middle
Examples are NSObject,
NSProxy, NSAutoreleasePool.

00:45:59.466 --> 00:46:03.206 A:middle
Examples are NSObject,
NSProxy, NSAutoreleasePool.

00:46:03.546 --> 00:46:06.816 A:middle
We also do not apply it to
APIs that at platform specific

00:46:06.816 --> 00:46:09.466 A:middle
and are, in fact, not
available on other platforms

00:46:09.466 --> 00:46:12.976 A:middle
such as NSUserNotification,
NSXPCConnection.

00:46:14.036 --> 00:46:17.176 A:middle
And in one other case is classes

00:46:17.176 --> 00:46:18.976 A:middle
which are also exposed
as value types.

00:46:19.416 --> 00:46:22.386 A:middle
So here we are exposing
data, URL, et cetera,

00:46:22.386 --> 00:46:26.866 A:middle
but we're also exposing NSData,
NSURL, and so on and let me talk

00:46:26.866 --> 00:46:27.756 A:middle
about what I mean there.

00:46:28.216 --> 00:46:30.876 A:middle
Now first let me explain
a bit about value types.

00:46:32.006 --> 00:46:34.016 A:middle
You might already be
familiar with value types.

00:46:34.406 --> 00:46:36.526 A:middle
We've had this concept in
Foundation for a long time.

00:46:36.846 --> 00:46:39.936 A:middle
These are types where value is
important, not the identity.

00:46:40.586 --> 00:46:44.396 A:middle
Examples are NSString,
NSData, URL, Array, et cetera.

00:46:45.496 --> 00:46:46.656 A:middle
Now, since a number

00:46:46.656 --> 00:46:49.786 A:middle
of Foundation APIs already have
these value type semantics,

00:46:49.826 --> 00:46:52.496 A:middle
we've gone ahead and added
them as value types in Swift.

00:46:53.056 --> 00:46:55.766 A:middle
And here is the full set of
APIs where we've done this.

00:46:55.966 --> 00:47:00.066 A:middle
This is in addition of course
to string, array, dictionary,

00:46:55.966 --> 00:47:00.066 A:middle
This is in addition of course
to string, array, dictionary,

00:47:00.066 --> 00:47:02.496 A:middle
and set which are already
exposed as values types

00:47:02.496 --> 00:47:03.726 A:middle
in Swift, since they're
available

00:47:03.726 --> 00:47:04.816 A:middle
in the standard library.

00:47:05.516 --> 00:47:09.536 A:middle
So now these types here are
exposed as structs in Swift

00:47:09.746 --> 00:47:11.386 A:middle
and they have value
type semantics,

00:47:11.386 --> 00:47:13.486 A:middle
meaning they can be
directly mutated,

00:47:13.686 --> 00:47:15.086 A:middle
if mutability makes
sense for them.

00:47:15.476 --> 00:47:19.096 A:middle
You can use let or var on these
to distinguished mutability

00:47:19.626 --> 00:47:20.656 A:middle
at the time you declare them.

00:47:21.206 --> 00:47:24.176 A:middle
These also conform to the
expected Swift protocols

00:47:24.176 --> 00:47:28.136 A:middle
as well, as you might expect.

00:47:28.286 --> 00:47:31.136 A:middle
Now existing class APIs
still remain in cases

00:47:31.136 --> 00:47:32.826 A:middle
where we've created
these value types

00:47:33.026 --> 00:47:35.666 A:middle
and let me look at
a case study here.

00:47:36.186 --> 00:47:38.576 A:middle
An example is data, the
one I already mentioned.

00:47:38.846 --> 00:47:40.806 A:middle
So now we have the
struct data type.

00:47:40.866 --> 00:47:42.196 A:middle
This is the value type for data.

00:47:42.536 --> 00:47:44.476 A:middle
This is the data
type we expect you

00:47:44.476 --> 00:47:48.206 A:middle
to use most often
in your programming.

00:47:48.236 --> 00:47:52.086 A:middle
This is the type moving forward;
however, we also have NSData

00:47:52.116 --> 00:47:54.756 A:middle
which is a subclass of
NSObject and NSMutableData

00:47:54.756 --> 00:47:57.426 A:middle
which is a subclass
of NSData itself.

00:47:57.846 --> 00:48:00.256 A:middle
Now NS types remain
because something

00:47:57.846 --> 00:48:00.256 A:middle
Now NS types remain
because something

00:48:00.256 --> 00:48:03.236 A:middle
like NSMutableData is not
migratable very easily,

00:48:03.236 --> 00:48:05.146 A:middle
so the migrator will
not migrate it.

00:48:05.556 --> 00:48:08.306 A:middle
Another reason we have NS types
is sometimes you actually do

00:48:08.306 --> 00:48:09.606 A:middle
want to subclass these types.

00:48:09.606 --> 00:48:11.266 A:middle
You know, you might
be subclassing NSData

00:48:11.266 --> 00:48:14.326 A:middle
or NSMutableData to provide
some specialized implementation

00:48:14.636 --> 00:48:16.056 A:middle
and you can do that
with, of course,

00:48:16.056 --> 00:48:18.226 A:middle
the class types,
as you see here.

00:48:18.226 --> 00:48:20.696 A:middle
So these are some of the reasons
why the NS types still remain.

00:48:22.186 --> 00:48:24.456 A:middle
Now, let's look at
some differences here.

00:48:25.256 --> 00:48:29.256 A:middle
The NSData class has
a length property.

00:48:29.546 --> 00:48:31.916 A:middle
This has been named count
in the struct version

00:48:31.916 --> 00:48:33.716 A:middle
because it's more
consistent with the rest

00:48:33.716 --> 00:48:34.986 A:middle
of the Swift Standard Library.

00:48:35.576 --> 00:48:38.026 A:middle
Methods such as write
to, range of and many

00:48:38.026 --> 00:48:40.036 A:middle
of these other methods
remain pretty much intact.

00:48:40.036 --> 00:48:42.346 A:middle
They come across the same
way except you'll notice

00:48:42.346 --> 00:48:45.796 A:middle
that the NSRange and NSData
has become range of index

00:48:46.776 --> 00:48:48.956 A:middle
in the struct data version,
which is more consistent

00:48:48.956 --> 00:48:50.656 A:middle
with the Swift Library.

00:48:51.036 --> 00:48:54.196 A:middle
And finally you'll note that a
mutating function, like append,

00:48:54.196 --> 00:48:57.416 A:middle
is not available on this
value type data directly while

00:48:57.416 --> 00:49:00.336 A:middle
in the case of NSData, it's
on the NSMutableData class.

00:48:57.416 --> 00:49:00.336 A:middle
in the case of NSData, it's
on the NSMutableData class.

00:49:00.736 --> 00:49:02.486 A:middle
So these are some of the
differences you'll see

00:49:02.486 --> 00:49:04.946 A:middle
between the value types
and the class types.

00:49:05.516 --> 00:49:08.066 A:middle
Now I'm not going to say
much more about this.

00:49:08.566 --> 00:49:10.926 A:middle
There is a talk this afternoon,
What's New in Foundation

00:49:10.926 --> 00:49:12.996 A:middle
for Swift in the Mission room.

00:49:13.206 --> 00:49:17.696 A:middle
I encourage you to attend that
and hear more about these.

00:49:17.916 --> 00:49:20.096 A:middle
Now we have several
new types in Foundation

00:49:20.326 --> 00:49:21.746 A:middle
to represent measured amounts.

00:49:22.276 --> 00:49:24.406 A:middle
The main class here
is the unit class.

00:49:24.446 --> 00:49:27.826 A:middle
This is an abstract type to
represent units, such as miles,

00:49:27.986 --> 00:49:30.406 A:middle
degrees Celsius, kilometers
per hour, and so on.

00:49:30.596 --> 00:49:32.446 A:middle
And then we have
a class dimension,

00:49:32.446 --> 00:49:33.606 A:middle
which is a subclass of unit.

00:49:33.976 --> 00:49:36.046 A:middle
This represents unit
families such as length,

00:49:36.156 --> 00:49:38.236 A:middle
temperature, and
speed and so on.

00:49:38.716 --> 00:49:40.146 A:middle
So here we have the unit class.

00:49:40.446 --> 00:49:43.486 A:middle
We have the subclass dimension
and then we have subclasses

00:49:44.206 --> 00:49:46.696 A:middle
such as unit length,
unit temperature,

00:49:46.696 --> 00:49:48.326 A:middle
unit speed, and a bunch more.

00:49:49.586 --> 00:49:53.036 A:middle
There's a helper class unit
converter that allows conversion

00:49:53.036 --> 00:49:55.276 A:middle
between units within
the same unit family

00:49:56.246 --> 00:49:59.576 A:middle
and there is a struct
measurement, it's a class,

00:49:59.576 --> 00:50:02.596 A:middle
of course, in Objective-C but
across as a value type in Swift,

00:49:59.576 --> 00:50:02.596 A:middle
of course, in Objective-C but
across as a value type in Swift,

00:50:03.036 --> 00:50:05.716 A:middle
struct measurement which
combines a value such as 10

00:50:06.026 --> 00:50:07.606 A:middle
with a unit such as miles,

00:50:07.996 --> 00:50:09.776 A:middle
so this basically is
now a measurement,

00:50:09.986 --> 00:50:11.466 A:middle
and finally the icing
on the cake,

00:50:11.896 --> 00:50:13.536 A:middle
we have the measurement
formatter class

00:50:13.776 --> 00:50:16.076 A:middle
which will take one of these
measurements and show it

00:50:16.076 --> 00:50:17.906 A:middle
to the user in the
user's locale.

00:50:18.416 --> 00:50:23.246 A:middle
So it'll show 10 miles to a
user here in the United States

00:50:23.526 --> 00:50:26.496 A:middle
but will show 16 kilometers, for
instance, to a user in Europe,

00:50:26.726 --> 00:50:27.896 A:middle
who's using the European system.

00:50:27.896 --> 00:50:29.466 A:middle
So it will do the
conversions for you

00:50:29.596 --> 00:50:31.076 A:middle
and show the user
the right thing.

00:50:32.516 --> 00:50:37.186 A:middle
[ Applause ]

00:50:37.686 --> 00:50:40.506 A:middle
Now out of the box, we have
plenty of unit families defined.

00:50:40.866 --> 00:50:41.706 A:middle
Here's the whole set.

00:50:42.236 --> 00:50:45.286 A:middle
So these are subclasses of
dimension, and within each one

00:50:45.286 --> 00:50:46.406 A:middle
of these unit families,

00:50:46.406 --> 00:50:49.486 A:middle
we actually have multiple units
defined out of the box as well.

00:50:49.736 --> 00:50:52.016 A:middle
Let me take a look at unit
temperature for instance.

00:50:52.446 --> 00:50:54.916 A:middle
You'll see that unit temperature
has three standards units;

00:50:54.916 --> 00:50:57.276 A:middle
kelvin, Celsius, and Fahrenheit.

00:50:57.596 --> 00:50:59.596 A:middle
And these are defined
as class properties

00:50:59.656 --> 00:51:02.646 A:middle
on the UnitTemperature
class and many

00:50:59.656 --> 00:51:02.646 A:middle
on the UnitTemperature
class and many

00:51:02.646 --> 00:51:06.126 A:middle
of the other dimensions also
have a number of units defined

00:51:06.126 --> 00:51:07.836 A:middle
that know how to convert
between each other.

00:51:08.306 --> 00:51:13.346 A:middle
And even better news, you can
actually add your own units

00:51:13.386 --> 00:51:15.276 A:middle
on top of what we
provided and they'll play

00:51:15.276 --> 00:51:16.426 A:middle
with what's already there

00:51:16.426 --> 00:51:18.896 A:middle
and you can also add your
own unit families as well.

00:51:19.526 --> 00:51:22.426 A:middle
So you can hear much more
about this Friday afternoon

00:51:22.426 --> 00:51:25.816 A:middle
at 4:00 o'clock,
Measurement and Units.

00:51:26.886 --> 00:51:29.166 A:middle
DateInterval is a new type
we've added to Foundation.

00:51:29.536 --> 00:51:31.906 A:middle
It represents a date interval.

00:51:32.386 --> 00:51:36.766 A:middle
It's got three properties;
start, end, and duration.

00:51:36.766 --> 00:51:38.526 A:middle
Fairly straightforward, so
these are not, of course,

00:51:38.526 --> 00:51:40.026 A:middle
fully independent
but they're reflected

00:51:40.026 --> 00:51:41.306 A:middle
as three separate properties.

00:51:41.546 --> 00:51:43.846 A:middle
In addition to these properties,
DateInterval knows how

00:51:43.846 --> 00:51:46.476 A:middle
to do things like check if a
date is within a date interval

00:51:46.706 --> 00:51:48.976 A:middle
or whether two date
intervals overlap and so on.

00:51:49.616 --> 00:51:54.296 A:middle
Date intervals are of course
also very useful to be formatted

00:51:54.346 --> 00:51:55.836 A:middle
with the DateIntervalFormatter
class.

00:51:55.836 --> 00:51:58.806 A:middle
That's something we -- That's an
API we introduced last release.

00:51:59.646 --> 00:52:01.766 A:middle
We had an API string from to.

00:51:59.646 --> 00:52:01.766 A:middle
We had an API string from to.

00:52:01.916 --> 00:52:03.406 A:middle
Now we have the string from API

00:52:03.566 --> 00:52:05.176 A:middle
which simply takes
a date interval,

00:52:05.766 --> 00:52:06.766 A:middle
so fairly straightforward.

00:52:07.816 --> 00:52:10.696 A:middle
Now at this point let me
give you a public service

00:52:10.696 --> 00:52:13.396 A:middle
announcement about
handling dates and times.

00:52:14.716 --> 00:52:16.486 A:middle
So handling dates can be tricky.

00:52:17.306 --> 00:52:19.296 A:middle
Now this is not relationship
advice here.

00:52:19.506 --> 00:52:22.236 A:middle
Okay? I'm not a doctor.

00:52:24.086 --> 00:52:26.406 A:middle
Let's say you want to
represent a ten second period.

00:52:26.866 --> 00:52:28.996 A:middle
You might go ahead and create
a DateInterval like this,

00:52:29.096 --> 00:52:31.426 A:middle
start date and a
ten second period.

00:52:31.836 --> 00:52:35.066 A:middle
This is likely correct for
whatever you might try to,

00:52:35.066 --> 00:52:37.366 A:middle
whatever you're trying to
do with a ten second period,

00:52:37.906 --> 00:52:39.636 A:middle
but let's say you're
trying to represent a day.

00:52:40.326 --> 00:52:42.106 A:middle
You might go ahead and
write code like this,

00:52:43.276 --> 00:52:46.436 A:middle
24 times 60 by 60 which is the
number of seconds in a day.

00:52:47.016 --> 00:52:49.326 A:middle
Well this is the number of
seconds in a 24-hour period

00:52:49.836 --> 00:52:52.986 A:middle
and it's often not
going to be correct.

00:52:53.346 --> 00:52:55.956 A:middle
The reason is because days
are not always 24 hours long.

00:52:56.056 --> 00:52:57.836 A:middle
Months aren't always 31 days.

00:52:57.836 --> 00:53:00.456 A:middle
Years aren't always
365 days and so on.

00:52:57.836 --> 00:53:00.456 A:middle
Years aren't always
365 days and so on.

00:53:00.456 --> 00:53:02.946 A:middle
We always keep those in
mind but there are also days

00:53:02.946 --> 00:53:07.786 A:middle
which are 23 hours or sometimes
24 hours, 25 hours, as you know.

00:53:08.316 --> 00:53:10.016 A:middle
So depending on what
you want to do

00:53:10.016 --> 00:53:12.476 A:middle
with a DateInterval representing
a date, are you trying

00:53:12.476 --> 00:53:14.476 A:middle
to set an alarm exactly
24 hours from now?

00:53:14.746 --> 00:53:17.606 A:middle
Are you trying to send an alarm
at the same time the next day?

00:53:17.606 --> 00:53:18.896 A:middle
You have to be careful.

00:53:19.326 --> 00:53:22.746 A:middle
Typically the correct solutions
here involve using the calendar

00:53:22.746 --> 00:53:25.306 A:middle
class and you can hear
about these problems

00:53:25.306 --> 00:53:28.696 A:middle
and also luckily their solutions
in this talk from 2013,

00:53:28.696 --> 00:53:30.666 A:middle
Solutions to Common Date
and Time Challenges,

00:53:30.666 --> 00:53:33.316 A:middle
which I encourage you
to go back and watch.

00:53:35.336 --> 00:53:38.906 A:middle
ISO8601 DateFormatter is
another new API in Foundation.

00:53:38.906 --> 00:53:40.226 A:middle
It's a formatter for dates.

00:53:40.896 --> 00:53:41.286 A:middle
Thank you.

00:53:42.516 --> 00:53:45.006 A:middle
[ Applause ]

00:53:45.506 --> 00:53:47.176 A:middle
So clearly some of you have had

00:53:47.236 --> 00:53:50.486 A:middle
to use 8601 before;
8601 is a standard.

00:53:50.486 --> 00:53:52.666 A:middle
It's an interchange
format for specifying dates

00:53:52.666 --> 00:53:53.956 A:middle
in an unambiguous manner.

00:53:54.446 --> 00:53:56.786 A:middle
So this is a separate
class than DateFormatter

00:53:56.786 --> 00:53:58.646 A:middle
because unlike DateFormatter,
which is meant

00:53:58.646 --> 00:54:02.916 A:middle
for user-localized dates, 8601
formatting is non-localized.

00:53:58.646 --> 00:54:02.916 A:middle
for user-localized dates, 8601
formatting is non-localized.

00:54:03.426 --> 00:54:04.666 A:middle
It's, you know, interchange
format.

00:54:04.666 --> 00:54:06.236 A:middle
So it's a separate type.

00:54:06.426 --> 00:54:08.076 A:middle
We decided to keep
things simple.

00:54:08.546 --> 00:54:09.706 A:middle
Using it is very simple.

00:54:10.596 --> 00:54:11.786 A:middle
So create a formatter.

00:54:12.726 --> 00:54:16.486 A:middle
Get yourself a date, again
not relationship advice.

00:54:18.086 --> 00:54:20.616 A:middle
And simply ask the formatter
for the string for that date

00:54:20.616 --> 00:54:22.006 A:middle
and it will return
you the format.

00:54:22.256 --> 00:54:24.276 A:middle
Now this DateFormatter
can actually go both ways,

00:54:24.836 --> 00:54:26.656 A:middle
so you can actually -- Oh,
by the way, here's the output

00:54:26.686 --> 00:54:28.416 A:middle
from that call, and
as you can see,

00:54:28.416 --> 00:54:29.816 A:middle
it's getting close to lunchtime.

00:54:30.476 --> 00:54:33.266 A:middle
And here is -- This formatter
also goes the other ways,

00:54:33.586 --> 00:54:34.596 A:middle
also does parsing.

00:54:34.786 --> 00:54:37.696 A:middle
So you can get yourself a
formatter and ask for the date

00:54:37.696 --> 00:54:40.116 A:middle
from a string and it'll
return the date for you.

00:54:40.216 --> 00:54:41.276 A:middle
So it goes both ways.

00:54:42.626 --> 00:54:46.146 A:middle
Now by default, this will do
RFC 3339, which is one format;

00:54:46.466 --> 00:54:48.956 A:middle
however, there are options
that let you specify some

00:54:48.956 --> 00:54:51.926 A:middle
of the behaviors,
if you need to.

00:54:52.276 --> 00:54:55.096 A:middle
Now quickly let me cover
some other Foundation updates

00:54:55.096 --> 00:54:56.676 A:middle
we have.

00:54:56.676 --> 00:55:00.236 A:middle
URL has a bunch of
new properties,

00:54:56.676 --> 00:55:00.236 A:middle
URL has a bunch of
new properties,

00:55:00.646 --> 00:55:04.276 A:middle
such as canonical path of
a file and a bunch more,

00:55:04.276 --> 00:55:06.566 A:middle
like whether a volume
is encrypted and so on.

00:55:06.566 --> 00:55:08.746 A:middle
You can read all about
these in the release notes.

00:55:09.046 --> 00:55:11.206 A:middle
There's a new class
URLSessionTaskMetrics.

00:55:11.606 --> 00:55:15.486 A:middle
This class helps you gather
network resource loading

00:55:15.486 --> 00:55:18.406 A:middle
performance information
so you can actually look

00:55:18.406 --> 00:55:20.936 A:middle
at the network performance
of your applications.

00:55:21.956 --> 00:55:25.456 A:middle
PersonNameComponentsFormatter
is an API we added last release.

00:55:26.006 --> 00:55:28.866 A:middle
As you know, it takes a
person's name and it formats it

00:55:28.916 --> 00:55:30.696 A:middle
in a locale-appropriate manner.

00:55:31.176 --> 00:55:33.456 A:middle
Well in this release, it
actually can now parse names.

00:55:33.456 --> 00:55:35.216 A:middle
So you give it a name
and it will return

00:55:35.216 --> 00:55:37.386 A:middle
to you the first name,
last name, et cetera

00:55:37.626 --> 00:55:38.796 A:middle
and it does a pretty good job

00:55:38.796 --> 00:55:42.886 A:middle
since it uses a statistical
model based on real-world data.

00:55:43.506 --> 00:55:47.986 A:middle
And finally -- But there are
some tricky names out there.

00:55:47.986 --> 00:55:52.126 A:middle
So don't get your
hopes up fully.

00:55:52.956 --> 00:55:54.966 A:middle
And DateComponentsFormatter,

00:55:55.296 --> 00:55:58.426 A:middle
again this is API we
added last release.

00:55:58.656 --> 00:56:01.386 A:middle
In addition to the full
style and the short style,

00:55:58.656 --> 00:56:01.386 A:middle
In addition to the full
style and the short style,

00:56:01.386 --> 00:56:03.976 A:middle
we now have a brief style
of date that you can format.

00:56:04.236 --> 00:56:06.946 A:middle
And next release, maybe we'll
add the boxer style as well.

00:56:07.646 --> 00:56:09.336 A:middle
Okay, so that's it
for Foundation.

00:56:11.406 --> 00:56:13.676 A:middle
Core data, just a quick
mention of core data.

00:56:13.716 --> 00:56:15.736 A:middle
You already saw some
API improvements

00:56:15.736 --> 00:56:16.996 A:middle
in core data with generics.

00:56:16.996 --> 00:56:19.876 A:middle
There's a bunch more
new APIs in core data,

00:56:19.876 --> 00:56:22.456 A:middle
such as generational querying,
persistent store description,

00:56:22.786 --> 00:56:26.516 A:middle
the NSFetchedResultsController
class is now available in OS X

00:56:26.516 --> 00:56:28.776 A:middle
as well, I'm sorry,
macOS as well.

00:56:29.086 --> 00:56:30.706 A:middle
You can hear all
about this Friday

00:56:30.706 --> 00:56:32.346 A:middle
at 10:00 a.m. What's
New in Core Data.

00:56:33.116 --> 00:56:35.526 A:middle
And one more talk I want
to give a shout out to,

00:56:36.516 --> 00:56:40.016 A:middle
every year we get up here
and tell you about new APIs,

00:56:40.016 --> 00:56:42.676 A:middle
new technologies were introduced
and you might not always be

00:56:42.676 --> 00:56:44.776 A:middle
in a position to adopt
these APIs because you're

00:56:44.776 --> 00:56:46.396 A:middle
in the middle of something else

00:56:46.466 --> 00:56:48.016 A:middle
or maybe you wait a
release and so on.

00:56:48.426 --> 00:56:49.896 A:middle
Well, if you want
to get an overview

00:56:49.896 --> 00:56:53.086 A:middle
of recent APIs we've
added, APIs are important

00:56:53.176 --> 00:56:55.116 A:middle
to create modern
applications for the Mac.

00:56:55.236 --> 00:56:56.296 A:middle
This is talk for you.

00:56:56.556 --> 00:56:59.796 A:middle
It will cover a lot of topics
and they'll have pointers

00:56:59.796 --> 00:57:01.966 A:middle
to other sessions of
interest, not just in this WWDC

00:56:59.796 --> 00:57:01.966 A:middle
to other sessions of
interest, not just in this WWDC

00:57:01.966 --> 00:57:04.096 A:middle
but also prior WWDCs as well.

00:57:04.476 --> 00:57:06.506 A:middle
It's also appropriate
for everyone, all ages,

00:57:06.506 --> 00:57:07.676 A:middle
all experience levels.

00:57:07.986 --> 00:57:09.456 A:middle
It's also Friday
at 5:00 o'clock.

00:57:09.456 --> 00:57:11.136 A:middle
So I hope you're here.

00:57:13.146 --> 00:57:16.476 A:middle
Okay, so and here is
the webpage you can go

00:57:16.476 --> 00:57:17.466 A:middle
to for more information.

00:57:17.826 --> 00:57:20.596 A:middle
Please read the AppKit and
Foundation release notes,

00:57:20.596 --> 00:57:22.586 A:middle
which you can find in
our developer tool site.

00:57:22.586 --> 00:57:24.816 A:middle
It's there, just raw
information about a lot

00:57:24.816 --> 00:57:25.886 A:middle
of the stuff I talked about.

00:57:26.256 --> 00:57:27.926 A:middle
Here are the related
sessions we mentioned.

00:57:27.926 --> 00:57:29.076 A:middle
There are of course many more.

00:57:29.506 --> 00:57:30.186 A:middle
Thank you very much.
