WEBVTT

00:00:06.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:25.516 --> 00:00:29.546 A:middle
[ Applause ]

00:00:30.046 --> 00:00:32.016 A:middle
&gt;&gt; Good afternoon,
everyone, and welcome.

00:00:32.836 --> 00:00:35.846 A:middle
I'm Alex, and Jacob and I are
going to talk to you today

00:00:36.256 --> 00:00:38.696 A:middle
about how you can use
value types and protocols

00:00:38.956 --> 00:00:39.966 A:middle
to make your app better.

00:00:40.546 --> 00:00:41.766 A:middle
And we're going to focus today

00:00:41.766 --> 00:00:44.006 A:middle
on something called
local reasoning.

00:00:44.556 --> 00:00:47.846 A:middle
Local reasoning means that
when you look at the code,

00:00:47.846 --> 00:00:51.256 A:middle
right in front of you, you don't
have to think about how the rest

00:00:51.256 --> 00:00:53.426 A:middle
of your code interacts
with that one function.

00:00:54.486 --> 00:00:56.026 A:middle
You may have had
this feeling before

00:00:56.956 --> 00:00:58.886 A:middle
and that's just a
name for that feeling.

00:00:59.846 --> 00:01:03.286 A:middle
For example, maybe when
you just joined a new team

00:00:59.846 --> 00:01:03.286 A:middle
For example, maybe when
you just joined a new team

00:01:03.506 --> 00:01:06.716 A:middle
and you have tons of code to
look at but very little context,

00:01:07.286 --> 00:01:09.646 A:middle
can you understand what's going
on in that single function?

00:01:10.846 --> 00:01:13.446 A:middle
And so the ability to do
that is really important

00:01:13.526 --> 00:01:16.486 A:middle
because it makes it easier
to maintain, easier to write,

00:01:17.096 --> 00:01:19.356 A:middle
and easier to test, and easier

00:01:19.356 --> 00:01:20.756 A:middle
to write the code
the first time.

00:01:21.286 --> 00:01:23.026 A:middle
And so we're going to talk

00:01:23.026 --> 00:01:26.956 A:middle
about how local reasoning
can improve our UIKit apps

00:01:27.296 --> 00:01:30.446 A:middle
in the context of model view
controller design paradigm,

00:01:31.196 --> 00:01:34.586 A:middle
which is what Cocoa uses, where
the model stores your data,

00:01:35.416 --> 00:01:36.796 A:middle
the view presents that data,

00:01:36.796 --> 00:01:40.976 A:middle
and the controller
coordinates between the two.

00:01:41.216 --> 00:01:43.786 A:middle
And so we need a real app to
put our answers to the test.

00:01:45.006 --> 00:01:47.036 A:middle
Unfortunately, we actually
had a problem at Apple

00:01:47.036 --> 00:01:48.156 A:middle
that we needed to solve.

00:01:48.156 --> 00:01:53.476 A:middle
So I'm going to tell
you a little secret

00:01:53.636 --> 00:01:55.986 A:middle
about how we plan
WWDC every year.

00:01:57.496 --> 00:02:01.236 A:middle
Engineers have dreams and
that's what they're dreaming

00:01:57.496 --> 00:02:01.236 A:middle
Engineers have dreams and
that's what they're dreaming

00:02:01.236 --> 00:02:02.516 A:middle
about for what they're
going to present.

00:02:03.096 --> 00:02:06.816 A:middle
And so somehow we need to take
those dreams and record them,

00:02:07.456 --> 00:02:09.015 A:middle
but we noticed a lot

00:02:09.015 --> 00:02:11.616 A:middle
of engineers don't actually
remember their dreams

00:02:11.616 --> 00:02:12.786 A:middle
by the time they get into work.

00:02:13.076 --> 00:02:13.766 A:middle
They forget them.

00:02:14.756 --> 00:02:18.136 A:middle
So Jacob and I developed this
awesome app to do just that

00:02:18.136 --> 00:02:20.966 A:middle
and the app is called
Lucid Dreams.

00:02:21.406 --> 00:02:23.846 A:middle
I want to show you
some of the dreams

00:02:23.846 --> 00:02:27.386 A:middle
that people had over
the past year.

00:02:27.386 --> 00:02:29.486 A:middle
Some people dream of unicorns.

00:02:30.846 --> 00:02:34.516 A:middle
This is serious [laughter].

00:02:34.976 --> 00:02:42.606 A:middle
Strangely, some people were also
wrapped up in work stress issues

00:02:43.126 --> 00:02:46.086 A:middle
and even more wanted to just get

00:02:46.086 --> 00:02:48.436 A:middle
out of the office
and ride their bike.

00:02:49.166 --> 00:02:52.976 A:middle
And some engineers
even dreams of Crusty.

00:02:53.516 --> 00:03:01.716 A:middle
[ Applause ]

00:02:53.516 --> 00:03:01.716 A:middle
[ Applause ]

00:03:02.216 --> 00:03:04.546 A:middle
And so that was the
inspiration for our application.

00:03:04.746 --> 00:03:05.426 A:middle
But since we're going

00:03:05.426 --> 00:03:07.476 A:middle
to be using the app
throughout our session,

00:03:07.476 --> 00:03:10.286 A:middle
I want to give you a quick
demo so you can get a feel

00:03:10.286 --> 00:03:11.726 A:middle
for what this application does.

00:03:13.016 --> 00:03:15.686 A:middle
And so if we launch the app,
you'll notice it takes us right

00:03:15.686 --> 00:03:17.206 A:middle
to the list of dreams
that we've had.

00:03:18.706 --> 00:03:21.096 A:middle
And if you tap one of the
dreams, you can edit it.

00:03:21.436 --> 00:03:24.496 A:middle
And so you can see we
have a preview at the top.

00:03:25.306 --> 00:03:28.046 A:middle
We can scroll down and we're
going to add some effects,

00:03:28.296 --> 00:03:30.386 A:middle
like laser focus and rain.

00:03:30.956 --> 00:03:36.446 A:middle
And so if we scroll back up, you
can see the preview of a dream

00:03:36.676 --> 00:03:40.876 A:middle
of a unicorn with laser focus,
rain, and fire breathing.

00:03:41.326 --> 00:03:45.406 A:middle
And so when we're done editing
the dream, we can just go back

00:03:45.406 --> 00:03:46.416 A:middle
to the list of our dreams.

00:03:47.046 --> 00:03:49.526 A:middle
And so that's the app.

00:03:50.446 --> 00:03:51.896 A:middle
And we wanted to think really,

00:03:51.896 --> 00:03:54.686 A:middle
really hard about how we could
make our code just awesome.

00:03:55.156 --> 00:03:57.746 A:middle
And so we watched these
fantastic Swift talks

00:03:57.746 --> 00:03:58.436 A:middle
from last year.

00:03:59.756 --> 00:04:02.096 A:middle
These sessions focus on
the benefits of value types

00:03:59.756 --> 00:04:02.096 A:middle
These sessions focus on
the benefits of value types

00:04:02.096 --> 00:04:03.636 A:middle
and protocol-oriented
programming.

00:04:03.636 --> 00:04:07.866 A:middle
And these ideas were so powerful
that we wanted to take advantage

00:04:07.866 --> 00:04:10.176 A:middle
of them because they can
help improve local reasoning

00:04:10.176 --> 00:04:11.076 A:middle
in our application.

00:04:12.456 --> 00:04:14.636 A:middle
And so we wrote our app with
this different way of thinking.

00:04:16.005 --> 00:04:18.156 A:middle
Now some of these ideas
might feel foreign

00:04:18.156 --> 00:04:19.636 A:middle
to you and that's okay.

00:04:19.636 --> 00:04:22.326 A:middle
When we were initially
trying these techniques out,

00:04:22.326 --> 00:04:23.996 A:middle
they felt foreign to us too.

00:04:24.476 --> 00:04:25.146 A:middle
So don't worry.

00:04:25.176 --> 00:04:26.236 A:middle
Just stick with us.

00:04:30.056 --> 00:04:32.306 A:middle
And so we're going to
quickly go over the benefits

00:04:32.616 --> 00:04:34.256 A:middle
of value types in
the model layer.

00:04:34.886 --> 00:04:36.336 A:middle
This was already
covered last year,

00:04:36.336 --> 00:04:38.226 A:middle
so it's going to
be a quick recap.

00:04:39.056 --> 00:04:41.736 A:middle
Then we're going to focus on
how we can use value types

00:04:41.736 --> 00:04:44.206 A:middle
in the viewing controller
layers since that's

00:04:44.206 --> 00:04:47.696 A:middle
where we think most people don't
think they can take advantage

00:04:47.866 --> 00:04:50.336 A:middle
of value types, even
though there're some really

00:04:50.336 --> 00:04:51.246 A:middle
tangible benefits.

00:04:51.396 --> 00:04:55.226 A:middle
And along the way we're going to
show you how using value types

00:04:55.226 --> 00:04:57.846 A:middle
and protocols made
our code testable.

00:04:59.306 --> 00:05:02.966 A:middle
And as you just saw this awesome
app, I know you want to test it.

00:04:59.306 --> 00:05:02.966 A:middle
And as you just saw this awesome
app, I know you want to test it.

00:05:03.036 --> 00:05:04.596 A:middle
We've shipped this
as a sample app

00:05:04.596 --> 00:05:08.126 A:middle
so you can go download it
yourself, see the code,

00:05:08.126 --> 00:05:10.166 A:middle
and log your own dreams.

00:05:12.176 --> 00:05:15.136 A:middle
All right, so now it's time
to talk about the model layer.

00:05:16.166 --> 00:05:17.386 A:middle
So what is a dream?

00:05:17.986 --> 00:05:21.056 A:middle
A dream is our model type

00:05:21.166 --> 00:05:23.676 A:middle
that represents a dream
entry in our application.

00:05:24.536 --> 00:05:28.816 A:middle
A dream as a description, a
creature, and a set of effects,

00:05:28.816 --> 00:05:30.446 A:middle
as you saw in the UI earlier on.

00:05:31.526 --> 00:05:33.366 A:middle
Now I want to show you a
version of the dream type

00:05:33.416 --> 00:05:37.016 A:middle
that we used last year in
the first version of our app.

00:05:37.236 --> 00:05:38.956 A:middle
We started with a dream
type being a class.

00:05:40.346 --> 00:05:42.586 A:middle
Now classes have
reference semantics,

00:05:42.966 --> 00:05:43.836 A:middle
meaning that references

00:05:43.836 --> 00:05:46.356 A:middle
to the same instance
share their storage

00:05:46.416 --> 00:05:47.646 A:middle
and that sharing is implicit.

00:05:48.756 --> 00:05:52.276 A:middle
So why is that a problem?

00:05:52.376 --> 00:05:56.166 A:middle
Well, let's say someone tries
to modify dream2's description.

00:05:57.606 --> 00:06:00.656 A:middle
If we only care about
dream1, we may be surprised

00:05:57.606 --> 00:06:00.656 A:middle
If we only care about
dream1, we may be surprised

00:06:00.656 --> 00:06:02.836 A:middle
that the variable's
value changed

00:06:02.836 --> 00:06:04.066 A:middle
from underneath our control.

00:06:04.066 --> 00:06:08.376 A:middle
And this really hurts
local reasoning.

00:06:08.936 --> 00:06:13.416 A:middle
And we had exactly this kind
of bug in our own application,

00:06:13.416 --> 00:06:14.896 A:middle
even though our test passed.

00:06:15.666 --> 00:06:16.506 A:middle
But why was that?

00:06:16.506 --> 00:06:22.096 A:middle
And so this diagram
shows the relationships

00:06:22.096 --> 00:06:23.866 A:middle
of the first version
of our application.

00:06:24.476 --> 00:06:27.966 A:middle
Some of these relationships
can be explicit and implicit,

00:06:28.246 --> 00:06:30.256 A:middle
some of them can be
one-way or two-way,

00:06:30.326 --> 00:06:33.036 A:middle
and some of them can even
be dynamic or static.

00:06:33.106 --> 00:06:37.296 A:middle
And so these relationships can
get very, very complicated.

00:06:39.176 --> 00:06:41.046 A:middle
So what happens when we try

00:06:41.046 --> 00:06:45.446 A:middle
and test just the
dream type on its own?

00:06:45.666 --> 00:06:49.496 A:middle
Well, even if you create a
dream that stands by itself,

00:06:50.406 --> 00:06:53.136 A:middle
this doesn't reflect
the reality in the app

00:06:53.196 --> 00:06:54.406 A:middle
because there are
many more dependencies

00:06:54.406 --> 00:06:54.976 A:middle
that actually exist.

00:07:00.606 --> 00:07:01.746 A:middle
And so that's not good.

00:07:06.786 --> 00:07:09.846 A:middle
And so we can solve this by
making our dream type a struct

00:07:09.846 --> 00:07:11.246 A:middle
which has value semantics.

00:07:12.536 --> 00:07:15.106 A:middle
This means each variable
has independent storage.

00:07:15.226 --> 00:07:16.776 A:middle
So changing the value

00:07:16.776 --> 00:07:19.096 A:middle
in one doesn't change
the value in the other.

00:07:19.096 --> 00:07:22.886 A:middle
And so if we modify
dream2's description,

00:07:23.886 --> 00:07:26.966 A:middle
we only change dream2's
description, not dream1's.

00:07:28.116 --> 00:07:31.376 A:middle
And so this guarantees us
that dreams aren't involved

00:07:31.376 --> 00:07:33.746 A:middle
in the complicated relationships
that we saw earlier.

00:07:34.296 --> 00:07:40.326 A:middle
And so this really improves
our ability to reason locally

00:07:40.326 --> 00:07:43.306 A:middle
because no code can change
the value we're using

00:07:43.366 --> 00:07:46.776 A:middle
from underneath our control.

00:07:46.846 --> 00:07:49.346 A:middle
Now using value types --

00:07:49.346 --> 00:07:50.986 A:middle
So we just saw how
we can take advantage

00:07:51.076 --> 00:07:53.236 A:middle
of value types in
the model layer.

00:07:54.016 --> 00:07:55.446 A:middle
And using value types

00:07:55.446 --> 00:07:57.816 A:middle
in the model layer is actually
pretty uncontroversial.

00:07:58.836 --> 00:08:01.326 A:middle
But wouldn't you want to take
advantage of the same benefits

00:07:58.836 --> 00:08:01.326 A:middle
But wouldn't you want to take
advantage of the same benefits

00:08:01.326 --> 00:08:03.936 A:middle
that we just saw in other
parts of our application?

00:08:04.486 --> 00:08:07.346 A:middle
And that might actually
raise a few eyebrows.

00:08:07.346 --> 00:08:10.906 A:middle
So I want to share with you
a quote that I recently saw

00:08:10.906 --> 00:08:14.306 A:middle
on the Internet and that
said, "Use values only

00:08:14.306 --> 00:08:16.286 A:middle
for simple model types."

00:08:17.056 --> 00:08:18.596 A:middle
That doesn't seem encouraging.

00:08:19.816 --> 00:08:22.986 A:middle
But do we believe everything
that we read on the Internet?

00:08:22.986 --> 00:08:27.226 A:middle
And the answer is no, if you
didn't know [audience laughter].

00:08:27.876 --> 00:08:32.566 A:middle
And so for the remainder of
the talk, we're going to focus

00:08:32.566 --> 00:08:34.736 A:middle
on how you can use
value types for more

00:08:34.736 --> 00:08:36.666 A:middle
than just simply model
data in your app,

00:08:36.666 --> 00:08:38.976 A:middle
and at the same time we'll
prove the Internet wrong.

00:08:44.686 --> 00:08:45.076 A:middle
There we go.

00:08:46.116 --> 00:08:48.216 A:middle
And with that, I'd like
to hand it over to Jacob

00:08:48.216 --> 00:08:48.976 A:middle
to talk about the view layer.

00:08:49.516 --> 00:08:56.596 A:middle
[ Applause ]

00:08:57.096 --> 00:08:57.776 A:middle
&gt;&gt; Thanks, Alex.

00:08:57.956 --> 00:09:01.876 A:middle
I'm really excited to tell you

00:08:57.956 --> 00:09:01.876 A:middle
I'm really excited to tell you

00:09:01.876 --> 00:09:03.986 A:middle
about how we use
protocol-oriented programming

00:09:04.266 --> 00:09:05.286 A:middle
together with views.

00:09:06.536 --> 00:09:08.386 A:middle
So we spent a lot
of time working

00:09:08.386 --> 00:09:09.766 A:middle
on our app's table view cells.

00:09:10.896 --> 00:09:13.326 A:middle
We had a specific design for
their layout that we wanted

00:09:13.326 --> 00:09:16.076 A:middle
to implement to make sure that
the unicorn the people dreamed

00:09:16.076 --> 00:09:17.966 A:middle
about showed up exactly right.

00:09:19.226 --> 00:09:21.806 A:middle
Now when we started our
app, we wrote these layouts

00:09:21.806 --> 00:09:24.206 A:middle
as abstract subclasses
of UITableViewCell.

00:09:24.766 --> 00:09:28.546 A:middle
For example, this simple layout
we called DecoratingLayoutCell,

00:09:29.306 --> 00:09:31.016 A:middle
it just shows a small
decoration on the left

00:09:31.296 --> 00:09:33.546 A:middle
and a larger content
area on the right.

00:09:35.116 --> 00:09:38.156 A:middle
Then, we made a concrete
subclass of the layout cell

00:09:38.336 --> 00:09:40.786 A:middle
that added our specific
logic, like showing a dream.

00:09:41.596 --> 00:09:44.326 A:middle
And we did this separation
because we wanted to be able

00:09:44.326 --> 00:09:46.516 A:middle
to reuse our layouts
in different places.

00:09:47.196 --> 00:09:48.796 A:middle
But as we worked
on the app more,

00:09:49.106 --> 00:09:50.666 A:middle
we found that this
wasn't working very well.

00:09:51.466 --> 00:09:55.186 A:middle
It helped us reuse our layout in
different cells, but it was hard

00:09:55.186 --> 00:09:56.816 A:middle
to use outside of a table view.

00:09:57.776 --> 00:09:59.476 A:middle
For example, we had
a detail view

00:09:59.766 --> 00:10:01.366 A:middle
that showed more
information about a dream

00:09:59.766 --> 00:10:01.366 A:middle
that showed more
information about a dream

00:10:01.366 --> 00:10:03.636 A:middle
but we couldn't reuse
our layout cell there.

00:10:05.196 --> 00:10:07.516 A:middle
So we wanted to find a
better way to structure this

00:10:07.566 --> 00:10:10.486 A:middle
where we could use our layouts
together with table view cells

00:10:11.086 --> 00:10:12.916 A:middle
but also in plain UI views.

00:10:14.046 --> 00:10:15.836 A:middle
And we also want to add
SpriteKit to our app

00:10:15.926 --> 00:10:18.636 A:middle
to show those cool particle
effects and we want to be able

00:10:18.636 --> 00:10:19.976 A:middle
to use our layouts with
those SpriteKit nodes too.

00:10:20.386 --> 00:10:24.386 A:middle
So those are our goals
and we use what we learned

00:10:24.386 --> 00:10:25.866 A:middle
about Swift to achieve this.

00:10:26.996 --> 00:10:29.326 A:middle
Now although I'll be talking
about layout in detail,

00:10:29.666 --> 00:10:30.716 A:middle
I want you to keep in mind

00:10:30.826 --> 00:10:33.716 A:middle
that these techniques can
be used all across your app.

00:10:34.056 --> 00:10:35.366 A:middle
All right, let's get started.

00:10:37.076 --> 00:10:39.746 A:middle
Now this is what our layout
cell looked like before.

00:10:40.496 --> 00:10:44.216 A:middle
It has two views that it lays
out, but there's really no need

00:10:44.216 --> 00:10:46.386 A:middle
for this layout logic to be
trapped inside of a cell.

00:10:47.196 --> 00:10:49.266 A:middle
It's just some math
and geometry to figure

00:10:49.266 --> 00:10:50.466 A:middle
out the right set of frames.

00:10:51.676 --> 00:10:54.866 A:middle
So let's change this from a cell
to just being a plain struct.

00:10:55.706 --> 00:10:59.406 A:middle
It will still have our two
views and we can put all

00:10:59.406 --> 00:11:02.086 A:middle
of that layout logic into a
single method that can be called

00:10:59.406 --> 00:11:02.086 A:middle
of that layout logic into a
single method that can be called

00:11:02.086 --> 00:11:04.546 A:middle
in to, to lay them out.

00:11:04.796 --> 00:11:06.266 A:middle
Now just with that small change,

00:11:06.336 --> 00:11:09.396 A:middle
we now have a really isolated
piece of code that knows how

00:11:09.396 --> 00:11:11.806 A:middle
to do our layout
and nothing else.

00:11:13.296 --> 00:11:16.376 A:middle
Then, we can update our dream
cell to use this new struct

00:11:16.476 --> 00:11:17.346 A:middle
to lay out its children.

00:11:18.536 --> 00:11:20.406 A:middle
And what's great is
that we can now use this

00:11:20.456 --> 00:11:22.056 A:middle
in our UIView subclass as well.

00:11:23.306 --> 00:11:26.136 A:middle
Now that this layout logic is
decoupled from table view cells,

00:11:26.296 --> 00:11:27.656 A:middle
we can use it in any UIView.

00:11:28.246 --> 00:11:31.536 A:middle
And there's another
great benefit with this.

00:11:32.036 --> 00:11:35.536 A:middle
Now that our layout can be used
in isolation, it's really easy

00:11:35.536 --> 00:11:37.806 A:middle
for us to run a unit
test for it.

00:11:38.046 --> 00:11:41.566 A:middle
We can just create some
views, add them to our layout,

00:11:41.636 --> 00:11:44.506 A:middle
and then lay them
out in a known rect.

00:11:46.056 --> 00:11:47.436 A:middle
Then, we just have to verify

00:11:47.496 --> 00:11:49.406 A:middle
that the resulting frames
are what we expected.

00:11:49.546 --> 00:11:52.776 A:middle
Our test doesn't have to
create a table view or wait

00:11:52.776 --> 00:11:54.516 A:middle
for the right view layout
callbacks to happen.

00:11:54.516 --> 00:11:57.686 A:middle
It can just tell our layout to
work and then verify the output.

00:11:58.556 --> 00:12:00.806 A:middle
And this is part of a general
benefit that we have now.

00:11:58.556 --> 00:12:00.806 A:middle
And this is part of a general
benefit that we have now.

00:12:01.806 --> 00:12:04.486 A:middle
Our new layout struct is
really small and focused.

00:12:05.076 --> 00:12:06.246 A:middle
This change has made
it much easier

00:12:06.246 --> 00:12:07.766 A:middle
to reason locally
about this code.

00:12:08.926 --> 00:12:11.166 A:middle
So if we want to understand
our tests to our layout,

00:12:11.516 --> 00:12:14.336 A:middle
we just have to understand
that small struct in isolation.

00:12:14.336 --> 00:12:16.326 A:middle
We don't have to
think about what set

00:12:16.326 --> 00:12:18.866 A:middle
of view capabilities it
might use or override.

00:12:19.516 --> 00:12:24.686 A:middle
Okay, now let's go back to
our DecoratingLayout code.

00:12:25.716 --> 00:12:29.126 A:middle
So right now, this still only
knows how to lay out views.

00:12:29.286 --> 00:12:31.106 A:middle
But as I said earlier,
we want to use this

00:12:31.106 --> 00:12:32.506 A:middle
to support SpriteKit as well.

00:12:32.586 --> 00:12:36.196 A:middle
So we don't want to have
to duplicate this code,

00:12:36.506 --> 00:12:38.726 A:middle
but SKNode is not a
subclass of UIView.

00:12:39.046 --> 00:12:41.586 A:middle
So there's no common
superclass that we can use here.

00:12:42.216 --> 00:12:45.186 A:middle
So how can we combine these
together into a single layout?

00:12:45.246 --> 00:12:48.606 A:middle
Well since the only thing
that our layout ever does

00:12:48.606 --> 00:12:50.496 A:middle
with these children is
to set their frames,

00:12:50.846 --> 00:12:53.886 A:middle
that's the only functionality
that we need them to have.

00:12:53.886 --> 00:12:56.316 A:middle
And we can represent that
requirement with a protocol.

00:12:57.686 --> 00:12:58.966 A:middle
So we'll make the protocol

00:12:59.036 --> 00:13:01.076 A:middle
and it'll just have a single
frame property for now.

00:12:59.036 --> 00:13:01.076 A:middle
and it'll just have a single
frame property for now.

00:13:01.646 --> 00:13:03.086 A:middle
This isn't very flushed out yet,

00:13:03.196 --> 00:13:05.936 A:middle
but we'll improve
it in a little bit.

00:13:06.156 --> 00:13:08.326 A:middle
Then, we use this
protocol as the type

00:13:08.326 --> 00:13:10.906 A:middle
of our children instead
of making them views.

00:13:11.426 --> 00:13:16.006 A:middle
And finally, we can use
retroactive modeling

00:13:16.236 --> 00:13:19.316 A:middle
to make UIView and SKNode
conform to our new protocol.

00:13:20.376 --> 00:13:22.876 A:middle
And now we have a layout that
works with both of these types,

00:13:23.386 --> 00:13:25.186 A:middle
and this is one of the
great things about relying

00:13:25.186 --> 00:13:28.076 A:middle
on protocols instead of
superclasses for polymorphism.

00:13:28.806 --> 00:13:30.836 A:middle
We can use this, add
this functionality

00:13:30.836 --> 00:13:34.646 A:middle
to unrelated types
to use both of them.

00:13:34.856 --> 00:13:37.296 A:middle
Now, our layouts no longer
have any dependencies

00:13:37.296 --> 00:13:38.256 A:middle
on UIKit as well.

00:13:38.886 --> 00:13:40.786 A:middle
And so another thing that we
could do is bring this same

00:13:40.786 --> 00:13:42.686 A:middle
system to AppKit
and support laying

00:13:42.686 --> 00:13:44.466 A:middle
out NS views just as easily.

00:13:44.836 --> 00:13:47.656 A:middle
I think that's pretty cool.

00:13:47.856 --> 00:13:49.386 A:middle
So we're really close now,

00:13:49.646 --> 00:13:51.796 A:middle
but there's something
here that we can improve.

00:13:53.316 --> 00:13:55.506 A:middle
When we're using a
DecoratingLayout in a view,

00:13:55.506 --> 00:13:58.696 A:middle
we want to be able to add all
of its content as subviews.

00:13:59.346 --> 00:14:01.646 A:middle
And similarly, when we're
using it in a SpriteKit scene,

00:13:59.346 --> 00:14:01.646 A:middle
And similarly, when we're
using it in a SpriteKit scene,

00:14:02.116 --> 00:14:04.396 A:middle
we want to be able to add
our content as child nodes.

00:14:05.366 --> 00:14:06.646 A:middle
But right now, content

00:14:06.646 --> 00:14:08.946 A:middle
and decoration can be any
type that has a frame.

00:14:09.746 --> 00:14:12.756 A:middle
And that means that for
example we could have content

00:14:12.756 --> 00:14:15.766 A:middle
that was a UIView and
decoration that was an SKNode.

00:14:16.436 --> 00:14:19.886 A:middle
But instead, we want our
layout to just have a set

00:14:19.886 --> 00:14:22.626 A:middle
of only UI views or only
SK nodes as its children.

00:14:23.226 --> 00:14:25.626 A:middle
And that way we'll
be able to add them

00:14:25.696 --> 00:14:27.096 A:middle
to their appropriate parent.

00:14:28.416 --> 00:14:31.056 A:middle
Now Swift has a great way of
expressing that with generics.

00:14:32.336 --> 00:14:34.366 A:middle
So we can update our
layout to be a generic type

00:14:34.956 --> 00:14:36.456 A:middle
with a type parameter
called child.

00:14:37.676 --> 00:14:40.176 A:middle
Then, we can make the content

00:14:40.176 --> 00:14:42.666 A:middle
and decoration properties
use that as their type.

00:14:42.666 --> 00:14:45.416 A:middle
And this gives us
exactly what we want.

00:14:45.546 --> 00:14:47.466 A:middle
We can enforce that they're
the same concrete type.

00:14:48.306 --> 00:14:49.766 A:middle
And so we can have
DecoratingLayout

00:14:49.816 --> 00:14:52.936 A:middle
with just UI views or one
that just contains SK nodes.

00:14:53.496 --> 00:14:54.546 A:middle
So generics are a great tool

00:14:54.546 --> 00:14:56.256 A:middle
that let us have
a lot more control

00:14:56.256 --> 00:14:57.336 A:middle
over the types in our code.

00:14:58.646 --> 00:15:00.406 A:middle
Another great benefit
of generics is

00:14:58.646 --> 00:15:00.406 A:middle
Another great benefit
of generics is

00:15:00.406 --> 00:15:02.086 A:middle
that the compiler
has more information

00:15:02.126 --> 00:15:03.266 A:middle
about what your code is doing.

00:15:03.726 --> 00:15:04.896 A:middle
So it can optimize more.

00:15:05.906 --> 00:15:08.076 A:middle
And you can learn about
this in a lot more detail

00:15:08.076 --> 00:15:09.746 A:middle
in the Understanding
Swift Performance talk.

00:15:10.456 --> 00:15:12.786 A:middle
It's a great talk for learning
how Swift works and how

00:15:12.786 --> 00:15:16.166 A:middle
to write fast Swift code.

00:15:16.926 --> 00:15:18.946 A:middle
Okay, we now have a
great implementation

00:15:18.946 --> 00:15:19.996 A:middle
of our DecoratingLayout.

00:15:20.776 --> 00:15:22.756 A:middle
But our app also includes
a lot of other layouts,

00:15:23.586 --> 00:15:24.966 A:middle
like this fancy cascading one.

00:15:25.506 --> 00:15:27.826 A:middle
And this layout is very
similar to the DecoratingLayout

00:15:27.826 --> 00:15:29.876 A:middle
that we just looked at.

00:15:30.216 --> 00:15:31.906 A:middle
They both show a large
area on the right

00:15:32.406 --> 00:15:34.176 A:middle
with a detailed decoration
on the left.

00:15:34.176 --> 00:15:36.696 A:middle
And we don't want to
copy and paste our code

00:15:36.696 --> 00:15:37.706 A:middle
to create this new layout

00:15:38.366 --> 00:15:39.776 A:middle
because that would miss
a great opportunity

00:15:39.776 --> 00:15:42.246 A:middle
to create a shared abstraction
that both of these can use.

00:15:43.156 --> 00:15:44.656 A:middle
So how can we share
this code instead?

00:15:44.656 --> 00:15:47.486 A:middle
Well, one tool you've
probably all used before

00:15:47.486 --> 00:15:48.996 A:middle
to share code is inheritance.

00:15:49.536 --> 00:15:51.896 A:middle
But with inheritance,
you have both your code,

00:15:52.006 --> 00:15:54.676 A:middle
and please don't try to read
this code, but you also have

00:15:54.676 --> 00:15:56.806 A:middle
to consider what your
superclass might be doing

00:15:57.436 --> 00:15:59.856 A:middle
and what your subclasses might
want to change or override.

00:16:00.556 --> 00:16:01.906 A:middle
So instead of just
thinking about the code

00:16:01.906 --> 00:16:03.466 A:middle
that you're working
with, your mind has

00:16:03.466 --> 00:16:05.186 A:middle
to pull together a large amount

00:16:05.186 --> 00:16:06.466 A:middle
of code that's spread
across your app.

00:16:07.156 --> 00:16:08.636 A:middle
And this is just the
tip of the iceberg.

00:16:08.636 --> 00:16:12.086 A:middle
A lot of the time you also
inherit from a framework class,

00:16:12.086 --> 00:16:14.646 A:middle
like UIView or view
controller and there's orders

00:16:14.646 --> 00:16:15.906 A:middle
of magnitude more code there.

00:16:17.076 --> 00:16:18.756 A:middle
So inheritance is another place

00:16:18.756 --> 00:16:21.276 A:middle
where you really sacrifice the
ability to use local reasoning.

00:16:24.616 --> 00:16:27.776 A:middle
But we can share code in a much
better way by using composition.

00:16:28.956 --> 00:16:31.786 A:middle
Composition is a simple idea
that's just combining smaller

00:16:31.786 --> 00:16:33.616 A:middle
pieces together to
build larger pieces.

00:16:34.286 --> 00:16:36.966 A:middle
But when composing, you can
understand those independent

00:16:36.966 --> 00:16:38.196 A:middle
pieces in isolation.

00:16:39.156 --> 00:16:41.696 A:middle
And you can also enforce
encapsulation without worrying

00:16:41.696 --> 00:16:44.496 A:middle
about subclasses or
superclasses poking holes

00:16:44.496 --> 00:16:45.556 A:middle
in your abstractions.

00:16:46.896 --> 00:16:48.186 A:middle
But composition isn't
new either.

00:16:49.206 --> 00:16:50.466 A:middle
You've probably used in the past

00:16:50.466 --> 00:16:52.226 A:middle
with Objective-C
or other languages.

00:16:53.576 --> 00:16:56.136 A:middle
And one way that we could've
made this layout before would be

00:16:56.136 --> 00:16:57.256 A:middle
to compose views together.

00:16:58.016 --> 00:16:59.856 A:middle
So you could've written a UIView

00:16:59.856 --> 00:17:03.386 A:middle
that does this cascading layout
behavior and another UIView

00:16:59.856 --> 00:17:03.386 A:middle
that does this cascading layout
behavior and another UIView

00:17:03.676 --> 00:17:04.986 A:middle
that does our decorating
layout behavior.

00:17:05.925 --> 00:17:08.006 A:middle
Then you could've added
both of those as subviews

00:17:08.006 --> 00:17:08.945 A:middle
in your table view cell.

00:17:10.076 --> 00:17:11.316 A:middle
But there's a big
problem with this.

00:17:12.256 --> 00:17:13.906 A:middle
Class instances are
very expensive.

00:17:14.546 --> 00:17:15.586 A:middle
When you make another object,

00:17:15.656 --> 00:17:17.066 A:middle
you have an extra
heap allocation

00:17:17.486 --> 00:17:19.126 A:middle
and this is even
worse with views.

00:17:19.955 --> 00:17:21.955 A:middle
There's a lot of work that's
needed to support a view

00:17:22.076 --> 00:17:24.516 A:middle
to allow to do things like
drawing and event handling.

00:17:25.215 --> 00:17:27.126 A:middle
And because of this,
we try very hard

00:17:27.126 --> 00:17:28.876 A:middle
to minimize the number
of views that we use.

00:17:29.946 --> 00:17:32.656 A:middle
So making a view that does
no drawing and only acts

00:17:32.656 --> 00:17:34.396 A:middle
as a layout abstraction
is very wasteful.

00:17:34.396 --> 00:17:36.626 A:middle
And that's why doing composition

00:17:36.626 --> 00:17:38.016 A:middle
with views doesn't
work very well.

00:17:39.256 --> 00:17:41.806 A:middle
But with Swift, we have a much
better way to do composition

00:17:41.806 --> 00:17:45.086 A:middle
and that's with value types.

00:17:45.226 --> 00:17:47.926 A:middle
Structs are very lightweight,
so we can use them together

00:17:47.976 --> 00:17:49.986 A:middle
without paying the high
heavy cost that we have

00:17:50.226 --> 00:17:51.476 A:middle
with classes and views.

00:17:52.686 --> 00:17:55.906 A:middle
And structs are also better
because of value semantics.

00:17:56.936 --> 00:17:59.246 A:middle
With value types you have
much better encapsulation

00:17:59.696 --> 00:18:02.306 A:middle
so you can use these pieces
together for composition

00:17:59.696 --> 00:18:02.306 A:middle
so you can use these pieces
together for composition

00:18:02.616 --> 00:18:03.486 A:middle
without having to worry

00:18:03.486 --> 00:18:06.076 A:middle
about someone else modifying
the copy that you're using.

00:18:07.336 --> 00:18:09.696 A:middle
So let's apply this
to our layouts.

00:18:11.096 --> 00:18:13.766 A:middle
Well, we can write the cascading
part of our layout like this,

00:18:14.366 --> 00:18:16.296 A:middle
with an array of
children that it lays out.

00:18:17.616 --> 00:18:20.646 A:middle
Then, we want to compose this
layout with our DecoratingLayout

00:18:20.946 --> 00:18:22.586 A:middle
to get the final effect.

00:18:23.156 --> 00:18:25.716 A:middle
But there's one more small
thing we have to change here.

00:18:26.586 --> 00:18:28.606 A:middle
These layouts only
expect to have children

00:18:28.606 --> 00:18:30.356 A:middle
that are UI views or SK nodes.

00:18:30.936 --> 00:18:33.616 A:middle
So let's generalize this
so that we can use layouts

00:18:33.616 --> 00:18:34.676 A:middle
and compose them together.

00:18:35.226 --> 00:18:38.616 A:middle
Well the layout protocol
that we're using

00:18:38.616 --> 00:18:40.506 A:middle
for our children
requires a frame property.

00:18:41.426 --> 00:18:43.356 A:middle
But we never need to call
the getter for that property.

00:18:43.356 --> 00:18:45.116 A:middle
We're only ever setting
new values for it.

00:18:45.936 --> 00:18:46.966 A:middle
And we don't actually care

00:18:46.966 --> 00:18:48.416 A:middle
if our children have
a frame or not.

00:18:48.926 --> 00:18:50.706 A:middle
We really just want to
be able to tell our child

00:18:50.796 --> 00:18:53.066 A:middle
to lay itself out
in a given rect.

00:18:53.676 --> 00:18:55.936 A:middle
So let's change this to a
method that reflects that.

00:18:55.936 --> 00:18:58.716 A:middle
When we decide a rect
for one of our children,

00:18:58.776 --> 00:19:02.246 A:middle
we'll tell that child
to lay out in that rect.

00:18:58.776 --> 00:19:02.246 A:middle
we'll tell that child
to lay out in that rect.

00:19:02.636 --> 00:19:05.586 A:middle
UIView and SKNode can still
conform to our protocol.

00:19:06.276 --> 00:19:07.556 A:middle
When they're asked
to layout in a rect,

00:19:07.826 --> 00:19:09.216 A:middle
they'll just use it
to set their frame.

00:19:10.116 --> 00:19:12.306 A:middle
But now we can make
our layouts conform

00:19:12.306 --> 00:19:13.406 A:middle
to this protocol as well.

00:19:13.856 --> 00:19:15.326 A:middle
They already know
how to do layout.

00:19:15.576 --> 00:19:17.896 A:middle
When they're given a frame,
they just divide up that rect

00:19:18.026 --> 00:19:21.796 A:middle
and give it to their children.

00:19:21.796 --> 00:19:24.916 A:middle
Now we also need to make one
small change to DecoratingLayout

00:19:24.996 --> 00:19:26.516 A:middle
to allow it to have
more flexibility

00:19:26.516 --> 00:19:27.526 A:middle
in the types of its children.

00:19:27.526 --> 00:19:30.066 A:middle
And we'll look at that in
detail a little bit later.

00:19:31.876 --> 00:19:35.196 A:middle
So now we can build
our fancy layout

00:19:35.196 --> 00:19:38.556 A:middle
by composing together a
CascadingLayout together

00:19:38.626 --> 00:19:40.346 A:middle
with a Decorating Layout.

00:19:42.696 --> 00:19:45.566 A:middle
The composition lets us build
advanced layouts like this

00:19:45.916 --> 00:19:48.896 A:middle
in a very declarative way and
there's even more examples

00:19:48.896 --> 00:19:50.076 A:middle
of this in the sample code.

00:19:51.636 --> 00:19:53.866 A:middle
So when you're working on your
own app, the next time you need

00:19:53.866 --> 00:19:56.186 A:middle
to reuse code or
customize some behavior,

00:19:56.516 --> 00:19:57.536 A:middle
trying using Composition.

00:19:57.886 --> 00:19:58.566 A:middle
It's a great tool.

00:20:01.316 --> 00:20:03.886 A:middle
So earlier I mentioned
that we wanted to be able

00:20:03.886 --> 00:20:05.726 A:middle
to add the contents
of our layouts

00:20:05.846 --> 00:20:08.046 A:middle
to either a superview
or a SpriteKit scene.

00:20:08.616 --> 00:20:11.206 A:middle
And an important part of
that is adding those contents

00:20:11.256 --> 00:20:11.986 A:middle
in the right order.

00:20:12.766 --> 00:20:16.366 A:middle
For example, our CascadingLayout
wants its children to be ordered

00:20:16.366 --> 00:20:19.526 A:middle
so that they line up on top
of each other, like this.

00:20:20.436 --> 00:20:23.426 A:middle
So let's expand our protocol to
be able to support that as well.

00:20:24.706 --> 00:20:27.616 A:middle
We'll add a property to our
layout protocol to be able

00:20:27.616 --> 00:20:28.826 A:middle
to return its contents.

00:20:29.796 --> 00:20:32.386 A:middle
And our combining layouts will
return all of their contents

00:20:32.446 --> 00:20:33.796 A:middle
in the correct order from this.

00:20:34.476 --> 00:20:37.176 A:middle
And then leaf views and nodes
can just return themselves.

00:20:38.616 --> 00:20:40.416 A:middle
But once again, if
we make the type

00:20:40.416 --> 00:20:43.356 A:middle
of the contents just be our
protocol, this would allow

00:20:43.356 --> 00:20:45.286 A:middle
for mixed environments
of UI views

00:20:45.286 --> 00:20:46.786 A:middle
and SK nodes as the contents.

00:20:47.596 --> 00:20:49.506 A:middle
And since we're adding
these children to a parent,

00:20:49.906 --> 00:20:51.786 A:middle
we only want to allow
a homogenous collection

00:20:51.896 --> 00:20:54.306 A:middle
of just UI views
or just SK nodes.

00:20:54.816 --> 00:20:58.686 A:middle
So to enforce this, we
can add an associated type

00:20:58.766 --> 00:20:59.426 A:middle
to our protocol.

00:20:59.876 --> 00:21:02.566 A:middle
An associated type is
like a type placeholder.

00:20:59.876 --> 00:21:02.566 A:middle
An associated type is
like a type placeholder.

00:21:03.206 --> 00:21:05.156 A:middle
The conforming type
chooses the concrete type

00:21:05.236 --> 00:21:06.256 A:middle
that it wants to use.

00:21:07.356 --> 00:21:09.246 A:middle
So our protocol's
associated type is

00:21:09.246 --> 00:21:10.626 A:middle
for what we'll be
putting in the array

00:21:10.626 --> 00:21:12.666 A:middle
of contents that our layout has.

00:21:13.256 --> 00:21:15.986 A:middle
This allows us to write
something that just knows how

00:21:15.986 --> 00:21:19.326 A:middle
to lay out views and specify
that its content type is UIView.

00:21:20.346 --> 00:21:21.936 A:middle
And similarly, we
can write layouts

00:21:21.936 --> 00:21:24.056 A:middle
that only have SK nodes
as their contents.

00:21:25.026 --> 00:21:26.426 A:middle
And this type safety
is really great.

00:21:26.886 --> 00:21:28.476 A:middle
But just like before,
we don't want to have

00:21:28.476 --> 00:21:30.816 A:middle
to write a separate
layout for views and nodes.

00:21:31.686 --> 00:21:34.186 A:middle
But with the generic
version of our layouts,

00:21:34.316 --> 00:21:36.856 A:middle
we can still have a single
layout that supports both.

00:21:37.716 --> 00:21:38.696 A:middle
And for our content type,

00:21:39.116 --> 00:21:41.416 A:middle
we'll just use whatever the
content of our child is.

00:21:42.026 --> 00:21:45.306 A:middle
And this means that we can make
a DecoratingLayout that works

00:21:45.306 --> 00:21:48.396 A:middle
with just UI views and one
that works with just SK nodes.

00:21:48.936 --> 00:21:51.636 A:middle
Both are strongly typed so that
we can pull out their contents

00:21:51.756 --> 00:21:52.996 A:middle
and know exactly what they are

00:21:53.136 --> 00:21:55.366 A:middle
and they can still share
all of the layout logic.

00:21:56.576 --> 00:21:58.196 A:middle
So associated types
are a great way

00:21:58.196 --> 00:21:59.976 A:middle
that you make your
protocols even more powerful.

00:22:05.136 --> 00:22:07.346 A:middle
So now that we have our
improved layout protocol,

00:22:07.526 --> 00:22:10.456 A:middle
we can also revisit the types of
our DecoratingLayout's children.

00:22:11.616 --> 00:22:13.246 A:middle
Now here they're
required to be the same.

00:22:13.856 --> 00:22:17.566 A:middle
And this works great if they're
both UI views but not if we want

00:22:17.566 --> 00:22:20.006 A:middle
to have a CascadingLayout
together with a UIView,

00:22:20.246 --> 00:22:21.996 A:middle
like we talked about
earlier for composition.

00:22:23.436 --> 00:22:26.306 A:middle
What we really want here
is for all of the contents

00:22:26.366 --> 00:22:27.236 A:middle
to have the same type.

00:22:28.266 --> 00:22:31.036 A:middle
So let's update our
layouts to reflect that.

00:22:31.536 --> 00:22:34.526 A:middle
We can change our struct to
have two different generic type

00:22:34.526 --> 00:22:37.046 A:middle
parameters, one for
each of its children.

00:22:38.296 --> 00:22:41.586 A:middle
Then, we can also add a
generic constraint to require

00:22:41.586 --> 00:22:43.666 A:middle
that those two types have
the same kind of contents.

00:22:44.536 --> 00:22:47.216 A:middle
And this lets us express the
exact restrictions that we want.

00:22:47.596 --> 00:22:49.756 A:middle
Our children's content
must be the same type.

00:22:50.306 --> 00:22:53.596 A:middle
So this is our finished
protocol,

00:22:54.096 --> 00:22:55.546 A:middle
which represents our
layout abstraction,

00:22:56.106 --> 00:22:57.806 A:middle
and this is a much
better protocol

00:22:57.806 --> 00:22:58.666 A:middle
that what we had earlier.

00:22:59.346 --> 00:23:00.486 A:middle
This now has real meaning.

00:22:59.346 --> 00:23:00.486 A:middle
This now has real meaning.

00:23:01.046 --> 00:23:02.546 A:middle
It's a complete set
of operations

00:23:02.836 --> 00:23:05.476 A:middle
that represent what it means to
be a part of the layout process.

00:23:06.356 --> 00:23:09.446 A:middle
You can also see our sample
app to learn all of the details

00:23:09.446 --> 00:23:12.126 A:middle
about how all this works,
including how we also used it

00:23:12.426 --> 00:23:16.366 A:middle
to do layout for rendering
images on a background thread.

00:23:16.956 --> 00:23:18.906 A:middle
And one last place that
we can also take advantage

00:23:18.906 --> 00:23:21.706 A:middle
of our new layout protocol
is in our unit tests.

00:23:22.316 --> 00:23:24.776 A:middle
So we can write a struct
that has a frame property

00:23:25.466 --> 00:23:26.946 A:middle
and conforms to our
layout protocol

00:23:27.826 --> 00:23:30.686 A:middle
and then we can change our
unit test to use this instead

00:23:30.686 --> 00:23:32.676 A:middle
of UI views as the
children in our layout.

00:23:33.876 --> 00:23:35.746 A:middle
Now our layouts will
just be setting frames

00:23:35.746 --> 00:23:36.836 A:middle
on these simple structs.

00:23:37.856 --> 00:23:41.066 A:middle
And this means that our test is
completely isolated from UIView

00:23:41.316 --> 00:23:44.826 A:middle
and only relies on the logic in
our own layout and test structs.

00:23:45.506 --> 00:23:48.576 A:middle
So we're unit testing our
layout without using the GUI.

00:23:48.866 --> 00:23:50.256 A:middle
I think Crusty would be proud.

00:23:51.516 --> 00:23:57.986 A:middle
[ Applause ]

00:23:58.486 --> 00:24:01.876 A:middle
So those are some examples
of how you can use types

00:23:58.486 --> 00:24:01.876 A:middle
So those are some examples
of how you can use types

00:24:01.876 --> 00:24:04.016 A:middle
and protocols in ways you
might not have expected

00:24:04.286 --> 00:24:05.846 A:middle
in the view layer of your app.

00:24:06.436 --> 00:24:08.796 A:middle
And we also saw some great
general Swift techniques

00:24:08.796 --> 00:24:10.016 A:middle
that you can apply anywhere.

00:24:10.676 --> 00:24:13.616 A:middle
First, we looked at how you
can improve local reasoning

00:24:13.946 --> 00:24:15.006 A:middle
by using value types.

00:24:15.986 --> 00:24:18.296 A:middle
Then, we saw how you
can use generic types

00:24:18.406 --> 00:24:20.556 A:middle
to get better type
safety and flexible code.

00:24:21.186 --> 00:24:24.836 A:middle
And we also saw how composition
of values is a great tool

00:24:24.836 --> 00:24:28.126 A:middle
for customizing and building
up complex behaviors.

00:24:29.066 --> 00:24:31.596 A:middle
Now I'd like to bring Alex
back to tell you what we did

00:24:31.596 --> 00:24:32.906 A:middle
with controllers in our app.

00:24:33.516 --> 00:24:37.500 A:middle
[ Applause ]

00:24:42.556 --> 00:24:43.386 A:middle
&gt;&gt; Thanks, Jacob.

00:24:44.506 --> 00:24:47.036 A:middle
Now I'd like to focus on
how we can use value types

00:24:47.036 --> 00:24:48.026 A:middle
in the controller layer.

00:24:48.026 --> 00:24:50.516 A:middle
And we're going to talk
about this in the context

00:24:50.516 --> 00:24:52.796 A:middle
of our app's Undo functionality.

00:24:54.696 --> 00:24:58.326 A:middle
So we implemented Undo
for our list of dreams

00:24:58.436 --> 00:25:01.606 A:middle
and that worked really
great, but we noticed

00:24:58.436 --> 00:25:01.606 A:middle
and that worked really
great, but we noticed

00:25:01.926 --> 00:25:04.736 A:middle
that we had a small bug
where Undo doesn't work

00:25:04.736 --> 00:25:06.126 A:middle
for our favorite
creature feature.

00:25:07.106 --> 00:25:10.726 A:middle
Now to reproduce this, we can
tap the Favorite Creature row.

00:25:11.346 --> 00:25:14.346 A:middle
Right now we have
our pink unicorn set

00:25:14.346 --> 00:25:16.446 A:middle
as our favorite creature
but let's change

00:25:16.446 --> 00:25:17.496 A:middle
that to be the dragon.

00:25:18.046 --> 00:25:20.396 A:middle
And to finish the change,

00:25:20.396 --> 00:25:24.986 A:middle
we can just tap the Done
button at the top right.

00:25:24.986 --> 00:25:27.636 A:middle
All right, so we've modified
the favorite creature

00:25:28.006 --> 00:25:31.376 A:middle
but the problem is that if we
shake to Undo, nothing happens.

00:25:32.436 --> 00:25:33.486 A:middle
And so that's a bug.

00:25:33.886 --> 00:25:35.736 A:middle
So let's take a look
at our code and see why

00:25:35.736 --> 00:25:36.646 A:middle
that actually happened.

00:25:37.046 --> 00:25:40.196 A:middle
So we have two model properties

00:25:40.196 --> 00:25:43.786 A:middle
on our view controller right
now: one for our dreams and one

00:25:43.786 --> 00:25:44.916 A:middle
for our favorite creature.

00:25:45.616 --> 00:25:48.446 A:middle
This is a pretty typical
arrangement in the UIKit app,

00:25:48.786 --> 00:25:51.816 A:middle
especially as they grow larger
and your feature set grows.

00:25:52.306 --> 00:25:57.026 A:middle
And so again we started off with
just our dreams functionality

00:25:57.386 --> 00:25:58.906 A:middle
and so we implemented
Undo for that

00:25:58.906 --> 00:26:00.256 A:middle
and it worked, which was great.

00:25:58.906 --> 00:26:00.256 A:middle
and it worked, which was great.

00:26:01.086 --> 00:26:03.876 A:middle
But after we added the
Favorite Creature functionality,

00:26:04.076 --> 00:26:05.406 A:middle
we didn't have that Undo code.

00:26:05.906 --> 00:26:09.156 A:middle
And so the bug was just
that we forgot that code.

00:26:10.166 --> 00:26:12.906 A:middle
And so to fix this, we
could've added another code path

00:26:13.816 --> 00:26:16.036 A:middle
that implemented Undo for
our favorite creature.

00:26:16.646 --> 00:26:18.286 A:middle
That sounds like a
maintenance nightmare,

00:26:18.526 --> 00:26:21.276 A:middle
because now every time we
add another model property,

00:26:21.916 --> 00:26:24.846 A:middle
we have to add another code
path to implement Undo.

00:26:25.276 --> 00:26:26.726 A:middle
And so that doesn't seem good.

00:26:27.286 --> 00:26:28.436 A:middle
So we don't want that.

00:26:28.436 --> 00:26:32.806 A:middle
And so after that we took a
step back and wanted to figure

00:26:32.806 --> 00:26:34.736 A:middle
out a solution that
would [inaudible] better

00:26:34.776 --> 00:26:36.906 A:middle
as we add more model properties.

00:26:37.456 --> 00:26:41.936 A:middle
And so the solution is to
compose these model properties

00:26:42.216 --> 00:26:44.996 A:middle
into a single value,
our model struct.

00:26:45.656 --> 00:26:47.766 A:middle
And our undo logic is
going to work solely

00:26:47.766 --> 00:26:49.126 A:middle
in terms of that one type.

00:26:49.646 --> 00:26:51.656 A:middle
Note it's really important

00:26:51.656 --> 00:26:54.606 A:middle
that our model still have
value semantics and that's

00:26:54.606 --> 00:26:56.636 A:middle
because it's composed
of two other values.

00:26:57.536 --> 00:26:59.886 A:middle
And so this approach
is really great

00:27:00.076 --> 00:27:02.156 A:middle
because we now have
only a single code path

00:27:02.156 --> 00:27:04.316 A:middle
for our two model properties,

00:27:04.526 --> 00:27:06.536 A:middle
and if we add another
model property,

00:27:06.536 --> 00:27:07.856 A:middle
we still just have
one code path.

00:27:07.856 --> 00:27:08.976 A:middle
And so this is really great.

00:27:13.866 --> 00:27:16.056 A:middle
And so we can accomplish
this in code

00:27:16.056 --> 00:27:17.656 A:middle
by moving our two
model properties

00:27:17.656 --> 00:27:20.436 A:middle
on our view controller
into our new model struct.

00:27:21.656 --> 00:27:24.366 A:middle
And from there, all we have to
do is add a new model property

00:27:24.366 --> 00:27:25.256 A:middle
to the view controller.

00:27:25.826 --> 00:27:29.396 A:middle
So that's how we're going to
structure it, but now we need

00:27:29.396 --> 00:27:30.786 A:middle
to implement the Undo code.

00:27:31.386 --> 00:27:32.446 A:middle
So how do we do that?

00:27:33.076 --> 00:27:35.846 A:middle
Well, I want to show you first
the way that it's commonly done

00:27:35.846 --> 00:27:37.266 A:middle
and we'll see why
it's a little buggy.

00:27:37.806 --> 00:27:42.286 A:middle
And so on the left, we have
our view controller's current

00:27:42.286 --> 00:27:43.006 A:middle
model value.

00:27:43.636 --> 00:27:46.216 A:middle
And on the right, we have our
operations and our undo stack.

00:27:47.406 --> 00:27:49.206 A:middle
Now in the original
version of our app,

00:27:49.326 --> 00:27:52.466 A:middle
we thought of the undo stack
as a sequence of small steps.

00:27:52.986 --> 00:27:56.056 A:middle
Each step was responsible
for modifying first the model

00:27:56.376 --> 00:27:59.646 A:middle
and then the view to match.

00:27:59.826 --> 00:28:01.896 A:middle
For example, in the
first undo step,

00:27:59.826 --> 00:28:01.896 A:middle
For example, in the
first undo step,

00:28:02.156 --> 00:28:04.306 A:middle
we're going to remove the
dream that the user just added

00:28:04.366 --> 00:28:06.816 A:middle
and then we're going to delete
the row in that tableView.

00:28:07.106 --> 00:28:12.306 A:middle
And we can continue
with the next undo step.

00:28:12.806 --> 00:28:19.536 A:middle
And so in this undo step,
we're going to change the model

00:28:20.066 --> 00:28:21.636 A:middle
to be back to a pink unicorn.

00:28:22.166 --> 00:28:26.176 A:middle
And so this approach of mutating
individual model properties

00:28:26.176 --> 00:28:28.876 A:middle
and updating our view
independently is really easy

00:28:28.876 --> 00:28:31.896 A:middle
to get wrong and that's because
you need to match the change

00:28:31.896 --> 00:28:35.426 A:middle
in the model to the change
in the view, precisely.

00:28:36.286 --> 00:28:39.466 A:middle
And so failing to do so leads
to a lot of inconsistencies

00:28:39.466 --> 00:28:42.526 A:middle
between your model and
your view, and so you end

00:28:42.526 --> 00:28:43.706 A:middle
up with bugs like this.

00:28:44.776 --> 00:28:47.096 A:middle
And I'm sure all of
you have run into this.

00:28:47.096 --> 00:28:48.506 A:middle
I run into this all the time.

00:28:49.646 --> 00:28:50.826 A:middle
And it's really hard to debug.

00:28:50.826 --> 00:28:53.156 A:middle
But why is it hard to debug?

00:28:54.486 --> 00:28:55.636 A:middle
Well, let's take another look

00:28:55.906 --> 00:28:58.326 A:middle
at our Undo stack
that we started with.

00:28:58.916 --> 00:29:02.226 A:middle
Where do these undoable
changes actually come from?

00:28:58.916 --> 00:29:02.226 A:middle
Where do these undoable
changes actually come from?

00:29:03.216 --> 00:29:07.386 A:middle
Well, each undoable change
comes from our view controller

00:29:07.866 --> 00:29:11.356 A:middle
and each of those undoable
changes matters for order.

00:29:12.156 --> 00:29:14.096 A:middle
And as we add features
to our app,

00:29:14.196 --> 00:29:16.896 A:middle
these opportunities
for mistakes spread.

00:29:18.086 --> 00:29:21.176 A:middle
And so there isn't one place
in our code where we can reason

00:29:21.176 --> 00:29:24.156 A:middle
about the correspondence between
our model and our view updates.

00:29:24.806 --> 00:29:26.906 A:middle
And so this is bad because
it's really complicated.

00:29:26.906 --> 00:29:32.286 A:middle
So let's think about a
simpler way to handle undo.

00:29:32.826 --> 00:29:37.146 A:middle
What if instead of
recording small changes,

00:29:38.686 --> 00:29:41.456 A:middle
each entry in the stack
is just a whole new value,

00:29:41.456 --> 00:29:44.896 A:middle
a whole new model and so
now performing an undo

00:29:44.896 --> 00:29:46.406 A:middle
on the model is really simple.

00:29:47.076 --> 00:29:49.426 A:middle
Just replace the current model
with the one on the stack

00:29:50.406 --> 00:29:52.656 A:middle
and that way we don't even
need to worry about order.

00:29:52.656 --> 00:29:55.476 A:middle
And then we just
replace the value.

00:29:55.476 --> 00:29:59.846 A:middle
And so now that we have that
sorted out with our model,

00:29:59.846 --> 00:30:02.116 A:middle
we need to figure out how
we're going to update our UI.

00:29:59.846 --> 00:30:02.116 A:middle
we need to figure out how
we're going to update our UI.

00:30:02.396 --> 00:30:07.556 A:middle
And so in our view controller,
whenever a model changes,

00:30:07.556 --> 00:30:09.616 A:middle
we're going to call this
modelDidChange method.

00:30:10.866 --> 00:30:13.946 A:middle
Now, I recommend you go
download this sample and look

00:30:13.946 --> 00:30:16.686 A:middle
at this method for more
information about how it works.

00:30:16.686 --> 00:30:19.836 A:middle
But in that method, we need
to find the differences

00:30:19.836 --> 00:30:21.926 A:middle
between the old and
the new model values

00:30:22.016 --> 00:30:23.576 A:middle
and update our UI to match.

00:30:24.626 --> 00:30:26.866 A:middle
So for example, we
can check to see

00:30:26.866 --> 00:30:29.646 A:middle
if the old model's favorite
creature is different

00:30:29.946 --> 00:30:31.946 A:middle
than the new model's
favorite creature.

00:30:33.056 --> 00:30:35.586 A:middle
And if it is, we're going to
update our table view section

00:30:35.586 --> 00:30:38.466 A:middle
that contains the
Favorite Creature row.

00:30:40.266 --> 00:30:44.026 A:middle
And there's a more flushed out
implementation in the project,

00:30:44.026 --> 00:30:46.416 A:middle
like I just mentioned, so I
recommend you check out more

00:30:46.416 --> 00:30:49.616 A:middle
of the UI that we
update in there.

00:30:49.836 --> 00:30:52.376 A:middle
And finally, we can just
register the undo logic

00:30:52.966 --> 00:30:54.996 A:middle
where we reset our
model to the old value.

00:30:55.676 --> 00:30:58.256 A:middle
Now this is great because
now we only need one

00:30:58.306 --> 00:31:01.026 A:middle
or we're only registering
the undo in a single place.

00:30:58.306 --> 00:31:01.026 A:middle
or we're only registering
the undo in a single place.

00:31:01.766 --> 00:31:05.076 A:middle
So what were the benefits here?

00:31:05.856 --> 00:31:08.116 A:middle
Well, as we saw, we now
have a single code path

00:31:08.116 --> 00:31:09.246 A:middle
for updating our UI,

00:31:09.666 --> 00:31:11.746 A:middle
and operations are
order independent,

00:31:12.006 --> 00:31:13.256 A:middle
which was not the case before.

00:31:14.256 --> 00:31:16.796 A:middle
This really helped us reason
locally about our code,

00:31:17.226 --> 00:31:20.306 A:middle
about our UI update code.

00:31:20.526 --> 00:31:24.096 A:middle
We also saw how values compose
very well with other values.

00:31:24.896 --> 00:31:28.376 A:middle
If we have two values as
properties of a single value,

00:31:28.896 --> 00:31:30.956 A:middle
that value still
has value semantics.

00:31:37.246 --> 00:31:41.246 A:middle
Okay, so we just talked
about how to use value types

00:31:41.246 --> 00:31:44.126 A:middle
in the controller layer
with our model properties.

00:31:44.676 --> 00:31:46.026 A:middle
And now I want to do the same

00:31:46.186 --> 00:31:48.246 A:middle
with our controller's
UI state properties.

00:31:48.786 --> 00:31:51.286 A:middle
And so you've seen
this screen before.

00:31:51.826 --> 00:31:53.926 A:middle
It's just our list of dreams.

00:31:54.496 --> 00:31:57.216 A:middle
But this view controller has
many, many different states

00:31:57.816 --> 00:31:59.646 A:middle
and so I'd like to show
you the state diagram

00:31:59.906 --> 00:32:02.536 A:middle
for our view controller as it
relates to a very cool feature

00:31:59.906 --> 00:32:02.536 A:middle
for our view controller as it
relates to a very cool feature

00:32:02.536 --> 00:32:05.536 A:middle
that we have, the ability to
share dreams with friends.

00:32:06.546 --> 00:32:07.276 A:middle
So let's take a look.

00:32:07.976 --> 00:32:10.956 A:middle
So this is our basic
state diagram.

00:32:11.596 --> 00:32:17.366 A:middle
We're going to start off
in the viewing state.

00:32:17.576 --> 00:32:20.256 A:middle
Now we can tap the Share button
at the top right, which is going

00:32:20.256 --> 00:32:21.866 A:middle
to take us to the
selecting state.

00:32:23.226 --> 00:32:24.836 A:middle
And then we can select
dreams to share.

00:32:25.446 --> 00:32:27.836 A:middle
And then we can tap
the Done button

00:32:27.836 --> 00:32:29.886 A:middle
to go back to the sharing state.

00:32:33.856 --> 00:32:36.576 A:middle
Then when we're done, we just
go back to the viewing state.

00:32:37.076 --> 00:32:39.726 A:middle
And so that all worked well.

00:32:39.726 --> 00:32:41.306 A:middle
But let's go back

00:32:41.306 --> 00:32:42.756 A:middle
to the selecting state
again real quick.

00:32:43.966 --> 00:32:47.516 A:middle
You'll notice that we
can stop sharing midway

00:32:47.516 --> 00:32:50.026 A:middle
through by tapping the Cancel
button at the top left.

00:32:50.706 --> 00:32:55.876 A:middle
And so this moved us back
into the viewing state.

00:32:56.546 --> 00:32:58.946 A:middle
And you can see that our
navigation bar looks correct

00:32:59.366 --> 00:33:00.986 A:middle
since it shows the
Share button again.

00:32:59.366 --> 00:33:00.986 A:middle
since it shows the
Share button again.

00:33:01.986 --> 00:33:03.976 A:middle
But there's actually a
subtle UI bug in our app

00:33:03.976 --> 00:33:06.066 A:middle
because of an inconsistent
state.

00:33:07.216 --> 00:33:10.736 A:middle
The UI on the left side of the
table view is still visible

00:33:10.736 --> 00:33:13.966 A:middle
to allow users to select dreams
to share and this is wrong.

00:33:14.526 --> 00:33:18.766 A:middle
So when we went back to debug
this code, we saw that some

00:33:18.766 --> 00:33:21.006 A:middle
of our state properties
weren't fully cleared

00:33:21.006 --> 00:33:22.666 A:middle
out during a state change.

00:33:23.746 --> 00:33:26.906 A:middle
And so in this case, even though
we moved to the viewing state,

00:33:26.906 --> 00:33:28.976 A:middle
we forgot to clear out
some of the properties

00:33:28.976 --> 00:33:30.376 A:middle
of the selecting state.

00:33:31.306 --> 00:33:33.596 A:middle
So let's take another look
at our state diagram to see

00:33:33.596 --> 00:33:37.846 A:middle
if we can come up with a fix.

00:33:38.046 --> 00:33:41.056 A:middle
Now each state here has
a corresponding property.

00:33:41.876 --> 00:33:43.756 A:middle
And those properties
are properties

00:33:43.756 --> 00:33:44.686 A:middle
on our view controller.

00:33:45.266 --> 00:33:49.736 A:middle
And the number of
state properties

00:33:49.886 --> 00:33:52.546 A:middle
in our view controller
can easily explode

00:33:52.546 --> 00:33:54.796 A:middle
as your app's feature set grows.

00:33:55.586 --> 00:33:58.546 A:middle
And so it's important that in
this case our properties are

00:33:58.546 --> 00:33:59.886 A:middle
mutually exclusive.

00:34:00.396 --> 00:34:03.586 A:middle
And so when we're
viewing, we not sharing.

00:34:03.586 --> 00:34:05.846 A:middle
And when we're sharing,
we not selecting.

00:34:07.456 --> 00:34:10.346 A:middle
But the way we've written it,
when you set one property,

00:34:10.346 --> 00:34:12.485 A:middle
you need to clear out
all the other properties

00:34:12.485 --> 00:34:13.746 A:middle
and this is really error prone.

00:34:14.246 --> 00:34:16.926 A:middle
And so how can we
solve this problem?

00:34:17.476 --> 00:34:21.606 A:middle
Well, enums are actually perfect
for mutually exclusive values.

00:34:22.106 --> 00:34:25.846 A:middle
And so we turn all of
our UI state properties

00:34:25.846 --> 00:34:27.826 A:middle
into cases on an enum value.

00:34:29.036 --> 00:34:31.226 A:middle
And from there, we can
just add a state property

00:34:31.295 --> 00:34:32.266 A:middle
to our view controller.

00:34:32.846 --> 00:34:37.146 A:middle
So by using an enum,
we can make sure

00:34:37.146 --> 00:34:38.856 A:middle
that our states are
mutually exclusive.

00:34:39.466 --> 00:34:41.525 A:middle
And that's great because
now the invalid state bug

00:34:41.525 --> 00:34:44.246 A:middle
that we had before
isn't even possible

00:34:44.246 --> 00:34:46.126 A:middle
and it's enforced
by the type system.

00:34:46.646 --> 00:34:51.126 A:middle
And so this approach also means
that our state changes all

00:34:51.126 --> 00:34:55.346 A:middle
at once, without any possibility
of any intermediate states.

00:34:55.346 --> 00:34:59.556 A:middle
So we don't to coordinate
flipping properties

00:34:59.936 --> 00:35:01.696 A:middle
with implicit timing
dependencies.

00:34:59.936 --> 00:35:01.696 A:middle
with implicit timing
dependencies.

00:35:02.386 --> 00:35:05.326 A:middle
And as a bonus, having
your state all

00:35:05.326 --> 00:35:07.616 A:middle
in one places makes it
easier to launch your app

00:35:07.946 --> 00:35:09.986 A:middle
in exactly the same state
as the user left it.

00:35:10.426 --> 00:35:11.816 A:middle
So I really recommend
you checkout

00:35:11.816 --> 00:35:14.106 A:middle
and download the project again

00:35:14.106 --> 00:35:17.306 A:middle
to see how we implemented state
restoration in our application.

00:35:17.956 --> 00:35:25.246 A:middle
Okay, so we covered a lot today,
and we started off with the goal

00:35:25.246 --> 00:35:28.186 A:middle
of improving local
reasoning in our application

00:35:28.556 --> 00:35:31.156 A:middle
by introducing value
types and protocols

00:35:31.156 --> 00:35:33.676 A:middle
into our model view
controller based application.

00:35:34.316 --> 00:35:35.776 A:middle
So how'd we do?

00:35:36.596 --> 00:35:39.866 A:middle
Well, we started off by making
our model have value semantics,

00:35:40.156 --> 00:35:41.756 A:middle
by making the dream
type a struct.

00:35:42.186 --> 00:35:45.676 A:middle
And this makes it easier for us
to locally reason about our code

00:35:45.676 --> 00:35:48.916 A:middle
because there's no implicit
sharing of our dream variables.

00:35:50.616 --> 00:35:53.486 A:middle
Then Jacob showed you how
we built small components,

00:35:53.796 --> 00:35:56.056 A:middle
like DecoratingLayout
and CascadingLayout.

00:35:57.096 --> 00:36:00.196 A:middle
These small components
took advantage of protocols

00:35:57.096 --> 00:36:00.196 A:middle
These small components
took advantage of protocols

00:36:00.196 --> 00:36:01.396 A:middle
in generics to make sure

00:36:01.396 --> 00:36:04.796 A:middle
that the generic components
were reusable with views,

00:36:05.086 --> 00:36:07.306 A:middle
SpriteKit nodes,
and image rendering.

00:36:08.046 --> 00:36:10.966 A:middle
And all of this led to better
local reasoning since each

00:36:10.966 --> 00:36:13.886 A:middle
of these types were
small, testable,

00:36:13.886 --> 00:36:14.976 A:middle
and isolated value types.

00:36:16.316 --> 00:36:20.226 A:middle
And then we saw how
we can take advantage

00:36:20.226 --> 00:36:21.866 A:middle
of composing model properties

00:36:22.136 --> 00:36:24.066 A:middle
on a view controller
into a single type.

00:36:25.156 --> 00:36:28.456 A:middle
This made it easier to implement
undo with a single code path,

00:36:29.186 --> 00:36:31.996 A:middle
even as our model type grows
to have more properties.

00:36:33.166 --> 00:36:35.586 A:middle
And this approach also
gave us one code path

00:36:35.616 --> 00:36:38.926 A:middle
for updating our
UI, making it easier

00:36:38.926 --> 00:36:40.306 A:middle
to understand the UI logic

00:36:40.736 --> 00:36:42.636 A:middle
of our view controller
in isolation.

00:36:43.196 --> 00:36:48.276 A:middle
And finally, we saw how we can
turn our mutually exclusive

00:36:48.276 --> 00:36:51.676 A:middle
state properties into an enum
value on our view controller.

00:36:52.516 --> 00:36:55.046 A:middle
Now this reduced the
potential for our UI to be an

00:36:55.046 --> 00:36:56.186 A:middle
in inconsistent state.

00:36:57.256 --> 00:37:01.786 A:middle
And so those were the value
types that we discussed today.

00:36:57.256 --> 00:37:01.786 A:middle
And so those were the value
types that we discussed today.

00:37:02.586 --> 00:37:05.316 A:middle
But if you go and download
the sample project,

00:37:05.806 --> 00:37:07.366 A:middle
you'll see that there
are actually many more

00:37:07.366 --> 00:37:08.036 A:middle
in the project.

00:37:08.686 --> 00:37:12.736 A:middle
And so pretty much our
whole application is built

00:37:12.736 --> 00:37:15.306 A:middle
with value types except

00:37:15.306 --> 00:37:17.436 A:middle
for where we have a
controller or view object.

00:37:18.206 --> 00:37:21.176 A:middle
Now these are required to
be reference types by UIKit

00:37:21.316 --> 00:37:23.496 A:middle
but we've still moved most

00:37:23.496 --> 00:37:26.026 A:middle
of our functionality
into value types.

00:37:26.556 --> 00:37:33.216 A:middle
And so we spoke about a lot
today and I want you to go home

00:37:33.216 --> 00:37:38.286 A:middle
with just a few things in
your mind to take home.

00:37:38.496 --> 00:37:41.496 A:middle
So the first is customization

00:37:41.906 --> 00:37:43.806 A:middle
through composition
instead of inheritance.

00:37:45.066 --> 00:37:46.386 A:middle
The next time you're
at your desk

00:37:47.076 --> 00:37:50.096 A:middle
and you're drawing a class
diagram to solve some problem,

00:37:50.736 --> 00:37:55.096 A:middle
I want you to think how you
can use composition instead

00:37:55.096 --> 00:37:58.306 A:middle
of inheritance to solve that
problem, so you get the benefits

00:37:58.306 --> 00:37:59.936 A:middle
of value types that
we talked about today.

00:38:00.506 --> 00:38:03.946 A:middle
And the second technique
is to use protocols

00:38:03.946 --> 00:38:05.566 A:middle
for generic reusable code.

00:38:06.616 --> 00:38:09.906 A:middle
You can make small reusable
components that are easy

00:38:09.906 --> 00:38:12.346 A:middle
to locally reason
about and easy to test.

00:38:13.076 --> 00:38:15.766 A:middle
And so I highly recommend
you check out how we've done

00:38:15.766 --> 00:38:18.706 A:middle
that in the sample with
generic types instead

00:38:18.706 --> 00:38:21.206 A:middle
of having class hierarchies.

00:38:21.736 --> 00:38:26.596 A:middle
We also showed you how to take
advantage of value semantics.

00:38:27.306 --> 00:38:29.266 A:middle
The important thing
to remember here is

00:38:29.266 --> 00:38:32.226 A:middle
that if you have a value
composed of other properties

00:38:32.366 --> 00:38:36.386 A:middle
that are values, the larger
value also has value semantics.

00:38:36.906 --> 00:38:40.776 A:middle
And finally, we talked
about local reasoning.

00:38:42.166 --> 00:38:45.836 A:middle
Now, local reasoning is actually
a very general technique that's

00:38:45.836 --> 00:38:51.656 A:middle
not specific to UI
programming, it's not specific

00:38:52.076 --> 00:38:54.586 A:middle
to mobile development, and
it's not specific to Swift.

00:38:55.336 --> 00:38:57.246 A:middle
This is a really
important aspect

00:38:57.316 --> 00:39:00.556 A:middle
of all programming language,
all programming languages.

00:38:57.316 --> 00:39:00.556 A:middle
of all programming language,
all programming languages.

00:39:01.406 --> 00:39:04.096 A:middle
So when you get back to your
desk and you start coding,

00:39:04.456 --> 00:39:08.266 A:middle
I want you to think, regardless
of the language, does that code,

00:39:08.266 --> 00:39:10.476 A:middle
how well does that code
support local reasoning.

00:39:11.716 --> 00:39:17.656 A:middle
Now it's no accident that Swift
emphasizes value types so much

00:39:18.076 --> 00:39:21.206 A:middle
because they're a hugely
important aspect for you

00:39:21.266 --> 00:39:23.486 A:middle
to be able to locally
reason about your code.

00:39:23.986 --> 00:39:27.486 A:middle
And that's it.

00:39:27.786 --> 00:39:29.316 A:middle
So you can find the sample code

00:39:29.316 --> 00:39:31.426 A:middle
and more relevant
resources here.

00:39:31.426 --> 00:39:33.366 A:middle
I highly recommend you do that.

00:39:34.096 --> 00:39:35.556 A:middle
We have some related sessions

00:39:35.556 --> 00:39:36.896 A:middle
that we mentioned
throughout the talk

00:39:37.886 --> 00:39:39.346 A:middle
and I recommend you
watch them on video.

00:39:40.176 --> 00:39:41.976 A:middle
And thank you for a great WWDC.

00:39:42.516 --> 00:39:45.500 A:middle
[ Applause ]
