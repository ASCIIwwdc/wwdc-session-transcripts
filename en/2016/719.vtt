WEBVTT

00:00:07.516 --> 00:00:17.500 A:middle
[ Music ]

00:00:20.516 --> 00:00:23.386 A:middle
[ Applause ]

00:00:23.886 --> 00:00:25.686 A:middle
&gt;&gt; Hello and welcome.

00:00:27.616 --> 00:00:31.356 A:middle
My name is Kushal Dalmia, and
I and my colleague, Terry Long,

00:00:31.446 --> 00:00:33.816 A:middle
I'm going to be representing
optimizing I/O

00:00:33.906 --> 00:00:35.476 A:middle
for performance and
battery life.

00:00:36.506 --> 00:00:39.146 A:middle
In this talk, we're going to
take a look at what an I/O is,

00:00:39.846 --> 00:00:43.346 A:middle
how it affects your app, and
how you can improve your app's

00:00:43.346 --> 00:00:45.896 A:middle
performance by improving
its I/O performance.

00:00:46.596 --> 00:00:47.656 A:middle
So let's begin.

00:00:49.076 --> 00:00:52.136 A:middle
As we all know, devices
are getting bigger

00:00:52.136 --> 00:00:53.106 A:middle
and better every year.

00:00:54.376 --> 00:00:56.596 A:middle
Screen resolutions
have gone up by as much

00:00:56.596 --> 00:00:58.766 A:middle
as 16 times in the past decade.

00:01:00.216 --> 00:01:01.216 A:middle
Similar improvements

00:01:01.216 --> 00:01:04.866 A:middle
in [inaudible] technologies
allow us to capture 4K HD videos

00:01:05.156 --> 00:01:08.136 A:middle
and amazing high-quality
images from our mobile devices.

00:01:10.226 --> 00:01:14.036 A:middle
All these improvements have led
to richer media being produced

00:01:14.166 --> 00:01:15.236 A:middle
and consumed every day.

00:01:15.766 --> 00:01:20.726 A:middle
Just to put it in perspective,
let's take a look at the trend

00:01:20.726 --> 00:01:22.396 A:middle
of the iPhone wallpaper size.

00:01:23.036 --> 00:01:27.176 A:middle
If you look at the size of the
iPhone wallpaper across device

00:01:27.176 --> 00:01:30.236 A:middle
and generations, you notice that
the growth has been exponential.

00:01:31.536 --> 00:01:35.126 A:middle
The size of the wallpaper on
an iPhone 6s Plus is as much

00:01:35.126 --> 00:01:37.956 A:middle
as 14 times its counterpart
on the iPhone 3G.

00:01:38.666 --> 00:01:41.276 A:middle
And there's a similar trend in
all of the phones' data as well.

00:01:41.796 --> 00:01:44.496 A:middle
We build and use
complex apps for gaming,

00:01:44.836 --> 00:01:46.456 A:middle
messaging, and social networks.

00:01:47.566 --> 00:01:52.006 A:middle
We work and store richer
documents like PDF's.

00:01:52.446 --> 00:01:55.236 A:middle
And we all share and
capture high-quality audio

00:01:55.236 --> 00:01:56.056 A:middle
and video files.

00:01:56.786 --> 00:02:01.376 A:middle
Now to manage this
data explosion,

00:01:56.786 --> 00:02:01.376 A:middle
Now to manage this
data explosion,

00:02:01.536 --> 00:02:04.726 A:middle
apps need to be really efficient
in their system resource usage,

00:02:05.616 --> 00:02:11.716 A:middle
and the main system resources
are CPU, memory, and I/O.

00:02:12.346 --> 00:02:17.216 A:middle
For CPU and memory, I'll refer
you to last year's WWDC talk,

00:02:17.276 --> 00:02:19.166 A:middle
Performance on iOS and watchOS,

00:02:20.166 --> 00:02:21.996 A:middle
and today we're going
to talk about I/O.

00:02:24.086 --> 00:02:27.896 A:middle
I/O, or input/output, are
operations that interact

00:02:27.896 --> 00:02:32.206 A:middle
with the local file storage
or network-based servers.

00:02:32.616 --> 00:02:35.786 A:middle
Operations that interact
with the file system and deal

00:02:35.786 --> 00:02:38.486 A:middle
with reading or writing files
are generally considered an I/O.

00:02:38.816 --> 00:02:43.086 A:middle
Talking to a web
server is a good example

00:02:43.086 --> 00:02:44.836 A:middle
of network-based I/O.

00:02:46.586 --> 00:02:49.506 A:middle
Now one of the reasons
I/O's are so interesting is

00:02:49.506 --> 00:02:52.096 A:middle
that there is a huge variation
in the I/O technologies

00:02:52.486 --> 00:02:54.066 A:middle
and the performance
characteristics.

00:02:55.876 --> 00:02:58.806 A:middle
Consider the latency to do
a one megabyte write to some

00:02:58.806 --> 00:03:03.736 A:middle
of the most common I/O medium
such as the SSD, a hard disk,

00:02:58.806 --> 00:03:03.736 A:middle
of the most common I/O medium
such as the SSD, a hard disk,

00:03:04.656 --> 00:03:05.996 A:middle
and a common Wi-Fi network.

00:03:07.496 --> 00:03:10.486 A:middle
As you'll notice here, the
same operation takes anywhere

00:03:10.486 --> 00:03:13.606 A:middle
from a couple of milliseconds to
hundreds of milliseconds based

00:03:13.606 --> 00:03:15.416 A:middle
on the I/O medium
you're interacting with.

00:03:15.926 --> 00:03:20.106 A:middle
And the reason I/O
is so important is

00:03:20.106 --> 00:03:23.186 A:middle
that the I/O performance of your
application has a direct impact

00:03:23.186 --> 00:03:24.206 A:middle
on user experience.

00:03:24.646 --> 00:03:29.636 A:middle
Latency variations in your
app's performance can show

00:03:29.636 --> 00:03:30.996 A:middle
as responsiveness issues.

00:03:32.616 --> 00:03:35.196 A:middle
Since I/O is a shared
resource in the system,

00:03:35.396 --> 00:03:37.706 A:middle
your app's I/O performance
could affect overall

00:03:37.706 --> 00:03:38.536 A:middle
system performance.

00:03:40.036 --> 00:03:41.606 A:middle
And as we'll see shortly,

00:03:42.066 --> 00:03:44.806 A:middle
I/O significantly impacts the
battery life of the device.

00:03:45.606 --> 00:03:50.426 A:middle
Now to help you reason about
the I/O usage of your app,

00:03:50.816 --> 00:03:52.846 A:middle
we've come up with our
own I/O philosophy,

00:03:54.066 --> 00:03:56.516 A:middle
and the I/O philosophy
has four main pillars.

00:03:57.096 --> 00:04:01.156 A:middle
Reduce the amount of I/O
your application does,

00:03:57.096 --> 00:04:01.156 A:middle
Reduce the amount of I/O
your application does,

00:04:01.766 --> 00:04:08.396 A:middle
use the right thread to do
these I/O's, adopt appropriate

00:04:08.396 --> 00:04:11.836 A:middle
and efficient API's to do
these I/O's, and, lastly,

00:04:12.076 --> 00:04:14.796 A:middle
test and measure your
application for I/O performance.

00:04:16.286 --> 00:04:18.576 A:middle
As we move through rest of the
doc, we'll look at each one

00:04:18.576 --> 00:04:19.856 A:middle
of them in further detail.

00:04:21.726 --> 00:04:25.306 A:middle
Now the best way to
improve the I/O efficiency

00:04:25.306 --> 00:04:29.936 A:middle
of your application is to reduce
the amount of I/O it does.

00:04:30.156 --> 00:04:31.966 A:middle
Every I/O operation interacts

00:04:31.966 --> 00:04:34.246 A:middle
with multiple hardware
competence on your device.

00:04:34.856 --> 00:04:39.246 A:middle
Here's a simple block diagram
of a modern device with some

00:04:39.246 --> 00:04:41.926 A:middle
of its competence and their
impact on battery life.

00:04:43.866 --> 00:04:48.806 A:middle
When your app is using I/O,
it runs on code on the CPU,

00:04:48.936 --> 00:04:52.606 A:middle
accesses memory, and
ultimately fetches data

00:04:52.686 --> 00:04:53.666 A:middle
to or from the disk.

00:04:55.106 --> 00:04:56.716 A:middle
If the network is involved,

00:04:57.216 --> 00:04:59.686 A:middle
the network-based radios
are interacted with as well.

00:05:01.516 --> 00:05:03.306 A:middle
The combined power cost of all

00:05:03.306 --> 00:05:06.036 A:middle
of these competents makes
I/O a heavy operation

00:05:06.036 --> 00:05:07.346 A:middle
in terms of battery usage.

00:05:09.156 --> 00:05:11.836 A:middle
Since I/O has such an adverse
effect on the battery life

00:05:11.836 --> 00:05:13.856 A:middle
of the device, let's
take a look at a couple

00:05:13.856 --> 00:05:16.656 A:middle
of best practices you can
use to reduce the amount

00:05:16.656 --> 00:05:17.806 A:middle
of I/O in your application.

00:05:18.346 --> 00:05:21.376 A:middle
And the first one is caching.

00:05:22.326 --> 00:05:25.766 A:middle
The main idea here is to
create an in memory copy

00:05:25.766 --> 00:05:27.476 A:middle
of your data rather than going

00:05:27.476 --> 00:05:29.226 A:middle
out of the disk for
every operation.

00:05:30.956 --> 00:05:33.886 A:middle
To decide if your data
should be cached in memory

00:05:33.886 --> 00:05:35.776 A:middle
in your application,
you should look

00:05:35.776 --> 00:05:38.716 A:middle
at the access patterns
of your data.

00:05:39.286 --> 00:05:41.116 A:middle
Data which is frequently
written to

00:05:41.116 --> 00:05:43.076 A:middle
or updated might
be a good candidate

00:05:43.076 --> 00:05:44.426 A:middle
to cache in your application.

00:05:46.596 --> 00:05:48.196 A:middle
Also, data which [inaudible]

00:05:48.196 --> 00:05:51.856 A:middle
from the disk needs an expensive
processing step, for example,

00:05:51.856 --> 00:05:54.536 A:middle
decompressing an image file
might be a good example

00:05:54.536 --> 00:05:56.386 A:middle
of data you should cache.

00:05:57.756 --> 00:06:00.646 A:middle
Having said that, you should
be aware of the tradeoffs

00:05:57.756 --> 00:06:00.646 A:middle
Having said that, you should
be aware of the tradeoffs

00:06:00.646 --> 00:06:02.056 A:middle
between memory and I/O.

00:06:03.416 --> 00:06:06.366 A:middle
Just like I/O, memory is a
shared and limited resource

00:06:06.366 --> 00:06:08.126 A:middle
in the system, and
you should be careful

00:06:08.126 --> 00:06:08.886 A:middle
in your user [inaudible].

00:06:10.366 --> 00:06:12.886 A:middle
If you do decide to create
caches in your application,

00:06:13.536 --> 00:06:15.856 A:middle
we would recommend
using the NS cache API's

00:06:16.586 --> 00:06:18.506 A:middle
since they handle memory
pressure conditions

00:06:18.506 --> 00:06:19.546 A:middle
appropriately for you.

00:06:24.136 --> 00:06:27.096 A:middle
The next best practice
is coalescing your I/O's,

00:06:28.196 --> 00:06:32.056 A:middle
and the main idea here is to
defer your I/O's to a later,

00:06:32.056 --> 00:06:33.626 A:middle
more suitable time
in the system.

00:06:34.446 --> 00:06:37.916 A:middle
Due to the way I/O
technologies work, larger,

00:06:37.916 --> 00:06:40.526 A:middle
fewer I/O's are always more
efficient for the system.

00:06:42.336 --> 00:06:43.696 A:middle
One of the ways to do that is

00:06:43.696 --> 00:06:46.386 A:middle
to use the application app
state change notification,

00:06:46.586 --> 00:06:48.776 A:middle
for example, application
data in the background

00:06:48.826 --> 00:06:50.526 A:middle
to schedule your I/O's.

00:06:51.476 --> 00:06:54.926 A:middle
On macOS, you can use the
centralized task scheduling

00:06:54.926 --> 00:06:57.626 A:middle
API's to schedule your
maintenance and backup tasks,

00:06:57.976 --> 00:06:58.866 A:middle
and the system will figure

00:06:58.866 --> 00:07:00.996 A:middle
out an optimal time
to run these for you.

00:06:58.866 --> 00:07:00.996 A:middle
out an optimal time
to run these for you.

00:07:01.646 --> 00:07:06.296 A:middle
To learn more about these API's,
we would recommend looking

00:07:06.296 --> 00:07:10.006 A:middle
at WWDC 2014 talk Writing
Energy Efficient Code.

00:07:10.646 --> 00:07:14.556 A:middle
Now that we've taken a look
at a couple of best practices

00:07:14.556 --> 00:07:16.706 A:middle
to reduce the amount of
I/O in your application,

00:07:17.356 --> 00:07:19.796 A:middle
I'd like to introduce our
sample application which Terry

00:07:19.796 --> 00:07:22.986 A:middle
and I have been working on,
and we'll use this application

00:07:22.986 --> 00:07:23.876 A:middle
for the rest of the talk

00:07:24.046 --> 00:07:26.346 A:middle
to demonstrate the
practical implications of some

00:07:26.346 --> 00:07:27.286 A:middle
of these best practices.

00:07:28.766 --> 00:07:30.536 A:middle
And that app is called ImageBox.

00:07:31.546 --> 00:07:35.196 A:middle
ImageBox is our amazing
app on iOS and macOS

00:07:35.776 --> 00:07:37.576 A:middle
that lets you add
and browse images.

00:07:38.166 --> 00:07:42.406 A:middle
For each image, it
shows you a thumbnail,

00:07:43.406 --> 00:07:46.096 A:middle
shows you associated
badges such as favorites,

00:07:47.216 --> 00:07:48.886 A:middle
or whether it has
notes associated

00:07:48.886 --> 00:07:49.886 A:middle
with the particular image.

00:07:50.426 --> 00:07:53.916 A:middle
When you tap on a
particular image, it takes you

00:07:53.916 --> 00:07:56.816 A:middle
to a detailed view, which
lets you mark the image

00:07:56.816 --> 00:08:02.186 A:middle
as a favorite, unfavorited,
or add a note to it.

00:07:56.816 --> 00:08:02.186 A:middle
as a favorite, unfavorited,
or add a note to it.

00:08:03.196 --> 00:08:05.566 A:middle
Now that we've created
this app, we want to know

00:08:05.566 --> 00:08:07.906 A:middle
if our app is I/O
efficient and does well

00:08:07.906 --> 00:08:09.196 A:middle
in terms of I/O performance.

00:08:10.176 --> 00:08:12.226 A:middle
So I'm going to talk about
the tool that you can use

00:08:12.266 --> 00:08:14.416 A:middle
to decide this for
your own application,

00:08:15.476 --> 00:08:17.536 A:middle
and the tool is the
Xcode debug gauge.

00:08:18.636 --> 00:08:19.896 A:middle
So let's see how that works.

00:08:21.146 --> 00:08:22.296 A:middle
In order to use that tool,

00:08:22.706 --> 00:08:24.686 A:middle
simply run your project
from the Xcode UI.

00:08:26.236 --> 00:08:28.206 A:middle
This launches the
project or the application

00:08:28.206 --> 00:08:29.606 A:middle
on the device or the simulator.

00:08:30.156 --> 00:08:32.135 A:middle
Click on the Xcode
debug navigator.

00:08:32.785 --> 00:08:37.356 A:middle
Now this shows you live data
from all, from your application

00:08:37.416 --> 00:08:40.426 A:middle
about all the system resources
your application is using.

00:08:41.236 --> 00:08:45.876 A:middle
You have CPU, memory,
energy, network, and disk.

00:08:47.686 --> 00:08:50.536 A:middle
Since we're interested in the
I/O activity or I/O performance

00:08:50.536 --> 00:08:53.116 A:middle
of our application, let's
go ahead and select disk.

00:08:54.796 --> 00:08:57.396 A:middle
Once you do that, you notice
that it shows you live data

00:08:57.396 --> 00:08:59.746 A:middle
about the reads and writes
being done by your application,

00:09:00.626 --> 00:09:02.966 A:middle
and it looks like our
application is doing a lot

00:09:02.966 --> 00:09:06.226 A:middle
of writes every few seconds even
though there is no user activity

00:09:06.226 --> 00:09:06.676 A:middle
to it.

00:09:06.936 --> 00:09:10.926 A:middle
Now to investigate this further,
we want to dig into instruments,

00:09:11.056 --> 00:09:13.276 A:middle
and use instruments to
find out what's happening.

00:09:13.796 --> 00:09:16.156 A:middle
So let's go ahead and click
on profile in instruments,

00:09:16.666 --> 00:09:17.806 A:middle
and hit the restart button.

00:09:19.846 --> 00:09:22.846 A:middle
Once you do that, instruments
provides you a set of templates

00:09:22.846 --> 00:09:25.986 A:middle
that you can choose from for
analyzing your application.

00:09:27.226 --> 00:09:29.056 A:middle
And since we're interested
in the I/O activity

00:09:29.056 --> 00:09:30.616 A:middle
of our application, we go ahead

00:09:30.616 --> 00:09:36.676 A:middle
and select system usage,
and next hit choose.

00:09:36.876 --> 00:09:39.846 A:middle
Doing that opens a new
instruments template that's

00:09:39.846 --> 00:09:42.266 A:middle
ready to record the I/O
activity for your application.

00:09:43.026 --> 00:09:44.726 A:middle
So let's go ahead
and start recording.

00:09:45.286 --> 00:09:50.436 A:middle
As you now notice in
the detail section,

00:09:50.696 --> 00:09:53.296 A:middle
this template shows you
all system calls being done

00:09:53.296 --> 00:09:56.236 A:middle
by our application which does,
which do I/O on your behalf.

00:09:57.046 --> 00:09:59.616 A:middle
It shows other useful
information such as the actual

00:09:59.616 --> 00:10:02.656 A:middle
and requested number of bytes
for those reads and writes

00:09:59.616 --> 00:10:02.656 A:middle
and requested number of bytes
for those reads and writes

00:10:03.036 --> 00:10:04.706 A:middle
and the file path
associated with them.

00:10:05.786 --> 00:10:08.056 A:middle
I'll go ahead and stop
this recording now.

00:10:09.396 --> 00:10:11.906 A:middle
Now in order to find out the
large writes that we were seeing

00:10:11.906 --> 00:10:14.546 A:middle
in the Xcode debug
gauge, we sort this data

00:10:14.546 --> 00:10:16.896 A:middle
by the actual number of bytes
that are being read and written

00:10:17.156 --> 00:10:20.546 A:middle
and identify the large
write that's near the top.

00:10:21.116 --> 00:10:23.936 A:middle
Once we have that,
we can actually go

00:10:23.936 --> 00:10:27.336 A:middle
into the extended detail viewer
and see the exact backtrace

00:10:27.396 --> 00:10:29.776 A:middle
of the piece of code doing
these I/O's in our application.

00:10:30.986 --> 00:10:33.386 A:middle
It looks like it's our
app delegate method.

00:10:34.976 --> 00:10:38.446 A:middle
Double clicking on that takes
you to a source inspector

00:10:38.446 --> 00:10:41.406 A:middle
which shows you the exact block
of code doing these I/O's.

00:10:42.766 --> 00:10:45.176 A:middle
If you click on the Xcode
icon in the source inspector,

00:10:45.406 --> 00:10:48.416 A:middle
it takes you back to Xcode
project and highlights the piece

00:10:48.416 --> 00:10:50.056 A:middle
of code doing these
I/O's for you.

00:10:50.686 --> 00:10:54.526 A:middle
So let's take a look at this
piece of code in further detail,

00:10:55.786 --> 00:10:58.226 A:middle
and the code in question
is our implementation

00:10:58.226 --> 00:11:00.486 A:middle
of the application
didFinishLaunchingApp

00:10:58.226 --> 00:11:00.486 A:middle
of the application
didFinishLaunchingApp

00:11:00.486 --> 00:11:01.256 A:middle
delegate method.

00:11:01.776 --> 00:11:04.286 A:middle
As part of its implementation,

00:11:04.286 --> 00:11:06.146 A:middle
we create a new timer
DispatchSource,

00:11:07.366 --> 00:11:09.606 A:middle
schedule it to file
every five seconds,

00:11:11.326 --> 00:11:13.496 A:middle
and as part of the event
handler for that timer,

00:11:13.796 --> 00:11:15.486 A:middle
we write out our
entire data store.

00:11:16.926 --> 00:11:19.096 A:middle
Now a lot of us write code
like this because we want

00:11:19.096 --> 00:11:21.536 A:middle
to make sure that the
application data is being saved

00:11:21.536 --> 00:11:23.426 A:middle
out consistently and regularly.

00:11:24.606 --> 00:11:27.606 A:middle
However, there's a more I/O
efficient way of doing this,

00:11:28.686 --> 00:11:30.646 A:middle
and to fix this code,
the first thing

00:11:30.646 --> 00:11:33.716 A:middle
that we'll do is eliminate the
repeating nature of the timer.

00:11:34.326 --> 00:11:36.276 A:middle
So let's get rid of that.

00:11:37.576 --> 00:11:41.026 A:middle
Instead, we create a new method
called dataStoreDidChange,

00:11:41.386 --> 00:11:42.786 A:middle
which is culled from
various places

00:11:42.786 --> 00:11:45.116 A:middle
in the application
whenever there is a change

00:11:45.116 --> 00:11:47.636 A:middle
to the to the data store.

00:11:47.636 --> 00:11:49.086 A:middle
As part of this implementation,

00:11:49.726 --> 00:11:51.636 A:middle
we push out the timer
dispatch source

00:11:51.636 --> 00:11:53.256 A:middle
by 15 seconds into the future.

00:11:54.686 --> 00:11:56.886 A:middle
This way, we collect all updates

00:11:56.886 --> 00:11:59.986 A:middle
for our application's data
store update and push them

00:11:59.986 --> 00:12:02.156 A:middle
out into the future and
coalesce and write them.

00:11:59.986 --> 00:12:02.156 A:middle
out into the future and
coalesce and write them.

00:12:03.366 --> 00:12:04.946 A:middle
Once the timer eventually
expires,

00:12:05.326 --> 00:12:07.236 A:middle
it has basically
collected a bunch of updates

00:12:07.236 --> 00:12:09.286 A:middle
that were frequently
done, and we'll write them

00:12:09.286 --> 00:12:10.916 A:middle
out as a single I/O operation.

00:12:11.486 --> 00:12:15.226 A:middle
So let's see what these code
changes do for our application.

00:12:16.496 --> 00:12:20.026 A:middle
We run the application again
using the Xcode UI's run button.

00:12:21.066 --> 00:12:24.346 A:middle
Go to the debug navigator
and select the disk gauge

00:12:24.346 --> 00:12:25.456 A:middle
to find the I/O activity.

00:12:26.076 --> 00:12:30.906 A:middle
As you'll notice here that the
application is not doing those

00:12:30.906 --> 00:12:31.546 A:middle
writes anymore.

00:12:32.246 --> 00:12:34.636 A:middle
Since it's completely idle and
the user is not interacting

00:12:34.636 --> 00:12:36.586 A:middle
with it, this is
exactly what we expect.

00:12:37.546 --> 00:12:39.686 A:middle
We've effectively
coalesced the amount of I/O's

00:12:39.726 --> 00:12:43.126 A:middle
that our application does, and
improved its I/O efficiency.

00:12:43.126 --> 00:12:48.006 A:middle
Now that we've taken
a look at a couple

00:12:48.006 --> 00:12:50.686 A:middle
of best practices you can use
to reduce the amount of I/O,

00:12:51.186 --> 00:12:53.946 A:middle
let's take a look at what
trends you should be using

00:12:53.946 --> 00:12:55.986 A:middle
to do these I/O's, and for that,

00:12:56.316 --> 00:12:57.866 A:middle
I'd like to invite
Terry on stage.

00:12:58.146 --> 00:12:58.396 A:middle
Terry.

00:12:59.516 --> 00:13:04.086 A:middle
[ Applause ]

00:12:59.516 --> 00:13:04.086 A:middle
[ Applause ]

00:13:04.586 --> 00:13:05.216 A:middle
&gt;&gt; Thanks, Kushal.

00:13:06.006 --> 00:13:08.786 A:middle
So we just saw some great
ways that you can reduce I/O

00:13:08.786 --> 00:13:11.296 A:middle
in your applications to
avoid negatively impacting

00:13:11.296 --> 00:13:11.936 A:middle
battery life.

00:13:12.936 --> 00:13:15.906 A:middle
Now let's move on to the second
pillar of our I/O philosophy.

00:13:16.556 --> 00:13:18.956 A:middle
I'll explain some ways
that you can use threads

00:13:19.096 --> 00:13:21.016 A:middle
and queues effectively
in your application

00:13:21.456 --> 00:13:23.646 A:middle
for great I/O performance
and efficiency.

00:13:24.136 --> 00:13:29.116 A:middle
Every thread or every
application on the system starts

00:13:29.116 --> 00:13:30.826 A:middle
with a single thread
called the main thread.

00:13:32.036 --> 00:13:35.776 A:middle
This thread is special, and
it has a few primary purposes.

00:13:35.846 --> 00:13:39.196 A:middle
The first purpose of the main
thread is to handle input.

00:13:40.316 --> 00:13:42.496 A:middle
So if I tap on a button
in my application,

00:13:43.236 --> 00:13:45.246 A:middle
the main thread is
responsible for handling

00:13:45.246 --> 00:13:48.806 A:middle
that input and responding to it.

00:13:49.126 --> 00:13:51.326 A:middle
Additionally, the main
thread is responsible

00:13:51.326 --> 00:13:52.586 A:middle
for updating your interface.

00:13:53.366 --> 00:13:55.486 A:middle
This is for doing things
like drawing your views,

00:13:56.036 --> 00:13:57.646 A:middle
doing layout, or animating.

00:13:58.206 --> 00:14:02.766 A:middle
When your main thread is
idle, it's ready and available

00:13:58.206 --> 00:14:02.766 A:middle
When your main thread is
idle, it's ready and available

00:14:02.916 --> 00:14:05.776 A:middle
to respond to input or
update your user interface.

00:14:06.286 --> 00:14:09.696 A:middle
But if you're doing other
things on your main thread,

00:14:10.196 --> 00:14:13.706 A:middle
such as executing lengthy
tasks, this could be something

00:14:13.706 --> 00:14:17.006 A:middle
like expensive image
processing, doing this type

00:14:17.006 --> 00:14:18.816 A:middle
of work keeps your
main thread busy,

00:14:19.266 --> 00:14:22.226 A:middle
which means it won't be idle,
you won't be able to respond

00:14:22.226 --> 00:14:25.426 A:middle
to input, or update your UI.

00:14:25.956 --> 00:14:27.856 A:middle
Additionally, what
we'll focus on today,

00:14:27.856 --> 00:14:30.636 A:middle
you should avoid doing
I/O on your main thread.

00:14:31.846 --> 00:14:35.616 A:middle
As we've already seen, I/O is an
expensive resource on the system

00:14:35.926 --> 00:14:37.456 A:middle
that needs to be
managed properly.

00:14:39.046 --> 00:14:40.586 A:middle
If you're doing I/O
on your main thread,

00:14:41.286 --> 00:14:44.196 A:middle
someone using your application
could notice some problems.

00:14:45.586 --> 00:14:48.106 A:middle
The first example
of this is on macOS.

00:14:48.826 --> 00:14:50.286 A:middle
Someone may see the
spinning cursor.

00:14:51.636 --> 00:14:54.076 A:middle
The spinning cursor indicates
that your main thread is busy

00:14:54.766 --> 00:14:58.766 A:middle
and that you won't be able to
interact with the application.

00:14:58.976 --> 00:15:03.106 A:middle
Additionally, on iOS, a
busy main thread may appear

00:14:58.976 --> 00:15:03.106 A:middle
Additionally, on iOS, a
busy main thread may appear

00:15:03.236 --> 00:15:05.936 A:middle
as a frozen or just
unresponsive application.

00:15:06.526 --> 00:15:11.596 A:middle
And, lastly, doing I/O on your
main thread can cause issues

00:15:11.596 --> 00:15:12.476 A:middle
for animations.

00:15:13.406 --> 00:15:16.106 A:middle
For example, if I do a
large scroll in a table view

00:15:16.106 --> 00:15:19.416 A:middle
in my application and then do
I/O on the main thread to load

00:15:19.416 --> 00:15:23.166 A:middle
in more data, the time that
my application spends doing

00:15:23.166 --> 00:15:26.586 A:middle
that I/O is time that it doesn't
have to continue animating,

00:15:26.926 --> 00:15:28.606 A:middle
which can cause issues
like stutters.

00:15:29.456 --> 00:15:31.616 A:middle
I'd like to mention, again,
the talk that Kushal pointed

00:15:31.616 --> 00:15:34.606 A:middle
out earlier, Performance
on iOS and watchOS.

00:15:35.386 --> 00:15:37.326 A:middle
This talk also has
some great information

00:15:37.536 --> 00:15:39.066 A:middle
about using your main
thread effectively.

00:15:39.686 --> 00:15:44.396 A:middle
Now I'd like take a look at our
ImageBox sample application,

00:15:44.706 --> 00:15:46.156 A:middle
this time running on macOS.

00:15:47.176 --> 00:15:49.876 A:middle
I've been noticing an issue
when trying to add images

00:15:50.106 --> 00:15:51.316 A:middle
to the main collection view.

00:15:52.046 --> 00:15:53.606 A:middle
So let's take a look.

00:15:54.536 --> 00:15:56.926 A:middle
First from Xcode, I'll
click on the run button.

00:15:58.156 --> 00:15:59.966 A:middle
Xcode launches my application,

00:16:00.436 --> 00:16:01.976 A:middle
and then I'll click
the add button

00:16:01.976 --> 00:16:05.406 A:middle
on the right side
of the toolbar.

00:16:05.566 --> 00:16:09.996 A:middle
Then I'll select an image from
the open panel and click open.

00:16:10.556 --> 00:16:15.236 A:middle
As you can see, the open
panel doesn't disappear,

00:16:15.706 --> 00:16:17.006 A:middle
and we see the spinning cursor.

00:16:18.886 --> 00:16:23.606 A:middle
Eventually, the open panel
disappears, and the image

00:16:23.766 --> 00:16:26.136 A:middle
that we selected shows up
in the main collection view.

00:16:27.696 --> 00:16:31.876 A:middle
So what might be going on here?

00:16:32.096 --> 00:16:35.406 A:middle
Well, as we already saw, the
spinning cursor indicates

00:16:35.406 --> 00:16:36.446 A:middle
that your main thread is busy.

00:16:37.006 --> 00:16:38.206 A:middle
So something must be running

00:16:38.206 --> 00:16:41.726 A:middle
on the main thread that's
preventing it from being idle.

00:16:41.996 --> 00:16:43.916 A:middle
So we won't be able to
interact with the application.

00:16:44.916 --> 00:16:48.076 A:middle
We need to figure out what's
going on, and to do that,

00:16:48.126 --> 00:16:49.446 A:middle
we can use instruments.

00:16:50.656 --> 00:16:53.516 A:middle
Back in Xcode, we can choose
profile from the product menu.

00:16:55.246 --> 00:16:57.696 A:middle
Xcode recompiles our
application for profiling

00:16:57.876 --> 00:16:59.006 A:middle
and then launches instruments.

00:16:59.516 --> 00:17:02.656 A:middle
This time, I'll choose the time
profiler instruments template.

00:16:59.516 --> 00:17:02.656 A:middle
This time, I'll choose the time
profiler instruments template.

00:17:03.206 --> 00:17:05.556 A:middle
Time profiler is great

00:17:05.556 --> 00:17:08.126 A:middle
for seeing how much
time different parts

00:17:08.126 --> 00:17:09.546 A:middle
of your code are
spending executing.

00:17:09.976 --> 00:17:12.656 A:middle
So we can use this to figure
out why our main thread is busy.

00:17:14.465 --> 00:17:17.656 A:middle
Now I'll click choose, and
instruments opens a new,

00:17:18.136 --> 00:17:19.816 A:middle
blank time profiler document.

00:17:24.195 --> 00:17:28.226 A:middle
By default, instruments time
profiler only shows time spent

00:17:28.316 --> 00:17:30.536 A:middle
while the CPU is
actively executing code.

00:17:31.906 --> 00:17:35.566 A:middle
Other things like I/O aren't
actively executing on the CPU.

00:17:36.386 --> 00:17:38.256 A:middle
The CPU's just waiting
on the I/O to complete.

00:17:39.506 --> 00:17:41.746 A:middle
So to also see those
types of operations

00:17:42.306 --> 00:17:44.856 A:middle
in our instruments trace,
first we need to click

00:17:44.856 --> 00:17:46.466 A:middle
on the record waiting
threads option

00:17:46.746 --> 00:17:47.876 A:middle
under the record settings.

00:17:48.796 --> 00:17:51.676 A:middle
Now instruments will also show
us time spent while we're doing

00:17:51.676 --> 00:17:53.026 A:middle
things like waiting on I/O.

00:17:54.106 --> 00:17:56.266 A:middle
So let's get started and
click the record button

00:17:56.436 --> 00:17:57.186 A:middle
in instruments.

00:18:00.066 --> 00:18:01.486 A:middle
Instruments launches
our application,

00:18:01.486 --> 00:18:04.526 A:middle
and then I'll take the same
actions that I took before

00:18:04.716 --> 00:18:05.696 A:middle
to reproduce the problem.

00:18:06.256 --> 00:18:08.646 A:middle
First, clicking the add button,

00:18:08.826 --> 00:18:10.806 A:middle
selecting an image,
and hitting open.

00:18:12.296 --> 00:18:13.406 A:middle
Again, we see the issue.

00:18:13.626 --> 00:18:15.496 A:middle
So now we can hit
stop in instruments

00:18:16.026 --> 00:18:17.566 A:middle
and see what's going on.

00:18:18.976 --> 00:18:21.766 A:middle
Before I continue, I'd like
to reduce some of the noise

00:18:21.766 --> 00:18:25.016 A:middle
in this output by focusing just
on the code that I've written

00:18:25.316 --> 00:18:26.926 A:middle
and not any other
system libraries.

00:18:27.796 --> 00:18:30.696 A:middle
And to do that, first, I can
click on the display options

00:18:30.796 --> 00:18:32.146 A:middle
on the right side
of instruments.

00:18:33.616 --> 00:18:36.336 A:middle
Then click on hide
system libraries.

00:18:37.566 --> 00:18:40.196 A:middle
Now instruments will only
show me code that I've written

00:18:40.526 --> 00:18:42.116 A:middle
and not any other
system frameworks

00:18:42.166 --> 00:18:43.076 A:middle
that I might be calling.

00:18:43.646 --> 00:18:47.726 A:middle
So now let's take a look at the
main detail view of instruments.

00:18:48.616 --> 00:18:50.196 A:middle
Instruments shows all
the different threads

00:18:50.196 --> 00:18:52.296 A:middle
in my application,
and the different time

00:18:52.296 --> 00:18:53.536 A:middle
that they're spending executing.

00:18:54.676 --> 00:18:57.656 A:middle
In this case, we know that we're
interested in the main thread.

00:18:58.286 --> 00:19:00.306 A:middle
So I can expand the
main thread section

00:18:58.286 --> 00:19:00.306 A:middle
So I can expand the
main thread section

00:19:00.886 --> 00:19:04.446 A:middle
and find the heaviest stack.

00:19:07.036 --> 00:19:10.976 A:middle
In this case, I can see that
we have an open panel callback

00:19:10.976 --> 00:19:13.836 A:middle
in our application, which
is calling an add method

00:19:13.836 --> 00:19:14.636 A:middle
on our data store.

00:19:15.596 --> 00:19:18.196 A:middle
That add method is then
saving our entire data store

00:19:18.196 --> 00:19:20.476 A:middle
out to disk.

00:19:20.856 --> 00:19:21.946 A:middle
And instrument shows us

00:19:22.006 --> 00:19:24.936 A:middle
that saving is taking
almost seven seconds,

00:19:25.616 --> 00:19:27.586 A:middle
and that's really bad.

00:19:28.876 --> 00:19:31.516 A:middle
I happen to know that this
save method is writing

00:19:31.516 --> 00:19:34.246 A:middle
out a pretty big Plist, and
that could be contributing

00:19:34.246 --> 00:19:34.836 A:middle
to the problem.

00:19:36.156 --> 00:19:38.046 A:middle
Kushal will mention some
ways later in the talk

00:19:38.286 --> 00:19:40.696 A:middle
on how we can optimize
our data store operations

00:19:40.886 --> 00:19:44.606 A:middle
so that this is really fast,
but for now, I'd like to focus

00:19:44.606 --> 00:19:47.696 A:middle
on how we can fix this problem
so that no matter how long

00:19:47.696 --> 00:19:48.686 A:middle
that operation takes,

00:19:49.296 --> 00:19:51.596 A:middle
our application is still
extremely responsive.

00:19:52.286 --> 00:19:56.766 A:middle
To do that, let's take
a look at the code.

00:19:56.976 --> 00:19:58.496 A:middle
Here I have the open
panel callback.

00:19:59.986 --> 00:20:01.186 A:middle
It's waiting for a response.

00:19:59.986 --> 00:20:01.186 A:middle
It's waiting for a response.

00:20:01.906 --> 00:20:05.936 A:middle
Once it receives that response,
it validates that it has URL

00:20:06.056 --> 00:20:07.346 A:middle
that points to a valid image.

00:20:09.016 --> 00:20:12.066 A:middle
Then it creates a new item
for our collection view

00:20:12.266 --> 00:20:14.826 A:middle
from the image and tries to
add it to our data store.

00:20:15.456 --> 00:20:20.166 A:middle
If that was successful, it
tells the main collection view

00:20:20.166 --> 00:20:23.926 A:middle
to reload its data so
that we can see the image

00:20:23.926 --> 00:20:24.856 A:middle
that we just selected.

00:20:25.356 --> 00:20:30.306 A:middle
As we saw earlier, and what
instruments verified for us,

00:20:30.876 --> 00:20:33.676 A:middle
calling that add method is
expensive because it's saving

00:20:33.676 --> 00:20:35.526 A:middle
out all that data to disk.

00:20:36.516 --> 00:20:38.906 A:middle
So let's see how
we can fix this.

00:20:40.456 --> 00:20:43.806 A:middle
To recap, our application
has a main thread.

00:20:44.826 --> 00:20:46.886 A:middle
The main thread is running
the open panel callback.

00:20:48.766 --> 00:20:51.616 A:middle
That callback then calls the
add method on our data store,

00:20:51.786 --> 00:20:53.596 A:middle
and this is where we
see the spinning cursor.

00:20:54.136 --> 00:20:56.736 A:middle
Once that work is done,

00:20:57.046 --> 00:20:58.946 A:middle
we finally update our
main collection view,

00:21:00.446 --> 00:21:02.516 A:middle
and this is obviously
not what we want.

00:21:03.106 --> 00:21:05.586 A:middle
This entire time, the
main thread is busy,

00:21:06.026 --> 00:21:07.866 A:middle
and we can't interact
with our application,

00:21:08.246 --> 00:21:09.296 A:middle
and we can't update any UI.

00:21:09.296 --> 00:21:13.456 A:middle
So one way that we
can fix this is

00:21:13.456 --> 00:21:15.996 A:middle
by using Grand Central
Dispatch, or GCD.

00:21:16.576 --> 00:21:19.926 A:middle
With GCD, we can create
a new dispatch queue.

00:21:21.526 --> 00:21:23.196 A:middle
Dispatch queues are a way

00:21:23.196 --> 00:21:25.156 A:middle
to run code concurrently
to the main thread.

00:21:26.266 --> 00:21:29.426 A:middle
We can use this to move our
expensive I/O related work

00:21:29.876 --> 00:21:32.136 A:middle
onto this queue, leaving
the main thread idle.

00:21:33.606 --> 00:21:36.396 A:middle
To do that, we can call the
async method on the queue

00:21:36.866 --> 00:21:38.286 A:middle
and push that expensive work

00:21:38.876 --> 00:21:43.296 A:middle
onto our queue rather
than the main thread.

00:21:43.466 --> 00:21:46.236 A:middle
Finally, since UI related
work has to happen back

00:21:46.236 --> 00:21:46.876 A:middle
on the main thread,

00:21:47.876 --> 00:21:50.356 A:middle
we can asynchronously
dispatch back there

00:21:50.706 --> 00:21:52.076 A:middle
to finally update
our collection view.

00:21:52.696 --> 00:21:56.026 A:middle
And now this is exactly
what we want.

00:21:57.426 --> 00:22:00.516 A:middle
Now the expensive I/O work is
happening on a separate queue,

00:21:57.426 --> 00:22:00.516 A:middle
Now the expensive I/O work is
happening on a separate queue,

00:22:00.996 --> 00:22:03.686 A:middle
which leaves the main thread
idle, which means we'll be able

00:22:03.686 --> 00:22:06.236 A:middle
to interact with the application
and continue using it.

00:22:06.746 --> 00:22:12.686 A:middle
Let's see what this looks like
if we implement it in code.

00:22:12.886 --> 00:22:15.296 A:middle
Here I have the same open
panel callback from before.

00:22:16.406 --> 00:22:20.536 A:middle
To get started, first I can
create a new GCD dispatch queue

00:22:21.146 --> 00:22:22.436 A:middle
and provide a descriptive label.

00:22:23.956 --> 00:22:27.156 A:middle
In this case, I've created a
queue that I can reuse for all

00:22:27.156 --> 00:22:28.516 A:middle
of my data store operations.

00:22:29.066 --> 00:22:33.176 A:middle
Next, we can move the
expensive work when we're adding

00:22:33.176 --> 00:22:36.746 A:middle
that image onto this queue by
providing that code as a block

00:22:37.116 --> 00:22:39.586 A:middle
to the async method
on the dispatch queue.

00:22:40.486 --> 00:22:43.856 A:middle
Finally, to update our UI,

00:22:43.856 --> 00:22:47.856 A:middle
we can call dispatch
queue.main.async,

00:22:48.846 --> 00:22:51.776 A:middle
and pass it in a block that
has all of our UI related work.

00:22:53.176 --> 00:22:56.216 A:middle
Now that we've done that,
let's see what this looks

00:22:56.216 --> 00:22:58.776 A:middle
like if we rebuild and run
our application in Xcode.

00:22:59.766 --> 00:23:04.136 A:middle
So first I'll click the run
button, wait for the application

00:22:59.766 --> 00:23:04.136 A:middle
So first I'll click the run
button, wait for the application

00:23:04.136 --> 00:23:06.696 A:middle
to launch, and then try
adding an image again.

00:23:08.126 --> 00:23:10.476 A:middle
Click the add button,
select an image

00:23:10.476 --> 00:23:13.236 A:middle
from the open panel,
and then click open.

00:23:13.816 --> 00:23:17.956 A:middle
As you can see, the open
panel disappears immediately,

00:23:18.296 --> 00:23:20.676 A:middle
and we can continue
interacting with the application

00:23:20.966 --> 00:23:22.616 A:middle
and adding more and more images.

00:23:23.966 --> 00:23:26.256 A:middle
You'll also notice that I've
added some placeholder images

00:23:26.316 --> 00:23:26.976 A:middle
in the main view.

00:23:27.366 --> 00:23:28.756 A:middle
This is just to give
an indication

00:23:28.756 --> 00:23:30.806 A:middle
that we're currently
processing that data

00:23:30.806 --> 00:23:31.936 A:middle
and saving it out to disk.

00:23:33.466 --> 00:23:35.926 A:middle
Once all that data is done
being added and saved,

00:23:36.586 --> 00:23:38.456 A:middle
all the images show up in
the main collection view,

00:23:38.966 --> 00:23:42.396 A:middle
and now this entire time,
our main thread was idle,

00:23:42.706 --> 00:23:44.946 A:middle
which means their application
was extremely responsive,

00:23:45.636 --> 00:23:47.446 A:middle
and that's exactly what we want.

00:23:48.416 --> 00:23:52.456 A:middle
So now that we've moved that
work from the main thread off

00:23:52.456 --> 00:23:56.086 A:middle
to a dispatch queue, we should
consider telling the system the

00:23:56.086 --> 00:23:59.396 A:middle
intent of that work so it can
manage resources on our behalf,

00:24:00.166 --> 00:24:02.946 A:middle
and to do that, we can use
something called quality

00:24:02.946 --> 00:24:03.586 A:middle
of service.

00:24:05.176 --> 00:24:08.426 A:middle
Quality of service is a way
to tell the system the intent

00:24:08.426 --> 00:24:09.606 A:middle
of the work that
you're performing

00:24:10.026 --> 00:24:13.946 A:middle
so that it can properly manage
resources like CPU or I/O.

00:24:16.386 --> 00:24:19.786 A:middle
It manages these resources among
the different processes running

00:24:19.786 --> 00:24:21.716 A:middle
on the system and
the different threads

00:24:21.716 --> 00:24:22.836 A:middle
within your own application.

00:24:23.386 --> 00:24:26.516 A:middle
When thinking about
quality of service,

00:24:26.976 --> 00:24:30.366 A:middle
keep in mind three attributes of
the work that you're performing.

00:24:31.586 --> 00:24:34.136 A:middle
The visibility, importance,
and expectation.

00:24:35.826 --> 00:24:37.156 A:middle
Ask yourself three questions.

00:24:38.476 --> 00:24:40.656 A:middle
Is the work that you're
performing visible

00:24:40.656 --> 00:24:41.936 A:middle
to someone using
your application?

00:24:43.556 --> 00:24:46.276 A:middle
Secondly, what is the
importance of that work?

00:24:46.276 --> 00:24:48.236 A:middle
Is that work required

00:24:48.236 --> 00:24:51.236 A:middle
to complete before someone can
continue using your application?

00:24:51.756 --> 00:24:56.276 A:middle
And, lastly, how long is
that work expected to take?

00:24:56.926 --> 00:24:59.756 A:middle
Is this something that happens
immediately or something

00:24:59.756 --> 00:25:03.386 A:middle
that you might assume takes
a longer amount of time?

00:24:59.756 --> 00:25:03.386 A:middle
that you might assume takes
a longer amount of time?

00:25:03.996 --> 00:25:06.116 A:middle
Before I continue, I'd
like to mention a talk

00:25:06.116 --> 00:25:09.536 A:middle
from last year's WWDC
called Building Responsive

00:25:09.536 --> 00:25:10.966 A:middle
and Efficient Apps with GCD.

00:25:11.666 --> 00:25:15.056 A:middle
This talk goes into a lot
of detail about GCD and how

00:25:15.056 --> 00:25:16.206 A:middle
to use quality of service,

00:25:16.566 --> 00:25:18.806 A:middle
and I highly recommend
that you go watch it.

00:25:19.956 --> 00:25:23.376 A:middle
So once we've thought about
these three attributes

00:25:23.376 --> 00:25:25.976 A:middle
of our work, we're
ready to choose from one

00:25:25.976 --> 00:25:28.766 A:middle
of the four quality
of service classes.

00:25:29.316 --> 00:25:32.776 A:middle
The first quality of service
class is user interactive.

00:25:34.086 --> 00:25:36.716 A:middle
User interactive is
designated for your main thread.

00:25:37.726 --> 00:25:39.236 A:middle
This is for doing
things like responding

00:25:39.236 --> 00:25:40.756 A:middle
to input and animating.

00:25:41.356 --> 00:25:45.106 A:middle
All other work that
happens asynchronously

00:25:45.106 --> 00:25:47.016 A:middle
from the main thread
should be using one

00:25:47.016 --> 00:25:51.516 A:middle
of the other three quality of
service classes, and the first

00:25:51.516 --> 00:25:53.676 A:middle
of those is user initiated.

00:25:55.126 --> 00:25:56.906 A:middle
User initiated work is visible

00:25:56.906 --> 00:25:58.156 A:middle
to someone using
your application,

00:25:58.156 --> 00:26:00.656 A:middle
and they're expecting immediate
results from that work.

00:25:58.156 --> 00:26:00.656 A:middle
and they're expecting immediate
results from that work.

00:26:01.656 --> 00:26:03.236 A:middle
They probably also
need that work

00:26:03.236 --> 00:26:05.946 A:middle
to complete before they
can continue interacting

00:26:05.946 --> 00:26:06.696 A:middle
with your application.

00:26:07.796 --> 00:26:11.206 A:middle
A good example of that is if
I click on a button to switch

00:26:11.206 --> 00:26:14.336 A:middle
to a new view, I may need
to load some resources

00:26:14.336 --> 00:26:17.006 A:middle
on a different queue in
order to display that view,

00:26:17.526 --> 00:26:19.686 A:middle
and that work should be
happening at user initiated.

00:26:20.296 --> 00:26:23.926 A:middle
The third quality of
service class is utility.

00:26:25.146 --> 00:26:27.956 A:middle
Utility quality of service is
often associated with things

00:26:27.956 --> 00:26:31.306 A:middle
that have progress bars or
other activity indicators.

00:26:32.216 --> 00:26:34.446 A:middle
This work generally takes
a longer amount of time,

00:26:35.046 --> 00:26:36.916 A:middle
and it's something
that's still visible

00:26:36.916 --> 00:26:38.256 A:middle
to someone using
your application.

00:26:39.326 --> 00:26:41.206 A:middle
A good example of this
is rendering a movie.

00:26:41.926 --> 00:26:45.376 A:middle
This is something that doesn't
block someone from continuing

00:26:45.376 --> 00:26:47.496 A:middle
to use your application,
but it's going

00:26:47.496 --> 00:26:49.116 A:middle
to take a longer amount
of time to complete.

00:26:49.626 --> 00:26:53.306 A:middle
And the final quality of
service class is background.

00:26:54.116 --> 00:26:55.766 A:middle
Background work is not visible

00:26:55.766 --> 00:26:57.036 A:middle
to someone using
your application.

00:26:57.996 --> 00:27:00.216 A:middle
In fact, they may not even
be aware that it's happening.

00:26:57.996 --> 00:27:00.216 A:middle
In fact, they may not even
be aware that it's happening.

00:27:01.346 --> 00:27:03.286 A:middle
A good example of
that is indexing work.

00:27:04.056 --> 00:27:06.176 A:middle
Indexing is usually
important for the performance

00:27:06.176 --> 00:27:08.526 A:middle
of your application,
but it's not something

00:27:08.796 --> 00:27:10.766 A:middle
that someone using
your app is aware of.

00:27:10.906 --> 00:27:16.006 A:middle
All of these quality of
service classes are important

00:27:16.846 --> 00:27:19.726 A:middle
because if you, when you choose
the quality of service class,

00:27:19.726 --> 00:27:22.556 A:middle
it helps inform the system
how it should manage resources

00:27:23.056 --> 00:27:26.126 A:middle
so that less important work
like background operations

00:27:26.126 --> 00:27:29.656 A:middle
and indexing doesn't adversely
affect more important work

00:27:29.656 --> 00:27:32.936 A:middle
like animating, even if
that work is happening

00:27:32.936 --> 00:27:33.886 A:middle
in a different process.

00:27:35.756 --> 00:27:38.916 A:middle
So once we've chosen from one of
the quality of service classes,

00:27:39.506 --> 00:27:42.426 A:middle
there are two main ways that you
can specify quality of service

00:27:42.466 --> 00:27:45.776 A:middle
in your applications,
and the first way is

00:27:45.776 --> 00:27:49.406 A:middle
by supplying an optional QOS
parameter to the async method

00:27:49.406 --> 00:27:50.286 A:middle
on the dispatch queue.

00:27:51.536 --> 00:27:54.506 A:middle
In this case, I've
specified QOS background.

00:27:55.656 --> 00:27:57.246 A:middle
This means that when
the supplied block

00:27:57.246 --> 00:27:58.816 A:middle
of code is running
asynchronously,

00:27:59.516 --> 00:28:01.656 A:middle
it will be using the
background quality of service.

00:27:59.516 --> 00:28:01.656 A:middle
it will be using the
background quality of service.

00:28:03.586 --> 00:28:05.726 A:middle
Additionally, if you're
using the operation queue

00:28:06.066 --> 00:28:09.186 A:middle
or operation API's, both
of those have a quality

00:28:09.186 --> 00:28:12.236 A:middle
of service property that you
can set, such as utility.

00:28:12.846 --> 00:28:18.026 A:middle
So now that we know a little
bit about quality of service

00:28:18.096 --> 00:28:20.476 A:middle
and how we can specify
it, let's go back

00:28:20.476 --> 00:28:21.876 A:middle
to our ImageBox application,

00:28:22.196 --> 00:28:24.056 A:middle
and see if we can choose
an appropriate quality

00:28:24.056 --> 00:28:25.716 A:middle
of service for adding images.

00:28:26.656 --> 00:28:29.446 A:middle
And to do that, we can think
about the three attributes

00:28:29.446 --> 00:28:33.516 A:middle
of this work: The visibility,
importance, and expectation.

00:28:34.026 --> 00:28:37.646 A:middle
Well, adding an image is
something that is visible

00:28:37.886 --> 00:28:39.226 A:middle
to someone using
our application,

00:28:40.656 --> 00:28:42.666 A:middle
but it's not necessarily
required

00:28:42.666 --> 00:28:45.376 A:middle
to complete before we can
continue doing other things

00:28:45.376 --> 00:28:47.936 A:middle
like browsing images
or adding more images.

00:28:49.616 --> 00:28:52.476 A:middle
Additionally, because we are
showing that placeholder image,

00:28:52.856 --> 00:28:55.396 A:middle
we've given an indication
that this is an operation

00:28:55.396 --> 00:28:58.556 A:middle
that could take a
longer amount of time.

00:28:58.756 --> 00:29:01.306 A:middle
For all of those reasons,
the utility quality

00:28:58.756 --> 00:29:01.306 A:middle
For all of those reasons,
the utility quality

00:29:01.306 --> 00:29:03.996 A:middle
of service may be an appropriate
choice for this work.

00:29:04.626 --> 00:29:08.346 A:middle
So now that we know some ways

00:29:08.346 --> 00:29:10.866 A:middle
that you can move
expensive work, like I/O,

00:29:11.066 --> 00:29:14.146 A:middle
off of your main thread and
onto a separate dispatch queue

00:29:14.676 --> 00:29:16.156 A:middle
and how to specify the intent

00:29:16.156 --> 00:29:17.656 A:middle
of that work using
quality of service.

00:29:18.406 --> 00:29:21.496 A:middle
Let's take a look at the third
pillar of our I/O philosophy,

00:29:22.286 --> 00:29:26.336 A:middle
adopting appropriate API's,
and the first one that I'd

00:29:26.336 --> 00:29:29.066 A:middle
like to mention is
Asset Catalogs.

00:29:30.966 --> 00:29:33.386 A:middle
If you're not already aware,
Asset Catalogs are a way

00:29:33.386 --> 00:29:36.696 A:middle
to easily manage resources in
your application, like images.

00:29:37.646 --> 00:29:39.566 A:middle
They're used to store
things like your app icon

00:29:39.566 --> 00:29:42.526 A:middle
and launch images and
also all of the images

00:29:42.526 --> 00:29:45.616 A:middle
for the different devices that
you support and scale factors,

00:29:45.836 --> 00:29:47.586 A:middle
like retina or non-retina.

00:29:48.186 --> 00:29:50.556 A:middle
When building games
with SpriteKit,

00:29:50.906 --> 00:29:54.286 A:middle
Asset Catalogs are also the way
that you guild Sprite Atlases.

00:29:55.186 --> 00:29:58.876 A:middle
And you can use Asset Catalogs
to tag resources for use

00:29:58.876 --> 00:30:00.576 A:middle
with the on-demand
resources feature.

00:29:58.876 --> 00:30:00.576 A:middle
with the on-demand
resources feature.

00:30:01.766 --> 00:30:05.196 A:middle
And another good example of how
you can use Asset Catalogs is

00:30:05.196 --> 00:30:07.966 A:middle
for storing resources for
your watch complications.

00:30:09.976 --> 00:30:12.806 A:middle
So why are Asset
Catalogs great for I/O?

00:30:14.546 --> 00:30:16.576 A:middle
Well, Asset Catalogs
have some great storage

00:30:16.576 --> 00:30:17.686 A:middle
efficiency properties.

00:30:18.586 --> 00:30:21.906 A:middle
First of all, because
Asset Catalogs store all

00:30:21.906 --> 00:30:24.736 A:middle
of their images in a single
optimized format rather

00:30:24.736 --> 00:30:26.426 A:middle
than many individual files,

00:30:27.996 --> 00:30:29.696 A:middle
you can have a lower
on-disk footprint

00:30:29.856 --> 00:30:31.136 A:middle
by using Asset Catalogs.

00:30:32.996 --> 00:30:36.446 A:middle
Additionally, with features
like app slicing on iOS,

00:30:37.056 --> 00:30:39.196 A:middle
when you download an
app from the App Store,

00:30:39.706 --> 00:30:42.946 A:middle
it uses the metadata in your
Asset Catalog to determine

00:30:42.946 --> 00:30:45.456 A:middle
which resources it should
download to your device.

00:30:46.736 --> 00:30:49.326 A:middle
For example, if I download
an app to my iPhone,

00:30:50.086 --> 00:30:51.616 A:middle
the App Store knows
that it doesn't need

00:30:51.616 --> 00:30:55.196 A:middle
to download any resources for
an iPad or for any iPhones

00:30:55.196 --> 00:30:56.556 A:middle
with different screen
resolutions,

00:30:56.936 --> 00:31:01.376 A:middle
and this can save a lot
of space on my device.

00:30:56.936 --> 00:31:01.376 A:middle
and this can save a lot
of space on my device.

00:31:01.526 --> 00:31:04.626 A:middle
Furthermore, Asset Catalogs
can be great for performance.

00:31:05.636 --> 00:31:07.866 A:middle
Because of this optimized
format that they're stored in,

00:31:08.636 --> 00:31:09.856 A:middle
image loading can be faster.

00:31:11.226 --> 00:31:14.156 A:middle
And if you're using them to make
Sprite Atlases for your games,

00:31:15.216 --> 00:31:16.666 A:middle
since cheap user much better

00:31:16.666 --> 00:31:19.086 A:middle
at managing a single
larger resource rather

00:31:19.086 --> 00:31:20.776 A:middle
than many tiny resources,

00:31:21.476 --> 00:31:23.456 A:middle
these Sprites Atlases
can improve your texture

00:31:23.456 --> 00:31:24.296 A:middle
rendering times.

00:31:26.046 --> 00:31:29.036 A:middle
And, lastly, if you're
using Asset Catalogs

00:31:29.426 --> 00:31:31.406 A:middle
on hard-drive machines
running macOS,

00:31:32.416 --> 00:31:34.096 A:middle
you can also improve
your app launch time.

00:31:35.476 --> 00:31:38.676 A:middle
In fact, we've seen up to
a ten percent improvement

00:31:38.896 --> 00:31:41.546 A:middle
in app launch time on
these machines just

00:31:41.546 --> 00:31:43.106 A:middle
by switching to Asset Catalogs.

00:31:43.616 --> 00:31:47.866 A:middle
And you might be thinking to get

00:31:47.866 --> 00:31:49.456 A:middle
such a big performance
improvement,

00:31:49.866 --> 00:31:52.366 A:middle
this must be difficult or
time consuming to switch

00:31:52.366 --> 00:31:54.646 A:middle
to Asset Catalogs, but, in fact,

00:31:55.156 --> 00:31:57.076 A:middle
if you're already using
the standard NS image

00:31:57.126 --> 00:31:58.866 A:middle
and UI image based API's,

00:31:59.356 --> 00:32:01.316 A:middle
switching to Asset
Catalogs is easy,

00:31:59.356 --> 00:32:01.316 A:middle
switching to Asset
Catalogs is easy,

00:32:01.886 --> 00:32:04.736 A:middle
and I'd like to demonstrate that
now with an example project.

00:32:04.736 --> 00:32:07.866 A:middle
Here I have a project
that hasn't

00:32:07.866 --> 00:32:09.366 A:middle
yet adopted Asset Catalogs.

00:32:10.486 --> 00:32:14.046 A:middle
To get started, first
we can choose new file

00:32:14.156 --> 00:32:15.066 A:middle
from the file menu.

00:32:15.666 --> 00:32:18.986 A:middle
Then, from the resource
category,

00:32:19.646 --> 00:32:23.986 A:middle
select Asset Catalog
and click next.

00:32:24.856 --> 00:32:27.756 A:middle
Xcode creates a new, sorry.

00:32:29.126 --> 00:32:30.416 A:middle
When prompted, enter a name

00:32:30.416 --> 00:32:32.396 A:middle
for your Asset Catalog
and the location.

00:32:33.196 --> 00:32:34.126 A:middle
Then you can click create,

00:32:34.856 --> 00:32:37.386 A:middle
and now Xcode creates a
new blank Asset Catalog

00:32:38.086 --> 00:32:38.756 A:middle
in your project.

00:32:40.816 --> 00:32:44.206 A:middle
To move all of your existing
assets from your project

00:32:44.206 --> 00:32:47.806 A:middle
into this new Asset Catalog,
first open the add menu

00:32:47.806 --> 00:32:50.496 A:middle
at the bottom of the screen,
and choose import from project.

00:32:52.056 --> 00:32:56.026 A:middle
Xcode displays a list of all
of the images in your project,

00:32:56.646 --> 00:32:59.906 A:middle
and when I click import,
it will move all of these

00:33:00.036 --> 00:33:02.036 A:middle
into my new empty Asset Catalog.

00:33:02.766 --> 00:33:05.416 A:middle
Xcode automatically
figures out which images are

00:33:05.416 --> 00:33:07.636 A:middle
for which devices and
which scale factors.

00:33:08.216 --> 00:33:10.846 A:middle
Now when I rebuild
my application,

00:33:11.736 --> 00:33:15.476 A:middle
it will be using this new
Asset Catalog, and that's it.

00:33:16.136 --> 00:33:18.066 A:middle
It took less than a
minute, and I didn't have

00:33:18.066 --> 00:33:19.876 A:middle
to change a single line of code.

00:33:20.546 --> 00:33:22.746 A:middle
So it's really easy, and
I highly encourage you

00:33:22.746 --> 00:33:26.036 A:middle
to adopt Asset Catalogs
today if you haven't already.

00:33:27.896 --> 00:33:29.816 A:middle
One more thing I'd
like to mention

00:33:29.976 --> 00:33:32.186 A:middle
with Asset Catalogs is
a new feature this year,

00:33:32.976 --> 00:33:34.226 A:middle
and that's image compression.

00:33:36.116 --> 00:33:39.166 A:middle
By default, images in your
Asset Catalog are lossless,

00:33:40.436 --> 00:33:42.496 A:middle
but new this year, you
can choose from one

00:33:42.496 --> 00:33:45.276 A:middle
of the lossy image
compression formats.

00:33:46.816 --> 00:33:49.436 A:middle
These formats have hardware
accelerated decompression.

00:33:49.896 --> 00:33:50.926 A:middle
So they're really fast,

00:33:51.926 --> 00:33:54.596 A:middle
and because of the compressed
format, they can result

00:33:54.596 --> 00:33:55.786 A:middle
in lower memory footprints.

00:33:57.566 --> 00:33:59.576 A:middle
If you have a lot of
assets in your application,

00:34:00.416 --> 00:34:02.556 A:middle
you may benefit from
the potential memory

00:34:02.556 --> 00:34:04.526 A:middle
and space savings by
using image compression.

00:34:05.956 --> 00:34:08.676 A:middle
So let's see how we can
use image compression back

00:34:08.676 --> 00:34:11.636 A:middle
in the project that I just
converted to use Asset Catalogs.

00:34:13.226 --> 00:34:15.335 A:middle
First, let's click on
an image in our catalog.

00:34:16.596 --> 00:34:19.686 A:middle
Then open the utility sidebar
on the right-hand side.

00:34:21.136 --> 00:34:22.815 A:middle
And then click on the
attributes inspector.

00:34:24.326 --> 00:34:27.136 A:middle
New in Xcode is a
compression popup menu.

00:34:28.235 --> 00:34:30.686 A:middle
When I select that,
it displays all

00:34:30.686 --> 00:34:32.706 A:middle
of the available image
compression formats.

00:34:33.275 --> 00:34:37.416 A:middle
In this case, I'll
choose lossy automatic

00:34:37.856 --> 00:34:40.886 A:middle
so that Xcode can choose
a good format for me.

00:34:42.556 --> 00:34:46.036 A:middle
So that's a little bit about
how you can use Asset Catalogs

00:34:46.096 --> 00:34:48.196 A:middle
in your applications,
adopt them,

00:34:48.766 --> 00:34:50.406 A:middle
and use the new image
compression feature.

00:34:51.886 --> 00:34:53.616 A:middle
Now I'd like to hand
it back to Kushal,

00:34:54.196 --> 00:34:56.136 A:middle
who's going to tell you
more about some other API's

00:34:56.136 --> 00:34:58.636 A:middle
that you can adopt
for storing your data.

00:34:59.516 --> 00:35:05.796 A:middle
[ Applause ]

00:34:59.516 --> 00:35:05.796 A:middle
[ Applause ]

00:35:06.296 --> 00:35:06.846 A:middle
&gt;&gt; Thanks, Terry.

00:35:07.666 --> 00:35:09.956 A:middle
Asset catalogs are an
easy and efficient way

00:35:09.956 --> 00:35:12.076 A:middle
to manage your app's assets.

00:35:12.756 --> 00:35:15.416 A:middle
Another thing that a lot
of us think about is how

00:35:15.416 --> 00:35:17.906 A:middle
and where our application
data lives on device.

00:35:19.216 --> 00:35:22.906 A:middle
A lot of us are familiar with
the serialized data formats.

00:35:22.966 --> 00:35:25.656 A:middle
For example, Plists,
XML, and JSON.

00:35:26.926 --> 00:35:29.206 A:middle
The reason these data
formats are popular are

00:35:29.206 --> 00:35:31.346 A:middle
because of their
simplicity and ease of use,

00:35:31.926 --> 00:35:35.006 A:middle
and they have been made popular
as data interchange formats

00:35:35.406 --> 00:35:36.866 A:middle
in a lot of web-based services.

00:35:38.146 --> 00:35:41.856 A:middle
These data formats are good
for small read-only data

00:35:41.976 --> 00:35:43.546 A:middle
such as configuration
information

00:35:43.546 --> 00:35:44.886 A:middle
in your Info.plist file.

00:35:46.206 --> 00:35:48.276 A:middle
However, they are
not a database,

00:35:49.346 --> 00:35:51.706 A:middle
and the biggest reason
they are not a database is

00:35:51.706 --> 00:35:54.706 A:middle
that minor updates to these
files causes the entire data

00:35:54.706 --> 00:35:56.346 A:middle
file to be written
out of the disk,

00:35:56.626 --> 00:35:58.436 A:middle
which is really bad
for I/O efficiency.

00:35:59.376 --> 00:36:01.196 A:middle
For all your data storage needs,

00:35:59.376 --> 00:36:01.196 A:middle
For all your data storage needs,

00:36:01.466 --> 00:36:04.286 A:middle
we would recommend using Apple
SQLite database framework

00:36:04.546 --> 00:36:05.066 A:middle
core data.

00:36:06.446 --> 00:36:11.466 A:middle
Core data is the, is a Cocoa
application development

00:36:11.466 --> 00:36:13.766 A:middle
framework for managing
your application data.

00:36:14.356 --> 00:36:19.376 A:middle
It handles your data persistence

00:36:19.506 --> 00:36:21.646 A:middle
by using SQLite as
a backing store.

00:36:23.456 --> 00:36:26.436 A:middle
It automatically manages
objects, objects graphs,

00:36:26.436 --> 00:36:29.786 A:middle
and relationships between
those objects to allow you

00:36:29.826 --> 00:36:32.086 A:middle
to manage your data
easily and efficiently.

00:36:32.696 --> 00:36:36.846 A:middle
It also does change tracking,
will let you do, undo,

00:36:36.846 --> 00:36:38.806 A:middle
and redo operations
on your data models.

00:36:41.046 --> 00:36:43.456 A:middle
And core data is
completely integrated

00:36:43.456 --> 00:36:45.366 A:middle
with the Xcode tool chain
so that you can build

00:36:45.366 --> 00:36:48.056 A:middle
and visualize your data model
directly from the Xcode UI.

00:36:48.726 --> 00:36:54.126 A:middle
Now that we're aware of this
amazing tool and framework

00:36:54.126 --> 00:36:56.306 A:middle
to use for designing or
writing our data model,

00:36:56.786 --> 00:36:58.836 A:middle
let's think about how to
design our data model.

00:36:59.346 --> 00:37:02.706 A:middle
And the best way to do that
is to base your data model

00:36:59.346 --> 00:37:02.706 A:middle
And the best way to do that
is to base your data model

00:37:02.706 --> 00:37:04.466 A:middle
on the UI needs of
your application.

00:37:05.026 --> 00:37:07.276 A:middle
Let's go back to ImageBox,

00:37:07.366 --> 00:37:10.156 A:middle
which up until now has been
using a giant Plist to write

00:37:10.156 --> 00:37:12.656 A:middle
out all the files and
all the images associated

00:37:12.656 --> 00:37:13.916 A:middle
with the application,

00:37:14.796 --> 00:37:16.866 A:middle
and instead move it
to a core data model.

00:37:18.396 --> 00:37:20.026 A:middle
Now if you think
about the application,

00:37:20.026 --> 00:37:22.076 A:middle
there are two main
entities for ImageBox.

00:37:23.046 --> 00:37:25.136 A:middle
The first is the list
of items that's there

00:37:25.136 --> 00:37:29.076 A:middle
in the collection view, and
secondly is the notes associated

00:37:29.076 --> 00:37:30.066 A:middle
with each of these items.

00:37:31.236 --> 00:37:33.536 A:middle
So let's go ahead and put
them in a table of their own.

00:37:34.196 --> 00:37:37.656 A:middle
And the first table is BoxItem,

00:37:37.656 --> 00:37:39.776 A:middle
which represents a particular
item in the collection view,

00:37:40.526 --> 00:37:41.996 A:middle
and the second table is notes,

00:37:41.996 --> 00:37:43.386 A:middle
which represents
the notes itself.

00:37:44.556 --> 00:37:46.566 A:middle
The BoxItem table
contains a Boolean

00:37:46.846 --> 00:37:50.036 A:middle
which represents whether the
image is a favorite or not

00:37:50.036 --> 00:37:54.036 A:middle
and contains the full
resolution image of the image

00:37:54.136 --> 00:37:55.306 A:middle
that you need to represent.

00:37:56.646 --> 00:38:00.036 A:middle
The Notes table contains a note
body for all notes associated

00:37:56.646 --> 00:38:00.036 A:middle
The Notes table contains a note
body for all notes associated

00:38:00.036 --> 00:38:03.436 A:middle
with the BoxItem, and we relay
these two tables using a simple

00:38:03.436 --> 00:38:04.636 A:middle
one is too many relationship.

00:38:05.186 --> 00:38:09.256 A:middle
Now when we use this data model
and looked at the performance

00:38:09.256 --> 00:38:10.866 A:middle
of our application, we noticed

00:38:10.866 --> 00:38:12.976 A:middle
that the app launch
performance was really slow.

00:38:14.196 --> 00:38:16.876 A:middle
We investigated using
instruments, and we found

00:38:16.876 --> 00:38:18.326 A:middle
out that app was spending most

00:38:18.326 --> 00:38:21.386 A:middle
of its time fetching the core
data model on the launch pad.

00:38:22.596 --> 00:38:25.266 A:middle
So we need to take a look at
application launch performance

00:38:25.556 --> 00:38:28.116 A:middle
from core data's
perspective, and,

00:38:28.116 --> 00:38:30.546 A:middle
luckily core data
lets us do just that.

00:38:31.606 --> 00:38:34.576 A:middle
It has a set of tools that let
you investigate how core data is

00:38:34.576 --> 00:38:35.576 A:middle
doing on your behalf.

00:38:36.736 --> 00:38:39.176 A:middle
For example, you can
set a launch argument

00:38:39.176 --> 00:38:42.866 A:middle
on your application which
is Apple.CoreData.SQLDebug

00:38:43.156 --> 00:38:46.226 A:middle
with a velocity level that
lets you see how core data is

00:38:46.226 --> 00:38:48.166 A:middle
interacting with its
SQLite backing store.

00:38:49.596 --> 00:38:53.836 A:middle
The core data instruments
template lets you see

00:38:53.836 --> 00:38:55.676 A:middle
[inaudible] patterns
in terms of fetching

00:38:55.736 --> 00:38:56.946 A:middle
and loading too much data.

00:38:57.526 --> 00:39:03.226 A:middle
And, lastly, the standard set
of SQLite query analysis tools,

00:38:57.526 --> 00:39:03.226 A:middle
And, lastly, the standard set
of SQLite query analysis tools,

00:39:03.386 --> 00:39:05.486 A:middle
for example, explain
query, are available

00:39:05.766 --> 00:39:07.926 A:middle
which lets you dive deep
into a particular query

00:39:07.926 --> 00:39:09.236 A:middle
and find out its performance.

00:39:09.946 --> 00:39:13.076 A:middle
To learn more about these tools,

00:39:13.346 --> 00:39:17.126 A:middle
I would recommend you watching
last year's WWDC doc What's New

00:39:17.266 --> 00:39:17.906 A:middle
in Core Data.

00:39:19.506 --> 00:39:22.036 A:middle
Now that we have these tools,
let's use one of them to find

00:39:22.036 --> 00:39:23.376 A:middle
out what's wrong
with our data model.

00:39:25.086 --> 00:39:27.346 A:middle
In order to do that,
click on the project

00:39:27.956 --> 00:39:28.976 A:middle
and click edit scheme.

00:39:35.456 --> 00:39:37.466 A:middle
In the window that opens,

00:39:37.606 --> 00:39:39.146 A:middle
we're going to select
the arguments pane,

00:39:39.926 --> 00:39:46.056 A:middle
and then add a new argument
com.Apple.CoreData.SQLDebug

00:39:46.056 --> 00:39:53.166 A:middle
at the highest velocity
level of 3.

00:39:53.746 --> 00:39:57.106 A:middle
Once you are done with that,
we'll go ahead, and click close.

00:39:58.366 --> 00:40:01.696 A:middle
And now we simply launch our
application from the Xcode UI.

00:39:58.366 --> 00:40:01.696 A:middle
And now we simply launch our
application from the Xcode UI.

00:40:03.716 --> 00:40:06.196 A:middle
This should rebuild
your project, load it,

00:40:06.516 --> 00:40:07.676 A:middle
and launch the application.

00:40:08.276 --> 00:40:13.136 A:middle
As you'll notice here, the
console shows various logs

00:40:13.136 --> 00:40:14.876 A:middle
from core data about
its performance

00:40:15.156 --> 00:40:16.356 A:middle
in terms of the data model.

00:40:17.596 --> 00:40:19.046 A:middle
Another thing you
should notice is

00:40:19.046 --> 00:40:21.196 A:middle
that the app is taking
multiple seconds to launch,

00:40:21.196 --> 00:40:22.776 A:middle
and it still hasn't
finished launching.

00:40:23.316 --> 00:40:29.876 A:middle
We see some more data from core
data on the log output, and,

00:40:29.876 --> 00:40:31.406 A:middle
finally, the app launches.

00:40:32.596 --> 00:40:35.756 A:middle
If you go back to the Xcode
UI, you can dig through all

00:40:35.756 --> 00:40:36.826 A:middle
of these logs and figure

00:40:36.826 --> 00:40:38.566 A:middle
out what was wrong
with your data model.

00:40:39.306 --> 00:40:41.316 A:middle
So let's go ahead and do
that for our application.

00:40:41.926 --> 00:40:46.126 A:middle
Now one of the first
logs that you see here is

00:40:46.126 --> 00:40:48.646 A:middle
that core data is doing
a fetch of all the rows

00:40:48.976 --> 00:40:52.926 A:middle
from the SQLite database for
the BoxItem table, and it,

00:40:52.926 --> 00:40:55.966 A:middle
that is exactly what we expect.

00:40:55.966 --> 00:40:57.546 A:middle
However, the next log tells us

00:40:57.706 --> 00:41:01.706 A:middle
that that fetch took almost nine
seconds, and that's really bad,

00:40:57.706 --> 00:41:01.706 A:middle
that that fetch took almost nine
seconds, and that's really bad,

00:41:01.706 --> 00:41:04.736 A:middle
and one of the biggest reasons
of our app launch slowness.

00:41:06.356 --> 00:41:08.746 A:middle
Now if you go back to the
previous query that was executed

00:41:08.746 --> 00:41:11.686 A:middle
to fetch all this data,
one thing you'll notice is

00:41:11.686 --> 00:41:14.126 A:middle
that we are fetching the full
resolution image for each

00:41:14.126 --> 00:41:17.486 A:middle
of the items in the BoxItem
table even though we just show

00:41:17.486 --> 00:41:19.196 A:middle
thumbnail images on
the launch screen.

00:41:20.906 --> 00:41:24.926 A:middle
Moving on, we also notice
that core data is doing a join

00:41:24.926 --> 00:41:27.406 A:middle
between the BoxItem
table and the Notes table

00:41:27.726 --> 00:41:30.156 A:middle
for every item it fetches
from the BoxItem table.

00:41:31.016 --> 00:41:32.856 A:middle
And the reason it's
doing that is

00:41:32.856 --> 00:41:34.636 A:middle
because there is a one
is too many relationship

00:41:34.636 --> 00:41:38.246 A:middle
between these two entities,
and we need to show a UI batch

00:41:38.326 --> 00:41:39.096 A:middle
in the launch screen

00:41:39.096 --> 00:41:41.126 A:middle
to represent whether
there are notes associated

00:41:41.126 --> 00:41:41.946 A:middle
with the BoxItem.

00:41:42.506 --> 00:41:46.166 A:middle
So let's go ahead and
fix our data model.

00:41:46.166 --> 00:41:50.676 A:middle
The first thing we'll
fix is to avoid the join

00:41:50.676 --> 00:41:51.626 A:middle
between these two tables,

00:41:52.586 --> 00:41:55.276 A:middle
and the reason the core data
was doing this join again was

00:41:55.276 --> 00:41:57.756 A:middle
because it needs to show the,
and we need to show the UI

00:41:57.756 --> 00:42:00.506 A:middle
for whether notes are present
with the BoxItem or not.

00:41:57.756 --> 00:42:00.506 A:middle
for whether notes are present
with the BoxItem or not.

00:42:01.066 --> 00:42:04.616 A:middle
So to improve this model, we
can simply add another field

00:42:04.616 --> 00:42:07.306 A:middle
to the BoxItem table, which
is called notes present.

00:42:08.506 --> 00:42:11.616 A:middle
The presence or absence or
[inaudible] for false value

00:42:11.616 --> 00:42:13.986 A:middle
of this particular field
tells us whether we need

00:42:13.986 --> 00:42:16.886 A:middle
to put a UI badge on
the launch screen.

00:42:18.596 --> 00:42:20.906 A:middle
The next problem with
our data model was

00:42:20.906 --> 00:42:22.846 A:middle
that we were fetching the
full resolution images

00:42:22.846 --> 00:42:23.856 A:middle
at the launch screen.

00:42:24.886 --> 00:42:26.096 A:middle
So let's go ahead and fix that.

00:42:26.096 --> 00:42:29.096 A:middle
We replace the image
data with thumbnail data,

00:42:29.466 --> 00:42:31.826 A:middle
and instead move the full
resolution image data

00:42:31.826 --> 00:42:35.206 A:middle
into a table of its own,
and we link these two tables

00:42:35.206 --> 00:42:36.886 A:middle
by a simple one is
to one relationship.

00:42:37.446 --> 00:42:42.306 A:middle
Now as lot of you know, these
images can become really large,

00:42:42.856 --> 00:42:45.166 A:middle
and it might be a good
idea to store these images

00:42:45.166 --> 00:42:48.276 A:middle
as a separate file on the file
system rather than putting them

00:42:48.276 --> 00:42:49.426 A:middle
in the SQLite database.

00:42:50.846 --> 00:42:53.606 A:middle
So we're going to replace the
full resolution image being part

00:42:53.606 --> 00:42:56.656 A:middle
of the database itself
with the image URL

00:42:56.656 --> 00:42:59.036 A:middle
and store the images
directly on disk.

00:42:59.486 --> 00:43:02.246 A:middle
Now let's look at the
launch performance

00:42:59.486 --> 00:43:02.246 A:middle
Now let's look at the
launch performance

00:43:02.246 --> 00:43:04.166 A:middle
of our application once
we made these changes.

00:43:05.366 --> 00:43:07.196 A:middle
Again, we run the
project from the Xcode UI

00:43:07.196 --> 00:43:12.386 A:middle
with the new data model that
builds it and launches it.

00:43:14.266 --> 00:43:17.526 A:middle
As you saw there, the
application launched four

00:43:17.526 --> 00:43:20.036 A:middle
to five times faster just
by changing the data model.

00:43:21.056 --> 00:43:22.426 A:middle
So basing your data model

00:43:22.426 --> 00:43:25.006 A:middle
on your UI needs has significant
impact on your launch

00:43:25.006 --> 00:43:26.836 A:middle
and overall performance
of your application.

00:43:27.426 --> 00:43:32.236 A:middle
Now that we've taken a
look at ways you can reduce

00:43:32.236 --> 00:43:34.526 A:middle
and optimize the amount of
I/O's your application does,

00:43:34.946 --> 00:43:37.966 A:middle
let's see how you can test
your app for I/O performance.

00:43:38.576 --> 00:43:42.826 A:middle
One of the things we
recommend is to test your app

00:43:42.826 --> 00:43:44.076 A:middle
on a variety of devices.

00:43:45.346 --> 00:43:47.706 A:middle
If your app shifts on this,
on multiple platforms,

00:43:48.026 --> 00:43:51.346 A:middle
it might be a good idea to test
your application on a variety

00:43:51.346 --> 00:43:53.046 A:middle
of devices from all
those platforms.

00:43:54.086 --> 00:43:56.086 A:middle
Even if your app shifts
on a single platform,

00:43:56.336 --> 00:43:58.976 A:middle
it might be a good idea to
test it across generations

00:43:59.076 --> 00:44:01.256 A:middle
because I/O characteristics
vary widely.

00:43:59.076 --> 00:44:01.256 A:middle
because I/O characteristics
vary widely.

00:44:03.416 --> 00:44:06.956 A:middle
Now another thing that can
vary between your environment

00:44:06.956 --> 00:44:09.416 A:middle
and probably your app user
environment is the network

00:44:09.416 --> 00:44:12.926 A:middle
condition, and to help you
test your network conditions

00:44:12.926 --> 00:44:14.676 A:middle
or the worst-case
network conditions,

00:44:15.116 --> 00:44:17.266 A:middle
we provide a tool called
network link conditioner.

00:44:17.266 --> 00:44:21.046 A:middle
In order to get to the
network link conditioner,

00:44:21.306 --> 00:44:26.886 A:middle
open the settings app, scroll
all the way to the bottom to get

00:44:26.886 --> 00:44:32.536 A:middle
to the developer settings,
and tap on developer settings

00:44:32.696 --> 00:44:34.066 A:middle
which brings you to this menu.

00:44:35.346 --> 00:44:37.746 A:middle
Now as you see here, we have
the network link conditioner,

00:44:38.646 --> 00:44:41.436 A:middle
and tapping on that
opens up this menu

00:44:41.436 --> 00:44:42.576 A:middle
which shows various kinds

00:44:42.576 --> 00:44:44.246 A:middle
of profiles you can
install on your device.

00:44:45.266 --> 00:44:47.896 A:middle
We have 3G, high latency DNS,

00:44:47.896 --> 00:44:50.596 A:middle
and my favorite,
very bad network.

00:44:52.596 --> 00:44:55.416 A:middle
So let's go ahead and use that
by picking very bad network

00:44:55.976 --> 00:44:59.126 A:middle
and enabling it with using
the toggle switch on top.

00:44:59.986 --> 00:45:01.066 A:middle
And that's it.

00:44:59.986 --> 00:45:01.066 A:middle
And that's it.

00:45:01.646 --> 00:45:04.296 A:middle
Your device will now behave as
if it's in a very bad network,

00:45:04.336 --> 00:45:06.746 A:middle
and you can test your
application against it.

00:45:08.296 --> 00:45:10.576 A:middle
Another factor to remember is

00:45:10.576 --> 00:45:12.696 A:middle
that I/O is a shared
resource on the system.

00:45:13.486 --> 00:45:16.736 A:middle
So the I/O performance of your
application might be impacted

00:45:16.736 --> 00:45:18.086 A:middle
by other system resources

00:45:18.146 --> 00:45:23.176 A:middle
or other I/O's happening
in the device.

00:45:23.336 --> 00:45:25.366 A:middle
For example, if there
are other applications

00:45:25.366 --> 00:45:27.056 A:middle
that are running
due to multitasking,

00:45:27.476 --> 00:45:29.596 A:middle
your app's I/O performance
might be affected.

00:45:30.286 --> 00:45:32.116 A:middle
So it's a good idea to
test your application

00:45:32.116 --> 00:45:35.326 A:middle
in the presence of other apps.

00:45:35.616 --> 00:45:38.616 A:middle
Also, the system tries to
maintain a fair balance

00:45:38.616 --> 00:45:40.666 A:middle
between its memory
and I/O usage,

00:45:41.496 --> 00:45:43.386 A:middle
and under memory
pressure conditions,

00:45:43.686 --> 00:45:45.546 A:middle
your I/O latencies
might be affected.

00:45:46.506 --> 00:45:47.976 A:middle
So we would recommend
testing your app

00:45:47.976 --> 00:45:51.526 A:middle
under memory pressure
conditions as well.

00:45:51.696 --> 00:45:55.506 A:middle
Lastly, the system maintains
a bunch of caches by default

00:45:55.506 --> 00:45:57.496 A:middle
on your behalf to
help you access

00:45:57.496 --> 00:45:58.586 A:middle
and store your data better.

00:45:59.906 --> 00:46:02.986 A:middle
The state of these caches
could affect the system or,

00:45:59.906 --> 00:46:02.986 A:middle
The state of these caches
could affect the system or,

00:46:02.986 --> 00:46:04.806 A:middle
and I/O performance
of your application.

00:46:05.626 --> 00:46:07.606 A:middle
And to test the worst-case
behavior for that,

00:46:08.006 --> 00:46:10.796 A:middle
we would recommend rebooting
your device on an iOS device,

00:46:11.626 --> 00:46:13.876 A:middle
and on macOS, you can
use the merge command

00:46:14.196 --> 00:46:16.046 A:middle
which flushes all these caches

00:46:16.046 --> 00:46:18.656 A:middle
and simulates worst-case
behavior for our application.

00:46:20.036 --> 00:46:22.456 A:middle
To make sure that
your app is robust

00:46:22.456 --> 00:46:24.316 A:middle
against all these
environmental variations,

00:46:24.736 --> 00:46:26.516 A:middle
we recommend following
the I/O philosophy

00:46:26.516 --> 00:46:28.786 A:middle
to reduce an optimize
your I/O's.

00:46:29.696 --> 00:46:33.086 A:middle
So here are some key
takeaways from the talk.

00:46:33.306 --> 00:46:35.396 A:middle
Reduce the amount of I/O's
your application does

00:46:35.516 --> 00:46:38.886 A:middle
since that significantly
impacts battery life.

00:46:39.416 --> 00:46:43.046 A:middle
Move your I/O heavy workload
off the main thread and keep

00:46:43.046 --> 00:46:45.696 A:middle
that main thread idle
for UI and animations.

00:46:47.096 --> 00:46:50.656 A:middle
Specify proper quality of
service to specify the intent

00:46:50.656 --> 00:46:51.826 A:middle
of work you're performing.

00:46:52.346 --> 00:46:56.086 A:middle
Switch to Asset Catalog
since they're an easy

00:46:56.086 --> 00:47:00.186 A:middle
and efficient way to
manage your app's assets.

00:46:56.086 --> 00:47:00.186 A:middle
and efficient way to
manage your app's assets.

00:47:00.716 --> 00:47:04.566 A:middle
Use core data for all your
database needs, and, lastly,

00:47:04.716 --> 00:47:06.886 A:middle
test and measure your
app for I/O performance.

00:47:08.616 --> 00:47:11.086 A:middle
For more information,
go to www.apple.com,

00:47:11.086 --> 00:47:13.026 A:middle
and the session ID is 719.

00:47:13.026 --> 00:47:17.196 A:middle
Here is some related sessions
that happened during the week

00:47:17.196 --> 00:47:19.576 A:middle
that you can refer to for
more details on the API's

00:47:19.576 --> 00:47:20.856 A:middle
and tools we mentioned.

00:47:21.636 --> 00:47:22.396 A:middle
And thanks for your time.
