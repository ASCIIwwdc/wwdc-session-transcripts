WEBVTT

00:00:06.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:24.626 --> 00:00:25.396 A:middle
&gt;&gt; Morning, everyone.

00:00:26.696 --> 00:00:26.946 A:middle
Thanks.

00:00:27.516 --> 00:00:30.126 A:middle
[ Applause ]

00:00:30.626 --> 00:00:32.266 A:middle
&gt;&gt; My name is Aaftab Munshi.

00:00:32.726 --> 00:00:34.966 A:middle
And my colleagues and I
are really excited to share

00:00:34.966 --> 00:00:36.416 A:middle
with you the new
features in Metal

00:00:36.906 --> 00:00:38.826 A:middle
in macOS Sierra and iOS 10.

00:00:39.276 --> 00:00:43.026 A:middle
But let's begin by highlighting
the sessions we have

00:00:43.416 --> 00:00:45.236 A:middle
on Metal this year at WWDC.

00:00:45.426 --> 00:00:48.256 A:middle
So yesterday we had two
sessions that talked

00:00:48.256 --> 00:00:50.526 A:middle
about adopting Metal
in your application.

00:00:51.086 --> 00:00:53.116 A:middle
And today we have
three sessions.

00:00:53.356 --> 00:00:56.296 A:middle
So this session and
the two sessions

00:00:56.346 --> 00:00:59.296 A:middle
that cover the new features in
Metal, which is then followed

00:00:59.296 --> 00:01:01.076 A:middle
by another session
where we'll talk

00:00:59.296 --> 00:01:01.076 A:middle
by another session
where we'll talk

00:01:01.076 --> 00:01:03.136 A:middle
about optimizing
your Metal shaders.

00:01:03.706 --> 00:01:04.736 A:middle
All right.

00:01:04.736 --> 00:01:10.426 A:middle
So let's look at the features
we're going to talk about.

00:01:10.546 --> 00:01:13.426 A:middle
So in the second session the
features we will be talking

00:01:13.426 --> 00:01:16.916 A:middle
about are function or shader
specialization and being able

00:01:16.916 --> 00:01:20.106 A:middle
to write to resources such
as buffers and textures

00:01:20.436 --> 00:01:22.266 A:middle
from your fragment
and vortex shader,

00:01:22.766 --> 00:01:26.106 A:middle
wide color using wide color
displays in your application

00:01:26.106 --> 00:01:29.136 A:middle
and texture assets, and some
new additions we've added

00:01:29.136 --> 00:01:32.656 A:middle
to Metal performance shaders,
specifically using axillary

00:01:32.656 --> 00:01:34.656 A:middle
and [inaudible] networks
on the GPU with Metal.

00:01:35.226 --> 00:01:39.366 A:middle
In this session we're
going to talk about some

00:01:39.366 --> 00:01:41.686 A:middle
of the improvements we
have added to Tools,

00:01:41.686 --> 00:01:43.326 A:middle
which we think you guys
are going to really love.

00:01:43.956 --> 00:01:45.346 A:middle
We've also made resource heaps

00:01:45.486 --> 00:01:47.786 A:middle
and resource allocations
much faster

00:01:48.206 --> 00:01:49.256 A:middle
and given you more control.

00:01:49.376 --> 00:01:51.016 A:middle
So we'll talk about
that resource heaps

00:01:51.016 --> 00:01:52.146 A:middle
and memoryless render targets.

00:01:52.636 --> 00:01:54.396 A:middle
And I'm going to be
talking about tessellation.

00:01:54.766 --> 00:01:55.556 A:middle
So let's begin.

00:01:56.256 --> 00:01:56.946 A:middle
All right.

00:01:57.026 --> 00:02:01.376 A:middle
So the first thing, let's spend
a little bit of time trying

00:01:57.026 --> 00:02:01.376 A:middle
So the first thing, let's spend
a little bit of time trying

00:02:01.376 --> 00:02:03.766 A:middle
to understand why we
need tessellation.

00:02:04.256 --> 00:02:08.686 A:middle
So we are seeing applications
such as games rendering more

00:02:08.686 --> 00:02:10.256 A:middle
and more realistic
visual content.

00:02:10.606 --> 00:02:13.136 A:middle
So what that means is in
order to render such content,

00:02:13.136 --> 00:02:15.266 A:middle
we need to be able to
send detailed amount

00:02:15.266 --> 00:02:16.746 A:middle
of geometry to the GPU.

00:02:16.836 --> 00:02:18.366 A:middle
That's where we're going
to send this input.

00:02:19.076 --> 00:02:21.736 A:middle
That means lots and lots
of triangles that have

00:02:21.736 --> 00:02:24.246 A:middle
to be processed, which
means a large increase

00:02:24.246 --> 00:02:24.916 A:middle
in memory bandwidth.

00:02:25.286 --> 00:02:26.776 A:middle
It would be really nice

00:02:27.526 --> 00:02:31.076 A:middle
if instead we could just
describe this geometry

00:02:31.076 --> 00:02:33.756 A:middle
that we want to send to the GPU
as a lower resolution model,

00:02:34.006 --> 00:02:38.526 A:middle
call it a core smash, and
then have the GPU generate the

00:02:38.526 --> 00:02:39.516 A:middle
high-resolution model.

00:02:39.886 --> 00:02:42.756 A:middle
So in fact, that's
what tessellation does.

00:02:43.486 --> 00:02:45.886 A:middle
Tessellation is a technique
that you can use to amplify

00:02:45.886 --> 00:02:48.616 A:middle
and refine the details
of your geometric object.

00:02:49.006 --> 00:02:51.416 A:middle
We have two important
requirements we need to meet.

00:02:51.986 --> 00:02:55.276 A:middle
The first is that the
high-resolution model,

00:02:55.276 --> 00:02:58.456 A:middle
the triangles that are
generated do not get stored

00:02:58.456 --> 00:02:59.226 A:middle
in graphics memory.

00:02:59.266 --> 00:03:00.976 A:middle
We don't want to pay
that bandwidth cost.

00:02:59.266 --> 00:03:00.976 A:middle
We don't want to pay
that bandwidth cost.

00:03:01.066 --> 00:03:03.716 A:middle
And the second is a
method that's used needs

00:03:03.716 --> 00:03:04.396 A:middle
to be programmable.

00:03:04.666 --> 00:03:06.756 A:middle
So let's look at an example.

00:03:06.756 --> 00:03:10.726 A:middle
So here is a screenshot
from GFXBench 4.0,

00:03:10.926 --> 00:03:12.516 A:middle
which is a benchmark
released by [inaudible].

00:03:12.516 --> 00:03:15.656 A:middle
And one of the key features
it focuses on is tessellation.

00:03:15.836 --> 00:03:16.926 A:middle
So here's a screenshot

00:03:16.926 --> 00:03:19.666 A:middle
of the car that's being
rendered without tessellation.

00:03:19.786 --> 00:03:20.816 A:middle
You can see those rims.

00:03:21.616 --> 00:03:22.396 A:middle
They're very polygonal.

00:03:22.396 --> 00:03:23.856 A:middle
You wouldn't drive a car
like that, would you?

00:03:24.946 --> 00:03:27.676 A:middle
Even the body panels
have cracks in them.

00:03:28.076 --> 00:03:32.296 A:middle
And the reason for that is this
is the actual geometry that's

00:03:32.296 --> 00:03:32.986 A:middle
being sent.

00:03:32.986 --> 00:03:36.076 A:middle
So you can see not a lot of
triangles, which is great --

00:03:36.076 --> 00:03:38.076 A:middle
it's exactly what we want.

00:03:38.566 --> 00:03:41.356 A:middle
What tessellation does is
takes that input geometry

00:03:41.356 --> 00:03:42.896 A:middle
and produces something
like that.

00:03:44.336 --> 00:03:46.376 A:middle
I think this is really cool.

00:03:46.706 --> 00:03:48.686 A:middle
So if you look at
the wire frame,

00:03:49.016 --> 00:03:51.136 A:middle
you can see the GPUs
actually generating,

00:03:51.136 --> 00:03:53.736 A:middle
now we're rendering lots
and lots of triangles, okay?

00:03:53.736 --> 00:03:55.186 A:middle
And that's the power
of tessellation.

00:03:55.866 --> 00:03:56.276 A:middle
All right.

00:03:56.276 --> 00:03:58.976 A:middle
So let's look at how
tessellation works in Metal.

00:03:59.846 --> 00:04:04.186 A:middle
So just like we did
with Metal, you know,

00:03:59.846 --> 00:04:04.186 A:middle
So just like we did
with Metal, you know,

00:04:04.186 --> 00:04:07.506 A:middle
we wanted to take a clean
sheet approach, right?

00:04:07.506 --> 00:04:09.396 A:middle
We wanted to design
something that was --

00:04:09.816 --> 00:04:11.716 A:middle
even though there
are existing API's

00:04:11.886 --> 00:04:14.636 A:middle
that do support tessellation
that you may be familiar with,

00:04:14.936 --> 00:04:17.926 A:middle
we wanted something that
was really simple to graph,

00:04:18.046 --> 00:04:20.366 A:middle
you know, easy to use,
and we did not want

00:04:20.366 --> 00:04:21.755 A:middle
to leave any performance
on the table.

00:04:23.016 --> 00:04:25.676 A:middle
And we think we have achieved
that, and I hope you agree

00:04:25.746 --> 00:04:26.816 A:middle
after this presentation.

00:04:27.826 --> 00:04:31.736 A:middle
So tessellation is available
in macOS Sierra and on iOS

00:04:32.086 --> 00:04:33.196 A:middle
with the A9 processor.

00:04:33.296 --> 00:04:34.066 A:middle
All right.

00:04:34.066 --> 00:04:37.396 A:middle
So let's -- the things I'm
going to talk about is well,

00:04:37.596 --> 00:04:39.586 A:middle
how does the Metal
graphics pipeline look

00:04:39.586 --> 00:04:40.956 A:middle
like for tessellation?

00:04:41.556 --> 00:04:43.566 A:middle
How do I render my
geometry with tessellation?

00:04:43.566 --> 00:04:45.816 A:middle
And then how do I adopt
it in my application?

00:04:46.266 --> 00:04:46.866 A:middle
So let's begin.

00:04:47.726 --> 00:04:51.796 A:middle
So today when you send
primitives to the GPU

00:04:51.796 --> 00:04:55.696 A:middle
with Metal, you're sending
triangles, lines, or points.

00:04:56.186 --> 00:04:59.016 A:middle
With tessellation, you're
sending what we call a patch.

00:04:59.726 --> 00:05:02.916 A:middle
And put simply, a patch is
just a parametric surface

00:04:59.726 --> 00:05:02.916 A:middle
And put simply, a patch is
just a parametric surface

00:05:03.376 --> 00:05:04.856 A:middle
that is made up of
spline curves.

00:05:04.856 --> 00:05:05.576 A:middle
What does that mean?

00:05:05.576 --> 00:05:06.416 A:middle
You may have heard of things

00:05:06.416 --> 00:05:08.686 A:middle
like Bezier patches
or B-spline patches.

00:05:09.166 --> 00:05:12.476 A:middle
So you describe a patch by
a set of control-points.

00:05:12.476 --> 00:05:16.256 A:middle
So in this figure you
see is a B-spline patch.

00:05:16.256 --> 00:05:19.666 A:middle
So you have 16 control-points
or control vertices.

00:05:20.316 --> 00:05:25.096 A:middle
And what tessellation does put
simply is allows you to control,

00:05:25.156 --> 00:05:28.676 A:middle
okay, how many triangles do
I use to render this patch?

00:05:28.786 --> 00:05:30.056 A:middle
So you may decide,
"You know what?

00:05:30.296 --> 00:05:31.676 A:middle
I don't really want
a lot of triangles.

00:05:31.736 --> 00:05:33.186 A:middle
I don't care how it looks."

00:05:33.186 --> 00:05:36.386 A:middle
So you may decide just four
triangles is more than enough

00:05:36.386 --> 00:05:37.826 A:middle
and you'll get a polygonal look.

00:05:38.456 --> 00:05:41.446 A:middle
Or you decide, "Hey, I
really want this looking nice

00:05:41.446 --> 00:05:41.976 A:middle
and smooth."

00:05:43.296 --> 00:05:44.466 A:middle
That would take a
lot more triangles.

00:05:44.686 --> 00:05:46.266 A:middle
But you have that control.

00:05:47.086 --> 00:05:48.726 A:middle
So let's start.

00:05:48.936 --> 00:05:51.256 A:middle
So the first stage in
the graphics pipeline

00:05:51.256 --> 00:05:53.146 A:middle
when we're doing
tessellation is we call it a

00:05:53.146 --> 00:05:54.096 A:middle
tessellation kernel.

00:05:54.666 --> 00:05:56.576 A:middle
And what it does is
it takes the patch --

00:05:56.576 --> 00:05:59.016 A:middle
we talked about the patch with
the control-points as input --

00:05:59.436 --> 00:06:02.816 A:middle
and decides, okay, how much
do I need to subdivide this?

00:05:59.436 --> 00:06:02.816 A:middle
and decides, okay, how much
do I need to subdivide this?

00:06:03.146 --> 00:06:05.866 A:middle
How many triangles do I want
the GPU to generate, right?

00:06:06.256 --> 00:06:09.066 A:middle
This information is
captured in what we call

00:06:09.066 --> 00:06:10.246 A:middle
as tessellation factors.

00:06:10.396 --> 00:06:11.396 A:middle
And I'll talk a little bit

00:06:11.396 --> 00:06:14.056 A:middle
about what these factors
are a few slides later.

00:06:15.006 --> 00:06:18.346 A:middle
And you can also generate
additional patch data

00:06:18.346 --> 00:06:20.196 A:middle
if you need it in a later stage.

00:06:20.426 --> 00:06:22.256 A:middle
The key thing this is
a programmable stage,

00:06:22.256 --> 00:06:24.676 A:middle
that means you're writing code.

00:06:24.856 --> 00:06:27.376 A:middle
So once you've written
[inaudible] tessellation

00:06:27.376 --> 00:06:30.276 A:middle
factors, the next stage
is called the tessellator.

00:06:30.846 --> 00:06:32.336 A:middle
So this is a fixed
function stage.

00:06:32.516 --> 00:06:33.556 A:middle
So no code to write.

00:06:33.786 --> 00:06:37.266 A:middle
But you do net knobs
to configure it, okay?

00:06:37.506 --> 00:06:39.296 A:middle
So it takes those
tessellation factors

00:06:39.856 --> 00:06:42.046 A:middle
and breaks the patch
up into triangles.

00:06:42.766 --> 00:06:45.126 A:middle
And the key thing the
tessellator does here is

00:06:45.126 --> 00:06:46.576 A:middle
that it does not store

00:06:46.936 --> 00:06:49.216 A:middle
that triangle list it
generates in graphics memory.

00:06:49.996 --> 00:06:52.526 A:middle
In addition to the triangle
list it has generated,

00:06:52.786 --> 00:06:56.146 A:middle
for each vertex in the triangle
list it will generate what we

00:06:56.146 --> 00:06:58.936 A:middle
call a parametric coordinate
-- the U and the V value.

00:06:59.296 --> 00:07:02.656 A:middle
And it uses this along
with the control-points

00:06:59.296 --> 00:07:02.656 A:middle
And it uses this along
with the control-points

00:07:03.026 --> 00:07:05.946 A:middle
to compute the actual
position on the surface.

00:07:05.946 --> 00:07:07.156 A:middle
Okay? All right.

00:07:07.156 --> 00:07:09.316 A:middle
So the tessellator
generates triangles.

00:07:09.316 --> 00:07:13.666 A:middle
Today in Metal when you
want to render primitives,

00:07:13.906 --> 00:07:15.806 A:middle
you send triangles to the GPU.

00:07:16.246 --> 00:07:17.316 A:middle
What is the first thing

00:07:17.316 --> 00:07:20.876 A:middle
that happens is a vertex
shader is executed, right?

00:07:21.136 --> 00:07:23.196 A:middle
Well, here the tessellator's
generating triangles.

00:07:23.196 --> 00:07:25.966 A:middle
So if you think logically,

00:07:25.966 --> 00:07:29.316 A:middle
the next stage would be a
vertex shader, and it is.

00:07:29.546 --> 00:07:32.446 A:middle
We just call it the
post-tessellation vertex shader

00:07:32.446 --> 00:07:34.786 A:middle
because it's operating
on the triangles

00:07:34.786 --> 00:07:36.426 A:middle
that are generated
by the tessellator.

00:07:37.036 --> 00:07:40.876 A:middle
And so it's going to execute for
the vertices of the triangles

00:07:41.126 --> 00:07:43.426 A:middle
that the tessellator
generated and it's going

00:07:43.426 --> 00:07:45.846 A:middle
to output transform positions.

00:07:46.026 --> 00:07:48.076 A:middle
So if you're familiar
with DirectX,

00:07:48.206 --> 00:07:50.906 A:middle
it's this shader plays
the same, similar role

00:07:50.906 --> 00:07:53.776 A:middle
as the domain shader
does in DirectX.

00:07:55.046 --> 00:07:55.316 A:middle
All right.

00:07:55.316 --> 00:07:57.536 A:middle
And then the rest of the
pipeline remains the same.

00:07:57.536 --> 00:07:59.776 A:middle
We have the rasterizer and
the fragment shader, right?

00:08:00.136 --> 00:08:03.736 A:middle
So you may ask, "Well, so I need
to write this compute kernel

00:08:03.736 --> 00:08:05.296 A:middle
to generate the tessellation
factors.

00:08:05.816 --> 00:08:08.016 A:middle
Well, can I use the
vertex or fragment shader?"

00:08:08.536 --> 00:08:09.386 A:middle
Of course you can.

00:08:09.926 --> 00:08:12.816 A:middle
In fact, you don't even
need to write a shader

00:08:12.816 --> 00:08:15.456 A:middle
to generate these factors;
you may have precomputed them

00:08:15.856 --> 00:08:17.666 A:middle
and you can just load
them in a buffer and pass

00:08:17.696 --> 00:08:18.566 A:middle
that to the tessellator.

00:08:18.566 --> 00:08:19.936 A:middle
So you have a lot of control.

00:08:20.306 --> 00:08:25.016 A:middle
But if you are generating these
factors in the GPU, we recommend

00:08:25.016 --> 00:08:26.076 A:middle
that you use a compute kernel.

00:08:26.076 --> 00:08:27.116 A:middle
Because guess what?

00:08:27.496 --> 00:08:30.686 A:middle
That allows us to run
that kernel asynchronously

00:08:30.686 --> 00:08:31.606 A:middle
with other draw commands.

00:08:32.426 --> 00:08:33.746 A:middle
So netting you a performance win

00:08:33.946 --> 00:08:35.806 A:middle
and I think you guys
will like that.

00:08:36.775 --> 00:08:38.506 A:middle
Well, actually let's
take it a step further.

00:08:39.066 --> 00:08:40.756 A:middle
You don't even need to run
this kernel every frame.

00:08:41.346 --> 00:08:42.106 A:middle
Because guess what?

00:08:42.566 --> 00:08:44.576 A:middle
If you have computed the
tessellation factors --

00:08:44.576 --> 00:08:46.726 A:middle
let's say you decide,
"Hey, objects close

00:08:46.726 --> 00:08:49.186 A:middle
to the camera get much
more tessellation,

00:08:49.546 --> 00:08:51.666 A:middle
objects further away
not as much."

00:08:51.886 --> 00:08:53.806 A:middle
So once I've computed
them, then depending

00:08:53.806 --> 00:08:56.676 A:middle
on how the object is moving,
I can just apply a scale

00:08:57.116 --> 00:08:58.456 A:middle
and the tessellator takes that.

00:08:58.456 --> 00:09:01.266 A:middle
So really, the pipeline
is really, really simple.

00:08:58.456 --> 00:09:01.266 A:middle
So really, the pipeline
is really, really simple.

00:09:01.266 --> 00:09:02.946 A:middle
We have four stages.

00:09:03.406 --> 00:09:05.936 A:middle
So let's compare it with
the graphics pipeline

00:09:05.936 --> 00:09:06.806 A:middle
without tessellation.

00:09:08.096 --> 00:09:09.666 A:middle
So without tessellation
we have three stages --

00:09:10.416 --> 00:09:12.536 A:middle
we have vertex shade,
the rasterizer,

00:09:12.626 --> 00:09:13.456 A:middle
and the fragment stage.

00:09:13.686 --> 00:09:16.466 A:middle
With tessellation we added a
new stage, the tessellator.

00:09:16.466 --> 00:09:18.886 A:middle
It's fixed function so you
don't have to write any shader.

00:09:19.466 --> 00:09:22.256 A:middle
And the vertex shader became the
post-tessellation vertex shader.

00:09:23.396 --> 00:09:26.016 A:middle
We think this is really
simple to understand.

00:09:26.156 --> 00:09:28.306 A:middle
I hope you agree.

00:09:28.876 --> 00:09:29.556 A:middle
All right.

00:09:29.556 --> 00:09:31.956 A:middle
So how do I render my
geometry with tessellation?

00:09:32.746 --> 00:09:34.596 A:middle
There are four things
I'm going to talk about.

00:09:35.166 --> 00:09:37.226 A:middle
Okay. Let's look at
this post-tessellation

00:09:37.226 --> 00:09:39.986 A:middle
or post-tess vertex shader;
how is this different

00:09:39.986 --> 00:09:41.186 A:middle
from the regular vertex shader?

00:09:41.686 --> 00:09:43.386 A:middle
How do I pass my patch inputs?

00:09:43.756 --> 00:09:46.306 A:middle
And I told you that the
tessellator's configurable.

00:09:46.306 --> 00:09:48.046 A:middle
So let's look at
how we configure it

00:09:48.046 --> 00:09:48.876 A:middle
and then draw patches.

00:09:50.886 --> 00:09:53.166 A:middle
So, well, meet the new shader,
same with the old shader.

00:09:53.406 --> 00:09:56.266 A:middle
So in fact, you declare a
post-tessellation vertex shader

00:09:56.266 --> 00:09:57.356 A:middle
with a vertex qualifier.

00:09:57.356 --> 00:10:01.536 A:middle
But in addition to that, you
also specify this attribute

00:09:57.356 --> 00:10:01.536 A:middle
But in addition to that, you
also specify this attribute

00:10:01.536 --> 00:10:03.286 A:middle
which says, "Hey, it's
working on a patch."

00:10:03.536 --> 00:10:06.646 A:middle
There are two kinds of patches
-- a quad and triangle patch.

00:10:06.726 --> 00:10:08.186 A:middle
And you see the number
next to that?

00:10:08.186 --> 00:10:11.586 A:middle
That number tells you how many
control-points this patch is

00:10:11.586 --> 00:10:12.056 A:middle
working on.

00:10:13.006 --> 00:10:15.116 A:middle
So if you had a regular
vertex shader,

00:10:15.146 --> 00:10:17.296 A:middle
you would have passed
a vertex ideas input.

00:10:17.796 --> 00:10:19.836 A:middle
Now you pass a patchID as input.

00:10:20.536 --> 00:10:22.936 A:middle
Remember I told you the
tessellator generated a

00:10:22.936 --> 00:10:24.936 A:middle
parametric UV coordinate?

00:10:25.006 --> 00:10:28.106 A:middle
Well, that's what this
position in patch input is.

00:10:28.646 --> 00:10:31.266 A:middle
And then if you had a
regular vertex shader,

00:10:31.266 --> 00:10:33.236 A:middle
you would have passed
something as stage in,

00:10:33.506 --> 00:10:35.416 A:middle
the patch input we
passed at the stage in.

00:10:36.016 --> 00:10:37.636 A:middle
Everything else you
just bring computations

00:10:37.696 --> 00:10:40.936 A:middle
and you're generating a
transformed vertex output.

00:10:40.936 --> 00:10:43.676 A:middle
And that's actually going
to be exactly identical

00:10:43.676 --> 00:10:45.266 A:middle
because the next stage with

00:10:45.266 --> 00:10:48.326 A:middle
or without tessellation
is a rasterizer.

00:10:50.316 --> 00:10:50.636 A:middle
All right.

00:10:50.636 --> 00:10:51.806 A:middle
So let's look at patch inputs.

00:10:52.616 --> 00:10:55.056 A:middle
So if you had a regular
vertex shader,

00:10:55.246 --> 00:10:57.176 A:middle
you would have described
your vertex input

00:10:57.176 --> 00:10:59.326 A:middle
as a struct, okay,
in your shader.

00:10:59.396 --> 00:11:03.026 A:middle
And if you had decoupled the
date type, that means the layout

00:10:59.396 --> 00:11:03.026 A:middle
And if you had decoupled the
date type, that means the layout

00:11:03.026 --> 00:11:05.246 A:middle
and the buffers where the
vertex inputs are coming

00:11:05.246 --> 00:11:08.176 A:middle
from do not match the
declaration in the shader,

00:11:08.176 --> 00:11:10.326 A:middle
then you would have used
the MTLVertexDescriptor

00:11:10.326 --> 00:11:12.116 A:middle
to describe the layout.

00:11:12.576 --> 00:11:14.946 A:middle
Well, for patches
there are two inputs.

00:11:15.096 --> 00:11:17.336 A:middle
One is the per-patch input.

00:11:17.746 --> 00:11:20.666 A:middle
And remember, I told there are
one or more control-points?

00:11:21.096 --> 00:11:23.476 A:middle
So we need to specify
those as inputs as well.

00:11:23.866 --> 00:11:27.466 A:middle
But it looks identical
how you specify these.

00:11:27.716 --> 00:11:31.356 A:middle
So you use a MTLVertexDescriptor
to specify the layout

00:11:31.356 --> 00:11:33.656 A:middle
of the patch input
data in memory.

00:11:34.186 --> 00:11:37.246 A:middle
And as I showed you the slide
before, we declared that input

00:11:37.246 --> 00:11:38.256 A:middle
as a stage in as well.

00:11:38.776 --> 00:11:43.376 A:middle
And you use the attribute index
to identify an element as input

00:11:43.376 --> 00:11:46.036 A:middle
in the shader with the
corresponding declaration

00:11:46.376 --> 00:11:47.926 A:middle
in your MTLVertexDescriptor.

00:11:49.136 --> 00:11:53.906 A:middle
Since there can be more than one
control-point, we basically have

00:11:53.906 --> 00:11:55.686 A:middle
to declare it using
a template type.

00:11:55.686 --> 00:11:57.546 A:middle
And I'll talk about
that in the next slide.

00:11:57.546 --> 00:11:58.656 A:middle
So let's look at an example.

00:11:58.656 --> 00:12:00.906 A:middle
So here I have my
control-point data.

00:11:58.656 --> 00:12:00.906 A:middle
So here I have my
control-point data.

00:12:01.036 --> 00:12:02.096 A:middle
It has two elements.

00:12:02.346 --> 00:12:04.086 A:middle
So I'm using attributes
zero and one.

00:12:04.966 --> 00:12:07.846 A:middle
And my per-patch data, which
is attributes two and three.

00:12:08.256 --> 00:12:09.926 A:middle
So we combine these
two things together

00:12:09.926 --> 00:12:12.526 A:middle
and this is my patch
input for every patch.

00:12:13.086 --> 00:12:16.386 A:middle
So notice that control templated
type patch underscore control

00:12:16.386 --> 00:12:17.096 A:middle
underscore point.

00:12:17.556 --> 00:12:20.316 A:middle
So that's what tells the
Metal shading compiler "Hey,

00:12:20.316 --> 00:12:21.916 A:middle
this is referring to
control-point input."

00:12:22.346 --> 00:12:25.286 A:middle
Okay? And remember I told
you about this number 16

00:12:25.286 --> 00:12:26.436 A:middle
or whatever the number is?

00:12:26.886 --> 00:12:29.286 A:middle
That also tells the Metal
shading compiler how many

00:12:29.286 --> 00:12:30.326 A:middle
control-points there are.

00:12:30.866 --> 00:12:34.626 A:middle
So now we have all information
we need to get the patch input.

00:12:35.156 --> 00:12:36.846 A:middle
And so we just pass
that as stage in.

00:12:37.776 --> 00:12:41.276 A:middle
It's pretty simple, I think.

00:12:42.216 --> 00:12:42.516 A:middle
All right.

00:12:43.526 --> 00:12:45.546 A:middle
So okay, how do I
configure knobs?

00:12:45.716 --> 00:12:46.856 A:middle
So there are properties

00:12:46.856 --> 00:12:49.026 A:middle
in the
MTLRenderPipelineDescriptor you

00:12:49.026 --> 00:12:49.436 A:middle
can set.

00:12:49.986 --> 00:12:54.476 A:middle
A few examples are you can tell
the tessellator the method you

00:12:54.476 --> 00:12:56.566 A:middle
want to use to generate
the triangles;

00:12:56.566 --> 00:12:57.886 A:middle
it's called the partitioning
mode.

00:12:58.656 --> 00:13:01.696 A:middle
You can also specify a
max tessellation level.

00:12:58.656 --> 00:13:01.696 A:middle
You can also specify a
max tessellation level.

00:13:02.016 --> 00:13:04.926 A:middle
And we think this is
really, really useful

00:13:04.926 --> 00:13:08.186 A:middle
because it allows you to control
the maximum amount of geometry

00:13:08.526 --> 00:13:10.976 A:middle
that the GPU will generate
for your tessellated objects.

00:13:11.696 --> 00:13:14.996 A:middle
Remember, the tessellator
needs to read these factors.

00:13:15.256 --> 00:13:17.396 A:middle
So you need to specify the
buffer of where they come from.

00:13:17.856 --> 00:13:21.016 A:middle
So use the
setTessellationFactorBuffer API

00:13:21.646 --> 00:13:22.116 A:middle
to do that.

00:13:22.336 --> 00:13:26.416 A:middle
Now, these factors,
so they tell how much

00:13:26.456 --> 00:13:30.046 A:middle
to subdivide the patches along
the edges and on the inside.

00:13:30.536 --> 00:13:32.206 A:middle
So we have two kinds of patches.

00:13:32.206 --> 00:13:33.536 A:middle
If it's a triangular patch,

00:13:33.666 --> 00:13:35.756 A:middle
there are three edges
and one inside.

00:13:36.186 --> 00:13:39.616 A:middle
If it's a quad, then you have
four edges and two insides.

00:13:39.616 --> 00:13:43.516 A:middle
So you specify these as half
precision floating point values

00:13:43.846 --> 00:13:45.156 A:middle
that you pass in.

00:13:47.466 --> 00:13:48.376 A:middle
And then drawing.

00:13:48.776 --> 00:13:51.586 A:middle
So today when you're
drawing primitives,

00:13:51.926 --> 00:13:53.866 A:middle
you're sending triangles
to be rendered by the GPU,

00:13:54.216 --> 00:13:55.736 A:middle
you're either going
to call drawPrimitives

00:13:56.056 --> 00:13:57.406 A:middle
or drawIndexPrimitives.

00:13:57.986 --> 00:14:00.996 A:middle
You the specify the start
vertex, number of vertices.

00:13:57.986 --> 00:14:00.996 A:middle
You the specify the start
vertex, number of vertices.

00:14:01.406 --> 00:14:03.776 A:middle
And if your vertex
indexes are not continuous,

00:14:03.836 --> 00:14:05.236 A:middle
you will pass an index buffer.

00:14:05.766 --> 00:14:08.006 A:middle
Well, to draw patches,
you call drawPatches

00:14:08.766 --> 00:14:09.896 A:middle
or drawIndexedPatches.

00:14:10.246 --> 00:14:13.216 A:middle
You specify the start patch,
the number of patches.

00:14:13.216 --> 00:14:15.886 A:middle
And if you're control-point
indexes are not continuous,

00:14:16.016 --> 00:14:17.336 A:middle
you specify an index buffer.

00:14:17.596 --> 00:14:18.946 A:middle
So it's just a one-to-one
mapping.

00:14:19.556 --> 00:14:22.716 A:middle
And then there is the
DrawIndirect variants.

00:14:23.176 --> 00:14:25.576 A:middle
And what these are is
that you do not specify

00:14:25.996 --> 00:14:28.076 A:middle
where the start patch
and how many patches

00:14:28.306 --> 00:14:31.136 A:middle
and other information when
you make the draw call,

00:14:31.306 --> 00:14:32.636 A:middle
but instead you pass a buffer.

00:14:33.516 --> 00:14:35.896 A:middle
And that gets filled out
with this information

00:14:35.896 --> 00:14:38.746 A:middle
by a command that's running on
the GPU, just like you would do

00:14:38.746 --> 00:14:39.756 A:middle
for drawPrimitives as well.

00:14:40.436 --> 00:14:43.336 A:middle
So really, if you don't know
how to use drawPrimitives,

00:14:43.836 --> 00:14:46.846 A:middle
then drawPatches just
works very similarly.

00:14:47.076 --> 00:14:49.216 A:middle
Okay? So we think this
is really easy to use.

00:14:49.936 --> 00:14:50.676 A:middle
All right?

00:14:51.616 --> 00:14:55.976 A:middle
So hold on.

00:14:57.466 --> 00:15:00.386 A:middle
So I've shown you what
Metal tessellation is

00:14:57.466 --> 00:15:00.386 A:middle
So I've shown you what
Metal tessellation is

00:15:00.646 --> 00:15:02.446 A:middle
and how to use it.

00:15:02.796 --> 00:15:05.366 A:middle
As many of you may
be familiar with

00:15:05.366 --> 00:15:09.376 A:middle
or already using tessellation in
your application using DirectX

00:15:09.846 --> 00:15:12.526 A:middle
or OpenGL, you will notice
Metal tessellation's a

00:15:12.526 --> 00:15:13.106 A:middle
little different.

00:15:13.596 --> 00:15:14.146 A:middle
Don't worry.

00:15:14.516 --> 00:15:15.816 A:middle
We've designed Metal
tessellation

00:15:15.966 --> 00:15:17.326 A:middle
so it's incredibly
straightforward

00:15:17.326 --> 00:15:19.916 A:middle
to move your existing
tessellation code to Metal.

00:15:20.296 --> 00:15:23.736 A:middle
As an example, for the past
few weeks we've been working

00:15:23.736 --> 00:15:24.326 A:middle
with Unity.

00:15:24.896 --> 00:15:28.026 A:middle
And in an incredibly short
period of time they've been able

00:15:28.026 --> 00:15:30.666 A:middle
to integrate Metal
Tessellation in the engine.

00:15:30.996 --> 00:15:34.836 A:middle
And here's what they
have to say.

00:15:35.076 --> 00:15:38.916 A:middle
So we're really excited that
support for Metal Tessellation,

00:15:39.226 --> 00:15:42.296 A:middle
Metal Compute and the ability
to write native Metal shaders

00:15:42.296 --> 00:15:43.756 A:middle
in Unity's coming
later this year.

00:15:44.066 --> 00:15:46.266 A:middle
It's incredibly exciting.

00:15:46.596 --> 00:15:48.666 A:middle
And we've also been
working with Epic

00:15:49.386 --> 00:15:52.546 A:middle
to efficiently integrate Metal
Tessellation in Unreal Engine 4.

00:15:53.336 --> 00:15:56.546 A:middle
And Epic is planning to
release their support

00:15:56.656 --> 00:15:58.836 A:middle
in UE4 later this year, okay?

00:16:00.176 --> 00:16:04.226 A:middle
So we have UE4, we have Unity
supporting Metal Tessellation.

00:16:04.716 --> 00:16:09.516 A:middle
Well, let me show you
tessellation in action

00:16:09.916 --> 00:16:11.316 A:middle
in these game engines

00:16:11.316 --> 00:16:15.106 A:middle
by demonstrating two commonly
used rendering techniques called

00:16:15.106 --> 00:16:18.276 A:middle
adaptive tessellation
and displacement mapping.

00:16:19.906 --> 00:16:21.226 A:middle
All right.

00:16:25.056 --> 00:16:31.786 A:middle
So here we have a
simple demo developed

00:16:31.786 --> 00:16:35.126 A:middle
by a few Apple engineers
using Unreal Engine 4.

00:16:35.196 --> 00:16:37.466 A:middle
So let's turn tessellation
off, which I have,

00:16:37.566 --> 00:16:38.776 A:middle
and get wire frame mode.

00:16:39.276 --> 00:16:40.486 A:middle
You can see there are not a lot

00:16:40.486 --> 00:16:42.506 A:middle
of triangles being
sent to the GPU.

00:16:42.506 --> 00:16:43.446 A:middle
This is great.

00:16:43.446 --> 00:16:44.546 A:middle
This is exactly what we want.

00:16:44.546 --> 00:16:46.816 A:middle
We want to keep the amount of
geometry we send to the GPU

00:16:46.816 --> 00:16:48.146 A:middle
to be as little as possible.

00:16:48.596 --> 00:16:51.056 A:middle
Let's turn tessellation
on and see what happens.

00:16:52.246 --> 00:16:55.356 A:middle
You can see now the GPU is
generating a lot more triangles.

00:16:56.156 --> 00:16:59.066 A:middle
And adaptive tessellation
is a technique that allows

00:16:59.066 --> 00:17:02.006 A:middle
to control the geometric
detail where it matters.

00:16:59.066 --> 00:17:02.006 A:middle
to control the geometric
detail where it matters.

00:17:02.226 --> 00:17:05.415 A:middle
So in this example we've decided
that objects that are closer

00:17:05.415 --> 00:17:06.906 A:middle
to the camera need more detail.

00:17:07.286 --> 00:17:09.185 A:middle
So let's draw them with
a lot more triangles

00:17:09.185 --> 00:17:11.086 A:middle
versus objects further
away do not.

00:17:11.415 --> 00:17:15.836 A:middle
So the regions in blue represent
regions of lowest amount

00:17:15.836 --> 00:17:18.646 A:middle
of tessellation, and the region
in red represents the regions

00:17:18.646 --> 00:17:19.876 A:middle
with the highest
amount of tessellation.

00:17:19.876 --> 00:17:22.236 A:middle
I can show you as I move
the slider to the right,

00:17:22.465 --> 00:17:24.425 A:middle
I can use that to increase
my tessellation level

00:17:24.425 --> 00:17:27.266 A:middle
and you can see objects
closer will become red.

00:17:27.715 --> 00:17:30.556 A:middle
Okay? Well, let's turn
wire frame mode off.

00:17:31.416 --> 00:17:34.196 A:middle
And if you run -- as we
go through this cave,

00:17:34.556 --> 00:17:36.506 A:middle
you can see there's a
lot more detail, right?

00:17:36.506 --> 00:17:40.226 A:middle
If I turn tessellation off, all
that detail is gone, it's lost.

00:17:41.106 --> 00:17:43.976 A:middle
Turn tessellation on,
it looks really amazing.

00:17:44.356 --> 00:17:49.526 A:middle
So this is an example of
how I can use tessellation

00:17:50.396 --> 00:17:53.826 A:middle
to really create rich visual
scenes in my application.

00:17:54.346 --> 00:17:56.886 A:middle
And I wanted to thank
the great folks at Epic

00:17:56.886 --> 00:17:57.846 A:middle
for making this happen.

00:17:58.776 --> 00:18:09.646 A:middle
So the next demo is displacement
mapping running on Unity.

00:17:58.776 --> 00:18:09.646 A:middle
So the next demo is displacement
mapping running on Unity.

00:18:10.156 --> 00:18:11.816 A:middle
So here we have a
sphere being rendered.

00:18:12.436 --> 00:18:14.256 A:middle
Well, let's look at how
many triangles we're using

00:18:14.256 --> 00:18:15.036 A:middle
to render the sphere.

00:18:16.416 --> 00:18:17.506 A:middle
Not a lot, right?

00:18:17.506 --> 00:18:19.366 A:middle
There are about 3,000 triangles.

00:18:19.836 --> 00:18:22.346 A:middle
And what displacement
mapping is, is a technique

00:18:22.346 --> 00:18:25.706 A:middle
that allows you to
displace the geometry

00:18:26.056 --> 00:18:27.706 A:middle
to create incredible detail.

00:18:28.216 --> 00:18:30.416 A:middle
And it does that
by looking up --

00:18:30.736 --> 00:18:33.646 A:middle
using a displacement
map, which is a texture.

00:18:33.646 --> 00:18:36.426 A:middle
So you look up, you know, from
a texture, from this texture

00:18:36.426 --> 00:18:39.126 A:middle
and then use that to
[inaudible] the vertex position.

00:18:39.526 --> 00:18:41.706 A:middle
Or you may actually do this
procedurally if you wanted to.

00:18:42.306 --> 00:18:45.846 A:middle
But displacement mapping
requires that, you know,

00:18:45.846 --> 00:18:48.166 A:middle
you're drawing lots and
lots of really, really,

00:18:48.166 --> 00:18:49.496 A:middle
really small triangles.

00:18:49.636 --> 00:18:50.466 A:middle
Otherwise it doesn't work.

00:18:50.466 --> 00:18:52.106 A:middle
It creates artifacts,
it just cracks.

00:18:52.606 --> 00:18:53.826 A:middle
But that's fine, you know?

00:18:53.826 --> 00:18:54.706 A:middle
We can use tessellation.

00:18:54.706 --> 00:18:55.516 A:middle
That's what it's here for.

00:18:55.896 --> 00:18:58.426 A:middle
Because we still want
to send 3,000 triangles,

00:18:58.426 --> 00:18:59.786 A:middle
smaller triangles to the GPU

00:19:00.166 --> 00:19:01.526 A:middle
and use tessellation
to generate that.

00:19:01.526 --> 00:19:02.776 A:middle
So let's turn wire
frame mode off

00:19:03.206 --> 00:19:04.936 A:middle
and let's turn displacement
mapping on.

00:19:06.286 --> 00:19:09.516 A:middle
As you can see now incredible
detail on the sphere, right?

00:19:09.516 --> 00:19:11.036 A:middle
If I turn wire frame mode on,

00:19:11.566 --> 00:19:14.386 A:middle
you can see we're generating
a lot more triangles

00:19:14.516 --> 00:19:15.816 A:middle
and they are really,
really small.

00:19:16.416 --> 00:19:18.706 A:middle
In fact, let's actually
animate the displacement map

00:19:18.706 --> 00:19:20.576 A:middle
so you can see the
shapes changing

00:19:20.856 --> 00:19:24.946 A:middle
and let's zoom in to see detail.

00:19:25.156 --> 00:19:26.776 A:middle
You can see self-shadowing
happening.

00:19:27.896 --> 00:19:30.646 A:middle
And the reason self-shadowing
is happening here is

00:19:30.696 --> 00:19:33.206 A:middle
because we're actually
changing the geometry,

00:19:33.616 --> 00:19:36.116 A:middle
unlike a technique many
of you may be familiar

00:19:36.116 --> 00:19:37.026 A:middle
with called bump mapping

00:19:37.326 --> 00:19:39.206 A:middle
which just creates an
illusion of realism.

00:19:39.466 --> 00:19:41.526 A:middle
So this is another
technique which you can use

00:19:41.806 --> 00:19:44.526 A:middle
with tessellation to
create incredible detail

00:19:44.526 --> 00:19:46.256 A:middle
in your application
that you're rendering.

00:19:46.716 --> 00:19:50.306 A:middle
And hey, thank you to
Unity for this demo.

00:19:51.516 --> 00:19:57.786 A:middle
[ Applause ]

00:19:58.286 --> 00:19:58.566 A:middle
All right.

00:19:58.566 --> 00:19:58.876 A:middle
So

00:20:05.306 --> 00:20:07.556 A:middle
Metal Tessellation
can also be used

00:20:07.556 --> 00:20:09.846 A:middle
to accelerate digital
content creation tools.

00:20:10.426 --> 00:20:14.586 A:middle
As an example OpenSubdiv is an
open source library released

00:20:14.586 --> 00:20:15.016 A:middle
by Pixar.

00:20:15.766 --> 00:20:17.856 A:middle
And it implements
high-performance

00:20:17.856 --> 00:20:18.866 A:middle
subdivision surfaces.

00:20:19.206 --> 00:20:21.196 A:middle
Actually, it has been
integrated into a number

00:20:21.196 --> 00:20:23.726 A:middle
of third-party digital
content creation tools,

00:20:24.066 --> 00:20:25.686 A:middle
such as Maya from Autodesk.

00:20:26.716 --> 00:20:28.736 A:middle
And OpenSubdiv uses tessellation

00:20:28.936 --> 00:20:30.656 A:middle
to render these subdivision
surfaces.

00:20:31.316 --> 00:20:34.976 A:middle
Well, we -- Apple -- have
added Metal Tessellation

00:20:34.976 --> 00:20:35.976 A:middle
into OpenSubdiv.

00:20:35.976 --> 00:20:38.726 A:middle
And I'm really excited to
announce here that we plan

00:20:38.726 --> 00:20:39.686 A:middle
to release these changes

00:20:39.716 --> 00:20:42.746 A:middle
to the OpenSubdiv open source
project later this summer.

00:20:42.746 --> 00:20:45.126 A:middle
Okay. I mean, here's
what Pixar has to say.

00:20:46.576 --> 00:20:48.156 A:middle
As you can see, Pixar's
really excited

00:20:48.156 --> 00:20:49.956 A:middle
to see a native Metal
implementation

00:20:50.366 --> 00:20:55.976 A:middle
of OpenSubdiv in iOS and macOS.

00:20:56.046 --> 00:20:56.246 A:middle
All right.

00:20:56.246 --> 00:20:58.766 A:middle
So now you may be asking,
"Well, what about me?

00:20:59.176 --> 00:21:02.346 A:middle
How do I move my existing
tessellation code to Metal?"

00:20:59.176 --> 00:21:02.346 A:middle
How do I move my existing
tessellation code to Metal?"

00:21:02.346 --> 00:21:03.816 A:middle
Well, let me show you how.

00:21:04.546 --> 00:21:06.216 A:middle
So we'll take DirectX
an as example here,

00:21:06.216 --> 00:21:07.796 A:middle
but the same rules
apply to OpenGL.

00:21:07.796 --> 00:21:11.516 A:middle
So here is what the DirectX
graphics pipeline looks

00:21:11.516 --> 00:21:12.416 A:middle
like with tessellation.

00:21:12.906 --> 00:21:15.516 A:middle
We have three new stages --
two of them are programmable.

00:21:15.516 --> 00:21:17.066 A:middle
They're called the hull
and the domain shader.

00:21:17.526 --> 00:21:19.026 A:middle
And then we have this
tessellator in the middle.

00:21:19.136 --> 00:21:20.016 A:middle
Right? So, well, okay.

00:21:20.056 --> 00:21:20.966 A:middle
How do I move this to Metal?

00:21:21.396 --> 00:21:23.136 A:middle
Notice where the
domain shader sits.

00:21:23.136 --> 00:21:24.426 A:middle
It sits right after
the tessellator.

00:21:24.426 --> 00:21:27.396 A:middle
Does it remind you of any
other shader I showed you

00:21:27.396 --> 00:21:28.186 A:middle
in the Metal pipeline?

00:21:28.906 --> 00:21:30.016 A:middle
Yeah, I think so.

00:21:30.016 --> 00:21:31.876 A:middle
Yeah, post-tessellation
vertex shader.

00:21:31.876 --> 00:21:32.686 A:middle
Because guess what?

00:21:33.006 --> 00:21:33.786 A:middle
The domain shader

00:21:34.126 --> 00:21:37.206 A:middle
with tessellation really
becomes the new vertex shader.

00:21:37.836 --> 00:21:41.236 A:middle
And just like you can
very easily move your HLSL

00:21:41.416 --> 00:21:44.096 A:middle
or GLSL vertex functions
to Metal,

00:21:44.566 --> 00:21:47.076 A:middle
you can move these domain
shaders pretty easily

00:21:47.346 --> 00:21:49.516 A:middle
to the post-tessellation
vertex shader.

00:21:49.936 --> 00:21:52.396 A:middle
The tessellator is exactly
the same, no changes.

00:21:52.966 --> 00:21:55.306 A:middle
So really, we have this
guy, these two shaders,

00:21:55.716 --> 00:21:56.816 A:middle
the vertex and hull shader.

00:21:57.026 --> 00:21:58.606 A:middle
And we got to make
them into a kernel.

00:21:58.746 --> 00:22:02.056 A:middle
Okay. Let's look at
how we can do that.

00:21:58.746 --> 00:22:02.056 A:middle
Okay. Let's look at
how we can do that.

00:22:02.206 --> 00:22:06.726 A:middle
So let's look at some --
since we have a vertex shader,

00:22:07.376 --> 00:22:10.566 A:middle
that means there's probably
a vertex descriptor described

00:22:10.946 --> 00:22:12.616 A:middle
at runtime by the application.

00:22:13.366 --> 00:22:16.426 A:middle
And that means -- because
the data's probably going

00:22:16.426 --> 00:22:17.046 A:middle
to be decoupled.

00:22:17.046 --> 00:22:19.416 A:middle
So that means I need
to declare stage in.

00:22:19.606 --> 00:22:22.186 A:middle
But I don't do stage
in in a kernel.

00:22:22.386 --> 00:22:24.146 A:middle
Right? Well, now you can.

00:22:24.426 --> 00:22:25.516 A:middle
We've added support for it.

00:22:25.926 --> 00:22:28.506 A:middle
So just like in a vertex
shader you use stage

00:22:28.506 --> 00:22:31.946 A:middle
in to say this is my vertex
input, you can use stage

00:22:31.946 --> 00:22:34.496 A:middle
in to say this my
per thread input.

00:22:34.896 --> 00:22:37.986 A:middle
And you can specify
the actual data layout

00:22:38.536 --> 00:22:40.926 A:middle
in a MTLStage
inputOutputDescriptor.

00:22:41.136 --> 00:22:42.416 A:middle
It behaves identically.

00:22:42.416 --> 00:22:44.956 A:middle
It's very similar to
a MTLVertexDescriptor.

00:22:45.166 --> 00:22:49.036 A:middle
Some of the things you
specify are a little different

00:22:49.036 --> 00:22:54.106 A:middle
because this is for
compute, not for vertex.

00:22:56.206 --> 00:23:00.106 A:middle
And then two things to observe.

00:22:56.206 --> 00:23:00.106 A:middle
And then two things to observe.

00:23:00.276 --> 00:23:02.546 A:middle
With tessellation
DirectX or OpenGL,

00:23:02.956 --> 00:23:06.296 A:middle
the vertex shader executes on
the control-point of a patch.

00:23:06.836 --> 00:23:09.996 A:middle
And the hull shader has
these two functions.

00:23:10.386 --> 00:23:13.056 A:middle
One that executes on a
control-point and one

00:23:13.056 --> 00:23:14.146 A:middle
that executes on a patch.

00:23:14.656 --> 00:23:17.226 A:middle
The per-patch hull function is
what actually generates your

00:23:17.226 --> 00:23:18.186 A:middle
tessellation factors.

00:23:18.696 --> 00:23:19.016 A:middle
All right.

00:23:19.436 --> 00:23:20.796 A:middle
So the best thing to do?

00:23:20.796 --> 00:23:23.186 A:middle
Translate all these three
functions to Metal functions.

00:23:23.606 --> 00:23:24.946 A:middle
And then we'll write
a Metal kernel

00:23:24.946 --> 00:23:26.476 A:middle
that will call these functions.

00:23:26.736 --> 00:23:28.366 A:middle
But don't worry, we're not
going to make function calls.

00:23:28.846 --> 00:23:30.376 A:middle
The Metal compiler
will in-line these.

00:23:30.576 --> 00:23:34.136 A:middle
Okay? So let's look
at how this works.

00:23:34.136 --> 00:23:36.106 A:middle
So each thread basically
is going

00:23:36.106 --> 00:23:39.166 A:middle
to call the control-point
function for the vertex

00:23:39.166 --> 00:23:40.466 A:middle
and for the hull, right?

00:23:40.466 --> 00:23:42.526 A:middle
So let's say there
were 16 control-points.

00:23:42.926 --> 00:23:44.896 A:middle
So the first thread
calls the vertex

00:23:45.066 --> 00:23:46.346 A:middle
and control-point hull function,

00:23:46.866 --> 00:23:49.736 A:middle
second thread does the
same thing, and so on.

00:23:49.736 --> 00:23:52.856 A:middle
Right? And any intermittent data
that they produce that they want

00:23:52.856 --> 00:23:55.206 A:middle
to share, they'll put that
in thread group memory,

00:23:55.206 --> 00:23:57.756 A:middle
which is this local memory

00:23:57.756 --> 00:24:00.376 A:middle
which is high-performance,
very low-latency.

00:23:57.756 --> 00:24:00.376 A:middle
which is high-performance,
very low-latency.

00:24:00.376 --> 00:24:01.856 A:middle
So we're not going
after graphics memory.

00:24:02.306 --> 00:24:04.946 A:middle
And then if there were
16 control-points,

00:24:04.946 --> 00:24:07.316 A:middle
there will be 16 threads
operating on these.

00:24:07.836 --> 00:24:11.126 A:middle
Only one of them need to execute
the per-patch hull function.

00:24:11.126 --> 00:24:13.046 A:middle
That means you typically
have a barrier,

00:24:13.416 --> 00:24:14.396 A:middle
and then you will execute --

00:24:14.396 --> 00:24:16.846 A:middle
only one of the thread will
execute the hull functions.

00:24:16.846 --> 00:24:18.466 A:middle
You have a conditional
check saying, "Hey,

00:24:18.466 --> 00:24:21.776 A:middle
is my thread in thread
group ID0?

00:24:21.776 --> 00:24:22.706 A:middle
Then call this thing."

00:24:22.916 --> 00:24:24.116 A:middle
And this is the function

00:24:24.116 --> 00:24:27.656 A:middle
that will output the
tessellation factors

00:24:27.856 --> 00:24:28.636 A:middle
to graphics memory.

00:24:29.156 --> 00:24:31.266 A:middle
If you had any additional
patch data you wanted

00:24:31.266 --> 00:24:32.716 A:middle
to output, you could do so.

00:24:32.716 --> 00:24:35.196 A:middle
And if you really, really,
really, really wanted

00:24:35.196 --> 00:24:38.376 A:middle
to output the control-point
data, you can do so.

00:24:38.376 --> 00:24:41.626 A:middle
But we find in most case the
control-point data is just

00:24:41.676 --> 00:24:42.306 A:middle
passed through.

00:24:42.306 --> 00:24:45.036 A:middle
It's the nature of
the graphics pipeline,

00:24:45.036 --> 00:24:47.006 A:middle
and these are the existing API's

00:24:47.346 --> 00:24:48.966 A:middle
which requires you
to pass them through.

00:24:49.116 --> 00:24:51.366 A:middle
But you're just passing them
through; don't write it out.

00:24:51.476 --> 00:24:53.516 A:middle
You already have them
in your buffer, okay?

00:24:54.486 --> 00:24:55.346 A:middle
All right.

00:24:55.346 --> 00:24:56.096 A:middle
Let me close.

00:24:56.386 --> 00:24:58.576 A:middle
So I hope I have shown you

00:24:58.916 --> 00:25:03.616 A:middle
that Metal Tessellation
is simple and easy to use.

00:24:58.916 --> 00:25:03.616 A:middle
that Metal Tessellation
is simple and easy to use.

00:25:03.796 --> 00:25:06.696 A:middle
We designed it from the
ground up for performance.

00:25:07.646 --> 00:25:09.046 A:middle
I've shown you how easy it is

00:25:09.156 --> 00:25:12.356 A:middle
to adapt your existing
tessellation code to Metal.

00:25:13.356 --> 00:25:15.056 A:middle
It's available on iOS and macOS.

00:25:15.276 --> 00:25:17.986 A:middle
So now it's your turn.

00:25:18.446 --> 00:25:20.316 A:middle
Show us, you know,
use tessellation

00:25:20.316 --> 00:25:22.716 A:middle
and create some amazing visuals

00:25:22.716 --> 00:25:24.716 A:middle
that you can render
in the application.

00:25:25.956 --> 00:25:27.456 A:middle
So I want to thank
you for your time.

00:25:27.456 --> 00:25:29.946 A:middle
I'm going to call my colleague,
James, and he's going to talk

00:25:29.946 --> 00:25:32.606 A:middle
to you about resource heaps
and memoryless render targets.

00:25:32.606 --> 00:25:32.996 A:middle
Thank you.

00:25:34.516 --> 00:25:40.596 A:middle
[ Applause ]

00:25:41.096 --> 00:25:41.386 A:middle
&gt;&gt; All right.

00:25:41.386 --> 00:25:41.996 A:middle
Thank you, Aaftab.

00:25:42.826 --> 00:25:45.866 A:middle
For the next part of
this session I'm excited

00:25:45.866 --> 00:25:49.926 A:middle
to introduce two new Metal
features available in iOS

00:25:49.926 --> 00:25:53.016 A:middle
and tvOS - resource heaps and
memoryless render targets.

00:25:54.196 --> 00:25:56.196 A:middle
These features enable
you to take control

00:25:56.196 --> 00:25:58.926 A:middle
of your resource
management for greater CPU

00:25:58.926 --> 00:25:59.946 A:middle
and memory efficiency.

00:26:00.876 --> 00:26:02.496 A:middle
I'll introduce resource
heaps first,

00:26:02.716 --> 00:26:04.336 A:middle
followed by memoryless
render targets.

00:26:06.246 --> 00:26:09.146 A:middle
So resource heaps are a
new lower overhead resource

00:26:09.146 --> 00:26:10.436 A:middle
management option in Metal.

00:26:10.436 --> 00:26:13.406 A:middle
Now, you can already create
buffers and textures in Metal,

00:26:13.856 --> 00:26:15.216 A:middle
so why do we need another way?

00:26:16.076 --> 00:26:18.516 A:middle
Well, creating resources
through the existing Metal API

00:26:18.626 --> 00:26:21.126 A:middle
with a device is
easy and convenient

00:26:21.516 --> 00:26:23.586 A:middle
and many developers
appreciate the simplicity.

00:26:24.346 --> 00:26:25.966 A:middle
On the other hand, as many

00:26:25.966 --> 00:26:28.336 A:middle
of your Metal apps
render increasingly rich

00:26:28.366 --> 00:26:31.646 A:middle
and complex scenes, you
asked for finer control

00:26:31.646 --> 00:26:34.726 A:middle
over your Metal resources
to unlock greater CPU

00:26:34.726 --> 00:26:35.646 A:middle
and memory efficiency.

00:26:36.426 --> 00:26:39.396 A:middle
That's why we are
introducing resource heaps.

00:26:39.576 --> 00:26:43.246 A:middle
Resource heaps enable fast
resource creation and binding

00:26:43.556 --> 00:26:45.036 A:middle
through resource sub-allocation.

00:26:45.866 --> 00:26:49.236 A:middle
The flexibility of resource
heaps saves you memory

00:26:49.286 --> 00:26:52.116 A:middle
by allowing multiple
resources to alias in memory.

00:26:52.986 --> 00:26:55.656 A:middle
And finally, the
efficiency and flexibility

00:26:55.656 --> 00:26:59.026 A:middle
of resource heaps is made
possible by you taking control

00:26:59.026 --> 00:27:00.926 A:middle
over tracking resource
dependencies

00:26:59.026 --> 00:27:00.926 A:middle
over tracking resource
dependencies

00:27:01.266 --> 00:27:02.966 A:middle
with explicit command
synchronization.

00:27:03.946 --> 00:27:06.386 A:middle
Now, let's dive into each one
of these features starting

00:27:06.386 --> 00:27:07.906 A:middle
with resource sub-allocation.

00:27:09.276 --> 00:27:11.506 A:middle
Before talking about the
details of sub-allocation,

00:27:11.816 --> 00:27:15.556 A:middle
let's first discuss why
device-based resource creation

00:27:15.556 --> 00:27:16.226 A:middle
is expensive.

00:27:17.416 --> 00:27:18.876 A:middle
Creating an individual resource

00:27:19.076 --> 00:27:21.186 A:middle
with a Metal device
involves multiple steps:

00:27:21.856 --> 00:27:24.776 A:middle
Allocating the memory; preparing
the memory for the GPU;

00:27:25.476 --> 00:27:28.136 A:middle
clearing the memory for
security; and then, finally,

00:27:28.196 --> 00:27:29.886 A:middle
creating the Metal object.

00:27:30.616 --> 00:27:33.036 A:middle
Each one of these steps
takes time and a majority

00:27:33.036 --> 00:27:34.886 A:middle
of the time is spent
in memory operations.

00:27:35.696 --> 00:27:38.686 A:middle
But there are situations when
you need to create resources

00:27:38.916 --> 00:27:40.376 A:middle
on your performance-critical
path

00:27:40.686 --> 00:27:42.266 A:middle
without introducing
performance hitches.

00:27:43.366 --> 00:27:44.736 A:middle
Texture streaming is one example

00:27:45.396 --> 00:27:48.316 A:middle
or perhaps you have an image
processing app that needs

00:27:48.316 --> 00:27:49.116 A:middle
to generate a number

00:27:49.116 --> 00:27:50.956 A:middle
of temporary textures
to execute a filter.

00:27:51.536 --> 00:27:55.086 A:middle
The cost of binding resources

00:27:55.276 --> 00:27:57.946 A:middle
to command encoders can also
become a performance issue.

00:27:58.836 --> 00:28:01.616 A:middle
Metal must track each
unique resource bound

00:27:58.836 --> 00:28:01.616 A:middle
Metal must track each
unique resource bound

00:28:01.616 --> 00:28:03.416 A:middle
to a command encoder
to make sure

00:28:03.416 --> 00:28:05.066 A:middle
that the GPU can
access the memory.

00:28:05.736 --> 00:28:08.316 A:middle
And for complex scenes, this
cost can add up as well.

00:28:10.066 --> 00:28:12.226 A:middle
Resource sub-allocation
addresses both

00:28:12.226 --> 00:28:13.396 A:middle
of these performance issues.

00:28:14.236 --> 00:28:17.146 A:middle
Remember that the expensive
part of resource creation is

00:28:17.146 --> 00:28:18.246 A:middle
in the memory operations.

00:28:19.046 --> 00:28:21.626 A:middle
With resource heaps you can
perform the memory operations

00:28:21.626 --> 00:28:23.736 A:middle
ahead of time outside
of your game loop.

00:28:24.976 --> 00:28:27.656 A:middle
Resource heaps address the
binding cost by allowing you

00:28:27.656 --> 00:28:31.096 A:middle
to sub-allocate many logical
resources from a single heap.

00:28:32.056 --> 00:28:34.436 A:middle
By sub-allocating multiple
resources from one heap,

00:28:34.756 --> 00:28:37.256 A:middle
Metal tracks one memory
allocation instead

00:28:37.256 --> 00:28:38.816 A:middle
of one per individual resource.

00:28:39.566 --> 00:28:41.696 A:middle
This significantly reduces
your driver overhead.

00:28:43.486 --> 00:28:44.946 A:middle
Now, let's compare
resource creation

00:28:44.946 --> 00:28:47.426 A:middle
between the Metal device and
the new Metal resource heap.

00:28:48.146 --> 00:28:51.786 A:middle
When you create a resource with
a device, Metal will allocate

00:28:51.786 --> 00:28:52.986 A:middle
and prepare a block of memory

00:28:53.466 --> 00:28:54.716 A:middle
and then create the
Metal object.

00:28:55.406 --> 00:28:57.506 A:middle
So for four resources,
Metal will allocate

00:28:57.506 --> 00:28:59.016 A:middle
or prepare four blocks
of memory.

00:28:59.826 --> 00:29:01.996 A:middle
Now, compare that
to the MTLHeap.

00:28:59.826 --> 00:29:01.996 A:middle
Now, compare that
to the MTLHeap.

00:29:02.456 --> 00:29:04.206 A:middle
When you use a MTLHeap
for resource creation,

00:29:04.206 --> 00:29:06.486 A:middle
you first create the heap
object ahead of time.

00:29:07.276 --> 00:29:09.726 A:middle
Memory will allocate and
prepare a block of memory

00:29:09.796 --> 00:29:10.836 A:middle
of the requested size.

00:29:11.466 --> 00:29:13.816 A:middle
And if you do this ahead of time
outside of your render loop,

00:29:14.376 --> 00:29:16.666 A:middle
the expensive part of
resource creation is complete.

00:29:18.166 --> 00:29:20.356 A:middle
Now, to create four
resources out of the MTLHeap,

00:29:20.986 --> 00:29:23.706 A:middle
Metal only needs to reserve
a piece of the heap's memory

00:29:23.926 --> 00:29:25.186 A:middle
and create the resource
metadata.

00:29:25.586 --> 00:29:26.606 A:middle
This is much faster.

00:29:27.496 --> 00:29:28.626 A:middle
Now let's see what
happens when we want

00:29:28.626 --> 00:29:29.906 A:middle
to release some resources.

00:29:30.956 --> 00:29:33.136 A:middle
When a device-based
resource is released,

00:29:33.456 --> 00:29:34.796 A:middle
the Metal object is destroyed,

00:29:35.306 --> 00:29:38.466 A:middle
but the device will also free
the memory resource allocation.

00:29:39.236 --> 00:29:41.186 A:middle
On the other hand, when
releasing a heap resource,

00:29:41.416 --> 00:29:43.006 A:middle
only the object is destroyed.

00:29:43.586 --> 00:29:45.156 A:middle
The memory is still
owned by the heap.

00:29:45.856 --> 00:29:47.066 A:middle
So creating a new resource

00:29:47.066 --> 00:29:50.136 A:middle
on the device will incur another
expensive memory allocation,

00:29:50.596 --> 00:29:54.006 A:middle
whereas the heap can quickly
reassign the free memory

00:29:54.216 --> 00:29:55.166 A:middle
to another resource.

00:29:56.766 --> 00:29:58.066 A:middle
Let me show you how easy it is

00:29:58.096 --> 00:30:00.726 A:middle
to sub-allocate Metal
resources with Swift.

00:29:58.096 --> 00:30:00.726 A:middle
to sub-allocate Metal
resources with Swift.

00:30:01.256 --> 00:30:04.096 A:middle
So like many Metal objects,

00:30:04.256 --> 00:30:07.866 A:middle
the Metal resource heap has a
corresponding descriptor object.

00:30:08.406 --> 00:30:11.176 A:middle
So let's create a heap
descriptor and set the size

00:30:11.406 --> 00:30:14.376 A:middle
to the amount of
memory to back the heap.

00:30:14.896 --> 00:30:16.756 A:middle
With the heap descriptor
we can ask the device

00:30:16.916 --> 00:30:18.256 A:middle
to create us a heap object.

00:30:18.726 --> 00:30:20.906 A:middle
Remember, this is the slower
operation, so do this ahead

00:30:20.906 --> 00:30:22.996 A:middle
of time, like when
your app starts

00:30:23.056 --> 00:30:24.576 A:middle
or at content loading time.

00:30:26.136 --> 00:30:27.386 A:middle
With the constructed heap,

00:30:27.736 --> 00:30:29.426 A:middle
we can call its resource
creation methods,

00:30:29.586 --> 00:30:32.076 A:middle
which should look very
familiar since the name

00:30:32.076 --> 00:30:38.006 A:middle
and arguments are the same
as the device equivalents.

00:30:39.496 --> 00:30:41.526 A:middle
So before moving on
to the next topic I'd

00:30:41.526 --> 00:30:42.876 A:middle
like to share some
best practices

00:30:42.876 --> 00:30:44.776 A:middle
for using resource heaps
for sub-allocation.

00:30:45.466 --> 00:30:48.276 A:middle
Now, the most important tip
is to use resource heaps

00:30:48.516 --> 00:30:51.176 A:middle
to create resources on your
performance-critical path.

00:30:51.696 --> 00:30:54.496 A:middle
Creating resources using
the device is not designed

00:30:54.496 --> 00:30:58.426 A:middle
for your game loop;
resource heaps are.

00:30:59.076 --> 00:31:03.146 A:middle
Allocating resources of varying
sizes can lead to fragmentation

00:30:59.076 --> 00:31:03.146 A:middle
Allocating resources of varying
sizes can lead to fragmentation

00:31:03.146 --> 00:31:03.966 A:middle
of a heap's memory

00:31:04.256 --> 00:31:06.346 A:middle
if the resources have
varying lifetimes.

00:31:07.226 --> 00:31:10.326 A:middle
So use multiple heaps and
bucket resources by size

00:31:10.526 --> 00:31:12.026 A:middle
to limit the effects
of fragmentation.

00:31:12.516 --> 00:31:15.306 A:middle
Now, you may also
be wondering how

00:31:15.306 --> 00:31:17.006 A:middle
to choose an appropriate
heap size.

00:31:17.716 --> 00:31:20.456 A:middle
Well, Metal provides two new
methods on the Metal device

00:31:20.816 --> 00:31:24.066 A:middle
to query the size and alignment
of a texture and buffer.

00:31:25.076 --> 00:31:27.256 A:middle
Use these queries to help
you calculate the heap size

00:31:27.256 --> 00:31:27.726 A:middle
that you need.

00:31:29.406 --> 00:31:30.816 A:middle
Okay. Let's move on
to the next feature

00:31:30.816 --> 00:31:32.866 A:middle
of resource heaps --
Resource aliasing.

00:31:34.256 --> 00:31:36.956 A:middle
Resource aliasing allows
multiple dynamic resources

00:31:37.226 --> 00:31:38.616 A:middle
to occupy the same memory,

00:31:38.906 --> 00:31:41.246 A:middle
therefore reducing the
total memory footprint

00:31:41.426 --> 00:31:42.296 A:middle
of the resources.

00:31:42.956 --> 00:31:46.666 A:middle
Dynamic resources have contents
that are regenerated each frame

00:31:46.666 --> 00:31:51.116 A:middle
and include things like your
shadow maps, your G buffer data,

00:31:51.116 --> 00:31:53.586 A:middle
or temporary textures
used in post-processing.

00:31:55.246 --> 00:31:58.096 A:middle
Here we have a heap containing
two nonaliasing resources.

00:31:58.656 --> 00:32:00.656 A:middle
Compare that to this heap
containing the same two

00:31:58.656 --> 00:32:00.656 A:middle
Compare that to this heap
containing the same two

00:32:00.656 --> 00:32:02.526 A:middle
resources but now
they are aliasing.

00:32:02.796 --> 00:32:04.026 A:middle
Now, you can obviously see

00:32:04.026 --> 00:32:07.206 A:middle
that the aliasing resources can
fit inside a much smaller heap.

00:32:10.066 --> 00:32:13.566 A:middle
Let's apply resource
aliasing to this game frame.

00:32:14.376 --> 00:32:16.626 A:middle
The shadow map passes render
a set of shadow maps --

00:32:17.036 --> 00:32:18.436 A:middle
one for each light in the scene.

00:32:19.426 --> 00:32:21.316 A:middle
So here in our heap we have
a number of shadow maps.

00:32:21.976 --> 00:32:26.556 A:middle
And in the main pass during
fragment processing the shaders

00:32:26.556 --> 00:32:28.416 A:middle
will sample the shadow
maps to determine

00:32:28.416 --> 00:32:29.946 A:middle
if each object is in shadow.

00:32:29.946 --> 00:32:34.016 A:middle
Now, after the main
pass ends, the contents

00:32:34.016 --> 00:32:35.856 A:middle
for the shadow maps are
completely consumed.

00:32:35.896 --> 00:32:38.306 A:middle
They will be regenerated
in the next frame.

00:32:38.966 --> 00:32:42.736 A:middle
So after the main pass ends, we
execute a post-processing chain

00:32:42.796 --> 00:32:45.476 A:middle
that can consist of a number
of off-screen render passes,

00:32:45.866 --> 00:32:48.486 A:middle
each executing a specific
filter like a blur or bloom.

00:32:49.556 --> 00:32:52.286 A:middle
These filters will store
their contents into textures

00:32:52.286 --> 00:32:54.966 A:middle
to pass filter results to
the next stages the chain.

00:32:55.686 --> 00:32:58.766 A:middle
Now, the key takeaway
here is that the contents

00:32:58.766 --> 00:33:00.936 A:middle
for the shadow maps and the
post-processing textures are

00:32:58.766 --> 00:33:00.936 A:middle
for the shadow maps and the
post-processing textures are

00:33:00.936 --> 00:33:02.326 A:middle
never used at the same time.

00:33:03.146 --> 00:33:06.846 A:middle
So why not share the memory?

00:33:07.176 --> 00:33:10.136 A:middle
So let me show you how to create
these aliasing resource sets

00:33:10.136 --> 00:33:10.586 A:middle
with Swift.

00:33:11.296 --> 00:33:12.906 A:middle
Now, the first section
should look familiar.

00:33:13.366 --> 00:33:15.026 A:middle
First we ask the device
to create us a heap

00:33:15.916 --> 00:33:18.126 A:middle
and we create our
three shadow maps.

00:33:18.786 --> 00:33:21.586 A:middle
Okay. Now we see a new
method, makeAliasable.

00:33:22.546 --> 00:33:23.876 A:middle
By calling makeAliasable

00:33:23.876 --> 00:33:26.476 A:middle
on a heap resource you are
telling the heap to consider

00:33:26.476 --> 00:33:28.056 A:middle
that resource's memory
to be free.

00:33:29.366 --> 00:33:33.126 A:middle
The shadow maps are still
active, but their memory is free

00:33:33.126 --> 00:33:35.546 A:middle
to be reassigned by the
heap to new resources.

00:33:35.806 --> 00:33:38.796 A:middle
So now when we create the
post-processing textures

00:33:38.796 --> 00:33:41.916 A:middle
on the same heap, they
can occupy the same memory

00:33:41.916 --> 00:33:43.426 A:middle
as the shadow maps.

00:33:44.616 --> 00:33:47.856 A:middle
So now let's talk about
some best practices

00:33:47.926 --> 00:33:48.896 A:middle
for resource aliasing.

00:33:49.526 --> 00:33:52.226 A:middle
To maximize memory reuse

00:33:52.226 --> 00:33:56.756 A:middle
for dynamic resources call
resource creation methods

00:33:56.826 --> 00:33:59.796 A:middle
in the same sequence that their
resources are used in a frame.

00:34:00.646 --> 00:34:02.956 A:middle
That will allow you to
call makeAliasable --

00:34:03.616 --> 00:34:06.606 A:middle
that will allow you to
interleave makeAliasable calls

00:34:07.026 --> 00:34:11.976 A:middle
when the resource contents
have been consumed.

00:34:12.045 --> 00:34:13.096 A:middle
And you want to keep dynamic

00:34:13.226 --> 00:34:15.005 A:middle
and static resources
in separate heaps.

00:34:15.886 --> 00:34:18.966 A:middle
Static resources are generally
not aliasable and can end

00:34:18.966 --> 00:34:21.766 A:middle
up preventing dynamic
resources from aliasing

00:34:21.766 --> 00:34:22.716 A:middle
with each other due

00:34:22.716 --> 00:34:24.156 A:middle
to fragmentation of
the heap's memory.

00:34:25.926 --> 00:34:28.815 A:middle
Next I'm going to talk about how
to synchronize command access

00:34:28.876 --> 00:34:32.496 A:middle
to your heap resources.

00:34:33.045 --> 00:34:35.746 A:middle
So, so far we have discussed
fast resource creation

00:34:35.815 --> 00:34:38.346 A:middle
with sub-allocation and
efficient memory usage

00:34:38.346 --> 00:34:39.446 A:middle
with resource aliasing.

00:34:40.025 --> 00:34:42.426 A:middle
But remember that resource
heaps are fast and flexible

00:34:42.616 --> 00:34:44.406 A:middle
because you control
the synchronization

00:34:44.406 --> 00:34:45.326 A:middle
of heap resources.

00:34:45.916 --> 00:34:47.396 A:middle
This is something
you do not have to do

00:34:47.396 --> 00:34:48.525 A:middle
with device resources.

00:34:49.716 --> 00:34:52.356 A:middle
But unlike device
resources, Metal won't know

00:34:52.356 --> 00:34:54.946 A:middle
when a command modifies the
contents of a heap resource

00:34:55.456 --> 00:34:59.096 A:middle
like when a render pass stores
new contents to a texture.

00:35:00.346 --> 00:35:02.646 A:middle
Metal also doesn't know when
you're changing interpretation

00:35:02.646 --> 00:35:05.576 A:middle
of the heap's memory from
one aliasing set to another.

00:35:06.116 --> 00:35:08.866 A:middle
But for correctness,
Metal needs know

00:35:08.866 --> 00:35:10.776 A:middle
when a command is
updating a heap resource

00:35:11.076 --> 00:35:14.016 A:middle
so that other commands can
safely read the results.

00:35:15.076 --> 00:35:16.296 A:middle
This is especially important

00:35:16.296 --> 00:35:19.066 A:middle
because the GPU can execute
multiple commands in parallel.

00:35:19.736 --> 00:35:22.656 A:middle
So to synchronize
access to heap resources,

00:35:22.886 --> 00:35:25.786 A:middle
your application will
create and manage GPU fences

00:35:26.466 --> 00:35:29.256 A:middle
to communicate resource
dependencies across commands.

00:35:30.276 --> 00:35:32.086 A:middle
Let's take a closer look
at how GPU fences work.

00:35:33.416 --> 00:35:35.516 A:middle
So a GPU fence is the timestamp.

00:35:35.976 --> 00:35:39.496 A:middle
It is a reference point in
the GPUs execution timeline.

00:35:40.026 --> 00:35:42.316 A:middle
Now, you can encode
two actions with fences

00:35:42.366 --> 00:35:43.386 A:middle
to synchronize commands.

00:35:43.876 --> 00:35:47.406 A:middle
A command can update a fence
to move the timestamp forward

00:35:47.466 --> 00:35:48.466 A:middle
when the command is finished.

00:35:49.156 --> 00:35:51.916 A:middle
And a command can wait
on a fence to wait

00:35:51.916 --> 00:35:54.476 A:middle
until the GPU has reached
the most recent fence update

00:35:54.476 --> 00:35:55.316 A:middle
before executing.

00:35:56.676 --> 00:35:58.836 A:middle
Okay. Let's bring back
the previous game frame

00:35:58.996 --> 00:36:00.616 A:middle
and I will show you
how to use fences

00:35:58.996 --> 00:36:00.616 A:middle
and I will show you
how to use fences

00:36:00.726 --> 00:36:03.596 A:middle
to synchronize command access
to the aliasing heap resources.

00:36:05.206 --> 00:36:08.776 A:middle
So here again is the example
frame, a three-part frame,

00:36:08.866 --> 00:36:10.676 A:middle
but now we have five
boxes because two

00:36:10.676 --> 00:36:13.556 A:middle
of the render stages, render
passes are split in the vertex

00:36:13.636 --> 00:36:15.476 A:middle
and fragment processing steps.

00:36:16.096 --> 00:36:18.296 A:middle
So we have a shadow
pass, a main pass,

00:36:18.296 --> 00:36:20.106 A:middle
and finally a post-processing
pass

00:36:20.536 --> 00:36:21.866 A:middle
that we will execute
with compute.

00:36:23.656 --> 00:36:25.806 A:middle
So Metal commands are submitted

00:36:25.806 --> 00:36:27.916 A:middle
in serial order to
the command queue.

00:36:28.556 --> 00:36:29.586 A:middle
So maybe it's not quite clear

00:36:29.586 --> 00:36:32.116 A:middle
yet why we need any
synchronization across commands.

00:36:33.046 --> 00:36:35.546 A:middle
But GPUs are very parallel
machines and can operate

00:36:35.546 --> 00:36:37.006 A:middle
on multiple commands
in parallel.

00:36:38.296 --> 00:36:41.956 A:middle
GPUs in our iOS and tvOS
products can execute vertex,

00:36:42.266 --> 00:36:45.436 A:middle
fragment, and compute
commands all in parallel

00:36:45.496 --> 00:36:47.846 A:middle
to maximize GPU utilization.

00:36:48.456 --> 00:36:49.936 A:middle
The GPU can even be working

00:36:49.936 --> 00:36:52.486 A:middle
on multiple frames
at the same time.

00:36:53.316 --> 00:36:53.696 A:middle
All right.

00:36:53.696 --> 00:36:55.136 A:middle
So maybe now you spot a problem.

00:36:55.136 --> 00:36:57.936 A:middle
Look at these two commands
that are highlighted.

00:36:58.586 --> 00:37:00.246 A:middle
They are both updating
the aliasing

00:36:58.586 --> 00:37:00.246 A:middle
They are both updating
the aliasing

00:37:00.286 --> 00:37:01.986 A:middle
and heap resources
at the same time.

00:37:02.766 --> 00:37:04.896 A:middle
We have to use a
fence to fix this.

00:37:05.866 --> 00:37:07.466 A:middle
So first let's bring in a fence.

00:37:08.876 --> 00:37:11.686 A:middle
The post-process command
will update the fence

00:37:13.006 --> 00:37:16.336 A:middle
so that the shadow commands
fragment processing stage can

00:37:16.336 --> 00:37:17.246 A:middle
wait on the fence.

00:37:18.616 --> 00:37:21.456 A:middle
Right? So now the two
commands don't execute

00:37:21.456 --> 00:37:22.426 A:middle
at the same time anymore.

00:37:22.426 --> 00:37:25.886 A:middle
So I'm going to show you how
to encode this fence update

00:37:25.886 --> 00:37:28.696 A:middle
and fence wait with Swift.

00:37:29.456 --> 00:37:31.666 A:middle
First, we create a
fence with a device.

00:37:32.416 --> 00:37:34.226 A:middle
This is a new method
-- no arguments.

00:37:35.036 --> 00:37:37.776 A:middle
Next, let's encode the
post-processing compute encoder

00:37:37.906 --> 00:37:39.066 A:middle
at the end of the first frame.

00:37:39.776 --> 00:37:43.416 A:middle
We first create a
computeCommandEncoder

00:37:43.656 --> 00:37:44.726 A:middle
and encode the dispatches.

00:37:45.216 --> 00:37:51.156 A:middle
But before we end the encoder,
we first update the fence

00:37:51.286 --> 00:37:53.146 A:middle
so that subsequent
commands can wait

00:37:53.146 --> 00:37:55.896 A:middle
until this command has
finished executing.

00:37:56.186 --> 00:38:01.326 A:middle
So in the next frame we would
encode the shadow rendering.

00:37:56.186 --> 00:38:01.326 A:middle
So in the next frame we would
encode the shadow rendering.

00:38:01.706 --> 00:38:03.336 A:middle
So we create a
renderCommandEncoder

00:38:03.966 --> 00:38:06.476 A:middle
in commandBufB, which
represents the command buffer

00:38:06.476 --> 00:38:07.576 A:middle
for the next frame.

00:38:08.146 --> 00:38:12.156 A:middle
But before drawing the scene,
we first encode a fence wait

00:38:13.226 --> 00:38:15.136 A:middle
to wait until the
post-processing is completed

00:38:15.336 --> 00:38:15.996 A:middle
on the GPU.

00:38:16.286 --> 00:38:18.266 A:middle
Now, notice this time
there are two arguments.

00:38:18.706 --> 00:38:21.046 A:middle
There's a second argument
called beforeStages.

00:38:22.496 --> 00:38:25.236 A:middle
Render commands execute in two
stages -- vertex and fragment.

00:38:25.606 --> 00:38:29.346 A:middle
So Metal allows you to specify
the particular stage that needs

00:38:29.346 --> 00:38:30.306 A:middle
to wait for the fence.

00:38:31.056 --> 00:38:33.056 A:middle
In our example only the
fragment stage needs

00:38:33.106 --> 00:38:37.936 A:middle
to access the heap resources, so
we specify the fragment stage.

00:38:38.416 --> 00:38:40.736 A:middle
Finally, we can render
our shadow maps safely

00:38:41.086 --> 00:38:43.536 A:middle
because we know that this
command will only execute

00:38:43.536 --> 00:38:46.146 A:middle
after the previous frame's
post-processing is complete.

00:38:46.756 --> 00:38:50.056 A:middle
Okay. Let me talk about
some best practices

00:38:50.056 --> 00:38:51.156 A:middle
for command synchronization.

00:38:51.966 --> 00:38:55.336 A:middle
So you know that if you use
heaps, you have to use fences

00:38:55.336 --> 00:38:56.696 A:middle
to synchronize command access.

00:38:57.196 --> 00:38:58.526 A:middle
But you are given this control

00:38:58.526 --> 00:39:00.356 A:middle
because you know you
have more knowledge

00:38:58.526 --> 00:39:00.356 A:middle
because you know you
have more knowledge

00:39:00.356 --> 00:39:02.366 A:middle
about how your resources
are used

00:39:02.846 --> 00:39:05.936 A:middle
and your application will
be more CPU-efficient

00:39:06.246 --> 00:39:08.196 A:middle
than if Metal were to
track all of this for you.

00:39:09.106 --> 00:39:11.926 A:middle
For example, textures
that are initialized once

00:39:11.926 --> 00:39:14.566 A:middle
and never modified don't
even need to be tracked.

00:39:15.916 --> 00:39:17.136 A:middle
And as another example,

00:39:17.376 --> 00:39:19.896 A:middle
resources that are used
together can be tracked together

00:39:19.896 --> 00:39:21.606 A:middle
with a single fence.

00:39:23.476 --> 00:39:26.976 A:middle
So let me summarize the main
ideas of resource heaps.

00:39:28.326 --> 00:39:31.126 A:middle
Create resources faster
with suballocation.

00:39:32.296 --> 00:39:34.226 A:middle
Use your memory budget
more efficiently

00:39:34.666 --> 00:39:35.716 A:middle
with resource aliasing.

00:39:36.866 --> 00:39:40.156 A:middle
And synchronize your
heap updates

00:39:40.256 --> 00:39:43.066 A:middle
across GPU commands
with GPU fences.

00:39:45.956 --> 00:39:49.786 A:middle
Okay. Now I'd like to introduce
another new feature available

00:39:49.986 --> 00:39:52.766 A:middle
in iOS and tvOS:
Memoryless render targets.

00:39:53.626 --> 00:39:54.956 A:middle
Now, this sounds
a little magical,

00:39:55.366 --> 00:39:58.146 A:middle
but I will show you how almost
every Metal app can use this

00:39:58.146 --> 00:40:00.536 A:middle
feature to save a
significant amount of memory

00:39:58.146 --> 00:40:00.536 A:middle
feature to save a
significant amount of memory

00:40:00.976 --> 00:40:03.266 A:middle
with a single line of code.

00:40:03.976 --> 00:40:07.106 A:middle
So memoryless render
targets are simply textures

00:40:07.106 --> 00:40:10.136 A:middle
that do not allocate any system
memory for the texture contents.

00:40:11.016 --> 00:40:14.676 A:middle
Without any memory backing
the texture contents,

00:40:14.956 --> 00:40:16.776 A:middle
what remains is the
texture's metadata,

00:40:17.086 --> 00:40:19.796 A:middle
such as the texture's dimensions
and internal texture format.

00:40:20.506 --> 00:40:22.746 A:middle
Now obviously this is
a huge memory savings,

00:40:23.356 --> 00:40:25.356 A:middle
but when can you use a
memoryless render target?

00:40:26.506 --> 00:40:29.566 A:middle
You can use them for render pass
attachments that are not stored.

00:40:30.566 --> 00:40:34.596 A:middle
Most Metal apps will have
some attachments associated

00:40:34.596 --> 00:40:38.606 A:middle
with a store action of don't
care or multisample resolve.

00:40:38.746 --> 00:40:41.296 A:middle
And the textures used for those
render pass attachments can

00:40:41.296 --> 00:40:42.026 A:middle
be memoryless.

00:40:42.726 --> 00:40:46.236 A:middle
To make a memoryless
render target,

00:40:46.556 --> 00:40:48.976 A:middle
you can simply create the
texture as you normally would

00:40:49.306 --> 00:40:50.836 A:middle
with an additional
storage mode flag --

00:40:51.486 --> 00:40:53.226 A:middle
MTLStorageModeMemoryless.

00:40:53.646 --> 00:40:54.756 A:middle
That's it.

00:40:55.286 --> 00:40:57.776 A:middle
This feature is supported
only on iOS and tvOS

00:40:57.776 --> 00:40:59.326 A:middle
because it relies

00:40:59.326 --> 00:41:01.366 A:middle
on the tile-based
rendering architecture

00:40:59.326 --> 00:41:01.366 A:middle
on the tile-based
rendering architecture

00:41:01.646 --> 00:41:03.616 A:middle
of A7 and later GPUs.

00:41:04.596 --> 00:41:05.886 A:middle
Let me show you how
this feature works.

00:41:06.846 --> 00:41:09.786 A:middle
Here on your right we have
two render pass attachment --

00:41:10.136 --> 00:41:11.876 A:middle
a color attachment and
a depth attachment.

00:41:12.326 --> 00:41:15.886 A:middle
Now, A7 and later GPUs
execute render passes one tile

00:41:15.886 --> 00:41:20.436 A:middle
at a time, taking advantage
of a fast GPU tile storage

00:41:20.696 --> 00:41:22.076 A:middle
at the heart of the GPU.

00:41:22.806 --> 00:41:25.836 A:middle
The GPU tile storage contains
tile-sized representations

00:41:25.836 --> 00:41:28.206 A:middle
of your depth, stencil,
and color attachments.

00:41:28.946 --> 00:41:31.246 A:middle
And this tile storage
is completely separate

00:41:31.566 --> 00:41:33.246 A:middle
from the texture backing
and system memory.

00:41:33.906 --> 00:41:37.466 A:middle
Now, in Metal your load and
store actions control how

00:41:37.466 --> 00:41:40.136 A:middle
to initialize the GPU
tile storage and whether

00:41:40.136 --> 00:41:43.326 A:middle
to copy the results from
the GPU tile storage back

00:41:43.326 --> 00:41:44.076 A:middle
to system memory.

00:41:44.906 --> 00:41:48.376 A:middle
If an attachment is not loaded
from memory and it is not stored

00:41:48.376 --> 00:41:50.496 A:middle
to memory, you can
make the texture

00:41:50.496 --> 00:41:51.836 A:middle
for that attachment memoryless

00:41:52.186 --> 00:41:54.516 A:middle
to eliminate the
memory allocation.

00:41:55.866 --> 00:41:57.966 A:middle
Next, I'll describe some
very common scenarios

00:41:57.996 --> 00:42:00.446 A:middle
where you can apply this
feature to your app.

00:41:57.996 --> 00:42:00.446 A:middle
where you can apply this
feature to your app.

00:42:01.996 --> 00:42:04.526 A:middle
Depth attachments
are frequently used

00:42:04.646 --> 00:42:06.956 A:middle
to enable depth testing
in 3-D scenes.

00:42:07.966 --> 00:42:11.016 A:middle
But the A7 and later GPUs
perform depth testing completely

00:42:11.016 --> 00:42:13.286 A:middle
in GPU tile storage
one tile at a time.

00:42:13.906 --> 00:42:16.356 A:middle
Depth testing does not
need to use system memory.

00:42:17.246 --> 00:42:19.826 A:middle
So if you don't store the depth
texture for use in later passes,

00:42:20.586 --> 00:42:22.586 A:middle
make the texture memoryless
and save the memory.

00:42:23.106 --> 00:42:25.686 A:middle
Let me show you another
opportunity.

00:42:27.226 --> 00:42:29.546 A:middle
When executing multisample
rendering, again,

00:42:29.546 --> 00:42:31.676 A:middle
the A7 and later GPUs
perform all the rendering

00:42:31.676 --> 00:42:32.686 A:middle
in GPU tile storage.

00:42:32.726 --> 00:42:35.906 A:middle
The MSAA color attachment
texture is only used

00:42:35.906 --> 00:42:38.386 A:middle
if you choose to store the
sample data for a later use.

00:42:39.646 --> 00:42:43.476 A:middle
But most apps will choose the
multisample resolve store action

00:42:43.836 --> 00:42:45.986 A:middle
which results directly
from the GPU tile storage

00:42:46.296 --> 00:42:47.946 A:middle
to the resolve color
attachment texture.

00:42:49.256 --> 00:42:51.666 A:middle
So in that case make the
multisample color attachment

00:42:51.666 --> 00:42:54.636 A:middle
texture memoryless and this
is a massive memory savings.

00:42:55.966 --> 00:42:57.206 A:middle
As you can see, the savings

00:42:57.206 --> 00:42:59.176 A:middle
for adopting this
feature are substantial.

00:42:59.176 --> 00:43:02.396 A:middle
By making a 1080p depth
texture memoryless,

00:42:59.176 --> 00:43:02.396 A:middle
By making a 1080p depth
texture memoryless,

00:43:02.856 --> 00:43:04.596 A:middle
your app will save
almost 8 megabytes.

00:43:05.666 --> 00:43:07.206 A:middle
If you are rendering to
the native resolution

00:43:07.206 --> 00:43:09.296 A:middle
of a 12.9-inch iPad Pro,

00:43:09.596 --> 00:43:11.896 A:middle
the savings for the depth
buffer is over 20 megabytes.

00:43:12.706 --> 00:43:15.516 A:middle
And the savings for making a
four times multisample render

00:43:15.516 --> 00:43:18.476 A:middle
target memoryless are even
larger, four times larger.

00:43:19.876 --> 00:43:23.436 A:middle
So use memoryless render
targets to make the most

00:43:23.436 --> 00:43:25.846 A:middle
of your application's
memory budget.

00:43:26.396 --> 00:43:29.216 A:middle
Use the savings to lower the
memory footprint of your game.

00:43:29.576 --> 00:43:32.646 A:middle
Or better yet, use the
savings to add more beautiful

00:43:32.646 --> 00:43:34.326 A:middle
and unique content to your game.

00:43:36.446 --> 00:43:38.976 A:middle
Okay. I'd like to invite
Jose up to tell you all

00:43:38.976 --> 00:43:40.806 A:middle
about the improvements
to the Metal Tools.

00:43:41.516 --> 00:43:46.966 A:middle
[ Applause ]

00:43:47.466 --> 00:43:47.946 A:middle
&gt;&gt; Thank you, James.

00:43:48.666 --> 00:43:50.116 A:middle
So outside the great additions

00:43:50.116 --> 00:43:52.396 A:middle
to the Metal API we did
some great improvements

00:43:52.396 --> 00:43:56.256 A:middle
to Metal Developer Tools
I want to show you.

00:43:56.546 --> 00:43:59.296 A:middle
First we'll talk about
what's in Metal System Trace.

00:43:59.846 --> 00:44:02.096 A:middle
Than we'll introduce a new
feature called GPU Override.

00:43:59.846 --> 00:44:02.096 A:middle
Than we'll introduce a new
feature called GPU Override.

00:44:03.146 --> 00:44:05.766 A:middle
And we have some very
exciting new features coming

00:44:05.766 --> 00:44:10.586 A:middle
to GPU Frame Debugger.

00:44:12.006 --> 00:44:13.156 A:middle
So what is Metal System Trace?

00:44:14.316 --> 00:44:18.016 A:middle
In the [inaudible] Metal session
we presented this graph showing

00:44:18.016 --> 00:44:21.966 A:middle
you Metal working on
power in CPU and GPU.

00:44:22.126 --> 00:44:24.236 A:middle
Metal System Trace is
a set of instruments

00:44:24.236 --> 00:44:25.926 A:middle
for visualizing just that,

00:44:26.746 --> 00:44:28.176 A:middle
helping you understand
the timeline

00:44:28.176 --> 00:44:29.576 A:middle
of your Metal applications

00:44:29.876 --> 00:44:33.096 A:middle
through the whole graphic
pipeline, from the CPU

00:44:33.806 --> 00:44:38.746 A:middle
to the GPU, and then
on to the display.

00:44:38.886 --> 00:44:41.836 A:middle
Last year at WWDC we
introduced Metal System Trace

00:44:41.836 --> 00:44:42.876 A:middle
for iOS platform.

00:44:43.446 --> 00:44:46.176 A:middle
I highly recommend checking
out last year's presentation

00:44:46.356 --> 00:44:49.566 A:middle
for a great overview
of Metal System Trace.

00:44:49.756 --> 00:44:52.176 A:middle
Later in the fall we
added support for tvOS.

00:44:53.236 --> 00:44:55.806 A:middle
And today we're happy to
announce Metal System Trace

00:44:55.806 --> 00:44:59.266 A:middle
for macOS to help you squeeze
out the last bit of performance

00:44:59.816 --> 00:45:00.836 A:middle
on all Metal platforms.

00:44:59.816 --> 00:45:00.836 A:middle
on all Metal platforms.

00:45:01.516 --> 00:45:05.756 A:middle
[ Applause ]

00:45:06.256 --> 00:45:08.696 A:middle
&gt;&gt; We improved Metal System
Trace across the board,

00:45:08.786 --> 00:45:12.226 A:middle
extending the events
that we report.

00:45:12.226 --> 00:45:12.956 A:middle
[Inaudible] events,

00:45:13.376 --> 00:45:16.236 A:middle
we visualized expensive resource
operations to just picking data

00:45:16.236 --> 00:45:18.146 A:middle
from system memory
to video memory.

00:45:20.106 --> 00:45:23.986 A:middle
Like in this case where we
can see painting in macOS,

00:45:24.456 --> 00:45:26.106 A:middle
which is causing a
delay in GPU execution.

00:45:29.336 --> 00:45:32.736 A:middle
Metal System Trace also
displays debug groups,

00:45:32.906 --> 00:45:33.966 A:middle
which make it easier for you

00:45:33.966 --> 00:45:38.736 A:middle
to understand command encoded
relations in your trace.

00:45:38.916 --> 00:45:42.586 A:middle
On macOS we support tracing
multiple GPUs at the same time,

00:45:42.946 --> 00:45:44.806 A:middle
which is unbelievable
for those use cases

00:45:44.806 --> 00:45:47.926 A:middle
where you're distributing
work across different GPUs.

00:45:49.016 --> 00:45:51.946 A:middle
And on iOS we now
display scalar workloads

00:45:52.236 --> 00:45:54.786 A:middle
so that you can diagnose when
you're introducing latency

00:45:55.286 --> 00:46:00.966 A:middle
by rotating or scaling
your views.

00:45:55.286 --> 00:46:00.966 A:middle
by rotating or scaling
your views.

00:46:01.156 --> 00:46:02.786 A:middle
You can now use a wider range

00:46:02.786 --> 00:46:04.876 A:middle
of instruments alongside
Metal System Trace

00:46:05.656 --> 00:46:09.636 A:middle
such as Time Profiler,
File Activity,

00:46:10.896 --> 00:46:13.356 A:middle
Allocations, and many more.

00:46:13.686 --> 00:46:15.506 A:middle
Even different views
such as CPU data,

00:46:15.826 --> 00:46:18.136 A:middle
which will show you
CPU core time slices.

00:46:19.766 --> 00:46:23.406 A:middle
These will help you to correlate
Metal events into context,

00:46:23.606 --> 00:46:24.856 A:middle
deepening the understanding

00:46:25.276 --> 00:46:27.566 A:middle
of how the system is
running your application

00:46:28.166 --> 00:46:29.776 A:middle
and allowing you
to diagnose things

00:46:29.776 --> 00:46:35.786 A:middle
such as GPU starvation
caused by CPU stall due

00:46:35.786 --> 00:46:37.346 A:middle
to a [inaudible] operation.

00:46:40.576 --> 00:46:43.196 A:middle
Metal System Trace
captures a wealth of data.

00:46:43.586 --> 00:46:45.996 A:middle
So we made it easier for you
to interpret and navigate.

00:46:47.506 --> 00:46:50.086 A:middle
With the new workload
highlighting, you can focus

00:46:50.086 --> 00:46:52.336 A:middle
on any command encoder
or command buffer

00:46:53.246 --> 00:46:54.286 A:middle
as it works through
the pipeline.

00:46:54.396 --> 00:46:56.906 A:middle
And with with support
for keyboard navigation,

00:46:56.906 --> 00:46:59.056 A:middle
you can quickly move your
selection through your trace.

00:47:01.456 --> 00:47:04.246 A:middle
Finally, I want to introduce
Performance Observation.

00:47:05.026 --> 00:47:07.886 A:middle
And what Performance
Observation does is present you

00:47:07.886 --> 00:47:10.896 A:middle
with a comprehensive list of
the potential issues we found

00:47:10.896 --> 00:47:12.266 A:middle
in your trace from analyzing it.

00:47:13.996 --> 00:47:16.336 A:middle
From display surface
taking too long

00:47:17.666 --> 00:47:20.146 A:middle
to unexpected shader
compilations,

00:47:21.316 --> 00:47:26.066 A:middle
or high GPU execution times,
Performance Observations finds

00:47:26.066 --> 00:47:27.596 A:middle
for you the events which
you are looking for,

00:47:28.356 --> 00:47:29.856 A:middle
which you can navigate
straight to them

00:47:29.856 --> 00:47:31.436 A:middle
from the Performance
Observation list.

00:47:32.706 --> 00:47:34.006 A:middle
All these new additions
will allow you

00:47:34.006 --> 00:47:36.216 A:middle
to tune your Metal
applications to run as smoothly

00:47:36.216 --> 00:47:37.126 A:middle
as you want them to be.

00:47:38.426 --> 00:47:39.526 A:middle
And now for a demonstration

00:47:39.526 --> 00:47:41.346 A:middle
of our awesome GPU
debugging improvements,

00:47:41.736 --> 00:47:43.166 A:middle
let me hand over to
my colleague, Alp.

00:47:44.516 --> 00:47:49.500 A:middle
[ Applause ]

00:47:57.046 --> 00:47:57.596 A:middle
&gt;&gt; Thanks, Jose.

00:47:58.856 --> 00:48:01.246 A:middle
I have a number of great
features to show you today.

00:47:58.856 --> 00:48:01.246 A:middle
I have a number of great
features to show you today.

00:48:01.416 --> 00:48:02.596 A:middle
So let's dive right in.

00:48:02.676 --> 00:48:05.506 A:middle
I have my app running here,

00:48:05.896 --> 00:48:09.586 A:middle
cruising over beautiful terrain
tessellated to finest details.

00:48:10.746 --> 00:48:13.136 A:middle
Wouldn't it be great to see
this terrain in wire frame

00:48:13.136 --> 00:48:14.936 A:middle
to see triangles individually?

00:48:15.656 --> 00:48:19.286 A:middle
The good news is our newest
feature, GPU Overrides,

00:48:19.676 --> 00:48:22.516 A:middle
gives you ability to modify
your Metal rendering right

00:48:22.516 --> 00:48:24.756 A:middle
from the debug bar while
your app is running.

00:48:26.096 --> 00:48:28.606 A:middle
We have a number of different
overrides you can mix and match,

00:48:28.906 --> 00:48:29.896 A:middle
including wire frame mode.

00:48:31.566 --> 00:48:32.606 A:middle
Let's switch to wire frame mode

00:48:32.606 --> 00:48:35.506 A:middle
to see how tessellated
the terrain is.

00:48:36.966 --> 00:48:40.146 A:middle
Visualizing each
triangle you might want

00:48:40.216 --> 00:48:42.046 A:middle
to tune your tessellation
to fine the balance

00:48:42.046 --> 00:48:45.006 A:middle
between performance
and visual quality.

00:48:45.326 --> 00:48:47.006 A:middle
Normally you'd have to go back

00:48:47.006 --> 00:48:49.776 A:middle
and change your code,
recompile, and run.

00:48:49.856 --> 00:48:52.456 A:middle
But with GPU Overrides,
you can experiment

00:48:52.456 --> 00:48:56.936 A:middle
with your tessellation scaling
right from the Overrides menu.

00:48:57.136 --> 00:48:59.276 A:middle
Let's set scaling to 25%.

00:49:02.306 --> 00:49:05.226 A:middle
Now we have far less
triangles but lost some

00:49:05.226 --> 00:49:06.386 A:middle
of the interesting details.

00:49:07.706 --> 00:49:11.066 A:middle
Let's try 75%.

00:49:11.776 --> 00:49:12.586 A:middle
I think this looks better.

00:49:12.586 --> 00:49:16.926 A:middle
Let's see it without
the wire frame.

00:49:16.926 --> 00:49:18.006 A:middle
Okay. I like this one.

00:49:18.596 --> 00:49:21.056 A:middle
Now, we have less triangles
than what we started with

00:49:21.526 --> 00:49:23.256 A:middle
but still have all
the nice details.

00:49:23.256 --> 00:49:25.006 A:middle
And with the performance gains,

00:49:25.366 --> 00:49:27.246 A:middle
I can add more cool
effects to my scene.

00:49:28.776 --> 00:49:32.296 A:middle
So as seen here, GPU Overrides
is a great tool to help

00:49:32.296 --> 00:49:34.666 A:middle
with initial diagnosis
for some of the visual

00:49:34.906 --> 00:49:38.276 A:middle
and performance problems
in your scene.

00:49:38.496 --> 00:49:42.926 A:middle
Next, let's capture the frame
to show you some of the features

00:49:43.016 --> 00:49:45.506 A:middle
that will greatly improve
your debugging workflow.

00:49:47.776 --> 00:49:50.466 A:middle
The frame capture is
done and I am looking

00:49:50.466 --> 00:49:54.566 A:middle
for the terrain resources to
see how we are [inaudible].

00:49:57.456 --> 00:50:00.536 A:middle
Let's switch to all GPU
objects in Resource Center

00:49:57.456 --> 00:50:00.536 A:middle
Let's switch to all GPU
objects in Resource Center

00:50:00.936 --> 00:50:03.376 A:middle
where you can see all
your textures and buffers.

00:50:05.976 --> 00:50:07.986 A:middle
So we have all of
resources here.

00:50:08.526 --> 00:50:10.346 A:middle
And going over everything
one by one

00:50:10.766 --> 00:50:14.016 A:middle
to find terrain resources
could take some time.

00:50:14.676 --> 00:50:16.946 A:middle
This is where the new
filter bar comes to help.

00:50:18.036 --> 00:50:21.496 A:middle
You can filter by any properties
you see here, such as label,

00:50:21.976 --> 00:50:23.866 A:middle
type, size, or details.

00:50:25.256 --> 00:50:27.446 A:middle
Since I labeled all
my resources,

00:50:27.596 --> 00:50:29.116 A:middle
I'll just filter by terrain.

00:50:29.166 --> 00:50:32.696 A:middle
And right here I have
all the resources used

00:50:32.696 --> 00:50:35.456 A:middle
for rendering the terrain.

00:50:35.636 --> 00:50:38.336 A:middle
Now that I found the terrain
patches buffer, what I would

00:50:38.396 --> 00:50:41.176 A:middle
like to do is to see where
I'm actually using it.

00:50:42.506 --> 00:50:47.156 A:middle
With a simple drag and drop I
can filter function navigator

00:50:47.156 --> 00:50:49.516 A:middle
to show me all the
calls that's made

00:50:49.516 --> 00:50:51.496 A:middle
to terrain patches
buffer just like that.

00:50:52.636 --> 00:50:56.406 A:middle
In this case, I see where it
is calculated using compute

00:50:56.896 --> 00:51:01.556 A:middle
and where it says [inaudible]
while rendering the terrain.

00:50:56.896 --> 00:51:01.556 A:middle
and where it says [inaudible]
while rendering the terrain.

00:51:01.736 --> 00:51:03.166 A:middle
This filter is really powerful.

00:51:03.166 --> 00:51:06.186 A:middle
I can also use any
other properties

00:51:06.186 --> 00:51:08.226 A:middle
of the bound resources
to filter draw calls.

00:51:09.146 --> 00:51:11.886 A:middle
For example, if you
filter by SRGB,

00:51:12.776 --> 00:51:16.436 A:middle
you'll see all the draw calls
that are using a texture

00:51:16.476 --> 00:51:18.326 A:middle
with SRGB pixel format.

00:51:19.666 --> 00:51:21.846 A:middle
This is a natural
way of navigating

00:51:21.846 --> 00:51:22.926 A:middle
around your frame quickly.

00:51:24.836 --> 00:51:28.536 A:middle
Next, let's move
to bound GP objects

00:51:28.536 --> 00:51:31.916 A:middle
to see how we are using these
resources to render the terrain.

00:51:32.536 --> 00:51:36.986 A:middle
In bound mode your
resources are grouped

00:51:36.986 --> 00:51:39.176 A:middle
under different sections
based on the stage

00:51:39.176 --> 00:51:40.636 A:middle
of the Metal pipeline
they are used

00:51:40.636 --> 00:51:44.256 A:middle
in so you know exactly
where to look.

00:51:44.486 --> 00:51:45.776 A:middle
Looking at the vertex stage,

00:51:46.236 --> 00:51:49.476 A:middle
terrain patches is a buffer
bound to multiple binding points

00:51:49.646 --> 00:51:50.686 A:middle
with different offsets.

00:51:52.036 --> 00:51:58.026 A:middle
Let's use our only buffer
[inaudible] to inspect the data.

00:51:58.026 --> 00:52:00.046 A:middle
All the vertex data
has stayed nicely

00:51:58.026 --> 00:52:00.046 A:middle
All the vertex data
has stayed nicely

00:52:00.096 --> 00:52:02.796 A:middle
with the layout except
[inaudible] Metal function

00:52:02.796 --> 00:52:03.456 A:middle
with patches.

00:52:04.036 --> 00:52:06.496 A:middle
So this is using the
exact same struct

00:52:06.496 --> 00:52:07.716 A:middle
as your post-vertex function.

00:52:08.256 --> 00:52:11.186 A:middle
And we have a color data here.

00:52:11.956 --> 00:52:15.576 A:middle
It recognizes the word color
and visualizes the real color

00:52:15.576 --> 00:52:19.576 A:middle
of the value right in there.

00:52:19.696 --> 00:52:22.146 A:middle
Since this is a large buffer
that contains different types

00:52:22.146 --> 00:52:24.886 A:middle
of data, I have added
some debug markers

00:52:25.016 --> 00:52:28.616 A:middle
with the new [inaudible] API,
which makes it extra easy

00:52:28.616 --> 00:52:29.926 A:middle
to find what you
are looking for.

00:52:32.496 --> 00:52:35.356 A:middle
With the layout menu,
you can jump straight

00:52:35.356 --> 00:52:43.136 A:middle
to any other available layout
you would like to inspect.

00:52:43.316 --> 00:52:45.056 A:middle
Looking at individual
buffers is great.

00:52:45.926 --> 00:52:48.916 A:middle
What is even better is the
new input attribute view

00:52:49.526 --> 00:52:51.936 A:middle
which lets you see
all your vertex data

00:52:52.006 --> 00:52:53.756 A:middle
as your vertex shader sees it.

00:52:56.036 --> 00:52:59.046 A:middle
Input attributes collects all
the data from your instances,

00:52:59.496 --> 00:53:02.556 A:middle
tessellation factor buffers,
and your stage in data,

00:52:59.496 --> 00:53:02.556 A:middle
tessellation factor buffers,
and your stage in data,

00:53:02.556 --> 00:53:10.276 A:middle
then provides you a single view
to look at all of it together.

00:53:10.276 --> 00:53:13.946 A:middle
In this case we are rendering
instances with multiple patches

00:53:14.436 --> 00:53:18.766 A:middle
and I can see what data belongs
to which patch of an instance.

00:53:19.316 --> 00:53:22.746 A:middle
So that was a quick look at some

00:53:22.746 --> 00:53:24.716 A:middle
of our newest GPU Frame
Debugger features.

00:53:25.246 --> 00:53:31.556 A:middle
Let's switch back to
slides and wrap up.

00:53:32.516 --> 00:53:37.336 A:middle
[ Applause ]

00:53:37.836 --> 00:53:39.156 A:middle
So you've just seen some

00:53:39.156 --> 00:53:41.086 A:middle
of our newest GPU Frame
Debugger features.

00:53:41.756 --> 00:53:43.316 A:middle
I would like to tell
you about two more.

00:53:44.026 --> 00:53:49.746 A:middle
With the new Extended Validation
mode the GPU Frame Debugger can

00:53:49.746 --> 00:53:52.596 A:middle
perform even deeper
analysis of your application,

00:53:53.386 --> 00:53:56.676 A:middle
providing recommendations
[inaudible] the optimal texture

00:53:56.676 --> 00:53:59.646 A:middle
usage or storage mode
for your resources.

00:54:01.356 --> 00:54:07.116 A:middle
You can enable this mode from
the Xcode scheme editors.

00:54:07.626 --> 00:54:08.486 A:middle
And the new support

00:54:08.486 --> 00:54:11.886 A:middle
for stand-alone Metal Library
Projects lets you create Metal

00:54:11.886 --> 00:54:14.256 A:middle
libraries to be shared
in multiple apps

00:54:14.806 --> 00:54:18.096 A:middle
or include multiple of
them in a single app just

00:54:18.096 --> 00:54:19.806 A:middle
like any other framework
or library.

00:54:22.536 --> 00:54:24.456 A:middle
So we talked about features

00:54:24.456 --> 00:54:26.416 A:middle
that will greatly improve
your tool's experience.

00:54:26.956 --> 00:54:30.326 A:middle
Now let's summarize what we have
seen so far in this session.

00:54:32.636 --> 00:54:36.136 A:middle
We have seen the great additions
to Metal API with tessellation,

00:54:36.916 --> 00:54:39.726 A:middle
resource heaps and
memoryless render targets,

00:54:40.216 --> 00:54:43.296 A:middle
then we showed you improved
tools, Metal System Trace

00:54:43.296 --> 00:54:44.236 A:middle
and GPU Frame Debugger.

00:54:45.606 --> 00:54:47.836 A:middle
Be sure to stick around
for part two this afternoon

00:54:47.896 --> 00:54:51.046 A:middle
where I will talk about
function specialization

00:54:51.196 --> 00:54:54.426 A:middle
and function resource
read-writes, wide color

00:54:54.676 --> 00:54:57.356 A:middle
and texture assets,
and additions

00:54:57.356 --> 00:54:58.816 A:middle
to Metal performance shaders.

00:55:00.636 --> 00:55:02.546 A:middle
For more information
about this session,

00:55:02.726 --> 00:55:04.336 A:middle
please check the link online.

00:55:04.676 --> 00:55:06.816 A:middle
You can catch the
video and get links

00:55:06.816 --> 00:55:11.376 A:middle
to documentation
and sample code.

00:55:11.866 --> 00:55:15.596 A:middle
We had great sessions yesterday,
which are available online.

00:55:15.886 --> 00:55:18.976 A:middle
And this afternoon we have
What's New in Metal, Part2,

00:55:18.976 --> 00:55:22.066 A:middle
then Advanced Metal Shader
Optimization in this room.

00:55:23.276 --> 00:55:25.306 A:middle
Thanks for coming,
and have a great WWDC.

00:55:26.516 --> 00:55:29.500 A:middle
[ Applause ]
