WEBVTT

00:00:07.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:24.516 --> 00:00:27.526 A:middle
[ Applause ]

00:00:28.026 --> 00:00:28.776 A:middle
&gt;&gt; Good morning, everyone.

00:00:29.636 --> 00:00:31.066 A:middle
My name's Bruno Sommer.

00:00:31.066 --> 00:00:32.836 A:middle
I'm a game technologies
engineer here at Apple,

00:00:32.836 --> 00:00:35.056 A:middle
and this is What's
New in GameplayKit.

00:00:36.436 --> 00:00:38.716 A:middle
So last year, we
introduced GameplayKit,

00:00:38.966 --> 00:00:40.686 A:middle
Apple's high-level
gameplay framework,

00:00:41.056 --> 00:00:43.136 A:middle
and what GameplayKit
is is a collection

00:00:43.136 --> 00:00:45.946 A:middle
of common architectural
patterns, data structures,

00:00:46.246 --> 00:00:49.686 A:middle
and algorithms that enables our
developers to make really great

00:00:49.686 --> 00:00:51.856 A:middle
and compelling gameplay
in their games.

00:00:52.746 --> 00:00:56.306 A:middle
We want you guys to think about
GameplayKit as your toolbox

00:00:56.306 --> 00:00:58.876 A:middle
for great gameplay, so
regardless of the type

00:00:58.876 --> 00:01:01.566 A:middle
of game you're making, whether
it's a platformer or an RPG

00:00:58.876 --> 00:01:01.566 A:middle
of game you're making, whether
it's a platformer or an RPG

00:01:01.856 --> 00:01:04.855 A:middle
or a city builder, there's
something you can find

00:01:04.855 --> 00:01:06.876 A:middle
in GameplayKit to make
your life a little easier

00:01:07.136 --> 00:01:09.376 A:middle
and to make your gameplay
a little stronger.

00:01:11.076 --> 00:01:12.866 A:middle
So last year when we
introduced GameplayKit,

00:01:12.866 --> 00:01:14.486 A:middle
it was made up of
seven major systems --

00:01:15.046 --> 00:01:17.666 A:middle
things like entities and
components, state machines,

00:01:18.006 --> 00:01:19.546 A:middle
and our game quality
random sources.

00:01:21.176 --> 00:01:23.186 A:middle
This year, we're making
improvements to pathfinding,

00:01:23.696 --> 00:01:27.996 A:middle
agents, and game AI, and we're
also introducing three new major

00:01:27.996 --> 00:01:29.276 A:middle
systems to GameplayKit.

00:01:29.446 --> 00:01:32.556 A:middle
We have a really powerful
spatial partitioning system

00:01:32.766 --> 00:01:34.516 A:middle
that's going to let you get
really great performance

00:01:34.516 --> 00:01:36.656 A:middle
out of runtime queries
in your games.

00:01:37.076 --> 00:01:40.556 A:middle
You must have a really rich
procedural generation system

00:01:40.556 --> 00:01:42.056 A:middle
that's going to let you
make really compelling

00:01:42.056 --> 00:01:42.866 A:middle
runtime content.

00:01:43.376 --> 00:01:47.326 A:middle
And this year, we've also
integrated GameplayKit

00:01:47.326 --> 00:01:49.516 A:middle
into our Xcode Game
Editor, so now a lot

00:01:49.516 --> 00:01:51.596 A:middle
of the workflows previously
that you could only do in code,

00:01:51.856 --> 00:01:53.686 A:middle
now you can do right in
the Editor data side,

00:01:53.996 --> 00:01:55.206 A:middle
no recompile necessary.

00:01:55.836 --> 00:01:58.226 A:middle
So we have a lot to
talk about today.

00:01:58.266 --> 00:02:01.466 A:middle
I'm going to jump right in
with what's new in pathfinding.

00:01:58.266 --> 00:02:01.466 A:middle
I'm going to jump right in
with what's new in pathfinding.

00:02:03.176 --> 00:02:05.466 A:middle
So last year, we introduced
our obstacle graphs.

00:02:05.546 --> 00:02:07.346 A:middle
These are our graph type
that deals with a set

00:02:07.346 --> 00:02:10.246 A:middle
of impassable obstacles
in your game world.

00:02:10.506 --> 00:02:12.586 A:middle
And under the hood, we use
a line of sight algorithm

00:02:12.586 --> 00:02:14.966 A:middle
to map the passable area
between those obstacles.

00:02:15.626 --> 00:02:17.616 A:middle
Now, this method
is very powerful.

00:02:17.826 --> 00:02:20.796 A:middle
It results in really good
quality paths, but especially

00:02:20.796 --> 00:02:23.126 A:middle
for larger game worlds and game
worlds that have a large number

00:02:23.126 --> 00:02:25.806 A:middle
of obstacles, these can
be really computationally

00:02:25.806 --> 00:02:27.586 A:middle
intensively to calculate

00:02:27.586 --> 00:02:29.146 A:middle
and really memory
intensive to store.

00:02:30.266 --> 00:02:32.206 A:middle
So this year, we're providing
you with an alternative.

00:02:32.266 --> 00:02:34.286 A:middle
We're introducing GKMeshGraph.

00:02:35.606 --> 00:02:37.466 A:middle
Now, this is very similar
to our obstacle graphs.

00:02:37.466 --> 00:02:38.506 A:middle
Again, we're dealing with a set

00:02:38.506 --> 00:02:40.246 A:middle
of impassable obstacles
in our game world.

00:02:40.636 --> 00:02:42.416 A:middle
But now instead of
using line of sight

00:02:42.416 --> 00:02:44.886 A:middle
to calculate the passable
areas between those obstacles,

00:02:44.886 --> 00:02:46.976 A:middle
we're actually going to
triangulate that space.

00:02:47.146 --> 00:02:48.716 A:middle
We're going to make a
triangle mesh out of it

00:02:49.186 --> 00:02:50.626 A:middle
such that every passable point

00:02:50.626 --> 00:02:52.596 A:middle
in your game world
is represented on one

00:02:52.596 --> 00:02:53.746 A:middle
and only one triangle.

00:02:54.306 --> 00:02:57.676 A:middle
So this new triangulation
method results, still results

00:02:57.676 --> 00:03:00.046 A:middle
in really good quality paths
but has the added benefit

00:02:57.676 --> 00:03:00.046 A:middle
in really good quality paths
but has the added benefit

00:03:00.106 --> 00:03:01.656 A:middle
of being really fast
to calculate

00:03:01.876 --> 00:03:03.266 A:middle
and really low overhead
to store,

00:03:03.496 --> 00:03:05.176 A:middle
especially for really
large game worlds.

00:03:06.716 --> 00:03:08.176 A:middle
In addition, you have
a lot of flexibility

00:03:08.176 --> 00:03:10.806 A:middle
with where nodes get
placed on these mesh graphs.

00:03:11.056 --> 00:03:13.776 A:middle
You can place them at triangle
centers, triangle vertices,

00:03:13.926 --> 00:03:16.376 A:middle
and on triangle edges and
all the combinations thereof.

00:03:16.676 --> 00:03:19.976 A:middle
Let's look at a quick
code example

00:03:19.976 --> 00:03:22.156 A:middle
of what using a mesh graph
looks like in GameplayKit,

00:03:22.446 --> 00:03:24.826 A:middle
and this is going to look
very familiar to those of you

00:03:24.826 --> 00:03:26.036 A:middle
that have used our
obstacle graphs.

00:03:26.036 --> 00:03:27.976 A:middle
They're solving the same
problem, just different ways.

00:03:28.596 --> 00:03:31.426 A:middle
So here at the top, I'm going to
go ahead and make my mesh graph.

00:03:31.636 --> 00:03:33.576 A:middle
I'm going to pass in
a buffer radius of 10.

00:03:34.006 --> 00:03:36.536 A:middle
Recall that this buffer
radius is related to the size

00:03:36.536 --> 00:03:38.446 A:middle
of your agents that are
actually doing the pathfinding

00:03:38.446 --> 00:03:38.946 A:middle
in your world.

00:03:38.986 --> 00:03:41.126 A:middle
We're going to artificially
increase the size

00:03:41.126 --> 00:03:42.416 A:middle
of your obstacles under the hood

00:03:42.736 --> 00:03:44.346 A:middle
to compensate for
that agent size.

00:03:45.396 --> 00:03:47.496 A:middle
Here we're also going
to pass in two points --

00:03:47.496 --> 00:03:49.156 A:middle
(0, 0) and (1000, 1000).

00:03:49.156 --> 00:03:50.596 A:middle
This is the span
of my game world

00:03:50.596 --> 00:03:52.176 A:middle
that this mesh graph
is going to represent.

00:03:52.596 --> 00:03:56.486 A:middle
Next, I'm going to set
the triangulation mode

00:03:56.486 --> 00:03:57.286 A:middle
on my mesh graph.

00:03:57.666 --> 00:03:59.736 A:middle
This is that flexibility
with where nodes get placed

00:03:59.736 --> 00:04:00.826 A:middle
that I was talking
about earlier.

00:03:59.736 --> 00:04:00.826 A:middle
that I was talking
about earlier.

00:04:01.486 --> 00:04:04.076 A:middle
Here we're going to specify
that I'd like nodes to be placed

00:04:04.076 --> 00:04:06.276 A:middle
at triangle vertices
and on triangle centers.

00:04:06.746 --> 00:04:09.616 A:middle
And lastly, we're
going to add our set

00:04:09.616 --> 00:04:10.896 A:middle
of obstacles into
the mesh graph.

00:04:10.896 --> 00:04:13.026 A:middle
We have a set of obstacles
associated with our game world.

00:04:13.026 --> 00:04:14.766 A:middle
Then we're going to
call triangulate.

00:04:15.286 --> 00:04:17.456 A:middle
This actually commits those
obstacles to the graph,

00:04:17.815 --> 00:04:19.856 A:middle
run the underlying
triangulation algorithm,

00:04:20.096 --> 00:04:21.156 A:middle
and then we're good to go.

00:04:21.586 --> 00:04:27.066 A:middle
This graph is ready for use
in pathfinding in our game.

00:04:27.266 --> 00:04:28.466 A:middle
So in addition to
our mesh graphs,

00:04:28.466 --> 00:04:30.336 A:middle
this year we're introducing
custom node classes

00:04:30.376 --> 00:04:31.026 A:middle
to pathfinding.

00:04:31.576 --> 00:04:33.866 A:middle
A number of our graphs
automatically instantiate

00:04:33.866 --> 00:04:34.396 A:middle
their nodes.

00:04:34.646 --> 00:04:35.566 A:middle
That's our grid graphs,

00:04:35.636 --> 00:04:37.466 A:middle
our obstacle graphs,
and our mesh graphs.

00:04:38.646 --> 00:04:39.826 A:middle
Now at initialization time,

00:04:39.826 --> 00:04:42.316 A:middle
you can optionally specify
a custom node class for them

00:04:42.316 --> 00:04:43.376 A:middle
to instantiate instead.

00:04:44.046 --> 00:04:46.546 A:middle
And this is really useful if you
need to attach any custom data

00:04:46.546 --> 00:04:48.696 A:middle
or logic to your nodes, which
is sometimes useful depending

00:04:48.696 --> 00:04:50.706 A:middle
on the game you're
trying to make.

00:04:51.226 --> 00:04:52.346 A:middle
We call the appropriate init()

00:04:52.346 --> 00:04:54.636 A:middle
when we would've generated
our original node type.

00:04:55.386 --> 00:04:57.836 A:middle
And all these graph classes
now support Objective-C

00:04:57.836 --> 00:04:59.996 A:middle
and Swift generics, so
no casting is required

00:05:00.276 --> 00:05:01.656 A:middle
when you query your
custom nodes.

00:05:02.336 --> 00:05:07.106 A:middle
So that's what's new in
pathfinding this year.

00:05:07.206 --> 00:05:09.306 A:middle
Let's go ahead and move on
on what's new in agents.

00:05:10.796 --> 00:05:14.706 A:middle
A little bit of a refresher on
what agents are in GameplayKit.

00:05:14.706 --> 00:05:18.196 A:middle
They are autonomously moving
entities controlled by a set

00:05:18.196 --> 00:05:20.506 A:middle
of goals and behaviors,
and they're under a number

00:05:20.506 --> 00:05:22.406 A:middle
of realistic physical
constraints --

00:05:22.406 --> 00:05:24.446 A:middle
things like velocity, mass,

00:05:24.936 --> 00:05:26.506 A:middle
obstacle avoidance,
and path following.

00:05:26.506 --> 00:05:30.036 A:middle
On the right here, you see
you have a number of goals

00:05:30.036 --> 00:05:32.126 A:middle
at your disposal to achieve
the behavior you're looking

00:05:32.126 --> 00:05:32.866 A:middle
for in your game.

00:05:32.866 --> 00:05:34.846 A:middle
And this is things like
seeking and avoiding

00:05:34.846 --> 00:05:36.746 A:middle
or wandering and fleeing.

00:05:37.306 --> 00:05:41.446 A:middle
So previously, agents
were purely in 2D.

00:05:41.916 --> 00:05:43.056 A:middle
This year, we're
excited to announce

00:05:43.056 --> 00:05:44.496 A:middle
that we're bringing
them fully into 3D.

00:05:45.356 --> 00:05:49.426 A:middle
The class is GKAgent3D and the
interface is extremely similar

00:05:49.426 --> 00:05:50.336 A:middle
to its 2D variant.

00:05:50.706 --> 00:05:53.656 A:middle
The key differences are that
position is of course a float 3

00:05:54.196 --> 00:05:57.006 A:middle
and rotation is of course
a flow 3 by 3 matrix.

00:05:57.376 --> 00:05:59.426 A:middle
And all the same goals and
behaviors are supported.

00:06:00.726 --> 00:06:02.806 A:middle
So a couple things to note
here with this transition.

00:06:02.876 --> 00:06:06.456 A:middle
GKPath has been changed to
support both 2D and 3D points

00:06:06.456 --> 00:06:08.676 A:middle
with regards to our
path following goals.

00:06:09.486 --> 00:06:12.366 A:middle
And with regards to obstacles
in our obstacle avoidance goals,

00:06:12.366 --> 00:06:14.946 A:middle
those, if you're going to
use those obstacles in 3D,

00:06:14.946 --> 00:06:16.286 A:middle
they still live on
a single plane,

00:06:16.286 --> 00:06:18.316 A:middle
so you need to pick a plane
that makes sense for your game.

00:06:18.316 --> 00:06:22.496 A:middle
So in addition to bringing
our agents into 3D,

00:06:22.496 --> 00:06:24.656 A:middle
this year we're introducing
behavior composition.

00:06:25.206 --> 00:06:27.606 A:middle
We have a new class
GKCompositeBehavior that's a

00:06:27.606 --> 00:06:30.846 A:middle
subclass of GKBehavior,
and this is a collection

00:06:30.846 --> 00:06:31.846 A:middle
of weighted behaviors.

00:06:31.846 --> 00:06:33.776 A:middle
This is really similar
to the relationship

00:06:33.776 --> 00:06:36.096 A:middle
between behaviors
and goals previously.

00:06:36.096 --> 00:06:37.886 A:middle
Behaviors are a weighted
set of goals.

00:06:38.656 --> 00:06:40.596 A:middle
So these are fully nestable,

00:06:40.596 --> 00:06:42.916 A:middle
so now you can do really
interesting nested behavior,

00:06:42.976 --> 00:06:45.976 A:middle
behaviors in your game, and
this also makes them much easier

00:06:45.976 --> 00:06:47.516 A:middle
to maintain, especially
if you're working

00:06:47.516 --> 00:06:49.866 A:middle
with a large number of
behaviors in your game.

00:06:50.386 --> 00:06:53.216 A:middle
Let's take a look at
a quick code example

00:06:53.216 --> 00:06:54.796 A:middle
of these composite
behaviors in action.

00:06:55.296 --> 00:06:57.446 A:middle
At the top here, I'm going
to make a flocking behavior

00:06:58.036 --> 00:07:00.906 A:middle
by combine an align, a
cohere, and a separate goal.

00:06:58.036 --> 00:07:00.906 A:middle
by combine an align, a
cohere, and a separate goal.

00:07:01.366 --> 00:07:05.006 A:middle
Next, I have some obstacles
and enemies in my game world

00:07:05.006 --> 00:07:06.786 A:middle
that I'd like my agents
to avoid, so we're going

00:07:06.786 --> 00:07:09.946 A:middle
to make an avoidance behavior
by combining an avoidObstacles

00:07:10.006 --> 00:07:11.066 A:middle
and an avoidEnemies goal.

00:07:11.486 --> 00:07:14.966 A:middle
Then I'm going to combine
those two behaviors

00:07:14.966 --> 00:07:16.456 A:middle
into our new composite behavior,

00:07:16.456 --> 00:07:18.076 A:middle
effectively combining
them into one.

00:07:18.536 --> 00:07:21.356 A:middle
And lastly, I'm going
to make my agent,

00:07:21.636 --> 00:07:23.286 A:middle
I'm going to set my
composite behavior

00:07:23.286 --> 00:07:26.106 A:middle
as the agent's behavior,
and now we're good to go.

00:07:26.106 --> 00:07:27.516 A:middle
The next time we
update this agent,

00:07:27.516 --> 00:07:29.666 A:middle
it's going to correctly
simultaneously attempt

00:07:29.666 --> 00:07:32.106 A:middle
to achieve both of those
sub-goals or sub-behaviors.

00:07:35.656 --> 00:07:37.556 A:middle
So that's what's new
in agents this year.

00:07:37.766 --> 00:07:40.266 A:middle
Let's move on and talk about our
new spatial partitioning system.

00:07:40.796 --> 00:07:44.306 A:middle
So a little bit of background

00:07:44.306 --> 00:07:46.756 A:middle
on why spatial partitioning
might be important to your game.

00:07:47.116 --> 00:07:50.106 A:middle
A lot of times when we're going
high-level gameplay programming,

00:07:50.616 --> 00:07:52.876 A:middle
we ask a lot of spatial
questions about our game world,

00:07:53.346 --> 00:07:55.766 A:middle
things like, how many
enemies are near the player?

00:07:55.766 --> 00:07:58.036 A:middle
Or where are all the
items in my world?

00:07:58.576 --> 00:08:00.566 A:middle
Or what projectiles will
hit the player this frame?

00:07:58.576 --> 00:08:00.566 A:middle
Or what projectiles will
hit the player this frame?

00:08:00.966 --> 00:08:04.246 A:middle
Now, especially for larger
game worlds or game worlds

00:08:04.246 --> 00:08:07.476 A:middle
with a large number of game
objects, answering these types

00:08:07.476 --> 00:08:08.726 A:middle
of questions can be expensive.

00:08:09.236 --> 00:08:12.566 A:middle
In gameplay programming, we
often speed up these sorts

00:08:12.566 --> 00:08:14.086 A:middle
of spatial queries using a form

00:08:14.086 --> 00:08:16.176 A:middle
of caching called
spatial partitioning.

00:08:16.786 --> 00:08:20.606 A:middle
So a little bit of an overview
of what we're providing

00:08:20.606 --> 00:08:22.046 A:middle
with our spatial
partitioning system.

00:08:22.456 --> 00:08:24.866 A:middle
This is a set of tree-like
data structures that allows you

00:08:24.866 --> 00:08:26.506 A:middle
to cache your game
objects spatially.

00:08:27.026 --> 00:08:29.096 A:middle
You add objects to these
tree-like data structures

00:08:29.096 --> 00:08:30.486 A:middle
and they get grouped
into hierarchies

00:08:30.486 --> 00:08:31.506 A:middle
and buckets under the hood.

00:08:31.506 --> 00:08:34.236 A:middle
And then future queries
on these objects are made

00:08:34.236 --> 00:08:35.166 A:middle
implicitly faster.

00:08:36.155 --> 00:08:39.285 A:middle
This year, we're introducing
three such data structures

00:08:39.285 --> 00:08:40.566 A:middle
for you spatial partitioning
needs.

00:08:41.216 --> 00:08:43.936 A:middle
We have R-trees,
quadtrees, and octrees.

00:08:44.446 --> 00:08:47.466 A:middle
Let's dive a little deeper
into these data structures.

00:08:47.466 --> 00:08:48.526 A:middle
Let's talk about R-trees.

00:08:49.336 --> 00:08:52.596 A:middle
Now, what an R-tree is,
it's a tree data structure

00:08:52.596 --> 00:08:54.526 A:middle
that has a number of
hierarchical buckets.

00:08:55.276 --> 00:08:58.386 A:middle
Whenever you add an object
to an R-tree, it gets fitted

00:08:58.386 --> 00:08:59.446 A:middle
into one of those buckets.

00:09:00.176 --> 00:09:02.906 A:middle
Now, all these buckets have
a bounding box associated

00:09:02.906 --> 00:09:06.536 A:middle
with them that is the sum
of the bounding box of all

00:09:06.536 --> 00:09:07.966 A:middle
of the children that
are in that bucket.

00:09:08.426 --> 00:09:10.566 A:middle
Now, R-trees have a special rule

00:09:10.566 --> 00:09:13.006 A:middle
that when these buckets grow
too large, they need to split,

00:09:13.246 --> 00:09:15.746 A:middle
and this is a user-configurable
parameter

00:09:15.746 --> 00:09:17.356 A:middle
of just how large
these buckets can grow.

00:09:17.996 --> 00:09:20.606 A:middle
And we have a number of
strategies at our disposal

00:09:20.656 --> 00:09:22.356 A:middle
to decide how these
buckets should split.

00:09:22.926 --> 00:09:25.516 A:middle
We can simply have them or we
can try and optimize for linear

00:09:25.516 --> 00:09:28.186 A:middle
and quadratic distance
or try and reduce overlap

00:09:28.186 --> 00:09:29.116 A:middle
of the resulting buckets.

00:09:29.736 --> 00:09:32.826 A:middle
I'm going to give you
a quick visual example

00:09:32.826 --> 00:09:34.506 A:middle
of what building a
simple R-tree looks like.

00:09:34.506 --> 00:09:36.526 A:middle
Let's say I have a space game

00:09:36.726 --> 00:09:38.146 A:middle
with some spaceships
and some asteroids.

00:09:38.746 --> 00:09:40.596 A:middle
I'm going to add a
spaceship to my R-tree.

00:09:41.146 --> 00:09:42.196 A:middle
It gets fitted to a bucket

00:09:42.196 --> 00:09:44.226 A:middle
and it's just simply the
bounding box of that spaceship.

00:09:44.226 --> 00:09:47.026 A:middle
And then I'm going to add a
couple asteroids to that bucket,

00:09:47.026 --> 00:09:50.076 A:middle
and you notice it grows larger
to encapsulate those objects.

00:09:50.606 --> 00:09:53.906 A:middle
I've specified a rule in
this particular R-tree

00:09:53.906 --> 00:09:55.706 A:middle
that these buckets need to
split when they grow larger

00:09:55.706 --> 00:09:57.696 A:middle
than three objects, so
I'm going to go ahead

00:09:57.696 --> 00:09:59.266 A:middle
and add a fourth
object to that bucket.

00:09:59.516 --> 00:10:00.546 A:middle
We've grown too larger.

00:09:59.516 --> 00:10:00.546 A:middle
We've grown too larger.

00:10:00.626 --> 00:10:01.506 A:middle
Now we need to split.

00:10:02.266 --> 00:10:04.326 A:middle
And we're just going to do a
simple linear distance split,

00:10:04.426 --> 00:10:06.126 A:middle
and we end up with
two resulting buckets.

00:10:06.496 --> 00:10:10.486 A:middle
Again, I'll add a couple objects
to the bucket on the right.

00:10:12.076 --> 00:10:13.306 A:middle
We've grown too large.

00:10:13.306 --> 00:10:14.036 A:middle
We need to split.

00:10:14.036 --> 00:10:15.896 A:middle
And again, we'll do a
linear split and end

00:10:15.896 --> 00:10:17.076 A:middle
up with two resulting buckets.

00:10:17.786 --> 00:10:20.646 A:middle
That's the gist of how
R-trees work under the hood.

00:10:24.196 --> 00:10:26.516 A:middle
So let's move on and talk
about quadtrees and octrees.

00:10:26.596 --> 00:10:28.626 A:middle
I'm going to address
these singularly

00:10:28.626 --> 00:10:31.476 A:middle
because they're solving the same
problem, just quadtrees live

00:10:31.476 --> 00:10:33.216 A:middle
in 2D and octrees live in 3D.

00:10:33.216 --> 00:10:34.286 A:middle
The interface is identical.

00:10:35.106 --> 00:10:37.656 A:middle
These are tree-like data
structures that have a number

00:10:37.656 --> 00:10:40.616 A:middle
of levels and hierarchies,
and at each level,

00:10:40.616 --> 00:10:42.056 A:middle
space is subdivided evenly.

00:10:42.056 --> 00:10:43.976 A:middle
Here on the right, I have
an example of a quadtree.

00:10:44.526 --> 00:10:46.276 A:middle
And you see in the upper
left, I've subdivided

00:10:46.276 --> 00:10:47.776 A:middle
that quadrant once, and then

00:10:47.776 --> 00:10:49.826 A:middle
in that new subdivided
quadrant's upper left,

00:10:49.826 --> 00:10:50.826 A:middle
I've subdivided again.

00:10:51.346 --> 00:10:55.396 A:middle
So quadtrees and octrees have
a max cell size associated

00:10:55.396 --> 00:10:58.046 A:middle
with them, and that controls
just how deep these trees can

00:10:58.046 --> 00:11:00.216 A:middle
grow and just how small
those cells can get.

00:10:58.046 --> 00:11:00.216 A:middle
grow and just how small
those cells can get.

00:11:00.906 --> 00:11:03.676 A:middle
Now, when you add an object
to a quadtree and octtree,

00:11:03.676 --> 00:11:06.796 A:middle
it gets placed into the smallest
cell that it fits in entirely.

00:11:07.616 --> 00:11:10.126 A:middle
And a small note on
this maximum cell size,

00:11:10.126 --> 00:11:13.146 A:middle
this is really related, this
value is particular important

00:11:13.146 --> 00:11:14.506 A:middle
to the performance gains
you're going to see

00:11:14.506 --> 00:11:16.636 A:middle
out of these data structures,
so you should pick a cell size,

00:11:17.246 --> 00:11:19.146 A:middle
or a max cell size that
makes sense for your game.

00:11:19.146 --> 00:11:20.736 A:middle
Typically, this is
on the order of some

00:11:20.736 --> 00:11:24.416 A:middle
of the smaller game
objects in your game world.

00:11:24.556 --> 00:11:26.786 A:middle
Again, I'll give you a visual
example of building a quadtree.

00:11:27.396 --> 00:11:29.186 A:middle
Same examples, spaceship
and asteroids.

00:11:29.186 --> 00:11:30.866 A:middle
I'll insert a spaceship
into our quadtree.

00:11:31.326 --> 00:11:34.206 A:middle
Gets placed into the lower
left quadrant two levels down.

00:11:34.206 --> 00:11:37.106 A:middle
I'll add some bigger
objects, and they get,

00:11:37.106 --> 00:11:38.156 A:middle
they live one level up.

00:11:39.646 --> 00:11:41.256 A:middle
Take special note of that
asteroid on the left.

00:11:41.256 --> 00:11:43.506 A:middle
You see it sort of straddles
the quadrant boundaries.

00:11:43.506 --> 00:11:44.766 A:middle
It's actually going
to live one level

00:11:44.766 --> 00:11:47.376 A:middle
up because it doesn't fit neatly
into either of those cells.

00:11:47.866 --> 00:11:50.616 A:middle
And lastly, I'll add
some smaller objects,

00:11:50.616 --> 00:11:52.466 A:middle
and you see that they
live three levels down.

00:11:52.996 --> 00:11:57.786 A:middle
So that's the gist of what's
going on under the hood

00:11:57.976 --> 00:11:59.396 A:middle
when you use a quadtree
or an octtree.

00:11:59.686 --> 00:12:03.236 A:middle
Let's look at a code example
of a quadtree in action.

00:11:59.686 --> 00:12:03.236 A:middle
Let's look at a code example
of a quadtree in action.

00:12:04.066 --> 00:12:06.316 A:middle
So at the top here, I'm
going to make my quadtree.

00:12:06.376 --> 00:12:08.766 A:middle
I'm going to pass in a
quad, which is the area

00:12:08.766 --> 00:12:10.996 A:middle
in my game world that I want
this quad tree to represent.

00:12:11.076 --> 00:12:13.996 A:middle
Here we're going to cover the
span between (0, 0) and (1000,

00:12:13.996 --> 00:12:15.676 A:middle
1000) in my game world.

00:12:16.216 --> 00:12:19.346 A:middle
I'm mostly going to specify
a minimum cell size of 100.

00:12:19.346 --> 00:12:22.156 A:middle
No cell in this quadtree's going
to be smaller than 100 units.

00:12:22.726 --> 00:12:25.816 A:middle
So I also have some
enemies in my game world.

00:12:25.816 --> 00:12:27.606 A:middle
I'm going to go ahead and
add them to my quadtree.

00:12:28.506 --> 00:12:30.176 A:middle
Notice here that all these
enemies are associated

00:12:30.176 --> 00:12:31.156 A:middle
with a quad of their own.

00:12:31.376 --> 00:12:33.596 A:middle
This is where that enemy
is in our game world

00:12:33.596 --> 00:12:35.626 A:middle
and where it's going to
end up in our quadtree.

00:12:36.166 --> 00:12:39.996 A:middle
And lastly, I'm going to
run a query on our quadtree.

00:12:40.046 --> 00:12:42.396 A:middle
I'm going to ask my quadtree
to give me back all the objects

00:12:42.396 --> 00:12:46.216 A:middle
that are between (0, 0) and
(1000, 1000) in that quadtree

00:12:46.216 --> 00:12:47.476 A:middle
and therefore in my game world.

00:12:47.836 --> 00:12:50.036 A:middle
And it just so happens that
all three of these enemies are,

00:12:50.036 --> 00:12:52.386 A:middle
and I'm going to get all three
of them back in my query.

00:12:52.916 --> 00:12:56.396 A:middle
So that's spatial
partitioning in GameplayKit.

00:12:57.046 --> 00:12:59.346 A:middle
Let's move on and talk about our
procedural generation system.

00:12:59.896 --> 00:13:03.106 A:middle
So a little bit of background

00:12:59.896 --> 00:13:03.106 A:middle
So a little bit of background

00:13:03.106 --> 00:13:05.346 A:middle
on why procedural generation
might be important to you.

00:13:05.866 --> 00:13:09.426 A:middle
I'm sure we're all familiar
with premade content in games.

00:13:09.516 --> 00:13:11.746 A:middle
This is things that we
make before the game is run

00:13:11.746 --> 00:13:14.266 A:middle
or before the game even
ships, and this is things

00:13:14.266 --> 00:13:16.666 A:middle
like artist design, or
designer designed levels

00:13:16.896 --> 00:13:19.286 A:middle
or artist developed
textures and characters.

00:13:19.986 --> 00:13:21.736 A:middle
And these are great assets.

00:13:21.736 --> 00:13:23.116 A:middle
They really work
for a lot of games.

00:13:23.596 --> 00:13:26.366 A:middle
But for other types of
games and particular genres,

00:13:27.286 --> 00:13:30.296 A:middle
you run into problems because
these sort of assets are static.

00:13:30.416 --> 00:13:31.976 A:middle
They don't change at
runtime very much.

00:13:32.306 --> 00:13:34.816 A:middle
So especially if I'm
looking for a random feel,

00:13:34.816 --> 00:13:36.586 A:middle
every time I play my
game, it feels new,

00:13:37.036 --> 00:13:39.706 A:middle
I can't really use these
kinds of static assets.

00:13:40.466 --> 00:13:42.136 A:middle
So what I'm looking for
is procedural content,

00:13:42.136 --> 00:13:44.036 A:middle
and this is things like
randomly generated worlds,

00:13:44.336 --> 00:13:50.166 A:middle
procedurally generated
textures or height maps.

00:13:50.346 --> 00:13:52.746 A:middle
So we're looking to make this
procedural content in games.

00:13:53.386 --> 00:13:56.646 A:middle
What we're really looking for is
a source of coherent randomness.

00:13:56.756 --> 00:13:59.356 A:middle
A lot of these random elements
I'm trying to make are spatial

00:13:59.356 --> 00:14:02.716 A:middle
in nature, things like worlds
and textures and height maps.

00:13:59.356 --> 00:14:02.716 A:middle
in nature, things like worlds
and textures and height maps.

00:14:03.406 --> 00:14:05.096 A:middle
So we need a source
of randomness

00:14:05.096 --> 00:14:06.206 A:middle
that makes sense spatially,

00:14:06.206 --> 00:14:09.236 A:middle
that actually has an underlying
spatial pattern to it.

00:14:09.866 --> 00:14:10.776 A:middle
Now, you might say
to yourself, well,

00:14:10.776 --> 00:14:12.516 A:middle
I can just use a random
number generator, right?

00:14:12.626 --> 00:14:14.506 A:middle
I can pull some values
from my RNG,

00:14:14.506 --> 00:14:16.706 A:middle
make my random content,
and I'm good to go.

00:14:17.436 --> 00:14:19.036 A:middle
Anyone that's ever tried to do

00:14:19.036 --> 00:14:21.056 A:middle
that very quickly runs
into some hurdles.

00:14:21.746 --> 00:14:24.306 A:middle
Outputs of RNGs tend to
fluctuate very wildly.

00:14:24.306 --> 00:14:26.566 A:middle
It's difficult to have
meaningful spatial relationships

00:14:26.566 --> 00:14:27.776 A:middle
between subsequent calls

00:14:28.446 --> 00:14:30.356 A:middle
and it's also very
challenging to have determinism.

00:14:30.756 --> 00:14:32.406 A:middle
Every time I randomly
generate my content,

00:14:32.406 --> 00:14:36.686 A:middle
I want it to appear the same
way if I'm given the same seed.

00:14:37.276 --> 00:14:39.366 A:middle
So we're looking for this
source of coherent randomness.

00:14:39.366 --> 00:14:42.006 A:middle
One such source of
this is called noise.

00:14:43.446 --> 00:14:46.936 A:middle
Now, what noise is, it's a
function that takes inputs

00:14:46.986 --> 00:14:48.186 A:middle
and gives output values,

00:14:48.636 --> 00:14:50.306 A:middle
but there's some rules
to that relationship.

00:14:51.166 --> 00:14:53.716 A:middle
For small changes in input, I
get small changes in output,

00:14:54.356 --> 00:14:56.816 A:middle
and for large changes
in input, I get random

00:14:57.066 --> 00:15:00.356 A:middle
but still spatially
meaningful changes in output.

00:14:57.066 --> 00:15:00.356 A:middle
but still spatially
meaningful changes in output.

00:15:00.356 --> 00:15:02.476 A:middle
There's some underlying
pattern to this noise source.

00:15:03.416 --> 00:15:05.466 A:middle
And noise functions
are also infinite

00:15:05.596 --> 00:15:07.016 A:middle
for the whole range of inputs.

00:15:07.196 --> 00:15:09.536 A:middle
It continues infinitely,
and they're deterministic.

00:15:09.536 --> 00:15:11.396 A:middle
Given the same input, I
always get the same output.

00:15:13.596 --> 00:15:16.246 A:middle
So once we have this noise
function, we can then sample it

00:15:16.246 --> 00:15:18.736 A:middle
at intervals that are relevant
for my game and for the type

00:15:18.736 --> 00:15:19.926 A:middle
of content I'm trying to make.

00:15:20.386 --> 00:15:21.916 A:middle
So if I'm trying to
randomly generate a world,

00:15:21.916 --> 00:15:25.186 A:middle
this might be coordinates or
tile indexes or biome indexes.

00:15:25.746 --> 00:15:27.366 A:middle
Or if I'm trying to
randomly generate a texture,

00:15:27.366 --> 00:15:29.616 A:middle
this might be texels
or pixels and so on.

00:15:30.136 --> 00:15:34.816 A:middle
So a little overview
of what we're providing

00:15:34.816 --> 00:15:36.196 A:middle
with our procedural
generation system

00:15:36.196 --> 00:15:38.046 A:middle
and our noise system in general.

00:15:38.636 --> 00:15:41.166 A:middle
You have a number of noise
sources at your disposal

00:15:41.776 --> 00:15:44.066 A:middle
to sample and make meaningful
content in your game,

00:15:44.066 --> 00:15:46.036 A:middle
and this is things
like random-ish noise,

00:15:46.036 --> 00:15:47.816 A:middle
things like Perlin
noise and Voronoi noise,

00:15:48.376 --> 00:15:50.896 A:middle
and also geometric noise
sources, things like billows

00:15:50.896 --> 00:15:55.186 A:middle
and spheres, ridges and
cylinders, and also some sources

00:15:55.186 --> 00:15:57.086 A:middle
of constant noise like
the checkerboard pattern

00:15:57.086 --> 00:15:58.246 A:middle
or the constant noise function.

00:15:58.756 --> 00:16:02.966 A:middle
So you can then combine noise
sources in a noise object

00:15:58.756 --> 00:16:02.966 A:middle
So you can then combine noise
sources in a noise object

00:16:03.046 --> 00:16:05.036 A:middle
and perform a number of
transformations on them.

00:16:05.746 --> 00:16:07.656 A:middle
And these are things like
combining noise sources

00:16:07.656 --> 00:16:10.296 A:middle
or translating, scaling,
rotating noise sources.

00:16:10.866 --> 00:16:13.976 A:middle
So once we've combined
them in some meaningful way

00:16:14.416 --> 00:16:16.946 A:middle
into a noise object, we
can then sample a region

00:16:16.946 --> 00:16:18.926 A:middle
of that underlying noise
map, that noise function,

00:16:19.496 --> 00:16:23.676 A:middle
in a noise map, get our samples,
and then make our game content.

00:16:24.126 --> 00:16:26.386 A:middle
So let's dig a little deeper.

00:16:26.386 --> 00:16:27.766 A:middle
Let's talk about
our noise sources.

00:16:28.346 --> 00:16:30.836 A:middle
Now, all of our noise
sources output values

00:16:30.836 --> 00:16:32.646 A:middle
between negative 1 and 1.

00:16:32.966 --> 00:16:34.946 A:middle
We'll talk a little bit
more about this later.

00:16:35.646 --> 00:16:37.346 A:middle
And they all have parameters

00:16:37.346 --> 00:16:39.126 A:middle
to tweak their various
noise outputs,

00:16:39.126 --> 00:16:42.236 A:middle
that underlying noise
function, so for our more random

00:16:42.236 --> 00:16:45.086 A:middle
and coherent noises like Perlin
and Voronoi, these can be seeded

00:16:45.456 --> 00:16:47.896 A:middle
with a GKRandomSource and they
also have a number of parameters

00:16:47.896 --> 00:16:49.696 A:middle
on them to tweak their
underlying pattern.

00:16:50.266 --> 00:16:52.906 A:middle
And for our more geometric noise
sources, there's parameters

00:16:52.906 --> 00:16:56.016 A:middle
to alter their shapes, so the
size of spheres and cylinders

00:16:56.616 --> 00:16:58.566 A:middle
or the frequency of
ridges and billows.

00:16:59.086 --> 00:17:02.696 A:middle
So once we have some
noise sources we like,

00:16:59.086 --> 00:17:02.696 A:middle
So once we have some
noise sources we like,

00:17:02.696 --> 00:17:04.756 A:middle
we can then combine them
into a GKNoiseObject.

00:17:05.406 --> 00:17:09.455 A:middle
Now, this has all the functions
necessary to transform, combine,

00:17:09.455 --> 00:17:12.705 A:middle
and modify our noise sources,
and a lot of common mathematical

00:17:12.705 --> 00:17:14.296 A:middle
and logical operations
are supported.

00:17:14.945 --> 00:17:16.955 A:middle
So if I'm trying to combine
noise sources, I can add,

00:17:16.955 --> 00:17:19.915 A:middle
multiply, min or max,
but if I'm trying

00:17:19.915 --> 00:17:23.026 A:middle
to transform a single noise map,
I can scale, rotate, translate,

00:17:23.496 --> 00:17:25.496 A:middle
or I can modify it by
taking the absolute value,

00:17:25.685 --> 00:17:27.296 A:middle
clamping, inverting.

00:17:29.106 --> 00:17:31.026 A:middle
So once we have our
noise the way we like,

00:17:31.516 --> 00:17:34.296 A:middle
we can them sample a
region of that noise,

00:17:34.296 --> 00:17:37.276 A:middle
that underlying noise
function, using a GKNoiseMap.

00:17:37.736 --> 00:17:39.826 A:middle
You specify an origin
and a size.

00:17:39.886 --> 00:17:41.936 A:middle
This is the region of
that underlying noise map

00:17:41.936 --> 00:17:42.596 A:middle
that we're sampling.

00:17:43.066 --> 00:17:44.686 A:middle
And you also specify
a sample count.

00:17:44.876 --> 00:17:47.386 A:middle
How many times do we sample that
noise function in this region?

00:17:47.386 --> 00:17:49.606 A:middle
What's my fidelity at
which I'm sampling?

00:17:50.566 --> 00:17:53.146 A:middle
So then once we have
our region sampled,

00:17:53.146 --> 00:17:55.126 A:middle
we can then get the value
at any given position

00:17:55.366 --> 00:17:58.206 A:middle
on that noise map, and again,
the range is in negative 1 to 1

00:17:58.506 --> 00:17:59.386 A:middle
like I mentioned before.

00:17:59.926 --> 00:18:02.406 A:middle
And at runtime, you can
optionally overwrite values

00:17:59.926 --> 00:18:02.406 A:middle
And at runtime, you can
optionally overwrite values

00:18:02.406 --> 00:18:04.016 A:middle
as needed if your
game world changes.

00:18:04.016 --> 00:18:07.286 A:middle
So I realize that this
is a lot to take in.

00:18:07.286 --> 00:18:09.036 A:middle
I think the best way
to illustrate this is

00:18:09.036 --> 00:18:09.976 A:middle
with a visual example.

00:18:10.816 --> 00:18:13.566 A:middle
Let's say I wanted to randomly
generate a world for my game,

00:18:14.066 --> 00:18:16.916 A:middle
and I want to model it
after Earth's biomes.

00:18:16.916 --> 00:18:18.296 A:middle
I want it to have
a realistic feel.

00:18:18.566 --> 00:18:22.736 A:middle
Deserts, forests, arctic
zones, things like that.

00:18:23.536 --> 00:18:25.886 A:middle
One, this is one method you
might use to accomplish that.

00:18:25.886 --> 00:18:27.936 A:middle
Here I've generated
two Perlin noise maps,

00:18:28.466 --> 00:18:31.556 A:middle
and the one on the left I'm
going to call a moisture map.

00:18:31.556 --> 00:18:34.146 A:middle
At any point in my game world,
I can look into this map

00:18:34.146 --> 00:18:36.826 A:middle
and determine how wet or
how dry my game world is.

00:18:37.486 --> 00:18:39.926 A:middle
And on the right, I have what
I'm calling a temperature map.

00:18:39.926 --> 00:18:42.676 A:middle
At any point in my game world,
I can look up into this map

00:18:43.076 --> 00:18:46.136 A:middle
and decide how hot or
cold my game world is.

00:18:47.016 --> 00:18:49.396 A:middle
So some things to note here,
and we'll come back to this.

00:18:49.396 --> 00:18:52.556 A:middle
On the moisture map, you
see I have a very dry spot

00:18:52.556 --> 00:18:53.056 A:middle
on the right.

00:18:53.056 --> 00:18:54.186 A:middle
That's that black smudge.

00:18:54.236 --> 00:18:55.866 A:middle
And a very wet area on the left.

00:18:56.416 --> 00:18:58.136 A:middle
And again, these
colors correspond

00:18:58.136 --> 00:18:59.326 A:middle
to that output I
was talking about.

00:18:59.326 --> 00:19:01.066 A:middle
Here black is my negative 1's

00:18:59.326 --> 00:19:01.066 A:middle
Here black is my negative 1's

00:19:01.926 --> 00:19:03.646 A:middle
and white is more
of my positive 1's.

00:19:04.606 --> 00:19:06.916 A:middle
And on the right, notice I
have an extremely cold spot

00:19:06.916 --> 00:19:07.376 A:middle
at the top.

00:19:07.376 --> 00:19:08.516 A:middle
That's that black smudge again.

00:19:08.516 --> 00:19:11.816 A:middle
And a very warm sort of
right side of my noise map.

00:19:11.816 --> 00:19:15.176 A:middle
So I'm going to specify
some rules

00:19:15.176 --> 00:19:16.496 A:middle
on how I actually combine these

00:19:16.496 --> 00:19:17.926 A:middle
in some meaningful
way for my game.

00:19:18.726 --> 00:19:20.396 A:middle
Here I just have
a simple 2D graph.

00:19:20.396 --> 00:19:22.356 A:middle
On the vertical axis,
I have moisture,

00:19:23.016 --> 00:19:25.386 A:middle
and on the horizontal
axis, I have temperature.

00:19:26.106 --> 00:19:28.966 A:middle
So I can use these rules
to decide the intersection

00:19:28.966 --> 00:19:30.986 A:middle
of those two maps,
so if I have a spot

00:19:30.986 --> 00:19:32.076 A:middle
that has a really
high temperature

00:19:32.076 --> 00:19:33.606 A:middle
but really low moisture,
I'm going to end

00:19:33.606 --> 00:19:34.596 A:middle
up with something like a desert.

00:19:35.636 --> 00:19:37.256 A:middle
Or if I have something with
really high temperature

00:19:37.256 --> 00:19:38.406 A:middle
and really high moisture,
I'm going to end

00:19:38.406 --> 00:19:39.686 A:middle
up with something
like a rainforest.

00:19:40.326 --> 00:19:42.476 A:middle
And so there, and sort of
on the colder end of things,

00:19:42.476 --> 00:19:44.186 A:middle
I have tundras and arctic zones.

00:19:44.446 --> 00:19:45.796 A:middle
And then in the middle,
I have things

00:19:45.796 --> 00:19:48.146 A:middle
like the more temperate
biomes, things like forests,

00:19:48.276 --> 00:19:50.136 A:middle
savannahs, and grasslands.

00:19:51.276 --> 00:19:52.906 A:middle
So using those two maps I made

00:19:52.996 --> 00:19:54.666 A:middle
and combining them
using these rules,

00:19:54.696 --> 00:19:57.666 A:middle
I get something like this.

00:19:58.316 --> 00:20:00.626 A:middle
You see it has a nice,
realistic feel to it,

00:19:58.316 --> 00:20:00.626 A:middle
You see it has a nice,
realistic feel to it,

00:20:01.086 --> 00:20:02.506 A:middle
and some things to note.

00:20:02.506 --> 00:20:04.646 A:middle
On the right, you see we have
a really big desert that sort

00:20:04.646 --> 00:20:06.106 A:middle
of bleeds into some grasslands

00:20:06.106 --> 00:20:07.626 A:middle
and then bleeds into
a forest area.

00:20:08.136 --> 00:20:10.886 A:middle
That corresponds with that
dry spot on our moisture map

00:20:10.886 --> 00:20:12.836 A:middle
and that really warm spot
on our temperature map.

00:20:13.096 --> 00:20:15.226 A:middle
And sort of on the upper left,

00:20:15.226 --> 00:20:17.706 A:middle
you see we have a really big
tundra with some arctic spots.

00:20:18.236 --> 00:20:19.836 A:middle
Then on the upper right
and the lower left,

00:20:20.336 --> 00:20:22.136 A:middle
we have some small
rainforests corresponding

00:20:22.136 --> 00:20:24.056 A:middle
with really high temperatures
and really high moisture.

00:20:24.596 --> 00:20:27.966 A:middle
So this is just a really
basic example of some

00:20:27.966 --> 00:20:30.226 A:middle
of the cool stuff you can do
with procedural generation.

00:20:30.226 --> 00:20:32.856 A:middle
Here we just used two simple
noise maps, combined them

00:20:32.856 --> 00:20:34.106 A:middle
with some really simple rules,

00:20:34.246 --> 00:20:35.676 A:middle
and got some pretty
decent output.

00:20:36.206 --> 00:20:40.216 A:middle
Now, I'd like to call my
colleague Michael Brennan

00:20:40.216 --> 00:20:41.896 A:middle
up to tell you about
what's new in game AI.

00:20:42.526 --> 00:20:42.806 A:middle
Michael?

00:20:43.516 --> 00:20:49.236 A:middle
[ Applause ]

00:20:49.736 --> 00:20:50.766 A:middle
&gt;&gt; Thank you, Bruno.

00:20:51.466 --> 00:20:52.396 A:middle
Hey, everyone.

00:20:52.626 --> 00:20:53.586 A:middle
I'm Michael Brennan.

00:20:53.586 --> 00:20:55.606 A:middle
I'm a game technologies
engineer here at Apple,

00:20:56.146 --> 00:20:57.176 A:middle
and I'm really excited to share

00:20:57.176 --> 00:20:58.666 A:middle
with you today what
we're bringing

00:20:58.666 --> 00:21:03.306 A:middle
to GameplayKit this
year for game AI.

00:20:58.666 --> 00:21:03.306 A:middle
to GameplayKit this
year for game AI.

00:21:03.556 --> 00:21:04.816 A:middle
Last year with GameplayKit,

00:21:05.066 --> 00:21:06.736 A:middle
we introduced the
Minmax strategist.

00:21:07.436 --> 00:21:10.106 A:middle
This is a great AI solution
for all kinds of games

00:21:10.606 --> 00:21:13.836 A:middle
that guarantees an optimal
search for your game state.

00:21:14.356 --> 00:21:17.466 A:middle
It guarantees this by
having an exhaustive search

00:21:17.466 --> 00:21:19.556 A:middle
of that state space combined

00:21:20.036 --> 00:21:23.156 A:middle
with the scoring function you
provide for every given state

00:21:23.156 --> 00:21:26.576 A:middle
in the game to give you the best
possible move for your entity

00:21:26.576 --> 00:21:28.106 A:middle
to make at a certain point.

00:21:28.836 --> 00:21:30.216 A:middle
The exhaustive nature

00:21:30.216 --> 00:21:32.846 A:middle
of the Minmax strategist does
make it a little bit prohibitive

00:21:32.846 --> 00:21:35.126 A:middle
to use for games with larger
state spaces, however.

00:21:35.376 --> 00:21:37.156 A:middle
Games like Go or
chess, for example.

00:21:38.616 --> 00:21:40.546 A:middle
That's why this year
I'm excited to bring

00:21:40.546 --> 00:21:43.186 A:middle
with you the Monte
Carlo strategist.

00:21:44.576 --> 00:21:46.656 A:middle
Monte Carlo strategist
is a best first search

00:21:46.656 --> 00:21:49.716 A:middle
of the state space combined
with the random sampling

00:21:49.716 --> 00:21:52.126 A:middle
of that state space
to give a great move

00:21:52.376 --> 00:21:53.356 A:middle
for you opponent to make.

00:21:53.896 --> 00:21:59.916 A:middle
It does this by first selecting
a player move using exploration

00:21:59.916 --> 00:22:03.686 A:middle
versus exploitation to choose
that move, then simulating

00:21:59.916 --> 00:22:03.686 A:middle
versus exploitation to choose
that move, then simulating

00:22:03.686 --> 00:22:05.146 A:middle
out new games from that move

00:22:05.696 --> 00:22:07.426 A:middle
until it reaches
an end condition --

00:22:07.856 --> 00:22:09.506 A:middle
either a win or a
loss or a draw --

00:22:10.126 --> 00:22:12.296 A:middle
which then propagates
back up the tree.

00:22:12.836 --> 00:22:19.056 A:middle
It doesn't guarantee the optimal
move quite like Minmax does,

00:22:19.056 --> 00:22:21.746 A:middle
but it does converge
on that optimal move.

00:22:23.636 --> 00:22:25.226 A:middle
Monte Carlo strategist is fast.

00:22:25.696 --> 00:22:28.576 A:middle
It guarantees a good
performance for even games

00:22:28.736 --> 00:22:31.296 A:middle
with incredibly large state
spaces like Go, for example.

00:22:32.416 --> 00:22:34.676 A:middle
And given that it only
needs that end condition,

00:22:35.316 --> 00:22:37.236 A:middle
something your games
probably already provide,

00:22:37.756 --> 00:22:39.396 A:middle
it's very simple to
implement in your game.

00:22:39.396 --> 00:22:42.956 A:middle
And it is approximately
optimal, so while it may miss

00:22:42.956 --> 00:22:46.736 A:middle
that optimal move Minmax would
find, it is approximate to it

00:22:46.736 --> 00:22:49.286 A:middle
and it will converge on
that move given the time.

00:22:51.766 --> 00:22:54.176 A:middle
Let's go over some of the
elements you need to use

00:22:54.176 --> 00:22:56.276 A:middle
to incorporate this
into your game.

00:22:56.916 --> 00:22:59.636 A:middle
With GKMonteCarloStrategist,
you need to provide a budget.

00:23:00.226 --> 00:23:01.756 A:middle
This is the amount
of times it'll do

00:23:01.756 --> 00:23:03.166 A:middle
that four steps we
mentioned earlier.

00:23:03.946 --> 00:23:06.716 A:middle
And you need to provide
an exploration parameter.

00:23:06.716 --> 00:23:10.326 A:middle
Now, this is a value between 0
and 1 that states whether or not

00:23:10.436 --> 00:23:13.696 A:middle
on selecting a move you want
to explore unvisited nodes

00:23:14.476 --> 00:23:17.266 A:middle
or whether you want it to
exploit nodes it's visited

00:23:17.266 --> 00:23:18.396 A:middle
and found to be very winning.

00:23:18.396 --> 00:23:21.616 A:middle
And you need to provide
the game model of course.

00:23:21.716 --> 00:23:22.856 A:middle
This is something
you're familiar

00:23:22.856 --> 00:23:25.166 A:middle
with if you've used
GKMinmaxStrategist in the past.

00:23:25.646 --> 00:23:28.226 A:middle
Now let's look at a
brief code example.

00:23:29.626 --> 00:23:31.876 A:middle
So here we've got our
game model, GoGameModel,

00:23:31.876 --> 00:23:33.126 A:middle
which we're going to
hold a reference to,

00:23:33.716 --> 00:23:35.976 A:middle
and our Monte Carlo strategist,
which we're going to initialize

00:23:35.976 --> 00:23:36.806 A:middle
and hold a reference to.

00:23:37.976 --> 00:23:40.076 A:middle
We're first going to set the
Monte Carlo strategist game

00:23:40.076 --> 00:23:42.406 A:middle
model to point to our
game model, and next,

00:23:43.376 --> 00:23:44.946 A:middle
we're going to give it a budget.

00:23:45.706 --> 00:23:46.766 A:middle
We're going to say around 100.

00:23:46.846 --> 00:23:48.496 A:middle
This means it'll do
that four steps --

00:23:48.536 --> 00:23:50.656 A:middle
the simulating [inaudible]
propagating -- 100 times.

00:23:51.536 --> 00:23:53.476 A:middle
And then we're going to set
the exploration parameter to 1.

00:23:53.586 --> 00:23:55.896 A:middle
This means we want it
to be very explorative.

00:23:56.436 --> 00:24:00.576 A:middle
And then we're just simply
going to call for the best move

00:23:56.436 --> 00:24:00.576 A:middle
And then we're just simply
going to call for the best move

00:24:00.576 --> 00:24:04.616 A:middle
for our active player in that
game state, find that best move,

00:24:04.616 --> 00:24:06.216 A:middle
and apply it back
to our game model.

00:24:06.646 --> 00:24:07.346 A:middle
It's just that easy.

00:24:09.596 --> 00:24:11.876 A:middle
This year, I'm excited to tell
you that we're also allowing you

00:24:11.876 --> 00:24:13.456 A:middle
to make your own
custom strategist.

00:24:14.196 --> 00:24:16.856 A:middle
We implemented a new
protocol called GKStrategist,

00:24:16.946 --> 00:24:19.676 A:middle
and you simply conform to
it, giving the game model,

00:24:19.746 --> 00:24:21.706 A:middle
game model update,
game model players,

00:24:22.926 --> 00:24:26.826 A:middle
and implementing find best move
for player, and you can use this

00:24:26.826 --> 00:24:30.576 A:middle
like you would any other
strategist we provide for you.

00:24:31.086 --> 00:24:33.996 A:middle
So that was what we were
bringing to strategist.

00:24:33.996 --> 00:24:37.616 A:middle
Now let's talk about something
else -- decision-making.

00:24:39.876 --> 00:24:42.096 A:middle
There are many ways to
model logic in your game,

00:24:42.326 --> 00:24:44.526 A:middle
many of which GameplayKit
already provides support for.

00:24:45.606 --> 00:24:46.446 A:middle
Your enemies need to be able

00:24:46.446 --> 00:24:49.196 A:middle
to make decisions considering
the vast amounts of state,

00:24:49.196 --> 00:24:51.316 A:middle
and they need to be able to
make these decisions quickly.

00:24:51.836 --> 00:24:55.386 A:middle
As you can see here, we have
this little button jumping game.

00:24:56.236 --> 00:24:59.186 A:middle
Just in this simple game, your
opponent would need to consider

00:24:59.186 --> 00:25:02.256 A:middle
where you are, where every other
enemy is, where the buttons are,

00:24:59.186 --> 00:25:02.256 A:middle
where you are, where every other
enemy is, where the buttons are,

00:25:02.716 --> 00:25:04.776 A:middle
who owns the buttons at
the current point in time,

00:25:04.776 --> 00:25:07.026 A:middle
whether they're jumping,
whether the enemies are jumping,

00:25:07.666 --> 00:25:08.686 A:middle
where they are in the level.

00:25:08.786 --> 00:25:09.986 A:middle
It's quite a lot of
state to consider.

00:25:12.746 --> 00:25:15.956 A:middle
Decision trees are a simple
method for making decisions.

00:25:16.626 --> 00:25:18.806 A:middle
They're a tree-like data
structure which makes them easy

00:25:18.806 --> 00:25:22.116 A:middle
to visualize and debug, and
they can be either handmade

00:25:22.116 --> 00:25:25.836 A:middle
or learned.

00:25:25.966 --> 00:25:28.806 A:middle
GKDecisionTree gives
you a low overhead

00:25:28.966 --> 00:25:30.146 A:middle
for determining your action.

00:25:30.756 --> 00:25:33.806 A:middle
It's completely serializable and
it's very flexible, allowing you

00:25:33.806 --> 00:25:36.396 A:middle
to make nodes that will
make decisions that random

00:25:36.396 --> 00:25:39.496 A:middle
with certain weights
for branches or by value

00:25:39.496 --> 00:25:41.256 A:middle
if a certain branch is a
value like true or false

00:25:41.796 --> 00:25:43.486 A:middle
or by satisfying
predicates even.

00:25:43.606 --> 00:25:45.776 A:middle
It's extremely flexible,
allowing you to do a lot.

00:25:46.286 --> 00:25:50.176 A:middle
Let's go over a brief
code example.

00:25:50.506 --> 00:25:52.506 A:middle
So as you can see here,
we've got our tree.

00:25:52.506 --> 00:25:54.506 A:middle
We're going to initialize
it with a root attribute,

00:25:54.866 --> 00:25:56.306 A:middle
asking if we're near the button.

00:25:56.306 --> 00:25:58.836 A:middle
And then we're going
to grab a reference

00:25:58.836 --> 00:25:59.916 A:middle
to that root node for later.

00:26:00.316 --> 00:26:04.326 A:middle
After that, we're simply
going to create branches off

00:26:04.326 --> 00:26:08.736 A:middle
of that root node -- one for
if we are near that root,

00:26:08.776 --> 00:26:11.276 A:middle
that button, in which
case we're going to jump,

00:26:11.276 --> 00:26:12.936 A:middle
and one if we're not
near that button,

00:26:12.936 --> 00:26:14.486 A:middle
in which case we're
going to want to wander.

00:26:14.906 --> 00:26:15.816 A:middle
And we're going to
grab a reference

00:26:15.816 --> 00:26:16.916 A:middle
to that wander node as well.

00:26:16.916 --> 00:26:19.526 A:middle
With that wander node,

00:26:19.576 --> 00:26:21.606 A:middle
we're going to create
a few branches --

00:26:21.786 --> 00:26:25.246 A:middle
one with a weight of 9 we're
going to move left at that point

00:26:25.246 --> 00:26:26.646 A:middle
and one with a weight of 1
we're going to move right.

00:26:26.646 --> 00:26:27.426 A:middle
Now, this is additive,

00:26:27.526 --> 00:26:31.266 A:middle
which means that for the left
branch we move with the weight

00:26:31.266 --> 00:26:33.676 A:middle
of 9, that means it
has a 90% chance given

00:26:33.676 --> 00:26:35.196 A:middle
that there's a total
weight of 10 there,

00:26:35.746 --> 00:26:38.776 A:middle
and the right move has a
10% chance of occurring.

00:26:40.536 --> 00:26:43.536 A:middle
Then we're simply going to pack
the state into a dictionary

00:26:43.856 --> 00:26:46.006 A:middle
and pass it into
findActionForAnswers method

00:26:46.006 --> 00:26:47.486 A:middle
on the tree to get our action.

00:26:49.276 --> 00:26:50.896 A:middle
Decision trees can
also be modeled.

00:26:51.766 --> 00:26:53.326 A:middle
You simply supply
the gameplay data,

00:26:53.396 --> 00:26:56.066 A:middle
and it will find the
decision-making behavior

00:26:56.066 --> 00:26:58.196 A:middle
in that data and
fit a decision tree

00:26:58.196 --> 00:26:59.826 A:middle
to that decision-making
behavior.

00:27:00.196 --> 00:27:03.466 A:middle
As you can see here
in our matrix,

00:27:03.466 --> 00:27:05.466 A:middle
we have a top row
which is dark gray.

00:27:05.606 --> 00:27:06.676 A:middle
That's the attributes.

00:27:06.846 --> 00:27:09.166 A:middle
And the interior
matrix is our examples.

00:27:09.326 --> 00:27:12.796 A:middle
That's what various points of
the game look like for gameplay.

00:27:13.396 --> 00:27:15.866 A:middle
And on the right-hand side, we
have the actions we performed.

00:27:16.546 --> 00:27:17.636 A:middle
That's simply what we did

00:27:17.636 --> 00:27:19.026 A:middle
at those various
points in the gameplay.

00:27:19.196 --> 00:27:23.096 A:middle
You pass this into the
constructor for GKDecisionTree

00:27:23.346 --> 00:27:24.846 A:middle
and it will fit a decision tree

00:27:25.356 --> 00:27:27.006 A:middle
to that gameplay
data you've recorded.

00:27:27.506 --> 00:27:31.036 A:middle
Let's look at what this
might look like in game.

00:27:32.786 --> 00:27:35.886 A:middle
So here we have my
player, the light green

00:27:35.886 --> 00:27:37.156 A:middle
to turquoise colored player,

00:27:37.466 --> 00:27:39.126 A:middle
playing against the
dark blue player using

00:27:39.126 --> 00:27:40.666 A:middle
that handmade decision
tree we showed earlier.

00:27:41.196 --> 00:27:43.136 A:middle
As you can see, it's missing
out on some of the things

00:27:43.136 --> 00:27:44.716 A:middle
that we're doing that
make us perform well.

00:27:44.886 --> 00:27:48.706 A:middle
Let's look at a different
example.

00:27:49.496 --> 00:27:52.126 A:middle
Here you'll see it
behaves quite a lot more

00:27:52.126 --> 00:27:53.476 A:middle
like how we were
behaving earlier.

00:27:54.376 --> 00:27:56.346 A:middle
Like I said, you just simply
record your gameplay data,

00:27:56.626 --> 00:27:59.836 A:middle
pass it in, and you can model
behaviors like you would use.

00:28:00.346 --> 00:28:03.296 A:middle
So that's what we're
bringing this year

00:28:03.296 --> 00:28:04.676 A:middle
to game AI for GameplayKit.

00:28:05.186 --> 00:28:06.846 A:middle
It's awesome and I'm
excited to share it with you,

00:28:07.176 --> 00:28:10.196 A:middle
and now I'd like to invite to
the stage my colleague Sri Nair

00:28:10.196 --> 00:28:10.776 A:middle
to tell you more

00:28:10.776 --> 00:28:13.046 A:middle
about GameplayKit
integration into Xcode.

00:28:13.806 --> 00:28:13.946 A:middle
Sri?

00:28:15.516 --> 00:28:18.326 A:middle
[ Applause ]

00:28:18.826 --> 00:28:19.326 A:middle
&gt;&gt; Thank you, Michael.

00:28:21.996 --> 00:28:22.846 A:middle
Hello, everyone.

00:28:22.846 --> 00:28:27.056 A:middle
My name is Sri Nair, and I'm a
game technologies engineer here

00:28:27.056 --> 00:28:27.456 A:middle
at Apple.

00:28:28.026 --> 00:28:32.176 A:middle
So when we introduced
GameplayKit last year,

00:28:32.886 --> 00:28:34.816 A:middle
it was exclusively
driven by code.

00:28:35.666 --> 00:28:38.366 A:middle
You had to create the
constructs, do the hook-up,

00:28:39.426 --> 00:28:41.946 A:middle
and tweak the properties and
their values all in code.

00:28:43.376 --> 00:28:45.816 A:middle
And that can be inefficient
for many obvious reasons,

00:28:47.376 --> 00:28:50.926 A:middle
so I'm happy to say that we
are improving that situation

00:28:51.456 --> 00:28:53.816 A:middle
by introducing a more
data-driven workflow

00:28:54.146 --> 00:28:57.166 A:middle
for GameplayKit by
integrating it

00:28:57.166 --> 00:28:59.076 A:middle
with Xcode and SpriteKit Editor.

00:28:59.616 --> 00:29:04.686 A:middle
As you know, editor integration
helps with [inaudible]

00:28:59.616 --> 00:29:04.686 A:middle
As you know, editor integration
helps with [inaudible]

00:29:04.686 --> 00:29:06.666 A:middle
on your game features
much faster.

00:29:07.836 --> 00:29:10.496 A:middle
They also help to separate
your engineering workflow

00:29:10.496 --> 00:29:11.846 A:middle
from the design workflow.

00:29:12.396 --> 00:29:17.336 A:middle
So here are the four main
features coming to the editor

00:29:17.336 --> 00:29:20.166 A:middle
to help accelerate your
GameplayKit development.

00:29:21.056 --> 00:29:23.906 A:middle
Number one, entity
and component editor.

00:29:24.786 --> 00:29:26.626 A:middle
Number two, navigation
graph editor.

00:29:26.626 --> 00:29:29.106 A:middle
Number three, scene
outline view.

00:29:30.016 --> 00:29:31.816 A:middle
And number four, state
machine quick look.

00:29:33.006 --> 00:29:35.296 A:middle
Let's dive deeper into
each one of these features.

00:29:35.946 --> 00:29:37.116 A:middle
What's the component editor?

00:29:38.296 --> 00:29:40.246 A:middle
Let's recall that an entity

00:29:40.246 --> 00:29:42.246 A:middle
and component system
is a design pattern

00:29:42.246 --> 00:29:45.796 A:middle
where a game object is
represented by entities

00:29:45.796 --> 00:29:48.616 A:middle
and their behavior is
represented by smaller

00:29:48.616 --> 00:29:51.136 A:middle
and independent components.

00:29:52.156 --> 00:29:54.086 A:middle
And this provides for
better structuring

00:29:54.086 --> 00:29:55.286 A:middle
and usability of code.

00:29:56.206 --> 00:30:00.336 A:middle
And they also tend to be easier
to maintain and to extend.

00:29:56.206 --> 00:30:00.336 A:middle
And they also tend to be easier
to maintain and to extend.

00:30:01.366 --> 00:30:05.396 A:middle
So now with the component
editor, you can assign entity

00:30:05.396 --> 00:30:08.146 A:middle
and components to your
nodes right in the editor

00:30:09.936 --> 00:30:13.346 A:middle
and tweak the properties all
in the editor that's providing

00:30:13.346 --> 00:30:15.736 A:middle
for an editor-based,
data-driven workflow.

00:30:16.096 --> 00:30:21.416 A:middle
The editor is closely
integrated with code

00:30:21.416 --> 00:30:22.726 A:middle
and supports auto-discovery

00:30:22.726 --> 00:30:24.916 A:middle
of component classes
and properties.

00:30:25.616 --> 00:30:28.816 A:middle
For example, let's say you
wrote a movement component class

00:30:29.316 --> 00:30:31.696 A:middle
that's derived from GKComponent,
added a few properties,

00:30:32.286 --> 00:30:36.086 A:middle
and annotated with the newly
introduced GKInspectableKeyword

00:30:36.606 --> 00:30:38.266 A:middle
for them to show up in the UI.

00:30:38.816 --> 00:30:44.066 A:middle
And the component editor will
automatically detect these

00:30:44.066 --> 00:30:45.936 A:middle
components that you have
added and show up in the UI,

00:30:45.936 --> 00:30:49.736 A:middle
and now you can simply select
those components of your choice

00:30:49.736 --> 00:30:51.966 A:middle
and assign to the nodes.

00:30:52.106 --> 00:30:55.926 A:middle
Once you add the component, the
properties are auto-populated

00:30:56.066 --> 00:30:58.546 A:middle
with the corresponding
type of [inaudible],

00:30:58.546 --> 00:31:01.616 A:middle
and now you can adjust
these properties

00:30:58.546 --> 00:31:01.616 A:middle
and now you can adjust
these properties

00:31:01.616 --> 00:31:04.616 A:middle
and preview the changes right
in the editor without having

00:31:04.616 --> 00:31:08.006 A:middle
to quit the editor or recompile
the code that's leading

00:31:08.006 --> 00:31:09.396 A:middle
to a much faster iteration.

00:31:09.936 --> 00:31:14.636 A:middle
And all of these updates
are saved in a JKC

00:31:14.636 --> 00:31:16.706 A:middle
and under the SKS file.

00:31:18.196 --> 00:31:21.066 A:middle
And all the unchanged
property values use the default

00:31:21.066 --> 00:31:22.316 A:middle
setting code.

00:31:23.456 --> 00:31:27.076 A:middle
The GKEntity to the
nodes connection is made

00:31:27.296 --> 00:31:29.886 A:middle
under the hood through
a GKSKComponent.

00:31:30.366 --> 00:31:34.476 A:middle
And the UI supports all
the common property types,

00:31:34.906 --> 00:31:37.496 A:middle
such as float, int,
bool, et cetera,

00:31:38.046 --> 00:31:41.286 A:middle
and that's component editor.

00:31:41.286 --> 00:31:43.946 A:middle
Now, let's move on to the
navigation graph editor.

00:31:45.216 --> 00:31:47.866 A:middle
As Bruno mentioned earlier,
navigation graphs known

00:31:47.866 --> 00:31:50.436 A:middle
as GKGraphs are used
in pathfinding

00:31:51.066 --> 00:31:53.586 A:middle
to find an optimal way
for an object to get

00:31:53.586 --> 00:31:56.746 A:middle
from point A to point B.

00:31:56.966 --> 00:31:59.066 A:middle
And with the navigation
graph editor,

00:31:59.846 --> 00:32:02.186 A:middle
now you can create GKGraphs
right in the editor.

00:31:59.846 --> 00:32:02.186 A:middle
now you can create GKGraphs
right in the editor.

00:32:03.546 --> 00:32:06.936 A:middle
You can add or edit
nodes, make the connections

00:32:06.936 --> 00:32:10.706 A:middle
between them just by clicking
and dragging in the same window.

00:32:12.116 --> 00:32:15.586 A:middle
And these GKGraphs are
saved in the GKScene

00:32:15.716 --> 00:32:18.266 A:middle
that you can later retrieve in
code and use for pathfinding.

00:32:21.206 --> 00:32:24.416 A:middle
I also want to mention a highly
useful feature of we introduce

00:32:24.416 --> 00:32:27.216 A:middle
to SpriteKit Editor
that's quite useful

00:32:27.216 --> 00:32:33.126 A:middle
for GameplayKit development as
well called scene outline view.

00:32:33.336 --> 00:32:37.236 A:middle
It outlines the scene elements,
their parent-child hierarchy.

00:32:38.976 --> 00:32:44.666 A:middle
Most standard operations are
supported there like add, edit,

00:32:44.926 --> 00:32:47.536 A:middle
rearrange, delete, et cetera.

00:32:49.436 --> 00:32:53.526 A:middle
The navigation graphs you add
in your scene also show up there

00:32:53.526 --> 00:32:56.596 A:middle
in the scene outline view.

00:32:56.806 --> 00:32:59.306 A:middle
It also can be used
for locking the nodes

00:32:59.306 --> 00:33:00.986 A:middle
and changing the visibility.

00:32:59.306 --> 00:33:00.986 A:middle
and changing the visibility.

00:33:01.436 --> 00:33:02.846 A:middle
It also comes with
the context menu

00:33:02.846 --> 00:33:05.626 A:middle
for more selection-specific
operations.

00:33:06.186 --> 00:33:06.696 A:middle
Quite handy.

00:33:06.696 --> 00:33:11.746 A:middle
And last but not least,
state machine quick look.

00:33:12.256 --> 00:33:14.376 A:middle
So just to refresh,

00:33:14.376 --> 00:33:17.556 A:middle
we introduced GKStateMachine
last year, and it allows you

00:33:17.556 --> 00:33:20.746 A:middle
to represent some kind of
execution flow in your game.

00:33:21.486 --> 00:33:25.966 A:middle
And it has many applications in
games such as in AI, animation,

00:33:25.966 --> 00:33:27.736 A:middle
UI, level sequencing, et cetera.

00:33:28.276 --> 00:33:32.236 A:middle
And up until this
point, you had no way

00:33:32.236 --> 00:33:34.996 A:middle
of previewing what these
state machine looked like.

00:33:36.066 --> 00:33:38.836 A:middle
It was quite hard to
understand the connection

00:33:38.836 --> 00:33:40.966 A:middle
between the states,
the execution flow,

00:33:41.006 --> 00:33:45.446 A:middle
or what state it is in
currently, so to help with that,

00:33:45.446 --> 00:33:49.546 A:middle
we are integrating a state
machine preview tool right

00:33:49.546 --> 00:33:52.136 A:middle
into Xcode Debugger's
quick look feature.

00:33:53.556 --> 00:33:56.616 A:middle
This allows you to put break
point in code where you want

00:33:56.616 --> 00:34:02.066 A:middle
to see the state machine and
click on the quick look icon,

00:33:56.616 --> 00:34:02.066 A:middle
to see the state machine and
click on the quick look icon,

00:34:02.166 --> 00:34:04.176 A:middle
and it pops up a
visual representation

00:34:04.176 --> 00:34:06.146 A:middle
of for your current
state machine.

00:34:06.876 --> 00:34:08.936 A:middle
And it shows the states,
the connection between them,

00:34:08.936 --> 00:34:10.656 A:middle
and the current state
is highlighted as well.

00:34:11.206 --> 00:34:16.326 A:middle
Here are a few more
examples of state machine

00:34:16.565 --> 00:34:17.985 A:middle
as seen in quick look.

00:34:18.396 --> 00:34:24.976 A:middle
And with that, I would like to
demonstrate the editor-based

00:34:25.326 --> 00:34:26.646 A:middle
workflow of GameplayKit.

00:34:29.516 --> 00:34:34.295 A:middle
[ Applause ]

00:34:34.795 --> 00:34:40.166 A:middle
So here I have a, we're going
to try to build a simple game

00:34:40.166 --> 00:34:43.846 A:middle
where a player picks up
balloons, paint balloons,

00:34:43.846 --> 00:34:48.036 A:middle
and throws at an enemy
that's simulated by game AI,

00:34:48.696 --> 00:34:51.335 A:middle
and enemy can do the same.

00:34:51.335 --> 00:34:54.065 A:middle
So we have a basic scene here.

00:34:54.065 --> 00:34:55.956 A:middle
As you can see in the
scene outline view,

00:34:56.485 --> 00:35:00.446 A:middle
we have a background and a
player, a bunch of balloons.

00:34:56.485 --> 00:35:00.446 A:middle
we have a background and a
player, a bunch of balloons.

00:35:01.596 --> 00:35:04.266 A:middle
So first, we will try to add,

00:35:04.266 --> 00:35:07.406 A:middle
it's a pretty basic,
no actions going on.

00:35:07.406 --> 00:35:11.616 A:middle
It's very static scene, so we'll
start with adding some movement

00:35:11.616 --> 00:35:13.596 A:middle
to the player using
the keyboard.

00:35:14.386 --> 00:35:17.766 A:middle
So for that, I have added a few
components here, but we'll look

00:35:17.766 --> 00:35:20.256 A:middle
at the movement component
that we talked about earlier

00:35:20.786 --> 00:35:24.636 A:middle
as a few properties that helps
with movements such as speed,

00:35:25.446 --> 00:35:26.736 A:middle
friction, acceleration,
et cetera.

00:35:27.296 --> 00:35:31.016 A:middle
And you have annotated
that with the GKInspectable

00:35:31.016 --> 00:35:34.026 A:middle
so that you can treat those
properties in the UI later.

00:35:35.236 --> 00:35:37.676 A:middle
Similarly, I have a
player input component,

00:35:38.446 --> 00:35:45.246 A:middle
and we will assign these to the
player by going to the scene

00:35:45.246 --> 00:35:47.856 A:middle
and looking in the
component editor.

00:35:47.856 --> 00:35:50.646 A:middle
So on the inspector area
on the right-hand side,

00:35:50.646 --> 00:35:52.886 A:middle
I have the newly
introduced component editor.

00:35:53.566 --> 00:35:58.136 A:middle
Now, I can select the player
and click on that plus button

00:35:58.136 --> 00:36:00.546 A:middle
to add these components
to the node.

00:35:58.136 --> 00:36:00.546 A:middle
to add these components
to the node.

00:36:00.606 --> 00:36:04.436 A:middle
So we'll go ahead and add
the player input component

00:36:04.946 --> 00:36:06.286 A:middle
and the movement component.

00:36:09.356 --> 00:36:13.066 A:middle
And we'll see what
we get with that.

00:36:13.066 --> 00:36:15.806 A:middle
So I would expect
the player to be able

00:36:16.396 --> 00:36:18.486 A:middle
to move with the keyboard.

00:36:18.486 --> 00:36:22.996 A:middle
That's great, so can
move in all directions.

00:36:22.996 --> 00:36:25.956 A:middle
And except you can, you'll
notice that it doesn't stop

00:36:25.956 --> 00:36:28.336 A:middle
at the boundaries because I
haven't added any collision

00:36:28.336 --> 00:36:32.526 A:middle
to the player yet, but I do have
a collision component added,

00:36:32.526 --> 00:36:36.296 A:middle
which essentially adds the
physics body to the player node.

00:36:36.296 --> 00:36:41.596 A:middle
So I will go ahead and
assign that to the player.

00:36:41.906 --> 00:36:45.246 A:middle
And while we are at it, I will
also assign a fight component

00:36:45.246 --> 00:36:49.136 A:middle
that I added which allows you
to pick up balloons and throw.

00:36:49.796 --> 00:36:53.626 A:middle
So let's see what
that looks like.

00:36:56.986 --> 00:36:58.876 A:middle
Yay, now I can pick
up the balloons,

00:36:59.196 --> 00:37:00.686 A:middle
and he's stopped
at the boundaries.

00:36:59.196 --> 00:37:00.686 A:middle
and he's stopped
at the boundaries.

00:37:00.686 --> 00:37:01.226 A:middle
That's awesome.

00:37:02.396 --> 00:37:04.996 A:middle
We'll go ahead and do the same
to the enemy, so for that,

00:37:04.996 --> 00:37:09.116 A:middle
I had a game object, enemy
object created in the scene,

00:37:09.116 --> 00:37:13.516 A:middle
but I had set it to invisible,
so I'm going to enable it

00:37:13.896 --> 00:37:14.996 A:middle
in the scene outline view.

00:37:16.016 --> 00:37:19.566 A:middle
And go ahead and assign the
components to the enemy.

00:37:19.686 --> 00:37:22.916 A:middle
So in this case, the difference
is it's a enemy input component

00:37:22.916 --> 00:37:25.586 A:middle
so that it picks up the game AI
rather than use the keyboard,

00:37:26.646 --> 00:37:31.236 A:middle
and similarly, movement
component, collision component,

00:37:31.236 --> 00:37:32.576 A:middle
as well as the fight component.

00:37:33.046 --> 00:37:40.326 A:middle
And with that, I would
expect the enemy also to pick

00:37:41.866 --> 00:37:46.776 A:middle
up the balloons and,
yeah, he got me.

00:37:47.476 --> 00:37:50.346 A:middle
That was quite easy for
him, but we're going

00:37:50.346 --> 00:37:52.396 A:middle
to make the gameplay a
little bit more interesting

00:37:52.566 --> 00:37:58.366 A:middle
by dropping some balloons into
the scene using a drawn object.

00:37:58.366 --> 00:38:05.056 A:middle
So I have a drawn object that I
will make visible in the scene

00:37:58.366 --> 00:38:05.056 A:middle
So I have a drawn object that I
will make visible in the scene

00:38:05.416 --> 00:38:09.556 A:middle
and go ahead and add
a drawn component,

00:38:09.596 --> 00:38:14.466 A:middle
which basically does the
dropping of the balloon as well

00:38:14.466 --> 00:38:16.526 A:middle
as follow a certain path.

00:38:16.976 --> 00:38:20.606 A:middle
So I want to add a
navigation graph to the scene,

00:38:21.006 --> 00:38:23.566 A:middle
and that's as simple as
going into the object library

00:38:23.566 --> 00:38:26.166 A:middle
and typing in "nav graph."

00:38:26.166 --> 00:38:28.346 A:middle
Now, you can just simply drag

00:38:28.346 --> 00:38:31.196 A:middle
and drop the nav
graph to the scene.

00:38:31.196 --> 00:38:35.006 A:middle
So we'll just make the
navigation graph a little bigger

00:38:35.006 --> 00:38:37.006 A:middle
to demonstrate the feature.

00:38:38.106 --> 00:38:44.956 A:middle
So here's the navigation
graph editor.

00:38:45.106 --> 00:38:48.086 A:middle
And while we are at it, we'll
also change some properties.

00:38:49.176 --> 00:38:55.986 A:middle
We'll set the health to be 2
and the movement for the player,

00:38:55.986 --> 00:38:59.876 A:middle
speed up a little,
give some advantage

00:38:59.876 --> 00:39:02.466 A:middle
to the player a little bit,
just a level 1, so, hey,

00:38:59.876 --> 00:39:02.466 A:middle
to the player a little bit,
just a level 1, so, hey,

00:39:02.506 --> 00:39:03.336 A:middle
you got some advantage.

00:39:03.336 --> 00:39:07.066 A:middle
And enemy will get
health of 2 as well.

00:39:11.886 --> 00:39:13.526 A:middle
And let's see what we have.

00:39:16.256 --> 00:39:19.456 A:middle
You know, you can see that the
drone is dropping more balloons

00:39:19.626 --> 00:39:21.946 A:middle
that I can pick up and throw.

00:39:22.296 --> 00:39:28.586 A:middle
He got me and I got him
once, but let's see.

00:39:28.846 --> 00:39:30.196 A:middle
Yay. All right.

00:39:31.076 --> 00:39:32.346 A:middle
I'm sure my son will have a lot

00:39:32.346 --> 00:39:34.206 A:middle
of fun playing this
game [applause].

00:39:35.556 --> 00:39:40.106 A:middle
That pretty much demonstrates
the new editor-based workflow

00:39:40.106 --> 00:39:40.916 A:middle
for GameplayKit.

00:39:41.456 --> 00:39:42.686 A:middle
Let's switch back to the slides.

00:39:43.596 --> 00:39:49.606 A:middle
So to recap the session,
this year,

00:39:50.956 --> 00:39:53.216 A:middle
we have introduced
many compelling

00:39:53.806 --> 00:39:55.376 A:middle
and useful features
to GameplayKit.

00:39:55.916 --> 00:39:58.106 A:middle
In the beginning, Bruno talked

00:39:58.106 --> 00:40:00.516 A:middle
about the next spatial
partitioning system

00:39:58.106 --> 00:40:00.516 A:middle
about the next spatial
partitioning system

00:40:00.716 --> 00:40:02.546 A:middle
for efficient spatial
queries in your game.

00:40:04.076 --> 00:40:06.006 A:middle
The new procedural
generation system

00:40:06.006 --> 00:40:08.836 A:middle
for using various
noise functions

00:40:08.836 --> 00:40:11.036 A:middle
to create more dynamic
content in your game,

00:40:11.606 --> 00:40:14.106 A:middle
as well as improvements
to existing systems

00:40:14.166 --> 00:40:16.586 A:middle
such as pathfinding and agents.

00:40:17.116 --> 00:40:21.466 A:middle
And Michael talked about
the additions to game AI

00:40:21.816 --> 00:40:25.376 A:middle
with gameplay strategists
and decision trees.

00:40:26.216 --> 00:40:30.706 A:middle
And I finally covered the newly
introduced editor-based workflow

00:40:30.706 --> 00:40:32.536 A:middle
of GameplayKit for
faster iteration.

00:40:33.726 --> 00:40:36.276 A:middle
I hope you find these features
useful and we can't wait

00:40:36.276 --> 00:40:37.626 A:middle
to see what you come
up with next.

00:40:38.036 --> 00:40:43.326 A:middle
And here is the URL for this
session to check out for later.

00:40:43.576 --> 00:40:45.286 A:middle
Number 608 is the
session number.

00:40:46.316 --> 00:40:50.526 A:middle
And here are a few sessions
on related technologies

00:40:50.526 --> 00:40:51.946 A:middle
that you might be
interested in attending.

00:40:51.946 --> 00:40:54.946 A:middle
What's New in SpriteKit,
SceneKit, Rendering,

00:40:54.946 --> 00:40:57.796 A:middle
Game Center, and Game
Technologies for Apple Watch.

00:40:59.396 --> 00:41:00.436 A:middle
Thank you for coming,

00:40:59.396 --> 00:41:00.436 A:middle
Thank you for coming,

00:41:00.576 --> 00:41:02.296 A:middle
and we hope you enjoy the
rest of your conference.

00:41:03.016 --> 00:41:05.000 A:middle
[ Applause ]
