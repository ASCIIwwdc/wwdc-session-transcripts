WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:19.500 A:middle
[ Music ]

00:00:27.516 --> 00:00:31.756 A:middle
[ Applause ]

00:00:32.256 --> 00:00:32.496 A:middle
&gt;&gt; Thank you.

00:00:34.746 --> 00:00:35.416 A:middle
Hello, and welcome.

00:00:35.936 --> 00:00:36.936 A:middle
My name is Tony Parker.

00:00:36.936 --> 00:00:38.666 A:middle
I am the manager of the
Foundation team at Apple,

00:00:38.816 --> 00:00:40.956 A:middle
and I'm here with my
colleague Michael LeHew to talk

00:00:40.956 --> 00:00:42.836 A:middle
about what's new in
Foundation for Swift.

00:00:44.636 --> 00:00:46.846 A:middle
This year the Foundation
team has put a lot of effort

00:00:46.846 --> 00:00:49.096 A:middle
into improving the way
that you use the Cocoa

00:00:49.096 --> 00:00:51.186 A:middle
and Cocoa Touch APIs in Swift.

00:00:51.856 --> 00:00:54.326 A:middle
We started by working on the
Swift API Design Guidelines.

00:00:55.106 --> 00:00:57.546 A:middle
After that, we looked at how
all of the Objective-C code

00:00:57.546 --> 00:01:01.316 A:middle
that the Cocoa SDK uses and your
own code is imported into Swift,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.546 --> 00:01:01.316 A:middle
that the Cocoa SDK uses and your
own code is imported into Swift,

00:01:02.536 --> 00:01:04.066 A:middle
but we knew that we
could go further.

00:01:04.236 --> 00:01:06.926 A:middle
So, we have introduced a
brand new set of value types

00:01:06.926 --> 00:01:09.686 A:middle
in Foundation, and
along with that a ton

00:01:09.686 --> 00:01:12.316 A:middle
of new Swift-specific API.

00:01:13.056 --> 00:01:15.196 A:middle
So, let's go ahead and jump
into design guidelines.

00:01:17.186 --> 00:01:19.316 A:middle
Now, this year we're
working on Swift 3, and yet,

00:01:19.516 --> 00:01:21.886 A:middle
from the beginning our goals for
Swift have remained the same.

00:01:22.476 --> 00:01:25.856 A:middle
We want you to write code that's
fast, safe, and expressive.

00:01:26.946 --> 00:01:28.876 A:middle
We've built the libraries,
the standard library,

00:01:28.876 --> 00:01:30.726 A:middle
and the language
around these core ideas.

00:01:30.726 --> 00:01:33.576 A:middle
And many of you have also
internalized those same

00:01:33.576 --> 00:01:36.066 A:middle
principals and built your
application around that.

00:01:36.886 --> 00:01:39.426 A:middle
However, we all know that there
is another part to that story,

00:01:39.556 --> 00:01:41.006 A:middle
and that it the Cocoa SDK.

00:01:41.956 --> 00:01:45.526 A:middle
Your app depends on this just as
much, or maybe even more than,

00:01:45.526 --> 00:01:46.626 A:middle
the Swift standard library.

00:01:47.086 --> 00:01:49.516 A:middle
It needs to feel like it's
part of the same ecosystem.

00:01:50.486 --> 00:01:52.996 A:middle
Because the SDK is a
critical part of that story

00:01:53.166 --> 00:01:56.186 A:middle
about how we develop apps on our
platforms, it's really important

00:01:56.186 --> 00:01:59.026 A:middle
that the language and the
libraries work together.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:01.086 --> 00:02:03.826 A:middle
So this year we focused on
this idea of expressiveness.

00:02:04.386 --> 00:02:05.826 A:middle
When I say expressive,
I actually mean it

00:02:05.826 --> 00:02:06.626 A:middle
in two different ways.

00:02:07.016 --> 00:02:10.256 A:middle
First is your ability as app
authors to write Swift code

00:02:10.256 --> 00:02:13.596 A:middle
that expresses your intent to
the compiler and the libraries,

00:02:14.206 --> 00:02:15.416 A:middle
but it goes the other way too.

00:02:15.836 --> 00:02:18.096 A:middle
The libraries need to be
able to express their intent,

00:02:18.246 --> 00:02:20.976 A:middle
their design patterns and
their ideas about how best

00:02:20.976 --> 00:02:23.636 A:middle
to use the API to
you as an app author.

00:02:25.596 --> 00:02:27.486 A:middle
And so, while working
on the guidelines,

00:02:27.486 --> 00:02:29.966 A:middle
we focused on this idea of
a consistent experience.

00:02:30.316 --> 00:02:32.916 A:middle
Every decision made about those
guidelines was done in support

00:02:32.916 --> 00:02:34.006 A:middle
of the idea that the language

00:02:34.006 --> 00:02:35.386 A:middle
and the libraries
don't stand alone.

00:02:35.566 --> 00:02:36.596 A:middle
They have to work together.

00:02:37.266 --> 00:02:38.876 A:middle
So, for example,
from the libraries,

00:02:39.226 --> 00:02:40.936 A:middle
they bring a huge
number of features.

00:02:41.336 --> 00:02:43.166 A:middle
Many of the features that
you see in the new versions

00:02:43.166 --> 00:02:45.846 A:middle
of our platforms this year
are based on new features

00:02:45.846 --> 00:02:48.486 A:middle
in the libraries that you
can also adopt in your apps

00:02:48.656 --> 00:02:50.286 A:middle
to improve your experience.

00:02:51.176 --> 00:02:53.476 A:middle
These libraries have a
widespread adoption across all

00:02:53.476 --> 00:02:56.736 A:middle
of our platforms, including
this year new, Swift Auto ARC

00:02:56.736 --> 00:02:57.676 A:middle
and Swift Open Source.

00:02:58.266 --> 00:03:00.186 A:middle
So, we have Swift
core libs foundation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.266 --> 00:03:00.186 A:middle
So, we have Swift
core libs foundation

00:03:00.416 --> 00:03:02.836 A:middle
which is bringing the
Foundation API, much of it,

00:03:03.136 --> 00:03:04.686 A:middle
to other platforms like Linux.

00:03:05.846 --> 00:03:07.886 A:middle
These libraries have a
battle-tested implementation.

00:03:08.486 --> 00:03:10.176 A:middle
Many of them have been
around since the beginning

00:03:10.176 --> 00:03:12.646 A:middle
of OS X or even further back.

00:03:13.576 --> 00:03:14.786 A:middle
They also bring with them,

00:03:14.786 --> 00:03:16.346 A:middle
thanks to the Cocoa
naming guidelines,

00:03:16.456 --> 00:03:17.976 A:middle
a consistent set of conventions.

00:03:18.336 --> 00:03:20.286 A:middle
This means that when you
see a new piece of API,

00:03:20.286 --> 00:03:22.326 A:middle
you can understand how it works

00:03:22.326 --> 00:03:24.086 A:middle
and what it does
almost immediately.

00:03:24.816 --> 00:03:27.076 A:middle
And finally and importantly,
these libraries are

00:03:27.076 --> 00:03:29.036 A:middle
under continuous and
active development.

00:03:29.466 --> 00:03:31.176 A:middle
Not only are we adding
those new features,

00:03:31.446 --> 00:03:34.226 A:middle
but we're making enhancements,
fixing bugs, and more,

00:03:34.226 --> 00:03:37.186 A:middle
and we're going to continue
to do that every year

00:03:37.356 --> 00:03:38.316 A:middle
as we release new OSs.

00:03:38.316 --> 00:03:42.576 A:middle
Now, on the other hand,
the language, Swift,

00:03:42.726 --> 00:03:45.416 A:middle
brings with it things that we
just didn't have in Objective-C.

00:03:45.806 --> 00:03:47.876 A:middle
For example, first class
abort for generics,

00:03:48.536 --> 00:03:51.266 A:middle
and built in support for
mutation, which is a key part

00:03:51.266 --> 00:03:52.646 A:middle
of Swift's story about safety.

00:03:53.936 --> 00:03:55.806 A:middle
There's also things like
protocol extensions,

00:03:55.806 --> 00:03:58.006 A:middle
function overloading, and
default argument values,

00:03:58.476 --> 00:03:59.876 A:middle
all of which make
a dramatic impact

00:03:59.876 --> 00:04:01.796 A:middle
on how you design
your API in Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.876 --> 00:04:01.796 A:middle
on how you design
your API in Swift.

00:04:03.096 --> 00:04:04.556 A:middle
This isn't a complete
list on either side,

00:04:04.556 --> 00:04:05.726 A:middle
by the way I just
ran out of space.

00:04:05.986 --> 00:04:07.166 A:middle
There's plenty more
to go around.

00:04:07.846 --> 00:04:12.176 A:middle
So, we came up with
three key documents.

00:04:12.666 --> 00:04:16.156 A:middle
The first was SE-0023,
the API Design Guidelines.

00:04:16.216 --> 00:04:17.986 A:middle
Now, all these documents
were sent

00:04:18.086 --> 00:04:21.106 A:middle
to the Swift Evolution
mailing list, which gives you

00:04:21.106 --> 00:04:22.756 A:middle
and the rest of the
Swift community a chance

00:04:22.756 --> 00:04:25.646 A:middle
to participate in the design
and evolution of the language.

00:04:26.246 --> 00:04:29.376 A:middle
Now, we see these guidelines as
a unifying document for current

00:04:29.376 --> 00:04:30.766 A:middle
and future Swift libraries.

00:04:31.186 --> 00:04:32.846 A:middle
Along with that we have SE-0006,

00:04:32.906 --> 00:04:35.426 A:middle
which applied those design
guidelines to Standard Library,

00:04:35.796 --> 00:04:38.286 A:middle
giving us a consistent and
predicable set of primitives

00:04:38.286 --> 00:04:41.296 A:middle
that we can build on
top of, and SE-0005,

00:04:41.696 --> 00:04:44.756 A:middle
which dramatically improved the
expressivity of the Cocoa SDK,

00:04:45.126 --> 00:04:47.036 A:middle
by doing things like
adding default arguments,

00:04:47.286 --> 00:04:49.206 A:middle
improving option sets
and building properties,

00:04:49.506 --> 00:04:51.776 A:middle
even automatically adopting
protocols in some cases.

00:04:51.956 --> 00:04:56.846 A:middle
We had a whole talk about this
that I definitely recommend

00:04:56.846 --> 00:04:59.986 A:middle
that you check out if you missed
it, Swift API Design Guidelines.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:02.136 --> 00:05:04.206 A:middle
Now, all these were
tremendous advances,

00:05:04.816 --> 00:05:06.606 A:middle
but we knew that we
could go even further.

00:05:07.226 --> 00:05:09.756 A:middle
That's because Swift goals
go beyond just the names.

00:05:11.366 --> 00:05:14.856 A:middle
Mutability in particular is
a key part of the language,

00:05:15.616 --> 00:05:18.466 A:middle
and so, we turned our
attention to Foundation.

00:05:19.956 --> 00:05:21.836 A:middle
Now, if you're wondering
why Foundation?

00:05:22.626 --> 00:05:24.416 A:middle
The answer is because
it's kind of special,

00:05:24.756 --> 00:05:26.546 A:middle
and I'm not just saying
that because I work on it.

00:05:27.486 --> 00:05:30.976 A:middle
Foundation occupies a
unique spot in the SDK.

00:05:31.056 --> 00:05:33.006 A:middle
What's interesting about it
is that it's low enough level

00:05:33.006 --> 00:05:35.576 A:middle
to be used everywhere, on all
those platforms I mentioned.

00:05:36.276 --> 00:05:38.496 A:middle
Yet, at the same time,
it's also high enough level

00:05:38.906 --> 00:05:42.646 A:middle
to establish a whole new set of
common types and design patterns

00:05:42.646 --> 00:05:44.966 A:middle
that again you see reflected
throughout the entire SDK.

00:05:44.966 --> 00:05:48.296 A:middle
If we go back to our picture
from earlier and sort of zoom

00:05:48.296 --> 00:05:52.456 A:middle
in on the Cocoa SDK, you'll see
lots of frameworks that you use

00:05:52.456 --> 00:05:56.226 A:middle
in your apps every day, from
UIKit to SpriteKit, and WatchKit

00:05:56.226 --> 00:05:58.256 A:middle
to CoreData, and many
other cores and kits

00:05:58.346 --> 00:05:59.516 A:middle
that don't fit here either.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:00.376 --> 00:06:02.646 A:middle
Now, what's interesting
here is that almost all

00:06:02.646 --> 00:06:04.646 A:middle
of these are built
on top of Foundation.

00:06:05.616 --> 00:06:07.676 A:middle
So, we see Foundation
as a leverage point.

00:06:08.696 --> 00:06:10.876 A:middle
What that means is that we can
make a small set of changes

00:06:10.876 --> 00:06:14.976 A:middle
in Foundation, and that can have
a big impact on the entire SDK.

00:06:16.476 --> 00:06:18.486 A:middle
Partly, that's because
Foundation is the home

00:06:18.486 --> 00:06:20.526 A:middle
of many value types.

00:06:21.456 --> 00:06:25.436 A:middle
So, we focused on this idea
of evolution over revolution.

00:06:25.926 --> 00:06:27.856 A:middle
We've seen everything
that those libraries bring

00:06:27.856 --> 00:06:29.136 A:middle
to the development of your apps.

00:06:29.606 --> 00:06:31.166 A:middle
We're not going to
throw all that away

00:06:31.466 --> 00:06:32.656 A:middle
because we have a new language.

00:06:32.996 --> 00:06:35.146 A:middle
Instead what we're doing is
we're bringing the language

00:06:35.146 --> 00:06:37.106 A:middle
and the libraries
closer together

00:06:37.176 --> 00:06:39.136 A:middle
by making incremental
improvements to both.

00:06:39.756 --> 00:06:40.656 A:middle
The changes that we're talking

00:06:40.656 --> 00:06:43.676 A:middle
about today are a
continuation of that process.

00:06:44.166 --> 00:06:46.716 A:middle
And so with that in mind,

00:06:46.716 --> 00:06:49.306 A:middle
the Foundation team put forth
two additional proposals

00:06:49.306 --> 00:06:50.696 A:middle
to the Swift Evolution
mailing list.

00:06:51.246 --> 00:06:53.776 A:middle
The first was mutability
in Foundation value types,

00:06:54.186 --> 00:06:56.706 A:middle
which is about embracing
that Swift mutability model

00:06:56.706 --> 00:06:57.816 A:middle
in the Foundation framework.

00:06:59.766 --> 00:07:02.876 A:middle
And also, dropping the NS
prefix in Swift Foundation,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.766 --> 00:07:02.876 A:middle
And also, dropping the NS
prefix in Swift Foundation,

00:07:03.256 --> 00:07:05.316 A:middle
which is about establishing
those common types

00:07:05.316 --> 00:07:06.816 A:middle
and design patterns for Swift,

00:07:07.156 --> 00:07:08.686 A:middle
no matter which platform
you're using.

00:07:09.306 --> 00:07:13.846 A:middle
So here is an overview of some

00:07:13.846 --> 00:07:15.496 A:middle
of the API improvements
we've made this year.

00:07:15.876 --> 00:07:18.416 A:middle
First and foremost, value
semantics, a brand new set

00:07:18.416 --> 00:07:20.616 A:middle
of value types that you're
going to see across the SDK.

00:07:21.436 --> 00:07:23.076 A:middle
Beyond that, we did
an additional set

00:07:23.076 --> 00:07:23.946 A:middle
of naming improvements,

00:07:24.016 --> 00:07:26.946 A:middle
beyond what the Objective-C
translation into Swift can do.

00:07:27.656 --> 00:07:29.516 A:middle
We've adopted many
standard library protocols

00:07:29.516 --> 00:07:30.886 A:middle
on these types, which means

00:07:30.886 --> 00:07:32.506 A:middle
that your generic
algorithms can now work

00:07:32.506 --> 00:07:33.896 A:middle
on Foundation types as well.

00:07:34.746 --> 00:07:36.846 A:middle
We've added additional
type safety and a lot

00:07:36.846 --> 00:07:38.366 A:middle
of new Swift-specific features.

00:07:38.366 --> 00:07:42.986 A:middle
So, let's do a quick
overview of value types.

00:07:43.546 --> 00:07:45.656 A:middle
Now, value types
are distinguished

00:07:45.656 --> 00:07:49.196 A:middle
from reference types, primarily
based on their behavior

00:07:49.196 --> 00:07:53.266 A:middle
around copying, so value types
copy their content on assignment

00:07:53.266 --> 00:07:54.426 A:middle
or passed as a parameter.

00:07:54.596 --> 00:07:55.486 A:middle
Here's a quick example.

00:07:55.796 --> 00:07:56.436 A:middle
I've got a point.

00:07:57.046 --> 00:07:59.306 A:middle
I use the equals operator
to assign that point

00:07:59.346 --> 00:08:01.966 A:middle
to another point, and when
I mutate that second point,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.346 --> 00:08:01.966 A:middle
to another point, and when
I mutate that second point,

00:08:02.166 --> 00:08:03.856 A:middle
you see that only
the copy is mutated.

00:08:03.856 --> 00:08:05.346 A:middle
I didn't affect the
content of both.

00:08:05.686 --> 00:08:08.106 A:middle
That's because CGPoint
is a value type.

00:08:09.226 --> 00:08:10.016 A:middle
Now, on the other hand,

00:08:10.016 --> 00:08:12.096 A:middle
reference types share
their content by default.

00:08:12.816 --> 00:08:14.906 A:middle
Here I'm going to create some
data using the reference type

00:08:14.906 --> 00:08:15.816 A:middle
and its mutable data.

00:08:16.776 --> 00:08:19.486 A:middle
Then I use that same
equal operator to assign

00:08:19.486 --> 00:08:20.526 A:middle
that data to otherData.

00:08:21.126 --> 00:08:23.686 A:middle
However, this time, when
I mutate that second data,

00:08:24.106 --> 00:08:25.966 A:middle
you can see that it
affects the content of both.

00:08:26.066 --> 00:08:28.706 A:middle
Now, it's important to
understand that neither

00:08:28.706 --> 00:08:30.216 A:middle
of these is better
than the other.

00:08:30.866 --> 00:08:32.186 A:middle
You just use them
in different ways.

00:08:33.265 --> 00:08:35.285 A:middle
I like to think of it as a
couple of tools in the tool box

00:08:35.285 --> 00:08:38.876 A:middle
that you can reach for when
you have a particular problem

00:08:39.525 --> 00:08:40.635 A:middle
to solve.

00:08:41.326 --> 00:08:43.216 A:middle
So, when you're trying
to decide for yourself

00:08:43.996 --> 00:08:46.166 A:middle
if your type is a value
type or a reference type,

00:08:46.906 --> 00:08:49.796 A:middle
you should think about object
identity and stored contents.

00:08:49.796 --> 00:08:52.326 A:middle
Let me explain by way
of a couple of examples.

00:08:52.906 --> 00:08:56.626 A:middle
So, in Foundation, we
have a class called.

00:08:57.376 --> 00:09:00.276 A:middle
OperationQueue has a singleton,
called the main operation queue.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:57.376 --> 00:09:00.276 A:middle
OperationQueue has a singleton,
called the main operation queue.

00:09:01.386 --> 00:09:03.416 A:middle
That operation queue,
the main operation queue,

00:09:03.416 --> 00:09:04.596 A:middle
is where you put
work that you want

00:09:04.596 --> 00:09:05.666 A:middle
to happen on the main thread.

00:09:06.056 --> 00:09:07.596 A:middle
And so, there's only
one of them.

00:09:07.856 --> 00:09:09.076 A:middle
It has a kind of identity.

00:09:09.436 --> 00:09:11.996 A:middle
If I were to copy the main
OperationQueue then it would no

00:09:11.996 --> 00:09:13.416 A:middle
longer be the main
operation queue.

00:09:13.986 --> 00:09:15.076 A:middle
So, we believe

00:09:15.146 --> 00:09:17.646 A:middle
that OperationQueue
is a reference type.

00:09:18.646 --> 00:09:19.776 A:middle
Another example, a pattern

00:09:19.776 --> 00:09:22.366 A:middle
that you see throughout the
Cocoa SDKs is a delegation.

00:09:23.146 --> 00:09:25.106 A:middle
So here is the delegate,
or one of the delegates

00:09:25.106 --> 00:09:27.506 A:middle
for URL session,
and you'll notice

00:09:27.666 --> 00:09:30.156 A:middle
that the delegate protocol
has an argument, right there,

00:09:30.306 --> 00:09:33.826 A:middle
called Session, and that
tells the object that's being

00:09:33.826 --> 00:09:37.336 A:middle
delegated to which URLSession
it's doing work on behalf of,

00:09:37.906 --> 00:09:41.796 A:middle
and that idea of which
URLSession it is implies,

00:09:41.906 --> 00:09:42.786 A:middle
again, identity.

00:09:43.186 --> 00:09:45.036 A:middle
So, we believe that types

00:09:45.036 --> 00:09:47.006 A:middle
with delegates are
usually reference types.

00:09:47.566 --> 00:09:50.776 A:middle
On the other hand,
many types are more

00:09:50.776 --> 00:09:52.196 A:middle
about their store contents.

00:09:52.256 --> 00:09:53.506 A:middle
For example, Date.

00:09:53.506 --> 00:09:55.306 A:middle
This is one of our new
Foundation value types.

00:09:56.376 --> 00:09:57.866 A:middle
Date is an absolute
point in time.

00:09:58.596 --> 00:10:01.276 A:middle
We can have two Dates
that have the same value,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.596 --> 00:10:01.276 A:middle
We can have two Dates
that have the same value,

00:10:01.406 --> 00:10:03.016 A:middle
the same absolute point in time,

00:10:03.336 --> 00:10:04.656 A:middle
and be talking about
the same Date.

00:10:04.656 --> 00:10:07.086 A:middle
We don't need to talk about the
reference to that point in time.

00:10:07.626 --> 00:10:09.536 A:middle
In fact, if we look inside
the implementation of Date,

00:10:09.776 --> 00:10:11.856 A:middle
as you see here, it's
actually just a double,

00:10:12.346 --> 00:10:13.716 A:middle
and a double is something
that we sort

00:10:13.716 --> 00:10:15.876 A:middle
of already intuitively
understand as a value type.

00:10:17.106 --> 00:10:18.476 A:middle
Another example is Data.

00:10:19.006 --> 00:10:21.536 A:middle
Data is another one of our
new Foundation value types.

00:10:22.126 --> 00:10:24.966 A:middle
Data, normally you care about
the contents of that Data,

00:10:25.206 --> 00:10:28.376 A:middle
the bytes that are there, not
the actual NSData instance.

00:10:28.546 --> 00:10:33.976 A:middle
So, Foundation has made
Data into a value type.

00:10:34.146 --> 00:10:36.626 A:middle
Now, copying the data
every time that we pass it

00:10:36.626 --> 00:10:38.476 A:middle
as a parameter would
quickly get very expensive.

00:10:39.026 --> 00:10:41.626 A:middle
So, we performed an optimization
called Copy on Write.

00:10:42.496 --> 00:10:44.136 A:middle
So, here I'm going
to create some data,

00:10:44.896 --> 00:10:47.596 A:middle
and you see I've got a
struct, but inside that struct,

00:10:47.596 --> 00:10:48.856 A:middle
I also have a reference.

00:10:48.886 --> 00:10:50.816 A:middle
So, another example of
things working better

00:10:50.816 --> 00:10:51.636 A:middle
when they work together.

00:10:51.976 --> 00:10:53.866 A:middle
Here I'm using both a
reference and a value

00:10:54.266 --> 00:10:55.976 A:middle
to get the performance
characteristics

00:10:56.276 --> 00:10:58.946 A:middle
that I want along with the value
semantics that are important.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:00.026 --> 00:11:02.756 A:middle
Now, if I use that equal
operator to assign that data

00:11:02.756 --> 00:11:05.116 A:middle
to another data,
then you can see

00:11:05.116 --> 00:11:07.616 A:middle
that I've got another
struct, but it points

00:11:07.616 --> 00:11:09.446 A:middle
at the same class
under the hood.

00:11:10.146 --> 00:11:14.006 A:middle
However, if I mutate that Data,
then we will copy the Data,

00:11:14.486 --> 00:11:17.506 A:middle
mutate the copy, and now we've
got two independent Datas.

00:11:18.876 --> 00:11:20.456 A:middle
If I continue to
mutate the second Data,

00:11:20.986 --> 00:11:23.616 A:middle
we can tell that that Data
is uniquely referenced,

00:11:23.616 --> 00:11:25.066 A:middle
and we don't need to
copy it each time.

00:11:25.996 --> 00:11:28.556 A:middle
So, this is an extension, or
actually, just another use

00:11:28.556 --> 00:11:31.256 A:middle
of the same technique that
we've talked about in the past,

00:11:31.256 --> 00:11:33.366 A:middle
including last year,
with building better apps

00:11:33.366 --> 00:11:34.396 A:middle
and value types in Swift.

00:11:34.396 --> 00:11:36.046 A:middle
So, check that out if you
want some more information

00:11:36.046 --> 00:11:38.486 A:middle
on how this works.

00:11:38.656 --> 00:11:41.386 A:middle
So, we did a survey of
every API in Foundation,

00:11:41.656 --> 00:11:43.476 A:middle
and we came up with
this list of things

00:11:43.476 --> 00:11:45.196 A:middle
that we think would
make great value types,

00:11:45.656 --> 00:11:47.566 A:middle
and I think you'll be happy
to see many of the types

00:11:47.566 --> 00:11:49.566 A:middle
that you use every
day on this list.

00:11:49.976 --> 00:11:51.976 A:middle
That includes Data and
Date, as I mentioned,

00:11:52.326 --> 00:11:54.766 A:middle
but also other types that
are really popular like URL,

00:11:55.166 --> 00:11:57.986 A:middle
IndexPath, CharacterSet,
and a lot more.

00:11:58.286 --> 00:12:00.426 A:middle
And many of these types not
only became value types,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.286 --> 00:12:00.426 A:middle
And many of these types not
only became value types,

00:12:00.726 --> 00:12:03.186 A:middle
but gained a lot of
great new API as well.

00:12:03.716 --> 00:12:06.946 A:middle
Now, to give you an idea
of what that looks like,

00:12:07.036 --> 00:12:08.406 A:middle
I'd like to invite
Michael on stage.

00:12:09.516 --> 00:12:13.796 A:middle
[ Applause ]

00:12:14.296 --> 00:12:14.846 A:middle
&gt;&gt; Thank you, Tony.

00:12:15.616 --> 00:12:17.626 A:middle
Let's start by visiting
the new homes of many

00:12:17.626 --> 00:12:19.046 A:middle
of Foundation's enumerations.

00:12:19.696 --> 00:12:22.176 A:middle
Now, as you know,
Objective-C enumerations

00:12:22.176 --> 00:12:24.166 A:middle
and option sets live in
the global namespace,

00:12:24.226 --> 00:12:25.896 A:middle
alongside the types
that consume them.

00:12:26.166 --> 00:12:30.066 A:middle
For example, NSNumberFormatter
alone defines four enumerations

00:12:30.226 --> 00:12:33.676 A:middle
for the style, behavior, pad
position, and rounding mode.

00:12:34.476 --> 00:12:37.106 A:middle
And each of these are implicitly
associated with NumberFormatter

00:12:37.466 --> 00:12:39.346 A:middle
through careful and
consistent naming convention.

00:12:39.996 --> 00:12:42.226 A:middle
In Swift 2 as you
know, these important

00:12:42.226 --> 00:12:43.576 A:middle
to the global namespace as well.

00:12:43.576 --> 00:12:46.896 A:middle
But that doesn't feel
like native Swift.

00:12:47.426 --> 00:12:49.286 A:middle
Swift supports nested types,

00:12:49.886 --> 00:12:53.126 A:middle
and so in Swift 3 we made the
decision to relocate these types

00:12:53.876 --> 00:12:56.496 A:middle
to be declared inside,
where they're destined to.

00:12:56.496 --> 00:12:59.026 A:middle
So NumberFormatter now has
internal types of style,

00:12:59.066 --> 00:13:00.526 A:middle
behavior, pad position,
and rounding mode.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.066 --> 00:13:00.526 A:middle
behavior, pad position,
and rounding mode.

00:13:00.886 --> 00:13:02.816 A:middle
And their names are
no longer redundant,

00:13:03.716 --> 00:13:05.856 A:middle
and this greatly reduces
the number of types

00:13:05.856 --> 00:13:08.066 A:middle
that Foundation declares
in the top-level namespace,

00:13:08.506 --> 00:13:10.486 A:middle
and now the relationship
is explicit,

00:13:10.526 --> 00:13:12.946 A:middle
our APIs more expressive
and more discoverable.

00:13:14.476 --> 00:13:16.806 A:middle
Sticking with the
theme of enumerations,

00:13:17.196 --> 00:13:20.836 A:middle
many Foundation APIs also use
families of streamed constants.

00:13:20.986 --> 00:13:24.626 A:middle
Examples include notification
names, URL resource keys.

00:13:25.066 --> 00:13:29.136 A:middle
Now of course, Swift has support
for enumerations that rely

00:13:29.136 --> 00:13:31.496 A:middle
on raw representations
that are other

00:13:31.496 --> 00:13:33.396 A:middle
than integers, including string.

00:13:33.816 --> 00:13:35.486 A:middle
Wouldn't it be great if
we could do the same thing

00:13:35.486 --> 00:13:36.326 A:middle
in Objective-C?

00:13:37.336 --> 00:13:40.346 A:middle
Well, new this year we can, and
the constants are now defined

00:13:40.346 --> 00:13:42.806 A:middle
in terms of very specific
kinds of string constants,

00:13:43.026 --> 00:13:46.286 A:middle
like notification name
and URL resource key,

00:13:46.596 --> 00:13:47.746 A:middle
and many, many more.

00:13:49.706 --> 00:13:53.846 A:middle
And these constants remain
extensible, in Objective-C

00:13:54.556 --> 00:14:00.966 A:middle
and also in Swift, where we can
also see that we nest them just


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:54.556 --> 00:14:00.966 A:middle
and also in Swift, where we can
also see that we nest them just

00:14:00.966 --> 00:14:04.036 A:middle
like their integral
cousins, so that using them

00:14:04.036 --> 00:14:06.166 A:middle
in Swift 3 is both
natural and expressive.

00:14:06.896 --> 00:14:10.036 A:middle
Now another common Foundation
design pattern is associating

00:14:10.036 --> 00:14:10.876 A:middle
state with a type.

00:14:11.226 --> 00:14:14.066 A:middle
For instance, the
standardUserDefaults.

00:14:14.886 --> 00:14:16.106 A:middle
Now, of course, Swift support

00:14:16.106 --> 00:14:19.516 A:middle
for class properties are
a great fit for this idea,

00:14:20.126 --> 00:14:22.956 A:middle
and new in this year, we
have brought class properties

00:14:22.956 --> 00:14:25.266 A:middle
to Objective-C, and
they're declared just

00:14:25.266 --> 00:14:26.476 A:middle
like instance properties,

00:14:26.786 --> 00:14:29.446 A:middle
except we now accept
this fancy class keyword,

00:14:29.796 --> 00:14:33.536 A:middle
and because we know that
it's a class property,

00:14:33.536 --> 00:14:35.286 A:middle
we no longer need to
import it as a func

00:14:35.286 --> 00:14:36.506 A:middle
as we did in Swift 2.2.

00:14:36.696 --> 00:14:40.316 A:middle
It can now appear as a class
property, just as you would

00:14:40.316 --> 00:14:41.946 A:middle
if you were defining
this natively in Swift.

00:14:43.036 --> 00:14:44.836 A:middle
But we didn't stop there.

00:14:44.836 --> 00:14:48.266 A:middle
There's some redundant
words here, and in Swift 3,

00:14:48.266 --> 00:14:50.976 A:middle
we overhauled the way that
Swift code is manifested,

00:14:50.976 --> 00:14:53.066 A:middle
or Objective-C code
is manifest in Swift,

00:14:53.366 --> 00:14:56.556 A:middle
so that our final API could
look a little more like this.

00:14:57.106 --> 00:15:00.166 A:middle
We know it's our user defaults,
and by helping Foundation grow


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:57.106 --> 00:15:00.166 A:middle
We know it's our user defaults,
and by helping Foundation grow

00:15:00.166 --> 00:15:02.346 A:middle
to be more Swift-like, we've
achieved great benefits

00:15:02.346 --> 00:15:04.026 A:middle
for both Objective-C and Swift.

00:15:04.516 --> 00:15:08.896 A:middle
Now Tony mentioned many
Foundation types deserve

00:15:08.896 --> 00:15:11.316 A:middle
to be value types, and so I'm
going to talk about a few.

00:15:11.526 --> 00:15:13.986 A:middle
We'll start with Date.

00:15:14.356 --> 00:15:16.396 A:middle
Now let's suppose we want
to schedule a reminder

00:15:16.396 --> 00:15:17.766 A:middle
for when we should go home.

00:15:17.816 --> 00:15:21.336 A:middle
We'll start with Swift 2.2,
just to motivate our example.

00:15:21.616 --> 00:15:23.486 A:middle
Let's suppose that we have
a function that can answer

00:15:23.486 --> 00:15:28.486 A:middle
when we need to go home, and we
call it, and five minutes seems

00:15:28.486 --> 00:15:30.776 A:middle
like a good time for our
reminder, so we'll go ahead and,

00:15:31.106 --> 00:15:32.456 A:middle
you know, offset
that a little bit.

00:15:33.236 --> 00:15:35.636 A:middle
Now, it's worth pointing
out, NSDate is

00:15:35.636 --> 00:15:38.746 A:middle
and remains a reference type,
and so there's actually two,

00:15:39.156 --> 00:15:41.356 A:middle
potentially two dynamic
allocations going on here.

00:15:41.796 --> 00:15:43.756 A:middle
One here, and another here.

00:15:44.346 --> 00:15:48.186 A:middle
Now in Swift 3, we gain
access to the Date value type.

00:15:49.206 --> 00:15:50.516 A:middle
So, let's go ahead and use it,

00:15:51.746 --> 00:15:53.106 A:middle
and consuming it
is very similar,

00:15:53.166 --> 00:15:56.446 A:middle
however now this var takes on
a whole new kind of behavior.

00:15:56.946 --> 00:15:59.456 A:middle
We specifically, we now
allow inline mutation.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.326 --> 00:16:01.536 A:middle
And so, we've done zero,

00:16:02.056 --> 00:16:04.556 A:middle
these two examples here are
doing the exact same thing,

00:16:04.556 --> 00:16:08.076 A:middle
except with the value
type we've done no extra

00:16:08.076 --> 00:16:09.166 A:middle
dynamic allocations.

00:16:09.466 --> 00:16:10.556 A:middle
Let's continue our example.

00:16:10.886 --> 00:16:12.836 A:middle
Now, of course, we can
do this inline as well.

00:16:12.836 --> 00:16:17.336 A:middle
Now, with reminders, it's
only really meaningful

00:16:17.336 --> 00:16:19.486 A:middle
to schedule them if
they haven't happened,

00:16:20.076 --> 00:16:21.986 A:middle
and one of the great
things that Swift brings

00:16:21.986 --> 00:16:25.156 A:middle
to the table is automatic
conformance to protocols

00:16:25.156 --> 00:16:29.066 A:middle
when you satisfy certain
criteria, and so in this case,

00:16:29.066 --> 00:16:31.606 A:middle
Date Auto has conforms
to comparable,

00:16:31.756 --> 00:16:33.486 A:middle
which gives us access
to the less

00:16:33.536 --> 00:16:35.816 A:middle
than operator, which we use now.

00:16:36.336 --> 00:16:38.276 A:middle
And we can go ahead
and schedule our timer,

00:16:38.276 --> 00:16:39.426 A:middle
but first we need to create it.

00:16:39.486 --> 00:16:41.996 A:middle
And so we'll use another new
Foundation API this year,

00:16:42.356 --> 00:16:45.666 A:middle
which is this fancy
closure-based timer API,

00:16:46.286 --> 00:16:48.356 A:middle
where we initialize the
timer with a closure.

00:16:48.356 --> 00:16:50.556 A:middle
So no more selectors
and targets there,

00:16:50.556 --> 00:16:53.236 A:middle
and we'll schedule it
on our main run loop.

00:16:54.516 --> 00:16:58.606 A:middle
[ Applause ]

00:16:59.106 --> 00:17:00.566 A:middle
I'll also call out thread


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.106 --> 00:17:00.566 A:middle
I'll also call out thread

00:17:00.566 --> 00:17:03.106 A:middle
and run loop have those
as well I believe.

00:17:03.106 --> 00:17:06.046 A:middle
And we schedule them on our
main run loop and we're done.

00:17:06.476 --> 00:17:08.066 A:middle
And this is a great
example of how all

00:17:08.066 --> 00:17:10.546 A:middle
of these familiar Foundation
APIs really can come

00:17:10.546 --> 00:17:12.215 A:middle
across so beautifully
in Swift 3.

00:17:12.856 --> 00:17:14.965 A:middle
This is some of the most
Foundationy code I could

00:17:14.965 --> 00:17:16.106 A:middle
possibly have in a demo.

00:17:16.106 --> 00:17:18.056 A:middle
I have a run loop, I have
a timer and some dates.

00:17:18.236 --> 00:17:19.986 A:middle
I just, there's only
a few other things,

00:17:19.986 --> 00:17:21.425 A:middle
and this is pretty
much all of Foundation.

00:17:21.566 --> 00:17:23.606 A:middle
And there isn't a
square bracket in sight.

00:17:25.606 --> 00:17:27.756 A:middle
So, another new example,
or another new type

00:17:27.846 --> 00:17:30.226 A:middle
in Foundation is the
measurement value type.

00:17:31.156 --> 00:17:33.456 A:middle
And let's suppose with
a new example here,

00:17:33.456 --> 00:17:34.956 A:middle
we care about how
long our commute is,

00:17:34.956 --> 00:17:37.876 A:middle
and we're lucky enough to
live two short streets away

00:17:37.876 --> 00:17:38.646 A:middle
from where we work.

00:17:39.386 --> 00:17:40.656 A:middle
Now, measurements
are value types,

00:17:40.656 --> 00:17:43.046 A:middle
and Swift supports
operator overloading,

00:17:43.376 --> 00:17:44.806 A:middle
and not only are they
value types, though.

00:17:45.036 --> 00:17:47.306 A:middle
They're mathematical in
nature, and so it makes sense

00:17:47.306 --> 00:17:50.796 A:middle
to specify operators on them.

00:17:50.796 --> 00:17:54.646 A:middle
No one will look the other
way, or make a sour face

00:17:54.646 --> 00:17:57.116 A:middle
if we contemplate
adding them together,

00:17:57.116 --> 00:18:00.636 A:middle
and so we can compute their sum,
and we can even convert them


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:57.116 --> 00:18:00.636 A:middle
and so we can compute their sum,
and we can even convert them

00:18:00.636 --> 00:18:01.786 A:middle
to a different kind of unit.

00:18:01.786 --> 00:18:04.376 A:middle
And let's suppose we were
curious how long it took

00:18:04.376 --> 00:18:05.256 A:middle
for us to get to work.

00:18:05.256 --> 00:18:08.506 A:middle
Well, we could do that as
well, except in Swift 3,

00:18:08.506 --> 00:18:10.996 A:middle
if we were to try to build
this code, it would fail,

00:18:10.996 --> 00:18:13.516 A:middle
and it would fail at
compile time because,

00:18:13.656 --> 00:18:16.526 A:middle
thanks to the power of Swift 3's
generics in type constraints,

00:18:16.916 --> 00:18:19.976 A:middle
we actually have designed this
in a way that the difference

00:18:19.976 --> 00:18:21.826 A:middle
in units is knowable
at compile time,

00:18:22.046 --> 00:18:24.106 A:middle
and so the Swift compiler
can detect us and tell us

00:18:24.146 --> 00:18:25.796 A:middle
that we're trying to do
an invalid conversion.

00:18:26.746 --> 00:18:28.526 A:middle
To learn more about
measurement and units

00:18:28.526 --> 00:18:30.136 A:middle
and the whole new
ecosystem of types

00:18:30.136 --> 00:18:33.346 A:middle
that we've introduced this year,
be sure to check out this talk

00:18:33.346 --> 00:18:35.776 A:middle
on Friday afternoon
to learn more

00:18:35.776 --> 00:18:36.986 A:middle
about measurements and units.

00:18:38.076 --> 00:18:39.926 A:middle
I'm going to switch
to another example.

00:18:40.886 --> 00:18:43.096 A:middle
I did say this was going
to be an adventure.

00:18:43.326 --> 00:18:45.656 A:middle
Suppose we want to
buy some MacBooks.

00:18:45.846 --> 00:18:48.116 A:middle
We'll use the new URL
Component's value type

00:18:48.916 --> 00:18:50.446 A:middle
and we can do this
very expressively.

00:18:51.166 --> 00:18:53.476 A:middle
We'll begin by describing
mutable components,

00:18:53.476 --> 00:18:55.526 A:middle
which we'll use as
a template below.

00:18:55.826 --> 00:18:57.656 A:middle
And we iterate through
the products that we want

00:18:57.696 --> 00:19:02.856 A:middle
to purchase, make a copy of
our template, and then mutate


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.696 --> 00:19:02.856 A:middle
to purchase, make a copy of
our template, and then mutate

00:19:02.856 --> 00:19:06.176 A:middle
that copy, specifying the
product that we wish to buy.

00:19:07.046 --> 00:19:07.766 A:middle
Note that we're safe

00:19:07.766 --> 00:19:09.756 A:middle
to explicitly unwrap
this optional here,

00:19:10.146 --> 00:19:13.256 A:middle
because we specified that it was
non-nill in our template above.

00:19:14.466 --> 00:19:16.956 A:middle
We can go ahead and
print our URLs and we see

00:19:16.956 --> 00:19:21.136 A:middle
that we have been able to build,
you know, the URLs that we'd

00:19:21.136 --> 00:19:26.606 A:middle
like to purchase with no
memory management whatsoever.

00:19:26.926 --> 00:19:29.276 A:middle
All we had to do was
declare our intent, whether

00:19:29.276 --> 00:19:31.576 A:middle
or not something was mutable or
not, and the language took care

00:19:31.576 --> 00:19:33.766 A:middle
of the rest of the
details for us.

00:19:34.676 --> 00:19:37.106 A:middle
Now, another thing
that Swift 3 brings,

00:19:37.216 --> 00:19:38.286 A:middle
or Swift in general brings

00:19:38.286 --> 00:19:40.126 A:middle
to the table is protocol
components.

00:19:40.126 --> 00:19:42.506 A:middle
In many Foundation
types, like Date,

00:19:42.706 --> 00:19:46.516 A:middle
getting useful new capabilities
thanks to new conformances.

00:19:46.716 --> 00:19:48.136 A:middle
For instance, CharacterSet

00:19:48.136 --> 00:19:51.236 A:middle
and IndexSet are now
conformed to SetAlgebra.

00:19:51.496 --> 00:19:54.206 A:middle
So you can union, intersect, and
symmetric difference these guys

00:19:54.206 --> 00:19:55.106 A:middle
to your hearts' content.

00:19:56.356 --> 00:19:59.006 A:middle
Data is also now a
MutableCollection,

00:19:59.296 --> 00:20:02.776 A:middle
MutableRandomAccessCollection
of unsigned eight-bit integers,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.296 --> 00:20:02.776 A:middle
MutableRandomAccessCollection
of unsigned eight-bit integers,

00:20:03.466 --> 00:20:06.526 A:middle
but, like you always
thought it was.

00:20:06.806 --> 00:20:08.546 A:middle
Let's look at some of the
things we can do with some

00:20:08.546 --> 00:20:09.926 A:middle
of Data's new conformances.

00:20:11.016 --> 00:20:13.236 A:middle
First we're going to need
some data, and I happen

00:20:13.236 --> 00:20:15.456 A:middle
to have some base64
data lying around,

00:20:15.616 --> 00:20:17.656 A:middle
which we'll parse using
the normal initializer.

00:20:18.476 --> 00:20:23.796 A:middle
In the explicit unwrap here
is, I know it's safe to do this

00:20:23.826 --> 00:20:25.126 A:middle
because this is a demo,

00:20:25.126 --> 00:20:26.546 A:middle
and I know that that's
valid base64 [laughter].

00:20:26.546 --> 00:20:31.446 A:middle
You should probably use a
try there if you do this

00:20:31.446 --> 00:20:35.376 A:middle
for yourself, but let's say,
you know, I like statistics

00:20:35.376 --> 00:20:36.826 A:middle
and the nice thing to look

00:20:36.826 --> 00:20:38.546 A:middle
at when you have
statistics is a histogram.

00:20:38.546 --> 00:20:39.416 A:middle
That's always a good
thing to start.

00:20:39.416 --> 00:20:40.426 A:middle
So we're going to
build a histogram.

00:20:40.646 --> 00:20:42.126 A:middle
We'll use as our
backing storage,

00:20:42.126 --> 00:20:44.806 A:middle
we'll use a native Swift array,
which will initialize to zero,

00:20:44.996 --> 00:20:48.466 A:middle
and we'll just use the byte
value of each byte in the data

00:20:48.466 --> 00:20:51.216 A:middle
as the index and maintain
a frequency count.

00:20:52.046 --> 00:20:54.696 A:middle
So let's, because Data
is a collection iterating

00:20:54.696 --> 00:20:58.026 A:middle
through its bytes, is natural
and expressive, which we can do

00:20:58.026 --> 00:21:01.066 A:middle
with a four N loop, and so
we'll produce our histogram.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.026 --> 00:21:01.066 A:middle
with a four N loop, and so
we'll produce our histogram.

00:21:01.066 --> 00:21:01.856 A:middle
And let's take a look.

00:21:01.856 --> 00:21:04.636 A:middle
Well that definitely
looks like a histogram,

00:21:04.896 --> 00:21:07.076 A:middle
and like all histograms,
there's signal and noise,

00:21:07.076 --> 00:21:09.216 A:middle
and I'm seeing a lot of high
frequency data in there,

00:21:09.856 --> 00:21:11.436 A:middle
and I'd like to filter that out,

00:21:11.726 --> 00:21:14.536 A:middle
and luckily Data's a collection
now, and so we gain access

00:21:14.536 --> 00:21:16.396 A:middle
to things like Map,
Reduce, and Filter,

00:21:16.396 --> 00:21:19.106 A:middle
and all of your other
favorite collection functions.

00:21:19.656 --> 00:21:21.606 A:middle
And so, let's say we wanted
to remove all the data

00:21:21.606 --> 00:21:23.486 A:middle
that was greater than three.

00:21:23.786 --> 00:21:25.996 A:middle
It's as simple as
specifying a predicate now,

00:21:26.436 --> 00:21:29.666 A:middle
and we can generate
our new filtered data.

00:21:30.666 --> 00:21:33.306 A:middle
And also as a collection,
Data is sliceable,

00:21:33.816 --> 00:21:37.156 A:middle
and these slices work just
like the mutable collections,

00:21:37.326 --> 00:21:38.256 A:middle
or value type collections

00:21:38.256 --> 00:21:40.306 A:middle
that you're already
accustomed to in Swift.

00:21:41.456 --> 00:21:44.456 A:middle
Mutating them invokes the
same copy on write machinery

00:21:44.456 --> 00:21:48.166 A:middle
that Tony described earlier and
they work just the same way.

00:21:49.826 --> 00:21:53.426 A:middle
Now, Data also remains
extensible through inheritance

00:21:53.426 --> 00:21:54.946 A:middle
of the underlying
reference type,

00:21:55.176 --> 00:21:57.866 A:middle
and that's a very big sentence,
so I'll walk through an example

00:21:57.866 --> 00:21:59.636 A:middle
to show what I mean by that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.056 --> 00:22:01.346 A:middle
As an example, let's go ahead

00:22:01.346 --> 00:22:04.106 A:middle
and create a custom
NSData subclass

00:22:04.426 --> 00:22:05.676 A:middle
that allocates no storage,

00:22:05.906 --> 00:22:08.446 A:middle
but represents a virtual
collection of all ones.

00:22:09.116 --> 00:22:10.556 A:middle
We'll call it an AllOnesData.

00:22:10.806 --> 00:22:11.556 A:middle
Very descriptive.

00:22:11.556 --> 00:22:14.006 A:middle
And I'm only going to show the
implementation a single method

00:22:14.006 --> 00:22:17.916 A:middle
here, specifically
getBytes, wherein the promise

00:22:17.916 --> 00:22:20.596 A:middle
of this class is more
or less fulfilled.

00:22:20.736 --> 00:22:21.976 A:middle
We set all the bytes to one.

00:22:22.436 --> 00:22:26.016 A:middle
So we don't need to store
anything, and let's go ahead

00:22:26.016 --> 00:22:27.936 A:middle
and create a read-only
instance of this.

00:22:28.496 --> 00:22:30.116 A:middle
But we won't just
use the reference.

00:22:30.116 --> 00:22:33.906 A:middle
We're actually going
to create a value type

00:22:33.906 --> 00:22:35.636 A:middle
that wraps the reference
type here.

00:22:35.926 --> 00:22:39.546 A:middle
And using that, we just use
the new initializer for Data,

00:22:39.546 --> 00:22:41.786 A:middle
and it works exactly the
way you would expect.

00:22:42.536 --> 00:22:46.226 A:middle
We have a ones value type that's
now pointing to the reference

00:22:46.226 --> 00:22:47.946 A:middle
of all ones, and those
ones are virtual.

00:22:47.946 --> 00:22:50.306 A:middle
They don't actually consume
bytes in memory currently.

00:22:50.626 --> 00:22:53.106 A:middle
Let's go ahead and create
a mutable copy, and again,

00:22:53.236 --> 00:22:56.156 A:middle
we've not done any mutation,
so we don't need to allocate

00:22:56.156 --> 00:22:58.266 A:middle
or manifest any of those
bytes in memory currently.

00:22:59.096 --> 00:23:01.646 A:middle
But let's get ready to mutate
those bytes, and to do that,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.096 --> 00:23:01.646 A:middle
But let's get ready to mutate
those bytes, and to do that,

00:23:01.646 --> 00:23:04.146 A:middle
we're going to actually use
another new Foundation API this

00:23:04.146 --> 00:23:07.646 A:middle
year, which is the
Scoped Pointer Accessor,

00:23:08.626 --> 00:23:10.856 A:middle
called withUnsafe MutableBytes.

00:23:11.046 --> 00:23:13.456 A:middle
And this is much better than
just calling mutable bytes

00:23:13.456 --> 00:23:18.646 A:middle
on the data itself, because
we're scoping the access

00:23:18.646 --> 00:23:20.886 A:middle
to those bytes within the
closure that we're specifying,

00:23:21.236 --> 00:23:23.956 A:middle
which it makes it very easy to
reason about where, you know,

00:23:23.956 --> 00:23:25.446 A:middle
you don't have pointers
just flying around.

00:23:25.446 --> 00:23:27.536 A:middle
Pointers are only going to
be in these little accessors.

00:23:28.596 --> 00:23:31.916 A:middle
And so we actually perform our
mutation, invoking the copy

00:23:31.916 --> 00:23:34.066 A:middle
on right machinery, and
those bytes are now,

00:23:34.176 --> 00:23:38.966 A:middle
the copies bytes are now
manifested memory for reals.

00:23:39.066 --> 00:23:40.036 A:middle
Let's move on to
another example.

00:23:40.036 --> 00:23:41.296 A:middle
I'm tired of talking about Data.

00:23:42.006 --> 00:23:47.216 A:middle
Let's talk about, URLs
and URL properties.

00:23:47.546 --> 00:23:49.866 A:middle
Now to motivate this
example, I want to talk first

00:23:49.866 --> 00:23:53.146 A:middle
about how we did
this in Swift 2.2.

00:23:53.146 --> 00:23:56.456 A:middle
So in Swift 2.2, we would
ask for a NSURL file URL,

00:23:56.456 --> 00:23:58.626 A:middle
we're going to talk about by
special file, and this file is

00:23:58.626 --> 00:24:01.336 A:middle
so special, I keep it at
the root of my file system.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.626 --> 00:24:01.336 A:middle
so special, I keep it at
the root of my file system.

00:24:02.086 --> 00:24:03.676 A:middle
And I'm curious about
three properties.

00:24:03.676 --> 00:24:06.966 A:middle
I care about the creation date,
whether or not it's regular,

00:24:07.306 --> 00:24:10.016 A:middle
and for some reason, the
maximum file size for the volume

00:24:10.016 --> 00:24:11.186 A:middle
that this file's located on.

00:24:11.866 --> 00:24:14.116 A:middle
And these are just strings
in Swift 2.2 and you just,

00:24:14.116 --> 00:24:15.646 A:middle
this is just an array
of strings.

00:24:16.036 --> 00:24:18.426 A:middle
And when I ask my URL
for its resource values,

00:24:18.426 --> 00:24:21.516 A:middle
I just get a regular dictionary,
and there's no type information.

00:24:21.516 --> 00:24:25.016 A:middle
It's just a string to an
object, which means consuming

00:24:25.016 --> 00:24:29.676 A:middle
that result requires a lot of
as is typing, and so I have to,

00:24:29.676 --> 00:24:31.086 A:middle
you know, suggest
that it's a Boolean,

00:24:31.086 --> 00:24:32.376 A:middle
and suggest that
it's an integer,

00:24:32.376 --> 00:24:35.246 A:middle
and I'm constantly consulting
the references to make sure

00:24:35.246 --> 00:24:38.696 A:middle
that I'm getting it right, and
further, mutation is also just

00:24:38.696 --> 00:24:39.826 A:middle
in terms of the dictionary.

00:24:40.336 --> 00:24:45.236 A:middle
And so you can do
absurd things like this,

00:24:45.366 --> 00:24:48.206 A:middle
and it's every failure is
going to a runtime failure.

00:24:49.166 --> 00:24:51.126 A:middle
So, let's see how this
gets better in Swift 3.

00:24:51.796 --> 00:24:55.416 A:middle
In Swift 3, creating
the URL is similar,

00:24:55.416 --> 00:24:59.006 A:middle
but we no longer use a
class factory method.

00:24:59.006 --> 00:25:02.626 A:middle
This is moved into a
regular initializer syntax.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.006 --> 00:25:02.626 A:middle
This is moved into a
regular initializer syntax.

00:25:03.456 --> 00:25:05.036 A:middle
We're still talking
about my special file,

00:25:05.996 --> 00:25:09.656 A:middle
and instead of asking with an
array of strings we're going

00:25:09.656 --> 00:25:11.966 A:middle
to use those new strongly
typed string enumerations

00:25:11.966 --> 00:25:14.566 A:middle
that I mentioned earlier, and
we'll produce a set of them,

00:25:14.566 --> 00:25:17.546 A:middle
and when we ask the URL
for the resource values,

00:25:17.546 --> 00:25:19.296 A:middle
no longer are we going
to get a dictionary,

00:25:19.606 --> 00:25:21.876 A:middle
but instead we're
going to get a value,

00:25:21.966 --> 00:25:24.326 A:middle
a new Foundation value
type, and let's see what

00:25:24.326 --> 00:25:26.746 A:middle
that Foundation value type
is for the three properties

00:25:26.776 --> 00:25:28.296 A:middle
that we're asking
about right now.

00:25:29.346 --> 00:25:31.476 A:middle
As you can see, creation
date is a Date,

00:25:31.846 --> 00:25:33.176 A:middle
its regular file is a Bool,

00:25:33.176 --> 00:25:35.366 A:middle
and volume maximum file
size is an integer.

00:25:35.796 --> 00:25:38.686 A:middle
And it's also worth pointing

00:25:38.686 --> 00:25:42.396 A:middle
out that the URLResourceValue
struct itself is lazy.

00:25:42.396 --> 00:25:45.626 A:middle
It's still implemented in terms
of the dictionary that was done

00:25:45.626 --> 00:25:48.606 A:middle
in the Swift 2 API, so we're not
necessarily this giant struct

00:25:48.746 --> 00:25:51.176 A:middle
of things that are
going to consume memory.

00:25:51.176 --> 00:25:52.926 A:middle
It's still going to be,
I asked for three things,

00:25:52.926 --> 00:25:54.356 A:middle
I get potentially
three things back.

00:25:54.746 --> 00:25:56.246 A:middle
And further, if you
have custom keys,

00:25:56.246 --> 00:25:58.356 A:middle
the dictionary is still here,
but no longer are you going

00:25:58.356 --> 00:25:59.676 A:middle
to ask for a string,
you're going to ask

00:25:59.676 --> 00:26:01.576 A:middle
for the URL resource key
that you're interested in.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.676 --> 00:26:01.576 A:middle
for the URL resource key
that you're interested in.

00:26:02.656 --> 00:26:04.836 A:middle
Now, you might be noticing
there's a lot of question marks

00:26:04.836 --> 00:26:07.276 A:middle
and the reason why is, well,
there's two reasons why.

00:26:07.276 --> 00:26:09.056 A:middle
The first is that you
didn't ask for it.

00:26:09.366 --> 00:26:11.616 A:middle
So, if you didn't ask for the
creation date it won't be there,

00:26:11.616 --> 00:26:13.776 A:middle
and that again, goes back to
that sparseness of the data.

00:26:14.256 --> 00:26:16.246 A:middle
The second reason why
it might not be there is

00:26:16.246 --> 00:26:20.526 A:middle
that the property itself might
be failable, and as an example

00:26:20.526 --> 00:26:21.796 A:middle
of VolumeMaximumFileSize.

00:26:22.066 --> 00:26:24.266 A:middle
Let's look at two
examples of how that works.

00:26:25.536 --> 00:26:28.916 A:middle
So because we asked for regular
file, we're entirely justified

00:26:28.916 --> 00:26:30.686 A:middle
to explicitly unwrap
our optional here.

00:26:30.686 --> 00:26:31.576 A:middle
It will be there.

00:26:31.576 --> 00:26:32.586 A:middle
We asked for it.

00:26:32.696 --> 00:26:35.696 A:middle
However, the documentation
for VolumeMaximumFileSize says

00:26:35.696 --> 00:26:38.676 A:middle
that not all volumes and not all
file systems support a maximum

00:26:38.676 --> 00:26:41.206 A:middle
file system size, and so
it might not be there.

00:26:41.416 --> 00:26:45.336 A:middle
And as a perfect example of a
time to use the if let construct

00:26:45.336 --> 00:26:47.686 A:middle
in Swift, to conditionally
set that local variable.

00:26:47.686 --> 00:26:51.226 A:middle
Now, let's talk about mutation.

00:26:51.396 --> 00:26:54.446 A:middle
Of course, the mutation
API now for the URLs

00:26:54.446 --> 00:26:57.176 A:middle
in URLResourceValues is in
terms of its new value type,

00:26:57.516 --> 00:26:58.776 A:middle
and so when you try
to, you know,

00:26:58.776 --> 00:27:00.986 A:middle
even though this is my special
file, and I'm trying very hard


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.776 --> 00:27:00.986 A:middle
even though this is my special
file, and I'm trying very hard

00:27:00.986 --> 00:27:04.236 A:middle
to say that it's not regular,
the compiler will catch me

00:27:04.236 --> 00:27:06.246 A:middle
at compile time instead
of letting me discover

00:27:06.246 --> 00:27:07.286 A:middle
that problem at run time.

00:27:07.856 --> 00:27:12.386 A:middle
And further, the creation date
is strongly typed as a Date,

00:27:12.386 --> 00:27:14.676 A:middle
and so something absurd
like this might work

00:27:14.676 --> 00:27:16.856 A:middle
with Siri, can't work with code.

00:27:17.466 --> 00:27:20.396 A:middle
Now the last thing
I want to talk

00:27:20.396 --> 00:27:23.076 A:middle
about on this Foundation
adventure is I want to talk

00:27:23.076 --> 00:27:24.746 A:middle
about Swift's native
enumerations.

00:27:24.956 --> 00:27:27.576 A:middle
And we're going to talk about
data again one more time,

00:27:27.576 --> 00:27:29.136 A:middle
because there's a
really good example.

00:27:30.256 --> 00:27:32.686 A:middle
When data takes ownership
of an UnsafeMutablePointer,

00:27:32.856 --> 00:27:35.116 A:middle
you have the option of
specifying a deallocator.

00:27:36.636 --> 00:27:38.456 A:middle
Data supports many
of these by default,

00:27:38.456 --> 00:27:43.426 A:middle
and including the option to
specify a custom deallocator.

00:27:44.256 --> 00:27:49.106 A:middle
Now, Swift supports
associated values with enums

00:27:49.106 --> 00:27:50.616 A:middle
and oftentimes you'll
see these with, you know,

00:27:50.616 --> 00:27:52.996 A:middle
integers where you can do case
expressions and stuff like that

00:27:52.996 --> 00:27:56.206 A:middle
to be able to, you know, do
really cool pattern matching

00:27:56.206 --> 00:27:57.586 A:middle
with it, but here
we're taking a closure,

00:27:57.966 --> 00:28:00.526 A:middle
because we actually want
to wrap the behavior


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:57.966 --> 00:28:00.526 A:middle
because we actually want
to wrap the behavior

00:28:00.526 --> 00:28:01.486 A:middle
that you want to provide.

00:28:01.746 --> 00:28:03.066 A:middle
Let's see this in action.

00:28:03.216 --> 00:28:04.966 A:middle
We'll start simple
with a malloc case.

00:28:05.296 --> 00:28:07.256 A:middle
Of course, you can
still malloc in Swift,

00:28:07.256 --> 00:28:10.316 A:middle
although you probably don't
see it in a slide very often.

00:28:10.536 --> 00:28:14.986 A:middle
So, you malloc, and when you
hand this pointer off to Data,

00:28:15.216 --> 00:28:17.036 A:middle
you can, you'll deallocate
it with free,

00:28:17.116 --> 00:28:20.796 A:middle
and the syntax there
is just simple

00:28:20.856 --> 00:28:23.156 A:middle
as using the integration
values themselves.

00:28:23.526 --> 00:28:24.826 A:middle
Let's look at a custom example.

00:28:24.936 --> 00:28:27.026 A:middle
Let's suppose we have a
function that allows us

00:28:27.026 --> 00:28:30.156 A:middle
to create glorious pointers,
which we want to make sure we

00:28:30.156 --> 00:28:32.446 A:middle
that we free gloriously,
lest they be offended,

00:28:32.826 --> 00:28:35.606 A:middle
and so we can specify the custom
deallocator, it's as simple

00:28:35.606 --> 00:28:38.596 A:middle
as providing a closure
and making sure

00:28:38.596 --> 00:28:40.186 A:middle
that you do the custom
thing that you like to do.

00:28:40.186 --> 00:28:45.656 A:middle
And this is really powerful, and
really powerful concept or idea

00:28:45.656 --> 00:28:46.976 A:middle
for framework developers,

00:28:47.246 --> 00:28:50.836 A:middle
because in other languages
we would have needed

00:28:50.836 --> 00:28:52.886 A:middle
to provide a second
function pointer-based API,

00:28:53.256 --> 00:28:57.566 A:middle
but now in Swift 3, we can
provide a single enum-based API

00:28:57.566 --> 00:29:00.096 A:middle
that expresses all of
these ideas very cleanly,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:57.566 --> 00:29:00.096 A:middle
that expresses all of
these ideas very cleanly,

00:29:00.476 --> 00:29:01.166 A:middle
and expressively.

00:29:02.386 --> 00:29:04.276 A:middle
And so that concludes our
API adventure for now.

00:29:04.586 --> 00:29:06.416 A:middle
Hopefully we saw a great
many wonders, and I'm going

00:29:06.416 --> 00:29:07.376 A:middle
to hand things back to Tony

00:29:07.376 --> 00:29:08.646 A:middle
to talk a little
more about adoption.

00:29:09.516 --> 00:29:15.746 A:middle
[ Applause ]

00:29:16.246 --> 00:29:16.686 A:middle
&gt;&gt; Thanks Michael.

00:29:17.216 --> 00:29:21.026 A:middle
All right, now you've seen just
a little bit of what's possible.

00:29:21.676 --> 00:29:23.616 A:middle
Let's talk about how you
can use it in your app.

00:29:24.986 --> 00:29:26.656 A:middle
First, let's talk
about bridging.

00:29:27.046 --> 00:29:29.066 A:middle
So, keeping with this theme
of iterative improvement,

00:29:29.486 --> 00:29:31.036 A:middle
we've extended the
exact same concept

00:29:31.036 --> 00:29:33.716 A:middle
that you're already familiar
with from Swift 2 for bridging

00:29:33.716 --> 00:29:36.976 A:middle
between Objective-C and Swift,
so if you understand how String

00:29:36.976 --> 00:29:38.726 A:middle
and NSString are
bridged, we've extended

00:29:38.726 --> 00:29:40.786 A:middle
that exact same concepts
for Data and NSData

00:29:40.786 --> 00:29:42.666 A:middle
and all the other value
types that you see here.

00:29:43.916 --> 00:29:47.466 A:middle
That means that all
of the imported API

00:29:47.506 --> 00:29:50.696 A:middle
from Cocoa SDK is going to
use these new value types,

00:29:51.136 --> 00:29:54.586 A:middle
and that's a key part of how we
achieve this idea of leverage.

00:29:55.126 --> 00:29:59.346 A:middle
So for example, in
AppKit in Swift 2.2,

00:29:59.556 --> 00:30:02.246 A:middle
you'll see this class called
NSDatePicker, which let's,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.556 --> 00:30:02.246 A:middle
you'll see this class called
NSDatePicker, which let's,

00:30:02.746 --> 00:30:06.466 A:middle
presents a UI to allow your
user to pick a date and it has,

00:30:06.536 --> 00:30:09.176 A:middle
among others, two properties
for controlling those dates

00:30:09.476 --> 00:30:11.406 A:middle
and you see here their
marked as @NSCopying,

00:30:11.676 --> 00:30:13.616 A:middle
and also NSDate reference types.

00:30:15.016 --> 00:30:17.146 A:middle
In Swift 3, with no
change to AppKit,

00:30:17.536 --> 00:30:19.306 A:middle
just by making these
changes in Foundation,

00:30:19.666 --> 00:30:20.766 A:middle
this class looks like this.

00:30:20.926 --> 00:30:23.746 A:middle
You see we've got the struct
date type, and we no longer need

00:30:23.746 --> 00:30:27.126 A:middle
to mark this as @NSCopying
because they're value types,

00:30:27.186 --> 00:30:28.756 A:middle
and we handle the
copying for you.

00:30:29.366 --> 00:30:34.666 A:middle
Now there can be a performance
cost for crossing this bridge

00:30:34.846 --> 00:30:37.916 A:middle
and to explain what that is, I'd
like to dive into some details

00:30:37.916 --> 00:30:39.546 A:middle
on how the bridging
actually works.

00:30:39.856 --> 00:30:42.796 A:middle
We have two major strategies for
bridging, one for large types,

00:30:42.886 --> 00:30:45.416 A:middle
which hold a reference, and
a second for small types,

00:30:45.556 --> 00:30:46.646 A:middle
which create a reference.

00:30:47.356 --> 00:30:51.106 A:middle
So, for example, we're
going back to data.

00:30:51.186 --> 00:30:53.496 A:middle
Here I've created data
again, and you see a struct

00:30:53.536 --> 00:30:54.716 A:middle
that wraps a reference type.

00:30:55.246 --> 00:30:58.326 A:middle
Now, if I call some
Objective-C API, what happens is

00:30:58.326 --> 00:31:01.106 A:middle
that we hand the reference
over to the Objective-C side.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.326 --> 00:31:01.106 A:middle
that we hand the reference
over to the Objective-C side.

00:31:01.486 --> 00:31:02.216 A:middle
That's because, of course,

00:31:02.216 --> 00:31:03.866 A:middle
Objective-C doesn't
deal with struct Data.

00:31:03.866 --> 00:31:05.466 A:middle
It only understands NSData.

00:31:05.966 --> 00:31:07.996 A:middle
Now, in this case perhaps
a synchronous method call,

00:31:08.326 --> 00:31:10.616 A:middle
that Objective-C code isn't
going to hold onto that data

00:31:10.616 --> 00:31:11.636 A:middle
for any period of time.

00:31:11.636 --> 00:31:13.266 A:middle
It may access it, and
then forget about it.

00:31:13.436 --> 00:31:15.206 A:middle
So, just holding the reference

00:31:15.206 --> 00:31:16.476 A:middle
for a short period
of time is enough.

00:31:17.066 --> 00:31:20.106 A:middle
On the other hand, you'll see
many APIs that, for example,

00:31:20.106 --> 00:31:23.436 A:middle
take a data for longer period
of time, usually marked

00:31:23.436 --> 00:31:25.926 A:middle
as properties that have
the copying attribute.

00:31:26.916 --> 00:31:28.766 A:middle
In that case, in Objective-C,

00:31:29.126 --> 00:31:31.646 A:middle
this Objective-C code will
call copy on that data,

00:31:32.106 --> 00:31:33.876 A:middle
and that's because it
needs to protect itself

00:31:33.876 --> 00:31:36.066 A:middle
from any potential mutation
that happens to that data

00:31:36.066 --> 00:31:38.286 A:middle
that it just received from
a totally unknown source.

00:31:39.236 --> 00:31:42.436 A:middle
So that means that when crossing
this bridge, a copy can occur.

00:31:43.296 --> 00:31:44.336 A:middle
Let's flip that around
the other way.

00:31:44.526 --> 00:31:45.706 A:middle
Let's say I've got
some Swift code

00:31:45.706 --> 00:31:48.326 A:middle
that is calling an Objective-C
method that returns some data.

00:31:48.846 --> 00:31:50.766 A:middle
Here, the Objective-C
code has, of course,

00:31:50.766 --> 00:31:53.996 A:middle
created the class NSData and
when it's returned to Swift,

00:31:54.746 --> 00:31:57.036 A:middle
we create the struct Data,
which wraps the reference

00:31:57.106 --> 00:31:59.596 A:middle
and it calls copy, for exactly
the same reason as we saw

00:31:59.596 --> 00:32:00.336 A:middle
in the previous slide.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.596 --> 00:32:00.336 A:middle
in the previous slide.

00:32:00.846 --> 00:32:03.206 A:middle
The struct needs to maintain
its control over this copy

00:32:03.206 --> 00:32:06.386 A:middle
so that it can provide the
proper value semantics for you.

00:32:07.776 --> 00:32:10.426 A:middle
Fortunately, almost all data
that you receive this way

00:32:10.426 --> 00:32:11.986 A:middle
from the SDK is immutable,

00:32:12.276 --> 00:32:14.416 A:middle
which means that the copy
is actually just a retain.

00:32:14.606 --> 00:32:16.236 A:middle
However, it is important
to understand

00:32:16.526 --> 00:32:18.846 A:middle
that when crossing this
bridge, a copy may occur.

00:32:19.966 --> 00:32:23.456 A:middle
For small types, like Date, you
can see there is no reference.

00:32:23.516 --> 00:32:24.866 A:middle
We saw earlier the
implementation,

00:32:24.866 --> 00:32:25.486 A:middle
just had a double.

00:32:25.996 --> 00:32:30.366 A:middle
So, in Swift, if we call an
Objective-C function, or method,

00:32:30.906 --> 00:32:34.766 A:middle
which takes a date, then we
have to allocate an NSDate

00:32:34.766 --> 00:32:37.296 A:middle
on the bridging, and
that's again, of course,

00:32:37.296 --> 00:32:38.836 A:middle
because the Objective-C
code only knows how

00:32:38.836 --> 00:32:39.726 A:middle
to deal with references.

00:32:40.236 --> 00:32:42.886 A:middle
Now, we do a lot of tricks in
Objective-C to make allocation

00:32:42.886 --> 00:32:44.786 A:middle
of things like NSDates
really cheap.

00:32:45.156 --> 00:32:46.906 A:middle
However, it is important
to understand

00:32:46.906 --> 00:32:48.976 A:middle
that an allocation can
occur on that bridge.

00:32:53.516 --> 00:32:56.016 A:middle
So, we optimize these
sites for use within Swift.

00:32:56.976 --> 00:32:58.916 A:middle
In your code, you should
avoid crossing back and forth

00:32:58.916 --> 00:33:00.776 A:middle
over that bridge repeatedly.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.916 --> 00:33:00.776 A:middle
over that bridge repeatedly.

00:33:01.826 --> 00:33:04.206 A:middle
This is because we wanted our
code to be safe by default,

00:33:04.656 --> 00:33:07.186 A:middle
but it does mean that there
is a potential copy there.

00:33:07.186 --> 00:33:08.846 A:middle
So, something to be aware
of when you're looking

00:33:08.846 --> 00:33:10.216 A:middle
at adopting these
new value types.

00:33:10.666 --> 00:33:13.326 A:middle
Next, let's talk
about migration.

00:33:14.296 --> 00:33:15.296 A:middle
So, first, some good news.

00:33:16.166 --> 00:33:18.086 A:middle
These new types we're
talking about today exist

00:33:18.086 --> 00:33:19.816 A:middle
for all Swift deployment
targets.

00:33:20.496 --> 00:33:22.026 A:middle
They're part of the
Swift Standard Library,

00:33:22.496 --> 00:33:24.266 A:middle
which means you don't need
to wait for your customers

00:33:24.266 --> 00:33:26.376 A:middle
to upgrade to the newest
versions of our platforms.

00:33:26.826 --> 00:33:29.016 A:middle
As soon as Swift 3 and
S Creator are released,

00:33:29.016 --> 00:33:30.386 A:middle
you can begin using
them immediately.

00:33:31.216 --> 00:33:34.936 A:middle
Now, to help you, we've of
course upgraded the Migrator,

00:33:35.416 --> 00:33:38.706 A:middle
and that means that when you
open your project in Xcode 8,

00:33:38.706 --> 00:33:41.346 A:middle
you'll see a dialog box like
this one, and I recommend

00:33:41.346 --> 00:33:42.156 A:middle
that you click convert.

00:33:42.526 --> 00:33:43.766 A:middle
So, let me show you a few things

00:33:43.986 --> 00:33:45.676 A:middle
that the Migrator
will do for you.

00:33:46.676 --> 00:33:49.616 A:middle
So here we have in
Swift 2.2 some NSDates,

00:33:49.826 --> 00:33:52.886 A:middle
and we're calling a method on
that, dateByAddingtimeInterval.

00:33:53.456 --> 00:33:56.616 A:middle
The Migrator will fix up
the reference type NSDate

00:33:56.616 --> 00:33:58.486 A:middle
into the value type
of struct Date,

00:33:59.206 --> 00:34:00.996 A:middle
and it will change the methods


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.206 --> 00:34:00.996 A:middle
and it will change the methods

00:34:01.216 --> 00:34:02.746 A:middle
because they've changed
according

00:34:02.746 --> 00:34:04.606 A:middle
to our new Swift 3
API Design Guidelines,

00:34:05.016 --> 00:34:07.566 A:middle
both for the reference types
and for the value types.

00:34:08.335 --> 00:34:09.376 A:middle
Here's another example.

00:34:10.085 --> 00:34:12.606 A:middle
Here, I'm creating an
NSDateComponents in Swift 2,

00:34:12.956 --> 00:34:16.496 A:middle
and then setting some of its
properties, and I can do this

00:34:16.496 --> 00:34:19.866 A:middle
because NSDateComponents is an
always mutable reference type.

00:34:20.656 --> 00:34:21.366 A:middle
Now, in Swift 3,

00:34:21.366 --> 00:34:23.235 A:middle
we've introduced a
struct DateComponents.

00:34:23.636 --> 00:34:25.775 A:middle
So the Migrator will change
the reference to the struct,

00:34:26.416 --> 00:34:29.216 A:middle
but also it notices that you're
mutating it, and changes the let

00:34:29.216 --> 00:34:30.446 A:middle
to a var for you as well.

00:34:31.466 --> 00:34:33.505 A:middle
Now the Migrator can
do quite a bit for you,

00:34:33.896 --> 00:34:35.956 A:middle
but there are some places
where if you go back and look

00:34:35.956 --> 00:34:38.596 A:middle
at what it's done, you can do
even better by taking advantage

00:34:38.596 --> 00:34:40.315 A:middle
of some additional things
that we've added for you.

00:34:40.726 --> 00:34:43.536 A:middle
In this case, DateComponents
has a new initializer,

00:34:43.536 --> 00:34:45.186 A:middle
and this is something
we can only do in Swift.

00:34:45.186 --> 00:34:48.545 A:middle
The initializer has
arguments for every property

00:34:48.545 --> 00:34:50.295 A:middle
in the DateComponents,
and they're all optional,

00:34:50.406 --> 00:34:51.505 A:middle
and they all have
default values,

00:34:51.835 --> 00:34:53.966 A:middle
which means that you can create
a DataComponents using only the

00:34:53.966 --> 00:34:56.426 A:middle
values you care about, your
month and day in this case.

00:34:56.696 --> 00:34:58.066 A:middle
And you can change
the var back to a let

00:34:58.176 --> 00:34:59.826 A:middle
because now you don't
need to mutate it

00:34:59.826 --> 00:35:01.386 A:middle
after you've initialized it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.826 --> 00:35:01.386 A:middle
after you've initialized it.

00:35:02.986 --> 00:35:04.656 A:middle
And finally, our
friend data again.

00:35:05.156 --> 00:35:08.036 A:middle
Here in Swift 2, see that I'm
creating an NSMutableData,

00:35:08.206 --> 00:35:10.556 A:middle
the reference type, and
appending some data to it.

00:35:11.846 --> 00:35:14.556 A:middle
In Swift 3, the Migrator
will fix up the method names,

00:35:14.826 --> 00:35:18.196 A:middle
like contentsOf URL,
and appendData,

00:35:19.376 --> 00:35:21.796 A:middle
and it will change NSData
into the struct Data.

00:35:22.246 --> 00:35:24.536 A:middle
However, it's left the
NSMutableData reference

00:35:24.536 --> 00:35:25.006 A:middle
type alone.

00:35:25.526 --> 00:35:28.046 A:middle
In some cases like this, there's
just not enough information

00:35:28.046 --> 00:35:29.066 A:middle
for the Migrator in order

00:35:29.066 --> 00:35:31.236 A:middle
to do what we think is the
best option, so we're going

00:35:31.236 --> 00:35:33.036 A:middle
to leave it as is and
it should still work.

00:35:33.726 --> 00:35:36.176 A:middle
However, if you go back and
do some additional fix ups

00:35:36.176 --> 00:35:38.676 A:middle
on your own, you can
do something cool here.

00:35:38.736 --> 00:35:41.056 A:middle
We can change the
MutableData into a struct Data,

00:35:41.636 --> 00:35:43.516 A:middle
which means that we
change it from let to var.

00:35:43.866 --> 00:35:46.046 A:middle
And we can remove
the options argument

00:35:46.046 --> 00:35:47.426 A:middle
because it has a
default value now.

00:35:48.006 --> 00:35:51.596 A:middle
So, we've talked
about a lot today,

00:35:51.596 --> 00:35:53.316 A:middle
and I'd like to just
briefly recap what we saw.

00:35:54.496 --> 00:35:55.826 A:middle
We believe that these
improvements

00:35:55.826 --> 00:35:58.316 A:middle
to Foundation are going
to benefit the entire SDK

00:35:58.316 --> 00:36:00.486 A:middle
and your whole development
experience in Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:58.316 --> 00:36:00.486 A:middle
and your whole development
experience in Swift.

00:36:01.366 --> 00:36:03.496 A:middle
Partly that was due
to the API renaming,

00:36:03.966 --> 00:36:06.406 A:middle
but we also took the
opportunity to go farther,

00:36:06.596 --> 00:36:08.446 A:middle
and add a brand new
set of value types,

00:36:08.566 --> 00:36:10.426 A:middle
and a lot of new
Swift-specific API.

00:36:11.626 --> 00:36:14.846 A:middle
We see this as the start
of a journey, and we intend

00:36:14.846 --> 00:36:16.886 A:middle
to continue to be this
leverage point in the future.

00:36:16.886 --> 00:36:19.006 A:middle
We're going to make many
improvements over time

00:36:19.006 --> 00:36:22.056 A:middle
to make your Swift apps safer,
faster, and more expressive.

00:36:23.296 --> 00:36:25.406 A:middle
So for more information,
check out this struct URL,

00:36:26.556 --> 00:36:30.186 A:middle
and these related sessions,
including, Going Server-side

00:36:30.186 --> 00:36:31.976 A:middle
with Swift Open Source,
Measurements and Units.

00:36:32.111 --> 00:36:34.111 A:middle
[ Applause ]

00:36:34.206 --> 00:36:34.446 A:middle
Thank you.

00:36:35.508 --> 00:36:37.508 A:middle
[ Applause ]

