WEBVTT

00:00:06.516 --> 00:00:18.500 A:middle
[ Music ]

00:00:22.516 --> 00:00:28.496 A:middle
[ Applause ]

00:00:28.996 --> 00:00:30.296 A:middle
&gt;&gt; Good afternoon,
ladies and gentlemen.

00:00:30.826 --> 00:00:32.326 A:middle
It's great to see
so many people here.

00:00:33.216 --> 00:00:35.946 A:middle
How many of you are here
for the first time at WWDC?

00:00:37.636 --> 00:00:39.056 A:middle
Wow! That's incredible.

00:00:39.096 --> 00:00:40.156 A:middle
Well, welcome.

00:00:40.156 --> 00:00:42.826 A:middle
I hope WWDC is going
well for you.

00:00:42.826 --> 00:00:46.606 A:middle
Now we're going to talk
about some networking topics.

00:00:47.686 --> 00:00:49.326 A:middle
I've got five things
to cover today.

00:00:49.896 --> 00:00:51.426 A:middle
We're going to give
you an update

00:00:51.966 --> 00:00:54.646 A:middle
on Explicit Congestion
Notification

00:00:54.646 --> 00:00:55.776 A:middle
that we talked about last year.

00:00:56.626 --> 00:00:59.386 A:middle
We're going to give you an
update in the progress on IPv6.

00:00:59.426 --> 00:01:04.166 A:middle
We're going to talk a little
bit about international text,

00:00:59.426 --> 00:01:04.166 A:middle
We're going to talk a little
bit about international text,

00:01:04.416 --> 00:01:06.106 A:middle
which is becoming
increasingly important.

00:01:07.606 --> 00:01:11.476 A:middle
We're going to explore
how you control access

00:01:11.476 --> 00:01:13.916 A:middle
to network interfaces
to avoid running

00:01:13.916 --> 00:01:15.656 A:middle
up big data bills
for your customers.

00:01:16.416 --> 00:01:19.276 A:middle
And we're going to finish
off with some discussion

00:01:19.276 --> 00:01:20.766 A:middle
of network quality of service.

00:01:21.606 --> 00:01:24.796 A:middle
You may have heard
about the Apple Cisco

00:01:25.016 --> 00:01:26.176 A:middle
Fastlane announcement.

00:01:26.686 --> 00:01:28.646 A:middle
We're going to talk a
little bit about how

00:01:28.646 --> 00:01:30.226 A:middle
that might apply to
your applications.

00:01:33.086 --> 00:01:34.266 A:middle
So let's start with ECN.

00:01:36.486 --> 00:01:38.046 A:middle
To recap from last year,

00:01:39.316 --> 00:01:41.456 A:middle
we showed how Smart
Queue Management

00:01:42.066 --> 00:01:46.956 A:middle
and marking packets instead of
dropping them can lower latency,

00:01:48.056 --> 00:01:50.356 A:middle
reduce delays due
to retransmission,

00:01:50.996 --> 00:01:55.206 A:middle
and improve the user
experience for all applications,

00:01:55.286 --> 00:01:57.176 A:middle
and especially for things
like streaming video.

00:02:00.326 --> 00:02:06.656 A:middle
In iOS 9, we did not enable
ECN for TCP connections,

00:02:06.826 --> 00:02:08.316 A:middle
but in an unrelated change,

00:02:08.366 --> 00:02:11.836 A:middle
the VPN software would pay
attention to ECN markings.

00:02:11.836 --> 00:02:16.086 A:middle
We found one ISP in Germany
that marked all packets

00:02:16.176 --> 00:02:19.826 A:middle
"congestion experienced,"
which was bad for VPN.

00:02:20.426 --> 00:02:22.886 A:middle
The good news is they
fixed their network

00:02:22.886 --> 00:02:23.916 A:middle
within a couple of weeks.

00:02:24.186 --> 00:02:26.696 A:middle
We had no reports of any
problems anywhere else

00:02:26.696 --> 00:02:30.936 A:middle
in the world, and what that
tells us now is we rolled

00:02:30.936 --> 00:02:34.866 A:middle
out iOS all around the world,
found one problem, fixed it;

00:02:35.586 --> 00:02:37.646 A:middle
the Internet is now
safe for ECN.

00:02:39.746 --> 00:02:46.286 A:middle
And because of that, in iOS
9.3 and OS X El Capitan,

00:02:47.116 --> 00:02:50.716 A:middle
five percent of TCP connections
at random are using ECN,

00:02:50.716 --> 00:02:55.456 A:middle
and we're using this to gather
performance data and check

00:02:55.456 --> 00:02:57.956 A:middle
that the Internet
continues to be safe for ECN.

00:02:58.576 --> 00:03:01.576 A:middle
In the Developer Seed
that you have already,

00:02:58.576 --> 00:03:01.576 A:middle
In the Developer Seed
that you have already,

00:03:02.216 --> 00:03:06.106 A:middle
100 percent of Wi-Fi connections
and 100 percent of connections

00:03:06.106 --> 00:03:08.886 A:middle
on these three carriers
are now using ECN.

00:03:10.636 --> 00:03:16.356 A:middle
So last year, I reported
that 56 percent

00:03:16.626 --> 00:03:20.776 A:middle
of the Alexa top million
websites supported ECN,

00:03:21.246 --> 00:03:24.326 A:middle
which is a pretty
impressive support number

00:03:24.326 --> 00:03:26.026 A:middle
for a technology
no one was using.

00:03:27.456 --> 00:03:33.886 A:middle
I talked to my good friends
at ETH Zurich, and Brian,

00:03:34.576 --> 00:03:37.076 A:middle
Brian Trammell and
Mira Coolwind,

00:03:37.076 --> 00:03:39.786 A:middle
and their colleagues reran
the experiment for us.

00:03:40.436 --> 00:03:43.066 A:middle
This year the percentage
is up to 70 percent.

00:03:43.446 --> 00:03:46.996 A:middle
And if you only look at IPv6
sites, it's up to 83 percent.

00:03:47.856 --> 00:03:55.766 A:middle
So this is a call to
action to ISPs and carriers

00:03:56.116 --> 00:03:58.006 A:middle
and their vendors who
sell equipment to them.

00:03:58.826 --> 00:04:00.406 A:middle
The clients are now doing ECN.

00:03:58.826 --> 00:04:00.406 A:middle
The clients are now doing ECN.

00:04:00.826 --> 00:04:02.326 A:middle
The services are supporting ECN.

00:04:02.796 --> 00:04:04.416 A:middle
It's time for the
network in the middle

00:04:04.756 --> 00:04:07.296 A:middle
to start marking packets
instead of dropping them.

00:04:07.796 --> 00:04:09.606 A:middle
It gives you a better
user experience,

00:04:10.526 --> 00:04:13.276 A:middle
it reduces delays due
to retransmission,

00:04:13.456 --> 00:04:15.356 A:middle
and it makes more
efficient use of your network

00:04:15.486 --> 00:04:17.305 A:middle
because you are avoiding
wasted bandwidth

00:04:17.305 --> 00:04:20.005 A:middle
retransmitting packets.

00:04:21.005 --> 00:04:23.616 A:middle
Our next topic is IPv6.

00:04:26.486 --> 00:04:30.806 A:middle
World IPv6 launch was
four years ago last week,

00:04:31.656 --> 00:04:34.856 A:middle
and it continues to grow.

00:04:36.146 --> 00:04:39.496 A:middle
I looked at a variety of
statistics, and I'm going

00:04:39.496 --> 00:04:42.066 A:middle
to show you just a
small sampling here.

00:04:42.656 --> 00:04:49.026 A:middle
I looked at accesses to Apple's
home page but coming over IPv6.

00:04:49.686 --> 00:04:53.716 A:middle
In Belgium, it's now
up to 39 percent.

00:04:54.696 --> 00:04:57.386 A:middle
On T-Mobile USA, we're
up to 54 percent.

00:04:58.696 --> 00:05:01.846 A:middle
On Verizon, we're
up to 74 percent.

00:04:58.696 --> 00:05:01.846 A:middle
On Verizon, we're
up to 74 percent.

00:05:02.346 --> 00:05:05.906 A:middle
So it's pretty clear
now on these carriers

00:05:06.186 --> 00:05:08.686 A:middle
that IPv6 traffic
is the majority.

00:05:10.586 --> 00:05:12.896 A:middle
And the reason is clear.

00:05:13.586 --> 00:05:16.766 A:middle
IPv6 is simpler,
it's more reliable,

00:05:16.766 --> 00:05:18.266 A:middle
it's less expensive to operate.

00:05:18.356 --> 00:05:21.966 A:middle
So it's very clear why the
carriers want to move to IPv6.

00:05:22.036 --> 00:05:26.556 A:middle
But at what cost to
developers and customers?

00:05:27.096 --> 00:05:28.796 A:middle
Is IPv6 less mature?

00:05:29.106 --> 00:05:30.136 A:middle
Is it slower?

00:05:30.466 --> 00:05:33.596 A:middle
Is there less capacity
allocated to IPv6?

00:05:33.936 --> 00:05:38.216 A:middle
These are important
questions, and content providers

00:05:38.386 --> 00:05:41.296 A:middle
and developers pay
close attention to this.

00:05:42.136 --> 00:05:45.796 A:middle
They use statistics
gathering in the web browsers

00:05:45.906 --> 00:05:49.186 A:middle
to measure things like page
load times for every single one

00:05:49.186 --> 00:05:52.496 A:middle
of their users viewing the
web page and report that back,

00:05:52.666 --> 00:05:56.246 A:middle
so they can tell how well
their product is working

00:05:56.356 --> 00:05:59.396 A:middle
in different countries around
the world, different ISPs,

00:05:59.576 --> 00:06:00.846 A:middle
different carrier networks.

00:05:59.576 --> 00:06:00.846 A:middle
different carrier networks.

00:06:02.856 --> 00:06:06.636 A:middle
LinkedIn reports that now 10
percent of their traffic is

00:06:06.636 --> 00:06:11.196 A:middle
over IPv6, and they find the
page load time on average is 10

00:06:11.356 --> 00:06:14.146 A:middle
to 40 percent faster
than over IPv4.

00:06:15.396 --> 00:06:18.816 A:middle
They theorize that that
is due to less overhead,

00:06:19.596 --> 00:06:22.856 A:middle
setting up connections through
overloaded large scale NATs.

00:06:23.846 --> 00:06:25.976 A:middle
Facebook found similar results.

00:06:26.036 --> 00:06:28.926 A:middle
45 percent of their
traffic is now over IPv6,

00:06:29.816 --> 00:06:32.026 A:middle
and they reported recently

00:06:32.266 --> 00:06:37.636 A:middle
that on average ATP GET requests
are 15 percent faster over IPv6.

00:06:37.696 --> 00:06:42.756 A:middle
If you only look at the iPhone
data in that collection,

00:06:43.026 --> 00:06:45.586 A:middle
it turns out to be
30 percent over IPv6.

00:06:47.866 --> 00:06:53.766 A:middle
So IPv6 is better for
network operators.

00:06:54.386 --> 00:06:56.366 A:middle
It's better for users
and content providers.

00:06:56.806 --> 00:07:01.596 A:middle
And that's why Apple is 100
percent backing the move

00:06:56.806 --> 00:07:01.596 A:middle
And that's why Apple is 100
percent backing the move

00:07:01.906 --> 00:07:02.656 A:middle
to IPv6.

00:07:03.446 --> 00:07:07.196 A:middle
And you will have all seen
this announcement last month.

00:07:08.056 --> 00:07:11.226 A:middle
We announced last year we were
going to be requiring all apps

00:07:12.156 --> 00:07:14.766 A:middle
to be compatible
with IPv6 networks,

00:07:15.106 --> 00:07:19.886 A:middle
and we said we would be testing
all apps on our own IPv6 network

00:07:19.886 --> 00:07:21.146 A:middle
with the NAT64 Gateway.

00:07:22.386 --> 00:07:25.326 A:middle
Starting this month we started
enforcing that requirement,

00:07:25.806 --> 00:07:29.056 A:middle
and we looked very
closely for any evidence

00:07:29.496 --> 00:07:32.046 A:middle
that this was causing
an increase in the rate

00:07:32.046 --> 00:07:35.566 A:middle
of application rejection,
because if that were the case,

00:07:35.896 --> 00:07:38.306 A:middle
we would have to look into
it and work out what to do.

00:07:38.856 --> 00:07:41.896 A:middle
But the good news is,
look as hard as we can,

00:07:42.596 --> 00:07:46.046 A:middle
we don't find any change
in application rejection,

00:07:46.506 --> 00:07:51.626 A:middle
so what that really tell us is
that 99 percent of you have apps

00:07:51.736 --> 00:07:53.866 A:middle
that are working just
fine with IPv6 support,

00:07:54.226 --> 00:07:57.106 A:middle
which is what we expected,
but it's still really good

00:07:57.106 --> 00:07:58.066 A:middle
to have that confirmed.

00:07:59.396 --> 00:08:01.996 A:middle
Now, if you've had
an app rejected

00:07:59.396 --> 00:08:01.996 A:middle
Now, if you've had
an app rejected

00:08:02.156 --> 00:08:06.906 A:middle
and you think it might be to
do with IPv6, then come on down

00:08:06.906 --> 00:08:08.586 A:middle
to the labs today or tomorrow.

00:08:09.226 --> 00:08:12.596 A:middle
You can test your app here
at WWDC on the NAT64 network,

00:08:12.596 --> 00:08:17.406 A:middle
and we can help you troubleshoot
what might be going wrong.

00:08:18.636 --> 00:08:22.246 A:middle
Our advice continues to
be, as it always has been,

00:08:23.036 --> 00:08:27.996 A:middle
use the high level APIs that
are address-family agnostic.

00:08:31.066 --> 00:08:34.405 A:middle
If you have to use the
low level BSD APIs,

00:08:34.405 --> 00:08:38.756 A:middle
then there is extra work that
you are going to have to do,

00:08:39.275 --> 00:08:42.046 A:middle
which is why we really advise
using the high level APIs

00:08:42.046 --> 00:08:42.846 A:middle
that do that for you.

00:08:44.035 --> 00:08:47.776 A:middle
Another key piece of
advice is use hostnames,

00:08:48.476 --> 00:08:50.206 A:middle
not literal IPv4 addresses.

00:08:50.756 --> 00:08:54.496 A:middle
Because IPv4 addresses are
inherently tied to IPv4.

00:08:54.976 --> 00:08:57.306 A:middle
And let me give you a
little picture showing why.

00:08:58.816 --> 00:09:01.336 A:middle
This is a typical situation
from a few years ago.

00:08:58.816 --> 00:09:01.336 A:middle
This is a typical situation
from a few years ago.

00:09:01.336 --> 00:09:02.916 A:middle
You have a client on IPv4.

00:09:02.976 --> 00:09:04.556 A:middle
You have a server on IPv4.

00:09:04.626 --> 00:09:08.126 A:middle
The packets make their little
detour via the NAT Gateway,

00:09:08.566 --> 00:09:12.846 A:middle
and that's how you
connect to the server.

00:09:12.926 --> 00:09:16.466 A:middle
Nowadays, many more carriers
are rolling out IPv6 networks

00:09:16.986 --> 00:09:20.596 A:middle
with a NAT64 Gateway, and the
packets still make their little

00:09:20.596 --> 00:09:22.666 A:middle
detour through the NAT
Gateway and connect

00:09:22.666 --> 00:09:25.906 A:middle
to that old legacy IPv4
service on the Internet.

00:09:28.926 --> 00:09:34.486 A:middle
Now, if your data center guys
bring up dual-stack services

00:09:35.046 --> 00:09:38.376 A:middle
but you're still using
v4 literals in your apps,

00:09:39.026 --> 00:09:41.676 A:middle
then the packets are going
to make that same detour

00:09:41.676 --> 00:09:44.596 A:middle
through the NAT to get to the
v4 interface at the service.

00:09:45.486 --> 00:09:47.076 A:middle
But if you look up by hostname

00:09:47.076 --> 00:09:50.916 A:middle
and they put the IPv6
quota records into the DNS,

00:09:51.806 --> 00:09:57.006 A:middle
that's how you get the straight
through data path without going

00:09:57.006 --> 00:09:57.896 A:middle
through the NAT Gateway.

00:10:02.446 --> 00:10:03.996 A:middle
I talked about literal
addresses.

00:10:05.396 --> 00:10:09.166 A:middle
We now support using
IPv4 literal addresses

00:10:09.286 --> 00:10:10.496 A:middle
in selected APIs.

00:10:11.616 --> 00:10:13.396 A:middle
And if you use one
of those addresses,

00:10:13.846 --> 00:10:18.416 A:middle
we will actually do the DNS64
synthesis for you locally

00:10:18.416 --> 00:10:22.896 A:middle
on the device, create a
temporary IPv6 address

00:10:22.896 --> 00:10:25.336 A:middle
corresponding with your v4
service on the Internet,

00:10:25.696 --> 00:10:27.806 A:middle
and then connect through
the NAT64 Gateway.

00:10:29.026 --> 00:10:33.676 A:middle
Now, remember, using literal v4
addresses will prevent your app

00:10:33.676 --> 00:10:35.576 A:middle
from ever connecting
to an ATV6 server.

00:10:35.576 --> 00:10:39.296 A:middle
But that said, if that's what
you need to do for your app,

00:10:40.536 --> 00:10:42.976 A:middle
here is an example
of how you do it.

00:10:44.816 --> 00:10:47.966 A:middle
If you're writing
code using Swift

00:10:48.526 --> 00:10:51.316 A:middle
and the high layer
Cocoa APIs, this happens

00:10:51.316 --> 00:10:52.276 A:middle
for you automatically.

00:10:52.756 --> 00:10:55.546 A:middle
But if you're writing
UDP code today

00:10:55.546 --> 00:10:58.376 A:middle
and you're using BSD
sockets, the API you need

00:10:58.376 --> 00:10:59.876 A:middle
to use is getaddrinfo.

00:11:00.966 --> 00:11:03.346 A:middle
You pass in the address
you want to connect

00:11:03.346 --> 00:11:04.866 A:middle
to as a literal string.

00:11:06.156 --> 00:11:07.496 A:middle
You pass in the port you want.

00:11:07.496 --> 00:11:10.886 A:middle
Here https is a synonym
for port 443.

00:11:12.266 --> 00:11:14.466 A:middle
You loop through all
the addresses you get.

00:11:14.746 --> 00:11:16.546 A:middle
Remember, don't just
take the first one.

00:11:16.546 --> 00:11:18.996 A:middle
You'll get back an array of
multiple addresses to try, and,

00:11:19.756 --> 00:11:21.436 A:middle
of course, free the memory
when you're finished.

00:11:23.956 --> 00:11:27.436 A:middle
Another question we
get from developers is

00:11:27.756 --> 00:11:29.606 A:middle
about the Internet of things.

00:11:30.416 --> 00:11:33.076 A:middle
There are developers
writing apps that interact

00:11:33.076 --> 00:11:34.566 A:middle
with the device that
they don't make,

00:11:35.446 --> 00:11:39.696 A:middle
and some of those devices
are not very modern.

00:11:40.636 --> 00:11:43.536 A:middle
Now, we'd like those
devices to support IPv6.

00:11:44.706 --> 00:11:47.506 A:middle
And if they don't support
IPv6, we recommend that they

00:11:47.506 --> 00:11:50.156 A:middle
at least support IPv4
link-local addressing.

00:11:50.906 --> 00:11:52.876 A:middle
So even on a v6 only network,

00:11:53.646 --> 00:11:56.716 A:middle
devices can use v4 amongst
themselves to communicate

00:11:56.996 --> 00:11:58.046 A:middle
with link-local addressing.

00:11:59.306 --> 00:12:00.956 A:middle
Now, if the device
can't do either

00:11:59.306 --> 00:12:00.956 A:middle
Now, if the device
can't do either

00:12:00.956 --> 00:12:02.876 A:middle
of those things, that's okay.

00:12:03.566 --> 00:12:06.176 A:middle
Inform app review, when
you submit your app,

00:12:07.116 --> 00:12:09.706 A:middle
that is not grounds for
rejection of your app.

00:12:10.086 --> 00:12:12.746 A:middle
It probably is grounds
for putting one

00:12:12.746 --> 00:12:13.996 A:middle
of these stickers on the device.

00:12:14.316 --> 00:12:20.096 A:middle
[Laughter] And remember, all off
link communication still have

00:12:20.096 --> 00:12:23.536 A:middle
to be compatible
with IPv6 and NAT64.

00:12:26.356 --> 00:12:32.256 A:middle
So to summarize, we recommend
you support both IPv4 and IPv6

00:12:33.146 --> 00:12:35.466 A:middle
at both ends, in the
clients and the servers.

00:12:36.386 --> 00:12:38.356 A:middle
We recommend you use hostnames.

00:12:38.756 --> 00:12:41.206 A:middle
That way you can get a v4
address on a v4 network

00:12:41.206 --> 00:12:43.986 A:middle
and a v6 address
on a v6 network.

00:12:45.626 --> 00:12:47.546 A:middle
If you do need to use
literal addresses,

00:12:48.056 --> 00:12:50.206 A:middle
those are now supported
in select APIs,

00:12:50.616 --> 00:12:51.666 A:middle
as long as you do it properly.

00:12:51.666 --> 00:12:55.496 A:middle
But remember, imbedding
v4 literals will block

00:12:55.586 --> 00:12:57.856 A:middle
communication to v6
servers in the future.

00:13:00.156 --> 00:13:03.436 A:middle
So that brings us to our next
session, international text.

00:13:06.476 --> 00:13:08.516 A:middle
You may have started to
see things like this,

00:13:09.126 --> 00:13:10.986 A:middle
and if you're a native
English speaker,

00:13:11.486 --> 00:13:14.076 A:middle
this can look pretty
daunting and scary.

00:13:15.276 --> 00:13:17.286 A:middle
And what I want to talk

00:13:17.286 --> 00:13:20.136 A:middle
about today is how
simple this really is.

00:13:20.916 --> 00:13:24.446 A:middle
International support in
your application doesn't need

00:13:24.446 --> 00:13:25.366 A:middle
to be a big task.

00:13:25.956 --> 00:13:28.766 A:middle
In fact, it really is no
harder than supporting ASCII.

00:13:29.416 --> 00:13:33.196 A:middle
So even though the title of this
session is International Text

00:13:33.196 --> 00:13:35.976 A:middle
and Networking, really we
can scratch the networking.

00:13:37.146 --> 00:13:38.346 A:middle
For now I just want to talk

00:13:38.346 --> 00:13:41.326 A:middle
about how you support
international text in general.

00:13:43.616 --> 00:13:45.546 A:middle
I'm going to start
with some background.

00:13:46.196 --> 00:13:49.846 A:middle
Not because many of you will
need to encounter this day

00:13:49.846 --> 00:13:53.136 A:middle
to day, but I want to
de-mystify some of this

00:13:53.406 --> 00:13:58.126 A:middle
and make it less scary,
because it really isn't any more

00:13:58.126 --> 00:13:59.276 A:middle
complicated than ASCII.

00:14:00.206 --> 00:14:02.076 A:middle
So the first concept
we have is Unicode.

00:14:03.526 --> 00:14:07.686 A:middle
Unicode is a big list of
numbers, and corresponding

00:14:07.686 --> 00:14:11.206 A:middle
to each number a human
visible character,

00:14:11.966 --> 00:14:15.366 A:middle
and it's like a big
phone directory.

00:14:15.366 --> 00:14:17.046 A:middle
In fact, it is available
in book form.

00:14:17.236 --> 00:14:19.176 A:middle
It's a big, thick book
with page after page

00:14:19.176 --> 00:14:20.126 A:middle
of number and character.

00:14:21.226 --> 00:14:23.406 A:middle
And that's an abstract concept.

00:14:23.626 --> 00:14:26.166 A:middle
You have integers and you have
the characters they represent.

00:14:27.026 --> 00:14:31.046 A:middle
Now, to use those integers in
our computers, we need some way

00:14:31.046 --> 00:14:34.146 A:middle
of representing those
numbers, in memory,

00:14:34.356 --> 00:14:35.966 A:middle
on disk, over the network.

00:14:37.016 --> 00:14:40.106 A:middle
One way of representing
them is UTF-32,

00:14:40.866 --> 00:14:43.196 A:middle
which is just a 32-bit number.

00:14:43.696 --> 00:14:45.246 A:middle
And like any 32-bit number,

00:14:45.696 --> 00:14:47.486 A:middle
you have to be concerned
whether it's big endian

00:14:47.486 --> 00:14:48.276 A:middle
or little endian.

00:14:49.066 --> 00:14:52.196 A:middle
And it takes up four times
as much space as ASCII.

00:14:54.226 --> 00:14:55.946 A:middle
UTF-16 is more compact.

00:14:55.946 --> 00:14:57.876 A:middle
It uses 16-bit numbers.

00:14:58.206 --> 00:15:01.386 A:middle
It still has the same problem of
little endian versus big endian,

00:14:58.206 --> 00:15:01.386 A:middle
It still has the same problem of
little endian versus big endian,

00:15:02.486 --> 00:15:04.286 A:middle
and because it's only 16-bits,

00:15:04.286 --> 00:15:06.796 A:middle
it can only represent
65,000 values.

00:15:07.366 --> 00:15:09.446 A:middle
So you have to use
the surrogate pairs

00:15:09.626 --> 00:15:11.696 A:middle
to represent the values
outside that range.

00:15:11.696 --> 00:15:12.856 A:middle
So that's a bit cumbersome.

00:15:14.446 --> 00:15:18.606 A:middle
UTF-8 is an 8-bit
byte-oriented encoding.

00:15:19.316 --> 00:15:21.726 A:middle
Because of that, there
are no byte order issues,

00:15:22.396 --> 00:15:28.536 A:middle
and this is really what makes
it the ideal encoding to use.

00:15:28.686 --> 00:15:31.296 A:middle
So let's dive in a
bit deeper into UTF-8.

00:15:32.966 --> 00:15:38.386 A:middle
It was invented late night in
New Jersey 1992, and it's one

00:15:38.416 --> 00:15:41.976 A:middle
of those rare pieces of
computer science genius.

00:15:42.296 --> 00:15:44.156 A:middle
And when I first
heard about that,

00:15:44.316 --> 00:15:46.556 A:middle
I immediately saw,
this is the answer.

00:15:46.556 --> 00:15:48.426 A:middle
This solves the problem
for international text.

00:15:49.156 --> 00:15:52.276 A:middle
So I want to tell you guys a
little bit about how it works

00:15:52.276 --> 00:15:54.786 A:middle
so you can understand
how simple it is.

00:15:57.386 --> 00:15:59.356 A:middle
The Codepoints in Unicode from 0

00:15:59.356 --> 00:16:02.506 A:middle
to 7F are exactly the
same as the ASCII values.

00:15:59.356 --> 00:16:02.506 A:middle
to 7F are exactly the
same as the ASCII values.

00:16:02.836 --> 00:16:06.106 A:middle
And UTF represents them using
the exact same bytes in memory.

00:16:06.776 --> 00:16:09.316 A:middle
So what that means is if
you've got a disk full

00:16:09.316 --> 00:16:13.786 A:middle
of plain ASCII files, I can wave
my magic wand over it and say,

00:16:14.166 --> 00:16:15.676 A:middle
I declare you to be UTF-8.

00:16:16.476 --> 00:16:18.426 A:middle
Not a single byte
on disk changes.

00:16:19.186 --> 00:16:21.266 A:middle
The meaning of the
files doesn't change.

00:16:21.946 --> 00:16:24.716 A:middle
You have automatic backwards
compatibility with all

00:16:24.716 --> 00:16:28.036 A:middle
that legacy of ASCII, so
that is a wonderful thing.

00:16:28.096 --> 00:16:31.716 A:middle
UTF-16, UTF-32, other encodings
don't have that property.

00:16:32.096 --> 00:16:36.306 A:middle
For the values that are
outside the ASCII range,

00:16:36.686 --> 00:16:39.506 A:middle
they are represented as
multi-byte sequences.

00:16:39.696 --> 00:16:43.096 A:middle
But all those multi-byte
sequences only use byte values

00:16:43.436 --> 00:16:45.726 A:middle
above 128.

00:16:46.386 --> 00:16:50.146 A:middle
So there was no overlap
between the ASCII characters

00:16:50.356 --> 00:16:51.936 A:middle
and the multi-byte encodings

00:16:52.206 --> 00:16:54.756 A:middle
of the higher value
Unicode Codepoints.

00:16:55.466 --> 00:16:57.926 A:middle
That property is not
true of other encodings

00:16:58.176 --> 00:17:01.036 A:middle
that re-use the high code
bytes to mean something else.

00:16:58.176 --> 00:17:01.036 A:middle
that re-use the high code
bytes to mean something else.

00:17:02.736 --> 00:17:06.116 A:middle
UTF-8 has three flavors
of bytes.

00:17:06.646 --> 00:17:09.796 A:middle
It has the plain ASCII bytes.

00:17:11.306 --> 00:17:14.576 A:middle
If a byte starts with the
most significant bit being 0,

00:17:14.656 --> 00:17:16.306 A:middle
that tells you it's plain ASCII.

00:17:18.036 --> 00:17:20.915 A:middle
If the top two, three,
or four bits are 1s,

00:17:20.915 --> 00:17:23.646 A:middle
that tells you it's a two,
three, or four byte sequence.

00:17:24.336 --> 00:17:25.965 A:middle
And if the top bits are 1 0,

00:17:25.965 --> 00:17:27.705 A:middle
that tells you it's
a continuation

00:17:27.826 --> 00:17:29.086 A:middle
of a multi-byte sequence.

00:17:29.586 --> 00:17:31.016 A:middle
So I'll show that in context.

00:17:32.146 --> 00:17:34.016 A:middle
The ASCII characters
stand alone.

00:17:35.706 --> 00:17:41.166 A:middle
The bytes with two leading
1s signify two byte sequence.

00:17:41.606 --> 00:17:43.556 A:middle
Three leading 1s is a
three byte sequence.

00:17:44.156 --> 00:17:46.196 A:middle
Four leading 1s is a
four byte sequence.

00:17:48.656 --> 00:17:51.256 A:middle
And this gives it a wonderful
property that you can jump

00:17:51.256 --> 00:17:56.646 A:middle
into the middle of a UTF-8 file
anywhere, and by just looking

00:17:56.646 --> 00:17:58.666 A:middle
at any old byte, you can
tell what you've got.

00:17:59.226 --> 00:18:00.736 A:middle
Does this stand alone as ASCII?

00:17:59.226 --> 00:18:00.736 A:middle
Does this stand alone as ASCII?

00:18:00.766 --> 00:18:02.726 A:middle
Is this the start of
a multi-byte sequence?

00:18:03.126 --> 00:18:05.336 A:middle
Did I land in the middle of a
multi-byte sequence and I have

00:18:05.336 --> 00:18:07.776 A:middle
to skip forward or back to
find the character boundary?

00:18:08.426 --> 00:18:12.416 A:middle
So it's very, very robust to
insertion and deletion errors.

00:18:12.966 --> 00:18:18.576 A:middle
It's an encoding that is
efficient enough to be compact

00:18:18.646 --> 00:18:21.386 A:middle
but has just enough
redundancy to be very reliable.

00:18:23.806 --> 00:18:28.256 A:middle
Another useful property it
has is in an UTF encoding

00:18:28.256 --> 00:18:30.106 A:middle
of a string, there
are no 0 bytes.

00:18:30.416 --> 00:18:33.106 A:middle
And C treats 0 as the
string terminator,

00:18:33.106 --> 00:18:34.856 A:middle
so that's a very
useful property.

00:18:34.856 --> 00:18:37.316 A:middle
UTF-16 strings have
zeros all over the place.

00:18:38.916 --> 00:18:41.536 A:middle
And another nice property is

00:18:41.536 --> 00:18:45.296 A:middle
if you do a naive simple
byte-wise string sort

00:18:45.446 --> 00:18:48.476 A:middle
on UTF strings, they
sort in the same order

00:18:48.596 --> 00:18:51.666 A:middle
as if you sorted the
Unicode Codepoints directly.

00:18:52.356 --> 00:18:55.336 A:middle
So a whole bunch of really
wonderful properties,

00:18:56.006 --> 00:18:59.576 A:middle
and this is why just six years
after Ken Thompson invented it,

00:19:00.196 --> 00:19:03.956 A:middle
the IETF issued a document
saying that from then on,

00:19:04.446 --> 00:19:07.216 A:middle
all new Internet
standard protocols had

00:19:07.216 --> 00:19:08.776 A:middle
to work with UTF-8.

00:19:10.146 --> 00:19:13.796 A:middle
And that philosophy has
been embraced on the web.

00:19:15.346 --> 00:19:19.056 A:middle
Four years ago, Google did a
survey and found that 80 percent

00:19:19.056 --> 00:19:22.736 A:middle
of web pages were UTF-8, and
that includes a small percentage

00:19:22.786 --> 00:19:24.786 A:middle
that were old fashioned,
plain ASCII,

00:19:24.786 --> 00:19:27.266 A:middle
which is of course a
compatible subset of UTF-8.

00:19:30.216 --> 00:19:33.356 A:middle
Last month that number
is now up to 87 percent.

00:19:33.636 --> 00:19:38.886 A:middle
And because of that, the
W3C, just like the IETF,

00:19:39.326 --> 00:19:43.156 A:middle
also recommends that we only
use UTF-8 for everything.

00:19:43.786 --> 00:19:44.576 A:middle
And this is wonderful.

00:19:46.326 --> 00:19:47.786 A:middle
There is, however, one catch.

00:19:48.556 --> 00:19:50.896 A:middle
For some reason,
lost in history,

00:19:51.296 --> 00:19:53.936 A:middle
the DNS community
decided not to do that,

00:19:53.936 --> 00:19:55.736 A:middle
and they invented a
different encoding

00:19:56.076 --> 00:19:57.206 A:middle
that they call Punycode.

00:19:58.726 --> 00:20:04.466 A:middle
And Punycode re-uses
existing ASCII byte values

00:19:58.726 --> 00:20:04.466 A:middle
And Punycode re-uses
existing ASCII byte values

00:20:04.466 --> 00:20:05.566 A:middle
to mean different things.

00:20:06.396 --> 00:20:09.416 A:middle
So those are the byte
values that correspond

00:20:09.416 --> 00:20:10.926 A:middle
to letters, digits, and hyphens.

00:20:12.286 --> 00:20:17.466 A:middle
A result of this is that if
we have a block of bytes,

00:20:18.346 --> 00:20:22.786 A:middle
I can interpret those bytes as
ASCII values and get something

00:20:22.786 --> 00:20:27.976 A:middle
like that, or I can interpret
them as being Punycode encoding

00:20:28.636 --> 00:20:29.836 A:middle
and get what they're
meant to be.

00:20:30.806 --> 00:20:33.306 A:middle
And that dual interpretation

00:20:33.306 --> 00:20:36.186 A:middle
of the same bytes can
be very problematic,

00:20:36.556 --> 00:20:40.926 A:middle
because it becomes unclear what
you want to display to the user

00:20:40.926 --> 00:20:42.266 A:middle
or what the user meant.

00:20:42.516 --> 00:20:44.326 A:middle
If we contrast that with UTF-8,

00:20:44.906 --> 00:20:47.386 A:middle
the first thing you notice is
the encoding is more compact.

00:20:47.386 --> 00:20:48.516 A:middle
It takes fewer bytes,

00:20:48.906 --> 00:20:51.286 A:middle
and there's also only
one valid interpretation.

00:20:51.886 --> 00:20:54.576 A:middle
So there was no ambiguity there.

00:20:55.946 --> 00:20:59.046 A:middle
The good news for you guys
is you don't need to care

00:20:59.046 --> 00:21:01.316 A:middle
about this, because
we handle it for you.

00:20:59.046 --> 00:21:01.316 A:middle
about this, because
we handle it for you.

00:21:03.036 --> 00:21:07.646 A:middle
In iOS 9 and OS X El
Capitan, if you tried

00:21:07.646 --> 00:21:11.906 A:middle
to ping a UTF-8 hostname on the
command line, it would fail.

00:21:12.716 --> 00:21:17.826 A:middle
You type in UTF-8, those
characters pass through the tool

00:21:18.246 --> 00:21:23.336 A:middle
to the APIs on to the network,
but that name was not put

00:21:23.336 --> 00:21:26.016 A:middle
into the DNS as UTF-8
and it fails.

00:21:26.946 --> 00:21:32.336 A:middle
Starting now in iOS 10 and macOS
Sierra, the same ping command

00:21:32.336 --> 00:21:36.376 A:middle
on the command line with
the same UTF-8 input,

00:21:37.216 --> 00:21:41.496 A:middle
we will now translate that
automatically to Punycode,

00:21:42.716 --> 00:21:45.316 A:middle
do the query, and it
will be successful.

00:21:46.086 --> 00:21:50.376 A:middle
Now, here the ping command
is taking that Punycode

00:21:50.826 --> 00:21:54.586 A:middle
and displaying it as if it were
ASCII so you get this gibberish

00:21:54.586 --> 00:21:57.466 A:middle
on the screen instead of the
actual name that you meant,

00:21:58.036 --> 00:21:59.076 A:middle
and that's part of the problem

00:21:59.076 --> 00:22:01.276 A:middle
of having dual interpretations
of the same string.

00:21:59.076 --> 00:22:01.276 A:middle
of having dual interpretations
of the same string.

00:22:01.866 --> 00:22:04.576 A:middle
But the good news
is all the Bonjour

00:22:04.576 --> 00:22:08.206 A:middle
and DSA APIs will now accept
international text input

00:22:08.206 --> 00:22:10.676 A:middle
in UTF-8 format, because --

00:22:11.516 --> 00:22:16.906 A:middle
[ Applause ]

00:22:17.406 --> 00:22:17.706 A:middle
Thank you.

00:22:18.976 --> 00:22:21.326 A:middle
Because the Punycode
format is quite restrictive,

00:22:21.436 --> 00:22:25.046 A:middle
it doesn't support even simple
things like spaces in names,

00:22:25.136 --> 00:22:28.906 A:middle
and we use DNS for Bonjour
search discovery, we don't want

00:22:28.906 --> 00:22:29.756 A:middle
to be that restrictive.

00:22:30.276 --> 00:22:33.976 A:middle
So the way the algorithm works,
which is what's documented

00:22:33.976 --> 00:22:39.676 A:middle
in RFC 6763, we will
first try UTF-8 as is,

00:22:40.156 --> 00:22:43.986 A:middle
and if the DNS administrator
put UTF-8 into their zone file,

00:22:43.986 --> 00:22:46.266 A:middle
which is very easy to do, and
people were doing that back

00:22:46.266 --> 00:22:48.966 A:middle
in the '90s, we do the
query, we are successful,

00:22:48.966 --> 00:22:50.576 A:middle
we get the result,
everything is fine.

00:22:51.056 --> 00:22:54.336 A:middle
What's new now is that if we
fail, instead of giving up,

00:22:54.336 --> 00:22:57.766 A:middle
we will do one more try with
Punycode and see if that works.

00:22:57.996 --> 00:23:01.856 A:middle
So we support both
in the same API.

00:22:57.996 --> 00:23:01.856 A:middle
So we support both
in the same API.

00:23:03.566 --> 00:23:05.406 A:middle
Email addresses are
also becoming

00:23:05.846 --> 00:23:07.066 A:middle
internationalized today.

00:23:07.736 --> 00:23:13.596 A:middle
And this is also not hard to
do, but users face problems

00:23:13.596 --> 00:23:14.956 A:middle
for a silly, trivial reason.

00:23:15.746 --> 00:23:18.716 A:middle
Many apps, when you sign
up for an account or you go

00:23:18.716 --> 00:23:22.226 A:middle
onto the website to sign up for
an account, they try to validate

00:23:22.226 --> 00:23:25.976 A:middle
if the email address is valid
and they check whether it ends

00:23:25.976 --> 00:23:29.226 A:middle
in .com or things of that form.

00:23:30.126 --> 00:23:34.126 A:middle
And users with perfectly valid
email addresses are not allowed

00:23:34.126 --> 00:23:37.986 A:middle
to sign up for accounts because
their email address is rejected.

00:23:38.426 --> 00:23:43.696 A:middle
So we need to remove those
ill-advised validators.

00:23:43.806 --> 00:23:45.326 A:middle
Really the only thing
you can check

00:23:45.326 --> 00:23:47.966 A:middle
for in an email address is
it has to have an @ sign.

00:23:47.966 --> 00:23:51.336 A:middle
And if it's got that, it could
be a valid email address.

00:23:51.386 --> 00:23:54.926 A:middle
If you want to know if it's
valid, send a validation email

00:23:55.016 --> 00:23:58.016 A:middle
and have the user respond
to confirm that it's live.

00:23:59.696 --> 00:24:03.206 A:middle
If you're writing an email
client or an email server,

00:23:59.696 --> 00:24:03.206 A:middle
If you're writing an email
client or an email server,

00:24:03.206 --> 00:24:06.466 A:middle
there are a bunch of RFCs you
are going to need to look at.

00:24:06.936 --> 00:24:09.666 A:middle
But for the rest of you, you
don't need to worry about that.

00:24:09.666 --> 00:24:13.416 A:middle
Let the user enter their
email address as UTF-8,

00:24:14.036 --> 00:24:15.736 A:middle
stick it in your
customer database,

00:24:16.186 --> 00:24:19.846 A:middle
and have the mail server send
that out correctly encoding

00:24:19.846 --> 00:24:20.966 A:middle
with the email standards.

00:24:24.356 --> 00:24:28.596 A:middle
So to wrap up this section, we
recommend UTF-8 for everything.

00:24:29.326 --> 00:24:31.086 A:middle
Makes everything
so much simpler.

00:24:31.636 --> 00:24:32.866 A:middle
Don't worry about Punycode.

00:24:32.866 --> 00:24:33.796 A:middle
We handle it for you.

00:24:34.566 --> 00:24:38.746 A:middle
And be liberal about
accepting user input

00:24:39.086 --> 00:24:41.496 A:middle
in this new international
multi-lingual world.

00:24:44.006 --> 00:24:46.826 A:middle
That brings us to
interface selection.

00:24:48.376 --> 00:24:53.286 A:middle
Now, Wi-Fi Assist is something
that we introduced last year.

00:24:55.556 --> 00:24:56.876 A:middle
Really, this is not new.

00:24:57.396 --> 00:24:59.846 A:middle
This is the way things
have worked

00:24:59.846 --> 00:25:01.406 A:middle
since the very first iPhone.

00:24:59.846 --> 00:25:01.406 A:middle
since the very first iPhone.

00:25:02.556 --> 00:25:05.156 A:middle
If I have Wi-Fi, I want
my phone to use it.

00:25:06.096 --> 00:25:09.866 A:middle
If I don't have Wi-Fi, that's
why I pay for cellular data,

00:25:10.046 --> 00:25:12.656 A:middle
so I have network access
outside the home as well.

00:25:13.656 --> 00:25:15.816 A:middle
And the first iPhone did this.

00:25:16.396 --> 00:25:19.556 A:middle
What we changed last
year is we did it better.

00:25:20.476 --> 00:25:23.106 A:middle
We were smarter about
making that determination,

00:25:24.156 --> 00:25:26.416 A:middle
because there's always
this gray area right

00:25:26.416 --> 00:25:27.846 A:middle
on the edge of a Wi-Fi network.

00:25:29.046 --> 00:25:31.916 A:middle
And mobility factors
into this as well.

00:25:31.916 --> 00:25:34.296 A:middle
We have a situation that we
call the parking lot problem,

00:25:34.296 --> 00:25:37.756 A:middle
and it happens at the end of
the day when you leave work.

00:25:38.146 --> 00:25:41.066 A:middle
You leave the office, you get
your phone out, you have Wi-Fi,

00:25:41.186 --> 00:25:44.076 A:middle
you're walking out to the car
and you want to check maps

00:25:44.076 --> 00:25:46.856 A:middle
or weather forecasts or
look for movies or something

00:25:47.576 --> 00:25:49.526 A:middle
and your phone thought
it had Wi-Fi.

00:25:49.526 --> 00:25:53.706 A:middle
It had Wi-Fi a moment ago, but
you just walked out of range

00:25:54.316 --> 00:25:55.546 A:middle
and it hasn't realized yet.

00:25:56.746 --> 00:25:58.726 A:middle
With Wi-Fi Assist,
we will detect that.

00:25:59.466 --> 00:26:00.756 A:middle
We'll try to use Wi-Fi.

00:25:59.466 --> 00:26:00.756 A:middle
We'll try to use Wi-Fi.

00:26:00.796 --> 00:26:02.996 A:middle
If it doesn't work, we'll
use cellular instead.

00:26:04.856 --> 00:26:09.186 A:middle
But like any new feature,
there's sometimes a tendency

00:26:09.666 --> 00:26:12.486 A:middle
for the new thing to be the
whipping boy that gets blamed

00:26:12.486 --> 00:26:13.446 A:middle
for people's problems.

00:26:13.896 --> 00:26:17.626 A:middle
Everybody hates it when
some app uses a ton of data

00:26:17.626 --> 00:26:19.416 A:middle
and they get a big bill
they weren't expecting,

00:26:20.176 --> 00:26:23.046 A:middle
and it's human nature to
blame the new feature.

00:26:23.406 --> 00:26:25.916 A:middle
But if you actually look
at your Wi-Fi Assist data,

00:26:25.916 --> 00:26:27.956 A:middle
you will probably find
they are very small.

00:26:28.616 --> 00:26:30.986 A:middle
Wi-Fi Assist is normally
not the problem here.

00:26:31.556 --> 00:26:33.806 A:middle
Now, apps have the switch.

00:26:34.036 --> 00:26:35.736 A:middle
If you don't want
that app using lots

00:26:35.736 --> 00:26:37.426 A:middle
of data, you can turn it off.

00:26:38.286 --> 00:26:39.336 A:middle
But that's very crude.

00:26:39.416 --> 00:26:40.986 A:middle
That's kind of an all
or nothing switch.

00:26:41.856 --> 00:26:44.496 A:middle
And a lot of apps want to do
something a bit more subtle.

00:26:45.426 --> 00:26:47.376 A:middle
Say you have a video
streaming app.

00:26:48.836 --> 00:26:53.046 A:middle
You may want the user to be
able to browse the catalog,

00:26:53.046 --> 00:26:54.546 A:middle
see little thumbnail pictures,

00:26:54.546 --> 00:26:57.706 A:middle
read the descriptions
over mobile data.

00:26:58.056 --> 00:26:59.166 A:middle
Doesn't cost very much.

00:26:59.926 --> 00:27:01.886 A:middle
But you may want the
setting in your app

00:26:59.926 --> 00:27:01.886 A:middle
But you may want the
setting in your app

00:27:02.256 --> 00:27:05.056 A:middle
that says don't stream
videos over mobile

00:27:06.186 --> 00:27:07.856 A:middle
because users may
not want to spend

00:27:07.856 --> 00:27:09.306 A:middle
that much money on mobile data.

00:27:10.076 --> 00:27:13.056 A:middle
And if you have that, you're
going to want to be able

00:27:13.056 --> 00:27:16.766 A:middle
to differentiate between getting
the thumbnail, which is allowed

00:27:16.766 --> 00:27:19.026 A:middle
over cellular, and streaming
the video, which is not.

00:27:20.156 --> 00:27:24.256 A:middle
A lot of developers have
done things like this.

00:27:24.636 --> 00:27:28.886 A:middle
They use the reachability
API to say, am I on cell?

00:27:29.096 --> 00:27:29.986 A:middle
Yes or no?

00:27:30.216 --> 00:27:32.836 A:middle
If I'm not on cell, go
ahead and do that download.

00:27:33.226 --> 00:27:36.096 A:middle
Well, things don't stay
the same in networking.

00:27:36.096 --> 00:27:37.946 A:middle
Things change from
second to second.

00:27:38.386 --> 00:27:41.586 A:middle
And between you checking
whether you're on cell

00:27:41.586 --> 00:27:43.016 A:middle
and actually doing
the connection,

00:27:43.406 --> 00:27:45.436 A:middle
the user may be walking
across the parking lot.

00:27:46.216 --> 00:27:49.006 A:middle
So this is not the
right way to do it.

00:27:49.716 --> 00:27:52.706 A:middle
The right way to do it
is to express your intent

00:27:52.856 --> 00:27:56.766 A:middle
to the networking layers, and
we will honor what you tell us.

00:27:58.356 --> 00:28:02.406 A:middle
The first step here is don't
bother with preflight checks.

00:27:58.356 --> 00:28:02.406 A:middle
The first step here is don't
bother with preflight checks.

00:28:02.946 --> 00:28:05.356 A:middle
If you want to do a network
transaction, just try it.

00:28:06.306 --> 00:28:09.996 A:middle
If that's a transaction that you
don't want to use cellular data,

00:28:10.546 --> 00:28:12.976 A:middle
then you can express that
to the networking layers.

00:28:13.536 --> 00:28:15.246 A:middle
Using the CoreMedia APIs,

00:28:15.686 --> 00:28:21.106 A:middle
you set the allow cellular
access key using NSURLSession.

00:28:21.616 --> 00:28:24.376 A:middle
If you set allows
cellular access to false,

00:28:24.756 --> 00:28:27.076 A:middle
then we won't use
cellular data connection.

00:28:27.846 --> 00:28:28.496 A:middle
Nice and simple.

00:28:29.516 --> 00:28:35.666 A:middle
[ Applause ]

00:28:36.166 --> 00:28:38.996 A:middle
If that connection fails,
you can ask the user,

00:28:38.996 --> 00:28:41.376 A:middle
do you want to stream this
video over mobile data,

00:28:42.376 --> 00:28:46.796 A:middle
or you can just wait, subscribe
for better route notifications,

00:28:47.146 --> 00:28:50.536 A:middle
and when the phone comes back on
Wi-Fi, you'll be told about it

00:28:50.836 --> 00:28:53.776 A:middle
and then you can retry your
connection once Wi-Fi is

00:28:53.776 --> 00:28:57.776 A:middle
available again.

00:28:58.956 --> 00:29:02.426 A:middle
So to summarize, don't
assume that because you're

00:28:58.956 --> 00:29:02.426 A:middle
So to summarize, don't
assume that because you're

00:29:02.426 --> 00:29:06.696 A:middle
on Wi-Fi now, you will still be
on Wi-Fi one second from now,

00:29:06.696 --> 00:29:08.006 A:middle
or even half a second from now.

00:29:08.896 --> 00:29:09.816 A:middle
Conditions change.

00:29:10.926 --> 00:29:13.266 A:middle
Express what you want
to the networking layers

00:29:13.266 --> 00:29:15.846 A:middle
and we will respect that.

00:29:16.886 --> 00:29:20.666 A:middle
Our last topic is
networking quality of service.

00:29:23.256 --> 00:29:26.556 A:middle
Last summer, we announced
a partnership between Cisco

00:29:26.556 --> 00:29:30.066 A:middle
and Apple, and I'm going to
tell you a little bit about one

00:29:30.066 --> 00:29:35.226 A:middle
of the new APIs that you can
use to express your needs

00:29:35.226 --> 00:29:36.406 A:middle
to the networking layers.

00:29:38.646 --> 00:29:40.556 A:middle
There are different kinds
of networking traffic.

00:29:41.926 --> 00:29:45.336 A:middle
99 percent of what
we do is good,

00:29:45.596 --> 00:29:48.056 A:middle
standard Internet
best effort traffic.

00:29:48.466 --> 00:29:50.316 A:middle
We want the best
throughput we can get,

00:29:51.066 --> 00:29:53.556 A:middle
and ideally we'd like low delay.

00:29:53.556 --> 00:29:57.136 A:middle
But we definitely want as
much throughput as we can get.

00:29:57.436 --> 00:29:59.976 A:middle
This supplies browsing
the web, sending an email.

00:30:01.066 --> 00:30:04.846 A:middle
Another thing that we
do is online backup,

00:30:06.046 --> 00:30:07.546 A:middle
uploading photos to iCloud.

00:30:08.396 --> 00:30:13.306 A:middle
And that also wants to have
good throughput, but not as good

00:30:13.306 --> 00:30:14.636 A:middle
as the priority stuff.

00:30:15.256 --> 00:30:19.066 A:middle
We'd like to be able to upload
all of our photos to iCloud

00:30:19.106 --> 00:30:24.686 A:middle
in the background without
disrupting our Netflix TV binge.

00:30:25.646 --> 00:30:28.706 A:middle
The photo upload should take
place when we're sleeping.

00:30:28.706 --> 00:30:31.506 A:middle
It is what we call
scavenger-class traffic.

00:30:31.506 --> 00:30:34.606 A:middle
It uses the otherwise idle
capacity of the network

00:30:34.606 --> 00:30:38.276 A:middle
that would otherwise have been
wasted, but it is second class

00:30:38.566 --> 00:30:40.596 A:middle
to sending emails,
browsing the web,

00:30:40.596 --> 00:30:42.776 A:middle
anything that the human
is actively involved with.

00:30:42.826 --> 00:30:47.926 A:middle
The third class of
traffic is telephony,

00:30:48.846 --> 00:30:50.396 A:middle
interactive voice and video.

00:30:50.396 --> 00:30:53.206 A:middle
And I say interactive,
because that's the key thing.

00:30:53.666 --> 00:30:56.216 A:middle
When we're having a
conversation, I speak,

00:30:56.586 --> 00:30:59.876 A:middle
you hear me, you respond,
you speak back, I hear you.

00:31:00.166 --> 00:31:03.176 A:middle
If that round-trip is more than
a couple hundred milliseconds,

00:31:03.566 --> 00:31:07.776 A:middle
human communication breaks down.

00:31:08.396 --> 00:31:12.386 A:middle
When people talk about voice and
video, it's important to realize

00:31:12.466 --> 00:31:15.616 A:middle
that watching a YouTube
video may be video,

00:31:16.116 --> 00:31:17.416 A:middle
but it's not interactive.

00:31:17.466 --> 00:31:21.926 A:middle
It doesn't need that sub 200
millisecond round-trip time.

00:31:21.926 --> 00:31:23.776 A:middle
Listening to a podcast
may be voice;

00:31:24.026 --> 00:31:26.046 A:middle
that doesn't mean a
podcast is voice traffic.

00:31:26.046 --> 00:31:26.996 A:middle
It's not interactive.

00:31:27.936 --> 00:31:31.176 A:middle
So that's why I labeled this
part of the chart telephony,

00:31:31.476 --> 00:31:33.476 A:middle
because this is interactive
voice and video.

00:31:34.386 --> 00:31:37.206 A:middle
For that traffic you want the
lowest round-trip time possible,

00:31:38.706 --> 00:31:40.006 A:middle
and it's very small throughput.

00:31:40.096 --> 00:31:41.476 A:middle
It's a few kilobits per second.

00:31:41.526 --> 00:31:43.326 A:middle
You don't need 50
megabits of voice.

00:31:44.056 --> 00:31:45.946 A:middle
So marking your traffic

00:31:45.946 --> 00:31:49.886 A:middle
as telephony tells the
network keep the latency low,

00:31:49.886 --> 00:31:52.136 A:middle
but you also don't
have a big queue.

00:31:52.536 --> 00:31:56.036 A:middle
If you try to do any kind of
bulk transfer as voice class,

00:31:56.226 --> 00:31:59.076 A:middle
you're going to lose
most of your packets,

00:31:59.346 --> 00:32:01.026 A:middle
because a very small amount

00:31:59.346 --> 00:32:01.026 A:middle
because a very small amount

00:32:01.026 --> 00:32:03.416 A:middle
of the network capacity is
allocated for that traffic.

00:32:03.986 --> 00:32:07.596 A:middle
So one of our FAQ
questions people ask us,

00:32:07.596 --> 00:32:09.306 A:middle
will Fastlane make
my app faster?

00:32:09.306 --> 00:32:11.596 A:middle
And the answer is no, it
doesn't make it faster.

00:32:11.966 --> 00:32:13.866 A:middle
It will lower the
latency for voice traffic.

00:32:16.496 --> 00:32:19.726 A:middle
You may be wondering,
how does this relate

00:32:19.846 --> 00:32:21.216 A:middle
to the Smart Queue Management

00:32:21.286 --> 00:32:23.166 A:middle
and Explicit Congestion
Notification

00:32:23.546 --> 00:32:24.826 A:middle
that we were talking
about earlier?

00:32:24.826 --> 00:32:30.056 A:middle
And the answer is those
technologies improve the delay

00:32:30.706 --> 00:32:33.766 A:middle
for all traffic across
the board,

00:32:34.426 --> 00:32:38.166 A:middle
but telephony will probably
still be an extreme case

00:32:38.456 --> 00:32:40.766 A:middle
that wants the very,
very lowest latency

00:32:40.766 --> 00:32:46.916 A:middle
and doesn't mind sacrificing
throughput to get that.

00:32:47.716 --> 00:32:51.786 A:middle
Starting in iOS 5 we had the
network service type API,

00:32:51.786 --> 00:32:55.376 A:middle
and that lets you express some
of these needs to the network.

00:32:56.116 --> 00:32:59.446 A:middle
But many of the developers
writing apps like Skype

00:32:59.446 --> 00:33:01.616 A:middle
and Facetime that
are doing this kind

00:32:59.446 --> 00:33:01.616 A:middle
and Facetime that
are doing this kind

00:33:01.616 --> 00:33:05.456 A:middle
of voice telephony
are using UDP.

00:33:05.456 --> 00:33:09.596 A:middle
And to use UDP today on iOS, you
need to be using BSD sockets.

00:33:10.056 --> 00:33:12.786 A:middle
So we now have a socket option

00:33:13.326 --> 00:33:15.636 A:middle
that exposes the
same functionality

00:33:15.946 --> 00:33:19.156 A:middle
so your UDP clients
can benefit from this.

00:33:20.176 --> 00:33:24.176 A:middle
We know some developers had been
previously setting the IP type

00:33:24.176 --> 00:33:27.586 A:middle
of service bits in an attempt
to get the same effect.

00:33:28.946 --> 00:33:30.166 A:middle
The problem is those type

00:33:30.166 --> 00:33:32.766 A:middle
of service bits are
not well defined.

00:33:32.826 --> 00:33:34.266 A:middle
They are not specified anywhere.

00:33:34.726 --> 00:33:38.466 A:middle
Some Wi-Fi chip vendors will
look at the type of service bits

00:33:38.606 --> 00:33:42.936 A:middle
and use that as a hint to
set the Wi-Fi traffic class

00:33:43.456 --> 00:33:45.756 A:middle
to voice, video, background.

00:33:47.056 --> 00:33:49.936 A:middle
But the problem is with no
standard definition of the bits,

00:33:50.216 --> 00:33:52.606 A:middle
that interpretation
is not consistent.

00:33:52.606 --> 00:33:56.486 A:middle
So you may test it in your
office and think it works fine,

00:33:56.876 --> 00:33:58.576 A:middle
but for a customer, it
does something different.

00:33:59.156 --> 00:34:00.866 A:middle
And that's why we have
the new socket option

00:33:59.156 --> 00:34:00.866 A:middle
And that's why we have
the new socket option

00:34:00.866 --> 00:34:01.856 A:middle
that gives you reliable,

00:34:01.856 --> 00:34:04.066 A:middle
consistent behavior
across all devices.

00:34:06.486 --> 00:34:07.956 A:middle
If you're writing Swift code,

00:34:08.536 --> 00:34:10.726 A:middle
you can set the network
service type property

00:34:10.726 --> 00:34:12.396 A:middle
to voice, video, or background.

00:34:12.746 --> 00:34:13.985 A:middle
Or if you don't set it at all,

00:34:13.985 --> 00:34:16.786 A:middle
then that is traditional
best effort.

00:34:17.716 --> 00:34:19.356 A:middle
If you are using
the socket option,

00:34:19.775 --> 00:34:21.216 A:middle
we have the same options.

00:34:21.735 --> 00:34:25.936 A:middle
We have about another seven
more than this, which is more

00:34:25.936 --> 00:34:26.835 A:middle
than most of you will need.

00:34:27.286 --> 00:34:30.326 A:middle
These are the four
interesting ones.

00:34:31.886 --> 00:34:35.126 A:middle
When you set these options,
a couple of things happen.

00:34:36.726 --> 00:34:39.676 A:middle
On the device itself, there
are multiple outband queues,

00:34:40.466 --> 00:34:43.795 A:middle
and the type of service you set

00:34:43.795 --> 00:34:46.045 A:middle
for your traffic controls
which queue it uses.

00:34:47.775 --> 00:34:51.565 A:middle
On Wi-Fi interfaces, it
will also set the wireless

00:34:51.565 --> 00:34:52.985 A:middle
multi-media access category.

00:34:54.446 --> 00:34:57.686 A:middle
This is supported on all
devices, iOS and OS X,

00:34:58.396 --> 00:35:00.566 A:middle
and the outband queue
selection also applies

00:34:58.396 --> 00:35:00.566 A:middle
and the outband queue
selection also applies

00:35:00.566 --> 00:35:01.936 A:middle
for Ethernet as well as Wi-Fi.

00:35:03.696 --> 00:35:07.506 A:middle
Now, if your device is on one

00:35:07.506 --> 00:35:12.056 A:middle
of these new Cisco Fastlane
networks, we will recognize that

00:35:12.056 --> 00:35:16.296 A:middle
and we will also set the IP
layer differentiating services

00:35:16.296 --> 00:35:20.626 A:middle
Code Point so that you get
that handling that you want,

00:35:20.846 --> 00:35:23.566 A:middle
not just on the first
hop leaving the device

00:35:23.906 --> 00:35:26.206 A:middle
but in subsequent hops
through the enterprise network.

00:35:27.136 --> 00:35:31.786 A:middle
I want to stress this is not
something that you all need

00:35:31.816 --> 00:35:34.266 A:middle
to feel obliged to go
away and change your code.

00:35:34.876 --> 00:35:36.856 A:middle
If you're writing an
online backup app,

00:35:37.476 --> 00:35:39.296 A:middle
definitely set background
traffic class.

00:35:39.996 --> 00:35:44.686 A:middle
If you're writing the next
Skype, then set the voice class.

00:35:45.156 --> 00:35:46.616 A:middle
But for the rest of you,

00:35:47.476 --> 00:35:50.306 A:middle
standard best effort is almost
certainly what you want.

00:35:51.736 --> 00:35:53.246 A:middle
Some other things you
ought to remember:

00:35:55.146 --> 00:35:58.776 A:middle
The outband queue
selection and Wi-Fi layer,

00:35:58.776 --> 00:36:01.776 A:middle
quality of service marking
is supported on all devices,

00:35:58.776 --> 00:36:01.776 A:middle
quality of service marking
is supported on all devices,

00:36:02.016 --> 00:36:04.106 A:middle
but remember it only
applies to outband packets.

00:36:04.106 --> 00:36:06.456 A:middle
The packets coming in have
to be marked by the thing

00:36:06.456 --> 00:36:07.546 A:middle
at the other end sending them.

00:36:08.526 --> 00:36:14.116 A:middle
And the IP layer marking is
also only for outbound packets.

00:36:14.866 --> 00:36:18.966 A:middle
It's today only supported
on Cisco networks

00:36:18.966 --> 00:36:20.106 A:middle
with compatible hardware.

00:36:20.906 --> 00:36:22.006 A:middle
It's only on iOS.

00:36:22.136 --> 00:36:25.406 A:middle
It's not supported on Macs
or Apple TV or anything else.

00:36:26.196 --> 00:36:28.296 A:middle
And for now it's only
supported on Wi-Fi.

00:36:28.296 --> 00:36:30.756 A:middle
I know most people don't use
Ethernet with your iPads,

00:36:30.756 --> 00:36:32.796 A:middle
but if you do plug in
an Ethernet adaptor,

00:36:33.436 --> 00:36:35.646 A:middle
the quality of service is
not supported on Ethernet.

00:36:36.476 --> 00:36:39.956 A:middle
And finally if the
administrator chooses

00:36:40.016 --> 00:36:42.706 A:middle
to install a management
profile on the device,

00:36:43.316 --> 00:36:47.126 A:middle
then that management profile can
restrict which apps are allowed

00:36:47.126 --> 00:36:50.936 A:middle
to use this type of service
option, and only apps

00:36:50.936 --> 00:36:52.766 A:middle
that are listed in the
profile will be able

00:36:52.766 --> 00:36:53.896 A:middle
to set type of service.

00:36:53.896 --> 00:36:57.296 A:middle
It will be a no op
for all other apps.

00:37:00.006 --> 00:37:01.486 A:middle
So to summarize this section,

00:37:01.996 --> 00:37:05.996 A:middle
most of your traffic should
continue to be best effort.

00:37:07.276 --> 00:37:09.806 A:middle
If you are doing
large, bulk transfers

00:37:09.806 --> 00:37:12.646 A:middle
that are not time critical,
background traffic is a way

00:37:12.646 --> 00:37:14.026 A:middle
for you to be less disruptive

00:37:14.026 --> 00:37:15.696 A:middle
and be a better citizen
on the network.

00:37:16.666 --> 00:37:18.786 A:middle
Remember, it's not
a priority level.

00:37:19.186 --> 00:37:20.906 A:middle
There isn't a ranked
ordering here

00:37:20.906 --> 00:37:22.556 A:middle
of high priority
to low priority.

00:37:23.056 --> 00:37:25.946 A:middle
It's a web expressing whether
you want low throughput

00:37:25.946 --> 00:37:30.286 A:middle
and low latency or high
throughput and moderate latency.

00:37:34.716 --> 00:37:35.876 A:middle
So that ends our session.

00:37:35.876 --> 00:37:37.106 A:middle
Thank you for coming.

00:37:37.656 --> 00:37:42.456 A:middle
We've talked about Smart Queue
Management, and this is a call

00:37:42.456 --> 00:37:46.666 A:middle
to action to all the ISPs and
carriers and network vendors.

00:37:47.506 --> 00:37:48.986 A:middle
The clients are supporting ECN.

00:37:49.076 --> 00:37:50.636 A:middle
The servers are supporting ECN.

00:37:51.106 --> 00:37:53.726 A:middle
If you start marking the
packets in your network instead

00:37:53.726 --> 00:37:56.226 A:middle
of dropping them, you will
make your users much happier.

00:37:57.166 --> 00:37:58.796 A:middle
The message for developers

00:37:58.796 --> 00:38:03.096 A:middle
in the room is IPv6 is now
the majority of traffic

00:37:58.796 --> 00:38:03.096 A:middle
in the room is IPv6 is now
the majority of traffic

00:38:03.226 --> 00:38:05.296 A:middle
for many carriers
on many networks.

00:38:06.006 --> 00:38:09.316 A:middle
Support IPv6 in your
applications.

00:38:09.846 --> 00:38:13.656 A:middle
Support IPv6 and
IPv4 in your servers.

00:38:15.146 --> 00:38:18.016 A:middle
For your text, UTF-8
is the new ASCII.

00:38:18.456 --> 00:38:19.866 A:middle
It's no harder than ASCII.

00:38:20.766 --> 00:38:22.366 A:middle
It's really very
simple to use it.

00:38:22.776 --> 00:38:26.096 A:middle
All of our devices
now have good support

00:38:26.316 --> 00:38:28.356 A:middle
for all the Unicode
characters in the fonts,

00:38:28.586 --> 00:38:29.856 A:middle
so you should have no worries

00:38:29.856 --> 00:38:32.236 A:middle
about supporting UTF-8
without hesitation.

00:38:33.266 --> 00:38:36.926 A:middle
And finally, we have new ways
for you to express intent

00:38:36.926 --> 00:38:38.076 A:middle
to the networking layers.

00:38:39.146 --> 00:38:41.936 A:middle
You can control when you don't
want to use cellular data,

00:38:42.796 --> 00:38:45.936 A:middle
and you now also
have finer control

00:38:46.306 --> 00:38:49.026 A:middle
of the throughput latency
characteristics of your data.

00:38:50.546 --> 00:38:53.016 A:middle
So with that, there's a link

00:38:53.356 --> 00:38:54.846 A:middle
where you can find
more information.

00:38:55.646 --> 00:38:58.676 A:middle
We have other sessions
that you can watch on video

00:38:58.676 --> 00:39:00.446 A:middle
that you may find interesting.

00:38:58.676 --> 00:39:00.446 A:middle
that you may find interesting.

00:39:00.446 --> 00:39:02.336 A:middle
We have sessions
about networking

00:39:02.336 --> 00:39:03.936 A:middle
and security, which
is important.

00:39:04.426 --> 00:39:05.576 A:middle
We have a couple
of other sessions

00:39:05.576 --> 00:39:07.106 A:middle
about internationalization.

00:39:07.806 --> 00:39:08.716 A:middle
We have some sessions

00:39:08.716 --> 00:39:12.216 A:middle
about higher layer networking
applications, like HomeKit.

00:39:12.586 --> 00:39:14.976 A:middle
So with that, thank
you for coming to WWDC.

00:39:15.516 --> 00:39:25.650 A:middle
[ Applause ]
