WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:19.500 A:middle
[ Music ]

00:00:26.516 --> 00:00:29.966 A:middle
[ Applause ]

00:00:30.466 --> 00:00:30.906 A:middle
&gt;&gt; Thank you.

00:00:33.066 --> 00:00:35.016 A:middle
Welcome. So, I'm Doug Gregor.

00:00:35.086 --> 00:00:37.316 A:middle
I'm here with my
colleague Michael Ilseman

00:00:37.646 --> 00:00:38.686 A:middle
to talk about design.

00:00:39.476 --> 00:00:42.386 A:middle
Because good design
makes us more productive.

00:00:42.946 --> 00:00:46.806 A:middle
And good API design helps
us write code that is clear,

00:00:47.056 --> 00:00:49.026 A:middle
concise and beautiful in Swift.

00:00:49.106 --> 00:00:52.596 A:middle
And that's every bit as true
whether you're writing your API

00:00:52.596 --> 00:00:55.016 A:middle
for a million other
developers or just

00:00:55.016 --> 00:00:56.696 A:middle
for yourself inside
your own app.

00:00:57.556 --> 00:00:59.106 A:middle
Because good design
really does matter.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:00.616 --> 00:01:03.236 A:middle
So, we're going to be talking

00:01:03.236 --> 00:01:05.355 A:middle
about the Swift API
Design Guidelines today.

00:01:05.726 --> 00:01:08.506 A:middle
These are new guidelines we're
introducing with Swift 3.

00:01:09.296 --> 00:01:10.956 A:middle
We're going to talk about
the philosophy behind

00:01:10.956 --> 00:01:11.776 A:middle
these guidelines.

00:01:12.006 --> 00:01:14.356 A:middle
Talk through some of them
to try to get a sense of how

00:01:14.356 --> 00:01:16.746 A:middle
to build great Swift APIs.

00:01:18.376 --> 00:01:22.646 A:middle
Now, then we're going to talk
about the Grand Renaming.

00:01:23.226 --> 00:01:25.216 A:middle
Which is what we like
to call the application

00:01:25.216 --> 00:01:28.916 A:middle
of these guidelines to all of
the APIs you use day to day.

00:01:29.316 --> 00:01:30.416 A:middle
Swift Standard Library.

00:01:30.696 --> 00:01:32.966 A:middle
Cocoa and Cocoa Touch APIs.

00:01:32.966 --> 00:01:34.146 A:middle
Now, this Grand Renaming
is going

00:01:34.146 --> 00:01:36.216 A:middle
to affect a lot of your code.

00:01:37.866 --> 00:01:39.066 A:middle
Pretty much all the
code that you've written

00:01:39.066 --> 00:01:41.836 A:middle
in Swift 2 is going to change
in some sense in Swift 3.

00:01:42.556 --> 00:01:42.966 A:middle
&gt;&gt; Whooh!

00:01:43.366 --> 00:01:43.816 A:middle
&gt;&gt; Yes!

00:01:44.516 --> 00:01:46.546 A:middle
[ Applause ]

00:01:47.046 --> 00:01:48.796 A:middle
So, we're going to talk through
what that means for your code.

00:01:49.816 --> 00:01:50.906 A:middle
And how to deal with it.

00:01:50.906 --> 00:01:53.156 A:middle
And starting thinking
in Swift 3.

00:01:54.186 --> 00:01:57.306 A:middle
Finally, we're going to talk
about some new tools and tricks

00:01:57.306 --> 00:02:01.036 A:middle
that we have for mapping
C and Objective-C APIs


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:57.306 --> 00:02:01.036 A:middle
that we have for mapping
C and Objective-C APIs

00:02:01.246 --> 00:02:03.416 A:middle
into beautiful Swift APIs.

00:02:03.416 --> 00:02:07.726 A:middle
That's a whole lot
of what and how.

00:02:08.196 --> 00:02:10.265 A:middle
The biggest question
you probably have

00:02:10.265 --> 00:02:12.836 A:middle
about the guidelines is why?

00:02:14.686 --> 00:02:16.256 A:middle
Why, after two years of working

00:02:16.256 --> 00:02:18.586 A:middle
with Swift are we changing
all the APIs that you work

00:02:18.586 --> 00:02:19.856 A:middle
with on a daily basis?

00:02:21.096 --> 00:02:24.116 A:middle
And the answer comes down to
the character of the language.

00:02:24.176 --> 00:02:26.386 A:middle
Because every programing
language has its own

00:02:26.386 --> 00:02:27.846 A:middle
distinctive character.

00:02:28.186 --> 00:02:30.116 A:middle
It has its own syntactic feel.

00:02:31.366 --> 00:02:33.386 A:middle
But it's more than the syntax.

00:02:33.486 --> 00:02:35.416 A:middle
It's also the kinds of tradeoffs

00:02:35.416 --> 00:02:37.206 A:middle
that that language
decides to make.

00:02:37.366 --> 00:02:40.316 A:middle
Does it skew toward
safety, performance?

00:02:40.316 --> 00:02:43.666 A:middle
Do you care about some
mathematical terseness

00:02:43.716 --> 00:02:46.426 A:middle
or something that is
clear and easy to read?

00:02:46.426 --> 00:02:51.596 A:middle
You take a look at Swift code,
and it's instantly recognizable.

00:02:51.876 --> 00:02:55.806 A:middle
And you can see Swift
rendering an opinion

00:02:55.806 --> 00:02:56.976 A:middle
about certain things here.

00:02:56.976 --> 00:02:58.736 A:middle
It uses trailing closures.

00:02:59.016 --> 00:03:00.306 A:middle
So the control flow works


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.016 --> 00:03:00.306 A:middle
So the control flow works

00:03:00.306 --> 00:03:02.696 A:middle
with your libraries
and your APIs nicely.

00:03:03.276 --> 00:03:04.816 A:middle
It has optionals, so you have

00:03:04.876 --> 00:03:07.166 A:middle
to consider the possibility
of nil everywhere.

00:03:07.166 --> 00:03:10.986 A:middle
You can't just ignore that
this possibility exists.

00:03:11.356 --> 00:03:15.106 A:middle
And so, when you're working
with Swift it feels like Swift.

00:03:15.776 --> 00:03:18.266 A:middle
But it's not just the
language contributing to it.

00:03:18.266 --> 00:03:21.316 A:middle
It's really the APIs you
use day in and day out.

00:03:21.676 --> 00:03:25.246 A:middle
And these APIs have to meld with
the character of the language.

00:03:25.556 --> 00:03:28.046 A:middle
So you get a consistent,
whole experience of working

00:03:28.046 --> 00:03:29.426 A:middle
with beautiful Swift code.

00:03:31.276 --> 00:03:34.776 A:middle
Now, these are some Cocoa
and Cocoa Touch APIs.

00:03:35.706 --> 00:03:38.596 A:middle
And these APIs were
designed based

00:03:38.596 --> 00:03:40.216 A:middle
on the coding guidelines
for Cocoa.

00:03:41.336 --> 00:03:42.356 A:middle
You may have read these before.

00:03:42.356 --> 00:03:43.146 A:middle
I hope you have.

00:03:43.666 --> 00:03:46.896 A:middle
They espouse clarity
and consistency

00:03:47.436 --> 00:03:48.536 A:middle
in the design of APIs.

00:03:48.536 --> 00:03:53.326 A:middle
And we've been applying these to
thousands upon thousands of APIs

00:03:53.326 --> 00:03:56.476 A:middle
over more than a decade, all
right, to produce the Cocoa

00:03:56.476 --> 00:03:57.776 A:middle
and Cocoa Touch platforms.

00:03:57.776 --> 00:03:59.246 A:middle
And these wonderful APIs we use.

00:03:59.876 --> 00:04:02.096 A:middle
Now, these guidelines
were designed


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.876 --> 00:04:02.096 A:middle
Now, these guidelines
were designed

00:04:02.706 --> 00:04:07.076 A:middle
for a different language
with a different character.

00:04:08.356 --> 00:04:12.026 A:middle
And so, when you bring all of
these APIs that were written

00:04:12.026 --> 00:04:15.426 A:middle
for Objective-C into
Swift unmodified,

00:04:16.375 --> 00:04:18.796 A:middle
they seemed a little
bit out of character.

00:04:18.796 --> 00:04:20.995 A:middle
They feel a bit not-Swifty.

00:04:22.506 --> 00:04:23.496 A:middle
What's that even mean?

00:04:24.236 --> 00:04:25.216 A:middle
Not Swifty?

00:04:26.206 --> 00:04:26.856 A:middle
You hear it a lot.

00:04:27.886 --> 00:04:32.386 A:middle
But in essence, this is why
two years in to having Swift

00:04:32.386 --> 00:04:35.076 A:middle
as a platform that
many thousands

00:04:35.076 --> 00:04:38.246 A:middle
of developers are using, is
the right time to reevaluate.

00:04:38.846 --> 00:04:41.646 A:middle
Because we have experience
from a much larger community

00:04:41.646 --> 00:04:44.506 A:middle
to understand what works
well in Swift code.

00:04:45.456 --> 00:04:50.916 A:middle
And so we set off to design the
API Design Guidelines to try

00:04:50.916 --> 00:04:53.386 A:middle
to codify what it is
to build a Swifty API

00:04:53.386 --> 00:04:57.186 A:middle
and help everyone build more
consistent, more clear APIs

00:04:57.186 --> 00:04:58.526 A:middle
within this language
that we love.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.476 --> 00:05:03.826 A:middle
Now, in the lower
left you see SE-0023.

00:05:04.136 --> 00:05:06.146 A:middle
That's the Swift
evolution proposal number

00:05:06.146 --> 00:05:09.426 A:middle
that contains all of the
API Design Guidelines.

00:05:09.706 --> 00:05:11.716 A:middle
You'll see these proposal
numbers throughout the talk.

00:05:12.336 --> 00:05:14.006 A:middle
Again, you can go
look at Swift.org,

00:05:14.136 --> 00:05:16.456 A:middle
look up this proposal number
to see more information

00:05:16.496 --> 00:05:20.066 A:middle
about that particular change
to the Swift language.

00:05:20.676 --> 00:05:23.196 A:middle
But for now, let's talk about
the guidelines themselves.

00:05:24.576 --> 00:05:28.376 A:middle
The main principles of the
Swift API design guidelines are

00:05:28.376 --> 00:05:31.026 A:middle
clarity at the point of use.

00:05:31.096 --> 00:05:34.146 A:middle
Where your API shows up
in someone else's code.

00:05:36.306 --> 00:05:38.156 A:middle
And we love concise code.

00:05:38.236 --> 00:05:41.026 A:middle
But the clarity is the
most important aspect.

00:05:41.026 --> 00:05:43.326 A:middle
It's more important
than having brief code.

00:05:44.486 --> 00:05:47.086 A:middle
That said, concise code
does happen in Swift.

00:05:47.366 --> 00:05:49.426 A:middle
Swift code does tend
to be more concise.

00:05:49.476 --> 00:05:50.896 A:middle
We can feel it when we
look at the language.

00:05:50.896 --> 00:05:53.486 A:middle
And we see it in actual
metrics when we talk about apps

00:05:53.486 --> 00:05:56.876 A:middle
that have been ported into
Swift and written in Swift.

00:05:56.876 --> 00:06:00.486 A:middle
But that comes from using
the right contextual cues.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:56.876 --> 00:06:00.486 A:middle
But that comes from using
the right contextual cues.

00:06:01.046 --> 00:06:03.046 A:middle
Let's dive into these
principles a little bit more

00:06:03.046 --> 00:06:04.286 A:middle
and look at some APIs.

00:06:05.216 --> 00:06:07.656 A:middle
So, we're going to
talk about usage first.

00:06:09.366 --> 00:06:10.966 A:middle
So why focus on the use sites?

00:06:11.236 --> 00:06:13.236 A:middle
Well, for one, it's just
a simple numbers game.

00:06:13.236 --> 00:06:15.046 A:middle
You're going to write
your API once.

00:06:15.636 --> 00:06:18.506 A:middle
People will look at that
API in code, or maybe look

00:06:18.506 --> 00:06:21.036 A:middle
at the documentation for
it a couple of times.

00:06:21.556 --> 00:06:25.096 A:middle
But the vast majority of
times that your API matters,

00:06:25.096 --> 00:06:28.646 A:middle
the number of times it's seen,
it's going to be in the context

00:06:28.956 --> 00:06:30.336 A:middle
of a whole lot of other code.

00:06:30.836 --> 00:06:33.716 A:middle
And when you're in that
context, you have all

00:06:33.716 --> 00:06:35.866 A:middle
of this extra rich
contextual information.

00:06:36.496 --> 00:06:40.606 A:middle
You have the local variables,
their names, their types.

00:06:41.316 --> 00:06:43.416 A:middle
You have uses of related APIs.

00:06:43.466 --> 00:06:45.266 A:middle
And so the goal of
your API isn't

00:06:45.266 --> 00:06:46.906 A:middle
to stand up and say, "Hello!

00:06:46.906 --> 00:06:48.786 A:middle
I'm here and I have
a nice big name."

00:06:49.586 --> 00:06:52.876 A:middle
The goal of your API is to fit
in with the rest of the code

00:06:53.186 --> 00:06:54.896 A:middle
so that the end result
is beautiful.

00:06:55.506 --> 00:06:59.696 A:middle
Now, when you're focusing on
use cases, resist the temptation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:00.456 --> 00:07:02.136 A:middle
to optimize for bad code.

00:07:03.346 --> 00:07:05.906 A:middle
It is absolutely true that
someone can go and use names

00:07:05.906 --> 00:07:08.476 A:middle
like A and B and C
for all the variables.

00:07:08.766 --> 00:07:10.816 A:middle
And this code is
not clear anymore.

00:07:11.416 --> 00:07:16.666 A:middle
You can't fix this bad
code with your API alone.

00:07:18.086 --> 00:07:21.756 A:middle
All you can do is make other
code more verbose or less clear.

00:07:22.986 --> 00:07:25.416 A:middle
So focus on proper use cases.

00:07:25.416 --> 00:07:28.666 A:middle
Focus on the beautiful code
and tune your API for that.

00:07:29.876 --> 00:07:32.296 A:middle
Let's actually look at
a specific example here.

00:07:32.576 --> 00:07:34.236 A:middle
And so we're going
to start with an API

00:07:34.436 --> 00:07:37.236 A:middle
that is removing an
item from a collection.

00:07:37.706 --> 00:07:40.196 A:middle
We're going to start by
calling it removeItem.

00:07:40.976 --> 00:07:41.836 A:middle
Sounds good.

00:07:41.836 --> 00:07:43.706 A:middle
But I've made my first mistake.

00:07:43.856 --> 00:07:45.546 A:middle
This is not a use case.

00:07:45.616 --> 00:07:47.456 A:middle
This is just a name
in the abstract.

00:07:48.006 --> 00:07:51.006 A:middle
So, let's bring up a use case
that I have in mind today.

00:07:51.746 --> 00:07:52.416 A:middle
Don't ask why.

00:07:52.706 --> 00:07:56.946 A:middle
He knows. So, remove item
ted from the list of friends.

00:07:57.906 --> 00:08:00.596 A:middle
Now, you'll notice that
there's actually two things


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:57.906 --> 00:08:00.596 A:middle
Now, you'll notice that
there's actually two things

00:08:00.596 --> 00:08:02.216 A:middle
in this use case
that are referring

00:08:02.216 --> 00:08:03.676 A:middle
to what the argument is.

00:08:03.676 --> 00:08:05.146 A:middle
They're trying to
describe the argument.

00:08:05.636 --> 00:08:07.786 A:middle
There's the word item
that's part of our name.

00:08:07.786 --> 00:08:10.326 A:middle
And then there's
the argument ted

00:08:10.416 --> 00:08:12.096 A:middle
which is some local
variable with a type.

00:08:12.976 --> 00:08:18.586 A:middle
Of these two, the variable ted
is the actual better descriptor

00:08:18.586 --> 00:08:19.546 A:middle
of what the argument is.

00:08:19.976 --> 00:08:21.086 A:middle
It's in context.

00:08:21.206 --> 00:08:23.516 A:middle
As you're reading this call
in context, you know what

00:08:23.516 --> 00:08:24.556 A:middle
that local variable is.

00:08:24.556 --> 00:08:25.456 A:middle
It means something.

00:08:25.456 --> 00:08:27.826 A:middle
It has a strong type.

00:08:28.016 --> 00:08:29.806 A:middle
So maybe the problem
here is really

00:08:30.246 --> 00:08:33.285 A:middle
that the word item isn't
sufficiently descriptive.

00:08:33.785 --> 00:08:35.366 A:middle
Maybe we'd feel a little
bit more comfortable

00:08:35.366 --> 00:08:36.626 A:middle
if it were called removeObject.

00:08:38.126 --> 00:08:39.635 A:middle
Well, that's probably not right,

00:08:39.635 --> 00:08:41.876 A:middle
because we're probably using
value types here anyway.

00:08:41.876 --> 00:08:43.655 A:middle
So it's just actively wrong.

00:08:44.066 --> 00:08:46.016 A:middle
We could say, hmm,
removeElement.

00:08:46.906 --> 00:08:49.686 A:middle
Okay. Collections in Swift
use the term element.

00:08:50.686 --> 00:08:52.886 A:middle
But, it's not helping us any.

00:08:53.716 --> 00:08:55.226 A:middle
And moreover, if we
were to start writing

00:08:55.226 --> 00:08:56.656 A:middle
down different use cases,

00:08:56.906 --> 00:08:59.326 A:middle
it might actually
become less clear.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.426 --> 00:09:02.066 A:middle
Here I want to remove
element caffeine

00:09:02.066 --> 00:09:03.666 A:middle
from a list of organic
compounds.

00:09:04.486 --> 00:09:05.186 A:middle
That's misleading.

00:09:05.186 --> 00:09:05.836 A:middle
It's wrong.

00:09:05.836 --> 00:09:07.006 A:middle
Caffeine is not an element.

00:09:07.006 --> 00:09:09.086 A:middle
It's a compound made
up of elements.

00:09:09.626 --> 00:09:12.166 A:middle
So, our attempt at using
some innocuous word here

00:09:12.166 --> 00:09:14.626 A:middle
to describe the argument
has actually led us

00:09:14.626 --> 00:09:16.606 A:middle
to less clear use cases.

00:09:17.966 --> 00:09:22.406 A:middle
Okay. So maybe the problem
is that we should stop trying

00:09:22.406 --> 00:09:24.726 A:middle
to get these innocuous sort
of general words in there

00:09:24.726 --> 00:09:25.926 A:middle
and we should be
really specific.

00:09:26.506 --> 00:09:28.836 A:middle
Remove person ted from
the list of friends.

00:09:29.416 --> 00:09:31.866 A:middle
It's a little awkward
in English.

00:09:32.616 --> 00:09:33.276 A:middle
I wouldn't say that.

00:09:33.276 --> 00:09:34.206 A:middle
I would just say, remove(ted).

00:09:35.056 --> 00:09:40.006 A:middle
But moreover, if I do this, if
I try to get really specific

00:09:40.616 --> 00:09:43.716 A:middle
for this generic API,
well now I expect

00:09:43.716 --> 00:09:44.976 A:middle
to be specific everywhere.

00:09:45.076 --> 00:09:49.016 A:middle
And now there's one conceptual
API of just removing an item

00:09:49.016 --> 00:09:51.616 A:middle
from a collection has
different names throughout the

00:09:51.616 --> 00:09:52.476 A:middle
source base.

00:09:53.766 --> 00:09:55.366 A:middle
That makes it harder
to understand.

00:09:55.366 --> 00:09:57.076 A:middle
It's harder to recognize
that actually we're talking

00:09:57.076 --> 00:09:59.296 A:middle
about the same thing
in different contexts.

00:09:59.756 --> 00:10:04.976 A:middle
So, the Swift API Design
Guidelines go a different route.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.756 --> 00:10:04.976 A:middle
So, the Swift API Design
Guidelines go a different route.

00:10:05.246 --> 00:10:07.336 A:middle
Omit needless words.

00:10:09.036 --> 00:10:12.396 A:middle
If a word is not
contributing to the clarity

00:10:12.396 --> 00:10:14.326 A:middle
of the use site,
don't put it in.

00:10:15.116 --> 00:10:17.096 A:middle
So we can just say, remove(ted)
from the list of friends.

00:10:17.096 --> 00:10:18.116 A:middle
It reads really nicely.

00:10:18.936 --> 00:10:22.926 A:middle
Now, one of the reasons this
works so beautifully in Swift is

00:10:22.926 --> 00:10:28.186 A:middle
that it has a strong static
type system to make sure

00:10:28.276 --> 00:10:30.936 A:middle
that you don't write
nonsensical code and again,

00:10:30.936 --> 00:10:32.086 A:middle
interpret it in the wrong way.

00:10:32.416 --> 00:10:35.216 A:middle
And so the strong static
type system is making sure

00:10:35.406 --> 00:10:38.466 A:middle
that the argument you passed
to remove is an element

00:10:38.466 --> 00:10:40.086 A:middle
of the corresponding collection.

00:10:41.396 --> 00:10:43.906 A:middle
If you were to do
something truly inadvisable,

00:10:44.036 --> 00:10:47.166 A:middle
like for example, try to
remove caffeine from your list

00:10:47.166 --> 00:10:49.746 A:middle
of friends, you're going
to get an error message

00:10:49.746 --> 00:10:54.016 A:middle
from the compiler telling you
that that doesn't make sense.

00:10:54.676 --> 00:10:58.256 A:middle
So, we've talked about
readability of the use sites.

00:10:59.436 --> 00:11:03.136 A:middle
And we've eliminated a bunch
of words, which might put you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.436 --> 00:11:03.136 A:middle
And we've eliminated a bunch
of words, which might put you

00:11:03.136 --> 00:11:05.096 A:middle
in the mind that what we're
looking for is terse code.

00:11:06.136 --> 00:11:06.756 A:middle
That's not true.

00:11:06.756 --> 00:11:07.846 A:middle
We want clear code.

00:11:08.816 --> 00:11:13.816 A:middle
But, clear code has to hit
the correct point in this sort

00:11:13.816 --> 00:11:16.086 A:middle
of spectrum of terseness
to verbosity.

00:11:16.506 --> 00:11:20.426 A:middle
And if you think about what is
verbose code, verbose code is

00:11:20.426 --> 00:11:23.586 A:middle
when you have extra information
in there that you don't need.

00:11:25.146 --> 00:11:27.656 A:middle
And verbose code
actually hurts clarity.

00:11:27.926 --> 00:11:30.146 A:middle
Because what is your mind
doing as you're reading

00:11:30.146 --> 00:11:31.496 A:middle
through this verbose code?

00:11:32.246 --> 00:11:35.476 A:middle
It's trying to filter out
all of this extra noise,

00:11:35.656 --> 00:11:37.676 A:middle
all the things you don't need
because they're redundant,

00:11:37.906 --> 00:11:39.526 A:middle
to find the actual
signal in there.

00:11:40.996 --> 00:11:43.196 A:middle
Now, the other end of the
spectrum is also not good.

00:11:43.196 --> 00:11:44.846 A:middle
If you have code
that is too terse,

00:11:45.206 --> 00:11:48.346 A:middle
then you're missing critical
information that you need

00:11:48.346 --> 00:11:50.106 A:middle
to understand that code.

00:11:51.416 --> 00:11:53.056 A:middle
A sign that this is happening,

00:11:53.056 --> 00:11:54.676 A:middle
that you've made
things too terse,

00:11:54.776 --> 00:11:57.426 A:middle
is when you're reading code
and you find yourself jumping

00:11:57.426 --> 00:11:59.516 A:middle
to the API documentation
all the time

00:11:59.766 --> 00:12:02.656 A:middle
because the APIs themselves
are insufficiently descriptive.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.766 --> 00:12:02.656 A:middle
because the APIs themselves
are insufficiently descriptive.

00:12:03.246 --> 00:12:06.156 A:middle
So we're looking for this
sort sweet spot in the middle

00:12:06.516 --> 00:12:11.076 A:middle
where you get clear
code that is concise.

00:12:11.366 --> 00:12:14.066 A:middle
So all of the information you
need to understand those APIs

00:12:14.066 --> 00:12:17.656 A:middle
and how they work is there in
the contextual information.

00:12:18.556 --> 00:12:21.196 A:middle
This is actually a principle
of the Swift language itself.

00:12:21.196 --> 00:12:23.126 A:middle
So I'm going to put up
a bunch of code here.

00:12:24.606 --> 00:12:29.306 A:middle
And in this bunch of code we
actually have verbosity that's

00:12:29.306 --> 00:12:30.516 A:middle
not needed in Swift.

00:12:30.876 --> 00:12:34.156 A:middle
That verbosity is all of these
explicit type annotations.

00:12:34.926 --> 00:12:36.956 A:middle
These aren't adding
to readability.

00:12:38.016 --> 00:12:39.676 A:middle
You can get a sense of
what the types are just

00:12:39.676 --> 00:12:41.096 A:middle
by reading the APIs.

00:12:41.146 --> 00:12:43.726 A:middle
And indeed, in Swift you
probably wouldn't write the code

00:12:43.726 --> 00:12:44.236 A:middle
this way.

00:12:44.436 --> 00:12:46.956 A:middle
You would probably align
that type information

00:12:46.956 --> 00:12:48.926 A:middle
and let the static type
trebicore [phonetic] do it

00:12:49.026 --> 00:12:51.236 A:middle
for you leading to
more concise code

00:12:51.406 --> 00:12:53.276 A:middle
that you can still read
through just as well.

00:12:53.406 --> 00:12:56.316 A:middle
Now of course, types
are important.

00:12:56.316 --> 00:12:57.396 A:middle
And the types are there.

00:12:57.786 --> 00:13:00.356 A:middle
And if you need reassurance
about what a particular type is,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:57.786 --> 00:13:00.356 A:middle
And if you need reassurance
about what a particular type is,

00:13:00.356 --> 00:13:02.116 A:middle
if it'd help your
understanding, of course,

00:13:02.116 --> 00:13:05.166 A:middle
the answer is just an option
click away inside Xcode.

00:13:06.816 --> 00:13:10.306 A:middle
So let's look at another
API and try to talk

00:13:10.306 --> 00:13:13.666 A:middle
about when a word
actually is needed

00:13:13.926 --> 00:13:15.816 A:middle
to help describe an argument.

00:13:16.866 --> 00:13:19.726 A:middle
We'll take this little API
here that adds a child view

00:13:20.326 --> 00:13:23.536 A:middle
at some particular point
within some main view.

00:13:24.156 --> 00:13:25.446 A:middle
And so we write out a use case.

00:13:25.616 --> 00:13:26.786 A:middle
Always start with the use case.

00:13:27.116 --> 00:13:29.286 A:middle
And think about the words
that apply to the arguments.

00:13:29.626 --> 00:13:32.796 A:middle
So in the first case we have
the word child is applying

00:13:32.796 --> 00:13:35.326 A:middle
to this view argument that
is our first argument.

00:13:36.126 --> 00:13:37.576 A:middle
Is child adding something?

00:13:38.116 --> 00:13:39.646 A:middle
Well, we know from
the static type system

00:13:39.646 --> 00:13:42.426 A:middle
that sidebar is going to
be a view of some sort.

00:13:42.906 --> 00:13:47.556 A:middle
But this word child
is clarifying the role

00:13:47.556 --> 00:13:49.466 A:middle
of this parameter
in the operation.

00:13:49.516 --> 00:13:53.276 A:middle
It's stating that this argument
here will become a child.

00:13:53.276 --> 00:13:54.826 A:middle
It's establishing hierarchy.

00:13:55.296 --> 00:13:56.756 A:middle
That's really important
information

00:13:56.756 --> 00:14:02.146 A:middle
for understanding
what this API does.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:56.756 --> 00:14:02.146 A:middle
for understanding
what this API does.

00:14:02.636 --> 00:14:07.426 A:middle
Now, in the second argument, we
have atPoint and then origin.

00:14:07.746 --> 00:14:08.946 A:middle
What's origin going to be?

00:14:08.946 --> 00:14:10.546 A:middle
Well, it's going
to be a CGPoint.

00:14:10.836 --> 00:14:12.526 A:middle
This API is going
to take CGPoints.

00:14:12.526 --> 00:14:14.966 A:middle
And you can't provide anything
other than a CGPoint here.

00:14:16.946 --> 00:14:19.046 A:middle
So this word, it's
not adding anything.

00:14:19.046 --> 00:14:21.416 A:middle
It's just restating
information that's already

00:14:21.446 --> 00:14:24.476 A:middle
in the strong static type
system that will be enforced

00:14:24.586 --> 00:14:26.246 A:middle
by the Swift language.

00:14:26.836 --> 00:14:27.516 A:middle
So take it away.

00:14:27.586 --> 00:14:28.356 A:middle
You don't need it.

00:14:29.016 --> 00:14:30.826 A:middle
And now notice what the
call site looks like here.

00:14:30.826 --> 00:14:35.046 A:middle
If we read it out, you add the
child sidebar at the origin.

00:14:36.456 --> 00:14:37.456 A:middle
It reads grammatically.

00:14:38.156 --> 00:14:38.396 A:middle
All right?

00:14:38.856 --> 00:14:39.926 A:middle
This is one of the principles

00:14:39.926 --> 00:14:43.826 A:middle
of this particular API
Design Guidelines is

00:14:43.826 --> 00:14:47.026 A:middle
that we really want the use
sites to read grammatically.

00:14:47.686 --> 00:14:49.856 A:middle
And we had this for our
example here of remove(ted)

00:14:50.736 --> 00:14:51.736 A:middle
from our list of friends.

00:14:52.576 --> 00:14:54.486 A:middle
Now, let's look at
a very related API.

00:14:54.486 --> 00:14:57.726 A:middle
So this is removing
specifically some element.

00:14:58.186 --> 00:15:00.966 A:middle
If we look at, say, the
API that removed something


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.186 --> 00:15:00.966 A:middle
If we look at, say, the
API that removed something

00:15:00.966 --> 00:15:01.886 A:middle
in a particular position.

00:15:02.146 --> 00:15:02.666 A:middle
Read it out.

00:15:03.196 --> 00:15:06.806 A:middle
Remove position of former
friend from the collection.

00:15:07.226 --> 00:15:07.836 A:middle
It's not right.

00:15:08.276 --> 00:15:10.496 A:middle
This isn't the collection
of positions.

00:15:10.846 --> 00:15:12.176 A:middle
This is a collection of people.

00:15:13.576 --> 00:15:18.926 A:middle
To actually make this read
well we want to say, remove at.

00:15:19.476 --> 00:15:23.456 A:middle
Let's read this out remove at
the position of former friend.

00:15:23.996 --> 00:15:29.436 A:middle
Notice how we've clarified the
behavior of the API by putting

00:15:29.436 --> 00:15:32.076 A:middle
in this first argument label
to describe the relationship

00:15:32.076 --> 00:15:34.796 A:middle
of the argument to the method.

00:15:36.796 --> 00:15:39.416 A:middle
This brings us to naming
and the idea of naming.

00:15:39.656 --> 00:15:43.266 A:middle
So, in Swift, a function
name is comprised

00:15:43.266 --> 00:15:46.226 A:middle
of so-called base name,
which here is remove in both

00:15:46.226 --> 00:15:48.586 A:middle
of these APIs, as well as all

00:15:48.586 --> 00:15:51.496 A:middle
of the argument labels
for the arguments.

00:15:51.546 --> 00:15:55.116 A:middle
And so these two related APIs,
they share the same base name

00:15:55.116 --> 00:15:57.776 A:middle
of remove because they're in
this method family of operations

00:15:57.776 --> 00:15:59.366 A:middle
that remove something
from a collection.

00:15:59.846 --> 00:16:01.556 A:middle
But their argument
labels are different


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.846 --> 00:16:01.556 A:middle
But their argument
labels are different

00:16:02.316 --> 00:16:04.366 A:middle
because they do different
things.

00:16:04.436 --> 00:16:07.356 A:middle
One removes an element
by its identity.

00:16:07.686 --> 00:16:10.016 A:middle
The other one removes
its element based

00:16:10.016 --> 00:16:11.796 A:middle
on its position in the sequence.

00:16:12.656 --> 00:16:15.076 A:middle
So slightly different
APIs have different names.

00:16:15.486 --> 00:16:19.426 A:middle
Now, you can overload
based on type information.

00:16:19.636 --> 00:16:22.686 A:middle
And if two APIs that share
the same compound name.

00:16:23.216 --> 00:16:24.856 A:middle
But you should only do this

00:16:25.336 --> 00:16:28.206 A:middle
when the APIs have
the same semantics.

00:16:28.586 --> 00:16:30.616 A:middle
So it's fine to overload
the append name

00:16:30.616 --> 00:16:33.056 A:middle
with no argument label
here to append a character

00:16:33.056 --> 00:16:34.296 A:middle
or a string to some text.

00:16:34.596 --> 00:16:36.726 A:middle
Because fundamentally these
are the same operation.

00:16:37.026 --> 00:16:40.876 A:middle
They're just overloaded on
different types for convenience.

00:16:41.276 --> 00:16:43.696 A:middle
Now, when you're coming up with
first argument labels, again,

00:16:43.806 --> 00:16:47.666 A:middle
you want that use case
to read grammatically.

00:16:47.716 --> 00:16:50.586 A:middle
And that includes the base
name of the method as well

00:16:50.586 --> 00:16:51.676 A:middle
as the argument label.

00:16:52.216 --> 00:16:55.956 A:middle
So my first API here
removeBoxes (withLabel:WWDC).

00:16:57.206 --> 00:16:58.306 A:middle
Notice how that reads well.

00:16:58.676 --> 00:17:02.676 A:middle
Now, inside that API we
have a prepositional phrase.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.676 --> 00:17:02.676 A:middle
Now, inside that API we
have a prepositional phrase.

00:17:02.676 --> 00:17:04.626 A:middle
So it's a little bit of
English grammar here.

00:17:04.626 --> 00:17:06.226 A:middle
But essentially it's withLabel.

00:17:06.455 --> 00:17:09.596 A:middle
And it describes the
relationship of the argument

00:17:10.156 --> 00:17:12.705 A:middle
to the actual operation
of removing boxes.

00:17:12.766 --> 00:17:14.636 A:middle
And so when you have one of
these prepositional phrases,

00:17:14.886 --> 00:17:16.106 A:middle
put it on the first
argument label

00:17:16.106 --> 00:17:17.586 A:middle
to describe the first argument.

00:17:19.616 --> 00:17:21.336 A:middle
You also use first
argument labels

00:17:21.406 --> 00:17:23.766 A:middle
if you essentially can't
form a grammatical phrase

00:17:23.955 --> 00:17:25.215 A:middle
because it would be misleading

00:17:25.336 --> 00:17:26.675 A:middle
to have the first
argument in there.

00:17:27.056 --> 00:17:28.486 A:middle
And so here we have
a viewController.

00:17:28.486 --> 00:17:29.716 A:middle
And we say dismiss(true).

00:17:29.716 --> 00:17:32.186 A:middle
What is that?

00:17:32.186 --> 00:17:34.536 A:middle
I can't banish a Boolean
constant to anywhere.

00:17:35.956 --> 00:17:38.166 A:middle
And so to make this
read grammatically,

00:17:38.406 --> 00:17:39.886 A:middle
I need to put an
argument label in there.

00:17:40.656 --> 00:17:41.756 A:middle
Dismiss the viewController.

00:17:42.346 --> 00:17:43.186 A:middle
And it's animated.

00:17:43.186 --> 00:17:44.076 A:middle
Animated is true.

00:17:44.266 --> 00:17:46.276 A:middle
And so this is extra
information that's coming along.

00:17:46.546 --> 00:17:50.376 A:middle
The first argument label breaks
it up so that it reads well

00:17:50.686 --> 00:17:53.806 A:middle
and it's clear that what
we're dismissing is the actual

00:17:53.806 --> 00:17:54.516 A:middle
view controller.

00:17:55.446 --> 00:17:56.876 A:middle
There are a couple of
other rules you can read

00:17:56.876 --> 00:17:57.906 A:middle
about on Swift.org.

00:17:58.286 --> 00:18:01.646 A:middle
But essentially you still will
omit first argument labels


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.286 --> 00:18:01.646 A:middle
But essentially you still will
omit first argument labels

00:18:01.646 --> 00:18:02.516 A:middle
in some cases.

00:18:02.756 --> 00:18:06.056 A:middle
And these are cases where
in the API it reads well

00:18:06.056 --> 00:18:08.546 A:middle
to just have the argument
there, insert michael

00:18:08.866 --> 00:18:10.496 A:middle
at the start index of friends.

00:18:11.656 --> 00:18:12.266 A:middle
That reads well.

00:18:12.266 --> 00:18:14.846 A:middle
We don't need a first argument
label to make it read well,

00:18:14.846 --> 00:18:16.326 A:middle
and so we leave it out.

00:18:17.346 --> 00:18:21.406 A:middle
Okay. Let's talk
a little bit more

00:18:21.406 --> 00:18:22.746 A:middle
about naming before we move on.

00:18:23.506 --> 00:18:27.746 A:middle
So, when you name a method, name
it based on its side effects.

00:18:28.016 --> 00:18:31.086 A:middle
So, use English verbs, commands,

00:18:31.086 --> 00:18:33.876 A:middle
to tell the receiver
do something.

00:18:34.866 --> 00:18:37.236 A:middle
So here we might say, okay, we
have the friends collection.

00:18:37.456 --> 00:18:37.976 A:middle
Reverse it.

00:18:38.246 --> 00:18:39.806 A:middle
A viewController, present it.

00:18:40.146 --> 00:18:41.906 A:middle
Organic compounds, append to it.

00:18:42.646 --> 00:18:44.256 A:middle
Right? These are actions taken.

00:18:44.526 --> 00:18:46.136 A:middle
We name based on
the actions taken.

00:18:46.856 --> 00:18:50.546 A:middle
Now, when we have methods whose
primary responsibility is just

00:18:50.676 --> 00:18:55.916 A:middle
to return some value
we use a noun.

00:18:56.036 --> 00:18:58.896 A:middle
Describe the thing
that is being returned.

00:18:59.446 --> 00:19:02.156 A:middle
And so here we can ask for the
background title of a button


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.446 --> 00:19:02.156 A:middle
And so here we can ask for the
background title of a button

00:19:02.246 --> 00:19:06.046 A:middle
or the suffix of
this friends array.

00:19:07.226 --> 00:19:09.266 A:middle
Now, when you're
dealing with value types,

00:19:10.636 --> 00:19:12.876 A:middle
it's sometimes the case that
you have both a mutating

00:19:12.876 --> 00:19:16.116 A:middle
and a non-mutating form of
essentially the same operation.

00:19:16.456 --> 00:19:17.746 A:middle
And here what we like to call --

00:19:17.746 --> 00:19:20.206 A:middle
we apply what we like
to call the ed/ing rule.

00:19:21.356 --> 00:19:24.646 A:middle
And so this follows
from English grammar.

00:19:24.646 --> 00:19:27.286 A:middle
And essentially you
start with the verb form.

00:19:27.466 --> 00:19:29.686 A:middle
And so here we have
reverse a collection.

00:19:29.686 --> 00:19:31.916 A:middle
You're commanding X
to reverse itself.

00:19:33.566 --> 00:19:36.276 A:middle
Now, for the more
noun-like other form,

00:19:36.466 --> 00:19:37.516 A:middle
we use the "ed" rule.

00:19:37.666 --> 00:19:39.996 A:middle
So we ask for X reversed.

00:19:39.996 --> 00:19:40.616 A:middle
All right?

00:19:40.616 --> 00:19:43.296 A:middle
Where we're describing what the
result is that we want to get.

00:19:43.296 --> 00:19:45.436 A:middle
And that corresponds
to the mutating form.

00:19:46.296 --> 00:19:47.786 A:middle
Now, when the "ed"
rule doesn't apply,

00:19:47.786 --> 00:19:49.606 A:middle
the "ing" rule generally does.

00:19:50.366 --> 00:19:52.266 A:middle
This is usually when we
have an argument here.

00:19:52.566 --> 00:19:53.826 A:middle
So we have a document directory.

00:19:53.906 --> 00:19:55.496 A:middle
We can append a path
component to it.

00:19:55.956 --> 00:19:56.726 A:middle
That's mutating.

00:19:56.726 --> 00:19:58.296 A:middle
We told it to append this.

00:19:59.356 --> 00:20:00.726 A:middle
Now we have the non-mutating
form.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.356 --> 00:20:00.726 A:middle
Now we have the non-mutating
form.

00:20:00.796 --> 00:20:03.616 A:middle
Give me the document directory
appending this particular

00:20:03.616 --> 00:20:04.216 A:middle
path component.

00:20:05.756 --> 00:20:10.886 A:middle
So these rules, and many, many
more, are described on Swift.org

00:20:10.886 --> 00:20:12.896 A:middle
as part of the API Design
Guidelines document.

00:20:13.386 --> 00:20:15.896 A:middle
Highly recommend that
you read them and try

00:20:15.896 --> 00:20:17.566 A:middle
to apply them to your own APIs.

00:20:18.406 --> 00:20:20.966 A:middle
But of course, these guidelines,

00:20:21.386 --> 00:20:23.466 A:middle
they're not interesting
unless they actually are

00:20:23.466 --> 00:20:24.406 A:middle
widely applied.

00:20:25.106 --> 00:20:28.156 A:middle
And this is why we set
off on the Grand Renaming.

00:20:28.796 --> 00:20:31.786 A:middle
Which is the application
of these guidelines

00:20:32.246 --> 00:20:35.246 A:middle
to the Swift Standard
Library, to the Cocoa

00:20:35.246 --> 00:20:39.986 A:middle
and Cocoa Touch APIs as well as
targeted improvements to APIs

00:20:39.986 --> 00:20:41.976 A:middle
like Core Graphics,
Grand Central Dispatch.

00:20:41.976 --> 00:20:45.766 A:middle
They're used all the time to
give them these Swifty makeovers

00:20:45.766 --> 00:20:46.876 A:middle
to be beautiful in Swift.

00:20:48.566 --> 00:20:50.866 A:middle
I talked a little bit about the
scale of the Grand Renaming.

00:20:51.006 --> 00:20:53.206 A:middle
So, this is a little screen shot

00:20:53.786 --> 00:20:56.536 A:middle
of a small Swift app called
Lister we've been shipping

00:20:56.536 --> 00:20:57.406 A:middle
for a couple years.

00:20:57.466 --> 00:20:58.816 A:middle
It's one of the sample
applications

00:20:59.646 --> 00:21:02.196 A:middle
when it's being migrated
from Swift 2 to Swift 3.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.646 --> 00:21:02.196 A:middle
when it's being migrated
from Swift 2 to Swift 3.

00:21:03.066 --> 00:21:05.496 A:middle
You can notice there's a whole
lot of .swift files on the left.

00:21:06.546 --> 00:21:09.846 A:middle
Basically every Swift file in
the entire project is changed

00:21:09.846 --> 00:21:12.016 A:middle
by the transition from
Swift 2 to Swift 3.

00:21:13.056 --> 00:21:15.416 A:middle
And if you're looking at some
of the details in the middle

00:21:15.416 --> 00:21:18.546 A:middle
and the right panes here,
you probably noticed that all

00:21:18.546 --> 00:21:21.066 A:middle
of these Cocoa API
names have changed.

00:21:22.246 --> 00:21:25.146 A:middle
Okay? So, there's a
lot of change here.

00:21:25.146 --> 00:21:26.016 A:middle
We'll talk about that.

00:21:26.436 --> 00:21:28.336 A:middle
But really what's interesting is

00:21:28.336 --> 00:21:30.516 A:middle
that these Cocoa APIs
you may have been using

00:21:30.516 --> 00:21:33.556 A:middle
for a very long time,
the APIs are the same,

00:21:33.556 --> 00:21:36.856 A:middle
but now a given API has
two different names.

00:21:37.716 --> 00:21:40.006 A:middle
Has one name that's
appropriate for Objective-C

00:21:40.776 --> 00:21:42.976 A:middle
and one name that's
appropriate for Swift.

00:21:43.116 --> 00:21:48.746 A:middle
As a Swift programmer, most of
the time you don't need to care.

00:21:49.316 --> 00:21:52.146 A:middle
You can entirely work
within the Swift names.

00:21:52.486 --> 00:21:54.566 A:middle
Use your generated
interfaces, the documentation,

00:21:54.566 --> 00:21:55.776 A:middle
everything will show
you the Swift names.

00:21:55.776 --> 00:21:56.716 A:middle
And that's all you'll deal with.

00:21:57.376 --> 00:21:59.096 A:middle
However, there are times
when you're interacting

00:21:59.096 --> 00:22:01.396 A:middle
with the system where
you actually do need the


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.096 --> 00:22:01.396 A:middle
with the system where
you actually do need the

00:22:01.396 --> 00:22:02.246 A:middle
Objective-C name.

00:22:02.246 --> 00:22:04.276 A:middle
For example, if you're
wiring up target action.

00:22:04.886 --> 00:22:06.606 A:middle
And so, here we actually need

00:22:06.606 --> 00:22:08.866 A:middle
to provide a selector
to target action.

00:22:09.106 --> 00:22:10.446 A:middle
And we have this string literal.

00:22:11.426 --> 00:22:12.246 A:middle
What do we write here?

00:22:12.856 --> 00:22:14.236 A:middle
I don't know.

00:22:14.426 --> 00:22:15.836 A:middle
You can look at the
generated interface.

00:22:16.376 --> 00:22:19.116 A:middle
Maybe ask your Swift compiler
friends on Twitter or something.

00:22:19.586 --> 00:22:20.586 A:middle
You can come up with the answer.

00:22:20.716 --> 00:22:21.126 A:middle
That's fine.

00:22:21.746 --> 00:22:23.466 A:middle
But, please don't do this.

00:22:24.346 --> 00:22:26.636 A:middle
Because this is a
really, really weak link

00:22:27.216 --> 00:22:29.886 A:middle
between this string literal,
which is super easy to mistype,

00:22:30.296 --> 00:22:32.706 A:middle
and the method above that
you actually meant to call.

00:22:33.366 --> 00:22:37.126 A:middle
This is why in Swift 2.2
we introduced #selector.

00:22:38.306 --> 00:22:39.686 A:middle
#selector is a very
simple thing.

00:22:39.686 --> 00:22:40.806 A:middle
It's an expression.

00:22:41.216 --> 00:22:44.006 A:middle
It takes in the name
of a Swift method

00:22:44.776 --> 00:22:47.116 A:middle
and produces the Objective-C
name for that method.

00:22:47.316 --> 00:22:49.486 A:middle
You don't have to care what
that Objective-C name is.

00:22:49.486 --> 00:22:50.616 A:middle
The compiler will get it right.

00:22:50.616 --> 00:22:52.926 A:middle
And the great thing
about this, of course,

00:22:52.996 --> 00:22:55.136 A:middle
is that Swift makes sure
that that method exists.

00:22:55.626 --> 00:22:57.736 A:middle
Makes sure it's exposed
to Objective-C,

00:22:58.226 --> 00:22:59.496 A:middle
and computes the correct name.

00:22:59.596 --> 00:23:01.636 A:middle
And of course, this is
safe against refactoring.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.596 --> 00:23:01.636 A:middle
And of course, this is
safe against refactoring.

00:23:01.976 --> 00:23:03.266 A:middle
Works with code completion.

00:23:03.406 --> 00:23:05.376 A:middle
So it's a much nicer
development experience.

00:23:05.376 --> 00:23:06.446 A:middle
That means you don't
have to worry

00:23:06.446 --> 00:23:07.596 A:middle
about the Objective-C names.

00:23:08.916 --> 00:23:12.026 A:middle
In Swift 3 we've extended this
so you can also refer to getters

00:23:12.026 --> 00:23:13.316 A:middle
and setters of properties.

00:23:13.606 --> 00:23:14.666 A:middle
So we round out the set

00:23:14.666 --> 00:23:16.776 A:middle
of Objective-C method names
you can actually compute.

00:23:16.876 --> 00:23:18.526 A:middle
So this is very easy to use.

00:23:18.636 --> 00:23:21.206 A:middle
You just pass in the argument
label setter or getter

00:23:21.206 --> 00:23:23.106 A:middle
to get the setter or
the getter respectively.

00:23:23.536 --> 00:23:25.306 A:middle
And then refer to an
Objective-C property.

00:23:26.226 --> 00:23:28.186 A:middle
And of course, the
compiler will validate

00:23:28.186 --> 00:23:30.786 A:middle
that that property exists, that
it's exposed to Objective-C

00:23:31.086 --> 00:23:34.226 A:middle
and get the right
Objective-C name for it.

00:23:35.046 --> 00:23:36.236 A:middle
Now, selectors aren't
the only sort

00:23:36.236 --> 00:23:38.496 A:middle
of stringly type thing
we have when talking

00:23:38.496 --> 00:23:39.876 A:middle
about Objective-C method names.

00:23:40.386 --> 00:23:43.236 A:middle
We also have Key Paths,
which are notoriously hard

00:23:43.236 --> 00:23:45.876 A:middle
to get right when
writing these things

00:23:45.876 --> 00:23:47.676 A:middle
as string literals
with no validation.

00:23:48.616 --> 00:23:53.236 A:middle
And so, in Swift 3 we're
also introducing #keyPath.

00:23:54.516 --> 00:24:00.876 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:54.516 --> 00:24:00.876 A:middle
[ Applause ]

00:24:01.376 --> 00:24:03.786 A:middle
#keyPath does exactly
what you'd expect.

00:24:03.906 --> 00:24:07.376 A:middle
You get to refer to a dotted
sequence of property accesses.

00:24:07.686 --> 00:24:10.186 A:middle
Compiler validates that these
are actually Objective-C

00:24:10.186 --> 00:24:12.416 A:middle
properties, gets
the right names.

00:24:12.856 --> 00:24:15.206 A:middle
And then produces the
string that we pass

00:24:15.206 --> 00:24:16.986 A:middle
down into the frameworks.

00:24:17.066 --> 00:24:19.336 A:middle
And so between #selector
and #keyPath,

00:24:19.946 --> 00:24:23.276 A:middle
you can essentially not worry
about the Objective-C names.

00:24:24.066 --> 00:24:26.316 A:middle
You just write everything
in terms of the Swift names

00:24:26.666 --> 00:24:28.606 A:middle
and you stay in that
set of names.

00:24:28.606 --> 00:24:30.126 A:middle
You don't have to
straddle the boundary.

00:24:31.466 --> 00:24:33.576 A:middle
Now, there are cases
where you do need to think

00:24:33.576 --> 00:24:35.306 A:middle
about what the Objective-C
names are.

00:24:35.506 --> 00:24:37.766 A:middle
You may have a mixed project
with Objective-C code in it

00:24:37.806 --> 00:24:39.746 A:middle
that needs to refer to the
names in your Swift code.

00:24:40.376 --> 00:24:42.486 A:middle
And names like this
handleDragWithSender

00:24:42.486 --> 00:24:45.946 A:middle
for just don't feel right
when they're in Objective-C.

00:24:46.456 --> 00:24:51.016 A:middle
So for these cases, you can
use the @objc attribute.

00:24:51.456 --> 00:24:54.706 A:middle
And in parentheses put the exact
Objective-C name that you want.

00:24:55.316 --> 00:24:58.006 A:middle
And that will be reflected in
your generated headers and all

00:24:58.006 --> 00:25:01.136 A:middle
of the metadata and everything
else so you get specific control


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.006 --> 00:25:01.136 A:middle
of the metadata and everything
else so you get specific control

00:25:01.136 --> 00:25:04.236 A:middle
over the Objective-C
names, but no other part

00:25:04.236 --> 00:25:06.106 A:middle
of your Swift code actually
has to care about this.

00:25:06.396 --> 00:25:11.926 A:middle
And of course, this @objc with
a name works for properties,

00:25:11.926 --> 00:25:14.226 A:middle
it works for methods,
classes, protocols.

00:25:14.226 --> 00:25:17.426 A:middle
Anything that can be exposed
to Objective-C from Swift,

00:25:17.926 --> 00:25:19.366 A:middle
you can control the name here.

00:25:19.966 --> 00:25:24.046 A:middle
So you get nice Objective-C
APIs for your Swift code.

00:25:25.076 --> 00:25:28.396 A:middle
Okay. There's a lot of
change coming with Swift 3.

00:25:29.936 --> 00:25:33.276 A:middle
The Swift language itself
abstracts away the need to worry

00:25:33.276 --> 00:25:34.536 A:middle
about the Objective-C names,

00:25:34.536 --> 00:25:37.226 A:middle
and yet it gives you the
control you need for those times

00:25:37.226 --> 00:25:39.356 A:middle
when you do care about
the Objective-C names.

00:25:40.986 --> 00:25:42.746 A:middle
The tools are here to help you.

00:25:44.016 --> 00:25:47.686 A:middle
So the Swift 3 migrator is going
to Swift 2 code and migrate it

00:25:47.686 --> 00:25:49.906 A:middle
to the Swift 3 names
and the Swift 3 syntax.

00:25:50.226 --> 00:25:51.406 A:middle
It's a lot of change.

00:25:52.366 --> 00:25:54.376 A:middle
But these tools will help
you get over the hump

00:25:54.376 --> 00:25:55.786 A:middle
and get working with Swift 3.

00:25:57.226 --> 00:25:59.246 A:middle
Now, the Swift 3
migrator is a great tool.

00:25:59.836 --> 00:26:01.976 A:middle
But it can't migrate
your muscle memory.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.836 --> 00:26:01.976 A:middle
But it can't migrate
your muscle memory.

00:26:02.916 --> 00:26:04.676 A:middle
Certainly can't migrate
all that code you copy

00:26:04.676 --> 00:26:06.086 A:middle
and paste from stack overflow.

00:26:09.236 --> 00:26:11.646 A:middle
So, the Swift compiler's
also here to help you.

00:26:12.196 --> 00:26:14.816 A:middle
The Swift compiler, it knows
the Swift 2 names of all

00:26:14.816 --> 00:26:17.126 A:middle
of these APIs as well
as the Swift 3 names.

00:26:17.436 --> 00:26:20.636 A:middle
So if you write or paste
in some code from Swift 2,

00:26:20.876 --> 00:26:24.586 A:middle
it'll recognize the old API
names and give you diagnostics

00:26:24.646 --> 00:26:27.656 A:middle
with Fix-its to update your code
so you can get moving faster.

00:26:29.066 --> 00:26:31.496 A:middle
Additionally, we've put
in near miss detection

00:26:31.636 --> 00:26:33.736 A:middle
when you're implementing
optional protocol methods.

00:26:34.076 --> 00:26:36.996 A:middle
And so this is great when
you're implementing a delegate.

00:26:37.316 --> 00:26:39.676 A:middle
You make some minor
mistake in the name

00:26:39.676 --> 00:26:41.326 A:middle
of that delegate method
you want to implement.

00:26:41.756 --> 00:26:44.406 A:middle
Now you'll get a warning with
a Fix-it to fix up the names

00:26:44.796 --> 00:26:46.876 A:middle
so you can be sure that your
method will be called properly.

00:26:46.966 --> 00:26:47.526 A:middle
All right.

00:26:48.356 --> 00:26:52.966 A:middle
Now I'd like to turn things
over to my colleague Michael,

00:26:53.376 --> 00:26:55.006 A:middle
who's going to talk
about the mapping of C

00:26:55.006 --> 00:26:56.966 A:middle
and Objective-C APIs into Swift.

00:26:58.516 --> 00:27:07.546 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.516 --> 00:27:07.546 A:middle
[ Applause ]

00:27:08.046 --> 00:27:09.046 A:middle
&gt;&gt; So that's a lot about Swift.

00:27:09.206 --> 00:27:12.496 A:middle
But what if you're an
Objective-C developer

00:27:12.756 --> 00:27:14.316 A:middle
or are working with
a mixed project?

00:27:14.966 --> 00:27:17.666 A:middle
All of your Objective-C
APIs are available in Swift.

00:27:17.856 --> 00:27:18.836 A:middle
They always have been.

00:27:19.266 --> 00:27:21.156 A:middle
But as Doug explained,
they were designed

00:27:21.156 --> 00:27:22.636 A:middle
for a different language.

00:27:23.016 --> 00:27:24.916 A:middle
They are increasingly starting

00:27:24.916 --> 00:27:27.356 A:middle
to feel a little bit
foreign in Swift.

00:27:27.916 --> 00:27:30.676 A:middle
So today I'm going to show
you how you can take control

00:27:30.676 --> 00:27:33.826 A:middle
of the situation and give
your Swift users the APIs

00:27:33.946 --> 00:27:34.506 A:middle
they deserve.

00:27:36.196 --> 00:27:38.996 A:middle
I'm going to start with
a couple Objective-C APIs

00:27:38.996 --> 00:27:40.666 A:middle
as they were imported
into Swift 2.

00:27:41.166 --> 00:27:44.926 A:middle
Here we have two methods;
saveToURL, forSaveOperation

00:27:44.926 --> 00:27:46.756 A:middle
and revertToContentsOfURL.

00:27:47.426 --> 00:27:51.606 A:middle
But these don't really express
the API Design Guidelines

00:27:51.606 --> 00:27:52.456 A:middle
that Doug outlined.

00:27:52.456 --> 00:27:55.186 A:middle
There's a lot of
redundant type information.

00:27:55.806 --> 00:27:58.986 A:middle
We're not making effective use
of the first parameter labels,

00:27:59.056 --> 00:27:59.926 A:middle
first argument labels.

00:27:59.926 --> 00:28:04.456 A:middle
So I'm going to start with what
you get for free automatically


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.926 --> 00:28:04.456 A:middle
So I'm going to start with what
you get for free automatically

00:28:04.456 --> 00:28:05.656 A:middle
in the Swift 3 compiler.

00:28:05.976 --> 00:28:09.496 A:middle
Swift 3 has improvements to how
Objective-C APIs are imported.

00:28:10.926 --> 00:28:13.596 A:middle
The Swift compiler will
inspect method names

00:28:13.626 --> 00:28:15.386 A:middle
and use grammatical
cues in order

00:28:15.386 --> 00:28:19.000 A:middle
to infer first parameter labels.

00:28:23.176 --> 00:28:25.256 A:middle
The Swift compiler will
inspect names in order

00:28:25.256 --> 00:28:27.506 A:middle
to eliminate redundant
type information.

00:28:28.096 --> 00:28:33.476 A:middle
The compiler can even
infer default arguments

00:28:33.556 --> 00:28:36.886 A:middle
for common Objective-C idioms
such as completion handlers.

00:28:38.156 --> 00:28:40.116 A:middle
Or option sets.

00:28:40.726 --> 00:28:44.556 A:middle
And also, there are
new value types

00:28:44.556 --> 00:28:47.096 A:middle
such as URL that
bridge to NSURL.

00:28:47.446 --> 00:28:50.086 A:middle
So when we import, we
just import it directly.

00:28:52.376 --> 00:28:55.416 A:middle
To find out more about
these value types, visit,

00:28:55.416 --> 00:28:59.376 A:middle
What's New in Foundation
for Swift later today.

00:28:59.926 --> 00:29:02.286 A:middle
So, automatic inference
is great and all,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.926 --> 00:29:02.286 A:middle
So, automatic inference
is great and all,

00:29:02.346 --> 00:29:05.616 A:middle
but fundamentally it's
driven by heuristics.

00:29:05.616 --> 00:29:07.546 A:middle
The compiler, it
can't read your mind.

00:29:07.546 --> 00:29:08.956 A:middle
It doesn't know your intent.

00:29:09.566 --> 00:29:12.816 A:middle
And every now and then you
want to specify your own name.

00:29:13.266 --> 00:29:15.296 A:middle
So we've extended NS Swift Name.

00:29:15.366 --> 00:29:17.446 A:middle
Now, NS Swift Name has
been around since Swift 2.

00:29:17.446 --> 00:29:20.646 A:middle
But in Swift 3 we support
full compound naming.

00:29:21.246 --> 00:29:23.906 A:middle
A compound name is a base
name plus the argument labels.

00:29:24.006 --> 00:29:25.516 A:middle
So in this case, we
have two methods.

00:29:26.316 --> 00:29:29.276 A:middle
They're performing semantically
very similar operations.

00:29:29.486 --> 00:29:32.116 A:middle
But they differ basically in
how they treat their argument.

00:29:32.116 --> 00:29:34.536 A:middle
And so we import them with the
same base name constraints,

00:29:35.186 --> 00:29:38.766 A:middle
but we say we want it equal
to this anchor or greater than

00:29:38.766 --> 00:29:41.616 A:middle
or equal to this anchor.

00:29:42.756 --> 00:29:45.496 A:middle
Now, method names will get you
a long way towards a Swifty API,

00:29:45.496 --> 00:29:47.616 A:middle
but this doesn't
quite go far enough.

00:29:48.266 --> 00:29:50.806 A:middle
Here I have some simple code
that's creating a standard

00:29:50.976 --> 00:29:51.956 A:middle
Gregorian calendar.

00:29:52.876 --> 00:29:56.146 A:middle
But if you look at this, this
doesn't really feel very Swifty,

00:29:56.876 --> 00:29:59.436 A:middle
especially
NSCalendarIdentifierGregorian,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.046 --> 00:30:02.486 A:middle
which is a plain
string global variable.

00:30:02.966 --> 00:30:04.476 A:middle
Plain string global variables,

00:30:04.476 --> 00:30:06.306 A:middle
that's not really
how we do Swift.

00:30:06.796 --> 00:30:10.396 A:middle
This is what we jokingly refer
to as stringly-typed API.

00:30:11.676 --> 00:30:13.866 A:middle
And the fact that this
API takes a string,

00:30:14.566 --> 00:30:16.366 A:middle
that kind of allows
simple errors.

00:30:16.366 --> 00:30:18.356 A:middle
And yes, I know this
bug is shallow

00:30:18.356 --> 00:30:20.186 A:middle
and a developer would
catch it right away.

00:30:20.686 --> 00:30:25.206 A:middle
But the fact that a user of this
API has to remember what it is

00:30:25.206 --> 00:30:27.326 A:middle
and it's not a valid
string to use here,

00:30:27.696 --> 00:30:29.996 A:middle
that's an unnecessary
cognitive burden.

00:30:31.736 --> 00:30:34.136 A:middle
So, why is this API like this?

00:30:34.666 --> 00:30:36.536 A:middle
Well, we all know why
this API is like this.

00:30:36.536 --> 00:30:38.006 A:middle
It came from Objective-C.

00:30:38.536 --> 00:30:41.426 A:middle
But the fact that this
API came from Objective-C,

00:30:41.686 --> 00:30:43.206 A:middle
that's an implementation detail.

00:30:43.386 --> 00:30:45.756 A:middle
And that implementation
detail is leaking out.

00:30:46.336 --> 00:30:51.976 A:middle
And at Apple, we're
not big fans of leaks.

00:30:52.046 --> 00:30:52.936 A:middle
To figure out what's
going wrong,

00:30:52.936 --> 00:30:55.116 A:middle
let's see how this Objective-C
API is mapping into Swift.

00:30:55.386 --> 00:30:58.956 A:middle
Our global variable comes in as
a global variable, of course.

00:30:59.496 --> 00:31:01.546 A:middle
But other than the name
of this global variable,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.496 --> 00:31:01.546 A:middle
But other than the name
of this global variable,

00:31:01.826 --> 00:31:02.876 A:middle
nothing really tells you

00:31:02.876 --> 00:31:07.426 A:middle
that this a very specific string
meant for a very specific API.

00:31:08.816 --> 00:31:11.176 A:middle
Now, we could try
adding a typedef to try

00:31:11.176 --> 00:31:12.426 A:middle
and hint at our intent.

00:31:12.856 --> 00:31:14.796 A:middle
But a typedef, it's
just a type alias.

00:31:14.796 --> 00:31:16.876 A:middle
It's a new name for an old type.

00:31:17.446 --> 00:31:19.796 A:middle
And so that doesn't really
fix the problem here.

00:31:21.356 --> 00:31:23.646 A:middle
So, how will this API
look if we were going

00:31:23.646 --> 00:31:25.896 A:middle
to design this fresh in Swift 3?

00:31:26.666 --> 00:31:30.786 A:middle
Well, we'd probably make a
new wrapper type around string

00:31:30.786 --> 00:31:32.436 A:middle
to get some strong typing.

00:31:32.646 --> 00:31:33.836 A:middle
And these global
variables, well,

00:31:33.916 --> 00:31:35.686 A:middle
those would instead
be static properties.

00:31:36.346 --> 00:31:38.626 A:middle
So in Swift 3 we introduced
a new attribute just

00:31:38.626 --> 00:31:39.446 A:middle
for this use case.

00:31:39.796 --> 00:31:41.056 A:middle
You can access this attribute

00:31:41.306 --> 00:31:44.036 A:middle
through NS Extensible
String Enum when you wish

00:31:44.036 --> 00:31:45.146 A:middle
to tell the Swift compiler

00:31:45.356 --> 00:31:48.176 A:middle
to make a new wrapper
type around your string.

00:31:48.756 --> 00:31:52.306 A:middle
You can just add
this to your typedef.

00:31:53.086 --> 00:31:57.286 A:middle
And the importer will create
you the new type around this.

00:31:57.436 --> 00:32:00.426 A:middle
And any global variables of
this type will get imported


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:57.436 --> 00:32:00.426 A:middle
And any global variables of
this type will get imported

00:32:00.426 --> 00:32:03.096 A:middle
automatically as static
properties of this type.

00:32:04.926 --> 00:32:07.366 A:middle
Now, we chose a struct here
because this is extensible.

00:32:07.366 --> 00:32:10.286 A:middle
That is, other modules may
want to define their own.

00:32:10.646 --> 00:32:13.576 A:middle
And if they do, they will also
be imported as static properties

00:32:13.576 --> 00:32:15.226 A:middle
on an extension of this struct.

00:32:15.856 --> 00:32:22.906 A:middle
Now, behind the scenes the Swift
compiler will map this directly

00:32:22.906 --> 00:32:24.466 A:middle
to the underlying stored value,

00:32:24.466 --> 00:32:27.296 A:middle
meaning that there's no
extra overhead or boxing

00:32:27.396 --> 00:32:32.756 A:middle
or intermediaries involved.

00:32:33.736 --> 00:32:35.446 A:middle
So, let's focus on the use site.

00:32:35.446 --> 00:32:38.806 A:middle
Because good API design is
always focused on the use site.

00:32:39.456 --> 00:32:41.676 A:middle
Before and after.

00:32:41.916 --> 00:32:44.856 A:middle
And because the type
context is clearer,

00:32:45.036 --> 00:32:47.486 A:middle
we can even just say .gregorian.

00:32:48.516 --> 00:32:57.146 A:middle
[ Applause ]

00:32:57.646 --> 00:33:03.546 A:middle
I'll kick it off by
starting myself next time.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.646 --> 00:33:03.546 A:middle
I'll kick it off by
starting myself next time.

00:33:03.906 --> 00:33:07.936 A:middle
Also, in Swift 3 NSCalendar,
it's now just known as Calendar.

00:33:07.996 --> 00:33:10.666 A:middle
This is a little fix up.

00:33:10.886 --> 00:33:16.236 A:middle
So, we have method
names and we have types.

00:33:16.556 --> 00:33:17.316 A:middle
What else do we have?

00:33:18.156 --> 00:33:21.046 A:middle
Well, we have an elephant.

00:33:22.626 --> 00:33:25.316 A:middle
That is, we have an
elephant in the room.

00:33:26.556 --> 00:33:28.886 A:middle
And we've been pretending
not to notice it.

00:33:28.966 --> 00:33:30.706 A:middle
But it's always been there.

00:33:32.396 --> 00:33:33.086 A:middle
And it's C.

00:33:35.376 --> 00:33:39.436 A:middle
Now, with Objective-C, the APIs
were already object-oriented,

00:33:39.436 --> 00:33:42.226 A:middle
so when we import them we
just change a few strings,

00:33:42.226 --> 00:33:43.226 A:middle
add a few types.

00:33:43.446 --> 00:33:44.436 A:middle
It's relatively straightforward.

00:33:44.796 --> 00:33:45.976 A:middle
But what about C?

00:33:46.756 --> 00:33:49.616 A:middle
I'm going to focus
on Core Graphics.

00:33:50.076 --> 00:33:53.056 A:middle
Now, Core Graphics is a
very popular API that's used

00:33:53.056 --> 00:33:54.946 A:middle
by pretty much every
Swift app out there.

00:33:55.306 --> 00:33:56.646 A:middle
It is a powerful API.

00:33:56.646 --> 00:34:00.326 A:middle
But it looks and
it feels like C.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:56.646 --> 00:34:00.326 A:middle
But it looks and
it feels like C.

00:34:01.666 --> 00:34:02.636 A:middle
Let's start with some code.

00:34:03.026 --> 00:34:04.196 A:middle
I have two functions here.

00:34:04.466 --> 00:34:06.176 A:middle
The first one transforms a --

00:34:06.176 --> 00:34:09.746 A:middle
takes a transform and rotates
it about a given offset.

00:34:10.335 --> 00:34:12.956 A:middle
And the second function
traces a path in red.

00:34:13.335 --> 00:34:15.326 A:middle
Now, neither of these
functions are too complicated,

00:34:15.326 --> 00:34:16.505 A:middle
and the details don't matter.

00:34:16.505 --> 00:34:18.936 A:middle
But I just want to look
at how does this look?

00:34:18.936 --> 00:34:19.886 A:middle
How does this feel?

00:34:20.005 --> 00:34:22.000 A:middle
Go ahead and take a moment.

00:34:25.436 --> 00:34:28.346 A:middle
So, if you notice, this
code is completely filled

00:34:28.346 --> 00:34:30.616 A:middle
with global variables
and global functions.

00:34:30.876 --> 00:34:33.356 A:middle
And we don't really like
global functions, of course.

00:34:34.136 --> 00:34:36.005 A:middle
Or global variables, of course.

00:34:37.866 --> 00:34:41.815 A:middle
So, how could we
take an API like this

00:34:42.146 --> 00:34:43.656 A:middle
and make it look Swifty?

00:34:43.656 --> 00:34:45.906 A:middle
How can we make it feel Swifty?

00:34:47.085 --> 00:34:50.696 A:middle
Well, for that, we revisit
our friend NS Swift Name.

00:34:50.936 --> 00:34:52.606 A:middle
You can use NS Swift
Name in order

00:34:52.606 --> 00:34:55.536 A:middle
to import globals
as members of types.

00:34:56.065 --> 00:34:57.776 A:middle
Let me start with
global variables

00:34:57.776 --> 00:34:58.476 A:middle
to show you what I mean.

00:34:59.666 --> 00:35:01.696 A:middle
Here at the top I have
this C definition.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.666 --> 00:35:01.696 A:middle
Here at the top I have
this C definition.

00:35:02.166 --> 00:35:04.126 A:middle
Below that the generated
Swift interface.

00:35:04.126 --> 00:35:05.856 A:middle
And underneath that
the Swift use site.

00:35:05.856 --> 00:35:07.536 A:middle
And we will be focusing
on the Swift use site

00:35:07.536 --> 00:35:09.286 A:middle
and improving the
Swift use site.

00:35:09.936 --> 00:35:14.436 A:middle
So we add NS Swift Name and we
use typename.membername in order

00:35:14.436 --> 00:35:20.096 A:middle
to tell the Swift compiler that
kCGColorWhite should be imported

00:35:20.096 --> 00:35:22.886 A:middle
as the static property
white on CGColor.

00:35:23.266 --> 00:35:27.786 A:middle
And of course, the Swift use
site can now use the properly

00:35:28.276 --> 00:35:29.876 A:middle
nested property.

00:35:30.516 --> 00:35:35.596 A:middle
[ Applause ]

00:35:36.096 --> 00:35:37.586 A:middle
And of course, if the
type context is clear,

00:35:37.586 --> 00:35:39.666 A:middle
users can even omit the CGColor.

00:35:40.346 --> 00:35:44.346 A:middle
Now Core Graphics has a lot
of different global functions

00:35:44.346 --> 00:35:46.936 A:middle
to create all different kinds
of CG Affine Transforms.

00:35:46.936 --> 00:35:48.996 A:middle
That's
CGAffineTransformMakeTranslation

00:35:48.996 --> 00:35:49.266 A:middle
as well

00:35:49.266 --> 00:35:51.566 A:middle
as CGAffineTransformMakeRotation
on all of these.

00:35:51.566 --> 00:35:53.826 A:middle
But in Swift we prefer
Initializer.

00:35:53.826 --> 00:35:58.126 A:middle
So we use TypeName.Init and
provide argument labels in order

00:35:58.126 --> 00:35:59.106 A:middle
to tell the Swift compiler

00:35:59.216 --> 00:36:01.496 A:middle
that this should really
just be an initializer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.216 --> 00:36:01.496 A:middle
that this should really
just be an initializer.

00:36:01.976 --> 00:36:03.806 A:middle
And we use argument
labels in order

00:36:03.806 --> 00:36:06.346 A:middle
to clarify the roles
of the parameter.

00:36:06.936 --> 00:36:11.856 A:middle
You can also import
as an instance member.

00:36:12.306 --> 00:36:14.746 A:middle
Use the special argument
label self in order

00:36:14.746 --> 00:36:16.836 A:middle
to tell the Swift
compiler what argument

00:36:16.876 --> 00:36:18.706 A:middle
to plug the reference
to self into.

00:36:19.906 --> 00:36:24.556 A:middle
And so now CGContextFillPath is
now just the method fill path.

00:36:24.916 --> 00:36:26.586 A:middle
And of course, the
Swift use site,

00:36:27.516 --> 00:36:28.946 A:middle
it just calls it like a method.

00:36:30.516 --> 00:36:35.546 A:middle
[ Applause ]

00:36:36.046 --> 00:36:37.926 A:middle
And the compiler will take
what's on the left of the dot

00:36:37.926 --> 00:36:41.706 A:middle
and plug it into the appropriate
parameter position as denoted

00:36:41.806 --> 00:36:43.556 A:middle
by the special argument
label self.

00:36:44.136 --> 00:36:46.936 A:middle
We can get more complicated.

00:36:47.036 --> 00:36:50.376 A:middle
You can prefix a Swift name
with getter or setter in order

00:36:50.376 --> 00:36:53.196 A:middle
to tell the compiler
to import this function

00:36:53.196 --> 00:36:55.726 A:middle
as a computed property
getter or setter.

00:36:56.326 --> 00:36:57.996 A:middle
Here ArtistGetName,

00:36:57.996 --> 00:37:01.076 A:middle
ArtistSetName are now just
the getters and setters


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.996 --> 00:37:01.076 A:middle
ArtistSetName are now just
the getters and setters

00:37:01.076 --> 00:37:02.966 A:middle
for the computed
property Artist.

00:37:04.226 --> 00:37:05.916 A:middle
Let's focus in the use site

00:37:06.146 --> 00:37:09.186 A:middle
because good API design is
always focused on the use site.

00:37:09.526 --> 00:37:11.936 A:middle
Before, we would use
a global function

00:37:11.936 --> 00:37:13.676 A:middle
to remember the former
name of an artist

00:37:13.896 --> 00:37:16.386 A:middle
and a different global
function to set a new name.

00:37:17.956 --> 00:37:22.006 A:middle
But now, our users can use the
computed property directly.

00:37:23.206 --> 00:37:26.696 A:middle
In all cases, this is
a zero cost overhead.

00:37:26.696 --> 00:37:29.856 A:middle
That is, when the compiler
sees myArtist.Name it maps it

00:37:29.856 --> 00:37:32.046 A:middle
directly to the corresponding
C function

00:37:32.256 --> 00:37:35.576 A:middle
without calling any wrappers
or intermediaries or overlays.

00:37:37.926 --> 00:37:40.616 A:middle
You can also use NS Swift
Name in order to nest types.

00:37:40.946 --> 00:37:47.306 A:middle
Remember earlier when we created
a new calendar identifier type?

00:37:48.046 --> 00:37:49.886 A:middle
Well, you can use typeName.

00:37:50.696 --> 00:37:52.096 A:middle
-- well member name --

00:37:52.186 --> 00:37:54.086 A:middle
nest a type name in
order to nest a type.

00:37:54.396 --> 00:37:58.000 A:middle
So in this case we get
Calendar.Identifier.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:06.106 --> 00:38:08.696 A:middle
Now, we love the
new NS Swift Name.

00:38:09.536 --> 00:38:18.856 A:middle
We love it so much that we went
absolutely, completely bananas.

00:38:19.516 --> 00:38:27.566 A:middle
[ Laughter &amp; Applause ]

00:38:28.066 --> 00:38:28.996 A:middle
Don't clap for this.

00:38:31.906 --> 00:38:35.656 A:middle
And we applied it
to over 600 APIs

00:38:35.876 --> 00:38:38.396 A:middle
in Core Graphics alone, 600.

00:38:39.076 --> 00:38:39.816 A:middle
Now you can clap.

00:38:40.516 --> 00:38:43.616 A:middle
[ Applause ]

00:38:44.116 --> 00:38:44.946 A:middle
That's a lot of bananas.

00:38:45.796 --> 00:38:48.036 A:middle
So, let's revisit
the code from before.

00:38:48.506 --> 00:38:50.296 A:middle
Before, our global variable,

00:38:50.296 --> 00:38:54.166 A:middle
which is painfully
global, is now a member.

00:38:54.166 --> 00:38:56.116 A:middle
And because the type
context is clearer,

00:38:56.276 --> 00:39:00.526 A:middle
we can even omit the type name.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:56.276 --> 00:39:00.526 A:middle
we can even omit the type name.

00:39:00.746 --> 00:39:03.866 A:middle
Our global functions
are now methods.

00:39:06.516 --> 00:39:10.626 A:middle
[ Applause ]

00:39:11.126 --> 00:39:12.656 A:middle
Actually, now that
I look at this,

00:39:12.656 --> 00:39:14.186 A:middle
I think this code
can even simpler.

00:39:14.186 --> 00:39:16.046 A:middle
We don't need that
extra variable result.

00:39:17.616 --> 00:39:18.666 A:middle
And so now this reads --

00:39:19.516 --> 00:39:23.636 A:middle
[ Applause ]

00:39:24.136 --> 00:39:26.526 A:middle
And so now this reads
nice, natural and Swifty.

00:39:26.926 --> 00:39:28.276 A:middle
We take a transform.

00:39:28.436 --> 00:39:29.586 A:middle
We translate it.

00:39:29.586 --> 00:39:30.236 A:middle
We rotate it.

00:39:30.236 --> 00:39:31.286 A:middle
And we translate it back.

00:39:31.616 --> 00:39:32.426 A:middle
Very straightforward.

00:39:32.936 --> 00:39:33.436 A:middle
Moving on.

00:39:33.936 --> 00:39:37.656 A:middle
CGColorCreateGenericRGB as
well as all of the other many,

00:39:37.656 --> 00:39:39.326 A:middle
many different ways
to create colors,

00:39:40.206 --> 00:39:43.446 A:middle
these are now initializers
with argument labels.

00:39:43.586 --> 00:39:45.766 A:middle
And of course --
hold your applause --

00:39:46.006 --> 00:39:50.376 A:middle
and of course CGContextAddPath,
ContextPath and all

00:39:50.376 --> 00:39:54.786 A:middle
of the other crazy redundant
stuff, they're now methods.

00:39:55.516 --> 00:40:01.546 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:55.516 --> 00:40:01.546 A:middle
[ Applause ]

00:40:02.046 --> 00:40:04.166 A:middle
We hope you enjoy
these new APIs.

00:40:04.386 --> 00:40:08.336 A:middle
So, to summarize, first we
presented the new API Design

00:40:08.336 --> 00:40:09.246 A:middle
Guidelines in Swift.

00:40:09.766 --> 00:40:12.746 A:middle
Good API design is always
focused on the use site.

00:40:13.216 --> 00:40:15.806 A:middle
Second, we looked at
the Grand Renaming.

00:40:15.976 --> 00:40:18.136 A:middle
This is also known as, "Oh, no!

00:40:18.166 --> 00:40:19.206 A:middle
Everything's different."

00:40:19.636 --> 00:40:20.456 A:middle
But don't panic.

00:40:20.806 --> 00:40:21.486 A:middle
It's okay.

00:40:21.766 --> 00:40:22.886 A:middle
The names are better.

00:40:22.886 --> 00:40:23.916 A:middle
The code is clearer.

00:40:23.916 --> 00:40:25.446 A:middle
And you have the
tools to migrate.

00:40:25.856 --> 00:40:27.916 A:middle
And last, we looked at
the new functionality

00:40:27.946 --> 00:40:30.896 A:middle
in the Swift compiler so
that you can have your own

00:40:30.976 --> 00:40:31.716 A:middle
Great Renaming.

00:40:32.546 --> 00:40:36.416 A:middle
For more information, visit
the page for this site

00:40:36.416 --> 00:40:40.516 A:middle
at developer.apple.com and check
out Swift.org, the homepage

00:40:40.516 --> 00:40:42.886 A:middle
of the open source Swift
project where you can see all

00:40:42.886 --> 00:40:44.146 A:middle
of the Swift evolution.

00:40:44.436 --> 00:40:45.926 A:middle
I also showed you Core Graphics.

00:40:46.126 --> 00:40:49.256 A:middle
But Grand Central Dispatch has
had its own Great Renaming using

00:40:49.256 --> 00:40:51.016 A:middle
many of these same
techniques I presented today.

00:40:51.426 --> 00:40:55.246 A:middle
So, Friday, check out
concurrent programming

00:40:55.246 --> 00:40:57.096 A:middle
with Grand Central
Dispatch in Swift 3.

00:40:57.626 --> 00:40:57.986 A:middle
Friday.

00:40:59.516 --> 00:41:15.080 A:middle
[ Applause ]

