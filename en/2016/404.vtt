WEBVTT

00:00:07.516 --> 00:00:18.516 A:middle
[ Music ]

00:00:19.516 --> 00:00:22.566 A:middle
[ Applause ]

00:00:23.066 --> 00:00:26.586 A:middle
&gt;&gt; Hello, and welcome to
Getting Started with Swift.

00:00:26.586 --> 00:00:28.956 A:middle
I'm Dave Addey, and together
with my colleagues Brian

00:00:28.956 --> 00:00:31.526 A:middle
and Alex, I'd like to
give you a quick overview

00:00:31.526 --> 00:00:32.826 A:middle
of the Swift Programming
Language.

00:00:33.836 --> 00:00:36.936 A:middle
In the next 60 minutes you'll
learn enough about Swift 3

00:00:36.936 --> 00:00:38.926 A:middle
to be able to read
Swift code and hopefully

00:00:38.926 --> 00:00:42.186 A:middle
to start writing it, too.

00:00:42.446 --> 00:00:45.226 A:middle
So let's start by taking a
look at some of the basics

00:00:45.286 --> 00:00:48.626 A:middle
of the language, and here's
some code I wrote two years ago.

00:00:48.996 --> 00:00:51.196 A:middle
I've written a constant,
indicated with let,

00:00:51.826 --> 00:00:54.016 A:middle
it's called language,
and it's a string.

00:00:54.076 --> 00:00:57.416 A:middle
And this colon in the middle,
you'll see this often in Swift,

00:00:57.596 --> 00:00:58.866 A:middle
this means is of type.

00:00:59.206 --> 00:01:02.836 A:middle
So language is of type string,
and I've just given it a value

00:00:59.206 --> 00:01:02.836 A:middle
So language is of type string,
and I've just given it a value

00:01:02.836 --> 00:01:05.886 A:middle
of Swift, using a string
literal in my code.

00:01:06.076 --> 00:01:06.856 A:middle
Let's make a few more.

00:01:07.426 --> 00:01:09.526 A:middle
Let's have an integer
called introduced.

00:01:09.636 --> 00:01:11.546 A:middle
We'll that to 2014.

00:01:11.546 --> 00:01:13.196 A:middle
And a Boolean called isAwesome.

00:01:13.546 --> 00:01:15.986 A:middle
And we'll set that to true.

00:01:16.126 --> 00:01:19.276 A:middle
Now, you might notice that none
of these values need to change.

00:01:19.566 --> 00:01:21.456 A:middle
The language's name
isn't going to change,

00:01:21.706 --> 00:01:22.936 A:middle
nor is the year it
was introduced.

00:01:23.816 --> 00:01:26.186 A:middle
And two years on,
Swift is still awesome,

00:01:26.186 --> 00:01:28.166 A:middle
so that can probably
be a constant as well.

00:01:29.046 --> 00:01:30.846 A:middle
And this is the general
principle in Swift.

00:01:31.386 --> 00:01:32.786 A:middle
If something doesn't
need to change,

00:01:32.976 --> 00:01:35.726 A:middle
we declare it as a constant.

00:01:35.726 --> 00:01:37.876 A:middle
Now, you might also
notice a naming trend here.

00:01:38.686 --> 00:01:41.656 A:middle
Constants and variables tend to
be written as lower camel case,

00:01:42.076 --> 00:01:45.986 A:middle
and types, such as String, Ints
and Bool, is upper camel case.

00:01:47.306 --> 00:01:48.876 A:middle
Now, if we look at the
things on the right here,

00:01:49.406 --> 00:01:52.476 A:middle
it's pretty obvious, actually,
that what I want is a string,

00:01:52.956 --> 00:01:54.306 A:middle
an integer and a Boolean,

00:01:54.836 --> 00:01:58.586 A:middle
and where this is the case
Swift can infer the type for us.

00:01:58.586 --> 00:02:00.346 A:middle
We don't actually need
to write it ourselves.

00:01:58.586 --> 00:02:00.346 A:middle
We don't actually need
to write it ourselves.

00:02:00.956 --> 00:02:03.126 A:middle
So you still get things
that are explicitly typed,

00:02:03.126 --> 00:02:04.906 A:middle
but you don't have to
write as much code.

00:02:06.326 --> 00:02:07.746 A:middle
So that's some constants.

00:02:08.015 --> 00:02:08.856 A:middle
What about variables?

00:02:08.856 --> 00:02:10.606 A:middle
Things do sometimes
need to change.

00:02:10.795 --> 00:02:12.576 A:middle
So here's a variable
indicated with var,

00:02:12.936 --> 00:02:14.726 A:middle
and it's for the
version of the language.

00:02:14.726 --> 00:02:15.526 A:middle
This has changed.

00:02:16.116 --> 00:02:17.926 A:middle
So let's bring it
up to date to 2016.

00:02:19.376 --> 00:02:21.456 A:middle
Now, if I try to do
this for a constant,

00:02:22.036 --> 00:02:25.276 A:middle
if I try to set isAwesome to
false, Swift would tell me

00:02:25.276 --> 00:02:27.166 A:middle
that it was an error,
and quite right, too.

00:02:29.266 --> 00:02:31.636 A:middle
So a common thing to want
to do in programming is

00:02:31.636 --> 00:02:33.196 A:middle
to build strings
from other values.

00:02:33.736 --> 00:02:36.146 A:middle
We could do this by
concatenating strings together,

00:02:36.146 --> 00:02:39.136 A:middle
as shown here, but Swift
has a neater way to do this,

00:02:39.626 --> 00:02:42.216 A:middle
known as string interpolation,
and this is how it looks.

00:02:42.606 --> 00:02:46.096 A:middle
And we can put strings and other
values inside a larger string

00:02:46.426 --> 00:02:49.296 A:middle
by wrapping them in parentheses
preceded by a backslash.

00:02:49.596 --> 00:02:51.756 A:middle
Here we're making the
message, Hello WWDC.

00:02:53.246 --> 00:02:54.986 A:middle
We're not just limited
to strings, however.

00:02:54.986 --> 00:02:56.426 A:middle
We can add other values as well,

00:02:56.426 --> 00:02:58.456 A:middle
such as integers here
putting the year in.

00:02:59.146 --> 00:03:01.696 A:middle
And we could even add
expressions as well.

00:02:59.146 --> 00:03:01.696 A:middle
And we could even add
expressions as well.

00:03:01.696 --> 00:03:03.536 A:middle
We can add year +
1 for some code

00:03:03.536 --> 00:03:05.176 A:middle
that would work for
a future year.

00:03:06.376 --> 00:03:09.426 A:middle
Now, strings in Swift are
fully Unicode friendly.

00:03:09.866 --> 00:03:12.416 A:middle
They're just as happy
with ASCII as they are

00:03:12.416 --> 00:03:13.876 A:middle
with dog, cows or with flags.

00:03:15.036 --> 00:03:18.086 A:middle
And the same also
goes for any constants

00:03:18.086 --> 00:03:19.106 A:middle
and variables you create.

00:03:19.106 --> 00:03:21.646 A:middle
You can use pretty much
any character in the name

00:03:21.646 --> 00:03:24.826 A:middle
of your constants and variables.

00:03:24.826 --> 00:03:26.036 A:middle
Talking of [inaudible]
characters,

00:03:26.036 --> 00:03:29.466 A:middle
Swift does all the hard work
of working out what it means

00:03:29.466 --> 00:03:30.946 A:middle
to be an individual character,

00:03:31.396 --> 00:03:33.716 A:middle
regardless of how your string
is encoded behind the scenes

00:03:34.066 --> 00:03:35.176 A:middle
or how it appears on screen.

00:03:35.716 --> 00:03:38.636 A:middle
So here I have a
string called dogString.

00:03:39.476 --> 00:03:43.206 A:middle
You might think that this
has six characters in it.

00:03:43.206 --> 00:03:46.296 A:middle
D, O, G, ?, !, dog face.

00:03:47.266 --> 00:03:48.096 A:middle
But you would be wrong.

00:03:49.046 --> 00:03:50.966 A:middle
There are five characters
here, not six.

00:03:51.786 --> 00:03:54.716 A:middle
This is a special character
called question exclamation

00:03:54.716 --> 00:03:56.126 A:middle
mark, which is really,

00:03:56.126 --> 00:04:00.456 A:middle
really good for expressing
incredulity about dogs.

00:03:56.126 --> 00:04:00.456 A:middle
really good for expressing
incredulity about dogs.

00:04:00.456 --> 00:04:03.406 A:middle
Now, if you don't believe me,
let's get Swift to prove it.

00:04:03.816 --> 00:04:06.216 A:middle
Every string has a
property called characters.

00:04:06.336 --> 00:04:08.386 A:middle
It gives us a collection of
the characters in the string

00:04:08.386 --> 00:04:11.166 A:middle
and we can access the count
property of that collection

00:04:11.476 --> 00:04:12.456 A:middle
to see how many there are.

00:04:13.276 --> 00:04:14.716 A:middle
If we pass that to
the print function,

00:04:15.116 --> 00:04:17.386 A:middle
we find out that we do,
indeed, have five characters.

00:04:18.245 --> 00:04:21.636 A:middle
But if you still don't
believe me, well, let's iterate

00:04:21.636 --> 00:04:24.396 A:middle
over each of those characters
in turn, using the for-in loop

00:04:24.396 --> 00:04:26.526 A:middle
and print each one of
them on its own line,

00:04:26.876 --> 00:04:29.076 A:middle
and you can see we do,
indeed, have five characters;

00:04:29.726 --> 00:04:30.626 A:middle
D, O, G, ?!

00:04:31.136 --> 00:04:33.866 A:middle
and dog face.

00:04:35.616 --> 00:04:39.456 A:middle
Now, in addition to all of these
fundamental types we also have

00:04:39.456 --> 00:04:41.096 A:middle
some built-in collections.

00:04:41.516 --> 00:04:43.136 A:middle
We have array and dictionary.

00:04:43.656 --> 00:04:45.586 A:middle
You might know dictionary
as a hash

00:04:45.586 --> 00:04:46.976 A:middle
or map table from
other languages.

00:04:47.856 --> 00:04:49.566 A:middle
And the easiest way
to create an array

00:04:49.616 --> 00:04:51.226 A:middle
or a dictionary is
with a literal.

00:04:51.306 --> 00:04:53.706 A:middle
This is an array literal
written with square bracketry

00:04:53.706 --> 00:04:55.676 A:middle
on the outside and
commas between each value.

00:04:56.756 --> 00:04:59.806 A:middle
Here we have an array of
four names, four strings.

00:05:01.066 --> 00:05:02.356 A:middle
Dictionaries look very similar.

00:05:02.826 --> 00:05:04.866 A:middle
Their keys and values are
separated with a colon.

00:05:05.336 --> 00:05:08.096 A:middle
Here we have a dictionary whose
keys are strings, the names,

00:05:08.556 --> 00:05:09.816 A:middle
and whose values are integers.

00:05:11.716 --> 00:05:15.336 A:middle
Now, you might notice from
the things in this array

00:05:15.596 --> 00:05:17.516 A:middle
that they're all the same
type; they're all strings.

00:05:18.356 --> 00:05:20.956 A:middle
It wouldn't make sense to insert
something else in a names array,

00:05:21.326 --> 00:05:24.096 A:middle
to have an integer or
a Boolean or a bicycle.

00:05:24.096 --> 00:05:25.676 A:middle
That would be just weird.

00:05:26.446 --> 00:05:28.676 A:middle
For names we always
want them to be strings,

00:05:28.676 --> 00:05:30.736 A:middle
and in Swift we can
express this.

00:05:30.736 --> 00:05:34.156 A:middle
We can say we want an array
of strings, so we know as soon

00:05:34.156 --> 00:05:35.296 A:middle
as we get anything out of it,

00:05:35.296 --> 00:05:37.446 A:middle
we can do string
like things with it.

00:05:37.946 --> 00:05:39.066 A:middle
So this is how we write that.

00:05:39.066 --> 00:05:40.706 A:middle
This is how we write
an array of strings,

00:05:40.706 --> 00:05:42.316 A:middle
a string with square
brackets around it.

00:05:43.606 --> 00:05:46.626 A:middle
But as we saw earlier
on, when it's clear

00:05:46.626 --> 00:05:49.076 A:middle
from the right hand side
what kind of type we want,

00:05:49.726 --> 00:05:52.336 A:middle
Swift works it out for us,
and that happens here as well.

00:05:52.336 --> 00:05:53.936 A:middle
We actually don't need
to write the type.

00:05:54.386 --> 00:05:56.556 A:middle
It's clear we want
an array of strings.

00:05:57.976 --> 00:05:58.976 A:middle
The same goes for
our dictionary.

00:05:59.336 --> 00:06:02.276 A:middle
Here it's clear we want string
keys and integer values,

00:05:59.336 --> 00:06:02.276 A:middle
Here it's clear we want string
keys and integer values,

00:06:02.516 --> 00:06:04.206 A:middle
so Swift can infer
that for us as well,

00:06:04.356 --> 00:06:08.346 A:middle
but everything is
still clearly typed.

00:06:08.526 --> 00:06:11.486 A:middle
Swift has all of the loops you
might know from other languages.

00:06:11.826 --> 00:06:14.476 A:middle
We have a while loop that checks
its condition before first

00:06:14.476 --> 00:06:15.396 A:middle
executing its body.

00:06:16.046 --> 00:06:17.086 A:middle
And a repeat-while loop,

00:06:17.486 --> 00:06:19.836 A:middle
which executes its body once
before checking a condition

00:06:19.836 --> 00:06:20.976 A:middle
to see if it should continue.

00:06:21.506 --> 00:06:25.096 A:middle
And as we saw earlier, we have
the for in loop, which we used

00:06:25.096 --> 00:06:26.556 A:middle
to iterate over the
characters of a string.

00:06:27.476 --> 00:06:30.466 A:middle
But that's not the only thing
the for in can be used with.

00:06:31.546 --> 00:06:33.696 A:middle
We can use it to
iterate over a range.

00:06:34.336 --> 00:06:37.026 A:middle
Here we have a range that
runs through from 1 through 5

00:06:37.026 --> 00:06:39.206 A:middle
and includes most of those
numbers, which we're using

00:06:39.206 --> 00:06:41.376 A:middle
to print five entries
from the four times table.

00:06:42.186 --> 00:06:44.786 A:middle
We write this as 1...5.

00:06:45.056 --> 00:06:46.216 A:middle
That is called a closed range

00:06:46.216 --> 00:06:47.626 A:middle
because it includes
both of those numbers.

00:06:48.726 --> 00:06:51.646 A:middle
However, sometimes it's useful
to have a range that runs

00:06:51.646 --> 00:06:53.856 A:middle
up to one less than
its final number.

00:06:54.586 --> 00:06:55.886 A:middle
Here's an example of
where that's useful.

00:06:56.806 --> 00:06:58.986 A:middle
I have an array of
integers, but I only want

00:06:58.986 --> 00:06:59.966 A:middle
to print the first five.

00:07:00.766 --> 00:07:02.726 A:middle
Now, because array
indices start from 0,

00:07:02.726 --> 00:07:04.986 A:middle
I actually want indices
0 through 4.

00:07:05.726 --> 00:07:08.006 A:middle
So for that we can use the
half-closed range operator,

00:07:08.406 --> 00:07:10.926 A:middle
..&lt; because it runs the one less

00:07:10.926 --> 00:07:12.576 A:middle
than the final number,
in this case 5.

00:07:14.696 --> 00:07:16.756 A:middle
We can use a for-in
loop with an array.

00:07:16.756 --> 00:07:18.616 A:middle
Here we're printing
a message for each

00:07:18.616 --> 00:07:19.656 A:middle
of the names in our array.

00:07:20.486 --> 00:07:22.176 A:middle
And we can also use
it with a dictionary.

00:07:23.056 --> 00:07:25.726 A:middle
Now, note here that we're
iterating over the key

00:07:25.726 --> 00:07:28.676 A:middle
and the value, the name and
the age, at the same time.

00:07:29.596 --> 00:07:32.296 A:middle
And this is an example of
Swift speech known as a tuple,

00:07:32.296 --> 00:07:34.626 A:middle
which lets you combine those
multiple values together

00:07:34.626 --> 00:07:35.646 A:middle
and use them at the same time.

00:07:35.736 --> 00:07:37.816 A:middle
And we'll see another
example of this later on.

00:07:38.496 --> 00:07:39.886 A:middle
And it makes for
much clearer code

00:07:40.086 --> 00:07:41.286 A:middle
when iterating over
a dictionary.

00:07:43.276 --> 00:07:45.466 A:middle
So how would we modify
these collections?

00:07:46.456 --> 00:07:49.096 A:middle
Well, here's my packing
list for WWDC this year.

00:07:49.266 --> 00:07:51.576 A:middle
I've declared it as a
variable so I can change it,

00:07:52.276 --> 00:07:54.896 A:middle
but I've included the
essentials, socks and shoes.

00:07:55.526 --> 00:08:01.796 A:middle
Now, at WWDC 2014 I
forgot to pack my socks

00:07:55.526 --> 00:08:01.796 A:middle
Now, at WWDC 2014 I
forgot to pack my socks

00:08:02.386 --> 00:08:05.536 A:middle
and it was a nightmare, so I'm
not making that mistake again.

00:08:06.286 --> 00:08:08.286 A:middle
So let's check that
the first item

00:08:08.286 --> 00:08:09.906 A:middle
in this array is
definitely socks.

00:08:10.026 --> 00:08:12.716 A:middle
After 2014, if I put it on
the list, it will be first.

00:08:13.666 --> 00:08:15.066 A:middle
We do this using a subscript,

00:08:15.476 --> 00:08:18.316 A:middle
writing an index inside square
brackets after the array name,

00:08:18.576 --> 00:08:19.756 A:middle
and if we print this value,

00:08:19.876 --> 00:08:22.956 A:middle
I have indeed remembered
to add socks.

00:08:23.186 --> 00:08:24.986 A:middle
Socks and shoes will
not be enough, however,

00:08:24.986 --> 00:08:26.186 A:middle
for a week of the conference.

00:08:26.186 --> 00:08:27.106 A:middle
I'll need more things.

00:08:27.616 --> 00:08:28.886 A:middle
So let's append a new item.

00:08:28.946 --> 00:08:31.186 A:middle
Let's append some trousers
to this array as well,

00:08:31.186 --> 00:08:32.916 A:middle
which we do using
the append method.

00:08:33.405 --> 00:08:35.616 A:middle
But there's a problem here.

00:08:36.816 --> 00:08:39.726 A:middle
The conference is in America and
they don't call them trousers,

00:08:40.346 --> 00:08:42.535 A:middle
they call them pants,
and that's going

00:08:42.676 --> 00:08:44.316 A:middle
to cause all kinds of confusion.

00:08:44.966 --> 00:08:46.696 A:middle
So let's change a
value in our array.

00:08:47.226 --> 00:08:48.926 A:middle
Let's change this
to be jeans instead.

00:08:49.246 --> 00:08:50.986 A:middle
Again, we use a subscript
to do so,

00:08:51.146 --> 00:08:52.566 A:middle
to change the item in index two.

00:08:52.936 --> 00:08:54.206 A:middle
Jeans are called the
same thing everywhere,

00:08:54.206 --> 00:08:55.326 A:middle
so this shouldn't
cause confusion.

00:08:57.406 --> 00:08:59.016 A:middle
Now, the conference
is in California

00:08:59.166 --> 00:09:00.756 A:middle
where it is always
hot and sunny,

00:08:59.166 --> 00:09:00.756 A:middle
where it is always
hot and sunny,

00:09:01.436 --> 00:09:02.806 A:middle
so let's add a few more items.

00:09:02.806 --> 00:09:06.506 A:middle
Let's add some shorts, some
sandals and some sunblock.

00:09:07.266 --> 00:09:10.346 A:middle
We can do this using the append
contents of method and pass

00:09:10.346 --> 00:09:12.566 A:middle
in a compatible array,
another array of strings here,

00:09:13.186 --> 00:09:16.466 A:middle
and they all get
appended at the same time.

00:09:16.526 --> 00:09:19.346 A:middle
That said, whilst the
conference is in California,

00:09:20.006 --> 00:09:23.216 A:middle
it's in San Francisco, where
it is not always hot and sunny.

00:09:23.956 --> 00:09:26.596 A:middle
So maybe let's change those
three items and replace them

00:09:26.596 --> 00:09:28.286 A:middle
with a hoodie and
a scarf instead.

00:09:29.206 --> 00:09:31.656 A:middle
We can do this by passing
a range into the subscript.

00:09:32.076 --> 00:09:34.046 A:middle
And note that we're changing
three items with two,

00:09:34.166 --> 00:09:37.766 A:middle
this is still perfectly
valid in Swift.

00:09:38.006 --> 00:09:38.906 A:middle
So what about a dictionary?

00:09:38.906 --> 00:09:40.036 A:middle
Let's modify a dictionary.

00:09:40.656 --> 00:09:43.976 A:middle
Well, here I have my ages
dictionary from before.

00:09:44.476 --> 00:09:47.346 A:middle
I'd like to add somebody else
to it, and I do this just

00:09:47.346 --> 00:09:50.556 A:middle
by adding a value for a key
that's not already there using

00:09:50.556 --> 00:09:51.136 A:middle
a subscript.

00:09:51.356 --> 00:09:52.156 A:middle
Here I've added Justyn.

00:09:52.726 --> 00:09:56.036 A:middle
But thinking about it, it was
Justyn's birthday last week

00:09:56.396 --> 00:09:57.676 A:middle
so this value is now incorrect.

00:09:57.676 --> 00:09:59.956 A:middle
I need to update it, which I
do in exactly the same way.

00:10:00.156 --> 00:10:02.896 A:middle
I just assign a different
value for the same key

00:10:03.036 --> 00:10:04.216 A:middle
and now my dictionary's correct.

00:10:06.716 --> 00:10:09.446 A:middle
What if I want to retrieve
a value from the dictionary?

00:10:10.176 --> 00:10:13.546 A:middle
What if I want to see if we have
an age for Devon or for Daryl,

00:10:13.546 --> 00:10:15.016 A:middle
or perhaps for Daniel?

00:10:16.456 --> 00:10:18.996 A:middle
Well, there might be a value in
the dictionary for these people,

00:10:18.996 --> 00:10:22.166 A:middle
but there might not, and we
need a way to model that,

00:10:22.626 --> 00:10:24.296 A:middle
and this is a great use case

00:10:24.296 --> 00:10:25.906 A:middle
for a Swift feature
known as Optionals.

00:10:25.906 --> 00:10:28.916 A:middle
If we tried this for Amy,

00:10:29.276 --> 00:10:31.576 A:middle
we might expect a
value of 40 perhaps.

00:10:31.736 --> 00:10:34.976 A:middle
But if we tried it for Daryl,
what should we get then?

00:10:34.976 --> 00:10:37.976 A:middle
There's no value here for Daryl.

00:10:38.186 --> 00:10:38.886 A:middle
Think of it like this.

00:10:40.046 --> 00:10:42.716 A:middle
There either is a value in the
dictionary and it's an Int,

00:10:43.086 --> 00:10:46.466 A:middle
that's for Amy, or there's
no value, there's no Int,

00:10:46.946 --> 00:10:47.756 A:middle
as in the case of Daryl.

00:10:47.836 --> 00:10:51.716 A:middle
So what we have here
is an optional Int,

00:10:52.336 --> 00:10:54.026 A:middle
which we write as
Int question mark.

00:10:54.736 --> 00:10:56.776 A:middle
And the question mark means
there might be a value here,

00:10:57.176 --> 00:10:58.306 A:middle
but there might not.

00:10:59.716 --> 00:11:02.096 A:middle
Now, we can check to
see if we found a value

00:10:59.716 --> 00:11:02.096 A:middle
Now, we can check to
see if we found a value

00:11:02.336 --> 00:11:03.686 A:middle
by comparing it against nil.

00:11:03.686 --> 00:11:05.126 A:middle
Nil is just a special way,

00:11:05.126 --> 00:11:06.926 A:middle
a shorthand way of
writing no value.

00:11:07.456 --> 00:11:09.926 A:middle
If we try this for
Daryl, there is no value,

00:11:10.076 --> 00:11:12.536 A:middle
we'd print the message.

00:11:12.536 --> 00:11:13.216 A:middle
Age not found.

00:11:13.896 --> 00:11:16.646 A:middle
If we try this for Amy,
well, we do find a value

00:11:16.946 --> 00:11:20.996 A:middle
so it doesn't equal nil and
so we don't print the message.

00:11:21.146 --> 00:11:23.416 A:middle
Typically, however, we don't
just want to check for a value.

00:11:23.416 --> 00:11:24.846 A:middle
We actually want to
use it if it exists,

00:11:25.486 --> 00:11:28.526 A:middle
and Swift has a really good
shorthand for writing this,

00:11:28.526 --> 00:11:31.216 A:middle
which we write as if let.

00:11:31.256 --> 00:11:34.616 A:middle
Now, this says here the
dictionary contains a value

00:11:34.616 --> 00:11:38.826 A:middle
for Amy, let a new constant
called age equal that value.

00:11:38.826 --> 00:11:42.006 A:middle
And then we can use that
value inside the if statement.

00:11:42.916 --> 00:11:45.256 A:middle
And note that we use it
as an actual integer.

00:11:45.256 --> 00:11:46.356 A:middle
It's not optional anymore.

00:11:47.416 --> 00:11:50.026 A:middle
The if statements checks
for the value, unwraps it

00:11:50.216 --> 00:11:51.646 A:middle
and gives us back
a normal integer

00:11:51.756 --> 00:11:53.396 A:middle
that we can do integer
like things with.

00:11:55.436 --> 00:11:57.696 A:middle
So we've seen a few
if statements so far.

00:11:57.986 --> 00:11:59.706 A:middle
Here's another that
prints a birthday message.

00:12:00.046 --> 00:12:03.116 A:middle
There are two things to
note about this statement.

00:12:04.096 --> 00:12:06.036 A:middle
Firstly, we don't
need parentheses

00:12:06.036 --> 00:12:07.876 A:middle
around the conditions so we can
just write them as they are.

00:12:09.066 --> 00:12:12.516 A:middle
And secondly, we do add
curly braces around each part

00:12:12.516 --> 00:12:14.656 A:middle
of the statement to make
it explicit which bits

00:12:14.656 --> 00:12:18.256 A:middle
of code are going to be run.

00:12:18.306 --> 00:12:21.156 A:middle
In addition to if, we also
have a switch statement,

00:12:21.566 --> 00:12:23.676 A:middle
and this is useful for
writing maybe more complex,

00:12:23.676 --> 00:12:24.606 A:middle
more powerful matches.

00:12:25.386 --> 00:12:28.176 A:middle
This switches over the
current value of a constant

00:12:28.176 --> 00:12:30.876 A:middle
or a variable and matches
certain cases that can occur.

00:12:31.496 --> 00:12:34.386 A:middle
So, for example, we can have
the case here for an age

00:12:34.826 --> 00:12:36.826 A:middle
where the value is
one and we want

00:12:36.826 --> 00:12:39.156 A:middle
to print a simple happy
first birthday message.

00:12:40.256 --> 00:12:41.826 A:middle
We can also match
against ranges.

00:12:42.396 --> 00:12:44.526 A:middle
Here matching any value that
would make someone a teenager.

00:12:45.666 --> 00:12:48.886 A:middle
And we can match more complex
patterns, such as this one,

00:12:49.136 --> 00:12:53.276 A:middle
which says that a temporary
constant called decade equal the

00:12:53.276 --> 00:12:54.386 A:middle
value that we're
currently matching,

00:12:55.426 --> 00:12:58.956 A:middle
check if it will divide
cleanly by 10, and if so,

00:12:59.366 --> 00:13:01.646 A:middle
use it to print a
special birthday message

00:12:59.366 --> 00:13:01.646 A:middle
use it to print a
special birthday message

00:13:02.016 --> 00:13:04.436 A:middle
for anyone who's
just turned 30 or 40

00:13:04.656 --> 00:13:06.036 A:middle
or some other significant age.

00:13:06.586 --> 00:13:10.286 A:middle
But there's a problem with
this statement as it stands.

00:13:11.336 --> 00:13:13.626 A:middle
What would happen if we wanted
to print a message for someone

00:13:13.626 --> 00:13:17.316 A:middle
who was 41, or 97 or 56?

00:13:17.316 --> 00:13:20.046 A:middle
Well, they wouldn't
get a message,

00:13:20.386 --> 00:13:21.766 A:middle
and that seems really
unfortunate,

00:13:21.826 --> 00:13:25.026 A:middle
especially on their birthday.

00:13:25.096 --> 00:13:26.406 A:middle
Frankly, Swift helps
us out here.

00:13:27.166 --> 00:13:29.896 A:middle
Swift makes sure that every
switch statement is complete,

00:13:29.896 --> 00:13:32.186 A:middle
that you don't accidentally
forget one

00:13:32.186 --> 00:13:33.556 A:middle
of the cases that
you might need.

00:13:34.416 --> 00:13:36.986 A:middle
And in this case we can
add a default statement

00:13:37.426 --> 00:13:40.666 A:middle
which catches every other case
we hadn't already caught above

00:13:41.026 --> 00:13:45.876 A:middle
and just says, Happy
plain old boring birthday.

00:13:45.876 --> 00:13:47.026 A:middle
Here's another switch statement.

00:13:48.176 --> 00:13:52.066 A:middle
This one takes a string value,
user name, and a Boolean value

00:13:52.066 --> 00:13:54.776 A:middle
that indicates whether that
user's password is valid,

00:13:55.496 --> 00:13:58.286 A:middle
and we'll use both of these
values together to work

00:13:58.286 --> 00:14:01.056 A:middle
out an appropriate message to
display when this user tries

00:13:58.286 --> 00:14:01.056 A:middle
out an appropriate message to
display when this user tries

00:14:01.056 --> 00:14:02.416 A:middle
to log into a restricted area.

00:14:03.326 --> 00:14:06.496 A:middle
And to do this we can
switch over both values

00:14:06.496 --> 00:14:09.746 A:middle
at the same time using a tuple,
same as we did earlier on.

00:14:11.006 --> 00:14:12.496 A:middle
So this means we can
write some really,

00:14:12.496 --> 00:14:13.646 A:middle
really interesting use cases,

00:14:13.646 --> 00:14:14.946 A:middle
some really interesting
switch cases.

00:14:15.636 --> 00:14:17.616 A:middle
We can have the case where
the user name is admin

00:14:17.716 --> 00:14:19.936 A:middle
and the password is
true, and print a message

00:14:19.936 --> 00:14:21.286 A:middle
to welcome back our
administrator.

00:14:23.046 --> 00:14:26.206 A:middle
Now, in the case of a guest we
never want to allow the guest

00:14:26.206 --> 00:14:28.816 A:middle
into the restricted area even
if their password is valid,

00:14:29.496 --> 00:14:31.246 A:middle
and so we can ignore
the password

00:14:31.466 --> 00:14:32.496 A:middle
by writing an underscore,

00:14:33.406 --> 00:14:36.896 A:middle
and this means just match
any possible value here.

00:14:37.036 --> 00:14:39.896 A:middle
For all other users we actually
don't care what the user

00:14:39.896 --> 00:14:40.266 A:middle
name is.

00:14:40.266 --> 00:14:41.546 A:middle
We just care about the password.

00:14:41.996 --> 00:14:45.046 A:middle
So we can ignore the user
name again, and instead,

00:14:45.476 --> 00:14:47.246 A:middle
we've switched on
what we want to do

00:14:47.246 --> 00:14:48.456 A:middle
with the password's validity.

00:14:49.056 --> 00:14:51.586 A:middle
To do this we create a temporary
constant called IsValid,

00:14:52.526 --> 00:14:55.456 A:middle
and we then use the ternary
conditional operator,

00:14:55.776 --> 00:14:57.476 A:middle
that's the question
mark and colon here,

00:14:57.616 --> 00:15:01.336 A:middle
to say if it's valid,
use this message;

00:14:57.616 --> 00:15:01.336 A:middle
to say if it's valid,
use this message;

00:15:01.806 --> 00:15:03.586 A:middle
otherwise, use this message.

00:15:04.896 --> 00:15:06.876 A:middle
So let's run that through
for a few examples.

00:15:06.876 --> 00:15:10.096 A:middle
If we take our administrator,
the password's valid,

00:15:10.436 --> 00:15:12.676 A:middle
they get a special administrator
message, as expected.

00:15:13.746 --> 00:15:15.216 A:middle
If we try this for
a guest, well,

00:15:15.216 --> 00:15:18.386 A:middle
even though their password is
valid, they get the I'm sorry,

00:15:18.386 --> 00:15:19.466 A:middle
you can't come in message.

00:15:19.886 --> 00:15:22.656 A:middle
If we try it for Bob,
his password is valid,

00:15:23.176 --> 00:15:24.856 A:middle
he gets the welcome
message as expected.

00:15:25.436 --> 00:15:28.406 A:middle
But if his password is not
valid, he gets access denied.

00:15:30.436 --> 00:15:32.956 A:middle
Now, there is one
final thing of note

00:15:33.226 --> 00:15:34.286 A:middle
about this switch statement,

00:15:34.936 --> 00:15:37.426 A:middle
and that's that it doesn't
have a default condition.

00:15:37.706 --> 00:15:40.186 A:middle
And the reason it doesn't
is it doesn't need one.

00:15:40.416 --> 00:15:42.566 A:middle
It's already complete.

00:15:42.566 --> 00:15:46.206 A:middle
If we take a look at
the final case here,

00:15:46.816 --> 00:15:49.626 A:middle
this actually covers all
of the possible conditions

00:15:49.626 --> 00:15:51.026 A:middle
that we haven't already
matched above

00:15:51.506 --> 00:15:53.556 A:middle
and so the switch
statement is complete

00:15:53.556 --> 00:15:55.976 A:middle
without needing a default.

00:15:56.086 --> 00:15:58.596 A:middle
So those are some of the
basics of the Swift language.

00:15:59.086 --> 00:16:01.426 A:middle
I'd now like to hand over to my
colleague Brian to introduce you

00:15:59.086 --> 00:16:01.426 A:middle
I'd now like to hand over to my
colleague Brian to introduce you

00:16:01.426 --> 00:16:03.366 A:middle
to functions and
closures in Swift.

00:16:05.016 --> 00:16:08.816 A:middle
[ Applause ]

00:16:09.316 --> 00:16:09.546 A:middle
&gt;&gt; All right.

00:16:09.756 --> 00:16:10.776 A:middle
Thanks, Dave, as I was saying.

00:16:10.916 --> 00:16:12.226 A:middle
Let's get started by looking

00:16:12.226 --> 00:16:13.706 A:middle
at how you define a
function in Swift.

00:16:14.356 --> 00:16:16.796 A:middle
You define a function
using the func keyword

00:16:17.166 --> 00:16:19.266 A:middle
and you implement it
inside of the curly braces.

00:16:19.806 --> 00:16:22.276 A:middle
Here we've defined a simple
function called sendMessage

00:16:22.586 --> 00:16:24.106 A:middle
that prints a message
to the console.

00:16:24.496 --> 00:16:27.476 A:middle
And you call this message
in an intuitive way

00:16:27.996 --> 00:16:30.096 A:middle
by writing its name,
sendMessage,

00:16:30.606 --> 00:16:32.246 A:middle
followed by an empty
pair of parentheses.

00:16:32.946 --> 00:16:35.166 A:middle
So let's add a parameter
to the function

00:16:35.166 --> 00:16:38.096 A:middle
that indicates whether the
message should be sent shouting.

00:16:39.176 --> 00:16:41.656 A:middle
You write the parameter's
name, followed by colon

00:16:41.656 --> 00:16:43.836 A:middle
and the parameter's
type, just like you do

00:16:43.836 --> 00:16:46.176 A:middle
when you declare a
constant or a variable.

00:16:47.076 --> 00:16:48.866 A:middle
Here we've added a
parameter called shouting,

00:16:48.996 --> 00:16:49.906 A:middle
which is of type Bool.

00:16:50.576 --> 00:16:52.036 A:middle
And when you call the function,

00:16:52.036 --> 00:16:54.236 A:middle
the parameter's name
provides a label

00:16:54.236 --> 00:16:57.796 A:middle
for the argument you pass in.

00:16:57.796 --> 00:17:00.356 A:middle
Labeling your arguments
makes your code read better

00:16:57.796 --> 00:17:00.356 A:middle
Labeling your arguments
makes your code read better

00:17:00.356 --> 00:17:03.196 A:middle
and makes the purpose or
intent of each argument clear.

00:17:03.196 --> 00:17:06.086 A:middle
In this case, if you left
out the shouting label,

00:17:06.415 --> 00:17:08.215 A:middle
someone reading your
code later might think

00:17:08.215 --> 00:17:10.846 A:middle
that true just indicated whether
the message should be sent

00:17:10.846 --> 00:17:11.376 A:middle
at all.

00:17:13.215 --> 00:17:15.016 A:middle
So you can shout a message,
but who are you going

00:17:15.016 --> 00:17:16.536 A:middle
to send the message to.

00:17:16.536 --> 00:17:19.036 A:middle
Let's add another parameter
that lets us address the message

00:17:19.036 --> 00:17:19.935 A:middle
to someone in particular.

00:17:20.476 --> 00:17:23.306 A:middle
So here we've added a
parameter called recipient,

00:17:23.596 --> 00:17:24.596 A:middle
which is of type string,

00:17:24.776 --> 00:17:26.455 A:middle
and we've included
the recipient's name

00:17:26.935 --> 00:17:28.926 A:middle
in our message using
string interpolation.

00:17:30.236 --> 00:17:32.456 A:middle
And now when you call the
function, you can pass

00:17:32.456 --> 00:17:33.406 A:middle
in the recipient's name.

00:17:34.666 --> 00:17:37.046 A:middle
Now, although the message
prints as you'd expect,

00:17:37.476 --> 00:17:39.446 A:middle
it doesn't read very
well when you call it.

00:17:40.246 --> 00:17:43.106 A:middle
sendMessage recipient
Morgan is pretty awkward.

00:17:44.046 --> 00:17:46.156 A:middle
When you call a function, you
want it to read naturally.

00:17:46.156 --> 00:17:49.256 A:middle
In this case you'd like it to
say something like sendMessage

00:17:49.256 --> 00:17:52.046 A:middle
to Morgan, which forms a
nice grammatical phrase.

00:17:52.596 --> 00:17:54.646 A:middle
And you could do this
by changing the name

00:17:54.646 --> 00:17:56.686 A:middle
of the parameter, which
then changes the name

00:17:56.686 --> 00:17:59.786 A:middle
of the argument label, and this
does make the function read

00:17:59.786 --> 00:18:02.276 A:middle
better when you call it,
sendMessage to Morgan,

00:17:59.786 --> 00:18:02.276 A:middle
better when you call it,
sendMessage to Morgan,

00:18:03.076 --> 00:18:06.236 A:middle
but it doesn't work so well
inside the body of the function.

00:18:07.286 --> 00:18:09.816 A:middle
Inside the body you really
want a noun for the parameter,

00:18:09.816 --> 00:18:13.316 A:middle
not a preposition, hey
there to, isn't so great.

00:18:14.696 --> 00:18:16.456 A:middle
But sometimes there
isn't a single word

00:18:16.456 --> 00:18:20.276 A:middle
that works well both inside the
function's body and as a label

00:18:20.276 --> 00:18:21.226 A:middle
when you call the function.

00:18:22.166 --> 00:18:23.876 A:middle
In Swift you don't have
to give one of these up.

00:18:24.676 --> 00:18:27.216 A:middle
When a parameter's name
isn't appropriate as a label

00:18:27.896 --> 00:18:29.236 A:middle
for the argument
when you call it,

00:18:29.716 --> 00:18:33.006 A:middle
you can explicitly provide
a more suitable one.

00:18:33.326 --> 00:18:35.856 A:middle
You write the explicit
argument label in front

00:18:35.856 --> 00:18:36.726 A:middle
of the parameter's name.

00:18:37.016 --> 00:18:39.596 A:middle
Here we've added to as an
explicit argument label

00:18:39.596 --> 00:18:42.436 A:middle
in addition to the recipient
parameter, and this just means

00:18:42.436 --> 00:18:44.126 A:middle
that you can use to when
you call the function,

00:18:44.746 --> 00:18:48.286 A:middle
sendMessage to Morgan, and you
can still use recipient inside

00:18:48.286 --> 00:18:49.366 A:middle
the body of the function.

00:18:49.906 --> 00:18:53.546 A:middle
Let's add one more
parameter to the function

00:18:53.546 --> 00:18:56.226 A:middle
which lets you provide a custom
message when you call it.

00:18:57.256 --> 00:18:59.736 A:middle
Here we've added a message
parameter of type string.

00:19:00.376 --> 00:19:01.536 A:middle
Now when you call the function,

00:19:01.536 --> 00:19:04.716 A:middle
you can pass on your
own message.

00:19:04.846 --> 00:19:07.176 A:middle
Now, once again, this
code works as expected,

00:19:07.626 --> 00:19:09.266 A:middle
but it doesn't read
very well either.

00:19:10.166 --> 00:19:12.646 A:middle
sendMessage message
is redundant.

00:19:13.706 --> 00:19:16.436 A:middle
The message label isn't
helping to clarify the role

00:19:16.486 --> 00:19:19.336 A:middle
of the first argument
because it's already clear

00:19:19.336 --> 00:19:21.256 A:middle
from the base name of the
function, sendMessage.

00:19:22.026 --> 00:19:24.956 A:middle
Here the argument label actually
makes the code harder to read.

00:19:24.956 --> 00:19:28.276 A:middle
In the cases like these, you
can write an underscore in front

00:19:28.276 --> 00:19:29.226 A:middle
of the parameter's name.

00:19:30.366 --> 00:19:32.626 A:middle
And this means that you don't
provide a label for the argument

00:19:32.976 --> 00:19:37.106 A:middle
when you call the function.

00:19:37.226 --> 00:19:39.346 A:middle
And now our function reads
naturally when you call it;

00:19:39.466 --> 00:19:41.456 A:middle
sendMessage, See you
at the bash, to Morgan.

00:19:42.006 --> 00:19:46.506 A:middle
Now, it's not very often that
we need to shout our message,

00:19:46.546 --> 00:19:49.536 A:middle
so we usually pass in
false for that argument,

00:19:49.536 --> 00:19:52.486 A:middle
and in Swift you can actually
capture this behavior right

00:19:52.486 --> 00:19:53.906 A:middle
in the declaration
of the function.

00:19:54.716 --> 00:19:57.416 A:middle
Whenever a parameter has a
single commonly used value,

00:19:57.896 --> 00:20:01.536 A:middle
you can provide that value as
the default, and you do this

00:19:57.896 --> 00:20:01.536 A:middle
you can provide that value as
the default, and you do this

00:20:01.536 --> 00:20:04.096 A:middle
by assigning a default
value, in this case false,

00:20:04.706 --> 00:20:06.216 A:middle
right after the type
of the parameter,

00:20:07.126 --> 00:20:08.926 A:middle
and now when you call the
function, you can leave

00:20:08.926 --> 00:20:12.466 A:middle
out the corresponding argument
and the default value is used.

00:20:14.876 --> 00:20:16.966 A:middle
And when you're deciding
whether to use or when

00:20:16.966 --> 00:20:20.796 A:middle
to use an explicit argument
label, when to omit one or when

00:20:20.796 --> 00:20:22.906 A:middle
to provide default
values for parameters,

00:20:23.246 --> 00:20:25.626 A:middle
remember that functions
are declared only once,

00:20:25.996 --> 00:20:27.216 A:middle
but they're used repeatedly.

00:20:27.516 --> 00:20:30.386 A:middle
So the most important thing is
that the function reads clearly

00:20:30.386 --> 00:20:31.916 A:middle
and concisely when it's called.

00:20:32.296 --> 00:20:35.146 A:middle
Now, to learn much
more about the kinds

00:20:35.146 --> 00:20:36.236 A:middle
of things you should consider

00:20:36.516 --> 00:20:37.816 A:middle
when you're writing
great Swift API,

00:20:38.986 --> 00:20:41.446 A:middle
check out the Swift
API Guidelines talk.

00:20:42.066 --> 00:20:44.796 A:middle
So we've looked at lots of
ways functions can take values.

00:20:45.296 --> 00:20:47.756 A:middle
Let's take a look at some of
the ways they can return values.

00:20:48.896 --> 00:20:50.206 A:middle
Let's say you want
to write a function

00:20:50.206 --> 00:20:51.856 A:middle
that returns a first
string in an array

00:20:52.076 --> 00:20:53.176 A:middle
that has a given prefix.

00:20:54.656 --> 00:20:58.556 A:middle
The function takes a string
prefix, an array of strings,

00:20:59.046 --> 00:21:01.856 A:middle
and it returns the string
with a given prefix.

00:20:59.046 --> 00:21:01.856 A:middle
and it returns the string
with a given prefix.

00:21:02.016 --> 00:21:04.826 A:middle
As you can see, you use an
arrow to indicate what type

00:21:04.826 --> 00:21:06.376 A:middle
of values your function
can return.

00:21:06.806 --> 00:21:07.726 A:middle
In this case a string.

00:21:08.636 --> 00:21:09.966 A:middle
So let's see how it works.

00:21:11.196 --> 00:21:13.956 A:middle
First use a for-in loop to
iterate through each string

00:21:13.956 --> 00:21:16.766 A:middle
in the array and then you
check whether a string has a

00:21:16.766 --> 00:21:17.686 A:middle
given prefix.

00:21:18.256 --> 00:21:21.926 A:middle
You need to check whether the
string has a given prefix using

00:21:21.926 --> 00:21:23.306 A:middle
strings.hasprefix method.

00:21:23.336 --> 00:21:27.236 A:middle
If it does, you're done and you
can simply return the string

00:21:27.236 --> 00:21:28.746 A:middle
by writing it in a
return statement.

00:21:30.516 --> 00:21:31.726 A:middle
But what do you return

00:21:31.726 --> 00:21:34.166 A:middle
if the array doesn't contain
the string you're looking for?

00:21:35.196 --> 00:21:37.586 A:middle
Well, because this function was
declared to return a string,

00:21:37.906 --> 00:21:40.726 A:middle
the only option you have
is some valid string value,

00:21:41.056 --> 00:21:42.236 A:middle
in this case the empty string.

00:21:43.056 --> 00:21:44.426 A:middle
But this is not good Swift code.

00:21:45.556 --> 00:21:48.136 A:middle
However, as Dave showed
earlier, optionals are perfect

00:21:48.136 --> 00:21:50.386 A:middle
for representing values
that may be missing.

00:21:51.786 --> 00:21:54.076 A:middle
So you just need to change the
return type of this function

00:21:54.076 --> 00:21:56.426 A:middle
to be an optional string
by writing a question mark

00:21:56.426 --> 00:21:58.876 A:middle
after string, and now
you can return nil

00:21:59.066 --> 00:22:00.316 A:middle
when the string isn't found.

00:21:59.066 --> 00:22:00.316 A:middle
when the string isn't found.

00:22:01.336 --> 00:22:03.916 A:middle
And because the function
returns an optional string,

00:22:04.166 --> 00:22:06.256 A:middle
you can call it safely
in an if-let statement.

00:22:07.626 --> 00:22:10.376 A:middle
Now, notice that Swift infers
a return type of the function,

00:22:10.806 --> 00:22:13.436 A:middle
so there's no need to
write it explicitly here.

00:22:14.256 --> 00:22:16.736 A:middle
So we've looked at some of
the ways functions can take

00:22:16.986 --> 00:22:19.796 A:middle
and return values of various
types, such as strings,

00:22:19.876 --> 00:22:22.796 A:middle
integers, arrays and
even optional types.

00:22:23.446 --> 00:22:25.836 A:middle
Let's take a look at writing
one more kind of function.

00:22:28.036 --> 00:22:30.236 A:middle
Let's say you want to write a
function that filters an array

00:22:30.236 --> 00:22:31.886 A:middle
of numbers based
on some condition.

00:22:33.036 --> 00:22:34.786 A:middle
Let's think about what
this function needs to do.

00:22:34.786 --> 00:22:39.396 A:middle
It's going to take in an array
of numbers and for each number

00:22:39.396 --> 00:22:41.606 A:middle
in the array it's going to
determine whether to include

00:22:41.606 --> 00:22:43.266 A:middle
that number in the
filtered results.

00:22:44.296 --> 00:22:46.536 A:middle
For example, if you wanted
an array that's been filtered

00:22:46.536 --> 00:22:48.506 A:middle
to contain only the
even numbers here,

00:22:49.516 --> 00:22:51.656 A:middle
you could test whether each
number is divisible by two.

00:22:52.416 --> 00:22:54.386 A:middle
In this case, of
course, four is even,

00:22:54.546 --> 00:22:57.336 A:middle
so it's included in
the result array.

00:22:58.096 --> 00:23:00.176 A:middle
If a number isn't
even, such as 17,

00:22:58.096 --> 00:23:00.176 A:middle
If a number isn't
even, such as 17,

00:23:00.176 --> 00:23:03.096 A:middle
the filtering function just
moves on to the next number

00:23:03.096 --> 00:23:05.696 A:middle
to test, and so on through
the rest of the array.

00:23:06.736 --> 00:23:10.766 A:middle
Now, let's look at writing
this function in code.

00:23:10.936 --> 00:23:12.876 A:middle
The function declaration
is what you might expect,

00:23:12.876 --> 00:23:16.276 A:middle
but what type do you put in for
the includeNumber parameter?

00:23:17.056 --> 00:23:19.236 A:middle
As you saw a few moments
ago, deciding whether

00:23:19.236 --> 00:23:20.156 A:middle
to include a number

00:23:20.156 --> 00:23:23.416 A:middle
in the filtered result is
itself actually a function,

00:23:23.736 --> 00:23:26.146 A:middle
not just a simple value,
like a string or a number,

00:23:27.256 --> 00:23:31.176 A:middle
and in Swift functions can take
other functions as parameters.

00:23:32.066 --> 00:23:33.966 A:middle
So what does the type
of a function look like.

00:23:33.966 --> 00:23:37.566 A:middle
Well, all function types in
Swift have this basic form.

00:23:38.186 --> 00:23:40.226 A:middle
The type of the function's
parameters, if any,

00:23:40.736 --> 00:23:43.716 A:middle
go inside of the parentheses,
followed by an arrow

00:23:43.716 --> 00:23:45.446 A:middle
and the function's return type.

00:23:46.056 --> 00:23:48.996 A:middle
So, for example, here's our
basic send message function

00:23:48.996 --> 00:23:49.556 A:middle
from earlier.

00:23:50.296 --> 00:23:52.176 A:middle
It has the type,
empty parentheses

00:23:52.406 --> 00:23:54.956 A:middle
because it doesn't take
any parameters, arrow Void.

00:23:55.886 --> 00:23:58.306 A:middle
Here void just means it
doesn't return any values.

00:23:59.486 --> 00:24:01.796 A:middle
And in Swift if your function
doesn't return anything,

00:23:59.486 --> 00:24:01.796 A:middle
And in Swift if your function
doesn't return anything,

00:24:01.796 --> 00:24:03.966 A:middle
you don't need to write
the arrow Void explicitly.

00:24:09.056 --> 00:24:11.046 A:middle
And here's the firstString
function.

00:24:11.506 --> 00:24:13.196 A:middle
Its signature is a
little more complicated,

00:24:13.526 --> 00:24:15.496 A:middle
but its type follows
the same basic form.

00:24:16.356 --> 00:24:18.456 A:middle
It takes a string,
an array of strings

00:24:18.456 --> 00:24:19.616 A:middle
and it returns an
optional string.

00:24:20.456 --> 00:24:23.236 A:middle
So now that you've seen this
syntax for function types,

00:24:23.286 --> 00:24:24.776 A:middle
it's pretty clear how you need

00:24:24.776 --> 00:24:26.796 A:middle
to finish the declaration
for filterInts.

00:24:27.936 --> 00:24:30.546 A:middle
The includeNumber
parameter can be any function

00:24:31.086 --> 00:24:33.886 A:middle
that takes an integer and
returns a Boolean, and you write

00:24:33.886 --> 00:24:37.386 A:middle
that type as Int in
parentheses, arrow Bool.

00:24:38.236 --> 00:24:40.116 A:middle
So let's go ahead and write
the rest of this function.

00:24:40.476 --> 00:24:44.186 A:middle
You need to build up an
array of filtered numbers,

00:24:44.326 --> 00:24:45.826 A:middle
so here's a variable
called result.

00:24:46.056 --> 00:24:48.246 A:middle
It's been initialized to
an empty array of Ints.

00:24:49.386 --> 00:24:51.146 A:middle
And as you iterate through
the array of numbers,

00:24:51.146 --> 00:24:52.876 A:middle
pass into the function, you need

00:24:52.876 --> 00:24:54.556 A:middle
to check whether each
number should be included

00:24:54.556 --> 00:24:55.496 A:middle
in the result array.

00:24:56.946 --> 00:25:00.146 A:middle
To do that you pass each number
to the includeNumber function,

00:24:56.946 --> 00:25:00.146 A:middle
To do that you pass each number
to the includeNumber function,

00:25:00.616 --> 00:25:02.816 A:middle
and notice that inside
the body of filterInts,

00:25:02.816 --> 00:25:05.946 A:middle
the includeNumber parameter
is treated as a name

00:25:06.026 --> 00:25:08.526 A:middle
of the function it's passed
in, and that just means

00:25:08.526 --> 00:25:09.826 A:middle
that you can call
it in the same way

00:25:09.826 --> 00:25:11.146 A:middle
that you do any other function.

00:25:11.246 --> 00:25:13.876 A:middle
So that's how you
write a function

00:25:13.976 --> 00:25:15.826 A:middle
that takes another
function as a parameter.

00:25:16.576 --> 00:25:18.476 A:middle
But how do you call one of
these kind of functions?

00:25:19.636 --> 00:25:21.126 A:middle
Well, first you're going
to need some values

00:25:21.126 --> 00:25:22.186 A:middle
to pass into filterInts.

00:25:22.956 --> 00:25:24.286 A:middle
So here's an array of numbers

00:25:24.526 --> 00:25:26.836 A:middle
and a simple function
called divisibleByTwo

00:25:27.086 --> 00:25:28.756 A:middle
that indicates whether
an integer is even.

00:25:29.796 --> 00:25:32.836 A:middle
As you can see, the type

00:25:32.836 --> 00:25:35.836 A:middle
of divisibleByTwo
matches exactly the type

00:25:35.836 --> 00:25:37.146 A:middle
of the includeNumber parameter.

00:25:37.866 --> 00:25:42.686 A:middle
So that means that we can pass
the divisibleByTwo function

00:25:43.206 --> 00:25:44.896 A:middle
as an argument to filterInts.

00:25:45.436 --> 00:25:48.546 A:middle
You do this by simply
passing in the name

00:25:48.546 --> 00:25:52.436 A:middle
of the divisibleByTwo function
and now you've got an array

00:25:52.436 --> 00:25:53.736 A:middle
of only the even numbers.

00:25:54.906 --> 00:25:56.996 A:middle
Now, notice that you don't
include the parentheses

00:25:57.246 --> 00:25:59.526 A:middle
when you pass in the
divisibleByTwo function,

00:25:59.806 --> 00:26:02.046 A:middle
and that's because you're
not calling it at this point.

00:25:59.806 --> 00:26:02.046 A:middle
and that's because you're
not calling it at this point.

00:26:02.566 --> 00:26:05.236 A:middle
Instead, it's called later
inside the body of filterInts.

00:26:05.726 --> 00:26:09.956 A:middle
Also notice that we passed in
the array of numbers by name,

00:26:11.336 --> 00:26:14.266 A:middle
but you could have passed
in a literal array instead;

00:26:14.586 --> 00:26:16.836 A:middle
for instance, if you just
needed to pass in a few values

00:26:17.106 --> 00:26:19.666 A:middle
without needing to create
a constant for later reuse.

00:26:20.936 --> 00:26:24.126 A:middle
The same is true for passing
in functions as arguments.

00:26:26.616 --> 00:26:29.616 A:middle
It's not very likely that the
divisibleByTwo function will

00:26:29.616 --> 00:26:30.806 A:middle
find much reuse.

00:26:31.286 --> 00:26:32.846 A:middle
And it would be pretty
cumbersome to have

00:26:32.846 --> 00:26:35.666 A:middle
to make a new function every
time you wanted to pass

00:26:35.666 --> 00:26:37.146 A:middle
in a different filterInt
condition.

00:26:37.726 --> 00:26:40.916 A:middle
And if you look at the important
parts of divisibleByTwo,

00:26:40.916 --> 00:26:43.046 A:middle
you can see that
giving it a name

00:26:43.046 --> 00:26:46.476 A:middle
at all is really just a
convenience geared toward reuse.

00:26:47.736 --> 00:26:51.456 A:middle
divisibleByTwo is just a
name for the functionality

00:26:51.456 --> 00:26:52.636 A:middle
that you see highlighted.

00:26:54.496 --> 00:26:57.126 A:middle
And in Swift, just as you
can write a literal string

00:26:57.496 --> 00:27:00.226 A:middle
or a literal array, you can
write a literal function

00:26:57.496 --> 00:27:00.226 A:middle
or a literal array, you can
write a literal function

00:27:00.826 --> 00:27:02.826 A:middle
without a name called
a closure expression

00:27:03.156 --> 00:27:04.286 A:middle
and pass it around in your code.

00:27:05.496 --> 00:27:08.136 A:middle
The syntax for writing a closure
expression is very similar

00:27:08.136 --> 00:27:09.266 A:middle
to a function declaration,

00:27:09.266 --> 00:27:10.876 A:middle
except that it doesn't
have a name.

00:27:11.356 --> 00:27:14.496 A:middle
You write the entire body
of the closure inside

00:27:14.496 --> 00:27:17.766 A:middle
of the curly braces and you
separate the closure's body

00:27:18.106 --> 00:27:20.406 A:middle
from its signature
using the Int keyword,

00:27:20.936 --> 00:27:24.536 A:middle
as in use the parameter
number of type Int in the body

00:27:24.536 --> 00:27:26.166 A:middle
of this closure,
which returns a Bool.

00:27:26.166 --> 00:27:30.886 A:middle
Now, this is the most
explicit or complete way

00:27:30.886 --> 00:27:33.546 A:middle
to write a closure, but
as you've seen before,

00:27:33.546 --> 00:27:35.376 A:middle
Swift can infer a
lot of information

00:27:35.376 --> 00:27:37.656 A:middle
from the context
your code appears in.

00:27:39.216 --> 00:27:42.686 A:middle
For example, the function type
of the closure is already known

00:27:42.886 --> 00:27:44.866 A:middle
from the type of the
includeNumber parameter,

00:27:45.926 --> 00:27:47.996 A:middle
and this means you don't
need to write it explicitly.

00:27:48.536 --> 00:27:51.046 A:middle
And when the entire body

00:27:51.046 --> 00:27:54.076 A:middle
of the closure is a single
return statement, as it is here,

00:27:54.856 --> 00:27:56.906 A:middle
you don't need to write
the return keyword either.

00:27:57.506 --> 00:28:01.426 A:middle
So this is much cleaner syntax,
but because the closure's

00:27:57.506 --> 00:28:01.426 A:middle
So this is much cleaner syntax,
but because the closure's

00:28:01.426 --> 00:28:05.396 A:middle
so short, even the number
parameter seems a bit redundant.

00:28:06.216 --> 00:28:09.236 A:middle
And in cases like these Swift
provides implicit argument

00:28:09.236 --> 00:28:10.636 A:middle
names, so there's no need

00:28:10.636 --> 00:28:13.366 A:middle
to even write the parameter
name or the Int keyword.

00:28:13.886 --> 00:28:17.436 A:middle
These implicit arguments
start with dollar sign

00:28:17.436 --> 00:28:18.626 A:middle
and a number beginning at 0.

00:28:18.626 --> 00:28:21.676 A:middle
So $0 refers to the first
argument to the closure,

00:28:21.676 --> 00:28:23.076 A:middle
$1 the second, and so on.

00:28:23.236 --> 00:28:25.916 A:middle
And even though these
are available to use

00:28:25.916 --> 00:28:29.226 A:middle
in any closure expression,
use them when doing

00:28:29.226 --> 00:28:32.566 A:middle
so doesn't make your
code harder to read.

00:28:33.676 --> 00:28:36.606 A:middle
Now, you've seen that Swift
provides lots of convenient ways

00:28:36.606 --> 00:28:37.456 A:middle
for writing closures,

00:28:38.096 --> 00:28:42.026 A:middle
but passing them directly inside
a function's parentheses is a

00:28:42.026 --> 00:28:43.396 A:middle
little punctuation heavy.

00:28:44.206 --> 00:28:45.996 A:middle
A closing curly brace right next

00:28:45.996 --> 00:28:48.196 A:middle
to a closing paren
is pretty terrible.

00:28:48.196 --> 00:28:53.206 A:middle
However, when the closure is the
last argument to the function,

00:28:53.206 --> 00:28:56.076 A:middle
as it is in this case,
you can write it instead

00:28:56.076 --> 00:28:59.176 A:middle
as a trailing closure right
outside of the parentheses.

00:29:00.426 --> 00:29:03.606 A:middle
And as you'll see later, if
the closure's the only argument

00:29:03.606 --> 00:29:06.436 A:middle
to a function, you can drop
the parentheses altogether.

00:29:07.046 --> 00:29:09.846 A:middle
Now, trailing closures
are especially nice

00:29:10.446 --> 00:29:12.946 A:middle
when the closure contains
more than one line of code.

00:29:13.886 --> 00:29:16.256 A:middle
For example, here's a
more complex closure

00:29:16.486 --> 00:29:19.846 A:middle
that determines whether the sum
of a number's digits is even.

00:29:21.156 --> 00:29:24.956 A:middle
Trailing closure syntax ensures
that even complex closures

00:29:24.956 --> 00:29:28.776 A:middle
with multiline functionality
read naturally and elegantly.

00:29:29.316 --> 00:29:34.006 A:middle
Now, the filterInts function is
pretty useful if all you want

00:29:34.006 --> 00:29:37.326 A:middle
to do is filter integers,
but what if you want

00:29:37.326 --> 00:29:39.196 A:middle
to filter arrays of other
types, like strings.

00:29:40.506 --> 00:29:42.566 A:middle
For example, say you
have an array of names

00:29:42.916 --> 00:29:45.376 A:middle
and you want a filtered array
that contains only the names

00:29:45.376 --> 00:29:47.426 A:middle
that have less than a
certain number of characters.

00:29:48.776 --> 00:29:51.006 A:middle
You could do this by writing
a filter string function

00:29:51.006 --> 00:29:51.976 A:middle
like the one you see here,

00:29:52.776 --> 00:29:54.956 A:middle
and since you've already
written a filterInts function,

00:29:55.466 --> 00:29:58.166 A:middle
let's see whether you can
reuse any of that logic.

00:29:59.316 --> 00:30:01.536 A:middle
Well, first, you'd obviously
want to do some bookkeeping

00:29:59.316 --> 00:30:01.536 A:middle
Well, first, you'd obviously
want to do some bookkeeping

00:30:01.766 --> 00:30:03.226 A:middle
and change all the
places that refer

00:30:03.226 --> 00:30:05.246 A:middle
to numbers to refer to strings.

00:30:06.566 --> 00:30:08.036 A:middle
And next you need to change all

00:30:08.036 --> 00:30:11.146 A:middle
of the Int types
to be string types.

00:30:11.696 --> 00:30:14.766 A:middle
And because the behavior

00:30:14.766 --> 00:30:16.436 A:middle
of these two functions
is actually the same

00:30:16.436 --> 00:30:17.876 A:middle
for both integers and strings,

00:30:18.346 --> 00:30:19.756 A:middle
there's really nothing
else to do.

00:30:19.906 --> 00:30:21.336 A:middle
They're essentially
the same function.

00:30:22.406 --> 00:30:23.646 A:middle
And now you have this function

00:30:23.646 --> 00:30:24.946 A:middle
that filters an array
of strings.

00:30:26.146 --> 00:30:28.456 A:middle
Now, if you want a
filtered function that works

00:30:28.456 --> 00:30:32.186 A:middle
for other kinds of types, you
can repeat this process over

00:30:32.186 --> 00:30:34.496 A:middle
and over and over again
for each kind of type,

00:30:35.166 --> 00:30:37.536 A:middle
but this would obviously
get boring pretty quickly.

00:30:38.696 --> 00:30:41.676 A:middle
So instead, you can write
one function that works

00:30:41.676 --> 00:30:43.496 A:middle
with arrays of any kind of type.

00:30:43.946 --> 00:30:45.436 A:middle
This is called a
generic function.

00:30:46.456 --> 00:30:48.956 A:middle
So let's look at
how you write one.

00:30:48.956 --> 00:30:51.106 A:middle
Writing one is not
much different

00:30:51.106 --> 00:30:52.096 A:middle
than what you've seen already.

00:30:53.016 --> 00:30:54.846 A:middle
First you change the
names to be more generic.

00:30:55.226 --> 00:30:58.176 A:middle
So, for example, the function's
name is simply filter,

00:30:58.176 --> 00:31:00.536 A:middle
rather than filterInts
or filterStrings.

00:30:58.176 --> 00:31:00.536 A:middle
rather than filterInts
or filterStrings.

00:31:01.716 --> 00:31:04.406 A:middle
Next, and more importantly, you
need to fill in the placeholders

00:31:04.406 --> 00:31:07.266 A:middle
that you see here with
the type of the elements,

00:31:07.976 --> 00:31:09.906 A:middle
but you don't know
what that type is yet.

00:31:10.956 --> 00:31:13.666 A:middle
So instead, what you really
want is a type parameter.

00:31:14.206 --> 00:31:16.986 A:middle
The actual type is determined
when the function is called.

00:31:17.446 --> 00:31:19.836 A:middle
Here we filled in
the placeholders

00:31:20.576 --> 00:31:22.746 A:middle
with a generic type
parameter called element.

00:31:23.686 --> 00:31:25.066 A:middle
And so that you can
tell the difference

00:31:25.066 --> 00:31:28.316 A:middle
between type parameters and
actual pre existing types

00:31:28.316 --> 00:31:31.916 A:middle
like strings or integers,
you write the type parameters

00:31:31.916 --> 00:31:34.996 A:middle
up front inside of the
angle brackets right

00:31:34.996 --> 00:31:36.086 A:middle
after the function's name.

00:31:36.866 --> 00:31:39.126 A:middle
And now you have a generic
filter function that works

00:31:39.126 --> 00:31:44.566 A:middle
with an array that
contains any type of values.

00:31:44.626 --> 00:31:47.126 A:middle
You call this kind of function
in the same way as before.

00:31:47.486 --> 00:31:49.896 A:middle
You don't need to specify the
type you want the function

00:31:49.896 --> 00:31:51.976 A:middle
to work with because
it's all inferred

00:31:51.976 --> 00:31:54.586 A:middle
from the values you pass in.

00:31:54.786 --> 00:31:56.816 A:middle
Filtering is such
a useful operation

00:31:56.816 --> 00:32:00.226 A:middle
that the Swift standard library
has a filter method that works

00:31:56.816 --> 00:32:00.226 A:middle
that the Swift standard library
has a filter method that works

00:32:00.226 --> 00:32:02.136 A:middle
with any kind of
sequence or collection.

00:32:02.946 --> 00:32:05.366 A:middle
It works in basically
the same way

00:32:05.366 --> 00:32:08.736 A:middle
as the filter function you just
saw, except that it's a method

00:32:08.736 --> 00:32:10.416 A:middle
so you call it using
dot notation,

00:32:10.816 --> 00:32:12.786 A:middle
names.filter, as you see here.

00:32:13.436 --> 00:32:16.586 A:middle
The Swift standard
library actually has lots

00:32:16.586 --> 00:32:19.356 A:middle
of other methods that take
closures as arguments.

00:32:19.966 --> 00:32:22.456 A:middle
And another really useful
one is the map method,

00:32:22.806 --> 00:32:24.956 A:middle
and it also works with any
sequence or collection.

00:32:25.336 --> 00:32:29.196 A:middle
Map returns a new array
that contains the result

00:32:29.196 --> 00:32:30.896 A:middle
of a plan enclosure
to each element.

00:32:31.396 --> 00:32:33.636 A:middle
So here's an example that
calls map on the array

00:32:33.636 --> 00:32:35.006 A:middle
of short names from above.

00:32:35.226 --> 00:32:38.276 A:middle
It passes a closure that
simply upper cases each string.

00:32:40.656 --> 00:32:42.496 A:middle
You can even chain
these together

00:32:42.496 --> 00:32:44.556 A:middle
to perform multiple operations.

00:32:44.946 --> 00:32:46.816 A:middle
So, for example, you can
perform the filtering

00:32:46.816 --> 00:32:48.966 A:middle
and the upper casing
in one expression.

00:32:49.596 --> 00:32:52.036 A:middle
By chaining these two
method calls together using

00:32:52.036 --> 00:32:52.716 A:middle
dot notation.

00:32:53.266 --> 00:32:55.926 A:middle
The filtering happens first,
and then map is called

00:32:55.926 --> 00:32:56.976 A:middle
on the filtered array,

00:32:57.246 --> 00:32:59.616 A:middle
which then finally returns
the upper cased strings.

00:33:01.546 --> 00:33:02.976 A:middle
And this reads nicely even

00:33:02.976 --> 00:33:05.126 A:middle
when you're using the
trailing closure syntax.

00:33:05.636 --> 00:33:09.706 A:middle
So the combination of closures
and functions that take them

00:33:09.706 --> 00:33:13.596 A:middle
as arguments makes it possible
to write really complex,

00:33:14.426 --> 00:33:18.226 A:middle
powerful code in a concise
yet highly expressive way.

00:33:18.956 --> 00:33:21.186 A:middle
So we've looked at
functions and closures,

00:33:21.186 --> 00:33:23.026 A:middle
and even a bit of
generic functions.

00:33:23.296 --> 00:33:25.606 A:middle
I'd like to invite Alex
on stage to tell you all

00:33:25.606 --> 00:33:26.976 A:middle
about data types in Swift.

00:33:27.516 --> 00:33:33.906 A:middle
[ Applause ]

00:33:34.406 --> 00:33:35.096 A:middle
&gt;&gt; Thanks, Brian.

00:33:36.236 --> 00:33:38.816 A:middle
You've seen how to use
existing data types in Swift.

00:33:39.626 --> 00:33:41.066 A:middle
Now let's take a look at how

00:33:41.066 --> 00:33:44.426 A:middle
to create some data
types of our own.

00:33:44.676 --> 00:33:46.136 A:middle
Let's start with structures.

00:33:46.766 --> 00:33:48.856 A:middle
You create one like this.

00:33:49.086 --> 00:33:51.476 A:middle
You write the struct
keyword followed

00:33:51.476 --> 00:33:52.726 A:middle
by the name of a structure.

00:33:53.206 --> 00:33:54.486 A:middle
Here, rectangle.

00:33:55.896 --> 00:34:01.726 A:middle
Then inside the curly braces
you write the properties

00:33:55.896 --> 00:34:01.726 A:middle
Then inside the curly braces
you write the properties

00:34:01.726 --> 00:34:02.566 A:middle
of the structure.

00:34:03.776 --> 00:34:07.356 A:middle
Properties use the same
syntax you've seen before

00:34:07.356 --> 00:34:09.315 A:middle
for variables and constants.

00:34:10.876 --> 00:34:14.456 A:middle
Both properties here have
the value assigned as part

00:34:14.456 --> 00:34:17.735 A:middle
of the declaration, so
you can create a rectangle

00:34:18.136 --> 00:34:20.356 A:middle
by just writing rectangle,
the name,

00:34:21.206 --> 00:34:22.936 A:middle
followed by a pair
of parentheses.

00:34:24.005 --> 00:34:27.726 A:middle
And to access the properties,
you use dot notation.

00:34:29.735 --> 00:34:33.766 A:middle
You don't have to provide a
value for a property as part

00:34:33.766 --> 00:34:34.996 A:middle
of the types declaration.

00:34:35.496 --> 00:34:37.636 A:middle
In fact, most of
the time you don't.

00:34:38.386 --> 00:34:43.176 A:middle
More often, you write just the
type and then you set the value

00:34:43.275 --> 00:34:44.666 A:middle
when you create the instance.

00:34:46.206 --> 00:34:47.846 A:middle
So another property

00:34:47.846 --> 00:34:51.366 A:middle
of a rectangle besides its
dimensions is its area.

00:34:52.636 --> 00:34:54.966 A:middle
You wouldn't want to
store the area though.

00:34:55.166 --> 00:34:58.736 A:middle
You'd have to update it every
time the dimensions changed.

00:34:59.586 --> 00:35:03.976 A:middle
What you want is a property
whose value is calculated right

00:34:59.586 --> 00:35:03.976 A:middle
What you want is a property
whose value is calculated right

00:35:03.976 --> 00:35:06.456 A:middle
at the point you need
it and you can do

00:35:06.456 --> 00:35:08.706 A:middle
that using a computed property.

00:35:10.206 --> 00:35:14.996 A:middle
To make a computed property,
after the property's name

00:35:15.096 --> 00:35:19.216 A:middle
and its type, you write a
function body that's responsible

00:35:19.216 --> 00:35:23.476 A:middle
for computing and returning the
current value of the function.

00:35:24.766 --> 00:35:27.536 A:middle
Even though it's computed
rather than being stored,

00:35:27.746 --> 00:35:30.266 A:middle
you still access it
using dot notation.

00:35:31.776 --> 00:35:33.796 A:middle
There's more that you
can do with properties.

00:35:34.476 --> 00:35:38.936 A:middle
You can have setters and
observers, and you can find

00:35:38.936 --> 00:35:42.786 A:middle
out information about those
in the Properties chapter

00:35:43.326 --> 00:35:45.386 A:middle
of the Swift Programming
Language.

00:35:47.716 --> 00:35:50.956 A:middle
Just like you can define
properties on a structure,

00:35:51.346 --> 00:35:52.936 A:middle
you can also define methods.

00:35:54.276 --> 00:35:57.666 A:middle
They use the same syntax you've
seen already for functions.

00:35:58.976 --> 00:36:03.546 A:middle
And just like properties, you
access them using dot notation

00:35:58.976 --> 00:36:03.546 A:middle
And just like properties, you
access them using dot notation

00:36:03.786 --> 00:36:08.416 A:middle
when you need to call them.

00:36:08.616 --> 00:36:12.286 A:middle
You've seen this syntax a few
times to create a rectangle.

00:36:13.066 --> 00:36:15.506 A:middle
Let's look at what it does
in a little bit more detail.

00:36:17.256 --> 00:36:20.076 A:middle
It looks a little bit
like a function call

00:36:20.226 --> 00:36:21.736 A:middle
because of the parenthesis,

00:36:22.226 --> 00:36:24.356 A:middle
but it's actually
calling an initializer.

00:36:25.136 --> 00:36:29.556 A:middle
So far we've been using a
special initializer called a

00:36:29.556 --> 00:36:32.946 A:middle
member wise initializer
that Swift implements

00:36:33.056 --> 00:36:34.826 A:middle
for you on structures.

00:36:35.766 --> 00:36:37.926 A:middle
Here's what it would
look like if you write

00:36:37.926 --> 00:36:39.986 A:middle
that initializer out explicitly.

00:36:41.276 --> 00:36:46.036 A:middle
You write the init keyword and
then inside you set a value

00:36:46.126 --> 00:36:47.796 A:middle
for the rectangle's properties.

00:36:49.046 --> 00:36:52.036 A:middle
Notice that there are two
things here called width.

00:36:52.686 --> 00:36:57.676 A:middle
There's a property and there's
a parameter, and you write self.

00:36:58.356 --> 00:37:00.706 A:middle
to explicitly refer
to the property.

00:36:58.356 --> 00:37:00.706 A:middle
to explicitly refer
to the property.

00:37:01.646 --> 00:37:04.406 A:middle
So that's how you write
your own initializer.

00:37:06.516 --> 00:37:10.036 A:middle
There's enough code in
this rectangle structure

00:37:10.396 --> 00:37:14.536 A:middle
that it could benefit from some
organization, and one way to do

00:37:14.536 --> 00:37:17.146 A:middle
that in Swift is
using extensions.

00:37:18.136 --> 00:37:21.196 A:middle
An extension lets
you add functionality

00:37:21.456 --> 00:37:22.626 A:middle
to an existing type.

00:37:23.926 --> 00:37:28.626 A:middle
In Swift you can use extensions
to divide up your code.

00:37:29.846 --> 00:37:33.626 A:middle
Core functionality can go in
the structure's declaration

00:37:33.626 --> 00:37:39.256 A:middle
and additional functionality can
go in one or more extensions.

00:37:40.586 --> 00:37:43.216 A:middle
You're not limited to
extending your own types.

00:37:43.916 --> 00:37:47.516 A:middle
If you need to, you can extend
types from other places,

00:37:47.856 --> 00:37:51.246 A:middle
such as foundation or
the standard library.

00:37:53.306 --> 00:37:56.386 A:middle
You saw earlier how you
can make a generic function

00:37:56.836 --> 00:37:59.046 A:middle
which performs the
same operations

00:37:59.486 --> 00:38:00.926 A:middle
on data of different types.

00:37:59.486 --> 00:38:00.926 A:middle
on data of different types.

00:38:02.056 --> 00:38:04.326 A:middle
You can also make
a generic structure

00:38:04.826 --> 00:38:07.206 A:middle
which contains data
of different types.

00:38:08.336 --> 00:38:10.076 A:middle
The syntax looks very similar.

00:38:10.646 --> 00:38:15.186 A:middle
You still have the generic type
parameters inside angle brackets

00:38:15.346 --> 00:38:16.026 A:middle
after the name.

00:38:16.776 --> 00:38:20.166 A:middle
This example attaches
a name to an array

00:38:20.166 --> 00:38:21.816 A:middle
of some kind of element.

00:38:23.216 --> 00:38:26.326 A:middle
This would be a useful data
structure, for example,

00:38:26.586 --> 00:38:31.386 A:middle
to populate a table view that
has sections with heading names.

00:38:31.856 --> 00:38:35.956 A:middle
You create a generic
structure instance just

00:38:35.956 --> 00:38:39.606 A:middle
like an instance
of another type.

00:38:39.806 --> 00:38:43.076 A:middle
Here you can see if you
write the type annotations,

00:38:44.236 --> 00:38:47.896 A:middle
board games and primes
have different types.

00:38:49.016 --> 00:38:51.196 A:middle
One is an array of strings

00:38:51.436 --> 00:38:53.586 A:middle
and the other is an
array of integers.

00:38:54.066 --> 00:38:56.256 A:middle
They have different
element types

00:38:57.076 --> 00:39:00.116 A:middle
so they are different types.

00:38:57.076 --> 00:39:00.116 A:middle
so they are different types.

00:39:00.296 --> 00:39:02.016 A:middle
You don't have to
write the arrays.

00:39:02.746 --> 00:39:06.076 A:middle
Swift infers what
element is automatically.

00:39:08.036 --> 00:39:09.606 A:middle
So that's structures.

00:39:11.356 --> 00:39:14.596 A:middle
Another data type
in Swift is classes.

00:39:15.816 --> 00:39:19.106 A:middle
You write class before
the name, but everything

00:39:19.106 --> 00:39:21.256 A:middle
about structures still applies.

00:39:21.706 --> 00:39:25.376 A:middle
Properties, methods,
initializers, and so on.

00:39:26.086 --> 00:39:30.826 A:middle
So why would you want
to create a class?

00:39:30.986 --> 00:39:35.286 A:middle
One reason is that your code
can refer to the same instance

00:39:35.316 --> 00:39:38.266 A:middle
of a class from several
different places,

00:39:38.346 --> 00:39:41.236 A:middle
and that's different than
the behavior you have

00:39:41.236 --> 00:39:42.196 A:middle
for structures.

00:39:42.736 --> 00:39:45.926 A:middle
A structure acts
like one big value.

00:39:46.936 --> 00:39:51.476 A:middle
For example, in a game, if
you make a score for player1,

00:39:52.436 --> 00:39:55.466 A:middle
and then give player2
the same score,

00:39:55.846 --> 00:39:58.076 A:middle
you have two independent scores.

00:39:59.066 --> 00:40:03.756 A:middle
Changing player2's score
doesn't change player1's score.

00:39:59.066 --> 00:40:03.756 A:middle
Changing player2's score
doesn't change player1's score.

00:40:04.936 --> 00:40:10.166 A:middle
However, both players need to
refer to the same file on disk

00:40:10.646 --> 00:40:12.616 A:middle
when they log their high scores.

00:40:13.936 --> 00:40:18.786 A:middle
Since it's a class, that's
the behavior that you get.

00:40:18.786 --> 00:40:23.256 A:middle
When player2 gets a new
high score and then logs it

00:40:23.256 --> 00:40:26.996 A:middle
to the file, both
players see the change.

00:40:28.596 --> 00:40:32.146 A:middle
If you're coming from another
object oriented language,

00:40:32.476 --> 00:40:35.256 A:middle
you might be used to
writing a lot of classes,

00:40:35.916 --> 00:40:38.426 A:middle
and in Swift you don't
need to write them

00:40:38.526 --> 00:40:40.086 A:middle
as often as you might think.

00:40:41.346 --> 00:40:45.826 A:middle
Anytime it makes sense to check
for equality or to make a copy,

00:40:46.936 --> 00:40:50.016 A:middle
you usually want a value
type like a structure.

00:40:51.316 --> 00:40:55.896 A:middle
For more information about how
and why to use value types,

00:40:56.256 --> 00:40:58.756 A:middle
there's a great talk
you can check out.

00:40:59.416 --> 00:41:03.036 A:middle
Another reason to use
classes is when you need

00:40:59.416 --> 00:41:03.036 A:middle
Another reason to use
classes is when you need

00:41:03.036 --> 00:41:05.336 A:middle
to subclass an existing class.

00:41:06.616 --> 00:41:09.716 A:middle
For example, suppose
you have a framework

00:41:09.976 --> 00:41:12.766 A:middle
that gives you this
fish class with sort

00:41:12.766 --> 00:41:14.706 A:middle
of core fish functionality.

00:41:16.096 --> 00:41:18.656 A:middle
You can subclass it
to add functionality,

00:41:19.296 --> 00:41:22.166 A:middle
like a FlyingFish can
add a flying method.

00:41:23.176 --> 00:41:27.786 A:middle
You indicate that this is a
subclass by writing colon fish.

00:41:28.636 --> 00:41:31.836 A:middle
Subclasses can also
override a method

00:41:32.326 --> 00:41:34.346 A:middle
to provide their
own implementation.

00:41:35.536 --> 00:41:37.136 A:middle
Like this ComplainingFish.

00:41:37.656 --> 00:41:41.816 A:middle
It swims like a normal fish, it
just complains about it first.

00:41:44.666 --> 00:41:49.706 A:middle
You write super.swim to call
the superclass' implementation.

00:41:50.826 --> 00:41:52.706 A:middle
This code doesn't compile yet.

00:41:54.006 --> 00:41:56.306 A:middle
When you override
a method in Swift,

00:41:56.746 --> 00:42:00.816 A:middle
you have to mark it
explicitly by writing override,

00:41:56.746 --> 00:42:00.816 A:middle
you have to mark it
explicitly by writing override,

00:42:01.666 --> 00:42:03.326 A:middle
and now this code works.

00:42:04.616 --> 00:42:08.666 A:middle
Just like it's an error to
override something by accident,

00:42:09.206 --> 00:42:12.076 A:middle
it's also an error
to write override

00:42:12.346 --> 00:42:14.316 A:middle
when you don't override
anything.

00:42:15.766 --> 00:42:19.656 A:middle
That means if you misspell a
method name that you're trying

00:42:19.656 --> 00:42:22.066 A:middle
to override, Swift tells you

00:42:22.066 --> 00:42:26.266 A:middle
about the error right
at compile time.

00:42:26.446 --> 00:42:29.146 A:middle
A segue can also
provide an initializer.

00:42:30.436 --> 00:42:35.056 A:middle
For example, fish that has an
initializer that takes a name.

00:42:35.946 --> 00:42:38.686 A:middle
ComplainingFish needs
an initializer

00:42:38.806 --> 00:42:41.006 A:middle
with both a name
and a complaint.

00:42:42.796 --> 00:42:46.686 A:middle
Inside the initializer
you set the initial value

00:42:46.686 --> 00:42:49.506 A:middle
for the properties
declared by the subclass,

00:42:50.376 --> 00:42:53.726 A:middle
and then you call super.init

00:42:54.866 --> 00:42:58.096 A:middle
to let the superclass
finish the initialization.

00:42:59.536 --> 00:43:02.186 A:middle
There's more you can
do with initializers,

00:42:59.536 --> 00:43:02.186 A:middle
There's more you can
do with initializers,

00:43:02.516 --> 00:43:04.296 A:middle
especially around classes.

00:43:05.146 --> 00:43:09.396 A:middle
You can read all about it
in the Initializers chapter

00:43:09.616 --> 00:43:11.676 A:middle
of the Swift Programming
Language.

00:43:13.306 --> 00:43:15.596 A:middle
You've seen how you
can use subclasses.

00:43:16.026 --> 00:43:18.746 A:middle
Now let's talk about
a subclassing problem.

00:43:20.366 --> 00:43:22.716 A:middle
Continuing the game example,

00:43:23.066 --> 00:43:25.456 A:middle
suppose you have this
player base class.

00:43:26.586 --> 00:43:28.686 A:middle
Since every player
can take a turn,

00:43:29.056 --> 00:43:31.936 A:middle
there's a method to do that.

00:43:32.006 --> 00:43:33.706 A:middle
You have two kinds of players.

00:43:34.576 --> 00:43:37.756 A:middle
You have a HumanPlayer
class, which takes its turn

00:43:38.016 --> 00:43:39.826 A:middle
by showing UI to the user.

00:43:40.606 --> 00:43:44.476 A:middle
And you have a ComputerPlayer
class which takes its turn

00:43:44.736 --> 00:43:47.016 A:middle
by finding the best legal move.

00:43:48.276 --> 00:43:51.236 A:middle
So the question then
is what goes

00:43:51.306 --> 00:43:53.196 A:middle
in the base class
implementation?

00:43:54.556 --> 00:43:57.656 A:middle
Well, there's no shared behavior

00:43:57.966 --> 00:44:00.486 A:middle
between human and
computer players.

00:43:57.966 --> 00:44:00.486 A:middle
between human and
computer players.

00:44:01.126 --> 00:44:05.296 A:middle
There isn't any shared
code to factor out.

00:44:05.296 --> 00:44:10.066 A:middle
And in the surrounding code you
would never want an instance

00:44:10.256 --> 00:44:11.536 A:middle
of the player base class.

00:44:12.586 --> 00:44:15.596 A:middle
So this method should
never be called.

00:44:16.306 --> 00:44:20.636 A:middle
The only reasonable thing you
could write here is some sort

00:44:20.636 --> 00:44:24.586 A:middle
of fatal error to help
you catch mistakes early

00:44:24.586 --> 00:44:25.846 A:middle
in the development process.

00:44:26.596 --> 00:44:31.966 A:middle
All the player class is doing
is describing what it means

00:44:32.066 --> 00:44:36.216 A:middle
to be a player, that every
player can take a turn.

00:44:37.026 --> 00:44:39.726 A:middle
It's a sort of blueprint
for players.

00:44:41.276 --> 00:44:43.696 A:middle
In Swift you express this kind

00:44:43.696 --> 00:44:46.696 A:middle
of relationship using
a protocol.

00:44:47.436 --> 00:44:51.636 A:middle
Protocols specify requirements
like methods and properties.

00:44:52.736 --> 00:44:56.086 A:middle
They're like interfaces
or abstract classes

00:44:56.396 --> 00:44:58.566 A:middle
that you might know
from other languages.

00:44:59.836 --> 00:45:02.526 A:middle
You make one using
the protocol keyword.

00:44:59.836 --> 00:45:02.526 A:middle
You make one using
the protocol keyword.

00:45:03.626 --> 00:45:07.506 A:middle
And because it describes
requirements for other types

00:45:07.506 --> 00:45:11.156 A:middle
to fulfill, you don't
provide an implementation.

00:45:12.656 --> 00:45:17.516 A:middle
Types conform to a protocol by
providing that implementation

00:45:18.426 --> 00:45:22.446 A:middle
and you declare conformance
by writing : player,

00:45:23.006 --> 00:45:25.166 A:middle
just like you do when
there's a superclass.

00:45:25.996 --> 00:45:30.026 A:middle
At this point you're
not subclassing anymore

00:45:30.516 --> 00:45:33.496 A:middle
so these methods are
not overriding anything.

00:45:34.916 --> 00:45:36.896 A:middle
So you don't write override.

00:45:39.256 --> 00:45:42.856 A:middle
There's no real reason these
need to be classes anymore,

00:45:43.406 --> 00:45:45.096 A:middle
so let's make them structures.

00:45:46.616 --> 00:45:50.346 A:middle
And let's take a closer
look at HumanPlayer.

00:45:50.936 --> 00:45:56.106 A:middle
It has a few other properties,
like a name and a score.

00:45:56.106 --> 00:46:02.146 A:middle
And if you make an instance of
player, you can print it out.

00:45:56.106 --> 00:46:02.146 A:middle
And if you make an instance of
player, you can print it out.

00:46:02.416 --> 00:46:04.566 A:middle
You get a default
description here

00:46:05.106 --> 00:46:08.266 A:middle
because the standard
library has a conversion

00:46:08.546 --> 00:46:12.356 A:middle
from any type to a string.

00:46:12.546 --> 00:46:15.336 A:middle
But what if you wanted to
customize the conversion

00:46:15.526 --> 00:46:17.236 A:middle
to print a nicer description?

00:46:18.146 --> 00:46:21.846 A:middle
The standard library also
has a protocol called

00:46:21.846 --> 00:46:23.556 A:middle
CustomStringConvertible

00:46:24.016 --> 00:46:27.826 A:middle
which lets you provide a custom
description, and here's what

00:46:27.826 --> 00:46:29.216 A:middle
that protocol looks like.

00:46:30.196 --> 00:46:33.496 A:middle
It has one requirement --
a description property.

00:46:34.996 --> 00:46:38.656 A:middle
Any type that conforms
to this protocol uses the

00:46:38.656 --> 00:46:39.736 A:middle
custom description.

00:46:40.766 --> 00:46:44.026 A:middle
Okay. So where should
you implement the

00:46:44.026 --> 00:46:45.166 A:middle
description property.

00:46:46.656 --> 00:46:50.236 A:middle
Remember from earlier how you
can organize your code using

00:46:50.236 --> 00:46:52.866 A:middle
extensions with core
functionality

00:46:53.306 --> 00:46:54.756 A:middle
in type declarations,

00:46:55.146 --> 00:46:57.996 A:middle
and additional functionality
in extensions.

00:46:59.246 --> 00:47:02.706 A:middle
Having a custom string
conversion definitely falls

00:46:59.246 --> 00:47:02.706 A:middle
Having a custom string
conversion definitely falls

00:47:02.706 --> 00:47:04.196 A:middle
into the second category.

00:47:04.506 --> 00:47:08.446 A:middle
It's not core functionality, so
let's put it in an extension.

00:47:09.126 --> 00:47:13.316 A:middle
Here's how you extend a type
to add protocol conformance.

00:47:14.536 --> 00:47:17.486 A:middle
You write colon
CustomStringConvertible

00:47:17.786 --> 00:47:18.746 A:middle
in the first line.

00:47:19.996 --> 00:47:23.156 A:middle
And then you implement the
requirements inside the

00:47:23.156 --> 00:47:24.186 A:middle
extension body.

00:47:26.196 --> 00:47:29.226 A:middle
Now when you call print,
you get the customized

00:47:29.226 --> 00:47:30.266 A:middle
string conversion.

00:47:31.656 --> 00:47:35.576 A:middle
There's a lot that you can
do in Swift using protocols

00:47:35.576 --> 00:47:39.756 A:middle
and extensions to organize your
code and create abstractions.

00:47:40.336 --> 00:47:43.706 A:middle
For more information
check out this talk

00:47:43.956 --> 00:47:47.756 A:middle
on Protocol Oriented
Programming from 2015.

00:47:48.956 --> 00:47:54.376 A:middle
That brings us to the last data
type in Swift -- enumerations.

00:47:55.356 --> 00:47:59.026 A:middle
You use an enumeration when
there's a list of values

00:47:59.026 --> 00:48:00.496 A:middle
that you know ahead of time.

00:47:59.026 --> 00:48:00.496 A:middle
that you know ahead of time.

00:48:01.336 --> 00:48:04.056 A:middle
Here's an enumeration
that supports left

00:48:04.246 --> 00:48:07.436 A:middle
and right alignment for text.

00:48:07.626 --> 00:48:09.126 A:middle
When you use an enumeration,

00:48:09.546 --> 00:48:12.796 A:middle
you use dot notation
to access its cases.

00:48:14.056 --> 00:48:17.726 A:middle
Here there are only two
cases, so it's still readable

00:48:17.936 --> 00:48:19.476 A:middle
if you write them on one line.

00:48:21.336 --> 00:48:24.886 A:middle
Because an enumeration has
a list of possible values,

00:48:25.176 --> 00:48:29.906 A:middle
it's very common to use one
with a switch, one switch case

00:48:30.156 --> 00:48:33.356 A:middle
for each enumeration case.

00:48:33.826 --> 00:48:37.266 A:middle
Writing alignment over and
over is a little repetitive

00:48:37.776 --> 00:48:39.596 A:middle
and here it's not necessary.

00:48:41.076 --> 00:48:43.596 A:middle
The switch is considering
textAlignment,

00:48:44.246 --> 00:48:46.546 A:middle
so the only possible
values to check

00:48:46.666 --> 00:48:50.356 A:middle
for are enumeration cases
from that alignment.

00:48:51.366 --> 00:48:54.416 A:middle
That means you can omit
the enumeration name

00:48:54.906 --> 00:48:56.726 A:middle
and write just .left.

00:48:58.296 --> 00:49:01.776 A:middle
Also, notice that there's
no default case here.

00:48:58.296 --> 00:49:01.776 A:middle
Also, notice that there's
no default case here.

00:49:02.956 --> 00:49:05.336 A:middle
That's for the same
reason you saw earlier.

00:49:06.246 --> 00:49:10.116 A:middle
The switch already covers
every possible alignment value,

00:49:10.706 --> 00:49:13.926 A:middle
so there's nothing left for
a default case to handle.

00:49:15.256 --> 00:49:18.766 A:middle
Omitting the default case
has a nice advantage.

00:49:19.256 --> 00:49:23.306 A:middle
If you come back later and
add a new enumeration case,

00:49:23.776 --> 00:49:28.036 A:middle
but forget to update the switch,
Swift will highlight the error

00:49:28.666 --> 00:49:30.486 A:middle
until you add the missing code.

00:49:32.476 --> 00:49:34.446 A:middle
Now let's take a quick look

00:49:34.786 --> 00:49:38.146 A:middle
at two more things you
can do with enumerations.

00:49:40.796 --> 00:49:44.786 A:middle
You can associate values
with each enumeration case.

00:49:45.716 --> 00:49:51.206 A:middle
For example, the alignment can
specify how much padding to use

00:49:52.616 --> 00:49:55.376 A:middle
and you can get that
padding value back

00:49:55.586 --> 00:50:00.536 A:middle
out as part of the switch case.

00:49:55.586 --> 00:50:00.536 A:middle
out as part of the switch case.

00:50:00.736 --> 00:50:05.796 A:middle
You can also give each
enumeration case a raw value

00:50:06.006 --> 00:50:09.776 A:middle
from some other type, such
as a string or an integer,

00:50:11.376 --> 00:50:14.546 A:middle
which lets you improve
type safety in your code

00:50:15.076 --> 00:50:18.566 A:middle
by using enumerations
instead of string constants.

00:50:21.276 --> 00:50:25.896 A:middle
You've seen a lot of Swift this
afternoon, but there isn't time

00:50:25.896 --> 00:50:27.096 A:middle
to show you everything.

00:50:28.036 --> 00:50:31.546 A:middle
One last thing I'd like to
show you is error handling.

00:50:33.416 --> 00:50:38.996 A:middle
In Swift you can use an
enumeration to describe errors.

00:50:40.556 --> 00:50:43.216 A:middle
You use throws to
mark a function

00:50:43.366 --> 00:50:44.836 A:middle
that can throw an error.

00:50:46.836 --> 00:50:51.676 A:middle
You write defer before a block
of code that must be executed,

00:50:51.906 --> 00:50:53.586 A:middle
whether or not there's an error,

00:50:54.176 --> 00:50:58.466 A:middle
and that execution happens
just before exiting scope,

00:50:58.466 --> 00:51:00.106 A:middle
such as returning
from a function.

00:50:58.466 --> 00:51:00.106 A:middle
such as returning
from a function.

00:51:03.446 --> 00:51:06.496 A:middle
Before calling code that
might throw an error,

00:51:06.836 --> 00:51:11.546 A:middle
you mark it with try,
and you can catch

00:51:11.716 --> 00:51:14.786 A:middle
and throw errors
using catch and throw.

00:51:16.056 --> 00:51:18.586 A:middle
For all the details
about error handling,

00:51:19.196 --> 00:51:21.386 A:middle
take a look at the
Error Handling chapter

00:51:21.786 --> 00:51:23.746 A:middle
in the Swift Programming
Language.

00:51:25.586 --> 00:51:29.396 A:middle
You can find a link to that
book and other resources here.

00:51:31.356 --> 00:51:34.326 A:middle
There are lots of other
great Swift talks to check

00:51:34.326 --> 00:51:36.956 A:middle
out later this week or on video.

00:51:37.736 --> 00:51:37.976 A:middle
Thank you.

00:51:38.516 --> 00:51:46.150 A:middle
[ Applause ]
