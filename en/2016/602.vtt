WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:18.516 A:middle
[ Music ]

00:00:19.516 --> 00:00:25.976 A:middle
[ Applause ]

00:00:26.476 --> 00:00:29.206 A:middle
&gt;&gt; Good afternoon, and welcome
to Adopting Metal, Part I.

00:00:29.796 --> 00:00:33.116 A:middle
I'm Warren Moore from the GPU
Software Team, and I'm joined

00:00:33.116 --> 00:00:34.376 A:middle
by my colleague, Matt Collins,

00:00:34.376 --> 00:00:35.826 A:middle
who will be driving
the demos today.

00:00:36.276 --> 00:00:39.236 A:middle
I want to start off by
asking a deceptively,

00:00:39.236 --> 00:00:41.546 A:middle
simple question: what is Metal?

00:00:42.336 --> 00:00:45.286 A:middle
You've heard us say that Metal
is Apple's low overhead API

00:00:45.286 --> 00:00:48.886 A:middle
for GPUs, that it has a unified
graphics compute language,

00:00:49.336 --> 00:00:51.366 A:middle
and that it's built for
efficient multithreading,

00:00:52.096 --> 00:00:53.736 A:middle
and is designed for
our platforms.

00:00:54.006 --> 00:00:54.926 A:middle
And all of this is true,

00:00:54.926 --> 00:00:58.496 A:middle
but Metal is a lot more
than Metal.framework.

00:00:59.276 --> 00:01:04.936 A:middle
Metal is supported by additional
frameworks and tools and so on.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.276 --> 00:01:04.936 A:middle
Metal is supported by additional
frameworks and tools and so on.

00:01:04.936 --> 00:01:08.406 A:middle
And they make it a lot more than
just the metal framework API.

00:01:09.376 --> 00:01:11.936 A:middle
In particular, last year
we introduced MetalKit,

00:01:12.456 --> 00:01:14.986 A:middle
which includes utilities
for doing common tasks

00:01:14.986 --> 00:01:18.536 A:middle
like interacting UIKit, and
AppKit, and loading textures,

00:01:18.536 --> 00:01:22.436 A:middle
as well as Metal Performance
Shaders, which allow you

00:01:22.436 --> 00:01:25.326 A:middle
to do common tasks such
as imaging processing,

00:01:25.356 --> 00:01:28.776 A:middle
and contain hand-tuned,
highly optimized Shaders

00:01:29.236 --> 00:01:32.366 A:middle
that you can drop right into
your app to do these tasks.

00:01:33.366 --> 00:01:36.236 A:middle
Metal is also tightly integrated
with our developer tools,

00:01:36.236 --> 00:01:37.756 A:middle
Xcode and Instruments.

00:01:39.976 --> 00:01:41.906 A:middle
When you have Shaders
in your app,

00:01:42.446 --> 00:01:44.466 A:middle
they're actually compiled
right along with your app,

00:01:44.586 --> 00:01:48.236 A:middle
including your app bundle to do
Metal's integration with Xcode.

00:01:49.546 --> 00:01:52.356 A:middle
And the GPU Frame Debugger,
allows you to take a snapshot

00:01:52.356 --> 00:01:55.916 A:middle
of your app at any given point,
and see exactly what's going on.

00:01:56.816 --> 00:02:00.096 A:middle
Metal System Trace in
Instruments allows you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:56.816 --> 00:02:00.096 A:middle
Metal System Trace in
Instruments allows you

00:02:00.096 --> 00:02:02.006 A:middle
to get an ongoing view
of the performance

00:02:02.006 --> 00:02:04.746 A:middle
and behavior of your Metal apps.

00:02:05.446 --> 00:02:08.776 A:middle
So two years ago, we introduced
Metal on iOS, and since then,

00:02:08.776 --> 00:02:13.936 A:middle
we've brought Metal
to Mac OS and tvOS.

00:02:13.936 --> 00:02:16.426 A:middle
So it really has broad
support across our platforms.

00:02:17.086 --> 00:02:19.556 A:middle
And it's also widely
supported by our hardware.

00:02:20.056 --> 00:02:24.096 A:middle
It's supported on our desktop
and mobile architectures

00:02:24.096 --> 00:02:27.106 A:middle
from Apple, AMD,
Intel, and NVIDIA,

00:02:27.546 --> 00:02:31.306 A:middle
and this includes all Apple
Macs introduced since 2012,

00:02:31.306 --> 00:02:34.666 A:middle
and all iOS devices since 2013,
as well as the new Apple TV.

00:02:35.166 --> 00:02:37.506 A:middle
So Metal gives your applications
access to the performance

00:02:37.506 --> 00:02:40.386 A:middle
and power of the GPU in
literally hundreds of millions

00:02:40.466 --> 00:02:44.966 A:middle
of our most popular products.

00:02:45.046 --> 00:02:47.716 A:middle
And Metal is also a foundational
technology on these platforms.

00:02:48.316 --> 00:02:53.146 A:middle
It powers Core Graphics, Core
Animation, as well as our Games

00:02:53.146 --> 00:02:55.006 A:middle
and Graphics Libraries
such as SpriteKit,

00:02:55.006 --> 00:02:56.706 A:middle
SceneKit, and Model I/O.

00:02:57.316 --> 00:02:58.676 A:middle
And it's also an
important component

00:02:59.086 --> 00:03:02.426 A:middle
in key system applications
like Preview and Safari.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.086 --> 00:03:02.426 A:middle
in key system applications
like Preview and Safari.

00:03:03.086 --> 00:03:06.666 A:middle
And Metal has been widely
adopted by developers

00:03:06.666 --> 00:03:10.596 A:middle
of all sizes, from AAA
Studios, game engine providers,

00:03:11.016 --> 00:03:13.796 A:middle
independent developers, and
creators of professional tools,

00:03:13.936 --> 00:03:16.176 A:middle
and they've built
amazing games and apps

00:03:16.176 --> 00:03:17.386 A:middle
across all of our platforms.

00:03:18.526 --> 00:03:19.766 A:middle
These are just a few examples,

00:03:19.946 --> 00:03:21.026 A:middle
but I'd like to highlight
a couple.

00:03:22.406 --> 00:03:24.656 A:middle
For instance, Fancy
Guo used Metal

00:03:24.656 --> 00:03:26.076 A:middle
to dramatically improve
performance

00:03:26.306 --> 00:03:27.796 A:middle
and bring amazing visual effects

00:03:27.796 --> 00:03:31.516 A:middle
to their highly popular
MORPG, Furious Wings.

00:03:32.606 --> 00:03:34.336 A:middle
And Metal has also been used

00:03:34.336 --> 00:03:36.836 A:middle
to build inspiring professional
content creation tools,

00:03:36.876 --> 00:03:39.356 A:middle
like the upcoming version
of Affinity Photos for iPad.

00:03:39.356 --> 00:03:44.676 A:middle
And I'd like to show you just a
quick preview of what's coming.

00:03:45.256 --> 00:03:48.566 A:middle
This is Affinity Photos
built by Serif Labs.

00:03:48.776 --> 00:03:51.256 A:middle
And they're building a fully
featured, photo editing app

00:03:51.256 --> 00:03:52.856 A:middle
for the iPad Pro, allowing them

00:03:52.856 --> 00:03:54.506 A:middle
to achieve truly
stunning results.

00:03:58.046 --> 00:04:00.956 A:middle
And this year at WWDC, we
want to give you the tools


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.046 --> 00:04:00.956 A:middle
And this year at WWDC, we
want to give you the tools

00:04:00.956 --> 00:04:02.796 A:middle
to help you start using Metal

00:04:02.796 --> 00:04:05.826 A:middle
to build amazing experiences
in your apps as well.

00:04:06.916 --> 00:04:10.556 A:middle
We have a lot of phenomenal
content this year at WWDC,

00:04:10.876 --> 00:04:12.616 A:middle
five sessions dedicated
to Metal.

00:04:13.256 --> 00:04:16.386 A:middle
Of course, this is the first
session, Adopting Metal, Part I.

00:04:17.125 --> 00:04:19.315 A:middle
And during this session,
we'll talk a little bit

00:04:19.315 --> 00:04:23.326 A:middle
about some foundational
concepts in Metal, go on to talk

00:04:23.326 --> 00:04:26.656 A:middle
about doing 2D drawing and
then actually add lighting,

00:04:26.656 --> 00:04:29.896 A:middle
texturing, and animation
as well as we move into 3D.

00:04:30.366 --> 00:04:33.266 A:middle
In Part II of this session,
happening in this room

00:04:33.266 --> 00:04:36.256 A:middle
after this session, we'll talk
about dynamic data management

00:04:36.256 --> 00:04:38.196 A:middle
and go on and talk about
some of the finer points

00:04:38.666 --> 00:04:40.426 A:middle
of synchronizing
the GPU and CPU,

00:04:40.706 --> 00:04:42.686 A:middle
and really taking your
performance to the next level

00:04:43.246 --> 00:04:44.426 A:middle
with multi-threaded encoding.

00:04:46.926 --> 00:04:49.526 A:middle
Of course, we're also going to
talk about what's new in Metal.

00:04:49.956 --> 00:04:53.076 A:middle
And there's really a
tremendous list of new features

00:04:53.076 --> 00:04:55.366 A:middle
that you probably saw teased
during the Platform State

00:04:55.366 --> 00:04:56.066 A:middle
of Union yesterday.

00:04:57.846 --> 00:04:59.346 A:middle
I won't go through all
of these in detail,

00:04:59.346 --> 00:05:01.126 A:middle
but if you're interested in
implementing any of these


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.346 --> 00:05:01.126 A:middle
but if you're interested in
implementing any of these

00:05:01.126 --> 00:05:02.646 A:middle
in your apps, you
should definitely check

00:05:02.646 --> 00:05:03.736 A:middle
out the What's New sessions.

00:05:05.566 --> 00:05:07.116 A:middle
And finally, we have
an awesome talk

00:05:07.116 --> 00:05:08.716 A:middle
on advanced Shader optimization.

00:05:09.246 --> 00:05:12.366 A:middle
And this is really a hardcore
talk for the people who want

00:05:12.366 --> 00:05:14.836 A:middle
to get the absolute most
out of their Metal Shaders.

00:05:14.836 --> 00:05:17.336 A:middle
We'll talk specifically
about how the hardware works

00:05:17.336 --> 00:05:20.596 A:middle
and how you can use Metal to
really drive it to the max,

00:05:21.186 --> 00:05:22.606 A:middle
and tune your Shader code.

00:05:23.456 --> 00:05:25.426 A:middle
Throughout the course
of these sessions,

00:05:25.426 --> 00:05:26.836 A:middle
we'll build a sample project,

00:05:26.886 --> 00:05:30.106 A:middle
starting with just a simple
Hello Triangle, and Hello world

00:05:30.166 --> 00:05:31.496 A:middle
of graphics programming.

00:05:32.356 --> 00:05:35.406 A:middle
And then as I mentioned, we'll
move to animation and texturing.

00:05:35.776 --> 00:05:39.286 A:middle
And in Part II, we'll take
it to the next level and talk

00:05:39.286 --> 00:05:42.456 A:middle
about updating object data
in real time and also,

00:05:42.756 --> 00:05:44.576 A:middle
performing draw calls
across multiple threads.

00:05:46.026 --> 00:05:47.226 A:middle
Now of course, we have
to make some assumptions

00:05:47.226 --> 00:05:48.056 A:middle
about who you are.

00:05:48.476 --> 00:05:50.846 A:middle
We assume that you're
familiar with the fundamentals

00:05:50.846 --> 00:05:55.746 A:middle
of graphics programming, ideally
with a programmable pipeline.

00:05:56.016 --> 00:05:58.186 A:middle
So you're familiar
with Shaders and so on.

00:05:58.446 --> 00:06:00.106 A:middle
And also of course
that you're interested


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.446 --> 00:06:00.106 A:middle
And also of course
that you're interested

00:06:00.106 --> 00:06:01.946 A:middle
in actually using Metal
to make your games

00:06:01.946 --> 00:06:03.726 A:middle
and apps even more awesome
than they already are.

00:06:04.366 --> 00:06:07.076 A:middle
I assume that everybody here
is on the same page with that.

00:06:07.076 --> 00:06:08.246 A:middle
That's why you're here, right?

00:06:08.746 --> 00:06:11.236 A:middle
So just to go through
the agenda.

00:06:12.126 --> 00:06:13.906 A:middle
We'll kick things off
with a conceptual overview

00:06:13.906 --> 00:06:16.536 A:middle
that will sort of introduce
the philosophy of Metal

00:06:16.536 --> 00:06:17.926 A:middle
and why Metal is
shaped the way it is.

00:06:18.516 --> 00:06:20.216 A:middle
Then we'll actually get right
down to the nitty gritty

00:06:20.216 --> 00:06:21.716 A:middle
and talk about creating
a Metal device.

00:06:22.496 --> 00:06:24.226 A:middle
We'll go on to talk
about loading data

00:06:24.736 --> 00:06:26.386 A:middle
into memory that's
accessible by the GPU.

00:06:26.386 --> 00:06:28.716 A:middle
And we'll talk about the Metal
shading language briefly.

00:06:28.716 --> 00:06:31.986 A:middle
We'll talk about creating
pre-validated pipeline states.

00:06:32.856 --> 00:06:36.156 A:middle
And then talk about issuing GPU
commands, including draw calls.

00:06:36.156 --> 00:06:39.706 A:middle
And then we'll finish up
with a discussion of how

00:06:39.706 --> 00:06:42.976 A:middle
to perform animation
and texturing in Metal.

00:06:43.746 --> 00:06:45.226 A:middle
Part II will take
things even further,

00:06:45.746 --> 00:06:47.186 A:middle
and I've already mentioned
what we'll discuss there.

00:06:47.656 --> 00:06:48.546 A:middle
So let's just forward ahead.

00:06:49.086 --> 00:06:51.006 A:middle
Starting off with the
conceptual overview.

00:06:51.476 --> 00:06:53.506 A:middle
There are a few things that
I want to emphasize here.

00:06:54.856 --> 00:06:57.456 A:middle
Use and API that matches
the hardware and driver.

00:06:58.746 --> 00:07:00.326 A:middle
Favor explicit over implicit.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:58.746 --> 00:07:00.326 A:middle
Favor explicit over implicit.

00:07:01.136 --> 00:07:03.796 A:middle
And do expensive
work less often.

00:07:04.256 --> 00:07:07.146 A:middle
Let's start with using an API
that matches the hardware.

00:07:08.216 --> 00:07:09.936 A:middle
Metal is a thoroughly
modern API.

00:07:10.576 --> 00:07:12.246 A:middle
And by that, I mean
that it integrates with

00:07:12.246 --> 00:07:13.976 A:middle
and exposes the latest
hardware features,

00:07:15.326 --> 00:07:18.336 A:middle
and it matches very closely to
how the hardware actually works.

00:07:18.886 --> 00:07:22.466 A:middle
And being a comparatively
new API, it's very thin

00:07:22.566 --> 00:07:25.736 A:middle
and has no historical cruft that
you get with other legacy APIs.

00:07:25.736 --> 00:07:28.316 A:middle
So there are no fancy
tricks required

00:07:28.316 --> 00:07:29.626 A:middle
for low overhead operation.

00:07:29.946 --> 00:07:33.176 A:middle
It's baked in to how Metal
is shaped and how it operates

00:07:33.176 --> 00:07:34.316 A:middle
at the most fundamental level.

00:07:34.316 --> 00:07:37.186 A:middle
And fortunately,
it's unique by design

00:07:37.706 --> 00:07:39.236 A:middle
across all -- across
our platforms.

00:07:40.586 --> 00:07:42.986 A:middle
When we say that we
want to favor explicit

00:07:42.986 --> 00:07:46.066 A:middle
over implicit operation, we
mean that we put in your hands,

00:07:46.066 --> 00:07:49.946 A:middle
the responsibility to
perform some explicit control

00:07:49.946 --> 00:07:51.806 A:middle
over how commands are
submitted to the GPU,

00:07:52.126 --> 00:07:53.996 A:middle
as well as how you manage
and synchronize your data.

00:07:53.996 --> 00:07:57.276 A:middle
And this puts on you, a
lot of responsibility,

00:07:57.786 --> 00:08:00.466 A:middle
but with great responsibility
comes great performance.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:57.786 --> 00:08:00.466 A:middle
but with great responsibility
comes great performance.

00:08:02.066 --> 00:08:04.356 A:middle
So, just to illustrate
what we mean when we say

00:08:04.356 --> 00:08:08.876 A:middle
"to do expensive work less
often," there are kind

00:08:08.876 --> 00:08:12.626 A:middle
of three regimes of time
that we can think about.

00:08:12.876 --> 00:08:14.026 A:middle
The time that your app is built,

00:08:14.116 --> 00:08:17.396 A:middle
the time that your app is
loading, loading assets

00:08:17.396 --> 00:08:19.696 A:middle
and so on, and then draw time,

00:08:19.696 --> 00:08:21.856 A:middle
the things that happen
60 times per second.

00:08:23.346 --> 00:08:27.376 A:middle
So with a legacy API, like
OpenGL, you pay the cost of work

00:08:27.376 --> 00:08:30.396 A:middle
like state validation every
time you issue a draw call.

00:08:30.396 --> 00:08:31.866 A:middle
You take the hit for
recompiling Shaders

00:08:31.866 --> 00:08:33.236 A:middle
on the fly in the worst case.

00:08:33.836 --> 00:08:36.676 A:middle
And all this adds overhead
on top of the necessary work

00:08:37.626 --> 00:08:41.936 A:middle
of encoding the actual work for
the GPU, like your draw calls.

00:08:42.006 --> 00:08:44.285 A:middle
With Metal, we push some of this
work earlier in the process.

00:08:45.056 --> 00:08:46.696 A:middle
So, as I alluded to earlier,

00:08:47.236 --> 00:08:48.966 A:middle
Shader compilation
can actually happen

00:08:48.966 --> 00:08:50.936 A:middle
at application build
time with Metal.

00:08:52.126 --> 00:08:54.776 A:middle
And additionally, we allow
you to validate the state

00:08:54.776 --> 00:08:57.286 A:middle
that you're going to be using
for your draw calls in advance

00:08:57.956 --> 00:08:59.616 A:middle
at load time, so you don't pay

00:08:59.616 --> 00:09:01.196 A:middle
that cost every time
you issue a draw call.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.616 --> 00:09:01.196 A:middle
that cost every time
you issue a draw call.

00:09:01.776 --> 00:09:04.616 A:middle
Instead, the only work
that remains to be done

00:09:04.616 --> 00:09:07.016 A:middle
when you're issuing your draw
calls, is to do your draw calls.

00:09:10.076 --> 00:09:11.486 A:middle
So with that conceptual
overview,

00:09:11.686 --> 00:09:13.116 A:middle
let's talk about where
the rubber hits the road,

00:09:13.116 --> 00:09:14.896 A:middle
and that's, the Metal device.

00:09:15.896 --> 00:09:17.776 A:middle
So there's a Class MTL device,

00:09:17.776 --> 00:09:21.076 A:middle
and it's an abstract
representation of your GPU.

00:09:21.626 --> 00:09:24.866 A:middle
And it functions as the root
object in your Metal app,

00:09:25.386 --> 00:09:27.486 A:middle
meaning that you'll
use it to create things

00:09:27.486 --> 00:09:30.906 A:middle
like command queues, resources,
pipeline state objects,

00:09:31.076 --> 00:09:32.756 A:middle
and other objects
that you'll be using.

00:09:34.156 --> 00:09:37.646 A:middle
It's very easy to
create a Metal device.

00:09:38.026 --> 00:09:40.836 A:middle
You'll just call
MTLCreateSystemDefaultDevice.

00:09:41.846 --> 00:09:44.246 A:middle
Now devices are persistent
objects, so you'll probably want

00:09:44.246 --> 00:09:46.306 A:middle
to create one at the
beginning of your application

00:09:46.306 --> 00:09:47.746 A:middle
and then hold onto reference

00:09:47.746 --> 00:09:49.696 A:middle
to it throughout your
application life cycle.

00:09:50.336 --> 00:09:52.196 A:middle
It's just that easy.

00:09:54.066 --> 00:09:55.976 A:middle
So now let's talk a little
bit about how to get data

00:09:56.516 --> 00:09:58.266 A:middle
into a place where
the GPU can access it,

00:09:58.486 --> 00:09:59.846 A:middle
so that you can issue
your draw calls.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:01.096 --> 00:10:04.046 A:middle
And in Metal, we'll store
our data in buffers.

00:10:04.476 --> 00:10:08.066 A:middle
So buffers are just allocations
of memory that can store data

00:10:08.066 --> 00:10:08.976 A:middle
in any format that you choose.

00:10:09.106 --> 00:10:15.256 A:middle
These might be vertex data,
index data, constant data.

00:10:15.566 --> 00:10:17.166 A:middle
And you write data
into these buffers

00:10:17.166 --> 00:10:19.846 A:middle
and then access them
later on in your vertex

00:10:19.846 --> 00:10:20.606 A:middle
and fragmentFunctions.

00:10:21.226 --> 00:10:23.606 A:middle
Let's take a look at what
that might look like.

00:10:24.126 --> 00:10:26.116 A:middle
So here is an example
of a couple of buffers

00:10:26.116 --> 00:10:28.696 A:middle
that you might create, as
you're loading your data.

00:10:28.916 --> 00:10:31.556 A:middle
We have a vertexBuffer,
containing some vertices.

00:10:31.666 --> 00:10:34.216 A:middle
And an indexBuffer, containing
some contiguous indices.

00:10:34.826 --> 00:10:38.466 A:middle
To get a little bit more
concrete, each instance

00:10:38.466 --> 00:10:42.056 A:middle
of this vertex type
might be a Swift struct

00:10:42.496 --> 00:10:44.916 A:middle
that contains a position
vector for the vertex,

00:10:44.916 --> 00:10:47.236 A:middle
as well as a color
for the vertex.

00:10:47.886 --> 00:10:49.626 A:middle
You can just lay them out
contiguously in memory.

00:10:49.626 --> 00:10:53.126 A:middle
Now let's talk about how
you actually create buffers.

00:10:53.706 --> 00:10:57.496 A:middle
So the API for this
is on the device

00:10:57.496 --> 00:10:58.296 A:middle
that you've already created.

00:10:58.776 --> 00:11:00.786 A:middle
And you simply call
newBufferWithLength


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:58.776 --> 00:11:00.786 A:middle
And you simply call
newBufferWithLength

00:11:01.086 --> 00:11:02.746 A:middle
to get a buffer of
a particular size

00:11:03.096 --> 00:11:04.996 A:middle
that doesn't have any
data loaded into it.

00:11:05.536 --> 00:11:07.736 A:middle
Or you can call
newBufferWithBytes

00:11:07.906 --> 00:11:10.226 A:middle
and pass a pointer to data
that already lives in memory.

00:11:10.636 --> 00:11:12.346 A:middle
And Metal will then
copy that data

00:11:12.706 --> 00:11:14.296 A:middle
into the newly created
Metal buffer,

00:11:14.526 --> 00:11:15.836 A:middle
and it will be ready
for your use.

00:11:17.366 --> 00:11:19.746 A:middle
You can also memcpy into
the contents pointer

00:11:19.746 --> 00:11:20.766 A:middle
of the buffer if you choose.

00:11:21.346 --> 00:11:26.576 A:middle
So, since we're going to
be showing a 2D triangle

00:11:26.726 --> 00:11:27.986 A:middle
as the first part of our demo,

00:11:28.146 --> 00:11:32.996 A:middle
let's talk about defining the
geometry for this triangle here.

00:11:33.216 --> 00:11:35.236 A:middle
So, since we want to
keep the vertex shader

00:11:35.236 --> 00:11:37.156 A:middle
and fragment shader
as simple as possible,

00:11:37.876 --> 00:11:40.896 A:middle
we'll actually provide these
coordinates in Clip Space.

00:11:41.816 --> 00:11:44.796 A:middle
And Metal's Clip
Space is interesting.

00:11:44.856 --> 00:11:47.596 A:middle
It differs from some APIs and
it's similar to some APIs.

00:11:47.596 --> 00:11:49.346 A:middle
This is like the
DirectX Clip Space.

00:11:49.886 --> 00:11:53.086 A:middle
It runs from negative 1
to 1 in X, negative 1 to 1

00:11:53.086 --> 00:11:55.876 A:middle
in Y, and zero to 1 in Z.

00:11:56.166 --> 00:11:58.046 A:middle
So this is the coordinate space

00:11:58.046 --> 00:11:59.406 A:middle
that we'll specify
our vertices in.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:00.066 --> 00:12:02.496 A:middle
So in code, it looks like this.

00:12:02.876 --> 00:12:04.996 A:middle
We create a Swift
array of vertices,

00:12:05.406 --> 00:12:07.306 A:middle
and then we just
append vertices each

00:12:07.346 --> 00:12:09.206 A:middle
with a position and a color.

00:12:12.556 --> 00:12:15.316 A:middle
Now, we don't strictly
need to use index drawing

00:12:15.506 --> 00:12:19.256 A:middle
to do the simple of a used
case, but we'll go ahead

00:12:19.256 --> 00:12:22.596 A:middle
and create an indexBuffer and
append the indices 0, 1, and 2,

00:12:23.016 --> 00:12:25.246 A:middle
which correspond to of
course, the first, second,

00:12:25.246 --> 00:12:26.526 A:middle
and third vertices
of our triangle.

00:12:26.616 --> 00:12:29.006 A:middle
And then we'll create a couple
of buffers with our device.

00:12:29.656 --> 00:12:32.076 A:middle
So we'll create the vertexBuffer
by calling newBuffer(withBytes,

00:12:32.076 --> 00:12:34.776 A:middle
which loads our vertex data
into this Metal buffer,

00:12:34.776 --> 00:12:36.856 A:middle
and we'll call a
newBuffer(withBytes again

00:12:36.926 --> 00:12:40.356 A:middle
and pass the index data and
get back the indexBuffer.

00:12:40.986 --> 00:12:44.396 A:middle
So, now that we have
our data and memory,

00:12:44.646 --> 00:12:47.146 A:middle
let's talk a little bit about
Metal's unique shading language.

00:12:47.816 --> 00:12:51.956 A:middle
The Metal shading language is
an extended subset of C++ 14,

00:12:52.456 --> 00:12:54.896 A:middle
and it's a unified language
for graphics and compute,

00:12:55.406 --> 00:12:56.906 A:middle
meaning that you can
do a whole lot more

00:12:56.906 --> 00:12:58.236 A:middle
than just 3D graphics with it.

00:12:58.236 --> 00:13:01.046 A:middle
It really just lets you
write programs for the GPU.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.236 --> 00:13:01.046 A:middle
It really just lets you
write programs for the GPU.

00:13:01.726 --> 00:13:05.786 A:middle
So here's a block diagram of
the stages of the pipeline.

00:13:05.786 --> 00:13:08.756 A:middle
And what we're really talking
about now is the vertex

00:13:08.756 --> 00:13:10.186 A:middle
and fragment processing stages.

00:13:10.696 --> 00:13:13.396 A:middle
Each of these has an associated
function that you'll write,

00:13:13.756 --> 00:13:16.986 A:middle
that's used to either process
the vertices or the fragments

00:13:16.986 --> 00:13:18.046 A:middle
that will wind up on screen.

00:13:19.266 --> 00:13:21.236 A:middle
Syntax-wise, it looks
a little bit like this.

00:13:21.416 --> 00:13:25.656 A:middle
And we're not actually going to
go through this in any detail.

00:13:25.836 --> 00:13:26.876 A:middle
I just want to call
your attention

00:13:26.876 --> 00:13:30.246 A:middle
to these function qualifiers:
vertex and fragment.

00:13:30.676 --> 00:13:32.946 A:middle
You'll notice that right out
in front of these functions,

00:13:33.346 --> 00:13:35.856 A:middle
unlike in say a regular
C++ program,

00:13:36.306 --> 00:13:38.416 A:middle
we actually have these
qualifiers that denote

00:13:38.666 --> 00:13:40.906 A:middle
which stage this function
is associated with.

00:13:40.906 --> 00:13:42.726 A:middle
So we have a vertex
function up top,

00:13:42.806 --> 00:13:44.576 A:middle
and a fragmentFunction
down below.

00:13:45.016 --> 00:13:48.456 A:middle
And I'll show you shortly how
to actually associate these

00:13:49.556 --> 00:13:51.856 A:middle
with your pipeline so that
you can use them to draw.

00:13:52.276 --> 00:13:55.046 A:middle
And we'll also look at the
internals of these functions

00:13:55.386 --> 00:13:58.096 A:middle
for our 2D demo and
later on for our 3D demo.

00:13:59.016 --> 00:14:01.166 A:middle
Now, I've mentioned a couple
of times that Metal allows you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.016 --> 00:14:01.166 A:middle
Now, I've mentioned a couple
of times that Metal allows you

00:14:01.166 --> 00:14:03.446 A:middle
to compile your Shaders
directly into your app bundle.

00:14:03.526 --> 00:14:05.306 A:middle
And the way that happens is,

00:14:05.306 --> 00:14:07.986 A:middle
if you have even a
single .Metal file

00:14:07.986 --> 00:14:11.006 A:middle
in your Compile Sources
Phase of your project,

00:14:11.596 --> 00:14:14.296 A:middle
the Metal will automatically
generate what's called a Metal

00:14:14.296 --> 00:14:16.376 A:middle
Lib file, the default.Metallib
file,

00:14:16.786 --> 00:14:17.966 A:middle
and copy it into your bundle

00:14:18.156 --> 00:14:19.686 A:middle
at the time your
application is built

00:14:20.026 --> 00:14:21.356 A:middle
with no further effort
on your part.

00:14:21.356 --> 00:14:24.336 A:middle
So there's the insides
of your app bundle.

00:14:25.896 --> 00:14:27.016 A:middle
There's your default.Metallib.

00:14:27.566 --> 00:14:29.336 A:middle
So just to recap.

00:14:29.426 --> 00:14:32.946 A:middle
You can build Metal
Shaders at runtime.

00:14:33.656 --> 00:14:36.386 A:middle
Again, if you have a .Metal file
in your app, it will be compiled

00:14:36.386 --> 00:14:37.876 A:middle
by Xcode using the
Metal toolchain.

00:14:38.236 --> 00:14:40.236 A:middle
And then produce
default.Metallib which will wind

00:14:40.236 --> 00:14:40.826 A:middle
up in your app bundle.

00:14:42.256 --> 00:14:44.316 A:middle
And the natural question you
have at this point is, "Well,

00:14:44.316 --> 00:14:48.006 A:middle
how do you actually get
these functions at runtime?"

00:14:48.006 --> 00:14:49.896 A:middle
And the answer is that
you'll use a class called

00:14:49.896 --> 00:14:50.776 A:middle
Metal Library.

00:14:51.196 --> 00:14:52.546 A:middle
So Metal Library is a collection

00:14:52.546 --> 00:14:54.576 A:middle
of these compiled
function objects,

00:14:54.576 --> 00:14:55.596 A:middle
produced by the compiler.

00:14:56.066 --> 00:14:57.656 A:middle
And there are multiple
ways to create it.

00:14:57.656 --> 00:14:59.396 A:middle
You can go through the flow
that we just discussed,

00:14:59.896 --> 00:15:02.556 A:middle
which is to build
a default.Metallib


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.896 --> 00:15:02.556 A:middle
which is to build
a default.Metallib

00:15:02.556 --> 00:15:04.636 A:middle
into your app bundle, and
then load it at runtime.

00:15:04.946 --> 00:15:06.316 A:middle
You can also build .metallibs

00:15:06.316 --> 00:15:09.576 A:middle
with a command line
toolchain that we provide.

00:15:10.486 --> 00:15:13.406 A:middle
And you can also build directly
from a source string at runtime

00:15:13.506 --> 00:15:15.176 A:middle
if you're for example,
building Shaders

00:15:15.176 --> 00:15:16.386 A:middle
through string concatenation.

00:15:17.876 --> 00:15:19.416 A:middle
So in code, it looks like this.

00:15:19.416 --> 00:15:22.096 A:middle
In order to load up
the default.Metallib,

00:15:22.096 --> 00:15:24.506 A:middle
you simply call
newDefaultLibrary

00:15:25.056 --> 00:15:26.306 A:middle
on your existing Metal device.

00:15:27.456 --> 00:15:30.326 A:middle
And there's other API for
loading from, for example,

00:15:30.496 --> 00:15:32.866 A:middle
an offline compiled
.Metallib, or from source.

00:15:32.866 --> 00:15:37.586 A:middle
And you can consult
the API docs for that.

00:15:37.796 --> 00:15:40.106 A:middle
So, you have a Metal Library.

00:15:40.316 --> 00:15:41.456 A:middle
What do you get from
Metal Library?

00:15:41.556 --> 00:15:42.596 A:middle
You get a Metal function.

00:15:42.596 --> 00:15:44.696 A:middle
Now a Metal function
is simply an object

00:15:44.696 --> 00:15:46.366 A:middle
that represents a
single function.

00:15:46.986 --> 00:15:49.316 A:middle
And it's associated with a
particular pipeline stage.

00:15:49.316 --> 00:15:50.826 A:middle
Remember that we saw
the diagram earlier,

00:15:51.046 --> 00:15:52.526 A:middle
the vertex or fragment stage.

00:15:52.866 --> 00:15:55.146 A:middle
And we also have an additional
function qualifier called

00:15:55.276 --> 00:16:01.836 A:middle
kernel, that signifies a data
parallel of compute function.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:55.276 --> 00:16:01.836 A:middle
kernel, that signifies a data
parallel of compute function.

00:16:02.006 --> 00:16:04.476 A:middle
So here's that code snippet
again, and you can see

00:16:04.476 --> 00:16:07.766 A:middle
that the function named
here is vertex transform,

00:16:08.116 --> 00:16:11.116 A:middle
and the fragmentFunction
name is fragment lighting.

00:16:11.866 --> 00:16:14.546 A:middle
And I rehash this so that
I can show you the API

00:16:14.546 --> 00:16:16.376 A:middle
for loading these
functions from your library,

00:16:16.886 --> 00:16:17.656 A:middle
which looks like this.

00:16:18.126 --> 00:16:19.566 A:middle
We simply call
NewFunctionWithName

00:16:19.966 --> 00:16:22.246 A:middle
and pass a string that
represents the name

00:16:22.356 --> 00:16:25.756 A:middle
of your function, and get
back a Metal function object,

00:16:25.756 --> 00:16:26.516 A:middle
and then hold onto it.

00:16:27.746 --> 00:16:28.476 A:middle
Now, I'll show you how

00:16:28.476 --> 00:16:30.356 A:middle
to actually use all these
objects in a moment.

00:16:30.526 --> 00:16:32.206 A:middle
But that was just a
brief introduction

00:16:32.206 --> 00:16:33.226 A:middle
to the Metal Shading language.

00:16:35.106 --> 00:16:38.236 A:middle
So let's talk about building
pre-validated pipeline states.

00:16:40.766 --> 00:16:42.486 A:middle
But first, let's
motivate it a little.

00:16:43.076 --> 00:16:45.436 A:middle
So, with an API like OpenGL,

00:16:45.836 --> 00:16:47.996 A:middle
you're often setting
a lot of state.

00:16:48.526 --> 00:16:50.096 A:middle
And then you issue draw calls.

00:16:50.096 --> 00:16:53.346 A:middle
And in between those, the
driver is obligated to validate

00:16:53.346 --> 00:16:57.136 A:middle
that the safety you've set, is
in fact a valid state and again,

00:16:57.136 --> 00:16:59.046 A:middle
in the worst case, you
can even pay the cost

00:16:59.356 --> 00:17:01.266 A:middle
of recompiling Shaders
at runtime.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.356 --> 00:17:01.266 A:middle
of recompiling Shaders
at runtime.

00:17:01.926 --> 00:17:03.316 A:middle
This is what we want to avoid.

00:17:04.715 --> 00:17:07.566 A:middle
So with Metal, it
looks more like this.

00:17:08.356 --> 00:17:10.276 A:middle
You set a pre-validated
pipeline state object,

00:17:10.386 --> 00:17:12.756 A:middle
and maybe set a few other
bits of ancillary state,

00:17:12.756 --> 00:17:14.266 A:middle
and then issue your draw call.

00:17:14.266 --> 00:17:17.146 A:middle
Now what we're trying to do
here is to reduce the overhead

00:17:17.146 --> 00:17:19.556 A:middle
of draw calls by again,
pushing more work earlier

00:17:19.556 --> 00:17:20.386 A:middle
into the process.

00:17:21.506 --> 00:17:24.246 A:middle
So here are a few examples of
state that you'll want to set

00:17:24.246 --> 00:17:25.536 A:middle
on your pipeline state object,

00:17:25.705 --> 00:17:26.856 A:middle
which we'll talk
about in a moment.

00:17:27.306 --> 00:17:29.266 A:middle
First, let's state that you
can set pretty much anytime

00:17:29.266 --> 00:17:29.966 A:middle
when you're drawing.

00:17:30.736 --> 00:17:32.166 A:middle
You'll notice that in
the left hand column,

00:17:32.166 --> 00:17:34.046 A:middle
the state that you'll set
on the pipeline state,

00:17:34.046 --> 00:17:35.756 A:middle
includes the vertex
and fragmentFunction

00:17:35.756 --> 00:17:36.866 A:middle
that will be used to draw.

00:17:36.956 --> 00:17:39.726 A:middle
And it also includes things
like your alpha blending state.

00:17:42.266 --> 00:17:44.416 A:middle
On the right hand side,
instead we see the state

00:17:44.416 --> 00:17:46.766 A:middle
that you can set before
issuing any given draw call,

00:17:46.766 --> 00:17:49.866 A:middle
including the front face
winding and the call mode.

00:17:51.056 --> 00:17:53.256 A:middle
So let's talk about how
you actually create objects

00:17:53.256 --> 00:17:55.546 A:middle
that contain this
pre-validated state.

00:17:56.096 --> 00:17:58.866 A:middle
The chief object is the
Metal RenderPipelineState.

00:17:59.886 --> 00:18:01.856 A:middle
It represents the
sort of configuration


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.886 --> 00:18:01.856 A:middle
It represents the
sort of configuration

00:18:01.896 --> 00:18:04.306 A:middle
of the GPU pipeline, and
it contains a set of --

00:18:04.306 --> 00:18:06.836 A:middle
of validated state that you'll
create during load time.

00:18:08.166 --> 00:18:09.236 A:middle
Like devices,

00:18:09.606 --> 00:18:12.126 A:middle
RenderPipelineStates
are persistent objects

00:18:12.126 --> 00:18:14.326 A:middle
that you'll want to keep
alive throughout the lifetime

00:18:14.326 --> 00:18:17.716 A:middle
of your application,
though if you have a lot

00:18:17.716 --> 00:18:20.116 A:middle
of different functions, you can
create pipeline state objects

00:18:20.116 --> 00:18:21.866 A:middle
asynchronously while
your app is running.

00:18:23.146 --> 00:18:25.176 A:middle
To actually create a
RenderPipelineState,

00:18:25.576 --> 00:18:26.726 A:middle
we don't create one directly.

00:18:26.726 --> 00:18:30.426 A:middle
Instead, we use an object
called a Descriptor that bundles

00:18:30.696 --> 00:18:32.586 A:middle
up all the parameters
that we're going to use

00:18:32.586 --> 00:18:34.016 A:middle
to create this
RenderPipelineState.

00:18:34.596 --> 00:18:37.726 A:middle
Often in Metal, we'll
create Descriptor objects

00:18:37.726 --> 00:18:40.426 A:middle
that really just bring together
all of the different parameters

00:18:40.426 --> 00:18:42.696 A:middle
that we need to create
yet another object.

00:18:42.776 --> 00:18:45.226 A:middle
And so for the
RenderPipelineState object,

00:18:45.226 --> 00:18:46.656 A:middle
that's called a Render
Pipeline Descriptor.

00:18:47.406 --> 00:18:50.396 A:middle
You'll notice that it contains
pointers to the vertex function

00:18:50.396 --> 00:18:52.096 A:middle
and fragmentFunction,
as I mentioned earlier.

00:18:52.376 --> 00:18:55.186 A:middle
And it also contains a
collection of attachments.

00:18:55.666 --> 00:18:59.746 A:middle
And attachments signify the type
of texture that will be rendered

00:18:59.746 --> 00:19:01.346 A:middle
into when we actually
do our drawing.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.746 --> 00:19:01.346 A:middle
into when we actually
do our drawing.

00:19:01.826 --> 00:19:04.356 A:middle
Now in Metal, all rendering
is rendered to texture,

00:19:04.786 --> 00:19:08.066 A:middle
but we don't need pointers to
those textures right up front.

00:19:08.506 --> 00:19:11.416 A:middle
Instead we just need you
to supply the pixel formats

00:19:11.516 --> 00:19:12.906 A:middle
that you'll be rendering into so

00:19:12.906 --> 00:19:14.766 A:middle
that we can optimize the
pipeline state for them.

00:19:15.696 --> 00:19:18.456 A:middle
Additionally, if you're using
a Depth or Stencil Buffer,

00:19:18.456 --> 00:19:21.366 A:middle
then you can also specify the
pixel format of those targets.

00:19:22.316 --> 00:19:24.816 A:middle
So once you've constructed a
render pipeline descriptor,

00:19:25.316 --> 00:19:27.276 A:middle
you can pass it off
to your Metal device

00:19:27.406 --> 00:19:29.606 A:middle
and get back a
MTLRenderPipelineState object.

00:19:30.006 --> 00:19:31.636 A:middle
Let's take a look
at that in code.

00:19:32.766 --> 00:19:35.106 A:middle
Here's a minimal configuration
for a RenderPipelineState.

00:19:35.536 --> 00:19:37.596 A:middle
You'll notice that we're
setting our vertex function

00:19:37.686 --> 00:19:39.836 A:middle
and fragmentFunction
properties to the vertex

00:19:39.836 --> 00:19:41.066 A:middle
and fragmentFunction objects

00:19:41.066 --> 00:19:42.826 A:middle
that we created earlier
from our library.

00:19:42.826 --> 00:19:46.526 A:middle
And we're also configuring
the pixel format

00:19:46.526 --> 00:19:50.446 A:middle
of the primary color attachment
to be .bgra8Unorm, which is one

00:19:50.446 --> 00:19:53.556 A:middle
of our renderable and
displayable pixel formats.

00:19:55.416 --> 00:19:57.396 A:middle
This represents basically
the texture that will --

00:19:57.396 --> 00:19:59.326 A:middle
ultimately be drawn to
when we do our drawing.

00:19:59.836 --> 00:20:02.006 A:middle
And finally, once
we've constructed


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.836 --> 00:20:02.006 A:middle
And finally, once
we've constructed

00:20:02.326 --> 00:20:03.286 A:middle
that pipeline descriptor,

00:20:03.876 --> 00:20:06.556 A:middle
we can use the new
RenderPipelineState function

00:20:06.616 --> 00:20:11.936 A:middle
on the device to actually get
back this pre-validated object.

00:20:12.066 --> 00:20:13.096 A:middle
I want to emphasize once more

00:20:13.096 --> 00:20:14.766 A:middle
that PipelineStates
are persistent objects,

00:20:14.766 --> 00:20:17.046 A:middle
and you should create them
during load time and keep them

00:20:17.046 --> 00:20:18.756 A:middle
around as you do your
device and resources.

00:20:19.356 --> 00:20:20.986 A:middle
You can switch among them
when doing drawing in order

00:20:20.986 --> 00:20:22.096 A:middle
to achieve different effects.

00:20:22.916 --> 00:20:25.896 A:middle
You'll generally have about
one per pair of vertex

00:20:25.896 --> 00:20:26.706 A:middle
and fragmentFunctions.

00:20:28.866 --> 00:20:29.826 A:middle
So now that we've
talked about how

00:20:29.826 --> 00:20:32.936 A:middle
to construct pre-validated
state and how to load some

00:20:32.936 --> 00:20:34.156 A:middle
of your resources into memory,

00:20:34.736 --> 00:20:36.876 A:middle
let's talk about actually
issuing GPU commands,

00:20:36.876 --> 00:20:38.466 A:middle
including draw calls.

00:20:39.646 --> 00:20:41.336 A:middle
We'll go through this
in several stages.

00:20:41.416 --> 00:20:43.876 A:middle
We'll talk about interfacing
with UIKit and AppKit,

00:20:44.486 --> 00:20:47.016 A:middle
talk about -- a bit about the
Metal command submission model,

00:20:47.546 --> 00:20:50.086 A:middle
and then get into render passes
and draw calls, and finally,

00:20:50.086 --> 00:20:51.566 A:middle
how to present your
content on the screen.

00:20:52.366 --> 00:20:55.316 A:middle
So in terms of interacting
with UIKit and AppKit,

00:20:55.516 --> 00:20:59.076 A:middle
we're going to use a utility
for MetalKit called MTKView.

00:20:59.736 --> 00:21:02.806 A:middle
And MTKView is a
cross-platform, view class.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.736 --> 00:21:02.806 A:middle
And MTKView is a
cross-platform, view class.

00:21:02.806 --> 00:21:05.276 A:middle
It inherits from
NSView on Mac OS

00:21:05.866 --> 00:21:08.076 A:middle
and from UIView on iOS and tvOS.

00:21:09.256 --> 00:21:11.466 A:middle
And it reduces the amount of
code that you have to write

00:21:11.466 --> 00:21:12.846 A:middle
in order to get up
and running on Metal.

00:21:13.566 --> 00:21:16.496 A:middle
For example, it creates and
manages a CA Metal Layer

00:21:16.496 --> 00:21:20.216 A:middle
for you, which is a specialized
CALayer subclass that interacts

00:21:20.216 --> 00:21:23.846 A:middle
with the Windows server or
with the display loop in order

00:21:23.846 --> 00:21:25.016 A:middle
to get your content on screen.

00:21:25.556 --> 00:21:29.246 A:middle
It can also, by use of
CV or CA display link,

00:21:29.586 --> 00:21:31.906 A:middle
manage the draw callback
cycle for you

00:21:32.106 --> 00:21:33.626 A:middle
by issuing periodic callbacks

00:21:34.086 --> 00:21:35.456 A:middle
in which you'll actually
do your drawing.

00:21:35.866 --> 00:21:38.516 A:middle
And it also manages the textures
that you'll be rendering into.

00:21:38.876 --> 00:21:41.826 A:middle
I want to emphasize
on particular aspect

00:21:42.266 --> 00:21:45.436 A:middle
of what this does for
you, and that's drawables.

00:21:46.406 --> 00:21:50.936 A:middle
So, inside of the CA Metal Layer
that's managed by your MTKView,

00:21:51.056 --> 00:21:52.906 A:middle
there is a collection
of drawables.

00:21:53.126 --> 00:21:54.916 A:middle
And drawables wrap a texture

00:21:54.916 --> 00:21:56.796 A:middle
that will ultimately
be displayed on screen.

00:21:56.796 --> 00:21:59.616 A:middle
And these are kept in an
internal queue, and then reused

00:21:59.616 --> 00:22:02.156 A:middle
across frames because they're
comparatively expensive


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.616 --> 00:22:02.156 A:middle
across frames because they're
comparatively expensive

00:22:02.606 --> 00:22:05.176 A:middle
and they need to be
managed by the system

00:22:05.176 --> 00:22:07.726 A:middle
because they actually
are very tightly bound

00:22:07.726 --> 00:22:09.866 A:middle
to how things actually get
displayed on the screen.

00:22:09.866 --> 00:22:13.186 A:middle
So we manage them for you and
we hand you the drawable object

00:22:13.186 --> 00:22:15.336 A:middle
that wraps up one of these
textures that you can draw into.

00:22:16.226 --> 00:22:18.346 A:middle
So here's how you can --
there are numerous properties

00:22:18.346 --> 00:22:20.356 A:middle
that you can configure
on an MTKView

00:22:20.476 --> 00:22:22.406 A:middle
to determine how it
manages the textures

00:22:22.406 --> 00:22:24.096 A:middle
that you're going
to be drawing into.

00:22:24.096 --> 00:22:26.966 A:middle
In particular, you can set a
clear color that will determine

00:22:26.966 --> 00:22:29.546 A:middle
which color, the primary
color target is clear to.

00:22:29.546 --> 00:22:32.766 A:middle
You can specify the
color pixel format,

00:22:33.216 --> 00:22:36.186 A:middle
which should match the color
format that you specified

00:22:36.186 --> 00:22:37.456 A:middle
on your pipeline state object,

00:22:37.956 --> 00:22:41.216 A:middle
as well as specifying a depth
and/or stencil pixel format.

00:22:41.216 --> 00:22:44.096 A:middle
And this last property is
probably the most important.

00:22:44.096 --> 00:22:45.386 A:middle
This is where we
set the delegate.

00:22:45.826 --> 00:22:49.796 A:middle
So, MTKView doesn't actually do
any drawing in and of itself.

00:22:49.796 --> 00:22:50.796 A:middle
You can either subclass it,

00:22:51.336 --> 00:22:53.596 A:middle
or you can implement a
delegate that's responsible

00:22:53.596 --> 00:22:54.416 A:middle
for doing the drawing.

00:22:54.416 --> 00:22:56.576 A:middle
And we'll talk through
the later use case.

00:22:56.936 --> 00:22:59.586 A:middle
So let's take a look at
what you have to do in order

00:22:59.586 --> 00:23:02.086 A:middle
to become an MTKView delegate.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.586 --> 00:23:02.086 A:middle
to become an MTKView delegate.

00:23:03.576 --> 00:23:05.796 A:middle
It really boils down to
implementing two methods:

00:23:06.456 --> 00:23:09.426 A:middle
drawable sizeable
change, and draw.

00:23:10.096 --> 00:23:13.206 A:middle
So in drawable sizeable
change, you are responsible

00:23:13.206 --> 00:23:16.906 A:middle
for responding to things
like the window resizing

00:23:16.906 --> 00:23:18.156 A:middle
or the device rotating.

00:23:18.216 --> 00:23:20.726 A:middle
So for example, if your
projection matrix is dependent

00:23:20.726 --> 00:23:23.676 A:middle
on the window size, then
this gives you an opportunity

00:23:23.676 --> 00:23:26.256 A:middle
to respond to that instead
of rebuilding it every frame.

00:23:27.046 --> 00:23:30.506 A:middle
So the draw method will
be called periodically,

00:23:30.736 --> 00:23:33.436 A:middle
in order for you to
actually encode the commands

00:23:33.436 --> 00:23:35.896 A:middle
that you want to have executed,
including your draw calls.

00:23:36.326 --> 00:23:38.286 A:middle
And we're not showing
the complete internals

00:23:38.286 --> 00:23:42.846 A:middle
of that method here, but this is
just a taste of what's to come

00:23:42.846 --> 00:23:44.146 A:middle
when we talk about
command submission.

00:23:44.656 --> 00:23:47.156 A:middle
So you'll create a
commandBuffer, do some things

00:23:47.156 --> 00:23:48.526 A:middle
with it, and then commit it.

00:23:48.886 --> 00:23:51.976 A:middle
We'll talk a lot more about that
in a moment, but this is sort

00:23:51.976 --> 00:23:55.056 A:middle
of your hook for doing the
drawing if you're using MTKView.

00:23:55.916 --> 00:23:57.396 A:middle
And we recommend using MTKView,

00:23:57.396 --> 00:23:59.136 A:middle
especially as you're getting
started, because it takes care

00:23:59.136 --> 00:24:00.016 A:middle
of a lot of things for you.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.136 --> 00:24:00.016 A:middle
of a lot of things for you.

00:24:01.226 --> 00:24:03.296 A:middle
So let's talk about Metal's
command submission model.

00:24:04.396 --> 00:24:05.996 A:middle
This is the picture that
we're going to be building

00:24:05.996 --> 00:24:07.396 A:middle
up over the next several slides.

00:24:08.526 --> 00:24:10.056 A:middle
And it's not important for you

00:24:10.056 --> 00:24:11.676 A:middle
to memorize everything
that's going on here.

00:24:12.116 --> 00:24:14.186 A:middle
We're going to be
building this up.

00:24:14.296 --> 00:24:15.646 A:middle
This is just sort
of an overview.

00:24:15.816 --> 00:24:19.346 A:middle
The objects that we're going to
be constructing as we go along.

00:24:20.736 --> 00:24:24.466 A:middle
So, Metals Command Submission
Model is fairly explicit,

00:24:24.826 --> 00:24:27.016 A:middle
meaning that your
obligated to construct

00:24:27.016 --> 00:24:28.966 A:middle
and submit commandBuffers
yourself.

00:24:29.406 --> 00:24:32.246 A:middle
And you can think of a
commandBuffer as a parcel

00:24:32.246 --> 00:24:34.006 A:middle
of work to be executed
by the GPU,

00:24:34.326 --> 00:24:36.796 A:middle
in contrast to what we're
calling a Metal buffer,

00:24:36.946 --> 00:24:37.756 A:middle
which stores data.

00:24:38.196 --> 00:24:40.436 A:middle
Command buffers store work
to be done by the GPU.

00:24:40.436 --> 00:24:43.026 A:middle
And commandBuffer submission
is under your control,

00:24:43.196 --> 00:24:45.026 A:middle
meaning that when you
have a commandBuffer

00:24:45.026 --> 00:24:48.006 A:middle
that you've constructed, you're
obligated to tell the GPU

00:24:48.006 --> 00:24:49.276 A:middle
when it's ready to be executed.

00:24:49.696 --> 00:24:50.916 A:middle
We'll talk all about
this in a moment.

00:24:51.596 --> 00:24:53.646 A:middle
Additionally, we'll talk
about command encoders

00:24:53.646 --> 00:24:56.376 A:middle
which are objects that are used
to translate from API calls

00:24:56.896 --> 00:24:58.166 A:middle
into work for the GPU.

00:24:58.576 --> 00:24:59.426 A:middle
It's important to realize

00:24:59.466 --> 00:25:01.696 A:middle
that these command encoders
perform no deferred state


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.466 --> 00:25:01.696 A:middle
that these command encoders
perform no deferred state

00:25:01.696 --> 00:25:02.416 A:middle
of validation.

00:25:02.766 --> 00:25:05.376 A:middle
So all of the pre-validated
state that bundled

00:25:05.376 --> 00:25:06.806 A:middle
up in your pipeline,
state objects,

00:25:06.806 --> 00:25:09.206 A:middle
we assume that that's valid

00:25:09.206 --> 00:25:10.876 A:middle
because we validated
it in advance.

00:25:11.266 --> 00:25:13.516 A:middle
And so there's no additional
work to be done by the encoder

00:25:13.516 --> 00:25:14.506 A:middle
or the driver at the point

00:25:14.506 --> 00:25:17.126 A:middle
that you're issuing
commands to be rendered.

00:25:19.736 --> 00:25:22.396 A:middle
Additionally, Metal's Command
Submission Model is inherently

00:25:22.396 --> 00:25:23.616 A:middle
multi-threaded, which allows you

00:25:23.616 --> 00:25:26.336 A:middle
to construct multiple
Command Buffers in parallel,

00:25:26.496 --> 00:25:28.886 A:middle
and have your app decide
the execution order.

00:25:29.296 --> 00:25:32.386 A:middle
This allows you to scale to,
and beyond, tens of thousands

00:25:32.386 --> 00:25:33.526 A:middle
of draw calls per frame.

00:25:34.076 --> 00:25:36.386 A:middle
Adopting Metal Part II will
talk about this in depth,

00:25:36.576 --> 00:25:39.336 A:middle
but I wanted to mention it
now to hint at what's to come.

00:25:39.336 --> 00:25:43.986 A:middle
So let's talk a little bit more
about these objects in depth.

00:25:44.316 --> 00:25:47.106 A:middle
The first thing we'll talk
about is the Command Queue.

00:25:48.086 --> 00:25:50.496 A:middle
And the Command Queue,
which corresponds

00:25:50.496 --> 00:25:53.496 A:middle
to a Metal class called Metal
Command Queue, manages the work

00:25:53.496 --> 00:25:55.546 A:middle
that has been queued up
for the device to execute.

00:25:56.036 --> 00:25:59.376 A:middle
Like the device and
resources and pipeline states,

00:25:59.926 --> 00:26:02.166 A:middle
queues are persistent objects
that you'll want to create


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.926 --> 00:26:02.166 A:middle
queues are persistent objects
that you'll want to create

00:26:02.166 --> 00:26:05.596 A:middle
up front and then keep a handle
on for the lifetime of your app.

00:26:05.596 --> 00:26:07.926 A:middle
You'll often only
need to create one.

00:26:08.616 --> 00:26:11.796 A:middle
And this is how thread safety
is introduced into the Metal API

00:26:12.356 --> 00:26:15.986 A:middle
in the sense that you can create
Command Buffers and render

00:26:15.986 --> 00:26:18.456 A:middle
into -- and use them
on multiple threads.

00:26:18.896 --> 00:26:22.336 A:middle
And the queue allows you
to create and commit them

00:26:22.726 --> 00:26:24.486 A:middle
in a thread safe fashion,
without you having

00:26:24.486 --> 00:26:25.766 A:middle
to do your own locking.

00:26:27.466 --> 00:26:29.306 A:middle
It's really simple to
create a Command Queue.

00:26:29.876 --> 00:26:32.166 A:middle
You simply call a new
Command Queue on your device,

00:26:32.586 --> 00:26:33.996 A:middle
and you'll get back a
Metal Command Queue.

00:26:34.636 --> 00:26:39.096 A:middle
Of course, a queue can't do much
unless you actually put work

00:26:39.096 --> 00:26:44.016 A:middle
into to, so let's
talk about that.

00:26:44.216 --> 00:26:45.476 A:middle
So I've already mentioned
Command Buffers.

00:26:45.476 --> 00:26:48.996 A:middle
And Command Buffers are the
parcels of work to be executed

00:26:48.996 --> 00:26:51.686 A:middle
by the GPU, and in
Metal, they're represented

00:26:51.686 --> 00:26:53.486 A:middle
by a class called
Metal Command Buffer.

00:26:53.486 --> 00:26:56.176 A:middle
So a Metal Command Buffer
contains a set of commands

00:26:56.176 --> 00:26:59.976 A:middle
to be executed by the GPU,
and these are each enqueued

00:26:59.976 --> 00:27:02.106 A:middle
onto a Command Queue for
scheduling by the driver.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.976 --> 00:27:02.106 A:middle
onto a Command Queue for
scheduling by the driver.

00:27:02.876 --> 00:27:04.936 A:middle
These, in contrast to almost
everything we're talked

00:27:04.936 --> 00:27:07.056 A:middle
about thus far, are
transient objects,

00:27:07.116 --> 00:27:09.636 A:middle
meaning that you'll create
one or more of them per frame,

00:27:10.336 --> 00:27:12.476 A:middle
and then encode commands
into them,

00:27:12.596 --> 00:27:15.126 A:middle
and then let them
go off to the GPU.

00:27:15.246 --> 00:27:16.066 A:middle
You won't reuse them.

00:27:16.066 --> 00:27:17.616 A:middle
You won't hold onto
a reference to them.

00:27:18.396 --> 00:27:19.296 A:middle
They're just fire and forget.

00:27:20.846 --> 00:27:23.076 A:middle
To create a Command
Buffer, you simply call

00:27:23.076 --> 00:27:24.666 A:middle
up the Command Buffer
on a Command Queue.

00:27:25.326 --> 00:27:31.456 A:middle
So we've talked a bit
about Buffers, and Queues,

00:27:31.456 --> 00:27:33.186 A:middle
and now let's actually
talk about how we get data

00:27:33.726 --> 00:27:36.156 A:middle
and commands into a
commandBuffer, and that's done

00:27:36.156 --> 00:27:38.626 A:middle
with a special class of
objects called Command Encoders.

00:27:39.166 --> 00:27:40.876 A:middle
And there are several
types of Command Encoders,

00:27:41.066 --> 00:27:43.226 A:middle
including Render,
Blit, and Compute.

00:27:43.226 --> 00:27:45.676 A:middle
And these each allow you
to do different things.

00:27:45.826 --> 00:27:49.016 A:middle
And they all have this common
thread though allowing you

00:27:49.166 --> 00:27:51.646 A:middle
to encode work into
a Command Buffer.

00:27:52.016 --> 00:27:55.706 A:middle
So for example, a Render
Command Encoder will allow you

00:27:55.706 --> 00:27:57.636 A:middle
to set state and
perform draw calls.

00:27:58.016 --> 00:28:00.526 A:middle
A Compute Command Encoder
will allow you to enqueue work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.016 --> 00:28:00.526 A:middle
A Compute Command Encoder
will allow you to enqueue work

00:28:00.906 --> 00:28:04.776 A:middle
for the GPU to execute in a
data parallel fashion that's not

00:28:04.776 --> 00:28:05.306 A:middle
rendering work.

00:28:05.456 --> 00:28:07.956 A:middle
That's your GP, GPU, and
other stuff like that.

00:28:08.776 --> 00:28:11.116 A:middle
And the Blit Command Encoder
allows you to copy data

00:28:11.116 --> 00:28:14.006 A:middle
between buffers and
textures, and vice versa.

00:28:14.006 --> 00:28:17.526 A:middle
We're going to look in detail

00:28:17.526 --> 00:28:19.336 A:middle
at the Render Command
Encoder in this session.

00:28:20.566 --> 00:28:23.326 A:middle
And as I mentioned, it
has the responsibility

00:28:23.326 --> 00:28:24.826 A:middle
of encoding commands.

00:28:24.826 --> 00:28:27.186 A:middle
And each Render Command
Encoder, encodes the work

00:28:27.186 --> 00:28:30.216 A:middle
of a single pass into
a Command Buffer.

00:28:30.686 --> 00:28:32.646 A:middle
So you'll issue some
state changes

00:28:32.646 --> 00:28:37.416 A:middle
and then you'll issue some
draws and it manages a set

00:28:37.466 --> 00:28:40.046 A:middle
of Render target attachments,
that represent the textures

00:28:40.046 --> 00:28:44.216 A:middle
that are going to be drawn into
by this one particular pass.

00:28:44.216 --> 00:28:45.986 A:middle
So schematically,
what we're talking

00:28:45.986 --> 00:28:48.096 A:middle
about here is sort
of the last stage.

00:28:48.096 --> 00:28:50.416 A:middle
You can see we have
these attachments sort

00:28:50.416 --> 00:28:55.176 A:middle
of hanging off the frame buffer
right stage of the pipeline.

00:28:55.886 --> 00:28:59.026 A:middle
And if we were doing multi pass
rendering, then one or more

00:28:59.026 --> 00:29:01.566 A:middle
of the render targets in
this pass might become inputs


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.026 --> 00:29:01.566 A:middle
of the render targets in
this pass might become inputs

00:29:01.566 --> 00:29:02.656 A:middle
for a subsequent pass.

00:29:02.706 --> 00:29:05.836 A:middle
But this is sort of the
single pass, simple use case.

00:29:06.836 --> 00:29:09.876 A:middle
So the again, the attachments
represent the textures

00:29:09.876 --> 00:29:14.076 A:middle
that we're going to be drawing
into at the end of this pass.

00:29:14.676 --> 00:29:17.246 A:middle
So in terms of actually creating
a render command encoder,

00:29:17.306 --> 00:29:19.146 A:middle
we use another type
of descriptor object,

00:29:19.196 --> 00:29:20.556 A:middle
called a RenderPassDescriptor.

00:29:21.096 --> 00:29:23.446 A:middle
So a RenderPassDescriptor
contains a collection

00:29:23.446 --> 00:29:26.586 A:middle
of attachments, each of which
has an associated load store

00:29:26.586 --> 00:29:28.676 A:middle
action, a clear color,
clear value,

00:29:28.676 --> 00:29:31.266 A:middle
and an associated Metal
Texture to be rendered into.

00:29:31.266 --> 00:29:34.536 A:middle
And we'll talk a little bit more
about load and store actions

00:29:34.536 --> 00:29:35.446 A:middle
in a couple of slides.

00:29:35.866 --> 00:29:37.946 A:middle
But the important
thing to realize here,

00:29:38.286 --> 00:29:41.816 A:middle
is that you'll be constructing
a RenderPassDescriptor

00:29:42.236 --> 00:29:45.746 A:middle
at the beginning of your frame,
and actually associating it

00:29:45.746 --> 00:29:47.446 A:middle
with the textures that
are going to be drawn.

00:29:47.816 --> 00:29:51.326 A:middle
So in contrast to the
renderPipelineState object

00:29:51.736 --> 00:29:54.416 A:middle
that only needs to know the
pixel format, this is sort

00:29:54.416 --> 00:29:56.106 A:middle
of where the rubber hits the
road and you actually have

00:29:56.106 --> 00:29:59.376 A:middle
to give us the textures that
we're going to be drawing into.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.996 --> 00:30:03.706 A:middle
So again, a RenderPassDescriptor
contains a collection

00:30:03.706 --> 00:30:06.466 A:middle
of render pass attachments,
each of which might be a color,

00:30:06.466 --> 00:30:07.776 A:middle
depth, or stencil target,

00:30:08.196 --> 00:30:10.006 A:middle
and refers to a texture
to render into.

00:30:10.006 --> 00:30:12.576 A:middle
And it also specifies
these things called load

00:30:12.576 --> 00:30:13.396 A:middle
and store actions.

00:30:13.806 --> 00:30:16.166 A:middle
Let's talk in more depth about
what that actually means.

00:30:17.116 --> 00:30:20.196 A:middle
So, at the beginning of a pass,
you have your color buffer

00:30:20.196 --> 00:30:23.586 A:middle
and your depth buffer and
they contain unknown content.

00:30:24.046 --> 00:30:26.606 A:middle
And in order to actually
do any meaningful work,

00:30:26.726 --> 00:30:28.056 A:middle
we'll need to clear them.

00:30:28.056 --> 00:30:30.896 A:middle
And we do this by setting
their associated load action

00:30:31.336 --> 00:30:32.656 A:middle
on the RenderPassDescriptor.

00:30:33.716 --> 00:30:37.636 A:middle
So we set a load action of clear
on the color and depth targets,

00:30:38.166 --> 00:30:40.826 A:middle
and that clears them to their
corresponding clear color

00:30:40.976 --> 00:30:42.636 A:middle
or clear value, as
the case may be.

00:30:43.396 --> 00:30:44.576 A:middle
Then we'll do some drawing,

00:30:44.956 --> 00:30:46.246 A:middle
which will actually
put the results

00:30:46.246 --> 00:30:48.036 A:middle
of our draw calls
into these textures.

00:30:48.676 --> 00:30:50.996 A:middle
And then the store
action will be performed.

00:30:51.266 --> 00:30:53.826 A:middle
And the store action here is
going to be one of two things.

00:30:54.286 --> 00:30:57.496 A:middle
The store action of
store, signifies the result

00:30:57.496 --> 00:30:59.416 A:middle
of rendering should
actually be written back

00:30:59.416 --> 00:31:00.956 A:middle
to memory and stored.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.416 --> 00:31:00.956 A:middle
to memory and stored.

00:31:00.956 --> 00:31:03.336 A:middle
And in the case of the color
buffer, we're actually going

00:31:03.336 --> 00:31:04.666 A:middle
to present it potentially
on screen.

00:31:04.766 --> 00:31:08.046 A:middle
In the case of the depth buffer,
we're really only using it

00:31:08.046 --> 00:31:11.426 A:middle
when we're actually drawing and
rendering, and so we don't care

00:31:11.676 --> 00:31:15.216 A:middle
about where the results of
that go at the end of the pass.

00:31:15.506 --> 00:31:17.866 A:middle
So we can set a store action
of "Don't Care" in order

00:31:17.866 --> 00:31:18.786 A:middle
to save some bandwidth.

00:31:19.266 --> 00:31:21.076 A:middle
This is an optimization
that you can do

00:31:21.076 --> 00:31:23.516 A:middle
if you don't actually need
to write back the results

00:31:23.516 --> 00:31:25.206 A:middle
of rendering into
the render target.

00:31:25.206 --> 00:31:29.636 A:middle
So to go in a little bit more
depth on load and store actions,

00:31:29.636 --> 00:31:31.386 A:middle
these determine how
texture contents are handled

00:31:31.546 --> 00:31:33.736 A:middle
at the start and
end of your pass.

00:31:33.736 --> 00:31:36.666 A:middle
In addition to the clear
load action that we just saw,

00:31:36.666 --> 00:31:39.436 A:middle
there's also a Load-Load
action that allows you

00:31:39.436 --> 00:31:43.126 A:middle
to load pixel contents
of your textures

00:31:43.506 --> 00:31:44.956 A:middle
with the results
of a previous pass.

00:31:45.186 --> 00:31:46.376 A:middle
There's also "Don't Care."

00:31:46.676 --> 00:31:49.896 A:middle
For example, if you're going to
be rendering across all pixels

00:31:49.896 --> 00:31:53.486 A:middle
of a given target, then you
don't actually care what was

00:31:53.486 --> 00:31:56.596 A:middle
in the texture previously,
nor do you need to clear it

00:31:57.096 --> 00:31:58.686 A:middle
because you know
that you're going

00:31:58.686 --> 00:32:00.956 A:middle
to actually be setting every
single pixel to some value.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.686 --> 00:32:00.956 A:middle
to actually be setting every
single pixel to some value.

00:32:01.326 --> 00:32:02.896 A:middle
So that's another way
that you can optimize,

00:32:02.896 --> 00:32:04.526 A:middle
if you know that in
fact you are going

00:32:04.526 --> 00:32:09.966 A:middle
to be hitting every
single pixel in this pass.

00:32:10.176 --> 00:32:11.176 A:middle
Now, I could walk
you through how

00:32:11.176 --> 00:32:13.526 A:middle
to create a RenderPassDescriptor

00:32:13.846 --> 00:32:16.376 A:middle
and then create a Render Command
Encoder, but fortunately,

00:32:16.696 --> 00:32:18.866 A:middle
MTKView makes this
really easy on you.

00:32:19.406 --> 00:32:21.706 A:middle
You saw earlier that we
configured the MTKView,

00:32:22.086 --> 00:32:23.236 A:middle
with a couple of properties

00:32:23.236 --> 00:32:25.456 A:middle
that by now I hope you become
familiar, like the clear color

00:32:25.846 --> 00:32:27.676 A:middle
and the texture formats
of your render targets.

00:32:28.306 --> 00:32:30.326 A:middle
So you can actually
just ask the view

00:32:30.526 --> 00:32:32.216 A:middle
for its current
RenderPassDescriptor

00:32:32.376 --> 00:32:35.126 A:middle
and you'll get back a
configured RenderPassDescriptor

00:32:35.496 --> 00:32:37.086 A:middle
that you can then go on to use

00:32:37.086 --> 00:32:39.956 A:middle
to create a Render
Command Encoder.

00:32:40.526 --> 00:32:42.856 A:middle
And this is how you do that.

00:32:42.856 --> 00:32:45.676 A:middle
You simply call Render Command
Encoder on your Command Buffer.

00:32:46.146 --> 00:32:47.106 A:middle
Now it's important to note here

00:32:47.106 --> 00:32:49.256 A:middle
that current
RenderPassDescriptor is

00:32:49.326 --> 00:32:50.606 A:middle
potentially a blocking call.

00:32:51.176 --> 00:32:53.616 A:middle
And the reason for that is
that it will actually call

00:32:53.616 --> 00:32:57.156 A:middle
into the CA Metal Layers
next drawable function,

00:32:57.606 --> 00:33:00.486 A:middle
which we won't talk about in
detail now, but which is used


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.606 --> 00:33:00.486 A:middle
which we won't talk about in
detail now, but which is used

00:33:00.486 --> 00:33:02.656 A:middle
to obtain the drawable
that wraps the texture

00:33:02.656 --> 00:33:03.936 A:middle
that can be presented on screen.

00:33:04.446 --> 00:33:06.636 A:middle
And because that is
a finite resource,

00:33:07.176 --> 00:33:09.836 A:middle
if there is not a drawable
currently available,

00:33:09.836 --> 00:33:13.046 A:middle
if all of them are in flight,
then this call will block.

00:33:13.046 --> 00:33:14.986 A:middle
So it' something to be aware of.

00:33:15.636 --> 00:33:18.916 A:middle
So we've talked about
loading resources into memory,

00:33:18.916 --> 00:33:21.116 A:middle
and we've talked about
creating pre-validated state

00:33:21.116 --> 00:33:24.126 A:middle
and we've talked about
now, created Render Passes

00:33:24.366 --> 00:33:25.376 A:middle
and Render Command Encoders.

00:33:25.916 --> 00:33:28.146 A:middle
So how do we actually get
data into our Shaders?

00:33:29.486 --> 00:33:32.226 A:middle
First, we need to talk a little
bit about argument tables.

00:33:33.276 --> 00:33:35.106 A:middle
So argument tables are mappings

00:33:35.106 --> 00:33:38.806 A:middle
from Metal resources
to Shader parameters.

00:33:39.316 --> 00:33:41.836 A:middle
And each type of resource that
you're going to be working with,

00:33:41.836 --> 00:33:43.166 A:middle
such as a buffer or a texture,

00:33:43.486 --> 00:33:45.466 A:middle
has its own separate
buffer argument table.

00:33:45.936 --> 00:33:47.076 A:middle
So you can see here
on the right,

00:33:47.076 --> 00:33:49.476 A:middle
that we have the
buffer argument table

00:33:49.476 --> 00:33:52.716 A:middle
and the texture argument table,
each of which contain a couple

00:33:52.716 --> 00:33:55.706 A:middle
of buffers that are maps
to particular indices

00:33:55.946 --> 00:33:56.836 A:middle
in the argument table.

00:33:57.676 --> 00:33:59.556 A:middle
Now the number of slots
that are available

00:33:59.556 --> 00:34:02.176 A:middle
in any given argument table
are actually dependent upon


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.556 --> 00:34:02.176 A:middle
in any given argument table
are actually dependent upon

00:34:02.176 --> 00:34:02.746 A:middle
the device.

00:34:02.836 --> 00:34:05.446 A:middle
So you should query for them.

00:34:05.566 --> 00:34:07.066 A:middle
Let's make that a
little bit more concrete.

00:34:07.636 --> 00:34:10.335 A:middle
So, on the Render Command
Encoder there's a function

00:34:10.335 --> 00:34:12.766 A:middle
called Set Over Text
Buffer, and you'll notice

00:34:12.766 --> 00:34:14.056 A:middle
that it has three parameters.

00:34:14.376 --> 00:34:17.255 A:middle
It takes a buffer, and
offset, and an index.

00:34:17.556 --> 00:34:19.906 A:middle
So this last parameter is
what we care about the most

00:34:20.045 --> 00:34:23.286 A:middle
because it's our
argument table index.

00:34:23.866 --> 00:34:29.806 A:middle
So this is sort of the host
side of setting resources

00:34:29.806 --> 00:34:31.226 A:middle
that are going to be
used in your Shader.

00:34:31.936 --> 00:34:34.606 A:middle
And there's a corresponding
Shader side

00:34:34.976 --> 00:34:36.025 A:middle
which looks like this.

00:34:36.565 --> 00:34:38.656 A:middle
So this is in the
middle shading language.

00:34:38.886 --> 00:34:41.896 A:middle
Inside your Shader file,
you'll specify that the --

00:34:42.255 --> 00:34:46.525 A:middle
that each given parameter
that corresponds to a resource

00:34:46.525 --> 00:34:50.116 A:middle
that you want to access, has an
attribute that looks like this.

00:34:50.606 --> 00:34:53.016 A:middle
So, this is the first
buffer index.

00:34:53.045 --> 00:34:54.775 A:middle
Buffer Index Zero in
the Argument Table,

00:34:55.295 --> 00:34:58.476 A:middle
corresponds to the buffer
that we just set back

00:34:58.476 --> 00:34:59.536 A:middle
on our Render Command Encoder.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:01.866 --> 00:35:04.616 A:middle
And we'll look at a little
bit more about this in detail

00:35:04.616 --> 00:35:06.536 A:middle
when we actually talk
about doing drawing in 2D.

00:35:10.866 --> 00:35:12.276 A:middle
We've already created
a renderPipelineState,

00:35:12.276 --> 00:35:14.806 A:middle
but we actually need to tell
our Render Command Encoder

00:35:15.026 --> 00:35:17.576 A:middle
which pipeline state to use
before doing any drawing.

00:35:17.926 --> 00:35:19.036 A:middle
So this is API for that.

00:35:19.036 --> 00:35:21.356 A:middle
We simple call
setRenderPipelineState

00:35:21.356 --> 00:35:23.636 A:middle
with the previously created
PipelineState object,

00:35:24.076 --> 00:35:27.266 A:middle
and that configures the pipeline
with the Shaders that we've --

00:35:27.266 --> 00:35:30.016 A:middle
that we created earlier that
we're going to be using to draw.

00:35:30.886 --> 00:35:32.746 A:middle
Now of course, the
RenderPipelineState,

00:35:32.746 --> 00:35:36.186 A:middle
has associated -- an associated
vertex and fragments function.

00:35:36.556 --> 00:35:38.656 A:middle
So let's take a look at the
vertex and fragmentFunction

00:35:38.656 --> 00:35:40.936 A:middle
that we're actually going
to be using to draw in 2D.

00:35:41.816 --> 00:35:44.166 A:middle
Back in Metal Shading
language, it looks like this.

00:35:44.796 --> 00:35:48.556 A:middle
So, this is basically a
pass through vertex function

00:35:48.556 --> 00:35:49.376 A:middle
which means that we're not going

00:35:49.376 --> 00:35:50.876 A:middle
to be doing any fancy
math in here.

00:35:50.876 --> 00:35:53.216 A:middle
It's really just going to
copy all these attributes,

00:35:53.216 --> 00:35:53.966 A:middle
straight on through.

00:35:54.666 --> 00:35:59.876 A:middle
So, the first parameter to this
function is a list of vertices


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:00.066 --> 00:36:02.176 A:middle
which is the buffer
that we just bound.

00:36:02.756 --> 00:36:05.346 A:middle
And the second parameter is
this thing that's attributed

00:36:05.346 --> 00:36:08.456 A:middle
with the vertex ID attribute,
which is something that's going

00:36:08.456 --> 00:36:11.696 A:middle
to be populated by Metal
with the index of the vertex

00:36:11.696 --> 00:36:13.086 A:middle
that we're currently
operating on.

00:36:13.476 --> 00:36:14.816 A:middle
And the reason that's
important is

00:36:14.816 --> 00:36:17.736 A:middle
because the vertexBuffer
contains all the vertices,

00:36:17.736 --> 00:36:18.986 A:middle
and we can access it at random.

00:36:18.986 --> 00:36:21.056 A:middle
But what we actually want to do

00:36:21.056 --> 00:36:22.946 A:middle
in our vertex function
is operate

00:36:22.946 --> 00:36:24.726 A:middle
on one particular
vertex at a time.

00:36:25.136 --> 00:36:27.056 A:middle
So this tells us which
vertex we're operating on.

00:36:27.706 --> 00:36:30.686 A:middle
So, we create an instance
of this struct VertexOut,

00:36:30.916 --> 00:36:34.286 A:middle
which represents all the
varying properties of the vertex

00:36:34.896 --> 00:36:36.676 A:middle
that we want to pass
through to the rasterizer.

00:36:37.216 --> 00:36:39.886 A:middle
So we create an instance of
this and set its position

00:36:40.166 --> 00:36:44.366 A:middle
to the position vector of the
vertex indexed at vertexId.

00:36:44.746 --> 00:36:45.976 A:middle
And similarly for the color.

00:36:46.026 --> 00:36:48.906 A:middle
And this just passes that data
on through from the vertexBuffer

00:36:49.336 --> 00:36:52.106 A:middle
to the struct that will be
interpolated by the rasterizer.

00:36:52.716 --> 00:36:56.246 A:middle
And then we return that
structure back on out.

00:36:57.196 --> 00:36:58.756 A:middle
Now let's look at
the fragmentFunction.

00:36:59.406 --> 00:37:00.576 A:middle
It's even simpler.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.406 --> 00:37:00.576 A:middle
It's even simpler.

00:37:01.196 --> 00:37:05.836 A:middle
So we take in the interpolated
struct, using the stage

00:37:05.836 --> 00:37:07.786 A:middle
in attribute, and that signifies

00:37:07.826 --> 00:37:10.346 A:middle
that this is the data that's
coming in from the rasterizer.

00:37:10.346 --> 00:37:12.476 A:middle
And we just extract
that color --

00:37:12.796 --> 00:37:15.696 A:middle
the color from the
incoming structure,

00:37:16.046 --> 00:37:17.296 A:middle
and then pass it back on out.

00:37:17.716 --> 00:37:20.086 A:middle
And so, what's happened in
this process is the vertices,

00:37:20.086 --> 00:37:23.286 A:middle
which were already specified
in Clip Space in this example,

00:37:23.806 --> 00:37:27.576 A:middle
are being interpolated and
then rasterized and then

00:37:27.576 --> 00:37:29.016 A:middle
for each fragment
that we're processing,

00:37:29.466 --> 00:37:31.066 A:middle
we simple return the
interpolated color

00:37:31.066 --> 00:37:32.766 A:middle
that was created for
us by the rasterizer.

00:37:34.796 --> 00:37:37.666 A:middle
So once we've specified
the RenderPipelineState

00:37:37.796 --> 00:37:39.596 A:middle
which contains our vertex
and fragmentFunction,

00:37:39.896 --> 00:37:42.036 A:middle
we can also set additional
state, kind of like the stuff

00:37:42.036 --> 00:37:42.806 A:middle
that I mentioned earlier,

00:37:43.156 --> 00:37:45.846 A:middle
including the front
facing state.

00:37:46.176 --> 00:37:49.266 A:middle
So if you want to specify a
different front facing winding

00:37:49.266 --> 00:37:52.016 A:middle
order, than Metal's
default of clockwise,

00:37:52.326 --> 00:37:53.256 A:middle
then you can do that here.

00:37:53.866 --> 00:37:56.966 A:middle
It's a lot of configuration,
but we're actually

00:37:56.966 --> 00:38:00.166 A:middle
about to see some draw
calls happen, right now.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:56.966 --> 00:38:00.166 A:middle
about to see some draw
calls happen, right now.

00:38:00.876 --> 00:38:02.196 A:middle
So Metal has numerous functions

00:38:02.196 --> 00:38:05.166 A:middle
for drawing geometry including
indexed, instance, and indirect,

00:38:05.366 --> 00:38:07.286 A:middle
but we'll just look at
basic index drawing.

00:38:07.786 --> 00:38:10.226 A:middle
Let's say that we want to draw
that triangle, at long last.

00:38:10.896 --> 00:38:13.236 A:middle
So, here we call
drawIndexedPrimitives,

00:38:13.896 --> 00:38:16.656 A:middle
and we specify that the
prototype is triangle

00:38:16.986 --> 00:38:19.076 A:middle
because we want to
draw a triangle.

00:38:19.076 --> 00:38:21.266 A:middle
We pass an index count of
three to signify that we want

00:38:21.266 --> 00:38:22.476 A:middle
to draw a single triangle,

00:38:22.666 --> 00:38:25.186 A:middle
and then we also specify
the type of indices.

00:38:27.086 --> 00:38:31.116 A:middle
We made our Swift array a
collection of UN 16s earlier,

00:38:31.116 --> 00:38:32.506 A:middle
so we mirror that here.

00:38:32.506 --> 00:38:34.246 A:middle
And we also pass
in the indexBuffer

00:38:34.246 --> 00:38:36.046 A:middle
that we created earlier
that signifies

00:38:36.636 --> 00:38:38.046 A:middle
which vertices should be drawn,

00:38:38.386 --> 00:38:40.226 A:middle
and then we pass in
an offset of zero.

00:38:40.706 --> 00:38:42.576 A:middle
And this is actually
going to result

00:38:42.786 --> 00:38:45.056 A:middle
in a single triangle
being drawn to the screen.

00:38:45.636 --> 00:38:48.766 A:middle
We might also additionally
set some more state

00:38:48.766 --> 00:38:50.806 A:middle
and issue other draw
calls, but for the purposes

00:38:50.806 --> 00:38:53.056 A:middle
of this first demo, this
is all there is to it.

00:38:53.746 --> 00:38:55.406 A:middle
So in order to conclude
a render pass,

00:38:55.946 --> 00:38:59.326 A:middle
we simple call it endEncoding
on the Render Command Encoder.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:00.706 --> 00:39:04.136 A:middle
To recap all of that, you
will create a request,

00:39:04.196 --> 00:39:06.696 A:middle
a RenderPassDescriptor, at
the beginning of your frame.

00:39:07.626 --> 00:39:09.896 A:middle
Then you'll create a
Render Command Encoder

00:39:10.066 --> 00:39:10.906 A:middle
with that Descriptor.

00:39:11.886 --> 00:39:13.266 A:middle
Set the RenderPipelineState.

00:39:13.266 --> 00:39:15.576 A:middle
Set any other necessary state.

00:39:15.976 --> 00:39:18.546 A:middle
Issue draw calls, and
finally end encoding.

00:39:18.886 --> 00:39:21.396 A:middle
So here's a recap of all the
code that we've seen thus far.

00:39:22.376 --> 00:39:23.056 A:middle
Nothing new here.

00:39:23.456 --> 00:39:26.106 A:middle
Exactly what we've seen and
exactly what I just said.

00:39:26.246 --> 00:39:32.106 A:middle
Create a Render Command
Encoder, set state, set state,

00:39:32.816 --> 00:39:34.576 A:middle
bind some buffers, and draw.

00:39:35.866 --> 00:39:37.966 A:middle
So you've rendered all
this great content,

00:39:38.556 --> 00:39:39.836 A:middle
but how do you actually
get it on the screen?

00:39:40.226 --> 00:39:41.306 A:middle
It's pretty straightforward.

00:39:42.056 --> 00:39:44.576 A:middle
So, first color attachment

00:39:44.666 --> 00:39:47.146 A:middle
of your render pass is
usually a drawables texture

00:39:47.386 --> 00:39:48.296 A:middle
that you've either gotten

00:39:48.296 --> 00:39:50.836 A:middle
from a CA Metal Layer
or from and MKTView.

00:39:51.656 --> 00:39:54.146 A:middle
So in order to request that that
texture actually get presented

00:39:54.146 --> 00:39:57.266 A:middle
on screen, you can
actually just call present

00:39:57.266 --> 00:39:59.306 A:middle
on the commandBuffer, and
pass in that drawable,

00:39:59.716 --> 00:40:01.606 A:middle
and that will be displayed


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.716 --> 00:40:01.606 A:middle
and that will be displayed

00:40:01.606 --> 00:40:04.636 A:middle
to the screen once all the
preceding passes are complete.

00:40:05.856 --> 00:40:08.546 A:middle
Then to finally actually
finish up the frame,

00:40:08.846 --> 00:40:10.576 A:middle
since we've been encoding
into this commandBuffer,

00:40:10.996 --> 00:40:12.076 A:middle
we need to signify
that we're done

00:40:12.076 --> 00:40:13.636 A:middle
with the commandBuffer
by calling commit.

00:40:14.566 --> 00:40:16.536 A:middle
Committing tells the driver
that the commandBuffer's ready

00:40:16.536 --> 00:40:19.706 A:middle
to be executed by the GPU.

00:40:19.916 --> 00:40:24.396 A:middle
So to recap that, we created
a command queue at start-up,

00:40:24.686 --> 00:40:26.486 A:middle
and since it's a
persistent object,

00:40:26.486 --> 00:40:28.586 A:middle
we hold onto reference to it.

00:40:28.586 --> 00:40:31.406 A:middle
Each frame we create a
commandBuffer, encode one

00:40:31.406 --> 00:40:33.896 A:middle
or more rendering passes into it
with a render command encoder.

00:40:33.896 --> 00:40:36.206 A:middle
Present the drawable
to the screen

00:40:36.206 --> 00:40:37.436 A:middle
and then commit the
commandBuffer.

00:40:39.256 --> 00:40:41.286 A:middle
And now I'm going to hand
things off to my colleague Matt,

00:40:41.676 --> 00:40:43.596 A:middle
to walk us through the
demo of drawing in 2D.

00:40:44.036 --> 00:40:44.506 A:middle
&gt;&gt; Thanks Warren.

00:40:47.516 --> 00:40:52.776 A:middle
[ Applause ]

00:40:53.276 --> 00:40:54.176 A:middle
&gt;&gt; So here's the proof.

00:40:54.176 --> 00:40:57.466 A:middle
A 2D triangle, this is the Metal
triangle demo as you can tell

00:40:57.466 --> 00:41:00.366 A:middle
by our awesome title,
is very simple.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:57.466 --> 00:41:00.366 A:middle
by our awesome title,
is very simple.

00:41:00.406 --> 00:41:01.626 A:middle
Just a triangle, three colors

00:41:01.626 --> 00:41:03.916 A:middle
on the ends interpolated
nicely over the edges.

00:41:05.316 --> 00:41:06.186 A:middle
Let's take a look at the code.

00:41:08.016 --> 00:41:09.566 A:middle
Now first I want to
show you what it takes

00:41:09.566 --> 00:41:11.176 A:middle
to become a delegate of MTKView,

00:41:11.646 --> 00:41:13.496 A:middle
and Warren mentioned we have
two functions to implement.

00:41:13.846 --> 00:41:16.986 A:middle
So here we have MTKView,
drawable, sizeable change.

00:41:17.436 --> 00:41:19.146 A:middle
And this is what is called
when you need to respond

00:41:19.176 --> 00:41:21.176 A:middle
to changes in your window.

00:41:22.156 --> 00:41:24.386 A:middle
This sample is very simple so
we didn't actually implement it.

00:41:24.386 --> 00:41:26.876 A:middle
We'll leave that up to you
guys for your own applications.

00:41:28.116 --> 00:41:29.786 A:middle
And the other thing
is simple the draw.

00:41:31.446 --> 00:41:33.086 A:middle
We chose to put this
into a render function.

00:41:33.626 --> 00:41:36.856 A:middle
So, when our draw gets
called, we go into our render.

00:41:39.426 --> 00:41:40.436 A:middle
Render's also quite simple.

00:41:40.696 --> 00:41:41.456 A:middle
I just wanted to show you.

00:41:41.456 --> 00:41:45.716 A:middle
When we take MTKView's
current RenderPassDescriptor,

00:41:46.806 --> 00:41:48.106 A:middle
you just grab it out
like Warren said,

00:41:48.106 --> 00:41:50.436 A:middle
and then you create the
RenderPassDescriptor

00:41:50.556 --> 00:41:51.396 A:middle
and your encoder with it.

00:41:51.936 --> 00:41:53.146 A:middle
And I'd like to draw
your attention here,

00:41:53.606 --> 00:41:54.416 A:middle
"push debug group."

00:41:54.416 --> 00:41:57.136 A:middle
And this is how you talk
to the awesome Metal tools.

00:41:57.496 --> 00:42:00.356 A:middle
So when you do a frame
capture, this will then sort all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:57.496 --> 00:42:00.356 A:middle
So when you do a frame
capture, this will then sort all

00:42:00.356 --> 00:42:02.626 A:middle
of your draws by whatever
debug group you've had.

00:42:02.726 --> 00:42:04.896 A:middle
So here, we have one
draw and a draw triangle

00:42:05.706 --> 00:42:08.696 A:middle
and then we pop the debug
group after we've drawn,

00:42:08.976 --> 00:42:11.206 A:middle
and so this draw will show up
labeled as "Draw Triangle."

00:42:13.396 --> 00:42:14.706 A:middle
Let's take a look at the Shader.

00:42:17.316 --> 00:42:19.006 A:middle
Now Warren mentioned,
we had structs.

00:42:19.006 --> 00:42:21.206 A:middle
We have a vertex end
struct, which is the format

00:42:21.206 --> 00:42:23.206 A:middle
of the data we're putting
into the Shader, as you see.

00:42:23.206 --> 00:42:24.516 A:middle
That's just a position
and a color.

00:42:25.486 --> 00:42:26.796 A:middle
And we have the vertex
out struct,

00:42:27.286 --> 00:42:28.976 A:middle
which is what we're passing
down to the rasterizer.

00:42:28.976 --> 00:42:31.226 A:middle
And you see here the
position has been tagged

00:42:31.266 --> 00:42:32.436 A:middle
with this position attribute.

00:42:32.986 --> 00:42:34.676 A:middle
And this represents the
Clip Space position.

00:42:34.826 --> 00:42:37.596 A:middle
And every vertex Shader that you
have or vertex function, sorry,

00:42:37.956 --> 00:42:38.846 A:middle
must have one of these.

00:42:40.426 --> 00:42:41.566 A:middle
And as you saw, these
should look kind

00:42:41.566 --> 00:42:42.906 A:middle
of familiar, they're
very simple.

00:42:43.536 --> 00:42:44.336 A:middle
Vertices come in.

00:42:44.336 --> 00:42:45.686 A:middle
We have a pass through.

00:42:45.686 --> 00:42:46.996 A:middle
And you write them out.

00:42:47.636 --> 00:42:51.326 A:middle
And in the fragmentFunction, we
take in the vertices that came

00:42:51.326 --> 00:42:52.136 A:middle
out of the rasterizer

00:42:52.206 --> 00:42:54.476 A:middle
and we read the color,
and send that down.

00:42:55.476 --> 00:42:56.556 A:middle
So that's the simple
triangle demo.

00:42:56.556 --> 00:42:58.066 A:middle
I'll send it back
to your Warren.

00:42:58.516 --> 00:43:02.436 A:middle
&gt;&gt; Thanks Matt.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:58.516 --> 00:43:02.436 A:middle
&gt;&gt; Thanks Matt.

00:43:03.916 --> 00:43:06.506 A:middle
So, we've shown how to
actually draw 2D content.

00:43:07.486 --> 00:43:10.096 A:middle
And 2D is cool, but you
know what's even cooler?

00:43:10.656 --> 00:43:14.056 A:middle
Three-D. So let's talk a
little bit about animation

00:43:14.056 --> 00:43:15.066 A:middle
and texturing in Metal.

00:43:18.486 --> 00:43:19.596 A:middle
In order to actually
get into 3D --

00:43:20.966 --> 00:43:23.016 A:middle
alright well, we'll go through
this in a couple stages.

00:43:23.016 --> 00:43:24.406 A:middle
We'll talk about how to
actually get into 3D.

00:43:24.406 --> 00:43:26.836 A:middle
And we'll talk about animating
with a constant buffer,

00:43:26.836 --> 00:43:29.636 A:middle
and then we'll talk a little
bit about texturing a sampling.

00:43:30.596 --> 00:43:31.826 A:middle
In order to move into 3D,

00:43:32.596 --> 00:43:35.026 A:middle
whereas we've been specifying
our vertices in Clip Space,

00:43:35.026 --> 00:43:37.736 A:middle
we now need to specify them
in a model local space.

00:43:38.326 --> 00:43:39.666 A:middle
And then multiply them

00:43:39.666 --> 00:43:42.916 A:middle
by a suitable model
view projection matrix,

00:43:43.346 --> 00:43:45.156 A:middle
in order to move them
back into Clip Space.

00:43:45.936 --> 00:43:49.686 A:middle
And we'll also add properties
for a vertex normal as well

00:43:49.686 --> 00:43:51.796 A:middle
as texture coordinates so
that we can actually use those

00:43:51.796 --> 00:43:54.616 A:middle
in our fragmentFunction,
to determine lighting

00:43:54.856 --> 00:43:56.666 A:middle
and to determine how to
apply the texture map.

00:43:58.246 --> 00:44:00.636 A:middle
So, here's our extended vertex.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.246 --> 00:44:00.636 A:middle
So, here's our extended vertex.

00:44:01.106 --> 00:44:03.636 A:middle
We have removed the color
attribute and we've added

00:44:03.636 --> 00:44:07.006 A:middle
in a normal vector as well as
a set of texture coordinates.

00:44:08.206 --> 00:44:12.696 A:middle
And similarly to how we had
in 2D, we'll just be adding

00:44:12.696 --> 00:44:16.846 A:middle
on a new buffer that will store
all the constants that we need

00:44:17.336 --> 00:44:21.466 A:middle
to reference from our various
vertex and fragmentFunctions

00:44:21.466 --> 00:44:25.226 A:middle
in order to actually transform
those vertices appropriately.

00:44:25.226 --> 00:44:27.236 A:middle
Now, you'll notice
that the outline

00:44:27.236 --> 00:44:31.006 A:middle
of this buffer is dashed, and
there's a good reason for that.

00:44:31.596 --> 00:44:35.256 A:middle
Because I don't want to create
another Metal buffer in order

00:44:35.256 --> 00:44:37.346 A:middle
to manage this tiny
amount of data.

00:44:37.346 --> 00:44:38.656 A:middle
This is only a couple
of matrices.

00:44:39.036 --> 00:44:41.396 A:middle
And it turns out that Metal
actually has an awesome API

00:44:42.036 --> 00:44:45.446 A:middle
for binding very small buffers
and managing them for you.

00:44:47.516 --> 00:44:49.536 A:middle
So again, for small
bits of data,

00:44:49.656 --> 00:44:53.356 A:middle
less than about 4 kilobytes,
you can use this API set

00:44:53.356 --> 00:44:57.406 A:middle
of vertex bytes and pass it --
a pointer directly to your data.

00:44:57.836 --> 00:44:59.396 A:middle
And of course, tell
us what size it is.

00:44:59.996 --> 00:45:04.216 A:middle
And Metal will create
and or reuse a buffer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.996 --> 00:45:04.216 A:middle
And Metal will create
and or reuse a buffer

00:45:04.386 --> 00:45:05.456 A:middle
that contains that data.

00:45:06.206 --> 00:45:10.046 A:middle
And again, you can actually
specify the argument table index

00:45:10.046 --> 00:45:12.086 A:middle
here, specifying it as 1,

00:45:12.086 --> 00:45:14.776 A:middle
because our vertices are
already bound at Index 0,

00:45:15.376 --> 00:45:18.266 A:middle
so we bind at Index 1 so that
we can then read from that,

00:45:18.266 --> 00:45:20.076 A:middle
inside of our functions.

00:45:20.866 --> 00:45:22.866 A:middle
So let's take a look at how
our functions actually change

00:45:22.866 --> 00:45:23.716 A:middle
and respond to this.

00:45:25.156 --> 00:45:26.696 A:middle
Before that, we'll
see an example of how

00:45:26.696 --> 00:45:30.396 A:middle
to actually call setForTextBytes
inside your application code.

00:45:30.776 --> 00:45:32.906 A:middle
So, we'll create
this constant struct

00:45:32.986 --> 00:45:34.066 A:middle
that again creates these --

00:45:34.116 --> 00:45:37.276 A:middle
contains these two matrices that
we're going to be multiplying

00:45:37.316 --> 00:45:40.696 A:middle
by the Model View Projection
Matrix, and the normal matrix,

00:45:40.696 --> 00:45:42.466 A:middle
which is the matrix that
transforms the normal

00:45:42.466 --> 00:45:45.086 A:middle
from local space into iSpace.

00:45:45.646 --> 00:45:47.856 A:middle
We'll construct them using
whatever matrix utilities we're

00:45:47.856 --> 00:45:50.276 A:middle
comfortable with, and then
multiply them together.

00:45:50.586 --> 00:45:53.996 A:middle
And finally use setVertexBytes,
passing a reference

00:45:54.046 --> 00:45:57.316 A:middle
to that structure and then
Metal will copy that into again,

00:45:57.316 --> 00:46:00.206 A:middle
this implicit buffer that's
going to be used for drawing


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:57.316 --> 00:46:00.206 A:middle
this implicit buffer that's
going to be used for drawing

00:46:00.326 --> 00:46:03.386 A:middle
in our subsequent draw call.

00:46:03.946 --> 00:46:07.846 A:middle
Now, last year at
WWDC, we introduced

00:46:07.846 --> 00:46:09.806 A:middle
and awesome framework
called Model I/O,

00:46:10.366 --> 00:46:13.586 A:middle
and Model I/O contains a
lot of awesome utilities.

00:46:14.096 --> 00:46:16.326 A:middle
But one of the great
things about Model I/O is

00:46:16.326 --> 00:46:19.966 A:middle
that it also allows you
to generate common shapes.

00:46:20.706 --> 00:46:22.466 A:middle
And because of MetalKit,

00:46:22.606 --> 00:46:25.406 A:middle
it actually has very tight
integration with Metal

00:46:25.406 --> 00:46:27.866 A:middle
so that you can create
vertex data

00:46:27.866 --> 00:46:29.996 A:middle
that can be rendered
directly by Metal.

00:46:31.086 --> 00:46:33.756 A:middle
So, instead of actually
specifying all these vertices

00:46:33.756 --> 00:46:37.366 A:middle
by hand, I can for example,
draw my model in some sort

00:46:37.416 --> 00:46:40.046 A:middle
of content creation
package, export it,

00:46:40.226 --> 00:46:41.236 A:middle
and load it with Model I/O.

00:46:41.526 --> 00:46:43.736 A:middle
Or in this case,
generate it procedurally.

00:46:44.016 --> 00:46:46.666 A:middle
So let's take a look
at that in code.

00:46:46.846 --> 00:46:48.236 A:middle
So I want to generate
some vertexBuffers

00:46:48.236 --> 00:46:49.856 A:middle
that represent this cube.

00:46:50.606 --> 00:46:53.546 A:middle
Well, in order to actually get
Model I/O to speak in Metal,

00:46:54.006 --> 00:46:56.446 A:middle
I'll create this thing
called a MeshBufferAllocator.

00:46:57.516 --> 00:47:00.116 A:middle
So MTKMeshBufferAllocator
is the glue


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:57.516 --> 00:47:00.116 A:middle
So MTKMeshBufferAllocator
is the glue

00:47:00.116 --> 00:47:02.046 A:middle
between Model I/O and Metal.

00:47:03.066 --> 00:47:05.906 A:middle
By passing a device to
a Mesh Buffer Allocator,

00:47:06.306 --> 00:47:09.276 A:middle
we allow Model I/O to create
Metal buffers directly

00:47:09.406 --> 00:47:13.226 A:middle
and then hand them back to us.

00:47:13.226 --> 00:47:15.906 A:middle
So we create an MDLMesh
using this utility method

00:47:16.236 --> 00:47:20.256 A:middle
boxWithExtent, etcetera,
pass in our allocator,

00:47:20.256 --> 00:47:23.136 A:middle
and this will create an
MDLMesh - a Model I/O Mesh -

00:47:23.806 --> 00:47:26.346 A:middle
that contains the relevant data.

00:47:26.906 --> 00:47:30.456 A:middle
We then need to extract it
by using MetalKit's utilities

00:47:31.036 --> 00:47:32.316 A:middle
that are provided
for this purpose.

00:47:32.456 --> 00:47:33.896 A:middle
And that looks like this.

00:47:34.366 --> 00:47:36.596 A:middle
So first, we generate
and MTKMesh that takes

00:47:36.596 --> 00:47:39.776 A:middle
in the MDLMesh that we just
generated, as well as a device.

00:47:40.176 --> 00:47:44.826 A:middle
And then in order to extract
the vertexBuffer, we just index

00:47:44.826 --> 00:47:46.736 A:middle
into the mesh and pull it out.

00:47:47.396 --> 00:47:48.706 A:middle
Similarly, for the indexBuffer.

00:47:49.406 --> 00:47:51.146 A:middle
And there are also a
couple of parameters here

00:47:51.146 --> 00:47:52.366 A:middle
that we've already
seen that we'll need

00:47:52.366 --> 00:47:53.656 A:middle
to supply to our draw call.

00:47:53.656 --> 00:47:56.926 A:middle
But the emphasis here is on
the fact that it's very easy

00:47:57.196 --> 00:47:59.836 A:middle
to use Model I/O to
generate procedural geometry


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:00.136 --> 00:48:01.736 A:middle
and subsequently
pull out buffers

00:48:01.736 --> 00:48:05.136 A:middle
that you can use
directly in Metal.

00:48:05.346 --> 00:48:06.916 A:middle
And now let's talk a
little bit about textures.

00:48:07.576 --> 00:48:08.556 A:middle
We have our vertex data.

00:48:08.676 --> 00:48:10.326 A:middle
We want to apply a
texture map to it

00:48:10.326 --> 00:48:11.366 A:middle
to add a little bit more detail.

00:48:12.066 --> 00:48:14.496 A:middle
Well, as you know, textures
are blocks of memory

00:48:14.686 --> 00:48:16.836 A:middle
in some pre-specified,
pixel format.

00:48:17.116 --> 00:48:19.856 A:middle
And they predominantly are
used to store image data.

00:48:21.086 --> 00:48:24.796 A:middle
In Metal, it's no great surprise
that you create textures

00:48:24.916 --> 00:48:25.956 A:middle
with a descriptor object,

00:48:26.296 --> 00:48:28.516 A:middle
specifically a Metal
Texture Descriptor.

00:48:29.216 --> 00:48:31.326 A:middle
And texture descriptors
are parameter objects

00:48:31.326 --> 00:48:34.446 A:middle
that brings together texture
properties like height and width

00:48:34.446 --> 00:48:37.996 A:middle
and pixel format, and
are used by the device

00:48:37.996 --> 00:48:41.356 A:middle
to actually generate the
texture object: Metal texture.

00:48:41.926 --> 00:48:44.086 A:middle
Let's take a look at that.

00:48:44.756 --> 00:48:46.146 A:middle
So we have these
convenience functions

00:48:46.206 --> 00:48:48.746 A:middle
on Metal Texture Descriptor,
that allow you to ask

00:48:48.746 --> 00:48:51.396 A:middle
for the descriptor that
corresponds to a 2D texture,

00:48:51.946 --> 00:48:55.366 A:middle
supplying on the necessary
parameters: height, width,

00:48:55.866 --> 00:48:58.606 A:middle
pixel format, and whether or
not you want it to be mipmapped.

00:48:59.016 --> 00:49:02.226 A:middle
You can then ask
for a new texture


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.016 --> 00:49:02.226 A:middle
You can then ask
for a new texture

00:49:02.226 --> 00:49:04.836 A:middle
by calling newTexture
on the device.

00:49:04.836 --> 00:49:07.456 A:middle
Now, this texture doesn't
actually have any image content

00:49:07.456 --> 00:49:09.356 A:middle
in it, so you'll
need to use a method

00:49:09.356 --> 00:49:11.286 A:middle
like Replace Region or similar.

00:49:11.286 --> 00:49:14.386 A:middle
You can consult the docs for
that, but we're going to use

00:49:14.386 --> 00:49:16.736 A:middle
yet another utility to make
that a little bit easier to day.

00:49:16.736 --> 00:49:19.116 A:middle
And that's called
MTKTextureLoader.

00:49:19.496 --> 00:49:22.556 A:middle
So this is a utility provided by
MetalKit, and it can load images

00:49:22.556 --> 00:49:24.976 A:middle
from a number of sources,
including your asset catalogs

00:49:24.976 --> 00:49:27.846 A:middle
or from a file URL,
or from CG images

00:49:27.846 --> 00:49:29.416 A:middle
that you have already
sitting in memory,

00:49:29.416 --> 00:49:31.626 A:middle
in the form of an MS
image or a UI image.

00:49:32.236 --> 00:49:34.616 A:middle
And this generates and
populates Metal textures

00:49:34.616 --> 00:49:36.796 A:middle
of the appropriate size
and format that correspond

00:49:36.796 --> 00:49:38.066 A:middle
to the image data
that you already have.

00:49:38.166 --> 00:49:40.566 A:middle
Now let's take a
look at that in code.

00:49:40.776 --> 00:49:43.696 A:middle
So you can create
an MTKTextureLoader

00:49:43.796 --> 00:49:45.256 A:middle
by simply passing
your Metal device.

00:49:45.836 --> 00:49:46.856 A:middle
You'll get back a TextureLoader,

00:49:47.656 --> 00:49:51.026 A:middle
and you can subsequently fetch a
data asset or whatever have you

00:49:51.026 --> 00:49:52.056 A:middle
from your asset catalog.

00:49:52.056 --> 00:49:54.286 A:middle
And as long as you
get the data back,

00:49:54.286 --> 00:49:56.956 A:middle
then you can call
texture Loader.newTexture,

00:49:57.666 --> 00:50:00.426 A:middle
and hand it to data, and it will
hand you back a Metal texture.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:57.666 --> 00:50:00.426 A:middle
and hand it to data, and it will
hand you back a Metal texture.

00:50:03.756 --> 00:50:07.516 A:middle
You might also be acquainted
with the notion called Samplers.

00:50:07.666 --> 00:50:10.326 A:middle
Now, Samplers and Metal are
distinct objects from textures.

00:50:10.326 --> 00:50:12.096 A:middle
They're not bound together.

00:50:13.296 --> 00:50:15.336 A:middle
And Samplers simply
contain the state related

00:50:15.336 --> 00:50:16.246 A:middle
to texture sampling.

00:50:16.806 --> 00:50:20.506 A:middle
So parameters such as
filtering modes, address modes,

00:50:20.506 --> 00:50:22.316 A:middle
as well as level of detail.

00:50:22.476 --> 00:50:24.786 A:middle
And so we support
all those shown here.

00:50:25.236 --> 00:50:28.806 A:middle
In order to get a Sampler
state that we'll bind later

00:50:28.806 --> 00:50:31.206 A:middle
on in our Render Command
encoder, to do textured drawing,

00:50:32.336 --> 00:50:34.486 A:middle
we'll create a Metal
Sampler Descriptor,

00:50:34.486 --> 00:50:35.536 A:middle
and that looks like this.

00:50:36.506 --> 00:50:38.826 A:middle
So we create an empty
Metal Sampler Descriptor

00:50:39.256 --> 00:50:40.476 A:middle
that has default properties,

00:50:40.476 --> 00:50:42.446 A:middle
and we specify whichever
properties we want.

00:50:42.716 --> 00:50:44.976 A:middle
Here, I'm specifying that we
want the texture to repeat

00:50:45.616 --> 00:50:48.706 A:middle
in both axes, and
that when minifying,

00:50:48.706 --> 00:50:50.106 A:middle
we want to use the
nearest filtering

00:50:50.106 --> 00:50:52.226 A:middle
and when magnifying
we linear filtering.

00:50:52.976 --> 00:50:54.686 A:middle
So once we've created
this descriptor object,

00:50:55.456 --> 00:50:56.676 A:middle
we call newSamplerState,

00:50:56.676 --> 00:50:59.206 A:middle
and we get back a Metal
Sampler State Object,

00:50:59.606 --> 00:51:03.686 A:middle
that we can subsequently use to
bind and sample from a texture.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.606 --> 00:51:03.686 A:middle
that we can subsequently use to
bind and sample from a texture.

00:51:03.686 --> 00:51:06.866 A:middle
In the Render Command Encoder,
the API looks like this.

00:51:07.586 --> 00:51:11.326 A:middle
We create a texture so
we set it at Slot Zero

00:51:11.956 --> 00:51:13.846 A:middle
of the Fragment Texture
Argument Table.

00:51:13.846 --> 00:51:18.736 A:middle
And then we bind our
Sampler State at Index Zero

00:51:18.836 --> 00:51:21.856 A:middle
of the Sampler State Argument
Table for the fragmentFunction.

00:51:23.866 --> 00:51:25.896 A:middle
And let's look at those
functions in turn.

00:51:26.856 --> 00:51:29.186 A:middle
So the vertex function this
time around, will multiply

00:51:29.186 --> 00:51:31.426 A:middle
by the MVP Matrix that
we're going to get

00:51:31.426 --> 00:51:32.896 A:middle
out of -- a constant buffer.

00:51:33.076 --> 00:51:35.326 A:middle
It will then transform
the vertex positions

00:51:35.326 --> 00:51:37.186 A:middle
from all the local
space into Clip Space,

00:51:37.626 --> 00:51:40.226 A:middle
which is what we're obligated to
return from the vertex function.

00:51:40.276 --> 00:51:42.796 A:middle
And it will also transform
those vertex normal

00:51:42.796 --> 00:51:44.566 A:middle
from Models Local
Space into Eye Space,

00:51:44.566 --> 00:51:45.736 A:middle
so that we can do our lighting.

00:51:46.406 --> 00:51:47.426 A:middle
Here's what it looks
like in code.

00:51:48.216 --> 00:51:50.346 A:middle
So notice that we've added
a parameter attributed

00:51:50.346 --> 00:51:52.706 A:middle
with Buffer 1, and like
I mentioned earlier,

00:51:52.706 --> 00:51:54.406 A:middle
this corresponds to
the constants buffer.

00:51:54.936 --> 00:51:56.346 A:middle
So we've created a struct type

00:51:56.346 --> 00:51:58.996 A:middle
in our metal shaving
language code that corresponds

00:51:58.996 --> 00:52:01.146 A:middle
to the constant struct that
we created in our SWF code,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:58.996 --> 00:52:01.146 A:middle
to the constant struct that
we created in our SWF code,

00:52:01.146 --> 00:52:04.016 A:middle
that allows us to fetch out
the Model View Projection

00:52:04.016 --> 00:52:04.946 A:middle
in normal matrices.

00:52:05.296 --> 00:52:08.036 A:middle
And again, this is bound
at Argument Table Index 1.

00:52:08.406 --> 00:52:11.046 A:middle
So that corresponds to the
attribute that you see there.

00:52:12.296 --> 00:52:16.236 A:middle
So, to actually move into Clip
Space, we index once again

00:52:16.236 --> 00:52:18.276 A:middle
into the vertexBuffer
at Vertex ID.

00:52:18.976 --> 00:52:20.056 A:middle
Get up a position vector.

00:52:20.346 --> 00:52:22.436 A:middle
Multiply it by the MVP
matrix and assign it

00:52:22.436 --> 00:52:23.346 A:middle
to the outgoing struct.

00:52:24.036 --> 00:52:25.456 A:middle
Similarly, for the normal.

00:52:25.986 --> 00:52:29.526 A:middle
And also, we just copy
through the texture coordinates

00:52:29.526 --> 00:52:30.976 A:middle
to the outgoing struct as well.

00:52:31.016 --> 00:52:32.736 A:middle
And all of these of
course will be interpolated

00:52:32.736 --> 00:52:33.516 A:middle
by the rasterizer.

00:52:34.086 --> 00:52:35.426 A:middle
So we just go ahead
and return that struct.

00:52:36.366 --> 00:52:38.596 A:middle
The fragmentFunction is a
little bit more involved

00:52:38.696 --> 00:52:39.346 A:middle
than previously.

00:52:39.836 --> 00:52:41.976 A:middle
We want to actually
compute some basic lighting,

00:52:42.246 --> 00:52:44.696 A:middle
so we'll include two terms of
ambient and diffuse lighting,

00:52:44.696 --> 00:52:48.076 A:middle
and also sample from the texture
[inaudible] you just bound

00:52:48.076 --> 00:52:50.346 A:middle
to apply the texture
to the surface.

00:52:51.276 --> 00:52:52.246 A:middle
It looks like this.

00:52:52.576 --> 00:52:55.156 A:middle
We're not going to talk
through this in exacting detail,

00:52:55.856 --> 00:52:57.296 A:middle
but the important
thing to note here is

00:52:57.296 --> 00:52:59.476 A:middle
that we've added a parameter
that corresponds to the texture

00:52:59.476 --> 00:53:00.696 A:middle
that we've created and bound,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:59.476 --> 00:53:00.696 A:middle
that we've created and bound,

00:53:01.316 --> 00:53:03.626 A:middle
we've given it an access
qualifier of sample

00:53:03.856 --> 00:53:05.196 A:middle
which allows us to
sample from it.

00:53:05.756 --> 00:53:07.486 A:middle
It's sitting at Argument
Table Index Zero.

00:53:07.946 --> 00:53:09.666 A:middle
The Sampler State that
we created is sitting

00:53:09.706 --> 00:53:13.906 A:middle
at Argument Slot Zero for the
sampler, and all we need to do

00:53:13.906 --> 00:53:15.736 A:middle
to actually read a
[inaudible] from the --

00:53:15.736 --> 00:53:18.106 A:middle
a filtered value
from the texture,

00:53:18.716 --> 00:53:20.596 A:middle
is call Sample, on the texture.

00:53:20.806 --> 00:53:23.996 A:middle
So Text2D.Sample, actually
it takes the sampler state,

00:53:24.946 --> 00:53:26.366 A:middle
as well as the texture
coordinates

00:53:26.366 --> 00:53:28.456 A:middle
and gives us back
the color vector.

00:53:29.796 --> 00:53:33.566 A:middle
We'll also go ahead and do
all of our fancy lighting,

00:53:33.636 --> 00:53:35.366 A:middle
but I won't talk
through any detail.

00:53:35.486 --> 00:53:39.196 A:middle
But it's just dependent upon the
dot product between the normal

00:53:39.196 --> 00:53:40.056 A:middle
and the lighting direction.

00:53:40.056 --> 00:53:43.926 A:middle
And we specified some constants
related to the light earlier

00:53:43.926 --> 00:53:45.616 A:middle
in our Shader file that
we'll see during the demo.

00:53:45.616 --> 00:53:47.596 A:middle
And that's pretty much it.

00:53:47.686 --> 00:53:52.176 A:middle
So we constructed the color
for this particular fragment

00:53:52.506 --> 00:53:54.846 A:middle
by multiplying through the value
that we sample from the texture,

00:53:55.056 --> 00:53:56.196 A:middle
by the lighting intensity,

00:53:56.336 --> 00:54:00.356 A:middle
to result in an animated
textured lit cube.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:56.336 --> 00:54:00.356 A:middle
to result in an animated
textured lit cube.

00:54:00.816 --> 00:54:05.306 A:middle
And I will now let Matt
show you exactly that.

00:54:05.556 --> 00:54:07.096 A:middle
&gt;&gt; Alright, let's take
a look at this demo.

00:54:08.046 --> 00:54:09.466 A:middle
Here's the Metal texture mesh.

00:54:09.676 --> 00:54:11.416 A:middle
You can see, it's a
very complicated cube.

00:54:12.066 --> 00:54:13.446 A:middle
Some simple lighting,
and texturing,

00:54:14.066 --> 00:54:15.926 A:middle
on a nice colored background.

00:54:18.586 --> 00:54:19.886 A:middle
Go ahead and admire
it in all its glory,

00:54:20.136 --> 00:54:22.216 A:middle
and now we'll take a
look at the Shader.

00:54:23.406 --> 00:54:24.666 A:middle
So you can see some new stuff

00:54:24.666 --> 00:54:25.966 A:middle
in our Shader compared
to last time.

00:54:26.536 --> 00:54:28.866 A:middle
The first thing we take a look
at is this constant struct.

00:54:29.346 --> 00:54:30.726 A:middle
This corresponds
the Swift's direct

00:54:30.756 --> 00:54:34.636 A:middle
that has a 4 X 4 Model View
Projection Matrix, and a 3 X 3,

00:54:34.636 --> 00:54:35.866 A:middle
normal matrix, and
those are used

00:54:35.866 --> 00:54:36.996 A:middle
for the appropriate transforms.

00:54:37.446 --> 00:54:40.716 A:middle
As Warren mentioned, we
have some light data here.

00:54:41.386 --> 00:54:43.176 A:middle
Ambient light intensity,
which is quite low.

00:54:43.486 --> 00:54:45.456 A:middle
And the diffused light
intensity, which is quite high,

00:54:45.586 --> 00:54:47.176 A:middle
and the direction of
the light that we'll use

00:54:47.596 --> 00:54:49.306 A:middle
to actually compute
the dot product.

00:54:49.306 --> 00:54:52.946 A:middle
Our input and output structs
are slightly different.

00:54:52.946 --> 00:54:54.076 A:middle
We've got a little
more information

00:54:54.076 --> 00:54:55.156 A:middle
that we need to pass down now.

00:54:55.956 --> 00:54:56.706 A:middle
We have position.

00:54:56.756 --> 00:54:58.296 A:middle
We have the normal, which
we needed for the lighting,

00:54:58.426 --> 00:54:59.396 A:middle
and the texture coordinates

00:54:59.396 --> 00:55:00.606 A:middle
which we need to
apply the texture.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:59.396 --> 00:55:00.606 A:middle
which we need to
apply the texture.

00:55:01.616 --> 00:55:04.136 A:middle
And similarly, when we output
from our vertex function,

00:55:05.616 --> 00:55:06.636 A:middle
we need that same data again.

00:55:06.946 --> 00:55:08.236 A:middle
So let's take a look
at the vertex function.

00:55:08.636 --> 00:55:09.556 A:middle
Just as Warren said,

00:55:10.066 --> 00:55:12.676 A:middle
it's basically just a couple
simple matrix, multiplies,

00:55:12.746 --> 00:55:14.496 A:middle
and then a pass through for
the texture coordinates.

00:55:16.176 --> 00:55:18.226 A:middle
And a quick look at
our fragmentFunction,

00:55:18.226 --> 00:55:20.636 A:middle
which is exactly what
Warren just showed you.

00:55:22.066 --> 00:55:24.566 A:middle
Now let's see how
the renderer looks.

00:55:26.136 --> 00:55:27.496 A:middle
A little more going on now.

00:55:29.076 --> 00:55:30.266 A:middle
So we have a little
bit of animation.

00:55:30.316 --> 00:55:32.786 A:middle
So we need to update a little
time step to know how much

00:55:32.836 --> 00:55:33.856 A:middle
to rotate our cube by.

00:55:34.696 --> 00:55:36.136 A:middle
So here we have a
little helper function

00:55:36.136 --> 00:55:37.986 A:middle
to update my time step
-- update with Time Step.

00:55:38.846 --> 00:55:42.806 A:middle
And that will change
our constants.

00:55:43.986 --> 00:55:45.816 A:middle
Just like Warren said, we
don't have much data that we'd

00:55:45.816 --> 00:55:48.446 A:middle
like to send over to the GPU,
so when you set vertex bytes,

00:55:48.846 --> 00:55:50.266 A:middle
send a small structure over,

00:55:50.266 --> 00:55:51.936 A:middle
which was the two
matrices before.

00:55:51.936 --> 00:55:53.376 A:middle
And that's what we'll use

00:55:53.376 --> 00:55:57.076 A:middle
to compute the animated
positions of our vertices.

00:55:58.416 --> 00:56:00.496 A:middle
Put the texture, the
samplers, and issue your Draws.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:58.416 --> 00:56:00.496 A:middle
Put the texture, the
samplers, and issue your Draws.

00:56:01.356 --> 00:56:02.826 A:middle
Highly recommend you
guys always remember

00:56:02.826 --> 00:56:04.616 A:middle
to push your debug
groups so you know,

00:56:04.996 --> 00:56:06.366 A:middle
exactly what you're looking
at if you're going to look

00:56:06.366 --> 00:56:07.426 A:middle
at a frame capture later on.

00:56:08.096 --> 00:56:12.856 A:middle
Present your drawable and
commit, and then you're done.

00:56:14.846 --> 00:56:19.316 A:middle
&gt;&gt; Cool. Thanks again, Matt.

00:56:19.936 --> 00:56:23.006 A:middle
So with these adopting Metal
sessions, we really wanted

00:56:23.006 --> 00:56:25.666 A:middle
to take advantage of the
fact that we've had a couple

00:56:25.666 --> 00:56:27.096 A:middle
of years now, teaching Metal,

00:56:27.586 --> 00:56:29.316 A:middle
and introducing awesome
new utilities

00:56:29.706 --> 00:56:31.196 A:middle
that make Metal easy to use.

00:56:31.286 --> 00:56:32.786 A:middle
And so we hope that these --

00:56:33.276 --> 00:56:36.116 A:middle
this two-part session
is useful for that.

00:56:36.116 --> 00:56:38.396 A:middle
You've seen that
Metal is a powerful

00:56:38.396 --> 00:56:42.436 A:middle
and low overhead GPU programming
technology, and fortunately now,

00:56:42.436 --> 00:56:44.696 A:middle
you've become acquainted
with some of the APIs

00:56:44.696 --> 00:56:47.066 A:middle
that are available inside of it.

00:56:48.056 --> 00:56:50.196 A:middle
Metal is a very closely --

00:56:50.196 --> 00:56:54.026 A:middle
is very much informed by how
the GPU actually operates

00:56:54.026 --> 00:56:57.666 A:middle
and is you know, philosophically
of course, we want you to push

00:56:57.666 --> 00:57:00.656 A:middle
as much expensive work
up front as possible.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:57.666 --> 00:57:00.656 A:middle
as much expensive work
up front as possible.

00:57:00.756 --> 00:57:02.466 A:middle
And so you've seen sort
of some of the ways

00:57:02.466 --> 00:57:04.896 A:middle
that that informs
the API as well.

00:57:05.466 --> 00:57:09.486 A:middle
And the emphasis of course
is not on the restrictions

00:57:09.486 --> 00:57:10.616 A:middle
that that entails,
but of course,

00:57:10.616 --> 00:57:12.146 A:middle
the power that it
imbues you with.

00:57:12.596 --> 00:57:14.476 A:middle
So you've seen how
explicit memory management

00:57:14.476 --> 00:57:17.346 A:middle
and command submission can let
you work a little bit smarter,

00:57:17.416 --> 00:57:19.816 A:middle
in a sense that if you know
how your application is shaped

00:57:19.816 --> 00:57:21.916 A:middle
and you know what it's
doing, then you can actually,

00:57:22.526 --> 00:57:25.466 A:middle
you can take the reins and
control the GPU directly.

00:57:26.336 --> 00:57:30.106 A:middle
And of course, over the next
few sessions on Metal here

00:57:30.666 --> 00:57:33.426 A:middle
at WWDC this year,
we'll show you even more

00:57:33.626 --> 00:57:34.816 A:middle
that Metal has in store.

00:57:34.876 --> 00:57:36.936 A:middle
And then of course, it
will be your turn to go

00:57:36.936 --> 00:57:38.346 A:middle
and build awesome
new experiences.

00:57:39.016 --> 00:57:41.386 A:middle
So for more information on this
session, Session Number 602,

00:57:41.386 --> 00:57:43.826 A:middle
you can go to this
URL, and of course,

00:57:43.826 --> 00:57:45.006 A:middle
there are some related sessions.

00:57:45.496 --> 00:57:48.936 A:middle
Part II will be happening in
this very room, very shortly.

00:57:49.866 --> 00:57:53.966 A:middle
And tomorrow we have, What's
New in Metal, Parts I and II.

00:57:54.116 --> 00:57:56.826 A:middle
And the Advanced Metal
Shader Optimization talk

00:57:56.826 --> 00:57:57.366 A:middle
that I mentioned.

00:57:57.736 --> 00:57:59.976 A:middle
So thank you, and
have a wonderful WWDC.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:58:00.016 --> 00:58:02.000 A:middle
[ Applause ]

