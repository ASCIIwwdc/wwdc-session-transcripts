WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:20.016 --> 00:00:21.046 A:middle
[ Applause ]

00:00:21.046 --> 00:00:24.206 A:middle
&gt;&gt; DOUG GREGOR: Thank you.

00:00:24.206 --> 00:00:26.056 A:middle
Hello. I'm Doug Gregor.

00:00:26.266 --> 00:00:29.366 A:middle
I'm here with my colleague
Bill Dudney, and we will talk

00:00:29.366 --> 00:00:32.366 A:middle
about building better apps
with value types in Swift.

00:00:32.665 --> 00:00:37.696 A:middle
First, we are going
to start off talking

00:00:37.696 --> 00:00:41.256 A:middle
about reference semantics,
and then we will delve

00:00:41.316 --> 00:00:44.726 A:middle
through immutability as a
solution to some of the problems

00:00:44.726 --> 00:00:46.376 A:middle
that reference semantics pose.

00:00:48.036 --> 00:00:51.236 A:middle
Dive into value semantics and
value types, how it works,

00:00:51.236 --> 00:00:54.226 A:middle
especially how it works
in Swift, and then talk

00:00:54.226 --> 00:00:56.856 A:middle
about using value types in
practice and then the mixing

00:00:56.856 --> 00:01:00.116 A:middle
of reference types and value
types together within Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:56.856 --> 00:01:00.116 A:middle
of reference types and value
types together within Swift.

00:01:01.086 --> 00:01:03.916 A:middle
Let's get started.

00:01:04.025 --> 00:01:05.075 A:middle
Reference semantics.

00:01:05.676 --> 00:01:07.366 A:middle
So the way into reference
semantics

00:01:07.366 --> 00:01:10.086 A:middle
in the Swift world
is to define a class.

00:01:11.396 --> 00:01:13.196 A:middle
Here's a very simple
temperature class.

00:01:13.796 --> 00:01:16.436 A:middle
We are storing our
temperature value in Celsius.

00:01:16.716 --> 00:01:19.206 A:middle
We want to have this nice
computed Fahrenheit property

00:01:19.206 --> 00:01:22.576 A:middle
so we can always get to
it with the correct unit.

00:01:23.646 --> 00:01:25.696 A:middle
Simple, abstracted
version of a temperature.

00:01:26.316 --> 00:01:28.056 A:middle
Let's try to use it
in some simple code.

00:01:28.746 --> 00:01:31.886 A:middle
We create a home instance, we
create a temperature instance.

00:01:32.236 --> 00:01:35.506 A:middle
We set our thermostat to a
balmy 75 degrees Fahrenheit.

00:01:36.886 --> 00:01:39.466 A:middle
Now we decide, oh, it's
getting close to dinnertime

00:01:39.466 --> 00:01:40.626 A:middle
and I want to bake some salmon.

00:01:40.976 --> 00:01:44.146 A:middle
So I set my oven to 425
degrees and hit Bake.

00:01:44.876 --> 00:01:45.456 A:middle
Walk away.

00:01:45.546 --> 00:01:49.636 A:middle
Why is it so hot in here?

00:01:49.796 --> 00:01:50.416 A:middle
What's going on?

00:01:51.866 --> 00:01:52.676 A:middle
You know what happened.

00:01:52.736 --> 00:01:55.076 A:middle
We hit this case of
unintended sharing.

00:01:55.456 --> 00:01:56.466 A:middle
Think of the object graph.

00:01:57.966 --> 00:01:58.966 A:middle
We have our house.

00:01:59.056 --> 00:02:00.806 A:middle
It has a thermostat and an oven.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.056 --> 00:02:00.806 A:middle
It has a thermostat and an oven.

00:02:01.166 --> 00:02:03.686 A:middle
We have this temperature
object that temp points to.

00:02:04.526 --> 00:02:06.076 A:middle
When we set our thermostat,

00:02:06.536 --> 00:02:08.436 A:middle
we wired it to the same
object as the temp.

00:02:09.166 --> 00:02:12.476 A:middle
Things look like fine until
we go ahead and do a mutation,

00:02:12.806 --> 00:02:14.186 A:middle
and now this unintended

00:02:14.186 --> 00:02:18.186 A:middle
or unexpected sharing just
caused us to set our thermostat

00:02:18.226 --> 00:02:20.216 A:middle
to 425 degrees Fahrenheit.

00:02:21.496 --> 00:02:23.176 A:middle
At this point it was
already game over,

00:02:23.176 --> 00:02:26.616 A:middle
but just for good measure let's
wire our thermostat to our oven

00:02:26.616 --> 00:02:27.736 A:middle
because we've lost already.

00:02:27.776 --> 00:02:32.556 A:middle
So what did we do wrong?

00:02:32.556 --> 00:02:34.966 A:middle
In this world where you
have reference semantics,

00:02:35.656 --> 00:02:38.456 A:middle
you want to prevent sharing,
and so you do copies.

00:02:40.066 --> 00:02:41.786 A:middle
Okay? Let's do this
the right way.

00:02:42.696 --> 00:02:45.356 A:middle
Okay. I'm going to
set my temperature

00:02:45.356 --> 00:02:47.196 A:middle
to 75 degrees Fahrenheit again.

00:02:47.806 --> 00:02:51.816 A:middle
When I set the temperature of my
thermostat, I will cause a copy.

00:02:52.146 --> 00:02:53.646 A:middle
So I get a brand new object.

00:02:53.906 --> 00:02:56.046 A:middle
That's what my thermostat's
temperature points to.

00:02:56.716 --> 00:02:58.686 A:middle
When I go ahead and
change the temperature

00:02:58.686 --> 00:03:00.626 A:middle
of my temp variable,
it doesn't affect it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.686 --> 00:03:00.626 A:middle
of my temp variable,
it doesn't affect it.

00:03:00.896 --> 00:03:01.256 A:middle
That's good.

00:03:02.156 --> 00:03:03.926 A:middle
Now I go and set the
oven's temperature,

00:03:04.156 --> 00:03:05.326 A:middle
I will make another copy.

00:03:06.496 --> 00:03:09.596 A:middle
Now, technically, I don't
need this last copy.

00:03:10.216 --> 00:03:13.666 A:middle
It's inefficient to go
waste time allocating memory

00:03:13.666 --> 00:03:15.556 A:middle
on the heap to create
this extra copy.

00:03:16.286 --> 00:03:18.656 A:middle
But I'm going to be safe because
the last time I missed a copy,

00:03:18.986 --> 00:03:19.826 A:middle
I got burned [groaning]!

00:03:22.166 --> 00:03:24.216 A:middle
Come on, it's a Friday
session, give me a break!

00:03:25.516 --> 00:03:29.696 A:middle
[ Applause ]

00:03:30.196 --> 00:03:35.716 A:middle
So we refer to this as defensive
copying, where we copy not

00:03:35.716 --> 00:03:38.656 A:middle
because we know we need it,
but because if we do happen

00:03:38.656 --> 00:03:41.986 A:middle
to need it now or sometime
down the road, it's really hard

00:03:41.986 --> 00:03:43.406 A:middle
to debug these problems.

00:03:43.866 --> 00:03:46.236 A:middle
And so it's way too easy

00:03:46.236 --> 00:03:49.286 A:middle
to forget a dot copy any time we
assigned a temperature somewhere

00:03:49.286 --> 00:03:49.866 A:middle
in our oven.

00:03:50.216 --> 00:03:52.866 A:middle
So instead, I will bake
this behavior right

00:03:53.606 --> 00:03:55.976 A:middle
into my oven [laughter].

00:03:56.146 --> 00:03:56.926 A:middle
All right, I'm done.

00:03:56.926 --> 00:03:57.836 A:middle
I'm done. I'm sorry.

00:03:58.006 --> 00:03:58.486 A:middle
I'm sorry [applause].

00:03:59.486 --> 00:04:01.516 A:middle
Naturally I have to do
this exact same thing


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.486 --> 00:04:01.516 A:middle
Naturally I have to do
this exact same thing

00:04:01.516 --> 00:04:02.936 A:middle
for the thermostat, all right?

00:04:02.936 --> 00:04:05.066 A:middle
So now we've got a whole bunch
of boilerplate we are copying

00:04:05.066 --> 00:04:07.256 A:middle
and pasting, and sooner or
later, you will be knocking

00:04:07.256 --> 00:04:09.126 A:middle
on my door asking for a
language feature here.

00:04:09.846 --> 00:04:14.206 A:middle
Hold off on that, and let's
talk about where we see copying

00:04:14.206 --> 00:04:15.646 A:middle
in Cocoa and Objective-C.

00:04:16.666 --> 00:04:18.486 A:middle
So in Cocoa, you
have this notion

00:04:18.486 --> 00:04:19.836 A:middle
of the NSCopying protocol.

00:04:20.315 --> 00:04:22.866 A:middle
And this codifies
what it means to copy,

00:04:23.506 --> 00:04:26.386 A:middle
and you have a whole lot of
data types and this NSstring,

00:04:26.446 --> 00:04:28.796 A:middle
NSArray, NSURLRequest, etcetera.

00:04:29.056 --> 00:04:31.906 A:middle
These things conform to
NSCopying because you have

00:04:31.956 --> 00:04:33.226 A:middle
to copy them to be safe.

00:04:33.616 --> 00:04:37.896 A:middle
We are in a system that needs
copying, and so you see a lot

00:04:37.896 --> 00:04:40.676 A:middle
of defensive copying for
very, very good reasons.

00:04:40.716 --> 00:04:44.756 A:middle
So NSDictionary will defensively
copy the keys you place

00:04:44.756 --> 00:04:45.506 A:middle
in the dictionary.

00:04:46.366 --> 00:04:49.966 A:middle
Why? Well, if you were to hand
NSDictionary a key to insert it

00:04:50.246 --> 00:04:53.736 A:middle
and then go change it in a way
that, say, alters the hash value

00:04:53.736 --> 00:04:55.996 A:middle
of it, you will break
all the internal variance

00:04:55.996 --> 00:04:58.396 A:middle
of NSDictionary and
blame us for your bugs.

00:04:58.396 --> 00:04:59.596 A:middle
We don't really want that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.216 --> 00:05:02.846 A:middle
What we really do is
we do defensive copying

00:05:02.846 --> 00:05:03.566 A:middle
in NSDictionary.

00:05:03.566 --> 00:05:06.626 A:middle
That's the right answer in this
system, but it's unfortunate

00:05:06.666 --> 00:05:09.166 A:middle
that we are losing performance

00:05:09.166 --> 00:05:10.616 A:middle
because we are doing
these extra copies.

00:05:11.736 --> 00:05:14.346 A:middle
Of course, we moved this all
the way down into the level

00:05:14.346 --> 00:05:17.146 A:middle
of the language with copy
properties in Objective-C

00:05:17.456 --> 00:05:20.746 A:middle
that do defensive copying on
every single assignment to try

00:05:20.746 --> 00:05:23.176 A:middle
to prevent these
problems, and it helps,

00:05:23.176 --> 00:05:25.106 A:middle
all this defensive
copying helps,

00:05:25.186 --> 00:05:26.546 A:middle
but it's never good enough.

00:05:26.846 --> 00:05:28.226 A:middle
You still have a ton of bugs.

00:05:29.036 --> 00:05:32.086 A:middle
So we have problems with
those reference semantics

00:05:32.136 --> 00:05:33.106 A:middle
and there's mutation.

00:05:34.356 --> 00:05:36.716 A:middle
Maybe the problem here is
not the reference semantics

00:05:36.936 --> 00:05:38.166 A:middle
but the mutation itself.

00:05:38.496 --> 00:05:40.066 A:middle
Perhaps we should
move to a world

00:05:40.066 --> 00:05:43.306 A:middle
of immutable data structures
with reference semantics.

00:05:44.006 --> 00:05:45.126 A:middle
If you go talk to someone

00:05:45.126 --> 00:05:48.546 A:middle
in the functional programming
community, they will say, yeah,

00:05:48.736 --> 00:05:50.246 A:middle
we have been doing
this for decades!

00:05:51.066 --> 00:05:52.926 A:middle
And it does improve
things there.

00:05:53.316 --> 00:05:56.386 A:middle
So you can't have unintended
side effects in a world

00:05:56.386 --> 00:05:58.826 A:middle
where there are no side effects,

00:05:58.896 --> 00:06:01.646 A:middle
and so immutable reference
semantics are a consistent way


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.896 --> 00:06:01.646 A:middle
and so immutable reference
semantics are a consistent way

00:06:01.826 --> 00:06:02.766 A:middle
to work in the system.

00:06:02.916 --> 00:06:06.666 A:middle
It doesn't have these unintended
consequences, which we ran

00:06:06.666 --> 00:06:08.306 A:middle
into in our little
temperature example.

00:06:09.296 --> 00:06:13.296 A:middle
The problem is that immutability
has some disadvantages.

00:06:13.756 --> 00:06:15.856 A:middle
It can lead to some
awkward interfaces,

00:06:16.306 --> 00:06:19.166 A:middle
and part of this is just
the way the languages work,

00:06:19.616 --> 00:06:22.506 A:middle
and part of this is that we're
used to living in a world

00:06:22.506 --> 00:06:25.376 A:middle
where we can mutate things,
and we think about state

00:06:25.376 --> 00:06:27.646 A:middle
and mutating state,
and so thinking

00:06:27.646 --> 00:06:29.996 A:middle
in purely a immutable world
can be a little bit weird

00:06:29.996 --> 00:06:30.936 A:middle
for us at times.

00:06:31.826 --> 00:06:33.776 A:middle
There's also the question
of an efficient mapping

00:06:33.776 --> 00:06:35.016 A:middle
down to the machine model.

00:06:35.816 --> 00:06:37.766 A:middle
Eventually, you have to
get down to machine code,

00:06:37.766 --> 00:06:40.516 A:middle
and you are running on a CPU
that has stateful registers,

00:06:40.516 --> 00:06:41.446 A:middle
and stateful caches,

00:06:41.446 --> 00:06:43.326 A:middle
and stateful memory,
and stateful storage.

00:06:44.356 --> 00:06:48.416 A:middle
It's not always easy to map
an immutable algorithm down to

00:06:48.416 --> 00:06:49.796 A:middle
that level efficiently.

00:06:50.486 --> 00:06:51.656 A:middle
Let's talk through
a couple of these.

00:06:52.166 --> 00:06:54.756 A:middle
We will take this temperature
class of ours and try

00:06:54.756 --> 00:06:56.586 A:middle
to make it safer by
making it immutable.

00:06:57.386 --> 00:07:00.436 A:middle
So, all we had to do here was
change the stored property


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.386 --> 00:07:00.436 A:middle
So, all we had to do here was
change the stored property

00:07:00.436 --> 00:07:03.286 A:middle
Celsius from a var to a let,
and now you can't change it.

00:07:03.916 --> 00:07:07.006 A:middle
And then the Fahrenheit computer
property loses its setter.

00:07:07.156 --> 00:07:08.296 A:middle
So you can't change the state

00:07:08.296 --> 00:07:09.646 A:middle
of temperature no
matter what you do.

00:07:09.966 --> 00:07:11.846 A:middle
We add some initializers
for convenience.

00:07:12.146 --> 00:07:15.706 A:middle
Okay. Let's talk
about awkwarding.

00:07:16.646 --> 00:07:18.066 A:middle
Awkward immutable interfaces.

00:07:18.466 --> 00:07:22.586 A:middle
Before, if I wanted to, say,
tweak the temperature of my oven

00:07:22.586 --> 00:07:25.356 A:middle
by 10 degrees Fahrenheit,
this was a simple operation.

00:07:26.306 --> 00:07:27.006 A:middle
Plus equals 10.

00:07:27.186 --> 00:07:27.856 A:middle
That does it.

00:07:27.856 --> 00:07:28.216 A:middle
That's it.

00:07:29.416 --> 00:07:31.876 A:middle
How would we do this if we
have taken away mutation?

00:07:32.206 --> 00:07:35.016 A:middle
Well, we have to go and grab the
temperature object in the oven,

00:07:35.656 --> 00:07:39.206 A:middle
create yet another temperature
object that has the new value.

00:07:39.206 --> 00:07:40.856 A:middle
All right?

00:07:41.106 --> 00:07:42.296 A:middle
So it's a little
bit more awkward.

00:07:42.296 --> 00:07:46.686 A:middle
There's more code, and we wasted
time allocating another object

00:07:46.686 --> 00:07:47.106 A:middle
on the heap.

00:07:47.946 --> 00:07:50.476 A:middle
But in truth, we have not
embraced immutability here

00:07:50.796 --> 00:07:54.336 A:middle
because we did an assignment
that mutated the oven itself.

00:07:55.196 --> 00:07:57.096 A:middle
If we were actually embracing the notion

00:07:57.096 --> 00:07:59.576 A:middle
of immutable reference
types throughout here,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.116 --> 00:08:02.366 A:middle
we would be creating a new
temperature to put in a new oven

00:08:02.366 --> 00:08:03.536 A:middle
to put in a new home [laughter].

00:08:05.716 --> 00:08:11.856 A:middle
Awkward! So let's get a
little bit more theoretical

00:08:11.856 --> 00:08:12.346 A:middle
and do some math.

00:08:13.286 --> 00:08:17.496 A:middle
So the Sieve of Eratosthenes
is an ancient algorithm

00:08:17.496 --> 00:08:18.916 A:middle
for computing prime numbers.

00:08:19.446 --> 00:08:22.106 A:middle
It uses mutation and
actually lends itself well

00:08:22.106 --> 00:08:24.256 A:middle
to drawing things out in
the dirt with a stick.

00:08:24.786 --> 00:08:29.246 A:middle
So this is the implementation of
the mutating version in Swift.

00:08:29.246 --> 00:08:31.366 A:middle
We are going to walk through it
so you get the idea behind it.

00:08:31.966 --> 00:08:33.546 A:middle
First thing you do:
create an array.

00:08:34.696 --> 00:08:36.416 A:middle
Notice the var because we are
going to mutate this array.

00:08:36.986 --> 00:08:40.716 A:middle
Notice this array is from
two, first prime number,

00:08:41.006 --> 00:08:42.676 A:middle
up through whatever
number you want to compute.

00:08:42.676 --> 00:08:43.535 A:middle
We will do 20 here.

00:08:44.836 --> 00:08:47.806 A:middle
Now, the outer loop,
each time through it,

00:08:47.806 --> 00:08:50.146 A:middle
we will pick the next
number in the array.

00:08:51.006 --> 00:08:52.536 A:middle
That number is a
prime number, P.

00:08:53.786 --> 00:08:56.546 A:middle
What the inner loop is
going to do is walk over all

00:08:56.546 --> 00:09:01.666 A:middle
of the multiples of P,
erasing them from the array


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:56.546 --> 00:09:01.666 A:middle
of the multiples of P,
erasing them from the array

00:09:01.956 --> 00:09:02.856 A:middle
by setting them to zero.

00:09:04.166 --> 00:09:05.276 A:middle
Because, of course,
if you are a multiple

00:09:05.276 --> 00:09:06.446 A:middle
of a prime number,
you are not prime.

00:09:07.516 --> 00:09:08.506 A:middle
Back to the outer loop,

00:09:08.506 --> 00:09:11.016 A:middle
we go and grab the next
number, it's a prime number.

00:09:11.276 --> 00:09:13.766 A:middle
We erase all of its
multiples from the array.

00:09:13.766 --> 00:09:15.486 A:middle
So it's a very, very
simple algorithm.

00:09:15.546 --> 00:09:16.686 A:middle
Think of the stick in the dirt.

00:09:16.686 --> 00:09:18.486 A:middle
You are just scratching
things out.

00:09:19.636 --> 00:09:21.136 A:middle
Once we are done
going through all

00:09:21.136 --> 00:09:24.236 A:middle
of our iterations,
we go down here.

00:09:24.456 --> 00:09:26.786 A:middle
And we do the last simple
operation, which says,

00:09:27.106 --> 00:09:28.986 A:middle
everything that we have not
zeroed out in the array,

00:09:28.986 --> 00:09:30.226 A:middle
that's part of our result.

00:09:30.226 --> 00:09:32.736 A:middle
So we will do that
with a filter.

00:09:32.846 --> 00:09:35.786 A:middle
Simple algorithm,
entirely based on mutation.

00:09:36.306 --> 00:09:38.956 A:middle
Now that doesn't mean
you can't express it

00:09:39.046 --> 00:09:40.356 A:middle
in a world without mutation.

00:09:40.646 --> 00:09:42.186 A:middle
You can. Of course.

00:09:42.986 --> 00:09:44.776 A:middle
So to do that, we are
going to use Haskell,

00:09:44.776 --> 00:09:46.456 A:middle
because it's a pure
functional language [applause].

00:09:48.256 --> 00:09:49.806 A:middle
Yes, I knew people
would love it!

00:09:50.276 --> 00:09:50.586 A:middle
All right.

00:09:51.586 --> 00:09:53.416 A:middle
So this is the Haskell
formulation.

00:09:53.416 --> 00:09:55.986 A:middle
It's -- if you read
Haskell, it's beautiful.

00:09:56.836 --> 00:09:57.546 A:middle
It's functional.

00:09:57.546 --> 00:09:58.516 A:middle
It doesn't mutate at all.

00:09:59.186 --> 00:10:01.106 A:middle
Here's a very similar
implementation because it turns


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.186 --> 00:10:01.106 A:middle
Here's a very similar
implementation because it turns

00:10:01.106 --> 00:10:03.676 A:middle
out Swift can do functional
also, and if you want

00:10:03.676 --> 00:10:05.666 A:middle
to make it lazy, that's
an exercise to the reader

00:10:05.666 --> 00:10:06.796 A:middle
but it's not that much harder.

00:10:07.556 --> 00:10:09.726 A:middle
And we're going to walk through
how this algorithm works,

00:10:09.766 --> 00:10:11.516 A:middle
because It's very, very similar.

00:10:12.036 --> 00:10:16.776 A:middle
We start with our array
of numbers from 2 to 20.

00:10:17.356 --> 00:10:21.586 A:middle
In the simple basis case,
if there's no numbers, well,

00:10:21.586 --> 00:10:22.636 A:middle
there's no prime
numbers in there.

00:10:22.636 --> 00:10:24.046 A:middle
So that's the first
If statement.

00:10:24.046 --> 00:10:24.636 A:middle
It's trivial.

00:10:25.916 --> 00:10:28.676 A:middle
Otherwise, what you do is we
take out the first number,

00:10:28.776 --> 00:10:30.206 A:middle
that's always going to be prime.

00:10:30.896 --> 00:10:32.786 A:middle
And separate it from
the remaining numbers.

00:10:33.196 --> 00:10:34.876 A:middle
Right? Haskell did this
with pattern matching,

00:10:34.876 --> 00:10:35.796 A:middle
and we can do slicing here.

00:10:36.786 --> 00:10:39.686 A:middle
Then we take that prime number
and we run a filter operation

00:10:39.906 --> 00:10:44.186 A:middle
over all of the elements
here in this remaining array.

00:10:45.166 --> 00:10:46.516 A:middle
Copying only those things

00:10:46.516 --> 00:10:48.566 A:middle
that aren't multiples
of that prime number.

00:10:49.936 --> 00:10:51.356 A:middle
Now we recurse and do it again.

00:10:52.106 --> 00:10:54.136 A:middle
Split out the three and this
is our new prime number.

00:10:54.516 --> 00:10:55.696 A:middle
Go ahead and run the filter.

00:10:56.886 --> 00:11:00.496 A:middle
Eliminate all the multiples of
three, and so on and so forth.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:56.886 --> 00:11:00.496 A:middle
Eliminate all the multiples of
three, and so on and so forth.

00:11:00.986 --> 00:11:02.286 A:middle
What happens here is you end

00:11:02.286 --> 00:11:05.986 A:middle
up building along this left-hand
diagonal the actual prime

00:11:05.986 --> 00:11:08.666 A:middle
numbers, and as a result they
all get concatenated together.

00:11:10.176 --> 00:11:11.456 A:middle
The idea is similar.

00:11:11.706 --> 00:11:12.946 A:middle
It's very, very similar.

00:11:13.976 --> 00:11:16.246 A:middle
But it's not the same algorithm

00:11:16.246 --> 00:11:20.076 A:middle
because it has different
performance characteristics.

00:11:21.236 --> 00:11:23.486 A:middle
So this result comes
from a brilliant paper

00:11:23.486 --> 00:11:26.486 A:middle
by Melissa O'Neil called "The
Genuine Sieve of Eratosthenes,"

00:11:27.156 --> 00:11:28.996 A:middle
where she showed the
Haskell community

00:11:28.996 --> 00:11:32.106 A:middle
that their beloved sieve
was not the real sieve

00:11:32.596 --> 00:11:35.616 A:middle
because it did not perform
the same as the real sieve.

00:11:36.356 --> 00:11:40.386 A:middle
She goes through much more
complicated implementations

00:11:40.386 --> 00:11:43.936 A:middle
in Haskell, that can get back to
the performance characteristics.

00:11:44.136 --> 00:11:45.126 A:middle
Read the paper and check it out.

00:11:45.126 --> 00:11:45.826 A:middle
It's really cool.

00:11:46.056 --> 00:11:48.736 A:middle
I want to give you a taste
of why this is the case.

00:11:48.736 --> 00:11:50.646 A:middle
Look at either the
Haskell list comprehension

00:11:50.946 --> 00:11:52.966 A:middle
or the equivalent
Swift filter below.

00:11:53.456 --> 00:11:59.206 A:middle
In this nonmutating version,
this operation will walk

00:11:59.206 --> 00:12:01.896 A:middle
over every single
element in the array


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.206 --> 00:12:01.896 A:middle
over every single
element in the array

00:12:02.136 --> 00:12:04.566 A:middle
and do a division operation
to see if it should still be

00:12:04.566 --> 00:12:06.726 A:middle
in the next step, to see if
it's a multiple of P or not.

00:12:07.666 --> 00:12:11.646 A:middle
In the original mutating
algorithm, we only walked

00:12:11.646 --> 00:12:14.936 A:middle
over the multiples of the prime
number and those, of course,

00:12:14.936 --> 00:12:16.536 A:middle
become increasingly
sparse as you get

00:12:16.536 --> 00:12:17.866 A:middle
to bigger and bigger numbers.

00:12:18.016 --> 00:12:20.926 A:middle
So you are visiting fewer
elements, and moreover,

00:12:20.926 --> 00:12:23.316 A:middle
you only have to do an addition
to the get to the next element.

00:12:23.316 --> 00:12:26.216 A:middle
So you are doing less
work per element.

00:12:26.726 --> 00:12:27.606 A:middle
That matters.

00:12:28.386 --> 00:12:30.596 A:middle
And the nonmutating
version is not as efficient

00:12:30.596 --> 00:12:32.986 A:middle
as the mutating version
without a whole ton of work.

00:12:33.586 --> 00:12:35.806 A:middle
Let's bring it back to Cocoa.

00:12:36.816 --> 00:12:39.786 A:middle
So you see uses of
immutability in the Cocoa,

00:12:39.786 --> 00:12:40.946 A:middle
Cocoa Touch frameworks.

00:12:41.436 --> 00:12:42.086 A:middle
There's a lot of them.

00:12:42.086 --> 00:12:44.436 A:middle
And that's Date, UI
image, NSNumber, and so on.

00:12:44.656 --> 00:12:45.886 A:middle
These are immutable types,

00:12:46.106 --> 00:12:48.606 A:middle
and having these immutable
types improves safety.

00:12:48.836 --> 00:12:50.176 A:middle
It's a good thing
because you don't have

00:12:50.176 --> 00:12:51.046 A:middle
to worrying about copying.

00:12:51.366 --> 00:12:52.026 A:middle
You don't have to worry

00:12:52.026 --> 00:12:54.576 A:middle
about your sharing having
unintended side effects.

00:12:55.536 --> 00:12:58.126 A:middle
But you also see the downsides
there when you work with it.

00:12:58.186 --> 00:13:00.816 A:middle
I gave myself a little
task in Objective-C.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.186 --> 00:13:00.816 A:middle
I gave myself a little
task in Objective-C.

00:13:01.206 --> 00:13:05.026 A:middle
I want to create an NSURL by
starting with my home directory

00:13:05.026 --> 00:13:07.616 A:middle
and adding successive
path components

00:13:07.906 --> 00:13:08.956 A:middle
to get to some directory.

00:13:09.836 --> 00:13:11.406 A:middle
And I wanted to do it
without the mutation

00:13:11.406 --> 00:13:12.646 A:middle
in the reference semantic world.

00:13:13.066 --> 00:13:14.776 A:middle
So I created an NSURL.

00:13:15.246 --> 00:13:17.846 A:middle
Each time through the
loop, I create a new URL

00:13:17.846 --> 00:13:19.566 A:middle
by appending the
next path component.

00:13:20.506 --> 00:13:22.006 A:middle
This is not a great
algorithm, really.

00:13:22.706 --> 00:13:25.556 A:middle
Every time through, I'm creating
an NSURL, another object,

00:13:25.646 --> 00:13:31.676 A:middle
the old one goes away, and then
the NSURL is going to copy all

00:13:31.676 --> 00:13:33.906 A:middle
of the string data each
time through the loop.

00:13:34.456 --> 00:13:36.736 A:middle
Not very efficient there.

00:13:37.086 --> 00:13:38.976 A:middle
Doug, you are holding it wrong.

00:13:39.216 --> 00:13:41.246 A:middle
Really you should be
collecting all these components

00:13:41.626 --> 00:13:45.346 A:middle
into an NSArray and then use
file URL with path components.

00:13:46.636 --> 00:13:49.536 A:middle
Fine. But, remember, we are
embracing immutability here.

00:13:50.556 --> 00:13:53.266 A:middle
So when I create my array,
I will create an NSArray

00:13:53.646 --> 00:13:55.226 A:middle
with a particular
object, all right,

00:13:55.226 --> 00:13:56.106 A:middle
that's the home directory.

00:13:56.516 --> 00:13:59.066 A:middle
Each time through, I
create a new array,

00:13:59.626 --> 00:14:00.886 A:middle
adding one more object.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.626 --> 00:14:00.886 A:middle
adding one more object.

00:14:01.356 --> 00:14:02.456 A:middle
I'm still quadratic.

00:14:03.026 --> 00:14:04.376 A:middle
I'm still copying the elements.

00:14:04.376 --> 00:14:05.486 A:middle
I'm not copying the string data.

00:14:05.486 --> 00:14:06.396 A:middle
So it's a little better.

00:14:06.696 --> 00:14:07.866 A:middle
I'm still copying the elements.

00:14:08.206 --> 00:14:11.726 A:middle
This is why we don't
fully embrace immutability

00:14:11.726 --> 00:14:13.726 A:middle
in the world of Cocoa
because it doesn't make sense.

00:14:13.726 --> 00:14:15.596 A:middle
Instead, you use mutability

00:14:16.096 --> 00:14:18.606 A:middle
in more localized places
where it makes sense.

00:14:19.096 --> 00:14:22.336 A:middle
Collect all of your components
into an NSMutable array.

00:14:22.946 --> 00:14:25.786 A:middle
Then use file URL with
path components to get back

00:14:25.786 --> 00:14:28.046 A:middle
to that immutable NSURL.

00:14:29.336 --> 00:14:31.806 A:middle
So immutability is a good thing.

00:14:31.846 --> 00:14:34.606 A:middle
It makes the reference semantic
world easier to reason about.

00:14:35.296 --> 00:14:38.006 A:middle
But you can't go
completely to immutability

00:14:38.296 --> 00:14:39.486 A:middle
or you start to go crazy.

00:14:39.886 --> 00:14:43.236 A:middle
So that brings us
to value semantics.

00:14:44.216 --> 00:14:46.076 A:middle
With value semantics, we
take a different approach.

00:14:46.566 --> 00:14:47.446 A:middle
We like mutation.

00:14:47.866 --> 00:14:48.626 A:middle
We think it's valuable.

00:14:48.626 --> 00:14:51.466 A:middle
We think it's easy to
use when done correctly.

00:14:52.146 --> 00:14:55.486 A:middle
The problem, as we see
it, is the sharing.

00:14:56.936 --> 00:14:59.906 A:middle
So you already know how value
semantics work and you demand

00:14:59.906 --> 00:15:03.976 A:middle
on it all the time, whether you
are in Objective-C or in Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.906 --> 00:15:03.976 A:middle
on it all the time, whether you
are in Objective-C or in Swift.

00:15:04.046 --> 00:15:05.976 A:middle
The idea is simple: if
you have two variables,

00:15:06.506 --> 00:15:09.056 A:middle
the values in those variables
are logically distinct.

00:15:10.416 --> 00:15:13.916 A:middle
So I have an integer A, I
copy it over to an integer B.

00:15:14.156 --> 00:15:16.466 A:middle
Of course they are
equivalent; it's a copy.

00:15:16.886 --> 00:15:18.876 A:middle
I go to mutate B.

00:15:19.626 --> 00:15:22.686 A:middle
If I told you that would change
A, you would say I'm crazy.

00:15:24.126 --> 00:15:24.896 A:middle
These are integers.

00:15:25.096 --> 00:15:26.146 A:middle
They have value semantics

00:15:26.146 --> 00:15:29.406 A:middle
in every language we
have ever worked with.

00:15:29.616 --> 00:15:31.176 A:middle
Go to CGPoint, for example.

00:15:32.916 --> 00:15:36.566 A:middle
Copy from A to B,
mutate B, it's not going

00:15:36.566 --> 00:15:37.956 A:middle
to have any effect on A.

00:15:38.936 --> 00:15:41.106 A:middle
You are used to this.

00:15:41.106 --> 00:15:42.606 A:middle
If CGPoint didn't
behave this way,

00:15:42.606 --> 00:15:44.386 A:middle
you would be really,
really surprised.

00:15:46.496 --> 00:15:50.276 A:middle
The idea of value semantics is
take this thing we already know

00:15:50.276 --> 00:15:53.636 A:middle
and understand for the very
fundamental types, like numbers

00:15:53.636 --> 00:15:57.126 A:middle
and small structs containing
numbers, and extend it outward

00:15:57.976 --> 00:16:00.456 A:middle
to work with much,
much richer types.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:57.976 --> 00:16:00.456 A:middle
to work with much,
much richer types.

00:16:00.516 --> 00:16:02.836 A:middle
So in Swift, strings
are value types.

00:16:03.526 --> 00:16:07.216 A:middle
You create A, copy from B
to A, go ahead and change B

00:16:07.216 --> 00:16:09.516 A:middle
in some way, it won't
have any effect on A.

00:16:10.756 --> 00:16:11.706 A:middle
Because it's a value type.

00:16:11.706 --> 00:16:13.746 A:middle
A and B are different variables.

00:16:13.836 --> 00:16:15.306 A:middle
Therefore, they are
logically distinct.

00:16:18.026 --> 00:16:22.256 A:middle
Okay? Why shouldn't the arrays
behave exactly the same way?

00:16:23.666 --> 00:16:26.206 A:middle
Create A, copy it
over to B, mutate B.

00:16:26.206 --> 00:16:27.186 A:middle
It has no effect on A.

00:16:27.186 --> 00:16:29.876 A:middle
They are completely
distinct values.

00:16:31.976 --> 00:16:33.826 A:middle
Last one, well, dictionaries,
of course.

00:16:33.886 --> 00:16:34.846 A:middle
It's just a collection.

00:16:35.396 --> 00:16:37.036 A:middle
You put value semantic
things into it,

00:16:37.736 --> 00:16:38.886 A:middle
you get value semantics back.

00:16:39.586 --> 00:16:43.316 A:middle
The great thing here is that
value types compose beautifully.

00:16:43.676 --> 00:16:46.856 A:middle
So you can build up very rich
abstractions all in the world

00:16:46.856 --> 00:16:48.416 A:middle
of value semantics easily.

00:16:49.106 --> 00:16:52.396 A:middle
So in Swift, all the fundamental
types -- integers, doubles,

00:16:52.466 --> 00:16:55.686 A:middle
strings, characters, et cetera
-- they are all value types.

00:16:55.686 --> 00:16:57.316 A:middle
They have this fundamental
behavior,

00:16:57.316 --> 00:16:59.036 A:middle
the two variables are
logically distinct.

00:16:59.806 --> 00:17:02.056 A:middle
All the collections we
build on top of them --


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.806 --> 00:17:02.056 A:middle
All the collections we
build on top of them --

00:17:02.056 --> 00:17:03.436 A:middle
array, set, dictionary --

00:17:03.926 --> 00:17:06.246 A:middle
are value types when
they're given value types.

00:17:06.736 --> 00:17:09.366 A:middle
And the language
abstractions you use

00:17:09.366 --> 00:17:12.576 A:middle
to build your own types --
tuples, structs, and enums --

00:17:12.886 --> 00:17:15.806 A:middle
when you put value types into
those, you get value types out.

00:17:16.156 --> 00:17:20.516 A:middle
Again, it's very, very easy
to build rich abstractions all

00:17:20.516 --> 00:17:21.796 A:middle
in the world of value semantics.

00:17:22.836 --> 00:17:25.746 A:middle
Now, there's one more
critical piece to a value type,

00:17:26.296 --> 00:17:30.076 A:middle
and that is that you have the
notion of when two values,

00:17:30.076 --> 00:17:32.506 A:middle
two variables of value
type, are equivalent.

00:17:32.626 --> 00:17:33.846 A:middle
They hold the same value.

00:17:33.846 --> 00:17:37.916 A:middle
And the important thing is that
identity is not what matters.

00:17:38.826 --> 00:17:40.226 A:middle
Because you can have
any number of copies.

00:17:40.226 --> 00:17:42.426 A:middle
What matters is the actual
value that's stored there.

00:17:42.426 --> 00:17:44.826 A:middle
It doesn't matter how
you got to that value.

00:17:45.226 --> 00:17:47.536 A:middle
I will tell you things that
are really, really silly.

00:17:48.376 --> 00:17:50.506 A:middle
Here we have A, we set
it to 5, and we have B

00:17:50.506 --> 00:17:51.806 A:middle
and we set it to 2 plus 3.

00:17:52.646 --> 00:17:54.276 A:middle
Of course A and B
are equivalent.

00:17:55.376 --> 00:17:56.376 A:middle
You work with this all the time.

00:17:56.376 --> 00:17:58.896 A:middle
You couldn't understand integers
if they didn't work this way.

00:17:59.516 --> 00:18:01.726 A:middle
So just extend that notion out.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.516 --> 00:18:01.726 A:middle
So just extend that notion out.

00:18:02.296 --> 00:18:04.196 A:middle
Of course it's the same
thing for CGPoints,

00:18:04.196 --> 00:18:05.146 A:middle
you wouldn't be able
to understand them

00:18:05.146 --> 00:18:05.956 A:middle
if it wasn't this way.

00:18:07.276 --> 00:18:09.696 A:middle
Why shouldn't strings
behave exactly the same way?

00:18:09.696 --> 00:18:13.466 A:middle
It doesn't matter how I get
to the string "Hello, WWDC."

00:18:14.576 --> 00:18:17.526 A:middle
The string is the value, and
the equality operator needs

00:18:17.526 --> 00:18:18.316 A:middle
to represent that.

00:18:19.206 --> 00:18:21.736 A:middle
You can make this
arbitrarily crazy and stupid.

00:18:21.736 --> 00:18:24.456 A:middle
So here I will go and do
some sorting operation.

00:18:25.086 --> 00:18:26.596 A:middle
What it comes down to though
is that I have two arrays

00:18:26.596 --> 00:18:28.816 A:middle
of integers, the integers
have the same values.

00:18:29.196 --> 00:18:30.596 A:middle
Therefore, these
things are equivalent.

00:18:31.566 --> 00:18:35.336 A:middle
When you're building a value
type, it's extremely important

00:18:35.946 --> 00:18:37.756 A:middle
that it conform to the
Equatable protocol.

00:18:37.756 --> 00:18:41.076 A:middle
Because every value type out
there should be equatable.

00:18:41.726 --> 00:18:44.156 A:middle
That means it has the
equal equal operator

00:18:44.316 --> 00:18:46.586 A:middle
to do a comparison,
but that operator has

00:18:46.586 --> 00:18:48.266 A:middle
to behave in a sensible way.

00:18:48.266 --> 00:18:50.946 A:middle
It needs to be reflexive,
symmetric, and transitive.

00:18:51.626 --> 00:18:53.016 A:middle
Why are these properties
important?

00:18:53.016 --> 00:18:55.716 A:middle
Because you can't understand
your code unless you have them.

00:18:56.676 --> 00:19:00.346 A:middle
If I copy from A to B, well,
I expect that A is equal


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:56.676 --> 00:19:00.346 A:middle
If I copy from A to B, well,
I expect that A is equal

00:19:00.346 --> 00:19:01.626 A:middle
to B and B is equal to A.

00:19:01.846 --> 00:19:02.346 A:middle
Of course.

00:19:02.346 --> 00:19:03.056 A:middle
Why wouldn't it be?

00:19:03.516 --> 00:19:06.186 A:middle
If I then copy B over to
C, well then C and B and A,

00:19:06.186 --> 00:19:06.916 A:middle
they're all equivalent.

00:19:06.916 --> 00:19:08.926 A:middle
It doesn't matter which I
have because the only thing

00:19:08.926 --> 00:19:11.206 A:middle
that matters there is the
value, not the identity.

00:19:12.416 --> 00:19:15.396 A:middle
Fortunately, it's very, very
easy to implement these things.

00:19:15.816 --> 00:19:20.066 A:middle
I can just say, take CGPoints
and extend it with Equatable

00:19:20.066 --> 00:19:21.516 A:middle
and implement the
equality operator,

00:19:21.706 --> 00:19:24.136 A:middle
and when you compose value
types out of other value types,

00:19:24.246 --> 00:19:26.576 A:middle
generally speaking,
you just have

00:19:26.666 --> 00:19:29.126 A:middle
to use the underlying
equal, equal operators

00:19:29.126 --> 00:19:30.046 A:middle
of all the value types.

00:19:30.556 --> 00:19:32.036 A:middle
All right.

00:19:32.256 --> 00:19:34.536 A:middle
Let's bring this back
to our temperature type.

00:19:34.766 --> 00:19:36.396 A:middle
We will make it a struct now.

00:19:36.396 --> 00:19:38.176 A:middle
We are going to switch
Celsius back

00:19:38.176 --> 00:19:40.406 A:middle
to a var to we can mutate it.

00:19:41.166 --> 00:19:42.556 A:middle
This now has value semantics.

00:19:42.556 --> 00:19:44.286 A:middle
We give it the obvious
equality operator.

00:19:44.856 --> 00:19:46.936 A:middle
We go ahead and use this
in our example before.

00:19:47.256 --> 00:19:47.706 A:middle
That's fine.

00:19:47.706 --> 00:19:49.896 A:middle
We create the home, create the
temperature, set the temperature

00:19:49.896 --> 00:19:52.406 A:middle
to 75 degrees Fahrenheit
and whoa!

00:19:52.756 --> 00:19:53.876 A:middle
Compiler stops us here.

00:19:54.146 --> 00:19:54.826 A:middle
What went on?

00:19:55.716 --> 00:19:59.236 A:middle
Well, we are trying to
mutate a property of temp,

00:19:59.476 --> 00:20:00.556 A:middle
which is describes as a let.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.476 --> 00:20:00.556 A:middle
which is describes as a let.

00:20:00.556 --> 00:20:01.726 A:middle
It's a constant.

00:20:01.786 --> 00:20:02.386 A:middle
It can't change.

00:20:03.076 --> 00:20:04.236 A:middle
We will appease the compiler.

00:20:04.606 --> 00:20:06.116 A:middle
Change it to var, and
now we can mutate it.

00:20:06.626 --> 00:20:08.326 A:middle
And this all works
perfectly fine.

00:20:09.606 --> 00:20:10.396 A:middle
Why is it fine?

00:20:10.396 --> 00:20:12.776 A:middle
Well, the house points out to
the thermostat in the oven.

00:20:12.776 --> 00:20:16.076 A:middle
The thermostat and the oven
both have their own instances

00:20:16.076 --> 00:20:17.336 A:middle
of temperature values.

00:20:17.336 --> 00:20:19.406 A:middle
They are completely distinct,
they're never shared.

00:20:20.086 --> 00:20:21.676 A:middle
They also happen to be
inlined into the struct,

00:20:21.676 --> 00:20:23.656 A:middle
and you are getting better
memory usage and performance.

00:20:24.856 --> 00:20:25.656 A:middle
This is great.

00:20:25.656 --> 00:20:27.966 A:middle
Value semantics have made
our lives easier here.

00:20:28.646 --> 00:20:31.346 A:middle
With our example,
let's go all the way

00:20:31.436 --> 00:20:33.456 A:middle
and make everything
value semantics.

00:20:34.976 --> 00:20:37.366 A:middle
Now, house is a struct that
has a thermostat struct

00:20:37.366 --> 00:20:39.906 A:middle
and an oven struct, and the
whole world is value semantics.

00:20:40.146 --> 00:20:40.956 A:middle
The changes we need to make

00:20:40.956 --> 00:20:45.256 A:middle
to our code is now home can be
mutated because we can go ahead

00:20:45.556 --> 00:20:48.086 A:middle
and change the temperature on
the thermostat of the home,

00:20:48.496 --> 00:20:49.846 A:middle
right, and that's
a mutation to home

00:20:49.846 --> 00:20:51.446 A:middle
and thermostat and
to temperature.

00:20:51.936 --> 00:20:57.126 A:middle
Okay. This brings us to
a really important point.

00:20:57.586 --> 00:21:00.836 A:middle
Value semantics works
beautifully in Swift


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:57.586 --> 00:21:00.836 A:middle
Value semantics works
beautifully in Swift

00:21:01.226 --> 00:21:04.356 A:middle
because of the way Swift's
immutability model works.

00:21:05.006 --> 00:21:08.276 A:middle
When you have a let in
Swift, it's of a value type.

00:21:08.746 --> 00:21:12.526 A:middle
It means this value
will never change short

00:21:12.526 --> 00:21:14.576 A:middle
of something corrupting
your process' memory.

00:21:15.086 --> 00:21:18.446 A:middle
This is a really
strong statement.

00:21:19.196 --> 00:21:20.546 A:middle
It means it's very
easy to reason

00:21:20.546 --> 00:21:21.566 A:middle
about things that are let.

00:21:22.356 --> 00:21:24.216 A:middle
But we still allow mutation.

00:21:24.396 --> 00:21:27.386 A:middle
You can use var to say this
variable can be changed.

00:21:27.896 --> 00:21:30.016 A:middle
And that's extremely
useful for our algorithms.

00:21:31.316 --> 00:21:33.286 A:middle
Note that this change
is very local.

00:21:33.466 --> 00:21:36.006 A:middle
I can change this
variable, but it's not going

00:21:36.006 --> 00:21:38.426 A:middle
to affect anything else
anywhere in my program

00:21:38.646 --> 00:21:41.236 A:middle
until I tell it to, until I
do a mutation somewhere else,

00:21:41.806 --> 00:21:44.896 A:middle
which gives you this really
nice controlled mutability.

00:21:45.446 --> 00:21:47.776 A:middle
With strong guarantees
elsewhere.

00:21:49.016 --> 00:21:51.696 A:middle
One of the nice things here is
when you are using value types

00:21:51.696 --> 00:21:54.476 A:middle
of passing them across thread
boundaries, it gives you freedom

00:21:54.476 --> 00:21:56.696 A:middle
from race conditions
on those types.

00:21:57.166 --> 00:21:58.086 A:middle
So I create numbers.

00:21:58.086 --> 00:21:59.816 A:middle
I passed them off
to some process

00:21:59.816 --> 00:22:01.586 A:middle
that will do something
asynchronously.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.816 --> 00:22:01.586 A:middle
that will do something
asynchronously.

00:22:02.156 --> 00:22:04.156 A:middle
I mutate numbers locally
and then do it again.

00:22:04.596 --> 00:22:08.646 A:middle
With a reference semantic
array, this is a race condition.

00:22:08.646 --> 00:22:10.356 A:middle
It's going to blow
up on you sometime.

00:22:10.636 --> 00:22:13.226 A:middle
With value semantics, you
are getting copies each time,

00:22:13.786 --> 00:22:14.916 A:middle
logical copies each time.

00:22:16.086 --> 00:22:17.746 A:middle
And therefore, there
is no race condition.

00:22:18.366 --> 00:22:19.576 A:middle
They are not hitting
the same array.

00:22:19.576 --> 00:22:21.616 A:middle
All right.

00:22:21.616 --> 00:22:23.926 A:middle
Hold on. This sounds like a
performance problem, right?

00:22:24.256 --> 00:22:26.816 A:middle
We are doing a copy every
time we pass numbers

00:22:26.816 --> 00:22:27.606 A:middle
through a parameter.

00:22:28.846 --> 00:22:32.916 A:middle
Okay. One of the important other
pieces of value semantics is

00:22:32.916 --> 00:22:34.396 A:middle
that it copies are cheap.

00:22:34.876 --> 00:22:37.456 A:middle
By cheap, I mean
constant time cheap.

00:22:37.886 --> 00:22:40.886 A:middle
Let's build this up
from fundamentals.

00:22:40.886 --> 00:22:42.556 A:middle
So when you have the
fundamental types,

00:22:42.556 --> 00:22:45.106 A:middle
the really low-level things
-- integers, doubles, floats,

00:22:45.106 --> 00:22:48.176 A:middle
et cetera -- copying
these is cheap.

00:22:48.236 --> 00:22:49.656 A:middle
You are copying a
couple of bytes.

00:22:49.836 --> 00:22:51.646 A:middle
Usually it happens
in the processor.

00:22:52.986 --> 00:22:55.126 A:middle
So then you start
building structs

00:22:55.126 --> 00:22:57.206 A:middle
out of doubles and
ints and so on.

00:22:57.236 --> 00:22:59.676 A:middle
Like CG points is
built of two CG floats.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:00.166 --> 00:23:02.526 A:middle
And any of these
structs, enums or tuples,

00:23:02.526 --> 00:23:06.246 A:middle
they have a fixed number
of fields, and copying each

00:23:06.246 --> 00:23:08.096 A:middle
of the things in there
is constant time.

00:23:08.096 --> 00:23:10.336 A:middle
So copying the whole
thing is constant time.

00:23:10.896 --> 00:23:12.396 A:middle
All right.

00:23:13.376 --> 00:23:14.776 A:middle
That's great for
fixed-length things.

00:23:14.776 --> 00:23:17.396 A:middle
What about extensible
things, strings, arrays,

00:23:17.396 --> 00:23:18.546 A:middle
dictionaries, and so on?

00:23:19.086 --> 00:23:21.816 A:middle
The way we handle these in the
Swift world is by copy-on-write.

00:23:22.836 --> 00:23:24.466 A:middle
So this makes the copy cheap.

00:23:24.676 --> 00:23:27.226 A:middle
It's just some fixed number of
reference-counting operations

00:23:27.226 --> 00:23:29.596 A:middle
to do a copy of a
copy-on-write value.

00:23:29.596 --> 00:23:32.746 A:middle
And then at the point where you
do a mutation, you have a var

00:23:32.746 --> 00:23:35.196 A:middle
and then you change
it, then we make a copy

00:23:35.196 --> 00:23:36.066 A:middle
and work on the copy.

00:23:36.836 --> 00:23:39.306 A:middle
So you have sharing
behind the scenes,

00:23:40.666 --> 00:23:42.646 A:middle
but it's not logical sharing

00:23:42.646 --> 00:23:45.006 A:middle
but logically these are
still distinct values.

00:23:45.226 --> 00:23:47.146 A:middle
This gives you great
performance characteristics

00:23:47.416 --> 00:23:50.676 A:middle
from value semantics and is
really a nice programming model.

00:23:51.576 --> 00:23:53.606 A:middle
So we really love the value
semantic programming model.

00:23:54.266 --> 00:23:57.166 A:middle
Different variables are
logically distinct, always.

00:23:58.506 --> 00:24:01.566 A:middle
You have the notion of
mutation, an efficient mutation,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.506 --> 00:24:01.566 A:middle
You have the notion of
mutation, an efficient mutation,

00:24:01.826 --> 00:24:04.036 A:middle
when you want it
locally controlled.

00:24:05.416 --> 00:24:07.216 A:middle
But you have these
strong guarantees of let,

00:24:07.216 --> 00:24:08.726 A:middle
meaning it will not
change elsewhere.

00:24:09.736 --> 00:24:11.936 A:middle
And copies are cheap, which
makes us all work together.

00:24:13.256 --> 00:24:13.596 A:middle
All right.

00:24:13.626 --> 00:24:15.716 A:middle
With that, I would like to
hand it over to my colleague,

00:24:15.716 --> 00:24:18.476 A:middle
Bill Dudney, who will talk
about value types and practice.

00:24:19.516 --> 00:24:25.996 A:middle
[ Applause ]

00:24:26.496 --> 00:24:27.006 A:middle
&gt;&gt; BILL DUDNEY: Thanks, Doug.

00:24:27.876 --> 00:24:28.536 A:middle
Hi, everybody.

00:24:28.536 --> 00:24:31.726 A:middle
So now that Doug has filled our
minds with how value types work,

00:24:32.056 --> 00:24:34.536 A:middle
how they compare with
reference semantics,

00:24:34.636 --> 00:24:38.596 A:middle
let's talk about building a real
example that uses value types.

00:24:38.596 --> 00:24:42.636 A:middle
So what we are going to do
is put together an example

00:24:42.636 --> 00:24:44.936 A:middle
where we build a
simple diagram made

00:24:44.936 --> 00:24:48.306 A:middle
of a couple odifferent value
types, a circle and a polygon.

00:24:49.386 --> 00:24:51.406 A:middle
So we will get started
with the circle.

00:24:51.916 --> 00:24:54.236 A:middle
It's a center, and a radius.

00:24:54.306 --> 00:24:56.056 A:middle
A couple of value types
that come straight

00:24:56.056 --> 00:24:57.246 A:middle
out of the standard library.

00:24:57.856 --> 00:25:00.766 A:middle
Of course, we want to
implement the equality operator,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.856 --> 00:25:00.766 A:middle
Of course, we want to
implement the equality operator,

00:25:00.766 --> 00:25:02.086 A:middle
the equals equals operator,

00:25:02.086 --> 00:25:04.496 A:middle
and we do that by just
comparing those types.

00:25:04.496 --> 00:25:06.756 A:middle
Again, since they are built
into the standard library,

00:25:07.056 --> 00:25:09.746 A:middle
all we have to do is use
those since we are composing

00:25:09.746 --> 00:25:11.806 A:middle
from the simple types that
came out of the library.

00:25:12.326 --> 00:25:14.676 A:middle
Next up is the polygon.

00:25:15.066 --> 00:25:16.906 A:middle
It has an array of corners,

00:25:17.116 --> 00:25:19.836 A:middle
and each of the corners is
just another CG point, which,

00:25:19.836 --> 00:25:20.916 A:middle
again, is a value type.

00:25:21.326 --> 00:25:23.986 A:middle
So our array is a
value type, and, again,

00:25:23.986 --> 00:25:25.606 A:middle
our comparison is
straightforward,

00:25:25.726 --> 00:25:27.676 A:middle
just using the equals,
equals operator there

00:25:27.676 --> 00:25:29.896 A:middle
to make sure we implement
the Equatable operator.

00:25:29.896 --> 00:25:36.296 A:middle
Now what we want to do is put
these types into our diagram,

00:25:36.656 --> 00:25:39.116 A:middle
put both polygons and circles.

00:25:40.376 --> 00:25:42.526 A:middle
Making an array of
circles is straightforward.

00:25:43.506 --> 00:25:46.876 A:middle
Making an array of
polygons is straightforward.

00:25:46.876 --> 00:25:49.536 A:middle
So we can make an
array of either type.

00:25:49.536 --> 00:25:53.376 A:middle
What we need to do is make
one array that contains both.

00:25:54.006 --> 00:25:59.476 A:middle
The mechanism to do that in
Swift is with a protocol.

00:25:59.476 --> 00:26:02.176 A:middle
So we will create a
protocol called Drawable.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.476 --> 00:26:02.176 A:middle
So we will create a
protocol called Drawable.

00:26:02.176 --> 00:26:05.416 A:middle
We will make both of
our subtypes implement

00:26:05.416 --> 00:26:07.516 A:middle
that protocol, and
then we can put them

00:26:07.516 --> 00:26:09.286 A:middle
into an array in our diagram.

00:26:10.816 --> 00:26:12.046 A:middle
Tons of great information

00:26:12.046 --> 00:26:14.916 A:middle
in this Protocol-Oriented
Programming in Swift talk,

00:26:14.916 --> 00:26:17.726 A:middle
which is repeating
again today at 3:30.

00:26:18.066 --> 00:26:19.096 A:middle
So if you haven't seen that,

00:26:19.096 --> 00:26:21.396 A:middle
I would highly suggest
you take a look

00:26:21.396 --> 00:26:23.166 A:middle
at it or catch it on video.

00:26:24.086 --> 00:26:27.526 A:middle
So here's our Drawable protocol.

00:26:27.816 --> 00:26:31.686 A:middle
Straightforward and simple,
has one method, Draw, on it.

00:26:32.276 --> 00:26:34.596 A:middle
And, of course, we want to
implement that on our two types.

00:26:34.596 --> 00:26:36.466 A:middle
We will create an
extension of polygon,

00:26:36.826 --> 00:26:39.176 A:middle
implement that draw method,
and that's just going to call

00:26:39.176 --> 00:26:41.216 A:middle
out to Core Graphics
and draw the polygon.

00:26:41.876 --> 00:26:44.496 A:middle
And the same thing
for the circle.

00:26:44.496 --> 00:26:47.276 A:middle
So what we are going to do,
just call Core Graphics to build

00:26:47.276 --> 00:26:49.316 A:middle
up the representation
of the circle.

00:26:49.316 --> 00:26:55.626 A:middle
Now back to out diagram.

00:26:55.626 --> 00:26:58.056 A:middle
It's got this array of
drawables called Items.

00:26:58.886 --> 00:27:00.756 A:middle
We need to create a
method to add items.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.886 --> 00:27:00.756 A:middle
We need to create a
method to add items.

00:27:00.926 --> 00:27:03.436 A:middle
That's marked as mutating
because that mutates self.

00:27:03.436 --> 00:27:08.096 A:middle
We are going to implement the
Draw method to simply iterate

00:27:08.096 --> 00:27:10.296 A:middle
through that list of items
and call the Draw method

00:27:10.296 --> 00:27:11.856 A:middle
on each item that's in the list.

00:27:13.176 --> 00:27:15.056 A:middle
So let's take a look
at it diagrammatically.

00:27:15.836 --> 00:27:18.806 A:middle
So we create a diagram,
called doc.

00:27:19.766 --> 00:27:21.876 A:middle
We create a polygon and
add that to the array.

00:27:23.426 --> 00:27:26.676 A:middle
We create another one, a circle,
and we add that to the array.

00:27:26.676 --> 00:27:28.696 A:middle
Now our array has
two drawables in it.

00:27:29.466 --> 00:27:30.806 A:middle
Notice they are different types.

00:27:31.386 --> 00:27:37.566 A:middle
When we create another document,
by saying doc2 equals doc,

00:27:37.716 --> 00:27:40.466 A:middle
we get a logically
distinct, brand-new instance.

00:27:40.466 --> 00:27:43.286 A:middle
It's logically separate
from that first instance.

00:27:45.076 --> 00:27:50.136 A:middle
I can go back and make changes
to doc2 now, and when I do that,

00:27:50.136 --> 00:27:52.326 A:middle
of course, it has
no effect on doc.

00:27:52.786 --> 00:27:54.696 A:middle
I change that circle
to a polygon.

00:27:55.756 --> 00:28:00.186 A:middle
The array has value semantics
even though the collection


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:55.756 --> 00:28:00.186 A:middle
The array has value semantics
even though the collection

00:28:00.186 --> 00:28:01.186 A:middle
is heterogeneous.

00:28:01.256 --> 00:28:05.976 A:middle
So it has the polygon inside,
and the circle is inside

00:28:05.976 --> 00:28:07.166 A:middle
that array as a value.

00:28:07.826 --> 00:28:15.516 A:middle
So, of course, we want to make
our diagram struct Equatable.

00:28:15.936 --> 00:28:17.506 A:middle
So we implement the protocol.

00:28:17.506 --> 00:28:19.486 A:middle
And this would be the
straightforward implementation

00:28:19.486 --> 00:28:20.486 A:middle
that we would look at doing.

00:28:21.176 --> 00:28:23.396 A:middle
However, if we would do that,
the compiler says, "Hey,

00:28:23.396 --> 00:28:26.846 A:middle
wait a minute, I don't have
an equals equals operator

00:28:27.066 --> 00:28:29.836 A:middle
for these two values on
either side of that equation."

00:28:30.166 --> 00:28:31.186 A:middle
Again, I will refer you

00:28:31.186 --> 00:28:33.056 A:middle
to the Protocol-Oriented
Programming talk,

00:28:33.056 --> 00:28:36.366 A:middle
where we talked through all the
details of how all that works.

00:28:36.526 --> 00:28:39.436 A:middle
In this talk, we will focus
on the value semantics.

00:28:39.966 --> 00:28:45.536 A:middle
So drawable has a single
method called Draw,

00:28:45.536 --> 00:28:48.286 A:middle
our diagram has a
method called Draw.

00:28:48.506 --> 00:28:51.586 A:middle
So let's go ahead and turn
our diagram into a drawable.

00:28:51.586 --> 00:28:54.516 A:middle
All we have to do is add
that declaration to it.

00:28:54.656 --> 00:28:59.046 A:middle
Now our diagram quacks
like a duck and is a duck.

00:28:59.736 --> 00:29:02.816 A:middle
So this brings us to
an interesting point.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.736 --> 00:29:02.816 A:middle
So this brings us to
an interesting point.

00:29:02.816 --> 00:29:08.866 A:middle
I can create a new diagram and
add it to my existing diagram.

00:29:09.946 --> 00:29:12.246 A:middle
It's got three different
types in there,

00:29:12.246 --> 00:29:15.166 A:middle
but they are all
contained inside that array.

00:29:16.016 --> 00:29:17.786 A:middle
It's a new instance of Diagram.

00:29:19.106 --> 00:29:21.246 A:middle
But I can push it
one further and add

00:29:21.246 --> 00:29:23.256 A:middle
that document to the array.

00:29:23.646 --> 00:29:25.536 A:middle
Now if this were
reference semantics --

00:29:26.416 --> 00:29:27.386 A:middle
let's look at the Draw method.

00:29:27.386 --> 00:29:28.996 A:middle
If this were reference
semantics,

00:29:29.386 --> 00:29:30.746 A:middle
this would infinite recurse.

00:29:31.326 --> 00:29:35.866 A:middle
As I call Draw on my diagram,
it will go through the list

00:29:35.866 --> 00:29:37.986 A:middle
of items and find
itself in that list.

00:29:37.986 --> 00:29:40.476 A:middle
And so it's going to call Draw
again and infinitely recurse.

00:29:41.146 --> 00:29:43.476 A:middle
But, we are using values.

00:29:43.776 --> 00:29:48.416 A:middle
So instead of the doc
being added to my diagram,

00:29:48.476 --> 00:29:49.866 A:middle
it's completely a separate

00:29:49.866 --> 00:29:53.156 A:middle
and distinct instance
because it's a value.

00:29:54.336 --> 00:29:55.986 A:middle
So there's no infinite
recursion.

00:29:56.246 --> 00:29:59.206 A:middle
I just get two polygons
and two circles drawn.

00:29:59.206 --> 00:30:05.146 A:middle
Now that we have talked
about building a tree


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.206 --> 00:30:05.146 A:middle
Now that we have talked
about building a tree

00:30:05.146 --> 00:30:06.976 A:middle
of objects purely
out of value types,

00:30:07.026 --> 00:30:10.186 A:middle
let's talk about how we mix
value types and reference types.

00:30:10.886 --> 00:30:12.256 A:middle
Now in Objective-C, you are used

00:30:12.256 --> 00:30:15.906 A:middle
to putting primitive data types
inside your reference types all

00:30:15.906 --> 00:30:16.286 A:middle
the time.

00:30:16.286 --> 00:30:18.186 A:middle
This is how we build
things in Objective-C.

00:30:19.286 --> 00:30:22.496 A:middle
But the flip side introduces
some interesting questions

00:30:22.496 --> 00:30:23.606 A:middle
that we have to think through.

00:30:25.226 --> 00:30:28.006 A:middle
If we are building a value
type, we want to make sure

00:30:28.006 --> 00:30:31.306 A:middle
that that value type
maintains its value semantics,

00:30:31.436 --> 00:30:33.926 A:middle
even though it has a
reference inside of it.

00:30:34.356 --> 00:30:35.826 A:middle
So if we are going to do that,

00:30:35.826 --> 00:30:37.386 A:middle
we have to think
about that question.

00:30:37.386 --> 00:30:39.376 A:middle
How do we deal with this fact

00:30:39.426 --> 00:30:44.026 A:middle
that two different values might
be pointing to the same thing

00:30:44.026 --> 00:30:45.126 A:middle
because it has a
reference in it?

00:30:45.126 --> 00:30:46.866 A:middle
So we have to solve
that question.

00:30:47.416 --> 00:30:48.426 A:middle
The other thing we have to think

00:30:48.426 --> 00:30:51.796 A:middle
through is how is
equality affected by that.

00:30:52.026 --> 00:30:53.786 A:middle
So let's start with
a simple example

00:30:53.786 --> 00:30:56.856 A:middle
with an immutable
class, UIImage.

00:30:57.456 --> 00:31:01.236 A:middle
We will create an image struct
that is going to be a drawable,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:57.456 --> 00:31:01.236 A:middle
We will create an image struct
that is going to be a drawable,

00:31:01.386 --> 00:31:03.326 A:middle
and it has a reference
to a UIImage.

00:31:03.856 --> 00:31:06.286 A:middle
So we create the instance

00:31:06.286 --> 00:31:08.666 A:middle
with this beautiful
photograph of San Francisco.

00:31:09.726 --> 00:31:13.596 A:middle
And if we create another
one, image 2, so now image

00:31:13.596 --> 00:31:16.696 A:middle
and image 2 are both
pointing to the same object.

00:31:17.206 --> 00:31:18.836 A:middle
And you look at this and
you think, Bill is going

00:31:18.836 --> 00:31:20.816 A:middle
to trick us, and this is going
to be a problem, and it will be

00:31:20.816 --> 00:31:21.936 A:middle
like the temperature thing.

00:31:22.436 --> 00:31:25.386 A:middle
But it's not because
UIImage is immutable.

00:31:25.716 --> 00:31:29.816 A:middle
So we don't have to worry about
image 2 mutating the image

00:31:29.816 --> 00:31:30.766 A:middle
that sits underneath it

00:31:30.806 --> 00:31:33.646 A:middle
and having the first
image be caught off guard

00:31:33.646 --> 00:31:34.486 A:middle
with that change.

00:31:35.736 --> 00:31:38.726 A:middle
Of course we want to make
sure we implement the equality

00:31:39.586 --> 00:31:41.796 A:middle
and at first blush, you might
look at this and think, okay,

00:31:41.796 --> 00:31:43.496 A:middle
I will use the triple
equals operator,

00:31:43.496 --> 00:31:46.366 A:middle
which will compare
the reference and see

00:31:46.366 --> 00:31:47.796 A:middle
if those references
are the same.

00:31:48.356 --> 00:31:51.846 A:middle
Well this would work okay in
this example, but we also have

00:31:51.846 --> 00:31:52.986 A:middle
to think through what happens

00:31:52.986 --> 00:31:57.766 A:middle
if we create two UI images using
the same underlying bitmap.

00:31:58.526 --> 00:32:02.596 A:middle
We want those also to equate to
being equal, and in this case,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.526 --> 00:32:02.596 A:middle
We want those also to equate to
being equal, and in this case,

00:32:02.596 --> 00:32:05.036 A:middle
since we are comparing the
reference, they would not.

00:32:05.036 --> 00:32:06.606 A:middle
So this would be falsely saying

00:32:06.606 --> 00:32:08.746 A:middle
that these two images
are not the same.

00:32:09.236 --> 00:32:12.386 A:middle
So instead what we want to
do is use the Is Equal method

00:32:12.896 --> 00:32:16.116 A:middle
that we inherit from NSObject
on UIImage to do the comparison,

00:32:16.416 --> 00:32:19.056 A:middle
so we'll be sure that the
reference type gets the right

00:32:19.546 --> 00:32:25.206 A:middle
answer on whether or not
it's the same object or not.

00:32:25.206 --> 00:32:27.666 A:middle
Let's talk about
using mutable objects.

00:32:28.226 --> 00:32:30.266 A:middle
We have a BezierPath here.

00:32:31.366 --> 00:32:32.956 A:middle
It also implements Drawable.

00:32:33.526 --> 00:32:35.226 A:middle
But its entire implementation
is made

00:32:35.226 --> 00:32:37.676 A:middle
up by this mutable
reference type, UIBezierPath.

00:32:37.676 --> 00:32:42.706 A:middle
In the reading case, when
we're doing Is Empty,

00:32:42.776 --> 00:32:43.726 A:middle
everything is okay.

00:32:43.726 --> 00:32:45.886 A:middle
We are not doing any
mutation, so we're not going

00:32:45.886 --> 00:32:48.386 A:middle
to mess any other instances up.

00:32:49.066 --> 00:32:52.146 A:middle
But on this one below, we have
this Add Line To Point method,

00:32:52.456 --> 00:32:54.966 A:middle
and if we have two
BezierPaths pointing to that,

00:32:55.316 --> 00:32:56.616 A:middle
it will cause problems.

00:32:57.436 --> 00:33:00.716 A:middle
Also notice here, we don't have
the Mutating keyword there.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.436 --> 00:33:00.716 A:middle
Also notice here, we don't have
the Mutating keyword there.

00:33:01.416 --> 00:33:04.636 A:middle
That's a sign that we know we
are mutating because Add Line

00:33:04.636 --> 00:33:06.746 A:middle
To Point is there, but the
compiler is not yelling

00:33:06.746 --> 00:33:07.326 A:middle
at us about it.

00:33:07.526 --> 00:33:09.346 A:middle
That's because path
is a reference type.

00:33:09.346 --> 00:33:11.566 A:middle
We will look at that
again in just a moment.

00:33:12.656 --> 00:33:16.766 A:middle
So if I have two instances
of BezierPath, both pointing

00:33:16.766 --> 00:33:18.866 A:middle
to the same instance
of UIBezierPath

00:33:18.866 --> 00:33:22.346 A:middle
through this reference, and I
make this mutation, that's going

00:33:22.346 --> 00:33:24.026 A:middle
to catch the other
one off guard.

00:33:24.026 --> 00:33:25.666 A:middle
This is a bad situation.

00:33:25.666 --> 00:33:27.786 A:middle
We are not maintaining
value semantics.

00:33:28.186 --> 00:33:29.726 A:middle
We need to fix that.

00:33:30.356 --> 00:33:33.226 A:middle
The way we will fix that
is use copy-on-write,

00:33:33.876 --> 00:33:37.446 A:middle
and we want to make sure that
before we write to that path,

00:33:37.446 --> 00:33:39.466 A:middle
that we make a copy of it.

00:33:40.656 --> 00:33:42.846 A:middle
So to do that, we need
to introduce a couple

00:33:42.846 --> 00:33:44.826 A:middle
of new things to our BezierPath.

00:33:44.956 --> 00:33:48.936 A:middle
First, we want to make
our path instance private,

00:33:49.506 --> 00:33:52.516 A:middle
and next we want to implement
this computed path property

00:33:52.956 --> 00:33:55.396 A:middle
for reading and from there
we will return our private

00:33:55.396 --> 00:33:56.196 A:middle
instance variable.

00:33:56.756 --> 00:33:59.026 A:middle
And we want to make a path

00:33:59.406 --> 00:34:02.776 A:middle
for writing computed property
that's marked as mutating,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.406 --> 00:34:02.776 A:middle
for writing computed property
that's marked as mutating,

00:34:03.096 --> 00:34:04.926 A:middle
and that's going to, in
fact, change the state.

00:34:04.926 --> 00:34:07.786 A:middle
So we marked it mutating
and we set path equal

00:34:07.786 --> 00:34:10.766 A:middle
to a new copy of
our existing path.

00:34:11.275 --> 00:34:15.136 A:middle
Now we have both a reading copy
and a way to get a writing copy.

00:34:16.315 --> 00:34:18.896 A:middle
And we change our
implementation to reflect that.

00:34:18.896 --> 00:34:21.696 A:middle
In the Is Empty method, we
will call our reading copy,

00:34:22.025 --> 00:34:23.815 A:middle
and in the mutating
method below,

00:34:23.815 --> 00:34:25.166 A:middle
we will call the
path for writing.

00:34:25.735 --> 00:34:28.466 A:middle
And the great thing about this
that the compiler is going

00:34:28.466 --> 00:34:29.956 A:middle
to yell at us and say, "Hey,

00:34:30.356 --> 00:34:33.466 A:middle
that path for writing
property is marked as mutating,

00:34:33.806 --> 00:34:36.065 A:middle
and this method is not
marked for mutating."

00:34:36.065 --> 00:34:39.076 A:middle
So we are getting help from
the compiler to help us figure

00:34:39.076 --> 00:34:41.096 A:middle
out when we are doing
something wrong.

00:34:41.795 --> 00:34:46.085 A:middle
Just to look through it
in a diagram, the path,

00:34:46.996 --> 00:34:49.545 A:middle
I create another one
by saying Path To.

00:34:49.996 --> 00:34:51.156 A:middle
Of course, I can read from it.

00:34:51.156 --> 00:34:54.376 A:middle
No issue. And when
I go to write to it,

00:34:54.985 --> 00:34:58.966 A:middle
since I'm creating another
instance of BezierPath,

00:34:59.566 --> 00:35:02.736 A:middle
path two is none the wiser
that a mutation has happened.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.566 --> 00:35:02.736 A:middle
path two is none the wiser
that a mutation has happened.

00:35:03.096 --> 00:35:06.676 A:middle
So I will not introduce some
unexpected mutation behind

00:35:07.996 --> 00:35:08.646 A:middle
path two.

00:35:11.046 --> 00:35:14.626 A:middle
So now let's talk about how to
use these things in practice.

00:35:15.656 --> 00:35:19.356 A:middle
Here we have our polygon
type, and we are extending

00:35:19.356 --> 00:35:21.506 A:middle
that by adding a method
that's going to return

00:35:21.506 --> 00:35:24.106 A:middle
to us a BezierPath that
describes that polygon.

00:35:24.826 --> 00:35:27.386 A:middle
So we create the BezierPath,
iterate through the points,

00:35:27.386 --> 00:35:29.776 A:middle
adding a line two to
each of these points.

00:35:30.086 --> 00:35:33.176 A:middle
Now, the downside is
remember that Add Line

00:35:33.176 --> 00:35:36.066 A:middle
To Point method is
copying on every call.

00:35:36.646 --> 00:35:39.166 A:middle
So this is not going to
perform as well as it might.

00:35:40.966 --> 00:35:43.656 A:middle
So instead, what we should
do is create an instance

00:35:43.656 --> 00:35:48.986 A:middle
of UIBezierPath and mutate that
mutable reference type in place

00:35:49.326 --> 00:35:52.686 A:middle
and when we're done, create a
new instance of our value type

00:35:52.826 --> 00:35:54.816 A:middle
with that BezierPath
and return that.

00:35:55.216 --> 00:35:57.806 A:middle
That creates only one
copy or only one instance

00:35:57.806 --> 00:35:59.926 A:middle
of UIBezierPath instead
of multiple.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:00.536 --> 00:36:05.686 A:middle
In Swift, we have a great
feature where we know

00:36:05.686 --> 00:36:07.436 A:middle
if objects are uniquely
referenced,

00:36:07.436 --> 00:36:09.156 A:middle
and so we can take
advantage of that.

00:36:09.156 --> 00:36:11.566 A:middle
This is a similar structure to
what we saw in our BezierPath,

00:36:12.196 --> 00:36:15.556 A:middle
and we can use this fact that
we have this uniquely referenced

00:36:15.686 --> 00:36:17.636 A:middle
property and we know for a fact

00:36:17.716 --> 00:36:18.996 A:middle
that something is
uniquely referenced

00:36:18.996 --> 00:36:21.566 A:middle
so we can avoid making
the copies if we know

00:36:21.566 --> 00:36:23.836 A:middle
that that reference type
is uniquely referenced.

00:36:24.276 --> 00:36:27.566 A:middle
The standard library uses
that feature throughout

00:36:27.566 --> 00:36:29.826 A:middle
and does a lot of great
performance optimizations

00:36:29.826 --> 00:36:31.006 A:middle
using that.

00:36:31.956 --> 00:36:34.616 A:middle
So that's mixing value
types and reference types.

00:36:34.616 --> 00:36:38.286 A:middle
You want to make sure that you
maintain value semantics despite

00:36:38.286 --> 00:36:42.656 A:middle
the fact that you have these
references to mutable types

00:36:42.786 --> 00:36:44.746 A:middle
by using copy-on-write.

00:36:45.496 --> 00:36:47.136 A:middle
So now I want to look

00:36:47.136 --> 00:36:49.026 A:middle
at a really cool
feature we can do now

00:36:49.026 --> 00:36:52.296 A:middle
that we have a model type
implemented as a value,

00:36:53.086 --> 00:36:54.726 A:middle
and implement an undo stack.

00:36:55.376 --> 00:36:59.056 A:middle
So I'm going to create a diagram
and an array of diagrams.

00:36:59.316 --> 00:37:04.896 A:middle
Then with every mutation, I will
add my doc to my diagram array.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.316 --> 00:37:04.896 A:middle
Then with every mutation, I will
add my doc to my diagram array.

00:37:05.246 --> 00:37:06.746 A:middle
So I create it and append.

00:37:07.456 --> 00:37:10.706 A:middle
I add a polygon and append
it to the undo stack.

00:37:11.616 --> 00:37:14.336 A:middle
I create a circle and append
that to the undo stack.

00:37:14.886 --> 00:37:19.606 A:middle
Now in my undo stack I have
three distinct instances

00:37:19.666 --> 00:37:20.756 A:middle
of Diagram.

00:37:21.066 --> 00:37:23.746 A:middle
These are not references
to the same thing,

00:37:23.746 --> 00:37:25.956 A:middle
these are three distinct values.

00:37:26.566 --> 00:37:29.386 A:middle
And so, I can implement some
really cool features with this.

00:37:29.716 --> 00:37:33.756 A:middle
So imagine this in an app,
and I have a History button.

00:37:34.046 --> 00:37:37.206 A:middle
I tap on the History button and
I get the list of all the states

00:37:37.206 --> 00:37:40.516 A:middle
of my diagram back
through my undo stack.

00:37:41.086 --> 00:37:43.296 A:middle
I can allow the user
to tap on something

00:37:43.626 --> 00:37:45.326 A:middle
and essentially go back in time.

00:37:45.686 --> 00:37:50.206 A:middle
I don't have to keep anything in
some array of how to undo adding

00:37:50.206 --> 00:37:51.356 A:middle
that property or anything.

00:37:51.696 --> 00:37:53.716 A:middle
It just goes back to
that previous instance,

00:37:53.716 --> 00:37:56.756 A:middle
and that's the one
that gets drawn.

00:37:56.936 --> 00:37:59.916 A:middle
This is a super-powerful
feature, and, in fact,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.316 --> 00:38:03.236 A:middle
Photoshop uses this
extensively to implement all

00:38:03.236 --> 00:38:04.186 A:middle
of their history stuff.

00:38:05.086 --> 00:38:07.036 A:middle
When you open an
image in Photoshop,

00:38:07.226 --> 00:38:08.966 A:middle
what happens behind the scenes?

00:38:09.316 --> 00:38:11.576 A:middle
Photoshop slices and
dices that photo,

00:38:11.576 --> 00:38:14.506 A:middle
no matter how large it is,
into a bunch of small tiles.

00:38:15.116 --> 00:38:18.566 A:middle
Each of those tiles are
values, and the document

00:38:18.686 --> 00:38:21.686 A:middle
that contains the
tiles is also a value.

00:38:22.116 --> 00:38:24.686 A:middle
Then if I make a change, like
change this person's shirt

00:38:24.686 --> 00:38:29.686 A:middle
from purple to green, the
only thing that gets copied

00:38:29.686 --> 00:38:33.196 A:middle
in the two instances of
that diagram are the tiles

00:38:33.246 --> 00:38:34.996 A:middle
that contain the person's shirt.

00:38:35.606 --> 00:38:38.306 A:middle
So even though I have
two distinct documents,

00:38:38.386 --> 00:38:42.596 A:middle
the old state and the new
state, the only new data

00:38:42.596 --> 00:38:44.596 A:middle
that I have had to
consume as a result

00:38:44.596 --> 00:38:47.836 A:middle
of that is the tiles contained
in this person's shirt.

00:38:48.486 --> 00:38:52.966 A:middle
So in summary, we have
talked about value types,

00:38:53.036 --> 00:38:55.806 A:middle
and what great features they
bring to your applications,

00:38:55.866 --> 00:38:59.246 A:middle
compared that to reference types
and showed how value types fix

00:38:59.246 --> 00:39:00.376 A:middle
up some of those issues.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.246 --> 00:39:00.376 A:middle
up some of those issues.

00:39:00.906 --> 00:39:03.466 A:middle
We talked through an example
and saw some cool features

00:39:03.466 --> 00:39:05.416 A:middle
that you can add to
your applications

00:39:05.796 --> 00:39:07.046 A:middle
by using value types.

00:39:07.346 --> 00:39:09.356 A:middle
I look forward to seeing
how those things play

00:39:09.356 --> 00:39:10.486 A:middle
out in your apps.

00:39:11.046 --> 00:39:13.696 A:middle
Some related sessions that
you can catch on video

00:39:13.696 --> 00:39:15.456 A:middle
or if you have time
today at 3:30

00:39:15.456 --> 00:39:16.896 A:middle
for the protocol-oriented talk.

00:39:18.406 --> 00:39:21.496 A:middle
For more information, you can
always email Stephan or go

00:39:21.496 --> 00:39:25.156 A:middle
to our forums, and the
documentation also has

00:39:25.186 --> 00:39:26.306 A:middle
great information.

00:39:27.076 --> 00:39:29.526 A:middle
Thank you very much and I hope
the rest of your WWDC is great.

00:39:31.516 --> 00:39:42.900 A:middle
[ Applause ]

