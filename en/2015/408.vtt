WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:15.516 A:middle
[Music]

00:00:16.015 --> 00:00:26.000 A:middle
[Silence]

00:00:26.516 --> 00:00:33.636 A:middle
[Applause]

00:00:34.136 --> 00:00:34.746 A:middle
&gt;&gt; Dave Abrahams: Hi, everybody.

00:00:35.346 --> 00:00:39.466 A:middle
My name is Dave Abrahams,
and I'm the technical lead

00:00:39.526 --> 00:00:42.516 A:middle
for the Swift standard library,
and it is truly my privilege

00:00:42.516 --> 00:00:44.036 A:middle
to be with you here today.

00:00:44.036 --> 00:00:47.026 A:middle
It is great to see all
of you in this room.

00:00:47.546 --> 00:00:52.076 A:middle
The next 40 minutes are about
putting aside your usual way

00:00:52.076 --> 00:00:53.336 A:middle
of thinking about programming.

00:00:54.466 --> 00:00:58.656 A:middle
What we're going to do together
here won't necessarily be easy,

00:00:58.656 --> 00:01:00.336 A:middle
but I promise you if
you stick with me,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:58.656 --> 00:01:00.336 A:middle
but I promise you if
you stick with me,

00:01:00.956 --> 00:01:02.096 A:middle
that it'll be worth your time.

00:01:02.096 --> 00:01:07.686 A:middle
I'm here to talk to you
about themes at the heart

00:01:07.686 --> 00:01:11.716 A:middle
of Swift's design, and introduce
you to a way of programming

00:01:11.916 --> 00:01:13.596 A:middle
that has the potential
to change everything.

00:01:15.076 --> 00:01:17.856 A:middle
But first, let me introduce
you to a friend of mine.

00:01:20.586 --> 00:01:21.636 A:middle
This is Crusty.

00:01:23.396 --> 00:01:26.276 A:middle
Now you've probably all worked
with some version of this guy.

00:01:26.456 --> 00:01:29.266 A:middle
Crusty is that old-school
programmer

00:01:29.626 --> 00:01:35.036 A:middle
who doesn't trust
debuggers, doesn't use IDEs.

00:01:35.036 --> 00:01:37.606 A:middle
No, he favors an 80
x 24 terminal window

00:01:37.606 --> 00:01:39.356 A:middle
and plain text, thank
you very much.

00:01:42.636 --> 00:01:45.506 A:middle
And he takes a dim view of
the latest programming fads.

00:01:46.156 --> 00:01:49.286 A:middle
Now I've learned
to expect Crusty

00:01:49.286 --> 00:01:51.986 A:middle
to be a little bit
cynical and grumpy,

00:01:52.436 --> 00:01:55.266 A:middle
but even so it sometimes
takes me by surprise.

00:01:55.886 --> 00:01:59.236 A:middle
Like last month we were
talking about app development,

00:01:59.666 --> 00:02:02.916 A:middle
and said flat out, 'I
don't do object-oriented.'


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.666 --> 00:02:02.916 A:middle
and said flat out, 'I
don't do object-oriented.'

00:02:03.946 --> 00:02:06.406 A:middle
I could hardly believe my ears.

00:02:07.056 --> 00:02:09.826 A:middle
I mean, object-oriented
programming has been

00:02:09.826 --> 00:02:14.426 A:middle
around since the 1970s, so it's
not exactly some new-fangled

00:02:14.426 --> 00:02:15.256 A:middle
programming fad.

00:02:15.756 --> 00:02:19.566 A:middle
And, furthermore, lots
of the amazing things

00:02:19.566 --> 00:02:23.686 A:middle
that we've all built together,
you and I and the engineers

00:02:23.686 --> 00:02:26.936 A:middle
on whose shoulders we stand,
were built with objects.

00:02:28.196 --> 00:02:30.406 A:middle
'Come on,' I said
to him as I walked

00:02:30.406 --> 00:02:31.956 A:middle
over to his old-school
chalkboard.

00:02:32.276 --> 00:02:33.176 A:middle
'OOP is awesome.

00:02:33.176 --> 00:02:35.326 A:middle
Look what you can
do with classes.'

00:02:36.516 --> 00:02:41.666 A:middle
[Silence]

00:02:42.166 --> 00:02:47.236 A:middle
Yes. So first you can group
related data and operations.

00:02:48.206 --> 00:02:52.206 A:middle
And then we can build walls to
separate the inside of our code

00:02:52.296 --> 00:02:54.896 A:middle
from the outside, and
that's what lets us

00:02:54.896 --> 00:02:56.076 A:middle
maintain invariants.

00:02:58.516 --> 00:03:03.266 A:middle
Then we use classes to represent
relatable ideas, like window


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.516 --> 00:03:03.266 A:middle
Then we use classes to represent
relatable ideas, like window

00:03:03.476 --> 00:03:05.116 A:middle
or communication channel.

00:03:05.696 --> 00:03:11.176 A:middle
They give us a namespace,
which helps prevent collisions

00:03:11.176 --> 00:03:12.986 A:middle
as our software grows.

00:03:15.096 --> 00:03:18.026 A:middle
They have amazing
expressive syntax.

00:03:18.316 --> 00:03:21.626 A:middle
So we can write method
calls and properties

00:03:21.626 --> 00:03:22.766 A:middle
and chain them together.

00:03:23.016 --> 00:03:24.316 A:middle
We can make subscripts.

00:03:25.326 --> 00:03:27.726 A:middle
We can even make properties
that do computation.

00:03:28.976 --> 00:03:32.936 A:middle
Last, classes are open
for extensibility.

00:03:33.286 --> 00:03:36.606 A:middle
So if a class author leaves
something out that I need, well,

00:03:36.606 --> 00:03:37.896 A:middle
I can come along
and add it later.

00:03:39.026 --> 00:03:41.396 A:middle
And, furthermore,
together, these things,

00:03:42.976 --> 00:03:44.636 A:middle
these things let us
manage complexity

00:03:45.396 --> 00:03:47.576 A:middle
and that's really the main
challenge in programming.

00:03:48.146 --> 00:03:52.746 A:middle
These properties, they directly
address the problems we're

00:03:52.746 --> 00:03:54.316 A:middle
trying to solve in
software development.

00:03:55.716 --> 00:03:57.826 A:middle
At that point, I had gotten
myself pretty inspired,

00:03:58.176 --> 00:04:04.196 A:middle
but Crusty just snorted
and [sighed].


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.176 --> 00:04:04.196 A:middle
but Crusty just snorted
and [sighed].

00:04:05.806 --> 00:04:07.206 A:middle
[hiss sound] He let all
the air out of my balloon.

00:04:09.506 --> 00:04:10.706 A:middle
And if that wasn't bad enough,

00:04:10.826 --> 00:04:12.636 A:middle
a moment later he
finished the sentence.

00:04:13.191 --> 00:04:15.191 A:middle
[Laughter]

00:04:15.366 --> 00:04:17.596 A:middle
Because it's true, in Swift,

00:04:17.896 --> 00:04:22.005 A:middle
any type you can name is a first
class citizen and it's able

00:04:22.005 --> 00:04:24.896 A:middle
to take advantage of
all these capabilities.

00:04:25.506 --> 00:04:29.846 A:middle
So I took a step back
and tried to figure

00:04:29.846 --> 00:04:33.526 A:middle
out what core capability enables
everything we've accomplished

00:04:33.526 --> 00:04:34.866 A:middle
with object-oriented
programming.

00:04:36.786 --> 00:04:41.606 A:middle
Obviously, it has to come from
something that you can only do

00:04:41.606 --> 00:04:44.076 A:middle
with classes, like inheritance.

00:04:45.416 --> 00:04:48.006 A:middle
And this got me thinking
specifically

00:04:48.006 --> 00:04:51.486 A:middle
about how these structures
enable both code sharing

00:04:51.836 --> 00:04:53.396 A:middle
and fine-grained customization.

00:04:54.746 --> 00:04:58.666 A:middle
So, for example, a superclass
can define a substantial method

00:04:58.666 --> 00:05:01.576 A:middle
with complex logic,
and subclasses get all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.666 --> 00:05:01.576 A:middle
with complex logic,
and subclasses get all

00:05:01.576 --> 00:05:03.476 A:middle
of the work done by the
superclass for free.

00:05:04.776 --> 00:05:05.716 A:middle
They just inherit it.

00:05:07.156 --> 00:05:11.036 A:middle
But the real magic happens when
the superclass author breaks

00:05:11.036 --> 00:05:12.966 A:middle
out a tiny part of
that operation

00:05:13.406 --> 00:05:15.276 A:middle
into a separate customization
point

00:05:15.786 --> 00:05:18.966 A:middle
that the subclass can override,

00:05:20.086 --> 00:05:22.176 A:middle
and this customization
is overlaid

00:05:22.176 --> 00:05:23.696 A:middle
on the inherited implementation.

00:05:24.256 --> 00:05:27.086 A:middle
That allows the difficult logic

00:05:27.086 --> 00:05:30.386 A:middle
to be reused while enabling
open-ended flexibility

00:05:30.386 --> 00:05:31.806 A:middle
and specific variations.

00:05:32.086 --> 00:05:33.806 A:middle
And now, I was sure, I had him.

00:05:34.406 --> 00:05:35.946 A:middle
'Ha,' I said to Crusty.

00:05:36.156 --> 00:05:37.866 A:middle
'Obviously, now you have to bow

00:05:37.866 --> 00:05:42.716 A:middle
down before the power
of the class.'

00:05:42.856 --> 00:05:45.246 A:middle
'Hold on just a darn
tootin' minute,' he replied.

00:05:46.196 --> 00:05:46.796 A:middle
'First of all,

00:05:46.796 --> 00:05:49.596 A:middle
I do customization
whatchamacallit all the time

00:05:49.596 --> 00:05:53.876 A:middle
with structs, and second,
yes, classes are powerful

00:05:53.966 --> 00:05:57.596 A:middle
but let's talk about the costs.

00:05:58.476 --> 00:06:04.566 A:middle
I have got three major beefs
with classes,' said Crusty.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.476 --> 00:06:04.566 A:middle
I have got three major beefs
with classes,' said Crusty.

00:06:05.156 --> 00:06:07.376 A:middle
And he started in on
his list of complaints.

00:06:08.766 --> 00:06:10.386 A:middle
'First, you got your
automatic sharing.'

00:06:11.636 --> 00:06:13.116 A:middle
Now you all know
what this looks like.

00:06:14.186 --> 00:06:18.176 A:middle
A hands B some piece of
perfectly sober looking data,

00:06:18.706 --> 00:06:21.886 A:middle
and B thinks, 'Great,
conversation over.'

00:06:22.986 --> 00:06:25.886 A:middle
But now we've got
a situation where A

00:06:26.216 --> 00:06:31.026 A:middle
and B each have their own very
reasonable view of the world

00:06:31.026 --> 00:06:32.346 A:middle
that just happens to be wrong.

00:06:33.976 --> 00:06:39.566 A:middle
Because this is the reality:
eventually A gets tired

00:06:39.566 --> 00:06:42.056 A:middle
of serious data and decides
he likes ponies instead,

00:06:42.936 --> 00:06:44.066 A:middle
and who doesn't love
a good pony?

00:06:44.626 --> 00:06:50.906 A:middle
This is totally fine until
B digs up this data later,

00:06:51.046 --> 00:06:52.796 A:middle
much later, that she got from A

00:06:52.796 --> 00:06:55.426 A:middle
and there's been a
surprise mutation.

00:06:57.256 --> 00:06:59.206 A:middle
B wants her data,
not A's ponies.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:00.526 --> 00:07:03.816 A:middle
Well, Crusty has a whole rant
about how this plays out.

00:07:06.386 --> 00:07:09.426 A:middle
'First,' he says, 'you start
copying everything like crazy

00:07:09.426 --> 00:07:10.876 A:middle
to squash the bugs in your code.

00:07:11.136 --> 00:07:12.836 A:middle
But now you're making
too many copies,

00:07:13.256 --> 00:07:14.696 A:middle
which slows the code down.

00:07:15.056 --> 00:07:17.576 A:middle
And then one day you handle
something on a dispatch queue

00:07:17.846 --> 00:07:19.876 A:middle
and suddenly you've
got a race condition

00:07:20.096 --> 00:07:22.026 A:middle
because threads are
sharing a mutable state,

00:07:22.416 --> 00:07:25.296 A:middle
so you start adding locks
to protect your invariants.

00:07:26.186 --> 00:07:28.366 A:middle
But the locks slow the
code down some more

00:07:28.696 --> 00:07:30.076 A:middle
and might even lead to deadlock.

00:07:30.356 --> 00:07:32.296 A:middle
And all of this is
added complexity,

00:07:32.596 --> 00:07:36.296 A:middle
whose effects can be summed
up in one word, bugs.'

00:07:36.866 --> 00:07:41.596 A:middle
But none of this is news
to Cocoa programmers.

00:07:42.516 --> 00:07:44.516 A:middle
[Laughter]

00:07:45.016 --> 00:07:50.000 A:middle
[Applause]

00:07:50.316 --> 00:07:50.936 A:middle
It's not news.

00:07:50.996 --> 00:07:54.156 A:middle
We've been applying a
combination of language features

00:07:54.156 --> 00:07:57.006 A:middle
like @property(copy)
and coding conventions

00:07:57.006 --> 00:07:58.886 A:middle
over the years to handle this.

00:07:59.416 --> 00:08:02.136 A:middle
And we still get bitten.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.416 --> 00:08:02.136 A:middle
And we still get bitten.

00:08:03.176 --> 00:08:05.586 A:middle
For example, there's
this warning

00:08:05.586 --> 00:08:07.306 A:middle
in the Cocoa documentation

00:08:07.526 --> 00:08:10.006 A:middle
about modifying a mutable
collection while you're

00:08:10.006 --> 00:08:10.776 A:middle
iterating through it.

00:08:12.086 --> 00:08:16.346 A:middle
Right? And this is all
due to implicit sharing

00:08:16.416 --> 00:08:19.606 A:middle
of mutable state, which
is inherent to classes.

00:08:20.106 --> 00:08:25.126 A:middle
But this doesn't apply to Swift.

00:08:25.286 --> 00:08:30.776 A:middle
Why not? It's because Swift
collections are all value types,

00:08:31.526 --> 00:08:32.666 A:middle
so the one you're iterating

00:08:32.666 --> 00:08:34.476 A:middle
and the one you're
modifying are distinct.

00:08:36.606 --> 00:08:39.395 A:middle
Okay, number two
on Crusty's list,

00:08:40.466 --> 00:08:42.206 A:middle
class inheritance
is too intrusive.

00:08:43.155 --> 00:08:46.096 A:middle
First of all, it's monolithic.

00:08:46.636 --> 00:08:48.806 A:middle
You get one and only
one superclass.

00:08:49.846 --> 00:08:52.216 A:middle
So what if you need to
model multiple abstractions?

00:08:52.576 --> 00:08:56.096 A:middle
Can you be a collection
and be serialized?

00:08:57.146 --> 00:08:59.986 A:middle
Well, not if collection
and serialized are classes.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:01.436 --> 00:09:04.196 A:middle
And because class inheritance
is single inheritance,

00:09:04.656 --> 00:09:06.336 A:middle
classes get bloated
as everything

00:09:06.336 --> 00:09:08.716 A:middle
that might be related
gets thrown together.

00:09:09.356 --> 00:09:11.636 A:middle
You also have to
choose your superclass

00:09:11.636 --> 00:09:13.136 A:middle
at the moment you
define your class,

00:09:13.136 --> 00:09:14.936 A:middle
not later in some extension.

00:09:15.466 --> 00:09:21.936 A:middle
Next, if your superclass
had stored properties, well,

00:09:22.606 --> 00:09:23.456 A:middle
you have to accept them.

00:09:24.536 --> 00:09:25.396 A:middle
You don't get a choice.

00:09:26.726 --> 00:09:29.736 A:middle
And then because it
has stored properties,

00:09:30.326 --> 00:09:31.306 A:middle
you have to initialize it.

00:09:31.306 --> 00:09:35.996 A:middle
And as Crusty says, 'designated
convenience required, oh, my.'

00:09:37.476 --> 00:09:39.706 A:middle
So you also have to make
sure that you understand how

00:09:39.706 --> 00:09:43.386 A:middle
to interact with your superclass
without breaking its invariants.

00:09:44.216 --> 00:09:48.866 A:middle
Right? And, finally, it's
natural for class authors

00:09:49.436 --> 00:09:53.106 A:middle
to write their code as though
they know what their methods are

00:09:53.106 --> 00:09:57.826 A:middle
going to do, without using
final and without accounting

00:09:57.916 --> 00:10:00.516 A:middle
for the chance that the
methods might get overridden.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:57.916 --> 00:10:00.516 A:middle
for the chance that the
methods might get overridden.

00:10:01.646 --> 00:10:06.646 A:middle
So, there's often a crucial
but unwritten contract

00:10:06.866 --> 00:10:08.746 A:middle
about which things
you're allowed

00:10:08.746 --> 00:10:12.376 A:middle
to actually override and,
like, do you have to chain

00:10:12.376 --> 00:10:13.486 A:middle
to the superclass method?

00:10:13.746 --> 00:10:15.576 A:middle
And if you're going to chain
to the superclass method,

00:10:15.576 --> 00:10:18.266 A:middle
is it at the beginning of
your method, or at the end,

00:10:18.266 --> 00:10:22.626 A:middle
or in the middle somewhere?

00:10:23.536 --> 00:10:26.626 A:middle
So, again, not news to
Cocoa programmers, right?

00:10:26.986 --> 00:10:29.486 A:middle
This is exactly why we use
the delegate pattern all

00:10:29.486 --> 00:10:30.476 A:middle
over the place in Cocoa.

00:10:31.016 --> 00:10:37.596 A:middle
Okay, last on Crusty's
list, classes just turn

00:10:37.596 --> 00:10:41.236 A:middle
out to be a really
bad fit for problems

00:10:41.326 --> 00:10:42.766 A:middle
where type relationships matter.

00:10:44.476 --> 00:10:46.826 A:middle
So if you've ever
tried to use classes

00:10:47.206 --> 00:10:49.416 A:middle
to represent a symmetric
operation,

00:10:49.416 --> 00:10:51.736 A:middle
like Comparison, you
know what I mean.

00:10:53.006 --> 00:10:56.846 A:middle
For example, if you want
to write a generalized sort

00:10:56.846 --> 00:10:59.116 A:middle
or binary search like
this, you need a way

00:10:59.116 --> 00:11:00.326 A:middle
to compare two elements.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.116 --> 00:11:00.326 A:middle
to compare two elements.

00:11:00.916 --> 00:11:03.406 A:middle
And with classes, you end
up with something like this.

00:11:04.236 --> 00:11:08.606 A:middle
Of course, you can't just
write Ordered this way,

00:11:08.956 --> 00:11:11.366 A:middle
because Swift demands a
method body for precedes.

00:11:11.366 --> 00:11:14.526 A:middle
So, what can we put there?

00:11:16.156 --> 00:11:18.216 A:middle
Remember, we don't know anything

00:11:18.216 --> 00:11:20.346 A:middle
about an arbitrary
instance of Ordered yet.

00:11:21.656 --> 00:11:25.616 A:middle
So if the method isn't
implemented by a subclass, well,

00:11:25.616 --> 00:11:27.536 A:middle
there's really nothing we
can do other than trap.

00:11:29.756 --> 00:11:33.496 A:middle
Now, this is the first sign that
we're fighting the type system.

00:11:34.026 --> 00:11:36.476 A:middle
And if we fail to
recognize that,

00:11:36.876 --> 00:11:38.946 A:middle
it's also where we start
lying to ourselves,

00:11:39.426 --> 00:11:43.226 A:middle
because we brush the issue
aside, telling ourselves

00:11:43.226 --> 00:11:45.076 A:middle
that as long as each subclass

00:11:45.076 --> 00:11:47.316 A:middle
of Ordered implements
precedes, we'll be okay.

00:11:48.806 --> 00:11:51.456 A:middle
Right? Make it the
subclasser's problem.

00:11:52.766 --> 00:11:55.866 A:middle
So we press ahead and
implement an example of Ordered.

00:11:57.346 --> 00:11:58.816 A:middle
So, here's a subclass.

00:11:59.376 --> 00:12:01.116 A:middle
It's got a double value


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.376 --> 00:12:01.116 A:middle
It's got a double value

00:12:01.466 --> 00:12:04.926 A:middle
and we override precedes
to do the comparison.

00:12:05.446 --> 00:12:09.746 A:middle
Right? Except, of
course, it doesn't work.

00:12:11.096 --> 00:12:14.056 A:middle
See, "other" is just
some arbitrary Ordered

00:12:14.206 --> 00:12:17.006 A:middle
and not a number, so
we don't know that

00:12:17.006 --> 00:12:19.726 A:middle
"other" has a value property.

00:12:20.276 --> 00:12:22.556 A:middle
In fact, it might turn
out to be a label,

00:12:23.156 --> 00:12:24.326 A:middle
which has a text property.

00:12:25.916 --> 00:12:28.136 A:middle
So, now we need to down-cast
just to get to the right type.

00:12:28.136 --> 00:12:34.126 A:middle
But, wait a sec, suppose that
"other" turns out to be a label?

00:12:34.746 --> 00:12:38.866 A:middle
Now, we're going to trap.

00:12:39.056 --> 00:12:42.936 A:middle
Right? So, this is
starting to smell a lot

00:12:43.016 --> 00:12:46.336 A:middle
like the problem we had when
writing the body for precedes

00:12:46.336 --> 00:12:51.406 A:middle
in the superclass, and we
don't have a better answer now

00:12:51.406 --> 00:12:52.256 A:middle
than we did before.

00:12:53.656 --> 00:12:55.226 A:middle
This is a static
type safety hole.

00:12:56.656 --> 00:12:57.786 A:middle
Why did it happen?

00:12:58.656 --> 00:13:02.296 A:middle
Well, it's because classes don't
let us express this crucial type


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.656 --> 00:13:02.296 A:middle
Well, it's because classes don't
let us express this crucial type

00:13:02.296 --> 00:13:05.846 A:middle
relationship between the type
of self and the type of other.

00:13:06.416 --> 00:13:09.606 A:middle
In fact, you can use
this as a "code smell."

00:13:10.466 --> 00:13:13.786 A:middle
So, any time you see a forced
down-cast in your code,

00:13:14.566 --> 00:13:17.366 A:middle
it's a good sign that some
important type relationship has

00:13:17.366 --> 00:13:19.946 A:middle
been lost, and often that's due

00:13:19.946 --> 00:13:21.546 A:middle
to using classes
for abstraction.

00:13:23.896 --> 00:13:28.686 A:middle
Okay, clearly what we need is
a better abstraction mechanism,

00:13:29.836 --> 00:13:33.616 A:middle
one that doesn't force us
to accept implicit sharing,

00:13:34.156 --> 00:13:35.996 A:middle
or lost type relationships,

00:13:36.766 --> 00:13:39.676 A:middle
or force us to choose just
one abstraction and do it

00:13:39.676 --> 00:13:43.416 A:middle
at the time we define our
types; one that doesn't force us

00:13:43.416 --> 00:13:45.636 A:middle
to accept unwanted instance data

00:13:46.186 --> 00:13:48.856 A:middle
or the associated
initialization complexity.

00:13:49.386 --> 00:13:54.016 A:middle
And, finally, one that
doesn't leave ambiguity

00:13:54.016 --> 00:13:55.336 A:middle
about what I need to override.

00:13:55.896 --> 00:13:58.696 A:middle
Of course, I'm talking
about protocols.

00:13:59.886 --> 00:14:03.446 A:middle
Protocols have all these
advantages, and that's why,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.886 --> 00:14:03.446 A:middle
Protocols have all these
advantages, and that's why,

00:14:03.766 --> 00:14:07.086 A:middle
when we made Swift, we made
the first protocol-oriented

00:14:07.086 --> 00:14:07.966 A:middle
programming language.

00:14:08.516 --> 00:14:17.176 A:middle
[Applause]

00:14:17.676 --> 00:14:21.206 A:middle
So, yes, Swift is great for
object-oriented programming,

00:14:21.746 --> 00:14:25.386 A:middle
but from the way for loops
and string literals work

00:14:25.786 --> 00:14:28.496 A:middle
to the emphasis in the
standard library on generics,

00:14:28.946 --> 00:14:31.226 A:middle
at its heart, Swift
is protocol-oriented.

00:14:32.586 --> 00:14:34.616 A:middle
And, hopefully, by the
time you leave here,

00:14:35.046 --> 00:14:36.976 A:middle
you'll be a little more
protocol-oriented yourself.

00:14:37.526 --> 00:14:42.176 A:middle
So, to get you started
off on the right foot,

00:14:42.616 --> 00:14:43.756 A:middle
we have a saying in Swift.

00:14:44.446 --> 00:14:45.536 A:middle
Don't start with a class.

00:14:46.086 --> 00:14:47.256 A:middle
Start with a protocol.

00:14:48.456 --> 00:14:51.636 A:middle
So let's do that with
our last example.

00:14:53.396 --> 00:14:58.166 A:middle
Okay, first, we need a protocol,
and right away Swift complains

00:14:58.316 --> 00:15:00.056 A:middle
that we can't put
a method body here,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.316 --> 00:15:00.056 A:middle
that we can't put
a method body here,

00:15:01.466 --> 00:15:03.476 A:middle
which is actually pretty
good because it means

00:15:03.476 --> 00:15:07.526 A:middle
that we're going to trade
that dynamic runtime check

00:15:08.026 --> 00:15:15.546 A:middle
for a static check, right,
that precedes as implemented.

00:15:16.136 --> 00:15:20.496 A:middle
Okay, next, it complains that
we're not overriding anything.

00:15:20.746 --> 00:15:22.156 A:middle
Well, of course we're not.

00:15:22.706 --> 00:15:24.556 A:middle
We don't have a baseclass
anymore, right?

00:15:24.646 --> 00:15:26.066 A:middle
No superclass, no override.

00:15:26.066 --> 00:15:29.736 A:middle
And we probably didn't even
want number to be a class

00:15:29.736 --> 00:15:31.826 A:middle
in the first place, because we
want it to act like a number.

00:15:32.686 --> 00:15:36.586 A:middle
Right? So, let's just
do two thing at once

00:15:36.586 --> 00:15:39.816 A:middle
and make that a struct.

00:15:39.956 --> 00:15:43.056 A:middle
Okay, I want to stop for a
moment here and appreciate

00:15:43.056 --> 00:15:46.036 A:middle
where we are, because this
is all valid code again.

00:15:47.106 --> 00:15:51.036 A:middle
Okay, the protocol is
playing exactly the same role

00:15:51.496 --> 00:15:55.546 A:middle
that the class did in our
first version of this example.

00:15:56.236 --> 00:15:57.496 A:middle
It's definitely a bit better.

00:15:57.646 --> 00:16:00.176 A:middle
I mean, we don't have
that fatal error anymore,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:57.646 --> 00:16:00.176 A:middle
I mean, we don't have
that fatal error anymore,

00:16:00.786 --> 00:16:03.846 A:middle
but we're not addressing the
underlying static type safety

00:16:03.846 --> 00:16:07.926 A:middle
hole, because we still need
that forced down-cast because

00:16:08.286 --> 00:16:11.546 A:middle
"other" is still some
arbitrary Ordered.

00:16:12.606 --> 00:16:16.656 A:middle
Okay. So, let's make it a number
instead, and drop the type cast.

00:16:19.346 --> 00:16:20.896 A:middle
Well, now Swift is
going to complain

00:16:20.896 --> 00:16:24.106 A:middle
that the signatures
don't match up.

00:16:25.446 --> 00:16:28.096 A:middle
To fix this, we need
to replace Ordered

00:16:28.096 --> 00:16:30.096 A:middle
in the protocol signature
with Self.

00:16:32.776 --> 00:16:34.646 A:middle
This is called a
Self-requirement.

00:16:35.676 --> 00:16:39.116 A:middle
So when you see Self in a
protocol, it's a placeholder

00:16:39.446 --> 00:16:40.886 A:middle
for the type that's
going to conform

00:16:40.886 --> 00:16:44.076 A:middle
to that protocol,
the model type.

00:16:45.016 --> 00:16:46.586 A:middle
So, now we have valid
code again.

00:16:47.626 --> 00:16:49.836 A:middle
Now, let's take a look at
how you use this protocol.

00:16:50.406 --> 00:16:55.896 A:middle
So, this is the binary
search that worked

00:16:55.896 --> 00:16:57.596 A:middle
when Ordered was a class.

00:16:58.916 --> 00:17:01.866 A:middle
And it also worked
perfectly before we added


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.916 --> 00:17:01.866 A:middle
And it also worked
perfectly before we added

00:17:01.866 --> 00:17:03.226 A:middle
that Self-requirement
to Ordered.

00:17:04.736 --> 00:17:08.806 A:middle
And this array of
ordered here is a claim.

00:17:09.796 --> 00:17:11.396 A:middle
It's a claim that we're going

00:17:11.396 --> 00:17:14.256 A:middle
to handle a heterogeneous
array of Ordered.

00:17:14.726 --> 00:17:18.056 A:middle
So, this array could
contain numbers

00:17:18.056 --> 00:17:21.056 A:middle
and labels mixed
together, right?

00:17:22.226 --> 00:17:26.175 A:middle
Now that we've made
this change to Ordered

00:17:26.175 --> 00:17:28.536 A:middle
and added the Self-requirement,
the compiler is going

00:17:28.536 --> 00:17:34.396 A:middle
to force us to make this
homogeneous, like this.

00:17:35.936 --> 00:17:39.406 A:middle
This one says, 'I work
on a homogeneous array

00:17:39.406 --> 00:17:41.676 A:middle
of any single Ordered type T.'

00:17:43.866 --> 00:17:45.666 A:middle
Now, you might think
that forcing the array

00:17:45.666 --> 00:17:49.056 A:middle
to be homogeneous is too
restrictive or, like,

00:17:49.176 --> 00:17:51.926 A:middle
a loss of functionality or
flexibility or something.

00:17:52.346 --> 00:17:53.396 A:middle
But if you think about it,

00:17:54.046 --> 00:17:56.326 A:middle
the original signature
was really a lie.

00:17:56.396 --> 00:17:59.906 A:middle
I mean, we never really handled
the heterogeneous case other

00:17:59.906 --> 00:18:00.976 A:middle
than by trapping.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.906 --> 00:18:00.976 A:middle
than by trapping.

00:18:01.516 --> 00:18:07.326 A:middle
Right? A homogeneous
array is what we want.

00:18:08.586 --> 00:18:11.726 A:middle
So, once you add a
Self-requirement to a protocol,

00:18:12.176 --> 00:18:15.476 A:middle
it moves the protocol into
a very different world,

00:18:16.246 --> 00:18:21.126 A:middle
where the capabilities have a
lot less overlap with classes.

00:18:21.656 --> 00:18:24.646 A:middle
It stops being usable as a type.

00:18:26.076 --> 00:18:30.456 A:middle
Collections become homogeneous
instead of heterogeneous.

00:18:30.936 --> 00:18:36.576 A:middle
An interaction between instances
no longer implies an interaction

00:18:36.576 --> 00:18:37.866 A:middle
between all model types.

00:18:40.026 --> 00:18:44.526 A:middle
We trade dynamic polymorphism
for static polymorphism, but,

00:18:44.526 --> 00:18:47.046 A:middle
in return for that extra type
information we're giving the

00:18:47.046 --> 00:18:48.876 A:middle
compiler, it's more optimizable.

00:18:49.446 --> 00:18:52.076 A:middle
So, two worlds.

00:18:54.086 --> 00:18:56.236 A:middle
Later in the talk, I'll show
you how to build a bridge

00:18:56.236 --> 00:18:58.156 A:middle
between them, at least one way.

00:18:59.596 --> 00:19:07.296 A:middle
Okay. So, I understood
how the static aspect


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.596 --> 00:19:07.296 A:middle
Okay. So, I understood
how the static aspect

00:19:07.296 --> 00:19:10.716 A:middle
of protocols worked, but
I wasn't sure whether

00:19:10.716 --> 00:19:14.406 A:middle
to believe Crusty that protocols
could really replace classes

00:19:14.866 --> 00:19:18.496 A:middle
and so I set him a
challenge, to build something

00:19:19.236 --> 00:19:22.506 A:middle
for which we'd normally use
OOP, but using protocols.

00:19:24.786 --> 00:19:26.556 A:middle
I had in mind a little
diagramming app

00:19:26.836 --> 00:19:30.836 A:middle
where you could drag and drop
shapes on a drawing surface

00:19:30.836 --> 00:19:31.786 A:middle
and then interact with them.

00:19:32.796 --> 00:19:36.316 A:middle
And so I asked Crusty to build
the document and display model.

00:19:37.336 --> 00:19:38.336 A:middle
And here's what he came up with.

00:19:41.166 --> 00:19:43.006 A:middle
First, he built some
drawing primitives.

00:19:43.656 --> 00:19:44.856 A:middle
Now, as you might imagine,

00:19:44.926 --> 00:19:46.556 A:middle
Crusty really doesn't
really do GUI's.

00:19:46.936 --> 00:19:47.966 A:middle
He's more of a text man.

00:19:48.776 --> 00:19:50.186 A:middle
So his primitives just print

00:19:50.186 --> 00:19:52.636 A:middle
out the drawing commands
you issue, right?

00:19:53.116 --> 00:19:56.456 A:middle
I grudgingly admitted that
this was probably enough

00:19:56.456 --> 00:20:01.426 A:middle
to prove his point, and then
he created a Drawable protocol


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:56.456 --> 00:20:01.426 A:middle
to prove his point, and then
he created a Drawable protocol

00:20:01.836 --> 00:20:05.856 A:middle
to provide a common interface
for all of our drawing elements.

00:20:06.856 --> 00:20:08.256 A:middle
Okay, this is pretty
straightforward.

00:20:09.126 --> 00:20:12.266 A:middle
And then he started
building shapes like Polygon.

00:20:13.006 --> 00:20:15.466 A:middle
Now, the first thing
to notice here

00:20:15.466 --> 00:20:17.476 A:middle
about Polygon is
it's a value type,

00:20:18.206 --> 00:20:19.786 A:middle
built out of other value types.

00:20:20.486 --> 00:20:23.046 A:middle
It's just a struct that
contains an array of points.

00:20:24.186 --> 00:20:27.766 A:middle
And to draw a polygon, we
move to the last corner

00:20:28.206 --> 00:20:30.936 A:middle
and then we cycle through all
the corners, drawing lines.

00:20:31.336 --> 00:20:33.836 A:middle
Okay, and here's a Circle.

00:20:35.246 --> 00:20:38.646 A:middle
Again, Circle is a value type,
built out of other value types.

00:20:38.696 --> 00:20:42.036 A:middle
It's just a struct that contains
a center point and a radius.

00:20:43.326 --> 00:20:46.506 A:middle
Now to draw a Circle, we make
an arc that sweeps all the way

00:20:46.626 --> 00:20:48.226 A:middle
from zero to two pi radians.

00:20:51.696 --> 00:20:55.826 A:middle
So, now we can build a diagram
out of circles and polygons.

00:20:59.076 --> 00:21:01.316 A:middle
'Okay,' said Crusty,
'let's take her for a spin.'


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.076 --> 00:21:01.316 A:middle
'Okay,' said Crusty,
'let's take her for a spin.'

00:21:02.256 --> 00:21:04.386 A:middle
So, he did.

00:21:05.036 --> 00:21:08.416 A:middle
This is a diagram.

00:21:10.006 --> 00:21:11.606 A:middle
A diagram is just a Drawable.

00:21:11.606 --> 00:21:13.216 A:middle
It's another value type.

00:21:14.246 --> 00:21:15.046 A:middle
Why is it a value type?

00:21:15.046 --> 00:21:17.956 A:middle
Because all Drawables are
value types, and so an array

00:21:17.956 --> 00:21:19.496 A:middle
of Drawables is also
a value type.

00:21:19.696 --> 00:21:20.806 A:middle
Let's go back to that.

00:21:22.206 --> 00:21:26.616 A:middle
Wow. Okay, there.

00:21:26.616 --> 00:21:30.936 A:middle
An array of Drawables is also
a value type and, therefore,

00:21:30.936 --> 00:21:33.636 A:middle
since that's the only
thing in my Diagram,

00:21:33.636 --> 00:21:34.996 A:middle
the Diagram is also
a value type.

00:21:35.546 --> 00:21:38.916 A:middle
So, to draw it, we
just loop through all

00:21:38.916 --> 00:21:41.966 A:middle
of the elements and
draw each one.

00:21:42.556 --> 00:21:45.646 A:middle
Okay, now let's take
her for a spin.

00:21:47.046 --> 00:21:52.016 A:middle
So, we're going to test it.

00:21:52.526 --> 00:21:55.046 A:middle
So, Crusty created a Circle

00:21:55.046 --> 00:21:58.656 A:middle
with curiously specific
center and radius.

00:21:59.076 --> 00:22:02.386 A:middle
And then, with uncanny
Spock-like precision,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.076 --> 00:22:02.386 A:middle
And then, with uncanny
Spock-like precision,

00:22:02.916 --> 00:22:03.886 A:middle
he added a Triangle.

00:22:05.096 --> 00:22:07.246 A:middle
And finally, he built a Diagram

00:22:07.246 --> 00:22:09.416 A:middle
around them, and
told it to draw.

00:22:13.126 --> 00:22:14.806 A:middle
'Voila,' said Crusty,
triumphantly.

00:22:15.136 --> 00:22:18.526 A:middle
'As you can plainly see, this
is an equilateral triangle

00:22:18.526 --> 00:22:20.666 A:middle
with a circle, inscribed
inside a circle.'

00:22:21.796 --> 00:22:25.756 A:middle
Well, maybe I'm just not as
good at doing trigonometry

00:22:25.756 --> 00:22:29.696 A:middle
in my head, as Crusty is,
but, 'No, Crusty,' I said,

00:22:29.696 --> 00:22:30.976 A:middle
'I can't plainly see that,

00:22:31.376 --> 00:22:33.476 A:middle
and I'd find this demo a
whole lot more compelling

00:22:33.476 --> 00:22:35.696 A:middle
if I was doing something
actually useful

00:22:35.696 --> 00:22:38.586 A:middle
for our app like, you know,
drawing to the screen.'

00:22:39.126 --> 00:22:41.996 A:middle
After I got over my annoyance,

00:22:42.436 --> 00:22:46.256 A:middle
I decided to rewrite his
Renderer to use CoreGraphics.

00:22:48.266 --> 00:22:52.076 A:middle
And I told him I was
going to this and he said,

00:22:52.546 --> 00:22:54.096 A:middle
'Hang on just a minute
there, monkey boy.

00:22:55.386 --> 00:22:58.066 A:middle
If you do that, how am I
going to test my code?'

00:22:58.726 --> 00:23:04.156 A:middle
And then he laid out a pretty
compelling case for the use


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.726 --> 00:23:04.156 A:middle
And then he laid out a pretty
compelling case for the use

00:23:04.156 --> 00:23:06.296 A:middle
of plaintext in testing.

00:23:06.706 --> 00:23:09.716 A:middle
If something changes
in what we're doing,

00:23:10.206 --> 00:23:12.716 A:middle
we'll immediately
see it in the output.

00:23:13.986 --> 00:23:16.136 A:middle
Instead, he suggested
we do a little

00:23:16.336 --> 00:23:17.636 A:middle
protocol-oriented programming.

00:23:18.756 --> 00:23:23.396 A:middle
So he copied his Renderer and
made the copy into a protocol.

00:23:24.626 --> 00:23:32.616 A:middle
Yeah, and then you have to
delete the bodies, okay.

00:23:33.066 --> 00:23:33.516 A:middle
There it is.

00:23:33.516 --> 00:23:37.906 A:middle
And then he renamed the original
Renderer and made it conform.

00:23:38.486 --> 00:23:44.046 A:middle
Now, all of this refactoring
was making me impatient, like,

00:23:44.046 --> 00:23:46.566 A:middle
I really want to see
this stuff on the screen.

00:23:47.876 --> 00:23:50.046 A:middle
I wanted to rush on and
implement a Renderer

00:23:50.046 --> 00:23:52.816 A:middle
for CoreGraphics,
but I had to wait

00:23:52.816 --> 00:23:54.616 A:middle
until Crusty tested
his code again.

00:23:55.916 --> 00:23:59.826 A:middle
And when he was finally
satisfied, he said to me, 'Okay,

00:23:59.826 --> 00:24:01.036 A:middle
what are you going to
put in your Renderer?'


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.826 --> 00:24:01.036 A:middle
what are you going to
put in your Renderer?'

00:24:01.686 --> 00:24:04.786 A:middle
And I said, 'Well, a CGContext.

00:24:05.206 --> 00:24:08.646 A:middle
CGContext has basically
everything a Renderer needs."

00:24:09.806 --> 00:24:13.036 A:middle
In fact, within the limits
of its plain C interface,

00:24:13.586 --> 00:24:14.756 A:middle
it basically is a Renderer.

00:24:15.276 --> 00:24:17.106 A:middle
'Great,' said Crusty.

00:24:17.106 --> 00:24:18.656 A:middle
'Gimme that keyboard.'

00:24:18.846 --> 00:24:21.956 A:middle
And he snatched something away
from me and he did something

00:24:21.956 --> 00:24:24.466 A:middle
so quickly I barely saw it.

00:24:31.796 --> 00:24:33.776 A:middle
'Wait a second,' I said.

00:24:34.306 --> 00:24:39.446 A:middle
'Did you just make every
CGContext into a Renderer?'

00:24:40.076 --> 00:24:44.236 A:middle
He had. I mean, it
didn't do anything yet,

00:24:45.126 --> 00:24:46.546 A:middle
but this was kind of amazing.

00:24:46.546 --> 00:24:48.226 A:middle
I didn't even have
to add a new type.

00:24:48.866 --> 00:24:51.816 A:middle
'What are you waiting for?'

00:24:51.816 --> 00:24:52.506 A:middle
said Crusty.

00:24:52.636 --> 00:24:53.516 A:middle
'Fill in those braces.'

00:24:55.026 --> 00:24:57.516 A:middle
So, I poured in the
necessary CoreGraphics goop,

00:24:57.926 --> 00:25:02.596 A:middle
and threw it all into a
playground, and there it is.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.926 --> 00:25:02.596 A:middle
and threw it all into a
playground, and there it is.

00:25:02.746 --> 00:25:04.646 A:middle
Now, you can download
this playground,

00:25:04.646 --> 00:25:07.736 A:middle
which demonstrates everything
I'm talking about here

00:25:07.736 --> 00:25:09.656 A:middle
in the talk, after we're done.

00:25:10.326 --> 00:25:13.606 A:middle
But back to our example.

00:25:14.906 --> 00:25:17.626 A:middle
Just to mess with me,
Crusty then did this.

00:25:18.146 --> 00:25:23.296 A:middle
Now, it took me a second to
realize why Drawing wasn't going

00:25:23.296 --> 00:25:26.616 A:middle
into an infinite recursion at
this point, and if you want

00:25:26.616 --> 00:25:28.376 A:middle
to know more about
that, you should go

00:25:28.376 --> 00:25:31.016 A:middle
to this session, on Friday.

00:25:32.606 --> 00:25:36.286 A:middle
But it also didn't
change the display at all.

00:25:37.456 --> 00:25:40.166 A:middle
Eventually, Crusty decided
to show me what was happening

00:25:40.166 --> 00:25:41.336 A:middle
in his plaintext output.

00:25:42.106 --> 00:25:45.336 A:middle
So it turns out that it was
just repeating the same drawing

00:25:45.336 --> 00:25:48.806 A:middle
commands, twice.

00:25:49.736 --> 00:25:52.846 A:middle
So, being more of a
graphics-oriented guy,

00:25:52.846 --> 00:25:54.796 A:middle
I really wanted to
see the results.

00:25:55.256 --> 00:25:58.796 A:middle
So, I built a little scaling
adapter and wrapped it

00:25:58.796 --> 00:26:03.576 A:middle
around the Diagram and
this is the result.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.796 --> 00:26:03.576 A:middle
around the Diagram and
this is the result.

00:26:04.016 --> 00:26:06.196 A:middle
And you can see this in the
playground, so I'm not going

00:26:06.196 --> 00:26:08.256 A:middle
to go into the scaling
adapter here.

00:26:10.046 --> 00:26:12.806 A:middle
But that's kind of
a demonstration

00:26:12.806 --> 00:26:16.606 A:middle
that with protocols, we can do
all the same kinds of things

00:26:16.606 --> 00:26:18.386 A:middle
that we're used to
doing with classes.

00:26:18.706 --> 00:26:21.116 A:middle
Adapters, usual design patterns.

00:26:21.516 --> 00:26:25.926 A:middle
Okay, now I'd like to
just reflect a second

00:26:25.926 --> 00:26:27.936 A:middle
on what Crusty did with
TestRenderer though,

00:26:28.526 --> 00:26:29.946 A:middle
because it's actually
kind of brilliant.

00:26:32.516 --> 00:26:36.356 A:middle
See, by decoupling the document
model from a specific Renderer,

00:26:36.966 --> 00:26:40.086 A:middle
he's able to plug in an
instrumented component

00:26:40.546 --> 00:26:43.516 A:middle
that reveals everything
that we do,

00:26:43.516 --> 00:26:44.906 A:middle
that our code does, in detail.

00:26:45.496 --> 00:26:49.196 A:middle
And we've since applied this
approach throughout our code.

00:26:50.246 --> 00:26:53.136 A:middle
We find that, the more we
decouple things with protocols,

00:26:53.516 --> 00:26:55.606 A:middle
the more testable
everything gets.

00:26:56.176 --> 00:26:59.686 A:middle
This kind of testing is
really similar to what you get

00:26:59.686 --> 00:27:01.836 A:middle
with mocks, but it's
so much better.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.686 --> 00:27:01.836 A:middle
with mocks, but it's
so much better.

00:27:03.086 --> 00:27:06.586 A:middle
See, mocks are inherently
fragile, right?

00:27:06.586 --> 00:27:09.016 A:middle
You have to couple
your testing code

00:27:09.016 --> 00:27:11.466 A:middle
to the implementation details
of the code under test.

00:27:12.606 --> 00:27:16.026 A:middle
And because of that
fragility, they don't play well

00:27:16.026 --> 00:27:20.436 A:middle
with Swift's strong
static type system.

00:27:20.646 --> 00:27:23.506 A:middle
See, protocols give us
a principled interface

00:27:23.816 --> 00:27:26.136 A:middle
that we can use, that's
enforced by the language,

00:27:26.686 --> 00:27:29.206 A:middle
but still gives us the
hooks to plug in all

00:27:29.206 --> 00:27:31.026 A:middle
of the instrumentation we need.

00:27:32.866 --> 00:27:36.776 A:middle
Okay, back to our example,
because now we seriously need

00:27:36.776 --> 00:27:38.676 A:middle
to talk about bubbles.

00:27:40.016 --> 00:27:43.176 A:middle
Okay. We wanted this diagramming
app to be popular with the kids,

00:27:43.176 --> 00:27:44.636 A:middle
and the kids love
bubbles, of course.

00:27:45.066 --> 00:27:51.126 A:middle
So, in a Diagram, a bubble is
just an inner circle offset

00:27:51.956 --> 00:27:55.896 A:middle
around the center of the
outer circle that you use

00:27:55.896 --> 00:27:57.006 A:middle
to represent a highlight.

00:27:57.836 --> 00:27:58.746 A:middle
So, you have two circles.

00:27:59.476 --> 00:27:59.976 A:middle
Just like that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:00.966 --> 00:28:03.936 A:middle
And when I put this
code in context though,

00:28:03.936 --> 00:28:06.096 A:middle
Crusty started getting
really agitated.

00:28:07.116 --> 00:28:09.046 A:middle
All the code repetition
was making him ornery,

00:28:09.726 --> 00:28:11.866 A:middle
and if Crusty ain't
happy, ain't nobody happy.

00:28:13.051 --> 00:28:15.051 A:middle
[Laughter]

00:28:15.086 --> 00:28:16.976 A:middle
'Look, they're all complete
circles,' he shouted.

00:28:16.976 --> 00:28:18.176 A:middle
'I just want to write this.'

00:28:19.176 --> 00:28:20.796 A:middle
I said, 'Calm down, Crusty.

00:28:20.926 --> 00:28:21.346 A:middle
Calm down.

00:28:22.076 --> 00:28:22.656 A:middle
We can do that.

00:28:24.166 --> 00:28:28.156 A:middle
All we need to do is add another
requirement to the protocol.

00:28:28.156 --> 00:28:29.276 A:middle
All right?

00:28:29.816 --> 00:28:32.886 A:middle
Then of course we update
our models to supply it.

00:28:33.786 --> 00:28:34.896 A:middle
There's test Renderer.

00:28:36.246 --> 00:28:37.656 A:middle
And then the CGContext.'

00:28:37.656 --> 00:28:42.706 A:middle
Now, at this point Crusty's got
his boot off and he's beating it

00:28:42.706 --> 00:28:45.916 A:middle
on the desk, because here we
were again, repeating code.

00:28:47.206 --> 00:28:49.776 A:middle
He snatched the keyboard back
from me, muttering something

00:28:49.776 --> 00:28:53.596 A:middle
about having to do everything
his own self, and he proceeded

00:28:53.596 --> 00:28:55.946 A:middle
to school me using a
new feature in Swift.

00:28:56.436 --> 00:29:01.896 A:middle
This is a protocol extension.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:56.436 --> 00:29:01.896 A:middle
This is a protocol extension.

00:29:03.276 --> 00:29:05.806 A:middle
This says 'all models

00:29:05.806 --> 00:29:08.246 A:middle
of Renderer have this
implementation of circleAt.'

00:29:09.516 --> 00:29:13.446 A:middle
Now we have an implementation
that is shared among all

00:29:13.446 --> 00:29:14.346 A:middle
of the models of Renderer.

00:29:14.936 --> 00:29:18.286 A:middle
So, notice that we still have
this circleAt requirement

00:29:18.476 --> 00:29:18.856 A:middle
up there.

00:29:19.566 --> 00:29:21.026 A:middle
You might ask, 'what
does it means

00:29:21.026 --> 00:29:23.856 A:middle
to have a requirement that's
also fulfilled immediately

00:29:24.166 --> 00:29:25.166 A:middle
in an extension?'

00:29:26.376 --> 00:29:26.856 A:middle
Good question.

00:29:27.506 --> 00:29:31.436 A:middle
The answer is that a
protocol requirement creates a

00:29:31.436 --> 00:29:32.456 A:middle
customization point.

00:29:33.736 --> 00:29:38.166 A:middle
To see how this plays out,
let's collapse this method body

00:29:38.726 --> 00:29:40.546 A:middle
and add another method
to the extension.

00:29:40.846 --> 00:29:43.446 A:middle
One that isn't backed
by a requirement.

00:29:43.956 --> 00:29:48.766 A:middle
And now we can extend
Crusty's TestRenderer

00:29:49.036 --> 00:29:51.466 A:middle
to implement both
of these methods.

00:29:51.836 --> 00:29:57.756 A:middle
And then we'll just call them.

00:29:57.976 --> 00:30:01.696 A:middle
Okay. Now, what happens here
is totally unsurprising.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:57.976 --> 00:30:01.696 A:middle
Okay. Now, what happens here
is totally unsurprising.

00:30:02.186 --> 00:30:04.856 A:middle
We're directly calling the
implementations in TestRenderer

00:30:05.796 --> 00:30:08.406 A:middle
and the protocol isn't
even involved, right?

00:30:08.896 --> 00:30:12.316 A:middle
We'd get the same result if
we removed that conformance.

00:30:14.566 --> 00:30:19.026 A:middle
But now, let's change
the context

00:30:19.026 --> 00:30:22.276 A:middle
so Swift only knows it has a
Renderer, not a TestRenderer.

00:30:22.856 --> 00:30:27.056 A:middle
And here's what happens.

00:30:28.146 --> 00:30:30.506 A:middle
So because circleAt
is a requirement,

00:30:31.316 --> 00:30:33.986 A:middle
our model gets the
privilege of customizing it,

00:30:34.396 --> 00:30:35.776 A:middle
and the customization
gets called.

00:30:38.896 --> 00:30:46.516 A:middle
That one. But rectangleAt
isn't a requirement,

00:30:46.516 --> 00:30:48.436 A:middle
so the implementation
in TestRenderer,

00:30:48.846 --> 00:30:52.896 A:middle
it only shadows the one in the
protocol and in this context,

00:30:53.456 --> 00:30:56.086 A:middle
where you only know you have a
Renderer and not a TestRenderer,

00:30:56.586 --> 00:30:58.066 A:middle
the protocol implementation
is called.

00:30:58.626 --> 00:31:01.226 A:middle
Which is kind of weird, right?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.626 --> 00:31:01.226 A:middle
Which is kind of weird, right?

00:31:02.516 --> 00:31:03.786 A:middle
So, does this mean

00:31:03.786 --> 00:31:05.996 A:middle
that rectangleAt should
have been a requirement?

00:31:07.066 --> 00:31:08.316 A:middle
Maybe, in this case, it should,

00:31:08.626 --> 00:31:11.236 A:middle
because some Renderers
are highly likely

00:31:11.236 --> 00:31:13.676 A:middle
to have a more efficient
way to draw rectangles, say,

00:31:13.916 --> 00:31:15.916 A:middle
aligned with a coordinate
system.

00:31:17.576 --> 00:31:21.376 A:middle
But, should everything in your
protocol extension also be

00:31:21.376 --> 00:31:22.456 A:middle
backed by a requirement?

00:31:22.896 --> 00:31:23.736 A:middle
Not necessarily.

00:31:24.356 --> 00:31:28.476 A:middle
I mean, some APIs
are just not intended

00:31:28.476 --> 00:31:29.996 A:middle
as customization points.

00:31:30.716 --> 00:31:32.876 A:middle
So, sometimes the right fix is

00:31:32.876 --> 00:31:37.476 A:middle
to just not shadow the
requirement in the model,

00:31:38.026 --> 00:31:39.916 A:middle
not shadow the method
in the model.

00:31:40.686 --> 00:31:47.196 A:middle
Okay. So, this new
feature, incidentally,

00:31:47.196 --> 00:31:50.496 A:middle
it's revolutionized our work
on the Swift Standard Library.

00:31:51.836 --> 00:31:54.336 A:middle
Sometimes what we can do
with protocol extensions,

00:31:55.336 --> 00:31:56.696 A:middle
it just feels like magic.

00:31:57.916 --> 00:32:01.176 A:middle
I really hope that you'll enjoy
working with the latest library


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:57.916 --> 00:32:01.176 A:middle
I really hope that you'll enjoy
working with the latest library

00:32:01.516 --> 00:32:03.226 A:middle
as much as we've
enjoyed applying this

00:32:03.256 --> 00:32:04.256 A:middle
to it and updating it.

00:32:04.256 --> 00:32:08.386 A:middle
And I want to put our
story aside for a second,

00:32:08.386 --> 00:32:11.676 A:middle
so I can show you some things
that we did in Standard Library

00:32:12.006 --> 00:32:14.896 A:middle
with protocol extensions,
and few other tricks besides.

00:32:16.506 --> 00:32:19.226 A:middle
So, first, there's a
new indexOf method.

00:32:20.706 --> 00:32:23.046 A:middle
So, this just walks through
the indices of the collection

00:32:23.426 --> 00:32:26.626 A:middle
until it finds an element that's
equal to what we're looking for

00:32:26.936 --> 00:32:28.456 A:middle
and it returns that index.

00:32:28.986 --> 00:32:30.746 A:middle
And if it doesn't find
one, it returns nil.

00:32:31.546 --> 00:32:32.336 A:middle
Simple enough, right?

00:32:32.886 --> 00:32:36.366 A:middle
But if we write it this
way, we have a problem.

00:32:37.846 --> 00:32:41.826 A:middle
See the elements of an arbitrary
collection can't be compared

00:32:41.826 --> 00:32:42.476 A:middle
with equal-equal.

00:32:42.996 --> 00:32:48.586 A:middle
So, to fix that, we can
constrain the extension.

00:32:49.376 --> 00:32:51.626 A:middle
This is another aspect
of this new feature.

00:32:54.896 --> 00:32:58.766 A:middle
So, by saying this extension
applies when the element type

00:32:58.766 --> 00:33:00.186 A:middle
of the collection is Equatable,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.766 --> 00:33:00.186 A:middle
of the collection is Equatable,

00:33:01.396 --> 00:33:04.456 A:middle
we've given Swift the
information it needs to allow

00:33:04.456 --> 00:33:05.986 A:middle
that equality comparison.

00:33:06.506 --> 00:33:10.336 A:middle
And now that we've
seen a simple example

00:33:10.406 --> 00:33:13.886 A:middle
of a constrained extension,
let's revisit our binary search.

00:33:15.266 --> 00:33:19.346 A:middle
And let's use it
on an array of Int.

00:33:21.036 --> 00:33:24.676 A:middle
Hmm. Okay, Int doesn't
conform to Ordered.

00:33:25.696 --> 00:33:26.886 A:middle
Well that's a simple fix, right?

00:33:27.386 --> 00:33:28.586 A:middle
We'll just add a conformance.

00:33:29.986 --> 00:33:33.076 A:middle
Okay, now what about Strings?

00:33:33.256 --> 00:33:34.476 A:middle
Well, of course,
this doesn't work

00:33:34.476 --> 00:33:35.966 A:middle
for Strings, so we do it again.

00:33:36.686 --> 00:33:39.316 A:middle
Now before Crusty starts banging
on his desk, we really want

00:33:39.316 --> 00:33:40.716 A:middle
to factor this stuff out, right?

00:33:41.016 --> 00:33:44.236 A:middle
The less-than operator
is present

00:33:44.236 --> 00:33:47.296 A:middle
in the Comparable
protocol, so we could do this

00:33:47.296 --> 00:33:48.836 A:middle
with an extension to comparable.

00:33:49.386 --> 00:33:51.176 A:middle
Like this.

00:33:52.146 --> 00:33:58.426 A:middle
Now we're providing the
precedes for those conformances.

00:33:58.746 --> 00:34:01.826 A:middle
So, on the one hand, this
is really nice, right?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.746 --> 00:34:01.826 A:middle
So, on the one hand, this
is really nice, right?

00:34:01.826 --> 00:34:03.736 A:middle
When I want a binary
search for Doubles, well,

00:34:04.106 --> 00:34:08.846 A:middle
all I have to is add this
conformance and I can do it.

00:34:08.976 --> 00:34:13.295 A:middle
On the other hand, it's
kind of icky, because even

00:34:13.295 --> 00:34:15.156 A:middle
if I take away the conformance,

00:34:15.516 --> 00:34:19.266 A:middle
I still have this precedes
function that's been glommed

00:34:19.266 --> 00:34:22.045 A:middle
onto Doubles, which already have
enough of an interface, right?

00:34:22.496 --> 00:34:25.466 A:middle
We maybe would like to be
a little bit more selective

00:34:25.466 --> 00:34:27.466 A:middle
about adding stuff to Double.

00:34:28.116 --> 00:34:33.846 A:middle
So, and even though
I can do that,

00:34:33.846 --> 00:34:35.755 A:middle
I can't binarySearch with it.

00:34:35.755 --> 00:34:38.255 A:middle
So it's really, that precedes
function buys me nothing.

00:34:39.806 --> 00:34:41.766 A:middle
Fortunately, I can
be more selective

00:34:41.766 --> 00:34:43.315 A:middle
about what gets a precedes API,

00:34:44.235 --> 00:34:46.295 A:middle
by using a constrained
extension on Ordered.

00:34:46.985 --> 00:34:52.786 A:middle
So, this says that a type that
is Comparable and is declared

00:34:52.786 --> 00:34:55.476 A:middle
to be Ordered will
automatically be able

00:34:55.476 --> 00:34:57.166 A:middle
to satisfy the precedes
requirement,

00:34:57.806 --> 00:35:00.406 A:middle
which is exactly what we want.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:57.806 --> 00:35:00.406 A:middle
which is exactly what we want.

00:35:00.566 --> 00:35:02.786 A:middle
I'm sorry, but I think
that's just really cool.

00:35:03.236 --> 00:35:05.866 A:middle
[Applause] We've got
the same abstraction.

00:35:06.846 --> 00:35:08.446 A:middle
The same logical
abstraction coming

00:35:08.446 --> 00:35:09.476 A:middle
from two different places,

00:35:09.476 --> 00:35:12.316 A:middle
and we've just made them
interoperate seamlessly.

00:35:12.896 --> 00:35:17.656 A:middle
Thank you for the applause,
but I just, I think it's cool.

00:35:17.656 --> 00:35:22.646 A:middle
Okay, ready for a
palate cleanser?

00:35:23.066 --> 00:35:25.136 A:middle
That's just showing it work.

00:35:25.786 --> 00:35:31.386 A:middle
Okay. This is the signature of
a fully generalized binarySearch

00:35:32.046 --> 00:35:33.736 A:middle
that works on any Collection

00:35:34.116 --> 00:35:36.876 A:middle
with the appropriate
Index and Element types.

00:35:37.596 --> 00:35:40.386 A:middle
Now, I can already hear you guys
getting uncomfortable out there.

00:35:40.656 --> 00:35:42.236 A:middle
I'm not going to write
the body out here,

00:35:42.236 --> 00:35:44.806 A:middle
because this is already pretty
awful to look at, right?

00:35:45.776 --> 00:35:48.786 A:middle
Swift 1 had lots of generic
free functions like this.

00:35:49.986 --> 00:35:52.576 A:middle
In Swift 2, we used protocol
extensions to make them

00:35:52.576 --> 00:35:55.816 A:middle
into methods like this,
which is awesome, right?

00:35:56.506 --> 00:36:00.156 A:middle
Now, everybody focuses on
the improvement this makes


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:56.506 --> 00:36:00.156 A:middle
Now, everybody focuses on
the improvement this makes

00:36:00.156 --> 00:36:04.596 A:middle
at the call site, which
is now clearly chock full

00:36:04.906 --> 00:36:06.546 A:middle
of method-y goodness, right?

00:36:06.976 --> 00:36:08.906 A:middle
But as the guy writing
binarySearch,

00:36:09.486 --> 00:36:10.976 A:middle
I love what it did
for the signature.

00:36:11.866 --> 00:36:15.306 A:middle
By separating the conditions
under which this method applies

00:36:15.616 --> 00:36:17.116 A:middle
from the rest of
the declaration,

00:36:17.816 --> 00:36:19.776 A:middle
which now just reads
like a regular method.

00:36:21.406 --> 00:36:22.816 A:middle
No more angle bracket blindness.

00:36:24.516 --> 00:36:28.556 A:middle
[Applause]

00:36:29.056 --> 00:36:30.976 A:middle
Thank you very much.

00:36:31.196 --> 00:36:35.036 A:middle
Okay, last trick before
we go back to our story.

00:36:35.836 --> 00:36:39.346 A:middle
This is a playground
containing a minimal model

00:36:39.346 --> 00:36:41.596 A:middle
of Swift's new OptionSetType
protocol.

00:36:42.786 --> 00:36:43.626 A:middle
It's just a struct

00:36:43.626 --> 00:36:46.706 A:middle
with a read-only Int
property, called rawValue.

00:36:47.486 --> 00:36:52.036 A:middle
Now take a look at the broad
Set-like interface you actually

00:36:52.036 --> 00:36:54.146 A:middle
get for free once
you've done that.

00:36:55.246 --> 00:36:57.586 A:middle
All of this comes from
protocol extensions.

00:36:58.966 --> 00:37:01.026 A:middle
And when you get a chance,
I invite you to take a look


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.966 --> 00:37:01.026 A:middle
And when you get a chance,
I invite you to take a look

00:37:01.026 --> 00:37:02.736 A:middle
at how those extensions
are declared

00:37:03.176 --> 00:37:06.046 A:middle
in the Standard Library, because
several layers are working

00:37:06.046 --> 00:37:08.356 A:middle
together to provide
this rich API.

00:37:11.326 --> 00:37:15.126 A:middle
Okay, so those are some of the
cool things that you can do

00:37:15.126 --> 00:37:16.306 A:middle
with protocol extensions.

00:37:17.376 --> 00:37:20.176 A:middle
Now, for the piece de
resistance, I'd like to return

00:37:20.176 --> 00:37:21.406 A:middle
to our diagramming example.

00:37:24.146 --> 00:37:25.836 A:middle
Always make value
types equatable.

00:37:27.696 --> 00:37:30.076 A:middle
Why? Because I said so.

00:37:30.806 --> 00:37:32.206 A:middle
Also, eat your vegetables.

00:37:32.856 --> 00:37:36.136 A:middle
No, actually, if you want to
know why, go to this session

00:37:36.136 --> 00:37:37.716 A:middle
on Friday, which I
told you about already.

00:37:39.576 --> 00:37:41.726 A:middle
It's a really cool
talk and they're going

00:37:41.726 --> 00:37:44.776 A:middle
to discuss this issue in detail.

00:37:44.866 --> 00:37:48.276 A:middle
Anyway, Equatable is easy
for most types, right?

00:37:48.276 --> 00:37:51.546 A:middle
You just compare corresponding
parts for equality, like this.

00:37:52.946 --> 00:37:55.236 A:middle
But, now, let's see what
happens with Diagram.

00:37:55.826 --> 00:38:03.366 A:middle
Uh-oh. We can't compare two
arrays of Drawable for equality.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:55.826 --> 00:38:03.366 A:middle
Uh-oh. We can't compare two
arrays of Drawable for equality.

00:38:05.206 --> 00:38:07.196 A:middle
All right, maybe we can do it

00:38:07.196 --> 00:38:09.756 A:middle
by comparing the
individual elements,

00:38:09.756 --> 00:38:14.366 A:middle
which looks something like this.

00:38:15.766 --> 00:38:19.046 A:middle
Okay, I'll go through
it for you.

00:38:19.176 --> 00:38:21.496 A:middle
First, you make sure they have
the same number of elements,

00:38:21.646 --> 00:38:23.906 A:middle
then you zip the
two arrays together.

00:38:23.906 --> 00:38:25.756 A:middle
If they do have the same number
of elements, then you look

00:38:25.846 --> 00:38:28.576 A:middle
for one where you have
a pair that's not equal.

00:38:28.576 --> 00:38:30.386 A:middle
All right, you can
take my word for it.

00:38:30.386 --> 00:38:36.116 A:middle
This isn't the interesting
part of the problem.

00:38:36.226 --> 00:38:36.986 A:middle
Oops, right?

00:38:37.206 --> 00:38:40.166 A:middle
This is, the whole reason we
couldn't compare the arrays is

00:38:40.196 --> 00:38:43.596 A:middle
because Drawables
aren't equatable, right?

00:38:43.786 --> 00:38:46.596 A:middle
So, we didn't have an equality
operator for the arrays.

00:38:47.056 --> 00:38:48.846 A:middle
We don't have an
equality operator

00:38:48.846 --> 00:38:49.966 A:middle
for the underlying Drawables.

00:38:49.966 --> 00:38:52.526 A:middle
So, can we just make
all Drawables Equatable?

00:38:53.196 --> 00:38:55.146 A:middle
We change our design like this.

00:38:56.516 --> 00:39:01.296 A:middle
Well, the problem with this is


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:56.516 --> 00:39:01.296 A:middle
Well, the problem with this is

00:39:01.336 --> 00:39:03.266 A:middle
that Equatable has
Self-requirements,

00:39:04.346 --> 00:39:07.206 A:middle
which means that Drawable
now has Self-requirements.

00:39:08.396 --> 00:39:11.326 A:middle
And a Self-requirement
puts Drawable squarely

00:39:11.326 --> 00:39:15.556 A:middle
in the homogeneous, statically
dispatched world, right?

00:39:16.176 --> 00:39:20.036 A:middle
But Diagram really needs
a heterogeneous array

00:39:20.266 --> 00:39:21.866 A:middle
of Drawables, right?

00:39:21.896 --> 00:39:25.216 A:middle
So we can put polygons and
circles in the same Diagram.

00:39:25.216 --> 00:39:28.066 A:middle
So Drawable has to stay
in the heterogeneous,

00:39:28.066 --> 00:39:29.316 A:middle
dynamically dispatched world.

00:39:30.366 --> 00:39:31.316 A:middle
And we've got a contradiction.

00:39:31.966 --> 00:39:36.286 A:middle
Making Drawable equatable
is not going to work.

00:39:37.796 --> 00:39:39.746 A:middle
We'll need to do
something like this,

00:39:39.746 --> 00:39:42.786 A:middle
which means adding a new
isEqualTo requirement

00:39:42.786 --> 00:39:43.336 A:middle
to Drawable.

00:39:44.676 --> 00:39:49.956 A:middle
But, oh, no, we can't
use Self, right?

00:39:49.956 --> 00:39:51.836 A:middle
Because we need to
stay heterogeneous.

00:39:52.176 --> 00:39:54.946 A:middle
And without Self, this is just

00:39:54.946 --> 00:39:57.846 A:middle
like implementing
Ordered with classes was.

00:39:58.756 --> 00:40:00.836 A:middle
We're now going to
force all Drawables


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:58.756 --> 00:40:00.836 A:middle
We're now going to
force all Drawables

00:40:01.136 --> 00:40:04.066 A:middle
to handle the heterogeneous
comparison case.

00:40:06.366 --> 00:40:08.606 A:middle
Fortunately, there's
a way out this time.

00:40:08.986 --> 00:40:13.286 A:middle
Unlike most symmetric
operations, equality is special

00:40:14.366 --> 00:40:16.626 A:middle
because there's an
obvious, default answer

00:40:16.626 --> 00:40:18.526 A:middle
when the types don't
match up, right?

00:40:18.526 --> 00:40:21.336 A:middle
We can say if you have
two different types,

00:40:21.636 --> 00:40:22.166 A:middle
they're not equal.

00:40:22.686 --> 00:40:27.516 A:middle
With that insight, we
can implement isEqualTo

00:40:27.516 --> 00:40:32.036 A:middle
for all Drawables when
they're Equatable.

00:40:32.726 --> 00:40:35.186 A:middle
Like this.

00:40:35.406 --> 00:40:36.316 A:middle
So, let me walk you through it.

00:40:37.546 --> 00:40:38.916 A:middle
The extension is
just what we said.

00:40:39.116 --> 00:40:48.036 A:middle
It's for all Drawables
that are Equatable.

00:40:49.046 --> 00:40:53.066 A:middle
Okay, first we conditionally
down-cast other

00:40:53.106 --> 00:40:53.876 A:middle
to the Self type.

00:40:54.486 --> 00:40:57.156 A:middle
Right? And if that
succeeds, then we can go ahead

00:40:57.156 --> 00:40:58.526 A:middle
and use equality comparison,

00:40:58.526 --> 00:41:00.496 A:middle
because we have an
Equatable conformance.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.526 --> 00:41:00.496 A:middle
because we have an
Equatable conformance.

00:41:01.466 --> 00:41:04.056 A:middle
Otherwise, the instances
are deemed unequal.

00:41:08.516 --> 00:41:12.876 A:middle
Okay, so, big picture,
what just happened here?

00:41:13.216 --> 00:41:15.996 A:middle
We made a deal with the
implementers of Drawable.

00:41:16.466 --> 00:41:19.426 A:middle
We said, 'If you
really want to go

00:41:19.426 --> 00:41:22.586 A:middle
and handle the heterogeneous
case, be my guest.

00:41:22.916 --> 00:41:24.746 A:middle
Go and implement isEqualTo.

00:41:25.636 --> 00:41:30.116 A:middle
But if you just want to just
use the regular way we express

00:41:30.116 --> 00:41:33.366 A:middle
homogeneous comparison,
we'll handle all the burdens

00:41:33.366 --> 00:41:36.356 A:middle
of the heterogeneous
comparison for you.'

00:41:38.116 --> 00:41:41.266 A:middle
So, building bridges
between the static

00:41:41.266 --> 00:41:44.336 A:middle
and dynamic worlds is a
fascinating design space,

00:41:44.836 --> 00:41:46.966 A:middle
and I encourage you
to look into more.

00:41:46.966 --> 00:41:51.986 A:middle
This particular problem we
solved using a special property

00:41:51.986 --> 00:41:55.556 A:middle
of equality, but the
problems aren't all like that,

00:41:55.906 --> 00:42:00.456 A:middle
and there's lots of really
cool stuff you can do.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:55.906 --> 00:42:00.456 A:middle
and there's lots of really
cool stuff you can do.

00:42:01.376 --> 00:42:04.226 A:middle
So, that property of equality
doesn't necessarily apply,

00:42:04.226 --> 00:42:06.196 A:middle
but what does apply
almost universally?

00:42:07.686 --> 00:42:08.696 A:middle
Protocol-based design.

00:42:10.126 --> 00:42:20.046 A:middle
Okay, so, I want to say a few
words before we wrap up about

00:42:20.046 --> 00:42:22.866 A:middle
when to use classes, because
they do have their place.

00:42:23.856 --> 00:42:26.656 A:middle
Okay? There are times when you
really do want implicit sharing,

00:42:27.206 --> 00:42:31.336 A:middle
for example, when the
fundamental operations

00:42:31.336 --> 00:42:34.676 A:middle
of a value type don't make any
sense, like copying this thing.

00:42:34.676 --> 00:42:35.906 A:middle
What would a copy mean?

00:42:35.906 --> 00:42:37.396 A:middle
If you can't figure
out what that means,

00:42:38.036 --> 00:42:40.426 A:middle
then maybe you really do want
it to be a reference type.

00:42:41.326 --> 00:42:42.776 A:middle
Or a comparison.

00:42:43.326 --> 00:42:43.886 A:middle
The same thing.

00:42:44.016 --> 00:42:46.106 A:middle
That's another fundamental
part of being a value.

00:42:46.786 --> 00:42:48.006 A:middle
So, for example, a Window.

00:42:48.676 --> 00:42:50.216 A:middle
What would it mean
to copy a Window?

00:42:50.476 --> 00:42:52.666 A:middle
Would you actually
want to see, you know,

00:42:52.666 --> 00:42:53.706 A:middle
a new graphical Window?

00:42:53.816 --> 00:42:55.266 A:middle
What, right on top
of the other one?

00:42:55.266 --> 00:42:56.986 A:middle
I don't know.

00:42:57.116 --> 00:42:58.876 A:middle
It wouldn't be part of
your view hierarchy.

00:42:59.976 --> 00:43:00.676 A:middle
Doesn't make sense.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.976 --> 00:43:00.676 A:middle
Doesn't make sense.

00:43:01.186 --> 00:43:04.146 A:middle
So, another case
where the lifetime

00:43:04.146 --> 00:43:09.116 A:middle
of your instance is tied to
some external side effect,

00:43:09.506 --> 00:43:11.686 A:middle
like files appearing
on your disk.

00:43:12.736 --> 00:43:17.286 A:middle
Part of this is because values
get created very liberally

00:43:17.286 --> 00:43:20.366 A:middle
by the compiler, and
created and destroyed,

00:43:20.626 --> 00:43:22.766 A:middle
and we try to optimize
that as well as possible.

00:43:23.616 --> 00:43:26.726 A:middle
It's the reference types that
have this stable identity,

00:43:26.726 --> 00:43:28.986 A:middle
so if you're going to make
something that corresponds

00:43:28.986 --> 00:43:31.986 A:middle
to an external entity,
you might want

00:43:32.116 --> 00:43:33.016 A:middle
to make it a reference type.

00:43:33.576 --> 00:43:38.706 A:middle
A class. Another case
is where the instances

00:43:38.706 --> 00:43:40.356 A:middle
of the abstraction
are just "sinks."

00:43:40.826 --> 00:43:42.536 A:middle
Like, our Renderers,
for example.

00:43:43.726 --> 00:43:47.966 A:middle
So, we're just pumping, we're
just pumping information

00:43:47.966 --> 00:43:49.606 A:middle
into that thing, into
that Renderer, right?

00:43:49.606 --> 00:43:50.976 A:middle
We tell it to draw a line.

00:43:52.136 --> 00:43:55.456 A:middle
So, for example, if you
wanted to make a TestRenderer

00:43:55.456 --> 00:44:00.636 A:middle
that accumulated the text
to output of these commands


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:55.456 --> 00:44:00.636 A:middle
that accumulated the text
to output of these commands

00:44:00.846 --> 00:44:03.606 A:middle
into a String instead of just
dumping them to the console,

00:44:03.996 --> 00:44:06.706 A:middle
you might do it like this.

00:44:06.916 --> 00:44:08.866 A:middle
But notice a couple
of things about this.

00:44:09.356 --> 00:44:12.336 A:middle
First, it's final, right?

00:44:13.146 --> 00:44:15.076 A:middle
Second, it doesn't
have a base class.

00:44:15.426 --> 00:44:16.446 A:middle
That's still a protocol.

00:44:17.066 --> 00:44:18.996 A:middle
I'm using the protocol
for the abstraction.

00:44:19.576 --> 00:44:25.306 A:middle
Okay, a couple of more cases.

00:44:27.706 --> 00:44:30.696 A:middle
So, we live in an
object-oriented world, right?

00:44:30.856 --> 00:44:33.656 A:middle
Cocoa and Cocoa Touch
deal in objects.

00:44:34.736 --> 00:44:36.066 A:middle
They're going to
give you baseclasses

00:44:36.146 --> 00:44:37.396 A:middle
and expect you to subclass them.

00:44:37.836 --> 00:44:40.756 A:middle
They're going to expect
objects in their APIs.

00:44:41.476 --> 00:44:43.576 A:middle
Don't fight the system, okay?

00:44:43.986 --> 00:44:45.086 A:middle
That would just be futile.

00:44:46.406 --> 00:44:51.226 A:middle
But, at the same time,
be circumspect about it.

00:44:51.976 --> 00:44:55.056 A:middle
You know, nothing in your
program should ever get too big,

00:44:55.056 --> 00:44:57.906 A:middle
and that goes for classes
just as well as anything else.

00:44:58.816 --> 00:45:01.826 A:middle
So, when you're refactoring
and factoring something


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.816 --> 00:45:01.826 A:middle
So, when you're refactoring
and factoring something

00:45:01.826 --> 00:45:07.216 A:middle
out of class, consider
using a value type instead.

00:45:07.576 --> 00:45:10.326 A:middle
Okay, to sum up.

00:45:10.976 --> 00:45:14.226 A:middle
Protocols, much greater than
superclasses for abstraction.

00:45:16.196 --> 00:45:21.126 A:middle
Second, protocol
extensions, this new feature

00:45:21.126 --> 00:45:23.286 A:middle
to let you do almost
magic things.

00:45:23.826 --> 00:45:27.716 A:middle
Third, did I mention you should
go see this talk on Friday?

00:45:29.786 --> 00:45:30.716 A:middle
Go see this talk on Friday.

00:45:31.576 --> 00:45:33.676 A:middle
Eat your vegetables.

00:45:34.826 --> 00:45:35.466 A:middle
Be like Crusty.

00:45:36.746 --> 00:45:37.346 A:middle
Thank you very much.

00:45:38.516 --> 00:45:42.516 A:middle
[Applause]

00:45:43.016 --> 00:45:51.576 A:middle
[Silence]

