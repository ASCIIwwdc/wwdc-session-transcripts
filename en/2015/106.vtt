WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:21.356 --> 00:00:22.976 A:middle
&gt;&gt; CHRIS LATTNER: Welcome
to What's New in Swift.

00:00:23.516 --> 00:00:28.596 A:middle
[ Applause ]

00:00:29.096 --> 00:00:30.096 A:middle
I'm Chris Lattner.

00:00:30.096 --> 00:00:31.886 A:middle
I'll start off this talk

00:00:31.886 --> 00:00:33.656 A:middle
and my colleague John
McCall will take you

00:00:33.656 --> 00:00:35.696 A:middle
through the second half to
take you through what's new.

00:00:36.626 --> 00:00:38.776 A:middle
Before we get going, I
thought it would be interesting

00:00:38.776 --> 00:00:41.466 A:middle
or helpful to look at what
we're trying to do here.

00:00:41.556 --> 00:00:44.456 A:middle
What are the goals and what are
the philosophies behind Swift 2?

00:00:45.426 --> 00:00:47.536 A:middle
We had three big things
we were going for.

00:00:48.276 --> 00:00:49.936 A:middle
First, fundamentals.

00:00:50.356 --> 00:00:53.036 A:middle
We want the core features
and the core behavior

00:00:53.036 --> 00:00:55.146 A:middle
of the language and
the tools to be great.

00:00:55.846 --> 00:00:58.696 A:middle
A lot of this is taking a
look at the feedback that many

00:00:58.696 --> 00:01:01.276 A:middle
of you have produced in
the process of using Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:58.696 --> 00:01:01.276 A:middle
of you have produced in
the process of using Swift.

00:01:01.616 --> 00:01:06.996 A:middle
So a lot of what this is is --

00:01:06.996 --> 00:01:09.756 A:middle
I want to thank you for
all the feedback you have.

00:01:10.156 --> 00:01:11.856 A:middle
You guys are continuing
to shape Swift

00:01:12.276 --> 00:01:14.686 A:middle
through all the great feedback
the producers have that use it.

00:01:15.916 --> 00:01:17.266 A:middle
Second up is safety.

00:01:18.096 --> 00:01:20.236 A:middle
Safety is a core value of Swift.

00:01:21.326 --> 00:01:24.466 A:middle
We really want it to be easy
to write safe code by default,

00:01:24.896 --> 00:01:26.466 A:middle
and we think that
the new availability

00:01:26.466 --> 00:01:29.396 A:middle
in error handling constructs
will be a great new way

00:01:29.396 --> 00:01:30.006 A:middle
to do this.

00:01:30.776 --> 00:01:32.086 A:middle
Third, beauty.

00:01:33.086 --> 00:01:34.516 A:middle
We want your code
to be beautiful.

00:01:34.966 --> 00:01:38.156 A:middle
As programmers, we work
with code all the time.

00:01:38.316 --> 00:01:40.006 A:middle
This is quite important to us.

00:01:40.386 --> 00:01:42.536 A:middle
We have added new things
to Swift making it easier

00:01:42.536 --> 00:01:44.776 A:middle
to write more beautiful
and natural code.

00:01:45.836 --> 00:01:48.706 A:middle
Today we'll talk about
five new things in Swift.

00:01:50.816 --> 00:01:53.246 A:middle
Before we get diving into
what's new in Swift 2,

00:01:53.246 --> 00:01:54.136 A:middle
I think it is important to point

00:01:54.136 --> 00:01:57.146 A:middle
out that Swift 1.2 was
also a huge update.

00:01:57.146 --> 00:01:58.976 A:middle
It was released just
three months ago.

00:01:59.606 --> 00:02:01.846 A:middle
Because of time limitations,
we don't have time


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.606 --> 00:02:01.846 A:middle
Because of time limitations,
we don't have time

00:02:01.846 --> 00:02:02.896 A:middle
to talk about it much.

00:02:02.896 --> 00:02:04.926 A:middle
But if you're interested and
you haven't seen it already,

00:02:04.926 --> 00:02:07.686 A:middle
check out the Swift
programming language book

00:02:08.116 --> 00:02:09.526 A:middle
and the Xcode 6 release notes.

00:02:10.666 --> 00:02:12.446 A:middle
Let's dive in and talk
about fundamentals.

00:02:13.656 --> 00:02:16.956 A:middle
Fundamentals is about
refining the core behavior

00:02:16.956 --> 00:02:18.366 A:middle
of the language and
how it works together.

00:02:19.026 --> 00:02:20.626 A:middle
So there are a lot of
little things here.

00:02:20.626 --> 00:02:23.806 A:middle
This will feel like a bit of a
random walk, but stick with me.

00:02:24.526 --> 00:02:25.586 A:middle
We'll start off with enums.

00:02:26.796 --> 00:02:29.656 A:middle
Enums are one of
Swift's best features.

00:02:29.656 --> 00:02:33.156 A:middle
Here I have an enum enumerating
some common household pets.

00:02:33.686 --> 00:02:37.656 A:middle
Enums are great because they're
simple to define and use.

00:02:38.666 --> 00:02:41.656 A:middle
On the other hand, if you have
played with them in a playground

00:02:41.656 --> 00:02:44.906 A:middle
or printed one out, you may
have been left wanting for more.

00:02:46.306 --> 00:02:49.036 A:middle
In Swift 2, enums now carry
enough reflection information

00:02:49.036 --> 00:02:50.466 A:middle
that you can print them,
and they work great.

00:02:51.516 --> 00:02:56.546 A:middle
[ Applause ]

00:02:57.046 --> 00:02:58.096 A:middle
&gt;&gt; CHRIS LATTNER: Next,
associated values.

00:02:59.056 --> 00:03:01.686 A:middle
Enums are also great because
they're the perfect model


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.056 --> 00:03:01.686 A:middle
Enums are also great because
they're the perfect model

00:03:01.686 --> 00:03:04.126 A:middle
for discriminated
union, which is great

00:03:04.126 --> 00:03:07.266 A:middle
when you have two values of
different types that you want

00:03:07.266 --> 00:03:08.796 A:middle
to store in one thing.

00:03:09.706 --> 00:03:12.086 A:middle
Right? Associated values are
very powerful, maybe you went

00:03:12.086 --> 00:03:14.826 A:middle
and tried to write the
obvious thing in either type.

00:03:15.446 --> 00:03:17.716 A:middle
This is a perfect way to
model this, but when you went

00:03:17.716 --> 00:03:20.796 A:middle
to use it, you got something
depressing like this.

00:03:22.076 --> 00:03:24.586 A:middle
Well, this has been very sad,
and none of us like this.

00:03:24.716 --> 00:03:26.816 A:middle
Now with Swift 2 it just works.

00:03:27.516 --> 00:03:32.546 A:middle
[ Applause ]

00:03:33.046 --> 00:03:34.836 A:middle
&gt;&gt; CHRIS LATTNER: Let's
talk about recursion.

00:03:34.836 --> 00:03:37.386 A:middle
Enums in Swift are actually
algebraic data types,

00:03:37.596 --> 00:03:38.666 A:middle
and in other languages,

00:03:38.666 --> 00:03:41.726 A:middle
recursive algebraic data
types are really powerful.

00:03:41.726 --> 00:03:42.846 A:middle
You can do some really
great things.

00:03:42.846 --> 00:03:44.966 A:middle
The problem is in Swift,

00:03:45.016 --> 00:03:47.096 A:middle
the values in an enum
are stored inline.

00:03:47.766 --> 00:03:49.246 A:middle
This means if you
have a recursive enum,

00:03:49.406 --> 00:03:51.966 A:middle
it has an infinite
size, which is hard

00:03:51.966 --> 00:03:53.536 A:middle
for our current devices to hold.

00:03:53.706 --> 00:03:54.296 A:middle
Maybe next year.

00:03:55.086 --> 00:03:58.386 A:middle
There are workarounds for this.

00:03:58.386 --> 00:04:02.006 A:middle
Everybody has seen probably
the box-type that you can turn


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.386 --> 00:04:02.006 A:middle
Everybody has seen probably
the box-type that you can turn

00:04:02.006 --> 00:04:04.166 A:middle
into a reference, but that
breaks pattern matching,

00:04:04.166 --> 00:04:05.236 A:middle
it is ugly and horrible.

00:04:05.776 --> 00:04:08.196 A:middle
With Swift 2, there
is a better way.

00:04:08.606 --> 00:04:10.796 A:middle
It didn't quite make
it into beta 1,

00:04:10.976 --> 00:04:11.946 A:middle
but coming soon you'll be able

00:04:11.946 --> 00:04:14.116 A:middle
to mark your cases
indirect allowing you

00:04:14.116 --> 00:04:16.656 A:middle
to express this naturally, and
pattern matching works great.

00:04:17.185 --> 00:04:20.125 A:middle
Let's move on and talk
about scoping [applause].

00:04:24.006 --> 00:04:26.546 A:middle
&gt;&gt; CHRIS LATTNER: So sometimes
you have a name that you want

00:04:26.546 --> 00:04:28.356 A:middle
to reuse or maybe a
resource that you want

00:04:28.356 --> 00:04:29.756 A:middle
to make sure is released early.

00:04:30.836 --> 00:04:32.976 A:middle
We have introduced a new
Do statement allowing you

00:04:33.186 --> 00:04:34.806 A:middle
to introduce an explicit scope.

00:04:35.546 --> 00:04:38.816 A:middle
In this case, we all have to
deal with Internet trolls now

00:04:38.866 --> 00:04:40.906 A:middle
and then, but we try
to keep them bound

00:04:40.906 --> 00:04:42.836 A:middle
as tightly as possible.

00:04:42.836 --> 00:04:44.866 A:middle
Do is really important
when we bring

00:04:44.866 --> 00:04:46.146 A:middle
up error handling
later in the talk.

00:04:46.766 --> 00:04:50.016 A:middle
But taking Do as a keyword led
to some potential ambiguity.

00:04:50.326 --> 00:04:52.046 A:middle
It's not ambiguity
for the compiler;

00:04:52.146 --> 00:04:53.966 A:middle
it's ambiguity as we read code.

00:04:54.896 --> 00:04:57.306 A:middle
You don't always see the bottom
of a big, long statement,

00:04:57.306 --> 00:04:58.546 A:middle
and we have a Do While loop.

00:04:59.856 --> 00:05:03.736 A:middle
To make it superclear by just
looking at the introducer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.856 --> 00:05:03.736 A:middle
To make it superclear by just
looking at the introducer

00:05:03.736 --> 00:05:08.026 A:middle
for a statement of what it does,
we want to make it superclear,

00:05:08.396 --> 00:05:09.676 A:middle
what something does by looking

00:05:09.676 --> 00:05:11.576 A:middle
at the introducer
keyword for the statement.

00:05:12.026 --> 00:05:15.646 A:middle
So we have taken the Do While
loop and renamed it to Repeat.

00:05:15.646 --> 00:05:18.866 A:middle
You can immediately tell from
the top it that it is a loop,

00:05:18.996 --> 00:05:19.966 A:middle
making it really
easy [applause].

00:05:20.336 --> 00:05:25.816 A:middle
&gt;&gt; CHRIS LATTNER: Let's
talk about option sets.

00:05:26.456 --> 00:05:29.546 A:middle
Option sets are a
lightweight, superefficient way

00:05:29.546 --> 00:05:31.186 A:middle
to represent a set of Booleans.

00:05:31.836 --> 00:05:33.786 A:middle
You may have seen them if you've
worked with various Cocoa APIs,

00:05:33.786 --> 00:05:36.886 A:middle
and you use the see the See
Like syntax to Or them together.

00:05:37.796 --> 00:05:39.786 A:middle
The basic syntax like this
is actually pretty nice.

00:05:40.146 --> 00:05:43.496 A:middle
The problem is, when you get
to the other syntaxes you end

00:05:43.496 --> 00:05:45.616 A:middle
up using, it is a bit less nice.

00:05:45.776 --> 00:05:48.066 A:middle
You create an empty-option
set with nil --

00:05:48.066 --> 00:05:50.296 A:middle
it doesn't make sense
because option sets

00:05:50.296 --> 00:05:52.466 A:middle
and optionals are
completely different concepts

00:05:52.466 --> 00:05:53.616 A:middle
and they're conflated together.

00:05:54.186 --> 00:05:57.006 A:middle
You extract them with bitwise
operations, which is a pain

00:05:57.006 --> 00:06:00.836 A:middle
and super error-prone, and
you can get it wrong easily.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:57.006 --> 00:06:00.836 A:middle
and super error-prone, and
you can get it wrong easily.

00:06:00.886 --> 00:06:02.796 A:middle
With Swift 2 we have
taken the option sets --

00:06:02.876 --> 00:06:06.596 A:middle
this is even worse, because
Swift 1.2 had a first-class set

00:06:06.596 --> 00:06:09.326 A:middle
type, and now the
combination of all

00:06:09.326 --> 00:06:12.006 A:middle
of this makes option sets seem
like an archaic throwback to C,

00:06:12.556 --> 00:06:13.696 A:middle
which they are [laughter].

00:06:15.726 --> 00:06:16.806 A:middle
&gt;&gt; CHRIS LATTNER: But
Swift 2 solves this.

00:06:16.806 --> 00:06:18.166 A:middle
It makes option sets set-like.

00:06:18.866 --> 00:06:20.926 A:middle
That means option sets
and sets are now formed

00:06:20.926 --> 00:06:21.686 A:middle
with square brackets.

00:06:22.226 --> 00:06:24.236 A:middle
That means you get empty
sets with an empty set

00:06:24.236 --> 00:06:27.566 A:middle
of square brackets, and you get
the full set of standard set API

00:06:27.566 --> 00:06:28.906 A:middle
to work with option sets.

00:06:28.906 --> 00:06:30.766 A:middle
It is supereasy and great.

00:06:31.516 --> 00:06:36.556 A:middle
[ Applause ]

00:06:37.056 --> 00:06:37.496 A:middle
&gt;&gt; CHRIS LATTNER:
Now, it is also nice

00:06:37.496 --> 00:06:39.186 A:middle
because you can define
your own option sets

00:06:39.186 --> 00:06:40.226 A:middle
in an easier way now.

00:06:40.956 --> 00:06:43.266 A:middle
Now all you have to do is
define your own set type,

00:06:43.456 --> 00:06:48.696 A:middle
or struct type, struct type for
your set, and have it conform

00:06:48.696 --> 00:06:53.086 A:middle
to the new option set type
protocol, find storage

00:06:53.086 --> 00:06:55.916 A:middle
to hold your bits, and
define the elements you want

00:06:55.916 --> 00:06:57.206 A:middle
for your option set.

00:06:58.366 --> 00:06:59.956 A:middle
With just a simple definition,

00:06:59.956 --> 00:07:01.956 A:middle
you now get all the
syntax we talked about.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.956 --> 00:07:01.956 A:middle
you now get all the
syntax we talked about.

00:07:02.576 --> 00:07:04.386 A:middle
The thing that's
supercool about this,

00:07:04.386 --> 00:07:05.966 A:middle
it doesn't require
any compiler matching.

00:07:06.246 --> 00:07:07.726 A:middle
This is done automatically

00:07:07.966 --> 00:07:10.276 A:middle
through a new feature called
Default Implementations

00:07:10.276 --> 00:07:13.816 A:middle
and Protocols provided
by option set type.

00:07:13.936 --> 00:07:16.496 A:middle
We don't have time to talk
about Default Implementations

00:07:16.496 --> 00:07:19.596 A:middle
and Protocols in detail here,
but we have a session talking

00:07:19.596 --> 00:07:21.566 A:middle
about protocols going
into it deeply.

00:07:21.566 --> 00:07:22.156 A:middle
It is great.

00:07:23.276 --> 00:07:26.956 A:middle
Let's talk about
functions and methods.

00:07:27.416 --> 00:07:30.206 A:middle
Swift unifies functions
and methods together

00:07:30.206 --> 00:07:31.456 A:middle
into a single func declaration.

00:07:31.866 --> 00:07:36.046 A:middle
This is a great thing that pulls
two disparate concepts together

00:07:36.046 --> 00:07:38.836 A:middle
in the type system into a
beautiful functional core.

00:07:39.576 --> 00:07:42.056 A:middle
This beautiful functional
core is a key part of Swift

00:07:42.236 --> 00:07:44.236 A:middle
that immediately falls
apart when you try

00:07:44.236 --> 00:07:46.776 A:middle
to call these things
because they take different

00:07:46.776 --> 00:07:48.956 A:middle
argument labels.

00:07:48.956 --> 00:07:50.926 A:middle
This has been a huge
pain for a lot of people.

00:07:51.046 --> 00:07:53.836 A:middle
If we look at where
this came from,

00:07:53.976 --> 00:07:56.626 A:middle
Swift was following the
precedent of Objective-C.

00:07:57.246 --> 00:07:58.806 A:middle
C doesn't have argument labels,

00:07:59.076 --> 00:08:00.886 A:middle
argument labels are
superimportant for methods


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.076 --> 00:08:00.886 A:middle
argument labels are
superimportant for methods

00:08:00.886 --> 00:08:02.766 A:middle
in Objective-C, and
Swift followed.

00:08:04.006 --> 00:08:06.116 A:middle
With Swift 2, we
fixed this and more.

00:08:06.946 --> 00:08:10.396 A:middle
Now functions and methods have
the same declaration syntax,

00:08:10.966 --> 00:08:12.326 A:middle
and they work the same way.

00:08:13.866 --> 00:08:15.646 A:middle
Now when you call
a global function,

00:08:15.646 --> 00:08:19.826 A:middle
you provide argument
labels by default.

00:08:19.826 --> 00:08:20.826 A:middle
Everything is uniform.

00:08:21.516 --> 00:08:25.686 A:middle
[ Applause ]

00:08:26.186 --> 00:08:27.446 A:middle
&gt;&gt; CHRIS LATTNER: So the
key thing to know here is

00:08:27.446 --> 00:08:29.226 A:middle
that this affects
pure Swift code.

00:08:29.226 --> 00:08:30.866 A:middle
If you declare a global
function in Swift,

00:08:30.866 --> 00:08:32.155 A:middle
you get this behavior
by default.

00:08:33.256 --> 00:08:35.506 A:middle
Functions imported from
C continue to behave

00:08:35.506 --> 00:08:38.466 A:middle
in the same way they always
have because argument names

00:08:38.466 --> 00:08:40.576 A:middle
in C functions are
not part of API

00:08:40.576 --> 00:08:42.166 A:middle
and are not thought
about as API.

00:08:43.006 --> 00:08:45.416 A:middle
But we like Swift
code going forward

00:08:45.416 --> 00:08:46.936 A:middle
to include argument
labels on functions.

00:08:47.786 --> 00:08:49.386 A:middle
If you look deeper
in what's going

00:08:49.386 --> 00:08:51.716 A:middle
on here, there is even more.

00:08:52.676 --> 00:08:55.216 A:middle
Swift functions take parameters,

00:08:55.526 --> 00:08:58.566 A:middle
parameters can have two
different names for each value.

00:08:58.566 --> 00:09:01.816 A:middle
So when you declare
something with the syntax,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.566 --> 00:09:01.816 A:middle
So when you declare
something with the syntax,

00:09:02.066 --> 00:09:03.636 A:middle
you're actually getting
a default behavior.

00:09:04.676 --> 00:09:08.266 A:middle
The two names that a parameter
can get are an external name

00:09:08.266 --> 00:09:10.476 A:middle
that the caller sees
and the internal name

00:09:10.476 --> 00:09:11.626 A:middle
that the implementation sees.

00:09:12.226 --> 00:09:16.406 A:middle
By default that first
argument has no label shown

00:09:16.406 --> 00:09:19.476 A:middle
to the external client of it and
has a name you're probably using

00:09:19.476 --> 00:09:20.426 A:middle
when you implement the method.

00:09:21.506 --> 00:09:24.656 A:middle
Likewise, the second and
later arguments all default

00:09:24.656 --> 00:09:26.396 A:middle
to being the same
inside and outside.

00:09:26.396 --> 00:09:28.356 A:middle
And that's why you
see this behavior

00:09:28.356 --> 00:09:30.506 A:middle
of having an argument
label for that argument.

00:09:31.236 --> 00:09:32.556 A:middle
The great thing about
this model is

00:09:32.556 --> 00:09:35.486 A:middle
that when you understand
this, you can customize it.

00:09:35.486 --> 00:09:39.236 A:middle
For example, in this case, it
would make sense to have a label

00:09:39.236 --> 00:09:42.126 A:middle
on that first argument
so you know what it is.

00:09:42.126 --> 00:09:44.936 A:middle
You can do that simply by
duplicating that argument name.

00:09:45.026 --> 00:09:45.646 A:middle
It is simple.

00:09:46.316 --> 00:09:47.896 A:middle
Similarly, if you want
to remove something,

00:09:47.896 --> 00:09:50.996 A:middle
you can explicitly set the
name of that to the underscore

00:09:50.996 --> 00:09:52.286 A:middle
to say remove this
argument label.

00:09:52.926 --> 00:09:54.576 A:middle
In doing so, we have
committed one

00:09:54.576 --> 00:09:56.816 A:middle
of the most heinous
naming crimes imaginable

00:09:56.816 --> 00:09:58.216 A:middle
by having a Boolean
without a label.

00:09:58.966 --> 00:10:05.386 A:middle
Go me! The even better
thing, this whole change,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.966 --> 00:10:05.386 A:middle
Go me! The even better
thing, this whole change,

00:10:05.386 --> 00:10:07.886 A:middle
this makes labels much more
prominent in the system.

00:10:07.886 --> 00:10:10.346 A:middle
This is great for having
APIs that are friendly to use

00:10:10.346 --> 00:10:13.916 A:middle
and means that we can simplify
away a ton of complexity.

00:10:14.386 --> 00:10:16.126 A:middle
So now functions and
methods work the same,

00:10:16.126 --> 00:10:18.116 A:middle
but we can also get
rid of special rules

00:10:18.116 --> 00:10:20.736 A:middle
for the default arguments and
there is the weird pound syntax,

00:10:20.736 --> 00:10:23.146 A:middle
nobody remembered what it
did, so now that's gone too.

00:10:23.146 --> 00:10:24.046 A:middle
It is much better.

00:10:25.776 --> 00:10:28.586 A:middle
We'll talk about the compiler
and talk about the warnings

00:10:28.586 --> 00:10:32.036 A:middle
and the error messages
compiled by the compiler.

00:10:32.036 --> 00:10:33.816 A:middle
Here is code that's
reasonable code,

00:10:33.816 --> 00:10:35.296 A:middle
maybe you have written
something like this before,

00:10:35.296 --> 00:10:37.646 A:middle
where I'm trying
to update a point.

00:10:37.826 --> 00:10:39.426 A:middle
If you gave this a
Swift 1 compiler,

00:10:39.426 --> 00:10:41.016 A:middle
it would produce
something like this.

00:10:41.476 --> 00:10:45.736 A:middle
I don't know about you, but
that's not helping much.

00:10:45.996 --> 00:10:48.436 A:middle
Swift 1.2 made this better.

00:10:48.436 --> 00:10:52.076 A:middle
Swift 1.2 made the error
message actually tell me

00:10:52.076 --> 00:10:53.066 A:middle
that there is a problem.

00:10:53.156 --> 00:10:55.756 A:middle
Now I see that indeed I
cannot assign to this.

00:10:56.156 --> 00:10:57.636 A:middle
Of course, this is not
good enough either.

00:10:57.796 --> 00:10:59.666 A:middle
We have continued to
invest in the error messages

00:10:59.666 --> 00:11:01.116 A:middle
and warnings produced
by the compiler,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.666 --> 00:11:01.116 A:middle
and warnings produced
by the compiler,

00:11:01.476 --> 00:11:04.136 A:middle
and in Swift 2 it says,
hey, you can't assign to x

00:11:04.136 --> 00:11:05.576 A:middle
because Self is immutable.

00:11:06.106 --> 00:11:08.646 A:middle
And Xcode will tell you
that you can fix this

00:11:08.696 --> 00:11:10.256 A:middle
by marking the method
as mutating.

00:11:11.186 --> 00:11:13.346 A:middle
This is a great way I
think many people --

00:11:13.346 --> 00:11:15.626 A:middle
it will help many people
understand the mutability model

00:11:15.626 --> 00:11:17.976 A:middle
in Swift better and lead
to better code everywhere.

00:11:18.516 --> 00:11:24.546 A:middle
[ Applause ]

00:11:25.046 --> 00:11:26.406 A:middle
&gt;&gt; CHRIS LATTNER: Of course,
this is just one example.

00:11:26.406 --> 00:11:27.286 A:middle
There is a bunch more.

00:11:27.676 --> 00:11:31.546 A:middle
Another example of
warnings we have added are

00:11:31.546 --> 00:11:34.806 A:middle
for if you have a variable that
can be declared as a constant,

00:11:34.806 --> 00:11:37.466 A:middle
we now produce a warning, say,
hey, use Let instead of Are.

00:11:37.936 --> 00:11:40.196 A:middle
The Swift migrator also
automatically moves a lot

00:11:40.196 --> 00:11:42.806 A:middle
of code to using Let
instead of Are in many cases.

00:11:42.806 --> 00:11:45.856 A:middle
We'll warn if you declare
a value, either Let

00:11:45.856 --> 00:11:47.716 A:middle
or Are, but don't use it.

00:11:48.266 --> 00:11:51.036 A:middle
We even have warnings if
you use a functional method

00:11:51.896 --> 00:11:53.976 A:middle
and then ignore the result
because you probably meant

00:11:53.976 --> 00:11:56.286 A:middle
to use an in-place
mutating method instead,

00:11:56.466 --> 00:11:57.846 A:middle
and we can produce
warnings for those.

00:11:58.036 --> 00:12:01.716 A:middle
Those are simple examples.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.036 --> 00:12:01.716 A:middle
Those are simple examples.

00:12:02.366 --> 00:12:05.746 A:middle
Let's talk about the SDK.

00:12:05.746 --> 00:12:08.816 A:middle
It's a core part of Swift, it's
how well it works with Cocoa.

00:12:09.076 --> 00:12:10.936 A:middle
With plain Objective-C APIs,

00:12:11.256 --> 00:12:13.976 A:middle
the Swift compiler has no idea
whether pointers can be null

00:12:13.976 --> 00:12:16.206 A:middle
or not and what the element
types of collections are.

00:12:16.866 --> 00:12:18.446 A:middle
We have introduced a
number of new features

00:12:18.446 --> 00:12:21.276 A:middle
to Objective-C including the
ability to express nullability

00:12:21.656 --> 00:12:24.746 A:middle
and the element types of
collections in Objective-C.

00:12:25.396 --> 00:12:27.616 A:middle
There is a whole bunch
of other features

00:12:28.136 --> 00:12:31.126 A:middle
that make a great experience
for Objective-C code in Swift.

00:12:31.956 --> 00:12:34.706 A:middle
The best news about this, is
that the framework engineers

00:12:34.706 --> 00:12:37.996 A:middle
at Apple have done a phenomenal
job adopting all these modern

00:12:37.996 --> 00:12:42.176 A:middle
Objective-C features, and
the Cocoa SDK in general

00:12:42.176 --> 00:12:44.466 A:middle
across all the platforms
feels great in Swift

00:12:44.466 --> 00:12:45.536 A:middle
with no work on your part.

00:12:46.576 --> 00:12:49.906 A:middle
However, if you have Objective-C
code, maybe you're mixing

00:12:49.906 --> 00:12:51.866 A:middle
and matching with Objective-C
code in your project,

00:12:52.206 --> 00:12:54.066 A:middle
or maybe you have an Objective-C
framework that you want

00:12:54.066 --> 00:12:56.396 A:middle
to be beautiful and
awesome in Swift,

00:12:56.396 --> 00:12:58.946 A:middle
go to some of these sessions
later today to learn more

00:12:58.946 --> 00:13:01.316 A:middle
about these features so you
can provide a really great


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.946 --> 00:13:01.316 A:middle
about these features so you
can provide a really great

00:13:01.496 --> 00:13:02.206 A:middle
Swift experience.

00:13:02.296 --> 00:13:04.586 A:middle
You probably have to watch
one of those on video.

00:13:05.146 --> 00:13:07.786 A:middle
Let's talk about unit testing.

00:13:08.346 --> 00:13:11.806 A:middle
Across the entire tools team,
testing is superimportant.

00:13:11.806 --> 00:13:16.006 A:middle
Testing is great in Swift until
you bring up access control.

00:13:16.566 --> 00:13:18.786 A:middle
The problem is that
Swift requires you

00:13:18.786 --> 00:13:22.426 A:middle
to mark symbols Public to be
visible to your unit test bundle

00:13:22.726 --> 00:13:25.376 A:middle
so you can test them, leading
to tons of stuff being public

00:13:25.376 --> 00:13:26.236 A:middle
that really shouldn't be.

00:13:26.686 --> 00:13:29.586 A:middle
Swift 2 and Xcode 7 has
solved this problem.

00:13:30.286 --> 00:13:32.486 A:middle
Now your code is automatically
built in a special mode,

00:13:32.786 --> 00:13:35.796 A:middle
meaning that for your tests they
can get access to your public

00:13:35.796 --> 00:13:37.636 A:middle
and internal symbols by default.

00:13:38.066 --> 00:13:39.676 A:middle
You have to use the
new app to --

00:13:40.516 --> 00:13:44.726 A:middle
[ Applause ]

00:13:45.226 --> 00:13:46.786 A:middle
&gt;&gt; CHRIS LATTNER: The
even better part of this,

00:13:46.786 --> 00:13:49.036 A:middle
not only is it easy,
it is also --

00:13:49.436 --> 00:13:51.546 A:middle
you still get the right behavior
for your release builds,

00:13:51.586 --> 00:13:52.666 A:middle
so you get the performance

00:13:52.666 --> 00:13:55.106 A:middle
and the protection
benefits of access control.

00:13:55.606 --> 00:13:57.826 A:middle
We have a bunch of
talks on testing,

00:13:57.826 --> 00:14:00.396 A:middle
UI Testing in Xcode will
be a fantastic talk.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.826 --> 00:14:00.396 A:middle
UI Testing in Xcode will
be a fantastic talk.

00:14:00.396 --> 00:14:01.156 A:middle
I highly recommend it.

00:14:01.716 --> 00:14:03.256 A:middle
Let's talk about rich comments.

00:14:04.036 --> 00:14:07.266 A:middle
Playgrounds, they're
great, and Xcode allows you

00:14:07.266 --> 00:14:09.676 A:middle
to build beautiful
Swift playgrounds right

00:14:09.676 --> 00:14:13.586 A:middle
in the editor using a comment
syntax, a rich comment syntax.

00:14:13.956 --> 00:14:17.176 A:middle
The syntax is a variant of
Markdown, which is a great,

00:14:17.176 --> 00:14:19.926 A:middle
well-known, very
popular, loved syntax.

00:14:20.276 --> 00:14:22.096 A:middle
We brought that to
documentation comments as well.

00:14:22.506 --> 00:14:24.416 A:middle
This means you can build rich

00:14:24.526 --> 00:14:28.186 A:middle
and pretty beautiful
documentation comments,

00:14:28.446 --> 00:14:30.016 A:middle
and it shows up for
clients in your API.

00:14:30.156 --> 00:14:31.316 A:middle
So if you're producing
a library,

00:14:31.366 --> 00:14:32.546 A:middle
you can do great things here.

00:14:33.636 --> 00:14:35.386 A:middle
Finally, the migrator in Xcode.

00:14:36.046 --> 00:14:38.996 A:middle
As soon as you open the
Swift 1 project in Xcode 7,

00:14:38.996 --> 00:14:40.456 A:middle
it will prompt you and say, hey,

00:14:40.726 --> 00:14:42.316 A:middle
I can upgrade this
to Swift 2 for you.

00:14:42.976 --> 00:14:44.336 A:middle
It takes you through
a couple steps,

00:14:44.336 --> 00:14:46.706 A:middle
you can pick your targets,
and then it gives you a dif.

00:14:47.216 --> 00:14:49.606 A:middle
The Swift 2 migrator is
actually pretty phenomenal.

00:14:49.836 --> 00:14:52.236 A:middle
It covers the vast majority
of the problems and cases

00:14:52.236 --> 00:14:55.516 A:middle
that you will see moving
from Swift 1 to Swift 2,

00:14:55.836 --> 00:14:58.506 A:middle
including the error handling
model, moving things to methods,

00:14:58.926 --> 00:15:03.216 A:middle
changes to the SDK, a ton
of the option set changes,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.926 --> 00:15:03.216 A:middle
changes to the SDK, a ton
of the option set changes,

00:15:03.216 --> 00:15:05.636 A:middle
all of these things are
built in the migrator,

00:15:05.636 --> 00:15:07.016 A:middle
and it does a great job.

00:15:08.046 --> 00:15:10.736 A:middle
There is a ton of new stuff
in Swift 2, we don't have time

00:15:10.736 --> 00:15:13.496 A:middle
to talk about all
of it right now.

00:15:13.496 --> 00:15:14.726 A:middle
If you're interested
in more detail,

00:15:14.726 --> 00:15:17.336 A:middle
I recommend taking a look at the
Swift programming language book,

00:15:17.336 --> 00:15:18.356 A:middle
there is a new version up.

00:15:19.196 --> 00:15:21.466 A:middle
Also the Xcode 7 release
notes talks about a lot

00:15:21.466 --> 00:15:22.636 A:middle
of these changes in more detail.

00:15:23.686 --> 00:15:25.636 A:middle
Let's move on now and talk
about pattern matching.

00:15:26.286 --> 00:15:30.726 A:middle
So probably the first place you
encounter pattern matches was

00:15:30.726 --> 00:15:31.846 A:middle
with the if-let statement.

00:15:32.326 --> 00:15:35.936 A:middle
It is a great way
to take an optional,

00:15:37.296 --> 00:15:39.466 A:middle
conditionally unwrap it,
and then bind that result

00:15:39.636 --> 00:15:42.096 A:middle
to a name with safety.

00:15:42.096 --> 00:15:44.326 A:middle
It is a great thing.

00:15:44.326 --> 00:15:46.426 A:middle
There can be too much of
a great thing, of course.

00:15:46.426 --> 00:15:49.636 A:middle
One of the things we saw is that
there is the "pyramid of doom,"

00:15:50.156 --> 00:15:52.936 A:middle
which is what happens when you
get too many if-lets all nestled

00:15:52.936 --> 00:15:55.076 A:middle
together, and suddenly your
code is fifteen levels deep

00:15:55.076 --> 00:15:57.526 A:middle
and you can't understand it.

00:15:57.526 --> 00:15:59.066 A:middle
Swift 1.2 solved this problem

00:15:59.066 --> 00:16:01.756 A:middle
by introducing a compound
condition into if statements.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.066 --> 00:16:01.756 A:middle
by introducing a compound
condition into if statements.

00:16:02.066 --> 00:16:03.336 A:middle
Which makes this really natural.

00:16:03.336 --> 00:16:04.966 A:middle
You can check multiple optionals

00:16:05.396 --> 00:16:08.996 A:middle
and Boolean conditions right
inline, and it is a lot nicer.

00:16:09.546 --> 00:16:11.506 A:middle
This didn't solve the
problem of early exits.

00:16:12.286 --> 00:16:16.126 A:middle
I'll show you some of what
might be the most horrible JSON

00:16:16.126 --> 00:16:18.186 A:middle
processing code you
can ever imagine.

00:16:18.716 --> 00:16:20.846 A:middle
It will get better over time.

00:16:20.846 --> 00:16:22.356 A:middle
Let's go with this.

00:16:22.356 --> 00:16:23.766 A:middle
Here I'm pulling various fields

00:16:23.766 --> 00:16:25.216 A:middle
out of an untyped
JSON dictionary.

00:16:25.346 --> 00:16:27.396 A:middle
So I'm pulling out a name,
converting it to string,

00:16:27.396 --> 00:16:29.726 A:middle
produces an optional, if it
doesn't match, I bail out.

00:16:30.336 --> 00:16:32.976 A:middle
Likewise, pull the year
out, convert it to an In,

00:16:33.016 --> 00:16:34.166 A:middle
if that doesn't match, bail out.

00:16:34.696 --> 00:16:36.986 A:middle
This pattern is very common
if you're pulling lots

00:16:36.986 --> 00:16:40.686 A:middle
of values out, it is better
to do this bailout approach

00:16:40.686 --> 00:16:42.226 A:middle
than to deeply nest your code.

00:16:43.046 --> 00:16:44.776 A:middle
The problem with this
approach is that then you have

00:16:44.806 --> 00:16:48.656 A:middle
to force unwrap the optional
values when you're done.

00:16:49.076 --> 00:16:51.076 A:middle
Here I only use them once,
but if you have a bunch

00:16:51.076 --> 00:16:53.946 A:middle
of code using them, you're force
unwrapping this everywhere.

00:16:53.946 --> 00:16:55.456 A:middle
You can do things
to factor this,

00:16:55.456 --> 00:16:57.696 A:middle
so the implicitly unwrapped
optional is a great way

00:16:57.696 --> 00:17:03.736 A:middle
to factor force unwraps into
a Mecca of unsafety for you.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:57.696 --> 00:17:03.736 A:middle
to factor force unwraps into
a Mecca of unsafety for you.

00:17:04.116 --> 00:17:07.016 A:middle
This is maybe not the
right approach either.

00:17:07.016 --> 00:17:08.396 A:middle
This is ugly.

00:17:08.546 --> 00:17:10.925 A:middle
We introduced a new
Guard statement.

00:17:11.096 --> 00:17:14.316 A:middle
The way to look at Guard is
it does a check and then bales

00:17:14.316 --> 00:17:17.036 A:middle
out if that check doesn't match.

00:17:17.096 --> 00:17:18.856 A:middle
You can do a lot of things
in a Guard statement.

00:17:18.896 --> 00:17:20.906 A:middle
Here we're doing
our optional check

00:17:20.906 --> 00:17:22.626 A:middle
and we're binding
a value to a name.

00:17:23.126 --> 00:17:25.016 A:middle
The way that it works,
the way it can work,

00:17:25.066 --> 00:17:29.786 A:middle
is that it guarantees that your
Else exits the current scope.

00:17:29.786 --> 00:17:33.416 A:middle
You can do this in one of two
ways, either return, throw,

00:17:33.416 --> 00:17:36.516 A:middle
brake, a lot of ways
to exit a scope.

00:17:37.796 --> 00:17:38.406 A:middle
That's fine.

00:17:38.656 --> 00:17:42.526 A:middle
You can also call a No Return
function like Precondition Fail

00:17:42.526 --> 00:17:44.736 A:middle
or Abort, and that's a
good way of stopping.

00:17:45.756 --> 00:17:49.366 A:middle
What this guarantees for the
compiler, it knows with safety

00:17:49.406 --> 00:17:52.596 A:middle
and certainty that the names
that are bound can be visible

00:17:52.596 --> 00:17:54.066 A:middle
after the code in
the fall-through.

00:17:54.746 --> 00:17:57.456 A:middle
If we take this to our
example, our example gets nicer

00:17:57.566 --> 00:18:00.246 A:middle
because now we can use
Guard, and we have very safe,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:57.566 --> 00:18:00.246 A:middle
because now we can use
Guard, and we have very safe,

00:18:00.346 --> 00:18:03.576 A:middle
concise checks for this
as we would expect.

00:18:04.776 --> 00:18:08.766 A:middle
The other nice thing about
this, this builds on the rich,

00:18:08.946 --> 00:18:12.376 A:middle
compound conditionals
we had with If.

00:18:12.376 --> 00:18:14.656 A:middle
Now you can merge them together
and check multiple Boolean

00:18:14.656 --> 00:18:17.866 A:middle
and optional and other cases
we'll talk about later right

00:18:17.866 --> 00:18:19.526 A:middle
in line in your Guard statement.

00:18:19.526 --> 00:18:20.886 A:middle
It is pretty nice.

00:18:21.516 --> 00:18:27.616 A:middle
[ Applause ]

00:18:28.116 --> 00:18:30.596 A:middle
&gt;&gt; CHRIS LATTNER: Let's
talk about the more exciting

00:18:30.596 --> 00:18:32.816 A:middle
and powerful form of
pattern matching, switches.

00:18:33.666 --> 00:18:37.476 A:middle
Switches are I think maybe
other people's favorite feature

00:18:37.476 --> 00:18:40.436 A:middle
of Swift because you can do
so much with pattern matching

00:18:40.436 --> 00:18:41.286 A:middle
in a switch statement.

00:18:41.626 --> 00:18:43.566 A:middle
You check against an
optional like here,

00:18:43.806 --> 00:18:45.746 A:middle
you can do class hierarchy
checks, you can check

00:18:45.746 --> 00:18:49.696 A:middle
against ranges, there is no end
to what you can do in a switch.

00:18:50.706 --> 00:18:53.616 A:middle
They're great when you want
to write a lot of cases,

00:18:53.696 --> 00:18:55.646 A:middle
but they're kind of
syntactically heavyweight

00:18:55.646 --> 00:18:56.956 A:middle
when you want to
check just one case.

00:18:56.956 --> 00:18:58.726 A:middle
They have to be exhaustive,

00:18:58.726 --> 00:19:00.716 A:middle
you have to have a
default, it is a pain.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.726 --> 00:19:00.716 A:middle
you have to have a
default, it is a pain.

00:19:00.716 --> 00:19:04.246 A:middle
What we have done, we have taken
the power of pattern matching

00:19:04.666 --> 00:19:06.416 A:middle
with switch and with
case and brought it

00:19:06.416 --> 00:19:08.336 A:middle
to the other control
statements in the language.

00:19:08.786 --> 00:19:12.086 A:middle
This example can be written
with a new If case, check,

00:19:12.086 --> 00:19:13.516 A:middle
and you can pattern match

00:19:13.516 --> 00:19:15.406 A:middle
and bind variable
names right in line.

00:19:16.516 --> 00:19:20.746 A:middle
[ Applause ]

00:19:21.246 --> 00:19:22.076 A:middle
&gt;&gt; CHRIS LATTNER: We
have gone further.

00:19:22.196 --> 00:19:25.276 A:middle
Another great statement in
Swift is the for...in loop.

00:19:25.666 --> 00:19:27.646 A:middle
So it's very common to
want to do some amount

00:19:27.646 --> 00:19:29.526 A:middle
of filtering in a for...in loop.

00:19:29.526 --> 00:19:30.656 A:middle
Some languages have gone so far

00:19:30.656 --> 00:19:32.796 A:middle
as to introduce entirely
new language constructs

00:19:32.796 --> 00:19:35.936 A:middle
like list comprehensions to
model this kind of pattern.

00:19:36.816 --> 00:19:38.006 A:middle
With Swift we have
done two things.

00:19:38.256 --> 00:19:39.656 A:middle
We have added the ability

00:19:39.656 --> 00:19:42.156 A:middle
to do a simple Boolean
a filter right inline

00:19:42.156 --> 00:19:43.196 A:middle
in your for...in statement.

00:19:43.906 --> 00:19:47.106 A:middle
But you can also do full-on
pattern matching right in your

00:19:47.106 --> 00:19:50.266 A:middle
for loop to give you
powerful conditions.

00:19:51.516 --> 00:19:55.656 A:middle
[ Applause ]

00:19:56.156 --> 00:19:57.666 A:middle
&gt;&gt; CHRIS LATTNER:
That's all I have to say

00:19:57.666 --> 00:19:59.396 A:middle
about our quick tour
of pattern matching.

00:19:59.726 --> 00:20:01.946 A:middle
We talked about the new Guard
statement, which is great


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.726 --> 00:20:01.946 A:middle
We talked about the new Guard
statement, which is great

00:20:01.946 --> 00:20:03.436 A:middle
for early exits, talked

00:20:03.436 --> 00:20:06.496 A:middle
about bringing pattern matching
pervasively to the language,

00:20:06.876 --> 00:20:08.816 A:middle
and we didn't talk about some
of the other improvements

00:20:08.816 --> 00:20:10.586 A:middle
that you can discover as
you start to use Swift.

00:20:11.186 --> 00:20:11.776 A:middle
Thank you.

00:20:11.776 --> 00:20:13.546 A:middle
I will hand it over to
John, who will tell you

00:20:13.546 --> 00:20:15.076 A:middle
about availability checking.

00:20:16.516 --> 00:20:20.946 A:middle
[ Applause ]

00:20:21.446 --> 00:20:21.876 A:middle
&gt;&gt; JOHN MCCALL: Thank
you, Chris.

00:20:23.546 --> 00:20:26.626 A:middle
We often roll out new
features, you may have heard

00:20:26.626 --> 00:20:28.206 A:middle
of one called Force Touch.

00:20:30.046 --> 00:20:33.376 A:middle
Force Touch is mostly a hardware
feature, of course, but it comes

00:20:33.376 --> 00:20:35.216 A:middle
with a number of APIs.

00:20:35.216 --> 00:20:36.976 A:middle
Like this one on NSButton,

00:20:37.456 --> 00:20:43.356 A:middle
letting me change how a button
responds to drags over it.

00:20:43.356 --> 00:20:46.296 A:middle
If I want to adopt
this in my own app,

00:20:46.896 --> 00:20:48.136 A:middle
that's pretty easy, right?

00:20:48.136 --> 00:20:50.516 A:middle
I have to write some
new event handling code

00:20:50.926 --> 00:20:52.516 A:middle
and then I just need
to take my button

00:20:52.516 --> 00:20:55.436 A:middle
and set this spring
loaded property on it.

00:20:56.236 --> 00:21:00.456 A:middle
The problem is that this may
work great on my dev machine,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:56.236 --> 00:21:00.456 A:middle
The problem is that this may
work great on my dev machine,

00:21:00.456 --> 00:21:03.126 A:middle
but when I farm it out
to my test hardware,

00:21:04.146 --> 00:21:06.266 A:middle
I'm going to get a crash
like this almost certainly.

00:21:07.006 --> 00:21:10.086 A:middle
That's because this
is a new API.

00:21:10.086 --> 00:21:12.156 A:middle
It was introduced in X v10.3.

00:21:12.706 --> 00:21:20.266 A:middle
And, like many of you in this
situation, you still have a need

00:21:20.316 --> 00:21:24.136 A:middle
to support an older
version of the OS.

00:21:24.136 --> 00:21:28.446 A:middle
How would I fix this?

00:21:28.446 --> 00:21:31.056 A:middle
The way I used to
fix this is, okay,

00:21:31.056 --> 00:21:34.736 A:middle
I'm getting this error message
about the method not existing,

00:21:34.736 --> 00:21:36.886 A:middle
let me check to see
if the method exists.

00:21:37.846 --> 00:21:39.726 A:middle
One way -- there are a
lot of different idioms

00:21:39.726 --> 00:21:42.446 A:middle
that people have
developed for doing this,

00:21:42.446 --> 00:21:46.386 A:middle
this is common idiom,
using Responds to Selector.

00:21:46.806 --> 00:21:50.516 A:middle
The problem is that this is a
fraught, error-prone pattern.

00:21:51.306 --> 00:21:57.586 A:middle
For example, I actually have to
figure out what the selector is,

00:21:57.676 --> 00:22:01.056 A:middle
the mapping from some
Swift language feature back


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.676 --> 00:22:01.056 A:middle
the mapping from some
Swift language feature back

00:22:01.056 --> 00:22:05.386 A:middle
to some Objective-C selector, it
is really not the sort of detail

00:22:05.386 --> 00:22:06.756 A:middle
that anybody should
need to know.

00:22:07.476 --> 00:22:11.336 A:middle
It is also, you know, not being
checked for me by the compiler

00:22:11.336 --> 00:22:14.166 A:middle
because I'm sort of
intrinsically escaping the sort

00:22:14.166 --> 00:22:15.546 A:middle
of checking that the
compiler provides.

00:22:16.446 --> 00:22:18.806 A:middle
For example, in this case
I have actually forgotten

00:22:18.806 --> 00:22:20.256 A:middle
to add this colon, which means

00:22:20.256 --> 00:22:22.696 A:middle
that check will never
actually be true.

00:22:23.426 --> 00:22:25.746 A:middle
In Swift 2 we have
a better solution.

00:22:26.666 --> 00:22:29.506 A:middle
By default, the compiler
is checking to make sure

00:22:29.506 --> 00:22:33.296 A:middle
that you don't use any
APIs that are not available

00:22:33.296 --> 00:22:36.936 A:middle
on your minimum deployment
target.

00:22:37.516 --> 00:22:42.546 A:middle
[ Applause ]

00:22:43.046 --> 00:22:44.016 A:middle
&gt;&gt; JOHN MCCALL: If I
do something like this,

00:22:44.016 --> 00:22:45.676 A:middle
I'm always going to
get a diagnostic.

00:22:46.086 --> 00:22:50.996 A:middle
What that lets me have is a
sort of safe core assumption

00:22:50.996 --> 00:22:52.466 A:middle
that as long as my code --

00:22:52.466 --> 00:22:55.786 A:middle
as long as my project fully
compiles, it is at least free

00:22:55.786 --> 00:22:58.336 A:middle
of this sort of trivial
deployment [unintelligible].

00:22:58.916 --> 00:23:02.256 A:middle
Now that's not the entirety
of the compatibility story,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.916 --> 00:23:02.256 A:middle
Now that's not the entirety
of the compatibility story,

00:23:02.256 --> 00:23:08.026 A:middle
of course, but this is a great
way to help you adopt new APIs.

00:23:08.026 --> 00:23:12.646 A:middle
I do want to use this.

00:23:12.736 --> 00:23:13.626 A:middle
How do I do that?

00:23:14.246 --> 00:23:17.716 A:middle
We added a new #available
condition.

00:23:18.536 --> 00:23:23.036 A:middle
In #available, you list out
the OS versions you want

00:23:23.036 --> 00:23:24.186 A:middle
to make sure you test for.

00:23:24.186 --> 00:23:27.076 A:middle
And at the end you use
this star to make sure

00:23:27.076 --> 00:23:29.686 A:middle
that if there are any new OSs

00:23:30.616 --> 00:23:32.606 A:middle
that you haven't
written this code for,

00:23:32.726 --> 00:23:35.526 A:middle
you at least get diagnostics
about the availability there.

00:23:36.866 --> 00:23:38.596 A:middle
Here I've used an If statement,

00:23:38.596 --> 00:23:40.726 A:middle
but I could have used
the Guard statement

00:23:40.726 --> 00:23:42.066 A:middle
that Chris showed us before.

00:23:42.066 --> 00:23:44.746 A:middle
It is the exact same
sort of condition logic

00:23:44.806 --> 00:23:45.716 A:middle
in all of these places.

00:23:45.756 --> 00:23:46.606 A:middle
That's it.

00:23:47.416 --> 00:23:49.646 A:middle
That's availability checking.

00:23:49.706 --> 00:23:52.776 A:middle
We think this is a great new
way for you to be able to adopt

00:23:52.776 --> 00:23:54.696 A:middle
and take advantage
of the new features

00:23:54.696 --> 00:23:58.306 A:middle
of new OSs automatically
and safely in your projects.

00:23:59.076 --> 00:24:01.406 A:middle
We'll talk more about this
in a talk later today.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.076 --> 00:24:01.406 A:middle
We'll talk more about this
in a talk later today.

00:24:01.406 --> 00:24:03.486 A:middle
I really suggest
that you come to it.

00:24:05.456 --> 00:24:08.216 A:middle
The next thing I want to talk
about is protocol extensions.

00:24:09.156 --> 00:24:11.866 A:middle
Extensions are a really
great feature in Swift.

00:24:12.496 --> 00:24:15.186 A:middle
I can take an arbitrary
type like Array

00:24:15.476 --> 00:24:17.376 A:middle
and add my own methods to it.

00:24:18.126 --> 00:24:23.556 A:middle
It is not necessarily obvious
why this is an important thing,

00:24:23.556 --> 00:24:29.276 A:middle
but a method is a core part,
it is how the native APIs

00:24:29.276 --> 00:24:31.336 A:middle
of that type are expressed.

00:24:31.616 --> 00:24:33.176 A:middle
When I'm adding an extension,

00:24:33.176 --> 00:24:36.286 A:middle
I'm really adding new
functionality to a type

00:24:36.586 --> 00:24:41.786 A:middle
that feels just as first
class, just as core to the API

00:24:41.786 --> 00:24:44.296 A:middle
of the type of anything
of the designer

00:24:44.296 --> 00:24:45.836 A:middle
of the type may have
already added.

00:24:46.486 --> 00:24:49.016 A:middle
That has a lot of advantages.

00:24:49.016 --> 00:24:54.536 A:middle
Here I've added a
Count If method,

00:24:54.536 --> 00:25:00.336 A:middle
that simply calls a closure for
every other array and counts


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:54.536 --> 00:25:00.336 A:middle
that simply calls a closure for
every other array and counts

00:25:00.336 --> 00:25:03.596 A:middle
up the number of times
that return True.

00:25:03.596 --> 00:25:07.176 A:middle
There is nothing in this
method that's actually specific

00:25:07.176 --> 00:25:08.006 A:middle
to array at all.

00:25:08.286 --> 00:25:10.646 A:middle
This ought to work for
an arbitrary collection.

00:25:12.116 --> 00:25:16.496 A:middle
Unfortunately, in Swift
1 I couldn't express this

00:25:16.496 --> 00:25:17.536 A:middle
as a method anymore.

00:25:18.126 --> 00:25:20.886 A:middle
To make this generic over
an arbitrary collection,

00:25:21.226 --> 00:25:23.026 A:middle
I would have had to write
something like this.

00:25:24.506 --> 00:25:26.296 A:middle
As a lot of you have
pointed out to us,

00:25:26.296 --> 00:25:28.396 A:middle
this is not exactly optimal.

00:25:28.906 --> 00:25:32.846 A:middle
The first thing is that this
is a lot of extra syntax,

00:25:32.846 --> 00:25:36.696 A:middle
there is sort of a blindness
about all of the angle brackets

00:25:36.696 --> 00:25:40.046 A:middle
in it, all of the extra crust
to just make this generic.

00:25:41.286 --> 00:25:44.506 A:middle
The second thing is it
is no longer a method.

00:25:45.316 --> 00:25:47.776 A:middle
Because it is no longer
a method, first off,

00:25:47.776 --> 00:25:50.896 A:middle
it doesn't feel like a
natural part of using the type.

00:25:51.526 --> 00:25:54.106 A:middle
Second off, it is a
lot less discoverable.

00:25:54.546 --> 00:25:58.136 A:middle
It won't show up in any lists
of the functionality on array,

00:25:58.476 --> 00:26:01.236 A:middle
and in particular it's not
going to show up in the list


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.476 --> 00:26:01.236 A:middle
and in particular it's not
going to show up in the list

00:26:01.326 --> 00:26:04.176 A:middle
of functionality provided
by code completion.

00:26:04.676 --> 00:26:09.796 A:middle
Which means that great, you
have written this awesome Count

00:26:09.796 --> 00:26:15.196 A:middle
If thing, but nobody using this
will realize it exists unless

00:26:15.196 --> 00:26:18.986 A:middle
you point it out to them.

00:26:19.186 --> 00:26:19.606 A:middle
All right.

00:26:19.606 --> 00:26:20.266 A:middle
Let's go back.

00:26:20.736 --> 00:26:24.166 A:middle
We had this extension on array
just to add the method to array.

00:26:24.496 --> 00:26:27.476 A:middle
Why can't we just
extend -- I don't know --

00:26:27.586 --> 00:26:30.686 A:middle
everything that implements
collection type?

00:26:30.686 --> 00:26:33.426 A:middle
In Swift 2, I'm happy
to say that now you can.

00:26:34.556 --> 00:26:38.976 A:middle
You extend collection type
rather than extending array.

00:26:39.626 --> 00:26:40.406 A:middle
When you do this,

00:26:40.406 --> 00:26:43.676 A:middle
you're automatically
adding the method everywhere

00:26:43.676 --> 00:26:46.256 A:middle
to every single type that
implements collection type,

00:26:46.576 --> 00:26:51.036 A:middle
not just from the standard
library or anything but even

00:26:51.376 --> 00:26:56.456 A:middle
in your own types that
happen to conform to this.

00:26:56.456 --> 00:26:59.496 A:middle
Not only is that great for
writing your own generic code,

00:26:59.496 --> 00:27:03.026 A:middle
but we found it really lets
us overhaul a lot of things


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.496 --> 00:27:03.026 A:middle
but we found it really lets
us overhaul a lot of things

00:27:03.026 --> 00:27:04.606 A:middle
that we weren't really
happy with about

00:27:04.606 --> 00:27:06.346 A:middle
with the standard
library in Swift 1.

00:27:07.416 --> 00:27:10.406 A:middle
There were a lot of
things in Swift 1 that had

00:27:10.556 --> 00:27:14.456 A:middle
to be global functions
because they had to be generic

00:27:14.546 --> 00:27:15.996 A:middle
or because we wrote
them generic.

00:27:16.746 --> 00:27:19.996 A:middle
Then worse, in order to
make the methods we sort

00:27:19.996 --> 00:27:23.656 A:middle
of special-cased certain
types, like array has a lot

00:27:23.656 --> 00:27:25.606 A:middle
of these map and
filter methods on it.

00:27:26.096 --> 00:27:29.036 A:middle
Other types like
Set may not have.

00:27:30.296 --> 00:27:34.706 A:middle
In Swift 2, this functionality
is going to be available,

00:27:34.936 --> 00:27:38.276 A:middle
this sort of filter and map
functionality is expressed

00:27:38.276 --> 00:27:42.826 A:middle
with extensions, meaning it is
available on every single thing.

00:27:42.826 --> 00:27:45.006 A:middle
It makes it a lot
more discoverable,

00:27:45.336 --> 00:27:48.466 A:middle
means using the standard
library is more uniform,

00:27:49.046 --> 00:27:51.096 A:middle
and we really think
that you'll love it.

00:27:52.516 --> 00:27:58.026 A:middle
[ Applause ]

00:27:58.526 --> 00:28:00.946 A:middle
&gt;&gt; JOHN MCCALL: I really
haven't even gone into a third


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.526 --> 00:28:00.946 A:middle
&gt;&gt; JOHN MCCALL: I really
haven't even gone into a third

00:28:00.946 --> 00:28:05.516 A:middle
of the complexity in the awesome
new power of this feature.

00:28:07.266 --> 00:28:09.366 A:middle
We're going to have a
talk dedicated to this,

00:28:09.476 --> 00:28:11.256 A:middle
it is a great talk tomorrow.

00:28:11.736 --> 00:28:14.206 A:middle
I strongly suggest
you come to it.

00:28:14.206 --> 00:28:17.506 A:middle
It is about the great
new design patterns

00:28:17.576 --> 00:28:19.386 A:middle
that protocols enable in Swift.

00:28:20.346 --> 00:28:22.376 A:middle
The rest of the talk is going
to be about error handling.

00:28:23.286 --> 00:28:25.466 A:middle
I don't think anyone
really likes thinking

00:28:25.466 --> 00:28:26.496 A:middle
about error handling.

00:28:26.496 --> 00:28:32.996 A:middle
It is always sort of this guilty
thing in the back of our minds

00:28:32.996 --> 00:28:36.666 A:middle
if you're at all like me.

00:28:36.666 --> 00:28:38.796 A:middle
It is really, really important.

00:28:38.796 --> 00:28:42.516 A:middle
When we were looking at
what we could do to Swift

00:28:42.906 --> 00:28:44.966 A:middle
that would really
make it a more robust,

00:28:44.966 --> 00:28:48.106 A:middle
more expressive language,
we said, okay,

00:28:48.106 --> 00:28:50.126 A:middle
the most important
thing here is going

00:28:50.126 --> 00:28:54.036 A:middle
to be doing something
about error handling.

00:28:54.036 --> 00:28:58.706 A:middle
When we looked at the
solutions that were out there,

00:28:58.706 --> 00:29:00.306 A:middle
in other languages, in Cocoa,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.706 --> 00:29:00.306 A:middle
in other languages, in Cocoa,

00:29:00.306 --> 00:29:03.186 A:middle
we weren't really
happy with any of them.

00:29:03.186 --> 00:29:06.876 A:middle
They all have sort
of major pitfalls

00:29:06.876 --> 00:29:08.266 A:middle
that we didn't really like.

00:29:09.316 --> 00:29:10.926 A:middle
Some of them, you know,

00:29:10.926 --> 00:29:13.966 A:middle
are based around propagating
the errors around automatically

00:29:13.966 --> 00:29:16.086 A:middle
like with NSError
in Objective-C,

00:29:16.396 --> 00:29:19.846 A:middle
what that creates is a lot of
repetitive error-prone code

00:29:19.846 --> 00:29:20.696 A:middle
where you end up having

00:29:20.696 --> 00:29:23.736 A:middle
to duplicate logic
all over the place.

00:29:24.006 --> 00:29:26.566 A:middle
That means it is very
easy to get wrong.

00:29:26.896 --> 00:29:29.606 A:middle
More importantly, when
you propagate error values

00:29:29.606 --> 00:29:34.796 A:middle
around yourself, the
implicit default behavior is

00:29:34.796 --> 00:29:36.546 A:middle
that you're ignoring errors.

00:29:37.086 --> 00:29:39.146 A:middle
That's just never
the right default.

00:29:39.436 --> 00:29:42.276 A:middle
You should have to think about
errors at least a little bit.

00:29:43.276 --> 00:29:45.456 A:middle
On the other end of the
spectrum, there are languages

00:29:45.516 --> 00:29:48.376 A:middle
that propagate errors
around implicitly,

00:29:48.916 --> 00:29:50.316 A:middle
like with exception handling.

00:29:50.366 --> 00:29:52.946 A:middle
But we didn't like how any
of those worked either.

00:29:52.946 --> 00:29:58.686 A:middle
There is too much that was
implicit, it was too easy not

00:29:58.686 --> 00:30:01.626 A:middle
to think of errors again,
and you end up with pitfalls


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:58.686 --> 00:30:01.626 A:middle
to think of errors again,
and you end up with pitfalls

00:30:01.626 --> 00:30:06.566 A:middle
where you just didn't
understand what could go wrong

00:30:06.566 --> 00:30:07.286 A:middle
in your program.

00:30:07.486 --> 00:30:10.786 A:middle
You didn't understand
how control could flow

00:30:10.786 --> 00:30:12.056 A:middle
from one place to another.

00:30:12.576 --> 00:30:16.106 A:middle
Again, it wasn't a safe,
reliable programming model.

00:30:16.636 --> 00:30:22.426 A:middle
There are really three different
ways that functions can fail.

00:30:23.796 --> 00:30:27.786 A:middle
One way is that they can simply
-- a lot of functions just fail

00:30:27.786 --> 00:30:32.486 A:middle
in one fairly simple,
innate, obvious way.

00:30:32.986 --> 00:30:35.016 A:middle
For example, unless
you're running a compiler,

00:30:35.086 --> 00:30:38.526 A:middle
you probably don't care
why parsing an integer

00:30:38.526 --> 00:30:41.236 A:middle
out of a string failed, this
isn't going to be something

00:30:41.236 --> 00:30:43.936 A:middle
that you're getting
the juicy details of

00:30:43.936 --> 00:30:45.276 A:middle
and reporting to the user.

00:30:45.556 --> 00:30:48.016 A:middle
Probably you want to
handle that directly.

00:30:48.786 --> 00:30:51.126 A:middle
That's already something
that when we looked at it,

00:30:51.256 --> 00:30:53.826 A:middle
this is handled extremely
well in Swift already,

00:30:53.896 --> 00:30:55.676 A:middle
just with optional results.

00:30:56.246 --> 00:30:58.146 A:middle
We didn't think we needed
to do anything here.

00:30:58.146 --> 00:31:00.066 A:middle
We're really happy with
how that works already.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.146 --> 00:31:00.066 A:middle
We're really happy with
how that works already.

00:31:00.526 --> 00:31:04.006 A:middle
On the other end of the
spectrum, there are a lot

00:31:04.006 --> 00:31:06.786 A:middle
of things that are logic
failures in your program

00:31:07.126 --> 00:31:09.996 A:middle
that are programmer
mistakes, assertions,

00:31:10.736 --> 00:31:14.326 A:middle
indexes out of bounds,
the vast majority of ways

00:31:14.326 --> 00:31:18.616 A:middle
in which people use
NSException, that kind of thing.

00:31:18.806 --> 00:31:21.276 A:middle
For these things, they
really actually shouldn't

00:31:21.336 --> 00:31:22.306 A:middle
be recoverable.

00:31:22.656 --> 00:31:25.026 A:middle
When you can recover
from this kind of thing,

00:31:25.026 --> 00:31:30.366 A:middle
you're just promoting a
less stable program overall.

00:31:30.656 --> 00:31:33.676 A:middle
You don't know what state
your program is actually

00:31:33.676 --> 00:31:37.166 A:middle
in if you randomly recover
from an index out of bounds.

00:31:37.566 --> 00:31:39.956 A:middle
You could even be
creating security problems

00:31:39.956 --> 00:31:40.956 A:middle
in your application.

00:31:41.516 --> 00:31:48.646 A:middle
In the middle, there is
this large spectrum of APIs

00:31:48.646 --> 00:31:51.606 A:middle
that can fail in a
very rich set of ways.

00:31:52.356 --> 00:31:54.276 A:middle
That's really what we
wanted to focus on.

00:31:54.576 --> 00:31:58.296 A:middle
The things that you today in
Cocoa would use NSError for.

00:31:58.296 --> 00:32:03.506 A:middle
I want to work through
an example for you.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.296 --> 00:32:03.506 A:middle
I want to work through
an example for you.

00:32:03.686 --> 00:32:05.926 A:middle
This is a preflight
method, I have some sort

00:32:05.926 --> 00:32:09.086 A:middle
of operation I want to
prefly to make sure it works.

00:32:09.126 --> 00:32:11.966 A:middle
This is something that a lot of
you have written I think before.

00:32:12.586 --> 00:32:15.546 A:middle
I'll check to see whether some
file is actually reachable,

00:32:15.546 --> 00:32:18.396 A:middle
and then I'm going to
reset some state associated

00:32:18.446 --> 00:32:20.556 A:middle
with the operation.

00:32:20.676 --> 00:32:23.396 A:middle
Now checking whether the
resource is reachable,

00:32:23.396 --> 00:32:25.616 A:middle
this is an operation
that can fail.

00:32:25.986 --> 00:32:28.036 A:middle
It can fail in a
wide variety of ways.

00:32:28.036 --> 00:32:30.426 A:middle
It should report
something back because, hey,

00:32:30.856 --> 00:32:32.786 A:middle
somebody calling
this really may want

00:32:32.786 --> 00:32:35.266 A:middle
to know why something
isn't reachable

00:32:35.496 --> 00:32:38.086 A:middle
and maybe treat it
differently depending on why.

00:32:38.656 --> 00:32:45.316 A:middle
If I wanted to use NSError
for this, this is kind

00:32:45.316 --> 00:32:46.836 A:middle
of what the code
ends up looking like.

00:32:47.206 --> 00:32:50.916 A:middle
I'm taking this error, I'm
propagating it out to my caller.

00:32:52.496 --> 00:32:56.206 A:middle
There are things
to like about this.

00:32:56.206 --> 00:32:58.296 A:middle
There are a lot of things
we don't really like.

00:32:59.346 --> 00:33:02.436 A:middle
It adds a lot of
boilerplate to my logic.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.346 --> 00:33:02.436 A:middle
It adds a lot of
boilerplate to my logic.

00:33:02.996 --> 00:33:08.356 A:middle
I had a tight little two-line
function, now it is turned

00:33:08.356 --> 00:33:10.916 A:middle
into this -- you know,
it has this If statement,

00:33:10.916 --> 00:33:13.016 A:middle
extra nesting, the
extra parameter,

00:33:13.016 --> 00:33:16.336 A:middle
there is a lot here
whose sole purpose is

00:33:16.336 --> 00:33:18.516 A:middle
to express there is an error,

00:33:18.746 --> 00:33:22.366 A:middle
and we're propagating
it out to the caller.

00:33:22.366 --> 00:33:28.016 A:middle
Worse, again, there
is a convention here,

00:33:28.596 --> 00:33:30.666 A:middle
that's a convention
you need to know about.

00:33:30.666 --> 00:33:33.416 A:middle
And it's a convention you
have to implement manually,

00:33:33.416 --> 00:33:36.866 A:middle
and the compiler's not really
going to help you with it.

00:33:37.336 --> 00:33:40.506 A:middle
Again, I made a mistake here.

00:33:40.976 --> 00:33:44.896 A:middle
The convention is that an error
happens when you return False,

00:33:44.896 --> 00:33:48.026 A:middle
I'm actually checking
it the wrong way.

00:33:48.386 --> 00:33:50.546 A:middle
I don't know why they
trust me to even work

00:33:50.546 --> 00:33:51.296 A:middle
with compilers [laughter].

00:33:54.136 --> 00:33:55.936 A:middle
I need to add this
Not here in order

00:33:55.936 --> 00:33:57.146 A:middle
to get the behavior I want.

00:33:58.426 --> 00:34:01.186 A:middle
Okay. That's -- well, no, sorry.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.426 --> 00:34:01.186 A:middle
Okay. That's -- well, no, sorry.

00:34:02.446 --> 00:34:03.786 A:middle
Those are the downsides of this.

00:34:03.786 --> 00:34:05.956 A:middle
There is actually a lot
that we like about it too.

00:34:07.446 --> 00:34:10.976 A:middle
The first thing is, it is
obvious from reading this code

00:34:11.396 --> 00:34:14.966 A:middle
that check resource is reachable
is something that can fail.

00:34:15.226 --> 00:34:17.476 A:middle
It says right there in the
name, it talks about errors,

00:34:17.795 --> 00:34:19.666 A:middle
it has the explicit
error handling thing,

00:34:19.936 --> 00:34:21.596 A:middle
this explicit error parameter.

00:34:22.735 --> 00:34:24.766 A:middle
Similarly, it is obvious

00:34:24.766 --> 00:34:26.985 A:middle
that preflight is an
operation that can fail.

00:34:27.206 --> 00:34:31.426 A:middle
Again, explicit error parameter,
the return value, et cetera.

00:34:32.676 --> 00:34:36.826 A:middle
The third thing is, there
isn't implicit control flow.

00:34:37.716 --> 00:34:40.396 A:middle
I can just look at this
thing and understand

00:34:41.596 --> 00:34:43.025 A:middle
where all the jumps in it are.

00:34:43.456 --> 00:34:48.065 A:middle
I can analyze my code statically
as a human, not as a compiler.

00:34:48.226 --> 00:34:51.036 A:middle
As a human, I can look
at this code and reason

00:34:51.036 --> 00:34:53.126 A:middle
about what it is
doing without needing

00:34:53.126 --> 00:34:54.886 A:middle
to know every last detail

00:34:54.886 --> 00:34:59.606 A:middle
of every single function
that I'm calling.

00:34:59.746 --> 00:35:00.026 A:middle
All right.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.746 --> 00:35:00.026 A:middle
All right.

00:35:00.706 --> 00:35:01.936 A:middle
Now let's go back
to the example.

00:35:02.076 --> 00:35:03.346 A:middle
This is how it looked before.

00:35:04.316 --> 00:35:07.026 A:middle
What's going to happen if I
try to compile this in Swift?

00:35:07.436 --> 00:35:10.846 A:middle
I'm going to get
an error message

00:35:10.906 --> 00:35:12.376 A:middle
because I'm not handling
the error.

00:35:13.876 --> 00:35:20.166 A:middle
There are two components to
handling errors in Swift.

00:35:20.976 --> 00:35:23.906 A:middle
The first is that whenever
you're calling an API

00:35:23.906 --> 00:35:26.726 A:middle
that can fail, you have
to use this Try keyword.

00:35:27.526 --> 00:35:30.986 A:middle
The Try communicates, it
is really there primarily

00:35:30.986 --> 00:35:32.256 A:middle
for someone reading the code.

00:35:32.466 --> 00:35:36.186 A:middle
It communicates to you, hey,
this is something that can fail.

00:35:36.576 --> 00:35:37.946 A:middle
That means when you're
coming back,

00:35:37.946 --> 00:35:40.026 A:middle
when you're maintaining
this in the future,

00:35:40.386 --> 00:35:42.786 A:middle
I know straight off --

00:35:43.656 --> 00:35:46.526 A:middle
Reset State, that's
not necessarily going

00:35:46.526 --> 00:35:49.246 A:middle
to be called every single
time to this function.

00:35:49.636 --> 00:35:51.726 A:middle
That may be a really
important thing for me to know.

00:35:52.076 --> 00:35:55.616 A:middle
When I'm writing this code in
the first place, it is something

00:35:55.616 --> 00:35:56.586 A:middle
for me to think about.

00:35:56.866 --> 00:36:01.466 A:middle
Hey, should Reset State be
called every single time I exit


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:56.866 --> 00:36:01.466 A:middle
Hey, should Reset State be
called every single time I exit

00:36:01.466 --> 00:36:01.956 A:middle
the function?

00:36:02.646 --> 00:36:03.766 A:middle
For a preflight operation?

00:36:03.766 --> 00:36:07.656 A:middle
Maybe. That alone isn't enough,

00:36:07.656 --> 00:36:10.026 A:middle
I'm not actually handling
the error in any way.

00:36:10.416 --> 00:36:15.116 A:middle
This is because in Swift, by
default, functions can't throw.

00:36:16.096 --> 00:36:19.516 A:middle
That's actually a really
core aspect of our design

00:36:20.996 --> 00:36:23.986 A:middle
because what it means
is errors are bounded.

00:36:24.546 --> 00:36:27.846 A:middle
You don't have to think about
literally everything being able

00:36:27.846 --> 00:36:30.466 A:middle
to throw an exception
like it can in Java or C#

00:36:30.556 --> 00:36:32.946 A:middle
or basically every
language using exceptions.

00:36:34.856 --> 00:36:39.036 A:middle
Instead, it is really
just very specific things

00:36:39.036 --> 00:36:42.076 A:middle
that you know you need to worry
about whether they can throw.

00:36:42.266 --> 00:36:43.846 A:middle
And when you call
them in your code,

00:36:43.846 --> 00:36:45.386 A:middle
it is always marked with Try.

00:36:45.666 --> 00:36:49.006 A:middle
That combination
communicates a lot.

00:36:49.266 --> 00:36:51.376 A:middle
Okay. Well, suppose I do want

00:36:51.376 --> 00:36:53.356 A:middle
to just propagate the
error out to my caller.

00:36:53.906 --> 00:36:57.386 A:middle
In order to do that, all I have
to do is tell the compiler, hey,

00:36:57.386 --> 00:37:00.036 A:middle
it is okay for this thing
to throw the error out.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.386 --> 00:37:00.036 A:middle
it is okay for this thing
to throw the error out.

00:37:00.716 --> 00:37:02.486 A:middle
I do that with throws.

00:37:03.156 --> 00:37:05.946 A:middle
That may not be how I
want to handle this.

00:37:06.086 --> 00:37:07.816 A:middle
This is a preflight operation.

00:37:08.066 --> 00:37:11.826 A:middle
I probably want to
just swallow the error

00:37:11.826 --> 00:37:14.096 A:middle
and tell whoever is
calling me whether

00:37:14.096 --> 00:37:15.476 A:middle
or not the preflight succeeded.

00:37:16.576 --> 00:37:18.436 A:middle
To do that, I have to handle it.

00:37:18.436 --> 00:37:21.156 A:middle
I handle it by writing
this Do Catch.

00:37:22.496 --> 00:37:26.946 A:middle
Any code that's within the Do,
any error arising within it,

00:37:26.946 --> 00:37:30.226 A:middle
is forwarded, sort of filtered
through all of the catches.

00:37:31.256 --> 00:37:33.786 A:middle
So what comes after
a catch, well,

00:37:34.726 --> 00:37:36.426 A:middle
anything that you could
write in a switch.

00:37:36.756 --> 00:37:41.526 A:middle
The entire power of Swift's
pattern matching syntax is

00:37:41.526 --> 00:37:44.266 A:middle
available in a catch.

00:37:44.436 --> 00:37:47.656 A:middle
As a very simple, common
syntactic refinement,

00:37:48.046 --> 00:37:54.306 A:middle
catches alone like this is
a shorthand for catching it

00:37:54.306 --> 00:37:58.326 A:middle
and binding this special
error variable to it.

00:37:58.326 --> 00:38:00.616 A:middle
I could also write a much
more elaborate thing.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.326 --> 00:38:00.616 A:middle
I could also write a much
more elaborate thing.

00:38:00.616 --> 00:38:04.826 A:middle
For example, I may want to
treat certain kinds of error

00:38:05.326 --> 00:38:10.556 A:middle
as special, maybe they're
acceptable in my preflight.

00:38:10.666 --> 00:38:13.646 A:middle
I don't know why the file
not existing would be okay,

00:38:13.646 --> 00:38:18.456 A:middle
maybe I really want to check
if it exists and, you know,

00:38:18.496 --> 00:38:21.586 A:middle
isn't actually usable for
some permissions reason.

00:38:21.956 --> 00:38:28.446 A:middle
If I wanted to, I can pattern
match against the error code

00:38:28.446 --> 00:38:34.326 A:middle
and domain directly like this.

00:38:34.536 --> 00:38:38.616 A:middle
As an aside, there is a third
way of "handling errors."

00:38:39.296 --> 00:38:43.916 A:middle
It does often happen that
you set up preconditions

00:38:44.416 --> 00:38:47.526 A:middle
such that you know that a
particular call to something

00:38:47.526 --> 00:38:52.096 A:middle
that can formally throw
can't actually throw.

00:38:52.096 --> 00:38:55.476 A:middle
For example, maybe this file
is actually in my app bundle

00:38:55.796 --> 00:39:02.736 A:middle
and I know that if I can't read
a file in my own app bundle,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:55.796 --> 00:39:02.736 A:middle
and I know that if I can't read
a file in my own app bundle,

00:39:03.026 --> 00:39:04.716 A:middle
something is really,
really wrong.

00:39:04.926 --> 00:39:07.336 A:middle
There's probably no real
way to recover from this.

00:39:08.386 --> 00:39:10.016 A:middle
So with this common pattern,

00:39:10.016 --> 00:39:11.686 A:middle
where you really
want a fatal error

00:39:11.686 --> 00:39:14.386 A:middle
because an error is thrown,

00:39:14.926 --> 00:39:20.386 A:middle
it has a very compact syntax
associated with it, this Try!

00:39:20.616 --> 00:39:25.186 A:middle
All that really does is creates
an assertion that the code

00:39:25.186 --> 00:39:29.606 A:middle
within the Try doesn't
actually throw.

00:39:29.946 --> 00:39:32.346 A:middle
If it does, your
program will crash just

00:39:32.346 --> 00:39:33.806 A:middle
like any sort of
assertion failure.

00:39:34.466 --> 00:39:36.806 A:middle
That's something that you
can debug very, very easily.

00:39:37.606 --> 00:39:39.426 A:middle
It is not something you
want to use all the time,

00:39:39.586 --> 00:39:44.826 A:middle
but when you need it, it
is really, really handy.

00:39:44.896 --> 00:39:47.536 A:middle
Going back a bit.

00:39:47.756 --> 00:39:48.626 A:middle
I caught an error.

00:39:49.546 --> 00:39:51.386 A:middle
What kind of thing is an error?

00:39:52.506 --> 00:39:54.676 A:middle
Well, we have a protocol built

00:39:54.676 --> 00:40:00.566 A:middle
in to the standard
library called ErrorType.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:54.676 --> 00:40:00.566 A:middle
in to the standard
library called ErrorType.

00:40:00.896 --> 00:40:05.916 A:middle
You can throw any value whose
type conforms to the ErrorType.

00:40:06.596 --> 00:40:07.886 A:middle
When you catch something,

00:40:09.046 --> 00:40:10.786 A:middle
that thing that you're
pattern matching

00:40:10.786 --> 00:40:13.836 A:middle
against is an arbitrary
value of ErrorType.

00:40:14.266 --> 00:40:15.966 A:middle
We think it is actually
really important

00:40:16.006 --> 00:40:22.076 A:middle
that we don't track errors more
precisely than just whether

00:40:22.076 --> 00:40:23.396 A:middle
or not an error was thrown.

00:40:23.396 --> 00:40:27.086 A:middle
It is not like Java, where you
end up with a pedantic list

00:40:27.086 --> 00:40:29.986 A:middle
of every single exception that
might have been thrown out

00:40:29.986 --> 00:40:32.736 A:middle
and then you end up with this
really complicated propagation

00:40:32.736 --> 00:40:34.456 A:middle
problem every time
you change errors.

00:40:36.016 --> 00:40:40.456 A:middle
Just tracking whether an error
can be thrown is usually good

00:40:40.456 --> 00:40:41.636 A:middle
enough, almost always.

00:40:42.016 --> 00:40:43.236 A:middle
We think this is a great model.

00:40:43.806 --> 00:40:47.626 A:middle
You can make your own
types conform to ErrorType.

00:40:47.626 --> 00:40:50.496 A:middle
This is a process
that's a lot easier

00:40:50.496 --> 00:40:52.326 A:middle
to do than it was in Cocoa.

00:40:53.896 --> 00:40:56.826 A:middle
Enums are a great way
of expressing this.

00:40:57.426 --> 00:41:00.496 A:middle
They're a great way to express
a group of related problems,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:57.426 --> 00:41:00.496 A:middle
They're a great way to express
a group of related problems,

00:41:00.876 --> 00:41:04.896 A:middle
just like they're -- you know,
so that's especially true

00:41:04.896 --> 00:41:10.176 A:middle
because you can associate data
with each case in an enum.

00:41:10.176 --> 00:41:12.346 A:middle
If I want to report a
richer error message

00:41:12.576 --> 00:41:15.256 A:middle
with maybe something
about the --

00:41:15.256 --> 00:41:18.286 A:middle
maybe I'm checking for some
invalid state and I want

00:41:18.286 --> 00:41:20.086 A:middle
to remember what the
invalid state was,

00:41:20.436 --> 00:41:25.046 A:middle
I can embed that directly in
my enum as an associated value

00:41:25.046 --> 00:41:28.306 A:middle
for that particular case.

00:41:28.506 --> 00:41:32.116 A:middle
All you need to do in order
to make an enum usable

00:41:32.876 --> 00:41:35.406 A:middle
as an error is make it
conform to ErrorType.

00:41:35.816 --> 00:41:38.596 A:middle
The compiler automatically
handles the details

00:41:38.596 --> 00:41:39.506 A:middle
of the synthesis.

00:41:39.996 --> 00:41:42.686 A:middle
This is much better
than the process

00:41:42.686 --> 00:41:46.516 A:middle
of creating a new NSError domain
and associating things with it.

00:41:46.516 --> 00:41:48.986 A:middle
We think that this will
really help you make great,

00:41:48.986 --> 00:41:52.156 A:middle
expressive error-throwing APIs

00:41:52.156 --> 00:41:53.996 A:middle
in your own code
when you need to.

00:41:57.716 --> 00:42:00.696 A:middle
Let's go back to that
example that Chris had


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:57.716 --> 00:42:00.696 A:middle
Let's go back to that
example that Chris had

00:42:00.696 --> 00:42:03.216 A:middle
up before, this JSON processor.

00:42:04.326 --> 00:42:07.286 A:middle
Here I'm returning an error
back using an Either type

00:42:07.286 --> 00:42:07.776 A:middle
in the string.

00:42:09.156 --> 00:42:11.896 A:middle
Let's make this look more
like it would in Swift.

00:42:12.926 --> 00:42:15.976 A:middle
The first thing is,
instead of the string,

00:42:16.236 --> 00:42:21.326 A:middle
I'll use that data error
enum I just talked about.

00:42:22.776 --> 00:42:25.716 A:middle
I just have to throw, use the
new throw statement in order

00:42:25.716 --> 00:42:28.126 A:middle
to throw those values,
and that just works.

00:42:29.166 --> 00:42:30.896 A:middle
The other side of this,
of course, is I'll need

00:42:30.896 --> 00:42:32.226 A:middle
to change the return type.

00:42:32.226 --> 00:42:34.116 A:middle
I'm no longer returning
an Either type.

00:42:34.486 --> 00:42:37.006 A:middle
This isn't something that
every single caller has

00:42:37.006 --> 00:42:40.446 A:middle
to carefully micromanage
the return value

00:42:40.446 --> 00:42:42.116 A:middle
of in order to check for errors.

00:42:43.486 --> 00:42:47.006 A:middle
I just change it so
that it returns Person

00:42:47.576 --> 00:42:50.506 A:middle
and is also a throwing method,
then I don't have to mess

00:42:50.506 --> 00:42:54.476 A:middle
around with these
little details.

00:42:54.696 --> 00:42:56.536 A:middle
Let's make a new
example that culls

00:42:56.576 --> 00:43:00.756 A:middle
that method we just created.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:56.576 --> 00:43:00.756 A:middle
that method we just created.

00:43:00.756 --> 00:43:05.336 A:middle
We parsed out, we have a snippet
of JSON, we parsed out a person.

00:43:06.236 --> 00:43:11.106 A:middle
Now we'll use that to parse out
an entire sales record involving

00:43:11.106 --> 00:43:16.466 A:middle
that person and some item.

00:43:17.666 --> 00:43:25.296 A:middle
Sometimes it happens that you
need to, you know, this is a bit

00:43:25.296 --> 00:43:26.196 A:middle
of a contrived example.

00:43:26.266 --> 00:43:31.176 A:middle
Sorry. Sometimes I want to
observe this kind of process.

00:43:31.176 --> 00:43:35.966 A:middle
I'm going to have some sort
of delegate, I'll let it know

00:43:35.966 --> 00:43:38.076 A:middle
that I have started
reading a sales record.

00:43:38.076 --> 00:43:42.456 A:middle
I have now told it
I started reading,

00:43:42.746 --> 00:43:45.646 A:middle
obviously I should tell it
when I'm finished reading.

00:43:45.646 --> 00:43:49.616 A:middle
I can add that code down here.

00:43:49.616 --> 00:43:53.996 A:middle
The problem is I'm not
doing anything right

00:43:54.106 --> 00:43:55.016 A:middle
with error handling.

00:43:55.366 --> 00:43:57.766 A:middle
It is really easy for
all of these -- like --

00:43:57.866 --> 00:44:01.186 A:middle
if my delegate actually has
Careful and Variants set


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:57.866 --> 00:44:01.186 A:middle
if my delegate actually has
Careful and Variants set

00:44:01.186 --> 00:44:04.736 A:middle
up around necessarily getting
called every single time --

00:44:05.226 --> 00:44:08.036 A:middle
getting called when
the sale finishes.

00:44:08.546 --> 00:44:11.196 A:middle
If my delegate has variance
it wants to maintain

00:44:11.196 --> 00:44:14.526 A:middle
about getting called on
both ends, I'll mess them

00:44:14.526 --> 00:44:16.296 A:middle
up if I actually
fail the process.

00:44:16.706 --> 00:44:18.826 A:middle
This is a sort of problem
that comes up a lot

00:44:18.926 --> 00:44:22.286 A:middle
and makes error handling
seem so fragile.

00:44:23.696 --> 00:44:27.176 A:middle
Okay. One way I could
solve this, of course,

00:44:27.286 --> 00:44:33.846 A:middle
is that I simply add my call
to Did End Reading Sale on both

00:44:33.846 --> 00:44:36.366 A:middle
of these throw sites
and then, of course,

00:44:36.366 --> 00:44:39.836 A:middle
I'm still not handling this
call down to Process Person.

00:44:39.876 --> 00:44:42.856 A:middle
In order to do something there,
I have to add this Do Catch.

00:44:43.976 --> 00:44:47.556 A:middle
This is a really, really --
one, this is incredibly verbose.

00:44:47.556 --> 00:44:50.376 A:middle
But it's also really error
prone because it is easy for me

00:44:50.376 --> 00:44:53.416 A:middle
to add new code to this,
new kinds of processing

00:44:53.726 --> 00:44:56.416 A:middle
that it then immediately
will get out of date

00:44:56.416 --> 00:44:57.896 A:middle
if I actually do something.

00:44:58.546 --> 00:45:02.756 A:middle
If I forget to add Did
End Reading Sale along


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.546 --> 00:45:02.756 A:middle
If I forget to add Did
End Reading Sale along

00:45:02.936 --> 00:45:04.646 A:middle
that particular path.

00:45:06.366 --> 00:45:08.486 A:middle
Swift 2 has a much
better option.

00:45:09.026 --> 00:45:11.466 A:middle
It is called Defer.

00:45:13.656 --> 00:45:16.766 A:middle
A Defer statement
creates an action.

00:45:17.656 --> 00:45:21.886 A:middle
When you execute it,
that action is going

00:45:21.886 --> 00:45:25.956 A:middle
to be executed no matter how
the current scope is left.

00:45:27.096 --> 00:45:30.976 A:middle
If I return out of it, if I fall
out of it, if I throw an error

00:45:30.976 --> 00:45:32.736 A:middle
out of it, no matter how,

00:45:33.676 --> 00:45:36.276 A:middle
I know that that thing
is going to be executed.

00:45:37.436 --> 00:45:40.066 A:middle
That means that as
someone reading this code,

00:45:40.476 --> 00:45:41.916 A:middle
maintaining this code,

00:45:42.216 --> 00:45:46.876 A:middle
I feel perfectly confident
Did End Reading Sale will be

00:45:46.876 --> 00:45:51.426 A:middle
executed no matter what I do
to finish reading the sale.

00:45:52.006 --> 00:45:54.636 A:middle
That's a really, really
valuable thing to know.

00:45:55.516 --> 00:46:06.696 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:55.516 --> 00:46:06.696 A:middle
[ Applause ]

00:46:07.196 --> 00:46:09.426 A:middle
&gt;&gt; JOHN MCCALL: I want to make a
quick note about implementation.

00:46:10.266 --> 00:46:14.946 A:middle
Some of you who are used to
exception handling may be aware

00:46:14.946 --> 00:46:18.306 A:middle
that exception handling in
many languages is implemented

00:46:18.306 --> 00:46:21.196 A:middle
in a way that's very,
very highly biased

00:46:21.276 --> 00:46:23.456 A:middle
against errors actually
being thrown.

00:46:23.956 --> 00:46:29.116 A:middle
It is often three, maybe even
four orders of magnitude slower

00:46:29.396 --> 00:46:34.306 A:middle
to return out of a function by
throwing an error than it is

00:46:34.356 --> 00:46:38.386 A:middle
to simply return out
in the normal manner.

00:46:38.506 --> 00:46:42.696 A:middle
Now, that's necessitated by some
aspects of the language designs.

00:46:42.826 --> 00:46:46.496 A:middle
It is not really something that
we wanted to imitate in Swift.

00:46:47.056 --> 00:46:50.706 A:middle
All you really need
to know here is

00:46:50.706 --> 00:46:54.546 A:middle
that the Swift implementation
here is far more balanced,

00:46:55.326 --> 00:46:59.206 A:middle
much more like, basically, an
If statement in the caller.

00:46:59.696 --> 00:47:02.926 A:middle
That means it is not completely
free in order to call something


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.696 --> 00:47:02.926 A:middle
That means it is not completely
free in order to call something

00:47:02.926 --> 00:47:03.866 A:middle
that can throw an error.

00:47:03.866 --> 00:47:06.916 A:middle
But it means that you
don't have to worry

00:47:06.916 --> 00:47:11.836 A:middle
about our error-handling
feature being so expensive

00:47:11.836 --> 00:47:16.946 A:middle
that you can't use it in
order for the actual reasons

00:47:16.946 --> 00:47:19.096 A:middle
that you need to if
you do need to care

00:47:19.096 --> 00:47:22.366 A:middle
about the efficiency
of the error path.

00:47:24.816 --> 00:47:27.756 A:middle
Finally, I just want
to note, Swift,

00:47:28.356 --> 00:47:31.426 A:middle
the Swift error handling
design works beautifully

00:47:31.626 --> 00:47:32.616 A:middle
with Cocoa APIs.

00:47:33.926 --> 00:47:38.556 A:middle
We automatically recognize the
most common conventions you see

00:47:38.616 --> 00:47:39.696 A:middle
in Cocoa.

00:47:39.696 --> 00:47:44.926 A:middle
For example, methods that
have an NSError Out parameter

00:47:44.926 --> 00:47:48.496 A:middle
and return Bool automatically
become throwing methods

00:47:48.496 --> 00:47:50.466 A:middle
and the Bool return
value goes away.

00:47:51.366 --> 00:47:55.826 A:middle
Similarly if it returns an
optional result, we recognize

00:47:55.826 --> 00:48:00.166 A:middle
that pattern as the nil
indicates an invalid thing,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:55.826 --> 00:48:00.166 A:middle
that pattern as the nil
indicates an invalid thing,

00:48:00.716 --> 00:48:06.786 A:middle
and it no longer returns an
optional result because the nil,

00:48:06.786 --> 00:48:09.466 A:middle
of course, is subsumed
within error handling.

00:48:10.516 --> 00:48:14.846 A:middle
[ Applause ]

00:48:15.346 --> 00:48:18.506 A:middle
&gt;&gt; JOHN MCCALL: Just with these
two very simple rules we found

00:48:18.506 --> 00:48:22.666 A:middle
that the vast, vast majority
of APIs in the system import

00:48:22.936 --> 00:48:26.436 A:middle
and automatically work with this
new Swift error handling model

00:48:26.846 --> 00:48:30.396 A:middle
seamlessly and beautifully, and
we think this is a great new way

00:48:30.396 --> 00:48:35.086 A:middle
to handle errors in Swift.

00:48:35.086 --> 00:48:37.336 A:middle
I really strongly suggest
that you check this out.

00:48:37.456 --> 00:48:39.226 A:middle
You probably don't really
have much of a choice,

00:48:39.296 --> 00:48:41.006 A:middle
they're all over the
place [laughter].

00:48:44.586 --> 00:48:47.066 A:middle
&gt;&gt; JOHN MCCALL: You know, we
really are proud of this design.

00:48:47.386 --> 00:48:50.886 A:middle
We think it is going to
greatly improve the robustness

00:48:51.156 --> 00:48:52.906 A:middle
and the expressiveness
of writing code

00:48:53.146 --> 00:48:56.566 A:middle
and let you design your own
APIs that work just wonderfully.

00:48:57.126 --> 00:48:59.576 A:middle
Let me sum up.

00:48:59.576 --> 00:49:04.196 A:middle
We have been working in Swift
2 really hard to present,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.576 --> 00:49:04.196 A:middle
We have been working in Swift
2 really hard to present,

00:49:04.376 --> 00:49:07.506 A:middle
to give you a new
language, really flesh

00:49:07.506 --> 00:49:13.376 A:middle
out the core aspects of
programming in Swift,

00:49:13.596 --> 00:49:17.546 A:middle
using the tools in
Swift, giving you a safer,

00:49:17.636 --> 00:49:22.626 A:middle
more robust environment, and
generally making things great.

00:49:24.596 --> 00:49:27.946 A:middle
An invaluable tool to
us, this entire time,

00:49:28.326 --> 00:49:29.666 A:middle
has been your feedback.

00:49:30.126 --> 00:49:31.896 A:middle
We really, really appreciate it.

00:49:32.126 --> 00:49:33.536 A:middle
We are listening, I promise.

00:49:35.546 --> 00:49:37.886 A:middle
If you have things to say to us,

00:49:38.246 --> 00:49:40.916 A:middle
of course you can
simply use bug reporter,

00:49:41.276 --> 00:49:47.066 A:middle
but you can also email Stefan
Lesser, come on the dev forums,

00:49:47.066 --> 00:49:49.056 A:middle
most of us are there
all the time.

00:49:49.346 --> 00:49:51.816 A:middle
We're really happy to
respond to any question,

00:49:52.136 --> 00:49:53.516 A:middle
hear your feedback about it.

00:49:53.846 --> 00:49:55.896 A:middle
We really, really value you.

00:49:57.116 --> 00:49:59.836 A:middle
Thank you very much [applause].


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:03.106 --> 00:50:04.966 A:middle
Have a great WWDC 2015.

00:50:05.516 --> 00:50:18.270 A:middle
[ Applause ]

