WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:10.066 --> 00:00:11.306 A:middle
&gt;&gt; Alright, good
morning everyone.

00:00:12.116 --> 00:00:13.926 A:middle
I'm Doug Davidson, and
I'm here to talk to you

00:00:13.926 --> 00:00:15.646 A:middle
about making your
app world ready.

00:00:18.236 --> 00:00:20.816 A:middle
So, the app store
is available in more

00:00:20.816 --> 00:00:23.026 A:middle
than 150 countries worldwide,

00:00:23.486 --> 00:00:26.906 A:middle
and if your application is
only targeted at one of them;

00:00:27.196 --> 00:00:29.566 A:middle
not only are you missing
out, but also a lot

00:00:29.566 --> 00:00:31.936 A:middle
of your potential users
are being deprived as well.

00:00:32.366 --> 00:00:36.566 A:middle
So, we're going to tell you how
with a little additional effort,

00:00:37.066 --> 00:00:39.236 A:middle
you can make your app ready
for international use.

00:00:40.106 --> 00:00:42.556 A:middle
The steps to go through
are fairly simple.

00:00:42.696 --> 00:00:45.476 A:middle
In many cases, we find
that what you have to watch

00:00:45.476 --> 00:00:48.416 A:middle
out for is assumptions
that you may be making;

00:00:48.526 --> 00:00:49.836 A:middle
maybe even unconsciously,

00:00:50.186 --> 00:00:52.406 A:middle
that just don't hold
everywhere in the world.

00:00:53.086 --> 00:00:55.466 A:middle
And, so we'll be
talking a lot about that.

00:00:55.506 --> 00:00:58.186 A:middle
Often, it's not things you don't
know that will hurt so much,

00:00:58.186 --> 00:01:00.266 A:middle
as the things you do
know that just aren't so.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:02.146 --> 00:01:05.476 A:middle
Now, there are some
genuine challenges here.

00:01:05.476 --> 00:01:09.706 A:middle
Our customers around the world
use many different languages,

00:01:09.756 --> 00:01:11.276 A:middle
many different writing systems,

00:01:11.696 --> 00:01:13.866 A:middle
and they have often
significantly different

00:01:13.866 --> 00:01:18.246 A:middle
expectations after the
presentation of items like dates

00:01:18.246 --> 00:01:19.616 A:middle
and times and numbers.

00:01:20.046 --> 00:01:23.916 A:middle
But, fortunately, the frameworks
are designed to handle this,

00:01:23.916 --> 00:01:24.756 A:middle
if you work with them.

00:01:25.396 --> 00:01:28.216 A:middle
Now, I say frameworks,
it's important to note

00:01:28.476 --> 00:01:30.366 A:middle
that almost everything
we're going talk

00:01:30.366 --> 00:01:34.226 A:middle
about here today applies
to both iOS and OS X.

00:01:34.226 --> 00:01:37.546 A:middle
Now, we're going to do
this in three parts.

00:01:37.826 --> 00:01:39.596 A:middle
The first is about localization.

00:01:40.006 --> 00:01:42.996 A:middle
Localization refers
to the language

00:01:43.446 --> 00:01:45.906 A:middle
in which you application's
user interface is presented.

00:01:47.116 --> 00:01:50.266 A:middle
Your job as a developer
is to make sure

00:01:50.266 --> 00:01:53.566 A:middle
that your application is
localizable, so that you can go

00:01:53.566 --> 00:01:56.776 A:middle
to the localizer, who
will translate the text

00:01:56.776 --> 00:01:59.786 A:middle
in your user interface into
any particular language,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:00.326 --> 00:02:03.526 A:middle
then all you have to do is
decide how many languages you

00:02:03.526 --> 00:02:04.406 A:middle
want to do this for.

00:02:05.536 --> 00:02:08.716 A:middle
Second, we'll talk about
locale data, and that refers

00:02:08.716 --> 00:02:11.856 A:middle
to presenting things like
dates and times and numbers

00:02:11.856 --> 00:02:13.646 A:middle
in a way that's intelligible
to people

00:02:13.646 --> 00:02:15.066 A:middle
in that particular region.

00:02:16.026 --> 00:02:18.366 A:middle
And, finally, we'll talk
about handling texts

00:02:18.446 --> 00:02:20.956 A:middle
and all the different writing
systems used around the world.

00:02:20.956 --> 00:02:26.336 A:middle
There are two main settings
that are involved here,

00:02:26.536 --> 00:02:28.506 A:middle
and this is what they
look like on iOS.

00:02:29.106 --> 00:02:31.796 A:middle
The first is the user's
language preference,

00:02:31.936 --> 00:02:33.016 A:middle
and that's what determines

00:02:33.016 --> 00:02:35.546 A:middle
which localization
your app will run in,

00:02:36.616 --> 00:02:39.696 A:middle
and the second is the
user's region preference,

00:02:40.166 --> 00:02:43.966 A:middle
which determines what their
locale settings will be.

00:02:44.516 --> 00:02:49.806 A:middle
On OS X Mavericks, we have
an entirely new pref pane

00:02:49.856 --> 00:02:50.866 A:middle
for handling this.

00:02:50.866 --> 00:02:52.766 A:middle
It's designed to streamline it,

00:02:52.766 --> 00:02:55.336 A:middle
and make changing
the settings simple,

00:02:55.336 --> 00:02:56.556 A:middle
and make it all more logical.

00:02:56.796 --> 00:02:57.556 A:middle
It's very similar.

00:02:57.626 --> 00:03:00.136 A:middle
You have the user's
language preference again

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:00.136 --> 00:03:02.416 A:middle
that determines what
localizations will be used,

00:03:03.006 --> 00:03:04.376 A:middle
and the user region preference

00:03:04.486 --> 00:03:06.136 A:middle
that determines the
locale settings.

00:03:06.556 --> 00:03:10.896 A:middle
Additionally, on OS X,
there is an advanced sheet

00:03:10.956 --> 00:03:14.106 A:middle
that allows the user to
customize in great detail,

00:03:14.106 --> 00:03:17.866 A:middle
if they want to, any of the
various settings that are part

00:03:17.866 --> 00:03:19.096 A:middle
of their locale preferences.

00:03:20.126 --> 00:03:23.706 A:middle
So, to start off with, we'll
talk about localization.

00:03:23.706 --> 00:03:26.756 A:middle
I'll bring up my colleague,
Albert Lund to talk about that.

00:03:27.516 --> 00:03:31.896 A:middle
[ Applause ]

00:03:32.396 --> 00:03:34.616 A:middle
&gt;&gt; Hello, I'm going to be
talking about localization,

00:03:34.926 --> 00:03:36.826 A:middle
and what localization is,

00:03:36.826 --> 00:03:38.966 A:middle
is that it translates
your application

00:03:38.966 --> 00:03:41.536 A:middle
from its current language
to another language,

00:03:41.876 --> 00:03:45.296 A:middle
so your app can provide much
more exposure and visibility

00:03:45.296 --> 00:03:47.106 A:middle
to other markets
around the world,

00:03:47.106 --> 00:03:49.676 A:middle
leading to more downloads
for your app.

00:03:49.676 --> 00:03:53.526 A:middle
It's also about adapting your
application to cultural norms

00:03:53.526 --> 00:03:56.756 A:middle
in those regions, so you
can provide the same level

00:03:56.756 --> 00:04:01.056 A:middle
of user experience for
all users of your app.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:01.696 --> 00:04:03.626 A:middle
Now, today, I'm going
to be talking about how

00:04:03.626 --> 00:04:07.026 A:middle
to use our tools and X codes
to localize your application,

00:04:07.426 --> 00:04:09.376 A:middle
as well as some common
mistakes and issues

00:04:09.376 --> 00:04:11.676 A:middle
that may occur when localizing.

00:04:13.186 --> 00:04:17.286 A:middle
So, here's your project is
structured for localization.

00:04:17.576 --> 00:04:21.156 A:middle
You have your single binary,
which is your header files,

00:04:21.156 --> 00:04:23.446 A:middle
your implementation files,
and libraries you call,

00:04:23.666 --> 00:04:26.006 A:middle
and you only have one
set of these files.

00:04:27.386 --> 00:04:31.486 A:middle
You also have localization
folders alongside your binary,

00:04:31.666 --> 00:04:34.236 A:middle
and these are folders
called L proj folders,

00:04:34.236 --> 00:04:36.476 A:middle
or your language
specific project folders.

00:04:37.116 --> 00:04:40.986 A:middle
Each localization is placed
into one of these folders,

00:04:40.986 --> 00:04:45.596 A:middle
and it's abbreviated
by the language.

00:04:45.596 --> 00:04:49.416 A:middle
So, for example, the English
location is EN, French is FR,

00:04:49.666 --> 00:04:51.346 A:middle
Spanish is ES and so on.

00:04:52.166 --> 00:04:54.216 A:middle
All of these localizations
are then placed

00:04:54.216 --> 00:04:55.846 A:middle
into your single app bundle,

00:04:56.196 --> 00:04:58.226 A:middle
and one of these will
get loaded at runtime.

00:04:59.056 --> 00:05:01.476 A:middle
Whichever one gets loaded
at run time is determined

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:01.476 --> 00:05:03.916 A:middle
by what the user selected
system language is.

00:05:03.916 --> 00:05:05.706 A:middle
So, if the user's
language is Spanish,

00:05:05.706 --> 00:05:07.086 A:middle
the Spanish localization
gets loaded.

00:05:07.086 --> 00:05:10.496 A:middle
So, here's how your
project is structured.

00:05:10.496 --> 00:05:13.416 A:middle
You can see that the L proj
folders are alongside your

00:05:13.416 --> 00:05:15.906 A:middle
implication files
and your localizers

00:05:15.906 --> 00:05:18.836 A:middle
or your translators just have
to modify these folders only;

00:05:18.836 --> 00:05:20.196 A:middle
they don't need to
touch anything else.

00:05:21.496 --> 00:05:24.736 A:middle
These folders contain things
such as your strings files,

00:05:24.736 --> 00:05:27.496 A:middle
which contains things such
as your user visible text,

00:05:27.896 --> 00:05:30.486 A:middle
as well as any resource
files, such as images

00:05:30.486 --> 00:05:32.886 A:middle
and anything else you might
want to use for localization.

00:05:32.886 --> 00:05:36.776 A:middle
So, let's get started on
how to localize things

00:05:36.776 --> 00:05:39.776 A:middle
such as your interface files or
your nib files or storyboards.

00:05:40.546 --> 00:05:43.206 A:middle
The old way to do this, and
you can still do this today,

00:05:43.206 --> 00:05:46.196 A:middle
is to make a copy of
every single nib file

00:05:46.196 --> 00:05:47.956 A:middle
for every single
localization you have.

00:05:48.626 --> 00:05:50.116 A:middle
Your localizers then just open

00:05:50.116 --> 00:05:52.746 A:middle
and modify the specific
interface file

00:05:52.746 --> 00:05:55.486 A:middle
for that specific
localization, modify the text

00:05:55.486 --> 00:05:57.456 A:middle
so it's localized, and make sure

00:05:57.456 --> 00:05:59.016 A:middle
that everything surrounding
it looks good

00:05:59.016 --> 00:06:00.386 A:middle
and works for this interface.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:01.466 --> 00:06:03.166 A:middle
Like I said, while
these work today,

00:06:03.166 --> 00:06:04.326 A:middle
if you want to localize
this way,

00:06:04.326 --> 00:06:06.666 A:middle
you can see this
gets very cumbersome,

00:06:06.666 --> 00:06:10.666 A:middle
and can be very time consuming
for you and your localizers,

00:06:10.886 --> 00:06:13.076 A:middle
so we highly recommend
you use this method called

00:06:13.156 --> 00:06:14.366 A:middle
base internationalization.

00:06:15.386 --> 00:06:19.116 A:middle
With base internationalization,
you only need to modify one set

00:06:19.216 --> 00:06:21.406 A:middle
of storyboards and nib files,
so you don't have to worry

00:06:21.406 --> 00:06:23.686 A:middle
about localization when it
comes to your interface.

00:06:24.556 --> 00:06:26.906 A:middle
Every single time you
create a new localization,

00:06:27.506 --> 00:06:29.676 A:middle
a strings file, which
basically takes all

00:06:29.676 --> 00:06:34.286 A:middle
of the user visible text out of
your nib file, is then placed

00:06:34.286 --> 00:06:36.166 A:middle
into those specific
language folders,

00:06:36.546 --> 00:06:40.026 A:middle
and your localizer just has to
modify those, the text only.

00:06:40.076 --> 00:06:41.446 A:middle
They don't need to touch
your interface at all.

00:06:42.556 --> 00:06:45.446 A:middle
Now, it's highly recommended
that you should use auto layout

00:06:45.446 --> 00:06:46.846 A:middle
for base internationalization,

00:06:46.846 --> 00:06:48.896 A:middle
and I'll explain what auto
layout is in a moment.

00:06:49.406 --> 00:06:52.926 A:middle
But, here's an example how base
internationalization works.

00:06:53.026 --> 00:06:54.506 A:middle
I have my one nib file here,

00:06:54.886 --> 00:06:58.136 A:middle
and this is my base
internationalization file.

00:06:58.816 --> 00:07:01.666 A:middle
As a developer, I only need
to modify this one file,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:02.056 --> 00:07:04.456 A:middle
and every single time I
create a new localization,

00:07:04.496 --> 00:07:06.646 A:middle
a strings file is then
generated for every single one.

00:07:07.486 --> 00:07:11.256 A:middle
From there on, my localizers
then do not touch anything

00:07:11.256 --> 00:07:12.146 A:middle
involving my interface.

00:07:12.206 --> 00:07:13.756 A:middle
They only need to
modify the strings,

00:07:13.756 --> 00:07:16.526 A:middle
and that's really convenient.

00:07:17.816 --> 00:07:19.506 A:middle
So, what's auto layout.

00:07:20.126 --> 00:07:23.826 A:middle
Auto layout is a way to define
the constraints between text

00:07:23.826 --> 00:07:26.766 A:middle
and anything surrounding your
text, such as text views,

00:07:26.766 --> 00:07:28.596 A:middle
UIImageViews, and
pretty much anything

00:07:28.886 --> 00:07:29.816 A:middle
that surrounds the text.

00:07:30.526 --> 00:07:33.806 A:middle
It is a way to appropriately
resize everything depending

00:07:33.806 --> 00:07:36.486 A:middle
on the length of the text, which
is crucial for localization;

00:07:37.066 --> 00:07:39.476 A:middle
the reason being is that when
you translate your application

00:07:39.476 --> 00:07:40.886 A:middle
from one language to another,

00:07:41.356 --> 00:07:44.306 A:middle
some translated strings may be
significantly longer or shorter,

00:07:44.306 --> 00:07:46.826 A:middle
and you want to be able to
dynamically adjust these,

00:07:46.826 --> 00:07:49.266 A:middle
so your interface looks good.

00:07:50.076 --> 00:07:51.906 A:middle
And, to learn more
about auto layout,

00:07:52.006 --> 00:07:54.906 A:middle
I highly recommend you check out
the video for "Taking Control

00:07:54.906 --> 00:07:56.316 A:middle
of Auto Layout in X Code 5".

00:07:56.316 --> 00:07:57.176 A:middle
That was held yesterday.

00:07:58.716 --> 00:08:02.766 A:middle
So, let's get started on how to
use base internationalization.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:02.966 --> 00:08:05.066 A:middle
So in my project
window for X code,

00:08:05.066 --> 00:08:08.236 A:middle
I have this checkbox here called
used space internationalization.

00:08:09.106 --> 00:08:12.836 A:middle
I check this box, and then
X code will then ask me

00:08:13.276 --> 00:08:17.096 A:middle
which files do I want to use for
my base internationalization.

00:08:17.096 --> 00:08:19.976 A:middle
It will then move all
of these interface files

00:08:19.976 --> 00:08:22.876 A:middle
and any file I want into
the base.Lproj folder,

00:08:23.336 --> 00:08:25.596 A:middle
and anytime I want to
create a new localization,

00:08:25.596 --> 00:08:27.046 A:middle
I then push this
plus button here.

00:08:28.556 --> 00:08:30.496 A:middle
Any interface files
then that are placed

00:08:30.616 --> 00:08:33.376 A:middle
in the base.Lproj folder
will then generate their own

00:08:33.376 --> 00:08:34.135 A:middle
strings files.

00:08:34.916 --> 00:08:37.596 A:middle
And, then again, my
localizer just has to go

00:08:37.596 --> 00:08:40.466 A:middle
into these strings file
only, and have nothing to do

00:08:40.466 --> 00:08:46.096 A:middle
with the interface,
which is great.

00:08:46.296 --> 00:08:49.396 A:middle
Now, when you make an update to
your interface, you also want

00:08:49.396 --> 00:08:52.026 A:middle
to make sure that your interface
is also localized as well.

00:08:52.336 --> 00:08:56.736 A:middle
And, we have a command line
tool in OS X; we call it IB12,

00:08:56.736 --> 00:08:59.346 A:middle
which will generate a
strings file for you.

00:08:59.986 --> 00:09:04.726 A:middle
So, in this example here
in my base.Lproj folder,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:04.726 --> 00:09:08.496 A:middle
I just pass in the nib file that
I have changed, and run IB12

00:09:08.666 --> 00:09:12.656 A:middle
on it, and it will generate a
new strings file containing all

00:09:12.656 --> 00:09:14.436 A:middle
of the strings that
were originally

00:09:14.436 --> 00:09:15.436 A:middle
in this interface file.

00:09:16.536 --> 00:09:20.256 A:middle
I then go in and open
this new strings file,

00:09:21.176 --> 00:09:23.196 A:middle
copy and paste everything
that has changed,

00:09:23.196 --> 00:09:25.636 A:middle
or anything that I have
updated or added, and paste it

00:09:25.636 --> 00:09:27.176 A:middle
into every single strings file

00:09:27.516 --> 00:09:30.236 A:middle
that has this interface
file here,

00:09:30.236 --> 00:09:34.746 A:middle
so it's very good to update.

00:09:35.346 --> 00:09:37.686 A:middle
Now, some issues that can come
up with using auto layout,

00:09:37.686 --> 00:09:40.556 A:middle
is that you may use the
fixed width for auto layout.

00:09:40.926 --> 00:09:43.016 A:middle
This entirely defeats the
purpose of auto layout,

00:09:43.016 --> 00:09:45.086 A:middle
since you want to make sure

00:09:45.086 --> 00:09:47.086 A:middle
that all text is
resized automatically,

00:09:47.086 --> 00:09:49.516 A:middle
and you don't want your
interface to look bad

00:09:49.516 --> 00:09:51.386 A:middle
on certain localization
because you decided

00:09:51.446 --> 00:09:54.136 A:middle
to have a fixed width
between text

00:09:54.136 --> 00:09:56.076 A:middle
and UITextView or something.

00:09:56.656 --> 00:09:59.406 A:middle
And, as always, it's good

00:09:59.406 --> 00:10:02.946 A:middle
to prefer an intrinsic content
size instead and as always

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:02.946 --> 00:10:07.366 A:middle
if you, you should always
try out your layouts

00:10:07.366 --> 00:10:08.876 A:middle
in every single localization
and test,

00:10:08.876 --> 00:10:10.366 A:middle
so your app in those
localizations.

00:10:10.876 --> 00:10:13.186 A:middle
Because what's works
in one language,

00:10:13.186 --> 00:10:15.196 A:middle
and what constraints may
work in one language,

00:10:15.196 --> 00:10:16.616 A:middle
may not necessarily
work in another.

00:10:18.336 --> 00:10:20.546 A:middle
So, let's talk about
the strings file.

00:10:20.896 --> 00:10:23.486 A:middle
The strings file contains
the user visible text

00:10:23.486 --> 00:10:28.006 A:middle
that will get localized
and displayed in your app.

00:10:28.116 --> 00:10:31.386 A:middle
The strings file is placed
into a key value table,

00:10:31.386 --> 00:10:33.296 A:middle
and what happens is,
is that the left side

00:10:33.296 --> 00:10:34.696 A:middle
of the table is your key.

00:10:35.186 --> 00:10:37.316 A:middle
The key is what the application
is going to be looking

00:10:37.316 --> 00:10:40.696 A:middle
for to display what localized
text should be displayed

00:10:40.696 --> 00:10:41.146 A:middle
to the user.

00:10:41.896 --> 00:10:46.156 A:middle
So, in this example here, I have
three localized strings files

00:10:46.156 --> 00:10:48.006 A:middle
that are placed in three
separate localizations;

00:10:48.096 --> 00:10:50.946 A:middle
the English, simplified
Chinese, and Spanish.

00:10:51.716 --> 00:10:54.996 A:middle
At run time, depending on what
localization my user is in,

00:10:55.286 --> 00:10:56.546 A:middle
one of these will get loaded,

00:10:56.546 --> 00:10:57.896 A:middle
and one of these
will get displayed.

00:10:58.196 --> 00:11:03.156 A:middle
So, if my application is looking
for a name key, it will look

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:03.156 --> 00:11:05.756 A:middle
in the name field for that
specific localization,

00:11:05.816 --> 00:11:08.086 A:middle
and display whatever is
in the user visible text.

00:11:08.646 --> 00:11:12.626 A:middle
Now, you will also have
some strings in your code

00:11:12.866 --> 00:11:14.586 A:middle
or some user visible
text in your code

00:11:14.586 --> 00:11:15.786 A:middle
that you want localized as well.

00:11:16.496 --> 00:11:18.736 A:middle
To do this, you should
use NSLocalizedString

00:11:18.736 --> 00:11:20.396 A:middle
and use NSLocalizedString
everywhere

00:11:20.396 --> 00:11:22.076 A:middle
where you have user
visible text,

00:11:22.436 --> 00:11:24.746 A:middle
and NSLocalizedString
has many variants

00:11:24.746 --> 00:11:27.256 A:middle
that pretty much can do
what you want it to do,

00:11:27.256 --> 00:11:28.946 A:middle
so check out more details

00:11:28.946 --> 00:11:30.746 A:middle
for NSLocalizedString
in the release notes.

00:11:31.266 --> 00:11:34.676 A:middle
Here's an example of
NSLocalizedString used

00:11:34.676 --> 00:11:36.116 A:middle
in its most common case.

00:11:36.116 --> 00:11:38.776 A:middle
It takes in two parameters;
one is a key,

00:11:38.776 --> 00:11:41.826 A:middle
which what will get mapped
to the localized text

00:11:41.826 --> 00:11:44.236 A:middle
that you want, as well as
a comment to the localizer,

00:11:44.236 --> 00:11:47.516 A:middle
which I'll talk about later.

00:11:47.746 --> 00:11:50.296 A:middle
Once you localize your
strings in your code,

00:11:50.356 --> 00:11:52.726 A:middle
you want to make sure that
you create a strings file

00:11:52.726 --> 00:11:55.896 A:middle
that will have all these
NSLocalizedStrings in one place.

00:11:56.606 --> 00:11:58.886 A:middle
You can do this manually,
but there is a script

00:11:59.116 --> 00:12:03.236 A:middle
that will do this for you, and
it's highly recommended you use.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:03.516 --> 00:12:05.496 A:middle
It's called gen strings,

00:12:06.116 --> 00:12:09.806 A:middle
and it's highly scriptable
and customizable.

00:12:09.806 --> 00:12:11.926 A:middle
You can add it to all of
your X code billing phases,

00:12:11.926 --> 00:12:13.786 A:middle
and to learn about gen strings,

00:12:13.786 --> 00:12:14.956 A:middle
you just check out
the amend page.

00:12:15.546 --> 00:12:18.446 A:middle
So, here's an example of
how gen strings is invoked.

00:12:18.976 --> 00:12:21.726 A:middle
What happens here is that I
look in the local directory

00:12:21.726 --> 00:12:25.436 A:middle
for all files that end in
.m, and run gen streams

00:12:25.436 --> 00:12:27.656 A:middle
of every single one;
meaning that it will go

00:12:27.656 --> 00:12:30.526 A:middle
into all .m files, search
for NSLocalizedString,

00:12:31.056 --> 00:12:34.326 A:middle
and place a localizable
.strings file

00:12:34.446 --> 00:12:37.126 A:middle
into the English localization
folder in this case.

00:12:38.536 --> 00:12:41.506 A:middle
So, I have a case here
when I've run gen streams

00:12:41.506 --> 00:12:42.856 A:middle
on two separate localization,

00:12:43.226 --> 00:12:46.156 A:middle
my .m file contained this
one NSLocalizedString,

00:12:46.156 --> 00:12:49.096 A:middle
and I placed the strings file
in the English localization

00:12:49.096 --> 00:12:50.456 A:middle
and the Japanese localization.

00:12:51.106 --> 00:12:53.526 A:middle
You can see that the comments
and the key have been placed

00:12:53.526 --> 00:12:56.316 A:middle
in the appropriate
positions, and now my localizer

00:12:56.316 --> 00:12:58.976 A:middle
or my translators just have
to modify the right side

00:12:58.976 --> 00:13:01.116 A:middle
of the table to localize
it to whatever language

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:01.116 --> 00:13:07.646 A:middle
that this is in, and
this is done right here.

00:13:07.826 --> 00:13:10.666 A:middle
Some issues that can come up
with using NSLocalizedString is

00:13:10.666 --> 00:13:13.546 A:middle
that you overload your keys,
meaning you have one key

00:13:13.546 --> 00:13:14.966 A:middle
that maps to many
different places.

00:13:15.876 --> 00:13:18.236 A:middle
Let's say in your application,
you ask the user if they want

00:13:18.236 --> 00:13:19.886 A:middle
to save, and you
have two buttons;

00:13:20.076 --> 00:13:21.546 A:middle
one for yes and one for no.

00:13:22.716 --> 00:13:25.366 A:middle
You also have another button
asking if they want to subscribe

00:13:25.366 --> 00:13:28.166 A:middle
to the super popular
catfacts, with a button

00:13:28.166 --> 00:13:29.586 A:middle
for yes and a button for no.

00:13:30.336 --> 00:13:33.236 A:middle
You have one NSLocalizedString
that maps to both of these,

00:13:33.596 --> 00:13:36.186 A:middle
and this seems to work perfectly
fine for your application.

00:13:37.476 --> 00:13:39.706 A:middle
However, later on in
your development process,

00:13:39.706 --> 00:13:42.686 A:middle
you start to realize that
yes and no aren't very clear,

00:13:43.066 --> 00:13:46.356 A:middle
and should be possibly save
and cancel, but in doing so,

00:13:46.356 --> 00:13:49.236 A:middle
you replace the string and you
inherently break the other part

00:13:49.236 --> 00:13:50.466 A:middle
of your application, and save

00:13:50.466 --> 00:13:52.066 A:middle
and cancel doesn't
really make any sense.

00:13:52.816 --> 00:13:55.446 A:middle
So, it's very important
that you make sure

00:13:55.446 --> 00:13:59.176 A:middle
that all user visible text
has its own unique key,

00:13:59.486 --> 00:14:01.636 A:middle
so you don't run into
this issue where one part

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:01.636 --> 00:14:03.436 A:middle
of your application
inherently breaks another.

00:14:04.416 --> 00:14:06.846 A:middle
Also notice here that
when I made the change

00:14:06.916 --> 00:14:07.886 A:middle
to NSLocalizedString,

00:14:08.216 --> 00:14:10.026 A:middle
the comments were also
updated appropriately

00:14:10.026 --> 00:14:11.376 A:middle
to reflect what was going on,

00:14:12.126 --> 00:14:13.476 A:middle
which leads me to
the second issue.

00:14:13.846 --> 00:14:16.726 A:middle
You provide no comments
to the localizer

00:14:16.726 --> 00:14:18.066 A:middle
or insufficient comments,

00:14:19.096 --> 00:14:22.156 A:middle
it is your localizer's worst
nightmare, and possibly

00:14:22.156 --> 00:14:25.046 A:middle
like will hate you for this,
if you add no comment provided,

00:14:25.406 --> 00:14:27.606 A:middle
and yes equals yes,
or not enough context.

00:14:28.266 --> 00:14:29.636 A:middle
While in English, for example,

00:14:29.946 --> 00:14:32.796 A:middle
yes can mean many different
things, in some languages,

00:14:32.796 --> 00:14:36.206 A:middle
such as Chinese, the word yes
has many different possible

00:14:36.206 --> 00:14:38.056 A:middle
translations, and
without any context

00:14:38.056 --> 00:14:40.546 A:middle
or knowing exactly what's
going on in your application,

00:14:40.856 --> 00:14:43.716 A:middle
your localizer will
pretty much be able

00:14:43.716 --> 00:14:46.226 A:middle
to translate this
part of your app.

00:14:46.796 --> 00:14:49.636 A:middle
So, it's very important that
you provide enough context

00:14:49.636 --> 00:14:52.166 A:middle
to the translators, so
they know exactly how

00:14:52.346 --> 00:14:54.226 A:middle
to translate your
application properly.

00:14:54.756 --> 00:14:58.736 A:middle
The third issue is
composing phrases together,

00:14:58.736 --> 00:15:01.126 A:middle
which is something we as
engineers do quite often;

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:02.306 --> 00:15:04.976 A:middle
the reason being is that if
you compose phases together,

00:15:04.976 --> 00:15:07.366 A:middle
some languages have
these conjugation rules

00:15:07.796 --> 00:15:11.706 A:middle
and some grammatical rules
that depend on other parts

00:15:11.706 --> 00:15:13.046 A:middle
of a phrase or sentence,

00:15:13.046 --> 00:15:15.756 A:middle
and without knowing the
previous parts of your sentence,

00:15:15.806 --> 00:15:17.456 A:middle
it will be grammatically
incorrect.

00:15:18.406 --> 00:15:20.716 A:middle
So, for example here, I
have three strings here,

00:15:20.856 --> 00:15:24.436 A:middle
one for go to next blank,
chapter, and then page.

00:15:25.506 --> 00:15:27.226 A:middle
In English, this seems
to work perfectly fine,

00:15:27.226 --> 00:15:29.586 A:middle
since go to next chapter and
go to next page are valid

00:15:29.586 --> 00:15:30.596 A:middle
and grammatically correct.

00:15:31.526 --> 00:15:33.316 A:middle
However, if I'm a
Spanish localizer,

00:15:33.316 --> 00:15:37.656 A:middle
and I try to translate this, I
see go to next and then chapter.

00:15:37.956 --> 00:15:40.046 A:middle
Since chapter is
a masculine noun,

00:15:40.286 --> 00:15:44.076 A:middle
and I must have a masculine
article in order to agree

00:15:44.076 --> 00:15:46.656 A:middle
with chapter, this is going
to work perfectly fine.

00:15:47.566 --> 00:15:50.116 A:middle
When it comes to page, since
page is a feminine noun,

00:15:50.476 --> 00:15:51.916 A:middle
the article must be feminine,

00:15:51.916 --> 00:15:53.476 A:middle
but if I've already
made it masculine,

00:15:53.476 --> 00:15:55.206 A:middle
then this is inherently broken,

00:15:55.206 --> 00:15:57.106 A:middle
and this localization
is broken for Spanish.

00:15:57.906 --> 00:16:00.356 A:middle
So, it's very important
to make sure again

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.356 --> 00:16:04.236 A:middle
that your user visible text
each has their own unique key,

00:16:04.576 --> 00:16:07.876 A:middle
and you compose things in
a sentence wise, or else,

00:16:07.876 --> 00:16:09.426 A:middle
you're going to run
into grammatical issues.

00:16:11.016 --> 00:16:12.956 A:middle
There are going to be
some cases, however,

00:16:12.956 --> 00:16:16.676 A:middle
when you are going to have to
dynamically create strings,

00:16:16.676 --> 00:16:19.246 A:middle
such as when it comes to
the case of pluralization.

00:16:19.916 --> 00:16:23.116 A:middle
This is cases where if I want
to display to the user I have 0

00:16:23.116 --> 00:16:25.626 A:middle
of something remaining, one
of something, or more than one

00:16:25.626 --> 00:16:27.816 A:middle
of something, and
in some languages,

00:16:27.816 --> 00:16:31.056 A:middle
this can get very complicated,
where there's a different string

00:16:31.056 --> 00:16:34.326 A:middle
for two to five of something or
10-14 of something and so on.

00:16:35.316 --> 00:16:37.396 A:middle
There is a new feature
in OS X Mavericks

00:16:37.396 --> 00:16:41.846 A:middle
and iOS 7 called stringsdict,
which a localized plist

00:16:41.846 --> 00:16:44.406 A:middle
that essentially
handles all these cases

00:16:44.406 --> 00:16:45.756 A:middle
of pluralization for you.

00:16:46.496 --> 00:16:49.026 A:middle
You as a developer do not
need to call any new API's,

00:16:49.256 --> 00:16:51.476 A:middle
since stringsdict will
be called automatically,

00:16:51.476 --> 00:16:54.406 A:middle
if it's available, and your
localizers then just have

00:16:54.406 --> 00:16:55.396 A:middle
to fill out this plist,

00:16:55.396 --> 00:16:57.506 A:middle
and will handle all
these cases for you.

00:16:58.556 --> 00:17:00.976 A:middle
To learn more about this in
complete technical detail,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:01.036 --> 00:17:03.466 A:middle
check out the foundation
release notes, but if you want

00:17:03.466 --> 00:17:06.246 A:middle
to learn how to get the setup
and have a brief tutorial

00:17:06.246 --> 00:17:09.026 A:middle
about this, check out the
"What's New in Cocoa Video"

00:17:09.026 --> 00:17:10.996 A:middle
for the session that
was held two days ago.

00:17:12.516 --> 00:17:14.906 A:middle
So, here's an example
of stringsdict

00:17:14.906 --> 00:17:16.665 A:middle
on two separate localizations;

00:17:16.816 --> 00:17:18.526 A:middle
one for English and
one for Russian.

00:17:19.246 --> 00:17:22.846 A:middle
You can see that the English
localization has very simple

00:17:22.846 --> 00:17:25.256 A:middle
case with one and
anything but one,

00:17:25.386 --> 00:17:27.636 A:middle
and the Russian case can
get very, very complicated.

00:17:29.976 --> 00:17:34.906 A:middle
Now, aside from text, which
is the most localizing you'll

00:17:34.906 --> 00:17:37.676 A:middle
probably be doing, you can
localize other things as well,

00:17:37.676 --> 00:17:40.026 A:middle
such as your images,
your sound files,

00:17:40.026 --> 00:17:41.946 A:middle
and pretty much anything
can be localized.

00:17:42.756 --> 00:17:46.946 A:middle
To do this, you create a
localized version of this file,

00:17:46.946 --> 00:17:49.556 A:middle
and place it into the
respective localization folder

00:17:49.856 --> 00:17:53.086 A:middle
that you wish to load for
this specific localization.

00:17:53.976 --> 00:17:55.516 A:middle
The API's you called to call

00:17:55.516 --> 00:17:58.226 A:middle
for these specific files
will automatically call the

00:17:58.226 --> 00:17:59.086 A:middle
localized version.

00:17:59.466 --> 00:18:01.746 A:middle
So, there is no need
for any extra code

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:01.746 --> 00:18:03.396 A:middle
to handle for localization.

00:18:05.136 --> 00:18:08.876 A:middle
So, let's say I have an image
here that I want to localize.

00:18:09.206 --> 00:18:12.816 A:middle
I push this localize
button here, right there,

00:18:12.816 --> 00:18:16.606 A:middle
and X code will then
ask me where do I want

00:18:16.606 --> 00:18:18.896 A:middle
to place this localization file.

00:18:19.806 --> 00:18:21.896 A:middle
In this case, I want
to move this image file

00:18:21.896 --> 00:18:24.516 A:middle
to the English localization,
so this file will get loaded

00:18:24.516 --> 00:18:25.666 A:middle
for the English localization.

00:18:26.476 --> 00:18:29.266 A:middle
Any single time I want to
create a new localized file

00:18:29.266 --> 00:18:33.156 A:middle
for this specific image here,
I just have to create a file

00:18:33.156 --> 00:18:34.676 A:middle
with the same name,
and just place it

00:18:34.676 --> 00:18:37.756 A:middle
into the specific
localized folder that I want,

00:18:38.486 --> 00:18:41.606 A:middle
so for example here, I have an
RTF file that has been localized

00:18:41.606 --> 00:18:43.276 A:middle
to several different languages,

00:18:43.586 --> 00:18:46.416 A:middle
and all of these
RTF files are placed

00:18:46.416 --> 00:18:48.276 A:middle
into their respective
L.proj folders.

00:18:50.596 --> 00:18:52.766 A:middle
Now some issues that
can come up is

00:18:52.766 --> 00:18:54.486 A:middle
that you have some
text in your image.

00:18:55.006 --> 00:18:56.746 A:middle
While it's okay to have
text in your image,

00:18:56.806 --> 00:19:00.426 A:middle
be aware that your localizers
will have trouble translating

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:00.426 --> 00:19:03.086 A:middle
text in your image, as opposed
to just translating text itself,

00:19:03.086 --> 00:19:04.536 A:middle
since it requires
a bit more effort

00:19:04.536 --> 00:19:05.906 A:middle
to translate text in your image.

00:19:06.906 --> 00:19:09.306 A:middle
The other issue is having
an image or something

00:19:09.306 --> 00:19:10.726 A:middle
to convey a meaning to the user,

00:19:10.726 --> 00:19:13.696 A:middle
since some images may
not necessarily work

00:19:14.046 --> 00:19:15.056 A:middle
in other languages.

00:19:15.836 --> 00:19:19.626 A:middle
So, for example I have a
keyword search, and I use a key

00:19:19.626 --> 00:19:20.886 A:middle
to denote a keyword search.

00:19:21.516 --> 00:19:23.286 A:middle
In English, this seems
to work perfectly fine,

00:19:23.286 --> 00:19:25.836 A:middle
since I see a key, I can think
of keyword, since, you know,

00:19:25.836 --> 00:19:28.666 A:middle
there's the same word,
but in other languages,

00:19:28.996 --> 00:19:32.536 A:middle
the word keyword doesn't
necessarily translate to a key

00:19:32.536 --> 00:19:35.436 A:middle
at all, since you'd come out
to head word or focus word

00:19:35.436 --> 00:19:38.276 A:middle
or indicative word, and your
users will pretty much have no

00:19:38.276 --> 00:19:40.116 A:middle
idea why you have
a key for keyword,

00:19:40.116 --> 00:19:42.106 A:middle
so the idea is completely
lost in translation.

00:19:43.776 --> 00:19:46.136 A:middle
Another issue is having
a cultural reference,

00:19:46.136 --> 00:19:48.646 A:middle
or something that's specific
to a specific culture,

00:19:48.646 --> 00:19:51.776 A:middle
and this may run
into some issues.

00:19:52.276 --> 00:19:55.576 A:middle
So, for example, in Japan,
this image here is placed

00:19:55.576 --> 00:19:59.356 A:middle
onto the back of all cars for
anyone who is inexperienced

00:19:59.356 --> 00:20:00.956 A:middle
or a beginner driver
to alert other drivers

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.956 --> 00:20:01.926 A:middle
that she should probably
get out of the way.

00:20:02.306 --> 00:20:08.576 A:middle
Some Japanese developers
sometimes use this to show

00:20:08.576 --> 00:20:11.366 A:middle
that this is a tutorial or a
beginner's guide to something,

00:20:11.366 --> 00:20:15.066 A:middle
and if someone isn't well
versed in the Japanese culture,

00:20:15.066 --> 00:20:16.536 A:middle
or doesn't know anything
about Japan,

00:20:16.536 --> 00:20:18.606 A:middle
they pretty much have no
idea what this icon is,

00:20:18.606 --> 00:20:20.546 A:middle
and they'll get lost
in your application.

00:20:21.356 --> 00:20:23.526 A:middle
So, make sure that any
images that you have

00:20:23.596 --> 00:20:26.726 A:middle
that display a meaning or try
to convey a meaning to the user,

00:20:27.166 --> 00:20:29.606 A:middle
is workable for all the
localizations you want

00:20:29.606 --> 00:20:30.136 A:middle
to support.

00:20:31.636 --> 00:20:33.516 A:middle
Now once you've localized
your application,

00:20:33.516 --> 00:20:36.246 A:middle
you'll want to test this out,
and the most accurate way

00:20:36.246 --> 00:20:39.136 A:middle
to do this, and to see exactly
what your user is going to see,

00:20:39.516 --> 00:20:42.166 A:middle
is to change the system
language inside of your system

00:20:42.166 --> 00:20:43.176 A:middle
to the language you want.

00:20:43.876 --> 00:20:45.106 A:middle
Also, the other reason is,

00:20:45.106 --> 00:20:49.326 A:middle
is that some system services may
not work in that localization

00:20:49.366 --> 00:20:52.036 A:middle
until you explicitly send the
language to that localization.

00:20:53.066 --> 00:20:54.896 A:middle
However, if you want to
quickly check whether

00:20:54.896 --> 00:20:57.306 A:middle
or not a string has
been localized

00:20:57.306 --> 00:21:00.986 A:middle
or a file loads correctly,
you can run your application

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:00.986 --> 00:21:03.566 A:middle
in X code using the dash
Apple language as argument.

00:21:04.016 --> 00:21:05.256 A:middle
And, in this example here,

00:21:05.296 --> 00:21:07.746 A:middle
no matter what language my
system is in, it's going to run

00:21:07.746 --> 00:21:09.546 A:middle
in the Korean localization.

00:21:10.976 --> 00:21:13.786 A:middle
A really cool way to
check whether or not

00:21:13.786 --> 00:21:16.046 A:middle
if your application
has been localized,

00:21:16.046 --> 00:21:18.316 A:middle
and to test out whether
your interface will work

00:21:18.316 --> 00:21:20.996 A:middle
for longer strings,
longer strings,

00:21:20.996 --> 00:21:22.476 A:middle
is to use pseudo localization.

00:21:23.396 --> 00:21:24.796 A:middle
So, what's pseudo localization?

00:21:25.426 --> 00:21:28.516 A:middle
Pseudo localization
is a way, well,

00:21:28.516 --> 00:21:31.396 A:middle
if you have your strings
files, you can run a script

00:21:31.546 --> 00:21:34.736 A:middle
through the user visible text
in your string to modify it

00:21:34.736 --> 00:21:36.636 A:middle
and distort it, such
that it is longer

00:21:36.636 --> 00:21:39.246 A:middle
than what's originally there,
and will distort it to the point

00:21:39.246 --> 00:21:41.076 A:middle
where if you were looking
in your application

00:21:41.076 --> 00:21:43.896 A:middle
to check whether or not some
strings have been localized,

00:21:44.226 --> 00:21:46.626 A:middle
you can obviously tell whether
you're missing some parts

00:21:46.626 --> 00:21:47.986 A:middle
or you forget to
localize something.

00:21:48.886 --> 00:21:50.676 A:middle
And, with that, I'd
like to bring back Doug

00:21:50.676 --> 00:21:51.976 A:middle
up to show us a demo on
how localization works.

00:21:52.516 --> 00:21:55.656 A:middle
[ Applause ]

00:21:56.156 --> 00:21:58.896 A:middle
&gt;&gt; Thanks Albert so in
order to demo this out,

00:21:59.656 --> 00:22:04.756 A:middle
we wrote a tiny little
application.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:04.756 --> 00:22:09.966 A:middle
So, what this application
does is it lets me type

00:22:10.016 --> 00:22:18.556 A:middle
in some brief little notes,
and then it shows them

00:22:18.556 --> 00:22:20.276 A:middle
in a scrolling list,
really simple.

00:22:25.006 --> 00:22:30.186 A:middle
And, so the first version
of this application

00:22:30.186 --> 00:22:32.906 A:middle
that we have here is
not localized at all.

00:22:33.336 --> 00:22:35.686 A:middle
Notice, it's not using
base internationalization;

00:22:35.686 --> 00:22:36.686 A:middle
that's turned off.

00:22:37.016 --> 00:22:43.426 A:middle
The only localization that's
there is English, and if I look

00:22:43.426 --> 00:22:46.756 A:middle
at my nib file, it's all in
English, and if I take a look

00:22:46.756 --> 00:22:51.186 A:middle
at my code, I notice that there
are some user visible strings

00:22:51.186 --> 00:22:53.036 A:middle
in here; for example when
I'm creating an alert,

00:22:54.116 --> 00:22:56.206 A:middle
they're just static
explicit strings,

00:22:56.786 --> 00:22:59.926 A:middle
and for setting the title of
the window to reflect the number

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:00.006 --> 00:23:05.656 A:middle
of notes, I have
switched between one note

00:23:05.656 --> 00:23:08.246 A:middle
or multiple notes, so
it's all in English.

00:23:08.786 --> 00:23:15.706 A:middle
So, what that means is that if
I go in and change my system

00:23:15.876 --> 00:23:20.136 A:middle
into say German, and then run
the app again, nothing changes

00:23:20.136 --> 00:23:21.626 A:middle
at all, it's not localized.

00:23:22.266 --> 00:23:31.616 A:middle
So, the next thing to do
is to create a new version

00:23:31.616 --> 00:23:34.826 A:middle
of this application,
and we turned

00:23:34.826 --> 00:23:36.806 A:middle
on base internationalization.

00:23:37.976 --> 00:23:40.526 A:middle
What that does is create
a base localization,

00:23:40.526 --> 00:23:42.856 A:middle
and that's where
our nib file goes,

00:23:42.856 --> 00:23:46.956 A:middle
and then we added an additional
German localization to this app.

00:23:48.066 --> 00:23:51.146 A:middle
So, if we take a look at our nib
file, it has not changed at all.

00:23:51.146 --> 00:23:53.156 A:middle
The only thing that happened
to it is that it moved

00:23:53.156 --> 00:23:58.616 A:middle
from the English localization
into the base, and in addition,

00:23:59.176 --> 00:24:03.076 A:middle
we get a strings file
associated with it

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:03.766 --> 00:24:07.266 A:middle
that contains the
translations; we added a rough

00:24:07.266 --> 00:24:10.076 A:middle
and ready German translation
here, to the various strings

00:24:10.076 --> 00:24:15.506 A:middle
that appear in that nib
file, and then we run the app

00:24:15.506 --> 00:24:18.656 A:middle
in German, these will
automatically be substituted

00:24:18.656 --> 00:24:21.756 A:middle
into that nib, in
place of all the places

00:24:21.756 --> 00:24:23.736 A:middle
where the English text appears.

00:24:24.336 --> 00:24:29.886 A:middle
In addition in code, we
took these explicit strings,

00:24:29.886 --> 00:24:32.466 A:middle
and replaced them calls
to NSLocalizedString

00:24:32.536 --> 00:24:36.456 A:middle
with suitable keys and suitable
comments for the localizer,

00:24:37.546 --> 00:24:40.336 A:middle
and then for the title that
reflects the number of notes,

00:24:40.336 --> 00:24:41.666 A:middle
we're going to use
a string sticks,

00:24:42.256 --> 00:24:46.416 A:middle
to get appropriate
localization of plurals

00:24:46.986 --> 00:24:49.156 A:middle
in whatever language we're
translating this into.

00:24:49.996 --> 00:24:53.216 A:middle
So, we ran gen strings on
this, and the result is

00:24:53.216 --> 00:24:56.066 A:middle
that we have localizable
string files for English,

00:24:57.396 --> 00:25:01.286 A:middle
and then for German, where we
put in appropriate translations

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:01.656 --> 00:25:06.606 A:middle
for each of the keys that
appear in our NSLocalizedString,

00:25:07.096 --> 00:25:10.266 A:middle
and created string
sticks for details

00:25:10.616 --> 00:25:13.556 A:middle
on the format string
sticked file.

00:25:13.556 --> 00:25:15.886 A:middle
You can again, take a look at
the foundation of these styles.

00:25:15.886 --> 00:25:19.476 A:middle
If explains it all in detail,
but the business part of it,

00:25:20.426 --> 00:25:23.046 A:middle
has these lines that
describe what to do for,

00:25:23.116 --> 00:25:25.666 A:middle
when the number is
one, and what to do

00:25:25.666 --> 00:25:26.866 A:middle
when the number is
other than one.

00:25:26.866 --> 00:25:29.906 A:middle
So, for English, we chose
a very simple set of rules.

00:25:30.536 --> 00:25:33.096 A:middle
For German, it got a
little more complicated.

00:25:33.136 --> 00:25:36.606 A:middle
We have rules for 0,
one or anything else.

00:25:38.496 --> 00:25:40.896 A:middle
And, let's see what
happens when this ends

00:25:40.896 --> 00:25:43.556 A:middle
up in our built application.

00:25:43.556 --> 00:25:45.656 A:middle
So, here we're taking a
look inside the app bundle.

00:25:46.196 --> 00:25:48.306 A:middle
In the resources we
have a base L.proj

00:25:48.476 --> 00:25:52.446 A:middle
that contains our nib file, so
there's only one copy of that,

00:25:52.446 --> 00:25:57.846 A:middle
and then in German L.proj, we
have just the strings file,

00:25:57.846 --> 00:26:00.926 A:middle
the stringsdict, and that
credits file that X code wants

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.926 --> 00:26:04.736 A:middle
to create for us,
and when we run this,

00:26:05.866 --> 00:26:11.096 A:middle
then the main menu.strings
contents should be automatically

00:26:11.096 --> 00:26:12.556 A:middle
substituted into our nib.

00:26:13.686 --> 00:26:17.626 A:middle
So, let's try that out.

00:26:17.906 --> 00:26:22.426 A:middle
And, we see one right now, the
whole interface is in German.

00:26:23.496 --> 00:26:27.066 A:middle
We got our strings sticks
has given us a proper title

00:26:27.066 --> 00:26:32.286 A:middle
for 0 items, and even
our menus are localized.

00:26:32.756 --> 00:26:35.886 A:middle
Even the Apple menu stuff, this
comes from outside our app,

00:26:36.366 --> 00:26:43.886 A:middle
all localized properly, and
our localized strings show

00:26:43.886 --> 00:26:44.596 A:middle
up in the alert.

00:26:45.946 --> 00:26:49.316 A:middle
So, that is the basic
process of localizing an app.

00:26:50.226 --> 00:26:52.336 A:middle
Let me go back to the slides.

00:26:53.956 --> 00:26:56.276 A:middle
And next, I want to bring
up my colleague, Nat,

00:26:56.426 --> 00:26:57.976 A:middle
to talk about dealing
with locale data.

00:26:58.516 --> 00:27:00.946 A:middle
[ Applause ]

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:01.446 --> 00:27:02.506 A:middle
&gt;&gt; Okay, hello, hello.

00:27:02.776 --> 00:27:03.346 A:middle
Thank you, Doug.

00:27:03.486 --> 00:27:05.836 A:middle
So, my name is Nat Hillard,
and for this section,

00:27:05.836 --> 00:27:07.866 A:middle
we will be going
over locale data.

00:27:08.516 --> 00:27:12.486 A:middle
So, another critical aspect of
making your app world ready,

00:27:12.706 --> 00:27:16.296 A:middle
is presenting numbers, dates,
times, and symbols in a manner

00:27:16.296 --> 00:27:17.786 A:middle
that is appropriate
for your users.

00:27:18.306 --> 00:27:20.726 A:middle
Now, to do this isn't
just a stylistic issue.

00:27:20.726 --> 00:27:23.546 A:middle
It can have practical usability
complications and implications

00:27:23.546 --> 00:27:26.976 A:middle
as well, and ultimately, you
can conceive of this process

00:27:26.976 --> 00:27:29.586 A:middle
as translating between
machine readable data

00:27:29.826 --> 00:27:31.196 A:middle
and user readable strengths.

00:27:31.656 --> 00:27:35.056 A:middle
Now, interestingly, this is
not a one to one mapping.

00:27:35.056 --> 00:27:36.326 A:middle
Things can get pretty
complicated.

00:27:36.796 --> 00:27:39.766 A:middle
Now, luckily, we provided a set
of API's for you that do a lot

00:27:39.766 --> 00:27:40.956 A:middle
of the heavy lifting for you.

00:27:41.466 --> 00:27:43.746 A:middle
So, in this section, I'll
be going over the first five

00:27:43.746 --> 00:27:45.556 A:middle
in this table, and Doug
will cover NSString

00:27:45.556 --> 00:27:46.786 A:middle
in more detail in the next.

00:27:47.366 --> 00:27:49.406 A:middle
So, first of all,
what is a locale?

00:27:50.256 --> 00:27:53.226 A:middle
In an abstract sense, it's a
collection of user preferences

00:27:53.226 --> 00:27:54.336 A:middle
with regard to formatting.

00:27:54.746 --> 00:27:56.446 A:middle
The users will set
this, as Doug mentioned,

00:27:56.446 --> 00:27:59.816 A:middle
in the region format
preference on iOS or on OS X

00:27:59.926 --> 00:28:01.936 A:middle
in the languages and
format preference pane.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:02.396 --> 00:28:05.516 A:middle
In a concrete sense, it
is represented in Cocoa

00:28:05.836 --> 00:28:09.106 A:middle
with the NSLocale API.

00:28:10.156 --> 00:28:12.156 A:middle
Usually as a programmer,
you will not be dealing

00:28:12.156 --> 00:28:14.096 A:middle
with the NSLocale
object directly.

00:28:14.186 --> 00:28:17.246 A:middle
Instead, interacting with it at
the class level or passing it

00:28:17.246 --> 00:28:19.506 A:middle
in as argument to other API's.

00:28:20.886 --> 00:28:23.526 A:middle
So, important to keep in mind,
however, is the distinction

00:28:23.526 --> 00:28:25.496 A:middle
between a local and
a localization.

00:28:25.896 --> 00:28:28.956 A:middle
Locale represents the formatting
standards for a particular user.

00:28:29.206 --> 00:28:30.816 A:middle
These are informed
by their region,

00:28:30.996 --> 00:28:32.446 A:middle
their language, and
their script.

00:28:32.956 --> 00:28:35.226 A:middle
On the other hand, localization
refers to the language

00:28:35.226 --> 00:28:36.386 A:middle
of the user interface.

00:28:36.786 --> 00:28:38.696 A:middle
Now, these can often
be the same,

00:28:38.696 --> 00:28:40.486 A:middle
but for a given user,
they may differ.

00:28:41.606 --> 00:28:45.166 A:middle
As an example of using locale
information to present,

00:28:45.366 --> 00:28:47.736 A:middle
or locale data to present
information to your users,

00:28:47.736 --> 00:28:49.256 A:middle
let's take a look
at formatting dates.

00:28:49.756 --> 00:28:52.746 A:middle
So, for this, we've provided
the NSDateFormatter.

00:28:53.096 --> 00:28:56.906 A:middle
This converts between NS
date machine readable data

00:28:57.016 --> 00:28:59.626 A:middle
and a string representation
for a particular user.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:00.986 --> 00:29:03.576 A:middle
Often, you'll be working with
this and explicitly attaching it

00:29:03.606 --> 00:29:05.976 A:middle
to a text field within
your nib file.

00:29:06.486 --> 00:29:08.266 A:middle
On the other hand, if you
need to use it in code,

00:29:08.266 --> 00:29:10.196 A:middle
you can call localized
string from date;

00:29:10.456 --> 00:29:12.236 A:middle
passing in your NSDate, as well

00:29:12.236 --> 00:29:14.086 A:middle
as a date style and
a time style.

00:29:15.176 --> 00:29:17.336 A:middle
So, what do these date
and time styles look like?

00:29:17.826 --> 00:29:19.096 A:middle
Well, they differ in the amount

00:29:19.096 --> 00:29:20.826 A:middle
of information they're
presenting to the user

00:29:20.826 --> 00:29:22.136 A:middle
about your NSDate object.

00:29:22.796 --> 00:29:25.006 A:middle
Here, they can vary
from anything as short

00:29:25.006 --> 00:29:27.316 A:middle
as a short style, where you're
simply presenting numbers,

00:29:27.726 --> 00:29:29.716 A:middle
to the full style where
you spell everything out.

00:29:30.166 --> 00:29:31.936 A:middle
As well, as if you need
to suppress either one

00:29:31.936 --> 00:29:33.486 A:middle
of these, you can use no style.

00:29:34.936 --> 00:29:38.996 A:middle
So, to see what this looks
like, we call localized string

00:29:38.996 --> 00:29:41.176 A:middle
from date on the NS
date formatter class.

00:29:41.526 --> 00:29:44.386 A:middle
We pass in our date, and we
pass in medium style for date

00:29:44.636 --> 00:29:45.956 A:middle
and short style for time.

00:29:46.736 --> 00:29:50.216 A:middle
Now, keep in mind this will
do the heavy lifting for us,

00:29:50.416 --> 00:29:51.646 A:middle
and present this information

00:29:51.646 --> 00:29:53.786 A:middle
in a locale appropriate
manner for our given user.

00:29:54.436 --> 00:29:57.246 A:middle
So, here we have three locales,
English as used in the US,

00:29:57.506 --> 00:30:01.266 A:middle
French as used in France,
and Chinese as used in China.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:01.266 --> 00:30:04.106 A:middle
Here we have the out of
the box representation

00:30:04.106 --> 00:30:06.166 A:middle
of a single NSDate object.

00:30:06.866 --> 00:30:09.526 A:middle
Here we have June 6, 2013,

00:30:09.526 --> 00:30:11.226 A:middle
a presentation familiar
in US English.

00:30:12.536 --> 00:30:15.666 A:middle
On the other hand in France,
this API has done the work

00:30:15.666 --> 00:30:18.756 A:middle
of presenting first the day
number, followed by the month,

00:30:18.756 --> 00:30:20.476 A:middle
followed by the year,
and without a coma.

00:30:21.126 --> 00:30:23.786 A:middle
Also, in Chinese, we presented
the year number first,

00:30:23.976 --> 00:30:25.306 A:middle
followed by the character
for year,

00:30:25.526 --> 00:30:27.816 A:middle
followed by the month
number, character for month,

00:30:27.816 --> 00:30:29.896 A:middle
and day number, followed
by character for day.

00:30:30.516 --> 00:30:33.846 A:middle
Likewise with times, we
present AM in the United States.

00:30:34.216 --> 00:30:37.436 A:middle
We don't provide either
AM or PM for France,

00:30:37.436 --> 00:30:40.326 A:middle
which traditionally uses
24 hour time, and in China,

00:30:40.326 --> 00:30:42.756 A:middle
we present the characters
for morning,

00:30:43.076 --> 00:30:45.706 A:middle
followed by our single
time object.

00:30:46.326 --> 00:30:48.706 A:middle
So, this is the preferred
way to work with NSDate.

00:30:49.016 --> 00:30:51.476 A:middle
Out of the box, calling a
class method, localized string

00:30:51.476 --> 00:30:53.926 A:middle
from date, you've gotten three
very different representations

00:30:53.926 --> 00:30:54.926 A:middle
from the same object.

00:30:55.116 --> 00:30:59.276 A:middle
If on the other hand, you
want to present a custom view

00:30:59.276 --> 00:31:00.706 A:middle
of this same NSDate object,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.706 --> 00:31:04.886 A:middle
you have to go beyond the
certain present packaged styles.

00:31:05.256 --> 00:31:09.046 A:middle
Keep in mind that the medium
style will always present the

00:31:09.046 --> 00:31:11.226 A:middle
month, the day, and the year.

00:31:11.626 --> 00:31:13.076 A:middle
Let's say for instance
though that you wanted

00:31:13.076 --> 00:31:15.036 A:middle
to only present the
month and the day.

00:31:15.406 --> 00:31:17.566 A:middle
So, when the default styles
don't meet your needs,

00:31:17.966 --> 00:31:20.576 A:middle
you create an instance of
the NSDateFormatter class.

00:31:21.476 --> 00:31:24.166 A:middle
From there, you create
a format string.

00:31:24.466 --> 00:31:27.546 A:middle
This is done with date format
from template, a class method

00:31:27.546 --> 00:31:28.556 A:middle
on interstate formatter.

00:31:29.206 --> 00:31:31.276 A:middle
To this, you pass
a format string.

00:31:31.666 --> 00:31:32.826 A:middle
Now, for more information
on this,

00:31:32.826 --> 00:31:35.636 A:middle
you can check Unicode
standard 35, which has a lot

00:31:35.636 --> 00:31:36.526 A:middle
of information on this.

00:31:36.886 --> 00:31:38.346 A:middle
Suffice it to say,
we've said here

00:31:38.346 --> 00:31:39.536 A:middle
that we want the day number,

00:31:39.536 --> 00:31:41.666 A:middle
followed by an abbreviated
form of the month.

00:31:41.726 --> 00:31:43.716 A:middle
This can go into
a lot of detail.

00:31:43.716 --> 00:31:47.976 A:middle
These format strings can present
everything from given variance

00:31:47.976 --> 00:31:50.316 A:middle
of abbreviations, as
well as fully spelled

00:31:50.316 --> 00:31:51.876 A:middle
out or number variance.

00:31:52.566 --> 00:31:55.106 A:middle
Also critically, we
pass here the locale,

00:31:55.326 --> 00:31:56.666 A:middle
NSLocale, current locale.

00:31:57.966 --> 00:32:01.596 A:middle
So, this is the correct to do
it, but, there is, oh, sorry,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:01.756 --> 00:32:06.326 A:middle
finally, we set the date format
on our date formatter instance.

00:32:06.596 --> 00:32:08.776 A:middle
Now, this is the
correct way to do it.

00:32:08.776 --> 00:32:11.246 A:middle
However, there is an incorrect
and naive way to do it.

00:32:11.696 --> 00:32:13.606 A:middle
Let's say you've read
Unicode standard 35,

00:32:13.936 --> 00:32:16.676 A:middle
and you've explicitly set
date format to a string

00:32:16.676 --> 00:32:17.426 A:middle
that you've read about here.

00:32:17.426 --> 00:32:19.806 A:middle
You want the month, followed by
the day, followed by the year.

00:32:20.136 --> 00:32:22.606 A:middle
Notice though that we haven't
got through the template object.

00:32:23.256 --> 00:32:24.696 A:middle
The template does
the work for us

00:32:24.696 --> 00:32:26.176 A:middle
of rearranging the components,

00:32:26.176 --> 00:32:27.716 A:middle
so they're appropriate
for a given locale.

00:32:28.466 --> 00:32:30.666 A:middle
Consequently though, when we
call from string from date,

00:32:30.666 --> 00:32:33.216 A:middle
we get a representation that
is the same for all three

00:32:33.216 --> 00:32:34.786 A:middle
of these very different locales.

00:32:35.756 --> 00:32:37.426 A:middle
So, this is not the
correct way to do this.

00:32:37.476 --> 00:32:40.616 A:middle
Instead, going through the
intermediary of date format

00:32:40.616 --> 00:32:42.966 A:middle
from template, it will do
the rearranging for us.

00:32:43.406 --> 00:32:46.546 A:middle
Consequently, if we pass in
lower case d, capital MMM,

00:32:46.606 --> 00:32:50.866 A:middle
day and number, basically
indicating that we wish

00:32:50.866 --> 00:32:55.646 A:middle
to convey day number and
month, and then call a string

00:32:55.646 --> 00:32:58.116 A:middle
from date, we get the
appropriate representation

00:32:58.116 --> 00:32:58.946 A:middle
for a given locale.

00:32:59.326 --> 00:33:01.446 A:middle
We have the month name
followed by number in the US,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:01.846 --> 00:33:05.526 A:middle
the vice versa in France, and
in China, we have month number,

00:33:05.526 --> 00:33:09.156 A:middle
followed by month
character, day, day character.

00:33:10.086 --> 00:33:12.366 A:middle
Likewise though, with NS dates,

00:33:12.366 --> 00:33:14.086 A:middle
let's take a look at
number formatting.

00:33:14.116 --> 00:33:16.086 A:middle
This is another area in
which there's a great degree

00:33:16.086 --> 00:33:17.256 A:middle
of variation around the world.

00:33:18.166 --> 00:33:21.146 A:middle
To help you with this, we
have NSNumberFormatter,

00:33:21.426 --> 00:33:23.426 A:middle
which is meant to mirror
an estate formatter.

00:33:24.476 --> 00:33:27.506 A:middle
As an example of the type of
variation you may come across,

00:33:27.726 --> 00:33:29.256 A:middle
you'll have everything
from the separator

00:33:29.256 --> 00:33:31.846 A:middle
between the thousands digit
and the decimal digit.

00:33:32.286 --> 00:33:34.686 A:middle
Likewise, even the
digits themselves,

00:33:34.686 --> 00:33:36.446 A:middle
something we may take
for granted, can vary.

00:33:36.736 --> 00:33:39.186 A:middle
On the right, we have an
aerobic Egyptian representation

00:33:39.186 --> 00:33:40.316 A:middle
of this same digit number.

00:33:41.066 --> 00:33:42.696 A:middle
Currency can differ
in the symbol,

00:33:42.696 --> 00:33:43.756 A:middle
as well as the separators.

00:33:44.146 --> 00:33:46.446 A:middle
Percentage size itself
can differ, as well again,

00:33:46.446 --> 00:33:48.986 A:middle
we see the digits
differing, and even numbers

00:33:48.986 --> 00:33:51.286 A:middle
that are not numbers,
so not a number can come

00:33:51.286 --> 00:33:53.666 A:middle
up differently in
different locales.

00:33:54.596 --> 00:33:59.006 A:middle
Again though one thing to avoid
is providing explicit format

00:33:59.006 --> 00:34:01.656 A:middle
strings, so those of you coming
from C world will be familiar

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:01.656 --> 00:34:04.546 A:middle
with the print F style
C format strings.

00:34:05.076 --> 00:34:07.946 A:middle
Here we call string from
format on NSString,

00:34:08.386 --> 00:34:11.755 A:middle
saying that we want a floating
point number with three digits.

00:34:11.755 --> 00:34:14.746 A:middle
Consequently though, we get
the same number for all three

00:34:14.746 --> 00:34:15.946 A:middle
of these very different locales.

00:34:16.735 --> 00:34:18.426 A:middle
This is not the correct
way to do it.

00:34:19.045 --> 00:34:23.016 A:middle
So, one way to do a very
simple in place fix,

00:34:23.016 --> 00:34:25.186 A:middle
is to instead called
localized string

00:34:25.186 --> 00:34:26.676 A:middle
of format on your NSString.

00:34:27.065 --> 00:34:28.826 A:middle
This is only for a code
that exists already,

00:34:28.826 --> 00:34:30.306 A:middle
and is a simple in place fix.

00:34:30.786 --> 00:34:34.255 A:middle
However, if you're making code
that will be used going forward,

00:34:34.255 --> 00:34:36.226 A:middle
we prefer using the
NSNumberFormatter.

00:34:36.735 --> 00:34:38.476 A:middle
Here you call localized
string with number,

00:34:38.636 --> 00:34:41.246 A:middle
pass in your NSNumber,
and pass in again,

00:34:41.246 --> 00:34:43.036 A:middle
an explicit format string.

00:34:43.976 --> 00:34:46.985 A:middle
And, this will do the
heavy lifting for you

00:34:46.985 --> 00:34:47.956 A:middle
in presenting a number

00:34:47.956 --> 00:34:50.346 A:middle
in a locale appropriate
manner for a given user.

00:34:52.016 --> 00:34:55.766 A:middle
So, like NSDateFormatter, we
have explicit preset styles.

00:34:56.136 --> 00:34:57.246 A:middle
Here's what these look like.

00:34:57.526 --> 00:35:00.186 A:middle
Let's start with an NSNumber
literal, denoted by the at sign,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:00.186 --> 00:35:03.846 A:middle
followed by the number, 1234.56,

00:35:04.446 --> 00:35:06.786 A:middle
decimal style will
do the correct thing.

00:35:06.786 --> 00:35:10.936 A:middle
Here on this table we have,
the left column is US English,

00:35:10.936 --> 00:35:12.626 A:middle
and on the right are
variants you may encounter

00:35:12.626 --> 00:35:13.146 A:middle
around the world.

00:35:13.946 --> 00:35:16.746 A:middle
Again, see in Italy,
we have the period

00:35:16.746 --> 00:35:17.676 A:middle
and the coma have flipped.

00:35:18.146 --> 00:35:19.736 A:middle
Currency style is
different in China.

00:35:20.216 --> 00:35:23.406 A:middle
Percentage style differs
in these two aspects again,

00:35:23.406 --> 00:35:25.916 A:middle
and even scientific style can
differ in that it uses the comma

00:35:25.916 --> 00:35:27.596 A:middle
to separate out the
significant digits.

00:35:28.736 --> 00:35:31.076 A:middle
Finally, the spell out style
itself can be dramatically

00:35:31.076 --> 00:35:32.526 A:middle
different between both locales.

00:35:32.806 --> 00:35:37.226 A:middle
So, let's go into more detail

00:35:37.226 --> 00:35:39.106 A:middle
about the NSLocale
object itself.

00:35:40.036 --> 00:35:43.156 A:middle
Traditionally, the
standard API's will do,

00:35:43.156 --> 00:35:45.176 A:middle
take into account this
information for you.

00:35:45.176 --> 00:35:49.526 A:middle
To give it as an information,
sorry, to give it as an argument

00:35:49.526 --> 00:35:51.656 A:middle
to an NSNumberFormatter
and NSDateFormatter,

00:35:51.966 --> 00:35:54.966 A:middle
you can call current
locale the class method

00:35:54.966 --> 00:35:57.896 A:middle
or auto updating current
locale, which will listen

00:35:57.896 --> 00:35:59.476 A:middle
for notification that indicates

00:35:59.476 --> 00:36:02.626 A:middle
that the user has changed your
locale as your app is running.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:03.736 --> 00:36:06.776 A:middle
From there, if you
want even more detail,

00:36:06.836 --> 00:36:09.176 A:middle
you can create an instance
of the NSLocale class.

00:36:09.596 --> 00:36:13.566 A:middle
From there, you can call object
for key with various keys

00:36:13.566 --> 00:36:14.536 A:middle
to get more information.

00:36:15.276 --> 00:36:17.266 A:middle
For instance, let's
say you want to see

00:36:17.266 --> 00:36:19.096 A:middle
if a given user uses
the metric system.

00:36:19.576 --> 00:36:22.586 A:middle
This information is stored in an
instance of the NSLocale class.

00:36:22.996 --> 00:36:25.656 A:middle
You call object for key
with uses metric system.

00:36:26.446 --> 00:36:28.446 A:middle
Likewise, you can get
the currency symbol,

00:36:28.826 --> 00:36:30.336 A:middle
or for a slightly
more detailed example,

00:36:30.336 --> 00:36:31.346 A:middle
you can get the beginning

00:36:31.346 --> 00:36:33.306 A:middle
and end quotation marks
for a given locale.

00:36:33.936 --> 00:36:36.856 A:middle
All this is available from an
instance of NSLocale class.

00:36:38.006 --> 00:36:41.736 A:middle
So, here, let's see what this
looks like in a real example,

00:36:41.736 --> 00:36:43.006 A:middle
where you call a
string from format,

00:36:43.006 --> 00:36:46.916 A:middle
and pass in our previously
obtained beginning quote string

00:36:46.916 --> 00:36:47.456 A:middle
and end quote.

00:36:47.766 --> 00:36:50.476 A:middle
As a result, we have the
appropriate quotation marks

00:36:50.476 --> 00:36:52.516 A:middle
for China, France, and Japan.

00:36:52.606 --> 00:36:54.646 A:middle
We have the angle
brackets for France

00:36:54.646 --> 00:36:56.076 A:middle
and the square brackets
for Japan.

00:36:56.576 --> 00:37:00.766 A:middle
Keep in mind though,
the distinction

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:00.766 --> 00:37:02.686 A:middle
between a locale
and a localization.

00:37:04.076 --> 00:37:07.106 A:middle
To get a given user's
localization, that is to say,

00:37:07.316 --> 00:37:08.776 A:middle
the user interface language

00:37:08.776 --> 00:37:10.716 A:middle
that the user is
running your app within,

00:37:10.956 --> 00:37:13.416 A:middle
you call preferred
localizations on an instance

00:37:13.416 --> 00:37:14.616 A:middle
of the NSBundle class.

00:37:15.036 --> 00:37:17.946 A:middle
On the other hand, to get the
locale you call current locale

00:37:17.946 --> 00:37:18.976 A:middle
on the locale object.

00:37:19.396 --> 00:37:21.606 A:middle
This is what you'll be passing
into the formatting objects

00:37:21.976 --> 00:37:24.466 A:middle
in order to obtain the
appropriate representation.

00:37:26.196 --> 00:37:28.846 A:middle
So, one final area in which
you'll see a lot of variation

00:37:28.846 --> 00:37:32.686 A:middle
around the world is in the
presentation of calendars.

00:37:32.746 --> 00:37:35.516 A:middle
We may take for granted
that this is the year 2013,

00:37:35.756 --> 00:37:38.766 A:middle
or year 2011, and you
can see that in fact,

00:37:38.816 --> 00:37:45.676 A:middle
this is simultaneously also
the year 1432, 2554, 5771.

00:37:45.676 --> 00:37:48.756 A:middle
Likewise, this era
is AD or CE here,

00:37:48.756 --> 00:37:50.666 A:middle
but in Japan, it's
the Hassay era.

00:37:50.666 --> 00:37:53.256 A:middle
The number of months per
year, length of the months,

00:37:53.256 --> 00:37:54.756 A:middle
the day of the week
itself can vary,

00:37:55.156 --> 00:37:56.906 A:middle
and even the transition
of years.

00:37:57.246 --> 00:37:59.536 A:middle
Now, here we have a transition
between the Showa period

00:37:59.536 --> 00:38:00.956 A:middle
and the Hassay period in Japan,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:01.276 --> 00:38:03.296 A:middle
which happened as
recently as 1989.

00:38:03.886 --> 00:38:08.746 A:middle
So, to interact with calendars,
we use the NSCalendar object.

00:38:09.096 --> 00:38:10.576 A:middle
This allows us to
do calculations

00:38:10.576 --> 00:38:11.506 A:middle
in a more intelligent way.

00:38:12.466 --> 00:38:14.506 A:middle
It also, it allows us to
obtain the information we saw

00:38:14.506 --> 00:38:16.346 A:middle
in the previous table, the
number of days in the month,

00:38:16.346 --> 00:38:19.496 A:middle
weeks in the year, etc. It also
allows us to get components

00:38:19.496 --> 00:38:20.766 A:middle
from the date, that
then we can add

00:38:20.766 --> 00:38:24.236 A:middle
on to additional NSDate objects
to get dates in the future.

00:38:25.516 --> 00:38:28.206 A:middle
Likewise, as I said, you
can do delta computations

00:38:28.206 --> 00:38:30.016 A:middle
between two NSDate objects.

00:38:31.036 --> 00:38:34.936 A:middle
So, keep in mind though that NS
date itself is an abstract point

00:38:34.936 --> 00:38:35.516 A:middle
in time.

00:38:36.266 --> 00:38:39.236 A:middle
You must interpret this NS
date object through the lens

00:38:39.236 --> 00:38:41.796 A:middle
of an NSCalendar if you're
presenting it to the user.

00:38:42.476 --> 00:38:43.766 A:middle
If you're using a
code internally,

00:38:43.766 --> 00:38:45.946 A:middle
of course it's still fine
to use the NSDate object.

00:38:46.016 --> 00:38:51.066 A:middle
So, let's see an example of
getting the components of a date

00:38:51.066 --> 00:38:52.056 A:middle
that may be of interest to you.

00:38:52.596 --> 00:38:55.476 A:middle
We here, call components
from date,

00:38:55.476 --> 00:38:57.106 A:middle
passing in our NSDate object,

00:38:57.526 --> 00:39:00.106 A:middle
and passing in the individual
units that we wish to obtain.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:00.676 --> 00:39:03.796 A:middle
Keep in mind here, you'll
only obtain these units

00:39:03.796 --> 00:39:06.496 A:middle
that you explicitly specify
that are returned in the form

00:39:06.496 --> 00:39:08.236 A:middle
of an NSDateComponents object.

00:39:09.326 --> 00:39:11.746 A:middle
From there, you can
call day, month, year,

00:39:11.746 --> 00:39:13.616 A:middle
and era to get this
information out of the object

00:39:13.616 --> 00:39:14.416 A:middle
that you've just created.

00:39:15.046 --> 00:39:17.366 A:middle
You can then this NS
date components object

00:39:17.616 --> 00:39:23.216 A:middle
onto an additional NSCalendar
method to add these components

00:39:23.246 --> 00:39:25.966 A:middle
to an existing NSDate, and
obtain a date in the future.

00:39:26.836 --> 00:39:30.526 A:middle
Now, this is important because
calendar computations can

00:39:30.526 --> 00:39:31.576 A:middle
be complicated.

00:39:32.696 --> 00:39:34.766 A:middle
The common thing to
keep in mind is that,

00:39:34.766 --> 00:39:37.236 A:middle
let's say we do some simple
arithmetic and we say,

00:39:37.446 --> 00:39:40.436 A:middle
well a day is 60
x 60 x 24 seconds.

00:39:40.686 --> 00:39:43.506 A:middle
So, if I go 86,400
seconds into the future,

00:39:43.726 --> 00:39:45.226 A:middle
I will be at this time tomorrow.

00:39:45.596 --> 00:39:48.726 A:middle
However, keep in mind
that on the border

00:39:48.726 --> 00:39:50.416 A:middle
between daylight savings time

00:39:50.416 --> 00:39:52.596 A:middle
and non-daylight savings
time, this is not the case.

00:39:53.416 --> 00:39:55.936 A:middle
Likewise, one month is not
always 30 days in the future.

00:39:56.216 --> 00:39:59.426 A:middle
One year is not always
525,600 minutes,

00:39:59.426 --> 00:40:01.286 A:middle
despite what the song may say.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:01.496 --> 00:40:03.206 A:middle
So, for more information
on this,

00:40:03.206 --> 00:40:04.566 A:middle
you can see tomorrow's
presentation,

00:40:04.566 --> 00:40:05.836 A:middle
date and time challenges.

00:40:06.676 --> 00:40:08.546 A:middle
I assure you its quite
complicated, but they'll go

00:40:08.546 --> 00:40:09.916 A:middle
into a lot of information
about this.

00:40:10.866 --> 00:40:13.726 A:middle
So, with that, I'll pack to
Doug, and we'll do a demo

00:40:13.756 --> 00:40:14.776 A:middle
of seeing this in real life.

00:40:15.266 --> 00:40:17.266 A:middle
[ Applause ]

00:40:17.516 --> 00:40:18.006 A:middle
&gt;&gt; Thanks, Nat.

00:40:18.946 --> 00:40:21.466 A:middle
Alright. So, let me go back

00:40:21.536 --> 00:40:24.506 A:middle
to my first crude
unlocalized application,

00:40:25.206 --> 00:40:31.236 A:middle
and notice that it prints a
little header in front of each

00:40:31.236 --> 00:40:35.136 A:middle
of my notes that shows an
index number; I've started

00:40:35.136 --> 00:40:37.936 A:middle
with a thousand, just so I
can illustrate some things,

00:40:38.286 --> 00:40:39.436 A:middle
and a date.

00:40:40.046 --> 00:40:43.476 A:middle
Unfortunately, the format I've
chosen for this is pretty crude.

00:40:44.086 --> 00:40:45.866 A:middle
Let's see what that
looks like in code.

00:40:47.476 --> 00:40:51.006 A:middle
So, I'm just creating
using string with format

00:40:51.576 --> 00:40:55.426 A:middle
from the NSNumber and NSDate
attached to my note object.

00:40:55.876 --> 00:40:57.866 A:middle
Now, that's the sort of thing
that I might want to use

00:40:57.946 --> 00:41:01.226 A:middle
for an internal machinery
for full representation,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:01.226 --> 00:41:03.686 A:middle
but it's not the sort of thing
I want to present to my users.

00:41:03.686 --> 00:41:06.996 A:middle
I really want to give them
locale appropriate presentations

00:41:06.996 --> 00:41:08.236 A:middle
of the number and the date.

00:41:09.286 --> 00:41:13.866 A:middle
So, let me go and see what
that looks like in my updated,

00:41:14.096 --> 00:41:15.656 A:middle
properly localized application.

00:41:16.956 --> 00:41:19.006 A:middle
So, what I've chosen
to do here is

00:41:19.006 --> 00:41:22.436 A:middle
to create an NSDateFormatter
and an NSNumberFormatter

00:41:22.436 --> 00:41:23.876 A:middle
to format these two objects.

00:41:24.566 --> 00:41:28.056 A:middle
Once I have those, it's
just a simple matter

00:41:28.056 --> 00:41:33.946 A:middle
of replacing the index
number and date in my string

00:41:33.946 --> 00:41:37.256 A:middle
with format with the
properly formatted results

00:41:37.256 --> 00:41:39.116 A:middle
of calling string
from number and string

00:41:39.116 --> 00:41:41.336 A:middle
from date using my
number formatter

00:41:41.336 --> 00:41:42.716 A:middle
and date formatter objects.

00:41:43.266 --> 00:41:46.306 A:middle
So, to do that, I have to
create the date formatter

00:41:46.306 --> 00:41:48.546 A:middle
and the number formatter,
which is pretty simple.

00:41:49.356 --> 00:41:53.046 A:middle
I've chosen to use a custom
format for my date formatter,

00:41:53.046 --> 00:41:55.206 A:middle
so I create a date
format from template,

00:41:55.596 --> 00:41:59.236 A:middle
with a simple template,
month, day, hour and minute,

00:41:59.916 --> 00:42:03.946 A:middle
and then I set that date format
that I got on my date formatter,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:03.946 --> 00:42:06.656 A:middle
and it's ready to go
for my number formatter.

00:42:06.816 --> 00:42:11.316 A:middle
I just create it, and I set
an appropriate style on it.

00:42:11.316 --> 00:42:15.096 A:middle
There are also, if you want to
customize your number formatter,

00:42:15.096 --> 00:42:16.546 A:middle
there are many, many
different options,

00:42:16.546 --> 00:42:18.656 A:middle
so you can control
all the various pieces

00:42:18.656 --> 00:42:19.466 A:middle
of number formatting.

00:42:19.986 --> 00:42:23.376 A:middle
The only thing I'm doing here
is saying I don't want floats.

00:42:24.416 --> 00:42:26.866 A:middle
So, I set that up at the
beginning of my application,

00:42:27.506 --> 00:42:30.766 A:middle
and then I have my date
formatter and number formatter

00:42:30.766 --> 00:42:33.986 A:middle
that I can use whenever I have
to format one of these headers.

00:42:34.816 --> 00:42:37.426 A:middle
Now, one thing I did
want to keep in mind is

00:42:37.426 --> 00:42:40.206 A:middle
that the user might change their
locale while my app is running,

00:42:40.946 --> 00:42:43.956 A:middle
and if they do that, then I'm
stuck with this number formatter

00:42:43.956 --> 00:42:46.106 A:middle
or date formatter that I
created for the old locale.

00:42:46.146 --> 00:42:48.996 A:middle
So, I want to listen
to a notification,

00:42:49.946 --> 00:42:55.046 A:middle
a little further down, I'm going
to add myself as an observer

00:42:55.046 --> 00:42:59.326 A:middle
to the locale that changed
notification, and when I get

00:42:59.326 --> 00:43:01.786 A:middle
that notification, I'm just
going to recreate my formatters

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:01.836 --> 00:43:03.256 A:middle
with whatever the new locale is.

00:43:04.396 --> 00:43:06.736 A:middle
So, now my app should be ready.

00:43:07.556 --> 00:43:09.506 A:middle
Let's try running it in English,

00:43:13.846 --> 00:43:17.306 A:middle
and I see that I got
properly formatted numbers

00:43:17.346 --> 00:43:18.796 A:middle
and dates for English.

00:43:19.166 --> 00:43:24.346 A:middle
I also note that my title of the
window is changing appropriately

00:43:25.996 --> 00:43:31.776 A:middle
with my using string stick to
give appropriate representations

00:43:32.006 --> 00:43:34.206 A:middle
for the proper pluralization,

00:43:35.256 --> 00:43:40.186 A:middle
and so my numbers are formatted
using the appropriate thousand

00:43:40.186 --> 00:43:45.716 A:middle
separator for English, and
I get a suitable date format

00:43:45.716 --> 00:43:50.106 A:middle
and number format for English
showing first the month name

00:43:50.256 --> 00:43:58.436 A:middle
and day, followed by the
time in 12 hour format.

00:43:58.576 --> 00:44:01.946 A:middle
So, now if I go into
the system preferences,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:01.946 --> 00:44:05.686 A:middle
I change my primary language
to English, and my region

00:44:06.036 --> 00:44:13.846 A:middle
from English to German, and my
region format also to Germany.

00:44:16.296 --> 00:44:19.116 A:middle
Let's try running the
app again in German.

00:44:19.116 --> 00:44:24.876 A:middle
Of course, the interface is
localized to German, let's see,

00:44:25.926 --> 00:44:34.096 A:middle
and now we can see that I
get appropriately formatted

00:44:34.206 --> 00:44:37.276 A:middle
for German with the
right thousand separator,

00:44:37.336 --> 00:44:40.916 A:middle
rather than a comma, and
appropriately formatted dates

00:44:41.516 --> 00:44:45.486 A:middle
with a day number, month name,

00:44:45.816 --> 00:44:49.826 A:middle
and using 24 hour
format for the hours.

00:44:50.586 --> 00:44:56.226 A:middle
And, we can see also that
are string stick is giving us

00:44:56.286 --> 00:45:07.406 A:middle
appropriately pluralized titles
as the number of notes changes.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:08.266 --> 00:45:11.996 A:middle
So, that's using date
and number formatters

00:45:12.736 --> 00:45:16.496 A:middle
to get properly formatted
user representations

00:45:16.846 --> 00:45:18.496 A:middle
of dates and numbers.

00:45:18.986 --> 00:45:20.296 A:middle
Now, let me go back
to the slides,

00:45:21.746 --> 00:45:23.756 A:middle
and let me talk about text.

00:45:24.536 --> 00:45:26.986 A:middle
Now, there are many
applications that deal with text

00:45:27.206 --> 00:45:28.476 A:middle
in one form or another.

00:45:28.866 --> 00:45:32.086 A:middle
Maybe your app is representing
text to the user that it got

00:45:32.086 --> 00:45:34.686 A:middle
from some external source, or
maybe you're dealing with text

00:45:34.746 --> 00:45:37.966 A:middle
that the user entered
themselves, but in either case,

00:45:38.116 --> 00:45:40.846 A:middle
you need to deal with all
the kinds of writing systems

00:45:40.846 --> 00:45:42.656 A:middle
that the users are
going to want to see.

00:45:43.166 --> 00:45:45.276 A:middle
I have some examples here.

00:45:45.276 --> 00:45:49.576 A:middle
These are all writing
systems for which we have font

00:45:49.576 --> 00:45:52.046 A:middle
and input method support
on both iOS and OS X.

00:45:52.546 --> 00:45:53.926 A:middle
You want to be able
to handle them all.

00:45:54.906 --> 00:45:56.956 A:middle
Well, here's some simple
rules for doing that.

00:45:56.956 --> 00:46:01.456 A:middle
The first one is, use
Unicode and in particular,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:01.626 --> 00:46:04.676 A:middle
the NSString class, which is
our standard representation

00:46:04.736 --> 00:46:07.576 A:middle
of the Unicode string
for representing text.

00:46:08.556 --> 00:46:13.186 A:middle
A second one is that when you
want to analyze this text,

00:46:13.346 --> 00:46:15.516 A:middle
going into or do something
to it, iterate through it,

00:46:15.516 --> 00:46:17.476 A:middle
search for a substring,
sort it, etc.,

00:46:17.846 --> 00:46:20.026 A:middle
use some of the standard
NSString API's,

00:46:20.836 --> 00:46:24.216 A:middle
which are all Unicode savvy,
and will deal with text in many

00:46:24.216 --> 00:46:25.406 A:middle
in many different
writing systems,

00:46:25.866 --> 00:46:28.816 A:middle
and as much as possible, use
the standard system views

00:46:28.816 --> 00:46:32.726 A:middle
and controls for displaying that
text or for accepting input.

00:46:32.726 --> 00:46:35.146 A:middle
Let me go into that
in some more detail.

00:46:35.736 --> 00:46:39.366 A:middle
So, Unicode is a
standard that allows us

00:46:39.366 --> 00:46:43.476 A:middle
to encode essentially all of the
world's living writing systems,

00:46:43.596 --> 00:46:45.696 A:middle
most of its date blocks
in a single strength,

00:46:46.926 --> 00:46:52.136 A:middle
we use NSString as our standard
Unicode containing object,

00:46:53.166 --> 00:46:57.506 A:middle
and it exposes the
contents using the UTF 16

00:46:57.506 --> 00:46:58.536 A:middle
and coding format.

00:46:59.736 --> 00:47:02.796 A:middle
The thing I want you to
remember about using Unicode

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:02.796 --> 00:47:08.396 A:middle
to represent text, is that you
cannot treat what the user sees

00:47:08.396 --> 00:47:10.466 A:middle
as a character as
being something

00:47:10.466 --> 00:47:12.646 A:middle
that is fixed length in memory.

00:47:13.366 --> 00:47:16.206 A:middle
That's true no matter what
encoding form you're using

00:47:16.206 --> 00:47:17.716 A:middle
or what normalization
form you're using.

00:47:17.716 --> 00:47:19.936 A:middle
It's just a fundamental
property of Unicode.

00:47:20.446 --> 00:47:22.776 A:middle
So, what we recommend
that you do is not deal

00:47:22.776 --> 00:47:24.826 A:middle
with individual characters
in a string.

00:47:25.216 --> 00:47:28.306 A:middle
Instead, work with ranges
of characters in a string

00:47:28.306 --> 00:47:29.556 A:middle
or substrings of a string.

00:47:31.376 --> 00:47:32.456 A:middle
Let me give you some examples.

00:47:32.456 --> 00:47:36.186 A:middle
So, here I have a Chinese
character, a Korean syllable,

00:47:36.186 --> 00:47:37.376 A:middle
and a couple of emogies.

00:47:37.946 --> 00:47:42.896 A:middle
And their representations
numerically in UTF 16 or UTF 32,

00:47:42.896 --> 00:47:46.446 A:middle
you can see that they all have
different lengths no matter what

00:47:46.446 --> 00:47:47.696 A:middle
encoding formats you've used.

00:47:48.896 --> 00:47:51.726 A:middle
So, to avoid dealing
with all this complexity,

00:47:51.726 --> 00:47:52.976 A:middle
you can use standard API's,

00:47:53.956 --> 00:47:56.866 A:middle
like range of composed
character sequence at index,

00:47:57.246 --> 00:47:59.836 A:middle
so this will give you
the range within a string

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:00.336 --> 00:48:03.856 A:middle
of what is effectively
user visible character,

00:48:03.856 --> 00:48:06.166 A:middle
what we call a composed
character sequence

00:48:06.236 --> 00:48:08.726 A:middle
or sometimes a character
cluster for short.

00:48:09.706 --> 00:48:13.156 A:middle
So we use this API, it will give
you the range that corresponds

00:48:13.156 --> 00:48:15.676 A:middle
to what the user is seeing
as a character and respect

00:48:15.736 --> 00:48:18.156 A:middle
that range, so you don't
split these things up,

00:48:18.156 --> 00:48:20.466 A:middle
and end up with broken text.

00:48:21.876 --> 00:48:25.366 A:middle
If you need to go through
a string; maybe you need

00:48:25.366 --> 00:48:27.746 A:middle
to through it by
character cluster or by word

00:48:27.746 --> 00:48:30.566 A:middle
or by sentence or by paragraph,
we have a standard API for that.

00:48:30.986 --> 00:48:33.876 A:middle
Innumerate substrings and
range options using block.

00:48:34.476 --> 00:48:37.546 A:middle
Depending on what options you
pass in, you can through it

00:48:37.906 --> 00:48:40.446 A:middle
by character cluster,
by word sentence, etc.,

00:48:41.306 --> 00:48:44.206 A:middle
and then you give it a block,
and your block gets called

00:48:44.206 --> 00:48:46.256 A:middle
with the range of each
individual component.

00:48:46.256 --> 00:48:47.716 A:middle
For example, if you're
going through it

00:48:47.716 --> 00:48:51.496 A:middle
by user visible characters,
character clusters,

00:48:52.496 --> 00:48:54.016 A:middle
you use the NSString
enumeration

00:48:54.016 --> 00:48:56.046 A:middle
by composed character
sequences options,

00:48:56.046 --> 00:48:59.266 A:middle
and then your block will
be called successively

00:48:59.516 --> 00:49:03.256 A:middle
with the range and the string
corresponding to this character,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:03.256 --> 00:49:08.086 A:middle
whatever it may be,
whether it's short or long.

00:49:08.276 --> 00:49:10.016 A:middle
Likewise, if you're going
through it by words,

00:49:10.016 --> 00:49:11.776 A:middle
use NSString enumeration
by words,

00:49:11.826 --> 00:49:15.566 A:middle
and your block will be called
successfully with the range

00:49:15.626 --> 00:49:17.706 A:middle
of each word and the text notice

00:49:17.806 --> 00:49:20.156 A:middle
that words are not necessarily
going to be separated

00:49:20.276 --> 00:49:22.316 A:middle
by punctuation or white space.

00:49:22.896 --> 00:49:26.856 A:middle
If you need to search for a
substring within a string,

00:49:27.046 --> 00:49:28.666 A:middle
there's a standard
API for that too.

00:49:29.176 --> 00:49:31.526 A:middle
Range of string options,
range locale.

00:49:31.986 --> 00:49:35.396 A:middle
There are a number of different
options you can pass in for case

00:49:35.396 --> 00:49:36.976 A:middle
and sensitive searching,
die printing

00:49:36.976 --> 00:49:38.886 A:middle
and sensitive searching,
if you're searching

00:49:38.886 --> 00:49:40.096 A:middle
for something user provider,

00:49:40.576 --> 00:49:42.726 A:middle
there's a good change you may
want to use both of those.

00:49:43.476 --> 00:49:45.346 A:middle
You can search forwards
or backwards.

00:49:46.006 --> 00:49:48.336 A:middle
There's the also the
anchored search option.

00:49:48.336 --> 00:49:51.826 A:middle
If you pass that in, you're not
looking for the next instance

00:49:51.926 --> 00:49:55.406 A:middle
of the substring, you're looking
to see whether it's present

00:49:55.406 --> 00:49:58.016 A:middle
or not at the given
location you start at,

00:49:58.996 --> 00:49:59.976 A:middle
which is often useful too.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:01.396 --> 00:50:04.856 A:middle
And, sorting.

00:50:05.546 --> 00:50:09.526 A:middle
If you need to sort strings in
such a way as to present them

00:50:09.526 --> 00:50:13.516 A:middle
to the user in sorted order,
you have to keep in mind

00:50:13.726 --> 00:50:17.426 A:middle
that each different
language; not just language,

00:50:17.506 --> 00:50:21.676 A:middle
but each country or region,
may have a different standard,

00:50:21.836 --> 00:50:25.326 A:middle
sort order, in which they
like to see strings presented.

00:50:26.046 --> 00:50:29.676 A:middle
Some die critics are sensitive,
important, sometimes not,

00:50:30.316 --> 00:50:33.096 A:middle
even what constitutes a
letter for sorting may change,

00:50:33.446 --> 00:50:35.336 A:middle
and if you don't put
things in the right order,

00:50:35.336 --> 00:50:36.216 A:middle
people are not going to be able

00:50:36.216 --> 00:50:37.316 A:middle
to find what they're
looking for.

00:50:38.136 --> 00:50:42.246 A:middle
Now, there are a couple of API's
that you might look at for this.

00:50:42.246 --> 00:50:43.916 A:middle
NSString has a standard
compare method

00:50:43.916 --> 00:50:46.656 A:middle
and a localized standard
compare, so the difference is

00:50:46.956 --> 00:50:50.446 A:middle
that the compare method
is that locale and variant

00:50:50.696 --> 00:50:54.566 A:middle
for internal machinery
purposes for sorting.

00:50:55.946 --> 00:50:58.786 A:middle
That's not what you want to use
for user presentation of text.

00:50:59.046 --> 00:51:01.806 A:middle
For user presentation of text,
use localized standard compare.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:02.256 --> 00:51:03.616 A:middle
That will be locale sensitive.

00:51:03.616 --> 00:51:06.636 A:middle
It will give you the
order that users expect.

00:51:07.436 --> 00:51:10.536 A:middle
It will match, for
example, the order of files

00:51:10.536 --> 00:51:12.276 A:middle
that are sorted in the finder.

00:51:13.706 --> 00:51:14.936 A:middle
So, let me give you
a few examples.

00:51:15.506 --> 00:51:16.676 A:middle
Here is a set of strings.

00:51:16.776 --> 00:51:18.596 A:middle
Here's the order that
you would get them

00:51:18.596 --> 00:51:19.646 A:middle
if you sorted them according

00:51:19.646 --> 00:51:23.056 A:middle
to the locale independent
internal compare method.

00:51:24.166 --> 00:51:29.616 A:middle
If we change this to localized
standard compare for let us say,

00:51:29.616 --> 00:51:30.606 A:middle
the US English locale,

00:51:31.066 --> 00:51:33.576 A:middle
you notice that the
order changes a fair bit.

00:51:34.626 --> 00:51:37.156 A:middle
If we were using
Danish sort order,

00:51:37.566 --> 00:51:38.926 A:middle
it changes even still further,

00:51:39.146 --> 00:51:41.106 A:middle
or we're using a
Chinese sort order,

00:51:41.406 --> 00:51:42.696 A:middle
it changes quite a bit again.

00:51:43.406 --> 00:51:44.356 A:middle
So, use the standard API,

00:51:44.356 --> 00:51:47.046 A:middle
and you'll get the sort
order users expect;

00:51:47.126 --> 00:51:48.466 A:middle
whatever it may happen to be.

00:51:50.486 --> 00:51:56.256 A:middle
For displaying text, keep
in mind that the characters

00:51:56.536 --> 00:51:59.756 A:middle
as they appear in the string
are not necessarily directly

00:51:59.756 --> 00:52:03.586 A:middle
correlated with what
gets shown on the screen.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:04.006 --> 00:52:06.746 A:middle
So, what gets shown on the
screen is a sequence of glifs.

00:52:06.746 --> 00:52:10.916 A:middle
A glif is the smallest unit from
a font that can be displayed.

00:52:10.916 --> 00:52:13.376 A:middle
It may represent one character
or more than one character

00:52:13.826 --> 00:52:15.036 A:middle
or a part of a character.

00:52:15.946 --> 00:52:18.206 A:middle
The mapping between the
characters in memory

00:52:18.206 --> 00:52:21.106 A:middle
and the glifs that are shown
is not necessarily simple

00:52:21.106 --> 00:52:25.806 A:middle
and general, it can mean many
to many, and even the ordering

00:52:26.036 --> 00:52:28.256 A:middle
of glifs within a line
can become complex.

00:52:29.096 --> 00:52:33.336 A:middle
Now, our standard views and
controls use the text system

00:52:33.946 --> 00:52:37.596 A:middle
to get proper Unicode
layout and display,

00:52:37.596 --> 00:52:38.726 A:middle
so use them as much as possible.

00:52:38.726 --> 00:52:40.486 A:middle
If you need to go beyond that

00:52:40.486 --> 00:52:44.446 A:middle
and do custom display,
use text API's.

00:52:45.006 --> 00:52:48.996 A:middle
Now it used to be, this was more
difficult on iOS than on OS X,

00:52:49.596 --> 00:52:51.346 A:middle
because on iOS, you had
to go down all the way

00:52:51.346 --> 00:52:53.126 A:middle
to the core text level to do it.

00:52:53.256 --> 00:52:55.366 A:middle
Not anymore.

00:52:55.936 --> 00:52:58.966 A:middle
With the iOS 7, we
have text kit API's,

00:52:58.966 --> 00:53:01.806 A:middle
and there are some
excellent sessions on this.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:01.846 --> 00:53:03.676 A:middle
There was an introductory
session yesterday.

00:53:04.116 --> 00:53:06.636 A:middle
There is a more advanced
session this afternoon

00:53:06.636 --> 00:53:09.686 A:middle
that will tell you exactly how
they keep track of the mapping

00:53:09.686 --> 00:53:15.116 A:middle
between the characters and
the glifs that display them.

00:53:15.416 --> 00:53:19.506 A:middle
Here's an example; I got
this from a developer.

00:53:19.676 --> 00:53:22.796 A:middle
This is some English text with
some Hebrew in the middle.

00:53:22.796 --> 00:53:24.696 A:middle
So, English goes left to right.

00:53:25.166 --> 00:53:26.336 A:middle
Hebrew goes right to left.

00:53:26.336 --> 00:53:29.016 A:middle
You put them together, you
have bidirectional text.

00:53:29.686 --> 00:53:32.126 A:middle
This is the proper order
for displaying the text,

00:53:33.136 --> 00:53:35.286 A:middle
but the way it shows up in
memory is very different.

00:53:35.406 --> 00:53:38.616 A:middle
It starts off with the English
on the left, flowing from left

00:53:38.616 --> 00:53:41.386 A:middle
to right, then the Hebrew
in logical order flows

00:53:41.976 --> 00:53:44.446 A:middle
for the first character,

00:53:44.446 --> 00:53:47.186 A:middle
which shows up as the
right-most one and so on.

00:53:48.046 --> 00:53:49.396 A:middle
Then this exclamation point;

00:53:50.206 --> 00:53:53.236 A:middle
it's a bit ambiguous whether
the explanation point goes

00:53:53.236 --> 00:53:54.976 A:middle
with the Hebrew or the English.

00:53:54.976 --> 00:53:56.066 A:middle
Here it goes with Hebrew.

00:53:56.406 --> 00:53:58.776 A:middle
In order to specify that,

00:53:58.856 --> 00:54:01.466 A:middle
there are some Unicode control
characters that are included

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:01.466 --> 00:54:04.756 A:middle
in this text and these
are things that may show

00:54:04.756 --> 00:54:05.646 A:middle
up in text that you get.

00:54:05.646 --> 00:54:08.496 A:middle
Text that you get from
an external source

00:54:08.496 --> 00:54:12.036 A:middle
or from your localizers, or
sometimes text from formatters

00:54:12.176 --> 00:54:14.816 A:middle
in bidirectional text languages.

00:54:14.906 --> 00:54:18.446 A:middle
It may include these to
specify certain cases

00:54:18.446 --> 00:54:19.766 A:middle
that are otherwise ambiguous.

00:54:20.196 --> 00:54:25.096 A:middle
And again, the text API's and
the standard system controls

00:54:25.096 --> 00:54:26.886 A:middle
and fields will handle
this properly,

00:54:27.186 --> 00:54:30.936 A:middle
and give you the appropriate
Unicode sensitive bidirectional

00:54:31.166 --> 00:54:32.766 A:middle
layout of this text.

00:54:33.986 --> 00:54:36.166 A:middle
Text input; it's
important to keep in mind

00:54:36.306 --> 00:54:41.036 A:middle
that it's not always a
matter of pressing a key

00:54:41.456 --> 00:54:43.996 A:middle
and getting a letter
in the text.

00:54:44.566 --> 00:54:48.216 A:middle
For languages that use complex
input methods like Chinese

00:54:48.216 --> 00:54:50.426 A:middle
and Japanese, usually
what will happen is

00:54:50.426 --> 00:54:52.986 A:middle
that the user types
a representation;

00:54:52.986 --> 00:54:55.566 A:middle
a phonetic representation
perhaps of the text they want,

00:54:55.966 --> 00:54:58.336 A:middle
that gets preliminarily
inserted into the text.

00:54:59.176 --> 00:55:02.086 A:middle
Then the system shows them
some options of choices,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:02.086 --> 00:55:03.766 A:middle
and they pick the one
they actually want,

00:55:03.766 --> 00:55:04.966 A:middle
and after that gets confirmed,

00:55:04.966 --> 00:55:06.646 A:middle
and that's the final
text that goes in.

00:55:07.056 --> 00:55:10.876 A:middle
So, in this case, the text on
the left has been confirmed.

00:55:11.046 --> 00:55:13.286 A:middle
The underlying text;
it's called marked text,

00:55:13.286 --> 00:55:17.386 A:middle
is preliminary only, and then
they'll pick one, and again,

00:55:17.386 --> 00:55:18.626 A:middle
this is what it looks like OS X.

00:55:18.626 --> 00:55:21.886 A:middle
This is what is looks like
on iOS; the same text.

00:55:22.356 --> 00:55:24.216 A:middle
It's not just for
Chinese and Japanese too.

00:55:24.506 --> 00:55:29.116 A:middle
On OS X, if you press and hold
to get accenting characters,

00:55:29.116 --> 00:55:31.706 A:middle
it's the same, your preliminary
character gets insert,

00:55:31.706 --> 00:55:33.276 A:middle
then the user picks
the final one.

00:55:34.136 --> 00:55:37.276 A:middle
So, if you're dealing with text
as its input, keep in mind,

00:55:37.696 --> 00:55:40.226 A:middle
it's not just a simple matter of
being inserted letter by letter,

00:55:40.276 --> 00:55:44.006 A:middle
there may be this preliminary
marked test that shows

00:55:44.006 --> 00:55:46.146 A:middle
up in your text view first.

00:55:47.176 --> 00:55:51.476 A:middle
If you're dealing with text as
it changes, deal with it change

00:55:51.476 --> 00:55:54.966 A:middle
by change, not keystroke by
keystroke, and you probably want

00:55:54.966 --> 00:55:56.836 A:middle
to notice that text
views will tell you

00:55:56.836 --> 00:55:58.406 A:middle
if there's marked
text from where it is.

00:55:58.906 --> 00:56:00.376 A:middle
You probably don't want
to operate on that,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:00.376 --> 00:56:03.906 A:middle
because it's only preliminary,
it's not the final text.

00:56:04.336 --> 00:56:06.886 A:middle
One last thing to mention
is that names, addresses,

00:56:06.886 --> 00:56:09.646 A:middle
and phone numbers vary quite
a bit around the world.

00:56:10.266 --> 00:56:12.526 A:middle
Names use many different
writing systems;

00:56:12.586 --> 00:56:17.266 A:middle
sometimes a user will have
their family name first,

00:56:17.266 --> 00:56:18.216 A:middle
and first name last.

00:56:18.396 --> 00:56:19.946 A:middle
Sometimes they may
not have a family name

00:56:19.946 --> 00:56:21.036 A:middle
or not have a personal name.

00:56:22.516 --> 00:56:25.586 A:middle
Phone number formats
differ widely.

00:56:25.926 --> 00:56:29.196 A:middle
The number of digits used
and the punctuation that goes

00:56:29.226 --> 00:56:32.596 A:middle
between them, and there are
many different address formats

00:56:32.596 --> 00:56:33.116 A:middle
around the world.

00:56:33.516 --> 00:56:35.126 A:middle
So, try as much as possible

00:56:35.126 --> 00:56:37.976 A:middle
to avoid making assumptions
about these formats.

00:56:38.176 --> 00:56:42.026 A:middle
Do it only as your app needs
to for its own purposes.

00:56:42.456 --> 00:56:44.956 A:middle
One thing that can help
sometimes is data detectors,

00:56:45.196 --> 00:56:49.536 A:middle
which can detect phone
numbers and addresses

00:56:49.536 --> 00:56:52.986 A:middle
in many different international
formats, so you can add this

00:56:53.186 --> 00:56:56.276 A:middle
to some views, and it
will detect these things,

00:56:56.276 --> 00:56:58.286 A:middle
and even make them into links.

00:56:58.756 --> 00:57:01.206 A:middle
There is also NSDataDetector
at the foundation level

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:57:01.206 --> 00:57:02.286 A:middle
for doing this protomatically
[assumed spelling].

00:57:04.866 --> 00:57:07.836 A:middle
So, we have a lot of
documentation for all this stuff

00:57:07.836 --> 00:57:11.566 A:middle
on line, both conceptual
documentation, tutorials,

00:57:13.386 --> 00:57:15.516 A:middle
and there are a number
of relevant sessions

00:57:15.766 --> 00:57:18.966 A:middle
that you might be interested
in, including sessions

00:57:18.966 --> 00:57:22.186 A:middle
about auto layout, many
sessions about text kit

00:57:22.186 --> 00:57:23.136 A:middle
and text handling,

00:57:23.576 --> 00:57:27.126 A:middle
and tomorrow's very interesting
session on date and time.

00:57:27.976 --> 00:57:32.146 A:middle
So, the most important things
to take away; for localization,

00:57:32.686 --> 00:57:34.806 A:middle
you job is to make your
interfaces localizable,

00:57:35.676 --> 00:57:38.476 A:middle
preferably by using base
localization with auto layout,

00:57:39.176 --> 00:57:40.906 A:middle
and for your strings and code,

00:57:41.686 --> 00:57:43.836 A:middle
use NSLocalizedString
and gen strings.

00:57:44.806 --> 00:57:47.676 A:middle
For locale data, be sure to
use formatters; date formatters

00:57:47.676 --> 00:57:48.596 A:middle
and number formatters

00:57:48.596 --> 00:57:50.556 A:middle
when you're presenting
these things to the user.

00:57:51.346 --> 00:57:57.266 A:middle
With the constants or templates,
if necessary, customize them,

00:57:57.326 --> 00:57:59.536 A:middle
and then as calendar for
calendrical calculations.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:58:00.776 --> 00:58:04.446 A:middle
For text, use Unicode and NS
string, and the NSString API's

00:58:04.886 --> 00:58:07.026 A:middle
for iteration, searching,
sorting, and so forth,

00:58:07.616 --> 00:58:10.256 A:middle
and as much as possible, use
the standard views and controls

00:58:10.256 --> 00:58:11.386 A:middle
for input and display.

00:58:11.986 --> 00:58:15.116 A:middle
If you have to go beyond those,
use the text system API's

00:58:15.116 --> 00:58:19.196 A:middle
to do so, and get proper Unicode
aware layout and display.

00:58:21.616 --> 00:58:23.906 A:middle
Thanks everyone, have
a great conference.

00:58:24.516 --> 00:58:29.270 A:middle
[ Applause ]

