WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:11.066 --> 00:00:13.466 A:middle
&gt;&gt; Good afternoon and welcome
to fixing memory issues.

00:00:14.036 --> 00:00:16.106 A:middle
My name is Kate Stone
[phonetic], and I'm responsible,

00:00:16.106 --> 00:00:17.716 A:middle
among other things,
for managing the team

00:00:17.716 --> 00:00:19.316 A:middle
that develops the
Instruments product

00:00:19.316 --> 00:00:21.946 A:middle
that hopefully you all know and
love and will learn a lot more

00:00:21.946 --> 00:00:22.996 A:middle
about in this session.

00:00:23.046 --> 00:00:27.326 A:middle
But, of course, the focus of
our session is not Instruments,

00:00:27.856 --> 00:00:29.056 A:middle
it's on your application.

00:00:29.596 --> 00:00:33.086 A:middle
So glad to see so many of you
here today because our goal is

00:00:33.086 --> 00:00:35.996 A:middle
to make your application the
best that it can possibly be.

00:00:36.506 --> 00:00:39.396 A:middle
We want applications that
are robust, that are fast,

00:00:40.076 --> 00:00:42.926 A:middle
that don't hog too many system
resources and work really well

00:00:42.926 --> 00:00:44.576 A:middle
with other applications
on the system.

00:00:45.496 --> 00:00:47.316 A:middle
So with that in mind
let's start thinking

00:00:47.316 --> 00:00:51.656 A:middle
about what could
possibly go wrong.

00:00:51.886 --> 00:00:54.376 A:middle
Your application, of
course it occupies memory.

00:00:54.376 --> 00:00:56.766 A:middle
From the very beginning
an application that's up

00:00:56.766 --> 00:00:58.396 A:middle
and running, it's
loaded into memory,

00:00:58.396 --> 00:01:00.526 A:middle
it starts executing,
starts loading data.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:00.646 --> 00:01:04.025 A:middle
It starts loading more
and more and more data.

00:01:04.775 --> 00:01:07.376 A:middle
And there are a couple of
potential side effects of this.

00:01:07.986 --> 00:01:10.766 A:middle
If you get too much you start
seeing a poor user experience.

00:01:11.006 --> 00:01:12.286 A:middle
It could mean long load times.

00:01:12.506 --> 00:01:14.236 A:middle
It could mean you're
trying to get too much up

00:01:14.236 --> 00:01:16.346 A:middle
and running before the user
sees something meaningful.

00:01:17.046 --> 00:01:19.386 A:middle
It could mean you're using
so many system resources

00:01:19.616 --> 00:01:22.296 A:middle
that you wind up
swapping on an OS X system

00:01:22.376 --> 00:01:23.666 A:middle
and slowing the system down.

00:01:24.586 --> 00:01:26.276 A:middle
It could mean that when
users try to switch

00:01:26.276 --> 00:01:27.786 A:middle
to their other applications
that they find

00:01:27.786 --> 00:01:30.436 A:middle
that they've been forced out
of memory by your application.

00:01:31.106 --> 00:01:32.946 A:middle
So there are a lot of
potential down sides,

00:01:32.946 --> 00:01:35.576 A:middle
and it really behooves us to
keep things under control.

00:01:35.576 --> 00:01:38.426 A:middle
Of course, the situation
could get worse.

00:01:38.926 --> 00:01:42.046 A:middle
It could be the situation that
you're using so much memory,

00:01:42.166 --> 00:01:43.606 A:middle
so many resources on the system,

00:01:43.826 --> 00:01:45.446 A:middle
that you were forcibly
terminated.

00:01:46.636 --> 00:01:48.106 A:middle
This can happen in
a variety of ways.

00:01:48.106 --> 00:01:49.586 A:middle
We'll discuss all of them.

00:01:49.586 --> 00:01:51.186 A:middle
But in particular you
should keep in mind

00:01:51.186 --> 00:01:53.836 A:middle
that your application being
terminated aggressively while

00:01:53.836 --> 00:01:56.736 A:middle
the user is watching is only
the worst possible outcome.

00:01:57.406 --> 00:01:59.246 A:middle
It's also possible that
the user switches away

00:01:59.246 --> 00:02:00.196 A:middle
from your application,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:00.496 --> 00:02:03.526 A:middle
and because you're using too
much memory the system needs

00:02:03.526 --> 00:02:06.396 A:middle
to clean that up, it discards
your application, and it's slow

00:02:06.396 --> 00:02:08.126 A:middle
to come back to your
app the next time.

00:02:08.316 --> 00:02:10.586 A:middle
And that's another form
of poor user experience.

00:02:11.316 --> 00:02:13.486 A:middle
So, again, memory is really
critical in this sense.

00:02:14.116 --> 00:02:15.826 A:middle
But it's critical in
another sense as well.

00:02:16.396 --> 00:02:19.246 A:middle
Poor management of memory
can lead to bugs that result

00:02:19.246 --> 00:02:21.916 A:middle
in the immediate crash of your
application even though your

00:02:21.916 --> 00:02:23.786 A:middle
resources may not be excessive.

00:02:24.736 --> 00:02:26.076 A:middle
So we're going to focus on all

00:02:26.076 --> 00:02:27.866 A:middle
of these problems
throughout this session.

00:02:28.606 --> 00:02:30.866 A:middle
Specifically, if you
look at our agenda,

00:02:31.086 --> 00:02:33.616 A:middle
we're going to talk a little
bit about app memory in general.

00:02:33.616 --> 00:02:34.896 A:middle
What does it look like?

00:02:34.896 --> 00:02:38.016 A:middle
How can you think about it, and
what kinds of tools do we have

00:02:38.016 --> 00:02:39.676 A:middle
to help you understand
what's going on?

00:02:40.776 --> 00:02:42.186 A:middle
We're going to talk
about the Heap,

00:02:42.336 --> 00:02:45.776 A:middle
because every memory discussion
discusses the Heap and, in fact,

00:02:45.776 --> 00:02:49.206 A:middle
that's an area where not only do
you have a lot of resource uses,

00:02:49.656 --> 00:02:52.186 A:middle
you have keys to
finding other areas

00:02:52.336 --> 00:02:53.826 A:middle
where there's memory
being occupied.

00:02:53.826 --> 00:02:55.336 A:middle
And we'll talk about
how that works.

00:02:56.086 --> 00:02:58.266 A:middle
I'll hand it over to one of
my engineers, and we'll move

00:02:58.266 --> 00:03:00.206 A:middle
on to talking about Objective-C,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:00.436 --> 00:03:03.216 A:middle
challenges on that front
including retained releases

00:03:03.216 --> 00:03:03.616 A:middle
a pattern.

00:03:04.136 --> 00:03:07.226 A:middle
And, lastly, how to be a really
good citizen in the environment.

00:03:08.606 --> 00:03:11.286 A:middle
So an overview of
application memory.

00:03:12.896 --> 00:03:14.446 A:middle
Thankfully this release,

00:03:14.446 --> 00:03:16.446 A:middle
and doubtless you've seen
this numerous times before,

00:03:16.826 --> 00:03:19.606 A:middle
we now have the debug
gauges in Xcode.

00:03:19.866 --> 00:03:22.136 A:middle
The debug gauges give you
access, among other things,

00:03:22.176 --> 00:03:23.556 A:middle
to memory at a glance.

00:03:24.106 --> 00:03:27.596 A:middle
So there's a gauge that
you can move to, click on,

00:03:27.966 --> 00:03:29.516 A:middle
and you'll get an
additional report

00:03:29.516 --> 00:03:31.586 A:middle
that shows you more detail
about your application.

00:03:31.866 --> 00:03:34.706 A:middle
We've tried to break this down
to one number that's most likely

00:03:34.706 --> 00:03:35.636 A:middle
to be meaningful to you.

00:03:35.996 --> 00:03:36.986 A:middle
In this case you can think of it

00:03:36.986 --> 00:03:38.986 A:middle
as the footprint of
your application.

00:03:39.826 --> 00:03:41.776 A:middle
That one number gives
you a good indication

00:03:41.776 --> 00:03:43.876 A:middle
as you're running your app
because it's always present

00:03:43.876 --> 00:03:45.966 A:middle
in the debugger of
just what you're doing.

00:03:45.966 --> 00:03:48.216 A:middle
If you're starting to consume
more resources over time,

00:03:48.656 --> 00:03:51.166 A:middle
if something catastrophic
does occur just what point

00:03:51.166 --> 00:03:51.856 A:middle
that occurred at.

00:03:51.856 --> 00:03:54.596 A:middle
So you've got a good
indicator when you might need

00:03:54.596 --> 00:03:55.796 A:middle
to go and use Instruments.

00:03:56.186 --> 00:03:58.136 A:middle
And, indeed, there's a
handy button right there

00:03:58.396 --> 00:04:00.906 A:middle
that if you see a trend you
don't like we can go directly

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.906 --> 00:04:03.156 A:middle
to Instruments from
the debug gauge.

00:04:05.796 --> 00:04:09.946 A:middle
You need to understand that
this memory number is just one

00:04:09.946 --> 00:04:12.976 A:middle
number, and there are all
kinds of ways to measure memory

00:04:12.976 --> 00:04:14.376 A:middle
as we'll discuss again in a bit.

00:04:14.806 --> 00:04:18.716 A:middle
But Instruments is typically
traditionally focused

00:04:18.716 --> 00:04:19.406 A:middle
on the Heap.

00:04:19.406 --> 00:04:21.016 A:middle
And you may have seen situations

00:04:21.016 --> 00:04:23.476 A:middle
where your application was
summarily killed despite the

00:04:23.476 --> 00:04:25.156 A:middle
fact that your Heap
was relatively small.

00:04:26.186 --> 00:04:28.246 A:middle
It's important to know
that there's really a lot

00:04:28.246 --> 00:04:30.976 A:middle
of other memory involved
in your application

00:04:30.976 --> 00:04:33.086 A:middle
that you may not have thought
about, may not have had to worry

00:04:33.086 --> 00:04:36.376 A:middle
about or may not have had the
tools to understand before

00:04:36.776 --> 00:04:40.016 A:middle
that can take the form of code,
it could be images, media.

00:04:40.236 --> 00:04:41.886 A:middle
It could be a lot
of different things

00:04:41.886 --> 00:04:43.676 A:middle
that you haven't been
able to see before.

00:04:44.076 --> 00:04:46.166 A:middle
So the big question
is how do you get

00:04:46.166 --> 00:04:47.756 A:middle
to all of this information?

00:04:50.696 --> 00:04:53.176 A:middle
Lastly, again, this point

00:04:53.176 --> 00:04:56.296 A:middle
that your measurement will tell
you different numbers depending

00:04:56.296 --> 00:04:59.206 A:middle
on the tool you use, the
strategy that the tool uses

00:04:59.206 --> 00:05:02.126 A:middle
to find that information and
really what you're looking for.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:02.436 --> 00:05:05.596 A:middle
So if you're looking for one
number that sums up everything

00:05:05.596 --> 00:05:08.086 A:middle
about your application, in
some sense you're trying

00:05:08.086 --> 00:05:10.686 A:middle
to oversimplify what's
really a fairly complex set

00:05:10.686 --> 00:05:11.866 A:middle
of subsystems operating.

00:05:12.146 --> 00:05:15.346 A:middle
So you will see that the gauge
provides you one set of numbers.

00:05:15.586 --> 00:05:18.326 A:middle
Again, it's what we think is
the most meaningful number.

00:05:18.756 --> 00:05:21.256 A:middle
But there are other numbers that
we can explore, and as we go

00:05:21.256 --> 00:05:23.166 A:middle
through Instruments you'll
see some of those as well.

00:05:23.906 --> 00:05:26.036 A:middle
So it sounds like the
right time to dive on in

00:05:26.306 --> 00:05:27.866 A:middle
and have a look at
this workflow.

00:05:27.926 --> 00:05:32.946 A:middle
I'm just going to bring
up a project here.

00:05:32.946 --> 00:05:37.676 A:middle
And this project is one that
you're probably familiar

00:05:37.676 --> 00:05:39.276 A:middle
with if not in source code

00:05:39.276 --> 00:05:40.506 A:middle
because we don't
make it available,

00:05:40.746 --> 00:05:42.876 A:middle
then because you've used it
every day at this conference.

00:05:42.876 --> 00:05:45.446 A:middle
It's the WWDC app that
you have on your devices.

00:05:47.306 --> 00:05:50.446 A:middle
Or at least it's an early
version of it with a few issues,

00:05:50.596 --> 00:05:53.176 A:middle
maybe some of them having been
introduced by us for purposes

00:05:53.426 --> 00:05:54.906 A:middle
that will become
clear on the stage.

00:05:55.406 --> 00:05:58.426 A:middle
So let's go ahead and
run that application.

00:05:58.466 --> 00:05:59.786 A:middle
So it's been deployed
to my device.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:00.426 --> 00:06:01.156 A:middle
It's up and running.

00:06:04.596 --> 00:06:07.756 A:middle
And we'll see that the gauges
are providing me feedback here

00:06:07.756 --> 00:06:09.586 A:middle
about how much CPU
time I'm using,

00:06:09.586 --> 00:06:10.626 A:middle
how much memory I'm using.

00:06:10.786 --> 00:06:12.926 A:middle
And so as I exercise the
app I'm going to drill

00:06:12.926 --> 00:06:14.346 A:middle
into a particular session.

00:06:14.686 --> 00:06:17.776 A:middle
I'm going to go ahead and look
at maps, look at news, videos.

00:06:17.776 --> 00:06:19.386 A:middle
You can't see any
of this but, again,

00:06:19.386 --> 00:06:20.916 A:middle
the workflow should
be familiar to you.

00:06:21.376 --> 00:06:23.496 A:middle
And so I've come back to
the initial state I was in,

00:06:23.496 --> 00:06:26.606 A:middle
and I've seen rather a lot
of growth over that time.

00:06:27.156 --> 00:06:29.876 A:middle
So maybe I want to have a
look at that memory curve.

00:06:29.876 --> 00:06:32.176 A:middle
And it doesn't look spectacular.

00:06:32.176 --> 00:06:33.696 A:middle
It's kind of going the
wrong direction here.

00:06:34.036 --> 00:06:35.496 A:middle
There's enough information
here to know

00:06:35.496 --> 00:06:37.266 A:middle
that there's something
I should investigate,

00:06:37.646 --> 00:06:38.696 A:middle
but not enough information

00:06:38.696 --> 00:06:40.196 A:middle
to tell me what exactly
I should do.

00:06:40.546 --> 00:06:43.516 A:middle
That's the time that we might
go to profile in Instruments.

00:06:43.966 --> 00:06:46.836 A:middle
And so by simply clicking
here I get a prompt,

00:06:46.836 --> 00:06:48.336 A:middle
and I have two options
at this point.

00:06:48.746 --> 00:06:52.156 A:middle
I can choose to stop
my debug session

00:06:52.316 --> 00:06:55.086 A:middle
and hand this existing
running application off

00:06:55.086 --> 00:06:56.496 A:middle
to Instruments to investigate.

00:06:57.426 --> 00:06:59.286 A:middle
I will have missed
the opportunity then

00:06:59.286 --> 00:07:01.756 A:middle
to measure a lot of
important information

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:01.756 --> 00:07:03.836 A:middle
about the allocations that
have already occurred.

00:07:04.226 --> 00:07:07.236 A:middle
So when you're looking at memory
that's rarely the right option.

00:07:07.776 --> 00:07:09.186 A:middle
It's possible there
may be things

00:07:09.186 --> 00:07:10.736 A:middle
that you could learn
using that technique,

00:07:11.046 --> 00:07:12.306 A:middle
but for our purposes no.

00:07:12.466 --> 00:07:15.836 A:middle
We're going to ask to stop the
debug session, launch a new copy

00:07:15.836 --> 00:07:18.636 A:middle
of the application
inside Instruments.

00:07:19.266 --> 00:07:22.926 A:middle
And we may see here what you may
very well have run into already

00:07:22.926 --> 00:07:24.486 A:middle
if you've been experimenting
with the seed,

00:07:24.966 --> 00:07:28.106 A:middle
that in the initial seed the
handoff is not always graceful.

00:07:28.686 --> 00:07:31.326 A:middle
If you run into problems
you can stop the application

00:07:31.886 --> 00:07:34.956 A:middle
and simply start
re-recording in Instruments.

00:07:34.956 --> 00:07:36.336 A:middle
Obviously this will
be corrected.

00:07:37.646 --> 00:07:40.086 A:middle
So we've got our application up
and running under Instruments.

00:07:40.086 --> 00:07:42.296 A:middle
We're getting recordings
here of what's going

00:07:42.296 --> 00:07:44.116 A:middle
on in terms of memory
allocation.

00:07:44.456 --> 00:07:46.306 A:middle
And we're seeing a
nice allocations curve.

00:07:46.896 --> 00:07:50.646 A:middle
I mentioned before that
typically Instruments is shown

00:07:50.646 --> 00:07:52.466 A:middle
as Heap information
in allocations.

00:07:52.866 --> 00:07:53.616 A:middle
Well, if we look at some

00:07:53.616 --> 00:07:56.226 A:middle
of these numbers we would
expect then maybe to see numbers

00:07:56.226 --> 00:07:57.826 A:middle
that are smaller
than the numbers

00:07:57.826 --> 00:07:59.146 A:middle
that are being reported
by the gauge.

00:07:59.666 --> 00:08:00.866 A:middle
That's no longer the case.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:01.456 --> 00:08:04.256 A:middle
My total live bytes being
reported here, 57 meg,

00:08:04.256 --> 00:08:07.266 A:middle
is actually even more than
the number reported in gauges.

00:08:07.266 --> 00:08:09.156 A:middle
And that's because
allocations has been enhanced

00:08:09.526 --> 00:08:10.896 A:middle
to show a lot more information

00:08:10.966 --> 00:08:12.356 A:middle
than we've been able
to see in the past.

00:08:12.676 --> 00:08:15.006 A:middle
In particular it's not
just Heap allocations

00:08:15.326 --> 00:08:18.126 A:middle
but all virtual memory regions
that have been allocated,

00:08:18.646 --> 00:08:21.016 A:middle
mapped into memory while
your application was running.

00:08:22.426 --> 00:08:26.166 A:middle
So if you look here specifically
we actually have a filter

00:08:26.166 --> 00:08:28.966 A:middle
that allows us to
see a blended view

00:08:28.966 --> 00:08:32.716 A:middle
of both Heap allocations
and VM allocations.

00:08:32.926 --> 00:08:34.696 A:middle
Or we can focus on just the heap

00:08:35.116 --> 00:08:37.806 A:middle
which is really just
3.6 meg in this case.

00:08:38.366 --> 00:08:41.506 A:middle
Or just the VM regions which
accounts for rather a lot

00:08:41.506 --> 00:08:42.655 A:middle
of memory in my application,

00:08:43.006 --> 00:08:45.346 A:middle
memory that you haven't been
able to see in the past.

00:08:45.906 --> 00:08:46.886 A:middle
Well, that's interesting,

00:08:46.886 --> 00:08:48.106 A:middle
what kinds of things
have we got here?

00:08:48.516 --> 00:08:52.096 A:middle
Well, if we sort by
live bytes we'll see

00:08:52.096 --> 00:08:56.396 A:middle
that we have mapped files, and I
can dive in and see specifically

00:08:56.516 --> 00:09:00.476 A:middle
which files, zoom back out,
which files have been mapped

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.476 --> 00:09:02.616 A:middle
into my application,
when they were mapped in

00:09:02.616 --> 00:09:03.876 A:middle
and get additional information.

00:09:03.876 --> 00:09:06.406 A:middle
In fact, I can find a
particular file of interest

00:09:06.646 --> 00:09:09.186 A:middle
and find the call stack
that was responsible.

00:09:09.186 --> 00:09:12.126 A:middle
What was it in my code that
caused this to be mapped in?

00:09:12.746 --> 00:09:13.286 A:middle
Interesting.

00:09:14.556 --> 00:09:17.596 A:middle
But in this particular case
what caught my eye wasn't the

00:09:17.596 --> 00:09:18.366 A:middle
mapped files.

00:09:19.886 --> 00:09:21.986 A:middle
It was all of this image IO.

00:09:22.866 --> 00:09:24.746 A:middle
So I've got image IO going on,

00:09:24.956 --> 00:09:27.886 A:middle
and as I exercise the
application in the same fashion

00:09:27.886 --> 00:09:31.496 A:middle
that I exercised it a moment
ago, we'll see that, in fact,

00:09:31.496 --> 00:09:34.146 A:middle
image IO turns out to be
a pretty substantial chunk

00:09:34.986 --> 00:09:36.456 A:middle
of what my application is doing.

00:09:36.456 --> 00:09:39.036 A:middle
In fact, it's dwarfing the
Heap memory at this point.

00:09:39.396 --> 00:09:41.916 A:middle
So optimizing for my Heap is
maybe not the most important

00:09:41.916 --> 00:09:42.836 A:middle
thing for me to consider.

00:09:43.346 --> 00:09:45.206 A:middle
Maybe I need to understand
this a little better.

00:09:45.796 --> 00:09:46.906 A:middle
And a lot of the tools

00:09:46.906 --> 00:09:49.146 A:middle
that we've used before
help me understand this.

00:09:49.506 --> 00:09:51.886 A:middle
So if I were to go into
my call trees view,

00:09:52.206 --> 00:09:54.106 A:middle
the call trees view
will show me, again,

00:09:54.106 --> 00:09:56.976 A:middle
down which paths the
allocations are occurring.

00:09:57.986 --> 00:09:59.976 A:middle
If I search for

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:01.276 --> 00:10:02.776 A:middle
image IO work here I can see

00:10:02.776 --> 00:10:05.486 A:middle
that there's core
animation-related things

00:10:05.486 --> 00:10:09.206 A:middle
happening that are resulting
in memory mapped operations.

00:10:09.206 --> 00:10:10.526 A:middle
And so I can actually drill down

00:10:10.876 --> 00:10:12.876 A:middle
and see the call path
that led to this.

00:10:13.486 --> 00:10:16.746 A:middle
It's interesting because I will
see there are actually also

00:10:17.236 --> 00:10:20.776 A:middle
malloc operations operating on
the Heap in the same vicinity.

00:10:21.276 --> 00:10:23.046 A:middle
In fact, if I look at this line,

00:10:23.716 --> 00:10:28.486 A:middle
we'll go up even one more level
here, 7.83 meg is being called

00:10:28.526 --> 00:10:30.856 A:middle
down this path somewhere
in code.

00:10:31.906 --> 00:10:36.026 A:middle
7.82 meg of that looks
like it's mapped memory,

00:10:36.336 --> 00:10:38.406 A:middle
memory that would
show up as VM regions

00:10:38.406 --> 00:10:39.706 A:middle
that I couldn't see before.

00:10:39.706 --> 00:10:42.176 A:middle
So I'd have this
tiny amount of memory

00:10:42.176 --> 00:10:44.956 A:middle
on the Heap that's
allocated down this same path

00:10:44.956 --> 00:10:47.646 A:middle
and represents the same
work that's allocating all

00:10:47.646 --> 00:10:48.406 A:middle
of these images.

00:10:48.636 --> 00:10:50.536 A:middle
That's what we'd like to
be able to queue in on

00:10:50.536 --> 00:10:52.486 A:middle
and understand a
lot better in order

00:10:52.486 --> 00:10:54.456 A:middle
to control the behavior
of our application.

00:10:55.116 --> 00:10:57.786 A:middle
So these are some interesting
new tools that we have.

00:10:57.786 --> 00:10:59.766 A:middle
Of course we have some
familiar tools as well.

00:10:59.766 --> 00:11:02.696 A:middle
I'm going to dig into
the library and bring

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:02.696 --> 00:11:05.886 A:middle
out one other familiar
favorite, VM Tracker,

00:11:06.416 --> 00:11:10.826 A:middle
and record a little bit
about the current state

00:11:10.826 --> 00:11:12.836 A:middle
of my application
from VM Tracker.

00:11:13.606 --> 00:11:16.006 A:middle
The reason I bring this up
we'll dive into in a moment,

00:11:16.006 --> 00:11:19.546 A:middle
but virtual memory is an
interesting slippery beast.

00:11:19.546 --> 00:11:22.496 A:middle
A region can represent
a lot of memory space

00:11:22.896 --> 00:11:25.846 A:middle
but have only portions of that
memory actually in active use

00:11:25.846 --> 00:11:27.416 A:middle
in physical RAM on your device.

00:11:27.876 --> 00:11:30.026 A:middle
And the VM Tracker is
one way that you can dig

00:11:30.026 --> 00:11:30.916 A:middle
in and understand this.

00:11:31.096 --> 00:11:35.156 A:middle
So the VM Tracker in this case
is showing me information like,

00:11:35.496 --> 00:11:37.886 A:middle
okay, there's this image
IO that's going on.

00:11:38.456 --> 00:11:42.936 A:middle
Of that image IO how
much of it is virtual,

00:11:42.936 --> 00:11:45.456 A:middle
how much of it is dirty and
how much of it is resident?

00:11:46.006 --> 00:11:49.726 A:middle
These are incredibly important
queues that we really need

00:11:49.726 --> 00:11:54.636 A:middle
to understand a little better
in order to see the full picture

00:11:54.636 --> 00:11:56.526 A:middle
of what's going on in
my applications memory.

00:11:57.116 --> 00:12:01.946 A:middle
I'd also like to point out that
if you've used the Instruments

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:01.976 --> 00:12:04.206 A:middle
from sort of a casual
perspective, you go in

00:12:04.206 --> 00:12:06.246 A:middle
and you look at the
default presentations,

00:12:06.246 --> 00:12:09.066 A:middle
you haven't really tried tuning
the way you look at things,

00:12:09.336 --> 00:12:11.466 A:middle
you might want to try
clicking on the left side

00:12:11.466 --> 00:12:12.766 A:middle
of the navigation bar here.

00:12:13.286 --> 00:12:15.176 A:middle
Because this isn't
just about navigation

00:12:15.176 --> 00:12:16.116 A:middle
in the bread crumb trail,

00:12:16.376 --> 00:12:18.736 A:middle
it's about fundamentally
different views

00:12:18.886 --> 00:12:20.096 A:middle
for the instruments
that we have.

00:12:20.096 --> 00:12:22.206 A:middle
And so for the VM Tracker one

00:12:22.206 --> 00:12:26.136 A:middle
of those handy views is the
region's map that allows me

00:12:26.136 --> 00:12:28.806 A:middle
to see where things
are laid out in memory.

00:12:28.806 --> 00:12:32.386 A:middle
So I could actually understand
my virtual memory address range,

00:12:32.566 --> 00:12:34.506 A:middle
which things are adjacent
to which other things

00:12:34.506 --> 00:12:37.326 A:middle
in case I'm overriding the
end of some buffer, et cetera.

00:12:37.526 --> 00:12:39.336 A:middle
There's a lot of good
information in here.

00:12:39.616 --> 00:12:42.446 A:middle
We won't cover it all in this
session sadly, but we are going

00:12:42.446 --> 00:12:44.006 A:middle
to focus on some of the things

00:12:44.006 --> 00:12:46.466 A:middle
that are particularly
new this time around.

00:12:47.516 --> 00:12:50.546 A:middle
[ Pause ]

00:12:51.046 --> 00:12:52.336 A:middle
So let's switch back to slides.

00:12:57.056 --> 00:12:58.306 A:middle
We talked about the fact

00:12:58.306 --> 00:13:01.446 A:middle
that virtual memory is
now more fully represented

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:01.656 --> 00:13:02.546 A:middle
in allocations.

00:13:02.736 --> 00:13:04.676 A:middle
And we have a lot
of familiar tools

00:13:04.676 --> 00:13:06.146 A:middle
and techniques that
we can apply.

00:13:07.026 --> 00:13:10.106 A:middle
There's one that may not be
quite so obvious, though,

00:13:10.306 --> 00:13:12.316 A:middle
this notion that there's
an efficient alternative

00:13:12.396 --> 00:13:15.106 A:middle
to running allocations on
your application as is.

00:13:15.106 --> 00:13:16.866 A:middle
If you've ever tried
using Allocations

00:13:16.866 --> 00:13:19.126 A:middle
on a particularly
large app you'll note

00:13:19.126 --> 00:13:21.396 A:middle
that it's tracking a
lot of information,

00:13:21.776 --> 00:13:24.726 A:middle
millions upon millions of
allocations and deallocations,

00:13:24.726 --> 00:13:27.326 A:middle
and bookkeeping for that
winds up actually taking a lot

00:13:27.326 --> 00:13:28.736 A:middle
of memory and a lot of time.

00:13:28.856 --> 00:13:31.076 A:middle
So if you've got an application
that you've never been able

00:13:31.076 --> 00:13:34.036 A:middle
to use Allocations on
before there's a new

00:13:34.036 --> 00:13:35.076 A:middle
interesting technique.

00:13:35.076 --> 00:13:39.806 A:middle
If you open the configuration
panel for Allocations and move

00:13:39.806 --> 00:13:44.876 A:middle
to only VM Allocation tracking,
you will lose your ability

00:13:44.876 --> 00:13:46.806 A:middle
to see the fine grained
information on the Heap,

00:13:47.286 --> 00:13:49.946 A:middle
but you can still see the
big picture in terms of VM,

00:13:49.946 --> 00:13:53.016 A:middle
and that could be a powerful
tool for applications

00:13:53.016 --> 00:13:55.846 A:middle
that previously there was no
way to get any insight into.

00:13:57.756 --> 00:13:59.936 A:middle
Because this does
give us insight

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:00.086 --> 00:14:01.526 A:middle
into some very interesting
things.

00:14:01.526 --> 00:14:04.236 A:middle
It gives us an idea of who
mapped files into memory,

00:14:04.496 --> 00:14:07.616 A:middle
who is responsible for
contributing to my footprint

00:14:07.616 --> 00:14:09.956 A:middle
in a way that the
Heap never could.

00:14:10.786 --> 00:14:13.206 A:middle
And, again, for page
level statistics,

00:14:13.436 --> 00:14:15.756 A:middle
so beyond the VM region
to an individual page,

00:14:15.756 --> 00:14:18.696 A:middle
a concept we'll talk about in a
moment, there's the VM Tracker

00:14:18.696 --> 00:14:20.646 A:middle
which can give me more depth.

00:14:23.216 --> 00:14:28.046 A:middle
So, sorry, built.

00:14:29.556 --> 00:14:30.466 A:middle
Virtual memory.

00:14:30.646 --> 00:14:32.196 A:middle
We've talked a lot
about virtual memory.

00:14:32.196 --> 00:14:35.866 A:middle
I pointed out concepts like
dirty memory, resident memory,

00:14:36.336 --> 00:14:38.686 A:middle
these are things that may
or may not be familiar

00:14:38.686 --> 00:14:40.326 A:middle
so let's go through
them briefly.

00:14:40.946 --> 00:14:43.586 A:middle
The notion of virtual memory
versus resident memory.

00:14:44.096 --> 00:14:46.546 A:middle
My virtual memory isn't
a logical address space

00:14:46.616 --> 00:14:49.516 A:middle
from address 0 to the
top of logical memory,

00:14:49.716 --> 00:14:53.006 A:middle
and every single process has
its own virtual memory region.

00:14:53.386 --> 00:14:56.356 A:middle
Process A may be thinking
it has memory at address 0

00:14:56.356 --> 00:14:57.906 A:middle
and process B thinks
the same thing.

00:14:57.906 --> 00:15:00.766 A:middle
And obviously they have
distinct chunks of memory.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:01.186 --> 00:15:03.356 A:middle
So this is a nice
logical concept

00:15:03.356 --> 00:15:04.996 A:middle
from an application
developer's point of view.

00:15:04.996 --> 00:15:06.996 A:middle
You can pretend that
you own all of RAM,

00:15:07.456 --> 00:15:11.876 A:middle
but the reality is a little
bit more complicated than that.

00:15:11.876 --> 00:15:15.106 A:middle
All memory regions that
are reserved are allocated

00:15:15.106 --> 00:15:19.646 A:middle
on 4K page boundaries and
occupy a fixed number of pages

00:15:19.936 --> 00:15:21.336 A:middle
so you'll never share a page

00:15:21.336 --> 00:15:22.796 A:middle
with another virtual
memory region.

00:15:23.456 --> 00:15:26.676 A:middle
So the example we have up here
you'll see that we have a region

00:15:26.676 --> 00:15:30.076 A:middle
that consists of 2 pages, 8K,
another region that consists

00:15:30.076 --> 00:15:34.766 A:middle
of 3 pages, 12K, and that's
representing my virtual address

00:15:34.766 --> 00:15:35.256 A:middle
space here.

00:15:35.696 --> 00:15:37.316 A:middle
But nothing's actually
in RAM yet.

00:15:37.826 --> 00:15:39.776 A:middle
This is all just from
my application's point

00:15:39.776 --> 00:15:42.286 A:middle
of view a simplistic way
of looking at the world.

00:15:43.656 --> 00:15:47.466 A:middle
What happens is that on the
first use, whether I read

00:15:47.466 --> 00:15:50.776 A:middle
from a chunk of memory or write
to a piece of memory it winds

00:15:50.776 --> 00:15:52.196 A:middle
up being mapped into
physical memory.

00:15:52.196 --> 00:15:55.656 A:middle
We find a page that's not used
in physical memory it's unlikely

00:15:55.656 --> 00:15:57.916 A:middle
to be the first page, there's
probably an operating system up

00:15:57.916 --> 00:16:00.706 A:middle
and running at this point, but
it finds a page that's unused

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.706 --> 00:16:03.386 A:middle
and it maps it to a page
of your application.

00:16:04.356 --> 00:16:05.786 A:middle
Same thing happens again.

00:16:05.786 --> 00:16:07.406 A:middle
I find some other
page that I touch,

00:16:07.406 --> 00:16:09.796 A:middle
and these can be completely
disjoint, and these result

00:16:09.796 --> 00:16:11.496 A:middle
in physical memory coming in.

00:16:12.046 --> 00:16:15.726 A:middle
What happens is we describe
these as having become resident.

00:16:16.026 --> 00:16:18.346 A:middle
So it's still virtual
memory, we still talk about it

00:16:18.346 --> 00:16:20.106 A:middle
as virtual memory,
but only a portion

00:16:20.106 --> 00:16:23.596 A:middle
of it is actually resident in
physical RAM at any given time.

00:16:25.336 --> 00:16:27.316 A:middle
Part of the reason that I
like to draw the distinction

00:16:27.316 --> 00:16:30.216 A:middle
between these two is because
while physical memory is more

00:16:30.216 --> 00:16:32.766 A:middle
likely to be your constraint,
we've tried to illustrate this

00:16:32.766 --> 00:16:35.706 A:middle
with the shorter bar,
it's not always the case.

00:16:35.706 --> 00:16:38.616 A:middle
It's possible in an application
that you will try to map

00:16:38.616 --> 00:16:41.606 A:middle
in too many media resources
in case you ever need them.

00:16:41.606 --> 00:16:43.846 A:middle
And so despite the fact that
you've never read a single one

00:16:43.846 --> 00:16:46.536 A:middle
of them, you've exhausted
the amount of virtual memory

00:16:46.576 --> 00:16:49.026 A:middle
that the operating system
is going to allow you.

00:16:49.296 --> 00:16:51.526 A:middle
In particular on
iOS you may find

00:16:51.526 --> 00:16:52.776 A:middle
that you don't have much loaded,

00:16:53.056 --> 00:16:55.966 A:middle
but if you exhaust the virtual
memory space that we allow

00:16:55.966 --> 00:16:58.996 A:middle
for you we will simply kill
your application outright.

00:16:59.536 --> 00:17:01.496 A:middle
So it's possible to
run into that limit.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:01.736 --> 00:17:04.746 A:middle
It is much more likely instead
that I'll run into limits

00:17:04.746 --> 00:17:06.496 A:middle
in terms of physical RAM.

00:17:07.656 --> 00:17:10.256 A:middle
The notion of clean
versus dirty comes up next.

00:17:10.256 --> 00:17:11.856 A:middle
What's dirty memory represent?

00:17:12.506 --> 00:17:13.915 A:middle
Well, clean pages are pages

00:17:13.915 --> 00:17:16.685 A:middle
that we can discard
at will and recreate.

00:17:17.816 --> 00:17:19.185 A:middle
What kinds of pages
can we do that with?

00:17:19.185 --> 00:17:21.526 A:middle
Well, if we've loaded
some code from Flash

00:17:21.626 --> 00:17:26.246 A:middle
or from a physical disk
drive we've loaded that in,

00:17:26.246 --> 00:17:27.376 A:middle
we know where it came from.

00:17:27.376 --> 00:17:29.486 A:middle
If we need that memory
back we can throw it away.

00:17:29.486 --> 00:17:31.086 A:middle
We can always reload
it from disk.

00:17:31.476 --> 00:17:32.986 A:middle
That memory is still
considered clean

00:17:33.206 --> 00:17:34.456 A:middle
because it can be discarded.

00:17:34.716 --> 00:17:36.886 A:middle
And this is true
of OS X and iOS.

00:17:38.036 --> 00:17:40.646 A:middle
On the other hand as
soon as I touch a page

00:17:40.646 --> 00:17:42.236 A:middle
and actually modify its contents

00:17:42.456 --> 00:17:44.636 A:middle
so that there's no longer
essentially a backup copy

00:17:44.636 --> 00:17:47.146 A:middle
that we can readily get we
consider that memory dirty.

00:17:47.536 --> 00:17:50.736 A:middle
And so basically everything
on your Heap, your Stacks,

00:17:50.736 --> 00:17:53.216 A:middle
global variables, all
of this is dirty RAM.

00:17:53.406 --> 00:17:55.636 A:middle
It's RAM that we have
to keep in memory --

00:17:56.236 --> 00:18:00.076 A:middle
sorry, information that we
have to keep in memory in order

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:00.076 --> 00:18:01.686 A:middle
for you to be able to
continue executing.

00:18:02.086 --> 00:18:05.396 A:middle
That's absolutely
critical for your sanity.

00:18:06.646 --> 00:18:08.996 A:middle
So what happens when
we start running low

00:18:08.996 --> 00:18:12.746 A:middle
on memory is we'll start
discarding pages that are clean.

00:18:14.226 --> 00:18:16.986 A:middle
On OS X then we will also worry

00:18:16.986 --> 00:18:19.486 A:middle
about what we can do
to swap things out.

00:18:19.486 --> 00:18:21.626 A:middle
We'll take dirty pages
and write them to disk

00:18:21.626 --> 00:18:24.156 A:middle
so we do have a backup copy
and we can reuse that memory.

00:18:24.376 --> 00:18:26.656 A:middle
At this point your system
will start to slow as it needs

00:18:26.656 --> 00:18:28.186 A:middle
to page memory in and out.

00:18:28.946 --> 00:18:31.396 A:middle
But on iOS the situation
is much more drastic.

00:18:32.066 --> 00:18:35.236 A:middle
If there's dirty memory and we
haven't got anywhere to put it

00:18:35.236 --> 00:18:38.566 A:middle
because we don't write it
to Flash, too expensive

00:18:38.566 --> 00:18:39.926 A:middle
for a variety of reasons,

00:18:39.926 --> 00:18:41.786 A:middle
we will simply terminate
your application.

00:18:42.406 --> 00:18:44.816 A:middle
So you absolutely need
to keep your dirty memory

00:18:45.016 --> 00:18:47.156 A:middle
under control especially on iOS.

00:18:47.846 --> 00:18:52.466 A:middle
So this process of swapping
gives us potential but, again,

00:18:52.466 --> 00:18:55.006 A:middle
for the vast majority of
you it's not available.

00:18:55.726 --> 00:18:57.666 A:middle
The last concept is the notion

00:18:57.666 --> 00:19:00.226 A:middle
of private memory
versus shared memory.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:01.326 --> 00:19:03.566 A:middle
When I create a memory
region I can give it a name,

00:19:03.566 --> 00:19:06.726 A:middle
and by giving it a name another
process can actually use the

00:19:06.726 --> 00:19:09.906 A:middle
same physical memory and map it
into its virtual address space.

00:19:11.156 --> 00:19:13.816 A:middle
Well, as it turns out in a
lot of cases you will wind

00:19:13.816 --> 00:19:16.916 A:middle
up instead with memory that
is automatically shared,

00:19:16.916 --> 00:19:20.116 A:middle
implicitly given a name
because it's mapped to a file.

00:19:20.116 --> 00:19:21.516 A:middle
And so as soon as I map a file

00:19:21.516 --> 00:19:24.586 A:middle
if somebody maps the same file
we're now sharing that memory.

00:19:25.146 --> 00:19:27.826 A:middle
So consider an example where
I write an application.

00:19:27.826 --> 00:19:29.396 A:middle
The first thing that
happens is a piece

00:19:29.396 --> 00:19:31.266 A:middle
of code gets paged in, okay?

00:19:31.296 --> 00:19:33.846 A:middle
We hit the code off
disk, it's now mapped

00:19:33.846 --> 00:19:34.946 A:middle
into my address space.

00:19:35.446 --> 00:19:38.386 A:middle
I then go and allocate
something on the Heap,

00:19:38.386 --> 00:19:40.626 A:middle
and so I need a page that
backs some of the Heap.

00:19:40.626 --> 00:19:42.966 A:middle
And now we've got one
process up and running.

00:19:42.966 --> 00:19:46.796 A:middle
But now I launch another
instance of the same process.

00:19:48.426 --> 00:19:50.586 A:middle
It's got its own address space.

00:19:51.176 --> 00:19:54.706 A:middle
So it has a completely separate
address space that they happen

00:19:54.706 --> 00:19:56.846 A:middle
to potentially align
here, they may not.

00:19:57.826 --> 00:19:59.406 A:middle
And now it needs to load code.

00:19:59.616 --> 00:19:59.956 A:middle
Well,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.046 --> 00:20:03.086 A:middle
because the code is coming
from a file it's actually able

00:20:03.086 --> 00:20:05.636 A:middle
to map the same chunk
of physical memory

00:20:05.816 --> 00:20:07.336 A:middle
into its virtual address space.

00:20:08.146 --> 00:20:09.776 A:middle
But then it goes to put
something on the Heap,

00:20:09.776 --> 00:20:13.306 A:middle
and because this is logically
a separate instance its data is

00:20:13.306 --> 00:20:16.206 A:middle
kept independently,
and this is separate.

00:20:16.206 --> 00:20:18.006 A:middle
This is what we call
private memory.

00:20:18.646 --> 00:20:21.896 A:middle
So often you will see a
focus on your private memory,

00:20:22.266 --> 00:20:24.626 A:middle
memory that is not potentially
shared with anyone else

00:20:24.626 --> 00:20:26.056 A:middle
because all the frameworks
are shared.

00:20:26.056 --> 00:20:28.736 A:middle
It's generally not considered
reasonable to account

00:20:28.736 --> 00:20:31.656 A:middle
against your process what you're
using from the frameworks.

00:20:32.626 --> 00:20:35.286 A:middle
And instead we want to focus
on the private dirty memory,

00:20:35.286 --> 00:20:38.246 A:middle
and that's largely what we
show you with the Xcode gauges.

00:20:38.716 --> 00:20:41.796 A:middle
So we're going to talk
about Heap memory.

00:20:42.646 --> 00:20:44.686 A:middle
What is the Heap?

00:20:44.896 --> 00:20:47.886 A:middle
Probably a familiar concept for
most of you, but if it's not,

00:20:48.606 --> 00:20:52.466 A:middle
any time you call malloc you are
allocating a chunk of memory,

00:20:52.466 --> 00:20:54.316 A:middle
and it's potentially
quite small.

00:20:54.316 --> 00:20:56.436 A:middle
This is often used for
fine grained things,

00:20:56.436 --> 00:20:58.346 A:middle
a dozen bytes or more.

00:20:58.886 --> 00:21:00.836 A:middle
But it can also be used
for fairly large things,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:00.936 --> 00:21:02.566 A:middle
and it's in this managed area.

00:21:04.126 --> 00:21:07.176 A:middle
You may not have called malloc,
but if you've called alloc

00:21:07.176 --> 00:21:09.086 A:middle
or new on an Objective-C object

00:21:09.086 --> 00:21:10.666 A:middle
under the covers
that's what it's doing.

00:21:10.836 --> 00:21:12.356 A:middle
Or if you use the new operator

00:21:12.356 --> 00:21:14.616 A:middle
on a C++ object that's
what it's been doing.

00:21:14.616 --> 00:21:17.276 A:middle
And so you wind up with
these malloc zones.

00:21:17.836 --> 00:21:21.336 A:middle
The malloc memory is actually
backed by virtual memory,

00:21:21.536 --> 00:21:23.066 A:middle
so there's a virtual memory zone

00:21:23.066 --> 00:21:25.026 A:middle
that the malloc subsystem
has created for you,

00:21:25.316 --> 00:21:26.926 A:middle
and it's doing all
the bookkeeping to try

00:21:26.926 --> 00:21:29.456 A:middle
to reuse space and
use space efficiently

00:21:29.696 --> 00:21:30.916 A:middle
within that malloc region.

00:21:31.866 --> 00:21:33.976 A:middle
So if you actually
look you will see

00:21:33.976 --> 00:21:36.196 A:middle
that there is this VM
malloc region lying

00:21:36.196 --> 00:21:38.826 A:middle
around that represents the
backing store for all of this.

00:21:39.266 --> 00:21:40.906 A:middle
And typically things
that you keep

00:21:40.906 --> 00:21:43.156 A:middle
on the heap you will often
have reference counted

00:21:43.236 --> 00:21:45.856 A:middle
so that you can do fairly
sophisticated memory management.

00:21:45.856 --> 00:21:48.996 A:middle
It takes care of a lot of
interesting bookkeeping for you.

00:21:50.006 --> 00:21:52.866 A:middle
You may also wind up seeing it,
of course, allocated implicitly

00:21:52.866 --> 00:21:54.756 A:middle
by other code on your behalf.

00:21:56.126 --> 00:21:58.926 A:middle
So when I'm looking at the heap
things that I might want to keep

00:21:58.926 --> 00:22:00.576 A:middle
in mind are that
there are some types

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.636 --> 00:22:02.766 A:middle
that are more expensive
than others.

00:22:03.486 --> 00:22:04.456 A:middle
VM is about bytes.

00:22:04.456 --> 00:22:07.026 A:middle
I can look at a VM region
and say this is a couple

00:22:07.026 --> 00:22:09.046 A:middle
of megabytes, that's
actually relatively large,

00:22:09.566 --> 00:22:11.936 A:middle
but in the Heap typically,
again, things are going

00:22:11.936 --> 00:22:16.446 A:middle
to be 16 bytes, 30 bytes, it's
going to be some small amount

00:22:16.446 --> 00:22:17.746 A:middle
of memory that's reserved.

00:22:18.096 --> 00:22:21.266 A:middle
And so it's the aggregation of
a large number of these things

00:22:21.266 --> 00:22:22.186 A:middle
that gets interesting.

00:22:22.666 --> 00:22:23.726 A:middle
Why is that important?

00:22:23.806 --> 00:22:27.856 A:middle
It's important because in
practice a small object can have

00:22:27.856 --> 00:22:31.006 A:middle
a large graph of other
objects that it references.

00:22:31.436 --> 00:22:33.506 A:middle
So let's say we have,
for example here,

00:22:35.036 --> 00:22:37.906 A:middle
in our world a view
of some kind.

00:22:39.616 --> 00:22:41.976 A:middle
It actually contains
that small chunk

00:22:41.976 --> 00:22:44.766 A:middle
of memory that's actually
allocated for us here,

00:22:45.016 --> 00:22:46.506 A:middle
96 bytes in this case.

00:22:46.506 --> 00:22:51.156 A:middle
It has a layer pointer, has view
delegate pointers, has pointers

00:22:51.156 --> 00:22:52.666 A:middle
to all kinds of other objects.

00:22:52.926 --> 00:22:55.326 A:middle
And these objects
themselves occupy space.

00:22:56.106 --> 00:22:58.716 A:middle
The layer object in this
case another 32 bytes.

00:22:58.716 --> 00:23:00.336 A:middle
And this may not seem
like it's going to add

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:00.336 --> 00:23:02.296 A:middle
up in a hurry except that some

00:23:02.296 --> 00:23:07.486 A:middle
of those objects manage whole
VM regions behind the scenes.

00:23:07.796 --> 00:23:10.706 A:middle
So a CA layer needs to keep
its bitmap data somewhere,

00:23:10.826 --> 00:23:14.066 A:middle
and as it turns out that data
isn't always on the Heap.

00:23:14.316 --> 00:23:17.016 A:middle
In this case we've got a VM
region that could be megabytes

00:23:17.016 --> 00:23:18.316 A:middle
and megabytes of pixel data.

00:23:18.676 --> 00:23:21.016 A:middle
And so it behooves you
to understand that, yes,

00:23:21.156 --> 00:23:24.126 A:middle
what I'm looking for are these
objects that keep large graphs

00:23:24.436 --> 00:23:26.266 A:middle
of other objects
behind the scenes.

00:23:27.186 --> 00:23:28.276 A:middle
There are the obvious ones.

00:23:28.276 --> 00:23:31.056 A:middle
If I look for an NSSet or
an NSDictionary I'll see

00:23:31.056 --> 00:23:32.436 A:middle
that there's a relatively
small amount

00:23:32.436 --> 00:23:34.836 A:middle
of memory attributed
to it by allocations.

00:23:35.356 --> 00:23:38.246 A:middle
But really it's holding onto
we know potentially a large

00:23:38.246 --> 00:23:39.736 A:middle
collection of objects.

00:23:39.736 --> 00:23:42.196 A:middle
And then there's the less
obvious containers, again,

00:23:42.196 --> 00:23:44.836 A:middle
UIView, view controllers
or NSImage

00:23:45.176 --> 00:23:47.126 A:middle
that represent a
lot of information.

00:23:47.396 --> 00:23:49.146 A:middle
So as I showed you
earlier in the call graph

00:23:49.146 --> 00:23:52.786 A:middle
where I found one place
that creates both an object

00:23:53.116 --> 00:23:55.726 A:middle
and a VM region this is
what happens typically.

00:23:55.886 --> 00:23:58.616 A:middle
And it's when you finally
de- reference the object

00:23:58.616 --> 00:24:02.436 A:middle
that the VM region is
deallocated on your behalf.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:02.836 --> 00:24:04.516 A:middle
So what can I do to investigate?

00:24:05.296 --> 00:24:07.956 A:middle
Well, as it turns out
there are a couple

00:24:07.956 --> 00:24:09.336 A:middle
of ways to think about this.

00:24:09.406 --> 00:24:10.426 A:middle
There are my classes.

00:24:11.296 --> 00:24:13.016 A:middle
My classes is a subset.

00:24:13.016 --> 00:24:16.526 A:middle
They're probably things
that hold onto large graphs.

00:24:17.046 --> 00:24:19.476 A:middle
And so if you want to just see
just your classes you should

00:24:19.476 --> 00:24:21.076 A:middle
probably prefix them
consistently.

00:24:21.666 --> 00:24:24.166 A:middle
So in this app we have
everything prefixed with WWDC.

00:24:24.166 --> 00:24:26.216 A:middle
And that means that I can
go ahead and just bring

00:24:26.216 --> 00:24:30.726 A:middle
up the allocations UI, go
ahead and click in the filter

00:24:30.726 --> 00:24:33.196 A:middle
in the upper right
corner and type my prefix.

00:24:35.436 --> 00:24:38.066 A:middle
So once we've got that
prefix typed in you'll see

00:24:38.066 --> 00:24:42.036 A:middle
that we're filtering down to
just the object whose category

00:24:42.036 --> 00:24:43.606 A:middle
here uses that prefix.

00:24:43.606 --> 00:24:47.176 A:middle
And category is the way we
divide all of the allocations

00:24:47.176 --> 00:24:51.716 A:middle
into some reasonably
observable group of objects.

00:24:51.716 --> 00:24:54.816 A:middle
And in this case it's based
on the class of the object.

00:24:54.816 --> 00:24:57.126 A:middle
So if I've used a
consistent prefix it's easy.

00:24:57.126 --> 00:24:59.706 A:middle
But we categorize
objects by things other

00:24:59.706 --> 00:25:01.736 A:middle
than just Objective-C classes.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:01.956 --> 00:25:03.586 A:middle
Specifically we're much,

00:25:03.866 --> 00:25:07.286 A:middle
much better in this
release at C++ objects.

00:25:07.286 --> 00:25:10.276 A:middle
If you have a virtual
C++ class you'll find

00:25:10.276 --> 00:25:12.286 A:middle
that we categorize
those by name as well.

00:25:12.886 --> 00:25:15.186 A:middle
We also find other
things that have V tables.

00:25:15.546 --> 00:25:17.396 A:middle
We can find dispatch queues.

00:25:17.396 --> 00:25:19.716 A:middle
We can find XPC-related types.

00:25:19.926 --> 00:25:21.926 A:middle
Just try searching
for dispatch or XPC.

00:25:22.056 --> 00:25:25.446 A:middle
We can also find blocks
that have escaped the scope

00:25:25.446 --> 00:25:26.626 A:middle
and been allocated on the Heap.

00:25:26.906 --> 00:25:28.976 A:middle
Look for NS malloc
block to find those.

00:25:29.516 --> 00:25:34.566 A:middle
[ Pause ]

00:25:35.066 --> 00:25:36.656 A:middle
So when we look at Heap growth

00:25:36.656 --> 00:25:38.976 A:middle
and it's going the wrong
direction and we could sit down

00:25:38.976 --> 00:25:42.206 A:middle
and look at objects all day
long, there are a few kinds

00:25:42.206 --> 00:25:43.616 A:middle
of problems to keep in mind.

00:25:43.906 --> 00:25:45.566 A:middle
One of them is the
potential for leaked memory.

00:25:46.156 --> 00:25:48.746 A:middle
It's possible that you
have allocated an object,

00:25:48.876 --> 00:25:49.876 A:middle
you've finished using it,

00:25:49.986 --> 00:25:52.206 A:middle
you in fact no longer
have any references to it.

00:25:52.206 --> 00:25:55.426 A:middle
And this is much easier to do
without ARC than it is with ARC.

00:25:55.766 --> 00:25:56.646 A:middle
It's still possible.

00:25:58.006 --> 00:25:59.856 A:middle
If you literally
cannot get to it anymore

00:25:59.856 --> 00:26:02.646 A:middle
because there is no longer a
pointer from any active object

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:02.646 --> 00:26:04.956 A:middle
that you reference we
consider this memory leaked.

00:26:05.066 --> 00:26:06.526 A:middle
And Daniel will show
you a little bit later

00:26:06.796 --> 00:26:09.046 A:middle
about how exactly you
can go about tracking

00:26:09.046 --> 00:26:10.026 A:middle
down this leaked memory.

00:26:10.476 --> 00:26:12.126 A:middle
But there's some
other categories

00:26:12.126 --> 00:26:14.266 A:middle
that are much trickier
to understand.

00:26:15.356 --> 00:26:17.476 A:middle
Abandoned memory,
memory I've allocated,

00:26:18.206 --> 00:26:21.466 A:middle
I have a legitimate path to
get to it, but as it turns

00:26:21.466 --> 00:26:23.396 A:middle
out there's never going to
be a single line of code

00:26:23.396 --> 00:26:26.006 A:middle
that actually follows
that path again.

00:26:26.356 --> 00:26:28.346 A:middle
I stuck it in the global
variable during startup,

00:26:28.346 --> 00:26:30.186 A:middle
and that startup
code is the only code

00:26:30.186 --> 00:26:31.076 A:middle
that ever references it.

00:26:31.076 --> 00:26:32.326 A:middle
That memory has been abandoned.

00:26:32.696 --> 00:26:35.376 A:middle
No leak detection tool on the
planet will find it for you,

00:26:35.736 --> 00:26:37.886 A:middle
but it's still important
that you understand

00:26:37.886 --> 00:26:40.026 A:middle
that that memory
exists and is cluttering

00:26:40.026 --> 00:26:41.226 A:middle
up your user's environment.

00:26:42.616 --> 00:26:44.576 A:middle
There's also cached memory.

00:26:45.176 --> 00:26:47.536 A:middle
If you have a cache that you
stick things in you may find

00:26:47.576 --> 00:26:49.896 A:middle
that you open a document,
put the document reference

00:26:49.896 --> 00:26:51.446 A:middle
in the cache, close
the document,

00:26:51.666 --> 00:26:52.876 A:middle
and it sticks around forever.

00:26:53.006 --> 00:26:55.586 A:middle
It's really efficient to go
and reopen that document now,

00:26:56.186 --> 00:26:58.326 A:middle
but it's a shame if the user
really intends to do a lot

00:26:58.326 --> 00:27:00.226 A:middle
of other things and it's
cluttering up the world.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:00.486 --> 00:27:02.766 A:middle
And in this place
maybe the right thing

00:27:02.766 --> 00:27:05.636 A:middle
to do is consider using NS
Cache to manage your chaches

00:27:05.636 --> 00:27:07.356 A:middle
so that it can handle
memory for you.

00:27:07.356 --> 00:27:09.596 A:middle
But we're going to talk
about tracking some of this

00:27:09.626 --> 00:27:12.686 A:middle
down using a technique
called generational analysis.

00:27:13.406 --> 00:27:14.426 A:middle
You may have seen this before.

00:27:14.426 --> 00:27:16.366 A:middle
Previously we referred
to it as a Heap shot.

00:27:16.726 --> 00:27:18.386 A:middle
But given that we cover more

00:27:18.386 --> 00:27:20.556 A:middle
than Heap now we've
renamed the facility.

00:27:22.016 --> 00:27:25.886 A:middle
It's about following these
steps to find our problems.

00:27:25.886 --> 00:27:26.886 A:middle
We reach a steady state.

00:27:26.886 --> 00:27:28.066 A:middle
We launch our application.

00:27:29.216 --> 00:27:30.696 A:middle
We then do something
that allocates memory,

00:27:30.696 --> 00:27:33.786 A:middle
open a document and then get
back to that steady state,

00:27:33.786 --> 00:27:37.066 A:middle
close the document and
repeat that series of steps.

00:27:37.756 --> 00:27:40.206 A:middle
And along the way we may
find something interesting.

00:27:40.536 --> 00:27:44.146 A:middle
Specifically if I repeat this
process over and over again

00:27:44.146 --> 00:27:47.196 A:middle
and every time memory
winds up accruing,

00:27:47.466 --> 00:27:50.406 A:middle
then I've got some form of
abandoned or over cached

00:27:50.406 --> 00:27:52.126 A:middle
or leaked memory going on.

00:27:52.566 --> 00:27:56.426 A:middle
So visually steady state, some
sort of intermediate state

00:27:56.426 --> 00:27:58.746 A:middle
with the document open,
back to the original state.

00:27:58.936 --> 00:28:02.426 A:middle
Now, you may find that
there's some warmup cost here.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:02.556 --> 00:28:04.756 A:middle
We're loading code that
hasn't been used before.

00:28:04.756 --> 00:28:06.856 A:middle
There's some basic data
structures being set up.

00:28:07.226 --> 00:28:09.616 A:middle
Some level of warmup
cost is to be expected.

00:28:10.056 --> 00:28:12.326 A:middle
But it's on the repeated
use of this

00:28:12.996 --> 00:28:13.976 A:middle
that we wind up finding waste.

00:28:14.516 --> 00:28:19.546 A:middle
[ Pause ]

00:28:20.046 --> 00:28:23.196 A:middle
If you find that you are going
through this repeated cycle

00:28:23.196 --> 00:28:26.006 A:middle
and you're not seeing any
waste, you're getting a net 0,

00:28:26.336 --> 00:28:30.096 A:middle
you may find that you have free
memory from a heap perspective

00:28:30.426 --> 00:28:33.556 A:middle
that isn't actually free from
a virtual memory perspective.

00:28:34.096 --> 00:28:34.796 A:middle
How does that happen?

00:28:34.796 --> 00:28:37.166 A:middle
Well, it's something we refer
to as Heap fragmentation.

00:28:38.006 --> 00:28:41.576 A:middle
Specifically I have a situation
where I have a variety of pages,

00:28:41.576 --> 00:28:43.686 A:middle
and every page has
exactly one object

00:28:43.686 --> 00:28:44.886 A:middle
that I keep referencing on it.

00:28:45.456 --> 00:28:47.646 A:middle
Those pages, therefore,
are still kept in,

00:28:47.646 --> 00:28:48.786 A:middle
they're in physical memory.

00:28:49.226 --> 00:28:52.266 A:middle
And I'm now using 32
bytes of some sort

00:28:52.266 --> 00:28:55.116 A:middle
of legitimate data
occupying 4K of memory.

00:28:55.906 --> 00:28:57.616 A:middle
So what do I do about this?

00:28:57.616 --> 00:28:59.736 A:middle
How do I understand
this situation,

00:28:59.736 --> 00:29:01.376 A:middle
and how did I get there
in the first place?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:02.296 --> 00:29:03.156 A:middle
Well, here's how it happens.

00:29:04.126 --> 00:29:06.106 A:middle
You go ahead and get
a malloc VM region.

00:29:06.306 --> 00:29:09.226 A:middle
This is created for you by
the malloc subsystem in order

00:29:09.226 --> 00:29:10.246 A:middle
to allocate an object.

00:29:10.246 --> 00:29:12.066 A:middle
I then allocate a
bunch of objects

00:29:12.836 --> 00:29:13.896 A:middle
and I've filled this page.

00:29:15.366 --> 00:29:19.036 A:middle
Repeat. So we allocate
a bunch more VM regions.

00:29:19.036 --> 00:29:21.396 A:middle
We fill them with a bunch
more objects, and now we're

00:29:21.396 --> 00:29:22.726 A:middle
in a perfectly reasonable
situation

00:29:22.726 --> 00:29:24.366 A:middle
where we're utilizing
all that memory.

00:29:25.826 --> 00:29:29.056 A:middle
Now we go and we free
most of those objects.

00:29:29.386 --> 00:29:32.246 A:middle
And unfortunately what happens
is we're left with objects

00:29:32.246 --> 00:29:34.196 A:middle
in the locations where
they were allocated,

00:29:34.196 --> 00:29:35.826 A:middle
pinned there occupying memory.

00:29:36.406 --> 00:29:38.966 A:middle
So if you've got a process
that allocates a lot of memory

00:29:38.966 --> 00:29:41.746 A:middle
and then releases most of it
you may be fragmenting memory.

00:29:41.986 --> 00:29:43.466 A:middle
You may not see the
memory coming back

00:29:43.466 --> 00:29:47.556 A:middle
that you would expect
from looking at the Heap.

00:29:47.706 --> 00:29:50.866 A:middle
The biggest thing you can do
about this is avoid a situation

00:29:50.866 --> 00:29:53.556 A:middle
where you have these
extreme peaks and valleys.

00:29:54.426 --> 00:29:55.576 A:middle
So go into Allocations.

00:29:55.936 --> 00:29:58.786 A:middle
This is the place where
the Heap Allocation tool,

00:29:58.786 --> 00:29:59.976 A:middle
if you're just filtering
for Heap

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.056 --> 00:30:01.676 A:middle
only and graphing the Heap,

00:30:01.966 --> 00:30:05.016 A:middle
can show you precisely how
much Heap you're using.

00:30:05.496 --> 00:30:07.836 A:middle
So we're seeing this graph
with peaks and valleys.

00:30:08.166 --> 00:30:10.796 A:middle
And that is indicative
of a potential problem.

00:30:11.646 --> 00:30:16.556 A:middle
You may never get back
the virtual memory region

00:30:16.556 --> 00:30:19.236 A:middle
that is resident from
that high water mark.

00:30:19.566 --> 00:30:21.636 A:middle
Most of the time you'll get
back a significant amount.

00:30:21.966 --> 00:30:24.066 A:middle
But be careful.

00:30:24.556 --> 00:30:27.106 A:middle
Your ideal graph looks
a lot more like this,

00:30:27.576 --> 00:30:30.236 A:middle
relatively small increases
and decreases over time

00:30:30.236 --> 00:30:32.266 A:middle
to the extent that
you can manage it.

00:30:32.976 --> 00:30:35.926 A:middle
Of course your friend
in this is auto release.

00:30:36.546 --> 00:30:38.366 A:middle
Keep in mind that
auto release is sort

00:30:38.366 --> 00:30:40.446 A:middle
of the best tool you
can possibly use here.

00:30:40.696 --> 00:30:42.416 A:middle
And what you need
to do is make sure

00:30:42.416 --> 00:30:45.366 A:middle
that you give the auto
release pool a chance to drain.

00:30:45.706 --> 00:30:47.986 A:middle
You either drain it
yourself in the course

00:30:47.986 --> 00:30:50.446 A:middle
of a long loop that's
doing a lot of operations,

00:30:50.876 --> 00:30:52.146 A:middle
or if you're doing something

00:30:52.146 --> 00:30:55.076 A:middle
on a dispatch queue you may
find it's valuable to drain it.

00:30:55.566 --> 00:30:57.186 A:middle
You need to be careful,
as always,

00:30:57.436 --> 00:30:59.386 A:middle
that auto released
objects aren't something

00:30:59.386 --> 00:31:00.416 A:middle
that you're going to reference

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.416 --> 00:31:02.166 A:middle
after the auto release
pool has been drained.

00:31:02.546 --> 00:31:07.096 A:middle
And with that I'm going to
turn it over to my engineer,

00:31:07.096 --> 00:31:09.996 A:middle
Daniel Delwood, who is going to
dive into more of the mysteries

00:31:10.036 --> 00:31:13.226 A:middle
of Objective-C, retain
release and other goodness.

00:31:13.546 --> 00:31:13.976 A:middle
Thank you, Daniel.

00:31:14.516 --> 00:31:19.956 A:middle
[ Applause ]

00:31:20.456 --> 00:31:21.286 A:middle
&gt;&gt; Thank you, Kate.

00:31:21.286 --> 00:31:23.886 A:middle
So Kate went over virtual
memory from a high level

00:31:24.276 --> 00:31:26.396 A:middle
and then zoomed into
Heap memory.

00:31:26.396 --> 00:31:28.376 A:middle
And now we're going to zoom
in even further and talk

00:31:28.376 --> 00:31:30.276 A:middle
about Objective-C, your objects

00:31:30.276 --> 00:31:33.576 A:middle
and the management schemes
that you can employ.

00:31:33.966 --> 00:31:35.156 A:middle
So first of all let's start

00:31:35.156 --> 00:31:36.806 A:middle
with a brief review
of retain release.

00:31:38.026 --> 00:31:40.016 A:middle
Objective-C uses as a reference
counting ownership model.

00:31:40.696 --> 00:31:43.706 A:middle
And this means that when you
create an object the object

00:31:43.706 --> 00:31:44.946 A:middle
starts out with a
reference count of 1.

00:31:45.756 --> 00:31:50.056 A:middle
So there's two main primitives,
retain which says I want

00:31:50.056 --> 00:31:52.346 A:middle
to express ownership over
this, it bumps the retain count

00:31:52.786 --> 00:31:56.396 A:middle
and release which
releases that ownership

00:31:56.776 --> 00:31:58.726 A:middle
and decrements are
a retain count by 1.

00:31:59.386 --> 00:32:02.136 A:middle
Whenever the account drops
to 0 the object is freed back

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:02.136 --> 00:32:03.056 A:middle
to the malloc subsystem.

00:32:03.956 --> 00:32:06.716 A:middle
Now, the third primitive
there is auto release,

00:32:06.756 --> 00:32:08.026 A:middle
and it's important to remember

00:32:08.026 --> 00:32:11.176 A:middle
that this is just a delayed
release, and it's very useful

00:32:11.176 --> 00:32:16.006 A:middle
for things like returning
objects from functions.

00:32:16.006 --> 00:32:18.916 A:middle
Just remember, though, that
the auto release will issue

00:32:18.916 --> 00:32:21.196 A:middle
that delayed release whenever
the current auto release ends.

00:32:22.306 --> 00:32:24.396 A:middle
The rules are established,
they're easy to learn,

00:32:24.396 --> 00:32:26.086 A:middle
and here's actually a
good reference document,

00:32:26.086 --> 00:32:27.986 A:middle
the advanced memory
management guide.

00:32:28.466 --> 00:32:30.436 A:middle
I'd recommend book marking it.

00:32:30.436 --> 00:32:33.006 A:middle
It's a great place to go back
to when you're debugging issues.

00:32:33.676 --> 00:32:35.556 A:middle
The thing to remember here,

00:32:35.556 --> 00:32:38.056 A:middle
though about Objective-C's
ownership model is

00:32:38.336 --> 00:32:41.366 A:middle
that it's deterministic
and simple to learn.

00:32:41.876 --> 00:32:46.246 A:middle
Most importantly,
though, it's fast.

00:32:46.246 --> 00:32:48.466 A:middle
So what can go wrong
with this, right?

00:32:48.466 --> 00:32:50.026 A:middle
We're talking about
fixing memory issues.

00:32:50.706 --> 00:32:52.426 A:middle
Well, it's tedious.

00:32:53.006 --> 00:32:56.236 A:middle
Writing retain and
release is very error prone

00:32:56.236 --> 00:32:57.676 A:middle
when you're writing
all of this code,

00:32:57.676 --> 00:32:59.306 A:middle
and more code really
is more bugs.

00:32:59.926 --> 00:33:02.316 A:middle
And so if you write too
many retains you're going

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:02.316 --> 00:33:05.196 A:middle
to get objects that may not
be referenced by anything else

00:33:05.196 --> 00:33:07.346 A:middle
in your code but still
have non 0 retain counts.

00:33:07.946 --> 00:33:10.196 A:middle
Now, if you release something
too many times it will quickly

00:33:10.196 --> 00:33:10.846 A:middle
lead to crashes.

00:33:11.376 --> 00:33:15.526 A:middle
Now, the third problem
that's common

00:33:15.526 --> 00:33:16.976 A:middle
with this is retain cycles.

00:33:16.976 --> 00:33:18.846 A:middle
And this is more of
a structural problem,

00:33:18.846 --> 00:33:20.216 A:middle
more of a behavioral problem.

00:33:20.706 --> 00:33:23.296 A:middle
And it's because you
could have objects

00:33:23.296 --> 00:33:25.296 A:middle
that reference each
other, retain each other,

00:33:25.586 --> 00:33:27.096 A:middle
and if they're not
referenced by anything else

00:33:27.096 --> 00:33:30.056 A:middle
in your application
they're still going to leak,

00:33:30.436 --> 00:33:33.216 A:middle
and you need to find some
way of breaking that cycle.

00:33:34.186 --> 00:33:37.156 A:middle
Well, luckily for the
tedium it's gone now.

00:33:37.836 --> 00:33:39.226 A:middle
We have automatic
reference counting.

00:33:39.656 --> 00:33:41.076 A:middle
And the compiler is really great

00:33:41.076 --> 00:33:43.586 A:middle
about doing those retains
and releases for us.

00:33:44.336 --> 00:33:47.106 A:middle
So it's compiler assisted
convention enforcement.

00:33:47.466 --> 00:33:50.106 A:middle
It knows that whole document
I just told you about.

00:33:50.106 --> 00:33:52.426 A:middle
It knows how to do the
retain and release perfectly.

00:33:52.426 --> 00:33:55.406 A:middle
But it's still important
that you know how

00:33:55.806 --> 00:33:57.516 A:middle
that convention works
under the covers.

00:33:57.556 --> 00:33:59.316 A:middle
Because whether you're
running ARC or not,

00:33:59.726 --> 00:34:01.556 A:middle
when you're debugging
issues you need to be able

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:01.556 --> 00:34:05.056 A:middle
to understand all of the
data, understand what retain

00:34:05.056 --> 00:34:08.386 A:middle
and release means in
your object history.

00:34:09.516 --> 00:34:13.426 A:middle
Now, automatic reference
counting doesn't solve retain

00:34:13.426 --> 00:34:16.426 A:middle
cycles on its own because
that's not a mechanics issue,

00:34:16.426 --> 00:34:18.525 A:middle
that's a design and
behavior issue.

00:34:19.085 --> 00:34:21.696 A:middle
Luckily, though, it does
provide some very useful tools

00:34:21.696 --> 00:34:24.795 A:middle
and keywords to help fix
these including things

00:34:24.795 --> 00:34:27.426 A:middle
like zeroing weak references
where you can mark one

00:34:27.426 --> 00:34:31.596 A:middle
of the references weak and
the whole cycle will go away.

00:34:31.775 --> 00:34:36.176 A:middle
So let's talk about then
what the common problems are

00:34:36.436 --> 00:34:39.896 A:middle
under ARC and focus on
those more behavioral

00:34:39.896 --> 00:34:40.846 A:middle
structural issues.

00:34:41.585 --> 00:34:43.686 A:middle
Well, the first one
is memory growth.

00:34:44.666 --> 00:34:48.396 A:middle
And memory growth can really
come in two different forms.

00:34:48.716 --> 00:34:50.666 A:middle
The first like I talked
about is retain cycles.

00:34:51.585 --> 00:34:55.275 A:middle
And the second is
abandoned objects.

00:34:55.916 --> 00:34:59.576 A:middle
So for retain cycles the leaks
instrument actually provides a

00:34:59.576 --> 00:35:02.266 A:middle
very nice graphical
display of the cycle

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:02.406 --> 00:35:05.426 A:middle
so you can easily understand
what the cause is and go in

00:35:05.426 --> 00:35:09.026 A:middle
and find out where you need to
use the weak keyword and fix it.

00:35:09.586 --> 00:35:12.056 A:middle
As for abandoned objects,
what Kate was talking

00:35:12.056 --> 00:35:14.366 A:middle
about with the generational
analysis is definitely the best

00:35:14.366 --> 00:35:14.736 A:middle
way to go.

00:35:15.986 --> 00:35:19.026 A:middle
The second thing that can happen

00:35:19.026 --> 00:35:21.386 A:middle
in ARC is messaging the
deallocated objects.

00:35:21.916 --> 00:35:23.456 A:middle
Now, you might say
how is this happening

00:35:23.456 --> 00:35:25.676 A:middle
if I'm not issuing
too many releases?

00:35:26.026 --> 00:35:27.636 A:middle
Well, I'll get to
that in a little bit.

00:35:27.636 --> 00:35:31.286 A:middle
But the problem with messaging
these objects is it's very

00:35:31.286 --> 00:35:33.136 A:middle
undefined and nondeterministic
behavior.

00:35:33.136 --> 00:35:35.486 A:middle
You might way, well, it
always crashes for me,

00:35:35.956 --> 00:35:38.386 A:middle
but it really depends
on what happens

00:35:38.426 --> 00:35:41.136 A:middle
to that object once you free it.

00:35:41.136 --> 00:35:44.516 A:middle
If you return the memory to the
malloc system it doesn't have

00:35:44.516 --> 00:35:46.086 A:middle
to clear it, it doesn't
have to reuse it.

00:35:46.436 --> 00:35:49.936 A:middle
And it may still appear to be
an object, it may still respond

00:35:49.936 --> 00:35:52.246 A:middle
to messages and you won't
get a crash some of the time.

00:35:52.246 --> 00:35:53.906 A:middle
When you do get crashes, though,

00:35:54.126 --> 00:35:57.006 A:middle
things like Objective-C
message send, store strong

00:35:57.296 --> 00:35:59.746 A:middle
or it does not respond to
selector are good indicators

00:35:59.746 --> 00:36:01.496 A:middle
that this is the sort of
problem that you have.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:02.866 --> 00:36:05.526 A:middle
So how do we fix that?

00:36:05.526 --> 00:36:06.486 A:middle
What tools do we have?

00:36:06.996 --> 00:36:09.736 A:middle
Well, the Zombies template
is a great way to do this,

00:36:09.736 --> 00:36:13.466 A:middle
and it uses a very age old
debugging environment variable

00:36:13.846 --> 00:36:15.066 A:middle
exposed by foundation.

00:36:15.476 --> 00:36:17.036 A:middle
And that's Zombie
enabled equals 1.

00:36:17.406 --> 00:36:20.396 A:middle
And what this does is instead
of objects being deallocated

00:36:20.586 --> 00:36:23.886 A:middle
when they're freed or when
their retain counts goes to 0,

00:36:24.166 --> 00:36:25.676 A:middle
they're changed into
Zombie objects.

00:36:26.386 --> 00:36:29.216 A:middle
So that whenever you reference
them later and use them

00:36:29.306 --> 00:36:31.436 A:middle
and send them a message
they crash.

00:36:32.256 --> 00:36:34.536 A:middle
Very deterministic behavior,
and this is what we want

00:36:34.536 --> 00:36:35.506 A:middle
when we're debugging issues.

00:36:36.756 --> 00:36:39.616 A:middle
So, again, it's deterministic

00:36:39.616 --> 00:36:42.596 A:middle
because the memory isn't
unchanged or reused.

00:36:43.386 --> 00:36:48.206 A:middle
And I want to also point
out that every Zombie object

00:36:48.336 --> 00:36:51.506 A:middle
that you leave in your process
is technically also a leak.

00:36:51.506 --> 00:36:53.986 A:middle
So you really don't want to
use this sort of debugging

00:36:54.196 --> 00:36:56.186 A:middle
at the same time that you're
looking for leaks in your code.

00:36:56.186 --> 00:36:58.736 A:middle
An important note, though,

00:36:58.936 --> 00:37:00.186 A:middle
previously this was
only available

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:00.186 --> 00:37:02.386 A:middle
for iOS on the iOS Simulator.

00:37:03.166 --> 00:37:04.976 A:middle
It's now available
for iOS 7 devices.

00:37:05.516 --> 00:37:11.546 A:middle
[ Applause ]

00:37:12.046 --> 00:37:13.606 A:middle
So with that I want to
show you a quick demo.

00:37:14.316 --> 00:37:16.476 A:middle
So I have here the
same WWDC app,

00:37:16.476 --> 00:37:20.086 A:middle
and I was noticing
an intermittent crash

00:37:20.556 --> 00:37:22.996 A:middle
when I was dealing with
bad network conditions.

00:37:23.376 --> 00:37:25.896 A:middle
Well, I can actually reproduce
this a lot easier just

00:37:25.896 --> 00:37:28.876 A:middle
by messing up a URL, and you'll
see what it turns out to do.

00:37:29.186 --> 00:37:32.336 A:middle
So I'm going to go ahead
and run this on my phone.

00:37:33.516 --> 00:37:39.916 A:middle
[ Pause ]

00:37:40.416 --> 00:37:44.976 A:middle
So the app comes up.

00:37:45.066 --> 00:37:49.466 A:middle
You'll have to trust me it's
looking very nice on iOS 7.

00:37:50.246 --> 00:37:52.876 A:middle
And immediately we see
this sort of thing.

00:37:52.876 --> 00:37:58.156 A:middle
Exec bad access, crash, and
if we zoom in here right

00:37:58.156 --> 00:38:00.276 A:middle
in the debugger ObjC
underscore release.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.446 --> 00:38:03.916 A:middle
So it looks like we've
got probably a memory

00:38:03.916 --> 00:38:04.536 A:middle
management issue.

00:38:04.626 --> 00:38:08.376 A:middle
So I'm just going to
use the profile action

00:38:08.376 --> 00:38:14.256 A:middle
from the run menu,
and goes ahead builds,

00:38:15.956 --> 00:38:18.626 A:middle
pops open instruments,
and I can go ahead

00:38:18.626 --> 00:38:20.606 A:middle
and select the Zombies
template for my device.

00:38:22.096 --> 00:38:25.116 A:middle
So, again, it launches,
and we get this graph

00:38:25.846 --> 00:38:28.366 A:middle
of allocations as we'd expect.

00:38:29.676 --> 00:38:33.086 A:middle
Alright, so instruments has
detected that I have message

00:38:33.086 --> 00:38:36.586 A:middle
to Zombie, and I can get
some more information just

00:38:36.586 --> 00:38:37.216 A:middle
by hitting the arrow.

00:38:38.826 --> 00:38:40.366 A:middle
So the first thing
you'll notice here is

00:38:40.366 --> 00:38:43.006 A:middle
that my retain release
history looks a lot different

00:38:43.076 --> 00:38:44.596 A:middle
than it did in Xcode 4.

00:38:44.596 --> 00:38:49.106 A:middle
And that's because what
Instruments is doing is showing

00:38:49.106 --> 00:38:51.656 A:middle
me a pairing view of
retains and releases.

00:38:51.896 --> 00:38:55.666 A:middle
And if I turn this down you'll
see that we have malloc events,

00:38:55.666 --> 00:39:00.336 A:middle
auto release, retain release all
grouped together into one chunk.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:01.006 --> 00:39:03.526 A:middle
Now the scope bar here
allows me to change my view

00:39:03.756 --> 00:39:06.936 A:middle
so I can see it by time which is
what I'm used to seeing before.

00:39:07.696 --> 00:39:09.026 A:middle
Or, I can see it again grouped

00:39:09.156 --> 00:39:11.916 A:middle
by that pairing or
bad back trace.

00:39:12.496 --> 00:39:15.666 A:middle
So the interesting part here
is that I can select each one

00:39:15.666 --> 00:39:22.026 A:middle
of these events and take a look
at the stack trace on the right.

00:39:22.026 --> 00:39:24.246 A:middle
And look through and see,
okay, what's going on here.

00:39:24.536 --> 00:39:25.906 A:middle
But Instruments has
already told me

00:39:25.996 --> 00:39:28.996 A:middle
that these are very
likely already paired.

00:39:28.996 --> 00:39:30.946 A:middle
They're already matching up.

00:39:30.946 --> 00:39:34.136 A:middle
There's probably not too many
retains, too many releases.

00:39:34.526 --> 00:39:40.256 A:middle
So the question is why is this a
message to a deallocated objects

00:39:40.256 --> 00:39:41.436 A:middle
and Objective-C store strong?

00:39:42.606 --> 00:39:44.256 A:middle
So we can just jump
right to the code.

00:39:44.566 --> 00:39:50.556 A:middle
And I'm going to open it in
Xcode so you can see it better.

00:39:51.066 --> 00:39:53.356 A:middle
And what happens,
let's see here --

00:39:54.516 --> 00:40:00.676 A:middle
[ Pause ]

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:01.176 --> 00:40:02.726 A:middle
What we've got --

00:40:03.516 --> 00:40:08.006 A:middle
[ Pause ]

00:40:08.506 --> 00:40:13.196 A:middle
-- is an error parameter
being returned by reference

00:40:13.316 --> 00:40:15.496 A:middle
from this process
raw data function.

00:40:16.456 --> 00:40:19.936 A:middle
So it seems like a
very standard function

00:40:19.936 --> 00:40:21.886 A:middle
for parsing a JSON response.

00:40:21.886 --> 00:40:23.156 A:middle
We've got an auto
release pool around it

00:40:23.156 --> 00:40:25.136 A:middle
because it's doing a lot
of string manipulation

00:40:25.136 --> 00:40:27.636 A:middle
and we don't want to
cause memory spikes,

00:40:27.636 --> 00:40:29.416 A:middle
and then we're passing
our error back.

00:40:29.416 --> 00:40:32.596 A:middle
So the question is why is
this crashing when we get back

00:40:32.596 --> 00:40:35.426 A:middle
to our caller of process
raw data right here.

00:40:36.016 --> 00:40:37.686 A:middle
We get the error back,
and then we're trying

00:40:37.686 --> 00:40:41.106 A:middle
to store a response
process error below.

00:40:42.666 --> 00:40:44.716 A:middle
Well, just by taking
a look at the retain

00:40:44.716 --> 00:40:46.076 A:middle
and release history we'll see

00:40:46.076 --> 00:40:48.386 A:middle
that there was auto
release going on so

00:40:48.386 --> 00:40:50.606 A:middle
that we can pass objects
back to our callers.

00:40:51.066 --> 00:40:54.286 A:middle
But then those auto release
pools actually popped somewhere

00:40:54.286 --> 00:40:54.776 A:middle
in between.

00:40:55.786 --> 00:40:57.036 A:middle
In looking at that function

00:40:57.036 --> 00:40:59.046 A:middle
that we saw there was an auto
release pool written there.

00:40:59.446 --> 00:41:00.746 A:middle
So I'll talk about this
a little bit later,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:00.746 --> 00:41:04.526 A:middle
but what we really needed to
do is was use a local NSError

00:41:04.526 --> 00:41:08.336 A:middle
and get that assignment
done outside

00:41:08.336 --> 00:41:10.706 A:middle
of the auto release pool.

00:41:10.886 --> 00:41:13.986 A:middle
So, the other thing I want

00:41:13.986 --> 00:41:17.776 A:middle
to show you here is using
the leaks instrument.

00:41:18.636 --> 00:41:20.826 A:middle
I'll just go ahead
and fix that typo.

00:41:21.376 --> 00:41:24.956 A:middle
And so I could just go ahead and
profile again in instruments.

00:41:25.516 --> 00:41:30.726 A:middle
[ Pause ]

00:41:31.226 --> 00:41:35.646 A:middle
I actually want to use
the leaks template.

00:41:36.516 --> 00:41:42.046 A:middle
[ Pause ]

00:41:42.546 --> 00:41:44.986 A:middle
And Instrument starts up
with both the template

00:41:44.986 --> 00:41:50.706 A:middle
with both allocation and
leaks and starts recording.

00:41:53.256 --> 00:41:56.506 A:middle
So quickly you'll notice that
we have some leaks detected

00:41:56.506 --> 00:41:57.156 A:middle
in the background.

00:41:57.496 --> 00:42:00.106 A:middle
And I can just go ahead and use
the app a little bit and sort

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:00.106 --> 00:42:02.206 A:middle
of get some activity going on.

00:42:02.686 --> 00:42:04.766 A:middle
And as I scroll around it
actually is interesting to type

00:42:04.766 --> 00:42:09.646 A:middle
in that WWDC prefix and
take a look at the view here

00:42:09.646 --> 00:42:12.786 A:middle
to see anything interesting
going on in our Heap.

00:42:13.236 --> 00:42:15.846 A:middle
If we zoom in we'll even notice
that like our table cells,

00:42:16.066 --> 00:42:17.406 A:middle
there's a lot of
transient cells.

00:42:17.786 --> 00:42:19.296 A:middle
It's very likely we've
done something wrong

00:42:19.296 --> 00:42:20.806 A:middle
with cell reuse use
just by looking

00:42:20.806 --> 00:42:22.296 A:middle
at these high level statistics.

00:42:23.656 --> 00:42:26.566 A:middle
And another interesting
thing here

00:42:26.566 --> 00:42:28.756 A:middle
with the retain release
view is if I select one

00:42:28.756 --> 00:42:31.286 A:middle
of these WWDC news
objects you'll notice

00:42:31.286 --> 00:42:34.636 A:middle
that Instruments was able to
quickly pair up a whole ton

00:42:34.636 --> 00:42:38.196 A:middle
of retains and releases even
pairing together retains auto

00:42:38.196 --> 00:42:38.976 A:middle
releases and releases together.

00:42:42.476 --> 00:42:44.716 A:middle
So let's take a look
at the leaks,

00:42:45.086 --> 00:42:46.206 A:middle
and I'll remove my filter.

00:42:46.206 --> 00:42:49.296 A:middle
And I'm actually interested in
a certain reachability leak.

00:42:50.416 --> 00:42:53.146 A:middle
You'll notice that
we have a bunch

00:42:53.146 --> 00:42:54.946 A:middle
of different objects
types, NS datas,

00:42:55.076 --> 00:42:57.166 A:middle
NS arrays, network reachability.

00:42:58.016 --> 00:43:01.836 A:middle
And they're all coming from
the system configuration

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:01.836 --> 00:43:03.236 A:middle
system library.

00:43:03.826 --> 00:43:05.476 A:middle
So are these really
our fault or not?

00:43:06.296 --> 00:43:09.626 A:middle
Well, to see if they're
related I can go to the cycles

00:43:09.626 --> 00:43:12.286 A:middle
and roots page and
see that, yes,

00:43:12.286 --> 00:43:14.906 A:middle
the SC network reachability
is a root leak,

00:43:15.306 --> 00:43:21.386 A:middle
and that this actually leaks
an NSArray which leaks a list.

00:43:21.956 --> 00:43:24.466 A:middle
So that's kind of nice.

00:43:24.506 --> 00:43:26.876 A:middle
I can focus all my efforts
in that one location.

00:43:27.356 --> 00:43:31.966 A:middle
So if I click on the network
reachability object and pull

00:43:31.966 --> 00:43:34.886 A:middle
in the extended detail view, I
notice I allocate it right here

00:43:34.886 --> 00:43:37.976 A:middle
at reachability with host name.

00:43:38.446 --> 00:43:44.376 A:middle
And in Xcode this shows up as me
using an SC network reachability

00:43:44.376 --> 00:43:47.696 A:middle
with host name, and then
I create a wrapper for it

00:43:47.696 --> 00:43:48.456 A:middle
and then I release it.

00:43:48.456 --> 00:43:50.756 A:middle
So it looks like I'm
using it fine, right?

00:43:51.666 --> 00:43:53.306 A:middle
No problem at the
allocation point.

00:43:54.196 --> 00:43:57.936 A:middle
Well, if I dive right in I again
get that retain release view,

00:43:59.356 --> 00:44:01.246 A:middle
and not many retains
and releases.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:01.966 --> 00:44:04.766 A:middle
Well, I'd like to pair these up
and know which one is at fault.

00:44:04.766 --> 00:44:07.366 A:middle
So we have a nice
pairing assistant

00:44:07.366 --> 00:44:08.966 A:middle
in the bottom left
that I can bring up.

00:44:09.946 --> 00:44:12.296 A:middle
And if I select different
CF retains

00:44:12.296 --> 00:44:15.046 A:middle
and CF releases it
will suggest ones

00:44:15.046 --> 00:44:16.376 A:middle
that could be possibly
be paired to it.

00:44:16.376 --> 00:44:20.196 A:middle
So in this case I have a
CF retain and a CF release,

00:44:20.236 --> 00:44:21.906 A:middle
and these look like
they're pretty paired.

00:44:22.506 --> 00:44:26.426 A:middle
And here's my malloc that I just
looked at and that CF release

00:44:26.826 --> 00:44:29.506 A:middle
that I just saw as well
so I can pair these up.

00:44:30.256 --> 00:44:32.766 A:middle
And now I very quickly
dropped everything

00:44:32.766 --> 00:44:36.216 A:middle
out of this table except
for the CF retain that's

00:44:36.216 --> 00:44:37.156 A:middle
probably unmatched.

00:44:37.746 --> 00:44:43.996 A:middle
Double click, go to source, and
here we have the INIT [phonetic]

00:44:43.996 --> 00:44:45.326 A:middle
with reachability ref.

00:44:45.696 --> 00:44:49.066 A:middle
And so we're doing a CF retain
into the reachability ref.

00:44:49.146 --> 00:44:51.656 A:middle
And well, oops, I forgot
to write into the alloc

00:44:51.706 --> 00:44:55.726 A:middle
so that's pretty easy to go fix.

00:44:56.016 --> 00:44:59.496 A:middle
So, alright, that is showing
you the Zombies template

00:44:59.496 --> 00:45:02.866 A:middle
on an iOS device and taking
a look at a couple leaks.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:04.516 --> 00:45:12.806 A:middle
[ Applause ]

00:45:13.306 --> 00:45:15.446 A:middle
So first steps in applying this

00:45:15.446 --> 00:45:17.796 A:middle
to your app I'd very
much recommend

00:45:17.796 --> 00:45:18.636 A:middle
that you switch to ARC.

00:45:18.636 --> 00:45:22.096 A:middle
It gets rid of a lot of that
code that the compiler can do

00:45:22.096 --> 00:45:23.956 A:middle
for you and do very, very well,

00:45:24.456 --> 00:45:25.886 A:middle
and also run the
static analyzer.

00:45:25.886 --> 00:45:28.846 A:middle
You may have noticed there
actually are some analyzer

00:45:28.846 --> 00:45:29.896 A:middle
warnings, and had I looked

00:45:29.896 --> 00:45:31.806 A:middle
at the analyzer I may have
fixed some of those bugs

00:45:31.806 --> 00:45:33.356 A:middle
without having to do
any run time debugging.

00:45:33.706 --> 00:45:36.466 A:middle
And that's always a lot
better if you can save time.

00:45:37.516 --> 00:45:40.146 A:middle
Another thing if
you have crashes,

00:45:40.206 --> 00:45:41.816 A:middle
the Zombies template is
a great first resort.

00:45:41.816 --> 00:45:44.386 A:middle
If it doesn't catch anything,
great, continue debugging.

00:45:44.386 --> 00:45:46.566 A:middle
But if it does then you just
saved yourself a lot of time.

00:45:47.976 --> 00:45:51.266 A:middle
For leaks the back trace of
that allocation doesn't tell the

00:45:51.266 --> 00:45:54.746 A:middle
whole story, so you can't just
stop at that top level view.

00:45:54.746 --> 00:45:56.236 A:middle
You really do need to dive down,

00:45:56.536 --> 00:45:59.306 A:middle
look at the retain
release history even

00:45:59.306 --> 00:46:02.586 A:middle
when it's an object
that's managed by ARC.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:02.586 --> 00:46:06.146 A:middle
And, finally, you
could save time now

00:46:06.286 --> 00:46:09.046 A:middle
by pairing those retains and
releases with the new UI.

00:46:10.246 --> 00:46:12.976 A:middle
So there's two ways to
do it as I've showed,

00:46:12.976 --> 00:46:15.476 A:middle
the manual pairing
assistant as well

00:46:15.476 --> 00:46:18.826 A:middle
as the heuristic-based
automatic pairing.

00:46:19.246 --> 00:46:21.506 A:middle
And you can see in this
screen shot that most

00:46:21.506 --> 00:46:23.686 A:middle
of them were automatically
paired, and I've got

00:46:23.686 --> 00:46:26.026 A:middle
that assistant up
giving me suggestions.

00:46:26.616 --> 00:46:28.706 A:middle
Now, I should note that
this is actually better

00:46:28.946 --> 00:46:33.316 A:middle
if you're using ARC and if
you're using no optimization.

00:46:33.316 --> 00:46:36.816 A:middle
And so why do I mention
that specifically?

00:46:37.666 --> 00:46:40.996 A:middle
Well, because by default the
profile action that I was using

00:46:40.996 --> 00:46:44.436 A:middle
from the run menu it defaults
to the release configuration.

00:46:44.436 --> 00:46:46.836 A:middle
And release is really great
if you're doing things

00:46:46.836 --> 00:46:48.896 A:middle
like performance work
and trying to find

00:46:48.896 --> 00:46:51.646 A:middle
out how your app is
spending its time.

00:46:51.916 --> 00:46:55.976 A:middle
You really want it to behave
as much as you can the same way

00:46:55.976 --> 00:46:56.886 A:middle
as you're going to ship it.

00:46:57.706 --> 00:46:59.576 A:middle
For memory tools
and memory analysis

00:46:59.676 --> 00:47:02.266 A:middle
that additional debugging
info is actually very useful.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:02.266 --> 00:47:10.456 A:middle
And so you can set it by just
using the scheme editor and so

00:47:10.456 --> 00:47:13.046 A:middle
that that profile action
translates directly

00:47:13.046 --> 00:47:16.376 A:middle
to the profile action in
the scheme and just set it

00:47:16.376 --> 00:47:19.226 A:middle
to release, or set it
to debug, I'm sorry.

00:47:20.736 --> 00:47:23.236 A:middle
So with that I want
to talk about a couple

00:47:23.236 --> 00:47:27.686 A:middle
of common Objective-C issues
that you can face even under ARC

00:47:28.046 --> 00:47:30.536 A:middle
because these are the
issues that are behavioral,

00:47:30.806 --> 00:47:31.866 A:middle
structural in your code.

00:47:32.306 --> 00:47:34.256 A:middle
And there's a lot of
really powerful keywords

00:47:34.716 --> 00:47:38.186 A:middle
that the run time provides
to solve some issues.

00:47:38.576 --> 00:47:39.856 A:middle
They're both powerful, and some

00:47:39.856 --> 00:47:40.946 A:middle
of them are a little
bit dangerous.

00:47:41.036 --> 00:47:43.486 A:middle
And so I want to go through
a couple of these so that

00:47:43.486 --> 00:47:45.496 A:middle
when you see them in your
code you hopefully won't be

00:47:45.566 --> 00:47:48.956 A:middle
surprised, and you'll be able to
more quickly get to a solution.

00:47:49.586 --> 00:47:53.116 A:middle
So the first thing
is block captures.

00:47:53.116 --> 00:47:54.616 A:middle
Now, blocks are really,
really powerful,

00:47:55.056 --> 00:47:59.056 A:middle
and you can use Objective-C
objectives, dispatch objects,

00:47:59.056 --> 00:48:00.296 A:middle
many things inside them.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:01.396 --> 00:48:03.916 A:middle
And when they're copied
to the Heap for things

00:48:03.916 --> 00:48:05.136 A:middle
like dispatch A sync

00:48:05.136 --> 00:48:08.576 A:middle
or as registrations they capture
those reference objects strongly

00:48:08.576 --> 00:48:09.146 A:middle
by default.

00:48:09.686 --> 00:48:12.086 A:middle
So if you use self
it will retain self,

00:48:12.086 --> 00:48:14.506 A:middle
and when the block is
destroyed it will release self.

00:48:15.236 --> 00:48:18.696 A:middle
But instance variables are
also implicitly reference self.

00:48:18.696 --> 00:48:20.106 A:middle
So this means if you have an

00:48:20.146 --> 00:48:23.096 A:middle
under bar fu [phonetic]
it's going to reference self

00:48:23.096 --> 00:48:24.486 A:middle
and use it in that way.

00:48:24.576 --> 00:48:26.616 A:middle
So let me show you
an example here.

00:48:27.016 --> 00:48:28.886 A:middle
I'm using NS Notification
Center API.

00:48:29.576 --> 00:48:33.286 A:middle
And I'm storing the observer
token in an instance variable.

00:48:33.906 --> 00:48:36.106 A:middle
Great. So self is
retaining observer token,

00:48:36.106 --> 00:48:38.136 A:middle
and then I'm sending in a block,

00:48:38.406 --> 00:48:41.396 A:middle
and that block is
roundabout retained

00:48:41.396 --> 00:48:43.216 A:middle
by the observer token as well.

00:48:44.456 --> 00:48:46.876 A:middle
But self is retained
by that block,

00:48:46.876 --> 00:48:49.146 A:middle
and so you can really quickly
see here that this leads

00:48:49.146 --> 00:48:51.316 A:middle
to retain cycle and it's
going to cause problems.

00:48:51.866 --> 00:48:54.626 A:middle
So the solution is just
to use a weak keyword

00:48:54.626 --> 00:48:55.626 A:middle
to break these cycles.

00:48:55.626 --> 00:49:01.156 A:middle
In this case we can just
define a weakly notified self

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:01.246 --> 00:49:03.176 A:middle
and use it inside the block.

00:49:04.216 --> 00:49:07.766 A:middle
Now, just as a note, when you
are running non-ARC you may have

00:49:07.766 --> 00:49:09.876 A:middle
to use the under
under block keyword

00:49:09.876 --> 00:49:11.686 A:middle
to also indicate don't retain.

00:49:11.686 --> 00:49:15.176 A:middle
It means that the variable can
be modified inside the block,

00:49:15.176 --> 00:49:17.746 A:middle
but it has that additional
effect under non-ARC.

00:49:19.136 --> 00:49:21.946 A:middle
So when do you need to look for
these retain cycles in blocks?

00:49:22.016 --> 00:49:24.066 A:middle
So is it all the time
or is it just sometimes?

00:49:24.306 --> 00:49:26.876 A:middle
Well, it's mostly just
persistent relationships,

00:49:26.916 --> 00:49:29.286 A:middle
so things like I showed
you, NS notifications

00:49:29.336 --> 00:49:33.936 A:middle
or error call backs or
things that recur over time.

00:49:34.016 --> 00:49:37.706 A:middle
So things like timers,
dispatch source handlers,

00:49:38.146 --> 00:49:39.766 A:middle
and that's where you
should definitely look

00:49:39.766 --> 00:49:41.366 A:middle
to using the weak keyword.

00:49:41.836 --> 00:49:43.916 A:middle
For things like one
time executions,

00:49:44.186 --> 00:49:47.226 A:middle
enumeration of an array, of
a dictionary you don't need

00:49:47.226 --> 00:49:49.286 A:middle
to use the weak keyword.

00:49:50.796 --> 00:49:53.656 A:middle
So let's talk about
weak just a little bit.

00:49:54.026 --> 00:49:56.896 A:middle
What does weak do and what
does that mean to you?

00:49:57.556 --> 00:49:59.976 A:middle
Well, weak validates
the reference

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:00.116 --> 00:50:01.586 A:middle
whenever it's used.

00:50:01.776 --> 00:50:05.466 A:middle
So it checks that the object
it refers to is still alive

00:50:05.466 --> 00:50:07.506 A:middle
and hasn't entered it's
dealloc on another thread.

00:50:08.176 --> 00:50:13.476 A:middle
So if the object isn't alive you
get back nil whenever you use a

00:50:13.476 --> 00:50:13.946 A:middle
weak variable.

00:50:14.456 --> 00:50:16.326 A:middle
This means you should avoid
consecutive uses, right?

00:50:16.326 --> 00:50:17.366 A:middle
If you begin transaction

00:50:17.366 --> 00:50:20.426 A:middle
on a weak variable then
you end transaction, well,

00:50:20.426 --> 00:50:22.746 A:middle
maybe only the begin
transaction went

00:50:22.746 --> 00:50:26.846 A:middle
through because your weak
reference may return nil

00:50:26.846 --> 00:50:27.586 A:middle
on the second use.

00:50:28.646 --> 00:50:31.776 A:middle
Finally, never do an arrow
to reference with weak.

00:50:32.496 --> 00:50:35.426 A:middle
And just to show you an example
of this, I can even check

00:50:35.566 --> 00:50:39.066 A:middle
if weak object then
I'll do an access

00:50:39.066 --> 00:50:41.176 A:middle
of the weak object's delegate
by an arrow reference.

00:50:42.286 --> 00:50:45.386 A:middle
If you get back nil then you've
referenced no and crashed.

00:50:45.676 --> 00:50:49.566 A:middle
So better would be to use
the dot syntax in this case

00:50:49.846 --> 00:50:53.866 A:middle
to access a delegate,
because sending a message

00:50:53.866 --> 00:50:56.286 A:middle
to nil is just fine.

00:50:56.736 --> 00:50:58.216 A:middle
Or, you can be very explicit,

00:50:58.266 --> 00:51:00.116 A:middle
and this is actually
probably the best way to go.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:00.116 --> 00:51:05.256 A:middle
Just create a strong object,
promote your weak reference

00:51:05.656 --> 00:51:08.826 A:middle
and then use the strong
object in any way you see fit.

00:51:10.196 --> 00:51:12.016 A:middle
So one final note about weak.

00:51:12.016 --> 00:51:14.086 A:middle
Since it has to validate
the reference,

00:51:14.216 --> 00:51:15.456 A:middle
it's not a free thing.

00:51:15.456 --> 00:51:18.256 A:middle
So if this is in a really,
really hot loop you may want

00:51:18.346 --> 00:51:21.276 A:middle
to think about promoting
it to strong and using that

00:51:21.676 --> 00:51:28.176 A:middle
or not using weak in
that specific instance.

00:51:28.176 --> 00:51:29.706 A:middle
Which brings us to
unsafe unretained.

00:51:30.296 --> 00:51:34.776 A:middle
This is, as the name
suggests, an unsafe keyword.

00:51:35.376 --> 00:51:37.416 A:middle
But there's some risk
and there's some reward.

00:51:37.986 --> 00:51:41.276 A:middle
What it says is ARC please don't
manage this variable at all.

00:51:41.646 --> 00:51:43.796 A:middle
There's no retain when something
is stored to the variable,

00:51:43.856 --> 00:51:46.036 A:middle
no release when nil is
stored to the variable.

00:51:47.536 --> 00:51:49.976 A:middle
Important to note, though,
is if you've got legacy code

00:51:49.976 --> 00:51:52.786 A:middle
that you've sort of by
hand migrated to ARC,

00:51:53.256 --> 00:51:56.276 A:middle
if you're using property
assign this actually means

00:51:56.276 --> 00:51:57.846 A:middle
under the covers
unsafe unretained.

00:51:57.846 --> 00:52:00.856 A:middle
And so you can very
easily get crashes

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:00.856 --> 00:52:02.506 A:middle
because these are
dangling references

00:52:02.556 --> 00:52:04.096 A:middle
to whatever the object is.

00:52:05.676 --> 00:52:08.066 A:middle
Also keep in mind that many

00:52:08.066 --> 00:52:11.296 A:middle
of the frameworks will have
these sort of unsafe references

00:52:11.406 --> 00:52:13.826 A:middle
to your code such as
delegates or data sources.

00:52:14.276 --> 00:52:18.106 A:middle
And if you're getting a
crash where it's trying

00:52:18.106 --> 00:52:20.916 A:middle
to send a data source
message to your object

00:52:21.006 --> 00:52:22.346 A:middle
and your object is
already deallocated,

00:52:22.606 --> 00:52:24.946 A:middle
you may have just needed to
go into your dealloc and mill

00:52:24.946 --> 00:52:27.176 A:middle
out that data source
before your object went way.

00:52:28.656 --> 00:52:32.526 A:middle
So in general I would
sort of recommend this

00:52:32.526 --> 00:52:35.076 A:middle
as last resort keyword if
you have performance issues

00:52:35.316 --> 00:52:37.026 A:middle
or you need to use it
for some other reason.

00:52:38.496 --> 00:52:42.676 A:middle
So one of the key words to talk
about here is auto releasing.

00:52:42.676 --> 00:52:45.146 A:middle
And this one actually came
up with that demo example.

00:52:45.266 --> 00:52:48.026 A:middle
So for an auto releasing
variable the object has sent a

00:52:48.026 --> 00:52:51.796 A:middle
retain and then auto release
whenever assignment happens

00:52:51.796 --> 00:52:52.056 A:middle
to it.

00:52:52.666 --> 00:52:55.076 A:middle
So out parameters are
actually auto releasing

00:52:55.076 --> 00:52:56.926 A:middle
by default like NS errors.

00:52:57.476 --> 00:53:02.096 A:middle
And this means that if there's
an auto release pool wrapping

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:02.096 --> 00:53:04.536 A:middle
the assignment you can get
some interesting behavior,

00:53:04.886 --> 00:53:05.916 A:middle
namely crashes.

00:53:06.546 --> 00:53:13.326 A:middle
So in this case here we have an
auto release pool wrapping our

00:53:13.826 --> 00:53:15.056 A:middle
JSON use just like that.

00:53:15.326 --> 00:53:20.516 A:middle
We take that out error and we do
the assignment inside the kit.

00:53:20.516 --> 00:53:23.876 A:middle
So the assignment to that auto
releasing variable happens

00:53:24.146 --> 00:53:25.216 A:middle
inside our auto release pool.

00:53:25.646 --> 00:53:28.746 A:middle
The instant we leave our
auto release pool, well,

00:53:28.746 --> 00:53:31.626 A:middle
now that delayed release
happens immediately,

00:53:32.536 --> 00:53:35.416 A:middle
and now what we've done is we've
returned our deallocated NS

00:53:35.416 --> 00:53:37.986 A:middle
error to our caller
causing problems.

00:53:38.186 --> 00:53:39.486 A:middle
So the fix is simple.

00:53:39.806 --> 00:53:42.126 A:middle
If you write an auto
release pool write a local.

00:53:42.866 --> 00:53:44.996 A:middle
So in this case we just
need to write a local error,

00:53:45.986 --> 00:53:47.506 A:middle
send the local error
into the API,

00:53:47.506 --> 00:53:50.956 A:middle
and then do the auto
releasing assignment outside

00:53:51.386 --> 00:53:52.936 A:middle
of the auto release
pool that we wrote.

00:53:53.446 --> 00:54:00.026 A:middle
The final keyword I want to
talk about is bridge gaps.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:00.026 --> 00:54:03.386 A:middle
Now, ARC is great for
managing life cycles

00:54:03.386 --> 00:54:08.646 A:middle
at the Objective-C level, but in
most of our code we still have

00:54:08.646 --> 00:54:11.936 A:middle
to use C-based APIs like core
foundation, core graphics,

00:54:11.936 --> 00:54:15.106 A:middle
things that take
void star context.

00:54:15.106 --> 00:54:17.496 A:middle
And for dealing with
there are bridge gaps.

00:54:17.596 --> 00:54:19.006 A:middle
There's three conversion
primitives,

00:54:19.516 --> 00:54:22.796 A:middle
bridge with just this type
casting, bridge transfer

00:54:22.946 --> 00:54:25.656 A:middle
which does the release,
and if you like the syntax

00:54:25.656 --> 00:54:28.296 A:middle
of CF bridging release
better you can use that,

00:54:28.296 --> 00:54:29.926 A:middle
or bridge retain which
does a retain as well.

00:54:31.116 --> 00:54:34.046 A:middle
Although I should note here
that incorrect bridging

00:54:34.046 --> 00:54:38.146 A:middle
because it's very explicit
can lead to a crash or a leak.

00:54:39.096 --> 00:54:40.856 A:middle
So how do you use
them correctly?

00:54:40.856 --> 00:54:43.836 A:middle
Well, this is the standard
way of using these.

00:54:43.836 --> 00:54:47.466 A:middle
If you're going from CF+ 1
you use a bridge transfer,

00:54:47.656 --> 00:54:50.836 A:middle
and you really should think
about your references in terms

00:54:50.836 --> 00:54:53.026 A:middle
of where the ARC
managed object is.

00:54:53.776 --> 00:54:56.216 A:middle
But I specifically want
to call out the third cast

00:54:56.216 --> 00:54:57.426 A:middle
because this is the
most dangerous.

00:54:57.606 --> 00:55:02.656 A:middle
If you're casting from an ARC
managed reference to a void star

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:02.656 --> 00:55:03.546 A:middle
or a CF reference,

00:55:04.196 --> 00:55:07.316 A:middle
this effectively creates an
unsafe unretained CF reference.

00:55:07.646 --> 00:55:09.086 A:middle
So what do I mean?

00:55:09.596 --> 00:55:11.696 A:middle
Well, if I have this
in a string it's

00:55:11.696 --> 00:55:15.196 A:middle
in an ARC managed reference,
I use the bridge cast,

00:55:15.596 --> 00:55:17.146 A:middle
put it in a CF reference.

00:55:17.766 --> 00:55:21.206 A:middle
Well, now anywhere in between
here if, say, the log info goes

00:55:21.206 --> 00:55:24.176 A:middle
out of scope, I never use it
again, the compiler is free

00:55:24.176 --> 00:55:25.436 A:middle
to release that variable.

00:55:25.736 --> 00:55:29.256 A:middle
And now when I go to use it
in CFURL create, boom, right?

00:55:29.256 --> 00:55:33.696 A:middle
And now it's kind of a very
strange crash inside the kit.

00:55:33.976 --> 00:55:36.666 A:middle
So for that just switch
to the fourth one.

00:55:36.666 --> 00:55:40.406 A:middle
Use bridge retained, and just
remember to CF release it later.

00:55:41.366 --> 00:55:44.216 A:middle
So I want to briefly talk
about being a good citizen

00:55:44.666 --> 00:55:48.846 A:middle
on the platform and what sort
of testing you can do for this.

00:55:49.256 --> 00:55:51.356 A:middle
So test some real
world scenarios.

00:55:51.566 --> 00:55:53.846 A:middle
Definitely test on
constrained devices.

00:55:53.846 --> 00:55:57.466 A:middle
If you're on a MAC, low memory
systems, maybe low CPUs.

00:55:57.466 --> 00:56:00.976 A:middle
If you're on an iPhone this
is just older hardware.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:01.786 --> 00:56:04.556 A:middle
Test your first install
and first launch.

00:56:05.086 --> 00:56:05.746 A:middle
If you're having to build

00:56:05.746 --> 00:56:08.386 A:middle
up a database you may have
memory spikes in that case,

00:56:08.466 --> 00:56:10.316 A:middle
and these are really
good test cases.

00:56:11.006 --> 00:56:12.146 A:middle
As well as large data sets.

00:56:12.316 --> 00:56:15.976 A:middle
Everyone wants to have really
devoted and awesome users

00:56:16.046 --> 00:56:20.306 A:middle
who use your app for years,
and it's worth testing for them

00:56:20.636 --> 00:56:22.706 A:middle
that you can handle
these big things.

00:56:23.586 --> 00:56:26.676 A:middle
Also, test background
launch on iOS 7.

00:56:27.056 --> 00:56:30.626 A:middle
And to do that you can just use
the option in the launch options

00:56:31.366 --> 00:56:35.496 A:middle
to simulate a background
fetch and off you go.

00:56:35.556 --> 00:56:37.106 A:middle
And, finally, make
sure that you test

00:56:37.106 --> 00:56:38.596 A:middle
for leaks and abandoned memory.

00:56:39.396 --> 00:56:43.676 A:middle
So under system memory pressure
we've talked about this briefly,

00:56:43.676 --> 00:56:45.066 A:middle
and I'm not going to
touch on it very much.

00:56:45.096 --> 00:56:46.406 A:middle
But when pages have

00:56:46.446 --> 00:56:49.636 A:middle
to be evicted it really is
your dirty memory that matters.

00:56:49.746 --> 00:56:54.726 A:middle
And in this case on OS X these
are compressed or saved to disk.

00:56:55.026 --> 00:56:55.986 A:middle
See this talk right here

00:56:55.986 --> 00:56:58.016 A:middle
for more information,
it's really great.

00:56:58.766 --> 00:57:01.356 A:middle
And for iOS memory
warnings are issued

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:57:01.356 --> 00:57:02.836 A:middle
and processes have terminated.

00:57:03.656 --> 00:57:05.276 A:middle
So when it comes
to memory warnings

00:57:05.616 --> 00:57:07.436 A:middle
and how you can avoid
termination,

00:57:08.046 --> 00:57:09.376 A:middle
well, don't be the biggest.

00:57:09.606 --> 00:57:11.356 A:middle
Dirty memory really
is what counts.

00:57:11.396 --> 00:57:13.656 A:middle
You can use the VM Tracker to
find out how much you're using.

00:57:14.316 --> 00:57:16.276 A:middle
And make sure you get
a chance to respond.

00:57:16.616 --> 00:57:20.246 A:middle
You're not guaranteed a memory
warning, but if you get one,

00:57:20.816 --> 00:57:23.326 A:middle
and hopefully you will, it
will arrive on the main thread.

00:57:23.776 --> 00:57:25.956 A:middle
So make sure your main thread
isn't blocked for many reasons,

00:57:26.076 --> 00:57:27.176 A:middle
also user responsiveness.

00:57:27.626 --> 00:57:29.676 A:middle
And, of course, avoid
large and rapid allocations

00:57:29.676 --> 00:57:31.726 A:middle
so the system doesn't
have to act quickly.

00:57:32.936 --> 00:57:35.836 A:middle
So these are the three best ways

00:57:35.836 --> 00:57:37.966 A:middle
to respond using
the notifications

00:57:37.966 --> 00:57:40.736 A:middle
or the APIs that get called.

00:57:41.566 --> 00:57:43.276 A:middle
And you should consider freeing

00:57:43.276 --> 00:57:44.916 A:middle
up some memory before
you enter the background.

00:57:46.556 --> 00:57:48.636 A:middle
So there's the [inaudible]
for that.

00:57:48.636 --> 00:57:52.266 A:middle
So to summarize we really want

00:57:52.266 --> 00:57:53.446 A:middle
to encourage you
to be proactive.

00:57:53.446 --> 00:57:55.926 A:middle
Start with the gauges,
use Instruments,

00:57:55.966 --> 00:57:57.506 A:middle
monitor, test and investigate.

00:57:57.826 --> 00:57:59.706 A:middle
Definitely avoid memory spikes.

00:57:59.706 --> 00:58:01.996 A:middle
This will lead to fragmentation
of your application,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:58:02.336 --> 00:58:03.926 A:middle
and avoidance is
the best policy.

00:58:04.446 --> 00:58:07.836 A:middle
And definitely don't allow
unbounded memory growth,

00:58:07.836 --> 00:58:09.636 A:middle
you set generational analysis.

00:58:10.276 --> 00:58:12.476 A:middle
There are some great
language tools for you to use.

00:58:12.506 --> 00:58:15.346 A:middle
And I hope that you make
great effective use of them.

00:58:15.556 --> 00:58:19.006 A:middle
For more information contact
our developer tools evangelist,

00:58:19.006 --> 00:58:19.566 A:middle
Dave DeLong.

00:58:20.216 --> 00:58:22.266 A:middle
And the Apple developer
forums are great.

00:58:23.356 --> 00:58:24.476 A:middle
Here's some related sessions.

00:58:24.476 --> 00:58:26.096 A:middle
I just want to specifically call

00:58:26.486 --> 00:58:28.406 A:middle
out the Building
Efficient OS X apps

00:58:28.406 --> 00:58:31.626 A:middle
so you can get a deeper
understanding of virtual memory

00:58:31.626 --> 00:58:32.856 A:middle
and how that works
on the system.

00:58:33.426 --> 00:58:35.196 A:middle
So come see us.

00:58:35.316 --> 00:58:36.416 A:middle
We'd love to help you.

00:58:36.446 --> 00:58:37.956 A:middle
And thank you very
much for coming today.

00:58:38.016 --> 00:58:40.000 A:middle
[ Applause ]

