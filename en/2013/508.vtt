WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:09.566 A:middle
[ Applause ]

00:00:10.066 --> 00:00:10.296 A:middle
&gt;&gt; Welcome.

00:00:13.886 --> 00:00:15.826 A:middle
My name is Jim.

00:00:16.236 --> 00:00:18.746 A:middle
I'm an engineer on the
OpenCL team at Apple.

00:00:19.736 --> 00:00:21.896 A:middle
Our purpose with today's
session is threefold.

00:00:22.576 --> 00:00:24.966 A:middle
First, I'm going to talk to
the newbies in the audience,

00:00:25.016 --> 00:00:27.386 A:middle
those of you who have an
application, are wondering

00:00:27.386 --> 00:00:28.816 A:middle
about OpenCL, if
it's appropriate

00:00:28.816 --> 00:00:29.726 A:middle
for your application.

00:00:30.086 --> 00:00:31.506 A:middle
My goal is to give
you a checklist.

00:00:31.786 --> 00:00:33.896 A:middle
So if you answer the
questions on the checklist,

00:00:34.056 --> 00:00:35.816 A:middle
you'll have a good idea
of OpenCL is appropriate

00:00:35.816 --> 00:00:38.486 A:middle
for your application
and also how to use it.

00:00:39.546 --> 00:00:41.736 A:middle
Then my colleague, Abe,
is going to talk to you

00:00:41.736 --> 00:00:45.186 A:middle
about some best practices
and some performance tips

00:00:45.186 --> 00:00:47.186 A:middle
for using OpenCL in Mavericks.

00:00:47.286 --> 00:00:50.836 A:middle
And then last we have
Dave McGavran from Adobe,

00:00:50.836 --> 00:00:53.776 A:middle
and he's going to show you
how Adobe has used OpenCL

00:00:53.776 --> 00:00:57.046 A:middle
to accelerate portions of
the video processing pipeline

00:00:57.046 --> 00:00:59.406 A:middle
in Adobe Premiere, and he
has a really cool demo,

00:00:59.576 --> 00:01:01.346 A:middle
so stick around for that.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:03.316 --> 00:01:05.886 A:middle
So let's first talk about
where OpenCL is going to work.

00:01:06.476 --> 00:01:10.136 A:middle
When we launched CL in Snow
Leopard, you could use OpenCL

00:01:10.136 --> 00:01:13.646 A:middle
on the CPU on any Mac, but
if you wanted to use OpenCL

00:01:13.646 --> 00:01:16.826 A:middle
on the GPU, you were limited to
those machines we were shipping

00:01:16.826 --> 00:01:20.366 A:middle
that had certain discrete
GPUs, an AMD or NVIDIA GPU.

00:01:20.916 --> 00:01:22.206 A:middle
So what about Mavericks?

00:01:22.206 --> 00:01:23.766 A:middle
Well, now we're happy to say

00:01:23.766 --> 00:01:28.846 A:middle
that you can also use the
integrated GPUs from Intel,

00:01:28.846 --> 00:01:30.176 A:middle
starting with HD 4000.

00:01:31.196 --> 00:01:35.216 A:middle
So what that means for you guys
is that OpenCL is now supported

00:01:35.216 --> 00:01:38.936 A:middle
on the CPU and the GPU on all
shipping Macs, so that's great.

00:01:40.296 --> 00:01:42.106 A:middle
So let's get to this
checklist I was talking about.

00:01:42.736 --> 00:01:45.346 A:middle
Your first question you ask is
"am I waiting for something?"

00:01:46.006 --> 00:01:46.916 A:middle
So what do I mean by that?

00:01:46.916 --> 00:01:48.486 A:middle
I mean you start up
your application,

00:01:48.696 --> 00:01:50.576 A:middle
you click the Go button
to do something cool,

00:01:50.576 --> 00:01:52.956 A:middle
and there's a progress
bar, and you wait

00:01:53.306 --> 00:01:54.316 A:middle
and you wait and you wait.

00:01:54.316 --> 00:01:56.706 A:middle
Or maybe you have some cool
video processing program

00:01:57.156 --> 00:01:59.426 A:middle
and you want to render effects
on the frames in realtime

00:01:59.426 --> 00:02:01.786 A:middle
but once you kick on the
effects everything slows down,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:01.786 --> 00:02:02.346 A:middle
it's choppy.

00:02:02.796 --> 00:02:03.676 A:middle
That's what I'm talking about.

00:02:04.716 --> 00:02:06.906 A:middle
So, like any good
developer, what do you do?

00:02:06.906 --> 00:02:08.686 A:middle
You fire up Instruments
and take a look

00:02:08.686 --> 00:02:10.846 A:middle
at your application running, you
look at it with Time Profiler.

00:02:10.846 --> 00:02:13.996 A:middle
And that's going to let you
zero in and find the part

00:02:13.996 --> 00:02:15.796 A:middle
of the program and
causing you to slow down.

00:02:15.796 --> 00:02:18.296 A:middle
That's the piece I want you
to hold in your mind as we go

00:02:18.296 --> 00:02:18.976 A:middle
through this checklist.

00:02:20.346 --> 00:02:23.006 A:middle
But maybe the answer
to this question is no,

00:02:23.006 --> 00:02:25.306 A:middle
but maybe the reason
is you've avoided doing

00:02:25.386 --> 00:02:26.256 A:middle
something intensive.

00:02:27.106 --> 00:02:29.496 A:middle
So maybe there's this
really cool new algorithm

00:02:29.496 --> 00:02:30.606 A:middle
that you really wanted to put

00:02:30.606 --> 00:02:32.336 A:middle
into your application
but you were afraid.

00:02:32.376 --> 00:02:34.396 A:middle
You were afraid that
if you did that,

00:02:34.396 --> 00:02:36.606 A:middle
it's going to slow it down,
your users will hate you,

00:02:37.276 --> 00:02:40.566 A:middle
so you don't have to be afraid,
maybe OpenCL is the doorway

00:02:40.566 --> 00:02:42.366 A:middle
to this new algorithm
that you want to use.

00:02:43.226 --> 00:02:44.916 A:middle
So let's say you can
answer yes to either

00:02:44.916 --> 00:02:45.786 A:middle
of these two questions.

00:02:46.196 --> 00:02:49.196 A:middle
So then you want to ask yourself
about that piece of code,

00:02:49.196 --> 00:02:51.956 A:middle
about that code pathway, "do
I have a parallel workload?"

00:02:52.206 --> 00:02:54.146 A:middle
Now, a lot of you people
probably know what I mean

00:02:54.146 --> 00:02:55.276 A:middle
when I say a parallel workload,

00:02:56.006 --> 00:02:58.316 A:middle
but let's just make sure
everyone is on the same page

00:02:58.316 --> 00:03:00.586 A:middle
like we always do with
a really terrible haiku.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:02.036 --> 00:03:08.166 A:middle
Pieces of data, all changing in
the same way, few dependencies.

00:03:08.726 --> 00:03:11.296 A:middle
So you can count my syllables
and I'll go through these lines

00:03:11.296 --> 00:03:12.096 A:middle
and tell you what they mean.

00:03:12.336 --> 00:03:13.806 A:middle
Pieces of data is
pretty obvious.

00:03:14.256 --> 00:03:16.396 A:middle
Anytime you're going to do
computation you have data

00:03:16.396 --> 00:03:17.386 A:middle
that you need to process.

00:03:17.596 --> 00:03:19.796 A:middle
All changing in the same way
is a little bit more subtle.

00:03:20.196 --> 00:03:22.126 A:middle
That means that for each
piece of data, you're going

00:03:22.126 --> 00:03:24.616 A:middle
to apply the same
instructions, the same program

00:03:24.616 --> 00:03:25.456 A:middle
to each piece of data.

00:03:25.456 --> 00:03:28.246 A:middle
And few dependencies is
the worst one of all.

00:03:28.966 --> 00:03:31.736 A:middle
What that means is
that the results

00:03:31.736 --> 00:03:34.056 A:middle
of one computation
is not needed for any

00:03:34.056 --> 00:03:36.436 A:middle
of the other computations, or
while I'm doing my computation,

00:03:36.436 --> 00:03:37.876 A:middle
I don't need to know
what my neighbor did.

00:03:38.096 --> 00:03:38.956 A:middle
They're all independent.

00:03:39.396 --> 00:03:41.346 A:middle
So that's what we mean when
we say "a parallel workload."

00:03:42.666 --> 00:03:45.126 A:middle
So let's make this
concrete, image processing.

00:03:45.466 --> 00:03:46.366 A:middle
Canonical example.

00:03:46.656 --> 00:03:49.546 A:middle
You want to sepia tone this big
cat, so you're going to pluck

00:03:49.546 --> 00:03:51.596 A:middle
out a pixel, you're going
to throw it through the math

00:03:52.076 --> 00:03:53.656 A:middle
that changes it to sepia,
and then you're going

00:03:53.656 --> 00:03:54.996 A:middle
to plop it back into
the right spot.

00:03:55.576 --> 00:03:58.056 A:middle
Okay, that's a classical
example of a parallel workload,

00:03:58.056 --> 00:04:00.546 A:middle
and in fact core image
in Mavericks is running

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.606 --> 00:04:02.176 A:middle
on top of CL on the GPU.

00:04:03.346 --> 00:04:05.536 A:middle
But we don't want you
to think that CL is only

00:04:05.636 --> 00:04:07.366 A:middle
for graphics type stuff.

00:04:07.366 --> 00:04:09.496 A:middle
So, when we showed CL first

00:04:09.496 --> 00:04:12.106 A:middle
in 2009 we showed you this
really cool physics simulation.

00:04:12.756 --> 00:04:15.026 A:middle
Now, we showed you the
results using pretty graphics,

00:04:15.026 --> 00:04:17.995 A:middle
but the guts of what was
happening, the computation

00:04:17.995 --> 00:04:19.935 A:middle
that was moving the bodies
around in space according

00:04:19.935 --> 00:04:21.046 A:middle
to the physics calculations,

00:04:21.366 --> 00:04:23.556 A:middle
that's just arbitrary
computation, and we want you

00:04:23.556 --> 00:04:24.976 A:middle
to remember that when
thinking about CL.

00:04:24.976 --> 00:04:27.156 A:middle
CL is good for arbitrary
computation like this.

00:04:27.686 --> 00:04:29.896 A:middle
And in fact, an example
of a parallel workload

00:04:29.896 --> 00:04:32.146 A:middle
that you might not even consider
is grepping a large file.

00:04:32.566 --> 00:04:34.076 A:middle
Think about what you
do when you grep.

00:04:34.076 --> 00:04:36.526 A:middle
You open up this file, you
look at the file line by line

00:04:36.886 --> 00:04:38.656 A:middle
and you apply the same
regular expression

00:04:38.656 --> 00:04:39.626 A:middle
to each line of the file.

00:04:40.016 --> 00:04:41.356 A:middle
That's an example of a problem

00:04:41.356 --> 00:04:45.436 A:middle
that you might be able
to apply CL to solve.

00:04:45.436 --> 00:04:47.096 A:middle
So let's say you
look at your problem

00:04:47.236 --> 00:04:48.846 A:middle
and it's not exactly parallel.

00:04:49.456 --> 00:04:50.436 A:middle
So the question then becomes

00:04:50.436 --> 00:04:52.036 A:middle
"Can you earn a parallel
workload?",

00:04:52.036 --> 00:04:54.756 A:middle
and this is usually
the trickiest piece.

00:04:54.906 --> 00:04:56.326 A:middle
What I mean by "earn" is,

00:04:56.326 --> 00:04:59.196 A:middle
can you take your non-parallel
problem and twist it somehow

00:04:59.196 --> 00:05:01.416 A:middle
or change it so that
it becomes parallel?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:01.756 --> 00:05:03.786 A:middle
So let's look at an example
of a problem like that.

00:05:04.846 --> 00:05:06.796 A:middle
Consider computing a
histogram of an image.

00:05:07.546 --> 00:05:10.576 A:middle
So for the image you have
some RGBA image, 8-bit color,

00:05:10.576 --> 00:05:12.316 A:middle
and you have a histogram
for each color channel,

00:05:12.836 --> 00:05:15.256 A:middle
one bucket per possible
color value.

00:05:16.186 --> 00:05:17.976 A:middle
And what you do is you look
at the pixels in the image --

00:05:17.976 --> 00:05:19.106 A:middle
so let's just look
at one of them --

00:05:19.896 --> 00:05:22.576 A:middle
so we look at this guy and we
see he has a red value of 79,

00:05:22.676 --> 00:05:24.816 A:middle
green of 148, and blue of 186.

00:05:25.266 --> 00:05:28.166 A:middle
Fine. So we go to each
histogram, we find the bin

00:05:28.166 --> 00:05:30.216 A:middle
that we're supposed to increment
and we knock it up by 1.

00:05:30.266 --> 00:05:33.096 A:middle
So for example here we
would increment the 79 bin

00:05:33.096 --> 00:05:34.606 A:middle
for red, increment it by 1.

00:05:35.456 --> 00:05:37.456 A:middle
So, at the end of the day
you have this nice histogram

00:05:37.456 --> 00:05:38.996 A:middle
which gives you a
distribution of the color

00:05:38.996 --> 00:05:40.136 A:middle
as it's used in the image.

00:05:40.536 --> 00:05:42.576 A:middle
And you'll have a good idea
of how colors are being used,

00:05:42.576 --> 00:05:45.446 A:middle
and more importantly your
algorithm will have an idea

00:05:45.446 --> 00:05:46.676 A:middle
of how color is being used.

00:05:46.676 --> 00:05:48.436 A:middle
Image histogram is
an intermediate step

00:05:48.436 --> 00:05:49.926 A:middle
in a lot of cool algorithms.

00:05:51.136 --> 00:05:53.406 A:middle
So this feels like one of these
parallel problems I just talked

00:05:53.406 --> 00:05:54.646 A:middle
about, so what's the problem?

00:05:54.796 --> 00:05:56.586 A:middle
Why is this not parallel
to begin with?

00:05:56.586 --> 00:05:59.316 A:middle
Well, let's look at just
2 pixels in parallel,

00:05:59.476 --> 00:06:00.986 A:middle
so let's look at these two.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:01.536 --> 00:06:03.706 A:middle
Now, these two happen to have
the same blue channel value.

00:06:04.456 --> 00:06:05.716 A:middle
So what's going to happen?

00:06:06.416 --> 00:06:08.326 A:middle
They're both going to go to
that blue bin they map to,

00:06:08.496 --> 00:06:10.846 A:middle
let's say the value
in there is 35 --

00:06:10.886 --> 00:06:14.026 A:middle
they're both going to read out
35, increment it by 1 to 36,

00:06:14.096 --> 00:06:15.346 A:middle
and try to write it back.

00:06:15.716 --> 00:06:16.766 A:middle
So that's a problem.

00:06:16.766 --> 00:06:18.306 A:middle
You have a classic collision.

00:06:18.306 --> 00:06:20.556 A:middle
You're going to have the
incorrect value in that slot.

00:06:20.556 --> 00:06:23.076 A:middle
So what do we do when we
hit a problem like this?

00:06:23.706 --> 00:06:26.946 A:middle
Well, normally you synchronize
around that code, you would make

00:06:26.946 --> 00:06:28.176 A:middle
that an atomic operation.

00:06:28.176 --> 00:06:30.746 A:middle
You've taken some problem
that seems very parallel

00:06:30.746 --> 00:06:32.426 A:middle
but there's this
serial bit of it

00:06:32.566 --> 00:06:34.026 A:middle
that just really ruins your day.

00:06:34.836 --> 00:06:35.936 A:middle
So now we have to get clever.

00:06:35.936 --> 00:06:38.716 A:middle
So what we can do instead
is we break the image

00:06:38.716 --> 00:06:39.956 A:middle
into groups of pixels.

00:06:40.296 --> 00:06:41.726 A:middle
So let's take a look
at one group.

00:06:42.226 --> 00:06:42.926 A:middle
Let's look at that one.

00:06:44.086 --> 00:06:46.226 A:middle
So what we're going to do in
this group is the same thing

00:06:46.226 --> 00:06:47.726 A:middle
that we were going to
do to the whole image.

00:06:47.836 --> 00:06:49.466 A:middle
We're still going to
compute a histogram

00:06:49.466 --> 00:06:50.516 A:middle
for that group of pixels.

00:06:51.156 --> 00:06:52.736 A:middle
But instead of a
global histogram,

00:06:52.736 --> 00:06:54.506 A:middle
we're going to update
only a partial histogram.

00:06:54.936 --> 00:06:57.326 A:middle
So this group's going to
have its own histogram

00:06:57.366 --> 00:06:58.896 A:middle
for each color channel,
and it's only going

00:06:58.896 --> 00:07:00.116 A:middle
to update that histogram.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:00.616 --> 00:07:03.426 A:middle
And all the groups, each group
has its own partial histogram.

00:07:04.006 --> 00:07:06.676 A:middle
So the thing is, these
collisions that I talked

00:07:06.676 --> 00:07:08.296 A:middle
about for the whole
image, they still exist

00:07:08.296 --> 00:07:11.076 A:middle
for the partial histograms,
but only within this group.

00:07:11.076 --> 00:07:13.666 A:middle
And OpenCL has a lot
of language facilities

00:07:13.846 --> 00:07:16.686 A:middle
that expose underlying
hardware that let you deal

00:07:16.686 --> 00:07:19.306 A:middle
with these collisions
within a group very quickly.

00:07:20.116 --> 00:07:23.536 A:middle
So we also get a win, because
all these groups can operate

00:07:23.536 --> 00:07:26.286 A:middle
in parallel, so we've taken this
and we've made this parallel.

00:07:26.816 --> 00:07:27.756 A:middle
Okay, so we're done, right.

00:07:27.756 --> 00:07:30.786 A:middle
Well, not yet, because
now we kind

00:07:30.786 --> 00:07:31.836 A:middle
of have what we don't
really want.

00:07:31.836 --> 00:07:34.636 A:middle
We have this big pile
of partial histograms.

00:07:34.636 --> 00:07:37.246 A:middle
What we wanted was
one total histogram.

00:07:38.076 --> 00:07:41.046 A:middle
So now we have a second step,
a new step to the algorithm.

00:07:41.046 --> 00:07:42.476 A:middle
This time our data
is not the image.

00:07:42.476 --> 00:07:44.656 A:middle
Forget about the image; it's
this partial histogram set.

00:07:45.396 --> 00:07:47.746 A:middle
And now each independent
thread of execution --

00:07:47.746 --> 00:07:50.526 A:middle
which in OpenCL is called a
work item -- they have a job.

00:07:50.526 --> 00:07:52.916 A:middle
This guy's job is
to sum up bin 79.

00:07:53.506 --> 00:07:54.606 A:middle
So what will he do?

00:07:54.606 --> 00:07:56.776 A:middle
He walks down through all
the partial histograms,

00:07:56.856 --> 00:07:59.246 A:middle
summing up bin 79, and
he writes the result

00:07:59.246 --> 00:08:00.236 A:middle
in that total histogram.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.686 --> 00:08:03.096 A:middle
Now, he's the only one
writing to that slot,

00:08:03.166 --> 00:08:05.346 A:middle
so there's no more collisions
in the total histogram.

00:08:06.316 --> 00:08:08.606 A:middle
So what we've done here is
we've taken this problem,

00:08:08.606 --> 00:08:10.146 A:middle
this image histogram problem,

00:08:10.146 --> 00:08:13.026 A:middle
we've twisted it just a little
bit and made it purely parallel.

00:08:13.026 --> 00:08:15.146 A:middle
And the cool thing is,

00:08:15.146 --> 00:08:17.086 A:middle
we do this for all the
partial histograms,

00:08:17.606 --> 00:08:19.306 A:middle
all threads operating
all together,

00:08:19.306 --> 00:08:20.786 A:middle
all these work items
in parallel.

00:08:21.306 --> 00:08:26.846 A:middle
So if you can answer
yes to either

00:08:26.846 --> 00:08:28.986 A:middle
of these first two
questions and yes to either

00:08:28.986 --> 00:08:31.516 A:middle
of the second two questions,
then you have a problem

00:08:31.516 --> 00:08:33.576 A:middle
that is probably
appropriate for OpenCL.

00:08:34.395 --> 00:08:34.946 A:middle
That's good.

00:08:34.946 --> 00:08:37.346 A:middle
So now the question is "do I
run it on the CPU or the GPU?"

00:08:37.346 --> 00:08:39.826 A:middle
You've probably heard that you
can run it in either place.

00:08:41.535 --> 00:08:43.006 A:middle
This breaks down
to three questions.

00:08:43.116 --> 00:08:46.166 A:middle
Where is my data now,
where is my data destined,

00:08:46.296 --> 00:08:47.896 A:middle
and by that I mean
destined to be used,

00:08:48.456 --> 00:08:51.136 A:middle
and how hard am I working
on each piece of data?

00:08:52.386 --> 00:08:54.006 A:middle
So let's look at some data.

00:08:54.006 --> 00:08:56.116 A:middle
Now, this happens to be image
data, but again, remember,

00:08:56.116 --> 00:08:58.356 A:middle
arbitrary computations,
just some data on the host,

00:08:58.356 --> 00:09:01.236 A:middle
and by host I just mean your
CPU, in its memory space,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:01.236 --> 00:09:03.286 A:middle
memory that you get
through malloc, for example.

00:09:04.856 --> 00:09:07.186 A:middle
Okay, so when you do
computation on this data,

00:09:07.186 --> 00:09:08.286 A:middle
you process it somehow.

00:09:08.286 --> 00:09:10.716 A:middle
The computation is
exemplified by this green arrow.

00:09:11.206 --> 00:09:13.396 A:middle
If you were to measure
the total time you spent,

00:09:13.396 --> 00:09:15.746 A:middle
it's going to be the total time
you spent doing the compute.

00:09:16.026 --> 00:09:17.386 A:middle
This is a normal situation;

00:09:17.386 --> 00:09:19.076 A:middle
now let's bring OpenCL
into the picture.

00:09:20.256 --> 00:09:22.316 A:middle
When you're doing compute
with an OpenCL device,

00:09:22.316 --> 00:09:24.636 A:middle
OpenCL has to be able to see
that memory you want to work on.

00:09:25.316 --> 00:09:27.916 A:middle
So normally you have to sort of
"transfer" it over to OpenCL,

00:09:27.916 --> 00:09:29.436 A:middle
and we'll define that
transfer in a second.

00:09:30.076 --> 00:09:31.676 A:middle
Then you can do your
compute in OpenCL,

00:09:32.366 --> 00:09:34.466 A:middle
and then if your host
wants to use that memory,

00:09:34.466 --> 00:09:35.786 A:middle
it has to be able
to see that memory.

00:09:36.256 --> 00:09:38.396 A:middle
So then you have to give
that memory back to the host.

00:09:39.346 --> 00:09:41.246 A:middle
So now when we're talking
about the total time,

00:09:42.026 --> 00:09:44.156 A:middle
it's not just your compute
time, hopefully faster,

00:09:44.786 --> 00:09:46.156 A:middle
it's also this transfer time.

00:09:46.296 --> 00:09:49.366 A:middle
So let's talk about that, this
transfer time, what is that?

00:09:49.366 --> 00:09:51.286 A:middle
It depends on your device.

00:09:51.526 --> 00:09:54.616 A:middle
If you're on a discrete GPU,
that's a function of the amount

00:09:54.616 --> 00:09:58.286 A:middle
of data you want to send and
your bus speed, the PCIe bus.

00:09:58.996 --> 00:10:01.586 A:middle
That makes sense, got to
get it over to the VRAM,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:01.586 --> 00:10:02.566 A:middle
get it over to the device.

00:10:03.946 --> 00:10:06.106 A:middle
But if you're working on the
CPU as your OpenCL device,

00:10:06.196 --> 00:10:08.656 A:middle
this transfer time is
nothing, because the host

00:10:08.656 --> 00:10:11.256 A:middle
and the OpenCL device share
the same memory space.

00:10:11.586 --> 00:10:14.706 A:middle
And if you're on
the integrated GPU,

00:10:14.976 --> 00:10:16.606 A:middle
sometimes this is also nothing.

00:10:16.756 --> 00:10:18.656 A:middle
Now, that's a maybe
because this is only true

00:10:18.656 --> 00:10:20.076 A:middle
if you're using OpenCL buffers.

00:10:20.536 --> 00:10:23.166 A:middle
If you're using images, a
copy still has to be made,

00:10:23.166 --> 00:10:25.696 A:middle
because the integrated GPU will
set up that image data in a way

00:10:25.696 --> 00:10:28.846 A:middle
that takes advantage of
texture caches, stuff like that.

00:10:29.736 --> 00:10:32.456 A:middle
So now you have an idea of
what that transfer cost is.

00:10:32.896 --> 00:10:33.736 A:middle
Now, what about the compute --

00:10:33.736 --> 00:10:35.706 A:middle
now this might go without
saying, but if you're working

00:10:35.706 --> 00:10:36.916 A:middle
on a problem like I described,

00:10:36.916 --> 00:10:38.276 A:middle
one of these data
parallel problems,

00:10:39.016 --> 00:10:41.336 A:middle
the OpenCL device is
going to beat the code

00:10:41.336 --> 00:10:42.936 A:middle
that you're writing on the host.

00:10:42.936 --> 00:10:45.386 A:middle
So let's just get that out there
right now, so for these kind

00:10:45.386 --> 00:10:46.906 A:middle
of problems, OpenCL
is going to win.

00:10:48.006 --> 00:10:51.156 A:middle
So let's look at a problem like
this, where you're doing a lot

00:10:51.156 --> 00:10:53.446 A:middle
of computation relative
to the amount

00:10:53.446 --> 00:10:55.786 A:middle
of data transfer you're doing.

00:10:55.786 --> 00:10:57.556 A:middle
Lot of compute versus
data transfer.

00:10:57.746 --> 00:11:02.056 A:middle
In this case this is an ideal
scenario for the discrete GPU.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:02.606 --> 00:11:05.336 A:middle
This is where you want
to use the discrete GPU,

00:11:05.336 --> 00:11:07.726 A:middle
because this transfer
cost that you incur

00:11:07.726 --> 00:11:10.156 A:middle
by using the discrete GPU
is dwarfed by the amount

00:11:10.156 --> 00:11:11.496 A:middle
of win you get for the compute.

00:11:12.556 --> 00:11:14.296 A:middle
Now, what about a
situation like this.

00:11:14.296 --> 00:11:15.696 A:middle
Here you're doing
a lot of transfer

00:11:15.696 --> 00:11:17.326 A:middle
and not so much compute.

00:11:17.326 --> 00:11:19.496 A:middle
You're spending too much
time doing transfer.

00:11:20.276 --> 00:11:21.196 A:middle
In this case you might want

00:11:21.196 --> 00:11:24.106 A:middle
to consider it using the
OpenCL CPU device or staying

00:11:24.106 --> 00:11:27.516 A:middle
on the integrated GPU, and then
that transfer cost may go away.

00:11:29.176 --> 00:11:32.046 A:middle
Now, remember, I talked about
the question of where is my data

00:11:32.046 --> 00:11:34.026 A:middle
at now and where is
it destined to be.

00:11:34.516 --> 00:11:37.786 A:middle
Well, let's imagine that you're
using an OpenCL device, the GPU,

00:11:37.786 --> 00:11:39.906 A:middle
that it happens to also
be the display device.

00:11:40.406 --> 00:11:43.536 A:middle
You might be sharing data with
say, OpenGL, like Chris talked

00:11:43.536 --> 00:11:47.016 A:middle
about in the previous session
or IOSurface, like this.

00:11:47.016 --> 00:11:49.926 A:middle
This data is the same and
it's already on the GPU.

00:11:51.056 --> 00:11:53.386 A:middle
Likewise, you might be doing
some computation then using the

00:11:53.386 --> 00:11:56.066 A:middle
result of that to be displayed
to the user, for example; again,

00:11:56.396 --> 00:11:57.676 A:middle
shared through GL or shared

00:11:57.676 --> 00:11:59.896 A:middle
through IOSurface,
or you may have both.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:00.316 --> 00:12:02.246 A:middle
In this case, it's
kind of obvious:

00:12:02.316 --> 00:12:04.206 A:middle
stay on the GPU and
do your compute.

00:12:04.206 --> 00:12:05.046 A:middle
Your data's already there,

00:12:05.046 --> 00:12:06.926 A:middle
it's going to be used
there, just stay there.

00:12:06.926 --> 00:12:10.426 A:middle
Even in a situation like this,
where your data is starting

00:12:10.426 --> 00:12:14.276 A:middle
on the host and then is going
to be displayed to the user

00:12:14.276 --> 00:12:18.426 A:middle
on the GPU after processing,
it makes sense even

00:12:18.426 --> 00:12:20.236 A:middle
if the transfer cost might
be a little bit high,

00:12:20.656 --> 00:12:21.976 A:middle
to go to the CL device --

00:12:22.436 --> 00:12:25.596 A:middle
that's the same as the display
device -- do your compute there,

00:12:25.656 --> 00:12:28.006 A:middle
because that leaves your host
free to do other computation.

00:12:28.536 --> 00:12:32.556 A:middle
So let's just talk a bit,
for those of you who weren't

00:12:32.556 --> 00:12:34.576 A:middle
in the previous session,
about the kind of data

00:12:34.576 --> 00:12:35.456 A:middle
that might be on the device.

00:12:35.456 --> 00:12:37.476 A:middle
We said we can share
with GL or IOSurface,

00:12:37.476 --> 00:12:38.446 A:middle
so let's talk about GL.

00:12:38.946 --> 00:12:41.156 A:middle
Now, GL has a lot of
different that it can have.

00:12:41.196 --> 00:12:43.616 A:middle
As an example, it can have
vertex buffer objects,

00:12:43.616 --> 00:12:45.526 A:middle
it can have textures,
and you use those

00:12:45.526 --> 00:12:46.666 A:middle
and you render some
cool picture.

00:12:46.996 --> 00:12:49.096 A:middle
Now, that picture might
be a texture attachment

00:12:49.096 --> 00:12:51.956 A:middle
or a render buffer
attachment to an FBO.

00:12:52.376 --> 00:12:55.026 A:middle
Great. And along the way
you can hit that in OpenGL

00:12:55.026 --> 00:12:56.956 A:middle
with some cool shaders to
produce some nice effects.

00:12:57.736 --> 00:12:59.196 A:middle
So where does CL fit
into this picture?

00:12:59.826 --> 00:13:02.996 A:middle
Well, typically you would
share something like the VBO

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:03.246 --> 00:13:05.126 A:middle
as a CL mem object,
as a CL buffer.

00:13:05.846 --> 00:13:08.476 A:middle
And likewise, you
would share textures

00:13:08.476 --> 00:13:10.716 A:middle
or render buffer
attachments with OpenCL

00:13:10.716 --> 00:13:12.006 A:middle
as an image memory object.

00:13:12.006 --> 00:13:15.546 A:middle
And where it fits into the
pipeline is right here.

00:13:15.546 --> 00:13:20.646 A:middle
You're going to use a CL to
modify or generate vertex data

00:13:20.766 --> 00:13:24.086 A:middle
in that VBO, and then you might
want to do some post processing

00:13:24.186 --> 00:13:26.066 A:middle
in CL after you're done
with your other GL pipeline,

00:13:26.206 --> 00:13:26.916 A:middle
and you might want to do

00:13:26.916 --> 00:13:29.356 A:middle
that because you can maybe
express things more cleanly

00:13:29.356 --> 00:13:32.366 A:middle
in the OpenCL programming
language than you could in say,

00:13:32.366 --> 00:13:36.126 A:middle
a GLSL shader, or you might
want to launch your CL kernel

00:13:36.126 --> 00:13:39.256 A:middle
over a smaller domain than
what GLSL will let you do.

00:13:40.166 --> 00:13:41.846 A:middle
Now I do want to say
one thing to the people

00:13:41.846 --> 00:13:43.656 A:middle
who are already using
CLGL sharing.

00:13:44.286 --> 00:13:48.086 A:middle
So previously in 2011 we
told you that the sort

00:13:48.086 --> 00:13:50.646 A:middle
of paradigm you should follow
when using shared objects in CL

00:13:50.646 --> 00:13:53.636 A:middle
from GL is flush, acquire,
compute, release --

00:13:53.916 --> 00:13:56.336 A:middle
you're going to finish with your
GL commands and call glFlush,

00:13:56.636 --> 00:13:59.906 A:middle
and then you're going to
clEnqueueAcquireGLPObjects,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:00.166 --> 00:14:02.656 A:middle
do your compute, wail on it
with CL, whatever you want,

00:14:02.956 --> 00:14:05.026 A:middle
and then call
clEnqueueReleaseGLObjects.

00:14:05.366 --> 00:14:08.606 A:middle
And within that function call
we internally will call clFlush

00:14:08.606 --> 00:14:10.716 A:middle
for you to make sure
your CL commands made it

00:14:10.716 --> 00:14:15.366 A:middle
down to the GPU before
GL would go do more work

00:14:15.366 --> 00:14:16.096 A:middle
with those objects.

00:14:16.836 --> 00:14:17.736 A:middle
That has changed.

00:14:17.896 --> 00:14:19.966 A:middle
In Mavericks we want you
to follow something else.

00:14:20.026 --> 00:14:22.826 A:middle
You notice that "acquire" has
disappeared from the list.

00:14:23.236 --> 00:14:25.166 A:middle
Flush, compute, flush,
or maybe "Flush

00:14:25.166 --> 00:14:26.856 A:middle
when you're done,"
something like that.

00:14:27.056 --> 00:14:29.686 A:middle
So first you're going to
call glFlushRenderAPPLE,

00:14:29.796 --> 00:14:32.206 A:middle
and then you're going
to do your compute,

00:14:32.316 --> 00:14:33.896 A:middle
and then you're going
to call clFlush.

00:14:33.996 --> 00:14:34.656 A:middle
Now, you call that.

00:14:34.656 --> 00:14:35.676 A:middle
Before, we did that for you.

00:14:36.236 --> 00:14:39.216 A:middle
And notice this is
glFlushRenderAPPLE, so why that?

00:14:39.216 --> 00:14:41.266 A:middle
Well, for single-buffered
contexts,

00:14:41.576 --> 00:14:42.906 A:middle
this allows you to avoid a blit.

00:14:42.906 --> 00:14:45.206 A:middle
If you have a double-buffered
context, this doesn't matter.

00:14:45.206 --> 00:14:46.396 A:middle
It's the same as glFlush.

00:14:46.586 --> 00:14:48.656 A:middle
There's no penalty to
using it so just use it.

00:14:49.146 --> 00:14:53.626 A:middle
And then I mentioned IOSurface
is another way you might be

00:14:53.626 --> 00:14:54.366 A:middle
sharing with CL.

00:14:54.756 --> 00:14:58.686 A:middle
So if Mac OS X technologies
are Tolkienian creatures,

00:14:59.046 --> 00:15:00.316 A:middle
IOSurface would be Gandalf.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:01.096 --> 00:15:05.426 A:middle
It's a container for 2D image
data, and it's really magical

00:15:05.426 --> 00:15:08.026 A:middle
in that you can set up an
IOSurface in one process

00:15:08.476 --> 00:15:10.516 A:middle
and then just using the
IOSurface handle you can use it

00:15:10.516 --> 00:15:13.366 A:middle
in another process,
through the IOSurface API,

00:15:13.366 --> 00:15:15.496 A:middle
and that process might be 64-bit

00:15:15.496 --> 00:15:17.126 A:middle
where the other process
is 32-bit.

00:15:17.416 --> 00:15:19.956 A:middle
And more, that process might
be sharing the IOSurface

00:15:19.956 --> 00:15:23.116 A:middle
with OpenGL, which is hammering
on this data on the GPU.

00:15:23.376 --> 00:15:26.256 A:middle
And we make sure, under the
covers, that this data is always

00:15:26.256 --> 00:15:27.536 A:middle
in the right place
at the right time

00:15:27.536 --> 00:15:29.506 A:middle
and you have the consistent,
correct view of the data.

00:15:29.676 --> 00:15:31.436 A:middle
So it's really cool,
especially for those

00:15:31.436 --> 00:15:32.596 A:middle
of you working on video.

00:15:32.936 --> 00:15:36.016 A:middle
You can get your video frames
as IOSurfaces fairly easily

00:15:36.016 --> 00:15:39.476 A:middle
and then share those with CL
or GL and do some cool things

00:15:39.476 --> 00:15:40.586 A:middle
to them, so please do that.

00:15:41.746 --> 00:15:45.006 A:middle
Now, we talked about IOSurface
sharing in detail in 2011.

00:15:45.006 --> 00:15:47.156 A:middle
I talked about that in the
talk, "What's New in OpenCL,"

00:15:47.156 --> 00:15:49.716 A:middle
so if you want to learn more
details, go listen to that talk.

00:15:49.716 --> 00:15:51.336 A:middle
It's on the developer website.

00:15:51.956 --> 00:15:55.316 A:middle
And also, Ken Dyke had an
excellent talk in 2010 called

00:15:55.316 --> 00:15:57.326 A:middle
"Taking Advantage of
Multiple GPUs" where he talks

00:15:57.326 --> 00:15:58.576 A:middle
about IOSurface in some detail.

00:15:59.186 --> 00:16:01.956 A:middle
So that brings us back
to this checklist.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:02.206 --> 00:16:04.256 A:middle
So those of you who walked
in here and had no idea

00:16:04.306 --> 00:16:07.176 A:middle
if CL was appropriate for you,
you should have a better idea,

00:16:07.176 --> 00:16:08.666 A:middle
but if not, come talk
to us in the lab.

00:16:08.666 --> 00:16:10.716 A:middle
It's right after the
session; we'll be there.

00:16:11.796 --> 00:16:12.576 A:middle
I do want to say something

00:16:12.576 --> 00:16:14.706 A:middle
about the OpenCL programming
model, though, before I go.

00:16:15.626 --> 00:16:17.456 A:middle
So if you look at
the OpenCL spec,

00:16:17.456 --> 00:16:18.956 A:middle
you'll see that it's 400 pages.

00:16:19.336 --> 00:16:22.286 A:middle
And even the OpenCL Programming
Guide, which is a good book,

00:16:22.286 --> 00:16:25.236 A:middle
a gentler introduction, it's
not exactly a lightweight tome.

00:16:25.796 --> 00:16:28.306 A:middle
But I'm going to give you an
easy way to think about OpenCL.

00:16:29.226 --> 00:16:30.626 A:middle
It breaks down into two pieces.

00:16:30.926 --> 00:16:33.526 A:middle
It's a C-like programming
language and a runtime API,

00:16:33.766 --> 00:16:35.456 A:middle
so let's talk about
the language first.

00:16:36.086 --> 00:16:39.506 A:middle
We say "C-like" because it's
basically C with some new types,

00:16:40.036 --> 00:16:41.826 A:middle
and has some nice
built-in functions

00:16:41.826 --> 00:16:42.726 A:middle
to make your life easier.

00:16:43.606 --> 00:16:45.696 A:middle
And you describe your work

00:16:45.696 --> 00:16:47.186 A:middle
from the perspective
of one piece of data.

00:16:47.186 --> 00:16:49.036 A:middle
Remember, we talked
about in the haiku,

00:16:49.286 --> 00:16:50.516 A:middle
"all changing in the same way."

00:16:50.816 --> 00:16:52.766 A:middle
That's what you do in
your OpenCL kernel,

00:16:52.766 --> 00:16:54.866 A:middle
which what you write with the
OpenCL programming language.

00:16:55.626 --> 00:16:58.386 A:middle
You do this all the time,
every day when you write code.

00:16:58.386 --> 00:17:00.266 A:middle
You write a loop, and
in your loop you say

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.336 --> 00:17:02.116 A:middle
"For My data, do this thing."

00:17:02.206 --> 00:17:03.956 A:middle
Well, "this thing,"
that's your OpenCL kernel.

00:17:04.705 --> 00:17:05.636 A:middle
Let's look at an example.

00:17:06.116 --> 00:17:07.036 A:middle
Here's a bunch of C code.

00:17:07.356 --> 00:17:09.955 A:middle
Let's go through it bit by bit.

00:17:09.955 --> 00:17:11.955 A:middle
So first, what are we doing?

00:17:11.955 --> 00:17:15.386 A:middle
We're converting a big
image from RGB to HSV.

00:17:16.415 --> 00:17:17.925 A:middle
So first we're going
to loop over the data.

00:17:18.026 --> 00:17:19.886 A:middle
That's what we have to
do, a pixel at a time.

00:17:20.516 --> 00:17:22.786 A:middle
Once we're inside the
loop what pixel do I do?

00:17:22.876 --> 00:17:24.626 A:middle
Oh, I'll use the
loop indices to find

00:17:24.626 --> 00:17:26.326 A:middle
out what pixel I
should modify, great.

00:17:26.925 --> 00:17:29.066 A:middle
I grab that pixel, I
shift out the color values

00:17:29.066 --> 00:17:32.116 A:middle
because it's stored in one
integer, and then I convert

00:17:32.116 --> 00:17:33.546 A:middle
that to floating
point because my RGB

00:17:33.606 --> 00:17:36.526 A:middle
to HSV conversion function,
which I'm going to show you

00:17:36.526 --> 00:17:38.556 A:middle
in a second, expects float.

00:17:38.626 --> 00:17:40.536 A:middle
Fine. I call that function

00:17:40.656 --> 00:17:42.416 A:middle
and I write back the
result to my output image.

00:17:43.116 --> 00:17:43.796 A:middle
Seems easy.

00:17:44.206 --> 00:17:46.396 A:middle
And let's take a look at
this RGB to HSV function.

00:17:46.456 --> 00:17:49.206 A:middle
You don't have to know what's
going on here, I just want you

00:17:49.206 --> 00:17:50.606 A:middle
to notice it's a
simple function,

00:17:51.036 --> 00:17:54.036 A:middle
takes in some parameters,
RGB, and writes out HSV,

00:17:54.236 --> 00:17:55.206 A:middle
according to the algorithm

00:17:55.206 --> 00:17:56.576 A:middle
for the algorithm
for converting this.

00:17:57.566 --> 00:17:59.406 A:middle
So let's turn this
into an OpenCL kernel.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:00.516 --> 00:18:04.716 A:middle
Now, remember, an OpenCL kernel
is launched over some domain.

00:18:04.806 --> 00:18:07.176 A:middle
In this case we've
launched our kernel

00:18:07.176 --> 00:18:10.136 A:middle
over a 2-dimensional domain
that corresponds exactly

00:18:10.176 --> 00:18:12.046 A:middle
to the number of pixels
in the X and Y dimension.

00:18:12.046 --> 00:18:15.446 A:middle
So this kernel will run for
each pixel of the image.

00:18:16.576 --> 00:18:18.056 A:middle
And you can see here
that every instance

00:18:18.056 --> 00:18:19.696 A:middle
of the kernel that's running
is going to have access

00:18:19.696 --> 00:18:21.026 A:middle
to that input and output image.

00:18:22.406 --> 00:18:24.196 A:middle
So how do we find out
what pixel to work on?

00:18:24.196 --> 00:18:26.156 A:middle
Well, here we call some
OpenCL built-in functions,

00:18:26.156 --> 00:18:28.566 A:middle
getglobalid(0) and
getglobalid(1).

00:18:28.566 --> 00:18:31.556 A:middle
That gives us the global ID in
the first and second dimensions.

00:18:31.976 --> 00:18:33.426 A:middle
This happens to correspond
to X and Y.

00:18:34.396 --> 00:18:36.476 A:middle
So then we use another
OpenCL built-in, readimagef.

00:18:36.476 --> 00:18:40.276 A:middle
And that will tap the input
image at that coordinate

00:18:40.276 --> 00:18:42.266 A:middle
and give us back 4
channel float data.

00:18:42.566 --> 00:18:44.746 A:middle
Now, notice, this
doesn't know anything

00:18:44.746 --> 00:18:46.216 A:middle
about the underlying
image format.

00:18:46.406 --> 00:18:48.296 A:middle
That's one nice thing about
using an OpenCL kernel.

00:18:48.446 --> 00:18:51.156 A:middle
You can swap out image
formats and OpenCL,

00:18:51.156 --> 00:18:52.666 A:middle
the kernel will still do
the right thing for you.

00:18:52.806 --> 00:18:55.606 A:middle
And then you're going to
call the conversion function

00:18:55.606 --> 00:18:58.106 A:middle
like before, and you're going
to use another built-in,

00:18:58.106 --> 00:18:59.266 A:middle
writeimagef, to write
the output.

00:18:59.266 --> 00:19:01.036 A:middle
So let's dive into
the kernel version

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:01.036 --> 00:19:01.966 A:middle
of this conversion function.

00:19:02.886 --> 00:19:04.126 A:middle
So here it is.

00:19:04.176 --> 00:19:05.806 A:middle
Now you probably don't
have a photographic memory,

00:19:06.106 --> 00:19:08.406 A:middle
but it looks a lot like
the previous version.

00:19:08.546 --> 00:19:09.866 A:middle
I do want to call out one thing.

00:19:10.356 --> 00:19:12.146 A:middle
You can see here that we
only have one parameter.

00:19:12.146 --> 00:19:13.446 A:middle
We're taking the input pixel

00:19:13.446 --> 00:19:15.596 A:middle
and then returning a
float4 output pixel.

00:19:16.366 --> 00:19:19.506 A:middle
But otherwise, this looks a
lot like the previous function,

00:19:19.506 --> 00:19:21.526 A:middle
so let's just bounce back
and forth between them here.

00:19:21.856 --> 00:19:24.796 A:middle
So here's the CL version
and that's the C version.

00:19:25.236 --> 00:19:27.506 A:middle
So CL, C.

00:19:28.316 --> 00:19:29.806 A:middle
So you can go back
afterwards and see

00:19:29.806 --> 00:19:32.156 A:middle
that they're almost identical,
so it really is just the guts

00:19:32.156 --> 00:19:34.106 A:middle
of the loop that
we've extracted out.

00:19:34.106 --> 00:19:37.336 A:middle
That's not always that easy, but
usually this is where you start

00:19:37.336 --> 00:19:39.936 A:middle
when you're writing
your CL kernel.

00:19:40.056 --> 00:19:41.806 A:middle
So let's talk for a second
about the runtime API.

00:19:42.496 --> 00:19:44.676 A:middle
Now, if you look at the OpenCL
API there's a lot of functions

00:19:44.676 --> 00:19:47.546 A:middle
in there, but really they break
down into three categories,

00:19:47.546 --> 00:19:50.446 A:middle
I'd say, discovery,
setup, and execution.

00:19:51.216 --> 00:19:51.936 A:middle
Discovery.

00:19:52.056 --> 00:19:55.446 A:middle
That lets you ask, "hey,
OpenCL, what devices are there

00:19:55.446 --> 00:19:56.836 A:middle
on my Mac for doing compute?"

00:19:56.836 --> 00:19:57.406 A:middle
Straightforward.

00:19:57.406 --> 00:20:00.216 A:middle
And then more interestingly,
"hey, given this device,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.356 --> 00:20:02.066 A:middle
what's the best way
to break up my work?"

00:20:02.676 --> 00:20:05.576 A:middle
And that's because your
integrated GPU and your CPU

00:20:05.576 --> 00:20:07.696 A:middle
and your discrete GPU, they
all have different parallel

00:20:07.696 --> 00:20:11.146 A:middle
capabilities, so you would
use the answers from this part

00:20:11.146 --> 00:20:14.326 A:middle
of the API to decide how to
break up your work the best.

00:20:14.516 --> 00:20:17.126 A:middle
Setup. "Hey OpenCL,
I have this kernel,

00:20:17.126 --> 00:20:19.566 A:middle
compile it and let me use it."

00:20:19.566 --> 00:20:21.316 A:middle
Or "hey, OpenCL, set
aside this memory.

00:20:21.316 --> 00:20:22.546 A:middle
I'm going to do some
compute and I want

00:20:22.546 --> 00:20:23.356 A:middle
to write the result there."

00:20:23.796 --> 00:20:25.666 A:middle
That's setup, pretty
straightforward.

00:20:25.666 --> 00:20:27.736 A:middle
And then finally, execution.

00:20:27.736 --> 00:20:30.466 A:middle
Once you have this all set
up, you want to say, "okay,

00:20:30.596 --> 00:20:32.496 A:middle
fill up that memory with
this data that I have here

00:20:32.496 --> 00:20:34.816 A:middle
on the host, or run this
kernel and run that one.

00:20:35.216 --> 00:20:36.636 A:middle
Do my work," basically.

00:20:37.676 --> 00:20:40.756 A:middle
So, hopefully I've
given you an idea of how

00:20:40.756 --> 00:20:42.156 A:middle
to start thinking about OpenCL.

00:20:43.196 --> 00:20:44.976 A:middle
And like I said, if you have
more questions, come down

00:20:44.976 --> 00:20:45.736 A:middle
and see us in the lab.

00:20:46.116 --> 00:20:47.526 A:middle
And with that I'd like
to hand it off to Abe,

00:20:47.526 --> 00:20:49.626 A:middle
who's going to talk to you
about some practical tasks.

00:20:49.626 --> 00:20:49.996 A:middle
[ Applause ]

00:20:49.996 --> 00:20:54.726 A:middle
&gt;&gt; Abe: Good afternoon.

00:20:55.026 --> 00:20:58.346 A:middle
My name's Abe Stevens, and I'm
an engineer on the OpenCL team,

00:20:58.676 --> 00:21:02.376 A:middle
and today I'm going to talk
about some practical tasks

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:02.376 --> 00:21:06.756 A:middle
that you can do with OpenCL,
and I'm going to focus

00:21:06.756 --> 00:21:11.206 A:middle
on a couple features that we've
added for OpenCL and 10.9.

00:21:11.806 --> 00:21:14.596 A:middle
I'm going to tell you how
to take advantage of some

00:21:14.596 --> 00:21:16.846 A:middle
of the program loading
and compiler features

00:21:16.846 --> 00:21:19.206 A:middle
that we've added to
decrease the startup time

00:21:19.206 --> 00:21:22.916 A:middle
of your applications, and then
I'm going to take a step back

00:21:22.916 --> 00:21:27.866 A:middle
and talk about how to save
power on laptop configurations

00:21:27.866 --> 00:21:32.486 A:middle
by using the discrete GPU and
setting your application up so

00:21:32.486 --> 00:21:34.886 A:middle
that it can transition
to the integrated CPU,

00:21:35.146 --> 00:21:39.816 A:middle
since we now support
Intel HD graphics on all

00:21:39.816 --> 00:21:41.346 A:middle
of our shipping configurations.

00:21:41.656 --> 00:21:43.336 A:middle
And then I'm going to talk
about a couple features

00:21:43.336 --> 00:21:48.486 A:middle
that are related in some ways
to what Jim just told you about.

00:21:48.486 --> 00:21:51.956 A:middle
Jim was talking about how
to look at the transfer time

00:21:52.246 --> 00:21:55.836 A:middle
that your application requires
to transfer data from the host

00:21:55.836 --> 00:21:59.616 A:middle
to the GPU, and I'm going
to show you a couple ways

00:21:59.616 --> 00:22:02.076 A:middle
of reducing that transfer
time and reducing the amount

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:02.076 --> 00:22:04.616 A:middle
of copying your application
has to do.

00:22:05.036 --> 00:22:07.476 A:middle
So let me start off
by talking about how

00:22:07.786 --> 00:22:11.276 A:middle
to address the start-up time,
or the time it takes for you

00:22:11.276 --> 00:22:14.116 A:middle
to load OpenCL programs when
you start your application.

00:22:14.606 --> 00:22:17.146 A:middle
In OpenCL there are really
three different functions

00:22:17.146 --> 00:22:21.176 A:middle
that contribute to a slow
startup: building a CL program,

00:22:21.316 --> 00:22:23.986 A:middle
compiling that program
and linking that program,

00:22:24.176 --> 00:22:26.866 A:middle
which are three different
steps that a program has to go

00:22:26.926 --> 00:22:30.416 A:middle
through before you end up
with an executable binary

00:22:30.416 --> 00:22:34.046 A:middle
that you can execute on a GPU.

00:22:34.136 --> 00:22:37.606 A:middle
Now, in OpenCL you can generate
these programs using three

00:22:37.606 --> 00:22:38.926 A:middle
different types of input.

00:22:38.926 --> 00:22:41.026 A:middle
You can start with a
piece of CL source code,

00:22:41.026 --> 00:22:45.476 A:middle
and that can be either a string
that you produced at runtime

00:22:45.476 --> 00:22:47.876 A:middle
or maybe a string that
you loaded from a .cl file

00:22:47.876 --> 00:22:49.706 A:middle
that you shipped with
your application.

00:22:50.026 --> 00:22:54.086 A:middle
It can be an LLVM bitcode file,
and that can be a bitcode file

00:22:54.086 --> 00:22:58.476 A:middle
that you generated in Xcode
using a .cl file at build time

00:22:58.476 --> 00:22:59.536 A:middle
and that was shipped
with your app.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:00.036 --> 00:23:02.976 A:middle
And then the third type
of input that I'll talk

00:23:02.976 --> 00:23:07.906 A:middle
about the most today is an
executable binary specifically

00:23:08.026 --> 00:23:10.266 A:middle
for the device that's in the
system that's running the app.

00:23:10.716 --> 00:23:12.406 A:middle
And this is something
that you can create

00:23:12.406 --> 00:23:15.966 A:middle
at runtime the first time your
app launches and then use it

00:23:15.966 --> 00:23:20.606 A:middle
on subsequent launches to really
decrease that startup time.

00:23:20.606 --> 00:23:24.336 A:middle
So let me show you how much
faster using executable binaries

00:23:24.336 --> 00:23:25.196 A:middle
can really be.

00:23:25.446 --> 00:23:27.316 A:middle
Let's say we have a
really simple application.

00:23:27.316 --> 00:23:31.796 A:middle
This is a 30-line CL
kernel which is going

00:23:31.796 --> 00:23:34.666 A:middle
to load a couple pixels
or read pixel values.

00:23:34.666 --> 00:23:37.346 A:middle
It's actually used as
a macro here to load,

00:23:37.656 --> 00:23:41.266 A:middle
pixels and a stencil, and then
it's going to take these values,

00:23:41.266 --> 00:23:44.646 A:middle
compute them and use them to
process a simple video effect.

00:23:45.176 --> 00:23:48.216 A:middle
Now, if you take this
application or this kernel

00:23:48.216 --> 00:23:50.716 A:middle
and you sort of set
up the system

00:23:51.046 --> 00:23:53.666 A:middle
in the worst possible
kind of case,

00:23:53.666 --> 00:23:57.426 A:middle
where the compiler
service hasn't started,

00:23:57.796 --> 00:24:02.426 A:middle
the program hasn't ever run
before, it might take the system

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:02.466 --> 00:24:06.076 A:middle
about 200 milliseconds
to compile that CL kernel

00:24:06.466 --> 00:24:08.376 A:middle
and give you an executable
program binary.

00:24:08.376 --> 00:24:11.716 A:middle
Now, if you had started with the
same system in that cold state

00:24:11.716 --> 00:24:14.196 A:middle
with a bitcode file that
you generated in Xcode,

00:24:14.196 --> 00:24:16.376 A:middle
you could do it in about
half the amount of time,

00:24:16.376 --> 00:24:18.666 A:middle
so about 80 milliseconds.

00:24:18.816 --> 00:24:20.896 A:middle
Now, if you had a warm system

00:24:21.226 --> 00:24:23.596 A:middle
or maybe you'd launched
the application recently

00:24:23.776 --> 00:24:26.106 A:middle
and the compiler service
was started and some

00:24:26.106 --> 00:24:30.376 A:middle
of the data was cached it
actually gets a lot faster.

00:24:30.546 --> 00:24:33.466 A:middle
That source, compiling from
source, can go down to about 1

00:24:33.466 --> 00:24:36.066 A:middle
to 2 milliseconds, same
thing for the bitcode file

00:24:36.066 --> 00:24:37.276 A:middle
and here is the kicker.

00:24:37.276 --> 00:24:39.526 A:middle
Here's the really neat thing.

00:24:39.966 --> 00:24:42.086 A:middle
If you'd had an executable
binary already,

00:24:42.226 --> 00:24:44.496 A:middle
and so you could skip
all that compiler work,

00:24:44.796 --> 00:24:48.346 A:middle
you could actually get started
and start executing the program

00:24:48.416 --> 00:24:49.676 A:middle
in under 1 millisecond.

00:24:49.866 --> 00:24:53.256 A:middle
So let me show you how to set
up your application to do that.

00:24:53.486 --> 00:24:56.336 A:middle
Well the first step is
to actually start off

00:24:56.336 --> 00:25:01.296 A:middle
with either a .cl source
file or a bitcode file,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:02.326 --> 00:25:06.336 A:middle
and you would want to
take this and load it

00:25:06.336 --> 00:25:08.426 A:middle
into your application,
and in this case I'm going

00:25:08.426 --> 00:25:09.846 A:middle
to show you how to
use a bitcode file.

00:25:10.236 --> 00:25:13.166 A:middle
Bitcode files are a great
way of avoiding having

00:25:13.166 --> 00:25:15.286 A:middle
to ship source code
in your application.

00:25:15.286 --> 00:25:19.906 A:middle
You can ship the bitcode
file in this case for 32 GPUs

00:25:20.166 --> 00:25:21.206 A:middle
and load it at runtime.

00:25:21.206 --> 00:25:23.396 A:middle
Here I'm going to load
this using some Cocoa code

00:25:23.756 --> 00:25:27.026 A:middle
and then pass it to
CLCreate program with binary

00:25:27.026 --> 00:25:28.136 A:middle
and then build the program,

00:25:28.136 --> 00:25:31.276 A:middle
then I end up with this
executable device binary.

00:25:31.916 --> 00:25:36.716 A:middle
I can take that binary
and save it to a cache,

00:25:36.716 --> 00:25:38.956 A:middle
and I'll show you how to figure
out where to put that cache

00:25:38.956 --> 00:25:40.546 A:middle
in a second, but in order

00:25:40.546 --> 00:25:43.256 A:middle
to extract the binary I
just call CLGetProgramInfo

00:25:43.696 --> 00:25:48.386 A:middle
and pack it into a Coca
data object and then store

00:25:48.386 --> 00:25:49.456 A:middle
that out to the file system.

00:25:49.846 --> 00:25:52.286 A:middle
So I call GetProgramInfo and
get the size of the binary

00:25:52.286 --> 00:25:54.626 A:middle
and then the actual binary
data itself, and then send it

00:25:54.626 --> 00:25:56.356 A:middle
out to the file system.

00:25:56.356 --> 00:25:59.306 A:middle
Now, let's say the user has
stopped using the application

00:25:59.306 --> 00:26:05.056 A:middle
and they started up again
later on, and I want to figure

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:05.056 --> 00:26:07.706 A:middle
out if I have a cache
file that I can load.

00:26:07.706 --> 00:26:11.336 A:middle
So if I look in my
caches directory,

00:26:11.456 --> 00:26:15.616 A:middle
I can compute just using
some simple Cocoa code here,

00:26:16.016 --> 00:26:18.356 A:middle
a location that a cache file
would be located and then try

00:26:18.356 --> 00:26:22.206 A:middle
to pull it into memory, and
if that's successful, I can go

00:26:22.206 --> 00:26:28.396 A:middle
and pass the executable binary
into CLCreateProgram with binary

00:26:28.396 --> 00:26:29.436 A:middle
and then CLBUild program.

00:26:29.436 --> 00:26:30.906 A:middle
So that's what I'm
going to do here.

00:26:31.006 --> 00:26:33.306 A:middle
You'll notice there's actually
some error checking code

00:26:33.306 --> 00:26:34.346 A:middle
in here, and this is important.

00:26:35.236 --> 00:26:38.086 A:middle
It's possible that
the runtime will --

00:26:38.246 --> 00:26:40.186 A:middle
even if you did have that
binary, even if we were able

00:26:40.186 --> 00:26:42.666 A:middle
to load it successfully from
the file system, it's possible

00:26:42.666 --> 00:26:46.146 A:middle
that the runtime might refuse
to load an executable binary

00:26:46.336 --> 00:26:48.096 A:middle
and it could do that for a
couple of different reasons.

00:26:48.096 --> 00:26:52.796 A:middle
It might be that your user took
their home directory and moved

00:26:52.796 --> 00:26:54.796 A:middle
on to a different machine
or they moved that binary

00:26:55.176 --> 00:26:58.956 A:middle
onto a different computer, maybe
they installed a software update

00:26:58.956 --> 00:27:02.066 A:middle
and the software update
installed new graphics driver

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:02.066 --> 00:27:05.846 A:middle
versions and the graphics driver
versions ended up not supporting

00:27:06.036 --> 00:27:08.516 A:middle
that particular executable
binary version.

00:27:09.036 --> 00:27:12.106 A:middle
And if that happens, your app
has to have a fallback path

00:27:12.436 --> 00:27:13.156 A:middle
that it can go back

00:27:13.236 --> 00:27:16.716 A:middle
to to regenerate the
executable device binary.

00:27:17.186 --> 00:27:20.156 A:middle
And so of course, that
fallback path could be as simple

00:27:20.156 --> 00:27:23.756 A:middle
as going back to whatever
mechanism we used two slides ago

00:27:23.756 --> 00:27:25.886 A:middle
to produce the binary in the
first place if you go back

00:27:25.886 --> 00:27:28.586 A:middle
to source code or
to a bitcode file.

00:27:28.786 --> 00:27:32.466 A:middle
So after you pull that binary
from disk and you pass it to CL,

00:27:32.906 --> 00:27:36.106 A:middle
CreateProgramwith Binary and
CL build program, check to see

00:27:36.106 --> 00:27:40.046 A:middle
if this invalid binary error
came back, and if it did,

00:27:40.046 --> 00:27:43.246 A:middle
make sure your app is a fallback
path and of course you won't

00:27:43.246 --> 00:27:46.186 A:middle
at the sub millisecond build
time but you'll be able

00:27:46.276 --> 00:27:51.406 A:middle
to take advantage of the faster
device executable binary load

00:27:51.406 --> 00:27:54.526 A:middle
times on subsequent
launches of your app.

00:27:54.616 --> 00:27:58.656 A:middle
So I took the code that we
just saw, and I applied it

00:27:58.766 --> 00:28:02.246 A:middle
to a couple different
programs, the 30-line program

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:02.246 --> 00:28:04.226 A:middle
that I showed you the
very first part of,

00:28:04.826 --> 00:28:08.276 A:middle
and then a 1,000-line program
that was actually from an app

00:28:08.276 --> 00:28:09.306 A:middle
that we were working on,

00:28:09.666 --> 00:28:12.896 A:middle
and then I had a much larger
test case, 4,000 line program.

00:28:13.186 --> 00:28:15.896 A:middle
And you can see that the
time to load source code

00:28:16.226 --> 00:28:18.766 A:middle
in each case kind of went
up quite a bit for each

00:28:18.766 --> 00:28:20.736 A:middle
of these different programs.

00:28:20.736 --> 00:28:22.586 A:middle
I went from 200 milliseconds

00:28:22.586 --> 00:28:24.876 A:middle
to 3,000 milliseconds
in the worst case.

00:28:24.956 --> 00:28:27.086 A:middle
But the best case here to load

00:28:27.086 --> 00:28:30.556 A:middle
that executable binary was
always under 1 millisecond.

00:28:31.166 --> 00:28:33.206 A:middle
And so really, depending on --

00:28:33.366 --> 00:28:36.496 A:middle
regardless of how big your
program ends up being,

00:28:37.146 --> 00:28:39.696 A:middle
taking advantage of that
executable binary can save you a

00:28:40.046 --> 00:28:43.836 A:middle
lot of time at startup.

00:28:43.836 --> 00:28:46.526 A:middle
Now I'd like to talk
about another topic,

00:28:46.526 --> 00:28:51.996 A:middle
which is that in 10.9, OpenCL
is supported on integrated GPUs,

00:28:51.996 --> 00:28:55.446 A:middle
the Intel HD Graphics,
and of course,

00:28:55.646 --> 00:28:57.846 A:middle
it's also supported
on discrete GPUs.

00:28:58.116 --> 00:29:00.326 A:middle
And so if you're working
on a configuration

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:00.326 --> 00:29:01.756 A:middle
like this Macbook Pro Retina,

00:29:02.296 --> 00:29:07.446 A:middle
you'll see that the
discrete GPU, the Nvidia 650

00:29:07.446 --> 00:29:10.176 A:middle
and the integrated
GPU both support CL,

00:29:10.606 --> 00:29:13.736 A:middle
and if you can take
advantage of both of those,

00:29:13.866 --> 00:29:16.826 A:middle
one thing you can do is
save power for your users.

00:29:17.026 --> 00:29:19.346 A:middle
And so OpenGL apps
have actually been able

00:29:19.346 --> 00:29:21.246 A:middle
to do this for quite some time.

00:29:21.456 --> 00:29:24.336 A:middle
Now, an OpenGL app running on
this GPU has a choice to make;

00:29:24.656 --> 00:29:27.946 A:middle
it can either run only
on the discrete device

00:29:28.436 --> 00:29:31.186 A:middle
or it can support what's called
automatic graphic switching,

00:29:31.646 --> 00:29:34.046 A:middle
and when it supports automatic
graphing switching it's been

00:29:34.046 --> 00:29:36.166 A:middle
written in a certain way
and it follows conventions

00:29:36.436 --> 00:29:39.196 A:middle
that allow it to transition
from the discrete GPU

00:29:39.196 --> 00:29:42.326 A:middle
to the integrated GPU if the
system tells it to do so,

00:29:42.326 --> 00:29:44.766 A:middle
and if it does that,
all the applications

00:29:44.766 --> 00:29:47.076 A:middle
in the system are able
to make that transition,

00:29:47.476 --> 00:29:48.936 A:middle
that can save power for the user

00:29:49.566 --> 00:29:51.426 A:middle
when there aren't any
applications running

00:29:51.426 --> 00:29:53.576 A:middle
that require that discrete GPU.

00:29:53.576 --> 00:29:57.516 A:middle
So let me show you how
to do this with OpenCL.

00:29:59.056 --> 00:30:02.146 A:middle
Now if you have an
OpenGL application,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:02.466 --> 00:30:04.416 A:middle
you probably have
an NSOpenGLView.

00:30:05.046 --> 00:30:06.306 A:middle
If you're working
on an application

00:30:06.306 --> 00:30:08.986 A:middle
that doesn't use Cocoa, you can
actually do the same kind --

00:30:09.116 --> 00:30:11.116 A:middle
perform the same operations
in a slightly different way,

00:30:11.116 --> 00:30:14.256 A:middle
but in your NSOpenGLView
you probably have some code

00:30:14.556 --> 00:30:16.776 A:middle
that checks to see what the
current virtual screen is.

00:30:16.776 --> 00:30:20.776 A:middle
And here, my NSOpenGL
View is keeping track

00:30:20.856 --> 00:30:24.746 A:middle
of the last virtual it used
to render the previous frame,

00:30:25.096 --> 00:30:28.166 A:middle
and it's going to compare
that to the virtual screen

00:30:28.166 --> 00:30:30.926 A:middle
that the GL context is
asking you to render

00:30:30.926 --> 00:30:33.216 A:middle
into for the next frame,
and it'll check to see

00:30:33.216 --> 00:30:34.436 A:middle
if these two things
are different.

00:30:34.776 --> 00:30:36.926 A:middle
And if the two virtual
screens are mismatched,

00:30:37.286 --> 00:30:40.166 A:middle
it's going to execute a couple
of8 GL commands to check and see

00:30:40.166 --> 00:30:42.856 A:middle
if the new device, that
new virtual screen,

00:30:43.216 --> 00:30:47.116 A:middle
the device associated with that
is capable of running everything

00:30:47.116 --> 00:30:48.676 A:middle
that it needs to execute.

00:30:48.676 --> 00:30:51.086 A:middle
And it might adapt its usage,
it might use smaller textures

00:30:51.086 --> 00:30:53.716 A:middle
or avoid using certain
extensions

00:30:53.716 --> 00:30:55.826 A:middle
or otherwise adapt its usage.

00:30:56.056 --> 00:30:58.376 A:middle
Now, we want to do the same
kind of thing in OpenCL

00:30:58.426 --> 00:31:01.586 A:middle
when we detect that
this render has changed.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:01.856 --> 00:31:04.246 A:middle
And so since OpenCL
doesn't use virtual screens;

00:31:04.246 --> 00:31:06.756 A:middle
it uses CL Device IDS, we need
to call the function that --

00:31:07.126 --> 00:31:10.176 A:middle
actually, Chris showed you this
function in the previous talk --

00:31:10.606 --> 00:31:13.416 A:middle
CGLGetDevices for
CurrentVirtual Screen Apple.

00:31:13.536 --> 00:31:16.106 A:middle
What that'll do is it'll map
whatever our current Virtual

00:31:16.106 --> 00:31:21.356 A:middle
Screen is from a virtual screen
to, ID'd back to a CL device ID,

00:31:21.866 --> 00:31:24.856 A:middle
and then we can start creating
that CL Device ID and learn more

00:31:24.856 --> 00:31:27.516 A:middle
about the new device that
we're supposed to use.

00:31:29.016 --> 00:31:32.316 A:middle
So CL does actually a
lot of the conversion

00:31:32.316 --> 00:31:34.466 A:middle
between two devices
automatically because a bit part

00:31:34.466 --> 00:31:37.726 A:middle
of the OpenCL API is the ability
to work with multiple devices

00:31:38.316 --> 00:31:40.496 A:middle
and to say run operations

00:31:40.496 --> 00:31:43.036 A:middle
on two different CPUs,
or the CPU and GPU.

00:31:43.386 --> 00:31:46.546 A:middle
So a lot of the CL objects
are context level objects,

00:31:46.846 --> 00:31:50.196 A:middle
and they'll handle sort of
switching from one device

00:31:50.196 --> 00:31:51.156 A:middle
to another automatically.

00:31:51.416 --> 00:31:53.296 A:middle
Memory objects, images
and buffers will do that.

00:31:54.046 --> 00:31:56.726 A:middle
CL kernel objects will handle
moving between the two devices

00:31:56.726 --> 00:31:59.636 A:middle
and of course programs, if
they're built for both devices,

00:31:59.636 --> 00:32:01.506 A:middle
will handle the transition
as well.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:01.506 --> 00:32:03.266 A:middle
Also if you have
an event dependency

00:32:03.626 --> 00:32:06.016 A:middle
or you create an event
on one command cue,

00:32:06.396 --> 00:32:09.816 A:middle
that event will sort of work
and will track a dependency

00:32:09.816 --> 00:32:13.046 A:middle
if you associate it -- or you
tell a command that's cued

00:32:13.046 --> 00:32:14.776 A:middle
on a different command
cue to wait for the event.

00:32:15.476 --> 00:32:16.626 A:middle
There are a couple of things

00:32:16.626 --> 00:32:17.966 A:middle
that you need to
check in OpenCL.

00:32:18.416 --> 00:32:21.376 A:middle
And those are that you have
to make sure your context

00:32:21.376 --> 00:32:23.246 A:middle
that you're using
contains both devices

00:32:23.246 --> 00:32:26.286 A:middle
and so you can create
command cues for both devices.

00:32:26.286 --> 00:32:29.326 A:middle
And of course, you have to make
sure that if you create programs

00:32:29.876 --> 00:32:34.186 A:middle
for the two devices,
that you create them

00:32:34.186 --> 00:32:39.316 A:middle
for either the right executable
binaries, or if there are PPUs

00:32:39.316 --> 00:32:41.466 A:middle
in this case, that
you create them

00:32:41.466 --> 00:32:43.626 A:middle
with this GPU 32 bitcode file.

00:32:44.206 --> 00:32:47.056 A:middle
And so there are other things

00:32:47.056 --> 00:32:48.076 A:middle
that you might have
to check as well.

00:32:48.076 --> 00:32:49.746 A:middle
These are less common.

00:32:49.746 --> 00:32:52.126 A:middle
It's possible that if your
program is using Double

00:32:52.126 --> 00:32:54.526 A:middle
Precision and you have
some highly tuned numerics

00:32:54.526 --> 00:32:57.176 A:middle
in your program,
when you compile this

00:32:57.576 --> 00:32:59.946 A:middle
for the integrated
device, it'll be --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:00.246 --> 00:33:02.496 A:middle
instead of running
with double it'll run

00:33:02.496 --> 00:33:04.516 A:middle
with single prevision floating
point, and you have to make sure

00:33:04.516 --> 00:33:06.946 A:middle
that that's enough precision
for your application.

00:33:07.656 --> 00:33:11.696 A:middle
Another thing to check is
that a lot of the capabilities

00:33:11.996 --> 00:33:14.136 A:middle
of the devices are a
little bit different,

00:33:14.216 --> 00:33:18.566 A:middle
and so the kernel work group
size of the integrated GPU

00:33:18.566 --> 00:33:20.776 A:middle
and the discrete GPU
will be different,

00:33:20.776 --> 00:33:24.786 A:middle
so when you initialize OpenCL,
you compile your programs,

00:33:25.196 --> 00:33:27.906 A:middle
you should check to see what
your kernel work group size is

00:33:27.906 --> 00:33:30.426 A:middle
of the discrete GPU, of course,
and record that and figure

00:33:30.426 --> 00:33:33.086 A:middle
out how large of
kernels to launch,

00:33:33.326 --> 00:33:35.446 A:middle
and then do the same thing
for the integrated GPU.

00:33:35.446 --> 00:33:38.516 A:middle
That way when you detect this
switch, it'll be really easy

00:33:38.516 --> 00:33:40.406 A:middle
for you to switch
to in cuing kernels

00:33:40.816 --> 00:33:46.446 A:middle
that use the appropriate likely
smaller work group sizes.

00:33:47.106 --> 00:33:49.216 A:middle
So now I'd like to go over a
couple of performance features

00:33:49.216 --> 00:33:52.936 A:middle
that we've added in 10.9,
and these features have to do

00:33:52.936 --> 00:33:58.186 A:middle
with reducing the cost of memory
transfers or reducing the time

00:33:58.186 --> 00:33:59.876 A:middle
that our application
will spend waiting

00:33:59.876 --> 00:34:01.146 A:middle
for transfers to complete.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:01.146 --> 00:34:02.736 A:middle
And the first thing
I'd like to talk

00:34:02.736 --> 00:34:04.716 A:middle
about is buffers and images.

00:34:05.126 --> 00:34:10.096 A:middle
In OpenCL, buffers are
really just like pointers

00:34:10.096 --> 00:34:11.775 A:middle
to memory in your kernel.

00:34:11.775 --> 00:34:13.076 A:middle
You can read and write them,

00:34:13.216 --> 00:34:15.556 A:middle
manipulate them as
global pointers.

00:34:15.556 --> 00:34:18.216 A:middle
You probably saw those in the
example Jim showed earlier.

00:34:19.335 --> 00:34:24.016 A:middle
Buffers support atomic
operations and on most GPUs,

00:34:24.406 --> 00:34:26.496 A:middle
the global memory that you use

00:34:26.496 --> 00:34:29.476 A:middle
to access buffers is
usually not cached,

00:34:29.476 --> 00:34:32.146 A:middle
and so sometimes it
can be higher latency

00:34:32.146 --> 00:34:35.516 A:middle
to access tasks as
buffer objects.

00:34:35.886 --> 00:34:37.916 A:middle
Image objects are kind
of like GL textures.

00:34:38.706 --> 00:34:40.956 A:middle
They're either read
only or write only,

00:34:40.956 --> 00:34:43.876 A:middle
so you have to decide when
you're writing a kernel

00:34:43.876 --> 00:34:46.235 A:middle
if you're going to either
only read or only write

00:34:46.235 --> 00:34:49.446 A:middle
for a particular object.

00:34:49.976 --> 00:34:51.916 A:middle
And they support
harbor filtering.

00:34:52.906 --> 00:34:54.866 A:middle
So what if you had an instance

00:34:54.866 --> 00:34:56.196 A:middle
where you wanted
to support both?

00:34:56.196 --> 00:35:00.826 A:middle
Say for example, you
had this set of kernels

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:00.826 --> 00:35:06.396 A:middle
where you have a histogram
operation and then you would

00:35:06.396 --> 00:35:08.786 A:middle
like to output data in
a floating point array

00:35:08.786 --> 00:35:13.226 A:middle
but then later on, perform a
read image operation where you'd

00:35:13.226 --> 00:35:14.676 A:middle
like some hardware
texture filtering.

00:35:15.076 --> 00:35:18.726 A:middle
Well, in 10.9 we
supported the image 2D

00:35:18.726 --> 00:35:21.236 A:middle
for buffering extension,
and this allows us

00:35:21.236 --> 00:35:24.786 A:middle
to basically take a buffer
object that we've created here

00:35:25.016 --> 00:35:26.556 A:middle
and wrap it with
an image object.

00:35:27.116 --> 00:35:30.146 A:middle
So here the image
object has been sized

00:35:30.146 --> 00:35:34.376 A:middle
so that it contains enough
pixels to fill the buffer,

00:35:34.916 --> 00:35:41.176 A:middle
and I'm essentially wrapping the
allocated buffer with an image,

00:35:41.476 --> 00:35:43.976 A:middle
and then in my kernel
I'll be able to --

00:35:44.036 --> 00:35:45.916 A:middle
or in two different
kernels, I'll be able

00:35:45.916 --> 00:35:49.716 A:middle
to access the same underlying
piece of memory once as a buffer

00:35:49.716 --> 00:35:51.116 A:middle
and then also as an image.

00:35:51.676 --> 00:35:53.596 A:middle
So when you're using
image 2D from buffer,

00:35:53.596 --> 00:35:55.656 A:middle
you have to be careful of a
couple of different things.

00:35:56.106 --> 00:35:58.526 A:middle
One thing is that if you've
created the buffer using

00:35:58.526 --> 00:36:00.956 A:middle
UseHostPointer, which
is a popular technique,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:00.956 --> 00:36:03.876 A:middle
you have to make sure that
the UseHostPointer address

00:36:03.876 --> 00:36:07.486 A:middle
that you pass in matches the
device's base address alignment.

00:36:08.016 --> 00:36:10.196 A:middle
You also have to make sure
that if you specify a row pitch

00:36:10.526 --> 00:36:12.556 A:middle
that the row pitch
matches or is a multiple

00:36:12.556 --> 00:36:15.236 A:middle
of the pitch alignment for
that particular device.

00:36:15.756 --> 00:36:20.686 A:middle
Now, in computeApps,
data movement is --

00:36:20.686 --> 00:36:22.926 A:middle
there are a lot of different
patterns for data movement

00:36:22.926 --> 00:36:24.316 A:middle
and Jim talked about
a few of these

00:36:24.776 --> 00:36:27.846 A:middle
in the previous section
of the talk.

00:36:28.536 --> 00:36:32.626 A:middle
One common pattern is a pattern
where you write some data

00:36:32.626 --> 00:36:35.836 A:middle
to the device, you process
on it, you execute a couple

00:36:35.836 --> 00:36:38.316 A:middle
of kernels, and then
you read back that data.

00:36:38.976 --> 00:36:42.216 A:middle
And so that would look something
like this, and this is common

00:36:42.386 --> 00:36:44.776 A:middle
in say video kind of operation

00:36:44.776 --> 00:36:49.506 A:middle
where for each frame you're
writing it to ComputeDevice,

00:36:50.066 --> 00:36:52.346 A:middle
processing it for a little
while, and then reading it back

00:36:52.516 --> 00:36:53.786 A:middle
and maybe encoding it.

00:36:54.306 --> 00:36:57.546 A:middle
In this kind of a
system, let's say it takes

00:36:57.546 --> 00:37:00.656 A:middle
about 2 milliseconds to
move those pieces of data

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:00.656 --> 00:37:03.116 A:middle
to the device and 6 milliseconds
to do the processing.

00:37:03.116 --> 00:37:07.016 A:middle
Well, that would be about 10
milliseconds per iteration.

00:37:07.016 --> 00:37:10.206 A:middle
And so if I was going
to do 100 iterations,

00:37:10.206 --> 00:37:12.336 A:middle
I'd end up spending
1,000 milliseconds

00:37:12.336 --> 00:37:14.926 A:middle
and I'd only really actually
be doing compute work

00:37:15.416 --> 00:37:18.876 A:middle
for 60% of that time.

00:37:19.446 --> 00:37:23.356 A:middle
Well, it turns out in many
discrete GPUs there's some DMA

00:37:23.356 --> 00:37:27.046 A:middle
hardware that can allow us to
overlap the read and write work

00:37:27.046 --> 00:37:27.826 A:middle
with the compute work.

00:37:27.826 --> 00:37:31.636 A:middle
And so if we take a look
at a piece of compute work,

00:37:31.676 --> 00:37:35.506 A:middle
say integration N here,
we can try to think

00:37:35.506 --> 00:37:37.856 A:middle
about what the system
might schedule using

00:37:37.856 --> 00:37:40.956 A:middle
in a DMA engine for iteration N.

00:37:41.076 --> 00:37:45.786 A:middle
So for example, the system
could schedule the readback

00:37:45.956 --> 00:37:46.776 A:middle
of the previous frame.

00:37:46.776 --> 00:37:48.706 A:middle
So we know that the
system is done,

00:37:48.706 --> 00:37:52.946 A:middle
the GPU is done processing
work for NMIs 1

00:37:53.416 --> 00:37:56.866 A:middle
and so it can do the
readback for that frame.

00:37:56.866 --> 00:37:58.706 A:middle
It could also actually,
since there's no dependency

00:37:58.706 --> 00:38:01.086 A:middle
between each frame, it
could also do the --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:01.166 --> 00:38:04.716 A:middle
it could also write for
it and write iteration

00:38:04.776 --> 00:38:07.256 A:middle
and +1s data out to the GPU.

00:38:07.256 --> 00:38:08.546 A:middle
And so if we repeat
this pattern,

00:38:08.916 --> 00:38:11.796 A:middle
we can see that we can
keep the DMAengine busy

00:38:11.936 --> 00:38:13.816 A:middle
and also keep the
computeEngine busy

00:38:13.816 --> 00:38:15.686 A:middle
for most of these iterations.

00:38:15.926 --> 00:38:19.316 A:middle
And so if I look across
all of my 100 iterations,

00:38:19.606 --> 00:38:22.456 A:middle
I might be able to do this
in about 40% less time --

00:38:22.456 --> 00:38:25.136 A:middle
a little more than 40% the time

00:38:25.136 --> 00:38:27.416 A:middle
by fully subscribing
both the DMA

00:38:27.416 --> 00:38:29.736 A:middle
and the compute sides
of the device.

00:38:29.956 --> 00:38:32.486 A:middle
To set this up in OpenCL,
I'd want to write some code

00:38:32.486 --> 00:38:33.656 A:middle
that looks something like this.

00:38:34.026 --> 00:38:36.346 A:middle
Here I'm using nonblocking
read and write commands,

00:38:36.576 --> 00:38:38.626 A:middle
and of course my
EnqueueKerneland my

00:38:38.626 --> 00:38:41.856 A:middle
EnqueueNDRange command is always
nonblocking, so I'm going to set

00:38:41.856 --> 00:38:46.276 A:middle
up the first kernel and
then have a pipeline loop

00:38:46.786 --> 00:38:49.436 A:middle
that iterates over
the body of the work,

00:38:49.436 --> 00:38:53.036 A:middle
and then at the end I clean that
up by enqueueing the last kernel

00:38:53.036 --> 00:38:54.606 A:middle
and then reading
back the last result.

00:38:54.886 --> 00:38:57.526 A:middle
And this code will work for
M input and output buffers.

00:38:57.526 --> 00:39:01.906 A:middle
In a sort of practical system
I'd probably have a relatively

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:01.906 --> 00:39:04.176 A:middle
much smaller pool of buffers
that I'd work on, much smaller

00:39:04.176 --> 00:39:07.356 A:middle
than say 100 buffers, and I
might have to track dependencies

00:39:07.796 --> 00:39:13.166 A:middle
and make sure that it's
safe to reuse a buffer

00:39:13.166 --> 00:39:16.676 A:middle
after it's been sent
to the device.

00:39:17.566 --> 00:39:22.526 A:middle
So before I close, I'd like to
talk about some programming tips

00:39:22.526 --> 00:39:25.296 A:middle
for using OpenCL and
these apply to 10.9

00:39:25.296 --> 00:39:28.176 A:middle
and to the other implementations
of OpenCL that we've shipped.

00:39:28.526 --> 00:39:31.386 A:middle
One tip that we have is
that when you're able to,

00:39:31.386 --> 00:39:35.166 A:middle
you should prefer passing page
line pointers to the system.

00:39:35.546 --> 00:39:38.036 A:middle
So if you create or an image
as a used host pointer,

00:39:38.036 --> 00:39:41.566 A:middle
try to pass in something that
page lined, you can also pass

00:39:41.566 --> 00:39:44.796 A:middle
in pageline pointers when you
have to read or write data

00:39:45.316 --> 00:39:47.176 A:middle
into the system and
the driver will try

00:39:47.176 --> 00:39:49.226 A:middle
to take an optimized
path when you do that.

00:39:49.646 --> 00:39:51.376 A:middle
One way of getting
pageline pointers is

00:39:51.376 --> 00:39:54.246 A:middle
to call POSIX Memoline
instead of Malik

00:39:54.306 --> 00:39:55.886 A:middle
when you're allocating
a host buffer.

00:39:57.116 --> 00:39:59.716 A:middle
Another tip that we have
is to avoid using CLFInish.

00:39:59.716 --> 00:40:02.536 A:middle
It's great for debugging
and for isolating a problem

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:02.536 --> 00:40:07.946 A:middle
in your code, but it'll create
sort of large bottlenecks

00:40:07.946 --> 00:40:11.816 A:middle
or bubbles in your
pipeline, and is not something

00:40:12.096 --> 00:40:14.966 A:middle
that you should use in
production code in most cases.

00:40:15.366 --> 00:40:18.436 A:middle
If you do need help debugging,
you can use CLLog error,

00:40:18.786 --> 00:40:20.646 A:middle
which is an environment
variable that you can set

00:40:20.646 --> 00:40:22.626 A:middle
and it will turn on
verbose log messages

00:40:23.036 --> 00:40:25.266 A:middle
in case there's an API
problem, or if you're trying

00:40:25.266 --> 00:40:27.186 A:middle
to debug a problem with
a kernel on the GPU,

00:40:27.186 --> 00:40:28.916 A:middle
consider using printf.

00:40:30.446 --> 00:40:35.136 A:middle
So Open CL Mavericks, today
we talked about a mechanism

00:40:35.136 --> 00:40:38.326 A:middle
for loading your program faster
using executable binaries,

00:40:38.516 --> 00:40:40.796 A:middle
and the important part there
was to have a fallback mechanism

00:40:41.306 --> 00:40:43.096 A:middle
so that if there is a binary

00:40:43.096 --> 00:40:46.186 A:middle
and compatibility your app
can fall back and load either

00:40:46.186 --> 00:40:48.066 A:middle
from the code files
or from source.

00:40:48.386 --> 00:40:50.476 A:middle
Then we talked about how to
make sure your app follows the

00:40:50.476 --> 00:40:51.646 A:middle
conventions that are necessary

00:40:51.646 --> 00:40:53.686 A:middle
to support automatic
graphic switching

00:40:53.686 --> 00:40:56.556 A:middle
so that you can reduce
battery life if you're able

00:40:56.556 --> 00:40:58.416 A:middle
to move everything over
to the integrated GPU.

00:40:59.116 --> 00:41:01.476 A:middle
And lastly, we talked
about a couple mechanisms

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:01.476 --> 00:41:04.636 A:middle
that are available to
decrease the overhead of having

00:41:04.636 --> 00:41:06.986 A:middle
to copy data from the
host to the device.

00:41:07.396 --> 00:41:12.056 A:middle
And so now I'd like to hand
the talk over to David McGavran

00:41:12.056 --> 00:41:16.136 A:middle
from Adobe, who's going to tell
us about how he's used OpenCL

00:41:16.266 --> 00:41:20.466 A:middle
and Adobe Premiere Pro, and
I think he has a demo for us.

00:41:20.741 --> 00:41:22.741 A:middle
[ Applause ]

00:41:23.016 --> 00:41:24.686 A:middle
&gt;&gt; David McGavran:
Good afternoon.

00:41:24.686 --> 00:41:27.896 A:middle
My name's David McGavran, I'm
the senior engineering manager

00:41:27.896 --> 00:41:28.966 A:middle
on Adobe Premiere Pro.

00:41:29.766 --> 00:41:33.016 A:middle
So about a year and a
half ago, we announced

00:41:33.116 --> 00:41:36.156 A:middle
that we ported the
entire GP rendering engine

00:41:36.156 --> 00:41:38.306 A:middle
in Premiere Pro to OpenCL.

00:41:38.306 --> 00:41:39.706 A:middle
That was a big announcement
for us.

00:41:39.706 --> 00:41:42.396 A:middle
It was a really exciting
time for us and we were doing

00:41:42.396 --> 00:41:45.216 A:middle
that specifically to
target the Macbook Pro

00:41:45.216 --> 00:41:46.936 A:middle
that shipped at that time.

00:41:46.936 --> 00:41:50.226 A:middle
So we're very excited about
that, and we came here

00:41:50.226 --> 00:41:52.476 A:middle
to WWDC last year and we
talked to this session

00:41:52.866 --> 00:41:55.776 A:middle
about the improvements we
made in Premiere using OpenCL

00:41:55.776 --> 00:41:57.036 A:middle
and it was really exciting.

00:41:57.436 --> 00:42:00.176 A:middle
This year I want to talk about
what we've done since then.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:00.316 --> 00:42:01.586 A:middle
We obviously didn't
stop working,

00:42:01.586 --> 00:42:05.356 A:middle
and OpenCL is a great way
to really excite our users

00:42:05.356 --> 00:42:07.426 A:middle
and really make them
enjoy working in Premiere.

00:42:08.126 --> 00:42:10.466 A:middle
So I want to talk about the
differences in Premiere Pro CS6

00:42:10.466 --> 00:42:14.376 A:middle
to what we're doing in Adobe
Premiere Pro CC that's shipping

00:42:14.376 --> 00:42:15.076 A:middle
in four days.

00:42:15.866 --> 00:42:19.226 A:middle
So last year in Premiere Pro
CS6, we were very careful

00:42:19.226 --> 00:42:20.006 A:middle
about what we targeted.

00:42:20.006 --> 00:42:23.826 A:middle
It was a massive effort to port
the entire GPU engine to OpenCL,

00:42:24.386 --> 00:42:25.566 A:middle
and so we were very careful.

00:42:25.566 --> 00:42:27.116 A:middle
We targeted just 2 GPUs.

00:42:27.116 --> 00:42:30.346 A:middle
We targeted the GPUs that
were in the Macbook Pro line

00:42:30.346 --> 00:42:33.206 A:middle
at the time, so the
650M and the 670M.

00:42:33.206 --> 00:42:35.036 A:middle
Well, we've been getting
much better at OpenCL,

00:42:35.036 --> 00:42:36.546 A:middle
and we've done a
lot more testing,

00:42:36.856 --> 00:42:38.506 A:middle
so the first thing we're
going to do is we're going

00:42:38.506 --> 00:42:39.696 A:middle
to really increase the places

00:42:39.696 --> 00:42:42.046 A:middle
where you can use
Premiere Pro on OpenCL.

00:42:42.046 --> 00:42:44.026 A:middle
So you can see here,
we support just

00:42:44.026 --> 00:42:47.436 A:middle
about every card that's
shipping in Macintoshes today.

00:42:48.106 --> 00:42:49.426 A:middle
The other thing that
we've done is now

00:42:49.426 --> 00:42:52.126 A:middle
that we know how well we can
take advantage of OpenCL,

00:42:52.636 --> 00:42:54.766 A:middle
sometimes cards come out
after we ship a version.

00:42:54.766 --> 00:42:56.336 A:middle
So traditionally we've
white-listed a card,

00:42:56.336 --> 00:42:58.126 A:middle
and then that's the
card that would work.

00:42:58.126 --> 00:43:00.536 A:middle
If you got a new card,
it took us a little while

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:00.536 --> 00:43:01.206 A:middle
to catch up with you.

00:43:01.946 --> 00:43:04.176 A:middle
So now that we're really
confident in OpenCL,

00:43:04.176 --> 00:43:06.566 A:middle
we're also allowing it so that
you can turn on a new card

00:43:06.566 --> 00:43:10.636 A:middle
as a user, and as long as it has
a gig of RAM on the video card,

00:43:10.636 --> 00:43:13.716 A:middle
and passes some basic video
card tests, you'll be confident

00:43:13.716 --> 00:43:15.346 A:middle
that it's going to
run well on your GPU,

00:43:15.486 --> 00:43:16.496 A:middle
so that's pretty exciting.

00:43:17.036 --> 00:43:18.486 A:middle
So we've really taken advantage

00:43:18.486 --> 00:43:22.206 A:middle
of all the different
computers that are out there.

00:43:22.406 --> 00:43:25.036 A:middle
Furthermore, we've really
worked hard on continuing

00:43:25.036 --> 00:43:26.066 A:middle
to improve the program elements.

00:43:26.066 --> 00:43:28.576 A:middle
We've showed you some pretty
amazing demos with CS6

00:43:28.726 --> 00:43:30.146 A:middle
about what you can
do with OpenCL,

00:43:30.666 --> 00:43:32.026 A:middle
but we still want to
always go further.

00:43:32.026 --> 00:43:34.176 A:middle
We really want to take
advantage of every bit

00:43:34.176 --> 00:43:35.076 A:middle
of power on the machine.

00:43:35.396 --> 00:43:36.856 A:middle
So we did three things.

00:43:37.096 --> 00:43:39.536 A:middle
Last year we were saying that
one of the pitfalls we ran

00:43:39.536 --> 00:43:41.746 A:middle
into with OpenCL was trying
to get pin memory to work.

00:43:42.166 --> 00:43:44.216 A:middle
We struggled with it, we didn't
quite get it done in time,

00:43:44.766 --> 00:43:45.756 A:middle
we've gotten that done now,

00:43:45.916 --> 00:43:48.276 A:middle
so OpenCL with pin memory is
working really well for us,

00:43:48.276 --> 00:43:50.916 A:middle
and it really shows some real
world performance improvements.

00:43:51.726 --> 00:43:53.036 A:middle
We've also been working
with some of the stuff

00:43:53.036 --> 00:43:55.346 A:middle
that you saw earlier in these
slides to take advantage

00:43:55.346 --> 00:43:57.956 A:middle
of the image to buffer
translation.

00:43:58.356 --> 00:44:00.506 A:middle
That was a pretty
heavy problem for us.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:00.506 --> 00:44:02.516 A:middle
We have a lot of kernels that
run really well on images,

00:44:02.516 --> 00:44:04.826 A:middle
and a lot of kernels that
run really well on buffers,

00:44:05.126 --> 00:44:08.946 A:middle
having to copy between those
was a pretty expensive piece

00:44:08.946 --> 00:44:09.756 A:middle
of problem for us.

00:44:09.756 --> 00:44:11.396 A:middle
So we take advantage
of this new thing,

00:44:11.396 --> 00:44:12.296 A:middle
and that's quite exciting.

00:44:13.096 --> 00:44:14.766 A:middle
You also saw something
in the keynote

00:44:14.766 --> 00:44:18.366 A:middle
about the new Mac Pro
shipping with dual GPUs.

00:44:18.366 --> 00:44:21.496 A:middle
So in Adobe Premiere Pro CC,
when you're rendering a sequence

00:44:21.496 --> 00:44:24.636 A:middle
down to a file, we fully take
advantage of multiple GPUs

00:44:24.636 --> 00:44:27.366 A:middle
in your system, so that
obviously gives you a really big

00:44:27.366 --> 00:44:28.496 A:middle
performance improvement
when you're running

00:44:28.496 --> 00:44:29.316 A:middle
on a system like that.

00:44:29.366 --> 00:44:31.166 A:middle
So we're really excited about
the Mac Pro announcement

00:44:31.166 --> 00:44:35.976 A:middle
and what it's going to do
for Premiere Pro customers.

00:44:35.976 --> 00:44:37.906 A:middle
So last year -- I
brought up this slide

00:44:37.906 --> 00:44:41.216 A:middle
to show all the different things
that Premiere does on OpenCL.

00:44:41.436 --> 00:44:44.036 A:middle
So if you're doing
basic video processing,

00:44:44.036 --> 00:44:46.286 A:middle
you need to do DM releasing,
you need to do compositing,

00:44:46.286 --> 00:44:49.036 A:middle
you need to use blend modes, you
need to upload all this stuff

00:44:49.036 --> 00:44:50.606 A:middle
onto your graphics card
and you can do effects,

00:44:50.606 --> 00:44:52.156 A:middle
you can do transitions,
you can do color,

00:44:52.156 --> 00:44:53.196 A:middle
effects, and all that stuff.

00:44:54.166 --> 00:44:55.516 A:middle
So we always want
to continue to see

00:44:55.516 --> 00:44:57.506 A:middle
if the other stuff
we can do on the GPU.

00:44:57.506 --> 00:45:00.936 A:middle
So this year with Premiere Pro
CC we've added a few effects.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:00.936 --> 00:45:03.706 A:middle
Now, this doesn't really
look like a big list.

00:45:03.706 --> 00:45:06.746 A:middle
We have some new blurs, we have
wipe and slide, some basic stuff

00:45:06.746 --> 00:45:09.236 A:middle
that you would expect for us
to do on the OpenCL kernels.

00:45:09.946 --> 00:45:12.676 A:middle
But on the bottom right there
you'll see the Lumetri deep

00:45:12.676 --> 00:45:13.296 A:middle
color engine.

00:45:13.646 --> 00:45:15.756 A:middle
I want to talk about
that for a little bit.

00:45:16.196 --> 00:45:18.766 A:middle
The Lumetri deep color engine
came from an acquisition we made

00:45:18.766 --> 00:45:19.916 A:middle
about a year and a half ago.

00:45:19.916 --> 00:45:22.016 A:middle
It's a technology from
a company called Aridos.

00:45:22.636 --> 00:45:25.576 A:middle
They have a super high-end color
grading application called Speed

00:45:25.576 --> 00:45:29.106 A:middle
grade, and that was a very,
very powerful application

00:45:29.106 --> 00:45:30.226 A:middle
that they used to do things

00:45:30.226 --> 00:45:33.506 A:middle
like grade the entire Blue
ray release of James Bond --

00:45:33.946 --> 00:45:35.576 A:middle
all the entire series.

00:45:36.356 --> 00:45:39.156 A:middle
We took that entire GPU
engine that they had,

00:45:39.396 --> 00:45:40.816 A:middle
brought it into Premiere Pro

00:45:40.816 --> 00:45:42.796 A:middle
under the Mercury
Playback engine,

00:45:42.976 --> 00:45:44.576 A:middle
and ported it all to OpenCL.

00:45:45.736 --> 00:45:47.166 A:middle
So this in itself,
this omen effect,

00:45:47.586 --> 00:45:50.706 A:middle
is built up of 60
kernels, all doing really,

00:45:50.706 --> 00:45:52.596 A:middle
really complicated
stuff, on the GPU.

00:45:52.596 --> 00:45:55.676 A:middle
And this allows the editors
using Premiere Pro now

00:45:55.676 --> 00:45:59.096 A:middle
to actually apply creative
looks to their movies

00:45:59.396 --> 00:46:00.576 A:middle
that I'll show you in
a demo in a minute,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:00.626 --> 00:46:03.846 A:middle
and that just changes the
way they completely use the

00:46:03.926 --> 00:46:04.586 A:middle
Premiere Pro.

00:46:04.586 --> 00:46:06.536 A:middle
You cannot do that
without the GPU.

00:46:06.536 --> 00:46:09.496 A:middle
It was a painful experience to
sit there and use that engine

00:46:09.496 --> 00:46:10.946 A:middle
without the GP running
behind you.

00:46:11.286 --> 00:46:12.656 A:middle
So that's how we can
really take advantage

00:46:12.656 --> 00:46:14.146 A:middle
of OpenCL to delight our users.

00:46:15.716 --> 00:46:17.936 A:middle
So using these performance
improvements,

00:46:17.936 --> 00:46:18.646 A:middle
what are we seeing?

00:46:19.496 --> 00:46:22.396 A:middle
So if we just talk about the pin
memory, and the image to buffer

00:46:22.496 --> 00:46:25.336 A:middle
and just do a simple encode
without them and with them,

00:46:25.336 --> 00:46:27.776 A:middle
we're seeing about a 30%
performance improvement.

00:46:28.036 --> 00:46:30.876 A:middle
That's pretty good, considering
we got a massive performance

00:46:30.876 --> 00:46:32.976 A:middle
improvement just switching
to OpenCL, so that we can go

00:46:32.976 --> 00:46:35.596 A:middle
with another 30%, that's
pretty good for our users.

00:46:36.486 --> 00:46:38.416 A:middle
If we take everything into
account that we're talking

00:46:38.416 --> 00:46:40.586 A:middle
about -- the new blurs,
the new transitions,

00:46:41.596 --> 00:46:44.586 A:middle
and the multiple GPUs, we're
seeing somewhere upward

00:46:44.586 --> 00:46:46.986 A:middle
of 200% performance
improvements on an encode.

00:46:47.886 --> 00:46:48.826 A:middle
This is very exciting.

00:46:48.826 --> 00:46:50.776 A:middle
You take Premiere Sequence,
you render the same sequence

00:46:50.916 --> 00:46:53.456 A:middle
with all these optimizations
and it's 200% faster.

00:46:54.286 --> 00:46:56.306 A:middle
This is what OpenCL can
really do for your users.

00:46:57.816 --> 00:47:00.816 A:middle
So last year, after we were
done with our initial port

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:00.816 --> 00:47:03.696 A:middle
and all the engineers took
their breath and calmed

00:47:03.696 --> 00:47:05.686 A:middle
down for a little bit, we said
there were still some things we

00:47:05.686 --> 00:47:07.766 A:middle
would like to do with OpenCL
that we didn't have in CS6.

00:47:07.766 --> 00:47:09.586 A:middle
This is a slide we put up.

00:47:10.316 --> 00:47:12.666 A:middle
So with Premiere Pro CC --
again, you can get it in 4 days,

00:47:12.666 --> 00:47:14.636 A:middle
we're very excited about that --

00:47:14.636 --> 00:47:17.686 A:middle
we've increased the set of
effects that work in OpenCL.

00:47:19.126 --> 00:47:21.016 A:middle
We now support third
party effects.

00:47:21.016 --> 00:47:23.096 A:middle
Now, this is something brand new
that I didn't talk about yet.

00:47:23.566 --> 00:47:26.266 A:middle
Traditionally in Premiere
Pro CS6 if you went out

00:47:26.266 --> 00:47:29.046 A:middle
and bought an effect plug-in
that works in Premiere,

00:47:29.596 --> 00:47:31.916 A:middle
they didn't really get the
opportunity to use the OpenCL.

00:47:32.116 --> 00:47:33.286 A:middle
They could use OpenCL
but they'd have

00:47:33.286 --> 00:47:37.076 A:middle
to take it off the GPU device,
put it back up on the device

00:47:37.076 --> 00:47:39.536 A:middle
in their OpenCL context, do
the compute, pull it back down

00:47:39.536 --> 00:47:40.806 A:middle
and give it back to
us and we put it back

00:47:40.806 --> 00:47:41.876 A:middle
up -- that's not good.

00:47:41.876 --> 00:47:44.256 A:middle
So we've now expanded our SDKs

00:47:44.256 --> 00:47:47.216 A:middle
so that third party developers
can actually write their kernel

00:47:47.216 --> 00:47:51.176 A:middle
-- their plug-ins and effects
using OpenCL and stay on the GPU

00:47:51.176 --> 00:47:52.796 A:middle
and be as fast as any
of our native effects.

00:47:52.796 --> 00:47:54.076 A:middle
So that's really exciting.

00:47:54.936 --> 00:47:57.826 A:middle
We didn't get to GPU
encoding and decoding,

00:47:57.826 --> 00:47:59.086 A:middle
still something we're
investigating.

00:47:59.086 --> 00:48:01.156 A:middle
We're waiting for that to
make sense for our users,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:01.156 --> 00:48:04.586 A:middle
but we did go to do multiple
GPU support, and that's very,

00:48:04.586 --> 00:48:06.566 A:middle
verity exciting, especially
with the keynote announcements.

00:48:07.566 --> 00:48:09.486 A:middle
So another thing that
we're still interested

00:48:09.486 --> 00:48:11.946 A:middle
in doing is taking our scopes
and putting them on a GPU

00:48:11.946 --> 00:48:12.956 A:middle
and we haven't done that yet.

00:48:13.636 --> 00:48:16.456 A:middle
We also have some really other
great ideas that we're not ready

00:48:16.506 --> 00:48:19.716 A:middle
to talk about today, because
OpenCL has really allowed us

00:48:19.786 --> 00:48:20.686 A:middle
to do some great stuff.

00:48:21.626 --> 00:48:25.706 A:middle
So now I want to
show you a demo.

00:48:28.226 --> 00:48:32.446 A:middle
So here we have Adobe Premiere
Pro CC, and I'm just going

00:48:32.446 --> 00:48:33.286 A:middle
to start playing back here.

00:48:33.286 --> 00:48:36.076 A:middle
This is a real project
done in Premiere Pro.

00:48:36.716 --> 00:48:40.106 A:middle
This is the documentary
about Danny Kaye from Waiting

00:48:40.106 --> 00:48:43.626 A:middle
for Lightning, and everything
you're seeing here is processed

00:48:43.626 --> 00:48:45.636 A:middle
on the GPU using OpenCL.

00:48:46.096 --> 00:48:48.316 A:middle
You read the files off disk
on the CPU, you put them

00:48:48.316 --> 00:48:49.926 A:middle
up onto the GPU and
everything that's going

00:48:49.926 --> 00:48:50.956 A:middle
on here is on the GPU.

00:48:51.716 --> 00:48:53.236 A:middle
I know 4Ks all the rage; some

00:48:53.486 --> 00:48:55.456 A:middle
of this footage is
5K from the Red Epic.

00:48:56.266 --> 00:48:58.246 A:middle
There's no proxies, this
is all full res stuff.

00:48:58.306 --> 00:49:02.106 A:middle
We're mixing Canon 5 Vmark 2
footage, we're mixing DNHXD,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:02.286 --> 00:49:06.586 A:middle
pro res, red, red epic, 54K,
all on this timeline here.

00:49:06.756 --> 00:49:10.026 A:middle
All the effects you're seeing
are being done on OpenCL.

00:49:10.236 --> 00:49:14.106 A:middle
So this is really how you can
change the way you use your

00:49:14.106 --> 00:49:16.316 A:middle
applications using OpenCL.

00:49:16.316 --> 00:49:18.016 A:middle
So that's pretty exciting.

00:49:18.016 --> 00:49:19.466 A:middle
So I want to show you
one other section here.

00:49:19.466 --> 00:49:21.876 A:middle
And so what I'm going
to do here is I'm going

00:49:22.596 --> 00:49:25.016 A:middle
to start playing back this
section of the timeline

00:49:25.016 --> 00:49:26.026 A:middle
and just put it on loop.

00:49:26.456 --> 00:49:31.756 A:middle
So here we can now go in and go
into my timeline here and look

00:49:31.756 --> 00:49:36.896 A:middle
for a color corrector in here
and just add that to this clip.

00:49:36.946 --> 00:49:39.516 A:middle
And now you can go over here

00:49:39.616 --> 00:49:44.906 A:middle
and you can very easily start
change the creative look

00:49:44.906 --> 00:49:47.616 A:middle
of that effect in Realtime
while they're playing back.

00:49:48.976 --> 00:49:50.296 A:middle
Now, that's pretty
exciting, right.

00:49:50.296 --> 00:49:52.186 A:middle
That changes the way you
can really edit video.

00:49:52.556 --> 00:49:55.006 A:middle
While it's playing back you
can start adding effects to it.

00:49:55.006 --> 00:49:56.826 A:middle
But I did show you
that last year

00:49:56.826 --> 00:49:58.286 A:middle
but this is actually
something different.

00:49:58.286 --> 00:50:01.056 A:middle
This isn't a single
clip in the timeline.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:01.306 --> 00:50:03.056 A:middle
This is a clip composite
with a bunch of other clips,

00:50:03.056 --> 00:50:06.026 A:middle
but that clip itself is a
nested sequence with a bunch

00:50:06.026 --> 00:50:07.486 A:middle
of other video files in it.

00:50:07.836 --> 00:50:11.166 A:middle
That's an extremely complex
set of composites that I'm able

00:50:11.166 --> 00:50:14.646 A:middle
to add a color correction to
and actually edit in real time.

00:50:15.056 --> 00:50:16.126 A:middle
So that's pretty exciting.

00:50:16.126 --> 00:50:22.496 A:middle
And this is in a Macbook
Pro retina using 5K footage

00:50:22.786 --> 00:50:25.456 A:middle
in real time editing
without any proxies.

00:50:25.456 --> 00:50:26.616 A:middle
So that's pretty exciting right,

00:50:26.616 --> 00:50:28.316 A:middle
and that's all possible
because of OpenCL.

00:50:28.316 --> 00:50:33.376 A:middle
So I talked a little bit about
the Lumetri deep color engine,

00:50:33.896 --> 00:50:35.536 A:middle
so here's another movie clip.

00:50:35.536 --> 00:50:37.186 A:middle
This is from a movie
called "Whalen's Song."

00:50:37.876 --> 00:50:41.316 A:middle
And here you can see it looks
like, it's good, it's pretty,

00:50:41.516 --> 00:50:43.146 A:middle
but this is sort of how
it comes off the camera.

00:50:44.066 --> 00:50:45.826 A:middle
And that looks nice,
but let's try

00:50:45.826 --> 00:50:47.986 A:middle
to make this look a
little bit more cinematic.

00:50:48.316 --> 00:50:49.956 A:middle
It's what you'd expect
to see in teh theater.

00:50:50.396 --> 00:50:51.716 A:middle
So the first thing I'm going
to do is I'm going to just put

00:50:51.716 --> 00:50:56.856 A:middle
down a mat so you get that sort
of cinematic wide screen look,

00:50:57.376 --> 00:50:59.786 A:middle
and I'm going to go into my
what we call a looks browser.

00:50:59.786 --> 00:51:02.746 A:middle
So looks are very
complex descriptions

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:02.746 --> 00:51:06.266 A:middle
of what you can do
with video grading.

00:51:07.316 --> 00:51:10.186 A:middle
So it's not just a
color correction;

00:51:10.186 --> 00:51:13.856 A:middle
it can add vignettes, masks,
feathering, very complex stuff

00:51:13.856 --> 00:51:16.086 A:middle
to creatively change the
way your video looks.

00:51:16.086 --> 00:51:18.486 A:middle
So this is our look
browser and these are

00:51:18.486 --> 00:51:19.436 A:middle
like I said everything in there.

00:51:19.436 --> 00:51:22.336 A:middle
I'm just going to apply
that to an adjustment layer.

00:51:23.066 --> 00:51:25.516 A:middle
And all of a sudden,
you know have a sort

00:51:25.516 --> 00:51:27.596 A:middle
of a more cinematic
look to your video.

00:51:27.596 --> 00:51:30.316 A:middle
This is very complex way,
and this is what you can do

00:51:30.316 --> 00:51:31.636 A:middle
when you're shooting with
some of these new cameras

00:51:31.636 --> 00:51:33.636 A:middle
that are shooting
in logC and you want

00:51:33.636 --> 00:51:36.556 A:middle
to give your director
much more of a look

00:51:36.556 --> 00:51:37.556 A:middle
of what your film's
going to look

00:51:37.556 --> 00:51:38.796 A:middle
like when it goes
to the big screen.

00:51:39.096 --> 00:51:40.586 A:middle
You can do this now
in the process

00:51:40.586 --> 00:51:42.406 A:middle
of editing video in real time.

00:51:42.716 --> 00:51:44.936 A:middle
This is all happening
on the GPU using OpenCL.

00:51:45.356 --> 00:51:46.196 A:middle
So we're really excited

00:51:46.196 --> 00:51:48.176 A:middle
about the way OpenCL's
allowing our users to do things

00:51:48.176 --> 00:51:50.946 A:middle
that they could never actually
do before in a video editor.

00:51:51.386 --> 00:51:53.086 A:middle
So that's Adobe Premiere Pro CC

00:51:53.086 --> 00:51:55.576 A:middle
and all the great improvements
we made with OpenCL.

00:51:56.256 --> 00:52:07.626 A:middle
So thank you very much, and I'm
going to give it back to Abe.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:07.626 --> 00:52:07.693 A:middle
[ Applause ]

00:52:07.693 --> 00:52:07.916 A:middle
&gt;&gt; Abe: Okay.

00:52:08.426 --> 00:52:11.476 A:middle
Well, thanks for coming
this session and listening

00:52:11.476 --> 00:52:13.676 A:middle
to what we had to tell you here

00:52:13.676 --> 00:52:16.116 A:middle
about using OpenCL
and Mavericks.

00:52:16.396 --> 00:52:20.556 A:middle
If you have more questions
about using OpenCL and 10.9

00:52:20.556 --> 00:52:22.716 A:middle
or about anything that you
saw here in this session,

00:52:23.116 --> 00:52:26.876 A:middle
you should talk to Alan
Schaefer who's our Graphics

00:52:26.876 --> 00:52:28.516 A:middle
and Games Technology evangelist.

00:52:28.906 --> 00:52:30.856 A:middle
Also, there are a couple
of related sessions

00:52:30.856 --> 00:52:31.976 A:middle
that you might want
to take a look at.

00:52:32.606 --> 00:52:35.936 A:middle
Now, the first session here
actually happened earlier today

00:52:36.326 --> 00:52:38.036 A:middle
in this room.

00:52:38.036 --> 00:52:39.556 A:middle
It was the OpenGL session.

00:52:39.816 --> 00:52:43.186 A:middle
There's also a session on Core
Image, which is the technology

00:52:43.296 --> 00:52:45.576 A:middle
in Mavericks that uses OpenCL

00:52:45.896 --> 00:52:47.656 A:middle
and thanks very much
for your attention.

00:52:48.156 --> 00:53:02.400 A:middle
[ Applause ]

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

