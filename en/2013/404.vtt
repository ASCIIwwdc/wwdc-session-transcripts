WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:09.516 A:middle
[ Silence ]

00:00:10.016 --> 00:00:14.000 A:middle
[ Applause ]

00:00:15.326 --> 00:00:16.076 A:middle
&gt;&gt; Good afternoon.

00:00:17.186 --> 00:00:20.116 A:middle
My name is Doug Gregor and I'm
here today to talk today to you

00:00:20.276 --> 00:00:22.196 A:middle
about Advances in Objective-C.

00:00:23.786 --> 00:00:27.906 A:middle
Objective-C is a great language
with the vibrant user community.

00:00:28.846 --> 00:00:31.776 A:middle
If you're here last year,
you saw that we are really,

00:00:31.836 --> 00:00:33.966 A:middle
really excited that
we could see this here

00:00:33.966 --> 00:00:35.876 A:middle
in the TIOBE Programming
Community Index.

00:00:35.876 --> 00:00:38.096 A:middle
This is from May 2012.

00:00:38.806 --> 00:00:40.916 A:middle
And we see that Objective-C
had moved all the way

00:00:40.916 --> 00:00:42.526 A:middle
up to fourth place
in the rankings.

00:00:42.856 --> 00:00:43.796 A:middle
Just pretty amazing.

00:00:44.666 --> 00:00:47.946 A:middle
Well in just the last
year, Objective-C has moved

00:00:47.946 --> 00:00:51.376 A:middle
up even further displacing
the vulnerable C++

00:00:51.376 --> 00:00:52.846 A:middle
for the number three spot.

00:00:52.846 --> 00:00:53.586 A:middle
Whoo!

00:00:54.516 --> 00:00:59.306 A:middle
[ Applause ]

00:00:59.806 --> 00:01:01.526 A:middle
So how do we evolve
the Objective-C?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:01.886 --> 00:01:04.296 A:middle
Well, there are some
things that we focus on.

00:01:04.676 --> 00:01:07.486 A:middle
The two things in general that
we really do want to focus

00:01:07.486 --> 00:01:10.016 A:middle
on are developer
productivity, that's your time,

00:01:10.686 --> 00:01:13.336 A:middle
and software quality,
that's the quality that goes

00:01:13.336 --> 00:01:14.506 A:middle
into your applications.

00:01:14.976 --> 00:01:17.336 A:middle
And we can improve
both of these things

00:01:17.946 --> 00:01:20.506 A:middle
through evolving the language
and the tools that support it.

00:01:21.626 --> 00:01:25.026 A:middle
So in the realm of developer
productivity, we can do things

00:01:25.026 --> 00:01:27.316 A:middle
like find places where
there's boilerplate,

00:01:27.316 --> 00:01:30.256 A:middle
you're writing the same thing
over and over and over again,

00:01:30.256 --> 00:01:33.546 A:middle
at synthesize, at synthesize,
at synthesize, and eliminate

00:01:33.546 --> 00:01:36.276 A:middle
that from the language by
getting the right defaults.

00:01:36.676 --> 00:01:39.806 A:middle
Second, we can find other
operations that you do day in

00:01:39.806 --> 00:01:42.316 A:middle
and day out throughout many,
many different code bases

00:01:42.536 --> 00:01:45.036 A:middle
and simplify them, bring the
syntax into the language,

00:01:45.036 --> 00:01:49.746 A:middle
make them easier to use, faster
to write, faster to read.

00:01:49.746 --> 00:01:52.146 A:middle
And finally, we can
provide great tools

00:01:52.196 --> 00:01:55.336 A:middle
because you use tools to
write codes in Objective-C.

00:01:55.696 --> 00:01:59.186 A:middle
And part of this is developing
the tools themselves and part

00:01:59.186 --> 00:02:02.186 A:middle
of this is making sure that
the language itself is amenable

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:02.186 --> 00:02:03.326 A:middle
to building great tools.

00:02:03.326 --> 00:02:06.246 A:middle
We'll actually get back to that
with our first major feature.

00:02:07.456 --> 00:02:09.556 A:middle
The other area is
software quality

00:02:09.556 --> 00:02:12.026 A:middle
and how can we help there
through the language.

00:02:12.856 --> 00:02:13.756 A:middle
So, couple of areas.

00:02:13.846 --> 00:02:16.246 A:middle
We can try to catch
more bugs earlier.

00:02:16.686 --> 00:02:20.646 A:middle
You can do this through stronger
and better static type safety

00:02:21.056 --> 00:02:23.476 A:middle
so the compiler can reason
about the type in your program

00:02:23.476 --> 00:02:25.946 A:middle
and warn when something
is going wrong.

00:02:26.166 --> 00:02:30.086 A:middle
Next, we can find error
prone tasks, for example,

00:02:30.086 --> 00:02:33.576 A:middle
writing retain and release
everywhere, automate those away

00:02:33.576 --> 00:02:36.736 A:middle
within the compiler to eliminate
huge classes of problems.

00:02:38.056 --> 00:02:40.916 A:middle
And finally, Objective-C is a
language with a rich history.

00:02:40.916 --> 00:02:42.666 A:middle
We have a large developer
community

00:02:42.666 --> 00:02:45.316 A:middle
that has established
best practices for how

00:02:45.316 --> 00:02:46.866 A:middle
to use this language well.

00:02:46.866 --> 00:02:49.366 A:middle
And we can bring those
into the language

00:02:49.366 --> 00:02:50.926 A:middle
to help you build
better software.

00:02:52.376 --> 00:02:54.836 A:middle
Today, we're going to talk
about a couple of things.

00:02:55.246 --> 00:02:57.176 A:middle
We're going to talk about a new
Objective-C language feature

00:02:57.336 --> 00:02:58.426 A:middle
called Modules.

00:02:58.426 --> 00:03:01.666 A:middle
We're also going to talk
about better productivity

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:01.786 --> 00:03:03.276 A:middle
in the use of Objective-C.

00:03:03.626 --> 00:03:05.106 A:middle
And finally, some improvements

00:03:05.106 --> 00:03:10.176 A:middle
to Automatic Reference
Counting or ARC.

00:03:10.446 --> 00:03:16.006 A:middle
Modules. So, the idea behind
Modules is that if you look

00:03:16.006 --> 00:03:19.166 A:middle
at applications built
for iOS and OS X,

00:03:19.246 --> 00:03:23.506 A:middle
at the core of these
applications is the use of a ton

00:03:23.506 --> 00:03:25.436 A:middle
of really great systems
frameworks.

00:03:26.246 --> 00:03:28.166 A:middle
This is how you integrate
with services

00:03:28.236 --> 00:03:30.576 A:middle
like iCloud or with Game Center.

00:03:30.966 --> 00:03:33.636 A:middle
Maybe it's using
iAd to introduce ads

00:03:33.636 --> 00:03:36.716 A:middle
into your application or
core location services

00:03:37.476 --> 00:03:39.866 A:middle
so that you give your
user relevant content

00:03:39.916 --> 00:03:41.836 A:middle
where they at right now.

00:03:42.876 --> 00:03:45.316 A:middle
And so, this is sort of
the foundational layer

00:03:45.316 --> 00:03:48.736 A:middle
on which you build all of the
magic of your applications.

00:03:49.326 --> 00:03:51.326 A:middle
So we looked at the
process of how is it

00:03:51.326 --> 00:03:52.346 A:middle
that you use a framework.

00:03:53.156 --> 00:03:54.986 A:middle
Well, first, you go into Xcode.

00:03:54.986 --> 00:03:56.056 A:middle
You go into your coding window.

00:03:56.746 --> 00:03:58.666 A:middle
You write the #import for
the framework you want.

00:03:58.916 --> 00:04:01.176 A:middle
In this case, we're going
to pull in iAd and use

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:01.176 --> 00:04:02.696 A:middle
that as our demonstration.

00:04:03.096 --> 00:04:05.466 A:middle
And the name is really
important, so you see iAd twice

00:04:05.466 --> 00:04:09.906 A:middle
when you import iAd/iAd.h.
That's fine.

00:04:09.906 --> 00:04:12.066 A:middle
You start writing your
code to the iAd framework,

00:04:12.066 --> 00:04:13.916 A:middle
use some tutorial
samples and so on.

00:04:14.196 --> 00:04:16.906 A:middle
You hit Build and you get
the dreaded link error.

00:04:17.555 --> 00:04:20.636 A:middle
If this is the first time you've
seen this, this is horrifying

00:04:20.636 --> 00:04:22.666 A:middle
and you have to search to
see what actually went wrong.

00:04:23.056 --> 00:04:25.016 A:middle
But of course seasoned
developers know.

00:04:25.296 --> 00:04:26.896 A:middle
Fine, there's several
ways to fix this.

00:04:26.896 --> 00:04:28.926 A:middle
You can go edit the project,

00:04:28.926 --> 00:04:32.056 A:middle
just go over to the build
phases, just close the triangle,

00:04:32.126 --> 00:04:34.746 A:middle
hit the Plus, go find
the framework again.

00:04:34.746 --> 00:04:37.196 A:middle
We said iAd three times
now if you're counting.

00:04:37.796 --> 00:04:40.496 A:middle
Hit Add and we can actually
build our application,

00:04:41.346 --> 00:04:42.786 A:middle
not exactly wonderful.

00:04:43.456 --> 00:04:46.606 A:middle
And both of these steps
are very disjointed.

00:04:46.636 --> 00:04:49.456 A:middle
We have the #import which is
what you write in your code

00:04:49.456 --> 00:04:51.366 A:middle
and then we have the
addition of the library

00:04:51.366 --> 00:04:53.216 A:middle
which is something you
do in Xcode, elsewhere.

00:04:53.896 --> 00:04:56.416 A:middle
And so, let's go back to
the #import side of things

00:04:56.816 --> 00:05:00.356 A:middle
because #import is a
teeny tiny innovation

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.666 --> 00:05:04.036 A:middle
over the basic #include
that's been in C for three,

00:05:04.126 --> 00:05:06.136 A:middle
four decades based
on the preprocessor.

00:05:06.766 --> 00:05:09.106 A:middle
And so, we're going to look a
little bit at how the #import

00:05:09.106 --> 00:05:10.796 A:middle
and #include actually work.

00:05:10.866 --> 00:05:14.176 A:middle
So you have your application,
some .m file from it.

00:05:14.176 --> 00:05:18.306 A:middle
And what it does is it
#imports iAd.h. Fine,

00:05:18.306 --> 00:05:19.056 A:middle
what does that actually do?

00:05:19.056 --> 00:05:22.166 A:middle
Well, it resolves iAd.h and
the compiler goes and hunts

00:05:22.166 --> 00:05:24.486 A:middle
for the next thing
that iAd included

00:05:24.486 --> 00:05:26.076 A:middle
and the next thing
that that included.

00:05:26.366 --> 00:05:29.066 A:middle
Eventually, we get back to
UIKit and all of its headers

00:05:29.066 --> 00:05:30.506 A:middle
and all the things
that that brings in.

00:05:30.506 --> 00:05:33.146 A:middle
And so, really, the
dependency that you have

00:05:33.616 --> 00:05:36.386 A:middle
from your data .m is
out to a whole bunch

00:05:36.386 --> 00:05:40.346 A:middle
of different header
files within the SDK.

00:05:40.576 --> 00:05:44.236 A:middle
How does this actually
work as the language model?

00:05:44.356 --> 00:05:47.146 A:middle
Well, again, this is the C
model of the preprocessor.

00:05:47.146 --> 00:05:48.946 A:middle
It's essentially
textual inclusion

00:05:49.246 --> 00:05:51.386 A:middle
or a fancy form of
cut and paste.

00:05:51.956 --> 00:05:55.176 A:middle
So, here we have, you know,
simple .m for an app delegate.

00:05:55.506 --> 00:05:57.776 A:middle
It imports iAd.h.
What's that do?

00:05:58.376 --> 00:05:59.386 A:middle
First thing compiler does,

00:05:59.386 --> 00:06:03.776 A:middle
go find what is iAd/iAd.h
actually refers to and it comes

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:03.776 --> 00:06:04.846 A:middle
up with a file on disk.

00:06:05.626 --> 00:06:08.836 A:middle
Fine, it copies that
file, preprocess it,

00:06:09.206 --> 00:06:15.496 A:middle
and pastes the results
into our .m at the end.

00:06:15.546 --> 00:06:17.536 A:middle
Okay. And then what do we have?

00:06:17.536 --> 00:06:18.356 A:middle
More imports.

00:06:18.726 --> 00:06:20.886 A:middle
So we go hunt for the next file.

00:06:21.056 --> 00:06:25.256 A:middle
Take its text, copy it,
preprocess it, paste it in,

00:06:25.256 --> 00:06:27.266 A:middle
and the .m gets as
little longer.

00:06:27.346 --> 00:06:30.646 A:middle
And we go hunt for more files
and we copy and paste those in.

00:06:30.646 --> 00:06:33.976 A:middle
And once you get at the
end is one big long .m

00:06:33.976 --> 00:06:36.746 A:middle
which is what the
compiler actually sees

00:06:36.976 --> 00:06:38.696 A:middle
for each .m file in
your application.

00:06:40.036 --> 00:06:42.016 A:middle
This model has been
working for decades,

00:06:42.096 --> 00:06:44.316 A:middle
so what's wrong with it?

00:06:44.316 --> 00:06:46.006 A:middle
Well, it has two problems.

00:06:46.006 --> 00:06:47.226 A:middle
The first problem
we're going to talk

00:06:47.226 --> 00:06:49.656 A:middle
about is it's a very
fragile model.

00:06:49.656 --> 00:06:51.776 A:middle
So I'm going to do
something here

00:06:51.776 --> 00:06:53.246 A:middle
that may make a few
of you cringe.

00:06:53.606 --> 00:06:57.226 A:middle
I'm going to define a
constant read-only to 0x01

00:06:57.226 --> 00:07:00.416 A:middle
because that makes sense for
my .m, for my application code.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:00.466 --> 00:07:05.766 A:middle
And I happen to do that
before #importing iAd.h. See,

00:07:05.766 --> 00:07:08.016 A:middle
preprocessor does
what its design to do.

00:07:08.306 --> 00:07:10.856 A:middle
It goes and hunts down
these files, copies them,

00:07:10.956 --> 00:07:13.126 A:middle
preprocess them,
paste the result,

00:07:13.566 --> 00:07:15.566 A:middle
and we end up with
this file up here

00:07:15.566 --> 00:07:17.846 A:middle
which is the .m the
compiler sees.

00:07:18.886 --> 00:07:22.116 A:middle
The compiler is not going to
like this .m and it's going

00:07:22.116 --> 00:07:25.456 A:middle
to complain, 0x01 is not a
valid property attribute,

00:07:25.826 --> 00:07:26.896 A:middle
it is very correct.

00:07:27.896 --> 00:07:31.056 A:middle
The really unfortunate
thing here is that the error

00:07:31.056 --> 00:07:32.706 A:middle
that you get is in
the system headers.

00:07:32.706 --> 00:07:34.826 A:middle
That's not code you wrote and

00:07:34.826 --> 00:07:39.256 A:middle
yet somehow you accidentally
broke it just by doing something

00:07:39.326 --> 00:07:41.546 A:middle
where you defined the local
constant in your header file.

00:07:41.956 --> 00:07:43.946 A:middle
And now, you can blame
me for doing this.

00:07:43.946 --> 00:07:45.656 A:middle
I'm the one that write--
wrote this code in this slide.

00:07:45.786 --> 00:07:49.636 A:middle
Clearly, it's my fault because
what I should have done is used

00:07:49.906 --> 00:07:54.186 A:middle
a prefixed very long
uppercase name for my constant

00:07:54.216 --> 00:07:55.826 A:middle
because that's what
we do with macros.

00:07:56.126 --> 00:07:57.976 A:middle
It's the convention
that we've established

00:07:58.016 --> 00:08:00.836 A:middle
within the C programming
world to cope

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.836 --> 00:08:02.886 A:middle
with this fragility problem.

00:08:03.146 --> 00:08:05.286 A:middle
And so, this doesn't
happen often

00:08:05.286 --> 00:08:06.436 A:middle
that you hit these problems.

00:08:06.646 --> 00:08:09.036 A:middle
But we do hit them
in programming.

00:08:09.036 --> 00:08:10.576 A:middle
And usually, they
come in as some sort

00:08:10.576 --> 00:08:11.776 A:middle
of header include-dependency.

00:08:12.216 --> 00:08:15.086 A:middle
Someone's header over here
didn't follow the rules.

00:08:15.086 --> 00:08:16.056 A:middle
He didn't get the memo.

00:08:16.396 --> 00:08:18.396 A:middle
And it stomps on
another header over here.

00:08:18.396 --> 00:08:21.086 A:middle
And if you include them in
one order, things work fine,

00:08:21.086 --> 00:08:23.756 A:middle
or with one version of some
framework, it works fine.

00:08:24.206 --> 00:08:25.746 A:middle
You migrate to another
version and, suddenly,

00:08:25.746 --> 00:08:27.646 A:middle
there's a conflict
that you get to debug.

00:08:27.866 --> 00:08:30.566 A:middle
If you're lucky, it manifests
an error that's fairly easy

00:08:30.566 --> 00:08:31.276 A:middle
to track down.

00:08:31.996 --> 00:08:35.035 A:middle
If you're not so lucky, it could
actually be a runtime that's

00:08:35.176 --> 00:08:37.356 A:middle
really hard to track down
for something that ends

00:08:37.356 --> 00:08:39.096 A:middle
up being just flipping
to include.

00:08:39.726 --> 00:08:43.676 A:middle
So this is a problem that we
deal with but we've been working

00:08:43.746 --> 00:08:45.196 A:middle
through it through
our conventions.

00:08:45.576 --> 00:08:46.156 A:middle
It's fine.

00:08:47.076 --> 00:08:48.926 A:middle
The real issue here, however,

00:08:48.926 --> 00:08:51.866 A:middle
is that this whole model
is inherently not scalable.

00:08:52.436 --> 00:08:56.726 A:middle
And so, to see this, we took
all of the .m files in iOS Mail

00:08:56.756 --> 00:08:59.176 A:middle
and we plot them according
to their size on disk.

00:08:59.806 --> 00:09:02.386 A:middle
So it's got, you know,
about 250 .ms here

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:02.756 --> 00:09:05.246 A:middle
and you can see they range
from half a kilobyte up to

00:09:05.246 --> 00:09:09.156 A:middle
about 200 kilobytes in
size with a very large skew

00:09:09.186 --> 00:09:10.676 A:middle
with really tiny files.

00:09:10.676 --> 00:09:13.446 A:middle
And we see this across the
numerous projects that you tend

00:09:13.446 --> 00:09:15.806 A:middle
to have many, many
small .m files.

00:09:17.096 --> 00:09:20.546 A:middle
Now, we've added iAd.h,
an import of iAd.h

00:09:20.696 --> 00:09:23.136 A:middle
into a fairly central header.

00:09:23.586 --> 00:09:25.606 A:middle
So what that really means
is for all these .m files,

00:09:25.606 --> 00:09:27.476 A:middle
we're not just parsing
what's in the .m file,

00:09:27.476 --> 00:09:30.356 A:middle
we're also parsing
everything that's in iAd.

00:09:30.466 --> 00:09:34.196 A:middle
iAd is a fairly small
framework and the headers come

00:09:34.196 --> 00:09:35.896 A:middle
in about 25 kilobytes.

00:09:35.946 --> 00:09:39.546 A:middle
So, for many of these
files, just the size

00:09:39.786 --> 00:09:42.786 A:middle
of iAd works the size
of the actual code

00:09:42.786 --> 00:09:44.966 A:middle
that you wrote in your .m file.

00:09:45.916 --> 00:09:47.476 A:middle
Of course, iAd isn't standalone

00:09:47.476 --> 00:09:49.626 A:middle
and everyone needs
UIKit everywhere

00:09:49.626 --> 00:09:52.236 A:middle
and UIKit is more
like 400 kilobytes.

00:09:53.336 --> 00:09:56.456 A:middle
Okay. So now, our tiny
little files which is most

00:09:56.456 --> 00:10:01.906 A:middle
of what's here are actually
going through 425 kilobytes

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:01.906 --> 00:10:03.596 A:middle
of header files pulling
all those

00:10:03.596 --> 00:10:07.276 A:middle
in from disk parsing
them just to get

00:10:07.276 --> 00:10:09.266 A:middle
at your tiny little bit of code.

00:10:10.306 --> 00:10:11.406 A:middle
And if you think this is bad,

00:10:11.406 --> 00:10:14.136 A:middle
this is iOS where UIKit
is actually fairly small.

00:10:14.436 --> 00:10:19.096 A:middle
So, on OS X, the Cocoa framework
that you pull in everywhere,

00:10:19.096 --> 00:10:23.096 A:middle
it's about 29 times
larger than UIKit.

00:10:23.226 --> 00:10:26.556 A:middle
So you can't even see the
.m files, your own code

00:10:26.556 --> 00:10:27.796 A:middle
in this kind of chart.

00:10:28.276 --> 00:10:32.356 A:middle
So what this presents is
inherent scalability problem.

00:10:32.356 --> 00:10:34.166 A:middle
You can't scale with
a system like this

00:10:34.216 --> 00:10:36.306 A:middle
because you have
your M source files

00:10:36.456 --> 00:10:38.316 A:middle
and you have the N headers.

00:10:39.476 --> 00:10:41.986 A:middle
That's the storage
on disk, M plus N.

00:10:42.046 --> 00:10:44.526 A:middle
But the time to compile
is M times N

00:10:44.526 --> 00:10:46.956 A:middle
because you're reparsing
every one of those headers

00:10:46.956 --> 00:10:48.456 A:middle
for all of your .m files.

00:10:48.566 --> 00:10:51.476 A:middle
And of course, both
M and N are growing

00:10:51.836 --> 00:10:54.656 A:middle
as you build your applications
and add more code to them

00:10:54.976 --> 00:10:59.936 A:middle
and as the system adds more
frameworks and APIs to them.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:00.126 --> 00:11:03.426 A:middle
So clearly, it can't be this
horrible or I'll be screaming

00:11:03.426 --> 00:11:05.016 A:middle
at us to fix the
compile time issue.

00:11:05.466 --> 00:11:08.686 A:middle
And so, one of that features
that we've had for a long time

00:11:08.686 --> 00:11:11.306 A:middle
to try to solve this
is precompiled headers.

00:11:12.206 --> 00:11:14.626 A:middle
And so, precompiled headers
actually do help a lot.

00:11:14.676 --> 00:11:15.866 A:middle
The idea is fairly simple.

00:11:16.226 --> 00:11:18.396 A:middle
You take some subset of
headers that's common

00:11:18.396 --> 00:11:21.866 A:middle
across your entire project,
like maybe all of UIKit.

00:11:21.866 --> 00:11:25.256 A:middle
And you compile it once
into some efficient

00:11:25.446 --> 00:11:26.896 A:middle
on disk representation.

00:11:27.726 --> 00:11:29.746 A:middle
And then whenever
you build a .m file,

00:11:29.996 --> 00:11:31.706 A:middle
you load that representation
first,

00:11:31.706 --> 00:11:33.376 A:middle
that binary representation
that's fast,

00:11:33.676 --> 00:11:36.216 A:middle
no parsing, and start
from there.

00:11:36.866 --> 00:11:38.556 A:middle
Now, this is great
because you don't have

00:11:38.556 --> 00:11:40.906 A:middle
to parse UIKit or Cocoa.

00:11:40.906 --> 00:11:43.706 A:middle
And in fact, when you started
with your project with Xcode,

00:11:43.706 --> 00:11:46.206 A:middle
you got a precompiled
header for UIKit or Cocoa

00:11:46.206 --> 00:11:47.326 A:middle
for free as you started.

00:11:48.206 --> 00:11:51.136 A:middle
But anything else that you've
added later on, when you add

00:11:51.136 --> 00:11:54.816 A:middle
that #import of iAd.h
is still being parsed

00:11:54.816 --> 00:11:56.146 A:middle
over and over again.

00:11:57.176 --> 00:11:59.106 A:middle
You could fix this if
you really wanted to.

00:11:59.426 --> 00:12:01.626 A:middle
You could extend your
precompiled header

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:01.756 --> 00:12:04.416 A:middle
to include iAd.h. And now,

00:12:04.416 --> 00:12:06.186 A:middle
you're no longer
parsing this every time.

00:12:06.226 --> 00:12:08.406 A:middle
What we've seen, however,

00:12:08.406 --> 00:12:11.216 A:middle
is that developers don't
generally maintain their

00:12:11.266 --> 00:12:12.276 A:middle
precompiled headers.

00:12:12.646 --> 00:12:14.686 A:middle
A few people do and
they see more benefits

00:12:14.686 --> 00:12:15.866 A:middle
out of precompiled headers.

00:12:16.236 --> 00:12:19.176 A:middle
But most don't, partly because
they don't know about it,

00:12:19.176 --> 00:12:22.146 A:middle
partly because they don't want
to be optimizing for our tools.

00:12:22.796 --> 00:12:26.666 A:middle
But also, there's another
reason you might want to this

00:12:26.666 --> 00:12:29.196 A:middle
and that's using
precompiled headers introduces

00:12:29.196 --> 00:12:30.116 A:middle
namespace pollution.

00:12:30.646 --> 00:12:34.426 A:middle
You may not want to have iAd in
every part of your application.

00:12:34.426 --> 00:12:36.726 A:middle
It maybe fairly centralized
but putting it

00:12:36.726 --> 00:12:39.696 A:middle
into your precompiled header
makes it available everywhere.

00:12:39.696 --> 00:12:40.796 A:middle
So they're always showing

00:12:40.796 --> 00:12:42.866 A:middle
up in code completion
results, for example.

00:12:43.156 --> 00:12:44.256 A:middle
It's always available.

00:12:44.256 --> 00:12:46.486 A:middle
And so, there's principle
reasons for not wanting

00:12:46.486 --> 00:12:47.856 A:middle
to use precompiled
headers anywhere.

00:12:48.486 --> 00:12:52.416 A:middle
So Modules are designed to
solve these two problems,

00:12:53.226 --> 00:12:55.636 A:middle
the problem of the inherent
scalability problem of headers

00:12:55.636 --> 00:12:57.556 A:middle
and also the fragility
problem of headers.

00:12:58.716 --> 00:13:00.156 A:middle
So what are these Modules?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:00.586 --> 00:13:02.986 A:middle
So think of them
as an encapsulation

00:13:03.046 --> 00:13:04.896 A:middle
of what a framework is.

00:13:05.206 --> 00:13:08.096 A:middle
It's API and its
corresponding implementation.

00:13:09.096 --> 00:13:11.946 A:middle
A Module is something that's
separately compiled all

00:13:11.946 --> 00:13:12.286 A:middle
the time.

00:13:12.756 --> 00:13:17.646 A:middle
So, it's compiled once and
set aside so that later

00:13:17.646 --> 00:13:19.816 A:middle
on your application
can import that Module,

00:13:19.816 --> 00:13:22.816 A:middle
get access to the API, get
access to the implementation

00:13:23.696 --> 00:13:25.726 A:middle
without having the go
through and parse the headers.

00:13:26.936 --> 00:13:28.396 A:middle
Now in support of Modules,

00:13:28.516 --> 00:13:30.656 A:middle
we introduced one
little bit of syntax.

00:13:31.256 --> 00:13:32.936 A:middle
It's the @import declaration.

00:13:33.906 --> 00:13:38.896 A:middle
What @import does is it pulls in
the API for a particular Module

00:13:38.896 --> 00:13:40.046 A:middle
which corresponds
to the framework.

00:13:40.276 --> 00:13:44.146 A:middle
So here, we're importing
the iAd frameworks API

00:13:44.396 --> 00:13:45.396 A:middle
into our application.

00:13:46.466 --> 00:13:48.896 A:middle
Now this is what we
call a Semantic Import

00:13:48.896 --> 00:13:51.756 A:middle
and it's very different from the
textual inclusion that you get

00:13:51.756 --> 00:13:54.216 A:middle
with headers 'cause
semantic import, of course,

00:13:54.296 --> 00:13:55.726 A:middle
it doesn't parse the headers

00:13:56.566 --> 00:13:59.916 A:middle
but it also doesn't let
the API that's exposed

00:13:59.916 --> 00:14:03.616 A:middle
by @import be changed by
any of your local context.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:03.616 --> 00:14:06.556 A:middle
So if I do this horrible
thing that I did earlier,

00:14:06.786 --> 00:14:10.826 A:middle
# defining read-only to
0x01, it's perfectly fine.

00:14:10.936 --> 00:14:15.516 A:middle
That doesn't change or break
the API of iAd in any way.

00:14:16.096 --> 00:14:20.346 A:middle
The API you get out of the iAd
Module is exactly as the authors

00:14:20.406 --> 00:14:21.736 A:middle
of iAd intended you to get.

00:14:21.826 --> 00:14:23.106 A:middle
You can't make mistake here.

00:14:23.676 --> 00:14:29.186 A:middle
Now, Modules can be thought
of as monolithic things,

00:14:29.186 --> 00:14:30.716 A:middle
like we often think
of frameworks

00:14:30.716 --> 00:14:31.786 A:middle
as a monolithic thing.

00:14:31.836 --> 00:14:35.966 A:middle
I want to get all of the API of
iAd, but you don't have to think

00:14:35.966 --> 00:14:37.046 A:middle
about frameworks this way.

00:14:37.046 --> 00:14:38.866 A:middle
And therefore, you don't have
to think about Modules this way.

00:14:39.346 --> 00:14:43.196 A:middle
And so, we can think of Modules
as being a larger structure,

00:14:43.196 --> 00:14:46.806 A:middle
so here we have the iAd Module
and their smaller pieces

00:14:46.806 --> 00:14:48.026 A:middle
which we call submodules.

00:14:48.176 --> 00:14:50.176 A:middle
So here, we have the
ADInterstitialAd,

00:14:50.176 --> 00:14:57.256 A:middle
the ADBannerView as submodules
within the iAd module itself.

00:14:57.556 --> 00:15:00.326 A:middle
We can import just
part of a framework

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:00.636 --> 00:15:02.716 A:middle
by writing @import of iAd.

00:15:02.716 --> 00:15:04.336 A:middle
and then one of the
submodule names.

00:15:04.336 --> 00:15:05.746 A:middle
In this case, it's ADBannerView.

00:15:05.746 --> 00:15:09.876 A:middle
And what that does is it gives
us just the API corresponding

00:15:09.876 --> 00:15:11.736 A:middle
to ADBannerView within iAd.

00:15:12.236 --> 00:15:14.326 A:middle
So from an API perspective,

00:15:14.326 --> 00:15:17.916 A:middle
this is giving you exactly the
same thing that you would get

00:15:17.916 --> 00:15:21.836 A:middle
out of #import of
iAd/ADBannerView.h. And in fact,

00:15:21.836 --> 00:15:23.666 A:middle
the frameworks and the sub--

00:15:23.666 --> 00:15:27.726 A:middle
the framework headers and the
submodules match up exactly.

00:15:27.726 --> 00:15:30.036 A:middle
It's something you can see if
you look at code completion

00:15:30.036 --> 00:15:32.416 A:middle
for example after @import iAd.

00:15:33.286 --> 00:15:37.186 A:middle
is the submodule structure here
to get at exactly what you want

00:15:37.186 --> 00:15:41.726 A:middle
and this match up exactly what
the file names that are there.

00:15:41.726 --> 00:15:45.436 A:middle
Now, once you've used @import,
you get the API of a framework.

00:15:46.246 --> 00:15:47.506 A:middle
You also get the implementation

00:15:47.506 --> 00:15:49.266 A:middle
for free via the
Autolinking feature.

00:15:50.156 --> 00:15:53.716 A:middle
And so, once you've
switch over to Modules

00:15:53.896 --> 00:15:56.046 A:middle
and you're importing
a particular Module,

00:15:56.046 --> 00:15:57.766 A:middle
the compiler is just
going to record

00:15:57.766 --> 00:16:00.766 A:middle
in the object files it
create what Modules you used

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:01.036 --> 00:16:03.516 A:middle
so that we'll automatically
link against these things

00:16:03.736 --> 00:16:05.856 A:middle
and you never have
to go in-- thank you.

00:16:06.516 --> 00:16:10.476 A:middle
[ Applause ]

00:16:10.976 --> 00:16:13.236 A:middle
Right. So you should not have
to go in and then link binary

00:16:13.236 --> 00:16:14.066 A:middle
with libraries anymore.

00:16:14.576 --> 00:16:16.556 A:middle
So what does it takes
to use Modules?

00:16:16.556 --> 00:16:19.276 A:middle
We've shown the new
syntax, the @import syntax.

00:16:20.296 --> 00:16:22.416 A:middle
So Modules are an
opting feature.

00:16:23.536 --> 00:16:25.786 A:middle
So you can opt in via
build setting and I'll show

00:16:25.786 --> 00:16:27.366 A:middle
in just a few moments.

00:16:28.476 --> 00:16:31.146 A:middle
And of course, once you've
opted in, you have access

00:16:31.146 --> 00:16:32.526 A:middle
to the @import syntax.

00:16:32.526 --> 00:16:37.206 A:middle
Now, you probably have
a couple of #imports

00:16:37.206 --> 00:16:38.936 A:middle
and maybe some #includes
in your code,

00:16:38.936 --> 00:16:41.316 A:middle
maybe a handful,
hundreds, thousands.

00:16:42.166 --> 00:16:44.236 A:middle
We don't actually want you to
have to go and rewrite those,

00:16:44.516 --> 00:16:46.376 A:middle
not even automatically.

00:16:46.376 --> 00:16:47.466 A:middle
Of course, we could
migrate them.

00:16:47.466 --> 00:16:50.106 A:middle
What we really want is you
to be able to turn on Modules

00:16:50.106 --> 00:16:51.866 A:middle
and go use the feature
immediately.

00:16:52.216 --> 00:16:52.976 A:middle
And so, the way we deal

00:16:52.976 --> 00:16:55.506 A:middle
with this is we actually
automatically remapped the

00:16:55.686 --> 00:16:57.986 A:middle
#includes and the #includes
in your source code.

00:16:58.426 --> 00:17:00.566 A:middle
When those refer to a
header that we know is part

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.566 --> 00:17:02.216 A:middle
of a Module, we just treat it

00:17:02.216 --> 00:17:05.066 A:middle
as if you had written
@import all along.

00:17:05.195 --> 00:17:07.136 A:middle
And the great thing
here is you don't have

00:17:07.205 --> 00:17:09.556 A:middle
to change your source
code to use Modules.

00:17:09.715 --> 00:17:12.066 A:middle
You just need to opt in
via the build settings.

00:17:12.756 --> 00:17:16.076 A:middle
The Modules, the @import
provides the exact same API

00:17:16.076 --> 00:17:19.596 A:middle
that you got before just
through a different mechanism

00:17:19.596 --> 00:17:21.945 A:middle
that is safer and
more efficient.

00:17:23.376 --> 00:17:26.685 A:middle
Now, all of the system
frameworks in iOS 7

00:17:26.685 --> 00:17:30.496 A:middle
and OS X Mavericks are
available as Modules.

00:17:31.226 --> 00:17:34.546 A:middle
And so, when you opt in to
Modules, anything you're using

00:17:34.546 --> 00:17:37.176 A:middle
from the system, any of those
system frameworks automatically

00:17:37.176 --> 00:17:41.196 A:middle
goes through this more
efficient, safer path.

00:17:41.376 --> 00:17:43.196 A:middle
You may be wondering, how
does this actually work

00:17:43.196 --> 00:17:43.746 A:middle
under the hood?

00:17:43.746 --> 00:17:45.286 A:middle
Well, let's take a quick look.

00:17:45.576 --> 00:17:51.926 A:middle
So, the basic idea is we have
this notion of Module Maps.

00:17:52.086 --> 00:17:56.936 A:middle
And a Module Map establishes a
relationship between the headers

00:17:57.026 --> 00:17:59.876 A:middle
that are part of the framework
and have always been there,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:00.326 --> 00:18:02.886 A:middle
and the actual logical
Module structure.

00:18:03.166 --> 00:18:04.826 A:middle
So here's a fragment
of a Module Map.

00:18:05.366 --> 00:18:08.586 A:middle
It defines the UIKit Module
based on the UIKit framework.

00:18:09.586 --> 00:18:13.186 A:middle
It says that to actually get
the contents of the UIKit model,

00:18:13.186 --> 00:18:15.276 A:middle
you parse the umbrella
header UIKit.h

00:18:15.546 --> 00:18:18.036 A:middle
which UIKit.h is what
you generally import.

00:18:18.036 --> 00:18:19.736 A:middle
So this is the same
API description.

00:18:20.406 --> 00:18:25.446 A:middle
And that anything that UIKit.h
itself imports becomes a

00:18:25.446 --> 00:18:26.966 A:middle
submodule within UIKit.

00:18:26.966 --> 00:18:29.286 A:middle
This is what reflects
the header structure

00:18:29.866 --> 00:18:31.726 A:middle
within the logical
Module structure.

00:18:33.046 --> 00:18:34.966 A:middle
And finally, you can
see Autolinking here

00:18:34.966 --> 00:18:37.736 A:middle
through the link framework
line here that says

00:18:37.806 --> 00:18:40.526 A:middle
when you actually use the
UIKit Module, you should link

00:18:40.526 --> 00:18:41.816 A:middle
against the UIKit framework.

00:18:42.996 --> 00:18:45.056 A:middle
Now, these Module Maps
are actually very crucial

00:18:45.446 --> 00:18:48.836 A:middle
because in our SDKs, we
don't ship Module binaries.

00:18:49.246 --> 00:18:51.766 A:middle
Instead, we ship headers
like we always have.

00:18:51.766 --> 00:18:55.286 A:middle
And when the compiler asks
for a Module, when you ask

00:18:55.286 --> 00:19:00.016 A:middle
to @import UIKit, the compiler
will find the Module Map,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:00.016 --> 00:19:01.486 A:middle
it tells it how to build UIKit

00:19:01.486 --> 00:19:04.506 A:middle
and effectively spawn a
separate compilation process

00:19:04.506 --> 00:19:08.896 A:middle
to go separately compile
UIkit.h into the UIKit Module

00:19:09.206 --> 00:19:11.736 A:middle
which is then cached in
Xcode's derived data.

00:19:12.216 --> 00:19:15.486 A:middle
So the next time you come
through and ask to import UIKit,

00:19:15.676 --> 00:19:17.956 A:middle
it's already there and
it's instantaneous to load.

00:19:18.336 --> 00:19:22.366 A:middle
So this is what breaks the M
times N scalability problem

00:19:22.366 --> 00:19:24.416 A:middle
down to actually
efficient compilation model.

00:19:24.416 --> 00:19:27.626 A:middle
So let's take a quick look at
what this does to build times?

00:19:28.126 --> 00:19:31.016 A:middle
So build times, of course, build
time for an entire project.

00:19:31.016 --> 00:19:32.666 A:middle
And so, we'll talk about
a couple of projects

00:19:32.666 --> 00:19:35.896 A:middle
at different scales and with
different levels of utilization

00:19:35.896 --> 00:19:37.476 A:middle
of the precompiled
headers feature.

00:19:37.896 --> 00:19:41.046 A:middle
So Xcode is a very, very
large Objective-C project,

00:19:41.306 --> 00:19:42.736 A:middle
a lot going on in the build.

00:19:43.356 --> 00:19:45.806 A:middle
And in fact, they've been
tuning their precompiled headers

00:19:45.806 --> 00:19:46.366 A:middle
for years.

00:19:46.656 --> 00:19:48.436 A:middle
And so, what we see when
we turn on Modules is

00:19:48.436 --> 00:19:50.706 A:middle
that they don't have to change
their source code at all.

00:19:50.706 --> 00:19:51.706 A:middle
It's just a build setting.

00:19:52.206 --> 00:19:53.706 A:middle
And they get a smallish win,

00:19:53.706 --> 00:19:55.716 A:middle
a couple of percent
win in the build time.

00:19:56.286 --> 00:19:58.336 A:middle
Since they had optimized
precompiled headers,

00:19:58.336 --> 00:19:59.446 A:middle
this isn't a huge surprise.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.906 --> 00:20:05.816 A:middle
Preview on the Mac is
actually a much smaller project

00:20:05.816 --> 00:20:06.606 A:middle
as you might expect.

00:20:06.906 --> 00:20:11.046 A:middle
Also, has fairly decent
precompiled header.

00:20:11.046 --> 00:20:14.006 A:middle
And so, you get a small
win [inaudible] larger win

00:20:14.306 --> 00:20:15.366 A:middle
out of using Modules.

00:20:15.366 --> 00:20:18.696 A:middle
Again, no source code-- yeah--
source code changes required,

00:20:19.296 --> 00:20:21.176 A:middle
so it's essentially a
free performance here.

00:20:21.876 --> 00:20:25.846 A:middle
And finally, the Mail
Application on iOS didn't have

00:20:25.846 --> 00:20:26.606 A:middle
such great use

00:20:26.606 --> 00:20:29.456 A:middle
of the precompiled headers
'cause they hadn't been actively

00:20:29.456 --> 00:20:30.256 A:middle
maintained, like most

00:20:30.256 --> 00:20:32.336 A:middle
of all operators don't actively
maintained their precompiled

00:20:32.336 --> 00:20:35.786 A:middle
headers and it's a huge
40 percent speed up just

00:20:35.786 --> 00:20:37.866 A:middle
from flipping the
switch, turning on Modules

00:20:37.866 --> 00:20:40.036 A:middle
and not doing anything
else, all right.

00:20:40.456 --> 00:20:41.656 A:middle
This is the elimination

00:20:41.656 --> 00:20:44.256 A:middle
of repeated header
processing really helping.

00:20:45.596 --> 00:20:48.456 A:middle
So now, build times or
overall project build times,

00:20:48.716 --> 00:20:50.766 A:middle
they're a little
bit messy in a sense

00:20:50.766 --> 00:20:52.336 A:middle
that we're not really
just measuring what the

00:20:52.336 --> 00:20:52.926 A:middle
compiler does.

00:20:52.926 --> 00:20:54.556 A:middle
There's a whole lot of
other things going on.

00:20:55.216 --> 00:20:58.616 A:middle
So, let's go to something
a little bit more heavy

00:20:58.616 --> 00:21:01.386 A:middle
on the parsing and
that is indexing.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:01.386 --> 00:21:03.786 A:middle
When an Xcode is
indexing your project,

00:21:03.786 --> 00:21:06.766 A:middle
it's parsing all the sources
in your project so it can build

00:21:06.766 --> 00:21:09.906 A:middle
that rich cross reference
to give you more information

00:21:09.906 --> 00:21:11.126 A:middle
at your fingertips
within the IDE.

00:21:11.126 --> 00:21:15.636 A:middle
And so if we take these
same projects, indexing time

00:21:15.636 --> 00:21:17.496 A:middle
for Xcode got a bit faster,

00:21:17.496 --> 00:21:20.496 A:middle
we're in the seven
percent range or so.

00:21:21.476 --> 00:21:24.716 A:middle
Preview on the other hand got
pretty significantly faster,

00:21:24.716 --> 00:21:27.526 A:middle
so 32 percent faster
indexing time just

00:21:27.526 --> 00:21:28.846 A:middle
from switching to Modules.

00:21:29.986 --> 00:21:32.556 A:middle
And iOS Mail, as you may have
seen earlier this morning,

00:21:32.866 --> 00:21:36.486 A:middle
got 2.3 times faster
indexing just

00:21:36.486 --> 00:21:37.796 A:middle
from doing the switch
to Modules.

00:21:40.016 --> 00:21:42.036 A:middle
Hopefully, at this
point, I've convinced you,

00:21:42.036 --> 00:21:45.176 A:middle
you should at least try out
Modules, fairly easy to do.

00:21:45.176 --> 00:21:47.696 A:middle
So if you start a new
project in Xcode 5,

00:21:47.696 --> 00:21:49.316 A:middle
Modules are enabled by default.

00:21:49.316 --> 00:21:52.106 A:middle
We really thinking this is the
way forward for Objective-C

00:21:52.266 --> 00:21:54.536 A:middle
to get access to
system frameworks.

00:21:54.786 --> 00:21:58.096 A:middle
If you have an existing
project, to covert it Modules,

00:21:58.096 --> 00:22:01.186 A:middle
just go into your Build Settings
and find the Module Setting,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:01.456 --> 00:22:02.996 A:middle
change it to Yes
and then Rebuild.

00:22:02.996 --> 00:22:04.586 A:middle
Nothing else is needed.

00:22:05.756 --> 00:22:08.426 A:middle
Now, if you're doing some
fancy linking tricks,

00:22:09.106 --> 00:22:11.406 A:middle
you may actually want to turn
off the Autolinking feature

00:22:11.956 --> 00:22:13.816 A:middle
in which case there is
a separate option here

00:22:13.816 --> 00:22:16.046 A:middle
where you can turn off
the Autolinking feature.

00:22:16.286 --> 00:22:20.076 A:middle
Most users shouldn't
actually need to do this.

00:22:20.286 --> 00:22:22.576 A:middle
As you may expect, there's
a couple of caveats.

00:22:22.576 --> 00:22:26.706 A:middle
So, first caveat, you
need to be using the iOS 7

00:22:26.826 --> 00:22:28.416 A:middle
or OS X Mavericks SDK.

00:22:28.416 --> 00:22:30.806 A:middle
Only those SDKs have
support for Modules.

00:22:31.146 --> 00:22:32.986 A:middle
Now, of course, you
can deploy backward

00:22:33.396 --> 00:22:35.886 A:middle
because you can use the new
SDK and deploy backward.

00:22:36.146 --> 00:22:39.316 A:middle
Modules don't change how
your code is actually built.

00:22:39.316 --> 00:22:40.836 A:middle
They don't change
for your source code.

00:22:40.836 --> 00:22:42.336 A:middle
They don't change how
your code is built.

00:22:42.336 --> 00:22:45.736 A:middle
You just need to move to
the newer SDK to get those--

00:22:45.796 --> 00:22:46.936 A:middle
essentially the Module Maps

00:22:47.316 --> 00:22:50.356 A:middle
that tell the Module
system how to work.

00:22:50.536 --> 00:22:54.416 A:middle
Second point is that
Modules aren't available C++.

00:22:54.736 --> 00:22:58.656 A:middle
Now, it's perfectly fine to
enable Modules in a C++ project.

00:22:58.946 --> 00:23:01.836 A:middle
Essentially, the fact that you
requested Modules will just be

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:01.836 --> 00:23:05.176 A:middle
ignored for the C++ sources,
you'll still get the benefits

00:23:05.176 --> 00:23:07.146 A:middle
of Modules for your
Objective-C sources.

00:23:07.756 --> 00:23:10.386 A:middle
The only downside here is you
can't use the fancy new @import

00:23:10.386 --> 00:23:12.096 A:middle
syntax in something
that's shared

00:23:12.546 --> 00:23:16.066 A:middle
between C++ and non-C++ code.

00:23:16.276 --> 00:23:19.206 A:middle
And finally, while Modules
are available for all

00:23:19.206 --> 00:23:22.986 A:middle
of the system frameworks,
on iOS and the Mac,

00:23:22.986 --> 00:23:24.686 A:middle
they're not available
for user frameworks.

00:23:26.116 --> 00:23:28.676 A:middle
So, let's wrap up here.

00:23:29.596 --> 00:23:32.176 A:middle
We talked about this
new feature, Modules.

00:23:32.696 --> 00:23:35.826 A:middle
The idea behind Modules is to
simplify the user frameworks

00:23:35.826 --> 00:23:39.896 A:middle
so you can just get the nice
semantic import behavior

00:23:40.326 --> 00:23:41.516 A:middle
which is much harder to break

00:23:41.586 --> 00:23:44.766 A:middle
than the textual inclusion
behavior that would, so--

00:23:44.766 --> 00:23:47.816 A:middle
and this means we've essentially
eliminated all of the problems

00:23:47.816 --> 00:23:50.246 A:middle
with strange header
order dependencies

00:23:50.246 --> 00:23:52.556 A:middle
between system frameworks
and user code,

00:23:54.166 --> 00:23:57.946 A:middle
and we've eliminated the
separate link with library step

00:23:57.946 --> 00:24:00.426 A:middle
through the Autolinking
feature of Modules.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:01.696 --> 00:24:04.096 A:middle
Now, Modules are
actually a lot more

00:24:04.096 --> 00:24:05.646 A:middle
than just a user convenience.

00:24:06.226 --> 00:24:09.196 A:middle
We're actually fundamentally
changing the underlying model

00:24:09.196 --> 00:24:11.916 A:middle
and how we can access
to APIs in a way

00:24:11.916 --> 00:24:15.076 A:middle
that can significantly improve
the performance of source tools.

00:24:15.416 --> 00:24:17.056 A:middle
And the very nice thing here is

00:24:17.056 --> 00:24:19.176 A:middle
that improvement
essentially comes for free.

00:24:19.496 --> 00:24:21.546 A:middle
You no longer have to tweak
your precompiled header

00:24:21.546 --> 00:24:22.526 A:middle
to get the build times.

00:24:22.826 --> 00:24:25.476 A:middle
Just use Modules and forget
about the precompiled header,

00:24:25.716 --> 00:24:27.396 A:middle
Modules will do the right thing.

00:24:28.616 --> 00:24:31.886 A:middle
And finally, you can enable
this feature without any changes

00:24:31.886 --> 00:24:33.156 A:middle
to your source code, whatsoever.

00:24:33.226 --> 00:24:36.186 A:middle
It's changing your Build Setting
and rebuilding your application.

00:24:36.456 --> 00:24:37.436 A:middle
The application doesn't change.

00:24:37.436 --> 00:24:38.496 A:middle
Your source code doesn't change.

00:24:39.936 --> 00:24:42.346 A:middle
So with that, I'd like to
turn you over to my colleague,

00:24:42.346 --> 00:24:44.886 A:middle
Dave Zarzycki to talk about
advances in Objective-C.

00:24:44.886 --> 00:24:45.446 A:middle
[applause]

00:24:45.446 --> 00:24:47.516 A:middle
&gt;&gt; All right.

00:24:48.066 --> 00:24:48.556 A:middle
Thanks, Doug.

00:24:51.396 --> 00:24:53.796 A:middle
So I'm going to be talking
to you about more advances

00:24:53.796 --> 00:24:56.536 A:middle
in Objective-C, some
recent, some new.

00:24:57.336 --> 00:24:59.146 A:middle
So, I'm going to be
starting off talking

00:24:59.146 --> 00:25:00.216 A:middle
about better productivity.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:00.216 --> 00:25:01.986 A:middle
We're going to be
talking about tool support

00:25:01.986 --> 00:25:03.236 A:middle
for modernizing your code.

00:25:03.236 --> 00:25:05.576 A:middle
We'll be talking about
improvements in the SDK

00:25:05.576 --> 00:25:08.146 A:middle
and how they make your life
better and more productive

00:25:08.146 --> 00:25:09.066 A:middle
and generate better code.

00:25:09.066 --> 00:25:12.466 A:middle
And we'll be talking
about block return safety

00:25:12.556 --> 00:25:13.926 A:middle
and catching some common errors.

00:25:14.436 --> 00:25:16.196 A:middle
And then we'll be talking
about the runtime in your code.

00:25:16.196 --> 00:25:19.886 A:middle
And then, for the rest of
the talk, we'll be talking

00:25:19.886 --> 00:25:21.216 A:middle
about Automatic Reference
Counting.

00:25:21.296 --> 00:25:24.486 A:middle
We'll be talking about
updates we've made to it

00:25:24.486 --> 00:25:26.576 A:middle
and we've been talking--
we'll talk about improvements

00:25:26.616 --> 00:25:28.206 A:middle
in generating better warnings

00:25:28.206 --> 00:25:29.716 A:middle
that help you generate
more correct code.

00:25:30.476 --> 00:25:32.386 A:middle
So with that, let's
jump in and talk

00:25:32.386 --> 00:25:34.136 A:middle
about Tools Support
for Modernization.

00:25:35.066 --> 00:25:38.336 A:middle
Something we did recently
was adding a Refactoring Tool

00:25:38.386 --> 00:25:39.716 A:middle
to modernize your code.

00:25:40.676 --> 00:25:42.516 A:middle
It's found right
here in the Edit Menu

00:25:42.656 --> 00:25:45.956 A:middle
under the Refactoring
Submenu and you just convert

00:25:45.956 --> 00:25:48.506 A:middle
to the Modern Objective-C
Syntax.

00:25:49.546 --> 00:25:50.736 A:middle
So what does this do?

00:25:50.976 --> 00:25:54.336 A:middle
Well, it reduces a ton of
boilerplate in your code.

00:25:54.336 --> 00:25:57.756 A:middle
We have object-- more object
literals, container literals.

00:25:58.246 --> 00:25:59.936 A:middle
We have improved subscripting.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.536 --> 00:26:01.596 A:middle
And this is covered in-depth

00:26:01.596 --> 00:26:03.036 A:middle
at last year's version
of this talk.

00:26:04.416 --> 00:26:05.806 A:middle
So let's look at
the example of this.

00:26:05.946 --> 00:26:08.236 A:middle
Here is an example of one of
my favorite jazz musicians.

00:26:09.436 --> 00:26:12.046 A:middle
Now, we do have literals.

00:26:12.046 --> 00:26:12.736 A:middle
We have string literals.

00:26:12.796 --> 00:26:13.846 A:middle
We have a lot of other things.

00:26:13.846 --> 00:26:15.406 A:middle
We need to remember how
to create a dictionary.

00:26:15.406 --> 00:26:17.506 A:middle
What factory method to call?

00:26:17.866 --> 00:26:21.146 A:middle
We need to remember the order
of the keys and the objects.

00:26:21.586 --> 00:26:23.856 A:middle
We need to remember that
they have to be objects.

00:26:23.986 --> 00:26:26.246 A:middle
And we have to remember to
nil-terminate this list.

00:26:26.916 --> 00:26:28.846 A:middle
And similarly for NSArray,

00:26:28.846 --> 00:26:30.716 A:middle
we have to remember the
right factory method to call.

00:26:30.796 --> 00:26:33.256 A:middle
And like NSDictionary, we need

00:26:33.256 --> 00:26:34.496 A:middle
to remember the nil-terminate
it.

00:26:35.866 --> 00:26:38.166 A:middle
Similarly, NSNumber
has the same problem.

00:26:39.366 --> 00:26:41.646 A:middle
We need to remember the
right factory method to call.

00:26:41.646 --> 00:26:42.276 A:middle
Is that an end?

00:26:42.276 --> 00:26:43.456 A:middle
Is it a long?

00:26:43.456 --> 00:26:45.106 A:middle
Is it a short?

00:26:45.106 --> 00:26:47.466 A:middle
We need to remember
the right one for Bool.

00:26:48.056 --> 00:26:50.726 A:middle
There's a lot of opportunity
here to reduce boilerplate.

00:26:51.666 --> 00:26:55.256 A:middle
Well, with the Refactoring Tool,
you can adopt the modern syntax.

00:26:55.736 --> 00:26:58.126 A:middle
Dictionary literals just
become @, curly brace.

00:26:58.596 --> 00:27:01.916 A:middle
Array literals become
@ square bracket.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:03.026 --> 00:27:06.136 A:middle
The compiler helps you remember
keys and values and the fact

00:27:06.136 --> 00:27:07.266 A:middle
that they have to be objects.

00:27:07.836 --> 00:27:10.036 A:middle
You don't need to worry about
nil terminating the list.

00:27:10.106 --> 00:27:13.436 A:middle
And similarly, for NSNumber,
you don't need to worry

00:27:13.436 --> 00:27:14.546 A:middle
about what type it is anymore.

00:27:14.546 --> 00:27:17.826 A:middle
You can just say @
number or @ yes or @ no.

00:27:17.826 --> 00:27:21.046 A:middle
So this is a huge simplification
and we have tools to help you

00:27:21.046 --> 00:27:23.556 A:middle
about the syntax so you can
focus on writing great code

00:27:23.556 --> 00:27:26.046 A:middle
and sweeping away the details.

00:27:27.876 --> 00:27:30.386 A:middle
Similarly, we can consider
containers before the

00:27:30.386 --> 00:27:31.416 A:middle
modern syntax.

00:27:32.276 --> 00:27:34.966 A:middle
Throughout your code, you work
with containers and you have

00:27:35.026 --> 00:27:37.196 A:middle
to write this code repeatedly.

00:27:37.196 --> 00:27:40.236 A:middle
You have to remember
if in the case--

00:27:40.266 --> 00:27:43.506 A:middle
whether the key comes first
or the object comes first,

00:27:44.056 --> 00:27:46.976 A:middle
it's just a lot of boilerplate
that could be simplified.

00:27:47.976 --> 00:27:49.876 A:middle
Well, with modern
syntax, you can do that.

00:27:50.506 --> 00:27:53.966 A:middle
You can use common subscripting
syntax that's available

00:27:53.966 --> 00:27:56.676 A:middle
in a variety of languages
to access containers

00:27:56.676 --> 00:27:59.296 A:middle
in the modern SDK and
the modern syntax.

00:27:59.816 --> 00:28:03.766 A:middle
Now, there's a ton more to
modern syntax that I'm not going

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:03.766 --> 00:28:05.176 A:middle
to cover here and
I strongly suggest

00:28:05.176 --> 00:28:06.346 A:middle
that you watch last year's talk.

00:28:07.266 --> 00:28:09.726 A:middle
We have boxed expressions
via @ parenthesis.

00:28:10.786 --> 00:28:14.456 A:middle
We have the full intersection
with C types if you want

00:28:14.456 --> 00:28:17.476 A:middle
to understand how they work,
like shorts and chars and longs

00:28:17.476 --> 00:28:18.466 A:middle
and unsigned behavior.

00:28:19.736 --> 00:28:24.016 A:middle
We have-- we teach you how
to implement subscripting

00:28:24.016 --> 00:28:27.786 A:middle
for your own classes and you can
see this on last year's version

00:28:27.936 --> 00:28:31.056 A:middle
of this talk, number
four or five.

00:28:31.926 --> 00:28:35.276 A:middle
So with that, I'd like to
jump into SDK improvements

00:28:35.446 --> 00:28:37.616 A:middle
and how they will
improve your productivity.

00:28:38.686 --> 00:28:42.116 A:middle
So the SDK is constantly
leveraging the compiler.

00:28:42.116 --> 00:28:43.486 A:middle
It's adopting new features.

00:28:43.876 --> 00:28:47.026 A:middle
It's helping you write more
correct code, safer code,

00:28:47.546 --> 00:28:50.836 A:middle
and get better compiled time
error detection and problems

00:28:50.836 --> 00:28:51.846 A:middle
that you might be running into.

00:28:52.846 --> 00:28:55.186 A:middle
And specifically, I'd like
to call out two features

00:28:55.186 --> 00:28:57.756 A:middle
that the new SDKs have adopted

00:28:57.806 --> 00:29:00.676 A:middle
that will affect
potentially your experience

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:00.676 --> 00:29:03.806 A:middle
and help you write better code.

00:29:04.026 --> 00:29:06.186 A:middle
And specifically, where there--

00:29:06.836 --> 00:29:09.956 A:middle
instancetype keyword and
explicitly-typed enums.

00:29:11.086 --> 00:29:12.866 A:middle
So let's jump in and
consider with that is.

00:29:14.236 --> 00:29:16.786 A:middle
Now, some of you probably
can look at this code

00:29:16.896 --> 00:29:18.006 A:middle
and already see the bug.

00:29:18.806 --> 00:29:20.916 A:middle
We're taking an NSArray
and we're assigning it

00:29:20.916 --> 00:29:22.976 A:middle
to an NSDictionary variable.

00:29:22.976 --> 00:29:24.386 A:middle
That's terrible.

00:29:24.866 --> 00:29:27.766 A:middle
But, copy and paste
errors are easy.

00:29:28.676 --> 00:29:30.586 A:middle
Refactoring are easy.

00:29:31.236 --> 00:29:35.346 A:middle
And in fact, now with the
SDKs worshipping this,

00:29:35.486 --> 00:29:39.376 A:middle
you will actually get a warning
pointing out the problem.

00:29:40.636 --> 00:29:42.926 A:middle
So how is it that the compiler
knows if we have a problem?

00:29:43.746 --> 00:29:45.256 A:middle
When previous versions
of the SDK,

00:29:45.256 --> 00:29:48.876 A:middle
array and many similar
APIs returned IDE.

00:29:49.676 --> 00:29:52.516 A:middle
The problem is that IDE
implicitly converts to anything,

00:29:52.556 --> 00:29:54.746 A:middle
so the compiler didn't
historically know

00:29:54.746 --> 00:29:56.346 A:middle
that there was a problem here.

00:29:57.826 --> 00:30:01.146 A:middle
In the new SDK, array
returns instancetype.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:02.176 --> 00:30:03.946 A:middle
This is a contextual keyword.

00:30:04.896 --> 00:30:06.796 A:middle
It's only for return types.

00:30:07.286 --> 00:30:12.066 A:middle
And subclasses don't need
to redeclare array here

00:30:12.066 --> 00:30:14.786 A:middle
to expose the fact that
they're returning an instance

00:30:14.866 --> 00:30:16.656 A:middle
of their subclass.

00:30:17.156 --> 00:30:20.446 A:middle
And finally, the compiler
contextually matches the return

00:30:20.446 --> 00:30:21.756 A:middle
type to that other receiver.

00:30:23.056 --> 00:30:24.306 A:middle
Okay, well what does that mean?

00:30:25.016 --> 00:30:27.506 A:middle
Let's consider our
subclassing NSArray.

00:30:27.646 --> 00:30:29.516 A:middle
And let's say we create
a class name Foobar.

00:30:30.116 --> 00:30:31.596 A:middle
We don't do anything more.

00:30:31.596 --> 00:30:33.036 A:middle
We just put in @end.

00:30:33.226 --> 00:30:37.526 A:middle
And what happens in this code
now that we're taking a Foobar

00:30:37.526 --> 00:30:40.726 A:middle
and calling array and this
signage NSDictionary variable?

00:30:40.726 --> 00:30:44.606 A:middle
Well, the compiler would still
print out the warning, great.

00:30:45.866 --> 00:30:47.476 A:middle
But I'd like to point out is

00:30:47.476 --> 00:30:49.836 A:middle
that the compiler is
contextually taking the receive

00:30:49.836 --> 00:30:53.706 A:middle
type Foobar and printing
out the warning pointing

00:30:53.706 --> 00:30:55.696 A:middle
out that the return
value is also a Foobar,

00:30:55.696 --> 00:30:57.156 A:middle
and that's the source
of the problem.

00:30:58.246 --> 00:30:59.926 A:middle
So that's the instancetype
keyword.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.776 --> 00:31:04.206 A:middle
Next up, I'd like to talk
about explicitly-typed enum.

00:31:04.206 --> 00:31:07.886 A:middle
Another feature that the SDK
has adopted that will show

00:31:07.886 --> 00:31:09.946 A:middle
up in your code and help
you detect more errors

00:31:10.036 --> 00:31:10.946 A:middle
and be more productive.

00:31:12.386 --> 00:31:14.356 A:middle
So let's look at this code.

00:31:15.016 --> 00:31:16.446 A:middle
Some of you that have experience

00:31:16.446 --> 00:31:19.106 A:middle
with URLs may already
see the bug.

00:31:19.966 --> 00:31:22.266 A:middle
These are not the same enum.

00:31:23.166 --> 00:31:26.016 A:middle
We have an NSURLHandleStatus
on the left.

00:31:26.456 --> 00:31:29.086 A:middle
We have an NSURLSessionTaskState
on the right.

00:31:29.986 --> 00:31:34.326 A:middle
Whoops. Well, again, copy
and paste errors are easy

00:31:35.126 --> 00:31:36.736 A:middle
and refactoring errors
are really easy.

00:31:37.646 --> 00:31:40.266 A:middle
And the reason this is used
to compile in the past is

00:31:40.266 --> 00:31:43.276 A:middle
that enums are essentially
just global integers.

00:31:43.276 --> 00:31:45.296 A:middle
So, we're just assigning
one number to another.

00:31:46.476 --> 00:31:51.416 A:middle
Well now, with the SDKs, you
will get a warning pointing

00:31:51.416 --> 00:31:53.366 A:middle
out that these are
of different types

00:31:53.456 --> 00:31:54.666 A:middle
which is exactly what you want.

00:31:54.666 --> 00:31:58.396 A:middle
So how does the compiler know?

00:31:59.446 --> 00:32:01.756 A:middle
In the past, we declared
enums like this.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:02.576 --> 00:32:05.536 A:middle
In one line, we would declare
the enum and enumerate,

00:32:05.966 --> 00:32:08.016 A:middle
you know, ABC, JKL, XYZ.

00:32:08.016 --> 00:32:12.396 A:middle
And the next line, we
declare a typedef where we say

00:32:12.396 --> 00:32:17.066 A:middle
that what the storage is
and then give it a name.

00:32:17.066 --> 00:32:21.126 A:middle
Well, this is where the
first line is just mint.

00:32:21.286 --> 00:32:24.466 A:middle
We haven't actually bound the
two pieces of information here.

00:32:26.736 --> 00:32:28.706 A:middle
And how we fixed this in the SDK

00:32:28.706 --> 00:32:31.046 A:middle
and with the compiler is the
compiler supports a new feature

00:32:31.046 --> 00:32:32.766 A:middle
for explicitly-typed enums.

00:32:33.286 --> 00:32:34.016 A:middle
What you can see here

00:32:34.016 --> 00:32:37.266 A:middle
on the first line is we've
actually moved the storage up

00:32:37.266 --> 00:32:39.476 A:middle
and now the enum knows
what its storage type is

00:32:39.476 --> 00:32:42.306 A:middle
and then now it's no longer
an int, it's an NSUInteger.

00:32:42.306 --> 00:32:46.806 A:middle
Now in the next line,
we actually bind or enum

00:32:46.806 --> 00:32:49.126 A:middle
to a type available for use.

00:32:49.796 --> 00:32:53.126 A:middle
This is all covered last year
in-depth and this version--

00:32:53.256 --> 00:32:54.546 A:middle
in this talk last year.

00:32:56.036 --> 00:32:59.346 A:middle
Now, the Cocoa team have
provided convenient macros

00:32:59.456 --> 00:33:00.716 A:middle
that exposed this feature.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:00.996 --> 00:33:04.056 A:middle
We have NS_ENUM for a
traditional enumerations,

00:33:04.056 --> 00:33:05.326 A:middle
like we just demonstrated.

00:33:06.036 --> 00:33:07.696 A:middle
You know, ABC, JKL, XYZ.

00:33:07.696 --> 00:33:11.826 A:middle
And they also have a
convenient macro for NS_OPTIONS.

00:33:12.686 --> 00:33:16.756 A:middle
So, a bit wise operations,
like, you know, different flags.

00:33:17.336 --> 00:33:21.416 A:middle
So I recommend the use of these
macros and you'll see them

00:33:21.416 --> 00:33:22.536 A:middle
in the system frameworks.

00:33:24.146 --> 00:33:26.646 A:middle
But we don't stop
with just warnings.

00:33:27.166 --> 00:33:30.816 A:middle
We also improved code
completion with NS_ENUM

00:33:30.816 --> 00:33:32.146 A:middle
and explicitly-typed enums.

00:33:33.236 --> 00:33:37.186 A:middle
So before NS_ENUM, if you tried

00:33:37.186 --> 00:33:40.806 A:middle
to code complete our
example enumeration here

00:33:40.806 --> 00:33:45.086 A:middle
and you typed X, you would see
a bunch of XPC-related APIs

00:33:45.086 --> 00:33:46.976 A:middle
and you wouldn't see your enum.

00:33:47.456 --> 00:33:48.396 A:middle
That's not fun.

00:33:49.356 --> 00:33:52.756 A:middle
Well, if we just switch to
the NS_ENUM macro and then get

00:33:52.756 --> 00:33:53.886 A:middle
up the compiler feature,

00:33:53.886 --> 00:33:55.966 A:middle
Code Completion gives
us exactly what we want

00:33:56.656 --> 00:33:58.736 A:middle
and we see our enumeration
available

00:33:58.736 --> 00:33:59.936 A:middle
in Code Completion
which is great.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:00.426 --> 00:34:04.326 A:middle
But it just doesn't--
it doesn't stop there.

00:34:04.476 --> 00:34:08.376 A:middle
The power of explicitly-typed
enums manifest in multiple ways.

00:34:09.536 --> 00:34:12.476 A:middle
So in this particular
case, we have an NSArray

00:34:12.476 --> 00:34:17.025 A:middle
that we're trying to
sort using a comparator.

00:34:17.116 --> 00:34:19.025 A:middle
And we do some logic
and then we decide

00:34:19.025 --> 00:34:20.666 A:middle
to return ascending
or descending.

00:34:21.646 --> 00:34:22.456 A:middle
Now if you look closely,

00:34:22.456 --> 00:34:24.956 A:middle
we actually haven't specified
the return type of this block

00:34:24.956 --> 00:34:26.946 A:middle
between the caret and
the opening parenthesis.

00:34:27.525 --> 00:34:32.156 A:middle
And the compiler would actually
give us an error saying that,

00:34:32.226 --> 00:34:35.735 A:middle
"Well, we infer the type of
this block as returning int

00:34:35.735 --> 00:34:42.005 A:middle
but the API actually takes
NS-- comparison result."

00:34:42.005 --> 00:34:44.025 A:middle
All right.

00:34:44.676 --> 00:34:46.146 A:middle
Well, how do we fix this?

00:34:46.706 --> 00:34:50.116 A:middle
Before explicitly-typed
enums, we have the Cast, thus,

00:34:50.556 --> 00:34:51.866 A:middle
assigning the correct type.

00:34:53.146 --> 00:34:54.896 A:middle
And yes, this would
make the warning go away

00:34:54.896 --> 00:34:57.366 A:middle
but now we have this lingering
cast in our code that, you know,

00:34:57.406 --> 00:34:58.956 A:middle
could create future problems.

00:34:59.266 --> 00:35:01.686 A:middle
Because the explicitly-typed
enums allow us to fix this

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:01.686 --> 00:35:04.146 A:middle
and make the enum how
many explicit-type,

00:35:05.216 --> 00:35:08.186 A:middle
we can help you avoid casting
and in fact you can now go

00:35:08.266 --> 00:35:09.646 A:middle
and delete these
casts and go back

00:35:09.646 --> 00:35:11.966 A:middle
to the natural looking
code you wanted to have

00:35:11.996 --> 00:35:14.506 A:middle
in the first place and
write it as intended.

00:35:16.776 --> 00:35:19.526 A:middle
Digging deeper on what
NS_ENUM can do for you,

00:35:20.046 --> 00:35:21.666 A:middle
let's consider the fact

00:35:21.666 --> 00:35:24.806 A:middle
of how implicitly-typed enums
can manifest in different ways.

00:35:25.396 --> 00:35:27.396 A:middle
Again, before explicitly-typed
enums,

00:35:27.456 --> 00:35:30.506 A:middle
these two URL-related enums

00:35:30.506 --> 00:35:33.486 A:middle
that are actually different
were just ints as far

00:35:33.486 --> 00:35:35.226 A:middle
as the compiler was concerned.

00:35:36.746 --> 00:35:39.636 A:middle
And this manifested as a
silent bug in your code.

00:35:40.296 --> 00:35:42.966 A:middle
Now with NS_ENUM, you get
the warning that you want

00:35:43.106 --> 00:35:46.266 A:middle
and now you have to
decide how to fix the code.

00:35:46.266 --> 00:35:48.256 A:middle
Now, here, this is pointing
out a design problem

00:35:48.256 --> 00:35:49.716 A:middle
so that there is
no quick solution.

00:35:49.716 --> 00:35:51.646 A:middle
You'd have to think about
it and actually figure

00:35:51.646 --> 00:35:52.796 A:middle
out what you originally
intended.

00:35:53.306 --> 00:35:56.536 A:middle
So with that, now
I'd like to move

00:35:56.536 --> 00:35:59.216 A:middle
on to the Objective-C
Runtime and you.

00:35:59.216 --> 00:36:02.806 A:middle
The Objective-C Runtime is
the core of the language.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:03.406 --> 00:36:05.816 A:middle
It enables a ton of
dynamic behavior.

00:36:05.816 --> 00:36:10.286 A:middle
We have, you know, of course,
dynamic method dispatch.

00:36:10.736 --> 00:36:12.296 A:middle
We have object introspection.

00:36:12.826 --> 00:36:14.846 A:middle
We have object proxies.

00:36:15.066 --> 00:36:16.686 A:middle
And we have dynamic
class construction,

00:36:16.686 --> 00:36:18.306 A:middle
even a dynamic method
replacement.

00:36:20.056 --> 00:36:23.596 A:middle
The runtime enables a ton of
innovation in the language.

00:36:24.336 --> 00:36:26.666 A:middle
We've added many
features over the years

00:36:26.666 --> 00:36:28.546 A:middle
and it's really the heart
of all these features.

00:36:29.646 --> 00:36:32.646 A:middle
So to give you an example, we've
added a new key-value observing,

00:36:32.646 --> 00:36:38.326 A:middle
associated objects, we've added
@synchronized to do locking,

00:36:38.936 --> 00:36:41.786 A:middle
we've added weak references,
we've added tagged pointers,

00:36:41.786 --> 00:36:44.236 A:middle
and the list go on, on and on.

00:36:44.286 --> 00:36:46.466 A:middle
I'd like to actually call
out tagged pointers though

00:36:46.466 --> 00:36:50.006 A:middle
because we have some new
warnings to enable innovation.

00:36:51.006 --> 00:36:54.036 A:middle
So, let's first dive deep
and ask the question,

00:36:54.036 --> 00:36:55.136 A:middle
what are tagged pointers?

00:36:56.006 --> 00:37:00.936 A:middle
They were added in 64-bit Cocoa
for a small value-like objects.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:01.006 --> 00:37:03.336 A:middle
And examples of a
value-like objects are

00:37:03.336 --> 00:37:06.576 A:middle
like NSNumber, NSDate,
just values.

00:37:07.436 --> 00:37:11.416 A:middle
What we're doing is we're
actually storing the object

00:37:11.416 --> 00:37:13.696 A:middle
in the pointer itself,
so we don't actually need

00:37:13.696 --> 00:37:15.066 A:middle
to call malloc or free.

00:37:15.066 --> 00:37:18.456 A:middle
And when you don't call
malloc or free, you could've--

00:37:19.056 --> 00:37:21.976 A:middle
code gets a ton faster and
it's more space efficient.

00:37:22.066 --> 00:37:23.936 A:middle
It's three times more
space efficient and it's

00:37:23.936 --> 00:37:25.506 A:middle
over 100 times faster
to allocate

00:37:25.506 --> 00:37:27.446 A:middle
and deallocate these
small value-like objects.

00:37:28.856 --> 00:37:31.636 A:middle
Okay, it's great in theory
but I'm a visual person.

00:37:31.636 --> 00:37:32.896 A:middle
Show me how this actually works.

00:37:34.116 --> 00:37:35.066 A:middle
In a normal pointer,

00:37:35.436 --> 00:37:37.856 A:middle
we're actually only
using the top 60 bits.

00:37:38.186 --> 00:37:40.616 A:middle
The bottom four bits of
a pointer are always zero

00:37:40.616 --> 00:37:42.476 A:middle
because objects are
always 16-byte aligned.

00:37:43.056 --> 00:37:45.376 A:middle
We can take advantage
of this fact

00:37:45.376 --> 00:37:49.206 A:middle
to implement what we call tagged
pointers where we actually store

00:37:49.206 --> 00:37:52.146 A:middle
in the bottom bit discriminators
and when it's one,

00:37:52.466 --> 00:37:54.886 A:middle
we can actually store a ton of
data in the rest of the bits.

00:37:55.306 --> 00:37:58.076 A:middle
And this is in fact what we do.

00:37:58.286 --> 00:38:01.686 A:middle
Having said all this, this
is an implementation detail.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:02.116 --> 00:38:03.876 A:middle
Some of you have
discovered this feature

00:38:03.876 --> 00:38:05.116 A:middle
and we need you to
undiscover it.

00:38:05.966 --> 00:38:10.616 A:middle
[laughter] The runtime
details are private.

00:38:10.616 --> 00:38:13.616 A:middle
And in fact, what
remaining little tidbits

00:38:13.616 --> 00:38:15.756 A:middle
of data structures you're
finding that are still public

00:38:15.756 --> 00:38:17.596 A:middle
in the data structures
are becoming private.

00:38:18.796 --> 00:38:21.926 A:middle
Most URI-- applications
are well behaved

00:38:21.926 --> 00:38:24.256 A:middle
and we thank you for that.

00:38:24.256 --> 00:38:26.176 A:middle
Use APIs to instropect things

00:38:26.776 --> 00:38:28.556 A:middle
and this lets us
innovate considerably

00:38:28.556 --> 00:38:29.596 A:middle
as we've already described.

00:38:30.206 --> 00:38:34.866 A:middle
But we've added some new
warnings to detect the use

00:38:34.866 --> 00:38:39.036 A:middle
of tagged pointers and a related
problem of Raw 'isa' access.

00:38:40.416 --> 00:38:43.896 A:middle
So, you might have code
like this in your program

00:38:44.026 --> 00:38:46.836 A:middle
where you're testing the tag bit
and then you are like, "Great,

00:38:47.036 --> 00:38:50.256 A:middle
I have discovered the tag bit
isn't set, I'm just going to run

00:38:50.256 --> 00:38:53.196 A:middle
in there and just access
the isa directly and--

00:38:53.546 --> 00:38:55.696 A:middle
because I'm think I'm
optimizing, this is fun."

00:38:56.506 --> 00:38:58.446 A:middle
But in the case when
the tag bit is set,

00:38:58.446 --> 00:38:59.796 A:middle
you actually called
the correct API.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:01.326 --> 00:39:04.556 A:middle
Well now, you're going to get a
warning for that tag bit check.

00:39:05.636 --> 00:39:06.936 A:middle
And you're actually
going to get an error

00:39:06.936 --> 00:39:08.626 A:middle
for the direct usage of the isa.

00:39:09.836 --> 00:39:10.916 A:middle
Well how do you fix this?

00:39:11.576 --> 00:39:14.316 A:middle
You delete the testing of that
bit and direct that access

00:39:14.316 --> 00:39:15.846 A:middle
to the isa and you actually call

00:39:15.846 --> 00:39:18.816 A:middle
like it isKindOfClass
or object getClass.

00:39:19.866 --> 00:39:21.126 A:middle
We really need you to do this

00:39:21.126 --> 00:39:22.926 A:middle
so we can unlock the
next level of innovation.

00:39:23.336 --> 00:39:25.726 A:middle
And failure to do so, might
break your code in the future.

00:39:25.876 --> 00:39:28.466 A:middle
So please, heed these warnings
and errors in your code

00:39:28.806 --> 00:39:30.386 A:middle
and do the right thing.

00:39:31.476 --> 00:39:32.506 A:middle
Thank you.

00:39:32.726 --> 00:39:35.706 A:middle
Finally on the runtime part
of this talk, I'd like to talk

00:39:35.706 --> 00:39:36.806 A:middle
about Garbage Collection.

00:39:38.096 --> 00:39:40.186 A:middle
GC only exists on the Mac.

00:39:41.026 --> 00:39:42.176 A:middle
We have replaced it with ARC

00:39:43.126 --> 00:39:47.216 A:middle
and in fact we deprecated
Garbage Collection as of 10.8.

00:39:48.376 --> 00:39:50.006 A:middle
We're very serious about this.

00:39:50.186 --> 00:39:52.566 A:middle
We're not supporting Garbage
Collection in new frameworks,

00:39:52.606 --> 00:39:55.726 A:middle
things like AVKit or Accounts
or GameController or GameKit,

00:39:56.736 --> 00:39:59.626 A:middle
et cetera, et cetera, we're not
supporting Garbage Collection.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:01.176 --> 00:40:03.686 A:middle
We really need you to
use the ARC Migrator

00:40:03.686 --> 00:40:05.866 A:middle
to transition off GC.

00:40:06.676 --> 00:40:09.866 A:middle
So with that, let's talk about
Automatic Reference Counting

00:40:10.276 --> 00:40:13.006 A:middle
and tell you about updates we've
been doing and some improvements

00:40:13.226 --> 00:40:15.276 A:middle
to help you write better code.

00:40:16.706 --> 00:40:18.346 A:middle
Let's start with the updates.

00:40:19.306 --> 00:40:22.636 A:middle
Cocoa is designed with reference
counting semantics in mind.

00:40:22.936 --> 00:40:23.696 A:middle
This is great.

00:40:24.136 --> 00:40:26.016 A:middle
Being able to deterministically
know

00:40:26.016 --> 00:40:27.706 A:middle
when an object is
destroyed allows you

00:40:27.706 --> 00:40:28.996 A:middle
to better reason
about your code.

00:40:29.546 --> 00:40:31.066 A:middle
It allows you to
better schedule things.

00:40:31.066 --> 00:40:32.536 A:middle
It allows you to better design.

00:40:32.536 --> 00:40:34.266 A:middle
And it's also just
great for debugging.

00:40:34.966 --> 00:40:38.296 A:middle
ARC also helps you
write great code.

00:40:38.296 --> 00:40:42.026 A:middle
It allows you to focus on what
matters and not the minutia

00:40:42.026 --> 00:40:45.986 A:middle
of details of when things
need to be released.

00:40:47.256 --> 00:40:51.726 A:middle
The majority of new App Store
submissions are using ARC.

00:40:51.726 --> 00:40:54.776 A:middle
So a lot of you also agree that
this is a really great tool

00:40:54.776 --> 00:40:56.086 A:middle
for focusing on what matters.

00:40:57.736 --> 00:41:01.236 A:middle
Specific-- another great
example of ARC is Xcode 5.0.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:01.716 --> 00:41:03.626 A:middle
This used to be a GC app.

00:41:04.266 --> 00:41:05.266 A:middle
It was a large app.

00:41:06.006 --> 00:41:07.596 A:middle
Nevertheless, we were
able to convert it

00:41:07.596 --> 00:41:08.906 A:middle
to Automatic Reference Counting

00:41:08.966 --> 00:41:10.506 A:middle
and we're thrilled
with the results.

00:41:11.486 --> 00:41:13.226 A:middle
We're thrilled with
the better determinism.

00:41:13.526 --> 00:41:14.786 A:middle
We love the better debugging.

00:41:14.956 --> 00:41:17.426 A:middle
We love that we're able to offer
tons of better performance.

00:41:17.936 --> 00:41:20.996 A:middle
And we hope that you'll
find the same experience.

00:41:20.996 --> 00:41:25.486 A:middle
Speaking of performance,
we are continuing

00:41:25.486 --> 00:41:27.476 A:middle
to improve the performance
of ARC.

00:41:27.876 --> 00:41:30.146 A:middle
Weak references are
now about twice as fast

00:41:30.276 --> 00:41:31.456 A:middle
and this year's version

00:41:31.516 --> 00:41:34.906 A:middle
of our operating system
iOS 7 and 10.9 for the Mac.

00:41:36.316 --> 00:41:39.246 A:middle
And we're also improving the
debug experience as well.

00:41:39.366 --> 00:41:41.946 A:middle
We have more predictable memory
usage under debug builds.

00:41:42.636 --> 00:41:44.376 A:middle
Specifically, the lifetime

00:41:44.376 --> 00:41:47.156 A:middle
of autoreleased objects is
much more like released builds.

00:41:48.586 --> 00:41:49.996 A:middle
Now when you autorelease
an object,

00:41:49.996 --> 00:41:51.696 A:middle
you don't necessarily
know when it goes away.

00:41:52.066 --> 00:41:54.926 A:middle
And in fact, ARC
optimizations could kick in

00:41:54.926 --> 00:41:56.046 A:middle
and change that timing.

00:41:56.736 --> 00:41:58.266 A:middle
We've improved the compilers

00:41:58.266 --> 00:42:02.436 A:middle
so the debug builds now
release the object much more

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:02.436 --> 00:42:06.166 A:middle
like when released builds and
we hope you appreciate that.

00:42:11.746 --> 00:42:13.926 A:middle
[applause] So this is our
great [inaudible] ARC.

00:42:14.736 --> 00:42:15.766 A:middle
Well, we have Migrator.

00:42:16.326 --> 00:42:17.896 A:middle
It does all the heavy
lifting for you.

00:42:17.896 --> 00:42:19.856 A:middle
It removes retain,
release, autorelease.

00:42:20.616 --> 00:42:24.366 A:middle
It deletes empty dealloc methods

00:42:24.366 --> 00:42:26.656 A:middle
if all your dealloc method
was doing was calling release,

00:42:26.656 --> 00:42:27.386 A:middle
release, release.

00:42:28.846 --> 00:42:30.726 A:middle
It converts NSAutoreleasePool

00:42:30.726 --> 00:42:33.646 A:middle
to @autoreleasepool
in the modern syntax.

00:42:34.986 --> 00:42:36.106 A:middle
But you have to do the rest.

00:42:36.466 --> 00:42:39.966 A:middle
You need to reason about some
rare things like id in structs.

00:42:39.966 --> 00:42:42.556 A:middle
Usually the easiest thing to
do is convert these to classes

00:42:42.556 --> 00:42:44.536 A:middle
and then, you know,
your code looks prettier

00:42:44.536 --> 00:42:45.146 A:middle
in the end anyway.

00:42:45.906 --> 00:42:48.276 A:middle
You also need to reason
about some atypical uses

00:42:48.276 --> 00:42:50.466 A:middle
of memory management APIs.

00:42:51.736 --> 00:42:53.976 A:middle
This was covered
in depth last year

00:42:54.106 --> 00:42:55.856 A:middle
in the Automatic
Reference Counting talk

00:42:56.136 --> 00:42:57.536 A:middle
and you can get all
the details there.

00:42:58.566 --> 00:43:00.436 A:middle
But if you don't have time
to jump back to the video,

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:00.436 --> 00:43:01.836 A:middle
here's what you need to do.

00:43:02.186 --> 00:43:05.626 A:middle
Just like with modern syntax,
you can go to the Edit Menu,

00:43:05.626 --> 00:43:10.256 A:middle
go to the Refracturing Submenu,
and you can convert to ARC

00:43:10.256 --> 00:43:14.566 A:middle
and let the tools help
you along the way.

00:43:14.796 --> 00:43:18.746 A:middle
So ARC and your app, we really
want you to switch to ARC

00:43:18.746 --> 00:43:21.606 A:middle
by default and focus on what
matters which is your app

00:43:21.606 --> 00:43:22.606 A:middle
and writing great code.

00:43:23.166 --> 00:43:25.876 A:middle
You can always opt out specific
files if you run into problems.

00:43:25.876 --> 00:43:27.956 A:middle
So you can just go to the
Profile Build Settings

00:43:27.956 --> 00:43:32.816 A:middle
and select the Compiler
Flag for turning off ARC.

00:43:33.756 --> 00:43:35.746 A:middle
And I'd also like to point

00:43:35.746 --> 00:43:38.866 A:middle
out that the ARC Migrator
supports both manual reference

00:43:38.916 --> 00:43:41.156 A:middle
counting code and
garbage-collected code

00:43:41.156 --> 00:43:44.436 A:middle
and it helps you migrate both
easily and straight forward.

00:43:45.066 --> 00:43:49.726 A:middle
Now for an update on
new things we've added

00:43:49.796 --> 00:43:51.886 A:middle
that we think you will love.

00:43:51.886 --> 00:43:54.976 A:middle
Let's talk about some new memory
management warnings we have

00:43:54.976 --> 00:43:58.606 A:middle
added to help you better
reason about life under ARC.

00:43:59.356 --> 00:44:02.736 A:middle
So, there are three things
I'm going to be talking about

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:03.316 --> 00:44:06.056 A:middle
and we're going to be talking
about the implicit referencing

00:44:06.056 --> 00:44:08.716 A:middle
of self and retain
cycles with blocks.

00:44:08.716 --> 00:44:13.876 A:middle
We're going to be talking about
repeated use of a weak variable

00:44:13.876 --> 00:44:15.386 A:middle
and what does that even mean.

00:44:16.046 --> 00:44:18.796 A:middle
And then thirdly, we'll be
talking about sending messages

00:44:18.796 --> 00:44:22.316 A:middle
to weak and had a better reason
about the behavior thereof.

00:44:23.716 --> 00:44:26.856 A:middle
So let's jump in first and
talk about retain cycles.

00:44:27.296 --> 00:44:28.276 A:middle
As a brief refresher,

00:44:28.276 --> 00:44:30.786 A:middle
let's imagine your app is
just referencing an object.

00:44:31.266 --> 00:44:34.076 A:middle
The reference count of this
object will start out is one.

00:44:35.136 --> 00:44:38.826 A:middle
And similarly, if that object
references another object,

00:44:38.946 --> 00:44:41.216 A:middle
that will be one.

00:44:41.216 --> 00:44:44.146 A:middle
But, if we actually
have a reference back

00:44:44.146 --> 00:44:46.786 A:middle
to the original object, its
reference count would be two.

00:44:46.786 --> 00:44:50.676 A:middle
And if our app lets go of
the object, we have a leak

00:44:50.676 --> 00:44:52.766 A:middle
because now these two
objects are holding references

00:44:52.766 --> 00:44:54.976 A:middle
on to each other and
keeping the object alive.

00:44:56.206 --> 00:44:58.836 A:middle
So with that in mind,
let's look at some code.

00:44:59.896 --> 00:45:02.376 A:middle
Let's say in a method you
have two instance variables.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:03.546 --> 00:45:05.526 A:middle
And one of the instance
variables holds the block

00:45:05.526 --> 00:45:06.966 A:middle
and the other one
is just an object.

00:45:06.966 --> 00:45:08.116 A:middle
It doesn't really
matter what kind.

00:45:09.146 --> 00:45:10.186 A:middle
In the block we use ivar2,

00:45:10.266 --> 00:45:12.346 A:middle
and then we assign
the block to ivar1.

00:45:12.346 --> 00:45:15.796 A:middle
Well what's actually
going on under the covers

00:45:15.796 --> 00:45:17.226 A:middle
and how the compiler reasons

00:45:17.226 --> 00:45:19.146 A:middle
about this is we have
implicit use of self

00:45:19.146 --> 00:45:20.256 A:middle
in both of these cases.

00:45:20.556 --> 00:45:23.166 A:middle
And those are the actual
objects in question

00:45:23.166 --> 00:45:26.606 A:middle
that we need to think about.

00:45:26.606 --> 00:45:30.236 A:middle
So let's delete that and then
see what warning the compiler

00:45:30.236 --> 00:45:31.036 A:middle
can now print out.

00:45:32.276 --> 00:45:35.736 A:middle
So I've enabled this warning,
the compiler will print out,

00:45:36.126 --> 00:45:39.516 A:middle
they were capturing self
strongly in the ivar2 case,

00:45:39.516 --> 00:45:41.856 A:middle
and then it points
out the related case

00:45:41.856 --> 00:45:43.546 A:middle
where it believes
the cycle began.

00:45:44.846 --> 00:45:46.196 A:middle
Well, again, I'm
a visual person,

00:45:46.196 --> 00:45:47.916 A:middle
but show what this
looks like in practice.

00:45:48.486 --> 00:45:52.616 A:middle
So we have an instance of
our class and we have ivar2.

00:45:52.726 --> 00:45:55.506 A:middle
Again, ivar2 can be any
object, string, whatever.

00:45:56.466 --> 00:45:57.876 A:middle
And now we're creating
this block.

00:45:59.096 --> 00:46:01.496 A:middle
Now when we wrote the code,
it may look like this.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:01.496 --> 00:46:04.206 A:middle
It may look like we're just
assigning the block to ivar1

00:46:04.206 --> 00:46:05.086 A:middle
and we're using ivar2.

00:46:05.256 --> 00:46:06.516 A:middle
What's the problem?

00:46:06.516 --> 00:46:07.376 A:middle
I don't see any cycle.

00:46:08.866 --> 00:46:11.086 A:middle
Well because there is
an implicit use of self,

00:46:11.176 --> 00:46:13.326 A:middle
the block is actually
retaining self.

00:46:13.326 --> 00:46:17.416 A:middle
And now we have a cycle and now
it's indirectly accessing ivar2.

00:46:17.416 --> 00:46:19.696 A:middle
And again, we'll
get the same leak

00:46:19.696 --> 00:46:22.916 A:middle
that we demonstrated earlier
if we let go of the instance

00:46:22.916 --> 00:46:25.296 A:middle
of our class, the
block will be keeping

00:46:25.296 --> 00:46:28.656 A:middle
that instance alive
and we have a leak.

00:46:28.796 --> 00:46:30.566 A:middle
So let's go back to the
code and the warning.

00:46:30.856 --> 00:46:31.936 A:middle
How do we fix this?

00:46:32.706 --> 00:46:34.996 A:middle
Well we make some room and
we add a weak variable.

00:46:35.696 --> 00:46:38.716 A:middle
So what we do is we create
a weak variable on the stack

00:46:39.776 --> 00:46:41.306 A:middle
and assign self to it.

00:46:41.306 --> 00:46:44.856 A:middle
And this variable is an instance
of the same type of our class.

00:46:45.926 --> 00:46:49.596 A:middle
And then what we do is we use
this weak variable in our block.

00:46:50.376 --> 00:46:52.786 A:middle
And if we do that,
the warning goes away.

00:46:54.476 --> 00:46:56.466 A:middle
So what's going on here?

00:46:57.746 --> 00:47:01.246 A:middle
Weak variables do not extend
the lifetime on objects.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:02.116 --> 00:47:04.806 A:middle
They are-- and therefore,

00:47:04.806 --> 00:47:06.806 A:middle
they don't implicitly
create retain cycles.

00:47:07.326 --> 00:47:11.636 A:middle
And the great thing about weak
variables is they safely become

00:47:11.636 --> 00:47:12.826 A:middle
nil when the reference count

00:47:12.826 --> 00:47:14.906 A:middle
of the object they're
referring to drops to zero.

00:47:15.686 --> 00:47:18.696 A:middle
Now in this particular
case, they are tied together

00:47:18.696 --> 00:47:19.646 A:middle
so we don't have a problem.

00:47:19.646 --> 00:47:21.206 A:middle
But it allows us
to break the cycle

00:47:21.206 --> 00:47:22.576 A:middle
and actually get
the paper we want

00:47:22.576 --> 00:47:26.486 A:middle
when we release the
instance of our class.

00:47:26.636 --> 00:47:29.536 A:middle
So building on this, let's talk
about weak variables in general.

00:47:30.666 --> 00:47:31.806 A:middle
Consider this simple method

00:47:31.806 --> 00:47:34.746 A:middle
where we're logging the
description of a weak ivar.

00:47:36.176 --> 00:47:37.576 A:middle
Does this method
even called call?

00:47:37.576 --> 00:47:39.096 A:middle
What happens if the weak is nil?

00:47:39.396 --> 00:47:41.196 A:middle
You know, what actually
happens here?

00:47:41.856 --> 00:47:45.876 A:middle
How do we reason
about this at all?

00:47:45.936 --> 00:47:49.526 A:middle
Well, now the compiler
can warn about this saying

00:47:50.246 --> 00:47:55.516 A:middle
that we're using weak variable
and it may unpredictably be nil.

00:47:56.686 --> 00:48:00.056 A:middle
Well what do we do about this?

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:00.266 --> 00:48:01.706 A:middle
Well, it's actually
worst than that.

00:48:01.706 --> 00:48:05.406 A:middle
It can get-- we can have a
weak variable and use it twice.

00:48:05.956 --> 00:48:08.606 A:middle
Does this get called
zero, one or two times?

00:48:08.886 --> 00:48:10.416 A:middle
You know, how do we
reason about this?

00:48:11.346 --> 00:48:13.296 A:middle
Well there's actually a
solution for both of these

00:48:13.436 --> 00:48:16.176 A:middle
and I'd like to-- oh, sorry.

00:48:17.106 --> 00:48:19.246 A:middle
In the repeated use case, we
now have a specific warning

00:48:19.246 --> 00:48:21.046 A:middle
for that too pointing
out that, you know,

00:48:21.116 --> 00:48:23.636 A:middle
you can't actually reason about
the zero, one or two case.

00:48:24.516 --> 00:48:28.716 A:middle
[ Pause ]

00:48:29.216 --> 00:48:33.656 A:middle
So let's go back to the original
code and the original warning

00:48:33.716 --> 00:48:34.826 A:middle
and look at how we fix this.

00:48:35.266 --> 00:48:39.826 A:middle
Let's make some room and
do as the compiler advices

00:48:39.826 --> 00:48:42.376 A:middle
and put a local strong
variable on the stack,

00:48:42.986 --> 00:48:45.056 A:middle
assign our weak variable
into it.

00:48:45.516 --> 00:48:46.566 A:middle
And once we've done that,

00:48:47.116 --> 00:48:50.506 A:middle
that strong variable is
either nil or not nil.

00:48:50.816 --> 00:48:52.106 A:middle
It's not going to
change magically

00:48:52.106 --> 00:48:53.106 A:middle
out from underneath us.

00:48:53.836 --> 00:48:56.156 A:middle
And because we know that,
we can now test for it.

00:48:56.156 --> 00:48:59.886 A:middle
And if it's not nil, we can now
safely print the description.

00:48:59.886 --> 00:49:02.736 A:middle
And if we do that, of
course, the warning goes away.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:03.646 --> 00:49:06.786 A:middle
So this is great.

00:49:07.216 --> 00:49:10.126 A:middle
We now can reason about the
lifetime of this variable.

00:49:11.056 --> 00:49:14.396 A:middle
And the great thing too is
handling the nil case becomes

00:49:14.396 --> 00:49:15.086 A:middle
very obvious.

00:49:15.086 --> 00:49:20.716 A:middle
We just add the else block
and do the right thing.

00:49:20.936 --> 00:49:24.206 A:middle
Next up in the Automatic
Reference Counting Improvements,

00:49:24.476 --> 00:49:26.976 A:middle
I'd like to talk
about the relationship

00:49:27.066 --> 00:49:28.726 A:middle
between ARC and CoreFoundation.

00:49:29.296 --> 00:49:31.766 A:middle
If you've already
been using ARC,

00:49:31.766 --> 00:49:32.956 A:middle
you may have been writing a code

00:49:32.956 --> 00:49:34.946 A:middle
like this every time you
interact with CoreFoundation.

00:49:34.946 --> 00:49:38.836 A:middle
You have a CFDictionary,
getting some value out of it.

00:49:39.246 --> 00:49:43.736 A:middle
And in order to help ARC reason
about the object lifetime,

00:49:43.846 --> 00:49:46.756 A:middle
we use a bridge cast saying
that there's no net change

00:49:46.756 --> 00:49:47.696 A:middle
in the reference count here.

00:49:49.196 --> 00:49:52.546 A:middle
This is required because
anytime we come in and out

00:49:52.546 --> 00:49:54.396 A:middle
of the ARC system, we
need the ARC compiler

00:49:54.396 --> 00:49:55.926 A:middle
to actually be tracking
the reference count

00:49:55.926 --> 00:49:58.386 A:middle
so that way objects live
only as long as they need to,

00:49:58.386 --> 00:49:59.626 A:middle
and no longer and no shorter.

00:49:59.626 --> 00:50:06.836 A:middle
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:07.116 --> 00:50:09.116 A:middle
You can express a decrement

00:50:09.116 --> 00:50:11.376 A:middle
of the reference count
via CFBridgingRelease.

00:50:12.036 --> 00:50:18.976 A:middle
And you can express a no
net change via bridge cast.

00:50:19.156 --> 00:50:22.036 A:middle
Well, you know, it's
great that we're using ARC

00:50:22.036 --> 00:50:23.806 A:middle
and we've been able
to make our CF code

00:50:23.806 --> 00:50:25.386 A:middle
and our Foundation
code work together,

00:50:25.386 --> 00:50:26.926 A:middle
but can we improve
this situation?

00:50:27.816 --> 00:50:29.716 A:middle
Well, CoreFoundation
actually has some really

00:50:29.716 --> 00:50:30.796 A:middle
strong conventions.

00:50:31.296 --> 00:50:33.516 A:middle
Create and copy methods
return +1

00:50:33.816 --> 00:50:35.526 A:middle
and everything else returns +0.

00:50:36.456 --> 00:50:39.596 A:middle
And in fact, we already have
some compiler attributes

00:50:39.596 --> 00:50:42.026 A:middle
for the exceptions,
like CF RETUNS RETAINED

00:50:42.026 --> 00:50:46.806 A:middle
and CF RETURNS NOT RETAINED and
CF releases argument for APIs

00:50:46.806 --> 00:50:48.466 A:middle
that consume their argument.

00:50:49.416 --> 00:50:52.236 A:middle
And these are there to
help the static analyzer

00:50:52.236 --> 00:50:53.986 A:middle
and you may have already
seen this kick in,

00:50:53.986 --> 00:50:55.536 A:middle
in your use of the
static analyzer.

00:50:56.326 --> 00:51:00.696 A:middle
Well, what if we can just
use these conventions

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:00.696 --> 00:51:03.146 A:middle
to make this bridge
cast go away?

00:51:04.186 --> 00:51:07.376 A:middle
In fact, we've formalized
the everything else cast now.

00:51:08.406 --> 00:51:13.096 A:middle
The common CF APIs you use
now allow implicit bridging

00:51:13.096 --> 00:51:14.846 A:middle
as opposed to this
explicit bridging.

00:51:15.516 --> 00:51:21.086 A:middle
[ Applause ]

00:51:21.586 --> 00:51:24.286 A:middle
There are new macros
available for use too.

00:51:24.286 --> 00:51:26.336 A:middle
And with that, I'd like to
show you how this works.

00:51:27.126 --> 00:51:29.656 A:middle
So, how do we enable
implicit bridging?

00:51:30.206 --> 00:51:34.706 A:middle
Let's imagine we're wrapping
a CoreFoundation Array

00:51:34.706 --> 00:51:36.066 A:middle
and we have our example
Foo that--

00:51:36.066 --> 00:51:37.896 A:middle
we have just bunch of
wrappers around the array.

00:51:39.376 --> 00:51:41.716 A:middle
Well the first API we
have here is great.

00:51:41.716 --> 00:51:43.876 A:middle
It follows the convention
as copying the name.

00:51:44.266 --> 00:51:45.456 A:middle
We don't need to do anything.

00:51:46.856 --> 00:51:48.606 A:middle
The second API is also great.

00:51:48.756 --> 00:51:49.756 A:middle
We don't need to anything

00:51:49.756 --> 00:51:50.956 A:middle
because it follows
the convention.

00:51:50.956 --> 00:51:51.936 A:middle
It returns +1.

00:51:51.936 --> 00:51:53.316 A:middle
It doesn't consume
any arguments.

00:51:54.376 --> 00:51:57.176 A:middle
But our third API, we don't
know what we were thinking.

00:51:57.176 --> 00:52:01.486 A:middle
We decided that we're going
to return retained and--

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:01.746 --> 00:52:03.136 A:middle
but we're following
the convention.

00:52:03.756 --> 00:52:07.936 A:middle
Well, what we need to do is put
a CF RETURNS RETAINED attribute

00:52:07.976 --> 00:52:13.016 A:middle
there via macro and let the
compiler know what's going on.

00:52:13.576 --> 00:52:14.966 A:middle
Even if we just stop
here and do this,

00:52:14.966 --> 00:52:17.496 A:middle
we've already help the static
analyzer reason about our code.

00:52:18.066 --> 00:52:20.196 A:middle
But once we're done auditing,

00:52:20.196 --> 00:52:22.886 A:middle
what we can do is
add these macros,

00:52:22.936 --> 00:52:26.786 A:middle
CF IMPLICIT BRIDGING ENABLED and
CF IMPLICIT BRIDGING DISABLED

00:52:26.986 --> 00:52:29.246 A:middle
to tell the compiler
that we've audited code.

00:52:30.586 --> 00:52:33.636 A:middle
Now, this must be
after all #includes.

00:52:33.766 --> 00:52:36.006 A:middle
Obviously, you're not
auditing somebody else's code.

00:52:36.006 --> 00:52:37.226 A:middle
You're auditing your code.

00:52:38.476 --> 00:52:40.696 A:middle
And you don't have to
do it around everything.

00:52:40.696 --> 00:52:42.526 A:middle
If there's code you don't
want to think about right now,

00:52:42.526 --> 00:52:45.466 A:middle
you could have the explicitly
bridge code remain outside

00:52:45.466 --> 00:52:48.346 A:middle
of the macros they are using.

00:52:49.786 --> 00:52:51.576 A:middle
And that is implicit bridging

00:52:51.576 --> 00:52:54.736 A:middle
and this is all the
common CF plist types

00:52:54.776 --> 00:52:57.876 A:middle
or have been auditing and you
can go remove this bridge cast

00:52:57.876 --> 00:53:00.316 A:middle
from your code if you're
using the new SDKs.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:00.836 --> 00:53:04.656 A:middle
So to wrap up, we have Modules.

00:53:05.206 --> 00:53:08.696 A:middle
This is really great for finally
fixing the textual inclusion

00:53:08.696 --> 00:53:11.236 A:middle
problem and all the
associated bugs.

00:53:11.706 --> 00:53:13.536 A:middle
It also adds great performance

00:53:13.536 --> 00:53:15.986 A:middle
for compilation time
and indexing.

00:53:16.596 --> 00:53:19.076 A:middle
And it's just a much more
pleasurable experience

00:53:19.076 --> 00:53:20.246 A:middle
with features like Autolinking.

00:53:20.826 --> 00:53:22.246 A:middle
We also have improved
productivity

00:53:22.246 --> 00:53:25.946 A:middle
with better compiler warnings
throughout the SDK adoption

00:53:25.946 --> 00:53:28.686 A:middle
of these compiler warnings to
help you catch errors early

00:53:29.106 --> 00:53:30.696 A:middle
and write more productive code.

00:53:31.326 --> 00:53:33.176 A:middle
And with ARC, we've made
it better and faster

00:53:33.176 --> 00:53:37.356 A:middle
by allowing you to better
reason about simple retain cycle

00:53:37.356 --> 00:53:40.386 A:middle
and weak reference bugs,
and also easier in the fact

00:53:40.386 --> 00:53:42.316 A:middle
that you no longer need
to write bridge cast

00:53:42.316 --> 00:53:45.046 A:middle
for common CF plist types.

00:53:45.236 --> 00:53:46.986 A:middle
For more information,
I'd like to point you

00:53:47.086 --> 00:53:48.596 A:middle
at Dave DeLong, our evangelist.

00:53:49.576 --> 00:53:51.016 A:middle
We also have tons
of documentation

00:53:51.016 --> 00:53:54.816 A:middle
on the developer website and
of course the Developer Forums.

00:53:55.576 --> 00:53:58.376 A:middle
We have two labs,
one tomorrow morning

00:53:58.376 --> 00:54:00.156 A:middle
and one Thursday afternoon.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:01.326 --> 00:54:02.666 A:middle
Oh sorry, related sessions.

00:54:03.006 --> 00:54:04.816 A:middle
We have What's New
in LLVM Compiler,

00:54:04.816 --> 00:54:07.146 A:middle
it happened earlier today, you
have to catch them on video.

00:54:07.196 --> 00:54:10.136 A:middle
But tomorrow, we have
Optimize Your Code Using LLVM

00:54:10.226 --> 00:54:12.306 A:middle
in Nob Hill at 3:30.

00:54:12.656 --> 00:54:13.706 A:middle
So, thanks for coming.

00:54:14.516 --> 00:54:21.840 A:middle
[ Applause ]

