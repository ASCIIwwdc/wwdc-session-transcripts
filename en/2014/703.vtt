WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:11.236 --> 00:00:12.116 A:middle
Good morning everyone.

00:00:12.186 --> 00:00:13.026 A:middle
My name is Geoff.

00:00:13.026 --> 00:00:15.646 A:middle
I'm an Engineer in the
Vector and Numerics Group

00:00:15.646 --> 00:00:17.386 A:middle
where we maintain the
Accelerate Framework.

00:00:18.706 --> 00:00:21.076 A:middle
The Accelerate Framework
is a collection of routines

00:00:21.436 --> 00:00:23.476 A:middle
which deliver a huge
range of functionality.

00:00:24.186 --> 00:00:26.656 A:middle
All this functionality is
going to be extremely fast

00:00:26.966 --> 00:00:29.056 A:middle
and be very energy efficient.

00:00:30.226 --> 00:00:32.906 A:middle
Today I want to introduce some
new features and functionality

00:00:32.906 --> 00:00:35.386 A:middle
to the Accelerated
Framework which are designed

00:00:35.496 --> 00:00:37.306 A:middle
to really simplify the way

00:00:37.306 --> 00:00:39.726 A:middle
that you access this
high-performance functionality.

00:00:40.626 --> 00:00:43.876 A:middle
So what are you going to find
in the Accelerated Framework?

00:00:44.786 --> 00:00:46.746 A:middle
We break this into
four broad categories.

00:00:47.586 --> 00:00:49.166 A:middle
The first is image processing.

00:00:50.016 --> 00:00:52.076 A:middle
Here you're going
to find conversions

00:00:52.076 --> 00:00:56.586 A:middle
between various pixel formats,
warp, shears, convolution,

00:00:56.626 --> 00:01:03.116 A:middle
etc. We've got digital signal
processing, FFTs, DFTs, biquads,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:56.626 --> 00:01:03.116 A:middle
etc. We've got digital signal
processing, FFTs, DFTs, biquads,

00:01:03.386 --> 00:01:05.156 A:middle
various vector operations.

00:01:06.966 --> 00:01:10.736 A:middle
Vector math functionality, so a
lot of things that you're going

00:01:10.736 --> 00:01:14.076 A:middle
to find in math.h for
example, operating on vectors,

00:01:14.076 --> 00:01:16.766 A:middle
so sign of a vector,
co-sign of a vector,

00:01:16.766 --> 00:01:20.226 A:middle
etc. And then finally,
linear algebra.

00:01:20.846 --> 00:01:25.386 A:middle
Solving systems with linear
equations, eigen values, matrix,

00:01:25.386 --> 00:01:28.866 A:middle
matrix operations, a lot of
functionality in here as well.

00:01:32.876 --> 00:01:34.836 A:middle
The Accelerate Framework
brings a lot more

00:01:34.836 --> 00:01:37.176 A:middle
than just functionality
to the table.

00:01:37.216 --> 00:01:38.936 A:middle
First, it's extremely
high performance.

00:01:39.546 --> 00:01:41.196 A:middle
When we say this,
there's two main metrics

00:01:41.196 --> 00:01:42.786 A:middle
that we pay a lot
of attention to.

00:01:42.986 --> 00:01:44.066 A:middle
The first is speed.

00:01:44.516 --> 00:01:46.056 A:middle
It's going to be extremely fast.

00:01:46.926 --> 00:01:49.776 A:middle
There's two key tools that
we use to achieve this.

00:01:49.936 --> 00:01:51.436 A:middle
The first is short vector units.

00:01:51.666 --> 00:01:55.446 A:middle
So on Intel we're taking
advantage of SSE and AVX

00:01:55.446 --> 00:01:57.616 A:middle
and on ARM we're taking
advantage of NEON.

00:01:58.966 --> 00:02:01.586 A:middle
Also in some situations we're
utilizing multiple cores.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:58.966 --> 00:02:01.586 A:middle
Also in some situations we're
utilizing multiple cores.

00:02:02.116 --> 00:02:03.356 A:middle
We're going to do
this automatically.

00:02:03.356 --> 00:02:05.326 A:middle
So we're really going
to take advantage of all

00:02:05.326 --> 00:02:08.156 A:middle
of the processing
that's available for you.

00:02:08.705 --> 00:02:11.806 A:middle
The other metric that we
spent a lot of time looking

00:02:11.806 --> 00:02:13.076 A:middle
at is energy efficiency.

00:02:13.396 --> 00:02:16.636 A:middle
So we're increasingly relying
on our portable devices.

00:02:16.906 --> 00:02:20.536 A:middle
It's important that we
keep an eye on this.

00:02:20.536 --> 00:02:23.436 A:middle
Generally, when we improve
speed and performance,

00:02:23.436 --> 00:02:25.746 A:middle
energy efficiency
improves as well.

00:02:26.146 --> 00:02:28.276 A:middle
So when you adopt the Accelerate
Framework, you're going

00:02:28.276 --> 00:02:29.966 A:middle
to be fast and energy efficient.

00:02:30.516 --> 00:02:35.186 A:middle
The Accelerate Framework is
available on both OS X and iOS.

00:02:35.186 --> 00:02:38.666 A:middle
And it's optimized for all
generations of hardware.

00:02:40.116 --> 00:02:42.366 A:middle
So when you adopt the
Accelerated Framework,

00:02:42.366 --> 00:02:43.306 A:middle
you're going to write once.

00:02:43.606 --> 00:02:45.786 A:middle
You're going to get a code
that runs extremely fast

00:02:45.786 --> 00:02:48.096 A:middle
and is energy efficient no
matter where it ends up running.

00:02:48.706 --> 00:02:54.076 A:middle
So it's really convenient
for you.

00:02:54.276 --> 00:02:57.026 A:middle
Today I want to talk about the
new features and functionalities

00:02:57.026 --> 00:02:59.406 A:middle
to make it easier to get
to this high performance.

00:02:59.516 --> 00:03:02.006 A:middle
We've got some great
new features in vImage


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.516 --> 00:03:02.006 A:middle
We've got some great
new features in vImage

00:03:02.006 --> 00:03:04.266 A:middle
which really round out what
you can do with vImage.

00:03:04.856 --> 00:03:06.686 A:middle
And then I want to
spend the rest

00:03:06.686 --> 00:03:09.006 A:middle
of the time introducing
two new pieces of work.

00:03:09.396 --> 00:03:12.226 A:middle
The first is designed to
really simplify the way

00:03:12.226 --> 00:03:14.336 A:middle
that you access high
performance LinearAlgebra.

00:03:15.256 --> 00:03:16.756 A:middle
We're calling this
LinearAlgebra.

00:03:17.226 --> 00:03:18.686 A:middle
It's a part of the
Accelerated framework.

00:03:19.716 --> 00:03:22.256 A:middle
The other piece is
not actually a part

00:03:22.256 --> 00:03:23.306 A:middle
of the Accelerated framework.

00:03:23.306 --> 00:03:25.856 A:middle
It's a collection of vector
programming primitives.

00:03:25.856 --> 00:03:31.296 A:middle
It's found in simd.h. And
for those of you that want

00:03:31.296 --> 00:03:33.256 A:middle
to roll your own
high-performance vector

00:03:33.256 --> 00:03:36.436 A:middle
implementations, there's
going to be some great,

00:03:36.436 --> 00:03:39.326 A:middle
great tools in here
to help you do that.

00:03:40.976 --> 00:03:42.996 A:middle
So now let's jump
right into vImage.

00:03:43.306 --> 00:03:47.156 A:middle
This is our high-performance
image processing library.

00:03:48.546 --> 00:03:50.566 A:middle
It's got a huge range
of functionality.

00:03:51.366 --> 00:03:52.856 A:middle
I want to show you
some of the things

00:03:52.856 --> 00:03:54.306 A:middle
that you can do with
a short video.

00:03:54.856 --> 00:04:00.856 A:middle
You can perform alpha
blending, dilatation, erosion.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:54.856 --> 00:04:00.856 A:middle
You can perform alpha
blending, dilatation, erosion.

00:04:01.616 --> 00:04:05.336 A:middle
You can create sobel
filters to do edge detection.

00:04:05.896 --> 00:04:08.506 A:middle
Convolutions for
blur and de-blur.

00:04:09.716 --> 00:04:11.996 A:middle
You can create multikernal
convolves.

00:04:13.206 --> 00:04:14.726 A:middle
There's min and max filters.

00:04:16.326 --> 00:04:18.125 A:middle
Various color transformations.

00:04:18.546 --> 00:04:21.676 A:middle
And warps and shears.

00:04:23.116 --> 00:04:25.606 A:middle
This is just some of what
you can do with the vImage.

00:04:25.916 --> 00:04:28.896 A:middle
Really you can do almost any
of your image processing needs

00:04:28.896 --> 00:04:31.046 A:middle
with the tools that are
available in vImage.

00:04:31.656 --> 00:04:35.196 A:middle
I want to move now
into some work

00:04:35.196 --> 00:04:36.486 A:middle
that we introduced last year.

00:04:37.246 --> 00:04:40.726 A:middle
And this is about getting
your image into a format

00:04:40.726 --> 00:04:41.936 A:middle
that the vImage can consume.

00:04:42.276 --> 00:04:44.866 A:middle
Specifically, if you're
coming from a CGImageRef.

00:04:45.756 --> 00:04:48.636 A:middle
So until last year this
was a difficult task.

00:04:48.916 --> 00:04:52.036 A:middle
If you didn't know exactly
what the pixel format

00:04:52.036 --> 00:04:54.926 A:middle
of your CGImageRef was
for whatever reason,

00:04:55.186 --> 00:04:58.996 A:middle
it could be difficult to
get it into the 8 bit ARGB

00:04:59.306 --> 00:05:01.216 A:middle
or whatever format
that you saw in vImage


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.306 --> 00:05:01.216 A:middle
or whatever format
that you saw in vImage

00:05:01.216 --> 00:05:02.886 A:middle
that you wanted to work with.

00:05:03.416 --> 00:05:06.316 A:middle
So last year we introduced
a single routine

00:05:06.316 --> 00:05:07.426 A:middle
that allows this to happen.

00:05:07.986 --> 00:05:09.796 A:middle
I'm just going to move
through this at a high level

00:05:09.796 --> 00:05:10.776 A:middle
to make you aware of it.

00:05:10.776 --> 00:05:13.106 A:middle
For further details,
please see last year's talk.

00:05:13.926 --> 00:05:16.766 A:middle
But all you do now is
you create a structure

00:05:17.116 --> 00:05:19.806 A:middle
which describes the pixel format
that you're trying to get to.

00:05:20.766 --> 00:05:24.446 A:middle
And then you're going to
make a single function call,

00:05:24.446 --> 00:05:26.556 A:middle
vImage buffer, and
it was CGImage.

00:05:27.806 --> 00:05:29.916 A:middle
This takes an uninitialized
vImage buffer.

00:05:30.716 --> 00:05:32.736 A:middle
It takes the structure
describing the format

00:05:32.736 --> 00:05:34.136 A:middle
and the CGImage.

00:05:34.916 --> 00:05:36.896 A:middle
At the end of this,
it's going to return

00:05:36.896 --> 00:05:38.876 A:middle
in a fully initialized
vImage buffer,

00:05:39.266 --> 00:05:41.916 A:middle
and you can do whatever
you need to do.

00:05:42.496 --> 00:05:45.416 A:middle
The round trip is just as
easy, single function call.

00:05:45.706 --> 00:05:48.696 A:middle
So now we've performed all the
operations on the vImage buffer.

00:05:49.176 --> 00:05:51.166 A:middle
I stayed in the same
format so we can use

00:05:51.166 --> 00:05:53.806 A:middle
that same structure
describing the pixel format.

00:05:53.806 --> 00:05:57.296 A:middle
And this is going to
return a CGImageRef.

00:05:58.016 --> 00:06:01.766 A:middle
So some really great
inoperability with CGImageRef.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.016 --> 00:06:01.766 A:middle
So some really great
inoperability with CGImageRef.

00:06:02.096 --> 00:06:04.346 A:middle
It's really easy to
get your image data in

00:06:04.346 --> 00:06:05.546 A:middle
and out of vImage this way.

00:06:06.726 --> 00:06:12.346 A:middle
Last year we also introduced
some high level entry points

00:06:12.416 --> 00:06:14.936 A:middle
to some really amazing
conversion support.

00:06:15.726 --> 00:06:17.846 A:middle
And this through
vImageConvert AnyToAny.

00:06:19.116 --> 00:06:21.326 A:middle
It does exactly what it
sounds like it's going to do.

00:06:21.326 --> 00:06:24.416 A:middle
It allows you to convert
between nearly any pixel format

00:06:24.416 --> 00:06:25.726 A:middle
and any other pixel format.

00:06:26.916 --> 00:06:28.126 A:middle
Again, just at a high level

00:06:28.126 --> 00:06:30.756 A:middle
for further details,
see last year's talk.

00:06:30.756 --> 00:06:34.266 A:middle
But the way that it works is
you're going to create two

00:06:34.266 --> 00:06:36.396 A:middle
of these structures
describing the pixel formats.

00:06:36.846 --> 00:06:41.836 A:middle
One for the source format,
one for the destination type.

00:06:42.326 --> 00:06:43.676 A:middle
Then you create a converter.

00:06:43.676 --> 00:06:47.106 A:middle
And then with that converter
you can create image.

00:06:47.106 --> 00:06:49.956 A:middle
You can convert between
the two image formats.

00:06:49.956 --> 00:06:53.636 A:middle
You can convert as many as you
want with a single converter.

00:06:54.176 --> 00:06:58.876 A:middle
So, this allows you to convert
between nearly any pixel format.

00:06:59.156 --> 00:07:02.086 A:middle
To the power user, this
means you can get almost any


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.156 --> 00:07:02.086 A:middle
To the power user, this
means you can get almost any

00:07:02.086 --> 00:07:04.366 A:middle
of your image formats
into a format

00:07:04.366 --> 00:07:08.266 A:middle
that the image can consume
very easily, very efficiently,

00:07:08.266 --> 00:07:09.886 A:middle
and it's going to
run extremely fast.

00:07:10.456 --> 00:07:14.746 A:middle
You guys had some really
great things to say

00:07:14.746 --> 00:07:15.996 A:middle
about these two new features.

00:07:16.346 --> 00:07:18.036 A:middle
One Twitter user said,

00:07:18.036 --> 00:07:20.256 A:middle
"functions that convert
vImage objects

00:07:20.256 --> 00:07:23.186 A:middle
to CGImage objects
and back," thumbs up.

00:07:24.016 --> 00:07:25.796 A:middle
Another Twitter user said,

00:07:25.796 --> 00:07:28.146 A:middle
"vImageConvert AnyToAny
is magical.

00:07:28.686 --> 00:07:32.116 A:middle
Threaded and vectorized
conversion

00:07:32.116 --> 00:07:34.166 A:middle
between nearly any
two pixel formats."

00:07:35.556 --> 00:07:37.326 A:middle
We really appreciate
the feedback.

00:07:37.576 --> 00:07:39.946 A:middle
We're very happy that
you guys are using this

00:07:39.946 --> 00:07:41.706 A:middle
and find it useful.

00:07:41.706 --> 00:07:43.096 A:middle
Please keep the feedback coming.

00:07:43.636 --> 00:07:49.546 A:middle
So with that I want to introduce
video support to vImage.

00:07:50.976 --> 00:07:54.386 A:middle
This is new in both
iOS 8.0 and OS X 10.10.

00:07:54.386 --> 00:07:59.946 A:middle
And I'm going to start with
the high level functionality


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.256 --> 00:08:01.876 A:middle
from a CVPixelBufferRef.

00:08:02.136 --> 00:08:04.106 A:middle
So this is a single video frame.

00:08:04.106 --> 00:08:07.946 A:middle
And we're introducing
the same interoperability

00:08:07.946 --> 00:08:10.926 A:middle
and the same ease of use that
we saw with core graphics.

00:08:12.236 --> 00:08:16.756 A:middle
So now if you want to get your
CVPixelBufferRef into a format

00:08:16.756 --> 00:08:19.986 A:middle
that the image can operate on,
it's a single function call.

00:08:20.946 --> 00:08:22.426 A:middle
You're going to use
that same structure

00:08:22.426 --> 00:08:24.516 A:middle
which describes the format
which you're trying to get to.

00:08:24.516 --> 00:08:27.606 A:middle
And then you're going
to call vImageBuffer

00:08:27.606 --> 00:08:29.126 A:middle
and it with CVPixelBuffer.

00:08:30.226 --> 00:08:32.676 A:middle
It takes an uninitialized
vImageBuffer.

00:08:33.496 --> 00:08:36.346 A:middle
It takes the structure
describing the format,

00:08:36.346 --> 00:08:37.586 A:middle
and the CVPixelBuffer.

00:08:38.155 --> 00:08:41.356 A:middle
There's some additional
arguments for the power user

00:08:41.356 --> 00:08:43.436 A:middle
which we'll see a little
bit more about in a second.

00:08:43.996 --> 00:08:47.986 A:middle
At the end of this you've got
a freshly initialized vImage

00:08:47.986 --> 00:08:51.506 A:middle
buffer, and you can perform
any operation you want.

00:08:52.756 --> 00:08:54.616 A:middle
The round trip is just as easy.

00:08:54.656 --> 00:08:55.976 A:middle
So vImageBuffer back

00:08:55.976 --> 00:09:00.726 A:middle
to CVPixelBufferRef is vImage
copied to CVPixelBuffer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:55.976 --> 00:09:00.726 A:middle
to CVPixelBufferRef is vImage
copied to CVPixelBuffer.

00:09:01.696 --> 00:09:04.256 A:middle
Takes the vImageBuffer that
you just finished working with,

00:09:04.596 --> 00:09:07.566 A:middle
the buffer format
describing the pixel format.

00:09:08.286 --> 00:09:12.676 A:middle
And then the CVPixelBuffer that
you're trying to copy back to.

00:09:13.666 --> 00:09:15.786 A:middle
So there's some great
interoperability now

00:09:15.786 --> 00:09:17.046 A:middle
with core graphics as well.

00:09:18.656 --> 00:09:24.196 A:middle
To support the high level
functionality that we just saw,

00:09:24.356 --> 00:09:26.116 A:middle
there's a lot going
on behind the scenes.

00:09:26.636 --> 00:09:28.826 A:middle
All of this is exposed
to you as well.

00:09:28.826 --> 00:09:31.246 A:middle
So, the lower level interfaces.

00:09:31.506 --> 00:09:34.236 A:middle
There's forty-one new video
conversions which are supported.

00:09:34.776 --> 00:09:38.786 A:middle
You can, through some of the
other arguments that we saw,

00:09:38.786 --> 00:09:40.786 A:middle
do things like manage
the chroma siting,

00:09:41.696 --> 00:09:45.206 A:middle
work with transfer functions,
and conversion matrices.

00:09:46.106 --> 00:09:49.456 A:middle
There's a lot that
you can do with this.

00:09:49.666 --> 00:09:51.466 A:middle
Another one that is really
neat if you've worked

00:09:51.466 --> 00:09:54.616 A:middle
with video formats
before is RGB colorspaces.

00:09:55.806 --> 00:09:58.376 A:middle
So there's some subtleties
and some,

00:09:58.886 --> 00:10:03.306 A:middle
it's just a little bit
tricky and complicated


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.886 --> 00:10:03.306 A:middle
it's just a little bit
tricky and complicated

00:10:03.646 --> 00:10:05.006 A:middle
to get an RGB colorspace.

00:10:05.006 --> 00:10:09.786 A:middle
And vImage makes this really
simple and easy to do.

00:10:10.046 --> 00:10:13.046 A:middle
vImageConvert AnyToAny is
extended to support all

00:10:13.046 --> 00:10:14.576 A:middle
of the video formats now.

00:10:14.666 --> 00:10:17.856 A:middle
And there's two great
new convenience routines

00:10:18.326 --> 00:10:20.996 A:middle
which allow you to create
converters to convert back

00:10:20.996 --> 00:10:23.726 A:middle
and forth between core
graphics and core video.

00:10:24.306 --> 00:10:27.046 A:middle
So now with video support

00:10:27.046 --> 00:10:29.286 A:middle
in vImage we've got
great interoperability

00:10:29.286 --> 00:10:33.946 A:middle
with both core graphics, core
video, really fast conversions

00:10:33.946 --> 00:10:38.346 A:middle
for both image and
video pixel formats.

00:10:38.736 --> 00:10:41.186 A:middle
And really fast operations
once you're in vImage.

00:10:41.586 --> 00:10:44.586 A:middle
I want to show you some
typical performance.

00:10:45.346 --> 00:10:48.666 A:middle
So what I have here is
performance from VideoToolbox.

00:10:49.596 --> 00:10:54.906 A:middle
This is available in
CoreMedia, and what I've got

00:10:54.906 --> 00:10:58.876 A:middle
on this graph is showing the
speed and megapixels per second

00:10:58.876 --> 00:11:04.986 A:middle
on the Y axis to convert
from VRGA 8 bit pixel format


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:58.876 --> 00:11:04.986 A:middle
on the Y axis to convert
from VRGA 8 bit pixel format

00:11:05.276 --> 00:11:09.286 A:middle
to the pixel format
shown on the X axis.

00:11:09.446 --> 00:11:11.676 A:middle
The gray bar is OS X 10.9.

00:11:11.806 --> 00:11:15.396 A:middle
This is before VideoToolbox
had adopted vImage.

00:11:15.956 --> 00:11:19.326 A:middle
And then the blue
bar is OS X 10.10

00:11:19.886 --> 00:11:22.126 A:middle
after VideoToolbox
adopted the image.

00:11:23.176 --> 00:11:24.306 A:middle
We see a few things here.

00:11:25.386 --> 00:11:27.916 A:middle
First we see some really great
performance improvements.

00:11:28.536 --> 00:11:30.906 A:middle
So vImage conversions are
going to be really fast.

00:11:31.076 --> 00:11:33.106 A:middle
In some cases we're up
to five times faster.

00:11:33.726 --> 00:11:36.946 A:middle
The other thing that we see
all the way at the right,

00:11:36.946 --> 00:11:42.276 A:middle
the v210 image format wasn't
even supported before.

00:11:43.296 --> 00:11:45.226 A:middle
The image supports a
wide range of formats,

00:11:45.226 --> 00:11:46.606 A:middle
and it made it really
easy for them

00:11:46.606 --> 00:11:50.686 A:middle
to produce new features
once they adopted the image

00:11:50.766 --> 00:11:51.596 A:middle
video support.

00:11:52.446 --> 00:11:54.756 A:middle
So this is what you can
expect out of vImage.

00:11:55.166 --> 00:11:56.166 A:middle
Great performance.

00:11:57.376 --> 00:12:00.346 A:middle
Simple, easy to use,
good interoperability


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.376 --> 00:12:00.346 A:middle
Simple, easy to use,
good interoperability

00:12:00.346 --> 00:12:01.736 A:middle
with core graphics
and core video.

00:12:02.326 --> 00:12:07.026 A:middle
Now I want to move
on to LinearAlgebra.

00:12:08.306 --> 00:12:12.066 A:middle
This is a new sub-framework
in the Accelerate Framework.

00:12:12.396 --> 00:12:14.476 A:middle
It is designed to
be simple access

00:12:14.806 --> 00:12:16.246 A:middle
to high-performance
LinearAlgebra.

00:12:16.246 --> 00:12:21.606 A:middle
I want to begin with
a motivating example.

00:12:22.176 --> 00:12:25.666 A:middle
How do you solve a system
of linear equations?

00:12:25.926 --> 00:12:30.126 A:middle
Let's look at how you do this
with a LAPACK, also available

00:12:30.126 --> 00:12:31.086 A:middle
in the Accelerate Framework.

00:12:31.086 --> 00:12:34.606 A:middle
And this is saying if we've
got a system of equations

00:12:35.916 --> 00:12:38.916 A:middle
in sub-matrix A on
the right-hand side

00:12:38.916 --> 00:12:42.936 A:middle
and sub-matrix B,
how do we find AX=B.

00:12:43.036 --> 00:12:49.596 A:middle
So with a LAPACK, it's going
to look something like this.

00:12:49.816 --> 00:12:51.416 A:middle
It's not terribly
straight forward.

00:12:52.996 --> 00:12:56.366 A:middle
The naming convention in
a LAPACK uses short names,

00:12:56.536 --> 00:12:58.336 A:middle
so you're going to
have to figure

00:12:58.336 --> 00:13:01.556 A:middle
out that sgesv means solve
system of linear equations.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.336 --> 00:13:01.556 A:middle
out that sgesv means solve
system of linear equations.

00:13:02.706 --> 00:13:05.506 A:middle
Once you're there, the
argument names are not going

00:13:06.116 --> 00:13:08.086 A:middle
to be much better.

00:13:08.396 --> 00:13:10.926 A:middle
You're passing by
reference here.

00:13:10.926 --> 00:13:13.526 A:middle
All of the argument
types are CLPK integer.

00:13:13.656 --> 00:13:17.166 A:middle
So there's going to be
a lot of explicit casts.

00:13:17.956 --> 00:13:20.426 A:middle
Additionally, there's going to
be a lot of memory management

00:13:20.426 --> 00:13:22.686 A:middle
that you need to do
explicitly, workspaces,

00:13:22.686 --> 00:13:25.536 A:middle
or in this case a pivot vector
that you need to create.

00:13:26.906 --> 00:13:29.096 A:middle
So there's a lot to just
finding the right routine

00:13:29.096 --> 00:13:30.296 A:middle
and then using it correctly.

00:13:30.966 --> 00:13:34.616 A:middle
We think it should be
much simpler than this.

00:13:34.816 --> 00:13:36.056 A:middle
Let's look at how
you solve the system

00:13:36.056 --> 00:13:38.376 A:middle
of linear equations
with LinearAlgebra.

00:13:38.996 --> 00:13:41.936 A:middle
It's going to be really simple.

00:13:42.716 --> 00:13:44.686 A:middle
It's simply going
to be la-solve.

00:13:44.686 --> 00:13:47.926 A:middle
All of the details are
going to be managed

00:13:47.926 --> 00:13:48.916 A:middle
for you behind the scenes.

00:13:49.476 --> 00:13:54.656 A:middle
So with that let's dive into
what exactly you're going to get

00:13:54.656 --> 00:13:56.356 A:middle
out of the LinearAlgebra
sub-framework.

00:13:57.206 --> 00:14:02.886 A:middle
So it's new in both
iOS 8.0 and OS 10.10.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.206 --> 00:14:02.886 A:middle
So it's new in both
iOS 8.0 and OS 10.10.

00:14:03.096 --> 00:14:05.596 A:middle
It is designed to be simple
with good performance.

00:14:09.316 --> 00:14:13.016 A:middle
It has got single and
double precision support.

00:14:13.016 --> 00:14:16.766 A:middle
So it's not going to be mixed,
much like BLAS and LAPACK.

00:14:18.096 --> 00:14:22.946 A:middle
It is, got support
for Objective-C,

00:14:22.946 --> 00:14:25.966 A:middle
so the object is going to be a
native of Objective-C Object.

00:14:30.816 --> 00:14:33.716 A:middle
What are you going to
find in LinearAlgebra?

00:14:34.276 --> 00:14:36.006 A:middle
There's a huge range
of functionality.

00:14:36.056 --> 00:14:38.656 A:middle
We've got element-wise
operations, add, subtract.

00:14:40.246 --> 00:14:41.116 A:middle
Matrix products.

00:14:41.276 --> 00:14:44.486 A:middle
This could be inner product,
outer product, matrix, matrix.

00:14:45.516 --> 00:14:46.096 A:middle
Transposes.

00:14:46.096 --> 00:14:49.416 A:middle
There's support for
norms and normalizations.

00:14:49.846 --> 00:14:53.636 A:middle
Support for solving systems
with linear equations.

00:14:53.776 --> 00:14:55.966 A:middle
And then two pieces
which are unique

00:14:55.966 --> 00:14:57.246 A:middle
to the LinearAlgebra
sub-framework,

00:14:57.246 --> 00:14:59.266 A:middle
and those are slice and splat.

00:14:59.266 --> 00:15:00.526 A:middle
And we'll see about those


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.266 --> 00:15:00.526 A:middle
And we'll see about those

00:15:00.526 --> 00:15:02.696 A:middle
in further detail
a little bit later.

00:15:03.596 --> 00:15:05.856 A:middle
Well let's begin with a
new LinearAlgebra object.

00:15:07.596 --> 00:15:10.316 A:middle
The LinearAlgebra object is a
reference counted opaque object.

00:15:10.316 --> 00:15:14.206 A:middle
As I said it's an Objective-C
Object in Objective-C.

00:15:15.106 --> 00:15:16.646 A:middle
It still works in C though.

00:15:17.236 --> 00:15:20.846 A:middle
It manages a lot
of things for you.

00:15:21.646 --> 00:15:24.756 A:middle
So in that initial
LAPACK example we saw

00:15:24.756 --> 00:15:28.066 A:middle
that for each argument you're
tracking a pointer, the row

00:15:28.066 --> 00:15:30.976 A:middle
and column dimensions,
leading dimension or a stride.

00:15:30.976 --> 00:15:32.576 A:middle
There's a lot of things
for each argument.

00:15:32.576 --> 00:15:33.936 A:middle
It means you have
a lot of arguments.

00:15:34.306 --> 00:15:35.366 A:middle
There's a lot going on.

00:15:36.286 --> 00:15:38.686 A:middle
Here the object is going to
keep track of the data buffer.

00:15:39.556 --> 00:15:41.006 A:middle
It's going to keep
track of the dimensions

00:15:41.006 --> 00:15:42.096 A:middle
of each of these objects.

00:15:42.576 --> 00:15:44.606 A:middle
Errors and warnings
are attached directly

00:15:44.606 --> 00:15:46.366 A:middle
to the object making
it really convenient.

00:15:46.366 --> 00:15:49.056 A:middle
And then finally scalar type.

00:15:49.056 --> 00:15:52.826 A:middle
So with BLAS and LAPACK you've
got all the APIs duplicated,

00:15:53.176 --> 00:15:54.716 A:middle
one for single and
one for double.

00:15:54.716 --> 00:16:00.816 A:middle
We can collapse all that down
to half the number of APIs.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:54.716 --> 00:16:00.816 A:middle
We can collapse all that down
to half the number of APIs.

00:16:01.036 --> 00:16:03.636 A:middle
Memory management for these
LinearAlgebra objects.

00:16:03.896 --> 00:16:06.226 A:middle
Again these are reference
counted objects.

00:16:06.226 --> 00:16:08.696 A:middle
There's a lot of documentation
about reference counted objects.

00:16:08.696 --> 00:16:09.786 A:middle
There's nothing new here.

00:16:10.246 --> 00:16:13.186 A:middle
Just very briefly from C,
you're going to use la-

00:16:13.186 --> 00:16:14.966 A:middle
release and la-retain.

00:16:15.476 --> 00:16:18.046 A:middle
You do not ever free these.

00:16:18.286 --> 00:16:20.916 A:middle
From Objective-C,
they take the standard

00:16:20.916 --> 00:16:22.316 A:middle
release/retain messages.

00:16:22.316 --> 00:16:25.956 A:middle
And then finally,
Objective-C with ARC,

00:16:26.266 --> 00:16:27.616 A:middle
which is what we recommend.

00:16:28.056 --> 00:16:29.696 A:middle
Just lets you write
exactly what you want

00:16:29.696 --> 00:16:31.286 A:middle
with no explicit
memory management.

00:16:32.316 --> 00:16:34.656 A:middle
From here on out, all the
examples that I show are going

00:16:34.656 --> 00:16:37.226 A:middle
to be Objective-C using
ARC, so there's going

00:16:37.226 --> 00:16:38.846 A:middle
to be no memory management.

00:16:39.366 --> 00:16:43.676 A:middle
So how do you get
your data into one

00:16:43.676 --> 00:16:45.086 A:middle
of these LinearAlgebra objects?

00:16:45.656 --> 00:16:49.486 A:middle
In this example, we're
going to allocate a buffer.

00:16:49.706 --> 00:16:53.776 A:middle
It's going to be some number of
rows by some number of columns,

00:16:53.776 --> 00:16:56.656 A:middle
and we know the row stride
and number of elements.

00:16:57.236 --> 00:16:59.346 A:middle
We're going to fill that
as a row major matrix.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.286 --> 00:17:03.456 A:middle
Then to get that matrix into
the LinearAlgebra domain,

00:17:03.456 --> 00:17:05.455 A:middle
we're going to just
call LA matrix

00:17:05.455 --> 00:17:07.185 A:middle
from float or double buffer.

00:17:08.116 --> 00:17:09.876 A:middle
It takes the pointer,
the dimensions

00:17:09.876 --> 00:17:12.116 A:middle
of the matrix, the row stride.

00:17:13.715 --> 00:17:15.326 A:middle
And then hints which we'll see

00:17:15.326 --> 00:17:17.896 A:middle
on the next slide a little
bit more details about those.

00:17:17.896 --> 00:17:21.606 A:middle
And then attributes, which
are attached to objects.

00:17:22.876 --> 00:17:24.175 A:middle
These attributes allow you

00:17:24.175 --> 00:17:26.746 A:middle
to do things enable
additional debug logging.

00:17:27.336 --> 00:17:30.686 A:middle
In this particular case,
the data is copied out of A

00:17:30.686 --> 00:17:32.536 A:middle
so the users retained
all rights to A.

00:17:32.536 --> 00:17:34.826 A:middle
In this case they
need to free it.

00:17:38.236 --> 00:17:42.426 A:middle
So hints, when you're
passing data to LinearAlgebra,

00:17:42.716 --> 00:17:44.596 A:middle
there's some information
that can be beneficial

00:17:44.676 --> 00:17:47.156 A:middle
to the framework to deliver
the maximum performance.

00:17:47.926 --> 00:17:51.446 A:middle
So hints are designed to allow
for this, to allow for you

00:17:51.446 --> 00:17:56.286 A:middle
to give us details and
insights about the buffer

00:17:57.246 --> 00:18:00.376 A:middle
so that we can use the right
routines behind the scenes.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:57.246 --> 00:18:00.376 A:middle
so that we can use the right
routines behind the scenes.

00:18:01.266 --> 00:18:04.086 A:middle
So for example, if you know that
you're a diagonal or a triangle

00:18:04.086 --> 00:18:06.506 A:middle
or matrix, we can leverage that.

00:18:07.436 --> 00:18:10.336 A:middle
These are hints, so if you pass
the wrong hint it's not going

00:18:10.336 --> 00:18:11.666 A:middle
to give you a wrong result.

00:18:11.666 --> 00:18:13.966 A:middle
It may just add additional
overhead.

00:18:14.096 --> 00:18:16.456 A:middle
If you don't know,
just use LA no hint.

00:18:20.676 --> 00:18:23.506 A:middle
The next piece I want to talk
about is Lazy Evaluation.

00:18:23.636 --> 00:18:28.086 A:middle
I want to do that with a fairly
large example for a slide.

00:18:28.206 --> 00:18:30.976 A:middle
So it's not important that you
understand exactly what's going

00:18:30.976 --> 00:18:32.006 A:middle
on in all of this code.

00:18:32.006 --> 00:18:34.386 A:middle
I just want to walk
through it at a high level

00:18:34.386 --> 00:18:36.176 A:middle
so that you can understand
what's going

00:18:36.176 --> 00:18:40.686 A:middle
on behind the scenes.

00:18:40.866 --> 00:18:43.186 A:middle
LinearAlgebra uses
an evaluation graph.

00:18:43.416 --> 00:18:44.736 A:middle
When you create an object,

00:18:44.736 --> 00:18:47.316 A:middle
evaluation is not
necessarily going to occur.

00:18:47.316 --> 00:18:49.556 A:middle
It's going to be added
into this evaluation graph.

00:18:50.176 --> 00:18:51.486 A:middle
So at the start of
this function,

00:18:51.486 --> 00:18:53.276 A:middle
we've got two evaluation graphs

00:18:53.466 --> 00:18:56.616 A:middle
with a single note
in each of them.

00:18:56.676 --> 00:18:58.316 A:middle
And as we step through
this code we're going

00:18:58.316 --> 00:18:59.386 A:middle
to create additional objects.

00:18:59.926 --> 00:19:01.846 A:middle
So in this case we
create a transpose.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.926 --> 00:19:01.846 A:middle
So in this case we
create a transpose.

00:19:02.236 --> 00:19:04.466 A:middle
We add that to our
evaluation graph.

00:19:05.596 --> 00:19:08.046 A:middle
Then we take the sum of
the odd elements of x

00:19:08.346 --> 00:19:11.646 A:middle
and the even elements of x.

00:19:12.086 --> 00:19:14.166 A:middle
Again, we just add that
to the evaluation graph.

00:19:15.276 --> 00:19:16.126 A:middle
And we continue.

00:19:16.126 --> 00:19:23.226 A:middle
This time the product of At
and x2, all scaled by 3.2.

00:19:24.366 --> 00:19:26.606 A:middle
All of this is just added
to this evaluation graph.

00:19:26.606 --> 00:19:30.006 A:middle
At no point has any
evaluation occurred

00:19:30.006 --> 00:19:33.446 A:middle
or any temporary data
structures been allocated.

00:19:34.116 --> 00:19:40.396 A:middle
So no computation is going to
occur until you trigger it.

00:19:41.616 --> 00:19:43.706 A:middle
This allows us to
not perform a lot

00:19:43.706 --> 00:19:46.616 A:middle
of frivolous memory
allocations and computations.

00:19:46.956 --> 00:19:49.606 A:middle
And right now we don't
trigger a computation

00:19:49.606 --> 00:19:51.696 A:middle
until you've explicitly
ask for data back.

00:19:52.886 --> 00:19:55.626 A:middle
This is going to happen
with la-matrix to float

00:19:55.626 --> 00:19:56.496 A:middle
or double-buffer,

00:19:56.926 --> 00:19:59.146 A:middle
or la-vector-to-float
or double-buffer.

00:19:59.766 --> 00:20:03.706 A:middle
So again, creating these objects
is going to be lightweight.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.766 --> 00:20:03.706 A:middle
So again, creating these objects
is going to be lightweight.

00:20:03.706 --> 00:20:05.826 A:middle
We're going to do a lot
of work behind the scenes

00:20:05.866 --> 00:20:07.416 A:middle
to make this run extremely fast.

00:20:07.416 --> 00:20:10.176 A:middle
And we're only going
to compute the data

00:20:10.176 --> 00:20:12.076 A:middle
that you request at the end.

00:20:13.156 --> 00:20:15.476 A:middle
I want to show you some
performance results

00:20:16.096 --> 00:20:17.636 A:middle
for the routine that
we just saw.

00:20:18.866 --> 00:20:21.056 A:middle
Before I do that, I want
to introduce Netlib BLAS.

00:20:22.026 --> 00:20:24.326 A:middle
This is an open source
implementation of BLAS.

00:20:24.326 --> 00:20:27.316 A:middle
I said if you weren't aware
that BLAS was available

00:20:27.316 --> 00:20:28.276 A:middle
in the Accelerated Framework,

00:20:28.316 --> 00:20:29.846 A:middle
this is probably
the implementation

00:20:29.846 --> 00:20:31.196 A:middle
that you would find
yourself using.

00:20:31.436 --> 00:20:34.786 A:middle
So now let's look at the
performance of that routine

00:20:34.786 --> 00:20:36.886 A:middle
that we were looking at before.

00:20:37.636 --> 00:20:41.146 A:middle
On the X axis we've got
various matrix sizes.

00:20:42.196 --> 00:20:44.046 A:middle
On the Y axis we've
got gigaflops,

00:20:44.306 --> 00:20:45.586 A:middle
so higher is going to be better.

00:20:46.126 --> 00:20:49.886 A:middle
Here's the performance of
the LinearAlgebra Framework.

00:20:51.006 --> 00:20:52.166 A:middle
We can see it's pretty good.

00:20:52.166 --> 00:20:54.276 A:middle
Let's compare it to
the accelerated BLAS,

00:20:54.276 --> 00:20:57.656 A:middle
an extremely high
performance benchmark here.

00:20:58.286 --> 00:21:02.316 A:middle
What we see here is
LinearAlgebra is getting most


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.286 --> 00:21:02.316 A:middle
What we see here is
LinearAlgebra is getting most

00:21:02.316 --> 00:21:04.266 A:middle
of the performance that
the Accelerated Framework

00:21:04.266 --> 00:21:04.816 A:middle
can deliver.

00:21:05.666 --> 00:21:08.346 A:middle
Much simpler to get all of the
performance from LinearAlgebra.

00:21:09.126 --> 00:21:11.406 A:middle
There is a discrepancy
on the small end.

00:21:11.406 --> 00:21:14.636 A:middle
There are fixed costs
associated with these objects

00:21:14.636 --> 00:21:17.136 A:middle
which are magnified
for smaller matrices.

00:21:18.136 --> 00:21:20.846 A:middle
But overall, you're getting
most of the performance

00:21:20.986 --> 00:21:22.726 A:middle
with a really simple clean API.

00:21:22.726 --> 00:21:26.226 A:middle
I just want to put this
performance comparison

00:21:26.226 --> 00:21:27.026 A:middle
into perspective.

00:21:27.396 --> 00:21:28.266 A:middle
What if you had used

00:21:28.296 --> 00:21:31.016 A:middle
that open-sourced NetLib
implementation of BLAS?

00:21:31.596 --> 00:21:33.946 A:middle
Your performance
would look like this.

00:21:34.026 --> 00:21:36.816 A:middle
So you can see, you're
getting a lot

00:21:36.816 --> 00:21:40.086 A:middle
of the possible performance
from LinearAlgebra.

00:21:40.586 --> 00:21:45.786 A:middle
Next I want to talk
about error handling.

00:21:46.806 --> 00:21:48.316 A:middle
So what I've got here
is just a sequence

00:21:48.316 --> 00:21:49.796 A:middle
of operations with
LinearAlgebra.

00:21:50.136 --> 00:21:53.016 A:middle
After each operation we're
checking the error status.

00:21:54.436 --> 00:21:56.056 A:middle
We don't recommend
you doing it this way.

00:21:57.926 --> 00:22:00.366 A:middle
What we recommend you doing
is checking the error once


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.926 --> 00:22:00.366 A:middle
What we recommend you doing
is checking the error once

00:22:00.366 --> 00:22:00.856 A:middle
at the end.

00:22:02.216 --> 00:22:05.216 A:middle
So errors are going to be
attached to and propagated

00:22:05.216 --> 00:22:06.696 A:middle
through these evaluation graphs.

00:22:07.156 --> 00:22:09.676 A:middle
So if we have an error
in the first statement,

00:22:09.966 --> 00:22:12.366 A:middle
that error is going to be
attached to the object AB.

00:22:12.946 --> 00:22:15.036 A:middle
Sum is going to see that
there is an error there

00:22:15.036 --> 00:22:18.296 A:middle
and just propagate it through.

00:22:18.516 --> 00:22:20.776 A:middle
Additionally with Lazy
Evaluation, there's a class

00:22:20.776 --> 00:22:22.426 A:middle
of errors that may
not be triggered

00:22:22.426 --> 00:22:24.366 A:middle
until computation time.

00:22:25.226 --> 00:22:28.276 A:middle
So it's always best to check
the status as late as possible.

00:22:28.956 --> 00:22:30.926 A:middle
In this case we're
trying to write back

00:22:30.926 --> 00:22:33.506 A:middle
to the buffer before we
even check the status.

00:22:34.296 --> 00:22:37.216 A:middle
The way that we recommend
you checking the status is

00:22:37.216 --> 00:22:40.056 A:middle
if the status is
zero or LA-SUCCESS,

00:22:40.556 --> 00:22:41.636 A:middle
then everything went well.

00:22:41.926 --> 00:22:43.596 A:middle
In this case, you've
got data in your buffer.

00:22:44.686 --> 00:22:47.496 A:middle
If it's greater than zero, there
was some warning, you're going

00:22:47.496 --> 00:22:50.256 A:middle
to have data there but you
may not have full accuracy.

00:22:50.796 --> 00:22:54.836 A:middle
And then finally less than
zero some hard error occurred.

00:22:55.166 --> 00:22:58.266 A:middle
In this case there's going
to be no data in that buffer.

00:22:58.776 --> 00:23:01.126 A:middle
This might be something
like a dimension mismatch


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.776 --> 00:23:01.126 A:middle
This might be something
like a dimension mismatch

00:23:01.126 --> 00:23:02.976 A:middle
or something we just
can't recover from.

00:23:03.556 --> 00:23:07.956 A:middle
So this sort of begs the
question, how do we debug this

00:23:07.956 --> 00:23:12.316 A:middle
if we've got all this late
error checking, Lazy Evaluation?

00:23:16.936 --> 00:23:20.726 A:middle
The best way to do this
is to enable debug logging

00:23:20.996 --> 00:23:23.066 A:middle
with LA-ATTRIBUTE-ENABLE-
LOGGING.

00:23:24.316 --> 00:23:26.816 A:middle
When you do this and you
encounter an error or warning,

00:23:27.116 --> 00:23:29.626 A:middle
you're going to get a message
like this to standard error.

00:23:29.986 --> 00:23:33.406 A:middle
This is going to help you
determine what the error was

00:23:33.406 --> 00:23:36.006 A:middle
and where it occurred,
which really helps you

00:23:36.006 --> 00:23:38.306 A:middle
to quickly narrow down where
the problem is coming from.

00:23:38.306 --> 00:23:41.946 A:middle
I want to talk a little bit
about the details of the solve.

00:23:42.236 --> 00:23:45.346 A:middle
So if you're familiar with
LinearAlgebra, if you've worked

00:23:45.346 --> 00:23:48.616 A:middle
with LAPACK before, you know
there's a lot of options here.

00:23:48.986 --> 00:23:49.676 A:middle
So I just want to talk

00:23:49.676 --> 00:23:51.816 A:middle
about what our solve
is doing at this point.

00:23:51.816 --> 00:23:54.796 A:middle
So if A is square and
non-singular matrix,

00:23:54.796 --> 00:23:58.036 A:middle
it's going to compute
the solution to Ax = b.

00:23:59.056 --> 00:24:01.416 A:middle
If A is square and
it's singular,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.056 --> 00:24:01.416 A:middle
If A is square and
it's singular,

00:24:01.416 --> 00:24:02.656 A:middle
it's going to produce an error.

00:24:03.716 --> 00:24:08.996 A:middle
So right now, it's pretty
straightforward to do,

00:24:09.226 --> 00:24:14.406 A:middle
and this is what you're
going to get out of it.

00:24:15.146 --> 00:24:18.216 A:middle
The next piece which is unique
to LinearAlgebra is slicing.

00:24:19.216 --> 00:24:22.416 A:middle
So slicing is light weight
access to partial objects.

00:24:23.036 --> 00:24:26.596 A:middle
I say lightweight
access, so there's going

00:24:26.596 --> 00:24:29.186 A:middle
to be no buffer allocation
and no copy.

00:24:30.126 --> 00:24:32.186 A:middle
Things that you can do with
slices are for example,

00:24:32.186 --> 00:24:35.676 A:middle
taking the odd elements
of a vector.

00:24:35.826 --> 00:24:38.416 A:middle
We shouldn't have to
allocate a temporary buffer

00:24:38.416 --> 00:24:40.006 A:middle
and copy those odd
elements out into

00:24:40.006 --> 00:24:43.046 A:middle
that buffer if we don't need to.

00:24:43.046 --> 00:24:47.006 A:middle
And when I say that there's
no allocation and no copy,

00:24:47.006 --> 00:24:49.216 A:middle
don't confuse this
with Lazy Evaluation,

00:24:49.216 --> 00:24:50.576 A:middle
this is added evaluation time.

00:24:50.836 --> 00:24:52.726 A:middle
We're going to do
everything that we can just

00:24:52.726 --> 00:24:56.476 A:middle
to access that data in place.

00:24:56.646 --> 00:24:58.006 A:middle
There's three pieces
of information

00:24:58.006 --> 00:24:59.806 A:middle
that you need to create a slice.

00:24:59.806 --> 00:25:03.226 A:middle
That is offset, stride
and dimension.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.806 --> 00:25:03.226 A:middle
That is offset, stride
and dimension.

00:25:04.366 --> 00:25:05.946 A:middle
And let's look at an example.

00:25:06.326 --> 00:25:10.636 A:middle
Let's say we wanted to slice
and get some of the elements

00:25:10.636 --> 00:25:12.156 A:middle
out of an existing
vector already.

00:25:12.796 --> 00:25:15.796 A:middle
The first argument is
going to be the offset.

00:25:15.796 --> 00:25:17.736 A:middle
This is a zero based offset.

00:25:18.126 --> 00:25:20.676 A:middle
So if you start with the 8th
element it's going to be 7.

00:25:21.886 --> 00:25:26.146 A:middle
The stride is the direction
and number of elements

00:25:26.146 --> 00:25:27.116 A:middle
that we're going to move.

00:25:27.946 --> 00:25:30.076 A:middle
In this case it's
negative 2, so we're going

00:25:30.076 --> 00:25:31.336 A:middle
to move back two elements.

00:25:32.216 --> 00:25:34.196 A:middle
And then finally,
the dimension is 3.

00:25:34.796 --> 00:25:37.756 A:middle
So we're going to have this
view of a three element vector,

00:25:38.846 --> 00:25:41.086 A:middle
which is really elements
out of some larger vector.

00:25:41.436 --> 00:25:45.436 A:middle
Again, no copy, no allocation
here, just a lightweight access

00:25:45.916 --> 00:25:47.636 A:middle
of elements in some
larger object.

00:25:48.096 --> 00:25:52.266 A:middle
One of the ways that
you might use this is

00:25:52.266 --> 00:25:54.376 A:middle
to create a tiling engine.

00:25:55.556 --> 00:25:57.026 A:middle
Let's just look at
a simple example.

00:25:57.026 --> 00:25:59.236 A:middle
You want to sum two
matrices together.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.006 --> 00:26:02.986 A:middle
One of the ways you can do this
is with this simple nested loop.

00:26:03.976 --> 00:26:07.176 A:middle
And you would put your
slices inside the loop.

00:26:07.216 --> 00:26:08.756 A:middle
And you're slicing
the two operands.

00:26:08.756 --> 00:26:10.016 A:middle
A and B in this case here.

00:26:10.076 --> 00:26:12.226 A:middle
And you're creating
a partial result C.

00:26:12.646 --> 00:26:16.446 A:middle
Just using that C and then
getting the next partial sum.

00:26:17.546 --> 00:26:19.196 A:middle
So you can do it this way.

00:26:19.196 --> 00:26:20.666 A:middle
And it's going to work.

00:26:20.726 --> 00:26:23.826 A:middle
But we can actually do a
lot of this work for you.

00:26:24.716 --> 00:26:28.576 A:middle
So instead what we
recommend doing is hoisting

00:26:28.576 --> 00:26:29.726 A:middle
that sum out of the loop.

00:26:30.886 --> 00:26:33.126 A:middle
With a Lazy Evaluation,
nothing is going to happen here.

00:26:33.746 --> 00:26:37.806 A:middle
And instead to just put
the slice on the result.

00:26:37.806 --> 00:26:42.046 A:middle
So our picture has
changed a little bit.

00:26:42.156 --> 00:26:44.396 A:middle
It looks like something
different is happening here.

00:26:44.726 --> 00:26:47.776 A:middle
But behind the scenes, you're
actually getting what you saw

00:26:47.776 --> 00:26:48.686 A:middle
on the previous slide.

00:26:48.806 --> 00:26:50.746 A:middle
So you're getting
exactly what you want.

00:26:50.746 --> 00:26:52.826 A:middle
We're doing all the work
for you behind the scenes.

00:26:53.226 --> 00:26:55.326 A:middle
So it's really easy to
work with these slices.

00:26:55.326 --> 00:26:57.756 A:middle
And the rule of thumb
is to put them as close

00:26:57.796 --> 00:26:59.036 A:middle
to the result as possible.

00:26:59.036 --> 00:27:04.556 A:middle
The next piece is a splat.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.036 --> 00:27:04.556 A:middle
The next piece is a splat.

00:27:05.276 --> 00:27:08.596 A:middle
A splat is way to work
with scalar values

00:27:08.596 --> 00:27:10.606 A:middle
with vectors and matrices.

00:27:10.606 --> 00:27:15.506 A:middle
So let's say you want to add 2
to every element of a vector.

00:27:16.536 --> 00:27:18.486 A:middle
The way that you're going
to do this is you're going

00:27:18.486 --> 00:27:20.996 A:middle
to call la-sum with
your vector object.

00:27:20.996 --> 00:27:24.976 A:middle
And then you're going to
splat the scalar value 2.

00:27:25.046 --> 00:27:27.786 A:middle
So it's really easy to
do certain operations now

00:27:27.786 --> 00:27:31.016 A:middle
with scalars on matrices
and vectors.

00:27:33.316 --> 00:27:35.266 A:middle
So that's a high level
summary of LinearAlgebra.

00:27:36.126 --> 00:27:38.116 A:middle
It's got a really
simple, easy-to-use API.

00:27:39.396 --> 00:27:42.336 A:middle
It's got some great modern
language and runtime features.

00:27:42.336 --> 00:27:45.416 A:middle
And it's going to deliver
really good performance.

00:27:46.186 --> 00:27:50.876 A:middle
With that I want to turn it over
to Steve to talk about LINPACK.

00:27:51.386 --> 00:27:53.276 A:middle
&gt;&gt; Thanks Geoff.

00:27:53.276 --> 00:27:54.006 A:middle
So I'm Steve Canon.

00:27:54.536 --> 00:27:56.816 A:middle
I'm a Senior Engineer in the
Vector and Numerics Group.

00:27:56.816 --> 00:27:57.996 A:middle
I work with Geoff.

00:27:58.146 --> 00:28:01.846 A:middle
And I'm going to talk about
our other new feature shortly,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.146 --> 00:28:01.846 A:middle
And I'm going to talk about
our other new feature shortly,

00:28:01.846 --> 00:28:04.816 A:middle
but before I do that, I thought
we'd have a little bit of fun

00:28:04.926 --> 00:28:06.876 A:middle
and talk about LINPACK
real quickly.

00:28:07.326 --> 00:28:10.456 A:middle
So LINPACK is a benchmark
that originated

00:28:10.456 --> 00:28:12.306 A:middle
in the high-performance
computing community.

00:28:13.036 --> 00:28:16.836 A:middle
And what it really measures
is how fast are you able

00:28:17.126 --> 00:28:19.166 A:middle
to solve a system
of linear equations?

00:28:19.806 --> 00:28:22.726 A:middle
Now this might seem like kind
of an arbitrary benchmark.

00:28:23.366 --> 00:28:25.716 A:middle
But it turns out that
lots of computations

00:28:25.716 --> 00:28:28.826 A:middle
that we do every day boil down
to solving linear problems.

00:28:28.826 --> 00:28:32.206 A:middle
So this is really an important
thing to be able to do quickly.

00:28:33.626 --> 00:28:36.706 A:middle
Now when you talk about LINPACK,
it's important to keep in mind

00:28:37.086 --> 00:28:39.276 A:middle
that LINPACK is measuring
the speed

00:28:39.276 --> 00:28:41.356 A:middle
of both hardware and software.

00:28:41.956 --> 00:28:47.576 A:middle
You can't have great performance
on LINPACK without good hardware

00:28:47.786 --> 00:28:50.136 A:middle
and without good software
that takes advantage

00:28:50.136 --> 00:28:51.006 A:middle
of the hardware that you have.

00:28:51.636 --> 00:28:56.286 A:middle
The past few years, we've
shown you a shootout

00:28:56.286 --> 00:28:59.176 A:middle
between Accelerate
running on iOS devices

00:28:59.346 --> 00:29:03.196 A:middle
and what we like
to call Brand A.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.346 --> 00:29:03.196 A:middle
and what we like
to call Brand A.

00:29:03.196 --> 00:29:06.416 A:middle
Last year we showed
you a chart that looked

00:29:06.416 --> 00:29:10.926 A:middle
like this comparing Accelerate
running on the iPhone 5

00:29:11.516 --> 00:29:14.766 A:middle
against the best LINPACK
score that we were able

00:29:14.766 --> 00:29:17.666 A:middle
to find anywhere for
any Brand A device.

00:29:18.716 --> 00:29:20.986 A:middle
So this is performance
in gigaflops.

00:29:20.986 --> 00:29:21.936 A:middle
This is double precision.

00:29:22.406 --> 00:29:24.396 A:middle
See that Accelerate on
the iPhone 5 gives you

00:29:24.396 --> 00:29:26.476 A:middle
about 3 1/2 gigaflops on LINPACK

00:29:27.026 --> 00:29:28.506 A:middle
which is a really
impressive number.

00:29:28.666 --> 00:29:29.156 A:middle
It's great.

00:29:29.156 --> 00:29:32.466 A:middle
Now the past few years we
showed you a chart like this,

00:29:32.836 --> 00:29:36.946 A:middle
and then the next year Brand
A hardware would have improved

00:29:36.946 --> 00:29:39.256 A:middle
enough to make the
comparison more interesting.

00:29:39.256 --> 00:29:40.876 A:middle
And then we could
blow you away again

00:29:40.876 --> 00:29:43.116 A:middle
with how much faster
Accelerate was.

00:29:43.736 --> 00:29:48.846 A:middle
But since last year, Brand
A hardware hasn't changed

00:29:48.846 --> 00:29:49.476 A:middle
that much.

00:29:50.206 --> 00:29:52.926 A:middle
And so the great software
primitives that we give you

00:29:52.926 --> 00:29:56.576 A:middle
in Accelerate, well this
is still on the iPhone 5,

00:29:56.576 --> 00:29:59.556 A:middle
and you can see, it's not that
interesting of a comparison.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.456 --> 00:30:02.716 A:middle
So this year we thought
we'd do something different.

00:30:03.186 --> 00:30:05.036 A:middle
We're going to find
some new competition.

00:30:06.086 --> 00:30:10.086 A:middle
Instead of comparing current
iOS hardware against Brand A,

00:30:10.746 --> 00:30:14.286 A:middle
we're going to compare
Accelerate running on the iPhone

00:30:14.846 --> 00:30:18.296 A:middle
against Accelerate running
on some other device.

00:30:18.816 --> 00:30:19.416 A:middle
What should we pick?

00:30:20.706 --> 00:30:23.126 A:middle
We chose to look at
the 2010 MacBook Air.

00:30:23.646 --> 00:30:25.066 A:middle
Now this was a sweet laptop.

00:30:25.066 --> 00:30:25.826 A:middle
I had one of these.

00:30:25.826 --> 00:30:26.506 A:middle
It's fantastic.

00:30:26.506 --> 00:30:28.156 A:middle
This was like the first
one that we shipped

00:30:28.156 --> 00:30:30.366 A:middle
with the current hardware
design on the outside.

00:30:31.006 --> 00:30:31.996 A:middle
It's a really nice machine.

00:30:32.166 --> 00:30:33.126 A:middle
It's just a few years old.

00:30:33.916 --> 00:30:36.706 A:middle
You can see it's more than twice
as fast as the iPhone 5 was.

00:30:37.566 --> 00:30:40.546 A:middle
So, how do you think
the iPhone 5s stacks up?

00:30:41.686 --> 00:30:44.826 A:middle
Well, you should have some clue.

00:30:44.826 --> 00:30:47.446 A:middle
I probably wouldn't be showing
you the graph if it wasn't

00:30:47.446 --> 00:30:48.636 A:middle
at least going to be close.

00:30:49.866 --> 00:30:52.266 A:middle
But on the other hand, this
is a pretty sweet laptop

00:30:52.266 --> 00:30:53.296 A:middle
from just a few years ago.

00:30:53.366 --> 00:30:56.706 A:middle
And we're going to compare it
against the phone that fits

00:30:56.706 --> 00:30:57.916 A:middle
in your pocket like so.

00:30:58.846 --> 00:30:59.226 A:middle
I don't know.

00:30:59.536 --> 00:31:02.116 A:middle
Who thinks that the
iPhone 5s is faster?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.536 --> 00:31:02.116 A:middle
Who thinks that the
iPhone 5s is faster?

00:31:03.696 --> 00:31:05.506 A:middle
Who thinks that the
MacBook Air is faster?

00:31:06.906 --> 00:31:08.376 A:middle
Ok. So let's see what happens.

00:31:09.416 --> 00:31:14.076 A:middle
The iPhone 5s would give
you 10.4 gigaflops double

00:31:14.076 --> 00:31:14.886 A:middle
precision LINPACK.

00:31:15.936 --> 00:31:18.086 A:middle
And we have other
iOS devices too.

00:31:18.936 --> 00:31:23.436 A:middle
On the iPad Air, we give you
14.6 double precision gigaflops.

00:31:24.486 --> 00:31:27.866 A:middle
And you don't need
to be an expert

00:31:27.956 --> 00:31:30.876 A:middle
in high-performance computing
in memory hierarchies,

00:31:31.226 --> 00:31:33.636 A:middle
in vectorization, in
multithreading to get this.

00:31:34.046 --> 00:31:37.676 A:middle
You just use the simple
primitives that we give you

00:31:37.796 --> 00:31:41.126 A:middle
for matrix operations, and you
get this kind of performance.

00:31:41.656 --> 00:31:42.886 A:middle
So I think this is really cool.

00:31:43.406 --> 00:31:50.046 A:middle
With that, I'm going to move
on to our last new feature

00:31:50.046 --> 00:31:52.316 A:middle
for the day, which
is called SIMD.

00:31:53.136 --> 00:31:56.566 A:middle
Now SIMD traditionally is a name
used to talk about hardware,

00:31:56.566 --> 00:31:59.056 A:middle
and it stands for single
instruction multiple data.

00:31:59.616 --> 00:32:02.236 A:middle
And that's not exactly what
we're talking about here.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.616 --> 00:32:02.236 A:middle
And that's not exactly what
we're talking about here.

00:32:02.346 --> 00:32:04.466 A:middle
This is a new library
that we're introducing

00:32:05.366 --> 00:32:08.076 A:middle
in iOS 8.0 and OS X Yosemite.

00:32:09.116 --> 00:32:11.546 A:middle
And it has three
primary purposes.

00:32:12.256 --> 00:32:14.186 A:middle
The first one is to support 2D,

00:32:14.336 --> 00:32:17.146 A:middle
3D and 4D vector
math and geometry.

00:32:18.506 --> 00:32:23.266 A:middle
The second purpose for SIMD is
to provide a lot of the features

00:32:23.656 --> 00:32:28.546 A:middle
of Metal in C, C++ and
Objective-C running on the CPU.

00:32:28.546 --> 00:32:31.376 A:middle
So it's going to make it
easier to prototype code.

00:32:31.376 --> 00:32:34.726 A:middle
Maybe you want to run the CPU
before you deal with GPU stuff.

00:32:34.726 --> 00:32:37.236 A:middle
Maybe you want to move code
between the CPU and the GPU.

00:32:37.236 --> 00:32:38.876 A:middle
Makes it a little bit
easier to do that.

00:32:40.206 --> 00:32:44.026 A:middle
And finally, SIMD library
provides an abstraction

00:32:44.116 --> 00:32:48.056 A:middle
over the actual hardware SIMD
and the types and intrinsics

00:32:48.056 --> 00:32:50.806 A:middle
that you often use to program
against it to make it easier

00:32:50.806 --> 00:32:53.016 A:middle
to write your own vector
code when you need to.

00:32:54.366 --> 00:32:56.036 A:middle
So I think the most
interesting thing

00:32:56.036 --> 00:32:58.136 A:middle
about this is the vector math
and geometry, and I'm going

00:32:58.136 --> 00:32:58.986 A:middle
to dive right into that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:00.146 --> 00:33:03.946 A:middle
There are already a
couple of vector math

00:33:03.946 --> 00:33:05.226 A:middle
and geometry libraries
on the platform.

00:33:05.706 --> 00:33:07.916 A:middle
There's all the features in
Accelerate, which can do just

00:33:07.916 --> 00:33:09.086 A:middle
about anything you want.

00:33:10.016 --> 00:33:12.216 A:middle
There's DLKit, SpriteKit,
SceneKit,

00:33:12.286 --> 00:33:13.686 A:middle
the physics library
that goes with them.

00:33:14.086 --> 00:33:16.056 A:middle
So if we're going to
do a whole new one,

00:33:16.726 --> 00:33:18.896 A:middle
we had better get
some things right.

00:33:19.576 --> 00:33:22.866 A:middle
So, my wish list of what a
library like this should look

00:33:22.866 --> 00:33:25.896 A:middle
like is kind of like this.

00:33:25.896 --> 00:33:28.296 A:middle
First off, we should have
inline implementations

00:33:28.296 --> 00:33:29.476 A:middle
of everything we possibly can.

00:33:29.876 --> 00:33:32.846 A:middle
Because when you're doing,
you know, a 40 dot product

00:33:32.846 --> 00:33:35.336 A:middle
or something, there's
not a lot of arithmetic.

00:33:35.336 --> 00:33:37.446 A:middle
It's just four multiplies
and three adds.

00:33:37.446 --> 00:33:40.596 A:middle
So you have to actually make
an external function call

00:33:41.186 --> 00:33:41.736 A:middle
to a jump.

00:33:42.426 --> 00:33:44.316 A:middle
That's not what you want to do.

00:33:44.616 --> 00:33:46.656 A:middle
You're only going to do
seven arithmetic operations.

00:33:47.766 --> 00:33:50.306 A:middle
And because of this,
essentially everything

00:33:50.306 --> 00:33:51.846 A:middle
in SIMD is header inlines.

00:33:52.026 --> 00:33:53.516 A:middle
So it just gets inserted
into your code.

00:33:54.036 --> 00:33:55.206 A:middle
We give you a really
nice performance.

00:33:55.996 --> 00:33:58.796 A:middle
Next, we should have
concise functions

00:33:58.796 --> 00:34:00.356 A:middle
that don't have a lot
of extra parameters.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.796 --> 00:34:00.356 A:middle
that don't have a lot
of extra parameters.

00:34:00.836 --> 00:34:02.166 A:middle
If you want to do a dot product,

00:34:02.166 --> 00:34:05.456 A:middle
3D dot product using
BLAS, it looks like this.

00:34:05.856 --> 00:34:07.376 A:middle
You've got all these
extra parameters.

00:34:08.005 --> 00:34:09.166 A:middle
We don't think you
should need to write this.

00:34:10.616 --> 00:34:13.815 A:middle
If you're going to use it using
GLK, which is a great library;

00:34:13.926 --> 00:34:18.315 A:middle
I love GLK, but the
compiler should know that x

00:34:18.315 --> 00:34:20.036 A:middle
and y are three-dimensional
vectors.

00:34:20.036 --> 00:34:22.235 A:middle
You shouldn't need to tell it
that in every function you call.

00:34:23.146 --> 00:34:27.735 A:middle
With SIMD, you just write
this, vector dot(x, y).

00:34:28.786 --> 00:34:31.295 A:middle
Functions overloaded to support
all the different vector types

00:34:31.295 --> 00:34:31.786 A:middle
that we have.

00:34:32.346 --> 00:34:33.146 A:middle
It just works.

00:34:33.146 --> 00:34:35.335 A:middle
It inserts the correct
implementation into your code.

00:34:35.565 --> 00:34:36.416 A:middle
You get great performance.

00:34:36.446 --> 00:34:40.485 A:middle
If you're writing C++, then
we have even shorter names

00:34:40.485 --> 00:34:41.616 A:middle
under the SIMD namespace.

00:34:42.295 --> 00:34:43.826 A:middle
And these look just like Metal.

00:34:44.376 --> 00:34:49.696 A:middle
So you can take Metal code,
add the using namespace SIMD,

00:34:49.696 --> 00:34:52.516 A:middle
and a lot of it will just
work using SIMD headers.

00:34:52.985 --> 00:34:56.476 A:middle
This is really convenient when
you're writing your own code.

00:34:56.666 --> 00:34:59.696 A:middle
The last feature that
I think is important is

00:34:59.696 --> 00:35:01.456 A:middle
that arithmetic should
use operators.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.696 --> 00:35:01.456 A:middle
that arithmetic should
use operators.

00:35:02.316 --> 00:35:06.616 A:middle
So if you want to average two
vectors, rather than needing

00:35:06.616 --> 00:35:09.766 A:middle
to write this, you
should just be able

00:35:09.766 --> 00:35:12.366 A:middle
to write 0.5 times ( x + y).

00:35:13.086 --> 00:35:14.326 A:middle
Now you have the
average of two vectors.

00:35:14.326 --> 00:35:15.966 A:middle
This is a lot easier to write.

00:35:15.966 --> 00:35:16.886 A:middle
It's a lot easier to read.

00:35:16.886 --> 00:35:18.666 A:middle
It makes your code more natural.

00:35:19.986 --> 00:35:21.216 A:middle
Alright, so let's dive

00:35:21.216 --> 00:35:23.196 A:middle
into what's actually available
here and what we're doing.

00:35:23.546 --> 00:35:26.066 A:middle
First, the basic types.

00:35:26.326 --> 00:35:28.976 A:middle
We have a lot of vector
types available in SIMD.

00:35:29.526 --> 00:35:31.956 A:middle
But the ones that you're
going to use most often

00:35:32.316 --> 00:35:35.906 A:middle
when you're doing vector math
and geometry are the 2, 3,

00:35:35.906 --> 00:35:38.856 A:middle
and 4 dimensional float factors,
which are just vector float2,

00:35:39.006 --> 00:35:40.766 A:middle
vector float3, and
vector float4.

00:35:41.076 --> 00:35:43.056 A:middle
If you're writing C++ code,

00:35:43.466 --> 00:35:45.496 A:middle
again we have the
names that match Metal.

00:35:45.496 --> 00:35:46.556 A:middle
They're in the SIMD namespace.

00:35:46.556 --> 00:35:49.346 A:middle
You can just say
float2, float3, float4.

00:35:50.406 --> 00:35:53.266 A:middle
And these are based on a clang
feature called extended vectors.

00:35:53.266 --> 00:35:55.716 A:middle
And that gives us a lot
of functionality for free

00:35:56.266 --> 00:35:58.006 A:middle
that made writing this
library really pleasant.

00:35:59.156 --> 00:36:03.506 A:middle
So first off, arithmetic on
vectors pretty much just works.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.156 --> 00:36:03.506 A:middle
So first off, arithmetic on
vectors pretty much just works.

00:36:04.086 --> 00:36:06.506 A:middle
You can use all your
favorite arithmetic operators

00:36:06.866 --> 00:36:08.576 A:middle
on vectors and on scalars.

00:36:09.496 --> 00:36:10.756 A:middle
Everything is nice.

00:36:10.756 --> 00:36:11.846 A:middle
It makes your code easy to read.

00:36:11.846 --> 00:36:13.386 A:middle
And I'm going to show
you another example

00:36:13.386 --> 00:36:13.956 A:middle
of that right now.

00:36:15.026 --> 00:36:17.196 A:middle
So, a pretty basic function

00:36:17.196 --> 00:36:19.186 A:middle
for a graphics library
is a vector reflect.

00:36:19.686 --> 00:36:24.076 A:middle
So we take a vector x, and
we take a unit vector n.

00:36:24.886 --> 00:36:26.506 A:middle
That unit vector
determines the plane.

00:36:27.146 --> 00:36:29.846 A:middle
And we're going to reflect
x through that plane.

00:36:29.846 --> 00:36:32.026 A:middle
This is a really common
operation in graphics.

00:36:32.466 --> 00:36:34.616 A:middle
And there's a simple
mathematical expression

00:36:35.126 --> 00:36:36.116 A:middle
that gives the result.

00:36:37.306 --> 00:36:39.376 A:middle
Now, before we might
have had to have a lot

00:36:39.376 --> 00:36:41.776 A:middle
of verbose function calls
to compute this expression.

00:36:42.386 --> 00:36:44.076 A:middle
But with SIMD, it's
really simple.

00:36:44.256 --> 00:36:47.776 A:middle
We just write x minus
twice the dot product of x

00:36:47.776 --> 00:36:50.036 A:middle
in the normal vector
times the normal vector.

00:36:50.586 --> 00:36:53.416 A:middle
This is just as simple
as the mathematics is.

00:36:53.866 --> 00:36:55.156 A:middle
It makes your code, again,

00:36:55.156 --> 00:36:58.516 A:middle
really easy to write,
really easy to read.

00:36:58.516 --> 00:37:00.146 A:middle
I think it's much nicer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.516 --> 00:37:00.146 A:middle
I think it's much nicer.

00:37:01.006 --> 00:37:02.866 A:middle
There are bunch of other
features that we get

00:37:02.866 --> 00:37:04.586 A:middle
with these vectors
without needing

00:37:04.586 --> 00:37:06.126 A:middle
to call any functions
or do anything.

00:37:07.236 --> 00:37:10.726 A:middle
We get access to vector elements
and subvectors really easily.

00:37:11.146 --> 00:37:12.546 A:middle
Array subscripting just works.

00:37:12.546 --> 00:37:15.526 A:middle
If you want to pull out
the second element vector,

00:37:15.526 --> 00:37:18.036 A:middle
you just subscript just like
you would if it were an array.

00:37:19.356 --> 00:37:21.156 A:middle
Named subvectors just work.

00:37:21.206 --> 00:37:24.036 A:middle
So if you have a vector of 4
floats, you can get the low half

00:37:24.036 --> 00:37:27.076 A:middle
of it, the first two elements
by just using the name

00:37:27.076 --> 00:37:28.096 A:middle
of the vector dot low.

00:37:28.246 --> 00:37:29.696 A:middle
The high half is just dot high.

00:37:30.126 --> 00:37:31.326 A:middle
You can get the even elements.

00:37:31.326 --> 00:37:32.526 A:middle
You can get the odd elements.

00:37:33.116 --> 00:37:34.896 A:middle
And I should point out
that these subvectors

00:37:35.326 --> 00:37:36.796 A:middle
and elements, they're L values.

00:37:36.796 --> 00:37:40.696 A:middle
So you can assign to them as
well as reading from them.

00:37:40.696 --> 00:37:42.156 A:middle
And this is real useful

00:37:42.156 --> 00:37:43.466 A:middle
when you're writing
your own vector code,

00:37:43.466 --> 00:37:45.186 A:middle
especially if you're doing
perspective coordinates

00:37:45.186 --> 00:37:45.886 A:middle
or something like that.

00:37:45.886 --> 00:37:47.816 A:middle
A lot of times you need
to just set some value

00:37:47.816 --> 00:37:49.056 A:middle
in the fourth coordinate
for example.

00:37:50.436 --> 00:37:51.496 A:middle
This is really nice.

00:37:51.706 --> 00:37:54.966 A:middle
If you go totally hog wild with
this, it will make it harder

00:37:54.966 --> 00:37:56.766 A:middle
for the compiler to
generate great code for you.

00:37:56.956 --> 00:37:59.396 A:middle
But used sparingly, this is
really a powerful feature.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.786 --> 00:38:03.826 A:middle
We have some other,
that's about what you get

00:38:03.986 --> 00:38:05.206 A:middle
for free with the types.

00:38:05.756 --> 00:38:07.746 A:middle
Now we also give you
lots of functions

00:38:07.956 --> 00:38:10.666 A:middle
that give you the
operations that you want.

00:38:11.306 --> 00:38:14.296 A:middle
We have three headers that
have tons of stuff that comes

00:38:14.296 --> 00:38:15.816 A:middle
up all the time for
math and geometry.

00:38:16.356 --> 00:38:18.246 A:middle
Math, common and geometry.

00:38:19.816 --> 00:38:23.016 A:middle
In C and Objective-C, those
functions look like this.

00:38:23.736 --> 00:38:27.006 A:middle
Notice the math functions look
just like the math functions

00:38:27.006 --> 00:38:28.126 A:middle
that you use for scalars.

00:38:28.576 --> 00:38:31.646 A:middle
They're overloaded, so now they
work for floats, for doubles,

00:38:31.886 --> 00:38:34.676 A:middle
for vectors of floats, for all
our other floating point vector

00:38:34.676 --> 00:38:36.196 A:middle
types, just works.

00:38:36.266 --> 00:38:37.826 A:middle
You want the square
root of a vector?

00:38:37.826 --> 00:38:38.896 A:middle
Just call square root.

00:38:39.956 --> 00:38:41.056 A:middle
Everything is there.

00:38:41.576 --> 00:38:43.556 A:middle
The common functions
you may be familiar

00:38:43.556 --> 00:38:45.036 A:middle
with if you've written
shader code before

00:38:45.036 --> 00:38:46.716 A:middle
or if you've done a lot
of graphics programming.

00:38:47.196 --> 00:38:49.096 A:middle
These are operations
that are really useful

00:38:49.096 --> 00:38:50.826 A:middle
when you're dealing with
coordinates or colors.

00:38:50.946 --> 00:38:53.086 A:middle
If you haven't done
a lot of that before,

00:38:53.086 --> 00:38:53.856 A:middle
they may be new to you.

00:38:54.066 --> 00:38:55.106 A:middle
But don't worry about that.

00:38:55.106 --> 00:38:57.236 A:middle
They're easy to understand and
there's a lot of documentation

00:38:57.236 --> 00:38:57.996 A:middle
for them in the headers.

00:38:58.226 --> 00:39:00.966 A:middle
And then there's the
geometry functions as well.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.226 --> 00:39:00.966 A:middle
And then there's the
geometry functions as well.

00:39:02.216 --> 00:39:06.176 A:middle
Now in C++ and Metal, again we
have shorter names available

00:39:06.176 --> 00:39:06.806 A:middle
in C++.

00:39:06.806 --> 00:39:08.026 A:middle
These are under the
SIMD namespace.

00:39:08.456 --> 00:39:11.296 A:middle
And these exactly match
the Metal functionality.

00:39:11.296 --> 00:39:14.936 A:middle
So again, this makes it really
easy to move code between C,

00:39:14.936 --> 00:39:18.006 A:middle
C++ and Objective-C and
Metal when you need to.

00:39:19.156 --> 00:39:21.576 A:middle
Now I want to call out that some

00:39:21.576 --> 00:39:23.316 A:middle
of these functions
come in two variants.

00:39:23.316 --> 00:39:24.466 A:middle
There's a precise version.

00:39:24.956 --> 00:39:26.136 A:middle
And there's a fast version.

00:39:26.556 --> 00:39:31.956 A:middle
Now precise is the default
because if you don't know

00:39:32.446 --> 00:39:34.716 A:middle
which one you need,
it's better to be safe

00:39:34.716 --> 00:39:37.096 A:middle
and give you the most
accurate one we have.

00:39:37.996 --> 00:39:40.626 A:middle
But, there is also
a fast version.

00:39:40.626 --> 00:39:42.196 A:middle
If you compile with ffast-math,

00:39:42.596 --> 00:39:44.236 A:middle
then you get the
fast ones by default.

00:39:44.236 --> 00:39:48.736 A:middle
The fast ones just may
not be totally accurate

00:39:48.736 --> 00:39:49.326 A:middle
to the last bit.

00:39:49.326 --> 00:39:51.966 A:middle
We give you about half the
bits in a floating point number

00:39:51.966 --> 00:39:52.886 A:middle
with the fast variance.

00:39:54.506 --> 00:39:56.916 A:middle
Now even if you compile
the ffast-math,

00:39:57.046 --> 00:40:00.736 A:middle
you can still call the precise
ones individually when you need


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:57.046 --> 00:40:00.736 A:middle
you can still call the precise
ones individually when you need

00:40:00.736 --> 00:40:03.356 A:middle
to by just introducing
precise into the name.

00:40:04.016 --> 00:40:05.466 A:middle
And similarly vice-versa.

00:40:05.466 --> 00:40:07.086 A:middle
If you don't have
ffast-math specified,

00:40:07.086 --> 00:40:08.706 A:middle
you can always call
the fast variant.

00:40:09.506 --> 00:40:11.776 A:middle
And in C++ we do
this with namespaces.

00:40:11.776 --> 00:40:13.736 A:middle
There's a sub-namespace
called fast

00:40:13.736 --> 00:40:16.386 A:middle
and a sub-namespace
called precise that you use

00:40:16.386 --> 00:40:19.126 A:middle
so that you can just override
the defaults really easily.

00:40:20.486 --> 00:40:23.566 A:middle
Now last, when we talk about
vector math and geometry,

00:40:24.356 --> 00:40:27.506 A:middle
wouldn't really be complete
if we didn't have matrices.

00:40:28.266 --> 00:40:30.506 A:middle
So we have a set
of matrix types,

00:40:30.896 --> 00:40:33.376 A:middle
which are matrix floatNxM.

00:40:33.776 --> 00:40:36.386 A:middle
This could be 2, 3, or 4, and
they don't need to be square.

00:40:36.386 --> 00:40:39.146 A:middle
You can have a 4 x 2
matrix or a 2 x 3 matrix.

00:40:39.256 --> 00:40:42.726 A:middle
I want to point out that N
is the number of columns.

00:40:43.046 --> 00:40:44.146 A:middle
M is the number of rows.

00:40:44.146 --> 00:40:46.396 A:middle
If you're a mathematician this
may be a little strange to you.

00:40:46.396 --> 00:40:49.636 A:middle
But 2 x 3 matrix has two columns

00:40:49.636 --> 00:40:51.626 A:middle
and three rows instead
of vice-versa.

00:40:52.356 --> 00:40:54.696 A:middle
But if you come from
a graphics background,

00:40:54.696 --> 00:40:55.426 A:middle
this is very natural.

00:40:55.426 --> 00:40:59.776 A:middle
This follows the precedent
that Metal and open CL and DX

00:40:59.776 --> 00:41:02.966 A:middle
and GLSL and all of these
libraries have always used.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.776 --> 00:41:02.966 A:middle
and GLSL and all of these
libraries have always used.

00:41:02.966 --> 00:41:05.356 A:middle
So that's why we do it.

00:41:05.726 --> 00:41:08.146 A:middle
There are lots of operations
available on matrices as well.

00:41:08.986 --> 00:41:11.486 A:middle
You don't get the operators
for free in C and Objective-C.

00:41:11.826 --> 00:41:13.976 A:middle
Sorry. So you do have to
make some function calls.

00:41:14.376 --> 00:41:16.936 A:middle
But we have a nice set of
functions to create matrices.

00:41:16.936 --> 00:41:19.046 A:middle
We have a nice set of
functions to operate on matrices

00:41:19.046 --> 00:41:20.166 A:middle
and matrices and vectors.

00:41:20.596 --> 00:41:23.296 A:middle
This is just sort of
the broad overview.

00:41:23.296 --> 00:41:24.336 A:middle
We have some other
stuff as well.

00:41:25.566 --> 00:41:28.266 A:middle
In C++ you get operator
overloading.

00:41:28.266 --> 00:41:30.936 A:middle
So you can add and
subtract, multiply by scalars,

00:41:31.306 --> 00:41:32.726 A:middle
multiply matrices and vectors.

00:41:32.726 --> 00:41:35.806 A:middle
We have some nice
constructors that make it easier

00:41:35.806 --> 00:41:36.766 A:middle
to create these objects.

00:41:37.096 --> 00:41:38.146 A:middle
It's really nice to work with.

00:41:38.586 --> 00:41:40.566 A:middle
Really easy to write
your vector code.

00:41:41.616 --> 00:41:44.726 A:middle
So that's, that's sort of the
vector math and geometry story.

00:41:45.326 --> 00:41:46.696 A:middle
And now I want to
talk a little bit

00:41:46.756 --> 00:41:49.696 A:middle
about writing your own SIMD
code using the library.

00:41:50.836 --> 00:41:53.686 A:middle
So we also have lots
of other types.

00:41:53.756 --> 00:41:54.776 A:middle
I mentioned this
at the beginning.

00:41:55.136 --> 00:41:57.126 A:middle
Vector float is just
a few of them.

00:41:57.406 --> 00:41:58.786 A:middle
We also have vectors of doubles.

00:41:58.986 --> 00:42:01.186 A:middle
Vectors of signed and
unsigned integers.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.986 --> 00:42:01.186 A:middle
Vectors of signed and
unsigned integers.

00:42:01.406 --> 00:42:04.456 A:middle
We've got 8 bit, 16 bit,
32 bit and 64 bit integers.

00:42:05.076 --> 00:42:07.936 A:middle
We support longer vector
types, 8, 16 and 32 elements.

00:42:08.406 --> 00:42:11.026 A:middle
This is really useful to write
just a little bit of code

00:42:11.026 --> 00:42:13.386 A:middle
and have the compiler
effectively unroll your loops

00:42:13.386 --> 00:42:13.746 A:middle
for you.

00:42:15.076 --> 00:42:17.316 A:middle
We also have unaligned
vector support.

00:42:18.046 --> 00:42:23.096 A:middle
All of the normal vector
types are aligned by default,

00:42:24.206 --> 00:42:26.276 A:middle
which is great when
you're doing geometry

00:42:26.756 --> 00:42:29.406 A:middle
because you're not
usually getting the data

00:42:29.406 --> 00:42:30.536 A:middle
from somewhere else.

00:42:30.536 --> 00:42:32.266 A:middle
You're, you know, we
just want to align it.

00:42:32.266 --> 00:42:33.796 A:middle
We want to give you the
best performance you can.

00:42:34.626 --> 00:42:36.316 A:middle
However, when you're
writing your own vector code,

00:42:36.466 --> 00:42:38.326 A:middle
usually you're operating
on data buffers

00:42:38.326 --> 00:42:39.086 A:middle
that came in from somewhere.

00:42:39.086 --> 00:42:40.586 A:middle
And those buffers
may not be aligned.

00:42:40.976 --> 00:42:44.306 A:middle
So we also provide unaligned
types for you to work with.

00:42:44.306 --> 00:42:47.896 A:middle
And I'll show you an example
of that a little bit later.

00:42:48.146 --> 00:42:51.176 A:middle
Now, just like the floating
point vectors I showed you,

00:42:51.676 --> 00:42:53.266 A:middle
you get lots of operators
for free.

00:42:53.726 --> 00:42:55.386 A:middle
You get the normal
arithmetic operators.

00:42:55.556 --> 00:42:56.146 A:middle
These just work.

00:42:56.636 --> 00:42:58.066 A:middle
You also get the
bitwise operators.

00:42:58.306 --> 00:42:59.366 A:middle
Those just work on vectors.

00:42:59.366 --> 00:43:00.616 A:middle
They work with vectors
and scalars


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.366 --> 00:43:00.616 A:middle
They work with vectors
and scalars

00:43:00.616 --> 00:43:03.316 A:middle
so you can shift every
element right by 3,

00:43:03.316 --> 00:43:05.626 A:middle
by just writing vector,
shift right, 3.

00:43:07.156 --> 00:43:09.906 A:middle
We also have a big set of
conversion functions for you.

00:43:10.286 --> 00:43:13.256 A:middle
These let you convert from
one vector type to another.

00:43:13.256 --> 00:43:15.356 A:middle
I want to point out
that you should use the

00:43:15.356 --> 00:43:16.306 A:middle
conversion functions.

00:43:16.546 --> 00:43:19.616 A:middle
Don't cast vectors, because it
almost surely doesn't do what

00:43:19.616 --> 00:43:20.316 A:middle
you want it to do.

00:43:21.086 --> 00:43:24.126 A:middle
When you cast vectors,
it reinterprets the data

00:43:24.126 --> 00:43:25.656 A:middle
in the vector as the other type.

00:43:26.166 --> 00:43:30.166 A:middle
This means that you can't
even cast say a vector

00:43:30.166 --> 00:43:33.076 A:middle
of 416 bit integers into a
vector of 432 bit integers

00:43:33.076 --> 00:43:34.256 A:middle
because they have
different sizes.

00:43:34.976 --> 00:43:38.006 A:middle
So rather than casting them,
call the conversion functions,

00:43:38.336 --> 00:43:40.856 A:middle
which will convert one vector
type to another vector type

00:43:40.856 --> 00:43:42.756 A:middle
for you, give you
the right behavior.

00:43:44.896 --> 00:43:46.496 A:middle
You also get comparisons.

00:43:47.406 --> 00:43:49.256 A:middle
So comparisons just
work on vectors.

00:43:50.356 --> 00:43:51.356 A:middle
It's a little bit strange though

00:43:51.356 --> 00:43:53.266 A:middle
because I can't really
talk meaningfully

00:43:53.266 --> 00:43:56.486 A:middle
about one vector being less
than another vector, right.

00:43:56.486 --> 00:43:57.866 A:middle
That doesn't make
sense geometrically.

00:43:58.366 --> 00:44:01.206 A:middle
So comparisons produce
a vector of results.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.366 --> 00:44:01.206 A:middle
So comparisons produce
a vector of results.

00:44:02.406 --> 00:44:06.776 A:middle
Where each lane of the result
vector is minus 1, that's all 1s

00:44:07.016 --> 00:44:09.116 A:middle
if the comparison is
true in that lane.

00:44:09.656 --> 00:44:12.156 A:middle
And it's zeros if the comparison
is false in that lane.

00:44:12.156 --> 00:44:13.006 A:middle
I'll show you an example.

00:44:13.486 --> 00:44:14.726 A:middle
Here's a vector of 4 floats.

00:44:15.406 --> 00:44:17.326 A:middle
Compare it against
another vector of 4 floats,

00:44:17.696 --> 00:44:19.226 A:middle
we'll see if x is less than y.

00:44:19.886 --> 00:44:22.786 A:middle
So, in the first lane,
zero is not less than zero,

00:44:22.956 --> 00:44:23.966 A:middle
the comparison is false.

00:44:24.076 --> 00:44:24.926 A:middle
We'll get a result of zero.

00:44:25.916 --> 00:44:29.946 A:middle
Now 1 is less than 3.14159,
so the result is all 1s.

00:44:30.716 --> 00:44:34.976 A:middle
So 2 is not less than minus
infinity, 3 is less than 42.

00:44:34.976 --> 00:44:39.066 A:middle
Now I just went through
this, but it's going to turn

00:44:39.066 --> 00:44:41.226 A:middle
out this doesn't matter a
lot to you most of the time

00:44:41.846 --> 00:44:44.476 A:middle
because almost always when you
do a comparison, you're going

00:44:44.476 --> 00:44:47.486 A:middle
to consume the result of
that comparison with one

00:44:47.486 --> 00:44:49.636 A:middle
of three operations; vector any,

00:44:50.146 --> 00:44:52.186 A:middle
vector all, and vector
bitselect.

00:44:53.196 --> 00:44:56.026 A:middle
Vector any is true if
the comparison is true

00:44:56.026 --> 00:44:57.776 A:middle
in any lane of the vector.

00:44:58.676 --> 00:45:02.206 A:middle
Vector all is true if it's true
in every lane of the vector.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.676 --> 00:45:02.206 A:middle
Vector all is true if it's true
in every lane of the vector.

00:45:02.726 --> 00:45:06.116 A:middle
And bitselect lets you
select between the elements

00:45:06.116 --> 00:45:09.386 A:middle
of two vectors based on some
result of the comparison.

00:45:09.826 --> 00:45:13.096 A:middle
So most of the time, these
give you the functionalities

00:45:13.096 --> 00:45:14.686 A:middle
that you really want
from comparisons anyway.

00:45:14.686 --> 00:45:17.636 A:middle
You don't need to worry about
the nitty-gritty details

00:45:17.636 --> 00:45:19.276 A:middle
of what the type
of the result is.

00:45:19.766 --> 00:45:24.096 A:middle
So now I'm going to show
you an example of using this

00:45:24.096 --> 00:45:25.086 A:middle
to write your own vector code.

00:45:26.096 --> 00:45:28.336 A:middle
I'm going to choose an
example that's something

00:45:28.336 --> 00:45:30.316 A:middle
that we normally don't really
think about vectorizing.

00:45:30.316 --> 00:45:33.156 A:middle
It's not that hard to
vectorize, but it's something

00:45:33.156 --> 00:45:35.026 A:middle
that you know, is
outside the realm of sort

00:45:35.026 --> 00:45:37.326 A:middle
of floating point computations
that we normally think of.

00:45:37.376 --> 00:45:39.476 A:middle
We're going to look
at string copy.

00:45:39.476 --> 00:45:42.186 A:middle
So here's a simple
scalar implementation

00:45:42.236 --> 00:45:45.186 A:middle
of string copy that's
sort of right out of KNR.

00:45:45.626 --> 00:45:48.466 A:middle
And all we do is we iterate
through the bytes of the source

00:45:49.266 --> 00:45:51.086 A:middle
and we copy them
to the destination.

00:45:51.466 --> 00:45:54.716 A:middle
And when we reach a byte
that's zero, we stop copying.

00:45:55.056 --> 00:45:55.326 A:middle
That's it.

00:45:55.766 --> 00:45:57.176 A:middle
Complete implementation
right there.

00:45:58.286 --> 00:46:01.236 A:middle
Now, as I said, this isn't
too hard to vectorize.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.286 --> 00:46:01.236 A:middle
Now, as I said, this isn't
too hard to vectorize.

00:46:01.906 --> 00:46:05.786 A:middle
Here's sort of a typical
SSE intrinsic implementation

00:46:05.786 --> 00:46:06.366 A:middle
string copy.

00:46:06.366 --> 00:46:09.696 A:middle
I haven't pulled out all
the crazy stops here,

00:46:09.696 --> 00:46:12.526 A:middle
but this is sort of a
reasonable implementation.

00:46:14.096 --> 00:46:15.256 A:middle
And this is fine.

00:46:15.256 --> 00:46:16.596 A:middle
It wasn't too hard to write.

00:46:16.596 --> 00:46:17.486 A:middle
It's a little bit ugly.

00:46:18.096 --> 00:46:22.366 A:middle
I find it kind of
a pain to read.

00:46:22.496 --> 00:46:25.486 A:middle
The big problem with this is
that this works for 32 bit

00:46:25.696 --> 00:46:28.486 A:middle
and 65 bit Intel,
but we might want

00:46:28.486 --> 00:46:29.626 A:middle
to now run our code unarmed.

00:46:29.726 --> 00:46:32.326 A:middle
We have to write, either write
a whole new implementation,

00:46:32.846 --> 00:46:34.846 A:middle
or just fall back
on the scalar code.

00:46:35.366 --> 00:46:38.686 A:middle
So we want to give you the tools
to write fast implementations

00:46:38.686 --> 00:46:41.096 A:middle
that you can run on
all of our platforms.

00:46:42.376 --> 00:46:43.716 A:middle
Here's what a SIMD
implementation

00:46:43.886 --> 00:46:44.916 A:middle
of string copy looks like.

00:46:45.446 --> 00:46:47.056 A:middle
First off, it's a
little bit shorter

00:46:47.156 --> 00:46:49.606 A:middle
than the SSE intrinsic version.

00:46:49.916 --> 00:46:51.006 A:middle
And I think it's a
little bit cleaner.

00:46:51.006 --> 00:46:51.866 A:middle
I'm going to walk
you through it.

00:46:52.546 --> 00:46:54.746 A:middle
The first part here we
just go byte by byte

00:46:55.516 --> 00:46:57.746 A:middle
until the source has
16 byte alignment.

00:46:57.746 --> 00:47:00.036 A:middle
That's going to enable
us to use lined goods


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:57.746 --> 00:47:00.036 A:middle
That's going to enable
us to use lined goods

00:47:00.036 --> 00:47:02.586 A:middle
from the source from
that point on.

00:47:03.056 --> 00:47:05.526 A:middle
I'm not going to get too
much into the nitty-gritty

00:47:05.526 --> 00:47:07.246 A:middle
of the details of why
it's important to do this.

00:47:07.326 --> 00:47:10.666 A:middle
But when you're dealing with
implicit length data objects

00:47:10.666 --> 00:47:13.766 A:middle
like strings, you do really need
to align your source buffers.

00:47:15.026 --> 00:47:18.066 A:middle
Having aligned our source
buffer, now I'm just going

00:47:18.066 --> 00:47:20.296 A:middle
to cast the source and
destination pointers

00:47:20.576 --> 00:47:21.696 A:middle
into pointers to vectors.

00:47:21.696 --> 00:47:24.506 A:middle
And you notice I used two
different vector types here.

00:47:25.076 --> 00:47:26.866 A:middle
Remember I aligned
the source buffer.

00:47:27.276 --> 00:47:29.136 A:middle
So it's a vector char16.

00:47:29.136 --> 00:47:30.816 A:middle
That's a line that
has 16 byte alignment.

00:47:32.146 --> 00:47:35.426 A:middle
The destination vector is
not necessarily aligned.

00:47:35.486 --> 00:47:37.396 A:middle
There's no guarantee that
by aligning the source

00:47:37.736 --> 00:47:38.986 A:middle
that the destination is aligned.

00:47:39.406 --> 00:47:42.376 A:middle
So instead, I'm going to
use this packed char16 type

00:47:42.696 --> 00:47:45.966 A:middle
which is an unaligned vector
type for the destination.

00:47:46.576 --> 00:47:50.086 A:middle
So now that I've set up
my types, the actual meat

00:47:50.086 --> 00:47:52.826 A:middle
of the copy is really
just these two lines.

00:47:53.466 --> 00:47:54.926 A:middle
All we do is load the vector

00:47:54.926 --> 00:47:56.996 A:middle
from the source,
compare it to zero.

00:47:57.836 --> 00:48:04.026 A:middle
If any lane is equal to zero,
then we stop the copy, right.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:57.836 --> 00:48:04.026 A:middle
If any lane is equal to zero,
then we stop the copy, right.

00:48:04.026 --> 00:48:08.486 A:middle
So if not, any lane of the
vector is zero, we're done.

00:48:08.806 --> 00:48:10.266 A:middle
We continue.

00:48:10.266 --> 00:48:13.776 A:middle
But as soon as a lane
is zero, we're done.

00:48:13.986 --> 00:48:18.206 A:middle
So, then in the copy, we just
copy that vector from the source

00:48:18.486 --> 00:48:21.726 A:middle
to the destination and
advance both the pointers

00:48:21.726 --> 00:48:22.316 A:middle
to the next vector.

00:48:22.916 --> 00:48:23.516 A:middle
Really simple.

00:48:24.196 --> 00:48:28.406 A:middle
And then finally, if we did
find a zero, if we found the end

00:48:28.406 --> 00:48:31.396 A:middle
of the string in the
next 16 bytes, well,

00:48:31.526 --> 00:48:33.306 A:middle
let's just copy it
byte by byte from there

00:48:33.506 --> 00:48:34.416 A:middle
until we reach the end.

00:48:35.076 --> 00:48:36.436 A:middle
This is a really
simple implementation.

00:48:36.816 --> 00:48:39.136 A:middle
It's not the best implementation
that's possible to write,

00:48:39.756 --> 00:48:41.226 A:middle
but it was really
easy and it's going

00:48:41.226 --> 00:48:42.756 A:middle
to give us a nice
performance string.

00:48:43.476 --> 00:48:44.196 A:middle
So let's look at that.

00:48:44.196 --> 00:48:46.616 A:middle
We're going to look at
the performance measured

00:48:46.616 --> 00:48:49.586 A:middle
in bytes per nanosecond for
a variety of string lengths.

00:48:50.216 --> 00:48:53.076 A:middle
Now this bytes per nanoseconds
is how fast we're copying

00:48:53.356 --> 00:48:56.606 A:middle
so that the more data we copy,
the better off we're doing.

00:48:56.936 --> 00:48:58.736 A:middle
Higher is better on this graph.

00:48:59.166 --> 00:49:00.796 A:middle
We start with that
scalar code we had.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.166 --> 00:49:00.796 A:middle
We start with that
scalar code we had.

00:49:00.946 --> 00:49:02.086 A:middle
And you can see we get up to

00:49:02.086 --> 00:49:04.806 A:middle
about half a byte per
nanosecond, which is,

00:49:04.806 --> 00:49:07.066 A:middle
that's still 500
megabytes a second.

00:49:07.066 --> 00:49:08.566 A:middle
We're moving a lot of data.

00:49:08.566 --> 00:49:10.976 A:middle
But we're going to
do a lot better.

00:49:11.886 --> 00:49:13.316 A:middle
Let's look at that
SIMD implantation

00:49:13.426 --> 00:49:15.206 A:middle
that you recall is just
a few lines of code.

00:49:16.206 --> 00:49:17.516 A:middle
It's almost ten times faster.

00:49:19.496 --> 00:49:22.646 A:middle
And, as I said, it's
possible to do better

00:49:22.646 --> 00:49:23.866 A:middle
if you really pull
out the stops.

00:49:24.336 --> 00:49:26.596 A:middle
Here's the performance that we
get from libc on the platform,

00:49:26.736 --> 00:49:28.616 A:middle
which is also a vectorized
implementation,

00:49:29.106 --> 00:49:30.626 A:middle
and it does some
really clever things

00:49:30.626 --> 00:49:33.536 A:middle
about etching an alignment
to get more performance.

00:49:34.326 --> 00:49:37.196 A:middle
But you notice, we're getting
most of the performance of libc.

00:49:37.196 --> 00:49:38.716 A:middle
We got nearly a 10X win.

00:49:38.716 --> 00:49:40.276 A:middle
We're within 80 percent
of the performance

00:49:40.276 --> 00:49:42.206 A:middle
of libc for long vectors.

00:49:42.746 --> 00:49:44.936 A:middle
And we got that with
just a few lines of code

00:49:45.336 --> 00:49:46.466 A:middle
that were really easy to write.

00:49:46.916 --> 00:49:48.286 A:middle
The libc implementation
is an assembly.

00:49:48.956 --> 00:49:50.736 A:middle
We wrote four lines
of C basically

00:49:51.026 --> 00:49:52.576 A:middle
to get the performance
we see here.

00:49:52.996 --> 00:49:57.896 A:middle
And that's really what
our message for today is,

00:49:58.416 --> 00:50:04.236 A:middle
that Accelerate has always given
you really fast vector code.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:58.416 --> 00:50:04.236 A:middle
that Accelerate has always given
you really fast vector code.

00:50:05.016 --> 00:50:07.616 A:middle
And what we're doing now is
try to make it even simpler

00:50:07.616 --> 00:50:08.396 A:middle
for you to get at that.

00:50:08.736 --> 00:50:11.336 A:middle
To make it so that more
developers can easily take

00:50:11.336 --> 00:50:13.786 A:middle
advantage of the performance
that the hardware offers.

00:50:14.386 --> 00:50:16.746 A:middle
Now I want to note
that LinearAlgebra

00:50:16.906 --> 00:50:18.746 A:middle
and SIMD are both
brand new libraries.

00:50:18.876 --> 00:50:19.896 A:middle
They do have some rough edges.

00:50:20.236 --> 00:50:22.316 A:middle
I'm sure you'll try to do things
that we haven't thought of.

00:50:23.426 --> 00:50:27.346 A:middle
But that also means that you
can tell us what use cases are

00:50:27.346 --> 00:50:30.386 A:middle
really important to you, and
we'll take that into account.

00:50:30.386 --> 00:50:32.876 A:middle
You can have an enormous
impact on the way

00:50:32.876 --> 00:50:34.036 A:middle
that these libraries develop.

00:50:35.196 --> 00:50:39.856 A:middle
If you want more information
about Accelerate or SIMD,

00:50:39.856 --> 00:50:43.466 A:middle
we have two great contacts,
Paul Danbold and George Warner.

00:50:44.376 --> 00:50:46.406 A:middle
There is a bunch of
documentation available

00:50:46.406 --> 00:50:48.656 A:middle
for vImage and vDSP online.

00:50:48.946 --> 00:50:53.306 A:middle
I would also recommend looking
at the headers in Accelerate

00:50:53.306 --> 00:50:54.356 A:middle
if you need documentation.

00:50:54.666 --> 00:50:59.726 A:middle
VImage and vDSP, LinearAlgebra
and SIMD all have lots and lots

00:50:59.726 --> 00:51:01.056 A:middle
of documentation in the headers.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.726 --> 00:51:01.056 A:middle
of documentation in the headers.

00:51:01.056 --> 00:51:03.646 A:middle
It's a fantastic resource
if you want to know more

00:51:03.646 --> 00:51:04.406 A:middle
about how things work.

00:51:05.066 --> 00:51:06.856 A:middle
The developer forums
are a pretty good place

00:51:06.856 --> 00:51:08.296 A:middle
to ask for help with things.

00:51:08.296 --> 00:51:12.036 A:middle
If you're going to
file any comments

00:51:12.036 --> 00:51:12.976 A:middle
in the developer forums,

00:51:13.286 --> 00:51:15.166 A:middle
the place to file
them is under Core OS.

00:51:15.566 --> 00:51:17.416 A:middle
That's where you're most likely

00:51:17.416 --> 00:51:18.306 A:middle
to get the attention
that you want.

00:51:19.216 --> 00:51:22.826 A:middle
And the Bug Reporter is also
a great way to report issues,

00:51:23.016 --> 00:51:24.156 A:middle
make feature requests.

00:51:24.406 --> 00:51:27.386 A:middle
You don't only need to
use this if there's a bug

00:51:27.696 --> 00:51:28.756 A:middle
in the conventional sense.

00:51:29.096 --> 00:51:32.016 A:middle
You can say hey, it would
be great if, you know,

00:51:32.016 --> 00:51:33.976 A:middle
I could do this thing that's
a little bit different

00:51:33.976 --> 00:51:34.586 A:middle
from what you're doing.

00:51:34.586 --> 00:51:36.686 A:middle
Or make an entirely
new feature request.

00:51:36.686 --> 00:51:39.966 A:middle
Or say I tried to this, and the
performance wasn't quite as good

00:51:39.966 --> 00:51:40.846 A:middle
as I thought it should be.

00:51:41.636 --> 00:51:43.116 A:middle
Those are absolutely
bugs, and those are things

00:51:43.116 --> 00:51:43.796 A:middle
that we want to look at.

00:51:43.796 --> 00:51:45.246 A:middle
So file bugs early and often.

00:51:45.246 --> 00:51:46.696 A:middle
We love to get them, and we love

00:51:46.696 --> 00:51:48.026 A:middle
to get feature requests
from you guys.

00:51:48.856 --> 00:51:51.036 A:middle
A ton of the stuff
that we've done

00:51:51.036 --> 00:51:52.506 A:middle
in the past few years
has been motivated

00:51:52.506 --> 00:51:54.656 A:middle
by feature requests we got
from external developers.

00:51:54.726 --> 00:51:57.826 A:middle
There are some related sessions
that are worth checking out.

00:51:57.906 --> 00:51:59.646 A:middle
If you're here, you're almost
certainly going to be interested

00:51:59.646 --> 00:52:01.166 A:middle
in the Metal sessions
that are tomorrow morning.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:59.646 --> 00:52:01.166 A:middle
in the Metal sessions
that are tomorrow morning.

00:52:01.926 --> 00:52:03.016 A:middle
Those are a great
thing to check out.

00:52:03.146 --> 00:52:04.136 A:middle
Thanks a lot for coming by guys.

