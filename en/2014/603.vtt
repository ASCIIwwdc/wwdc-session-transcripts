WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:13.356 --> 00:00:14.436 A:middle
&gt;&gt; Welcome everyone.

00:00:14.896 --> 00:00:17.336 A:middle
Welcome. Welcome to WWDC,

00:00:17.656 --> 00:00:20.906 A:middle
and welcome to our Introductory
Session about Working

00:00:21.146 --> 00:00:25.206 A:middle
with Metal, and we're incredibly
excited to get to talk

00:00:25.206 --> 00:00:26.386 A:middle
to you today about Metal.

00:00:27.076 --> 00:00:30.696 A:middle
We believe it's literally going
to be a game changer for you,

00:00:31.336 --> 00:00:33.586 A:middle
your applications, and for iOS.

00:00:34.566 --> 00:00:36.246 A:middle
Now as you've heard
in the keynote,

00:00:36.846 --> 00:00:40.926 A:middle
Metal is our new
low-overhead, high-performance,

00:00:41.006 --> 00:00:43.926 A:middle
and incredibly efficient
GPU programming API.

00:00:45.046 --> 00:00:49.016 A:middle
It provides dramatically reduced
overhead for executing work

00:00:49.196 --> 00:00:51.356 A:middle
such as graphics and
compute on a GPU.

00:00:52.406 --> 00:00:54.866 A:middle
And with the support for
a precompiled shaders

00:00:55.046 --> 00:00:59.076 A:middle
and incredibly efficient
threading, we designed it to run

00:00:59.076 --> 00:01:01.096 A:middle
like a dream on the A7 chip.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.076 --> 00:01:01.096 A:middle
like a dream on the A7 chip.

00:01:02.476 --> 00:01:05.355 A:middle
Now today in this session,
I'm going to talk to you

00:01:05.355 --> 00:01:07.986 A:middle
at a relatively high level
about the background, the how

00:01:07.986 --> 00:01:09.756 A:middle
and why we created
Metal and some

00:01:09.756 --> 00:01:12.046 A:middle
of the conceptual
framework for the API.

00:01:12.046 --> 00:01:15.836 A:middle
I'll also touch briefly on
the Metal shading language

00:01:16.416 --> 00:01:17.596 A:middle
and our developer tools.

00:01:18.816 --> 00:01:21.136 A:middle
The sessions that follow
will go into much more detail

00:01:21.136 --> 00:01:23.746 A:middle
about exactly how to use
the Metal API and how

00:01:23.746 --> 00:01:25.806 A:middle
to build your applications,
but we'll keep things

00:01:25.806 --> 00:01:27.326 A:middle
at a high level for
this session.

00:01:28.686 --> 00:01:31.346 A:middle
So, first, a bit of
background on Metal itself.

00:01:31.576 --> 00:01:35.616 A:middle
Now you also heard in a
keynote that Metal provides

00:01:36.046 --> 00:01:39.606 A:middle
up to 10x the number of draw
calls for your application.

00:01:40.186 --> 00:01:41.986 A:middle
Now what does that really mean?

00:01:42.886 --> 00:01:45.736 A:middle
Well, it's important to think
about draw calls in this way.

00:01:46.056 --> 00:01:50.546 A:middle
Each draw call requires its
own graphics state vector.

00:01:51.266 --> 00:01:54.166 A:middle
So when you're specifying that
you would like to draw something

00:01:54.166 --> 00:01:57.886 A:middle
with the GPU, you also need
to tell the GPU which shaders,

00:01:57.886 --> 00:02:00.246 A:middle
which states, how you want
to configure the textures


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:57.886 --> 00:02:00.246 A:middle
which states, how you want
to configure the textures

00:02:00.246 --> 00:02:01.566 A:middle
and the Rendering destinations.

00:02:02.676 --> 00:02:06.376 A:middle
This is very important in order
to get the effect you're looking

00:02:06.376 --> 00:02:08.876 A:middle
for from the GPU,
but, unfortunately,

00:02:08.916 --> 00:02:11.166 A:middle
with previous API's
changing state vectors,

00:02:11.316 --> 00:02:12.966 A:middle
it'd be extremely expensive.

00:02:13.526 --> 00:02:17.076 A:middle
You have to translate between
the API state and the state

00:02:17.076 --> 00:02:18.336 A:middle
that the hardware's
going to consume.

00:02:19.436 --> 00:02:23.346 A:middle
When I say expensive, I mean,
not for the GPU, but for the CPU

00:02:24.126 --> 00:02:26.646 A:middle
because it's the CPU that's
doing that type of translation.

00:02:26.646 --> 00:02:30.406 A:middle
So let's take a look
at a quick example.

00:02:31.416 --> 00:02:34.006 A:middle
If your application is
setting up for a new draw call,

00:02:34.176 --> 00:02:35.906 A:middle
you'll want to specify
the shaders and the state

00:02:35.906 --> 00:02:39.986 A:middle
and the textures for each
draw operation, and you'll do

00:02:39.986 --> 00:02:42.326 A:middle
that each time you want to
specify a new draw call.

00:02:42.776 --> 00:02:44.846 A:middle
And then the CPU gets
involved and spends a bunch

00:02:44.846 --> 00:02:49.116 A:middle
of time translating those state
changes and those requests

00:02:49.116 --> 00:02:53.096 A:middle
to draw in the hardware commands
before sending it to the GPU.

00:02:54.216 --> 00:02:56.706 A:middle
So if we had a way to make
that much less expensive,

00:02:56.876 --> 00:02:59.616 A:middle
we could give you a lot
more draw calls per frame,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:00.266 --> 00:03:01.536 A:middle
and you might ask
yourself, well,

00:03:01.606 --> 00:03:03.206 A:middle
why do I want more
draw calls per frame?

00:03:03.916 --> 00:03:07.336 A:middle
Well, more draw calls lets
you build much better games

00:03:07.336 --> 00:03:08.266 A:middle
and applications.

00:03:08.776 --> 00:03:11.046 A:middle
You can build many
more unique objects,

00:03:11.326 --> 00:03:13.906 A:middle
have many more bad guys, or
other characters in the scene.

00:03:14.506 --> 00:03:17.226 A:middle
You can add a lot more
visual variety to your games,

00:03:17.926 --> 00:03:21.506 A:middle
but probably the most important
reason is your game artists

00:03:21.556 --> 00:03:23.606 A:middle
and designers are going
to thank you profusely

00:03:23.606 --> 00:03:25.406 A:middle
because you're going to
give them more freedom

00:03:25.406 --> 00:03:29.276 A:middle
to realize their vision without
having to jump through all types

00:03:29.276 --> 00:03:32.396 A:middle
of draw call gymnastics to
fit what they'd like to see

00:03:32.396 --> 00:03:34.586 A:middle
on screen into a tiny
number of draw calls.

00:03:34.586 --> 00:03:37.796 A:middle
Now let's take a
little bit of a look

00:03:38.306 --> 00:03:40.246 A:middle
at what life was
like before Metal.

00:03:41.386 --> 00:03:45.816 A:middle
Now Apple has a long history
of GPU programming API's,

00:03:45.816 --> 00:03:46.896 A:middle
both implementing them,

00:03:46.896 --> 00:03:48.356 A:middle
maintaining them,
developing them.

00:03:49.566 --> 00:03:53.646 A:middle
We've supported standard
API's like OpenGL and OpenCL.

00:03:54.996 --> 00:03:57.276 A:middle
We've supported API's across
a wide variety of domains,

00:03:57.276 --> 00:03:59.716 A:middle
both at the high level and the
low level of GP programming

00:03:59.716 --> 00:04:01.246 A:middle
for things like 2D, 3D,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.716 --> 00:04:01.246 A:middle
for things like 2D, 3D,

00:04:01.406 --> 00:04:03.026 A:middle
animations, and image
processing.

00:04:03.936 --> 00:04:07.836 A:middle
And we've supported a wide
variety of architectures

00:04:08.216 --> 00:04:12.266 A:middle
in the hardware, across
platforms, computers, devices,

00:04:12.646 --> 00:04:17.466 A:middle
phones, iPads, and a
wide variety of GPU's.

00:04:18.466 --> 00:04:20.416 A:middle
And during all this time,
as we're supporting all

00:04:20.416 --> 00:04:21.755 A:middle
of this variety, we realized

00:04:21.755 --> 00:04:24.776 A:middle
that there was something pretty
fundamental missing from all

00:04:24.776 --> 00:04:29.966 A:middle
of these API's, and that was
the level of deep integration

00:04:30.246 --> 00:04:32.126 A:middle
that Apple brings
to its products.

00:04:32.866 --> 00:04:36.176 A:middle
Now Apple, as you know,
provides the operating system,

00:04:36.916 --> 00:04:40.816 A:middle
the hardware, and the
products as a complete package.

00:04:41.076 --> 00:04:42.876 A:middle
They're designed to work
together seamlessly.

00:04:43.676 --> 00:04:46.106 A:middle
And so we thought
to ourselves what

00:04:46.106 --> 00:04:49.376 A:middle
if we could take the same
approach to GPU programming

00:04:49.376 --> 00:04:50.986 A:middle
that we take to our
products as a whole?

00:04:51.906 --> 00:04:53.676 A:middle
If we could build these
to work seamlessly,

00:04:54.266 --> 00:04:56.556 A:middle
we knew we could do the
same for GPU programming,

00:04:57.086 --> 00:04:58.256 A:middle
and that's what we've
done with Metal.

00:04:58.256 --> 00:05:01.836 A:middle
Now as I said, we have a
long history at looking


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.256 --> 00:05:01.836 A:middle
Now as I said, we have a
long history at looking

00:05:01.836 --> 00:05:03.326 A:middle
at these different types
of programming API's,

00:05:03.326 --> 00:05:07.896 A:middle
and we realized that if we
wanted to get a tenfold in order

00:05:07.896 --> 00:05:10.486 A:middle
of magnitude improvement in
performance, we're going to have

00:05:10.486 --> 00:05:11.906 A:middle
to do some pretty
radical things.

00:05:12.376 --> 00:05:20.076 A:middle
We decided to take a clean
sheet approach to this design,

00:05:20.656 --> 00:05:25.146 A:middle
and the key design goals that
we had were outlined here.

00:05:26.146 --> 00:05:29.796 A:middle
First, we knew we wanted to
have the thinnest possible API

00:05:29.796 --> 00:05:31.386 A:middle
that we could create.

00:05:31.516 --> 00:05:34.266 A:middle
We wanted to be, reduce
the amount of code

00:05:34.266 --> 00:05:36.866 A:middle
that was executing in
between your application

00:05:37.056 --> 00:05:38.616 A:middle
and the GPU to a bare minimum.

00:05:40.656 --> 00:05:43.096 A:middle
We knew it needed to
support the most modern GPU

00:05:43.196 --> 00:05:44.106 A:middle
hardware features.

00:05:44.686 --> 00:05:47.146 A:middle
We didn't want it bogged down
with the [inaudible] of 20 years

00:05:47.426 --> 00:05:48.726 A:middle
of previous GPU designs.

00:05:48.726 --> 00:05:52.006 A:middle
We wanted to focus entirely
and squarely on the future.

00:05:52.426 --> 00:05:56.006 A:middle
We knew that there were some
expensive CPU operations

00:05:56.006 --> 00:05:58.876 A:middle
that needed to take place, but
we wanted to carefully control

00:05:58.936 --> 00:06:00.656 A:middle
when those happen and
make sure that they happen


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.936 --> 00:06:00.656 A:middle
when those happen and
make sure that they happen

00:06:00.656 --> 00:06:02.496 A:middle
as infrequently as possible.

00:06:02.866 --> 00:06:07.826 A:middle
And we wanted to give you
the developer predictable

00:06:07.936 --> 00:06:10.456 A:middle
performance so you
would know exactly when

00:06:10.556 --> 00:06:13.536 A:middle
and how those expensive
operations could take place.

00:06:13.876 --> 00:06:18.026 A:middle
We wanted to give
you explicit control

00:06:18.026 --> 00:06:21.006 A:middle
over when the work was
executed on the GPU.

00:06:21.086 --> 00:06:24.396 A:middle
So you could decide when and
how to kick off that work

00:06:24.726 --> 00:06:27.066 A:middle
and never be surprised by what
the implementation might do

00:06:27.066 --> 00:06:29.546 A:middle
behind your back.

00:06:29.546 --> 00:06:32.296 A:middle
And, last but not least, we
knew it had to be highly,

00:06:32.296 --> 00:06:35.426 A:middle
highly optimized for
the A7 CPU behavior

00:06:35.946 --> 00:06:37.746 A:middle
as this will become
key in a few moments.

00:06:38.086 --> 00:06:40.896 A:middle
So how to think about Metal.

00:06:41.086 --> 00:06:43.116 A:middle
Well, where does it fit?

00:06:43.266 --> 00:06:45.296 A:middle
Well, let's say you have your
application here represented

00:06:45.296 --> 00:06:47.026 A:middle
at the top of this
diagram in green,

00:06:47.416 --> 00:06:48.756 A:middle
and you like to talk to the GPU.

00:06:49.456 --> 00:06:51.916 A:middle
Well, Apple provides a
wide variety of API's

00:06:51.916 --> 00:06:55.016 A:middle
to do just that, but they
come at different levels

00:06:55.016 --> 00:06:58.466 A:middle
of abstraction, different
levels of conceptual distance

00:06:58.496 --> 00:07:00.046 A:middle
between you and the GPU.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:58.496 --> 00:07:00.046 A:middle
between you and the GPU.

00:07:00.846 --> 00:07:04.006 A:middle
So at a high level, you have
awesome API's like Scene Kit

00:07:04.056 --> 00:07:07.206 A:middle
and Sprite Kit that give high
level services for scene graphs

00:07:07.206 --> 00:07:09.896 A:middle
for 2D and 3D animations,
and they're great.

00:07:10.166 --> 00:07:13.786 A:middle
They provide a lot of services,
but they are relatively far

00:07:13.886 --> 00:07:15.596 A:middle
from the GPU in terms
of abstraction.

00:07:16.816 --> 00:07:19.226 A:middle
And then, of course, we have our
2D graphics and imaging API's

00:07:19.226 --> 00:07:22.916 A:middle
such as Core Animation, Core
Image, and Core Graphics,

00:07:23.346 --> 00:07:25.006 A:middle
and these, too, provide
a lot of services,

00:07:25.236 --> 00:07:27.296 A:middle
and if this is the type
of operation you're doing,

00:07:27.896 --> 00:07:30.856 A:middle
these are perfect API's for you.

00:07:30.856 --> 00:07:33.816 A:middle
And, as always, we have the
standard space 3D graphics

00:07:33.816 --> 00:07:35.446 A:middle
approach with OpenGL ES.

00:07:36.796 --> 00:07:38.466 A:middle
But when we wanted to
do something better,

00:07:38.466 --> 00:07:42.076 A:middle
and to give you high
efficiency GPU access

00:07:42.376 --> 00:07:44.126 A:middle
at the thinnest possible
API layer,

00:07:44.446 --> 00:07:46.046 A:middle
that's where Metal comes in.

00:07:47.016 --> 00:07:51.036 A:middle
So how do we do this?

00:07:51.036 --> 00:07:52.396 A:middle
Well, first thing we wanted

00:07:52.396 --> 00:07:55.316 A:middle
to understand is how
most modern games try

00:07:55.316 --> 00:07:57.786 A:middle
to manage their CPU
and GPU workloads.

00:07:58.216 --> 00:08:00.606 A:middle
So most games will
target a frame rate.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.216 --> 00:08:00.606 A:middle
So most games will
target a frame rate.

00:08:00.966 --> 00:08:02.756 A:middle
Oftentimes, it could
be 60 frames a second,

00:08:03.416 --> 00:08:04.266 A:middle
sometimes at 30.

00:08:04.396 --> 00:08:06.666 A:middle
In this example, we're using
30, which works out to be

00:08:06.666 --> 00:08:09.796 A:middle
about 33.3 milliseconds
per frame.

00:08:11.096 --> 00:08:13.576 A:middle
Now on this timeline, you can
see how most games would try

00:08:13.576 --> 00:08:16.136 A:middle
to optimize for this
type of timeline.

00:08:16.606 --> 00:08:21.866 A:middle
They'll try to balance the
amount of CPU work and the type

00:08:21.866 --> 00:08:25.286 A:middle
of GPU work to fill the entire
frame, but they'll do so offset.

00:08:25.356 --> 00:08:27.316 A:middle
So the CPU will be working
and generating commands

00:08:27.316 --> 00:08:30.336 A:middle
for one frame, and the GPU will
then consume those commands

00:08:30.336 --> 00:08:32.956 A:middle
in the next frame, and
while the CPU is doing that,

00:08:33.285 --> 00:08:37.885 A:middle
the GPU is busily working on the
previous frame, and you lay this

00:08:37.885 --> 00:08:40.385 A:middle
out on a timeline, and you
can see how you get relatively

00:08:40.385 --> 00:08:41.576 A:middle
perfect parallelism.

00:08:42.046 --> 00:08:45.936 A:middle
Well, let's look at one frame
in particular, and you'll notice

00:08:45.936 --> 00:08:49.716 A:middle
in this example we're assuming
a completely balanced frame

00:08:50.206 --> 00:08:55.016 A:middle
where the CPU and GPU are
occupying all of the time.

00:08:55.196 --> 00:08:58.176 A:middle
Now, unfortunately, real life
is not quite so balanced,

00:08:58.546 --> 00:09:01.756 A:middle
and oftentimes you'll find
that the CPU can take more time


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.546 --> 00:09:01.756 A:middle
and oftentimes you'll find
that the CPU can take more time

00:09:01.896 --> 00:09:05.596 A:middle
to generate these commands than
the GPU does to consume them,

00:09:06.046 --> 00:09:10.316 A:middle
and this is unfortunate because
it often leads the GPU idle.

00:09:10.646 --> 00:09:13.246 A:middle
So you're not even using the
system to its fullest capacity,

00:09:13.676 --> 00:09:14.836 A:middle
and if you were, it would be

00:09:14.836 --> 00:09:16.836 A:middle
like having a 50
percent faster GPU,

00:09:17.056 --> 00:09:18.056 A:middle
but it's just sitting
there dark.

00:09:18.056 --> 00:09:22.086 A:middle
So you say to yourself, "Well,
I'd like to fix this problem.

00:09:22.086 --> 00:09:25.646 A:middle
I'm just going to give more work
to the GPU", and, unfortunately,

00:09:25.646 --> 00:09:28.506 A:middle
what you'll find is that to give
more work to the GPU you have

00:09:28.506 --> 00:09:30.516 A:middle
to first spin up
more work on the CPU.

00:09:31.306 --> 00:09:33.186 A:middle
And if you were already bound by
the amount of work you could do

00:09:33.186 --> 00:09:35.926 A:middle
on the CPU, this pushes you, out
your frame time even further.

00:09:35.926 --> 00:09:38.566 A:middle
Now we're below our 30
frames per second target.

00:09:39.696 --> 00:09:42.476 A:middle
And to add insult to
injury, the GPU is still idle

00:09:42.956 --> 00:09:45.006 A:middle
because now our frame
time is actually longer,

00:09:45.206 --> 00:09:46.746 A:middle
and the GPU can't
fill that work either.

00:09:47.256 --> 00:09:51.476 A:middle
So to understand what's
happening here, it's helpful

00:09:51.476 --> 00:09:54.216 A:middle
to realize that the CPU
workload is actually split

00:09:54.216 --> 00:09:55.136 A:middle
into two parts.

00:09:56.226 --> 00:09:57.956 A:middle
You have the applications
workload,

00:09:57.956 --> 00:09:59.066 A:middle
what you guys are providing,

00:09:59.626 --> 00:10:01.376 A:middle
and then you have all
the implementation work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.626 --> 00:10:01.376 A:middle
and then you have all
the implementation work

00:10:01.376 --> 00:10:01.976 A:middle
for the GPU API itself.

00:10:02.366 --> 00:10:06.216 A:middle
So whenever you make a
GPU programming call,

00:10:07.026 --> 00:10:08.406 A:middle
we're going to have to translate

00:10:08.406 --> 00:10:09.936 A:middle
that in the way I
described earlier.

00:10:11.176 --> 00:10:14.586 A:middle
Well, it's this GPU
programming API time on the CPU

00:10:14.586 --> 00:10:16.186 A:middle
that we're focused
on with Metal,

00:10:16.916 --> 00:10:19.936 A:middle
and Metal dramatically
reduces this time

00:10:21.076 --> 00:10:22.136 A:middle
down to a bare minimum.

00:10:23.236 --> 00:10:25.166 A:middle
Now in this example,
we've actually freed

00:10:25.166 --> 00:10:27.176 A:middle
up additional CPU time.

00:10:27.176 --> 00:10:28.526 A:middle
Now it's the CPU that's idle,

00:10:28.816 --> 00:10:31.216 A:middle
and our frame time has
become limited by the GPU,

00:10:31.376 --> 00:10:33.776 A:middle
and we're actually beating our
30 frames per second target.

00:10:34.256 --> 00:10:35.996 A:middle
So if that was your goal,
you can now Render faster

00:10:35.996 --> 00:10:39.166 A:middle
than 30 frames per second,
but you have another option.

00:10:39.756 --> 00:10:42.976 A:middle
You can actually use that
CPU time to improve your game

00:10:42.976 --> 00:10:43.826 A:middle
and make it even better.

00:10:44.396 --> 00:10:49.246 A:middle
You could add more physics
or may AI or other types

00:10:49.306 --> 00:10:51.386 A:middle
of workloads to your
application.

00:10:52.196 --> 00:10:54.146 A:middle
We have a little bit of
CPU idle time here left.

00:10:55.016 --> 00:10:56.586 A:middle
We can actually choose
to go back

00:10:56.586 --> 00:10:58.586 A:middle
to our 30 frames
per second target,

00:10:59.216 --> 00:11:01.806 A:middle
and add even more draw calls
with Metal providing you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.216 --> 00:11:01.806 A:middle
and add even more draw calls
with Metal providing you

00:11:01.806 --> 00:11:03.816 A:middle
up to a 10x increase
in efficiency,

00:11:04.296 --> 00:11:06.836 A:middle
and you can either draw
more things with the GPU,

00:11:06.966 --> 00:11:09.376 A:middle
or maybe just draw them in
a much more flexible manner

00:11:09.846 --> 00:11:11.216 A:middle
so you can get more
visual variety.

00:11:12.266 --> 00:11:13.746 A:middle
So that's what we're
trying to do with Metal.

00:11:15.946 --> 00:11:19.466 A:middle
Now why is this GPU programming
so expensive on the CPU?

00:11:19.466 --> 00:11:21.356 A:middle
To understand what we did
with Metal, it's helpful

00:11:21.356 --> 00:11:24.426 A:middle
to take a deeper look here, too,
and there are 3 main reasons.

00:11:25.546 --> 00:11:28.646 A:middle
First, you have what's
called state validation.

00:11:29.336 --> 00:11:32.216 A:middle
Now some people think state
validation is just having the

00:11:32.216 --> 00:11:34.976 A:middle
implementation verify that
you're calling the API

00:11:34.976 --> 00:11:37.016 A:middle
in the right way and
that's certainly true,

00:11:37.946 --> 00:11:41.166 A:middle
but it also involves encoding
the state from the API

00:11:41.786 --> 00:11:45.456 A:middle
to the hardware and translating
it and oftentimes looking

00:11:45.456 --> 00:11:46.806 A:middle
at different aspects
of the state

00:11:46.806 --> 00:11:49.176 A:middle
and different state objects in
the API and figuring out how

00:11:49.176 --> 00:11:50.726 A:middle
to combine them into a way

00:11:50.726 --> 00:11:52.396 A:middle
that the hardware's
going to understand.

00:11:52.726 --> 00:11:53.586 A:middle
This can be expensive,

00:11:54.336 --> 00:11:56.026 A:middle
and perhaps the most
expensive version

00:11:56.026 --> 00:11:58.286 A:middle
of this is actually the
shader compilation itself.

00:11:59.436 --> 00:12:01.796 A:middle
So you take your source
code shaders for your vertex


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.436 --> 00:12:01.796 A:middle
So you take your source
code shaders for your vertex

00:12:01.796 --> 00:12:04.326 A:middle
and pixel shaders, and they
have to be compiled at run time

00:12:04.696 --> 00:12:07.546 A:middle
and to generate the
GPU's machine code.

00:12:08.126 --> 00:12:12.366 A:middle
What's worse is that in a lot
of API's before Metal, the state

00:12:13.216 --> 00:12:16.176 A:middle
and the shader code was not
described in the API in a way

00:12:16.176 --> 00:12:19.096 A:middle
that really mapped well to what
the hardware actually was going

00:12:19.096 --> 00:12:19.726 A:middle
to expect.

00:12:20.356 --> 00:12:22.816 A:middle
And so when you change
certain states, you could find

00:12:22.816 --> 00:12:24.876 A:middle
that behind the scenes,
we actually had to go back

00:12:24.876 --> 00:12:27.756 A:middle
and recompile your shaders,
causing even more CPU work.

00:12:29.096 --> 00:12:32.566 A:middle
And, last, they're sending
the work to the GPU itself,

00:12:32.826 --> 00:12:33.836 A:middle
and this can be expensive.

00:12:34.236 --> 00:12:36.996 A:middle
The resources, the memory, the
textures have to all be managed

00:12:36.996 --> 00:12:39.016 A:middle
and given to the GPU in
the way it can expect.

00:12:39.016 --> 00:12:42.516 A:middle
And because those first
two items are so expensive,

00:12:42.806 --> 00:12:45.186 A:middle
we often have encouraged you
with previous API's to batch

00:12:45.186 --> 00:12:46.406 A:middle
up lots of work to send,

00:12:46.766 --> 00:12:48.756 A:middle
to try to amortize
these expensive costs

00:12:49.096 --> 00:12:50.646 A:middle
across a fewer number
of draw calls

00:12:50.646 --> 00:12:52.926 A:middle
and just give more per
draw call to the GPU.

00:12:53.566 --> 00:12:57.526 A:middle
And, of course, this tends to
work at the cost of flexibility

00:12:57.526 --> 00:12:59.686 A:middle
to you, the developer, and
to your game designers,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:00.346 --> 00:13:03.456 A:middle
but it also increases latency
because now the GPU has more

00:13:03.456 --> 00:13:05.266 A:middle
to work on in a single chunk.

00:13:06.336 --> 00:13:08.976 A:middle
So we wanted to fix
these 3 key areas

00:13:09.416 --> 00:13:11.346 A:middle
of expense for GPU programming.

00:13:12.296 --> 00:13:16.576 A:middle
To do that, we thought
about 3 times, 3 occurrences

00:13:16.906 --> 00:13:18.976 A:middle
in the application life
cycle to focus in on.

00:13:19.456 --> 00:13:20.756 A:middle
There's the application
build time,

00:13:21.616 --> 00:13:23.616 A:middle
there's when you're loading
the content for your game,

00:13:23.916 --> 00:13:26.136 A:middle
and then when, there's when
you draw, and they occur

00:13:26.136 --> 00:13:27.196 A:middle
at different frequencies.

00:13:28.396 --> 00:13:30.496 A:middle
So, first, application
build time.

00:13:31.156 --> 00:13:32.556 A:middle
This basically never occurs.

00:13:33.806 --> 00:13:35.636 A:middle
I see some surprised
look on your faces

00:13:35.636 --> 00:13:38.066 A:middle
because as developers you think
you're building your application

00:13:38.186 --> 00:13:40.606 A:middle
all the time, and that's true.

00:13:41.126 --> 00:13:43.556 A:middle
But from your customer's
perspective,

00:13:43.556 --> 00:13:45.196 A:middle
from the people using
your application,

00:13:45.446 --> 00:13:46.396 A:middle
they never see this.

00:13:46.396 --> 00:13:49.126 A:middle
So if we can move things to
occur at application build time,

00:13:49.586 --> 00:13:51.046 A:middle
you've just eliminated
this expense

00:13:51.296 --> 00:13:52.396 A:middle
from the experience
of your game.

00:13:52.856 --> 00:13:55.096 A:middle
And then you have
content loading time,

00:13:55.416 --> 00:13:58.456 A:middle
which is relatively rare, again,
from a user's perspective.

00:13:58.456 --> 00:14:01.156 A:middle
They're only going to load a
level a few times per play.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.456 --> 00:14:01.156 A:middle
They're only going to load a
level a few times per play.

00:14:01.656 --> 00:14:05.236 A:middle
You have draw calls, on the
other hand, you're going

00:14:05.236 --> 00:14:07.956 A:middle
to do this thousands, ideally
thousands of times per frame.

00:14:08.746 --> 00:14:12.846 A:middle
And before Metal, unfortunately,
all 3 of those expensive bits

00:14:12.846 --> 00:14:15.476 A:middle
of operations for
the CPU occurred

00:14:15.476 --> 00:14:18.226 A:middle
in this last time,
at draw call time.

00:14:18.946 --> 00:14:21.076 A:middle
Thousands of time per
frame, or more likely,

00:14:21.246 --> 00:14:22.416 A:middle
a few hundred times per frame

00:14:22.416 --> 00:14:24.076 A:middle
because that's all
the CPU could absorb.

00:14:25.296 --> 00:14:28.946 A:middle
Now with metal, we've moved
these expensive operations

00:14:28.946 --> 00:14:30.736 A:middle
to occur much more optimally.

00:14:31.416 --> 00:14:34.556 A:middle
So you put shader compilation to
occur at application build time,

00:14:34.716 --> 00:14:37.586 A:middle
again, out of the field of view
for the users of your game.

00:14:38.326 --> 00:14:41.826 A:middle
And content loading, that's
when we do state validation.

00:14:42.336 --> 00:14:43.896 A:middle
This, again, is relatively rare.

00:14:44.656 --> 00:14:46.056 A:middle
This means the only
thing we have to do

00:14:46.056 --> 00:14:47.946 A:middle
at draw call time is the
most important thing to do

00:14:47.946 --> 00:14:50.606 A:middle
at draw call time, which is
kick off the work on the GPU.

00:14:51.086 --> 00:14:56.156 A:middle
So that's the how and the why
we created Metal, and now I want

00:14:56.156 --> 00:14:59.636 A:middle
to take a deeper look at the API
itself, and we'll take a look

00:14:59.636 --> 00:15:02.496 A:middle
at some of the conceptual
framework for the API starting


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.636 --> 00:15:02.496 A:middle
at some of the conceptual
framework for the API starting

00:15:03.256 --> 00:15:04.466 A:middle
with the objects in the API.

00:15:05.166 --> 00:15:08.286 A:middle
So the first object to talk

00:15:08.286 --> 00:15:10.096 A:middle
about in the Metal
API is the device,

00:15:10.846 --> 00:15:13.196 A:middle
and this essentially is just
an abstraction on the GPU,

00:15:13.196 --> 00:15:13.796 A:middle
the thing that's going

00:15:13.796 --> 00:15:16.476 A:middle
to consume your Rendering
and compute commands.

00:15:17.936 --> 00:15:20.286 A:middle
Those commands will be
stored and submitted

00:15:20.286 --> 00:15:21.816 A:middle
to the GPU in a command queue.

00:15:22.566 --> 00:15:25.036 A:middle
Now the command queue, its
job is simply to decide

00:15:25.036 --> 00:15:28.846 A:middle
and let you specify what order
those commands will be executed.

00:15:30.156 --> 00:15:31.826 A:middle
Those commands themselves
are stored

00:15:31.826 --> 00:15:33.206 A:middle
in what's called
a command buffer.

00:15:34.216 --> 00:15:36.966 A:middle
This stores the translated
hardware commands ready

00:15:36.966 --> 00:15:38.866 A:middle
for consumption by the GPU.

00:15:39.296 --> 00:15:44.536 A:middle
And the command encoder is the
API object that's responsible

00:15:44.536 --> 00:15:45.596 A:middle
for that translation.

00:15:45.886 --> 00:15:49.166 A:middle
So when you create a command
encoder, and you use it to write

00:15:49.166 --> 00:15:51.936 A:middle
into a command buffer,
that's the translation.

00:15:53.946 --> 00:15:56.566 A:middle
The state of the API is
described in a series

00:15:56.566 --> 00:15:58.566 A:middle
of state objects for things

00:15:58.566 --> 00:16:01.446 A:middle
like how your frame buffers
are set up, how you're blending


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.566 --> 00:16:01.446 A:middle
like how your frame buffers
are set up, how you're blending

00:16:01.446 --> 00:16:03.376 A:middle
and your depth and your
sample state is set up.

00:16:03.456 --> 00:16:06.546 A:middle
These are all described to the
API in objects, which we'll talk

00:16:06.546 --> 00:16:08.806 A:middle
about in all 3 sessions today.

00:16:10.006 --> 00:16:10.886 A:middle
And you have the code.

00:16:11.606 --> 00:16:13.876 A:middle
Your shaders, your
vertex, your pixel shaders.

00:16:14.156 --> 00:16:21.346 A:middle
And, last, you have your data,
your resources, your memory,

00:16:21.346 --> 00:16:23.966 A:middle
the textures and
the vertex buffers

00:16:23.966 --> 00:16:24.986 A:middle
and the shader constants.

00:16:25.016 --> 00:16:26.936 A:middle
Those are all stored
in resources.

00:16:27.306 --> 00:16:28.926 A:middle
So let's take a look
next at kind

00:16:28.926 --> 00:16:31.286 A:middle
of how these objects
fit together by walking

00:16:31.286 --> 00:16:33.416 A:middle
through a bit about how
we construct the objects

00:16:33.546 --> 00:16:35.806 A:middle
in the API.

00:16:36.026 --> 00:16:38.126 A:middle
So first thing you
have is the device.

00:16:39.216 --> 00:16:41.336 A:middle
So like we said, this is
the device's, the GPU.

00:16:41.336 --> 00:16:42.716 A:middle
The thing that's going
to consume your commands,

00:16:42.916 --> 00:16:44.816 A:middle
and from that you
create the command queue,

00:16:45.066 --> 00:16:47.216 A:middle
and typically you'll have one
of these in your application.

00:16:48.076 --> 00:16:49.976 A:middle
From the command
queue, you'll create one

00:16:49.976 --> 00:16:52.566 A:middle
or more command buffers to use
to store the hardware commands,

00:16:52.766 --> 00:16:54.076 A:middle
and you'll write
into those commands

00:16:54.336 --> 00:16:56.446 A:middle
with a Render Command
Encoder in this example.

00:16:58.386 --> 00:17:00.556 A:middle
Now, in order to
generate those commands,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.386 --> 00:17:00.556 A:middle
Now, in order to
generate those commands,

00:17:00.556 --> 00:17:01.976 A:middle
you need to specify
some information

00:17:01.976 --> 00:17:02.966 A:middle
of the Render Command Encoder,

00:17:03.296 --> 00:17:06.016 A:middle
and you do that by
attaching various objects

00:17:06.126 --> 00:17:07.756 A:middle
to the Render Command
Encoder before you use it.

00:17:08.296 --> 00:17:10.876 A:middle
So, for instance, you
specify your data buffers

00:17:11.096 --> 00:17:13.356 A:middle
and your textures
that you want to use

00:17:13.526 --> 00:17:15.036 A:middle
to do this Rendering operation.

00:17:15.826 --> 00:17:18.425 A:middle
Now you'll notice in this
diagram we also show something

00:17:18.425 --> 00:17:19.776 A:middle
called the texture descriptor,

00:17:20.156 --> 00:17:23.046 A:middle
and the texture descriptor is
used to create the textures.

00:17:23.185 --> 00:17:25.306 A:middle
It specifies all of the
necessary state used

00:17:25.306 --> 00:17:26.566 A:middle
for texture object creation.

00:17:28.236 --> 00:17:30.926 A:middle
Probably the biggest state
object is the Render Pipeline

00:17:30.926 --> 00:17:34.126 A:middle
state, and it, too, is
constructed from a descriptor,

00:17:34.756 --> 00:17:36.826 A:middle
and the descriptor in
this case describes all

00:17:36.826 --> 00:17:38.926 A:middle
of the 3D Rendering
state you need

00:17:38.926 --> 00:17:41.606 A:middle
to create a single
Render Pipeline.

00:17:42.566 --> 00:17:45.686 A:middle
Similarly, you have descriptors
for your depth and stencil state

00:17:45.686 --> 00:17:50.376 A:middle
that you use to create those
objects, and we have a series

00:17:50.376 --> 00:17:53.996 A:middle
of state for describing
the Render pass itself.

00:17:54.186 --> 00:17:55.886 A:middle
How you're going to
output your Rendering.

00:17:56.536 --> 00:17:59.156 A:middle
Now the reason we split the
state up into descriptors

00:17:59.486 --> 00:18:02.826 A:middle
and state objects is because
once you've specified what all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.486 --> 00:18:02.826 A:middle
and state objects is because
once you've specified what all

00:18:02.826 --> 00:18:06.366 A:middle
these state combinations should
be, Metal bakes all of these

00:18:06.406 --> 00:18:08.966 A:middle
into a small number
of state objects.

00:18:08.966 --> 00:18:11.136 A:middle
That now all of the state
has been translated,

00:18:11.136 --> 00:18:12.446 A:middle
all the shaders have
been compiled,

00:18:12.916 --> 00:18:14.476 A:middle
and the system is ready to go.

00:18:14.816 --> 00:18:17.356 A:middle
You can now issue your draw
calls incredibly quickly

00:18:17.516 --> 00:18:19.676 A:middle
without worrying that the
implementation's going to have

00:18:19.676 --> 00:18:22.376 A:middle
to come around and do some late
binding translation or figure

00:18:22.376 --> 00:18:24.356 A:middle
out if what you're trying to
do is valid in the first place.

00:18:24.686 --> 00:18:26.756 A:middle
A couple more notes.

00:18:27.326 --> 00:18:30.566 A:middle
So the source resources of
textures and buffers here,

00:18:30.566 --> 00:18:31.876 A:middle
you can change those as you go.

00:18:32.386 --> 00:18:34.356 A:middle
The Render targets
themselves are fixed

00:18:34.426 --> 00:18:35.966 A:middle
for a given Render
command decoder.

00:18:36.466 --> 00:18:41.866 A:middle
We'll talk more about why that's
important in just a moment.

00:18:41.866 --> 00:18:43.516 A:middle
Now inverting this
diagram a little bit,

00:18:43.516 --> 00:18:45.736 A:middle
we can see how objects
are actually sending data

00:18:45.736 --> 00:18:46.396 A:middle
to the device.

00:18:46.686 --> 00:18:48.606 A:middle
You can have one or more
Render Command Encoders,

00:18:48.806 --> 00:18:51.756 A:middle
one for each Rendering pass,
writing into the command buffer.

00:18:53.056 --> 00:18:55.566 A:middle
You can also interleave
different types of commands.

00:18:55.666 --> 00:18:57.496 A:middle
In this case, I'm
using compute commands

00:18:57.526 --> 00:19:00.206 A:middle
in the middle of my frame.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.526 --> 00:19:00.206 A:middle
in the middle of my frame.

00:19:01.176 --> 00:19:05.066 A:middle
And, as we said, Metal supports
efficient multi-threading.

00:19:05.066 --> 00:19:07.526 A:middle
You can actually construct
multiple command buffers

00:19:07.526 --> 00:19:09.486 A:middle
in parallel using
multiple threads.

00:19:09.486 --> 00:19:12.036 A:middle
So let's talk a little bit more

00:19:12.036 --> 00:19:13.676 A:middle
about the command
submission model itself

00:19:13.766 --> 00:19:14.886 A:middle
to understand how this works.

00:19:15.626 --> 00:19:18.566 A:middle
Just as we've said, command
encoders will encode the API

00:19:18.566 --> 00:19:20.976 A:middle
of your, it will
encode the API commands

00:19:20.976 --> 00:19:21.906 A:middle
into the hardware state,

00:19:22.456 --> 00:19:24.176 A:middle
and then they'll
store those commands

00:19:24.276 --> 00:19:25.606 A:middle
in the hardware command buffer.

00:19:27.176 --> 00:19:29.116 A:middle
There are 3 types
of command encoders

00:19:29.116 --> 00:19:32.476 A:middle
for generating 3 different
types of work on the GPU.

00:19:32.926 --> 00:19:35.976 A:middle
We have Render, Compute,
and Blit, and we'll talk

00:19:35.976 --> 00:19:37.016 A:middle
about each of them in detail.

00:19:37.766 --> 00:19:38.886 A:middle
But important to realize here is

00:19:38.886 --> 00:19:41.026 A:middle
that you can interleave these
different types of operations

00:19:41.336 --> 00:19:42.606 A:middle
in a single command buffer

00:19:42.866 --> 00:19:45.066 A:middle
and within a single
frame very efficiently.

00:19:45.586 --> 00:19:48.416 A:middle
And this is because the command
encoders themselves encapsulate

00:19:48.416 --> 00:19:50.526 A:middle
all the state necessary
so that we don't have

00:19:50.566 --> 00:19:53.676 A:middle
to do implicit transitions
between different types

00:19:53.676 --> 00:19:56.836 A:middle
of operations and behind the
scenes we don't have to try

00:19:56.836 --> 00:19:58.876 A:middle
to save and restore all
of the state necessary

00:19:58.876 --> 00:19:59.976 A:middle
for using these different
types of operations.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.106 --> 00:20:02.656 A:middle
It's all under your
explicit control.

00:20:03.156 --> 00:20:07.876 A:middle
The command buffers themselves
are incredibly lightweight,

00:20:07.876 --> 00:20:10.336 A:middle
and most applications are
going to create a large number

00:20:10.336 --> 00:20:11.526 A:middle
of these in their frames.

00:20:11.876 --> 00:20:15.846 A:middle
And you control exactly when

00:20:15.846 --> 00:20:19.606 A:middle
and how these get
submitted to the GPU.

00:20:19.796 --> 00:20:20.896 A:middle
Once they've been submitted,

00:20:21.166 --> 00:20:22.966 A:middle
Metal signals you
the application

00:20:23.466 --> 00:20:25.606 A:middle
when those command buffers
have completed their execution

00:20:25.606 --> 00:20:26.086 A:middle
on the GPU.

00:20:26.086 --> 00:20:29.216 A:middle
And so you get very fine grain
control and clear notifications

00:20:29.216 --> 00:20:31.226 A:middle
about exactly what's happening
at any one point in time.

00:20:32.556 --> 00:20:35.736 A:middle
And very important to realize
is that these command encoders,

00:20:35.976 --> 00:20:38.686 A:middle
they're not just sending some
work off that later is going

00:20:38.686 --> 00:20:40.796 A:middle
to be consumed by the CPU.

00:20:40.926 --> 00:20:43.206 A:middle
They're actually generating
these commands immediately.

00:20:43.206 --> 00:20:44.866 A:middle
There's no deferred
state validation.

00:20:45.246 --> 00:20:47.266 A:middle
It's essentially like
they're making a direct call

00:20:47.436 --> 00:20:48.336 A:middle
to the GPU driver.

00:20:48.856 --> 00:20:52.346 A:middle
As I mentioned, you can also
multi-thread this command

00:20:52.346 --> 00:20:54.706 A:middle
encoding to get even
more performance.

00:20:55.736 --> 00:20:57.666 A:middle
Multiple command buffers
can be encoded in parallel

00:20:57.666 --> 00:21:01.036 A:middle
across threads, and, yet,
you get to decide exactly


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:57.666 --> 00:21:01.036 A:middle
across threads, and, yet,
you get to decide exactly

00:21:01.036 --> 00:21:02.816 A:middle
when those commands
will be executed.

00:21:02.816 --> 00:21:05.276 A:middle
So you have the control to
both to split out the order

00:21:05.276 --> 00:21:08.216 A:middle
in which the commands will be
constructed while maintaining

00:21:08.216 --> 00:21:10.446 A:middle
the order you wish for
their execution on the GPU.

00:21:11.076 --> 00:21:13.386 A:middle
And we've provided an incredibly
efficient implementation

00:21:13.386 --> 00:21:14.346 A:middle
with no automic [phonetic] locks

00:21:14.346 --> 00:21:16.086 A:middle
to make sure you can
get scalable performance

00:21:16.236 --> 00:21:17.666 A:middle
across CPU course.

00:21:18.266 --> 00:21:19.686 A:middle
So that's the commands.

00:21:20.366 --> 00:21:22.756 A:middle
Next we're going to take a look
at the resources, the memory,

00:21:22.876 --> 00:21:25.606 A:middle
the objects in the API
for specifying data.

00:21:26.266 --> 00:21:30.286 A:middle
Now we've designed the resource
model in Metal explicitly

00:21:30.286 --> 00:21:33.066 A:middle
for the A7's unified
memory system.

00:21:33.916 --> 00:21:37.466 A:middle
This means that the CPU and the
GPU are sharing the exact same

00:21:37.466 --> 00:21:39.656 A:middle
memory for exchanging data.

00:21:40.136 --> 00:21:41.456 A:middle
There's no implicit copies.

00:21:41.456 --> 00:21:44.306 A:middle
We're not coming in behind
the scenes and taking the data

00:21:44.306 --> 00:21:47.426 A:middle
and moving it somewhere
else for the GPU to see it.

00:21:47.926 --> 00:21:51.396 A:middle
We also manage the CPU and
GPU cache coherency for you.

00:21:51.646 --> 00:21:53.336 A:middle
You don't have to worry
about flushing caches

00:21:53.336 --> 00:21:54.636 A:middle
between the CPU and the GPU.

00:21:54.926 --> 00:21:57.476 A:middle
You simply have to make sure
that you schedule your work

00:21:57.476 --> 00:22:00.926 A:middle
to occur such that the GPU
and the CPU are not writing


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.476 --> 00:22:00.926 A:middle
to occur such that the GPU
and the CPU are not writing

00:22:00.926 --> 00:22:02.546 A:middle
to the same chunk of
memory at the same time,

00:22:02.676 --> 00:22:05.016 A:middle
but you don't have to do
anything to manage caches.

00:22:05.656 --> 00:22:08.556 A:middle
And by you taking on
this responsibility

00:22:08.556 --> 00:22:10.826 A:middle
for synchronization
between the GPU and the CPU,

00:22:10.976 --> 00:22:13.106 A:middle
we can offer you
significantly higher performance

00:22:13.526 --> 00:22:15.416 A:middle
because we're not implicitly
synchronizing things

00:22:15.416 --> 00:22:17.436 A:middle
that didn't necessarily
need to be synchronized.

00:22:19.376 --> 00:22:21.616 A:middle
There are 2 different
types of resources for you

00:22:22.166 --> 00:22:23.766 A:middle
to use in your application.

00:22:24.396 --> 00:22:28.096 A:middle
The first is textures, which
are simply formatted image data

00:22:28.096 --> 00:22:31.986 A:middle
that you use for
Rendering for source data

00:22:32.316 --> 00:22:35.226 A:middle
or for Rendering destinations,
and there are data buffers

00:22:35.346 --> 00:22:38.666 A:middle
which are essentially
unformatted ranges of memory.

00:22:38.756 --> 00:22:40.266 A:middle
You can think of them
like just a bag of bytes

00:22:40.266 --> 00:22:42.336 A:middle
to store your vertex data,
your shader constants,

00:22:42.336 --> 00:22:45.086 A:middle
any output memory from
your GPU workloads.

00:22:45.086 --> 00:22:49.206 A:middle
The important thing to remember
with Metal is that the structure

00:22:49.736 --> 00:22:52.386 A:middle
of these resources is immutable.

00:22:52.386 --> 00:22:53.276 A:middle
You cannot change it.

00:22:53.276 --> 00:22:56.706 A:middle
Once you create a texture of
a given size or given level

00:22:56.706 --> 00:22:59.226 A:middle
or a given format, it's baked,

00:22:59.716 --> 00:23:02.796 A:middle
and this lets us avoid
costly resource validation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.716 --> 00:23:02.796 A:middle
and this lets us avoid
costly resource validation

00:23:03.516 --> 00:23:05.416 A:middle
that would previously have
taken place in other API's

00:23:05.416 --> 00:23:07.646 A:middle
where we'd have to
figure out, hey,

00:23:07.646 --> 00:23:10.056 A:middle
not that you've changed how
a texture is structured,

00:23:10.416 --> 00:23:11.236 A:middle
is it still valid.

00:23:11.236 --> 00:23:13.296 A:middle
Can we still use it as
a Rendering destination?

00:23:13.296 --> 00:23:14.286 A:middle
Is it still [inaudible]
complete?

00:23:14.286 --> 00:23:15.506 A:middle
We don't have to do any of that

00:23:15.506 --> 00:23:17.196 A:middle
because you've specified
it all up front.

00:23:18.326 --> 00:23:20.816 A:middle
If you want to use two
different textures with, sorry.

00:23:20.816 --> 00:23:23.666 A:middle
If you want to use two different
formats for your texture,

00:23:23.666 --> 00:23:25.436 A:middle
you simply create two
different textures,

00:23:25.766 --> 00:23:27.096 A:middle
and this is actually
much more efficient.

00:23:27.096 --> 00:23:29.976 A:middle
We can rapidly switch
between these on,

00:23:30.036 --> 00:23:31.136 A:middle
in the Metal implementation.

00:23:31.656 --> 00:23:35.676 A:middle
Of course, you can still change
the contents of your textures

00:23:35.766 --> 00:23:37.746 A:middle
for your buffers,
and to do that,

00:23:38.026 --> 00:23:39.146 A:middle
we provide several methods.

00:23:39.976 --> 00:23:41.826 A:middle
So you can update
data buffers directly.

00:23:42.006 --> 00:23:44.276 A:middle
You simply get a pointer
to the underlying storage.

00:23:44.636 --> 00:23:47.106 A:middle
There's no lock API needed
because, again, this is running

00:23:47.106 --> 00:23:50.306 A:middle
on a unified memory
system, and for textures,

00:23:50.556 --> 00:23:52.816 A:middle
we have what's called an
implementation private storage.

00:23:53.116 --> 00:23:54.676 A:middle
Now this doesn't mean that
we're copying the data

00:23:54.676 --> 00:23:55.886 A:middle
and moving it somewhere else.

00:23:56.126 --> 00:23:58.396 A:middle
This simply means that we
will reformat the textures

00:23:58.396 --> 00:24:00.476 A:middle
for efficient Rendering
on the GPU,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.396 --> 00:24:00.476 A:middle
for efficient Rendering
on the GPU,

00:24:00.476 --> 00:24:03.556 A:middle
but we provide some
blazing fast update routines

00:24:03.626 --> 00:24:05.016 A:middle
in Metal to do that.

00:24:05.446 --> 00:24:09.426 A:middle
If you need an asynchronous
update routine for your textures

00:24:09.426 --> 00:24:11.556 A:middle
or your buffers, you can do
this via the Blit Encoder,

00:24:11.836 --> 00:24:14.156 A:middle
and we'll talk in just a
moment about how that works.

00:24:16.726 --> 00:24:19.146 A:middle
Now one other thing you can do
with resources, and textures

00:24:19.146 --> 00:24:21.326 A:middle
in particular, is you can
actually share the underlying

00:24:21.326 --> 00:24:23.266 A:middle
storage across multiple textures

00:24:23.636 --> 00:24:26.826 A:middle
and reinterpret the pixel
data differently in each one.

00:24:27.456 --> 00:24:29.026 A:middle
So, for instance, if
you have a texture

00:24:29.446 --> 00:24:32.916 A:middle
that is using a single
32-bit integer pixel format,

00:24:33.466 --> 00:24:34.526 A:middle
you can have another texture

00:24:34.526 --> 00:24:39.806 A:middle
which is using a 4-component
RGBA8 pixel format,

00:24:39.806 --> 00:24:41.096 A:middle
and they can actually
be pointing

00:24:41.096 --> 00:24:42.336 A:middle
at the same underlying storage

00:24:42.556 --> 00:24:45.206 A:middle
because the pixel size is
the same between the 2.

00:24:46.496 --> 00:24:48.556 A:middle
And you can also share
the texture storage

00:24:48.966 --> 00:24:49.666 A:middle
with data buffers.

00:24:50.126 --> 00:24:53.506 A:middle
This will allow you direct
access to the underlying storage

00:24:53.506 --> 00:24:55.556 A:middle
with the CPU and to use
the underlying storage

00:24:55.556 --> 00:24:58.806 A:middle
as a data buffer, and we
simply assume row lineal,

00:24:58.986 --> 00:25:02.336 A:middle
row linear pixel order
in this particular case.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.986 --> 00:25:02.336 A:middle
row linear pixel order
in this particular case.

00:25:02.496 --> 00:25:04.046 A:middle
OK. Those are resources.

00:25:04.266 --> 00:25:05.286 A:middle
Now I'm going to talk briefly

00:25:05.446 --> 00:25:08.146 A:middle
about the command encoders
themselves, and as I mentioned,

00:25:08.226 --> 00:25:10.316 A:middle
there are 3 basic
command encoder types.

00:25:11.146 --> 00:25:15.336 A:middle
You have your Render, Compute,
and Blit command encoders,

00:25:15.496 --> 00:25:18.066 A:middle
and I'm going to talk about
each of these in sequence.

00:25:18.776 --> 00:25:21.196 A:middle
So first off the
Render Command Encoder.

00:25:21.196 --> 00:25:24.576 A:middle
Now the Render Command Encoder,
you can think about this as all

00:25:24.576 --> 00:25:25.996 A:middle
of the hardware commands
necessary

00:25:26.136 --> 00:25:29.496 A:middle
for generating a single
Rendering pass, and by pass,

00:25:29.496 --> 00:25:32.516 A:middle
I mean all of the Rendering
to one frame buffer object,

00:25:32.516 --> 00:25:33.696 A:middle
one set of Render targets.

00:25:34.226 --> 00:25:37.656 A:middle
If you want to change to
another set of Render targets

00:25:37.736 --> 00:25:38.846 A:middle
to another frame buffer,

00:25:39.386 --> 00:25:41.626 A:middle
you simply use another
Render Command Encoder,

00:25:42.216 --> 00:25:45.096 A:middle
and this is all the state
for specifying the vertex

00:25:45.096 --> 00:25:47.896 A:middle
and fragment stages
of the 3D pipeline.

00:25:48.376 --> 00:25:51.366 A:middle
And it allows you to
interleave these state changes,

00:25:51.486 --> 00:25:53.966 A:middle
the resources, and any
draw calls necessary

00:25:53.966 --> 00:25:56.356 A:middle
for constructing your
pass, but, critically,

00:25:56.726 --> 00:25:59.016 A:middle
there's no draw time
compilation.

00:25:59.926 --> 00:26:02.606 A:middle
You get to control, the
app developer, exactly when


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.926 --> 00:26:02.606 A:middle
You get to control, the
app developer, exactly when

00:26:02.606 --> 00:26:04.796 A:middle
and how all of the
state compilation

00:26:04.796 --> 00:26:06.846 A:middle
and expensive validation
actually takes place.

00:26:08.166 --> 00:26:11.296 A:middle
And you do that with a series
of API calls and state objects,

00:26:11.466 --> 00:26:12.906 A:middle
and I'll show you just
a few of those here.

00:26:13.576 --> 00:26:15.966 A:middle
So as we talked about, you have
your depth and stencil objects,

00:26:16.546 --> 00:26:18.176 A:middle
sampler objects,
the Render Pipeline,

00:26:18.476 --> 00:26:20.436 A:middle
and they describe
various aspects

00:26:20.516 --> 00:26:23.596 A:middle
of the 3D Rendering state.

00:26:25.146 --> 00:26:28.246 A:middle
Basically, almost everything
fits in the Render Pipeline

00:26:28.526 --> 00:26:30.246 A:middle
where you, that's where
you specify your shaders,

00:26:30.776 --> 00:26:33.386 A:middle
your blend states, all, how
your vertex data is actually

00:26:33.386 --> 00:26:36.736 A:middle
specified, and all of that can
fit into these state objects.

00:26:36.936 --> 00:26:40.166 A:middle
Now important to
realize in Metal is

00:26:40.166 --> 00:26:42.406 A:middle
that not all state
objects are created equal.

00:26:42.716 --> 00:26:45.176 A:middle
Some of the states are actually
very expensive to change,

00:26:45.356 --> 00:26:47.986 A:middle
and for these, we've put them
in what's called immutable

00:26:47.986 --> 00:26:49.466 A:middle
or unchangeable state objects,

00:26:50.456 --> 00:26:51.826 A:middle
and you can't change
these states

00:26:51.876 --> 00:26:53.376 A:middle
after you've created
the objects.

00:26:53.696 --> 00:26:56.616 A:middle
These are the types of things
that affect expensive operations

00:26:56.616 --> 00:26:58.686 A:middle
or cause recompilation to occur.

00:26:59.346 --> 00:27:02.336 A:middle
So things like the shaders
themselves we don't want to be,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.346 --> 00:27:02.336 A:middle
So things like the shaders
themselves we don't want to be,

00:27:02.336 --> 00:27:04.466 A:middle
you don't us to be
recompiling them all the time.

00:27:04.856 --> 00:27:07.436 A:middle
So once you specified
those into a state object,

00:27:07.866 --> 00:27:08.506 A:middle
you can't change them.

00:27:09.226 --> 00:27:10.926 A:middle
But other things, like
the viewport and scissor,

00:27:10.926 --> 00:27:13.366 A:middle
are actually really cheap
to specify and really cheap

00:27:13.366 --> 00:27:15.636 A:middle
to change, and so
those remain flexible.

00:27:16.146 --> 00:27:21.106 A:middle
Now I talked a few times
about how the API was designed

00:27:21.386 --> 00:27:25.766 A:middle
with the A7 in mind, and one of
the key ways you can see this is

00:27:25.766 --> 00:27:28.166 A:middle
in how we handle frame
buffer loads and stores.

00:27:28.166 --> 00:27:34.346 A:middle
Now the A7 GPU is a
tile-based deferred mode Render.

00:27:34.346 --> 00:27:37.716 A:middle
Now I'm not going to go into
the details of what this means,

00:27:37.716 --> 00:27:39.786 A:middle
but one important
piece of that is

00:27:39.786 --> 00:27:45.366 A:middle
that it has what's called a tile
cache, and a tile cache is used

00:27:45.366 --> 00:27:47.466 A:middle
at the beginning and end
of each Rendering pass

00:27:47.766 --> 00:27:50.806 A:middle
to load the contents of
the previous frame buffer

00:27:50.806 --> 00:27:53.726 A:middle
or to write it up to memory.

00:27:53.726 --> 00:27:57.366 A:middle
And so you need some explicit
control over this tile cache

00:27:57.366 --> 00:27:58.586 A:middle
to get optimal performance

00:27:58.586 --> 00:28:00.486 A:middle
and to make sure you're
not doing needless reads


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.586 --> 00:28:00.486 A:middle
and to make sure you're
not doing needless reads

00:28:00.486 --> 00:28:01.206 A:middle
and writes to memory.

00:28:01.886 --> 00:28:04.846 A:middle
In Metal, you can specify
load and store actions

00:28:04.846 --> 00:28:07.556 A:middle
on the frame buffer to make
this incredibly efficient,

00:28:07.556 --> 00:28:09.216 A:middle
and I'll show you an example
of how that works here.

00:28:10.626 --> 00:28:13.546 A:middle
So let's say, as an example,
this is before Metal,

00:28:14.016 --> 00:28:17.296 A:middle
you had one frame
for which you wanted

00:28:17.296 --> 00:28:20.376 A:middle
to do two Rendering passes, and
in this example, you're going

00:28:20.376 --> 00:28:21.736 A:middle
to take the color frame
buffer, you're going to have

00:28:21.736 --> 00:28:22.606 A:middle
to redo the beginning.

00:28:22.656 --> 00:28:24.726 A:middle
You're going to write it
out at one pass through,

00:28:24.726 --> 00:28:26.666 A:middle
and then you're going to do
the same for the second pass,

00:28:26.896 --> 00:28:29.716 A:middle
and you'll probably want to
use a depth buffer as well.

00:28:30.166 --> 00:28:33.916 A:middle
So before Metal, you can
actually see here there was

00:28:33.916 --> 00:28:35.526 A:middle
quite a lot of memory
bandwidth taking place

00:28:35.526 --> 00:28:36.506 A:middle
across these passes.

00:28:36.826 --> 00:28:40.086 A:middle
You end up with 2 reads and 2
writes for each of the color

00:28:40.086 --> 00:28:42.576 A:middle
and the depth buffer, which
is a lot of memory traffic.

00:28:43.916 --> 00:28:46.876 A:middle
Well, with Metal, we
actually let you specify

00:28:47.166 --> 00:28:49.746 A:middle
which of those reads and writes
you actually need to occur.

00:28:50.206 --> 00:28:51.856 A:middle
So, for instance,
you can say, well,

00:28:51.856 --> 00:28:54.496 A:middle
I'm going to Render every
pixel of my frame anyway.

00:28:54.496 --> 00:28:56.846 A:middle
There's no point in loading
the tile cache at the beginning

00:28:56.846 --> 00:28:58.696 A:middle
of the frame, and I can
save that bandwidth.

00:28:59.466 --> 00:29:01.736 A:middle
And if you're going to write
out the pass and then read it


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.466 --> 00:29:01.736 A:middle
And if you're going to write
out the pass and then read it

00:29:01.736 --> 00:29:04.526 A:middle
in the second pass, you probably
would need to actually do that,

00:29:05.186 --> 00:29:07.266 A:middle
but when you look at the depth
buffer, you can see a lot

00:29:07.266 --> 00:29:08.646 A:middle
of unnecessary reads and writes.

00:29:08.926 --> 00:29:11.876 A:middle
And so you can specify that we
should probably just clear the

00:29:11.876 --> 00:29:13.356 A:middle
depth buffer at the
beginning of the frame

00:29:13.356 --> 00:29:15.206 A:middle
because you're not going to
need its previous contents,

00:29:15.596 --> 00:29:17.296 A:middle
and you don't need to write
it out at the end of the frame

00:29:17.296 --> 00:29:18.796 A:middle
because you're not using
it in a second pass.

00:29:18.796 --> 00:29:21.216 A:middle
You're simply going to clear it
again, and then you don't need

00:29:21.216 --> 00:29:22.126 A:middle
to write it out there either,

00:29:22.586 --> 00:29:24.846 A:middle
and we can get some
dramatic reductions

00:29:24.876 --> 00:29:26.526 A:middle
in memory traffic
as a result of this.

00:29:27.786 --> 00:29:30.456 A:middle
You can reduce the overall
amount of reads and writes

00:29:30.646 --> 00:29:32.376 A:middle
to a fraction of
what it was before,

00:29:32.546 --> 00:29:34.296 A:middle
and you can gain
significant performance

00:29:34.296 --> 00:29:35.066 A:middle
for your application.

00:29:35.856 --> 00:29:37.336 A:middle
So this is just one of the ways

00:29:37.336 --> 00:29:39.506 A:middle
in which we've designed
Metal with the A7 in mind.

00:29:39.916 --> 00:29:42.566 A:middle
Alright. That's Rendering.

00:29:42.566 --> 00:29:45.376 A:middle
Now we're going to look at
the next area we introduced

00:29:45.376 --> 00:29:48.416 A:middle
with Metal, a functionality,
which is Compute.

00:29:49.156 --> 00:29:51.086 A:middle
So we're not going to spend
a lot of time today talking

00:29:51.086 --> 00:29:54.506 A:middle
about general purpose data
parallel computation in the GPU,

00:29:54.696 --> 00:29:56.076 A:middle
but for those of you
who have done this type

00:29:56.076 --> 00:29:57.826 A:middle
of operation before,
you're going to find

00:29:57.826 --> 00:29:59.976 A:middle
that this is a very familiar
run time in memory model.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.066 --> 00:30:03.266 A:middle
It uses the same
textures and data buffers

00:30:03.266 --> 00:30:07.496 A:middle
from the Metal graphics API's,
has the same basic kinds

00:30:07.496 --> 00:30:10.096 A:middle
of memory hierarchy,
barriers, memories,

00:30:10.096 --> 00:30:11.156 A:middle
and load stores you might find

00:30:11.156 --> 00:30:13.036 A:middle
in other data parallel
programming API's,

00:30:13.516 --> 00:30:14.486 A:middle
and you can configure

00:30:14.486 --> 00:30:16.696 A:middle
and specify exactly
how the work groups

00:30:16.696 --> 00:30:19.236 A:middle
for your Compute operations
will be executed by the GPU.

00:30:21.116 --> 00:30:24.716 A:middle
Probably more important
to realize with Metal is

00:30:24.716 --> 00:30:27.256 A:middle
that it is, the Compute
operations are fully integrated

00:30:27.256 --> 00:30:27.746 A:middle
with graphics.

00:30:28.856 --> 00:30:32.106 A:middle
This means you get a unified
API, a single shading language,

00:30:32.286 --> 00:30:34.446 A:middle
and a single set of
fantastic developer tools

00:30:34.446 --> 00:30:37.046 A:middle
for both graphics and
compute operations on the GPU.

00:30:37.046 --> 00:30:40.316 A:middle
And probably more
important for performance,

00:30:40.756 --> 00:30:43.266 A:middle
we can efficiently
interleave these operations

00:30:43.436 --> 00:30:45.116 A:middle
between Compute, Rendering,

00:30:45.506 --> 00:30:47.766 A:middle
and data [inaudible]
operations in Blit.

00:30:49.336 --> 00:30:53.416 A:middle
Similarly, to graphics, there's
no execution time compilation

00:30:53.566 --> 00:30:54.716 A:middle
with the Compute operations.

00:30:55.036 --> 00:30:59.116 A:middle
You control exactly when these
expensive compilation activities

00:30:59.116 --> 00:30:59.546 A:middle
will occur.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.056 --> 00:31:02.316 A:middle
And probably a little
bit different

00:31:02.316 --> 00:31:06.156 A:middle
from how graphics looks in
Metal, there's very little state

00:31:06.206 --> 00:31:07.556 A:middle
in the Compute command encoder.

00:31:07.976 --> 00:31:09.546 A:middle
There's some state
for specifying exactly

00:31:09.546 --> 00:31:10.996 A:middle
which Compute kernels
you're going to be using

00:31:10.996 --> 00:31:12.516 A:middle
and how you're going to
configure work groups,

00:31:12.516 --> 00:31:13.476 A:middle
and that's pretty much it.

00:31:13.966 --> 00:31:15.586 A:middle
And that's it.

00:31:15.746 --> 00:31:17.456 A:middle
If the Compute command
encoder seems simple,

00:31:17.486 --> 00:31:19.856 A:middle
that's because it is,
and that brings us

00:31:19.856 --> 00:31:22.666 A:middle
to our last command encoder,
the Blit Command Encoder,

00:31:23.226 --> 00:31:25.976 A:middle
and this is what you're going to
use for asynchronous data copies

00:31:26.006 --> 00:31:29.216 A:middle
between resources on the GPU,
and this can happen in parallel

00:31:29.216 --> 00:31:31.376 A:middle
with your compute and
your graphics operations.

00:31:32.216 --> 00:31:34.606 A:middle
You can use this to upload
textures, to copy data

00:31:34.606 --> 00:31:38.846 A:middle
between textures and buffers,
or to generate your mipmaps.

00:31:39.596 --> 00:31:42.756 A:middle
You can also update the data
buffers themselves, again,

00:31:42.756 --> 00:31:45.016 A:middle
copying to and from
textures or other buffers,

00:31:45.196 --> 00:31:47.716 A:middle
and you can actually fill
the buffers themselves

00:31:47.716 --> 00:31:49.896 A:middle
with constant values and
Blit Command Encoder.

00:31:50.266 --> 00:31:53.956 A:middle
Alright. That's it for the
API high level summary.

00:31:53.956 --> 00:31:55.416 A:middle
Now I'm going to
take a quick tour

00:31:55.626 --> 00:31:56.746 A:middle
through the shading
language itself.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:00.506 --> 00:32:04.216 A:middle
Alright. So the Metal
shading language is a unified

00:32:04.216 --> 00:32:04.986 A:middle
shading language.

00:32:05.306 --> 00:32:07.926 A:middle
This means use the same
language, syntax, constructs,

00:32:07.926 --> 00:32:10.096 A:middle
tool change for both graphics
and compute processing,

00:32:10.696 --> 00:32:14.636 A:middle
and it's based on C++11,
essentially a static subset

00:32:14.856 --> 00:32:19.186 A:middle
of this language, and it's
built out of LLVM and clang,

00:32:19.366 --> 00:32:21.316 A:middle
which means you get
incredibly high performance

00:32:21.316 --> 00:32:24.696 A:middle
and incredibly high quality
code generation for the GPU.

00:32:25.006 --> 00:32:28.336 A:middle
The only thing we've really
had to do was add some syntax

00:32:28.336 --> 00:32:30.356 A:middle
for describing certain
hardware functionality

00:32:30.356 --> 00:32:32.116 A:middle
such as how you're going
to control texture sampling

00:32:32.116 --> 00:32:34.806 A:middle
and rasterization, and then
we've added a few things

00:32:34.806 --> 00:32:37.086 A:middle
to make shader authoring
much more convenient

00:32:37.086 --> 00:32:39.426 A:middle
such as function overloading
and basic template support.

00:32:40.456 --> 00:32:40.966 A:middle
But that's it.

00:32:41.046 --> 00:32:44.666 A:middle
If you know C++, you understand
Metal shading language.

00:32:44.956 --> 00:32:50.076 A:middle
As I said, we added just a
few data types and some syntax

00:32:50.076 --> 00:32:52.306 A:middle
for handling graphics and
compute functionality.

00:32:52.466 --> 00:32:55.296 A:middle
Some basic data types you'll
probably find very useful

00:32:55.296 --> 00:32:56.926 A:middle
such as scaler, vector,
and matrix types,

00:32:57.516 --> 00:33:01.106 A:middle
and then we've used what's
called the attribute syntax


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.516 --> 00:33:01.106 A:middle
and then we've used what's
called the attribute syntax

00:33:01.136 --> 00:33:04.926 A:middle
to specify a lot of the
connection between the Metal API

00:33:04.926 --> 00:33:06.276 A:middle
and the Metal shading language.

00:33:06.496 --> 00:33:08.886 A:middle
So things like how do you get
data in and out of your shaders.

00:33:08.886 --> 00:33:11.076 A:middle
You specify those with
function arguments

00:33:11.076 --> 00:33:14.576 A:middle
and use the attribute syntax to
actually identify which textures

00:33:14.576 --> 00:33:15.656 A:middle
and buffers you want to use.

00:33:16.606 --> 00:33:19.186 A:middle
Or how to implement programmable
blending in your shaders.

00:33:19.186 --> 00:33:20.536 A:middle
You can actually use
the attribute syntax

00:33:20.536 --> 00:33:23.856 A:middle
to specify pixels you want to
read from the frame buffer.

00:33:24.236 --> 00:33:27.706 A:middle
The Metal shading language
itself is incredibly easy

00:33:27.706 --> 00:33:28.236 A:middle
to use.

00:33:28.436 --> 00:33:30.936 A:middle
You can put multiple shaders
in a single source code file,

00:33:31.126 --> 00:33:34.276 A:middle
and then we will build those
source code files with Xcode

00:33:34.276 --> 00:33:35.976 A:middle
when you're building
your application

00:33:36.376 --> 00:33:38.416 A:middle
into Metal library files,

00:33:38.916 --> 00:33:41.586 A:middle
and the Metal library files
are essentially just an archive

00:33:41.586 --> 00:33:42.576 A:middle
of your Metal shaders.

00:33:43.596 --> 00:33:44.676 A:middle
With the Metal run time API's,

00:33:44.676 --> 00:33:46.526 A:middle
you can actually
load a Metal library,

00:33:46.596 --> 00:33:48.396 A:middle
and then you can
finalize the compilation

00:33:48.396 --> 00:33:51.016 A:middle
into this device's
machine specific code.

00:33:52.036 --> 00:33:54.716 A:middle
We also include an
awesome standard library

00:33:54.716 --> 00:33:58.336 A:middle
of very commonly used and
incredibly performing graphics

00:33:58.336 --> 00:33:59.166 A:middle
and compute functions.

00:33:59.556 --> 00:34:02.866 A:middle
One other thing to realize


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.556 --> 00:34:02.866 A:middle
One other thing to realize

00:34:02.866 --> 00:34:04.826 A:middle
about the Metal shading language
is you need to get data in

00:34:04.826 --> 00:34:05.786 A:middle
and out of your shaders.

00:34:05.986 --> 00:34:09.076 A:middle
So we specify, use a method
called argument tables

00:34:09.106 --> 00:34:11.755 A:middle
to let you specify which
arguments, which resources,

00:34:12.036 --> 00:34:14.136 A:middle
and which data needs
to move between the API

00:34:14.136 --> 00:34:15.795 A:middle
and the shading environment.

00:34:17.735 --> 00:34:20.536 A:middle
So each command encoder will
include what's called an

00:34:20.536 --> 00:34:22.656 A:middle
argument table, and
this is simply a list

00:34:22.656 --> 00:34:25.235 A:middle
of the resources you want to use
in the API that you want to read

00:34:25.235 --> 00:34:28.386 A:middle
and access and write in
the shader themselves.

00:34:28.755 --> 00:34:34.466 A:middle
There's one table for each type
of resource, and then the shader

00:34:34.686 --> 00:34:38.036 A:middle
and the host code will simply
use an index into that table

00:34:38.036 --> 00:34:39.255 A:middle
to refer to the same resource.

00:34:39.255 --> 00:34:40.025 A:middle
Let's see an example.

00:34:40.196 --> 00:34:44.746 A:middle
So on the right here, I simply
have a representation of one

00:34:44.746 --> 00:34:45.755 A:middle
of the command encoders.

00:34:45.795 --> 00:34:47.795 A:middle
Could be Render Command
Encoder, for instance.

00:34:48.426 --> 00:34:51.136 A:middle
And you have a table
in the command encoder

00:34:51.136 --> 00:34:53.226 A:middle
that describes the resources.

00:34:53.295 --> 00:34:55.846 A:middle
So you have a list of all
of the textures you want

00:34:55.846 --> 00:34:57.206 A:middle
to use in your shaders.

00:34:59.256 --> 00:35:01.806 A:middle
Similar tables exist for
buffers and samplers.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.256 --> 00:35:01.806 A:middle
Similar tables exist for
buffers and samplers.

00:35:02.196 --> 00:35:03.366 A:middle
Now I've simplified
this a little bit

00:35:03.366 --> 00:35:05.666 A:middle
because there's actually 1 of
these sets of tables for each

00:35:05.666 --> 00:35:07.356 A:middle
of the vertex and
fragment shader stages.

00:35:07.596 --> 00:35:09.116 A:middle
Well, let's take a look
at an example shader.

00:35:09.266 --> 00:35:13.236 A:middle
So in this, we have a vertex
shader and a fragment shader

00:35:13.416 --> 00:35:14.596 A:middle
in Metal shader code
on the left,

00:35:14.596 --> 00:35:16.336 A:middle
and you'll see it
looks quite familiar.

00:35:16.666 --> 00:35:18.666 A:middle
You'll get a lot more
information about how this works

00:35:18.666 --> 00:35:20.576 A:middle
in the next session, but
you can get a good sense

00:35:20.576 --> 00:35:21.776 A:middle
of how this works
just from looking

00:35:21.776 --> 00:35:25.226 A:middle
at the code itself right here.

00:35:25.226 --> 00:35:28.946 A:middle
So in the fragment shader, we're
simply referring to texture

00:35:29.056 --> 00:35:32.096 A:middle
at index 1 to identify that we
would like to use the texture

00:35:32.096 --> 00:35:34.906 A:middle
that we set up in the
command encoder to read

00:35:35.226 --> 00:35:36.176 A:middle
in this fragment shader.

00:35:36.996 --> 00:35:39.906 A:middle
And, similarly, in the vertex
shader, we can do the same thing

00:35:39.906 --> 00:35:42.706 A:middle
with the buffers, and use those
as inputs to the vertex shader

00:35:42.746 --> 00:35:45.356 A:middle
and refer back to the
argument index table

00:35:45.466 --> 00:35:46.286 A:middle
and the command encoder.

00:35:46.726 --> 00:35:49.126 A:middle
So you set up the command
encoder's argument tables

00:35:49.336 --> 00:35:53.036 A:middle
with the API and simply
refer to those resources

00:35:53.466 --> 00:35:55.396 A:middle
in your shaders using
the attribute syntax

00:35:55.586 --> 00:35:56.946 A:middle
and function arguments
themselves.

00:35:57.306 --> 00:35:58.666 A:middle
And that's it.

00:35:59.206 --> 00:36:01.406 A:middle
The shading language is
actually pretty simple,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.206 --> 00:36:01.406 A:middle
The shading language is
actually pretty simple,

00:36:01.476 --> 00:36:03.156 A:middle
and we think you're
going to really like it.

00:36:03.566 --> 00:36:04.936 A:middle
And, next, I'm going
to talk about how

00:36:04.936 --> 00:36:07.126 A:middle
to build your Metal
application using our awesome

00:36:07.126 --> 00:36:07.966 A:middle
developer tools.

00:36:08.296 --> 00:36:09.826 A:middle
And probably the most important

00:36:09.826 --> 00:36:14.566 A:middle
of those developer tools is
the Metal shader complier.

00:36:15.726 --> 00:36:17.626 A:middle
Now, ideally, you don't
even know this exists

00:36:17.896 --> 00:36:20.426 A:middle
because we're simply going to
build your shader sources just

00:36:20.426 --> 00:36:22.396 A:middle
like we build the rest of
your application sources

00:36:22.516 --> 00:36:23.626 A:middle
at application build time.

00:36:24.006 --> 00:36:26.756 A:middle
There's no need for you to
separate out your shaders

00:36:26.756 --> 00:36:28.096 A:middle
and specify them at run time.

00:36:28.386 --> 00:36:29.736 A:middle
You can actually ship them

00:36:30.026 --> 00:36:32.826 A:middle
with your application already
having been precompiled.

00:36:32.826 --> 00:36:34.656 A:middle
So there's no source
code that needs to go

00:36:34.656 --> 00:36:36.836 A:middle
with your application
for your shaders.

00:36:37.176 --> 00:36:39.406 A:middle
But probably more important from
the developer's point of view is

00:36:39.406 --> 00:36:41.966 A:middle
that we can actually give you
errors and warnings and guidance

00:36:41.966 --> 00:36:44.116 A:middle
about your shaders at
the time you're building

00:36:44.116 --> 00:36:44.886 A:middle
your application.

00:36:45.106 --> 00:36:45.956 A:middle
So you don't have to wait

00:36:46.336 --> 00:36:49.186 A:middle
until your customers are
running your game to find

00:36:49.186 --> 00:36:50.746 A:middle
out that you have an error
in one of your shaders.

00:36:51.586 --> 00:36:52.136 A:middle
This is awesome.

00:36:53.436 --> 00:36:56.346 A:middle
Those shaders will then be
compiled into Metal libraries

00:36:56.346 --> 00:36:59.456 A:middle
by Xcode and then
compiled to device code

00:36:59.796 --> 00:37:02.046 A:middle
at the time you create your
state objects themselves.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.796 --> 00:37:02.046 A:middle
at the time you create your
state objects themselves.

00:37:02.416 --> 00:37:04.366 A:middle
So, again, there's no
draw time compilation,

00:37:05.276 --> 00:37:07.466 A:middle
and we will cache
this compilation,

00:37:07.546 --> 00:37:09.876 A:middle
this final device machine
specific compilation

00:37:10.676 --> 00:37:11.386 A:middle
on the device.

00:37:12.196 --> 00:37:15.106 A:middle
So we won't be continually doing
even this last translation step.

00:37:16.396 --> 00:37:19.436 A:middle
Now for those of you who like
to specify your source code

00:37:19.676 --> 00:37:22.006 A:middle
at run time, perhaps you're
constructing strings on the fly,

00:37:22.006 --> 00:37:24.226 A:middle
we do provide a runtime
shader compiler as well.

00:37:24.466 --> 00:37:26.196 A:middle
This can also be really
useful for debugging.

00:37:27.586 --> 00:37:29.876 A:middle
It, too, has no draw time
compilation overhead.

00:37:30.046 --> 00:37:32.376 A:middle
It operates just like
the precompile shaders,

00:37:32.916 --> 00:37:34.366 A:middle
but for best performance,

00:37:34.366 --> 00:37:36.656 A:middle
we generally recommend you
use the offline compiler.

00:37:36.826 --> 00:37:38.266 A:middle
We can give you the
most information

00:37:38.266 --> 00:37:40.646 A:middle
to help you build the
best possible shaders

00:37:40.646 --> 00:37:41.316 A:middle
if you do it this way.

00:37:41.946 --> 00:37:43.066 A:middle
Well, let's see what
this would look like.

00:37:43.346 --> 00:37:44.416 A:middle
So here's an example.

00:37:44.416 --> 00:37:47.656 A:middle
You're building your application
in Xcode, and you have a series

00:37:48.086 --> 00:37:52.226 A:middle
of Metal shader files, and
each shader files are passed

00:37:52.436 --> 00:37:54.696 A:middle
to the Metal shader
compiler, the compiler

00:37:54.696 --> 00:37:55.806 A:middle
or the Metal shader sources

00:37:55.916 --> 00:37:57.286 A:middle
at the time you build
your application,

00:37:57.536 --> 00:37:59.826 A:middle
and a Metal library
file is generated.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.656 --> 00:38:04.536 A:middle
That Metal library file will be
packaged with your application,

00:38:04.986 --> 00:38:08.036 A:middle
and so then when you deploy
your application to a device,

00:38:09.486 --> 00:38:11.436 A:middle
that Metal library file
goes along for the ride.

00:38:11.996 --> 00:38:13.306 A:middle
Then at application run time

00:38:13.306 --> 00:38:15.866 A:middle
when you're constructing
your pipeline objects,

00:38:16.506 --> 00:38:19.456 A:middle
you specify which vertex
and fragment shaders you'd

00:38:19.456 --> 00:38:21.656 A:middle
like to use from
that Metal library.

00:38:22.466 --> 00:38:25.056 A:middle
Metal implementation then will
look up those shaders to see

00:38:25.056 --> 00:38:27.616 A:middle
if it's already cached them
once before, and if not,

00:38:27.686 --> 00:38:30.206 A:middle
we'll compile them to the
final machine device code

00:38:31.226 --> 00:38:32.176 A:middle
and send it to the GPU.

00:38:32.666 --> 00:38:34.516 A:middle
And that's it.

00:38:34.946 --> 00:38:37.296 A:middle
Most of this happens
automatically for you, but,

00:38:37.296 --> 00:38:41.786 A:middle
critically, exactly
when you want it to.

00:38:41.996 --> 00:38:45.016 A:middle
Now if you've used our OpenGL
ES debugging tools and Xcode,

00:38:45.016 --> 00:38:46.366 A:middle
you're going to feel
right at home.

00:38:46.366 --> 00:38:49.606 A:middle
We have an awesome set of
GPU programming debugging

00:38:49.606 --> 00:38:52.026 A:middle
and profiling tools integrated
right into Xcode, and I'm going

00:38:52.526 --> 00:38:53.976 A:middle
to give you a quick
tour of those now.

00:38:54.496 --> 00:38:58.976 A:middle
So this is an example
application inside Xcode

00:38:58.976 --> 00:39:01.636 A:middle
where you get visual
debugging tools built right


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.976 --> 00:39:01.636 A:middle
where you get visual
debugging tools built right

00:39:01.636 --> 00:39:03.406 A:middle
in the same environment
you're using

00:39:03.406 --> 00:39:04.686 A:middle
to build the rest
of your application.

00:39:05.046 --> 00:39:07.866 A:middle
On the left-hand side, we
have what's called the frame

00:39:07.866 --> 00:39:11.516 A:middle
navigator, which shows you
exactly which Metal API calls,

00:39:11.516 --> 00:39:15.046 A:middle
draw calls you issued and
in what order they occurred,

00:39:15.506 --> 00:39:18.366 A:middle
and in the middle, you have
the frame navigator, or, sorry,

00:39:18.366 --> 00:39:21.316 A:middle
the frame buffer view where you
can actually see the results

00:39:21.316 --> 00:39:25.026 A:middle
of those draw calls and state
operations happening live

00:39:25.026 --> 00:39:26.226 A:middle
as you're constructing
your frame.

00:39:27.616 --> 00:39:30.106 A:middle
We also have the resource
view, where you can see all

00:39:30.106 --> 00:39:33.196 A:middle
of the textures, resources, data
buffers, everything you're using

00:39:33.196 --> 00:39:36.096 A:middle
to construct your frame,
inspect them, and make sure

00:39:36.096 --> 00:39:37.796 A:middle
that they're exactly
as you set them up.

00:39:38.226 --> 00:39:42.696 A:middle
And at the bottom, you can
see the Metal state inspector

00:39:42.696 --> 00:39:44.926 A:middle
where you can see all
of the API state and all

00:39:44.926 --> 00:39:47.996 A:middle
of the important bits of
control and information you have

00:39:48.386 --> 00:39:49.816 A:middle
about your application in Metal.

00:39:51.786 --> 00:39:55.516 A:middle
We also provide some
really fantastic profiling

00:39:55.516 --> 00:39:56.666 A:middle
and performance tools.

00:39:57.216 --> 00:39:58.326 A:middle
So in this example,

00:39:58.606 --> 00:39:59.976 A:middle
we're showing the Metal
performance report.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:01.056 --> 00:40:02.906 A:middle
You can see things
like your frame rate

00:40:03.246 --> 00:40:04.536 A:middle
or how much you're
using the GPU.

00:40:04.566 --> 00:40:09.236 A:middle
You can also see exactly which
shaders are the most expensive,

00:40:09.816 --> 00:40:12.496 A:middle
and you can see how much time
they're taking per frame.

00:40:13.206 --> 00:40:13.906 A:middle
This is awesome.

00:40:14.286 --> 00:40:16.886 A:middle
You can also see for
each of those shaders

00:40:17.256 --> 00:40:20.086 A:middle
in milliseconds how much time
they're taking as a whole,

00:40:20.646 --> 00:40:22.166 A:middle
but you can get a feel

00:40:22.166 --> 00:40:25.716 A:middle
for exactly what are the most
expensive lines of each shader.

00:40:25.716 --> 00:40:28.376 A:middle
So if you want to really
optimize your shaders,

00:40:28.576 --> 00:40:31.366 A:middle
you can find out which line
is taking up the most time

00:40:31.726 --> 00:40:33.926 A:middle
and focus in on that,
and this is all built

00:40:33.926 --> 00:40:36.186 A:middle
for you right inside of Xcode.

00:40:37.516 --> 00:40:42.526 A:middle
[ Applause ]

00:40:43.026 --> 00:40:43.676 A:middle
I'm glad you like it.

00:40:45.126 --> 00:40:47.436 A:middle
So you can also build
your shaders,

00:40:47.436 --> 00:40:48.646 A:middle
as we said, inside Xcode.

00:40:48.646 --> 00:40:49.876 A:middle
You can actually
edit them as well,

00:40:49.876 --> 00:40:51.976 A:middle
and you get all the
familiar syntax highlighting

00:40:52.246 --> 00:40:55.636 A:middle
and code completion, and you
get warnings and errors right

00:40:55.636 --> 00:40:56.786 A:middle
for you inside of Xcode, too.

00:40:57.346 --> 00:40:58.746 A:middle
We think this is
really fantastic.

00:40:58.746 --> 00:41:00.286 A:middle
It makes writing and editing


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.746 --> 00:41:00.286 A:middle
It makes writing and editing

00:41:00.286 --> 00:41:02.706 A:middle
and profiling shaders a
much more natural part

00:41:02.706 --> 00:41:04.516 A:middle
of the process, and
we've designed Metal

00:41:04.516 --> 00:41:06.806 A:middle
to work seamlessly
in this environment.

00:41:07.436 --> 00:41:11.046 A:middle
Alright. So that's the developer
tools, the API concepts,

00:41:11.046 --> 00:41:12.276 A:middle
and the shading language.

00:41:12.516 --> 00:41:15.656 A:middle
Now as you heard in the keynote,
we've been working with Metal,

00:41:16.486 --> 00:41:18.866 A:middle
some leading game
engine providers

00:41:19.416 --> 00:41:23.256 A:middle
such as Electronic Arts,
Epic, Unity, and Crytek,

00:41:23.726 --> 00:41:25.766 A:middle
and we've been amazed at what
they've been able to create

00:41:25.926 --> 00:41:27.256 A:middle
in just a short amount of time.

00:41:27.796 --> 00:41:29.496 A:middle
Well, I'm very happy
to introduce

00:41:29.496 --> 00:41:31.536 A:middle
up on stage Sean
Tracey from Crytek,

00:41:31.756 --> 00:41:33.746 A:middle
who's going to show you what
they've been able to create

00:41:33.746 --> 00:41:35.356 A:middle
with Metal in just a few weeks.

00:41:35.866 --> 00:41:36.076 A:middle
Sean.

00:41:37.456 --> 00:41:41.496 A:middle
&gt;&gt; Thanks a lot, Jeremy.

00:41:42.256 --> 00:41:44.176 A:middle
Crytek is known for
pushing the boundaries

00:41:44.806 --> 00:41:47.526 A:middle
and for developing
blockbuster hits such as Crysis

00:41:47.526 --> 00:41:48.676 A:middle
and Ryse for the consoles.

00:41:49.326 --> 00:41:51.716 A:middle
The CRYENGINE is going
mobile, and our latest game,

00:41:51.716 --> 00:41:53.986 A:middle
The Collectables, was recently
released on the App Store.

00:41:54.366 --> 00:41:57.186 A:middle
Integrating Metal into the
game gives us opportunities

00:41:57.186 --> 00:41:58.286 A:middle
that we didn't have before,

00:41:58.346 --> 00:42:01.026 A:middle
and the added performance
changes the way we think


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.346 --> 00:42:01.026 A:middle
and the added performance
changes the way we think

00:42:01.026 --> 00:42:03.646 A:middle
about creating mobile game
play and mobile game content.

00:42:04.346 --> 00:42:05.976 A:middle
Today, we'd like to show
you the next version

00:42:05.976 --> 00:42:08.446 A:middle
of The Collectibles, and to
show you how we use Metal

00:42:08.566 --> 00:42:09.546 A:middle
to change the game.

00:42:10.016 --> 00:42:10.586 A:middle
Let's take a look.

00:42:11.346 --> 00:42:15.446 A:middle
In The Collectibles, you control
a renegade team of mercenaries,

00:42:15.446 --> 00:42:17.476 A:middle
and today we're on a daring
hit-and-run mission to take

00:42:17.476 --> 00:42:18.536 A:middle
out the enemy artillery.

00:42:19.506 --> 00:42:21.966 A:middle
As you can see, the environment
is incredibly dynamic

00:42:22.456 --> 00:42:26.836 A:middle
and very rich with wind
affecting vegetation and more.

00:42:28.046 --> 00:42:29.726 A:middle
Looks like the enemy's
set up a roadblock ahead.

00:42:29.726 --> 00:42:31.546 A:middle
Let's take out these
jeeps with our RPGs.

00:42:33.746 --> 00:42:36.046 A:middle
So you can see this level

00:42:36.046 --> 00:42:38.296 A:middle
of cinematic destruction
simply wasn't possible

00:42:38.296 --> 00:42:39.086 A:middle
on mobile before.

00:42:39.376 --> 00:42:40.296 A:middle
When those jeeps explode,

00:42:40.296 --> 00:42:43.006 A:middle
there's over 168 unique
pieces that come flying off.

00:42:43.316 --> 00:42:45.436 A:middle
The tires, windshield,
engine block, and more.

00:42:46.666 --> 00:42:47.626 A:middle
Using the power of Metal,

00:42:47.626 --> 00:42:50.356 A:middle
we're able to leverage
our geom cache technology

00:42:50.666 --> 00:42:52.086 A:middle
as seen in Ryse on console.

00:42:53.026 --> 00:42:56.306 A:middle
And there it is, our
objective, the enemy artillery.

00:42:56.656 --> 00:42:57.736 A:middle
It's a pretty big mother.

00:42:57.736 --> 00:42:58.666 A:middle
So let's go ahead and call

00:42:58.666 --> 00:43:00.656 A:middle
in our AC130 gunship
for air support.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:58.666 --> 00:43:00.656 A:middle
in our AC130 gunship
for air support.

00:43:01.516 --> 00:43:07.466 A:middle
[ Background Sounds ]

00:43:07.966 --> 00:43:11.176 A:middle
Geom cache uses cache-based
animation

00:43:11.466 --> 00:43:14.806 A:middle
to realize extremely complex
simulation and special effects,

00:43:15.046 --> 00:43:16.926 A:middle
as you saw in the
destruction of those buildings.

00:43:18.376 --> 00:43:20.666 A:middle
So as our players make their
way to their next objective,

00:43:21.006 --> 00:43:22.426 A:middle
let's take a look
at another example

00:43:22.426 --> 00:43:26.146 A:middle
of how we can use this power
to turn the environment

00:43:26.296 --> 00:43:27.836 A:middle
into a weapon for our player.

00:43:28.346 --> 00:43:30.296 A:middle
Sounds like trouble ahead.

00:43:30.856 --> 00:43:31.786 A:middle
Yeah, they've got a tank.

00:43:31.786 --> 00:43:33.676 A:middle
Alright. We need to block off
that road and get out of here,

00:43:33.676 --> 00:43:34.506 A:middle
or we're going to be toast.

00:43:34.826 --> 00:43:35.826 A:middle
Let's try taking
out the chimney.

00:43:41.596 --> 00:43:43.726 A:middle
And that's how you stop a
tank in The Collectibles.

00:43:44.386 --> 00:43:45.836 A:middle
When that building
and chimney come down,

00:43:45.836 --> 00:43:48.216 A:middle
there's over 4,000
draw calls on screen,

00:43:48.456 --> 00:43:50.676 A:middle
4,000 draw calls on an iPad.

00:43:51.936 --> 00:43:54.796 A:middle
Ah, they've got another tank,
and we're out of chimneys.

00:43:54.856 --> 00:43:56.036 A:middle
So mission accomplished.

00:43:56.246 --> 00:43:56.836 A:middle
Let's get out of here.

00:43:59.186 --> 00:44:00.556 A:middle
As you can see, the
performance game


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.186 --> 00:44:00.556 A:middle
As you can see, the
performance game

00:44:00.616 --> 00:44:03.626 A:middle
with Metal gives us a
tenfold performance increase

00:44:03.846 --> 00:44:07.676 A:middle
that allows us to bring the
Crytek DNA alive on mobile.

00:44:08.266 --> 00:44:09.886 A:middle
We look forward to seeing
you guys in the game.

00:44:10.326 --> 00:44:10.976 A:middle
Thanks a lot.

00:44:11.516 --> 00:44:17.776 A:middle
[ Applause ]

00:44:18.276 --> 00:44:18.576 A:middle
&gt;&gt; Alright.

00:44:18.576 --> 00:44:19.206 A:middle
Thanks, Sean.

00:44:19.866 --> 00:44:20.906 A:middle
That's really amazing.

00:44:20.906 --> 00:44:23.776 A:middle
So 4,000 draw calls
is a tenfold increase

00:44:24.096 --> 00:44:26.116 A:middle
over what was previously
possible before Metal,

00:44:26.116 --> 00:44:28.606 A:middle
and we're are truly, truly
excited to see it in action.

00:44:29.936 --> 00:44:31.166 A:middle
Alright. So that's Metal.

00:44:31.456 --> 00:44:33.566 A:middle
Metal is our new low overhead,

00:44:33.836 --> 00:44:37.546 A:middle
high-performance GPU programming
API which can provide you

00:44:37.546 --> 00:44:40.316 A:middle
with dramatic increase
in efficiency

00:44:40.316 --> 00:44:41.416 A:middle
and performance for your game.

00:44:42.256 --> 00:44:46.356 A:middle
We've designed it from
scratch to run like a dream

00:44:46.356 --> 00:44:49.756 A:middle
on the A7 chip and
our iOS products.

00:44:50.346 --> 00:44:51.996 A:middle
And we've streamlined
the feature set

00:44:51.996 --> 00:44:55.636 A:middle
and the API footprint to focus
on the most modern GPU features

00:44:55.766 --> 00:44:57.376 A:middle
such as unified graphics
and compute,

00:44:57.626 --> 00:45:01.276 A:middle
and the most modern GPU game
programming techniques such,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:57.626 --> 00:45:01.276 A:middle
and the most modern GPU game
programming techniques such,

00:45:01.346 --> 00:45:04.666 A:middle
that require fine grain control
and efficient multi-threading.

00:45:05.396 --> 00:45:08.956 A:middle
With support for precompiled
shaders and a fantastic set

00:45:08.956 --> 00:45:11.546 A:middle
of developer tools, we
believe you're going to be able

00:45:11.546 --> 00:45:14.326 A:middle
to use Metal to create
an entirely new class

00:45:14.466 --> 00:45:16.716 A:middle
of games for your customers.

00:45:17.416 --> 00:45:19.226 A:middle
We're really looking forward
to what you guys are going

00:45:19.226 --> 00:45:20.736 A:middle
to be able to create with Metal.

00:45:20.876 --> 00:45:24.086 A:middle
We think it's just a truly,
truly fantastic thing.

00:45:24.606 --> 00:45:27.276 A:middle
For more information
about Metal,

00:45:27.776 --> 00:45:30.726 A:middle
you can come see our
Evangelists, Filip and Allan,

00:45:31.106 --> 00:45:33.916 A:middle
and we have an amazing set
of documentation about Metal

00:45:33.916 --> 00:45:35.306 A:middle
on our developer
relations website.

00:45:35.696 --> 00:45:37.826 A:middle
You can also check out
the developer forums

00:45:37.826 --> 00:45:40.726 A:middle
where you can talk with folks
about Metal, and you can come

00:45:41.026 --> 00:45:43.656 A:middle
to the next two sessions which
we're going to go into Metal

00:45:43.656 --> 00:45:45.286 A:middle
in a much more level of detail.

00:45:45.286 --> 00:45:48.386 A:middle
So you can see how Metal
works in your application,

00:45:48.386 --> 00:45:51.456 A:middle
how to build your first Metal
application, how to build scenes

00:45:51.456 --> 00:45:54.816 A:middle
out of Metal and use
it to control the GPU,

00:45:54.816 --> 00:45:56.626 A:middle
how the Metal shading
language itself works,

00:45:57.106 --> 00:45:58.546 A:middle
and then we'll have
a second session

00:45:58.676 --> 00:46:00.726 A:middle
where we cover some
more advanced techniques


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.676 --> 00:46:00.726 A:middle
where we cover some
more advanced techniques

00:46:01.026 --> 00:46:03.426 A:middle
such as using multi-pass
Rendering and Compute.

00:46:04.306 --> 00:46:06.376 A:middle
We're really looking forward
to what you're going to be able

00:46:06.376 --> 00:46:07.956 A:middle
to create with this API.

00:46:07.956 --> 00:46:08.976 A:middle
Thank you very much for coming.

