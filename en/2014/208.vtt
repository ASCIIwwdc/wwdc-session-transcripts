WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:13.236 --> 00:00:14.526 A:middle
&gt;&gt; My name is Olivier Bonnet.

00:00:14.526 --> 00:00:18.266 A:middle
I'm the engineering manager for
the CloudKit on the client side.

00:00:20.536 --> 00:00:25.976 A:middle
So, up until today Apple
had many iCloud technologies

00:00:25.976 --> 00:00:28.266 A:middle
and they looked like
this to you.

00:00:28.426 --> 00:00:31.666 A:middle
We had iCloud Drive, iCloud
Core Data, iCloud file Library

00:00:31.976 --> 00:00:33.736 A:middle
and how they interacted
with the iCloud,

00:00:34.526 --> 00:00:36.996 A:middle
the Apple iCloud server
was kind of a mystery.

00:00:37.286 --> 00:00:42.276 A:middle
So today we're lifting
some of the mystery

00:00:42.276 --> 00:00:43.576 A:middle
in introducing CloudKit.

00:00:45.056 --> 00:00:47.336 A:middle
So let's look at
what we're going

00:00:47.336 --> 00:00:49.816 A:middle
to cover here in this session.

00:00:49.866 --> 00:00:53.686 A:middle
First we're going to start
with what is CloudKit.

00:00:55.566 --> 00:00:58.996 A:middle
We're going to walk you through
the couple of steps you need

00:00:58.996 --> 00:01:01.466 A:middle
to enable CloudKit in your
application and start using it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:58.996 --> 00:01:01.466 A:middle
to enable CloudKit in your
application and start using it.

00:01:02.806 --> 00:01:05.996 A:middle
We're going to do a walkthrough
of the different APIs,

00:01:06.676 --> 00:01:10.266 A:middle
we're going to talk about
how CloudKit interacts

00:01:10.266 --> 00:01:15.406 A:middle
with the Apple, the iCloud
user accounts and last

00:01:15.406 --> 00:01:18.786 A:middle
but not least we'll cover when
to use CloudKit as opposed

00:01:18.786 --> 00:01:23.426 A:middle
to other existing iCloud APIs we
already have on the platforms.

00:01:25.356 --> 00:01:26.416 A:middle
So let's start.

00:01:26.416 --> 00:01:27.286 A:middle
What is CloudKit?

00:01:28.576 --> 00:01:31.686 A:middle
You'll notice the new batch
but the whole session is new

00:01:31.786 --> 00:01:33.626 A:middle
so it's share only
on that slide.

00:01:35.566 --> 00:01:38.276 A:middle
[Laughter] CloudKit is
a way to give you access

00:01:38.276 --> 00:01:42.396 A:middle
to iCloud servers and
we really mean it.

00:01:42.806 --> 00:01:46.206 A:middle
CloudKit is the foundation
for both iCloud Drive

00:01:46.466 --> 00:01:47.736 A:middle
and iCloud file Library.

00:01:48.346 --> 00:01:51.586 A:middle
Those features were written
from scratch on top of CloudKit.

00:01:52.936 --> 00:01:55.936 A:middle
CloudKit is supported
on both OS 10 and iOS.

00:01:56.006 --> 00:01:58.966 A:middle
It's a new public
framework, cloudkit.framework.

00:01:59.436 --> 00:02:01.326 A:middle
Check it out in SDK.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.436 --> 00:02:01.326 A:middle
Check it out in SDK.

00:02:02.596 --> 00:02:05.826 A:middle
CloudKit uses the iCloud
accounts infrastructure.

00:02:05.826 --> 00:02:10.376 A:middle
That means that if there's
a logged in iCloud account

00:02:10.376 --> 00:02:14.656 A:middle
on the device we'll use
that to identify the user.

00:02:15.196 --> 00:02:18.766 A:middle
If there's none, we'll provide
read only anonymous access.

00:02:20.006 --> 00:02:24.116 A:middle
CloudKit supports both a concept
of public and private databases.

00:02:24.116 --> 00:02:26.776 A:middle
You can see public
databases as a soup

00:02:26.776 --> 00:02:30.126 A:middle
of data that's all your
user can access to.

00:02:30.986 --> 00:02:36.796 A:middle
Private databases are meant
to store the actual data just

00:02:36.796 --> 00:02:38.296 A:middle
on behalf of a specific user.

00:02:41.136 --> 00:02:43.946 A:middle
CloudKit support both
structured and bulk data.

00:02:44.366 --> 00:02:48.646 A:middle
You can use it to store
large files on iCloud servers

00:02:48.646 --> 00:02:51.936 A:middle
and we'll take care of
transmitting them efficiently

00:02:52.286 --> 00:02:54.646 A:middle
from the iCloud servers.

00:02:55.926 --> 00:02:59.546 A:middle
Importantly CloudKit is
a transport technology.

00:02:59.776 --> 00:03:02.356 A:middle
It doesn't provide
any local persistence.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.776 --> 00:03:02.356 A:middle
It doesn't provide
any local persistence.

00:03:02.476 --> 00:03:06.946 A:middle
It enables you to send and
receive data from the servers.

00:03:08.766 --> 00:03:09.506 A:middle
So let's start.

00:03:09.696 --> 00:03:12.526 A:middle
How do you enable CloudKit
in your application?

00:03:12.766 --> 00:03:16.956 A:middle
So first you'll want to navigate
your application's capabilities,

00:03:16.956 --> 00:03:18.006 A:middle
pane and X code.

00:03:18.236 --> 00:03:21.056 A:middle
See that big iCloud off switch?

00:03:21.056 --> 00:03:24.266 A:middle
You want to turn
it on and you want

00:03:24.266 --> 00:03:28.056 A:middle
to check the CloudKit
checkbox here.

00:03:28.746 --> 00:03:29.806 A:middle
At that point you're ready.

00:03:30.026 --> 00:03:30.986 A:middle
There's no fourth step.

00:03:32.646 --> 00:03:35.166 A:middle
Your app is ready to
read and write data

00:03:35.206 --> 00:03:39.776 A:middle
to Apple's iCloud server and to
walk you through the API on how

00:03:39.776 --> 00:03:43.656 A:middle
to do this I'm going to hand
over to Paul to chat about it.

00:03:43.656 --> 00:03:43.723 A:middle
[Applause]

00:03:43.723 --> 00:03:44.476 A:middle
&gt;&gt; All right.

00:03:45.156 --> 00:03:45.866 A:middle
Thank you, Olivier.

00:03:46.516 --> 00:03:49.996 A:middle
[ Applause ]

00:03:50.496 --> 00:03:52.156 A:middle
So, as Olivier said,
my name is Paul.

00:03:52.156 --> 00:03:54.966 A:middle
I work on the CloudKit client
framework, and I'm very excited

00:03:54.966 --> 00:03:57.276 A:middle
to talk to you guys
today about CloudKit.

00:03:57.356 --> 00:03:59.446 A:middle
We're going to start off
we're going to start talking

00:03:59.446 --> 00:04:01.746 A:middle
about the fundamental
CloudKit objects.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.446 --> 00:04:01.746 A:middle
about the fundamental
CloudKit objects.

00:04:01.796 --> 00:04:03.206 A:middle
These are going to
be the set of objects

00:04:03.206 --> 00:04:05.336 A:middle
that you're initially
exposed to when you open up

00:04:05.336 --> 00:04:06.986 A:middle
and start playing with
the CloudKit framework.

00:04:07.976 --> 00:04:10.016 A:middle
Just running through a quick
list of them we're going to talk

00:04:10.016 --> 00:04:12.616 A:middle
about containers and we're
going to talk about databases,

00:04:12.976 --> 00:04:15.396 A:middle
we're going to talk about
records, we're going to talk

00:04:15.396 --> 00:04:19.706 A:middle
about record zones
and RecordIDentifiers,

00:04:20.196 --> 00:04:21.555 A:middle
we're going to talk
about references

00:04:21.555 --> 00:04:23.126 A:middle
and we're going to
talk about assets.

00:04:23.126 --> 00:04:23.766 A:middle
It's quite a list.

00:04:23.766 --> 00:04:26.886 A:middle
This is going to be a really fun
and really jam-packed session.

00:04:27.226 --> 00:04:31.046 A:middle
So let's get started and we're
going to talk about containers.

00:04:31.786 --> 00:04:33.876 A:middle
This is sort of the
idealized model

00:04:34.106 --> 00:04:36.656 A:middle
of your application
talking about iCloud.

00:04:36.656 --> 00:04:39.706 A:middle
Now you guys are
application developers,

00:04:39.706 --> 00:04:42.046 A:middle
you guys are client
developers, and you know

00:04:42.046 --> 00:04:44.856 A:middle
that your application
running on a client whether

00:04:44.856 --> 00:04:46.216 A:middle
that client is a iPhone

00:04:46.276 --> 00:04:49.556 A:middle
or whether it be a Mac Book
yours is not the only process

00:04:49.556 --> 00:04:50.446 A:middle
running on that client.

00:04:50.876 --> 00:04:52.106 A:middle
Rather yours is one of many.

00:04:52.906 --> 00:04:56.486 A:middle
Now on your client your
process is going to be siloed,

00:04:56.486 --> 00:04:57.926 A:middle
sandboxed in some ways.

00:04:58.616 --> 00:05:02.206 A:middle
In some cases, it's
a literal sandbox.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.616 --> 00:05:02.206 A:middle
In some cases, it's
a literal sandbox.

00:05:02.236 --> 00:05:03.166 A:middle
Certainly in others
you're running

00:05:03.166 --> 00:05:04.326 A:middle
in your own memory space.

00:05:05.006 --> 00:05:06.926 A:middle
This concept of taking
your client

00:05:06.926 --> 00:05:08.666 A:middle
and actually running
it separated

00:05:08.666 --> 00:05:10.656 A:middle
from other clients
is pretty powerful.

00:05:10.656 --> 00:05:12.176 A:middle
It has got a couple
of advantages.

00:05:12.326 --> 00:05:15.256 A:middle
It helps with security,
it helps with stability

00:05:15.256 --> 00:05:16.646 A:middle
and it helps with privacy.

00:05:17.506 --> 00:05:20.536 A:middle
So as we are figuring out how
we wanted to build CloudKit,

00:05:20.586 --> 00:05:23.456 A:middle
we thought to ourselves how can
we take these three advantages

00:05:23.846 --> 00:05:25.336 A:middle
and replicate them
up in the server?

00:05:25.336 --> 00:05:28.026 A:middle
So here's what we did.

00:05:28.026 --> 00:05:30.836 A:middle
Just as your client is
one of many, I'm sorry,

00:05:30.936 --> 00:05:33.076 A:middle
your application is one of
many running on the client,

00:05:33.516 --> 00:05:35.806 A:middle
so too the part of
iCloud that you're talking

00:05:35.806 --> 00:05:39.056 A:middle
to is one of many up on iCloud.

00:05:39.096 --> 00:05:41.016 A:middle
We call these different
silos containers.

00:05:41.646 --> 00:05:43.966 A:middle
So containers.

00:05:44.456 --> 00:05:46.566 A:middle
Containers are exposed
in the CloudKit framework

00:05:46.566 --> 00:05:48.556 A:middle
as the CKContainer class.

00:05:48.556 --> 00:05:49.626 A:middle
CK is our prefix
and you're going

00:05:49.626 --> 00:05:51.326 A:middle
to see this all over the place.

00:05:51.466 --> 00:05:54.146 A:middle
By default one application
talks to one container.

00:05:55.546 --> 00:05:58.336 A:middle
Containers afford us the
ability to segregate data.

00:05:58.866 --> 00:06:01.306 A:middle
That means that your application
can read and write data


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.866 --> 00:06:01.306 A:middle
That means that your application
can read and write data

00:06:01.306 --> 00:06:03.856 A:middle
to iCloud, another application
can read and write data

00:06:03.856 --> 00:06:05.586 A:middle
to iCloud and the two datasets

00:06:05.586 --> 00:06:07.326 A:middle
up on the server will
not be intermingled.

00:06:08.256 --> 00:06:11.986 A:middle
In addition to data segregation,
this containerization

00:06:11.986 --> 00:06:15.876 A:middle
of iCloud storage allows us to
encapsulate user information.

00:06:16.626 --> 00:06:17.876 A:middle
Now as Olivier mentioned,

00:06:18.226 --> 00:06:21.776 A:middle
CloudKit involves using the
iCloud account infrastructure

00:06:22.266 --> 00:06:24.496 A:middle
and we want to give
you some limited access

00:06:24.556 --> 00:06:26.896 A:middle
to that iCloud account
and we want to make sure

00:06:26.896 --> 00:06:29.816 A:middle
that we're doing so in a
privacy conscientious manner.

00:06:30.436 --> 00:06:33.486 A:middle
So in order to do that, we
encapsulate user information.

00:06:33.946 --> 00:06:36.406 A:middle
User information available
to your application is going

00:06:36.406 --> 00:06:38.116 A:middle
to be container scoped
and, therefore,

00:06:38.116 --> 00:06:41.416 A:middle
different than the view
of user information seen

00:06:41.416 --> 00:06:42.456 A:middle
by another application.

00:06:43.896 --> 00:06:46.076 A:middle
Containers are managed
by you the developer.

00:06:46.076 --> 00:06:49.256 A:middle
You're going to be managing
them via the WWDR portal.

00:06:50.186 --> 00:06:52.796 A:middle
It's important to note
that the name space

00:06:52.796 --> 00:06:55.616 A:middle
of containers is
global to all developers

00:06:55.966 --> 00:06:58.046 A:middle
so when you're choosing a name
for your container make sure

00:06:58.046 --> 00:06:59.366 A:middle
that you're using
it in a reverse,

00:06:59.406 --> 00:07:01.706 A:middle
you're using a reverse DNS name.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.406 --> 00:07:01.706 A:middle
you're using a reverse DNS name.

00:07:02.986 --> 00:07:06.606 A:middle
Now, right up there just like
a little while ago I said

00:07:06.606 --> 00:07:08.876 A:middle
that by default there
is one container

00:07:08.876 --> 00:07:10.736 A:middle
to one application,
a one to one mapping.

00:07:11.406 --> 00:07:14.486 A:middle
We think this is going to be
successful for 99% of use cases

00:07:14.756 --> 00:07:17.126 A:middle
and certainly as you go and
start using CloudKit it's going

00:07:17.126 --> 00:07:18.896 A:middle
to be great as you start
exploring the framework.

00:07:19.316 --> 00:07:21.566 A:middle
We recognize that there
are some scenarios

00:07:21.566 --> 00:07:23.386 A:middle
where you need a
more complex mapping

00:07:23.716 --> 00:07:25.426 A:middle
so we support a many
to many model.

00:07:25.526 --> 00:07:29.166 A:middle
What we mean is that multiple
applications can coordinate

00:07:29.166 --> 00:07:31.026 A:middle
on the same iCloud container.

00:07:32.046 --> 00:07:34.006 A:middle
Also a single application
can talk

00:07:34.006 --> 00:07:35.496 A:middle
to multiple iCloud containers.

00:07:38.306 --> 00:07:39.266 A:middle
On to databases.

00:07:40.226 --> 00:07:42.686 A:middle
One of the chief purposes
of CloudKit is the ability

00:07:42.686 --> 00:07:45.516 A:middle
to take your object model in
your application and replicate

00:07:45.516 --> 00:07:46.356 A:middle
that up to the server.

00:07:46.786 --> 00:07:49.206 A:middle
So when we start
thinking about how we want

00:07:49.206 --> 00:07:51.436 A:middle
to present this modeling
to you we thought

00:07:51.436 --> 00:07:54.486 A:middle
to ourselves how can we
divide up application objects?

00:07:54.486 --> 00:07:55.706 A:middle
Obviously all objects

00:07:55.706 --> 00:07:57.776 A:middle
in my application are
not treated equally.

00:07:58.536 --> 00:08:01.116 A:middle
One of the first things that we
notice was there's a fundamental


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.536 --> 00:08:01.116 A:middle
One of the first things that we
notice was there's a fundamental

00:08:01.116 --> 00:08:03.796 A:middle
difference in the
audience of data.

00:08:04.576 --> 00:08:08.246 A:middle
Some data is intended to be used
by the user that created it.

00:08:08.736 --> 00:08:11.136 A:middle
If you imagine an application
where I'm writing up notes

00:08:11.136 --> 00:08:13.236 A:middle
and I want to see my notes
everywhere else, that's my data.

00:08:13.276 --> 00:08:15.576 A:middle
I create it, I consume it.

00:08:15.956 --> 00:08:19.386 A:middle
On the other hand, there's use
for what we call public data.

00:08:19.816 --> 00:08:23.026 A:middle
This is data that can be,
a, created by the user

00:08:23.026 --> 00:08:24.316 A:middle
for the benefit of a community;

00:08:24.686 --> 00:08:26.856 A:middle
think perhaps a review
on a restaurant.

00:08:27.676 --> 00:08:29.916 A:middle
Or it could be information that
you the developer has uploaded

00:08:29.916 --> 00:08:32.265 A:middle
to iCloud because it's
useful to your application.

00:08:33.025 --> 00:08:35.736 A:middle
In either case, the audience
is not just a single user

00:08:35.736 --> 00:08:36.686 A:middle
but a community of people.

00:08:37.395 --> 00:08:38.895 A:middle
So how did we solve the fact

00:08:38.895 --> 00:08:40.756 A:middle
that we've got these
different types of data.

00:08:41.346 --> 00:08:43.306 A:middle
Let's break open a container
and have a look inside.

00:08:44.186 --> 00:08:46.596 A:middle
Inside of a container
you're going to notice first

00:08:46.596 --> 00:08:48.026 A:middle
and foremost the
public database.

00:08:48.026 --> 00:08:50.236 A:middle
This is the soup, this is
where all of the public

00:08:50.236 --> 00:08:52.886 A:middle
and communal data
co-lives, co-mingles.

00:08:53.946 --> 00:08:55.036 A:middle
Additionally, you're
going to notice

00:08:55.036 --> 00:08:57.366 A:middle
that there's private databases
and you're going to find

00:08:57.366 --> 00:08:59.076 A:middle
that there's an individual
private database

00:08:59.076 --> 00:09:00.716 A:middle
for each user of
your application.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.076 --> 00:09:00.716 A:middle
for each user of
your application.

00:09:01.436 --> 00:09:03.836 A:middle
Now this is sort of the
50,000 foot overview

00:09:03.836 --> 00:09:05.466 A:middle
of what the iCloud
infrastructure looks like,

00:09:05.606 --> 00:09:07.866 A:middle
but you know, how much do
you guys care about that?

00:09:08.186 --> 00:09:09.186 A:middle
What you guys are interested

00:09:09.186 --> 00:09:11.156 A:middle
in is what does this
infrastructure look

00:09:11.156 --> 00:09:13.726 A:middle
like to me the client running
on a phone or running on a Mac.

00:09:14.736 --> 00:09:16.196 A:middle
Obviously you're only
going to have access

00:09:16.196 --> 00:09:18.026 A:middle
to the currently
logged in iCloud user.

00:09:18.216 --> 00:09:20.246 A:middle
So rather than seeing
a public database

00:09:20.246 --> 00:09:22.926 A:middle
and a gajillion private
databases, your view is going

00:09:22.926 --> 00:09:24.116 A:middle
to look a little
bit more like this.

00:09:24.256 --> 00:09:26.196 A:middle
You're going to have a choice
between a public database

00:09:26.656 --> 00:09:28.486 A:middle
or the private database
that is correlated

00:09:28.486 --> 00:09:30.006 A:middle
to the currently
logged in iCloud user.

00:09:31.096 --> 00:09:32.556 A:middle
So databases.

00:09:33.096 --> 00:09:36.606 A:middle
Databases are exposed in our
API as a CK database class.

00:09:37.176 --> 00:09:38.866 A:middle
Every application has
access to two of them,

00:09:39.266 --> 00:09:40.516 A:middle
the public and the private.

00:09:41.376 --> 00:09:44.266 A:middle
Let's have a look at
a little bit of code.

00:09:44.556 --> 00:09:47.206 A:middle
The container is the initial
entry point into CloudKit.

00:09:47.726 --> 00:09:49.726 A:middle
Here we see that I am talking
to my default container

00:09:50.066 --> 00:09:51.496 A:middle
and getting its public database.

00:09:51.876 --> 00:09:53.276 A:middle
I can also talk to
the default container

00:09:53.276 --> 00:09:54.476 A:middle
and get it to private database.

00:09:55.186 --> 00:09:56.296 A:middle
Let's have a look
at the differences

00:09:56.296 --> 00:09:57.646 A:middle
between these 2 databases.

00:09:58.396 --> 00:10:01.166 A:middle
As we mentioned, the
desired audience is going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.396 --> 00:10:01.166 A:middle
As we mentioned, the
desired audience is going

00:10:01.166 --> 00:10:02.906 A:middle
to be different between
the public database

00:10:02.906 --> 00:10:03.796 A:middle
and the private database.

00:10:03.836 --> 00:10:06.476 A:middle
The public db is for shared
data, the private db is

00:10:06.476 --> 00:10:07.386 A:middle
for the user's own data.

00:10:08.586 --> 00:10:11.116 A:middle
As such, we have different
requirements for whether

00:10:11.116 --> 00:10:13.756 A:middle
or not an iCloud account
needs to exist on the client.

00:10:14.566 --> 00:10:16.766 A:middle
In the private database,
since I am reading

00:10:16.766 --> 00:10:19.566 A:middle
and writing a user's data if
we have no notion of the user,

00:10:19.696 --> 00:10:23.206 A:middle
that is if we don't have a login
iCloud account there's really no

00:10:23.206 --> 00:10:24.806 A:middle
utility in moving
this information

00:10:24.806 --> 00:10:26.336 A:middle
to and from the server.

00:10:26.656 --> 00:10:29.336 A:middle
So we require an iCloud account
to be logged in if you want

00:10:29.336 --> 00:10:30.446 A:middle
to use the private database.

00:10:30.996 --> 00:10:33.446 A:middle
In the public database since
the audience is more communal,

00:10:33.686 --> 00:10:37.086 A:middle
we allow you read only anonymous
access to the public database.

00:10:40.466 --> 00:10:42.796 A:middle
You'll recall from
yesterday's talk

00:10:42.876 --> 00:10:45.476 A:middle
that CloudKit is
free with Linux.

00:10:45.846 --> 00:10:48.816 A:middle
So we've got some
pretty aggressive quotas.

00:10:49.266 --> 00:10:50.826 A:middle
That being said we
still need to account

00:10:50.886 --> 00:10:53.846 A:middle
for where data is being used
so that we can talk to you

00:10:53.846 --> 00:10:55.516 A:middle
when we start approaching
those limits.

00:10:56.086 --> 00:10:59.086 A:middle
Data stored in the public
database is accounted

00:10:59.086 --> 00:11:00.196 A:middle
for on the developer's quota.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.086 --> 00:11:00.196 A:middle
for on the developer's quota.

00:11:00.416 --> 00:11:02.226 A:middle
Date stored in the private
database is accounted

00:11:02.226 --> 00:11:03.126 A:middle
for on the user's quota.

00:11:04.256 --> 00:11:07.066 A:middle
By default data written
into the public database is

00:11:07.066 --> 00:11:07.776 A:middle
world readable.

00:11:08.466 --> 00:11:10.796 A:middle
Data written to the private
database is user readable.

00:11:10.986 --> 00:11:13.636 A:middle
Again it's the user's own data
so they're really the only ones

00:11:13.636 --> 00:11:15.586 A:middle
to have access to it in
the private database.

00:11:16.756 --> 00:11:20.816 A:middle
We recognize that world readable
is not an appropriate permission

00:11:20.816 --> 00:11:22.606 A:middle
for a lot of data in
the public database

00:11:22.926 --> 00:11:25.416 A:middle
so we give you the ability
to edit these permissions

00:11:25.416 --> 00:11:27.456 A:middle
on a record class level.

00:11:28.306 --> 00:11:31.126 A:middle
The mechanism by which you edit
these permissions is something

00:11:31.126 --> 00:11:33.376 A:middle
that we call the
iCloud Dashboard roles.

00:11:33.946 --> 00:11:36.286 A:middle
iCloud Dashboard is the
administrative interface

00:11:36.346 --> 00:11:37.306 A:middle
into CloudKit.

00:11:37.926 --> 00:11:39.696 A:middle
I invite you guys to
come back on Thursday

00:11:39.746 --> 00:11:40.536 A:middle
for the advanced talk.

00:11:40.536 --> 00:11:43.246 A:middle
We're going to go into a lot
of detail about the dashboard.

00:11:43.926 --> 00:11:46.446 A:middle
Suffice it to say there's
an ability to set ACLs

00:11:46.726 --> 00:11:48.926 A:middle
so that a user is
a member of a role

00:11:49.376 --> 00:11:52.356 A:middle
and a role can have
certain enlarged access

00:11:52.356 --> 00:11:53.436 A:middle
to a class of records.

00:11:54.246 --> 00:11:56.396 A:middle
In the private database,
things start

00:11:56.396 --> 00:11:58.136 A:middle
out in lockdown there's
no need to edit them.

00:11:58.236 --> 00:12:00.036 A:middle
The user is the only
one to create data


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.236 --> 00:12:00.036 A:middle
The user is the only
one to create data

00:12:00.036 --> 00:12:01.966 A:middle
and the user is the only one
to be able to read that data.

00:12:02.506 --> 00:12:04.856 A:middle
When I say that the user is
the only one to be able to read

00:12:04.856 --> 00:12:06.136 A:middle
that data, I really mean it.

00:12:06.226 --> 00:12:08.836 A:middle
You as the developer
do not have access

00:12:08.836 --> 00:12:10.456 A:middle
into somebody else's
private database.

00:12:10.606 --> 00:12:11.536 A:middle
Their data is their own.

00:12:11.536 --> 00:12:14.546 A:middle
All right so those
are databases.

00:12:14.906 --> 00:12:15.896 A:middle
Let's talk about records.

00:12:17.376 --> 00:12:19.946 A:middle
So, here's our model
that we have so far.

00:12:19.946 --> 00:12:22.246 A:middle
We've got a container, within
containers are databases.

00:12:22.246 --> 00:12:24.696 A:middle
Let's keep going down the rabbit
hole and crack open a database.

00:12:25.096 --> 00:12:27.326 A:middle
Inside the database we see
that it's full of records.

00:12:29.086 --> 00:12:32.056 A:middle
Records are exposed in our
framework as the CKRecord class.

00:12:32.196 --> 00:12:35.156 A:middle
They are the mechanism by which
you've moved structured data

00:12:35.226 --> 00:12:36.406 A:middle
to and from CloudKit.

00:12:37.816 --> 00:12:41.536 A:middle
CKRecords wrap key value pairs.

00:12:41.626 --> 00:12:44.316 A:middle
Lest you think that a CKRecord
is just a glorified dictionary,

00:12:44.316 --> 00:12:45.486 A:middle
there are some additional
attributes

00:12:45.486 --> 00:12:47.816 A:middle
that make it worthwhile
of being in its own class.

00:12:47.866 --> 00:12:49.916 A:middle
To start off with records
have a record type.

00:12:50.726 --> 00:12:53.326 A:middle
If CloudKit is a mechanism by
which you take your object graph

00:12:53.326 --> 00:12:55.406 A:middle
from your application and
move it into CloudKit,

00:12:55.816 --> 00:12:57.126 A:middle
then let's continue
with that analogy.

00:12:57.586 --> 00:13:00.416 A:middle
An instance of an object in
your application is equivalent


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:57.586 --> 00:13:00.416 A:middle
An instance of an object in
your application is equivalent

00:13:00.466 --> 00:13:02.386 A:middle
to an instance of a CKRecord.

00:13:02.936 --> 00:13:05.006 A:middle
Similarly the class
of the object

00:13:05.006 --> 00:13:07.076 A:middle
in your application
is equivalent

00:13:07.076 --> 00:13:08.886 A:middle
to the record type
of the CKRecord.

00:13:11.286 --> 00:13:12.976 A:middle
Records have a just
in time schema.

00:13:13.196 --> 00:13:16.726 A:middle
You do not need to tell CloudKit
about what your data looks

00:13:16.826 --> 00:13:18.866 A:middle
like before you hand
CloudKit your data.

00:13:19.686 --> 00:13:23.076 A:middle
Hand us your data and
we'll figure it out.

00:13:23.966 --> 00:13:27.046 A:middle
CloudKit, excuse me,
CKRecord also supports a raft

00:13:27.046 --> 00:13:28.156 A:middle
of metadata.

00:13:28.466 --> 00:13:30.636 A:middle
For example, a record
understands

00:13:30.636 --> 00:13:32.296 A:middle
when it was created
and who created it.

00:13:32.896 --> 00:13:35.246 A:middle
It understands when a
record was last modified

00:13:35.246 --> 00:13:36.976 A:middle
and who last modified it.

00:13:36.976 --> 00:13:40.016 A:middle
Lastly a record contains
a notion of a change tag.

00:13:40.016 --> 00:13:42.596 A:middle
A change tag is a
version of a record.

00:13:42.596 --> 00:13:45.246 A:middle
It represents a specific
revision of this record.

00:13:45.686 --> 00:13:47.836 A:middle
It's use so that we can
have a lightweight way

00:13:47.836 --> 00:13:50.286 A:middle
of determining whether or not
a client server had the same

00:13:50.286 --> 00:13:51.106 A:middle
version of a record.

00:13:51.746 --> 00:13:55.756 A:middle
Let's talk a little bit
about record values,

00:13:55.756 --> 00:13:57.406 A:middle
CKRecords wrap key value pairs.

00:13:57.806 --> 00:13:59.596 A:middle
What are the acceptable
value types

00:13:59.596 --> 00:14:01.046 A:middle
that you can put
into a CKRecord?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.596 --> 00:14:01.046 A:middle
that you can put
into a CKRecord?

00:14:01.736 --> 00:14:04.646 A:middle
Well, we've got your usual
suspects, your P list types,

00:14:04.646 --> 00:14:07.646 A:middle
your strings, your numbers,
your datas and your dates.

00:14:07.716 --> 00:14:09.476 A:middle
We think that especially

00:14:09.476 --> 00:14:11.636 A:middle
in the public database
domain location is an

00:14:11.636 --> 00:14:12.466 A:middle
interesting scenario.

00:14:12.736 --> 00:14:16.246 A:middle
So, CLLocation is a native type
that you can set on a CKRecord.

00:14:17.686 --> 00:14:20.336 A:middle
You can set CKReferences and
CKAssets and we're going to go

00:14:20.336 --> 00:14:21.596 A:middle
over what those are
in just a moment.

00:14:22.846 --> 00:14:25.206 A:middle
Lastly any value can
be a single instance.

00:14:25.206 --> 00:14:29.006 A:middle
I can have a string or a date
or it can be a homogenous array.

00:14:29.256 --> 00:14:32.536 A:middle
I can have an array of numbers
or an array of CKAssets.

00:14:32.536 --> 00:14:37.686 A:middle
Let's have a look at
a little bit of code.

00:14:38.206 --> 00:14:39.746 A:middle
Here we see a CKRecord.

00:14:39.826 --> 00:14:41.676 A:middle
The CKRecord Initializer
takes a record type

00:14:41.676 --> 00:14:44.256 A:middle
because that's an invaluable
and necessary piece of a record.

00:14:44.976 --> 00:14:47.806 A:middle
You can set objects
and get objects

00:14:47.806 --> 00:14:49.506 A:middle
from a record using
a dictionary syntax

00:14:49.696 --> 00:14:51.836 A:middle
or a keyed subscripting syntax.

00:14:52.486 --> 00:14:55.026 A:middle
We also give you the ability to
enumerate all keys on a record

00:14:55.336 --> 00:14:57.926 A:middle
so that you can dump the
entire key value pair.

00:14:57.926 --> 00:15:00.886 A:middle
Let's have a look at
a specific example.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:57.926 --> 00:15:00.886 A:middle
Let's have a look at
a specific example.

00:15:01.596 --> 00:15:03.326 A:middle
Now, throughout this
talk my example is going

00:15:03.326 --> 00:15:05.806 A:middle
to be an application that I've
created for me and my friends.

00:15:05.996 --> 00:15:09.016 A:middle
This application allows us to
create parties and we're going

00:15:09.016 --> 00:15:11.546 A:middle
to stick party records
in the public database.

00:15:11.546 --> 00:15:13.776 A:middle
A party might be a
structured data it's going

00:15:13.776 --> 00:15:15.536 A:middle
to have a summary, a
start date and end date

00:15:15.536 --> 00:15:17.846 A:middle
and it might also have
additional metadata

00:15:17.846 --> 00:15:19.016 A:middle
that we associate with it,

00:15:19.256 --> 00:15:20.576 A:middle
pictures of the party,
et cetera.

00:15:21.746 --> 00:15:23.716 A:middle
So, how do I create
a party record?

00:15:24.246 --> 00:15:26.016 A:middle
Well I create one just
as you might imagine

00:15:26.016 --> 00:15:28.176 A:middle
with a party record type.

00:15:28.896 --> 00:15:31.276 A:middle
I can now set values on
it and I can read values

00:15:31.276 --> 00:15:34.536 A:middle
from it using the dictionary
or key subscripting syntax.

00:15:35.226 --> 00:15:35.986 A:middle
Those are records.

00:15:36.756 --> 00:15:38.156 A:middle
Let's talk about record zones.

00:15:38.596 --> 00:15:41.386 A:middle
This is the model that we've
just presented and it was kind

00:15:41.386 --> 00:15:44.466 A:middle
of a lie but it was a
useful lie at the time.

00:15:45.276 --> 00:15:51.236 A:middle
So, records don't exist by
themselves just as objects

00:15:51.236 --> 00:15:52.946 A:middle
in your application don't
exist by themselves.

00:15:52.946 --> 00:15:54.756 A:middle
There's going to be a
natural grouping of objects

00:15:54.756 --> 00:15:55.656 A:middle
within your application.

00:15:56.046 --> 00:15:58.516 A:middle
Similarly we want a way

00:15:58.516 --> 00:16:00.576 A:middle
to express this grouping
in CloudKit.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.516 --> 00:16:00.576 A:middle
to express this grouping
in CloudKit.

00:16:00.756 --> 00:16:03.926 A:middle
Fundamentally we're trying
via CloudKit to take as much

00:16:03.926 --> 00:16:06.336 A:middle
of your knowledge about your
object graph and reflect

00:16:06.336 --> 00:16:07.096 A:middle
that up to the server.

00:16:08.066 --> 00:16:10.466 A:middle
So the way that we group
records is via something

00:16:10.466 --> 00:16:11.646 A:middle
that we call a record zone.

00:16:12.566 --> 00:16:14.606 A:middle
There can be multiple
records within a record zone

00:16:15.246 --> 00:16:17.916 A:middle
and there can be multiple
record zones within a database.

00:16:18.666 --> 00:16:21.046 A:middle
Every database has a
default record zone.

00:16:21.366 --> 00:16:24.486 A:middle
Some databases support
additional custom record zones.

00:16:25.386 --> 00:16:27.686 A:middle
Record zones are the
default granularity

00:16:27.686 --> 00:16:28.296 A:middle
at which you're going

00:16:28.296 --> 00:16:30.426 A:middle
to do atomic commits
and change tracking.

00:16:31.016 --> 00:16:32.716 A:middle
If either of those sound
interesting to you,

00:16:32.716 --> 00:16:34.596 A:middle
I invite you back on Thursday
for the advanced talk.

00:16:34.596 --> 00:16:37.406 A:middle
We're going to go over
a whole bunch of that.

00:16:37.616 --> 00:16:38.996 A:middle
So, those were record zones.

00:16:38.996 --> 00:16:40.496 A:middle
Let's talk about
RecordIDentifiers.

00:16:41.366 --> 00:16:45.846 A:middle
RecordIDentifiers, let's get
the code up there, are a tuple.

00:16:45.846 --> 00:16:48.306 A:middle
They represent both a
client provided record name

00:16:48.876 --> 00:16:51.696 A:middle
and also the zone in which
that record name exists.

00:16:52.676 --> 00:16:54.046 A:middle
So what are their
characteristics?

00:16:54.556 --> 00:16:56.946 A:middle
Number one they are
created by the client.

00:16:57.306 --> 00:17:01.246 A:middle
You get to specify the ID,
the record name of the record,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:57.306 --> 00:17:01.246 A:middle
You get to specify the ID,
the record name of the record,

00:17:02.456 --> 00:17:04.695 A:middle
but because we are
coupling this record name,

00:17:04.826 --> 00:17:08.596 A:middle
which is scoped per record
zone, along with a reference

00:17:08.656 --> 00:17:09.996 A:middle
to the owning record zone,

00:17:10.455 --> 00:17:13.236 A:middle
they become a fully normalized
representation of the record.

00:17:13.326 --> 00:17:15.256 A:middle
It's the full path to it.

00:17:15.256 --> 00:17:19.695 A:middle
We think that it's going to be
fairly common for you to try

00:17:19.695 --> 00:17:22.246 A:middle
and bridge an external
dataset into CloudKit.

00:17:22.596 --> 00:17:25.746 A:middle
If you're doing so and if your
external dataset has a unique

00:17:25.746 --> 00:17:30.716 A:middle
key, using that unique key
as the CKRecordID allows you

00:17:30.716 --> 00:17:32.956 A:middle
to have a foreign key back
into your external dataset.

00:17:33.236 --> 00:17:34.436 A:middle
Totally an approved usage.

00:17:35.646 --> 00:17:37.186 A:middle
Let's have a look at some code.

00:17:37.616 --> 00:17:39.626 A:middle
Here we are, you know,
creating a record,

00:17:39.626 --> 00:17:40.446 A:middle
you've seen that already,

00:17:41.076 --> 00:17:43.236 A:middle
and we've got multiple
initializers for CKRecord.

00:17:43.366 --> 00:17:45.126 A:middle
You can either choose
to provide us a RecordID

00:17:45.126 --> 00:17:46.106 A:middle
or you can choose not to.

00:17:46.236 --> 00:17:48.216 A:middle
If you choose not to
provide a RecordID,

00:17:48.466 --> 00:17:51.206 A:middle
we're going to assign a random
view UUID to the record.

00:17:52.206 --> 00:17:55.556 A:middle
Also note here that when I
created my RecordID I chose not

00:17:55.556 --> 00:17:56.726 A:middle
to give it a zone.

00:17:57.186 --> 00:17:59.946 A:middle
Throughout CloudKit's
API if you choose not

00:17:59.946 --> 00:18:01.556 A:middle
to give us a record zone,
we're going to assume


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.946 --> 00:18:01.556 A:middle
to give us a record zone,
we're going to assume

00:18:01.556 --> 00:18:02.856 A:middle
that you meant the default zone.

00:18:03.156 --> 00:18:06.346 A:middle
So here, I am creating
a RecordID

00:18:06.346 --> 00:18:08.306 A:middle
with the name well-known
party that exists

00:18:08.306 --> 00:18:09.216 A:middle
within the default zone.

00:18:10.316 --> 00:18:11.526 A:middle
So those are RecordIDs.

00:18:12.066 --> 00:18:13.406 A:middle
Now let's talk about references.

00:18:14.126 --> 00:18:16.386 A:middle
Just as there's a natural
grouping of records that we want

00:18:16.386 --> 00:18:18.976 A:middle
to expose via a record
zone, there's also going

00:18:18.976 --> 00:18:20.996 A:middle
to be a natural relationship
between objects.

00:18:21.746 --> 00:18:24.776 A:middle
For example, let's say that in
addition to being able to write

00:18:24.776 --> 00:18:27.156 A:middle
up parties I can assign
different clowns to parties

00:18:27.186 --> 00:18:28.466 A:middle
because what is the
point of a party

00:18:28.466 --> 00:18:29.806 A:middle
if you don't have a few clowns?

00:18:30.206 --> 00:18:31.916 A:middle
So, I want some way

00:18:32.276 --> 00:18:36.146 A:middle
of representing the object
relationship that I have

00:18:36.146 --> 00:18:39.056 A:middle
between parties and clowns up
to the server and the way we do

00:18:39.056 --> 00:18:40.946 A:middle
that is via something
that we call references.

00:18:41.756 --> 00:18:45.726 A:middle
Now you'll note here that in
this contrived example parties

00:18:45.776 --> 00:18:46.636 A:middle
own clowns.

00:18:46.636 --> 00:18:49.336 A:middle
That is we've got a parent/child
relationship with the party

00:18:49.336 --> 00:18:50.896 A:middle
as a parent and the
clown as a child

00:18:50.896 --> 00:18:54.276 A:middle
and that the reference
goes from the child object,

00:18:54.276 --> 00:18:56.446 A:middle
from the clown, up
to its parent object.

00:18:56.816 --> 00:18:58.846 A:middle
We call that a back reference.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:00.316 --> 00:19:03.816 A:middle
References are exposing API
as the CKReference class.

00:19:03.816 --> 00:19:05.516 A:middle
They are a way of letting
the server understand the

00:19:05.516 --> 00:19:06.916 A:middle
relationship between records.

00:19:07.516 --> 00:19:09.086 A:middle
When the server understands
the relationship

00:19:09.086 --> 00:19:11.166 A:middle
between records it can do
very interesting things

00:19:11.236 --> 00:19:12.576 A:middle
such as cascade delete.

00:19:13.216 --> 00:19:16.266 A:middle
If the server notices that
you've deleted a record

00:19:16.266 --> 00:19:19.676 A:middle
and that record is the parent in
a parent and child relationship,

00:19:20.196 --> 00:19:21.896 A:middle
the server will automatically
go ahead

00:19:21.896 --> 00:19:24.556 A:middle
and cascade delete all
the children of that item.

00:19:25.116 --> 00:19:28.086 A:middle
With any database
the scope and scale

00:19:28.146 --> 00:19:31.396 A:middle
of CloudKit dangling pointers
are going to become a necessary

00:19:31.396 --> 00:19:35.326 A:middle
and inconvenient truth
of your use of CloudKit.

00:19:35.916 --> 00:19:38.256 A:middle
By the time you fetch a record
and you read a reference,

00:19:38.386 --> 00:19:40.246 A:middle
then you go and fetch the
target of that reference,

00:19:40.246 --> 00:19:41.536 A:middle
the target may not exist.

00:19:41.976 --> 00:19:44.746 A:middle
So it's important that you're
code is resilient to this.

00:19:46.156 --> 00:19:49.076 A:middle
Again, as I mentioned, we
prefer back references.

00:19:49.076 --> 00:19:52.046 A:middle
It's not a requirement, but it's
more efficient if references go

00:19:52.046 --> 00:19:54.126 A:middle
from child objects
to parent objects.

00:19:54.256 --> 00:19:55.836 A:middle
This is the tip of the iceberg

00:19:55.836 --> 00:19:58.766 A:middle
in a very large topic
called data modeling

00:19:59.066 --> 00:20:00.606 A:middle
and if you come back
on Thursday we're going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.066 --> 00:20:00.606 A:middle
and if you come back
on Thursday we're going

00:20:00.606 --> 00:20:02.526 A:middle
to tell you a whole bunch about
data modeling in CloudKit.

00:20:03.296 --> 00:20:05.746 A:middle
Let's have a look at some code.

00:20:06.766 --> 00:20:11.006 A:middle
Here we see creating a reference
between two CKRecord instances

00:20:11.006 --> 00:20:14.316 A:middle
that I have in memory,
but it's not necessary

00:20:14.316 --> 00:20:16.516 A:middle
that I have the target
of a reference in memory.

00:20:17.146 --> 00:20:19.986 A:middle
I can make a reference
that points at a RecordID.

00:20:20.656 --> 00:20:23.096 A:middle
This allows me to refer to a
record that I've got, you know,

00:20:23.236 --> 00:20:25.326 A:middle
reason to believe
exists up on the server.

00:20:26.116 --> 00:20:28.636 A:middle
If I were to save this record
and the target didn't exist,

00:20:28.636 --> 00:20:31.706 A:middle
I'd actually be creating a
dangling pointer and that's okay

00:20:31.706 --> 00:20:33.926 A:middle
because the code you're going
to write is going to support

00:20:34.076 --> 00:20:36.106 A:middle
and be resilient in the
face of dangling pointers.

00:20:37.466 --> 00:20:39.976 A:middle
So those are references now
let's talk about assets.

00:20:40.236 --> 00:20:43.716 A:middle
Here we have our
model again just

00:20:43.716 --> 00:20:45.466 A:middle
to refresh our container
database record

00:20:46.366 --> 00:20:50.146 A:middle
and now let's take the idea
that I want to write a record,

00:20:50.146 --> 00:20:53.056 A:middle
I want to write a party record
up to the server, but let's say

00:20:53.056 --> 00:20:55.626 A:middle
that I want to associate a
large file with that record.

00:20:55.746 --> 00:20:57.036 A:middle
Let's say, for example,
that we're going

00:20:57.036 --> 00:20:59.496 A:middle
to have a get together after
the presentation and I'm going

00:20:59.496 --> 00:21:01.316 A:middle
to read you a screen play
that I've been working on.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.496 --> 00:21:01.316 A:middle
to read you a screen play
that I've been working on.

00:21:02.266 --> 00:21:03.666 A:middle
Now I know, I understand

00:21:03.666 --> 00:21:04.906 A:middle
that there's different
characteristics

00:21:04.906 --> 00:21:06.186 A:middle
between these different datas.

00:21:06.246 --> 00:21:09.156 A:middle
I understand that the record
about the party is structured,

00:21:09.306 --> 00:21:11.136 A:middle
you know, it's got a summary,
it's got a start date,

00:21:11.136 --> 00:21:14.636 A:middle
it's got an end date and, you
know, just innately I believe

00:21:14.636 --> 00:21:15.376 A:middle
that I want the server

00:21:15.376 --> 00:21:17.776 A:middle
to understand those
bits about the record.

00:21:18.126 --> 00:21:20.826 A:middle
If you contrast that to
the screen play, well,

00:21:20.826 --> 00:21:23.016 A:middle
the screen play is just
essentially a bag of bits.

00:21:23.266 --> 00:21:24.826 A:middle
I don't feel any real need

00:21:24.826 --> 00:21:26.556 A:middle
to tell the server how
my screen play breaks

00:21:26.556 --> 00:21:29.266 A:middle
down into amazing acts and,
you know, dashing scenes,

00:21:29.916 --> 00:21:32.876 A:middle
but I do know that
I want to treat them

00:21:32.876 --> 00:21:33.836 A:middle
as just an opaque bag.

00:21:34.296 --> 00:21:35.646 A:middle
So how do we solve this?

00:21:35.646 --> 00:21:38.256 A:middle
Well, we're going to
solve this and we're going

00:21:38.256 --> 00:21:40.396 A:middle
to solve the fact that data
has different characteristics

00:21:40.396 --> 00:21:42.086 A:middle
like this in two different ways.

00:21:42.836 --> 00:21:44.716 A:middle
Up on the server we're
going to introduce a notion

00:21:44.716 --> 00:21:46.186 A:middle
that we call bulk storage.

00:21:46.836 --> 00:21:48.716 A:middle
As you might expect,
bulk storage is great

00:21:48.716 --> 00:21:49.926 A:middle
for storing bulk data.

00:21:51.176 --> 00:21:54.966 A:middle
Similarly on the client
you're going to tell CloudKit

00:21:54.966 --> 00:21:56.746 A:middle
about the different
characteristics of your data

00:21:57.036 --> 00:21:58.946 A:middle
by treating some
of it as a CKRecord

00:21:59.296 --> 00:22:01.146 A:middle
and other bits of
it as a CKAsset.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.296 --> 00:22:01.146 A:middle
and other bits of
it as a CKAsset.

00:22:01.436 --> 00:22:04.296 A:middle
A CKAsset is the representation
of this bag of bits.

00:22:04.656 --> 00:22:06.766 A:middle
Now when you ask CloudKit
to save this record,

00:22:07.246 --> 00:22:08.326 A:middle
the appropriate bits
are going to go

00:22:08.326 --> 00:22:09.386 A:middle
in the appropriate database.

00:22:09.476 --> 00:22:11.186 A:middle
Structured data in
public database,

00:22:11.246 --> 00:22:12.846 A:middle
bulk data in bulk storage.

00:22:13.646 --> 00:22:15.136 A:middle
So assets.

00:22:15.396 --> 00:22:19.466 A:middle
Assets are exposed in our
framework as the CKAsset class.

00:22:19.526 --> 00:22:21.226 A:middle
They represent large,
unstructured data.

00:22:22.196 --> 00:22:24.396 A:middle
Because you don't necessarily
want large unstructured data

00:22:24.396 --> 00:22:26.826 A:middle
in memory, the way you
communicate assets to

00:22:26.826 --> 00:22:29.156 A:middle
and from CloudKit is
via files on disks.

00:22:30.506 --> 00:22:32.266 A:middle
Assets are owned by records.

00:22:32.376 --> 00:22:33.746 A:middle
This gives us a nice
tight coupling

00:22:33.746 --> 00:22:34.896 A:middle
between a record and an asset.

00:22:36.186 --> 00:22:39.596 A:middle
What this allows the server to
do is garbage collect assets.

00:22:40.006 --> 00:22:42.826 A:middle
Even though that we're storing
this data in two separate areas

00:22:43.216 --> 00:22:45.866 A:middle
when the server detects a delete
for a record it can go ahead

00:22:45.866 --> 00:22:48.676 A:middle
and clean up any assets that
were owned by that record.

00:22:49.936 --> 00:22:53.336 A:middle
Lastly because we expect CKAsset
to be large, opaque data,

00:22:53.636 --> 00:22:56.756 A:middle
we go through some great pains
to try and move that data to

00:22:56.756 --> 00:22:58.516 A:middle
and from the server as
efficiently as possible.

00:22:58.676 --> 00:23:01.316 A:middle
This is all sort of inside
of CloudKit but we're going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.676 --> 00:23:01.316 A:middle
This is all sort of inside
of CloudKit but we're going

00:23:01.316 --> 00:23:03.926 A:middle
to send only the bits
that the minimal amount

00:23:03.926 --> 00:23:04.676 A:middle
of bits that we can.

00:23:05.386 --> 00:23:07.496 A:middle
Let's have a look at some code.

00:23:08.566 --> 00:23:11.876 A:middle
Here I'm creating a
CKAsset based on a file URL

00:23:11.876 --> 00:23:14.296 A:middle
to my screen play
on disk and just

00:23:14.296 --> 00:23:18.076 A:middle
like any other CKRecord value
supporting class I'm setting it

00:23:18.076 --> 00:23:19.296 A:middle
on CKRecord.

00:23:19.986 --> 00:23:22.856 A:middle
So these are the fundamental
objects in CloudKit.

00:23:23.266 --> 00:23:24.806 A:middle
The first thing you
talk to is a container.

00:23:25.176 --> 00:23:27.056 A:middle
Within a container are
two different databases.

00:23:27.516 --> 00:23:30.196 A:middle
Databases contains
records, records are wrapped

00:23:30.196 --> 00:23:31.746 A:middle
and grouped within record zones.

00:23:32.136 --> 00:23:34.666 A:middle
You identify a record
via a RecordIDentifier

00:23:35.286 --> 00:23:39.086 A:middle
and records are related to
one another via references

00:23:39.086 --> 00:23:41.016 A:middle
and large bulk data
is transmitted to

00:23:41.016 --> 00:23:43.356 A:middle
and from CloudKit via CKAssets.

00:23:45.286 --> 00:23:46.216 A:middle
All right you guys made it

00:23:46.216 --> 00:23:48.086 A:middle
through the nouns now
let's get into the verbs.

00:23:50.486 --> 00:23:53.206 A:middle
[Laughter] CloudKit we
offer two different APIs

00:23:53.206 --> 00:23:54.176 A:middle
for using CloudKit.

00:23:54.416 --> 00:23:56.986 A:middle
We call them the operational
API and the convenience API.

00:23:57.786 --> 00:24:00.086 A:middle
The operational API
has every single bell


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:57.786 --> 00:24:00.086 A:middle
The operational API
has every single bell

00:24:00.086 --> 00:24:01.536 A:middle
and whistle you might
care about.

00:24:01.536 --> 00:24:07.806 A:middle
In some cases, you're going to
want to tweak every single bell

00:24:07.806 --> 00:24:09.896 A:middle
and whistle to fit your
application's model,

00:24:10.926 --> 00:24:14.246 A:middle
but not every application really
wants to do all of this tweaking

00:24:14.406 --> 00:24:16.406 A:middle
and not every application
has enough knowledge

00:24:16.406 --> 00:24:17.786 A:middle
to set these bits correctly.

00:24:18.186 --> 00:24:20.206 A:middle
Sometimes you want to let
the framework make some

00:24:20.206 --> 00:24:22.596 A:middle
of these decisions
on your behalf.

00:24:22.596 --> 00:24:25.536 A:middle
So, we offer the
convenience API.

00:24:25.876 --> 00:24:27.946 A:middle
It's convenient, it's
going to be what you want

00:24:27.946 --> 00:24:30.206 A:middle
to start off playing with when
you start looking at CloudKit.

00:24:30.316 --> 00:24:32.766 A:middle
For many uses of
CloudKit it's all

00:24:32.766 --> 00:24:35.396 A:middle
that you're going
to need to touch.

00:24:35.576 --> 00:24:37.696 A:middle
So quickly we're going to go
over how you save a record

00:24:37.696 --> 00:24:40.036 A:middle
in the convenience of API,
how you fetch a record

00:24:40.036 --> 00:24:42.726 A:middle
from the server via
the convenience of API

00:24:42.726 --> 00:24:45.966 A:middle
and how you can take a
fetched record, modify it

00:24:45.966 --> 00:24:47.386 A:middle
and save it back
up to the server.

00:24:48.526 --> 00:24:49.986 A:middle
Let's start off with
saving a record.

00:24:52.876 --> 00:24:53.996 A:middle
Here I am creating a record.

00:24:53.996 --> 00:24:55.926 A:middle
You guys are now very
well familiar with this.

00:24:57.566 --> 00:24:59.196 A:middle
When I want to save the
record, I have to choose

00:24:59.196 --> 00:25:02.176 A:middle
which database I
want to save it into.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.196 --> 00:25:02.176 A:middle
which database I
want to save it into.

00:25:02.176 --> 00:25:03.206 A:middle
Here I'm going to save the data

00:25:03.206 --> 00:25:05.536 A:middle
into the public database
and how do I do that?

00:25:06.096 --> 00:25:08.896 A:middle
Well, I call the save record
with completion handler method.

00:25:08.896 --> 00:25:12.136 A:middle
Now I want you guys to
note three separate things

00:25:12.136 --> 00:25:13.686 A:middle
about this code right here.

00:25:14.306 --> 00:25:15.856 A:middle
First of all it's very simple.

00:25:16.266 --> 00:25:17.946 A:middle
You guys aren't providing
a lot of options,

00:25:17.946 --> 00:25:19.936 A:middle
you're delegating a lot
of the bells and whistles

00:25:19.936 --> 00:25:21.536 A:middle
like how important is this,

00:25:21.596 --> 00:25:23.326 A:middle
what interface should
I send this data over,

00:25:23.736 --> 00:25:25.536 A:middle
you're delegating those
choices off to CloudKit.

00:25:26.576 --> 00:25:28.616 A:middle
Second, it's asynchronous.

00:25:28.946 --> 00:25:30.056 A:middle
As Olivier mentioned,

00:25:30.056 --> 00:25:32.536 A:middle
the CloudKit does not
have local persistence.

00:25:32.616 --> 00:25:33.996 A:middle
We are a transport technology.

00:25:34.466 --> 00:25:36.136 A:middle
We're going to transport
your data up to the server

00:25:36.136 --> 00:25:38.196 A:middle
and we'll store it on the server
and we'll transport it back

00:25:38.196 --> 00:25:39.556 A:middle
down to other clients.

00:25:40.316 --> 00:25:43.626 A:middle
So when you save a record
via CloudKit, we are going

00:25:43.626 --> 00:25:45.716 A:middle
to attempt to save that
record directly to the server.

00:25:46.186 --> 00:25:48.916 A:middle
If it fails, we're going to tell
you about that immediately or,

00:25:49.016 --> 00:25:50.086 A:middle
you know, as quickly as we can.

00:25:51.396 --> 00:25:53.526 A:middle
Now we don't want
to block threads

00:25:53.616 --> 00:25:55.006 A:middle
and we don't want you
to block the user.

00:25:55.226 --> 00:25:56.816 A:middle
So we don't want to make
this a synchronous call.

00:25:57.256 --> 00:25:59.006 A:middle
So here we've got an
asynchronous call.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.366 --> 00:26:02.206 A:middle
Now the third thing
I want you to note is

00:26:02.206 --> 00:26:05.236 A:middle
that even though is a very
simple method we do provide an

00:26:05.236 --> 00:26:06.696 A:middle
error as part of the call back.

00:26:07.136 --> 00:26:09.516 A:middle
Now if you've been
to WWC in the past

00:26:09.516 --> 00:26:11.036 A:middle
or if you've watched
any presentations,

00:26:11.036 --> 00:26:12.516 A:middle
you've seen something
that looks like this.

00:26:12.516 --> 00:26:14.096 A:middle
We've got an Apple
developer up here

00:26:14.096 --> 00:26:16.976 A:middle
and the Apple developer says
you need to handle errors

00:26:16.976 --> 00:26:18.096 A:middle
that return from our framework.

00:26:18.096 --> 00:26:21.496 A:middle
Now, I'm not calling them
liars it's true you do need

00:26:21.496 --> 00:26:23.216 A:middle
to handle errors
returned from frameworks.

00:26:23.216 --> 00:26:26.386 A:middle
In many applications, it's
the difference between a good

00:26:26.386 --> 00:26:28.506 A:middle
and functioning application
and a great application.

00:26:29.616 --> 00:26:30.846 A:middle
CloudKit is a little
bit different.

00:26:31.366 --> 00:26:33.276 A:middle
CloudKit by its very
nature is going

00:26:33.276 --> 00:26:34.506 A:middle
to be talking over the network.

00:26:34.756 --> 00:26:36.196 A:middle
Networks are inherently
lossy [phonetic].

00:26:36.516 --> 00:26:38.926 A:middle
Phones like to fall off
the network all the time.

00:26:38.926 --> 00:26:42.046 A:middle
So, in CloudKit, the difference
between handling an error

00:26:42.046 --> 00:26:44.376 A:middle
versus not handling an error
is really the difference

00:26:44.376 --> 00:26:46.606 A:middle
between a functional and
a non-functional app.

00:26:47.106 --> 00:26:49.026 A:middle
Error handling has got to
be one of the first things

00:26:49.026 --> 00:26:50.936 A:middle
that you look at when
you start using CloudKit.

00:26:50.936 --> 00:26:53.416 A:middle
I'm going to be a little bit
glib throughout the slides here

00:26:53.416 --> 00:26:54.976 A:middle
but every time you
see a comment imagine

00:26:54.976 --> 00:26:57.146 A:middle
that you're seeing just some
really nice error handling.

00:26:57.876 --> 00:27:02.486 A:middle
[Laughter] So let's talk about
now that we've saved a record


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.876 --> 00:27:02.486 A:middle
[Laughter] So let's talk about
now that we've saved a record

00:27:02.486 --> 00:27:04.146 A:middle
up to the server, how do
we fetch a record back

00:27:04.146 --> 00:27:04.986 A:middle
down from the server?

00:27:05.756 --> 00:27:09.646 A:middle
I'm going to start by
deciding which database I want

00:27:09.646 --> 00:27:10.486 A:middle
to fetch a record from.

00:27:10.556 --> 00:27:13.666 A:middle
I'm then going to construct
a RecordID, the identifier

00:27:13.666 --> 00:27:16.526 A:middle
of the record I care
to fetch down.

00:27:16.526 --> 00:27:19.456 A:middle
Here I've gotten this name
either via some side channel

00:27:19.456 --> 00:27:21.136 A:middle
or something that's built
into my application.

00:27:22.586 --> 00:27:25.396 A:middle
I then can ask the database
to fetch a record with ID

00:27:25.396 --> 00:27:26.226 A:middle
with completion handler.

00:27:26.826 --> 00:27:30.296 A:middle
Again, asynchronous, simple,
amazing error handling.

00:27:32.276 --> 00:27:35.026 A:middle
Once I fetched a record let's
get that code back up here,

00:27:35.546 --> 00:27:38.886 A:middle
I want you to note that the
successful return value is an

00:27:38.886 --> 00:27:40.646 A:middle
actual CKRecord instance

00:27:40.646 --> 00:27:43.016 A:middle
and this is a live
honest to God CKRecord.

00:27:43.536 --> 00:27:45.726 A:middle
Let's say I'm having so much
fun at this party I pulled

00:27:46.126 --> 00:27:47.586 A:middle
that I want it to last
a little bit longer.

00:27:47.776 --> 00:27:50.346 A:middle
I can take a record off of it
and I can bump out the end date

00:27:50.346 --> 00:27:52.486 A:middle
by half an hour and I
can set that record,

00:27:52.486 --> 00:27:53.816 A:middle
that value back on the record.

00:27:54.656 --> 00:27:57.476 A:middle
Once I've done that I can take
my CKRecord instance and just

00:27:57.476 --> 00:27:59.776 A:middle
like one that I've created
locally I can turn around

00:27:59.776 --> 00:28:02.506 A:middle
and save it back up
to the database again


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.776 --> 00:28:02.506 A:middle
and save it back up
to the database again

00:28:02.506 --> 00:28:03.456 A:middle
with amazing error handling.

00:28:04.496 --> 00:28:07.586 A:middle
All right so that's
the convenience API,

00:28:07.586 --> 00:28:09.396 A:middle
the initial typical flow
that you're going to go

00:28:09.446 --> 00:28:10.446 A:middle
through when talking
with CloudKit.

00:28:10.446 --> 00:28:12.586 A:middle
You're going to be saving
records, fetching records

00:28:12.996 --> 00:28:16.086 A:middle
and taking those records that
you fetched modifying them

00:28:16.236 --> 00:28:18.096 A:middle
and putting them back
up to the server.

00:28:19.096 --> 00:28:21.926 A:middle
So now let's say my party
application starts becoming

00:28:21.926 --> 00:28:24.056 A:middle
really popular and it's grown.

00:28:24.056 --> 00:28:27.476 A:middle
My user base is no longer me and
my friends but it's all of you.

00:28:27.476 --> 00:28:29.906 A:middle
Everyone is really excited
about joining into the parties.

00:28:30.586 --> 00:28:32.216 A:middle
What are some of the problems
I'm going to run into?

00:28:32.986 --> 00:28:35.506 A:middle
Well, let's assume
that when I started

00:28:35.506 --> 00:28:37.306 A:middle
out I was a relatively
naive developer

00:28:37.566 --> 00:28:40.276 A:middle
and because the developer on
stage said CloudKit is all

00:28:40.276 --> 00:28:41.856 A:middle
about taking your object
graph and moving it to

00:28:41.856 --> 00:28:43.956 A:middle
and from the cloud,
that's exactly what I did.

00:28:43.956 --> 00:28:45.586 A:middle
I had the one to one mapping.

00:28:45.806 --> 00:28:47.766 A:middle
My objects went up to the Cloud

00:28:48.016 --> 00:28:50.546 A:middle
and on every client I would
fetch the entire cloud state

00:28:50.546 --> 00:28:52.056 A:middle
and that would become
my object graph.

00:28:52.486 --> 00:28:53.996 A:middle
What are some problems
we're going to run into?

00:28:54.876 --> 00:28:57.776 A:middle
Well, at that point we've got
big data and a very tiny phone.

00:28:58.626 --> 00:29:00.776 A:middle
The more popular my app
becomes the more data


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.626 --> 00:29:00.776 A:middle
The more popular my app
becomes the more data

00:29:00.776 --> 00:29:03.876 A:middle
on the database the less
reasonable it is to have a cache

00:29:03.876 --> 00:29:06.406 A:middle
of that entire data
locally on my device.

00:29:06.816 --> 00:29:08.016 A:middle
So how are we going
to solve this.

00:29:08.016 --> 00:29:10.186 A:middle
Let's think about
what we want to do.

00:29:10.776 --> 00:29:13.456 A:middle
We want to keep the large
data up in the Cloud.

00:29:13.606 --> 00:29:15.726 A:middle
The Cloud is very good at
storing large datasets.

00:29:16.366 --> 00:29:18.676 A:middle
My client wants to view
a slice of that data.

00:29:19.276 --> 00:29:21.556 A:middle
Because I'm writing an
application for my users

00:29:21.556 --> 00:29:24.666 A:middle
and my users have their own
preferences, I want each client

00:29:24.666 --> 00:29:26.716 A:middle
to be able to view a
different slice of that data

00:29:26.916 --> 00:29:28.406 A:middle
and each individual
client might want

00:29:28.406 --> 00:29:29.926 A:middle
to change its view of that data.

00:29:30.776 --> 00:29:34.246 A:middle
The way we saw this is via
something that we call queries.

00:29:35.176 --> 00:29:37.616 A:middle
Clients use queries to
focus their viewpoint

00:29:38.076 --> 00:29:40.986 A:middle
so that they can see a small
section of a large dataset

00:29:41.076 --> 00:29:42.586 A:middle
that exists up on the cloud.

00:29:43.556 --> 00:29:45.506 A:middle
So what is a query?

00:29:45.506 --> 00:29:47.606 A:middle
As you might imagine,
it's exposed in our API

00:29:47.606 --> 00:29:49.536 A:middle
as the CK query class.

00:29:50.666 --> 00:29:52.866 A:middle
A query combines three
different things.

00:29:52.866 --> 00:29:54.706 A:middle
It combines a record
type, a predicate

00:29:55.096 --> 00:29:56.796 A:middle
and optionally a
sort descriptor.

00:29:57.986 --> 00:30:00.126 A:middle
If you've used NS
predicate in the past,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:57.986 --> 00:30:00.126 A:middle
If you've used NS
predicate in the past,

00:30:00.126 --> 00:30:02.046 A:middle
you know that NS predicate
is very expressive.

00:30:03.036 --> 00:30:04.986 A:middle
CloudKit supports
most of NS predicate.

00:30:05.226 --> 00:30:08.746 A:middle
We document the parts that we do
and if you hand us a predicate

00:30:08.746 --> 00:30:10.576 A:middle
that we don't understand, we're
going to throw an exception.

00:30:10.716 --> 00:30:12.406 A:middle
So you're going to learn
pretty quickly which ones are

00:30:12.406 --> 00:30:13.046 A:middle
and are not supported.

00:30:13.046 --> 00:30:13.976 A:middle
Let's have a look at
some that are supported.

00:30:14.126 --> 00:30:19.476 A:middle
Here we see a predicate
that would match records

00:30:19.706 --> 00:30:21.936 A:middle
where name is equal to
a value I had in memory.

00:30:23.376 --> 00:30:25.636 A:middle
Predicates allow you
to use dynamic keys

00:30:25.636 --> 00:30:28.126 A:middle
so that I don't have to know
the key name at compile time.

00:30:29.166 --> 00:30:31.386 A:middle
We can do relative
ordering comparisons

00:30:31.386 --> 00:30:32.856 A:middle
as opposed to strict equalities.

00:30:33.436 --> 00:30:36.846 A:middle
We mentioned that location
is an interesting aspect

00:30:36.846 --> 00:30:37.836 A:middle
in the public database.

00:30:37.906 --> 00:30:40.656 A:middle
So you can query with
location as a filter.

00:30:41.136 --> 00:30:43.306 A:middle
This is every location
within a 100 meters

00:30:43.306 --> 00:30:44.726 A:middle
of where we're standing
here in Moscone.

00:30:46.716 --> 00:30:48.736 A:middle
CloudKit supports a
tokenization search.

00:30:49.096 --> 00:30:52.616 A:middle
So, what this predicate is going
to do is it's going to tokenize

00:30:52.706 --> 00:30:55.376 A:middle
that string after session
and it's going to come

00:30:55.376 --> 00:30:57.906 A:middle
up with two different
tokens, after and session.

00:30:58.726 --> 00:31:00.466 A:middle
This predicate will
match any record


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.726 --> 00:31:00.466 A:middle
This predicate will
match any record

00:31:00.466 --> 00:31:03.106 A:middle
that has those two
tokens as values.

00:31:03.806 --> 00:31:05.996 A:middle
These two tokens don't
need to exist side by side,

00:31:06.076 --> 00:31:08.176 A:middle
they don't even need to exist
in the same key value pair,

00:31:08.736 --> 00:31:10.846 A:middle
but so long as the
record has the token after

00:31:11.096 --> 00:31:13.726 A:middle
and the record has the token
session the record will be

00:31:13.726 --> 00:31:14.226 A:middle
a match.

00:31:15.826 --> 00:31:19.656 A:middle
Lastly, CloudKit supports
compound predicates joined using

00:31:19.656 --> 00:31:20.676 A:middle
the and operator.

00:31:21.216 --> 00:31:23.086 A:middle
Here we see a predicate
that does that.

00:31:25.406 --> 00:31:26.826 A:middle
Here we see the creation
of a query

00:31:27.086 --> 00:31:30.846 A:middle
and as we mentioned it's
combining both a record type

00:31:30.846 --> 00:31:31.426 A:middle
and a predicate.

00:31:32.956 --> 00:31:35.076 A:middle
How do I perform queries
after I've created them?

00:31:36.186 --> 00:31:39.176 A:middle
Well, just like saving records
performing a query is going

00:31:39.176 --> 00:31:41.186 A:middle
to be a database
specific operation.

00:31:41.396 --> 00:31:42.866 A:middle
So I'm going to choose
the database

00:31:42.866 --> 00:31:45.646 A:middle
on which I want to
perform a query.

00:31:45.756 --> 00:31:48.966 A:middle
Even in the simple API and the
convenience API we give you the

00:31:48.966 --> 00:31:52.096 A:middle
ability to restrict these
queries by record zones.

00:31:52.176 --> 00:31:54.166 A:middle
You see here that we're
not choosing to pass

00:31:54.166 --> 00:31:55.056 A:middle
in a record zone filter.

00:31:55.506 --> 00:31:56.886 A:middle
So this query is going to search

00:31:56.886 --> 00:31:58.436 A:middle
across the entire
public database.

00:31:58.946 --> 00:32:01.156 A:middle
Let's have a look
at what happens


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.946 --> 00:32:01.156 A:middle
Let's have a look
at what happens

00:32:01.226 --> 00:32:02.796 A:middle
in the completion handler.

00:32:03.026 --> 00:32:05.306 A:middle
First, of course,
amazing error handling.

00:32:05.736 --> 00:32:08.146 A:middle
Second, if we don't have errors,

00:32:08.146 --> 00:32:09.456 A:middle
let's have a look
at the results.

00:32:09.456 --> 00:32:12.736 A:middle
You'll see here that the results
are actually CKRecord instances.

00:32:12.736 --> 00:32:13.936 A:middle
These are live objects.

00:32:14.426 --> 00:32:16.506 A:middle
If I wanted to, I could
pull data off of them,

00:32:16.506 --> 00:32:18.886 A:middle
I could set data on them
and I could even choose

00:32:18.886 --> 00:32:20.226 A:middle
to save them back to the server.

00:32:20.226 --> 00:32:26.446 A:middle
So a way to think about queries
is that queries are polls

00:32:26.446 --> 00:32:28.446 A:middle
and polls are great
in some scenarios.

00:32:28.826 --> 00:32:31.036 A:middle
They're great for slicing
through large datasets.

00:32:31.286 --> 00:32:33.666 A:middle
If your application wants to
start up and, for example,

00:32:33.666 --> 00:32:36.566 A:middle
show all the parties, the top
10 parties that are near me,

00:32:36.986 --> 00:32:40.516 A:middle
a query is absolutely the way
to go, but there's other things

00:32:40.516 --> 00:32:41.726 A:middle
that you might be
tempted to use a query

00:32:41.726 --> 00:32:43.116 A:middle
for that are not perfect.

00:32:43.116 --> 00:32:46.806 A:middle
If you find yourself issuing
the same query over and over

00:32:46.806 --> 00:32:49.516 A:middle
and over again and you're
getting back a static,

00:32:49.516 --> 00:32:53.116 A:middle
a mostly same data
result set, well,

00:32:53.116 --> 00:32:55.866 A:middle
then you've got a large
mostly static dataset

00:32:55.866 --> 00:32:58.606 A:middle
and queries are bad for that
use case for a few reasons.

00:32:59.336 --> 00:33:00.506 A:middle
They're bad for battery life.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.336 --> 00:33:00.506 A:middle
They're bad for battery life.

00:33:00.636 --> 00:33:03.106 A:middle
You have to constantly
wake the device up, poll,

00:33:03.106 --> 00:33:05.986 A:middle
run the same query and get back
more or less the same results.

00:33:06.886 --> 00:33:08.026 A:middle
They're bad for network traffic.

00:33:08.236 --> 00:33:09.956 A:middle
All those questions
go to the server

00:33:09.956 --> 00:33:11.436 A:middle
and if they're not
pulling down new

00:33:11.436 --> 00:33:13.706 A:middle
and interesting data,
why do we bother?

00:33:14.486 --> 00:33:17.036 A:middle
They are also bad for
the user experience.

00:33:17.286 --> 00:33:20.506 A:middle
By definition, you're only
going to learn about new results

00:33:20.506 --> 00:33:24.056 A:middle
on the period of how
often you're polling.

00:33:24.726 --> 00:33:26.796 A:middle
Users nowadays have
come to expect push.

00:33:27.816 --> 00:33:30.386 A:middle
So as opposed to using
a client-generated query

00:33:30.386 --> 00:33:33.146 A:middle
in the scenario, what you really
want is you want the server

00:33:33.146 --> 00:33:34.616 A:middle
to be running the
query on your behalf.

00:33:35.466 --> 00:33:37.276 A:middle
You want the server to be
running the query on your behalf

00:33:37.366 --> 00:33:39.306 A:middle
in the background and
you want that to happen

00:33:39.306 --> 00:33:41.756 A:middle
after every single record
save whether it was you

00:33:41.756 --> 00:33:43.336 A:middle
or somebody else that
saved the record.

00:33:44.146 --> 00:33:46.136 A:middle
Lastly, of course,
you want pushes

00:33:46.136 --> 00:33:47.976 A:middle
when the results have changes.

00:33:48.816 --> 00:33:51.086 A:middle
Well, we've given you this and
we call that subscriptions.

00:33:51.736 --> 00:33:51.816 A:middle
Yay.

00:33:52.516 --> 00:33:58.986 A:middle
[ Applause ]

00:33:59.486 --> 00:34:01.436 A:middle
So subscriptions are
exposed in our API


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.486 --> 00:34:01.436 A:middle
So subscriptions are
exposed in our API

00:34:01.436 --> 00:34:03.516 A:middle
as the CKSubscription class.

00:34:03.986 --> 00:34:07.106 A:middle
They combine a record
type, a predicate and push.

00:34:08.186 --> 00:34:10.496 A:middle
Push is delivered via
the Apple Push Service.

00:34:10.496 --> 00:34:12.676 A:middle
If you've used APS in the
past, you're largely familiar

00:34:12.676 --> 00:34:16.116 A:middle
with this, but note CloudKit
pushes are slightly augmented.

00:34:16.346 --> 00:34:18.476 A:middle
They contain CloudKit
specific information

00:34:18.746 --> 00:34:20.246 A:middle
about what caused
the push to happen.

00:34:20.576 --> 00:34:21.985 A:middle
Let's have a look at an example.

00:34:23.726 --> 00:34:26.516 A:middle
Here we have a phone and that
phone is interested in parties

00:34:26.516 --> 00:34:27.985 A:middle
that are going to be
happening in the future.

00:34:28.936 --> 00:34:31.866 A:middle
This phone when it sees that
happening wants to be alerted

00:34:31.866 --> 00:34:33.335 A:middle
with a push that
says party time.

00:34:34.005 --> 00:34:36.426 A:middle
The phone is going to go ahead
and save that up to iCloud

00:34:36.516 --> 00:34:39.235 A:middle
and iCloud is going to,
you know, shuffle it away

00:34:39.235 --> 00:34:40.505 A:middle
with all the other
subscriptions.

00:34:41.436 --> 00:34:42.576 A:middle
Now along comes the Mac.

00:34:42.886 --> 00:34:44.275 A:middle
The Mac creates a new record.

00:34:44.505 --> 00:34:46.706 A:middle
It's a record-type party
and it's happening tonight

00:34:47.266 --> 00:34:50.295 A:middle
and because the Mac didn't chose
to give us a RecordID we created

00:34:50.295 --> 00:34:52.306 A:middle
that random UUID you see.

00:34:52.746 --> 00:34:55.795 A:middle
The Mac goes ahead and
saves that to ICloud.

00:34:55.795 --> 00:34:58.756 A:middle
ICloud is then going
to loop through all

00:34:58.756 --> 00:35:00.376 A:middle
of the subscriptions
that it knows about.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:58.756 --> 00:35:00.376 A:middle
of the subscriptions
that it knows about.

00:35:00.756 --> 00:35:02.256 A:middle
Eventually it's going
to come across this one.

00:35:02.936 --> 00:35:04.556 A:middle
It's going to check
and say, yeah, okay,

00:35:04.556 --> 00:35:07.286 A:middle
this is a new party and, yeah,
it's happening in the future.

00:35:07.946 --> 00:35:10.496 A:middle
So at that point it's going to
create a push and it's going

00:35:10.496 --> 00:35:12.796 A:middle
to take some information
from the subscription.

00:35:13.206 --> 00:35:15.476 A:middle
Here it took the alert
string party time.

00:35:16.066 --> 00:35:17.446 A:middle
It's going to take
other information

00:35:17.656 --> 00:35:19.066 A:middle
from the record itself.

00:35:19.066 --> 00:35:20.556 A:middle
Here we're pulling
in the RecordID.

00:35:21.186 --> 00:35:23.316 A:middle
Now that I've constructed
this augmented payload,

00:35:23.426 --> 00:35:25.946 A:middle
I can send that augmented
payload down to all clients

00:35:25.996 --> 00:35:28.126 A:middle
that are registered
and interested in it.

00:35:29.316 --> 00:35:30.706 A:middle
So let's look at some code.

00:35:31.246 --> 00:35:32.526 A:middle
How do I create a subscription?

00:35:33.126 --> 00:35:37.356 A:middle
Well, a subscription combines
a record type and a predicate.

00:35:38.826 --> 00:35:41.136 A:middle
Because a subscription
is also in charge

00:35:41.136 --> 00:35:43.596 A:middle
of telling the server how
you want to be alerted,

00:35:44.106 --> 00:35:46.516 A:middle
we introduce a notion
called CKNotificationInfo.

00:35:47.546 --> 00:35:51.826 A:middle
Here we're requesting that
the server badges our icon,

00:35:51.826 --> 00:35:54.626 A:middle
that it plays a particular sound
pulled out of my resources,

00:35:55.296 --> 00:35:57.916 A:middle
and that it shows an alert
string based on a string

00:35:57.916 --> 00:35:59.166 A:middle
in my localized strings file.

00:35:59.846 --> 00:36:02.186 A:middle
I can associate that
notification info


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.846 --> 00:36:02.186 A:middle
I can associate that
notification info

00:36:02.186 --> 00:36:04.846 A:middle
with a subscription and now
I've created everything I need

00:36:04.846 --> 00:36:05.556 A:middle
in my subscription.

00:36:06.266 --> 00:36:07.636 A:middle
Let's go ahead and
save it to the server.

00:36:08.826 --> 00:36:11.926 A:middle
As you might imagine via the
convenience API, it's simple,

00:36:11.926 --> 00:36:14.176 A:middle
it's asynchronous and it's
got great error handling.

00:36:14.656 --> 00:36:18.566 A:middle
Let's look at how you're going
to be handling subscriptions,

00:36:18.566 --> 00:36:20.446 A:middle
how you're going to handle
pushes as they come in.

00:36:20.946 --> 00:36:23.676 A:middle
If you've used APS in the
past, you're probably familiar

00:36:23.676 --> 00:36:24.536 A:middle
with this code snippet.

00:36:25.116 --> 00:36:27.216 A:middle
This is your application
delegate implementing the

00:36:27.216 --> 00:36:30.306 A:middle
ApplicationDidReceive
from notification method.

00:36:31.436 --> 00:36:34.406 A:middle
Now in most scenarios
if you know the format

00:36:34.406 --> 00:36:36.206 A:middle
of the push payload
that's coming in,

00:36:36.496 --> 00:36:38.666 A:middle
you would just then iterate
through that dictionary pulling

00:36:38.666 --> 00:36:40.236 A:middle
out the key value pairs
that you care about.

00:36:41.076 --> 00:36:42.656 A:middle
However, because
CloudKit was the one

00:36:42.656 --> 00:36:43.846 A:middle
that generated this push,

00:36:44.376 --> 00:36:46.366 A:middle
we ask that you let
CloudKit do that parsing.

00:36:47.026 --> 00:36:50.346 A:middle
So the way you would do that
is via CKNotification then

00:36:50.346 --> 00:36:53.186 A:middle
that really long one
I'm not going to name.

00:36:53.396 --> 00:36:55.026 A:middle
Once we've actually parsed

00:36:55.026 --> 00:36:58.326 A:middle
out a CKNotification you can
pull off APS level information

00:36:58.326 --> 00:37:02.126 A:middle
from it and you can also pull
off CloudKit level information


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.326 --> 00:37:02.126 A:middle
from it and you can also pull
off CloudKit level information

00:37:02.126 --> 00:37:02.966 A:middle
from it.

00:37:03.186 --> 00:37:06.486 A:middle
Here we're taking the
RecordID of the saved record

00:37:06.876 --> 00:37:08.036 A:middle
that caused the push to happen.

00:37:09.476 --> 00:37:12.626 A:middle
So between queries and
subscriptions we have an answer

00:37:12.626 --> 00:37:14.506 A:middle
to the big data,
tiny phone problem.

00:37:14.796 --> 00:37:17.036 A:middle
You're going to leave your
large data up in the cloud

00:37:17.336 --> 00:37:19.816 A:middle
and you're going to use
these two capabilities

00:37:19.816 --> 00:37:24.016 A:middle
to give your users a quick
view into that large dataset.

00:37:24.146 --> 00:37:28.846 A:middle
Now, I want to talk about
CloudKit user accounts.

00:37:30.986 --> 00:37:33.926 A:middle
As Olivier mentioned,
CloudKit is built on top

00:37:33.926 --> 00:37:35.526 A:middle
of the iCloud account
infrastructure.

00:37:36.026 --> 00:37:37.036 A:middle
So what does that mean?

00:37:37.036 --> 00:37:41.466 A:middle
I want to focus a little bit
on how accounts are exposed

00:37:41.466 --> 00:37:43.626 A:middle
to you explicitly
throughout the API.

00:37:44.546 --> 00:37:46.116 A:middle
When you think about
an account system,

00:37:46.426 --> 00:37:48.036 A:middle
the first thing you think
about is authentication

00:37:48.546 --> 00:37:50.936 A:middle
and CloudKit supports
authentication via the logged

00:37:50.936 --> 00:37:53.096 A:middle
in iCloud user, but
that's not, you know,

00:37:53.096 --> 00:37:54.886 A:middle
that's sort of behind the
scenes and you guys don't care

00:37:54.886 --> 00:37:55.866 A:middle
about that, that's implicit.

00:37:55.976 --> 00:37:57.626 A:middle
Let's talk about
the explicit things.

00:37:58.286 --> 00:38:00.556 A:middle
What do we give you
because we're built


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.286 --> 00:38:00.556 A:middle
What do we give you
because we're built

00:38:00.556 --> 00:38:01.746 A:middle
on top of iCloud accounts?

00:38:02.436 --> 00:38:05.006 A:middle
We give you identity; a way
of identifying the user.

00:38:05.716 --> 00:38:08.076 A:middle
We give you metadata;
the ability to save

00:38:08.076 --> 00:38:09.816 A:middle
and retrieve information
about users.

00:38:10.776 --> 00:38:13.186 A:middle
We do all of this in a
privacy conscientious manner

00:38:13.186 --> 00:38:14.476 A:middle
and we don't want
to disclose anything

00:38:14.476 --> 00:38:16.736 A:middle
if the user hasn't agreed to it

00:38:17.126 --> 00:38:19.066 A:middle
and lastly we give
users the ability

00:38:19.066 --> 00:38:21.856 A:middle
to discover their friends that
are using your application.

00:38:22.506 --> 00:38:24.336 A:middle
Let's dive into each
one of these.

00:38:24.566 --> 00:38:26.346 A:middle
First of all we're going
to talk about identity.

00:38:27.436 --> 00:38:29.076 A:middle
So, here's our model.

00:38:29.076 --> 00:38:30.836 A:middle
We've got our client,
our application running

00:38:30.836 --> 00:38:32.966 A:middle
on the client, and all
of these different users

00:38:32.966 --> 00:38:34.786 A:middle
and their private databases
up in the container.

00:38:36.376 --> 00:38:39.536 A:middle
Your specific client is
going to be linked to one

00:38:39.536 --> 00:38:40.856 A:middle
and only one of those users.

00:38:41.036 --> 00:38:45.396 A:middle
This is related to
the user that's logged

00:38:45.396 --> 00:38:47.496 A:middle
in via iCloud locally
on your device.

00:38:48.546 --> 00:38:51.556 A:middle
Because this is iCloud we've
got a rich backing store

00:38:51.556 --> 00:38:54.756 A:middle
of user information and
because iCloud is the one

00:38:55.136 --> 00:38:59.386 A:middle
that is hosting your container
we can correlate users.

00:38:59.636 --> 00:39:01.776 A:middle
For example, here we
see that the user,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.636 --> 00:39:01.776 A:middle
For example, here we
see that the user,

00:39:01.776 --> 00:39:04.116 A:middle
whose email address is
c at iCloud dot com,

00:39:04.536 --> 00:39:06.246 A:middle
is linked to your
current client.

00:39:07.366 --> 00:39:11.166 A:middle
So given this setup how are we
going to present an identity?

00:39:11.166 --> 00:39:13.356 A:middle
How are we going to let
you know, your client,

00:39:13.356 --> 00:39:16.436 A:middle
your application, know
what user is logged in?

00:39:16.926 --> 00:39:19.266 A:middle
Well, natively you might
think let's give them an

00:39:19.266 --> 00:39:19.916 A:middle
email address.

00:39:20.156 --> 00:39:21.876 A:middle
We're not going to
do that obviously.

00:39:22.446 --> 00:39:25.376 A:middle
That's private user
identifiable information

00:39:25.376 --> 00:39:26.636 A:middle
and we don't want
to give that out.

00:39:27.446 --> 00:39:29.416 A:middle
So, instead what we
do is on a container

00:39:29.416 --> 00:39:33.036 A:middle
by container basis we
come up with a random ID.

00:39:33.366 --> 00:39:35.586 A:middle
This is an identifier
that is stable

00:39:35.656 --> 00:39:39.036 A:middle
so that is your application no
matter what client it's running

00:39:39.036 --> 00:39:42.676 A:middle
on talking to this container
will get the same identifier,

00:39:43.096 --> 00:39:46.306 A:middle
but it's not identifying
the user via any

00:39:46.306 --> 00:39:47.166 A:middle
personal information.

00:39:48.056 --> 00:39:51.706 A:middle
So we feel confident
giving you this identifier.

00:39:52.066 --> 00:39:54.316 A:middle
You can take this identifier
and do with it what you will.

00:39:55.276 --> 00:39:58.796 A:middle
Note that different applications
running on your phone

00:39:58.796 --> 00:40:03.426 A:middle
because they're talking to
different containers are going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:58.796 --> 00:40:03.426 A:middle
because they're talking to
different containers are going

00:40:03.426 --> 00:40:06.256 A:middle
to get back different container
scoped RecordIdentifiers

00:40:06.476 --> 00:40:07.286 A:middle
for the same user.

00:40:08.146 --> 00:40:09.976 A:middle
This goes back to what we
talked about in the beginning

00:40:09.976 --> 00:40:14.926 A:middle
that we've got user
encapsulation.

00:40:15.046 --> 00:40:15.556 A:middle
So user identity.

00:40:15.676 --> 00:40:19.346 A:middle
We expose user identity
via API as a user RecordID.

00:40:20.016 --> 00:40:22.216 A:middle
It is a stable identifier
for this user.

00:40:22.606 --> 00:40:24.796 A:middle
It will be the same for
your application no matter

00:40:24.796 --> 00:40:26.086 A:middle
where your application
is running.

00:40:26.716 --> 00:40:29.296 A:middle
It's scoped to the container

00:40:29.576 --> 00:40:31.446 A:middle
so 2 different applications
are going to come

00:40:31.446 --> 00:40:33.726 A:middle
up with different
identifiers for the same user.

00:40:34.096 --> 00:40:36.196 A:middle
This is a feature.

00:40:36.196 --> 00:40:37.986 A:middle
Lastly this is an
independent API.

00:40:38.156 --> 00:40:40.006 A:middle
This is a section of
the CloudKit framework.

00:40:40.646 --> 00:40:42.076 A:middle
You can use this
in collaboration

00:40:42.076 --> 00:40:45.496 A:middle
with the database API or you can
use this completely separately.

00:40:45.756 --> 00:40:48.006 A:middle
We've given you enough
support that if you wanted

00:40:48.006 --> 00:40:51.076 A:middle
to you could implement
a login via iCloud flow

00:40:51.336 --> 00:40:53.496 A:middle
in your application using
the CloudKit framework.

00:40:54.426 --> 00:40:56.846 A:middle
Let's have a look at the code.

00:40:57.516 --> 00:41:00.806 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:57.516 --> 00:41:00.806 A:middle
[ Applause ]

00:41:01.306 --> 00:41:02.746 A:middle
All right let's have
a look at the code.

00:41:03.396 --> 00:41:06.106 A:middle
Because identity is a
container-scoped notion

00:41:06.246 --> 00:41:09.396 A:middle
and not a database-scoped
notion, we go to our container

00:41:09.396 --> 00:41:10.356 A:middle
to learn about our user.

00:41:11.116 --> 00:41:13.946 A:middle
Here we're asking our container
to fetch the user RecordID.

00:41:15.276 --> 00:41:18.116 A:middle
Now because we may have
to talk to the server

00:41:18.116 --> 00:41:20.666 A:middle
to figure this out, for example,
the first time you access

00:41:20.666 --> 00:41:22.886 A:middle
and try to learn about
a RecordID we have to go

00:41:22.886 --> 00:41:25.376 A:middle
to the server to do that
translation and come

00:41:25.376 --> 00:41:26.626 A:middle
up with a container-scoped info.

00:41:27.086 --> 00:41:29.566 A:middle
So, asynchronous and we
have to do error handling.

00:41:31.296 --> 00:41:32.666 A:middle
That's user identity.

00:41:32.966 --> 00:41:35.576 A:middle
Let's talk about user
metadata and quickly

00:41:35.576 --> 00:41:38.996 A:middle
to recap the problem what we
have here is we have a stable

00:41:38.996 --> 00:41:40.946 A:middle
identifier and we've
got a desire

00:41:41.006 --> 00:41:44.476 A:middle
to set key value pairs
based on that identifier.

00:41:45.106 --> 00:41:47.776 A:middle
I don't know about you but
to me that sounds very much

00:41:47.776 --> 00:41:49.326 A:middle
like what a record
was built to do.

00:41:49.906 --> 00:41:53.086 A:middle
So we expose users
as user records.

00:41:55.036 --> 00:41:56.086 A:middle
Looking inside a container

00:41:56.086 --> 00:41:58.696 A:middle
within a database we see
there is one user record

00:41:58.696 --> 00:41:59.886 A:middle
in the private database


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:00.296 --> 00:42:02.656 A:middle
that user record
represents your user.

00:42:03.576 --> 00:42:06.376 A:middle
There are many user records
inside the public database

00:42:06.656 --> 00:42:09.136 A:middle
representing each one of the
users of your application.

00:42:10.166 --> 00:42:11.886 A:middle
One of them will have a RecordID

00:42:12.096 --> 00:42:13.916 A:middle
that matches your
currently logged

00:42:13.916 --> 00:42:15.476 A:middle
in iCloud user's RecordID.

00:42:17.036 --> 00:42:18.666 A:middle
So, user metadata.

00:42:18.666 --> 00:42:21.166 A:middle
Exposed via our framework
as a user record.

00:42:21.666 --> 00:42:24.976 A:middle
There's one per database that
represents your current user.

00:42:26.356 --> 00:42:27.936 A:middle
User records in the
public database

00:42:27.936 --> 00:42:30.836 A:middle
like any other default
record are world readable.

00:42:32.446 --> 00:42:35.506 A:middle
They're treated mostly
like an ordinary record

00:42:35.776 --> 00:42:37.136 A:middle
with a record type
that we exposed

00:42:37.136 --> 00:42:39.386 A:middle
in the framework
CKRecord TypeUserRecord,

00:42:39.906 --> 00:42:41.786 A:middle
but there are a couple
of caveats.

00:42:42.666 --> 00:42:46.176 A:middle
First off these records
are reserved by the system.

00:42:46.486 --> 00:42:48.726 A:middle
You do not create a user record.

00:42:49.046 --> 00:42:51.136 A:middle
Rather you fetch an
existing one from the server.

00:42:51.896 --> 00:42:53.996 A:middle
What that means is
that you can be assured

00:42:53.996 --> 00:42:56.406 A:middle
that when you fetch a
record for your current user

00:42:56.586 --> 00:42:57.846 A:middle
but it has not been spoofed.

00:42:58.356 --> 00:42:59.996 A:middle
It was, indeed, iCloud
that created

00:42:59.996 --> 00:43:01.166 A:middle
that record in the first place.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.996 --> 00:43:01.166 A:middle
that record in the first place.

00:43:02.116 --> 00:43:04.526 A:middle
Secondly, we think that it
doesn't make sense for you

00:43:04.526 --> 00:43:06.916 A:middle
to be able to query the
entire set of user records

00:43:06.916 --> 00:43:07.986 A:middle
in the public database.

00:43:08.106 --> 00:43:10.496 A:middle
It doesn't really make sense to
be able to say I want to look

00:43:10.496 --> 00:43:12.936 A:middle
at all users whose first
name begins with A.

00:43:12.936 --> 00:43:17.176 A:middle
It's a little bit too course
grained for something that's so,

00:43:17.266 --> 00:43:19.076 A:middle
that we want to protect
privacy around.

00:43:19.636 --> 00:43:22.306 A:middle
So we don't allow you
to query user records.

00:43:22.996 --> 00:43:25.446 A:middle
Don't worry we're going to fix
that in a couple of slides.

00:43:26.396 --> 00:43:27.826 A:middle
All right so what
does it look like?

00:43:28.506 --> 00:43:30.566 A:middle
Here we have the same
code that we saw earlier

00:43:30.676 --> 00:43:32.196 A:middle
and we're fetching
a user RecordID.

00:43:32.716 --> 00:43:36.236 A:middle
Once I have that CKRecordID I
can go ahead and I can fetch

00:43:36.236 --> 00:43:38.896 A:middle
that record from either
database that I choose.

00:43:39.306 --> 00:43:41.866 A:middle
Here I'm choosing to fetch a
record with that identifier

00:43:42.006 --> 00:43:43.406 A:middle
from the public database.

00:43:44.326 --> 00:43:48.506 A:middle
Assuming that I don't get an
error I now had a live CKRecord

00:43:48.506 --> 00:43:51.306 A:middle
that represents this
user and I can treat it

00:43:51.306 --> 00:43:52.936 A:middle
like I would any other CKRecord.

00:43:53.616 --> 00:43:57.206 A:middle
I can pull records, excuse me,
I can pull key value pairs off

00:43:57.206 --> 00:44:00.376 A:middle
of it, I can set key value
pairs on it, and if I wanted to,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:57.206 --> 00:44:00.376 A:middle
of it, I can set key value
pairs on it, and if I wanted to,

00:44:00.376 --> 00:44:02.176 A:middle
I could go ahead and save
it back to the server.

00:44:02.176 --> 00:44:05.566 A:middle
Now let's talk about privacy.

00:44:06.246 --> 00:44:08.056 A:middle
We care very much about
our user's privacy.

00:44:09.956 --> 00:44:12.156 A:middle
Therefore, we disclose
no information,

00:44:12.276 --> 00:44:14.376 A:middle
no personally identifying
user information

00:44:14.766 --> 00:44:16.616 A:middle
about the current
user by default.

00:44:17.606 --> 00:44:21.446 A:middle
Now we recognize that in some
cases your application is going

00:44:21.446 --> 00:44:25.296 A:middle
to want to have limited access
to metadata about the user.

00:44:26.636 --> 00:44:30.766 A:middle
So, if you want that data, you
can request that from CloudKit.

00:44:31.546 --> 00:44:33.726 A:middle
When you do, we're going to
go to the user to make sure

00:44:33.726 --> 00:44:34.986 A:middle
that they're okay with that.

00:44:35.476 --> 00:44:36.326 A:middle
Here we see an example

00:44:36.326 --> 00:44:38.856 A:middle
of the party application
requesting the ability

00:44:38.896 --> 00:44:40.936 A:middle
for my user account
to be discoverable

00:44:40.936 --> 00:44:41.776 A:middle
within the application.

00:44:42.006 --> 00:44:45.256 A:middle
The user can either choose
to allow or deny that.

00:44:46.256 --> 00:44:48.796 A:middle
Assuming that the
user has acquiesced

00:44:48.866 --> 00:44:50.426 A:middle
to this privacy request,

00:44:50.876 --> 00:44:53.266 A:middle
we can go on to the next
phase, which is discovery.

00:44:53.536 --> 00:44:55.446 A:middle
So let's talk a little
bit about user discovery.

00:44:57.146 --> 00:44:57.706 A:middle
Here's our image.

00:44:57.706 --> 00:44:59.556 A:middle
We've got our client
talking to a container

00:44:59.556 --> 00:45:01.436 A:middle
and the container
is backed by iCloud


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.556 --> 00:45:01.436 A:middle
and the container
is backed by iCloud

00:45:01.496 --> 00:45:03.676 A:middle
and iCloud has all this
rich user information.

00:45:05.156 --> 00:45:07.806 A:middle
If we look a little bit
more on the client side,

00:45:07.956 --> 00:45:09.956 A:middle
we see there's actually
two different processes

00:45:09.956 --> 00:45:10.586 A:middle
involved here.

00:45:11.056 --> 00:45:12.376 A:middle
There's your client process

00:45:12.376 --> 00:45:14.426 A:middle
and then there's
the CloudKit process

00:45:14.426 --> 00:45:16.886 A:middle
and it's the CloudKit process
that's the one that's actually

00:45:16.886 --> 00:45:18.496 A:middle
talking over the wire.

00:45:19.476 --> 00:45:22.066 A:middle
So let's examine what
user discovery would look

00:45:22.066 --> 00:45:24.226 A:middle
like if you want to
discover information

00:45:24.226 --> 00:45:25.856 A:middle
about a user given a RecordID.

00:45:26.646 --> 00:45:30.076 A:middle
You take that RecordID and you
can send it off to CloudKit.

00:45:30.696 --> 00:45:33.116 A:middle
CloudKit is going to in turn
send it up to the container.

00:45:34.546 --> 00:45:36.156 A:middle
Once it hits the
container we're going

00:45:36.156 --> 00:45:38.626 A:middle
to ask the iCloud
account info to exchange

00:45:38.626 --> 00:45:41.286 A:middle
out for different information
for information about that user.

00:45:42.356 --> 00:45:45.396 A:middle
If that user has opted
in to discoverability,

00:45:45.516 --> 00:45:46.846 A:middle
we're going to get
information back.

00:45:47.616 --> 00:45:49.566 A:middle
That information can
traverse back to CloudKit

00:45:49.666 --> 00:45:52.406 A:middle
and back via the process
boundary over to your client,

00:45:53.686 --> 00:45:55.606 A:middle
but we're not restricted
to just RecordIDs.

00:45:56.216 --> 00:45:58.336 A:middle
If your user enters
in an email address,

00:45:58.336 --> 00:45:59.786 A:middle
we can do the same
sort of dance.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:00.166 --> 00:46:02.716 A:middle
This email address is sent from
your client over to CloudKit

00:46:02.716 --> 00:46:05.416 A:middle
and CloudKit is then going
to hash it out a whole bunch

00:46:05.416 --> 00:46:08.776 A:middle
of times so that we're not
sending personal info off the

00:46:08.776 --> 00:46:10.946 A:middle
client, and we'll send
that up to the container.

00:46:11.836 --> 00:46:14.786 A:middle
That container exchanges it
with iCloud and if the target

00:46:14.786 --> 00:46:17.406 A:middle
of this discovery has opted
in to discoverability,

00:46:17.406 --> 00:46:19.616 A:middle
we're going to get
a result sent back.

00:46:20.056 --> 00:46:21.536 A:middle
Those results can
go back to CloudKit

00:46:21.536 --> 00:46:25.276 A:middle
and can traverse back
up to your client.

00:46:25.696 --> 00:46:26.976 A:middle
Now, I'd like to think
that are we are pretty good

00:46:26.976 --> 00:46:29.056 A:middle
about naming things in
CloudKit but this one we sort

00:46:29.056 --> 00:46:30.266 A:middle
of didn't really do well.

00:46:30.686 --> 00:46:33.496 A:middle
So we offer a different
way of doing user discovery

00:46:33.496 --> 00:46:35.856 A:middle
that we call the whole address
book and it's a way for you

00:46:35.856 --> 00:46:38.206 A:middle
to discover the whole
address book.

00:46:38.466 --> 00:46:41.996 A:middle
The way this works is that your
client is going to say I would

00:46:41.996 --> 00:46:45.356 A:middle
like to discover the user
RecordIDs and more information

00:46:45.846 --> 00:46:48.386 A:middle
about every user that is friends

00:46:48.456 --> 00:46:50.466 A:middle
with my currently
logged in iCloud user.

00:46:51.516 --> 00:46:53.896 A:middle
You send that request over
to the CloudKit process.

00:46:54.426 --> 00:46:56.796 A:middle
The CloudKit process
is then going to pull

00:46:56.796 --> 00:46:57.996 A:middle
in the user's address book.

00:46:57.996 --> 00:47:00.386 A:middle
We're going to take all
the emailed addresses


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:57.996 --> 00:47:00.386 A:middle
We're going to take all
the emailed addresses

00:47:00.386 --> 00:47:02.246 A:middle
in that address book and
we're going to hash them up

00:47:02.766 --> 00:47:04.096 A:middle
and we're going to
send, you know,

00:47:04.096 --> 00:47:05.986 A:middle
a non-personally
identifying version

00:47:05.986 --> 00:47:08.116 A:middle
of that address book
up to the container.

00:47:09.366 --> 00:47:11.076 A:middle
The container is going
to send it off to iCloud

00:47:11.606 --> 00:47:14.986 A:middle
and for those members of my
address book that have opted

00:47:14.986 --> 00:47:17.886 A:middle
into discoverability I'm going
to learn information about them.

00:47:18.846 --> 00:47:20.576 A:middle
That information is going
to come back to CloudKit

00:47:20.666 --> 00:47:21.426 A:middle
and it's going to be sent

00:47:21.426 --> 00:47:23.726 A:middle
over the process
boundary to your client.

00:47:24.776 --> 00:47:27.256 A:middle
Now if you'll note at
no point did your client

00:47:27.456 --> 00:47:30.706 A:middle
in this little flow have access
to the user's address book.

00:47:31.506 --> 00:47:34.046 A:middle
What this means is that we
can give you the support

00:47:34.346 --> 00:47:37.766 A:middle
without requiring that your
user allows your application

00:47:37.766 --> 00:47:40.186 A:middle
to the address book meaning
that you don't have to have

00:47:40.186 --> 00:47:41.776 A:middle
that blue alert, which
is now the white alert,

00:47:42.186 --> 00:47:44.466 A:middle
giving your application
access to the address book.

00:47:45.006 --> 00:47:47.326 A:middle
You can leverage it
without access to it.

00:47:48.516 --> 00:47:53.896 A:middle
[ Applause ]

00:47:54.396 --> 00:47:55.456 A:middle
So user discovery.

00:47:55.886 --> 00:47:57.326 A:middle
These are the three
different kinds of inputs

00:47:57.326 --> 00:47:58.656 A:middle
that we can have
for user discovery.

00:47:58.656 --> 00:48:01.506 A:middle
You can start off with a user
RecordID, an email address


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:58.656 --> 00:48:01.506 A:middle
You can start off with a user
RecordID, an email address

00:48:01.586 --> 00:48:04.076 A:middle
or request to view the
entire address book.

00:48:04.936 --> 00:48:06.376 A:middle
What do you get back
from user discovery?

00:48:06.866 --> 00:48:08.366 A:middle
Well, you'll get
back a user RecordID.

00:48:08.366 --> 00:48:10.956 A:middle
In the latter two cases,
that's new information.

00:48:11.816 --> 00:48:14.376 A:middle
You also get back the first
and last name of this user.

00:48:15.346 --> 00:48:18.356 A:middle
Of course it bears
repeating first

00:48:18.356 --> 00:48:20.766 A:middle
and last name is personally
identifying information

00:48:21.116 --> 00:48:23.936 A:middle
so you're only going to get
discovery results for users

00:48:23.936 --> 00:48:25.856 A:middle
that have opted into
discoverability.

00:48:26.386 --> 00:48:30.086 A:middle
Let's have a look
at some code here.

00:48:31.906 --> 00:48:35.976 A:middle
Here we are asking our default
container to discover all

00:48:35.976 --> 00:48:39.606 A:middle
of my users that are
part of my address book.

00:48:41.486 --> 00:48:43.916 A:middle
In the response, again,
asynchronous error handling

00:48:44.506 --> 00:48:47.686 A:middle
in the successful response
case what we see is

00:48:47.686 --> 00:48:50.776 A:middle
that we get back a
CKDiscoveredUserInfo object

00:48:51.086 --> 00:48:54.316 A:middle
and that user info from that
I can pull a user RecordID

00:48:54.446 --> 00:48:55.546 A:middle
and a first and last name.

00:48:56.946 --> 00:48:59.046 A:middle
So these are really
the four tent poles

00:48:59.046 --> 00:49:01.286 A:middle
of how we do user accounts.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.046 --> 00:49:01.286 A:middle
of how we do user accounts.

00:49:01.286 --> 00:49:05.196 A:middle
We give you a stable identifier,
we give you the ability to store

00:49:05.196 --> 00:49:09.946 A:middle
and retrieve metadata about
users, we protect user's privacy

00:49:10.506 --> 00:49:12.176 A:middle
and we give your
users the ability

00:49:12.176 --> 00:49:13.856 A:middle
to discover their friends
in your application.

00:49:14.856 --> 00:49:17.396 A:middle
Now, to tell you when it's
appropriate to use CloudKit

00:49:17.396 --> 00:49:19.166 A:middle
versus some of the other
iCloud technologies

00:49:19.166 --> 00:49:20.406 A:middle
that we already have exposed,

00:49:20.746 --> 00:49:22.256 A:middle
I'd like to invite
back up Olivier Bonnet.

00:49:23.516 --> 00:49:29.776 A:middle
[ Applause ]

00:49:30.276 --> 00:49:30.806 A:middle
&gt;&gt; Thank you, Paul.

00:49:32.216 --> 00:49:37.726 A:middle
So CloudKit is the new framework
but it doesn't obsolete

00:49:37.726 --> 00:49:40.406 A:middle
or deprecate any of
the existing tools.

00:49:40.546 --> 00:49:43.736 A:middle
It's really just a new
tool in your toolbox.

00:49:44.256 --> 00:49:49.276 A:middle
Let's look at all the four
tools you now have and look

00:49:49.276 --> 00:49:52.416 A:middle
at where different use cases
where we think they make sense

00:49:52.416 --> 00:49:54.696 A:middle
and they're appropriate to use.

00:49:54.916 --> 00:49:57.036 A:middle
So, first, iCloud
Key Value Store.

00:49:57.036 --> 00:50:03.126 A:middle
iCloud Key Value Store keeps
small piles of data up to date


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:57.036 --> 00:50:03.126 A:middle
iCloud Key Value Store keeps
small piles of data up to date

00:50:03.126 --> 00:50:05.666 A:middle
between your app and
the iCloud servers.

00:50:06.106 --> 00:50:07.876 A:middle
This is done asynchronously.

00:50:08.036 --> 00:50:09.736 A:middle
Your app doesn't
really need to care

00:50:09.736 --> 00:50:11.966 A:middle
about when and how this is done.

00:50:12.376 --> 00:50:14.936 A:middle
We think this is great
for small amounts of data

00:50:14.936 --> 00:50:18.526 A:middle
like application
preferences game states.

00:50:19.056 --> 00:50:22.996 A:middle
Conflict resolution is pretty
simple, last writer wins.

00:50:23.136 --> 00:50:26.276 A:middle
So, that's iCloud
Key Value Store.

00:50:27.836 --> 00:50:31.376 A:middle
iCloud Drive builds on top

00:50:31.376 --> 00:50:35.436 A:middle
of the existing iCloud
document APIs.

00:50:35.576 --> 00:50:38.446 A:middle
Doing so it provides full
offline cache on OS X;

00:50:38.826 --> 00:50:40.926 A:middle
all the files on
the iCloud drive

00:50:40.926 --> 00:50:43.506 A:middle
of the user are downloaded
on the OS X.

00:50:43.506 --> 00:50:44.796 A:middle
It's completely unstructured

00:50:44.796 --> 00:50:46.746 A:middle
and internally tied
to the file system.

00:50:46.746 --> 00:50:51.246 A:middle
You use the file coordination
APIs to read and write data

00:50:51.756 --> 00:50:54.846 A:middle
in your application iCloud
container on the file system

00:50:54.846 --> 00:50:58.636 A:middle
and the iCloud Drive daemon
takes care of uploading

00:50:58.636 --> 00:51:05.176 A:middle
and downloading those changes
up and from the iCloud servers.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:58.636 --> 00:51:05.176 A:middle
and downloading those changes
up and from the iCloud servers.

00:51:06.156 --> 00:51:09.776 A:middle
We think it's great for document
centric apps or apps that need

00:51:09.806 --> 00:51:11.826 A:middle
to deal with an existing
file formats.

00:51:13.236 --> 00:51:16.006 A:middle
ICloud Core Data built on top

00:51:16.006 --> 00:51:21.056 A:middle
of iCloud Drive replicates
off specific user data

00:51:22.016 --> 00:51:23.886 A:middle
between all the user's devices.

00:51:24.416 --> 00:51:27.176 A:middle
It's great for keeping
private structured data in sync

00:51:27.486 --> 00:51:30.636 A:middle
but because it downloads
all the data

00:51:30.636 --> 00:51:34.356 A:middle
to all devices you're also
constrained to the size

00:51:34.356 --> 00:51:36.426 A:middle
of the smallest device
in that case.

00:51:37.656 --> 00:51:40.276 A:middle
Enters CloudKit, the
new kid on the block

00:51:40.276 --> 00:51:43.546 A:middle
and we think there are a
number of interesting use cases

00:51:43.546 --> 00:51:45.716 A:middle
where CloudKit makes sense

00:51:45.716 --> 00:51:50.846 A:middle
and complements pretty well
the existing technologies.

00:51:50.956 --> 00:51:52.816 A:middle
So first any public data.

00:51:53.786 --> 00:51:57.476 A:middle
If your app, if you need to
give access to all the users

00:51:57.476 --> 00:52:00.046 A:middle
of your app to large datasets,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:57.476 --> 00:52:00.046 A:middle
of your app to large datasets,

00:52:00.046 --> 00:52:05.536 A:middle
CloudKit public databases are
pretty good compiling tool.

00:52:07.136 --> 00:52:09.796 A:middle
CloudKit supports both
structured and bulk data.

00:52:10.276 --> 00:52:14.496 A:middle
So you can use it to store large
files on iCloud and we take care

00:52:14.496 --> 00:52:19.886 A:middle
of downloading and uploading
them to the iCloud servers.

00:52:20.806 --> 00:52:25.556 A:middle
As Paul described, CloudKit has
good support for large datasets

00:52:25.556 --> 00:52:28.706 A:middle
where your app will want
to give a specific slice,

00:52:28.706 --> 00:52:32.526 A:middle
a specific view of large
data set to the user

00:52:32.526 --> 00:52:35.426 A:middle
at a giver point in time.

00:52:35.616 --> 00:52:43.736 A:middle
CloudKit lets you use the
existing accounts infrastructure

00:52:43.736 --> 00:52:46.236 A:middle
whether you need to
identify the user

00:52:46.666 --> 00:52:52.766 A:middle
or to let the user discover his
friends using your app CloudKit

00:52:53.006 --> 00:52:55.886 A:middle
enables you to do that.

00:52:56.746 --> 00:52:58.486 A:middle
Last but not least compared

00:52:58.486 --> 00:53:03.246 A:middle
to the other three technologies
we think CloudKit is closer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.486 --> 00:53:03.246 A:middle
to the other three technologies
we think CloudKit is closer

00:53:03.246 --> 00:53:04.426 A:middle
to the middle in some way.

00:53:05.086 --> 00:53:08.906 A:middle
In this case when you're using
CloudKit, your app is really

00:53:08.906 --> 00:53:12.756 A:middle
in control of when
the app is uploaded

00:53:12.756 --> 00:53:14.316 A:middle
or downloaded from the server.

00:53:14.566 --> 00:53:17.706 A:middle
Your app is controllng
the operations

00:53:17.706 --> 00:53:22.076 A:middle
and that is also why you need
to do this [inaudible] will do.

00:53:24.736 --> 00:53:28.266 A:middle
So, in summary, what
have we covered today?

00:53:29.076 --> 00:53:32.106 A:middle
CloudKit gives you
access to iCloud servers.

00:53:33.186 --> 00:53:36.366 A:middle
It supports both
public and private data.

00:53:37.576 --> 00:53:39.526 A:middle
It supports both
structured and bulk data.

00:53:39.526 --> 00:53:42.766 A:middle
You can use it for large files.

00:53:42.896 --> 00:53:46.056 A:middle
It leverages the existing
iCloud account infrastructure

00:53:46.056 --> 00:53:50.716 A:middle
which means that the over
400 million iCloud accounts

00:53:50.716 --> 00:53:53.716 A:middle
out there are here for
you to take advantage of.

00:53:54.426 --> 00:53:56.896 A:middle
Apple is building
on it in a big way.

00:53:57.146 --> 00:54:00.916 A:middle
Both iCloud Drive and iCloud
file Library were built


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:57.146 --> 00:54:00.916 A:middle
Both iCloud Drive and iCloud
file Library were built

00:54:00.916 --> 00:54:02.656 A:middle
from scratch on top of CloudKit.

00:54:04.426 --> 00:54:08.036 A:middle
We're super excited to see what
you're going to build on top

00:54:08.036 --> 00:54:08.996 A:middle
of this new framework.

00:54:10.766 --> 00:54:14.286 A:middle
So for more information
Dave is our evangelist.

00:54:14.286 --> 00:54:16.556 A:middle
We have some awesome
framework reference

00:54:16.556 --> 00:54:20.176 A:middle
on developer.apple.com website
as well as developer forums.

00:54:21.176 --> 00:54:24.036 A:middle
We have an advanced
CloudKit session on Thursday

00:54:24.036 --> 00:54:26.526 A:middle
and Jacob is going to tell you
everything you want to know

00:54:26.526 --> 00:54:30.226 A:middle
about that, Data Modeling and
Advanced Record Manipulations.

00:54:30.996 --> 00:54:32.276 A:middle
Thank you very much
for being here

00:54:32.276 --> 00:54:32.976 A:middle
and thank you for
your attention.

00:54:33.508 --> 00:54:35.508 A:middle
[ Applause ]

