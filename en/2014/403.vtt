WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:11.516 --> 00:00:14.546 A:middle
[ Applause ]

00:00:15.046 --> 00:00:15.356 A:middle
&gt;&gt; Good afternoon.

00:00:15.356 --> 00:00:15.716 A:middle
Welcome.

00:00:16.186 --> 00:00:17.566 A:middle
Welcome to Intermediate Swift.

00:00:18.656 --> 00:00:20.666 A:middle
My name is Brian Lanier.

00:00:20.666 --> 00:00:22.606 A:middle
I'm an engineer in
Developer Publications.

00:00:22.866 --> 00:00:25.596 A:middle
Later I'll be joined on stage
by my colleague, Joe Groff,

00:00:25.966 --> 00:00:27.836 A:middle
who is an engineer on
the Swift compiler team.

00:00:28.266 --> 00:00:31.786 A:middle
We're both really excited to be
here today to talk with you more

00:00:32.156 --> 00:00:34.316 A:middle
in depth about the Swift
programming language.

00:00:34.976 --> 00:00:36.676 A:middle
I've been in the labs
the last couple of days

00:00:36.676 --> 00:00:38.496 A:middle
and I've been very
impressed already

00:00:38.496 --> 00:00:40.506 A:middle
with what you've been
able to do with Swift,

00:00:41.156 --> 00:00:44.026 A:middle
and I think that to go
into some more detail

00:00:44.026 --> 00:00:46.426 A:middle
on some really key features
of Swift, you'll be able

00:00:46.426 --> 00:00:48.736 A:middle
to take advantage of
those features even more

00:00:48.736 --> 00:00:52.716 A:middle
so in your code.

00:00:52.866 --> 00:00:56.306 A:middle
So, in particular, we're
going to look at some features

00:00:56.306 --> 00:00:59.066 A:middle
in some more detail
including optionals

00:00:59.246 --> 00:01:02.206 A:middle
and how you can use them
to make your code safer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.246 --> 00:01:02.206 A:middle
and how you can use them
to make your code safer.

00:01:02.826 --> 00:01:05.245 A:middle
We're going to talk to you
about memory management in Swift

00:01:05.245 --> 00:01:06.856 A:middle
and how it's largely automatic.

00:01:07.966 --> 00:01:09.916 A:middle
We're also going to talk
about initialization

00:01:10.486 --> 00:01:13.386 A:middle
and how you can take advantage
of the power of closures

00:01:13.686 --> 00:01:15.226 A:middle
and pattern matching
in your code.

00:01:15.516 --> 00:01:19.406 A:middle
So, I want to begin
by looking at one

00:01:19.406 --> 00:01:22.666 A:middle
of Swift's most powerful
features, optionals,

00:01:24.096 --> 00:01:25.566 A:middle
but first I want to take a look

00:01:25.566 --> 00:01:27.986 A:middle
at why we might need
optionals in the first place.

00:01:29.686 --> 00:01:32.206 A:middle
Say you need to work with
input data from a user.

00:01:32.676 --> 00:01:34.586 A:middle
Here we're asking
for the user's age.

00:01:35.356 --> 00:01:38.406 A:middle
The response comes in as
a string but say we need

00:01:38.406 --> 00:01:39.546 A:middle
to convert that string

00:01:39.546 --> 00:01:43.876 A:middle
to an integer using
this toInt method here.

00:01:44.096 --> 00:01:47.126 A:middle
Now when the enter
users a string

00:01:47.126 --> 00:01:48.416 A:middle
that represents a valid integer,

00:01:48.806 --> 00:01:53.066 A:middle
the toInt method returns the
correct result but, however,

00:01:53.066 --> 00:01:56.726 A:middle
because you're not in control
of the user's response you have

00:01:57.276 --> 00:01:59.696 A:middle
to deal with cases or situations

00:01:59.696 --> 00:02:02.376 A:middle
where there's not an
obvious value to return.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.696 --> 00:02:02.376 A:middle
where there's not an
obvious value to return.

00:02:03.346 --> 00:02:05.656 A:middle
The user has full control
over what they're entering in.

00:02:05.706 --> 00:02:09.936 A:middle
So, if they try to
get cute or snippy,

00:02:11.566 --> 00:02:15.426 A:middle
we don't really have a clear
value to return in this case.

00:02:15.856 --> 00:02:19.086 A:middle
So, what do we do?

00:02:19.086 --> 00:02:20.346 A:middle
What value do we return?

00:02:20.346 --> 00:02:23.686 A:middle
Well, we have lots
of options, right?

00:02:25.086 --> 00:02:29.766 A:middle
Well, as you're probably aware,
various sentinels have been used

00:02:30.306 --> 00:02:32.636 A:middle
in various different
languages to model these kinds

00:02:32.636 --> 00:02:35.506 A:middle
of problems, but
having so many sentinels

00:02:35.506 --> 00:02:37.326 A:middle
around isn't very good.

00:02:37.436 --> 00:02:38.636 A:middle
It's not very safe.

00:02:38.976 --> 00:02:41.346 A:middle
It's a common source of bugs
and problems in your code.

00:02:41.826 --> 00:02:42.826 A:middle
For one you have to know

00:02:42.826 --> 00:02:45.396 A:middle
which of these possible
sentinels was chosen

00:02:45.396 --> 00:02:48.766 A:middle
by the author of the API and
then you have to remember

00:02:48.766 --> 00:02:51.036 A:middle
which one to check against it.

00:02:52.456 --> 00:02:53.866 A:middle
So this isn't a very
good pattern.

00:02:54.126 --> 00:02:56.066 A:middle
So really how should
we model this?

00:02:57.256 --> 00:03:00.006 A:middle
Well, in Swift, we
model problems


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:57.256 --> 00:03:00.006 A:middle
Well, in Swift, we
model problems

00:03:00.006 --> 00:03:02.606 A:middle
like these using
the optional type.

00:03:03.436 --> 00:03:07.446 A:middle
The optional type represents
possibly missing values

00:03:07.736 --> 00:03:09.506 A:middle
of any type whatsoever.

00:03:10.816 --> 00:03:17.366 A:middle
The optional type has 2 discrete
states; a default, nil state,

00:03:18.176 --> 00:03:23.296 A:middle
which represents literally the
absence of any value whatsoever

00:03:23.786 --> 00:03:25.376 A:middle
and optionals are
defaulted to nil.

00:03:25.836 --> 00:03:27.796 A:middle
You've probably seen a couple
of examples and options.

00:03:27.796 --> 00:03:30.646 A:middle
If you've seen the introduction
to Swift Talk, you write them

00:03:30.646 --> 00:03:33.496 A:middle
by writing the base height
followed by a question mark

00:03:33.546 --> 00:03:34.866 A:middle
to indicate their optionality.

00:03:36.116 --> 00:03:41.226 A:middle
Now, in Swift, nil is not
like Swift in Objective-C

00:03:41.516 --> 00:03:44.196 A:middle
where in Objective-C Swift is
an object pointer to nothing

00:03:44.456 --> 00:03:46.356 A:middle
and it only works for
the reference types.

00:03:47.226 --> 00:03:49.886 A:middle
In Swift, nil is a
true sentinel value.

00:03:50.156 --> 00:03:52.076 A:middle
It works with any
type whatsoever.

00:03:52.116 --> 00:03:54.836 A:middle
It literally just means
there's no value present.

00:03:56.266 --> 00:03:58.706 A:middle
The other state of an
option includes a presence

00:03:58.706 --> 00:04:01.226 A:middle
of a value that's been
wrapped up in the optional.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.706 --> 00:04:01.226 A:middle
of a value that's been
wrapped up in the optional.

00:04:01.226 --> 00:04:04.056 A:middle
Think of optionals as this
wrapper container that wraps

00:04:04.056 --> 00:04:06.776 A:middle
up values when there
are values present.

00:04:06.776 --> 00:04:09.316 A:middle
So here we're setting the
value of optional number to 6

00:04:09.316 --> 00:04:12.346 A:middle
and the value is wrapped
up in the optional.

00:04:12.866 --> 00:04:15.366 A:middle
We'll see how to unwrap
this value and access it

00:04:15.886 --> 00:04:16.766 A:middle
in just a little while.

00:04:18.495 --> 00:04:24.706 A:middle
So, now that we have a single
sentinel value that works

00:04:24.706 --> 00:04:26.826 A:middle
with any type at
all even integers,

00:04:27.506 --> 00:04:29.566 A:middle
it's clear what this
method should return.

00:04:29.566 --> 00:04:33.446 A:middle
It's clear that whenever we
have a value that's not valid,

00:04:33.536 --> 00:04:35.166 A:middle
we should just return an
optional and, in fact,

00:04:35.696 --> 00:04:37.916 A:middle
the toInt method is defined
in the standard library

00:04:37.986 --> 00:04:41.196 A:middle
under string type and it does
just that it returns nil.

00:04:42.066 --> 00:04:44.596 A:middle
Now because we have optionals,

00:04:45.066 --> 00:04:47.276 A:middle
we also have non-optional
types as well.

00:04:47.276 --> 00:04:49.166 A:middle
So what are non-optional types?

00:04:49.306 --> 00:04:51.846 A:middle
Well, they're just ordinary
types you would think they are.

00:04:52.146 --> 00:04:55.036 A:middle
Integers, strings, even
your custom objects.

00:04:55.396 --> 00:05:00.016 A:middle
And the great thing about
non-optional types is


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:55.396 --> 00:05:00.016 A:middle
And the great thing about
non-optional types is

00:05:00.016 --> 00:05:01.706 A:middle
that they can't be nil.

00:05:01.706 --> 00:05:04.126 A:middle
And we think this is pretty cool

00:05:04.126 --> 00:05:06.606 A:middle
because this makes your
code safe and predictable.

00:05:06.606 --> 00:05:08.306 A:middle
When you declare a value

00:05:08.306 --> 00:05:11.796 A:middle
of a non-optional
type, it can't be nil.

00:05:11.796 --> 00:05:13.776 A:middle
You can be sure that it's
there when you need it

00:05:14.416 --> 00:05:15.506 A:middle
and you can't be surprised

00:05:15.506 --> 00:05:18.496 A:middle
by unexpected nil values
propagating throughout

00:05:19.146 --> 00:05:21.026 A:middle
your code.

00:05:21.216 --> 00:05:22.996 A:middle
So, now that we know
what optional types are

00:05:22.996 --> 00:05:25.056 A:middle
and what they represent
let's see how we can use them

00:05:25.056 --> 00:05:27.856 A:middle
in our code, for example,
to write a function

00:05:28.596 --> 00:05:30.206 A:middle
that returns an optional type.

00:05:31.016 --> 00:05:33.496 A:middle
So here we're going to write a
function that looks for a string

00:05:34.286 --> 00:05:35.496 A:middle
in an array of strings and if

00:05:35.496 --> 00:05:38.196 A:middle
that string has found the array
it simply returns the index,

00:05:39.176 --> 00:05:41.416 A:middle
but as you might guess,
this is a case in which

00:05:42.436 --> 00:05:45.216 A:middle
if the string isn't found we
need some value to indicate

00:05:45.216 --> 00:05:48.156 A:middle
that failure and because
we have nil and optionals

00:05:48.156 --> 00:05:51.346 A:middle
at our disposal, let's go ahead
and change return pipe here

00:05:51.466 --> 00:05:54.336 A:middle
to an optional by adding the
question mark at the end.

00:05:55.326 --> 00:05:56.956 A:middle
So, let's implement
the function.

00:05:56.956 --> 00:05:58.856 A:middle
The first thing we need
to is enumerate the array

00:05:58.856 --> 00:06:00.626 A:middle
and here we're using
the enumerate method


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.856 --> 00:06:00.626 A:middle
and here we're using
the enumerate method

00:06:00.626 --> 00:06:03.136 A:middle
to find the standard library
which actually enumerates

00:06:03.136 --> 00:06:07.586 A:middle
to an array and returns as
tuple, the index and the value

00:06:07.586 --> 00:06:09.546 A:middle
of each value in the array.

00:06:09.546 --> 00:06:14.086 A:middle
We can use that in the 4N
statement here and check to see

00:06:14.086 --> 00:06:16.626 A:middle
if the string that we're looking
for matches the value and if

00:06:16.626 --> 00:06:18.246 A:middle
so simply return the integer.

00:06:18.696 --> 00:06:21.746 A:middle
Now, we're returning an integer
here but then it gets wrapped

00:06:21.746 --> 00:06:24.226 A:middle
up as we said in the
optional return type

00:06:24.486 --> 00:06:27.756 A:middle
and because we have nil at our
disposal, we know exactly what

00:06:27.756 --> 00:06:30.786 A:middle
to do when we don't
have a valid result.

00:06:30.916 --> 00:06:31.946 A:middle
We just simply return nil.

00:06:32.586 --> 00:06:36.296 A:middle
Now, as I said, we need
to unwrap optionals.

00:06:36.666 --> 00:06:41.986 A:middle
So, let's use this function here
to look through an array and try

00:06:41.986 --> 00:06:43.456 A:middle
to find a name in this array.

00:06:44.086 --> 00:06:47.326 A:middle
Here you can clearly see that
the string that we're looking

00:06:47.326 --> 00:06:50.306 A:middle
for is in the array so we
have a valid result to return.

00:06:51.176 --> 00:06:52.316 A:middle
Then we can check though.

00:06:52.406 --> 00:06:55.166 A:middle
We always want to make
sure the value is present

00:06:55.166 --> 00:06:58.346 A:middle
so we can simply ask if the
index value isn't nil here

00:06:59.076 --> 00:07:01.846 A:middle
and notice that I don't, I'm not
checking explicitly against nil


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.076 --> 00:07:01.846 A:middle
and notice that I don't, I'm not
checking explicitly against nil

00:07:02.236 --> 00:07:05.146 A:middle
and that's because optionals
can be used in Boolean context.

00:07:05.636 --> 00:07:08.126 A:middle
That means that you can check
them directly very naturally

00:07:08.126 --> 00:07:08.896 A:middle
like I've done here.

00:07:09.846 --> 00:07:13.346 A:middle
So if the value is present,
which it is, we can simply try

00:07:13.346 --> 00:07:16.356 A:middle
to use that value in the
subscript of the array,

00:07:16.626 --> 00:07:19.236 A:middle
but if we've done it like
this we have a problem

00:07:20.056 --> 00:07:23.936 A:middle
because the array is expecting
a non-optional integer,

00:07:23.936 --> 00:07:27.206 A:middle
but we've said that the function
returns an optional integer.

00:07:27.826 --> 00:07:29.176 A:middle
So the types don't match here

00:07:29.176 --> 00:07:30.406 A:middle
and the compiler
will let us know

00:07:30.406 --> 00:07:33.476 A:middle
that first before we use it we
need to unwrap the optionals.

00:07:34.146 --> 00:07:35.846 A:middle
One way we can unwrap optionals,

00:07:36.206 --> 00:07:39.236 A:middle
is using the force unwrapping
operator which simply consists

00:07:39.236 --> 00:07:40.306 A:middle
of an exclamation mark.

00:07:41.106 --> 00:07:43.886 A:middle
You write the exclamation
mark after the optional value

00:07:43.886 --> 00:07:44.656 A:middle
that you wish to unwrap.

00:07:46.176 --> 00:07:50.396 A:middle
And here because our search
returned a valid response,

00:07:51.066 --> 00:07:53.536 A:middle
we can simply print out
the result, but you have

00:07:53.536 --> 00:07:55.326 A:middle
to be careful as I
said we should check

00:07:55.436 --> 00:07:57.756 A:middle
to make sure the value is nil
first before we unwrap it.

00:07:58.206 --> 00:08:00.576 A:middle
So if we try to use the forced
unwrapping operator here


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.206 --> 00:08:00.576 A:middle
So if we try to use the forced
unwrapping operator here

00:08:01.056 --> 00:08:04.186 A:middle
without checking, we would
actually get a runtime

00:08:04.186 --> 00:08:06.606 A:middle
assertion, a runtime
error because we need

00:08:06.606 --> 00:08:08.866 A:middle
to make sure the value
is there and we're trying

00:08:08.866 --> 00:08:11.486 A:middle
to force it when it's not.

00:08:11.756 --> 00:08:14.316 A:middle
So instead in Swift we have
a better way of doing this

00:08:14.636 --> 00:08:16.766 A:middle
where we can actually
test and unwrap

00:08:17.756 --> 00:08:20.506 A:middle
at the same time using what
we call optional binding.

00:08:21.126 --> 00:08:22.426 A:middle
Optional binding uses this

00:08:22.426 --> 00:08:24.896 A:middle
if let syntax you
may have seen earlier

00:08:24.896 --> 00:08:26.086 A:middle
in the Introduction
to Swift Talk.

00:08:27.476 --> 00:08:29.366 A:middle
So, the if let statement,
how does it work?

00:08:29.536 --> 00:08:33.096 A:middle
Well, first as I said
it tests so it tests

00:08:33.096 --> 00:08:36.616 A:middle
to see the optional type here
to see if it's actually present

00:08:36.616 --> 00:08:40.696 A:middle
or if its value is nil, and
if it's not nil, it assigns,

00:08:40.696 --> 00:08:43.265 A:middle
unwraps and assigns
a non-optional type

00:08:43.936 --> 00:08:47.006 A:middle
to the index value here,
this temporary constant,

00:08:47.226 --> 00:08:49.486 A:middle
and you can use a temporary
constant because it's unwrapped

00:08:50.396 --> 00:08:53.466 A:middle
as the index, as a
subscript to this array

00:08:54.426 --> 00:08:55.746 A:middle
and everything should
work just fine,

00:08:56.926 --> 00:08:58.666 A:middle
but we can actually
combine these together.

00:08:58.666 --> 00:09:01.416 A:middle
There's no need to actually
include a temporary variable.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.666 --> 00:09:01.416 A:middle
There's no need to actually
include a temporary variable.

00:09:01.656 --> 00:09:06.596 A:middle
We can simply evaluate the
result of the function directly

00:09:06.596 --> 00:09:08.796 A:middle
in line and then assign
that after it's unwrapped

00:09:08.796 --> 00:09:12.126 A:middle
to the index here, which now
index is a non-optional Int,

00:09:12.226 --> 00:09:14.966 A:middle
just regular old Int.

00:09:15.866 --> 00:09:19.286 A:middle
But that's what optional bind
looks like in a simple case.

00:09:19.286 --> 00:09:20.406 A:middle
Let's look at how it might look

00:09:20.406 --> 00:09:22.506 A:middle
if we did something a
little bit more complex.

00:09:23.306 --> 00:09:26.296 A:middle
So, to do that, let's set
up a couple of classes.

00:09:26.296 --> 00:09:29.136 A:middle
Say we have a person class
that has an optional residence

00:09:30.266 --> 00:09:32.106 A:middle
and a residence which
has an optional address.

00:09:33.066 --> 00:09:34.636 A:middle
Finally, we have
an address class

00:09:34.636 --> 00:09:37.466 A:middle
that has 3 optional
properties; the building number,

00:09:37.466 --> 00:09:39.696 A:middle
a street name and
apartment number all

00:09:39.696 --> 00:09:40.446 A:middle
of which are optional.

00:09:41.376 --> 00:09:43.386 A:middle
Let's do a little
bit more bookkeeping.

00:09:43.386 --> 00:09:45.646 A:middle
Let's go ahead and create
a person instance, Paul,

00:09:45.646 --> 00:09:48.806 A:middle
here and let's give
Paul a residence

00:09:49.716 --> 00:09:52.946 A:middle
and let's also give
Paul's residence an address

00:09:53.126 --> 00:09:54.186 A:middle
so he can receive his mail.

00:09:54.426 --> 00:09:58.436 A:middle
Now because Paul doesn't live
in an apartment we're not going

00:09:58.436 --> 00:10:00.006 A:middle
to set the apartment
number but we're going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.436 --> 00:10:00.006 A:middle
to set the apartment
number but we're going

00:10:00.006 --> 00:10:02.586 A:middle
to set the building
number to the string 243

00:10:02.586 --> 00:10:04.256 A:middle
and the street name
to Main Street.

00:10:05.416 --> 00:10:09.516 A:middle
Now let's say that we wanted
to get at the address number

00:10:09.796 --> 00:10:12.076 A:middle
as an integer not as a string.

00:10:12.076 --> 00:10:16.336 A:middle
Well we could use if let binding
to drill down through all

00:10:16.336 --> 00:10:17.726 A:middle
of these properties
and sub properties

00:10:17.726 --> 00:10:19.076 A:middle
of the classes we've defined.

00:10:19.246 --> 00:10:21.576 A:middle
So first we can test to see
if Paul has a residence.

00:10:21.576 --> 00:10:23.626 A:middle
If so, unwrap it,
assign it to home.

00:10:24.286 --> 00:10:28.286 A:middle
We can do the same with the
address and finally we can drill

00:10:28.286 --> 00:10:31.386 A:middle
down and use the toInt
method to convert that string

00:10:31.716 --> 00:10:36.386 A:middle
into a number and assign
it to the address variable,

00:10:37.556 --> 00:10:39.826 A:middle
but this is really
cumbersome as you can tell.

00:10:40.106 --> 00:10:43.606 A:middle
This does not lead to pretty
code and it's kind of hard

00:10:43.606 --> 00:10:46.826 A:middle
to follow all of the nested if
let syntax and statements here.

00:10:47.516 --> 00:10:51.796 A:middle
So in Swift we can actually
use optional chaining as a way

00:10:51.796 --> 00:10:53.086 A:middle
of accomplishing the same thing.

00:10:53.706 --> 00:10:55.586 A:middle
Optional chaining lets
you work with optionals

00:10:55.636 --> 00:10:57.406 A:middle
to conditionally
perform operations.

00:10:57.766 --> 00:11:01.086 A:middle
It's like messaging nil in
Objective-C but in such a way


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:57.766 --> 00:11:01.086 A:middle
It's like messaging nil in
Objective-C but in such a way

00:11:01.086 --> 00:11:03.036 A:middle
that it works with
any type whatsoever.

00:11:04.286 --> 00:11:07.876 A:middle
Optional chaining provides
a clean and succinct syntax

00:11:07.996 --> 00:11:09.456 A:middle
for doing these kinds
of operations

00:11:09.886 --> 00:11:12.316 A:middle
so what we're doing here is
we're evaluating each point

00:11:12.316 --> 00:11:15.726 A:middle
using the question mark operator
or the chaining operator to see

00:11:15.726 --> 00:11:19.106 A:middle
if the thing to its left which
is an optional type if it's nil

00:11:19.356 --> 00:11:22.216 A:middle
or if it's present before we
proceed to the next expression.

00:11:22.886 --> 00:11:23.876 A:middle
So to see how this works

00:11:23.876 --> 00:11:26.586 A:middle
in a little bit more detail
let's look at this example

00:11:26.586 --> 00:11:27.646 A:middle
and see how it's evaluated.

00:11:27.796 --> 00:11:29.186 A:middle
You could think of
the evaluation

00:11:29.736 --> 00:11:31.356 A:middle
of an optional chaining
expression

00:11:32.016 --> 00:11:34.946 A:middle
like 2 parallel railroad
tracks that end

00:11:34.946 --> 00:11:36.916 A:middle
in two different
destinations or two stations.

00:11:37.196 --> 00:11:40.576 A:middle
The first station being the
optional value that's wrapped

00:11:40.576 --> 00:11:43.876 A:middle
up here so in this case an Int
that's wrapped in an optional

00:11:44.416 --> 00:11:46.156 A:middle
or simply nil when
there's no value present.

00:11:47.036 --> 00:11:48.906 A:middle
So let's see what this
looks like as we go

00:11:48.906 --> 00:11:49.666 A:middle
through the expression.

00:11:50.136 --> 00:11:51.966 A:middle
Well, Paul is non-optional
so that's obvious.

00:11:51.966 --> 00:11:53.356 A:middle
We've set him, he's
a valid instance.

00:11:54.116 --> 00:11:55.786 A:middle
We can go to the
first optional here

00:11:55.966 --> 00:11:57.836 A:middle
in the chain expression
residence.

00:11:57.836 --> 00:11:59.686 A:middle
Well, we know that we've
set it as a residence

00:11:59.946 --> 00:12:03.226 A:middle
but if it were nil, we would
actually just take the nil track


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.946 --> 00:12:03.226 A:middle
but if it were nil, we would
actually just take the nil track

00:12:03.646 --> 00:12:05.936 A:middle
and the entire expression
would return nil.

00:12:05.936 --> 00:12:08.636 A:middle
It's still an optional type
but it simply returns nil

00:12:08.636 --> 00:12:12.996 A:middle
and the rest of the expression
is ignored, but of course,

00:12:12.996 --> 00:12:13.976 A:middle
we did set a residence

00:12:13.976 --> 00:12:16.206 A:middle
and we can do the same
here along the path

00:12:16.926 --> 00:12:20.576 A:middle
and we can check every single
optional in a chained expression

00:12:20.576 --> 00:12:21.866 A:middle
to see whether or
not it's valid.

00:12:22.486 --> 00:12:24.466 A:middle
In this case, we've
set an address

00:12:24.466 --> 00:12:28.606 A:middle
and we've set a building
number and finally we come

00:12:28.606 --> 00:12:32.586 A:middle
to the last method call
after we've checked all

00:12:32.586 --> 00:12:33.556 A:middle
of the rest of the optionals.

00:12:33.946 --> 00:12:34.916 A:middle
Now the toInt method

00:12:34.916 --> 00:12:37.116 A:middle
as you recall returns
an optional type itself

00:12:37.486 --> 00:12:39.656 A:middle
so there's actually one more
path we need to consider.

00:12:39.906 --> 00:12:42.496 A:middle
It could, in fact, return nil
if it can't convert the value,

00:12:43.926 --> 00:12:47.826 A:middle
but we've set it, of course, to
a valid string representation

00:12:47.826 --> 00:12:50.406 A:middle
of an integer and so
toInt method has a result

00:12:50.406 --> 00:12:54.786 A:middle
to return 243 and the entire
expression is completely

00:12:54.786 --> 00:12:57.676 A:middle
evaluated it's wrapped
back up in an optional

00:12:58.096 --> 00:13:00.526 A:middle
so that the address
number is now an optional


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.096 --> 00:13:00.526 A:middle
so that the address
number is now an optional

00:13:00.796 --> 00:13:02.996 A:middle
with an underlying value of 243,

00:13:03.756 --> 00:13:06.276 A:middle
but because it's an optional
value if I need to use it

00:13:07.246 --> 00:13:09.986 A:middle
as a real integer, I
need to unwrap it still.

00:13:10.466 --> 00:13:12.856 A:middle
Actually we can combine
these operations together,

00:13:12.856 --> 00:13:17.206 A:middle
optional chaining, and if let
syntax are optional binding,

00:13:17.576 --> 00:13:20.226 A:middle
to test and unwrap it
at the same time again.

00:13:20.566 --> 00:13:23.116 A:middle
So here we can take the entire
optional chained expression

00:13:23.386 --> 00:13:27.766 A:middle
and evaluate it, see if it isn't
nil, unwrap it and assign it

00:13:27.766 --> 00:13:28.596 A:middle
to the address variable.

00:13:28.876 --> 00:13:30.996 A:middle
We can use it like an
ordinary non-optional type.

00:13:31.446 --> 00:13:32.846 A:middle
For example, to add
it to a database.

00:13:34.236 --> 00:13:35.686 A:middle
So that's how optionals work.

00:13:36.516 --> 00:13:39.546 A:middle
[ Applause ]

00:13:40.046 --> 00:13:40.766 A:middle
It's pretty cool.

00:13:41.166 --> 00:13:42.476 A:middle
So that's how optionals works.

00:13:42.476 --> 00:13:43.816 A:middle
It's how optional
chaining works,

00:13:43.816 --> 00:13:46.316 A:middle
how optional binding works,
I want to take a step back

00:13:46.806 --> 00:13:48.866 A:middle
and show you what optionals
look like under the hood.

00:13:49.376 --> 00:13:51.366 A:middle
I don't want to spend a lot
of time here but I do want

00:13:51.366 --> 00:13:52.946 A:middle
to show you how powerful

00:13:52.946 --> 00:13:54.916 A:middle
and expressive the Swift
programming language is

00:13:55.226 --> 00:13:57.566 A:middle
that we can actually model
something so fundamental

00:13:57.566 --> 00:14:01.046 A:middle
to the language like optionals
in the language itself.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.566 --> 00:14:01.046 A:middle
to the language like optionals
in the language itself.

00:14:01.626 --> 00:14:04.636 A:middle
So optionals are really
just a simple enumeration,

00:14:05.286 --> 00:14:07.566 A:middle
a generic enumeration
at that, of any type.

00:14:07.876 --> 00:14:10.596 A:middle
You can see the sum type
here represents the case

00:14:10.596 --> 00:14:13.686 A:middle
in which I said there is a
value present that's wrapped up.

00:14:13.906 --> 00:14:15.516 A:middle
You can see that
wrapping here going on

00:14:15.896 --> 00:14:19.376 A:middle
and the None case just simply is
a default value which we've said

00:14:19.376 --> 00:14:20.796 A:middle
that you can indicate using nil.

00:14:22.126 --> 00:14:24.466 A:middle
We haven't talked too much about
generics and we're not going

00:14:24.466 --> 00:14:27.176 A:middle
to go into generics in much
detail here, but I encourage you

00:14:27.176 --> 00:14:29.756 A:middle
to watch the Advanced Swift talk
where you can see the full power

00:14:29.756 --> 00:14:32.476 A:middle
of generics in action.

00:14:32.656 --> 00:14:33.636 A:middle
So that's optionals.

00:14:34.316 --> 00:14:37.186 A:middle
You use optionals to
work safely in your code

00:14:37.186 --> 00:14:38.756 A:middle
with possibly missing values.

00:14:39.706 --> 00:14:40.896 A:middle
Missing values are nil

00:14:40.896 --> 00:14:43.766 A:middle
and present values are
wrapped up in the optionals.

00:14:44.256 --> 00:14:46.576 A:middle
You can then unwrap the
optionals in two ways;

00:14:46.576 --> 00:14:49.196 A:middle
either with a forced-unwrapping
operator but only do

00:14:49.196 --> 00:14:51.466 A:middle
that if you're sure there's a
value there and it's not nil,

00:14:52.186 --> 00:14:55.376 A:middle
and you can also use if let
syntax or optional binding

00:14:55.376 --> 00:14:58.276 A:middle
to unwrap and test at the
same time in a very safe way.

00:14:59.026 --> 00:15:02.226 A:middle
And finally, you can use
optional chaining to work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.026 --> 00:15:02.226 A:middle
And finally, you can use
optional chaining to work

00:15:02.226 --> 00:15:03.836 A:middle
in a very succinct
and eloquent way

00:15:04.196 --> 00:15:06.616 A:middle
with multiple optional
expressions chained together

00:15:06.616 --> 00:15:08.336 A:middle
and that's optionals.

00:15:08.696 --> 00:15:11.096 A:middle
So, I'd like to invite Joe back
on the stage to talk to you

00:15:11.096 --> 00:15:12.386 A:middle
about memory management
in Swift.

00:15:13.516 --> 00:15:15.546 A:middle
[ Applause ]

00:15:16.046 --> 00:15:18.246 A:middle
&gt;&gt; My name is Joe Groff, I
work on the Swift compiler,

00:15:18.356 --> 00:15:21.666 A:middle
and I'm really excited because
managing memory is my favorite

00:15:21.666 --> 00:15:24.116 A:middle
thing to do when I program.

00:15:24.976 --> 00:15:26.266 A:middle
No, it's not.

00:15:26.956 --> 00:15:29.226 A:middle
Thankfully Swift is built

00:15:29.226 --> 00:15:32.076 A:middle
on automatic reference
counting the same model we used

00:15:32.076 --> 00:15:33.586 A:middle
in Objective-C or ARC.

00:15:35.216 --> 00:15:39.496 A:middle
We don't make you use pointer
syntax, we don't make you spell

00:15:39.496 --> 00:15:42.426 A:middle
out Alec, but still we need
a clear class like this

00:15:42.716 --> 00:15:47.166 A:middle
and a constructed class you get
a memory allocation implicitly

00:15:47.316 --> 00:15:50.926 A:middle
and a reference to that is what
gets stored in a local variable

00:15:50.926 --> 00:15:54.006 A:middle
and it's these references
that keep that memory alive.

00:15:55.426 --> 00:15:57.986 A:middle
Now we can juggle a couple
of these bowling pins here

00:15:57.986 --> 00:16:01.306 A:middle
and when the last reference
to a class goes away,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:57.986 --> 00:16:01.306 A:middle
and when the last reference
to a class goes away,

00:16:01.306 --> 00:16:05.716 A:middle
an object goes away, the object
automatically gets deallocated.

00:16:06.386 --> 00:16:08.006 A:middle
ARC is a horrible
juggler but it's great

00:16:08.006 --> 00:16:09.606 A:middle
at reclaiming unused memory.

00:16:10.166 --> 00:16:13.636 A:middle
When a reference
goes out of scope,

00:16:13.636 --> 00:16:15.706 A:middle
it's automatically
released but as long

00:16:15.706 --> 00:16:18.206 A:middle
as you have some reference to
the object, it's kept alive

00:16:19.296 --> 00:16:22.386 A:middle
and only when the final
reference is released is the

00:16:22.386 --> 00:16:23.576 A:middle
object deallocated.

00:16:23.946 --> 00:16:27.586 A:middle
It's safe, it's predictable,
it just works.

00:16:28.616 --> 00:16:31.036 A:middle
Except for those cycles.

00:16:31.916 --> 00:16:35.146 A:middle
Sometimes it doesn't make sense
for an object to be owned.

00:16:35.666 --> 00:16:39.766 A:middle
For instance, apartments
literally aren't owned

00:16:39.766 --> 00:16:42.206 A:middle
by their tenants but
they also will have

00:16:42.206 --> 00:16:43.666 A:middle
like multiple people
living in them

00:16:43.666 --> 00:16:45.236 A:middle
over the lifetime
of the building.

00:16:46.506 --> 00:16:48.806 A:middle
On the other hand, a person
will move from apartment

00:16:48.806 --> 00:16:50.046 A:middle
to apartment over their life.

00:16:50.496 --> 00:16:54.646 A:middle
Even if you move a
person into an apartment,

00:16:56.516 --> 00:16:59.696 A:middle
this relationship isn't
really an owning relationship.

00:16:59.696 --> 00:17:04.036 A:middle
And there's a problem if
we try to model it as such.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.696 --> 00:17:04.036 A:middle
And there's a problem if
we try to model it as such.

00:17:04.566 --> 00:17:08.715 A:middle
Let's set up a dictionary
of our renters

00:17:08.715 --> 00:17:10.576 A:middle
and our apartments
say we're a landlord.

00:17:11.516 --> 00:17:14.675 A:middle
Let's move one of tenants,
Elsvette, into her apartment.

00:17:15.486 --> 00:17:16.536 A:middle
Now there's a problem.

00:17:17.286 --> 00:17:20.236 A:middle
If she tries to move
out, she's trapped.

00:17:21.336 --> 00:17:24.376 A:middle
The reference to the apartment
keeps her object alive

00:17:24.376 --> 00:17:27.945 A:middle
and even worse if we try to sell
off the property we're stuck

00:17:27.945 --> 00:17:28.626 A:middle
with the deed.

00:17:29.546 --> 00:17:33.476 A:middle
Both objects keep each other
alive in a reference cycle.

00:17:35.296 --> 00:17:38.556 A:middle
So like Objective-C,
we have weak references

00:17:38.966 --> 00:17:42.026 A:middle
and these tell Swift that
this object isn't responsible

00:17:42.026 --> 00:17:44.116 A:middle
for keeping the object
on the other end alive.

00:17:44.686 --> 00:17:49.736 A:middle
Now, when we work through the
example again, a weak reference

00:17:49.736 --> 00:17:54.366 A:middle
between these two
objects Elsvette can move

00:17:54.366 --> 00:17:59.566 A:middle
out of her apartment and make a
clean break with her landlord.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:00.146 --> 00:18:03.266 A:middle
And the reference
automatically gets reset to nil.

00:18:04.266 --> 00:18:07.306 A:middle
There's no dangling reference
to the allocated object.

00:18:08.516 --> 00:18:11.116 A:middle
Now of course, when we sell off
the property, both objects end

00:18:11.116 --> 00:18:12.786 A:middle
up deallocated and
there's no leak.

00:18:13.226 --> 00:18:19.296 A:middle
And weak references in Swift
are modeled as optional values.

00:18:19.296 --> 00:18:20.946 A:middle
You can use all the
optional operations

00:18:20.946 --> 00:18:23.036 A:middle
that Brian just showed
you to work with them

00:18:23.036 --> 00:18:26.426 A:middle
and when you take an
optional weak value

00:18:26.516 --> 00:18:29.466 A:middle
and you bind the
non-optional part

00:18:29.466 --> 00:18:33.496 A:middle
out of it you get a
strong non-optional value

00:18:33.496 --> 00:18:35.186 A:middle
and you can safely
work with that just

00:18:35.186 --> 00:18:36.426 A:middle
like any other reference.

00:18:37.516 --> 00:18:39.556 A:middle
If you're applying a
single method or looking

00:18:39.556 --> 00:18:41.376 A:middle
at the single property
conditionally

00:18:41.376 --> 00:18:42.716 A:middle
on a weak reference object,

00:18:42.716 --> 00:18:45.796 A:middle
you can also use the chaining
operator as a nice shorthand.

00:18:46.336 --> 00:18:50.646 A:middle
Some things to be aware
of are that the test

00:18:50.646 --> 00:18:53.506 A:middle
and unwrap pattern does not
work very well with weak.

00:18:54.386 --> 00:18:56.716 A:middle
You could go to cash your
tenant's rent check and find

00:18:56.716 --> 00:18:59.636 A:middle
out it bounced and evict
them before you have a chance

00:18:59.636 --> 00:19:00.956 A:middle
to even greet them and end


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.636 --> 00:19:00.956 A:middle
to even greet them and end

00:19:00.956 --> 00:19:05.596 A:middle
up with a runtime error
you didn't expect.

00:19:05.716 --> 00:19:08.886 A:middle
Chaining also doesn't preserve
a strong reference if you use it

00:19:08.886 --> 00:19:11.806 A:middle
to try to apply multiple
methods to the same object.

00:19:12.296 --> 00:19:17.656 A:middle
Here cashRentCheck could again
cause the tenant to get released

00:19:17.656 --> 00:19:22.026 A:middle
and then we'd end up getting a
nil object and then, in fact,

00:19:22.096 --> 00:19:23.576 A:middle
not calling greet at all.

00:19:27.456 --> 00:19:29.746 A:middle
Weak references are
great for breaking cycles

00:19:29.846 --> 00:19:31.696 A:middle
but they aren't always ideal.

00:19:32.266 --> 00:19:35.476 A:middle
Let's say we're a
modern landlord

00:19:35.476 --> 00:19:37.546 A:middle
and we accept credit card
payments from our tenants.

00:19:37.836 --> 00:19:40.136 A:middle
A dream I know but bear with me.

00:19:40.866 --> 00:19:44.376 A:middle
Now a credit card
should only ever be owned

00:19:44.376 --> 00:19:45.826 A:middle
by one person, right?

00:19:46.416 --> 00:19:48.846 A:middle
So we really want this to
be an immutable binding,

00:19:48.846 --> 00:19:51.766 A:middle
an immutable property
of the credit card.

00:19:52.766 --> 00:19:56.016 A:middle
We also don't even really
want to track a credit card

00:19:56.016 --> 00:19:57.666 A:middle
if it isn't owned by a person.

00:19:58.106 --> 00:19:59.766 A:middle
It shouldn't be an
optional property.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:01.616 --> 00:20:04.686 A:middle
There's obviously a cycle here
and we could break that cycle

00:20:04.686 --> 00:20:07.096 A:middle
with weak references
but that forces us

00:20:07.096 --> 00:20:09.866 A:middle
into some unfortunate
loosening of the model here.

00:20:10.776 --> 00:20:13.196 A:middle
First of all weak
references have to be optional

00:20:14.056 --> 00:20:17.136 A:middle
because they have to
be resettable to nil.

00:20:17.356 --> 00:20:19.706 A:middle
Second of all they
have to be mutable

00:20:20.026 --> 00:20:23.406 A:middle
because they could be
reset to nil at any time

00:20:24.086 --> 00:20:26.866 A:middle
and we don't really want this.

00:20:27.636 --> 00:20:30.376 A:middle
We could end up accidently
reassigning a credit card

00:20:30.776 --> 00:20:34.706 A:middle
or ending up with an
orphan credit card just

00:20:34.706 --> 00:20:36.876 A:middle
to deal with memory leaks.

00:20:37.086 --> 00:20:38.366 A:middle
That would suck.

00:20:39.196 --> 00:20:40.676 A:middle
So, instead, we have
another kind

00:20:40.676 --> 00:20:42.366 A:middle
of weak reference the
unowned reference.

00:20:42.846 --> 00:20:45.246 A:middle
What this tells Swift is

00:20:45.246 --> 00:20:48.216 A:middle
that although I don't have an
owning stake in the object,

00:20:48.576 --> 00:20:49.806 A:middle
my life depends on it.

00:20:51.036 --> 00:20:54.846 A:middle
I cannot live without my
owner, my card holder.

00:20:58.776 --> 00:21:00.756 A:middle
So we can go back to
our renter's table,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.776 --> 00:21:00.756 A:middle
So we can go back to
our renter's table,

00:21:01.216 --> 00:21:03.686 A:middle
we can save our tenant's
credit card information

00:21:03.686 --> 00:21:07.286 A:middle
and you can see here that the
credit card is uniquely owned

00:21:07.556 --> 00:21:11.076 A:middle
by the person record so that

00:21:11.076 --> 00:21:14.876 A:middle
when her record is reallocated
the entire object graph

00:21:14.876 --> 00:21:15.806 A:middle
gets allocated.

00:21:16.116 --> 00:21:21.046 A:middle
There's no need to observe
the credit card independent

00:21:21.046 --> 00:21:21.886 A:middle
of the person.

00:21:22.426 --> 00:21:25.446 A:middle
And because there's
this assumption

00:21:25.446 --> 00:21:28.936 A:middle
that the program is not
correct without the object

00:21:28.936 --> 00:21:31.546 A:middle
on the other side, you can
use unknown references just

00:21:31.546 --> 00:21:32.636 A:middle
like strong references.

00:21:32.636 --> 00:21:34.636 A:middle
You can assign them
into a local variable

00:21:35.066 --> 00:21:36.876 A:middle
or you can call methods
on them directly.

00:21:37.686 --> 00:21:39.996 A:middle
It's a bit like unsafe,
unretained in C

00:21:40.106 --> 00:21:42.476 A:middle
or Objective-C but
it's still safe.

00:21:42.476 --> 00:21:45.616 A:middle
We still assert that the object
is still allocated every time

00:21:45.616 --> 00:21:47.366 A:middle
you access it through
an unowned reference.

00:21:47.806 --> 00:21:52.006 A:middle
So let's look at three kinds
of references in Swift.

00:21:53.386 --> 00:21:55.646 A:middle
Strong references are
the default and that's

00:21:55.646 --> 00:21:57.356 A:middle
because they're what you
should use most of the time.

00:21:57.496 --> 00:21:59.416 A:middle
Most of the time you
have an ownership stake

00:21:59.416 --> 00:22:03.686 A:middle
in an object you want to use.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.416 --> 00:22:03.686 A:middle
in an object you want to use.

00:22:03.686 --> 00:22:05.736 A:middle
However, if you have
independent objects,

00:22:05.736 --> 00:22:08.426 A:middle
objects with independent
lifetimes, sort of a, you know,

00:22:08.426 --> 00:22:10.896 A:middle
a casual relationship
going on where you can move

00:22:10.896 --> 00:22:14.046 A:middle
on if they went away,
weak references are great

00:22:14.046 --> 00:22:15.476 A:middle
for modeling that sort of thing.

00:22:16.006 --> 00:22:18.296 A:middle
If part of your program
ends up deallocated due

00:22:18.296 --> 00:22:21.796 A:middle
to maybe low memory, the rest
of your program marches on

00:22:22.026 --> 00:22:23.666 A:middle
and optionals are a
great way of dealing

00:22:23.926 --> 00:22:25.966 A:middle
with weak referenced
objects going away.

00:22:26.536 --> 00:22:30.916 A:middle
And unowned references are
great for back references

00:22:30.916 --> 00:22:33.426 A:middle
from dependent objects
backed up to their owners.

00:22:34.516 --> 00:22:36.166 A:middle
If part of the object
graph goes away,

00:22:36.166 --> 00:22:37.996 A:middle
the entire object
graph goes away

00:22:37.996 --> 00:22:39.976 A:middle
and there's no need
to deal with nil.

00:22:41.176 --> 00:22:42.846 A:middle
And that's memory
management with Swift.

00:22:43.436 --> 00:22:46.796 A:middle
It's automatic, it's automatic
reference counting, it's safe

00:22:47.326 --> 00:22:50.126 A:middle
and it lets you think
about the relationships

00:22:50.126 --> 00:22:53.096 A:middle
between your objects rather
than the raw mechanics

00:22:53.096 --> 00:22:55.086 A:middle
of memory management
making strong,

00:22:55.086 --> 00:22:58.846 A:middle
weak and unknown references
to model those relationships

00:22:59.426 --> 00:23:02.076 A:middle
and provides a nice, safe
foundation for Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.426 --> 00:23:02.076 A:middle
and provides a nice, safe
foundation for Swift.

00:23:02.076 --> 00:23:05.406 A:middle
To talk a little bit more
about that foundation I'm going

00:23:05.406 --> 00:23:08.046 A:middle
to bring it back to Brian to
talk about initialization.

00:23:09.516 --> 00:23:11.556 A:middle
[ Applause ]

00:23:12.056 --> 00:23:13.946 A:middle
&gt;&gt; Thank you, Joe,
thank you, Joe.

00:23:14.116 --> 00:23:16.506 A:middle
So I want to talk to you
about initialization in Swift.

00:23:17.426 --> 00:23:22.776 A:middle
Initialization in Swift follows
one very simple rule and that's

00:23:22.806 --> 00:23:25.726 A:middle
that every value must be
initialized before it's used.

00:23:27.066 --> 00:23:29.996 A:middle
This one simple rule is
enforced by the compiler

00:23:29.996 --> 00:23:32.956 A:middle
and it ensures memory
safety in your code.

00:23:34.356 --> 00:23:37.666 A:middle
It ensures that you never
read from uninitialized memory

00:23:38.066 --> 00:23:38.626 A:middle
and it, therefore,

00:23:38.626 --> 00:23:40.536 A:middle
helps eliminate an
entire class of bugs.

00:23:42.146 --> 00:23:44.756 A:middle
Let's look at how this rule
applies throughout the language.

00:23:44.756 --> 00:23:48.546 A:middle
So let's start with
the simple variables.

00:23:49.176 --> 00:23:51.896 A:middle
Swift doesn't default
initialized variables,

00:23:52.366 --> 00:23:56.966 A:middle
constants, or properties because
there often isn't a natural

00:23:56.966 --> 00:23:58.566 A:middle
and correct value
for everything.

00:23:59.056 --> 00:24:02.296 A:middle
The only exception to this is
optionals where we saw earlier


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.056 --> 00:24:02.296 A:middle
The only exception to this is
optionals where we saw earlier

00:24:02.296 --> 00:24:05.296 A:middle
that optionals have a very
natural default value of nil.

00:24:06.186 --> 00:24:09.466 A:middle
This means that you need to
set these values explicitly

00:24:09.466 --> 00:24:11.976 A:middle
in your code, but it
doesn't mean that you need

00:24:11.976 --> 00:24:14.426 A:middle
to declare these
values at the point

00:24:14.476 --> 00:24:17.176 A:middle
that you declare your variable
as constants or properties.

00:24:17.516 --> 00:24:20.276 A:middle
It just means that you must
do so before you try to read

00:24:20.276 --> 00:24:21.526 A:middle
from them or access them.

00:24:22.756 --> 00:24:26.556 A:middle
For example, say we
wanted to set message here

00:24:27.226 --> 00:24:30.076 A:middle
to an appropriate value
depending on whether

00:24:30.076 --> 00:24:33.406 A:middle
or not a condition was true and
then print that message out.

00:24:34.126 --> 00:24:36.566 A:middle
Even though the condition is
true in this case, I mean we're

00:24:36.566 --> 00:24:37.916 A:middle
in the middle of the
session after all,

00:24:38.626 --> 00:24:40.046 A:middle
we'd get a compiler error

00:24:40.546 --> 00:24:45.576 A:middle
because we haven't considered
every possible branch

00:24:45.626 --> 00:24:46.436 A:middle
in our code.

00:24:47.116 --> 00:24:49.556 A:middle
We haven't said what
the value of messages

00:24:49.846 --> 00:24:51.256 A:middle
when the condition is false.

00:24:52.546 --> 00:24:56.506 A:middle
So let's add an else
clause to do just that.

00:24:56.676 --> 00:24:59.206 A:middle
Now when we read for message
to print it out we can be sure

00:24:59.206 --> 00:25:02.396 A:middle
that it has an explicit value
for every single condition


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.206 --> 00:25:02.396 A:middle
that it has an explicit value
for every single condition

00:25:02.616 --> 00:25:07.346 A:middle
in our code, but now as I'm sure
you're all aware it's quite easy

00:25:07.346 --> 00:25:09.896 A:middle
to forget to check all of
the conditions in your code.

00:25:10.546 --> 00:25:15.206 A:middle
So rather than surprising you
by unexpected and hard to track

00:25:15.206 --> 00:25:19.096 A:middle
down behavior, the Swift
compiler catches these kinds

00:25:19.096 --> 00:25:21.786 A:middle
of mistakes for you and
ensures that you're explicit

00:25:21.786 --> 00:25:24.056 A:middle
about the values you want
to set for every branch

00:25:24.056 --> 00:25:25.796 A:middle
and under every condition
in your code.

00:25:26.506 --> 00:25:28.066 A:middle
This is great for memory safety.

00:25:28.706 --> 00:25:31.966 A:middle
Now that we've seen
how this rule applies

00:25:31.966 --> 00:25:34.356 A:middle
to simple variables,
let's see how it applies

00:25:34.806 --> 00:25:38.486 A:middle
when you're defining your
own classes like, classes

00:25:38.486 --> 00:25:41.736 A:middle
or structures, your own types.

00:25:41.916 --> 00:25:45.786 A:middle
So, inside of the structure are
class declaration initializers

00:25:45.786 --> 00:25:47.116 A:middle
handle this responsibility.

00:25:47.336 --> 00:25:49.416 A:middle
They handle the responsibility
of satisfying the rule

00:25:49.416 --> 00:25:52.826 A:middle
that everything is
set before it's used.

00:25:53.906 --> 00:25:56.876 A:middle
Now, you've seen some
initializers in some

00:25:56.876 --> 00:25:59.406 A:middle
of Joe's examples and memory
management just a while ago

00:25:59.406 --> 00:26:02.106 A:middle
and they're declared
using the key word in it


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.406 --> 00:26:02.106 A:middle
and they're declared
using the key word in it

00:26:03.166 --> 00:26:05.896 A:middle
and they're invoked
at object creation

00:26:06.096 --> 00:26:11.736 A:middle
or instance creation here
using this initializer syntax.

00:26:11.736 --> 00:26:14.466 A:middle
Now initializers can have any
number of labeled arguments

00:26:14.466 --> 00:26:18.756 A:middle
or parameters and when
they do you need to call,

00:26:18.756 --> 00:26:21.236 A:middle
you need to call it using
these label parameters.

00:26:21.236 --> 00:26:23.226 A:middle
They're required
at the call site.

00:26:24.356 --> 00:26:27.606 A:middle
Before we look at initialization
in classes, let's take a look

00:26:27.606 --> 00:26:30.416 A:middle
at initialization and how
it works in structures.

00:26:31.216 --> 00:26:32.766 A:middle
Let's define a simple
color structure

00:26:33.156 --> 00:26:35.986 A:middle
that has three properties,
red, green and blue

00:26:35.986 --> 00:26:38.806 A:middle
to represent the color
components and we'll deal

00:26:38.806 --> 00:26:42.626 A:middle
with alpha later, now let's say
that we want to create colors

00:26:42.626 --> 00:26:43.736 A:middle
in different shades of gray.

00:26:44.696 --> 00:26:47.936 A:middle
Well to do so we can define a
single initializer here a very

00:26:47.936 --> 00:26:50.016 A:middle
simple one that simply has,

00:26:50.486 --> 00:26:55.336 A:middle
takes a single gray scale
double value and sets all

00:26:55.336 --> 00:26:58.576 A:middle
of the stored properties of the
structure to that same value.

00:26:58.776 --> 00:27:01.846 A:middle
Now, if we had forgotten to set
the red property, for example,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.776 --> 00:27:01.846 A:middle
Now, if we had forgotten to set
the red property, for example,

00:27:02.496 --> 00:27:03.726 A:middle
we'd get a compiler error

00:27:03.996 --> 00:27:05.626 A:middle
because we haven't
satisfied the rule

00:27:05.626 --> 00:27:08.496 A:middle
that every value must be
initialized before it's used.

00:27:09.566 --> 00:27:11.736 A:middle
The same is true
for calling a method

00:27:12.316 --> 00:27:15.006 A:middle
in your initializer before you
set all of your properties.

00:27:16.256 --> 00:27:19.076 A:middle
For example, say we want to
validate, we want a method

00:27:19.076 --> 00:27:21.646 A:middle
that validates the color
components to make sure they're

00:27:21.646 --> 00:27:26.046 A:middle
within a valid range
of values say 0 to 1.0.

00:27:27.166 --> 00:27:29.826 A:middle
If we then call this
method here inside

00:27:29.826 --> 00:27:32.596 A:middle
of the initializer before we
set all of our properties,

00:27:33.296 --> 00:27:36.356 A:middle
we'd again get a compiler
error because we're trying

00:27:36.356 --> 00:27:38.646 A:middle
to call a method on
self on the instance,

00:27:39.436 --> 00:27:41.606 A:middle
but before self has
been fully initialized.

00:27:42.556 --> 00:27:46.126 A:middle
So if you need to access self
just customize any property

00:27:46.126 --> 00:27:48.926 A:middle
values or to call on the
methods in your initializer,

00:27:49.526 --> 00:27:52.316 A:middle
always do so after you've set
all of your stored properties

00:27:52.316 --> 00:27:53.336 A:middle
to appropriate values.

00:27:55.156 --> 00:27:57.726 A:middle
Now in structures, if
you don't define any

00:27:57.726 --> 00:28:00.526 A:middle
of your own initializers,
Swift provides you


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:57.726 --> 00:28:00.526 A:middle
of your own initializers,
Swift provides you

00:28:00.526 --> 00:28:03.656 A:middle
with a memberwise
initializer automatically.

00:28:05.116 --> 00:28:08.276 A:middle
The memberwise initializer
has arguments that correspond

00:28:08.276 --> 00:28:11.556 A:middle
to each of that instances
store, each of that classes

00:28:11.556 --> 00:28:12.746 A:middle
or structures stored property.

00:28:13.636 --> 00:28:16.886 A:middle
You can also provide default
values in line directly

00:28:17.156 --> 00:28:19.526 A:middle
for your stored properties
and when you've set all

00:28:19.526 --> 00:28:21.986 A:middle
of your stored properties
and you haven't defined any

00:28:21.986 --> 00:28:23.526 A:middle
of your own custom initializers,

00:28:24.606 --> 00:28:27.436 A:middle
Swift provides a default
initializer for you to use

00:28:27.626 --> 00:28:30.666 A:middle
that takes no parameters
and creates an instance

00:28:30.666 --> 00:28:33.516 A:middle
with the properties you
set as default values

00:28:34.116 --> 00:28:35.286 A:middle
when you declare your structure.

00:28:37.106 --> 00:28:39.376 A:middle
So that's how initialization
works in structures.

00:28:40.576 --> 00:28:43.936 A:middle
Now let's take a look at
how it works in classes.

00:28:44.106 --> 00:28:45.166 A:middle
Really it's no different.

00:28:46.786 --> 00:28:48.616 A:middle
So let's start with a
simple car class here

00:28:49.686 --> 00:28:51.996 A:middle
that has a single
property, a paint color,

00:28:52.326 --> 00:28:55.056 A:middle
and a single initializer that
just sets that paint color

00:28:55.326 --> 00:28:56.306 A:middle
to an appropriate value.

00:28:56.306 --> 00:28:58.876 A:middle
Now, in practice, classes

00:28:59.056 --> 00:29:01.336 A:middle
and often subclass
inherit from other classes.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.056 --> 00:29:01.336 A:middle
and often subclass
inherit from other classes.

00:29:01.636 --> 00:29:04.316 A:middle
So we need to deal with
how initialization works

00:29:04.316 --> 00:29:05.496 A:middle
with subclasses as well.

00:29:07.036 --> 00:29:09.506 A:middle
So let's define a
subclass called RaceCar

00:29:09.546 --> 00:29:12.516 A:middle
and it has one extra property
and its own initializer.

00:29:13.586 --> 00:29:15.416 A:middle
When the RaceCar's
initializer is called,

00:29:16.206 --> 00:29:18.146 A:middle
it first sets its own properties

00:29:19.046 --> 00:29:21.606 A:middle
and then it called the
super class initializer.

00:29:22.206 --> 00:29:26.326 A:middle
And the super class
initializer, of course,

00:29:26.326 --> 00:29:28.946 A:middle
sets its own properties to
an appropriate value as well

00:29:29.866 --> 00:29:32.686 A:middle
and only after the super class
and all the super classes

00:29:32.686 --> 00:29:35.746 A:middle
in the class hierarchy
have had a chance

00:29:35.746 --> 00:29:39.356 A:middle
to set their own values is
a class fully initialized

00:29:39.356 --> 00:29:40.326 A:middle
and ready to use.

00:29:41.466 --> 00:29:43.406 A:middle
Now if you're coming from
an Objective-C background,

00:29:44.326 --> 00:29:46.976 A:middle
you probably noticed that
this is opposite or different

00:29:47.346 --> 00:29:50.156 A:middle
than what you've noticed than
what you do in Objective-C

00:29:50.376 --> 00:29:53.746 A:middle
where you always call
your super class first

00:29:53.746 --> 00:29:55.366 A:middle
and then you set
your own properties.

00:29:58.806 --> 00:30:00.776 A:middle
So in Swift if we
were to do this,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:58.806 --> 00:30:00.776 A:middle
So in Swift if we
were to do this,

00:30:00.776 --> 00:30:02.936 A:middle
if we were to call our super
class initializer first

00:30:03.206 --> 00:30:04.586 A:middle
and then set our own properties,

00:30:05.816 --> 00:30:07.346 A:middle
we would actually
get a compiler error

00:30:07.346 --> 00:30:10.236 A:middle
because it's not always
safe to do so in this order

00:30:11.086 --> 00:30:13.846 A:middle
and the reason Swift's
initialization follows this

00:30:13.846 --> 00:30:18.236 A:middle
order is that it ensures memory
safety so that you don't try

00:30:18.356 --> 00:30:20.556 A:middle
to access memory before it's
been completely initialized.

00:30:20.556 --> 00:30:24.056 A:middle
Now it may not be obvious where
you might run into problems

00:30:24.096 --> 00:30:26.756 A:middle
by doing things in this order so
let's take a look at an example

00:30:26.756 --> 00:30:29.846 A:middle
where calling your super class
initializer first is unsafe.

00:30:31.446 --> 00:30:33.886 A:middle
Let's say, for example, that
we want to define a function

00:30:33.976 --> 00:30:37.146 A:middle
or method on our car class
that fills up the gas tank

00:30:37.146 --> 00:30:39.766 A:middle
and we want to call that
function inside the initializer

00:30:39.766 --> 00:30:41.836 A:middle
so that every time we
get a new car it comes

00:30:41.836 --> 00:30:45.296 A:middle
with a full gas tank and because
race cars use a different kind

00:30:45.296 --> 00:30:46.566 A:middle
of gas than regular cars,

00:30:46.946 --> 00:30:49.256 A:middle
we've overridden this
method in our subclass.

00:30:50.396 --> 00:30:52.886 A:middle
So, when we create
a new race car

00:30:53.536 --> 00:30:55.066 A:middle
and its initializer is called,

00:30:55.806 --> 00:30:57.896 A:middle
it's first called
super class initializer

00:30:58.756 --> 00:31:00.756 A:middle
which then sets its
paint color properties


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.756 --> 00:31:00.756 A:middle
which then sets its
paint color properties

00:31:01.306 --> 00:31:03.476 A:middle
and finally calls its
fillGasTank method,

00:31:04.356 --> 00:31:07.306 A:middle
but because we've overridden
our subclass it gets dynamically

00:31:07.306 --> 00:31:11.806 A:middle
dispatched to the subclass's
version of that same method

00:31:12.516 --> 00:31:13.876 A:middle
and that's where
we have a problem.

00:31:15.366 --> 00:31:17.306 A:middle
And our problem is that
we haven't got a chance

00:31:17.306 --> 00:31:20.356 A:middle
in our own initializer
to set our own properties

00:31:20.586 --> 00:31:22.886 A:middle
and so we're trying to
call a method on self.

00:31:23.196 --> 00:31:25.516 A:middle
We're trying to access this
object or this instance

00:31:25.746 --> 00:31:28.486 A:middle
that hasn't been fully
initialized and that's not safe.

00:31:29.926 --> 00:31:34.286 A:middle
So in Swift, we always make sure
we set our own properties before

00:31:34.286 --> 00:31:36.446 A:middle
we call our super
class's initializer

00:31:36.946 --> 00:31:38.156 A:middle
to have a chance to do the same.

00:31:39.846 --> 00:31:43.126 A:middle
So far we've just seen
examples of a single initializer

00:31:43.126 --> 00:31:46.156 A:middle
in a class, but you can
have multiple initializers

00:31:46.156 --> 00:31:48.036 A:middle
in your class just like
you can in Objective-C.

00:31:48.036 --> 00:31:52.356 A:middle
In fact, you can have designated
initializers what we've seen

00:31:52.356 --> 00:31:55.846 A:middle
so far designated initializers
which you may be familiar

00:31:55.846 --> 00:31:58.986 A:middle
with coming from Objective-C
have the sole responsibility

00:31:58.986 --> 00:32:01.436 A:middle
of creating an object and
setting all of its properties


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.986 --> 00:32:01.436 A:middle
of creating an object and
setting all of its properties

00:32:01.926 --> 00:32:04.926 A:middle
and it has a job of calling
the super class's initializer

00:32:05.196 --> 00:32:06.386 A:middle
and delegating up.

00:32:06.626 --> 00:32:08.176 A:middle
Like you can think of
them as funnel points

00:32:08.176 --> 00:32:10.946 A:middle
that funnel the initialization
process all the way to the class

00:32:11.496 --> 00:32:12.906 A:middle
to the base class and hierarchy,

00:32:13.116 --> 00:32:15.456 A:middle
but you can also have
convenience initializers.

00:32:15.776 --> 00:32:18.966 A:middle
Convenience initializers are
sort of secondary initializers

00:32:19.266 --> 00:32:24.316 A:middle
that provide an alternative
implementation initialization

00:32:24.316 --> 00:32:28.676 A:middle
interface that allows you
to say pass default values

00:32:28.916 --> 00:32:30.556 A:middle
and make it easier for
your clients to use.

00:32:30.796 --> 00:32:32.686 A:middle
They can only call across.

00:32:32.786 --> 00:32:36.836 A:middle
They can only delegate side
to side in a particular class.

00:32:36.866 --> 00:32:37.966 A:middle
They never call up.

00:32:38.156 --> 00:32:40.616 A:middle
So they can call designated
initializers in the same class

00:32:40.956 --> 00:32:42.656 A:middle
or other convenience
initializers

00:32:43.046 --> 00:32:45.086 A:middle
but ultimately these
convenience initializers need

00:32:45.086 --> 00:32:47.716 A:middle
to call a designated to
actually do the heavy lifting

00:32:47.716 --> 00:32:48.786 A:middle
of setting the properties.

00:32:49.816 --> 00:32:52.176 A:middle
So let's see how you might
write a convenience initializer

00:32:52.406 --> 00:32:53.176 A:middle
in your own code.

00:32:53.726 --> 00:32:55.776 A:middle
Say we have RaceCar
again and we want

00:32:55.776 --> 00:32:57.206 A:middle
to create a convenience
initializer

00:32:57.206 --> 00:32:59.376 A:middle
that lets it just
pass in a color

00:32:59.376 --> 00:33:03.006 A:middle
and it sets the turbo
property to true and it does


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.376 --> 00:33:03.006 A:middle
and it sets the turbo
property to true and it does

00:33:03.006 --> 00:33:04.446 A:middle
so by delegating this task

00:33:05.116 --> 00:33:07.356 A:middle
to the designated
initializer in the same class.

00:33:08.676 --> 00:33:10.846 A:middle
Now when we do this
kind of thing in Swift,

00:33:10.936 --> 00:33:12.756 A:middle
when we define a
convenience initializer,

00:33:13.026 --> 00:33:14.446 A:middle
we need to let the
Swift compiler know

00:33:14.746 --> 00:33:16.676 A:middle
by including the
convenience key word

00:33:16.946 --> 00:33:18.116 A:middle
in front of the declaration.

00:33:19.236 --> 00:33:22.146 A:middle
We can even provide more than
one convenience initializer

00:33:22.706 --> 00:33:25.826 A:middle
so we can even provide a
convenience initializer

00:33:25.826 --> 00:33:28.656 A:middle
that lets us create a RaceCar
providing no parameters at all

00:33:28.866 --> 00:33:32.976 A:middle
and then delegates this task
here providing a default gray

00:33:32.976 --> 00:33:36.556 A:middle
value and it calls the other
convenience initializer we've

00:33:36.556 --> 00:33:38.766 A:middle
just declared and that
in turn, of course,

00:33:39.066 --> 00:33:40.796 A:middle
has to call the designated
initializer

00:33:40.796 --> 00:33:43.806 A:middle
to actually set the values and
because we have a super class

00:33:43.806 --> 00:33:45.776 A:middle
to deal with here,
that initializer needs

00:33:45.776 --> 00:33:46.556 A:middle
to call its super class.

00:33:47.866 --> 00:33:50.406 A:middle
And how are initializers
inherited in Swift?

00:33:51.186 --> 00:33:53.466 A:middle
Well, they're not
inherited by default

00:33:54.256 --> 00:33:55.946 A:middle
because doing so
isn't always safe.

00:33:57.526 --> 00:34:00.966 A:middle
However, when your class
provides no initializers at all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:57.526 --> 00:34:00.966 A:middle
However, when your class
provides no initializers at all

00:34:01.476 --> 00:34:04.386 A:middle
and you set default values for
all of its stored properties

00:34:04.386 --> 00:34:06.336 A:middle
as we've done here with
the FormulaOne RaceCar

00:34:06.336 --> 00:34:08.266 A:middle
where we've set a
single stored property

00:34:08.266 --> 00:34:11.045 A:middle
to a minimum regulation
weight and since we know

00:34:11.045 --> 00:34:12.476 A:middle
that weight we can
set it directly.

00:34:12.476 --> 00:34:16.606 A:middle
Now when we do this, we actually
inherit automatically all

00:34:16.606 --> 00:34:18.025 A:middle
of the initializers
of the super class

00:34:18.025 --> 00:34:19.996 A:middle
that includes designated
initializers

00:34:20.266 --> 00:34:22.136 A:middle
and the convenience initializers
that we've declared.

00:34:22.896 --> 00:34:24.815 A:middle
Now, if we did this in
this particular case,

00:34:24.815 --> 00:34:26.835 A:middle
we'd have a problem because one

00:34:26.835 --> 00:34:29.735 A:middle
of the convenience initializers
we've inherited sets the wrong

00:34:29.735 --> 00:34:30.656 A:middle
value for turbo.

00:34:31.226 --> 00:34:34.056 A:middle
Formula One race cars aren't
allowed to have a turbo

00:34:34.226 --> 00:34:36.266 A:middle
by regulation and so this
wouldn't be appropriate

00:34:36.266 --> 00:34:36.896 A:middle
in this case.

00:34:37.516 --> 00:34:39.826 A:middle
So instead we'll define
our own initializer here

00:34:39.906 --> 00:34:41.916 A:middle
and now it's a designated
initializer

00:34:41.916 --> 00:34:44.966 A:middle
because it calls super and
passes that turbo value of false

00:34:46.206 --> 00:34:47.886 A:middle
and because we've done
this we've provided our own

00:34:47.886 --> 00:34:51.436 A:middle
initializer, we actually don't
inherit those other convenience

00:34:51.436 --> 00:34:53.666 A:middle
initializers or the other
designated initializer.

00:34:54.786 --> 00:34:58.846 A:middle
So that's how you would use
initializers to set properties

00:34:58.846 --> 00:35:01.396 A:middle
and how you can set
properties in line directly,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:58.846 --> 00:35:01.396 A:middle
and how you can set
properties in line directly,

00:35:02.196 --> 00:35:04.336 A:middle
but I haven't told you about a
pattern and you may be familiar

00:35:04.336 --> 00:35:07.886 A:middle
with from Objective-C sometimes
called lazy instantiation

00:35:07.886 --> 00:35:12.056 A:middle
or lazy initialization where
you want to delay the evaluation

00:35:12.296 --> 00:35:16.156 A:middle
of a property in setting
it because, for example,

00:35:16.156 --> 00:35:18.786 A:middle
maybe doing so is
computationally expensive.

00:35:19.706 --> 00:35:23.616 A:middle
So we have the same concept
in Swift using lazy properties

00:35:24.296 --> 00:35:27.336 A:middle
and let's take a
look at an example

00:35:27.336 --> 00:35:29.466 A:middle
of where you might use one,
where it might be appropriate.

00:35:29.466 --> 00:35:32.276 A:middle
Say we have a game class and
the game can either be a single

00:35:32.276 --> 00:35:33.896 A:middle
player game or a
multi-player game.

00:35:34.606 --> 00:35:38.636 A:middle
Now, the multiplayerManager
let's just suppose

00:35:38.966 --> 00:35:41.326 A:middle
that it does a bunch of
expensive computation

00:35:41.646 --> 00:35:43.206 A:middle
and so we don't want
to create it

00:35:43.956 --> 00:35:45.716 A:middle
if there's only ever
a single player.

00:35:46.766 --> 00:35:48.816 A:middle
We only want to create it
when there's multiple players.

00:35:49.476 --> 00:35:51.536 A:middle
So we want to delay
that initialization

00:35:51.536 --> 00:35:52.646 A:middle
until it's appropriate.

00:35:53.246 --> 00:35:59.356 A:middle
So we can do this in Swift by
including the @lazy attribute

00:35:59.356 --> 00:36:00.786 A:middle
in front of the declaration here


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.356 --> 00:36:00.786 A:middle
in front of the declaration here

00:36:01.376 --> 00:36:05.086 A:middle
and when we do this it will
only be evaluated the time it's

00:36:05.086 --> 00:36:08.086 A:middle
accessed and only when it's
accessed and only that one time.

00:36:08.636 --> 00:36:10.226 A:middle
Now just as we have
initialization

00:36:10.226 --> 00:36:10.966 A:middle
in Swift, we also have --

00:36:11.516 --> 00:36:16.716 A:middle
[ Applause ]

00:36:17.216 --> 00:36:18.476 A:middle
Just as we have initialization

00:36:18.476 --> 00:36:20.116 A:middle
in Swift we have
deinitialization.

00:36:20.116 --> 00:36:22.426 A:middle
Deinitialization is responsible
for tearing down the object.

00:36:22.796 --> 00:36:25.916 A:middle
Now as Joe has already
told you, memory management

00:36:25.916 --> 00:36:28.846 A:middle
in Swift is automatic so most
of the time you don't even need

00:36:28.906 --> 00:36:31.196 A:middle
to think about the
initialization it just works,

00:36:31.196 --> 00:36:32.226 A:middle
it just happens for you.

00:36:33.446 --> 00:36:36.566 A:middle
But for cases where you
do need it, for example,

00:36:36.566 --> 00:36:39.756 A:middle
to unregister yourself as
an observer or, for example,

00:36:39.756 --> 00:36:41.686 A:middle
to close a file that
you may have opened,

00:36:42.306 --> 00:36:45.236 A:middle
we want to have a chance to
close that file and clean

00:36:45.236 --> 00:36:46.836 A:middle
up those non-memory resources.

00:36:47.296 --> 00:36:50.566 A:middle
So for that we use
a deinitializer

00:36:50.926 --> 00:36:53.756 A:middle
and deinitializers are just
declared using the deinit

00:36:53.806 --> 00:36:54.166 A:middle
key word.

00:36:54.456 --> 00:36:56.876 A:middle
So, for example, here we have
a class that when we open

00:36:56.876 --> 00:36:59.706 A:middle
up a file if this class gets
deallocated before we have a

00:36:59.706 --> 00:37:03.816 A:middle
chance to close the file,
that's not good so think of this


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.706 --> 00:37:03.816 A:middle
chance to close the file,
that's not good so think of this

00:37:03.816 --> 00:37:06.496 A:middle
as the last resort, the last
chance you have to clean

00:37:06.496 --> 00:37:10.176 A:middle
up non-memory resources before
your object is deallocated.

00:37:11.106 --> 00:37:13.016 A:middle
Again most of the time you
probably won't need them.

00:37:13.656 --> 00:37:15.076 A:middle
So that's initialization
in Swift.

00:37:15.316 --> 00:37:15.876 A:middle
It's safe.

00:37:16.696 --> 00:37:19.386 A:middle
You initialize all of your
values before you use them

00:37:19.386 --> 00:37:22.216 A:middle
and set your stored
property values first

00:37:22.806 --> 00:37:25.086 A:middle
and then call your super
class initializer always

00:37:25.086 --> 00:37:25.626 A:middle
in that order.

00:37:26.416 --> 00:37:28.536 A:middle
Designated initializers
only delegate up

00:37:28.976 --> 00:37:31.896 A:middle
and convenience initializers
only delegate across.

00:37:32.816 --> 00:37:35.916 A:middle
And finally, we have the
initializers if you need them,

00:37:36.296 --> 00:37:37.386 A:middle
but most of the time you won't.

00:37:37.386 --> 00:37:39.456 A:middle
So that's initialization.

00:37:39.456 --> 00:37:41.586 A:middle
I'd like to invite Joe back
on the stage to talk to you

00:37:41.586 --> 00:37:42.576 A:middle
about closures in Swift.

00:37:43.516 --> 00:37:50.826 A:middle
[ Applause ]

00:37:51.326 --> 00:37:54.366 A:middle
&gt;&gt; Now, there are a lot
of ways to sort an array

00:37:54.366 --> 00:37:57.686 A:middle
and we could keep our standard
library writers busy writing a

00:37:57.686 --> 00:38:01.356 A:middle
million different sort methods
on array, but we'd rather not.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:57.686 --> 00:38:01.356 A:middle
million different sort methods
on array, but we'd rather not.

00:38:01.676 --> 00:38:04.566 A:middle
So instead we have a single sort
method that takes a closure.

00:38:04.646 --> 00:38:06.656 A:middle
You've probably seen a bit
of this in the intro talk

00:38:06.656 --> 00:38:07.776 A:middle
or even in the keynotes.

00:38:08.766 --> 00:38:13.096 A:middle
A closure in Swift is
spelled inside curly braces.

00:38:13.976 --> 00:38:15.466 A:middle
You follow it with a signature.

00:38:15.466 --> 00:38:18.696 A:middle
In the case of sort,
it takes two arguments

00:38:18.696 --> 00:38:20.666 A:middle
of the element type of the
array, in this case String,

00:38:20.666 --> 00:38:23.396 A:middle
and in terms of Boolean telling
us whether the elements are

00:38:23.396 --> 00:38:24.546 A:middle
sorted in the right order.

00:38:25.606 --> 00:38:26.886 A:middle
Default with the in key word,

00:38:26.886 --> 00:38:30.466 A:middle
you're binding these arguments
inside the body of the closure

00:38:30.926 --> 00:38:34.786 A:middle
and then you follow it with
the body of the function.

00:38:35.346 --> 00:38:40.406 A:middle
And now we have a single sort
method that can sort an array

00:38:40.406 --> 00:38:41.736 A:middle
in a number of different ways.

00:38:42.366 --> 00:38:45.976 A:middle
We can sort A to Z ascending
using the lesson operator.

00:38:46.736 --> 00:38:49.776 A:middle
We can sort descending using
the greater than operator.

00:38:50.336 --> 00:38:54.916 A:middle
We can even do something like
sort from shortest to longest

00:38:54.916 --> 00:38:56.876 A:middle
by counting the number of
characters in each string.

00:38:57.566 --> 00:39:00.656 A:middle
Now this is a great interface.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:57.566 --> 00:39:00.656 A:middle
Now this is a great interface.

00:39:01.076 --> 00:39:04.866 A:middle
It's also a lot of
typing and closures

00:39:04.866 --> 00:39:07.286 A:middle
in this form are a little
awkward to work with

00:39:07.796 --> 00:39:11.776 A:middle
and the actual interesting
part gets lost

00:39:11.776 --> 00:39:13.486 A:middle
in a lot of syntactic noise.

00:39:14.686 --> 00:39:16.976 A:middle
Thankfully we have type
inference to help us here.

00:39:17.286 --> 00:39:18.926 A:middle
Let's open a definition
of sorts.

00:39:20.216 --> 00:39:22.936 A:middle
Sort, of course, already knows
what kind of closure it takes.

00:39:22.936 --> 00:39:25.736 A:middle
In this case, we're working
with an array of strings

00:39:25.736 --> 00:39:28.056 A:middle
so it takes two strings
and returns a Bool.

00:39:28.056 --> 00:39:32.336 A:middle
Let's look at the
call side again

00:39:32.336 --> 00:39:36.026 A:middle
and that's really offensive,

00:39:36.026 --> 00:39:38.306 A:middle
that's really burning
my eyes here and I want

00:39:39.396 --> 00:39:42.526 A:middle
to do something about that.

00:39:42.746 --> 00:39:43.456 A:middle
Much better.

00:39:44.446 --> 00:39:47.066 A:middle
We can infer the
argument and return types

00:39:47.376 --> 00:39:49.416 A:middle
from the signature
of the function.

00:39:49.966 --> 00:39:53.746 A:middle
That's a great improvement
but we don't stop there.

00:39:54.176 --> 00:39:56.496 A:middle
If a closure consists of
a single return statement

00:39:56.496 --> 00:39:59.336 A:middle
like this, we don't
need to specify return.

00:39:59.746 --> 00:40:03.766 A:middle
A single expression closure
implicitly returns its results.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.746 --> 00:40:03.766 A:middle
A single expression closure
implicitly returns its results.

00:40:04.516 --> 00:40:07.576 A:middle
[ Applause ]

00:40:08.076 --> 00:40:08.456 A:middle
Thank you.

00:40:10.116 --> 00:40:12.996 A:middle
At this point even the
argument list is starting

00:40:12.996 --> 00:40:14.056 A:middle
to look a little heavy.

00:40:14.466 --> 00:40:15.656 A:middle
Let's get rid of
that too [laughter].

00:40:17.306 --> 00:40:21.836 A:middle
There are implicit argument
names, $0, $1, $ a million,

00:40:22.136 --> 00:40:24.416 A:middle
they may need a little taste
in some cases but they're there

00:40:24.416 --> 00:40:26.846 A:middle
if you need them and they
make closures really succinct

00:40:26.846 --> 00:40:29.236 A:middle
and easy to use.

00:40:29.406 --> 00:40:31.786 A:middle
We've also seen that we have
trailing closure syntax.

00:40:32.156 --> 00:40:34.106 A:middle
When you have a single
argument like this,

00:40:35.216 --> 00:40:37.966 A:middle
you can move it outside and when
it's the only argument you can

00:40:37.966 --> 00:40:39.356 A:middle
drop the parens all together.

00:40:40.426 --> 00:40:42.136 A:middle
And this makes functional
programming

00:40:42.136 --> 00:40:44.526 A:middle
in Swift really expressive
and fun to do

00:40:44.526 --> 00:40:49.336 A:middle
and we've added methods to the
array class, to the array struct

00:40:49.376 --> 00:40:51.366 A:middle
to make this possible.

00:40:52.116 --> 00:40:53.836 A:middle
I'll start with a
list of all the words

00:40:53.836 --> 00:40:56.726 A:middle
in the English language that we
got from the dictionary service.

00:40:57.086 --> 00:41:03.006 A:middle
Now we can pick out words
that share some common traits,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:57.086 --> 00:41:03.006 A:middle
Now we can pick out words
that share some common traits,

00:41:03.006 --> 00:41:04.806 A:middle
say the ones that end
in G-R-Y and it turns

00:41:04.806 --> 00:41:07.496 A:middle
out there's only two and we
can use the filter method

00:41:07.956 --> 00:41:12.476 A:middle
which selects out, which applies
a closure to each element

00:41:12.476 --> 00:41:16.956 A:middle
of the array and for the one it
returns true returns a new array

00:41:16.956 --> 00:41:17.936 A:middle
containing those.

00:41:18.336 --> 00:41:23.326 A:middle
We can then transform
these with the map method,

00:41:23.656 --> 00:41:25.246 A:middle
which applies closure
to each element

00:41:25.246 --> 00:41:27.646 A:middle
and collects the results
into another array.

00:41:28.166 --> 00:41:31.016 A:middle
And then we can use
the reduced method

00:41:31.296 --> 00:41:34.246 A:middle
to fold these into
a single string.

00:41:37.136 --> 00:41:40.406 A:middle
Now each of these is
chaining another method call

00:41:40.406 --> 00:41:42.456 A:middle
onto the result of the
previous expression.

00:41:42.926 --> 00:41:45.686 A:middle
Even if we're using trailing
closure syntax we can just chain

00:41:45.686 --> 00:41:48.216 A:middle
method invocations
using dot like this.

00:41:49.196 --> 00:41:53.236 A:middle
Because it's a single expression
we can even include it in a

00:41:53.236 --> 00:41:58.276 A:middle
yet larger expression and
include a lot of complex logic

00:41:58.276 --> 00:42:00.296 A:middle
into a very small
amount of code.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.276 --> 00:42:00.296 A:middle
into a very small
amount of code.

00:42:00.976 --> 00:42:06.376 A:middle
It's an extremely expressive
way to build up your logic even

00:42:06.446 --> 00:42:08.806 A:middle
for a code that doesn't
involve Hulk.

00:42:09.516 --> 00:42:15.916 A:middle
[ Applause ]

00:42:16.416 --> 00:42:18.366 A:middle
Closures can also
capture local states.

00:42:18.936 --> 00:42:23.516 A:middle
We could sum up all the elements
in array using a for loop

00:42:23.516 --> 00:42:27.406 A:middle
or reduce but we can
actually abuse math to do it.

00:42:27.676 --> 00:42:30.196 A:middle
Inside of closure we can
refer to local variables

00:42:30.196 --> 00:42:31.466 A:middle
and we can even mutate them.

00:42:31.466 --> 00:42:35.636 A:middle
There's never need to mark
them under block or in any way.

00:42:35.636 --> 00:42:36.526 A:middle
It just works.

00:42:37.676 --> 00:42:43.796 A:middle
And then we can return
that result.

00:42:43.796 --> 00:42:47.226 A:middle
Closures are really just
literal functions in Swift just

00:42:47.226 --> 00:42:48.996 A:middle
like you can pass
a literal integer

00:42:48.996 --> 00:42:51.746 A:middle
or a named integer constant
as an integer parameter,

00:42:51.746 --> 00:42:54.666 A:middle
you can pass a closure
or, indeed,

00:42:54.666 --> 00:42:57.076 A:middle
a named function
as a closure value.

00:42:57.336 --> 00:43:00.296 A:middle
We don't have to wrap up print
line in a closure like this.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:57.336 --> 00:43:00.296 A:middle
We don't have to wrap up print
line in a closure like this.

00:43:01.196 --> 00:43:02.426 A:middle
We can just pass print line.

00:43:02.426 --> 00:43:04.516 A:middle
There's only one kind of
function type in Swift.

00:43:05.056 --> 00:43:09.136 A:middle
We can even do this with
bound methods instead

00:43:09.136 --> 00:43:12.516 A:middle
of packing an index set
like this wrapping a call

00:43:12.516 --> 00:43:16.126 A:middle
to the method in a closure we
can just pass the bound method

00:43:16.126 --> 00:43:17.626 A:middle
directly as a function value.

00:43:20.836 --> 00:43:23.206 A:middle
Closures in Swift
are just ARC objects.

00:43:23.206 --> 00:43:25.766 A:middle
They follow the same memory
management rules as classes.

00:43:25.766 --> 00:43:29.486 A:middle
So if we wanted to
have a global variable

00:43:29.486 --> 00:43:33.786 A:middle
that we can install a call
back on and write a function

00:43:34.326 --> 00:43:41.836 A:middle
that installs a call back using
local state of that function,

00:43:41.936 --> 00:43:44.476 A:middle
that reference will keep
that closure and all

00:43:44.476 --> 00:43:45.656 A:middle
of its local state alive.

00:43:45.656 --> 00:43:47.806 A:middle
There's never a need to
explicitly copy a closure

00:43:47.806 --> 00:43:50.586 A:middle
or to worry about dangling
references to its environment

00:43:51.106 --> 00:43:53.976 A:middle
and just like closures
of functions,

00:43:54.036 --> 00:43:55.356 A:middle
functions are also closures.

00:43:55.356 --> 00:43:58.616 A:middle
We can nest functions inside
other functions and refer

00:43:58.616 --> 00:44:00.576 A:middle
to the local state of
the outer function.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.616 --> 00:44:00.576 A:middle
to the local state of
the outer function.

00:44:01.116 --> 00:44:03.306 A:middle
If we look at these in the
debugger or instruments,

00:44:03.306 --> 00:44:04.756 A:middle
they show up with their names.

00:44:05.326 --> 00:44:10.936 A:middle
So when we store a reference
to this in a global variable,

00:44:11.596 --> 00:44:13.586 A:middle
even when the local
function goes out of scope

00:44:14.206 --> 00:44:16.466 A:middle
that reference keeps the
local function alive just

00:44:16.466 --> 00:44:17.196 A:middle
like the closure.

00:44:17.806 --> 00:44:23.326 A:middle
Now because closures are ARC
objects they have the same

00:44:23.326 --> 00:44:26.836 A:middle
ownership and reference cycle
problems as classes can have.

00:44:27.426 --> 00:44:29.956 A:middle
If we did something
as seemingly innocent

00:44:29.956 --> 00:44:33.716 A:middle
as taking this call back and
putting it into the property

00:44:33.826 --> 00:44:37.026 A:middle
of a class, we'll
have a problem.

00:44:38.406 --> 00:44:41.306 A:middle
When we go to set up
these objects, of course,

00:44:41.476 --> 00:44:43.606 A:middle
what we're really doing
is we're capturing self

00:44:43.606 --> 00:44:46.106 A:middle
and we're capturing it as
a strong reference and then

00:44:46.106 --> 00:44:48.826 A:middle
when we store reference to
the closure inside the class,

00:44:49.546 --> 00:44:53.706 A:middle
we end up with the reference
cycle and a memory leak.

00:44:54.666 --> 00:44:59.156 A:middle
The compiler actually won't let
you implicitly reference self

00:44:59.156 --> 00:45:01.136 A:middle
inside of closure
because of this problem.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.156 --> 00:45:01.136 A:middle
inside of closure
because of this problem.

00:45:01.396 --> 00:45:04.816 A:middle
Yeah, it's pretty nice.

00:45:05.526 --> 00:45:08.346 A:middle
Now in a past life, you may
have solved this using unknown

00:45:08.346 --> 00:45:11.946 A:middle
reference, using a local
variable with weak ownership.

00:45:12.886 --> 00:45:15.696 A:middle
In Swift, we can use
unowned ownership instead,

00:45:16.666 --> 00:45:18.976 A:middle
but this is problematic.

00:45:18.976 --> 00:45:21.536 A:middle
Even if we did this if
someone cut and pasted code

00:45:21.536 --> 00:45:23.426 A:middle
into this closure, it
would still be capturing

00:45:23.426 --> 00:45:24.366 A:middle
self strongly.

00:45:24.686 --> 00:45:26.356 A:middle
So we have a better
way to do it in Swift.

00:45:27.136 --> 00:45:29.676 A:middle
You can specify directly
inside the closure how

00:45:29.676 --> 00:45:31.176 A:middle
to capture its local states.

00:45:32.516 --> 00:45:37.006 A:middle
[ Applause ]

00:45:37.506 --> 00:45:39.086 A:middle
And now when we set
up the object graph,

00:45:39.136 --> 00:45:41.326 A:middle
there's no longer a cycle
and there's no leak.

00:45:41.946 --> 00:45:44.716 A:middle
So that's closures in Swift.

00:45:44.716 --> 00:45:47.656 A:middle
They have an incredibly
expressive syntax

00:45:48.966 --> 00:45:51.456 A:middle
and a much simplified memory
model from Objective-C

00:45:51.456 --> 00:45:53.406 A:middle
and they make functional
programming

00:45:53.406 --> 00:45:55.346 A:middle
in Swift really awesome
and powerful.

00:45:55.346 --> 00:45:59.326 A:middle
Now I'd like to talk about
another powerful feature

00:45:59.326 --> 00:46:01.116 A:middle
of Swift, pattern matching.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:59.326 --> 00:46:01.116 A:middle
of Swift, pattern matching.

00:46:01.716 --> 00:46:08.136 A:middle
You may have seen in the intro
talk that Switch not only works

00:46:08.136 --> 00:46:11.496 A:middle
with integers it also works
with strings or, indeed,

00:46:11.496 --> 00:46:15.826 A:middle
values of any type and also
works with ranges of values

00:46:15.896 --> 00:46:18.006 A:middle
but that's just the
tip of the iceberg.

00:46:19.156 --> 00:46:21.326 A:middle
You may also remember
that enumerations

00:46:21.326 --> 00:46:24.606 A:middle
in Swift can carry associated
data and we can tell not only

00:46:24.606 --> 00:46:27.076 A:middle
that a train is delayed
we can say by how much

00:46:27.296 --> 00:46:29.366 A:middle
with an integer value
that only makes sense

00:46:30.526 --> 00:46:31.896 A:middle
when the train is delayed.

00:46:33.276 --> 00:46:37.516 A:middle
Because this associated data is
tied to that case of the enum,

00:46:38.626 --> 00:46:40.536 A:middle
we access it through
a case statement.

00:46:41.776 --> 00:46:43.796 A:middle
We combine it to a
variable and then use

00:46:43.796 --> 00:46:45.966 A:middle
that variable inside
that case statement.

00:46:46.246 --> 00:46:48.886 A:middle
It's electrically
scoped to that case.

00:46:49.406 --> 00:46:52.476 A:middle
Cases are electrical
scopes by default in Swift

00:46:52.476 --> 00:46:54.316 A:middle
and we can't access
it anywhere else.

00:46:54.316 --> 00:46:57.276 A:middle
It's much safer and easier
than using an enum with a union

00:46:57.276 --> 00:46:59.076 A:middle
or struct like you
may have in C.

00:46:59.566 --> 00:47:03.326 A:middle
Now this is a simple
case of a pattern.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.566 --> 00:47:03.326 A:middle
Now this is a simple
case of a pattern.

00:47:04.126 --> 00:47:08.906 A:middle
This outer construct
Delayed only matches values

00:47:08.906 --> 00:47:11.486 A:middle
of the delayed state
inside the enum.

00:47:12.966 --> 00:47:16.196 A:middle
If it is at the delayed state,
it unwraps the associated data

00:47:16.196 --> 00:47:17.996 A:middle
and passes it down
to a sub pattern.

00:47:18.196 --> 00:47:21.106 A:middle
In this case, the let pattern
binds it to a variable.

00:47:21.586 --> 00:47:25.446 A:middle
This is actually a
completely independent

00:47:25.446 --> 00:47:26.666 A:middle
and fully powerful pattern.

00:47:26.666 --> 00:47:29.226 A:middle
Anything we do at the
top level of a switch

00:47:29.226 --> 00:47:31.746 A:middle
with an int we can do
to its associated value.

00:47:32.806 --> 00:47:35.456 A:middle
So we can match it against a
specific value say we're delayed

00:47:35.456 --> 00:47:36.256 A:middle
by 1 minute.

00:47:36.856 --> 00:47:37.946 A:middle
We can match it against a range

00:47:37.946 --> 00:47:40.166 A:middle
of values say we're delayed
from 2 to 10 minutes.

00:47:41.046 --> 00:47:42.876 A:middle
We can also ignore the
value all together,

00:47:42.876 --> 00:47:45.796 A:middle
match any Delay using
the underscore,

00:47:45.796 --> 00:47:47.946 A:middle
which is the wild card pattern.

00:47:48.516 --> 00:47:54.646 A:middle
[ Applause ]

00:47:55.146 --> 00:47:58.266 A:middle
You can also use enums as
associated data of other enums.

00:47:58.796 --> 00:48:02.296 A:middle
We can track not only the status


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:58.796 --> 00:48:02.296 A:middle
We can track not only the status

00:48:02.296 --> 00:48:05.246 A:middle
of our train while we're
traveling we can track the

00:48:05.246 --> 00:48:07.526 A:middle
entire state of our
vacation and when we do so,

00:48:07.526 --> 00:48:08.706 A:middle
we can tell our friends

00:48:08.706 --> 00:48:10.526 A:middle
on social media based
on that state.

00:48:11.246 --> 00:48:13.056 A:middle
We can match a simple
case of the enum,

00:48:13.736 --> 00:48:17.196 A:middle
we can match a nested associated
value two levels deep.

00:48:17.296 --> 00:48:20.346 A:middle
If we're 15 minutes in, we might
be able to, 15 minutes delayed,

00:48:20.346 --> 00:48:22.896 A:middle
we might be a little
snarky, but still composed.

00:48:23.596 --> 00:48:24.756 A:middle
If we're delayed
any more than that,

00:48:24.756 --> 00:48:26.826 A:middle
we might get a little upset.

00:48:30.296 --> 00:48:31.816 A:middle
Pattern matching
doesn't just work

00:48:31.816 --> 00:48:33.206 A:middle
with enumerations it also works

00:48:33.206 --> 00:48:35.656 A:middle
with the dynamic
types of classes.

00:48:36.166 --> 00:48:40.106 A:middle
Let's say we're going to tune up
a car and it's an arbitrary car.

00:48:40.766 --> 00:48:44.046 A:middle
If someone brings a Formula
One car into our mechanics,

00:48:44.046 --> 00:48:48.296 A:middle
to our mechanic, he's probably
going to be a little confused.

00:48:48.296 --> 00:48:49.886 A:middle
He might want to take
it to a specialist.

00:48:50.786 --> 00:48:52.716 A:middle
We can do this using
the as pattern.

00:48:53.276 --> 00:48:56.136 A:middle
This will both check that
the value is of a type and if

00:48:56.136 --> 00:48:59.516 A:middle
so cast it and pass it
into the sub pattern,

00:48:59.516 --> 00:49:02.906 A:middle
which we can then use to bind a
variable and then we can pass it


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.516 --> 00:49:02.906 A:middle
which we can then use to bind a
variable and then we can pass it

00:49:02.906 --> 00:49:06.416 A:middle
on to a pit crew who will then
tune up that Formula One car.

00:49:07.516 --> 00:49:11.396 A:middle
For a more mundane car, we
can pattern match it and then

00:49:11.396 --> 00:49:14.406 A:middle
if it has a turbo tune up
the turbo before following

00:49:14.456 --> 00:49:17.996 A:middle
through using the fall through
statement into the default case

00:49:18.196 --> 00:49:22.986 A:middle
that does the normal
tune up for a car.

00:49:23.186 --> 00:49:26.096 A:middle
We can also pattern match
multiple values simultaneously

00:49:26.096 --> 00:49:27.036 A:middle
using tuples.

00:49:27.446 --> 00:49:30.006 A:middle
Tuples are a great way of
returning multiple values

00:49:30.006 --> 00:49:33.846 A:middle
from a function or for
combining related values

00:49:33.846 --> 00:49:39.236 A:middle
like the components of a color
and when we do so, each element

00:49:39.236 --> 00:49:41.566 A:middle
of this tuple pattern is
an independent pattern.

00:49:42.346 --> 00:49:46.506 A:middle
We can match red against a
single value, we can match green

00:49:46.506 --> 00:49:49.876 A:middle
against a range of values,
bind blue to a variable

00:49:50.206 --> 00:49:54.826 A:middle
and ignore the alpha component
all in a single pattern.

00:49:55.516 --> 00:49:59.726 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:00.226 --> 00:50:02.366 A:middle
We can also match
multiple values

00:50:02.366 --> 00:50:03.866 A:middle
and test additional conditions

00:50:03.866 --> 00:50:05.706 A:middle
with those values
using a where clause.

00:50:06.626 --> 00:50:08.376 A:middle
Here we're testing that
they're all equal to see

00:50:08.376 --> 00:50:09.606 A:middle
if it's a grey scale value.

00:50:10.186 --> 00:50:13.956 A:middle
So these are some
neat parlor tricks.

00:50:14.166 --> 00:50:16.086 A:middle
Let's try something
a little more real.

00:50:16.086 --> 00:50:21.186 A:middle
Let's validate a property list,
a dictionary of arbitrary values

00:50:21.186 --> 00:50:24.976 A:middle
of unknown type and
given a valid one we want

00:50:24.976 --> 00:50:27.386 A:middle
to return a well-typed struct.

00:50:30.756 --> 00:50:35.236 A:middle
Given a property list with
a name key that's a string,

00:50:35.306 --> 00:50:36.796 A:middle
a population that's a number

00:50:37.056 --> 00:50:39.026 A:middle
and a two-letter
postal abbreviation,

00:50:39.026 --> 00:50:42.056 A:middle
we want to get a
record like this.

00:50:42.266 --> 00:50:44.756 A:middle
However, if one of the
fields is of the wrong type

00:50:44.756 --> 00:50:50.256 A:middle
or if the postal abbreviation is
too long, we want to return nil.

00:50:51.126 --> 00:50:52.766 A:middle
Let's see how we can do
this with pattern matching.

00:50:53.436 --> 00:50:59.466 A:middle
We'll start with a single
key of the property list

00:50:59.806 --> 00:51:05.466 A:middle
and you may remember that
optional is just an enumeration


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.806 --> 00:51:05.466 A:middle
and you may remember that
optional is just an enumeration

00:51:05.466 --> 00:51:07.246 A:middle
so we can use an
enumeration pattern

00:51:07.246 --> 00:51:09.936 A:middle
to both reject property
lists that don't have the key

00:51:10.166 --> 00:51:14.476 A:middle
and unwrap the value
for ones that do.

00:51:14.726 --> 00:51:17.906 A:middle
Inside that pattern we
can use a type pattern

00:51:17.906 --> 00:51:20.916 A:middle
to both reject property lists
that don't have a string name

00:51:21.356 --> 00:51:23.796 A:middle
and get the string value
out for those that do.

00:51:24.896 --> 00:51:27.856 A:middle
Then we can use a let pattern
to bind to that string value

00:51:28.446 --> 00:51:29.726 A:middle
and store it to a variable

00:51:30.296 --> 00:51:34.616 A:middle
with a single default clause
handle all invalid names.

00:51:35.056 --> 00:51:38.726 A:middle
Now we can repeat this for
each element that we care

00:51:38.726 --> 00:51:41.736 A:middle
about inside the dictionary
but there's a better way.

00:51:42.226 --> 00:51:43.816 A:middle
Remember we can use
tuple patterns

00:51:43.886 --> 00:51:48.396 A:middle
to match these simultaneously
and repeat this pattern

00:51:48.746 --> 00:51:52.236 A:middle
for each key of the property
list that we're interested in.

00:51:52.766 --> 00:51:55.316 A:middle
We can see that the
name is a string,

00:51:55.316 --> 00:51:56.566 A:middle
the population is a number

00:51:56.566 --> 00:52:00.196 A:middle
and the abbreviation is a string
all simultaneously and with the


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:56.566 --> 00:52:00.196 A:middle
and the abbreviation is a string
all simultaneously and with the

00:52:00.196 --> 00:52:02.216 A:middle
where clause even
check the abbreviations

00:52:02.216 --> 00:52:06.596 A:middle
of the appropriate
length and we're done.

00:52:06.816 --> 00:52:09.886 A:middle
With a single default clause
we handle all invalid property

00:52:09.886 --> 00:52:12.496 A:middle
lists and it all fits
nicely on a single slide.

00:52:13.746 --> 00:52:14.926 A:middle
That's the power of
pattern matching.

00:52:15.516 --> 00:52:19.566 A:middle
[ Applause ]

00:52:20.066 --> 00:52:22.336 A:middle
It's an incredible way to
test the structure of values

00:52:22.746 --> 00:52:24.536 A:middle
and really improve
the readability

00:52:24.626 --> 00:52:25.926 A:middle
and safety of your code.

00:52:26.486 --> 00:52:31.846 A:middle
So we still just scratched the
surface of what Swift can do.

00:52:33.146 --> 00:52:36.746 A:middle
We've looked at how optionals
allow you to write safe code,

00:52:37.196 --> 00:52:39.956 A:middle
we looked at the
foundations of Swift

00:52:39.956 --> 00:52:42.006 A:middle
in memory management
and initialization.

00:52:43.546 --> 00:52:45.476 A:middle
We looked at how
powerful closure is

00:52:45.476 --> 00:52:46.616 A:middle
and pattern matching are.

00:52:47.976 --> 00:52:49.796 A:middle
There's a ton more
information online.

00:52:50.116 --> 00:52:52.096 A:middle
There's the book that you
probably already downloaded

00:52:52.096 --> 00:52:52.946 A:middle
and read by now.

00:52:53.026 --> 00:52:56.036 A:middle
There's also some additional
material on the developer's site

00:52:56.036 --> 00:52:57.386 A:middle
about Interop with Cocoa.

00:52:58.166 --> 00:53:01.746 A:middle
If you're following along from
home, talk to Dave he's great


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.166 --> 00:53:01.746 A:middle
If you're following along from
home, talk to Dave he's great

00:53:02.016 --> 00:53:02.996 A:middle
and there's our forums.

00:53:03.656 --> 00:53:07.036 A:middle
You also might want to
save your seat here.

00:53:07.036 --> 00:53:09.216 A:middle
We've got a lot of other great
Swift sessions right here

00:53:09.216 --> 00:53:09.916 A:middle
in Presidio.

00:53:10.816 --> 00:53:11.476 A:middle
Thank you.

