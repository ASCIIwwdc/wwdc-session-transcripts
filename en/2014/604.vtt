WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:13.336 --> 00:00:14.186 A:middle
&gt;&gt; So welcome.

00:00:14.896 --> 00:00:15.736 A:middle
So, thank you.

00:00:21.836 --> 00:00:24.046 A:middle
So my name's Richard
Schreyer, and I've been working

00:00:24.046 --> 00:00:26.146 A:middle
on the design of Metal
for quite a while now.

00:00:26.146 --> 00:00:28.246 A:middle
And it's really exciting
to finally be able

00:00:28.246 --> 00:00:29.206 A:middle
to talk to all of you about.

00:00:29.536 --> 00:00:31.826 A:middle
So this is the Metal
fundamental session.

00:00:32.016 --> 00:00:35.396 A:middle
It's the second in our trio of
sessions, following concepts

00:00:35.466 --> 00:00:37.816 A:middle
and to be followed by
Metal advanced usage.

00:00:38.036 --> 00:00:42.276 A:middle
So this session is going to
be split into two major parts.

00:00:43.036 --> 00:00:45.306 A:middle
The first half which I'm going
to present is going to be how

00:00:45.306 --> 00:00:47.126 A:middle
to build a basic
Metal application.

00:00:48.056 --> 00:00:49.686 A:middle
I want to take all
of the concepts

00:00:49.686 --> 00:00:50.736 A:middle
that Jeremy just described,

00:00:50.876 --> 00:00:52.946 A:middle
a bunch of block
diagrams and arrows.

00:00:53.376 --> 00:00:54.956 A:middle
And turn those into actual code.

00:00:55.646 --> 00:00:57.986 A:middle
So, we'll try to make
everything more concrete.

00:00:59.636 --> 00:01:01.126 A:middle
During the second
half of the session,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.636 --> 00:01:01.126 A:middle
During the second
half of the session,

00:01:01.126 --> 00:01:03.176 A:middle
I'm going to turn the stage over
to my colleague Aafi [phonetic],

00:01:03.176 --> 00:01:05.196 A:middle
who will take you
into a deep dive

00:01:05.266 --> 00:01:06.496 A:middle
into the Metal shading language.

00:01:07.076 --> 00:01:10.366 A:middle
Talk about, you know, the
various syntax and data types.

00:01:10.366 --> 00:01:12.736 A:middle
How to express vertex,
pixel and compute shaders.

00:01:12.996 --> 00:01:15.246 A:middle
And then a bunch of grab bag
of other interesting topics.

00:01:16.236 --> 00:01:19.176 A:middle
So, getting right into
building a Metal application.

00:01:19.176 --> 00:01:24.186 A:middle
So as I said, this is going to
be a fairly, a set of slides

00:01:24.716 --> 00:01:26.376 A:middle
that are fairly heavy on code.

00:01:26.496 --> 00:01:29.036 A:middle
That's really what I want to
try to get across is, you know,

00:01:29.146 --> 00:01:31.906 A:middle
what you're going to actually
want to put down in Xcode.

00:01:32.106 --> 00:01:33.986 A:middle
So I'm going to try and
keep this application

00:01:33.986 --> 00:01:34.896 A:middle
as simple as possible.

00:01:34.896 --> 00:01:36.946 A:middle
So it's going to be a very
hello world kind of thing.

00:01:37.416 --> 00:01:40.576 A:middle
So in the interest of, is it
always that way in graphics?

00:01:40.576 --> 00:01:41.836 A:middle
So the application I'm going

00:01:41.836 --> 00:01:43.616 A:middle
to build is basically
just a triangle.

00:01:43.616 --> 00:01:45.456 A:middle
We're going to go
through all the steps

00:01:45.456 --> 00:01:47.896 A:middle
to go put a single shaded
triangle on the screen.

00:01:48.086 --> 00:01:49.896 A:middle
I know, really exciting stuff.

00:01:51.476 --> 00:01:54.016 A:middle
But it's actually pretty cool
because, and we're going to go

00:01:54.016 --> 00:01:56.136 A:middle
through some boiler
plate and some setup.

00:01:56.136 --> 00:01:57.306 A:middle
But once you get through that,

00:01:57.306 --> 00:01:58.936 A:middle
that's really the same
foundation you need

00:01:58.936 --> 00:02:01.276 A:middle
to start building immediately
a much more complex content


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:58.936 --> 00:02:01.276 A:middle
to start building immediately
a much more complex content

00:02:01.276 --> 00:02:01.886 A:middle
on top of that.

00:02:02.536 --> 00:02:05.016 A:middle
So we're not going out of our
way to draw such a triangle.

00:02:07.226 --> 00:02:08.985 A:middle
So the first set of
things I'm going to go

00:02:08.985 --> 00:02:10.616 A:middle
through are just
the initialization.

00:02:10.616 --> 00:02:12.556 A:middle
I mean what's the
one-shot setup you'll do

00:02:12.646 --> 00:02:14.646 A:middle
when your application launches
or you start using Metal?

00:02:15.646 --> 00:02:17.686 A:middle
Then I'll get into the
contents of what, you know,

00:02:17.686 --> 00:02:18.996 A:middle
the actual drawing
will look like.

00:02:19.736 --> 00:02:22.356 A:middle
And then we'll get on to
extending the application

00:02:22.356 --> 00:02:23.806 A:middle
to do a little bit more stuff.

00:02:23.906 --> 00:02:26.256 A:middle
So these are the
steps that we'll walk

00:02:26.256 --> 00:02:27.346 A:middle
through in the code in order.

00:02:28.546 --> 00:02:30.506 A:middle
So right at the top
is getting the device.

00:02:31.106 --> 00:02:32.506 A:middle
So what is the device API?

00:02:33.286 --> 00:02:37.586 A:middle
So Metal, a device is sort of
the root object of a whole API.

00:02:37.586 --> 00:02:40.656 A:middle
It's your direct connection

00:02:40.656 --> 00:02:42.916 A:middle
to the GPU driver
and the GPU hardware.

00:02:43.616 --> 00:02:46.226 A:middle
Now as far as the actual API
that the device sends out,

00:02:46.886 --> 00:02:50.226 A:middle
what it really does directly,
it's the source that you go

00:02:50.226 --> 00:02:52.556 A:middle
to to create all the other
objects in the Metal API.

00:02:53.786 --> 00:02:56.856 A:middle
So if you want to go create
a new texture or a new buffer

00:02:56.856 --> 00:02:59.146 A:middle
or a new RenderPipeline,
the device is

00:02:59.146 --> 00:02:59.876 A:middle
where you'll find that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:01.006 --> 00:03:02.826 A:middle
So, we want to go
create some stuff,

00:03:02.826 --> 00:03:04.616 A:middle
and so we need a device
to create them on.

00:03:05.236 --> 00:03:05.966 A:middle
So that's really easy.

00:03:06.026 --> 00:03:09.016 A:middle
So our first initialization
step is to just say hey,

00:03:09.096 --> 00:03:12.396 A:middle
I want the default device.

00:03:13.196 --> 00:03:17.046 A:middle
Our second initialization step
is we need a command queue.

00:03:18.126 --> 00:03:20.996 A:middle
The CommandQueue is our channel
to submit work to the GPU.

00:03:21.726 --> 00:03:24.036 A:middle
Now we're not actually going
to do any of that until we get

00:03:24.036 --> 00:03:26.156 A:middle
to drawing, so I'm going to
create a CommandQueue now

00:03:26.446 --> 00:03:28.566 A:middle
from the device and
save it aside.

00:03:29.166 --> 00:03:35.086 A:middle
The third initialization step is
to go create all of my buffers

00:03:35.086 --> 00:03:37.536 A:middle
and textures and
other resources.

00:03:38.316 --> 00:03:40.576 A:middle
My application is simple enough
that I have exactly one of them.

00:03:40.576 --> 00:03:41.416 A:middle
I need a vertexArray.

00:03:41.416 --> 00:03:44.166 A:middle
And so I'm going to
go back to the device

00:03:44.366 --> 00:03:45.866 A:middle
yet again and say newbuffer.

00:03:46.646 --> 00:03:48.886 A:middle
This particular variance
will go allocate a new block

00:03:48.886 --> 00:03:52.256 A:middle
of CPU/GPU shared memory, copy
the provided pointer into it,

00:03:52.256 --> 00:03:53.916 A:middle
and give me back a
handle to that buffer.

00:03:55.376 --> 00:03:57.136 A:middle
So right off the bat
we've gotten through three

00:03:57.136 --> 00:03:58.696 A:middle
of our five initialization
steps.

00:03:58.696 --> 00:03:59.706 A:middle
We're making pretty good time.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.586 --> 00:04:02.706 A:middle
The fourth one is going to
be quite a bit more involved.

00:04:02.706 --> 00:04:04.266 A:middle
We're going to spend
some time on that one.

00:04:04.816 --> 00:04:06.806 A:middle
And that is creating
the RenderPipeline.

00:04:07.416 --> 00:04:09.176 A:middle
So is all.

00:04:09.576 --> 00:04:11.396 A:middle
So as we saw in the
concepts session,

00:04:12.336 --> 00:04:14.366 A:middle
the RenderPipeline
is a collection

00:04:14.366 --> 00:04:15.706 A:middle
of quite a bit of stuff.

00:04:15.976 --> 00:04:19.096 A:middle
Most importantly, the vertex
and the fragment shaders,

00:04:19.896 --> 00:04:22.396 A:middle
but it also incorporates
every other piece of state

00:04:22.396 --> 00:04:24.006 A:middle
that the shader compiler needs

00:04:24.006 --> 00:04:27.346 A:middle
to generate the final
machine code for the A7.

00:04:27.896 --> 00:04:29.926 A:middle
That includes some
information on vertex layout,

00:04:30.236 --> 00:04:33.146 A:middle
some rasterizer configuration,
all of the framebuffer,

00:04:33.146 --> 00:04:35.226 A:middle
blend modes, and
some information

00:04:35.226 --> 00:04:36.846 A:middle
about the framebuffer
configuration

00:04:36.966 --> 00:04:37.966 A:middle
that this pipeline will draw to.

00:04:38.086 --> 00:04:41.486 A:middle
That's actually quite
a bit of stuff.

00:04:41.986 --> 00:04:43.756 A:middle
And so we've split
the RenderPipeline

00:04:43.756 --> 00:04:45.216 A:middle
into two separate objects.

00:04:45.636 --> 00:04:48.596 A:middle
The RenderPipeline
descriptor, which is your object

00:04:48.666 --> 00:04:50.506 A:middle
that provides all the
configuration API,

00:04:50.506 --> 00:04:56.036 A:middle
and the RenderPipeline
state, which is the sort

00:04:56.036 --> 00:04:59.186 A:middle
of baked finalized form of
that, that's just small.

00:04:59.186 --> 00:05:02.526 A:middle
It's compact, and they're
really cheap to switch between.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.186 --> 00:05:02.526 A:middle
It's compact, and they're
really cheap to switch between.

00:05:03.916 --> 00:05:05.706 A:middle
So let's go look at
the code to build,

00:05:05.706 --> 00:05:07.226 A:middle
I'm going to build
one RenderPipeline

00:05:07.226 --> 00:05:12.536 A:middle
in this application, so
let's go look at the code.

00:05:12.646 --> 00:05:15.186 A:middle
So first, I'm going to
conjure up a new descriptor.

00:05:16.286 --> 00:05:18.686 A:middle
And the very first things I'm
going to set on it are my vertex

00:05:18.686 --> 00:05:19.916 A:middle
and my fragment shaders.

00:05:21.736 --> 00:05:23.946 A:middle
And you'll notice that I'm not
providing any source code here.

00:05:24.476 --> 00:05:26.516 A:middle
So this is what the
runtime in API looks

00:05:26.516 --> 00:05:29.246 A:middle
like when Xcode builds your
shaders offline for you.

00:05:29.546 --> 00:05:32.596 A:middle
Xcode's going to package up
all of the offline belt shaders

00:05:33.046 --> 00:05:35.056 A:middle
into a device independent
bicode file.

00:05:35.866 --> 00:05:37.726 A:middle
And ship that into your
application bundle.

00:05:37.776 --> 00:05:40.256 A:middle
And at runtime I can
go ask the device

00:05:40.256 --> 00:05:41.716 A:middle
to load that default library.

00:05:43.266 --> 00:05:45.556 A:middle
Once I have that, I can
go start taking functions

00:05:45.556 --> 00:05:46.496 A:middle
out of that by name.

00:05:49.256 --> 00:05:51.216 A:middle
The second piece of
configuration I need

00:05:51.216 --> 00:05:53.726 A:middle
on the RenderPipeline is
the frame buffer format.

00:05:54.256 --> 00:05:58.256 A:middle
So, I'm only going to have one
color attachment I'm rendering

00:05:58.256 --> 00:06:00.436 A:middle
to, and so I'm going to
say hey, this is going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.256 --> 00:06:00.436 A:middle
to, and so I'm going to
say hey, this is going

00:06:00.436 --> 00:06:01.946 A:middle
to be a BGRA render target.

00:06:03.086 --> 00:06:06.816 A:middle
A RenderPipeline has a whole
bunch of other stuff I can set

00:06:06.816 --> 00:06:08.906 A:middle
on it, but for my simple
little application,

00:06:09.356 --> 00:06:10.536 A:middle
that's really all I need.

00:06:10.946 --> 00:06:13.336 A:middle
The default values of all
the other properties are

00:06:13.336 --> 00:06:14.276 A:middle
already appropriate.

00:06:14.676 --> 00:06:19.096 A:middle
So I'm going to go ahead and
compile and ask the device

00:06:19.096 --> 00:06:20.656 A:middle
to compile a RenderPipeline
state.

00:06:20.896 --> 00:06:21.946 A:middle
I'll just go to the device

00:06:21.946 --> 00:06:25.426 A:middle
and call newRenderPipelineState
WithDescriptor.

00:06:26.706 --> 00:06:28.386 A:middle
So this is actually
the expensive API.

00:06:29.166 --> 00:06:31.646 A:middle
This is the API that is
going to, if necessary,

00:06:31.976 --> 00:06:33.466 A:middle
go call over to the
shader compiler

00:06:33.676 --> 00:06:37.416 A:middle
and finish the code generation,
taking into account all

00:06:37.416 --> 00:06:40.506 A:middle
of the other information
that you have provided.

00:06:40.576 --> 00:06:42.976 A:middle
Once we have this
RenderPipeline, now you,

00:06:43.076 --> 00:06:44.586 A:middle
you know it's all baked.

00:06:44.586 --> 00:06:46.466 A:middle
It's all finalized, and
we can toggle between them

00:06:46.466 --> 00:06:48.476 A:middle
at draw time very, very cheaply.

00:06:48.956 --> 00:06:51.846 A:middle
So that's our fourth
initialization step,

00:06:52.416 --> 00:06:53.496 A:middle
building the RenderPipeline.

00:06:53.916 --> 00:06:57.436 A:middle
But before I move on from that,
you know, since we're pointing

00:06:57.436 --> 00:06:58.946 A:middle
at our vertex and
fragment shader here,

00:06:59.426 --> 00:07:01.336 A:middle
I do want to take a
really quick little detour


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.426 --> 00:07:01.336 A:middle
I do want to take a
really quick little detour

00:07:01.336 --> 00:07:04.066 A:middle
and show you the vertex and
fragment shader code itself.

00:07:04.836 --> 00:07:08.296 A:middle
So I'm not going to explain to
you every part of the syntax,

00:07:08.326 --> 00:07:11.086 A:middle
because Aafi is going to
tell you all about that

00:07:11.086 --> 00:07:12.126 A:middle
in just a few minutes.

00:07:12.876 --> 00:07:15.486 A:middle
But I'm going to show you
just, I'm going to focus

00:07:15.486 --> 00:07:18.696 A:middle
on just the dataflow from the
vertexArray through the vertex

00:07:18.696 --> 00:07:20.896 A:middle
and fragment shader and
into the frame buffer.

00:07:21.616 --> 00:07:24.826 A:middle
So, I split this
up into two slides.

00:07:24.826 --> 00:07:26.686 A:middle
My first slide are
a couple structures

00:07:26.976 --> 00:07:29.276 A:middle
that describe the input and
output of the vertex shader.

00:07:30.156 --> 00:07:34.066 A:middle
The vertex structure defines
how my vertexArray is laid

00:07:34.066 --> 00:07:34.586 A:middle
out in memory.

00:07:34.956 --> 00:07:39.186 A:middle
Position followed by a color.

00:07:39.376 --> 00:07:40.366 A:middle
My vertex shader is going

00:07:40.366 --> 00:07:42.086 A:middle
to be a really simple
pass-through shader.

00:07:42.086 --> 00:07:44.666 A:middle
I'm going to read my position
color from the vertexArray

00:07:44.666 --> 00:07:47.226 A:middle
and pass them right out
down the pipeline unchanged.

00:07:47.556 --> 00:07:51.656 A:middle
So, unsurprisingly, my
vertex out-struct looks,

00:07:51.886 --> 00:07:52.826 A:middle
well, just like it.

00:07:53.376 --> 00:07:56.766 A:middle
The only difference is that
the rasterizer needs to know

00:07:56.766 --> 00:07:58.266 A:middle
which of the outputs
is the position,

00:07:58.266 --> 00:07:59.966 A:middle
so we have to use an attribute


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.096 --> 00:08:03.126 A:middle
to identify that
to the compiler.

00:08:03.206 --> 00:08:05.556 A:middle
All of the other outputs
will get interpolated

00:08:05.556 --> 00:08:06.766 A:middle
across the triangle as usual.

00:08:06.766 --> 00:08:12.996 A:middle
So on to the body of
the vertex shader.

00:08:13.226 --> 00:08:15.866 A:middle
So here's my simple
pass-through VertexShader.

00:08:16.766 --> 00:08:21.226 A:middle
So we have a sort a
C-style declaration

00:08:21.256 --> 00:08:22.606 A:middle
with some extra key
words and attributes.

00:08:22.606 --> 00:08:23.906 A:middle
We'll go into more
detail into later.

00:08:24.806 --> 00:08:27.316 A:middle
But I'm getting a
pointer to my vertexArray

00:08:28.076 --> 00:08:31.036 A:middle
into my VertexShader, along
with a vertex ID that tells me

00:08:31.296 --> 00:08:32.246 A:middle
which of the three vertexes

00:08:32.246 --> 00:08:33.686 A:middle
that this thread is
going to be processing.

00:08:36.416 --> 00:08:38.645 A:middle
From those I'm going to
read from the vertexArray,

00:08:39.035 --> 00:08:44.456 A:middle
copy to the output struct, and
I'm going to return an instance

00:08:44.456 --> 00:08:45.636 A:middle
of the vertex out-struct.

00:08:45.636 --> 00:08:50.406 A:middle
So this is sort of in comparison
to GLSL where all of the inputs

00:08:50.406 --> 00:08:52.016 A:middle
and outputs are specified
as global scope.

00:08:52.076 --> 00:08:55.036 A:middle
In the Metal shading language,
all of your inputs come

00:08:55.036 --> 00:08:56.146 A:middle
in via function arguments.

00:08:56.296 --> 00:08:59.206 A:middle
All of your outputs are
returned via the C return pipe.

00:08:59.856 --> 00:09:02.496 A:middle
Okay. This guy likes that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.856 --> 00:09:02.496 A:middle
Okay. This guy likes that.

00:09:04.326 --> 00:09:07.236 A:middle
So now the FragmentShader
is of course even easier.

00:09:07.956 --> 00:09:12.246 A:middle
The input to my FragmentShader
is again, a single argument.

00:09:12.666 --> 00:09:14.776 A:middle
In this case the same
VertexOut structs,

00:09:14.776 --> 00:09:16.066 A:middle
the VertexShader just returned.

00:09:16.976 --> 00:09:19.226 A:middle
Except now it contains
an interpolated position

00:09:19.776 --> 00:09:21.016 A:middle
and an interpolated color.

00:09:21.016 --> 00:09:23.136 A:middle
So I'm going to go
read my color.

00:09:23.136 --> 00:09:25.886 A:middle
And I'm going to return a
float4, which will write

00:09:25.886 --> 00:09:26.646 A:middle
into the frame buffer.

00:09:27.426 --> 00:09:29.556 A:middle
And because we told
them to put it

00:09:29.556 --> 00:09:31.446 A:middle
in the pipeline state what
the frame buffer for it is,

00:09:31.826 --> 00:09:33.706 A:middle
the compiler knows how it
needs to pack this down

00:09:33.706 --> 00:09:35.956 A:middle
and compress it to the
actual frame buffer format.

00:09:36.516 --> 00:09:39.786 A:middle
So that's the vertex
and frag pass

00:09:40.016 --> 00:09:41.346 A:middle
through vertex and
FragmentShaders.

00:09:41.816 --> 00:09:44.646 A:middle
And that's really the end of
how to build a RenderPipeline.

00:09:45.026 --> 00:09:47.766 A:middle
The one last bit are just the
function names themselves,

00:09:47.826 --> 00:09:49.976 A:middle
which are the strings that are
used to pull up these functions

00:09:49.976 --> 00:09:51.336 A:middle
up when building
another pipeline.

00:09:51.916 --> 00:09:59.946 A:middle
So our fifth and final step to
initialize is creating the view.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:00.346 --> 00:10:03.136 A:middle
So if you've been working
on iOS for a while,

00:10:03.136 --> 00:10:05.576 A:middle
you're probably aware that
if you want to get anything

00:10:05.726 --> 00:10:08.316 A:middle
on the screen, it
basically needs to be part

00:10:08.316 --> 00:10:09.646 A:middle
of a core animation layer tree.

00:10:10.546 --> 00:10:13.566 A:middle
So, iOS 8 provides
a new subclass

00:10:13.566 --> 00:10:15.606 A:middle
of CA layer called CAMetalLayer.

00:10:16.796 --> 00:10:18.436 A:middle
And that class is
really interesting

00:10:18.476 --> 00:10:20.746 A:middle
because it can vend
out textures.

00:10:20.746 --> 00:10:23.266 A:middle
It will manage a swap chain
of typically three textures,

00:10:23.266 --> 00:10:24.756 A:middle
and you can ask for the
next one in the chain.

00:10:25.276 --> 00:10:27.576 A:middle
And I can say give me a
texture, render into it,

00:10:27.576 --> 00:10:29.626 A:middle
and when I'm done
I can push it back

00:10:29.626 --> 00:10:30.816 A:middle
to be swapped on to the display.

00:10:32.116 --> 00:10:34.046 A:middle
To create a layer,

00:10:34.126 --> 00:10:36.676 A:middle
that's typically owned
by a UIView subclass.

00:10:37.306 --> 00:10:38.806 A:middle
I'm going to show you a very,

00:10:38.886 --> 00:10:41.826 A:middle
very bare bones UIView
subclass on the next slide.

00:10:42.216 --> 00:10:44.156 A:middle
And you can find a much
more complete implementation

00:10:44.156 --> 00:10:46.146 A:middle
with a bunch of functionality
in our sample code.

00:10:46.816 --> 00:10:50.066 A:middle
And then because this is
iOS, and this is you know,

00:10:50.206 --> 00:10:52.676 A:middle
entirely typical, your view
is then typically owned

00:10:52.676 --> 00:10:54.946 A:middle
by UIViewController, which is
usually typically completely

00:10:54.946 --> 00:10:56.066 A:middle
custom to your application.

00:10:56.526 --> 00:10:59.726 A:middle
So let's go look at our
really bare bones view.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:01.406 --> 00:11:03.696 A:middle
So really this is all
you really need to do.

00:11:03.826 --> 00:11:05.226 A:middle
I need to subclass UIView,

00:11:05.596 --> 00:11:07.376 A:middle
and I need to override
the layer class method

00:11:07.376 --> 00:11:11.046 A:middle
and say I want this view to
own a Metal layer as opposed

00:11:11.046 --> 00:11:12.906 A:middle
to any other kind of layer.

00:11:13.636 --> 00:11:16.356 A:middle
There is some other
configuration we could do

00:11:16.456 --> 00:11:17.586 A:middle
on this view in this layer,

00:11:18.026 --> 00:11:20.546 A:middle
primarily for efficient
compositing.

00:11:20.856 --> 00:11:22.756 A:middle
But this is really the
bare minimum that you need

00:11:22.756 --> 00:11:23.866 A:middle
to get something
on to the screen.

00:11:24.416 --> 00:11:27.976 A:middle
So with that, we've been
through all five our

00:11:27.976 --> 00:11:28.996 A:middle
initialization steps.

00:11:29.636 --> 00:11:34.556 A:middle
We breezed through getting the
device, getting a command queue,

00:11:34.816 --> 00:11:36.546 A:middle
and creating a resource.

00:11:37.056 --> 00:11:40.256 A:middle
Spent a little bit of time on
the RenderPipeline descriptor

00:11:40.556 --> 00:11:41.636 A:middle
and RenderPipelineState.

00:11:42.636 --> 00:11:43.856 A:middle
Also looked at the shaders.

00:11:43.856 --> 00:11:46.166 A:middle
And then we created a view.

00:11:46.246 --> 00:11:50.216 A:middle
So with that we can
actually even draw something.

00:11:50.756 --> 00:11:52.786 A:middle
And that has a few more steps.

00:11:52.786 --> 00:11:58.856 A:middle
So, we need to get a command
buffer, since all of our work

00:11:58.856 --> 00:12:02.056 A:middle
that goes to the GPU will be
enqueued into a command buffer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.856 --> 00:12:02.056 A:middle
that goes to the GPU will be
enqueued into a command buffer.

00:12:02.796 --> 00:12:04.826 A:middle
We're going to encode a
render to texture pass

00:12:05.096 --> 00:12:06.046 A:middle
into that command buffer.

00:12:06.046 --> 00:12:08.216 A:middle
We're going to put some stuff
in that render texture pass.

00:12:08.926 --> 00:12:10.596 A:middle
And then finally we're going
to send that CommandBuffer

00:12:10.746 --> 00:12:12.306 A:middle
to the GPU hardware
to be executed.

00:12:13.516 --> 00:12:15.266 A:middle
So, step 1, getting
the CommandBuffer.

00:12:16.176 --> 00:12:17.116 A:middle
That's another one-liner.

00:12:18.166 --> 00:12:19.566 A:middle
You can simply go
to the command queue

00:12:19.886 --> 00:12:22.246 A:middle
and say give me the next
available CommandBuffer.

00:12:22.896 --> 00:12:28.736 A:middle
The second step is setting
up my render to texture pass.

00:12:29.726 --> 00:12:33.056 A:middle
One thing that sets Metal apart
from other graphic APIs is

00:12:33.056 --> 00:12:35.806 A:middle
that we have a sort of
very rigorous definition

00:12:35.806 --> 00:12:38.846 A:middle
of when a rendered texture
pass begins and when it ends.

00:12:39.436 --> 00:12:41.336 A:middle
And when you start a
render to texture pass,

00:12:41.906 --> 00:12:43.586 A:middle
we require that you tell us all

00:12:43.586 --> 00:12:45.456 A:middle
of the frame buffer
configuration right up front

00:12:45.776 --> 00:12:47.206 A:middle
so we know how to
configure the hardware.

00:12:48.506 --> 00:12:52.696 A:middle
And most of what goes into
that configuration looks a lot

00:12:52.696 --> 00:12:54.506 A:middle
like a frame buffer
object in open GL.

00:12:55.226 --> 00:12:58.066 A:middle
There's, you know, what color
textures am I rendering too?

00:12:58.266 --> 00:12:59.056 A:middle
Up to four of those.

00:12:59.056 --> 00:12:59.846 A:middle
What depth texture?

00:12:59.846 --> 00:13:00.786 A:middle
What stencil texture?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.846 --> 00:13:00.786 A:middle
What stencil texture?

00:13:00.786 --> 00:13:04.466 A:middle
Which bitmap levels that, the
load actions and store actions

00:13:04.466 --> 00:13:05.806 A:middle
that you saw in Jeremy's
presentation.

00:13:06.426 --> 00:13:10.396 A:middle
So given that there's so much
configuration that happens here,

00:13:11.406 --> 00:13:14.416 A:middle
we've again taken that
and packaged it all

00:13:14.416 --> 00:13:17.246 A:middle
up into a descriptor to do
convenient configuration on.

00:13:18.056 --> 00:13:20.136 A:middle
And then once you have
the descriptor configured,

00:13:20.416 --> 00:13:23.766 A:middle
you can then create the
render to texture pass.

00:13:23.966 --> 00:13:25.216 A:middle
So, putting that into code.

00:13:25.706 --> 00:13:29.916 A:middle
Right at the top we need to
know what texture we're going

00:13:29.916 --> 00:13:30.666 A:middle
to render into.

00:13:30.786 --> 00:13:33.286 A:middle
So we're actually going to
go back to our CA MetalLayer

00:13:33.286 --> 00:13:35.736 A:middle
and say give me the
next available drawable.

00:13:35.736 --> 00:13:39.176 A:middle
And a drawable is pretty
much just a wraparound

00:13:39.176 --> 00:13:41.346 A:middle
to texture plus a little
bit of extra bookkeeping.

00:13:42.876 --> 00:13:45.956 A:middle
This is one of the very
few API calls in Metal

00:13:45.956 --> 00:13:47.486 A:middle
that will actually
block your application

00:13:47.806 --> 00:13:49.396 A:middle
if there's no more
available textures

00:13:49.396 --> 00:13:51.256 A:middle
in the swap chain,
if they're all busy.

00:13:51.976 --> 00:13:53.466 A:middle
So this could block
and wait awhile,

00:13:53.466 --> 00:13:54.646 A:middle
especially if you're GPU bound.

00:13:55.006 --> 00:14:00.256 A:middle
Next, I want to set up
my RenderPass Descriptor.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:55.006 --> 00:14:00.256 A:middle
Next, I want to set up
my RenderPass Descriptor.

00:14:01.206 --> 00:14:02.906 A:middle
I'm going to point
color attachment zero

00:14:02.906 --> 00:14:04.276 A:middle
at my drawables texture.

00:14:04.436 --> 00:14:06.516 A:middle
I'm going to configure
the RenderPass

00:14:06.856 --> 00:14:09.246 A:middle
such that it will clear
that texture at the start

00:14:09.246 --> 00:14:12.076 A:middle
of the pass, preventing
the existing contents

00:14:12.076 --> 00:14:14.496 A:middle
of that texture from being
loaded into the GPU tiles cache.

00:14:14.796 --> 00:14:16.616 A:middle
And then I'm going to
then actually, you know,

00:14:16.616 --> 00:14:20.216 A:middle
I'm going to choose some really
boring array to clear it to.

00:14:20.886 --> 00:14:23.546 A:middle
So again, if I had a
more complex frame buffer

00:14:23.546 --> 00:14:25.826 A:middle
configuration, there would be a
bunch more similar stuff here.

00:14:25.896 --> 00:14:27.386 A:middle
But again, that's
all I really need

00:14:27.386 --> 00:14:29.386 A:middle
for my hello world application.

00:14:29.806 --> 00:14:32.656 A:middle
So now I can go to the
CommandBuffer, and I can say,

00:14:32.876 --> 00:14:34.926 A:middle
the next thing on
this CommandBuffer is

00:14:34.986 --> 00:14:35.846 A:middle
a renderCommand.

00:14:36.686 --> 00:14:37.536 A:middle
Here's the descriptor.

00:14:37.886 --> 00:14:40.056 A:middle
Give me back the interface
I can use to encode.

00:14:40.906 --> 00:14:43.996 A:middle
And this renderCommand encoder
you're getting back is the

00:14:43.996 --> 00:14:45.046 A:middle
object that has most

00:14:45.046 --> 00:14:47.976 A:middle
of the traditional 3D graphics
API you're expecting to find.

00:14:48.346 --> 00:14:50.016 A:middle
Things like setting
the depth stencil state

00:14:50.226 --> 00:14:53.176 A:middle
and binding textures and
colNodes and all that stuff.

00:14:54.346 --> 00:14:58.586 A:middle
So let's go actually
draw our triangle out.

00:14:58.856 --> 00:15:01.946 A:middle
So previously I created
my RenderPipeline,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.856 --> 00:15:01.946 A:middle
So previously I created
my RenderPipeline,

00:15:01.946 --> 00:15:03.316 A:middle
and I created my vertexArray.

00:15:03.516 --> 00:15:04.596 A:middle
So I want to set them both here.

00:15:04.996 --> 00:15:06.276 A:middle
Which RenderPipeline
we're going to use.

00:15:06.506 --> 00:15:07.526 A:middle
And I'm going to say, I'm going

00:15:07.526 --> 00:15:08.796 A:middle
to point right at
the vertexArray.

00:15:09.056 --> 00:15:10.706 A:middle
And I can finally
encode the command

00:15:10.806 --> 00:15:12.106 A:middle
to draw my simple triangle.

00:15:13.556 --> 00:15:16.446 A:middle
So now we've gotten
through our third step

00:15:16.446 --> 00:15:17.356 A:middle
of drawing a triangle.

00:15:17.456 --> 00:15:19.056 A:middle
And now we get to the final one,

00:15:19.306 --> 00:15:20.786 A:middle
committing the CommandBuffer
to the GPU.

00:15:21.436 --> 00:15:26.066 A:middle
At this point we have basically
a fully formed CommandBuffer

00:15:26.066 --> 00:15:27.426 A:middle
just sitting in memory idle.

00:15:27.426 --> 00:15:30.766 A:middle
It's not going, GPU
will not start executing

00:15:30.806 --> 00:15:31.566 A:middle
until you've committed.

00:15:32.566 --> 00:15:35.346 A:middle
So before we do that
though, we actually want

00:15:35.346 --> 00:15:38.336 A:middle
to do one more thing
and tell CoreAnimation

00:15:38.696 --> 00:15:40.376 A:middle
when you actually want
to present this texture.

00:15:40.866 --> 00:15:43.586 A:middle
Because we got a texture from
CoreAnimation, and now we need

00:15:43.586 --> 00:15:46.716 A:middle
to tell CA when we can
display that texture safely.

00:15:47.646 --> 00:15:48.936 A:middle
Because we haven't
rendered anything yet,

00:15:49.116 --> 00:15:49.926 A:middle
now's not the time.

00:15:50.866 --> 00:15:54.836 A:middle
So we want to be able to, and
so this API addPresent will set

00:15:54.836 --> 00:15:58.086 A:middle
up an automatic notification
from Metal to CoreAnimation

00:15:58.536 --> 00:16:02.206 A:middle
that when this rendering is
complete, it will cross call


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.536 --> 00:16:02.206 A:middle
that when this rendering is
complete, it will cross call

00:16:02.206 --> 00:16:03.596 A:middle
into CoreAnimation and say,

00:16:03.996 --> 00:16:05.386 A:middle
it's time to put this
on the display now.

00:16:06.046 --> 00:16:09.476 A:middle
And then finally we
have the big red button.

00:16:10.216 --> 00:16:13.096 A:middle
You call commit, and this
CommandBuffer gets encoded,

00:16:13.096 --> 00:16:15.026 A:middle
gets enqueued into the
end of the command queue,

00:16:15.386 --> 00:16:17.266 A:middle
and it will execute
on the GPU hardware.

00:16:17.896 --> 00:16:23.836 A:middle
So that is all of the steps to
go and draw my single triangle.

00:16:24.676 --> 00:16:28.676 A:middle
We needed to get a command
buffer, configure a render pass

00:16:28.676 --> 00:16:30.936 A:middle
with one target texture that
we got from CoreAnimation,

00:16:32.256 --> 00:16:34.286 A:middle
draw my triangle
with the vertexArray

00:16:34.286 --> 00:16:35.116 A:middle
and a pipeline state.

00:16:35.396 --> 00:16:38.706 A:middle
And commit the command encoder.

00:16:40.636 --> 00:16:42.326 A:middle
So that's my triangle.

00:16:42.546 --> 00:16:43.906 A:middle
That's pretty much all
the codes you need.

00:16:44.406 --> 00:16:51.466 A:middle
Go do it. So it's kind
of a boring application.

00:16:51.706 --> 00:16:54.446 A:middle
So let's add at least
one little thing more

00:16:54.476 --> 00:16:56.646 A:middle
that every single
application is going to need

00:16:56.946 --> 00:16:59.026 A:middle
because I imagine
you're all not going

00:16:59.026 --> 00:17:02.966 A:middle
to be happy drawing exactly the
same thing over and over again.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.026 --> 00:17:02.966 A:middle
to be happy drawing exactly the
same thing over and over again.

00:17:02.996 --> 00:17:06.616 A:middle
We need to load some shader
uniforms because, you know,

00:17:06.846 --> 00:17:09.816 A:middle
we actually want to make things
move over time or what have you.

00:17:10.156 --> 00:17:12.445 A:middle
So, this is going
to take the form of,

00:17:12.445 --> 00:17:15.826 A:middle
so I want to use this
opportunity to show you how

00:17:15.826 --> 00:17:19.076 A:middle
to load shader uniforms,
also known as constants.

00:17:21.205 --> 00:17:24.536 A:middle
So, in Metal, shader constants
come in through buffers.

00:17:24.616 --> 00:17:26.455 A:middle
Just like vertexArrays
or anything else.

00:17:27.616 --> 00:17:30.536 A:middle
So back to my vertex
shader code.

00:17:31.336 --> 00:17:33.376 A:middle
I have declared a new struct,

00:17:33.376 --> 00:17:36.826 A:middle
which describes a compiler
how my uniforms are laid you

00:17:36.966 --> 00:17:37.416 A:middle
in memory.

00:17:37.976 --> 00:17:40.306 A:middle
In this case it's just
a general 4x4 matrix.

00:17:43.106 --> 00:17:45.626 A:middle
And I've added a second
argument to my function.

00:17:45.626 --> 00:17:47.026 A:middle
I'm going to read from
a different buffer.

00:17:47.026 --> 00:17:48.716 A:middle
Now I'm going to read
from buffer location 1,

00:17:49.396 --> 00:17:52.146 A:middle
and that's where the compiler is
going to expect to find a buffer

00:17:52.146 --> 00:17:55.246 A:middle
that it's going to actually
load that struct from.

00:17:55.246 --> 00:17:58.816 A:middle
So that's the extent
of the shader changes.

00:17:59.376 --> 00:18:05.206 A:middle
On the API side, I've
allocated a second buffer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.376 --> 00:18:05.206 A:middle
On the API side, I've
allocated a second buffer

00:18:05.206 --> 00:18:06.556 A:middle
to sort of hold my uniforms.

00:18:06.556 --> 00:18:08.446 A:middle
And I'm going to call
the contents property,

00:18:08.446 --> 00:18:10.536 A:middle
and that's just going to
return to me a void start.

00:18:10.826 --> 00:18:14.636 A:middle
And like I said, these are
CPU/GPU shared CommandBuffers,

00:18:14.636 --> 00:18:15.606 A:middle
or shared, not Command Buffers.

00:18:15.606 --> 00:18:16.956 A:middle
These are CPU/GPU shared memory.

00:18:17.446 --> 00:18:19.226 A:middle
The GPU is reading from
exactly the same memory

00:18:19.226 --> 00:18:19.996 A:middle
that GPU's writing.

00:18:20.316 --> 00:18:22.386 A:middle
There's no lock or
unlock API calls

00:18:22.386 --> 00:18:23.446 A:middle
or flushing or any of that.

00:18:24.006 --> 00:18:26.116 A:middle
You can get a pointer,
[inaudible] it to a type

00:18:26.116 --> 00:18:27.426 A:middle
of your choosing
and start writing.

00:18:28.206 --> 00:18:33.096 A:middle
And then finally, I'm going to
set a second buffer argument

00:18:33.186 --> 00:18:36.626 A:middle
to the vertex stage to point
the hardware at uniformBuffer.

00:18:37.556 --> 00:18:40.346 A:middle
This is almost okay
but not quite.

00:18:40.346 --> 00:18:43.266 A:middle
Because we actually have
a race condition here.

00:18:45.176 --> 00:18:49.456 A:middle
So your application encodes
a frame and also writes

00:18:49.456 --> 00:18:50.856 A:middle
to a uniform buffer
at the same time.

00:18:50.896 --> 00:18:53.656 A:middle
And then we ship that off
to the GPU to be executed.

00:18:55.436 --> 00:18:57.976 A:middle
The execution is going to take
some amount of time depending

00:18:57.976 --> 00:19:01.636 A:middle
on the complexity of your seam.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.976 --> 00:19:01.636 A:middle
on the complexity of your seam.

00:19:02.486 --> 00:19:04.556 A:middle
So if you have like a
conventional game loop,

00:19:04.556 --> 00:19:05.946 A:middle
you're probably going
to turn around

00:19:05.946 --> 00:19:07.786 A:middle
and immediately check back
up to the top of your loop

00:19:08.126 --> 00:19:09.966 A:middle
and start encoding the
next frame right away.

00:19:10.606 --> 00:19:14.076 A:middle
Of course the GPU being an
[inaudible] device is still

00:19:14.076 --> 00:19:15.906 A:middle
executing the previous
command buffer.

00:19:16.886 --> 00:19:19.786 A:middle
So if I have a right to that
unit, I have a new frame.

00:19:20.066 --> 00:19:20.886 A:middle
It's a new time stamp.

00:19:21.096 --> 00:19:22.316 A:middle
It's a new model view matrix.

00:19:22.726 --> 00:19:24.516 A:middle
But if I write that into
my buffer right now,

00:19:24.516 --> 00:19:28.216 A:middle
I'm writing into the same memory
that the GPU is reading from.

00:19:28.356 --> 00:19:29.636 A:middle
And I've created
a race condition.

00:19:30.246 --> 00:19:32.926 A:middle
At that point what the GPU
reads is completely undefined.

00:19:34.766 --> 00:19:37.726 A:middle
So, the easy thing to do is
write to a different buffer.

00:19:38.646 --> 00:19:39.746 A:middle
So there's no conflict here.

00:19:40.256 --> 00:19:44.576 A:middle
Then I come down here to my
third frame and so forth.

00:19:44.576 --> 00:19:46.926 A:middle
But there comes a point where
you just, where you, you know,

00:19:47.096 --> 00:19:48.666 A:middle
you can't allocate
new buffers forever.

00:19:48.746 --> 00:19:51.206 A:middle
There comes a point where
you're going to want to recycle

00:19:51.326 --> 00:19:52.446 A:middle
and existing buffer again.

00:19:53.216 --> 00:19:57.536 A:middle
And the problem here is that,
a CPU can get sometimes,

00:19:57.536 --> 00:19:59.306 A:middle
depending on how you
structure you're application,

00:19:59.606 --> 00:20:01.266 A:middle
several frames ahead of the GPU.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.606 --> 00:20:01.266 A:middle
several frames ahead of the GPU.

00:20:01.776 --> 00:20:04.346 A:middle
And the GPU might still
be working on that frame

00:20:04.556 --> 00:20:05.866 A:middle
that you submitted
two frames ago.

00:20:06.396 --> 00:20:08.526 A:middle
And we still have
a race condition.

00:20:10.216 --> 00:20:13.636 A:middle
So the final step to resolving
this is that we need to wait.

00:20:13.806 --> 00:20:16.486 A:middle
That your application needs
to not write to that buffer

00:20:16.746 --> 00:20:18.686 A:middle
until you know that your code

00:20:18.686 --> 00:20:21.606 A:middle
on the GPU is no
longer reading from it.

00:20:21.846 --> 00:20:23.406 A:middle
Fortunately, that's pretty easy.

00:20:23.546 --> 00:20:24.866 A:middle
It takes about four
lines of code.

00:20:24.866 --> 00:20:28.266 A:middle
So I'm going to show
you that now.

00:20:29.146 --> 00:20:32.176 A:middle
So I'm going to do this
with dispatch semaphores,

00:20:32.856 --> 00:20:36.696 A:middle
you know a common low-level
synchronization primitive

00:20:36.696 --> 00:20:37.266 A:middle
on iOS.

00:20:38.176 --> 00:20:39.606 A:middle
So for this example,
I'm going to have a pool

00:20:39.606 --> 00:20:41.346 A:middle
of three uniform
buffers I've created.

00:20:41.346 --> 00:20:43.456 A:middle
So I'm going to create
a dispatch semaphore

00:20:43.456 --> 00:20:44.316 A:middle
with a count of 3.

00:20:45.316 --> 00:20:48.146 A:middle
I'm going to add my
common CommandBuffer loop.

00:20:48.146 --> 00:20:49.356 A:middle
I'm going to build
a Command Buffer.

00:20:49.356 --> 00:20:50.476 A:middle
And I'm going to
send it to the GPU.

00:20:51.556 --> 00:20:54.856 A:middle
But right at the top, before
I write to any shared memory

00:20:54.856 --> 00:20:57.386 A:middle
that I'm recycling, that the
GPU is potentially still reading

00:20:57.386 --> 00:20:58.696 A:middle
from, I'm going to wait.

00:20:58.696 --> 00:20:59.726 A:middle
And I'm going to make sure


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:00.056 --> 00:21:03.436 A:middle
that the GPU has actually
finished executing

00:21:03.436 --> 00:21:05.986 A:middle
that previous CommandBuffer
before I reuse the memory.

00:21:06.296 --> 00:21:10.006 A:middle
So this is the second place
apart from next [inaudible]

00:21:10.006 --> 00:21:13.286 A:middle
where you probably see
an application block

00:21:13.386 --> 00:21:14.056 A:middle
when using Metal.

00:21:14.546 --> 00:21:19.076 A:middle
Now the other side of this is
we need to signal the semaphore

00:21:19.076 --> 00:21:21.016 A:middle
when it is safe for the
application to proceed.

00:21:22.016 --> 00:21:24.966 A:middle
So, in Metal, you can
add a completion handler

00:21:25.086 --> 00:21:25.906 A:middle
to a CommandBuffer.

00:21:26.576 --> 00:21:29.156 A:middle
When the GPU finishes
executing this CommandBuffer,

00:21:30.446 --> 00:21:33.066 A:middle
the OS will invoke the
block that you provide,

00:21:33.126 --> 00:21:34.646 A:middle
and you can do whatever
you want in there.

00:21:35.306 --> 00:21:37.906 A:middle
In this case, I'm going to
signal the semaphore and say,

00:21:38.556 --> 00:21:39.866 A:middle
hey a CommandBuffer finished.

00:21:40.216 --> 00:21:41.536 A:middle
There's a uniform
buffer available.

00:21:42.266 --> 00:21:43.036 A:middle
Start writing to it.

00:21:43.036 --> 00:21:43.586 A:middle
Have a blast.

00:21:43.786 --> 00:21:46.246 A:middle
And that's really it.

00:21:46.976 --> 00:21:50.256 A:middle
So that's really the
basic walk-through

00:21:50.256 --> 00:21:53.356 A:middle
through a simple hello world
application with some animation.

00:21:53.356 --> 00:21:54.466 A:middle
It does shader constants.

00:21:54.726 --> 00:21:58.516 A:middle
Does vertexArrays, and
we still have a 3D state.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.096 --> 00:22:02.336 A:middle
Went through some basic
initialization process.

00:22:03.036 --> 00:22:06.146 A:middle
We showed how to set up
basic CommandBuffer draw.

00:22:06.146 --> 00:22:09.266 A:middle
And we said hey, the moment
you produce any CPU dynamically

00:22:09.266 --> 00:22:12.106 A:middle
produced data, we saw how you
have to synchronize access

00:22:12.106 --> 00:22:14.456 A:middle
to that because we're just
giving you the raw memory

00:22:14.456 --> 00:22:16.476 A:middle
pointers now.

00:22:18.356 --> 00:22:22.766 A:middle
So, that thing, these design
patterns actually go really far.

00:22:22.766 --> 00:22:26.186 A:middle
For example, that same pattern
of synchronizing with semaphores

00:22:26.186 --> 00:22:28.906 A:middle
or any other permit of your
choice, and the callbacks,

00:22:29.416 --> 00:22:31.996 A:middle
for example, are just as
useful for dynamic vertex data,

00:22:32.436 --> 00:22:34.626 A:middle
for streaming image
updates, texture updates,

00:22:34.626 --> 00:22:36.746 A:middle
if you have a large open
world kind of scene.

00:22:37.456 --> 00:22:39.056 A:middle
Or even if you're going
the other direction

00:22:39.096 --> 00:22:40.456 A:middle
and having the GPU produce data,

00:22:41.256 --> 00:22:43.386 A:middle
you know that the CPU
can read it as soon

00:22:43.386 --> 00:22:44.716 A:middle
as that callback fires.

00:22:46.076 --> 00:22:48.036 A:middle
So that's really
your introduction

00:22:48.036 --> 00:22:50.686 A:middle
to a really simple
hello world application.

00:22:50.836 --> 00:22:51.966 A:middle
We made a spinning triangle.

00:22:52.146 --> 00:22:56.376 A:middle
Hooray. So, with that,
that wraps up this.

00:22:56.376 --> 00:22:58.356 A:middle
And so I'm going to turn the
stage over to my colleague Aafi,

00:22:58.686 --> 00:23:01.436 A:middle
to talk to you in detail about
the Metal shading language.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.686 --> 00:23:01.436 A:middle
to talk to you in detail about
the Metal shading language.

00:23:01.786 --> 00:23:02.216 A:middle
So thank you.

00:23:03.766 --> 00:23:06.996 A:middle
&gt;&gt; All right.

00:23:07.426 --> 00:23:08.066 A:middle
Thanks Richard.

00:23:08.766 --> 00:23:13.416 A:middle
All right, so we're going to
talk about the shading language.

00:23:13.626 --> 00:23:16.456 A:middle
And so Jeremy mentioned
in the first presentation

00:23:16.456 --> 00:23:20.986 A:middle
that this language is based
on C++, so a lot of you,

00:23:21.156 --> 00:23:23.656 A:middle
most of you are familiar
with writing C++ code.

00:23:23.656 --> 00:23:26.336 A:middle
What we're going to talk
about is how we extended this

00:23:26.686 --> 00:23:29.406 A:middle
to be able to write
shaders in Metal.

00:23:30.626 --> 00:23:33.936 A:middle
So the things, the things
we're going to cover

00:23:33.936 --> 00:23:36.946 A:middle
in this session is
how to write shaders.

00:23:36.946 --> 00:23:39.326 A:middle
We're going to take a simple
vertex in the fragment shader

00:23:39.326 --> 00:23:41.916 A:middle
and see how we can take
C++ code and make it

00:23:41.916 --> 00:23:43.166 A:middle
into a vertex fragment shader.

00:23:43.586 --> 00:23:46.466 A:middle
We will talk about data
types that Metal supports.

00:23:46.466 --> 00:23:50.896 A:middle
We will talk about, you know,
while shaders need inputs

00:23:50.896 --> 00:23:53.746 A:middle
and outputs, so how do
you specify that in Metal.

00:23:54.226 --> 00:23:55.936 A:middle
And, you know, if I'm
going to use them,

00:23:55.936 --> 00:23:58.216 A:middle
because in the RenderPipeline,
I need a vertex shader

00:23:58.216 --> 00:24:01.126 A:middle
and a fragment shader, well
how do I make sure I pair these


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.216 --> 00:24:01.126 A:middle
and a fragment shader, well
how do I make sure I pair these

00:24:01.166 --> 00:24:01.856 A:middle
things together?

00:24:02.416 --> 00:24:04.896 A:middle
And then we'll talk
about math, okay.

00:24:05.436 --> 00:24:09.236 A:middle
All right, so how to
write shaders in Metal.

00:24:09.236 --> 00:24:13.126 A:middle
So let's take this in
a pseudo C code here.

00:24:13.596 --> 00:24:17.526 A:middle
So what you see here in
this function is it takes

00:24:17.596 --> 00:24:18.416 A:middle
three arguments.

00:24:18.416 --> 00:24:21.526 A:middle
The first two are some
pointers to some structures

00:24:21.956 --> 00:24:24.376 A:middle
and the returns this
vertex output struct

00:24:24.376 --> 00:24:25.806 A:middle
which you declared it.

00:24:26.276 --> 00:24:30.266 A:middle
And what I want to happen here
is remember the vertex shader is

00:24:30.266 --> 00:24:34.296 A:middle
executing for each vertex,
so if I have N vertices

00:24:34.296 --> 00:24:35.706 A:middle
in my primitive I want,

00:24:36.026 --> 00:24:38.256 A:middle
there may be multiple threads
executing these vertices

00:24:38.256 --> 00:24:39.616 A:middle
in parallel.

00:24:39.876 --> 00:24:43.616 A:middle
So what I want to be
able to do is read

00:24:43.616 --> 00:24:45.426 A:middle
in that thread that's
executing this vertex shader,

00:24:45.426 --> 00:24:49.096 A:middle
which vertex am I actually
accessing so I can go

00:24:49.096 --> 00:24:50.716 A:middle
and get the right index.

00:24:50.786 --> 00:24:53.746 A:middle
Use that index to access
the right vertex data.

00:24:54.156 --> 00:24:56.536 A:middle
So, just you know,
imagine, just imagine

00:24:56.536 --> 00:24:59.056 A:middle
that this is that ID, okay.

00:24:59.146 --> 00:25:01.716 A:middle
So in this code, what we see
is here is going to use this ID


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.146 --> 00:25:01.716 A:middle
So in this code, what we see
is here is going to use this ID

00:25:02.046 --> 00:25:04.936 A:middle
and reference into
the input arguments.

00:25:04.936 --> 00:25:07.106 A:middle
This is the vertex
data and UV data.

00:25:07.106 --> 00:25:08.866 A:middle
Arguments have passed
to this function.

00:25:09.106 --> 00:25:11.316 A:middle
And you would typically
probably do some computations.

00:25:11.316 --> 00:25:12.616 A:middle
In this case I'm not doing much.

00:25:12.616 --> 00:25:14.406 A:middle
I'm just going to copy
them and return them back.

00:25:15.016 --> 00:25:17.986 A:middle
Well okay, how do I make this
into a Metal vertex shader?

00:25:18.146 --> 00:25:21.896 A:middle
Well the first thing,
note that we don't,

00:25:21.946 --> 00:25:24.916 A:middle
and Metal doesn't support
the C++ standard library.

00:25:24.916 --> 00:25:27.116 A:middle
Instead Metal has its
own standard library

00:25:27.506 --> 00:25:30.156 A:middle
that has been optimized
for the GPU.

00:25:30.156 --> 00:25:31.366 A:middle
For the graphics and compute.

00:25:32.066 --> 00:25:33.846 A:middle
In addition to that, so
I want to include that.

00:25:33.936 --> 00:25:37.016 A:middle
In addition to that, you know,
types and functions defined

00:25:37.016 --> 00:25:39.276 A:middle
by Metal actually out in
the Metal's namespace.

00:25:39.356 --> 00:25:40.886 A:middle
So I'm just being lazy.

00:25:40.886 --> 00:25:43.426 A:middle
Instead of explicitly calling
them, I'm just saying I'm going

00:25:43.426 --> 00:25:45.336 A:middle
to use the Metal
namespace in my shader here.

00:25:45.676 --> 00:25:47.776 A:middle
The next thing I'm
going to do is I'm going

00:25:47.776 --> 00:25:48.876 A:middle
to tell the compiler hey,

00:25:48.876 --> 00:25:50.436 A:middle
that this function
is a vertex function.

00:25:50.666 --> 00:25:53.316 A:middle
Okay, so that's what
I'm going to do.

00:25:53.316 --> 00:25:57.966 A:middle
And then Jeremy showed you
that any resource that's passed

00:25:57.966 --> 00:25:59.466 A:middle
as arguments to your functions,

00:25:59.826 --> 00:26:01.786 A:middle
you need to have the
argument indices.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.826 --> 00:26:01.786 A:middle
you need to have the
argument indices.

00:26:01.786 --> 00:26:03.206 A:middle
So in this case, you know,

00:26:03.206 --> 00:26:05.086 A:middle
anything that's a pointer
is actually a buffer.

00:26:05.086 --> 00:26:07.366 A:middle
So I'm going to assign
buffer indices.

00:26:07.666 --> 00:26:10.306 A:middle
And there's this global
thing that I have added here.

00:26:10.306 --> 00:26:12.066 A:middle
So just ignore that for now.

00:26:12.066 --> 00:26:13.926 A:middle
I'll cover what that
is in a few slides.

00:26:14.196 --> 00:26:16.496 A:middle
So almost there.

00:26:16.946 --> 00:26:18.576 A:middle
And I need to tell the compiler

00:26:18.576 --> 00:26:21.126 A:middle
that that ID is actually
the vertex ID.

00:26:21.126 --> 00:26:22.936 A:middle
So it can generate
the right code for me.

00:26:23.196 --> 00:26:23.696 A:middle
And that's it.

00:26:23.866 --> 00:26:26.476 A:middle
That's a Metal vertex
shader, okay.

00:26:27.296 --> 00:26:33.666 A:middle
What, nobody's going to clap?

00:26:33.666 --> 00:26:36.796 A:middle
All right, and you know
a fragment shader is just

00:26:36.796 --> 00:26:37.766 A:middle
very similar.

00:26:38.026 --> 00:26:41.526 A:middle
So I need to tell the compiler
it's a fragment function,

00:26:41.526 --> 00:26:43.436 A:middle
so I use the fragment qualifier.

00:26:43.856 --> 00:26:47.986 A:middle
Now note, remember the fragment
shader typically takes inputs

00:26:48.036 --> 00:26:51.146 A:middle
that are generated
by the vertex shader.

00:26:51.146 --> 00:26:53.386 A:middle
The output of the vertex
shader goes to the rasterizer

00:26:53.386 --> 00:26:55.806 A:middle
and becomes inputs to
the fragment shader.

00:26:56.216 --> 00:26:59.236 A:middle
So in this case, the vertex
shader returns, VertexOutput,

00:26:59.236 --> 00:27:00.936 A:middle
and I want to use
that as an input.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.236 --> 00:27:00.936 A:middle
and I want to use
that as an input.

00:27:01.116 --> 00:27:05.776 A:middle
No this is some struct
that you have compared.

00:27:05.816 --> 00:27:07.536 A:middle
So the compiler needs to know

00:27:07.806 --> 00:27:09.956 A:middle
that this is a per
instance input.

00:27:10.006 --> 00:27:14.636 A:middle
So anything that's user defined
and input to a vertex shader

00:27:14.636 --> 00:27:17.466 A:middle
or fragment shader that needs
to be [inaudible] and unique

00:27:17.466 --> 00:27:20.016 A:middle
for instance, has
to be qualified.

00:27:20.066 --> 00:27:22.376 A:middle
And so in Metal you do
that by declaring that with

00:27:22.376 --> 00:27:24.176 A:middle
that stage and attribute, okay.

00:27:24.876 --> 00:27:27.596 A:middle
So what I'm doing is in this
shader I'm going to look

00:27:27.596 --> 00:27:30.966 A:middle
at the texture coordinate per
fragment and use that example

00:27:31.366 --> 00:27:33.096 A:middle
into a texture that'll
return the color value.

00:27:33.096 --> 00:27:34.226 A:middle
So pretty straight forward.

00:27:34.226 --> 00:27:34.776 A:middle
So that's it.

00:27:34.906 --> 00:27:37.196 A:middle
It's really, you're going
to find the writing shaders

00:27:37.196 --> 00:27:38.896 A:middle
in Metal is really, really easy.

00:27:39.086 --> 00:27:42.516 A:middle
All right so let's
talk about data types.

00:27:42.876 --> 00:27:46.666 A:middle
All right, so I've broken data
types into two categories.

00:27:47.166 --> 00:27:48.506 A:middle
One I call the basic types.

00:27:48.766 --> 00:27:50.646 A:middle
And then we have
resources and data objects.

00:27:51.046 --> 00:27:55.466 A:middle
Note that one thing you
see is that all the inputs

00:27:55.466 --> 00:27:57.296 A:middle
to a shader are passed
as arguments.

00:27:57.336 --> 00:27:58.196 A:middle
There are no globals.

00:27:58.196 --> 00:28:00.226 A:middle
So you declare everything
as arguments,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.196 --> 00:28:00.226 A:middle
So you declare everything
as arguments,

00:28:00.576 --> 00:28:03.096 A:middle
and then if these are
resources are data objects,

00:28:03.576 --> 00:28:06.966 A:middle
then you specify the indices
that the runtime will use

00:28:06.966 --> 00:28:08.416 A:middle
to set the right resources too.

00:28:08.726 --> 00:28:10.136 A:middle
Okay, so let's talk
about the base types.

00:28:10.136 --> 00:28:10.856 A:middle
What are these?

00:28:10.856 --> 00:28:13.766 A:middle
These are scalars, vectors,
matrices and atomics.

00:28:13.766 --> 00:28:16.866 A:middle
So the scalar is
pretty straight forward.

00:28:16.936 --> 00:28:18.656 A:middle
I mean it don't usually
tell much.

00:28:18.826 --> 00:28:21.466 A:middle
We support the C++11
scalar types.

00:28:22.376 --> 00:28:25.926 A:middle
In addition to that,
we have the half type.

00:28:26.366 --> 00:28:31.636 A:middle
Okay. All right so
the half type.

00:28:32.616 --> 00:28:36.026 A:middle
So this is the i64 [inaudible]
16 bit floating point type.

00:28:36.026 --> 00:28:38.786 A:middle
And so any operation
you could do with Float,

00:28:38.786 --> 00:28:40.246 A:middle
at half of the first
class citizens.

00:28:40.246 --> 00:28:42.226 A:middle
So anything you can do with
Float, you can do with Half.

00:28:42.456 --> 00:28:44.556 A:middle
In fact, we really
want you to use half

00:28:44.556 --> 00:28:46.236 A:middle
because they are
both performance

00:28:46.236 --> 00:28:50.076 A:middle
and power optimizations that you
can share and take advantage of.

00:28:50.586 --> 00:28:52.386 A:middle
Vectors, very similar.

00:28:52.626 --> 00:28:55.976 A:middle
So you have you know, two, three
and four component vector types.

00:28:56.046 --> 00:29:00.696 A:middle
So for example, a half2 is a
two component 16 bit floating


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:56.046 --> 00:29:00.696 A:middle
So for example, a half2 is a
two component 16 bit floating

00:29:00.696 --> 00:29:01.286 A:middle
plan vector.

00:29:01.786 --> 00:29:06.186 A:middle
Matrices we have floating point
matrices, and they're stored

00:29:06.186 --> 00:29:09.056 A:middle
in column major order,
just like they are in GL.

00:29:09.426 --> 00:29:12.726 A:middle
The constructors and
operators, the things you can do

00:29:12.726 --> 00:29:14.716 A:middle
on them are very similar
to what you would find

00:29:14.716 --> 00:29:15.786 A:middle
in other shading languages,

00:29:15.976 --> 00:29:19.376 A:middle
so I'm not really
going to cover that.

00:29:19.586 --> 00:29:21.016 A:middle
But here's the thing
I want to talk about.

00:29:21.136 --> 00:29:22.856 A:middle
So, remember your path.

00:29:22.856 --> 00:29:23.996 A:middle
You're declaring a struct.

00:29:23.996 --> 00:29:25.696 A:middle
You're passing a
pointer to that struct

00:29:26.066 --> 00:29:27.716 A:middle
as argument to your shader.

00:29:27.716 --> 00:29:31.096 A:middle
So what you want to be able
to do is declare these,

00:29:31.306 --> 00:29:33.976 A:middle
let's say in a header file
and then use them both

00:29:33.976 --> 00:29:35.336 A:middle
on the host guard
because you're going

00:29:35.336 --> 00:29:36.886 A:middle
to build this data
structure on the host.

00:29:37.366 --> 00:29:40.276 A:middle
And then use this header
file also in your shader.

00:29:41.056 --> 00:29:43.456 A:middle
Well you can do that
because these types,

00:29:44.206 --> 00:29:48.426 A:middle
so in iOS 8 we have
the SIMD math library,

00:29:48.426 --> 00:29:51.296 A:middle
and so these define the
vector and matrix types.

00:29:51.296 --> 00:29:53.716 A:middle
And Metal uses the
exact same types.

00:29:53.716 --> 00:29:56.936 A:middle
So, what that means is that
if you include the SIMD header

00:29:57.036 --> 00:29:59.926 A:middle
in a host guard and you
can build the structures,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.046 --> 00:30:00.916 A:middle
you can share them.

00:30:01.356 --> 00:30:02.726 A:middle
You don't have to
do anything special.

00:30:02.726 --> 00:30:04.176 A:middle
It just works, okay.

00:30:05.566 --> 00:30:09.976 A:middle
Not every slide, no
clapping every slide.

00:30:10.496 --> 00:30:13.716 A:middle
Again, just like I said
previously, use the half vector

00:30:13.716 --> 00:30:16.376 A:middle
and matrix types
whenever you can, okay.

00:30:16.906 --> 00:30:20.896 A:middle
All right, so the last, oh, so
one more point on vector types.

00:30:21.186 --> 00:30:23.276 A:middle
So they are aligned
at vector length.

00:30:23.476 --> 00:30:24.226 A:middle
So what does that mean?

00:30:24.226 --> 00:30:28.216 A:middle
So if I look at the struct, what
that means is that a float2,

00:30:28.386 --> 00:30:30.896 A:middle
which is what bs is going
to be aligned on 8 bytes.

00:30:31.156 --> 00:30:34.096 A:middle
And similarly c is going to
be aligned with 16 bytes.

00:30:34.406 --> 00:30:37.666 A:middle
But if you notice, b is
actually at an offset of 4.

00:30:38.626 --> 00:30:39.746 A:middle
So that's a problem.

00:30:39.856 --> 00:30:41.716 A:middle
So what the compiler
will do is going

00:30:41.776 --> 00:30:43.976 A:middle
to generate a pairing variable.

00:30:44.196 --> 00:30:45.626 A:middle
Okay, so when you
do sizeof(Foo),

00:30:45.626 --> 00:30:47.046 A:middle
you're only going
to get 32 bytes.

00:30:47.046 --> 00:30:51.256 A:middle
So depending on how big your
data structure is and what kind

00:30:51.256 --> 00:30:52.746 A:middle
of scalars and vectors you use,

00:30:53.086 --> 00:30:54.516 A:middle
the compiler may
potentially have

00:30:54.516 --> 00:30:55.636 A:middle
to generate lots of pairing.

00:30:55.636 --> 00:30:58.816 A:middle
And if you're going to declare
an array of these trucks, then,

00:30:58.816 --> 00:31:00.866 A:middle
you know, it has
potential implications


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.816 --> 00:31:00.866 A:middle
you know, it has
potential implications

00:31:00.866 --> 00:31:04.416 A:middle
to your allocation size
and even memory boundary

00:31:04.416 --> 00:31:06.926 A:middle
when you access these data
structures in a shader code.

00:31:07.326 --> 00:31:12.326 A:middle
So, you may want to be smart
and say wow, let me declare them

00:31:12.326 --> 00:31:14.126 A:middle
in order of decreasing size.

00:31:14.176 --> 00:31:15.906 A:middle
All of my biggest
data types first,

00:31:16.326 --> 00:31:17.836 A:middle
and then the smaller types.

00:31:18.586 --> 00:31:20.826 A:middle
Well if you try to do
a sizeof(Foo) on that,

00:31:21.136 --> 00:31:22.496 A:middle
you're still going
to get 32 bytes.

00:31:22.786 --> 00:31:24.376 A:middle
And you're like, why is that.

00:31:24.926 --> 00:31:28.356 A:middle
The reason for that is the
compiler still has to guarantee

00:31:28.766 --> 00:31:31.626 A:middle
that each struct is
aligned to the site

00:31:31.626 --> 00:31:33.836 A:middle
of the largest data
type in that struct.

00:31:34.446 --> 00:31:37.136 A:middle
Because if you were to
use an array of these,

00:31:37.136 --> 00:31:40.126 A:middle
if you type index C at index 1,

00:31:40.506 --> 00:31:42.386 A:middle
you have to make sure
it's the line on 16 bytes.

00:31:42.676 --> 00:31:43.456 A:middle
So that doesn't work.

00:31:44.026 --> 00:31:47.626 A:middle
So what if I wanted to tightly
pack all my data structures?

00:31:48.126 --> 00:31:48.966 A:middle
You can do that.

00:31:48.966 --> 00:31:51.056 A:middle
And we have packed
vector types for that.

00:31:51.796 --> 00:31:54.046 A:middle
So they are just like
the aligned vector types.

00:31:54.096 --> 00:31:56.796 A:middle
There declared with this
packed underscore prefix.

00:31:57.746 --> 00:32:01.896 A:middle
You can do all of the operations
on these types as you can


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:57.746 --> 00:32:01.896 A:middle
You can do all of the operations
on these types as you can

00:32:01.966 --> 00:32:03.246 A:middle
on the aligned vector types.

00:32:04.076 --> 00:32:07.436 A:middle
The only benefit is that a
line is scalar type length.

00:32:07.606 --> 00:32:11.756 A:middle
So if I declare the same struct
now, but use the packed types,

00:32:12.376 --> 00:32:14.066 A:middle
then these are aligned
correctly.

00:32:14.066 --> 00:32:16.466 A:middle
And so the size of Foo
is going to be 28 bytes.

00:32:16.786 --> 00:32:19.976 A:middle
So then you are asked, well why
shouldn't I always use these

00:32:19.976 --> 00:32:20.586 A:middle
packed types?

00:32:21.486 --> 00:32:23.406 A:middle
And the reason, the
answer to that depends

00:32:23.406 --> 00:32:26.186 A:middle
on how you are going to
use these on the host.

00:32:26.186 --> 00:32:31.426 A:middle
Because the CPU, these types
are not a good fit for the CPU.

00:32:31.426 --> 00:32:33.786 A:middle
But the CPU likes vector
types to be aligned.

00:32:33.786 --> 00:32:35.766 A:middle
So if you're just
building a data structure,

00:32:36.106 --> 00:32:38.696 A:middle
and just filling it
out and going to pass

00:32:38.696 --> 00:32:41.776 A:middle
that to the shader, and
most of your computations

00:32:41.776 --> 00:32:43.686 A:middle
on these data types are going
to happen in the shader,

00:32:43.936 --> 00:32:45.186 A:middle
then you can use the pack types.

00:32:45.626 --> 00:32:48.436 A:middle
But if you're going to perform
computations with these types

00:32:49.336 --> 00:32:51.916 A:middle
in host code, then you should
use the aligned vector types.

00:32:52.256 --> 00:32:55.816 A:middle
So use that to determine like
which types you need to use.

00:32:56.116 --> 00:32:58.796 A:middle
All right, so the last
of the basic types,

00:32:58.796 --> 00:32:59.986 A:middle
and these are the atomic types.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:00.476 --> 00:33:04.346 A:middle
And so we support a subset
of the C++11 atomic types.

00:33:04.936 --> 00:33:07.686 A:middle
And the question is why
should I use atomic types?

00:33:07.796 --> 00:33:11.416 A:middle
Well, the operations on
these types are race-free.

00:33:11.516 --> 00:33:12.886 A:middle
So, let's take an example.

00:33:12.886 --> 00:33:15.206 A:middle
Let's say I'm generating
a histogram for an image.

00:33:15.616 --> 00:33:17.016 A:middle
And so I have 8 bits
per channel.

00:33:17.016 --> 00:33:20.026 A:middle
So I have 256 bins for
each color channel.

00:33:20.526 --> 00:33:22.196 A:middle
So I want to update a bin.

00:33:22.456 --> 00:33:23.666 A:middle
So I'm going to read
the current value.

00:33:23.726 --> 00:33:25.826 A:middle
I'm going to increment
it, and then write it out.

00:33:25.826 --> 00:33:28.936 A:middle
So what I want to make sure
is that after I've read

00:33:29.076 --> 00:33:31.826 A:middle
but before I've written, nobody
else comes and changes it.

00:33:31.976 --> 00:33:34.706 A:middle
And that's what these
atomic operations guarantee.

00:33:35.226 --> 00:33:38.326 A:middle
Okay. All right, so that
covers the basic types.

00:33:38.896 --> 00:33:42.136 A:middle
So let's talk about resource and
state objects that you can pass

00:33:42.606 --> 00:33:43.796 A:middle
as data types to your shader.

00:33:45.826 --> 00:33:49.156 A:middle
All right, so we support the
traditional texture types

00:33:49.156 --> 00:33:51.806 A:middle
like 1d, 1dArray, 2d, 2dArray,

00:33:52.096 --> 00:33:54.006 A:middle
but how do you declare
these in Metal?

00:33:54.096 --> 00:33:58.556 A:middle
So these are declared
as a template.

00:33:58.926 --> 00:34:00.256 A:middle
He likes it, all right.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:58.926 --> 00:34:00.256 A:middle
He likes it, all right.

00:34:00.376 --> 00:34:03.416 A:middle
So the template takes
two parameters.

00:34:03.416 --> 00:34:04.616 A:middle
One is the color type.

00:34:04.616 --> 00:34:07.656 A:middle
And this indicates if
you're going to sample

00:34:07.656 --> 00:34:10.356 A:middle
from a texture the vector
type you're going to return,

00:34:10.856 --> 00:34:13.676 A:middle
or as a color value, or
if you're going to write

00:34:13.916 --> 00:34:15.346 A:middle
to the texture, what
is the vector type

00:34:15.696 --> 00:34:17.206 A:middle
that would represent
the color value?

00:34:17.416 --> 00:34:18.335 A:middle
And the access mode.

00:34:18.565 --> 00:34:21.275 A:middle
And this tells the compiler
whether you're going

00:34:21.275 --> 00:34:24.886 A:middle
to be sampling from a
texture or reading or writing.

00:34:25.005 --> 00:34:27.216 A:middle
Reading is just saying hey,

00:34:27.216 --> 00:34:31.496 A:middle
go read this specific
location pixel in my texture

00:34:31.545 --> 00:34:33.866 A:middle
or in write this color value

00:34:33.866 --> 00:34:35.636 A:middle
to this specific
location in the texture.

00:34:36.255 --> 00:34:38.356 A:middle
You can sample and
read or write.

00:34:38.505 --> 00:34:41.936 A:middle
You cannot do both to the
same texture within a shader.

00:34:42.436 --> 00:34:44.896 A:middle
And that textures is
of a different type

00:34:44.896 --> 00:34:47.656 A:middle
because the GPU actually
optimizes them differently.

00:34:47.656 --> 00:34:48.565 A:middle
And so we need to know

00:34:48.565 --> 00:34:50.815 A:middle
that you're actually
working with a depth texture.

00:34:51.656 --> 00:34:53.446 A:middle
So let's look at some examples.

00:34:54.246 --> 00:34:56.726 A:middle
So in this first one
we have a 2d texture,

00:34:56.946 --> 00:34:58.416 A:middle
and it's this color
type, this float.

00:34:58.416 --> 00:34:59.796 A:middle
So if you sample from
this, you're going

00:34:59.796 --> 00:35:00.816 A:middle
to return the float forward.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.796 --> 00:35:00.816 A:middle
to return the float forward.

00:35:01.176 --> 00:35:02.596 A:middle
Notice I didn't specify
the access [inaudible]

00:35:02.596 --> 00:35:05.526 A:middle
because it has a
default which is sample.

00:35:05.946 --> 00:35:11.326 A:middle
So the next one is a 2d texture
again which uses the half type

00:35:11.326 --> 00:35:13.196 A:middle
and its mode is right.

00:35:13.196 --> 00:35:16.286 A:middle
So if I try to read from
this texture in my shader,

00:35:16.286 --> 00:35:17.576 A:middle
the compiler will
throw an error.

00:35:17.766 --> 00:35:20.986 A:middle
And finally we have a
depth texture, okay.

00:35:22.016 --> 00:35:24.546 A:middle
Samplers are separate
from textures.

00:35:24.836 --> 00:35:26.656 A:middle
So, what does that mean?

00:35:26.656 --> 00:35:29.966 A:middle
That means I can u se the same
sampler with multiple textures.

00:35:29.966 --> 00:35:31.946 A:middle
Or I can use multiple samplers

00:35:31.946 --> 00:35:33.346 A:middle
of the same thing
with one texture.

00:35:33.926 --> 00:35:34.706 A:middle
You have the freedom.

00:35:35.206 --> 00:35:36.206 A:middle
How do I pass these?

00:35:36.426 --> 00:35:39.326 A:middle
Well, like I said, everything
is passed as an argument,

00:35:39.326 --> 00:35:41.636 A:middle
so you can pass them as an
argument to your shader.

00:35:41.636 --> 00:35:44.646 A:middle
In addition though, you
can actually declare them

00:35:44.646 --> 00:35:45.356 A:middle
in your source.

00:35:45.876 --> 00:35:47.856 A:middle
So it depends.

00:35:47.856 --> 00:35:49.076 A:middle
So like in a lot of cases,

00:35:49.076 --> 00:35:52.206 A:middle
especially if you're doing
an image processing filters.

00:35:52.296 --> 00:35:53.896 A:middle
You know you just need
a hand full of samplers

00:35:53.926 --> 00:35:55.606 A:middle
that you're going to use.

00:35:56.106 --> 00:35:57.916 A:middle
And data declared is
a variadic template.

00:35:57.916 --> 00:36:00.296 A:middle
And the reason for that
is samples have a number


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:57.916 --> 00:36:00.296 A:middle
And the reason for that
is samples have a number

00:36:00.296 --> 00:36:02.926 A:middle
of properties like the filter
mode, the aggressing mode,

00:36:03.416 --> 00:36:05.706 A:middle
whether the coordinates I'm
going to use are normalized

00:36:05.706 --> 00:36:07.626 A:middle
or pixel and a bunch
of other things.

00:36:07.716 --> 00:36:11.496 A:middle
I don't want to have to set
them explicitly every time.

00:36:11.716 --> 00:36:13.106 A:middle
All of these have defaults.

00:36:13.396 --> 00:36:15.186 A:middle
So you only change
the one you want to,

00:36:15.186 --> 00:36:16.656 A:middle
you are changing
from the defaults.

00:36:16.656 --> 00:36:19.066 A:middle
So in this example, I'm
changing the address more

00:36:19.066 --> 00:36:20.516 A:middle
from [inaudible] to zero,

00:36:20.846 --> 00:36:23.716 A:middle
and the other properties
take the default.

00:36:24.276 --> 00:36:26.796 A:middle
So you can choose to
pass them as an argument,

00:36:26.796 --> 00:36:28.746 A:middle
or you can choose them to
declare them the source,

00:36:28.746 --> 00:36:29.656 A:middle
depending on your needs.

00:36:30.966 --> 00:36:32.296 A:middle
All right, so last of the types.

00:36:32.566 --> 00:36:37.356 A:middle
All right, so buffers is just as
Jeremy mentioned a bag of bytes.

00:36:37.486 --> 00:36:40.856 A:middle
And so you just pass a pointer
or a reference to this type.

00:36:41.086 --> 00:36:43.616 A:middle
And notice in the first slide
I have this global qualifier.

00:36:43.616 --> 00:36:45.226 A:middle
Well let's talk about that now.

00:36:45.526 --> 00:36:48.366 A:middle
See anything that's passed
as a pointer or a reference

00:36:48.366 --> 00:36:51.356 A:middle
to some memory, you need to say
its memory region comes from.

00:36:51.866 --> 00:36:53.636 A:middle
And that's because GPU's
actually implement the

00:36:53.636 --> 00:36:54.476 A:middle
member hierarchy.

00:36:55.126 --> 00:36:57.206 A:middle
With compute, you got an
additional memory region.

00:36:57.206 --> 00:36:58.876 A:middle
But if you're just writing
vertex and fragment shaders,

00:36:58.916 --> 00:37:02.436 A:middle
the two memory regions we
call them address spaces.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.916 --> 00:37:02.436 A:middle
the two memory regions we
call them address spaces.

00:37:02.436 --> 00:37:04.756 A:middle
You need to worry about
our global and constant.

00:37:04.866 --> 00:37:07.096 A:middle
So the question is, well
when should I use which?

00:37:07.976 --> 00:37:11.246 A:middle
All right, so if you are
writing a vertex shader,

00:37:11.676 --> 00:37:14.666 A:middle
your past pointers to
some buffers, you're going

00:37:14.666 --> 00:37:16.796 A:middle
to use your vertex
ID to index into it.

00:37:16.986 --> 00:37:20.926 A:middle
That means for each, if the
vertex shader is being executed

00:37:20.926 --> 00:37:24.596 A:middle
over n vertices, all
of these instances

00:37:24.596 --> 00:37:26.136 A:middle
that are executing the
vertex shader are going

00:37:26.136 --> 00:37:27.566 A:middle
to be unique locations.

00:37:27.746 --> 00:37:30.916 A:middle
So when you see that data
pattern, you want to use global.

00:37:32.196 --> 00:37:33.576 A:middle
Okay, and the same
thing for compute.

00:37:33.626 --> 00:37:35.496 A:middle
You will find that
out when we talk

00:37:35.496 --> 00:37:36.636 A:middle
about computing in
the next session.

00:37:37.486 --> 00:37:41.906 A:middle
However, you will also find
in your shader that you may,

00:37:42.136 --> 00:37:45.066 A:middle
you are actually accessing
some data structures where all

00:37:45.066 --> 00:37:48.656 A:middle
of these instances actually
access the same location.

00:37:48.856 --> 00:37:51.986 A:middle
For example, if you
have a light descriptor.

00:37:52.296 --> 00:37:53.416 A:middle
Or if you're doing skinning.

00:37:53.416 --> 00:37:54.406 A:middle
Or if you're doing filtering.

00:37:55.046 --> 00:37:56.356 A:middle
So in this case you will find

00:37:56.356 --> 00:38:00.876 A:middle
that all these instances
executing your vertex shader go


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:56.356 --> 00:38:00.876 A:middle
that all these instances
executing your vertex shader go

00:38:00.876 --> 00:38:02.536 A:middle
refer to the same
light descriptor.

00:38:02.756 --> 00:38:04.416 A:middle
All of the same skinning matrix.

00:38:04.736 --> 00:38:05.826 A:middle
So let's look at an example.

00:38:06.336 --> 00:38:08.746 A:middle
One more thing here is
that when you use constant,

00:38:08.986 --> 00:38:10.566 A:middle
we really want you
to pass by reference.

00:38:11.006 --> 00:38:12.816 A:middle
Because that tells
us what the size it

00:38:12.816 --> 00:38:15.186 A:middle
and we can actually optimize
by prefetching the data.

00:38:15.246 --> 00:38:18.606 A:middle
And that can have a significant
impact to improvement

00:38:18.606 --> 00:38:19.596 A:middle
of performance of the shader.

00:38:19.706 --> 00:38:23.146 A:middle
So definitely take
advantage of that.

00:38:23.146 --> 00:38:24.346 A:middle
Okay, so let's take an example.

00:38:24.846 --> 00:38:26.466 A:middle
Here I have four arguments,

00:38:26.696 --> 00:38:29.386 A:middle
passing three buffers
and my vertex ID.

00:38:29.386 --> 00:38:30.976 A:middle
So let's look at the
first data pattern.

00:38:31.516 --> 00:38:33.136 A:middle
Look at normal data
and position data.

00:38:33.136 --> 00:38:35.876 A:middle
I'm actually accessing
using my vertex ID,

00:38:35.876 --> 00:38:38.886 A:middle
so which address space
should these belong in?

00:38:40.176 --> 00:38:42.376 A:middle
Global. But if you look

00:38:42.376 --> 00:38:46.786 A:middle
at the other three data
pattern accesses and matrices,

00:38:46.786 --> 00:38:50.596 A:middle
you notice that if in a multiple
vertices root exiting this

00:38:50.596 --> 00:38:53.246 A:middle
function across multiple
vertices, they're going to defer

00:38:53.246 --> 00:38:56.536 A:middle
to the same normal matrix,
the same projection matrix.

00:38:57.026 --> 00:38:59.696 A:middle
So, therefore, I
should declare these

00:38:59.696 --> 00:39:00.826 A:middle
in a constant address space.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.696 --> 00:39:00.826 A:middle
in a constant address space.

00:39:00.826 --> 00:39:02.886 A:middle
So hopefully this gives
you an idea of how

00:39:02.886 --> 00:39:05.326 A:middle
to declare your buffers
in which address space.

00:39:05.446 --> 00:39:06.786 A:middle
You don't have to do
that for textures.

00:39:07.206 --> 00:39:11.056 A:middle
All right, so let's talk
about inputs and outputs.

00:39:11.056 --> 00:39:14.526 A:middle
So that was a very high-level
overview of the data types.

00:39:14.526 --> 00:39:17.736 A:middle
So, how do you pass input
through your vertex shader?

00:39:17.886 --> 00:39:18.886 A:middle
Well there are two ways.

00:39:19.346 --> 00:39:21.026 A:middle
The first one we've
actually shown you, right.

00:39:21.026 --> 00:39:24.186 A:middle
In all of the examples I have
shown you, you pass the input

00:39:24.296 --> 00:39:27.276 A:middle
by passing a point to
a struct, you declare,

00:39:27.276 --> 00:39:29.276 A:middle
and then you use your
vertex ID to index into it.

00:39:29.626 --> 00:39:32.486 A:middle
So that means is you
actually know the data layout

00:39:33.146 --> 00:39:34.726 A:middle
of your vertex inputting
in a shader.

00:39:34.796 --> 00:39:38.056 A:middle
So if you do, this is
the way to do it, okay.

00:39:38.056 --> 00:39:40.506 A:middle
So in addition to your vertex
ID you can also use your

00:39:40.506 --> 00:39:41.206 A:middle
instance ID.

00:39:42.246 --> 00:39:45.076 A:middle
Like in this example, I
have two inputs I'm passing

00:39:45.076 --> 00:39:49.736 A:middle
in as buffers, and I'm using
the vertex ID and instance ID.

00:39:50.046 --> 00:39:52.946 A:middle
But there is also the
traditional approach.

00:39:53.486 --> 00:39:57.216 A:middle
So in this approach, you
don't know the data layout

00:39:57.456 --> 00:39:58.076 A:middle
in your shader.

00:39:58.546 --> 00:40:01.656 A:middle
And so if you want it all,
you may want to decouple.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:58.546 --> 00:40:01.656 A:middle
And so if you want it all,
you may want to decouple.

00:40:01.886 --> 00:40:04.446 A:middle
You may want to declare in your
vertex shader you have other

00:40:04.446 --> 00:40:07.056 A:middle
data types you want to
use for your vertex inputs

00:40:07.056 --> 00:40:09.106 A:middle
because of the computations
you're doing in your shader.

00:40:09.606 --> 00:40:13.056 A:middle
And have the flexibility to be
able to declare the actual input

00:40:13.296 --> 00:40:15.146 A:middle
at runtime in the
buffers your showing

00:40:15.146 --> 00:40:15.976 A:middle
and they may be different.

00:40:16.486 --> 00:40:20.376 A:middle
So, this is more like the
OpenGL's Vertex Array API.

00:40:20.376 --> 00:40:25.006 A:middle
And so this, this approach in
Metal is actually a good match.

00:40:25.096 --> 00:40:26.936 A:middle
And let me talk about
how it works.

00:40:27.346 --> 00:40:28.176 A:middle
So the thing you'll do

00:40:28.176 --> 00:40:30.586 A:middle
in the runtime is you will
create a vertex descriptor.

00:40:30.656 --> 00:40:32.906 A:middle
So in this descriptor for
each input, you're going

00:40:32.906 --> 00:40:36.546 A:middle
to specify the buffer it comes
from, where inside the buffer,

00:40:37.566 --> 00:40:39.936 A:middle
what is the format,
things like that.

00:40:40.376 --> 00:40:43.106 A:middle
And you may have one or more
buffers for your inputs.

00:40:43.346 --> 00:40:46.826 A:middle
In the shader, everything
that is an input, you're going

00:40:46.826 --> 00:40:47.916 A:middle
to declare them in the struct.

00:40:47.916 --> 00:40:51.456 A:middle
And remember I said, anything
that is user defined information

00:40:51.456 --> 00:40:53.186 A:middle
that you want to
generate per instance,

00:40:53.936 --> 00:40:55.066 A:middle
you have to use stage
underscore in.

00:40:55.066 --> 00:40:55.936 A:middle
So that's how you declare it.

00:40:56.616 --> 00:40:58.506 A:middle
So let's look at a code example.

00:40:59.986 --> 00:41:02.986 A:middle
Before that, so I declared
my struct and my shader,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.986 --> 00:41:02.986 A:middle
Before that, so I declared
my struct and my shader,

00:41:03.196 --> 00:41:06.186 A:middle
and I declared my vertex
descriptor, all my inputs

00:41:06.186 --> 00:41:07.776 A:middle
and my vertex descriptor,
I need to be able

00:41:07.776 --> 00:41:08.926 A:middle
to say hey, this will work.

00:41:08.926 --> 00:41:11.246 A:middle
I need to be able to
map one to the other.

00:41:11.346 --> 00:41:12.876 A:middle
And the way I do that is

00:41:12.876 --> 00:41:15.376 A:middle
by specifying an
attributing index, okay.

00:41:15.466 --> 00:41:16.396 A:middle
So let's look at an example.

00:41:16.396 --> 00:41:19.236 A:middle
Let's say I want to
pass four inputs.

00:41:19.406 --> 00:41:21.906 A:middle
The first one is going to be
positioned, and it's going

00:41:21.906 --> 00:41:25.306 A:middle
to be an index 0,
and 12 bytes in size.

00:41:25.376 --> 00:41:26.706 A:middle
The next one is normal.

00:41:27.186 --> 00:41:29.656 A:middle
It's also at offset 12
and 12 bytes in size.

00:41:29.656 --> 00:41:31.356 A:middle
In fact, all four
inputs are going

00:41:31.356 --> 00:41:32.426 A:middle
to come from the same buffer.

00:41:32.816 --> 00:41:36.486 A:middle
And so the next one is color
at index 2, 4 bytes in size.

00:41:36.486 --> 00:41:39.606 A:middle
And then third is texture
coordinate at index 3,

00:41:39.606 --> 00:41:40.926 A:middle
4 bytes in size, okay.

00:41:41.366 --> 00:41:43.026 A:middle
All right, so how do I
declare this in the shader?

00:41:43.516 --> 00:41:44.526 A:middle
So I have a struct.

00:41:44.526 --> 00:41:47.716 A:middle
I have defined the data
types I want to use.

00:41:48.146 --> 00:41:50.326 A:middle
And the attribute indices
they're going to use.

00:41:50.326 --> 00:41:53.226 A:middle
And notice that I've declared
them with the stage a qualifier

00:41:53.226 --> 00:41:54.966 A:middle
because this is going
to be per instance.

00:41:55.436 --> 00:41:57.376 A:middle
For every instance it
executes as a vertex shader.

00:41:57.476 --> 00:41:59.276 A:middle
Okay, so let's look at the API.

00:41:59.776 --> 00:42:00.696 A:middle
So the first thing I'm going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.776 --> 00:42:00.696 A:middle
So the first thing I'm going

00:42:00.696 --> 00:42:02.776 A:middle
to do is create the
vertex descriptor.

00:42:03.536 --> 00:42:06.496 A:middle
So the first imput
was my position.

00:42:06.576 --> 00:42:08.906 A:middle
So I'm going to say
float3 is 12 bytes.

00:42:08.906 --> 00:42:11.296 A:middle
It's going to start us off at 0.

00:42:11.926 --> 00:42:15.996 A:middle
And notice I had a single
buffer for all of the input.

00:42:15.996 --> 00:42:18.406 A:middle
So my buffer index for all
of these is going to be 0.

00:42:19.226 --> 00:42:20.446 A:middle
The attribute index is 0.

00:42:21.196 --> 00:42:24.696 A:middle
The next I set the
normal, so at index1.

00:42:24.696 --> 00:42:27.736 A:middle
The next I set color, at index2.

00:42:27.736 --> 00:42:29.346 A:middle
Actual coordinate.

00:42:30.156 --> 00:42:33.796 A:middle
And for each buffer that I'm
using could declare my vertex

00:42:33.796 --> 00:42:36.776 A:middle
inputs and my descriptor,
I have to say the stride,

00:42:37.116 --> 00:42:39.376 A:middle
what is the stride so I can
fetch the right vertex data.

00:42:40.066 --> 00:42:41.476 A:middle
So in this case it's 32 bytes.

00:42:41.626 --> 00:42:42.366 A:middle
So I did that.

00:42:43.276 --> 00:42:44.826 A:middle
Then I put this vertex
descriptor

00:42:45.376 --> 00:42:47.076 A:middle
to in my pipeline descriptor.

00:42:47.226 --> 00:42:49.536 A:middle
And then I create
my pipeline object,

00:42:49.606 --> 00:42:50.736 A:middle
my RenderPipeline object.

00:42:51.026 --> 00:42:55.206 A:middle
And at that point in time,
Metal will go figure out how

00:42:55.206 --> 00:42:57.016 A:middle
to generate the code
to go fetch your input.

00:42:57.226 --> 00:42:58.576 A:middle
So, you have both
options available.

00:42:58.576 --> 00:43:02.216 A:middle
Use which works best
for your problem.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:58.576 --> 00:43:02.216 A:middle
Use which works best
for your problem.

00:43:02.606 --> 00:43:06.606 A:middle
All right, outputs, well there
are two ways of writing inputs,

00:43:06.606 --> 00:43:08.516 A:middle
so we wanted to make
sure you get two ways

00:43:08.516 --> 00:43:09.506 A:middle
of writing outputs too.

00:43:10.466 --> 00:43:13.576 A:middle
So, typically what you
would do is the output

00:43:13.576 --> 00:43:15.906 A:middle
of your vertex shader will go
that rasterizer because you want

00:43:15.906 --> 00:43:17.446 A:middle
to show something on the screen,

00:43:17.446 --> 00:43:18.796 A:middle
so you want to rasterize
triangles.

00:43:19.276 --> 00:43:22.856 A:middle
So anything that you
return from the return type

00:43:22.856 --> 00:43:25.306 A:middle
of your vertex shader is what's
going to go to that rasterizer.

00:43:25.566 --> 00:43:26.416 A:middle
So what can I return?

00:43:26.626 --> 00:43:27.786 A:middle
I can return a float4.

00:43:27.996 --> 00:43:30.996 A:middle
At a minimum I must return a
float4, and I'll tell you why.

00:43:31.416 --> 00:43:33.106 A:middle
Or you can have a
user-defined struct.

00:43:33.606 --> 00:43:35.106 A:middle
What can be I this struct?

00:43:35.316 --> 00:43:38.736 A:middle
So there can be a scalar,
a vector or a matrix.

00:43:38.736 --> 00:43:39.966 A:middle
You can even have
arrays of these.

00:43:40.776 --> 00:43:42.476 A:middle
There's some special
variables we need to know

00:43:42.476 --> 00:43:44.876 A:middle
about like position, point size

00:43:44.876 --> 00:43:47.096 A:middle
if you're rendering a point
sprite or clip distance.

00:43:47.586 --> 00:43:49.946 A:middle
You must return a float4
because the position must always

00:43:49.946 --> 00:43:50.376 A:middle
be returned.

00:43:50.376 --> 00:43:51.616 A:middle
It's kind of hard
for the rasterizer

00:43:51.616 --> 00:43:54.306 A:middle
to generate rasterized triangles
for that [inaudible] position.

00:43:54.816 --> 00:43:55.376 A:middle
So that's why.

00:43:57.336 --> 00:43:58.946 A:middle
All right, so here's an example.

00:43:59.926 --> 00:44:01.076 A:middle
I'm returning four things.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.926 --> 00:44:01.076 A:middle
I'm returning four things.

00:44:01.686 --> 00:44:05.766 A:middle
And I use the built-in variables
attributes to identify things

00:44:05.766 --> 00:44:07.146 A:middle
as position and point size.

00:44:07.226 --> 00:44:08.806 A:middle
This is really pretty
straight forward.

00:44:08.806 --> 00:44:09.636 A:middle
Declare your struct.

00:44:10.086 --> 00:44:11.596 A:middle
Declare some attributes
and you're done.

00:44:12.606 --> 00:44:14.146 A:middle
Okay. So it's great.

00:44:14.936 --> 00:44:17.826 A:middle
I can generate output,
pass it to the rasterizer.

00:44:17.986 --> 00:44:18.976 A:middle
But I want to do more.

00:44:20.256 --> 00:44:22.966 A:middle
I want to be able to
write some buffer,

00:44:23.066 --> 00:44:24.336 A:middle
maybe more than one buffer.

00:44:24.336 --> 00:44:26.416 A:middle
I don't want to send
anything to the rasterizer.

00:44:26.616 --> 00:44:27.776 A:middle
Or maybe I want to do both.

00:44:28.236 --> 00:44:28.826 A:middle
Can I do that?

00:44:29.116 --> 00:44:34.216 A:middle
The answer is we
are here to please.

00:44:36.396 --> 00:44:39.386 A:middle
So remember the vertex ID
you can use that to input.

00:44:39.386 --> 00:44:40.496 A:middle
Well guess what?

00:44:40.496 --> 00:44:42.726 A:middle
You can use that to output too.

00:44:42.856 --> 00:44:45.226 A:middle
So here is the structure
I want to write out.

00:44:45.256 --> 00:44:49.546 A:middle
I want to pass that as, declare

00:44:49.546 --> 00:44:52.356 A:middle
that as a struct
to create a buffer.

00:44:52.356 --> 00:44:54.206 A:middle
Pass that as an argument
to my shader.

00:44:55.036 --> 00:44:57.716 A:middle
And output to it
using the vertex ID.

00:44:58.236 --> 00:45:05.636 A:middle
In fact, I can pass up to 31
buffers if one is not enough.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.236 --> 00:45:05.636 A:middle
In fact, I can pass up to 31
buffers if one is not enough.

00:45:05.636 --> 00:45:08.056 A:middle
You notice I'm not
returning anything here

00:45:08.056 --> 00:45:09.086 A:middle
because the return type.

00:45:11.186 --> 00:45:13.226 A:middle
But I could have returned
the same struct here,

00:45:13.396 --> 00:45:15.366 A:middle
or I could return something
completely different.

00:45:15.656 --> 00:45:18.336 A:middle
So you have a lot
of flexibility here.

00:45:18.666 --> 00:45:19.006 A:middle
All right.

00:45:19.846 --> 00:45:21.706 A:middle
So that's per vertex
inputs/outputs.

00:45:21.926 --> 00:45:23.566 A:middle
Per-fragments are a lot simpler.

00:45:23.696 --> 00:45:25.146 A:middle
There's only one way
of doing things here.

00:45:25.696 --> 00:45:31.786 A:middle
So, the inputs to a fragment
shader are typically the outputs

00:45:31.786 --> 00:45:33.906 A:middle
of the vertex shader because
they go to the rasterizer

00:45:34.016 --> 00:45:36.526 A:middle
and they generate fragments
and that's the inputs.

00:45:36.996 --> 00:45:39.926 A:middle
So what can I, must be declared
in with this stage in qualifier.

00:45:41.776 --> 00:45:44.666 A:middle
Sometimes the raster also
generates information

00:45:44.666 --> 00:45:46.226 A:middle
that you may actually
want to know about,

00:45:46.226 --> 00:45:48.066 A:middle
like is my triangle
front-facing?

00:45:48.616 --> 00:45:50.176 A:middle
Or if I'm doing multi-sampling,

00:45:51.226 --> 00:45:53.186 A:middle
so things like that
you can use attributes

00:45:53.726 --> 00:45:55.646 A:middle
to identify these inputs.

00:45:55.736 --> 00:45:57.896 A:middle
And if you wanted to
program a blending,

00:45:58.216 --> 00:45:59.996 A:middle
you want to read the
frame buffer color value.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:00.276 --> 00:46:02.926 A:middle
So, you can, so let's
talk about how I do that.

00:46:03.136 --> 00:46:04.276 A:middle
So here's an example.

00:46:05.136 --> 00:46:08.716 A:middle
In this case, my fragment
input was the output

00:46:08.716 --> 00:46:09.636 A:middle
of the vertex shader.

00:46:09.926 --> 00:46:12.136 A:middle
So I used the staging
qualifier to say

00:46:12.136 --> 00:46:13.676 A:middle
that this is a per-fragment
input.

00:46:14.686 --> 00:46:18.106 A:middle
I want to read whether the
triangle is front facing or not.

00:46:18.106 --> 00:46:20.696 A:middle
So I use this attribute
to identify

00:46:20.696 --> 00:46:22.986 A:middle
that this front face is
a front-facing variable.

00:46:23.056 --> 00:46:25.386 A:middle
And I also want to do
blending in my shader.

00:46:25.646 --> 00:46:28.066 A:middle
So I'm going to read
front color attachment 0.

00:46:29.856 --> 00:46:31.936 A:middle
Though I passed as a
separate arguments here,

00:46:31.936 --> 00:46:32.866 A:middle
they don't have to be.

00:46:32.866 --> 00:46:37.406 A:middle
I could have declared them
in the struct itself, okay.

00:46:38.126 --> 00:46:40.166 A:middle
Outputs from a fragment
shader work just

00:46:40.166 --> 00:46:41.906 A:middle
like outputs from
a vertex shader.

00:46:42.226 --> 00:46:43.256 A:middle
You can't write the
memory though.

00:46:43.356 --> 00:46:44.176 A:middle
Only the first one.

00:46:44.176 --> 00:46:45.106 A:middle
So you only return type.

00:46:45.106 --> 00:46:49.016 A:middle
And you get in return a scalar,
vector or user-defined struct.

00:46:49.016 --> 00:46:50.146 A:middle
A lot of flexibility here.

00:46:50.476 --> 00:46:53.316 A:middle
But the only you can return in
a fragment shader is a color,

00:46:53.316 --> 00:46:55.536 A:middle
a depth or a sample mask.

00:46:55.796 --> 00:46:57.676 A:middle
And we need to know so you have

00:46:57.676 --> 00:46:59.546 A:middle
to four color attachments,
one depth.

00:46:59.966 --> 00:47:00.856 A:middle
And sample mass.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.966 --> 00:47:00.856 A:middle
And sample mass.

00:47:00.856 --> 00:47:02.126 A:middle
We need to know what
you're writing to.

00:47:02.186 --> 00:47:05.156 A:middle
And so you identify them
with attributes, okay.

00:47:06.036 --> 00:47:10.696 A:middle
So in this example, I'm
just returning a single

00:47:10.696 --> 00:47:11.836 A:middle
and a color value back.

00:47:11.836 --> 00:47:13.826 A:middle
This is going to be returned
to color attachment zero.

00:47:14.676 --> 00:47:17.646 A:middle
Here's another example where I'm
returning more than one color.

00:47:17.946 --> 00:47:20.726 A:middle
And notice here that the color
attachments don't have to be

00:47:20.726 --> 00:47:22.356 A:middle
in the right order, okay.

00:47:22.426 --> 00:47:23.396 A:middle
They can be sparse.

00:47:24.836 --> 00:47:27.166 A:middle
All right, you guys ready
for some matchmaking?

00:47:28.436 --> 00:47:33.176 A:middle
All right, so I've written,
you've written a vertex shader

00:47:33.176 --> 00:47:34.086 A:middle
and a fragment shader.

00:47:34.516 --> 00:47:36.986 A:middle
I want to pair them because
I can't do the RenderPipeline

00:47:36.986 --> 00:47:37.496 A:middle
without it.

00:47:37.496 --> 00:47:38.496 A:middle
So how do I pair?

00:47:38.786 --> 00:47:39.516 A:middle
What are the rules?

00:47:39.976 --> 00:47:41.916 A:middle
The simplest rule
is the types match.

00:47:42.776 --> 00:47:46.536 A:middle
That means to return type of
the vertex share is the input

00:47:46.756 --> 00:47:47.556 A:middle
to the fragment sharer.

00:47:47.626 --> 00:47:49.406 A:middle
In this example,
that's what it is.

00:47:50.356 --> 00:47:52.576 A:middle
And this will always pair, okay.

00:47:53.386 --> 00:47:54.586 A:middle
But that's boring.

00:47:54.736 --> 00:47:59.856 A:middle
I want to just, I want
to declare my own struct

00:47:59.946 --> 00:48:01.626 A:middle
as my input to my
fragment shader,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.946 --> 00:48:01.626 A:middle
as my input to my
fragment shader,

00:48:01.626 --> 00:48:03.976 A:middle
and that can be a subset.

00:48:03.976 --> 00:48:05.606 A:middle
In fact, that's typically
very common

00:48:05.636 --> 00:48:08.696 A:middle
if I use one vertex shader with
many, many fragment shaders.

00:48:08.696 --> 00:48:09.936 A:middle
So where's the rule here then?

00:48:09.936 --> 00:48:10.566 A:middle
How do I pair?

00:48:10.566 --> 00:48:11.906 A:middle
The rule is really simple.

00:48:12.036 --> 00:48:14.556 A:middle
For anything that's an
input to the fragment,

00:48:15.696 --> 00:48:20.726 A:middle
it's attribute name and type
must exist in the vertex output.

00:48:20.916 --> 00:48:26.326 A:middle
So in this example, you know,
I have position is a float4

00:48:26.326 --> 00:48:29.066 A:middle
in my fragment input, but it
exists, and it's the same.

00:48:29.766 --> 00:48:32.386 A:middle
Same thing for this
attribute, user(T).

00:48:32.386 --> 00:48:35.406 A:middle
So anything that's not
a variable, you can come

00:48:35.616 --> 00:48:36.766 A:middle
up with your own name.

00:48:37.006 --> 00:48:40.636 A:middle
It just needs to use the user
parenthesis, a basis index.

00:48:41.096 --> 00:48:42.546 A:middle
So that's the same thing here.

00:48:43.806 --> 00:48:46.726 A:middle
And so if I create a vertex
shader and a fragment shader

00:48:46.896 --> 00:48:48.876 A:middle
that uses these types,
they will pair.

00:48:49.516 --> 00:48:50.956 A:middle
Note that there is
no requirement

00:48:50.956 --> 00:48:52.666 A:middle
that all the elements I have

00:48:52.666 --> 00:48:55.266 A:middle
in my fragment input must
occur in the same order.

00:48:55.446 --> 00:48:57.976 A:middle
They can occur in any order,
they just need to occur.

00:48:58.276 --> 00:48:58.586 A:middle
That's it.

00:48:58.626 --> 00:49:00.926 A:middle
All right so that's
matchmaking for you guys.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:58.626 --> 00:49:00.926 A:middle
All right so that's
matchmaking for you guys.

00:49:01.806 --> 00:49:04.026 A:middle
Okay. All right my
favorite topic, math.

00:49:04.836 --> 00:49:08.776 A:middle
Is anyone interested in math?

00:49:08.866 --> 00:49:13.876 A:middle
But why? Well because the two
common operations you guys are

00:49:13.876 --> 00:49:15.816 A:middle
going to do are loads
and stores.

00:49:16.136 --> 00:49:18.026 A:middle
And the rest is math.

00:49:19.346 --> 00:49:21.776 A:middle
By default, all operation
math operations

00:49:21.776 --> 00:49:23.876 A:middle
in Metal are in fast math mode.

00:49:23.876 --> 00:49:27.016 A:middle
So want to make sure you get
the absolute fastest experience

00:49:27.016 --> 00:49:28.366 A:middle
of shaders running on the GPU.

00:49:28.746 --> 00:49:31.656 A:middle
Did anyone say, well, do you
want to give me fast mode,

00:49:31.656 --> 00:49:33.656 A:middle
why do I care about
precise mode.

00:49:34.316 --> 00:49:36.286 A:middle
Well because you
don't fast modes comes

00:49:36.286 --> 00:49:38.206 A:middle
with some caveats, it's fast.

00:49:39.116 --> 00:49:42.746 A:middle
So, sometimes like in fast
mode we tell you behavior

00:49:42.746 --> 00:49:44.666 A:middle
of nans is NaNs is not defined.

00:49:44.666 --> 00:49:45.756 A:middle
So NaN is not a number.

00:49:46.486 --> 00:49:47.556 A:middle
Well then why do
I care about that?

00:49:47.556 --> 00:49:48.146 A:middle
It's not a number.

00:49:48.146 --> 00:49:50.066 A:middle
I'm not going to do
math on a not a number.

00:49:50.066 --> 00:49:51.806 A:middle
You're like well
sometimes you do.

00:49:52.346 --> 00:49:55.626 A:middle
So for example, if I'm clamping
an input with some minimum

00:49:55.626 --> 00:49:59.996 A:middle
and a maximum, if I pass
an input that's NaN,

00:49:59.996 --> 00:50:02.646 A:middle
in fast mode we're
going to say ah,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:59.996 --> 00:50:02.646 A:middle
in fast mode we're
going to say ah,

00:50:02.646 --> 00:50:03.976 A:middle
we don't know what the
answer is going to be.

00:50:04.446 --> 00:50:06.736 A:middle
But if you actually
follow iTripoli54 rules,

00:50:06.736 --> 00:50:08.246 A:middle
there's guaranteed
defined behavior.

00:50:08.246 --> 00:50:09.656 A:middle
And you may actually
care about that.

00:50:10.426 --> 00:50:12.716 A:middle
Or, let's say you're using
trigonometric functions

00:50:12.716 --> 00:50:13.336 A:middle
in your shader.

00:50:13.806 --> 00:50:16.936 A:middle
In fast mode, they work
great over a small range.

00:50:17.556 --> 00:50:20.006 A:middle
If your inputs go above
and beyond that range,

00:50:20.326 --> 00:50:21.446 A:middle
behavior is undefined.

00:50:22.046 --> 00:50:25.126 A:middle
So, let's say you want
correct behavior for those.

00:50:26.216 --> 00:50:28.516 A:middle
Then you want to
use precise mode.

00:50:29.036 --> 00:50:32.576 A:middle
So one option is you're going
to say I want my entire shader

00:50:32.576 --> 00:50:33.616 A:middle
to run in precise mode.

00:50:33.816 --> 00:50:34.666 A:middle
You can do that.

00:50:34.666 --> 00:50:36.016 A:middle
You can set the compiler option.

00:50:36.196 --> 00:50:38.706 A:middle
But that may actually,

00:50:38.706 --> 00:50:40.776 A:middle
so you need to really know what
you're doing before you set

00:50:40.776 --> 00:50:41.436 A:middle
that option.

00:50:41.556 --> 00:50:43.296 A:middle
So, but that option does exist.

00:50:43.406 --> 00:50:47.296 A:middle
All right, I think the more
common scenario is, you know,

00:50:47.296 --> 00:50:49.936 A:middle
you're going to do most of
your stuff in fast mode.

00:50:50.416 --> 00:50:55.156 A:middle
There may be some functions you
want to run in precise mode.

00:50:55.296 --> 00:50:56.776 A:middle
So, you can do that in Metal.

00:50:57.586 --> 00:50:59.896 A:middle
Because guess what, these
functions actually occur

00:50:59.896 --> 00:51:00.916 A:middle
in nested name spaces.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.896 --> 00:51:00.916 A:middle
in nested name spaces.

00:51:02.256 --> 00:51:09.266 A:middle
So by default, you get
the fast name space.

00:51:09.566 --> 00:51:13.456 A:middle
But you can call the precise
math function explicitly, okay.

00:51:14.296 --> 00:51:15.616 A:middle
So that's it.

00:51:17.026 --> 00:51:18.536 A:middle
Ah Metal standard library.

00:51:18.646 --> 00:51:20.346 A:middle
So we don't do the
C++ standard library.

00:51:20.676 --> 00:51:21.446 A:middle
We do our own.

00:51:21.776 --> 00:51:23.976 A:middle
And it is really
optimized for the GPU.

00:51:23.976 --> 00:51:25.776 A:middle
And I think you guys
are going to love it.

00:51:25.776 --> 00:51:27.326 A:middle
I think it has a nice
list of functions.

00:51:28.036 --> 00:51:30.066 A:middle
It's all described
in the documentation.

00:51:30.486 --> 00:51:33.366 A:middle
I'm going to cover
details of these functions,

00:51:33.366 --> 00:51:34.986 A:middle
but please refer
to the specs of,

00:51:34.986 --> 00:51:36.016 A:middle
these are some of the functions.

00:51:36.556 --> 00:51:38.486 A:middle
There's quite a few, okay.

00:51:39.186 --> 00:51:42.276 A:middle
All right, so what did we do?

00:51:43.226 --> 00:51:45.016 A:middle
We covered, Richard talked

00:51:45.016 --> 00:51:46.936 A:middle
about how you build
a Metal application.

00:51:47.156 --> 00:51:49.306 A:middle
And he showed you how to
draw a simple triangle.

00:51:49.306 --> 00:51:51.626 A:middle
But then he took
it even further.

00:51:51.866 --> 00:51:56.656 A:middle
He showed you how to do
stream uniforms, okay,

00:51:57.056 --> 00:51:59.616 A:middle
with multiple buffers and how
to synchronize them efficiently.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:00.186 --> 00:52:02.096 A:middle
Then I talked to you guys
about the shading language.

00:52:02.096 --> 00:52:02.896 A:middle
We went on a tour.

00:52:03.256 --> 00:52:06.496 A:middle
We didn't go much deeper,
but a very high level tour.

00:52:06.806 --> 00:52:09.626 A:middle
We talked about how to write
shaders, given that it's based

00:52:09.626 --> 00:52:12.496 A:middle
on C++, it's actually going to
be really, really easy for you

00:52:12.496 --> 00:52:13.726 A:middle
to write these shaders.

00:52:14.246 --> 00:52:16.046 A:middle
We talked about data
types Metal supports.

00:52:16.526 --> 00:52:18.806 A:middle
We talked about inputs
and outputs to shaders.

00:52:18.996 --> 00:52:20.566 A:middle
We talked about how
to match them.

00:52:21.016 --> 00:52:22.146 A:middle
We talked about math.

00:52:23.986 --> 00:52:25.636 A:middle
So really, now it's your turn.

00:52:26.326 --> 00:52:29.026 A:middle
I'm excited about how the
amazing ways you guys are going

00:52:29.026 --> 00:52:29.636 A:middle
to use Metal.

00:52:30.316 --> 00:52:32.096 A:middle
And we want to hear from you.

00:52:32.236 --> 00:52:34.106 A:middle
We want to know how we can
improve this even better.

00:52:34.106 --> 00:52:37.156 A:middle
So, please come talk to us.

00:52:38.166 --> 00:52:42.136 A:middle
So, for more information,
please Filip Iliescu

00:52:42.136 --> 00:52:43.556 A:middle
and Allan Schaffer
are evangelists.

00:52:43.636 --> 00:52:45.086 A:middle
Their email addresses are here,

00:52:45.286 --> 00:52:47.826 A:middle
so bug them as much
as you can, okay.

00:52:48.666 --> 00:52:50.266 A:middle
And Jeremy talked
about documentation.

00:52:50.266 --> 00:52:52.456 A:middle
All documentation
for both the API

00:52:52.456 --> 00:52:54.876 A:middle
and the language
are on our website.

00:52:55.376 --> 00:52:58.456 A:middle
Please, you can use the
forums to ask questions.

00:52:58.966 --> 00:53:01.946 A:middle
But actually, there's
one more session.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.966 --> 00:53:01.946 A:middle
But actually, there's
one more session.

00:53:02.266 --> 00:53:06.426 A:middle
The next session covers, goes
into a deeper dive in Metal,

00:53:06.426 --> 00:53:07.046 A:middle
and we're going to talk

00:53:07.046 --> 00:53:09.576 A:middle
about data [inaudible]
computing and tools as well.

00:53:10.236 --> 00:53:11.416 A:middle
The one session I
actually wanted

00:53:11.466 --> 00:53:13.966 A:middle
to highlight was what's new
in the Accelerate Framework.

00:53:13.966 --> 00:53:16.396 A:middle
And it actually happened
yesterday, okay.

00:53:16.726 --> 00:53:18.856 A:middle
But I think this is really
important because we talked

00:53:18.856 --> 00:53:21.546 A:middle
about sharing data structures
between the CPU and the GPU.

00:53:21.866 --> 00:53:24.466 A:middle
So this actually session
talks about the same library.

00:53:24.886 --> 00:53:27.776 A:middle
So definitely go
and listen to it.

00:53:27.776 --> 00:53:28.276 A:middle
And that's it.

00:53:28.666 --> 00:53:29.346 A:middle
Thank you for coming.

