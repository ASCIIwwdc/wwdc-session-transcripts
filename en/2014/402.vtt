WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:12.046 --> 00:00:12.676 A:middle
&gt;&gt; Hello, welcome.

00:00:12.676 --> 00:00:15.866 A:middle
Thanks for joining us for
an introduction to Swift.

00:00:16.276 --> 00:00:18.286 A:middle
Before we get started, I want

00:00:18.286 --> 00:00:19.636 A:middle
to share you a little,
a little fact.

00:00:21.626 --> 00:00:25.056 A:middle
So we announced Swift
yesterday at the keynote and,

00:00:25.666 --> 00:00:26.616 A:middle
as part of the announcement,

00:00:27.276 --> 00:00:29.296 A:middle
we made available to
you this document.

00:00:30.306 --> 00:00:31.966 A:middle
It's the Swift Programming
Language.

00:00:31.966 --> 00:00:34.886 A:middle
It's the guide and reference to
the language and it's available

00:00:34.886 --> 00:00:37.236 A:middle
in the Doc Viewer online but
also in the iBooks Store.

00:00:38.836 --> 00:00:40.296 A:middle
And something really
remarkable happened.

00:00:42.176 --> 00:00:46.346 A:middle
From the time that we made it
available yesterday we've had

00:00:47.426 --> 00:00:49.626 A:middle
370,000 downloads.

00:00:50.436 --> 00:00:51.896 A:middle
So, yes, thank you.

00:00:53.536 --> 00:00:55.036 A:middle
Anyway, this is "Introduction
to Swift".

00:00:55.196 --> 00:00:57.766 A:middle
I am Tim Isted and I'm
joined by Dave Addey.

00:00:59.466 --> 00:01:02.376 A:middle
This is the first of three talks
on the Swift language this,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.466 --> 00:01:02.376 A:middle
This is the first of three talks
on the Swift language this,

00:01:02.376 --> 00:01:04.196 A:middle
at the conference, and
we're focusing today

00:01:04.196 --> 00:01:07.216 A:middle
on a broad overview of the
language, giving you as much

00:01:07.216 --> 00:01:08.976 A:middle
as we can, a few
little teasers of some

00:01:08.976 --> 00:01:10.096 A:middle
of the more advanced features.

00:01:11.356 --> 00:01:13.676 A:middle
Before we get started let's
go back in time a little way,

00:01:15.366 --> 00:01:17.126 A:middle
so many, many decades ago.

00:01:18.366 --> 00:01:20.176 A:middle
This program appeared
and it printed "hello,

00:01:20.176 --> 00:01:21.286 A:middle
world" for the first time.

00:01:22.096 --> 00:01:24.426 A:middle
It is, of course, the
introduction to K&amp;R,

00:01:24.476 --> 00:01:25.616 A:middle
Kernighan and Ritchie's C book.

00:01:26.856 --> 00:01:30.216 A:middle
But many decades, that's quite
a long time in computer terms.

00:01:31.276 --> 00:01:34.866 A:middle
So what's changed in that time?

00:01:35.236 --> 00:01:40.496 A:middle
Ahh. This becomes much shorter
in Swift, yes, thank you.

00:01:41.706 --> 00:01:43.206 A:middle
So, what's happened
in this time?

00:01:43.206 --> 00:01:45.556 A:middle
Well, we've got rid of
the include statement.

00:01:45.556 --> 00:01:46.906 A:middle
There's no need to bring
in the standard library.

00:01:46.906 --> 00:01:47.826 A:middle
It should just be there.

00:01:47.826 --> 00:01:49.376 A:middle
We should just be able to
print and it should just work.

00:01:49.376 --> 00:01:52.046 A:middle
What about Main?

00:01:52.436 --> 00:01:55.346 A:middle
Well, this entire slide,
this single line of code,

00:01:55.346 --> 00:01:57.436 A:middle
that is a complete program
right there and for something

00:01:57.436 --> 00:02:00.266 A:middle
like this we shouldn't need
to have to specify, you know,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:57.436 --> 00:02:00.266 A:middle
like this we shouldn't need
to have to specify, you know,

00:02:00.266 --> 00:02:01.666 A:middle
"This is the entry
point for the app."

00:02:02.296 --> 00:02:02.976 A:middle
So we don't have to.

00:02:04.706 --> 00:02:05.666 A:middle
Because then it's
not a function.

00:02:05.666 --> 00:02:09.425 A:middle
We're not returning any random
values anymore and last,

00:02:09.425 --> 00:02:11.546 A:middle
but not least, no semicolons.

00:02:12.396 --> 00:02:13.316 A:middle
So that's Hello World.

00:02:13.316 --> 00:02:14.136 A:middle
It's a very simple app.

00:02:14.496 --> 00:02:15.206 A:middle
It's a little bit simpler

00:02:15.206 --> 00:02:17.156 A:middle
than what we all
write day in, day out.

00:02:17.156 --> 00:02:19.816 A:middle
So, what are we going
to cover today?

00:02:20.446 --> 00:02:23.366 A:middle
We're going to focus on
syntax in some key areas:

00:02:23.416 --> 00:02:27.486 A:middle
how Swift makes your code safe,
makes it much easier to read,

00:02:27.486 --> 00:02:29.816 A:middle
write, more concise,
look at some

00:02:29.816 --> 00:02:32.646 A:middle
of the modern features we've
introduced and the consistency

00:02:32.646 --> 00:02:36.116 A:middle
between declarations and all
of the syntax that we have and,

00:02:36.116 --> 00:02:39.906 A:middle
of course, how Swift gives
you extra power to do things.

00:02:41.176 --> 00:02:43.156 A:middle
To kick us off I'm going
to hand over to Dave Addey

00:02:43.376 --> 00:02:44.646 A:middle
to take us through the basics.

00:02:44.906 --> 00:02:47.256 A:middle
&gt;&gt; So I'd like to start with
some of the, the fundamentals

00:02:47.256 --> 00:02:48.146 A:middle
of the Swift language.

00:02:48.486 --> 00:02:49.686 A:middle
Let's start with
something really simple.

00:02:49.686 --> 00:02:50.586 A:middle
Let's define a variable.

00:02:51.416 --> 00:02:53.966 A:middle
So we do this with the var
keyword and then the name,

00:02:54.076 --> 00:02:56.926 A:middle
languageName in this case,
and a colon and the type.

00:02:57.556 --> 00:02:59.756 A:middle
And this colon appears
quite often in Swift.

00:02:59.756 --> 00:03:00.816 A:middle
This means, "is of type."


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.756 --> 00:03:00.816 A:middle
This means, "is of type."

00:03:01.436 --> 00:03:02.806 A:middle
So languageName is
a type string.

00:03:03.556 --> 00:03:05.986 A:middle
So we'll give it an initial
string value to start us off.

00:03:07.126 --> 00:03:08.746 A:middle
Now I say initial value

00:03:09.256 --> 00:03:11.336 A:middle
but there's one thing you might
notice about this variable:

00:03:12.396 --> 00:03:14.676 A:middle
it doesn't vary so
there's no real need

00:03:14.676 --> 00:03:15.766 A:middle
for this to be a variable.

00:03:16.516 --> 00:03:18.446 A:middle
Instead, we can define
it as a constant

00:03:18.646 --> 00:03:19.736 A:middle
with a let keyword instead.

00:03:20.676 --> 00:03:22.806 A:middle
And if we introduce a
few more of these things,

00:03:23.266 --> 00:03:26.346 A:middle
let's have the version of the
language: that's a Double, 1.0.

00:03:27.206 --> 00:03:28.806 A:middle
We'll have the year
it was introduced:

00:03:28.806 --> 00:03:30.356 A:middle
that's an integer, 2014.

00:03:30.916 --> 00:03:32.886 A:middle
And the fact that the
language isAwesome?

00:03:33.186 --> 00:03:35.146 A:middle
that's a boolean
and clearly true.

00:03:36.596 --> 00:03:39.166 A:middle
Well, the year the language
was introduced and the fact

00:03:39.166 --> 00:03:42.256 A:middle
that it's awesome, these
also aren't going to change.

00:03:43.826 --> 00:03:45.206 A:middle
So they may as well
also be constant.

00:03:46.136 --> 00:03:48.066 A:middle
And this is a general
principle in Swift,

00:03:48.576 --> 00:03:51.656 A:middle
that we prefer immutability
or constants by default

00:03:51.656 --> 00:03:54.916 A:middle
and only really opt into
mutability or variables

00:03:55.156 --> 00:03:56.556 A:middle
where things actually
need to change.

00:03:57.896 --> 00:03:59.376 A:middle
Now this makes your code safer

00:03:59.376 --> 00:04:00.966 A:middle
in a multi-threaded
environments.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.376 --> 00:04:00.966 A:middle
in a multi-threaded
environments.

00:04:01.476 --> 00:04:03.746 A:middle
It also means that Swift
can optimize your code more

00:04:03.746 --> 00:04:05.956 A:middle
effectively because it knows
what isn't going to change

00:04:06.476 --> 00:04:08.756 A:middle
and it just generally makes
your code more readable,

00:04:08.756 --> 00:04:10.936 A:middle
makes your intent clearer
that you're saying what is

00:04:10.936 --> 00:04:13.286 A:middle
and isn't going to vary.

00:04:13.516 --> 00:04:15.766 A:middle
So here I created
a string, a double,

00:04:15.896 --> 00:04:17.086 A:middle
an integer and a Boolean.

00:04:17.396 --> 00:04:19.086 A:middle
And it's pretty obvious
from these values

00:04:19.086 --> 00:04:21.185 A:middle
on the right-hand side what
it is that I want to create.

00:04:21.836 --> 00:04:24.976 A:middle
In fact, it's so
obvious from the values

00:04:24.976 --> 00:04:26.876 A:middle
on the right hand side that
there's really no point

00:04:26.876 --> 00:04:27.766 A:middle
in me writing the types.

00:04:27.766 --> 00:04:31.076 A:middle
And in Swift, in many
cases, you don't need to.

00:04:31.416 --> 00:04:33.956 A:middle
Swift uses type inference
to look at the values

00:04:33.956 --> 00:04:36.146 A:middle
on the right-hand side that
we've assigned and work

00:04:36.146 --> 00:04:37.716 A:middle
out what type these
things should be.

00:04:38.266 --> 00:04:40.206 A:middle
Now this is, this makes code
safe without the effort.

00:04:40.286 --> 00:04:41.726 A:middle
This means all these constants

00:04:41.726 --> 00:04:45.086 A:middle
and variables are explicitly
typed but you don't have

00:04:45.086 --> 00:04:48.966 A:middle
to write a ton of code to
get those types in place.

00:04:49.166 --> 00:04:52.016 A:middle
One more thing on constants
and variables before we move on

00:04:52.016 --> 00:04:55.466 A:middle
and that's that you can
use pretty much any Unicode

00:04:55.506 --> 00:04:57.056 A:middle
character you like
for your constant

00:04:57.056 --> 00:04:58.646 A:middle
and variable names,
such as pi here.

00:04:59.796 --> 00:05:03.236 A:middle
And, yes, [applause]
that does include emojis.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.796 --> 00:05:03.236 A:middle
And, yes, [applause]
that does include emojis.

00:05:04.096 --> 00:05:05.566 A:middle
This is the stuff that
matters, seriously [laughter].

00:05:08.046 --> 00:05:09.266 A:middle
So that's some of the basics.

00:05:09.816 --> 00:05:12.396 A:middle
Talking of Unicode we
also have a modern,

00:05:12.396 --> 00:05:14.756 A:middle
fast Unicode string
implementation called,

00:05:14.936 --> 00:05:17.556 A:middle
suitably enough, String
and as we just saw

00:05:17.746 --> 00:05:20.326 A:middle
if you're initializing a
string from string literal,

00:05:20.326 --> 00:05:22.916 A:middle
as we are here, Swift
infers the times for you.

00:05:22.916 --> 00:05:24.386 A:middle
It's clear you want
this to be a string.

00:05:25.866 --> 00:05:29.136 A:middle
Now, Swift's string
syntax is very lightweight.

00:05:29.136 --> 00:05:31.746 A:middle
It looks a lot like a C
string but it's as powerful

00:05:31.886 --> 00:05:34.266 A:middle
as NSString and,
indeed, if you're working

00:05:34.266 --> 00:05:37.716 A:middle
with foundation you can use a
Swift string anywhere you would

00:05:37.716 --> 00:05:38.706 A:middle
use an NSString.

00:05:38.936 --> 00:05:42.016 A:middle
So here we're setting
the HTTP method property

00:05:42.016 --> 00:05:44.246 A:middle
of an NSURL request
using a Swift string.

00:05:45.496 --> 00:05:46.726 A:middle
Moreover, if you're working

00:05:46.726 --> 00:05:50.466 A:middle
with Foundation you have the
entire NSString API available

00:05:50.466 --> 00:05:52.406 A:middle
to you on any Swift
string you create.

00:05:52.876 --> 00:05:55.026 A:middle
So we can call the
pathComponents property

00:05:55.026 --> 00:05:57.846 A:middle
on this string and get back an
Array of the components therein.

00:05:59.506 --> 00:06:02.166 A:middle
Now every Swift string is
a collection of characters


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.506 --> 00:06:02.166 A:middle
Now every Swift string is
a collection of characters

00:06:02.166 --> 00:06:06.146 A:middle
and you can use a for-in loop
to iterate over those characters

00:06:06.406 --> 00:06:09.046 A:middle
such as here, we're printing
the five characters in the word

00:06:09.046 --> 00:06:10.326 A:middle
"mouse" on five lines.

00:06:11.806 --> 00:06:15.876 A:middle
This works just as well in
English as it does in Icelandic

00:06:16.796 --> 00:06:21.916 A:middle
or Russian or Chinese
and even with emoji.

00:06:22.906 --> 00:06:26.216 A:middle
So if you want to create a
character, you can do so just

00:06:26.216 --> 00:06:29.496 A:middle
by assigning a character
annotation to the string,

00:06:29.496 --> 00:06:31.196 A:middle
the string literal
that you've assigned.

00:06:31.546 --> 00:06:33.806 A:middle
This says we want this string,
that we want this string literal

00:06:33.806 --> 00:06:35.016 A:middle
to be a character not a string.

00:06:36.096 --> 00:06:39.366 A:middle
If you want to add together two
characters you could do so just

00:06:39.366 --> 00:06:42.726 A:middle
with addition and this goes for
two characters making a string,

00:06:43.056 --> 00:06:44.086 A:middle
it goes for strings

00:06:44.086 --> 00:06:46.176 A:middle
and characters making longer
strings, likewise 2 strings.

00:06:47.736 --> 00:06:50.256 A:middle
But sometimes we want to
make more complex strings

00:06:50.556 --> 00:06:53.116 A:middle
than just addition,
so let's say we want

00:06:53.116 --> 00:06:56.616 A:middle
to take these 2 constants,
a and b, which are inferred

00:06:56.616 --> 00:06:58.986 A:middle
to be integers from these
default values of 3 and 5,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:00.366 --> 00:07:04.226 A:middle
and we'd like to make this
string, "3 times 5 is 15"

00:07:05.056 --> 00:07:07.136 A:middle
but in a way that would
work for any values of a

00:07:07.136 --> 00:07:09.806 A:middle
and b that we pass in.

00:07:09.956 --> 00:07:11.976 A:middle
Now Swift has a really
elegant way to do this,

00:07:11.976 --> 00:07:13.976 A:middle
a really powerful way
of writing these kind

00:07:13.976 --> 00:07:16.826 A:middle
of more complex strings,
known as string interpolation

00:07:17.006 --> 00:07:17.796 A:middle
and this is how it looks.

00:07:17.866 --> 00:07:22.426 A:middle
And we can insert constants and
variables and even expressions

00:07:22.756 --> 00:07:25.046 A:middle
such as "3 times
5" here directly

00:07:25.046 --> 00:07:27.656 A:middle
within a string literal just by
wrapping them in parentheses,

00:07:28.016 --> 00:07:31.106 A:middle
escape with a backslash and it's
really clear what this string

00:07:31.106 --> 00:07:33.336 A:middle
interpolation will make
when it's evaluated.

00:07:33.866 --> 00:07:35.296 A:middle
It makes exactly the
string we'd expect.

00:07:36.106 --> 00:07:38.266 A:middle
And this works with
any value of a and b.

00:07:40.626 --> 00:07:43.596 A:middle
Now you might be wondering
does Swift have a mutable

00:07:43.596 --> 00:07:44.376 A:middle
string type?

00:07:45.636 --> 00:07:47.426 A:middle
And the answer is actually
it doesn't need one.

00:07:48.346 --> 00:07:51.696 A:middle
Instead, string mutability is a
case of working with a variable,

00:07:52.216 --> 00:07:53.846 A:middle
in which case the
string can change,

00:07:53.976 --> 00:07:57.496 A:middle
such as adding another string
on the end or, alternatively,

00:07:57.606 --> 00:07:58.566 A:middle
working with the constant

00:07:59.086 --> 00:08:00.756 A:middle
in which case the
string can't change.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.086 --> 00:08:00.756 A:middle
in which case the
string can't change.

00:08:01.806 --> 00:08:04.086 A:middle
It's actually a compile
time error to try

00:08:04.086 --> 00:08:05.946 A:middle
and add another string
onto this constantString.

00:08:07.956 --> 00:08:08.486 A:middle
So that's string.

00:08:08.626 --> 00:08:09.236 A:middle
What else do we have?

00:08:10.576 --> 00:08:13.836 A:middle
Well, we have collection times,
Array and Dictionary and,

00:08:13.836 --> 00:08:16.356 A:middle
in the same way we saw,
you can use a Swift string

00:08:16.356 --> 00:08:18.716 A:middle
and an NSString interchangeably
with APIs.

00:08:19.276 --> 00:08:21.936 A:middle
You can use an Array anywhere
that takes an NSArray,

00:08:22.386 --> 00:08:24.566 A:middle
and a Dictionary anywhere
that takes an NSDictionary.

00:08:25.366 --> 00:08:27.596 A:middle
In fact, earlier on when we
called the pathComponents

00:08:27.596 --> 00:08:31.036 A:middle
property on our Swift string
what we got back was actually an

00:08:31.036 --> 00:08:34.666 A:middle
Array not an NSArray even
though the API here is defined

00:08:34.666 --> 00:08:35.476 A:middle
to return an NSArray.

00:08:36.126 --> 00:08:40.366 A:middle
Now the easiest way to create a
new collection is with a literal

00:08:40.785 --> 00:08:42.056 A:middle
and Array and Dictionary
literals

00:08:42.056 --> 00:08:44.246 A:middle
in Swift are very
familiar from Objective-C.

00:08:45.056 --> 00:08:47.406 A:middle
Arrays are just square
brackets around the edge,

00:08:47.626 --> 00:08:48.506 A:middle
commas between the items.

00:08:48.956 --> 00:08:51.656 A:middle
Here we have an Array of four
string values, four names.

00:08:53.446 --> 00:08:55.246 A:middle
Dictionary literals,
also very familiar,

00:08:55.576 --> 00:08:57.096 A:middle
colons between the
keys and values,

00:08:57.246 --> 00:08:58.526 A:middle
commas between the
key value pairs,

00:08:58.766 --> 00:08:59.646 A:middle
square brackets around the edge.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.596 --> 00:09:02.976 A:middle
Here we have keys,
which are strings,

00:09:03.146 --> 00:09:05.826 A:middle
the names of some animals,
and integer values,

00:09:05.926 --> 00:09:09.206 A:middle
the numbers of legs
that those animals have.

00:09:09.346 --> 00:09:11.876 A:middle
So these literals are
very familiar but Array

00:09:11.876 --> 00:09:15.076 A:middle
and Dictionary actually have 2
things that are quite different

00:09:15.336 --> 00:09:17.146 A:middle
from NSArray and NSDictionary.

00:09:18.446 --> 00:09:20.266 A:middle
The first is they can
work with any type.

00:09:20.946 --> 00:09:23.826 A:middle
Here we have strings and
integers in our collections.

00:09:24.216 --> 00:09:25.356 A:middle
They don't have to be objects.

00:09:25.516 --> 00:09:27.286 A:middle
They don't have to
be a Class type.

00:09:27.996 --> 00:09:30.476 A:middle
The second difference
is that in Swift,

00:09:30.846 --> 00:09:32.706 A:middle
collections are types
collections.

00:09:33.026 --> 00:09:33.806 A:middle
Let's see what that means.

00:09:35.036 --> 00:09:38.026 A:middle
So here's our Array of names and
it's an Array of four strings.

00:09:38.026 --> 00:09:42.306 A:middle
Now, it's pretty clear from
looking at this Array of names

00:09:42.786 --> 00:09:45.676 A:middle
that it would be odd to add
an integer into this Array or,

00:09:45.746 --> 00:09:48.566 A:middle
or a Boolean value,
or a bicycle.

00:09:49.056 --> 00:09:49.836 A:middle
That would be just odd.

00:09:51.176 --> 00:09:53.086 A:middle
An Array of names
should always be strings.

00:09:54.076 --> 00:09:55.686 A:middle
So it would be nice
to have a way to say

00:09:55.946 --> 00:09:59.976 A:middle
that it can only always be
strings and in Swift we can.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:00.046 --> 00:10:01.026 A:middle
We can provide a
type annotation.

00:10:01.276 --> 00:10:03.266 A:middle
This is how we write
an Array of strings.

00:10:03.396 --> 00:10:04.676 A:middle
String followed by
two square brackets,

00:10:05.596 --> 00:10:07.236 A:middle
and then we can only put
strings in this Array.

00:10:08.936 --> 00:10:09.546 A:middle
But from the thing

00:10:09.546 --> 00:10:12.396 A:middle
on the right-hand side
here it's pretty clear

00:10:12.536 --> 00:10:14.526 A:middle
that we want an Array of
strings just from looking

00:10:14.526 --> 00:10:17.886 A:middle
at this literal, and so
if we initialize an Array

00:10:17.886 --> 00:10:20.356 A:middle
in this way we actually
don't need to write the type.

00:10:20.916 --> 00:10:24.226 A:middle
Swift can infer it for us and we
still end up with a typed Array.

00:10:25.626 --> 00:10:26.796 A:middle
The same goes for dictionaries.

00:10:27.286 --> 00:10:30.276 A:middle
Here it's clear we want
string keys, integer values,

00:10:30.276 --> 00:10:33.876 A:middle
and Swift can infer this
type for us as well.

00:10:34.546 --> 00:10:39.696 A:middle
This, the fact that we have
typed collections makes code

00:10:39.846 --> 00:10:41.096 A:middle
safe for two reasons.

00:10:41.856 --> 00:10:44.086 A:middle
Firstly, it means you know
what you're going to get back.

00:10:44.476 --> 00:10:46.346 A:middle
You now what you'll get
out of these collections.

00:10:47.296 --> 00:10:49.896 A:middle
It also means that you
can't insert the wrong kinds

00:10:49.896 --> 00:10:50.696 A:middle
of things by mistake.

00:10:51.116 --> 00:10:53.296 A:middle
It's actually an error to, to
insert the wrong kinds of things

00:10:53.296 --> 00:10:57.076 A:middle
into these Arrays and
these Dictionaries.

00:10:57.076 --> 00:10:58.386 A:middle
So, having defined
our collections,

00:10:58.866 --> 00:11:00.906 A:middle
it would now be useful
to loop over them,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:58.866 --> 00:11:00.906 A:middle
it would now be useful
to loop over them,

00:11:00.906 --> 00:11:02.076 A:middle
to iterate over their values.

00:11:02.496 --> 00:11:05.326 A:middle
And we have all the loops
you'll be familiar with from C.

00:11:05.996 --> 00:11:08.076 A:middle
We have while loops, do
while loops, and for loops.

00:11:09.196 --> 00:11:11.906 A:middle
And as we saw earlier, we
also have the for-in loop,

00:11:11.996 --> 00:11:13.766 A:middle
which we use with
strings and characters

00:11:14.666 --> 00:11:16.546 A:middle
but it's a bit more
powerful than just strings.

00:11:16.546 --> 00:11:17.956 A:middle
We can use it for a few
more things than that.

00:11:19.166 --> 00:11:20.446 A:middle
We can use it with ranges.

00:11:20.996 --> 00:11:22.476 A:middle
This is a way to write a range

00:11:22.666 --> 00:11:24.196 A:middle
that includes the
numbers at both ends.

00:11:24.196 --> 00:11:24.996 A:middle
Here it's 1...5.

00:11:25.166 --> 00:11:29.846 A:middle
That's known as a closed range
because it includes both one

00:11:29.846 --> 00:11:30.766 A:middle
and five in that range.

00:11:31.396 --> 00:11:33.056 A:middle
Here, we're just printing
the first five items

00:11:33.296 --> 00:11:35.776 A:middle
in the four times table.

00:11:35.996 --> 00:11:39.156 A:middle
Sometimes, however, we want
to arrange the start at zero

00:11:39.406 --> 00:11:41.706 A:middle
and count up to but not
including the final value.

00:11:42.126 --> 00:11:43.466 A:middle
We have a way to
write that as well,

00:11:43.806 --> 00:11:45.256 A:middle
just using two dots
rather than three.

00:11:45.826 --> 00:11:48.876 A:middle
So this counts from zero to
five but not including five.

00:11:48.876 --> 00:11:50.286 A:middle
It's known as a half
closed range.

00:11:50.286 --> 00:11:52.146 A:middle
It includes the value
at the beginning

00:11:52.146 --> 00:11:53.066 A:middle
but not the one at the end.

00:11:54.936 --> 00:11:58.906 A:middle
We can use for-in with an Array
so to print a nice welcome

00:11:58.906 --> 00:12:00.536 A:middle
to the four people
in our names Array,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.906 --> 00:12:00.536 A:middle
to the four people
in our names Array,

00:12:01.386 --> 00:12:02.946 A:middle
and we can even use
it with Dictionary.

00:12:03.506 --> 00:12:06.906 A:middle
Now note here that we're
extracting the key and the value

00:12:06.906 --> 00:12:09.706 A:middle
at the same time in
a single for-in loop.

00:12:10.266 --> 00:12:12.246 A:middle
This makes for much
more expressive code

00:12:12.246 --> 00:12:13.536 A:middle
when working with dictionaries.

00:12:15.266 --> 00:12:18.516 A:middle
Now this combination of key
and value wrapped together

00:12:18.516 --> 00:12:20.366 A:middle
in parentheses is an example

00:12:20.366 --> 00:12:21.926 A:middle
of a Swift feature
known as a tuple.

00:12:21.926 --> 00:12:25.026 A:middle
And these are groupings
of values grouped together

00:12:25.026 --> 00:12:26.756 A:middle
as a single, compound value

00:12:26.756 --> 00:12:28.236 A:middle
that you can pass
around in your code.

00:12:28.236 --> 00:12:31.426 A:middle
And we'll come back to tuples
later in the session to see

00:12:31.426 --> 00:12:32.316 A:middle
where else they can be useful.

00:12:33.686 --> 00:12:35.906 A:middle
So that's how we
create collections

00:12:35.906 --> 00:12:36.746 A:middle
and how we iterate them.

00:12:37.066 --> 00:12:39.046 A:middle
How do we modify them?

00:12:39.046 --> 00:12:39.976 A:middle
Well, let's start with an Array.

00:12:40.256 --> 00:12:43.486 A:middle
Here's a shopping list,
contains 2 items, eggs and milk.

00:12:44.946 --> 00:12:47.266 A:middle
As in Objective-C we can
access the first item

00:12:47.266 --> 00:12:48.926 A:middle
in the Array just
using subscripting.

00:12:49.246 --> 00:12:50.456 A:middle
Here we're extracting eggs.

00:12:52.026 --> 00:12:55.126 A:middle
If we want to add an item to the
Array, we literally just add it

00:12:55.126 --> 00:12:56.376 A:middle
to the Array, we
add it to the end.

00:12:56.696 --> 00:12:58.056 A:middle
Here we're adding a
third item, flour.

00:12:59.326 --> 00:13:02.426 A:middle
We can also add multiple
items in one go just


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.326 --> 00:13:02.426 A:middle
We can also add multiple
items in one go just

00:13:02.426 --> 00:13:03.646 A:middle
by adding a compatible Array.

00:13:03.916 --> 00:13:04.996 A:middle
Here we're adding cheese,

00:13:05.176 --> 00:13:06.766 A:middle
butter and chocolate
spread to our list.

00:13:08.196 --> 00:13:10.296 A:middle
If we want to change a
value subscripting again;

00:13:10.456 --> 00:13:12.526 A:middle
we just assign a new value
for an existing Array.

00:13:12.886 --> 00:13:14.616 A:middle
Here we're changing
eggs to be six eggs.

00:13:16.356 --> 00:13:18.796 A:middle
And if we, if we want to make
our shopping list a little bit

00:13:18.796 --> 00:13:19.416 A:middle
healthier perhaps,

00:13:20.326 --> 00:13:22.656 A:middle
we can actually replace
an entire range in one go.

00:13:23.216 --> 00:13:26.066 A:middle
So we can replace items three
through five, that's the cheese,

00:13:26.266 --> 00:13:27.346 A:middle
the butter and the
chocolate spread

00:13:27.346 --> 00:13:29.176 A:middle
with some bananas
and apples instead.

00:13:30.576 --> 00:13:31.836 A:middle
So that's, that's Arrays.

00:13:31.836 --> 00:13:32.736 A:middle
What about Dictionaries?

00:13:33.106 --> 00:13:34.576 A:middle
Well, we can modify.

00:13:34.576 --> 00:13:35.726 A:middle
Here's our Dictionary
from earlier.

00:13:35.726 --> 00:13:38.046 A:middle
We have three key value
pairs for animals and legs.

00:13:38.986 --> 00:13:40.806 A:middle
And so we start off
with three but we want

00:13:40.806 --> 00:13:42.406 A:middle
to add a new animal
to this Array.

00:13:43.326 --> 00:13:45.536 A:middle
This is as easy as just
assigning a new value

00:13:45.646 --> 00:13:47.566 A:middle
for a key that's not
already in the Dictionary.

00:13:48.056 --> 00:13:51.536 A:middle
Here we're adding the fact
that spiders have 273 legs.

00:13:52.556 --> 00:13:53.236 A:middle
But there's a problem.

00:13:54.426 --> 00:13:57.116 A:middle
Spiders do not have 273 legs.

00:13:57.916 --> 00:13:58.946 A:middle
If you find one that does,

00:13:59.156 --> 00:14:02.546 A:middle
run away [laughter] although
be warned it will probably


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.156 --> 00:14:02.546 A:middle
run away [laughter] although
be warned it will probably

00:14:02.546 --> 00:14:02.856 A:middle
catch you.

00:14:04.066 --> 00:14:04.996 A:middle
But this is not a problem.

00:14:04.996 --> 00:14:05.626 A:middle
We can fix it.

00:14:06.166 --> 00:14:08.686 A:middle
We can just assign a new
value for an existing key

00:14:08.846 --> 00:14:10.306 A:middle
and change the value
in the Dictionary.

00:14:10.306 --> 00:14:11.226 A:middle
Spiders now have eight legs.

00:14:13.216 --> 00:14:14.866 A:middle
So that's how to
modify a Dictionary.

00:14:15.106 --> 00:14:16.116 A:middle
But what, what if we want

00:14:16.116 --> 00:14:18.086 A:middle
to retrieve a value
from this Dictionary?

00:14:19.246 --> 00:14:21.936 A:middle
What if we want to see if our
Dictionary contains the number

00:14:21.936 --> 00:14:25.536 A:middle
of legs for an aardvark, or
perhaps the number of legs

00:14:25.786 --> 00:14:28.606 A:middle
for a dugong, or maybe
the number of legs

00:14:28.606 --> 00:14:30.166 A:middle
for a Venezuelan poodle moth?

00:14:31.876 --> 00:14:34.056 A:middle
Well, our Dictionary might
contain the number of legs

00:14:34.056 --> 00:14:35.786 A:middle
for these animals
but it might not.

00:14:36.226 --> 00:14:37.336 A:middle
There might be no value at all

00:14:37.336 --> 00:14:39.686 A:middle
and we need a way
to model this fact.

00:14:40.726 --> 00:14:42.126 A:middle
And this is a really
good use case

00:14:42.126 --> 00:14:45.216 A:middle
for a really powerful feature
in Swift known as optionals.

00:14:45.696 --> 00:14:48.256 A:middle
I'd like to invite Tim back up
to tell you more about optionals

00:14:48.256 --> 00:14:49.366 A:middle
and some other power features

00:14:49.606 --> 00:14:50.676 A:middle
that take us beyond
the basics [applause].

00:14:51.256 --> 00:14:51.746 A:middle
&gt;&gt; Thank you, Dave.

00:14:52.056 --> 00:14:54.856 A:middle
So, I'd love to use Venezuelan
poodle moths as my examples

00:14:54.856 --> 00:14:56.516 A:middle
but I actually find that
quite hard to say so I'm going

00:14:56.516 --> 00:14:57.576 A:middle
to stick with aardvark.

00:14:59.336 --> 00:15:00.676 A:middle
How do we get the
number of legs out?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.336 --> 00:15:00.676 A:middle
How do we get the
number of legs out?

00:15:00.676 --> 00:15:02.426 A:middle
Well, we can subscript
and we can query this

00:15:02.546 --> 00:15:03.666 A:middle
but what should we get back?

00:15:05.156 --> 00:15:07.856 A:middle
Well, we kind of want to be able
to get two types of thing back.

00:15:07.976 --> 00:15:10.126 A:middle
We either want the number
of legs as an integer

00:15:10.126 --> 00:15:12.856 A:middle
or we want something that
says this value wasn't found.

00:15:12.996 --> 00:15:13.956 A:middle
So, that's something else.

00:15:15.216 --> 00:15:17.156 A:middle
We could use some magic
integer value like,

00:15:17.156 --> 00:15:18.156 A:middle
I don't know, zero perhaps.

00:15:18.446 --> 00:15:20.186 A:middle
But the zero is a
possible value here;

00:15:20.306 --> 00:15:21.316 A:middle
snakes don't have any legs.

00:15:21.886 --> 00:15:22.686 A:middle
So we can't use zero.

00:15:23.756 --> 00:15:26.526 A:middle
In Objective-C you might be used
to using things like NSNotFound

00:15:26.526 --> 00:15:29.166 A:middle
or minus one and, you know,
we could use minus one here.

00:15:29.166 --> 00:15:31.446 A:middle
As far as I know it's not
possible to have minus one legs

00:15:32.206 --> 00:15:35.366 A:middle
but we could be using an example
where minus one was some kind

00:15:35.366 --> 00:15:36.166 A:middle
of value we wanted back.

00:15:36.976 --> 00:15:40.086 A:middle
So wouldn't it be great if we
could use some kind of value

00:15:40.086 --> 00:15:42.056 A:middle
that didn't take up one
of the possible integers?

00:15:43.236 --> 00:15:43.766 A:middle
Well, yes.

00:15:43.766 --> 00:15:45.276 A:middle
In Swift we did this
with an optional.

00:15:46.326 --> 00:15:49.596 A:middle
It's an optional integer,
indicated here by "Int?"

00:15:49.596 --> 00:15:52.826 A:middle
It means that we either
get an integer back

00:15:52.996 --> 00:15:55.276 A:middle
or we get nothing at all.

00:15:56.446 --> 00:15:57.566 A:middle
So what does nothing
at all mean?

00:15:58.696 --> 00:16:00.766 A:middle
Well, nothing in Swift
is represented by nil.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.696 --> 00:16:00.766 A:middle
Well, nothing in Swift
is represented by nil.

00:16:00.766 --> 00:16:02.096 A:middle
It's very different

00:16:02.096 --> 00:16:03.946 A:middle
to Objective-C nil,
it means nothing.

00:16:03.946 --> 00:16:06.246 A:middle
It means no value at all
in some optional value.

00:16:06.246 --> 00:16:11.246 A:middle
So we can test to see if this
possible leg count is nil,

00:16:11.246 --> 00:16:12.656 A:middle
to see whether the
animal was found

00:16:12.656 --> 00:16:15.576 A:middle
and if it is nil then
the animal was not found.

00:16:15.926 --> 00:16:17.166 A:middle
What if it had been found?

00:16:17.806 --> 00:16:18.796 A:middle
How would we get this value out?

00:16:18.796 --> 00:16:20.236 A:middle
How do we get that
integer out of the,

00:16:20.276 --> 00:16:21.176 A:middle
out of the optional integer?

00:16:22.566 --> 00:16:25.516 A:middle
We would, we use that by, we do
that by forcing the value out,

00:16:25.516 --> 00:16:26.756 A:middle
using the unwrap operator.

00:16:26.756 --> 00:16:28.096 A:middle
That's the exclamation
mark here.

00:16:29.166 --> 00:16:31.536 A:middle
So what I'm saying is I'm saying
set the constant leg count

00:16:32.246 --> 00:16:34.626 A:middle
to the underlying value
inside possible leg count.

00:16:34.976 --> 00:16:36.836 A:middle
That's what that
unwrap operator does.

00:16:37.296 --> 00:16:41.026 A:middle
Notice I'm not specifying
a type of leg count here.

00:16:41.136 --> 00:16:43.516 A:middle
I don't need to because
this is an optional Int.

00:16:43.646 --> 00:16:45.156 A:middle
The compiler knows that
it's an optional Int

00:16:45.156 --> 00:16:47.996 A:middle
and when I'm forcing that value
out I get the underlying Int

00:16:48.076 --> 00:16:49.876 A:middle
so leg count here is an integer.

00:16:52.496 --> 00:16:54.926 A:middle
Now I said forcing,
forcing the value

00:16:54.926 --> 00:16:55.866 A:middle
out when we're unwrapping it.

00:16:56.066 --> 00:16:56.886 A:middle
Why am I using that word?

00:16:56.916 --> 00:16:59.156 A:middle
Well, I am forcing
the value out.

00:16:59.966 --> 00:17:02.666 A:middle
If I try and unwrap an
optional and there's,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.966 --> 00:17:02.666 A:middle
If I try and unwrap an
optional and there's,

00:17:02.666 --> 00:17:04.296 A:middle
in fact that there's no
value there, it's nil,

00:17:04.945 --> 00:17:05.876 A:middle
I'll trigger an assertion.

00:17:06.215 --> 00:17:08.046 A:middle
So I should only do this
when I know for sure

00:17:08.046 --> 00:17:09.915 A:middle
that the value is there.

00:17:09.915 --> 00:17:12.266 A:middle
Because of this, there's a
very common pattern in Swift,

00:17:12.266 --> 00:17:15.195 A:middle
which is to say, is there a
value in this optional thing?

00:17:15.796 --> 00:17:17.246 A:middle
If there is, then unwrap it,

00:17:17.246 --> 00:17:18.675 A:middle
give me the value
back so I can use it.

00:17:19.455 --> 00:17:21.965 A:middle
So common, in fact, that
we have a special syntax

00:17:21.965 --> 00:17:22.896 A:middle
for this that's much safer.

00:17:22.896 --> 00:17:26.126 A:middle
It bundles those two steps
into, into a single step.

00:17:26.986 --> 00:17:30.216 A:middle
And what this does is it says if
possible leg count has a value,

00:17:30.886 --> 00:17:33.036 A:middle
unwrap it, give it back
to the leg count constant

00:17:33.036 --> 00:17:34.346 A:middle
and then I can use it
in the block of code.

00:17:34.866 --> 00:17:37.346 A:middle
If there is no value,
block of code is skipped.

00:17:38.456 --> 00:17:42.066 A:middle
So we've seen a number of
examples of if statements so far

00:17:42.066 --> 00:17:43.466 A:middle
and if statements
in Swift look much

00:17:43.466 --> 00:17:44.556 A:middle
like they do in other languages.

00:17:45.566 --> 00:17:46.996 A:middle
There's one exception
though and that is

00:17:46.996 --> 00:17:48.276 A:middle
that there are no
parentheses here.

00:17:49.116 --> 00:17:50.606 A:middle
We can use parentheses
if we like,

00:17:50.606 --> 00:17:52.116 A:middle
but they're actually optional.

00:17:52.366 --> 00:17:56.796 A:middle
So in this case they just add
unnecessary punctuation noise

00:17:57.086 --> 00:17:57.876 A:middle
so I'm going to leave them out.

00:17:59.206 --> 00:18:01.696 A:middle
The braces though, braces
are required [applause].


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.206 --> 00:18:01.696 A:middle
The braces though, braces
are required [applause].

00:18:02.236 --> 00:18:04.096 A:middle
And, as I can hear from
that, you're acknowledging

00:18:04.096 --> 00:18:06.166 A:middle
that this gets rid of a whole
chain of bugs that happens

00:18:06.166 --> 00:18:08.006 A:middle
with nested ifs,
sorry trailing ifs.

00:18:08.096 --> 00:18:11.106 A:middle
That, you know, "if you
have that" if statement

00:18:11.106 --> 00:18:12.506 A:middle
and then two lines of code

00:18:12.506 --> 00:18:14.276 A:middle
and you've indented
them correctly but, uh,

00:18:14.676 --> 00:18:16.246 A:middle
the second one is
still going to happen.

00:18:16.246 --> 00:18:16.696 A:middle
That's bad.

00:18:16.696 --> 00:18:18.776 A:middle
It cannot happen in Swift,
we have braces for that.

00:18:18.776 --> 00:18:19.386 A:middle
They're required.

00:18:20.886 --> 00:18:23.026 A:middle
So we can do more complex things
with if statements of course.

00:18:23.026 --> 00:18:24.176 A:middle
We can have an else if in there.

00:18:24.176 --> 00:18:28.096 A:middle
But in this case I'm matching,
I'm matching multiple values.

00:18:28.096 --> 00:18:30.786 A:middle
I'm saying if leg count
is zero then I'm printing

00:18:30.786 --> 00:18:32.586 A:middle
on my animal slithers
and slides around.

00:18:33.366 --> 00:18:35.176 A:middle
Otherwise, if it's one
maybe it hops around.

00:18:35.446 --> 00:18:36.286 A:middle
Otherwise, it walks.

00:18:36.286 --> 00:18:38.706 A:middle
So I'm matching this,
this leg count

00:18:38.706 --> 00:18:40.306 A:middle
against multiple
possible values.

00:18:41.196 --> 00:18:43.216 A:middle
Really I should be using switch.

00:18:44.606 --> 00:18:46.786 A:middle
Now switch in Swift-try
saying that,

00:18:46.886 --> 00:18:49.446 A:middle
saying that three times-is
the most powerful of all

00:18:49.446 --> 00:18:50.486 A:middle
of our control flow statements.

00:18:51.266 --> 00:18:52.356 A:middle
But let's start with the basics.

00:18:52.766 --> 00:18:54.246 A:middle
Starting with leg
count, switching on that

00:18:54.386 --> 00:18:56.616 A:middle
and I'm using case to
indicate the possible values.

00:18:57.046 --> 00:18:58.966 A:middle
Value 0 slithers
and slides; case 1,

00:18:58.966 --> 00:19:00.256 A:middle
it hops; otherwise, it walks.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.966 --> 00:19:00.256 A:middle
it hops; otherwise, it walks.

00:19:00.256 --> 00:19:03.486 A:middle
So use case like you do
in C and Objective-C.

00:19:04.296 --> 00:19:06.476 A:middle
Notice I'm not specifying
break here.

00:19:07.306 --> 00:19:10.706 A:middle
Cases in Swift do not
automatically fall through.

00:19:11.496 --> 00:19:14.906 A:middle
I'm also not limited to just
matching against integer values.

00:19:15.716 --> 00:19:17.616 A:middle
In Swift I can match
against objects

00:19:17.616 --> 00:19:18.646 A:middle
or read any values I like.

00:19:19.136 --> 00:19:22.416 A:middle
Imagine this is an ID action
method and I'm tracking which,

00:19:22.416 --> 00:19:24.286 A:middle
which object the user
has interacted with.

00:19:24.286 --> 00:19:25.976 A:middle
So I can switch on the
sender and match it

00:19:25.976 --> 00:19:28.176 A:middle
against different outlets and
print the suitable message.

00:19:28.316 --> 00:19:29.246 A:middle
So I can match an object.

00:19:30.276 --> 00:19:31.616 A:middle
Let's go back to
integers for a moment.

00:19:32.126 --> 00:19:33.896 A:middle
And in Swift I can be
much more expressive.

00:19:34.516 --> 00:19:36.686 A:middle
So here I'm matching multiple
values in a single case

00:19:36.686 --> 00:19:39.506 A:middle
at a time, of numbers between
1 and 13, animal limps,

00:19:41.086 --> 00:19:43.006 A:middle
even numbers between
2 and 14, it walks.

00:19:43.766 --> 00:19:45.396 A:middle
That's nice, very expressive,

00:19:45.396 --> 00:19:46.936 A:middle
but there's a problem
with this example.

00:19:47.616 --> 00:19:51.536 A:middle
If I try and compile this, I'll
get an error and the error says,

00:19:51.716 --> 00:19:54.226 A:middle
"Switch must be exhaustive."

00:19:55.236 --> 00:19:58.586 A:middle
In Swift you must include
a case or a default

00:19:58.656 --> 00:20:01.186 A:middle
for every possible value that,
that could be matched against.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.656 --> 00:20:01.186 A:middle
for every possible value that,
that could be matched against.

00:20:01.346 --> 00:20:05.176 A:middle
So the easiest way to do that
is to supply default case.

00:20:05.996 --> 00:20:08.626 A:middle
And the reason for this is it,
again, makes your code safer.

00:20:09.426 --> 00:20:11.886 A:middle
Imagine you're writing something
that uses a state machine

00:20:11.996 --> 00:20:13.816 A:middle
and you have a big switch
statement in the middle

00:20:14.066 --> 00:20:15.246 A:middle
and you forget one of the cases.

00:20:15.906 --> 00:20:18.436 A:middle
Well, then your state machine
grinds to a halt and that's bad.

00:20:18.466 --> 00:20:19.406 A:middle
That cannot happen in Swift.

00:20:19.556 --> 00:20:21.236 A:middle
You must have an
exhaustive switch,

00:20:21.236 --> 00:20:23.426 A:middle
which means either a case
for every value or a default.

00:20:24.716 --> 00:20:26.936 A:middle
So we've matched against
individual values here.

00:20:28.076 --> 00:20:30.776 A:middle
But, what if I might want
to match against a lot of,

00:20:30.776 --> 00:20:32.416 A:middle
a lot of values, a
big range of values?

00:20:32.726 --> 00:20:34.266 A:middle
Well, I can do just that.

00:20:34.266 --> 00:20:35.896 A:middle
I can match against a range.

00:20:36.326 --> 00:20:38.306 A:middle
So this is bringing in pattern
matching now a little bit.

00:20:38.696 --> 00:20:40.186 A:middle
So here we have zero
still, no legs.

00:20:40.356 --> 00:20:42.036 A:middle
One to eight has a few legs

00:20:42.166 --> 00:20:44.096 A:middle
and this is this
closed range operator

00:20:44.096 --> 00:20:46.106 A:middle
that Dave showed you
earlier, includes both the one

00:20:46.106 --> 00:20:47.356 A:middle
and the eight, three dots.

00:20:48.466 --> 00:20:51.006 A:middle
So that matches, has a few
legs, otherwise lots of legs.

00:20:51.676 --> 00:20:53.716 A:middle
So that's an introduction
to our pattern matching.

00:20:54.496 --> 00:20:56.856 A:middle
There's a whole load more
awesomeness that you can find

00:20:56.856 --> 00:20:59.866 A:middle
out about by watching the
"Intermediate Swift" talk.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:00.896 --> 00:21:03.056 A:middle
So, for the examples we've used

00:21:03.056 --> 00:21:04.536 A:middle
so far we've seen
a lot of println.

00:21:05.186 --> 00:21:05.826 A:middle
What is this thing?

00:21:06.686 --> 00:21:08.626 A:middle
This is a function, it's
defined in the Standard Library,

00:21:08.626 --> 00:21:10.276 A:middle
and it prints some
value to the console.

00:21:10.836 --> 00:21:12.656 A:middle
How do we define
our own functions?

00:21:13.216 --> 00:21:17.126 A:middle
When Swift functions are
defined with the func keyword,

00:21:17.126 --> 00:21:20.386 A:middle
so you can read this as declare
a function called sayHello.

00:21:20.766 --> 00:21:21.876 A:middle
Doesn't take any parameters.

00:21:21.876 --> 00:21:24.606 A:middle
It doesn't return any values
and in this case it prints

00:21:24.606 --> 00:21:25.366 A:middle
"Hello" to the console.

00:21:25.816 --> 00:21:27.676 A:middle
Call it, as you might
imagine, sayHello().

00:21:28.826 --> 00:21:30.326 A:middle
Of course, I can
add a parameter.

00:21:30.326 --> 00:21:32.016 A:middle
Maybe I want to say hello
to someone specific.

00:21:32.686 --> 00:21:34.356 A:middle
So I can add in a
name parameter.

00:21:35.046 --> 00:21:38.056 A:middle
Notice the consistency
here, name: String.

00:21:38.416 --> 00:21:40.386 A:middle
The name is of type string.

00:21:41.166 --> 00:21:42.986 A:middle
Matches with the variable
declaration syntax

00:21:42.986 --> 00:21:43.806 A:middle
and constants as well.

00:21:44.686 --> 00:21:47.536 A:middle
So this means I can
now say, "Hello WWDC!"

00:21:47.826 --> 00:21:51.176 A:middle
Hello WWDC, and using string
interpolation, I get my name

00:21:51.176 --> 00:21:51.906 A:middle
in the, in the hello there.

00:21:53.026 --> 00:21:56.546 A:middle
In Swift, my parameter could
have a default value as well.

00:21:56.956 --> 00:21:59.096 A:middle
So let's say I usually
want to say, "Hello World."

00:21:59.796 --> 00:22:03.596 A:middle
I can add that with
"=" so "name: string"


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.796 --> 00:22:03.596 A:middle
I can add that with
"=" so "name: string"

00:22:03.826 --> 00:22:05.466 A:middle
and has a default
value of "world".

00:22:06.136 --> 00:22:07.286 A:middle
This means I can
call the function

00:22:07.286 --> 00:22:09.986 A:middle
without specifying any name at
all, it'll say, "Hello, World,"

00:22:10.396 --> 00:22:12.806 A:middle
but I still want to say hi
to you guys, so, Hello WWDC,

00:22:12.806 --> 00:22:13.796 A:middle
I can still do that anyway.

00:22:14.736 --> 00:22:16.916 A:middle
So that's parameters passing
values into a function.

00:22:16.916 --> 00:22:17.886 A:middle
What about getting values out?

00:22:17.886 --> 00:22:21.046 A:middle
Well we return values
in Swift with the arrow.

00:22:21.046 --> 00:22:23.786 A:middle
So here I've got a new function,
it's called buildGreeting.

00:22:24.506 --> 00:22:27.466 A:middle
This time, it takes a name
and it returns a string

00:22:27.926 --> 00:22:32.776 A:middle
with a concatenation operator,
that's that "+" there.

00:22:32.776 --> 00:22:34.766 A:middle
So function returns
value with the arrow.

00:22:34.856 --> 00:22:35.746 A:middle
How do we get at that value?

00:22:36.356 --> 00:22:38.936 A:middle
I'm going to create a
constant, it's called greeting,

00:22:38.936 --> 00:22:41.586 A:middle
and I'm going to set it to the
return value from this function.

00:22:42.616 --> 00:22:43.606 A:middle
Notice what I'm not doing.

00:22:43.696 --> 00:22:45.586 A:middle
I'm not specifying the
type of greeting here.

00:22:45.806 --> 00:22:47.226 A:middle
It's very clear this
returns a string

00:22:47.226 --> 00:22:48.726 A:middle
because that's what
the function returns.

00:22:49.066 --> 00:22:49.986 A:middle
The compiler knows that.

00:22:49.986 --> 00:22:51.436 A:middle
It will infer this
correctly for us.

00:22:51.576 --> 00:22:53.326 A:middle
So we don't have
to specify it again

00:22:53.326 --> 00:22:55.226 A:middle
but we can supply
the value right there

00:22:55.226 --> 00:22:56.496 A:middle
to println and it just works.

00:22:56.996 --> 00:22:59.576 A:middle
We talked about returning
a single value.

00:22:59.676 --> 00:23:00.916 A:middle
What about multiple values?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.676 --> 00:23:00.916 A:middle
What about multiple values?

00:23:01.586 --> 00:23:03.626 A:middle
Well in Swift we can
return multiple values

00:23:03.626 --> 00:23:06.096 A:middle
with this tuple thing that
Dave introduced earlier.

00:23:06.916 --> 00:23:07.586 A:middle
What is a tuple?

00:23:09.226 --> 00:23:12.236 A:middle
Well, tuple is just a grouping
of, a grouping of values

00:23:12.796 --> 00:23:15.096 A:middle
and they can be of any type
and any number of values

00:23:15.096 --> 00:23:16.256 A:middle
that you want, in this case,

00:23:16.256 --> 00:23:18.536 A:middle
first tuple: three
double values.

00:23:19.146 --> 00:23:21.186 A:middle
Otherwise, we could have an
Int and a string, if I like,

00:23:21.426 --> 00:23:23.136 A:middle
or Int and a string and
a double-any combination

00:23:23.136 --> 00:23:23.786 A:middle
of things that you like.

00:23:24.366 --> 00:23:26.876 A:middle
Why do I want one of these?

00:23:27.116 --> 00:23:29.866 A:middle
Well, it's not a replacement
for a full-blown data Structure.

00:23:30.266 --> 00:23:31.866 A:middle
Sometimes you really want
a Class or a Structure

00:23:32.056 --> 00:23:35.066 A:middle
to be most explicit but
tuples are really useful

00:23:35.136 --> 00:23:36.706 A:middle
when you just want to
pass multiple values

00:23:36.706 --> 00:23:38.346 A:middle
around very simply, such as

00:23:38.476 --> 00:23:40.266 A:middle
when returning multiple
values from a function.

00:23:41.226 --> 00:23:43.876 A:middle
So in this example I have
a refresh webpage function.

00:23:43.876 --> 00:23:45.266 A:middle
It goes out, refreshes a webpage

00:23:45.266 --> 00:23:46.966 A:middle
and it gives me back
the status code.

00:23:47.316 --> 00:23:50.296 A:middle
That means an integer
code and a string message

00:23:50.386 --> 00:23:51.676 A:middle
and they get bundled together.

00:23:52.686 --> 00:23:55.456 A:middle
So I return that with
a tuple, (Int, String).

00:23:55.516 --> 00:23:57.326 A:middle
How do I get at those things?

00:23:57.326 --> 00:23:58.036 A:middle
How do I use them?

00:23:59.386 --> 00:24:00.276 A:middle
Let's create a constant.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.386 --> 00:24:00.276 A:middle
Let's create a constant.

00:24:01.556 --> 00:24:04.316 A:middle
This time I've got two names,
also in parentheses with a comma

00:24:04.316 --> 00:24:06.976 A:middle
in between and those
get bound to the values

00:24:06.976 --> 00:24:08.196 A:middle
that come back from a function.

00:24:09.256 --> 00:24:11.556 A:middle
This means that I can
then use them individually

00:24:11.556 --> 00:24:12.716 A:middle
and print them out separately.

00:24:12.966 --> 00:24:15.706 A:middle
So we've decomposed the
tuple with these names.

00:24:17.246 --> 00:24:18.666 A:middle
Again notice, thank you,

00:24:18.786 --> 00:24:20.946 A:middle
notice that I haven't
specified types here.

00:24:22.226 --> 00:24:23.556 A:middle
Return of the function
is obvious.

00:24:23.556 --> 00:24:24.996 A:middle
We've got two values
coming back from there,

00:24:24.996 --> 00:24:25.766 A:middle
they're an Int and a string.

00:24:26.206 --> 00:24:28.976 A:middle
So these map to the names and
the compiler knows it's an Int

00:24:28.976 --> 00:24:31.086 A:middle
and a message right there, I'm
sorry, an Int and a string.

00:24:32.136 --> 00:24:34.066 A:middle
You've seen an example of
this decomposition already.

00:24:34.916 --> 00:24:37.746 A:middle
That was when Dave was showing
you enumeration of a Dictionary.

00:24:38.526 --> 00:24:42.096 A:middle
And the way that we give you the
key and the value in one go is

00:24:42.096 --> 00:24:44.766 A:middle
for each iteration through the
Dictionary you get back a tuple

00:24:44.766 --> 00:24:46.786 A:middle
pair containing the
key and the value.

00:24:46.836 --> 00:24:49.016 A:middle
So these names here, these
bind in to those returns

00:24:49.016 --> 00:24:51.866 A:middle
and then you can use
them individually in, in,

00:24:51.906 --> 00:24:52.886 A:middle
in the full statement.

00:24:53.366 --> 00:24:57.076 A:middle
So tuple decomposition is one
way to get these values out.

00:24:57.076 --> 00:25:00.396 A:middle
There's another one and that is
we can actually name the values


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.076 --> 00:25:00.396 A:middle
There's another one and that is
we can actually name the values

00:25:00.396 --> 00:25:00.906 A:middle
in the tuple.

00:25:01.076 --> 00:25:02.236 A:middle
So I've got this
Int and a String

00:25:02.236 --> 00:25:04.076 A:middle
but it's not entirely
clear what they are.

00:25:05.026 --> 00:25:06.176 A:middle
What about if I could name them?

00:25:06.466 --> 00:25:09.326 A:middle
I'm going to say I have a
code, which is a type Int,

00:25:09.596 --> 00:25:11.526 A:middle
and a message, which
is of type String.

00:25:12.156 --> 00:25:14.936 A:middle
Same syntaxes, parameters,
and variable declarations.

00:25:15.606 --> 00:25:17.346 A:middle
Thing is of type, type.

00:25:18.426 --> 00:25:20.166 A:middle
This means, when I
call this function,

00:25:20.636 --> 00:25:23.446 A:middle
I can now just declare a
single constant called status

00:25:23.916 --> 00:25:26.176 A:middle
and I can then grab the
individual bits out by name,

00:25:26.176 --> 00:25:28.406 A:middle
status.code and status.message
ready for use.

00:25:28.766 --> 00:25:29.916 A:middle
So that's functions.

00:25:29.916 --> 00:25:32.556 A:middle
I want to move to a related
thing now which is Closures.

00:25:33.526 --> 00:25:36.276 A:middle
Closures in Swift, much
like blocks in Objective-C.

00:25:36.466 --> 00:25:37.376 A:middle
They're just blocks of code.

00:25:37.376 --> 00:25:39.126 A:middle
You can pass them around,
they can capture values

00:25:39.126 --> 00:25:40.006 A:middle
from the surrounding scope.

00:25:40.526 --> 00:25:43.226 A:middle
So here I have a very simple
one, it's called greetingPrinter

00:25:43.226 --> 00:25:46.276 A:middle
and it's a constant, and it
has this, this, this Closure

00:25:46.276 --> 00:25:48.166 A:middle
that just prints, "Hello World!"

00:25:48.666 --> 00:25:51.216 A:middle
Again, I'm not specifying
any type for greeting printer

00:25:51.216 --> 00:25:53.956 A:middle
because it's very clear this
Closure doesn't take any values.

00:25:53.956 --> 00:25:55.136 A:middle
It doesn't return
anything either.

00:25:55.786 --> 00:25:58.026 A:middle
So the compiler will infer that
this is this thing, () -&gt; ().

00:25:58.756 --> 00:26:00.566 A:middle
Empty parens are empty parens.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.756 --> 00:26:00.566 A:middle
Empty parens are empty parens.

00:26:00.626 --> 00:26:01.716 A:middle
That's the type of this Closure.

00:26:01.716 --> 00:26:02.846 A:middle
It doesn't take any parameters.

00:26:02.846 --> 00:26:03.996 A:middle
It doesn't return any values.

00:26:05.566 --> 00:26:07.046 A:middle
You may think well that
looks kind of familiar,

00:26:07.046 --> 00:26:10.206 A:middle
I recommend this, this parens,
arrow, parens syntax and that's

00:26:10.356 --> 00:26:12.846 A:middle
because it looks very much
like a function syntax

00:26:13.206 --> 00:26:15.166 A:middle
and there's a reason for that.

00:26:15.716 --> 00:26:18.566 A:middle
In Swift functions are
just named Closures.

00:26:19.586 --> 00:26:21.966 A:middle
So I can call my
greetingPrinter thing just

00:26:21.966 --> 00:26:24.176 A:middle
by saying greetingPrinter ()
and it prints, "Hello World."

00:26:25.376 --> 00:26:27.716 A:middle
That's a simple Closure as
a local variable perhaps.

00:26:27.716 --> 00:26:30.066 A:middle
What about Closures
as parameters?

00:26:31.426 --> 00:26:33.726 A:middle
Well to do this,
same syntax again.

00:26:33.726 --> 00:26:35.766 A:middle
I'm going to create a
repeat function this time

00:26:36.466 --> 00:26:39.006 A:middle
and this will repeat a task
a given number of times

00:26:39.006 --> 00:26:40.026 A:middle
and the task is a Closure.

00:26:40.706 --> 00:26:41.246 A:middle
So, again, () -&gt; ().

00:26:41.246 --> 00:26:44.496 A:middle
Doesn't take any values,
doesn't return anything,

00:26:44.556 --> 00:26:47.076 A:middle
and it will be repeated for
the number that I supplied.

00:26:47.706 --> 00:26:49.166 A:middle
How do I call it?

00:26:50.216 --> 00:26:51.526 A:middle
Let's call it twice.

00:26:51.766 --> 00:26:53.686 A:middle
I want this Closure to
repeat, be repeated twice.

00:26:53.686 --> 00:26:56.176 A:middle
So I can supply my
Closure inline right there

00:26:56.176 --> 00:26:56.916 A:middle
in the function call.

00:26:57.366 --> 00:27:00.456 A:middle
Don't know about you, not
so keen on that syntax.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.366 --> 00:27:00.456 A:middle
Don't know about you, not
so keen on that syntax.

00:27:00.456 --> 00:27:03.696 A:middle
And we can do something really
special in Swift and that is

00:27:03.696 --> 00:27:06.586 A:middle
if the Closure is the last
argument to this function,

00:27:07.316 --> 00:27:10.666 A:middle
we can shift it outside of
the, outside of the parentheses

00:27:10.666 --> 00:27:13.216 A:middle
of the function call and turn
it into a Trailing Closure.

00:27:14.236 --> 00:27:15.786 A:middle
This makes the code
much more readable.

00:27:15.786 --> 00:27:17.266 A:middle
It looks like a control
close statement now,

00:27:17.266 --> 00:27:18.376 A:middle
which it is in this case.

00:27:18.946 --> 00:27:20.486 A:middle
And, much more readable,

00:27:20.766 --> 00:27:22.856 A:middle
much more modern bringing
Trailer Closures in.

00:27:23.486 --> 00:27:25.396 A:middle
So that's Closures.

00:27:25.396 --> 00:27:26.336 A:middle
We've talked through functions.

00:27:26.336 --> 00:27:27.376 A:middle
We've talked through tuples.

00:27:27.376 --> 00:27:30.236 A:middle
To take us forward I'm going
to hand back Dave to go

00:27:30.236 --> 00:27:32.446 A:middle
through data types and
specifically Classes [applause].

00:27:33.316 --> 00:27:36.026 A:middle
&gt;&gt; So let's take a look at how
to define a Class in Swift.

00:27:36.796 --> 00:27:39.226 A:middle
We do this with the class
keyword followed by the name

00:27:39.226 --> 00:27:40.396 A:middle
of the class you want to create.

00:27:40.726 --> 00:27:42.236 A:middle
Here I'm going to
create a vehicle.

00:27:42.886 --> 00:27:44.606 A:middle
And all of the class's
definition,

00:27:44.606 --> 00:27:45.606 A:middle
all of its implementation,

00:27:45.606 --> 00:27:49.166 A:middle
appears between these curly
braces, all of its properties,

00:27:49.306 --> 00:27:52.626 A:middle
all of its methods, all of its
initializers and we'll see how

00:27:52.626 --> 00:27:54.516 A:middle
to write all of those
in just a moment.

00:27:55.376 --> 00:27:57.376 A:middle
But first, there are two
things you don't have

00:27:57.416 --> 00:27:58.416 A:middle
to write in Swift.

00:27:59.816 --> 00:28:03.396 A:middle
You don't have to import
vehicle.h and the reason is


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.816 --> 00:28:03.396 A:middle
You don't have to import
vehicle.h and the reason is

00:28:03.396 --> 00:28:05.206 A:middle
because Vehicle.h
does not exist.

00:28:05.876 --> 00:28:07.356 A:middle
Swift doesn't have header files.

00:28:07.896 --> 00:28:08.456 A:middle
There's no need.

00:28:09.106 --> 00:28:11.646 A:middle
Instead, you just write your
implementation for your class

00:28:12.016 --> 00:28:13.656 A:middle
and that becomes its
interface as well.

00:28:13.656 --> 00:28:14.566 A:middle
There's no need to duplicate it.

00:28:16.366 --> 00:28:19.546 A:middle
The second thing you don't
have to write is we don't have

00:28:19.636 --> 00:28:21.396 A:middle
to have a base class for Vehicle

00:28:21.926 --> 00:28:24.116 A:middle
because Swift doesn't have
a universal base class

00:28:24.176 --> 00:28:26.276 A:middle
that every class must,
must, must come from.

00:28:26.376 --> 00:28:30.976 A:middle
And you can still use
NSObjects or any of the Cocoa

00:28:30.976 --> 00:28:32.976 A:middle
or Cocoa Touch Classes
if you wish, that's fine.

00:28:33.556 --> 00:28:34.586 A:middle
But you don't have to.

00:28:35.716 --> 00:28:38.266 A:middle
If it makes sense for
vehicle to be a base class

00:28:38.266 --> 00:28:40.856 A:middle
for some hierarchy of classes
in your app then it can be.

00:28:40.856 --> 00:28:42.746 A:middle
It can be its own base class.

00:28:43.776 --> 00:28:46.716 A:middle
When we want to create a
subclass ourselves we do this

00:28:46.716 --> 00:28:49.766 A:middle
by providing the subclass
name, followed again by a colon

00:28:49.766 --> 00:28:51.546 A:middle
and then the thing we
want to subclass from.

00:28:51.546 --> 00:28:54.056 A:middle
And we'll come back to this
bicycle subclass shortly

00:28:54.826 --> 00:28:56.406 A:middle
but first let's add
a bit more detail

00:28:56.566 --> 00:28:57.916 A:middle
to our base class,
to our vehicle.

00:28:59.326 --> 00:29:00.626 A:middle
So we'll start by
adding a property,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.326 --> 00:29:00.626 A:middle
So we'll start by
adding a property,

00:29:00.796 --> 00:29:02.306 A:middle
a property called
numberOfWheels.

00:29:02.306 --> 00:29:04.586 A:middle
It's a variable property,
default value 0.

00:29:05.826 --> 00:29:08.626 A:middle
Know that this is exactly
the same syntax we would use

00:29:08.856 --> 00:29:10.206 A:middle
if we were declaring
this as a variable,

00:29:10.436 --> 00:29:11.706 A:middle
just move into class context.

00:29:12.556 --> 00:29:14.566 A:middle
Here we've made it be
a variable property,

00:29:14.636 --> 00:29:16.696 A:middle
what we'd call a read/write
property in Objective-C

00:29:16.816 --> 00:29:17.876 A:middle
but it could be a constant.

00:29:18.756 --> 00:29:20.696 A:middle
In this case, and we just
use let, same as we would do

00:29:20.696 --> 00:29:21.476 A:middle
for a normal constant.

00:29:22.096 --> 00:29:23.886 A:middle
But we'll keep it as a
variable for now because we want

00:29:23.886 --> 00:29:27.896 A:middle
to change its, change its
value for some subclasses.

00:29:28.356 --> 00:29:31.016 A:middle
Now big, big difference
that we have in Swift

00:29:31.016 --> 00:29:34.816 A:middle
from Objective-C is that we
don't have any distinction

00:29:34.816 --> 00:29:37.756 A:middle
between instance variables
and properties in Swift,

00:29:37.756 --> 00:29:38.896 A:middle
they're one and the same thing.

00:29:39.726 --> 00:29:43.476 A:middle
And, in fact, this var
numberOfWheels = 0 is all you

00:29:43.476 --> 00:29:46.436 A:middle
have to write to
define a property.

00:29:46.436 --> 00:29:48.316 A:middle
Swift provides the
backing store for you.

00:29:48.416 --> 00:29:49.606 A:middle
You don't have to
define it yourself

00:29:49.956 --> 00:29:51.156 A:middle
and it handles all access

00:29:51.276 --> 00:29:52.696 A:middle
to that backing store
for you as well.

00:29:54.326 --> 00:29:57.436 A:middle
Now, in this case, were we just
storing a value, these are known

00:29:57.436 --> 00:30:00.396 A:middle
as stored properties but we do
have a second kind of property


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:57.436 --> 00:30:00.396 A:middle
as stored properties but we do
have a second kind of property

00:30:00.396 --> 00:30:02.976 A:middle
as well-known as
computed properties.

00:30:03.046 --> 00:30:05.076 A:middle
Let's add one of those to our
Vehicle, our Vehicle class.

00:30:06.346 --> 00:30:08.966 A:middle
So this is a computed property
that provides a description

00:30:08.966 --> 00:30:10.556 A:middle
of our class, just
a string description

00:30:10.616 --> 00:30:13.116 A:middle
of the number of wheels it has.

00:30:13.116 --> 00:30:15.556 A:middle
Note that computed properties
don't have a backing store.

00:30:16.136 --> 00:30:18.816 A:middle
Instead, they, they
generate or calculate a value

00:30:18.816 --> 00:30:22.036 A:middle
when they're called and to
write one we provide the type

00:30:22.136 --> 00:30:23.016 A:middle
that we want this
property to have

00:30:23.076 --> 00:30:26.056 A:middle
and then just return a value
of the appropriate type.

00:30:26.406 --> 00:30:28.106 A:middle
Here we're using
string interpolation

00:30:28.226 --> 00:30:29.266 A:middle
to return the number of wheels.

00:30:30.706 --> 00:30:34.376 A:middle
Now, in this case I've provided
a read-only computed property,

00:30:34.376 --> 00:30:36.086 A:middle
which is why it only
has a getter here,

00:30:36.596 --> 00:30:38.136 A:middle
but I could also
provide a setter as well

00:30:38.246 --> 00:30:39.366 A:middle
if I wanted it to be read/write.

00:30:40.556 --> 00:30:42.566 A:middle
It doesn't really make
sense for this description

00:30:42.626 --> 00:30:43.696 A:middle
to be read/write though.

00:30:43.736 --> 00:30:45.906 A:middle
It's generated based on
other properties so I'm going

00:30:45.906 --> 00:30:47.296 A:middle
to keep it as a read-only
property.

00:30:48.946 --> 00:30:50.956 A:middle
Where a computer
property is read-only,

00:30:51.366 --> 00:30:53.816 A:middle
you can actually lose
the get and the braces

00:30:53.816 --> 00:30:57.096 A:middle
and just return a value directly
from the outer description

00:30:57.096 --> 00:30:58.366 A:middle
of the computed property.

00:30:59.216 --> 00:31:01.226 A:middle
The end result is the same,
you just don't have to write


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.216 --> 00:31:01.226 A:middle
The end result is the same,
you just don't have to write

00:31:01.226 --> 00:31:02.166 A:middle
that extra level of nesting.

00:31:03.506 --> 00:31:06.696 A:middle
Note, however, that computed
properties, even read-only ones,

00:31:06.976 --> 00:31:08.726 A:middle
do need to be defined
as variables.

00:31:09.456 --> 00:31:12.136 A:middle
Even though you can't set
them, their value can change,

00:31:12.136 --> 00:31:16.636 A:middle
it can vary, so they
need to be variables.

00:31:16.636 --> 00:31:17.876 A:middle
Now that we've created
our vehicle

00:31:17.876 --> 00:31:19.096 A:middle
and we've given it
a few properties,

00:31:19.216 --> 00:31:21.046 A:middle
let's create a new
instance of that vehicle,

00:31:21.236 --> 00:31:22.996 A:middle
which we do with
initializer syntax.

00:31:23.756 --> 00:31:25.746 A:middle
This is the name of the
class followed by a pair

00:31:25.746 --> 00:31:30.076 A:middle
of parentheses, creating a
new instance of this class.

00:31:30.256 --> 00:31:33.396 A:middle
Because we provided a default
value for our stored property,

00:31:33.396 --> 00:31:35.126 A:middle
it's clear what to do
when initializing this.

00:31:35.156 --> 00:31:36.816 A:middle
Just set numberOfWheels to 0.

00:31:37.806 --> 00:31:40.786 A:middle
Note that we didn't need
to write alloc at the point

00:31:40.786 --> 00:31:41.626 A:middle
that we created this instance.

00:31:42.106 --> 00:31:43.916 A:middle
Swift handles all of the
memory allocation for you.

00:31:43.916 --> 00:31:44.906 A:middle
There's no need to write alloc.

00:31:46.046 --> 00:31:47.456 A:middle
We also didn't need
to write the type.

00:31:47.656 --> 00:31:50.466 A:middle
Once again, Swift can infer
the type we want to create.

00:31:50.466 --> 00:31:52.196 A:middle
It's clear from the thing
on the right-hand side

00:31:52.196 --> 00:31:56.006 A:middle
that we want this
to be a vehicle.

00:31:56.006 --> 00:31:58.546 A:middle
As I mentioned earlier we,
we have these default values.

00:31:58.546 --> 00:32:00.066 A:middle
Now, this means we
actually haven't had


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.546 --> 00:32:00.066 A:middle
Now, this means we
actually haven't had

00:32:00.066 --> 00:32:01.746 A:middle
to write an initializer at all

00:32:02.256 --> 00:32:03.706 A:middle
because it's just
clear what to do here.

00:32:03.736 --> 00:32:05.096 A:middle
It's clear to create
a new instance,

00:32:05.466 --> 00:32:07.016 A:middle
give it the default value of 0.

00:32:07.626 --> 00:32:12.256 A:middle
Now that we've created our
vehicle instance we can use dot

00:32:12.256 --> 00:32:14.176 A:middle
syntax to, to access
its properties,

00:32:14.216 --> 00:32:15.506 A:middle
so to print its description
perhaps.

00:32:15.506 --> 00:32:18.206 A:middle
And we can see that it has
a description of 0 wheels.

00:32:18.206 --> 00:32:20.576 A:middle
If we had changed
them, the wheels to 2,

00:32:20.616 --> 00:32:21.746 A:middle
we can see the description
change.

00:32:21.746 --> 00:32:22.646 A:middle
It now has two wheels.

00:32:24.346 --> 00:32:27.676 A:middle
But it would be nice to create a
class that always has two wheels

00:32:27.726 --> 00:32:29.776 A:middle
by default, our bicycle
subclass from earlier.

00:32:30.056 --> 00:32:31.386 A:middle
So let's see how
we'd, how we do that,

00:32:31.386 --> 00:32:32.816 A:middle
how we'd make it
have two by default.

00:32:34.486 --> 00:32:37.306 A:middle
Now, because we want
bicycle to change the value

00:32:37.306 --> 00:32:40.246 A:middle
of an inherited property, we
do need to write an initializer

00:32:40.246 --> 00:32:41.336 A:middle
and this is how we do it.

00:32:41.776 --> 00:32:44.316 A:middle
The init keyword followed
by a pair of parentheses

00:32:45.046 --> 00:32:47.866 A:middle
and these can contain parameters
so you can use parameters

00:32:47.866 --> 00:32:49.236 A:middle
to customize your
initialization,

00:32:49.326 --> 00:32:51.486 A:middle
and they look just like the
function parameters Tim showed

00:32:51.486 --> 00:32:53.856 A:middle
earlier, but we're not going
to use them in this case.

00:32:53.856 --> 00:32:56.996 A:middle
We're just going to
use a new value of 2.

00:32:57.256 --> 00:33:00.966 A:middle
Now because we're changing an
inherited property we do need


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.256 --> 00:33:00.966 A:middle
Now because we're changing an
inherited property we do need

00:33:00.966 --> 00:33:03.506 A:middle
to give our super class a chance
to set that property first,

00:33:03.846 --> 00:33:05.446 A:middle
which we do by calling
super.init,

00:33:06.116 --> 00:33:08.346 A:middle
after all it introduced
the property so we need

00:33:08.346 --> 00:33:10.436 A:middle
to give it a chance to
set an initial value,

00:33:10.546 --> 00:33:12.676 A:middle
which we may then use to
modify the value we use.

00:33:14.156 --> 00:33:15.816 A:middle
After we've done so we
can change the value,

00:33:15.866 --> 00:33:17.806 A:middle
we can set it to 2.

00:33:17.966 --> 00:33:20.656 A:middle
Now we'll go into a lot more
detail on initialization

00:33:20.656 --> 00:33:23.876 A:middle
in the Intermediate Swift Talk
but, for now, one final thing

00:33:23.876 --> 00:33:27.046 A:middle
to note: Swift initializers
don't return a value.

00:33:27.496 --> 00:33:29.446 A:middle
Rather, their main
role is to make sure

00:33:29.446 --> 00:33:31.266 A:middle
that every stored
property has a value

00:33:31.416 --> 00:33:33.186 A:middle
by the time its initialization
completes.

00:33:34.896 --> 00:33:35.996 A:middle
So now we have that set up.

00:33:35.996 --> 00:33:37.126 A:middle
We can create a new bicycle.

00:33:37.776 --> 00:33:40.466 A:middle
We can print its description,
which we inherited from vehicle,

00:33:40.636 --> 00:33:42.766 A:middle
and see it has two wheels
by default, all the,

00:33:42.766 --> 00:33:43.986 A:middle
all bicycles have two wheels.

00:33:45.106 --> 00:33:49.376 A:middle
So that changes the default
value of an inherited property

00:33:49.376 --> 00:33:51.076 A:middle
but if we want to
change its behavior?

00:33:51.186 --> 00:33:51.716 A:middle
What if we want it

00:33:51.756 --> 00:33:53.566 A:middle
to do something different
every time it's called?

00:33:53.636 --> 00:33:55.216 A:middle
For this we override
the property.

00:33:55.956 --> 00:33:58.936 A:middle
We'll create a new subclass
of vehicle called Car,

00:33:59.436 --> 00:34:02.316 A:middle
give it a new stored property
called speed, initial value


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.436 --> 00:34:02.316 A:middle
give it a new stored property
called speed, initial value

00:34:02.316 --> 00:34:04.086 A:middle
of 0.0 (so inferred
to be a double),

00:34:04.886 --> 00:34:07.586 A:middle
and we'll add an initializer
that sets the car's number

00:34:07.586 --> 00:34:08.876 A:middle
of wheels to be four by default.

00:34:08.985 --> 00:34:11.246 A:middle
Same approach we just
saw for, for the bicycle.

00:34:11.766 --> 00:34:14.876 A:middle
So its overrider
description: in this case I'd

00:34:14.876 --> 00:34:17.065 A:middle
like to add the speed on to
the end of the description.

00:34:17.545 --> 00:34:19.106 A:middle
We just write the,
we write the property

00:34:19.106 --> 00:34:20.436 A:middle
in the same ways we did before.

00:34:20.556 --> 00:34:22.136 A:middle
So we have that same
name and the same type.

00:34:22.936 --> 00:34:25.426 A:middle
But to do the override we
have the override keywords

00:34:25.456 --> 00:34:26.246 A:middle
on the beginning.

00:34:27.036 --> 00:34:29.025 A:middle
This makes the override
safe for two reasons.

00:34:30.005 --> 00:34:32.846 A:middle
Firstly, it makes it clear we
want to provide an override.

00:34:33.116 --> 00:34:35.716 A:middle
We haven't just accidentally
written a property

00:34:35.716 --> 00:34:38.025 A:middle
that has the same name and
the same type of something

00:34:38.025 --> 00:34:40.356 A:middle
in our super class that maybe
we didn't even know about.

00:34:41.686 --> 00:34:44.016 A:middle
Moreover, it actually
prompts Swift to go and check

00:34:44.466 --> 00:34:46.426 A:middle
that this property
exists somewhere

00:34:46.426 --> 00:34:48.606 A:middle
in our super class chain so
there definitely is something

00:34:48.606 --> 00:34:49.866 A:middle
with the same name
and the same type.

00:34:50.266 --> 00:34:52.406 A:middle
So our override will
do what we expect.

00:34:53.036 --> 00:34:55.826 A:middle
In this case we'll just
call the super description

00:34:55.976 --> 00:34:58.536 A:middle
to get the number of wheels and
we'll add an extra bit of text

00:34:58.536 --> 00:34:59.856 A:middle
on the end that shows the speed.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:00.386 --> 00:35:02.946 A:middle
So, if we create
a car we can see

00:35:02.946 --> 00:35:04.816 A:middle
that the description
defaults to four wheels,

00:35:04.816 --> 00:35:07.916 A:middle
zero miles per hour and, if we
change the speed, it updates.

00:35:07.916 --> 00:35:09.126 A:middle
It now includes the
new speed as well.

00:35:09.746 --> 00:35:14.426 A:middle
So that's the way to change the
behavior of inherited property

00:35:14.426 --> 00:35:16.476 A:middle
but maybe sometimes
that's a bit overkill.

00:35:17.036 --> 00:35:19.076 A:middle
We don't want to see, we don't
want to change how it works.

00:35:19.076 --> 00:35:21.616 A:middle
We just want to know when it
changes and what it changes to

00:35:22.396 --> 00:35:24.056 A:middle
and for this we have
property observers.

00:35:25.176 --> 00:35:27.196 A:middle
So to show these,
I'll create a subclass

00:35:27.196 --> 00:35:28.596 A:middle
of car called ParentsCar.

00:35:28.596 --> 00:35:32.386 A:middle
Now, ParentsCar doesn't stop
you going at a certain speed,

00:35:32.926 --> 00:35:35.286 A:middle
it just watches how
fast you're going and,

00:35:35.286 --> 00:35:37.236 A:middle
if you go too fast,
it issues a warning.

00:35:37.236 --> 00:35:39.776 A:middle
It says, "Careful now,
that's a bit too fast."

00:35:41.146 --> 00:35:44.136 A:middle
[Laughter] So to do this we
still override a property.

00:35:44.136 --> 00:35:47.116 A:middle
In this case we're overriding
the speed property we inherited

00:35:47.116 --> 00:35:47.636 A:middle
from Car.

00:35:48.256 --> 00:35:50.286 A:middle
Note that this override
is for stored property,

00:35:50.416 --> 00:35:51.466 A:middle
not a computer property,

00:35:51.676 --> 00:35:52.826 A:middle
but it's still written
in the same way.

00:35:54.276 --> 00:35:56.656 A:middle
This time, however, we won't
provide a custom getter

00:35:56.656 --> 00:36:00.846 A:middle
and setter, we'll provide either
willSet or a didSet observer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:56.656 --> 00:36:00.846 A:middle
and setter, we'll provide either
willSet or a didSet observer

00:36:01.426 --> 00:36:03.666 A:middle
and willSet is called
just before didSet just

00:36:03.666 --> 00:36:04.676 A:middle
after the value changes.

00:36:06.266 --> 00:36:09.286 A:middle
WillSet gets a newValue
constant that you can use

00:36:09.286 --> 00:36:10.486 A:middle
within the body of
the subserver.

00:36:10.816 --> 00:36:12.446 A:middle
didSet gets an oldValue constant

00:36:12.446 --> 00:36:15.006 A:middle
so that you can see what the
value was or has just changed

00:36:15.006 --> 00:36:16.376 A:middle
to be within these observers.

00:36:17.926 --> 00:36:20.526 A:middle
In this case we'll just
use willSet and we'll use

00:36:20.526 --> 00:36:23.516 A:middle
that newValue constant to keep
an eye on the speed of this car

00:36:23.906 --> 00:36:26.696 A:middle
and if it goes over 65 miles
an hour we'll issue a warning,

00:36:27.066 --> 00:36:27.476 A:middle
careful now.

00:36:29.356 --> 00:36:30.606 A:middle
So that's how we add properties.

00:36:30.796 --> 00:36:31.606 A:middle
What about methods?

00:36:31.786 --> 00:36:33.206 A:middle
How do we add methods
to our Classes?

00:36:34.026 --> 00:36:36.226 A:middle
Well, here's a simple
class called Counter.

00:36:36.476 --> 00:36:39.456 A:middle
Just keeps track how many
times something has happened.

00:36:39.456 --> 00:36:43.106 A:middle
Does with a stored property
called count and in the same way

00:36:43.106 --> 00:36:45.486 A:middle
that this stored property
looks just like a variable,

00:36:46.246 --> 00:36:48.286 A:middle
methods in Swift look
just like functions,

00:36:48.566 --> 00:36:49.826 A:middle
the ones that Tim
introduced earlier.

00:36:49.976 --> 00:36:51.726 A:middle
Here, this increment
method looks just

00:36:51.726 --> 00:36:53.186 A:middle
like we'd write a
function of the same type.

00:36:53.186 --> 00:36:55.926 A:middle
In this case it just adds 1 to
count each times it's called.

00:36:55.926 --> 00:36:58.726 A:middle
If we make it a bit more
complex, if we add a parameter,

00:36:58.966 --> 00:37:00.086 A:middle
again, it's just the same


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.966 --> 00:37:00.086 A:middle
again, it's just the same

00:37:00.086 --> 00:37:01.666 A:middle
as the function parameters
we saw earlier.

00:37:03.166 --> 00:37:05.726 A:middle
Know that when we refer to
count here, we don't have

00:37:05.726 --> 00:37:07.616 A:middle
to use self.count
inside the method

00:37:07.716 --> 00:37:09.286 A:middle
because it's clear what
we're referring to.

00:37:09.286 --> 00:37:10.366 A:middle
There's no ambiguity here.

00:37:10.586 --> 00:37:13.566 A:middle
The one time we do
need to use self is

00:37:13.566 --> 00:37:16.226 A:middle
if we have methods whose
parameter name is the same

00:37:16.226 --> 00:37:16.936 A:middle
as a property name.

00:37:17.216 --> 00:37:18.936 A:middle
Here we have a method with
a parameter called count.

00:37:19.646 --> 00:37:21.736 A:middle
So in this case we use
self.count to refer

00:37:21.806 --> 00:37:26.136 A:middle
to the property and count
refers to the parameter.

00:37:26.136 --> 00:37:28.376 A:middle
So that's how we create classes,
how we give them properties,

00:37:28.426 --> 00:37:30.506 A:middle
how we give them initializers
and how we give them methods.

00:37:31.236 --> 00:37:33.986 A:middle
I'd now like to invite Tim back
up to take us beyond classes

00:37:33.986 --> 00:37:36.766 A:middle
and to show some of the other
data structures you can create

00:37:36.766 --> 00:37:38.646 A:middle
in Swift to make the
building blocks of your apps.

00:37:39.036 --> 00:37:39.316 A:middle
Thank you [applause].

00:37:39.696 --> 00:37:40.106 A:middle
&gt;&gt; Thank you.

00:37:40.686 --> 00:37:42.686 A:middle
So beyond classes,
where should we go next?

00:37:43.216 --> 00:37:44.946 A:middle
Let's go to structures.

00:37:45.126 --> 00:37:47.796 A:middle
Structures in Swift are defined
using these struct keywords.

00:37:47.796 --> 00:37:50.326 A:middle
So here I'm going to define
a couple, maybe three.

00:37:50.586 --> 00:37:53.006 A:middle
I've got a point, it has
an x and a y coordinate,

00:37:53.226 --> 00:37:54.306 A:middle
size with a width and a height,

00:37:54.566 --> 00:37:56.136 A:middle
rectangle with an
origin and a size.

00:37:57.486 --> 00:38:01.086 A:middle
With structures I get a very
handy memberwise initializer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:57.486 --> 00:38:01.086 A:middle
With structures I get a very
handy memberwise initializer

00:38:01.086 --> 00:38:01.736 A:middle
by default.

00:38:02.346 --> 00:38:04.186 A:middle
This means it's really
easy to create instances

00:38:04.186 --> 00:38:06.506 A:middle
of these Structures
just by supplying values

00:38:06.556 --> 00:38:07.706 A:middle
for the properties in line.

00:38:07.796 --> 00:38:09.836 A:middle
So, supplying an x and
a y, width and a height,

00:38:10.366 --> 00:38:11.616 A:middle
point and a size
for the rectangle.

00:38:12.856 --> 00:38:15.326 A:middle
If I really wanted to, I
could actually provide custom

00:38:15.326 --> 00:38:16.496 A:middle
initializers in my Structures.

00:38:16.496 --> 00:38:19.106 A:middle
To find out more about
that check out the

00:38:19.106 --> 00:38:21.486 A:middle
"Intermediate Swift" talk.

00:38:21.706 --> 00:38:23.786 A:middle
OK. So this is a
simple structure.

00:38:23.786 --> 00:38:25.376 A:middle
It has an origin
and it has a size.

00:38:25.426 --> 00:38:26.416 A:middle
Those are two, two properties.

00:38:26.416 --> 00:38:28.736 A:middle
It would be rather nice

00:38:28.866 --> 00:38:31.036 A:middle
if I could add an
area to my rectangle.

00:38:31.086 --> 00:38:33.176 A:middle
That sounds like a
computed property

00:38:33.176 --> 00:38:34.166 A:middle
so can we add one of those?

00:38:34.746 --> 00:38:35.596 A:middle
Yes, yes we can.

00:38:36.176 --> 00:38:38.226 A:middle
So here is an area
property on my rectangle,

00:38:38.256 --> 00:38:40.346 A:middle
just returns the width
times the height.

00:38:40.546 --> 00:38:43.106 A:middle
OK, properties are great
but what about methods?

00:38:43.486 --> 00:38:45.106 A:middle
Sometimes I want more
than just a property.

00:38:46.006 --> 00:38:48.226 A:middle
Well, in Swift a structure
can have a method as well.

00:38:48.706 --> 00:38:50.526 A:middle
So here I have an
isBiggerThanRect(other:

00:38:50.526 --> 00:38:53.246 A:middle
Rect) method and I can
pass in a rectangle

00:38:53.246 --> 00:38:54.326 A:middle
and return a value back

00:38:54.326 --> 00:38:55.956 A:middle
that indicates whether it's
bigger than the other one.

00:38:56.936 --> 00:38:59.026 A:middle
So structures in Swift,
incredibly powerful,

00:38:59.296 --> 00:39:01.326 A:middle
a lot more functionality
than you're used to in C.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.296 --> 00:39:01.326 A:middle
a lot more functionality
than you're used to in C.

00:39:02.066 --> 00:39:04.726 A:middle
So that raises the question,
what is the difference

00:39:04.806 --> 00:39:06.106 A:middle
between a Structure and a Class?

00:39:07.116 --> 00:39:08.056 A:middle
Here's a couple of examples.

00:39:08.056 --> 00:39:10.266 A:middle
We've got a rectangle, that's
at the moment a structure,

00:39:10.266 --> 00:39:11.016 A:middle
and we've got a window.

00:39:11.016 --> 00:39:13.646 A:middle
It's a hypothetical
Window class that refers

00:39:13.736 --> 00:39:15.166 A:middle
to some user interface object.

00:39:16.376 --> 00:39:18.816 A:middle
How do you determine
whether you want a class

00:39:18.816 --> 00:39:20.116 A:middle
or a structure given
that you've got a lot

00:39:20.116 --> 00:39:21.076 A:middle
of the same functionality?

00:39:22.216 --> 00:39:23.546 A:middle
Where there are two
primary differences

00:39:23.546 --> 00:39:24.696 A:middle
between classes and structures.

00:39:24.916 --> 00:39:27.706 A:middle
The first difference is that
structures cannot inherit

00:39:27.706 --> 00:39:28.716 A:middle
from other structures.

00:39:29.716 --> 00:39:32.596 A:middle
The second difference is how
values are passed around.

00:39:32.596 --> 00:39:34.706 A:middle
So let's look at our window.

00:39:34.706 --> 00:39:37.476 A:middle
I'm going to create a window;

00:39:37.876 --> 00:39:39.386 A:middle
that means I get
the window object.

00:39:39.386 --> 00:39:42.556 A:middle
All right, now this is a
reference to that object.

00:39:43.526 --> 00:39:46.746 A:middle
But what if I declared
my window as a structure?

00:39:47.366 --> 00:39:49.656 A:middle
Well, structures
are passed by value.

00:39:49.916 --> 00:39:52.076 A:middle
That means the values are copied
when they're passed around.

00:39:52.076 --> 00:39:54.716 A:middle
So my setup function here
would get a copy of my window.

00:39:55.736 --> 00:39:56.386 A:middle
That seems weird.

00:39:56.386 --> 00:39:56.996 A:middle
What would happen?

00:39:56.996 --> 00:39:59.096 A:middle
Well, I'd probably get a
second window on screen

00:39:59.096 --> 00:40:00.456 A:middle
and that doesn't
feel right at all.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.096 --> 00:40:00.456 A:middle
and that doesn't
feel right at all.

00:40:01.376 --> 00:40:04.606 A:middle
So window, it should be a class
because classes are passed

00:40:04.666 --> 00:40:08.716 A:middle
by reference in Swift and that
means my setup function gets a

00:40:08.716 --> 00:40:10.116 A:middle
reference to the
window that I gave it,

00:40:10.116 --> 00:40:11.406 A:middle
it's a reference to this object.

00:40:11.406 --> 00:40:14.226 A:middle
OK, so that's classes.

00:40:14.226 --> 00:40:15.456 A:middle
What about structures?

00:40:16.276 --> 00:40:17.856 A:middle
Well, let's look at the
frame of the window.

00:40:18.376 --> 00:40:19.106 A:middle
It's a rectangle.

00:40:19.106 --> 00:40:22.056 A:middle
And I want to get this frame,
I want to do something to it,

00:40:22.056 --> 00:40:23.256 A:middle
and I want to use
it somewhere else.

00:40:23.596 --> 00:40:25.576 A:middle
So I'm going to extract it
into a variable, newFrame.

00:40:26.166 --> 00:40:30.726 A:middle
What happens if rectangle
was actually a class?

00:40:31.966 --> 00:40:33.346 A:middle
Well if I set the origin here,

00:40:33.346 --> 00:40:35.646 A:middle
that's actually going
to affect my window.

00:40:35.646 --> 00:40:37.106 A:middle
Clearly, that's not
want I want to do.

00:40:37.106 --> 00:40:38.666 A:middle
I just want to change this
and use it somewhere else

00:40:38.666 --> 00:40:41.676 A:middle
and it's covering up my
slide so, clearly bad.

00:40:41.676 --> 00:40:45.676 A:middle
So the window's frame is a
rectangle and the rectangle,

00:40:45.756 --> 00:40:47.616 A:middle
that should be a value
type, a structure.

00:40:48.026 --> 00:40:49.636 A:middle
Structures are passed
by value, they're copied

00:40:49.636 --> 00:40:51.386 A:middle
around when they're
passed around.

00:40:52.036 --> 00:40:53.206 A:middle
So we talked about
the difference

00:40:53.206 --> 00:40:55.326 A:middle
between reference
and value types.

00:40:55.326 --> 00:40:56.776 A:middle
Let's look at constants
and variables

00:40:56.776 --> 00:40:57.686 A:middle
with these things in mind.

00:40:58.906 --> 00:41:02.406 A:middle
Let's say I create a window
and this time I declare it


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.906 --> 00:41:02.406 A:middle
Let's say I create a window
and this time I declare it

00:41:02.406 --> 00:41:04.496 A:middle
with a let keyword, that
means I have a constant

00:41:04.496 --> 00:41:05.456 A:middle
window reference.

00:41:05.946 --> 00:41:07.096 A:middle
What does that really mean?

00:41:07.096 --> 00:41:10.436 A:middle
Well it means that I have a
reference to a window object

00:41:11.826 --> 00:41:13.946 A:middle
but the window object isn't
affected by this constant.

00:41:13.946 --> 00:41:15.186 A:middle
It's only the reference that is.

00:41:15.526 --> 00:41:18.116 A:middle
So I can still change my
window's title quite happily.

00:41:18.156 --> 00:41:19.196 A:middle
I can still set that to "Hello!"

00:41:19.196 --> 00:41:19.876 A:middle
and it just works.

00:41:20.846 --> 00:41:23.166 A:middle
But, it's a constant reference.

00:41:23.236 --> 00:41:25.716 A:middle
That means if I try and
connect this reference

00:41:25.746 --> 00:41:28.316 A:middle
to a different window I'll
get a compile time error

00:41:28.376 --> 00:41:30.246 A:middle
because I cannot mutate
a constant and I'm trying

00:41:30.246 --> 00:41:31.526 A:middle
to mutate the constant
reference here.

00:41:32.386 --> 00:41:34.226 A:middle
What about value types?

00:41:36.046 --> 00:41:36.896 A:middle
Let's start with a variable.

00:41:36.896 --> 00:41:39.766 A:middle
I'm going to create a variable
point1 and, for a value type,

00:41:39.816 --> 00:41:42.496 A:middle
try to think of it as a
big value in and of itself.

00:41:42.566 --> 00:41:43.556 A:middle
The whole thing is a value.

00:41:44.336 --> 00:41:46.106 A:middle
A point is an x and
a y coordinate,

00:41:46.326 --> 00:41:48.116 A:middle
so this point1 has an
x and a y in there.

00:41:48.936 --> 00:41:51.746 A:middle
If I change my point1.x it's
going to update that value

00:41:51.746 --> 00:41:54.306 A:middle
and set it to 5 and that's fine,
it's a variable, it can do that.

00:41:55.186 --> 00:41:58.876 A:middle
But if I use let
to declare point2,

00:41:59.706 --> 00:42:01.466 A:middle
the entire value
is now immutable.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.706 --> 00:42:01.466 A:middle
the entire value
is now immutable.

00:42:01.466 --> 00:42:02.356 A:middle
That's now constant.

00:42:02.406 --> 00:42:06.486 A:middle
That means I cannot set
point2.x, the x coordinate there

00:42:06.536 --> 00:42:08.416 A:middle
because I cannot
mutate a constant.

00:42:08.636 --> 00:42:10.116 A:middle
The entirety of that
value is constant.

00:42:11.436 --> 00:42:16.356 A:middle
Hmm. So, whether or not I can
mutate my value type depends

00:42:16.426 --> 00:42:17.986 A:middle
on the declaration used.

00:42:18.126 --> 00:42:20.716 A:middle
So what does that mean if I want
to add some kind of a method

00:42:20.716 --> 00:42:22.516 A:middle
to my Structure that,
that changes it?

00:42:23.556 --> 00:42:25.366 A:middle
Let's say I want
something that moves a point

00:42:25.606 --> 00:42:27.276 A:middle
to the right by a given number.

00:42:28.396 --> 00:42:29.806 A:middle
Well, that's changing the value.

00:42:29.806 --> 00:42:31.696 A:middle
So I shouldn't be able
to do this on a constant.

00:42:32.156 --> 00:42:35.896 A:middle
If you do want to do this then
you must declare the method is

00:42:35.896 --> 00:42:37.466 A:middle
mutating and it tells
the compiler

00:42:37.466 --> 00:42:38.966 A:middle
that you're changing
the underlying value.

00:42:39.616 --> 00:42:42.386 A:middle
That means, if you declare
a point with a constant

00:42:42.386 --> 00:42:44.106 A:middle
in this case and
you try and move it

00:42:44.106 --> 00:42:45.046 A:middle
to the right you'll get an error

00:42:45.046 --> 00:42:46.526 A:middle
because you cannot
mutate a constant.

00:42:48.476 --> 00:42:50.926 A:middle
Structures, that's one example
of a value type in Swift.

00:42:51.636 --> 00:42:53.126 A:middle
Another one is enumerations.

00:42:53.126 --> 00:42:56.466 A:middle
So enumerations in Swift can
have raw values much like C.

00:42:56.756 --> 00:42:58.156 A:middle
So here I have a
planet enumeration

00:42:58.156 --> 00:42:59.606 A:middle
and it has a raw value of Int.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:00.296 --> 00:43:02.046 A:middle
So I'm using a 1-based index.

00:43:02.046 --> 00:43:03.086 A:middle
Mercury is the first planet.

00:43:03.086 --> 00:43:03.846 A:middle
Venus is the second.

00:43:03.846 --> 00:43:06.146 A:middle
I could use 0 if I
wanted but I want 1.

00:43:07.206 --> 00:43:09.276 A:middle
So Earth must have
some, some value.

00:43:09.596 --> 00:43:11.276 A:middle
How do I determine
what that value is?

00:43:12.716 --> 00:43:14.616 A:middle
Let's create a constant,
EarthNumber, and I'm going

00:43:14.616 --> 00:43:17.856 A:middle
to set it to raw
value of Planet.Earth

00:43:17.856 --> 00:43:19.226 A:middle
and that will give
me back three.

00:43:19.316 --> 00:43:20.776 A:middle
That's how I get the
raw value back out.

00:43:21.856 --> 00:43:24.166 A:middle
So I can use integers
as an underlying value

00:43:24.606 --> 00:43:26.296 A:middle
but in Swift I can use
other types as well

00:43:26.426 --> 00:43:28.456 A:middle
such as a string or
maybe a character.

00:43:28.826 --> 00:43:30.626 A:middle
Here I can now name
the tab, linefeed,

00:43:30.626 --> 00:43:33.436 A:middle
and carriage return
characters with using an enum.

00:43:34.716 --> 00:43:36.306 A:middle
But sometimes it
doesn't make sense

00:43:36.346 --> 00:43:38.226 A:middle
to have an underlying
value at all.

00:43:39.216 --> 00:43:42.836 A:middle
Sometimes the cases are just
values in their own right.

00:43:43.146 --> 00:43:44.296 A:middle
So here I have a compass point.

00:43:44.786 --> 00:43:46.456 A:middle
It has north, south,
east and west.

00:43:47.156 --> 00:43:49.666 A:middle
There's no real number or string
that really makes sense to tie

00:43:49.716 --> 00:43:51.316 A:middle
to these so they're just values.

00:43:52.026 --> 00:43:53.106 A:middle
They're just values
in themselves.

00:43:53.106 --> 00:43:54.246 A:middle
So how do I work with them?

00:43:54.936 --> 00:43:56.056 A:middle
Let's create a directionToHead.

00:43:56.056 --> 00:43:56.656 A:middle
It's a variable.

00:43:56.656 --> 00:43:58.156 A:middle
I'm going to maybe
change that in the future.

00:43:58.156 --> 00:44:00.846 A:middle
And I'm going to set it
to CompassPoint.West.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.156 --> 00:44:00.846 A:middle
And I'm going to set it
to CompassPoint.West.

00:44:01.916 --> 00:44:04.136 A:middle
Compiler will then say
oh, it's a compass point.

00:44:04.136 --> 00:44:06.166 A:middle
So it knows that directionToHead
is a compass point.

00:44:07.166 --> 00:44:08.346 A:middle
Let's say I'm following
some directions

00:44:08.346 --> 00:44:10.036 A:middle
and I change direction,
I want to head east.

00:44:10.136 --> 00:44:10.866 A:middle
How do I saw that?

00:44:11.536 --> 00:44:14.106 A:middle
Well, because the compiler
knows that it's a compass point,

00:44:14.106 --> 00:44:16.906 A:middle
all I have to say is enough
to change that to east,

00:44:17.006 --> 00:44:18.486 A:middle
which is .east in this example.

00:44:19.186 --> 00:44:22.406 A:middle
This works extremely
well when you're working

00:44:22.406 --> 00:44:23.686 A:middle
with Cocoa Touch and Cocoa.

00:44:24.036 --> 00:44:26.426 A:middle
We've done some incredible
magic when we've imported things

00:44:26.426 --> 00:44:29.236 A:middle
over into Swift, so that if
you're dealing with a UILabel

00:44:29.276 --> 00:44:31.856 A:middle
for example and you want to set
the text alignment property,

00:44:33.346 --> 00:44:35.826 A:middle
in Objective-C you do that
with NSTextAlignment right.

00:44:35.976 --> 00:44:40.796 A:middle
But the compiler knows text
alignment is NSTextAlignment,

00:44:40.796 --> 00:44:43.306 A:middle
that is the type, so all we
need to do is supply enough

00:44:43.426 --> 00:44:44.626 A:middle
to specify that it is right.

00:44:45.216 --> 00:44:47.766 A:middle
So the text alignment is now
right, much more readable,

00:44:47.766 --> 00:44:49.946 A:middle
much more concise,
super awesome.

00:44:50.386 --> 00:44:53.156 A:middle
Enums can have raw
values, underlying values,

00:44:54.186 --> 00:44:56.886 A:middle
no values at all but there's a
different type I want to talk

00:44:56.886 --> 00:44:59.726 A:middle
about and that's enumerations
with associated values,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:00.016 --> 00:45:01.726 A:middle
neither are discriminated
unions.

00:45:01.906 --> 00:45:04.126 A:middle
So to give you an example,
let's consider a train.

00:45:04.736 --> 00:45:07.546 A:middle
Trains are usually one of two
things, they're either on time,

00:45:07.786 --> 00:45:10.196 A:middle
sometimes, or they're delayed.

00:45:11.146 --> 00:45:14.596 A:middle
If they're on time, they're just
on time but, if they're delayed,

00:45:15.156 --> 00:45:16.436 A:middle
they're delayed by
a number of minutes.

00:45:17.046 --> 00:45:20.436 A:middle
So in this case we have
(Int) after the delayed case.

00:45:20.436 --> 00:45:23.876 A:middle
And this says that I want to
be able to, to catch both,

00:45:23.876 --> 00:45:26.486 A:middle
either on time or the
delay and the number

00:45:26.486 --> 00:45:27.446 A:middle
of minutes that it's delayed.

00:45:28.046 --> 00:45:29.876 A:middle
Let's see how we work with that.

00:45:29.876 --> 00:45:32.756 A:middle
I'm going to create a status
variable and I'm going

00:45:32.756 --> 00:45:35.456 A:middle
to set it's initial value
to TrainStatus.OnTime.

00:45:35.516 --> 00:45:39.056 A:middle
The train's very optimistic,
he always starts on time but,

00:45:39.056 --> 00:45:42.856 A:middle
as we all know, sometimes stuff
happens and they get delayed

00:45:43.256 --> 00:45:46.666 A:middle
and so we can change that just
by saying, hey, it's now delayed

00:45:46.666 --> 00:45:50.646 A:middle
and we can supply the value,
42 minutes, right there.

00:45:50.826 --> 00:45:52.196 A:middle
So that's an associated value.

00:45:52.936 --> 00:45:55.876 A:middle
Very powerful but we can,
we can do more than this.

00:45:55.876 --> 00:45:58.406 A:middle
I'm going to add a little
bit more functionality

00:45:58.406 --> 00:46:01.746 A:middle
to my train status and I'm gonna
start by adding an initializer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.406 --> 00:46:01.746 A:middle
to my train status and I'm gonna
start by adding an initializer.

00:46:02.746 --> 00:46:05.366 A:middle
This means that when
I declare something

00:46:05.366 --> 00:46:08.036 A:middle
that uses this train status
it will automatically get the

00:46:08.036 --> 00:46:09.656 A:middle
onTime status by default.

00:46:09.656 --> 00:46:12.036 A:middle
I'm not going to
stop there though.

00:46:13.156 --> 00:46:15.446 A:middle
Let's add a computed
property called description.

00:46:16.806 --> 00:46:19.516 A:middle
This time I'm going to
determine what the value is

00:46:19.516 --> 00:46:22.096 A:middle
and then give back a string
that means something sensible.

00:46:22.096 --> 00:46:24.086 A:middle
So if it's on time it
will say, "On time."

00:46:24.876 --> 00:46:27.736 A:middle
If it's delayed, I'm going
to grab the number of minutes

00:46:27.736 --> 00:46:30.276 A:middle
that it's delayed by by binding
minutes in here to the number

00:46:30.276 --> 00:46:31.876 A:middle
and then I can build
a string using

00:46:31.876 --> 00:46:32.986 A:middle
that with string interpolation.

00:46:34.336 --> 00:46:36.406 A:middle
So enumerations are
hugely powerful here.

00:46:36.716 --> 00:46:38.246 A:middle
How do I work with this
thing once I've done this?

00:46:38.746 --> 00:46:40.696 A:middle
Well, now I can delay,
I can declare it

00:46:40.696 --> 00:46:42.276 A:middle
with status = TrainStatus().

00:46:42.386 --> 00:46:45.106 A:middle
That'll give me an
on-time status by default.

00:46:45.106 --> 00:46:47.466 A:middle
So if I print the description
it will say it's on time

00:46:47.706 --> 00:46:49.356 A:middle
but then it gets delayed, hmm.

00:46:49.776 --> 00:46:51.786 A:middle
And so I can set
the delay and now

00:46:51.786 --> 00:46:54.096 A:middle
when I call description it will
give me "delayed by 42 minutes".

00:46:54.726 --> 00:46:58.636 A:middle
But this status is very
much tied to a train.

00:46:59.336 --> 00:47:01.236 A:middle
It's very likely that the
only place we really use this


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.336 --> 00:47:01.236 A:middle
It's very likely that the
only place we really use this

00:47:01.236 --> 00:47:03.476 A:middle
in our app is inside
some kind of train class.

00:47:03.536 --> 00:47:05.316 A:middle
It seems a bit of shame
to have it just floating

00:47:05.316 --> 00:47:06.306 A:middle
around for anyone to use,

00:47:06.556 --> 00:47:08.766 A:middle
or at least making it super
easy for anyone to use.

00:47:09.316 --> 00:47:11.336 A:middle
Wouldn't it be nice if
we could tie our status

00:47:11.386 --> 00:47:12.856 A:middle
into the train class itself?

00:47:13.686 --> 00:47:15.686 A:middle
Well in Swift we can do
that by nesting the type.

00:47:16.356 --> 00:47:20.736 A:middle
So we can grab, we can put our
status inside the train class,

00:47:20.836 --> 00:47:21.716 A:middle
nest it right there.

00:47:21.716 --> 00:47:23.716 A:middle
So now it's just called Status
because it's inside the train.

00:47:24.216 --> 00:47:25.076 A:middle
Set up as before.

00:47:25.076 --> 00:47:27.366 A:middle
I can still have a property
on my train that is of this,

00:47:27.366 --> 00:47:29.626 A:middle
of this status and it will
be set to OnTime by default

00:47:29.936 --> 00:47:30.716 A:middle
and we can just use it.

00:47:31.426 --> 00:47:32.826 A:middle
So we can nest types in Swift.

00:47:33.466 --> 00:47:34.646 A:middle
Let's move on to more power.

00:47:35.056 --> 00:47:35.586 A:middle
I like power.

00:47:35.956 --> 00:47:36.586 A:middle
Extensions.

00:47:37.656 --> 00:47:38.676 A:middle
So an extension in Swift,

00:47:38.946 --> 00:47:40.586 A:middle
very much like a
category in Objective-C.

00:47:41.786 --> 00:47:43.076 A:middle
We can extend any Class we like.

00:47:43.746 --> 00:47:46.106 A:middle
But in Swift we can go
a little bit further.

00:47:46.236 --> 00:47:48.906 A:middle
We can actually extend
any named type we like,

00:47:49.926 --> 00:47:51.006 A:middle
including value types.

00:47:51.566 --> 00:47:53.496 A:middle
So here I have my Size
structure you saw earlier,

00:47:53.906 --> 00:47:54.486 A:middle
that's a structure.

00:47:54.486 --> 00:47:56.446 A:middle
And I'm going to add
this mutating function.

00:47:56.446 --> 00:47:58.526 A:middle
It increases the size
by a given factor

00:47:58.676 --> 00:48:00.736 A:middle
because it changes the
underlying values I've marked


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:58.676 --> 00:48:00.736 A:middle
because it changes the
underlying values I've marked

00:48:00.736 --> 00:48:01.396 A:middle
as mutating.

00:48:02.776 --> 00:48:04.026 A:middle
But I'm not just limited

00:48:04.576 --> 00:48:06.176 A:middle
to named types that
I have in Swift.

00:48:06.636 --> 00:48:09.896 A:middle
I can actually also extend
any name type I have available

00:48:09.896 --> 00:48:10.236 A:middle
to me.

00:48:10.556 --> 00:48:13.136 A:middle
So here I'm extending CGSize,
that's from Core Graphics.

00:48:13.136 --> 00:48:16.666 A:middle
It's a structure defined in C to
add the same increaseByFactor.

00:48:17.396 --> 00:48:19.256 A:middle
When I've done that,
it's available anywhere

00:48:19.366 --> 00:48:21.296 A:middle
in my Swift code
from this extension.

00:48:21.906 --> 00:48:24.316 A:middle
So that's extending
a named type.

00:48:24.316 --> 00:48:26.326 A:middle
I want to see what else
I can do with this.

00:48:27.256 --> 00:48:31.176 A:middle
Wouldn't it be fantastic if
I could extend, hmm, an Int?

00:48:32.056 --> 00:48:34.486 A:middle
Well, yes it would
and let's do that.

00:48:35.596 --> 00:48:37.636 A:middle
Int is just a structure
defined in the standard library

00:48:37.636 --> 00:48:41.626 A:middle
so I can extend it and I'm going
to add a repetitions function

00:48:41.626 --> 00:48:44.536 A:middle
to my integer and this is going
to take a task, a closure,

00:48:44.536 --> 00:48:45.966 A:middle
and it's going to
repeat it to how,

00:48:45.966 --> 00:48:49.066 A:middle
whatever value the
integer is, 0..self,

00:48:49.206 --> 00:48:51.226 A:middle
that will give me the number
of repetitions I need.

00:48:52.346 --> 00:48:54.606 A:middle
So now I can supply
closure on the call

00:48:54.606 --> 00:48:57.006 A:middle
to repetitions on
any integer value.

00:48:57.596 --> 00:49:00.366 A:middle
So I can say, for
example, 500.repetitions


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:57.596 --> 00:49:00.366 A:middle
So I can say, for
example, 500.repetitions

00:49:00.366 --> 00:49:02.296 A:middle
and then supply closure
and I'll get "Hello!"

00:49:02.296 --> 00:49:03.306 A:middle
printed 500 times [applause].

00:49:03.946 --> 00:49:04.466 A:middle
But there's more.

00:49:06.006 --> 00:49:09.126 A:middle
Because, because the
closure is the last argument

00:49:09.606 --> 00:49:13.426 A:middle
in this function call, I can
hoist it out, put it outside

00:49:13.426 --> 00:49:15.216 A:middle
of the parentheses
and, you know what?

00:49:15.286 --> 00:49:18.676 A:middle
For training closures, if there
are no other arguments I don't

00:49:18.676 --> 00:49:20.006 A:middle
even need the parentheses.

00:49:20.106 --> 00:49:20.666 A:middle
So this turns

00:49:20.666 --> 00:49:24.366 A:middle
into 500.repetitions do this
thing like Control Flow.

00:49:25.036 --> 00:49:27.606 A:middle
So I just extended an
Int, a value type Int

00:49:27.606 --> 00:49:28.346 A:middle
from the Standard Library.

00:49:28.346 --> 00:49:29.146 A:middle
How amazing is that?

00:49:29.626 --> 00:49:32.086 A:middle
And as we head more into kind
of blow your mind territory,

00:49:32.086 --> 00:49:35.466 A:middle
I'm going to leave you with one
more thing and that's generics.

00:49:36.466 --> 00:49:38.306 A:middle
So let's start with a
non-generic example.

00:49:39.816 --> 00:49:42.236 A:middle
Here I have a stack of
integers, it's an IntStack.

00:49:43.426 --> 00:49:45.196 A:middle
And I can push values
onto the stack

00:49:45.196 --> 00:49:48.246 A:middle
and I can pop them off again and
that's, that's great but what

00:49:48.246 --> 00:49:50.546 A:middle
if I wanted a double
stack or a string stack?

00:49:50.726 --> 00:49:51.986 A:middle
Or, hell, even a
stack of stacks?

00:49:52.326 --> 00:49:53.736 A:middle
How would I, how would
I, how would I do that?

00:49:54.246 --> 00:49:57.426 A:middle
Well, I'd have to duplicate
this definition multiple times

00:49:57.426 --> 00:49:58.806 A:middle
and the only thing I would
change would be these

00:49:58.886 --> 00:50:00.986 A:middle
highlighted bits, the
Ints across there.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:58.886 --> 00:50:00.986 A:middle
highlighted bits, the
Ints across there.

00:50:00.986 --> 00:50:04.136 A:middle
That's the types used for the
Array and the two functions

00:50:04.136 --> 00:50:05.026 A:middle
that I have, the two methods.

00:50:06.386 --> 00:50:08.196 A:middle
Wouldn't it be lovely if I
could just say, you know this,

00:50:08.336 --> 00:50:09.766 A:middle
this should work
with any type at all?

00:50:10.396 --> 00:50:13.256 A:middle
We can do that with a generic.

00:50:13.816 --> 00:50:15.706 A:middle
So generics in Swift,
you indicate the type

00:50:15.826 --> 00:50:18.296 A:middle
with these angle
brackets and so &lt;T&gt;

00:50:18.456 --> 00:50:20.896 A:middle
that says there is a
generic-type parameter here

00:50:21.056 --> 00:50:24.006 A:middle
and anything that uses this
T, that must be the same type.

00:50:24.746 --> 00:50:26.906 A:middle
So elements is just
an array of Ts.

00:50:27.676 --> 00:50:30.036 A:middle
Push now takes a T,
pop now returns a T.

00:50:30.576 --> 00:50:31.096 A:middle
What does that mean?

00:50:31.736 --> 00:50:34.816 A:middle
It means that we can now build
our stack of Ints like this.

00:50:34.816 --> 00:50:37.856 A:middle
We can just say create
stack of Ints, push on 50,

00:50:37.856 --> 00:50:39.126 A:middle
notice I'm not specifying
anything

00:50:39.126 --> 00:50:41.776 A:middle
and here the compiler knows
that push must take an integer

00:50:41.876 --> 00:50:42.786 A:middle
if it's a stack of Ints.

00:50:42.956 --> 00:50:43.886 A:middle
So I'm pushing 50 on.

00:50:44.236 --> 00:50:47.376 A:middle
I can pop that off and it knows
that lastIn will be of type Int

00:50:47.416 --> 00:50:48.726 A:middle
because that's what
I'm dealing with.

00:50:49.186 --> 00:50:49.816 A:middle
What about strings?

00:50:49.816 --> 00:50:51.876 A:middle
Well, I can use this
with a string as well,

00:50:51.876 --> 00:50:55.556 A:middle
so now I can create a string of,
uh, a stack of strings and push

00:50:55.556 --> 00:50:57.816 A:middle
on a string, again, compiler
knows it can only work

00:50:57.816 --> 00:50:59.496 A:middle
with a string and when
I pop it off it knows

00:50:59.496 --> 00:51:01.346 A:middle
that I'm returning a string,
therefore I can print it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.496 --> 00:51:01.346 A:middle
that I'm returning a string,
therefore I can print it.

00:51:02.656 --> 00:51:03.406 A:middle
So that's generics.

00:51:03.406 --> 00:51:05.766 A:middle
It's a very, very brief
introduction to generics.

00:51:06.166 --> 00:51:08.186 A:middle
To get further details on all

00:51:08.186 --> 00:51:10.206 A:middle
of the awesome stuff you can
do you should check out the

00:51:10.206 --> 00:51:10.986 A:middle
"Advanced Swift" talk.

00:51:12.346 --> 00:51:13.816 A:middle
That brings me on
to a question then.

00:51:14.546 --> 00:51:16.086 A:middle
How do you learn Swift?

00:51:16.086 --> 00:51:19.316 A:middle
How do you go and figure out
all the cool stuff you can do

00:51:19.316 --> 00:51:19.966 A:middle
with this language?

00:51:20.566 --> 00:51:23.996 A:middle
Well, as we saw up front,
this book is available.

00:51:23.996 --> 00:51:25.486 A:middle
It's in the Doc Viewer,
it's online.

00:51:25.856 --> 00:51:27.106 A:middle
It's available in
the iBooks Store.

00:51:27.106 --> 00:51:29.096 A:middle
The Swift Programming Languages:
it's the canonical guide

00:51:29.096 --> 00:51:30.236 A:middle
and reference to the language.

00:51:31.566 --> 00:51:34.686 A:middle
We also have Using Swift
with Cocoa and Objective-C.

00:51:34.686 --> 00:51:36.746 A:middle
This is a document that tells
you how to work with Cocoa

00:51:36.746 --> 00:51:38.296 A:middle
and Objective-C from
existing code,

00:51:39.026 --> 00:51:40.316 A:middle
how Swift interoperates
with Cocoa.

00:51:40.316 --> 00:51:42.956 A:middle
For more information
on the language itself,

00:51:43.616 --> 00:51:45.686 A:middle
check out the intermediate
and advanced Swift talks.

00:51:45.826 --> 00:51:47.536 A:middle
And for more information
on Objective-C

00:51:47.536 --> 00:51:50.276 A:middle
and interoperability, check
out the two "Interoperability

00:51:50.616 --> 00:51:52.916 A:middle
in Depth" and "Integrating
Swift with Objective-C" talks.

00:51:53.806 --> 00:51:54.946 A:middle
We are in labs all week.

00:51:55.166 --> 00:51:56.346 A:middle
Come down, tell us
what you think.

00:51:56.346 --> 00:51:57.466 A:middle
We want to hear your questions.

00:51:57.976 --> 00:52:00.586 A:middle
If you're playing along at home,
talk to this guy, Dave DeLong.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:57.976 --> 00:52:00.586 A:middle
If you're playing along at home,
talk to this guy, Dave DeLong.

00:52:00.586 --> 00:52:01.396 A:middle
He's our evangelist.

00:52:01.966 --> 00:52:03.056 A:middle
Check out Developer Forums.

00:52:03.056 --> 00:52:03.706 A:middle
Thank you very much.

00:52:03.866 --> 00:52:04.846 A:middle
That is Swift.

00:52:05.516 --> 00:52:12.310 A:middle
[ Applause ]

