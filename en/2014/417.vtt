WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:12.356 --> 00:00:13.336 A:middle
&gt;&gt; Good morning!

00:00:13.616 --> 00:00:13.796 A:middle
Welcome!

00:00:14.516 --> 00:00:17.136 A:middle
[ Applause ]

00:00:17.636 --> 00:00:20.886 A:middle
Glad to see a number of folks
out now, bright and early,

00:00:20.886 --> 00:00:23.906 A:middle
to talk about all the
heart-pounding excitement

00:00:23.906 --> 00:00:25.276 A:middle
in the world of compilers.

00:00:26.026 --> 00:00:31.396 A:middle
And I'm Jim Grosbach, and I'm
really happy to be here today

00:00:31.396 --> 00:00:35.746 A:middle
to share with you all of the
new things that we have in LLVM.

00:00:37.106 --> 00:00:42.226 A:middle
When we normally talk about LLVM
and what first comes to mind

00:00:42.226 --> 00:00:46.296 A:middle
when we think about it is the
Apple LLVM Compiler itself.

00:00:46.646 --> 00:00:51.146 A:middle
This is what we all use to
build our apps and that's

00:00:51.146 --> 00:00:53.276 A:middle
where we really first
encounter LLVM,

00:00:53.966 --> 00:00:57.136 A:middle
but it's much more than that.

00:00:57.886 --> 00:01:03.266 A:middle
LLVM is used in a wide
variety of products and tools


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.886 --> 00:01:03.266 A:middle
LLVM is used in a wide
variety of products and tools

00:01:03.766 --> 00:01:09.436 A:middle
that we all use every day, both
as developers and as end users.

00:01:10.866 --> 00:01:16.326 A:middle
Over the years LLVM has grown to
be a really key technology here

00:01:16.326 --> 00:01:19.566 A:middle
at Apple for building
tools, for performance,

00:01:20.146 --> 00:01:25.996 A:middle
and for modernization, and that
has been no exception this year

00:01:26.496 --> 00:01:28.276 A:middle
as we have moved swiftly along

00:01:29.226 --> 00:01:32.106 A:middle
with a wide variety
of new improvements.

00:01:33.666 --> 00:01:38.806 A:middle
To start with, back in September
we introduced the Apple A7

00:01:38.806 --> 00:01:43.086 A:middle
processor which has been
just absolutely magnificent

00:01:43.206 --> 00:01:44.516 A:middle
in what it's allowed us to do,

00:01:44.826 --> 00:01:47.366 A:middle
bringing truly desktop-class
performance

00:01:48.076 --> 00:01:53.166 A:middle
to your mobile devices and
LLVM plays a key role in this.

00:01:54.226 --> 00:01:59.546 A:middle
And now we're encouraging more
of you to use this technology

00:01:59.546 --> 00:02:03.396 A:middle
in your apps, so
building for 64-bit


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.546 --> 00:02:03.396 A:middle
in your apps, so
building for 64-bit

00:02:03.676 --> 00:02:05.546 A:middle
in iOS is now the default.

00:02:05.626 --> 00:02:09.515 A:middle
As of Xcode 5.1 carrying
on into Xcode 6,

00:02:10.235 --> 00:02:11.546 A:middle
when you rebuild your app,

00:02:12.486 --> 00:02:14.146 A:middle
if you're using standard
architectures,

00:02:14.616 --> 00:02:16.676 A:middle
ARM64 will be included.

00:02:17.406 --> 00:02:19.926 A:middle
This does not impact
your deployment story.

00:02:19.926 --> 00:02:23.466 A:middle
You can continue to
deploy back to iOS 4.3.

00:02:23.466 --> 00:02:26.786 A:middle
We still build for
arm V7 for 32 bit.

00:02:27.626 --> 00:02:30.546 A:middle
All of the development work
flows that you're familiar

00:02:30.546 --> 00:02:34.346 A:middle
with for the simulator,
the debugger, profiling,

00:02:34.916 --> 00:02:38.066 A:middle
all of these things continue
to work transparently,

00:02:38.526 --> 00:02:41.636 A:middle
just as you're familiar with
in a 64-bit environment.

00:02:42.506 --> 00:02:44.926 A:middle
Now, one thing to be aware of is

00:02:44.926 --> 00:02:49.166 A:middle
that because ARM64 is an
entirely new architecture,

00:02:49.856 --> 00:02:52.786 A:middle
your entire application
must be built 64 bit,

00:02:53.256 --> 00:02:54.826 A:middle
not just a few libraries here,

00:02:54.826 --> 00:02:57.526 A:middle
or a few files there,
but the whole app.

00:02:57.746 --> 00:03:00.586 A:middle
So, if you're relying
on third-party libraries


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:57.746 --> 00:03:00.586 A:middle
So, if you're relying
on third-party libraries

00:03:01.286 --> 00:03:05.416 A:middle
and those libraries have
not yet adopted 64 bit,

00:03:06.036 --> 00:03:10.506 A:middle
please work with your vendors
and encourage them to update

00:03:10.746 --> 00:03:12.796 A:middle
and support 64 bit development

00:03:13.146 --> 00:03:16.276 A:middle
so that your app
can then migrate

00:03:16.276 --> 00:03:18.116 A:middle
as well and get the benefits.

00:03:18.666 --> 00:03:22.526 A:middle
Now, during migration there
are a few things that we'd

00:03:22.526 --> 00:03:26.426 A:middle
like to bring to your
attention that might come up,

00:03:26.426 --> 00:03:29.586 A:middle
a few advancements we've
made, and a few things

00:03:29.586 --> 00:03:31.676 A:middle
that we've tightened
up in the specification

00:03:31.806 --> 00:03:35.406 A:middle
and what the possible
impact of that tier app is.

00:03:35.956 --> 00:03:42.556 A:middle
To start with, in 64-bit iOS all
functions must have a prototype.

00:03:43.096 --> 00:03:47.116 A:middle
This has been good style
since time immemorial

00:03:47.596 --> 00:03:51.496 A:middle
and it's been required
for C++ since the start.

00:03:51.886 --> 00:03:55.156 A:middle
It's been highly suggested in C,

00:03:55.276 --> 00:03:58.636 A:middle
for any modern version not
using a prototype is deprecated

00:03:59.306 --> 00:04:01.976 A:middle
and has been for a
very long time now.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.306 --> 00:04:01.976 A:middle
and has been for a
very long time now.

00:04:03.206 --> 00:04:06.546 A:middle
So, we've taken advantage
of this in ARM64

00:04:06.986 --> 00:04:10.156 A:middle
to generate more efficient
calling convention code,

00:04:10.396 --> 00:04:12.866 A:middle
in particular for variatic
functions like printf,

00:04:12.866 --> 00:04:14.866 A:middle
that the number of arguments

00:04:15.166 --> 00:04:17.476 A:middle
to the function varies
by call site.

00:04:18.995 --> 00:04:21.805 A:middle
So, when you have older
code that you're using

00:04:21.805 --> 00:04:23.356 A:middle
that may not use prototypes,

00:04:24.176 --> 00:04:27.496 A:middle
what is normally a warning has
now been promoted to an error,

00:04:27.496 --> 00:04:31.646 A:middle
so the compiler will highlight
to you in your code exactly

00:04:31.736 --> 00:04:35.766 A:middle
where this is happening so
that you know which prototypes

00:04:35.766 --> 00:04:38.156 A:middle
to go add to your
header files to move on.

00:04:39.796 --> 00:04:42.786 A:middle
One place that this
does sometimes come

00:04:42.786 --> 00:04:46.556 A:middle
up in a little bit more
of a subtle way is when C

00:04:46.556 --> 00:04:50.116 A:middle
and Objective-C interworking
code with direct indications

00:04:50.116 --> 00:04:51.816 A:middle
of Objective-C message send.

00:04:52.466 --> 00:04:54.946 A:middle
To help find this, we
have a new Xcode setting

00:04:55.536 --> 00:04:58.896 A:middle
to enable strict checking
of objc underscore msgSend.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.366 --> 00:05:01.706 A:middle
This is a recommended setting

00:05:02.796 --> 00:05:05.236 A:middle
and when you first
upgrade your project

00:05:05.236 --> 00:05:07.396 A:middle
to [inaudible] code
6 we'll encourage you

00:05:07.506 --> 00:05:08.546 A:middle
to adopt this setting.

00:05:08.546 --> 00:05:12.926 A:middle
And what's tricky is
that every indication

00:05:12.926 --> 00:05:15.816 A:middle
of objc underscore
msgSend effectively has a

00:05:15.816 --> 00:05:16.636 A:middle
different type.

00:05:17.466 --> 00:05:22.196 A:middle
It has the type of what the
final receiving method is going

00:05:22.196 --> 00:05:22.646 A:middle
to be.

00:05:23.696 --> 00:05:26.566 A:middle
For example here,
a trivial piece

00:05:26.566 --> 00:05:29.906 A:middle
of code that's invoking
method foo,

00:05:31.046 --> 00:05:36.446 A:middle
with strict checking enabled,
the compiler will now tell us

00:05:36.576 --> 00:05:40.236 A:middle
that we need to tell it
what the final type is.

00:05:41.136 --> 00:05:42.466 A:middle
This is straightforward to do.

00:05:42.466 --> 00:05:44.956 A:middle
It's a little bit verbose,
but very straightforward.

00:05:44.956 --> 00:05:47.736 A:middle
We simply add the type of
the final receiving method.

00:05:48.146 --> 00:05:49.406 A:middle
Done it here with a typedef.

00:05:49.446 --> 00:05:52.856 A:middle
This could be done with a direct
type test on all on one line,

00:05:52.856 --> 00:05:54.866 A:middle
if you prefer, just to make sure

00:05:54.866 --> 00:05:57.646 A:middle
that the compiler knows what
the final receiving type

00:05:57.646 --> 00:06:01.046 A:middle
of the method is so that it
can generate the right code


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:57.646 --> 00:06:01.046 A:middle
of the method is so that it
can generate the right code

00:06:01.296 --> 00:06:02.926 A:middle
to get the final result correct.

00:06:05.016 --> 00:06:08.296 A:middle
Another place that we've
tightened things up

00:06:08.296 --> 00:06:09.916 A:middle
and taken advantage
of our new ABI

00:06:09.916 --> 00:06:13.856 A:middle
and ARM64 is the
Objective-C Boolean type.

00:06:14.276 --> 00:06:17.776 A:middle
If any of you were at <i>Stump
the Experts </i>last night,

00:06:17.776 --> 00:06:19.916 A:middle
this topic actually
came up as a question.

00:06:20.396 --> 00:06:23.306 A:middle
It was rather amusing like,
"I have a slide on that!

00:06:23.456 --> 00:06:25.116 A:middle
That'll be great!"

00:06:25.116 --> 00:06:27.596 A:middle
So, BOOL is basically
now a BOOL type.

00:06:28.716 --> 00:06:31.666 A:middle
Previously, it's been
a signed character.

00:06:32.156 --> 00:06:36.726 A:middle
And, sometimes our code -- our
code as well, not just in yours,

00:06:37.326 --> 00:06:39.756 A:middle
would put values
into the Boolean type

00:06:39.786 --> 00:06:41.876 A:middle
that weren't strictly Boolean.

00:06:42.946 --> 00:06:46.606 A:middle
Now, the compiler is going to
be taking advantage of this type

00:06:46.606 --> 00:06:48.796 A:middle
or definition, so
what can happen is

00:06:48.796 --> 00:06:52.346 A:middle
that if your code does that,
the results between 32-bit iOS

00:06:52.696 --> 00:06:55.106 A:middle
and 64-bit iOS may differ.

00:06:56.046 --> 00:06:59.066 A:middle
So, if you start seeing some
odd behaviors with Booleans,

00:06:59.366 --> 00:07:03.326 A:middle
this is something
to look out for.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.366 --> 00:07:03.326 A:middle
this is something
to look out for.

00:07:04.946 --> 00:07:06.296 A:middle
We also have pointers.

00:07:07.516 --> 00:07:10.196 A:middle
As we're now 64-bit
architecture, this is kind

00:07:10.196 --> 00:07:12.666 A:middle
of the core of what this
is all about, that pointers

00:07:12.666 --> 00:07:14.266 A:middle
and longs are now 64 bits.

00:07:15.226 --> 00:07:19.146 A:middle
So, old code would
often do horrible things

00:07:19.146 --> 00:07:21.916 A:middle
like casting integers to
pointers, and back-and-forth.

00:07:22.866 --> 00:07:25.286 A:middle
And hopefully, we don't write
code that does that anymore,

00:07:25.286 --> 00:07:28.026 A:middle
but we all have this legacy
code that we have to live with,

00:07:29.076 --> 00:07:32.176 A:middle
and now this can bite
us if we're not careful.

00:07:32.486 --> 00:07:34.736 A:middle
This is very similar
to what we've all dealt

00:07:34.736 --> 00:07:38.876 A:middle
with on the 32-bit to
64-bit Intel transition,

00:07:38.876 --> 00:07:39.816 A:middle
if we went through that.

00:07:40.616 --> 00:07:41.496 A:middle
That's still a problem;

00:07:41.496 --> 00:07:43.826 A:middle
we haven't magically just
solved that in the compiler.

00:07:44.886 --> 00:07:48.946 A:middle
So for example here, we're
casting an integer which came

00:07:48.946 --> 00:07:50.106 A:middle
from a pointer somewhere else.

00:07:50.106 --> 00:07:51.816 A:middle
We're casting that to a void.

00:07:51.816 --> 00:07:55.186 A:middle
But now the compiler
can help a little bit.

00:07:55.186 --> 00:08:00.196 A:middle
It can at least inform us
that the problem is coming up


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:55.186 --> 00:08:00.196 A:middle
It can at least inform us
that the problem is coming up

00:08:00.196 --> 00:08:03.636 A:middle
and tell us that, "Oh, we have a
problem here that we need to go

00:08:03.636 --> 00:08:04.606 A:middle
and look at and make sure

00:08:04.606 --> 00:08:06.796 A:middle
that this is really
what's happening."

00:08:07.596 --> 00:08:09.176 A:middle
Now, if we ignore this warning,

00:08:09.796 --> 00:08:12.656 A:middle
the runtime in the
kernel is going

00:08:12.656 --> 00:08:15.036 A:middle
to be a little bit more
forceful about this.

00:08:15.606 --> 00:08:19.116 A:middle
If we dereference that pointer
we're going to get a hard fault

00:08:19.916 --> 00:08:22.936 A:middle
because the page zero is
mapped to always give a fault

00:08:22.936 --> 00:08:26.236 A:middle
so if we miss any of these
through other warnings,

00:08:26.806 --> 00:08:27.916 A:middle
we'll still get an error.

00:08:28.406 --> 00:08:29.696 A:middle
Paying attention
to the compiler,

00:08:29.696 --> 00:08:32.106 A:middle
it's going to be a lot
friendlier because it'll be nice

00:08:32.106 --> 00:08:34.515 A:middle
and friendly and tell you the
line number and the source file

00:08:34.576 --> 00:08:35.496 A:middle
for where the problem is.

00:08:35.716 --> 00:08:37.756 A:middle
The kernel's just going to
tell you you did something bad.

00:08:39.246 --> 00:08:43.666 A:middle
To address this we use
the C language typedefs

00:08:44.456 --> 00:08:46.776 A:middle
that are 64 and 32-bit cleaned.

00:08:46.776 --> 00:08:49.596 A:middle
We say we want a signed
integer, an unsigned integer,

00:08:49.816 --> 00:08:53.086 A:middle
that is an appropriate type
for saving a pointer value

00:08:53.386 --> 00:08:55.306 A:middle
or for indexing into an array

00:08:55.746 --> 00:08:58.466 A:middle
for comparing the differences
between two pointers.

00:08:59.446 --> 00:09:02.026 A:middle
For example, if we would
modify our previous code


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.446 --> 00:09:02.026 A:middle
For example, if we would
modify our previous code

00:09:02.026 --> 00:09:05.566 A:middle
to simply use the intptr type,
which when we're compiling

00:09:05.566 --> 00:09:08.726 A:middle
for 32-bit iOS, will we
get 32-bit signed integer,

00:09:09.126 --> 00:09:13.726 A:middle
and for 64-bit iOS will be
a 64-bit signed integer.

00:09:14.456 --> 00:09:18.686 A:middle
Slightly more subtly, this can
come up in structure layouts.

00:09:19.496 --> 00:09:23.266 A:middle
When we use a long or pointer
these now grow, which change

00:09:23.636 --> 00:09:26.236 A:middle
but the size and
sometimes the alignment,

00:09:26.236 --> 00:09:28.836 A:middle
the offsets of other
fields in our structures.

00:09:29.486 --> 00:09:30.576 A:middle
And, we have to be careful

00:09:30.576 --> 00:09:32.646 A:middle
that this is done in
a way that's safe.

00:09:33.876 --> 00:09:36.586 A:middle
Now, most of time this is
going to work transparently,

00:09:36.586 --> 00:09:38.856 A:middle
because these structures
are used entirely

00:09:38.856 --> 00:09:40.236 A:middle
within our application

00:09:40.236 --> 00:09:42.926 A:middle
and everything gets the new
definition and works fine.

00:09:44.146 --> 00:09:46.806 A:middle
But, if we're doing something
like a representation

00:09:46.806 --> 00:09:50.556 A:middle
of an on-disk file format
communicating across a network

00:09:50.556 --> 00:09:54.436 A:middle
to another process that is going
to rely on the exact layout

00:09:54.436 --> 00:09:58.056 A:middle
of a structure, that
can go badly.

00:09:58.056 --> 00:10:01.086 A:middle
So again, on any of those
data structures we want


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.056 --> 00:10:01.086 A:middle
So again, on any of those
data structures we want

00:10:01.086 --> 00:10:07.496 A:middle
to use the C fixed type,
fixed size types to make sure

00:10:07.496 --> 00:10:09.316 A:middle
that we get what we want,
whether we're building

00:10:09.316 --> 00:10:12.876 A:middle
for 64-bit iOS or
for 32-bit iOS.

00:10:14.756 --> 00:10:18.166 A:middle
So in summary, building
for 64-bit iOS is easy,

00:10:18.636 --> 00:10:23.596 A:middle
it's a default, and the
compiler will help find

00:10:23.596 --> 00:10:25.136 A:middle
and resolve any issues.

00:10:26.116 --> 00:10:29.736 A:middle
But, this isn't the only
thing that we've been up to.

00:10:29.816 --> 00:10:33.056 A:middle
We've also been making
advances in Objective-C

00:10:34.086 --> 00:10:36.596 A:middle
and the compiler
can help here, too.

00:10:37.996 --> 00:10:39.906 A:middle
The language has
continued to move forward.

00:10:40.386 --> 00:10:43.166 A:middle
Some of this really helps with
the interoperability with SWF

00:10:43.286 --> 00:10:46.006 A:middle
as well, as you may be
seeing in that talk.

00:10:46.006 --> 00:10:47.656 A:middle
I highly encourage
you to check it out.

00:10:47.656 --> 00:10:50.116 A:middle
It's happening at the same time
as this one, so go and look

00:10:50.116 --> 00:10:53.516 A:middle
on the video when that
comes on the WWDC app.

00:10:53.566 --> 00:10:59.776 A:middle
And, whenever we write new
code, we've been using all

00:10:59.776 --> 00:11:02.046 A:middle
of these advancements
in the language


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.776 --> 00:11:02.046 A:middle
of these advancements
in the language

00:11:02.626 --> 00:11:05.436 A:middle
to get the modern best
practices, more expressive code,

00:11:05.436 --> 00:11:10.386 A:middle
but then we have all of this
older legacy code that we'd

00:11:10.386 --> 00:11:12.776 A:middle
like to adopt all of these
features in, as well.

00:11:13.026 --> 00:11:15.436 A:middle
But, that's a lot of
code to go read through

00:11:15.436 --> 00:11:19.216 A:middle
and manually find all of these
things, so we have a tool

00:11:19.216 --> 00:11:22.196 A:middle
that will help us
identify the opportunities

00:11:22.746 --> 00:11:24.686 A:middle
where we can use
these new features.

00:11:24.926 --> 00:11:28.496 A:middle
And, I think the best
way to talk about that is

00:11:28.496 --> 00:11:32.066 A:middle
to show you with the demo.

00:11:32.686 --> 00:11:37.576 A:middle
Now, rather than use some
contrived example code here,

00:11:37.576 --> 00:11:39.376 A:middle
I thought we'd maybe
look at something

00:11:39.376 --> 00:11:40.966 A:middle
that we all are familiar with,

00:11:40.966 --> 00:11:44.326 A:middle
at least as users,
and our WWDC app.

00:11:45.236 --> 00:11:47.246 A:middle
That code has been
with us for a while.

00:11:47.246 --> 00:11:48.696 A:middle
We update it every year.

00:11:49.126 --> 00:11:53.326 A:middle
And, with the modernizer we
wanted to use that to look at it

00:11:53.326 --> 00:11:55.986 A:middle
and find out if there
are perhaps some places

00:11:55.986 --> 00:11:58.486 A:middle
in the codebase that we
missed for opportunities

00:11:59.496 --> 00:12:01.516 A:middle
to use new Objective-C features.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.496 --> 00:12:01.516 A:middle
to use new Objective-C features.

00:12:02.396 --> 00:12:04.786 A:middle
So, let's look and
see what a few

00:12:04.786 --> 00:12:06.396 A:middle
of those things that
we found are.

00:12:06.876 --> 00:12:11.246 A:middle
If we go under Edit to refactor,
we can convert our project

00:12:11.356 --> 00:12:13.246 A:middle
to modern Objective-C syntax.

00:12:14.136 --> 00:12:16.796 A:middle
We get a dialog box telling
us what we've just selected,

00:12:16.896 --> 00:12:18.676 A:middle
so make sure that we've
got the right thing.

00:12:20.476 --> 00:12:21.486 A:middle
We can select whether --

00:12:21.566 --> 00:12:23.886 A:middle
which targets in our
project to modernize.

00:12:23.886 --> 00:12:26.876 A:middle
In this case, we're looking
at the WWDC app, itself.

00:12:27.476 --> 00:12:32.406 A:middle
In the previous versions of
Xcode the modernizer would go

00:12:32.466 --> 00:12:33.716 A:middle
through and just look

00:12:33.806 --> 00:12:36.246 A:middle
for Objective-C literals
and subscripting.

00:12:36.246 --> 00:12:38.596 A:middle
But now, we have more options.

00:12:39.606 --> 00:12:42.476 A:middle
Now personally, I prefer not
to do all of these at once.

00:12:42.476 --> 00:12:45.566 A:middle
That tends to be a little too
much to swap back-and-forth,

00:12:45.596 --> 00:12:48.156 A:middle
so I tend to want to
select a few things.

00:12:48.446 --> 00:12:51.616 A:middle
I'm going to look for
instance type here

00:12:51.616 --> 00:12:53.866 A:middle
that we can get our
initialization methods more

00:12:53.866 --> 00:12:54.616 A:middle
strongly typed.

00:12:54.616 --> 00:12:58.596 A:middle
I'm going to try and find if we
missed any read/write properties

00:12:58.596 --> 00:13:01.726 A:middle
where we convert explicit
getter/setter methods.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.596 --> 00:13:01.726 A:middle
where we convert explicit
getter/setter methods.

00:13:02.316 --> 00:13:05.116 A:middle
And, we're going to
look to use NS ENUM

00:13:05.496 --> 00:13:08.766 A:middle
for our enumeration values
so the compiler can cooperate

00:13:08.766 --> 00:13:11.156 A:middle
with the runtime to
give better results.

00:13:12.246 --> 00:13:16.736 A:middle
Click Next, and the compiler
will run over our code

00:13:16.986 --> 00:13:20.216 A:middle
and it turns out we do, indeed,
have a few more suggestions

00:13:20.216 --> 00:13:21.506 A:middle
for what we can look at.

00:13:22.176 --> 00:13:25.016 A:middle
Now, do keep in mind that
these are just suggestions,

00:13:25.866 --> 00:13:27.406 A:middle
that we need to go
through and look

00:13:27.406 --> 00:13:30.656 A:middle
at the side-by-side diff here,
where we have the new code

00:13:30.656 --> 00:13:35.026 A:middle
on the left, the old code on the
right, and we look through here.

00:13:35.026 --> 00:13:36.226 A:middle
This looks fine.

00:13:36.926 --> 00:13:38.196 A:middle
Everything looks good here.

00:13:38.196 --> 00:13:39.556 A:middle
We're converting to ENUMS.

00:13:40.066 --> 00:13:42.096 A:middle
Let's look at our next one.

00:13:42.936 --> 00:13:46.036 A:middle
This looks a little
bit different,

00:13:46.036 --> 00:13:50.686 A:middle
because we still have this NS
integer over here that looks

00:13:50.686 --> 00:13:52.196 A:middle
like it'd be straightforward
to clean up,

00:13:52.196 --> 00:13:54.116 A:middle
but I'd rather come
back to this later.

00:13:54.116 --> 00:13:55.076 A:middle
I just want to deal
with the things

00:13:55.076 --> 00:13:56.756 A:middle
that we can do automatically
right now.

00:13:57.416 --> 00:14:00.546 A:middle
So, I tell the modernizer
to discard that change.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:57.416 --> 00:14:00.546 A:middle
So, I tell the modernizer
to discard that change.

00:14:00.996 --> 00:14:03.396 A:middle
It wants to make sure
that I'm doing that.

00:14:03.396 --> 00:14:04.966 A:middle
Yes, I am absolutely sure.

00:14:04.966 --> 00:14:07.396 A:middle
I can do the same here.

00:14:08.876 --> 00:14:11.646 A:middle
We could also tell it to ignore
all of the changes in this file

00:14:11.646 --> 00:14:12.846 A:middle
with this Check button here.

00:14:13.406 --> 00:14:16.366 A:middle
And now, it's also found a place

00:14:17.026 --> 00:14:18.396 A:middle
where we can use
an instance type.

00:14:18.696 --> 00:14:23.296 A:middle
And, that all looks good
so we tell it to save.

00:14:24.236 --> 00:14:26.086 A:middle
And, Xcode will now
tell us that, "Oh!

00:14:26.086 --> 00:14:29.926 A:middle
We can update our project as
well, and take snapshots."

00:14:30.376 --> 00:14:31.416 A:middle
That sounds great.

00:14:31.416 --> 00:14:33.216 A:middle
Let's let it do that
because backups are good.

00:14:33.216 --> 00:14:36.476 A:middle
And now, our project is
saved, it's been rebuilt,

00:14:37.286 --> 00:14:42.416 A:middle
and the Objective-C modernizer
works to update our code

00:14:42.416 --> 00:14:45.026 A:middle
and help us find places
where we can take advantage

00:14:45.326 --> 00:14:46.216 A:middle
of new features.

00:14:46.846 --> 00:14:51.046 A:middle
But, this isn't the only
place that we've made advances

00:14:51.616 --> 00:14:55.086 A:middle
for Objective-C and
for interoperability.

00:14:55.136 --> 00:14:58.886 A:middle
And, to tell you more about that
I'd like to invite my friend

00:14:58.886 --> 00:15:00.036 A:middle
and coworker, Bob Wilson.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.886 --> 00:15:00.036 A:middle
and coworker, Bob Wilson.

00:15:00.246 --> 00:15:01.066 A:middle
Thank you, Bob.

00:15:02.516 --> 00:15:07.576 A:middle
[ Applause ]

00:15:08.076 --> 00:15:08.516 A:middle
&gt;&gt; Thank you, Jim.

00:15:10.186 --> 00:15:12.006 A:middle
So, modules are another way

00:15:12.096 --> 00:15:14.476 A:middle
that LLVM can help
modernize your code.

00:15:14.726 --> 00:15:18.066 A:middle
We introduced modules just last
year, but in cases you missed

00:15:18.066 --> 00:15:19.786 A:middle
that let's start
with some background.

00:15:22.056 --> 00:15:24.896 A:middle
So, before modules we
had precompiled headers,

00:15:25.136 --> 00:15:28.556 A:middle
which are often an effective
way to speed up the compilation

00:15:28.556 --> 00:15:31.286 A:middle
of your code, but they
do have some limitations.

00:15:32.196 --> 00:15:35.606 A:middle
You can only have one
precompiled header at a time,

00:15:36.516 --> 00:15:39.536 A:middle
and more importantly,
the whole approach

00:15:39.536 --> 00:15:43.156 A:middle
of using a textual inclusion
of a header file as a way

00:15:43.156 --> 00:15:45.846 A:middle
of importing a framework
is just fragile.

00:15:46.916 --> 00:15:48.396 A:middle
We have a deal with the issue

00:15:48.396 --> 00:15:51.266 A:middle
where a header file gets
included more than once

00:15:51.266 --> 00:15:52.406 A:middle
in a single compilation.

00:15:53.606 --> 00:15:55.986 A:middle
We have also a problem
of headers being fragile.

00:15:56.526 --> 00:15:59.346 A:middle
And, what I mean by
that is that the meaning

00:15:59.346 --> 00:16:01.956 A:middle
of the header can change
depending on the environment


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.346 --> 00:16:01.956 A:middle
of the header can change
depending on the environment

00:16:02.236 --> 00:16:05.246 A:middle
where it's imported, and let me
show you that with an example.

00:16:06.706 --> 00:16:09.936 A:middle
So here, I've defined a macro
count to the value of 100,

00:16:10.266 --> 00:16:12.266 A:middle
and then I import the
foundation framework.

00:16:13.256 --> 00:16:17.056 A:middle
Now, inside the foundation
header there's an include

00:16:17.096 --> 00:16:18.586 A:middle
for the NSArray definition.

00:16:19.346 --> 00:16:21.786 A:middle
An NSArray has an
ivar, the count.

00:16:22.726 --> 00:16:26.896 A:middle
So, the macro of count gets
substituted as literal text

00:16:27.356 --> 00:16:30.296 A:middle
in that place and we end up
with completely broken code

00:16:30.296 --> 00:16:32.936 A:middle
where instead of the ivar
name, we have a value of 100.

00:16:33.856 --> 00:16:35.876 A:middle
This is what I mean by
headers being fragile.

00:16:37.296 --> 00:16:40.696 A:middle
Modules solve this problem
by replacing the model

00:16:40.696 --> 00:16:43.996 A:middle
of textual inclusion
with a semantic import.

00:16:44.326 --> 00:16:48.426 A:middle
And, there's a lot more detail
about modules in the Advances

00:16:48.426 --> 00:16:50.956 A:middle
in Objective-C presentation
from last year's WWDC

00:16:50.956 --> 00:16:52.556 A:middle
and I encourage you to watch

00:16:52.556 --> 00:16:54.146 A:middle
that if you're not
familiar with modules.

00:16:55.816 --> 00:16:58.466 A:middle
Until now, modules have
only been available

00:16:58.516 --> 00:16:59.776 A:middle
for the system frameworks.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.486 --> 00:17:04.286 A:middle
The new in Xcode 6, you
can now define modules

00:17:04.476 --> 00:17:07.906 A:middle
for your own frameworks as
well for C and Objective-C.

00:17:09.156 --> 00:17:11.866 A:middle
Besides fixing the
problems we just looked at,

00:17:11.986 --> 00:17:13.356 A:middle
this also gives you a way

00:17:13.356 --> 00:17:16.886 A:middle
of importing your own
framework into your SWF code.

00:17:17.586 --> 00:17:19.286 A:middle
And as Jim mentioned,
there's another session

00:17:19.286 --> 00:17:22.336 A:middle
on integrating SWF with
Objective-C that I encourage you

00:17:22.336 --> 00:17:24.425 A:middle
to watch the video to
learn more about that.

00:17:25.675 --> 00:17:27.556 A:middle
So if you want to do this, how?

00:17:28.806 --> 00:17:29.986 A:middle
It's really very easy.

00:17:30.946 --> 00:17:32.926 A:middle
For most frameworks
it's possible

00:17:32.926 --> 00:17:35.656 A:middle
to define a single
umbrella header

00:17:35.916 --> 00:17:38.126 A:middle
that imports all of
the framework API.

00:17:38.606 --> 00:17:40.866 A:middle
And, this is what we
recommend that you do

00:17:41.276 --> 00:17:43.976 A:middle
as it is the easiest
way to adopt a module.

00:17:45.046 --> 00:17:48.046 A:middle
Once you've done that, simply
go to the Xcode BUILD settings

00:17:48.256 --> 00:17:52.756 A:middle
for your framework and in the
packaging section set Defines

00:17:52.756 --> 00:17:55.616 A:middle
Module to Yes, and that's it.

00:17:55.616 --> 00:17:57.176 A:middle
It really is very easy.

00:17:57.796 --> 00:17:59.896 A:middle
Now, if you have a more
complicated framework


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:00.116 --> 00:18:03.516 A:middle
where that single umbrella
header is not sufficient,

00:18:03.516 --> 00:18:05.146 A:middle
you can use a custom module map.

00:18:05.946 --> 00:18:08.236 A:middle
And, there's more
information to describe how

00:18:08.236 --> 00:18:09.846 A:middle
that works on the LLVM website.

00:18:12.036 --> 00:18:14.506 A:middle
After you've created a
module you'll want to use it.

00:18:15.396 --> 00:18:16.036 A:middle
How do you do that?

00:18:17.226 --> 00:18:21.516 A:middle
There's an @import keyword
followed by the module name

00:18:21.856 --> 00:18:24.076 A:middle
that tells the compiler, "I
want to import this module."

00:18:24.726 --> 00:18:27.636 A:middle
If you haven't had a
chance to update your code

00:18:27.636 --> 00:18:28.716 A:middle
and you're still --

00:18:28.716 --> 00:18:31.726 A:middle
have a #import to include
the umbrella header,

00:18:31.726 --> 00:18:33.986 A:middle
the compiler's smart
enough to know

00:18:34.206 --> 00:18:37.416 A:middle
that this is now a modular
framework and it will go ahead

00:18:37.416 --> 00:18:40.426 A:middle
and treat that as an implicit
modular import anyway.

00:18:41.966 --> 00:18:45.516 A:middle
So just as a guideline though,
we do recommend you use @import

00:18:46.396 --> 00:18:49.536 A:middle
when you're importing your
framework into a separate target

00:18:49.536 --> 00:18:53.036 A:middle
within your project just because
it makes it clear in the source

00:18:53.116 --> 00:18:56.326 A:middle
that you really intend for
this to be a modular import.

00:18:57.646 --> 00:19:00.466 A:middle
One exception to that is
within the implementation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.646 --> 00:19:00.466 A:middle
One exception to that is
within the implementation

00:19:00.466 --> 00:19:01.776 A:middle
of your framework, itself.

00:19:02.476 --> 00:19:05.746 A:middle
It doesn't make any sense to
import a framework into itself

00:19:05.746 --> 00:19:09.006 A:middle
and so, in that case, you
really need to use #import

00:19:09.006 --> 00:19:11.096 A:middle
to textually include
the framework headers,

00:19:11.276 --> 00:19:13.286 A:middle
just within the implementation
of the framework.

00:19:14.846 --> 00:19:17.616 A:middle
And, besides those guidelines,
we have a few other rules

00:19:17.616 --> 00:19:19.876 A:middle
about modules that you
should be aware of.

00:19:20.286 --> 00:19:23.916 A:middle
First, don't expose
any non-modular headers

00:19:23.916 --> 00:19:24.966 A:middle
in your framework API.

00:19:26.186 --> 00:19:28.786 A:middle
It's fine to import
another module, like Cocoa,

00:19:29.296 --> 00:19:32.266 A:middle
but if I have an import of
something like Postgres.h,

00:19:32.266 --> 00:19:34.226 A:middle
which presumably
is not a module,

00:19:34.986 --> 00:19:37.156 A:middle
you can put that down
inside the implementation

00:19:37.156 --> 00:19:40.366 A:middle
of your framework, but
don't expose it in the API.

00:19:42.596 --> 00:19:46.436 A:middle
One other issue is that
modules can change the semantics

00:19:46.526 --> 00:19:47.146 A:middle
of your code.

00:19:47.636 --> 00:19:50.386 A:middle
We saw earlier the
problem of a fragile header

00:19:50.496 --> 00:19:53.676 A:middle
where a macro definition
inadvertently broke the code.

00:19:54.206 --> 00:19:56.256 A:middle
Sometimes you might want
to do this on purpose,

00:19:56.286 --> 00:19:59.236 A:middle
and I'm showing here an example
where I've defined a macro,

00:19:59.336 --> 00:20:03.226 A:middle
DEBUG, as a flag to enable
additional debugging APIs


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.336 --> 00:20:03.226 A:middle
DEBUG, as a flag to enable
additional debugging APIs

00:20:03.896 --> 00:20:04.726 A:middle
in my framework.

00:20:06.386 --> 00:20:08.806 A:middle
By switching that
framework to be a module,

00:20:08.806 --> 00:20:10.846 A:middle
the DEBUG macro defined

00:20:10.846 --> 00:20:13.066 A:middle
in my source code no
longer has any effect,

00:20:13.196 --> 00:20:14.426 A:middle
which is not what I wanted.

00:20:15.296 --> 00:20:17.726 A:middle
Now, that limitation
only applies to macros

00:20:17.726 --> 00:20:19.716 A:middle
that are defined
in the source code.

00:20:19.966 --> 00:20:22.066 A:middle
So, if you really want to
do something like this,

00:20:22.546 --> 00:20:26.146 A:middle
one alternative is to define
the macro on the command line

00:20:26.276 --> 00:20:27.726 A:middle
or in the Xcode build settings.

00:20:30.086 --> 00:20:31.716 A:middle
So, that is user-defined
modules.

00:20:31.906 --> 00:20:33.466 A:middle
It's really pretty
straightforward

00:20:33.466 --> 00:20:36.096 A:middle
in the common case, and it
gives you fast compilation,

00:20:36.436 --> 00:20:40.076 A:middle
clear semantics, and a way of
interoperating with SWF code.

00:20:42.396 --> 00:20:44.826 A:middle
So far, we've been
talking a lot about ways

00:20:44.826 --> 00:20:47.016 A:middle
that LLVM helps you
modernize your code

00:20:47.016 --> 00:20:52.106 A:middle
and adopt modern Objective-C
modules, but let's turn now

00:20:52.106 --> 00:20:53.346 A:middle
and look at performance,

00:20:53.446 --> 00:20:55.566 A:middle
which is the other theme
of this presentation.

00:20:56.846 --> 00:21:02.766 A:middle
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:56.846 --> 00:21:02.766 A:middle
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6

00:21:03.316 --> 00:21:04.606 A:middle
and it gives you a way

00:21:04.606 --> 00:21:07.206 A:middle
of getting even more
performance out of your code.

00:21:08.436 --> 00:21:11.836 A:middle
Let me give you an overall
high-level understanding

00:21:11.836 --> 00:21:13.396 A:middle
of what this is about.

00:21:14.506 --> 00:21:17.426 A:middle
One of the inherent
challenges for the compiler is

00:21:17.426 --> 00:21:19.656 A:middle
that it has no way of
knowing what the input

00:21:19.656 --> 00:21:20.946 A:middle
to your program is going to be.

00:21:21.356 --> 00:21:24.006 A:middle
The only input to the
compiler is your source code.

00:21:25.176 --> 00:21:27.106 A:middle
So, the compiler has to assume

00:21:27.366 --> 00:21:29.346 A:middle
that all inputs are
equally likely.

00:21:30.506 --> 00:21:32.096 A:middle
There are some cases
where it can guess

00:21:32.536 --> 00:21:35.116 A:middle
that certain code paths will
be more common than others.

00:21:35.856 --> 00:21:39.346 A:middle
For example, it can assume that
going through a loop is going

00:21:39.346 --> 00:21:41.516 A:middle
to happen more often than
code outside of that loop.

00:21:42.246 --> 00:21:44.246 A:middle
But, those are just guesses
and there are a lot of things

00:21:44.246 --> 00:21:45.496 A:middle
that it simply can't know.

00:21:47.286 --> 00:21:50.616 A:middle
If we provide a profile
as an additional input

00:21:50.616 --> 00:21:55.486 A:middle
to the compiler it can now try
to optimize for the common case

00:21:55.816 --> 00:21:58.736 A:middle
and do a better job
of optimization.

00:21:59.216 --> 00:22:01.036 A:middle
And, what I mean
by a profile, here,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.216 --> 00:22:01.036 A:middle
And, what I mean
by a profile, here,

00:22:01.226 --> 00:22:03.876 A:middle
is simply a count how
many times each statement

00:22:03.876 --> 00:22:08.366 A:middle
in your app executes in a
typical run of your app.

00:22:09.086 --> 00:22:12.086 A:middle
You may be wondering, "How do
I get a profile like that?"

00:22:12.466 --> 00:22:14.166 A:middle
Again, we could use
the compiler here

00:22:14.826 --> 00:22:17.616 A:middle
to generate a special
instrumented app

00:22:17.676 --> 00:22:19.316 A:middle
that as it runs is going

00:22:19.316 --> 00:22:22.276 A:middle
to count how many times each
statement will executes.

00:22:22.606 --> 00:22:24.146 A:middle
And then, when your app finishes

00:22:24.146 --> 00:22:26.676 A:middle
with this special instrumented
version, it will write

00:22:26.676 --> 00:22:29.706 A:middle
out that profile which
we can then use for PGO.

00:22:31.896 --> 00:22:34.936 A:middle
So, how does the compiler
use that profile information?

00:22:35.736 --> 00:22:37.106 A:middle
There are an awful lot of ways.

00:22:37.236 --> 00:22:39.636 A:middle
So many optimizations
can benefit from this,

00:22:40.326 --> 00:22:41.916 A:middle
but I'm highlighting
just three here

00:22:41.916 --> 00:22:43.316 A:middle
that are particularly valuable.

00:22:43.946 --> 00:22:45.046 A:middle
One is to the inliner.

00:22:46.066 --> 00:22:48.166 A:middle
If we know that a
function is really hot,

00:22:48.166 --> 00:22:50.706 A:middle
and by that I mean it's
run a lot, over and over.

00:22:51.256 --> 00:22:54.936 A:middle
The inliner can be much more
aggressive about inlining that.

00:22:55.226 --> 00:22:57.016 A:middle
When we're generating
the code we can try

00:22:57.016 --> 00:22:59.696 A:middle
to layout the common
paths through your code


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:00.126 --> 00:23:02.246 A:middle
so that they're contiguous,
which makes it easy

00:23:02.246 --> 00:23:04.156 A:middle
for the processor
to run them fast.

00:23:04.986 --> 00:23:08.006 A:middle
And the register allocator
can also try to keep values

00:23:08.066 --> 00:23:12.466 A:middle
in registers throughout
those most common paths.

00:23:12.766 --> 00:23:14.006 A:middle
Let's look at an example just

00:23:14.006 --> 00:23:16.306 A:middle
to give you a better
understanding of this.

00:23:16.836 --> 00:23:20.286 A:middle
This is some C++ code that's
going to iterate over a set

00:23:20.286 --> 00:23:22.306 A:middle
of colored objects and
for each one it's going

00:23:22.306 --> 00:23:24.146 A:middle
to update the position
of the object.

00:23:24.596 --> 00:23:27.646 A:middle
So, at the top I've got
a loop over the objects,

00:23:28.206 --> 00:23:29.016 A:middle
and for each one I'm going

00:23:29.016 --> 00:23:30.956 A:middle
to call my Update
Position function.

00:23:32.066 --> 00:23:33.906 A:middle
And, Update Position is
going to look and see

00:23:34.166 --> 00:23:38.206 A:middle
if the object is red it moves in
a very simple horizontal line,

00:23:38.206 --> 00:23:39.456 A:middle
so the code is really simple.

00:23:40.146 --> 00:23:42.266 A:middle
But, if the object
is blue, let's assume

00:23:42.516 --> 00:23:44.696 A:middle
that the movement is
much more complicated,

00:23:44.696 --> 00:23:46.796 A:middle
I've got a very large
block of code here.

00:23:48.126 --> 00:23:51.416 A:middle
Now, the compiler has no way
of knowing whether red objects

00:23:51.416 --> 00:23:53.216 A:middle
or blue objects are more likely,

00:23:53.256 --> 00:23:56.196 A:middle
so it just assumes they're
both equally likely.

00:23:56.196 --> 00:23:59.856 A:middle
But, with PGO I might
be able to know

00:23:59.856 --> 00:24:02.796 A:middle
that red objects
are far more common.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.856 --> 00:24:02.796 A:middle
that red objects
are far more common.

00:24:03.326 --> 00:24:05.906 A:middle
And so, I'm highlighting
in red here the hot code,

00:24:06.346 --> 00:24:09.116 A:middle
which is the code to iterate
over the set of objects and then

00:24:09.116 --> 00:24:10.546 A:middle
to handle the red objects.

00:24:11.536 --> 00:24:14.986 A:middle
I'm going to color-code
the cold code in blue,

00:24:15.016 --> 00:24:16.736 A:middle
which is blue objects
which are rare

00:24:16.736 --> 00:24:18.346 A:middle
for some reason in
this application.

00:24:19.216 --> 00:24:22.056 A:middle
And then, let's look at how the
compiler would handle this code.

00:24:24.016 --> 00:24:27.786 A:middle
Here's kind of the default code
layout that matches, roughly,

00:24:27.786 --> 00:24:29.286 A:middle
the original source order.

00:24:29.606 --> 00:24:31.416 A:middle
We've got the hot loop outside,

00:24:31.416 --> 00:24:34.346 A:middle
and then the Update
Position function down below,

00:24:34.556 --> 00:24:37.536 A:middle
with a little bit
of hot code in it.

00:24:38.486 --> 00:24:41.606 A:middle
Inlining is one of the most
important optimizations

00:24:42.346 --> 00:24:45.826 A:middle
and we'd really like to inline
that Update Position function.

00:24:46.226 --> 00:24:48.686 A:middle
But, the compiler
can't inline everything

00:24:49.266 --> 00:24:52.586 A:middle
or the code would bloat beyond a
point where it would be useful.

00:24:53.796 --> 00:24:57.006 A:middle
But in this case, the Update
Position function is big

00:24:57.046 --> 00:24:59.916 A:middle
because of all that cold code
for handling the blue objects


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:00.876 --> 00:25:02.646 A:middle
and so it wouldn't
normally be inlined.

00:25:02.956 --> 00:25:05.866 A:middle
But, because PGO tells us
there's some really hot code

00:25:05.866 --> 00:25:09.896 A:middle
here, the inliner can be much
more aggressive about that

00:25:09.896 --> 00:25:11.216 A:middle
in this particular case.

00:25:11.936 --> 00:25:16.046 A:middle
So, we take the loop iterating
over the objects and split

00:25:16.046 --> 00:25:20.546 A:middle
that in half and move the Update
Position code right inline.

00:25:21.416 --> 00:25:22.706 A:middle
So, this is much better now.

00:25:22.706 --> 00:25:25.406 A:middle
We've got a lot of the
hot code right together,

00:25:25.406 --> 00:25:29.966 A:middle
but we've still got a big chunk
of this code for blue objects,

00:25:29.966 --> 00:25:31.816 A:middle
the cold code, right in
the middle of our loop.

00:25:32.696 --> 00:25:36.596 A:middle
And, PGO can help this, as well,
by changing the code layout.

00:25:36.926 --> 00:25:40.456 A:middle
It knows that that code is cold
and can move it down below,

00:25:40.456 --> 00:25:43.436 A:middle
out of the way, and we end
up with a nice tight loop

00:25:43.746 --> 00:25:45.016 A:middle
that can run really fast.

00:25:45.536 --> 00:25:48.906 A:middle
And, it also typically
enables other optimizations

00:25:48.906 --> 00:25:49.906 A:middle
on that hot code.

00:25:51.146 --> 00:25:53.416 A:middle
So obviously, this is
a simplified example,

00:25:53.416 --> 00:25:56.216 A:middle
but hopefully gives you a
feel of the power of PGO

00:25:56.216 --> 00:25:58.486 A:middle
and just how much it
can help the optimizer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:00.056 --> 00:26:01.606 A:middle
So, you may want to use it.

00:26:02.406 --> 00:26:03.496 A:middle
When does it make sense?

00:26:04.406 --> 00:26:07.746 A:middle
The compiler does a really
good job optimizing by default.

00:26:08.916 --> 00:26:11.636 A:middle
With PGO, if you do just
a little bit of extra work

00:26:11.856 --> 00:26:15.146 A:middle
to gather the profile
you can do even better.

00:26:15.826 --> 00:26:17.666 A:middle
So obviously, if you're happy

00:26:17.666 --> 00:26:19.616 A:middle
with the performance
you're already getting,

00:26:20.126 --> 00:26:21.806 A:middle
you're probably not
motivated to do that --

00:26:22.036 --> 00:26:23.506 A:middle
even that little
bit of extra work.

00:26:23.936 --> 00:26:25.966 A:middle
But, if you need
more performance,

00:26:26.486 --> 00:26:28.486 A:middle
by all means, give it a try.

00:26:29.136 --> 00:26:31.066 A:middle
And, let me show
you some examples

00:26:31.066 --> 00:26:32.436 A:middle
of just how much it can help.

00:26:33.676 --> 00:26:36.886 A:middle
This is a graph showing
the speedup.

00:26:36.886 --> 00:26:38.876 A:middle
Compare it with PGO
compared to a case

00:26:38.876 --> 00:26:40.636 A:middle
of just a normal optimize build.

00:26:41.446 --> 00:26:44.206 A:middle
And, I'm looking at four
different applications here;

00:26:44.206 --> 00:26:47.516 A:middle
the Apple LLVM compiler
itself, applying PGO

00:26:47.606 --> 00:26:50.766 A:middle
to the compiler itself,
the SQLite database,

00:26:51.246 --> 00:26:53.596 A:middle
the PERL interpreter, and
gzip file compression.

00:26:54.676 --> 00:26:56.736 A:middle
And, PGO gives us
speedups ranging

00:26:56.736 --> 00:26:59.456 A:middle
from about 4% all
the way up to 18%.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:00.786 --> 00:27:02.806 A:middle
So, not all apps will
benefit this much.

00:27:03.026 --> 00:27:04.646 A:middle
It really varies,
depending on the app,

00:27:05.116 --> 00:27:07.426 A:middle
but clearly there's a
lot of potential here.

00:27:09.676 --> 00:27:12.606 A:middle
So, if you want to try it,
how do you go about that?

00:27:13.166 --> 00:27:15.016 A:middle
PGO is really easy to use.

00:27:15.616 --> 00:27:17.476 A:middle
The first step is to
collect a profile.

00:27:17.476 --> 00:27:20.186 A:middle
I'm going to come back and talk
about that in just a minute.

00:27:21.286 --> 00:27:24.146 A:middle
Once you've done that, simply
go in the Xcode Build settings

00:27:24.146 --> 00:27:27.676 A:middle
for your project and find
the Use Optimization Profile

00:27:27.676 --> 00:27:30.096 A:middle
setting, and set it
to Yes, typically just

00:27:30.096 --> 00:27:31.446 A:middle
for the release configuration.

00:27:32.216 --> 00:27:32.886 A:middle
And that's it!

00:27:32.886 --> 00:27:34.576 A:middle
You've enabled PGO.

00:27:35.696 --> 00:27:36.576 A:middle
Once you've done that,

00:27:36.576 --> 00:27:39.326 A:middle
as you continue developing
your app you may change it

00:27:39.326 --> 00:27:41.176 A:middle
as you fix bugs, you
add new features,

00:27:41.876 --> 00:27:44.336 A:middle
the code becomes
gradually out of sync

00:27:44.336 --> 00:27:46.136 A:middle
with the profile you've
collected earlier.

00:27:47.096 --> 00:27:50.996 A:middle
And, when that happens, the
compiler will simply fail to use

00:27:50.996 --> 00:27:52.486 A:middle
that profile information.

00:27:52.486 --> 00:27:53.636 A:middle
It won't break anything,

00:27:53.636 --> 00:27:56.666 A:middle
you just gradually lose
the optimization benefit.

00:27:56.666 --> 00:27:58.986 A:middle
And when that happens, it
will give you a warning.

00:27:59.966 --> 00:28:01.636 A:middle
So, if you see warnings
like this,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.966 --> 00:28:01.636 A:middle
So, if you see warnings
like this,

00:28:01.636 --> 00:28:04.866 A:middle
saying that your profile may
be out of date, as you see more

00:28:04.866 --> 00:28:06.866 A:middle
and more of them, it's a good
indication to you that's time

00:28:06.866 --> 00:28:09.376 A:middle
to go back and update
your profile.

00:28:10.726 --> 00:28:13.876 A:middle
So, let's turn now and look at,
how do you generate the profile?

00:28:15.166 --> 00:28:19.406 A:middle
Xcode 6 has a new command,
Generate Optimization Profile.

00:28:20.096 --> 00:28:21.176 A:middle
When you run this command,

00:28:21.376 --> 00:28:24.316 A:middle
Xcode will build the special
instrumented version of your app

00:28:24.316 --> 00:28:27.096 A:middle
and then run it, and
you can then interact

00:28:27.096 --> 00:28:29.506 A:middle
with the running app to
generate the profile.

00:28:29.506 --> 00:28:31.616 A:middle
When it finishes running, it
will write out the profile

00:28:31.616 --> 00:28:32.956 A:middle
and add it to your project.

00:28:34.316 --> 00:28:37.156 A:middle
As you're running your app,
keep in mind it's important

00:28:37.156 --> 00:28:40.056 A:middle
to exercise all of the
code that's important

00:28:40.056 --> 00:28:41.076 A:middle
for your performance.

00:28:41.626 --> 00:28:43.906 A:middle
If I have a game with
three different levels

00:28:44.416 --> 00:28:47.966 A:middle
and I only play the first level
of my game, the compiler's going

00:28:47.966 --> 00:28:49.856 A:middle
to assume that that's the
only thing that really matters

00:28:49.856 --> 00:28:52.096 A:middle
and not work as hard
on the other levels.

00:28:54.356 --> 00:28:57.166 A:middle
Now, you may be wondering, "If
I've written a really hard game,

00:28:57.936 --> 00:29:00.746 A:middle
it may take a while to play
the whole thing to completion."


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:57.936 --> 00:29:00.746 A:middle
it may take a while to play
the whole thing to completion."

00:29:01.396 --> 00:29:03.476 A:middle
That could be a problem, right?

00:29:03.546 --> 00:29:05.966 A:middle
So, Xcode has another option,

00:29:07.116 --> 00:29:10.076 A:middle
which is to use your
performance tests as inputs

00:29:10.076 --> 00:29:11.286 A:middle
to drive the profiling.

00:29:12.496 --> 00:29:15.296 A:middle
Performance tests are a
new feature in Xcode 6.

00:29:15.796 --> 00:29:17.246 A:middle
If you'd like to
learn more about them,

00:29:17.376 --> 00:29:19.096 A:middle
there's a session right
here tomorrow morning

00:29:19.096 --> 00:29:20.756 A:middle
on testing in Xcode 6.

00:29:21.586 --> 00:29:25.436 A:middle
And, if you care about
performance you want to set

00:29:25.436 --> 00:29:28.406 A:middle
up these performance tests
anyway, to catch regressions

00:29:28.406 --> 00:29:30.406 A:middle
in your code, just to keep
track of how you're doing.

00:29:31.296 --> 00:29:34.276 A:middle
And once you've gone to
that trouble to set them up,

00:29:34.776 --> 00:29:36.906 A:middle
in most cases they're
pretty good inputs

00:29:36.906 --> 00:29:38.176 A:middle
for driving this profile.

00:29:40.106 --> 00:29:42.396 A:middle
Again though, keep in
mind it's important

00:29:42.596 --> 00:29:45.116 A:middle
that your tests cover
the code in a way

00:29:45.116 --> 00:29:47.566 A:middle
that reflects the
typical usage of your app.

00:29:47.946 --> 00:29:51.066 A:middle
Going back to my three-level
game, if I write lots of tests

00:29:51.066 --> 00:29:53.356 A:middle
for the first level and
only a few for the second

00:29:53.356 --> 00:29:56.006 A:middle
and third level, again,
the compiler's going to end

00:29:56.006 --> 00:29:59.216 A:middle
up optimizing more heavily
for that first level.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.656 --> 00:30:03.416 A:middle
Another benefit of using tests
is it gives you a great way

00:30:03.746 --> 00:30:06.306 A:middle
of evaluating, how
much does PGO help me?

00:30:06.306 --> 00:30:07.726 A:middle
You can just run your tests.

00:30:08.086 --> 00:30:10.286 A:middle
Now, let me show you
that with a demo now.

00:30:12.376 --> 00:30:14.556 A:middle
So, with the release
of the SWF language,

00:30:15.286 --> 00:30:18.026 A:middle
we thought it would be
fun to make a demo app

00:30:18.026 --> 00:30:19.016 A:middle
that would celebrate that.

00:30:19.986 --> 00:30:21.566 A:middle
And so, rather than
the SWF language,

00:30:21.566 --> 00:30:25.056 A:middle
we thought of the SWF birds
and we made an application

00:30:25.196 --> 00:30:28.326 A:middle
that uses the Boids
Artificial Life Simulation

00:30:29.326 --> 00:30:30.816 A:middle
to simulate a flock of SWFs.

00:30:33.146 --> 00:30:35.206 A:middle
And, I can create a
whole bunch of them here

00:30:35.206 --> 00:30:36.436 A:middle
and let them fly around.

00:30:36.516 --> 00:30:40.686 A:middle
And, the way this Boids
application works is

00:30:40.686 --> 00:30:44.986 A:middle
that each bird, or Boid,
compares its position to all

00:30:44.986 --> 00:30:48.346 A:middle
of the other ones on the screen
and it calculates the distance

00:30:48.346 --> 00:30:52.066 A:middle
between them to find the flock
of the birds nearest to it.

00:30:53.016 --> 00:30:57.136 A:middle
And then, each Boid
has competing urges.

00:30:57.136 --> 00:30:59.446 A:middle
On the one hand, it
wants to move closer

00:30:59.446 --> 00:31:00.696 A:middle
to the center of the flock.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.446 --> 00:31:00.696 A:middle
to the center of the flock.

00:31:00.696 --> 00:31:03.886 A:middle
At the same time, it doesn't
want to get too close.

00:31:04.676 --> 00:31:08.986 A:middle
And so, if it gets too close to
another one it will move apart.

00:31:10.066 --> 00:31:12.946 A:middle
And the performance of that,
as we add more and more

00:31:12.946 --> 00:31:15.666 A:middle
of these Boids, could
become a problem.

00:31:16.466 --> 00:31:20.086 A:middle
So, we set up a performance
test to track that,

00:31:20.936 --> 00:31:24.216 A:middle
and this is a really
simple performance test.

00:31:25.576 --> 00:31:29.296 A:middle
We set up a scene with 200 Boids
and measured the time it takes

00:31:29.296 --> 00:31:31.686 A:middle
to update their positions
100 times,

00:31:31.686 --> 00:31:32.816 A:middle
and that's our performance test.

00:31:32.816 --> 00:31:33.716 A:middle
So, let's run that.

00:31:34.476 --> 00:31:36.376 A:middle
Because I care about
performance,

00:31:36.816 --> 00:31:39.806 A:middle
I'm going to edit my
current scheme to make sure

00:31:39.806 --> 00:31:41.656 A:middle
that my test step is going

00:31:41.656 --> 00:31:44.186 A:middle
to use the release-built
configuration

00:31:44.586 --> 00:31:46.436 A:middle
so that we get optimized
results.

00:31:47.616 --> 00:31:49.726 A:middle
And, I'll go to the
Product Test menu

00:31:51.376 --> 00:31:53.096 A:middle
and run my performance
test here.

00:31:57.526 --> 00:31:57.936 A:middle
All right.

00:31:58.086 --> 00:32:00.486 A:middle
And now, because I haven't run
the test before I don't have a


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.086 --> 00:32:00.486 A:middle
And now, because I haven't run
the test before I don't have a

00:32:00.536 --> 00:32:02.086 A:middle
baseline, so let's go ahead

00:32:02.086 --> 00:32:06.536 A:middle
and set the baseline
based on that first run.

00:32:07.666 --> 00:32:10.366 A:middle
And now, let's try adding PGO.

00:32:11.256 --> 00:32:13.636 A:middle
Under the Product
menu, Perform Action,

00:32:14.246 --> 00:32:16.636 A:middle
down at the bottom here is this
new command I told you about,

00:32:16.636 --> 00:32:18.496 A:middle
Generate Optimization Profile.

00:32:19.136 --> 00:32:22.516 A:middle
I get two choices; I can
either run the application

00:32:23.616 --> 00:32:25.446 A:middle
or I can use my performance
test.

00:32:25.446 --> 00:32:28.016 A:middle
And, I'd like to show you how it
works with the performance test.

00:32:29.026 --> 00:32:33.256 A:middle
I just click Build and Run,
and Xcode, very helpfully,

00:32:33.396 --> 00:32:35.906 A:middle
warns me that I haven't
yet enabled PGO

00:32:35.906 --> 00:32:38.616 A:middle
in the Build settings
and it offers to do that.

00:32:38.616 --> 00:32:41.196 A:middle
So, let's go ahead and
let it enable that.

00:32:41.486 --> 00:32:44.236 A:middle
It's now building a special
instrumented version of our app

00:32:44.236 --> 00:32:48.736 A:middle
and running it using
the performance test.

00:32:49.136 --> 00:32:50.406 A:middle
And when those tests finish --

00:32:52.516 --> 00:32:55.436 A:middle
ah, I got a warning
here, an error.

00:32:55.436 --> 00:32:57.586 A:middle
Let me just explain
what's happened here is

00:32:57.616 --> 00:33:00.016 A:middle
that because we've
run the app with a lot


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:57.616 --> 00:33:00.016 A:middle
that because we've
run the app with a lot

00:33:00.016 --> 00:33:02.966 A:middle
of the instrumentation
code, it runs more slowly.

00:33:03.246 --> 00:33:05.616 A:middle
But, this is just being
used to generate the profile

00:33:05.616 --> 00:33:06.656 A:middle
so that's not a problem.

00:33:07.026 --> 00:33:10.016 A:middle
I'm going to go back to the
Project Navigator a minute

00:33:10.616 --> 00:33:13.666 A:middle
and show you that Xcode has
added this new Optimization

00:33:13.666 --> 00:33:14.836 A:middle
Profiles folder.

00:33:15.446 --> 00:33:18.806 A:middle
And inside of that, if you can
see it, there's my profile data.

00:33:20.066 --> 00:33:20.826 A:middle
So, that's great!

00:33:21.416 --> 00:33:23.776 A:middle
PGO is enabled, we
have a profile.

00:33:23.776 --> 00:33:25.676 A:middle
Let's rerun those
performance tests.

00:33:26.276 --> 00:33:27.786 A:middle
We'll go back to
run Product Test,

00:33:28.946 --> 00:33:30.156 A:middle
and see how much does it help?

00:33:30.156 --> 00:33:34.956 A:middle
And the tests are running now.

00:33:36.376 --> 00:33:39.036 A:middle
And, wow, we got a 21%
improvement just like that.

00:33:39.386 --> 00:33:41.696 A:middle
We didn't have to change the
code or do anything else.

00:33:42.516 --> 00:33:49.286 A:middle
[ Applause ]

00:33:49.786 --> 00:33:51.276 A:middle
So, that is PGO.

00:33:51.626 --> 00:33:54.836 A:middle
It's a great new feature to help
you get even more performance,

00:33:54.946 --> 00:33:57.346 A:middle
when you care about
getting every last drop

00:33:57.346 --> 00:33:58.006 A:middle
out of your code.

00:33:59.136 --> 00:34:01.186 A:middle
Continuing on this
theme of performance,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.136 --> 00:34:01.186 A:middle
Continuing on this
theme of performance,

00:34:01.266 --> 00:34:04.736 A:middle
I'd like to turn the stage over
to Nadav Rotem, my colleague,

00:34:04.736 --> 00:34:08.936 A:middle
to talk about advances
in vectorization

00:34:09.536 --> 00:34:09.966 A:middle
&gt;&gt; Thank you, Bob.

00:34:10.565 --> 00:34:10.735 A:middle
Hi.

00:34:11.516 --> 00:34:16.476 A:middle
[ Applause ]

00:34:16.976 --> 00:34:21.896 A:middle
So, Last year with Xcode 5 we've
introduced a new optimization

00:34:22.186 --> 00:34:23.856 A:middle
called loop vectorization.

00:34:24.156 --> 00:34:28.485 A:middle
And, I would like to remind
you what loop vectorization is.

00:34:29.085 --> 00:34:33.186 A:middle
So, modern processors
have vector instructions.

00:34:33.616 --> 00:34:37.025 A:middle
These instructions can process
multiple scalars at once.

00:34:37.505 --> 00:34:40.406 A:middle
And loop vectorization is
the compiler optimization

00:34:40.766 --> 00:34:43.866 A:middle
that accelerates loops using
these vector instructions.

00:34:44.866 --> 00:34:45.735 A:middle
And let's see how it's done.

00:34:46.295 --> 00:34:48.266 A:middle
If you can see the code
on the screen here,

00:34:48.266 --> 00:34:49.656 A:middle
you'll see that it's
a simple program

00:34:50.266 --> 00:34:52.716 A:middle
that accumulates all
the numbers in the array

00:34:53.025 --> 00:34:54.436 A:middle
into one variable, into sum.

00:34:54.496 --> 00:34:59.016 A:middle
And, the natural way of
executing this code is

00:34:59.016 --> 00:35:02.366 A:middle
to load one number at a time and
save it into the variable sum.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.016 --> 00:35:02.366 A:middle
to load one number at a time and
save it into the variable sum.

00:35:02.426 --> 00:35:04.586 A:middle
And then, load another
number and save it into sum.

00:35:05.236 --> 00:35:07.736 A:middle
But, there's the better
way of executing this code.

00:35:09.076 --> 00:35:11.856 A:middle
What the loop vector does
for you automatically,

00:35:12.186 --> 00:35:15.596 A:middle
is that it introduces a new
temporary variable, temp4.

00:35:15.596 --> 00:35:19.436 A:middle
Now, this is a vector register,
a vector temporary variable.

00:35:20.576 --> 00:35:23.586 A:middle
And, this allows us to
load four numbers at a time

00:35:23.856 --> 00:35:25.246 A:middle
and add four numbers at a time,

00:35:25.556 --> 00:35:26.766 A:middle
and we do it for
the entire array.

00:35:27.206 --> 00:35:29.136 A:middle
So, this is obviously
much faster

00:35:29.136 --> 00:35:32.236 A:middle
because we're processing
four numbers at once instead

00:35:32.236 --> 00:35:34.896 A:middle
of processing one
number at a time.

00:35:35.036 --> 00:35:37.416 A:middle
And, when you finish
scanning the array we need

00:35:37.416 --> 00:35:40.186 A:middle
to take the four numbers
from that temporary register

00:35:40.186 --> 00:35:42.076 A:middle
and add them together,
but it doesn't matter

00:35:42.076 --> 00:35:43.826 A:middle
because usually an
array is pretty big.

00:35:44.836 --> 00:35:48.716 A:middle
So, this is how loop
vectorization accelerates loops

00:35:48.716 --> 00:35:49.846 A:middle
and makes your code run faster

00:35:49.956 --> 00:35:51.466 A:middle
so that you don't have
to change your code.

00:35:52.696 --> 00:35:56.956 A:middle
So, in Xcode 6 we've improved
loop vectorization in a number

00:35:56.956 --> 00:35:58.726 A:middle
of ways, where first of all,

00:35:59.006 --> 00:36:01.126 A:middle
we've improved the analysis
of complicated loops.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.006 --> 00:36:01.126 A:middle
we've improved the analysis
of complicated loops.

00:36:01.716 --> 00:36:03.976 A:middle
This means that the
LLVM will be able

00:36:03.976 --> 00:36:07.906 A:middle
to analyze more complicated
loops and vectorize more loops

00:36:07.906 --> 00:36:09.326 A:middle
in your code, which is great.

00:36:09.696 --> 00:36:12.696 A:middle
We've also integrated the
Loop Vectorizer with PGO,

00:36:12.696 --> 00:36:14.146 A:middle
that Bob just mentioned.

00:36:14.596 --> 00:36:18.166 A:middle
So, this means that when PGO is
available the Loop Vectorizer

00:36:18.236 --> 00:36:19.896 A:middle
will be able to make
better decisions

00:36:20.406 --> 00:36:21.436 A:middle
when vectorizing your code.

00:36:22.436 --> 00:36:27.016 A:middle
We've also improved the X86
and ARM64 in coding support.

00:36:27.096 --> 00:36:28.066 A:middle
Now this means two things.

00:36:28.766 --> 00:36:31.616 A:middle
First of all, the Loop
Vectorizer has a better

00:36:31.616 --> 00:36:35.096 A:middle
understanding of the processor
so it can predict better

00:36:35.376 --> 00:36:37.806 A:middle
when it is profitable
to vectorize your codes.

00:36:38.226 --> 00:36:40.266 A:middle
And the second thing
that it means is

00:36:40.266 --> 00:36:44.096 A:middle
that when it vectorize your
code it'll generate better,

00:36:44.096 --> 00:36:46.216 A:middle
more optimized code sequences,

00:36:46.286 --> 00:36:47.756 A:middle
so that your code
would run faster.

00:36:49.926 --> 00:36:51.576 A:middle
And, the last feature
that I want to talk to you

00:36:51.576 --> 00:36:54.156 A:middle
about is specialization
of loop variables.

00:36:56.896 --> 00:37:02.946 A:middle
So, most variables in your
code are only known at runtime.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:56.896 --> 00:37:02.946 A:middle
So, most variables in your
code are only known at runtime.

00:37:03.796 --> 00:37:09.396 A:middle
These variables can be arguments
or computed expressions,

00:37:09.396 --> 00:37:12.356 A:middle
and compiler doesn't know
the values of these variables

00:37:12.656 --> 00:37:15.076 A:middle
at compile time,
only at runtime.

00:37:16.186 --> 00:37:17.776 A:middle
And in many times,

00:37:18.176 --> 00:37:21.556 A:middle
the Vectorizer cannot vectorize
your code unless the value

00:37:21.556 --> 00:37:23.536 A:middle
of these variables is
known to be constant.

00:37:24.146 --> 00:37:25.416 A:middle
So, let's take a
look at the example

00:37:25.416 --> 00:37:26.266 A:middle
that I showed you earlier.

00:37:26.496 --> 00:37:30.026 A:middle
So, this is a simple loop and
I modified it a little bit

00:37:30.026 --> 00:37:32.066 A:middle
and I introduced
the Step variable.

00:37:32.356 --> 00:37:36.196 A:middle
So now, instead of consecutively
scanning all of the elements

00:37:36.196 --> 00:37:38.796 A:middle
in the array, we jump
and skip some elements,

00:37:38.796 --> 00:37:41.216 A:middle
and we go in step
of variable Step.

00:37:42.826 --> 00:37:44.366 A:middle
Now, we can't vectorize
this code

00:37:44.366 --> 00:37:48.056 A:middle
because these elements are
not consecutive in memory.

00:37:48.056 --> 00:37:51.466 A:middle
We can't use these vector
registers to load a few elements

00:37:51.466 --> 00:37:52.766 A:middle
and then add them together.

00:37:52.766 --> 00:37:56.266 A:middle
It's won't work unless
Step is equal to one.

00:37:56.586 --> 00:37:59.236 A:middle
Well, in many cases
Step is equal to one.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.236 --> 00:38:01.046 A:middle
So, what do we do?

00:38:01.726 --> 00:38:04.776 A:middle
Well, we've introduced a
new optimization that's

00:38:04.776 --> 00:38:05.976 A:middle
called Specialization.

00:38:06.706 --> 00:38:09.546 A:middle
What we do is we create
multiple versions of the loop.

00:38:10.206 --> 00:38:13.036 A:middle
In one version of the loop
we assume that step is equal

00:38:13.036 --> 00:38:15.176 A:middle
to one, and then we
vectorize the code

00:38:15.896 --> 00:38:17.046 A:middle
and make the code run faster.

00:38:17.946 --> 00:38:20.706 A:middle
But, in another version of the
loop we don't assume anything

00:38:20.756 --> 00:38:24.316 A:middle
and the code runs
as-is -- scalar.

00:38:25.396 --> 00:38:29.106 A:middle
And then, we add code
for selecting at runtime

00:38:29.636 --> 00:38:31.586 A:middle
which version of
the loop to run.

00:38:31.926 --> 00:38:35.056 A:middle
If Step happened to
be one, then we go

00:38:35.056 --> 00:38:36.956 A:middle
and execute the vectorized
version.

00:38:37.136 --> 00:38:38.286 A:middle
But, if Step is not equal

00:38:38.286 --> 00:38:40.956 A:middle
to one then we execute
the regular version.

00:38:41.236 --> 00:38:43.206 A:middle
And this compiler,
this new feature,

00:38:43.206 --> 00:38:45.666 A:middle
allows the Loop Vectorizer

00:38:45.736 --> 00:38:50.146 A:middle
to vectorize a lot more
loops, and it's great.

00:38:50.146 --> 00:38:52.106 A:middle
Okay. So, this was
loop vectorization.

00:38:52.626 --> 00:38:56.606 A:middle
But, in Xcode 6 we've also added
a new kind of vectorization.

00:38:56.816 --> 00:38:59.916 A:middle
This is -- this new vectorizer
is not a loop vectorizer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:00.206 --> 00:39:03.156 A:middle
It's called SLP Vectorizer,
which stands

00:39:03.156 --> 00:39:05.386 A:middle
for Superword Level Parallelism,

00:39:05.686 --> 00:39:08.646 A:middle
and it extracts parallelism
beyond loops.

00:39:09.116 --> 00:39:11.726 A:middle
What this SLP Vectorizer
does is that it looks

00:39:11.726 --> 00:39:15.426 A:middle
for multiple scalars in your
code and it glues them together

00:39:15.426 --> 00:39:16.686 A:middle
into vector instructions.

00:39:18.136 --> 00:39:20.496 A:middle
Let's see how it's done.

00:39:21.696 --> 00:39:23.596 A:middle
So, on the screen you
see a very simple struct.

00:39:24.476 --> 00:39:26.936 A:middle
This struct has two
members, x and y.

00:39:27.596 --> 00:39:28.816 A:middle
They're consecutive in memory.

00:39:29.766 --> 00:39:32.246 A:middle
And, we have a simple
function that converts units

00:39:32.946 --> 00:39:34.326 A:middle
from feet to centimeters.

00:39:34.496 --> 00:39:36.086 A:middle
Now, this is a very
simple conversion.

00:39:36.136 --> 00:39:39.486 A:middle
All we have to do is
load the x member,

00:39:39.486 --> 00:39:41.206 A:middle
multiply it by a
constant, and do it again.

00:39:41.206 --> 00:39:42.246 A:middle
And, we do the same thing for y.

00:39:42.576 --> 00:39:46.606 A:middle
And of course, the natural
way of executing this code is

00:39:46.636 --> 00:39:49.746 A:middle
to do it consecutively;
load variable x,

00:39:49.836 --> 00:39:51.646 A:middle
multiply it, save it back.

00:39:52.736 --> 00:39:56.396 A:middle
Load variable y, multiply
it, and save it back.

00:39:57.076 --> 00:39:59.556 A:middle
But again, there's a
better way of doing it,

00:39:59.866 --> 00:40:01.956 A:middle
and this is what the
SLP Vectorizer does.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.866 --> 00:40:01.956 A:middle
and this is what the
SLP Vectorizer does.

00:40:02.486 --> 00:40:05.316 A:middle
We can load x and y together
because they're consecutive

00:40:05.316 --> 00:40:09.026 A:middle
in memory, multiply
them together again,

00:40:09.026 --> 00:40:10.316 A:middle
and save them back to memory.

00:40:10.316 --> 00:40:19.046 A:middle
And, this is SLP vectorization
SLP vectorization is very

00:40:19.046 --> 00:40:21.376 A:middle
beneficial for some
kinds of application,

00:40:21.786 --> 00:40:24.906 A:middle
mainly numeric applications,
and we see great speedups.

00:40:25.186 --> 00:40:27.386 A:middle
It may not speed
up all programs,

00:40:27.996 --> 00:40:30.096 A:middle
but it definitely
speeds up a lot

00:40:30.166 --> 00:40:32.546 A:middle
of numerically complex
applications.

00:40:33.816 --> 00:40:40.236 A:middle
So to summarize, we've improved
loop vectorization in Xcode 6

00:40:40.526 --> 00:40:42.056 A:middle
and we've introduced a new kind

00:40:42.056 --> 00:40:44.896 A:middle
of vectorization called
SLP vectorization.

00:40:46.866 --> 00:40:49.676 A:middle
Now in Xcode 5, when we
introduced the Loop Vectorizer

00:40:49.916 --> 00:40:52.646 A:middle
we did not enable it by default
and you had to go into one

00:40:52.646 --> 00:40:54.816 A:middle
of the settings and
select Loop Vectorization

00:40:54.816 --> 00:40:56.186 A:middle
and then Loop Vectorization
worked.

00:40:56.596 --> 00:40:59.426 A:middle
Well, in Xcode 6 you
don't have to do anything

00:40:59.426 --> 00:41:02.136 A:middle
because both the
new SLP Vectorizer


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.426 --> 00:41:02.136 A:middle
because both the
new SLP Vectorizer

00:41:02.536 --> 00:41:05.776 A:middle
and the improved Loop Vectorizer
are enabled by default

00:41:05.916 --> 00:41:08.036 A:middle
when you build your
application in a release mode.

00:41:08.306 --> 00:41:09.746 A:middle
This means that you don't
need to do anything.

00:41:09.746 --> 00:41:11.846 A:middle
Just compile your
application in release mode

00:41:12.346 --> 00:41:15.016 A:middle
and the improved LLVM will
make your code run faster.

00:41:18.916 --> 00:41:20.856 A:middle
Okay. So, we talked
about a number

00:41:20.856 --> 00:41:23.036 A:middle
of performance features in LLVM.

00:41:23.276 --> 00:41:25.486 A:middle
We talked about PGO, we
talked about vectorization,

00:41:26.656 --> 00:41:29.696 A:middle
but both of these
features are features

00:41:29.696 --> 00:41:32.806 A:middle
of a static C and C++ compiler.

00:41:33.316 --> 00:41:36.346 A:middle
But, LLVM is essential
technology here at Apple,

00:41:36.346 --> 00:41:38.156 A:middle
that's used by many projects.

00:41:38.506 --> 00:41:40.126 A:middle
And, one of the projects
that I want to talk to you

00:41:40.126 --> 00:41:43.266 A:middle
about today is accelerating
JavaScript code.

00:41:47.356 --> 00:41:52.126 A:middle
Well, WebKit is another
important technology.

00:41:52.126 --> 00:41:54.406 A:middle
It's the heart of the
Safari Web Browser.

00:41:55.166 --> 00:41:57.646 A:middle
And, WebKit needs to
execute JavaScript code

00:41:58.046 --> 00:42:00.326 A:middle
because JavaScript is
everywhere in every web page.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.046 --> 00:42:00.326 A:middle
because JavaScript is
everywhere in every web page.

00:42:01.806 --> 00:42:03.236 A:middle
And, WebKit has an interpreter,

00:42:03.536 --> 00:42:05.826 A:middle
so when you load your Facebook
page, or any other page,

00:42:06.156 --> 00:42:09.966 A:middle
WebKit starts executing your
code with the interpreter.

00:42:11.356 --> 00:42:13.906 A:middle
But, WebKit also has
two JIT compilers

00:42:14.276 --> 00:42:15.926 A:middle
to accelerate your code.

00:42:17.156 --> 00:42:19.466 A:middle
When WebKit sees that you
execute the same function,

00:42:19.466 --> 00:42:21.816 A:middle
the same JavaScript
functions over

00:42:21.816 --> 00:42:23.396 A:middle
and over again, it says, "Huh.

00:42:23.716 --> 00:42:27.106 A:middle
Let's take a little bit of time
to compile it really quickly

00:42:27.106 --> 00:42:29.396 A:middle
so that it will run a little bit
faster than the interpreter."

00:42:29.876 --> 00:42:30.956 A:middle
So, this is the fast JIT.

00:42:32.366 --> 00:42:36.236 A:middle
And, when WebKit sees that you
execute a function many times,

00:42:36.806 --> 00:42:39.726 A:middle
then it says, "All right,
let's also take the time

00:42:39.936 --> 00:42:41.596 A:middle
and optimize this
function real quick,

00:42:41.836 --> 00:42:44.256 A:middle
so that it will run a
little bit more faster,

00:42:44.256 --> 00:42:45.286 A:middle
a little bit faster."

00:42:45.676 --> 00:42:49.736 A:middle
So, we have the interpreter,
we have the fast JIT,

00:42:50.126 --> 00:42:54.176 A:middle
and we have the optimizing
JIT, and there are tradeoffs

00:42:54.176 --> 00:42:56.836 A:middle
between compile time and
the quality of the code.

00:42:57.186 --> 00:43:00.256 A:middle
And this works really great,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:57.186 --> 00:43:00.256 A:middle
And this works really great,

00:43:01.136 --> 00:43:03.096 A:middle
except that JavaScript
is evolving.

00:43:04.146 --> 00:43:05.986 A:middle
People start writing large,

00:43:06.106 --> 00:43:08.696 A:middle
compute intensive
applications in JavaScript.

00:43:09.346 --> 00:43:13.356 A:middle
People then compile C++
programs into JavaScript

00:43:13.776 --> 00:43:15.326 A:middle
and run them in the browser.

00:43:15.586 --> 00:43:18.256 A:middle
You can even compile
a Quake3 and run it

00:43:18.256 --> 00:43:20.446 A:middle
in your browser today,
which is --

00:43:20.486 --> 00:43:22.266 A:middle
some people like it [laughter].

00:43:23.586 --> 00:43:25.716 A:middle
Yeah, it's great.

00:43:26.436 --> 00:43:30.956 A:middle
But, it's a new-use case
and we need a new compiler

00:43:31.306 --> 00:43:32.356 A:middle
to support this use-case,

00:43:32.926 --> 00:43:35.476 A:middle
and this is where LLVM
comes into the picture.

00:43:36.986 --> 00:43:41.446 A:middle
So, we're adding LLVM as a
fourth tier compiler to WebKit.

00:43:43.896 --> 00:43:45.796 A:middle
Functions that run many, many,

00:43:45.796 --> 00:43:48.906 A:middle
many times are now
compiled with LLVM.

00:43:49.096 --> 00:43:52.716 A:middle
And, LLVM is tuned for making
the most out of your code,

00:43:52.716 --> 00:43:55.736 A:middle
for really trying hard
to optimize your code

00:43:55.966 --> 00:43:59.366 A:middle
and to generate excellent
code quality.

00:43:59.746 --> 00:44:03.106 A:middle
And again, there's a
tradeoff between compiled time


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.746 --> 00:44:03.106 A:middle
And again, there's a
tradeoff between compiled time

00:44:03.386 --> 00:44:06.286 A:middle
and the quality of the code,
so WebKit really waits for you

00:44:06.286 --> 00:44:09.426 A:middle
to execute that function
many, many times as you do

00:44:09.426 --> 00:44:10.976 A:middle
in computing intensive
applications

00:44:11.016 --> 00:44:11.856 A:middle
that you run in the browser.

00:44:11.856 --> 00:44:17.746 A:middle
But, compiling JavaScript
with LLVM is very different

00:44:17.746 --> 00:44:21.126 A:middle
from compiling C or Objective-C
because JavaScript --

00:44:21.786 --> 00:44:24.446 A:middle
it's a great language,
it's a dynamic language,

00:44:24.446 --> 00:44:26.226 A:middle
and if you look at the code
on the screen you'll see

00:44:26.226 --> 00:44:27.726 A:middle
that there are no types.

00:44:28.356 --> 00:44:33.086 A:middle
There's this n argument
here, but what is n?

00:44:33.086 --> 00:44:34.246 A:middle
Is it an integer?

00:44:34.326 --> 00:44:35.346 A:middle
Is it double?

00:44:35.626 --> 00:44:36.436 A:middle
Is it a class?

00:44:37.306 --> 00:44:38.506 A:middle
It can be a lot of
different things.

00:44:39.706 --> 00:44:41.316 A:middle
So, how do we compile it?

00:44:41.906 --> 00:44:48.616 A:middle
Well luckily, WebKit executed
this function many, many, many,

00:44:48.616 --> 00:44:50.376 A:middle
many times before
with the interpreter,

00:44:50.526 --> 00:44:56.636 A:middle
so it knows that in the last
1000 times n was an integer.

00:44:57.006 --> 00:45:00.016 A:middle
So now, we can compile this code
assuming that n is an integer,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:57.006 --> 00:45:00.016 A:middle
So now, we can compile this code
assuming that n is an integer,

00:45:00.996 --> 00:45:03.406 A:middle
except that someone made decide

00:45:03.406 --> 00:45:06.466 A:middle
to pass an n that's
not an integer.

00:45:06.466 --> 00:45:09.206 A:middle
Someone may decide to
pass a double or a class

00:45:09.736 --> 00:45:12.266 A:middle
and then everything will
break and we can't allow that.

00:45:12.786 --> 00:45:13.866 A:middle
So, what do we do?

00:45:14.216 --> 00:45:15.606 A:middle
We use a technique
that's very similar

00:45:15.606 --> 00:45:16.936 A:middle
to what we did with
the vectorizer.

00:45:17.596 --> 00:45:18.336 A:middle
We add checks.

00:45:18.336 --> 00:45:19.896 A:middle
We make assumptions
and we add checks.

00:45:20.306 --> 00:45:21.946 A:middle
We assume that n is an integer.

00:45:22.806 --> 00:45:24.976 A:middle
We assume that n
does not overflow.

00:45:24.976 --> 00:45:28.476 A:middle
And then, we verify our
assumptions at runtime.

00:45:29.526 --> 00:45:30.486 A:middle
Okay, that's great.

00:45:30.966 --> 00:45:32.016 A:middle
But, what is the fallback?

00:45:32.016 --> 00:45:32.506 A:middle
What do we do?

00:45:33.276 --> 00:45:35.656 A:middle
When our assumptions
fail we have to go back

00:45:35.656 --> 00:45:38.676 A:middle
to the interpreter because only
the interpreter can handle all

00:45:38.676 --> 00:45:40.736 A:middle
these cases, all
these extreme cases.

00:45:42.426 --> 00:45:45.616 A:middle
But, moving back to the
interpreter is not simple

00:45:46.106 --> 00:45:47.826 A:middle
because we started
executing it in a code

00:45:47.826 --> 00:45:48.976 A:middle
and the function made changes.

00:45:48.976 --> 00:45:50.976 A:middle
We can't just start executing
it from the beginning.

00:45:51.736 --> 00:45:54.536 A:middle
So, we developed a technology
that's called On-Stack

00:45:54.536 --> 00:45:57.406 A:middle
Replacement, which is
techniques that is used

00:45:57.856 --> 00:46:01.856 A:middle
to migrate the state of the
program from the JITed code


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:57.856 --> 00:46:01.856 A:middle
to migrate the state of the
program from the JITed code

00:46:01.856 --> 00:46:03.886 A:middle
in LLVM back to WebKit.

00:46:04.156 --> 00:46:07.486 A:middle
And, LLVM needs to track all of
the variables in your program

00:46:07.486 --> 00:46:09.966 A:middle
and some of them may be in the
register, some of them may be

00:46:09.966 --> 00:46:13.406 A:middle
in the stack, and now we're
able to migrate them from LLVM

00:46:13.406 --> 00:46:17.666 A:middle
to WebKit and continue
the execution in WebKit.

00:46:17.906 --> 00:46:22.726 A:middle
Now, this doesn't happen all the
time, it's a very extreme case.

00:46:22.726 --> 00:46:24.806 A:middle
But when it happens, we
have to handle these cases.

00:46:26.996 --> 00:46:32.086 A:middle
Okay, now compiling code
with LLVM is very beneficial,

00:46:32.086 --> 00:46:35.956 A:middle
especially for compute intensive
applications and especially

00:46:36.226 --> 00:46:39.106 A:middle
for these C++ applications
compiled

00:46:39.106 --> 00:46:40.976 A:middle
into JavaScript,
run in the browser.

00:46:43.986 --> 00:46:45.596 A:middle
And, we're really excited
about this technology.

00:46:45.886 --> 00:46:46.216 A:middle
It's great.

00:46:47.176 --> 00:46:49.966 A:middle
So now, we use LLVM.

00:46:50.386 --> 00:46:53.566 A:middle
So to summarize, we use LLVM
as a fourth tier compiler

00:46:53.966 --> 00:47:00.006 A:middle
in Safari, both for X86
and ARM64 on iOS and OS X,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:53.966 --> 00:47:00.006 A:middle
in Safari, both for X86
and ARM64 on iOS and OS X,

00:47:00.006 --> 00:47:02.306 A:middle
and we get excellent
performance speedups.

00:47:03.336 --> 00:47:05.276 A:middle
To summarize this
talk, today we talked

00:47:05.276 --> 00:47:08.286 A:middle
about modernizing Objective-C
code and we also talked

00:47:08.286 --> 00:47:09.946 A:middle
about a number of
performance features.

00:47:10.716 --> 00:47:12.326 A:middle
If you have any more questions,

00:47:12.326 --> 00:47:15.966 A:middle
you can contact our Developer
Tools Evangelist, Dave DeLong

00:47:16.156 --> 00:47:19.276 A:middle
or you can go to the Apple
website or to the LLVM website.

00:47:19.476 --> 00:47:24.046 A:middle
There are a few related
sessions, and I encourage you

00:47:24.046 --> 00:47:26.496 A:middle
to attend these sessions
or to watch them online.

00:47:28.506 --> 00:47:31.756 A:middle
Thank you, very much,
and have a good week.

00:47:32.436 --> 00:47:32.896 A:middle
Bye-bye.

00:47:33.016 --> 00:47:35.000 A:middle
[ Applause ]

