WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:11.516 A:middle
[ Silence ]

00:00:12.016 --> 00:00:16.000 A:middle
[ Applause ]

00:00:16.516 --> 00:00:16.986 A:middle
&gt;&gt; Welcome.

00:00:18.216 --> 00:00:19.176 A:middle
So I'm Doug Gregor.

00:00:19.416 --> 00:00:22.656 A:middle
I'm an engineer on the Swift
Compiler Team, and we're here

00:00:22.656 --> 00:00:24.976 A:middle
to talk about Swift
Interoperabiity.

00:00:28.626 --> 00:00:30.416 A:middle
We're going to talk about a
couple of different things here.

00:00:31.166 --> 00:00:33.986 A:middle
So, of course, Swift is
a new language for Cocoa

00:00:33.986 --> 00:00:35.526 A:middle
and Cocoa Touch development.

00:00:36.856 --> 00:00:38.746 A:middle
Now, Cocoa's not
written in Swift.

00:00:38.746 --> 00:00:41.286 A:middle
It's written in Objective-C,
a language you've been using

00:00:41.286 --> 00:00:43.526 A:middle
for years and that all of
your apps are written in.

00:00:44.276 --> 00:00:47.036 A:middle
So, interoperability between
these two very different

00:00:47.036 --> 00:00:49.626 A:middle
programming languages
is absolutely critical.

00:00:50.106 --> 00:00:52.636 A:middle
So we're going to talk about
how that interoperating works

00:00:53.076 --> 00:00:54.576 A:middle
at the language level.

00:00:55.116 --> 00:00:58.786 A:middle
We're going to hit a number
of different topics today.

00:00:59.426 --> 00:01:01.336 A:middle
We're going to talk
about working with Cocoa,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.426 --> 00:01:01.336 A:middle
We're going to talk
about working with Cocoa,

00:01:01.436 --> 00:01:06.816 A:middle
seeing how the Cocoa APIs or
Objective-C APIs look and feel

00:01:06.816 --> 00:01:09.916 A:middle
in Swift and how to work
with them, as well as working

00:01:09.916 --> 00:01:13.786 A:middle
with some more Swift concepts
like dealing with AnyObject

00:01:13.786 --> 00:01:17.046 A:middle
and doing dynamic
checks on your types.

00:01:18.106 --> 00:01:20.206 A:middle
Then we're going to
talk about bridging

00:01:20.526 --> 00:01:24.216 A:middle
of the core Cocoa datatypes
and NSArray, NSDictionary,

00:01:24.366 --> 00:01:27.386 A:middle
NSString into their
Swift-native equivalents.

00:01:28.616 --> 00:01:30.796 A:middle
Then we'll move on
to subclassing,

00:01:30.946 --> 00:01:33.946 A:middle
so writing Swift classes that
subclass from Objective-C

00:01:34.186 --> 00:01:36.576 A:middle
and how they're mapped
back into Objective-C

00:01:36.856 --> 00:01:38.926 A:middle
so that you can use these
two languages together.

00:01:40.156 --> 00:01:42.526 A:middle
And, finally, we're going to
talk about Core Foundation

00:01:42.526 --> 00:01:44.316 A:middle
and Core Graphics, and
this general notion

00:01:44.316 --> 00:01:48.276 A:middle
of CF Interoperability within
the Swift programming language.

00:01:48.806 --> 00:01:53.366 A:middle
Let's get started talking
about working with Cocoa.

00:01:55.466 --> 00:01:59.616 A:middle
So Swift provides seamless
access to Objective-C APIs

00:01:59.916 --> 00:02:03.166 A:middle
through the Objective-C Module
System we introduced last year.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.916 --> 00:02:03.166 A:middle
through the Objective-C Module
System we introduced last year.

00:02:03.796 --> 00:02:06.986 A:middle
So you can pull your Objective-C
APIs whether they be from Cocoa

00:02:06.986 --> 00:02:09.826 A:middle
or your own into
Swift and use them.

00:02:10.556 --> 00:02:13.206 A:middle
And then Swift maps
those Objective-C APIs

00:02:13.306 --> 00:02:15.126 A:middle
into the Swift syntax.

00:02:15.836 --> 00:02:19.186 A:middle
This covers both the objective
parts of Objective-C -

00:02:19.306 --> 00:02:21.656 A:middle
the classes, protocols,
methods, and so on,

00:02:22.116 --> 00:02:24.856 A:middle
as well as the lower level
C things like functions,

00:02:24.856 --> 00:02:26.956 A:middle
enumerations, structs, pointers.

00:02:27.456 --> 00:02:29.966 A:middle
So you have access to all
of your Objective-C APIs.

00:02:31.456 --> 00:02:33.926 A:middle
Now when you look at one of
these Objective-C APIs in Swift,

00:02:34.486 --> 00:02:36.366 A:middle
it's going to be
different from Objective-C.

00:02:37.316 --> 00:02:39.286 A:middle
There are inherent
syntactic differences

00:02:39.336 --> 00:02:41.346 A:middle
between these two
language, of course.

00:02:42.426 --> 00:02:46.506 A:middle
Swift also has some
modern features that we use

00:02:46.506 --> 00:02:49.266 A:middle
when expressing those
Objective-C APIs in Swift

00:02:49.266 --> 00:02:51.196 A:middle
that will make it look
a little bit different,

00:02:51.516 --> 00:02:54.066 A:middle
as well as the bridging
of core Cocoa types

00:02:54.316 --> 00:02:55.306 A:middle
that I mentioned earlier.

00:02:55.926 --> 00:02:59.486 A:middle
Now, despite all of these
differences that you see

00:02:59.486 --> 00:03:02.396 A:middle
when looking at the
APIs, it's still Cocoa,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.486 --> 00:03:02.396 A:middle
when looking at the
APIs, it's still Cocoa,

00:03:02.586 --> 00:03:04.006 A:middle
it's still Cocoa Touch.

00:03:04.236 --> 00:03:07.366 A:middle
And the same conventions
and idioms still apply,

00:03:07.766 --> 00:03:10.166 A:middle
so what you know of
Cocoa works in Swift.

00:03:10.206 --> 00:03:11.676 A:middle
It's just a different
programming language

00:03:11.766 --> 00:03:14.646 A:middle
for the same great platform,
the same great frameworks.

00:03:16.136 --> 00:03:19.356 A:middle
So we're going to walk through
part of something we know

00:03:19.356 --> 00:03:22.336 A:middle
and love, and that's
the UIDocument class.

00:03:23.736 --> 00:03:26.456 A:middle
Here's a tiny slice
of it in Objective-C.

00:03:26.846 --> 00:03:30.706 A:middle
We're going to walk through how
and why that maps into Swift.

00:03:31.546 --> 00:03:35.656 A:middle
First thing, something simple, a
property: fileModificationDate.

00:03:35.656 --> 00:03:36.596 A:middle
It is an NSDate!.

00:03:37.826 --> 00:03:40.756 A:middle
This comes into Swift
as a property.

00:03:40.986 --> 00:03:41.956 A:middle
It's the var keyword.

00:03:42.536 --> 00:03:45.536 A:middle
The NSDate class, of course
just comes into Swift.

00:03:45.536 --> 00:03:47.346 A:middle
Nothing interesting there except

00:03:47.346 --> 00:03:50.396 A:middle
for this little exclamation
point that you may have noticed.

00:03:50.896 --> 00:03:55.966 A:middle
Now that exclamation point is an
Implicitly Unwrapped Optional.

00:03:56.486 --> 00:03:58.846 A:middle
What does that mean?

00:03:59.156 --> 00:04:01.456 A:middle
Well, let's look at
Swift in Objective-C.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.156 --> 00:04:01.456 A:middle
Well, let's look at
Swift in Objective-C.

00:04:01.456 --> 00:04:03.946 A:middle
They're different languages with
some different ideas in them.

00:04:04.456 --> 00:04:06.616 A:middle
So in Swift, when
you have a value

00:04:06.616 --> 00:04:09.366 A:middle
of class type, so
I have an NSDate!

00:04:09.866 --> 00:04:11.746 A:middle
That can never be nil.

00:04:12.466 --> 00:04:13.826 A:middle
So a very strong constraint.

00:04:14.566 --> 00:04:16.616 A:middle
And it makes life a bit
simpler when you know

00:04:16.616 --> 00:04:17.565 A:middle
that thing is not nil.

00:04:19.036 --> 00:04:21.646 A:middle
Now, when you want to deal
with nil, you have an NSDate!

00:04:21.646 --> 00:04:25.056 A:middle
that could be nil, you
use an optional type,

00:04:25.236 --> 00:04:27.526 A:middle
and optional types are
covered extensively in the

00:04:27.526 --> 00:04:29.506 A:middle
"Intermediate Swift" talk.

00:04:30.046 --> 00:04:31.526 A:middle
We're going to cover them
a little bit more now.

00:04:32.976 --> 00:04:34.546 A:middle
That's the Swift side of things.

00:04:34.986 --> 00:04:36.226 A:middle
What about Objective-C?

00:04:36.656 --> 00:04:39.756 A:middle
Well, it does not have
the notion of a never

00:04:39.756 --> 00:04:42.816 A:middle
"never-nil" pointer
like we have in Swift.

00:04:43.356 --> 00:04:45.876 A:middle
And so we have a little
impedance mismatch here.

00:04:45.876 --> 00:04:50.256 A:middle
The Objective-C APIs don't have
the notion of this is not nil,

00:04:50.256 --> 00:04:52.146 A:middle
but we need to bring
them into Swift.

00:04:52.796 --> 00:04:56.066 A:middle
And so, we have the
implicitly unwrapped optional

00:04:56.146 --> 00:04:57.486 A:middle
with the exclamation point here.

00:04:57.486 --> 00:04:59.916 A:middle
And this gives us
a nice balance.

00:04:59.916 --> 00:05:02.336 A:middle
It means that we can
express the notion of nil


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.916 --> 00:05:02.336 A:middle
It means that we can
express the notion of nil

00:05:03.006 --> 00:05:05.686 A:middle
and you can test it against
nil to do those checks.

00:05:06.426 --> 00:05:09.656 A:middle
However, you can also just
directly access properties

00:05:09.656 --> 00:05:12.346 A:middle
or directly call a method
on it, or you can convert it

00:05:12.346 --> 00:05:14.786 A:middle
down to NSNil, and we'll unwrap

00:05:14.936 --> 00:05:17.116 A:middle
that optional object
automatically

00:05:17.116 --> 00:05:17.976 A:middle
for you doing the checking.

00:05:18.046 --> 00:05:21.976 A:middle
So it's a fairly syntactically
lightweight way of dealing

00:05:21.976 --> 00:05:26.786 A:middle
with nil in a language where nil
is a much more explicit entity

00:05:27.376 --> 00:05:28.006 A:middle
like in Swift.

00:05:29.406 --> 00:05:32.976 A:middle
Let's look at another property.

00:05:33.096 --> 00:05:35.396 A:middle
So here we have the fileType
property that's in NSString.

00:05:36.676 --> 00:05:42.456 A:middle
This is going to come into
Swift as a native Swift string.

00:05:43.196 --> 00:05:45.636 A:middle
Now, again, we have the
implicitly unwrapped optional

00:05:45.636 --> 00:05:47.876 A:middle
here so that nil can be passed

00:05:47.876 --> 00:05:50.866 A:middle
through since NSString doesn't
have a notion of nil inside it.

00:05:52.446 --> 00:05:55.106 A:middle
And there's a number
of Objective-C types

00:05:55.286 --> 00:05:58.056 A:middle
that get mapped slightly
differently into Swift.

00:05:58.776 --> 00:06:01.846 A:middle
So there's some very, very
fundamental types like BOOL


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.776 --> 00:06:01.846 A:middle
So there's some very, very
fundamental types like BOOL

00:06:01.896 --> 00:06:07.036 A:middle
and NSInteger that map into the
Bool and Int types within Swift.

00:06:07.256 --> 00:06:08.846 A:middle
So we're working with
all the Swift types.

00:06:09.636 --> 00:06:11.606 A:middle
There's id and Class,

00:06:11.606 --> 00:06:14.396 A:middle
which we're very familiar
with in Objective-C.

00:06:14.676 --> 00:06:16.496 A:middle
These map over to AnyObject!

00:06:16.496 --> 00:06:18.396 A:middle
and AnyClass!, something
we're going to talk

00:06:18.396 --> 00:06:19.346 A:middle
about in a couple of minutes.

00:06:20.366 --> 00:06:22.746 A:middle
And we also have the core
Cocoa types that are bridged,

00:06:22.746 --> 00:06:24.066 A:middle
like NSString and NSArray,

00:06:24.326 --> 00:06:26.586 A:middle
mapping to their
Swift-native equivalents.

00:06:26.776 --> 00:06:28.616 A:middle
Again, we'll talk about
that later in this talk.

00:06:29.956 --> 00:06:31.106 A:middle
Let's take a look at methods.

00:06:32.346 --> 00:06:34.706 A:middle
There's an Objective-C method
fileNameExtensionForType,

00:06:34.776 --> 00:06:35.796 A:middle
saveOperation.

00:06:36.356 --> 00:06:39.796 A:middle
It comes into Swift here
as, again, a method.

00:06:40.906 --> 00:06:43.946 A:middle
Now, one important thing
to know here is that all

00:06:43.946 --> 00:06:47.596 A:middle
of the selector pieces from
the Objective-C method are here

00:06:47.666 --> 00:06:49.926 A:middle
in the method's signature
in Swift.

00:06:50.556 --> 00:06:53.236 A:middle
The first selector piece has
become the so-called base name

00:06:53.236 --> 00:06:53.846 A:middle
of the method.

00:06:54.436 --> 00:06:56.816 A:middle
The second selector
piece, SaveOperation,

00:06:57.226 --> 00:07:00.576 A:middle
has become a label on
the second argument.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.226 --> 00:07:00.576 A:middle
has become a label on
the second argument.

00:07:01.966 --> 00:07:05.046 A:middle
A really important thing
here is that these labels

00:07:05.306 --> 00:07:08.846 A:middle
and their order are
enforced at the call site.

00:07:09.656 --> 00:07:13.026 A:middle
So, you must call it as
fileNameExtensionForType,

00:07:13.266 --> 00:07:15.746 A:middle
saveOperation, just
like you do in Cocoa

00:07:16.036 --> 00:07:18.236 A:middle
with the exact same
ordering, so to preserve

00:07:18.506 --> 00:07:21.416 A:middle
that nice readability from
Cocoa that we all know and love.

00:07:23.466 --> 00:07:26.516 A:middle
Now the other thing to note
here is the consistency here

00:07:26.516 --> 00:07:27.296 A:middle
on the Swift side.

00:07:28.496 --> 00:07:31.106 A:middle
All of the names and the
colons and the parentheses

00:07:31.106 --> 00:07:33.586 A:middle
and the commas are in
exactly the same places

00:07:34.166 --> 00:07:37.206 A:middle
in the declaration of
the method in the middle

00:07:37.676 --> 00:07:39.946 A:middle
and in the call site of
the method at the bottom.

00:07:39.946 --> 00:07:41.846 A:middle
So the kind of consistency
we like out

00:07:41.846 --> 00:07:43.196 A:middle
of building a new language.

00:07:43.196 --> 00:07:47.296 A:middle
Let's look at a little bit
more complicated method here

00:07:47.296 --> 00:07:48.646 A:middle
where we have some
blocks going on,

00:07:48.646 --> 00:07:51.506 A:middle
some more interesting things,
and map that into Swift.

00:07:52.326 --> 00:07:54.556 A:middle
And here there are two different
things I want to talk about.

00:07:54.596 --> 00:07:58.496 A:middle
The first thing I want to
talk about is the naming

00:07:58.586 --> 00:08:02.096 A:middle
of these argument labels and
the internal parameter names.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:58.586 --> 00:08:02.096 A:middle
of these argument labels and
the internal parameter names.

00:08:02.676 --> 00:08:05.816 A:middle
So here in Objective-C you
always have a selector piece,

00:08:06.556 --> 00:08:07.586 A:middle
goes before the colon.

00:08:07.976 --> 00:08:10.666 A:middle
And then you have the name of
the - at the internal parameter

00:08:10.956 --> 00:08:13.016 A:middle
that you use when you're
defining the method

00:08:13.016 --> 00:08:14.196 A:middle
in your .m file.

00:08:14.406 --> 00:08:17.416 A:middle
In Objective-C you always
have to write both of these,

00:08:17.416 --> 00:08:19.536 A:middle
of course, and many
times they're the same.

00:08:19.536 --> 00:08:20.696 A:middle
So you have some redundancy.

00:08:21.316 --> 00:08:24.566 A:middle
We do a little bit of syntax
optimization here in Swift,

00:08:24.566 --> 00:08:25.866 A:middle
so you just write the name once.

00:08:26.236 --> 00:08:28.996 A:middle
It serves both as the label
and the internal name.

00:08:29.906 --> 00:08:32.525 A:middle
If you want those names
to be different, fine,

00:08:32.525 --> 00:08:33.576 A:middle
we can handle that, too.

00:08:33.706 --> 00:08:35.416 A:middle
You just write the two
names next to each other.

00:08:35.626 --> 00:08:37.816 A:middle
The first one is the label
because that's what's important

00:08:37.816 --> 00:08:38.996 A:middle
for the caller to use.

00:08:39.616 --> 00:08:42.376 A:middle
And then the second one is the
internal name that you're going

00:08:42.376 --> 00:08:44.896 A:middle
to use within the
implementation of your method.

00:08:46.366 --> 00:08:50.106 A:middle
The next thing I want to
point out here is the Block.

00:08:51.436 --> 00:08:54.596 A:middle
So here we have a method
that takes a Block,

00:08:55.126 --> 00:08:59.716 A:middle
and Blocks in Objective-C get
mapped into Closures in Swift.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.566 --> 00:09:03.316 A:middle
You see, again, this is an
implicitly unwrapped optional

00:09:03.536 --> 00:09:05.936 A:middle
so that you can pass
a nil Block in here.

00:09:07.486 --> 00:09:08.806 A:middle
Now the really great thing

00:09:09.076 --> 00:09:13.036 A:middle
about getting Objective-C Blocks
mapped into Swift Closures is

00:09:13.036 --> 00:09:16.316 A:middle
that we get all of the great
closure syntax that is provided

00:09:16.316 --> 00:09:18.766 A:middle
by Swift, including
trailing closures

00:09:18.986 --> 00:09:20.826 A:middle
when your block is
the last parameter.

00:09:21.356 --> 00:09:23.816 A:middle
So all of your block-based
APIs that you've written,

00:09:23.886 --> 00:09:26.526 A:middle
all the ones from Cocoa, when
they're following the convention

00:09:26.526 --> 00:09:30.736 A:middle
of putting the block last get
this nice trailing closure

00:09:30.736 --> 00:09:31.736 A:middle
syntax in Swift.

00:09:32.166 --> 00:09:37.026 A:middle
Let's talk a little
bit about Initializers.

00:09:38.626 --> 00:09:41.796 A:middle
So in Objective-C
we have init methods

00:09:42.576 --> 00:09:46.506 A:middle
and init methods have a lot of
conventions built around them.

00:09:47.036 --> 00:09:48.376 A:middle
They start with the word "init."

00:09:49.046 --> 00:09:51.016 A:middle
They should be returning
instance type,

00:09:51.546 --> 00:09:52.966 A:middle
although that's a
fairly new invention.

00:09:52.966 --> 00:09:54.746 A:middle
So sometimes they're
still returning ID.

00:09:56.206 --> 00:09:58.036 A:middle
And when you're implementing
these things,

00:09:58.036 --> 00:09:59.356 A:middle
you have a lot of requirements.

00:09:59.356 --> 00:09:59.966 A:middle
You need to call "super init."


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:00.046 --> 00:10:01.896 A:middle
You need to reassign "self."

00:10:01.896 --> 00:10:03.996 A:middle
You need to check "self,"
you need to return "self."

00:10:05.926 --> 00:10:09.666 A:middle
So all of this screams, we
need something formalized

00:10:09.696 --> 00:10:10.506 A:middle
in the language.

00:10:10.536 --> 00:10:13.476 A:middle
And so Swift has this
notion of Initializers.

00:10:13.906 --> 00:10:18.236 A:middle
And we import Objective-C init
methods as Swift Initializers.

00:10:19.206 --> 00:10:21.696 A:middle
How do we get from the
top Objective-C code

00:10:21.696 --> 00:10:23.016 A:middle
to the Swift code in the bottom?

00:10:23.526 --> 00:10:27.436 A:middle
Well, we find the init,
so we match the init name

00:10:27.436 --> 00:10:28.916 A:middle
and the camel-case string here.

00:10:28.916 --> 00:10:31.586 A:middle
We actually look forward
a little bit to see

00:10:31.586 --> 00:10:34.546 A:middle
if it's really initWith
because that's extremely common.

00:10:34.986 --> 00:10:37.756 A:middle
And then we take the
rest of that Selector,

00:10:37.846 --> 00:10:39.826 A:middle
and lowercase the
first character in it,

00:10:40.146 --> 00:10:43.666 A:middle
and turn that into an argument
label for the Swift Initializer.

00:10:44.976 --> 00:10:45.866 A:middle
Now, why do we do this?

00:10:45.866 --> 00:10:47.736 A:middle
Well, let's look at
how we build objects

00:10:47.736 --> 00:10:49.996 A:middle
in Objective-C versus in Swift.

00:10:50.566 --> 00:10:54.196 A:middle
So in Objective-C you do
an alloc on your class

00:10:54.386 --> 00:10:58.256 A:middle
and then you immediately
send it an init message

00:10:58.386 --> 00:10:59.556 A:middle
to initialize the Object.

00:10:59.846 --> 00:11:02.246 A:middle
These two steps are
almost never separated.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.846 --> 00:11:02.246 A:middle
These two steps are
almost never separated.

00:11:02.866 --> 00:11:07.376 A:middle
Now in Swift we have
our Initializers

00:11:07.856 --> 00:11:11.116 A:middle
and we use this Unified
Object Construction syntax

00:11:11.386 --> 00:11:13.176 A:middle
where we write the
name of the Class

00:11:13.536 --> 00:11:16.346 A:middle
and then we pass arguments
directly to the Initializer.

00:11:16.916 --> 00:11:20.626 A:middle
And notice here, we're using the
argument label of fileURL to say

00:11:20.626 --> 00:11:22.786 A:middle
which Initializer
we're actually using

00:11:23.146 --> 00:11:24.316 A:middle
and then give it the argument.

00:11:25.046 --> 00:11:27.556 A:middle
And, of course, we folded the
alloc and the init together

00:11:27.556 --> 00:11:29.906 A:middle
in this one nice syntax
that also happens to work

00:11:29.906 --> 00:11:32.216 A:middle
for all other types of in
Swift whether they be structs

00:11:32.216 --> 00:11:32.786 A:middle
or enums.

00:11:33.336 --> 00:11:38.186 A:middle
Okay. So let's talk
about factory methods

00:11:38.226 --> 00:11:40.026 A:middle
because this is the other way

00:11:40.176 --> 00:11:42.376 A:middle
that we build Objects
in Objective-C.

00:11:42.816 --> 00:11:44.746 A:middle
So here we have something
from UIColor.

00:11:44.746 --> 00:11:46.106 A:middle
I've stepped away
from UIDocument.

00:11:46.106 --> 00:11:48.316 A:middle
And they have colorWithRed
blue green alpha.

00:11:48.726 --> 00:11:50.366 A:middle
And, of course, we
can go and construct

00:11:50.366 --> 00:11:55.366 A:middle
that by calling UIColor
colorWithRed green blue alpha.

00:11:55.616 --> 00:11:58.206 A:middle
All of this can be
directly imported in Swift.

00:11:58.646 --> 00:12:01.496 A:middle
It would just be a class
method, colorwithRed,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.646 --> 00:12:01.496 A:middle
It would just be a class
method, colorwithRed,

00:12:01.496 --> 00:12:04.406 A:middle
and green blue alpha
as argument labels,

00:12:04.846 --> 00:12:07.456 A:middle
and we could just
call it on the class.

00:12:08.396 --> 00:12:09.286 A:middle
This would be fine.

00:12:09.286 --> 00:12:10.876 A:middle
However, we don't really love

00:12:10.876 --> 00:12:12.626 A:middle
that they're two
completely different kinds

00:12:12.626 --> 00:12:13.626 A:middle
of initialization.

00:12:14.916 --> 00:12:19.496 A:middle
So we recognize the
common patterns

00:12:19.496 --> 00:12:22.066 A:middle
in how factory methods are
described in Objective-C,

00:12:22.236 --> 00:12:24.786 A:middle
and bring them in as
Swift Initializers.

00:12:25.976 --> 00:12:27.906 A:middle
And the really great
thing here is we get

00:12:27.906 --> 00:12:31.416 A:middle
that common Initialization
syntax for all

00:12:31.416 --> 00:12:32.816 A:middle
of these Objective-C APIs.

00:12:33.266 --> 00:12:35.396 A:middle
You don't have to think, "Is
there an init method for this?

00:12:35.396 --> 00:12:38.156 A:middle
Or is there a class
method for this?"

00:12:39.046 --> 00:12:40.486 A:middle
It's there as an Initializer.

00:12:43.176 --> 00:12:43.956 A:middle
Do you like that?

00:12:44.516 --> 00:12:49.026 A:middle
[ Applause ]

00:12:49.526 --> 00:12:51.166 A:middle
Let's go a little
bit down the stack

00:12:51.586 --> 00:12:52.856 A:middle
and let's talk about Enums.

00:12:54.006 --> 00:12:56.826 A:middle
So here's the
UIDocumentSaveOperation enum

00:12:57.186 --> 00:12:58.556 A:middle
as defined in Objective-C.

00:12:59.646 --> 00:13:02.666 A:middle
And if we look at this we see
a whole lot of redundancy.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.646 --> 00:13:02.666 A:middle
And if we look at this we see
a whole lot of redundancy.

00:13:03.416 --> 00:13:06.646 A:middle
This UIDocumentSave
prefix is used for the enum

00:13:06.916 --> 00:13:09.136 A:middle
and for both of its enum values.

00:13:10.066 --> 00:13:10.986 A:middle
Why is this?

00:13:10.986 --> 00:13:12.436 A:middle
Well, this is C.

00:13:13.236 --> 00:13:16.896 A:middle
The enum values in C are
in a global namespace.

00:13:17.276 --> 00:13:20.386 A:middle
We can't call these enum
values just ForCreating

00:13:20.386 --> 00:13:22.456 A:middle
and ForOverwriting because
that's going to stomp

00:13:22.456 --> 00:13:25.016 A:middle
on some other completely
different enumeration somewhere

00:13:25.016 --> 00:13:27.546 A:middle
else in the system
and cause havoc.

00:13:28.396 --> 00:13:31.456 A:middle
So we do this common
prefix by convention.

00:13:31.496 --> 00:13:33.506 A:middle
It helps code completion
find the right thing.

00:13:33.506 --> 00:13:37.196 A:middle
But when we're talking about
Swift, it's also a great cue

00:13:37.196 --> 00:13:38.776 A:middle
for us that we can do better.

00:13:39.376 --> 00:13:42.036 A:middle
And so we can import
this NS-ENUM

00:13:42.506 --> 00:13:46.876 A:middle
as a Swift enum chopping off
all of those common prefixes

00:13:47.116 --> 00:13:49.396 A:middle
to get us nice short
names for the cases.

00:13:50.886 --> 00:13:54.126 A:middle
Now the reason we can do this
is because the enum cases

00:13:54.126 --> 00:13:57.446 A:middle
in Swift are scoped within
the enum type itself.

00:13:58.016 --> 00:14:02.026 A:middle
How does this play
out in actual code?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.016 --> 00:14:02.026 A:middle
How does this play
out in actual code?

00:14:02.596 --> 00:14:04.656 A:middle
Well, okay, if we call
fileNameExtensionForType

00:14:04.656 --> 00:14:08.606 A:middle
saveOperation, we can
refer to, say ForCreating,

00:14:09.306 --> 00:14:12.216 A:middle
with its fully dotted
name - class name.enum,

00:14:12.216 --> 00:14:13.996 A:middle
the same dotted syntax we use

00:14:14.146 --> 00:14:16.686 A:middle
for a number of anything
in Swift.

00:14:17.896 --> 00:14:19.626 A:middle
But Swift has type inference.

00:14:20.496 --> 00:14:23.426 A:middle
We know that this method takes
the UIDocumentSaveOperation,

00:14:23.536 --> 00:14:25.446 A:middle
so there's absolutely
no reason to write that.

00:14:25.756 --> 00:14:27.626 A:middle
You can just pass .ForCreating

00:14:27.626 --> 00:14:30.546 A:middle
and we will infer the
enum type from that.

00:14:36.046 --> 00:14:38.426 A:middle
I'd also like to
talk about NSError.

00:14:39.276 --> 00:14:43.086 A:middle
So this is our pattern in
Cocoa for dealing with errors.

00:14:43.676 --> 00:14:45.846 A:middle
And so there are many
methods throughout Cocoa

00:14:45.846 --> 00:14:48.896 A:middle
and throughout your own
apps that take an NSError ,

00:14:49.106 --> 00:14:53.266 A:middle
and that's a C pointer
to an NSError object.

00:14:53.896 --> 00:14:57.076 A:middle
We bring this in with a
special type in Swift.

00:14:57.166 --> 00:14:58.216 A:middle
In fact, if you type alias

00:14:58.216 --> 00:15:01.896 A:middle
for a much longer type
name call NSErrorPointer.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.216 --> 00:15:01.896 A:middle
for a much longer type
name call NSErrorPointer.

00:15:03.026 --> 00:15:03.356 A:middle
We're going

00:15:03.356 --> 00:15:05.976 A:middle
to see NSErrorPointer
twice in this talk.

00:15:06.826 --> 00:15:08.846 A:middle
For now we're going to
talk about how to use it

00:15:09.356 --> 00:15:11.326 A:middle
when we're calling into the API.

00:15:13.036 --> 00:15:15.646 A:middle
And it's not actually all that
much different from Objective-C.

00:15:16.506 --> 00:15:20.506 A:middle
So, if we bring this up, we
declare a local variable.

00:15:20.936 --> 00:15:22.026 A:middle
It's called error.

00:15:22.096 --> 00:15:24.036 A:middle
It's a type NSError optional.

00:15:24.996 --> 00:15:27.566 A:middle
And we pass its address
in when we're calling

00:15:27.566 --> 00:15:28.766 A:middle
contentsForType error.

00:15:30.076 --> 00:15:32.816 A:middle
And so in this code we check
whether we're getting back some

00:15:32.816 --> 00:15:33.826 A:middle
contents from this.

00:15:34.726 --> 00:15:36.106 A:middle
Then we can deal
with those contents.

00:15:36.736 --> 00:15:39.446 A:middle
If we fail to find any contents
well, we probably have an error.

00:15:39.446 --> 00:15:42.056 A:middle
So we can go unwrap
that optional error

00:15:42.356 --> 00:15:43.726 A:middle
and present it to the user.

00:15:44.126 --> 00:15:46.626 A:middle
And if we fall through the
else here, now we're in trouble

00:15:46.626 --> 00:15:49.256 A:middle
because something failed and we
have nothing we can do about it.

00:15:49.906 --> 00:15:52.476 A:middle
We hope that doesn't happen.

00:15:52.686 --> 00:15:55.456 A:middle
But this is the pattern
you'll be using when dealing

00:15:55.456 --> 00:15:57.026 A:middle
with NSError in Swift.

00:15:57.296 --> 00:15:59.036 A:middle
If you truly don't
care about the error,

00:15:59.176 --> 00:16:00.176 A:middle
you can also pass nil.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.176 --> 00:16:00.176 A:middle
you can also pass nil.

00:16:01.656 --> 00:16:04.916 A:middle
So we've walked through
a lot of little pieces

00:16:05.356 --> 00:16:08.446 A:middle
of the Objective-C
mapping into Swift.

00:16:08.446 --> 00:16:11.306 A:middle
And there are a lot of
rules that we've talked

00:16:11.306 --> 00:16:13.016 A:middle
about that you're certainly
not going to remember.

00:16:14.166 --> 00:16:15.196 A:middle
That's perfectly fine.

00:16:15.366 --> 00:16:16.506 A:middle
Xcode has your back here.

00:16:17.226 --> 00:16:18.466 A:middle
Use the tools to help you.

00:16:19.026 --> 00:16:21.346 A:middle
So if you're in Xcode,
you're in some Swift Code,

00:16:21.346 --> 00:16:23.636 A:middle
you can Command+Click
on a class name.

00:16:23.886 --> 00:16:25.956 A:middle
And we'll show you
the Swift projection

00:16:26.276 --> 00:16:28.096 A:middle
of the underlying
Objective-C class.

00:16:28.896 --> 00:16:31.046 A:middle
So take your favorite
Cocoa class and look

00:16:31.046 --> 00:16:33.176 A:middle
at how it maps into Swift.

00:16:33.566 --> 00:16:35.616 A:middle
Get a feel for the
language, an intuitive feel

00:16:35.616 --> 00:16:38.806 A:middle
for how these languages
work together and you'll get

00:16:38.806 --> 00:16:40.336 A:middle
into Swift really fast.

00:16:41.126 --> 00:16:43.956 A:middle
And the great thing
is, all of these tools,

00:16:44.166 --> 00:16:47.016 A:middle
all the rules I've talked
about, apply equally

00:16:47.016 --> 00:16:50.976 A:middle
to any Objective-C API
when it comes into Swift.

00:16:51.416 --> 00:16:52.636 A:middle
It doesn't matter if it's Cocoa.

00:16:52.636 --> 00:16:53.776 A:middle
It doesn't matter if
it's your own API.

00:16:54.256 --> 00:16:58.876 A:middle
The same rules apply, and you
can view your own Objective-C

00:16:58.956 --> 00:17:01.186 A:middle
APIs in Swift to get
to know them better.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.956 --> 00:17:01.186 A:middle
APIs in Swift to get
to know them better.

00:17:02.246 --> 00:17:05.146 A:middle
Now this works best
when you're following

00:17:05.175 --> 00:17:07.136 A:middle
"modern" Objective-C practices.

00:17:07.705 --> 00:17:11.935 A:middle
So these are using features
like Properties, instancetype,

00:17:12.726 --> 00:17:15.915 A:middle
marking your enumerations
with NS-ENUM or NS-OPTIONS

00:17:15.965 --> 00:17:17.866 A:middle
to describe more
semantic information

00:17:17.866 --> 00:17:20.366 A:middle
about what these enums
actually mean in C.

00:17:21.616 --> 00:17:24.306 A:middle
We've also introduced
NS-DESIGNATED-INITIALIZER this

00:17:24.306 --> 00:17:27.086 A:middle
year to mark your
designated Initializers

00:17:27.606 --> 00:17:29.546 A:middle
and formalize a Designated
Initializer pattern,

00:17:29.546 --> 00:17:31.676 A:middle
both in Objective-C
through additional warnings,

00:17:32.306 --> 00:17:35.486 A:middle
and as the initialization
model for Swift.

00:17:36.736 --> 00:17:39.176 A:middle
So, of course, we want
you to follow all of these

00:17:39.176 --> 00:17:42.496 A:middle
"modern" Objective-C
practices but we don't want you

00:17:42.496 --> 00:17:43.296 A:middle
to have to go it alone.

00:17:44.046 --> 00:17:47.316 A:middle
And so this year we introduced
the Objective-C Modernizer

00:17:47.776 --> 00:17:50.296 A:middle
that helps find these
cases in your code

00:17:50.596 --> 00:17:53.376 A:middle
where we could possibly
modernize them to work

00:17:53.376 --> 00:17:55.496 A:middle
with all these "modern"
Objective-C features

00:17:55.786 --> 00:17:57.876 A:middle
and give you a better
projection into Swift.

00:17:58.426 --> 00:18:00.696 A:middle
And that Modernizer is
discussed in the "What's New


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.426 --> 00:18:00.696 A:middle
And that Modernizer is
discussed in the "What's New

00:18:00.696 --> 00:18:02.666 A:middle
in LLVM" talk earlier today.

00:18:03.296 --> 00:18:05.686 A:middle
Highly recommend you catch
it on video if you missed it.

00:18:08.096 --> 00:18:12.056 A:middle
With that, let's talk about id.

00:18:13.766 --> 00:18:15.176 A:middle
What is id in Objective-C?

00:18:15.736 --> 00:18:19.576 A:middle
It's kind of a placeholder
in some sense.

00:18:19.766 --> 00:18:21.596 A:middle
It means, I have a value.

00:18:22.016 --> 00:18:25.066 A:middle
I know it's an object
but I don't know

00:18:25.066 --> 00:18:28.686 A:middle
or I don't care what the
static type of that object is.

00:18:29.096 --> 00:18:30.996 A:middle
It's going to vary at
runtime most likely.

00:18:31.766 --> 00:18:34.026 A:middle
And there's a couple
of core operations

00:18:34.026 --> 00:18:35.316 A:middle
that you can perform on id.

00:18:35.316 --> 00:18:38.216 A:middle
You can do upcasting on it.

00:18:38.296 --> 00:18:41.996 A:middle
So, if I have this
variable object of type id,

00:18:42.366 --> 00:18:44.416 A:middle
I can put an NSURL into it.

00:18:45.406 --> 00:18:48.326 A:middle
Later I can go reassign it
and I can put a UIView on it.

00:18:48.736 --> 00:18:49.646 A:middle
That's perfectly fine.

00:18:49.806 --> 00:18:52.626 A:middle
They can both be upcasted
essentially to id.

00:18:52.806 --> 00:18:53.596 A:middle
They're both objects.

00:18:54.536 --> 00:18:57.796 A:middle
I can do Message sends
to id just directly

00:18:57.796 --> 00:18:58.816 A:middle
by doing a Message Send.

00:18:59.206 --> 00:19:02.786 A:middle
I can subscript an id
if I really feel like.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.206 --> 00:19:02.786 A:middle
I can subscript an id
if I really feel like.

00:19:03.516 --> 00:19:08.546 A:middle
In Swift, any object is
the equivalent to id.

00:19:08.546 --> 00:19:13.376 A:middle
And it provides these same
core operations - Upcasting,

00:19:13.796 --> 00:19:15.576 A:middle
Message Sends, Subscripting -

00:19:15.876 --> 00:19:17.736 A:middle
that you can do on
id in Objective-C.

00:19:17.736 --> 00:19:23.316 A:middle
Now one of the things we know
from using id in Objective-C is

00:19:23.316 --> 00:19:25.636 A:middle
that you sometimes have
to be a little bit careful

00:19:26.906 --> 00:19:28.816 A:middle
because if you send a
message to an object

00:19:29.386 --> 00:19:31.256 A:middle
that doesn't have a
corresponding method,

00:19:31.446 --> 00:19:33.036 A:middle
you're going to get
a runtime failure

00:19:33.036 --> 00:19:34.866 A:middle
that this is an unrecognized
selector.

00:19:35.916 --> 00:19:37.976 A:middle
Now in Objective-C we
have an answer for this.

00:19:38.456 --> 00:19:40.476 A:middle
Using this respondsToSelector
idiom.

00:19:40.966 --> 00:19:44.186 A:middle
Do an if. Check whether it
respondsToSelector, then do it.

00:19:45.356 --> 00:19:47.556 A:middle
In Swift we like to do
a little bit better.

00:19:48.556 --> 00:19:49.916 A:middle
So let's take the same call

00:19:49.916 --> 00:19:52.466 A:middle
and let's do a
removeFromSuperview() call

00:19:52.466 --> 00:19:53.076 A:middle
on this object.

00:19:54.506 --> 00:19:59.216 A:middle
And the thing to note here
is that removeFromSuperview()

00:19:59.836 --> 00:20:02.576 A:middle
on an object of unknown type,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:59.836 --> 00:20:02.576 A:middle
on an object of unknown type,

00:20:02.946 --> 00:20:04.976 A:middle
it may be there, it
may not be there.

00:20:06.226 --> 00:20:07.876 A:middle
Well, how do we deal with
this notion in Swift?

00:20:08.246 --> 00:20:11.406 A:middle
We use an "optional" that says
there may be a value there;

00:20:11.496 --> 00:20:12.226 A:middle
there may not be.

00:20:12.566 --> 00:20:14.726 A:middle
And so the reference to
removeFromSuperview()

00:20:14.726 --> 00:20:17.086 A:middle
on object is in effect,
optional.

00:20:17.506 --> 00:20:20.936 A:middle
That means we can use the
optional Chaining Operator here

00:20:21.886 --> 00:20:22.026 A:middle
to -

00:20:23.516 --> 00:20:29.066 A:middle
[ Applause ]

00:20:29.566 --> 00:20:30.616 A:middle
What we're doing, of course,

00:20:30.806 --> 00:20:33.266 A:middle
is we're folding the
respondsToSelector check in,

00:20:33.696 --> 00:20:36.566 A:middle
so we do the reference, go
look for RemoveFromSuperview.

00:20:36.976 --> 00:20:39.126 A:middle
If it's there, go on, call it.

00:20:39.886 --> 00:20:42.176 A:middle
If it's not there, stop
evaluating this expression.

00:20:42.176 --> 00:20:42.536 A:middle
We're done.

00:20:44.276 --> 00:20:47.156 A:middle
Now, something that id does

00:20:47.156 --> 00:20:50.496 A:middle
that AnyObject does not
do is implicitly downcast.

00:20:50.816 --> 00:20:54.316 A:middle
So I have Object, which is a
type AnyObject, and I'm trying

00:20:54.316 --> 00:20:56.486 A:middle
to assign it into a UIView.

00:20:57.506 --> 00:20:59.166 A:middle
This is going to
produce a compiler error

00:20:59.166 --> 00:21:01.786 A:middle
because this is a
unsafe downcast.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.166 --> 00:21:01.786 A:middle
because this is a
unsafe downcast.

00:21:02.276 --> 00:21:05.146 A:middle
How do we deal with this?

00:21:05.236 --> 00:21:06.666 A:middle
Well, there's really
two cases here that need

00:21:06.666 --> 00:21:07.866 A:middle
that you need to think about.

00:21:08.536 --> 00:21:12.796 A:middle
One case is, I know it's a
UIView but for some reason

00:21:12.796 --> 00:21:15.496 A:middle
that strong type information
got lost when going

00:21:15.496 --> 00:21:16.626 A:middle
through some API somewhere.

00:21:17.226 --> 00:21:19.126 A:middle
If I know for sure
it's a UIView,

00:21:19.456 --> 00:21:23.086 A:middle
I can use the cast
operator, "as", to say,

00:21:23.086 --> 00:21:25.066 A:middle
"Treat this object as a UIView."

00:21:26.466 --> 00:21:29.326 A:middle
We're going to do these kind
of class check at runtime

00:21:29.326 --> 00:21:31.196 A:middle
to make sure that's
absolutely true.

00:21:31.836 --> 00:21:36.336 A:middle
But the type system will
believe you at this point.

00:21:36.516 --> 00:21:40.976 A:middle
Now if you don't know whether
this object is a UIView

00:21:40.976 --> 00:21:42.906 A:middle
or not, you can use the "as?"

00:21:43.036 --> 00:21:45.976 A:middle
to perform a conditional
downcast.

00:21:46.516 --> 00:21:52.606 A:middle
[ Applause ]

00:21:53.106 --> 00:21:54.286 A:middle
Think you guys have
figured it out?

00:21:54.286 --> 00:21:57.476 A:middle
But just to be sure, this is
doing "is kind of" class check.

00:21:57.476 --> 00:22:00.936 A:middle
And it's wrapping the result
in an optional UIView.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.476 --> 00:22:00.936 A:middle
And it's wrapping the result
in an optional UIView.

00:22:01.756 --> 00:22:03.336 A:middle
It's nil if the check failed.

00:22:03.636 --> 00:22:06.426 A:middle
It has the UIView if
the check succeeded.

00:22:06.826 --> 00:22:08.256 A:middle
We can do an if-let here

00:22:08.676 --> 00:22:10.986 A:middle
to completely do this
entire thing safely,

00:22:11.336 --> 00:22:13.896 A:middle
and view in here is the
UIView we were looking for.

00:22:15.276 --> 00:22:17.886 A:middle
So let's take a little
bit of detour and talk

00:22:17.886 --> 00:22:19.366 A:middle
about tiny bit of protocols.

00:22:19.836 --> 00:22:24.026 A:middle
Here's an Objective-C Protocol
for a UITableViewDataSource

00:22:24.536 --> 00:22:27.426 A:middle
and its Swift equivalent.

00:22:27.786 --> 00:22:31.496 A:middle
Not a whole lot new here.

00:22:31.706 --> 00:22:33.866 A:middle
But there are two things that
I do I want to point out.

00:22:33.926 --> 00:22:38.076 A:middle
The first thing I want to point
out is optional and required.

00:22:38.546 --> 00:22:39.856 A:middle
So in Objective-C optional

00:22:39.856 --> 00:22:42.406 A:middle
and required are essentially
modes in the protocol.

00:22:42.916 --> 00:22:44.826 A:middle
You say @optional,
and everything

00:22:44.826 --> 00:22:47.636 A:middle
that follows is optional
up until the point

00:22:47.636 --> 00:22:50.066 A:middle
where you hit an @required and
then everything is required.

00:22:50.836 --> 00:22:54.426 A:middle
And we're not totally thrilled
with this decision now.

00:22:54.976 --> 00:22:56.996 A:middle
And the basic reason is
that you can't just look

00:22:56.996 --> 00:22:59.126 A:middle
at one single declaration
in the protocol

00:22:59.126 --> 00:23:00.846 A:middle
and know whether it's
optional or required.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.126 --> 00:23:00.846 A:middle
and know whether it's
optional or required.

00:23:00.846 --> 00:23:03.636 A:middle
You have to go scan up
your protocol to find it.

00:23:04.006 --> 00:23:06.056 A:middle
And so we did something a
little bit different in Swift

00:23:06.756 --> 00:23:10.876 A:middle
in that requirements in
protocol are required

00:23:10.876 --> 00:23:12.506 A:middle
by default in Swift.

00:23:12.806 --> 00:23:15.326 A:middle
If you want to make them
optional, then tag them

00:23:15.326 --> 00:23:17.596 A:middle
with the optional attribute
to make them optional.

00:23:18.936 --> 00:23:20.696 A:middle
The other thing I want
to point out here.

00:23:21.016 --> 00:23:23.216 A:middle
We're doing a little bit
of Protocol Inheritance

00:23:23.916 --> 00:23:26.416 A:middle
and we're inheriting
from NSObjectProtocol.

00:23:28.196 --> 00:23:31.946 A:middle
So in Objective-C we will
have NSObject the class

00:23:32.116 --> 00:23:34.046 A:middle
and NSObject the protocol.

00:23:35.216 --> 00:23:38.716 A:middle
And they have the same name so
we have to add the "the class"

00:23:38.716 --> 00:23:40.746 A:middle
or "the protocol" at the
end when we talk about it.

00:23:41.106 --> 00:23:45.296 A:middle
The language keeps these in
syntactically distinct points

00:23:45.736 --> 00:23:47.456 A:middle
so the language isn't confused.

00:23:48.086 --> 00:23:50.606 A:middle
But in Swift we wanted
to bring all these things

00:23:50.606 --> 00:23:53.476 A:middle
into the same namespace because
that's far more convenient

00:23:53.476 --> 00:23:54.476 A:middle
for the general case.

00:23:54.876 --> 00:23:56.436 A:middle
And so we needed to
rename something.

00:23:57.056 --> 00:23:59.376 A:middle
And essentially when there's a
conflict between a class name

00:23:59.376 --> 00:24:01.336 A:middle
and a protocol name,
we'll append protocol


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.376 --> 00:24:01.336 A:middle
and a protocol name,
we'll append protocol

00:24:01.336 --> 00:24:03.286 A:middle
to the name of the protocol.

00:24:03.846 --> 00:24:06.286 A:middle
Why did we do this?

00:24:06.286 --> 00:24:10.766 A:middle
Well, let's take a look at
another use of id that we see

00:24:10.846 --> 00:24:14.086 A:middle
in Objective-C, and that's
protocol-qualified id.

00:24:15.086 --> 00:24:19.426 A:middle
So this dataSource here is an
object of some unknown type.

00:24:20.626 --> 00:24:22.336 A:middle
But we know that
the type conforms

00:24:22.336 --> 00:24:24.346 A:middle
to the UITableViewDataSource
protocol.

00:24:25.526 --> 00:24:27.416 A:middle
We describe that a
little bit more directly

00:24:27.416 --> 00:24:30.056 A:middle
in the Swift language by
just saying the dataSource is

00:24:30.056 --> 00:24:31.486 A:middle
a UITableViewDataSource!.

00:24:32.146 --> 00:24:33.026 A:middle
That's it.

00:24:33.716 --> 00:24:38.006 A:middle
Now some of you here noticed
with protocol-qualified id,

00:24:38.256 --> 00:24:40.766 A:middle
you can have many different
protocols if you want.

00:24:41.346 --> 00:24:44.836 A:middle
We can use the protocol
keyword with angle brackets

00:24:44.996 --> 00:24:46.396 A:middle
to describe more
than one protocol.

00:24:46.396 --> 00:24:49.456 A:middle
Now, one of the things we do

00:24:49.456 --> 00:24:52.116 A:middle
with Protocol Conformance is we
have an object of unknown type

00:24:52.116 --> 00:24:55.266 A:middle
and we want to determine, does
it conform to the protocol?

00:24:55.456 --> 00:24:57.606 A:middle
This is the "conforms
to protocol check"

00:24:57.606 --> 00:25:00.236 A:middle
in the Objective-C runtime.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.606 --> 00:25:00.236 A:middle
in the Objective-C runtime.

00:25:00.356 --> 00:25:02.506 A:middle
In Swift, we do this same thing

00:25:03.056 --> 00:25:05.276 A:middle
with the conditional
downcast operator.

00:25:05.836 --> 00:25:09.106 A:middle
So we can just ask, is my object
the UITableViewDataSource"

00:25:09.686 --> 00:25:11.916 A:middle
conforms to protocol check,
happens in the runtime,

00:25:12.196 --> 00:25:13.826 A:middle
captures the results
in an optional.

00:25:14.216 --> 00:25:17.026 A:middle
Here we can go easily do
that, call one of the methods

00:25:17.026 --> 00:25:19.926 A:middle
and compute the number of
rows in the first section

00:25:19.976 --> 00:25:21.406 A:middle
of this TableViewDataSource.

00:25:21.916 --> 00:25:25.146 A:middle
Let's make our example a
little bit more interesting.

00:25:25.766 --> 00:25:28.446 A:middle
Let's compute the number of
rows in the last section.

00:25:29.716 --> 00:25:32.446 A:middle
So here we need to compute the
number of sections that exist

00:25:32.446 --> 00:25:36.936 A:middle
in the TableView, subtract one
off of it, and then we can ask

00:25:36.936 --> 00:25:38.576 A:middle
for the number of
rows in that section.

00:25:39.076 --> 00:25:41.506 A:middle
Now there's a problem
with this code.

00:25:42.566 --> 00:25:45.226 A:middle
And the problem is the number
of sections in TableView,

00:25:45.266 --> 00:25:48.186 A:middle
as you might remember,
is an optional method.

00:25:48.766 --> 00:25:50.196 A:middle
It might not be there
at runtime.

00:25:50.886 --> 00:25:53.876 A:middle
So we're going to need to
compile error out of this

00:25:53.876 --> 00:25:55.706 A:middle
because we need to deal
with the optionality

00:25:55.706 --> 00:25:57.006 A:middle
of this protocol method.

00:25:57.836 --> 00:25:59.796 A:middle
And we deal with this
the same way we deal

00:25:59.796 --> 00:26:02.736 A:middle
with optionality everywhere
else in the Swift language,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.796 --> 00:26:02.736 A:middle
with optionality everywhere
else in the Swift language,

00:26:03.576 --> 00:26:05.166 A:middle
using the mechanisms we have.

00:26:05.166 --> 00:26:07.836 A:middle
So here we're going to
use the chaining "?"

00:26:07.836 --> 00:26:11.916 A:middle
operator. We're checking, does
my DataSource have a number

00:26:11.916 --> 00:26:13.626 A:middle
of sections in TableView method?

00:26:14.066 --> 00:26:16.606 A:middle
If so, call it, given
the TableView,

00:26:16.956 --> 00:26:19.156 A:middle
and then we capture the
result in numSections

00:26:19.456 --> 00:26:21.226 A:middle
so we can compute the
last section number

00:26:21.696 --> 00:26:23.926 A:middle
and get the number of rows

00:26:24.026 --> 00:26:28.766 A:middle
in the last section
of our TableView.

00:26:29.046 --> 00:26:30.996 A:middle
That's about all we're going to
talk about with Protocols here.

00:26:31.716 --> 00:26:33.776 A:middle
If you're interested
in Protocols and some

00:26:33.776 --> 00:26:35.196 A:middle
of the amazing things
they can do,

00:26:35.586 --> 00:26:37.996 A:middle
there's an "Advanced Swift"
talk tomorrow morning.

00:26:38.556 --> 00:26:41.756 A:middle
It goes into more depth on
those and their interaction

00:26:42.296 --> 00:26:46.196 A:middle
with the generic system.

00:26:46.196 --> 00:26:51.646 A:middle
So, wrapping up here, AnyObject
is Swift's equivalent to id.

00:26:52.346 --> 00:26:53.856 A:middle
The functionality is similar.

00:26:53.856 --> 00:26:56.386 A:middle
The ideas are similar
and the uses are similar.

00:26:56.746 --> 00:26:58.706 A:middle
However, it's more
safe by default.

00:26:59.756 --> 00:27:02.826 A:middle
Now we didn't talk about it,
but there's also AnyClass,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.756 --> 00:27:02.826 A:middle
Now we didn't talk about it,
but there's also AnyClass,

00:27:02.956 --> 00:27:06.706 A:middle
which is Swift's equivalent
to class and has most

00:27:06.706 --> 00:27:07.876 A:middle
of the same behaviors.

00:27:08.446 --> 00:27:12.256 A:middle
Now the other thing that we've
seen is how Optionals are used

00:27:12.336 --> 00:27:15.656 A:middle
throughout the language to
represent dynamic checks.

00:27:16.276 --> 00:27:18.456 A:middle
We've taken "is kind
of" class checks,

00:27:18.826 --> 00:27:22.416 A:middle
conforms to protocol checks,
responds to selector checks,

00:27:22.706 --> 00:27:25.616 A:middle
and folded them all into
the notion of Optionals

00:27:25.616 --> 00:27:28.706 A:middle
within the language with
their optimized syntax

00:27:28.746 --> 00:27:31.976 A:middle
to make them easy to use and
easy to do the right thing.

00:27:32.526 --> 00:27:38.336 A:middle
With that, let's switch
gears a little bit and talk

00:27:38.336 --> 00:27:40.546 A:middle
about Bridging of
Cocoa data types.

00:27:41.106 --> 00:27:44.516 A:middle
Now first, let's talk a little
bit about the native Strings,

00:27:44.516 --> 00:27:46.736 A:middle
Arrays, and the Dictionaries
within Swift.

00:27:47.586 --> 00:27:50.006 A:middle
The goal of Swift
is to have one set

00:27:50.006 --> 00:27:53.296 A:middle
of general-purpose native
value types that you use

00:27:53.296 --> 00:27:54.456 A:middle
for nearly everything.

00:27:55.396 --> 00:27:57.066 A:middle
These need to be
safe by default.

00:27:57.066 --> 00:27:58.846 A:middle
This means bounds
restricting for arrays,

00:27:58.846 --> 00:28:00.796 A:middle
automatic memory
management, and so on.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.846 --> 00:28:00.796 A:middle
automatic memory
management, and so on.

00:28:01.926 --> 00:28:04.636 A:middle
They need to have predictable
performance so that you can look

00:28:04.636 --> 00:28:07.176 A:middle
at code and have a sense
of how it's going to behave

00:28:07.176 --> 00:28:09.356 A:middle
with no surprises, how
it's going to perform.

00:28:10.746 --> 00:28:13.116 A:middle
And, of course, we want
arrays and dictionaries

00:28:13.616 --> 00:28:16.956 A:middle
to be collections and they need
to be strongly typed collections

00:28:16.956 --> 00:28:17.946 A:middle
that work with any type.

00:28:18.056 --> 00:28:19.886 A:middle
We can't limit them
just to objects

00:28:19.926 --> 00:28:22.486 A:middle
because sometimes you need
an array of strings or ints.

00:28:23.576 --> 00:28:26.746 A:middle
And we don't have a seed to
fall back to for the cases

00:28:26.746 --> 00:28:27.976 A:middle
where the other tools
don't work.

00:28:28.416 --> 00:28:31.206 A:middle
This is it.

00:28:31.476 --> 00:28:34.776 A:middle
Now, to support having
this one notion of one set

00:28:34.776 --> 00:28:37.656 A:middle
of general purpose native value
types, we're going to bridge

00:28:37.656 --> 00:28:40.446 A:middle
from Cocoa's NSString,
NSArray, NSDictionary,

00:28:40.816 --> 00:28:42.496 A:middle
into the Swift-native
equivalents.

00:28:44.616 --> 00:28:46.836 A:middle
So let's first talk a little bit

00:28:46.986 --> 00:28:49.226 A:middle
about the native
string type itself.

00:28:50.326 --> 00:28:54.146 A:middle
So, String is an efficient,
Unicode-compliant string type.

00:28:55.556 --> 00:28:59.356 A:middle
Core string type of Swift
has Unicode built in through

00:28:59.356 --> 00:29:01.056 A:middle
and through so it makes
it easy to work with.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.356 --> 00:29:01.056 A:middle
and through so it makes
it easy to work with.

00:29:01.626 --> 00:29:02.706 A:middle
We provide flexible

00:29:02.706 --> 00:29:06.226 A:middle
and efficient high-level
APIs to work with strings.

00:29:06.226 --> 00:29:08.696 A:middle
You can easily do
concatenation, searches,

00:29:08.816 --> 00:29:11.076 A:middle
prefix matches, sub-strings.

00:29:11.516 --> 00:29:14.106 A:middle
And the strings provide
value semantics,

00:29:14.206 --> 00:29:15.716 A:middle
which makes them
easier to work with.

00:29:16.416 --> 00:29:21.286 A:middle
And value semantics is generally
a fairly simple notion of,

00:29:21.606 --> 00:29:23.476 A:middle
you know, if I have two
variables of string type,

00:29:24.106 --> 00:29:27.706 A:middle
modifying one of them doesn't
affect the other one, all right.

00:29:27.796 --> 00:29:30.436 A:middle
This is very nice for a
fundamental data type.

00:29:32.716 --> 00:29:34.976 A:middle
Now, of course, you can also
think of strings as a unit,

00:29:34.976 --> 00:29:37.026 A:middle
but you can also think
of them as being composed

00:29:37.026 --> 00:29:39.496 A:middle
of characters which,
in fact, they are.

00:29:40.476 --> 00:29:44.576 A:middle
And so we can go walk over a
string and using the for loop,

00:29:44.816 --> 00:29:47.196 A:middle
and get all of the
characters out of the string.

00:29:47.506 --> 00:29:49.596 A:middle
And you get the answer
that you would expect.

00:29:49.646 --> 00:29:52.806 A:middle
There are five characters here
even though there's no emoji

00:29:53.596 --> 00:29:55.516 A:middle
at the end.

00:29:55.516 --> 00:30:01.016 A:middle
So I want to talk a little bit
about characters and code points


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:55.516 --> 00:30:01.016 A:middle
So I want to talk a little bit
about characters and code points

00:30:02.106 --> 00:30:03.856 A:middle
because the character
that you're getting

00:30:03.856 --> 00:30:04.976 A:middle
out of here is a full
Unicode character.

00:30:05.236 --> 00:30:09.166 A:middle
It's not a UTF-8 code
point or UTF-16 code point

00:30:09.166 --> 00:30:09.936 A:middle
that you have to deal with.

00:30:10.376 --> 00:30:12.226 A:middle
It is a Unicode character.

00:30:13.386 --> 00:30:16.706 A:middle
And now, one of the challenges
with the Unicode characters is,

00:30:16.706 --> 00:30:20.866 A:middle
you really can't encode
them efficiently in a way

00:30:20.866 --> 00:30:24.866 A:middle
that treats a string as
just an array of characters.

00:30:25.586 --> 00:30:26.456 A:middle
It would be too large.

00:30:27.096 --> 00:30:28.946 A:middle
And so what you generally see is

00:30:28.946 --> 00:30:33.346 A:middle
that a string is encoded
as, say, UTF-8 or UTF-16.

00:30:34.376 --> 00:30:37.446 A:middle
But working with those
UTF-8 or UTF-16 code points,

00:30:37.736 --> 00:30:40.556 A:middle
that requires Unicode expertise
to get right all the time.

00:30:42.246 --> 00:30:44.126 A:middle
And so we made a really
interesting decision here.

00:30:45.336 --> 00:30:49.066 A:middle
We decided not to provide the
super low-level operations

00:30:49.066 --> 00:30:52.856 A:middle
like length and characterAtIndex
to let you poke directly

00:30:52.856 --> 00:30:55.796 A:middle
at the UTF-16 or UTF-8 code
points, or whatever is stored

00:30:55.796 --> 00:30:59.786 A:middle
in the string because doing
so causes big problems.

00:30:59.886 --> 00:31:03.876 A:middle
Instead we want you to
use the high-level APIs


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.886 --> 00:31:03.876 A:middle
Instead we want you to
use the high-level APIs

00:31:04.186 --> 00:31:06.726 A:middle
and let the library do
the hard work of dealing

00:31:06.726 --> 00:31:08.516 A:middle
with all the intricacies
of Unicode.

00:31:09.086 --> 00:31:13.056 A:middle
Of course, there's still common
operations you want to use.

00:31:13.546 --> 00:31:16.836 A:middle
You may want to count the number
of characters in a string,

00:31:17.526 --> 00:31:19.946 A:middle
so there's this countElements
algorithm.

00:31:19.946 --> 00:31:23.296 A:middle
It works on any sequence
and allows you to, well,

00:31:23.366 --> 00:31:25.176 A:middle
just count the number of
characters in a string,

00:31:25.546 --> 00:31:27.146 A:middle
and this produces
the right answer,

00:31:27.146 --> 00:31:29.566 A:middle
which is there are five
characters in this string.

00:31:30.426 --> 00:31:32.846 A:middle
Some of you will want to
work with code points, right.

00:31:33.336 --> 00:31:36.006 A:middle
You may be Unicode experts
and that's wonderful.

00:31:36.396 --> 00:31:38.206 A:middle
You can get access
to the code points.

00:31:38.356 --> 00:31:42.996 A:middle
There's a property UTF-16 that
gives you a lazily computed view

00:31:42.996 --> 00:31:46.976 A:middle
on the string producing
the UTF-16 code points

00:31:46.976 --> 00:31:47.746 A:middle
in that string.

00:31:49.316 --> 00:31:53.216 A:middle
And we can go walk over
the 16-bit unsigned integer

00:31:53.546 --> 00:31:54.656 A:middle
code points.

00:31:55.096 --> 00:31:58.536 A:middle
We can print out the number of
code points here and, of course,

00:31:58.536 --> 00:32:00.836 A:middle
you'll get the answer "6"


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.536 --> 00:32:00.836 A:middle
you'll get the answer "6"

00:32:01.306 --> 00:32:04.966 A:middle
because there are six UTF-16
code points in this string.

00:32:06.056 --> 00:32:06.956 A:middle
The last thing I want to talk

00:32:06.956 --> 00:32:09.376 A:middle
about with strings
is the relationship

00:32:09.376 --> 00:32:11.466 A:middle
between string and NSSring.

00:32:12.726 --> 00:32:14.686 A:middle
So NSString has a wealth

00:32:14.926 --> 00:32:17.586 A:middle
of really great text
processing APIs

00:32:17.916 --> 00:32:19.856 A:middle
that you've probably
been using for years.

00:32:20.376 --> 00:32:23.886 A:middle
So we've made all those
Foundation APIs directly

00:32:23.886 --> 00:32:26.846 A:middle
available on the string
type, so the APIs you know

00:32:26.846 --> 00:32:29.506 A:middle
and love are there,
and you can use them.

00:32:30.716 --> 00:32:33.706 A:middle
Now in doing so, we've made
them a little bit more Swift.

00:32:33.706 --> 00:32:35.976 A:middle
We've tightened up the
type signatures so that

00:32:35.976 --> 00:32:38.996 A:middle
if you're going to split a
string into its components,

00:32:38.996 --> 00:32:41.826 A:middle
well, you're getting it back
an array of strings rather

00:32:41.826 --> 00:32:43.726 A:middle
than just an array
of somethings.

00:32:45.596 --> 00:32:49.316 A:middle
Now you may have developed
your own categories on NSString

00:32:49.566 --> 00:32:51.426 A:middle
with additional functionality
that you use

00:32:51.426 --> 00:32:52.896 A:middle
within your own applications.

00:32:53.896 --> 00:32:55.946 A:middle
You can get to those
with a simple Cast.

00:32:56.086 --> 00:32:59.626 A:middle
So you can take a Swift string,
turn it into an NSString,

00:32:59.796 --> 00:33:00.926 A:middle
so this is just a conversion,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.796 --> 00:33:00.926 A:middle
so this is just a conversion,

00:33:01.986 --> 00:33:04.426 A:middle
and then call your
NSStringMethod.

00:33:05.636 --> 00:33:07.996 A:middle
If you find yourselves
doing this a lot,

00:33:08.696 --> 00:33:10.646 A:middle
feel free to just go ahead

00:33:10.646 --> 00:33:12.656 A:middle
and extend the underlying
string type.

00:33:12.966 --> 00:33:15.196 A:middle
Add your StringMethod,
make it a little more Swift

00:33:15.196 --> 00:33:17.486 A:middle
with strong type signatures,
closures if you'd like.

00:33:18.766 --> 00:33:22.146 A:middle
But this should help you feel
at home in Swift fairly quickly

00:33:22.376 --> 00:33:24.166 A:middle
and use the String type.

00:33:25.476 --> 00:33:29.306 A:middle
Now let's move from
String to a container.

00:33:29.566 --> 00:33:31.486 A:middle
Let's talk about Arrays.

00:33:32.376 --> 00:33:36.396 A:middle
So here we have toolbar
items that is in an NSArray.

00:33:37.036 --> 00:33:43.386 A:middle
That's going to come into
Swift as an array of AnyObject.

00:33:44.386 --> 00:33:46.656 A:middle
Now these two types
are fairly similar.

00:33:47.346 --> 00:33:49.826 A:middle
You can iterate over them
and what you're going to get

00:33:49.826 --> 00:33:52.396 A:middle
out of it are values
of type AnyObject.

00:33:52.466 --> 00:33:54.646 A:middle
They're objects but you don't
know what kind of object it is.

00:33:55.356 --> 00:33:57.486 A:middle
You can subscript into
them and, of course,

00:33:57.486 --> 00:33:58.786 A:middle
you will get an AnyObject.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:00.256 --> 00:34:04.976 A:middle
Now, in Swift, you tend to deal
in typed arrays more often.

00:34:05.446 --> 00:34:07.906 A:middle
And so there are
some other operations

00:34:07.906 --> 00:34:09.846 A:middle
that the core language
needs to provide

00:34:09.846 --> 00:34:11.315 A:middle
for you to make this clean.

00:34:12.085 --> 00:34:16.696 A:middle
So maybe I'm composing my
toolbar items into a Swift array

00:34:17.176 --> 00:34:20.406 A:middle
and that Swift array is going
to contain UIBarButtonItems.

00:34:20.926 --> 00:34:24.716 A:middle
That's what actually goes into
the toolbar items property.

00:34:25.706 --> 00:34:29.636 A:middle
I can work with that Swift
Array and then I can assign it

00:34:29.636 --> 00:34:31.335 A:middle
into the AnyObject array.

00:34:31.335 --> 00:34:35.065 A:middle
So this is essentially doing
a safe upcast of any array

00:34:35.065 --> 00:34:37.636 A:middle
of ToolbarItems to any
array of AnyObjects.

00:34:38.456 --> 00:34:40.906 A:middle
It also happens to be
calling into Objective-C,

00:34:41.085 --> 00:34:43.916 A:middle
which we'll get to in a minute.

00:34:44.076 --> 00:34:48.025 A:middle
Now we also see the flip side
of this where we want to, say,

00:34:48.025 --> 00:34:49.636 A:middle
iterate over all
the ToolbarItems

00:34:50.735 --> 00:34:56.295 A:middle
in this particular view
controller and here we're going

00:34:56.295 --> 00:34:59.476 A:middle
to get AnyObject values and,
we talked about cast earlier,

00:34:59.476 --> 00:35:01.226 A:middle
so we can downcast each of them.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.476 --> 00:35:01.226 A:middle
so we can downcast each of them.

00:35:01.756 --> 00:35:04.406 A:middle
This is fine but it's a little
bit on the tedious side.

00:35:04.766 --> 00:35:07.076 A:middle
And so we have specialized
syntax here

00:35:07.296 --> 00:35:12.836 A:middle
to downcast an entire
array at a time doing the

00:35:12.836 --> 00:35:14.656 A:middle
"is kind of" class
checks necessary

00:35:14.656 --> 00:35:17.436 A:middle
to make this safe
lazily behind the scenes.

00:35:18.596 --> 00:35:19.966 A:middle
And then you can walk
over all with them.

00:35:20.516 --> 00:35:26.086 A:middle
[ Applause ]

00:35:26.586 --> 00:35:29.646 A:middle
Now, we've seen NSArrays
in the Objective-C side,

00:35:30.176 --> 00:35:32.506 A:middle
Swift arrays on the Swift side.

00:35:32.946 --> 00:35:35.116 A:middle
Let's take a little bit
of a peek under the hood

00:35:35.296 --> 00:35:38.226 A:middle
at how this actually
works because you're going

00:35:38.226 --> 00:35:41.526 A:middle
to be writing a lot of Swift
code that interacts with a lot

00:35:41.526 --> 00:35:43.626 A:middle
of Objective-C code and we
want this to perform well.

00:35:45.456 --> 00:35:48.496 A:middle
So there's a Swift array.

00:35:48.536 --> 00:35:52.896 A:middle
And the Swift array actually has
two internal representations.

00:35:53.826 --> 00:35:56.726 A:middle
Its first representation is
probably what you'd expect

00:35:56.726 --> 00:35:57.286 A:middle
out of Swift.

00:35:57.756 --> 00:35:59.206 A:middle
It's a native representation.

00:35:59.596 --> 00:36:02.166 A:middle
It has a length, which is the
number of elements in the array.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.596 --> 00:36:02.166 A:middle
It has a length, which is the
number of elements in the array.

00:36:02.166 --> 00:36:04.316 A:middle
It has a capacity that's used

00:36:04.316 --> 00:36:07.026 A:middle
so we can algorithmically
efficiently add things

00:36:07.026 --> 00:36:07.556 A:middle
to the array.

00:36:09.126 --> 00:36:12.926 A:middle
And then it has the buffer of
elements that are in the array.

00:36:14.416 --> 00:36:17.916 A:middle
And, of course, those buffered
elements, whatever kind

00:36:17.916 --> 00:36:19.736 A:middle
of array it is, that's how
much storage they take.

00:36:19.736 --> 00:36:21.906 A:middle
If we have an array
of 32-bit integers,

00:36:21.906 --> 00:36:24.156 A:middle
each element takes
32 bits of storage.

00:36:24.156 --> 00:36:25.966 A:middle
There's not extra
boxing going on here,

00:36:26.666 --> 00:36:27.776 A:middle
no extra performance loss.

00:36:27.946 --> 00:36:30.986 A:middle
It's just a native buffer.

00:36:31.166 --> 00:36:33.906 A:middle
Now we also have this
second representation

00:36:34.526 --> 00:36:37.446 A:middle
and we do a couple of pointer
tricks so that we can fit it

00:36:37.446 --> 00:36:39.546 A:middle
into just a tiny
amount of memory.

00:36:40.116 --> 00:36:42.076 A:middle
And that's the Cocoa
representation.

00:36:43.236 --> 00:36:49.096 A:middle
So any Swift array can actually
be an NSArray underneath

00:36:49.256 --> 00:36:50.346 A:middle
as representation.

00:36:50.966 --> 00:36:54.476 A:middle
And all the operations
on an array handle both

00:36:54.476 --> 00:36:55.996 A:middle
of these representations.

00:36:56.486 --> 00:37:00.386 A:middle
So if I subscript my array and
it happens to be an NSArray,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:56.486 --> 00:37:00.386 A:middle
So if I subscript my array and
it happens to be an NSArray,

00:37:00.916 --> 00:37:02.886 A:middle
we'll use object and
index behind the scenes.

00:37:03.666 --> 00:37:04.926 A:middle
So you get the result
that you want.

00:37:05.916 --> 00:37:07.606 A:middle
If we do append to
such an array, well,

00:37:07.636 --> 00:37:10.196 A:middle
we can flip the representation
quickly and give you

00:37:10.196 --> 00:37:11.566 A:middle
that efficient append operation.

00:37:12.166 --> 00:37:16.176 A:middle
So given these two
representations,

00:37:16.356 --> 00:37:20.066 A:middle
we can talk about the notion
of bridging, of converting

00:37:20.666 --> 00:37:23.746 A:middle
between an NSArray, as
Objective-C would see,

00:37:24.786 --> 00:37:26.936 A:middle
and a Swift array that
you use within Swift.

00:37:28.256 --> 00:37:29.216 A:middle
There's two directions here:

00:37:29.696 --> 00:37:31.686 A:middle
going to Objective-C
and coming back.

00:37:32.986 --> 00:37:36.416 A:middle
So first, let's talk
about coming back.

00:37:37.196 --> 00:37:39.036 A:middle
So we have an Objective-C
method.

00:37:39.036 --> 00:37:41.336 A:middle
In this case, it's the
getter for toolbar items.

00:37:41.766 --> 00:37:43.686 A:middle
In Objective-C, that
returns NSArray.

00:37:44.406 --> 00:37:47.576 A:middle
In Swift, that's going to come
back as an array of AnyObject.

00:37:48.236 --> 00:37:49.136 A:middle
How do we do this?

00:37:49.586 --> 00:37:51.406 A:middle
Well, given our two
representations,

00:37:51.956 --> 00:37:53.386 A:middle
it's extremely efficient
to do it

00:37:53.386 --> 00:37:54.976 A:middle
because we have our
representation

00:37:55.266 --> 00:37:57.846 A:middle
that can just take
that NSArray directly.

00:37:58.426 --> 00:38:00.616 A:middle
All we need to do is
one copy operation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.426 --> 00:38:00.616 A:middle
All we need to do is
one copy operation

00:38:00.946 --> 00:38:03.256 A:middle
to make sure the contents
don't change underneath us

00:38:03.256 --> 00:38:04.616 A:middle
if it's a mutable array.

00:38:05.746 --> 00:38:08.206 A:middle
But the common case here is
that it's not a mutable array.

00:38:08.336 --> 00:38:12.436 A:middle
It's an immutable NSArray and so
this copy operation is trivial.

00:38:12.436 --> 00:38:14.966 A:middle
It's a message send, it's
a retain, and that's it.

00:38:15.366 --> 00:38:16.926 A:middle
So its conversion
is extremely fast.

00:38:17.746 --> 00:38:20.646 A:middle
Let's talk about
the other direction,

00:38:21.576 --> 00:38:23.656 A:middle
going from a Swift
array to an NSArray.

00:38:24.146 --> 00:38:27.556 A:middle
So this would happen when we
take, say, our ToolbarItems.

00:38:27.556 --> 00:38:28.436 A:middle
It's a Swift array.

00:38:28.946 --> 00:38:31.036 A:middle
And we call the Objective-C
setter,

00:38:31.446 --> 00:38:32.886 A:middle
which expects an NSArray.

00:38:33.586 --> 00:38:36.036 A:middle
Well, now we have an
interesting question

00:38:36.906 --> 00:38:38.686 A:middle
because there's two possible
representations here.

00:38:39.176 --> 00:38:40.496 A:middle
There's the really easy answer.

00:38:41.036 --> 00:38:43.186 A:middle
It's already in the
Cocoa representation

00:38:43.386 --> 00:38:46.246 A:middle
and we can just hand off
the NSArray, no work at all.

00:38:47.696 --> 00:38:50.546 A:middle
But the native one, that a
different question entirely.

00:38:51.406 --> 00:38:55.906 A:middle
We could copy the whole buffer
but that would be awful.

00:38:55.906 --> 00:38:59.016 A:middle
We could possibly go
allocate a little shim object.

00:38:59.016 --> 00:39:00.636 A:middle
That's also possible.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.016 --> 00:39:00.636 A:middle
That's also possible.

00:39:01.346 --> 00:39:05.096 A:middle
Instead, we decided to make
our native representation

00:39:06.016 --> 00:39:08.866 A:middle
into a little bit of an
Objective-C object [laughter].

00:39:09.526 --> 00:39:12.376 A:middle
It's already an NSArray.

00:39:13.516 --> 00:39:15.986 A:middle
And we've optimized
the allocation here

00:39:16.406 --> 00:39:18.656 A:middle
so we can build these
objects super fast

00:39:19.476 --> 00:39:21.776 A:middle
and just pass off our
native representation

00:39:21.956 --> 00:39:24.826 A:middle
as if it were an NSArray
and it works beautifully

00:39:24.826 --> 00:39:26.466 A:middle
on the Objective-C side.

00:39:29.516 --> 00:39:33.856 A:middle
[ Applause ]

00:39:34.356 --> 00:39:37.216 A:middle
I think that's enough
of Bridging.

00:39:37.696 --> 00:39:39.106 A:middle
Let's talk about subclassing.

00:39:41.206 --> 00:39:52.556 A:middle
Okay. So, Swift objects are
all Objective-C objects.

00:39:53.776 --> 00:39:56.546 A:middle
Now what this means is that,
if you define a class in Swift,

00:39:57.456 --> 00:39:59.976 A:middle
it has basic Objective-C
interoperability built in.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:00.226 --> 00:40:05.136 A:middle
We use the same layout as an
Objective-C class so there's an

00:40:05.136 --> 00:40:06.346 A:middle
"isa" pointer in there.

00:40:06.346 --> 00:40:09.366 A:middle
The "isa" pointer points
out to Objective-C metadata.

00:40:10.166 --> 00:40:12.306 A:middle
There's the same
underlying infrastructure,

00:40:12.306 --> 00:40:15.836 A:middle
the thing that makes "arch" work
and the basic frameworks work

00:40:15.836 --> 00:40:16.906 A:middle
with retain and release.

00:40:17.116 --> 00:40:18.296 A:middle
You can expect a class.

00:40:19.136 --> 00:40:19.786 A:middle
That sort of thing.

00:40:20.086 --> 00:40:20.896 A:middle
They're all available.

00:40:22.416 --> 00:40:25.376 A:middle
Now, if you really want to
make use of your classes

00:40:25.486 --> 00:40:29.386 A:middle
from within your
Objective-C code, well,

00:40:29.386 --> 00:40:32.246 A:middle
then you should inherit
from an Objective-C class,

00:40:32.616 --> 00:40:35.106 A:middle
whether it's NSObject
or some other class.

00:40:35.596 --> 00:40:38.926 A:middle
And this is going to expose your
class to the Objective-C world

00:40:38.926 --> 00:40:42.516 A:middle
and make all the things you
write in Swift available also

00:40:42.516 --> 00:40:43.606 A:middle
to your Objective-C code.

00:40:44.746 --> 00:40:47.226 A:middle
So we're going to continue
with our UIDocument example

00:40:47.226 --> 00:40:50.636 A:middle
from earlier and we're going to
create a little MyDocument class

00:40:50.676 --> 00:40:52.766 A:middle
that inherits from UIDocument.

00:40:53.266 --> 00:40:57.046 A:middle
And we're going to
talk about a couple

00:40:57.046 --> 00:40:58.666 A:middle
of the things that
subclasses do.

00:40:59.076 --> 00:41:00.266 A:middle
They override methods.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.076 --> 00:41:00.266 A:middle
They override methods.

00:41:01.276 --> 00:41:03.546 A:middle
So here we're going to
override the handleError,

00:41:03.546 --> 00:41:05.566 A:middle
userInteractionPermitted method.

00:41:06.636 --> 00:41:09.486 A:middle
And you do this exactly
the same way as you'd do it

00:41:09.486 --> 00:41:11.156 A:middle
if you were overriding
a Swift method.

00:41:11.426 --> 00:41:12.196 A:middle
It doesn't matter.

00:41:12.196 --> 00:41:13.486 A:middle
The syntax is the same.

00:41:13.636 --> 00:41:15.856 A:middle
The fact that the super class
is written in Objective-C?

00:41:16.116 --> 00:41:18.596 A:middle
Completely irrelevant to
the syntax of the language

00:41:18.896 --> 00:41:19.796 A:middle
and how you work with it.

00:41:21.856 --> 00:41:23.916 A:middle
Now one thing to note
in Swift is that the

00:41:23.916 --> 00:41:26.726 A:middle
"override" keyword is mandatory.

00:41:28.146 --> 00:41:28.976 A:middle
Why do we do that?

00:41:29.296 --> 00:41:30.656 A:middle
There's a couple of
reasons for doing that.

00:41:31.346 --> 00:41:35.136 A:middle
One of the reasons is because
when you look at a method,

00:41:35.726 --> 00:41:38.306 A:middle
you probably want to know
if the intention here is

00:41:38.306 --> 00:41:41.046 A:middle
to override your
super class's behavior

00:41:41.046 --> 00:41:43.906 A:middle
because that's a really
important part of your API.

00:41:44.136 --> 00:41:45.136 A:middle
It's a really part

00:41:45.136 --> 00:41:48.166 A:middle
of understanding what this
method is supposed to do.

00:41:48.766 --> 00:41:54.236 A:middle
Now the other thing it does is
it helps overriding accidents.

00:41:55.236 --> 00:41:58.496 A:middle
For example, I meant to override
something from my super class,

00:41:59.056 --> 00:42:01.046 A:middle
but I typed part of
the selector wrong


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.056 --> 00:42:01.046 A:middle
but I typed part of
the selector wrong

00:42:01.796 --> 00:42:04.006 A:middle
and the method name
no longer overrides.

00:42:04.286 --> 00:42:06.896 A:middle
My code isn't running
and I have no idea why.

00:42:06.896 --> 00:42:09.696 A:middle
Well, with mandatory
override, we catch that.

00:42:09.946 --> 00:42:12.286 A:middle
If you didn't override something
and you thought you did,

00:42:12.986 --> 00:42:13.826 A:middle
compiler will complain.

00:42:15.456 --> 00:42:19.196 A:middle
There's also the real
surprise which is

00:42:19.256 --> 00:42:21.916 A:middle
when you override something
from your super class

00:42:21.966 --> 00:42:23.786 A:middle
that you didn't even
know existed.

00:42:24.386 --> 00:42:30.046 A:middle
And this is the case where you
just wrote a method and maybe

00:42:30.046 --> 00:42:32.266 A:middle
in this release that
method happens to exist

00:42:32.266 --> 00:42:34.276 A:middle
or maybe it doesn't
exist in this release,

00:42:34.736 --> 00:42:37.516 A:middle
but some joker added it to the
next release in the frameworks

00:42:37.516 --> 00:42:39.696 A:middle
that you use and now
you're overriding something

00:42:39.696 --> 00:42:41.166 A:middle
that you didn't know
existed at the time.

00:42:41.996 --> 00:42:44.886 A:middle
We can catch that by
requiring override throughout

00:42:45.356 --> 00:42:45.926 A:middle
the language.

00:42:46.516 --> 00:42:51.686 A:middle
We could also talk a little bit
about overriding properties.

00:42:53.436 --> 00:42:57.406 A:middle
So, in Swift, you don't
override the getter

00:42:57.586 --> 00:42:58.926 A:middle
or the setter separately.

00:42:59.146 --> 00:43:01.796 A:middle
Instead you override
the property itself


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.146 --> 00:43:01.796 A:middle
Instead you override
the property itself

00:43:02.396 --> 00:43:06.116 A:middle
and then you provide a getter
or a setter as appropriate.

00:43:06.716 --> 00:43:08.276 A:middle
So here we're doing
something very simple.

00:43:08.276 --> 00:43:10.476 A:middle
We're overriding the
description property

00:43:11.046 --> 00:43:12.616 A:middle
and providing a new
getter for it.

00:43:13.806 --> 00:43:16.176 A:middle
Now what this means to
the Objective-C runtime,

00:43:16.416 --> 00:43:17.636 A:middle
to your Objective-C code,

00:43:17.636 --> 00:43:19.326 A:middle
is that you've overridden
the getter.

00:43:20.546 --> 00:43:23.276 A:middle
But the semantic model
in Swift is different.

00:43:23.276 --> 00:43:26.386 A:middle
It's based on overriding the
actual thing that was declared.

00:43:26.386 --> 00:43:27.646 A:middle
In this case, the property.

00:43:28.216 --> 00:43:32.636 A:middle
As I mentioned before,
NSError is going to come back.

00:43:33.446 --> 00:43:35.966 A:middle
So we have contentsForType
error we're going

00:43:35.966 --> 00:43:37.346 A:middle
to override in our subclass.

00:43:37.766 --> 00:43:40.576 A:middle
And remember that the
Objective-C method took NSError,

00:43:42.226 --> 00:43:45.806 A:middle
a C pointer to an NSError
which could be nil.

00:43:47.346 --> 00:43:49.986 A:middle
The way we work with
these in Swift is

00:43:49.986 --> 00:43:53.646 A:middle
that the NSErrorPointer class
provides a couple of operations

00:43:53.646 --> 00:43:55.336 A:middle
that you would expect
out of a pointer.

00:43:55.736 --> 00:43:58.966 A:middle
You can test it for nil, as
we do in the if check here,

00:43:59.396 --> 00:44:02.116 A:middle
to see whether we were actually
given a valid point error


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.396 --> 00:44:02.116 A:middle
to see whether we were actually
given a valid point error

00:44:02.116 --> 00:44:04.216 A:middle
where it's being given
nil by our caller.

00:44:05.426 --> 00:44:07.596 A:middle
Now, if it's not
nil, we can point

00:44:07.596 --> 00:44:10.006 A:middle
at the memory location
associated with that pointer

00:44:10.556 --> 00:44:14.756 A:middle
by referring to it as
error.memory and we can read

00:44:14.756 --> 00:44:16.846 A:middle
from that memory or
write to that memory

00:44:16.846 --> 00:44:18.356 A:middle
by just reading or
signing to it.

00:44:19.566 --> 00:44:21.426 A:middle
Now, and this error pointer
is going to take care

00:44:21.426 --> 00:44:24.726 A:middle
of the nitty-gritty details
of making this auto-releasing

00:44:24.866 --> 00:44:27.146 A:middle
to fit in with the
code conventions

00:44:27.146 --> 00:44:29.316 A:middle
of Cocoa NSError handling.

00:44:29.316 --> 00:44:33.146 A:middle
So it's actually fairly easy
to deal with the C pointer

00:44:33.346 --> 00:44:34.516 A:middle
from within the Swift world.

00:44:35.266 --> 00:44:36.626 A:middle
Now let's take a look
at the Swift class

00:44:36.626 --> 00:44:37.856 A:middle
that we've been building here.

00:44:38.436 --> 00:44:42.266 A:middle
We have MyDocument.

00:44:42.266 --> 00:44:43.796 A:middle
It inherits from UIDocument.

00:44:44.356 --> 00:44:45.556 A:middle
It has a property in it.

00:44:45.556 --> 00:44:47.226 A:middle
It has some method overrides.

00:44:47.986 --> 00:44:50.106 A:middle
It's just a Swift class
through and through.

00:44:51.256 --> 00:44:54.316 A:middle
But all of this is
accessible directly

00:44:54.316 --> 00:44:56.096 A:middle
in your Objective-C code.

00:44:57.386 --> 00:44:59.326 A:middle
So if you project
this into Objective-C,

00:44:59.886 --> 00:45:01.656 A:middle
it would look like this.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.886 --> 00:45:01.656 A:middle
it would look like this.

00:45:01.656 --> 00:45:04.406 A:middle
All the same elements are there.

00:45:04.406 --> 00:45:05.306 A:middle
We have properties.

00:45:05.306 --> 00:45:06.166 A:middle
We have methods.

00:45:06.686 --> 00:45:08.636 A:middle
Now there's some interesting
things to point out.

00:45:09.216 --> 00:45:12.596 A:middle
Well, for one, we have
this item's property

00:45:12.596 --> 00:45:13.776 A:middle
that is in an NSArray.

00:45:14.866 --> 00:45:16.596 A:middle
Remember, we talked
about bridging here.

00:45:17.836 --> 00:45:21.046 A:middle
The original Swift code
had an array of strings.

00:45:22.496 --> 00:45:25.416 A:middle
We bridged that seamlessly
over to an NSArray

00:45:25.446 --> 00:45:27.666 A:middle
that contains NSString objects

00:45:27.866 --> 00:45:29.626 A:middle
for your Objective-C
code to use.

00:45:30.146 --> 00:45:35.166 A:middle
So you can use strong typing
in the Swift world and it maps

00:45:35.166 --> 00:45:38.606 A:middle
over to the natural thing
within the Objective-C world.

00:45:39.746 --> 00:45:43.486 A:middle
The other thing I want to point
out is this really ugly name

00:45:43.486 --> 00:45:44.436 A:middle
up top you've noticed.

00:45:45.346 --> 00:45:46.466 A:middle
So this is a mangled name.

00:45:47.386 --> 00:45:50.986 A:middle
Usually you're going to see
this as MyApp.MyDocument,

00:45:51.996 --> 00:45:53.716 A:middle
unless you're poking at
the internal somewhere.

00:45:54.306 --> 00:46:00.126 A:middle
And the purpose of this mangled
name is to put everything


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:54.306 --> 00:46:00.126 A:middle
And the purpose of this mangled
name is to put everything

00:46:00.126 --> 00:46:02.566 A:middle
in a namespace of some
sort so you don't have

00:46:02.566 --> 00:46:04.756 A:middle
to prefix all of
your class names.

00:46:05.616 --> 00:46:09.436 A:middle
Instead, what Swift does
is it puts the module name,

00:46:09.496 --> 00:46:11.786 A:middle
which is your target, your
framework, or your app -

00:46:12.886 --> 00:46:16.186 A:middle
that name into the names
of the classes it creates

00:46:16.386 --> 00:46:18.956 A:middle
so you can use the
simple names that you want

00:46:18.956 --> 00:46:21.486 A:middle
to use throughout your
application and not worry

00:46:21.486 --> 00:46:24.246 A:middle
about a conflict with something
else in the system somewhere.

00:46:26.516 --> 00:46:32.286 A:middle
[ Applause ]

00:46:32.786 --> 00:46:34.106 A:middle
When you're writing
your Swift Classes,

00:46:34.326 --> 00:46:36.436 A:middle
you do need to be a
little bit cognizant

00:46:37.006 --> 00:46:38.886 A:middle
of the limits of Objective-C.

00:46:39.906 --> 00:46:42.286 A:middle
Swift has a lot of cool
features; you might want

00:46:42.286 --> 00:46:45.336 A:middle
to use them -Tuples,
Generics and so on.

00:46:45.876 --> 00:46:48.426 A:middle
And if you go crazy
in your classes

00:46:48.426 --> 00:46:51.526 A:middle
and you use these features,
you might be a little surprised

00:46:51.526 --> 00:46:55.966 A:middle
that this generic method that
returns a tuple doesn't show

00:46:55.966 --> 00:46:58.576 A:middle
up in your Objective-C code
because Objective-C has no way

00:46:58.576 --> 00:46:59.766 A:middle
to express that signature.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:00.306 --> 00:47:01.076 A:middle
There's nothing we can do.

00:47:01.076 --> 00:47:02.386 A:middle
We don't have tuples
in Objective-C.

00:47:04.216 --> 00:47:07.186 A:middle
So if this happens to you
and you're surprised by it,

00:47:08.176 --> 00:47:10.046 A:middle
there's an attribute you
can add to your method.

00:47:10.716 --> 00:47:12.046 A:middle
It's the objc attribute.

00:47:12.596 --> 00:47:16.656 A:middle
And what this does is it
asks the compiler to check

00:47:17.166 --> 00:47:22.326 A:middle
and make sure that this method
or property or initializer

00:47:22.326 --> 00:47:26.636 A:middle
or whatever is expressible in
Objective-C so it can be used

00:47:26.636 --> 00:47:27.856 A:middle
from your Objective-C code.

00:47:28.566 --> 00:47:31.566 A:middle
And if it's not expressible in
Objective-C for some reason,

00:47:31.896 --> 00:47:33.696 A:middle
the compiler will
give you a hard error

00:47:33.696 --> 00:47:36.536 A:middle
to tell you this is not
something you can use

00:47:36.536 --> 00:47:37.246 A:middle
from Objective-C.

00:47:39.006 --> 00:47:42.676 A:middle
Now the objc attribute
actually has a second purpose.

00:47:42.866 --> 00:47:45.626 A:middle
And that's controlling
the names that you see

00:47:45.626 --> 00:47:47.386 A:middle
in the Objective-C
side of things.

00:47:48.456 --> 00:47:50.096 A:middle
So, here's a property enabled.

00:47:50.286 --> 00:47:51.046 A:middle
It has a getter.

00:47:51.046 --> 00:47:51.806 A:middle
It has a setter.

00:47:53.486 --> 00:47:56.336 A:middle
In Objective-C this is going to
come through as a property named

00:47:56.336 --> 00:48:00.216 A:middle
"enabled," a getter named
"enabled," and a setter named


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:56.336 --> 00:48:00.216 A:middle
"enabled," a getter named
"enabled," and a setter named

00:48:00.216 --> 00:48:04.436 A:middle
"setEnabled:" That's
not Cocoa convention.

00:48:04.596 --> 00:48:07.346 A:middle
You'd really rather the call,
the getter, "isEnabled".

00:48:08.726 --> 00:48:11.186 A:middle
And so to do that we just
use the objc attribute,

00:48:11.946 --> 00:48:13.976 A:middle
provide it with the
selector "isEnabled"

00:48:14.346 --> 00:48:17.136 A:middle
so we can control
the mapping ourselves

00:48:17.136 --> 00:48:18.746 A:middle
between these two languages.

00:48:19.476 --> 00:48:21.206 A:middle
I don't expect you
to do this often,

00:48:21.856 --> 00:48:24.866 A:middle
but it's there if you need it.

00:48:25.136 --> 00:48:29.746 A:middle
You can also do this
for the name of a class.

00:48:29.916 --> 00:48:32.106 A:middle
And what we have here
in the parentheses,

00:48:32.326 --> 00:48:36.806 A:middle
in the objc attribute, is the
non-named space name of a class.

00:48:37.406 --> 00:48:38.706 A:middle
So why would you do this?

00:48:39.206 --> 00:48:42.556 A:middle
Well, perhaps you're porting
part of your application

00:48:42.556 --> 00:48:44.496 A:middle
from Objective-C to
Swift for some reason.

00:48:45.036 --> 00:48:46.906 A:middle
And so you had ABCMyDocument.

00:48:47.226 --> 00:48:48.816 A:middle
Now you just want to
call it MyDocument

00:48:48.816 --> 00:48:50.316 A:middle
because you're sick
of typing ABC.

00:48:51.346 --> 00:48:53.876 A:middle
However, you have some
archives that you still want

00:48:53.876 --> 00:48:55.446 A:middle
to have work, because
this is going

00:48:55.446 --> 00:48:57.466 A:middle
to be a drop-in compatible
implementation.

00:48:58.316 --> 00:49:00.116 A:middle
In Swift, for your
Objective-C class,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:58.316 --> 00:49:00.116 A:middle
In Swift, for your
Objective-C class,

00:49:00.476 --> 00:49:01.976 A:middle
you can use the objc attribute

00:49:02.116 --> 00:49:06.676 A:middle
to give this class the
runtime name of ABCMyDocument

00:49:06.926 --> 00:49:08.526 A:middle
and keep all of your
archives working.

00:49:08.526 --> 00:49:11.836 A:middle
One last thing I
promised to talk about,

00:49:12.276 --> 00:49:14.246 A:middle
and that's CF Interoperability.

00:49:15.286 --> 00:49:20.216 A:middle
So by CF we're referring
to all of the C-like APIs

00:49:20.296 --> 00:49:22.686 A:middle
that work with the C objects.

00:49:22.966 --> 00:49:24.476 A:middle
So, this is Core Foundation.

00:49:24.476 --> 00:49:27.706 A:middle
This is Core Graphics
and other frameworks,

00:49:27.706 --> 00:49:29.056 A:middle
maybe some of your
own frameworks.

00:49:29.866 --> 00:49:32.976 A:middle
And let's take a
little look at using CF,

00:49:33.196 --> 00:49:35.906 A:middle
particularly Core
Graphics in Objective-C.

00:49:36.256 --> 00:49:38.426 A:middle
I'm going to do something
really simple here.

00:49:38.496 --> 00:49:42.806 A:middle
I'm going to draw a gradient in
a rectangle using Core Graphics.

00:49:43.276 --> 00:49:46.686 A:middle
Here's my start.

00:49:47.096 --> 00:49:48.916 A:middle
I need to go build
up the ColorSpace

00:49:49.006 --> 00:49:49.986 A:middle
and build up the Gradient.

00:49:50.036 --> 00:49:54.496 A:middle
Now there's a couple of things
of here that I find non-optimal.

00:49:55.236 --> 00:49:56.956 A:middle
So the one thing
is bridge casts.

00:49:57.916 --> 00:49:58.726 A:middle
So we're in ARC.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:00.056 --> 00:50:00.666 A:middle
It's partly great.

00:50:00.666 --> 00:50:02.366 A:middle
It's handling our
NSArray for us.

00:50:02.366 --> 00:50:04.596 A:middle
We're using the nice
array literal syntax.

00:50:04.846 --> 00:50:09.136 A:middle
But now we need to do bridge
casts between CGColorRef and id

00:50:09.136 --> 00:50:11.296 A:middle
so we can put things
into the NSArray.

00:50:12.866 --> 00:50:15.536 A:middle
And we have this
CFArray cast sort

00:50:15.536 --> 00:50:16.836 A:middle
of doing toll-free
bridging there

00:50:16.996 --> 00:50:19.296 A:middle
between the NSArray
and the CFArray.

00:50:20.666 --> 00:50:24.076 A:middle
And there's also this
semi-amusing thing

00:50:24.076 --> 00:50:26.656 A:middle
that we're using three
different kinds of arrays

00:50:27.186 --> 00:50:28.356 A:middle
in four lines of code.

00:50:28.796 --> 00:50:34.246 A:middle
And you can write this - you
can try to write this better.

00:50:34.246 --> 00:50:37.546 A:middle
I couldn't, actually, find a way
to make it cleaner than this.

00:50:38.216 --> 00:50:40.186 A:middle
And it's really unfortunate

00:50:40.416 --> 00:50:43.236 A:middle
because the NSArray gives
us some useful behavior.

00:50:43.236 --> 00:50:45.056 A:middle
ARC is managing its
lifetime for us.

00:50:45.056 --> 00:50:45.686 A:middle
That's great.

00:50:46.086 --> 00:50:49.676 A:middle
We need the C Array because
we need to put CGFloats in it,

00:50:50.246 --> 00:50:52.166 A:middle
and we can't do that
within NSArray.

00:50:53.596 --> 00:50:56.256 A:middle
And finally, we need to
do the toll-free bridging

00:50:56.256 --> 00:51:00.846 A:middle
over to CFArrayRef
because that's what we use


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:56.256 --> 00:51:00.846 A:middle
over to CFArrayRef
because that's what we use

00:51:00.846 --> 00:51:04.846 A:middle
with Core Graphics APIs.

00:51:05.056 --> 00:51:07.066 A:middle
Now, moving along, we
can create some points

00:51:07.066 --> 00:51:10.696 A:middle
with CGPointMake and, of course,
even though you're under ARC

00:51:10.986 --> 00:51:12.996 A:middle
where memory management
is automatic,

00:51:13.366 --> 00:51:15.556 A:middle
it's not automated
for CF things.

00:51:15.556 --> 00:51:17.796 A:middle
So we have to remember
to release the ColorSpace

00:51:17.896 --> 00:51:18.906 A:middle
and release the Gradient.

00:51:19.636 --> 00:51:21.046 A:middle
We feel like we can
do a little bit better

00:51:21.046 --> 00:51:21.816 A:middle
in the world of Swift.

00:51:23.106 --> 00:51:26.686 A:middle
So let's start again,
this time in Swift.

00:51:27.126 --> 00:51:29.296 A:middle
And first, let's
build our colorSpace.

00:51:30.256 --> 00:51:33.156 A:middle
So here we're just calling
CGColorSpaceCreateDeviceRGB().

00:51:34.746 --> 00:51:35.996 A:middle
Nothing different about that.

00:51:36.856 --> 00:51:39.236 A:middle
However, the type that we infer

00:51:39.236 --> 00:51:43.106 A:middle
for this ColorSpace
variable is CGColorSpace.

00:51:44.016 --> 00:51:46.406 A:middle
Note the lack of a ref
at the end of this.

00:51:46.986 --> 00:51:49.006 A:middle
This isn't some opaque pointer.

00:51:49.686 --> 00:51:54.386 A:middle
This is the CGColorSpace
class that we've created.

00:51:55.866 --> 00:51:57.676 A:middle
What's the nice thing
about being a class?

00:51:57.996 --> 00:52:00.226 A:middle
Well, that means we're in
the ARC model and we're going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:57.996 --> 00:52:00.226 A:middle
Well, that means we're in
the ARC model and we're going

00:52:00.226 --> 00:52:02.606 A:middle
to automatically manage
the memory for you.

00:52:04.516 --> 00:52:09.946 A:middle
[ Applause ]

00:52:10.446 --> 00:52:13.166 A:middle
Let's go a little
further and create

00:52:13.166 --> 00:52:14.446 A:middle
that Gradient we talked about.

00:52:15.896 --> 00:52:18.936 A:middle
So here, remember, we need to
pass a couple of arrays through.

00:52:19.816 --> 00:52:23.426 A:middle
We can use this nice
Swift array literal syntax

00:52:23.906 --> 00:52:26.456 A:middle
to form an array containing
startColor and Color.

00:52:27.296 --> 00:52:30.166 A:middle
We're doing all of the bridging
automatically here for you.

00:52:30.426 --> 00:52:32.186 A:middle
So we've created
the NSArray we need.

00:52:32.516 --> 00:52:36.386 A:middle
We've toll-free bridged it to
the CFArray behind the scenes

00:52:36.536 --> 00:52:38.616 A:middle
so you don't have to deal
with the fact that there are

00:52:38.616 --> 00:52:40.106 A:middle
so many array types
running around.

00:52:40.606 --> 00:52:44.606 A:middle
Did the exact same
thing for the C parts.

00:52:45.226 --> 00:52:48.936 A:middle
So here we just have an array
of floating point values.

00:52:49.366 --> 00:52:52.756 A:middle
So it's treated as a native
Swift array of CGFloats

00:52:53.866 --> 00:52:57.516 A:middle
that we bridged seamlessly
to the underlying C array

00:52:57.776 --> 00:52:59.436 A:middle
that this C function expects.

00:52:59.926 --> 00:53:03.136 A:middle
Let's keep going with
our example here.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:59.926 --> 00:53:03.136 A:middle
Let's keep going with
our example here.

00:53:04.976 --> 00:53:08.716 A:middle
CGPoint. You can use
CGPointMake if you want.

00:53:09.086 --> 00:53:10.106 A:middle
It's perfectly fine.

00:53:10.106 --> 00:53:13.126 A:middle
It works exactly the same way
as it does in Objective-C.

00:53:14.256 --> 00:53:16.556 A:middle
However, whenever
we import a struct,

00:53:16.726 --> 00:53:20.346 A:middle
like CGPoint is a struct, we
provide it with initializers

00:53:21.126 --> 00:53:22.626 A:middle
that have labeled arguments.

00:53:23.056 --> 00:53:26.256 A:middle
And so a better way to
build CGPoints in Swift is

00:53:26.496 --> 00:53:29.706 A:middle
to just construct a
CGPoint value using

00:53:29.706 --> 00:53:32.046 A:middle
that same construction
syntax we've been talking

00:53:32.046 --> 00:53:33.266 A:middle
about throughout this talk.

00:53:34.726 --> 00:53:37.506 A:middle
And then use the
argument labels x and y

00:53:37.806 --> 00:53:39.926 A:middle
to make it absolutely
clear what you're doing.

00:53:39.926 --> 00:53:42.996 A:middle
And this brings a
little bit of a flavor

00:53:43.146 --> 00:53:46.646 A:middle
of that nice Cocoa readability
using argument labels

00:53:47.036 --> 00:53:48.646 A:middle
into the underlying CF APIs.

00:53:48.646 --> 00:53:52.366 A:middle
And that's it for
our example in Swift.

00:53:52.846 --> 00:53:53.626 A:middle
It's smaller.

00:53:53.626 --> 00:53:54.416 A:middle
It's easier.

00:53:54.416 --> 00:53:56.746 A:middle
There's far fewer concepts
that you have to deal

00:53:56.746 --> 00:53:58.976 A:middle
with because we've automatically
taken over the management.

00:53:59.516 --> 00:54:06.356 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:59.516 --> 00:54:06.356 A:middle
[ Applause ]

00:54:06.856 --> 00:54:09.086 A:middle
Now you may have some of
your own APIs that we refer

00:54:09.086 --> 00:54:11.066 A:middle
to as explicitly bridged.

00:54:11.726 --> 00:54:14.046 A:middle
So these are CF-like APIs

00:54:14.526 --> 00:54:17.136 A:middle
where we're not quite sure
whether you're following all the

00:54:17.136 --> 00:54:22.066 A:middle
CF memory conventions because,
unlike the world of Cocoa

00:54:22.066 --> 00:54:25.126 A:middle
which is fairly tame, and we've
been following conventions

00:54:25.126 --> 00:54:28.016 A:middle
fairly well for many years,
we haven't been following them

00:54:28.016 --> 00:54:30.056 A:middle
so well in C as a community.

00:54:30.746 --> 00:54:34.356 A:middle
And so we may have this
function GetRandomColor,

00:54:34.696 --> 00:54:35.886 A:middle
produces some random color.

00:54:36.976 --> 00:54:40.836 A:middle
When we pull this in, the Swift
compiler doesn't know whether we

00:54:40.836 --> 00:54:43.886 A:middle
can really trust that this
returns plus zero or not.

00:54:43.956 --> 00:54:46.186 A:middle
It has get in the name
but we're not sure.

00:54:46.686 --> 00:54:49.126 A:middle
And so we do the safe
thing and we import it

00:54:49.126 --> 00:54:51.356 A:middle
as an Unmanaged&lt;CGColor&gt;

00:54:52.546 --> 00:54:55.326 A:middle
which means we can't directly
manage the memory here

00:54:55.326 --> 00:54:57.076 A:middle
because we don't know
what the conventions are.

00:54:58.656 --> 00:55:00.536 A:middle
So what is this Unmanaged thing?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:58.656 --> 00:55:00.536 A:middle
So what is this Unmanaged thing?

00:55:00.966 --> 00:55:03.886 A:middle
So Unmanaged is actually
a generic struct

00:55:04.856 --> 00:55:05.916 A:middle
over an arbitrary T.

00:55:06.836 --> 00:55:09.316 A:middle
Now the details of generic
structs we don't need

00:55:09.316 --> 00:55:10.216 A:middle
to go into now.

00:55:10.326 --> 00:55:12.916 A:middle
They're covered in the Advanced
talk which I highly recommend.

00:55:13.536 --> 00:55:15.926 A:middle
What we want to look at right
now is just the simple API

00:55:16.526 --> 00:55:17.626 A:middle
of this Unmanaged type.

00:55:18.156 --> 00:55:21.706 A:middle
We have two core operations
- takeUnretainedValue,

00:55:21.876 --> 00:55:25.226 A:middle
which you use for +0
returns, and takeRetainedValue

00:55:25.226 --> 00:55:27.216 A:middle
which you use for +1 returns.

00:55:27.746 --> 00:55:32.116 A:middle
Now, when we call our
CGColorGetRandomColor,

00:55:32.766 --> 00:55:35.396 A:middle
we want to immediately use
one of these two functions.

00:55:35.536 --> 00:55:39.166 A:middle
So we know that GetRandomColor
returns a plus zero,

00:55:39.456 --> 00:55:41.306 A:middle
so we're going to do a
takeUnretainedValue of it.

00:55:42.126 --> 00:55:43.706 A:middle
Now the reason to
do this immediately

00:55:43.706 --> 00:55:47.286 A:middle
after the call is
this gets us a CGColor

00:55:47.486 --> 00:55:48.486 A:middle
which takes us right back

00:55:48.606 --> 00:55:51.186 A:middle
into automatically
managing memory for you.

00:55:52.286 --> 00:55:54.756 A:middle
So the window in which
you have to do something

00:55:54.926 --> 00:55:57.476 A:middle
with manual memory
management is tiny.

00:55:57.476 --> 00:55:59.256 A:middle
It's just this one
little line of code

00:55:59.556 --> 00:56:01.306 A:middle
where you establish
what the convention is


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:59.556 --> 00:56:01.306 A:middle
where you establish
what the convention is

00:56:01.596 --> 00:56:03.776 A:middle
for CGColorGetRandomColor.

00:56:04.366 --> 00:56:12.706 A:middle
Now, if you own
CGColorGetRandomColor,

00:56:13.526 --> 00:56:17.036 A:middle
you can audit your APIs to
make sure they follow the Core

00:56:17.036 --> 00:56:20.046 A:middle
Foundation naming conventions
for memory management.

00:56:21.276 --> 00:56:24.226 A:middle
And when they do, you can
use these annotations here

00:56:24.226 --> 00:56:25.106 A:middle
in core foundation -

00:56:25.266 --> 00:56:27.586 A:middle
CF-IMPLICIT-BRIDGING-ENABLED
and DISABLED.

00:56:28.066 --> 00:56:31.616 A:middle
Put this over a whole header
once you've audited all the

00:56:31.616 --> 00:56:32.596 A:middle
methods in that header.

00:56:33.626 --> 00:56:38.046 A:middle
And when you do that, well,
now your function when you use

00:56:38.046 --> 00:56:42.056 A:middle
from Swift, gets you right back
into the managed world directly.

00:56:43.176 --> 00:56:46.016 A:middle
So you have the great
automatic memory management

00:56:46.386 --> 00:56:48.426 A:middle
that Swift can provide for CF.

00:56:49.816 --> 00:56:50.836 A:middle
So let's wrap up here.

00:56:50.836 --> 00:56:53.346 A:middle
We've talked about a
lot of different topics.

00:56:54.516 --> 00:56:55.896 A:middle
We've talked about
interoperability

00:56:55.896 --> 00:56:57.256 A:middle
between Swift and Objective-C.

00:56:57.616 --> 00:57:00.166 A:middle
We've talked about a whole lot
of rules about how that works.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:57.616 --> 00:57:00.166 A:middle
We've talked about a whole lot
of rules about how that works.

00:57:00.476 --> 00:57:02.746 A:middle
But let the tools and
documentation help you.

00:57:03.046 --> 00:57:05.896 A:middle
They can show you Swift and
Objective-C side-by-side

00:57:05.986 --> 00:57:09.576 A:middle
so you can get a feel for how
your Objective-C APIs work

00:57:09.576 --> 00:57:10.086 A:middle
in Swift.

00:57:11.126 --> 00:57:12.626 A:middle
We've talked about
some of the details

00:57:12.626 --> 00:57:14.846 A:middle
of bridging Core
Cocoa data types

00:57:14.916 --> 00:57:17.226 A:middle
and using Swift's native types.

00:57:18.326 --> 00:57:22.166 A:middle
And we talked about automated
CF memory management available

00:57:23.136 --> 00:57:24.046 A:middle
in Swift.

00:57:24.206 --> 00:57:26.376 A:middle
For more information,
check out the

00:57:26.376 --> 00:57:30.086 A:middle
"Swift Programming Language
Book," and also the "Using Swift

00:57:30.086 --> 00:57:32.126 A:middle
with Cocoa and Objective-C"
guide that goes

00:57:32.126 --> 00:57:34.286 A:middle
into more details
on the interplay

00:57:34.286 --> 00:57:38.716 A:middle
between these two
programming languages.

00:57:39.136 --> 00:57:39.906 A:middle
Thank you.

00:57:40.516 --> 00:57:55.880 A:middle
[ Applause ]

