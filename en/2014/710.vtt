WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:12.356 --> 00:00:13.036 A:middle
&gt;&gt; Good morning.

00:00:13.806 --> 00:00:16.166 A:middle
Welcome to Writing Energy
Efficient Code, Part 1.

00:00:16.436 --> 00:00:19.806 A:middle
I'm Anthony Chivetta from the
OS X Power &amp; Performance team.

00:00:20.726 --> 00:00:22.646 A:middle
And hopefully, everyone
is feeling awake

00:00:22.646 --> 00:00:25.266 A:middle
and recharged this morning now
that you've had your first cup

00:00:25.266 --> 00:00:26.866 A:middle
of coffee, your iDevices

00:00:26.866 --> 00:00:28.926 A:middle
and Macs have a full
charge from overnight.

00:00:29.476 --> 00:00:32.735 A:middle
But unfortunately, as we all
know, as the day wears on,

00:00:33.616 --> 00:00:36.196 A:middle
sometimes our energy
can begin to drain,

00:00:36.946 --> 00:00:38.846 A:middle
we find our batteries
just aren't as full.

00:00:39.576 --> 00:00:40.636 A:middle
And I want to talk to you today

00:00:40.636 --> 00:00:44.896 A:middle
about how you can help make sure
your applications contribute

00:00:44.896 --> 00:00:47.516 A:middle
to extending users' battery
life for as long as possible,

00:00:47.706 --> 00:00:49.386 A:middle
and improving the
user experience

00:00:50.576 --> 00:00:52.136 A:middle
by making sure users
can continue

00:00:52.136 --> 00:00:53.556 A:middle
to use your app all day long.

00:00:53.556 --> 00:00:55.546 A:middle
And of course, you know running

00:00:55.546 --> 00:00:57.066 A:middle
out of battery life is
something we all hate.

00:00:57.416 --> 00:00:59.546 A:middle
So, hopefully, that in
itself is motivation to try

00:00:59.546 --> 00:01:01.866 A:middle
to help improve the energy
efficiency of your application.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.546 --> 00:01:01.866 A:middle
to help improve the energy
efficiency of your application.

00:01:02.346 --> 00:01:06.676 A:middle
But if not, in OS X
Mavericks and iOS 8,

00:01:07.016 --> 00:01:09.916 A:middle
we've been helping
provide users better tools

00:01:10.256 --> 00:01:12.716 A:middle
to understand what
applications are contributing

00:01:12.716 --> 00:01:14.566 A:middle
to battery life on their system.

00:01:15.016 --> 00:01:17.606 A:middle
So, on the left in
OS X Mavericks,

00:01:17.636 --> 00:01:20.546 A:middle
we added to the Battery
menu a list of applications

00:01:20.546 --> 00:01:22.156 A:middle
that are using significant
amounts of energy.

00:01:22.706 --> 00:01:25.606 A:middle
And on the right, you can see
the new Battery Usage screen

00:01:25.606 --> 00:01:26.906 A:middle
in iOS 8 settings.

00:01:27.346 --> 00:01:30.756 A:middle
And with these tools, users
can make smart decisions

00:01:30.756 --> 00:01:32.116 A:middle
about what apps they use,

00:01:32.396 --> 00:01:35.156 A:middle
understanding how those apps
impact their battery life.

00:01:35.216 --> 00:01:36.886 A:middle
So, if your app is
energy inefficient,

00:01:36.886 --> 00:01:38.876 A:middle
you might find users
stop using your apps

00:01:39.616 --> 00:01:41.176 A:middle
or give them poor
App Store ratings.

00:01:41.496 --> 00:01:43.576 A:middle
And so, it's in everyone's
interest

00:01:43.656 --> 00:01:46.096 A:middle
to make sure your apps are as
energy efficient as possible.

00:01:46.386 --> 00:01:49.616 A:middle
So, with that, what are we
going to talk about today?

00:01:50.736 --> 00:01:52.896 A:middle
We'll start by going
through some general power

00:01:52.896 --> 00:01:53.906 A:middle
energy concepts.

00:01:53.906 --> 00:01:55.676 A:middle
So, you have kind of a
high level understanding

00:01:55.676 --> 00:01:56.986 A:middle
of what it is we're discussing.

00:01:57.176 --> 00:02:00.466 A:middle
And then, we'll go
through some specific ways


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:57.176 --> 00:02:00.466 A:middle
And then, we'll go
through some specific ways

00:02:00.466 --> 00:02:01.996 A:middle
that you can improve
your energy use.

00:02:02.456 --> 00:02:04.886 A:middle
We'll start with the technique
of doing something never,

00:02:05.856 --> 00:02:07.496 A:middle
progress to doing
it at a better time,

00:02:08.545 --> 00:02:10.096 A:middle
discuss how to do
it more efficiently,

00:02:11.396 --> 00:02:13.356 A:middle
and finally, how to do less.

00:02:13.356 --> 00:02:17.066 A:middle
And then, for Part 2, in
the same room immediately

00:02:17.066 --> 00:02:20.296 A:middle
after this talk, Albert will
come up and talk specifically

00:02:20.296 --> 00:02:22.516 A:middle
about networking, location,

00:02:22.966 --> 00:02:25.736 A:middle
and sleep/wake issues
in much more depth.

00:02:26.316 --> 00:02:27.896 A:middle
And so with that,
let's get started.

00:02:28.706 --> 00:02:30.376 A:middle
So, first, what uses energy?

00:02:30.376 --> 00:02:31.876 A:middle
Well, the short answer
is everything

00:02:31.876 --> 00:02:33.046 A:middle
on the system uses energy.

00:02:33.046 --> 00:02:35.866 A:middle
Any resource you
might use as part

00:02:35.866 --> 00:02:38.126 A:middle
of your code's execution is
going to consume some energy.

00:02:38.806 --> 00:02:41.406 A:middle
And a few things you want to
keep particularly in mind,

00:02:41.406 --> 00:02:43.026 A:middle
the first is your
CPU consumption.

00:02:43.406 --> 00:02:45.776 A:middle
And CPU has a huge dynamic
range, using a little

00:02:45.776 --> 00:02:47.506 A:middle
versus using a lot
makes a big difference.

00:02:48.796 --> 00:02:50.856 A:middle
How you use Flash
storage in particular.

00:02:50.856 --> 00:02:53.416 A:middle
Flash also has a
big dynamic range.

00:02:53.816 --> 00:02:56.496 A:middle
So, any time you read or
write to a storage device,

00:02:56.496 --> 00:02:58.376 A:middle
you're going to incur
more energy consumption.

00:02:59.456 --> 00:03:01.636 A:middle
Networking, especially
on iOS devices


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.456 --> 00:03:01.636 A:middle
Networking, especially
on iOS devices

00:03:01.636 --> 00:03:04.006 A:middle
with so many different types
of networking, can play,

00:03:04.166 --> 00:03:07.706 A:middle
can be a large factor in
your energy consumption.

00:03:07.706 --> 00:03:11.836 A:middle
And then Graphics, you might
do a little bit of drawing

00:03:11.836 --> 00:03:13.476 A:middle
in your app but this
can cause a lot of work

00:03:13.476 --> 00:03:15.266 A:middle
to happen downstream
the Graphics pipeline.

00:03:15.736 --> 00:03:17.416 A:middle
This is obviously not
an exhaustive list,

00:03:17.856 --> 00:03:19.846 A:middle
but just some areas of your
application you should kind

00:03:19.846 --> 00:03:22.116 A:middle
of keep in the back of your
head as we talk about some

00:03:22.116 --> 00:03:23.376 A:middle
of these power fundamentals.

00:03:24.936 --> 00:03:26.336 A:middle
So, let's look at
the graph here.

00:03:26.676 --> 00:03:28.686 A:middle
And we're going to see a number
of graphs like this today.

00:03:28.686 --> 00:03:30.906 A:middle
So, just to kind of orient
you, on the bottom here,

00:03:30.906 --> 00:03:34.136 A:middle
we have time going
across from left to right.

00:03:34.136 --> 00:03:36.436 A:middle
And on the vertical
axis, we have power.

00:03:36.436 --> 00:03:37.746 A:middle
So, you can imagine,
we took a device

00:03:37.746 --> 00:03:38.816 A:middle
and attached the power meter.

00:03:39.286 --> 00:03:40.856 A:middle
And we would like
to see a reading

00:03:40.856 --> 00:03:42.266 A:middle
that looks something like this.

00:03:42.716 --> 00:03:47.586 A:middle
There's a couple of features of
this graph I want to point out.

00:03:48.066 --> 00:03:50.726 A:middle
The first is this very low
idle power at the beginning.

00:03:50.876 --> 00:03:52.416 A:middle
Our devices are really
good at getting

00:03:52.416 --> 00:03:54.536 A:middle
into low-power states
when not being used.

00:03:54.806 --> 00:03:57.876 A:middle
And so, the idle power of
a device is very, very low.

00:03:58.546 --> 00:04:01.116 A:middle
We then have these portions
where the system is active.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.546 --> 00:04:01.116 A:middle
We then have these portions
where the system is active.

00:04:01.116 --> 00:04:02.956 A:middle
Your code might have been
running, doing something,

00:04:03.296 --> 00:04:05.416 A:middle
were actively consuming
resources

00:04:05.416 --> 00:04:06.466 A:middle
and accomplishing work.

00:04:06.916 --> 00:04:09.436 A:middle
And then we also have
these intermediate states.

00:04:09.696 --> 00:04:11.426 A:middle
And these are places
where the system is idle,

00:04:11.526 --> 00:04:13.386 A:middle
but we haven't been able
to get all the way back

00:04:13.386 --> 00:04:14.956 A:middle
down to our lowest idle power.

00:04:15.886 --> 00:04:17.546 A:middle
We need some time to
achieve that state

00:04:17.546 --> 00:04:18.805 A:middle
and you can see at
the end, we do.

00:04:19.315 --> 00:04:20.546 A:middle
But if you have sporadic work,

00:04:20.546 --> 00:04:22.436 A:middle
we can stay in these
intermediate states

00:04:22.436 --> 00:04:23.316 A:middle
for a very long time.

00:04:24.486 --> 00:04:26.456 A:middle
So, ultimately, what we can
do is we can divide this graph

00:04:26.456 --> 00:04:26.966 A:middle
in half.

00:04:27.196 --> 00:04:30.256 A:middle
We can say everything in the
top half is the dynamic cost.

00:04:30.496 --> 00:04:32.936 A:middle
This is the cost associated
with actually accomplishing more

00:04:32.936 --> 00:04:35.976 A:middle
and more work, whereas the
bottom part is the fixed cost.

00:04:35.976 --> 00:04:38.126 A:middle
This is what we pay just
to have accomplished any

00:04:38.126 --> 00:04:38.956 A:middle
work whatsoever.

00:04:39.396 --> 00:04:42.116 A:middle
And this fixed-cost
concept can come

00:04:42.116 --> 00:04:43.996 A:middle
into play whenever you
have sporadic work.

00:04:43.996 --> 00:04:45.656 A:middle
So, you can imagine here,

00:04:45.966 --> 00:04:47.326 A:middle
we have a workload
that's doing a bunch

00:04:47.326 --> 00:04:48.706 A:middle
of little tasks sporadically.

00:04:49.576 --> 00:04:53.096 A:middle
Well, all of this blue area at
the bottom is the fixed cost.

00:04:53.496 --> 00:04:55.166 A:middle
That's a lot of energy
we're consuming

00:04:55.166 --> 00:04:58.156 A:middle
to get a very small
actual amount of work done.

00:04:59.096 --> 00:05:02.566 A:middle
So, any time you can help
avoid small sporadic work units


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.096 --> 00:05:02.566 A:middle
So, any time you can help
avoid small sporadic work units

00:05:02.776 --> 00:05:04.076 A:middle
by aggregating them together,

00:05:04.616 --> 00:05:08.706 A:middle
you can dramatically reduce
the fixed cost of your work.

00:05:09.386 --> 00:05:11.846 A:middle
And this is an easy way
to get energy savings.

00:05:12.116 --> 00:05:13.586 A:middle
And it's also important
to keep in mind

00:05:13.586 --> 00:05:15.246 A:middle
because your app
probably does lots

00:05:15.246 --> 00:05:16.676 A:middle
of things exponentially
concurrently.

00:05:16.956 --> 00:05:19.016 A:middle
And you have to think
holistically about the behavior

00:05:19.016 --> 00:05:21.216 A:middle
of your application to make
sure you're grouping work

00:05:21.216 --> 00:05:22.276 A:middle
together appropriately.

00:05:24.576 --> 00:05:26.156 A:middle
So, we've also mentioned
these terms,

00:05:26.156 --> 00:05:27.836 A:middle
energy and power, a few times.

00:05:28.106 --> 00:05:30.256 A:middle
Let's put some more
specific definitions to them.

00:05:30.676 --> 00:05:32.176 A:middle
So, first, power.

00:05:32.636 --> 00:05:34.246 A:middle
Power is an instantaneous
measurement.

00:05:34.326 --> 00:05:36.236 A:middle
So, as we're looking at
these graphs it's the value

00:05:36.236 --> 00:05:37.236 A:middle
at one point in time.

00:05:37.786 --> 00:05:41.146 A:middle
On the other hand, energy is
the area under that graph.

00:05:41.446 --> 00:05:44.266 A:middle
So, we might say that something
consumes a certain number

00:05:44.266 --> 00:05:46.436 A:middle
of watts as an instantaneous
power measurement.

00:05:46.746 --> 00:05:49.106 A:middle
But to accomplish a task,
we want to talk about joules

00:05:49.106 --> 00:05:50.486 A:middle
and the total energy it uses.

00:05:51.266 --> 00:05:53.456 A:middle
And it's important to keep
these concepts separate

00:05:53.456 --> 00:05:55.576 A:middle
because we can actually
trade power for energy.

00:05:55.866 --> 00:05:58.466 A:middle
So, let's imagine we have
a single-threaded workload.

00:05:59.006 --> 00:06:01.856 A:middle
The actual dynamic cost of
that work is just this top part


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.006 --> 00:06:01.856 A:middle
The actual dynamic cost of
that work is just this top part

00:06:01.856 --> 00:06:02.276 A:middle
in blue.

00:06:02.276 --> 00:06:03.866 A:middle
And if we were to make

00:06:03.866 --> 00:06:05.546 A:middle
that single-threaded
workload multi-threaded,

00:06:06.456 --> 00:06:09.486 A:middle
we can have the same dynamic
cost but reduce our fixed cost

00:06:09.486 --> 00:06:10.746 A:middle
by getting the work done faster.

00:06:11.116 --> 00:06:13.806 A:middle
In this way, our
instantaneous power is increased

00:06:14.236 --> 00:06:16.556 A:middle
but our overall energy
consumption is decreased.

00:06:16.606 --> 00:06:18.866 A:middle
In essence, by getting
better performance,

00:06:18.866 --> 00:06:20.726 A:middle
we've also achieved
better energy use.

00:06:21.126 --> 00:06:22.556 A:middle
And that's a common
theme we'll talk about,

00:06:22.556 --> 00:06:24.436 A:middle
is that any time you
can improve performance,

00:06:24.716 --> 00:06:26.306 A:middle
it's also likely going
to improve energy,

00:06:26.486 --> 00:06:27.666 A:middle
and these things
go hand in hand.

00:06:28.176 --> 00:06:31.216 A:middle
So, that's our power
fundamentals.

00:06:31.286 --> 00:06:33.426 A:middle
Things to remember is
that work is a fixed cost.

00:06:33.426 --> 00:06:36.686 A:middle
For small workloads, that
fixed cost will often dominate.

00:06:37.106 --> 00:06:38.256 A:middle
For intensive workloads,

00:06:38.256 --> 00:06:39.856 A:middle
the dynamic cost will
usually dominate.

00:06:40.316 --> 00:06:42.496 A:middle
And better performance
often means better energy.

00:06:43.096 --> 00:06:48.086 A:middle
OK, so, let's dive into
techniques you can use

00:06:48.086 --> 00:06:50.016 A:middle
to improve the energy
consumption of your app.

00:06:50.666 --> 00:06:52.436 A:middle
The first we want to talk
about is Do It Never.

00:06:52.746 --> 00:06:56.116 A:middle
So, this might seem simple-if
you can avoid doing work,

00:06:56.276 --> 00:06:57.016 A:middle
avoid doing it.

00:06:57.556 --> 00:07:00.086 A:middle
That's certainly going to have
better energy consumption.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.556 --> 00:07:00.086 A:middle
That's certainly going to have
better energy consumption.

00:07:00.176 --> 00:07:01.966 A:middle
So, let's imagine we
have an application

00:07:01.996 --> 00:07:04.906 A:middle
and some ad that's animating,
maybe it's a scrolling marquee

00:07:04.906 --> 00:07:07.096 A:middle
like in our iTunes
or App Stores.

00:07:07.596 --> 00:07:10.916 A:middle
And this is fine, you know,
that's a nice user interface.

00:07:11.256 --> 00:07:16.776 A:middle
But what happens if another app
comes along and they're sitting

00:07:16.776 --> 00:07:17.996 A:middle
in front of your application?

00:07:18.766 --> 00:07:22.306 A:middle
Are you still doing the work
necessary for that, for your ad

00:07:22.306 --> 00:07:24.946 A:middle
or marquee or what it might be
to draw it up into the screen?

00:07:25.486 --> 00:07:26.796 A:middle
Are your timers still firing?

00:07:27.026 --> 00:07:29.216 A:middle
Are you still consuming energy
even though the user can't see

00:07:29.216 --> 00:07:29.716 A:middle
your app?

00:07:30.606 --> 00:07:32.836 A:middle
It's very important to make
sure that we're not doing work

00:07:33.136 --> 00:07:35.676 A:middle
to power user interface features
that the user isn't aware of.

00:07:36.176 --> 00:07:40.536 A:middle
So, on iOS, hopefully, most of
you are familiar with these.

00:07:40.536 --> 00:07:43.026 A:middle
There's two
UIApplicationDelegate methods

00:07:43.026 --> 00:07:45.666 A:middle
you can implement,
applicationDidResignActive

00:07:45.666 --> 00:07:47.176 A:middle
and applicationDidBecomeActive.

00:07:47.306 --> 00:07:49.106 A:middle
And you'll get didResignActive

00:07:49.106 --> 00:07:50.466 A:middle
when your app enters
the background

00:07:50.736 --> 00:07:53.006 A:middle
or becomes not visible on
screen due to, let's say,

00:07:53.006 --> 00:07:54.046 A:middle
the user gets a phone call.

00:07:54.126 --> 00:07:56.286 A:middle
And then of course,
you'll get didBecomeActive

00:07:56.286 --> 00:07:57.906 A:middle
when you are now visible again.

00:07:58.366 --> 00:07:59.996 A:middle
It's important to
use the pair of these

00:07:59.996 --> 00:08:02.946 A:middle
to pause any animations,
UI updating timers


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.996 --> 00:08:02.946 A:middle
to pause any animations,
UI updating timers

00:08:02.946 --> 00:08:06.096 A:middle
that might be firing and make
sure your app gets as quiesced

00:08:06.096 --> 00:08:08.456 A:middle
and energy efficient
as possible,

00:08:08.456 --> 00:08:10.556 A:middle
because the user can't see any

00:08:10.556 --> 00:08:11.886 A:middle
of the work you're
doing to update the UI.

00:08:12.596 --> 00:08:15.896 A:middle
You can also listen to
the UIApplicationWill

00:08:15.896 --> 00:08:18.616 A:middle
ResignActiveNotification as well
in other parts of your code.

00:08:19.046 --> 00:08:24.466 A:middle
Now, in OS X, it's similar,
same application didResignActive

00:08:24.466 --> 00:08:26.626 A:middle
and becomeActive on your
NSApplication Delegate.

00:08:28.286 --> 00:08:30.506 A:middle
But OS X makes things a
little more complicated

00:08:30.506 --> 00:08:32.616 A:middle
because there are multiple
applications on the screen.

00:08:33.986 --> 00:08:35.476 A:middle
And so, on OS X, we
have something called

00:08:35.476 --> 00:08:36.676 A:middle
Occlusion Notifications.

00:08:36.676 --> 00:08:39.275 A:middle
So, this is a new feature
that was new in OS X Mavericks

00:08:39.515 --> 00:08:41.746 A:middle
and it lets you determine
the visibility

00:08:41.746 --> 00:08:43.836 A:middle
of a particular window
or application.

00:08:45.016 --> 00:08:48.326 A:middle
For application, you have the
delegate method application

00:08:48.326 --> 00:08:49.446 A:middle
DidChangeOcclusionState.

00:08:50.356 --> 00:08:51.726 A:middle
And for a window, you can check,

00:08:51.726 --> 00:08:53.736 A:middle
get
windowDidChangeOcclusionState

00:08:53.736 --> 00:08:55.076 A:middle
to know when a particular window

00:08:55.076 --> 00:08:57.296 A:middle
or the whole application
becomes visible

00:08:57.296 --> 00:08:58.506 A:middle
or becomes fully occluded.

00:08:58.966 --> 00:09:04.316 A:middle
And with the use of these and
the applicationDidBecomeActive


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.966 --> 00:09:04.316 A:middle
And with the use of these and
the applicationDidBecomeActive

00:09:04.316 --> 00:09:06.406 A:middle
and resignActive,
which changes based

00:09:06.406 --> 00:09:08.406 A:middle
on what the frontmost
app on the system is.

00:09:08.456 --> 00:09:11.196 A:middle
So, you are active on OS X when
you're in the menu at the top

00:09:11.196 --> 00:09:12.996 A:middle
of the screen and
you resignActive

00:09:12.996 --> 00:09:14.536 A:middle
when another app
becomes frontmost.

00:09:14.536 --> 00:09:16.586 A:middle
So, between that and
occlusion notifications,

00:09:16.586 --> 00:09:18.886 A:middle
you can determine the full
state of your app on the system

00:09:19.146 --> 00:09:20.056 A:middle
and make smart decisions

00:09:20.056 --> 00:09:21.676 A:middle
about whether it's
appropriate to do work.

00:09:22.146 --> 00:09:23.696 A:middle
And some of you might want

00:09:23.696 --> 00:09:25.996 A:middle
to know how App Nap
factors into all this.

00:09:25.996 --> 00:09:28.526 A:middle
So, App Nap is the feature
reintroduced in OS X Mavericks

00:09:28.886 --> 00:09:31.566 A:middle
that can reduce an inactive
application's energy use

00:09:31.726 --> 00:09:33.146 A:middle
by constraining its resources.

00:09:33.896 --> 00:09:36.826 A:middle
But, the problem is that App
Nap relies on heuristics.

00:09:36.826 --> 00:09:39.816 A:middle
We have to make guesses
as to whether a user cares

00:09:39.816 --> 00:09:42.106 A:middle
about a particular application
at a particular time.

00:09:42.536 --> 00:09:46.286 A:middle
And so, there are cases where
we cannot put an app in App Nap,

00:09:46.286 --> 00:09:49.336 A:middle
because we're not certain
the app isn't in use.

00:09:49.656 --> 00:09:52.336 A:middle
But as a developer, you are the
authoritative source for this.

00:09:52.666 --> 00:09:54.236 A:middle
Once you've taken
into account things

00:09:54.236 --> 00:09:55.466 A:middle
like occlusion notifications,

00:09:55.466 --> 00:09:57.826 A:middle
you know whether a particular
piece of work is necessary.

00:09:58.576 --> 00:10:00.966 A:middle
And so, ultimately,
in a well-behaved app,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.576 --> 00:10:00.966 A:middle
And so, ultimately,
in a well-behaved app,

00:10:00.966 --> 00:10:02.706 A:middle
App Nap should never
have an effect.

00:10:03.136 --> 00:10:05.526 A:middle
If the user isn't using the app,
you shouldn't be doing any work.

00:10:05.846 --> 00:10:08.646 A:middle
And if you are doing work
on behalf of the user,

00:10:09.096 --> 00:10:11.606 A:middle
you should be using
the NSProcessInfo

00:10:11.686 --> 00:10:15.006 A:middle
PerformActivityWithOptions
API to let the system know

00:10:15.006 --> 00:10:17.206 A:middle
that you're doing work and
now is not an appropriate time

00:10:17.526 --> 00:10:18.096 A:middle
to nap you.

00:10:18.786 --> 00:10:20.946 A:middle
So, ultimately, App
Nap is a fallback

00:10:20.946 --> 00:10:23.016 A:middle
and in a well-behaved
application you really shouldn't

00:10:23.016 --> 00:10:25.366 A:middle
have any effects from App Nap.

00:10:27.516 --> 00:10:30.046 A:middle
So, remember, try to
avoid unnecessary work.

00:10:30.256 --> 00:10:32.126 A:middle
Monitor the app, your
application's state to know

00:10:32.126 --> 00:10:32.936 A:middle
when it's not visible.

00:10:33.336 --> 00:10:36.296 A:middle
Avoid updating the UI until
the user can see the results

00:10:36.516 --> 00:10:39.806 A:middle
and make sure to be efficient in
napping yourself when not in use

00:10:39.806 --> 00:10:41.406 A:middle
so App Nap doesn't
have to take effect.

00:10:41.876 --> 00:10:46.816 A:middle
So, with that, let's talk about
doing it at a better time.

00:10:47.186 --> 00:10:49.976 A:middle
So, user devices have lots
of different power states.

00:10:49.976 --> 00:10:51.026 A:middle
Sometimes, they're plugged in.

00:10:51.026 --> 00:10:52.026 A:middle
Sometimes, they're on battery.

00:10:52.916 --> 00:10:54.706 A:middle
And when you do work, in effect,

00:10:55.366 --> 00:10:57.686 A:middle
what the user's overall
experience over a long period

00:10:57.686 --> 00:10:59.526 A:middle
of time is with respect
to their battery life.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:00.576 --> 00:11:03.966 A:middle
So, if we imagine here,
your typical user day, oh,

00:11:03.966 --> 00:11:06.676 A:middle
maybe not typical, but
the user forgets to plug

00:11:06.676 --> 00:11:08.636 A:middle
in their device overnight,
they get a little bit of charge

00:11:08.636 --> 00:11:11.166 A:middle
in the morning and then
they have this big window

00:11:11.166 --> 00:11:13.386 A:middle
until noon before they can
plug in their device again.

00:11:13.846 --> 00:11:15.396 A:middle
And our goal here is
obviously to make it

00:11:15.396 --> 00:11:16.826 A:middle
so the user never
runs out of battery.

00:11:17.096 --> 00:11:18.386 A:middle
So, let's take a
look at what happens.

00:11:19.496 --> 00:11:21.996 A:middle
We start out, user is doing OK.

00:11:21.996 --> 00:11:23.226 A:middle
They get a little
charge in the morning.

00:11:23.476 --> 00:11:25.206 A:middle
And now, they're
sitting around at 10 a.m.

00:11:25.336 --> 00:11:26.496 A:middle
and they run your application.

00:11:27.996 --> 00:11:29.956 A:middle
Well, your application
decides it wants

00:11:29.956 --> 00:11:31.676 A:middle
to do something very
power intensive,

00:11:31.726 --> 00:11:33.786 A:middle
wants to download new
content, do some update,

00:11:34.186 --> 00:11:35.576 A:middle
and that uses a lot of energy.

00:11:36.576 --> 00:11:39.076 A:middle
Well, now, we've dramatically
reduced the user's battery life

00:11:39.146 --> 00:11:39.816 A:middle
and they're going to run

00:11:39.816 --> 00:11:41.586 A:middle
out of energy before they
have a chance to plug in.

00:11:41.736 --> 00:11:44.736 A:middle
And the user is now very sad,
we're sad, everyone is sad,

00:11:44.736 --> 00:11:45.956 A:middle
this isn't a good experience.

00:11:46.566 --> 00:11:48.936 A:middle
But what if instead of
running that work immediately,

00:11:49.436 --> 00:11:51.396 A:middle
you knew this just needs
to happen sometimes soon.

00:11:51.396 --> 00:11:52.866 A:middle
It doesn't need to
happen right now.

00:11:52.866 --> 00:11:54.326 A:middle
And you were to tell the system,

00:11:54.326 --> 00:11:56.356 A:middle
please let me know
when a good time is.

00:11:56.766 --> 00:11:58.406 A:middle
Give the system a
window to schedule in

00:11:59.326 --> 00:12:02.386 A:middle
and then let the system
automatically move


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.326 --> 00:12:02.386 A:middle
and then let the system
automatically move

00:12:02.386 --> 00:12:04.706 A:middle
that work out to a better time.

00:12:05.426 --> 00:12:09.626 A:middle
And now, rather than running out
of battery, our user makes it

00:12:09.626 --> 00:12:10.886 A:middle
to a time when they can plug in.

00:12:11.256 --> 00:12:11.896 A:middle
They're happy.

00:12:12.226 --> 00:12:14.816 A:middle
Your app isn't blamed for
causing their poor battery life,

00:12:15.556 --> 00:12:18.256 A:middle
and we have a general
improvement in user experience.

00:12:19.646 --> 00:12:24.316 A:middle
So, on OS X Yosemite, we have
a new foundation API called

00:12:24.356 --> 00:12:27.896 A:middle
NSBackgroundActivityScheduler
that you can use

00:12:27.896 --> 00:12:29.246 A:middle
to accomplish exactly this.

00:12:29.616 --> 00:12:32.006 A:middle
It allows you to
schedule an arbitrary task

00:12:32.006 --> 00:12:33.336 A:middle
for some good time
in the future.

00:12:34.186 --> 00:12:36.776 A:middle
It supports repeating or
non-repeating activities.

00:12:36.776 --> 00:12:39.526 A:middle
So, it's great for any periodic
updating you might need to do.

00:12:39.526 --> 00:12:42.476 A:middle
And you can use it
to schedule things

00:12:42.476 --> 00:12:45.956 A:middle
like periodic content
fetches, update installs,

00:12:45.956 --> 00:12:47.906 A:middle
garbage collection or
data maintenance tasks,

00:12:48.186 --> 00:12:50.346 A:middle
automatic saves or
backups-really anything you do

00:12:50.346 --> 00:12:52.086 A:middle
in the background that
doesn't need to happen

00:12:52.086 --> 00:12:54.136 A:middle
at a particular time,
you can sort of do

00:12:54.136 --> 00:12:55.836 A:middle
when the system conditions
are right.

00:12:56.896 --> 00:12:58.756 A:middle
So, let's take a look
at how to use this API.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:00.146 --> 00:13:01.516 A:middle
The first thing you'll
do is create an

00:13:01.516 --> 00:13:03.336 A:middle
NSBackgroundActivityScheduler
object.

00:13:03.556 --> 00:13:05.396 A:middle
And you'll use the
initWithIdentifier method

00:13:05.876 --> 00:13:08.616 A:middle
to pass in an identifier for
that particular activity.

00:13:09.326 --> 00:13:11.536 A:middle
This is something that you
should put in reverse-DNS style

00:13:11.896 --> 00:13:13.936 A:middle
and use it to identify the
particular action you're

00:13:13.936 --> 00:13:14.826 A:middle
doing uniquely.

00:13:15.096 --> 00:13:17.696 A:middle
But you also want to try
to reuse these identifiers

00:13:17.696 --> 00:13:21.336 A:middle
over multiple invocations
of that activity or launches

00:13:21.336 --> 00:13:24.586 A:middle
of your app because the system
will use identifiers as a way

00:13:24.586 --> 00:13:26.266 A:middle
to learn about the
activity you're doing

00:13:26.266 --> 00:13:27.846 A:middle
and make better scheduling
decisions.

00:13:28.866 --> 00:13:31.196 A:middle
So, once you've created
a scheduler,

00:13:31.196 --> 00:13:33.156 A:middle
you can now specify
scheduling properties.

00:13:33.526 --> 00:13:36.006 A:middle
So, and let's say we want
to have something fire

00:13:36.006 --> 00:13:37.106 A:middle
in the next 10 minutes.

00:13:37.306 --> 00:13:40.576 A:middle
What we can do is specify the
tolerance to be 600 seconds.

00:13:40.976 --> 00:13:43.406 A:middle
And then, when we
run the activity,

00:13:43.446 --> 00:13:46.016 A:middle
we'll try to schedule it within
that 10-minute tolerance period.

00:13:46.556 --> 00:13:49.096 A:middle
On the other hand, if we
want to schedule something

00:13:49.096 --> 00:13:52.306 A:middle
out for the future, let's say
we want it to happen between 15

00:13:52.306 --> 00:13:55.596 A:middle
and 45 minutes from now,
we can specify an interval

00:13:55.996 --> 00:13:58.726 A:middle
of 30 minutes and a
tolerance of 15 minutes.

00:13:59.246 --> 00:14:01.196 A:middle
And what this means is
that we want this work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.246 --> 00:14:01.196 A:middle
And what this means is
that we want this work

00:14:01.196 --> 00:14:04.596 A:middle
to happen 30 minutes plus or
minus 15 minutes in the future.

00:14:05.646 --> 00:14:08.646 A:middle
And finally, if we want
the activity to repeat,

00:14:09.046 --> 00:14:11.276 A:middle
let's say we want to check
for new content every hour,

00:14:11.786 --> 00:14:15.466 A:middle
you can set repeats equals YES
and then interval to 60 minutes.

00:14:15.666 --> 00:14:18.416 A:middle
And now, we'll try to have the
activity run once each hour.

00:14:18.806 --> 00:14:21.256 A:middle
It's actually once each hour
in the sense that if you were

00:14:21.256 --> 00:14:23.686 A:middle
to break up time into one-hour
periods, we'll make sure

00:14:23.686 --> 00:14:25.516 A:middle
to run it once in each period.

00:14:25.516 --> 00:14:27.746 A:middle
So, your average time
will be once every hour.

00:14:27.746 --> 00:14:30.796 A:middle
But within a period, it
might happen sooner or later.

00:14:31.246 --> 00:14:32.016 A:middle
But the benefit of this is

00:14:32.016 --> 00:14:33.876 A:middle
that you won't experience
drift over time.

00:14:34.216 --> 00:14:34.546 A:middle
All right.

00:14:35.576 --> 00:14:38.246 A:middle
So, once you've specified
scheduling properties,

00:14:38.246 --> 00:14:39.976 A:middle
now it's time to actually go
ahead and schedule the work.

00:14:40.376 --> 00:14:41.286 A:middle
This is pretty simple.

00:14:41.886 --> 00:14:44.166 A:middle
You'll call the
scheduleWithBlock method

00:14:44.296 --> 00:14:45.326 A:middle
on the activity object.

00:14:45.846 --> 00:14:48.296 A:middle
And you'll pass in a block that
takes a completion handler.

00:14:48.366 --> 00:14:51.336 A:middle
In that block, you can do
whatever work you might need

00:14:51.336 --> 00:14:54.336 A:middle
to do and it's perfectly OK
to do that work asynchronously

00:14:54.336 --> 00:14:55.716 A:middle
and save off the
completion handler.

00:14:56.186 --> 00:14:57.116 A:middle
But then when you're done,

00:14:57.436 --> 00:14:58.656 A:middle
you'll call the completion
handler

00:14:58.656 --> 00:15:00.046 A:middle
with NSBackgroundActivity


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.656 --> 00:15:00.046 A:middle
with NSBackgroundActivity

00:15:00.046 --> 00:15:02.406 A:middle
ResultFinished to
indicate that to the system

00:15:02.406 --> 00:15:05.546 A:middle
that now this activity is done,
you've completed the work.

00:15:06.046 --> 00:15:10.146 A:middle
Of course, if the work is really
long running, maybe, you know,

00:15:10.146 --> 00:15:13.066 A:middle
multiple minutes, it's possible
the system power state will

00:15:13.176 --> 00:15:15.746 A:middle
change during the
execution of that work.

00:15:16.056 --> 00:15:18.786 A:middle
In this case, you want to
give the system the ability

00:15:18.786 --> 00:15:21.606 A:middle
to tell you to pause and
later resume that work.

00:15:22.006 --> 00:15:25.246 A:middle
And you can do this by checking
the shouldDefer property

00:15:25.246 --> 00:15:25.906 A:middle
of the activity.

00:15:26.346 --> 00:15:27.346 A:middle
This returns YES.

00:15:27.646 --> 00:15:30.016 A:middle
The state of the system has
changed and we would like you

00:15:30.016 --> 00:15:32.526 A:middle
to defer the remaining
work until a better time.

00:15:32.786 --> 00:15:34.266 A:middle
So, you can check that property

00:15:34.636 --> 00:15:36.146 A:middle
and then call the
completion handler

00:15:36.146 --> 00:15:37.636 A:middle
with NSBackgroundActivity

00:15:37.636 --> 00:15:40.586 A:middle
ResultDeferred to indicate
to the system that it should,

00:15:40.976 --> 00:15:42.296 A:middle
that you're going
to pause the work

00:15:42.296 --> 00:15:43.776 A:middle
and that it should
call you back later.

00:15:45.326 --> 00:15:47.956 A:middle
We're using the same scheduling
parameters as you started with.

00:15:48.606 --> 00:15:52.416 A:middle
So, that's
NSBackgroundActivityScheduler.

00:15:52.886 --> 00:15:55.386 A:middle
You specify the scheduling
requirements for the work.

00:15:55.966 --> 00:15:58.096 A:middle
The system selects the best
time to perform that work.

00:15:58.976 --> 00:16:01.696 A:middle
We have support for
repeating tasks without drift,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.976 --> 00:16:01.696 A:middle
We have support for
repeating tasks without drift,

00:16:02.086 --> 00:16:05.736 A:middle
and it's available in OS
X Yosemite, or if you want

00:16:05.886 --> 00:16:07.836 A:middle
to use a C API, it was available

00:16:07.896 --> 00:16:10.926 A:middle
as XPC activity in
10.9 Mavericks.

00:16:11.496 --> 00:16:14.996 A:middle
Now, this works really
well for CPU or I/O or kind

00:16:14.996 --> 00:16:16.746 A:middle
of other local intensive tasks.

00:16:17.256 --> 00:16:20.976 A:middle
But if you want to do large
transfers to or from a server

00:16:20.976 --> 00:16:23.176 A:middle
on the network, we actually
have an even better solution

00:16:23.176 --> 00:16:25.556 A:middle
and that comes in the
form of the NSURLSession

00:16:25.826 --> 00:16:27.056 A:middle
with the Background Session.

00:16:28.336 --> 00:16:30.116 A:middle
So, let's imagine we
have an application,

00:16:30.706 --> 00:16:32.296 A:middle
and your app has a number

00:16:32.296 --> 00:16:34.626 A:middle
of NSURLRequests it
would like to issue.

00:16:35.656 --> 00:16:37.586 A:middle
What the Background Session
lets you do is create an

00:16:37.586 --> 00:16:41.836 A:middle
NSURLSession, pass it
those NSURLRequests.

00:16:42.296 --> 00:16:44.586 A:middle
But then, instead of
creating in-process tasks,

00:16:44.896 --> 00:16:46.956 A:middle
those go out of process
to a system daemon

00:16:47.356 --> 00:16:49.316 A:middle
that can then handle
executing those tasks for you.

00:16:49.726 --> 00:16:51.586 A:middle
And if your app sticks around,

00:16:51.586 --> 00:16:53.946 A:middle
then you'll get delegate methods
called on your delegate just

00:16:53.946 --> 00:16:55.846 A:middle
like you normally would
with NSURLSession.

00:16:56.366 --> 00:17:00.086 A:middle
But the really cool thing is
if your app happens to go away,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:56.366 --> 00:17:00.086 A:middle
But the really cool thing is
if your app happens to go away,

00:17:00.556 --> 00:17:03.506 A:middle
let's say the user quits it,
maybe the system reboots,

00:17:04.056 --> 00:17:07.156 A:middle
those tasks will stick around
in that out-of-process session

00:17:07.665 --> 00:17:10.445 A:middle
and get processed while
your app isn't running.

00:17:11.016 --> 00:17:13.006 A:middle
So, that means if you need to
do, you know, many hundreds

00:17:13.006 --> 00:17:15.596 A:middle
of megabyte download, your app
doesn't have to stay running

00:17:15.596 --> 00:17:16.656 A:middle
for that download to continue.

00:17:17.566 --> 00:17:19.336 A:middle
Then, when your app
gets relaunched,

00:17:20.136 --> 00:17:23.195 A:middle
you'll use the same
backgroundSession

00:17:23.195 --> 00:17:26.346 A:middle
ConfigurationWithIdentifier
call and make sure you pass

00:17:26.346 --> 00:17:27.925 A:middle
in the same identifier
as before,

00:17:28.236 --> 00:17:30.556 A:middle
and you'll get reconnected
with that existing session

00:17:30.826 --> 00:17:33.906 A:middle
and then get your delegate
methods called for those tasks

00:17:34.236 --> 00:17:35.766 A:middle
for whatever progress
has happened

00:17:35.766 --> 00:17:37.446 A:middle
on those tasks while
your app isn't running.

00:17:38.316 --> 00:17:41.536 A:middle
This is already great
features in an iOS.

00:17:41.706 --> 00:17:44.596 A:middle
It supports multitasking, so
your app can get re-awoken

00:17:44.596 --> 00:17:46.256 A:middle
to receive these
delegate methods.

00:17:46.726 --> 00:17:50.366 A:middle
But the really cool part
for power comes into play

00:17:50.366 --> 00:17:53.286 A:middle
when we talk about the
concepts of discretionary tasks.

00:17:54.086 --> 00:17:55.306 A:middle
So, there's a configuration

00:17:55.586 --> 00:17:57.856 A:middle
on the NSURLSession
configuration object.

00:17:58.226 --> 00:18:00.186 A:middle
You can set the discretionary
property to TRUE.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.226 --> 00:18:00.186 A:middle
You can set the discretionary
property to TRUE.

00:18:00.496 --> 00:18:03.496 A:middle
And it's something
that's available in iOS 7

00:18:03.496 --> 00:18:04.976 A:middle
or now in OS X Yosemite.

00:18:05.676 --> 00:18:08.666 A:middle
And what this tells the system
to do is to pick the best time

00:18:08.666 --> 00:18:11.076 A:middle
to do the work based on
a variety of factors,

00:18:11.186 --> 00:18:14.686 A:middle
including system power state,
network state and more.

00:18:14.846 --> 00:18:18.316 A:middle
And it will automatically
provide things

00:18:18.316 --> 00:18:20.456 A:middle
like bandwidth monitoring
and automatic retry.

00:18:20.596 --> 00:18:22.376 A:middle
So, bandwidth monitoring
is important

00:18:22.376 --> 00:18:24.836 A:middle
because it's very energy
inefficient to do work

00:18:24.836 --> 00:18:26.546 A:middle
over super-slow connections.

00:18:26.756 --> 00:18:28.856 A:middle
And so, when you're using
the Background Session

00:18:28.856 --> 00:18:32.456 A:middle
with a discretionary task, we'll
monitor the effective bandwidth.

00:18:32.456 --> 00:18:35.156 A:middle
And if it falls below certain
levels, automatically stop

00:18:35.156 --> 00:18:36.646 A:middle
and later retry that task

00:18:36.646 --> 00:18:38.556 A:middle
to make sure we can download
it quickly and efficiently.

00:18:39.246 --> 00:18:41.906 A:middle
We can also, because of
this, do automatic retry.

00:18:42.216 --> 00:18:43.636 A:middle
So, if the network
gets disconnected,

00:18:43.926 --> 00:18:45.846 A:middle
we'll then automatically
retry the task later

00:18:45.846 --> 00:18:48.616 A:middle
when the network becomes
available, handling a variety

00:18:48.646 --> 00:18:51.886 A:middle
of edge cases in uploads and
downloads automatically for you.

00:18:53.386 --> 00:18:56.516 A:middle
Now, you can adjust this way
we schedule discretionary tasks

00:18:56.636 --> 00:18:58.756 A:middle
by changing the
timeoutIntervalForResource

00:18:58.756 --> 00:19:00.496 A:middle
property on the configuration
object.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.756 --> 00:19:00.496 A:middle
property on the configuration
object.

00:19:00.856 --> 00:19:02.726 A:middle
So, in this case, we
specified one day.

00:19:02.726 --> 00:19:05.646 A:middle
So then, we want this to happen
sometime within 24 hours.

00:19:06.206 --> 00:19:09.336 A:middle
Now, if this timeout elapses,
you'll get an error thrown.

00:19:09.676 --> 00:19:11.556 A:middle
So, generally, you want to
make sure this is long enough

00:19:11.556 --> 00:19:13.366 A:middle
that we can reasonably
do the download,

00:19:13.886 --> 00:19:16.056 A:middle
taking into account the fact
there might not always be

00:19:16.056 --> 00:19:17.436 A:middle
appropriate networking
available.

00:19:18.206 --> 00:19:20.826 A:middle
It's why anything less than
12 hours is probably going

00:19:20.826 --> 00:19:22.446 A:middle
to put stress in
the system's ability

00:19:22.446 --> 00:19:23.706 A:middle
to effectively do the work.

00:19:24.786 --> 00:19:28.096 A:middle
This was a very high level
overview to NSURLSession,

00:19:28.096 --> 00:19:30.616 A:middle
just enough to kind
of whet your appetite.

00:19:30.616 --> 00:19:33.396 A:middle
If you want to learn more,
check out yesterday's What's New

00:19:33.396 --> 00:19:35.676 A:middle
in Foundation Networking
talk, where they go

00:19:35.676 --> 00:19:36.566 A:middle
into much more detail

00:19:36.566 --> 00:19:38.766 A:middle
on the Background
Session and how to use it.

00:19:40.356 --> 00:19:42.756 A:middle
So that was Do It
at a Better Time.

00:19:42.756 --> 00:19:45.346 A:middle
We talked about how you can let
the system schedule your work

00:19:45.346 --> 00:19:46.716 A:middle
for power optimum execution.

00:19:47.086 --> 00:19:48.566 A:middle
But let's say you're
already executing,

00:19:49.086 --> 00:19:50.286 A:middle
maybe at the better time.

00:19:51.106 --> 00:19:52.376 A:middle
I want to talk now about ways

00:19:52.376 --> 00:19:54.076 A:middle
that you can do your
work more efficiently.

00:19:55.316 --> 00:19:58.036 A:middle
So, our system has a variety of
resource management properties.

00:19:58.426 --> 00:20:00.726 A:middle
Some of these affect the
responsiveness of the system


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.426 --> 00:20:00.726 A:middle
Some of these affect the
responsiveness of the system

00:20:00.726 --> 00:20:01.976 A:middle
when a particular
task is going on.

00:20:02.656 --> 00:20:05.566 A:middle
This includes things like
the CPU Scheduler Priority

00:20:05.646 --> 00:20:08.126 A:middle
and the I/O Priority
for a particular task.

00:20:08.376 --> 00:20:11.446 A:middle
We also have properties that
affect the efficiency of work.

00:20:11.826 --> 00:20:13.876 A:middle
This includes the amount of
time we're coalescing or willing

00:20:13.876 --> 00:20:17.046 A:middle
to apply, or hence, as to
whether we should run the CPU

00:20:17.046 --> 00:20:20.236 A:middle
in a throughput or
efficiency-oriented mode.

00:20:21.316 --> 00:20:23.456 A:middle
Now, these properties
are very difficult

00:20:23.456 --> 00:20:25.136 A:middle
to specify individually.

00:20:25.226 --> 00:20:26.956 A:middle
It's complicated
to get it right.

00:20:27.276 --> 00:20:29.976 A:middle
And so, most developers are
simply left the whens they could

00:20:29.976 --> 00:20:31.556 A:middle
get by using these
properties on the table.

00:20:32.226 --> 00:20:34.096 A:middle
So, we want to make
this easy to be able

00:20:34.096 --> 00:20:37.016 A:middle
to use the correct values
for all these properties.

00:20:37.406 --> 00:20:39.366 A:middle
And in OS X Yosemite and iOS 8,

00:20:39.786 --> 00:20:41.326 A:middle
we're introducing
something called Quality

00:20:41.326 --> 00:20:43.726 A:middle
of Service Classes that
can help you do this.

00:20:44.316 --> 00:20:46.026 A:middle
So, there are four Quality

00:20:46.026 --> 00:20:47.716 A:middle
of Service Classes we have
defined on the system.

00:20:48.276 --> 00:20:50.306 A:middle
The first is User
Interactive, which indicates

00:20:50.306 --> 00:20:51.736 A:middle
that this work is involved

00:20:51.736 --> 00:20:53.836 A:middle
in creating a smooth,
buttery user UI.

00:20:54.366 --> 00:20:56.676 A:middle
It's these things like the
main thread, animations,

00:20:56.846 --> 00:20:59.386 A:middle
event processing, whether
that's touch events or meeting

00:20:59.386 --> 00:21:02.176 A:middle
or some other kind
of event processing


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.386 --> 00:21:02.176 A:middle
or some other kind
of event processing

00:21:02.176 --> 00:21:04.516 A:middle
where we need very,
very short latencies.

00:21:05.366 --> 00:21:08.836 A:middle
User Initiated is
for doing request,

00:21:08.836 --> 00:21:11.426 A:middle
making servicing requests
that the user has made in ways

00:21:11.426 --> 00:21:14.446 A:middle
that we need to provide
immediate results.

00:21:14.596 --> 00:21:17.086 A:middle
So, these are clicks on an
object to get more information

00:21:17.086 --> 00:21:18.406 A:middle
about it in your user interface.

00:21:18.796 --> 00:21:20.596 A:middle
The task of getting the
details of that object

00:21:20.596 --> 00:21:23.456 A:middle
and populating them onscreen
would fall into User Initiated.

00:21:24.476 --> 00:21:26.736 A:middle
Utility, for longer
running tasks.

00:21:26.736 --> 00:21:29.946 A:middle
So User Initiated and User
Interactive are designed to be

00:21:29.946 --> 00:21:31.836 A:middle
as performant as possible.

00:21:32.456 --> 00:21:35.216 A:middle
Utility, we try to achieve a
good balance between throughput

00:21:35.216 --> 00:21:36.116 A:middle
and energy efficiency.

00:21:36.306 --> 00:21:38.116 A:middle
So, we want to put
longer-running tasks

00:21:38.456 --> 00:21:42.306 A:middle
where we don't want to
have an over, we don't want

00:21:43.286 --> 00:21:45.416 A:middle
to put a large power
drain on the system.

00:21:45.946 --> 00:21:47.526 A:middle
And then Background, for things

00:21:47.526 --> 00:21:49.146 A:middle
that are not visible
to the user.

00:21:49.986 --> 00:21:52.086 A:middle
So, with all these
classes, how do you pick?

00:21:52.186 --> 00:21:55.486 A:middle
So, the question you
want to ask yourself,

00:21:55.486 --> 00:21:58.396 A:middle
or User Interactive is, Is
this work actively involved

00:21:58.396 --> 00:21:59.156 A:middle
in updating the UI?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.106 --> 00:22:02.796 A:middle
If this doesn't happen, will
the UI appear to be frozen?

00:22:03.416 --> 00:22:05.106 A:middle
This includes things
like the main thread,

00:22:05.106 --> 00:22:08.036 A:middle
which we handle automatically
for you, animations

00:22:08.036 --> 00:22:09.736 A:middle
or input event processing.

00:22:10.616 --> 00:22:12.536 A:middle
If the answer is no,
then you want to think

00:22:12.536 --> 00:22:14.436 A:middle
about User Initiated and
ask yourself the question,

00:22:14.676 --> 00:22:17.526 A:middle
Is this work required to
continue user interaction?

00:22:18.296 --> 00:22:20.686 A:middle
So, for example, is
this actively involved

00:22:20.686 --> 00:22:22.176 A:middle
in loading content
that the user needs

00:22:22.176 --> 00:22:25.636 A:middle
to see before they can make
the next user interaction

00:22:25.636 --> 00:22:26.466 A:middle
in your application?

00:22:27.686 --> 00:22:29.186 A:middle
If this isn't the
case, for example,

00:22:29.186 --> 00:22:31.936 A:middle
the user initiates a task
and it's long running

00:22:31.936 --> 00:22:33.076 A:middle
and displays a progress bar.

00:22:33.416 --> 00:22:35.266 A:middle
So, either they can
continue interacting

00:22:35.266 --> 00:22:37.066 A:middle
with your application
or you might expect them

00:22:37.066 --> 00:22:40.806 A:middle
to take a break or go switch
to another app on OS X.

00:22:40.806 --> 00:22:42.916 A:middle
You want to think about Utility.

00:22:42.976 --> 00:22:45.156 A:middle
In which case, the question
you can ask yourself is,

00:22:45.926 --> 00:22:47.966 A:middle
Is the user aware of the
progress of this work?

00:22:48.436 --> 00:22:50.656 A:middle
If it's a longer-running job
with a progress indicator,

00:22:50.656 --> 00:22:52.416 A:middle
that's perfectly
suited to Utility.

00:22:53.496 --> 00:22:55.606 A:middle
And then finally,
for Background,

00:22:56.106 --> 00:22:56.966 A:middle
that's the remaining work

00:22:56.966 --> 00:22:58.746 A:middle
that the user isn't
aware of the progress of.

00:22:59.006 --> 00:23:00.706 A:middle
And for Background work,
you want to ask yourself,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.006 --> 00:23:00.706 A:middle
And for Background work,
you want to ask yourself,

00:23:00.996 --> 00:23:03.896 A:middle
Can this work be
deferred to a better time?

00:23:04.346 --> 00:23:07.016 A:middle
If so, use the
NSBackgroundActivityScheduler

00:23:07.016 --> 00:23:09.206 A:middle
object in addition to
running in Background.

00:23:10.506 --> 00:23:13.186 A:middle
So, let's say you've gone
through, you've thought

00:23:13.186 --> 00:23:15.586 A:middle
about a piece of work in your
application and you decide

00:23:15.586 --> 00:23:18.066 A:middle
that User Initiated is
probably the right Quality

00:23:18.066 --> 00:23:18.926 A:middle
of Service Class.

00:23:19.386 --> 00:23:21.516 A:middle
Well, the next thing you want

00:23:21.516 --> 00:23:23.166 A:middle
to do is ask yourself
a few more questions.

00:23:23.566 --> 00:23:27.396 A:middle
The first is, Is it OK if User
Interactive work happens before

00:23:28.016 --> 00:23:29.076 A:middle
my User Initiated work?

00:23:30.126 --> 00:23:31.986 A:middle
Is it OK for this
work to compete

00:23:31.986 --> 00:23:33.336 A:middle
with other User Initiated work?

00:23:34.086 --> 00:23:36.546 A:middle
And is it OK for my
work to take precedence

00:23:36.546 --> 00:23:38.196 A:middle
over Utility and
Background work?

00:23:38.866 --> 00:23:41.476 A:middle
Ultimately, these Quality of
Service Classes form a hierarchy

00:23:41.906 --> 00:23:44.736 A:middle
and the system will prefer
things higher up in this list.

00:23:44.736 --> 00:23:47.246 A:middle
So, you want to make sure
that within your application,

00:23:47.656 --> 00:23:49.556 A:middle
you've picked a set of
Quality of Service Classes

00:23:49.816 --> 00:23:51.736 A:middle
that let the system
appropriately prioritize

00:23:51.736 --> 00:23:55.316 A:middle
resources, which brings
us to what exactly happens

00:23:55.316 --> 00:23:57.116 A:middle
when you specify a
Quality of Service Class.

00:23:57.116 --> 00:23:59.986 A:middle
So, let's imagine we
have a Background Quality

00:23:59.986 --> 00:24:03.226 A:middle
of Service operation running,
and it's using a lot of CPU


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.986 --> 00:24:03.226 A:middle
of Service operation running,
and it's using a lot of CPU

00:24:03.226 --> 00:24:05.386 A:middle
and has a lot of I/O going on.

00:24:06.006 --> 00:24:08.736 A:middle
And then, a User
Initiated task comes around.

00:24:09.706 --> 00:24:11.626 A:middle
Well, what the system is
going to do is it's going

00:24:11.626 --> 00:24:15.006 A:middle
to prioritize resources to
the User Initiated task,

00:24:15.496 --> 00:24:18.126 A:middle
letting that get the majority
of the throughput on the system

00:24:18.376 --> 00:24:20.086 A:middle
and letting that
work happen quickly.

00:24:21.936 --> 00:24:26.656 A:middle
Similarly, if we were to look at
power graphs for User Initiated

00:24:26.656 --> 00:24:29.806 A:middle
and Background work, in User
Initiated, we run the work

00:24:29.806 --> 00:24:32.156 A:middle
as quickly as possible,
but potentially

00:24:32.156 --> 00:24:33.576 A:middle
in power-inefficient ways.

00:24:34.116 --> 00:24:36.896 A:middle
Whereas, for Background work,
we will try to run the system

00:24:36.896 --> 00:24:38.306 A:middle
in power-efficient ways.

00:24:38.346 --> 00:24:39.916 A:middle
It might take slightly longer,

00:24:40.366 --> 00:24:42.726 A:middle
but your overall energy
consumption will be reduced.

00:24:43.656 --> 00:24:46.526 A:middle
And, of course, Utility falls
on the middle of the spectrum.

00:24:47.016 --> 00:24:48.066 A:middle
And so in this way,

00:24:48.236 --> 00:24:50.346 A:middle
by appropriately
classifying your Utility

00:24:50.346 --> 00:24:53.426 A:middle
and Background work, you can
both improve the responsiveness

00:24:53.786 --> 00:24:55.816 A:middle
of User Initiated and
User Interactive work

00:24:56.176 --> 00:24:58.286 A:middle
and improve your overall
energy efficiency.

00:24:59.496 --> 00:25:00.356 A:middle
All right.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.496 --> 00:25:00.356 A:middle
All right.

00:25:00.356 --> 00:25:02.266 A:middle
So, let's take a look at
an example application

00:25:02.266 --> 00:25:05.626 A:middle
and how we might apply
Quality of Service to it.

00:25:05.866 --> 00:25:07.906 A:middle
So, we have PhotoMeister 3000.

00:25:07.906 --> 00:25:09.956 A:middle
It's our kind of generic
photos application.

00:25:10.396 --> 00:25:13.236 A:middle
You connect the camera
containing a bunch of RAW images

00:25:13.556 --> 00:25:15.516 A:middle
and we pull off some
JPEG previews

00:25:15.726 --> 00:25:17.036 A:middle
and display a bunch
of thumbnails.

00:25:17.036 --> 00:25:18.466 A:middle
And then in the background,

00:25:18.676 --> 00:25:20.506 A:middle
load the full-size
images and convert them.

00:25:21.296 --> 00:25:23.026 A:middle
They, of course also
have search functionality

00:25:23.026 --> 00:25:24.816 A:middle
because every app needs
search functionality.

00:25:24.816 --> 00:25:28.096 A:middle
So, how do we apply
Quality of Service?

00:25:28.386 --> 00:25:30.326 A:middle
Well, User Interactive
is just going to be used

00:25:30.326 --> 00:25:32.026 A:middle
for the main thread
in our application.

00:25:32.246 --> 00:25:33.866 A:middle
And that happens automatically

00:25:33.866 --> 00:25:35.546 A:middle
without you having
to do any work.

00:25:37.566 --> 00:25:40.156 A:middle
User Initiated, we're going to
use for thumbnail generation.

00:25:40.156 --> 00:25:43.746 A:middle
And this is because the
user plugs in their camera,

00:25:43.746 --> 00:25:44.666 A:middle
and the next thing they want

00:25:44.666 --> 00:25:46.136 A:middle
to do is start browsing
the thumbnails.

00:25:46.406 --> 00:25:48.596 A:middle
And so, their ability to
make the next interaction

00:25:48.596 --> 00:25:51.326 A:middle
with their application is
dependent upon those thumbnails

00:25:51.326 --> 00:25:51.986 A:middle
being available.

00:25:52.136 --> 00:25:53.916 A:middle
So, it's going to run
at User Initiated.

00:25:53.916 --> 00:25:56.776 A:middle
Now, imagine that the user
is browsing these thumbnails

00:25:56.776 --> 00:25:59.326 A:middle
and they click on one to try
to view the photo full size.

00:25:59.736 --> 00:26:02.126 A:middle
Their next interaction, which
might be looking at the photos,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.736 --> 00:26:02.126 A:middle
Their next interaction, which
might be looking at the photos,

00:26:02.126 --> 00:26:04.196 A:middle
scrolling through it,
depends on the ability

00:26:04.196 --> 00:26:05.566 A:middle
to load that full-size image.

00:26:05.976 --> 00:26:08.486 A:middle
So, we're going to load
just that particular image

00:26:08.486 --> 00:26:09.996 A:middle
in that case at User Initiated.

00:26:11.116 --> 00:26:13.666 A:middle
But all the other images we're
going to load off the camera

00:26:13.666 --> 00:26:15.686 A:middle
and convert should
happen at Utility.

00:26:15.776 --> 00:26:17.876 A:middle
The user might be able to
see the progress of it,

00:26:18.056 --> 00:26:21.486 A:middle
but you want this work to
happen in deference to the work

00:26:21.486 --> 00:26:23.706 A:middle
of updating the UI, scrolling,

00:26:23.706 --> 00:26:25.196 A:middle
displaying the thumbnails
and so on.

00:26:25.726 --> 00:26:28.576 A:middle
And finally, any
work we have to do

00:26:28.576 --> 00:26:30.566 A:middle
to update our search index
would happen at Background.

00:26:31.186 --> 00:26:33.296 A:middle
This isn't something the user
is aware of the progress of.

00:26:33.496 --> 00:26:35.846 A:middle
And so, we want it to happen
in deference to things

00:26:35.846 --> 00:26:37.186 A:middle
like loading the
images off the camera.

00:26:37.846 --> 00:26:42.166 A:middle
So, let's imagine that our
app, we're trying to figure

00:26:42.166 --> 00:26:43.096 A:middle
out how to build this thing.

00:26:43.456 --> 00:26:47.206 A:middle
Let's kind of create a simple
NSOperation-based approach

00:26:47.206 --> 00:26:49.316 A:middle
to writing this application.

00:26:50.086 --> 00:26:53.066 A:middle
We might create an
NSOperationQueue

00:26:53.066 --> 00:26:55.416 A:middle
for thumbnail generation
and create an NSOperation

00:26:55.416 --> 00:26:56.716 A:middle
for each thumbnail
we want to generate.

00:26:57.246 --> 00:27:00.456 A:middle
And we might create another
queue for image conversion


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.246 --> 00:27:00.456 A:middle
And we might create another
queue for image conversion

00:27:00.906 --> 00:27:03.066 A:middle
and an operation for each
image we want to convert.

00:27:04.046 --> 00:27:06.606 A:middle
So, how does this play into QOS?

00:27:07.436 --> 00:27:12.516 A:middle
So, in OS X Yosemite
and iOS 8, NSOperation,

00:27:12.616 --> 00:27:15.606 A:middle
NSOperationQueue now have
a qualityOfService property

00:27:15.836 --> 00:27:17.836 A:middle
that you can use
to set what Quality

00:27:17.836 --> 00:27:19.296 A:middle
of Service particular
work should run at.

00:27:19.896 --> 00:27:22.476 A:middle
So, if we want to run an
NSOperation at Utility,

00:27:22.856 --> 00:27:25.146 A:middle
we can simply say
operation.qualityOfService

00:27:25.146 --> 00:27:27.056 A:middle
equals
NSQualityOfServiceUtility.

00:27:27.496 --> 00:27:31.486 A:middle
If you set a Quality of
Service on both an operation

00:27:31.606 --> 00:27:33.956 A:middle
and the queue, we'll use
the higher of the two.

00:27:35.106 --> 00:27:37.776 A:middle
And if you don't set
NSOperation, for example,

00:27:37.776 --> 00:27:39.976 A:middle
in the code you're shipping
today, we will attempt

00:27:39.976 --> 00:27:43.116 A:middle
to infer an NSOperation from the
environment whenever possible.

00:27:43.476 --> 00:27:45.846 A:middle
So, what this means is that
if you have code executing

00:27:45.846 --> 00:27:47.276 A:middle
at Utility Quality of Service

00:27:47.656 --> 00:27:50.576 A:middle
and you create a new
NSOperation inside of that code,

00:27:51.086 --> 00:27:53.746 A:middle
that new NSOperation will
automatically use Utility

00:27:54.136 --> 00:27:56.466 A:middle
if there isn't a Quality
of Service set later

00:27:56.466 --> 00:27:58.016 A:middle
on that operation
or on the queue.

00:27:58.626 --> 00:28:03.386 A:middle
So, if we go back to
our application example,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.626 --> 00:28:03.386 A:middle
So, if we go back to
our application example,

00:28:03.456 --> 00:28:05.746 A:middle
if we want to apply
Quality of Service to this,

00:28:05.746 --> 00:28:07.676 A:middle
the first thing we'll
do is set User Initiated

00:28:07.676 --> 00:28:10.906 A:middle
on our thumbnail generation
queue, and then Utility

00:28:11.216 --> 00:28:12.386 A:middle
on our image conversion queue.

00:28:12.826 --> 00:28:14.426 A:middle
And now, those pieces
of work will happen

00:28:14.426 --> 00:28:16.126 A:middle
at the appropriate
Quality of Service.

00:28:17.196 --> 00:28:19.596 A:middle
But Quality of Service
isn't static.

00:28:19.966 --> 00:28:21.406 A:middle
And the logical Quality
of Service

00:28:21.406 --> 00:28:23.186 A:middle
of an operation might
change over time.

00:28:23.646 --> 00:28:26.466 A:middle
So, for example, you start
doing a conversion of an image

00:28:26.706 --> 00:28:28.986 A:middle
at Utility but the user
wants to view the result.

00:28:29.646 --> 00:28:32.466 A:middle
Well now, that work needs to
happen at User Initiated Quality

00:28:32.466 --> 00:28:33.716 A:middle
of Service instead of Utility.

00:28:35.316 --> 00:28:36.996 A:middle
With NSOperation,
we have three ways

00:28:36.996 --> 00:28:40.046 A:middle
that we can promote the Quality
of Service of existing work.

00:28:40.646 --> 00:28:43.836 A:middle
The first is enqueueing a higher
Quality of Service operation

00:28:43.836 --> 00:28:45.256 A:middle
on the same queue as that work.

00:28:46.176 --> 00:28:49.006 A:middle
If you have a queue full
of utility operations

00:28:49.376 --> 00:28:51.166 A:middle
and you enqueue something
that's User Initiated,

00:28:51.606 --> 00:28:54.656 A:middle
we will then promote everything
in front of that operation.

00:28:54.796 --> 00:28:55.936 A:middle
Also, to User Initiated.

00:28:56.256 --> 00:28:58.796 A:middle
So, that operation gets to the
front of the queue and runs

00:28:58.796 --> 00:29:00.546 A:middle
at an appropriate time.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.796 --> 00:29:00.546 A:middle
at an appropriate time.

00:29:01.566 --> 00:29:05.196 A:middle
If you use addDependency and
make a, let's for example,

00:29:05.326 --> 00:29:07.226 A:middle
User Initiated operation
dependent

00:29:07.356 --> 00:29:09.616 A:middle
on a Background operation,
we'll promote

00:29:09.616 --> 00:29:11.526 A:middle
that Background operation
to User Initiated.

00:29:11.986 --> 00:29:14.486 A:middle
And finally, if you
use waitUntilFinished

00:29:14.516 --> 00:29:16.376 A:middle
or waitUntilAllOperations

00:29:16.376 --> 00:29:18.686 A:middle
AreFinished from a higher
Quality of Service thread,

00:29:18.686 --> 00:29:20.996 A:middle
we will promote the
operations you're waiting on.

00:29:21.546 --> 00:29:24.026 A:middle
So, if we go back
to our example,

00:29:24.196 --> 00:29:27.206 A:middle
and let's say you get an event
that indicates the user tapped

00:29:27.206 --> 00:29:29.326 A:middle
on a particular image
to view it full size,

00:29:30.136 --> 00:29:32.696 A:middle
the first thing you'll do is
find the operation associated

00:29:32.696 --> 00:29:33.826 A:middle
with converting that image.

00:29:34.956 --> 00:29:36.506 A:middle
You'll then adjust
this queuePriority

00:29:36.656 --> 00:29:39.766 A:middle
to set queuePriority very
high, and after that,

00:29:40.126 --> 00:29:42.226 A:middle
adjust its Quality of
Service to set its Quality

00:29:42.226 --> 00:29:43.446 A:middle
of Service to User Initiated.

00:29:44.006 --> 00:29:45.286 A:middle
And now, if this is our queue,

00:29:46.276 --> 00:29:48.606 A:middle
we've now promoted the operation
we care about to the front

00:29:48.606 --> 00:29:51.836 A:middle
of that queue by adjusting the
queuePriority, and then cause it

00:29:51.836 --> 00:29:52.796 A:middle
to run at User Initiated

00:29:52.966 --> 00:29:54.446 A:middle
by adjusting the
Quality of Service.

00:29:56.986 --> 00:29:58.676 A:middle
All right.

00:29:58.676 --> 00:29:59.336 A:middle
So, quiz time.

00:29:59.496 --> 00:29:59.976 A:middle
This is your turn.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.326 --> 00:30:02.096 A:middle
We have another example
app and I'm going to walk

00:30:02.096 --> 00:30:04.336 A:middle
through the different features
of this app, and I want you

00:30:04.336 --> 00:30:06.186 A:middle
to think about what
Quality of Service each

00:30:06.186 --> 00:30:07.326 A:middle
of these features should run at.

00:30:07.676 --> 00:30:08.696 A:middle
Then, I'll let you
know the answer.

00:30:09.556 --> 00:30:11.546 A:middle
So, it's Feed Reader 9000.

00:30:11.546 --> 00:30:15.326 A:middle
It's a kind of typical RSS
or newsreader application.

00:30:15.776 --> 00:30:19.326 A:middle
So, if the user clicks on a
particular item in the feed

00:30:19.466 --> 00:30:21.676 A:middle
and we need to display
the content of that item,

00:30:22.386 --> 00:30:26.716 A:middle
the work to read the item on
our database, render the HTML,

00:30:26.766 --> 00:30:28.006 A:middle
generally get it onscreen.

00:30:28.416 --> 00:30:30.276 A:middle
What do you think
that might run at?

00:30:30.756 --> 00:30:35.096 A:middle
So, that's going to
run at User Initiated.

00:30:35.336 --> 00:30:38.126 A:middle
The user asked for it,
and so we need to display

00:30:38.126 --> 00:30:40.116 A:middle
that content before the
user can interact with it.

00:30:40.616 --> 00:30:43.726 A:middle
But it's not actively
involved scrolling

00:30:43.726 --> 00:30:47.016 A:middle
or otherwise be creating
a buttery user experience.

00:30:47.236 --> 00:30:49.606 A:middle
It's certainly longer
running work than that.

00:30:50.336 --> 00:30:52.886 A:middle
Now, imagine all the
users reading this item,

00:30:52.886 --> 00:30:55.656 A:middle
at the same time, we're
pre-fetching images

00:30:55.906 --> 00:30:58.396 A:middle
that happen later on
in this stream of news.

00:30:58.906 --> 00:31:02.046 A:middle
What Quality of Service
might that run at?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.906 --> 00:31:02.046 A:middle
What Quality of Service
might that run at?

00:31:04.696 --> 00:31:06.556 A:middle
So, we're going to want
to run that at Background.

00:31:06.556 --> 00:31:08.686 A:middle
The user is not aware of
the progress of this work.

00:31:09.026 --> 00:31:12.426 A:middle
And so, we don't need to
give it quite the performance

00:31:12.426 --> 00:31:12.986 A:middle
of Utility.

00:31:13.636 --> 00:31:15.356 A:middle
The Background work
will certainly happen

00:31:15.616 --> 00:31:18.046 A:middle
and we'll be able to
catch those images.

00:31:18.296 --> 00:31:20.656 A:middle
Of course, if the user then
goes to that post or wants

00:31:20.656 --> 00:31:21.726 A:middle
to promote that operation.

00:31:23.196 --> 00:31:26.796 A:middle
What about fetching
new content, new feeds?

00:31:27.406 --> 00:31:32.526 A:middle
So, this one is kind
of a trick question.

00:31:33.056 --> 00:31:34.976 A:middle
If the user requested
the content,

00:31:34.976 --> 00:31:38.156 A:middle
so they click Get New Items
or Get New Feeds button,

00:31:38.676 --> 00:31:41.316 A:middle
the expectation is that now
they're going to be watching

00:31:41.316 --> 00:31:43.946 A:middle
that list of items and be
unable to interact with it

00:31:43.946 --> 00:31:46.146 A:middle
until we've populated
it with new entries.

00:31:46.466 --> 00:31:49.446 A:middle
In that case, doing just the
minimum amount of work possible,

00:31:49.636 --> 00:31:51.956 A:middle
to get the list of items
that they can browse through,

00:31:52.176 --> 00:31:53.266 A:middle
should be User Initiated.

00:31:53.956 --> 00:31:56.486 A:middle
On the other hand, this
happens automatically.

00:31:56.486 --> 00:31:57.906 A:middle
Let's say we have a timer,

00:31:58.146 --> 00:32:00.906 A:middle
hopefully using
NSBackgroundActivityScheduler


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.146 --> 00:32:00.906 A:middle
hopefully using
NSBackgroundActivityScheduler

00:32:01.326 --> 00:32:04.376 A:middle
that causes us to fetch
new content every hour.

00:32:04.796 --> 00:32:06.296 A:middle
That work should
happen at Utility.

00:32:07.376 --> 00:32:09.576 A:middle
This is something the user
is aware of the progress of.

00:32:09.576 --> 00:32:11.186 A:middle
If it doesn't happen
then, obviously,

00:32:11.186 --> 00:32:13.106 A:middle
they won't see their new items.

00:32:13.446 --> 00:32:14.566 A:middle
But they're not watching for it

00:32:14.566 --> 00:32:16.286 A:middle
and it's not preventing
their further interaction.

00:32:16.796 --> 00:32:19.246 A:middle
And finally, search indexing.

00:32:22.516 --> 00:32:24.866 A:middle
This would happen at Background
because the user isn't aware

00:32:24.866 --> 00:32:26.016 A:middle
of the progress of this work.

00:32:26.596 --> 00:32:30.306 A:middle
So, you've taken
your application.

00:32:30.306 --> 00:32:32.526 A:middle
You've diligently gone
through and adopted Quality

00:32:32.526 --> 00:32:33.416 A:middle
of Service everywhere.

00:32:33.496 --> 00:32:34.606 A:middle
All your work is classified.

00:32:34.836 --> 00:32:36.186 A:middle
How do you actually validate

00:32:36.186 --> 00:32:37.506 A:middle
that this is working
and debug it?

00:32:37.796 --> 00:32:39.786 A:middle
So, there are three things
that you'll want to do.

00:32:40.216 --> 00:32:42.256 A:middle
The first is after
adopting Quality of Service,

00:32:42.256 --> 00:32:44.976 A:middle
set breakpoints to confirm
that your work is running

00:32:44.976 --> 00:32:46.576 A:middle
with the Quality of
Service you adopted.

00:32:47.026 --> 00:32:50.386 A:middle
Use the powermetrics
tool to confirm

00:32:50.386 --> 00:32:53.916 A:middle
for a longer running task which
Quality of Services are in use.

00:32:54.426 --> 00:32:58.216 A:middle
And then you can use the
spindump tool to determine

00:32:58.216 --> 00:32:59.726 A:middle
which Quality of Service
a particular piece

00:32:59.726 --> 00:33:02.446 A:middle
of code is executing with
if what you find using one


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.726 --> 00:33:02.446 A:middle
of code is executing with
if what you find using one

00:33:02.446 --> 00:33:03.746 A:middle
of these other methods
is unexpected.

00:33:05.386 --> 00:33:07.956 A:middle
So, let's start with
the first of these.

00:33:08.286 --> 00:33:12.306 A:middle
In Xcode 6, if you first pause
your application, whether using,

00:33:12.306 --> 00:33:15.826 A:middle
just pausing it or setting a
breakpoint, and then you go

00:33:15.826 --> 00:33:18.396 A:middle
to the CPU debug gauge, which
is part of the debug navigator.

00:33:18.596 --> 00:33:20.736 A:middle
Most of you are probably
familiar with this.

00:33:21.086 --> 00:33:23.796 A:middle
The top, you see a graph
of CPU use over time.

00:33:24.246 --> 00:33:25.246 A:middle
And so, we can see
in our example,

00:33:25.246 --> 00:33:27.126 A:middle
we have something burning CPU.

00:33:27.816 --> 00:33:29.516 A:middle
If you then go down
through the threads list,

00:33:30.086 --> 00:33:32.936 A:middle
underneath each thread will
tell you what Quality of Service

00:33:32.936 --> 00:33:34.136 A:middle
that thread currently has.

00:33:34.136 --> 00:33:36.396 A:middle
So, in this case, this
thread has Utility.

00:33:36.436 --> 00:33:38.796 A:middle
And so, we know that that CPU
time is happening at Utility.

00:33:39.606 --> 00:33:41.746 A:middle
Now, this is the
Quality of Service

00:33:41.746 --> 00:33:42.806 A:middle
that your code requested.

00:33:43.256 --> 00:33:45.566 A:middle
So, if you start an operation at
a particular Quality of Service,

00:33:45.566 --> 00:33:46.786 A:middle
that's what will
be displayed here.

00:33:47.326 --> 00:33:49.016 A:middle
If another part of
your application tries

00:33:49.016 --> 00:33:51.666 A:middle
to change the Quality of Service
of that thread, for example,

00:33:51.666 --> 00:33:53.566 A:middle
using the override
API that you'll learn

00:33:53.566 --> 00:33:57.026 A:middle
about in a session later
today, that won't appear here.

00:33:59.016 --> 00:34:00.386 A:middle
So, let's say you've
gone through,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.016 --> 00:34:00.386 A:middle
So, let's say you've
gone through,

00:34:00.516 --> 00:34:03.846 A:middle
validated your initial adoption,
and now you want to know, OK,

00:34:04.066 --> 00:34:06.656 A:middle
what is my code actually
using in practice?

00:34:06.656 --> 00:34:09.726 A:middle
You can use the powermetrics
command line tool

00:34:09.726 --> 00:34:12.226 A:middle
with the show-process-QOS to see

00:34:12.226 --> 00:34:13.746 A:middle
where your code is
spending time.

00:34:14.606 --> 00:34:16.946 A:middle
So, in this case,
we'll run powermetrics

00:34:17.065 --> 00:34:18.436 A:middle
and we'll get a list
of running tasks

00:34:18.436 --> 00:34:20.085 A:middle
and we can see MyApplication
is here.

00:34:20.606 --> 00:34:23.536 A:middle
And I'm spending 80
milliseconds per second

00:34:23.536 --> 00:34:26.446 A:middle
on the CPU, or about 8 percent.

00:34:26.446 --> 00:34:29.985 A:middle
I can see some information
about timers, which we'll talk

00:34:29.985 --> 00:34:30.846 A:middle
about later in the talk.

00:34:31.286 --> 00:34:34.106 A:middle
But then, what's important to
us here is I get a breakdown

00:34:34.106 --> 00:34:36.085 A:middle
of what Quality of Service
Classes I was using.

00:34:36.226 --> 00:34:39.755 A:middle
So, I can see that I'm spending
88 milliseconds at Utility,

00:34:39.976 --> 00:34:41.446 A:middle
so almost all of
my time is there.

00:34:41.686 --> 00:34:42.626 A:middle
And if that's what I wanted,

00:34:42.626 --> 00:34:44.775 A:middle
then I've done a good job
adopting Quality of Service.

00:34:45.556 --> 00:34:47.996 A:middle
Now, if you find that what
you see here isn't expected,

00:34:49.436 --> 00:34:50.746 A:middle
you can use the spindump tool

00:34:50.746 --> 00:34:52.606 A:middle
to get a more detailed
understanding

00:34:52.606 --> 00:34:54.596 A:middle
of where your code is
executing with respect

00:34:54.596 --> 00:34:55.636 A:middle
to Quality of Service.

00:34:56.295 --> 00:34:57.526 A:middle
So, if you're not
familiar with spindump,

00:34:57.526 --> 00:34:59.466 A:middle
it's kind of like
sample or time profile.

00:34:59.466 --> 00:35:01.186 A:middle
It's a sampling-based profiler.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.466 --> 00:35:01.186 A:middle
It's a sampling-based profiler.

00:35:01.946 --> 00:35:05.956 A:middle
But in OS X Yosemite, we added a
new option, the timeline option

00:35:06.636 --> 00:35:11.436 A:middle
that can show your stacks
chronologically instead

00:35:11.436 --> 00:35:12.856 A:middle
of by heaviest first.

00:35:14.026 --> 00:35:15.646 A:middle
So, in this case,
we've run spindump

00:35:15.646 --> 00:35:16.476 A:middle
against our application.

00:35:17.156 --> 00:35:19.706 A:middle
And you can see that we
have a particular thread

00:35:19.706 --> 00:35:21.326 A:middle
and it starts at
executing Utility.

00:35:21.956 --> 00:35:25.676 A:middle
And then, if later that thread
happens to change to executing

00:35:25.676 --> 00:35:29.056 A:middle
at Background, we'll see another
indication of our Quality

00:35:29.056 --> 00:35:29.986 A:middle
of Service of that thread.

00:35:29.986 --> 00:35:31.706 A:middle
In this way, you
can kind of walk

00:35:31.706 --> 00:35:33.576 A:middle
through what code
you're executed during,

00:35:34.526 --> 00:35:36.806 A:middle
what code your app executed
during the spindump,

00:35:37.356 --> 00:35:39.596 A:middle
and see what Quality of
Services that code was using.

00:35:40.146 --> 00:35:43.846 A:middle
So, that's Quality of Service.

00:35:44.186 --> 00:35:46.156 A:middle
It lets you specify
the responsiveness

00:35:46.156 --> 00:35:47.456 A:middle
and energy requirements of work.

00:35:47.886 --> 00:35:49.466 A:middle
We expose it as both
a foundation

00:35:49.466 --> 00:35:51.896 A:middle
and C-level APIs
including dispatch.

00:35:52.586 --> 00:35:56.146 A:middle
It lets you, your goal just
kind of immediately walking

00:35:56.146 --> 00:35:58.656 A:middle
out of the session, should be
to try to classify long running

00:35:58.656 --> 00:36:01.186 A:middle
or resource intensive
parts of your application.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:58.656 --> 00:36:01.186 A:middle
or resource intensive
parts of your application.

00:36:01.746 --> 00:36:04.176 A:middle
And this can get you the biggest
bang for the buck both in terms

00:36:04.176 --> 00:36:07.016 A:middle
of responsiveness benefits
and energy improvement.

00:36:08.056 --> 00:36:09.876 A:middle
And you want to try
to aim for 90 percent

00:36:09.876 --> 00:36:13.116 A:middle
of your application's execution
to be at Utility or below

00:36:13.116 --> 00:36:15.656 A:middle
when the user isn't
actively interacting

00:36:15.656 --> 00:36:16.396 A:middle
with your application.

00:36:17.056 --> 00:36:19.936 A:middle
This is kind of a
high-level overview.

00:36:20.056 --> 00:36:22.466 A:middle
There's a lot more details
including discussion

00:36:22.466 --> 00:36:24.936 A:middle
of the dispatch-based APIs
that you can use for this

00:36:25.136 --> 00:36:26.186 A:middle
at the Power Performance

00:36:26.186 --> 00:36:28.936 A:middle
and Diagnostic session
tomorrow afternoon.

00:36:29.306 --> 00:36:31.446 A:middle
I highly encourage
you to attend that.

00:36:33.716 --> 00:36:36.006 A:middle
So, that was Do It
More Efficiently.

00:36:36.756 --> 00:36:38.426 A:middle
So, let's talk about Do It Less.

00:36:39.376 --> 00:36:41.436 A:middle
So, you're running your
code at the right time.

00:36:42.036 --> 00:36:42.816 A:middle
You're not doing work.

00:36:42.816 --> 00:36:43.476 A:middle
You don't need to.

00:36:43.476 --> 00:36:45.486 A:middle
You're doing it with
Quality of Service specified.

00:36:46.336 --> 00:36:49.126 A:middle
Now, how do you just simply
make your code do less work?

00:36:50.166 --> 00:36:51.726 A:middle
So, we're going to talk
about three things.

00:36:52.226 --> 00:36:55.986 A:middle
CPU, Graphics, and Storage,
and techniques you can use

00:36:55.986 --> 00:36:57.836 A:middle
to improve your efficiency
in each of these areas.

00:36:58.966 --> 00:37:01.036 A:middle
But before we talk
about a specific topic,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.966 --> 00:37:01.036 A:middle
But before we talk
about a specific topic,

00:37:01.036 --> 00:37:03.446 A:middle
how do you just generally
monitor your energy consumption?

00:37:04.306 --> 00:37:08.456 A:middle
Well, if you are debugging your
application in Xcode and you go

00:37:08.456 --> 00:37:12.336 A:middle
to Debug Navigator, there's
the energy impact gauge.

00:37:12.996 --> 00:37:16.226 A:middle
This is an indication of how
much energy your app is using,

00:37:16.226 --> 00:37:17.906 A:middle
taking into account
a variety of factors.

00:37:18.216 --> 00:37:20.126 A:middle
And you can see in this case,

00:37:20.126 --> 00:37:24.756 A:middle
our application has high energy
impact that is unexpected or bad

00:37:24.846 --> 00:37:26.766 A:middle
if we don't think we're
doing something that's

00:37:26.766 --> 00:37:27.506 A:middle
energy intensive.

00:37:27.506 --> 00:37:30.576 A:middle
And so, you want to keep an
eye on the energy impact gauge,

00:37:30.896 --> 00:37:33.626 A:middle
and what your application is
scoring on as you're developing,

00:37:33.966 --> 00:37:36.076 A:middle
to look for things that
are unexpectedly expensive.

00:37:36.596 --> 00:37:39.616 A:middle
So, with that, let's
dive into CPU.

00:37:39.986 --> 00:37:42.336 A:middle
So, why is it important
to reduce CPU use?

00:37:43.226 --> 00:37:46.006 A:middle
Well, if I have 1
percent CPU use,

00:37:46.266 --> 00:37:49.416 A:middle
I'm going to cause 10 percent
higher power draw from the CPU.

00:37:49.996 --> 00:37:54.726 A:middle
If I have 10 percent CPU use, I
will cause two times the amount

00:37:54.726 --> 00:37:56.476 A:middle
of power draw compared
to an idle CPU.

00:37:57.076 --> 00:38:00.786 A:middle
And finally, if I have
100 percent CPU use,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:57.076 --> 00:38:00.786 A:middle
And finally, if I have
100 percent CPU use,

00:38:00.786 --> 00:38:03.036 A:middle
I will cause 10 times
the power draw.

00:38:03.626 --> 00:38:07.346 A:middle
And so, in this way, your use of
the CPU can have a huge impact

00:38:07.346 --> 00:38:10.996 A:middle
on the amount of power
consumed by your application.

00:38:11.356 --> 00:38:15.706 A:middle
Now, if we go back to
our Debug Navigator,

00:38:15.986 --> 00:38:17.676 A:middle
we can look at the CPU gauge

00:38:18.166 --> 00:38:20.966 A:middle
to see how much CPU our
app is using over time.

00:38:21.316 --> 00:38:22.836 A:middle
This is another thing you
want to try to monitor

00:38:22.836 --> 00:38:25.346 A:middle
as you're developing your
app, to look for places

00:38:25.346 --> 00:38:27.226 A:middle
where you're using
unexpected amounts of CPU.

00:38:28.356 --> 00:38:30.696 A:middle
If you do find you're using
more CPU than you expect,

00:38:31.216 --> 00:38:33.486 A:middle
your best friend is going to
be Instruments Time Profiler.

00:38:33.906 --> 00:38:36.946 A:middle
There's a variety of
talks and guides online

00:38:36.946 --> 00:38:38.186 A:middle
on how to use Time Profiler.

00:38:38.726 --> 00:38:40.106 A:middle
But the short of it is
that it lets you see

00:38:40.106 --> 00:38:42.346 A:middle
where your application is
spending its time to look

00:38:42.346 --> 00:38:44.196 A:middle
for CPU-intensive
routines that you can try

00:38:44.196 --> 00:38:45.436 A:middle
to optimize or eliminate.

00:38:47.356 --> 00:38:50.666 A:middle
One feature that's new in Xcode
6 is Performance Unit Tests.

00:38:51.376 --> 00:38:53.486 A:middle
This is an addition
to the XCTestCase API,

00:38:53.486 --> 00:38:56.286 A:middle
and it helps you find
performance regressions

00:38:56.286 --> 00:38:58.016 A:middle
in your code by measuring
the performance

00:38:58.016 --> 00:38:59.806 A:middle
of particular parts
of your application.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:00.066 --> 00:39:03.596 A:middle
I mentioned before performance
and energy go hand in hand.

00:39:03.936 --> 00:39:06.096 A:middle
And so, making sure you're
doing good performance testing

00:39:06.096 --> 00:39:09.396 A:middle
of your code can help you
find energy regressions early.

00:39:10.546 --> 00:39:12.506 A:middle
API is pretty simple.

00:39:12.616 --> 00:39:14.066 A:middle
You simply call measureBlock

00:39:14.066 --> 00:39:15.646 A:middle
and tell it what code
you want to measure.

00:39:16.166 --> 00:39:19.276 A:middle
And then you'll get a
variety of performance metrics

00:39:19.636 --> 00:39:24.476 A:middle
from that code, including, for
our purposes here, wall time.

00:39:24.476 --> 00:39:27.956 A:middle
If you want to learn more
about this, you should check

00:39:27.956 --> 00:39:30.996 A:middle
out Testing in Xcode 6
and Continuous Integration

00:39:30.996 --> 00:39:33.956 A:middle
with Xcode 6 tomorrow, and
I'll have all these at the end

00:39:33.956 --> 00:39:34.956 A:middle
of the presentation as well.

00:39:35.566 --> 00:39:38.986 A:middle
So, that's reducing CPU use.

00:39:39.506 --> 00:39:42.426 A:middle
And remember that CPU has a
huge dynamic range in power.

00:39:43.496 --> 00:39:45.566 A:middle
Monitor CPU with the
Xcode debug gauge

00:39:45.566 --> 00:39:46.936 A:middle
as you're developing
your application.

00:39:48.316 --> 00:39:50.396 A:middle
Profile your code with
Instruments to find

00:39:50.396 --> 00:39:53.346 A:middle
and eliminate CPU
hogging routines.

00:39:54.846 --> 00:39:57.756 A:middle
And use performance unit
tests to prevent regressions.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:00.066 --> 00:40:02.636 A:middle
Now, reducing the amount
of CPU use is important,

00:40:02.636 --> 00:40:04.786 A:middle
but it's also important
to consider how you use it

00:40:04.786 --> 00:40:07.206 A:middle
in the context of fixed costs
that we discussed earlier.

00:40:07.496 --> 00:40:10.906 A:middle
So, you want to make sure
you minimize timer use

00:40:10.906 --> 00:40:11.656 A:middle
in your application.

00:40:12.126 --> 00:40:14.976 A:middle
There are lots of
timer APIs in a system.

00:40:14.976 --> 00:40:18.496 A:middle
Everything from NSTimer,
Grand Central Dispatch timers,

00:40:18.676 --> 00:40:23.386 A:middle
CVDisplayLink, all these
APIs will cause timer wakeups

00:40:23.386 --> 00:40:24.536 A:middle
to happen in your application.

00:40:24.536 --> 00:40:27.626 A:middle
And so it's important to
understand how you're using them

00:40:27.886 --> 00:40:29.936 A:middle
and make sure to minimize
your use of these sorts

00:40:29.936 --> 00:40:31.376 A:middle
of APIs as much as possible.

00:40:31.726 --> 00:40:35.236 A:middle
And if we go back to one of our
power graphs, if we imagine each

00:40:35.236 --> 00:40:37.776 A:middle
of these small units of work
is actually a timer firing

00:40:37.776 --> 00:40:42.386 A:middle
in your application, we now
pay all of this fixed cost just

00:40:42.576 --> 00:40:44.456 A:middle
to service these
very small timers.

00:40:44.986 --> 00:40:48.116 A:middle
Who knows whether these are
actually important or not?

00:40:48.556 --> 00:40:53.836 A:middle
So, what you can do is use the
Energy Impact Gauge in Xcode

00:40:53.966 --> 00:40:56.376 A:middle
and look at the wakes
in CPU area

00:40:56.376 --> 00:40:58.656 A:middle
to see how often your
application is waking due

00:40:58.656 --> 00:40:59.546 A:middle
to a timer firing.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:00.606 --> 00:41:02.236 A:middle
If you find this is
higher than expected,

00:41:03.466 --> 00:41:05.446 A:middle
you can use the timerfires
command line tool.

00:41:05.516 --> 00:41:07.826 A:middle
And in this case, we'll
want it with a dash-g option

00:41:08.036 --> 00:41:09.756 A:middle
that gives us a summary
of the timers

00:41:09.756 --> 00:41:10.866 A:middle
that fired in our application.

00:41:11.096 --> 00:41:13.516 A:middle
So, you start this tool,
run your application

00:41:13.596 --> 00:41:16.246 A:middle
for a little while, kill
the tool with Control-C,

00:41:17.586 --> 00:41:19.656 A:middle
and then you'll get
a list of the timers

00:41:19.656 --> 00:41:21.786 A:middle
that fired while the tool was
running in your application.

00:41:21.976 --> 00:41:25.676 A:middle
In this case, we can see we
had a lot of calls to sleep,

00:41:26.066 --> 00:41:29.046 A:middle
some dispatch timers and
what routine they called,

00:41:29.046 --> 00:41:30.736 A:middle
and some CF timers, what
routine they called.

00:41:32.396 --> 00:41:34.206 A:middle
Now, reducing timers is great.

00:41:34.326 --> 00:41:36.836 A:middle
Sometimes, you can't
eliminate a timer completely.

00:41:37.286 --> 00:41:39.816 A:middle
In that case, you want to
help the system do a good job

00:41:39.816 --> 00:41:42.016 A:middle
of scheduling that timer
in energy efficient time.

00:41:42.676 --> 00:41:44.906 A:middle
This includes just something
we call Timer Coalescing.

00:41:45.106 --> 00:41:48.276 A:middle
This is a feature we introduced
in last year's releases.

00:41:49.156 --> 00:41:51.516 A:middle
And what this does
is take timers

00:41:51.516 --> 00:41:54.196 A:middle
that are firing the
system and coalesce them

00:41:54.196 --> 00:41:55.536 A:middle
to fire at the same time.

00:41:55.686 --> 00:41:57.276 A:middle
In this way, we can
keep the system

00:41:57.276 --> 00:41:58.536 A:middle
in an idle state for longer.

00:41:59.456 --> 00:42:02.226 A:middle
And we will try to do this
as best we can but we have


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.456 --> 00:42:02.226 A:middle
And we will try to do this
as best we can but we have

00:42:02.226 --> 00:42:03.816 A:middle
to subject it to
some limitations

00:42:03.816 --> 00:42:07.716 A:middle
to make sure we don't delay a
timer more than is appropriate.

00:42:08.536 --> 00:42:10.216 A:middle
But you can help us
determine the amount

00:42:10.216 --> 00:42:12.586 A:middle
of tolerance you're willing that
time, for that timer to have

00:42:13.126 --> 00:42:16.146 A:middle
by specifying a timer tolerance
whenever you create a timer.

00:42:16.826 --> 00:42:18.926 A:middle
So, this first example
is for NSTimer.

00:42:19.046 --> 00:42:20.726 A:middle
You can simply call setTolerance

00:42:20.986 --> 00:42:22.716 A:middle
and indicate how much
tolerance you're willing

00:42:22.716 --> 00:42:23.626 A:middle
for that timer to have.

00:42:23.886 --> 00:42:25.826 A:middle
In this case, we
specified 60 seconds.

00:42:26.416 --> 00:42:28.716 A:middle
For a CFRunLoopTimer,
you can call

00:42:28.716 --> 00:42:30.436 A:middle
a CFRunLoopTimerSetTolerance.

00:42:30.866 --> 00:42:32.856 A:middle
And then for a dispatch
source timer,

00:42:33.156 --> 00:42:34.796 A:middle
when you call dispatch
source set timer,

00:42:34.796 --> 00:42:36.776 A:middle
that last parameter
is a tolerance value.

00:42:37.276 --> 00:42:38.776 A:middle
And so, in all these
cases, what we're indicating

00:42:38.776 --> 00:42:41.106 A:middle
in the system is that we're
willing for this timer to take

00:42:41.476 --> 00:42:43.376 A:middle
up to an extra 60
seconds to fire

00:42:43.776 --> 00:42:45.616 A:middle
if that will improve
our energy consumption.

00:42:47.356 --> 00:42:49.276 A:middle
So, let's minimize timers.

00:42:49.746 --> 00:42:51.856 A:middle
Be mindful of the
wakeup overhead timers.

00:42:52.036 --> 00:42:55.066 A:middle
Monitor your app for wakeups
using the Xcode Debug Gauge.

00:42:56.446 --> 00:42:58.876 A:middle
Debug with timerfires
if you find more wakeups

00:42:58.876 --> 00:43:01.866 A:middle
than you expect, and make sure
you specify a timer tolerance


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:58.876 --> 00:43:01.866 A:middle
than you expect, and make sure
you specify a timer tolerance

00:43:02.446 --> 00:43:03.456 A:middle
whenever you create a timer.

00:43:04.066 --> 00:43:07.496 A:middle
Now, this is a very brief
introduction to timers.

00:43:07.546 --> 00:43:10.656 A:middle
If you want a lot more details
and some examples of good

00:43:10.656 --> 00:43:12.186 A:middle
and bad timer-related code,

00:43:12.426 --> 00:43:14.676 A:middle
check out last year's
Energy Best Practices talk.

00:43:14.676 --> 00:43:19.926 A:middle
So, next I want to talk
about efficient Graphics.

00:43:20.466 --> 00:43:22.336 A:middle
Why is Graphics an
important area?

00:43:22.966 --> 00:43:24.686 A:middle
Well, let's say you
have an application

00:43:24.946 --> 00:43:26.506 A:middle
and your app does some drawing.

00:43:26.826 --> 00:43:30.096 A:middle
Well, that drawing now needs
to get handed to the system

00:43:30.096 --> 00:43:31.906 A:middle
so that it can compute how

00:43:31.906 --> 00:43:35.356 A:middle
that drawing affects the overall
user interface, do some work

00:43:35.356 --> 00:43:36.936 A:middle
in core animation
or core graphics.

00:43:37.446 --> 00:43:39.446 A:middle
Eventually, we'll hand
that work off to the GPU.

00:43:39.446 --> 00:43:43.206 A:middle
That GPU now needs to wake up
out of its low power states

00:43:43.206 --> 00:43:44.196 A:middle
and do some processing.

00:43:44.826 --> 00:43:46.536 A:middle
And then, we eventually
have to hand that off

00:43:46.536 --> 00:43:48.686 A:middle
to the display itself,
which might also be

00:43:48.686 --> 00:43:50.186 A:middle
in a low-power state
and it has to wake up

00:43:50.186 --> 00:43:51.546 A:middle
and do work to update the UI.

00:43:51.546 --> 00:43:53.756 A:middle
And so, it's very important

00:43:53.756 --> 00:43:55.916 A:middle
that we limit our screen
updates as much as possible.

00:43:56.676 --> 00:43:58.976 A:middle
This includes avoiding updating
the screen when we don't need

00:43:58.976 --> 00:44:02.776 A:middle
to because unnecessary drawing
can kick the graphics hardware


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.976 --> 00:44:02.776 A:middle
to because unnecessary drawing
can kick the graphics hardware

00:44:02.776 --> 00:44:03.896 A:middle
out of low-power modes.

00:44:04.556 --> 00:44:07.036 A:middle
It also means avoiding drawing
more content than needed.

00:44:07.356 --> 00:44:09.876 A:middle
So, if you get a, if
you have a custom view

00:44:10.006 --> 00:44:13.006 A:middle
and you get a DrawRect
call for a very small area,

00:44:13.286 --> 00:44:15.726 A:middle
make sure you don't draw more
than the area you're required.

00:44:16.146 --> 00:44:19.606 A:middle
And you can use needsToDrawRect
or getRectsBeingDrawn:count

00:44:19.906 --> 00:44:22.256 A:middle
to fine tune what areas
you update in your view.

00:44:22.256 --> 00:44:25.686 A:middle
And there's a great view drawing
guide available and we'll go

00:44:25.686 --> 00:44:27.396 A:middle
into that in more
detail if you're curious.

00:44:28.256 --> 00:44:30.856 A:middle
So, how do you determine whether
you're doing the right thing

00:44:30.856 --> 00:44:31.746 A:middle
with respect to drawing?

00:44:32.686 --> 00:44:34.556 A:middle
Well, you can use
Flash Screen Updates.

00:44:34.556 --> 00:44:36.776 A:middle
So, this is the Quartz
Debug utility that comes

00:44:36.776 --> 00:44:38.176 A:middle
with Graphics tools for Xcode.

00:44:38.556 --> 00:44:41.996 A:middle
If you run this and check the
Flash Screen Updates box-I'm not

00:44:41.996 --> 00:44:42.896 A:middle
going to demo this for you

00:44:42.896 --> 00:44:44.496 A:middle
because it can be a little
bit seizure inducing.

00:44:45.026 --> 00:44:48.336 A:middle
But, if you were to look at the
Shut Down dialog, you would,

00:44:48.336 --> 00:44:51.416 A:middle
on OS X Mavericks, you'd see
the Shut Down button flashing

00:44:51.416 --> 00:44:52.526 A:middle
at 30 frames per second.

00:44:53.066 --> 00:44:55.206 A:middle
And this is correct
behavior in this case,

00:44:55.206 --> 00:44:56.346 A:middle
because that button pulses.

00:44:56.586 --> 00:44:59.086 A:middle
And so, as long as you see
a flash only when we expect

00:44:59.086 --> 00:45:02.016 A:middle
that button to be updated
and that the region flashed,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.086 --> 00:45:02.016 A:middle
that button to be updated
and that the region flashed,

00:45:02.016 --> 00:45:03.316 A:middle
which is indicated in yellow,

00:45:03.776 --> 00:45:05.986 A:middle
is only the area
immediately surrounding

00:45:05.986 --> 00:45:09.076 A:middle
that UI element that's changing,
then we're behaving correctly.

00:45:09.256 --> 00:45:12.116 A:middle
On the other hand, if you'd
seen the entire window flash,

00:45:12.466 --> 00:45:13.766 A:middle
that would have been
a cause for concern.

00:45:14.616 --> 00:45:17.796 A:middle
Now, if you were to compare
this to OS X Yosemite,

00:45:18.306 --> 00:45:20.406 A:middle
you'd see that the Shut Down
button doesn't pulse anymore,

00:45:20.626 --> 00:45:21.986 A:middle
so you wouldn't get
any flashing.

00:45:22.446 --> 00:45:25.066 A:middle
And we've improved
the energy consumption

00:45:25.066 --> 00:45:26.146 A:middle
of the Shut Down dialogue.

00:45:27.126 --> 00:45:31.276 A:middle
Now, for iOS, we, if you go to
the Core Animation instrument,

00:45:31.456 --> 00:45:35.116 A:middle
there's a debug option
for Flash Updated Regions

00:45:35.116 --> 00:45:35.746 A:middle
that you can check.

00:45:35.746 --> 00:45:38.216 A:middle
And this will produce
similar behavior

00:45:38.216 --> 00:45:39.606 A:middle
on your tethered iOS device.

00:45:40.096 --> 00:45:43.396 A:middle
And also, one other
thing you want to keep

00:45:43.446 --> 00:45:44.896 A:middle
in mind is visual effects.

00:45:45.256 --> 00:45:49.776 A:middle
So, with the new UI in OS
X Yosemite or the iOS 7 UI,

00:45:50.686 --> 00:45:52.946 A:middle
you might want to
place a translucency

00:45:52.946 --> 00:45:54.446 A:middle
or blur effect on some element.

00:45:54.966 --> 00:45:56.906 A:middle
But you want to make sure
you avoid placing these

00:45:56.906 --> 00:45:58.406 A:middle
over frequently updating
elements.

00:45:58.406 --> 00:46:01.556 A:middle
Because if something
underneath that effect changes,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.406 --> 00:46:01.556 A:middle
Because if something
underneath that effect changes,

00:46:01.806 --> 00:46:03.956 A:middle
you have to update
the, and redo the work

00:46:03.956 --> 00:46:05.356 A:middle
to do the blur and translucency.

00:46:05.686 --> 00:46:07.076 A:middle
So, you can imagine, if we were

00:46:07.076 --> 00:46:09.196 A:middle
to put Animating
Content underneath the

00:46:09.196 --> 00:46:12.626 A:middle
NSVisualEffectView, we
would magnify the power cost

00:46:12.626 --> 00:46:14.166 A:middle
of updating that
Animating Content.

00:46:14.256 --> 00:46:16.256 A:middle
On the other hand, if
you move that content

00:46:16.256 --> 00:46:17.626 A:middle
out from underneath
the EffectView,

00:46:18.476 --> 00:46:22.666 A:middle
then you won't see dramatically
increased cost due to that.

00:46:23.456 --> 00:46:24.986 A:middle
So, that's Efficient Graphics.

00:46:25.686 --> 00:46:27.236 A:middle
Make sure to draw
minimally and efficiently.

00:46:28.136 --> 00:46:30.846 A:middle
Monitor your drawing with
Quartz Debug or Instruments

00:46:31.266 --> 00:46:33.186 A:middle
and avoid blurs on
updating content.

00:46:33.686 --> 00:46:36.926 A:middle
And finally, Flash Power.

00:46:37.636 --> 00:46:41.056 A:middle
So, Flash is a little
bit of a different beast

00:46:41.056 --> 00:46:43.566 A:middle
than the rotating hard drives
you might have been familiar

00:46:43.566 --> 00:46:44.556 A:middle
with in older Macs.

00:46:45.026 --> 00:46:48.116 A:middle
In particular, writes to Flash
are significantly more energy

00:46:48.116 --> 00:46:49.076 A:middle
hungry than reads.

00:46:49.196 --> 00:46:51.676 A:middle
So, you want to make sure
you write the minimum amount

00:46:51.676 --> 00:46:55.286 A:middle
of content necessary and
do writing in aggregate

00:46:55.586 --> 00:46:57.796 A:middle
to help amortize some
of those fixed costs.

00:46:58.886 --> 00:47:02.086 A:middle
Also, remember that any I/O you
do can pull the storage device


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:58.886 --> 00:47:02.086 A:middle
Also, remember that any I/O you
do can pull the storage device

00:47:02.216 --> 00:47:03.396 A:middle
out of a lower-power state.

00:47:04.156 --> 00:47:05.276 A:middle
And so, you want
to take advantage

00:47:05.276 --> 00:47:06.926 A:middle
of the I/O caching
available to you

00:47:07.716 --> 00:47:10.266 A:middle
to ensure you're not doing
lots of sporadic I/Os

00:47:10.266 --> 00:47:11.726 A:middle
to keep the device from idling.

00:47:12.306 --> 00:47:15.816 A:middle
So, that was Do It Less.

00:47:16.456 --> 00:47:17.796 A:middle
Things you want to
remember, profile

00:47:17.796 --> 00:47:19.346 A:middle
and monitor your CPU use.

00:47:19.836 --> 00:47:20.806 A:middle
Reduce your timers.

00:47:21.286 --> 00:47:24.526 A:middle
Be efficient in the use of
graphics and minimize your I/O.

00:47:24.626 --> 00:47:25.206 A:middle
All right.

00:47:26.596 --> 00:47:29.046 A:middle
So, to summarize what
we talked about today,

00:47:30.116 --> 00:47:32.106 A:middle
improving your app's energy
consumption improves the

00:47:32.106 --> 00:47:33.016 A:middle
user experience.

00:47:33.536 --> 00:47:36.106 A:middle
Keep in mind how you're
using the device and how,

00:47:36.106 --> 00:47:37.726 A:middle
what kind of impact that
will have on energy.

00:47:39.826 --> 00:47:42.206 A:middle
Make sure you continuously
monitor your app's energy

00:47:42.206 --> 00:47:43.516 A:middle
and resource consumption
as you're developing.

00:47:44.316 --> 00:47:47.386 A:middle
And look for ways to apply the
four techniques we talked about.

00:47:47.616 --> 00:47:50.556 A:middle
Do It Never, respond to
changes in your app's active

00:47:50.786 --> 00:47:53.326 A:middle
or occlusion state to minimize
the amount of work you do

00:47:53.326 --> 00:47:55.776 A:middle
when that work won't
be visible to the user.

00:47:55.776 --> 00:47:59.936 A:middle
Do It at a Better Time, let the
system schedule work using the

00:47:59.936 --> 00:48:04.166 A:middle
NSBackgroundActivityScheduler or
NSURLSessionBackground Session.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.936 --> 00:48:04.166 A:middle
NSBackgroundActivityScheduler or
NSURLSessionBackground Session.

00:48:04.776 --> 00:48:08.526 A:middle
Do It More Efficiently, specify
Quality of Service Classes

00:48:08.526 --> 00:48:11.386 A:middle
on your work-and this can
provide huge benefits both

00:48:11.386 --> 00:48:15.536 A:middle
in energy and responsiveness-and
Do It Less.

00:48:15.846 --> 00:48:17.576 A:middle
Optimize and improve
your resource use.

00:48:18.316 --> 00:48:20.626 A:middle
For more information, you
can contact Paul Danbold,

00:48:20.776 --> 00:48:22.316 A:middle
the Core OS Evangelist.

00:48:22.376 --> 00:48:24.466 A:middle
You can also check out
these talks from last year,

00:48:24.466 --> 00:48:27.076 A:middle
Energy Best Practices and
Building Resource Efficient Apps

00:48:27.436 --> 00:48:29.296 A:middle
for more depth in some of
the things we covered today.

00:48:30.426 --> 00:48:32.586 A:middle
There's a variety of related
sessions I'd highly encourage

00:48:32.586 --> 00:48:33.946 A:middle
you to check out.

00:48:33.946 --> 00:48:36.286 A:middle
Yesterday's What's New in
Foundation Networking talk went

00:48:36.286 --> 00:48:38.036 A:middle
in more depth about
the Background Session.

00:48:39.196 --> 00:48:42.056 A:middle
Improving Your App with
Instruments is a great session

00:48:42.056 --> 00:48:43.326 A:middle
to learn more about
Instruments and some

00:48:43.326 --> 00:48:44.586 A:middle
of the new features available.

00:48:45.376 --> 00:48:48.116 A:middle
Writing Energy Efficient Code,
Part 2, right here on this stage

00:48:48.116 --> 00:48:50.056 A:middle
in just a few minutes.

00:48:51.006 --> 00:48:54.666 A:middle
Testing in Xcode 6 and
the Continuous Integration

00:48:54.666 --> 00:48:56.246 A:middle
with Xcode 6 will
go into more depth

00:48:56.346 --> 00:48:58.226 A:middle
about the performance
unit tests.

00:48:58.656 --> 00:49:01.596 A:middle
Fix Bugs Faster Using Activity
Tracking is a great way


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:58.656 --> 00:49:01.596 A:middle
Fix Bugs Faster Using Activity
Tracking is a great way

00:49:01.596 --> 00:49:03.616 A:middle
to help understand the
asynchronous work your

00:49:03.616 --> 00:49:04.486 A:middle
application is doing.

00:49:05.036 --> 00:49:07.306 A:middle
And, of course, Power,
Performance, and Diagnostics,

00:49:07.626 --> 00:49:10.276 A:middle
tomorrow afternoon, will go into
much more depth about Quality

00:49:10.276 --> 00:49:12.416 A:middle
of Service Classes and
how to specify them

00:49:12.416 --> 00:49:13.926 A:middle
in a variety of layers
in the API.

00:49:15.416 --> 00:49:15.966 A:middle
Thank you.

00:49:16.516 --> 00:49:23.880 A:middle
[ Applause ]

