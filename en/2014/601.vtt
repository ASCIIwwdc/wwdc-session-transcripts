WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:12.456 A:middle
[ Music ]

00:00:12.956 --> 00:00:15.296 A:middle
&gt;&gt; Good morning and
welcome to the session.

00:00:15.966 --> 00:00:18.886 A:middle
My name is Abe Stephens,
and I'm an engineer

00:00:18.886 --> 00:00:22.156 A:middle
in the GPU Frameworks Team
at Apple, and this morning,

00:00:22.156 --> 00:00:24.686 A:middle
I'm going to tell you
about how to take advantage

00:00:24.686 --> 00:00:27.396 A:middle
of the New Mac Pro Workstation,

00:00:27.396 --> 00:00:29.856 A:middle
which is a really
exciting platform to work

00:00:29.856 --> 00:00:34.176 A:middle
with for graphics and
compute applications.

00:00:34.176 --> 00:00:39.146 A:middle
We're going to talk a
little bit about the Mac Pro

00:00:39.146 --> 00:00:42.016 A:middle
and the hardware
that it contains

00:00:42.016 --> 00:00:44.596 A:middle
and the hardware
that's available

00:00:44.676 --> 00:00:45.706 A:middle
for you as a programmer.

00:00:46.216 --> 00:00:49.516 A:middle
Then we're going to take a
look at some of the graphics

00:00:49.586 --> 00:00:54.456 A:middle
and general purpose GPU
compute APIs that you'll use

00:00:54.456 --> 00:00:57.206 A:middle
to program on this computer.

00:00:57.946 --> 00:01:01.006 A:middle
And then, at the end of the
talk, we're going to take a look


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.946 --> 00:01:01.006 A:middle
And then, at the end of the
talk, we're going to take a look

00:01:01.006 --> 00:01:03.976 A:middle
at some common patterns
that you might follow

00:01:03.976 --> 00:01:07.116 A:middle
when you're writing an
application to take advantage

00:01:07.116 --> 00:01:09.726 A:middle
of the hardware that's
available in this configuration.

00:01:09.726 --> 00:01:16.066 A:middle
So let's take a look at-let's
take a look at the Mac Pro.

00:01:16.476 --> 00:01:19.616 A:middle
And as you can see here, this
is actually the Mac Pro tower

00:01:19.616 --> 00:01:23.156 A:middle
and the new desktop.

00:01:23.156 --> 00:01:27.306 A:middle
And the tower's actually
eight times larger

00:01:27.306 --> 00:01:31.356 A:middle
than the new workstation
and it actually is only

00:01:31.356 --> 00:01:32.886 A:middle
about four times heavier.

00:01:32.886 --> 00:01:36.516 A:middle
And so there's a lot
of hardware packed

00:01:36.516 --> 00:01:37.866 A:middle
into a very small package.

00:01:38.106 --> 00:01:40.956 A:middle
And if you're an application
developer, you know,

00:01:40.956 --> 00:01:44.786 A:middle
this means that someone can
have a very powerful workstation

00:01:44.786 --> 00:01:47.706 A:middle
sitting on their desk
that you can - you know,

00:01:47.706 --> 00:01:52.546 A:middle
that can run a pretty
high-performance application

00:01:52.926 --> 00:01:54.636 A:middle
and in a much smaller
form factor

00:01:54.666 --> 00:01:58.316 A:middle
than the tower, the
tower system.

00:01:58.726 --> 00:02:02.266 A:middle
If we take a look at this
computer in some detail,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:58.726 --> 00:02:02.266 A:middle
If we take a look at this
computer in some detail,

00:02:02.606 --> 00:02:05.596 A:middle
probably the most exciting thing
as a graphics programmer is

00:02:05.596 --> 00:02:09.816 A:middle
that the Mac Pro has two
GPUs in every configuration.

00:02:10.256 --> 00:02:12.966 A:middle
And these are two
identical devices.

00:02:12.966 --> 00:02:15.656 A:middle
So, in the tower Mac Pro,

00:02:16.116 --> 00:02:18.986 A:middle
you could-a customer could
configure this system

00:02:18.986 --> 00:02:22.296 A:middle
to have multiple GPUs and
there are actually cases

00:02:22.296 --> 00:02:26.816 A:middle
in that system where you might
end up with two different GPUs

00:02:26.816 --> 00:02:30.106 A:middle
that were from different
vendors.

00:02:30.476 --> 00:02:32.826 A:middle
In the new Mac Pro, you always -

00:02:32.826 --> 00:02:35.806 A:middle
your application will always
have two identical GPUs

00:02:35.806 --> 00:02:37.296 A:middle
available to use.

00:02:37.796 --> 00:02:41.056 A:middle
And as we'll see in a little
while, that's - you know,

00:02:41.156 --> 00:02:42.996 A:middle
that's kind of an
advantage because it means

00:02:42.996 --> 00:02:45.156 A:middle
that you don't have to or
your application doesn't have

00:02:45.156 --> 00:02:49.566 A:middle
to have a lot of logic to query
and find out if the capabilities

00:02:49.566 --> 00:02:51.886 A:middle
of the available
GPUs are different.

00:02:51.886 --> 00:02:53.716 A:middle
You can write to
a single platform.

00:02:54.076 --> 00:02:57.056 A:middle
And then there are some very
specific things that you can do

00:02:57.056 --> 00:02:59.076 A:middle
to distinguish the two devices.

00:02:59.456 --> 00:03:03.526 A:middle
In this configuration, one of
the GPUs is directly connected


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.456 --> 00:03:03.526 A:middle
In this configuration, one of
the GPUs is directly connected

00:03:03.526 --> 00:03:06.236 A:middle
to the display hardware,
and the other GPU isn't.

00:03:06.596 --> 00:03:07.956 A:middle
And so there's some
specific things

00:03:07.956 --> 00:03:10.296 A:middle
that your application
can do that you can write

00:03:10.296 --> 00:03:13.036 A:middle
into your application to
take advantage of that

00:03:13.216 --> 00:03:17.076 A:middle
and to make sure that when you
are sending work, graphics work,

00:03:17.076 --> 00:03:19.506 A:middle
or compute work to
one of the GPUs,

00:03:19.506 --> 00:03:22.536 A:middle
you know which one is
connected to the display.

00:03:23.236 --> 00:03:29.196 A:middle
So inside this configuration,
the GPUs have

00:03:29.196 --> 00:03:32.716 A:middle
about two thousand
stream processors.

00:03:32.716 --> 00:03:36.126 A:middle
That's important if
you're working with OpenCL

00:03:36.126 --> 00:03:38.716 A:middle
to do general purpose
GPU compute work.

00:03:39.066 --> 00:03:42.066 A:middle
The configuration that
we'll be looking at today

00:03:42.066 --> 00:03:45.446 A:middle
when we show a demo later on
has six gigabytes of memory

00:03:45.496 --> 00:03:49.186 A:middle
and 3.5 teraflops peak.

00:03:49.446 --> 00:03:51.366 A:middle
And so it's a very
capable package

00:03:51.366 --> 00:03:54.706 A:middle
for graphics and
for GPU compute.

00:03:55.536 --> 00:04:01.666 A:middle
So now I'd like to explain some
of the APIs that you can use


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:55.536 --> 00:04:01.666 A:middle
So now I'd like to explain some
of the APIs that you can use

00:04:01.666 --> 00:04:05.276 A:middle
to program this configuration.

00:04:05.656 --> 00:04:08.806 A:middle
And if you're - if you've
worked with Apple Graphics

00:04:08.806 --> 00:04:11.996 A:middle
or Compute before, these
will be familiar to you.

00:04:12.196 --> 00:04:16.976 A:middle
Actually, you've probably used
OpenCL and OpenGL on - say,

00:04:16.976 --> 00:04:21.326 A:middle
an ordinary laptop or on a
single GPU system in the past.

00:04:21.326 --> 00:04:25.576 A:middle
Maybe you've even worked with a
tower Mac Pro and done multi-GPU

00:04:25.576 --> 00:04:26.966 A:middle
or multi-display programming.

00:04:27.476 --> 00:04:29.956 A:middle
What I'm going to talk
about in this session is,

00:04:30.566 --> 00:04:33.606 A:middle
the parts of those APIs that
you have to pay attention to

00:04:33.606 --> 00:04:35.906 A:middle
and that you have to
use when you are setting

00:04:35.906 --> 00:04:39.066 A:middle
up an application to use
this Mac Pro configuration,

00:04:39.066 --> 00:04:41.656 A:middle
because it's a little
bit different than some

00:04:41.736 --> 00:04:44.756 A:middle
of the other configurations
that have been available

00:04:44.756 --> 00:04:47.686 A:middle
in the Mac platform in the past.

00:04:48.036 --> 00:04:50.666 A:middle
Okay, so let's take a look
at the Software Stack.

00:04:51.536 --> 00:04:54.716 A:middle
So on top of the Software
Stack, is your application.

00:04:54.716 --> 00:04:57.956 A:middle
So this is your code
that you've implemented

00:04:57.956 --> 00:05:00.076 A:middle
and this might be a
graphics application


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:57.956 --> 00:05:00.076 A:middle
and this might be a
graphics application

00:05:00.076 --> 00:05:02.166 A:middle
that does some type
of 3D rendering.

00:05:02.166 --> 00:05:04.716 A:middle
It could be an application
that's doing say,

00:05:04.716 --> 00:05:07.976 A:middle
image processing or video
processing using OpenCL

00:05:08.246 --> 00:05:10.476 A:middle
or GPU - for GPU compute.

00:05:10.686 --> 00:05:12.536 A:middle
Maybe your application
does a little bit of OpenCL

00:05:12.576 --> 00:05:15.616 A:middle
and a little bit of OpenGL to
fully take advantage of the GPU.

00:05:16.456 --> 00:05:20.276 A:middle
Anyway, the first sort of
level of GPU programming

00:05:20.276 --> 00:05:23.616 A:middle
that you might have in
your app is some Cocoa code

00:05:23.616 --> 00:05:29.506 A:middle
that is using an
NSOpenGLView or a CAOpenGLLayer.

00:05:29.966 --> 00:05:35.106 A:middle
And I'm going to show you
how to configure this level

00:05:35.106 --> 00:05:39.496 A:middle
of the software to correctly set
up or to set up your application

00:05:39.806 --> 00:05:42.176 A:middle
to take advantage of the
two GPUs in the Mac Pro

00:05:42.176 --> 00:05:43.196 A:middle
in the most efficient way.

00:05:43.236 --> 00:05:46.446 A:middle
And then on top of
the next sort of level

00:05:46.446 --> 00:05:50.036 A:middle
on this stack are a
number of lower level APIs.

00:05:50.856 --> 00:05:54.016 A:middle
The CGL API is something
that you may be familiar

00:05:54.016 --> 00:05:56.766 A:middle
with in the Mac from
other systems.

00:05:57.026 --> 00:06:01.606 A:middle
It's a lower level API that you
can use to configure the GPU


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:57.026 --> 00:06:01.606 A:middle
It's a lower level API that you
can use to configure the GPU

00:06:01.606 --> 00:06:04.526 A:middle
and to find out information
about the displays

00:06:04.656 --> 00:06:07.356 A:middle
and the hardware
that's in the system.

00:06:07.766 --> 00:06:10.236 A:middle
Then, the few other
sort of programming APIs

00:06:10.236 --> 00:06:14.206 A:middle
that you're quite familiar
with, OpenCL and OpenGL,

00:06:14.206 --> 00:06:19.336 A:middle
which are the APIs that you'll
end up writing a lot of the code

00:06:19.336 --> 00:06:24.576 A:middle
that dispatches work to the GPU
and also the kernels and shaders

00:06:24.576 --> 00:06:26.926 A:middle
that are executed
on the GPU itself.

00:06:26.926 --> 00:06:31.416 A:middle
And then of course,
underneath OpenCL and OpenGL,

00:06:31.416 --> 00:06:32.496 A:middle
there's some graphics drivers.

00:06:32.766 --> 00:06:34.676 A:middle
And these graphics
drivers are handling things

00:06:34.676 --> 00:06:38.256 A:middle
like allocating memory on
the devices and moving memory

00:06:38.836 --> 00:06:40.436 A:middle
between the host and the device.

00:06:40.436 --> 00:06:44.766 A:middle
And we'll look at certain
parts of the driver that end

00:06:44.846 --> 00:06:47.286 A:middle
up performing some of the
standard movement for us

00:06:47.286 --> 00:06:50.216 A:middle
and we'll try to understand
exactly how this will impact the

00:06:50.216 --> 00:06:51.676 A:middle
way that we design applications.

00:06:52.406 --> 00:06:54.646 A:middle
So now I'm going to
talk about OpenCL

00:06:54.646 --> 00:06:57.146 A:middle
and OpenGL in some detail.

00:06:57.146 --> 00:07:01.056 A:middle
And most of the programming that
we'll see in a little while,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.146 --> 00:07:01.056 A:middle
And most of the programming that
we'll see in a little while,

00:07:01.186 --> 00:07:04.316 A:middle
is going to focus on
this level of the stack.

00:07:04.396 --> 00:07:06.786 A:middle
The CGL, OpenCL and
OpenGL layer.

00:07:07.606 --> 00:07:11.156 A:middle
So, on the Mac Pro,
we support OpenGL.

00:07:11.356 --> 00:07:15.336 A:middle
It's our accelerated
3D rendering API.

00:07:15.436 --> 00:07:20.896 A:middle
And we support OpenGL 4.1
Core Profile and the shaders

00:07:20.896 --> 00:07:23.786 A:middle
that you write that are
executed on the GPU are written

00:07:23.786 --> 00:07:25.466 A:middle
in a language called GLSL.

00:07:25.466 --> 00:07:28.956 A:middle
And we support version 4.10.

00:07:29.396 --> 00:07:32.616 A:middle
And, OpenCL is the data
parallel programming API

00:07:32.806 --> 00:07:34.576 A:middle
that the Mac Pro supports.

00:07:35.386 --> 00:07:41.116 A:middle
And it is-the version that
is supported is OpenCL 1.2

00:07:41.116 --> 00:07:42.416 A:middle
with a number of extensions.

00:07:42.876 --> 00:07:49.346 A:middle
So the Mac Pro has a pretty
advanced AMD graphics card, er,

00:07:49.346 --> 00:07:50.676 A:middle
a pair of AMD graphics cards.

00:07:51.016 --> 00:07:53.166 A:middle
And there are a couple
extensions that are supported,

00:07:53.166 --> 00:07:56.666 A:middle
so on the Mac Pro you
can use double precision.

00:07:57.136 --> 00:07:59.626 A:middle
And there's actually an
extension that allows you

00:07:59.626 --> 00:08:03.536 A:middle
to set the priority of
the OpenCL command queues


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.626 --> 00:08:03.536 A:middle
to set the priority of
the OpenCL command queues

00:08:03.536 --> 00:08:07.236 A:middle
that are used when you
enqueue work onto the GPU.

00:08:07.236 --> 00:08:09.726 A:middle
And so for example,
on this configuration,

00:08:09.726 --> 00:08:13.566 A:middle
you can set up a work or
an OpenCL command queue

00:08:13.656 --> 00:08:16.346 A:middle
for background priority work.

00:08:16.716 --> 00:08:19.086 A:middle
Say, for example, if you
are performing an operation

00:08:19.086 --> 00:08:23.176 A:middle
that isn't related to the
GUI and can be performed

00:08:23.426 --> 00:08:26.096 A:middle
at a lower priority, maybe
you're applying some type

00:08:26.096 --> 00:08:30.426 A:middle
of final render to an image
processing application,

00:08:30.426 --> 00:08:33.436 A:middle
you can send that work off
to a lower priority queue.

00:08:33.966 --> 00:08:39.116 A:middle
And then a if higher priority
work comes to the GPU,

00:08:39.416 --> 00:08:42.996 A:middle
that work won't interfere-or
the lower priority work won't

00:08:42.996 --> 00:08:48.016 A:middle
interfere, say, with rendering
work that was being used

00:08:48.016 --> 00:08:49.356 A:middle
to display the GUI
in the system.

00:08:50.076 --> 00:08:56.116 A:middle
And so, if you take advantage of
these extensions, you can work

00:08:56.116 --> 00:08:59.896 A:middle
around some of the
challenges that we'll talk

00:08:59.896 --> 00:09:00.906 A:middle
about in a little while.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.896 --> 00:09:00.906 A:middle
about in a little while.

00:09:01.626 --> 00:09:10.126 A:middle
Okay, so when you have this
computer and the GPUs that are

00:09:10.126 --> 00:09:15.266 A:middle
in it, you can do a couple
different things actually.

00:09:15.266 --> 00:09:18.596 A:middle
You can take advantage
of this second device.

00:09:18.996 --> 00:09:21.826 A:middle
One thing that you can do is
you can take, say, the OpenCL,

00:09:22.216 --> 00:09:26.026 A:middle
the compute portion of your
application and simply run

00:09:26.026 --> 00:09:29.246 A:middle
that compute portion
on the second device,

00:09:29.246 --> 00:09:32.566 A:middle
and let the primary GPU
be continued to be used

00:09:32.636 --> 00:09:37.956 A:middle
for GUI rendering and for
maybe OpenGL 3D graphics.

00:09:38.516 --> 00:09:42.346 A:middle
And this is actually
a relatively easy type

00:09:42.346 --> 00:09:43.416 A:middle
of operation to perform.

00:09:43.416 --> 00:09:47.616 A:middle
You can sort of offload
compute work to the second GPU.

00:09:47.616 --> 00:09:50.106 A:middle
This is kind of similar to
if you took an application

00:09:50.106 --> 00:09:52.246 A:middle
to where you were, say, running
most of your compute work

00:09:52.246 --> 00:09:55.946 A:middle
on the CPU and you decided
to move some of that work

00:09:55.946 --> 00:09:58.326 A:middle
from the CPU off
to a GPU in OpenCL,

00:09:58.656 --> 00:10:00.446 A:middle
we would perform
the same operation.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.656 --> 00:10:00.446 A:middle
we would perform
the same operation.

00:10:00.446 --> 00:10:01.526 A:middle
We'd take that compute work

00:10:01.526 --> 00:10:03.466 A:middle
and just move it to
the secondary GPU.

00:10:04.126 --> 00:10:09.216 A:middle
Another common design or another
common task that you might use

00:10:09.216 --> 00:10:11.526 A:middle
for the Mac Pro is to
perform off-screen rendering

00:10:11.526 --> 00:10:11.976 A:middle
on the second GPU.

00:10:12.206 --> 00:10:17.506 A:middle
So, if you were going to
do some type OpenGL work,

00:10:17.986 --> 00:10:21.366 A:middle
and that the results of that
work don't necessarily have

00:10:21.366 --> 00:10:25.596 A:middle
to be displayed, every single
frame, that's a great candidate

00:10:25.596 --> 00:10:28.646 A:middle
for moving to the
secondary GPU as well.

00:10:28.826 --> 00:10:30.186 A:middle
And we'll take a
look at an example

00:10:30.186 --> 00:10:31.596 A:middle
of that in a little while.

00:10:32.776 --> 00:10:35.856 A:middle
So let me tell you about how
to set up your application

00:10:35.856 --> 00:10:40.646 A:middle
to use this configuration and
to take advantage of both GPUs.

00:10:40.646 --> 00:10:43.606 A:middle
And it's important to know that,

00:10:44.286 --> 00:10:46.646 A:middle
if you have an application
that's running on a Mac

00:10:46.946 --> 00:10:50.086 A:middle
and using OpenCL and
OpenGL, it will run just fine

00:10:50.316 --> 00:10:52.826 A:middle
on the new Mac Pro, but
there are a couple things

00:10:52.826 --> 00:10:54.026 A:middle
that you can do to make sure

00:10:54.026 --> 00:10:57.466 A:middle
that it's using one
GPU or the other.

00:10:57.946 --> 00:11:01.576 A:middle
And also a couple things
that you can do to make sure


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:57.946 --> 00:11:01.576 A:middle
And also a couple things
that you can do to make sure

00:11:01.576 --> 00:11:04.486 A:middle
that if it's possible, you
can divide your application

00:11:04.486 --> 00:11:08.636 A:middle
into pieces and run one piece
of the work on the first GPU

00:11:08.636 --> 00:11:10.396 A:middle
and the other piece of
the work on the second GPU

00:11:10.666 --> 00:11:11.876 A:middle
with a small number of changes.

00:11:11.876 --> 00:11:16.066 A:middle
So to get started with
modifying the application,

00:11:16.066 --> 00:11:18.866 A:middle
there are a number or steps
that you can go through.

00:11:18.866 --> 00:11:19.776 A:middle
There are four steps.

00:11:20.776 --> 00:11:23.216 A:middle
There's creating the
context that you're using.

00:11:23.686 --> 00:11:26.636 A:middle
This is either the
OpenCL context

00:11:26.636 --> 00:11:28.856 A:middle
or the OpenGL context
in a specific way.

00:11:28.886 --> 00:11:32.306 A:middle
And if you follow
this procedure,

00:11:32.706 --> 00:11:36.226 A:middle
the runtime in the system
will be able to do a lot

00:11:36.286 --> 00:11:38.186 A:middle
of the tasks associated
with moving data

00:11:38.186 --> 00:11:41.676 A:middle
between the two devices and
between the host automatically.

00:11:42.246 --> 00:11:48.496 A:middle
Then, your application
should identify what happens

00:11:48.646 --> 00:11:51.946 A:middle
or actually it should identify
which device is the primary GPU

00:11:51.946 --> 00:11:53.346 A:middle
and which is the secondary GPU.

00:11:53.346 --> 00:11:55.746 A:middle
Then once you've
figured that out,

00:11:55.786 --> 00:11:58.986 A:middle
you can dispatch work
in a particular way.

00:11:58.986 --> 00:12:00.176 A:middle
And I'll show you
how to do that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.986 --> 00:12:00.176 A:middle
And I'll show you
how to do that.

00:12:00.296 --> 00:12:03.356 A:middle
The way that you select
the GPU and send work

00:12:03.356 --> 00:12:06.956 A:middle
to it is a little bit
different in OpenCL and OpenGL.

00:12:06.956 --> 00:12:10.916 A:middle
And then after you've done
that, you can synchronize data

00:12:11.286 --> 00:12:14.286 A:middle
between the two devices
or offload data

00:12:14.286 --> 00:12:18.226 A:middle
from the secondary GPU to
the host's main memory.

00:12:19.146 --> 00:12:22.696 A:middle
So, let's take a look
now at context creation.

00:12:23.276 --> 00:12:28.626 A:middle
And it turns out that this
process is, it's similar

00:12:28.626 --> 00:12:30.326 A:middle
in OpenCL and OpenGL,

00:12:30.326 --> 00:12:33.096 A:middle
but there's some specific
terminology that I'd like to go

00:12:33.096 --> 00:12:37.116 A:middle
over that I think will make the
process a little bit more clear.

00:12:38.206 --> 00:12:43.776 A:middle
So before we showed the
Software Stack, now we're going

00:12:43.776 --> 00:12:48.496 A:middle
to concentrate on the
graphics APIs in the stack.

00:12:48.526 --> 00:12:54.196 A:middle
So, OpenGL is our graphics
API and, like I said before,

00:12:54.396 --> 00:12:56.926 A:middle
CGL is this API that we use.

00:12:56.926 --> 00:12:59.306 A:middle
It's a Mac platform API.

00:12:59.876 --> 00:13:03.056 A:middle
And we use it to set
up our OpenGL context


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.876 --> 00:13:03.056 A:middle
And we use it to set
up our OpenGL context

00:13:03.286 --> 00:13:05.886 A:middle
and to select devices
in the system and figure

00:13:05.886 --> 00:13:09.266 A:middle
out get some information
about the hardware that's

00:13:09.266 --> 00:13:11.146 A:middle
in the system, the
devices and the renderers.

00:13:11.516 --> 00:13:16.276 A:middle
And we also have OpenCL, and
it turns out that, in OpenCL,

00:13:16.276 --> 00:13:20.466 A:middle
a lot of the operations that we
were going to perform in CGL,

00:13:20.466 --> 00:13:22.356 A:middle
about learning about displays

00:13:22.356 --> 00:13:26.006 A:middle
and devices are actually
included in that OpenCL API.

00:13:26.306 --> 00:13:29.916 A:middle
And so as I walk through this,
I'm going to show you an example

00:13:29.916 --> 00:13:35.006 A:middle
of how to perform an operation
using the graphics APIs,

00:13:35.216 --> 00:13:36.606 A:middle
OpenGL and CGL.

00:13:36.606 --> 00:13:38.026 A:middle
And then I'll also show you how

00:13:38.026 --> 00:13:40.456 A:middle
to perform the same
operation using OpenCL.

00:13:41.106 --> 00:13:42.236 A:middle
And in most cases,

00:13:42.266 --> 00:13:45.506 A:middle
we're performing very
similar tasks or operations.

00:13:45.506 --> 00:13:51.266 A:middle
We're just using two
different APIs to do that.

00:13:51.486 --> 00:13:53.466 A:middle
Okay, so the first
thing to think

00:13:53.466 --> 00:13:57.906 A:middle
about in OpenGL is the notion
of a piece of hardware.

00:13:58.286 --> 00:14:01.656 A:middle
And in OpenGL, there
are a certain number


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.286 --> 00:14:01.656 A:middle
And in OpenGL, there
are a certain number

00:14:01.656 --> 00:14:03.046 A:middle
of renderers in the system.

00:14:03.566 --> 00:14:06.566 A:middle
And each renderer is
assigned a render ID number.

00:14:07.266 --> 00:14:11.746 A:middle
So for example, in the Mac Pro,
there's going to be one renderer

00:14:11.746 --> 00:14:15.476 A:middle
for each of the GPUs, and then
there will also be a software

00:14:15.476 --> 00:14:17.966 A:middle
fallback renderer that's
available on all Macs

00:14:18.386 --> 00:14:22.506 A:middle
that the system can
use if, for example,

00:14:22.506 --> 00:14:24.166 A:middle
if you were on a configuration

00:14:24.166 --> 00:14:28.326 A:middle
that didn't have hardware
support for a certain feature,

00:14:28.326 --> 00:14:32.176 A:middle
the system might fall back
to this software renderer.

00:14:32.326 --> 00:14:34.956 A:middle
And so, if you look at the
render IDs in the system,

00:14:34.956 --> 00:14:40.706 A:middle
you'd see two render IDs for the
two discreet GPUs, and then one

00:14:41.006 --> 00:14:45.686 A:middle
for the software renderer GPU.

00:14:46.356 --> 00:14:49.966 A:middle
So when you start to
set up an OpenGL context

00:14:50.376 --> 00:14:55.366 A:middle
and an OpenGL application, you
have to figure out how to select

00:14:55.366 --> 00:14:56.826 A:middle
between all of these
different renderers

00:14:56.826 --> 00:14:58.476 A:middle
and these different
render IDs in the system.

00:14:58.786 --> 00:15:03.076 A:middle
And in OpenGL, you do that
by putting together a list


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.786 --> 00:15:03.076 A:middle
And in OpenGL, you do that
by putting together a list

00:15:03.076 --> 00:15:03.906 A:middle
of attributes.

00:15:04.166 --> 00:15:05.906 A:middle
These are called pixel
format attributes.

00:15:06.016 --> 00:15:09.746 A:middle
And these are things like, does
the renderer you're looking

00:15:09.826 --> 00:15:11.246 A:middle
for support double buffering?

00:15:11.716 --> 00:15:15.946 A:middle
Does it support a
certain color format

00:15:16.056 --> 00:15:17.976 A:middle
or a certain depth format?

00:15:17.976 --> 00:15:21.416 A:middle
Does it support Core profile
or legacy profile OpenGL?

00:15:21.776 --> 00:15:24.336 A:middle
Anyway, you put together
this list of attributes

00:15:24.716 --> 00:15:29.516 A:middle
and one important attribute for
setting up an OpenGL application

00:15:29.516 --> 00:15:32.986 A:middle
on the new Mac Pro is the
offline renderers attribute.

00:15:33.296 --> 00:15:36.616 A:middle
Now, the Mac Pro
has two GPUs and one

00:15:36.616 --> 00:15:38.806 A:middle
of those GPUs is
always connected

00:15:38.976 --> 00:15:41.776 A:middle
to the display hardware
that's in the Mac Pro.

00:15:41.986 --> 00:15:43.066 A:middle
The other GPU isn't.

00:15:43.566 --> 00:15:46.816 A:middle
And the terminology for
this on the Mac platform is

00:15:46.816 --> 00:15:50.426 A:middle
that the display connected
GPU is considered "online",

00:15:50.906 --> 00:15:53.216 A:middle
and the GPU that's not connected

00:15:53.266 --> 00:15:55.676 A:middle
to the display is
considered "offline".

00:15:56.026 --> 00:15:59.896 A:middle
Now, it turns out that you
know, both GPUs are powered up

00:15:59.896 --> 00:16:03.316 A:middle
and both can perform rendering
and compute operations,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.896 --> 00:16:03.316 A:middle
and both can perform rendering
and compute operations,

00:16:03.366 --> 00:16:05.936 A:middle
but the terminology is that
the one that's connected

00:16:05.936 --> 00:16:08.286 A:middle
to the display hardware
is "online",

00:16:08.596 --> 00:16:09.836 A:middle
and the other one's "offline".

00:16:10.016 --> 00:16:13.886 A:middle
So we when we put together a
pixel format attribute list,

00:16:14.336 --> 00:16:17.026 A:middle
we add an attribute
that says that we want

00:16:17.066 --> 00:16:20.136 A:middle
to include offline renderers.

00:16:20.416 --> 00:16:24.436 A:middle
And then, when we send
that into the system

00:16:24.436 --> 00:16:27.496 A:middle
and we call the Choose
Pixel Format API routine,

00:16:27.636 --> 00:16:29.996 A:middle
and we'll look at that in a
second at what that looks like.

00:16:30.396 --> 00:16:32.816 A:middle
We're going to get back
a list of the renderers

00:16:33.106 --> 00:16:34.756 A:middle
of all the renderers
in the system.

00:16:34.756 --> 00:16:38.276 A:middle
In this case, we're going to
get both GPUs - the online GPU

00:16:38.276 --> 00:16:42.066 A:middle
and the offline GPU and
then the software renderer.

00:16:42.066 --> 00:16:45.746 A:middle
Now, the next step in this
context creation process is

00:16:45.976 --> 00:16:47.496 A:middle
to actually create the context.

00:16:47.496 --> 00:16:50.776 A:middle
And this is really just
a container that points

00:16:50.776 --> 00:16:53.916 A:middle
to these renderers and
associates state with them.

00:16:53.916 --> 00:16:56.006 A:middle
So there's a lot of
state in the OpenGL API

00:16:56.006 --> 00:17:00.196 A:middle
and that state is associated
with this context object.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:56.006 --> 00:17:00.196 A:middle
and that state is associated
with this context object.

00:17:00.946 --> 00:17:06.836 A:middle
Now, once we have a context,
we need a way for that context

00:17:06.925 --> 00:17:09.476 A:middle
to refer back to the renderers.

00:17:09.536 --> 00:17:11.086 A:middle
And this is actually
a difference

00:17:11.086 --> 00:17:12.876 A:middle
between OpenCL and OpenGL.

00:17:13.296 --> 00:17:19.406 A:middle
In OpenGL, the context assigns
virtual screen numbers to each

00:17:19.406 --> 00:17:21.136 A:middle
of the renderers that
are in the system.

00:17:21.496 --> 00:17:23.986 A:middle
And so here we have a
context with three renderers,

00:17:23.986 --> 00:17:27.705 A:middle
and we have virtual screen
numbers, zero through two.

00:17:28.415 --> 00:17:31.776 A:middle
Now, the last piece of
terminology I want to go

00:17:31.776 --> 00:17:34.286 A:middle
over in OpenGL before
we start talking

00:17:34.286 --> 00:17:37.556 A:middle
about OpenCL, is
the share group.

00:17:37.916 --> 00:17:41.286 A:middle
If you have a context,
now remember,

00:17:41.286 --> 00:17:42.946 A:middle
a context is that
state container.

00:17:43.396 --> 00:17:46.846 A:middle
If you have a context, and
you want to set some state

00:17:46.846 --> 00:17:49.736 A:middle
and create some objects
and then maybe you decide

00:17:49.736 --> 00:17:53.116 A:middle
that you need another thread
to do some OpenGL work

00:17:53.396 --> 00:17:55.436 A:middle
and maybe it's going to have
slightly different state,

00:17:55.786 --> 00:17:59.346 A:middle
you can create another
context that has the same set

00:17:59.346 --> 00:18:03.676 A:middle
of renderers in it
and can share objects,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.346 --> 00:18:03.676 A:middle
of renderers in it
and can share objects,

00:18:04.506 --> 00:18:05.766 A:middle
serve buffers and textures.

00:18:06.126 --> 00:18:09.386 A:middle
And you would obtain a share
group from the first context

00:18:09.386 --> 00:18:12.886 A:middle
and use that to create
or to communicate

00:18:12.886 --> 00:18:14.046 A:middle
with a second context.

00:18:14.386 --> 00:18:17.436 A:middle
So a share group in
OpenGL terminology

00:18:17.836 --> 00:18:20.696 A:middle
and CGL terminology
is this entity

00:18:20.696 --> 00:18:24.966 A:middle
that lets you bridge
two OpenGL contexts.

00:18:25.266 --> 00:18:28.156 A:middle
And that's important because,
as we'll see in a second,

00:18:28.486 --> 00:18:32.556 A:middle
we can also use that share
group to communicate its objects

00:18:32.556 --> 00:18:35.546 A:middle
and state between
OpenGL and OpenCL.

00:18:36.136 --> 00:18:40.876 A:middle
Okay, so let's look at what
the equivalent operations

00:18:41.006 --> 00:18:44.486 A:middle
and components are
of the OpenCL API.

00:18:44.656 --> 00:18:50.286 A:middle
Now, OpenCL has device IDs which
are kind of like renderers.

00:18:50.286 --> 00:18:56.006 A:middle
A CL context object, that's
a lot like that GL context,

00:18:56.006 --> 00:18:59.256 A:middle
and then a command queue, which
as it turns out is a little bit

00:18:59.256 --> 00:19:00.316 A:middle
like the virtual screen.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.256 --> 00:19:00.316 A:middle
like the virtual screen.

00:19:00.316 --> 00:19:01.586 A:middle
We use it in a similar way.

00:19:02.166 --> 00:19:04.906 A:middle
The API is presented in a
slightly different fashion,

00:19:04.906 --> 00:19:07.216 A:middle
but these operations
are very similar.

00:19:07.216 --> 00:19:11.626 A:middle
Now, our CL context is
something-it's a lot

00:19:11.626 --> 00:19:13.856 A:middle
like a GL context.

00:19:14.206 --> 00:19:18.586 A:middle
It turns out, when we
set up our CL context,

00:19:18.586 --> 00:19:21.066 A:middle
we actually are going to set
it up using, in some cases,

00:19:21.366 --> 00:19:24.306 A:middle
a share group that we
obtain from a GL context.

00:19:24.306 --> 00:19:26.766 A:middle
And I'll show you what that
looks like in just a moment.

00:19:27.586 --> 00:19:30.926 A:middle
Okay so, now that I've
described the terminology,

00:19:30.926 --> 00:19:33.346 A:middle
and remember the, you know,
the term-there's a lot

00:19:33.346 --> 00:19:36.956 A:middle
of terminology in OpenGL
and there's some terminology

00:19:36.956 --> 00:19:40.546 A:middle
in OpenCL, but the two
APIs are performing very

00:19:40.546 --> 00:19:41.556 A:middle
similar operations.

00:19:41.836 --> 00:19:44.116 A:middle
Let's take a look at the
API that you have to use

00:19:44.476 --> 00:19:48.206 A:middle
when you set up, when you start
to set up your application

00:19:48.206 --> 00:19:51.876 A:middle
for working on the Mac Pro
with OpenCL and OpenGL.

00:19:51.876 --> 00:19:53.186 A:middle
So, let's say that we're

00:19:53.186 --> 00:19:57.306 A:middle
in an application that's using
an NSOpenGLView in Cocoa.

00:19:58.106 --> 00:20:02.216 A:middle
Now, I'm going to create
an NSOpenGLView and I'd


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.106 --> 00:20:02.216 A:middle
Now, I'm going to create
an NSOpenGLView and I'd

00:20:02.216 --> 00:20:03.746 A:middle
like to use the Core profile.

00:20:04.246 --> 00:20:06.956 A:middle
So I'd like to use the
newest features in OpenGL.

00:20:07.046 --> 00:20:09.096 A:middle
And so I'd like to make sure

00:20:09.096 --> 00:20:12.406 A:middle
that I get a Core
profile OpenGL context.

00:20:12.636 --> 00:20:15.796 A:middle
And in order to do that
with an NSOpenGLView,

00:20:15.796 --> 00:20:21.226 A:middle
I have to implement my
own NSOpenGLView class

00:20:21.276 --> 00:20:24.406 A:middle
that is derived from
the Cocoa base class.

00:20:24.826 --> 00:20:29.066 A:middle
And then I would
implement my own version

00:20:29.176 --> 00:20:32.566 A:middle
of the initWithFrame
method and in that function,

00:20:32.566 --> 00:20:35.486 A:middle
I'm going to set up my
pixel formal attribute list.

00:20:36.096 --> 00:20:38.166 A:middle
And as you can see
here, at the top,

00:20:38.586 --> 00:20:43.036 A:middle
I included the Core
profile attribute and then

00:20:43.086 --> 00:20:45.246 A:middle
at the very bottom-and
this is the important piece

00:20:45.246 --> 00:20:48.876 A:middle
for the Mac Pro-at the bottom,
I also said that I wanted

00:20:48.876 --> 00:20:50.376 A:middle
to allow offline renderers.

00:20:50.376 --> 00:20:54.856 A:middle
And now when I create a GL
context using this pixel format

00:20:54.856 --> 00:20:59.336 A:middle
attribute list by passing it up
to the super class, when I go

00:20:59.336 --> 00:21:03.086 A:middle
and do that, I'll get a context
object initialize that has all


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.336 --> 00:21:03.086 A:middle
and do that, I'll get a context
object initialize that has all

00:21:03.086 --> 00:21:04.336 A:middle
of the devices in the system.

00:21:04.666 --> 00:21:07.316 A:middle
And that's really
the important part.

00:21:07.426 --> 00:21:09.746 A:middle
Okay, let's see how
to do that in OpenCL.

00:21:09.746 --> 00:21:14.476 A:middle
Well, if you're in an
ordinary OpenCL application,

00:21:14.476 --> 00:21:16.956 A:middle
that's an application
that is just going

00:21:16.956 --> 00:21:20.536 A:middle
to do some OpenCL programming,
it's not going to do anything

00:21:20.866 --> 00:21:24.106 A:middle
where there is sharing
between OpenCL and OpenGL.

00:21:24.106 --> 00:21:27.636 A:middle
The easiest way to get a context
that has all the GPU devices

00:21:27.706 --> 00:21:30.066 A:middle
in it, is just to create
a context with a type.

00:21:30.796 --> 00:21:33.776 A:middle
So here, I'm calling
clCreateContextWithType

00:21:33.776 --> 00:21:36.806 A:middle
and I'm asking for CL Type GPU.

00:21:37.026 --> 00:21:39.606 A:middle
That's going to give me a
CL context that contains all

00:21:39.606 --> 00:21:40.776 A:middle
of the GPUs in the system.

00:21:41.436 --> 00:21:43.916 A:middle
On the Mac Pro, that means
that I'm going to get a context

00:21:43.916 --> 00:21:47.826 A:middle
that has two device IDs, one
for each of the discreet GPUs.

00:21:47.996 --> 00:21:50.766 A:middle
Now, if we were in an
application that was going

00:21:50.766 --> 00:21:53.096 A:middle
to do some OpenCL
and some OpenGL,

00:21:53.426 --> 00:21:55.616 A:middle
and those operations were going
to interact with each other,

00:21:56.066 --> 00:21:59.156 A:middle
I'd want to create a context
in a slightly different way.

00:21:59.916 --> 00:22:03.136 A:middle
So here what I'm doing,
is I've created already


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.916 --> 00:22:03.136 A:middle
So here what I'm doing,
is I've created already

00:22:03.336 --> 00:22:09.276 A:middle
in my previous slide, I
set up my NSOpenGLView.

00:22:09.616 --> 00:22:12.906 A:middle
And then I would obtain
the context object

00:22:12.906 --> 00:22:15.216 A:middle
from that NSOpenGLView.

00:22:15.416 --> 00:22:18.116 A:middle
And then you can see here,
I'm using the CGL API

00:22:18.766 --> 00:22:24.526 A:middle
to get the share group that is
associated with that GL context.

00:22:25.086 --> 00:22:27.616 A:middle
Then I take the share group,
remember the share group is

00:22:27.616 --> 00:22:32.736 A:middle
that entity that we use to
create a pair of contexts

00:22:32.736 --> 00:22:35.736 A:middle
that operate on the same objects
and use the same devices.

00:22:36.496 --> 00:22:39.916 A:middle
I use that share group
now with clCreateContext

00:22:40.416 --> 00:22:44.656 A:middle
and another property list
to create a CL context

00:22:44.656 --> 00:22:47.216 A:middle
that contains the
same devices that were

00:22:47.216 --> 00:22:49.726 A:middle
in that original GL context.

00:22:49.726 --> 00:22:51.026 A:middle
And now what I'm going
to do is I'm going to end

00:22:51.026 --> 00:22:54.476 A:middle
up with my CL context here, C,

00:22:54.736 --> 00:22:57.336 A:middle
that contains all the
GPUs in the Mac Pro.

00:22:57.336 --> 00:22:58.756 A:middle
And that's really
the important part.

00:22:58.756 --> 00:23:02.856 A:middle
It's very important that
I always create a context


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.756 --> 00:23:02.856 A:middle
It's very important that
I always create a context

00:23:02.986 --> 00:23:06.806 A:middle
in either API or in this case,
I've created a GL context

00:23:06.806 --> 00:23:08.116 A:middle
and then a CL context

00:23:08.836 --> 00:23:11.626 A:middle
that contains all the
devices in the system.

00:23:12.106 --> 00:23:14.806 A:middle
Okay, so now that
I've done this,

00:23:14.806 --> 00:23:18.366 A:middle
now that I have this very
versatile and flexible context,

00:23:18.636 --> 00:23:22.416 A:middle
the next step is to take a
look inside it and figure

00:23:22.416 --> 00:23:25.886 A:middle
out which device
corresponds to the primary GPU

00:23:25.886 --> 00:23:28.476 A:middle
and which device corresponds
to the secondary GPU.

00:23:28.936 --> 00:23:32.086 A:middle
And so that's important
because, if I'm doing a task

00:23:32.156 --> 00:23:34.866 A:middle
that is going to be, the
results of which are going

00:23:34.866 --> 00:23:36.836 A:middle
to be displayed on the screen,
it might make sense for me

00:23:36.836 --> 00:23:39.466 A:middle
to use the primary GPU first

00:23:40.086 --> 00:23:42.286 A:middle
because it's directly
connected to display hardware.

00:23:42.486 --> 00:23:46.156 A:middle
And then maybe if I have a task
that isn't related to the GUI

00:23:46.156 --> 00:23:49.616 A:middle
or isn't related to the display,
I might want to always send

00:23:49.616 --> 00:23:51.846 A:middle
that task to the secondary GPU.

00:23:52.296 --> 00:23:56.166 A:middle
So if I look at the OpenCL
API and the OpenGL API,

00:23:56.866 --> 00:23:58.896 A:middle
it turns out there are a
number of different queries

00:23:58.896 --> 00:24:01.946 A:middle
that I can make, but
since the two devices


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.896 --> 00:24:01.946 A:middle
that I can make, but
since the two devices

00:24:01.946 --> 00:24:04.556 A:middle
in the Mac Pro are identical,
all of those queries,

00:24:04.556 --> 00:24:06.276 A:middle
all those CL device
info queries,

00:24:06.546 --> 00:24:08.636 A:middle
are going to return
exactly the same information

00:24:08.636 --> 00:24:09.666 A:middle
for both devices.

00:24:10.196 --> 00:24:12.726 A:middle
In order to distinguish
the two devices,

00:24:12.726 --> 00:24:13.976 A:middle
we have to do something
different.

00:24:14.746 --> 00:24:17.856 A:middle
So what we're trying to do
here, is we'd like to figure

00:24:17.856 --> 00:24:22.656 A:middle
out which GPU is the online
one-that's the primary GPU-and

00:24:22.656 --> 00:24:25.536 A:middle
which GPU is the offline one,
that's the secondary GPU.

00:24:25.536 --> 00:24:27.196 A:middle
And then we're going
to try to figure

00:24:27.196 --> 00:24:29.086 A:middle
out what its virtual
screen number is

00:24:29.086 --> 00:24:33.156 A:middle
if we're doing OpenGL work, or
what the CL device ID is for it

00:24:33.156 --> 00:24:35.506 A:middle
if we're doing OpenCL work.

00:24:36.616 --> 00:24:39.006 A:middle
Okay, so let's walk
through some code here.

00:24:39.486 --> 00:24:41.896 A:middle
This is the process that
you go through to decide

00:24:42.286 --> 00:24:45.336 A:middle
which GPU is the primary
GPU or the secondary GPU.

00:24:46.246 --> 00:24:48.606 A:middle
In this particular example,
I'm going to be looking

00:24:48.606 --> 00:24:49.996 A:middle
for the secondary GPU.

00:24:49.996 --> 00:24:52.316 A:middle
So I'm going to go through
a bunch of steps here

00:24:52.756 --> 00:24:55.876 A:middle
where I issue some queries
against the system to figure

00:24:55.876 --> 00:24:58.616 A:middle
out which GPU is
the offline GPU.

00:24:59.076 --> 00:25:04.096 A:middle
So the first thing that I do
is I iterate the renderers


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.076 --> 00:25:04.096 A:middle
So the first thing that I do
is I iterate the renderers

00:25:04.096 --> 00:25:04.726 A:middle
in the system.

00:25:05.096 --> 00:25:09.656 A:middle
I obtain these using this
CGLQueryRendererInfo call.

00:25:10.076 --> 00:25:14.356 A:middle
I iterate over all of the
renderers and I ask the system,

00:25:14.846 --> 00:25:16.646 A:middle
"Is the renderer
online or offline?"

00:25:17.026 --> 00:25:21.436 A:middle
So this will actually tell
me, once I get past this step,

00:25:21.436 --> 00:25:25.746 A:middle
I'll know if I have that GPU
that's connected to display

00:25:25.836 --> 00:25:29.136 A:middle
and that's online, or
the one that's offline.

00:25:29.136 --> 00:25:31.286 A:middle
Of course, as I mentioned
earlier,

00:25:31.456 --> 00:25:33.136 A:middle
there are some other
renderers in the system.

00:25:33.136 --> 00:25:36.536 A:middle
There's the software renderer
and I have to make sure

00:25:36.536 --> 00:25:40.746 A:middle
that I am able to distinguish
between the offline GPU

00:25:40.746 --> 00:25:41.896 A:middle
and the software
renderer and so,

00:25:42.156 --> 00:25:43.296 A:middle
we'll do that in just a second.

00:25:43.336 --> 00:25:46.836 A:middle
So, if I find the GPU that's
offline, I then check to see

00:25:46.836 --> 00:25:49.156 A:middle
if it supports accelerated
compute.

00:25:49.156 --> 00:25:51.366 A:middle
This is basically saying,
does it support OpenCL?

00:25:51.926 --> 00:25:57.546 A:middle
And now, in the Mac, the OpenCL
API actually does have a CPU

00:25:57.546 --> 00:26:00.816 A:middle
device, but it's presented
to the system differently


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:57.546 --> 00:26:00.816 A:middle
device, but it's presented
to the system differently

00:26:00.816 --> 00:26:02.926 A:middle
than the software renderer.

00:26:02.926 --> 00:26:05.536 A:middle
Those are two separate
entities within the system.

00:26:05.956 --> 00:26:09.936 A:middle
And so if I obtained-if
I've sort of iterated

00:26:09.936 --> 00:26:14.506 A:middle
over the render ID for
the software renderer,

00:26:14.506 --> 00:26:16.946 A:middle
it wouldn't match this
accelerated compute query.

00:26:16.946 --> 00:26:18.456 A:middle
And so I'd be able
to distinguish

00:26:18.456 --> 00:26:21.236 A:middle
between it by making this check.

00:26:21.506 --> 00:26:23.626 A:middle
And then, if I get
past that step,

00:26:23.626 --> 00:26:28.596 A:middle
I'm going to issue another query
here using CGLDescribeRenderer

00:26:28.966 --> 00:26:30.916 A:middle
and I'm going to ask
for the renderer ID.

00:26:30.916 --> 00:26:36.166 A:middle
So I started by getting
a renderer info object.

00:26:36.466 --> 00:26:39.956 A:middle
I then walked over
all of the renderers

00:26:39.956 --> 00:26:41.126 A:middle
that were in the object.

00:26:41.126 --> 00:26:44.676 A:middle
And then filtered them using
a number of other queries,

00:26:45.276 --> 00:26:48.686 A:middle
and eventually ended up querying
them for their render ID number.

00:26:49.106 --> 00:26:54.376 A:middle
And in this case, I found the
secondary GPU, its renderer ID

00:26:54.376 --> 00:26:56.836 A:middle
and I'm going to write that
or store that to a value.

00:26:56.896 --> 00:26:59.276 A:middle
And we'll use that
in a little while.

00:26:59.706 --> 00:27:05.096 A:middle
So now I have a renderer ID
but in order to actually select


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.706 --> 00:27:05.096 A:middle
So now I have a renderer ID
but in order to actually select

00:27:05.506 --> 00:27:08.446 A:middle
or send work to a
GPU in the system,

00:27:08.786 --> 00:27:10.716 A:middle
I need to know its virtual
screen number because,

00:27:10.716 --> 00:27:14.896 A:middle
if you recall, the virtual
screen number is how the context

00:27:14.896 --> 00:27:19.306 A:middle
refers to the different
renderers that it contains.

00:27:19.666 --> 00:27:22.036 A:middle
And so here what I'm going
to do is I actually have

00:27:22.066 --> 00:27:25.096 A:middle
to have a context in order to
have virtual screen numbers.

00:27:25.636 --> 00:27:32.286 A:middle
So I'll get a context from my
NSOpenGLView and then I'll check

00:27:32.286 --> 00:27:37.016 A:middle
to see for each virtual
screen in the context,

00:27:37.016 --> 00:27:40.636 A:middle
I'll check for its number
and also its render ID.

00:27:40.636 --> 00:27:42.916 A:middle
So here I am, getting the number

00:27:42.916 --> 00:27:44.596 A:middle
of virtual screens
that are available.

00:27:45.706 --> 00:27:49.376 A:middle
And then the next step is to
walk over those virtual screens,

00:27:49.686 --> 00:27:54.846 A:middle
make them current, and then ask
for the renderer ID associated

00:27:54.846 --> 00:27:56.016 A:middle
with each virtual screen.

00:27:56.526 --> 00:27:58.946 A:middle
So I've iterated over
all the virtual screens,

00:27:59.306 --> 00:28:02.176 A:middle
gotten their render IDs
and then matched those


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.306 --> 00:28:02.176 A:middle
gotten their render IDs
and then matched those

00:28:02.176 --> 00:28:04.036 A:middle
with the renderer ID
that I'm looking for,

00:28:04.246 --> 00:28:08.036 A:middle
and that tells me the virtual
screen number that corresponds

00:28:08.036 --> 00:28:10.266 A:middle
to that particular GPU.

00:28:12.606 --> 00:28:14.296 A:middle
Okay, so it's important

00:28:14.296 --> 00:28:16.596 A:middle
to always check virtual
screen numbers.

00:28:16.596 --> 00:28:20.136 A:middle
So in the example that we
just looked at, when I walked

00:28:20.136 --> 00:28:22.236 A:middle
through that and actually
executed that code,

00:28:22.556 --> 00:28:25.776 A:middle
it turned out that the primary
GPU was actually virtual

00:28:25.776 --> 00:28:26.976 A:middle
screen one.

00:28:27.386 --> 00:28:30.676 A:middle
And so if I had just
assumed that you know,

00:28:30.676 --> 00:28:32.216 A:middle
virtual screen zero
would be the primary

00:28:32.216 --> 00:28:34.006 A:middle
because primary comes
before secondary,

00:28:34.006 --> 00:28:35.406 A:middle
I would have been wrong
and I might have ended

00:28:35.926 --> 00:28:37.966 A:middle
up rendering all of my work

00:28:38.046 --> 00:28:42.736 A:middle
on say the secondary GPU
instead of the primary GPU.

00:28:42.926 --> 00:28:45.256 A:middle
And so our - and so the
Mac is very flexible.

00:28:45.256 --> 00:28:46.666 A:middle
It actually can handle
this case.

00:28:47.016 --> 00:28:51.166 A:middle
It's just not as efficient as,
say, rendering all that 3D work

00:28:51.166 --> 00:28:55.326 A:middle
to the primary GPU and then
displaying it immediately.

00:28:55.326 --> 00:28:58.566 A:middle
Okay, so that's how
you do it in OpenGL.

00:28:59.076 --> 00:29:01.886 A:middle
Let's take a look at how
to do the same operation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.076 --> 00:29:01.886 A:middle
Let's take a look at how
to do the same operation

00:29:01.886 --> 00:29:05.206 A:middle
of the same set of
operations in OpenCL.

00:29:05.296 --> 00:29:08.436 A:middle
So, in OpenCL, I would have
gone through the process.

00:29:08.436 --> 00:29:11.096 A:middle
I would have started
with the CGL API and gone

00:29:11.096 --> 00:29:14.116 A:middle
through the process of
figuring out which render ID

00:29:14.116 --> 00:29:18.086 A:middle
in the system is the secondary
GPU which - and if I had sort

00:29:18.086 --> 00:29:20.446 A:middle
of flipped that process
around, I could have determined

00:29:20.446 --> 00:29:21.936 A:middle
which one was the primary GPU.

00:29:22.476 --> 00:29:26.246 A:middle
Now I have to go from a
renderer ID that I obtained

00:29:26.246 --> 00:29:28.816 A:middle
from CGL to a CL device ID.

00:29:29.396 --> 00:29:34.066 A:middle
And in Yosemite, there's
an API that we can use

00:29:34.066 --> 00:29:38.166 A:middle
that will convert a CL device
ID directly to a renderer ID

00:29:38.166 --> 00:29:42.336 A:middle
and that function is
CGLGetDeviceFromGLRenderer.

00:29:42.756 --> 00:29:47.516 A:middle
I pass in the renderer ID and
it gives me back a CL device ID.

00:29:47.896 --> 00:29:52.756 A:middle
Then I can use that CL device
ID to create a command queue

00:29:52.816 --> 00:29:56.726 A:middle
and dispatch work
directly to that GPU.

00:29:56.726 --> 00:30:00.236 A:middle
And so instead of having to
do a query for virtual screens


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:56.726 --> 00:30:00.236 A:middle
And so instead of having to
do a query for virtual screens

00:30:00.626 --> 00:30:04.006 A:middle
in the OpenCL API, I can
just create a command queue

00:30:04.006 --> 00:30:07.676 A:middle
and then use that command queue
to directly dispatch work,

00:30:07.676 --> 00:30:10.976 A:middle
in this case, to
that secondary GPU.

00:30:12.236 --> 00:30:15.196 A:middle
Okay, so the next stop
is dispatching work.

00:30:16.476 --> 00:30:21.856 A:middle
So in OpenGL, the
context - the GL context -

00:30:22.926 --> 00:30:25.016 A:middle
refers to the renderer
or interacts

00:30:25.016 --> 00:30:28.476 A:middle
with the renderer via this
virtual screen number.

00:30:29.046 --> 00:30:32.396 A:middle
And to do - to set the virtual
screen, we saw an example

00:30:32.396 --> 00:30:35.596 A:middle
of this earlier, if I'm going
to set up some draw calls,

00:30:35.596 --> 00:30:38.456 A:middle
I'm going to issue some draw
calls to one of the devices,

00:30:39.146 --> 00:30:42.156 A:middle
the first thing I have to do
is make sure that the context

00:30:42.216 --> 00:30:44.206 A:middle
that I created is
the current context.

00:30:44.606 --> 00:30:47.066 A:middle
So I'll call
CGLSetCurrentContext.

00:30:47.566 --> 00:30:50.286 A:middle
And pass in the context that
I'm entrusted in working with.

00:30:50.936 --> 00:30:53.876 A:middle
Then once that context is set,

00:30:54.236 --> 00:30:56.736 A:middle
I can set the virtual
screen number and,

00:30:56.816 --> 00:30:59.496 A:middle
like I said a couple slides
ago, it's really important

00:30:59.496 --> 00:31:01.836 A:middle
and I can't emphasize
this enough, to make sure


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.496 --> 00:31:01.836 A:middle
and I can't emphasize
this enough, to make sure

00:31:01.836 --> 00:31:04.206 A:middle
that you know which
virtual screen corresponds

00:31:04.206 --> 00:31:06.666 A:middle
to the primary GPU and the
secondary GPU as opposed

00:31:06.756 --> 00:31:09.746 A:middle
to just assuming
that the first one

00:31:09.746 --> 00:31:14.126 A:middle
or the second one is always
the primary or the secondary.

00:31:14.406 --> 00:31:19.006 A:middle
Anyway, I can call
CGLSetVirtualScreen and pass

00:31:19.006 --> 00:31:20.036 A:middle
in the number that I want.

00:31:20.096 --> 00:31:26.326 A:middle
And then issue my bind calls
and my draw calls in OpenGL.

00:31:26.816 --> 00:31:32.906 A:middle
In OpenCL, instead of having
to set a virtual screen,

00:31:33.146 --> 00:31:34.356 A:middle
I just use a command queue.

00:31:34.356 --> 00:31:36.786 A:middle
And so here, I'm
not setting state.

00:31:36.786 --> 00:31:38.776 A:middle
Instead what I'm doing is
I'm creating an object,

00:31:39.106 --> 00:31:42.956 A:middle
this queue object, and then
using that queue object

00:31:42.956 --> 00:31:45.346 A:middle
to enqueue work to
a particular device.

00:31:45.816 --> 00:31:48.406 A:middle
And so there are no
bind calls in OpenCL.

00:31:48.406 --> 00:31:51.476 A:middle
Here I'm just creating
a number of objects.

00:31:51.516 --> 00:31:52.896 A:middle
There was already a kernel here.

00:31:53.146 --> 00:31:54.606 A:middle
I set some arguments on it.

00:31:54.876 --> 00:31:58.506 A:middle
I have a command queue that I've
created based on the device ID

00:31:58.506 --> 00:32:01.736 A:middle
that I looked up using the
process that we just described.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.506 --> 00:32:01.736 A:middle
that I looked up using the
process that we just described.

00:32:02.136 --> 00:32:05.816 A:middle
And I can queue work
to that GPU.

00:32:07.926 --> 00:32:12.516 A:middle
Okay, now that I've created a
context that has two GPUs in it,

00:32:12.836 --> 00:32:16.866 A:middle
then identified the primary
GPU and the secondary GPU,

00:32:17.536 --> 00:32:22.316 A:middle
dispatched work using a virtual
screen or a CL command queue,

00:32:23.096 --> 00:32:27.566 A:middle
the last step is to get results
or to get the data off the GPU

00:32:27.566 --> 00:32:30.926 A:middle
that I've selected and to
use it in my application.

00:32:30.926 --> 00:32:34.066 A:middle
And of course, in an OpenGL
application, you might -

00:32:34.266 --> 00:32:37.466 A:middle
you know, the results might
be displayed on a primary GPU.

00:32:37.466 --> 00:32:41.726 A:middle
In an OpenCL application, if
you were doing CL-GL sharing,

00:32:42.226 --> 00:32:45.606 A:middle
you might end up sending the
results from the secondary GPU

00:32:45.606 --> 00:32:47.876 A:middle
to the primary GPU in
order to render them,

00:32:47.936 --> 00:32:51.826 A:middle
or you might download the
results from the secondary GPU

00:32:51.826 --> 00:32:54.486 A:middle
to host memory if you
were working on something

00:32:54.486 --> 00:32:57.806 A:middle
that wasn't related to
rendering or to display.

00:32:58.706 --> 00:33:01.956 A:middle
And either of those
things are possible.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.706 --> 00:33:01.956 A:middle
And either of those
things are possible.

00:33:01.956 --> 00:33:03.596 A:middle
Either of those techniques
are possible.

00:33:04.086 --> 00:33:08.896 A:middle
So if you're in a CL-GL sharing
case, there are a couple things

00:33:08.896 --> 00:33:11.086 A:middle
that you have to do that
we'll look at in a second,

00:33:11.526 --> 00:33:13.776 A:middle
but the runtime is going to
do most of the work for you.

00:33:14.546 --> 00:33:16.696 A:middle
If you follow a specific
procedure,

00:33:17.326 --> 00:33:21.096 A:middle
after you've dispatched the
work to the - to one GPU,

00:33:21.366 --> 00:33:24.956 A:middle
when you start using that work
on the second GPU, the runtime

00:33:25.126 --> 00:33:28.116 A:middle
and the driver will take
care of moving the data

00:33:28.546 --> 00:33:29.816 A:middle
between the two devices.

00:33:30.226 --> 00:33:32.936 A:middle
And well actually, this is a
great advantage because it means

00:33:32.936 --> 00:33:35.636 A:middle
that we can very
easily take advantage

00:33:35.636 --> 00:33:37.846 A:middle
of using the secondary
GPU in our application,

00:33:37.916 --> 00:33:40.286 A:middle
but we have to follow
certain rules to make sure

00:33:40.286 --> 00:33:43.166 A:middle
that the system will behave
in an efficient manner

00:33:43.586 --> 00:33:45.406 A:middle
when we move data
between the two devices.

00:33:46.486 --> 00:33:50.976 A:middle
So let's take a look at what
to do when we're switching work

00:33:50.976 --> 00:33:53.626 A:middle
between - from one
GPU to another.

00:33:53.626 --> 00:33:56.076 A:middle
So, let's say that we were going

00:33:56.076 --> 00:33:59.146 A:middle
to do some OpenGL work
on the secondary GPU.

00:33:59.146 --> 00:34:02.376 A:middle
So we'd call SetVirtualScreen
and we'd pass


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.146 --> 00:34:02.376 A:middle
So we'd call SetVirtualScreen
and we'd pass

00:34:02.376 --> 00:34:04.156 A:middle
in the secondary virtual screen.

00:34:04.826 --> 00:34:07.736 A:middle
And then we would bind some
objects, maybe some textures

00:34:07.736 --> 00:34:11.746 A:middle
that we're going to work
with, and do some drawing.

00:34:12.005 --> 00:34:15.126 A:middle
And then we would call
glFlushRenderAPPLE()

00:34:15.295 --> 00:34:18.126 A:middle
and that's going to -
that's going to cause all

00:34:18.126 --> 00:34:21.376 A:middle
of that GL work to be submitted
to the device, and it's going

00:34:21.376 --> 00:34:23.545 A:middle
to push all of that
work off to the GPU

00:34:23.545 --> 00:34:27.406 A:middle
and the GPU will
start working on it.

00:34:27.666 --> 00:34:30.106 A:middle
At some point in the
future, we're going to want

00:34:30.106 --> 00:34:32.646 A:middle
to use the results
that we had computed.

00:34:32.646 --> 00:34:35.065 A:middle
Maybe we are rendering
into an FBL or something.

00:34:35.485 --> 00:34:38.446 A:middle
We want to use those
results on the primary GPU.

00:34:38.446 --> 00:34:41.866 A:middle
And so, we're going to
call CGLSetVirtualScreen,

00:34:42.196 --> 00:34:45.656 A:middle
pass in the primary GPU's
virtual screen number,

00:34:46.485 --> 00:34:51.025 A:middle
and then start working with
the data on the primary GPU.

00:34:51.346 --> 00:34:54.976 A:middle
Now, in this case, there
is a single OpenGL context.

00:34:55.606 --> 00:34:57.646 A:middle
And because there was a
single OpenGL context,

00:34:57.926 --> 00:35:01.576 A:middle
it wasn't necessary for
me to change the state


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:57.926 --> 00:35:01.576 A:middle
it wasn't necessary for
me to change the state

00:35:01.576 --> 00:35:05.106 A:middle
or to re-bind the objects
that we are working with.

00:35:05.496 --> 00:35:06.906 A:middle
That state was already set.

00:35:06.906 --> 00:35:10.076 A:middle
I simply changed
the virtual screen

00:35:10.386 --> 00:35:14.386 A:middle
and continued using the
objects - the GL objects -

00:35:14.426 --> 00:35:15.856 A:middle
that I was working
with previously.

00:35:16.466 --> 00:35:20.086 A:middle
And that allows me to -
that allows the runtime,

00:35:20.486 --> 00:35:24.446 A:middle
that SetVirtualScreen call,
allows the runtime to realize

00:35:24.446 --> 00:35:26.616 A:middle
that I'm going to start
sending work to the other GPU.

00:35:26.616 --> 00:35:30.266 A:middle
And it will take care of
synchronizing the data

00:35:30.266 --> 00:35:34.426 A:middle
that I wrote to you on the
other device over to the device

00:35:34.476 --> 00:35:38.086 A:middle
that I'm going to start using
when I issue the next draw call.

00:35:38.396 --> 00:35:40.836 A:middle
Okay, so let's take
a look at what

00:35:40.836 --> 00:35:43.226 A:middle
that looks like in a schematic.

00:35:43.226 --> 00:35:45.726 A:middle
So I've taken some graphics work

00:35:45.816 --> 00:35:47.856 A:middle
and I've issued a
bunch of Draw calls.

00:35:48.176 --> 00:35:51.016 A:middle
On the secondary GPU, I
call glFlushRenderAPPLE()

00:35:51.436 --> 00:35:54.746 A:middle
and the runtime pushes all
of that work onto the device.

00:35:54.746 --> 00:35:59.726 A:middle
Now, if the runtime was going
to issue any more commands,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:00.206 --> 00:36:03.106 A:middle
like for example, if the
runtime decided that it had

00:36:03.106 --> 00:36:04.496 A:middle
to issue a page off command,

00:36:04.916 --> 00:36:08.386 A:middle
that page off command would
be sitting behind all the work

00:36:08.696 --> 00:36:10.716 A:middle
that I'd previously
flushed to the device.

00:36:10.806 --> 00:36:12.156 A:middle
And that's exactly
what happened.

00:36:12.156 --> 00:36:15.816 A:middle
So when the primary GPU or
when the runtime detects

00:36:15.816 --> 00:36:20.216 A:middle
that CGLSetVirtualScreen call
going to the primary GPU,

00:36:21.126 --> 00:36:26.246 A:middle
it in turn will page the data
from - or page off the data

00:36:26.316 --> 00:36:27.586 A:middle
from the secondary GPU,

00:36:27.866 --> 00:36:32.526 A:middle
after those previously flushed
commands have been executed

00:36:32.676 --> 00:36:35.106 A:middle
and then page it on
to the primary GPU

00:36:35.536 --> 00:36:40.946 A:middle
so that I can then execute my
draw calls and continue working

00:36:40.946 --> 00:36:43.106 A:middle
with the data on
the primary GPU.

00:36:43.886 --> 00:36:48.726 A:middle
So, the movement of the data,
takes place automatically

00:36:49.236 --> 00:36:53.056 A:middle
and as a programmer, I've made
sure that that data movement is

00:36:53.166 --> 00:36:58.496 A:middle
in the right order or it
takes place after the commands

00:36:58.496 --> 00:37:01.636 A:middle
that I used to create the data
by calling glFlushRenderAPPLE().


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.496 --> 00:37:01.636 A:middle
that I used to create the data
by calling glFlushRenderAPPLE().

00:37:03.926 --> 00:37:07.226 A:middle
Okay, so in OpenCL, it's
a little bit different.

00:37:07.766 --> 00:37:09.576 A:middle
In OpenCL, we have
command queues instead

00:37:09.576 --> 00:37:11.336 A:middle
of virtual screens,
and we're going

00:37:11.336 --> 00:37:13.126 A:middle
to do something that's
very similar.

00:37:13.126 --> 00:37:16.716 A:middle
We're going to enqueue
work using a command queue

00:37:16.716 --> 00:37:18.426 A:middle
that we created in
the primary GPU

00:37:19.026 --> 00:37:22.146 A:middle
and then flush it
using just clFlush.

00:37:23.026 --> 00:37:27.176 A:middle
That will cause that queue to
start working or that device

00:37:27.436 --> 00:37:31.586 A:middle
to start working on the data, on
the commands that we enqueued.

00:37:31.586 --> 00:37:36.406 A:middle
And then when I enqueue
work to the secondary queue,

00:37:37.636 --> 00:37:41.546 A:middle
once that work gets to the
head of the command queue,

00:37:41.906 --> 00:37:46.076 A:middle
the system will execute a
similar page-off operation

00:37:46.406 --> 00:37:50.936 A:middle
that in this case is going to be
guaranteed to be behind the work

00:37:50.936 --> 00:37:52.666 A:middle
that was sent to
the primary queue.

00:37:52.996 --> 00:37:56.446 A:middle
And so we'll see a similar
type of behavior as we saw

00:37:56.816 --> 00:38:02.296 A:middle
in the GL case where I made sure
that that page-off would arrive


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:56.816 --> 00:38:02.296 A:middle
in the GL case where I made sure
that that page-off would arrive

00:38:02.296 --> 00:38:07.056 A:middle
at the GPU, after it had already
started working on the producer

00:38:07.416 --> 00:38:11.096 A:middle
or the operations that
were producing the data.

00:38:11.856 --> 00:38:17.256 A:middle
So, on Mac, you have heard of a
pattern called Flush and Bind.

00:38:17.696 --> 00:38:22.656 A:middle
And this is a pattern
of APIs that is used

00:38:22.656 --> 00:38:26.986 A:middle
in multiple GPU situations and
in instances where there is more

00:38:26.986 --> 00:38:29.966 A:middle
than one OpenGL context.

00:38:30.236 --> 00:38:32.416 A:middle
It's also used in a situation

00:38:32.416 --> 00:38:37.516 A:middle
where you have an OpenGL context
that's, say, producing the data

00:38:37.516 --> 00:38:39.956 A:middle
and an OpenCL context
that's consuming the data.

00:38:39.956 --> 00:38:44.826 A:middle
So, any instance where on Mac
you have two different contexts,

00:38:45.166 --> 00:38:46.776 A:middle
you have to use Flush and Bind.

00:38:47.026 --> 00:38:49.466 A:middle
And what that means
is that when you -

00:38:49.466 --> 00:38:51.796 A:middle
after you queue the work
that's doing the production,

00:38:52.046 --> 00:38:53.966 A:middle
that's producing the texture

00:38:53.966 --> 00:38:57.596 A:middle
or maybe it's producing some
geometry, after you enqueue

00:38:57.596 --> 00:39:00.826 A:middle
that work, you always have to
make sure that you flush it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:57.596 --> 00:39:00.826 A:middle
that work, you always have to
make sure that you flush it.

00:39:01.066 --> 00:39:02.326 A:middle
You flush that command queue

00:39:02.326 --> 00:39:05.186 A:middle
or you flush before
switching virtual screens.

00:39:06.376 --> 00:39:09.916 A:middle
And then after that, when
you switch to the other API

00:39:09.916 --> 00:39:12.926 A:middle
or to the other context,
you have to make sure

00:39:12.926 --> 00:39:17.216 A:middle
that you rebind any
objects that were modified,

00:39:17.686 --> 00:39:19.576 A:middle
in this case, by OpenCL.

00:39:20.236 --> 00:39:23.996 A:middle
So in the single instance
that we looked at before,

00:39:23.996 --> 00:39:27.466 A:middle
when we were - just had one
OpenGL context, we could flush

00:39:27.466 --> 00:39:33.016 A:middle
and then immediately use the
objects on the other device.

00:39:33.466 --> 00:39:37.236 A:middle
In an instance where there
are either two OpenGL contexts

00:39:37.556 --> 00:39:40.786 A:middle
or there's an OpenGL context
and an OpenCL context,

00:39:41.136 --> 00:39:42.466 A:middle
we have to use Flush and Bind.

00:39:42.466 --> 00:39:45.346 A:middle
We have to flush like we
did before, but then we have

00:39:45.346 --> 00:39:49.116 A:middle
to rebind those objects once
we switch to the other device.

00:39:50.196 --> 00:39:53.866 A:middle
So if you follow these steps,
the runtime will take care

00:39:53.866 --> 00:39:58.616 A:middle
of moving this data between the
two GPUs for you as you work

00:39:58.616 --> 00:39:59.976 A:middle
on the data in those
two different places.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:00.116 --> 00:40:02.906 A:middle
And the reason that the
runtime's able to do this,

00:40:02.906 --> 00:40:06.786 A:middle
is that you've created a context
that contains all the devices

00:40:06.896 --> 00:40:10.526 A:middle
in the system, and so that the
runtime and the driver are able

00:40:10.526 --> 00:40:14.916 A:middle
to track enough state to perform
these operations for you.

00:40:14.916 --> 00:40:16.976 A:middle
And so it's very
important to emphasize

00:40:17.456 --> 00:40:21.836 A:middle
that when you create a
context, always create a context

00:40:21.836 --> 00:40:23.826 A:middle
that contains all the
devices in the system,

00:40:23.826 --> 00:40:25.556 A:middle
all of the GPU devices
in the system.

00:40:26.036 --> 00:40:30.086 A:middle
There are some other design
patterns that you might follow.

00:40:30.086 --> 00:40:33.786 A:middle
For example, you might create
or be tempted to create a, say,

00:40:33.976 --> 00:40:37.676 A:middle
a set of objects, a
context, a command queue,

00:40:37.876 --> 00:40:39.996 A:middle
a whole stack of objects.

00:40:40.366 --> 00:40:42.766 A:middle
One stack per device
in the system.

00:40:43.506 --> 00:40:47.646 A:middle
But on Mac, really the
best thing to do is

00:40:47.646 --> 00:40:50.636 A:middle
to always create a - the context
to contain all of the devices

00:40:50.636 --> 00:40:52.166 A:middle
in the system, even
if you're, say,

00:40:52.506 --> 00:40:53.856 A:middle
on a different configuration,

00:40:53.856 --> 00:40:55.286 A:middle
only going to use
one of the devices.

00:40:55.726 --> 00:40:58.706 A:middle
If you do this, it
will be very easy

00:40:58.706 --> 00:41:01.476 A:middle
when you move your
application onto the Mac Pro


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.706 --> 00:41:01.476 A:middle
when you move your
application onto the Mac Pro

00:41:01.626 --> 00:41:05.916 A:middle
to start using two GPUs
because the application

00:41:06.286 --> 00:41:09.276 A:middle
and the structure of the
program has already been written

00:41:09.276 --> 00:41:12.896 A:middle
to handle a context that
contains both devices.

00:41:12.896 --> 00:41:16.366 A:middle
It makes it a lot easier
to migrate to the system

00:41:16.786 --> 00:41:22.726 A:middle
and allows the runtime to take
advantage or allows the runtime

00:41:22.726 --> 00:41:26.376 A:middle
to move objects between
the two GPUs for you.

00:41:27.916 --> 00:41:32.686 A:middle
Okay, so now that I've
showed you how to program

00:41:32.686 --> 00:41:38.676 A:middle
or the API that's involved in
programming for the Mac Pro,

00:41:39.146 --> 00:41:41.206 A:middle
I'd like to show you some
programming patterns.

00:41:41.326 --> 00:41:45.106 A:middle
And what I'm going to focus on
here is what the system does,

00:41:45.106 --> 00:41:46.746 A:middle
or what the system's
doing on your behalf,

00:41:47.566 --> 00:41:50.736 A:middle
when you perform
different tasks on the GPU.

00:41:50.736 --> 00:41:54.286 A:middle
So, what I'm going to start
with is an example of an offline

00:41:54.286 --> 00:41:59.056 A:middle
or an offload task where you
have some kind of operation

00:41:59.486 --> 00:42:04.016 A:middle
that isn't related to
display, and you're going


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.486 --> 00:42:04.016 A:middle
that isn't related to
display, and you're going

00:42:04.086 --> 00:42:07.576 A:middle
to perform this operation
on the secondary GPU.

00:42:07.906 --> 00:42:11.036 A:middle
And so, I've called this -
I call this an offline task.

00:42:11.446 --> 00:42:14.706 A:middle
And you might have an offline
task in your application

00:42:15.266 --> 00:42:18.056 A:middle
if it's something that
- say it's something

00:42:18.056 --> 00:42:21.836 A:middle
that you apply once or one
- sort of one set of time.

00:42:22.256 --> 00:42:25.236 A:middle
So for example, you have an
image processing application

00:42:25.236 --> 00:42:28.806 A:middle
and the user goes to the Edit
menu and they select a filter

00:42:29.286 --> 00:42:32.456 A:middle
and they change some filter
parameters and click Apply,

00:42:33.076 --> 00:42:36.286 A:middle
that might be a great offline
task because you're not going

00:42:36.286 --> 00:42:40.876 A:middle
to perform the bulk of the
work, of the bulk of that say,

00:42:40.876 --> 00:42:44.326 A:middle
OpenCL compute work until
the user clicks Apply.

00:42:44.746 --> 00:42:46.746 A:middle
Then you're going to perform
a large amount of work

00:42:46.866 --> 00:42:49.216 A:middle
on some input data,
on some giant image.

00:42:49.716 --> 00:42:53.496 A:middle
And then once you're done,
you're going to say save

00:42:53.496 --> 00:42:56.636 A:middle
that image off to main memory
or maybe you're going to save

00:42:56.636 --> 00:42:59.026 A:middle
that image off to disk.

00:42:59.516 --> 00:43:03.196 A:middle
And that operation is
a discrete operation.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.516 --> 00:43:03.196 A:middle
And that operation is
a discrete operation.

00:43:03.196 --> 00:43:04.586 A:middle
It takes a long time.

00:43:05.096 --> 00:43:08.196 A:middle
If you were to run it
on say the main thread,

00:43:08.196 --> 00:43:12.416 A:middle
it might cause the GUI
to respond more slowly.

00:43:12.766 --> 00:43:17.936 A:middle
And it's something that is -
it's something that's separate

00:43:17.936 --> 00:43:22.216 A:middle
from the main sort of, GUI
loop of the application.

00:43:23.216 --> 00:43:25.026 A:middle
So let's take a look
at what that -

00:43:25.026 --> 00:43:26.126 A:middle
what I'm talking about here.

00:43:26.126 --> 00:43:30.936 A:middle
So I have some OpenCL
work in green,

00:43:30.936 --> 00:43:34.966 A:middle
and this OpenCL work is
going to apply my operation.

00:43:34.966 --> 00:43:36.766 A:middle
And it might take a long time.

00:43:36.766 --> 00:43:40.286 A:middle
And then I'm going to first have
some OpenGL work that's going

00:43:40.286 --> 00:43:42.346 A:middle
on that's related to my GUI.

00:43:42.346 --> 00:43:45.876 A:middle
And my application actually
may be using OpenGL in the GPU

00:43:45.876 --> 00:43:49.336 A:middle
if I'm using a - if I'm using
certain parts of the UI,

00:43:50.226 --> 00:43:52.716 A:middle
even if my application
itself doesn't use OpenGL.

00:43:53.536 --> 00:43:56.326 A:middle
Now, what this looks like
is, it has a lot of -

00:43:56.326 --> 00:43:57.966 A:middle
we might have a lot
of sort of short

00:43:58.216 --> 00:44:01.836 A:middle
or inexpensive OpenGL
operations being performed.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.216 --> 00:44:01.836 A:middle
or inexpensive OpenGL
operations being performed.

00:44:01.836 --> 00:44:04.286 A:middle
And then we have this
giant compute operation.

00:44:04.526 --> 00:44:10.646 A:middle
And of course, if I then have
some more GUI-related OpenGL

00:44:10.646 --> 00:44:12.786 A:middle
work coming through,
what's going to happen is,

00:44:12.786 --> 00:44:14.896 A:middle
I'm going to - you know,
my system's going to lag.

00:44:14.896 --> 00:44:18.966 A:middle
I might end up with some
sort of progress problem

00:44:18.966 --> 00:44:20.696 A:middle
or maybe I'll even
get a beachball,

00:44:21.106 --> 00:44:25.196 A:middle
if this OpenCL program
or this part

00:44:25.326 --> 00:44:27.726 A:middle
of my OpenCL application
takes too long.

00:44:27.966 --> 00:44:29.966 A:middle
And so what we're going to do is
we're really just going to take

00:44:29.966 --> 00:44:31.336 A:middle
that green box, the Open -

00:44:31.336 --> 00:44:34.316 A:middle
the expensive OpenCL compute
operation, and we're just going

00:44:34.316 --> 00:44:35.846 A:middle
to move it over to
the secondary GPU.

00:44:36.016 --> 00:44:38.136 A:middle
And if we've set
up our application

00:44:38.466 --> 00:44:44.086 A:middle
so that we have both
devices in our context,

00:44:44.556 --> 00:44:50.706 A:middle
and we followed the API that we
just described, it's very easy

00:44:50.706 --> 00:44:52.646 A:middle
to perform this offload task

00:44:52.946 --> 00:44:56.226 A:middle
and move an offline operation
off to the secondary GPU.

00:44:56.556 --> 00:44:57.696 A:middle
So here's what this looks like.

00:44:57.856 --> 00:44:59.066 A:middle
It's very straightforward.

00:44:59.196 --> 00:45:00.716 A:middle
I have an application here.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:59.196 --> 00:45:00.716 A:middle
I have an application here.

00:45:01.036 --> 00:45:03.326 A:middle
The user went into my -
or the user is going to go

00:45:03.326 --> 00:45:05.626 A:middle
into my Edit menu and
select Apply Effect.

00:45:06.016 --> 00:45:07.856 A:middle
I end up in an action here.

00:45:08.176 --> 00:45:12.496 A:middle
And I have a kernel that I'm
executing iteratively a large

00:45:12.496 --> 00:45:13.366 A:middle
number of times.

00:45:13.706 --> 00:45:16.286 A:middle
This makes the application
a little bit slower.

00:45:16.466 --> 00:45:18.976 A:middle
And I'm doing this right
now in the primary queue,

00:45:19.306 --> 00:45:21.196 A:middle
and all I'm going to do
is make sure that I've set

00:45:21.196 --> 00:45:24.196 A:middle
up the secondary queue and
just send that operation off

00:45:24.196 --> 00:45:25.206 A:middle
to the secondary queue.

00:45:25.206 --> 00:45:28.316 A:middle
And now, at some
point in the future,

00:45:28.316 --> 00:45:32.606 A:middle
after these operations are
finished, the existing code

00:45:32.606 --> 00:45:37.046 A:middle
in my application to move
the data off the GPU and back

00:45:37.516 --> 00:45:41.006 A:middle
to disk will just move that
data, those memory objects,

00:45:42.176 --> 00:45:46.146 A:middle
off the other GPU
instead of the primary GPU

00:45:46.146 --> 00:45:47.526 A:middle
that I was previously using.

00:45:48.376 --> 00:45:51.966 A:middle
Another pattern that you might
end up following is an instance

00:45:51.966 --> 00:45:55.486 A:middle
where you're going to perform
graphics work on both GPUs.

00:45:56.026 --> 00:45:59.106 A:middle
And once you've divided the
work, the rendering work,

00:45:59.146 --> 00:46:00.356 A:middle
between the two devices,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:59.146 --> 00:46:00.356 A:middle
between the two devices,

00:46:00.906 --> 00:46:03.886 A:middle
the window server actually
will take care of copying data

00:46:04.526 --> 00:46:08.196 A:middle
from the secondary GPU to
the primary GPU for display.

00:46:08.246 --> 00:46:10.346 A:middle
So I'm going to show
you what this looks like

00:46:10.346 --> 00:46:11.306 A:middle
and what happens here.

00:46:11.726 --> 00:46:15.236 A:middle
And actually in a second,
I'll show an example

00:46:15.626 --> 00:46:18.476 A:middle
where we perform these
kinds of operations

00:46:18.476 --> 00:46:20.306 A:middle
in an actual application.

00:46:20.956 --> 00:46:25.596 A:middle
So, here I have an application's
app thread, and it's going

00:46:25.596 --> 00:46:28.916 A:middle
to perform a - it's
going to select a -

00:46:28.946 --> 00:46:30.086 A:middle
make the context current.

00:46:30.506 --> 00:46:34.136 A:middle
It will set the virtual
screen to the primary.

00:46:34.136 --> 00:46:35.996 A:middle
It's going to call the drawScene
method and that's going

00:46:35.996 --> 00:46:38.216 A:middle
to do a lot of OpenGL work.

00:46:38.676 --> 00:46:41.216 A:middle
And then I'm going to
call glFlushRenderAPPLE

00:46:41.956 --> 00:46:47.566 A:middle
and maybe I call flushBuffer
to put the work on the screen.

00:46:47.566 --> 00:46:50.166 A:middle
And now I'm going to do the
same thing on the secondary GPU

00:46:50.916 --> 00:46:52.396 A:middle
and also call flushBuffer.

00:46:52.396 --> 00:46:56.386 A:middle
In this example, I might
have two separate parts

00:46:56.386 --> 00:47:00.046 A:middle
of my application and I'm going
to render one part on one GPU


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:56.386 --> 00:47:00.046 A:middle
of my application and I'm going
to render one part on one GPU

00:47:00.046 --> 00:47:02.136 A:middle
and the other part
on the other GPU.

00:47:02.806 --> 00:47:06.846 A:middle
Now, what happens here, if
I look at the operations

00:47:06.846 --> 00:47:09.146 A:middle
that are being performed,
at some point and time,

00:47:09.566 --> 00:47:15.096 A:middle
both of these GPUs are
going to get flush commands

00:47:15.216 --> 00:47:17.206 A:middle
and then flushBuffer commands.

00:47:17.626 --> 00:47:21.216 A:middle
And the window server is going
to wake up and it's going

00:47:21.216 --> 00:47:26.036 A:middle
to realize as it's getting
ready to composite the image

00:47:26.086 --> 00:47:28.666 A:middle
for the next frame, that some

00:47:28.666 --> 00:47:31.236 A:middle
of the data it needs is
on the secondary GPU.

00:47:31.236 --> 00:47:34.296 A:middle
And so it's going to actually
perform a very similar operation

00:47:34.296 --> 00:47:37.106 A:middle
to what we saw a little
while ago with the page-off.

00:47:37.106 --> 00:47:39.226 A:middle
It's going to realize
that that -

00:47:39.226 --> 00:47:43.586 A:middle
the data's on the other device,
send a page off request for it

00:47:43.586 --> 00:47:46.926 A:middle
to the device, move the
data back, then page it

00:47:46.926 --> 00:47:49.696 A:middle
on to the primary GPU
performance composite,

00:47:49.956 --> 00:47:52.296 A:middle
and then display the image.

00:47:52.656 --> 00:47:54.536 A:middle
And so, there's a
period of time here

00:47:54.536 --> 00:47:58.766 A:middle
where the window server has
gotten involved for display

00:47:59.206 --> 00:48:03.406 A:middle
and it's going to end up
executing that page-off


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.206 --> 00:48:03.406 A:middle
and it's going to end up
executing that page-off

00:48:03.406 --> 00:48:06.006 A:middle
and then the secondary GPU
is free to continue working

00:48:06.006 --> 00:48:07.676 A:middle
on more graphics work.

00:48:07.676 --> 00:48:10.816 A:middle
But the primary GPU is
going to have to end

00:48:10.816 --> 00:48:16.856 A:middle
up copying the data back on, and
then rendering the composite.

00:48:16.856 --> 00:48:20.136 A:middle
And so there's a certain
amount of overhead

00:48:20.136 --> 00:48:22.796 A:middle
that your application
has to be aware

00:48:22.796 --> 00:48:26.466 A:middle
of when you're performing
work on both devices.

00:48:26.526 --> 00:48:29.206 A:middle
But the system, if
you follow this API,

00:48:29.416 --> 00:48:32.066 A:middle
the system will handle
this for you

00:48:32.416 --> 00:48:36.966 A:middle
and your application will
be able to use both devices.

00:48:38.136 --> 00:48:41.886 A:middle
Okay, so the challenge here,
when we're taking an application

00:48:41.886 --> 00:48:44.816 A:middle
and modifying it to
use this configuration,

00:48:45.206 --> 00:48:47.186 A:middle
is really that we have to
divide our work somehow.

00:48:47.506 --> 00:48:51.236 A:middle
We might divide it by taking
a task that isn't related

00:48:51.236 --> 00:48:53.556 A:middle
to display and moving
it to the secondary GPU

00:48:53.556 --> 00:49:00.146 A:middle
or maybe we can parallelize the
work between the two devices


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:53.556 --> 00:49:00.146 A:middle
or maybe we can parallelize the
work between the two devices

00:49:00.146 --> 00:49:03.686 A:middle
in such a way that the
overhead is not a problem.

00:49:04.236 --> 00:49:05.926 A:middle
And we have to always be aware

00:49:05.926 --> 00:49:08.726 A:middle
that there is one device that's
connected to the display,

00:49:08.726 --> 00:49:09.796 A:middle
and the other device that isn't.

00:49:10.276 --> 00:49:11.866 A:middle
And so that can be a
source of overhead,

00:49:13.086 --> 00:49:17.336 A:middle
especially if the data is -
especially if the data has

00:49:17.336 --> 00:49:19.416 A:middle
to be moved back and
forth very frequently.

00:49:20.336 --> 00:49:23.726 A:middle
So, I'd like to take
a second here and talk

00:49:23.726 --> 00:49:25.176 A:middle
about some other situations

00:49:25.506 --> 00:49:28.046 A:middle
that involve multiple
GPUs on our platform.

00:49:28.386 --> 00:49:33.076 A:middle
So the - probably the most
common multi-GPU situation is a

00:49:33.076 --> 00:49:36.236 A:middle
laptop that has two
GPUs: a discrete GPU

00:49:36.236 --> 00:49:37.406 A:middle
and an integrated GPU.

00:49:37.656 --> 00:49:41.276 A:middle
And it's important to
remember that although the APIs

00:49:41.276 --> 00:49:43.956 A:middle
that you use when you
modify an application

00:49:43.956 --> 00:49:46.796 A:middle
to support automatic graphics
switching are similar,

00:49:47.156 --> 00:49:49.946 A:middle
the way that you use those
APIs is a little bit different.

00:49:50.366 --> 00:49:54.826 A:middle
And so, if you are interested
in supporting both GPUs

00:49:54.826 --> 00:49:57.116 A:middle
in a laptop, be sure
to take a look

00:49:57.116 --> 00:49:58.806 A:middle
at the automatic graphics
switching feature.

00:49:59.596 --> 00:50:06.456 A:middle
Also, the tower Mac Pro
configuration is still available


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:59.596 --> 00:50:06.456 A:middle
Also, the tower Mac Pro
configuration is still available

00:50:06.516 --> 00:50:07.956 A:middle
or is still out there.

00:50:07.996 --> 00:50:09.976 A:middle
And is - your application
may run on it.

00:50:10.866 --> 00:50:14.306 A:middle
And it is something that can
support multiple displays

00:50:14.306 --> 00:50:17.726 A:middle
connected to multiple GPUs, and
there's a lot of infrastructure

00:50:17.726 --> 00:50:20.856 A:middle
in Mac graphics for
handling instances

00:50:20.856 --> 00:50:24.356 A:middle
where an application moves
from one GPU to another,

00:50:24.706 --> 00:50:28.656 A:middle
based on the display
that's connected to the GPU.

00:50:28.976 --> 00:50:31.986 A:middle
And that uses a different set
of APIs and callback mechanisms.

00:50:31.986 --> 00:50:34.106 A:middle
And so, if you're working
or if you're concerned

00:50:34.106 --> 00:50:35.686 A:middle
about that situation,
you should take a look

00:50:35.686 --> 00:50:36.716 A:middle
at that documentation.

00:50:37.256 --> 00:50:39.216 A:middle
So let's look at a complete
example of everything

00:50:39.216 --> 00:50:41.226 A:middle
that you have to do
in an application.

00:50:41.706 --> 00:50:43.856 A:middle
The first step of course
was to create a context

00:50:43.856 --> 00:50:45.516 A:middle
that contains all the GPUs.

00:50:46.246 --> 00:50:53.636 A:middle
The second is to check and see
if you have an offline device.

00:50:54.046 --> 00:50:58.176 A:middle
So if you're on a Mac Pro,
you should have a single -

00:50:58.566 --> 00:51:00.396 A:middle
basically you should have
one device that's online


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:58.566 --> 00:51:00.396 A:middle
basically you should have
one device that's online

00:51:00.666 --> 00:51:02.016 A:middle
and one device that's offline.

00:51:02.446 --> 00:51:06.346 A:middle
Then check to see if you have
two identical - in this case,

00:51:06.346 --> 00:51:07.656 A:middle
I'm looking for device names.

00:51:08.096 --> 00:51:11.176 A:middle
And if I fail any of these
checks, it might mean that I'm

00:51:11.176 --> 00:51:12.506 A:middle
in one of those other
situations.

00:51:12.506 --> 00:51:15.146 A:middle
I might be in an instance
where I have a laptop

00:51:15.146 --> 00:51:18.256 A:middle
that has an integrated
and discrete GPU

00:51:18.256 --> 00:51:21.326 A:middle
that are different devices,
or maybe I'm in an instance

00:51:21.326 --> 00:51:26.346 A:middle
where I have a tower Mac Pro
and I have two different -

00:51:27.396 --> 00:51:31.706 A:middle
two displays connected
to two different GPUs.

00:51:31.706 --> 00:51:35.576 A:middle
Once I've determined that I'm
on a Mac Pro, a new Mac Pro,

00:51:36.106 --> 00:51:38.636 A:middle
then I have to be
concerned about dividing work

00:51:38.666 --> 00:51:41.396 A:middle
between the GPU and then
synchronizing the results.

00:51:41.396 --> 00:51:48.746 A:middle
So, if I fail that first check,
I'm going to go and take a look

00:51:48.746 --> 00:51:53.636 A:middle
at supporting multiple displays.

00:51:53.636 --> 00:51:56.016 A:middle
And if I - if the second
check doesn't work out,

00:51:56.076 --> 00:51:58.256 A:middle
then I might have
to be concerned

00:51:58.256 --> 00:51:59.606 A:middle
about automatic graphics
switching.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:00.776 --> 00:52:04.486 A:middle
Okay, so let me show you
a multi-GPU example now.

00:52:04.786 --> 00:52:09.936 A:middle
And this is a - this demo is a
system that's performing some

00:52:09.936 --> 00:52:13.066 A:middle
OpenCL work and some
OpenGL work.

00:52:13.736 --> 00:52:18.356 A:middle
And we're performing the
OpenGL work on the primary GPU,

00:52:18.826 --> 00:52:23.276 A:middle
and the OpenCL work in the
demo mode that we'll see

00:52:23.276 --> 00:52:25.856 A:middle
in a just a second, is
going to be performed on -

00:52:26.206 --> 00:52:29.706 A:middle
partially on the primary GPU and
then also on the secondary GPU.

00:52:30.406 --> 00:52:31.696 A:middle
So when I launch
this application,

00:52:31.696 --> 00:52:33.746 A:middle
this is performing
a physics simulation

00:52:34.206 --> 00:52:37.996 A:middle
where there's a particle system
that's being rendered in OpenGL

00:52:38.366 --> 00:52:41.126 A:middle
and it's being simulated
in OpenCL.

00:52:41.296 --> 00:52:43.986 A:middle
And right now, we have a
large number of particles.

00:52:44.616 --> 00:52:46.566 A:middle
We're performing the
physics simulation

00:52:46.566 --> 00:52:47.916 A:middle
and we're using one GPU.

00:52:48.216 --> 00:52:50.156 A:middle
And we're getting about
15 frames per second.

00:52:50.156 --> 00:52:56.836 A:middle
We have a - this is a relatively
fluid animation but it turns

00:52:56.836 --> 00:52:59.566 A:middle
out we can do much
better if we go over here

00:52:59.566 --> 00:53:02.616 A:middle
and reconfigure the
demo to use two GPUs.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:59.566 --> 00:53:02.616 A:middle
and reconfigure the
demo to use two GPUs.

00:53:02.616 --> 00:53:05.116 A:middle
And here you can
see that we're doing

00:53:05.116 --> 00:53:07.786 A:middle
about 30 frames per second,
maybe a little bit more

00:53:07.786 --> 00:53:10.556 A:middle
than 30 frames per second,
and we were able to accomplish

00:53:10.556 --> 00:53:15.006 A:middle
that by working through our
application and making sure

00:53:15.006 --> 00:53:17.376 A:middle
that we enable the application

00:53:17.376 --> 00:53:19.886 A:middle
to move data between
the two GPUs.

00:53:20.236 --> 00:53:22.446 A:middle
And then we found a way
of dividing the data

00:53:22.676 --> 00:53:27.416 A:middle
and the computation in
such a way that the speedup

00:53:27.416 --> 00:53:32.286 A:middle
that we obtained from
dividing our work and executing

00:53:32.456 --> 00:53:34.356 A:middle
with twice the amount
of GPU capability,

00:53:34.846 --> 00:53:38.346 A:middle
that speedup was a lot greater
than the overhead of having

00:53:38.346 --> 00:53:40.486 A:middle
to move a small amount
of data back

00:53:40.546 --> 00:53:42.326 A:middle
to the primary GPU for display.

00:53:43.226 --> 00:53:45.436 A:middle
So here actually we're -
I guess towards the end,

00:53:45.436 --> 00:53:46.796 A:middle
we're getting even faster

00:53:46.796 --> 00:53:51.326 A:middle
than the very beginning
of the simulation.

00:53:52.056 --> 00:53:55.896 A:middle
So this is a relatively
simple example.

00:53:56.016 --> 00:53:57.206 A:middle
Let's see if I can restart here.

00:53:57.606 --> 00:53:59.906 A:middle
This is a simple example.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:00.896 --> 00:54:03.726 A:middle
And without a huge
amount of effort,

00:54:03.726 --> 00:54:06.626 A:middle
we're able to divide our
application into pieces

00:54:06.696 --> 00:54:11.486 A:middle
and then execute the
compute part on both devices

00:54:11.486 --> 00:54:13.546 A:middle
and obtain a significant
speedup.

00:54:14.516 --> 00:54:25.946 A:middle
[ Silence ]

00:54:26.446 --> 00:54:30.916 A:middle
Okay, so in the demo what
we saw was an application

00:54:30.916 --> 00:54:34.656 A:middle
that we had modified
to move between

00:54:35.676 --> 00:54:39.036 A:middle
or to take an application
and perform some of the work

00:54:39.356 --> 00:54:43.286 A:middle
on one GPU and a lot of the
work on the secondary GPU.

00:54:43.286 --> 00:54:46.296 A:middle
And we saw that that produced
a pretty significant speedup.

00:54:46.296 --> 00:54:50.256 A:middle
There are a lot of other
applications that can benefit

00:54:50.256 --> 00:54:52.526 A:middle
from working on this
configuration and I hope

00:54:52.596 --> 00:54:56.016 A:middle
that using this API
and understanding some

00:54:56.016 --> 00:54:59.146 A:middle
of the terminology and the way

00:54:59.146 --> 00:55:01.686 A:middle
that the system behaves will
help you port applications


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:59.146 --> 00:55:01.686 A:middle
that the system behaves will
help you port applications

00:55:02.116 --> 00:55:03.546 A:middle
to this configuration.

00:55:04.186 --> 00:55:07.786 A:middle
For more information about
using OpenCL and OpenGL

00:55:07.786 --> 00:55:12.666 A:middle
in the Mac Pro, please talk
to the WWDR representatives.

00:55:12.926 --> 00:55:15.826 A:middle
Thank you very much for
attending this session

00:55:15.866 --> 00:55:17.816 A:middle
and please let us know
how we can help you.

00:55:18.016 --> 00:55:20.016 A:middle
[ Applause ]

00:55:20.016 --> 00:55:30.186 A:middle
[ Silence ]

