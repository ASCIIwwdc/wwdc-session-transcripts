WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:13.216 --> 00:00:15.566 A:middle
&gt;&gt; Hello. Welcome to
the Advanced Session

00:00:15.566 --> 00:00:16.566 A:middle
on Working with Metal.

00:00:17.126 --> 00:00:18.616 A:middle
My name is Gokhan Avkarogullari.

00:00:18.996 --> 00:00:20.826 A:middle
My colleagues, Aaftab
Munshi and Serhat Tekin,

00:00:20.826 --> 00:00:22.236 A:middle
and I will be presenting
this session.

00:00:23.456 --> 00:00:26.186 A:middle
This is the third session that
we have about Metal today.

00:00:26.746 --> 00:00:28.916 A:middle
In the first session, Jeremy
introduced Metal to us.

00:00:29.256 --> 00:00:32.625 A:middle
He talked about the motivation
behind Metal, the structures

00:00:32.625 --> 00:00:35.866 A:middle
that we build the Metal on,
and concluded it with a demo

00:00:36.056 --> 00:00:39.316 A:middle
from a Crytek on collectibles
with thousands of draw calls.

00:00:39.906 --> 00:00:42.066 A:middle
We followed-up with the
second session where we talked

00:00:42.066 --> 00:00:44.056 A:middle
about Fundamentals of Metal.

00:00:44.786 --> 00:00:47.846 A:middle
We talked about creating your
first application with Metal,

00:00:48.366 --> 00:00:51.296 A:middle
drawing an animated triangle
on the screen, and followed it

00:00:51.296 --> 00:00:54.206 A:middle
up with the details about
the shading language.

00:00:55.116 --> 00:00:57.606 A:middle
In this session, we're going
to do a more deeper dive

00:00:57.906 --> 00:01:00.976 A:middle
into creating a full blown
graphics application with Metal.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.906 --> 00:01:00.976 A:middle
into creating a full blown
graphics application with Metal.

00:01:01.456 --> 00:01:03.656 A:middle
We'll follow it up with
data-parallel computing

00:01:03.656 --> 00:01:06.996 A:middle
on the GPU using Metal and
finally, we'll have a demo

00:01:07.526 --> 00:01:10.026 A:middle
of the developer tools
that we build from Metal.

00:01:11.326 --> 00:01:15.706 A:middle
Ok, so let's talk about
why multi-pass applications

00:01:15.706 --> 00:01:16.276 A:middle
are relevant.

00:01:16.976 --> 00:01:19.736 A:middle
The modern graphics applications
are very complicated pieces

00:01:19.736 --> 00:01:20.326 A:middle
of software.

00:01:20.966 --> 00:01:23.716 A:middle
They're built on using
many, many advanced graphics

00:01:23.716 --> 00:01:27.606 A:middle
and computer algorithms and they
do them in a piecewise manner.

00:01:27.706 --> 00:01:30.716 A:middle
Basically they're built on many,
many hundreds of texture passes

00:01:30.716 --> 00:01:32.396 A:middle
and compute passes
and blip passes

00:01:32.746 --> 00:01:35.546 A:middle
to generate a final great
looking image on the screen.

00:01:36.476 --> 00:01:38.116 A:middle
So we're going to go and
talk about a little bit how

00:01:38.116 --> 00:01:39.146 A:middle
to do that using Metal.

00:01:40.146 --> 00:01:43.326 A:middle
We will talk about multiple
framebuffer configurations,

00:01:43.826 --> 00:01:48.116 A:middle
rendering to off-screen and
on-screen textures, using meshes

00:01:48.116 --> 00:01:50.026 A:middle
and different things
with different states

00:01:50.026 --> 00:01:51.856 A:middle
and in different configurations,

00:01:52.296 --> 00:01:54.086 A:middle
and how to set up
multiple encoders.

00:01:55.416 --> 00:01:58.536 A:middle
We'll use a deferred lighting
with a shadow map example

00:01:59.096 --> 00:02:01.046 A:middle
to basically walk through
these code examples.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.096 --> 00:02:01.046 A:middle
to basically walk through
these code examples.

00:02:01.096 --> 00:02:04.546 A:middle
This is a 2 pass
application that we built

00:02:04.686 --> 00:02:06.386 A:middle
for this particular
presentation.

00:02:06.886 --> 00:02:08.985 A:middle
In the first pass, we
have a shadow map pass

00:02:08.985 --> 00:02:11.476 A:middle
where we rendered the
scene from the perspective

00:02:11.476 --> 00:02:13.606 A:middle
of the directional
light to a depth buffer.

00:02:13.936 --> 00:02:17.456 A:middle
And in the second pass we set
up a G-buffer, fat G-buffer,

00:02:17.606 --> 00:02:18.976 A:middle
through multiple render targets.

00:02:19.486 --> 00:02:21.276 A:middle
We generate attributes
in that G-buffer

00:02:21.756 --> 00:02:24.716 A:middle
and we apply the point light
volumes onto that G-buffer

00:02:24.716 --> 00:02:26.366 A:middle
to find out which
pixels are affected.

00:02:26.786 --> 00:02:28.936 A:middle
And finally using the
framebuffer fetch,

00:02:29.616 --> 00:02:31.876 A:middle
create light accumulation
information and then merge

00:02:31.876 --> 00:02:34.136 A:middle
with the [inaudible] textures
to generate a final image.

00:02:34.946 --> 00:02:37.616 A:middle
Having said that, we're
not really interested

00:02:37.616 --> 00:02:40.706 A:middle
in describing the example in
here; it's just a vehicle for us

00:02:40.706 --> 00:02:42.036 A:middle
to basically talk
about the APIs.

00:02:42.036 --> 00:02:45.416 A:middle
On top of that, the example
is actually published

00:02:45.416 --> 00:02:48.446 A:middle
as a sample code on
the developer website

00:02:48.446 --> 00:02:50.426 A:middle
so you can go ahead and
download it and take a look

00:02:50.426 --> 00:02:53.576 A:middle
at it later if you
would like to.

00:02:53.776 --> 00:02:56.846 A:middle
The way the example is
structured that it has 2 passes.

00:02:57.266 --> 00:02:59.786 A:middle
Both of them are
RenderCommandEncoder passes.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:00.226 --> 00:03:01.636 A:middle
The first 1 is for shadow map

00:03:01.636 --> 00:03:04.066 A:middle
and the second 1 is afforded
the deferred lighting pass.

00:03:04.636 --> 00:03:06.576 A:middle
They're all encoded into
a single command buffer

00:03:06.576 --> 00:03:09.446 A:middle
which is...and the
single command buffer goes

00:03:09.446 --> 00:03:10.406 A:middle
into a command queue.

00:03:10.736 --> 00:03:13.676 A:middle
So this is kind of what most
applications will look like;

00:03:14.016 --> 00:03:15.756 A:middle
multiple render to
texture passes going

00:03:15.756 --> 00:03:16.666 A:middle
into a command encoder

00:03:16.666 --> 00:03:19.006 A:middle
on a frame boundary that's
sent to the command queue.

00:03:19.946 --> 00:03:22.096 A:middle
I did a demo of the application.

00:03:23.516 --> 00:03:27.576 A:middle
[ Pause ]

00:03:28.076 --> 00:03:31.556 A:middle
Ok, I have it here.

00:03:31.766 --> 00:03:33.836 A:middle
So this is the upload
of the first pass

00:03:33.836 --> 00:03:36.096 A:middle
where we are rendering
basically through that buffer

00:03:36.096 --> 00:03:38.566 A:middle
from the perspective of
the directional light.

00:03:39.956 --> 00:03:42.566 A:middle
And this is how our
G-buffer is laid out.

00:03:42.566 --> 00:03:44.506 A:middle
On the top left we
normally have RB to texture,

00:03:44.506 --> 00:03:47.336 A:middle
but we're showing basically the
combined image that is going

00:03:47.336 --> 00:03:49.886 A:middle
to go to the screen
when we're actually done

00:03:49.886 --> 00:03:50.846 A:middle
with our entire rendering.

00:03:51.266 --> 00:03:53.046 A:middle
And there's a normal
buffer, and a depth buffer,

00:03:53.046 --> 00:03:54.326 A:middle
and a light accumulation buffer,

00:03:54.716 --> 00:03:58.346 A:middle
4 color buffers basically
attached to a framebuffer

00:03:58.706 --> 00:04:00.356 A:middle
and depth and stencil
buffers as well.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.706 --> 00:04:00.356 A:middle
and depth and stencil
buffers as well.

00:04:01.376 --> 00:04:02.386 A:middle
This is the light accumulation;

00:04:02.386 --> 00:04:04.436 A:middle
there's also the light
accumulation pass.

00:04:04.986 --> 00:04:06.396 A:middle
And these are the visualization

00:04:06.396 --> 00:04:08.926 A:middle
of the lights basically
using light voluminous.

00:04:09.116 --> 00:04:10.566 A:middle
They're mapped onto the screen.

00:04:11.816 --> 00:04:15.176 A:middle
And finally this is the final
image that goes to the display.

00:04:15.176 --> 00:04:17.745 A:middle
It looks a lot better on the
device than on the presentation.

00:04:18.046 --> 00:04:23.296 A:middle
Ok, let's go back
to our presentation.

00:04:24.816 --> 00:04:29.306 A:middle
Ok, so how do we setup
an application like this

00:04:29.306 --> 00:04:31.516 A:middle
or more complicated
ones that you have seen

00:04:31.846 --> 00:04:35.036 A:middle
in the demos using Metal?

00:04:35.616 --> 00:04:37.576 A:middle
Just like Jeremy talked about
in the first session and looked

00:04:37.576 --> 00:04:40.226 A:middle
at the things that...at what
frequency things are done

00:04:40.226 --> 00:04:42.156 A:middle
and moved the most heavy ones

00:04:42.156 --> 00:04:44.496 A:middle
to the least frequently
done stages.

00:04:44.886 --> 00:04:47.916 A:middle
An application has a lot of
things that are done once

00:04:48.366 --> 00:04:50.296 A:middle
and there are things that
are done at low level times

00:04:50.296 --> 00:04:53.576 A:middle
or streaming time, and there
are things done every frame

00:04:53.716 --> 00:04:55.496 A:middle
and in an application
there are also things

00:04:55.496 --> 00:04:56.606 A:middle
that are render to textures.

00:04:56.606 --> 00:04:58.996 A:middle
So we're going to look at
each category and figure

00:04:58.996 --> 00:05:01.556 A:middle
out what is done in these
categories and figure out how


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.996 --> 00:05:01.556 A:middle
out what is done in these
categories and figure out how

00:05:01.556 --> 00:05:02.416 A:middle
to do those with Metal.

00:05:03.706 --> 00:05:05.446 A:middle
Let's start with the
things that are done once.

00:05:05.896 --> 00:05:06.816 A:middle
Creating a device.

00:05:06.816 --> 00:05:09.426 A:middle
They are the only ones you queue
on the system so you're going

00:05:09.426 --> 00:05:12.616 A:middle
to get a GPU and are
handled through the GPU,

00:05:12.966 --> 00:05:15.636 A:middle
and creating a command queue
on the GPU is only done once

00:05:16.076 --> 00:05:17.686 A:middle
in most of the applications.

00:05:18.086 --> 00:05:20.176 A:middle
And Richard told you something
about this; I'm not going

00:05:20.176 --> 00:05:22.076 A:middle
to talk about that
in this session.

00:05:23.076 --> 00:05:24.596 A:middle
There are things
we do as needed.

00:05:25.086 --> 00:05:27.096 A:middle
For example; we know
up front in all

00:05:27.196 --> 00:05:29.286 A:middle
of our applications
what our render

00:05:29.286 --> 00:05:30.696 A:middle
to texture stages will be.

00:05:30.696 --> 00:05:33.826 A:middle
There are usually a set of
render to texture passes,

00:05:33.826 --> 00:05:36.166 A:middle
that are known up front for
like an indoor environment

00:05:36.466 --> 00:05:38.576 A:middle
or an outdoor environment and
they might change if there's

00:05:38.576 --> 00:05:41.146 A:middle
like [inaudible] included
or something like that

00:05:41.146 --> 00:05:42.776 A:middle
but most of them are up front.

00:05:42.776 --> 00:05:45.466 A:middle
You know as an application
developer what your render

00:05:45.466 --> 00:05:47.896 A:middle
to texture passes will be,
in what order they're going

00:05:47.896 --> 00:05:50.236 A:middle
to be done, and what kind of
framebuffers that are going

00:05:50.236 --> 00:05:50.756 A:middle
to be used with those.

00:05:50.756 --> 00:05:53.456 A:middle
So we can actually
define...create the framebuffer

00:05:53.456 --> 00:05:54.796 A:middle
textures for those passes

00:05:54.796 --> 00:05:56.456 A:middle
and define what those
textures are going to look

00:05:56.456 --> 00:05:58.216 A:middle
like up front at once.

00:05:58.786 --> 00:06:02.446 A:middle
And at level load time we can
download our assets including


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.786 --> 00:06:02.446 A:middle
And at level load time we can
download our assets including

00:06:02.446 --> 00:06:06.346 A:middle
our meshes, textures and
then basically our shaders

00:06:06.346 --> 00:06:07.616 A:middle
and associated with
those shaders

00:06:07.616 --> 00:06:10.016 A:middle
to create pipeline objects,
and the pipeline objects.

00:06:10.496 --> 00:06:13.506 A:middle
And of course we can
create our uniform buffers

00:06:13.506 --> 00:06:14.376 A:middle
up front as well.

00:06:15.476 --> 00:06:17.966 A:middle
These are the things that we
do either at level load time

00:06:18.456 --> 00:06:21.676 A:middle
at once or depending on if we're
going to stream load or not,

00:06:22.116 --> 00:06:24.406 A:middle
at other times as well
but only as needed.

00:06:24.956 --> 00:06:28.866 A:middle
In our example, we're using
a single command buffer

00:06:28.866 --> 00:06:31.256 A:middle
to submit a set of
render to texture passes

00:06:31.486 --> 00:06:34.366 A:middle
to basically have the results
of our render to texture passes

00:06:34.366 --> 00:06:35.476 A:middle
to show up on the screen

00:06:35.476 --> 00:06:38.616 A:middle
so that's basically a
frame boundary operation.

00:06:38.616 --> 00:06:41.036 A:middle
Every time you want to have
something to go to the screen,

00:06:41.036 --> 00:06:43.096 A:middle
we're going to basically create
a command buffer and use it

00:06:43.096 --> 00:06:44.866 A:middle
to encode our render
to texture passes

00:06:44.866 --> 00:06:46.906 A:middle
so this is something
we do every frame.

00:06:47.436 --> 00:06:50.016 A:middle
Of course there are uniform
buffers that need to be updated

00:06:50.016 --> 00:06:52.386 A:middle
on frame boundaries; that's
where you do it as well.

00:06:52.976 --> 00:06:57.126 A:middle
And finally the things we do
every render to texture pass

00:06:57.126 --> 00:07:00.576 A:middle
such as encoding the command
so that GPU can understand.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.126 --> 00:07:00.576 A:middle
such as encoding the command
so that GPU can understand.

00:07:00.926 --> 00:07:02.576 A:middle
Setting up the states
and resources,

00:07:02.576 --> 00:07:03.856 A:middle
and initiating draw calls.

00:07:03.916 --> 00:07:06.236 A:middle
And then finally
finishing the encoding

00:07:06.236 --> 00:07:07.576 A:middle
so you can go to
the next encoder.

00:07:08.796 --> 00:07:10.846 A:middle
So these are the things we do
every render to texture pass

00:07:10.846 --> 00:07:12.956 A:middle
and we're going to basically
look at each one of them

00:07:12.956 --> 00:07:15.966 A:middle
and understand how Metal is
used to do these operations.

00:07:18.446 --> 00:07:23.236 A:middle
Ok, let's start with the
things that we do as needed

00:07:23.606 --> 00:07:27.296 A:middle
and understand how we can setup
information for our render

00:07:27.296 --> 00:07:29.176 A:middle
to texture passes
up front so that

00:07:29.176 --> 00:07:31.106 A:middle
when we create our
encoders; all the information

00:07:31.106 --> 00:07:33.456 A:middle
that is necessary for
that encoding is ready.

00:07:34.626 --> 00:07:37.026 A:middle
But before we go there, I'd
like to speak a little bit

00:07:37.026 --> 00:07:39.616 A:middle
about descriptors because all
of the code examples have lots

00:07:39.616 --> 00:07:42.356 A:middle
of descriptors and I'd
like to establish that all

00:07:42.356 --> 00:07:44.236 A:middle
of the descriptor...that all

00:07:44.236 --> 00:07:47.076 A:middle
of the descriptor are
defining how an object is going

00:07:47.076 --> 00:07:47.716 A:middle
to be created.

00:07:47.716 --> 00:07:49.826 A:middle
It's like the blueprint and just

00:07:49.826 --> 00:07:52.336 A:middle
like the blueprints
you basically use

00:07:52.336 --> 00:07:55.266 A:middle
to build a house from,
once a house is built,

00:07:55.266 --> 00:07:57.236 A:middle
you don't have actually
a connection back

00:07:57.236 --> 00:07:57.946 A:middle
to the blueprint.

00:07:57.946 --> 00:08:00.706 A:middle
You cannot change the blueprint
and see in fact a change


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:57.946 --> 00:08:00.706 A:middle
You cannot change the blueprint
and see in fact a change

00:08:00.996 --> 00:08:02.126 A:middle
on an already built house.

00:08:02.536 --> 00:08:05.036 A:middle
You cannot change a
descriptor and expect a change

00:08:05.066 --> 00:08:06.756 A:middle
to the built object
from that descriptor.

00:08:06.756 --> 00:08:10.136 A:middle
Descriptors are there to define
what objects are going to be

00:08:10.136 --> 00:08:12.136 A:middle
but once they're created,
the connection is lost.

00:08:12.936 --> 00:08:15.826 A:middle
But just like a blueprint as
well, a descriptor can be used

00:08:15.826 --> 00:08:18.916 A:middle
to create more instances
of the same kind of object

00:08:19.356 --> 00:08:21.926 A:middle
or they can modify it a little
bit to create a different kind

00:08:21.926 --> 00:08:25.726 A:middle
of object that shares
some of the personality

00:08:25.726 --> 00:08:26.926 A:middle
of the previous object.

00:08:28.256 --> 00:08:32.346 A:middle
And as Jeremy pointed out
before, everything except

00:08:32.346 --> 00:08:33.916 A:middle
for a few states
that you can set

00:08:33.916 --> 00:08:35.986 A:middle
on the render encoders
are actually built

00:08:36.306 --> 00:08:39.866 A:middle
into the state objects and the
resources and they are immutable

00:08:40.076 --> 00:08:42.015 A:middle
which gives us the
opportunity acutely

00:08:42.346 --> 00:08:44.155 A:middle
to avoid the state
revelation [assumed spelling]

00:08:44.536 --> 00:08:45.486 A:middle
at the draw time.

00:08:46.016 --> 00:08:49.116 A:middle
So a descriptor built an
object and pretty much

00:08:49.116 --> 00:08:51.416 A:middle
that object is immutable
after that point.

00:08:51.796 --> 00:08:54.356 A:middle
That basically makes the
Metal a lower head API

00:08:54.416 --> 00:08:57.686 A:middle
by avoiding all the state
tracking, all the state changes,

00:08:57.956 --> 00:08:59.406 A:middle
and reflecting them
at the draw time.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.046 --> 00:09:00.976 A:middle
Ok, let's go back

00:09:00.976 --> 00:09:04.496 A:middle
to our framebuffer
configuration,

00:09:04.496 --> 00:09:05.316 A:middle
how we setup that.

00:09:06.806 --> 00:09:09.366 A:middle
Ok, so for
RenderCommandEncoders,

00:09:09.366 --> 00:09:12.006 A:middle
we need to know about the
nature of the framebuffer

00:09:12.256 --> 00:09:14.366 A:middle
like how many color
detections there are,

00:09:14.366 --> 00:09:16.436 A:middle
what kind of pixel types
there are, the depth

00:09:16.436 --> 00:09:18.516 A:middle
and stencil attachment;
things of that sort.

00:09:18.996 --> 00:09:21.656 A:middle
And those are defined through
a RenderPassDescriptor.

00:09:22.156 --> 00:09:25.396 A:middle
We are allowed up to 4 color
attachments that are allowed

00:09:25.396 --> 00:09:27.676 A:middle
on Metal and we can
attach a depth

00:09:27.676 --> 00:09:29.266 A:middle
and stencil buffer as well.

00:09:29.776 --> 00:09:32.056 A:middle
And the attachments
themselves are also described

00:09:32.056 --> 00:09:34.136 A:middle
to in other descriptor
that's embedded

00:09:34.136 --> 00:09:35.526 A:middle
into the RenderPassDescriptor

00:09:35.526 --> 00:09:38.656 A:middle
which is
RenderPassAttachmentDescriptor.

00:09:38.936 --> 00:09:42.526 A:middle
In this descriptor we basically
define what kind of load

00:09:42.526 --> 00:09:45.956 A:middle
and store actions clear
values and what kind of slice

00:09:46.056 --> 00:09:48.686 A:middle
or mid-level that we're
going to render into;

00:09:48.936 --> 00:09:50.806 A:middle
all of these are
basically defined here.

00:09:51.876 --> 00:09:55.166 A:middle
And it also points to the
texture that we're going

00:09:55.166 --> 00:09:56.376 A:middle
to use to render into.

00:09:57.036 --> 00:09:59.636 A:middle
So this pass descriptor
basically has all

00:09:59.636 --> 00:09:59.976 A:middle
the information


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:00.136 --> 00:10:00.716 A:middle
necessary

00:10:00.716 --> 00:10:03.036 A:middle
for a RenderCommandEncoder
to get going.

00:10:03.036 --> 00:10:06.316 A:middle
And we're going to look at
the 2 passes that we have;

00:10:06.746 --> 00:10:10.266 A:middle
the shadow pass and the deferred
lighting pass in our example

00:10:10.266 --> 00:10:12.826 A:middle
and build render pass
descriptors for those.

00:10:13.486 --> 00:10:15.326 A:middle
So let's start with
the shadowRenderPass.

00:10:15.986 --> 00:10:18.306 A:middle
In this case we only
have a depth buffer;

00:10:18.576 --> 00:10:21.296 A:middle
we don't have any color buffers
attached because all we want is

00:10:21.296 --> 00:10:23.916 A:middle
to create a shadow map
buffer that we can use later

00:10:24.086 --> 00:10:27.476 A:middle
to basically see if a
pixel is all clear or not.

00:10:28.736 --> 00:10:31.816 A:middle
So we're going to start with
creating the texture for that

00:10:31.816 --> 00:10:36.016 A:middle
and what we have in here is
basically a 1k by 1k texture

00:10:36.016 --> 00:10:40.826 A:middle
with no mitmapping,
a depth 432 texture.

00:10:41.436 --> 00:10:46.286 A:middle
It is created on the device as
we talked extensively before.

00:10:46.286 --> 00:10:51.136 A:middle
There's no concept of context or
shared groups like GL on Metal.

00:10:52.176 --> 00:10:54.936 A:middle
Every resource is created on
the device, they are visible

00:10:54.936 --> 00:10:58.796 A:middle
by the GPU, and also you can
independently modify them,

00:10:59.426 --> 00:11:02.596 A:middle
not the objects themselves,
but like the texture data


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.426 --> 00:11:02.596 A:middle
not the objects themselves,
but like the texture data

00:11:02.596 --> 00:11:06.726 A:middle
or the buffer data, read that in
a requirement of bind to modify.

00:11:07.236 --> 00:11:10.496 A:middle
You can modify them any time you
want as long as you're careful

00:11:10.496 --> 00:11:12.916 A:middle
that they are not modified
while the GPU is accessing them

00:11:13.336 --> 00:11:15.346 A:middle
and as long as you make sure
that memory coincident rules

00:11:15.346 --> 00:11:17.406 A:middle
at the command buffer
boundaries is followed.

00:11:17.516 --> 00:11:21.626 A:middle
After we have our texture,

00:11:21.896 --> 00:11:23.626 A:middle
we can create our
render pass descriptor.

00:11:24.196 --> 00:11:28.176 A:middle
We're going to assign this
texture to the depth detector

00:11:28.176 --> 00:11:29.406 A:middle
of render pass descriptor

00:11:29.406 --> 00:11:31.326 A:middle
because it has only
a single attachment.

00:11:32.496 --> 00:11:35.696 A:middle
And then define the properties
such as the clear value,

00:11:35.696 --> 00:11:36.976 A:middle
load, and store actions.

00:11:37.286 --> 00:11:39.586 A:middle
We talked extensively about
load and store actions before.

00:11:39.906 --> 00:11:41.786 A:middle
They're very important
in terms of performance

00:11:42.106 --> 00:11:43.206 A:middle
so you should really
pay attention

00:11:43.206 --> 00:11:45.226 A:middle
to setting them correctly
and most

00:11:45.226 --> 00:11:47.656 A:middle
of the time the default values
are the most sensible values.

00:11:47.976 --> 00:11:52.676 A:middle
Ok, let's go to our second pass.

00:11:52.676 --> 00:11:55.886 A:middle
We need to also create a
descriptor for our second pass;

00:11:55.886 --> 00:11:58.126 A:middle
we're going to actually do the
second render command encoding.

00:11:58.506 --> 00:12:00.256 A:middle
That information will
be available up front.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.506 --> 00:12:00.256 A:middle
That information will
be available up front.

00:12:00.516 --> 00:12:02.326 A:middle
Those textures are created
up front so we don't have

00:12:02.326 --> 00:12:05.206 A:middle
to pay the penalty of doing
those at the draw time.

00:12:05.976 --> 00:12:09.936 A:middle
In this example we
have 4 color buffers,

00:12:09.936 --> 00:12:11.226 A:middle
one of them is actually
interesting;

00:12:11.226 --> 00:12:12.226 A:middle
the one on the top left.

00:12:12.716 --> 00:12:15.596 A:middle
It is a buffer that we're going
to render into and then go

00:12:15.596 --> 00:12:16.706 A:middle
and send it to the display.

00:12:17.136 --> 00:12:20.456 A:middle
So that texture we cannot create
up front; we need to get it

00:12:20.456 --> 00:12:22.006 A:middle
from the Metal layer,
the CAMetal layer.

00:12:22.286 --> 00:12:24.396 A:middle
And we talked extensively about
this in the second session.

00:12:24.396 --> 00:12:27.756 A:middle
Richard basically had a sample
code showing how we can get

00:12:27.756 --> 00:12:28.966 A:middle
that texture from
the Metal layer.

00:12:29.776 --> 00:12:32.066 A:middle
The other 3 color textures
though and the depth

00:12:32.066 --> 00:12:34.656 A:middle
and stencil texture are
things that we know up front.

00:12:34.656 --> 00:12:36.716 A:middle
They are structures and we
can create them up front

00:12:36.986 --> 00:12:38.186 A:middle
and we don't have
to do them later

00:12:39.006 --> 00:12:40.276 A:middle
so let's go ahead and do that.

00:12:40.876 --> 00:12:44.926 A:middle
Ok, we're going to start again
with a texture descriptor

00:12:44.926 --> 00:12:46.896 A:middle
to define how our texture
is going to look like.

00:12:47.206 --> 00:12:49.296 A:middle
In this example I'm
going to create only 2

00:12:49.296 --> 00:12:51.456 A:middle
of the color textures
and then the rest

00:12:51.456 --> 00:12:52.466 A:middle
of them are very similar.

00:12:53.636 --> 00:12:56.686 A:middle
So we basically need to create
something that has a width

00:12:56.686 --> 00:12:59.196 A:middle
and height of the
displayable surface

00:12:59.696 --> 00:13:02.166 A:middle
and there is no mapping
required.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.696 --> 00:13:02.166 A:middle
and there is no mapping
required.

00:13:02.166 --> 00:13:04.726 A:middle
So we create our first
texture using this descriptor,

00:13:04.726 --> 00:13:05.636 A:middle
texture descriptor.

00:13:06.106 --> 00:13:08.186 A:middle
Now as I said before,
the descriptors are kind

00:13:08.186 --> 00:13:11.306 A:middle
of blueprints so we can
actually use the same descriptor

00:13:11.926 --> 00:13:14.546 A:middle
and create the second
texture out of that as well.

00:13:14.876 --> 00:13:16.506 A:middle
This is what we're going
to do as well in here.

00:13:16.946 --> 00:13:18.926 A:middle
Basically we modify
the descriptor

00:13:19.286 --> 00:13:21.786 A:middle
to change the pixel format and
everything like width, height,

00:13:22.096 --> 00:13:24.166 A:middle
the mitmapping properties were
the same so we didn't have

00:13:24.166 --> 00:13:27.396 A:middle
to modify those, and then create
the second texture with that.

00:13:27.396 --> 00:13:30.746 A:middle
So you can see that we basically
have 1 descriptor creating 2

00:13:30.746 --> 00:13:31.616 A:middle
different textures.

00:13:32.546 --> 00:13:34.436 A:middle
So now that...and
we're going to do this

00:13:34.436 --> 00:13:37.006 A:middle
for the third color
attachment, depth and stencil.

00:13:37.006 --> 00:13:39.116 A:middle
Now that we have done all
of those, we can go ahead

00:13:39.116 --> 00:13:40.726 A:middle
and create our
RenderPassDescriptor

00:13:41.026 --> 00:13:43.566 A:middle
so that we can use it later to
create our RenderCommandEncoder.

00:13:44.946 --> 00:13:46.206 A:middle
We first create it.

00:13:47.306 --> 00:13:49.436 A:middle
What is interesting in
here as I explained before;

00:13:49.826 --> 00:13:53.366 A:middle
the first color attachment we
actually don't have a texture

00:13:53.366 --> 00:13:54.486 A:middle
up front ready for it.

00:13:54.666 --> 00:13:57.466 A:middle
We'll have it when we actually
start setting up our frame.

00:13:58.136 --> 00:14:02.146 A:middle
So it's set to "no" initially
and eventually we'll get it


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.136 --> 00:14:02.146 A:middle
So it's set to "no" initially
and eventually we'll get it

00:14:02.146 --> 00:14:04.786 A:middle
from the drawable when we
create our RenderCommandEncoder.

00:14:05.456 --> 00:14:09.266 A:middle
But despite not having
a texture,

00:14:09.716 --> 00:14:11.836 A:middle
we know actually
the actions up front

00:14:11.836 --> 00:14:14.766 A:middle
so we can define the clear
value, load and store actions

00:14:14.766 --> 00:14:16.466 A:middle
on the attachment
descriptor up front.

00:14:17.396 --> 00:14:20.276 A:middle
And we can go ahead and do it
for the second color attachment.

00:14:20.676 --> 00:14:24.276 A:middle
As you can see in this one, I
used the texture that we created

00:14:24.276 --> 00:14:26.336 A:middle
in the previous slide
as an attachment.

00:14:26.976 --> 00:14:30.116 A:middle
And we can also define
the clear value,

00:14:30.116 --> 00:14:31.976 A:middle
load and store actions
up front over here.

00:14:33.246 --> 00:14:35.266 A:middle
I'd like to point
out the difference

00:14:35.266 --> 00:14:37.226 A:middle
between the store
actions between these 2;

00:14:37.626 --> 00:14:40.576 A:middle
for the first buffer
attachment, we'd like it to end

00:14:40.576 --> 00:14:43.856 A:middle
up on the screen so we'd like
it to be stored into the memory.

00:14:44.426 --> 00:14:46.716 A:middle
But the second, third, and
fourth, color attachments depth

00:14:46.716 --> 00:14:49.236 A:middle
and stencil buffers,
they can be discarded;

00:14:49.236 --> 00:14:51.266 A:middle
they're just intermediate
values that we used

00:14:51.266 --> 00:14:53.436 A:middle
to generate the first
attachment's values.

00:14:53.826 --> 00:14:56.476 A:middle
So we don't really need to store
them into memory; we don't want

00:14:56.476 --> 00:14:58.556 A:middle
to lose memory bandwidth
and GP cycles

00:14:58.556 --> 00:15:01.446 A:middle
for that expensive operation
so we set them as "don't care"


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.556 --> 00:15:01.446 A:middle
for that expensive operation
so we set them as "don't care"

00:15:01.446 --> 00:15:04.406 A:middle
and let the driver figure out
the best kind of operation

00:15:04.406 --> 00:15:06.116 A:middle
for the particular GP
that you're working on.

00:15:07.476 --> 00:15:11.316 A:middle
Ok, so that covers how we
create render pass descriptors

00:15:11.626 --> 00:15:14.166 A:middle
that we want and the textures
associated with the framebuffers

00:15:14.166 --> 00:15:15.656 A:middle
that we are going to use later

00:15:15.656 --> 00:15:17.376 A:middle
for creating render
command encoders

00:15:17.696 --> 00:15:19.276 A:middle
when we do render
to texture passes.

00:15:20.726 --> 00:15:23.736 A:middle
Let's look at now the textures,
buffers, and state objects,

00:15:23.736 --> 00:15:27.396 A:middle
and specifically the pipeline
state objects that we're going

00:15:27.396 --> 00:15:30.126 A:middle
to create at level load
time so that we don't have

00:15:30.126 --> 00:15:31.276 A:middle
to basically deal
with them later.

00:15:33.196 --> 00:15:35.046 A:middle
We've already seen
how to create textures

00:15:35.046 --> 00:15:36.706 A:middle
from texture descriptors;
I am not going

00:15:36.706 --> 00:15:37.806 A:middle
to go into details of that.

00:15:37.806 --> 00:15:40.486 A:middle
I just want to point out
that there are multiple ways

00:15:40.486 --> 00:15:41.936 A:middle
to upload data into
your texture.

00:15:42.536 --> 00:15:45.076 A:middle
This is one of them;
basically a CPU copy.

00:15:45.706 --> 00:15:47.616 A:middle
And you can also use
booth command encoder

00:15:47.616 --> 00:15:50.936 A:middle
to upload data inline through
the GPU to do that as well.

00:15:52.956 --> 00:15:54.676 A:middle
We talked about buffers before.

00:15:55.176 --> 00:15:56.236 A:middle
We don't have a concept

00:15:56.236 --> 00:15:58.836 A:middle
of a vertex buffer
or a uniform buffer.

00:15:59.126 --> 00:16:00.766 A:middle
Buffers are buffers;
they are raw data.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.126 --> 00:16:00.766 A:middle
Buffers are buffers;
they are raw data.

00:16:01.106 --> 00:16:02.906 A:middle
You can create them
for anything you want

00:16:02.906 --> 00:16:05.896 A:middle
and then reach them...you
know access them through a GPU

00:16:06.446 --> 00:16:10.386 A:middle
in your shaders when you
specify them as inputs.

00:16:10.846 --> 00:16:14.216 A:middle
All we're doing here is creating
one with the information

00:16:14.216 --> 00:16:16.556 A:middle
about you now the
size and the options.

00:16:17.606 --> 00:16:22.066 A:middle
And as I said before, you can
modify these really easily while

00:16:22.726 --> 00:16:26.216 A:middle
your GPU is working on,
for example another section

00:16:26.216 --> 00:16:28.296 A:middle
of your buffer, you can
modify this section of buffer.

00:16:28.506 --> 00:16:31.506 A:middle
You need to take care of the
synchronization and you need

00:16:31.506 --> 00:16:34.286 A:middle
to follow the memory coincident
rules, but you don't have

00:16:34.286 --> 00:16:37.126 A:middle
to do anything like locking the
buffer or getting the pointer

00:16:37.126 --> 00:16:38.976 A:middle
to do...both pointers are
always available to you.

00:16:38.976 --> 00:16:41.676 A:middle
You have the freedom to modify
however you want whenever you

00:16:41.676 --> 00:16:45.486 A:middle
want and as long as you
basically pay attention to GP

00:16:45.486 --> 00:16:48.336 A:middle
and CP synchronization
issues, it will work correctly.

00:16:48.896 --> 00:16:53.386 A:middle
And finally one other example
of a depth stencil state,

00:16:53.866 --> 00:16:56.916 A:middle
I showed this one; I don't have
much to say about it except

00:16:56.916 --> 00:16:58.286 A:middle
that it is an interesting one

00:16:58.446 --> 00:17:01.896 A:middle
that it has an embedded
descriptor, internal descriptor.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.446 --> 00:17:01.896 A:middle
that it has an embedded
descriptor, internal descriptor.

00:17:01.896 --> 00:17:04.146 A:middle
Basically that stencil
descriptor has a stencil

00:17:04.146 --> 00:17:05.425 A:middle
descriptor defined within it.

00:17:05.896 --> 00:17:10.715 A:middle
But you can create all of your
depth stencil states up front

00:17:10.715 --> 00:17:12.935 A:middle
because just like you know
your render to texture state,

00:17:13.286 --> 00:17:15.276 A:middle
you actually know how
your objects are going

00:17:15.276 --> 00:17:17.185 A:middle
to be rendered into
those textures.

00:17:17.536 --> 00:17:21.086 A:middle
You know that, for example
in the shadow map pass,

00:17:21.476 --> 00:17:23.915 A:middle
you don't really need to
write into stencil buffer,

00:17:23.915 --> 00:17:26.836 A:middle
so you can basically say
that information here

00:17:26.836 --> 00:17:27.685 A:middle
or you don't use that.

00:17:28.016 --> 00:17:30.176 A:middle
Or when you have
something that is opaque,

00:17:30.556 --> 00:17:31.986 A:middle
you can basically
update the depth buffer,

00:17:31.986 --> 00:17:34.686 A:middle
but if you're going to do
something that is blended

00:17:34.686 --> 00:17:37.576 A:middle
for example, you might choose
to not update the depth buffer

00:17:37.576 --> 00:17:40.436 A:middle
and then you can actually...if
you know all the sates up front,

00:17:40.436 --> 00:17:41.356 A:middle
you can actually
create them up front

00:17:41.356 --> 00:17:44.016 A:middle
and don't pay the penalty
during the draw time.

00:17:44.646 --> 00:17:45.856 A:middle
Ok so we're going to talk

00:17:45.856 --> 00:17:48.786 A:middle
about next the render
pipeline state objects

00:17:48.786 --> 00:17:52.496 A:middle
but before we go there, I'd
like to revisit the...kind

00:17:53.226 --> 00:17:57.936 A:middle
of the open GL view of the GPU.

00:17:58.526 --> 00:18:01.676 A:middle
And then go and basically talk
about what's the motivation


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.526 --> 00:18:01.676 A:middle
And then go and basically talk
about what's the motivation

00:18:01.676 --> 00:18:04.676 A:middle
of RenderPipelineState objects
and what is included in them.

00:18:05.296 --> 00:18:08.716 A:middle
So this is kind of how it looks
to basically in general open GL,

00:18:08.716 --> 00:18:11.036 A:middle
but there's actually a
separate vertex shader state

00:18:11.416 --> 00:18:14.106 A:middle
and a fragment shader state
and all the other operations

00:18:14.106 --> 00:18:15.166 A:middle
that are all that looks

00:18:15.166 --> 00:18:17.316 A:middle
like fixed function
hardware controlled

00:18:17.316 --> 00:18:20.156 A:middle
through basically
state changing APIs.

00:18:20.666 --> 00:18:23.126 A:middle
Unfortunately the modern
hardware doesn't really work

00:18:23.126 --> 00:18:23.516 A:middle
that way.

00:18:24.236 --> 00:18:26.066 A:middle
If you think about
it, for example,

00:18:26.276 --> 00:18:28.956 A:middle
when your vertex layout
doesn't match your vertex shader

00:18:28.956 --> 00:18:29.826 A:middle
because they're separate,

00:18:29.826 --> 00:18:32.256 A:middle
the meshes are all
altered separately

00:18:32.256 --> 00:18:33.476 A:middle
than your vertex shaders,

00:18:33.806 --> 00:18:35.676 A:middle
there has to be some
code running somewhere;

00:18:36.106 --> 00:18:39.596 A:middle
either a deimaging code or
a vertex fetch shader code

00:18:39.866 --> 00:18:41.056 A:middle
that needs to bridge that gap

00:18:41.056 --> 00:18:43.096 A:middle
between these 2 layout
differences.

00:18:43.706 --> 00:18:47.896 A:middle
Or in some GPUs we have tile
based deferred render so most

00:18:47.896 --> 00:18:50.506 A:middle
of the frame buffer actually is
on the GPU while you're working

00:18:50.506 --> 00:18:53.176 A:middle
on it so the blending or write
mask is basically a read,

00:18:53.176 --> 00:18:56.476 A:middle
modify, write operation
I the tile and we do

00:18:56.476 --> 00:18:58.686 A:middle
that by creating actually
a shader code running

00:18:58.686 --> 00:19:01.036 A:middle
on the shader core;
it's not really a state.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.686 --> 00:19:01.036 A:middle
on the shader core;
it's not really a state.

00:19:01.036 --> 00:19:04.226 A:middle
So when you actually make a
draw call with one blending mode

00:19:04.626 --> 00:19:07.886 A:middle
for compiled shaders and
then change your blend state

00:19:07.956 --> 00:19:11.176 A:middle
and make another draw call
with the same compiled shaders.

00:19:11.416 --> 00:19:12.856 A:middle
Well we find out
that we actually have

00:19:12.856 --> 00:19:15.576 A:middle
to generate new code for this
new framebuffer configuration

00:19:15.606 --> 00:19:18.456 A:middle
because we have never seen
it before and we're going

00:19:18.456 --> 00:19:21.006 A:middle
to do this fixed-function
looking-like operation

00:19:21.006 --> 00:19:22.556 A:middle
in the shader core and we end

00:19:22.556 --> 00:19:24.476 A:middle
up recompiling your
shader causing a hitch

00:19:24.746 --> 00:19:25.696 A:middle
in your application.

00:19:26.256 --> 00:19:29.666 A:middle
So recognizing the differences
between how the API looks

00:19:29.666 --> 00:19:32.466 A:middle
on a PGL and how
actually a GP behaves,

00:19:32.466 --> 00:19:35.596 A:middle
we decided to basically
put everything in the GPU

00:19:35.596 --> 00:19:39.296 A:middle
that closes shader code and has
an impact on the shader code

00:19:39.296 --> 00:19:42.276 A:middle
in one place that's called
"render pipeline state object."

00:19:42.986 --> 00:19:44.316 A:middle
So let's look at
what we have in it.

00:19:44.896 --> 00:19:47.616 A:middle
We basically have the vertex
fetch basically information

00:19:47.616 --> 00:19:50.396 A:middle
about your vertex layout
that we talked about before.

00:19:50.396 --> 00:19:51.906 A:middle
I actually gave a
good example of it.

00:19:51.906 --> 00:19:54.326 A:middle
Aaftab gave a good example of
it in his talk about language.

00:19:55.436 --> 00:19:59.056 A:middle
Obviously we have the
shaders included in it.

00:19:59.236 --> 00:19:59.776 A:middle
We have


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:00.316 --> 00:20:03.836 A:middle
framebuffer configurations like
number of the rendered targets,

00:20:03.836 --> 00:20:06.036 A:middle
the pixel format,
sample count, write mask,

00:20:06.036 --> 00:20:11.276 A:middle
blend information actually,
and depth and stencil state.

00:20:12.246 --> 00:20:15.396 A:middle
Now we didn't go all the
way to including everything

00:20:15.456 --> 00:20:18.136 A:middle
in the GPU state in the
render pipeline state object

00:20:18.136 --> 00:20:21.106 A:middle
because if we had done that,
you would be creating millions

00:20:21.106 --> 00:20:21.876 A:middle
and millions of them

00:20:21.876 --> 00:20:24.456 A:middle
and actually there would
be only a few unique ones

00:20:24.456 --> 00:20:25.256 A:middle
of these around.

00:20:25.476 --> 00:20:29.486 A:middle
So basically anything that
is...that can easily be updated

00:20:29.736 --> 00:20:32.326 A:middle
or that's really truly fix
function hardware is not

00:20:32.326 --> 00:20:36.726 A:middle
in the render pipeline state
object such as the inputs.

00:20:37.046 --> 00:20:39.166 A:middle
We need to know the layout
of the buffer for example,

00:20:39.466 --> 00:20:40.566 A:middle
but we don't really need to know

00:20:40.566 --> 00:20:41.936 A:middle
which particular
buffer you're using.

00:20:41.936 --> 00:20:43.706 A:middle
It's really easy to
update the pointer pointing

00:20:43.706 --> 00:20:45.466 A:middle
to the buffer and the hardware.

00:20:46.696 --> 00:20:48.846 A:middle
The same goes true
for buffers as outputs

00:20:48.846 --> 00:20:50.566 A:middle
or the framebuffer textures.

00:20:50.996 --> 00:20:53.246 A:middle
We need to know how they're
configured, but we don't need

00:20:53.246 --> 00:20:55.516 A:middle
to know specifically which
ones are used at any time.

00:20:55.596 --> 00:20:59.316 A:middle
Or the primitive setup
states like the cull mode,

00:20:59.436 --> 00:21:03.136 A:middle
facing orientation, or
information like viewport


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.436 --> 00:21:03.136 A:middle
facing orientation, or
information like viewport

00:21:03.136 --> 00:21:05.806 A:middle
and scissor information; depth
bias and clamp and slope.

00:21:06.346 --> 00:21:07.476 A:middle
So those are not included

00:21:07.476 --> 00:21:09.536 A:middle
in your render pipeline
state objects, but everything

00:21:09.536 --> 00:21:11.296 A:middle
that affects your
cost is included

00:21:11.296 --> 00:21:12.776 A:middle
in your pipeline state object

00:21:13.076 --> 00:21:14.826 A:middle
so everything you
create is explicit

00:21:15.296 --> 00:21:18.026 A:middle
and everything you create is
basically you pay the cost

00:21:18.026 --> 00:21:18.446 A:middle
up front.

00:21:18.446 --> 00:21:19.706 A:middle
There are no hidden codes

00:21:19.706 --> 00:21:21.866 A:middle
that are not deferred
state validation,

00:21:21.866 --> 00:21:23.826 A:middle
no later compilation in Metal.

00:21:23.826 --> 00:21:26.486 A:middle
So what you do, you know
you do it, you're doing it,

00:21:26.766 --> 00:21:29.186 A:middle
why you're doing it, and
the cost is paid up front

00:21:29.186 --> 00:21:30.176 A:middle
when you are actually doing it.

00:21:31.336 --> 00:21:32.836 A:middle
So let's go and create
a few of those.

00:21:33.616 --> 00:21:36.216 A:middle
Basically there's a render
pipeline sate object associated

00:21:36.216 --> 00:21:37.206 A:middle
with every draw call.

00:21:37.516 --> 00:21:40.576 A:middle
And in our example, for example
under rendering the mesh,

00:21:40.576 --> 00:21:43.346 A:middle
the mesh for the [inaudible],
we're going to render it twice;

00:21:43.346 --> 00:21:45.346 A:middle
1 we're creating the depth
buffer for the shadowMap

00:21:45.686 --> 00:21:47.506 A:middle
and then one; we are
basically doing light

00:21:47.506 --> 00:21:49.126 A:middle
accumulation...deferred
lighting pass.

00:21:49.506 --> 00:21:51.576 A:middle
So we're going to create 2 of
them; I'm going to give examples

00:21:51.576 --> 00:21:53.156 A:middle
of how to create them.

00:21:53.796 --> 00:21:55.566 A:middle
We create a new one,
a descriptor.

00:21:55.676 --> 00:21:57.416 A:middle
As we talked before,

00:21:57.676 --> 00:22:00.676 A:middle
you hopefully basically
compiled your shaders on Xcode


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.676 --> 00:22:00.676 A:middle
you hopefully basically
compiled your shaders on Xcode

00:22:00.676 --> 00:22:02.656 A:middle
on the [inaudible] or in
a library so we can go

00:22:02.656 --> 00:22:05.106 A:middle
and get your vertex
shader from the library.

00:22:05.786 --> 00:22:10.116 A:middle
And now I'm basically setting
the rest of the sates here;

00:22:10.116 --> 00:22:11.716 A:middle
basically we're setting
the vertex function,

00:22:12.066 --> 00:22:14.176 A:middle
we're setting depth
write enabled to "true"

00:22:14.176 --> 00:22:16.036 A:middle
because you actually want
to update that buffer.

00:22:16.966 --> 00:22:19.306 A:middle
Interestingly since there's
no color buffer attached,

00:22:19.746 --> 00:22:21.426 A:middle
you can set your
fragment shader to "no."

00:22:21.496 --> 00:22:22.286 A:middle
There is not really going

00:22:22.286 --> 00:22:23.846 A:middle
to be a fragment
shader operation going

00:22:23.846 --> 00:22:26.846 A:middle
on for this configuration
for this drawing.

00:22:27.386 --> 00:22:30.816 A:middle
And once you have
that information,

00:22:30.816 --> 00:22:32.316 A:middle
you can use that descriptor

00:22:32.316 --> 00:22:35.676 A:middle
to create our render pipeline
state object for our temple mesh

00:22:35.806 --> 00:22:37.196 A:middle
for our shadowMap pass.

00:22:38.236 --> 00:22:40.686 A:middle
Let's do the same thing for
the deferred lighting pass.

00:22:41.226 --> 00:22:43.856 A:middle
Well the deferred lighting
pass is a little bit more rich

00:22:43.856 --> 00:22:46.966 A:middle
in terms of the stream buffer
configuration and terms

00:22:46.966 --> 00:22:48.496 A:middle
of the actions that
are taking place.

00:22:48.806 --> 00:22:51.316 A:middle
So we're going to have both
the vertex and fragment shader

00:22:51.826 --> 00:22:53.876 A:middle
and we're going to
define the pixel formats

00:22:54.226 --> 00:22:55.656 A:middle
for all attachments.

00:22:56.426 --> 00:23:01.876 A:middle
So we have now basically defined
our render pass descriptors;


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:56.426 --> 00:23:01.876 A:middle
So we have now basically defined
our render pass descriptors;

00:23:02.276 --> 00:23:05.866 A:middle
we created our buffers
for meshes, for uniforms;

00:23:06.146 --> 00:23:09.096 A:middle
we created our textures
and uploaded them;

00:23:09.346 --> 00:23:11.636 A:middle
we created our render
pipeline state objects;

00:23:12.056 --> 00:23:13.996 A:middle
well I think we can now
get into the business

00:23:13.996 --> 00:23:15.286 A:middle
of drawing things on the screen.

00:23:16.216 --> 00:23:19.166 A:middle
So...well Richard
did a great job

00:23:19.166 --> 00:23:22.436 A:middle
in explaining how the command
buffers are formed and used

00:23:22.436 --> 00:23:27.626 A:middle
so I'm going you know visit it
for just a bit to remind you.

00:23:27.836 --> 00:23:31.286 A:middle
So we have a single command
queue that is our channel

00:23:31.286 --> 00:23:34.736 A:middle
to the GPU and we get a command
buffer from the command queue

00:23:35.256 --> 00:23:38.096 A:middle
and that's how we do it;
ask the command queue

00:23:38.096 --> 00:23:39.216 A:middle
to give us a new command buffer.

00:23:39.286 --> 00:23:42.976 A:middle
And then once we basically go
ahead and encode all our render

00:23:42.976 --> 00:23:45.586 A:middle
to texture passes, we're
going to be ready to send it

00:23:45.586 --> 00:23:49.286 A:middle
to the GPU so that's how we do
it, by issuing a commit call.

00:23:49.286 --> 00:23:52.706 A:middle
And then finally, command
buffers are not reused.

00:23:52.916 --> 00:23:55.856 A:middle
Once they're used, we get rid
of them and then the next step,

00:23:56.016 --> 00:23:58.446 A:middle
next frame, we're going to get
a new one so we set it to "new"

00:23:58.446 --> 00:23:59.496 A:middle
and that takes care of it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:00.476 --> 00:24:02.326 A:middle
One thing I like to point
out just as Richard did

00:24:02.326 --> 00:24:05.266 A:middle
in the previous session; if
you like to get the results

00:24:05.266 --> 00:24:07.946 A:middle
of your command buffer's
operations to show

00:24:07.946 --> 00:24:09.436 A:middle
up on the screen, you need

00:24:09.436 --> 00:24:12.376 A:middle
to schedule the operation before
committing your command buffer

00:24:12.756 --> 00:24:15.686 A:middle
so that you basically call
the addPresent API to schedule

00:24:15.686 --> 00:24:18.286 A:middle
that so when the command
buffer is executed by the GPU,

00:24:18.576 --> 00:24:20.086 A:middle
the display will
basically know about it

00:24:20.086 --> 00:24:22.596 A:middle
and it will show your
image on the display.

00:24:24.176 --> 00:24:29.196 A:middle
Ok, now is an exciting part;
creating the command encoders

00:24:29.506 --> 00:24:31.786 A:middle
and actually encoding stuff.

00:24:32.146 --> 00:24:35.756 A:middle
Well it is exciting, but there's
actually not much left to do

00:24:35.806 --> 00:24:37.836 A:middle
at this point because you
have done everything up front.

00:24:38.536 --> 00:24:40.216 A:middle
So all we're going to
do is create an encoder

00:24:40.216 --> 00:24:41.406 A:middle
from the command
buffer this time.

00:24:41.716 --> 00:24:43.316 A:middle
There can only be one
command encoder active

00:24:43.316 --> 00:24:44.636 A:middle
at any time on a command buffer.

00:24:45.036 --> 00:24:46.246 A:middle
There's one exception to this;

00:24:46.246 --> 00:24:48.766 A:middle
this is a parallel
RenderCommandEncoder.

00:24:48.886 --> 00:24:51.566 A:middle
I'd like to take a look
at the programming guide

00:24:51.566 --> 00:24:52.656 A:middle
to understand when it's used.

00:24:52.656 --> 00:24:55.506 A:middle
It's mostly when you have a
huge render to texture pass

00:24:55.506 --> 00:24:57.636 A:middle
and you want to basically
paralyze operations

00:24:57.636 --> 00:24:59.576 A:middle
on multiple CPUs; that's
the only time you're going

00:24:59.576 --> 00:25:00.026 A:middle
to use it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:59.576 --> 00:25:00.026 A:middle
to use it.

00:25:00.636 --> 00:25:04.066 A:middle
But for most applications, there
will be one render encoder,

00:25:04.506 --> 00:25:06.796 A:middle
RenderCommandEncoder or
a blip command encoder

00:25:06.796 --> 00:25:09.606 A:middle
or a compute command
encoder active at any time.

00:25:10.426 --> 00:25:13.276 A:middle
So we created one in here;
it's a RenderCommandEncoder

00:25:13.276 --> 00:25:15.316 A:middle
for our shadowMap pass

00:25:15.686 --> 00:25:18.246 A:middle
and we create it using the
shadowMap pass descriptor

00:25:18.556 --> 00:25:20.776 A:middle
that we created just
a few minutes ago.

00:25:20.956 --> 00:25:23.826 A:middle
It has all the information
about the depth attachment

00:25:24.316 --> 00:25:26.846 A:middle
and the structure of the depth
attachment and how it's defined

00:25:26.846 --> 00:25:29.056 A:middle
and all the information
necessary

00:25:29.056 --> 00:25:30.066 A:middle
for creating this encoder.

00:25:30.136 --> 00:25:33.476 A:middle
And then what we do
is just set the sates;

00:25:33.746 --> 00:25:34.846 A:middle
they're all [inaudible] before

00:25:34.846 --> 00:25:36.256 A:middle
so we don't have
to validate them.

00:25:37.016 --> 00:25:41.736 A:middle
And we set the buffers as inputs
for texture samples as inputs

00:25:41.736 --> 00:25:45.096 A:middle
to our draw calls, and then
finally issue our draw calls.

00:25:45.096 --> 00:25:47.976 A:middle
And then repeat this hopefully
thousands and thousands of times

00:25:48.466 --> 00:25:50.716 A:middle
and in each one you will
basically be using a different

00:25:50.716 --> 00:25:51.416 A:middle
kind of state.

00:25:51.636 --> 00:25:54.446 A:middle
But the driver will be able to
just go ahead and fetch them

00:25:54.796 --> 00:25:57.476 A:middle
from a [inaudible] place instead
of creating them on the fly

00:25:57.476 --> 00:25:58.766 A:middle
or validating them on the fly

00:25:59.136 --> 00:26:01.996 A:middle
which makes Metal significantly
faster than the alternative app.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.136 --> 00:26:01.996 A:middle
which makes Metal significantly
faster than the alternative app.

00:26:01.996 --> 00:26:05.366 A:middle
And once you're done,
you finish your encoding

00:26:05.366 --> 00:26:07.566 A:middle
by calling end encoding.

00:26:08.326 --> 00:26:11.726 A:middle
And at this point, the
commands are just created

00:26:11.726 --> 00:26:14.106 A:middle
in the command buffer, but
they're not really submitted

00:26:14.106 --> 00:26:16.956 A:middle
to the GPU; they cannot
be executed on the GPU

00:26:16.956 --> 00:26:18.776 A:middle
yet because that's only done

00:26:18.856 --> 00:26:20.346 A:middle
when you submit your
command buffer,

00:26:20.646 --> 00:26:22.586 A:middle
not when you finish
your encoding.

00:26:23.096 --> 00:26:25.876 A:middle
Let's go create the
encoding for the second pass

00:26:25.876 --> 00:26:28.006 A:middle
because it has an
interesting feature

00:26:28.006 --> 00:26:30.886 A:middle
that we couldn't finish
completing our vendor pass

00:26:30.886 --> 00:26:34.006 A:middle
descriptor early enough because
we didn't have the texture

00:26:34.336 --> 00:26:36.436 A:middle
for our drawable at that point.

00:26:37.016 --> 00:26:40.436 A:middle
So just in the previous session
if you saw that how we can get

00:26:40.436 --> 00:26:42.486 A:middle
that texture, if you
remember doing that,

00:26:42.486 --> 00:26:45.186 A:middle
and then assigning it our
first color attachment

00:26:45.186 --> 00:26:48.696 A:middle
to the texture point of
our first color attachment.

00:26:49.336 --> 00:26:52.186 A:middle
The rest of the descriptor
was well defined before;

00:26:52.186 --> 00:26:55.746 A:middle
we knew what textures to use
and how many textures there were

00:26:56.066 --> 00:26:58.306 A:middle
and so we don't actually
need to modify that part.

00:26:58.306 --> 00:26:59.946 A:middle
We're just going to
basically update this part

00:26:59.946 --> 00:27:02.236 A:middle
of the descriptor and
are going to use that one


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:59.946 --> 00:27:02.236 A:middle
of the descriptor and
are going to use that one

00:27:02.236 --> 00:27:04.586 A:middle
to create our
RenderCommandEncoder

00:27:04.586 --> 00:27:06.826 A:middle
for our deferred lighting pass.

00:27:07.516 --> 00:27:11.456 A:middle
We do the usual, just issue
draw calls and finally end

00:27:11.456 --> 00:27:14.076 A:middle
up finishing our draw calls

00:27:14.476 --> 00:27:16.486 A:middle
and closing our encoder
by end encoding.

00:27:16.826 --> 00:27:19.366 A:middle
And at this point for this
particular application

00:27:19.756 --> 00:27:22.726 A:middle
since you have only 2 passes,
we just call the command buffer

00:27:22.726 --> 00:27:25.086 A:middle
to commit and it
will go to the GPU

00:27:25.086 --> 00:27:27.516 A:middle
and the GPU will start executing
the commands we encoded

00:27:27.516 --> 00:27:27.836 A:middle
just now.

00:27:29.286 --> 00:27:31.266 A:middle
Ok, so that's all I
wanted to talk about;

00:27:31.266 --> 00:27:33.576 A:middle
how to structure your
application to take advantage

00:27:33.576 --> 00:27:36.866 A:middle
of Metal and we're going
to go into a really,

00:27:36.866 --> 00:27:40.186 A:middle
really interesting and new
feature that we have on iOS;

00:27:40.526 --> 00:27:42.676 A:middle
data-parallel computing
on the GPU with Metal

00:27:43.026 --> 00:27:44.656 A:middle
so Aaftab will talk about that.

00:27:44.656 --> 00:27:44.836 A:middle
Thank you.

00:27:45.516 --> 00:27:49.716 A:middle
[ Applause ]

00:27:50.216 --> 00:27:50.836 A:middle
&gt;&gt; Thanks Gokhan.

00:27:51.586 --> 00:27:54.516 A:middle
All right, I'm back.

00:27:54.516 --> 00:27:57.576 A:middle
All right, so I have
15 minutes to talk

00:27:57.576 --> 00:27:59.176 A:middle
about data-parallel
computing so I want to focus

00:27:59.176 --> 00:28:01.466 A:middle
on the key points I
wanted to get across.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.176 --> 00:28:01.466 A:middle
on the key points I
wanted to get across.

00:28:01.466 --> 00:28:05.746 A:middle
So we'll first talk about...and
give a very high level overview

00:28:05.746 --> 00:28:07.096 A:middle
of what is data-parallel
computing,

00:28:07.666 --> 00:28:12.246 A:middle
how Metal does data-parallel
computing, and then we'll look

00:28:12.246 --> 00:28:17.536 A:middle
at how to write kernels in
metal and how to execute them.

00:28:17.616 --> 00:28:18.826 A:middle
And we'll actually
take an example,

00:28:18.826 --> 00:28:21.536 A:middle
a post processing example,
and show how you do that.

00:28:22.106 --> 00:28:23.356 A:middle
All right, so let's start.

00:28:23.766 --> 00:28:25.146 A:middle
So what is data-parallel
computing?

00:28:25.486 --> 00:28:27.896 A:middle
So imagine if you have a piece
of code, let's say a function,

00:28:28.546 --> 00:28:34.036 A:middle
that we can execute all elements
of your data; so maybe elements

00:28:34.036 --> 00:28:36.466 A:middle
in an array or pixels
of an image.

00:28:37.806 --> 00:28:41.436 A:middle
And these computations are
independent to each other.

00:28:41.856 --> 00:28:44.726 A:middle
So that means if I have you know
multiple threads of execution,

00:28:44.726 --> 00:28:48.176 A:middle
I can run them all in
parallel so that's what I mean

00:28:48.176 --> 00:28:49.096 A:middle
by data-parallel computing.

00:28:49.096 --> 00:28:51.746 A:middle
So this is actually a very
simple form a data-parallel

00:28:51.746 --> 00:28:54.436 A:middle
computing and I'll
talk a little bit more

00:28:54.436 --> 00:28:58.436 A:middle
about additional things
you can do in Metal

00:28:58.436 --> 00:28:59.496 A:middle
with data-parallel computing.

00:28:59.496 --> 00:29:04.026 A:middle
So a classic example of this
data-parallel computing is


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.496 --> 00:29:04.026 A:middle
So a classic example of this
data-parallel computing is

00:29:04.026 --> 00:29:05.366 A:middle
blurring an image, right?

00:29:05.366 --> 00:29:08.376 A:middle
So for example you
have an image.

00:29:08.376 --> 00:29:11.356 A:middle
For each pixel you're
looking at a nearby region

00:29:11.356 --> 00:29:12.366 A:middle
and you know applying a filter.

00:29:12.586 --> 00:29:14.366 A:middle
Well I could execute
these in parallel.

00:29:14.366 --> 00:29:16.536 A:middle
So if I had let's
say a 1k by 1k image

00:29:16.896 --> 00:29:18.056 A:middle
and I had a million threads,

00:29:18.306 --> 00:29:21.446 A:middle
I could execute each
pixel in parallel, right?

00:29:21.886 --> 00:29:23.956 A:middle
So how does that work in Metal?

00:29:24.426 --> 00:29:27.716 A:middle
So the code that you're
going to execute in parallel,

00:29:28.236 --> 00:29:29.436 A:middle
we call that a kernel.

00:29:30.056 --> 00:29:32.396 A:middle
And the thing that actually
executes independently,

00:29:32.716 --> 00:29:33.596 A:middle
we call that a work-item.

00:29:33.716 --> 00:29:38.066 A:middle
So on a GPU, a thread may
actually contain multiple

00:29:38.066 --> 00:29:41.496 A:middle
work-items because now a thread
actually may execute multiple

00:29:41.496 --> 00:29:44.146 A:middle
such things in SIMD fashion and
then you have multiple threads.

00:29:44.586 --> 00:29:46.006 A:middle
So the work-item is the thing

00:29:46.006 --> 00:29:48.726 A:middle
that identifies each
independent execution instance.

00:29:49.036 --> 00:29:52.636 A:middle
So you're going stop me
right there and say, "Hey,

00:29:52.636 --> 00:29:55.256 A:middle
that looks just like a
fragment shader," right?

00:29:55.256 --> 00:29:57.556 A:middle
Because that's what
fragment shaders do, right?

00:29:57.856 --> 00:29:59.976 A:middle
You execute the shader
in parallel


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:00.046 --> 00:30:02.886 A:middle
or multiple fragments; they
don't talk to each other.

00:30:03.056 --> 00:30:04.436 A:middle
Like they are in
their own world.

00:30:04.436 --> 00:30:06.166 A:middle
They take inputs;
produce outputs.

00:30:06.686 --> 00:30:08.126 A:middle
So what is this
data-parallelism?

00:30:08.626 --> 00:30:11.716 A:middle
So that is indeed; we
call it SIMD parallelism

00:30:11.716 --> 00:30:15.326 A:middle
and that is a data-parallelism
model supported in Metal.

00:30:15.666 --> 00:30:19.776 A:middle
And the only benefit here
is that you no longer have

00:30:19.776 --> 00:30:21.496 A:middle
to create a graphics pipeline;

00:30:21.496 --> 00:30:25.236 A:middle
you don't specify a vertex
shader and a fragment shader

00:30:25.236 --> 00:30:26.256 A:middle
and sate and things like that.

00:30:26.256 --> 00:30:27.846 A:middle
You just say, "Here
is my function,

00:30:27.986 --> 00:30:29.506 A:middle
here is my problem size,

00:30:29.706 --> 00:30:31.746 A:middle
go execute this function
over there."

00:30:31.826 --> 00:30:35.166 A:middle
But there's more to it than that
because in data-parallelism,

00:30:35.426 --> 00:30:38.926 A:middle
you can actually tell
the number of algorithms

00:30:38.926 --> 00:30:41.636 A:middle
where you actually
want these work-items

00:30:41.996 --> 00:30:43.466 A:middle
to communicate with each other.

00:30:43.566 --> 00:30:45.006 A:middle
Let's take an example;
let's say I want to --

00:30:45.106 --> 00:30:48.186 A:middle
a very simple example -- I want
to sum elements of an array.

00:30:48.216 --> 00:30:51.026 A:middle
It's referred to as a
classic problem of reduction.

00:30:51.556 --> 00:30:54.716 A:middle
So in that case, you now we
have these work-items generating

00:30:54.766 --> 00:30:57.506 A:middle
partial results and
you keep looking

00:30:57.506 --> 00:31:00.316 A:middle
over until you finally have
you know 2 partial sums


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:57.506 --> 00:31:00.316 A:middle
over until you finally have
you know 2 partial sums

00:31:00.316 --> 00:31:01.446 A:middle
and then you get the final sum.

00:31:01.656 --> 00:31:04.996 A:middle
But in order to make this
work, these work-items need

00:31:05.036 --> 00:31:08.746 A:middle
to know the results generated by
other work-items, so they need

00:31:08.746 --> 00:31:11.116 A:middle
to be able to talk and you
know talk is always good.

00:31:11.526 --> 00:31:14.476 A:middle
So what you can do in
Metal is you can say, "Hey,

00:31:14.476 --> 00:31:17.166 A:middle
these work-items, they
work together," ok?

00:31:17.166 --> 00:31:18.696 A:middle
And we call that a work-group.

00:31:19.456 --> 00:31:20.866 A:middle
And these work-items

00:31:20.866 --> 00:31:23.366 A:middle
in the work-group can
actually share data

00:31:23.926 --> 00:31:25.986 A:middle
through what we call
local memory.

00:31:25.986 --> 00:31:28.026 A:middle
Remember we talked in the
previous session about global

00:31:28.026 --> 00:31:30.536 A:middle
and constant and so for kernels,

00:31:30.706 --> 00:31:34.226 A:middle
you get an additional high
bandwidth low latency memory we

00:31:34.226 --> 00:31:34.946 A:middle
call "local memory."

00:31:34.946 --> 00:31:36.796 A:middle
Think of it just as
a user-managed cache.

00:31:36.896 --> 00:31:37.516 A:middle
that's all it is.

00:31:37.516 --> 00:31:39.886 A:middle
And then they can
synchronize because now

00:31:40.196 --> 00:31:43.276 A:middle
when these threads want...or
work-items want to communicate,

00:31:43.276 --> 00:31:45.536 A:middle
they need to make sure they
arrive at a place together

00:31:45.616 --> 00:31:48.996 A:middle
so they can exchange data
so you get all of that

00:31:49.406 --> 00:31:50.706 A:middle
with data-parallelism in Metal.

00:31:50.856 --> 00:31:51.806 A:middle
So let's...

00:31:53.206 --> 00:31:55.926 A:middle
Ok? So I wrote my code
that can do all of this,

00:31:56.086 --> 00:31:57.746 A:middle
but how do I describe
my problem?

00:31:58.326 --> 00:32:01.736 A:middle
So the thing is we called it a
computation domain so depending


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.326 --> 00:32:01.736 A:middle
So the thing is we called it a
computation domain so depending

00:32:01.736 --> 00:32:05.506 A:middle
on what thing you're going to
execute this function over,

00:32:05.506 --> 00:32:07.686 A:middle
if it's an array, your
problem is 1-dimensional.

00:32:08.156 --> 00:32:10.366 A:middle
If it's an image, your
problem is 2-dimensional.

00:32:11.036 --> 00:32:13.386 A:middle
So I've specified
the dimensions,

00:32:13.476 --> 00:32:14.926 A:middle
but what else do
I need to specify?

00:32:15.096 --> 00:32:17.586 A:middle
Well now I need to tell
you how many work items are

00:32:17.586 --> 00:32:20.456 A:middle
in my work-group and then how
many work-groups do I have?

00:32:20.826 --> 00:32:22.726 A:middle
So that describes the
number of work-items

00:32:23.276 --> 00:32:24.806 A:middle
in the work-group times
the number of work-groups

00:32:24.806 --> 00:32:26.136 A:middle
that describes the total problem

00:32:26.136 --> 00:32:28.046 A:middle
that will be executed
in parallel.

00:32:28.416 --> 00:32:30.926 A:middle
So choose the dimensions that
are best for your algorithm.

00:32:30.926 --> 00:32:32.326 A:middle
So if you're doing
an image processing,

00:32:32.326 --> 00:32:34.456 A:middle
a post processing effect,
you know you're going

00:32:34.456 --> 00:32:35.666 A:middle
to operate on textures.

00:32:35.666 --> 00:32:39.366 A:middle
Use 2D. Yeah, you could do it
in 1D, but who wants to do all

00:32:39.366 --> 00:32:41.346 A:middle
that work to turn that 2D to 1D?

00:32:41.416 --> 00:32:42.886 A:middle
And you shouldn't have to.

00:32:43.316 --> 00:32:46.346 A:middle
And the work-items you
have in your work-group,

00:32:46.496 --> 00:32:48.196 A:middle
how many they are,
it's going to depend

00:32:48.196 --> 00:32:49.696 A:middle
on the algorithm you're using.

00:32:49.696 --> 00:32:52.966 A:middle
It's going to depend on how many
loads to operations you're doing

00:32:52.966 --> 00:32:57.206 A:middle
and how much computations; a
ratio of memory to computations

00:32:57.386 --> 00:32:58.816 A:middle
and so play with that.

00:32:58.816 --> 00:32:59.706 A:middle
Choose the right dimensions.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:00.286 --> 00:33:02.376 A:middle
You have the flexibility
because you can specify these.

00:33:03.306 --> 00:33:04.766 A:middle
All right, so let's
take an example.

00:33:04.966 --> 00:33:08.356 A:middle
We'll look at how to take
pseudo-code C, C Plus Plus code,

00:33:08.356 --> 00:33:09.486 A:middle
and make it into shaders.

00:33:09.826 --> 00:33:11.606 A:middle
We'll look at how we do that
for calls and we're going

00:33:11.606 --> 00:33:13.246 A:middle
to take a really,
really simple example.

00:33:13.246 --> 00:33:16.836 A:middle
So this function takes an
input, squares the result

00:33:16.836 --> 00:33:19.006 A:middle
for each element,
and writs it out.

00:33:19.306 --> 00:33:21.296 A:middle
And remember ah,

00:33:21.296 --> 00:33:23.416 A:middle
it has the...the
function is not complete.

00:33:24.356 --> 00:33:26.716 A:middle
So we include the standard
library just like we did

00:33:26.716 --> 00:33:28.846 A:middle
for shaders and we use
the Metal namespace.

00:33:29.196 --> 00:33:32.036 A:middle
So remember, we're going
to execute this function

00:33:32.036 --> 00:33:35.376 A:middle
for each index in
parallel but first,

00:33:35.666 --> 00:33:38.366 A:middle
I need to tell the compiler that
this is a data-parallel function

00:33:38.486 --> 00:33:39.826 A:middle
so that's what the
kernel is going

00:33:39.826 --> 00:33:41.276 A:middle
to do; that's the qualifier.

00:33:41.396 --> 00:33:45.526 A:middle
All right, I'm passing
pointers so I need

00:33:45.526 --> 00:33:48.806 A:middle
to specify these buffers, what
indices they're going to be in

00:33:48.806 --> 00:33:50.856 A:middle
and that they're in the
global address space.

00:33:50.856 --> 00:33:51.646 A:middle
Remember we talked

00:33:51.756 --> 00:33:53.446 A:middle
in the previous session
about address spaces?

00:33:53.446 --> 00:33:56.286 A:middle
So these are coming in
global and then I need

00:33:56.286 --> 00:33:59.526 A:middle
to tell the compiler that
this ID to I'm going to use

00:33:59.526 --> 00:34:03.226 A:middle
to index is unique for each
instance and so in this case,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.526 --> 00:34:03.226 A:middle
to index is unique for each
instance and so in this case,

00:34:03.226 --> 00:34:05.326 A:middle
I call that a "global ID," ok?

00:34:05.606 --> 00:34:07.726 A:middle
So we have a vertex
ID and compute.

00:34:08.186 --> 00:34:09.696 A:middle
You have global IDs, ok?

00:34:09.835 --> 00:34:12.585 A:middle
So pretty simple;
pretty straightforward.

00:34:12.786 --> 00:34:14.446 A:middle
Well let's say if
I'm using textures,

00:34:14.446 --> 00:34:15.926 A:middle
how would I write a kernel.

00:34:16.016 --> 00:34:20.306 A:middle
So let's say I'm trying to just
mirror an image horizontally,

00:34:20.505 --> 00:34:24.906 A:middle
so this was my image and I
want to...remember what I said,

00:34:25.255 --> 00:34:26.206 A:middle
"Use the right dimensions?"

00:34:26.505 --> 00:34:28.156 A:middle
So since I'm operating
on an image,

00:34:28.246 --> 00:34:31.025 A:middle
I really want my global ID
to be 2-dimensional in nature

00:34:31.326 --> 00:34:32.476 A:middle
and that's what I'm doing here.

00:34:32.956 --> 00:34:35.626 A:middle
And I want to read
from my input texture

00:34:36.045 --> 00:34:37.446 A:middle
after I have mirrored
the coordinate

00:34:37.446 --> 00:34:38.876 A:middle
and then I want to write it out.

00:34:39.366 --> 00:34:42.196 A:middle
So you're going to find
in writing kernels,

00:34:43.016 --> 00:34:45.686 A:middle
just like writing
shaders, it's really easy.

00:34:45.985 --> 00:34:48.835 A:middle
Its C Plus Plus code; it's
standard with information

00:34:48.835 --> 00:34:51.636 A:middle
so that a compiler knows
what you are trying to do.

00:34:52.106 --> 00:34:55.356 A:middle
Ok, remember we talked
about built-in variables?

00:34:55.686 --> 00:34:59.606 A:middle
You had a special attribute
to say position, front-facing,

00:34:59.606 --> 00:35:00.866 A:middle
and things like that
for graphics?


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.606 --> 00:35:00.866 A:middle
and things like that
for graphics?

00:35:01.336 --> 00:35:03.706 A:middle
Well we have something
similar for kernels too.

00:35:04.576 --> 00:35:07.636 A:middle
Well global ID; you guys
already know it is now, right?

00:35:08.336 --> 00:35:12.186 A:middle
So in this case, my example, I'm
actually using...I'm operating

00:35:12.186 --> 00:35:15.016 A:middle
on a texture so my global
ID is 2-dimensional.

00:35:15.236 --> 00:35:17.936 A:middle
So it can be a ushort2 or uint2

00:35:18.466 --> 00:35:20.196 A:middle
so use the right
dimensions you want.

00:35:20.556 --> 00:35:24.096 A:middle
Now so that's great if I'm
only operating on textures

00:35:24.306 --> 00:35:27.126 A:middle
in my kernel, but what if
I'm passing in buffers too?

00:35:27.596 --> 00:35:29.226 A:middle
So when I access my texture,

00:35:29.266 --> 00:35:31.226 A:middle
I'm going to use my
2-dimensional global ID,

00:35:31.226 --> 00:35:34.416 A:middle
but if I access a buffer, I need
to create a 1-dimensional ID.

00:35:34.536 --> 00:35:38.006 A:middle
So we're trying to help you
not have to write all that code

00:35:38.006 --> 00:35:40.156 A:middle
because there may be bugs;
we fixed that for you

00:35:40.276 --> 00:35:41.556 A:middle
so that's the global linear ID.

00:35:42.006 --> 00:35:44.696 A:middle
So now remember we said,

00:35:44.696 --> 00:35:46.236 A:middle
"Work-items work
in a work-group?"

00:35:46.716 --> 00:35:47.936 A:middle
So within that work-group,

00:35:47.936 --> 00:35:49.846 A:middle
I need to know which
instance I am.

00:35:50.266 --> 00:35:53.506 A:middle
So I have global ID; we
call this the "local id."

00:35:54.186 --> 00:35:56.436 A:middle
And just like you can have
a 2-dimensional local ID,

00:35:57.016 --> 00:35:58.156 A:middle
there's also a 1-dimensional;

00:35:59.096 --> 00:36:00.326 A:middle
we call that that the
"local linear ID."


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.096 --> 00:36:00.326 A:middle
we call that that the
"local linear ID."

00:36:00.326 --> 00:36:03.166 A:middle
So you just specify these
attributes for the arguments

00:36:03.166 --> 00:36:06.516 A:middle
to your kernel function and
the compiler will generate the

00:36:06.516 --> 00:36:07.066 A:middle
right code.

00:36:07.556 --> 00:36:10.646 A:middle
And finally we call this
the "work-group ID."

00:36:10.646 --> 00:36:12.156 A:middle
And so why do I care about this?

00:36:12.476 --> 00:36:17.006 A:middle
Well remember you specify
the number of work-items

00:36:17.586 --> 00:36:19.166 A:middle
in the work-group and
number of work-groups?

00:36:19.596 --> 00:36:22.486 A:middle
So let's take...for an example
I'm generating a histogram.

00:36:22.806 --> 00:36:26.346 A:middle
So each work-group...one way you
could do this is each work-group

00:36:26.346 --> 00:36:28.666 A:middle
could generate a partial
histogram, so a histogram

00:36:28.666 --> 00:36:30.056 A:middle
for the things it's working on.

00:36:30.446 --> 00:36:31.646 A:middle
And then you will
run another kernel

00:36:31.646 --> 00:36:33.486 A:middle
that could sum these
partial histograms

00:36:33.486 --> 00:36:34.736 A:middle
and generate a final histogram.

00:36:35.996 --> 00:36:38.006 A:middle
Well so that means I
need to write the results

00:36:38.006 --> 00:36:41.096 A:middle
of these partial histograms
to some buffer, right?

00:36:41.516 --> 00:36:43.906 A:middle
Well I don't want to create
a buffer for each work-group

00:36:43.906 --> 00:36:45.996 A:middle
so I just want to
allocate one buffer

00:36:46.096 --> 00:36:49.566 A:middle
so guess what index
would I use to write?

00:36:49.936 --> 00:36:51.176 A:middle
That would be my work-group ID

00:36:51.176 --> 00:36:54.326 A:middle
so that's how you
would use it, ok?

00:36:54.966 --> 00:36:57.346 A:middle
All right, so let's see
how to execute kernels.

00:36:57.346 --> 00:37:01.276 A:middle
What commands do I
encode to send work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.346 --> 00:37:01.276 A:middle
What commands do I
encode to send work

00:37:01.276 --> 00:37:02.606 A:middle
to the GPU to execute a kernel?

00:37:02.606 --> 00:37:04.606 A:middle
And we're going to take
a post-processing example

00:37:04.606 --> 00:37:06.596 A:middle
so this is going to do
some highlights, shadows,

00:37:06.636 --> 00:37:08.006 A:middle
renew the facts and
things like that

00:37:08.006 --> 00:37:09.476 A:middle
and I'll actually demo
that for you guys.

00:37:09.856 --> 00:37:11.706 A:middle
So let's look at the source.

00:37:11.706 --> 00:37:13.436 A:middle
I'm not going to give the
details of the source;

00:37:13.436 --> 00:37:15.936 A:middle
just give a very high-level
picture of what's happening.

00:37:15.986 --> 00:37:18.836 A:middle
So it takes a number of
images and some information.

00:37:19.066 --> 00:37:21.956 A:middle
It's going to take the
global ID and transform

00:37:21.956 --> 00:37:24.356 A:middle
that using some matrix;
an affine matrix.

00:37:24.816 --> 00:37:26.326 A:middle
It's going to sample
from an image

00:37:26.636 --> 00:37:28.596 A:middle
and then apply a
post-processing effect,

00:37:28.996 --> 00:37:30.896 A:middle
and then write to an image, ok?

00:37:30.896 --> 00:37:33.096 A:middle
And then you're going
to say, "That looks just

00:37:33.096 --> 00:37:33.936 A:middle
like a fragment shader."

00:37:34.646 --> 00:37:36.506 A:middle
Well in this case, yes it does.

00:37:37.096 --> 00:37:40.716 A:middle
But remember, the number
of work-items times number

00:37:40.716 --> 00:37:43.526 A:middle
of work-groups makeup the total
problem domain you're going

00:37:43.526 --> 00:37:44.066 A:middle
to operate on.

00:37:44.536 --> 00:37:45.566 A:middle
There is no such requirement

00:37:45.566 --> 00:37:48.086 A:middle
that each work-item must
only operate on only 1 pixel;

00:37:48.546 --> 00:37:50.146 A:middle
it could actually
operate on many pixels.

00:37:50.566 --> 00:37:52.996 A:middle
And depending on what you
are doing in your code --

00:37:52.996 --> 00:37:55.556 A:middle
again that computation
to memory ratio --

00:37:56.336 --> 00:37:59.736 A:middle
you may find its better to
do more work than less work.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.326 --> 00:38:02.376 A:middle
So when we do this, we
actually modify this kernel.

00:38:02.536 --> 00:38:04.386 A:middle
So we have a crack
team working on it

00:38:04.896 --> 00:38:07.386 A:middle
and what they did
is they changed it

00:38:07.716 --> 00:38:09.306 A:middle
to 4 pixels per work-item.

00:38:10.756 --> 00:38:12.636 A:middle
It's like...it was
actually faster.

00:38:13.106 --> 00:38:14.616 A:middle
And so we like faster, don't we?

00:38:16.056 --> 00:38:19.066 A:middle
So that's what it's
doing; it's for...so and so

00:38:19.066 --> 00:38:22.256 A:middle
in fact each work-group is
doing the work of 4 work-groups

00:38:22.256 --> 00:38:25.306 A:middle
so we don't need to look at this
code, but its straightforward.

00:38:25.306 --> 00:38:26.896 A:middle
It's going to loop
over these things

00:38:26.896 --> 00:38:28.186 A:middle
that the compiler
is going to unroll.

00:38:28.576 --> 00:38:32.556 A:middle
But the point here is that
there is no requirement

00:38:32.556 --> 00:38:35.416 A:middle
of one-to-one mapping; you
can have one-to-end mapping.

00:38:35.686 --> 00:38:37.976 A:middle
And so you have a lot
of flexibility, ok?

00:38:37.976 --> 00:38:41.066 A:middle
And that can actually
help...really help you tune your

00:38:41.066 --> 00:38:42.936 A:middle
code; your data parellel
function that you want

00:38:42.936 --> 00:38:43.916 A:middle
to execute on the GPU.

00:38:45.196 --> 00:38:47.626 A:middle
All right, so let's talk about
the compute command encoder.

00:38:47.836 --> 00:38:49.846 A:middle
So this is what you
need to send commands

00:38:50.126 --> 00:38:51.656 A:middle
to execute kernels on the GPU.

00:38:52.106 --> 00:38:54.316 A:middle
So just like the
RenderCommandEncoder

00:38:54.486 --> 00:38:56.716 A:middle
for compute, we have this
compute command encoder

00:38:56.716 --> 00:38:58.096 A:middle
but first things first.

00:38:58.636 --> 00:39:00.266 A:middle
Remember I compiled my kernel


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.636 --> 00:39:00.266 A:middle
Remember I compiled my kernel

00:39:00.736 --> 00:39:02.616 A:middle
and so I have created
a Metal library.

00:39:03.086 --> 00:39:04.086 A:middle
And so I'm going to load that

00:39:04.086 --> 00:39:05.396 A:middle
and I'm going to
load that kernel.

00:39:06.236 --> 00:39:07.826 A:middle
The next thing I'm
going to do is I'm going

00:39:07.826 --> 00:39:08.936 A:middle
to create my compute state.

00:39:09.106 --> 00:39:10.736 A:middle
Just like we had the
render pipeline state,

00:39:11.006 --> 00:39:12.396 A:middle
there's the compute
pipeline state.

00:39:12.606 --> 00:39:15.496 A:middle
And all it takes in this
case is just the function.

00:39:16.296 --> 00:39:17.976 A:middle
The compute doesn't
have a lot of states.

00:39:18.686 --> 00:39:19.976 A:middle
So at this point in time,

00:39:20.116 --> 00:39:23.226 A:middle
remember in the Metal library
the information we compiled

00:39:23.226 --> 00:39:27.606 A:middle
from your source to Metal
IR, in LLVM-based IR,

00:39:27.606 --> 00:39:28.906 A:middle
we're going to take that

00:39:28.906 --> 00:39:30.836 A:middle
and when you create a new
compute pipeline state,

00:39:30.836 --> 00:39:33.566 A:middle
we're going to compile it
to the actual GPU binary

00:39:33.566 --> 00:39:35.506 A:middle
that the GPU is going
to execute, ok?

00:39:36.296 --> 00:39:38.776 A:middle
I'm going to create my
compute command encoder.

00:39:40.516 --> 00:39:42.046 A:middle
I'm ready to send commands now.

00:39:43.266 --> 00:39:46.066 A:middle
So the first thing I'm going
to do is set my compute state.

00:39:46.446 --> 00:39:49.446 A:middle
So then I'm going to set my
resources my kernel uses;

00:39:49.446 --> 00:39:50.946 A:middle
remember the buffers
and textures.

00:39:51.496 --> 00:39:54.506 A:middle
And then I'm going to execute
"ready to encode the command"

00:39:54.506 --> 00:39:55.526 A:middle
to execute the kernel.

00:39:55.836 --> 00:39:56.736 A:middle
So in order to do that,

00:39:57.286 --> 00:39:59.966 A:middle
I need to first set the number
work-items in the work-group,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:00.056 --> 00:40:01.176 A:middle
and how many work-groups
there are.

00:40:01.326 --> 00:40:03.956 A:middle
So in this example,
I use a 16 by 16.

00:40:04.036 --> 00:40:05.366 A:middle
Remember they are
2-dimensional problems;

00:40:05.366 --> 00:40:07.986 A:middle
I'm going to give it
2-dimensional work-group size.

00:40:08.436 --> 00:40:11.276 A:middle
And so I know the
output image dimensions,

00:40:11.456 --> 00:40:13.076 A:middle
I know my work-group
size, so I'm going

00:40:13.076 --> 00:40:15.476 A:middle
to know...calculate how many
work-groups there are going

00:40:15.476 --> 00:40:15.796 A:middle
to be.

00:40:17.186 --> 00:40:20.686 A:middle
And now, I encode the
command to execute the kernel.

00:40:20.686 --> 00:40:22.976 A:middle
So 2 things I specify;
the work-group size

00:40:22.976 --> 00:40:24.736 A:middle
and how many work-groups
there are, ok?

00:40:24.736 --> 00:40:27.216 A:middle
And then I'm done encoding.

00:40:27.786 --> 00:40:33.176 A:middle
So at this point in time,
commands have been encoded

00:40:33.866 --> 00:40:35.396 A:middle
but the GPU hasn't
received them.

00:40:35.546 --> 00:40:38.066 A:middle
So just like we talked
about sending commands,

00:40:38.066 --> 00:40:40.246 A:middle
you have to commit the command
buffer and when you do that,

00:40:40.586 --> 00:40:43.136 A:middle
the GPU will start
executing this kernel, ok?

00:40:43.336 --> 00:40:46.216 A:middle
So let me show you a demo of
these filtering operations.

00:40:47.026 --> 00:40:49.096 A:middle
All right, so that's
applying and we know the fact

00:40:49.096 --> 00:40:49.976 A:middle
that we can do shadows.

00:40:50.516 --> 00:40:54.546 A:middle
[ Applause ]

00:40:55.046 --> 00:40:56.686 A:middle
Ok, so that's the
highlights and shadows filter,

00:40:56.856 --> 00:40:58.276 A:middle
but I can actually
do a tune filter.

00:40:58.276 --> 00:41:01.836 A:middle
And so this is actually...what
it's doing is its taking your


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.276 --> 00:41:01.836 A:middle
And so this is actually...what
it's doing is its taking your

00:41:01.836 --> 00:41:03.376 A:middle
input image and
applying...converting it

00:41:03.376 --> 00:41:05.276 A:middle
into a what we'll
call the LAB space

00:41:05.276 --> 00:41:08.936 A:middle
which approximates human vision,
then does a bilateral filter,

00:41:08.936 --> 00:41:10.346 A:middle
and then actually
does the tune filter,

00:41:10.346 --> 00:41:12.186 A:middle
and then converts
it back to RGB.

00:41:12.186 --> 00:41:14.076 A:middle
Or let's say I want to
sharpen it so I want

00:41:14.076 --> 00:41:15.186 A:middle
to apply a sharpen filter.

00:41:15.746 --> 00:41:19.306 A:middle
So you can see we adjusted the
image, it's getting sharpened.

00:41:19.306 --> 00:41:22.796 A:middle
Hopefully you do see reduced of
the image getting sharpened, ok?

00:41:22.976 --> 00:41:24.226 A:middle
So these are some of the filters

00:41:24.456 --> 00:41:25.976 A:middle
and these are really,
really easy to write.

00:41:25.976 --> 00:41:29.596 A:middle
Because in effect what you're
doing now is you're just writing

00:41:29.596 --> 00:41:32.946 A:middle
your code, you're algorithm,
just as a set of functions.

00:41:33.346 --> 00:41:34.826 A:middle
And saying, "Execute
this function

00:41:34.826 --> 00:41:36.776 A:middle
or this problem domain."

00:41:36.776 --> 00:41:39.006 A:middle
Really, really simple
to think about.

00:41:39.006 --> 00:41:40.236 A:middle
So focus more on the algorithm

00:41:40.236 --> 00:41:42.926 A:middle
and that's what data-parallel
computing allows you to do, ok?

00:41:43.956 --> 00:41:46.486 A:middle
So that's all I could...that's
all I'm going to say

00:41:46.486 --> 00:41:48.196 A:middle
about data-parallel
computing and next,

00:41:48.406 --> 00:41:49.706 A:middle
we're going to have Serhat come

00:41:49.706 --> 00:41:51.416 A:middle
and show you the
amazing tools we have

00:41:51.416 --> 00:41:54.596 A:middle
and show you how you can debug
profile Metal applications

00:41:54.596 --> 00:41:55.976 A:middle
in Xcode, so Serhat.

00:41:56.516 --> 00:42:03.566 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:56.516 --> 00:42:03.566 A:middle
[ Applause ]

00:42:04.066 --> 00:42:05.956 A:middle
&gt;&gt; Well thank you Aaftab
and hello everyone.

00:42:07.086 --> 00:42:09.846 A:middle
Now I'm going to show off the
great developer tools we have

00:42:10.286 --> 00:42:12.106 A:middle
in Xcode for your Metal apps.

00:42:12.956 --> 00:42:15.316 A:middle
We'll be focusing
on some combinations

00:42:15.406 --> 00:42:19.426 A:middle
such as state setup, shadow
completion, and performance,

00:42:20.046 --> 00:42:22.866 A:middle
and how you can use the tools
to address these issues.

00:42:24.076 --> 00:42:28.166 A:middle
So I have the same app that
Gokhan showed you earlier here.

00:42:28.646 --> 00:42:31.576 A:middle
The shadow buffer
pass has been modified

00:42:31.576 --> 00:42:34.236 A:middle
to use percentage closer
filtering for softer shadows,

00:42:34.236 --> 00:42:37.226 A:middle
but my app has a few issues
that I'm going to fix live.

00:42:38.166 --> 00:42:41.086 A:middle
So let's go ahead and run it.

00:42:41.336 --> 00:42:44.776 A:middle
Ok as you can see,
I've got some compilers

00:42:44.996 --> 00:42:49.266 A:middle
and Xcode is pointing right
here at my G-buffer shader code.

00:42:49.786 --> 00:42:52.506 A:middle
So one of the great things
with Metal is its support

00:42:52.506 --> 00:42:54.946 A:middle
for pre-compiled shaders
right here in Xcode.

00:42:55.626 --> 00:42:59.496 A:middle
So in addition to the improved
initialization time for my app

00:42:59.496 --> 00:43:03.576 A:middle
and other benefits, I also
get to see the compilers


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:59.496 --> 00:43:03.576 A:middle
and other benefits, I also
get to see the compilers

00:43:03.576 --> 00:43:06.296 A:middle
and warnings right here
in Xcode at build time

00:43:06.436 --> 00:43:07.356 A:middle
as opposed to run time.

00:43:08.286 --> 00:43:09.926 A:middle
Let's go in and fix
this real quick.

00:43:10.926 --> 00:43:15.566 A:middle
Let's define usable
variables and launch the app.

00:43:15.956 --> 00:43:19.226 A:middle
Now you can imagine this offers
a much more productive workflow

00:43:19.226 --> 00:43:20.286 A:middle
for shader development.

00:43:21.366 --> 00:43:23.666 A:middle
Also using it is pretty
easy, all you have

00:43:23.666 --> 00:43:26.026 A:middle
to do is you add your
dot mil shader files,

00:43:26.026 --> 00:43:30.096 A:middle
your Xcode project, and
Xcode takes care of the rest.

00:43:30.096 --> 00:43:32.996 A:middle
Ok so my app is running now,
but there's something wrong

00:43:32.996 --> 00:43:33.926 A:middle
with what I'm rendering.

00:43:34.536 --> 00:43:37.076 A:middle
Now I'm going to take a
frame capture and bring

00:43:37.076 --> 00:43:39.696 A:middle
up the frame developer so that
you can see the issue as well

00:43:39.696 --> 00:43:42.666 A:middle
and to do that, I'm going to
click on this camera icon here

00:43:42.666 --> 00:43:45.246 A:middle
in the Debug bar and
trigger a capture.

00:43:46.396 --> 00:43:47.676 A:middle
When I trigger a capture,

00:43:48.036 --> 00:43:50.856 A:middle
the frame debugger harvests
all the Metal commands

00:43:50.856 --> 00:43:54.726 A:middle
that your application
uses in the frame along

00:43:54.726 --> 00:43:57.056 A:middle
with all the other
resources that it uses

00:43:57.056 --> 00:43:59.326 A:middle
as buffers, textures
and shaders.

00:43:59.786 --> 00:44:03.146 A:middle
With these we can reconstruct
the frame and you can replay


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.786 --> 00:44:03.146 A:middle
With these we can reconstruct
the frame and you can replay

00:44:03.146 --> 00:44:05.606 A:middle
to any particular Metal
command that we choose.

00:44:06.306 --> 00:44:08.106 A:middle
So this is what I was seeing

00:44:08.406 --> 00:44:10.816 A:middle
and you can see my theme
is completely in shadow

00:44:12.106 --> 00:44:13.676 A:middle
and I'm missing my
directional light.

00:44:14.356 --> 00:44:17.326 A:middle
So let's use the frame debugger
to figure out the problem.

00:44:18.576 --> 00:44:21.336 A:middle
Well the first thing
I want to do is I want

00:44:21.336 --> 00:44:23.486 A:middle
to check my commands and make
sure everything is in order.

00:44:24.246 --> 00:44:26.726 A:middle
For that, I'm going to use
the debug navigator here

00:44:26.726 --> 00:44:28.616 A:middle
on the left-hand side
of the Xcode window.

00:44:29.836 --> 00:44:32.756 A:middle
This is where the debugger
shows the old Metal commands

00:44:33.636 --> 00:44:34.986 A:middle
that were executing
in the frame.

00:44:35.596 --> 00:44:38.346 A:middle
You can see that it also
reflects the natural hierarchy

00:44:38.346 --> 00:44:40.036 A:middle
of your command encoders

00:44:40.036 --> 00:44:43.086 A:middle
within your command buffers
that's making it a lot easier

00:44:43.086 --> 00:44:44.256 A:middle
for you to navigate your frame.

00:44:45.436 --> 00:44:48.336 A:middle
Well one thing to keep in mind
here though is the order you see

00:44:48.336 --> 00:44:52.136 A:middle
here is the order that the
GPU executes these commands

00:44:52.136 --> 00:44:53.796 A:middle
so it's a bit different
than CPU debugging.

00:44:54.116 --> 00:44:57.906 A:middle
You can also see that most

00:44:57.906 --> 00:45:00.046 A:middle
of my objects here have
human readable names,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:57.906 --> 00:45:00.046 A:middle
of my objects here have
human readable names,

00:45:00.046 --> 00:45:01.586 A:middle
not just draw pointer values.

00:45:02.346 --> 00:45:05.946 A:middle
Metal class has a label
property that lets you set this

00:45:06.026 --> 00:45:08.076 A:middle
and I highly recommend
taking advantage of it

00:45:08.076 --> 00:45:09.666 A:middle
as it's an aid in debugging.

00:45:11.136 --> 00:45:12.396 A:middle
Within the encoders,

00:45:13.116 --> 00:45:16.596 A:middle
I can further annotate my
command stream using debug

00:45:16.596 --> 00:45:19.556 A:middle
groups shown in the navigator
as these folder icons.

00:45:20.996 --> 00:45:25.646 A:middle
Well I can do this by using
the push and pop debug APIs

00:45:25.646 --> 00:45:28.196 A:middle
and the debug groups are great

00:45:28.196 --> 00:45:30.866 A:middle
for bracketing related commands
together here in the navigator.

00:45:31.556 --> 00:45:34.116 A:middle
Now let's investigate the
G-buffer pass and figure

00:45:34.116 --> 00:45:35.286 A:middle
out what's wrong
with the shadows.

00:45:35.286 --> 00:45:38.016 A:middle
I'm going to click on
this structure debug group

00:45:38.066 --> 00:45:41.796 A:middle
to navigate there; there you go.

00:45:42.016 --> 00:45:46.256 A:middle
And as I navigate my frame,
Xcode main editor area is going

00:45:46.256 --> 00:45:49.016 A:middle
to update and show me
all the attachments

00:45:49.016 --> 00:45:50.066 A:middle
for the current framebuffer.

00:45:50.686 --> 00:45:53.846 A:middle
The assistant editor is
where I see all my textures,

00:45:54.146 --> 00:45:55.766 A:middle
buffers, and functions.

00:45:56.576 --> 00:45:59.456 A:middle
Currently sits in bound GPU
objects so it's only going

00:45:59.456 --> 00:46:01.216 A:middle
to show me the objects
that are bound


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:59.456 --> 00:46:01.216 A:middle
to show me the objects
that are bound

00:46:01.216 --> 00:46:03.006 A:middle
to the current command encoder.

00:46:03.686 --> 00:46:07.536 A:middle
All right, so I can see that my
debuffer attachments look more

00:46:07.536 --> 00:46:08.876 A:middle
or less correct except
for the color.

00:46:09.516 --> 00:46:11.186 A:middle
But if I look at the assistant,

00:46:12.006 --> 00:46:14.376 A:middle
I see that my shadow
texture bound

00:46:14.376 --> 00:46:16.076 A:middle
to my fragment shader
here labeled

00:46:16.076 --> 00:46:17.056 A:middle
as "shadow" is all black.

00:46:18.176 --> 00:46:22.216 A:middle
So that explains why my scene
was completely in shadow,

00:46:22.296 --> 00:46:24.756 A:middle
but it also means that my shadow
buffer passes aren't working

00:46:24.756 --> 00:46:28.876 A:middle
properly so let's just go there
and investigate so I'm going

00:46:28.876 --> 00:46:32.276 A:middle
to just expand this and
click on the encoder itself.

00:46:33.376 --> 00:46:35.566 A:middle
Now looking at this
I can see right away

00:46:35.736 --> 00:46:37.096 A:middle
that the depth attachment

00:46:37.096 --> 00:46:39.236 A:middle
for this pass isn't
cleared when it starts.

00:46:40.446 --> 00:46:41.886 A:middle
As Gokhan explained earlier,

00:46:41.886 --> 00:46:44.346 A:middle
you control your
framebuffer attachment clears

00:46:44.346 --> 00:46:46.636 A:middle
with the load action
property of the attachment.

00:46:48.536 --> 00:46:52.096 A:middle
Now not only that, but this
don't look like it was rendered

00:46:52.096 --> 00:46:55.296 A:middle
from the point of light either
but if I step through my frame

00:46:55.596 --> 00:46:58.796 A:middle
to see my geometry,
that looks proper.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:00.036 --> 00:47:03.646 A:middle
So let's look at the
framebuffer state and figure

00:47:03.646 --> 00:47:04.616 A:middle
out what the problem is there.

00:47:05.226 --> 00:47:06.676 A:middle
I can investigate this state

00:47:06.676 --> 00:47:09.236 A:middle
of "any Metal object
using the variables view,"

00:47:09.236 --> 00:47:10.016 A:middle
here at the bottom.

00:47:10.056 --> 00:47:11.956 A:middle
I'll expand that a
little bit [inaudible].

00:47:11.956 --> 00:47:16.786 A:middle
On the right-hand side, I have
a list of all my Metal objects.

00:47:17.276 --> 00:47:20.216 A:middle
But I like to use the Auto
View you see on the left.

00:47:20.216 --> 00:47:23.336 A:middle
This is where you see all the
relevant objects and their state

00:47:23.766 --> 00:47:25.816 A:middle
for the current selected
command only.

00:47:26.506 --> 00:47:28.256 A:middle
So I know what I'm looking for.

00:47:29.136 --> 00:47:30.596 A:middle
My framebuffer state
is going to be

00:47:30.596 --> 00:47:33.176 A:middle
under the RenderCommandEncoder
so I'm going to disclose that

00:47:33.176 --> 00:47:35.366 A:middle
and search for framebuffer.

00:47:35.886 --> 00:47:40.646 A:middle
And yeah, as I suspected, my
load action is not set to clear.

00:47:40.646 --> 00:47:44.966 A:middle
And not only that, the attached
texture here is actually depth;

00:47:45.116 --> 00:47:47.556 A:middle
the texture I was looking at
earlier was labeled "shadow."

00:47:48.686 --> 00:47:51.946 A:middle
Now if I disclose my
frame reference setup

00:47:51.946 --> 00:47:52.946 A:middle
that I prepared earlier,

00:47:52.946 --> 00:47:56.236 A:middle
I can see that I already
have a shadow frame buffer

00:47:56.236 --> 00:47:58.386 A:middle
but I'm using debug
framebuffer here.

00:47:58.386 --> 00:48:01.836 A:middle
So that explains why I
was getting a blank shadow


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:58.386 --> 00:48:01.836 A:middle
So that explains why I
was getting a blank shadow

00:48:01.836 --> 00:48:02.466 A:middle
buffer texture.

00:48:02.846 --> 00:48:06.386 A:middle
I can quickly fix this by
using the debug navigator

00:48:06.386 --> 00:48:07.766 A:middle
to take me straight
to the problem.

00:48:08.666 --> 00:48:12.296 A:middle
And I can do that by going
back to the navigator.

00:48:13.006 --> 00:48:14.796 A:middle
Now you setup your framebuffer

00:48:14.796 --> 00:48:16.516 A:middle
when you're creating your
RenderCommandEncoder.

00:48:16.676 --> 00:48:18.616 A:middle
I can disclose the back-trace

00:48:19.106 --> 00:48:21.026 A:middle
where I create the
RenderCommandEncoder and use

00:48:21.026 --> 00:48:23.306 A:middle
that to jump straight
to the source.

00:48:24.236 --> 00:48:25.936 A:middle
So let me go ahead and
fix this real quick.

00:48:29.756 --> 00:48:30.886 A:middle
It should be shadow.

00:48:31.026 --> 00:48:33.956 A:middle
I like to stop my
app and relaunch it

00:48:34.926 --> 00:48:36.636 A:middle
and make sure everything
is running properly.

00:48:37.516 --> 00:48:43.086 A:middle
[ Pause ]

00:48:43.586 --> 00:48:47.686 A:middle
All right, so my theme
looks great now but looking

00:48:47.686 --> 00:48:49.466 A:middle
at the frames per
second tray here,

00:48:50.216 --> 00:48:52.216 A:middle
I can see that I'm not really
getting the performance

00:48:52.216 --> 00:48:52.846 A:middle
I expect.

00:48:52.846 --> 00:48:55.006 A:middle
I'm going to click
on this tray to bring

00:48:55.006 --> 00:48:57.476 A:middle
up the graphics performance
report.

00:48:58.846 --> 00:49:02.746 A:middle
Now I'm getting about
35ish frames per second;


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:58.846 --> 00:49:02.746 A:middle
Now I'm getting about
35ish frames per second;

00:49:02.746 --> 00:49:04.036 A:middle
I was getting 60 earlier.

00:49:05.066 --> 00:49:08.366 A:middle
Now looking at the report, I can
tell my GPU is heavily utilized

00:49:08.366 --> 00:49:10.176 A:middle
with most of the work
coming from the render

00:49:10.216 --> 00:49:11.736 A:middle
or the fragment shader stage.

00:49:13.086 --> 00:49:14.836 A:middle
Ok, to get a more
detailed picture,

00:49:14.836 --> 00:49:16.796 A:middle
let's take another frame capture

00:49:17.196 --> 00:49:19.626 A:middle
and see what the Shader
Profiler has to say about it.

00:49:20.106 --> 00:49:23.556 A:middle
And the Shader Profiler
is at Sampling Profiler.

00:49:24.036 --> 00:49:25.216 A:middle
That's going to automatically

00:49:25.216 --> 00:49:27.116 A:middle
and repeatedly run
all my shaders

00:49:27.116 --> 00:49:28.146 A:middle
in my frame for sampling.

00:49:28.846 --> 00:49:31.626 A:middle
This may take a bit longer
for a more complicated scene,

00:49:31.626 --> 00:49:34.266 A:middle
but that small amount of time
is well worth the investment

00:49:34.266 --> 00:49:36.886 A:middle
as it offers an in depth
performance analysis

00:49:36.886 --> 00:49:38.716 A:middle
that I otherwise
wouldn't be able to get.

00:49:40.046 --> 00:49:41.936 A:middle
Ok, when the Shader
Profiler is done,

00:49:42.546 --> 00:49:45.906 A:middle
I'm going to get this
program performance table here

00:49:45.906 --> 00:49:46.466 A:middle
in the report.

00:49:46.996 --> 00:49:51.276 A:middle
In this table, I get a breakdown
of the performance cost

00:49:51.276 --> 00:49:54.576 A:middle
of all my render
pipelines in the frame along

00:49:54.576 --> 00:49:57.826 A:middle
with all the draw calls
that use these pipelines;

00:49:57.826 --> 00:49:59.366 A:middle
again close so you
don't see that.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:00.466 --> 00:50:03.366 A:middle
Another great way to look
at this is to again go back

00:50:03.366 --> 00:50:06.986 A:middle
to the navigator and
switch it to use the

00:50:06.986 --> 00:50:08.236 A:middle
"View Frame by Program" mode.

00:50:09.696 --> 00:50:11.206 A:middle
Now the nice thing about this is

00:50:11.206 --> 00:50:14.676 A:middle
that I can both navigate my
frame and see my shader profiler

00:50:14.716 --> 00:50:16.096 A:middle
and results at the same time.

00:50:16.836 --> 00:50:20.236 A:middle
So let's look at the
most expensive draw call

00:50:20.346 --> 00:50:22.426 A:middle
and the most expensive
pipeline real quick.

00:50:22.916 --> 00:50:27.586 A:middle
I'm going to hide my
draw call highlight

00:50:27.586 --> 00:50:29.986 A:middle
so that I can see my
attachments better.

00:50:30.396 --> 00:50:32.036 A:middle
And in the Assistant,
I'm going to bring

00:50:32.036 --> 00:50:34.546 A:middle
up that costly fragment shader,
so that I can look at this

00:50:34.546 --> 00:50:36.036 A:middle
for us, make some
more room here.

00:50:36.596 --> 00:50:36.686 A:middle
Oops.

00:50:39.176 --> 00:50:44.346 A:middle
Ok, now as I look at
my code, I can see line

00:50:44.346 --> 00:50:47.866 A:middle
by line profiling data
right alongside my code here

00:50:47.866 --> 00:50:48.386 A:middle
in the editor.

00:50:48.816 --> 00:50:50.336 A:middle
And if I keep scrolling down,

00:50:51.156 --> 00:50:54.986 A:middle
I see that the most expensive
parts of my shader by far is

00:50:54.986 --> 00:50:57.176 A:middle
where I'm doing the
shadow sampling loop.

00:50:58.076 --> 00:50:59.636 A:middle
So this many samples
is an overkill.

00:50:59.636 --> 00:51:04.596 A:middle
Let's reduce it to just a 2 by
2 grid and Save; Command 'S'.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:59.636 --> 00:51:04.596 A:middle
Let's reduce it to just a 2 by
2 grid and Save; Command 'S'.

00:51:05.366 --> 00:51:08.146 A:middle
Now when I do that, my shader
is going to get recompiled

00:51:08.706 --> 00:51:10.656 A:middle
and my changes will
take effect immediately.

00:51:11.776 --> 00:51:14.436 A:middle
And once the shader
profiler is done analyzing,

00:51:14.576 --> 00:51:17.586 A:middle
I'm going to get updated
performance numbers as well.

00:51:18.906 --> 00:51:22.006 A:middle
And I can see that my
attachments look more

00:51:22.006 --> 00:51:23.416 A:middle
or less unaffected; that's good.

00:51:23.796 --> 00:51:26.706 A:middle
And now I'm spending far less
time than the expensive part

00:51:26.706 --> 00:51:28.576 A:middle
of my shader source
and that's great.

00:51:28.846 --> 00:51:33.856 A:middle
And if I scroll all the way to
the end, this is my end result.

00:51:34.776 --> 00:51:38.126 A:middle
Now I can go ahead
and resume my app

00:51:38.386 --> 00:51:40.596 A:middle
and I see a nice smooth
60 frames per second.

00:51:40.986 --> 00:51:41.436 A:middle
Excellent.

00:51:42.066 --> 00:51:45.006 A:middle
With that, my work here
is done and it's time

00:51:45.006 --> 00:51:46.366 A:middle
to leave the stage
back to Aaftab.

00:51:46.366 --> 00:51:46.926 A:middle
Thank you.

00:51:47.516 --> 00:51:53.936 A:middle
[ Applause ]

00:51:54.436 --> 00:51:56.066 A:middle
All right, so let's
summarize, ok?

00:51:56.486 --> 00:52:01.586 A:middle
So Gokhan you know took you
deeper into how Metal works.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:56.486 --> 00:52:01.586 A:middle
So Gokhan you know took you
deeper into how Metal works.

00:52:02.056 --> 00:52:05.336 A:middle
You know we talked about how
you structure the application.

00:52:05.336 --> 00:52:07.706 A:middle
The descriptors and
state objects;

00:52:07.706 --> 00:52:10.576 A:middle
how do you create them
and when to do what.

00:52:10.576 --> 00:52:12.996 A:middle
Like for example; things
you want to do once

00:52:13.436 --> 00:52:15.656 A:middle
like creating your
command queue.

00:52:16.276 --> 00:52:18.296 A:middle
Things you need to
create whenever you need

00:52:18.296 --> 00:52:22.026 A:middle
to like resources, and things
you must create every frame

00:52:22.156 --> 00:52:24.206 A:middle
and every pass, right?

00:52:24.206 --> 00:52:29.946 A:middle
And he showed you how you can do
multi-pass encoding with Metal.

00:52:30.546 --> 00:52:34.286 A:middle
Then I gave you a
small, brief teaser

00:52:34.286 --> 00:52:36.046 A:middle
into data parellel
computing, ok?

00:52:36.196 --> 00:52:40.086 A:middle
And then finally we showed you
the amazing tools that we have

00:52:40.086 --> 00:52:42.846 A:middle
in Metal that you can use to
write amazing applications.

00:52:44.026 --> 00:52:44.766 A:middle
That was it.

00:52:45.256 --> 00:52:49.186 A:middle
So for more information,
any questions, you know,

00:52:49.186 --> 00:52:51.756 A:middle
Philip Iliescu [phonetic] and
Alan Shafer are evangelists;

00:52:51.756 --> 00:52:53.076 A:middle
you know their emails are there.

00:52:53.686 --> 00:52:55.416 A:middle
And documentation
is on our website.

00:52:55.416 --> 00:52:59.696 A:middle
You know you can post questions,
emails, on the developer forums.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:00.916 --> 00:53:03.056 A:middle
The first 2 sessions that
happened this morning,

00:53:03.056 --> 00:53:04.266 A:middle
so these are the ones.

00:53:04.886 --> 00:53:05.466 A:middle
Thank you guys.

00:53:06.508 --> 00:53:08.508 A:middle
[ Applause ]

