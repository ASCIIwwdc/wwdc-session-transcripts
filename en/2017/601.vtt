WEBVTT

00:00:21.516 --> 00:00:27.956 A:middle
[ Applause ]

00:00:28.456 --> 00:00:28.916 A:middle
&gt;&gt; Welcome.

00:00:29.436 --> 00:00:30.996 A:middle
We introduced the host of new

00:00:30.996 --> 00:00:32.576 A:middle
technologies with Metal 2 to

00:00:32.856 --> 00:00:34.846 A:middle
allow you to make better,

00:00:35.116 --> 00:00:36.896 A:middle
faster, and more efficient

00:00:36.896 --> 00:00:37.706 A:middle
applications.

00:00:38.206 --> 00:00:39.396 A:middle
My name is Michal and together

00:00:39.396 --> 00:00:40.856 A:middle
with my colleague Richard we'll

00:00:40.856 --> 00:00:42.756 A:middle
explore three main themes today.

00:00:44.546 --> 00:00:46.546 A:middle
With Metal 2 we are continuing

00:00:46.756 --> 00:00:48.656 A:middle
our direction of moving the

00:00:48.656 --> 00:00:50.526 A:middle
expensive things to happen less

00:00:50.526 --> 00:00:52.266 A:middle
frequently and making sure that

00:00:52.266 --> 00:00:54.376 A:middle
the frequent things are really,

00:00:54.376 --> 00:00:55.176 A:middle
really cheap.

00:00:55.656 --> 00:00:57.356 A:middle
Over the years we introduced

00:00:57.646 --> 00:01:00.226 A:middle
precompiled shaders, render

00:01:00.226 --> 00:01:02.286 A:middle
state objects, Metal Heap last

00:01:02.286 --> 00:01:04.566 A:middle
year all to make sure that you

00:01:04.566 --> 00:01:06.416 A:middle
can move the costly operations

00:01:06.576 --> 00:01:08.796 A:middle
outside of your main application

00:01:09.346 --> 00:01:09.446 A:middle
loop.

00:01:10.096 --> 00:01:13.836 A:middle
We gave you 10 times more draw

00:01:13.836 --> 00:01:15.886 A:middle
calls by switching from open GL

00:01:16.206 --> 00:01:16.696 A:middle
to Metal.

00:01:17.616 --> 00:01:18.996 A:middle
And this year we are introducing

00:01:18.996 --> 00:01:21.496 A:middle
our new binding API that gives

00:01:21.496 --> 00:01:22.866 A:middle
you some more.

00:01:22.866 --> 00:01:24.426 A:middle
And so we will talk about it a

00:01:24.426 --> 00:01:24.946 A:middle
bit further.

00:01:26.446 --> 00:01:29.006 A:middle
We are also putting GPU more in

00:01:29.006 --> 00:01:32.016 A:middle
a driving seat with GPU driven

00:01:32.016 --> 00:01:32.856 A:middle
pipelines.

00:01:33.426 --> 00:01:35.326 A:middle
And you will be able to create

00:01:35.326 --> 00:01:37.966 A:middle
new, novel algorithms, new

00:01:37.966 --> 00:01:40.316 A:middle
rendering techniques, and whole

00:01:40.926 --> 00:01:43.276 A:middle
unique experiences utilizing

00:01:43.276 --> 00:01:45.176 A:middle
Metal 2 on modern GPUs.

00:01:45.546 --> 00:01:46.366 A:middle
Well, speaking of the

00:01:46.366 --> 00:01:49.096 A:middle
experiences, we have a lot of

00:01:49.096 --> 00:01:50.306 A:middle
new features in Metal and we

00:01:50.306 --> 00:01:51.726 A:middle
have three other sessions that I

00:01:51.726 --> 00:01:52.746 A:middle
would love you to attend.

00:01:53.586 --> 00:01:56.786 A:middle
VR is coming to Mac this year

00:01:56.786 --> 00:01:58.986 A:middle
and with the new iMacs we are

00:01:58.986 --> 00:02:01.486 A:middle
giving you really powerful GPUs.

00:02:01.976 --> 00:02:04.056 A:middle
The external GPU is coming to

00:02:04.106 --> 00:02:05.646 A:middle
MacBook Pro to give you the same

00:02:05.646 --> 00:02:06.006 A:middle
power.

00:02:06.726 --> 00:02:09.166 A:middle
And this all enables your users

00:02:09.516 --> 00:02:11.566 A:middle
and your content creators to

00:02:11.566 --> 00:02:14.156 A:middle
experience VR in ways not

00:02:14.156 --> 00:02:14.936 A:middle
possible before.

00:02:15.576 --> 00:02:17.746 A:middle
Tomorrow's session will show you

00:02:18.486 --> 00:02:22.136 A:middle
how to use our display -- direct

00:02:22.136 --> 00:02:23.876 A:middle
display technology -- to get

00:02:23.876 --> 00:02:25.996 A:middle
your content to HMD quick and

00:02:25.996 --> 00:02:26.846 A:middle
with low latency.

00:02:28.176 --> 00:02:29.906 A:middle
You'll learn about the new Metal

00:02:29.906 --> 00:02:32.066 A:middle
API editions for VR and our new

00:02:32.066 --> 00:02:33.066 A:middle
Tools editions.

00:02:35.856 --> 00:02:38.266 A:middle
Machine learning is quickly

00:02:38.266 --> 00:02:40.296 A:middle
becoming a key feature of our

00:02:40.296 --> 00:02:42.076 A:middle
devices in many, many

00:02:42.076 --> 00:02:42.976 A:middle
applications.

00:02:42.976 --> 00:02:45.056 A:middle
And with Metal 2 you can use

00:02:45.056 --> 00:02:47.786 A:middle
Metal performance shaders to

00:02:47.876 --> 00:02:49.726 A:middle
utilize the power of the GPU for

00:02:49.726 --> 00:02:53.446 A:middle
machine learning on both test up

00:02:53.546 --> 00:02:54.536 A:middle
and mobile devices.

00:02:55.376 --> 00:02:56.786 A:middle
And you're probably staring at

00:02:56.916 --> 00:02:58.256 A:middle
that picture behind me and

00:02:58.256 --> 00:02:59.486 A:middle
thinking, "How's that done?"

00:02:59.776 --> 00:03:01.316 A:middle
Well, we have a session for you

00:03:01.316 --> 00:03:03.776 A:middle
on Thursday where you will learn

00:03:03.776 --> 00:03:05.416 A:middle
about this and about the machine

00:03:05.416 --> 00:03:07.256 A:middle
learning primitives -- the image

00:03:07.256 --> 00:03:08.796 A:middle
processing primitives -- we have

00:03:09.036 --> 00:03:10.966 A:middle
in our Metal performance

00:03:10.966 --> 00:03:11.506 A:middle
shaders.

00:03:13.036 --> 00:03:15.576 A:middle
Lastly, our tools have seen the

00:03:15.576 --> 00:03:17.566 A:middle
biggest advancement yet with

00:03:17.566 --> 00:03:18.146 A:middle
Metal 2.

00:03:18.256 --> 00:03:19.856 A:middle
You'll be able to debug your

00:03:19.856 --> 00:03:21.006 A:middle
applications quicker.

00:03:21.556 --> 00:03:23.266 A:middle
You can drill down to problems

00:03:23.686 --> 00:03:26.796 A:middle
easier and we are exposing, for

00:03:26.796 --> 00:03:28.226 A:middle
example GPU performance

00:03:28.226 --> 00:03:29.866 A:middle
counters, to make sure that you

00:03:29.866 --> 00:03:33.566 A:middle
can find your hotspots and your

00:03:33.566 --> 00:03:36.126 A:middle
application fast pass quicker.

00:03:37.416 --> 00:03:39.786 A:middle
So I hope I got you excited

00:03:40.056 --> 00:03:41.946 A:middle
about the few days ahead and

00:03:41.946 --> 00:03:44.076 A:middle
let's get back to the present

00:03:44.076 --> 00:03:45.336 A:middle
with the content of today's

00:03:45.336 --> 00:03:45.866 A:middle
session.

00:03:51.426 --> 00:03:53.576 A:middle
So we'll start with argument

00:03:53.576 --> 00:03:55.946 A:middle
buffers, probably our biggest

00:03:55.996 --> 00:03:57.686 A:middle
core framework addition this

00:03:57.686 --> 00:03:57.916 A:middle
year.

00:03:58.716 --> 00:04:00.756 A:middle
argument buffers provide an

00:04:00.756 --> 00:04:03.426 A:middle
efficient new way of configuring

00:04:03.426 --> 00:04:05.946 A:middle
which buffers, textures, and

00:04:06.416 --> 00:04:07.986 A:middle
samplers your application can

00:04:07.986 --> 00:04:11.356 A:middle
use freeing up considerable

00:04:11.356 --> 00:04:13.246 A:middle
amount of CPU resources and

00:04:13.246 --> 00:04:15.026 A:middle
actually enabling completely new

00:04:15.026 --> 00:04:16.366 A:middle
schedules for the GPU at the

00:04:16.366 --> 00:04:17.086 A:middle
same time.

00:04:18.196 --> 00:04:20.726 A:middle
Then we'll talk about Raster

00:04:20.726 --> 00:04:22.966 A:middle
Order Groups, a new fragment

00:04:22.966 --> 00:04:24.516 A:middle
shader synchronization primitive

00:04:25.006 --> 00:04:26.856 A:middle
that allows you to precisely

00:04:26.856 --> 00:04:28.566 A:middle
control the order in which

00:04:28.786 --> 00:04:30.426 A:middle
fragment shaders access common

00:04:30.426 --> 00:04:33.026 A:middle
memory, enabling you new use

00:04:33.026 --> 00:04:34.726 A:middle
cases for example of

00:04:35.286 --> 00:04:37.186 A:middle
programmable blending on MacOS

00:04:37.246 --> 00:04:41.466 A:middle
or voxelization [phonetic] order

00:04:41.516 --> 00:04:42.626 A:middle
independent transparency.

00:04:43.466 --> 00:04:44.866 A:middle
And then we'll switch to the

00:04:44.866 --> 00:04:46.656 A:middle
topic of display and we talk

00:04:46.656 --> 00:04:48.396 A:middle
about the new ProMotion Displays

00:04:48.396 --> 00:04:50.496 A:middle
on iPads and how to best drive

00:04:50.496 --> 00:04:51.526 A:middle
them using Metal.

00:04:51.526 --> 00:04:54.396 A:middle
And we'll also give you a recap

00:04:54.446 --> 00:04:57.376 A:middle
of our best practices of getting

00:04:57.376 --> 00:04:58.876 A:middle
your content from your render

00:04:58.876 --> 00:05:02.606 A:middle
targets to the glass as quickly

00:05:02.606 --> 00:05:04.046 A:middle
as possible and with the least

00:05:04.046 --> 00:05:04.996 A:middle
amount of latency.

00:05:05.576 --> 00:05:07.686 A:middle
And finally we'll finish with a

00:05:08.106 --> 00:05:10.036 A:middle
survey of all the other Metal

00:05:10.036 --> 00:05:12.316 A:middle
features that we added to align

00:05:12.566 --> 00:05:15.436 A:middle
iOS and macOS platforms into one

00:05:15.786 --> 00:05:16.976 A:middle
big, common Metal ecosystem.

00:05:22.336 --> 00:05:26.186 A:middle
So the argument buffers.

00:05:26.536 --> 00:05:28.556 A:middle
Let's look at what they are and

00:05:28.716 --> 00:05:29.266 A:middle
how they work.

00:05:29.316 --> 00:05:30.806 A:middle
And I will need an example for

00:05:30.806 --> 00:05:33.776 A:middle
that so let's think of a simple

00:05:33.776 --> 00:05:36.166 A:middle
material that those who actually

00:05:36.166 --> 00:05:39.456 A:middle
wrote any sort of 3D render

00:05:39.456 --> 00:05:40.046 A:middle
program would know.

00:05:40.466 --> 00:05:42.326 A:middle
In your material you have a

00:05:42.326 --> 00:05:44.936 A:middle
bunch of numerical constants, a

00:05:45.106 --> 00:05:46.236 A:middle
bunch of textures -- probably

00:05:46.236 --> 00:05:47.416 A:middle
more than two now a days --

00:05:47.466 --> 00:05:48.016 A:middle
assembler.

00:05:48.686 --> 00:05:53.196 A:middle
And this is what you need to

00:05:53.196 --> 00:05:54.726 A:middle
send to the GPU to be able to

00:05:54.726 --> 00:05:56.056 A:middle
render your primitive.

00:05:56.516 --> 00:05:58.566 A:middle
Now the texture objects are

00:05:59.456 --> 00:06:01.026 A:middle
interesting because they contain

00:06:01.166 --> 00:06:03.506 A:middle
both texture properties such as

00:06:03.506 --> 00:06:06.626 A:middle
width, height, pixel format

00:06:06.626 --> 00:06:08.866 A:middle
perhaps, and then a pointer to a

00:06:08.866 --> 00:06:10.176 A:middle
blob of memory which contains

00:06:10.176 --> 00:06:11.196 A:middle
all the pretty pixels.

00:06:11.196 --> 00:06:13.896 A:middle
Well, unfortunately we are not

00:06:13.896 --> 00:06:14.766 A:middle
really interested in those

00:06:14.766 --> 00:06:15.926 A:middle
pixels in this presentation.

00:06:15.926 --> 00:06:18.636 A:middle
So off it goes and we'll only be

00:06:18.636 --> 00:06:20.426 A:middle
talking about boring texture

00:06:20.426 --> 00:06:20.916 A:middle
states.

00:06:22.156 --> 00:06:24.456 A:middle
So with traditional argument

00:06:24.456 --> 00:06:26.566 A:middle
model we allow you to put all

00:06:26.566 --> 00:06:29.106 A:middle
the constants into a Metal

00:06:29.106 --> 00:06:30.216 A:middle
buffer and we created this

00:06:30.216 --> 00:06:32.126 A:middle
indirection so that it's easy

00:06:32.126 --> 00:06:33.846 A:middle
for you to use and also it gives

00:06:33.846 --> 00:06:36.136 A:middle
GPU the unfiltered, direct

00:06:36.136 --> 00:06:37.926 A:middle
access to all the data.

00:06:39.136 --> 00:06:41.166 A:middle
However, when it comes to things

00:06:41.166 --> 00:06:43.386 A:middle
like textures or samplers you

00:06:43.386 --> 00:06:44.446 A:middle
still need to go through quite

00:06:44.446 --> 00:06:46.266 A:middle
about of an API and in your

00:06:46.266 --> 00:06:47.686 A:middle
rendering loop you'll set the

00:06:47.686 --> 00:06:50.066 A:middle
buffer, set all the textures,

00:06:50.676 --> 00:06:52.146 A:middle
samplers, and only after that

00:06:52.146 --> 00:06:53.396 A:middle
you can finally draw.

00:06:53.446 --> 00:06:55.676 A:middle
And even though Metal is really

00:06:55.676 --> 00:06:57.676 A:middle
optimized this is quite a few

00:06:57.676 --> 00:06:59.336 A:middle
API codes and if you multiply it

00:06:59.336 --> 00:07:00.286 A:middle
with the number of objects you

00:07:00.286 --> 00:07:02.766 A:middle
need to render, every frame, and

00:07:02.766 --> 00:07:04.046 A:middle
the fact that you need to do all

00:07:04.046 --> 00:07:06.156 A:middle
this work every frame, it

00:07:06.156 --> 00:07:09.026 A:middle
actually at some point limits

00:07:09.026 --> 00:07:10.136 A:middle
the amount of objects that you

00:07:10.136 --> 00:07:13.826 A:middle
can put on the screen.

00:07:13.826 --> 00:07:17.126 A:middle
With argument buffers we decided

00:07:17.126 --> 00:07:19.076 A:middle
that we would like to extend

00:07:19.486 --> 00:07:21.476 A:middle
this very convenient indirection

00:07:21.786 --> 00:07:23.026 A:middle
that we have for constants to

00:07:23.026 --> 00:07:23.626 A:middle
everything.

00:07:23.626 --> 00:07:26.046 A:middle
So you can actually put texture

00:07:26.046 --> 00:07:28.226 A:middle
state, samplers, pointers to

00:07:28.226 --> 00:07:29.696 A:middle
another buffer into an argument

00:07:29.696 --> 00:07:31.456 A:middle
buffer and this really

00:07:31.456 --> 00:07:34.036 A:middle
simplifies your rendering

00:07:34.036 --> 00:07:35.656 A:middle
pipeline because -- well,

00:07:35.656 --> 00:07:37.956 A:middle
suddenly the only thing you need

00:07:37.956 --> 00:07:40.386 A:middle
to do is set the buffer and

00:07:41.426 --> 00:07:41.806 A:middle
draw.

00:07:42.016 --> 00:07:43.316 A:middle
And you probably figured out

00:07:43.316 --> 00:07:46.196 A:middle
that with this few API calls you

00:07:46.196 --> 00:07:47.126 A:middle
can put more objects on the

00:07:47.126 --> 00:07:49.996 A:middle
screen, and as you'll see later,

00:07:50.236 --> 00:07:51.726 A:middle
you can do actually even better

00:07:51.726 --> 00:07:54.006 A:middle
with argument buffers.

00:07:54.656 --> 00:07:55.536 A:middle
So we've done a bunch of

00:07:55.536 --> 00:07:58.746 A:middle
benchmarks and run argument

00:07:58.746 --> 00:07:59.976 A:middle
buffers on our devices.

00:08:04.426 --> 00:08:05.886 A:middle
And this is for example what you

00:08:05.886 --> 00:08:07.616 A:middle
get on iPhone 7.

00:08:08.196 --> 00:08:10.196 A:middle
While with traditional model,

00:08:10.526 --> 00:08:13.546 A:middle
quite unsurprisingly, the cost

00:08:13.646 --> 00:08:16.366 A:middle
of your draw call scales, with

00:08:16.366 --> 00:08:17.756 A:middle
the amount of resources you use

00:08:18.246 --> 00:08:22.016 A:middle
in a draw call, with argument

00:08:22.016 --> 00:08:25.096 A:middle
buffers the cost stays pretty

00:08:25.096 --> 00:08:26.736 A:middle
low and almost flat.

00:08:26.736 --> 00:08:29.976 A:middle
So this already shows that for

00:08:29.976 --> 00:08:31.436 A:middle
example with a very simple

00:08:31.436 --> 00:08:33.496 A:middle
shader, with just two resources,

00:08:33.496 --> 00:08:35.956 A:middle
with texture and a buffer, or

00:08:36.126 --> 00:08:37.786 A:middle
two textures, you're getting

00:08:37.786 --> 00:08:39.536 A:middle
seven times the performance

00:08:39.536 --> 00:08:40.136 A:middle
improvement.

00:08:40.136 --> 00:08:42.186 A:middle
With eight textures or eight

00:08:42.186 --> 00:08:45.146 A:middle
resources, however you want to

00:08:45.146 --> 00:08:47.286 A:middle
mix it up, you are getting 18

00:08:47.286 --> 00:08:48.996 A:middle
times performance improvement on

00:08:48.996 --> 00:08:50.966 A:middle
iPhone 7 and it goes even better

00:08:50.966 --> 00:08:52.696 A:middle
with 16 resources, obviously.

00:08:55.106 --> 00:08:58.116 A:middle
So I already talked about the

00:08:58.116 --> 00:08:58.896 A:middle
performance.

00:08:58.986 --> 00:09:01.316 A:middle
I hinted toward a new use -- new

00:09:01.316 --> 00:09:01.906 A:middle
use schedules.

00:09:01.906 --> 00:09:04.486 A:middle
And we'll talk about this in a

00:09:04.486 --> 00:09:04.866 A:middle
minute.

00:09:05.066 --> 00:09:06.456 A:middle
And the last point -- the last

00:09:06.456 --> 00:09:08.166 A:middle
benefit of argument buffers I

00:09:08.166 --> 00:09:09.616 A:middle
would like to bring up is the

00:09:09.616 --> 00:09:10.376 A:middle
ease of use.

00:09:10.976 --> 00:09:13.856 A:middle
And it comes from the fact that

00:09:13.856 --> 00:09:15.546 A:middle
argument buffers are ultimately

00:09:15.716 --> 00:09:16.686 A:middle
an extension of buffers.

00:09:16.686 --> 00:09:17.966 A:middle
So you can, for example go ahead

00:09:17.966 --> 00:09:19.406 A:middle
and prepare them ahead of the

00:09:19.406 --> 00:09:21.116 A:middle
time, let's say when your game

00:09:21.116 --> 00:09:23.426 A:middle
is loading, and then don't have

00:09:23.476 --> 00:09:25.216 A:middle
to worry about it anymore during

00:09:25.216 --> 00:09:26.386 A:middle
your rendering loop, further

00:09:26.556 --> 00:09:27.836 A:middle
improving your performance.

00:09:28.786 --> 00:09:30.356 A:middle
Or you can mix them with a

00:09:30.356 --> 00:09:31.606 A:middle
traditional binding model, for

00:09:31.606 --> 00:09:33.866 A:middle
example even within a single

00:09:34.066 --> 00:09:36.376 A:middle
draw call, which means that your

00:09:36.376 --> 00:09:38.186 A:middle
adoption can be as simple as

00:09:38.366 --> 00:09:39.746 A:middle
using our new tools to figure

00:09:39.746 --> 00:09:40.986 A:middle
out what is your most expensive

00:09:41.256 --> 00:09:43.626 A:middle
loop in our application and

00:09:43.626 --> 00:09:44.946 A:middle
optimizing that and then maybe

00:09:44.946 --> 00:09:46.526 A:middle
return to the rest in a year

00:09:46.526 --> 00:09:49.626 A:middle
when you have time.

00:09:49.746 --> 00:09:52.936 A:middle
And lastly, the argument buffers

00:09:52.936 --> 00:09:55.246 A:middle
are supported across all Metal

00:09:55.246 --> 00:09:55.786 A:middle
devices.

00:09:55.786 --> 00:09:57.986 A:middle
So once you take this adoption

00:09:57.986 --> 00:09:59.356 A:middle
step and you get all the

00:09:59.356 --> 00:10:00.956 A:middle
performance you can keep using

00:10:00.956 --> 00:10:02.556 A:middle
it on all Metal devices.

00:10:02.986 --> 00:10:04.076 A:middle
The ease of use actually

00:10:04.076 --> 00:10:05.796 A:middle
translates really well to the

00:10:05.796 --> 00:10:06.426 A:middle
shaders.

00:10:06.426 --> 00:10:07.836 A:middle
And since we will be looking at

00:10:07.836 --> 00:10:10.666 A:middle
the shaders quite a bit during

00:10:10.666 --> 00:10:12.576 A:middle
this section -- this is an

00:10:12.576 --> 00:10:14.806 A:middle
example of the material I gave

00:10:14.806 --> 00:10:15.676 A:middle
you in the beginning.

00:10:16.666 --> 00:10:19.266 A:middle
And as you can see, the textures

00:10:19.266 --> 00:10:21.596 A:middle
in the sampler are part of the

00:10:21.596 --> 00:10:23.366 A:middle
structure, and that's the main

00:10:23.366 --> 00:10:24.746 A:middle
thing to take away from this is

00:10:25.296 --> 00:10:28.616 A:middle
that your argument buffer is

00:10:28.616 --> 00:10:29.976 A:middle
just a structure in a shader and

00:10:29.976 --> 00:10:31.316 A:middle
you can use all the language

00:10:31.686 --> 00:10:33.066 A:middle
that you have at your disposal

00:10:33.066 --> 00:10:35.266 A:middle
to make embedded structures, to

00:10:35.266 --> 00:10:38.856 A:middle
organize your data, or use erase

00:10:38.856 --> 00:10:39.576 A:middle
or pointers.

00:10:39.766 --> 00:10:40.976 A:middle
It just really works.

00:10:42.216 --> 00:10:44.486 A:middle
So let's now look at the three

00:10:44.766 --> 00:10:46.216 A:middle
main new features of argument

00:10:46.216 --> 00:10:47.586 A:middle
buffers, the first one being

00:10:47.676 --> 00:10:48.946 A:middle
dynamic indexing.

00:10:50.276 --> 00:10:53.346 A:middle
And great example of it is crowd

00:10:53.346 --> 00:10:53.826 A:middle
rendering.

00:10:53.826 --> 00:10:56.056 A:middle
If you played some of the recent

00:10:56.056 --> 00:10:57.436 A:middle
Open World games you've seen

00:10:57.436 --> 00:11:00.686 A:middle
that games try to render large

00:11:00.686 --> 00:11:02.506 A:middle
crowds full of unique, varying

00:11:02.986 --> 00:11:05.036 A:middle
characters in order to make

00:11:05.036 --> 00:11:07.546 A:middle
these beautiful, immersive

00:11:07.606 --> 00:11:08.166 A:middle
worlds.

00:11:08.696 --> 00:11:10.116 A:middle
Well, actually that's quite a

00:11:10.116 --> 00:11:12.246 A:middle
costly thing to do if you need

00:11:12.246 --> 00:11:13.706 A:middle
to create so many draw calls.

00:11:15.076 --> 00:11:16.936 A:middle
With argument buffers we already

00:11:16.936 --> 00:11:19.416 A:middle
said that we could put all the

00:11:19.416 --> 00:11:20.876 A:middle
properties required for let's

00:11:20.876 --> 00:11:22.096 A:middle
say a character into a single

00:11:22.096 --> 00:11:24.006 A:middle
argument buffer, bind it, and

00:11:24.006 --> 00:11:25.566 A:middle
save all that performance on the

00:11:25.566 --> 00:11:27.686 A:middle
CPU, but actually we can do

00:11:27.686 --> 00:11:27.966 A:middle
better.

00:11:27.966 --> 00:11:30.246 A:middle
We can for example create an

00:11:30.416 --> 00:11:32.236 A:middle
array of argument buffers where

00:11:32.546 --> 00:11:35.266 A:middle
each element represents single

00:11:35.266 --> 00:11:35.726 A:middle
character.

00:11:36.306 --> 00:11:37.476 A:middle
And then it suddenly becomes

00:11:37.476 --> 00:11:38.696 A:middle
very, very simple because what

00:11:38.696 --> 00:11:40.856 A:middle
you need to do is set this big

00:11:40.856 --> 00:11:44.016 A:middle
buffer, this one API call, issue

00:11:44.126 --> 00:11:46.046 A:middle
single instance draw call, let's

00:11:46.046 --> 00:11:47.646 A:middle
say with 1,000 instances because

00:11:47.646 --> 00:11:49.126 A:middle
I would like 1,000 characters on

00:11:49.126 --> 00:11:49.496 A:middle
screen.

00:11:50.096 --> 00:11:51.186 A:middle
That's second API call.

00:11:51.256 --> 00:11:53.626 A:middle
And after that it's all on the

00:11:53.626 --> 00:11:54.176 A:middle
GPU.

00:11:54.176 --> 00:11:55.576 A:middle
In a vertex shader you use

00:11:55.576 --> 00:11:57.426 A:middle
instance ID to pick the right

00:11:57.426 --> 00:12:00.926 A:middle
element from the array, get the

00:12:00.926 --> 00:12:02.266 A:middle
character, put it somewhere

00:12:02.266 --> 00:12:03.036 A:middle
where it needs to be in the

00:12:03.036 --> 00:12:04.496 A:middle
world, give it the right pose,

00:12:04.496 --> 00:12:05.646 A:middle
if it's for example mid-walk

00:12:05.646 --> 00:12:07.766 A:middle
cycle, and then in the fragment

00:12:07.766 --> 00:12:10.176 A:middle
shader again you use the

00:12:10.176 --> 00:12:12.146 A:middle
instance ID and pick the right

00:12:12.146 --> 00:12:13.516 A:middle
materials, the right hair color

00:12:13.516 --> 00:12:14.446 A:middle
to finalize the look.

00:12:14.716 --> 00:12:17.056 A:middle
So we are suddenly getting from

00:12:17.576 --> 00:12:19.916 A:middle
tens, hundreds, maybe thousands

00:12:19.916 --> 00:12:22.316 A:middle
of draw calls to a single one.

00:12:22.636 --> 00:12:24.156 A:middle
And it's faster on the CPU.

00:12:24.246 --> 00:12:25.386 A:middle
It's faster on the GPU.

00:12:26.036 --> 00:12:29.466 A:middle
And this is how simple it looks

00:12:29.466 --> 00:12:30.036 A:middle
in a shader.

00:12:31.166 --> 00:12:33.066 A:middle
Pretty much your argument buffer

00:12:33.066 --> 00:12:35.516 A:middle
becomes an array of structures.

00:12:36.966 --> 00:12:40.156 A:middle
You pick the right element using

00:12:40.156 --> 00:12:41.506 A:middle
instance ID referenced within

00:12:41.506 --> 00:12:42.856 A:middle
and you can, for example take

00:12:42.856 --> 00:12:44.526 A:middle
the pointer and pass it to your

00:12:44.526 --> 00:12:46.176 A:middle
helper methods or whatever you

00:12:46.226 --> 00:12:49.176 A:middle
need to do to process data.

00:12:49.256 --> 00:12:51.496 A:middle
The second great feature of

00:12:51.536 --> 00:12:53.206 A:middle
argument buffers is the ability

00:12:53.806 --> 00:12:56.436 A:middle
of the GPU to set resources.

00:12:56.436 --> 00:12:57.656 A:middle
And we actually created an

00:12:57.656 --> 00:12:58.546 A:middle
example for this.

00:12:59.486 --> 00:13:01.586 A:middle
We created a particle simulation

00:13:01.586 --> 00:13:03.876 A:middle
running completely on the GPU.

00:13:04.466 --> 00:13:06.036 A:middle
And I'll tell you how we done

00:13:06.036 --> 00:13:08.216 A:middle
that and we'll see the -- we'll

00:13:08.216 --> 00:13:09.506 A:middle
see it in action later.

00:13:10.256 --> 00:13:11.836 A:middle
So we created an array of

00:13:12.086 --> 00:13:13.316 A:middle
argument buffers where each

00:13:13.366 --> 00:13:16.296 A:middle
element is single particle --

00:13:16.296 --> 00:13:17.756 A:middle
and I guess you already spotted

00:13:17.756 --> 00:13:19.196 A:middle
a trend here.

00:13:19.766 --> 00:13:23.716 A:middle
Our simulation kernel then

00:13:24.596 --> 00:13:26.696 A:middle
treats and simulates one

00:13:26.696 --> 00:13:28.796 A:middle
particle per thread, but we want

00:13:28.796 --> 00:13:29.966 A:middle
to actually go further and we

00:13:29.966 --> 00:13:32.906 A:middle
want it to be able to create the

00:13:32.906 --> 00:13:36.416 A:middle
particles in the kernel as well,

00:13:36.416 --> 00:13:37.006 A:middle
on the GPU.

00:13:37.006 --> 00:13:39.106 A:middle
So in order to do that, and to

00:13:39.106 --> 00:13:41.316 A:middle
give it the right materials, we

00:13:41.316 --> 00:13:43.016 A:middle
also have argument buffer with

00:13:43.076 --> 00:13:44.686 A:middle
all the different materials that

00:13:44.686 --> 00:13:45.806 A:middle
we would like our particles to

00:13:45.806 --> 00:13:46.176 A:middle
have.

00:13:46.906 --> 00:13:48.896 A:middle
And our simulation kernel then,

00:13:49.386 --> 00:13:50.866 A:middle
every time you do an action in

00:13:51.186 --> 00:13:53.826 A:middle
our little demo, the simulation

00:13:53.826 --> 00:13:54.776 A:middle
kernel looks into the

00:13:54.776 --> 00:13:57.066 A:middle
environment and sees what's the

00:13:57.806 --> 00:13:59.446 A:middle
correct, most appropriate

00:13:59.446 --> 00:13:59.906 A:middle
material.

00:14:00.056 --> 00:14:01.596 A:middle
And let's say if you are in the

00:14:01.596 --> 00:14:04.126 A:middle
forest, we pick moss as the

00:14:04.286 --> 00:14:05.786 A:middle
right, appropriate material for

00:14:05.786 --> 00:14:08.696 A:middle
a rock and copy it to the

00:14:09.126 --> 00:14:10.126 A:middle
particle itself.

00:14:11.366 --> 00:14:13.226 A:middle
If you're on the rocks we pick

00:14:13.226 --> 00:14:14.106 A:middle
the rock material.

00:14:14.106 --> 00:14:15.946 A:middle
On the hill we pick grass.

00:14:16.826 --> 00:14:18.506 A:middle
So this way everything stays on

00:14:18.506 --> 00:14:22.796 A:middle
the GPU and it actually looks in

00:14:22.796 --> 00:14:24.206 A:middle
the shader just as simple as I

00:14:24.206 --> 00:14:24.946 A:middle
describe it.

00:14:25.336 --> 00:14:26.756 A:middle
If you want to modify data on

00:14:26.756 --> 00:14:30.156 A:middle
your GPU you bind it as a device

00:14:30.156 --> 00:14:31.486 A:middle
buffer and start assigning

00:14:31.486 --> 00:14:33.866 A:middle
values as you are used to, but

00:14:33.866 --> 00:14:34.986 A:middle
also this time around you can

00:14:34.986 --> 00:14:37.146 A:middle
copy textures or copy the whole

00:14:37.146 --> 00:14:38.676 A:middle
structure and it's really this

00:14:38.676 --> 00:14:38.966 A:middle
simple.

00:14:40.106 --> 00:14:42.346 A:middle
And the last great feature I

00:14:42.346 --> 00:14:44.576 A:middle
would like to mention is ability

00:14:44.576 --> 00:14:47.116 A:middle
of argument buffers to reference

00:14:47.116 --> 00:14:48.116 A:middle
another argument buffer.

00:14:48.116 --> 00:14:50.106 A:middle
So this way you can actually go

00:14:50.106 --> 00:14:52.936 A:middle
ahead and create a reusable and

00:14:53.026 --> 00:14:55.816 A:middle
complex object hierarchy just as

00:14:55.816 --> 00:14:59.076 A:middle
you are used to from C++ Swift,

00:14:59.296 --> 00:15:00.046 A:middle
Objective-C.

00:15:00.566 --> 00:15:03.676 A:middle
Let's say in the example of our

00:15:04.376 --> 00:15:06.496 A:middle
renderer, if you have a ton of

00:15:06.536 --> 00:15:09.076 A:middle
objects, but you probably have

00:15:09.726 --> 00:15:11.046 A:middle
very few materials, so what you

00:15:11.046 --> 00:15:14.556 A:middle
can do is reference the material

00:15:14.556 --> 00:15:15.866 A:middle
from each object and save some

00:15:15.866 --> 00:15:18.336 A:middle
memory or you can build your

00:15:18.336 --> 00:15:19.716 A:middle
scene graph as a binary tree

00:15:19.716 --> 00:15:21.566 A:middle
where actually you point to the

00:15:21.566 --> 00:15:25.186 A:middle
objects and the tree nodes as

00:15:25.186 --> 00:15:26.436 A:middle
you need them, as you would be

00:15:26.436 --> 00:15:27.526 A:middle
used to from the CPU.

00:15:27.906 --> 00:15:29.396 A:middle
And you can share this data with

00:15:29.396 --> 00:15:30.086 A:middle
the CPU as well.

00:15:31.536 --> 00:15:32.846 A:middle
So these are the main features.

00:15:32.846 --> 00:15:34.526 A:middle
And let's look at the support

00:15:34.526 --> 00:15:35.026 A:middle
matrix.

00:15:35.596 --> 00:15:37.036 A:middle
We have two tiers.

00:15:37.266 --> 00:15:39.796 A:middle
The tier one is supported across

00:15:39.796 --> 00:15:42.466 A:middle
all Metal devices and you get

00:15:42.466 --> 00:15:43.386 A:middle
the CPU performance

00:15:43.386 --> 00:15:43.926 A:middle
improvements.

00:15:43.926 --> 00:15:44.866 A:middle
You get the new schedule

00:15:44.866 --> 00:15:45.276 A:middle
language.

00:15:45.766 --> 00:15:49.096 A:middle
But because of the limitations

00:15:49.096 --> 00:15:52.296 A:middle
of the GPUs this tier does not

00:15:52.896 --> 00:15:54.526 A:middle
-- is not able to utilize the

00:15:55.016 --> 00:15:56.486 A:middle
GPU driven use cases that I

00:15:56.486 --> 00:15:57.346 A:middle
mentioned earlier.

00:15:57.776 --> 00:15:58.916 A:middle
With tier two however you are

00:15:58.916 --> 00:16:00.586 A:middle
getting all of this -- so you

00:16:00.586 --> 00:16:02.396 A:middle
get all the new use cases -- and

00:16:02.396 --> 00:16:04.126 A:middle
we are also really increasing

00:16:04.126 --> 00:16:05.736 A:middle
the amount of resources you can

00:16:05.736 --> 00:16:06.176 A:middle
access.

00:16:06.176 --> 00:16:07.416 A:middle
Your shaders can access half a

00:16:07.466 --> 00:16:10.406 A:middle
million textures and buffers to

00:16:10.406 --> 00:16:11.676 A:middle
-- for you to do this -- do

00:16:11.676 --> 00:16:12.806 A:middle
these new algorithms.

00:16:13.696 --> 00:16:15.696 A:middle
While tier one is supported on

00:16:15.986 --> 00:16:18.526 A:middle
all Metal devices, tier two is

00:16:18.526 --> 00:16:19.826 A:middle
something you need to query for.

00:16:20.306 --> 00:16:22.216 A:middle
But don't worry, the support is

00:16:22.216 --> 00:16:22.846 A:middle
really wide.

00:16:23.556 --> 00:16:25.016 A:middle
All the Macs with these three

00:16:25.016 --> 00:16:26.166 A:middle
GPUs are tier two.

00:16:26.626 --> 00:16:28.436 A:middle
All the new MacBook Pros, the

00:16:28.436 --> 00:16:29.676 A:middle
latest MacBook, the last tier

00:16:29.676 --> 00:16:31.586 A:middle
MacBooks Pros are tier two.

00:16:31.586 --> 00:16:33.316 A:middle
So you can go ahead and have

00:16:33.416 --> 00:16:33.586 A:middle
fun.

00:16:34.106 --> 00:16:35.546 A:middle
Now let's look at the demo I

00:16:35.546 --> 00:16:36.136 A:middle
promised you.

00:16:36.226 --> 00:16:39.116 A:middle
We will be showing three videos

00:16:39.426 --> 00:16:41.416 A:middle
with three different features.

00:16:41.986 --> 00:16:43.936 A:middle
The real time rendered terrain,

00:16:44.136 --> 00:16:45.846 A:middle
with material that changes

00:16:45.846 --> 00:16:48.346 A:middle
dynamically, we place some

00:16:48.346 --> 00:16:50.616 A:middle
vegetation by the GPU on the

00:16:50.616 --> 00:16:51.716 A:middle
terrain to make it interesting,

00:16:52.116 --> 00:16:53.326 A:middle
and we have all these nice

00:16:53.326 --> 00:16:56.076 A:middle
particles that I mentioned

00:16:56.076 --> 00:16:56.436 A:middle
before.

00:16:56.656 --> 00:16:59.516 A:middle
So, as you see, we are painting

00:17:00.006 --> 00:17:01.246 A:middle
high on the terrain.

00:17:01.246 --> 00:17:02.496 A:middle
We can changing sculpting the

00:17:02.496 --> 00:17:03.466 A:middle
terrain and the material

00:17:03.466 --> 00:17:04.326 A:middle
actually follows.

00:17:04.626 --> 00:17:05.796 A:middle
And this is a great thing about

00:17:05.796 --> 00:17:08.426 A:middle
argument buffers because they

00:17:08.426 --> 00:17:10.966 A:middle
allowed us to create a one big

00:17:11.666 --> 00:17:13.506 A:middle
argument buffer with all the

00:17:13.506 --> 00:17:16.406 A:middle
possible materials as layers in

00:17:16.406 --> 00:17:18.456 A:middle
there and when we are rendering

00:17:18.456 --> 00:17:20.576 A:middle
the terrain in a pixel shader we

00:17:20.576 --> 00:17:21.736 A:middle
are looking at things like

00:17:22.076 --> 00:17:24.846 A:middle
terrain height, slope, the

00:17:25.116 --> 00:17:27.406 A:middle
amount of sun that reaches

00:17:27.606 --> 00:17:29.166 A:middle
certain pixels, and based on

00:17:29.166 --> 00:17:30.976 A:middle
these properties and some others

00:17:30.976 --> 00:17:33.866 A:middle
we do decide what are the best

00:17:34.026 --> 00:17:35.446 A:middle
and most appropriate materials

00:17:35.446 --> 00:17:36.466 A:middle
for that given pixel.

00:17:36.896 --> 00:17:38.046 A:middle
And this is all happening in

00:17:38.046 --> 00:17:40.746 A:middle
real time, whereas previously we

00:17:40.746 --> 00:17:42.436 A:middle
would have to go ahead and split

00:17:42.436 --> 00:17:44.316 A:middle
the terrain in small pieces

00:17:44.766 --> 00:17:47.466 A:middle
offline, analyze which pieces

00:17:47.466 --> 00:17:49.206 A:middle
need which textures in order to

00:17:49.206 --> 00:17:50.676 A:middle
make it as optimal as possible,

00:17:51.236 --> 00:17:53.166 A:middle
and only then render it.

00:17:53.166 --> 00:17:55.386 A:middle
So we are going from a

00:17:55.456 --> 00:17:56.546 A:middle
pre-processing step, which is

00:17:56.546 --> 00:17:58.366 A:middle
heavy and prevents real time

00:17:58.366 --> 00:18:00.496 A:middle
modification, to something that

00:18:00.496 --> 00:18:02.226 A:middle
is real time, without -- sorry

00:18:02.286 --> 00:18:04.716 A:middle
-- without preprocessing and

00:18:04.716 --> 00:18:05.626 A:middle
completely dynamic.

00:18:08.976 --> 00:18:11.986 A:middle
And we added vegetation on it

00:18:12.296 --> 00:18:14.086 A:middle
and as you see the vegetation is

00:18:14.086 --> 00:18:16.196 A:middle
also context sensitive.

00:18:17.026 --> 00:18:18.766 A:middle
You see the palm trees on the

00:18:18.766 --> 00:18:19.136 A:middle
sand.

00:18:19.136 --> 00:18:20.826 A:middle
You see the little tiny apple

00:18:20.826 --> 00:18:21.816 A:middle
trees on the hills.

00:18:23.446 --> 00:18:25.536 A:middle
And while the vegetation itself

00:18:25.536 --> 00:18:28.176 A:middle
is fairly traditional instance

00:18:28.176 --> 00:18:29.776 A:middle
rendering, the power of the

00:18:29.776 --> 00:18:32.396 A:middle
argument buffers here is that it

00:18:32.396 --> 00:18:34.086 A:middle
allows us to share the same

00:18:34.416 --> 00:18:36.006 A:middle
terrain material with all the

00:18:36.006 --> 00:18:37.846 A:middle
same properties and the same

00:18:37.846 --> 00:18:39.646 A:middle
terrain analysis function

00:18:40.126 --> 00:18:41.486 A:middle
between two completely separate

00:18:41.486 --> 00:18:43.446 A:middle
pieces of code.

00:18:43.676 --> 00:18:45.246 A:middle
While terrain rendering uses all

00:18:45.246 --> 00:18:47.326 A:middle
this data to render pixels, the

00:18:47.326 --> 00:18:48.796 A:middle
computer that places the

00:18:48.796 --> 00:18:50.316 A:middle
geometry, the vegetation,

00:18:50.686 --> 00:18:51.956 A:middle
actually analyzes the same

00:18:51.956 --> 00:18:53.786 A:middle
materials to figure out what is

00:18:53.786 --> 00:18:56.266 A:middle
the best type of tree to place

00:18:56.266 --> 00:18:57.026 A:middle
in the given spot.

00:18:57.486 --> 00:18:58.616 A:middle
And this is very easy because

00:18:58.616 --> 00:18:59.836 A:middle
every time we make a change

00:19:00.166 --> 00:19:01.566 A:middle
nothing actually changes in our

00:19:01.566 --> 00:19:02.686 A:middle
code because we just add new

00:19:02.686 --> 00:19:04.516 A:middle
layers or change our analysis

00:19:04.516 --> 00:19:06.806 A:middle
function, whereas previously we

00:19:06.806 --> 00:19:08.526 A:middle
would have to maybe juggle 70

00:19:08.526 --> 00:19:10.226 A:middle
textures between two completely

00:19:10.226 --> 00:19:11.776 A:middle
separate code basis in order to

00:19:11.816 --> 00:19:17.036 A:middle
make them run in sync.

00:19:17.216 --> 00:19:19.406 A:middle
Lastly, we have the particles.

00:19:19.406 --> 00:19:22.226 A:middle
I hope you can see that they

00:19:22.226 --> 00:19:25.146 A:middle
nicely get the material of the

00:19:25.146 --> 00:19:25.916 A:middle
terrain there.

00:19:26.876 --> 00:19:28.606 A:middle
Now what I did not mention is

00:19:28.606 --> 00:19:30.866 A:middle
that this all is rendered with

00:19:31.126 --> 00:19:32.816 A:middle
again a single draw call.

00:19:32.816 --> 00:19:34.756 A:middle
We are rendering 16,000

00:19:35.086 --> 00:19:38.006 A:middle
particles here with single draw

00:19:38.006 --> 00:19:39.776 A:middle
call, with absolutely no

00:19:39.816 --> 00:19:41.586 A:middle
involvement on the CPU.

00:19:42.406 --> 00:19:44.486 A:middle
And not only do particles have

00:19:44.826 --> 00:19:46.316 A:middle
unique materials, they actually

00:19:46.316 --> 00:19:47.486 A:middle
have unique shapes because

00:19:47.766 --> 00:19:48.876 A:middle
argument buffers allow --

00:19:48.936 --> 00:19:50.176 A:middle
actually allow you to change

00:19:50.176 --> 00:19:52.166 A:middle
your vertex buffer per draw

00:19:52.166 --> 00:19:52.466 A:middle
call.

00:19:53.526 --> 00:19:56.076 A:middle
This is something where if you

00:19:56.076 --> 00:19:58.466 A:middle
try to do that without argument

00:19:58.466 --> 00:20:01.956 A:middle
buffers, we had to create a

00:20:01.956 --> 00:20:04.496 A:middle
complicated control hand over

00:20:04.496 --> 00:20:06.856 A:middle
between GPU that simulates and

00:20:06.856 --> 00:20:08.036 A:middle
the CPU that tries to come up

00:20:08.036 --> 00:20:09.866 A:middle
with the best set of draw calls

00:20:09.866 --> 00:20:11.356 A:middle
to represent all this variety.

00:20:11.776 --> 00:20:13.396 A:middle
So with argument buffers this

00:20:13.396 --> 00:20:17.116 A:middle
became just very, very simple.

00:20:18.346 --> 00:20:21.706 A:middle
Okay, so enough pretty pictures.

00:20:22.296 --> 00:20:25.226 A:middle
And let's wrap my portion of the

00:20:25.226 --> 00:20:28.406 A:middle
session with a look at some APIs

00:20:28.406 --> 00:20:29.716 A:middle
and some best practices.

00:20:29.986 --> 00:20:33.426 A:middle
As I mentioned before, argument

00:20:33.426 --> 00:20:34.926 A:middle
buffers are an extension of

00:20:34.926 --> 00:20:37.426 A:middle
Metal buffers and that means all

00:20:37.426 --> 00:20:39.286 A:middle
of our API related to buffers

00:20:39.286 --> 00:20:39.776 A:middle
just works.

00:20:39.776 --> 00:20:40.946 A:middle
You can go ahead and take

00:20:40.946 --> 00:20:42.196 A:middle
argument buffer, copy it

00:20:42.196 --> 00:20:43.456 A:middle
somewhere else; you can blitz it

00:20:43.456 --> 00:20:44.976 A:middle
between CPU and GPU.

00:20:45.826 --> 00:20:48.106 A:middle
And while argument buffers look

00:20:48.106 --> 00:20:51.266 A:middle
like structures on the GPU for

00:20:51.266 --> 00:20:54.796 A:middle
shaders, on the CPU you will use

00:20:54.796 --> 00:20:56.816 A:middle
MTLArgumentEncoder objects to

00:20:56.816 --> 00:20:57.716 A:middle
fill up the content.

00:20:58.676 --> 00:21:02.196 A:middle
This abstraction allows Metal to

00:21:02.196 --> 00:21:04.696 A:middle
create the most optimal memory

00:21:05.186 --> 00:21:06.686 A:middle
representation for any given

00:21:06.686 --> 00:21:08.316 A:middle
argument buffer on that specific

00:21:08.316 --> 00:21:09.376 A:middle
GPU that you are actually

00:21:09.376 --> 00:21:09.716 A:middle
running.

00:21:10.206 --> 00:21:11.506 A:middle
So you get the best performance.

00:21:11.896 --> 00:21:13.266 A:middle
It also frees you, as the

00:21:13.266 --> 00:21:14.686 A:middle
developer, from all these

00:21:15.646 --> 00:21:19.956 A:middle
details and worries about, for

00:21:19.956 --> 00:21:21.956 A:middle
example how each GPU represents

00:21:22.096 --> 00:21:22.966 A:middle
what the texture is.

00:21:22.966 --> 00:21:23.986 A:middle
Where does it live in memory?

00:21:24.616 --> 00:21:26.746 A:middle
All of this changes from

00:21:26.886 --> 00:21:28.776 A:middle
platform to platform and we hide

00:21:28.776 --> 00:21:31.356 A:middle
it between a simple interface so

00:21:31.356 --> 00:21:32.616 A:middle
that you can write very simple

00:21:32.616 --> 00:21:33.826 A:middle
and effective applications.

00:21:34.506 --> 00:21:37.106 A:middle
So I hope you're not worried

00:21:37.106 --> 00:21:38.006 A:middle
about the encoder that I

00:21:38.006 --> 00:21:38.376 A:middle
mentioned.

00:21:38.376 --> 00:21:39.886 A:middle
It's really, really simple to

00:21:39.886 --> 00:21:40.286 A:middle
use.

00:21:41.346 --> 00:21:42.396 A:middle
For example, if you want to

00:21:42.396 --> 00:21:43.856 A:middle
create an argument encoder for

00:21:43.856 --> 00:21:46.386 A:middle
this argument buffer all you

00:21:46.386 --> 00:21:49.886 A:middle
need to do is get your Metal

00:21:49.886 --> 00:21:51.386 A:middle
function that uses the argument

00:21:51.386 --> 00:21:53.736 A:middle
buffer and ask the Metal

00:21:53.736 --> 00:21:55.386 A:middle
function for the encoder and

00:21:55.386 --> 00:21:56.116 A:middle
that's about this.

00:21:56.116 --> 00:21:57.386 A:middle
This is all you needed to do.

00:21:57.386 --> 00:21:59.526 A:middle
You get an object and you start

00:21:59.526 --> 00:22:02.066 A:middle
using a familiar set texture or

00:22:02.486 --> 00:22:04.586 A:middle
filling constant API that is

00:22:04.586 --> 00:22:05.906 A:middle
very, very similar to how you've

00:22:05.906 --> 00:22:08.666 A:middle
been using Metal with command

00:22:08.666 --> 00:22:09.016 A:middle
encoder.

00:22:09.016 --> 00:22:11.916 A:middle
So this also plays into what I

00:22:11.916 --> 00:22:15.116 A:middle
said about ease of use and

00:22:15.116 --> 00:22:15.846 A:middle
transition.

00:22:16.866 --> 00:22:18.736 A:middle
There are multiple other ways of

00:22:18.736 --> 00:22:20.546 A:middle
creating the encoder.

00:22:20.546 --> 00:22:21.786 A:middle
You can go more explicit with

00:22:21.786 --> 00:22:22.686 A:middle
the descriptor, but that's

00:22:22.686 --> 00:22:24.706 A:middle
something you should look into

00:22:24.876 --> 00:22:26.036 A:middle
in documentation if you need

00:22:26.036 --> 00:22:27.326 A:middle
such thing.

00:22:27.326 --> 00:22:28.956 A:middle
We advise you to actually go and

00:22:29.566 --> 00:22:30.866 A:middle
get argument encoders from the

00:22:30.866 --> 00:22:31.386 A:middle
shaders.

00:22:33.846 --> 00:22:36.706 A:middle
Now with all those interactions,

00:22:36.706 --> 00:22:38.396 A:middle
GPU being able to step in and

00:22:38.396 --> 00:22:40.436 A:middle
modify the argument buffers or

00:22:41.036 --> 00:22:42.286 A:middle
you know dynamic indexing and

00:22:42.286 --> 00:22:44.356 A:middle
half a million textures, all

00:22:44.356 --> 00:22:47.526 A:middle
that in a mix, it's not really

00:22:47.906 --> 00:22:49.366 A:middle
possible for Metal to figure out

00:22:49.366 --> 00:22:50.466 A:middle
what -- for example what

00:22:50.466 --> 00:22:52.226 A:middle
textures or buffers do actually

00:22:52.226 --> 00:22:55.396 A:middle
intend to use in your rendering,

00:22:55.396 --> 00:22:57.006 A:middle
but luckily you as a developer

00:22:57.006 --> 00:22:58.916 A:middle
have pretty good idea about

00:22:58.916 --> 00:22:59.126 A:middle
that.

00:22:59.126 --> 00:23:01.276 A:middle
So we ask you with argument

00:23:01.276 --> 00:23:02.716 A:middle
buffers to be quite explicit

00:23:02.716 --> 00:23:03.066 A:middle
about it.

00:23:04.266 --> 00:23:05.776 A:middle
If you are using Heaps, and

00:23:06.646 --> 00:23:08.336 A:middle
absolutely you should use Heaps

00:23:08.336 --> 00:23:09.896 A:middle
to get the best performance out

00:23:09.896 --> 00:23:12.506 A:middle
of your platform and the best

00:23:12.506 --> 00:23:13.766 A:middle
way of organizing your data, the

00:23:14.366 --> 00:23:15.586 A:middle
only thing you need to do is

00:23:15.586 --> 00:23:16.936 A:middle
tell Metal that you intend to

00:23:16.936 --> 00:23:18.886 A:middle
use a Heap , or multiple Heaps,

00:23:18.886 --> 00:23:19.816 A:middle
it's up to you.

00:23:19.816 --> 00:23:22.356 A:middle
And -- this is -- this makes

00:23:22.356 --> 00:23:24.196 A:middle
sure that the textures are

00:23:24.196 --> 00:23:25.546 A:middle
available for you in the

00:23:25.546 --> 00:23:27.696 A:middle
rendering loop.

00:23:27.696 --> 00:23:29.066 A:middle
If you want to do something more

00:23:29.066 --> 00:23:30.076 A:middle
specific, let's say you would

00:23:30.076 --> 00:23:32.586 A:middle
like to write to a render target

00:23:32.586 --> 00:23:34.556 A:middle
from inside a shader, or you

00:23:34.556 --> 00:23:35.626 A:middle
would like to read from a dev

00:23:35.626 --> 00:23:38.466 A:middle
buffer, you use a more specific

00:23:38.466 --> 00:23:40.466 A:middle
API and tell Metal that you

00:23:40.466 --> 00:23:42.476 A:middle
intend to change resource and --

00:23:43.476 --> 00:23:44.516 A:middle
with a specific way.

00:23:44.516 --> 00:23:46.076 A:middle
And again, it's as simple as

00:23:46.076 --> 00:23:46.166 A:middle
this.

00:23:46.166 --> 00:23:46.836 A:middle
You don't need to do anything

00:23:46.836 --> 00:23:46.976 A:middle
else.

00:23:50.506 --> 00:23:52.196 A:middle
So let's start out with a couple

00:23:52.196 --> 00:23:53.116 A:middle
of best practices.

00:23:53.116 --> 00:23:55.986 A:middle
I think if you know Metal they

00:23:55.986 --> 00:23:58.076 A:middle
are very, very similar to what

00:23:58.076 --> 00:24:00.076 A:middle
we are telling you about using

00:24:00.076 --> 00:24:00.716 A:middle
Metal buffers.

00:24:01.156 --> 00:24:02.586 A:middle
The best way to organize your

00:24:02.586 --> 00:24:04.706 A:middle
data is by usage pattern.

00:24:04.706 --> 00:24:05.856 A:middle
And you probably have a ton of

00:24:05.856 --> 00:24:08.406 A:middle
properties that do not change

00:24:08.686 --> 00:24:09.306 A:middle
per frame.

00:24:09.396 --> 00:24:10.536 A:middle
So put them into an argument

00:24:10.536 --> 00:24:11.956 A:middle
buffer and share it with all the

00:24:11.956 --> 00:24:13.166 A:middle
objects so you will save memory

00:24:13.166 --> 00:24:13.536 A:middle
this way.

00:24:14.286 --> 00:24:16.076 A:middle
The same -- on the same -- on

00:24:16.076 --> 00:24:17.756 A:middle
the other hand you will probably

00:24:17.756 --> 00:24:19.566 A:middle
have a lot of properties that

00:24:19.566 --> 00:24:21.106 A:middle
actually do change for every

00:24:21.106 --> 00:24:23.496 A:middle
object and you need to manage

00:24:23.496 --> 00:24:24.346 A:middle
them every frame.

00:24:24.346 --> 00:24:26.946 A:middle
And for these I think the best

00:24:26.946 --> 00:24:28.066 A:middle
way is to put those into

00:24:28.066 --> 00:24:29.226 A:middle
separate argument buffers so

00:24:29.226 --> 00:24:30.396 A:middle
that you can double buffer it or

00:24:30.396 --> 00:24:32.056 A:middle
whatever is your management

00:24:32.056 --> 00:24:34.786 A:middle
scheme and you don't need to do

00:24:34.786 --> 00:24:36.576 A:middle
all the other copies to keep all

00:24:36.576 --> 00:24:37.266 A:middle
the data in there.

00:24:37.706 --> 00:24:39.186 A:middle
And then you will likely have a

00:24:39.186 --> 00:24:41.326 A:middle
ton of argument buffers that

00:24:41.786 --> 00:24:43.286 A:middle
just don't change at all.

00:24:43.286 --> 00:24:44.456 A:middle
Let's say the materials, or

00:24:45.026 --> 00:24:46.816 A:middle
maybe some other properties, and

00:24:46.966 --> 00:24:49.296 A:middle
for these just create them at

00:24:49.296 --> 00:24:50.296 A:middle
the initialization of your

00:24:50.296 --> 00:24:53.826 A:middle
application and keep using them.

00:24:54.026 --> 00:24:57.576 A:middle
Similar to Metal buffers, think

00:24:57.576 --> 00:24:59.816 A:middle
about your data locality and how

00:24:59.816 --> 00:25:01.566 A:middle
you actually use your argument

00:25:01.566 --> 00:25:01.916 A:middle
buffers.

00:25:02.246 --> 00:25:03.816 A:middle
If, for example you have three

00:25:03.816 --> 00:25:06.076 A:middle
textures that are accessed in a

00:25:06.076 --> 00:25:08.776 A:middle
shader, one after another, then

00:25:09.316 --> 00:25:10.836 A:middle
the best thing you can do is

00:25:10.836 --> 00:25:12.046 A:middle
actually put those textures

00:25:12.046 --> 00:25:13.216 A:middle
close to each other in argument

00:25:13.216 --> 00:25:14.566 A:middle
buffers so that you maximize the

00:25:14.566 --> 00:25:16.466 A:middle
use of GPU caches.

00:25:17.376 --> 00:25:18.146 A:middle
And as I mentioned at the

00:25:18.146 --> 00:25:20.736 A:middle
beginning, traditional argument

00:25:20.736 --> 00:25:23.716 A:middle
model is not going anywhere and

00:25:23.716 --> 00:25:25.576 A:middle
you should take advantage of it

00:25:25.576 --> 00:25:26.776 A:middle
and mix it with the argument

00:25:26.776 --> 00:25:28.116 A:middle
buffers whenever it's more

00:25:28.116 --> 00:25:28.786 A:middle
convenient.

00:25:29.296 --> 00:25:30.626 A:middle
So let's say if you need to

00:25:30.626 --> 00:25:32.256 A:middle
change a single texture for

00:25:33.376 --> 00:25:35.786 A:middle
every object, for example a cube

00:25:35.786 --> 00:25:37.606 A:middle
reflection, it probably would be

00:25:37.606 --> 00:25:38.786 A:middle
an overhead to create argument

00:25:38.786 --> 00:25:40.096 A:middle
buffer just for that and upload

00:25:40.096 --> 00:25:40.896 A:middle
it every frame.

00:25:40.896 --> 00:25:42.826 A:middle
So just use the traditional

00:25:42.826 --> 00:25:43.526 A:middle
model for this.

00:25:43.656 --> 00:25:46.216 A:middle
That's it about argument

00:25:46.216 --> 00:25:46.576 A:middle
buffers.

00:25:46.576 --> 00:25:50.256 A:middle
I really hope you will adopt our

00:25:50.256 --> 00:25:52.516 A:middle
new API and get some creative

00:25:52.806 --> 00:25:53.596 A:middle
use cases out of it.

00:25:54.136 --> 00:25:57.456 A:middle
And please welcome Richard, who

00:25:57.546 --> 00:25:59.156 A:middle
will talk about the Raster Order

00:25:59.156 --> 00:25:59.506 A:middle
Groups.

00:26:00.556 --> 00:26:02.556 A:middle
[ Applause ]

00:26:02.596 --> 00:26:03.016 A:middle
&gt;&gt; Thank you.

00:26:05.046 --> 00:26:06.686 A:middle
Hello. So thank you Michal.

00:26:06.826 --> 00:26:07.776 A:middle
So I'm going to take you through

00:26:07.776 --> 00:26:08.436 A:middle
the rest of the day's

00:26:08.436 --> 00:26:10.006 A:middle
presentation, starting with

00:26:10.046 --> 00:26:10.936 A:middle
Raster Order Groups.

00:26:12.476 --> 00:26:14.196 A:middle
So this is a new feature that

00:26:14.196 --> 00:26:16.636 A:middle
gives you control over the GPU's

00:26:16.726 --> 00:26:17.866 A:middle
thread scheduling to run

00:26:18.196 --> 00:26:19.686 A:middle
fragment shooter threads, in

00:26:19.746 --> 00:26:20.086 A:middle
order.

00:26:20.686 --> 00:26:22.096 A:middle
This allows overlapping fragment

00:26:22.096 --> 00:26:23.266 A:middle
shooter threads to communicate

00:26:23.266 --> 00:26:24.876 A:middle
through memory, where before it

00:26:24.876 --> 00:26:27.366 A:middle
wasn't always really possible to

00:26:27.366 --> 00:26:28.286 A:middle
do in most cases.

00:26:28.646 --> 00:26:30.246 A:middle
So this opens up a whole new set

00:26:30.246 --> 00:26:31.266 A:middle
of graphics algorithms that were

00:26:31.266 --> 00:26:32.956 A:middle
not practically achievable with

00:26:33.156 --> 00:26:34.206 A:middle
just write only access to your

00:26:34.206 --> 00:26:36.196 A:middle
frame buffers or onward access

00:26:36.196 --> 00:26:37.216 A:middle
memory to device memory.

00:26:38.476 --> 00:26:40.986 A:middle
For example, one of our key --

00:26:40.986 --> 00:26:42.226 A:middle
one of the key applications for

00:26:42.306 --> 00:26:43.156 A:middle
this is Order-independent

00:26:43.156 --> 00:26:43.926 A:middle
transparency.

00:26:44.746 --> 00:26:46.106 A:middle
We've been -- already talked a

00:26:46.106 --> 00:26:47.476 A:middle
lot today about how to reduce

00:26:47.476 --> 00:26:48.596 A:middle
the CP usage of your Metal

00:26:48.596 --> 00:26:50.356 A:middle
application and this feature

00:26:50.356 --> 00:26:52.006 A:middle
lets you build or an algorithm

00:26:52.476 --> 00:26:54.456 A:middle
to include blending back to

00:26:54.456 --> 00:26:56.116 A:middle
front without having to pay the

00:26:56.116 --> 00:26:57.526 A:middle
CPU cost of triangle level

00:26:57.526 --> 00:26:57.896 A:middle
sorting.

00:26:59.536 --> 00:27:00.736 A:middle
There's also been lots of

00:27:00.736 --> 00:27:01.836 A:middle
investigations into advanced

00:27:01.836 --> 00:27:03.176 A:middle
techniques such as dual layer

00:27:03.396 --> 00:27:04.236 A:middle
G-buffers, which can

00:27:04.236 --> 00:27:05.946 A:middle
substantially improve post

00:27:05.946 --> 00:27:07.596 A:middle
processing results, or using the

00:27:07.596 --> 00:27:08.846 A:middle
GPU rasterizer to sort of

00:27:08.846 --> 00:27:10.196 A:middle
voxelize triangle meshes.

00:27:11.056 --> 00:27:12.716 A:middle
For both of these onward

00:27:12.716 --> 00:27:13.826 A:middle
accesses to memory has been a

00:27:13.826 --> 00:27:15.336 A:middle
really large barrier to

00:27:15.336 --> 00:27:16.516 A:middle
efficient implementations.

00:27:17.296 --> 00:27:18.976 A:middle
But probably the simplest and

00:27:18.976 --> 00:27:20.566 A:middle
most common application for this

00:27:20.566 --> 00:27:21.836 A:middle
feature is just implementing

00:27:21.836 --> 00:27:22.776 A:middle
custom blend equations.

00:27:23.656 --> 00:27:25.076 A:middle
iOS hardware could always do

00:27:25.076 --> 00:27:27.336 A:middle
this pretty natively, but this

00:27:27.336 --> 00:27:29.406 A:middle
is not something that desktop

00:27:29.406 --> 00:27:31.066 A:middle
hardware has traditionally been

00:27:31.066 --> 00:27:31.686 A:middle
able to do.

00:27:32.656 --> 00:27:33.906 A:middle
So I'm going to use custom

00:27:33.906 --> 00:27:34.986 A:middle
blending as an example

00:27:34.986 --> 00:27:36.076 A:middle
application to introduce this

00:27:36.076 --> 00:27:36.346 A:middle
feature.

00:27:38.076 --> 00:27:40.086 A:middle
Okay, so pretty typical case of

00:27:40.126 --> 00:27:41.316 A:middle
triangle blending; one triangle

00:27:41.316 --> 00:27:41.836 A:middle
over another.

00:27:42.776 --> 00:27:45.036 A:middle
Pretty much all modern GPU APIs

00:27:45.036 --> 00:27:46.386 A:middle
guarantee that blending happens

00:27:46.386 --> 00:27:47.426 A:middle
in draw call order.

00:27:47.566 --> 00:27:48.856 A:middle
It provides this nice,

00:27:48.926 --> 00:27:50.416 A:middle
convenient illusion of serial

00:27:50.416 --> 00:27:50.946 A:middle
execution.

00:27:51.796 --> 00:27:53.376 A:middle
But of course what's really

00:27:53.376 --> 00:27:54.586 A:middle
going on behind the scenes is

00:27:54.676 --> 00:27:56.026 A:middle
GPU hardware's highly parallel.

00:27:56.026 --> 00:27:57.056 A:middle
It's going to be running

00:27:57.056 --> 00:27:58.256 A:middle
multiple threads concurrently.

00:27:58.836 --> 00:28:00.296 A:middle
And only this fixed-function

00:28:00.296 --> 00:28:01.786 A:middle
blend step at the end is going

00:28:01.786 --> 00:28:03.046 A:middle
to be delayed until everything

00:28:03.046 --> 00:28:05.776 A:middle
gets put back in order again.

00:28:05.776 --> 00:28:06.876 A:middle
There's this implicit wait that

00:28:06.876 --> 00:28:08.906 A:middle
happens before that blend step.

00:28:10.476 --> 00:28:12.686 A:middle
Things change however if the

00:28:12.686 --> 00:28:13.616 A:middle
ordering -- if we need to put

00:28:13.616 --> 00:28:14.766 A:middle
things in order not at the end

00:28:14.766 --> 00:28:16.326 A:middle
of our fragment shooter, but

00:28:16.416 --> 00:28:18.066 A:middle
right in the middle because in

00:28:18.066 --> 00:28:20.156 A:middle
this case triangle one wants to

00:28:20.156 --> 00:28:21.316 A:middle
write something to memory that

00:28:21.316 --> 00:28:22.596 A:middle
triangle two's threads want to

00:28:22.596 --> 00:28:23.026 A:middle
read from.

00:28:23.306 --> 00:28:25.016 A:middle
If we want triangle two to be

00:28:25.016 --> 00:28:26.236 A:middle
able to build upon and consume

00:28:26.236 --> 00:28:28.026 A:middle
triangle one's data we need to

00:28:28.026 --> 00:28:28.906 A:middle
get that ordering back.

00:28:29.646 --> 00:28:32.366 A:middle
And so that's pretty much what

00:28:32.366 --> 00:28:33.576 A:middle
Raster Order Groups provides.

00:28:34.706 --> 00:28:37.116 A:middle
So I'm going to jump over to a

00:28:37.206 --> 00:28:38.156 A:middle
shader code example.

00:28:39.806 --> 00:28:41.116 A:middle
So if I want to implement custom

00:28:41.116 --> 00:28:42.466 A:middle
blending, an initial attempt

00:28:42.636 --> 00:28:44.456 A:middle
that does not work is going to

00:28:44.456 --> 00:28:45.726 A:middle
be to replace my classic

00:28:45.726 --> 00:28:46.696 A:middle
graphics frame buffer with a

00:28:46.696 --> 00:28:47.996 A:middle
read to write texture and

00:28:47.996 --> 00:28:49.696 A:middle
perform all of my rendering and

00:28:49.696 --> 00:28:50.636 A:middle
blending directly to this

00:28:50.636 --> 00:28:50.956 A:middle
texture.

00:28:51.776 --> 00:28:53.976 A:middle
But of course if the threads

00:28:53.976 --> 00:28:55.206 A:middle
that I'm blending over have yet

00:28:55.206 --> 00:28:56.416 A:middle
to execute, or concurrently

00:28:56.416 --> 00:28:59.066 A:middle
executing, this is -- this whole

00:28:59.166 --> 00:29:00.596 A:middle
remodify/write sequence is going

00:29:00.596 --> 00:29:01.546 A:middle
to create a race condition.

00:29:02.076 --> 00:29:03.876 A:middle
So how do we use Raster Order

00:29:03.876 --> 00:29:05.146 A:middle
Groups to fix this?

00:29:05.316 --> 00:29:07.416 A:middle
It's really, really easy.

00:29:08.626 --> 00:29:10.146 A:middle
All I have to do is add a new

00:29:10.276 --> 00:29:12.996 A:middle
attribute to the memory that has

00:29:12.996 --> 00:29:14.086 A:middle
conflicting accesses.

00:29:14.866 --> 00:29:16.906 A:middle
At this point the compiler and

00:29:16.906 --> 00:29:17.636 A:middle
the hardware are going to

00:29:17.636 --> 00:29:18.876 A:middle
cooperate to be able to

00:29:18.876 --> 00:29:20.616 A:middle
implicitly take the entire range

00:29:20.866 --> 00:29:21.806 A:middle
of [inaudible] shader that

00:29:21.806 --> 00:29:22.996 A:middle
accesses that memory from the

00:29:22.996 --> 00:29:24.176 A:middle
very first to the very last

00:29:24.176 --> 00:29:25.386 A:middle
access and turn it into a

00:29:25.386 --> 00:29:26.366 A:middle
critical section behind the

00:29:26.366 --> 00:29:26.836 A:middle
scenes.

00:29:28.806 --> 00:29:29.826 A:middle
You can also apply this

00:29:29.826 --> 00:29:31.296 A:middle
attribute to normal device

00:29:31.296 --> 00:29:33.846 A:middle
memory pointers, not just

00:29:34.536 --> 00:29:34.886 A:middle
textures.

00:29:34.886 --> 00:29:37.606 A:middle
So with that we get the thread

00:29:37.606 --> 00:29:38.536 A:middle
schedule that we want.

00:29:39.216 --> 00:29:40.406 A:middle
Thread one will proceed and

00:29:40.406 --> 00:29:42.116 A:middle
write to memory and thread two

00:29:42.116 --> 00:29:43.526 A:middle
is going to stop and wait until

00:29:43.526 --> 00:29:46.046 A:middle
thread one's write's complete

00:29:46.046 --> 00:29:47.916 A:middle
giving us basically race free

00:29:47.916 --> 00:29:51.576 A:middle
access to this memory.

00:29:51.926 --> 00:29:53.096 A:middle
Oh, there's one other really

00:29:53.096 --> 00:29:54.106 A:middle
important topic and that's

00:29:54.106 --> 00:29:56.016 A:middle
talking about which threads are

00:29:56.016 --> 00:29:57.266 A:middle
synchronizing with each other.

00:29:57.706 --> 00:29:59.656 A:middle
So of course GPU hardware's

00:29:59.656 --> 00:30:00.486 A:middle
going to be running not just

00:30:00.486 --> 00:30:02.296 A:middle
two, but tens of thousands of

00:30:02.296 --> 00:30:05.146 A:middle
threads at the same time and in

00:30:05.246 --> 00:30:06.396 A:middle
fact it's probably executing

00:30:06.436 --> 00:30:07.746 A:middle
every single thread from both of

00:30:07.746 --> 00:30:09.136 A:middle
these triangles simultaneously.

00:30:09.616 --> 00:30:12.056 A:middle
So of all of these thousands --

00:30:12.056 --> 00:30:12.816 A:middle
tens of thousands -- of threads,

00:30:12.816 --> 00:30:13.966 A:middle
which one synchronizes with each

00:30:13.966 --> 00:30:14.176 A:middle
other?

00:30:15.836 --> 00:30:17.786 A:middle
So I've highlighted one pixel

00:30:17.786 --> 00:30:18.986 A:middle
here because that's the answer

00:30:18.986 --> 00:30:19.586 A:middle
to this question.

00:30:20.356 --> 00:30:21.876 A:middle
You -- this feature only

00:30:21.876 --> 00:30:22.846 A:middle
synchronizes against other

00:30:22.846 --> 00:30:23.986 A:middle
threads that your current

00:30:23.986 --> 00:30:25.526 A:middle
fragment shooter thread overlaps

00:30:25.526 --> 00:30:27.516 A:middle
with, those other threads that

00:30:27.596 --> 00:30:29.106 A:middle
are targeting the same frame

00:30:29.106 --> 00:30:31.146 A:middle
buffer xy location, targeting

00:30:31.146 --> 00:30:32.886 A:middle
the same multi-sample location,

00:30:33.196 --> 00:30:34.306 A:middle
targeting the same render target

00:30:34.306 --> 00:30:34.786 A:middle
index.

00:30:36.726 --> 00:30:37.776 A:middle
If I wanted -- and it

00:30:37.776 --> 00:30:39.096 A:middle
specifically does not provide

00:30:39.136 --> 00:30:40.756 A:middle
any guarantees at all against --

00:30:40.756 --> 00:30:41.836 A:middle
that you can safely access

00:30:41.836 --> 00:30:43.376 A:middle
memory that are written by any

00:30:43.376 --> 00:30:44.276 A:middle
neighboring pixels.

00:30:45.366 --> 00:30:46.816 A:middle
If you do need to have these

00:30:46.816 --> 00:30:48.496 A:middle
kind of area -- or region of

00:30:48.496 --> 00:30:49.726 A:middle
influence -- kind of algorithms

00:30:50.096 --> 00:30:51.156 A:middle
then you will need to go back to

00:30:51.156 --> 00:30:52.326 A:middle
using full memory barriers

00:30:52.356 --> 00:30:53.736 A:middle
between draw call -- or full API

00:30:53.736 --> 00:30:54.916 A:middle
barriers between draw calls or

00:30:54.916 --> 00:30:55.666 A:middle
render passes.

00:30:56.376 --> 00:30:57.846 A:middle
But this comes at a much higher

00:30:57.846 --> 00:30:59.656 A:middle
performance cost and it does not

00:30:59.656 --> 00:31:00.876 A:middle
work in the case where you have

00:31:00.876 --> 00:31:02.236 A:middle
triangle overlap within a single

00:31:02.236 --> 00:31:02.696 A:middle
draw call.

00:31:03.336 --> 00:31:05.256 A:middle
But for these common algorithms

00:31:05.256 --> 00:31:06.806 A:middle
that you do have only need

00:31:06.806 --> 00:31:08.206 A:middle
overlap only synchronization,

00:31:08.836 --> 00:31:09.976 A:middle
Raster Order Groups can get the

00:31:09.976 --> 00:31:11.286 A:middle
job done at a substantially

00:31:11.286 --> 00:31:13.866 A:middle
lower performance cost.

00:31:13.866 --> 00:31:15.486 A:middle
So this is a pretty actually

00:31:15.676 --> 00:31:16.716 A:middle
easy one and that's really all

00:31:16.716 --> 00:31:17.356 A:middle
I've got to say about it.

00:31:17.396 --> 00:31:19.546 A:middle
Raster Order Groups lets you

00:31:19.546 --> 00:31:21.246 A:middle
efficiently wait for overlapping

00:31:21.516 --> 00:31:24.046 A:middle
and only overlapping threads to

00:31:24.046 --> 00:31:25.136 A:middle
finish their access to memory,

00:31:25.806 --> 00:31:27.586 A:middle
which enables a collection of GP

00:31:27.586 --> 00:31:28.736 A:middle
algorithms that were previously

00:31:28.736 --> 00:31:30.026 A:middle
just too inefficient to use

00:31:30.026 --> 00:31:31.296 A:middle
practically in GPU hardware.

00:31:33.516 --> 00:31:35.766 A:middle
This middle of shader thread

00:31:35.766 --> 00:31:37.076 A:middle
summarization is a feature of

00:31:37.076 --> 00:31:38.556 A:middle
the latest GPU hardware, so it

00:31:38.556 --> 00:31:39.286 A:middle
is something you do need to

00:31:39.286 --> 00:31:40.426 A:middle
check for at run time.

00:31:41.106 --> 00:31:42.446 A:middle
In particular it's supported on

00:31:42.446 --> 00:31:43.896 A:middle
the newest AMD Vega GPUs

00:31:43.896 --> 00:31:45.256 A:middle
announced this week as well as

00:31:45.256 --> 00:31:46.356 A:middle
the past couple years' worth of

00:31:46.356 --> 00:31:47.216 A:middle
Intel GPUs.

00:31:49.136 --> 00:31:50.196 A:middle
And that brings us on to our

00:31:50.196 --> 00:31:51.286 A:middle
second feature and that is the

00:31:51.286 --> 00:31:52.616 A:middle
new iPad Pro's ProMotion

00:31:52.616 --> 00:31:52.966 A:middle
Display.

00:32:01.056 --> 00:32:02.486 A:middle
So ProMotion, this is a

00:32:02.616 --> 00:32:04.006 A:middle
particularly great feature for

00:32:04.006 --> 00:32:05.186 A:middle
graphics and game developers and

00:32:05.186 --> 00:32:06.226 A:middle
so I really want to show you

00:32:06.226 --> 00:32:07.626 A:middle
what you can do with it.

00:32:07.946 --> 00:32:10.466 A:middle
This is the first of a sequence

00:32:10.466 --> 00:32:11.606 A:middle
of timeline diagrams I'm going

00:32:11.606 --> 00:32:13.946 A:middle
to show you, showing us when the

00:32:13.946 --> 00:32:15.606 A:middle
GPU starts and finishes

00:32:15.606 --> 00:32:16.916 A:middle
producing a frame, and then when

00:32:16.916 --> 00:32:18.056 A:middle
that same frame finally gets

00:32:18.056 --> 00:32:19.256 A:middle
onto the glass for the user to

00:32:19.256 --> 00:32:19.526 A:middle
see.

00:32:20.646 --> 00:32:22.116 A:middle
The first and most obvious thing

00:32:22.116 --> 00:32:23.356 A:middle
that ProMotion does is we can

00:32:23.356 --> 00:32:25.146 A:middle
now render at 120 frames per

00:32:25.146 --> 00:32:25.556 A:middle
second.

00:32:27.316 --> 00:32:28.896 A:middle
This feels absolutely fantastic

00:32:28.896 --> 00:32:29.896 A:middle
for anything that has really

00:32:29.896 --> 00:32:31.616 A:middle
high speed animations, for

00:32:31.616 --> 00:32:32.796 A:middle
anything that's latency critical

00:32:32.796 --> 00:32:34.096 A:middle
such as tracking user touch or

00:32:34.096 --> 00:32:34.756 A:middle
pencil input.

00:32:35.576 --> 00:32:37.876 A:middle
And it does have some catches.

00:32:37.876 --> 00:32:40.336 A:middle
You of course only get half as

00:32:40.336 --> 00:32:42.146 A:middle
much CPU and GPU time available

00:32:42.146 --> 00:32:43.596 A:middle
per frame so you really have to

00:32:43.596 --> 00:32:44.356 A:middle
pay a lot of attention to

00:32:44.356 --> 00:32:46.196 A:middle
optimization and it does

00:32:46.196 --> 00:32:47.276 A:middle
increase overall system power

00:32:47.276 --> 00:32:47.836 A:middle
consumption.

00:32:48.816 --> 00:32:49.546 A:middle
But if you've got the right

00:32:49.546 --> 00:32:51.506 A:middle
content, where this matters, it

00:32:51.506 --> 00:32:52.686 A:middle
gets a really payoff for the

00:32:52.686 --> 00:32:53.576 A:middle
user experience.

00:32:55.006 --> 00:32:56.566 A:middle
But ProMotion goes a lot farther

00:32:56.566 --> 00:32:58.096 A:middle
than 120 frames per second

00:32:58.096 --> 00:32:58.436 A:middle
rendering.

00:32:59.176 --> 00:33:01.626 A:middle
It also provides much more

00:33:01.626 --> 00:33:03.496 A:middle
flexibility regarding when to

00:33:03.496 --> 00:33:04.546 A:middle
swap the next image onto the

00:33:04.546 --> 00:33:05.016 A:middle
glass.

00:33:05.726 --> 00:33:07.776 A:middle
We're not limited to just 120 or

00:33:07.776 --> 00:33:09.906 A:middle
30 or 60 frames per second.

00:33:10.486 --> 00:33:12.816 A:middle
ProMotion behaves much more

00:33:12.816 --> 00:33:14.056 A:middle
gracefully as your application's

00:33:14.056 --> 00:33:15.446 A:middle
performance moves up and down

00:33:15.716 --> 00:33:16.756 A:middle
compared to a fixed frame rate

00:33:16.756 --> 00:33:17.166 A:middle
display.

00:33:18.376 --> 00:33:21.186 A:middle
For example, here I have a

00:33:21.226 --> 00:33:22.586 A:middle
timeline diagram of a title

00:33:22.586 --> 00:33:23.926 A:middle
that, you know just -- is just

00:33:23.926 --> 00:33:24.986 A:middle
doing too much GPU work to

00:33:24.986 --> 00:33:26.356 A:middle
target 60 frames per second.

00:33:26.516 --> 00:33:27.226 A:middle
You know they're producing

00:33:27.226 --> 00:33:28.906 A:middle
frames every about 21

00:33:28.906 --> 00:33:30.366 A:middle
milliseconds or about 48 frames

00:33:30.366 --> 00:33:30.836 A:middle
per second.

00:33:31.576 --> 00:33:33.466 A:middle
The GPU is perfectly happy to do

00:33:33.466 --> 00:33:35.526 A:middle
that, but on the display side we

00:33:35.526 --> 00:33:37.076 A:middle
can only refresh once every 16

00:33:37.076 --> 00:33:38.176 A:middle
milliseconds and so we end up

00:33:38.176 --> 00:33:38.976 A:middle
with this beating pattern.

00:33:39.046 --> 00:33:40.126 A:middle
There's this stuttering that the

00:33:40.126 --> 00:33:41.866 A:middle
user feels where some frames are

00:33:41.866 --> 00:33:42.916 A:middle
on the glass a lot longer than

00:33:42.916 --> 00:33:43.356 A:middle
others.

00:33:44.056 --> 00:33:47.006 A:middle
And it's not nice at all.

00:33:47.306 --> 00:33:48.866 A:middle
And so pretty much universally

00:33:48.866 --> 00:33:49.846 A:middle
what applications do in this

00:33:49.846 --> 00:33:50.586 A:middle
case is they all have to

00:33:50.586 --> 00:33:51.976 A:middle
artificially constrain the frame

00:33:51.976 --> 00:33:53.776 A:middle
rate all the way down to 30

00:33:53.776 --> 00:33:56.336 A:middle
frames per second.

00:33:56.336 --> 00:33:57.686 A:middle
They're basically trading away

00:33:57.686 --> 00:33:59.036 A:middle
their peak frame rate in order

00:33:59.036 --> 00:33:59.926 A:middle
to get some level of

00:33:59.926 --> 00:34:00.556 A:middle
consistency.

00:34:02.176 --> 00:34:04.146 A:middle
ProMotion does much better here.

00:34:04.616 --> 00:34:05.636 A:middle
So if I just take the same

00:34:05.636 --> 00:34:06.596 A:middle
application, move it to a

00:34:06.596 --> 00:34:09.126 A:middle
ProMotion display, it does this

00:34:09.126 --> 00:34:09.756 A:middle
to our timeline.

00:34:10.826 --> 00:34:12.036 A:middle
We now have a refresh point

00:34:12.036 --> 00:34:13.596 A:middle
every four milliseconds rather

00:34:13.596 --> 00:34:14.356 A:middle
than every 16.

00:34:15.266 --> 00:34:16.646 A:middle
Our timeline gets pulled in,

00:34:16.866 --> 00:34:18.286 A:middle
even with the GPU doing exactly

00:34:18.286 --> 00:34:19.286 A:middle
the same work as before.

00:34:19.906 --> 00:34:21.976 A:middle
The display can now present at

00:34:21.976 --> 00:34:23.626 A:middle
an entirely consistent 48 frames

00:34:23.626 --> 00:34:24.136 A:middle
per second.

00:34:24.986 --> 00:34:26.466 A:middle
The user is now getting both the

00:34:26.466 --> 00:34:28.176 A:middle
best possible frame rate and

00:34:28.176 --> 00:34:30.156 A:middle
perfect consistency from frame

00:34:30.156 --> 00:34:30.546 A:middle
to frame.

00:34:31.186 --> 00:34:32.116 A:middle
This tradeoff that we had to

00:34:32.116 --> 00:34:33.056 A:middle
make is completely gone.

00:34:34.246 --> 00:34:37.096 A:middle
Furthermore -- so a second

00:34:37.096 --> 00:34:38.996 A:middle
example is that this time in

00:34:38.996 --> 00:34:41.296 A:middle
application that wanted to make

00:34:41.296 --> 00:34:42.936 A:middle
60 frames per second, but one

00:34:42.936 --> 00:34:44.666 A:middle
frame just ran a bit long and we

00:34:44.666 --> 00:34:48.296 A:middle
missed our deadline.

00:34:48.296 --> 00:34:49.886 A:middle
On a fixed frame rate display we

00:34:49.886 --> 00:34:50.826 A:middle
end up on the display side with

00:34:50.826 --> 00:34:51.856 A:middle
a pattern that looks very

00:34:51.856 --> 00:34:53.126 A:middle
similar to what we saw before.

00:34:54.586 --> 00:34:56.416 A:middle
ProMotion can fix this too.

00:34:57.576 --> 00:34:58.626 A:middle
So frame one's time on the

00:34:58.626 --> 00:34:59.866 A:middle
glass, rather than it being

00:34:59.866 --> 00:35:01.336 A:middle
extended by 16 milliseconds, is

00:35:01.336 --> 00:35:02.666 A:middle
now only extended by four.

00:35:03.126 --> 00:35:04.526 A:middle
The degree of stutter that the

00:35:04.526 --> 00:35:06.446 A:middle
user experiences is tremendously

00:35:06.446 --> 00:35:09.066 A:middle
reduced and then frame two and

00:35:09.066 --> 00:35:11.336 A:middle
three, their latency gets pulled

00:35:11.336 --> 00:35:12.286 A:middle
right back into where they were

00:35:12.286 --> 00:35:12.796 A:middle
before.

00:35:13.426 --> 00:35:14.736 A:middle
The system recovers right back

00:35:14.736 --> 00:35:15.886 A:middle
onto the timeline right away,

00:35:16.336 --> 00:35:19.136 A:middle
latency is improved, and your

00:35:19.136 --> 00:35:20.446 A:middle
application can proceed on.

00:35:20.516 --> 00:35:21.306 A:middle
We've just gotten right back to

00:35:21.306 --> 00:35:22.756 A:middle
where we wanted to be.

00:35:23.416 --> 00:35:26.126 A:middle
So put it all together, it just

00:35:26.126 --> 00:35:27.816 A:middle
makes animation just feel that

00:35:27.816 --> 00:35:29.136 A:middle
much more robust and solid no

00:35:29.136 --> 00:35:30.786 A:middle
matter what's going on.

00:35:31.906 --> 00:35:33.816 A:middle
So how do you actually go about

00:35:33.816 --> 00:35:35.116 A:middle
taking advantage of this?

00:35:35.756 --> 00:35:38.576 A:middle
For normal UIKit animation, such

00:35:38.576 --> 00:35:39.546 A:middle
as scrolling through lists or

00:35:39.546 --> 00:35:41.506 A:middle
views, iOS will do this entirely

00:35:41.506 --> 00:35:42.516 A:middle
for you out of the box.

00:35:43.016 --> 00:35:44.506 A:middle
It will render it 120 frames per

00:35:44.506 --> 00:35:45.456 A:middle
second when appropriate.

00:35:45.526 --> 00:35:47.606 A:middle
It will use the flexible display

00:35:47.696 --> 00:35:48.466 A:middle
times when appropriate.

00:35:50.206 --> 00:35:51.256 A:middle
Metal applications though tend

00:35:51.256 --> 00:35:52.286 A:middle
to be much more aware of their

00:35:52.286 --> 00:35:53.466 A:middle
timing and so for those we've

00:35:53.466 --> 00:35:54.446 A:middle
made this an opt in feature.

00:35:55.766 --> 00:35:57.886 A:middle
Opting in is done really easily

00:35:57.886 --> 00:35:59.186 A:middle
just by adding a new entry to

00:35:59.186 --> 00:36:00.106 A:middle
your application bundles

00:36:00.106 --> 00:36:00.866 A:middle
info.plist.

00:36:01.596 --> 00:36:03.206 A:middle
Once you do this the timing

00:36:03.206 --> 00:36:04.616 A:middle
behavior of our three Metal

00:36:04.616 --> 00:36:06.266 A:middle
presentation API changes a

00:36:06.266 --> 00:36:06.536 A:middle
little bit.

00:36:06.536 --> 00:36:07.536 A:middle
And so I'm going to walk you

00:36:07.536 --> 00:36:08.846 A:middle
through those three APIs and how

00:36:08.846 --> 00:36:09.456 A:middle
they change now.

00:36:10.226 --> 00:36:12.066 A:middle
So the first of our Metal

00:36:12.066 --> 00:36:14.046 A:middle
presentation APIs is just

00:36:14.466 --> 00:36:14.966 A:middle
present.

00:36:15.616 --> 00:36:18.216 A:middle
It's -- it says present

00:36:18.216 --> 00:36:20.156 A:middle
immediately; schedule my image

00:36:20.156 --> 00:36:21.206 A:middle
to be put on the glass at the

00:36:21.206 --> 00:36:22.676 A:middle
very next available refresh

00:36:22.726 --> 00:36:24.306 A:middle
point after the GPU finishes.

00:36:25.376 --> 00:36:26.596 A:middle
On fixed frame rate hardware

00:36:26.596 --> 00:36:28.566 A:middle
that's 16 milliseconds and on

00:36:28.566 --> 00:36:29.956 A:middle
iPad Pro that's now four

00:36:29.956 --> 00:36:30.626 A:middle
milliseconds.

00:36:31.296 --> 00:36:32.866 A:middle
This is the easiest API to use

00:36:32.866 --> 00:36:33.726 A:middle
because it takes no runs.

00:36:33.726 --> 00:36:35.046 A:middle
So it's the API that most of the

00:36:35.046 --> 00:36:35.966 A:middle
people in this room are already

00:36:35.966 --> 00:36:36.296 A:middle
using.

00:36:37.416 --> 00:36:38.476 A:middle
It's also the API that gives you

00:36:38.476 --> 00:36:40.056 A:middle
the lowest latency access to the

00:36:40.056 --> 00:36:40.466 A:middle
display.

00:36:41.296 --> 00:36:43.236 A:middle
It works identically on both our

00:36:43.236 --> 00:36:44.596 A:middle
fixed frame rate and ProMotion

00:36:44.596 --> 00:36:46.636 A:middle
hardware, but once you opt in it

00:36:46.636 --> 00:36:47.486 A:middle
starts working with much, much

00:36:47.486 --> 00:36:47.976 A:middle
better granularity.

00:36:51.646 --> 00:36:53.116 A:middle
The second of our Metal

00:36:53.116 --> 00:36:54.996 A:middle
presentation APIs is present

00:36:54.996 --> 00:36:56.036 A:middle
with minimum duration.

00:36:56.806 --> 00:36:59.236 A:middle
So this one says, whenever this

00:36:59.236 --> 00:37:00.766 A:middle
image lands on the glass, keep

00:37:00.766 --> 00:37:01.836 A:middle
it there for a certain fixed

00:37:01.836 --> 00:37:02.486 A:middle
amount of time.

00:37:03.046 --> 00:37:03.956 A:middle
So if my image lands on the

00:37:03.956 --> 00:37:04.966 A:middle
glass here, it's going to stay

00:37:04.966 --> 00:37:06.076 A:middle
for 33 milliseconds.

00:37:06.076 --> 00:37:08.176 A:middle
And if my start time shifts so

00:37:08.176 --> 00:37:08.896 A:middle
does the end time.

00:37:09.576 --> 00:37:11.116 A:middle
This is the API you'd use if you

00:37:11.116 --> 00:37:12.386 A:middle
want perfect consistency in

00:37:12.386 --> 00:37:13.796 A:middle
frame rate from frame to frame.

00:37:14.416 --> 00:37:16.146 A:middle
This is particularly useful in

00:37:16.146 --> 00:37:17.616 A:middle
30 frames per seconds -- on 60

00:37:17.856 --> 00:37:19.406 A:middle
rate per seconds displays,

00:37:19.406 --> 00:37:20.316 A:middle
although it's also sometimes

00:37:20.316 --> 00:37:21.446 A:middle
useful on ProMotion as well.

00:37:22.416 --> 00:37:24.706 A:middle
But our third presentation

00:37:24.706 --> 00:37:25.916 A:middle
varying is the most interesting

00:37:25.916 --> 00:37:26.386 A:middle
by far.

00:37:26.596 --> 00:37:28.406 A:middle
It's present at a specific time

00:37:28.736 --> 00:37:30.486 A:middle
and it does exactly what it

00:37:30.486 --> 00:37:30.996 A:middle
sounds like.

00:37:31.736 --> 00:37:33.106 A:middle
If the GPU's done well before

00:37:33.106 --> 00:37:34.436 A:middle
the designated time, the display

00:37:34.436 --> 00:37:34.836 A:middle
will wait.

00:37:35.196 --> 00:37:36.556 A:middle
If the GPU runs over your

00:37:36.556 --> 00:37:37.966 A:middle
deadline the display will pick

00:37:37.966 --> 00:37:39.606 A:middle
it up at the very next available

00:37:39.606 --> 00:37:40.536 A:middle
point afterwards.

00:37:41.666 --> 00:37:44.256 A:middle
This is the key API to use if

00:37:44.256 --> 00:37:45.376 A:middle
you want to build fully custom

00:37:45.376 --> 00:37:46.596 A:middle
animation and timing loops.

00:37:47.286 --> 00:37:49.036 A:middle
This API to present and time,

00:37:49.116 --> 00:37:50.656 A:middle
combined with ProMotion display

00:37:51.096 --> 00:37:52.286 A:middle
basically lets you leave behind

00:37:52.286 --> 00:37:53.446 A:middle
the concept of a fixed frame

00:37:53.446 --> 00:37:54.696 A:middle
rate entirely and render your

00:37:54.696 --> 00:37:56.206 A:middle
content exactly for the time the

00:37:56.206 --> 00:37:57.196 A:middle
user is going to see it.

00:37:58.006 --> 00:37:59.296 A:middle
If you want to keep your Metal

00:37:59.296 --> 00:38:00.516 A:middle
view perfectly in synch with

00:38:00.516 --> 00:38:01.416 A:middle
something else happening on the

00:38:01.416 --> 00:38:03.386 A:middle
system, such as audio, or if you

00:38:03.386 --> 00:38:04.236 A:middle
want to basically provide the

00:38:04.236 --> 00:38:05.476 A:middle
appearance of zero latency at

00:38:05.476 --> 00:38:06.606 A:middle
all and be able to forward

00:38:06.606 --> 00:38:07.766 A:middle
project your animation for

00:38:07.766 --> 00:38:09.176 A:middle
exactly when the user's going to

00:38:09.176 --> 00:38:11.036 A:middle
see your content this is what

00:38:11.036 --> 00:38:11.846 A:middle
lets you do that.

00:38:13.266 --> 00:38:14.116 A:middle
Now of course the trick is

00:38:14.116 --> 00:38:15.326 A:middle
implementing that project next

00:38:15.326 --> 00:38:15.896 A:middle
display time.

00:38:15.896 --> 00:38:16.596 A:middle
That's your function.

00:38:17.616 --> 00:38:18.776 A:middle
To make that work you do need

00:38:18.776 --> 00:38:19.986 A:middle
some feedback from the system to

00:38:19.986 --> 00:38:21.146 A:middle
help you determine what your

00:38:21.146 --> 00:38:22.166 A:middle
actual performance is.

00:38:22.196 --> 00:38:23.356 A:middle
And so we've added that as well.

00:38:24.646 --> 00:38:26.966 A:middle
So a Metal drawable object is a

00:38:26.966 --> 00:38:28.156 A:middle
transient object that tracks the

00:38:28.156 --> 00:38:29.496 A:middle
lifetime of one image you've

00:38:29.496 --> 00:38:30.746 A:middle
rendered all the way through the

00:38:30.746 --> 00:38:31.516 A:middle
display system.

00:38:31.736 --> 00:38:34.896 A:middle
It can now be queried for the

00:38:34.896 --> 00:38:36.426 A:middle
specific time that frame lands

00:38:36.426 --> 00:38:37.606 A:middle
on the glass and you can also

00:38:37.606 --> 00:38:38.346 A:middle
get a call back when that

00:38:38.346 --> 00:38:38.866 A:middle
happens.

00:38:39.906 --> 00:38:41.466 A:middle
So now you can know when your

00:38:41.466 --> 00:38:42.696 A:middle
image is landing on the glass,

00:38:43.076 --> 00:38:44.656 A:middle
when they're being removed, and

00:38:44.656 --> 00:38:45.696 A:middle
you have the key signal to know

00:38:45.696 --> 00:38:47.356 A:middle
when you are or are not making

00:38:47.356 --> 00:38:48.436 A:middle
the designated timing that you

00:38:48.436 --> 00:38:49.876 A:middle
intended and are giving you the

00:38:49.876 --> 00:38:51.156 A:middle
signal to adjust for future

00:38:51.156 --> 00:38:51.706 A:middle
frames.

00:38:54.176 --> 00:38:56.146 A:middle
So that's the story of ProMotion

00:38:56.146 --> 00:38:57.276 A:middle
and what you need to do to make

00:38:57.276 --> 00:38:58.296 A:middle
use of it on the future -- on

00:38:58.296 --> 00:38:59.326 A:middle
these new iPad Pros.

00:38:59.936 --> 00:39:01.566 A:middle
It's incredibly easy to get more

00:39:01.566 --> 00:39:02.706 A:middle
consistent and higher frame

00:39:02.706 --> 00:39:05.256 A:middle
rates with almost no code

00:39:05.256 --> 00:39:06.496 A:middle
changing at all in most

00:39:06.496 --> 00:39:07.246 A:middle
applications.

00:39:07.646 --> 00:39:10.306 A:middle
From there it gives you a menu

00:39:10.306 --> 00:39:11.606 A:middle
of options to decide what

00:39:11.606 --> 00:39:12.766 A:middle
display time model is going to

00:39:12.766 --> 00:39:13.906 A:middle
best benefit your particular

00:39:13.906 --> 00:39:14.126 A:middle
app.

00:39:14.976 --> 00:39:16.356 A:middle
A really, really fast paced

00:39:16.406 --> 00:39:18.216 A:middle
Twitch arcade game or something

00:39:18.216 --> 00:39:19.986 A:middle
tracking touch or pencil input

00:39:19.986 --> 00:39:21.286 A:middle
probably wants to go for 120

00:39:21.286 --> 00:39:22.036 A:middle
frames per second.

00:39:22.646 --> 00:39:24.386 A:middle
A really high end rendering

00:39:24.386 --> 00:39:25.766 A:middle
title might want to stick with

00:39:25.836 --> 00:39:27.156 A:middle
30 or 60 frames per second or

00:39:27.156 --> 00:39:28.176 A:middle
somewhere in between and just

00:39:28.176 --> 00:39:30.456 A:middle
enjoy the consistency benefits.

00:39:31.136 --> 00:39:32.266 A:middle
And applications that want to

00:39:32.266 --> 00:39:33.166 A:middle
really take control of their

00:39:33.166 --> 00:39:34.506 A:middle
timing loop have entirely new

00:39:34.506 --> 00:39:35.546 A:middle
capabilities here as well.

00:39:36.776 --> 00:39:37.956 A:middle
But regardless of what your app

00:39:37.956 --> 00:39:39.966 A:middle
actually is, ProMotion gives you

00:39:39.966 --> 00:39:41.186 A:middle
this powerful new tool to

00:39:41.186 --> 00:39:42.446 A:middle
support its specific animation

00:39:42.446 --> 00:39:42.726 A:middle
needs.

00:39:42.726 --> 00:39:45.306 A:middle
So that's ProMotion.

00:39:46.016 --> 00:39:48.846 A:middle
So moving on, I have a different

00:39:48.936 --> 00:39:50.346 A:middle
display topic to talk about and

00:39:50.346 --> 00:39:51.256 A:middle
that is a feature we're calling

00:39:51.256 --> 00:39:52.326 A:middle
Direct 2 Display.

00:39:54.236 --> 00:39:56.206 A:middle
So the story of what happens

00:39:56.206 --> 00:39:58.036 A:middle
after your GPU finishes

00:39:58.036 --> 00:39:59.306 A:middle
rendering your content and the

00:39:59.306 --> 00:40:00.426 A:middle
display is actually a little bit

00:40:00.426 --> 00:40:01.066 A:middle
more complicated.

00:40:01.116 --> 00:40:02.886 A:middle
And then your image can take two

00:40:02.886 --> 00:40:04.836 A:middle
paths to the display; GPU

00:40:04.836 --> 00:40:07.016 A:middle
composition and direct to

00:40:08.116 --> 00:40:08.306 A:middle
display.

00:40:08.426 --> 00:40:10.256 A:middle
The first of those is a -- your

00:40:10.256 --> 00:40:11.956 A:middle
typical user interface scenario

00:40:12.486 --> 00:40:13.446 A:middle
where I've got a collection of

00:40:13.446 --> 00:40:15.086 A:middle
views or layers or windows and

00:40:15.086 --> 00:40:17.426 A:middle
the like and at this point the

00:40:17.426 --> 00:40:18.376 A:middle
system is going to take all of

00:40:18.376 --> 00:40:19.136 A:middle
these and composite them

00:40:19.136 --> 00:40:19.496 A:middle
together.

00:40:19.636 --> 00:40:20.776 A:middle
It's going to scale any content

00:40:20.776 --> 00:40:21.396 A:middle
to fit the display.

00:40:21.396 --> 00:40:21.906 A:middle
It's going to perform

00:40:21.906 --> 00:40:22.796 A:middle
color/space conversion.

00:40:22.796 --> 00:40:23.746 A:middle
It's going to perform -- apply

00:40:23.746 --> 00:40:24.776 A:middle
any core image filters or

00:40:24.776 --> 00:40:26.056 A:middle
blending and it's going to

00:40:26.056 --> 00:40:27.516 A:middle
produce the one, final combined

00:40:27.516 --> 00:40:28.636 A:middle
image that the user sees.

00:40:30.776 --> 00:40:32.436 A:middle
This is really, really critical

00:40:32.436 --> 00:40:33.676 A:middle
abstraction for full-featured

00:40:33.676 --> 00:40:34.586 A:middle
user interfaces.

00:40:35.106 --> 00:40:38.136 A:middle
But it's also all done on the

00:40:38.136 --> 00:40:39.186 A:middle
GPU and it takes some time and

00:40:39.186 --> 00:40:39.706 A:middle
memory there.

00:40:40.436 --> 00:40:41.746 A:middle
And if we're basically building,

00:40:41.746 --> 00:40:42.646 A:middle
you know a full-screen

00:40:42.646 --> 00:40:44.046 A:middle
application, you know it's a

00:40:44.046 --> 00:40:45.136 A:middle
little bit overkill for that.

00:40:45.136 --> 00:40:46.316 A:middle
And so that's where direct

00:40:46.316 --> 00:40:48.106 A:middle
display mode comes in.

00:40:48.256 --> 00:40:49.236 A:middle
If none of these operations are

00:40:49.236 --> 00:40:51.496 A:middle
actually required, we can point

00:40:51.496 --> 00:40:52.936 A:middle
the display hardware directly at

00:40:52.976 --> 00:40:54.216 A:middle
the memory you just rendered to

00:40:54.586 --> 00:40:55.856 A:middle
and so without any middleman at

00:40:55.856 --> 00:40:55.986 A:middle
all.

00:40:57.646 --> 00:40:59.026 A:middle
So how do you enable this?

00:40:59.406 --> 00:41:01.196 A:middle
It turns out there is no single

00:41:01.196 --> 00:41:02.716 A:middle
turn it on API for direct to

00:41:02.716 --> 00:41:03.146 A:middle
display.

00:41:03.916 --> 00:41:05.566 A:middle
This mode is really an omission

00:41:05.566 --> 00:41:06.796 A:middle
of anything that requires the

00:41:06.796 --> 00:41:08.166 A:middle
GPU compositer to intervene.

00:41:08.836 --> 00:41:10.386 A:middle
When the compositer takes a look

00:41:10.386 --> 00:41:11.596 A:middle
at the set-up of your scene and

00:41:11.596 --> 00:41:13.026 A:middle
says there's nothing it needs to

00:41:13.026 --> 00:41:14.686 A:middle
do here it will just step out of

00:41:14.686 --> 00:41:15.626 A:middle
the way.

00:41:16.426 --> 00:41:18.176 A:middle
So how can you set up your scene

00:41:18.176 --> 00:41:20.726 A:middle
to get the compositer to step

00:41:20.726 --> 00:41:22.756 A:middle
out of the way?

00:41:23.216 --> 00:41:23.706 A:middle
So this is pretty

00:41:23.706 --> 00:41:24.916 A:middle
straightforward, an intuitive

00:41:24.966 --> 00:41:26.166 A:middle
feel of, does my content need

00:41:26.166 --> 00:41:27.106 A:middle
any kind of nontrurial

00:41:27.106 --> 00:41:27.846 A:middle
[phonetic] processing is a

00:41:27.846 --> 00:41:29.336 A:middle
pretty good intuitive start.

00:41:30.066 --> 00:41:31.146 A:middle
But more specifically you do

00:41:31.146 --> 00:41:32.166 A:middle
want your layer to be opaque.

00:41:32.726 --> 00:41:33.756 A:middle
I don't want to be blending over

00:41:33.756 --> 00:41:34.096 A:middle
anything.

00:41:34.716 --> 00:41:36.616 A:middle
We don't want to apply anything

00:41:36.616 --> 00:41:37.716 A:middle
that requires that core

00:41:37.716 --> 00:41:38.666 A:middle
animation or the window server

00:41:38.916 --> 00:41:39.946 A:middle
modify our pixels.

00:41:39.946 --> 00:41:40.836 A:middle
We don't want to put on rounded

00:41:40.836 --> 00:41:42.406 A:middle
corners in our view or masking

00:41:42.406 --> 00:41:44.326 A:middle
or filters or the like.

00:41:45.656 --> 00:41:46.896 A:middle
We do want to be full-screen.

00:41:47.226 --> 00:41:49.496 A:middle
If your content does not

00:41:49.496 --> 00:41:51.256 A:middle
actually match the aspect ratio

00:41:51.256 --> 00:41:52.436 A:middle
of the display it is okay to put

00:41:52.436 --> 00:41:53.896 A:middle
a full-screen, opaque, black

00:41:53.896 --> 00:41:55.016 A:middle
background layer to sort of give

00:41:55.016 --> 00:41:56.396 A:middle
a black bar kind of effect.

00:41:56.396 --> 00:41:57.216 A:middle
But in the end we want to

00:41:57.216 --> 00:41:58.516 A:middle
basically obscure everything.

00:42:01.456 --> 00:42:02.656 A:middle
We do want to pick render

00:42:02.656 --> 00:42:03.636 A:middle
resolutions that match the

00:42:03.636 --> 00:42:04.306 A:middle
native panel.

00:42:05.176 --> 00:42:06.416 A:middle
So this is actually a little bit

00:42:06.416 --> 00:42:07.616 A:middle
tricky because all of our --

00:42:07.616 --> 00:42:09.056 A:middle
both on macOS and iOS we ship

00:42:09.056 --> 00:42:10.556 A:middle
hardware that has a virtual

00:42:10.556 --> 00:42:12.446 A:middle
desktop modes or resolution

00:42:12.446 --> 00:42:13.696 A:middle
modes that are larger than the

00:42:13.696 --> 00:42:14.676 A:middle
actual physical panel.

00:42:14.766 --> 00:42:16.216 A:middle
And the last thing we want to do

00:42:16.216 --> 00:42:17.356 A:middle
is spend time rendering too many

00:42:17.356 --> 00:42:18.256 A:middle
pixels only to have to spend

00:42:18.286 --> 00:42:19.456 A:middle
time on the GPU to scale it all

00:42:19.456 --> 00:42:19.976 A:middle
back down again.

00:42:24.466 --> 00:42:25.846 A:middle
And finally, you want to pick a

00:42:25.846 --> 00:42:26.976 A:middle
color, space, and pixel format

00:42:26.976 --> 00:42:28.046 A:middle
that the display hardware is

00:42:28.046 --> 00:42:29.186 A:middle
happy to read from directly.

00:42:30.116 --> 00:42:31.126 A:middle
And so this one, there's any

00:42:31.126 --> 00:42:32.216 A:middle
infinite number of combinations

00:42:32.216 --> 00:42:33.986 A:middle
here so I want to help out by

00:42:33.986 --> 00:42:34.656 A:middle
giving you a little bit of a

00:42:34.656 --> 00:42:35.986 A:middle
white list of some particularly

00:42:35.986 --> 00:42:36.916 A:middle
common and efficient

00:42:36.916 --> 00:42:37.576 A:middle
combinations.

00:42:39.926 --> 00:42:41.596 A:middle
So right on the top is our good

00:42:41.596 --> 00:42:44.556 A:middle
old friend; SRGB8888.

00:42:44.556 --> 00:42:45.496 A:middle
This is pretty much the

00:42:45.496 --> 00:42:46.986 A:middle
universal pixel format that most

00:42:46.986 --> 00:42:48.806 A:middle
applications use and all

00:42:48.806 --> 00:42:50.626 A:middle
hardware is happy to read.

00:42:50.626 --> 00:42:51.776 A:middle
And so for most people that's

00:42:51.776 --> 00:42:52.196 A:middle
all they need.

00:42:53.666 --> 00:42:55.876 A:middle
But we've been shipping wide

00:42:55.876 --> 00:42:58.096 A:middle
color gamut P3 displays on both

00:42:58.096 --> 00:43:00.806 A:middle
our macOS and iOS hardware and

00:43:01.106 --> 00:43:02.246 A:middle
if your application does want to

00:43:02.246 --> 00:43:03.766 A:middle
start making use of this ability

00:43:03.766 --> 00:43:04.926 A:middle
to represent more colors, you

00:43:04.926 --> 00:43:06.016 A:middle
need to pay a bit more

00:43:06.016 --> 00:43:06.396 A:middle
attention.

00:43:06.396 --> 00:43:09.676 A:middle
In both the -- the concepts are

00:43:09.676 --> 00:43:11.086 A:middle
the same between iOS and macOS,

00:43:11.086 --> 00:43:11.996 A:middle
although the details differ a

00:43:11.996 --> 00:43:13.316 A:middle
little bit.

00:43:13.316 --> 00:43:14.686 A:middle
In both cases we do want to

00:43:14.686 --> 00:43:15.846 A:middle
render to attend the pixel

00:43:17.266 --> 00:43:20.106 A:middle
format, but note that if you

00:43:20.106 --> 00:43:21.566 A:middle
render P3 content onto a P3

00:43:21.566 --> 00:43:23.286 A:middle
display that's fine, but if you

00:43:23.286 --> 00:43:25.686 A:middle
render P3 content onto an SRGB

00:43:25.686 --> 00:43:28.166 A:middle
display the system -- the GP

00:43:28.166 --> 00:43:29.266 A:middle
compositer might have to get

00:43:29.266 --> 00:43:30.326 A:middle
involved to crush the color

00:43:30.326 --> 00:43:31.426 A:middle
space back down to fit the

00:43:31.426 --> 00:43:31.796 A:middle
display.

00:43:32.706 --> 00:43:34.206 A:middle
And so this is -- P3 is not

00:43:34.206 --> 00:43:34.816 A:middle
something you want to do

00:43:34.816 --> 00:43:35.996 A:middle
universally, all the time.

00:43:36.106 --> 00:43:37.166 A:middle
you do want to take a look at

00:43:37.226 --> 00:43:39.466 A:middle
the current display and make

00:43:39.466 --> 00:43:40.616 A:middle
this a conditional thing.

00:43:40.986 --> 00:43:43.356 A:middle
So finally, for completeness I'm

00:43:43.356 --> 00:43:44.726 A:middle
also going to list RGBA float

00:43:44.726 --> 00:43:45.866 A:middle
16, which is sort of the

00:43:45.866 --> 00:43:48.116 A:middle
universal, wide gamut, high

00:43:48.116 --> 00:43:49.406 A:middle
dynamic range pixel format.

00:43:49.956 --> 00:43:52.086 A:middle
Although, in -- I do -- it's

00:43:52.086 --> 00:43:53.266 A:middle
also necessary for MacOS's

00:43:53.266 --> 00:43:54.466 A:middle
extended data range feature.

00:43:55.196 --> 00:43:56.076 A:middle
Although it is worth noting that

00:43:56.076 --> 00:43:57.476 A:middle
it does require GPU compositing

00:43:57.476 --> 00:43:57.976 A:middle
in all cases.

00:44:01.646 --> 00:44:02.566 A:middle
So I mentioned, you do want to

00:44:02.566 --> 00:44:03.776 A:middle
be a little bit conditional if

00:44:03.776 --> 00:44:04.716 A:middle
you write an application that's

00:44:04.716 --> 00:44:05.586 A:middle
wide color aware.

00:44:06.376 --> 00:44:07.776 A:middle
Fortunately, both UIKit and

00:44:07.776 --> 00:44:08.596 A:middle
AppKit provide really convenient

00:44:08.596 --> 00:44:08.976 A:middle
APIs to check that.

00:44:13.256 --> 00:44:14.786 A:middle
So the last step is, how do you

00:44:14.786 --> 00:44:16.056 A:middle
know if you're actually on the

00:44:16.056 --> 00:44:17.646 A:middle
directed display path?

00:44:17.646 --> 00:44:18.676 A:middle
So this is a screen shot of our

00:44:18.676 --> 00:44:19.966 A:middle
Metal system trace tool and

00:44:19.966 --> 00:44:20.566 A:middle
instruments.

00:44:20.676 --> 00:44:23.376 A:middle
And Metal system trace is pretty

00:44:23.426 --> 00:44:25.006 A:middle
much a developer tool that will

00:44:25.006 --> 00:44:26.656 A:middle
give you a live timeline of the

00:44:26.656 --> 00:44:27.886 A:middle
CPU and the GPU in the display.

00:44:28.216 --> 00:44:30.106 A:middle
Pretty much a real-world version

00:44:30.106 --> 00:44:30.996 A:middle
of the diagrams I've been

00:44:30.996 --> 00:44:31.636 A:middle
showing you in this

00:44:31.636 --> 00:44:32.236 A:middle
presentation.

00:44:33.396 --> 00:44:35.216 A:middle
So in this case, I want to

00:44:35.216 --> 00:44:36.596 A:middle
highlight my three frames that

00:44:36.596 --> 00:44:37.016 A:middle
I've rendered.

00:44:37.546 --> 00:44:39.106 A:middle
The color-time intervals are my

00:44:39.106 --> 00:44:40.126 A:middle
own application's rendering.

00:44:41.296 --> 00:44:42.716 A:middle
And the gray time intervals are

00:44:42.716 --> 00:44:44.446 A:middle
some other processes in the GPU.

00:44:44.496 --> 00:44:46.806 A:middle
I can get more details down at

00:44:46.806 --> 00:44:47.666 A:middle
the bottom of the window or I

00:44:47.666 --> 00:44:48.306 A:middle
can see it's coming from

00:44:48.306 --> 00:44:50.836 A:middle
backboard D, our iOS composition

00:44:50.836 --> 00:44:51.406 A:middle
process.

00:44:51.596 --> 00:44:52.606 A:middle
So this is the case where my

00:44:52.606 --> 00:44:53.676 A:middle
application is going down the

00:44:53.676 --> 00:44:55.946 A:middle
GPU compositing path.

00:44:55.946 --> 00:44:56.896 A:middle
Going back and revisiting some

00:44:56.896 --> 00:44:59.166 A:middle
of our best practices can remove

00:44:59.166 --> 00:45:00.486 A:middle
that from the picture and now I

00:45:00.486 --> 00:45:02.116 A:middle
can rerun my Metal system trace

00:45:02.556 --> 00:45:04.026 A:middle
and see that I have a timeline

00:45:04.026 --> 00:45:05.626 A:middle
where, you know I've got the GPU

00:45:05.716 --> 00:45:06.616 A:middle
completely and entirely to

00:45:06.616 --> 00:45:06.976 A:middle
myself.

00:45:10.046 --> 00:45:12.006 A:middle
So that's it for direct to

00:45:12.146 --> 00:45:12.756 A:middle
display.

00:45:12.756 --> 00:45:14.086 A:middle
Our system compositors can make

00:45:14.086 --> 00:45:15.406 A:middle
a lot of magic happen behind the

00:45:15.406 --> 00:45:16.746 A:middle
scenes to make full-featured

00:45:16.746 --> 00:45:18.626 A:middle
user interfaces possible, but

00:45:18.626 --> 00:45:19.706 A:middle
that can come at a performance

00:45:19.706 --> 00:45:20.976 A:middle
cost because they use the GPU to

00:45:20.976 --> 00:45:21.426 A:middle
do it.

00:45:22.396 --> 00:45:23.456 A:middle
By being a little bit aware of

00:45:23.456 --> 00:45:24.036 A:middle
what you're asking the

00:45:24.036 --> 00:45:25.536 A:middle
compositer to do, or more

00:45:25.536 --> 00:45:26.896 A:middle
importantly by not asking what

00:45:26.896 --> 00:45:28.186 A:middle
you're not asking the compositer

00:45:28.186 --> 00:45:30.046 A:middle
to do, it can get out of the way

00:45:30.046 --> 00:45:31.816 A:middle
without using the GPU, returning

00:45:31.816 --> 00:45:32.766 A:middle
some of that time to you.

00:45:33.496 --> 00:45:35.536 A:middle
Direct to display is supported

00:45:35.536 --> 00:45:37.046 A:middle
on iOS and Tos and always has

00:45:37.046 --> 00:45:39.056 A:middle
been and its support is new to

00:45:39.056 --> 00:45:40.356 A:middle
macOS High Sierra for Metal

00:45:40.356 --> 00:45:40.976 A:middle
applications.

00:45:45.366 --> 00:45:46.536 A:middle
So with that I want to touch on

00:45:46.536 --> 00:45:48.136 A:middle
our last topic of the day and

00:45:48.136 --> 00:45:50.576 A:middle
that's everything else.

00:45:50.616 --> 00:45:51.716 A:middle
There's a lot more that we've

00:45:51.716 --> 00:45:52.826 A:middle
added to the core frameworks and

00:45:52.826 --> 00:45:54.056 A:middle
sheeting language for Metal 2.

00:45:54.056 --> 00:45:55.306 A:middle
And so I'm not going to dive

00:45:55.306 --> 00:45:56.226 A:middle
deep into any of these things,

00:45:56.226 --> 00:45:56.896 A:middle
but I do want to give you a

00:45:56.896 --> 00:45:57.236 A:middle
survey.

00:45:57.716 --> 00:46:01.036 A:middle
So right off the bat we've added

00:46:01.036 --> 00:46:02.026 A:middle
some new APIs to be able to

00:46:02.026 --> 00:46:03.916 A:middle
query how much GPU memory's

00:46:03.916 --> 00:46:05.316 A:middle
being allocated for each buffer,

00:46:05.316 --> 00:46:06.446 A:middle
for each texture, for each Heap.

00:46:06.736 --> 00:46:08.996 A:middle
This actually takes into account

00:46:08.996 --> 00:46:09.576 A:middle
things that just generally

00:46:09.576 --> 00:46:10.666 A:middle
happen behind the scenes, like

00:46:10.666 --> 00:46:12.496 A:middle
alignment and various padding.

00:46:13.156 --> 00:46:13.996 A:middle
So this can give you a more

00:46:13.996 --> 00:46:15.356 A:middle
accurate view of how much GPU

00:46:15.356 --> 00:46:16.586 A:middle
memory you're actually using.

00:46:16.586 --> 00:46:19.466 A:middle
We also have a roll-up query on

00:46:19.466 --> 00:46:22.006 A:middle
the Metal device, which is the

00:46:22.006 --> 00:46:23.766 A:middle
entire GPU memory usage for your

00:46:23.766 --> 00:46:24.786 A:middle
entire process.

00:46:25.106 --> 00:46:26.716 A:middle
And this is particularly notable

00:46:26.716 --> 00:46:28.616 A:middle
because that also counts all of

00:46:28.616 --> 00:46:29.616 A:middle
the memory that the driver needs

00:46:29.616 --> 00:46:30.966 A:middle
to allocate that's not otherwise

00:46:30.966 --> 00:46:33.156 A:middle
visible to you; things like

00:46:33.156 --> 00:46:34.676 A:middle
memory to put shader code in or

00:46:34.676 --> 00:46:35.686 A:middle
command buffers or anything

00:46:35.686 --> 00:46:36.076 A:middle
else.

00:46:36.576 --> 00:46:37.516 A:middle
So this can give you where

00:46:37.516 --> 00:46:38.216 A:middle
you're at relative -- you know

00:46:38.216 --> 00:46:38.946 A:middle
everything all in compared to

00:46:38.946 --> 00:46:39.976 A:middle
your memory usage target.

00:46:43.736 --> 00:46:44.666 A:middle
We have a couple compute

00:46:44.666 --> 00:46:45.586 A:middle
oriented additions.

00:46:46.026 --> 00:46:47.246 A:middle
The first of those is that we've

00:46:47.246 --> 00:46:48.276 A:middle
added a set of shading language

00:46:48.276 --> 00:46:49.636 A:middle
functions to help -- to allow

00:46:49.636 --> 00:46:50.826 A:middle
you to transfer data directly

00:46:50.826 --> 00:46:51.976 A:middle
between threads in a SIMD group.

00:46:52.176 --> 00:46:54.306 A:middle
If you're not familiar; GPU

00:46:54.306 --> 00:46:55.526 A:middle
hardware typically gains an

00:46:55.746 --> 00:46:57.606 A:middle
individual vertex fragment and

00:46:57.606 --> 00:46:59.586 A:middle
compute shader thread into SIMD

00:46:59.586 --> 00:47:00.756 A:middle
groups and executes them

00:47:00.756 --> 00:47:01.986 A:middle
together for greater efficiency.

00:47:02.536 --> 00:47:04.266 A:middle
This are also called wayfrencer

00:47:04.266 --> 00:47:04.726 A:middle
[phonetic] warps.

00:47:05.766 --> 00:47:07.386 A:middle
Within a group these threads do

00:47:07.386 --> 00:47:08.506 A:middle
have some ability to directly

00:47:08.506 --> 00:47:09.756 A:middle
communicate without having to

00:47:09.756 --> 00:47:10.796 A:middle
load and store through memory.

00:47:11.386 --> 00:47:13.126 A:middle
They can read values directly

00:47:13.126 --> 00:47:14.226 A:middle
out of one thread's register and

00:47:14.226 --> 00:47:15.096 A:middle
write them to another thread's

00:47:15.096 --> 00:47:15.666 A:middle
register.

00:47:15.796 --> 00:47:16.516 A:middle
And that's what these new

00:47:16.516 --> 00:47:17.506 A:middle
standard library functions

00:47:17.506 --> 00:47:17.816 A:middle
allow.

00:47:18.916 --> 00:47:21.516 A:middle
So in this case broadcast means

00:47:21.516 --> 00:47:22.756 A:middle
I can read a data directly --

00:47:22.856 --> 00:47:24.226 A:middle
read a field directly out of

00:47:24.226 --> 00:47:25.526 A:middle
thread zero's registers and

00:47:25.526 --> 00:47:26.406 A:middle
write it directly into the

00:47:26.406 --> 00:47:27.866 A:middle
registers of 16 other threads

00:47:27.866 --> 00:47:28.796 A:middle
that happen to be part of this

00:47:28.796 --> 00:47:28.976 A:middle
group.

00:47:33.146 --> 00:47:34.606 A:middle
Our second compute addition is

00:47:34.606 --> 00:47:35.776 A:middle
to give you more flexibility in

00:47:35.776 --> 00:47:37.086 A:middle
how big your thread groups are.

00:47:37.936 --> 00:47:39.576 A:middle
So for example if I have a pixel

00:47:39.576 --> 00:47:40.556 A:middle
bird here that I want to run

00:47:40.556 --> 00:47:41.916 A:middle
some pretty classic image

00:47:41.916 --> 00:47:44.866 A:middle
processing kernel over, but then

00:47:44.866 --> 00:47:45.936 A:middle
I've written my compute kernel

00:47:45.936 --> 00:47:47.666 A:middle
such that I'm using four by four

00:47:47.716 --> 00:47:48.516 A:middle
thread groups everywhere.

00:47:49.906 --> 00:47:50.936 A:middle
Well, this leads to some

00:47:50.936 --> 00:47:52.246 A:middle
problems because I've got -- if

00:47:52.246 --> 00:47:53.716 A:middle
my image is not a nice multiple

00:47:53.716 --> 00:47:55.056 A:middle
of my thread group size I've got

00:47:55.056 --> 00:47:56.066 A:middle
a bunch of stray threads on the

00:47:56.066 --> 00:47:56.396 A:middle
side.

00:47:57.056 --> 00:47:59.766 A:middle
I mean this means that I've got

00:47:59.766 --> 00:48:01.726 A:middle
to dive into those and say when

00:48:01.726 --> 00:48:02.546 A:middle
I actually write my code.

00:48:02.546 --> 00:48:03.466 A:middle
I have to be defensive.

00:48:03.466 --> 00:48:04.326 A:middle
Am I out of bounds?

00:48:04.326 --> 00:48:05.146 A:middle
I have to handle it in some

00:48:05.146 --> 00:48:05.736 A:middle
special way.

00:48:05.736 --> 00:48:07.136 A:middle
It's doable but annoying.

00:48:07.976 --> 00:48:09.006 A:middle
It also means that we're just

00:48:09.006 --> 00:48:10.126 A:middle
wasting GPU cycles.

00:48:10.646 --> 00:48:12.926 A:middle
So non-uniform thread group

00:48:12.926 --> 00:48:14.536 A:middle
sizes, unless you declare what

00:48:14.536 --> 00:48:15.476 A:middle
dimensions you want to run your

00:48:15.476 --> 00:48:16.896 A:middle
kernel over, without being

00:48:16.896 --> 00:48:18.136 A:middle
multiple thread group sizes.

00:48:18.736 --> 00:48:20.156 A:middle
So the hard working, smaller

00:48:20.156 --> 00:48:21.766 A:middle
thread groups along the edges of

00:48:21.766 --> 00:48:23.536 A:middle
my grid, in order to say -- in

00:48:23.536 --> 00:48:24.466 A:middle
order to just shave off that

00:48:24.466 --> 00:48:26.006 A:middle
unnecessary work it both

00:48:26.096 --> 00:48:28.456 A:middle
improves GPU performance and

00:48:28.456 --> 00:48:29.556 A:middle
just makes your kernels easier

00:48:29.556 --> 00:48:29.976 A:middle
to write.

00:48:34.236 --> 00:48:35.206 A:middle
We've added support for a view

00:48:35.206 --> 00:48:35.896 A:middle
port arrays.

00:48:36.206 --> 00:48:37.736 A:middle
You can now configure up to 16

00:48:37.736 --> 00:48:39.396 A:middle
simultaneous view ports and your

00:48:39.396 --> 00:48:41.146 A:middle
vertex shader can select, per

00:48:41.146 --> 00:48:42.776 A:middle
triangle, which view port that

00:48:42.776 --> 00:48:43.916 A:middle
triangle gets presented into.

00:48:44.626 --> 00:48:45.596 A:middle
I'm not going to go further into

00:48:45.596 --> 00:48:46.256 A:middle
this because it will be

00:48:46.256 --> 00:48:48.026 A:middle
discussed in detail tomorrow in

00:48:48.026 --> 00:48:49.176 A:middle
the VR with Metal 2 session.

00:48:49.546 --> 00:48:50.546 A:middle
It is particularly valuable for

00:48:50.546 --> 00:48:51.346 A:middle
efficiently rendering to the

00:48:51.346 --> 00:48:51.976 A:middle
left and right eyes.

00:48:56.666 --> 00:48:57.476 A:middle
We've added the ability to

00:48:57.476 --> 00:48:59.126 A:middle
choose where in each pixel your

00:48:59.126 --> 00:49:00.076 A:middle
multi-sample locations are

00:49:00.076 --> 00:49:00.606 A:middle
supported.

00:49:01.566 --> 00:49:02.776 A:middle
This lets you do a few

00:49:02.776 --> 00:49:04.356 A:middle
interesting things including

00:49:04.356 --> 00:49:05.366 A:middle
maybe toggling your sample

00:49:05.366 --> 00:49:07.256 A:middle
positions every other frame and

00:49:07.256 --> 00:49:08.396 A:middle
giving you some new -- you know

00:49:08.396 --> 00:49:09.376 A:middle
valuable input into some

00:49:09.376 --> 00:49:10.386 A:middle
temporal anti-aliasing

00:49:10.386 --> 00:49:11.066 A:middle
algorithms.

00:49:15.716 --> 00:49:17.206 A:middle
In the vein of trying to keep --

00:49:17.266 --> 00:49:18.726 A:middle
of working to bring our

00:49:18.726 --> 00:49:19.756 A:middle
platforms up to date to have

00:49:19.806 --> 00:49:20.816 A:middle
them have the same feature set

00:49:20.816 --> 00:49:21.856 A:middle
wherever possible, we've brought

00:49:21.856 --> 00:49:23.356 A:middle
resource Heaps, shipped last

00:49:23.356 --> 00:49:25.586 A:middle
year in iOS 10 to macOS High

00:49:25.586 --> 00:49:26.366 A:middle
Sierra this year.

00:49:26.616 --> 00:49:28.826 A:middle
So I'm going to actually do a

00:49:28.826 --> 00:49:29.926 A:middle
little bit of a refresher on

00:49:29.926 --> 00:49:32.196 A:middle
this because good use of your

00:49:32.196 --> 00:49:33.906 A:middle
Heaps is really important to

00:49:33.906 --> 00:49:34.816 A:middle
getting the most out of argument

00:49:34.816 --> 00:49:35.246 A:middle
buffers.

00:49:36.606 --> 00:49:37.986 A:middle
So Heaps are of course where I

00:49:37.986 --> 00:49:38.896 A:middle
can allocate a big slab of

00:49:38.896 --> 00:49:40.786 A:middle
memory up front rather than

00:49:40.786 --> 00:49:42.416 A:middle
going to the kernel to -- I want

00:49:42.506 --> 00:49:43.926 A:middle
memory for texture a, and I want

00:49:43.926 --> 00:49:45.046 A:middle
memory for texture b and so

00:49:45.046 --> 00:49:45.416 A:middle
forth.

00:49:45.826 --> 00:49:46.896 A:middle
I can go to the kernel and get

00:49:46.896 --> 00:49:49.036 A:middle
memory right up front and of

00:49:49.036 --> 00:49:50.626 A:middle
course put textures -- you know

00:49:50.626 --> 00:49:51.556 A:middle
add and remove textures and

00:49:51.556 --> 00:49:52.906 A:middle
buffers to -- without having to

00:49:52.976 --> 00:49:55.396 A:middle
go back to the system.

00:49:55.466 --> 00:49:56.766 A:middle
This has a few advantages.

00:49:56.946 --> 00:49:58.206 A:middle
It means that I can bind

00:49:58.206 --> 00:49:59.116 A:middle
everything in that Heap much

00:49:59.116 --> 00:49:59.726 A:middle
more efficiently.

00:49:59.916 --> 00:50:00.666 A:middle
There's much less software

00:50:00.666 --> 00:50:01.026 A:middle
overhead.

00:50:01.786 --> 00:50:02.966 A:middle
It means that we can oftentimes

00:50:02.966 --> 00:50:03.936 A:middle
pack that memory a little bit

00:50:03.936 --> 00:50:04.466 A:middle
closer together.

00:50:04.466 --> 00:50:05.536 A:middle
We can save some padding and

00:50:05.536 --> 00:50:06.686 A:middle
alignment, save you a little bit

00:50:06.686 --> 00:50:07.056 A:middle
of memory.

00:50:08.096 --> 00:50:10.116 A:middle
It means when we delete memory

00:50:10.426 --> 00:50:11.816 A:middle
we don't give memory back to the

00:50:11.816 --> 00:50:12.236 A:middle
system.

00:50:12.576 --> 00:50:13.296 A:middle
That could be good or bad.

00:50:13.996 --> 00:50:15.666 A:middle
It means when we allocate new

00:50:15.666 --> 00:50:16.526 A:middle
memory -- when we allocate a new

00:50:16.526 --> 00:50:17.676 A:middle
texture it means we don't have

00:50:17.676 --> 00:50:18.656 A:middle
to go back to the system and get

00:50:18.656 --> 00:50:18.976 A:middle
new memory.

00:50:22.476 --> 00:50:23.386 A:middle
It also means that you can

00:50:23.386 --> 00:50:24.916 A:middle
choose to alias these textures

00:50:24.916 --> 00:50:25.476 A:middle
with each other.

00:50:26.256 --> 00:50:27.606 A:middle
If I have -- you typically

00:50:27.606 --> 00:50:29.456 A:middle
render targets or intermediate

00:50:29.456 --> 00:50:31.126 A:middle
render targets between different

00:50:31.126 --> 00:50:32.666 A:middle
passes in my render graph.

00:50:33.076 --> 00:50:34.176 A:middle
It means that if I have two

00:50:34.176 --> 00:50:34.886 A:middle
different intermediates that

00:50:34.886 --> 00:50:36.616 A:middle
just don't have to exist at the

00:50:36.616 --> 00:50:37.966 A:middle
same point in time I can alias

00:50:37.966 --> 00:50:38.926 A:middle
them over each other and I can

00:50:38.926 --> 00:50:43.416 A:middle
save tons of memory like this.

00:50:44.096 --> 00:50:46.066 A:middle
So that's it for a quick survey

00:50:46.866 --> 00:50:47.906 A:middle
of Heaps.

00:50:47.996 --> 00:50:50.196 A:middle
We've added linear textures from

00:50:50.386 --> 00:50:52.056 A:middle
iOS to macOS.

00:50:52.296 --> 00:50:53.366 A:middle
Linear textures allows you to

00:50:53.366 --> 00:50:55.146 A:middle
create a texture directly from a

00:50:55.146 --> 00:50:56.736 A:middle
Metal buffer without any copies

00:50:56.786 --> 00:50:57.216 A:middle
at all.

00:50:59.306 --> 00:51:00.266 A:middle
We've extended our function

00:51:00.266 --> 00:51:01.736 A:middle
constant feature a little bit.

00:51:01.736 --> 00:51:02.766 A:middle
A quick refresher, function

00:51:02.766 --> 00:51:03.656 A:middle
constants allow you to

00:51:03.656 --> 00:51:04.886 A:middle
specialize by codes.

00:51:05.026 --> 00:51:05.926 A:middle
When you've done all your front

00:51:05.926 --> 00:51:07.466 A:middle
end compilation offline you can

00:51:07.466 --> 00:51:08.636 A:middle
then tweak and customize your

00:51:08.636 --> 00:51:09.886 A:middle
uber shader bi-code a little bit

00:51:10.106 --> 00:51:11.296 A:middle
before actual generating final

00:51:11.296 --> 00:51:11.856 A:middle
machine code.

00:51:12.716 --> 00:51:14.046 A:middle
If you have a classic uber

00:51:14.046 --> 00:51:15.156 A:middle
shader this can save you the

00:51:15.156 --> 00:51:16.206 A:middle
cost of having to re-run the

00:51:16.206 --> 00:51:17.836 A:middle
compiler front end for every

00:51:17.836 --> 00:51:18.726 A:middle
single permutation.

00:51:19.806 --> 00:51:21.016 A:middle
So we've made this a bit more

00:51:21.016 --> 00:51:22.546 A:middle
flexible and added a few more

00:51:22.546 --> 00:51:25.136 A:middle
cases where you can use these

00:51:25.246 --> 00:51:26.286 A:middle
specialized arguments.

00:51:28.046 --> 00:51:29.106 A:middle
We've added some extra vertex

00:51:29.106 --> 00:51:29.796 A:middle
array formats.

00:51:29.826 --> 00:51:31.196 A:middle
We had some missing one and two

00:51:31.196 --> 00:51:32.396 A:middle
component vertex formats.

00:51:32.546 --> 00:51:34.366 A:middle
And we've also added BGRA vertex

00:51:34.366 --> 00:51:34.916 A:middle
formats.

00:51:37.576 --> 00:51:38.616 A:middle
We've brought iOS surface

00:51:38.616 --> 00:51:40.306 A:middle
texture support from macOS to

00:51:40.436 --> 00:51:40.846 A:middle
iOS.

00:51:40.846 --> 00:51:42.716 A:middle
And we've also brought dual

00:51:42.716 --> 00:51:44.156 A:middle
sourced blending to iOS as well,

00:51:44.446 --> 00:51:46.666 A:middle
also particularly useful in some

00:51:46.666 --> 00:51:47.926 A:middle
deferred shading scenarios.

00:51:50.706 --> 00:51:52.756 A:middle
So that's -- brings us to the

00:51:52.756 --> 00:51:56.086 A:middle
end of introducing Metal 2.

00:51:56.166 --> 00:51:57.586 A:middle
My colleague, Michal, started

00:51:57.586 --> 00:51:58.976 A:middle
with giving you a little bit of

00:51:58.976 --> 00:52:00.266 A:middle
an overview of the overall scope

00:52:00.266 --> 00:52:00.806 A:middle
of Metal 2.

00:52:01.126 --> 00:52:03.686 A:middle
From VR to external GPUs, to

00:52:04.056 --> 00:52:05.206 A:middle
machine learning, and to new

00:52:05.206 --> 00:52:06.886 A:middle
developer tools and performance

00:52:07.306 --> 00:52:08.026 A:middle
analysis.

00:52:08.026 --> 00:52:08.986 A:middle
Of that, the pieces that we

00:52:08.986 --> 00:52:10.936 A:middle
really covered today are our

00:52:10.936 --> 00:52:12.456 A:middle
next big push toward reducing

00:52:12.576 --> 00:52:13.926 A:middle
CPU overhead using argument

00:52:13.926 --> 00:52:14.386 A:middle
buffers.

00:52:15.006 --> 00:52:16.506 A:middle
Argument buffers also unlock the

00:52:16.506 --> 00:52:17.856 A:middle
ability for the GPU to start

00:52:17.886 --> 00:52:18.956 A:middle
taking a little bit of its own

00:52:18.956 --> 00:52:19.866 A:middle
destiny when it comes to

00:52:19.866 --> 00:52:21.126 A:middle
configuring shader arguments,

00:52:21.126 --> 00:52:22.536 A:middle
which is one less reason to take

00:52:22.536 --> 00:52:24.676 A:middle
back to the CPU.

00:52:25.586 --> 00:52:27.356 A:middle
Raster Order Groups let us start

00:52:27.356 --> 00:52:28.666 A:middle
using the rasterizer for things

00:52:28.666 --> 00:52:30.186 A:middle
beyond basic in order blending.

00:52:31.356 --> 00:52:32.476 A:middle
We can now start taking

00:52:32.476 --> 00:52:34.056 A:middle
advantage of the latest hardware

00:52:34.056 --> 00:52:36.566 A:middle
capabilities to do, you know,

00:52:36.566 --> 00:52:38.386 A:middle
vox slice triangle meshes or set

00:52:38.616 --> 00:52:40.316 A:middle
transparency blending either in

00:52:40.316 --> 00:52:41.226 A:middle
order or independent.

00:52:41.296 --> 00:52:42.216 A:middle
They're both -- it makes them

00:52:42.216 --> 00:52:42.816 A:middle
both possible.

00:52:44.016 --> 00:52:46.656 A:middle
For the new iPad Pros, ProMotion

00:52:46.656 --> 00:52:47.726 A:middle
gives you very fine grained

00:52:47.726 --> 00:52:49.126 A:middle
control over exactly how your

00:52:49.126 --> 00:52:50.226 A:middle
animations are presented to the

00:52:50.226 --> 00:52:51.886 A:middle
user, giving you the ability to

00:52:51.886 --> 00:52:53.656 A:middle
get both peak frame rates and

00:52:53.656 --> 00:52:54.736 A:middle
the lowest possible latency.

00:52:55.136 --> 00:52:57.736 A:middle
Direct to display provides you a

00:52:57.736 --> 00:52:59.116 A:middle
path to reclaim a little bit of

00:52:59.116 --> 00:53:00.436 A:middle
GPU performance from the system

00:53:00.526 --> 00:53:01.706 A:middle
by being aware of what our

00:53:01.706 --> 00:53:02.956 A:middle
compositors do on your behalf.

00:53:06.336 --> 00:53:07.536 A:middle
So you'll be able to find the

00:53:07.536 --> 00:53:08.426 A:middle
video and the slides for this

00:53:08.426 --> 00:53:11.216 A:middle
session on the WWDC2017 website.

00:53:11.876 --> 00:53:15.096 A:middle
We have three other sessions on

00:53:15.096 --> 00:53:15.996 A:middle
Metal 2 this year.

00:53:16.596 --> 00:53:18.536 A:middle
In particular, tomorrow

00:53:18.536 --> 00:53:19.456 A:middle
afternoon we're going to have a

00:53:19.456 --> 00:53:20.696 A:middle
session dedicated to VR and

00:53:20.696 --> 00:53:21.136 A:middle
Metal 2.

00:53:21.326 --> 00:53:22.886 A:middle
This is going to go deep into

00:53:22.886 --> 00:53:24.706 A:middle
what your application needs to

00:53:24.706 --> 00:53:26.456 A:middle
do and a conceptual overview of

00:53:26.456 --> 00:53:28.426 A:middle
how to do VR rendering, dive

00:53:28.426 --> 00:53:30.056 A:middle
into specifically how to do VR

00:53:30.056 --> 00:53:32.106 A:middle
with the combination of Metal 2

00:53:32.106 --> 00:53:34.076 A:middle
and the Steam VR toolkit.

00:53:34.076 --> 00:53:36.086 A:middle
It's also going to go into using

00:53:36.086 --> 00:53:37.326 A:middle
Metal with external GPU

00:53:37.326 --> 00:53:37.736 A:middle
hardware.

00:53:39.666 --> 00:53:40.376 A:middle
On Thursday we have a

00:53:40.376 --> 00:53:42.286 A:middle
doubleheader starting with Metal

00:53:42.286 --> 00:53:43.676 A:middle
2 optimization and debugging.

00:53:43.996 --> 00:53:45.716 A:middle
This is going to go into what's

00:53:45.716 --> 00:53:46.726 A:middle
new in our developer and

00:53:46.726 --> 00:53:48.106 A:middle
performance tools and all the

00:53:48.106 --> 00:53:49.376 A:middle
new workflows that enables to

00:53:49.376 --> 00:53:50.086 A:middle
help you build the best

00:53:50.086 --> 00:53:51.076 A:middle
applications possible.

00:53:51.286 --> 00:53:52.826 A:middle
And it's going to be followed up

00:53:52.826 --> 00:53:54.336 A:middle
right after that with using

00:53:54.336 --> 00:53:55.276 A:middle
Metal 2 for compute.

00:53:55.656 --> 00:53:57.126 A:middle
And that's going to really have

00:53:57.126 --> 00:53:58.896 A:middle
a big focus this year on using

00:53:58.896 --> 00:54:00.206 A:middle
the GPU for machine learning

00:54:00.206 --> 00:54:00.916 A:middle
applications.

00:54:00.916 --> 00:54:01.946 A:middle
We've added a whole lot this

00:54:01.946 --> 00:54:03.806 A:middle
year and we want to show you

00:54:03.806 --> 00:54:05.166 A:middle
everything we've done.

00:54:07.206 --> 00:54:08.386 A:middle
I want to point you to a couple

00:54:08.426 --> 00:54:10.206 A:middle
of last year's WWDC sessions.

00:54:11.286 --> 00:54:12.626 A:middle
The first, What's New in Metal

00:54:12.626 --> 00:54:14.186 A:middle
Part One is where we did a deep

00:54:14.186 --> 00:54:15.786 A:middle
dive on resource Heaps.

00:54:16.196 --> 00:54:17.146 A:middle
And instead if you're looking to

00:54:17.146 --> 00:54:18.026 A:middle
get the best performance out of

00:54:18.026 --> 00:54:19.836 A:middle
argument buffers, argument

00:54:19.836 --> 00:54:20.936 A:middle
buffers and Heaps were built to

00:54:20.936 --> 00:54:22.716 A:middle
go together and so I highly

00:54:22.716 --> 00:54:23.836 A:middle
encourage you to go check out

00:54:23.836 --> 00:54:26.336 A:middle
the video and really -- and, you

00:54:26.436 --> 00:54:28.416 A:middle
know basically plan your

00:54:28.416 --> 00:54:29.326 A:middle
application around both of those

00:54:29.326 --> 00:54:29.686 A:middle
together.

00:54:29.756 --> 00:54:31.196 A:middle
They cover that in a lot more

00:54:31.196 --> 00:54:32.516 A:middle
detail than we did here today.

00:54:34.056 --> 00:54:36.016 A:middle
Second, if the conversation

00:54:36.016 --> 00:54:38.076 A:middle
about direct to display and wide

00:54:38.076 --> 00:54:39.436 A:middle
gamut and wide color interested

00:54:39.436 --> 00:54:40.996 A:middle
you we have a whole session that

00:54:40.996 --> 00:54:41.916 A:middle
really goes deep into the

00:54:41.916 --> 00:54:43.066 A:middle
concepts and the specifics

00:54:43.066 --> 00:54:44.066 A:middle
behind that, we also talked

00:54:44.066 --> 00:54:44.656 A:middle
about last year.

00:54:45.706 --> 00:54:47.676 A:middle
With that I think we'll wrap it

00:54:47.676 --> 00:54:47.796 A:middle
up.

00:54:47.796 --> 00:54:48.886 A:middle
I thank you for all attending

00:54:48.886 --> 00:54:49.596 A:middle
and I hope you enjoy the

00:54:49.596 --> 00:54:50.266 A:middle
remainder of your week.

00:54:50.266 --> 00:54:50.906 A:middle
So thank you.

00:54:51.516 --> 00:54:55.500 A:middle
[ Applause ]