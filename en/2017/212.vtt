WEBVTT

00:00:21.756 --> 00:00:22.106 A:middle
&gt;&gt; Hello.

00:00:23.516 --> 00:00:27.116 A:middle
[ Applause ]

00:00:27.616 --> 00:00:28.166 A:middle
Thanks for coming.

00:00:28.626 --> 00:00:29.636 A:middle
My name is Tony Parker.

00:00:29.636 --> 00:00:30.306 A:middle
I'm the manager of the

00:00:30.306 --> 00:00:31.806 A:middle
Foundation Team at Apple, and

00:00:31.806 --> 00:00:32.516 A:middle
I'm here today with my

00:00:32.516 --> 00:00:33.846 A:middle
colleagues Michael LeHew and

00:00:33.846 --> 00:00:35.226 A:middle
Itai Ferber to tell you What's

00:00:35.226 --> 00:00:36.206 A:middle
New in Foundation.

00:00:37.476 --> 00:00:38.766 A:middle
We have three topics today.

00:00:39.016 --> 00:00:40.376 A:middle
The first, we're going to go

00:00:40.376 --> 00:00:41.916 A:middle
over really quickly some new API

00:00:42.066 --> 00:00:42.966 A:middle
highlights from this year's

00:00:42.966 --> 00:00:43.906 A:middle
release of Foundation.

00:00:44.646 --> 00:00:46.006 A:middle
After that, we're going to go

00:00:46.006 --> 00:00:47.326 A:middle
into the first of our two major

00:00:47.326 --> 00:00:49.796 A:middle
topics, the key paths and key

00:00:49.796 --> 00:00:51.186 A:middle
value observation APIs.

00:00:52.476 --> 00:00:53.536 A:middle
And after that, we'll talk about

00:00:53.536 --> 00:00:55.356 A:middle
our new encoding and decoding

00:00:55.466 --> 00:00:55.846 A:middle
APIs.

00:00:56.636 --> 00:00:58.426 A:middle
So let's get started with those

00:00:58.426 --> 00:01:00.186 A:middle
new API highlights.

00:01:01.996 --> 00:01:04.286 A:middle
First, this year, we've enhanced

00:01:04.286 --> 00:01:05.656 A:middle
the FileProvider API that we

00:01:05.656 --> 00:01:06.956 A:middle
introduced last year as part of

00:01:06.956 --> 00:01:07.506 A:middle
iOS 10.

00:01:08.406 --> 00:01:09.866 A:middle
This enhances your ability to

00:01:09.866 --> 00:01:12.006 A:middle
communicate between FileProvider

00:01:12.006 --> 00:01:13.136 A:middle
extensions and other

00:01:13.136 --> 00:01:13.896 A:middle
applications.

00:01:14.456 --> 00:01:17.046 A:middle
We've improved our available

00:01:17.046 --> 00:01:18.126 A:middle
storage space API.

00:01:18.796 --> 00:01:21.216 A:middle
This is new API on MSURL that

00:01:21.216 --> 00:01:22.586 A:middle
lets you not only get an idea of

00:01:22.586 --> 00:01:24.146 A:middle
how much free space is available

00:01:24.146 --> 00:01:25.706 A:middle
on your customer's device but

00:01:25.706 --> 00:01:26.906 A:middle
also how much space can be made

00:01:26.906 --> 00:01:28.216 A:middle
available if we purge

00:01:28.536 --> 00:01:30.316 A:middle
unnecessary content like caches

00:01:30.416 --> 00:01:31.396 A:middle
or old data.

00:01:32.016 --> 00:01:35.896 A:middle
We've added new API to NS range

00:01:36.046 --> 00:01:37.666 A:middle
and Swift range to help convert

00:01:37.666 --> 00:01:39.766 A:middle
between NSString's use of NS

00:01:39.766 --> 00:01:42.226 A:middle
range and Swift's string and its

00:01:42.226 --> 00:01:42.636 A:middle
range.

00:01:43.106 --> 00:01:44.416 A:middle
This is especially useful for

00:01:44.416 --> 00:01:46.156 A:middle
classes like AttributedString

00:01:46.156 --> 00:01:47.106 A:middle
and RegularExpression.

00:01:47.716 --> 00:01:50.846 A:middle
In NSXPCConnection, we've added

00:01:50.846 --> 00:01:52.996 A:middle
support for, better support for

00:01:53.036 --> 00:01:53.736 A:middle
NSProgress.

00:01:53.736 --> 00:01:54.946 A:middle
And this is actually really

00:01:54.946 --> 00:01:56.106 A:middle
interesting for that first item

00:01:56.326 --> 00:01:58.006 A:middle
because the new, enhanced

00:01:58.006 --> 00:01:59.466 A:middle
ability for communication

00:01:59.466 --> 00:02:01.406 A:middle
between extensions and apps is

00:02:01.406 --> 00:02:03.176 A:middle
actually NSXPCConnection, which

00:02:03.176 --> 00:02:04.646 A:middle
is available this year on iOS

00:02:04.646 --> 00:02:05.366 A:middle
for the first time.

00:02:06.086 --> 00:02:07.516 A:middle
NSURLSession has also gained

00:02:07.516 --> 00:02:08.726 A:middle
support for NSProgress.

00:02:09.166 --> 00:02:10.516 A:middle
And so what we're hoping is that

00:02:10.516 --> 00:02:11.946 A:middle
you can use all of these

00:02:11.946 --> 00:02:14.066 A:middle
progress features together to

00:02:14.266 --> 00:02:16.056 A:middle
flow progress from a download to

00:02:16.056 --> 00:02:18.126 A:middle
the extension, to an app, and

00:02:18.126 --> 00:02:19.326 A:middle
display something to your user.

00:02:19.856 --> 00:02:22.196 A:middle
And finally, we've brought the

00:02:22.196 --> 00:02:23.726 A:middle
thermal notifications from Mac

00:02:23.866 --> 00:02:24.856 A:middle
to iOS this year.

00:02:25.496 --> 00:02:27.056 A:middle
For more on many of these

00:02:27.056 --> 00:02:28.246 A:middle
topics, check out What's New in

00:02:28.246 --> 00:02:28.756 A:middle
Cocoa.

00:02:28.756 --> 00:02:29.896 A:middle
It was this morning, so if you

00:02:29.896 --> 00:02:31.486 A:middle
missed it, we had a pretty big

00:02:31.486 --> 00:02:33.146 A:middle
section on Foundation in that

00:02:33.926 --> 00:02:34.026 A:middle
talk.

00:02:35.436 --> 00:02:37.026 A:middle
Performance was also a really

00:02:37.026 --> 00:02:38.986 A:middle
key consideration for us this

00:02:38.986 --> 00:02:40.576 A:middle
year on Foundation, and that

00:02:40.576 --> 00:02:42.456 A:middle
started with a new copy-on-write

00:02:42.456 --> 00:02:43.936 A:middle
behavior for NSArray and its

00:02:43.966 --> 00:02:45.816 A:middle
dictionary, NSSet, and their

00:02:45.816 --> 00:02:46.456 A:middle
mutable friends.

00:02:47.656 --> 00:02:49.726 A:middle
So a huge motivator for this was

00:02:49.806 --> 00:02:50.726 A:middle
bridging into Swift.

00:02:51.216 --> 00:02:53.876 A:middle
So when an NSArray is returned

00:02:53.876 --> 00:02:55.626 A:middle
from an Objective-C API, perhaps

00:02:55.626 --> 00:02:57.486 A:middle
in a framework, and you use it

00:02:57.486 --> 00:02:58.916 A:middle
in Swift, you're receiving the

00:02:58.916 --> 00:03:00.216 A:middle
Swift value type: array,

00:03:00.216 --> 00:03:01.066 A:middle
dictionary, and set.

00:03:01.066 --> 00:03:03.106 A:middle
And to preserve value semantics,

00:03:03.466 --> 00:03:05.886 A:middle
those structures call copy on

00:03:05.886 --> 00:03:07.086 A:middle
the reference type when they do

00:03:07.086 --> 00:03:07.596 A:middle
that bridging.

00:03:08.296 --> 00:03:09.486 A:middle
If the result happened to be one

00:03:09.486 --> 00:03:11.126 A:middle
of the mutable subclasses, then

00:03:11.126 --> 00:03:12.186 A:middle
that copy could be pretty

00:03:12.186 --> 00:03:12.756 A:middle
expensive.

00:03:13.316 --> 00:03:14.636 A:middle
Now, we can defer the cost of

00:03:14.636 --> 00:03:16.106 A:middle
that copy until the time that

00:03:16.106 --> 00:03:17.466 A:middle
it's actually mutated, if that

00:03:17.466 --> 00:03:19.036 A:middle
happens at all, which can result

00:03:19.036 --> 00:03:21.076 A:middle
in really big improvements for

00:03:21.076 --> 00:03:22.036 A:middle
performance when bridging.

00:03:22.406 --> 00:03:25.276 A:middle
Struct data, a part of the

00:03:25.276 --> 00:03:27.486 A:middle
Foundation's Swift overlap, has

00:03:27.486 --> 00:03:28.816 A:middle
also gained a lot of performance

00:03:28.816 --> 00:03:29.356 A:middle
enhancements.

00:03:29.846 --> 00:03:31.406 A:middle
In particular, something really

00:03:31.406 --> 00:03:32.566 A:middle
cool -- we're able to actually

00:03:32.566 --> 00:03:34.386 A:middle
inline critical parts of data's

00:03:34.386 --> 00:03:35.956 A:middle
behavior into your app when you

00:03:35.956 --> 00:03:36.496 A:middle
compile.

00:03:36.936 --> 00:03:38.096 A:middle
This can include things like

00:03:38.176 --> 00:03:40.136 A:middle
indexing byte by byte in a data.

00:03:40.906 --> 00:03:42.966 A:middle
And again, that leads to some

00:03:42.966 --> 00:03:44.016 A:middle
really impressive performance

00:03:44.016 --> 00:03:44.546 A:middle
improvements.

00:03:45.836 --> 00:03:47.606 A:middle
NSCalendar has gained a better

00:03:47.606 --> 00:03:49.296 A:middle
performance, both in CPU time

00:03:49.296 --> 00:03:51.126 A:middle
and with lower peak memory, and

00:03:51.126 --> 00:03:51.996 A:middle
in addition to that, we've

00:03:51.996 --> 00:03:53.026 A:middle
actually improved the results

00:03:53.026 --> 00:03:54.206 A:middle
that it gives you, especially in

00:03:54.206 --> 00:03:55.006 A:middle
corner cases.

00:03:55.556 --> 00:03:57.756 A:middle
And finally, we've improved the

00:03:57.756 --> 00:03:59.236 A:middle
performance of bridging NSNumber

00:03:59.276 --> 00:04:01.336 A:middle
to and from Swift, and we've

00:04:01.336 --> 00:04:02.956 A:middle
improved its behavior in corner

00:04:02.956 --> 00:04:05.146 A:middle
cases as well to provide better

00:04:05.146 --> 00:04:07.166 A:middle
safety when you are converting

00:04:07.166 --> 00:04:08.716 A:middle
things from NSNumber to Swift

00:04:08.716 --> 00:04:10.096 A:middle
types like integer, Boolean, and

00:04:10.096 --> 00:04:10.496 A:middle
so forth.

00:04:11.446 --> 00:04:12.606 A:middle
This faster bridging has a big

00:04:12.606 --> 00:04:13.796 A:middle
impact on things like property

00:04:13.796 --> 00:04:14.406 A:middle
list parsing.

00:04:15.146 --> 00:04:16.396 A:middle
For more on many of these

00:04:16.396 --> 00:04:17.856 A:middle
topics, check out Efficient

00:04:17.856 --> 00:04:18.896 A:middle
Interactions with Frameworks.

00:04:19.006 --> 00:04:20.416 A:middle
That's Friday at 1:50.

00:04:21.296 --> 00:04:22.346 A:middle
Now, with that, I'd like to turn

00:04:22.346 --> 00:04:23.556 A:middle
it over to my colleague Michael

00:04:23.556 --> 00:04:24.876 A:middle
to talk about key paths and key

00:04:24.876 --> 00:04:25.526 A:middle
value observing.

00:04:26.516 --> 00:04:34.406 A:middle
[ Applause ]

00:04:34.906 --> 00:04:35.546 A:middle
&gt;&gt; Thanks, Tony.

00:04:36.236 --> 00:04:37.676 A:middle
Hi, I'm Michael from the

00:04:37.676 --> 00:04:39.336 A:middle
Foundation Team, and I'm excited

00:04:39.576 --> 00:04:40.736 A:middle
to share some improvements that

00:04:40.736 --> 00:04:42.026 A:middle
we're making to key paths and

00:04:42.026 --> 00:04:43.246 A:middle
key value observing this year.

00:04:43.446 --> 00:04:44.666 A:middle
And I'd like to start by saying

00:04:44.666 --> 00:04:45.616 A:middle
something that we feel fairly

00:04:45.616 --> 00:04:46.876 A:middle
strongly about on the Foundation

00:04:46.876 --> 00:04:47.136 A:middle
Team.

00:04:47.926 --> 00:04:49.276 A:middle
And that is that key paths are

00:04:49.276 --> 00:04:50.696 A:middle
incredibly important in Cocoa

00:04:50.696 --> 00:04:51.286 A:middle
development.

00:04:51.496 --> 00:04:53.056 A:middle
And this is because they let us

00:04:53.056 --> 00:04:54.306 A:middle
reason about the structure of

00:04:54.306 --> 00:04:55.676 A:middle
our types apart from any

00:04:55.676 --> 00:04:57.316 A:middle
specific instance in a way

00:04:57.316 --> 00:04:58.596 A:middle
that's far more constrained than

00:04:58.596 --> 00:04:59.136 A:middle
a closure.

00:04:59.906 --> 00:05:01.486 A:middle
And this is so important that we

00:05:01.486 --> 00:05:02.656 A:middle
felt that they weren't, that

00:05:02.656 --> 00:05:03.816 A:middle
warranted special treatment in

00:05:03.816 --> 00:05:04.666 A:middle
the language itself.

00:05:04.766 --> 00:05:09.466 A:middle
And we started on this last

00:05:09.466 --> 00:05:11.396 A:middle
year, when we added string key

00:05:11.396 --> 00:05:12.706 A:middle
paths to Swift 3.

00:05:13.656 --> 00:05:14.606 A:middle
This was the, this added the

00:05:14.606 --> 00:05:17.506 A:middle
ability for Swift to, at compile

00:05:17.506 --> 00:05:19.196 A:middle
time, confirm the correctness of

00:05:19.196 --> 00:05:21.446 A:middle
an Objective-C key path, which

00:05:21.446 --> 00:05:22.156 A:middle
I'll review now.

00:05:22.676 --> 00:05:23.836 A:middle
Let's suppose we have a class

00:05:23.836 --> 00:05:25.166 A:middle
Kid, and it has some key value

00:05:25.166 --> 00:05:26.396 A:middle
observable properties, such as

00:05:26.396 --> 00:05:28.006 A:middle
their nickname, their age, and,

00:05:28.006 --> 00:05:28.976 A:middle
of course, their current best

00:05:28.976 --> 00:05:29.736 A:middle
friend of the moment.

00:05:30.306 --> 00:05:31.446 A:middle
We can go ahead and construct an

00:05:31.446 --> 00:05:32.746 A:middle
instance -- in this case, a

00:05:32.746 --> 00:05:34.076 A:middle
little boy by the name of Benji

00:05:34.896 --> 00:05:36.406 A:middle
-- and then form a string key

00:05:36.406 --> 00:05:37.776 A:middle
path to a kid's nickname

00:05:37.776 --> 00:05:38.266 A:middle
property.

00:05:38.556 --> 00:05:40.006 A:middle
And then, the Swift compiler

00:05:40.006 --> 00:05:41.296 A:middle
will confirm that this is a

00:05:41.296 --> 00:05:43.896 A:middle
reasonable thing for us to do.

00:05:43.896 --> 00:05:45.636 A:middle
We can then use key value, or

00:05:45.636 --> 00:05:47.856 A:middle
key value coding to read or

00:05:47.856 --> 00:05:49.086 A:middle
write that variable back into

00:05:49.086 --> 00:05:49.796 A:middle
the instance.

00:05:51.316 --> 00:05:52.766 A:middle
Now, while this compile time

00:05:52.766 --> 00:05:54.006 A:middle
check that we get with using a

00:05:54.006 --> 00:05:55.486 A:middle
string key path expression is

00:05:55.486 --> 00:05:57.536 A:middle
pretty awesome, in the end, it

00:05:57.536 --> 00:05:59.176 A:middle
still compiles down to a string.

00:06:00.226 --> 00:06:01.386 A:middle
And in order for that string to

00:06:01.386 --> 00:06:02.566 A:middle
be useful, we need to use the

00:06:02.566 --> 00:06:04.316 A:middle
Objective-C runtime, which, last

00:06:04.316 --> 00:06:05.306 A:middle
I checked, still remains

00:06:05.306 --> 00:06:07.066 A:middle
unavailable for Swift value

00:06:07.066 --> 00:06:08.346 A:middle
types and probably won't be made

00:06:08.346 --> 00:06:09.496 A:middle
available any time soon.

00:06:10.826 --> 00:06:12.756 A:middle
Finally, string key paths carry

00:06:12.756 --> 00:06:15.296 A:middle
no type information.

00:06:15.296 --> 00:06:16.386 A:middle
It's just a string.

00:06:17.666 --> 00:06:19.896 A:middle
And so all general API that uses

00:06:19.896 --> 00:06:21.046 A:middle
string key paths needs to be

00:06:21.046 --> 00:06:23.206 A:middle
defined in terms of any.

00:06:23.756 --> 00:06:27.006 A:middle
But this is Swift, and surely we

00:06:27.006 --> 00:06:27.626 A:middle
can do better.

00:06:28.476 --> 00:06:29.756 A:middle
And so we thought about what

00:06:29.856 --> 00:06:31.256 A:middle
would, you know, key paths, what

00:06:31.256 --> 00:06:32.386 A:middle
should they be in Swift?

00:06:32.666 --> 00:06:34.326 A:middle
Well, we'd want to be able to

00:06:34.326 --> 00:06:35.426 A:middle
describe properties first, so

00:06:35.426 --> 00:06:36.336 A:middle
that's pretty essential.

00:06:36.706 --> 00:06:37.516 A:middle
They should be statically

00:06:37.516 --> 00:06:38.246 A:middle
type-safe.

00:06:39.476 --> 00:06:41.066 A:middle
They should be fast as well.

00:06:41.286 --> 00:06:42.316 A:middle
And they should work with all

00:06:42.316 --> 00:06:43.516 A:middle
the kinds of values that we

00:06:43.516 --> 00:06:44.536 A:middle
encounter in Swift.

00:06:44.886 --> 00:06:47.706 A:middle
And they also should work on all

00:06:47.706 --> 00:06:48.596 A:middle
platforms where Swift is

00:06:48.596 --> 00:06:49.046 A:middle
supported.

00:06:49.976 --> 00:06:51.096 A:middle
And so we thought for a long

00:06:51.096 --> 00:06:52.386 A:middle
time about how to make all these

00:06:52.386 --> 00:06:53.746 A:middle
key paths' dreams come true,

00:06:54.416 --> 00:06:55.996 A:middle
ultimately sharing our idea with

00:06:55.996 --> 00:06:56.926 A:middle
the world through the open

00:06:56.926 --> 00:06:58.596 A:middle
source Swift evolution process

00:06:58.596 --> 00:07:00.946 A:middle
with a document entitled SE-0161

00:07:01.106 --> 00:07:02.736 A:middle
Smart Key Paths.

00:07:02.816 --> 00:07:04.146 A:middle
And here's what the new Swift 4

00:07:04.146 --> 00:07:05.466 A:middle
key path literals look like.

00:07:07.316 --> 00:07:08.906 A:middle
They start with a backslash,

00:07:10.336 --> 00:07:12.046 A:middle
followed by the name of the base

00:07:12.046 --> 00:07:14.666 A:middle
type, a dot to indicate that

00:07:14.666 --> 00:07:15.576 A:middle
we're doing something inside

00:07:15.576 --> 00:07:17.076 A:middle
that base type, and then the

00:07:17.076 --> 00:07:17.826 A:middle
name of the property.

00:07:18.436 --> 00:07:21.036 A:middle
And the backslash here is really

00:07:21.036 --> 00:07:22.436 A:middle
important because it helps us to

00:07:22.436 --> 00:07:24.056 A:middle
disambiguate the execution of a

00:07:24.056 --> 00:07:26.156 A:middle
property versus a mention or a

00:07:26.156 --> 00:07:27.236 A:middle
reference to the property.

00:07:27.756 --> 00:07:30.316 A:middle
And of course, this is Swift, so

00:07:30.316 --> 00:07:31.716 A:middle
when we can infer the base type,

00:07:32.036 --> 00:07:34.546 A:middle
we do, though the backslash and

00:07:34.546 --> 00:07:35.346 A:middle
the dot remain.

00:07:37.036 --> 00:07:38.736 A:middle
Key paths can be composed in

00:07:38.736 --> 00:07:39.896 A:middle
sequence, just like calling

00:07:39.896 --> 00:07:41.126 A:middle
property after property, after

00:07:41.126 --> 00:07:41.536 A:middle
property.

00:07:42.716 --> 00:07:44.416 A:middle
And soon, optional chaining will

00:07:44.416 --> 00:07:46.026 A:middle
work as it does with properties.

00:07:49.196 --> 00:07:50.456 A:middle
We'll also soon allow

00:07:50.456 --> 00:07:51.926 A:middle
indirection through subscripts.

00:07:55.096 --> 00:07:56.286 A:middle
Someone likes that.

00:07:56.286 --> 00:07:56.876 A:middle
I like it too.

00:07:57.136 --> 00:07:59.206 A:middle
[laughs] Key paths can also

00:08:00.306 --> 00:08:02.436 A:middle
begin directly at a subscript,

00:08:02.436 --> 00:08:03.676 A:middle
and here we're starting with

00:08:04.216 --> 00:08:06.446 A:middle
data's byte subscript, and we're

00:08:06.446 --> 00:08:08.266 A:middle
using the startIndex here.

00:08:08.966 --> 00:08:10.886 A:middle
And of course, this can be

00:08:10.886 --> 00:08:12.036 A:middle
inferred as well, though the

00:08:12.036 --> 00:08:14.056 A:middle
backslash and the dot remain for

00:08:14.056 --> 00:08:14.816 A:middle
consistency.

00:08:15.926 --> 00:08:17.326 A:middle
These new key path expressions

00:08:17.326 --> 00:08:19.086 A:middle
offer uniform syntax for all

00:08:19.086 --> 00:08:20.546 A:middle
Swift types that support

00:08:20.546 --> 00:08:21.826 A:middle
properties, whether they are

00:08:21.826 --> 00:08:23.086 A:middle
stored or computed.

00:08:23.886 --> 00:08:25.976 A:middle
And of course, forming key paths

00:08:25.976 --> 00:08:27.566 A:middle
is one thing, but how can we use

00:08:27.566 --> 00:08:27.806 A:middle
them?

00:08:27.916 --> 00:08:29.306 A:middle
Well, let's suppose we have a

00:08:29.306 --> 00:08:32.126 A:middle
key path.

00:08:32.346 --> 00:08:33.736 A:middle
In this case, to a kid's age.

00:08:34.366 --> 00:08:35.546 A:middle
Using the key path to read a

00:08:35.546 --> 00:08:37.246 A:middle
property is as easy as invoking

00:08:37.246 --> 00:08:37.856 A:middle
a subscript.

00:08:39.476 --> 00:08:41.116 A:middle
That's starting to look like

00:08:41.116 --> 00:08:41.966 A:middle
code, so I'm going to go ahead

00:08:41.966 --> 00:08:44.406 A:middle
and syntax highlight now.

00:08:44.656 --> 00:08:44.976 A:middle
There we go.

00:08:45.226 --> 00:08:47.356 A:middle
So there's a little bit going on

00:08:47.356 --> 00:08:48.076 A:middle
here, and I want to talk about

00:08:48.076 --> 00:08:50.446 A:middle
some of the motivations behind

00:08:50.446 --> 00:08:51.636 A:middle
why this looks the way it looks.

00:08:51.886 --> 00:08:53.066 A:middle
First, we gave the key path

00:08:53.406 --> 00:08:56.086 A:middle
subscript parameter a label, and

00:08:56.086 --> 00:08:57.176 A:middle
we did this because we wanted it

00:08:57.176 --> 00:08:58.206 A:middle
to be non-ambiguous with other

00:08:58.206 --> 00:08:59.206 A:middle
subscripts that may exist on

00:08:59.206 --> 00:08:59.796 A:middle
other types.

00:09:00.396 --> 00:09:02.176 A:middle
Next, the type of the value that

00:09:02.176 --> 00:09:03.036 A:middle
you're using, invoking the

00:09:03.036 --> 00:09:04.646 A:middle
subscript on needs to match the

00:09:04.646 --> 00:09:06.936 A:middle
base type of the key path.

00:09:06.936 --> 00:09:08.206 A:middle
And if they match, it's a

00:09:08.206 --> 00:09:09.866 A:middle
reasonable thing, and your code

00:09:09.866 --> 00:09:10.466 A:middle
will compile.

00:09:10.986 --> 00:09:14.086 A:middle
You can also use subscripts to

00:09:14.086 --> 00:09:16.626 A:middle
mutate a particular value.

00:09:17.256 --> 00:09:18.446 A:middle
And subscripts are nice because

00:09:18.446 --> 00:09:20.016 A:middle
they offer a fast and symmetric

00:09:20.016 --> 00:09:21.636 A:middle
syntax for reads and writes into

00:09:21.636 --> 00:09:22.706 A:middle
a value, whether they be a value

00:09:22.706 --> 00:09:24.326 A:middle
type or a reference type.

00:09:24.876 --> 00:09:26.636 A:middle
Now, let me, I've been showing

00:09:26.636 --> 00:09:27.756 A:middle
these with reference types now,

00:09:27.756 --> 00:09:28.876 A:middle
but now I want to switch and

00:09:28.876 --> 00:09:29.986 A:middle
show how they work with value

00:09:29.986 --> 00:09:30.396 A:middle
types.

00:09:30.726 --> 00:09:31.866 A:middle
And to do this, we're going to

00:09:31.866 --> 00:09:32.836 A:middle
expand our example to what I

00:09:32.836 --> 00:09:34.016 A:middle
really wanted to talk about,

00:09:34.146 --> 00:09:35.166 A:middle
which is birthday party

00:09:35.166 --> 00:09:35.526 A:middle
planning.

00:09:36.956 --> 00:09:38.286 A:middle
So let's go ahead and create a

00:09:38.286 --> 00:09:38.686 A:middle
party.

00:09:39.646 --> 00:09:40.366 A:middle
Benji's going to have a

00:09:40.366 --> 00:09:41.686 A:middle
construction-theme birthday

00:09:41.686 --> 00:09:42.486 A:middle
party, it looks like.

00:09:42.926 --> 00:09:44.556 A:middle
And reading from a value type

00:09:44.556 --> 00:09:45.566 A:middle
with a key path that uses the

00:09:45.566 --> 00:09:47.086 A:middle
same subscript syntax that we

00:09:47.086 --> 00:09:48.516 A:middle
saw with our reference types.

00:09:49.156 --> 00:09:52.446 A:middle
Similarly, mutating a party uses

00:09:52.446 --> 00:09:53.576 A:middle
the same subscript syntax.

00:09:53.576 --> 00:09:54.636 A:middle
There's a common theme here.

00:09:54.806 --> 00:09:56.246 A:middle
The syntax really is uniform.

00:09:56.896 --> 00:09:59.526 A:middle
However, since this is Swift, we

00:09:59.526 --> 00:10:00.786 A:middle
know that Ben's party is a

00:10:00.786 --> 00:10:01.926 A:middle
birthday party, and so the

00:10:01.926 --> 00:10:03.406 A:middle
language can infer that for us.

00:10:04.696 --> 00:10:05.836 A:middle
And I just heard that Ben

00:10:05.836 --> 00:10:06.766 A:middle
changed his mind about his

00:10:06.766 --> 00:10:08.156 A:middle
birthday party theme again, so

00:10:08.156 --> 00:10:09.866 A:middle
let's fix that while we're at

00:10:10.576 --> 00:10:10.676 A:middle
it.

00:10:10.896 --> 00:10:11.986 A:middle
Now, here I'm just highlighting

00:10:11.986 --> 00:10:12.676 A:middle
the syntax.

00:10:12.966 --> 00:10:13.946 A:middle
In code like this, you would

00:10:13.946 --> 00:10:15.516 A:middle
just call the properties, so

00:10:15.516 --> 00:10:16.476 A:middle
let's look at what's actually

00:10:16.476 --> 00:10:17.756 A:middle
happening when you use these key

00:10:17.756 --> 00:10:18.736 A:middle
path expressions.

00:10:19.096 --> 00:10:22.866 A:middle
Key path expressions are

00:10:22.866 --> 00:10:24.186 A:middle
actually producing concrete

00:10:24.186 --> 00:10:25.636 A:middle
values, and like all values,

00:10:25.726 --> 00:10:26.566 A:middle
they can be stored.

00:10:27.906 --> 00:10:29.296 A:middle
Well, what is the type of this

00:10:29.296 --> 00:10:29.716 A:middle
variable?

00:10:30.156 --> 00:10:30.876 A:middle
Let's pretend we can

00:10:30.876 --> 00:10:33.026 A:middle
Option-click in X, just like we

00:10:33.026 --> 00:10:34.456 A:middle
could in Xcode and see that, not

00:10:34.456 --> 00:10:35.646 A:middle
surprisingly, we're getting back

00:10:35.646 --> 00:10:37.776 A:middle
a strongly typed key path with

00:10:37.776 --> 00:10:39.286 A:middle
the base type being a kid and

00:10:39.286 --> 00:10:41.026 A:middle
the property type being a string

00:10:41.026 --> 00:10:43.356 A:middle
because nicknames are strings.

00:10:44.176 --> 00:10:45.506 A:middle
Strongly typed key paths also

00:10:45.506 --> 00:10:46.886 A:middle
work with compound key paths.

00:10:47.136 --> 00:10:48.166 A:middle
Here we see that we started a

00:10:48.166 --> 00:10:49.686 A:middle
birthday party and traversed

00:10:49.686 --> 00:10:51.126 A:middle
through to the celebrant's age.

00:10:51.296 --> 00:10:52.726 A:middle
And of course, age is a double

00:10:52.726 --> 00:10:53.726 A:middle
because if you've ever known a

00:10:53.726 --> 00:10:55.386 A:middle
young kid, the numbers after the

00:10:55.386 --> 00:10:56.336 A:middle
decimal point are very

00:10:56.336 --> 00:10:56.836 A:middle
important.

00:10:58.736 --> 00:11:00.186 A:middle
Key paths stored in variables

00:11:00.186 --> 00:11:01.326 A:middle
can be used just like the

00:11:01.326 --> 00:11:01.906 A:middle
literals.

00:11:02.196 --> 00:11:07.106 A:middle
And because they're strongly

00:11:07.106 --> 00:11:08.426 A:middle
typed, they are statically known

00:11:08.426 --> 00:11:09.816 A:middle
to have the right type -- here

00:11:09.816 --> 00:11:11.166 A:middle
double, as we expected.

00:11:12.316 --> 00:11:13.206 A:middle
Let's suppose we had another

00:11:13.206 --> 00:11:14.126 A:middle
birthday party to plan.

00:11:14.806 --> 00:11:16.806 A:middle
This time, it's Mia's, or Ben's

00:11:16.806 --> 00:11:17.676 A:middle
little sister Mia.

00:11:18.706 --> 00:11:19.906 A:middle
We can use the same key path

00:11:19.906 --> 00:11:20.846 A:middle
variable to find out which

00:11:20.846 --> 00:11:22.166 A:middle
birthday she'll be celebrating,

00:11:22.716 --> 00:11:23.916 A:middle
and in this way, key paths kind

00:11:23.916 --> 00:11:25.566 A:middle
of serve as an unexecuted

00:11:25.566 --> 00:11:26.666 A:middle
property invocation.

00:11:27.856 --> 00:11:28.936 A:middle
Now, in this example, I'm hard

00:11:28.936 --> 00:11:30.396 A:middle
coding the celebrant's age, but

00:11:30.526 --> 00:11:31.576 A:middle
let's go ahead and generalize

00:11:31.576 --> 00:11:31.956 A:middle
this a bit.

00:11:32.156 --> 00:11:34.336 A:middle
What if I wanted to know the age

00:11:34.336 --> 00:11:35.746 A:middle
of anyone relevant to a party?

00:11:36.256 --> 00:11:37.256 A:middle
We're going to go ahead and

00:11:37.256 --> 00:11:38.816 A:middle
define a function, and we're

00:11:38.816 --> 00:11:39.296 A:middle
going to call it the

00:11:39.296 --> 00:11:40.926 A:middle
partyPersonsAge function.

00:11:41.316 --> 00:11:42.936 A:middle
They're given a party, and a key

00:11:42.936 --> 00:11:44.536 A:middle
path to a participant will

00:11:44.536 --> 00:11:45.406 A:middle
return their age.

00:11:45.696 --> 00:11:46.626 A:middle
And to do this, I'm going to

00:11:46.626 --> 00:11:48.266 A:middle
show another feature that these

00:11:48.266 --> 00:11:50.066 A:middle
type-safe key paths have, and

00:11:50.066 --> 00:11:50.726 A:middle
that is the ability to

00:11:50.726 --> 00:11:52.536 A:middle
dynamically form new key paths

00:11:52.536 --> 00:11:53.536 A:middle
from other key paths.

00:11:53.976 --> 00:11:55.456 A:middle
And so here I'll append two key

00:11:55.456 --> 00:11:56.466 A:middle
paths together, the

00:11:56.466 --> 00:11:58.376 A:middle
participantPath to a kid's age.

00:11:58.546 --> 00:11:59.616 A:middle
And again, we're inferring kid

00:11:59.616 --> 00:12:00.446 A:middle
here, which is why you don't see

00:12:00.446 --> 00:12:01.486 A:middle
the word "kid" there, except for

00:12:01.486 --> 00:12:02.436 A:middle
in the variable name.

00:12:03.696 --> 00:12:05.466 A:middle
And as you would expect, you get

00:12:05.466 --> 00:12:06.586 A:middle
a strongly typed key path that

00:12:06.586 --> 00:12:07.806 A:middle
starts at a birthday party and

00:12:07.806 --> 00:12:08.386 A:middle
goes to a double.

00:12:09.546 --> 00:12:11.556 A:middle
Using the key path is the same

00:12:11.556 --> 00:12:12.796 A:middle
as any other key path stored

00:12:12.796 --> 00:12:13.376 A:middle
into a variable.

00:12:13.736 --> 00:12:14.656 A:middle
And we can go ahead and call our

00:12:14.656 --> 00:12:15.556 A:middle
function on the celebrant in

00:12:15.556 --> 00:12:16.516 A:middle
that we have the same exact

00:12:16.746 --> 00:12:18.126 A:middle
result that we saw previously.

00:12:19.226 --> 00:12:20.536 A:middle
And when subscripts are

00:12:20.536 --> 00:12:21.816 A:middle
supported, we can also use this

00:12:21.816 --> 00:12:23.466 A:middle
function now to find the age of

00:12:23.466 --> 00:12:25.006 A:middle
the first attendee to the party.

00:12:25.066 --> 00:12:28.216 A:middle
Now, I want to talk to the rules

00:12:28.216 --> 00:12:30.706 A:middle
of appending key paths a bit.

00:12:30.706 --> 00:12:31.906 A:middle
When we append two key paths

00:12:31.906 --> 00:12:33.666 A:middle
together, it's like we're adding

00:12:33.666 --> 00:12:34.176 A:middle
them together.

00:12:34.706 --> 00:12:36.856 A:middle
But in order for this addition

00:12:36.856 --> 00:12:38.266 A:middle
to make sense, we really need to

00:12:38.266 --> 00:12:39.406 A:middle
look at the types of the key

00:12:39.406 --> 00:12:40.176 A:middle
paths involved.

00:12:41.036 --> 00:12:42.306 A:middle
Specifically, we need to look at

00:12:42.396 --> 00:12:43.956 A:middle
each base type and each property

00:12:43.956 --> 00:12:44.226 A:middle
type.

00:12:45.286 --> 00:12:47.736 A:middle
And the inner types need to

00:12:47.736 --> 00:12:48.196 A:middle
match.

00:12:48.316 --> 00:12:50.186 A:middle
And if that's the case, we can

00:12:50.186 --> 00:12:51.466 A:middle
form a key path from the

00:12:51.496 --> 00:12:53.716 A:middle
original base type to the final

00:12:53.716 --> 00:12:54.356 A:middle
property type.

00:12:54.916 --> 00:12:58.606 A:middle
And in this way, it's like key

00:12:58.606 --> 00:12:59.536 A:middle
paths actually don't care how

00:12:59.536 --> 00:13:00.646 A:middle
they get from the, their base

00:13:00.646 --> 00:13:02.286 A:middle
type to the property type, just

00:13:02.286 --> 00:13:03.376 A:middle
that they can, and the compiler

00:13:03.376 --> 00:13:05.896 A:middle
ensures that for us.

00:13:06.086 --> 00:13:06.976 A:middle
Now, I'd like to take another

00:13:06.976 --> 00:13:08.236 A:middle
look at another example or

00:13:08.236 --> 00:13:09.356 A:middle
another aspect of the type

00:13:09.356 --> 00:13:10.606 A:middle
safety that the Swift key paths

00:13:10.606 --> 00:13:13.366 A:middle
provide, in case it wasn't that

00:13:13.676 --> 00:13:13.946 A:middle
clear.

00:13:13.946 --> 00:13:17.296 A:middle
Suppose we wanted to output a

00:13:17.296 --> 00:13:18.236 A:middle
summary of our party.

00:13:18.636 --> 00:13:20.106 A:middle
We could form an array of labels

00:13:20.106 --> 00:13:22.976 A:middle
in key paths, but what would we

00:13:22.976 --> 00:13:25.196 A:middle
expect this array, partyPaths,

00:13:25.616 --> 00:13:26.746 A:middle
what would we expect the type of

00:13:26.746 --> 00:13:27.196 A:middle
it to be?

00:13:27.456 --> 00:13:29.106 A:middle
After all, theme is a string,

00:13:29.476 --> 00:13:30.616 A:middle
the attending is an array of

00:13:30.616 --> 00:13:32.716 A:middle
kids, and the celebrant is a

00:13:32.716 --> 00:13:33.826 A:middle
reference to a single kid.

00:13:35.346 --> 00:13:36.466 A:middle
In this case, we get a new type.

00:13:36.826 --> 00:13:38.276 A:middle
It's a, it's an array of partial

00:13:38.276 --> 00:13:39.676 A:middle
key paths to BirthdayParty.

00:13:40.246 --> 00:13:41.266 A:middle
And partial key paths are

00:13:41.266 --> 00:13:43.186 A:middle
partially type-erased key paths.

00:13:43.656 --> 00:13:44.736 A:middle
They know about their base type,

00:13:44.996 --> 00:13:47.466 A:middle
but they can point to any valid

00:13:47.466 --> 00:13:50.406 A:middle
key path for that particular

00:13:50.406 --> 00:13:50.776 A:middle
base.

00:13:50.776 --> 00:13:52.216 A:middle
And so in this case, let's go

00:13:52.216 --> 00:13:53.486 A:middle
ahead and print our report.

00:13:54.466 --> 00:13:57.176 A:middle
We'll zip our titles and paths

00:13:57.176 --> 00:13:59.446 A:middle
together, use the party path to

00:13:59.446 --> 00:14:01.286 A:middle
get the party value, and then

00:14:01.286 --> 00:14:01.946 A:middle
print our report.

00:14:02.096 --> 00:14:04.086 A:middle
And you can see Mia's having a

00:14:04.086 --> 00:14:05.226 A:middle
space-themed -- well, it looks

00:14:05.226 --> 00:14:06.406 A:middle
like a family birthday party --

00:14:06.566 --> 00:14:07.676 A:middle
but it's space themed, which

00:14:07.676 --> 00:14:11.076 A:middle
should be pretty fun.

00:14:11.296 --> 00:14:12.716 A:middle
Now, I want to add an extension

00:14:12.776 --> 00:14:13.476 A:middle
to BirthdayParty.

00:14:13.756 --> 00:14:14.756 A:middle
We're going to add a function

00:14:14.926 --> 00:14:15.916 A:middle
that lets our kids blow out

00:14:15.916 --> 00:14:16.896 A:middle
their birthday candles, and this

00:14:16.896 --> 00:14:17.586 A:middle
is going to be a little bit

00:14:17.586 --> 00:14:18.346 A:middle
different from what we were

00:14:18.346 --> 00:14:19.836 A:middle
doing previously because up

00:14:19.836 --> 00:14:20.806 A:middle
until now, we've been reading

00:14:20.806 --> 00:14:21.756 A:middle
key paths, and now I want to

00:14:21.756 --> 00:14:23.066 A:middle
write to a key path or use a key

00:14:23.066 --> 00:14:24.006 A:middle
path to write to a value.

00:14:24.216 --> 00:14:25.876 A:middle
So we're going to add our

00:14:25.876 --> 00:14:27.586 A:middle
functions, and I want to point

00:14:27.586 --> 00:14:28.566 A:middle
out that age key path is

00:14:28.566 --> 00:14:29.426 A:middle
actually a new type.

00:14:29.426 --> 00:14:30.736 A:middle
It's a writable key path of a,

00:14:30.866 --> 00:14:31.956 A:middle
that starts at a BirthdayParty

00:14:31.956 --> 00:14:32.736 A:middle
and goes to a double.

00:14:33.236 --> 00:14:35.616 A:middle
We can use writable key paths

00:14:35.616 --> 00:14:37.976 A:middle
just like regular key paths to

00:14:37.976 --> 00:14:39.806 A:middle
get values out of our values,

00:14:40.506 --> 00:14:41.506 A:middle
and we can also use them to

00:14:41.506 --> 00:14:42.386 A:middle
mutate our values.

00:14:43.016 --> 00:14:44.236 A:middle
And we can finally go ahead and

00:14:44.236 --> 00:14:45.246 A:middle
blow out our candles.

00:14:45.616 --> 00:14:46.766 A:middle
This all looks pretty good,

00:14:47.016 --> 00:14:48.106 A:middle
except for one problem.

00:14:48.836 --> 00:14:49.716 A:middle
Doesn't compile.

00:14:50.286 --> 00:14:51.856 A:middle
This is a birthday catastrophe.

00:14:52.846 --> 00:14:54.826 A:middle
So let's try to, I'm going to

00:14:54.826 --> 00:14:56.326 A:middle
debug this live on stage.

00:14:56.706 --> 00:15:00.246 A:middle
Debug. So the compiler's telling

00:15:00.246 --> 00:15:01.406 A:middle
us, "Cannot assign to an

00:15:01.406 --> 00:15:02.446 A:middle
immutable expression of type

00:15:02.486 --> 00:15:04.486 A:middle
'Double,'" which is very Swift

00:15:04.486 --> 00:15:04.736 A:middle
of it.

00:15:04.736 --> 00:15:06.936 A:middle
Let's see if we can figure out

00:15:06.936 --> 00:15:07.506 A:middle
what's going on.

00:15:08.076 --> 00:15:09.206 A:middle
It's saying immutable, but we

00:15:09.206 --> 00:15:12.196 A:middle
are passing a writable key path.

00:15:12.196 --> 00:15:13.946 A:middle
And we are indeed passing a key

00:15:13.946 --> 00:15:14.146 A:middle
path.

00:15:14.146 --> 00:15:15.116 A:middle
Let's confirm, though, that this

00:15:15.116 --> 00:15:16.556 A:middle
key path is actually to

00:15:16.556 --> 00:15:17.226 A:middle
immutable variable.

00:15:17.226 --> 00:15:18.186 A:middle
That, you know, sometimes you

00:15:18.186 --> 00:15:19.216 A:middle
say let when you meant to say

00:15:19.216 --> 00:15:19.496 A:middle
var.

00:15:19.626 --> 00:15:20.306 A:middle
So let's bring back the

00:15:20.306 --> 00:15:21.636 A:middle
declaration of kid, but we'll

00:15:21.636 --> 00:15:23.676 A:middle
see that var, our age is indeed

00:15:23.676 --> 00:15:24.116 A:middle
mutable.

00:15:24.496 --> 00:15:26.196 A:middle
It's a var, so that's not the

00:15:26.196 --> 00:15:26.706 A:middle
problem.

00:15:27.406 --> 00:15:28.496 A:middle
So maybe the problem's with the

00:15:28.496 --> 00:15:29.626 A:middle
actual write itself.

00:15:30.186 --> 00:15:31.166 A:middle
And that's, and we're using the

00:15:31.166 --> 00:15:31.676 A:middle
subscript.

00:15:31.816 --> 00:15:32.926 A:middle
And I'm on stage telling you

00:15:32.926 --> 00:15:34.116 A:middle
that subscripts work, so that's

00:15:34.116 --> 00:15:34.866 A:middle
not the problem.

00:15:35.476 --> 00:15:37.006 A:middle
So it must be something to do

00:15:37.006 --> 00:15:37.536 A:middle
self.

00:15:38.076 --> 00:15:39.136 A:middle
Well, what's self?

00:15:39.136 --> 00:15:40.426 A:middle
Self is an extension on

00:15:40.426 --> 00:15:41.546 A:middle
BirthdayParty, so now we're

00:15:41.546 --> 00:15:42.596 A:middle
going to need to bring back the

00:15:42.596 --> 00:15:43.666 A:middle
declaration of BirthdayParty.

00:15:43.666 --> 00:15:44.576 A:middle
Luckily, we had some room.

00:15:44.786 --> 00:15:47.116 A:middle
And we'll see that

00:15:47.626 --> 00:15:49.196 A:middle
BirthdayParty's a struct, and

00:15:49.196 --> 00:15:50.356 A:middle
structs are value types.

00:15:50.516 --> 00:15:51.566 A:middle
And so the compiler's actually

00:15:51.566 --> 00:15:52.426 A:middle
doing the right thing here.

00:15:52.616 --> 00:15:53.816 A:middle
It's not letting us mutate a

00:15:53.816 --> 00:15:55.126 A:middle
BirthdayParty because our key

00:15:55.126 --> 00:15:56.676 A:middle
path's anchored in a

00:15:56.676 --> 00:15:57.716 A:middle
BirthdayParty there.

00:15:58.346 --> 00:15:59.446 A:middle
And so one trick we could do,

00:15:59.446 --> 00:15:59.726 A:middle
right.

00:15:59.726 --> 00:16:00.946 A:middle
We look in our bag of Swift

00:16:00.946 --> 00:16:03.116 A:middle
tricks that we know, and we see

00:16:03.116 --> 00:16:04.496 A:middle
that, oh, OK, we can just add

00:16:04.496 --> 00:16:05.436 A:middle
mutating, and everything will

00:16:05.436 --> 00:16:05.706 A:middle
work.

00:16:07.136 --> 00:16:08.706 A:middle
But when you do that, you want

00:16:08.706 --> 00:16:09.606 A:middle
to stop and think, is this

00:16:09.606 --> 00:16:10.716 A:middle
really the right choice?

00:16:11.316 --> 00:16:13.396 A:middle
Because we're not really

00:16:13.396 --> 00:16:15.336 A:middle
modifying the key, or the

00:16:15.606 --> 00:16:16.336 A:middle
birthday party.

00:16:16.936 --> 00:16:18.276 A:middle
We're modifying the celebrant.

00:16:18.276 --> 00:16:19.736 A:middle
Birthday parties don't have ages

00:16:19.736 --> 00:16:21.756 A:middle
last I checked, and celebrant's

00:16:21.756 --> 00:16:24.076 A:middle
actually a class, a reference

00:16:24.076 --> 00:16:24.256 A:middle
type.

00:16:24.986 --> 00:16:26.326 A:middle
And so for this, we actually

00:16:26.326 --> 00:16:27.496 A:middle
have another kind of key path

00:16:27.496 --> 00:16:29.496 A:middle
that adds reference mutable

00:16:29.496 --> 00:16:31.696 A:middle
semantics to mutations, and it's

00:16:31.696 --> 00:16:32.736 A:middle
called a reference writable key

00:16:33.956 --> 00:16:34.076 A:middle
path.

00:16:34.846 --> 00:16:35.866 A:middle
And so let's go ahead and use

00:16:35.866 --> 00:16:35.996 A:middle
it.

00:16:36.246 --> 00:16:37.866 A:middle
And this compiles, and we can

00:16:37.866 --> 00:16:39.056 A:middle
finally assert that our little

00:16:39.056 --> 00:16:40.396 A:middle
boy, Benji, is finally one year

00:16:40.396 --> 00:16:41.606 A:middle
older, although I think he goes

00:16:41.606 --> 00:16:43.066 A:middle
by Ben now.

00:16:43.256 --> 00:16:44.036 A:middle
And so we can review the

00:16:44.036 --> 00:16:45.076 A:middle
difference between these two

00:16:45.406 --> 00:16:48.196 A:middle
kinds of mutating key paths.

00:16:48.276 --> 00:16:49.766 A:middle
So we have a writable key path.

00:16:49.916 --> 00:16:51.336 A:middle
And writable key paths write

00:16:51.336 --> 00:16:52.966 A:middle
directly into their value-type

00:16:52.966 --> 00:16:53.556 A:middle
bases.

00:16:53.936 --> 00:16:55.786 A:middle
So the base or the chained bases

00:16:55.906 --> 00:16:56.866 A:middle
need to be mutable.

00:16:57.236 --> 00:16:59.936 A:middle
Whereas a reference writable key

00:16:59.936 --> 00:17:01.666 A:middle
path simply invokes a property

00:17:01.666 --> 00:17:02.966 A:middle
setter on the reference type.

00:17:03.576 --> 00:17:05.136 A:middle
And all of these key path types

00:17:05.136 --> 00:17:08.206 A:middle
form an inheritance tree, each

00:17:08.206 --> 00:17:09.716 A:middle
more specific than the last.

00:17:10.166 --> 00:17:11.716 A:middle
Rooted at the top of this tree

00:17:11.716 --> 00:17:13.046 A:middle
is another kind of key path that

00:17:13.046 --> 00:17:14.086 A:middle
I haven't talked about called an

00:17:14.086 --> 00:17:15.156 A:middle
any key path, and this is a

00:17:15.156 --> 00:17:17.236 A:middle
fully type-erased key path.

00:17:17.236 --> 00:17:18.386 A:middle
And this is useful for when you

00:17:18.386 --> 00:17:19.146 A:middle
have key paths that are

00:17:19.146 --> 00:17:20.636 A:middle
comprised of multiple bases to

00:17:20.636 --> 00:17:21.476 A:middle
multiple different property

00:17:21.476 --> 00:17:22.816 A:middle
types, usually in a collection.

00:17:23.326 --> 00:17:25.256 A:middle
Now, if all of this seems a

00:17:25.256 --> 00:17:26.836 A:middle
little bit complicated, I assure

00:17:26.836 --> 00:17:27.916 A:middle
you that the rules for the kind

00:17:27.916 --> 00:17:29.046 A:middle
of key path that you want, and

00:17:29.046 --> 00:17:32.086 A:middle
use, and get are actually fairly

00:17:32.086 --> 00:17:33.616 A:middle
simple and match the rules that

00:17:33.616 --> 00:17:34.546 A:middle
you're already familiar with

00:17:34.546 --> 00:17:35.686 A:middle
from working with Swift value

00:17:35.756 --> 00:17:37.536 A:middle
types and reference types.

00:17:38.756 --> 00:17:40.366 A:middle
We'll start out with eliminating

00:17:40.366 --> 00:17:41.116 A:middle
half of the problem.

00:17:41.416 --> 00:17:43.916 A:middle
Read-only properties always

00:17:43.916 --> 00:17:46.656 A:middle
yield a key path.

00:17:46.866 --> 00:17:47.786 A:middle
With read-write properties,

00:17:47.786 --> 00:17:48.576 A:middle
things get a little more

00:17:48.576 --> 00:17:49.216 A:middle
nuanced.

00:17:50.716 --> 00:17:52.446 A:middle
Mutable value type bases or

00:17:52.446 --> 00:17:54.026 A:middle
chained mutable value type bases

00:17:54.206 --> 00:17:56.026 A:middle
will result in a writable key

00:17:56.026 --> 00:17:56.156 A:middle
path.

00:17:56.386 --> 00:17:58.516 A:middle
And so writable key paths help

00:17:58.516 --> 00:18:00.816 A:middle
let you write efficiently into a

00:18:00.816 --> 00:18:02.016 A:middle
value type.

00:18:02.426 --> 00:18:03.876 A:middle
However, if one of those value

00:18:03.876 --> 00:18:06.566 A:middle
types is made immutable, say

00:18:06.566 --> 00:18:08.836 A:middle
through a let statement, the

00:18:08.836 --> 00:18:10.156 A:middle
mutability of that property goes

00:18:10.156 --> 00:18:11.186 A:middle
away, just as it does when

00:18:11.186 --> 00:18:12.796 A:middle
you're using regular properties,

00:18:13.236 --> 00:18:14.256 A:middle
and you're left with just a key

00:18:14.946 --> 00:18:15.086 A:middle
path.

00:18:15.896 --> 00:18:17.076 A:middle
And saving the simplest case for

00:18:17.076 --> 00:18:18.566 A:middle
last, read-write properties on

00:18:18.566 --> 00:18:20.196 A:middle
reference type bases always

00:18:20.196 --> 00:18:21.386 A:middle
produce reference writable key

00:18:21.386 --> 00:18:21.836 A:middle
paths.

00:18:21.836 --> 00:18:24.996 A:middle
Now, I want to share one last

00:18:25.226 --> 00:18:26.436 A:middle
detail regarding the behavior of

00:18:26.436 --> 00:18:27.066 A:middle
key paths.

00:18:28.046 --> 00:18:29.596 A:middle
When we can use key paths with

00:18:29.596 --> 00:18:31.076 A:middle
subscripts, it's important to

00:18:31.076 --> 00:18:32.626 A:middle
know how their behavior differs

00:18:32.626 --> 00:18:33.376 A:middle
from closures.

00:18:34.746 --> 00:18:35.966 A:middle
Consider the following example.

00:18:36.626 --> 00:18:37.526 A:middle
Here I'm going to form a key

00:18:37.526 --> 00:18:38.676 A:middle
path to the first attendee of

00:18:38.676 --> 00:18:40.836 A:middle
the birthday party and use that

00:18:40.836 --> 00:18:42.106 A:middle
to identify their, use our

00:18:42.106 --> 00:18:43.486 A:middle
partyPersonAge method from

00:18:43.486 --> 00:18:45.736 A:middle
before to identify their age.

00:18:46.256 --> 00:18:47.886 A:middle
And not surprisingly, the key

00:18:47.886 --> 00:18:48.726 A:middle
path that we get here is

00:18:48.726 --> 00:18:50.156 A:middle
actually, is going to the zeroth

00:18:50.156 --> 00:18:51.716 A:middle
element of the attendees array.

00:18:52.936 --> 00:18:54.216 A:middle
Well, let's suppose I change the

00:18:54.216 --> 00:18:54.936 A:middle
index to 1.

00:18:55.006 --> 00:18:56.356 A:middle
I also care about the second

00:18:56.356 --> 00:18:58.206 A:middle
attendee's age for some reason.

00:18:59.296 --> 00:19:01.176 A:middle
You would be, might be surprised

00:19:02.436 --> 00:19:03.966 A:middle
that the resulting key path

00:19:03.966 --> 00:19:05.186 A:middle
actually is unchanged,

00:19:05.186 --> 00:19:06.516 A:middle
regardless of my changing of

00:19:06.516 --> 00:19:06.976 A:middle
index.

00:19:07.496 --> 00:19:08.766 A:middle
And in this way, key paths

00:19:08.836 --> 00:19:10.456 A:middle
became different than closures.

00:19:10.896 --> 00:19:12.806 A:middle
They capture by value, and so

00:19:12.806 --> 00:19:14.166 A:middle
when this feature becomes

00:19:14.166 --> 00:19:15.046 A:middle
available -- I wanted to say

00:19:15.046 --> 00:19:16.076 A:middle
this today so that you're not

00:19:16.076 --> 00:19:18.586 A:middle
surprised, and now I have.

00:19:19.356 --> 00:19:21.636 A:middle
So at this point, we've seen

00:19:21.636 --> 00:19:23.236 A:middle
many examples for how these

00:19:23.336 --> 00:19:25.546 A:middle
type-safe key paths satisfy our

00:19:25.546 --> 00:19:28.116 A:middle
goals for fast, type-safe and

00:19:28.116 --> 00:19:29.676 A:middle
expressive property traversal.

00:19:30.276 --> 00:19:31.956 A:middle
I'm going to change gears a

00:19:31.956 --> 00:19:33.176 A:middle
little bit now, though, because

00:19:33.176 --> 00:19:34.036 A:middle
I want to talk about how these

00:19:34.036 --> 00:19:35.346 A:middle
key paths can be used to improve

00:19:35.346 --> 00:19:37.026 A:middle
existing APIs in Swift today.

00:19:37.746 --> 00:19:38.626 A:middle
Specifically, I want to talk

00:19:38.626 --> 00:19:39.846 A:middle
about how we applied them to key

00:19:39.846 --> 00:19:40.486 A:middle
value observing.

00:19:42.116 --> 00:19:44.496 A:middle
As you probably know, KVO is

00:19:44.496 --> 00:19:45.816 A:middle
Cocoa's way of allowing objects

00:19:45.816 --> 00:19:47.566 A:middle
to establish relationships to be

00:19:47.566 --> 00:19:48.696 A:middle
notified about changes in their

00:19:48.696 --> 00:19:49.026 A:middle
state.

00:19:49.626 --> 00:19:50.966 A:middle
And if you've tried to use KVO

00:19:50.966 --> 00:19:53.176 A:middle
in Swift up to now, you probably

00:19:53.176 --> 00:19:55.226 A:middle
know that it leaves a little bit

00:19:55.226 --> 00:19:56.056 A:middle
to be desired.

00:19:58.596 --> 00:20:00.216 A:middle
Let's suppose we have a

00:20:00.216 --> 00:20:00.876 A:middle
reference--

00:20:01.016 --> 00:20:02.636 A:middle
[ Applause ]

00:20:02.636 --> 00:20:03.226 A:middle
Don't clap yet.

00:20:03.226 --> 00:20:05.726 A:middle
Clap in a minute.

00:20:05.726 --> 00:20:06.536 A:middle
[laughs] Let's suppose we have a

00:20:06.536 --> 00:20:07.726 A:middle
reference to an Objective-C

00:20:07.726 --> 00:20:09.086 A:middle
value -- say the little kid,

00:20:09.086 --> 00:20:10.936 A:middle
Mia, from earlier -- and we

00:20:10.936 --> 00:20:12.106 A:middle
really care about when this

00:20:12.106 --> 00:20:13.196 A:middle
kid's age changes.

00:20:14.446 --> 00:20:15.396 A:middle
We think that forming an

00:20:15.396 --> 00:20:17.096 A:middle
observation should simple, look

00:20:17.096 --> 00:20:18.236 A:middle
as simple as this.

00:20:18.346 --> 00:20:18.766 A:middle
Now clap. [laughs]

00:20:20.516 --> 00:20:24.606 A:middle
[ Applause ]

00:20:25.106 --> 00:20:26.266 A:middle
So I want to call out some

00:20:26.306 --> 00:20:27.346 A:middle
details about this form.

00:20:27.786 --> 00:20:29.546 A:middle
We are forming our observation

00:20:29.546 --> 00:20:31.856 A:middle
directly on the value type using

00:20:31.856 --> 00:20:33.856 A:middle
our new type-safe key paths.

00:20:34.056 --> 00:20:35.406 A:middle
What we get back is an

00:20:35.406 --> 00:20:37.016 A:middle
observation token similar to our

00:20:37.016 --> 00:20:38.076 A:middle
Notification Center APIs.

00:20:38.076 --> 00:20:39.856 A:middle
And this observation token is

00:20:39.856 --> 00:20:40.876 A:middle
doing two things for us.

00:20:41.036 --> 00:20:42.826 A:middle
One, it's saving us from having

00:20:42.826 --> 00:20:44.906 A:middle
to deal with unsafe raw pointers

00:20:44.906 --> 00:20:46.136 A:middle
with context to uniquely

00:20:46.136 --> 00:20:47.686 A:middle
identify our observation.

00:20:47.986 --> 00:20:49.526 A:middle
Now, our observation is directly

00:20:49.526 --> 00:20:50.976 A:middle
tied to our, the observation

00:20:50.976 --> 00:20:51.436 A:middle
that we get back.

00:20:52.126 --> 00:20:53.506 A:middle
Two, it's managing the life

00:20:53.506 --> 00:20:54.716 A:middle
[inaudible] of our observation.

00:20:55.006 --> 00:20:56.846 A:middle
And so if I, if -- well, in this

00:20:56.846 --> 00:20:57.736 A:middle
case, I can't set it to nil --

00:20:57.736 --> 00:20:58.786 A:middle
but if I were to set it to nil,

00:20:58.906 --> 00:20:59.996 A:middle
the observation would be toward

00:21:00.746 --> 00:21:01.866 A:middle
now [phonetic], which is a vast

00:21:01.866 --> 00:21:03.096 A:middle
improvement over getting

00:21:03.096 --> 00:21:04.506 A:middle
exceptions and having your app

00:21:04.626 --> 00:21:05.396 A:middle
crash when you forget to

00:21:05.396 --> 00:21:06.576 A:middle
unregister an observation.

00:21:07.736 --> 00:21:09.376 A:middle
Finally -- and this is perhaps

00:21:09.406 --> 00:21:10.886 A:middle
the nicest part -- you now

00:21:10.956 --> 00:21:13.056 A:middle
handle your observation's

00:21:13.056 --> 00:21:14.736 A:middle
reaction with a closure as

00:21:15.016 --> 00:21:16.996 A:middle
opposed to nested if statements

00:21:16.996 --> 00:21:18.066 A:middle
looking at and comparing

00:21:18.066 --> 00:21:18.606 A:middle
strings.

00:21:19.186 --> 00:21:19.836 A:middle
Let's take a look at the

00:21:19.836 --> 00:21:20.876 A:middle
parameters to this closure a

00:21:20.876 --> 00:21:21.496 A:middle
little bit more.

00:21:22.786 --> 00:21:24.006 A:middle
It has two parameters.

00:21:24.006 --> 00:21:25.526 A:middle
The first is the observed object

00:21:25.526 --> 00:21:25.986 A:middle
itself.

00:21:26.256 --> 00:21:27.626 A:middle
This is the same reference, Mia,

00:21:27.726 --> 00:21:29.506 A:middle
but we provide it as a parameter

00:21:29.816 --> 00:21:32.516 A:middle
to help you avoid accidentally

00:21:32.516 --> 00:21:33.726 A:middle
creating retain cycles.

00:21:34.906 --> 00:21:37.236 A:middle
Second, parameter is a change

00:21:37.476 --> 00:21:39.036 A:middle
object, and this is very similar

00:21:39.036 --> 00:21:40.756 A:middle
to the existing KVO API, except

00:21:40.756 --> 00:21:41.856 A:middle
you, if you've used, if you're

00:21:41.856 --> 00:21:43.066 A:middle
familiar with that API, you know

00:21:43.066 --> 00:21:44.096 A:middle
that that's a loosely type

00:21:44.096 --> 00:21:45.106 A:middle
dictionary, and here we're

00:21:45.106 --> 00:21:46.076 A:middle
actually providing a strongly

00:21:46.076 --> 00:21:46.686 A:middle
typed struct.

00:21:46.906 --> 00:21:48.066 A:middle
So we know observed is a kid

00:21:48.066 --> 00:21:49.126 A:middle
because of the key path and we

00:21:49.126 --> 00:21:50.476 A:middle
know that the age that's

00:21:50.476 --> 00:21:51.736 A:middle
changing is a double because of

00:21:51.736 --> 00:21:52.256 A:middle
the key path.

00:21:52.626 --> 00:21:53.476 A:middle
And now, I want to go ahead and

00:21:53.476 --> 00:21:54.136 A:middle
make this real.

00:21:54.276 --> 00:21:55.386 A:middle
So we'll do an example.

00:21:55.386 --> 00:21:56.596 A:middle
Let's suppose we have a

00:21:56.596 --> 00:21:57.736 A:middle
controller that cares about when

00:21:57.736 --> 00:21:58.586 A:middle
our kids get older.

00:21:58.706 --> 00:21:59.996 A:middle
It's the KindergartenController,

00:22:00.366 --> 00:22:01.506 A:middle
and it has a single key value

00:22:01.506 --> 00:22:03.036 A:middle
observable property, its

00:22:03.396 --> 00:22:04.516 A:middle
representedKid.

00:22:04.666 --> 00:22:05.486 A:middle
And we're going to form an

00:22:05.486 --> 00:22:06.936 A:middle
observation, so let's go ahead

00:22:06.936 --> 00:22:08.606 A:middle
and add an i var for our

00:22:08.606 --> 00:22:09.316 A:middle
observation.

00:22:09.446 --> 00:22:11.116 A:middle
And then, we'll form that

00:22:11.116 --> 00:22:12.796 A:middle
observation right now to our

00:22:12.796 --> 00:22:14.236 A:middle
controller's representedKid's

00:22:14.296 --> 00:22:15.406 A:middle
age, and we'll hold onto that in

00:22:15.406 --> 00:22:15.906 A:middle
the i var.

00:22:16.656 --> 00:22:18.206 A:middle
And we'll add our super-secret

00:22:18.206 --> 00:22:18.926 A:middle
business logic.

00:22:19.246 --> 00:22:20.156 A:middle
And if you're looking at this

00:22:20.156 --> 00:22:21.706 A:middle
and thinking that it's wrong, I

00:22:21.706 --> 00:22:22.596 A:middle
assure you that once you're

00:22:22.596 --> 00:22:23.616 A:middle
ready for kindergarten, you're

00:22:23.616 --> 00:22:24.666 A:middle
always ready for kindergarten,

00:22:24.666 --> 00:22:25.606 A:middle
so it's actually correct.

00:22:26.146 --> 00:22:27.466 A:middle
And that's it.

00:22:27.646 --> 00:22:30.176 A:middle
That's the entire declaration of

00:22:30.176 --> 00:22:30.806 A:middle
our controller.

00:22:31.856 --> 00:22:33.416 A:middle
There is no need for a dnit

00:22:33.416 --> 00:22:34.526 A:middle
[phonetic] where I throw away or

00:22:34.526 --> 00:22:36.016 A:middle
tear down my observation because

00:22:36.016 --> 00:22:36.986 A:middle
it's tied to the life

00:22:36.986 --> 00:22:37.876 A:middle
[inaudible] of that observation

00:22:37.876 --> 00:22:38.156 A:middle
token.

00:22:38.156 --> 00:22:39.266 A:middle
And so when the controller goes

00:22:39.266 --> 00:22:40.686 A:middle
away, the observation token will

00:22:40.686 --> 00:22:42.996 A:middle
go away, and it fits on the

00:22:42.996 --> 00:22:43.346 A:middle
slide.

00:22:43.926 --> 00:22:46.716 A:middle
So let's go ahead and create our

00:22:46.716 --> 00:22:47.216 A:middle
controller.

00:22:48.806 --> 00:22:50.596 A:middle
And here we'll point to Mia, and

00:22:50.596 --> 00:22:51.466 A:middle
we'll have Mia blow out her

00:22:51.466 --> 00:22:52.516 A:middle
candles with our function that

00:22:52.516 --> 00:22:53.326 A:middle
we defined earlier.

00:22:53.676 --> 00:22:54.696 A:middle
And we'll finally see through

00:22:54.696 --> 00:22:55.936 A:middle
the power of these new type-safe

00:22:55.936 --> 00:22:57.196 A:middle
key paths our little girl grow

00:22:57.196 --> 00:22:57.876 A:middle
one year older.

00:22:58.306 --> 00:23:01.396 A:middle
Now, at this point, I've shown

00:23:01.396 --> 00:23:02.316 A:middle
everything that I'm planning on

00:23:02.316 --> 00:23:03.896 A:middle
showing, but I do want to circle

00:23:03.896 --> 00:23:05.096 A:middle
back and talk about string key

00:23:05.096 --> 00:23:06.196 A:middle
paths one more time.

00:23:06.276 --> 00:23:08.756 A:middle
These guys are going to continue

00:23:08.756 --> 00:23:10.016 A:middle
to exist, and they're going to

00:23:10.016 --> 00:23:12.106 A:middle
remain useful for legacy APIs

00:23:13.036 --> 00:23:14.356 A:middle
that, you know, insist on using

00:23:14.356 --> 00:23:14.906 A:middle
strings.

00:23:15.996 --> 00:23:17.686 A:middle
However, starting in Swift 4,

00:23:19.006 --> 00:23:20.506 A:middle
you now have access to these new

00:23:20.506 --> 00:23:22.436 A:middle
type-safe performant key paths,

00:23:23.006 --> 00:23:23.946 A:middle
and we brought them to the

00:23:23.946 --> 00:23:25.156 A:middle
language because we feel that

00:23:25.156 --> 00:23:26.196 A:middle
they are so incredibly

00:23:26.196 --> 00:23:26.646 A:middle
important.

00:23:26.646 --> 00:23:28.456 A:middle
And they're only going to grow

00:23:28.456 --> 00:23:29.916 A:middle
to be more important over time.

00:23:30.466 --> 00:23:32.796 A:middle
And with that, I'd like to bring

00:23:32.796 --> 00:23:34.046 A:middle
Tony back on stage to discuss

00:23:34.046 --> 00:23:34.986 A:middle
another important language

00:23:34.986 --> 00:23:35.776 A:middle
feature that we're bringing to

00:23:35.776 --> 00:23:36.416 A:middle
Swift this year.

00:23:36.586 --> 00:23:36.916 A:middle
Thank you.

00:23:38.516 --> 00:23:42.686 A:middle
[ Applause ]

00:23:43.186 --> 00:23:43.466 A:middle
&gt;&gt; All right.

00:23:43.466 --> 00:23:43.956 A:middle
Thanks, Michael.

00:23:44.446 --> 00:23:45.806 A:middle
So next up, we're going to talk

00:23:45.806 --> 00:23:47.486 A:middle
about encoding and decoding.

00:23:48.836 --> 00:23:50.726 A:middle
So broadly speaking, encoding

00:23:50.726 --> 00:23:51.906 A:middle
and decoding is about the

00:23:51.906 --> 00:23:53.776 A:middle
conversion between your native

00:23:53.776 --> 00:23:55.596 A:middle
and custom Swift data structures

00:23:56.016 --> 00:23:58.216 A:middle
and archived formats, especially

00:23:58.216 --> 00:23:58.776 A:middle
JSON.

00:23:59.656 --> 00:24:00.646 A:middle
Now, many of you have told us

00:24:00.646 --> 00:24:02.266 A:middle
about the challenge of a

00:24:02.266 --> 00:24:03.946 A:middle
mismatch that is between the

00:24:03.946 --> 00:24:05.516 A:middle
strongly typed language of Swift

00:24:06.146 --> 00:24:08.476 A:middle
and loosely typed archive data

00:24:08.476 --> 00:24:09.566 A:middle
formats like JSON.

00:24:10.606 --> 00:24:11.856 A:middle
We believe that the answer to

00:24:11.856 --> 00:24:13.666 A:middle
this challenge is something that

00:24:13.666 --> 00:24:15.106 A:middle
starts with the language itself

00:24:15.626 --> 00:24:16.776 A:middle
and also takes advantage of the

00:24:16.776 --> 00:24:18.876 A:middle
compiler, the standard library,

00:24:19.006 --> 00:24:20.736 A:middle
and Foundation to make

00:24:20.736 --> 00:24:22.576 A:middle
interaction with JSON simple,

00:24:22.926 --> 00:24:24.326 A:middle
but also to provide you the

00:24:24.326 --> 00:24:25.596 A:middle
opportunity for powerful

00:24:25.596 --> 00:24:26.276 A:middle
customization.

00:24:27.276 --> 00:24:28.746 A:middle
So let's get started by looking

00:24:28.746 --> 00:24:29.436 A:middle
at an example.

00:24:29.536 --> 00:24:31.946 A:middle
Here is some JSON from one of

00:24:31.946 --> 00:24:33.106 A:middle
our favorite sites, GitHub.

00:24:33.836 --> 00:24:35.296 A:middle
This is the result of asking for

00:24:35.296 --> 00:24:37.006 A:middle
information about a commit made

00:24:37.006 --> 00:24:38.996 A:middle
to a repository, and it's pretty

00:24:38.996 --> 00:24:39.696 A:middle
standard JSON.

00:24:40.116 --> 00:24:41.936 A:middle
It's a JSON object or maybe what

00:24:41.936 --> 00:24:42.946 A:middle
we would call a dictionary.

00:24:43.436 --> 00:24:44.666 A:middle
It supports and arbitrary number

00:24:44.666 --> 00:24:46.136 A:middle
of key value pairs -- in this

00:24:46.136 --> 00:24:48.046 A:middle
case, name, which is a string;

00:24:48.746 --> 00:24:50.196 A:middle
email, which is also a string;

00:24:50.196 --> 00:24:52.316 A:middle
and date, which is a string.

00:24:52.756 --> 00:24:53.946 A:middle
And the reason is because, of

00:24:53.946 --> 00:24:55.316 A:middle
course, JSON has no native type

00:24:55.316 --> 00:24:55.866 A:middle
for dates.

00:24:56.346 --> 00:24:57.896 A:middle
But there are many conventions

00:24:57.896 --> 00:24:59.666 A:middle
by which dates are encoded in a

00:24:59.666 --> 00:25:01.986 A:middle
way into JSON, and this one

00:25:01.986 --> 00:25:03.566 A:middle
appears to be iso8601.

00:25:04.826 --> 00:25:06.436 A:middle
If we were to represent this

00:25:06.436 --> 00:25:08.446 A:middle
JSON in Swift, it would look

00:25:08.446 --> 00:25:09.406 A:middle
very different.

00:25:09.546 --> 00:25:11.846 A:middle
For example, we would make a

00:25:11.846 --> 00:25:13.756 A:middle
strong type for it, a struct

00:25:13.756 --> 00:25:14.786 A:middle
perhaps called Author.

00:25:15.936 --> 00:25:17.096 A:middle
This struct would have exactly

00:25:17.096 --> 00:25:18.876 A:middle
three properties -- name and

00:25:18.876 --> 00:25:20.446 A:middle
email, which are strings still;

00:25:20.946 --> 00:25:22.266 A:middle
but date, as you can see here,

00:25:22.366 --> 00:25:24.366 A:middle
is using Foundation's date type.

00:25:24.366 --> 00:25:26.516 A:middle
And the reason that's important

00:25:26.516 --> 00:25:27.876 A:middle
is because, as you interact with

00:25:27.876 --> 00:25:29.466 A:middle
the rest of the Cocoa SDK and

00:25:29.466 --> 00:25:31.416 A:middle
other APIs, you'll find that

00:25:31.416 --> 00:25:34.026 A:middle
date is the kind of type used to

00:25:34.026 --> 00:25:35.446 A:middle
represent a point in time.

00:25:36.266 --> 00:25:37.436 A:middle
And so this is where we've

00:25:37.436 --> 00:25:38.576 A:middle
reached that challenge, right.

00:25:39.406 --> 00:25:41.306 A:middle
How do we convert between that

00:25:41.306 --> 00:25:43.796 A:middle
loosely typed JSON on top and

00:25:43.796 --> 00:25:45.336 A:middle
the strong Swift type on the

00:25:45.336 --> 00:25:45.666 A:middle
bottom?

00:25:46.586 --> 00:25:48.236 A:middle
Well, we think it should be as

00:25:48.236 --> 00:25:49.046 A:middle
easy as this.

00:25:49.226 --> 00:25:51.196 A:middle
Simply adopt a protocol on your

00:25:51.196 --> 00:25:53.206 A:middle
struct and let the compiler, the

00:25:53.206 --> 00:25:54.886 A:middle
standard library, and Foundation

00:25:55.246 --> 00:25:56.936 A:middle
do the vast majority of the work

00:25:56.936 --> 00:25:57.256 A:middle
for you.

00:25:57.346 --> 00:25:59.216 A:middle
Thank you.

00:26:00.516 --> 00:26:03.706 A:middle
[ Applause ]

00:26:04.206 --> 00:26:05.436 A:middle
So let's turn this slide into

00:26:05.436 --> 00:26:06.056 A:middle
some real code.

00:26:06.836 --> 00:26:07.866 A:middle
First, I'm going to turn that

00:26:07.866 --> 00:26:09.306 A:middle
JSON into a string using Swift

00:26:09.306 --> 00:26:10.836 A:middle
4's cool, new string literal

00:26:10.836 --> 00:26:12.696 A:middle
syntax, the triple quote, and

00:26:12.696 --> 00:26:13.876 A:middle
then turn that string into data

00:26:14.126 --> 00:26:15.436 A:middle
using UTF-8 encoding, which is

00:26:15.436 --> 00:26:16.416 A:middle
pretty common for JSON.

00:26:16.896 --> 00:26:18.076 A:middle
Struct Author remains the same,

00:26:18.286 --> 00:26:18.776 A:middle
of course.

00:26:19.366 --> 00:26:21.296 A:middle
Next, we create a decoder.

00:26:21.296 --> 00:26:22.496 A:middle
This is what is actually doing

00:26:22.496 --> 00:26:24.696 A:middle
the conversion between the JSON

00:26:24.696 --> 00:26:25.706 A:middle
and our Swift structure.

00:26:26.256 --> 00:26:29.106 A:middle
We tell the decoder about that

00:26:29.106 --> 00:26:31.256 A:middle
convention, the iso8601 date.

00:26:31.256 --> 00:26:32.396 A:middle
And we'll talk more about this

00:26:32.396 --> 00:26:32.656 A:middle
later.

00:26:33.526 --> 00:26:35.146 A:middle
And finally, we ask the decoder

00:26:35.146 --> 00:26:36.706 A:middle
to decode an author.

00:26:37.086 --> 00:26:38.346 A:middle
The result is not an any.

00:26:38.486 --> 00:26:39.586 A:middle
It's not a dictionary.

00:26:39.586 --> 00:26:40.276 A:middle
You don't have to fish through

00:26:40.276 --> 00:26:42.136 A:middle
strings or check for keys.

00:26:42.546 --> 00:26:43.736 A:middle
It's already the type that you

00:26:43.736 --> 00:26:45.396 A:middle
care about using, in this case.

00:26:46.806 --> 00:26:47.916 A:middle
So that was pretty easy.

00:26:48.196 --> 00:26:49.216 A:middle
Let's bump up the difficulty

00:26:49.216 --> 00:26:50.116 A:middle
level one notch.

00:26:50.496 --> 00:26:52.046 A:middle
This JSON is actually part of a

00:26:52.046 --> 00:26:53.856 A:middle
larger set of JSON that comes as

00:26:53.856 --> 00:26:55.026 A:middle
the result of this request,

00:26:55.346 --> 00:26:57.516 A:middle
which includes things like URLs,

00:26:57.516 --> 00:26:58.836 A:middle
and additional strings, and

00:26:58.836 --> 00:26:59.716 A:middle
integer values.

00:27:00.436 --> 00:27:02.926 A:middle
So in Swift, we can just follow

00:27:02.926 --> 00:27:03.206 A:middle
suit.

00:27:03.396 --> 00:27:04.846 A:middle
So I'm going to nest my struct

00:27:04.846 --> 00:27:06.346 A:middle
Author in a new struct called

00:27:06.346 --> 00:27:08.076 A:middle
Commit, which is also codable.

00:27:08.706 --> 00:27:09.826 A:middle
There you can see that I'm able

00:27:09.826 --> 00:27:12.096 A:middle
to use Foundation's URL type and

00:27:12.096 --> 00:27:13.106 A:middle
our struct Author.

00:27:13.236 --> 00:27:14.016 A:middle
So you can see how we can

00:27:14.016 --> 00:27:15.566 A:middle
recursively descend into types,

00:27:15.566 --> 00:27:16.766 A:middle
if they conform with codable, to

00:27:16.766 --> 00:27:17.816 A:middle
decode them as well.

00:27:18.586 --> 00:27:19.956 A:middle
The string, which is, message,

00:27:19.956 --> 00:27:21.456 A:middle
which is a string, and our

00:27:21.456 --> 00:27:22.456 A:middle
comment count property.

00:27:22.456 --> 00:27:25.786 A:middle
And to decode this, again, one

00:27:25.786 --> 00:27:26.236 A:middle
line of code.

00:27:26.236 --> 00:27:27.176 A:middle
We're going to decode a commit

00:27:27.216 --> 00:27:27.706 A:middle
this time.

00:27:27.866 --> 00:27:30.146 A:middle
And the result: Our strong Swift

00:27:30.146 --> 00:27:31.586 A:middle
type, which lets us use the

00:27:31.586 --> 00:27:32.846 A:middle
Swift language features that we

00:27:32.846 --> 00:27:34.356 A:middle
know and love to get at the

00:27:34.356 --> 00:27:35.636 A:middle
values that we care about in the

00:27:35.636 --> 00:27:36.096 A:middle
archive.

00:27:36.456 --> 00:27:37.416 A:middle
In this case, it's simply

00:27:37.416 --> 00:27:38.366 A:middle
property access.

00:27:38.836 --> 00:27:40.856 A:middle
So let's look at what's going on

00:27:40.856 --> 00:27:41.026 A:middle
here.

00:27:41.636 --> 00:27:43.236 A:middle
First, the codable protocol,

00:27:43.236 --> 00:27:44.336 A:middle
which is actually not one

00:27:44.336 --> 00:27:45.136 A:middle
protocol, but two.

00:27:45.616 --> 00:27:47.076 A:middle
The first is called encodable

00:27:47.526 --> 00:27:49.466 A:middle
and has one function, encode to

00:27:49.466 --> 00:27:49.936 A:middle
encoder.

00:27:50.656 --> 00:27:52.806 A:middle
The purpose of that function is

00:27:52.956 --> 00:27:54.086 A:middle
to allow the type to tell the

00:27:54.086 --> 00:27:55.916 A:middle
encoder all of the information

00:27:55.916 --> 00:27:57.076 A:middle
that it needs in order to

00:27:57.076 --> 00:27:58.636 A:middle
recreate itself at a later time.

00:27:59.566 --> 00:28:01.106 A:middle
The corresponding protocol,

00:28:01.106 --> 00:28:03.066 A:middle
decodable, has one initializer.

00:28:03.716 --> 00:28:04.976 A:middle
The purpose of the initializer

00:28:05.286 --> 00:28:06.376 A:middle
is to allow the type to get the

00:28:06.376 --> 00:28:07.676 A:middle
values that it needs from the

00:28:07.676 --> 00:28:10.026 A:middle
decoder and then use those to

00:28:10.026 --> 00:28:11.616 A:middle
create a fully initialized

00:28:11.616 --> 00:28:13.686 A:middle
instance of itself that is ready

00:28:13.686 --> 00:28:14.226 A:middle
for use.

00:28:14.756 --> 00:28:17.616 A:middle
The primary design point of

00:28:17.616 --> 00:28:20.486 A:middle
these APIs is to use a Swift

00:28:20.486 --> 00:28:21.846 A:middle
behavior that you may already be

00:28:21.846 --> 00:28:23.276 A:middle
familiar with, and that's called

00:28:23.276 --> 00:28:24.176 A:middle
protocol extensions.

00:28:24.876 --> 00:28:26.746 A:middle
So in Swift, protocols can not

00:28:26.746 --> 00:28:28.966 A:middle
only define an interface, but

00:28:28.966 --> 00:28:31.626 A:middle
via an extension, they can

00:28:31.626 --> 00:28:33.346 A:middle
provide a default implementation

00:28:33.496 --> 00:28:34.876 A:middle
for that interface.

00:28:36.106 --> 00:28:37.426 A:middle
And they let you write your own

00:28:37.426 --> 00:28:39.026 A:middle
implementation for either part

00:28:39.026 --> 00:28:40.746 A:middle
or whole of that protocol to

00:28:40.746 --> 00:28:41.956 A:middle
customize the behavior.

00:28:42.746 --> 00:28:44.316 A:middle
So let's go back to our commit

00:28:44.316 --> 00:28:45.216 A:middle
to see how this works.

00:28:46.226 --> 00:28:47.216 A:middle
When I adopted the codable

00:28:47.216 --> 00:28:49.016 A:middle
protocol, the compiler actually

00:28:49.016 --> 00:28:50.796 A:middle
generated an implementation of

00:28:50.796 --> 00:28:52.356 A:middle
encode to encoder and initfrom

00:28:52.356 --> 00:28:54.106 A:middle
decoder for us completely for

00:28:54.106 --> 00:28:54.376 A:middle
free.

00:28:54.476 --> 00:28:56.426 A:middle
And in this case, I don't need

00:28:56.426 --> 00:28:57.556 A:middle
to customize anything about

00:28:57.556 --> 00:28:59.286 A:middle
them, so I can just omit them

00:28:59.286 --> 00:29:00.386 A:middle
completely from my type.

00:29:01.866 --> 00:29:02.896 A:middle
There is one thing I do want to

00:29:02.896 --> 00:29:04.056 A:middle
customize about this type,

00:29:04.106 --> 00:29:05.856 A:middle
though, and that is the name of

00:29:05.856 --> 00:29:06.476 A:middle
this property.

00:29:06.856 --> 00:29:08.176 A:middle
Now, you may notice that it is

00:29:08.176 --> 00:29:09.546 A:middle
using snake case, which is

00:29:09.546 --> 00:29:11.116 A:middle
pretty common in JSON, but it

00:29:11.116 --> 00:29:12.576 A:middle
doesn't match Swift's naming

00:29:12.576 --> 00:29:13.196 A:middle
conventions.

00:29:13.656 --> 00:29:14.846 A:middle
So let me show you how we're

00:29:14.846 --> 00:29:15.456 A:middle
going to fix that.

00:29:15.936 --> 00:29:17.336 A:middle
First, there's one more thing

00:29:17.336 --> 00:29:18.546 A:middle
that the compiler generated for

00:29:18.546 --> 00:29:20.226 A:middle
us, and that is this private

00:29:20.226 --> 00:29:21.646 A:middle
enum called CodingKeys.

00:29:23.176 --> 00:29:24.846 A:middle
This enum is backed by a string

00:29:25.326 --> 00:29:27.266 A:middle
and adopts a CodingKey protocol,

00:29:27.266 --> 00:29:28.276 A:middle
which, again, we'll talk more

00:29:28.276 --> 00:29:28.806 A:middle
about later.

00:29:29.266 --> 00:29:30.466 A:middle
But what's interesting to note

00:29:30.466 --> 00:29:32.136 A:middle
here is that this enum has four

00:29:32.136 --> 00:29:33.796 A:middle
case statements that match the

00:29:33.796 --> 00:29:35.676 A:middle
names of my four properties.

00:29:36.246 --> 00:29:37.666 A:middle
And so in order to customize the

00:29:37.666 --> 00:29:39.706 A:middle
name of my property, I just need

00:29:39.706 --> 00:29:41.186 A:middle
to customize the name of my case

00:29:41.186 --> 00:29:41.616 A:middle
statement.

00:29:42.056 --> 00:29:43.526 A:middle
So to do that, I'm going to

00:29:43.526 --> 00:29:45.456 A:middle
change this comment count snake

00:29:45.456 --> 00:29:47.356 A:middle
case to camel case.

00:29:47.986 --> 00:29:49.996 A:middle
But as you can see, I remain

00:29:50.216 --> 00:29:51.866 A:middle
compatible with the JSON that

00:29:51.866 --> 00:29:53.126 A:middle
we're reading by setting the

00:29:53.126 --> 00:29:55.096 A:middle
string value of that case to be

00:29:55.376 --> 00:29:56.846 A:middle
the value we expect to find in

00:29:56.846 --> 00:29:57.406 A:middle
our archive.

00:29:58.326 --> 00:29:59.506 A:middle
Now, if that's all the

00:29:59.506 --> 00:30:00.706 A:middle
customization that we needed to

00:30:00.706 --> 00:30:04.006 A:middle
do, then we're done.

00:30:04.086 --> 00:30:05.506 A:middle
Maybe you can stop watching now

00:30:05.506 --> 00:30:08.156 A:middle
and leave, but by the end of the

00:30:08.156 --> 00:30:09.586 A:middle
talk, I do want to show you how

00:30:09.586 --> 00:30:11.326 A:middle
we can do even more kinds of

00:30:11.326 --> 00:30:12.786 A:middle
customizations on this commit.

00:30:13.056 --> 00:30:14.426 A:middle
For now, I'd like to hand it

00:30:14.426 --> 00:30:16.186 A:middle
over to my colleague Itai to

00:30:16.186 --> 00:30:17.456 A:middle
show us a demo of this stuff in

00:30:17.456 --> 00:30:17.796 A:middle
action.

00:30:19.516 --> 00:30:25.856 A:middle
[ Applause ]

00:30:26.356 --> 00:30:28.556 A:middle
&gt;&gt; Thanks, Tony.

00:30:29.726 --> 00:30:31.796 A:middle
So Tony showed you just how easy

00:30:31.796 --> 00:30:32.986 A:middle
it is to adopt codable in your

00:30:32.986 --> 00:30:34.776 A:middle
types, but let's dive in to see

00:30:34.776 --> 00:30:35.936 A:middle
what this might look like for

00:30:35.936 --> 00:30:37.226 A:middle
many of your apps in practice.

00:30:37.756 --> 00:30:39.656 A:middle
I've got a small app here that

00:30:39.656 --> 00:30:40.756 A:middle
I've been prototyping lately.

00:30:41.266 --> 00:30:42.306 A:middle
Because I'm such a big fan of

00:30:42.306 --> 00:30:43.646 A:middle
Swift, I like to watch for

00:30:43.646 --> 00:30:45.156 A:middle
interesting git commits as they

00:30:45.156 --> 00:30:46.736 A:middle
come in on Swift's GitHub repo.

00:30:47.296 --> 00:30:48.836 A:middle
I've written a small app here

00:30:49.036 --> 00:30:50.876 A:middle
that talks to GitHub's JSON REST

00:30:50.876 --> 00:30:52.836 A:middle
API to parse these commits and

00:30:52.836 --> 00:30:53.856 A:middle
show me them in the table view.

00:30:54.946 --> 00:30:55.976 A:middle
So let's take a quick look at

00:30:55.976 --> 00:30:57.396 A:middle
how easy it was to put this app

00:30:57.396 --> 00:30:58.856 A:middle
together using the new codable

00:30:59.016 --> 00:30:59.316 A:middle
APIs.

00:30:59.916 --> 00:31:02.446 A:middle
If we switch to Xcode, you'll

00:31:02.446 --> 00:31:03.646 A:middle
notice some of the same models

00:31:03.646 --> 00:31:05.246 A:middle
that Tony had up on his slide

00:31:05.506 --> 00:31:06.896 A:middle
expanded a little bit.

00:31:07.216 --> 00:31:09.116 A:middle
We've got the same commit info,

00:31:09.206 --> 00:31:11.456 A:middle
author info, and we've gone

00:31:11.456 --> 00:31:12.276 A:middle
ahead and done the same

00:31:12.276 --> 00:31:12.636 A:middle
renaming.

00:31:13.876 --> 00:31:15.216 A:middle
On the right is the JSON spec

00:31:15.336 --> 00:31:16.786 A:middle
that GitHub provides, but with

00:31:16.786 --> 00:31:17.676 A:middle
some of the irrelevant parts

00:31:17.676 --> 00:31:18.156 A:middle
snipped out.

00:31:18.156 --> 00:31:19.506 A:middle
And if you'll notice on the

00:31:19.506 --> 00:31:20.986 A:middle
bottom right, we've got some

00:31:20.986 --> 00:31:22.526 A:middle
info in the JSON spec that we're

00:31:22.526 --> 00:31:23.646 A:middle
not currently decoding.

00:31:24.526 --> 00:31:25.666 A:middle
That's actually OK because it'll

00:31:25.666 --> 00:31:26.926 A:middle
get ignored by default, and so

00:31:26.926 --> 00:31:27.886 A:middle
we can come back to this later.

00:31:28.436 --> 00:31:30.196 A:middle
So let's hide this JSON spec and

00:31:30.256 --> 00:31:31.436 A:middle
go a little bit further down

00:31:31.436 --> 00:31:32.746 A:middle
into our file to see how we can

00:31:32.746 --> 00:31:33.946 A:middle
use these models in practice.

00:31:34.736 --> 00:31:35.926 A:middle
So in here, we've got our

00:31:35.926 --> 00:31:37.606 A:middle
CommitsViewController, and this

00:31:37.606 --> 00:31:38.586 A:middle
is the view controller that

00:31:38.586 --> 00:31:40.146 A:middle
actually displays these commits

00:31:40.196 --> 00:31:40.866 A:middle
in our table view.

00:31:41.426 --> 00:31:42.636 A:middle
And so the view controller here

00:31:42.636 --> 00:31:44.506 A:middle
has our table view, along with

00:31:44.506 --> 00:31:45.556 A:middle
an array of these commits.

00:31:45.906 --> 00:31:47.126 A:middle
And note here that this is an

00:31:47.126 --> 00:31:49.146 A:middle
array of our type.

00:31:49.516 --> 00:31:50.746 A:middle
It's not an array of any or

00:31:50.746 --> 00:31:51.346 A:middle
anything similar.

00:31:52.796 --> 00:31:54.846 A:middle
When we're going to go and

00:31:54.846 --> 00:31:56.136 A:middle
display this data, we can fetch

00:31:56.136 --> 00:31:57.716 A:middle
the data from GitHub, and then

00:31:57.716 --> 00:31:59.316 A:middle
using a JSON decoder, just like

00:31:59.316 --> 00:32:01.146 A:middle
Tony showed you, we can go ahead

00:32:01.146 --> 00:32:02.606 A:middle
and request to decode an array

00:32:02.606 --> 00:32:03.926 A:middle
of these commits into our type.

00:32:05.286 --> 00:32:06.776 A:middle
Once that's done, we can reload

00:32:06.776 --> 00:32:07.876 A:middle
our table view and have that

00:32:07.876 --> 00:32:08.226 A:middle
display.

00:32:09.766 --> 00:32:11.366 A:middle
Now, if anything goes wrong, we

00:32:11.366 --> 00:32:13.186 A:middle
can catch that error and display

00:32:13.186 --> 00:32:14.456 A:middle
some localized information to

00:32:14.456 --> 00:32:15.606 A:middle
the user to tell them what went

00:32:15.606 --> 00:32:17.686 A:middle
wrong at a high level.

00:32:17.956 --> 00:32:19.096 A:middle
Now, this is how you load the

00:32:19.096 --> 00:32:20.146 A:middle
data into your app, but let's

00:32:20.146 --> 00:32:21.276 A:middle
take a look at how this hooks up

00:32:21.276 --> 00:32:21.626 A:middle
to our UI.

00:32:21.876 --> 00:32:23.356 A:middle
So a little bit further down in

00:32:23.356 --> 00:32:24.876 A:middle
the file here, I've got a helper

00:32:24.876 --> 00:32:26.556 A:middle
method that lets me set up table

00:32:26.556 --> 00:32:27.586 A:middle
view cells right before they're

00:32:27.586 --> 00:32:28.476 A:middle
displayed to the user.

00:32:28.896 --> 00:32:30.696 A:middle
So in here, to set up my custom

00:32:30.696 --> 00:32:32.246 A:middle
table view cell, I'm going to

00:32:32.246 --> 00:32:33.586 A:middle
pull out a commit from our array

00:32:33.586 --> 00:32:35.856 A:middle
of commits, and then using the

00:32:35.856 --> 00:32:37.516 A:middle
strongly typed properties on

00:32:37.516 --> 00:32:38.866 A:middle
that commit, we can hook it up

00:32:38.866 --> 00:32:39.266 A:middle
to our UI.

00:32:39.876 --> 00:32:40.946 A:middle
And note again that we're not

00:32:40.946 --> 00:32:42.216 A:middle
downcasting from any and we're

00:32:42.216 --> 00:32:43.406 A:middle
not peering through arrays or

00:32:43.406 --> 00:32:43.966 A:middle
dictionaries.

00:32:44.316 --> 00:32:45.626 A:middle
This is our type the way we

00:32:45.626 --> 00:32:47.076 A:middle
wrote it and how we want to use

00:32:47.076 --> 00:32:47.146 A:middle
it.

00:32:48.226 --> 00:32:49.676 A:middle
Now, that's all nice and good,

00:32:49.676 --> 00:32:50.826 A:middle
but let's go back into our app

00:32:50.826 --> 00:32:51.806 A:middle
and you'll take a look here and

00:32:51.806 --> 00:32:53.206 A:middle
notice that we've got some room

00:32:53.206 --> 00:32:54.526 A:middle
in the UI that I've left here

00:32:54.526 --> 00:32:56.096 A:middle
for hooking up the hash values

00:32:56.096 --> 00:32:56.996 A:middle
of each of these commits.

00:32:57.306 --> 00:32:58.356 A:middle
But it's not hooked up yet, so

00:32:58.446 --> 00:33:01.506 A:middle
let's go ahead and do that now.

00:33:02.166 --> 00:33:03.626 A:middle
If we go back to our models and

00:33:03.626 --> 00:33:05.736 A:middle
pop open the JSON spec again, we

00:33:05.736 --> 00:33:08.636 A:middle
can see that there's a hash

00:33:08.636 --> 00:33:10.226 A:middle
property in the JSON spec that

00:33:10.226 --> 00:33:11.256 A:middle
we haven't been requesting.

00:33:11.836 --> 00:33:12.876 A:middle
So let's go ahead and add that

00:33:12.876 --> 00:33:13.396 A:middle
to our type.

00:33:14.036 --> 00:33:15.826 A:middle
And then, if I go ahead and

00:33:15.826 --> 00:33:17.096 A:middle
build our project to use it,

00:33:17.636 --> 00:33:18.646 A:middle
you'll notice that I actually

00:33:18.646 --> 00:33:19.836 A:middle
got a build failure.

00:33:19.876 --> 00:33:21.356 A:middle
So let's explore why that

00:33:21.356 --> 00:33:21.816 A:middle
happens.

00:33:23.296 --> 00:33:24.606 A:middle
As part of this type, I've

00:33:24.606 --> 00:33:26.046 A:middle
created a custom CodingKeys

00:33:26.046 --> 00:33:26.356 A:middle
enum.

00:33:26.896 --> 00:33:28.246 A:middle
Now, the CodingKeys enum that

00:33:28.246 --> 00:33:29.766 A:middle
you put in your type is a really

00:33:29.766 --> 00:33:31.416 A:middle
powerful tool for controlling

00:33:31.416 --> 00:33:32.956 A:middle
what the compiler generates as

00:33:32.956 --> 00:33:34.836 A:middle
part of init from NNCode

00:33:34.866 --> 00:33:35.126 A:middle
[phonetic] 2.

00:33:36.016 --> 00:33:37.186 A:middle
In this case, I provided a

00:33:37.186 --> 00:33:39.246 A:middle
CodingKeys enum that renames my

00:33:39.296 --> 00:33:41.106 A:middle
info property to commit to match

00:33:41.106 --> 00:33:42.396 A:middle
what's in the JSON.

00:33:43.116 --> 00:33:44.456 A:middle
But in this case, the hash

00:33:44.526 --> 00:33:46.096 A:middle
property that I just added isn't

00:33:46.096 --> 00:33:47.206 A:middle
found in the CodingKeys.

00:33:47.886 --> 00:33:49.286 A:middle
Now, what the compiler will try

00:33:49.286 --> 00:33:50.846 A:middle
to do is if you purposefully

00:33:50.846 --> 00:33:52.406 A:middle
leave a property out of your

00:33:52.406 --> 00:33:53.906 A:middle
CodingKeys enum, it'll actually

00:33:53.906 --> 00:33:55.826 A:middle
omit it from your encoded and

00:33:55.826 --> 00:33:56.866 A:middle
decoded representation.

00:33:57.326 --> 00:33:58.546 A:middle
But what's happening here is

00:33:58.546 --> 00:34:00.146 A:middle
that because this hash property

00:34:00.146 --> 00:34:02.046 A:middle
doesn't have a default value, if

00:34:02.046 --> 00:34:03.356 A:middle
the compiler were to try and

00:34:03.356 --> 00:34:05.096 A:middle
generate an initializer for us,

00:34:05.436 --> 00:34:06.776 A:middle
there'd be no reasonable value

00:34:06.776 --> 00:34:08.076 A:middle
to initialize this property to,

00:34:08.496 --> 00:34:09.846 A:middle
and so the compiler refuses to

00:34:09.846 --> 00:34:10.846 A:middle
do it and we get our build

00:34:10.846 --> 00:34:11.806 A:middle
failure because our type

00:34:11.806 --> 00:34:13.416 A:middle
actually doesn't conform to

00:34:13.416 --> 00:34:13.896 A:middle
decodable.

00:34:14.856 --> 00:34:16.116 A:middle
Now, in this case, we actually

00:34:16.116 --> 00:34:17.136 A:middle
don't want to leave this hash

00:34:17.136 --> 00:34:18.416 A:middle
property out of our encoded

00:34:18.416 --> 00:34:19.156 A:middle
representation.

00:34:19.156 --> 00:34:20.016 A:middle
We do want to decode it.

00:34:20.346 --> 00:34:21.546 A:middle
So let's go ahead and mirror

00:34:21.546 --> 00:34:22.906 A:middle
that same property in our

00:34:22.906 --> 00:34:23.676 A:middle
CodingKeys enum.

00:34:25.036 --> 00:34:26.276 A:middle
Let's hide the JSON spec again

00:34:26.276 --> 00:34:27.766 A:middle
and go and hook up this property

00:34:27.976 --> 00:34:28.796 A:middle
directly to our UI.

00:34:29.536 --> 00:34:31.276 A:middle
So here in the cell setup method

00:34:31.276 --> 00:34:32.586 A:middle
that we have, we're going to add

00:34:32.586 --> 00:34:34.496 A:middle
another line of code that grabs

00:34:34.496 --> 00:34:35.846 A:middle
that hash, and here we're going

00:34:35.846 --> 00:34:36.766 A:middle
to shorten it up a bit so it

00:34:36.766 --> 00:34:37.816 A:middle
fits nicely in our UI.

00:34:37.816 --> 00:34:39.276 A:middle
And just like using everything

00:34:39.276 --> 00:34:40.456 A:middle
else, using the strongly typed

00:34:40.456 --> 00:34:41.636 A:middle
properties, we can hook it up to

00:34:41.636 --> 00:34:42.416 A:middle
our UI directly.

00:34:43.096 --> 00:34:44.196 A:middle
So let's go ahead and rerun our

00:34:44.466 --> 00:34:45.586 A:middle
app and take a look to make sure

00:34:45.586 --> 00:34:46.766 A:middle
that things hooked up correctly.

00:34:49.516 --> 00:34:51.596 A:middle
Here, now that we've rerun, we

00:34:51.596 --> 00:34:53.066 A:middle
can actually see that everything

00:34:53.066 --> 00:34:54.466 A:middle
is hooked up to our UI, and I'm

00:34:54.466 --> 00:34:55.686 A:middle
pretty happy because that took a

00:34:55.686 --> 00:34:57.366 A:middle
whole of four lines of code to

00:34:57.366 --> 00:34:58.566 A:middle
add to our app.

00:35:00.516 --> 00:35:06.186 A:middle
[ Applause ]

00:35:06.686 --> 00:35:07.956 A:middle
Now, going back to the code for

00:35:07.956 --> 00:35:09.046 A:middle
a moment, let's take a look at

00:35:09.046 --> 00:35:10.506 A:middle
what we can do when things go

00:35:10.506 --> 00:35:12.816 A:middle
wrong in our app.

00:35:13.116 --> 00:35:14.626 A:middle
So if we pop open the JSON spec

00:35:14.626 --> 00:35:16.126 A:middle
one more time, you might notice

00:35:16.126 --> 00:35:16.876 A:middle
that in the bottom right, we

00:35:17.106 --> 00:35:18.356 A:middle
have one final property that we

00:35:18.356 --> 00:35:19.766 A:middle
haven't been decoding, so let's

00:35:19.766 --> 00:35:20.936 A:middle
go ahead and try to do that now.

00:35:22.106 --> 00:35:23.126 A:middle
We're going to add a URL

00:35:23.196 --> 00:35:24.786 A:middle
property to our type, and again,

00:35:24.786 --> 00:35:25.976 A:middle
we're going to want to mirror it

00:35:25.976 --> 00:35:27.016 A:middle
in the CodingKeys enum.

00:35:28.276 --> 00:35:29.726 A:middle
This time, though, let's give

00:35:29.726 --> 00:35:31.696 A:middle
the CodingKey a value that is

00:35:31.696 --> 00:35:33.376 A:middle
clearly not found within our

00:35:33.376 --> 00:35:34.126 A:middle
JSON payload.

00:35:35.296 --> 00:35:36.926 A:middle
Now, when we go ahead and try to

00:35:36.926 --> 00:35:38.386 A:middle
decode this value, it won't be

00:35:38.386 --> 00:35:39.906 A:middle
found, and so this'll actually

00:35:39.906 --> 00:35:41.176 A:middle
be an error at decode time.

00:35:41.676 --> 00:35:43.466 A:middle
To see how we can handle that

00:35:43.466 --> 00:35:44.806 A:middle
error, let's hide the JSON spec

00:35:44.806 --> 00:35:46.186 A:middle
again and go down to where we

00:35:46.186 --> 00:35:47.096 A:middle
perform the decode.

00:35:48.706 --> 00:35:49.926 A:middle
In order to handle this error,

00:35:50.316 --> 00:35:51.966 A:middle
we can catch a decoding error,

00:35:52.366 --> 00:35:53.946 A:middle
key not found error, which

00:35:53.946 --> 00:35:55.066 A:middle
indicates that we tried to

00:35:55.066 --> 00:35:56.596 A:middle
access something with this key,

00:35:56.996 --> 00:35:57.906 A:middle
but it wasn't found in the

00:35:57.906 --> 00:35:58.566 A:middle
payload anywhere.

00:35:59.486 --> 00:36:00.606 A:middle
Along with that, we get some

00:36:00.606 --> 00:36:01.936 A:middle
contextual information about

00:36:01.936 --> 00:36:02.816 A:middle
what went wrong and where.

00:36:03.476 --> 00:36:04.966 A:middle
So now, let's set a break point

00:36:04.966 --> 00:36:06.256 A:middle
here, and run our app with this

00:36:06.256 --> 00:36:07.866 A:middle
faulty key, and take a look to

00:36:07.866 --> 00:36:09.146 A:middle
make sure that we can catch this

00:36:09.146 --> 00:36:10.146 A:middle
error and we hit the break

00:36:10.206 --> 00:36:10.386 A:middle
point.

00:36:11.496 --> 00:36:13.456 A:middle
And so now that we run this app,

00:36:13.596 --> 00:36:14.476 A:middle
you'll notice that we do hit

00:36:14.476 --> 00:36:15.086 A:middle
that break point.

00:36:15.316 --> 00:36:16.466 A:middle
Now, if we go ahead and print

00:36:16.466 --> 00:36:17.946 A:middle
the key, you might see that this

00:36:17.946 --> 00:36:19.376 A:middle
is in fact the URL key that we

00:36:19.376 --> 00:36:21.036 A:middle
gave a faulty value to, and in

00:36:21.036 --> 00:36:22.356 A:middle
fact, it wasn't found in the

00:36:22.416 --> 00:36:23.426 A:middle
payload, and so we get the

00:36:23.426 --> 00:36:23.656 A:middle
error.

00:36:24.616 --> 00:36:26.016 A:middle
Now, here if we take a look at

00:36:26.016 --> 00:36:27.166 A:middle
the contextual information, you

00:36:27.166 --> 00:36:28.696 A:middle
might see two useful features

00:36:29.046 --> 00:36:29.996 A:middle
that helps you debug what

00:36:29.996 --> 00:36:30.376 A:middle
happened.

00:36:31.146 --> 00:36:32.726 A:middle
First, a debug description for

00:36:32.726 --> 00:36:34.176 A:middle
you the developer to figure out

00:36:34.176 --> 00:36:35.836 A:middle
what went wrong along with the

00:36:35.836 --> 00:36:37.476 A:middle
coding path that describes where

00:36:37.476 --> 00:36:38.376 A:middle
in the payload something

00:36:38.376 --> 00:36:39.846 A:middle
happened to cause this to go

00:36:39.846 --> 00:36:40.136 A:middle
wrong.

00:36:41.666 --> 00:36:42.846 A:middle
Now, this is all nice and good,

00:36:42.946 --> 00:36:45.216 A:middle
but in fact, if my URL is

00:36:45.216 --> 00:36:46.446 A:middle
something I don't really care

00:36:46.446 --> 00:36:47.526 A:middle
about all that much and I might

00:36:47.526 --> 00:36:49.036 A:middle
not need it, one way to handle

00:36:49.036 --> 00:36:50.516 A:middle
this error is to make your URL

00:36:50.646 --> 00:36:51.056 A:middle
optional.

00:36:52.466 --> 00:36:53.356 A:middle
When you make the property

00:36:53.356 --> 00:36:55.176 A:middle
optional by default, if the key

00:36:55.176 --> 00:36:56.956 A:middle
or value is not found, it'll

00:36:56.956 --> 00:36:58.616 A:middle
actually get set to nil on

00:36:58.616 --> 00:36:59.256 A:middle
initialization.

00:36:59.876 --> 00:37:01.256 A:middle
So let's hide our UI a bit and

00:37:01.256 --> 00:37:02.596 A:middle
rerun our app to see if we hit

00:37:02.596 --> 00:37:04.046 A:middle
that break point or not.

00:37:04.596 --> 00:37:06.506 A:middle
And in fact, when we rerun it,

00:37:06.606 --> 00:37:07.706 A:middle
we don't hit that break point

00:37:07.706 --> 00:37:09.056 A:middle
because the value is set to nil

00:37:09.056 --> 00:37:10.246 A:middle
by default, which is a handy

00:37:10.246 --> 00:37:10.626 A:middle
behavior.

00:37:11.386 --> 00:37:12.996 A:middle
Now, let's go back to our code

00:37:12.996 --> 00:37:13.946 A:middle
and take a look and see what

00:37:13.946 --> 00:37:15.116 A:middle
other errors we might be able to

00:37:15.116 --> 00:37:16.006 A:middle
catch that are helpful.

00:37:17.236 --> 00:37:18.766 A:middle
One other error like that is the

00:37:18.766 --> 00:37:20.356 A:middle
DecodingError.valueNotFound,

00:37:20.976 --> 00:37:22.156 A:middle
which indicates we tried to

00:37:22.156 --> 00:37:23.596 A:middle
decode something of this type

00:37:24.006 --> 00:37:25.146 A:middle
but in fact found nil.

00:37:26.066 --> 00:37:27.296 A:middle
Again, you get that same

00:37:27.296 --> 00:37:29.016 A:middle
contextual information that

00:37:29.016 --> 00:37:31.046 A:middle
tells you what went wrong and

00:37:32.176 --> 00:37:32.286 A:middle
where.

00:37:32.486 --> 00:37:33.686 A:middle
Along with that, you might want

00:37:33.686 --> 00:37:35.576 A:middle
to catch a type mismatch, which

00:37:35.576 --> 00:37:36.916 A:middle
indicates that you try to decode

00:37:36.916 --> 00:37:38.416 A:middle
something of this type, but

00:37:38.416 --> 00:37:39.516 A:middle
something else was found in a,

00:37:39.616 --> 00:37:40.186 A:middle
in the payload.

00:37:40.326 --> 00:37:41.706 A:middle
Say, you tried to decode a

00:37:41.706 --> 00:37:43.236 A:middle
strong, but instead, a number

00:37:43.236 --> 00:37:43.646 A:middle
was found.

00:37:44.126 --> 00:37:45.316 A:middle
And again, you get that same

00:37:45.316 --> 00:37:46.566 A:middle
contextual information as

00:37:46.566 --> 00:37:46.926 A:middle
before.

00:37:47.746 --> 00:37:49.226 A:middle
Now, these errors are really

00:37:49.226 --> 00:37:50.756 A:middle
handy for when you want to debug

00:37:50.756 --> 00:37:52.366 A:middle
when something goes wrong, but

00:37:52.366 --> 00:37:53.486 A:middle
in the general case, you don't

00:37:53.486 --> 00:37:54.566 A:middle
really want to catch these at

00:37:54.566 --> 00:37:55.676 A:middle
the top level like here.

00:37:56.196 --> 00:37:57.026 A:middle
Instead, you just want to

00:37:57.026 --> 00:37:57.976 A:middle
capture general error and

00:37:57.976 --> 00:37:59.136 A:middle
display something localized to

00:37:59.136 --> 00:38:00.436 A:middle
the users so they can figure out

00:38:00.436 --> 00:38:03.166 A:middle
what went wrong or report the

00:38:03.476 --> 00:38:03.566 A:middle
bug.

00:38:03.566 --> 00:38:04.956 A:middle
Now, these are actually a very

00:38:04.956 --> 00:38:06.336 A:middle
powerful tool to do some more

00:38:06.336 --> 00:38:07.176 A:middle
advanced things.

00:38:07.586 --> 00:38:09.056 A:middle
If you customize your init from

00:38:09.056 --> 00:38:10.726 A:middle
or encode to, you can actually

00:38:10.726 --> 00:38:12.026 A:middle
catch these errors within your

00:38:12.026 --> 00:38:13.486 A:middle
types to do powerful things like

00:38:13.526 --> 00:38:15.186 A:middle
data migrations, renaming

00:38:15.186 --> 00:38:16.626 A:middle
properties, and so on and so

00:38:16.626 --> 00:38:16.886 A:middle
forth.

00:38:17.146 --> 00:38:18.676 A:middle
But within our app, we actually

00:38:18.676 --> 00:38:19.866 A:middle
don't need that because I've got

00:38:19.866 --> 00:38:21.116 A:middle
exactly what I want with not

00:38:21.116 --> 00:38:21.526 A:middle
much code.

00:38:22.096 --> 00:38:23.126 A:middle
And so I'm going to turn things

00:38:23.126 --> 00:38:24.606 A:middle
back over to Tony to talk about

00:38:24.606 --> 00:38:25.696 A:middle
some of these more advanced

00:38:25.696 --> 00:38:27.176 A:middle
encoding and decoding topics.

00:38:27.406 --> 00:38:27.716 A:middle
Thanks.

00:38:28.516 --> 00:38:32.896 A:middle
[ Applause ]

00:38:33.396 --> 00:38:33.826 A:middle
&gt;&gt; Thanks, Itai.

00:38:34.456 --> 00:38:37.256 A:middle
All right, let's move on to talk

00:38:37.256 --> 00:38:39.396 A:middle
about some more advanced topics

00:38:39.446 --> 00:38:41.136 A:middle
in this, with encoding and

00:38:41.136 --> 00:38:41.536 A:middle
decoding.

00:38:41.536 --> 00:38:42.646 A:middle
And to do that, we're going to

00:38:42.646 --> 00:38:43.996 A:middle
go over what I call the three

00:38:43.996 --> 00:38:45.546 A:middle
pillars of our codable API

00:38:45.546 --> 00:38:46.486 A:middle
design philosophy.

00:38:46.926 --> 00:38:48.296 A:middle
The first is that we really

00:38:48.296 --> 00:38:49.546 A:middle
wanted error handling to be

00:38:49.546 --> 00:38:50.986 A:middle
built right in, as you just saw

00:38:50.986 --> 00:38:51.556 A:middle
in this demo.

00:38:51.906 --> 00:38:53.286 A:middle
So when you're working with

00:38:53.286 --> 00:38:54.976 A:middle
archived data, dealing with

00:38:54.976 --> 00:38:56.246 A:middle
unexpected input is not a

00:38:56.246 --> 00:38:58.586 A:middle
question of if, but simply when.

00:38:59.866 --> 00:39:01.396 A:middle
This can be data corruption, it

00:39:01.396 --> 00:39:03.156 A:middle
could be unexpected API changes

00:39:03.156 --> 00:39:04.216 A:middle
from where you receive that

00:39:04.216 --> 00:39:05.916 A:middle
data, or even something like

00:39:05.916 --> 00:39:07.356 A:middle
malicious input -- somebody

00:39:07.356 --> 00:39:08.836 A:middle
trying to probe for weaknesses

00:39:08.836 --> 00:39:09.646 A:middle
in your app.

00:39:09.786 --> 00:39:10.916 A:middle
And so we decided that there

00:39:10.916 --> 00:39:12.326 A:middle
should be no fatal errors as a

00:39:12.326 --> 00:39:13.756 A:middle
result of parsing untrusted

00:39:13.756 --> 00:39:13.976 A:middle
data.

00:39:14.546 --> 00:39:16.636 A:middle
However, we do use the fatal

00:39:16.636 --> 00:39:18.626 A:middle
error in Swift if we detect

00:39:18.626 --> 00:39:19.306 A:middle
something that may be a

00:39:19.306 --> 00:39:20.196 A:middle
developer mistake.

00:39:20.296 --> 00:39:21.406 A:middle
And in those cases, there's a

00:39:21.406 --> 00:39:22.356 A:middle
string with the fatal error

00:39:22.356 --> 00:39:23.266 A:middle
that'll tell you where you may

00:39:23.266 --> 00:39:23.976 A:middle
have gone wrong.

00:39:23.976 --> 00:39:26.296 A:middle
For everything else, we use

00:39:26.296 --> 00:39:27.886 A:middle
Swift's built-in error handling

00:39:27.886 --> 00:39:29.196 A:middle
mechanism, and those kinds of

00:39:29.196 --> 00:39:30.296 A:middle
errors are possible on both

00:39:30.376 --> 00:39:31.956 A:middle
encoding and decoding.

00:39:32.076 --> 00:39:33.866 A:middle
So let's look at what they are.

00:39:35.166 --> 00:39:37.186 A:middle
First, there's encoding.

00:39:37.286 --> 00:39:38.286 A:middle
So there's only one kind of

00:39:38.286 --> 00:39:39.476 A:middle
error on encoding, and that is

00:39:39.476 --> 00:39:40.406 A:middle
an invalid value.

00:39:41.216 --> 00:39:42.756 A:middle
So for some kinds of formats

00:39:42.756 --> 00:39:44.406 A:middle
like JSON, we wanted to give

00:39:44.406 --> 00:39:46.086 A:middle
them the flexibility to handle

00:39:46.626 --> 00:39:48.116 A:middle
input that they may not expect

00:39:48.116 --> 00:39:49.536 A:middle
without resorting to a fatal

00:39:49.536 --> 00:39:50.846 A:middle
error or some kind of default

00:39:50.846 --> 00:39:51.256 A:middle
value.

00:39:51.696 --> 00:39:53.076 A:middle
In JSON, for example, not a

00:39:53.076 --> 00:39:55.416 A:middle
number or infinity are not valid

00:39:55.416 --> 00:39:55.906 A:middle
values.

00:39:55.906 --> 00:39:57.226 A:middle
And so in those cases, they can

00:39:57.226 --> 00:39:57.756 A:middle
throw in error.

00:39:58.336 --> 00:39:59.256 A:middle
There may not be much you can do

00:39:59.256 --> 00:40:00.526 A:middle
about this at the type, by type

00:40:00.526 --> 00:40:01.946 A:middle
level, but you could still catch

00:40:01.946 --> 00:40:03.196 A:middle
it at the top level and present

00:40:03.196 --> 00:40:05.096 A:middle
an error to your user or prevent

00:40:05.096 --> 00:40:07.176 A:middle
some other kind of recovery

00:40:07.176 --> 00:40:07.686 A:middle
mechanism.

00:40:08.676 --> 00:40:09.896 A:middle
On decoding, there are four

00:40:09.896 --> 00:40:11.396 A:middle
kinds of error, three of which

00:40:11.396 --> 00:40:12.576 A:middle
we just saw in the demo -- type

00:40:12.576 --> 00:40:13.776 A:middle
mismatch, missing key, and

00:40:13.776 --> 00:40:14.836 A:middle
missing value, which you can

00:40:14.836 --> 00:40:16.326 A:middle
handle, again, either by using

00:40:16.326 --> 00:40:17.736 A:middle
the air handling mechanism if

00:40:17.736 --> 00:40:19.196 A:middle
the [inaudible] a required part

00:40:19.196 --> 00:40:20.966 A:middle
of your type or by making those

00:40:20.966 --> 00:40:21.906 A:middle
properties optional.

00:40:22.736 --> 00:40:23.796 A:middle
And lastly, we have data

00:40:23.796 --> 00:40:24.236 A:middle
corrupt.

00:40:24.706 --> 00:40:25.646 A:middle
Data corrupt is our kind of

00:40:25.686 --> 00:40:26.946 A:middle
catch-all error for all the

00:40:26.946 --> 00:40:27.876 A:middle
other kinds of things that can

00:40:27.876 --> 00:40:29.046 A:middle
happen during a decode.

00:40:29.646 --> 00:40:30.436 A:middle
And to see where it might be

00:40:30.436 --> 00:40:32.136 A:middle
useful, let's go into some depth

00:40:32.136 --> 00:40:33.356 A:middle
on what actually happens during

00:40:33.356 --> 00:40:33.886 A:middle
a decode.

00:40:34.656 --> 00:40:36.346 A:middle
First, in the beginning, all we

00:40:36.346 --> 00:40:37.046 A:middle
have are bytes.

00:40:37.616 --> 00:40:38.986 A:middle
It could be from the network.

00:40:39.026 --> 00:40:40.716 A:middle
It could be from a file on disk

00:40:41.016 --> 00:40:41.976 A:middle
or somewhere else in your app.

00:40:42.256 --> 00:40:43.956 A:middle
But regardless, at this point,

00:40:43.956 --> 00:40:44.826 A:middle
we don't really know anything

00:40:44.826 --> 00:40:45.266 A:middle
about them.

00:40:45.266 --> 00:40:47.146 A:middle
And so the very first step is to

00:40:47.146 --> 00:40:48.346 A:middle
convert those bytes into

00:40:48.346 --> 00:40:49.286 A:middle
structured bytes.

00:40:50.176 --> 00:40:51.976 A:middle
For example, the JSON decoder

00:40:52.356 --> 00:40:53.266 A:middle
has to verify certain

00:40:53.266 --> 00:40:54.726 A:middle
requirements of the JSON spec

00:40:54.726 --> 00:40:56.846 A:middle
are met -- the particular bytes

00:40:56.846 --> 00:40:58.036 A:middle
at the beginning of the archive,

00:40:58.196 --> 00:40:59.386 A:middle
which indicate string encoding;

00:40:59.556 --> 00:41:00.896 A:middle
certain characters which are

00:41:00.896 --> 00:41:02.946 A:middle
used as delimiters for strings,

00:41:03.176 --> 00:41:04.366 A:middle
numeric values, arrays, and

00:41:04.366 --> 00:41:05.386 A:middle
dictionaries, and so forth.

00:41:05.596 --> 00:41:07.486 A:middle
If any of those look wrong, then

00:41:07.486 --> 00:41:08.996 A:middle
the JSON decoder can throw an

00:41:08.996 --> 00:41:10.876 A:middle
error and stop the decode right

00:41:10.876 --> 00:41:11.096 A:middle
there.

00:41:12.526 --> 00:41:14.306 A:middle
After that, we want to convert

00:41:14.306 --> 00:41:15.826 A:middle
from things like JSON arrays,

00:41:15.826 --> 00:41:16.896 A:middle
and dictionaries, and strings

00:41:16.896 --> 00:41:18.706 A:middle
into your types, commits and

00:41:18.706 --> 00:41:19.196 A:middle
authors.

00:41:19.316 --> 00:41:20.606 A:middle
That is, after all, the entire

00:41:20.606 --> 00:41:21.506 A:middle
point of this API.

00:41:22.836 --> 00:41:24.066 A:middle
But there may be more that we

00:41:24.066 --> 00:41:26.016 A:middle
can do, and we call that

00:41:26.016 --> 00:41:27.576 A:middle
domain-specific validation.

00:41:28.156 --> 00:41:29.506 A:middle
For example, let's say that you

00:41:29.506 --> 00:41:30.526 A:middle
have a type that has an integer

00:41:30.526 --> 00:41:32.276 A:middle
property, but the only valid

00:41:32.276 --> 00:41:33.426 A:middle
values for the integer are

00:41:33.426 --> 00:41:34.626 A:middle
between zero and 100.

00:41:35.286 --> 00:41:37.086 A:middle
Or maybe your type has two

00:41:37.086 --> 00:41:38.506 A:middle
Boolean properties, but they

00:41:38.506 --> 00:41:39.786 A:middle
have to have an exclusive or

00:41:39.786 --> 00:41:40.876 A:middle
relationship with each other.

00:41:41.726 --> 00:41:42.546 A:middle
These kinds of things can be

00:41:42.546 --> 00:41:44.126 A:middle
difficult to express in Swift's

00:41:44.126 --> 00:41:46.116 A:middle
type system, but we do think we

00:41:46.116 --> 00:41:48.066 A:middle
have a great tool for handling

00:41:48.066 --> 00:41:49.176 A:middle
those, and that's just simply

00:41:49.176 --> 00:41:50.126 A:middle
writing more Swift code.

00:41:50.456 --> 00:41:51.786 A:middle
And so we wanted to make sure

00:41:51.786 --> 00:41:52.486 A:middle
that we provided you the

00:41:52.486 --> 00:41:53.826 A:middle
opportunity to do that if you

00:41:53.826 --> 00:41:54.526 A:middle
have those kinds of

00:41:54.526 --> 00:41:55.126 A:middle
requirements.

00:41:56.156 --> 00:41:57.116 A:middle
Finally, you may have

00:41:57.266 --> 00:41:58.396 A:middle
graph-level validation.

00:41:58.736 --> 00:41:59.876 A:middle
This is about the relationship

00:41:59.876 --> 00:42:01.036 A:middle
of the objects in the graph to

00:42:01.036 --> 00:42:02.686 A:middle
each other or to another part of

00:42:02.686 --> 00:42:03.066 A:middle
your app.

00:42:04.046 --> 00:42:05.986 A:middle
Let's apply this to our commit.

00:42:06.286 --> 00:42:07.676 A:middle
So earlier we saw how we

00:42:07.676 --> 00:42:08.976 A:middle
customized our commentCount

00:42:08.976 --> 00:42:10.826 A:middle
property by customizing the enum

00:42:10.826 --> 00:42:11.696 A:middle
called CodingKeys.

00:42:12.066 --> 00:42:13.016 A:middle
Now, we're going to customize

00:42:13.046 --> 00:42:15.136 A:middle
the decodable by implementing

00:42:15.136 --> 00:42:16.066 A:middle
init from decoder.

00:42:16.916 --> 00:42:19.006 A:middle
First, I asked the decoder for a

00:42:19.006 --> 00:42:19.716 A:middle
container.

00:42:20.286 --> 00:42:21.976 A:middle
Containers are what match up

00:42:21.976 --> 00:42:24.226 A:middle
your keys to the values that you

00:42:24.226 --> 00:42:25.706 A:middle
expect to find in the archive.

00:42:26.926 --> 00:42:28.426 A:middle
Once we have a container, we can

00:42:28.426 --> 00:42:30.226 A:middle
ask it for the values that we

00:42:30.226 --> 00:42:30.506 A:middle
need.

00:42:30.736 --> 00:42:32.586 A:middle
So in this case, a URL, a

00:42:32.586 --> 00:42:34.556 A:middle
string, our author, and there's

00:42:34.556 --> 00:42:36.616 A:middle
our recursive descent again, and

00:42:36.656 --> 00:42:37.886 A:middle
the integer value for

00:42:37.886 --> 00:42:38.646 A:middle
commentCount.

00:42:39.716 --> 00:42:40.686 A:middle
Now, let's say that I have an

00:42:40.686 --> 00:42:41.766 A:middle
additional requirement that I

00:42:41.766 --> 00:42:43.246 A:middle
need to verify as part of my

00:42:43.246 --> 00:42:45.296 A:middle
spec, and that is that all URLs

00:42:45.296 --> 00:42:47.056 A:middle
have to be HTTPS.

00:42:47.496 --> 00:42:48.786 A:middle
If they're not, then something

00:42:48.786 --> 00:42:49.426 A:middle
has gone wrong.

00:42:50.106 --> 00:42:50.966 A:middle
So let's see how we might do

00:42:50.966 --> 00:42:51.186 A:middle
that.

00:42:51.586 --> 00:42:52.976 A:middle
First, make some more room on

00:42:52.976 --> 00:42:53.346 A:middle
the slide.

00:42:54.286 --> 00:42:55.806 A:middle
After that, I'm going to use the

00:42:55.806 --> 00:42:57.256 A:middle
URL API that we already know how

00:42:57.256 --> 00:42:59.276 A:middle
to use, and that is the scheme

00:42:59.276 --> 00:42:59.706 A:middle
property.

00:43:00.696 --> 00:43:01.666 A:middle
Here I can just check that it's

00:43:01.666 --> 00:43:03.476 A:middle
equal to HTTPS, and if it's not,

00:43:03.476 --> 00:43:04.816 A:middle
I can throw one of these

00:43:04.816 --> 00:43:06.626 A:middle
decoding errors, providing a

00:43:06.626 --> 00:43:07.676 A:middle
debug description so that you

00:43:07.676 --> 00:43:08.956 A:middle
can catch it in your debugger as

00:43:08.956 --> 00:43:09.986 A:middle
Itai showed in the demo.

00:43:10.726 --> 00:43:11.806 A:middle
Now, what you see, what you'll

00:43:11.806 --> 00:43:14.466 A:middle
notice is not here is this type,

00:43:14.466 --> 00:43:16.076 A:middle
commit, looking into the string

00:43:16.076 --> 00:43:17.136 A:middle
value for the URL.

00:43:17.136 --> 00:43:19.286 A:middle
We can allow URL to decode

00:43:19.286 --> 00:43:21.126 A:middle
itself, and that's part of

00:43:21.176 --> 00:43:22.636 A:middle
what's so great about this

00:43:22.636 --> 00:43:23.036 A:middle
design.

00:43:23.426 --> 00:43:25.546 A:middle
So URL knows if that string is

00:43:25.546 --> 00:43:26.896 A:middle
URL or not, and if it's not,

00:43:27.296 --> 00:43:28.216 A:middle
it'll throw an error before we

00:43:28.216 --> 00:43:29.106 A:middle
even get to this point.

00:43:29.406 --> 00:43:30.466 A:middle
And because of the design of

00:43:30.466 --> 00:43:32.006 A:middle
Swift's error handling, that can

00:43:32.006 --> 00:43:34.036 A:middle
propagate out of this type to

00:43:34.036 --> 00:43:34.826 A:middle
the one that's decoding the

00:43:34.826 --> 00:43:36.426 A:middle
commit or even to the top level.

00:43:36.926 --> 00:43:39.906 A:middle
Let's move on to the second

00:43:39.906 --> 00:43:41.106 A:middle
pillar, and that is

00:43:41.106 --> 00:43:42.706 A:middle
encapsulation of the encoding

00:43:42.706 --> 00:43:43.246 A:middle
details.

00:43:44.366 --> 00:43:45.576 A:middle
We felt it was really important

00:43:45.576 --> 00:43:47.536 A:middle
to make sure that the keys and

00:43:47.536 --> 00:43:49.226 A:middle
values that a type chooses to

00:43:49.226 --> 00:43:50.776 A:middle
put into the archive are private

00:43:50.876 --> 00:43:51.606 A:middle
to that type.

00:43:51.606 --> 00:43:54.036 A:middle
And the reason it's important is

00:43:54.036 --> 00:43:55.616 A:middle
because that frees us from

00:43:55.616 --> 00:43:57.176 A:middle
something that, from designing

00:43:57.176 --> 00:43:58.326 A:middle
something that has global

00:43:58.326 --> 00:43:59.906 A:middle
knowledge of everything in the

00:43:59.906 --> 00:44:01.256 A:middle
archive that can possibly be

00:44:01.256 --> 00:44:01.476 A:middle
there.

00:44:02.286 --> 00:44:03.486 A:middle
The main mechanism we have for

00:44:03.586 --> 00:44:05.206 A:middle
performing this encapsulation is

00:44:05.206 --> 00:44:06.926 A:middle
called containers, and we have

00:44:07.026 --> 00:44:07.576 A:middle
three kinds.

00:44:08.126 --> 00:44:10.026 A:middle
The first is a keyed container.

00:44:10.716 --> 00:44:11.946 A:middle
Keyed containers are the

00:44:11.946 --> 00:44:13.056 A:middle
preferred choice in the vast

00:44:13.056 --> 00:44:14.426 A:middle
majority of cases, and the

00:44:14.426 --> 00:44:16.396 A:middle
reason is because they're by far

00:44:16.396 --> 00:44:17.636 A:middle
the most forward and backward

00:44:17.636 --> 00:44:18.166 A:middle
compatible.

00:44:18.836 --> 00:44:20.166 A:middle
If in a new version of your app

00:44:20.226 --> 00:44:22.186 A:middle
you have new or changed data,

00:44:22.556 --> 00:44:23.626 A:middle
you simply have to use a new

00:44:23.626 --> 00:44:23.946 A:middle
key.

00:44:24.576 --> 00:44:26.016 A:middle
This makes the most versions of

00:44:26.016 --> 00:44:27.546 A:middle
your app compatible with the

00:44:27.546 --> 00:44:28.686 A:middle
most versions of your data,

00:44:28.946 --> 00:44:29.836 A:middle
which is the best possible

00:44:29.836 --> 00:44:30.716 A:middle
outcome for everybody.

00:44:31.896 --> 00:44:32.976 A:middle
Let's look at what those keys

00:44:32.976 --> 00:44:33.586 A:middle
actually are.

00:44:34.186 --> 00:44:35.086 A:middle
So earlier we talked about the

00:44:35.086 --> 00:44:36.056 A:middle
CodingKey protocol.

00:44:36.206 --> 00:44:37.146 A:middle
Here's what it is.

00:44:37.526 --> 00:44:39.406 A:middle
It has two protocol, or two

00:44:39.406 --> 00:44:41.256 A:middle
properties and two initializers.

00:44:41.836 --> 00:44:43.046 A:middle
So the properties are

00:44:43.046 --> 00:44:44.376 A:middle
stringValue, which is handy when

00:44:44.376 --> 00:44:45.346 A:middle
you're working with JSON, for

00:44:45.346 --> 00:44:46.776 A:middle
example, but you can also

00:44:46.776 --> 00:44:48.166 A:middle
provide an integer value, which

00:44:48.166 --> 00:44:49.376 A:middle
is useful for formats that may

00:44:49.376 --> 00:44:50.896 A:middle
support a more efficient encoded

00:44:50.896 --> 00:44:51.976 A:middle
binary representation.

00:44:53.186 --> 00:44:54.346 A:middle
The initializers, what I would

00:44:54.346 --> 00:44:55.336 A:middle
like you to notice is that they

00:44:55.336 --> 00:44:56.056 A:middle
are optional.

00:44:56.576 --> 00:44:57.386 A:middle
What that means is that the

00:44:57.386 --> 00:44:58.956 A:middle
decoder has an ability to

00:44:58.956 --> 00:45:00.416 A:middle
perform an additional level of

00:45:00.416 --> 00:45:01.236 A:middle
safety checking.

00:45:01.476 --> 00:45:03.406 A:middle
It can verify with your coding

00:45:03.406 --> 00:45:05.436 A:middle
key that the value that's found

00:45:05.436 --> 00:45:06.486 A:middle
in the archive is actually what

00:45:06.486 --> 00:45:07.456 A:middle
you expect to find there.

00:45:08.346 --> 00:45:09.416 A:middle
Typically, you're going to adopt

00:45:09.416 --> 00:45:11.316 A:middle
this protocol on an enumeration,

00:45:11.496 --> 00:45:12.946 A:middle
like the one we've seen so far.

00:45:13.366 --> 00:45:15.196 A:middle
And again, what's happening here

00:45:15.196 --> 00:45:16.036 A:middle
is that the compiler in the

00:45:16.036 --> 00:45:17.306 A:middle
standard library are providing

00:45:17.306 --> 00:45:18.636 A:middle
an implementation of all four of

00:45:18.636 --> 00:45:19.576 A:middle
those requirements for us

00:45:19.576 --> 00:45:20.436 A:middle
completely for free.

00:45:20.976 --> 00:45:22.146 A:middle
So in this case, because the

00:45:22.146 --> 00:45:24.636 A:middle
enum is backed by a string, the

00:45:24.636 --> 00:45:26.516 A:middle
compiler uses the case name as

00:45:26.516 --> 00:45:27.566 A:middle
the string value, both for the

00:45:27.566 --> 00:45:28.656 A:middle
property and for the

00:45:28.656 --> 00:45:29.316 A:middle
initializer.

00:45:29.386 --> 00:45:30.916 A:middle
The intValue, though, remains

00:45:30.916 --> 00:45:32.046 A:middle
nil because there's not enough

00:45:32.046 --> 00:45:33.406 A:middle
information in this enum to

00:45:33.406 --> 00:45:34.846 A:middle
assign a particular value to

00:45:34.846 --> 00:45:35.096 A:middle
that.

00:45:36.096 --> 00:45:37.286 A:middle
Earlier when we customized the

00:45:37.286 --> 00:45:38.856 A:middle
case name, you can see how that

00:45:38.856 --> 00:45:39.446 A:middle
worked now.

00:45:39.566 --> 00:45:40.986 A:middle
We changed the name of the case,

00:45:41.166 --> 00:45:42.726 A:middle
but the value remained the same.

00:45:42.726 --> 00:45:44.066 A:middle
And so stringValue remained

00:45:44.066 --> 00:45:45.426 A:middle
compatible with our GitHub API.

00:45:47.016 --> 00:45:48.646 A:middle
If you're writing library code,

00:45:48.736 --> 00:45:49.366 A:middle
I would encourage you to

00:45:49.366 --> 00:45:50.436 A:middle
consider backing your coding

00:45:50.436 --> 00:45:51.376 A:middle
keys with an integer.

00:45:51.426 --> 00:45:54.036 A:middle
If you do this, you still get

00:45:54.036 --> 00:45:55.326 A:middle
more implementation for free

00:45:55.326 --> 00:45:56.706 A:middle
from the compiler -- in this

00:45:56.706 --> 00:45:57.986 A:middle
case, an integer value, which,

00:45:57.986 --> 00:45:59.806 A:middle
again, could be useful for

00:45:59.806 --> 00:46:01.286 A:middle
formats that may support integer

00:46:01.286 --> 00:46:01.726 A:middle
keys.

00:46:03.496 --> 00:46:05.256 A:middle
We also support unkeyed

00:46:05.256 --> 00:46:05.826 A:middle
containers.

00:46:06.026 --> 00:46:08.126 A:middle
These encode and decode in

00:46:08.236 --> 00:46:08.576 A:middle
order.

00:46:09.326 --> 00:46:10.606 A:middle
Use these for ordered or

00:46:10.606 --> 00:46:12.236 A:middle
unbounded data, and, you know,

00:46:12.236 --> 00:46:13.126 A:middle
the reason for that is that, of

00:46:13.126 --> 00:46:13.726 A:middle
course, you don't have to

00:46:13.726 --> 00:46:14.986 A:middle
generate fake keys in order to

00:46:14.986 --> 00:46:16.216 A:middle
get your data into an archive.

00:46:17.076 --> 00:46:18.826 A:middle
We also support single value

00:46:18.826 --> 00:46:20.166 A:middle
container, which, as the name

00:46:20.166 --> 00:46:22.006 A:middle
suggests, holds exactly one

00:46:22.006 --> 00:46:22.336 A:middle
entry.

00:46:22.996 --> 00:46:24.286 A:middle
Use these for primitive types.

00:46:24.346 --> 00:46:25.796 A:middle
For example, date stores the

00:46:25.796 --> 00:46:27.036 A:middle
number of seconds since a

00:46:27.036 --> 00:46:28.156 A:middle
reference point in time.

00:46:28.966 --> 00:46:30.196 A:middle
Now, when you choose these, just

00:46:30.196 --> 00:46:31.856 A:middle
be aware that they are the least

00:46:31.856 --> 00:46:34.376 A:middle
compatible choice, so keep that

00:46:34.376 --> 00:46:34.716 A:middle
in mind.

00:46:35.896 --> 00:46:37.266 A:middle
Let's return one more time to

00:46:37.266 --> 00:46:37.866 A:middle
our commit.

00:46:39.056 --> 00:46:40.346 A:middle
So we saw how we customized the

00:46:40.346 --> 00:46:42.696 A:middle
commentCount and the CodingKeys

00:46:42.696 --> 00:46:44.286 A:middle
with that, the decoding by

00:46:44.286 --> 00:46:45.546 A:middle
changing init from decoder.

00:46:45.916 --> 00:46:48.406 A:middle
Now, let's look at encoding with

00:46:48.406 --> 00:46:49.476 A:middle
encode to encoder.

00:46:49.806 --> 00:46:50.976 A:middle
And actually, I don't need to

00:46:50.976 --> 00:46:52.616 A:middle
customize anything here, but I

00:46:52.616 --> 00:46:53.366 A:middle
still want to show you what it

00:46:53.366 --> 00:46:54.726 A:middle
looks like so you can understand

00:46:54.726 --> 00:46:55.316 A:middle
how it works.

00:46:55.756 --> 00:46:57.876 A:middle
So first, we get a container,

00:46:57.946 --> 00:46:59.266 A:middle
and that container, as you can

00:46:59.266 --> 00:47:00.986 A:middle
see here, is keyed by our own

00:47:00.986 --> 00:47:02.766 A:middle
private-to-us CodingKeys.

00:47:03.276 --> 00:47:05.426 A:middle
That container is how I can

00:47:05.426 --> 00:47:07.706 A:middle
encode the values that I want to

00:47:07.706 --> 00:47:08.886 A:middle
be put in the archive -- our

00:47:08.916 --> 00:47:10.376 A:middle
URL, message, author, the

00:47:10.376 --> 00:47:12.056 A:middle
recursive descent again, and the

00:47:12.056 --> 00:47:12.666 A:middle
comment count.

00:47:12.836 --> 00:47:14.466 A:middle
I do want to show you an example

00:47:14.466 --> 00:47:15.176 A:middle
of where you may choose a

00:47:15.176 --> 00:47:16.756 A:middle
different kind of container, so

00:47:16.756 --> 00:47:17.766 A:middle
let's say that we are working

00:47:17.766 --> 00:47:19.436 A:middle
with the GO JSON spec, which has

00:47:19.756 --> 00:47:20.876 A:middle
this concept of a point.

00:47:21.346 --> 00:47:22.636 A:middle
And point has two values, and it

00:47:22.636 --> 00:47:23.556 A:middle
should be an array of two

00:47:23.556 --> 00:47:24.786 A:middle
numeric entries in JSON.

00:47:25.076 --> 00:47:26.306 A:middle
So in order to make that work,

00:47:26.636 --> 00:47:28.826 A:middle
I'm going to adopt encodable and

00:47:28.896 --> 00:47:30.426 A:middle
implement the encode to encoder

00:47:30.466 --> 00:47:32.206 A:middle
to use a unkeyed container.

00:47:32.316 --> 00:47:33.166 A:middle
And you'll notice, of course,

00:47:33.166 --> 00:47:34.796 A:middle
there's no key argument to this

00:47:34.796 --> 00:47:35.266 A:middle
container.

00:47:35.756 --> 00:47:37.156 A:middle
And when I encode, I use no

00:47:37.156 --> 00:47:37.616 A:middle
keys.

00:47:37.756 --> 00:47:39.466 A:middle
And the result looks something

00:47:39.466 --> 00:47:40.506 A:middle
like this in JSON.

00:47:41.656 --> 00:47:43.116 A:middle
We also support nested

00:47:43.116 --> 00:47:43.616 A:middle
containers.

00:47:44.076 --> 00:47:45.676 A:middle
So let's say that maybe the

00:47:45.676 --> 00:47:47.066 A:middle
second entry in my dictionary

00:47:47.066 --> 00:47:48.226 A:middle
actually needed to be an array

00:47:48.226 --> 00:47:48.896 A:middle
of three values.

00:47:49.106 --> 00:47:50.936 A:middle
So we support nesting unkeyed

00:47:50.936 --> 00:47:52.286 A:middle
containers and keyed containers,

00:47:52.286 --> 00:47:53.886 A:middle
as you see here, or any other

00:47:53.886 --> 00:47:55.456 A:middle
combination of keyed, unkeyed,

00:47:55.456 --> 00:47:56.266 A:middle
and single value.

00:47:57.126 --> 00:47:58.346 A:middle
The primary use case for nested

00:47:58.346 --> 00:48:00.096 A:middle
containers is actually classes.

00:48:00.506 --> 00:48:01.926 A:middle
We've talked a lot about structs

00:48:02.376 --> 00:48:04.926 A:middle
so far, but nested containers

00:48:04.926 --> 00:48:06.526 A:middle
gives us a natural mechanism for

00:48:06.526 --> 00:48:08.066 A:middle
encapsulating our superclass

00:48:08.066 --> 00:48:09.406 A:middle
data from our own data as a

00:48:09.406 --> 00:48:10.886 A:middle
subclass, which is a change from

00:48:10.886 --> 00:48:11.346 A:middle
NSCoding.

00:48:12.116 --> 00:48:13.006 A:middle
Let's look at an example.

00:48:13.546 --> 00:48:14.636 A:middle
Here's everyone's favorite

00:48:14.766 --> 00:48:15.816 A:middle
object-oriented example,

00:48:15.816 --> 00:48:16.286 A:middle
animals.

00:48:16.426 --> 00:48:17.956 A:middle
So animals have a leg count,

00:48:18.336 --> 00:48:18.786 A:middle
naturally.

00:48:19.176 --> 00:48:21.296 A:middle
And its own coding keys.

00:48:21.406 --> 00:48:23.306 A:middle
And here you can see that on

00:48:23.306 --> 00:48:24.366 A:middle
this class, when I implement

00:48:24.366 --> 00:48:25.436 A:middle
init from decoder, it is a

00:48:25.436 --> 00:48:26.466 A:middle
required initializer.

00:48:27.726 --> 00:48:29.376 A:middle
Here I create a keyed contained

00:48:29.376 --> 00:48:30.806 A:middle
using the animal's coding keys

00:48:30.806 --> 00:48:31.856 A:middle
and decode my leg count.

00:48:31.996 --> 00:48:32.786 A:middle
Pretty similar to what we've

00:48:32.786 --> 00:48:33.466 A:middle
seen so far.

00:48:34.576 --> 00:48:35.766 A:middle
Now, let's subclass it.

00:48:36.526 --> 00:48:37.786 A:middle
Dogs is a kind of animal that

00:48:37.786 --> 00:48:39.046 A:middle
has a best friend, which is the

00:48:39.046 --> 00:48:40.186 A:middle
kid from our birthday party

00:48:40.186 --> 00:48:40.566 A:middle
earlier.

00:48:41.256 --> 00:48:42.926 A:middle
Now, you notice that dog also

00:48:42.926 --> 00:48:44.256 A:middle
has a private enum called

00:48:44.256 --> 00:48:46.486 A:middle
CodingKeys, and yet, even though

00:48:46.486 --> 00:48:47.546 A:middle
it has the same name as the one

00:48:47.546 --> 00:48:48.956 A:middle
from the superclass, because

00:48:48.956 --> 00:48:50.536 A:middle
it's private, it doesn't

00:48:50.536 --> 00:48:52.146 A:middle
conflict with the one that

00:48:52.146 --> 00:48:52.896 A:middle
animal uses.

00:48:53.376 --> 00:48:54.996 A:middle
So when I implement the dog's

00:48:54.996 --> 00:48:56.316 A:middle
init from decoder and get a

00:48:56.316 --> 00:48:58.046 A:middle
container with its own coding

00:48:58.046 --> 00:48:59.696 A:middle
keys, I can decode it in a

00:48:59.696 --> 00:49:01.506 A:middle
type-safe way with the keys that

00:49:01.506 --> 00:49:03.126 A:middle
are important to it, not its

00:49:03.126 --> 00:49:03.786 A:middle
superclass.

00:49:04.526 --> 00:49:05.516 A:middle
Now, we do need to finish that

00:49:05.516 --> 00:49:05.926 A:middle
nesting.

00:49:06.556 --> 00:49:08.516 A:middle
So we could call superclass, our

00:49:08.516 --> 00:49:09.956 A:middle
superclasses init from decoder

00:49:09.956 --> 00:49:10.986 A:middle
with the decoder that we

00:49:10.986 --> 00:49:11.546 A:middle
received.

00:49:12.026 --> 00:49:13.776 A:middle
However, that doesn't give the

00:49:13.776 --> 00:49:16.266 A:middle
container a chance to nest that

00:49:16.266 --> 00:49:17.146 A:middle
superclass data.

00:49:17.636 --> 00:49:19.226 A:middle
So the easiest way to do that is

00:49:19.226 --> 00:49:20.466 A:middle
to use this convenience API --

00:49:21.046 --> 00:49:22.406 A:middle
it's called superDecoder -- that

00:49:22.406 --> 00:49:23.966 A:middle
gets a new decoder that we could

00:49:23.966 --> 00:49:25.106 A:middle
pass to our superclass.

00:49:25.386 --> 00:49:27.416 A:middle
And by calling super, we finish

00:49:27.866 --> 00:49:29.546 A:middle
satisfying Swift's rules for

00:49:29.546 --> 00:49:30.906 A:middle
creating an initializer that

00:49:31.036 --> 00:49:32.556 A:middle
results in a finally initialized

00:49:32.606 --> 00:49:33.876 A:middle
type that's ready for use.

00:49:36.776 --> 00:49:38.166 A:middle
Finally, we have our third

00:49:38.166 --> 00:49:39.666 A:middle
pillar, and that is abstracting

00:49:39.666 --> 00:49:41.676 A:middle
the encoded format from these

00:49:41.706 --> 00:49:42.226 A:middle
types.

00:49:43.606 --> 00:49:44.716 A:middle
We felt it was important to be

00:49:44.716 --> 00:49:46.816 A:middle
able to reuse one implementation

00:49:46.876 --> 00:49:48.286 A:middle
of these protocols.

00:49:49.186 --> 00:49:50.216 A:middle
We didn't want to wind up in a

00:49:50.216 --> 00:49:51.906 A:middle
situation where we had many

00:49:52.156 --> 00:49:53.036 A:middle
almost duplicated

00:49:53.036 --> 00:49:55.256 A:middle
implementations of encodable and

00:49:55.256 --> 00:49:56.656 A:middle
decodable to support new

00:49:56.656 --> 00:49:57.276 A:middle
formats.

00:49:57.986 --> 00:50:00.636 A:middle
So by abstracting the format, we

00:50:00.636 --> 00:50:02.046 A:middle
can allow brand-new formats

00:50:02.046 --> 00:50:03.436 A:middle
without any library changes.

00:50:03.626 --> 00:50:04.886 A:middle
Those formats can come from us,

00:50:05.216 --> 00:50:06.836 A:middle
or from you, or even from Swift

00:50:06.836 --> 00:50:09.636 A:middle
Packages, and those formats can

00:50:09.636 --> 00:50:10.656 A:middle
work with types that come from

00:50:10.656 --> 00:50:12.276 A:middle
us, or from you, or with Swift

00:50:12.276 --> 00:50:12.866 A:middle
Packages.

00:50:13.836 --> 00:50:15.146 A:middle
We do understand, though, that

00:50:15.146 --> 00:50:16.916 A:middle
different formats have different

00:50:16.916 --> 00:50:18.576 A:middle
fundamental types and different

00:50:18.576 --> 00:50:19.256 A:middle
conventions.

00:50:19.906 --> 00:50:21.196 A:middle
So the mechanism we have for

00:50:21.196 --> 00:50:22.116 A:middle
working with that is called

00:50:22.116 --> 00:50:23.136 A:middle
encoding strategies.

00:50:23.496 --> 00:50:24.536 A:middle
These are encoder- and

00:50:24.536 --> 00:50:26.266 A:middle
decoder-specific customizations

00:50:26.596 --> 00:50:27.746 A:middle
for certain types.

00:50:27.906 --> 00:50:29.696 A:middle
For example, in JSON, we saw one

00:50:29.696 --> 00:50:30.556 A:middle
already for date.

00:50:31.016 --> 00:50:32.596 A:middle
In our GitHub example, the date

00:50:32.596 --> 00:50:34.426 A:middle
was encoded as an iso8601

00:50:34.426 --> 00:50:34.816 A:middle
string.

00:50:35.486 --> 00:50:36.906 A:middle
But there are other conventions

00:50:37.006 --> 00:50:38.046 A:middle
that are possible.

00:50:38.096 --> 00:50:39.236 A:middle
For example, the number of

00:50:39.236 --> 00:50:40.726 A:middle
seconds since a reference date,

00:50:40.986 --> 00:50:42.236 A:middle
the number of milliseconds since

00:50:42.236 --> 00:50:43.786 A:middle
a reference date, or you can

00:50:43.786 --> 00:50:45.216 A:middle
even specify a completely custom

00:50:45.216 --> 00:50:46.546 A:middle
date formatter if you have

00:50:46.546 --> 00:50:47.726 A:middle
something very specialized in

00:50:47.726 --> 00:50:48.026 A:middle
mind.

00:50:49.066 --> 00:50:50.276 A:middle
The JSON encoder and decoder

00:50:50.276 --> 00:50:51.196 A:middle
support other kinds of

00:50:51.196 --> 00:50:51.756 A:middle
strategies.

00:50:51.756 --> 00:50:53.346 A:middle
For example, for data.

00:50:53.956 --> 00:50:55.356 A:middle
In JSON, it's very common to

00:50:55.446 --> 00:50:56.816 A:middle
Base64 encode your data.

00:50:57.766 --> 00:50:59.116 A:middle
But we also allow you to

00:50:59.116 --> 00:51:00.256 A:middle
customize this by choosing a

00:51:00.256 --> 00:51:02.636 A:middle
strategy that encodes it as an

00:51:02.636 --> 00:51:04.126 A:middle
array of bytes, or you can

00:51:04.126 --> 00:51:05.176 A:middle
specify something completely

00:51:05.176 --> 00:51:06.576 A:middle
custom, like this one, which

00:51:06.576 --> 00:51:07.886 A:middle
turns all zeros into sheep and

00:51:07.886 --> 00:51:08.866 A:middle
everything else into a dog.

00:51:09.506 --> 00:51:11.066 A:middle
I don't know why you'd do this,

00:51:11.066 --> 00:51:13.196 A:middle
but it's possible, so there you

00:51:13.196 --> 00:51:13.366 A:middle
go.

00:51:13.976 --> 00:51:16.196 A:middle
Now, this abstraction helps us

00:51:16.256 --> 00:51:17.506 A:middle
with different formats as well.

00:51:17.506 --> 00:51:18.246 A:middle
So we've seen, we've talked a

00:51:18.246 --> 00:51:19.736 A:middle
lot about JSON today, but

00:51:19.736 --> 00:51:20.526 A:middle
actually, we are also

00:51:20.526 --> 00:51:21.806 A:middle
introducing a property list

00:51:21.806 --> 00:51:22.756 A:middle
encoder and decoder.

00:51:23.396 --> 00:51:25.186 A:middle
And property lists, unlike JSON,

00:51:25.186 --> 00:51:27.066 A:middle
have native types for data and

00:51:27.066 --> 00:51:27.486 A:middle
for date.

00:51:28.096 --> 00:51:29.786 A:middle
And so when these encoders and

00:51:29.786 --> 00:51:31.326 A:middle
decoders encounter these objects

00:51:31.326 --> 00:51:32.336 A:middle
either in the object graph that

00:51:32.336 --> 00:51:33.706 A:middle
it's encoding or in the data

00:51:33.706 --> 00:51:35.656 A:middle
that it's unarchiving, we can

00:51:35.656 --> 00:51:36.506 A:middle
convert them into the right

00:51:36.506 --> 00:51:37.716 A:middle
types that are proper for that

00:51:37.716 --> 00:51:38.076 A:middle
format.

00:51:38.486 --> 00:51:40.876 A:middle
Because of these abstractions,

00:51:40.876 --> 00:51:41.996 A:middle
we're able to adopt the codable

00:51:41.996 --> 00:51:43.696 A:middle
protocols on a wide variety of

00:51:43.696 --> 00:51:45.066 A:middle
Foundation types, including all

00:51:45.066 --> 00:51:45.836 A:middle
the ones you see here.

00:51:45.836 --> 00:51:48.416 A:middle
Now, we've talked about a lot of

00:51:48.416 --> 00:51:49.286 A:middle
codable API.

00:51:49.286 --> 00:51:51.096 A:middle
I want to give you a visual

00:51:51.096 --> 00:51:52.946 A:middle
overview to help you understand

00:51:52.986 --> 00:51:54.006 A:middle
what the big picture is.

00:51:54.116 --> 00:51:54.866 A:middle
So we're going to start, of

00:51:54.866 --> 00:51:55.846 A:middle
course, with your type.

00:51:56.616 --> 00:51:58.836 A:middle
Your type adopts two protocols.

00:51:58.896 --> 00:52:00.166 A:middle
They're called encodable and

00:52:00.166 --> 00:52:00.746 A:middle
decodable.

00:52:01.916 --> 00:52:03.116 A:middle
These have a function and an

00:52:03.116 --> 00:52:04.476 A:middle
initializer, which give you

00:52:04.476 --> 00:52:06.546 A:middle
access to an encoder and a

00:52:06.546 --> 00:52:07.146 A:middle
decoder.

00:52:08.266 --> 00:52:09.686 A:middle
These provide you access to

00:52:09.686 --> 00:52:10.736 A:middle
containers, and that's what

00:52:10.736 --> 00:52:11.976 A:middle
actually holds the values that

00:52:11.976 --> 00:52:12.726 A:middle
are in the archive.

00:52:13.216 --> 00:52:14.086 A:middle
In the case of a keyed

00:52:14.086 --> 00:52:16.086 A:middle
container, we use the coding

00:52:16.086 --> 00:52:17.646 A:middle
keys that are defined by your

00:52:17.646 --> 00:52:18.016 A:middle
type.

00:52:19.216 --> 00:52:20.746 A:middle
And finally, the encoders and

00:52:20.746 --> 00:52:22.026 A:middle
containers provide an

00:52:22.026 --> 00:52:23.606 A:middle
abstraction for encoded formats

00:52:23.606 --> 00:52:25.766 A:middle
like JSON, property list, and

00:52:25.806 --> 00:52:26.076 A:middle
more.

00:52:26.656 --> 00:52:29.996 A:middle
All right, so we started today

00:52:29.996 --> 00:52:31.626 A:middle
by going over some new API and

00:52:31.626 --> 00:52:32.776 A:middle
improved performance in this

00:52:32.776 --> 00:52:33.896 A:middle
year's release of Foundation.

00:52:34.476 --> 00:52:35.976 A:middle
After that, we looked at the new

00:52:36.246 --> 00:52:37.476 A:middle
strongly typed key paths for

00:52:37.476 --> 00:52:38.966 A:middle
Swift, including one really cool

00:52:38.966 --> 00:52:40.636 A:middle
use case, our brand-new,

00:52:40.716 --> 00:52:42.186 A:middle
closure-based KVO API.

00:52:43.126 --> 00:52:44.166 A:middle
And finally, we went over the

00:52:44.166 --> 00:52:46.266 A:middle
new codable protocols, which

00:52:46.436 --> 00:52:47.556 A:middle
make integration with formats

00:52:47.556 --> 00:52:49.786 A:middle
like JSON easy, but also allow

00:52:49.786 --> 00:52:51.566 A:middle
you the opportunity for powerful

00:52:51.566 --> 00:52:52.306 A:middle
customization.

00:52:53.316 --> 00:52:54.716 A:middle
For more information, check out

00:52:54.716 --> 00:52:55.106 A:middle
this link.

00:52:56.116 --> 00:52:57.366 A:middle
We have a couple of related

00:52:57.366 --> 00:52:58.266 A:middle
sessions that we've talked

00:52:58.266 --> 00:52:58.566 A:middle
about.

00:52:58.566 --> 00:53:01.096 A:middle
Thank you so much.

00:53:02.516 --> 00:53:05.500 A:middle
[ Applause ]