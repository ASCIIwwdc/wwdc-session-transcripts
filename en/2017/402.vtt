WEBVTT

00:00:18.046 --> 00:00:18.756 A:middle
&gt;&gt; Good afternoon everyone.

00:00:19.516 --> 00:00:23.796 A:middle
[ Applause ]

00:00:24.296 --> 00:00:24.606 A:middle
Thank you.

00:00:25.186 --> 00:00:26.516 A:middle
Welcome to what's new in Swift.

00:00:27.256 --> 00:00:28.206 A:middle
My name is Doug Gregor.

00:00:28.436 --> 00:00:29.296 A:middle
I'm here with some of my

00:00:29.296 --> 00:00:30.446 A:middle
colleagues from the Swift team

00:00:30.696 --> 00:00:32.286 A:middle
to talk about some of the great

00:00:32.286 --> 00:00:33.866 A:middle
things we're bringing in Swift

00:00:33.866 --> 00:00:34.246 A:middle
4.

00:00:35.276 --> 00:00:38.866 A:middle
Now, if you follow iOS Developer

00:00:38.866 --> 00:00:40.576 A:middle
and author Ole Begemann, you

00:00:40.576 --> 00:00:41.486 A:middle
actually know everything that's

00:00:41.486 --> 00:00:42.356 A:middle
already in Swift 4.

00:00:43.606 --> 00:00:45.046 A:middle
This is something I absolutely

00:00:45.046 --> 00:00:46.896 A:middle
love about the Swift community.

00:00:47.296 --> 00:00:49.726 A:middle
What Ole did here is, he looked

00:00:49.726 --> 00:00:50.886 A:middle
at all the proposals, what was

00:00:50.886 --> 00:00:53.036 A:middle
going into Swift 4, and what did

00:00:53.036 --> 00:00:53.366 A:middle
he do?

00:00:53.366 --> 00:00:54.996 A:middle
He built a playground to

00:00:54.996 --> 00:00:56.346 A:middle
demonstrate how these features

00:00:56.346 --> 00:00:57.926 A:middle
worked, and he shared it with

00:00:57.926 --> 00:00:58.996 A:middle
the world so we could all learn

00:00:58.996 --> 00:00:59.386 A:middle
from it.

00:01:00.136 --> 00:01:00.996 A:middle
This is awesome.

00:01:01.896 --> 00:01:03.986 A:middle
And it's possible because at any

00:01:03.986 --> 00:01:05.426 A:middle
point you can go over to

00:01:05.426 --> 00:01:07.086 A:middle
Swift.org, our home of open

00:01:07.086 --> 00:01:09.276 A:middle
source, and download a snapshot

00:01:09.276 --> 00:01:10.766 A:middle
of the latest and greatest Swift

00:01:10.766 --> 00:01:11.336 A:middle
compiler.

00:01:12.046 --> 00:01:13.626 A:middle
That snapshot is a toolchain

00:01:13.626 --> 00:01:16.016 A:middle
that you can install into Xcode.

00:01:16.926 --> 00:01:18.576 A:middle
Provides new compiler, debugger,

00:01:18.576 --> 00:01:19.646 A:middle
source kit, everything.

00:01:19.646 --> 00:01:20.696 A:middle
So, you can build your app

00:01:20.696 --> 00:01:21.906 A:middle
against the latest tools.

00:01:22.126 --> 00:01:23.026 A:middle
Try out some of the new

00:01:23.026 --> 00:01:24.466 A:middle
features, check whether we fixed

00:01:24.466 --> 00:01:25.226 A:middle
your favorite bug.

00:01:25.336 --> 00:01:27.766 A:middle
Of course, this is all possible

00:01:27.766 --> 00:01:29.286 A:middle
because Swift is open source.

00:01:29.286 --> 00:01:30.426 A:middle
We develop everything in the

00:01:30.426 --> 00:01:32.406 A:middle
open on GitHub, so you can

00:01:32.406 --> 00:01:33.116 A:middle
follow along.

00:01:33.526 --> 00:01:34.746 A:middle
You can participate if you're

00:01:34.746 --> 00:01:35.346 A:middle
interested.

00:01:36.266 --> 00:01:38.706 A:middle
And also, the way Swift evolves.

00:01:38.706 --> 00:01:40.226 A:middle
The standard library, the

00:01:40.226 --> 00:01:42.206 A:middle
language is through this open

00:01:42.206 --> 00:01:43.926 A:middle
evolution process where we

00:01:44.076 --> 00:01:46.036 A:middle
evaluate individual proposals.

00:01:46.396 --> 00:01:48.116 A:middle
Refine them improve them, to

00:01:48.116 --> 00:01:49.846 A:middle
make Swift better for all the

00:01:49.846 --> 00:01:51.156 A:middle
development community.

00:01:52.346 --> 00:01:54.036 A:middle
Now as you undoubtedly heard by

00:01:54.036 --> 00:01:56.256 A:middle
now Xcode 9 introduces

00:01:56.256 --> 00:01:57.846 A:middle
refactoring support for Swift.

00:01:58.516 --> 00:02:01.736 A:middle
[ Applause ]

00:01:58.516 --> 00:02:01.736 A:middle
[ Applause ]

00:02:02.236 --> 00:02:05.256 A:middle
So, all fo the language level

00:02:05.256 --> 00:02:07.176 A:middle
bits that make refactoring work

00:02:07.176 --> 00:02:08.846 A:middle
for Swift actually lived down in

00:02:08.846 --> 00:02:09.576 A:middle
the Swift project.

00:02:09.576 --> 00:02:10.716 A:middle
So, we'll be open sourcing that

00:02:10.716 --> 00:02:11.226 A:middle
soon.

00:02:11.546 --> 00:02:12.746 A:middle
The great thing about this is

00:02:12.746 --> 00:02:14.516 A:middle
then you can check out and build

00:02:14.516 --> 00:02:16.286 A:middle
the Swift source code, build

00:02:16.286 --> 00:02:17.826 A:middle
your own refactorings and then

00:02:17.826 --> 00:02:19.226 A:middle
through the toolchain mechanism

00:02:19.226 --> 00:02:20.626 A:middle
I just talked about, try them

00:02:20.626 --> 00:02:21.626 A:middle
out in Xcode.

00:02:22.026 --> 00:02:22.866 A:middle
All right, it's a way of really

00:02:22.866 --> 00:02:23.896 A:middle
working with your development

00:02:23.896 --> 00:02:24.356 A:middle
tools.

00:02:26.186 --> 00:02:27.786 A:middle
Now, also part of our open

00:02:27.786 --> 00:02:29.266 A:middle
source ecosystem is the Swift

00:02:29.306 --> 00:02:30.126 A:middle
package manager.

00:02:30.456 --> 00:02:31.626 A:middle
So, this supports a growing

00:02:31.626 --> 00:02:33.726 A:middle
ecosystem with over 7000

00:02:33.726 --> 00:02:34.866 A:middle
packages on GitHub.

00:02:35.376 --> 00:02:36.996 A:middle
This is extremely popular for

00:02:36.996 --> 00:02:38.936 A:middle
server-side Swift, where Swift

00:02:38.936 --> 00:02:41.666 A:middle
PM makes it really easy to grab

00:02:41.666 --> 00:02:42.706 A:middle
the server components you need

00:02:42.706 --> 00:02:44.526 A:middle
to build a server-side Swift app

00:02:44.526 --> 00:02:45.536 A:middle
on Linux.

00:02:46.056 --> 00:02:47.416 A:middle
Now, the Swift Package Manager

00:02:47.416 --> 00:02:49.126 A:middle
has seen a lot of improvements

00:02:49.156 --> 00:02:49.756 A:middle
this year.

00:02:49.936 --> 00:02:51.366 A:middle
In better manifest API, better

00:02:51.786 --> 00:02:53.586 A:middle
development workflow and so on.

00:02:53.586 --> 00:02:55.796 A:middle
And also, we've made a lot of

00:02:55.796 --> 00:02:57.586 A:middle
progress toward our eventual

00:02:57.586 --> 00:02:59.316 A:middle
goal of first-class support for

00:02:59.316 --> 00:03:01.446 A:middle
Swift packages within the Xcode

00:02:59.316 --> 00:03:01.446 A:middle
Swift packages within the Xcode

00:03:01.446 --> 00:03:01.516 A:middle
IDE.

00:03:01.516 --> 00:03:03.896 A:middle
And we're getting closer to that

00:03:03.896 --> 00:03:05.396 A:middle
with the use of Swift PM as a

00:03:05.396 --> 00:03:07.256 A:middle
library, and of course, the new

00:03:07.256 --> 00:03:08.926 A:middle
Xcode build system, builds

00:03:08.926 --> 00:03:11.126 A:middle
entirely in Swift.

00:03:12.276 --> 00:03:13.516 A:middle
So, we've got a lot to cover

00:03:13.516 --> 00:03:13.836 A:middle
today.

00:03:14.616 --> 00:03:16.306 A:middle
I'll be talking about a couple

00:03:16.306 --> 00:03:17.916 A:middle
of small refinements and

00:03:17.916 --> 00:03:19.616 A:middle
additions to the language itself

00:03:20.126 --> 00:03:21.376 A:middle
before we dive into the source

00:03:21.376 --> 00:03:22.736 A:middle
compatibility story, we're going

00:03:23.016 --> 00:03:23.866 A:middle
to talk about how we can

00:03:23.866 --> 00:03:25.256 A:middle
leverage all of the code that

00:03:25.256 --> 00:03:27.266 A:middle
you've built in Swift, with

00:03:27.266 --> 00:03:28.736 A:middle
Swift 4 and Xcode 9.

00:03:29.646 --> 00:03:31.056 A:middle
My colleague Bob will talk about

00:03:31.056 --> 00:03:32.466 A:middle
Swift tools and improvements in

00:03:32.466 --> 00:03:34.366 A:middle
performance, before Ben dives

00:03:34.366 --> 00:03:36.526 A:middle
into strings, collections, and

00:03:36.526 --> 00:03:37.686 A:middle
some of the generic features of

00:03:37.686 --> 00:03:38.046 A:middle
Swift.

00:03:38.676 --> 00:03:40.316 A:middle
Finally, John will talk about

00:03:40.316 --> 00:03:41.586 A:middle
exclusive access to memory.

00:03:41.906 --> 00:03:43.306 A:middle
Which is a semantic restriction

00:03:43.306 --> 00:03:44.576 A:middle
we're introducing into the Swift

00:03:44.576 --> 00:03:46.316 A:middle
language to build for the

00:03:46.316 --> 00:03:46.716 A:middle
future.

00:03:47.606 --> 00:03:50.356 A:middle
So, let's start with one small

00:03:50.356 --> 00:03:52.016 A:middle
little feature.

00:03:53.366 --> 00:03:54.646 A:middle
Access control.

00:03:54.746 --> 00:03:56.206 A:middle
So, here are I've defined this

00:03:56.206 --> 00:03:57.216 A:middle
simple date structure.

00:03:57.906 --> 00:03:59.206 A:middle
And it's similar to the one in

00:03:59.206 --> 00:03:59.876 A:middle
foundation.

00:03:59.906 --> 00:04:00.666 A:middle
It's going to use

00:03:59.906 --> 00:04:00.666 A:middle
It's going to use

00:04:00.666 --> 00:04:02.436 A:middle
secondsSinceReferenceDate as an

00:04:02.436 --> 00:04:03.896 A:middle
internal representation, but I'm

00:04:03.896 --> 00:04:05.146 A:middle
making this private because this

00:04:05.146 --> 00:04:07.276 A:middle
isn't a good API to expose out

00:04:07.276 --> 00:04:07.996 A:middle
to my users.

00:04:08.516 --> 00:04:09.656 A:middle
I want this type to be a good

00:04:09.656 --> 00:04:11.706 A:middle
value type citizen so its

00:04:11.706 --> 00:04:13.066 A:middle
equitable and comparable.

00:04:13.506 --> 00:04:14.776 A:middle
But already this code is feeling

00:04:14.776 --> 00:04:15.706 A:middle
a little bit cluttered and

00:04:15.706 --> 00:04:16.125 A:middle
messy.

00:04:16.125 --> 00:04:17.776 A:middle
I really should break this up

00:04:18.216 --> 00:04:20.086 A:middle
into separate extensions; one

00:04:20.086 --> 00:04:21.305 A:middle
for each task, right?

00:04:21.305 --> 00:04:23.316 A:middle
This is good Swift coding style,

00:04:23.716 --> 00:04:25.226 A:middle
but Swift 3 didn't support it

00:04:25.226 --> 00:04:26.456 A:middle
very well, because you would get

00:04:26.456 --> 00:04:28.376 A:middle
this error that you can't reach

00:04:28.376 --> 00:04:30.256 A:middle
across to a private declaration

00:04:30.256 --> 00:04:31.296 A:middle
from another lexical scope.

00:04:32.206 --> 00:04:33.196 A:middle
You could fix this with

00:04:33.196 --> 00:04:34.036 A:middle
fileprivate.

00:04:34.446 --> 00:04:35.706 A:middle
But that meant the whole file

00:04:35.706 --> 00:04:38.546 A:middle
could see this member and that's

00:04:38.546 --> 00:04:39.356 A:middle
not quite right.

00:04:39.356 --> 00:04:40.326 A:middle
It's too broad.

00:04:40.786 --> 00:04:43.416 A:middle
And so, Swift 4 refines this so

00:04:43.416 --> 00:04:45.706 A:middle
that we expand the scope of what

00:04:45.706 --> 00:04:48.736 A:middle
private means to only cover the

00:04:48.886 --> 00:04:51.246 A:middle
declarations in all extensions

00:04:51.246 --> 00:04:52.706 A:middle
of a particular type within that

00:04:52.706 --> 00:04:53.566 A:middle
same source file.

00:04:53.936 --> 00:04:55.316 A:middle
This fits much better with the

00:04:55.316 --> 00:04:57.316 A:middle
notion of using extensions to

00:04:57.316 --> 00:04:57.976 A:middle
organize your code.

00:04:58.516 --> 00:05:01.546 A:middle
[ Applause ]

00:04:58.516 --> 00:05:01.546 A:middle
[ Applause ]

00:05:02.046 --> 00:05:03.336 A:middle
And with this change, let us

00:05:03.336 --> 00:05:05.176 A:middle
never speak of access control

00:05:05.176 --> 00:05:05.626 A:middle
again.

00:05:06.516 --> 00:05:09.546 A:middle
[ Laughter ]

00:05:10.046 --> 00:05:11.016 A:middle
Second, I want to talk about

00:05:11.016 --> 00:05:12.536 A:middle
composing classes and protocols.

00:05:13.006 --> 00:05:14.676 A:middle
So, here I've introduced this

00:05:14.786 --> 00:05:16.186 A:middle
shakable protocol for a UI

00:05:16.186 --> 00:05:17.656 A:middle
element that can give a little

00:05:17.656 --> 00:05:18.866 A:middle
shake effect to draw attention

00:05:18.866 --> 00:05:19.486 A:middle
to itself.

00:05:20.106 --> 00:05:21.826 A:middle
And I've gone ahead and extended

00:05:21.826 --> 00:05:23.846 A:middle
some of the UIKit classes to

00:05:24.296 --> 00:05:25.526 A:middle
actually provide this shake

00:05:25.526 --> 00:05:26.306 A:middle
functionality.

00:05:26.306 --> 00:05:27.466 A:middle
And now I want to write

00:05:27.466 --> 00:05:28.756 A:middle
something that seems simple.

00:05:28.796 --> 00:05:30.336 A:middle
I just want to write a function

00:05:30.506 --> 00:05:32.046 A:middle
that takes a bunch of controls

00:05:32.046 --> 00:05:33.556 A:middle
that are shakable and shakes the

00:05:33.556 --> 00:05:34.926 A:middle
ones that are enabled to draw

00:05:34.926 --> 00:05:36.186 A:middle
attention to them.

00:05:36.996 --> 00:05:38.486 A:middle
What type can I write here in

00:05:38.876 --> 00:05:39.546 A:middle
this array?

00:05:40.696 --> 00:05:41.866 A:middle
It's actually frustrating and

00:05:41.866 --> 00:05:42.196 A:middle
tricky.

00:05:42.616 --> 00:05:44.206 A:middle
So, I could try to use a UI

00:05:44.206 --> 00:05:44.746 A:middle
control.

00:05:44.746 --> 00:05:46.146 A:middle
But not all UI controls are

00:05:46.146 --> 00:05:47.156 A:middle
shakable in this game.

00:05:48.006 --> 00:05:49.846 A:middle
I could try shakable, but not

00:05:49.846 --> 00:05:51.536 A:middle
all shakables are UI controls.

00:05:51.536 --> 00:05:52.496 A:middle
And there's actually no good way

00:05:52.496 --> 00:05:54.506 A:middle
to represent this in Swift 3.

00:05:54.916 --> 00:05:56.986 A:middle
Swift 4 introduces the notion of

00:05:57.386 --> 00:06:00.266 A:middle
composing a class with any

00:05:57.386 --> 00:06:00.266 A:middle
composing a class with any

00:06:00.266 --> 00:06:01.326 A:middle
number of protocols.

00:06:02.516 --> 00:06:07.696 A:middle
[ Applause ]

00:06:08.196 --> 00:06:09.716 A:middle
It's a small feature, but it

00:06:09.716 --> 00:06:11.046 A:middle
just fits in nicely with the

00:06:11.046 --> 00:06:12.476 A:middle
overall set of Swift.

00:06:12.526 --> 00:06:13.826 A:middle
Now, if you come from

00:06:13.826 --> 00:06:15.376 A:middle
Objective-C background, you

00:06:15.376 --> 00:06:16.196 A:middle
already know everything about

00:06:16.196 --> 00:06:17.246 A:middle
what this does, because

00:06:17.246 --> 00:06:18.456 A:middle
Objective-C has actually had

00:06:18.456 --> 00:06:19.746 A:middle
this feature for a very long

00:06:19.746 --> 00:06:20.156 A:middle
time.

00:06:20.616 --> 00:06:22.446 A:middle
Here's a Touch Bar API where the

00:06:22.446 --> 00:06:24.836 A:middle
client is in NSView that is also

00:06:24.876 --> 00:06:26.906 A:middle
conformed to NSTextInputClient.

00:06:27.426 --> 00:06:29.386 A:middle
In Swift 3, we actually couldn't

00:06:29.386 --> 00:06:30.586 A:middle
represent that type, so we'd

00:06:30.586 --> 00:06:31.996 A:middle
import it as an NSView, which is

00:06:32.166 --> 00:06:33.386 A:middle
a little bit embarrassing.

00:06:34.326 --> 00:06:36.716 A:middle
So, Swift 4 corrects this and

00:06:36.716 --> 00:06:38.186 A:middle
now we can actually import the

00:06:38.186 --> 00:06:41.016 A:middle
type using an NSView that is an

00:06:41.046 --> 00:06:43.346 A:middle
NSTextInputClient to map all of

00:06:43.346 --> 00:06:44.526 A:middle
the APIs and appropriately.

00:06:46.516 --> 00:06:49.546 A:middle
[ Applause ]

00:06:50.046 --> 00:06:51.366 A:middle
So, there's a huge number of

00:06:51.366 --> 00:06:52.216 A:middle
great features we're going to

00:06:52.216 --> 00:06:53.046 A:middle
talk about today.

00:06:53.316 --> 00:06:54.366 A:middle
I want to call out a couple of

00:06:54.366 --> 00:06:55.566 A:middle
features in the realm of

00:06:55.566 --> 00:06:57.106 A:middle
improving on things we think of

00:06:57.106 --> 00:06:58.156 A:middle
as Cocoa idioms.

00:06:58.196 --> 00:07:00.096 A:middle
KeyPaths, Key-Value Coding,

00:06:58.196 --> 00:07:00.096 A:middle
KeyPaths, Key-Value Coding,

00:07:00.476 --> 00:07:02.736 A:middle
Archival &amp; Serialization that

00:07:02.736 --> 00:07:04.136 A:middle
are big new Swift features that

00:07:04.216 --> 00:07:05.916 A:middle
will be discussed in this other

00:07:05.916 --> 00:07:06.896 A:middle
session, "What's New in

00:07:06.896 --> 00:07:08.576 A:middle
Foundation" on Wednesday.

00:07:09.856 --> 00:07:12.656 A:middle
And these features work

00:07:12.756 --> 00:07:14.586 A:middle
beautifully with Swift value

00:07:14.586 --> 00:07:14.936 A:middle
types.

00:07:14.936 --> 00:07:16.596 A:middle
So, you can use them throughout

00:07:16.596 --> 00:07:17.666 A:middle
all of your Swift code.

00:07:19.056 --> 00:07:20.136 A:middle
In this session, they'll also

00:07:20.136 --> 00:07:21.706 A:middle
answer the aged old question,

00:07:22.096 --> 00:07:24.496 A:middle
how do I parse JSON in Swift.

00:07:26.806 --> 00:07:28.346 A:middle
All right, let's talk about

00:07:28.346 --> 00:07:29.176 A:middle
source compatibility.

00:07:30.036 --> 00:07:32.916 A:middle
So, by its nature, Swift 4 is

00:07:32.916 --> 00:07:34.306 A:middle
largely source compatible with

00:07:34.306 --> 00:07:35.126 A:middle
Swift 3.

00:07:35.676 --> 00:07:37.416 A:middle
And the reason is the language

00:07:37.566 --> 00:07:39.806 A:middle
hasn't changed all that much.

00:07:39.996 --> 00:07:41.426 A:middle
We've made some refinements.

00:07:41.426 --> 00:07:42.986 A:middle
Like the change to axis control.

00:07:43.396 --> 00:07:44.626 A:middle
We've made some additions.

00:07:44.896 --> 00:07:46.486 A:middle
Like the change to class and

00:07:46.486 --> 00:07:47.506 A:middle
protocol composition.

00:07:48.156 --> 00:07:49.436 A:middle
There's also been improvements

00:07:49.436 --> 00:07:51.906 A:middle
into the way that existing APIs

00:07:51.936 --> 00:07:53.806 A:middle
in the SDK map into Swift.

00:07:53.806 --> 00:07:55.566 A:middle
They provide better Swift APIs

00:07:55.566 --> 00:07:57.086 A:middle
than they did previously.

00:07:57.426 --> 00:07:59.566 A:middle
But the scale of such changes is

00:07:59.566 --> 00:08:01.276 A:middle
much, much smaller than say from

00:07:59.566 --> 00:08:01.276 A:middle
much, much smaller than say from

00:08:01.276 --> 00:08:03.126 A:middle
Swift 2 to 3, or even Swift 1 to

00:08:03.126 --> 00:08:03.556 A:middle
2.

00:08:04.136 --> 00:08:06.956 A:middle
And so, going from Swift 3 to 4

00:08:06.956 --> 00:08:08.626 A:middle
isn't as big of an upset to a

00:08:08.706 --> 00:08:10.026 A:middle
code base as it used to be.

00:08:10.436 --> 00:08:11.316 A:middle
And many of the features we're

00:08:11.316 --> 00:08:12.386 A:middle
talking about are purely

00:08:12.386 --> 00:08:12.866 A:middle
additive.

00:08:13.116 --> 00:08:14.536 A:middle
So, they're in some new

00:08:14.536 --> 00:08:15.476 A:middle
syntactic space.

00:08:15.476 --> 00:08:17.166 A:middle
It doesn't break code to

00:08:17.166 --> 00:08:18.566 A:middle
introduce these new features.

00:08:19.586 --> 00:08:21.426 A:middle
That said, we want a smooth

00:08:21.426 --> 00:08:22.176 A:middle
migration path.

00:08:22.626 --> 00:08:24.166 A:middle
So, we're also introducing Swift

00:08:24.366 --> 00:08:25.106 A:middle
3.2.

00:08:26.146 --> 00:08:27.456 A:middle
Most important thing about Swift

00:08:27.456 --> 00:08:29.496 A:middle
3.2 is it's not a separate

00:08:29.496 --> 00:08:30.836 A:middle
compiler or a different

00:08:30.836 --> 00:08:31.486 A:middle
toolchain.

00:08:32.246 --> 00:08:34.066 A:middle
It's a compilation mode of the

00:08:34.066 --> 00:08:36.166 A:middle
Swift 4 compiler that emulates

00:08:36.216 --> 00:08:37.316 A:middle
Swift 3 behavior.

00:08:37.926 --> 00:08:39.285 A:middle
And so if some syntax or

00:08:39.285 --> 00:08:41.256 A:middle
semantics change from Swift 3 to

00:08:41.256 --> 00:08:43.756 A:middle
4, it will provide the Swift 3

00:08:43.756 --> 00:08:44.275 A:middle
behavior.

00:08:45.226 --> 00:08:47.016 A:middle
Moreover, it understands the

00:08:47.016 --> 00:08:48.736 A:middle
changes that have been made in

00:08:48.846 --> 00:08:50.006 A:middle
the new SDK.

00:08:50.006 --> 00:08:51.236 A:middle
And so, if an API projects

00:08:51.236 --> 00:08:53.156 A:middle
differently in Swift 4 than it

00:08:53.156 --> 00:08:55.406 A:middle
did in Swift 3, it will actually

00:08:55.556 --> 00:08:57.176 A:middle
roll back those changes to the

00:08:57.176 --> 00:08:58.156 A:middle
Swift 3 view.

00:08:59.446 --> 00:09:01.726 A:middle
The end result here is that when

00:08:59.446 --> 00:09:01.726 A:middle
The end result here is that when

00:09:01.726 --> 00:09:03.196 A:middle
you open up your Swift 3 project

00:09:03.606 --> 00:09:05.096 A:middle
in Xcode 9 and build it with

00:09:05.096 --> 00:09:07.406 A:middle
Swift 3.2, pretty much

00:09:07.436 --> 00:09:09.176 A:middle
everything should just build and

00:09:09.176 --> 00:09:10.586 A:middle
work the way it did before.

00:09:11.306 --> 00:09:14.026 A:middle
And this makes fantastic path to

00:09:14.026 --> 00:09:15.906 A:middle
adopting the new features of

00:09:15.906 --> 00:09:17.886 A:middle
Swift 4, because most of them

00:09:17.886 --> 00:09:20.176 A:middle
are available also in Swift 3.2

00:09:20.596 --> 00:09:22.506 A:middle
as well as all of the great new

00:09:22.506 --> 00:09:25.696 A:middle
APIs and frameworks in this

00:09:25.736 --> 00:09:28.036 A:middle
years' SDKs.

00:09:28.266 --> 00:09:29.866 A:middle
Now, when you're ready to

00:09:29.866 --> 00:09:31.826 A:middle
migrate to Swift 4, and then, in

00:09:31.826 --> 00:09:33.376 A:middle
previous years we've always

00:09:33.376 --> 00:09:35.676 A:middle
provided a migrator to take your

00:09:35.676 --> 00:09:39.186 A:middle
code from Swift 3 and move it to

00:09:39.186 --> 00:09:39.766 A:middle
Swift 4.

00:09:40.526 --> 00:09:42.336 A:middle
Now, unlike in previous years,

00:09:42.596 --> 00:09:45.226 A:middle
this migration effort isn't stop

00:09:45.226 --> 00:09:46.836 A:middle
the world, get nothing else done

00:09:46.836 --> 00:09:48.656 A:middle
until the entire stack has been

00:09:48.656 --> 00:09:49.546 A:middle
moved forward.

00:09:50.656 --> 00:09:52.636 A:middle
The reason is Swift 3.2 and

00:09:52.636 --> 00:09:55.466 A:middle
Swift 4 can co-exist in the same

00:09:55.466 --> 00:09:56.246 A:middle
application.

00:09:57.606 --> 00:09:58.726 A:middle
And so, you can set which

00:09:58.726 --> 00:09:59.216 A:middle
version.

00:10:00.516 --> 00:10:04.226 A:middle
[ Applause ]

00:10:04.726 --> 00:10:06.506 A:middle
You can set which version of the

00:10:06.506 --> 00:10:08.006 A:middle
language you're going to use on

00:10:08.006 --> 00:10:09.426 A:middle
a per target basis.

00:10:10.046 --> 00:10:10.846 A:middle
So, if you want to migrate to

00:10:10.846 --> 00:10:12.096 A:middle
Swift 4, you can migrate your

00:10:12.096 --> 00:10:13.866 A:middle
app target, but leave all of

00:10:13.866 --> 00:10:14.686 A:middle
your frameworks and all of your

00:10:14.686 --> 00:10:16.226 A:middle
other dependencies in Swift 3.2.

00:10:16.466 --> 00:10:16.936 A:middle
That's fine.

00:10:17.516 --> 00:10:18.766 A:middle
As your dependencies update and

00:10:18.766 --> 00:10:20.006 A:middle
move to Swift 4, that's

00:10:20.006 --> 00:10:21.516 A:middle
perfectly fine, they can work

00:10:21.666 --> 00:10:22.906 A:middle
with your app, whether it's in

00:10:22.906 --> 00:10:24.426 A:middle
Swift 3.2 or Swift 4.

00:10:25.196 --> 00:10:26.996 A:middle
The Swift Package Manager also

00:10:26.996 --> 00:10:27.966 A:middle
understands this.

00:10:28.456 --> 00:10:29.756 A:middle
And so, it will build packages

00:10:29.756 --> 00:10:31.246 A:middle
with the tools version that was

00:10:31.246 --> 00:10:33.536 A:middle
used to develop the package and

00:10:33.536 --> 00:10:34.946 A:middle
if a package supports multiple

00:10:34.946 --> 00:10:36.116 A:middle
Swift language versions, that

00:10:36.116 --> 00:10:37.076 A:middle
can be described in the

00:10:37.076 --> 00:10:38.696 A:middle
manifest, so the Swift Package

00:10:38.696 --> 00:10:39.696 A:middle
Manager will do the right thing.

00:10:40.756 --> 00:10:42.466 A:middle
Now, we think that with Swift

00:10:42.466 --> 00:10:44.316 A:middle
3.2 and Swift 4 co-existence,

00:10:44.376 --> 00:10:45.776 A:middle
with the smaller amount of

00:10:46.046 --> 00:10:48.336 A:middle
change from Swift 3 to Swift 4

00:10:48.396 --> 00:10:50.766 A:middle
that you'll get a nice buttery

00:10:50.766 --> 00:10:52.526 A:middle
smooth migration path to Swift

00:10:52.526 --> 00:10:52.776 A:middle
4.

00:10:54.086 --> 00:10:55.376 A:middle
And with that, I'd like to bring

00:10:55.376 --> 00:10:56.166 A:middle
up Bob to talk about

00:10:56.166 --> 00:10:56.966 A:middle
improvements to the build.

00:10:57.516 --> 00:11:03.046 A:middle
[ Applause ]

00:10:57.516 --> 00:11:03.046 A:middle
[ Applause ]

00:11:03.546 --> 00:11:05.256 A:middle
&gt;&gt; As the size and complexity of

00:11:05.256 --> 00:11:07.016 A:middle
your Swift apps continues to

00:11:07.016 --> 00:11:08.996 A:middle
grow, we've been investing in

00:11:08.996 --> 00:11:10.556 A:middle
improvements in the build system

00:11:10.556 --> 00:11:12.036 A:middle
to keep up with that growth.

00:11:13.826 --> 00:11:15.826 A:middle
Xcode 9 has a brand-new

00:11:15.826 --> 00:11:17.186 A:middle
implementation of the build

00:11:17.256 --> 00:11:17.636 A:middle
system.

00:11:18.006 --> 00:11:19.686 A:middle
Of course, it's written in Swift

00:11:19.976 --> 00:11:21.246 A:middle
and it's built on top of the

00:11:21.246 --> 00:11:23.606 A:middle
open source LLBuild engine.

00:11:24.326 --> 00:11:26.476 A:middle
It is really fast at calculating

00:11:26.476 --> 00:11:28.046 A:middle
the dependencies between the

00:11:28.046 --> 00:11:29.536 A:middle
different steps of your build.

00:11:30.246 --> 00:11:31.396 A:middle
You're most likely to notice

00:11:31.446 --> 00:11:32.896 A:middle
that when doing an incremental

00:11:32.896 --> 00:11:34.736 A:middle
build of a large project.

00:11:35.886 --> 00:11:37.866 A:middle
This is a technology preview in

00:11:37.996 --> 00:11:38.616 A:middle
Xcode 9.

00:11:38.846 --> 00:11:40.206 A:middle
We'd love to have you try it

00:11:40.206 --> 00:11:40.636 A:middle
out.

00:11:40.876 --> 00:11:42.656 A:middle
So, go to the project or

00:11:42.656 --> 00:11:44.486 A:middle
workspace settings in the file

00:11:44.486 --> 00:11:46.796 A:middle
menu and choose the new build

00:11:47.506 --> 00:11:47.686 A:middle
system.

00:11:48.936 --> 00:11:50.916 A:middle
Besides having a faster build

00:11:50.976 --> 00:11:53.026 A:middle
system, another way we can use

00:11:53.026 --> 00:11:54.876 A:middle
your system more efficiently is

00:11:54.876 --> 00:11:56.656 A:middle
to avoid doing redundant work.

00:11:57.186 --> 00:11:58.896 A:middle
And Xcode 9 does this in a few

00:11:58.896 --> 00:12:00.366 A:middle
different ways.

00:11:58.896 --> 00:12:00.366 A:middle
different ways.

00:12:01.296 --> 00:12:03.816 A:middle
The precompiled bridging header

00:12:04.156 --> 00:12:05.956 A:middle
speeds up the build of large

00:12:06.066 --> 00:12:07.506 A:middle
mixed source projects.

00:12:08.246 --> 00:12:10.056 A:middle
The bridging header describes

00:12:10.056 --> 00:12:11.116 A:middle
the interfaces in your

00:12:11.116 --> 00:12:13.116 A:middle
Objective-C code so they can be

00:12:13.116 --> 00:12:14.676 A:middle
used in your Swift code.

00:12:15.516 --> 00:12:16.476 A:middle
If you have a lot of

00:12:16.476 --> 00:12:18.556 A:middle
Objective-C, the bridging header

00:12:18.556 --> 00:12:20.496 A:middle
can be really large and slow to

00:12:20.496 --> 00:12:21.446 A:middle
compile.

00:12:21.996 --> 00:12:23.656 A:middle
And parsing the contents of that

00:12:23.656 --> 00:12:25.706 A:middle
header repeatedly for every one

00:12:25.706 --> 00:12:27.786 A:middle
of your Swift files is wasteful.

00:12:29.326 --> 00:12:31.256 A:middle
The Apple LLVM compiler has a

00:12:31.256 --> 00:12:32.506 A:middle
great solution for this,

00:12:33.196 --> 00:12:34.426 A:middle
precompiled headers.

00:12:35.916 --> 00:12:38.046 A:middle
Xcode 9 will now use a

00:12:38.096 --> 00:12:39.886 A:middle
precompiled version of the

00:12:39.886 --> 00:12:41.846 A:middle
bridging header so that it only

00:12:41.846 --> 00:12:43.256 A:middle
needs to be parsed once.

00:12:45.166 --> 00:12:47.416 A:middle
Apple's music app is a great

00:12:47.416 --> 00:12:49.666 A:middle
example where this helps a lot.

00:12:49.866 --> 00:12:51.676 A:middle
Music is a really large project

00:12:51.676 --> 00:12:53.126 A:middle
and it's split about evenly

00:12:53.186 --> 00:12:54.846 A:middle
between Objective-C and Swift.

00:12:55.886 --> 00:12:57.446 A:middle
Using a precompiled bridging

00:12:57.446 --> 00:12:59.156 A:middle
header, which is the default in

00:12:59.236 --> 00:13:01.396 A:middle
Xcode 9, speeds up the debug

00:12:59.236 --> 00:13:01.396 A:middle
Xcode 9, speeds up the debug

00:13:01.396 --> 00:13:03.666 A:middle
build of music by about 40%.

00:13:04.426 --> 00:13:09.326 A:middle
Code coverage testing is another

00:13:09.326 --> 00:13:11.846 A:middle
powerful tool, but in Xcode 8,

00:13:11.846 --> 00:13:13.576 A:middle
it can also be a source of

00:13:13.576 --> 00:13:14.586 A:middle
redundant effort.

00:13:15.616 --> 00:13:16.996 A:middle
Consider the common scenario

00:13:16.996 --> 00:13:18.206 A:middle
where you make some changes to

00:13:18.206 --> 00:13:20.276 A:middle
your code, you get it to build

00:13:20.276 --> 00:13:21.126 A:middle
and then you want to run your

00:13:21.196 --> 00:13:22.226 A:middle
tests with coverage.

00:13:23.356 --> 00:13:24.586 A:middle
Here's what that looks like in

00:13:24.586 --> 00:13:25.986 A:middle
Xcode's report navigator.

00:13:27.166 --> 00:13:29.046 A:middle
Notice there's an extra build.

00:13:29.686 --> 00:13:30.746 A:middle
Why is that there?

00:13:32.046 --> 00:13:33.796 A:middle
Coverage testing is implemented

00:13:33.796 --> 00:13:35.556 A:middle
in the compiler by admitting

00:13:35.556 --> 00:13:37.746 A:middle
extra instrumentation code to

00:13:37.746 --> 00:13:39.086 A:middle
count the number of times each

00:13:39.086 --> 00:13:40.226 A:middle
fragment of code runs.

00:13:41.296 --> 00:13:43.106 A:middle
With Xcode 8, the normal build

00:13:43.106 --> 00:13:44.356 A:middle
does not include that

00:13:44.356 --> 00:13:45.176 A:middle
instrumentation.

00:13:45.176 --> 00:13:46.336 A:middle
So, before you can run your

00:13:46.426 --> 00:13:48.396 A:middle
tests with coverage, the whole

00:13:48.396 --> 00:13:49.986 A:middle
project needs to be rebuilt.

00:13:50.596 --> 00:13:54.896 A:middle
In Xcode 9, we're combining

00:13:54.896 --> 00:13:55.596 A:middle
those builds.

00:13:56.016 --> 00:13:57.726 A:middle
If you have coverage enabled for

00:13:57.726 --> 00:14:00.126 A:middle
testing, the normal build will

00:13:57.726 --> 00:14:00.126 A:middle
testing, the normal build will

00:14:00.126 --> 00:14:01.456 A:middle
include the instrumentation.

00:14:02.246 --> 00:14:03.736 A:middle
There's a very small cost for

00:14:03.736 --> 00:14:03.946 A:middle
this.

00:14:04.276 --> 00:14:06.246 A:middle
Less than 3% for one project

00:14:06.246 --> 00:14:06.926 A:middle
that we measured.

00:14:07.876 --> 00:14:10.076 A:middle
But you get a huge benefit,

00:14:10.146 --> 00:14:11.226 A:middle
because now you only need to

00:14:11.226 --> 00:14:12.866 A:middle
build your project once in that

00:14:12.866 --> 00:14:13.406 A:middle
scenario.

00:14:15.856 --> 00:14:18.426 A:middle
This next change is not actually

00:14:18.426 --> 00:14:19.776 A:middle
about making your build faster.

00:14:20.646 --> 00:14:21.826 A:middle
It's about avoiding this.

00:14:24.036 --> 00:14:24.306 A:middle
So.

00:14:25.516 --> 00:14:29.016 A:middle
[ Applause ]

00:14:29.516 --> 00:14:30.676 A:middle
Indexing is great.

00:14:30.816 --> 00:14:32.496 A:middle
It's a key to some of Xcode's

00:14:32.496 --> 00:14:33.956 A:middle
most powerful features like the

00:14:33.956 --> 00:14:35.746 A:middle
new global rename re-factoring,

00:14:36.676 --> 00:14:38.236 A:middle
but indexing in the background

00:14:38.586 --> 00:14:39.446 A:middle
wastes effort.

00:14:40.886 --> 00:14:42.476 A:middle
Whenever you build your project

00:14:42.856 --> 00:14:44.226 A:middle
the compiler needs to look up

00:14:44.226 --> 00:14:45.956 A:middle
all the same symbol information

00:14:46.216 --> 00:14:47.476 A:middle
that's needed for the symbol

00:14:47.476 --> 00:14:47.926 A:middle
index.

00:14:48.306 --> 00:14:50.606 A:middle
And so, now in Xcode 9 we will

00:14:50.606 --> 00:14:52.456 A:middle
automatically update the index

00:14:52.506 --> 00:14:54.176 A:middle
whenever you build your project.

00:14:54.796 --> 00:14:56.486 A:middle
There's a very small overhead

00:14:56.486 --> 00:14:58.566 A:middle
for that at the build time, but

00:14:58.566 --> 00:15:00.016 A:middle
then there's no need to repeat

00:14:58.566 --> 00:15:00.016 A:middle
then there's no need to repeat

00:15:00.016 --> 00:15:01.686 A:middle
all that work again in the

00:15:01.686 --> 00:15:02.306 A:middle
background.

00:15:02.946 --> 00:15:05.776 A:middle
So, we have a new build system

00:15:05.866 --> 00:15:07.606 A:middle
and several different ways of

00:15:07.606 --> 00:15:08.796 A:middle
using the system more

00:15:08.796 --> 00:15:10.806 A:middle
efficiently that especially for

00:15:10.806 --> 00:15:12.116 A:middle
those of you with large Swift

00:15:12.116 --> 00:15:13.906 A:middle
projects we think are going to

00:15:13.906 --> 00:15:14.836 A:middle
be a great improvement.

00:15:16.256 --> 00:15:17.656 A:middle
Let's turn now and look at

00:15:17.656 --> 00:15:18.966 A:middle
runtime performance.

00:15:20.276 --> 00:15:22.406 A:middle
Delivering high performance code

00:15:22.406 --> 00:15:24.266 A:middle
has always been one of the key

00:15:24.266 --> 00:15:25.356 A:middle
goals for Swift.

00:15:25.446 --> 00:15:26.786 A:middle
And with each new release of

00:15:26.786 --> 00:15:28.266 A:middle
Swift, performance has

00:15:28.266 --> 00:15:28.906 A:middle
increased.

00:15:29.776 --> 00:15:31.806 A:middle
The next step is to make that

00:15:31.806 --> 00:15:33.306 A:middle
performance more predictable,

00:15:33.366 --> 00:15:34.066 A:middle
more stable.

00:15:35.736 --> 00:15:37.146 A:middle
Let's look at an example with

00:15:37.146 --> 00:15:37.746 A:middle
Swift 3.

00:15:38.736 --> 00:15:40.956 A:middle
Here I have a simple protocol

00:15:40.956 --> 00:15:42.266 A:middle
ordered with a comparison

00:15:42.266 --> 00:15:44.366 A:middle
function, and another function

00:15:44.706 --> 00:15:46.186 A:middle
that's going to test that by

00:15:46.306 --> 00:15:47.696 A:middle
sorting an array of values,

00:15:48.026 --> 00:15:49.146 A:middle
using the comparison.

00:15:50.006 --> 00:15:51.696 A:middle
The code is written in a very

00:15:51.696 --> 00:15:52.546 A:middle
general way.

00:15:52.616 --> 00:15:54.256 A:middle
It has to work with any value

00:15:54.256 --> 00:15:55.806 A:middle
that conforms to the ordered

00:15:55.806 --> 00:15:56.606 A:middle
protocol.

00:15:57.236 --> 00:15:58.476 A:middle
Even the different elements

00:15:58.476 --> 00:15:59.436 A:middle
within the array could be

00:15:59.436 --> 00:16:00.366 A:middle
different types.

00:15:59.436 --> 00:16:00.366 A:middle
different types.

00:16:01.546 --> 00:16:02.766 A:middle
Let's look at the performance of

00:16:02.816 --> 00:16:02.976 A:middle
this.

00:16:04.756 --> 00:16:06.436 A:middle
This graph shows the time in

00:16:06.486 --> 00:16:09.236 A:middle
seconds to sort 100,000 arrays

00:16:09.236 --> 00:16:10.506 A:middle
of 100 elements each.

00:16:10.936 --> 00:16:12.466 A:middle
And it's measuring for different

00:16:12.466 --> 00:16:13.966 A:middle
sizes of array elements.

00:16:14.166 --> 00:16:16.846 A:middle
So, for a one-work struct, it

00:16:16.846 --> 00:16:18.006 A:middle
takes a little less than 2

00:16:18.006 --> 00:16:19.576 A:middle
seconds to do those sorts.

00:16:20.576 --> 00:16:22.286 A:middle
If for some reason the size of

00:16:22.286 --> 00:16:24.236 A:middle
the values increases to 2 words,

00:16:24.986 --> 00:16:26.656 A:middle
the time increases only very

00:16:26.746 --> 00:16:27.176 A:middle
slightly.

00:16:27.176 --> 00:16:29.626 A:middle
And if it grows to three words,

00:16:30.136 --> 00:16:31.456 A:middle
it continues on that same

00:16:31.456 --> 00:16:32.146 A:middle
trajectory.

00:16:33.506 --> 00:16:34.586 A:middle
What about if we have four

00:16:34.586 --> 00:16:35.416 A:middle
words.

00:16:36.846 --> 00:16:38.156 A:middle
We hit a performance cliff.

00:16:38.566 --> 00:16:40.236 A:middle
It's nine times slower.

00:16:41.566 --> 00:16:43.326 A:middle
What just happened here?

00:16:44.756 --> 00:16:46.586 A:middle
To understand this performance

00:16:46.586 --> 00:16:48.326 A:middle
cliff we need to delve into the

00:16:48.326 --> 00:16:49.736 A:middle
implementation of Swift.

00:16:50.106 --> 00:16:51.316 A:middle
If you're interested in this, I

00:16:51.316 --> 00:16:52.206 A:middle
recommend you watch

00:16:52.306 --> 00:16:53.866 A:middle
Understanding Swift Performance

00:16:53.966 --> 00:16:54.726 A:middle
from last year.

00:16:55.306 --> 00:16:57.606 A:middle
For now, I'll just give a quick

00:16:57.606 --> 00:16:57.976 A:middle
summary.

00:16:58.756 --> 00:17:01.246 A:middle
To represent a value of unknown

00:16:58.756 --> 00:17:01.246 A:middle
To represent a value of unknown

00:17:01.246 --> 00:17:03.496 A:middle
type, the compiler uses a data

00:17:03.496 --> 00:17:04.536 A:middle
structure that we call an

00:17:04.536 --> 00:17:05.756 A:middle
existential container.

00:17:06.695 --> 00:17:08.506 A:middle
Inside the existential container

00:17:08.896 --> 00:17:10.306 A:middle
there's an in-line buffer to

00:17:10.306 --> 00:17:11.566 A:middle
hold small values.

00:17:13.215 --> 00:17:14.506 A:middle
We're currently reassessing the

00:17:14.576 --> 00:17:15.766 A:middle
size of that buffer, but for

00:17:15.766 --> 00:17:18.086 A:middle
Swift 4 it remains the same 3

00:17:18.086 --> 00:17:19.195 A:middle
words that it's been in the

00:17:19.195 --> 00:17:19.566 A:middle
past.

00:17:21.386 --> 00:17:23.266 A:middle
If the value is too big to fit

00:17:23.266 --> 00:17:25.226 A:middle
in the in-line buffer, then it's

00:17:25.226 --> 00:17:26.465 A:middle
allocated on the heap.

00:17:27.435 --> 00:17:29.556 A:middle
And heap storage can be really

00:17:29.556 --> 00:17:30.116 A:middle
expensive.

00:17:31.016 --> 00:17:32.136 A:middle
That's what caused the

00:17:32.136 --> 00:17:33.486 A:middle
performance quit that we just

00:17:33.536 --> 00:17:33.906 A:middle
saw.

00:17:35.216 --> 00:17:36.266 A:middle
So, what can we do about it?

00:17:37.696 --> 00:17:39.586 A:middle
The answer is cow buffers,

00:17:40.076 --> 00:17:41.586 A:middle
existential cow buffers

00:17:41.821 --> 00:17:43.821 A:middle
[laughter].

00:17:44.056 --> 00:17:45.276 A:middle
No not that kind of cow.

00:17:45.756 --> 00:17:47.736 A:middle
COW is an acronym for copy on

00:17:47.736 --> 00:17:48.016 A:middle
right.

00:17:48.446 --> 00:17:49.646 A:middle
You may have heard us talk about

00:17:49.646 --> 00:17:51.006 A:middle
this before because it's a key

00:17:51.006 --> 00:17:52.886 A:middle
to high performance with value

00:17:52.966 --> 00:17:53.446 A:middle
semantics.

00:17:55.506 --> 00:17:57.796 A:middle
With Swift 4, if a value is too

00:17:57.796 --> 00:17:59.836 A:middle
big to fit in the inline buffer,

00:18:00.286 --> 00:18:02.326 A:middle
it's allocated on the heap along

00:18:02.326 --> 00:18:03.396 A:middle
with a reference count.

00:18:04.096 --> 00:18:05.976 A:middle
Multiple existential containers

00:18:06.026 --> 00:18:07.796 A:middle
can share the same buffer as

00:18:07.796 --> 00:18:08.936 A:middle
long as they're only reading

00:18:08.936 --> 00:18:09.246 A:middle
from it.

00:18:09.636 --> 00:18:11.186 A:middle
And that avoids a lot of

00:18:11.186 --> 00:18:12.936 A:middle
expensive heap allocation.

00:18:13.926 --> 00:18:15.326 A:middle
The buffer only needs to be

00:18:15.326 --> 00:18:16.736 A:middle
copied with a separate

00:18:16.736 --> 00:18:19.186 A:middle
allocation if it's modified

00:18:19.406 --> 00:18:20.546 A:middle
while there are multiple

00:18:20.546 --> 00:18:21.386 A:middle
references to it.

00:18:22.076 --> 00:18:23.336 A:middle
And Swift now manages the

00:18:23.336 --> 00:18:24.566 A:middle
complexity of that for you

00:18:24.566 --> 00:18:25.856 A:middle
completely automatically.

00:18:27.356 --> 00:18:28.246 A:middle
What's the impact on the

00:18:28.246 --> 00:18:28.866 A:middle
performance?

00:18:30.166 --> 00:18:31.436 A:middle
It's much more stable.

00:18:32.246 --> 00:18:34.256 A:middle
Instead of taking over 18

00:18:34.326 --> 00:18:35.946 A:middle
seconds to sort those forward

00:18:35.946 --> 00:18:37.726 A:middle
structs it's now only a little

00:18:37.726 --> 00:18:38.926 A:middle
more than 4 seconds.

00:18:39.536 --> 00:18:41.266 A:middle
It's a gentle slope instead of

00:18:41.266 --> 00:18:42.146 A:middle
that steep cliff.

00:18:42.806 --> 00:18:45.846 A:middle
This improvement applies to the

00:18:45.846 --> 00:18:46.946 A:middle
case where the compiler is

00:18:46.946 --> 00:18:48.216 A:middle
dealing with values where it

00:18:48.216 --> 00:18:49.536 A:middle
doesn't know the type at all.

00:18:50.246 --> 00:18:51.616 A:middle
But a similar issue comes up

00:18:51.616 --> 00:18:53.156 A:middle
with generic code, where the

00:18:53.156 --> 00:18:54.586 A:middle
type is parameterized.

00:18:55.266 --> 00:18:56.366 A:middle
Let's look at that.

00:18:58.316 --> 00:18:59.806 A:middle
In many cases, the compiler's

00:18:59.806 --> 00:19:01.486 A:middle
able to make generic code fast

00:18:59.806 --> 00:19:01.486 A:middle
able to make generic code fast

00:19:01.976 --> 00:19:03.696 A:middle
by using specialized versions

00:19:04.096 --> 00:19:05.206 A:middle
for specific types.

00:19:05.896 --> 00:19:07.176 A:middle
But sometimes the compiler

00:19:07.176 --> 00:19:09.026 A:middle
cannot see the specific types

00:19:09.106 --> 00:19:10.746 A:middle
and then it needs to use

00:19:10.746 --> 00:19:12.336 A:middle
unspecialized generic code.

00:19:13.206 --> 00:19:14.896 A:middle
That can be much slower.

00:19:15.306 --> 00:19:16.526 A:middle
It's another form of a

00:19:16.526 --> 00:19:17.436 A:middle
performance cliff.

00:19:18.676 --> 00:19:20.656 A:middle
Until now, Swift has used heap

00:19:20.656 --> 00:19:22.546 A:middle
allocation for generic buffers

00:19:22.546 --> 00:19:23.866 A:middle
in unspecialized code.

00:19:24.156 --> 00:19:25.946 A:middle
And as we've just seen, heap

00:19:25.946 --> 00:19:27.866 A:middle
allocation can be really slow.

00:19:28.776 --> 00:19:31.236 A:middle
Swift 4 now uses stack allocated

00:19:31.236 --> 00:19:32.136 A:middle
generic buffers.

00:19:32.486 --> 00:19:34.166 A:middle
So, we get similar improvement

00:19:34.446 --> 00:19:37.906 A:middle
for unspecialized generic code.

00:19:38.136 --> 00:19:39.886 A:middle
Now making Swift performance

00:19:39.976 --> 00:19:41.846 A:middle
really predictable is an ongoing

00:19:41.846 --> 00:19:42.226 A:middle
effort.

00:19:42.756 --> 00:19:45.056 A:middle
But Swift 4 has made big strides

00:19:45.346 --> 00:19:46.596 A:middle
to fix some of the worst of

00:19:46.596 --> 00:19:49.576 A:middle
those performance cliffs.

00:19:50.176 --> 00:19:51.736 A:middle
Another dimension of performance

00:19:51.996 --> 00:19:52.576 A:middle
is size.

00:19:54.196 --> 00:19:56.006 A:middle
As your apps grow larger and

00:19:56.006 --> 00:19:58.446 A:middle
larger, code size is becoming

00:19:58.516 --> 00:19:59.786 A:middle
increasingly important.

00:20:01.096 --> 00:20:02.656 A:middle
One way to make code size

00:20:02.656 --> 00:20:05.376 A:middle
smaller is to avoid unused code.

00:20:06.606 --> 00:20:08.166 A:middle
Let's return to Doug's example

00:20:08.166 --> 00:20:09.566 A:middle
of a date struct.

00:20:10.126 --> 00:20:11.656 A:middle
As with any value type, it's a

00:20:11.656 --> 00:20:13.536 A:middle
good idea to make it conform to

00:20:13.536 --> 00:20:14.956 A:middle
the equatable and comparable

00:20:14.956 --> 00:20:15.516 A:middle
protocols.

00:20:16.476 --> 00:20:17.766 A:middle
But what if it turns out that

00:20:17.766 --> 00:20:19.216 A:middle
your app isn't using one of

00:20:19.216 --> 00:20:19.466 A:middle
those.

00:20:20.196 --> 00:20:21.656 A:middle
You shouldn't have to pay for

00:20:21.686 --> 00:20:25.366 A:middle
code that you don't use.

00:20:25.556 --> 00:20:27.966 A:middle
In Swift 4, compiler will

00:20:27.966 --> 00:20:30.536 A:middle
automatically optimize away

00:20:30.536 --> 00:20:32.146 A:middle
conformances that are used so

00:20:32.146 --> 00:20:33.336 A:middle
you don't pay the price for

00:20:33.336 --> 00:20:33.616 A:middle
that.

00:20:34.296 --> 00:20:35.686 A:middle
And note that this interacts

00:20:35.686 --> 00:20:37.336 A:middle
with other optimizations such as

00:20:37.336 --> 00:20:39.186 A:middle
de-virtualization and in-lining

00:20:39.496 --> 00:20:41.616 A:middle
that exposes other opportunities

00:20:41.616 --> 00:20:42.946 A:middle
for the compiler to remove

00:20:42.946 --> 00:20:44.086 A:middle
unused conformances.

00:20:44.746 --> 00:20:47.326 A:middle
So, this is optimization the

00:20:47.326 --> 00:20:48.876 A:middle
compiler can do completely

00:20:48.876 --> 00:20:49.596 A:middle
automatically.

00:20:50.436 --> 00:20:51.816 A:middle
That isn't always possible.

00:20:52.646 --> 00:20:54.466 A:middle
Let's look at another one.

00:20:55.456 --> 00:20:57.956 A:middle
Here, I have a very simple class

00:20:57.956 --> 00:20:58.776 A:middle
with two functions.

00:20:59.816 --> 00:21:01.156 A:middle
The compiler will generate those

00:20:59.816 --> 00:21:01.156 A:middle
The compiler will generate those

00:21:01.156 --> 00:21:05.126 A:middle
functions and because in Swift 3

00:21:05.126 --> 00:21:07.316 A:middle
this is a subclass of NSObject,

00:21:08.106 --> 00:21:10.536 A:middle
the language will automatically

00:21:10.536 --> 00:21:12.716 A:middle
infer, the compiler will infer

00:21:12.716 --> 00:21:14.036 A:middle
the objc attribute.

00:21:15.416 --> 00:21:16.806 A:middle
What that means is these

00:21:16.806 --> 00:21:18.226 A:middle
functions should be accessible

00:21:18.226 --> 00:21:19.366 A:middle
from Objective-C.

00:21:20.376 --> 00:21:22.066 A:middle
And so, the compiler will

00:21:22.066 --> 00:21:24.506 A:middle
generate thunk functions that

00:21:24.506 --> 00:21:25.566 A:middle
are compatible with the

00:21:25.566 --> 00:21:27.146 A:middle
Objective-C conventions and that

00:21:27.196 --> 00:21:29.056 A:middle
forward to the Swift functions.

00:21:30.756 --> 00:21:32.756 A:middle
Now, functions within Swift are

00:21:32.756 --> 00:21:33.846 A:middle
still called directly.

00:21:34.176 --> 00:21:36.016 A:middle
In my example, show calls print.

00:21:36.766 --> 00:21:37.996 A:middle
And what that means is that the

00:21:37.996 --> 00:21:39.576 A:middle
thunk functions often end up

00:21:39.576 --> 00:21:40.426 A:middle
being unused.

00:21:41.026 --> 00:21:44.646 A:middle
But because they are exposed to

00:21:44.646 --> 00:21:45.956 A:middle
the Objective-C runtime the

00:21:45.956 --> 00:21:47.846 A:middle
compiler has no way to tell that

00:21:47.846 --> 00:21:48.416 A:middle
they're unused.

00:21:49.036 --> 00:21:51.196 A:middle
Fixing this requires changing

00:21:51.196 --> 00:21:52.126 A:middle
the language model.

00:21:53.256 --> 00:21:55.806 A:middle
And so, in Swift 4, the objc

00:21:55.806 --> 00:21:57.846 A:middle
attribute is only inferred in

00:21:57.906 --> 00:21:59.306 A:middle
situations where it's clearly

00:21:59.306 --> 00:21:59.626 A:middle
needed.

00:21:59.686 --> 00:22:00.936 A:middle
Such as when you're overriding

00:21:59.686 --> 00:22:00.936 A:middle
Such as when you're overriding

00:22:00.936 --> 00:22:02.426 A:middle
an Objective-C method or

00:22:02.426 --> 00:22:03.966 A:middle
conforming to an Objective-C

00:22:04.016 --> 00:22:04.776 A:middle
protocol.

00:22:05.656 --> 00:22:08.036 A:middle
This change avoids a lot of

00:22:08.036 --> 00:22:09.286 A:middle
those unused thunks.

00:22:10.796 --> 00:22:12.536 A:middle
When we adopted this in Apple's

00:22:12.536 --> 00:22:14.026 A:middle
Music App, it reduced the code

00:22:14.076 --> 00:22:14.976 A:middle
size by almost 6%.

00:22:19.566 --> 00:22:21.266 A:middle
When you have a set of functions

00:22:21.616 --> 00:22:23.106 A:middle
that you want to make accessible

00:22:23.106 --> 00:22:25.136 A:middle
and Objective-C, we recommend

00:22:25.196 --> 00:22:26.126 A:middle
that you put them in an

00:22:26.126 --> 00:22:28.336 A:middle
extension and mark the extension

00:22:28.336 --> 00:22:29.546 A:middle
with the objc attribute.

00:22:30.026 --> 00:22:31.436 A:middle
This guarantees that all those

00:22:31.436 --> 00:22:32.696 A:middle
functions will be available to

00:22:32.696 --> 00:22:33.866 A:middle
your Objective-C code.

00:22:34.416 --> 00:22:35.846 A:middle
And if that's not possible for

00:22:35.846 --> 00:22:38.436 A:middle
some reason, the compiler will

00:22:38.436 --> 00:22:38.976 A:middle
report an error to you.

00:22:41.556 --> 00:22:43.316 A:middle
So, what does it take to adopt

00:22:43.316 --> 00:22:43.976 A:middle
this change?

00:22:44.476 --> 00:22:45.906 A:middle
Doug mentioned the migrator tool

00:22:45.906 --> 00:22:47.186 A:middle
to help you move your code into

00:22:47.186 --> 00:22:47.886 A:middle
Swift 4.

00:22:48.506 --> 00:22:50.486 A:middle
With objc inference the migrator

00:22:50.486 --> 00:22:51.416 A:middle
offers you a choice.

00:22:52.046 --> 00:22:53.336 A:middle
If you don't care that much

00:22:53.336 --> 00:22:55.246 A:middle
about code size, the migrator

00:22:55.246 --> 00:22:57.056 A:middle
can easily match the Swift 3

00:22:57.056 --> 00:22:59.056 A:middle
behavior by simply inserting the

00:22:59.056 --> 00:23:00.816 A:middle
objc attribute wherever it would

00:22:59.056 --> 00:23:00.816 A:middle
objc attribute wherever it would

00:23:00.816 --> 00:23:02.276 A:middle
previously have been inferred.

00:23:03.156 --> 00:23:04.496 A:middle
But with just a little more

00:23:04.496 --> 00:23:06.206 A:middle
effort, you can take advantage

00:23:06.206 --> 00:23:08.226 A:middle
of the code size improvements by

00:23:08.226 --> 00:23:09.766 A:middle
using minimal inference.

00:23:10.316 --> 00:23:13.206 A:middle
If you go with that option for

00:23:13.206 --> 00:23:15.256 A:middle
minimal inference, the migrator

00:23:15.256 --> 00:23:17.456 A:middle
will start by finding all the

00:23:17.456 --> 00:23:18.956 A:middle
places where it can determine

00:23:18.956 --> 00:23:20.786 A:middle
the objc attribute is definitely

00:23:20.786 --> 00:23:21.216 A:middle
needed.

00:23:21.216 --> 00:23:22.646 A:middle
And it will do that, it will

00:23:22.646 --> 00:23:23.886 A:middle
insert that automatically.

00:23:24.966 --> 00:23:26.386 A:middle
That may not be sufficient

00:23:26.816 --> 00:23:28.416 A:middle
because the migrator is unable

00:23:28.416 --> 00:23:30.626 A:middle
to detect issues across separate

00:23:30.626 --> 00:23:32.226 A:middle
Swift modules or in your

00:23:32.226 --> 00:23:33.246 A:middle
Objective-C code.

00:23:34.106 --> 00:23:35.496 A:middle
So, to help you find those

00:23:35.496 --> 00:23:38.736 A:middle
places, the migrator will mark

00:23:38.736 --> 00:23:39.776 A:middle
the thunk functions that are

00:23:39.776 --> 00:23:42.046 A:middle
inferred as deprecated.

00:23:42.766 --> 00:23:44.166 A:middle
And you can then build your code

00:23:44.166 --> 00:23:45.466 A:middle
and run your code and look for

00:23:45.466 --> 00:23:46.516 A:middle
deprecation warnings.

00:23:47.806 --> 00:23:49.306 A:middle
Let's look at that more closely.

00:23:50.336 --> 00:23:51.936 A:middle
Here's an example of a build

00:23:51.936 --> 00:23:52.236 A:middle
warning.

00:23:53.246 --> 00:23:55.266 A:middle
I've got a Swift function to

00:23:55.266 --> 00:23:56.596 A:middle
show the status of my view

00:23:56.596 --> 00:23:57.116 A:middle
controller.

00:23:57.576 --> 00:23:58.786 A:middle
And I'm calling that from my

00:23:58.786 --> 00:23:59.806 A:middle
Objective-C code.

00:24:00.226 --> 00:24:01.706 A:middle
But because I'm still relying on

00:24:01.706 --> 00:24:03.236 A:middle
the objc inference, I get this

00:24:03.236 --> 00:24:04.666 A:middle
warning about it being

00:24:04.666 --> 00:24:05.356 A:middle
deprecated.

00:24:05.906 --> 00:24:08.216 A:middle
To fix this, I need to go and

00:24:08.306 --> 00:24:09.976 A:middle
find the place in my Swift code

00:24:09.976 --> 00:24:11.356 A:middle
where the function is defined

00:24:11.986 --> 00:24:13.756 A:middle
and add the objc attribute.

00:24:14.256 --> 00:24:19.076 A:middle
Some of the issues may not be

00:24:19.076 --> 00:24:20.326 A:middle
visible at build time.

00:24:20.366 --> 00:24:22.026 A:middle
In Objective-C, it's possible to

00:24:22.026 --> 00:24:24.156 A:middle
refer to a function in ways that

00:24:24.156 --> 00:24:26.136 A:middle
can't be detected until runtime.

00:24:26.876 --> 00:24:28.466 A:middle
And so, for that reason, it's

00:24:28.466 --> 00:24:30.756 A:middle
also important to run your code,

00:24:30.956 --> 00:24:32.626 A:middle
run all of your tests, exercise

00:24:32.626 --> 00:24:34.176 A:middle
as much of the code as you can,

00:24:34.726 --> 00:24:36.336 A:middle
and look on the console in

00:24:36.526 --> 00:24:38.486 A:middle
Xcode's debug area for messages

00:24:38.486 --> 00:24:39.246 A:middle
like this one.

00:24:39.336 --> 00:24:40.556 A:middle
Telling you that you need to add

00:24:40.556 --> 00:24:41.626 A:middle
an objc attribute.

00:24:42.506 --> 00:24:45.586 A:middle
Notice, that the message there

00:24:45.586 --> 00:24:46.886 A:middle
shows you the exact source

00:24:46.886 --> 00:24:48.546 A:middle
location where the function is

00:24:48.596 --> 00:24:49.056 A:middle
defined.

00:24:49.056 --> 00:24:50.366 A:middle
So, you can just go to that

00:24:50.366 --> 00:24:53.826 A:middle
location and add the attribute.

00:24:53.926 --> 00:24:55.336 A:middle
Once you've fixed all the build

00:24:55.336 --> 00:24:57.736 A:middle
and runtime warnings, go to the

00:24:57.736 --> 00:24:59.226 A:middle
build settings for your project.

00:24:59.566 --> 00:25:01.276 A:middle
Change the Swift 3 objc

00:24:59.566 --> 00:25:01.276 A:middle
Change the Swift 3 objc

00:25:01.276 --> 00:25:03.286 A:middle
inference setting to default.

00:25:03.286 --> 00:25:05.146 A:middle
And with that the migration is

00:25:05.216 --> 00:25:05.516 A:middle
done.

00:25:06.166 --> 00:25:07.486 A:middle
It's really not that hard.

00:25:08.086 --> 00:25:09.486 A:middle
We did this for Apple's Music

00:25:09.686 --> 00:25:11.886 A:middle
App, there were only a total of

00:25:11.886 --> 00:25:13.706 A:middle
about 40 places where an objc

00:25:13.706 --> 00:25:15.696 A:middle
attribute needed to be added in

00:25:15.696 --> 00:25:16.946 A:middle
a really large project.

00:25:17.476 --> 00:25:19.446 A:middle
And more than 30 of those could

00:25:19.446 --> 00:25:20.566 A:middle
be handled completely

00:25:20.566 --> 00:25:22.316 A:middle
automatically by the migrator.

00:25:22.806 --> 00:25:26.136 A:middle
This change to limit objc

00:25:26.136 --> 00:25:27.796 A:middle
inference as well as the

00:25:27.796 --> 00:25:30.066 A:middle
optimization of removing unused

00:25:30.066 --> 00:25:32.316 A:middle
protocol conformances both help

00:25:32.316 --> 00:25:33.436 A:middle
to reduce your code size.

00:25:33.436 --> 00:25:36.016 A:middle
I'm going to tell you now about

00:25:36.016 --> 00:25:37.686 A:middle
another change that has an even

00:25:37.686 --> 00:25:39.406 A:middle
bigger impact on the overall

00:25:39.406 --> 00:25:41.106 A:middle
size of your app.

00:25:42.076 --> 00:25:44.486 A:middle
Besides the instructions and

00:25:44.486 --> 00:25:45.846 A:middle
data that make up a compile

00:25:45.936 --> 00:25:48.176 A:middle
Swift app, the symbol tables in

00:25:48.176 --> 00:25:50.816 A:middle
Swift frameworks occupy a lot of

00:25:50.886 --> 00:25:51.266 A:middle
space.

00:25:52.366 --> 00:25:54.726 A:middle
Swift uses a lot of symbols and

00:25:54.726 --> 00:25:58.016 A:middle
the names are often quite long.

00:25:58.206 --> 00:26:01.376 A:middle
For example, in Swift 3.1 almost

00:25:58.206 --> 00:26:01.376 A:middle
For example, in Swift 3.1 almost

00:26:01.456 --> 00:26:03.476 A:middle
half of the standard library is

00:26:03.516 --> 00:26:04.866 A:middle
taken up by symbols.

00:26:05.186 --> 00:26:06.736 A:middle
As shown by the darker blue bar

00:26:06.736 --> 00:26:06.966 A:middle
here.

00:26:08.016 --> 00:26:10.776 A:middle
In Swift 4, much less space is

00:26:10.776 --> 00:26:11.676 A:middle
needed for symbols.

00:26:11.676 --> 00:26:12.996 A:middle
So, even though there's a lot

00:26:12.996 --> 00:26:14.306 A:middle
more content in the standard

00:26:14.306 --> 00:26:14.836 A:middle
library.

00:26:15.346 --> 00:26:17.166 A:middle
The total size has actually

00:26:17.166 --> 00:26:17.626 A:middle
decreased.

00:26:19.146 --> 00:26:20.496 A:middle
We've accomplished this by

00:26:20.496 --> 00:26:22.956 A:middle
making the name shorter and also

00:26:22.956 --> 00:26:24.576 A:middle
by stripping out the symbols.

00:26:25.286 --> 00:26:28.526 A:middle
Both the static linker and the

00:26:28.526 --> 00:26:30.316 A:middle
dynamic linker use a separate

00:26:30.316 --> 00:26:32.096 A:middle
try data structure to quickly

00:26:32.096 --> 00:26:32.946 A:middle
look up symbols.

00:26:33.956 --> 00:26:35.286 A:middle
And so, what that means is that

00:26:35.286 --> 00:26:37.156 A:middle
the Swift symbols are rarely

00:26:37.156 --> 00:26:38.616 A:middle
needed in the symbol table.

00:26:39.706 --> 00:26:41.596 A:middle
Xcode 9 has a new build setting,

00:26:41.796 --> 00:26:44.156 A:middle
Strip Swift Symbols that's

00:26:44.156 --> 00:26:45.366 A:middle
enabled by default.

00:26:46.646 --> 00:26:47.986 A:middle
You can turn this off, if it

00:26:47.986 --> 00:26:49.176 A:middle
causes problems for your

00:26:49.176 --> 00:26:49.736 A:middle
workflow.

00:26:50.676 --> 00:26:52.926 A:middle
But Xcode normally runs the

00:26:52.926 --> 00:26:55.726 A:middle
symbol stripping as part of

00:26:55.726 --> 00:26:57.266 A:middle
archiving your project.

00:26:57.566 --> 00:26:59.336 A:middle
So, this feature has no impact

00:26:59.336 --> 00:27:00.746 A:middle
on earlier stages of

00:26:59.336 --> 00:27:00.746 A:middle
on earlier stages of

00:27:00.746 --> 00:27:01.306 A:middle
development.

00:27:01.306 --> 00:27:02.896 A:middle
And in particular, it should not

00:27:02.896 --> 00:27:04.516 A:middle
interfere with normal debugging

00:27:04.516 --> 00:27:05.266 A:middle
or profiling.

00:27:05.856 --> 00:27:09.176 A:middle
If for some reason you want to

00:27:09.176 --> 00:27:10.466 A:middle
examine the symbols that are

00:27:10.506 --> 00:27:12.196 A:middle
present in a binary, after it's

00:27:12.236 --> 00:27:12.796 A:middle
been stripped.

00:27:13.296 --> 00:27:15.616 A:middle
You can use the DYLD info tool

00:27:15.906 --> 00:27:17.836 A:middle
with the export option to look

00:27:17.836 --> 00:27:18.936 A:middle
at the exported symbols.

00:27:19.586 --> 00:27:22.776 A:middle
This build setting applies to

00:27:22.776 --> 00:27:24.486 A:middle
the code that you build in your

00:27:24.486 --> 00:27:25.076 A:middle
project.

00:27:26.186 --> 00:27:27.786 A:middle
The Swift standard libraries are

00:27:27.786 --> 00:27:28.706 A:middle
handled separately.

00:27:29.426 --> 00:27:31.086 A:middle
They're stripped as part of App

00:27:31.206 --> 00:27:31.486 A:middle
Thinning.

00:27:32.716 --> 00:27:33.896 A:middle
It's important to understand

00:27:33.896 --> 00:27:34.876 A:middle
this because if you want to

00:27:34.876 --> 00:27:36.216 A:middle
measure the size of your app,

00:27:36.806 --> 00:27:37.926 A:middle
you really need to go through

00:27:37.926 --> 00:27:39.956 A:middle
Xcode's distribution workflow

00:27:40.356 --> 00:27:41.586 A:middle
and export your app.

00:27:42.086 --> 00:27:43.796 A:middle
And when you do that, you'll see

00:27:43.796 --> 00:27:45.056 A:middle
there's a new setting that you

00:27:45.056 --> 00:27:46.646 A:middle
can use to control whether or

00:27:46.646 --> 00:27:48.866 A:middle
not to strip the symbols from

00:27:48.866 --> 00:27:49.836 A:middle
the standard libraries.

00:27:51.126 --> 00:27:52.966 A:middle
You can turn it off, but we

00:27:52.966 --> 00:27:54.816 A:middle
recommend that in most cases you

00:27:54.816 --> 00:27:55.976 A:middle
leave this enabled, because it

00:27:56.056 --> 00:27:57.726 A:middle
will provide a significant

00:27:57.726 --> 00:27:59.276 A:middle
reduction in the size of your

00:28:00.026 --> 00:28:00.106 A:middle
app.

00:28:00.716 --> 00:28:02.836 A:middle
Next, Ben's going to come up and

00:28:02.956 --> 00:28:04.026 A:middle
talk about what's new in

00:28:04.026 --> 00:28:05.126 A:middle
strings, collections and

00:28:05.126 --> 00:28:05.676 A:middle
generics.

00:28:06.516 --> 00:28:11.236 A:middle
[ Applause ]

00:28:11.736 --> 00:28:12.106 A:middle
&gt;&gt; Thanks, Bob.

00:28:13.066 --> 00:28:14.356 A:middle
So, we've got some really great

00:28:14.356 --> 00:28:15.646 A:middle
features in the standard library

00:28:15.646 --> 00:28:16.816 A:middle
and generics in this release.

00:28:16.816 --> 00:28:18.316 A:middle
And I'm going to start with

00:28:18.376 --> 00:28:18.746 A:middle
strings.

00:28:19.946 --> 00:28:21.506 A:middle
Strings in Swift 4 make

00:28:21.546 --> 00:28:23.446 A:middle
processing characters faster and

00:28:23.446 --> 00:28:25.326 A:middle
easier, while still having the

00:28:25.326 --> 00:28:27.226 A:middle
same goal they've always had of

00:28:27.226 --> 00:28:28.786 A:middle
helping you write Unicode

00:28:28.786 --> 00:28:29.386 A:middle
correct code.

00:28:29.386 --> 00:28:32.506 A:middle
So what do we mean by Unicode

00:28:32.506 --> 00:28:32.826 A:middle
correct?

00:28:33.986 --> 00:28:34.896 A:middle
Well, a lot of it comes down to

00:28:34.896 --> 00:28:36.246 A:middle
what we mean when we talk about

00:28:36.246 --> 00:28:36.886 A:middle
the character.

00:28:38.186 --> 00:28:39.476 A:middle
In most programming languages a

00:28:39.476 --> 00:28:42.276 A:middle
character is just a number, and

00:28:42.276 --> 00:28:42.916 A:middle
some encoding.

00:28:43.716 --> 00:28:44.866 A:middle
In older systems that might

00:28:44.996 --> 00:28:45.236 A:middle
ASCII.

00:28:45.756 --> 00:28:46.746 A:middle
These days, it's probably one of

00:28:46.746 --> 00:28:47.856 A:middle
the Unicode encodings.

00:28:48.916 --> 00:28:50.816 A:middle
So why does that matter.

00:28:50.816 --> 00:28:53.896 A:middle
Let's look at an example.

00:28:54.496 --> 00:28:58.456 A:middle
So, the single letter é, with

00:28:58.456 --> 00:29:01.286 A:middle
an acute accent in Unicode can

00:28:58.456 --> 00:29:01.286 A:middle
an acute accent in Unicode can

00:29:01.286 --> 00:29:02.426 A:middle
be encoded in two different

00:29:02.426 --> 00:29:02.716 A:middle
ways.

00:29:04.076 --> 00:29:06.766 A:middle
One way is with a single Unicode

00:29:06.766 --> 00:29:08.356 A:middle
scaler, E9.

00:29:09.576 --> 00:29:11.236 A:middle
The other way is by following

00:29:11.236 --> 00:29:13.426 A:middle
the plain letter E with the

00:29:13.426 --> 00:29:15.106 A:middle
combining acute accent modifier.

00:29:16.346 --> 00:29:17.456 A:middle
These two ways of encoding the

00:29:17.456 --> 00:29:18.976 A:middle
same letter are what Unicode

00:29:18.976 --> 00:29:20.366 A:middle
calls canonically equivalent.

00:29:21.196 --> 00:29:22.006 A:middle
You ought to be able to use

00:29:22.126 --> 00:29:23.926 A:middle
either one without it making any

00:29:23.926 --> 00:29:24.486 A:middle
difference.

00:29:25.706 --> 00:29:27.746 A:middle
So, what can that mean in code.

00:29:28.656 --> 00:29:30.076 A:middle
Well, when the default way of a

00:29:30.076 --> 00:29:31.736 A:middle
language of looking at strings

00:29:32.026 --> 00:29:33.106 A:middle
is to look at the individual

00:29:33.106 --> 00:29:34.256 A:middle
code units in the string.

00:29:34.256 --> 00:29:35.386 A:middle
You can get some very odd

00:29:35.446 --> 00:29:35.916 A:middle
behavior.

00:29:36.876 --> 00:29:38.216 A:middle
This example is in Ruby, but we

00:29:38.216 --> 00:29:39.806 A:middle
see similar behavior in otherer

00:29:39.806 --> 00:29:41.146 A:middle
languages like Java or C.

00:29:42.016 --> 00:29:43.676 A:middle
We can create two strings in two

00:29:43.676 --> 00:29:45.306 A:middle
different ways that ought to be

00:29:45.346 --> 00:29:46.376 A:middle
exactly equivalent.

00:29:46.866 --> 00:29:48.556 A:middle
To a user, they look identical.

00:29:50.026 --> 00:29:51.256 A:middle
But if we do things like count

00:29:51.586 --> 00:29:53.646 A:middle
the number of characters, we get

00:29:53.646 --> 00:29:54.276 A:middle
different results.

00:29:55.026 --> 00:29:56.926 A:middle
And if we use the default

00:29:56.926 --> 00:29:58.636 A:middle
comparison operation, they're

00:29:58.636 --> 00:29:59.236 A:middle
not equal.

00:30:00.416 --> 00:30:01.636 A:middle
This can cause some really hard

00:30:01.636 --> 00:30:02.806 A:middle
to understand and diagnose

00:30:02.806 --> 00:30:03.256 A:middle
issues.

00:30:03.986 --> 00:30:05.296 A:middle
And that's why strict Swift

00:30:05.406 --> 00:30:06.426 A:middle
takes a slightly different

00:30:06.426 --> 00:30:06.866 A:middle
approach.

00:30:08.136 --> 00:30:10.516 A:middle
In Swift, a character is what

00:30:10.516 --> 00:30:12.036 A:middle
Unicode cools a grapheme.

00:30:13.046 --> 00:30:14.486 A:middle
A grapheme is what most users

00:30:14.486 --> 00:30:15.456 A:middle
would think of as a single

00:30:15.456 --> 00:30:16.866 A:middle
character when they see one on

00:30:16.866 --> 00:30:17.376 A:middle
the screen.

00:30:18.576 --> 00:30:20.256 A:middle
And in Swift, no matter how you

00:30:20.256 --> 00:30:21.636 A:middle
compose a particular grapheme,

00:30:22.096 --> 00:30:24.266 A:middle
it's one character, and two

00:30:24.266 --> 00:30:25.556 A:middle
differently composed equivalent

00:30:25.556 --> 00:30:26.986 A:middle
graphemes compare as equal.

00:30:27.586 --> 00:30:30.866 A:middle
Now, the logic for breaking up a

00:30:30.866 --> 00:30:32.426 A:middle
string into graphemes can get

00:30:32.476 --> 00:30:33.366 A:middle
quite complicated.

00:30:34.156 --> 00:30:36.146 A:middle
For example, the family emoji is

00:30:36.146 --> 00:30:38.036 A:middle
made up by combining adult emoji

00:30:38.246 --> 00:30:39.026 A:middle
with child emoji.

00:30:40.426 --> 00:30:41.846 A:middle
And in Swift 4 because we're

00:30:41.846 --> 00:30:43.256 A:middle
using Unicode 9 graphing

00:30:43.256 --> 00:30:44.296 A:middle
breaking that's built into the

00:30:44.296 --> 00:30:45.906 A:middle
operating system, this counts as

00:30:45.906 --> 00:30:46.606 A:middle
one character.

00:30:47.226 --> 00:30:50.406 A:middle
But this complicated logic has a

00:30:50.406 --> 00:30:50.906 A:middle
cost.

00:30:51.206 --> 00:30:52.266 A:middle
And in previous versions of

00:30:52.266 --> 00:30:53.526 A:middle
Swift, you were paying for this

00:30:53.556 --> 00:30:55.346 A:middle
cost for every character you

00:30:55.346 --> 00:30:55.826 A:middle
processed.

00:30:55.986 --> 00:30:56.886 A:middle
Even simpler ones.

00:30:57.926 --> 00:30:59.296 A:middle
In this release, we've added

00:30:59.296 --> 00:31:00.866 A:middle
fast path for those simpler

00:30:59.296 --> 00:31:00.866 A:middle
fast path for those simpler

00:31:00.866 --> 00:31:02.446 A:middle
characters in many different

00:31:02.446 --> 00:31:02.886 A:middle
languages.

00:31:04.216 --> 00:31:05.826 A:middle
That means that processing these

00:31:05.826 --> 00:31:07.266 A:middle
simpler characters in a string

00:31:07.266 --> 00:31:08.656 A:middle
as you go through it should take

00:31:08.656 --> 00:31:10.156 A:middle
about a third of the time it did

00:31:10.216 --> 00:31:11.316 A:middle
in previous versions.

00:31:11.806 --> 00:31:14.206 A:middle
These fast paths are robust to

00:31:14.206 --> 00:31:16.636 A:middle
the presence of more complicated

00:31:16.636 --> 00:31:17.146 A:middle
characters.

00:31:17.506 --> 00:31:18.676 A:middle
So, for example if you were

00:31:18.676 --> 00:31:19.866 A:middle
processing messages on social

00:31:19.866 --> 00:31:22.326 A:middle
media, that was mostly simple

00:31:22.326 --> 00:31:24.266 A:middle
plain text, but with some emoji

00:31:24.266 --> 00:31:25.776 A:middle
mixed in, we only take the

00:31:25.776 --> 00:31:26.996 A:middle
slower more complex path to

00:31:26.996 --> 00:31:28.226 A:middle
process the emoji.

00:31:28.226 --> 00:31:31.466 A:middle
Now, let's look at that emoji

00:31:31.466 --> 00:31:33.476 A:middle
example again.

00:31:33.776 --> 00:31:34.956 A:middle
There's two things to notice

00:31:34.956 --> 00:31:35.316 A:middle
about this.

00:31:36.636 --> 00:31:38.996 A:middle
One is that graphemes can be of

00:31:38.996 --> 00:31:39.826 A:middle
variable width.

00:31:40.186 --> 00:31:41.616 A:middle
So, we clearly can't have random

00:31:41.616 --> 00:31:43.196 A:middle
access to a particular grapheme

00:31:43.196 --> 00:31:43.696 A:middle
in a string.

00:31:44.416 --> 00:31:45.716 A:middle
We can have random access to a

00:31:45.716 --> 00:31:47.026 A:middle
particular code unit, and you

00:31:47.026 --> 00:31:48.306 A:middle
can still get at those in Swift

00:31:48.306 --> 00:31:48.676 A:middle
strings.

00:31:50.336 --> 00:31:51.346 A:middle
But what does that mean, it

00:31:51.346 --> 00:31:52.376 A:middle
doesn't mean anything in this

00:31:52.376 --> 00:31:54.096 A:middle
example to access the fifth code

00:31:54.096 --> 00:31:54.416 A:middle
unit.

00:31:54.766 --> 00:31:55.676 A:middle
It's certainly not the fifth

00:31:55.676 --> 00:31:56.096 A:middle
character.

00:31:57.566 --> 00:31:58.826 A:middle
The other thing to notice is

00:31:58.826 --> 00:32:00.296 A:middle
that there's a bit of an unusual

00:31:58.826 --> 00:32:00.296 A:middle
that there's a bit of an unusual

00:32:00.296 --> 00:32:00.746 A:middle
behavior.

00:32:00.746 --> 00:32:03.566 A:middle
And we've appended six items to

00:32:03.566 --> 00:32:04.866 A:middle
a string, but when we were done,

00:32:05.126 --> 00:32:06.206 A:middle
the count hadn't gone up.

00:32:06.206 --> 00:32:07.926 A:middle
And that's not normally what

00:32:07.926 --> 00:32:09.816 A:middle
you'd expect from other

00:32:09.816 --> 00:32:11.056 A:middle
collections like arrays.

00:32:11.056 --> 00:32:13.696 A:middle
And it was because of edge cases

00:32:13.696 --> 00:32:15.106 A:middle
like this that it was felt that

00:32:15.106 --> 00:32:16.536 A:middle
strings shouldn't be collections

00:32:16.536 --> 00:32:19.296 A:middle
in previous versions of Swift.

00:32:19.456 --> 00:32:21.116 A:middle
Instead, you used to have to

00:32:21.116 --> 00:32:24.366 A:middle
access the characters as a

00:32:24.366 --> 00:32:25.816 A:middle
collection for the character's

00:32:25.816 --> 00:32:26.886 A:middle
property on the string.

00:32:28.856 --> 00:32:30.676 A:middle
But this actually really wasn't

00:32:30.676 --> 00:32:32.046 A:middle
helping anyone understand the

00:32:32.046 --> 00:32:33.556 A:middle
issues it was trying to avoid.

00:32:33.906 --> 00:32:35.176 A:middle
All it was doing was cluttering

00:32:35.176 --> 00:32:35.576 A:middle
up code.

00:32:35.576 --> 00:32:37.366 A:middle
It was dissuading people from

00:32:37.366 --> 00:32:38.786 A:middle
thinking in terms of characters

00:32:39.096 --> 00:32:40.306 A:middle
and from using the standard

00:32:40.306 --> 00:32:41.496 A:middle
library to do their string

00:32:41.496 --> 00:32:41.986 A:middle
processing.

00:32:42.986 --> 00:32:45.006 A:middle
So, in Swift 4, strings are a

00:32:45.006 --> 00:32:45.946 A:middle
collection of characters.

00:32:45.946 --> 00:32:47.116 A:middle
And that helps clean up code

00:32:47.116 --> 00:32:48.346 A:middle
like this, a lot.

00:32:49.516 --> 00:32:54.696 A:middle
[ Applause ]

00:32:55.196 --> 00:32:56.076 A:middle
Now, there's one other thing we

00:32:56.076 --> 00:32:56.966 A:middle
can simplify here.

00:32:57.126 --> 00:32:58.166 A:middle
In string processing it's very

00:32:58.206 --> 00:32:59.806 A:middle
common to want to slice from an

00:32:59.806 --> 00:33:01.666 A:middle
index to the end of a string.

00:32:59.806 --> 00:33:01.666 A:middle
index to the end of a string.

00:33:03.026 --> 00:33:04.276 A:middle
There's a shorthand in Swift 4

00:33:04.276 --> 00:33:04.936 A:middle
for that.

00:33:05.036 --> 00:33:06.156 A:middle
You can leave off the end of a

00:33:06.156 --> 00:33:07.306 A:middle
range whenever you're slicing a

00:33:07.306 --> 00:33:08.956 A:middle
collection and that means from

00:33:08.956 --> 00:33:10.146 A:middle
the index, to the end of the

00:33:10.146 --> 00:33:10.656 A:middle
collection.

00:33:10.656 --> 00:33:12.526 A:middle
And there's a similar syntax for

00:33:12.526 --> 00:33:15.976 A:middle
going from the start up to an

00:33:16.336 --> 00:33:16.546 A:middle
index.

00:33:16.546 --> 00:33:18.096 A:middle
Making strings collections means

00:33:18.096 --> 00:33:19.146 A:middle
they have all of the properties

00:33:19.146 --> 00:33:19.916 A:middle
you're use to in other

00:33:19.916 --> 00:33:21.286 A:middle
collections, so you can zip

00:33:21.286 --> 00:33:23.106 A:middle
them, map them, search or filter

00:33:23.106 --> 00:33:23.256 A:middle
them.

00:33:24.196 --> 00:33:25.396 A:middle
This makes building up string

00:33:25.396 --> 00:33:26.606 A:middle
processing a lot simpler.

00:33:27.626 --> 00:33:28.496 A:middle
We'll look at an example.

00:33:30.016 --> 00:33:31.266 A:middle
Supposing you want to detect

00:33:31.506 --> 00:33:33.486 A:middle
whether there was a country flag

00:33:33.746 --> 00:33:34.976 A:middle
in a message in your app in

00:33:34.976 --> 00:33:37.086 A:middle
order to trigger some logic.

00:33:38.436 --> 00:33:40.506 A:middle
Country flags in Unicode are

00:33:40.506 --> 00:33:41.926 A:middle
made up of pairs of special

00:33:41.926 --> 00:33:43.296 A:middle
regional indicators that spell

00:33:43.296 --> 00:33:44.656 A:middle
out the ISO country code of the

00:33:44.746 --> 00:33:45.066 A:middle
flag.

00:33:45.356 --> 00:33:46.376 A:middle
So, the Japanese flag for

00:33:46.376 --> 00:33:47.316 A:middle
example is JNP.

00:33:47.316 --> 00:33:49.626 A:middle
We can add an extension to

00:33:49.626 --> 00:33:51.066 A:middle
Unicode scaler to be able to

00:33:51.066 --> 00:33:52.256 A:middle
detect whether it's one of these

00:33:52.256 --> 00:33:53.586 A:middle
special regional indicators.

00:33:54.266 --> 00:33:58.276 A:middle
Next, we can extend character in

00:33:58.276 --> 00:34:00.116 A:middle
order to detect whether the

00:33:58.276 --> 00:34:00.116 A:middle
order to detect whether the

00:34:00.116 --> 00:34:01.306 A:middle
character is a flag.

00:34:02.276 --> 00:34:03.426 A:middle
This is using a new property

00:34:03.426 --> 00:34:04.746 A:middle
that's available in Swift 4 that

00:34:04.746 --> 00:34:06.146 A:middle
lets you access the underlying

00:34:06.146 --> 00:34:07.736 A:middle
Unicode scalers that make up the

00:34:07.736 --> 00:34:08.156 A:middle
graphic.

00:34:08.726 --> 00:34:10.686 A:middle
This is actually a really useful

00:34:10.686 --> 00:34:11.976 A:middle
thing to play around with, if

00:34:11.976 --> 00:34:13.065 A:middle
you want to learn more about how

00:34:13.065 --> 00:34:14.606 A:middle
Unicode works, especially in a

00:34:14.606 --> 00:34:15.406 A:middle
Swift playground.

00:34:18.295 --> 00:34:19.335 A:middle
Now that we have this, we can

00:34:19.335 --> 00:34:20.545 A:middle
use it with all of the familiar

00:34:20.886 --> 00:34:21.795 A:middle
collection API's.

00:34:21.996 --> 00:34:23.656 A:middle
So, we can search if the string

00:34:23.656 --> 00:34:24.516 A:middle
contains a flag.

00:34:25.376 --> 00:34:27.226 A:middle
Or, we can filter out just the

00:34:27.226 --> 00:34:28.676 A:middle
flags into a new string.

00:34:28.835 --> 00:34:32.726 A:middle
So, now that strings are

00:34:32.726 --> 00:34:34.136 A:middle
collections, you might notice

00:34:34.136 --> 00:34:35.295 A:middle
that they have a new method,

00:34:35.536 --> 00:34:35.916 A:middle
split.

00:34:36.136 --> 00:34:37.275 A:middle
Which is an existing method on

00:34:37.275 --> 00:34:37.735 A:middle
collection.

00:34:38.976 --> 00:34:41.106 A:middle
It breaks up a string into an

00:34:41.106 --> 00:34:42.116 A:middle
array of slices.

00:34:42.966 --> 00:34:44.775 A:middle
But if you run it on Swift, in

00:34:44.835 --> 00:34:46.166 A:middle
Swift 4, you'll notice it

00:34:46.166 --> 00:34:47.516 A:middle
doesn't return an array of

00:34:47.516 --> 00:34:47.956 A:middle
strings.

00:34:49.556 --> 00:34:50.996 A:middle
The slice type in Swift 4 for

00:34:50.996 --> 00:34:52.726 A:middle
strings is a substring.

00:34:53.946 --> 00:34:54.815 A:middle
So, why did we give it a

00:34:54.815 --> 00:34:55.536 A:middle
different type?

00:34:56.786 --> 00:34:58.346 A:middle
Well, there's some fundamental

00:34:58.346 --> 00:34:59.446 A:middle
engineering trade-offs to be

00:34:59.446 --> 00:35:01.526 A:middle
made when deciding how slicing

00:34:59.446 --> 00:35:01.526 A:middle
made when deciding how slicing

00:35:01.526 --> 00:35:02.726 A:middle
on collections ought to work.

00:35:04.536 --> 00:35:05.306 A:middle
When you're slicing a

00:35:05.306 --> 00:35:06.586 A:middle
collection, should it make a

00:35:06.636 --> 00:35:08.126 A:middle
copy of the elements that you're

00:35:08.126 --> 00:35:10.896 A:middle
slicing out, or should it return

00:35:11.136 --> 00:35:13.316 A:middle
a view into the internal storage

00:35:13.426 --> 00:35:14.586 A:middle
of the original collection.

00:35:14.586 --> 00:35:17.556 A:middle
From a performance point of

00:35:17.556 --> 00:35:19.616 A:middle
view, sharing storage is clearly

00:35:19.616 --> 00:35:20.396 A:middle
going to be faster.

00:35:21.326 --> 00:35:22.366 A:middle
As Bob mentioned earlier,

00:35:22.426 --> 00:35:24.686 A:middle
allocating and tracking heap

00:35:24.686 --> 00:35:26.196 A:middle
memory can be very expensive.

00:35:26.516 --> 00:35:27.926 A:middle
You could easily spend at least

00:35:27.926 --> 00:35:29.326 A:middle
half of the time in an operation

00:35:29.326 --> 00:35:31.116 A:middle
like Split, making copies.

00:35:32.116 --> 00:35:34.456 A:middle
What's more, if slicing takes

00:35:34.456 --> 00:35:35.866 A:middle
linear time, because we're

00:35:35.866 --> 00:35:37.166 A:middle
making copies of the elements,

00:35:37.816 --> 00:35:39.786 A:middle
then a loop that was performing

00:35:39.786 --> 00:35:40.926 A:middle
slicing operations might

00:35:40.926 --> 00:35:42.226 A:middle
accidentally be quadratic,

00:35:42.496 --> 00:35:43.786 A:middle
instead of running in the linear

00:35:43.866 --> 00:35:44.986 A:middle
time you might be expecting.

00:35:46.526 --> 00:35:47.756 A:middle
So, that's was slicing of any

00:35:47.756 --> 00:35:49.426 A:middle
collection in Swift needs to

00:35:49.426 --> 00:35:50.596 A:middle
happen in constant time.

00:35:52.476 --> 00:35:53.906 A:middle
But that shared storage approach

00:35:53.906 --> 00:35:55.636 A:middle
that we use instead also has a

00:35:55.636 --> 00:35:56.116 A:middle
downside.

00:35:56.246 --> 00:35:57.516 A:middle
And to understand what that is,

00:35:58.056 --> 00:35:59.056 A:middle
let's look at the internal

00:35:59.056 --> 00:36:00.406 A:middle
implementation of string.

00:35:59.056 --> 00:36:00.406 A:middle
implementation of string.

00:36:01.876 --> 00:36:04.856 A:middle
So, currently in Swift strings

00:36:04.856 --> 00:36:06.026 A:middle
internally are made up of three

00:36:06.026 --> 00:36:06.506 A:middle
properties.

00:36:07.646 --> 00:36:08.766 A:middle
They have a pointer to the start

00:36:08.766 --> 00:36:09.196 A:middle
of the buffer.

00:36:10.076 --> 00:36:11.066 A:middle
They have a count of the number

00:36:11.066 --> 00:36:12.476 A:middle
of code units in the buffer, and

00:36:12.606 --> 00:36:14.086 A:middle
they have a reference to an

00:36:14.086 --> 00:36:14.836 A:middle
owner object.

00:36:15.696 --> 00:36:17.196 A:middle
The owner object is responsible

00:36:17.196 --> 00:36:18.526 A:middle
for tracking and managing the

00:36:18.526 --> 00:36:18.846 A:middle
buffer.

00:36:18.966 --> 00:36:20.216 A:middle
And this is a familiar pattern

00:36:20.216 --> 00:36:21.316 A:middle
if you know on copy on write

00:36:21.316 --> 00:36:22.376 A:middle
works in other collections.

00:36:24.306 --> 00:36:25.826 A:middle
When the original string struct

00:36:25.826 --> 00:36:28.946 A:middle
is destroyed, the reference

00:36:28.946 --> 00:36:30.116 A:middle
count and the owner object drops

00:36:30.166 --> 00:36:31.896 A:middle
to zero, and the [inaudible] on

00:36:31.896 --> 00:36:33.696 A:middle
the class frees the buffer.

00:36:35.276 --> 00:36:36.626 A:middle
Now, let's have a look at what

00:36:36.626 --> 00:36:37.816 A:middle
happens when we create a

00:36:37.926 --> 00:36:38.396 A:middle
substring.

00:36:39.066 --> 00:36:42.066 A:middle
So, supposing we sliced off just

00:36:42.066 --> 00:36:43.456 A:middle
the word well from the original

00:36:43.456 --> 00:36:43.736 A:middle
string.

00:36:45.176 --> 00:36:47.546 A:middle
The substring now has a start

00:36:47.546 --> 00:36:49.446 A:middle
that points to the W, has a

00:36:49.446 --> 00:36:51.656 A:middle
count of five, and the owner is

00:36:51.656 --> 00:36:53.136 A:middle
a shared reference to the

00:36:53.136 --> 00:36:54.146 A:middle
original strings owner.

00:36:55.506 --> 00:36:56.486 A:middle
Now what happens when that

00:36:56.486 --> 00:36:58.576 A:middle
original string goes out of

00:36:59.496 --> 00:36:59.706 A:middle
scope.

00:37:00.526 --> 00:37:01.796 A:middle
The owner's reference count is

00:37:01.796 --> 00:37:03.636 A:middle
decremented, but it's not

00:37:03.636 --> 00:37:04.546 A:middle
destroyed because it's being

00:37:04.546 --> 00:37:05.526 A:middle
shared by the substring.

00:37:05.526 --> 00:37:06.806 A:middle
So, the buffer isn't freed.

00:37:07.156 --> 00:37:08.496 A:middle
And that's good because the

00:37:08.496 --> 00:37:09.556 A:middle
substring is relying on the

00:37:09.556 --> 00:37:09.756 A:middle
buffer.

00:37:09.756 --> 00:37:12.236 A:middle
But the entire of the buffer

00:37:12.236 --> 00:37:12.606 A:middle
remains.

00:37:12.816 --> 00:37:14.296 A:middle
Not just the part, the substring

00:37:14.296 --> 00:37:14.946 A:middle
it's relying on.

00:37:16.436 --> 00:37:17.496 A:middle
Now in this case, it's no big

00:37:17.496 --> 00:37:18.516 A:middle
deal, it's just a few

00:37:18.516 --> 00:37:19.006 A:middle
characters.

00:37:19.696 --> 00:37:20.846 A:middle
But it can be a real problem.

00:37:22.886 --> 00:37:24.626 A:middle
Supposing you downloaded a giant

00:37:24.626 --> 00:37:25.816 A:middle
blob of text from the internet,

00:37:26.596 --> 00:37:28.046 A:middle
then you sliced out just a small

00:37:28.046 --> 00:37:29.636 A:middle
part of that text and assigned

00:37:29.636 --> 00:37:31.796 A:middle
it to some long-lived variable

00:37:32.126 --> 00:37:33.116 A:middle
like a UI label.

00:37:34.216 --> 00:37:35.496 A:middle
This ends up looking like a

00:37:35.496 --> 00:37:36.116 A:middle
memory leak.

00:37:36.716 --> 00:37:38.046 A:middle
Because the original giant blob

00:37:38.046 --> 00:37:39.686 A:middle
of text's buffer never gets

00:37:39.686 --> 00:37:40.066 A:middle
freed.

00:37:41.166 --> 00:37:42.206 A:middle
This was actually such a big

00:37:42.206 --> 00:37:43.456 A:middle
problem in Java that they

00:37:43.456 --> 00:37:45.036 A:middle
changed the behavior of slicing

00:37:45.036 --> 00:37:47.346 A:middle
on strings a few years ago to

00:37:47.346 --> 00:37:48.236 A:middle
make it make copies.

00:37:49.566 --> 00:37:50.676 A:middle
But as we've seen, that has a

00:37:50.676 --> 00:37:51.806 A:middle
performance downside, and we

00:37:51.806 --> 00:37:52.916 A:middle
don't necessarily want to make

00:37:53.006 --> 00:37:53.706 A:middle
that tradeoff.

00:37:54.646 --> 00:37:55.896 A:middle
The natural solution for a

00:37:55.896 --> 00:37:57.686 A:middle
problem like this in Swift is to

00:37:57.776 --> 00:37:58.446 A:middle
use a type.

00:37:59.166 --> 00:38:00.746 A:middle
And that's why substrings are a

00:37:59.166 --> 00:38:00.746 A:middle
And that's why substrings are a

00:38:00.746 --> 00:38:01.856 A:middle
different type to strings.

00:38:02.866 --> 00:38:04.486 A:middle
Now, when you're performing your

00:38:04.486 --> 00:38:06.086 A:middle
slicing operation on the

00:38:06.086 --> 00:38:07.896 A:middle
original large string, you'll

00:38:07.896 --> 00:38:09.316 A:middle
end up wanting to assign a

00:38:09.356 --> 00:38:10.986 A:middle
substring to a string and the

00:38:10.986 --> 00:38:12.186 A:middle
compiler will tell you about it.

00:38:13.456 --> 00:38:14.686 A:middle
If you apply the fix it, it's

00:38:14.686 --> 00:38:16.736 A:middle
going to suggest then you'll

00:38:16.736 --> 00:38:18.836 A:middle
create a new string, and that

00:38:18.836 --> 00:38:20.216 A:middle
will copy just the part of the

00:38:20.216 --> 00:38:21.246 A:middle
buffer that you sliced.

00:38:22.286 --> 00:38:23.556 A:middle
And that allows the original

00:38:23.556 --> 00:38:25.916 A:middle
buffer to go out of scope and be

00:38:26.896 --> 00:38:27.666 A:middle
freed up.

00:38:28.516 --> 00:38:33.286 A:middle
[ Applause ]

00:38:33.786 --> 00:38:35.706 A:middle
So, now we've got two different

00:38:35.706 --> 00:38:36.056 A:middle
types.

00:38:36.056 --> 00:38:37.056 A:middle
You might ask the question when

00:38:37.056 --> 00:38:38.606 A:middle
should I use substring in my

00:38:38.606 --> 00:38:38.736 A:middle
code.

00:38:38.736 --> 00:38:40.856 A:middle
And the answer is, you probably

00:38:40.856 --> 00:38:42.756 A:middle
shouldn't very often explicitly.

00:38:43.306 --> 00:38:45.596 A:middle
When defining interfaces, like

00:38:45.596 --> 00:38:47.216 A:middle
methods on types or properties,

00:38:47.686 --> 00:38:49.096 A:middle
you should prefer to use string,

00:38:49.856 --> 00:38:51.126 A:middle
both to avoid the memory leak

00:38:51.126 --> 00:38:52.696 A:middle
issues we just talked about, but

00:38:52.696 --> 00:38:54.336 A:middle
also because string is what we

00:38:54.336 --> 00:38:55.796 A:middle
call the common currency type.

00:38:56.036 --> 00:38:56.916 A:middle
It's the type that everybody

00:38:56.916 --> 00:38:58.446 A:middle
expects to see in APIs.

00:39:00.076 --> 00:39:01.386 A:middle
Most of the time, the only time

00:39:01.386 --> 00:39:03.176 A:middle
you will encounter a substring

00:39:03.176 --> 00:39:04.676 A:middle
type is when you're performing a

00:39:04.676 --> 00:39:05.566 A:middle
slicing operation.

00:39:06.076 --> 00:39:07.726 A:middle
And because Swift uses type

00:39:07.786 --> 00:39:09.186 A:middle
inference, you won't actually

00:39:09.186 --> 00:39:10.596 A:middle
name the substring type at all.

00:39:12.196 --> 00:39:13.706 A:middle
Substrings have many of the same

00:39:13.706 --> 00:39:14.856 A:middle
methods and properties as

00:39:14.856 --> 00:39:15.586 A:middle
regular strings.

00:39:15.936 --> 00:39:17.666 A:middle
So even though you're not naming

00:39:17.666 --> 00:39:19.606 A:middle
the type as a substring, much of

00:39:19.686 --> 00:39:20.806 A:middle
the code will operate just the

00:39:20.896 --> 00:39:22.686 A:middle
same as if it was operating on a

00:39:22.686 --> 00:39:23.056 A:middle
string.

00:39:24.066 --> 00:39:25.196 A:middle
And if you don't actually need

00:39:25.196 --> 00:39:26.036 A:middle
to create a string because

00:39:26.036 --> 00:39:26.836 A:middle
you're only doing local

00:39:26.836 --> 00:39:28.336 A:middle
operations, then that can be

00:39:28.336 --> 00:39:29.296 A:middle
avoided altogether.

00:39:31.866 --> 00:39:32.656 A:middle
So, that's almost it for

00:39:32.656 --> 00:39:33.026 A:middle
strings.

00:39:33.386 --> 00:39:34.526 A:middle
There's one last feature we want

00:39:34.526 --> 00:39:34.976 A:middle
to talk about.

00:39:34.976 --> 00:39:36.266 A:middle
And that's multiline string

00:39:36.266 --> 00:39:36.656 A:middle
literals.

00:39:37.616 --> 00:39:38.916 A:middle
Previously, these were a real

00:39:38.916 --> 00:39:39.586 A:middle
pain to write.

00:39:39.726 --> 00:39:41.256 A:middle
You had to write one big long

00:39:41.256 --> 00:39:42.776 A:middle
string literal with embedded

00:39:42.846 --> 00:39:43.516 A:middle
slash ends in it.

00:39:44.606 --> 00:39:46.606 A:middle
Swift 4 introduces the triple

00:39:46.606 --> 00:39:47.426 A:middle
quoting syntax.

00:39:48.676 --> 00:39:49.876 A:middle
You start your multiline string

00:39:49.876 --> 00:39:50.556 A:middle
with a triple quote.

00:39:51.516 --> 00:39:56.906 A:middle
[ Applause ]

00:39:57.406 --> 00:39:58.416 A:middle
And then you end it with a

00:39:58.416 --> 00:39:58.946 A:middle
triple quote.

00:39:59.606 --> 00:40:01.316 A:middle
The indentation of the closing

00:39:59.606 --> 00:40:01.316 A:middle
The indentation of the closing

00:40:01.316 --> 00:40:02.966 A:middle
triple quote is what determines

00:40:03.446 --> 00:40:04.936 A:middle
the indentation for every line

00:40:04.936 --> 00:40:05.976 A:middle
of the multiline string.

00:40:06.546 --> 00:40:08.856 A:middle
You can see here, because we've

00:40:08.856 --> 00:40:09.996 A:middle
put our literal inside a

00:40:09.996 --> 00:40:10.866 A:middle
function, we want it to be

00:40:10.866 --> 00:40:12.086 A:middle
nicely indented to match the

00:40:12.086 --> 00:40:13.596 A:middle
formatting of the rest of our

00:40:13.596 --> 00:40:13.716 A:middle
code.

00:40:14.586 --> 00:40:15.706 A:middle
The rule is, whatever

00:40:15.706 --> 00:40:16.956 A:middle
indentation you use on the

00:40:16.996 --> 00:40:18.576 A:middle
closing quote, you need to

00:40:18.576 --> 00:40:20.136 A:middle
include at least that much

00:40:20.136 --> 00:40:21.936 A:middle
indentation on every line of the

00:40:21.936 --> 00:40:22.266 A:middle
string.

00:40:23.076 --> 00:40:24.596 A:middle
Then, when the code is compiled,

00:40:25.546 --> 00:40:27.356 A:middle
that indentation is stripped

00:40:28.236 --> 00:40:28.326 A:middle
off.

00:40:29.436 --> 00:40:30.806 A:middle
This is a really nice feature.

00:40:30.806 --> 00:40:31.636 A:middle
And one of the cool things to

00:40:31.636 --> 00:40:33.006 A:middle
mention about it is it's being

00:40:33.006 --> 00:40:35.696 A:middle
both proposed and implemented by

00:40:35.696 --> 00:40:36.896 A:middle
external members of the Swift

00:40:36.896 --> 00:40:38.036 A:middle
open source community.

00:40:39.516 --> 00:40:45.106 A:middle
[ Applause ]

00:40:45.606 --> 00:40:46.396 A:middle
So, that's it for string.

00:40:46.396 --> 00:40:47.326 A:middle
Now, let's talk about some of

00:40:47.326 --> 00:40:48.366 A:middle
the new generics features.

00:40:49.516 --> 00:40:50.756 A:middle
With each version of Swift,

00:40:50.756 --> 00:40:52.506 A:middle
we've been refining the generic

00:40:52.576 --> 00:40:52.916 A:middle
system.

00:40:53.136 --> 00:40:54.406 A:middle
Both to make it more powerful,

00:40:55.116 --> 00:40:56.766 A:middle
but also to make it more usable

00:40:56.936 --> 00:40:57.606 A:middle
and approachable.

00:40:57.986 --> 00:40:59.396 A:middle
Such as with protocol extensions

00:40:59.396 --> 00:41:00.356 A:middle
that came in Swift 2.

00:40:59.396 --> 00:41:00.356 A:middle
that came in Swift 2.

00:41:01.576 --> 00:41:03.616 A:middle
In this release, we are

00:41:03.616 --> 00:41:04.866 A:middle
introducing two features.

00:41:05.556 --> 00:41:06.846 A:middle
Where clauses on associated

00:41:06.846 --> 00:41:09.466 A:middle
types, and generic subscripts.

00:41:10.016 --> 00:41:10.806 A:middle
And I'm going to show you a

00:41:10.806 --> 00:41:12.176 A:middle
couple of examples of how we've

00:41:12.176 --> 00:41:13.016 A:middle
used them in the standard

00:41:13.016 --> 00:41:14.356 A:middle
library to give you an idea of

00:41:14.356 --> 00:41:15.376 A:middle
how you might be able to use

00:41:15.406 --> 00:41:17.006 A:middle
them in your code.

00:41:18.256 --> 00:41:20.386 A:middle
So, supposing you wanted to

00:41:20.386 --> 00:41:22.176 A:middle
detect whether every element of

00:41:22.176 --> 00:41:24.276 A:middle
a sequence was equal to a

00:41:24.276 --> 00:41:25.106 A:middle
particular value.

00:41:26.166 --> 00:41:27.806 A:middle
You can do this with a contains

00:41:27.806 --> 00:41:28.946 A:middle
method that already exists on

00:41:28.946 --> 00:41:29.366 A:middle
sequence.

00:41:29.716 --> 00:41:31.486 A:middle
But, that code is a bit clunky.

00:41:31.876 --> 00:41:33.546 A:middle
You have to write the sequence

00:41:33.726 --> 00:41:35.766 A:middle
doesn't contain any element not

00:41:35.766 --> 00:41:36.536 A:middle
equal to the value.

00:41:37.656 --> 00:41:38.676 A:middle
If you are writing this over and

00:41:38.676 --> 00:41:39.506 A:middle
over again, that might get

00:41:39.506 --> 00:41:41.036 A:middle
pretty annoying and protocol

00:41:41.036 --> 00:41:42.526 A:middle
extensions give you a really

00:41:42.526 --> 00:41:44.146 A:middle
nice way to wrap up code like

00:41:44.146 --> 00:41:46.046 A:middle
this into helper methods that

00:41:46.046 --> 00:41:46.846 A:middle
neaten up your code.

00:41:47.996 --> 00:41:49.786 A:middle
So, we can wrap this code inside

00:41:49.786 --> 00:41:51.686 A:middle
an extension on sequence that

00:41:51.686 --> 00:41:52.706 A:middle
gives us something much more

00:41:52.706 --> 00:41:53.566 A:middle
readable to call.

00:41:55.026 --> 00:41:56.796 A:middle
Now, when you're extending

00:41:56.796 --> 00:41:58.326 A:middle
sequence like this, there's one

00:41:58.326 --> 00:41:59.536 A:middle
thing that's slightly annoying.

00:41:59.536 --> 00:42:01.056 A:middle
And that's that you used to have

00:41:59.536 --> 00:42:01.056 A:middle
And that's that you used to have

00:42:01.086 --> 00:42:03.146 A:middle
to write Iterator.Element to

00:42:03.146 --> 00:42:04.266 A:middle
refer to the type of the

00:42:04.266 --> 00:42:05.256 A:middle
elements of the sequence.

00:42:06.306 --> 00:42:08.116 A:middle
In Swift 4, you can drop the

00:42:08.116 --> 00:42:08.506 A:middle
Iterator.

00:42:08.506 --> 00:42:10.796 A:middle
because sequence has an element

00:42:10.856 --> 00:42:11.706 A:middle
type of its own.

00:42:13.006 --> 00:42:13.786 A:middle
Now, this might seem like a

00:42:13.786 --> 00:42:15.356 A:middle
really easy features we have

00:42:15.356 --> 00:42:15.486 A:middle
added.

00:42:15.486 --> 00:42:16.706 A:middle
But we actually couldn't do it

00:42:17.016 --> 00:42:18.506 A:middle
without the ability to constrain

00:42:18.506 --> 00:42:19.466 A:middle
associated types.

00:42:19.516 --> 00:42:20.396 A:middle
And I'll show you how.

00:42:22.026 --> 00:42:23.626 A:middle
So, in Swift 3, we had a

00:42:23.626 --> 00:42:25.576 A:middle
protocol sequence, it had an

00:42:25.576 --> 00:42:26.916 A:middle
associated type iterator.

00:42:27.526 --> 00:42:28.756 A:middle
And the iterator had an

00:42:28.756 --> 00:42:30.136 A:middle
associated type for the element.

00:42:30.816 --> 00:42:33.856 A:middle
In Swift 4, we added the

00:42:33.856 --> 00:42:36.736 A:middle
associated type Element and then

00:42:37.246 --> 00:42:38.856 A:middle
we add a where clause to the

00:42:38.856 --> 00:42:40.916 A:middle
Iterator associated type to

00:42:40.916 --> 00:42:43.026 A:middle
require that its element is the

00:42:43.106 --> 00:42:44.536 A:middle
same as sequence's element.

00:42:45.366 --> 00:42:46.336 A:middle
Otherwise they could get out of

00:42:46.336 --> 00:42:47.426 A:middle
sync and that would cause

00:42:47.426 --> 00:42:47.976 A:middle
difficulties.

00:42:49.276 --> 00:42:50.326 A:middle
We've used this in several

00:42:50.326 --> 00:42:51.656 A:middle
places in the standard library.

00:42:52.396 --> 00:42:54.366 A:middle
So, for example, previously

00:42:54.366 --> 00:42:55.996 A:middle
there was no guarantee the

00:42:55.996 --> 00:42:58.006 A:middle
elements of a subsequence were

00:42:58.006 --> 00:42:59.266 A:middle
the same type as the elements of

00:42:59.266 --> 00:42:59.736 A:middle
a sequence.

00:43:00.646 --> 00:43:01.896 A:middle
No one would ever want to write

00:43:01.896 --> 00:43:03.006 A:middle
a sequence where that wasn't the

00:43:03.006 --> 00:43:03.336 A:middle
case.

00:43:03.666 --> 00:43:05.026 A:middle
It would be impossible to use.

00:43:05.286 --> 00:43:06.746 A:middle
But, still it wasn't guaranteed

00:43:06.746 --> 00:43:08.356 A:middle
by the compiler, because we have

00:43:08.356 --> 00:43:09.846 A:middle
no way of expressing it in the

00:43:09.846 --> 00:43:10.376 A:middle
language.

00:43:11.146 --> 00:43:12.806 A:middle
Now, with where clauses on

00:43:12.806 --> 00:43:14.596 A:middle
associated types we can make

00:43:14.596 --> 00:43:15.276 A:middle
that guarantee.

00:43:16.826 --> 00:43:18.016 A:middle
So, what does this mean for your

00:43:18.016 --> 00:43:18.256 A:middle
code?

00:43:19.866 --> 00:43:21.056 A:middle
Well, if you've even extended

00:43:21.086 --> 00:43:22.436 A:middle
sequence or collection yourself,

00:43:22.436 --> 00:43:23.936 A:middle
you've probably found that you

00:43:23.936 --> 00:43:25.016 A:middle
had to add all of these

00:43:25.016 --> 00:43:26.736 A:middle
seemingly unnecessary where

00:43:26.736 --> 00:43:29.156 A:middle
clauses to your extension in

00:43:29.156 --> 00:43:30.196 A:middle
order to guarantee that it would

00:43:30.196 --> 00:43:31.696 A:middle
compile because the body was

00:43:31.696 --> 00:43:33.736 A:middle
relying on things the protocol

00:43:33.846 --> 00:43:34.606 A:middle
didn't guarantee.

00:43:35.966 --> 00:43:37.966 A:middle
Now, because we've done the

00:43:37.966 --> 00:43:38.686 A:middle
things you've seen in the

00:43:38.686 --> 00:43:40.546 A:middle
previous slides, it can

00:43:40.546 --> 00:43:41.206 A:middle
guarantee that.

00:43:41.206 --> 00:43:43.496 A:middle
And so, you'll get warnings

00:43:43.796 --> 00:43:44.816 A:middle
telling you that you now have

00:43:44.876 --> 00:43:45.986 A:middle
redundant constraints.

00:43:47.096 --> 00:43:48.726 A:middle
These are just warnings in both

00:43:48.726 --> 00:43:50.276 A:middle
Swift 3 and Swift 4 mode, and

00:43:50.276 --> 00:43:51.616 A:middle
all they're telling you is that

00:43:51.616 --> 00:43:53.176 A:middle
they're unnecessary and you can

00:43:53.676 --> 00:43:55.126 A:middle
neaten up your code, which you

00:43:55.126 --> 00:43:56.926 A:middle
can do at your own pace.

00:43:58.056 --> 00:43:59.326 A:middle
Now, there's one more thing to

00:43:59.326 --> 00:44:00.666 A:middle
know about these new constraints

00:43:59.326 --> 00:44:00.666 A:middle
know about these new constraints

00:44:00.666 --> 00:44:01.186 A:middle
that we've added.

00:44:01.276 --> 00:44:02.746 A:middle
And that's that this is one of

00:44:02.746 --> 00:44:04.476 A:middle
the few things that is not

00:44:04.476 --> 00:44:05.896 A:middle
backwardly compatible in Swift

00:44:05.896 --> 00:44:06.796 A:middle
3.2 mode.

00:44:07.436 --> 00:44:09.036 A:middle
Because protocol performance has

00:44:09.116 --> 00:44:10.186 A:middle
to be consistent across the

00:44:10.186 --> 00:44:11.186 A:middle
entire program.

00:44:12.546 --> 00:44:13.566 A:middle
So, if you written your own

00:44:13.566 --> 00:44:15.216 A:middle
custom collection types, that

00:44:15.546 --> 00:44:17.186 A:middle
might happen to violate some of

00:44:17.186 --> 00:44:18.786 A:middle
these constraints, you'll have

00:44:18.846 --> 00:44:20.266 A:middle
to resolve those issues before

00:44:20.266 --> 00:44:21.236 A:middle
you can compile with the new

00:44:21.236 --> 00:44:21.746 A:middle
compiler.

00:44:22.686 --> 00:44:24.076 A:middle
We think this is a pretty rare

00:44:24.146 --> 00:44:24.846 A:middle
thing to happen.

00:44:25.086 --> 00:44:26.666 A:middle
It's usually an oversight and

00:44:26.666 --> 00:44:28.136 A:middle
it's usually easily resolved.

00:44:28.166 --> 00:44:29.346 A:middle
But it's something to be aware

00:44:29.346 --> 00:44:31.006 A:middle
of if you have done this.

00:44:32.716 --> 00:44:34.296 A:middle
So, finally, let's talk about

00:44:34.296 --> 00:44:35.166 A:middle
generic subscripts.

00:44:36.076 --> 00:44:37.516 A:middle
Earlier, we saw an example of a

00:44:37.516 --> 00:44:38.876 A:middle
one-sided range syntax.

00:44:39.666 --> 00:44:40.536 A:middle
So, how did we actually

00:44:40.536 --> 00:44:41.896 A:middle
implement this internally within

00:44:41.896 --> 00:44:42.676 A:middle
the standard library?

00:44:42.676 --> 00:44:47.376 A:middle
Well, first, there's a new type

00:44:47.566 --> 00:44:48.596 A:middle
partial range from.

00:44:49.116 --> 00:44:50.106 A:middle
It looks a lot like a regular

00:44:50.106 --> 00:44:51.696 A:middle
range, but it only has a lower

00:44:51.696 --> 00:44:51.996 A:middle
bound.

00:44:52.646 --> 00:44:55.956 A:middle
Next, there's a protocol range

00:44:55.956 --> 00:44:57.636 A:middle
expression, which we've used to

00:44:57.636 --> 00:44:59.206 A:middle
unify all of the different kinds

00:44:59.206 --> 00:45:00.036 A:middle
of range types.

00:44:59.206 --> 00:45:00.036 A:middle
of range types.

00:45:00.776 --> 00:45:01.856 A:middle
It has a method that takes a

00:45:01.856 --> 00:45:03.996 A:middle
collection and uses that to turn

00:45:03.996 --> 00:45:05.586 A:middle
any range expression into a

00:45:05.586 --> 00:45:07.176 A:middle
concrete range type that can be

00:45:07.176 --> 00:45:08.006 A:middle
used for slicing.

00:45:08.626 --> 00:45:11.936 A:middle
For example, partial range from

00:45:12.096 --> 00:45:13.776 A:middle
uses the collections end index

00:45:14.006 --> 00:45:15.376 A:middle
to fill in the missing upper

00:45:15.376 --> 00:45:15.716 A:middle
bound.

00:45:16.426 --> 00:45:19.586 A:middle
Now that we have that protocol,

00:45:19.776 --> 00:45:21.566 A:middle
we can extend string with a

00:45:21.566 --> 00:45:23.876 A:middle
generic subscript that will take

00:45:23.956 --> 00:45:25.656 A:middle
any kind of range expression and

00:45:25.656 --> 00:45:27.406 A:middle
use that range expression to

00:45:27.406 --> 00:45:28.526 A:middle
slice a substring.

00:45:30.346 --> 00:45:31.316 A:middle
But because strings now

00:45:31.316 --> 00:45:33.176 A:middle
collections, we're actually able

00:45:33.176 --> 00:45:34.776 A:middle
to put this feature directly on

00:45:34.776 --> 00:45:35.276 A:middle
collection.

00:45:35.276 --> 00:45:37.026 A:middle
And that includes any custom

00:45:37.026 --> 00:45:38.066 A:middle
collections that you might have

00:45:38.066 --> 00:45:39.456 A:middle
written, which get this feature,

00:45:39.686 --> 00:45:41.386 A:middle
automatically via the protocol.

00:45:43.006 --> 00:45:44.016 A:middle
We were actually able to clean

00:45:44.016 --> 00:45:45.366 A:middle
up a lot of code in the standard

00:45:45.366 --> 00:45:46.696 A:middle
library this way because we

00:45:46.696 --> 00:45:47.636 A:middle
could remove all of the

00:45:47.636 --> 00:45:49.446 A:middle
duplicated slicing operations we

00:45:49.446 --> 00:45:50.806 A:middle
had to hard code for each

00:45:50.806 --> 00:45:51.906 A:middle
different range type we wanted

00:45:51.906 --> 00:45:53.426 A:middle
to support and replace them with

00:45:53.426 --> 00:45:54.926 A:middle
a single generic subscript.

00:45:55.496 --> 00:45:56.746 A:middle
And we hope that you can find

00:45:56.746 --> 00:45:58.356 A:middle
similar ways to use generics to

00:45:58.356 --> 00:46:01.176 A:middle
clean up your code as well.

00:45:58.356 --> 00:46:01.176 A:middle
clean up your code as well.

00:46:01.676 --> 00:46:02.396 A:middle
So, there are loads of new

00:46:02.396 --> 00:46:03.506 A:middle
features I didn't get a chance

00:46:03.506 --> 00:46:04.866 A:middle
to cover today, like some new

00:46:04.866 --> 00:46:05.796 A:middle
numeric protocols.

00:46:06.156 --> 00:46:06.956 A:middle
And some really cool

00:46:06.956 --> 00:46:08.116 A:middle
enhancements to the dictionary

00:46:08.186 --> 00:46:08.386 A:middle
type.

00:46:09.506 --> 00:46:11.086 A:middle
One of the things we've added is

00:46:11.086 --> 00:46:12.866 A:middle
a new method on collections that

00:46:12.866 --> 00:46:14.206 A:middle
allows you to swap two elements

00:46:14.386 --> 00:46:16.006 A:middle
in the collection, given two

00:46:16.006 --> 00:46:17.296 A:middle
indices instead of using the

00:46:17.296 --> 00:46:18.966 A:middle
global function that takes two

00:46:18.966 --> 00:46:19.736 A:middle
arguments in out.

00:46:21.046 --> 00:46:22.376 A:middle
And this was to support a new

00:46:22.376 --> 00:46:24.206 A:middle
feature of exclusive access to

00:46:24.206 --> 00:46:25.526 A:middle
memory that John's going to talk

00:46:25.526 --> 00:46:26.276 A:middle
to you more about now.

00:46:27.516 --> 00:46:34.266 A:middle
[ Applause ]

00:46:34.766 --> 00:46:35.486 A:middle
&gt;&gt; Thanks, Ben.

00:46:36.026 --> 00:46:37.316 A:middle
Thanks, Ben.

00:46:38.616 --> 00:46:40.556 A:middle
Exclusive access to memory is a

00:46:40.556 --> 00:46:42.126 A:middle
new rule that we're adding in

00:46:42.126 --> 00:46:42.966 A:middle
Swift 4.

00:46:43.636 --> 00:46:46.896 A:middle
It's really the first part of a

00:46:46.896 --> 00:46:48.556 A:middle
much larger feature that we call

00:46:48.716 --> 00:46:49.236 A:middle
ownership.

00:46:49.946 --> 00:46:51.666 A:middle
Ownership is all about making it

00:46:51.666 --> 00:46:53.196 A:middle
easier to understand the

00:46:53.196 --> 00:46:54.986 A:middle
performance of your program.

00:46:55.826 --> 00:46:57.296 A:middle
It's going to make it easier for

00:46:57.296 --> 00:46:59.106 A:middle
you to optimize your program by

00:46:59.106 --> 00:47:01.206 A:middle
eliminating unnecessary copies

00:46:59.106 --> 00:47:01.206 A:middle
eliminating unnecessary copies

00:47:01.206 --> 00:47:03.066 A:middle
and retains when you need to.

00:47:03.216 --> 00:47:04.966 A:middle
But it's also going to enable us

00:47:05.126 --> 00:47:07.336 A:middle
to make Swift, faster by default

00:47:07.636 --> 00:47:08.836 A:middle
in a number of cases.

00:47:09.726 --> 00:47:11.426 A:middle
And ultimately, it's going to

00:47:11.426 --> 00:47:13.936 A:middle
enable some really powerful new

00:47:13.936 --> 00:47:15.986 A:middle
language features for creating

00:47:16.126 --> 00:47:18.156 A:middle
safe and optimally efficient

00:47:18.156 --> 00:47:20.356 A:middle
abstractions, before we can do

00:47:20.356 --> 00:47:22.396 A:middle
any of that we have to make it

00:47:22.476 --> 00:47:23.976 A:middle
easier to reason about memory.

00:47:24.326 --> 00:47:26.116 A:middle
And that means enforcing

00:47:26.146 --> 00:47:27.916 A:middle
exclusive access to memory.

00:47:28.976 --> 00:47:30.186 A:middle
So, what do I mean by that.

00:47:31.486 --> 00:47:32.576 A:middle
Let's walk through an example.

00:47:33.606 --> 00:47:35.086 A:middle
Often it happens that I'm

00:47:35.246 --> 00:47:37.046 A:middle
iterating over a collection like

00:47:37.126 --> 00:47:38.766 A:middle
this and I want to modify each

00:47:38.766 --> 00:47:39.776 A:middle
element as I go.

00:47:40.616 --> 00:47:42.166 A:middle
This is a pretty common pattern.

00:47:42.166 --> 00:47:43.856 A:middle
So, I'm going to go ahead and

00:47:43.856 --> 00:47:45.746 A:middle
extract that into a method.

00:47:46.486 --> 00:47:49.096 A:middle
Now that I've got this method

00:47:49.666 --> 00:47:51.376 A:middle
I've got a generic operation

00:47:51.546 --> 00:47:53.346 A:middle
that I can use to modify any

00:47:53.346 --> 00:47:54.466 A:middle
mutable collection.

00:47:54.976 --> 00:47:58.956 A:middle
Each element at a time.

00:47:59.156 --> 00:48:01.966 A:middle
This operation is iterating over

00:47:59.156 --> 00:48:01.966 A:middle
This operation is iterating over

00:48:01.966 --> 00:48:03.676 A:middle
a set of indices that it

00:48:03.726 --> 00:48:07.386 A:middle
captures at the start of the

00:48:07.386 --> 00:48:08.176 A:middle
iteration.

00:48:09.226 --> 00:48:11.256 A:middle
So, this only really works if

00:48:11.256 --> 00:48:13.286 A:middle
nothing within this operation

00:48:13.636 --> 00:48:15.186 A:middle
actually modifies the set of

00:48:15.186 --> 00:48:16.976 A:middle
indices by adding or removing

00:48:16.976 --> 00:48:18.186 A:middle
elements from the collection.

00:48:19.356 --> 00:48:21.456 A:middle
But I can pretty clearly see

00:48:21.556 --> 00:48:22.816 A:middle
nothing in this method is

00:48:22.816 --> 00:48:23.786 A:middle
actually modifying the

00:48:23.786 --> 00:48:24.286 A:middle
collection.

00:48:24.416 --> 00:48:28.186 A:middle
Right? Well, okay I do call this

00:48:28.186 --> 00:48:30.056 A:middle
closure that was passed in.

00:48:30.056 --> 00:48:31.726 A:middle
And a closure is arbitrary code.

00:48:32.386 --> 00:48:34.406 A:middle
But again, I look at this

00:48:34.406 --> 00:48:37.726 A:middle
method, and I think to myself OK

00:48:37.856 --> 00:48:39.646 A:middle
I'm only giving this closure

00:48:39.646 --> 00:48:41.816 A:middle
access to a specific element of

00:48:41.816 --> 00:48:43.196 A:middle
the collection, not to the

00:48:43.196 --> 00:48:44.216 A:middle
entire collection.

00:48:44.616 --> 00:48:47.126 A:middle
So, I should know that nothing

00:48:47.126 --> 00:48:48.406 A:middle
is allowed to modify the

00:48:48.406 --> 00:48:50.336 A:middle
collection while this operation

00:48:50.336 --> 00:48:50.986 A:middle
is underway.

00:48:52.376 --> 00:48:54.526 A:middle
Unfortunately, in Swift 3,

00:48:54.626 --> 00:48:55.586 A:middle
that's not really how the

00:48:55.586 --> 00:48:56.196 A:middle
language works.

00:48:57.546 --> 00:48:59.086 A:middle
Let's go back to that code that

00:48:59.086 --> 00:49:01.026 A:middle
I had where I was calling my

00:48:59.086 --> 00:49:01.026 A:middle
I had where I was calling my

00:49:01.026 --> 00:49:01.486 A:middle
method.

00:49:02.236 --> 00:49:03.106 A:middle
What if instead of just

00:49:03.106 --> 00:49:06.026 A:middle
multiplying the element by 2, I

00:49:06.476 --> 00:49:08.296 A:middle
try to access the numbers

00:49:08.296 --> 00:49:08.976 A:middle
variable.

00:49:09.976 --> 00:49:11.276 A:middle
There's nothing stopping me from

00:49:11.276 --> 00:49:11.766 A:middle
doing that.

00:49:12.076 --> 00:49:14.756 A:middle
I can just, at any point in this

00:49:14.756 --> 00:49:17.336 A:middle
closure, remove something or add

00:49:17.336 --> 00:49:20.106 A:middle
something to the variable, to

00:49:20.106 --> 00:49:21.756 A:middle
the array while I'm iterating

00:49:21.756 --> 00:49:23.176 A:middle
over it in another method.

00:49:23.796 --> 00:49:26.466 A:middle
As soon as I do this, one thing

00:49:26.466 --> 00:49:27.866 A:middle
immediately stands out to me.

00:49:28.326 --> 00:49:30.216 A:middle
It's a lot harder to reason

00:49:30.256 --> 00:49:32.376 A:middle
about what's going on with this

00:49:32.376 --> 00:49:33.106 A:middle
numbers array.

00:49:33.106 --> 00:49:36.456 A:middle
It used to be the case before

00:49:36.826 --> 00:49:38.456 A:middle
that I could just look at each

00:49:38.456 --> 00:49:39.996 A:middle
individual function in my

00:49:39.996 --> 00:49:41.786 A:middle
program and think about what it

00:49:41.986 --> 00:49:44.186 A:middle
individually is doing to each

00:49:44.306 --> 00:49:46.106 A:middle
variable that it has access to.

00:49:46.736 --> 00:49:47.596 A:middle
And that's great.

00:49:47.896 --> 00:49:49.086 A:middle
That's one of the best

00:49:49.156 --> 00:49:50.976 A:middle
properties of what we call value

00:49:50.976 --> 00:49:51.416 A:middle
semantics.

00:49:51.416 --> 00:49:52.836 A:middle
That you get this kind of

00:49:52.896 --> 00:49:55.226 A:middle
isolation in each program, each

00:49:55.266 --> 00:49:56.286 A:middle
part of your program.

00:49:56.786 --> 00:49:58.706 A:middle
Everything composes together and

00:49:58.866 --> 00:50:00.206 A:middle
you don't have to reason about

00:49:58.866 --> 00:50:00.206 A:middle
you don't have to reason about

00:50:00.256 --> 00:50:01.836 A:middle
everything all at once.

00:50:03.136 --> 00:50:05.586 A:middle
But unfortunately, because we

00:50:05.586 --> 00:50:07.476 A:middle
can do things like this we get a

00:50:07.556 --> 00:50:09.966 A:middle
sort of reference semantics like

00:50:09.966 --> 00:50:11.936 A:middle
affect, where you all the sudden

00:50:11.936 --> 00:50:13.556 A:middle
have to reason about your entire

00:50:13.636 --> 00:50:15.336 A:middle
program together in order to

00:50:15.336 --> 00:50:16.676 A:middle
understand what's going on.

00:50:17.646 --> 00:50:19.076 A:middle
Here, when I do this sort of

00:50:19.176 --> 00:50:21.056 A:middle
thing, I'm going to run past the

00:50:21.116 --> 00:50:21.876 A:middle
end of the array.

00:50:22.686 --> 00:50:24.836 A:middle
Now, it's pretty easy for me to

00:50:24.836 --> 00:50:26.876 A:middle
go ahead and try to fix that in

00:50:26.876 --> 00:50:29.566 A:middle
my method, by instead of

00:50:29.856 --> 00:50:31.006 A:middle
iterating over the set of

00:50:31.006 --> 00:50:32.356 A:middle
indices at the start of the

00:50:32.416 --> 00:50:34.636 A:middle
collection, I'm going to reload

00:50:34.636 --> 00:50:37.066 A:middle
the index each time through, and

00:50:37.066 --> 00:50:38.986 A:middle
compare that and that way, if I

00:50:38.986 --> 00:50:40.486 A:middle
move something from the end,

00:50:40.486 --> 00:50:41.416 A:middle
everything is going to work.

00:50:41.936 --> 00:50:46.266 A:middle
But, oh, there has to be another

00:50:46.296 --> 00:50:46.456 A:middle
way.

00:50:46.656 --> 00:50:47.336 A:middle
A better way.

00:50:47.966 --> 00:50:50.076 A:middle
Because I've made my code so

00:50:50.076 --> 00:50:51.946 A:middle
much uglier, and a little bit

00:50:51.946 --> 00:50:52.556 A:middle
slower.

00:50:52.856 --> 00:50:54.376 A:middle
And you know if that were good

00:50:54.376 --> 00:50:55.896 A:middle
enough, that would be a

00:50:55.956 --> 00:50:57.226 A:middle
reasonable tradeoff, right.

00:50:57.846 --> 00:50:59.486 A:middle
You know, lose a little bit of

00:50:59.486 --> 00:51:00.886 A:middle
performance, and making your

00:50:59.486 --> 00:51:00.886 A:middle
performance, and making your

00:51:00.886 --> 00:51:03.826 A:middle
code a little bit uglier is OK,

00:51:04.036 --> 00:51:06.376 A:middle
if it leads it to it being more

00:51:06.376 --> 00:51:06.806 A:middle
correct.

00:51:08.336 --> 00:51:09.466 A:middle
But that's not really good

00:51:09.466 --> 00:51:09.986 A:middle
enough here.

00:51:10.686 --> 00:51:11.986 A:middle
Let's go back to this closure

00:51:11.986 --> 00:51:12.306 A:middle
again.

00:51:12.856 --> 00:51:14.966 A:middle
What if instead of removing one

00:51:15.016 --> 00:51:19.126 A:middle
thing at the end of the loop, I

00:51:19.126 --> 00:51:20.796 A:middle
actually just wipe the entire

00:51:20.846 --> 00:51:22.576 A:middle
array out before I even access

00:51:22.666 --> 00:51:23.216 A:middle
the element.

00:51:23.826 --> 00:51:26.436 A:middle
What is this even accessing at

00:51:26.496 --> 00:51:27.036 A:middle
this point?

00:51:27.466 --> 00:51:28.686 A:middle
Where is this going?

00:51:29.516 --> 00:51:31.276 A:middle
I'm assigning to something that

00:51:31.276 --> 00:51:32.856 A:middle
doesn't really exist anymore

00:51:33.076 --> 00:51:34.246 A:middle
because the array doesn't have

00:51:34.246 --> 00:51:35.706 A:middle
any elements in it.

00:51:37.016 --> 00:51:38.806 A:middle
That's a really good question

00:51:38.836 --> 00:51:40.116 A:middle
and in order to answer it we

00:51:40.116 --> 00:51:41.076 A:middle
need to dig into the

00:51:41.076 --> 00:51:42.756 A:middle
implementation of array a little

00:51:43.336 --> 00:51:43.576 A:middle
bit.

00:51:43.576 --> 00:51:45.846 A:middle
Array is a copy on write value

00:51:45.846 --> 00:51:47.156 A:middle
type, implemented with a

00:51:47.266 --> 00:51:49.166 A:middle
reference counted buffer.

00:51:49.916 --> 00:51:52.626 A:middle
At the beginning of the loop,

00:51:53.956 --> 00:51:57.026 A:middle
numbers is pointing to exactly

00:51:57.076 --> 00:51:58.846 A:middle
to that buffer.

00:51:59.036 --> 00:52:00.866 A:middle
For performance, Swift really

00:51:59.036 --> 00:52:00.866 A:middle
For performance, Swift really

00:52:00.866 --> 00:52:02.836 A:middle
wants to bind the element

00:52:03.066 --> 00:52:05.816 A:middle
variable that's passed into the

00:52:05.816 --> 00:52:08.316 A:middle
closure directly to the memory

00:52:08.316 --> 00:52:09.296 A:middle
within that buffer.

00:52:10.106 --> 00:52:11.706 A:middle
But that creates a problem

00:52:11.966 --> 00:52:12.886 A:middle
because when we do this

00:52:12.886 --> 00:52:16.056 A:middle
assignment, numbers is no longer

00:52:16.056 --> 00:52:17.746 A:middle
pointing to that buffer, which

00:52:17.746 --> 00:52:19.026 A:middle
means it's no longer keeping it

00:52:19.026 --> 00:52:19.536 A:middle
alive.

00:52:20.736 --> 00:52:23.026 A:middle
Swift has to be a safe language.

00:52:23.266 --> 00:52:24.826 A:middle
We don't want to just leave this

00:52:24.826 --> 00:52:26.236 A:middle
as a dangling reference.

00:52:26.646 --> 00:52:28.256 A:middle
So, something has to be keeping

00:52:28.256 --> 00:52:30.226 A:middle
this buffer alive in order for

00:52:30.226 --> 00:52:31.646 A:middle
this to not end up crashing the

00:52:31.646 --> 00:52:32.216 A:middle
program.

00:52:32.986 --> 00:52:33.786 A:middle
How can that work?

00:52:34.616 --> 00:52:37.006 A:middle
Well the way it works is that

00:52:37.096 --> 00:52:39.556 A:middle
Swift actually implicitly

00:52:39.556 --> 00:52:41.986 A:middle
creates a reference to the

00:52:41.986 --> 00:52:43.976 A:middle
buffer for the duration of the

00:52:43.976 --> 00:52:45.206 A:middle
subscript operation.

00:52:46.226 --> 00:52:48.886 A:middle
And that makes things not crash.

00:52:49.386 --> 00:52:50.926 A:middle
But it creates this extra

00:52:50.926 --> 00:52:53.266 A:middle
performance penalty that we're

00:52:53.266 --> 00:52:55.096 A:middle
hoping with the optimizer will

00:52:55.146 --> 00:52:57.486 A:middle
clean up on every single time

00:52:57.706 --> 00:52:59.136 A:middle
that we subscript into the

00:52:59.136 --> 00:52:59.346 A:middle
array.

00:52:59.946 --> 00:53:03.906 A:middle
So, this kind of nonexclusive

00:52:59.946 --> 00:53:03.906 A:middle
So, this kind of nonexclusive

00:53:03.906 --> 00:53:05.456 A:middle
access to memory creates

00:53:05.456 --> 00:53:07.446 A:middle
problems at multiple levels.

00:53:07.676 --> 00:53:09.166 A:middle
Cascading problems in your

00:53:09.206 --> 00:53:09.716 A:middle
program.

00:53:10.166 --> 00:53:11.766 A:middle
It makes things harder to reason

00:53:11.766 --> 00:53:12.136 A:middle
about.

00:53:12.516 --> 00:53:14.356 A:middle
It makes your code less general

00:53:14.676 --> 00:53:16.236 A:middle
and harder to prove correct.

00:53:17.206 --> 00:53:18.566 A:middle
And it creates performance

00:53:18.566 --> 00:53:20.486 A:middle
problems both in your part of

00:53:20.486 --> 00:53:22.946 A:middle
the program and for Swift, when

00:53:22.946 --> 00:53:24.756 A:middle
it's trying to optimize these

00:53:24.756 --> 00:53:26.086 A:middle
general data structures.

00:53:27.156 --> 00:53:28.826 A:middle
The solution is that we have to

00:53:28.826 --> 00:53:31.276 A:middle
have exclusive access to memory.

00:53:31.806 --> 00:53:35.336 A:middle
What do I mean by exclusive?

00:53:35.496 --> 00:53:39.016 A:middle
Well it's OK to have two

00:53:39.016 --> 00:53:40.086 A:middle
different parts of the program

00:53:40.086 --> 00:53:41.356 A:middle
that are reading from the same

00:53:41.356 --> 00:53:42.656 A:middle
variable at the same time.

00:53:44.286 --> 00:53:45.326 A:middle
But, when I have something

00:53:45.326 --> 00:53:46.926 A:middle
that's writing to the variable,

00:53:47.266 --> 00:53:48.946 A:middle
it's very important that nothing

00:53:48.946 --> 00:53:50.476 A:middle
else be accessing at all.

00:53:50.946 --> 00:53:52.166 A:middle
The thing that's writing to the

00:53:52.166 --> 00:53:53.866 A:middle
variable should be exclusive.

00:53:54.736 --> 00:53:55.246 A:middle
And that's it.

00:53:55.726 --> 00:53:56.616 A:middle
That's the rule.

00:53:56.616 --> 00:53:58.006 A:middle
That's the new rule that we're

00:53:58.066 --> 00:53:59.526 A:middle
adding in Swift 4.

00:54:00.186 --> 00:54:04.166 A:middle
So, how do we enforce it?

00:54:04.796 --> 00:54:08.896 A:middle
Well, in most cases, like in our

00:54:08.896 --> 00:54:10.896 A:middle
original example, Swift is

00:54:10.896 --> 00:54:12.676 A:middle
actually capable of enforcing

00:54:12.676 --> 00:54:15.846 A:middle
this at compile time.

00:54:16.056 --> 00:54:18.136 A:middle
Here I'm calling a mutating

00:54:18.136 --> 00:54:19.736 A:middle
method on numbers.

00:54:19.986 --> 00:54:22.046 A:middle
That initiates a right to it for

00:54:22.046 --> 00:54:23.166 A:middle
the duration of the call.

00:54:23.166 --> 00:54:27.306 A:middle
When I come along later within

00:54:27.306 --> 00:54:29.576 A:middle
that call, and call another

00:54:29.576 --> 00:54:30.876 A:middle
mutating method on it.

00:54:31.496 --> 00:54:33.226 A:middle
I've got a conflicting right

00:54:33.636 --> 00:54:34.856 A:middle
that violates the rule.

00:54:35.346 --> 00:54:36.596 A:middle
And Swift can just see that

00:54:36.596 --> 00:54:38.486 A:middle
that's happening at compile time

00:54:38.796 --> 00:54:39.806 A:middle
and tell you about it

00:54:39.856 --> 00:54:40.576 A:middle
immediately.

00:54:41.166 --> 00:54:44.036 A:middle
Now, that's generally going to

00:54:44.036 --> 00:54:46.726 A:middle
be true in most common value

00:54:46.796 --> 00:54:48.336 A:middle
semantics sorts of situations.

00:54:49.346 --> 00:54:50.906 A:middle
But there are some situations

00:54:51.966 --> 00:54:54.236 A:middle
where that's not possible,

00:54:54.816 --> 00:54:56.176 A:middle
generally because of some sort

00:54:56.176 --> 00:54:57.276 A:middle
of reference semantics.

00:54:57.446 --> 00:54:59.106 A:middle
Either a global variable, or

00:54:59.106 --> 00:55:01.116 A:middle
some sort of shared memory like

00:54:59.106 --> 00:55:01.116 A:middle
some sort of shared memory like

00:55:01.116 --> 00:55:02.126 A:middle
a class property.

00:55:03.486 --> 00:55:04.526 A:middle
So, let's go back to our

00:55:04.526 --> 00:55:05.446 A:middle
original example.

00:55:05.976 --> 00:55:08.206 A:middle
Here, numbers was a local

00:55:08.206 --> 00:55:08.776 A:middle
variable.

00:55:09.266 --> 00:55:12.396 A:middle
But what if instead it were a

00:55:13.616 --> 00:55:15.726 A:middle
class property?

00:55:15.816 --> 00:55:17.486 A:middle
Well, the situation is still

00:55:17.486 --> 00:55:20.186 A:middle
basically the same.

00:55:20.386 --> 00:55:22.106 A:middle
Here, I'm calling a mutating

00:55:22.106 --> 00:55:23.936 A:middle
method on a class property.

00:55:25.076 --> 00:55:27.326 A:middle
And within the closure, I'm

00:55:27.326 --> 00:55:29.616 A:middle
calling a mutating method on the

00:55:30.166 --> 00:55:31.366 A:middle
same class property.

00:55:32.266 --> 00:55:34.336 A:middle
But they are on objects that the

00:55:34.336 --> 00:55:36.816 A:middle
compiler can't reason whether

00:55:36.816 --> 00:55:38.446 A:middle
they're the same object or not.

00:55:39.596 --> 00:55:42.036 A:middle
In general, the point of class

00:55:42.286 --> 00:55:44.486 A:middle
types is that you can move them,

00:55:44.486 --> 00:55:46.496 A:middle
copy them around, share them

00:55:46.496 --> 00:55:47.666 A:middle
throughout your program.

00:55:48.306 --> 00:55:51.186 A:middle
And use them wherever you like.

00:55:51.736 --> 00:55:54.116 A:middle
But, that means that the

00:55:54.116 --> 00:55:55.746 A:middle
compiler can no longer really

00:55:55.856 --> 00:55:58.136 A:middle
tell you conclusively whether or

00:55:58.136 --> 00:56:00.456 A:middle
not any particular function all

00:55:58.136 --> 00:56:00.456 A:middle
not any particular function all

00:56:00.456 --> 00:56:02.936 A:middle
or access like this is actually

00:56:02.936 --> 00:56:04.396 A:middle
accessing the same object.

00:56:05.116 --> 00:56:06.226 A:middle
So, the compiler has to be

00:56:06.226 --> 00:56:06.976 A:middle
conservative.

00:56:07.536 --> 00:56:09.556 A:middle
Now, it would be prohibitive if

00:56:09.556 --> 00:56:11.606 A:middle
we just banned all this sort of

00:56:11.676 --> 00:56:12.816 A:middle
thing all the time.

00:56:12.816 --> 00:56:14.486 A:middle
So, instead we do the check

00:56:14.586 --> 00:56:15.486 A:middle
dynamically.

00:56:16.256 --> 00:56:17.366 A:middle
Which means that we'll get an

00:56:17.366 --> 00:56:20.286 A:middle
error like this at run time.

00:56:20.896 --> 00:56:22.986 A:middle
But only if they're actually the

00:56:22.986 --> 00:56:23.696 A:middle
same object.

00:56:23.846 --> 00:56:24.806 A:middle
Of course, if they're different

00:56:24.806 --> 00:56:27.116 A:middle
objects, they're considered the

00:56:27.256 --> 00:56:29.076 A:middle
two class properties on them are

00:56:29.076 --> 00:56:30.776 A:middle
considered different memory.

00:56:31.346 --> 00:56:32.316 A:middle
And there's no conflict.

00:56:32.846 --> 00:56:37.726 A:middle
Now this enforcement that we do

00:56:38.776 --> 00:56:40.936 A:middle
is for performance reasons only

00:56:40.936 --> 00:56:42.486 A:middle
done within a single thread.

00:56:43.116 --> 00:56:45.476 A:middle
However, the thread sanitizer

00:56:45.476 --> 00:56:47.406 A:middle
tool that we make available in

00:56:47.486 --> 00:56:49.226 A:middle
Xcode will catch this sort of

00:56:49.266 --> 00:56:50.906 A:middle
problem even across threads.

00:56:51.716 --> 00:56:53.016 A:middle
There's a great session later

00:56:53.016 --> 00:56:53.546 A:middle
this week.

00:56:53.866 --> 00:56:55.486 A:middle
I strongly encourage any of you

00:56:55.486 --> 00:56:57.706 A:middle
to go to about finding bugs like

00:56:57.776 --> 00:56:59.326 A:middle
this with Xcode.

00:57:03.216 --> 00:57:05.226 A:middle
This is a Swift 4 rule.

00:57:06.636 --> 00:57:08.066 A:middle
Like we said yesterday in the

00:57:08.306 --> 00:57:12.596 A:middle
State of Union, Swift 3.2 is all

00:57:12.596 --> 00:57:15.466 A:middle
about allowing your existing

00:57:15.466 --> 00:57:16.896 A:middle
code to continue to work.

00:57:17.606 --> 00:57:19.526 A:middle
So, in Swift 3.2, this is just a

00:57:19.586 --> 00:57:19.886 A:middle
warning.

00:57:20.716 --> 00:57:23.436 A:middle
However, because Swift 4 and

00:57:23.436 --> 00:57:27.356 A:middle
Swift 3 need to interoperate in

00:57:27.356 --> 00:57:30.066 A:middle
a future version of Xcode we are

00:57:30.066 --> 00:57:31.676 A:middle
going to have to make this an

00:57:31.726 --> 00:57:33.496 A:middle
error even in Swift 3 mode.

00:57:34.236 --> 00:57:36.066 A:middle
So, we strongly encourage you to

00:57:36.216 --> 00:57:37.846 A:middle
pay attention to these warnings

00:57:38.316 --> 00:57:39.086 A:middle
and fix them.

00:57:39.456 --> 00:57:40.496 A:middle
Because they're just warnings

00:57:40.536 --> 00:57:41.776 A:middle
you can fix them in your own

00:57:41.856 --> 00:57:42.226 A:middle
time.

00:57:42.226 --> 00:57:44.116 A:middle
And at your own pace, but you

00:57:44.116 --> 00:57:45.486 A:middle
should take them seriously.

00:57:52.076 --> 00:57:53.966 A:middle
We're really looking forward to

00:57:54.006 --> 00:57:55.196 A:middle
the power this is going to

00:57:55.196 --> 00:57:55.576 A:middle
bring.

00:57:55.866 --> 00:57:57.066 A:middle
It's going to make it so much

00:57:57.136 --> 00:58:00.126 A:middle
easier to reason about code.

00:57:57.136 --> 00:58:00.126 A:middle
easier to reason about code.

00:58:00.126 --> 00:58:03.716 A:middle
It's going to enable a lot of

00:58:03.716 --> 00:58:05.376 A:middle
really amazing optimizations,

00:58:05.616 --> 00:58:07.416 A:middle
both in the library and in the

00:58:07.416 --> 00:58:08.106 A:middle
compiler.

00:58:08.416 --> 00:58:09.776 A:middle
And it's also going to make it

00:58:10.386 --> 00:58:12.076 A:middle
you know a lot easier for us to

00:58:12.076 --> 00:58:14.666 A:middle
deliver tools that you can use

00:58:15.016 --> 00:58:18.496 A:middle
to take advantage of to optimize

00:58:18.496 --> 00:58:20.256 A:middle
your own code in ways that are

00:58:20.256 --> 00:58:21.236 A:middle
going to be really great.

00:58:22.386 --> 00:58:23.626 A:middle
If you're interested in reading

00:58:23.626 --> 00:58:25.116 A:middle
more about what we're planning

00:58:25.116 --> 00:58:26.796 A:middle
on doing with this, there's an

00:58:26.946 --> 00:58:28.736 A:middle
ownership manifesto on the Swift

00:58:28.736 --> 00:58:30.476 A:middle
website that I would encourage

00:58:30.476 --> 00:58:32.946 A:middle
you to check out.

00:58:33.216 --> 00:58:34.546 A:middle
Now, one caveat.

00:58:34.706 --> 00:58:36.276 A:middle
The developer preview that we've

00:58:36.276 --> 00:58:38.186 A:middle
given you this week, some of

00:58:38.186 --> 00:58:39.826 A:middle
this stuff is still in progress.

00:58:40.226 --> 00:58:41.396 A:middle
There's a lot of information in

00:58:41.396 --> 00:58:42.296 A:middle
the release notes.

00:58:42.556 --> 00:58:43.766 A:middle
I really encourage you to check

00:58:43.816 --> 00:58:44.256 A:middle
those out.

00:58:44.846 --> 00:58:46.406 A:middle
We really would like you to go

00:58:46.406 --> 00:58:48.496 A:middle
ahead and make sure that all of

00:58:48.496 --> 00:58:49.426 A:middle
this stuff is enabled.

00:58:49.486 --> 00:58:50.646 A:middle
And let us know if you run into

00:58:50.646 --> 00:58:50.976 A:middle
any problems.

00:58:54.086 --> 00:58:55.676 A:middle
And that's it for what's new in

00:58:55.746 --> 00:58:56.076 A:middle
Swift.

00:58:56.836 --> 00:58:58.306 A:middle
There are a lot of great new

00:58:58.306 --> 00:59:00.506 A:middle
refinements in addition to the

00:58:58.306 --> 00:59:00.506 A:middle
refinements in addition to the

00:59:00.506 --> 00:59:03.416 A:middle
library, and to the language.

00:59:04.036 --> 00:59:05.676 A:middle
We've got a great new Swift type

00:59:06.146 --> 00:59:07.436 A:middle
and we've optimized a lot of

00:59:07.436 --> 00:59:07.896 A:middle
stuff.

00:59:08.606 --> 00:59:10.186 A:middle
And we've really done a ton of

00:59:10.186 --> 00:59:12.306 A:middle
work on the tools and improving

00:59:12.306 --> 00:59:13.526 A:middle
the performance and the code

00:59:13.526 --> 00:59:14.276 A:middle
size of your code.

00:59:14.366 --> 00:59:17.496 A:middle
I hope you have a great WWDC,

00:59:17.586 --> 00:59:18.626 A:middle
and thank you very much for

00:59:18.626 --> 00:59:18.816 A:middle
coming.

00:59:19.516 --> 00:59:23.500 A:middle
[ Applause ]
