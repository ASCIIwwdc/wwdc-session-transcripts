WEBVTT

00:00:01.176 --> 00:00:04.500 A:middle
[ Music ]

00:00:10.516 --> 00:00:14.546 A:middle
[ Applause ]

00:00:15.046 --> 00:00:15.836 A:middle
&gt;&gt; Good morning everyone.

00:00:16.245 --> 00:00:17.746 A:middle
My name is Sean and I'm an

00:00:17.746 --> 00:00:19.376 A:middle
engineer on Apple's GPU Software

00:00:19.376 --> 00:00:19.736 A:middle
Team.

00:00:20.856 --> 00:00:21.686 A:middle
In this session we're going to

00:00:21.686 --> 00:00:22.706 A:middle
talk about Ray Tracing.

00:00:23.336 --> 00:00:24.606 A:middle
So, let's first review what Ray

00:00:24.606 --> 00:00:25.866 A:middle
Tracing is.

00:00:26.556 --> 00:00:27.976 A:middle
Ray Tracing applications are

00:00:27.976 --> 00:00:29.346 A:middle
based on tracing the paths the

00:00:29.346 --> 00:00:30.816 A:middle
rays take as they interact with

00:00:30.816 --> 00:00:31.296 A:middle
a scene.

00:00:32.076 --> 00:00:33.796 A:middle
So, Ray Tracing has applications

00:00:33.796 --> 00:00:35.666 A:middle
in rendering, audio, physics

00:00:35.666 --> 00:00:36.836 A:middle
simulation, and more.

00:00:37.926 --> 00:00:39.336 A:middle
In particular Ray Tracing is

00:00:39.336 --> 00:00:41.016 A:middle
often used in offline rendering

00:00:41.016 --> 00:00:42.686 A:middle
applications to simulate

00:00:42.686 --> 00:00:43.886 A:middle
individual rays of light

00:00:43.886 --> 00:00:44.886 A:middle
bouncing around a scene.

00:00:45.586 --> 00:00:47.086 A:middle
This allows these applications

00:00:47.086 --> 00:00:48.166 A:middle
to render photo realistic

00:00:48.196 --> 00:00:49.756 A:middle
reflections, refractions,

00:00:49.926 --> 00:00:51.706 A:middle
shadows, global illumination,

00:00:51.976 --> 00:00:56.336 A:middle
and more.

00:00:56.556 --> 00:00:58.076 A:middle
Recently, Ray Tracing has also

00:00:58.076 --> 00:00:59.336 A:middle
started to be used in real-time

00:00:59.336 --> 00:01:00.366 A:middle
applications such as games.

00:00:59.336 --> 00:01:00.366 A:middle
applications such as games.

00:01:00.366 --> 00:01:02.606 A:middle
And this actually introduces

00:01:02.606 --> 00:01:03.596 A:middle
some new requirements.

00:01:05.016 --> 00:01:07.036 A:middle
First, in real-time applications

00:01:07.036 --> 00:01:08.256 A:middle
objects tend to move around.

00:01:08.326 --> 00:01:09.436 A:middle
So, we need to be able to

00:01:09.436 --> 00:01:10.926 A:middle
support both camera and object

00:01:10.926 --> 00:01:11.406 A:middle
motion.

00:01:12.376 --> 00:01:14.466 A:middle
Second, performance is now even

00:01:14.466 --> 00:01:15.136 A:middle
more critical.

00:01:15.896 --> 00:01:16.726 A:middle
This means that the ray

00:01:16.726 --> 00:01:18.206 A:middle
intersection itself has to be as

00:01:18.206 --> 00:01:20.016 A:middle
efficient as possible and we

00:01:20.016 --> 00:01:21.406 A:middle
also have to make effective use

00:01:21.406 --> 00:01:22.546 A:middle
of our limited ray budget.

00:01:23.576 --> 00:01:24.746 A:middle
So, we need to careful with our

00:01:24.746 --> 00:01:26.196 A:middle
sampling strategies, random

00:01:26.196 --> 00:01:28.256 A:middle
number generation, and so on.

00:01:29.236 --> 00:01:30.746 A:middle
Finally, even with these

00:01:30.746 --> 00:01:31.956 A:middle
techniques we won't be able to

00:01:31.956 --> 00:01:33.376 A:middle
cast enough rays to remove all

00:01:33.376 --> 00:01:33.756 A:middle
the noise.

00:01:34.386 --> 00:01:35.446 A:middle
So, we need a sophisticated

00:01:35.446 --> 00:01:36.606 A:middle
noise reduction strategy.

00:01:37.366 --> 00:01:39.336 A:middle
Fortunately, Metal has built in

00:01:39.336 --> 00:01:41.006 A:middle
support for Ray Tracing and

00:01:41.006 --> 00:01:41.576 A:middle
Denoising.

00:01:41.766 --> 00:01:42.876 A:middle
So, it's easy to get started.

00:01:43.956 --> 00:01:45.146 A:middle
So, let's first review how Ray

00:01:45.146 --> 00:01:46.686 A:middle
Tracing works in Metal and then

00:01:46.686 --> 00:01:47.496 A:middle
we'll move on to some more

00:01:47.496 --> 00:01:48.306 A:middle
advanced topics.

00:01:48.866 --> 00:01:51.656 A:middle
So, if you look at a typical Ray

00:01:51.656 --> 00:01:53.246 A:middle
Tracing application, they all

00:01:53.246 --> 00:01:54.686 A:middle
follow roughly the same outline.

00:01:55.516 --> 00:01:56.946 A:middle
First, we generate some rays.

00:01:57.646 --> 00:01:58.846 A:middle
Each ray is defined by its

00:01:58.886 --> 00:02:00.206 A:middle
origin point and its direction

00:01:58.886 --> 00:02:00.206 A:middle
origin point and its direction

00:02:00.206 --> 00:02:00.616 A:middle
vector.

00:02:01.816 --> 00:02:03.086 A:middle
Those rays are then intersected

00:02:03.086 --> 00:02:04.136 A:middle
against the geometry in the

00:02:04.136 --> 00:02:05.566 A:middle
scene, which is usually made of

00:02:05.566 --> 00:02:06.076 A:middle
triangles.

00:02:06.746 --> 00:02:08.286 A:middle
The intersection data could just

00:02:08.286 --> 00:02:09.076 A:middle
be the distance to the

00:02:09.076 --> 00:02:10.536 A:middle
intersection point, but it

00:02:10.606 --> 00:02:11.726 A:middle
typically includes additional

00:02:11.726 --> 00:02:13.186 A:middle
data such as the index of the

00:02:13.186 --> 00:02:14.636 A:middle
triangle that was hit and the

00:02:14.636 --> 00:02:15.766 A:middle
very center coordinates of the

00:02:15.766 --> 00:02:17.206 A:middle
intersection point.

00:02:18.636 --> 00:02:19.906 A:middle
The next step consumes the

00:02:19.906 --> 00:02:20.846 A:middle
intersection results.

00:02:21.106 --> 00:02:22.176 A:middle
For example, in a rendering

00:02:22.176 --> 00:02:23.866 A:middle
application this is typically a

00:02:23.866 --> 00:02:25.436 A:middle
shading step which outputs an

00:02:25.436 --> 00:02:25.806 A:middle
image.

00:02:26.566 --> 00:02:27.876 A:middle
And this step may also generate

00:02:27.876 --> 00:02:29.646 A:middle
additional rays, so we repeat

00:02:29.646 --> 00:02:31.056 A:middle
this process however many times

00:02:31.056 --> 00:02:33.996 A:middle
we need until we're done.

00:02:34.176 --> 00:02:35.676 A:middle
Applications typically intersect

00:02:35.786 --> 00:02:37.116 A:middle
millions of rays with the scene

00:02:37.116 --> 00:02:37.736 A:middle
every frame.

00:02:38.786 --> 00:02:40.166 A:middle
And this core intersection step

00:02:40.226 --> 00:02:41.536 A:middle
is common to all Ray Tracing

00:02:41.536 --> 00:02:42.246 A:middle
applications.

00:02:42.936 --> 00:02:44.326 A:middle
So, this intersection step is

00:02:44.326 --> 00:02:47.426 A:middle
what we accelerate in Metal.

00:02:47.566 --> 00:02:49.136 A:middle
Last year, we introduced the

00:02:49.136 --> 00:02:51.486 A:middle
MPSRayIntersector API, which is

00:02:51.486 --> 00:02:52.486 A:middle
part of the Metal performance

00:02:52.486 --> 00:02:53.226 A:middle
shaders framework.

00:02:54.296 --> 00:02:55.806 A:middle
This API accelerates ray

00:02:55.806 --> 00:02:57.946 A:middle
intersection on the GPU on all

00:02:57.946 --> 00:02:59.456 A:middle
of our Mac and iOS devices.

00:03:00.366 --> 00:03:01.556 A:middle
We talked a lot about this API

00:03:01.626 --> 00:03:02.866 A:middle
in last year's talk, so we'd

00:03:02.866 --> 00:03:03.926 A:middle
encourage you to go back and

00:03:03.926 --> 00:03:05.056 A:middle
review this talk for more

00:03:05.056 --> 00:03:05.526 A:middle
information.

00:03:06.486 --> 00:03:08.336 A:middle
At a high level, this API takes

00:03:08.336 --> 00:03:09.496 A:middle
in batches of rays through a

00:03:09.496 --> 00:03:10.176 A:middle
Metal buffer.

00:03:10.996 --> 00:03:11.846 A:middle
It finds the closest

00:03:11.846 --> 00:03:13.406 A:middle
intersection along each ray and

00:03:13.406 --> 00:03:14.746 A:middle
returns the results in another

00:03:14.746 --> 00:03:15.136 A:middle
buffer.

00:03:15.666 --> 00:03:18.376 A:middle
And all of this work is encoded

00:03:18.416 --> 00:03:20.006 A:middle
into a Metal commandBuffer at

00:03:20.006 --> 00:03:21.146 A:middle
the point in your application

00:03:21.146 --> 00:03:21.716 A:middle
where you'd like to do

00:03:21.716 --> 00:03:22.626 A:middle
intersection testing.

00:03:23.236 --> 00:03:26.016 A:middle
Much of the speed up comes from

00:03:26.016 --> 00:03:27.106 A:middle
building a data structure we

00:03:27.106 --> 00:03:28.466 A:middle
call an acceleration structure.

00:03:29.156 --> 00:03:30.546 A:middle
This data structure recursively

00:03:30.546 --> 00:03:32.426 A:middle
partitions triangles in space so

00:03:32.976 --> 00:03:34.266 A:middle
that we can quickly eliminate

00:03:34.266 --> 00:03:35.756 A:middle
triangles which cannot possibly

00:03:35.756 --> 00:03:37.306 A:middle
intersect a given ray during the

00:03:37.306 --> 00:03:38.196 A:middle
intersection search.

00:03:38.706 --> 00:03:41.036 A:middle
Metal takes care of building

00:03:41.036 --> 00:03:42.326 A:middle
this data structure for you.

00:03:42.746 --> 00:03:44.066 A:middle
All you have to do is specify

00:03:44.066 --> 00:03:44.996 A:middle
when you'd like to build the

00:03:44.996 --> 00:03:46.616 A:middle
acceleration structure, then

00:03:46.616 --> 00:03:47.486 A:middle
simply pass it to the

00:03:47.486 --> 00:03:48.696 A:middle
intersector for intersection

00:03:48.696 --> 00:03:49.126 A:middle
testing.

00:03:50.266 --> 00:03:51.436 A:middle
Now, building this data

00:03:51.436 --> 00:03:52.756 A:middle
structure is typically a fixed

00:03:52.756 --> 00:03:54.156 A:middle
cost paid when your app starts

00:03:54.156 --> 00:03:54.366 A:middle
up.

00:03:55.666 --> 00:03:56.536 A:middle
In last year's version of the

00:03:56.536 --> 00:03:58.106 A:middle
API this data structure was

00:03:58.106 --> 00:03:59.386 A:middle
always built on the CPU.

00:04:00.056 --> 00:04:01.156 A:middle
This year, we've moved the

00:04:01.156 --> 00:04:02.756 A:middle
acceleration structure build to

00:04:02.756 --> 00:04:04.716 A:middle
the GPU, which can significantly

00:04:04.716 --> 00:04:06.076 A:middle
reduce the startup cost.

00:04:06.646 --> 00:04:08.006 A:middle
And even better, the GPU will be

00:04:08.006 --> 00:04:09.226 A:middle
used automatically whenever

00:04:09.226 --> 00:04:09.726 A:middle
possible.

00:04:09.856 --> 00:04:10.726 A:middle
So, you don't need to do

00:04:10.726 --> 00:04:12.166 A:middle
anything to see the speed up in

00:04:12.166 --> 00:04:12.796 A:middle
your applications.

00:04:14.406 --> 00:04:15.796 A:middle
So, let's now revisit our

00:04:15.796 --> 00:04:17.305 A:middle
typical Ray Tracing application

00:04:17.396 --> 00:04:18.315 A:middle
and see what we need to do to

00:04:18.315 --> 00:04:19.466 A:middle
translate it into a Metal Ray

00:04:19.466 --> 00:04:20.375 A:middle
Tracing application.

00:04:21.005 --> 00:04:23.346 A:middle
So, like I said, we'll start by

00:04:23.376 --> 00:04:24.106 A:middle
generating rays.

00:04:24.896 --> 00:04:26.076 A:middle
This is typically done using a

00:04:26.076 --> 00:04:27.326 A:middle
compute kernel, but it could

00:04:27.326 --> 00:04:28.416 A:middle
also be done from a fragment

00:04:28.416 --> 00:04:30.286 A:middle
shader or really any mechanism

00:04:30.286 --> 00:04:31.116 A:middle
that can write to a Metal

00:04:31.116 --> 00:04:31.486 A:middle
buffer.

00:04:32.676 --> 00:04:33.946 A:middle
We then pass the ray buffer to

00:04:33.946 --> 00:04:34.646 A:middle
the intersector.

00:04:35.596 --> 00:04:37.196 A:middle
It'll find the intersections and

00:04:37.196 --> 00:04:38.236 A:middle
return the result in our

00:04:38.236 --> 00:04:39.116 A:middle
intersection buffer.

00:04:39.556 --> 00:04:40.956 A:middle
And remember that to use the

00:04:40.956 --> 00:04:42.486 A:middle
intersector we need to provide

00:04:42.486 --> 00:04:43.596 A:middle
an acceleration structure.

00:04:44.386 --> 00:04:45.926 A:middle
We can often build this just one

00:04:46.076 --> 00:04:47.186 A:middle
and reuse it many times.

00:04:48.496 --> 00:04:50.056 A:middle
Finally, we'll launch one last

00:04:50.056 --> 00:04:52.016 A:middle
compute kernel which will use

00:04:52.016 --> 00:04:53.456 A:middle
the intersection data to write a

00:04:53.456 --> 00:04:55.026 A:middle
shaded image into a texture.

00:04:55.986 --> 00:04:57.616 A:middle
And this compute kernel can also

00:04:57.616 --> 00:04:59.006 A:middle
write additional rays back into

00:04:59.006 --> 00:05:00.176 A:middle
the ray buffer for iterative

00:04:59.006 --> 00:05:00.176 A:middle
the ray buffer for iterative

00:05:00.176 --> 00:05:00.846 A:middle
applications.

00:05:02.286 --> 00:05:03.166 A:middle
So, let's see how this works in

00:05:03.166 --> 00:05:03.936 A:middle
a real application.

00:05:05.226 --> 00:05:06.676 A:middle
For this example, we'll talk

00:05:06.676 --> 00:05:08.006 A:middle
about how Ray Tracing is being

00:05:08.006 --> 00:05:09.236 A:middle
used in AR Quick Look.

00:05:09.686 --> 00:05:11.236 A:middle
AR Quick Look was introduced

00:05:11.236 --> 00:05:12.436 A:middle
last year and allows you to

00:05:12.506 --> 00:05:14.346 A:middle
preview 3D assets in augmented

00:05:14.346 --> 00:05:14.676 A:middle
reality.

00:05:15.996 --> 00:05:17.176 A:middle
We talked a lot about AR Quick

00:05:17.176 --> 00:05:18.456 A:middle
Look in this morning's session.

00:05:18.526 --> 00:05:19.686 A:middle
So, I'd encourage you to watch

00:05:19.686 --> 00:05:20.436 A:middle
that talk as well.

00:05:20.436 --> 00:05:22.336 A:middle
For this talk, we'll focus on

00:05:22.336 --> 00:05:23.816 A:middle
how AR Quick Look is using Ray

00:05:23.816 --> 00:05:25.446 A:middle
Tracing to render an Ambient

00:05:25.446 --> 00:05:26.146 A:middle
Occlusion effect.

00:05:27.076 --> 00:05:28.086 A:middle
We'll talk more about Ambient

00:05:28.086 --> 00:05:29.766 A:middle
Occlusion later, but for now,

00:05:29.766 --> 00:05:31.116 A:middle
what you need to know is that

00:05:31.156 --> 00:05:32.356 A:middle
Ambient Occlusion computes an

00:05:32.356 --> 00:05:34.326 A:middle
approximation of how much light

00:05:34.386 --> 00:05:35.436 A:middle
can reach each point in the

00:05:35.506 --> 00:05:35.816 A:middle
scene.

00:05:36.616 --> 00:05:37.376 A:middle
So, this results in the

00:05:37.376 --> 00:05:38.316 A:middle
darkening of the ground

00:05:38.316 --> 00:05:39.926 A:middle
underneath the robot model as

00:05:39.926 --> 00:05:41.436 A:middle
well as soft contact shadows

00:05:41.486 --> 00:05:42.776 A:middle
between the robot's legs and the

00:05:42.776 --> 00:05:43.136 A:middle
ground.

00:05:43.656 --> 00:05:46.236 A:middle
The effect is somewhat subtle,

00:05:46.236 --> 00:05:47.556 A:middle
but if we turn it off, we can

00:05:47.556 --> 00:05:48.766 A:middle
see that it actually goes a long

00:05:48.766 --> 00:05:50.066 A:middle
way towards grounding the robot

00:05:50.066 --> 00:05:50.606 A:middle
in the scene.

00:05:51.206 --> 00:05:52.566 A:middle
And this is really important for

00:05:52.566 --> 00:05:54.226 A:middle
AR applications to prevent

00:05:54.226 --> 00:05:55.126 A:middle
objects from looking like

00:05:55.126 --> 00:05:56.876 A:middle
they're floating above the

00:05:58.496 --> 00:05:58.656 A:middle
ground.

00:05:58.806 --> 00:05:59.946 A:middle
In last year's version of AR

00:05:59.946 --> 00:06:01.036 A:middle
Quick Look, the shadows are

00:05:59.946 --> 00:06:01.036 A:middle
Quick Look, the shadows are

00:06:01.036 --> 00:06:02.876 A:middle
actually precomputed, so they

00:06:02.936 --> 00:06:04.246 A:middle
wouldn't move as objects moved

00:06:04.246 --> 00:06:04.606 A:middle
around.

00:06:05.956 --> 00:06:07.736 A:middle
This year, we've used Metal

00:06:07.776 --> 00:06:09.466 A:middle
support for dynamic scenes to

00:06:09.466 --> 00:06:10.606 A:middle
render these shadows in real

00:06:10.606 --> 00:06:10.956 A:middle
time.

00:06:11.426 --> 00:06:13.226 A:middle
So now as objects move their

00:06:13.226 --> 00:06:14.276 A:middle
shadows will move with them.

00:06:14.836 --> 00:06:17.106 A:middle
And this even works for

00:06:17.106 --> 00:06:18.516 A:middle
deforming objects such as

00:06:18.516 --> 00:06:19.246 A:middle
skinned models.

00:06:19.686 --> 00:06:20.886 A:middle
We can see the shadows follow

00:06:20.886 --> 00:06:22.176 A:middle
the motions of the fish as it

00:06:22.176 --> 00:06:23.706 A:middle
swims around the scene.

00:06:25.916 --> 00:06:27.326 A:middle
So, what we just saw actually

00:06:27.326 --> 00:06:28.456 A:middle
has three types of animation

00:06:28.456 --> 00:06:28.946 A:middle
going on.

00:06:28.946 --> 00:06:30.486 A:middle
If we were just using the

00:06:30.486 --> 00:06:31.796 A:middle
rasterizer, we'd simply

00:06:31.796 --> 00:06:33.006 A:middle
rasterize the triangles in their

00:06:33.006 --> 00:06:33.576 A:middle
new position.

00:06:34.346 --> 00:06:35.266 A:middle
But because we're using Ray

00:06:35.266 --> 00:06:36.646 A:middle
Tracing, we need to maintain an

00:06:36.646 --> 00:06:37.726 A:middle
acceleration structure.

00:06:38.826 --> 00:06:40.446 A:middle
So, the first type of animation

00:06:40.446 --> 00:06:41.476 A:middle
is simple camera movement.

00:06:41.476 --> 00:06:43.186 A:middle
And this is movement due to just

00:06:43.326 --> 00:06:44.436 A:middle
moving the iPad around.

00:06:45.516 --> 00:06:46.386 A:middle
We don't need to update the

00:06:46.386 --> 00:06:47.436 A:middle
acceleration structure just

00:06:47.436 --> 00:06:48.586 A:middle
because the cameras moved.

00:06:48.876 --> 00:06:49.956 A:middle
So, we actually get this type of

00:06:49.956 --> 00:06:50.916 A:middle
animation for free.

00:06:51.646 --> 00:06:53.056 A:middle
We can simply start firing rays

00:06:53.056 --> 00:06:54.006 A:middle
from the new camera position.

00:06:55.156 --> 00:06:56.436 A:middle
The other two types of animation

00:06:56.436 --> 00:06:57.536 A:middle
do require updating the

00:06:57.536 --> 00:06:58.476 A:middle
acceleration structure.

00:06:58.666 --> 00:07:00.746 A:middle
So, the first is Vertex

00:06:58.666 --> 00:07:00.746 A:middle
So, the first is Vertex

00:07:00.746 --> 00:07:01.286 A:middle
Animation.

00:07:02.236 --> 00:07:03.346 A:middle
This could be skinned models

00:07:03.346 --> 00:07:04.876 A:middle
like the fish, but it could also

00:07:04.876 --> 00:07:06.226 A:middle
be plants blowing in the wind,

00:07:06.376 --> 00:07:07.676 A:middle
cloth, or other types of

00:07:07.676 --> 00:07:08.206 A:middle
deformation.

00:07:09.276 --> 00:07:10.336 A:middle
Metal includes a special

00:07:10.336 --> 00:07:11.636 A:middle
acceleration structure update

00:07:11.636 --> 00:07:13.166 A:middle
mechanism optimized for cases

00:07:13.166 --> 00:07:13.646 A:middle
like this.

00:07:14.176 --> 00:07:16.446 A:middle
And the last type of animation

00:07:16.446 --> 00:07:17.626 A:middle
is rigid body animation.

00:07:18.346 --> 00:07:19.566 A:middle
This is where objects can move,

00:07:19.646 --> 00:07:21.556 A:middle
rotate, and scale, but otherwise

00:07:21.556 --> 00:07:22.796 A:middle
completely maintain their shape.

00:07:23.606 --> 00:07:24.496 A:middle
So, a large portion of the

00:07:24.496 --> 00:07:25.646 A:middle
acceleration structure is

00:07:25.646 --> 00:07:26.566 A:middle
actually still valid.

00:07:27.266 --> 00:07:28.406 A:middle
So, Metal also includes a

00:07:28.406 --> 00:07:30.006 A:middle
special mechanism to reuse the

00:07:30.006 --> 00:07:30.976 A:middle
parts of the acceleration

00:07:30.976 --> 00:07:32.186 A:middle
structure that hasn't changed.

00:07:33.456 --> 00:07:34.316 A:middle
So, let's first talk about

00:07:34.316 --> 00:07:35.086 A:middle
Vertex Animation.

00:07:36.206 --> 00:07:38.166 A:middle
As the geometry changes, we need

00:07:38.166 --> 00:07:39.176 A:middle
to update the acceleration

00:07:39.176 --> 00:07:39.626 A:middle
structure.

00:07:40.616 --> 00:07:42.046 A:middle
We could rebuild it from scratch

00:07:42.046 --> 00:07:43.706 A:middle
every frame, but we can actually

00:07:44.496 --> 00:07:45.246 A:middle
do better.

00:07:45.436 --> 00:07:47.146 A:middle
In Vertex Animation use cases

00:07:47.446 --> 00:07:48.896 A:middle
objects tend to mostly retain

00:07:48.896 --> 00:07:49.306 A:middle
their shape.

00:07:49.646 --> 00:07:50.986 A:middle
For example, a character's hands

00:07:50.986 --> 00:07:51.816 A:middle
will stay connected to their

00:07:51.816 --> 00:07:52.186 A:middle
arms.

00:07:52.546 --> 00:07:53.606 A:middle
Their arms will stay connected

00:07:53.606 --> 00:07:54.866 A:middle
to their body and so on.

00:07:55.506 --> 00:07:57.046 A:middle
So, the spatial hierarchy

00:07:57.046 --> 00:07:58.406 A:middle
encoded into the acceleration

00:07:58.406 --> 00:08:00.326 A:middle
structure is mostly still valid.

00:07:58.406 --> 00:08:00.326 A:middle
structure is mostly still valid.

00:08:00.856 --> 00:08:02.046 A:middle
It just needs to be adjusted to

00:08:02.046 --> 00:08:02.866 A:middle
the new geometry.

00:08:03.636 --> 00:08:04.586 A:middle
Let's look at an example.

00:08:06.046 --> 00:08:06.966 A:middle
So, here's the acceleration

00:08:06.966 --> 00:08:08.036 A:middle
structure we saw earlier.

00:08:09.356 --> 00:08:10.656 A:middle
If the triangles move, we can

00:08:10.656 --> 00:08:11.806 A:middle
see that the bounding boxes no

00:08:11.806 --> 00:08:12.586 A:middle
longer line up with the

00:08:12.586 --> 00:08:13.026 A:middle
triangles.

00:08:13.786 --> 00:08:15.086 A:middle
But the tree structure itself

00:08:15.086 --> 00:08:16.226 A:middle
mostly still makes sense.

00:08:16.596 --> 00:08:18.006 A:middle
So rather than rebuild it from

00:08:18.006 --> 00:08:19.566 A:middle
scratch, we can simply snap the

00:08:19.566 --> 00:08:20.816 A:middle
bounding boxes to the new

00:08:20.816 --> 00:08:22.616 A:middle
triangle positions from bottom

00:08:23.066 --> 00:08:24.286 A:middle
to top.

00:08:24.496 --> 00:08:25.456 A:middle
We call this operation

00:08:25.456 --> 00:08:25.956 A:middle
Refitting.

00:08:26.786 --> 00:08:27.766 A:middle
As we can see, this still

00:08:27.766 --> 00:08:29.146 A:middle
results in a valid acceleration

00:08:29.146 --> 00:08:31.016 A:middle
structure, but it's much faster

00:08:31.016 --> 00:08:32.256 A:middle
than building from scratch

00:08:32.385 --> 00:08:33.356 A:middle
because we can reuse the

00:08:33.356 --> 00:08:34.126 A:middle
existing tree.

00:08:34.666 --> 00:08:37.186 A:middle
This also runs entirely on the

00:08:37.186 --> 00:08:39.216 A:middle
GPU, which makes it even faster,

00:08:39.296 --> 00:08:40.426 A:middle
but also means that we can

00:08:40.476 --> 00:08:41.666 A:middle
safely encode a Refitting

00:08:41.666 --> 00:08:43.596 A:middle
operation after say a compute

00:08:43.596 --> 00:08:44.986 A:middle
kernel which updates the

00:08:44.986 --> 00:08:45.606 A:middle
vertices.

00:08:46.136 --> 00:08:48.406 A:middle
The downside is that we can't

00:08:48.406 --> 00:08:49.886 A:middle
add or remove any geometry

00:08:49.886 --> 00:08:50.866 A:middle
because the tree will still

00:08:50.866 --> 00:08:52.086 A:middle
encode references to the old

00:08:52.086 --> 00:08:52.646 A:middle
geometry.

00:08:54.156 --> 00:08:55.786 A:middle
This also potentially degrades

00:08:55.786 --> 00:08:56.856 A:middle
the acceleration structures

00:08:56.856 --> 00:08:58.206 A:middle
quality which can impact Ray

00:08:58.206 --> 00:08:59.156 A:middle
Tracing performance.

00:08:59.966 --> 00:09:00.946 A:middle
This is because the triangles

00:08:59.966 --> 00:09:00.946 A:middle
This is because the triangles

00:09:00.946 --> 00:09:02.136 A:middle
were originally partitioned

00:09:02.316 --> 00:09:03.636 A:middle
using a set of futuristics which

00:09:03.636 --> 00:09:04.786 A:middle
won't be accurate after the

00:09:04.786 --> 00:09:05.536 A:middle
triangles move.

00:09:06.016 --> 00:09:08.376 A:middle
The impact is usually minor, but

00:09:08.376 --> 00:09:09.886 A:middle
extreme cases like teleporting

00:09:09.886 --> 00:09:11.396 A:middle
geometry could cause performance

00:09:11.396 --> 00:09:11.826 A:middle
problems.

00:09:12.606 --> 00:09:13.766 A:middle
Nonetheless, this works great

00:09:13.766 --> 00:09:15.456 A:middle
for typical deformation and

00:09:15.456 --> 00:09:16.796 A:middle
character skinning use cases.

00:09:17.236 --> 00:09:18.606 A:middle
So, let's see how to set this up

00:09:18.606 --> 00:09:18.976 A:middle
in code.

00:09:20.056 --> 00:09:21.526 A:middle
First, before we build the

00:09:21.526 --> 00:09:22.856 A:middle
accelerations structure, we need

00:09:22.856 --> 00:09:24.336 A:middle
to enable support for Refitting.

00:09:24.886 --> 00:09:26.306 A:middle
And note that just enabling

00:09:26.306 --> 00:09:27.606 A:middle
Refitting is enough to reduce

00:09:27.646 --> 00:09:28.636 A:middle
the acceleration structure's

00:09:28.636 --> 00:09:29.056 A:middle
quality.

00:09:29.056 --> 00:09:31.006 A:middle
So definitely only turn this on

00:09:31.036 --> 00:09:32.136 A:middle
if you really need to refit the

00:09:32.136 --> 00:09:33.076 A:middle
acceleration structure.

00:09:34.536 --> 00:09:36.376 A:middle
Then we simple call encodeRefit

00:09:36.376 --> 00:09:37.596 A:middle
into a Metal commandBuffer.

00:09:38.176 --> 00:09:39.786 A:middle
And that's all we need to do for

00:09:39.786 --> 00:09:40.736 A:middle
Vertex Animation.

00:09:41.636 --> 00:09:43.176 A:middle
So next, let's talk about Rigid

00:09:43.176 --> 00:09:43.826 A:middle
Body Animation.

00:09:44.936 --> 00:09:46.526 A:middle
So as the name implies, this is

00:09:46.526 --> 00:09:47.576 A:middle
animation where objects can

00:09:47.576 --> 00:09:49.396 A:middle
move, rotate, and scale, but

00:09:49.396 --> 00:09:50.676 A:middle
otherwise completely maintain

00:09:50.676 --> 00:09:51.086 A:middle
their shape.

00:09:51.876 --> 00:09:53.166 A:middle
So, in the example on the right,

00:09:53.436 --> 00:09:54.246 A:middle
even though it looks like the

00:09:54.246 --> 00:09:55.846 A:middle
robot is deforming, actually all

00:09:55.846 --> 00:09:57.366 A:middle
of its joins are moving rigidly.

00:09:57.776 --> 00:09:58.906 A:middle
So, this is still an example of

00:09:58.906 --> 00:09:59.856 A:middle
Rigid Body Animation.

00:10:01.316 --> 00:10:02.816 A:middle
So, in a typical scene, most of

00:10:02.816 --> 00:10:04.036 A:middle
the geometry is probably only

00:10:04.036 --> 00:10:04.846 A:middle
moving rigidly.

00:10:05.546 --> 00:10:07.026 A:middle
In fact, most of the geometry is

00:10:07.026 --> 00:10:08.196 A:middle
probably not moving at all.

00:10:09.636 --> 00:10:11.346 A:middle
We may also have multiple copies

00:10:11.436 --> 00:10:12.596 A:middle
of the same objects in the

00:10:12.656 --> 00:10:13.006 A:middle
scene.

00:10:13.426 --> 00:10:14.766 A:middle
It would be wasteful to

00:10:14.766 --> 00:10:16.196 A:middle
replicate these objects multiple

00:10:16.196 --> 00:10:17.256 A:middle
times in the accelerations

00:10:17.256 --> 00:10:18.976 A:middle
structure and it would also be

00:10:18.976 --> 00:10:20.506 A:middle
inefficient to refit or rebuild

00:10:20.506 --> 00:10:21.556 A:middle
the entire acceleration

00:10:21.556 --> 00:10:23.306 A:middle
structure just because a subset

00:10:23.306 --> 00:10:24.346 A:middle
of the geometry is moving.

00:10:25.526 --> 00:10:26.816 A:middle
So, to solve both of these

00:10:26.846 --> 00:10:28.176 A:middle
problems, we can use what we

00:10:28.176 --> 00:10:29.486 A:middle
call a Two-Level Acceleration

00:10:29.486 --> 00:10:29.956 A:middle
Structure.

00:10:30.526 --> 00:10:33.586 A:middle
So, what we'll do is first build

00:10:33.586 --> 00:10:34.766 A:middle
a high-quality triangle

00:10:34.766 --> 00:10:36.186 A:middle
acceleration structure for each

00:10:36.186 --> 00:10:37.626 A:middle
unique object in the scene.

00:10:37.626 --> 00:10:38.896 A:middle
And we can do this just once

00:10:38.896 --> 00:10:41.326 A:middle
when the app starts up.

00:10:41.356 --> 00:10:42.826 A:middle
We'll then create two copies of

00:10:42.826 --> 00:10:44.296 A:middle
those -- of those triangle

00:10:44.296 --> 00:10:45.936 A:middle
acceleration structures using a

00:10:46.016 --> 00:10:47.266 A:middle
second acceleration structure.

00:10:47.976 --> 00:10:49.876 A:middle
Each copy is called an instance

00:10:49.876 --> 00:10:51.166 A:middle
of one of the original triangle

00:10:51.166 --> 00:10:52.156 A:middle
acceleration structures.

00:10:53.866 --> 00:10:55.196 A:middle
Each instance is associated with

00:10:55.196 --> 00:10:56.396 A:middle
a transformation matrix,

00:10:57.126 --> 00:10:58.356 A:middle
describing where to place it in

00:10:58.356 --> 00:10:58.796 A:middle
the scene.

00:10:59.696 --> 00:11:00.786 A:middle
So, we'll do this all using two

00:10:59.696 --> 00:11:00.786 A:middle
So, we'll do this all using two

00:11:00.786 --> 00:11:02.106 A:middle
buffers and each buffer will

00:11:02.106 --> 00:11:03.556 A:middle
contain one entry for each

00:11:03.556 --> 00:11:04.526 A:middle
instance in the scene.

00:11:05.846 --> 00:11:06.806 A:middle
The first buffer will contain

00:11:06.806 --> 00:11:08.146 A:middle
the transformation matrices for

00:11:08.146 --> 00:11:08.926 A:middle
all the instances.

00:11:10.376 --> 00:11:11.816 A:middle
The second buffer will contain

00:11:11.816 --> 00:11:13.286 A:middle
indices into an array of

00:11:13.286 --> 00:11:14.256 A:middle
triangle accelerations

00:11:14.256 --> 00:11:16.056 A:middle
structures describing which

00:11:16.056 --> 00:11:17.286 A:middle
acceleration structure to use

00:11:17.286 --> 00:11:18.096 A:middle
for each instance.

00:11:18.716 --> 00:11:21.246 A:middle
We'll then build a second

00:11:21.246 --> 00:11:22.976 A:middle
acceleration structure over just

00:11:22.976 --> 00:11:24.466 A:middle
the instances in the scene.

00:11:25.556 --> 00:11:26.926 A:middle
We can then quickly rebuild just

00:11:26.926 --> 00:11:28.016 A:middle
the instance acceleration

00:11:28.016 --> 00:11:29.446 A:middle
structure as the objects move.

00:11:30.346 --> 00:11:31.346 A:middle
So, let's see how to set this

00:11:31.346 --> 00:11:31.666 A:middle
up.

00:11:32.566 --> 00:11:33.816 A:middle
First, we'll create what's

00:11:33.816 --> 00:11:34.266 A:middle
called an

00:11:34.266 --> 00:11:35.606 A:middle
AccelerationStructureGroup.

00:11:36.386 --> 00:11:37.566 A:middle
All the acceleration structures

00:11:37.566 --> 00:11:38.746 A:middle
in the instance's hierarchy must

00:11:38.746 --> 00:11:39.796 A:middle
belong to the same group.

00:11:39.796 --> 00:11:41.126 A:middle
And this allows them to share

00:11:41.126 --> 00:11:42.166 A:middle
resources internally.

00:11:42.786 --> 00:11:45.106 A:middle
Next, we'll create an array to

00:11:45.106 --> 00:11:46.436 A:middle
hold our triangle acceleration

00:11:46.436 --> 00:11:46.916 A:middle
structures.

00:11:47.866 --> 00:11:49.206 A:middle
Then finally, we'll loop over

00:11:49.206 --> 00:11:50.376 A:middle
all the unique objects in the

00:11:50.376 --> 00:11:51.776 A:middle
scene, building a triangle

00:11:51.776 --> 00:11:52.926 A:middle
acceleration structure for each

00:11:52.926 --> 00:11:53.246 A:middle
of them.

00:11:53.526 --> 00:11:55.496 A:middle
Adding them to the array as we

00:11:56.896 --> 00:11:56.976 A:middle
go.

00:11:57.216 --> 00:11:58.006 A:middle
We're now ready to create the

00:11:58.006 --> 00:11:59.076 A:middle
second level acceleration

00:11:59.076 --> 00:11:59.526 A:middle
structure.

00:12:00.156 --> 00:12:02.006 A:middle
We do this using the NPSInstance

00:12:02.006 --> 00:12:03.286 A:middle
AccelerationStructure class.

00:12:04.266 --> 00:12:05.446 A:middle
We'll start by attaching our

00:12:05.446 --> 00:12:06.746 A:middle
array of triangle acceleration

00:12:06.746 --> 00:12:08.686 A:middle
structures as well as the two

00:12:08.686 --> 00:12:09.606 A:middle
buffers I talked about

00:12:09.606 --> 00:12:10.136 A:middle
previously.

00:12:10.836 --> 00:12:12.146 A:middle
Then finally, we'll specify the

00:12:12.146 --> 00:12:15.106 A:middle
num of instances in the scene.

00:12:15.306 --> 00:12:16.916 A:middle
Then, whenever the objects move

00:12:16.916 --> 00:12:18.086 A:middle
or if an object is added or

00:12:18.086 --> 00:12:19.816 A:middle
removed from the scene, we can

00:12:19.816 --> 00:12:21.256 A:middle
simply rebuild just the instance

00:12:21.256 --> 00:12:22.256 A:middle
acceleration structure.

00:12:23.246 --> 00:12:24.326 A:middle
This acceleration structure is

00:12:24.326 --> 00:12:25.566 A:middle
typically much smaller than a

00:12:25.566 --> 00:12:27.016 A:middle
triangle acceleration structure,

00:12:27.336 --> 00:12:28.336 A:middle
so we can afford to do this

00:12:28.336 --> 00:12:28.956 A:middle
every frame.

00:12:29.236 --> 00:12:30.366 A:middle
But note that similar to

00:12:30.366 --> 00:12:31.506 A:middle
Refitting, there is some

00:12:31.506 --> 00:12:32.896 A:middle
overhead when using instancing.

00:12:33.696 --> 00:12:34.776 A:middle
So, if your scene only has one

00:12:34.776 --> 00:12:36.446 A:middle
object or a handful of objects,

00:12:36.526 --> 00:12:37.496 A:middle
or especially if none of the

00:12:37.496 --> 00:12:39.156 A:middle
objects are moving, it might be

00:12:39.156 --> 00:12:40.446 A:middle
worthwhile to pack those into a

00:12:40.446 --> 00:12:41.776 A:middle
single triangle acceleration

00:12:41.776 --> 00:12:42.226 A:middle
structure.

00:12:43.026 --> 00:12:43.966 A:middle
This will increase your memory

00:12:44.016 --> 00:12:45.806 A:middle
footprint, but it should gain

00:12:45.806 --> 00:12:46.856 A:middle
back some of the performance.

00:12:47.226 --> 00:12:48.686 A:middle
So, you need to experiment to

00:12:48.716 --> 00:12:49.806 A:middle
find the right tradeoff for your

00:12:49.806 --> 00:12:50.286 A:middle
application.

00:12:50.286 --> 00:12:53.386 A:middle
So that's it for dynamic scenes.

00:12:53.826 --> 00:12:54.736 A:middle
We talked about how to support

00:12:54.736 --> 00:12:56.146 A:middle
Vertex Animation and Skinning

00:12:56.146 --> 00:12:57.006 A:middle
using Refitting.

00:12:57.606 --> 00:12:58.816 A:middle
As well as how to support Rigid

00:12:58.816 --> 00:13:00.306 A:middle
Body Animation using a Two-Level

00:12:58.816 --> 00:13:00.306 A:middle
Body Animation using a Two-Level

00:13:00.306 --> 00:13:01.276 A:middle
Acceleration Structure.

00:13:02.196 --> 00:13:03.726 A:middle
So next, let's switch gears and

00:13:03.726 --> 00:13:04.676 A:middle
talk about Denoising.

00:13:05.306 --> 00:13:08.516 A:middle
So far, all the images that we

00:13:08.516 --> 00:13:09.396 A:middle
have seen have been free of

00:13:09.396 --> 00:13:09.766 A:middle
noise.

00:13:10.326 --> 00:13:11.556 A:middle
That's because they've all been

00:13:11.556 --> 00:13:12.786 A:middle
using a denoising filter.

00:13:13.676 --> 00:13:14.966 A:middle
If we turn it off, we could see

00:13:14.966 --> 00:13:15.896 A:middle
what it would have looked like

00:13:15.896 --> 00:13:16.796 A:middle
without the denoiser.

00:13:17.826 --> 00:13:19.036 A:middle
We can see that these images are

00:13:19.036 --> 00:13:20.276 A:middle
too noisy to use in a real

00:13:20.276 --> 00:13:20.986 A:middle
application.

00:13:21.526 --> 00:13:22.576 A:middle
That's because we're only using

00:13:22.576 --> 00:13:23.966 A:middle
a handful of samples per pixel.

00:13:25.266 --> 00:13:26.516 A:middle
Usually we would just solve this

00:13:26.516 --> 00:13:27.506 A:middle
by averaging together more

00:13:27.506 --> 00:13:28.526 A:middle
samples over time.

00:13:28.926 --> 00:13:30.236 A:middle
But if the camera or objects are

00:13:30.236 --> 00:13:31.466 A:middle
moving it's not quite that

00:13:31.466 --> 00:13:31.846 A:middle
simple.

00:13:32.226 --> 00:13:34.236 A:middle
Fortunately, Metal now includes

00:13:34.236 --> 00:13:35.506 A:middle
a sophisticated Denoising

00:13:35.546 --> 00:13:35.936 A:middle
filter.

00:13:36.726 --> 00:13:37.566 A:middle
Let's see how this works.

00:13:37.676 --> 00:13:40.376 A:middle
Ideally what we'd be able to do

00:13:40.376 --> 00:13:41.856 A:middle
is simply take the noisy image

00:13:41.856 --> 00:13:43.556 A:middle
output by a renderer, run it

00:13:43.556 --> 00:13:44.766 A:middle
through a denoiser and get back

00:13:44.766 --> 00:13:45.506 A:middle
a clean image.

00:13:46.236 --> 00:13:47.436 A:middle
In practice, the denoiser needs

00:13:47.436 --> 00:13:48.736 A:middle
a little more information about

00:13:48.736 --> 00:13:49.186 A:middle
the scene.

00:13:50.296 --> 00:13:51.236 A:middle
We'll start by providing the

00:13:51.236 --> 00:13:52.296 A:middle
depths and normal for the

00:13:52.296 --> 00:13:53.616 A:middle
directly visible geometry.

00:13:54.386 --> 00:13:55.586 A:middle
Many renderers have these

00:13:55.586 --> 00:13:57.156 A:middle
textures lying around, and if

00:13:57.156 --> 00:13:59.076 A:middle
not, it's easy to produce them.

00:13:59.716 --> 00:14:00.946 A:middle
The denoiser will then run a

00:13:59.716 --> 00:14:00.946 A:middle
The denoiser will then run a

00:14:00.946 --> 00:14:01.926 A:middle
bunch of image processing

00:14:01.926 --> 00:14:03.326 A:middle
operations and output a cleaner

00:14:03.326 --> 00:14:03.696 A:middle
image.

00:14:04.336 --> 00:14:05.466 A:middle
But since we started with just a

00:14:05.466 --> 00:14:06.846 A:middle
handful of samples per pixel,

00:14:06.846 --> 00:14:07.926 A:middle
the result will still have some

00:14:07.926 --> 00:14:08.196 A:middle
noise.

00:14:08.936 --> 00:14:10.316 A:middle
So, we'll revisit the idea of

00:14:10.316 --> 00:14:11.706 A:middle
combining samples over multiple

00:14:11.706 --> 00:14:12.116 A:middle
frames.

00:14:12.786 --> 00:14:14.646 A:middle
So, we'll first set aside the

00:14:14.646 --> 00:14:16.246 A:middle
clean image to reuse in the next

00:14:16.246 --> 00:14:16.566 A:middle
frame.

00:14:17.726 --> 00:14:18.866 A:middle
We'll also set aside the depth

00:14:18.866 --> 00:14:20.356 A:middle
and normal so we can compare

00:14:20.356 --> 00:14:21.186 A:middle
them to the next frame.

00:14:22.256 --> 00:14:23.336 A:middle
Then finally, we'll provide a

00:14:23.336 --> 00:14:24.886 A:middle
motion vector texture which

00:14:24.886 --> 00:14:26.266 A:middle
describes how much each pixel

00:14:26.266 --> 00:14:27.476 A:middle
has moved between frames.

00:14:28.116 --> 00:14:30.916 A:middle
In the next frame, the denoiser

00:14:30.916 --> 00:14:32.126 A:middle
will churn through all of these

00:14:32.126 --> 00:14:33.406 A:middle
textures to produce an even

00:14:33.406 --> 00:14:34.136 A:middle
better image.

00:14:34.706 --> 00:14:35.856 A:middle
And this image will continue to

00:14:35.856 --> 00:14:37.506 A:middle
get better over time even if the

00:14:37.506 --> 00:14:38.686 A:middle
camera or objects move.

00:14:39.076 --> 00:14:41.156 A:middle
The denoiser will use the depths

00:14:41.156 --> 00:14:43.116 A:middle
and normal to detect cases where

00:14:43.116 --> 00:14:44.296 A:middle
the history for a pixel has

00:14:44.296 --> 00:14:46.426 A:middle
become invalid due to an object

00:14:46.426 --> 00:14:47.656 A:middle
moving or getting in the way.

00:14:49.196 --> 00:14:50.056 A:middle
So, this is all implemented

00:14:50.056 --> 00:14:51.946 A:middle
using the MPSSVGF family of

00:14:51.986 --> 00:14:52.506 A:middle
classes.

00:14:53.456 --> 00:14:54.756 A:middle
This is an implementation of the

00:14:54.756 --> 00:14:56.246 A:middle
popular MPSSVGF denoising

00:14:56.246 --> 00:14:56.716 A:middle
algorithm.

00:14:57.356 --> 00:14:58.276 A:middle
This algorithm makes a good

00:14:58.276 --> 00:14:59.536 A:middle
tradeoff between high quality

00:14:59.536 --> 00:15:00.596 A:middle
and real-time performance.

00:14:59.536 --> 00:15:00.596 A:middle
and real-time performance.

00:15:01.236 --> 00:15:03.146 A:middle
So, the denoising process is all

00:15:03.146 --> 00:15:04.386 A:middle
coordinated by the

00:15:04.386 --> 00:15:06.096 A:middle
MPSSVGFDenoiser class.

00:15:07.206 --> 00:15:08.976 A:middle
Meanwhile, low-level control is

00:15:08.976 --> 00:15:10.896 A:middle
provided using the MPSSVGF

00:15:10.896 --> 00:15:11.316 A:middle
class.

00:15:12.186 --> 00:15:12.996 A:middle
This class provides the

00:15:12.996 --> 00:15:14.516 A:middle
individual compute kernels used

00:15:14.516 --> 00:15:16.516 A:middle
by the denoiser and exposes many

00:15:16.516 --> 00:15:17.726 A:middle
parameters you can use to fine

00:15:17.726 --> 00:15:18.736 A:middle
tune the Denoising in your

00:15:18.736 --> 00:15:19.236 A:middle
application.

00:15:20.006 --> 00:15:21.026 A:middle
And you also just call this

00:15:21.026 --> 00:15:22.306 A:middle
classes' methods directly to

00:15:22.306 --> 00:15:23.526 A:middle
build a customized denoiser.

00:15:24.126 --> 00:15:26.416 A:middle
Now the denoiser creates and

00:15:26.416 --> 00:15:27.706 A:middle
destroys quite a few temporary

00:15:27.706 --> 00:15:28.576 A:middle
textures throughout the

00:15:28.576 --> 00:15:29.566 A:middle
Denoising process.

00:15:30.246 --> 00:15:32.456 A:middle
To the MPSSVGF texture allocator

00:15:32.456 --> 00:15:34.216 A:middle
protocol serves as a cache for

00:15:34.216 --> 00:15:35.346 A:middle
these memory allocations.

00:15:36.536 --> 00:15:37.646 A:middle
You can either use the default

00:15:37.646 --> 00:15:39.416 A:middle
implementation or implement this

00:15:39.416 --> 00:15:40.606 A:middle
protocol yourself to share

00:15:40.606 --> 00:15:41.356 A:middle
memory with your own

00:15:41.356 --> 00:15:41.966 A:middle
application.

00:15:42.986 --> 00:15:44.376 A:middle
So as usual, we've optimized

00:15:44.376 --> 00:15:45.666 A:middle
these classes for all of our Mac

00:15:45.666 --> 00:15:46.646 A:middle
and iOS devices.

00:15:47.536 --> 00:15:48.836 A:middle
The denoiser can process two

00:15:48.836 --> 00:15:49.736 A:middle
independent images

00:15:49.736 --> 00:15:50.576 A:middle
simultaneously.

00:15:50.706 --> 00:15:51.966 A:middle
For example, you might want to

00:15:51.966 --> 00:15:53.346 A:middle
split your direct and indirect

00:15:53.346 --> 00:15:54.576 A:middle
lighting terms into separate

00:15:54.576 --> 00:15:55.066 A:middle
textures.

00:15:56.036 --> 00:15:57.166 A:middle
There's also a fast path for

00:15:57.166 --> 00:15:58.756 A:middle
single channel textures such as

00:15:58.756 --> 00:15:59.946 A:middle
Ambient Occlusion or shadow

00:15:59.946 --> 00:16:01.456 A:middle
textures, which is faster than

00:15:59.946 --> 00:16:01.456 A:middle
textures, which is faster than

00:16:01.456 --> 00:16:03.146 A:middle
Denoising a full RBG image.

00:16:04.276 --> 00:16:06.706 A:middle
Let's see how to set this up.

00:16:06.706 --> 00:16:08.016 A:middle
So first we'll create the

00:16:08.096 --> 00:16:09.996 A:middle
MPSSVGF object and configure its

00:16:10.036 --> 00:16:10.516 A:middle
properties.

00:16:11.136 --> 00:16:12.106 A:middle
All we need to provide is the

00:16:12.106 --> 00:16:13.366 A:middle
Metal device we want to use for

00:16:13.366 --> 00:16:13.946 A:middle
Denoising.

00:16:14.416 --> 00:16:16.146 A:middle
Next, we'll create the

00:16:16.146 --> 00:16:16.996 A:middle
TextureAllocator.

00:16:17.276 --> 00:16:18.296 A:middle
In this case we'll just use the

00:16:18.296 --> 00:16:19.446 A:middle
default implementation.

00:16:20.616 --> 00:16:21.716 A:middle
Then finally, we'll create the

00:16:21.716 --> 00:16:23.256 A:middle
high level Denoiser object which

00:16:23.256 --> 00:16:24.216 A:middle
will manage the denoising

00:16:24.246 --> 00:16:24.696 A:middle
process.

00:16:26.146 --> 00:16:27.086 A:middle
So now we're ready to do some

00:16:27.086 --> 00:16:27.636 A:middle
denoising.

00:16:28.156 --> 00:16:29.406 A:middle
We'll start by attaching all of

00:16:29.406 --> 00:16:30.446 A:middle
the input textures to the

00:16:30.446 --> 00:16:30.896 A:middle
Denoiser.

00:16:31.546 --> 00:16:32.866 A:middle
Now we simply encode the entire

00:16:32.866 --> 00:16:34.366 A:middle
denoising process to a Metal

00:16:34.366 --> 00:16:34.996 A:middle
commandBuffer.

00:16:35.876 --> 00:16:37.146 A:middle
And finally, we can retrieve the

00:16:37.146 --> 00:16:38.516 A:middle
clean image from the denoiser.

00:16:39.106 --> 00:16:40.416 A:middle
And that's all you need to do to

00:16:40.416 --> 00:16:41.306 A:middle
enable denoising your

00:16:41.306 --> 00:16:41.926 A:middle
applications.

00:16:42.646 --> 00:16:45.086 A:middle
So, we now talked about all of

00:16:45.086 --> 00:16:46.136 A:middle
the basic building blocks

00:16:46.136 --> 00:16:47.246 A:middle
available in Metal for Ray

00:16:47.246 --> 00:16:48.416 A:middle
Tracing and Denoising.

00:16:48.646 --> 00:16:50.186 A:middle
We reviewed how to do basic

00:16:50.186 --> 00:16:52.476 A:middle
ray/triangle intersection using

00:16:52.526 --> 00:16:53.826 A:middle
the MPS Ray Intersector API.

00:16:54.996 --> 00:16:55.816 A:middle
We then talked about how to

00:16:55.816 --> 00:16:57.196 A:middle
extend this to dynamic scenes

00:16:57.196 --> 00:16:58.866 A:middle
using Refitting and Two-Level

00:16:58.866 --> 00:16:59.886 A:middle
Acceleration Structures.

00:17:00.876 --> 00:17:02.156 A:middle
And finally, we talked about how

00:17:02.156 --> 00:17:03.376 A:middle
to remove the noise from your

00:17:03.376 --> 00:17:04.856 A:middle
images using the MPSSVGF

00:17:04.945 --> 00:17:05.376 A:middle
classes.

00:17:05.376 --> 00:17:07.406 A:middle
Now, don't worry if this is all

00:17:07.406 --> 00:17:09.096 A:middle
a little bit overwhelming.

00:17:09.396 --> 00:17:10.576 A:middle
We've written a sample, which

00:17:10.576 --> 00:17:11.695 A:middle
demonstrates how to use all of

00:17:11.695 --> 00:17:12.656 A:middle
these concepts which is

00:17:12.656 --> 00:17:13.566 A:middle
available online.

00:17:14.146 --> 00:17:16.316 A:middle
Now, I mentioned earlier that we

00:17:16.316 --> 00:17:17.116 A:middle
need to be careful with

00:17:17.116 --> 00:17:17.715 A:middle
performance.

00:17:17.715 --> 00:17:18.705 A:middle
Especially in a real-time

00:17:18.705 --> 00:17:19.086 A:middle
setting.

00:17:19.626 --> 00:17:20.536 A:middle
So next, I'd like to bring out

00:17:20.536 --> 00:17:22.036 A:middle
my colleague Wayne who will talk

00:17:22.036 --> 00:17:22.996 A:middle
about how to make all of this

00:17:22.996 --> 00:17:24.796 A:middle
work on real devices with real

00:17:24.796 --> 00:17:25.576 A:middle
performance budgets.

00:17:27.516 --> 00:17:31.636 A:middle
[ Applause ]

00:17:32.136 --> 00:17:32.556 A:middle
&gt;&gt; Hi everyone.

00:17:33.106 --> 00:17:34.596 A:middle
Now, what I'd like to show you

00:17:34.596 --> 00:17:36.556 A:middle
in this part of the talk is how

00:17:36.596 --> 00:17:38.416 A:middle
to use the Ray Tracing features

00:17:38.416 --> 00:17:40.006 A:middle
that we have in Metal to

00:17:40.006 --> 00:17:41.126 A:middle
implement a few different

00:17:41.126 --> 00:17:42.486 A:middle
rendering techniques in your

00:17:42.486 --> 00:17:43.266 A:middle
applications.

00:17:43.746 --> 00:17:45.316 A:middle
So, in particular, I'll be

00:17:45.316 --> 00:17:46.506 A:middle
focusing on hard and soft

00:17:46.506 --> 00:17:48.566 A:middle
shadows, Ambient Occlusion, and

00:17:48.696 --> 00:17:49.756 A:middle
global illumination.

00:17:49.896 --> 00:17:52.176 A:middle
So, let's start with hard

00:17:52.176 --> 00:17:52.656 A:middle
shadows.

00:17:52.656 --> 00:17:54.956 A:middle
Now, the way that we model this

00:17:54.956 --> 00:17:56.516 A:middle
with Ray Tracing is to take

00:17:56.516 --> 00:17:58.366 A:middle
points on our surface and fire

00:17:58.366 --> 00:17:59.566 A:middle
rays up in the direction of the

00:17:59.566 --> 00:17:59.806 A:middle
sun.

00:18:00.616 --> 00:18:02.616 A:middle
If a ray hits something, then

00:18:02.616 --> 00:18:03.816 A:middle
the associated point is in

00:18:03.816 --> 00:18:04.126 A:middle
shadow.

00:18:04.776 --> 00:18:06.266 A:middle
Otherwise, it's in sunlight.

00:18:07.476 --> 00:18:10.066 A:middle
Now, to incorporate this into an

00:18:10.066 --> 00:18:11.946 A:middle
existing application, I'm going

00:18:11.946 --> 00:18:12.896 A:middle
to assume that you're starting

00:18:12.896 --> 00:18:15.106 A:middle
with something a bit like this.

00:18:15.106 --> 00:18:16.986 A:middle
You've rasterized a G-Buffer and

00:18:16.986 --> 00:18:17.896 A:middle
run a compute pass for your

00:18:17.896 --> 00:18:18.286 A:middle
lighting.

00:18:18.466 --> 00:18:19.936 A:middle
And the output of that is your

00:18:19.936 --> 00:18:21.106 A:middle
final shaded image.

00:18:21.856 --> 00:18:24.036 A:middle
Now, to take advantage of Ray

00:18:24.036 --> 00:18:25.516 A:middle
Tracing here we'll start by

00:18:25.516 --> 00:18:27.416 A:middle
taking the G-Buffer and then run

00:18:27.416 --> 00:18:28.826 A:middle
a compute shader to generate

00:18:28.826 --> 00:18:29.226 A:middle
some rays.

00:18:30.836 --> 00:18:31.836 A:middle
We'll then pass those rays to

00:18:31.836 --> 00:18:33.256 A:middle
Metal to intersect with an

00:18:33.256 --> 00:18:34.256 A:middle
acceleration structure.

00:18:34.956 --> 00:18:35.906 A:middle
And Metal will output the

00:18:35.906 --> 00:18:37.076 A:middle
results to an intersection

00:18:37.076 --> 00:18:37.356 A:middle
buffer.

00:18:38.786 --> 00:18:40.026 A:middle
You can now use this buffer in

00:18:40.026 --> 00:18:41.356 A:middle
your shading kernel to decide

00:18:41.356 --> 00:18:42.336 A:middle
whether your surface points are

00:18:42.336 --> 00:18:42.816 A:middle
in shadow.

00:18:43.446 --> 00:18:46.066 A:middle
Now the main part I'd like us to

00:18:46.066 --> 00:18:47.776 A:middle
focus on here is Ray Generation.

00:18:48.626 --> 00:18:49.916 A:middle
So, let's start with a quick

00:18:49.916 --> 00:18:51.196 A:middle
reminder of how rays are

00:18:51.196 --> 00:18:52.006 A:middle
described in Metal.

00:18:54.256 --> 00:18:55.606 A:middle
So, Metal provides a few

00:18:55.606 --> 00:18:56.616 A:middle
different ray structures for you

00:18:56.616 --> 00:18:58.456 A:middle
to use, and at a minimum these

00:18:58.456 --> 00:18:59.676 A:middle
contain fields for your ray

00:18:59.676 --> 00:19:01.406 A:middle
origin and your ray direction.

00:18:59.676 --> 00:19:01.406 A:middle
origin and your ray direction.

00:19:02.496 --> 00:19:03.596 A:middle
So just fill out one of these

00:19:03.596 --> 00:19:04.986 A:middle
structures for each ray that you

00:19:04.986 --> 00:19:06.566 A:middle
want to trace and write it out

00:19:06.566 --> 00:19:09.346 A:middle
to your ray buffer.

00:19:09.926 --> 00:19:10.896 A:middle
Now, the way in which you

00:19:10.896 --> 00:19:12.176 A:middle
arrange your rays in your ray

00:19:12.176 --> 00:19:13.926 A:middle
buffer, that has a performance

00:19:13.926 --> 00:19:14.326 A:middle
impact.

00:19:15.436 --> 00:19:16.446 A:middle
So, often you might start like

00:19:16.446 --> 00:19:16.876 A:middle
this.

00:19:17.166 --> 00:19:18.506 A:middle
We call this row linear order.

00:19:19.246 --> 00:19:22.326 A:middle
Now, the problem here is that as

00:19:22.326 --> 00:19:23.506 A:middle
Metal works its way through

00:19:23.506 --> 00:19:25.336 A:middle
these rays, they tend to hit

00:19:25.336 --> 00:19:26.556 A:middle
very different nodes in the

00:19:26.556 --> 00:19:28.166 A:middle
internal data structures that

00:19:28.166 --> 00:19:29.586 A:middle
Metal uses to accelerate ray

00:19:29.586 --> 00:19:30.126 A:middle
traversal.

00:19:30.606 --> 00:19:32.646 A:middle
Now this in turn can flash the

00:19:32.646 --> 00:19:33.816 A:middle
underlying hardware caches.

00:19:33.816 --> 00:19:37.116 A:middle
So, a better approach is to use

00:19:37.116 --> 00:19:38.386 A:middle
block linear ordering.

00:19:39.646 --> 00:19:40.946 A:middle
So, rays from nearby pixels on

00:19:40.946 --> 00:19:42.336 A:middle
the screen, they tend to hit the

00:19:42.336 --> 00:19:43.606 A:middle
same parts of your acceleration

00:19:43.606 --> 00:19:45.626 A:middle
structure, and so by storing

00:19:45.626 --> 00:19:47.136 A:middle
your rays like this it enables

00:19:47.136 --> 00:19:48.536 A:middle
Metal to drive the hardware much

00:19:48.536 --> 00:19:49.246 A:middle
more efficiently.

00:19:49.616 --> 00:19:52.226 A:middle
Now, in the visualization here,

00:19:52.226 --> 00:19:53.826 A:middle
I'm showing you a block size of

00:19:53.886 --> 00:19:54.716 A:middle
4 by 4.

00:19:55.056 --> 00:19:56.446 A:middle
In practice we found that 8 by 8

00:19:56.446 --> 00:19:58.026 A:middle
works really, really well.

00:19:59.796 --> 00:20:01.526 A:middle
So, optimizing your ray storage

00:19:59.796 --> 00:20:01.526 A:middle
So, optimizing your ray storage

00:20:01.526 --> 00:20:02.796 A:middle
is a great way to improve

00:20:02.796 --> 00:20:03.686 A:middle
performance.

00:20:03.776 --> 00:20:05.216 A:middle
But where possible, an even

00:20:05.216 --> 00:20:06.836 A:middle
better way is just not to fire

00:20:06.836 --> 00:20:07.336 A:middle
rays at all.

00:20:07.336 --> 00:20:10.246 A:middle
Now, in the context of shadows,

00:20:10.246 --> 00:20:11.826 A:middle
the reason that you might want

00:20:11.826 --> 00:20:13.386 A:middle
to do this is because not all

00:20:13.386 --> 00:20:14.646 A:middle
pixels need a shadow ray.

00:20:14.986 --> 00:20:16.786 A:middle
For example, pixels on your

00:20:16.786 --> 00:20:18.656 A:middle
background, on your skybox, or

00:20:18.656 --> 00:20:19.976 A:middle
on surfaces that are facing away

00:20:19.976 --> 00:20:22.876 A:middle
from the sun.

00:20:23.056 --> 00:20:24.056 A:middle
Now, it's likely that your ray

00:20:24.056 --> 00:20:25.716 A:middle
buffer contains a ray structure

00:20:25.986 --> 00:20:27.416 A:middle
for each pixel on the screen.

00:20:27.676 --> 00:20:29.496 A:middle
So, what we need here is a way

00:20:29.496 --> 00:20:31.156 A:middle
to tell Metal to skip firing

00:20:31.156 --> 00:20:32.616 A:middle
ways for the pixels that we just

00:20:32.616 --> 00:20:33.866 A:middle
don't care about.

00:20:34.456 --> 00:20:35.696 A:middle
Now, there's a few ways to do

00:20:35.696 --> 00:20:36.076 A:middle
this.

00:20:36.076 --> 00:20:37.316 A:middle
The approach I'm showing you

00:20:37.316 --> 00:20:38.656 A:middle
here is simply to set the

00:20:38.656 --> 00:20:39.966 A:middle
maxDistance field in your ray

00:20:39.966 --> 00:20:41.776 A:middle
structure to a negative value.

00:20:42.346 --> 00:20:45.146 A:middle
And that's the main things you

00:20:45.146 --> 00:20:46.446 A:middle
need to know for Hard Shadows.

00:20:47.506 --> 00:20:48.636 A:middle
As you can see, Ray Tracing

00:20:48.636 --> 00:20:50.036 A:middle
gives really great results.

00:20:50.106 --> 00:20:51.376 A:middle
The shadows are very crisp and

00:20:51.376 --> 00:20:52.346 A:middle
they're very precise.

00:20:53.386 --> 00:20:56.316 A:middle
But in reality, shadows cast by

00:20:56.316 --> 00:20:58.636 A:middle
the sun, they tend not to look

00:20:58.636 --> 00:20:59.196 A:middle
that sharp.

00:20:59.976 --> 00:21:00.736 A:middle
they look more like this.

00:20:59.976 --> 00:21:00.736 A:middle
they look more like this.

00:21:01.726 --> 00:21:02.916 A:middle
They're soft around the edges

00:21:03.156 --> 00:21:04.276 A:middle
and that softness varies with

00:21:04.276 --> 00:21:04.926 A:middle
distance.

00:21:05.686 --> 00:21:07.316 A:middle
And you can see a great example

00:21:07.316 --> 00:21:08.436 A:middle
of this on the left there.

00:21:09.356 --> 00:21:10.446 A:middle
the shadow from the lamp post

00:21:10.446 --> 00:21:11.896 A:middle
starts off hard at the base and

00:21:11.896 --> 00:21:13.356 A:middle
it softens as the distance to

00:21:13.356 --> 00:21:14.176 A:middle
the ground increases.

00:21:14.846 --> 00:21:17.116 A:middle
So, to model that with Ray

00:21:17.116 --> 00:21:18.776 A:middle
Tracing, instead of using the

00:21:18.776 --> 00:21:19.966 A:middle
parallel rays that I was showing

00:21:19.966 --> 00:21:21.556 A:middle
you earlier, we'll instead

00:21:21.726 --> 00:21:23.056 A:middle
extend the cone from our surface

00:21:23.126 --> 00:21:24.596 A:middle
point all the way up to the sun.

00:21:25.506 --> 00:21:27.176 A:middle
And then, we'll generate some

00:21:27.176 --> 00:21:28.666 A:middle
ray directions randomly within

00:21:29.606 --> 00:21:31.066 A:middle
this cone.

00:21:31.286 --> 00:21:32.446 A:middle
Now you can see there that some

00:21:32.446 --> 00:21:34.096 A:middle
rays intersect geometry and some

00:21:34.156 --> 00:21:34.396 A:middle
don't.

00:21:34.396 --> 00:21:36.356 A:middle
And it's this ratio that

00:21:36.356 --> 00:21:37.506 A:middle
controls the softness of your

00:21:37.506 --> 00:21:38.136 A:middle
shadow.

00:21:38.866 --> 00:21:41.186 A:middle
So, here's what that looks like.

00:21:42.066 --> 00:21:44.496 A:middle
What I'm showing you here is the

00:21:44.496 --> 00:21:46.556 A:middle
raw direct lighting term ray

00:21:46.556 --> 00:21:48.006 A:middle
traced with one ray per pixel.

00:21:49.006 --> 00:21:50.386 A:middle
So, in this image, all other

00:21:50.386 --> 00:21:52.716 A:middle
effects such as reflections and

00:21:52.716 --> 00:21:54.616 A:middle
global illumination, they're all

00:21:54.616 --> 00:21:56.216 A:middle
disabled so we can focus purely

00:21:56.216 --> 00:21:56.726 A:middle
on the shadow.

00:21:57.876 --> 00:22:00.096 A:middle
And as you can see, the result

00:21:57.876 --> 00:22:00.096 A:middle
And as you can see, the result

00:22:00.096 --> 00:22:01.406 A:middle
is really quite noisy.

00:22:02.086 --> 00:22:04.856 A:middle
Now, to deal with that, we could

00:22:04.856 --> 00:22:06.086 A:middle
just keep firing more and more

00:22:06.086 --> 00:22:06.346 A:middle
rays.

00:22:06.756 --> 00:22:08.086 A:middle
But since that's something we're

00:22:08.086 --> 00:22:09.486 A:middle
really trying to avoid in a real

00:22:09.486 --> 00:22:11.706 A:middle
time application, what we can do

00:22:11.706 --> 00:22:13.786 A:middle
instead is use the Denoiser that

00:22:13.786 --> 00:22:14.706 A:middle
Sean was telling us about

00:22:14.706 --> 00:22:14.926 A:middle
earlier.

00:22:15.606 --> 00:22:19.266 A:middle
And here's the results of that.

00:22:19.346 --> 00:22:20.376 A:middle
Most of the noise is filtered

00:22:20.376 --> 00:22:21.796 A:middle
away and we get these great

00:22:21.796 --> 00:22:23.166 A:middle
looking soft shadows with just

00:22:23.166 --> 00:22:24.066 A:middle
one ray per pixel.

00:22:24.956 --> 00:22:26.666 A:middle
And I'll be showing you this in

00:22:26.666 --> 00:22:28.226 A:middle
action in our live demo later

00:22:28.226 --> 00:22:28.426 A:middle
on.

00:22:29.026 --> 00:22:33.466 A:middle
So now let's talk about Ambient

00:22:33.466 --> 00:22:33.956 A:middle
Occlusion.

00:22:34.606 --> 00:22:37.016 A:middle
So essentially, this is an

00:22:37.016 --> 00:22:38.346 A:middle
approximation of how much

00:22:38.406 --> 00:22:39.776 A:middle
ambient light is able to reach

00:22:39.776 --> 00:22:40.446 A:middle
the surface.

00:22:41.306 --> 00:22:42.946 A:middle
And as you saw in our AR Quick

00:22:42.946 --> 00:22:44.506 A:middle
Look demo earlier, it's a really

00:22:44.506 --> 00:22:45.716 A:middle
great technique for grounding

00:22:45.716 --> 00:22:47.266 A:middle
objects in their environments.

00:22:48.596 --> 00:22:50.176 A:middle
So, let's visualize how this

00:22:50.176 --> 00:22:51.126 A:middle
works with Ray Tracing.

00:22:52.066 --> 00:22:53.866 A:middle
We have a surface point in the

00:22:53.866 --> 00:22:54.736 A:middle
middle of the screen there and

00:22:55.556 --> 00:22:57.206 A:middle
there's a blue block over on the

00:22:57.206 --> 00:22:58.216 A:middle
right that's going to play the

00:22:58.216 --> 00:22:59.146 A:middle
role of our occluder.

00:23:00.676 --> 00:23:01.686 A:middle
We define an imaginary

00:23:01.686 --> 00:23:03.176 A:middle
hemisphere around our surface

00:23:03.216 --> 00:23:04.916 A:middle
points and then we fire some

00:23:04.916 --> 00:23:05.136 A:middle
rays.

00:23:05.836 --> 00:23:09.106 A:middle
If a ray hits something, and we

00:23:09.106 --> 00:23:10.426 A:middle
found that object is blocking

00:23:10.426 --> 00:23:11.616 A:middle
ambient light from reaching the

00:23:11.726 --> 00:23:11.886 A:middle
surface.

00:23:14.376 --> 00:23:15.866 A:middle
Now, as I've mentioned a couple

00:23:15.866 --> 00:23:17.356 A:middle
of times now, in a real time

00:23:17.356 --> 00:23:18.826 A:middle
application, we're really trying

00:23:18.826 --> 00:23:20.186 A:middle
to limit ourselves to just one

00:23:20.186 --> 00:23:21.156 A:middle
or two rays per pixel.

00:23:22.136 --> 00:23:23.616 A:middle
So, we need to use these rays as

00:23:23.616 --> 00:23:26.616 A:middle
efficiently as we can.

00:23:26.646 --> 00:23:28.236 A:middle
Now, one of the ways to do this

00:23:28.236 --> 00:23:29.246 A:middle
is importance sampling.

00:23:29.846 --> 00:23:31.446 A:middle
And the general idea here is to

00:23:31.446 --> 00:23:33.286 A:middle
fire rays in the directions

00:23:33.286 --> 00:23:34.036 A:middle
where we expect they'll

00:23:34.036 --> 00:23:35.626 A:middle
contribute most to our final

00:23:35.626 --> 00:23:36.066 A:middle
image.

00:23:36.666 --> 00:23:39.536 A:middle
Now with Ambient Occlusion the

00:23:39.536 --> 00:23:40.836 A:middle
most important rays are the ones

00:23:40.836 --> 00:23:41.826 A:middle
closer to the normal.

00:23:43.026 --> 00:23:44.676 A:middle
So instead of firing rays evenly

00:23:44.676 --> 00:23:45.776 A:middle
in a hemisphere like you see

00:23:45.776 --> 00:23:47.216 A:middle
here, we instead use cosine

00:23:47.216 --> 00:23:47.946 A:middle
sampling.

00:23:48.546 --> 00:23:51.196 A:middle
Now, this distributes fewer rays

00:23:51.196 --> 00:23:52.656 A:middle
around the horizons and more

00:23:52.656 --> 00:23:53.876 A:middle
rays around the surface normal.

00:23:54.256 --> 00:23:54.786 A:middle
And that's great.

00:23:54.786 --> 00:23:56.766 A:middle
That's exactly where we need

00:23:58.836 --> 00:23:58.946 A:middle
them.

00:23:59.156 --> 00:24:00.536 A:middle
Now in addition to this angular

00:23:59.156 --> 00:24:00.536 A:middle
Now in addition to this angular

00:24:00.536 --> 00:24:02.626 A:middle
falloff, Ambient Occlusion also

00:24:02.626 --> 00:24:03.666 A:middle
has a distance term.

00:24:04.326 --> 00:24:05.576 A:middle
So, objects close to the

00:24:05.576 --> 00:24:06.786 A:middle
surface, they tend to block the

00:24:06.786 --> 00:24:07.196 A:middle
most light.

00:24:07.196 --> 00:24:09.226 A:middle
And there's usually a fall off

00:24:09.226 --> 00:24:10.286 A:middle
function in there too,

00:24:10.286 --> 00:24:11.536 A:middle
proportional to the square of

00:24:11.536 --> 00:24:12.226 A:middle
distance.

00:24:13.876 --> 00:24:15.376 A:middle
Now, interesting thing we can do

00:24:15.376 --> 00:24:16.976 A:middle
here is bake that fall off

00:24:16.976 --> 00:24:18.336 A:middle
function right into the ray

00:24:18.336 --> 00:24:19.476 A:middle
distribution itself.

00:24:20.316 --> 00:24:21.736 A:middle
And the way we do this is by

00:24:21.846 --> 00:24:22.936 A:middle
firing rays of different

00:24:23.856 --> 00:24:24.036 A:middle
lengths.

00:24:25.076 --> 00:24:26.676 A:middle
So, as you can see here, because

00:24:26.676 --> 00:24:28.446 A:middle
of that distance squared fall

00:24:28.446 --> 00:24:29.376 A:middle
off function I was telling you

00:24:29.376 --> 00:24:31.426 A:middle
about, the majority of rays end

00:24:31.426 --> 00:24:32.256 A:middle
up being quite short.

00:24:32.256 --> 00:24:33.956 A:middle
Now this is great for

00:24:33.956 --> 00:24:34.656 A:middle
performance.

00:24:34.726 --> 00:24:36.366 A:middle
Short rays are much easier for

00:24:36.366 --> 00:24:37.366 A:middle
Metal to trace through the

00:24:37.366 --> 00:24:38.366 A:middle
acceleration structures.

00:24:38.986 --> 00:24:43.386 A:middle
So, a couple of times now, I've

00:24:43.386 --> 00:24:45.186 A:middle
talked about generating rays in

00:24:45.186 --> 00:24:46.666 A:middle
various shapes and various

00:24:46.666 --> 00:24:48.596 A:middle
distributions, such as the cones

00:24:48.596 --> 00:24:49.826 A:middle
we were using for Soft Shadows

00:24:50.006 --> 00:24:51.186 A:middle
and the hemisphere's that we're

00:24:51.186 --> 00:24:52.366 A:middle
using for Ambient Occlusion.

00:24:52.966 --> 00:24:55.606 A:middle
Now, the way that this works in

00:24:55.606 --> 00:24:57.366 A:middle
practice is we begin by

00:24:57.396 --> 00:24:58.866 A:middle
generating points in 2D

00:24:58.866 --> 00:25:00.556 A:middle
parameter space and then we map

00:24:58.866 --> 00:25:00.556 A:middle
parameter space and then we map

00:25:00.716 --> 00:25:02.206 A:middle
that space with whichever ray

00:25:02.206 --> 00:25:03.516 A:middle
distribution you want to use.

00:25:04.106 --> 00:25:06.826 A:middle
Now the position of these points

00:25:06.826 --> 00:25:08.426 A:middle
in parameter space can have a

00:25:08.426 --> 00:25:09.796 A:middle
big effect on image quality.

00:25:11.206 --> 00:25:12.856 A:middle
If you choose them randomly, you

00:25:12.856 --> 00:25:14.056 A:middle
tend to end up with regions

00:25:14.056 --> 00:25:15.076 A:middle
where sample points clump

00:25:15.076 --> 00:25:15.366 A:middle
together.

00:25:15.366 --> 00:25:18.896 A:middle
Now this causes us to fire rays

00:25:18.896 --> 00:25:19.896 A:middle
in pretty much the same

00:25:19.896 --> 00:25:21.296 A:middle
direction and that's just

00:25:21.296 --> 00:25:21.926 A:middle
wasting rays.

00:25:22.576 --> 00:25:26.536 A:middle
You can also get areas without

00:25:26.536 --> 00:25:27.606 A:middle
any sample points at all.

00:25:28.106 --> 00:25:30.226 A:middle
Now this impacts image quality

00:25:30.226 --> 00:25:31.346 A:middle
because we're undersampling the

00:25:31.346 --> 00:25:32.266 A:middle
scene in these areas.

00:25:32.946 --> 00:25:35.336 A:middle
So, a better approach to

00:25:35.336 --> 00:25:37.046 A:middle
generate sample points is to use

00:25:37.046 --> 00:25:37.846 A:middle
something called a low

00:25:37.846 --> 00:25:39.206 A:middle
discrepancy sequence.

00:25:39.906 --> 00:25:40.726 A:middle
So, the one I'm showing you up

00:25:40.756 --> 00:25:41.986 A:middle
on the screen here is the Halton

00:25:41.986 --> 00:25:43.286 A:middle
2,3 sequence.

00:25:44.756 --> 00:25:46.206 A:middle
You can see that sample points

00:25:46.206 --> 00:25:47.406 A:middle
generated in this way, they

00:25:47.556 --> 00:25:49.446 A:middle
cover the space far more evenly

00:25:49.446 --> 00:25:50.746 A:middle
and we vanish the void by

00:25:50.896 --> 00:25:52.436 A:middle
plumping and undersampling.

00:25:53.046 --> 00:25:57.856 A:middle
So that's how to generate good

00:25:57.856 --> 00:25:59.406 A:middle
rays for a single pixel.

00:26:00.036 --> 00:26:01.216 A:middle
And what we need to do now is

00:26:01.316 --> 00:26:02.936 A:middle
scale that to generate good rays

00:26:02.936 --> 00:26:04.406 A:middle
for all pixels on the screen.

00:26:04.496 --> 00:26:06.846 A:middle
Now, the way that we're doing

00:26:06.846 --> 00:26:08.586 A:middle
this is by taking one of those

00:26:08.586 --> 00:26:10.336 A:middle
low discrepancy sample points I

00:26:10.336 --> 00:26:12.206 A:middle
was just showing you and then we

00:26:12.206 --> 00:26:13.726 A:middle
apply a random delta for each

00:26:13.726 --> 00:26:14.106 A:middle
pixel.

00:26:14.726 --> 00:26:18.426 A:middle
Now, the effect of that is that

00:26:18.466 --> 00:26:20.396 A:middle
each pixel still runs through a

00:26:20.396 --> 00:26:22.556 A:middle
low discrepancy sequence, but

00:26:22.556 --> 00:26:23.676 A:middle
the exact positions of the

00:26:23.676 --> 00:26:25.326 A:middle
sample points are offset from

00:26:25.326 --> 00:26:26.176 A:middle
neighboring pixels on the

00:26:26.176 --> 00:26:26.726 A:middle
screen.

00:26:27.206 --> 00:26:29.826 A:middle
Now, there's a couple of

00:26:29.826 --> 00:26:31.116 A:middle
different ways to generate these

00:26:31.116 --> 00:26:31.706 A:middle
deltas.

00:26:32.646 --> 00:26:34.826 A:middle
One way is just to sample an RG

00:26:34.826 --> 00:26:36.856 A:middle
texture full of random numbers.

00:26:37.386 --> 00:26:40.026 A:middle
What we saw previously that

00:26:40.026 --> 00:26:41.446 A:middle
random numbers aren't always a

00:26:41.446 --> 00:26:42.796 A:middle
great choice for Ray Tracing.

00:26:43.376 --> 00:26:44.796 A:middle
And an alternative that works

00:26:44.856 --> 00:26:45.836 A:middle
really well for Ambient

00:26:45.836 --> 00:26:47.266 A:middle
Occlusion is blue noise.

00:26:47.376 --> 00:26:49.966 A:middle
So, you can see on the right

00:26:50.026 --> 00:26:51.906 A:middle
there that the randomness is the

00:26:51.906 --> 00:26:53.366 A:middle
blue noise texture, it's

00:26:53.396 --> 00:26:55.436 A:middle
distributed far more evenly and

00:26:55.576 --> 00:26:56.936 A:middle
that's great for image quality.

00:26:56.936 --> 00:26:58.726 A:middle
Particularly when we're limited

00:26:58.836 --> 00:26:59.856 A:middle
to just a couple of rays per

00:26:59.856 --> 00:27:00.096 A:middle
pixel.

00:26:59.856 --> 00:27:00.096 A:middle
pixel.

00:27:00.096 --> 00:27:03.886 A:middle
So, let's look at the effect of

00:27:03.886 --> 00:27:05.416 A:middle
all of this on the Ambient

00:27:05.416 --> 00:27:06.396 A:middle
Occlusion result that we were

00:27:06.396 --> 00:27:07.136 A:middle
trying to generate.

00:27:07.886 --> 00:27:09.896 A:middle
So, here's what we started with.

00:27:11.036 --> 00:27:12.066 A:middle
This is using hemisphere

00:27:12.066 --> 00:27:14.186 A:middle
sampling and random deltas for

00:27:14.186 --> 00:27:14.786 A:middle
all pixels.

00:27:15.396 --> 00:27:18.546 A:middle
And this is what we get with

00:27:18.546 --> 00:27:20.196 A:middle
cosine sampling and the blue

00:27:20.196 --> 00:27:21.136 A:middle
noise that I was telling you

00:27:21.136 --> 00:27:21.446 A:middle
about.

00:27:21.446 --> 00:27:23.506 A:middle
So, I'll flip between these

00:27:23.506 --> 00:27:24.396 A:middle
images so you can see.

00:27:25.816 --> 00:27:27.146 A:middle
Now, both of these images are

00:27:27.146 --> 00:27:28.846 A:middle
generated using just two rays

00:27:28.846 --> 00:27:29.346 A:middle
per pixel.

00:27:29.406 --> 00:27:31.896 A:middle
But you can see by being

00:27:31.946 --> 00:27:33.576 A:middle
selective about how we use those

00:27:33.576 --> 00:27:35.836 A:middle
rays, the amount of noise is

00:27:35.836 --> 00:27:37.246 A:middle
significantly reduced.

00:27:37.246 --> 00:27:38.396 A:middle
And we've managed to capture

00:27:38.396 --> 00:27:39.856 A:middle
much more of the fine surface

00:27:39.856 --> 00:27:40.266 A:middle
detail.

00:27:40.856 --> 00:27:43.456 A:middle
And if we were to keep firing

00:27:43.456 --> 00:27:45.316 A:middle
rays, eventually the two

00:27:45.316 --> 00:27:46.516 A:middle
approaches would converge on

00:27:46.516 --> 00:27:47.746 A:middle
exactly the same image.

00:27:48.136 --> 00:27:49.846 A:middle
But using importance sampling

00:27:49.846 --> 00:27:51.616 A:middle
gets us there much faster.

00:27:53.516 --> 00:27:55.386 A:middle
So that's Shadows and Ambient

00:27:55.386 --> 00:27:55.846 A:middle
Occlusion.

00:27:56.386 --> 00:27:58.046 A:middle
And for these effects we were

00:27:58.046 --> 00:27:59.636 A:middle
really only interested in

00:27:59.636 --> 00:28:00.916 A:middle
whether our rays hit something

00:27:59.636 --> 00:28:00.916 A:middle
whether our rays hit something

00:28:00.916 --> 00:28:01.976 A:middle
or whether they missed.

00:28:02.826 --> 00:28:04.866 A:middle
Now, for many of the other

00:28:04.866 --> 00:28:06.036 A:middle
effects that we typically

00:28:06.036 --> 00:28:07.756 A:middle
associate with Ray Tracing, such

00:28:07.756 --> 00:28:09.766 A:middle
as Global Illumination, you need

00:28:09.766 --> 00:28:10.676 A:middle
to model your rays as they

00:28:10.676 --> 00:28:11.856 A:middle
bounce around the scene.

00:28:11.856 --> 00:28:13.896 A:middle
And to talk some more about that

00:28:13.896 --> 00:28:14.876 A:middle
I'll invite up my colleague

00:28:14.876 --> 00:28:14.976 A:middle
Matt.

00:28:16.516 --> 00:28:23.346 A:middle
[ Applause ]

00:28:23.846 --> 00:28:25.916 A:middle
&gt;&gt; Thanks Wayne.

00:28:26.456 --> 00:28:28.846 A:middle
So, we're going to cover a few

00:28:28.846 --> 00:28:30.336 A:middle
topics in this section, starting

00:28:30.336 --> 00:28:31.486 A:middle
with a brief overview of Global

00:28:31.486 --> 00:28:32.046 A:middle
Illumination.

00:28:32.546 --> 00:28:34.126 A:middle
Then, we'll go into some best

00:28:34.126 --> 00:28:35.306 A:middle
practices for memory and ray

00:28:35.306 --> 00:28:35.796 A:middle
management.

00:28:36.426 --> 00:28:38.036 A:middle
Finally, we'll cover some

00:28:38.036 --> 00:28:39.206 A:middle
strategies for debugging your

00:28:39.206 --> 00:28:40.186 A:middle
Ray Tracing application.

00:28:41.486 --> 00:28:43.256 A:middle
So, what is Global Illumination?

00:28:44.866 --> 00:28:46.056 A:middle
Conceptually it's pretty simple.

00:28:46.626 --> 00:28:47.876 A:middle
Light enters the scene and

00:28:47.876 --> 00:28:48.786 A:middle
directly illuminates the

00:28:48.786 --> 00:28:49.926 A:middle
surfaces that it hits.

00:28:50.646 --> 00:28:51.846 A:middle
And rasterization, that's

00:28:51.876 --> 00:28:52.546 A:middle
typically the end of the

00:28:52.546 --> 00:28:53.476 A:middle
rendering process.

00:28:53.866 --> 00:28:55.066 A:middle
But in the real world, those

00:28:55.066 --> 00:28:56.416 A:middle
objects absorb some of the light

00:28:56.416 --> 00:28:58.026 A:middle
and then the rays bounce off and

00:28:58.026 --> 00:28:59.196 A:middle
keep traveling around the scene.

00:28:59.686 --> 00:29:00.896 A:middle
And as they bounce around, some

00:28:59.686 --> 00:29:00.896 A:middle
And as they bounce around, some

00:29:00.896 --> 00:29:01.926 A:middle
interesting visual effects

00:29:01.926 --> 00:29:02.366 A:middle
emerge.

00:29:03.656 --> 00:29:05.986 A:middle
After light has bounced once we

00:29:05.986 --> 00:29:06.876 A:middle
start to see specular

00:29:06.876 --> 00:29:07.786 A:middle
reflections on the mirrored

00:29:07.786 --> 00:29:09.456 A:middle
surfaces like the ball and wall

00:29:09.456 --> 00:29:09.896 A:middle
to the right.

00:29:10.446 --> 00:29:12.916 A:middle
You can also see that objects

00:29:12.916 --> 00:29:14.166 A:middle
and shadows get brighter as they

00:29:14.166 --> 00:29:14.916 A:middle
pick up light that's been

00:29:14.916 --> 00:29:16.366 A:middle
reflected off nearby surfaces.

00:29:16.886 --> 00:29:19.406 A:middle
After the light has bounced

00:29:19.406 --> 00:29:20.286 A:middle
twice, we start to see

00:29:20.286 --> 00:29:21.476 A:middle
reflections between mirrored

00:29:21.476 --> 00:29:23.906 A:middle
surfaces and eventually, some

00:29:23.906 --> 00:29:25.176 A:middle
rays have refracted all the way

00:29:25.176 --> 00:29:26.946 A:middle
through transparent objects, and

00:29:26.946 --> 00:29:27.816 A:middle
they're showing the surfaces

00:29:27.816 --> 00:29:29.206 A:middle
behind them giving us the glass

00:29:29.206 --> 00:29:30.136 A:middle
effect of the box.

00:29:30.726 --> 00:29:32.956 A:middle
Now, if we tried to model all

00:29:32.956 --> 00:29:33.766 A:middle
the light bouncing around the

00:29:33.766 --> 00:29:35.746 A:middle
scene only a small portion of it

00:29:35.746 --> 00:29:36.946 A:middle
would actually make it back to

00:29:36.946 --> 00:29:38.066 A:middle
the camera and that would be

00:29:38.066 --> 00:29:38.706 A:middle
pretty inefficient.

00:29:38.986 --> 00:29:41.296 A:middle
So instead, we'll work backwards

00:29:41.446 --> 00:29:42.576 A:middle
from the camera towards the

00:29:42.576 --> 00:29:43.446 A:middle
light source.

00:29:44.376 --> 00:29:46.236 A:middle
We cast rays from the camera

00:29:46.236 --> 00:29:47.606 A:middle
towards the pixels in our image.

00:29:49.386 --> 00:29:51.316 A:middle
The intersection points of those

00:29:51.316 --> 00:29:52.666 A:middle
rays tell us what objects are

00:29:52.666 --> 00:29:53.036 A:middle
visible.

00:29:53.036 --> 00:29:54.376 A:middle
But we'll need to figure out how

00:29:54.376 --> 00:29:55.516 A:middle
much light is reaching them in

00:29:55.516 --> 00:29:56.416 A:middle
order to figure out what their

00:29:56.416 --> 00:29:57.666 A:middle
color in the final image should

00:29:57.666 --> 00:29:57.956 A:middle
be.

00:29:59.036 --> 00:30:00.396 A:middle
Earlier, Wayne described how to

00:29:59.036 --> 00:30:00.396 A:middle
Earlier, Wayne described how to

00:30:00.396 --> 00:30:02.296 A:middle
calculate soft shadows and here

00:30:02.296 --> 00:30:03.156 A:middle
we're going to be performing

00:30:03.156 --> 00:30:04.616 A:middle
exactly the same process.

00:30:05.956 --> 00:30:07.136 A:middle
We cast shadow rays from the

00:30:07.136 --> 00:30:08.546 A:middle
intersection points towards the

00:30:08.546 --> 00:30:09.826 A:middle
lights in the scene in order to

00:30:09.826 --> 00:30:10.946 A:middle
approximate how much light's

00:30:10.946 --> 00:30:11.366 A:middle
reaching them.

00:30:12.606 --> 00:30:13.496 A:middle
That's used as the light

00:30:13.496 --> 00:30:14.706 A:middle
contribution towards the final

00:30:14.706 --> 00:30:15.026 A:middle
image.

00:30:15.526 --> 00:30:19.336 A:middle
Next, from the intersection

00:30:19.336 --> 00:30:21.166 A:middle
points we cast secondary rays in

00:30:21.166 --> 00:30:22.136 A:middle
random directions.

00:30:22.676 --> 00:30:24.226 A:middle
We use Metal to figure out what

00:30:24.306 --> 00:30:25.706 A:middle
those rays hit and then cast

00:30:25.706 --> 00:30:26.866 A:middle
shadow rays to determine their

00:30:26.866 --> 00:30:28.216 A:middle
direct lighting and then use

00:30:28.216 --> 00:30:29.396 A:middle
that to add light to the final

00:30:29.396 --> 00:30:29.726 A:middle
image.

00:30:30.366 --> 00:30:31.816 A:middle
By repeating this process, we

00:30:31.816 --> 00:30:32.866 A:middle
can simulate light bouncing

00:30:32.866 --> 00:30:34.056 A:middle
around the room.

00:30:34.486 --> 00:30:35.856 A:middle
We described this extensively in

00:30:35.856 --> 00:30:37.126 A:middle
last year's talk, so I'll refer

00:30:37.126 --> 00:30:38.206 A:middle
you to that for more details on

00:30:38.206 --> 00:30:39.476 A:middle
how to go through this process.

00:30:39.996 --> 00:30:42.586 A:middle
Our pipeline for this will look

00:30:42.586 --> 00:30:43.456 A:middle
a little bit different than the

00:30:43.456 --> 00:30:44.656 A:middle
hybrid pipelines that we've seen

00:30:44.656 --> 00:30:45.156 A:middle
so far.

00:30:46.316 --> 00:30:47.526 A:middle
First, we set up rays and use

00:30:47.526 --> 00:30:48.226 A:middle
Metal to find their

00:30:48.226 --> 00:30:51.496 A:middle
intersections with the scene.

00:30:51.966 --> 00:30:53.216 A:middle
Then, we write a shader to

00:30:53.216 --> 00:30:54.236 A:middle
process the results of those

00:30:54.236 --> 00:30:55.916 A:middle
intersection tests to tell us

00:30:55.916 --> 00:30:57.506 A:middle
what surfaces we hit.

00:30:58.956 --> 00:31:01.226 A:middle
Then, we generate shadow rays

00:30:58.956 --> 00:31:01.226 A:middle
Then, we generate shadow rays

00:31:01.226 --> 00:31:02.066 A:middle
from those intersection

00:31:02.066 --> 00:31:03.266 A:middle
locations towards the lights in

00:31:03.266 --> 00:31:03.636 A:middle
the scene.

00:31:04.136 --> 00:31:05.456 A:middle
I'll write a shader to figure

00:31:05.456 --> 00:31:06.516 A:middle
out which of those rays hit the

00:31:06.516 --> 00:31:07.806 A:middle
light and then add their light

00:31:07.806 --> 00:31:08.566 A:middle
to the final image.

00:31:10.016 --> 00:31:11.656 A:middle
Finally, we use the hit surfaces

00:31:11.656 --> 00:31:12.776 A:middle
as the starting positions for

00:31:12.776 --> 00:31:13.766 A:middle
our next set of rays.

00:31:14.326 --> 00:31:15.666 A:middle
We repeat this process over and

00:31:15.666 --> 00:31:16.686 A:middle
over again until we've modeled

00:31:16.686 --> 00:31:17.996 A:middle
as many ray bounces as we like.

00:31:18.626 --> 00:31:20.996 A:middle
So that's how Global

00:31:20.996 --> 00:31:22.156 A:middle
Illumination works.

00:31:22.826 --> 00:31:24.536 A:middle
Now we'll discuss some best

00:31:24.536 --> 00:31:25.606 A:middle
practices that come up with

00:31:25.606 --> 00:31:27.446 A:middle
memory for this programing

00:31:27.446 --> 00:31:27.736 A:middle
model.

00:31:28.976 --> 00:31:31.026 A:middle
As any ray bounces around the

00:31:31.026 --> 00:31:31.486 A:middle
scene.

00:31:31.836 --> 00:31:33.186 A:middle
Its state changes depending on

00:31:33.186 --> 00:31:34.106 A:middle
its interactions with the

00:31:34.106 --> 00:31:35.106 A:middle
objects that it hits.

00:31:35.766 --> 00:31:37.276 A:middle
For instance, if a ray hits a

00:31:37.276 --> 00:31:38.906 A:middle
red material that surface

00:31:38.906 --> 00:31:40.496 A:middle
absorbs everything but the red

00:31:40.496 --> 00:31:41.266 A:middle
component of the light.

00:31:41.836 --> 00:31:42.986 A:middle
So, the secondary rays that

00:31:42.986 --> 00:31:44.616 A:middle
reflect off of that surface will

00:31:44.616 --> 00:31:45.636 A:middle
only carry red light.

00:31:46.146 --> 00:31:47.586 A:middle
So, we'll have to keep track of

00:31:47.586 --> 00:31:48.736 A:middle
that information in order to

00:31:48.736 --> 00:31:50.056 A:middle
pass it to the next iteration of

00:31:50.056 --> 00:31:50.666 A:middle
our pipeline.

00:31:51.366 --> 00:31:51.996 A:middle
That means we'll have to

00:31:51.996 --> 00:31:53.346 A:middle
allocate a bunch of resources to

00:31:53.346 --> 00:31:54.816 A:middle
keep track of ray and scene

00:31:54.816 --> 00:31:55.516 A:middle
properties.

00:31:56.136 --> 00:31:57.646 A:middle
To the right, I've listed a few

00:31:57.646 --> 00:31:59.446 A:middle
examples of scene properties you

00:31:59.446 --> 00:32:02.636 A:middle
may want to keep track of.

00:31:59.446 --> 00:32:02.636 A:middle
may want to keep track of.

00:32:03.146 --> 00:32:04.116 A:middle
With all these new buffers

00:32:04.116 --> 00:32:05.626 A:middle
relocated we're going to be

00:32:05.626 --> 00:32:06.676 A:middle
using a lot of memory.

00:32:07.186 --> 00:32:08.836 A:middle
For a 4K image, the ray buffer

00:32:08.836 --> 00:32:11.096 A:middle
alone would be 250 MB.

00:32:11.416 --> 00:32:12.576 A:middle
In one of our demos, we're using

00:32:12.576 --> 00:32:13.906 A:middle
almost 80 bytes per ray.

00:32:14.536 --> 00:32:15.756 A:middle
And this approach can quickly

00:32:15.756 --> 00:32:16.836 A:middle
exceed the amount of available

00:32:16.836 --> 00:32:17.586 A:middle
GPU memory.

00:32:19.396 --> 00:32:20.946 A:middle
One solution to this is just to

00:32:20.946 --> 00:32:22.476 A:middle
batch up your rays into smaller

00:32:22.476 --> 00:32:23.266 A:middle
groups or tiles.

00:32:23.926 --> 00:32:25.066 A:middle
And by restricting the number of

00:32:25.066 --> 00:32:25.816 A:middle
rays that you're launching

00:32:25.816 --> 00:32:26.916 A:middle
simultaneously you can

00:32:26.916 --> 00:32:28.156 A:middle
drastically reduce the memory

00:32:28.156 --> 00:32:29.396 A:middle
footprint of your resources.

00:32:29.846 --> 00:32:32.336 A:middle
Because the data in these

00:32:32.336 --> 00:32:33.396 A:middle
buffers is going to be passed

00:32:33.496 --> 00:32:35.316 A:middle
between pipeline iterations,

00:32:36.256 --> 00:32:37.546 A:middle
storing that data out and then

00:32:37.546 --> 00:32:38.736 A:middle
reading it in, in the next pass

00:32:38.736 --> 00:32:39.906 A:middle
is going to be a major limiting

00:32:39.906 --> 00:32:40.276 A:middle
factor.

00:32:40.906 --> 00:32:42.956 A:middle
For 4K image we're using over 8

00:32:42.956 --> 00:32:43.756 A:middle
million rays.

00:32:44.276 --> 00:32:45.486 A:middle
And for that number of rays,

00:32:45.486 --> 00:32:46.626 A:middle
we're reading and writing almost

00:32:46.626 --> 00:32:50.006 A:middle
5 gigabytes of data per pass.

00:32:50.286 --> 00:32:51.466 A:middle
There's no one solution to every

00:32:51.466 --> 00:32:52.736 A:middle
bandwidth problem, but we can

00:32:52.736 --> 00:32:53.796 A:middle
give you some best practices

00:32:53.796 --> 00:32:54.936 A:middle
that worked well for us.

00:32:55.206 --> 00:32:57.066 A:middle
First, don't index into your

00:32:57.066 --> 00:32:57.946 A:middle
data buffers randomly.

00:32:58.996 --> 00:33:00.606 A:middle
It's much more efficient if you

00:32:58.996 --> 00:33:00.606 A:middle
It's much more efficient if you

00:33:00.606 --> 00:33:02.196 A:middle
can index by thread ID, so the

00:33:02.196 --> 00:33:03.636 A:middle
compiler can coalesce all of the

00:33:03.636 --> 00:33:05.456 A:middle
loads and stores since the

00:33:05.456 --> 00:33:06.746 A:middle
memory the threads are accessing

00:33:06.746 --> 00:33:07.936 A:middle
will be in adjacent buffer

00:33:07.936 --> 00:33:08.576 A:middle
positions.

00:33:09.796 --> 00:33:10.966 A:middle
This is really going to improve

00:33:10.966 --> 00:33:11.946 A:middle
your cache coherency.

00:33:13.146 --> 00:33:14.756 A:middle
Next, for variables where you

00:33:14.756 --> 00:33:15.786 A:middle
don't need full precision,

00:33:16.376 --> 00:33:17.726 A:middle
consider using smaller data

00:33:17.726 --> 00:33:18.586 A:middle
types where possible.

00:33:19.316 --> 00:33:20.736 A:middle
Try to use half instead of float

00:33:20.736 --> 00:33:22.196 A:middle
data types for ray and scene and

00:33:22.196 --> 00:33:23.366 A:middle
material properties if you can.

00:33:24.806 --> 00:33:26.566 A:middle
Finally, split up structs if

00:33:26.566 --> 00:33:27.836 A:middle
possible, to avoid loading or

00:33:27.836 --> 00:33:28.996 A:middle
storing data you're not going to

00:33:28.996 --> 00:33:29.446 A:middle
use.

00:33:29.696 --> 00:33:31.506 A:middle
For example, we have a struct

00:33:31.506 --> 00:33:32.586 A:middle
that contains material

00:33:32.586 --> 00:33:33.206 A:middle
properties.

00:33:33.776 --> 00:33:35.026 A:middle
We get a nice performance boost

00:33:35.026 --> 00:33:35.706 A:middle
by stripping out the

00:33:35.706 --> 00:33:37.316 A:middle
transparency variables because

00:33:37.316 --> 00:33:38.926 A:middle
not every ray hits a transparent

00:33:38.926 --> 00:33:39.446 A:middle
surface.

00:33:39.446 --> 00:33:40.626 A:middle
And we didn't want those rays to

00:33:40.626 --> 00:33:41.756 A:middle
have to pay the penalty for

00:33:41.756 --> 00:33:42.806 A:middle
reading and writing that data.

00:33:43.626 --> 00:33:44.356 A:middle
We're going to see a more

00:33:44.356 --> 00:33:45.716 A:middle
concrete example of this later

00:33:45.716 --> 00:33:46.916 A:middle
in the GPU debugging section.

00:33:46.916 --> 00:33:51.476 A:middle
It might be counter intuitive,

00:33:51.576 --> 00:33:52.586 A:middle
but it may be more efficient to

00:33:52.586 --> 00:33:53.886 A:middle
allocate your own buffers to

00:33:53.886 --> 00:33:55.996 A:middle
store origin and direction data

00:33:56.356 --> 00:33:57.586 A:middle
rather than reusing the Metal

00:33:57.586 --> 00:33:58.506 A:middle
ray buffer structs.

00:33:59.816 --> 00:34:00.996 A:middle
This is because the Metal ray

00:33:59.816 --> 00:34:00.996 A:middle
This is because the Metal ray

00:34:00.996 --> 00:34:02.566 A:middle
buffers may contain extra data

00:34:02.566 --> 00:34:03.636 A:middle
numbers that you don't want to

00:34:03.636 --> 00:34:05.516 A:middle
have to load and store for every

00:34:05.516 --> 00:34:06.806 A:middle
shader that may access the ray.

00:34:09.576 --> 00:34:12.096 A:middle
To maximize your GPU usage, you

00:34:12.096 --> 00:34:12.985 A:middle
need to be mindful of your

00:34:12.985 --> 00:34:13.856 A:middle
shader occupancy.

00:34:14.545 --> 00:34:16.306 A:middle
Occupancy is a huge topic, so we

00:34:16.306 --> 00:34:17.565 A:middle
won't go into it in depth here.

00:34:18.266 --> 00:34:19.525 A:middle
But if you are getting occupancy

00:34:19.525 --> 00:34:20.746 A:middle
problems the easiest way to

00:34:20.746 --> 00:34:22.156 A:middle
improve it is to reduce your

00:34:22.156 --> 00:34:22.896 A:middle
register pressure.

00:34:24.246 --> 00:34:25.735 A:middle
So, be conscious of the number

00:34:25.735 --> 00:34:27.255 A:middle
of simultaneously live variables

00:34:27.255 --> 00:34:28.096 A:middle
that you have in your shader.

00:34:28.876 --> 00:34:30.326 A:middle
Be careful with loop counters,

00:34:30.326 --> 00:34:32.505 A:middle
function calls, and don't hold

00:34:32.505 --> 00:34:33.626 A:middle
on to full structs if you can

00:34:33.626 --> 00:34:34.585 A:middle
avoid it.

00:34:35.156 --> 00:34:38.766 A:middle
When we process ray intersection

00:34:38.766 --> 00:34:40.485 A:middle
points we need to evaluate the

00:34:40.485 --> 00:34:41.826 A:middle
surface properties of whatever

00:34:41.826 --> 00:34:42.866 A:middle
object a ray hits.

00:34:43.116 --> 00:34:44.755 A:middle
And graphics applications

00:34:44.755 --> 00:34:45.686 A:middle
typically store a lot of the

00:34:45.686 --> 00:34:47.335 A:middle
material properties in textures.

00:34:47.976 --> 00:34:49.456 A:middle
The problem here is that because

00:34:49.456 --> 00:34:51.446 A:middle
a shader may need access to any

00:34:51.446 --> 00:34:52.346 A:middle
texture that an object

00:34:52.346 --> 00:34:54.936 A:middle
references, and we don't know in

00:34:54.936 --> 00:34:56.696 A:middle
advance what object a ray is

00:34:56.696 --> 00:34:58.246 A:middle
going to hit, we may potential

00:34:58.246 --> 00:35:00.296 A:middle
he need access to every -- every

00:34:58.246 --> 00:35:00.296 A:middle
he need access to every -- every

00:35:00.296 --> 00:35:01.246 A:middle
texture that's in the scene.

00:35:02.006 --> 00:35:03.026 A:middle
And this can get out of hand

00:35:03.026 --> 00:35:03.356 A:middle
quickly.

00:35:03.846 --> 00:35:05.386 A:middle
For instance, the commonly used

00:35:05.386 --> 00:35:07.406 A:middle
Sponza Atrium scene has 76

00:35:07.406 --> 00:35:09.236 A:middle
textures, which is over double

00:35:09.306 --> 00:35:10.426 A:middle
our available number of bind

00:35:10.426 --> 00:35:10.746 A:middle
slots.

00:35:11.376 --> 00:35:12.666 A:middle
So, we'll pretty quickly run out

00:35:12.666 --> 00:35:13.866 A:middle
of binding locations.

00:35:15.756 --> 00:35:17.796 A:middle
One way to address this is by

00:35:17.796 --> 00:35:19.566 A:middle
using Metal Argument Buffers.

00:35:19.906 --> 00:35:20.766 A:middle
A Metal Argument Buffer

00:35:20.766 --> 00:35:22.566 A:middle
represents a group of resources

00:35:22.566 --> 00:35:23.526 A:middle
that can be collectively

00:35:23.526 --> 00:35:24.946 A:middle
assigned as a single argument to

00:35:24.946 --> 00:35:25.316 A:middle
a shader.

00:35:26.466 --> 00:35:27.786 A:middle
We gave a talk on this at WWDC

00:35:27.786 --> 00:35:29.006 A:middle
two years ago.

00:35:29.276 --> 00:35:30.786 A:middle
So, I'll refer you to that for

00:35:30.786 --> 00:35:33.106 A:middle
more details on how to use them.

00:35:33.546 --> 00:35:34.926 A:middle
Assuming we have one texture per

00:35:34.926 --> 00:35:36.706 A:middle
primitive, our argument buffer

00:35:36.706 --> 00:35:38.166 A:middle
will be a struct that contains a

00:35:38.166 --> 00:35:39.006 A:middle
reference to a texture.

00:35:40.376 --> 00:35:41.596 A:middle
Here, we've set up a struct that

00:35:41.596 --> 00:35:43.196 A:middle
we called material that contains

00:35:43.196 --> 00:35:44.536 A:middle
a texture reference and any

00:35:44.536 --> 00:35:45.576 A:middle
other information we'd like to

00:35:45.576 --> 00:35:46.206 A:middle
access.

00:35:47.566 --> 00:35:48.896 A:middle
Next, we bind our argument

00:35:48.896 --> 00:35:49.916 A:middle
buffer to a compute kernel.

00:35:50.206 --> 00:35:51.846 A:middle
It will appear as an array of

00:35:51.846 --> 00:35:52.726 A:middle
material structs.

00:35:54.506 --> 00:35:55.646 A:middle
We read from our intersection

00:35:55.646 --> 00:35:56.676 A:middle
buffer to find out what

00:35:56.676 --> 00:35:59.206 A:middle
primitive the ray hit and then

00:35:59.206 --> 00:36:00.596 A:middle
we index into our argument

00:35:59.206 --> 00:36:00.596 A:middle
we index into our argument

00:36:00.596 --> 00:36:01.936 A:middle
buffer using that index.

00:36:02.626 --> 00:36:04.126 A:middle
That lets us access a unique

00:36:04.126 --> 00:36:04.976 A:middle
texture for every primitive.

00:36:08.646 --> 00:36:10.106 A:middle
That covers our memory topics.

00:36:11.186 --> 00:36:12.336 A:middle
Now we'll discuss managing the

00:36:12.336 --> 00:36:13.436 A:middle
lifetime of your rays.

00:36:14.516 --> 00:36:16.066 A:middle
As your ray bounces around the

00:36:16.066 --> 00:36:17.716 A:middle
scene it can stop contributing

00:36:17.716 --> 00:36:19.026 A:middle
to the final image for a variety

00:36:19.026 --> 00:36:19.646 A:middle
of reasons.

00:36:20.156 --> 00:36:21.546 A:middle
First, it may leave the scene

00:36:21.546 --> 00:36:22.036 A:middle
entirely.

00:36:22.736 --> 00:36:23.936 A:middle
Unlike the real world, your

00:36:23.936 --> 00:36:25.156 A:middle
scene takes up a finite amount

00:36:25.156 --> 00:36:26.956 A:middle
of space, and if the ray exits

00:36:26.956 --> 00:36:28.096 A:middle
it there's no way for it to make

00:36:28.096 --> 00:36:28.866 A:middle
its way back in.

00:36:29.386 --> 00:36:31.386 A:middle
If that happens, we typically

00:36:31.386 --> 00:36:32.716 A:middle
evaluate an environment map to

00:36:32.716 --> 00:36:34.336 A:middle
get a background color, but that

00:36:34.336 --> 00:36:35.376 A:middle
ray is effectively dead.

00:36:36.806 --> 00:36:39.166 A:middle
Second, as the ray bounces, the

00:36:39.166 --> 00:36:40.136 A:middle
light it carries will be

00:36:40.136 --> 00:36:41.566 A:middle
attenuated by the surfaces is

00:36:41.566 --> 00:36:42.266 A:middle
interacts with.

00:36:42.936 --> 00:36:45.456 A:middle
If it loses enough light it may

00:36:45.456 --> 00:36:46.576 A:middle
not be able to have a measurable

00:36:46.576 --> 00:36:47.716 A:middle
impact on the final image.

00:36:48.686 --> 00:36:50.276 A:middle
And finally, with transparent

00:36:50.276 --> 00:36:51.516 A:middle
surfaces, there are some rays

00:36:51.516 --> 00:36:53.026 A:middle
that can get trapped in

00:36:53.026 --> 00:36:54.066 A:middle
position, such that they can

00:36:54.066 --> 00:36:55.166 A:middle
never get back to the camera.

00:36:55.786 --> 00:36:58.826 A:middle
So how quickly to rays become

00:36:58.826 --> 00:36:59.236 A:middle
inactive?

00:37:00.116 --> 00:37:01.136 A:middle
Well, depending on the kind of

00:37:01.136 --> 00:37:02.706 A:middle
scene it can be quite rapid.

00:37:03.396 --> 00:37:04.996 A:middle
For example, this scene has an

00:37:04.996 --> 00:37:06.626 A:middle
open world and a lot of the rays

00:37:06.626 --> 00:37:07.866 A:middle
will exit quickly by hitting the

00:37:07.866 --> 00:37:08.456 A:middle
environment map.

00:37:09.156 --> 00:37:10.156 A:middle
On the right, we're showing a

00:37:10.156 --> 00:37:11.696 A:middle
simplified representation of a

00:37:11.696 --> 00:37:13.666 A:middle
fully active ray buffer as it

00:37:13.666 --> 00:37:14.696 A:middle
would exist for the first

00:37:14.696 --> 00:37:15.956 A:middle
iteration of our pipeline.

00:37:16.346 --> 00:37:17.886 A:middle
This is the step where we cast

00:37:17.886 --> 00:37:19.246 A:middle
rays from the camera towards the

00:37:19.246 --> 00:37:19.546 A:middle
scene.

00:37:20.136 --> 00:37:23.096 A:middle
Some of those rays will hit the

00:37:23.096 --> 00:37:24.016 A:middle
environment map and become

00:37:24.016 --> 00:37:24.436 A:middle
inactive.

00:37:25.156 --> 00:37:26.336 A:middle
Here, we've colored inactive

00:37:26.336 --> 00:37:27.986 A:middle
rays yellow and we've removed

00:37:27.986 --> 00:37:28.826 A:middle
them from the ray buffer.

00:37:29.626 --> 00:37:31.626 A:middle
After the first pass only 57

00:37:31.626 --> 00:37:32.746 A:middle
percent of our rays are still

00:37:32.746 --> 00:37:33.046 A:middle
active.

00:37:34.526 --> 00:37:36.046 A:middle
When we let the rays continue

00:37:36.046 --> 00:37:37.276 A:middle
traveling, some of the rays that

00:37:37.276 --> 00:37:39.006 A:middle
initially hit the ground bounce

00:37:39.006 --> 00:37:40.076 A:middle
up and hit the environment map.

00:37:40.636 --> 00:37:41.916 A:middle
Now we're down to 43 percent of

00:37:41.916 --> 00:37:44.566 A:middle
rays that -- left active.

00:37:45.286 --> 00:37:46.796 A:middle
Now, some of the rays travel all

00:37:46.796 --> 00:37:47.826 A:middle
the way through the transparent

00:37:47.826 --> 00:37:49.126 A:middle
objects and eventually exit the

00:37:49.126 --> 00:37:49.536 A:middle
scene.

00:37:50.036 --> 00:37:50.956 A:middle
We've only got about a third

00:37:50.956 --> 00:37:51.556 A:middle
remaining active.

00:37:52.646 --> 00:37:53.816 A:middle
And of course, the more we

00:37:53.816 --> 00:37:55.016 A:middle
iterate, the more rays become

00:37:55.016 --> 00:37:55.386 A:middle
inactive.

00:37:56.086 --> 00:37:58.896 A:middle
In this example we know a lot of

00:37:58.896 --> 00:38:00.116 A:middle
the rays in our ray buffer will

00:37:58.896 --> 00:38:00.116 A:middle
the rays in our ray buffer will

00:38:00.116 --> 00:38:01.406 A:middle
be inactive, and anytime we

00:38:01.406 --> 00:38:02.466 A:middle
spend processing them will be

00:38:02.466 --> 00:38:02.886 A:middle
wasted.

00:38:03.376 --> 00:38:04.916 A:middle
But because we don't know in

00:38:04.916 --> 00:38:06.156 A:middle
advance which rays are going to

00:38:06.156 --> 00:38:07.896 A:middle
be inactive, the Metal Ray

00:38:07.896 --> 00:38:09.366 A:middle
Intersector and all of the

00:38:09.366 --> 00:38:10.896 A:middle
shaders that process its results

00:38:10.896 --> 00:38:12.126 A:middle
are still going to have to be

00:38:12.126 --> 00:38:13.276 A:middle
run on all of them.

00:38:13.696 --> 00:38:14.296 A:middle
That means we'll have to

00:38:14.296 --> 00:38:15.486 A:middle
allocate thread group memory,

00:38:15.626 --> 00:38:16.756 A:middle
the compiler may be prefetching

00:38:16.756 --> 00:38:18.176 A:middle
data, and we may have to add

00:38:18.176 --> 00:38:20.056 A:middle
control flow statements to cull

00:38:20.056 --> 00:38:21.146 A:middle
inactive rays.

00:38:22.026 --> 00:38:23.676 A:middle
Our occupancy here stays the

00:38:23.676 --> 00:38:25.676 A:middle
same, but our thread groups have

00:38:25.676 --> 00:38:27.076 A:middle
become sparsely utilized.

00:38:27.486 --> 00:38:28.756 A:middle
And we're wasting all that

00:38:28.756 --> 00:38:29.676 A:middle
processor capacity.

00:38:30.216 --> 00:38:33.386 A:middle
Our solution to this is to the

00:38:33.386 --> 00:38:34.736 A:middle
compact the ray buffers.

00:38:35.536 --> 00:38:37.396 A:middle
For every pass we only add

00:38:37.396 --> 00:38:39.256 A:middle
active rays to the next passes

00:38:39.256 --> 00:38:39.726 A:middle
ray buffer.

00:38:40.426 --> 00:38:41.856 A:middle
This adds some overhead, but it

00:38:41.856 --> 00:38:43.166 A:middle
results in the cache lines and

00:38:43.166 --> 00:38:44.136 A:middle
thread groups being fully

00:38:44.136 --> 00:38:45.926 A:middle
utilized so there's less waste

00:38:45.926 --> 00:38:47.566 A:middle
of processing and less bandwidth

00:38:47.566 --> 00:38:48.056 A:middle
required.

00:38:48.746 --> 00:38:50.446 A:middle
It's also important to note that

00:38:50.446 --> 00:38:51.666 A:middle
this can be used for shadow rays

00:38:51.666 --> 00:38:52.286 A:middle
as well.

00:38:52.756 --> 00:38:54.066 A:middle
Some rays will hit surfaces that

00:38:54.066 --> 00:38:55.186 A:middle
are pointing away from a light

00:38:55.436 --> 00:38:56.436 A:middle
or they may hit the background.

00:38:56.546 --> 00:38:57.406 A:middle
So, we won't want to cache

00:38:57.406 --> 00:38:58.776 A:middle
shadow rays for them.

00:38:59.936 --> 00:39:01.966 A:middle
The downside is that because

00:38:59.936 --> 00:39:01.966 A:middle
The downside is that because

00:39:01.966 --> 00:39:03.196 A:middle
we're shuffling ray positions

00:39:03.196 --> 00:39:04.856 A:middle
within the ray buffers, the

00:39:04.856 --> 00:39:06.836 A:middle
indices in our ray buffer no

00:39:06.836 --> 00:39:08.206 A:middle
longer map to constant pixel

00:39:08.206 --> 00:39:08.846 A:middle
locations.

00:39:09.336 --> 00:39:10.256 A:middle
So, we'll need to allocate a

00:39:10.256 --> 00:39:11.546 A:middle
buffer to start tracking pixel

00:39:11.546 --> 00:39:12.876 A:middle
coordinates along with each ray.

00:39:12.876 --> 00:39:15.386 A:middle
Even though we're using extra

00:39:15.386 --> 00:39:17.026 A:middle
buffers, we'll actually be using

00:39:17.026 --> 00:39:18.616 A:middle
much less memory if we factor in

00:39:18.616 --> 00:39:19.726 A:middle
all of the rays that we don't

00:39:19.726 --> 00:39:20.636 A:middle
have to process.

00:39:21.886 --> 00:39:23.976 A:middle
When we're compacting the rays,

00:39:24.316 --> 00:39:25.846 A:middle
we don't want two shaders to try

00:39:25.846 --> 00:39:27.136 A:middle
to add rays to the new ray

00:39:27.136 --> 00:39:28.506 A:middle
buffer at the same location.

00:39:29.296 --> 00:39:30.476 A:middle
Therefore, we need to produce a

00:39:30.476 --> 00:39:32.126 A:middle
unique index into the ray buffer

00:39:32.126 --> 00:39:33.286 A:middle
for every ray that remains

00:39:33.286 --> 00:39:34.916 A:middle
active between passes.

00:39:35.996 --> 00:39:37.406 A:middle
We use an atomic counter to do

00:39:37.406 --> 00:39:37.756 A:middle
this.

00:39:38.536 --> 00:39:39.836 A:middle
Here, the atomic integer

00:39:39.946 --> 00:39:41.446 A:middle
outgoingRayCount contains the

00:39:41.446 --> 00:39:43.036 A:middle
current number of rays in the

00:39:43.036 --> 00:39:43.756 A:middle
new ray buffer.

00:39:45.376 --> 00:39:47.506 A:middle
We use atomic fetch add explicit

00:39:47.506 --> 00:39:48.836 A:middle
to grab the current value of

00:39:48.836 --> 00:39:50.786 A:middle
outgoing ray count and increment

00:39:51.396 --> 00:39:52.606 A:middle
it by one.

00:39:52.606 --> 00:39:54.156 A:middle
Using that value as the index

00:39:54.156 --> 00:39:55.306 A:middle
into the outgoing ray buffer

00:39:55.406 --> 00:39:56.376 A:middle
ensures that we don't get

00:39:56.376 --> 00:39:57.086 A:middle
conflicts.

00:39:57.556 --> 00:39:58.806 A:middle
It has the added benefit of

00:39:58.806 --> 00:39:59.936 A:middle
leaving the number of rays that

00:39:59.936 --> 00:40:02.516 A:middle
remain active in outgoing ray

00:39:59.936 --> 00:40:02.516 A:middle
remain active in outgoing ray

00:40:03.416 --> 00:40:03.556 A:middle
count.

00:40:04.096 --> 00:40:05.446 A:middle
Now, Ray Compaction doesn't help

00:40:05.446 --> 00:40:06.666 A:middle
you much if you can't restrict

00:40:06.666 --> 00:40:07.426 A:middle
the number of threads that

00:40:07.426 --> 00:40:07.906 A:middle
you're launching.

00:40:08.076 --> 00:40:09.476 A:middle
The outgoing ray count buffer we

00:40:09.476 --> 00:40:11.046 A:middle
just produced contains the total

00:40:11.046 --> 00:40:12.806 A:middle
number of active rays in our

00:40:12.806 --> 00:40:13.686 A:middle
outgoing ray buffer.

00:40:14.836 --> 00:40:16.286 A:middle
We can use that to fill out an

00:40:16.356 --> 00:40:17.646 A:middle
MTLDispatch ThreadGroups

00:40:17.686 --> 00:40:19.026 A:middle
IndirectArguments object.

00:40:19.956 --> 00:40:21.266 A:middle
That just specifies launch

00:40:21.266 --> 00:40:22.476 A:middle
dimensions to be used with the

00:40:22.476 --> 00:40:23.026 A:middle
dispatch.

00:40:24.146 --> 00:40:25.836 A:middle
Then, by using IndirectDispatch

00:40:25.836 --> 00:40:27.056 A:middle
with that indirectBuffer object

00:40:27.496 --> 00:40:28.596 A:middle
we can restrict the number of

00:40:28.596 --> 00:40:29.666 A:middle
threads that we're launching to

00:40:29.666 --> 00:40:30.896 A:middle
only process the rays that

00:40:30.896 --> 00:40:31.416 A:middle
remain active.

00:40:31.416 --> 00:40:33.506 A:middle
There's also a version of the

00:40:33.506 --> 00:40:34.436 A:middle
ray intersection function that

00:40:34.466 --> 00:40:34.976 A:middle
corresponds to this.

00:40:35.066 --> 00:40:37.576 A:middle
The important point here is that

00:40:38.266 --> 00:40:40.966 A:middle
we can pass our ray count via a

00:40:40.966 --> 00:40:42.356 A:middle
buffer, so we can feed the

00:40:42.356 --> 00:40:43.626 A:middle
result of our ray compaction

00:40:43.626 --> 00:40:45.216 A:middle
step in as the number of threads

00:40:45.216 --> 00:40:45.796 A:middle
to launch.

00:40:47.596 --> 00:40:49.776 A:middle
After Ray Compaction we get

00:40:49.776 --> 00:40:51.326 A:middle
about a 15 percent performance

00:40:51.326 --> 00:40:52.216 A:middle
gain in this scene.

00:40:52.346 --> 00:40:54.096 A:middle
But of course, your results will

00:40:54.096 --> 00:40:55.616 A:middle
depend on the complexity of the

00:40:55.616 --> 00:40:56.876 A:middle
scene you're using and the

00:40:56.876 --> 00:40:57.926 A:middle
number of ray bounces.

00:40:58.486 --> 00:41:02.036 A:middle
So that covers ray lifetime and

00:40:58.486 --> 00:41:02.036 A:middle
So that covers ray lifetime and

00:41:02.036 --> 00:41:02.396 A:middle
culling.

00:41:03.696 --> 00:41:05.386 A:middle
Now we're going to discuss

00:41:05.386 --> 00:41:07.806 A:middle
debugging your application with

00:41:08.536 --> 00:41:08.706 A:middle
Xcode.

00:41:09.346 --> 00:41:10.496 A:middle
Debugging on the GPU is

00:41:10.496 --> 00:41:12.176 A:middle
notoriously difficult process.

00:41:12.756 --> 00:41:14.126 A:middle
And this is especially true for

00:41:14.126 --> 00:41:14.546 A:middle
Ray Tracing.

00:41:15.346 --> 00:41:16.436 A:middle
Any change you make may get

00:41:16.436 --> 00:41:18.016 A:middle
invoked multiple times per ray

00:41:18.016 --> 00:41:19.286 A:middle
and you might have to write a

00:41:19.286 --> 00:41:20.726 A:middle
lot of code to dump out buffers

00:41:20.726 --> 00:41:22.196 A:middle
and textures for a bunch of

00:41:22.196 --> 00:41:23.046 A:middle
different stages of your

00:41:23.046 --> 00:41:24.676 A:middle
algorithm to get a clue about

00:41:24.676 --> 00:41:25.916 A:middle
where an error was introduced.

00:41:26.736 --> 00:41:28.566 A:middle
Xcode's frame capture tools are

00:41:28.566 --> 00:41:30.226 A:middle
amazing for debugging exactly

00:41:30.226 --> 00:41:31.446 A:middle
these kinds of issues.

00:41:31.896 --> 00:41:32.966 A:middle
It's incredibly powerful and a

00:41:32.966 --> 00:41:33.766 A:middle
real time saver.

00:41:34.746 --> 00:41:36.356 A:middle
So, I'm going to walk you

00:41:36.356 --> 00:41:37.586 A:middle
through debugging a real-world

00:41:37.586 --> 00:41:38.856 A:middle
issue that we hit when we

00:41:38.856 --> 00:41:40.246 A:middle
implemented super sampling in

00:41:40.246 --> 00:41:40.976 A:middle
our ray tracer.

00:41:41.606 --> 00:41:43.256 A:middle
We implemented the ability to

00:41:43.256 --> 00:41:44.776 A:middle
sample a single pixel multiple

00:41:44.776 --> 00:41:46.336 A:middle
times per frame and all of a

00:41:46.336 --> 00:41:47.476 A:middle
sudden, our ray tracer is

00:41:47.476 --> 00:41:48.746 A:middle
producing a blown-out image.

00:41:50.096 --> 00:41:52.356 A:middle
The first step is just to do a

00:41:52.356 --> 00:41:53.386 A:middle
frame capture as your

00:41:53.386 --> 00:41:54.276 A:middle
application is running.

00:41:55.716 --> 00:41:56.756 A:middle
This records the state of the

00:41:56.756 --> 00:41:58.686 A:middle
GPU for every API call and

00:41:58.686 --> 00:41:59.686 A:middle
shader over the course of a

00:41:59.686 --> 00:42:00.046 A:middle
frame.

00:41:59.686 --> 00:42:00.046 A:middle
frame.

00:42:01.076 --> 00:42:03.106 A:middle
By selecting any shader, we can

00:42:03.106 --> 00:42:04.266 A:middle
examine the resources that are

00:42:04.266 --> 00:42:06.206 A:middle
bound to it so we can really

00:42:06.206 --> 00:42:07.716 A:middle
quickly narrow down exactly what

00:42:07.716 --> 00:42:09.176 A:middle
shader's failing by just

00:42:09.176 --> 00:42:10.376 A:middle
selecting all of the shaders

00:42:10.376 --> 00:42:11.346 A:middle
that write to the frame buffer

00:42:11.486 --> 00:42:12.636 A:middle
and examining the frame buffer

00:42:12.636 --> 00:42:13.546 A:middle
contents directly.

00:42:13.956 --> 00:42:15.556 A:middle
So here we can see the first

00:42:15.556 --> 00:42:16.316 A:middle
image is pretty light.

00:42:16.866 --> 00:42:18.006 A:middle
The second image is pretty

00:42:18.006 --> 00:42:18.486 A:middle
washed out.

00:42:18.486 --> 00:42:19.716 A:middle
And the third is almost white.

00:42:20.326 --> 00:42:23.186 A:middle
But here we're going to select

00:42:23.186 --> 00:42:24.166 A:middle
the shader that outputs the

00:42:24.166 --> 00:42:26.206 A:middle
lightest image and we're going

00:42:26.206 --> 00:42:27.526 A:middle
to take a look at the two input

00:42:27.526 --> 00:42:28.426 A:middle
buffers that we used to

00:42:28.466 --> 00:42:29.736 A:middle
calculate the frame buffer.

00:42:30.566 --> 00:42:31.826 A:middle
And the first buffer just

00:42:31.826 --> 00:42:32.956 A:middle
contains the sum of all the

00:42:32.956 --> 00:42:34.736 A:middle
light a ray has accumulated.

00:42:36.796 --> 00:42:38.346 A:middle
The second buffer contains our

00:42:38.346 --> 00:42:38.836 A:middle
new variable.

00:42:38.836 --> 00:42:40.456 A:middle
And that's just the number of

00:42:40.456 --> 00:42:41.506 A:middle
times we've sampled a given

00:42:41.506 --> 00:42:41.816 A:middle
pixel.

00:42:42.786 --> 00:42:43.916 A:middle
Both of these buffers look like

00:42:43.916 --> 00:42:45.386 A:middle
they have valid data in them, so

00:42:45.386 --> 00:42:46.406 A:middle
we'll go directly to the shader

00:42:46.406 --> 00:42:47.456 A:middle
debugger to examine what our

00:42:47.456 --> 00:42:48.476 A:middle
shader is doing with this data.

00:42:49.116 --> 00:42:51.846 A:middle
Our color calculation is just

00:42:51.846 --> 00:42:52.956 A:middle
that some of the luminance for

00:42:52.956 --> 00:42:54.076 A:middle
all the rays that were launched

00:42:54.076 --> 00:42:54.936 A:middle
for a given pixel.

00:42:55.546 --> 00:42:57.246 A:middle
When we only had one ray per

00:42:57.246 --> 00:42:58.676 A:middle
pixel, this worked just fine.

00:42:59.636 --> 00:43:00.586 A:middle
But now, we're failing to

00:42:59.636 --> 00:43:00.586 A:middle
But now, we're failing to

00:43:00.586 --> 00:43:01.566 A:middle
compensate for the fact that

00:43:01.566 --> 00:43:02.896 A:middle
we're sampling multiple times

00:43:02.936 --> 00:43:03.346 A:middle
per pixel.

00:43:03.346 --> 00:43:05.576 A:middle
So, we're going to change that

00:43:05.576 --> 00:43:06.986 A:middle
code in the shader debugger to

00:43:07.126 --> 00:43:08.486 A:middle
divide the total luminance by

00:43:08.486 --> 00:43:09.746 A:middle
the number of input samples.

00:43:10.586 --> 00:43:12.146 A:middle
We reevaluate directly in the

00:43:12.146 --> 00:43:14.176 A:middle
shader debugger and we can

00:43:14.176 --> 00:43:15.266 A:middle
instantly see that our output

00:43:15.266 --> 00:43:16.226 A:middle
image has been fixed.

00:43:16.606 --> 00:43:19.836 A:middle
It's just that easy.

00:43:20.486 --> 00:43:21.666 A:middle
Another issue we hit frequently

00:43:21.666 --> 00:43:22.636 A:middle
was trying to understand the

00:43:22.636 --> 00:43:23.556 A:middle
performance impact of our

00:43:23.556 --> 00:43:24.246 A:middle
changes.

00:43:24.476 --> 00:43:26.776 A:middle
Xcode frame captures tools make

00:43:26.816 --> 00:43:27.886 A:middle
this easy as well.

00:43:29.136 --> 00:43:30.226 A:middle
Here's an example of a struct

00:43:30.226 --> 00:43:31.046 A:middle
that tracks surface

00:43:31.046 --> 00:43:32.366 A:middle
characteristics across ray

00:43:32.366 --> 00:43:33.066 A:middle
bounces.

00:43:33.826 --> 00:43:35.116 A:middle
Not every surface in our scene

00:43:35.116 --> 00:43:36.206 A:middle
uses transparencies.

00:43:36.206 --> 00:43:37.186 A:middle
The final two values,

00:43:37.246 --> 00:43:38.566 A:middle
transmission and index of

00:43:38.566 --> 00:43:40.206 A:middle
refraction, won't be used for

00:43:40.206 --> 00:43:40.986 A:middle
some rays.

00:43:41.566 --> 00:43:43.056 A:middle
But, because we've packed all of

00:43:43.056 --> 00:43:44.546 A:middle
that data into a single struct,

00:43:44.986 --> 00:43:46.406 A:middle
rays that don't hit transparent

00:43:46.406 --> 00:43:47.896 A:middle
surfaces are still going to have

00:43:47.896 --> 00:43:49.676 A:middle
to pay the penalty for reading

00:43:49.676 --> 00:43:50.976 A:middle
and writing those fields out

00:43:51.906 --> 00:43:53.376 A:middle
between passes.

00:43:53.876 --> 00:43:55.896 A:middle
Here, we've refactored the index

00:43:55.896 --> 00:43:57.096 A:middle
of refraction variables into

00:43:57.096 --> 00:43:57.746 A:middle
their own struct.

00:43:58.556 --> 00:44:00.036 A:middle
By separating the structs only

00:43:58.556 --> 00:44:00.036 A:middle
By separating the structs only

00:44:00.036 --> 00:44:01.166 A:middle
rays that hit transparent

00:44:01.166 --> 00:44:02.326 A:middle
surfaces will have to touch the

00:44:02.326 --> 00:44:03.756 A:middle
refraction data.

00:44:06.156 --> 00:44:07.636 A:middle
But we can still do a bit

00:44:07.636 --> 00:44:07.926 A:middle
better.

00:44:08.606 --> 00:44:09.626 A:middle
Now we've changed all of our

00:44:09.626 --> 00:44:11.306 A:middle
variables to half data types to

00:44:11.306 --> 00:44:12.346 A:middle
save even more space.

00:44:13.096 --> 00:44:14.226 A:middle
We've reduced our memory usage

00:44:14.226 --> 00:44:16.236 A:middle
from 40 to 20 bytes, and rays

00:44:16.236 --> 00:44:17.256 A:middle
that don't hit transparent

00:44:17.256 --> 00:44:18.776 A:middle
objects will only need 12 bytes.

00:44:19.326 --> 00:44:21.526 A:middle
So how do we understand the

00:44:21.526 --> 00:44:22.706 A:middle
performance impact of this?

00:44:23.386 --> 00:44:25.666 A:middle
Here we grab GPU traces using

00:44:25.666 --> 00:44:26.726 A:middle
the frame capture tool both

00:44:26.756 --> 00:44:28.306 A:middle
before and after our change.

00:44:29.216 --> 00:44:30.666 A:middle
The most basic version of

00:44:30.666 --> 00:44:31.946 A:middle
performance analysis we can do

00:44:31.946 --> 00:44:33.256 A:middle
takes place at this phase.

00:44:34.036 --> 00:44:35.536 A:middle
By comparing the shader timings

00:44:35.866 --> 00:44:37.056 A:middle
in our before and after

00:44:37.056 --> 00:44:38.976 A:middle
captures, we can isolate shaders

00:44:38.976 --> 00:44:40.076 A:middle
whose performance has changed.

00:44:40.796 --> 00:44:41.906 A:middle
Here, we can see that the shader

00:44:41.906 --> 00:44:43.026 A:middle
that we've labeled sample

00:44:43.026 --> 00:44:45.136 A:middle
surface has gone from 5.5

00:44:45.136 --> 00:44:46.756 A:middle
milliseconds to 4 milliseconds.

00:44:47.396 --> 00:44:48.536 A:middle
That's almost a 30 percent

00:44:48.536 --> 00:44:49.546 A:middle
savings for one of our more

00:44:49.546 --> 00:44:50.516 A:middle
costly shaders.

00:44:51.546 --> 00:44:53.726 A:middle
If we want to quantify exactly

00:44:53.726 --> 00:44:54.926 A:middle
why we're getting a performance

00:44:54.926 --> 00:44:56.836 A:middle
gain, Xcode helpfully displays

00:44:56.836 --> 00:44:57.756 A:middle
the results of all the

00:44:57.756 --> 00:44:58.756 A:middle
performance counters that it

00:44:58.756 --> 00:44:59.846 A:middle
inserts when it does a frame

00:44:59.846 --> 00:45:00.146 A:middle
capture.

00:44:59.846 --> 00:45:00.146 A:middle
capture.

00:45:00.526 --> 00:45:02.176 A:middle
Because we're interested in how

00:45:02.176 --> 00:45:03.626 A:middle
we've affected our memory usage,

00:45:04.386 --> 00:45:05.246 A:middle
we can take a look at the

00:45:05.246 --> 00:45:07.266 A:middle
texture unit statistics and we

00:45:07.266 --> 00:45:08.496 A:middle
see that our average texture

00:45:08.496 --> 00:45:10.096 A:middle
unit stall time has gone down

00:45:10.096 --> 00:45:11.836 A:middle
from 70 percent to 54 percent.

00:45:12.476 --> 00:45:13.686 A:middle
And we've reduced our L2

00:45:13.686 --> 00:45:16.686 A:middle
throughput by almost two-thirds.

00:45:17.506 --> 00:45:18.986 A:middle
Even more helpfully Xcode will

00:45:18.986 --> 00:45:20.336 A:middle
do some analysis of its own and

00:45:20.336 --> 00:45:21.576 A:middle
report potential problems to

00:45:21.576 --> 00:45:21.726 A:middle
you.

00:45:22.246 --> 00:45:23.846 A:middle
Here, it's telling us that our

00:45:23.846 --> 00:45:25.086 A:middle
original version had some real

00:45:25.086 --> 00:45:26.366 A:middle
problems with memory and that

00:45:26.366 --> 00:45:27.476 A:middle
our new version's performing

00:45:27.476 --> 00:45:29.806 A:middle
much better.

00:45:30.456 --> 00:45:31.526 A:middle
One more tip that you may find

00:45:31.526 --> 00:45:33.106 A:middle
useful, is that the compute

00:45:33.106 --> 00:45:34.116 A:middle
pipeline state had some

00:45:34.116 --> 00:45:35.376 A:middle
interesting telemetry as well.

00:45:36.346 --> 00:45:36.616 A:middle
Look at

00:45:36.616 --> 00:45:37.966 A:middle
MaxTotalThreadsForThreadgroup.

00:45:38.356 --> 00:45:39.746 A:middle
This is an indication of the

00:45:39.746 --> 00:45:40.876 A:middle
occupancy of a shader.

00:45:41.576 --> 00:45:42.866 A:middle
You should target 1024 as the

00:45:42.866 --> 00:45:44.346 A:middle
maximum and anything less means

00:45:44.346 --> 00:45:45.386 A:middle
that there may be an occupancy

00:45:45.386 --> 00:45:46.426 A:middle
issue that you can fix.

00:45:46.926 --> 00:45:50.166 A:middle
So that's debugging in Xcode.

00:45:50.706 --> 00:45:51.996 A:middle
It makes developing Ray Tracing

00:45:51.996 --> 00:45:52.896 A:middle
and Global Illumination

00:45:52.896 --> 00:45:54.296 A:middle
algorithms on the Mac platform

00:45:54.296 --> 00:45:55.116 A:middle
incredibly easy.

00:45:55.876 --> 00:45:56.986 A:middle
And now, here's Wayne to give

00:45:56.986 --> 00:45:57.966 A:middle
you a live demo of all of this.

00:45:58.516 --> 00:46:01.056 A:middle
[ Applause ]

00:45:58.516 --> 00:46:01.056 A:middle
[ Applause ]

00:46:01.556 --> 00:46:03.206 A:middle
&gt;&gt; Thanks Matt.

00:46:04.386 --> 00:46:06.086 A:middle
So, you may recognize this scene

00:46:06.176 --> 00:46:07.736 A:middle
from our platform State of the

00:46:07.736 --> 00:46:09.636 A:middle
Union session earlier this week.

00:46:10.826 --> 00:46:12.546 A:middle
To render it here, I'm using a

00:46:12.546 --> 00:46:14.176 A:middle
MacBook Pro along with four

00:46:14.176 --> 00:46:14.606 A:middle
external GPUs.

00:46:14.606 --> 00:46:17.986 A:middle
And everything you can see on

00:46:18.016 --> 00:46:19.386 A:middle
the screen there is being ray

00:46:19.386 --> 00:46:20.546 A:middle
traced in real time.

00:46:21.106 --> 00:46:22.696 A:middle
So, I can just take hold of the

00:46:22.696 --> 00:46:23.706 A:middle
camera and move around the

00:46:23.706 --> 00:46:23.976 A:middle
scene.

00:46:25.216 --> 00:46:26.936 A:middle
So, let's start over here.

00:46:26.936 --> 00:46:29.306 A:middle
You can see these great shadows

00:46:29.306 --> 00:46:30.076 A:middle
that we're getting with Ray

00:46:30.076 --> 00:46:30.616 A:middle
Tracing.

00:46:30.826 --> 00:46:32.386 A:middle
They're hard at the contact

00:46:32.386 --> 00:46:33.836 A:middle
points and they become softer

00:46:33.836 --> 00:46:35.356 A:middle
and softer as the distance to

00:46:35.356 --> 00:46:36.326 A:middle
the ground increases.

00:46:37.736 --> 00:46:40.186 A:middle
And remember, for these shadows

00:46:40.186 --> 00:46:41.666 A:middle
we're firing just one ray per

00:46:41.666 --> 00:46:43.236 A:middle
pixel and then we're using the

00:46:43.236 --> 00:46:44.576 A:middle
Denoiser that Sean was telling

00:46:44.576 --> 00:46:45.786 A:middle
us about to get this great

00:46:45.826 --> 00:46:46.506 A:middle
filtered result.

00:46:47.126 --> 00:46:49.176 A:middle
And this is all calculated

00:46:49.176 --> 00:46:49.816 A:middle
dynamically.

00:46:49.816 --> 00:46:51.136 A:middle
So, I can just take hold of the

00:46:51.136 --> 00:46:52.966 A:middle
light and move it around.

00:46:54.066 --> 00:46:56.096 A:middle
And I can see the effect of that

00:46:56.096 --> 00:46:57.026 A:middle
pretty much immediately.

00:46:57.596 --> 00:47:00.256 A:middle
There's a really great effect

00:46:57.596 --> 00:47:00.256 A:middle
There's a really great effect

00:47:00.256 --> 00:47:01.056 A:middle
going on here too.

00:47:01.056 --> 00:47:02.636 A:middle
If we fly over and look in the

00:47:02.636 --> 00:47:04.346 A:middle
window of the tram here, you can

00:47:04.346 --> 00:47:05.856 A:middle
actually see the reflections of

00:47:05.856 --> 00:47:07.606 A:middle
our shadows, and again, you can

00:47:07.606 --> 00:47:09.126 A:middle
see the shadow moving around as

00:47:09.126 --> 00:47:10.826 A:middle
I take control of the light.

00:47:13.226 --> 00:47:15.326 A:middle
And if we head over to this part

00:47:15.326 --> 00:47:16.296 A:middle
of the scene now, there's a

00:47:16.296 --> 00:47:18.036 A:middle
really great reflection effect

00:47:18.076 --> 00:47:18.656 A:middle
going on here.

00:47:19.306 --> 00:47:21.866 A:middle
So, if we look at the left most

00:47:21.866 --> 00:47:24.276 A:middle
tram you can see the reflection

00:47:24.276 --> 00:47:25.446 A:middle
of the tram behind this.

00:47:26.296 --> 00:47:28.106 A:middle
But you can also see reflections

00:47:28.196 --> 00:47:29.636 A:middle
in the windshield of the tram

00:47:29.636 --> 00:47:30.276 A:middle
behind us.

00:47:30.396 --> 00:47:31.846 A:middle
So, there's reflections within

00:47:31.846 --> 00:47:33.856 A:middle
reflections going on here and we

00:47:33.856 --> 00:47:35.136 A:middle
have to simulate a couple of ray

00:47:35.136 --> 00:47:36.896 A:middle
bounces per pixel to achieve

00:47:37.106 --> 00:47:38.006 A:middle
that effect.

00:47:39.856 --> 00:47:41.226 A:middle
So, I'm going to zoom out here a

00:47:41.226 --> 00:47:41.606 A:middle
bit now.

00:47:41.886 --> 00:47:43.896 A:middle
And of course, in this scene

00:47:43.896 --> 00:47:45.676 A:middle
it's not just the camera and the

00:47:45.676 --> 00:47:46.526 A:middle
lights that can move.

00:47:47.486 --> 00:47:48.636 A:middle
Sean was telling us about

00:47:48.636 --> 00:47:50.086 A:middle
Metal's Two-Level Acceleration

00:47:50.086 --> 00:47:50.806 A:middle
structures earlier.

00:47:51.156 --> 00:47:52.556 A:middle
And we're using those here to

00:47:52.676 --> 00:47:53.926 A:middle
enable the trams to move around

00:47:53.926 --> 00:47:54.226 A:middle
the scene.

00:47:54.846 --> 00:47:57.966 A:middle
What I really want to show you

00:47:57.966 --> 00:47:59.576 A:middle
now though is this fantastic

00:47:59.576 --> 00:48:01.076 A:middle
lighting effect we have going on

00:47:59.576 --> 00:48:01.076 A:middle
lighting effect we have going on

00:48:01.116 --> 00:48:01.656 A:middle
up on the roof.

00:48:01.656 --> 00:48:05.266 A:middle
So, if we focus on the wall on

00:48:05.266 --> 00:48:07.006 A:middle
the right there you can see that

00:48:07.006 --> 00:48:08.486 A:middle
currently it's being lit

00:48:08.626 --> 00:48:10.206 A:middle
primarily by direct sunlight.

00:48:10.866 --> 00:48:13.266 A:middle
But as I take control of the sun

00:48:13.396 --> 00:48:15.636 A:middle
and I rotate it around you can

00:48:15.636 --> 00:48:16.996 A:middle
see the wall falls into shadow

00:48:16.996 --> 00:48:18.756 A:middle
and now it's being lit by this

00:48:18.846 --> 00:48:20.606 A:middle
really great indirect

00:48:20.606 --> 00:48:21.206 A:middle
illumination.

00:48:22.176 --> 00:48:24.336 A:middle
So, what's going on here is

00:48:24.866 --> 00:48:26.116 A:middle
sunlight is hitting the roof on

00:48:26.116 --> 00:48:28.246 A:middle
the left and it's bouncing and

00:48:28.246 --> 00:48:29.246 A:middle
illuminating the wall on the

00:48:29.246 --> 00:48:29.576 A:middle
right.

00:48:29.576 --> 00:48:30.756 A:middle
Giving us this great color

00:48:30.756 --> 00:48:31.476 A:middle
bleeding effect.

00:48:31.956 --> 00:48:35.226 A:middle
And if I continue to rotate the

00:48:35.226 --> 00:48:36.556 A:middle
sun you can see these really

00:48:36.556 --> 00:48:38.026 A:middle
dramatic shadows start to come

00:48:38.026 --> 00:48:39.626 A:middle
in and they travel across the

00:48:39.626 --> 00:48:40.356 A:middle
surface of the roof there.

00:48:41.016 --> 00:48:43.506 A:middle
If I spin the camera around a

00:48:43.506 --> 00:48:44.516 A:middle
bit you can really see the

00:48:44.516 --> 00:48:45.956 A:middle
reflections as well hitting the

00:48:45.956 --> 00:48:47.366 A:middle
roof on the left.

00:48:47.976 --> 00:48:49.246 A:middle
So, this is -- I really like

00:48:49.246 --> 00:48:49.796 A:middle
this shot.

00:48:49.796 --> 00:48:51.636 A:middle
There's a lot of Ray Tracing

00:48:51.636 --> 00:48:53.056 A:middle
effects all going on at the same

00:48:53.056 --> 00:48:53.706 A:middle
time here.

00:48:53.706 --> 00:48:54.686 A:middle
We have the indirect

00:48:54.686 --> 00:48:55.766 A:middle
illumination, we have the

00:48:55.766 --> 00:48:56.696 A:middle
shadows, we have the

00:48:56.696 --> 00:48:57.426 A:middle
reflections.

00:48:58.126 --> 00:48:59.516 A:middle
And it's all being ray traced in

00:48:59.516 --> 00:49:01.666 A:middle
real time with Metal and multi

00:48:59.516 --> 00:49:01.666 A:middle
real time with Metal and multi

00:49:01.666 --> 00:49:01.976 A:middle
GPU.

00:49:02.976 --> 00:49:04.176 A:middle
So, I'm going to switch back to

00:49:04.176 --> 00:49:05.516 A:middle
the keynote now and it's this

00:49:05.516 --> 00:49:07.206 A:middle
multi GPU aspect that I'd like

00:49:07.206 --> 00:49:08.396 A:middle
to talk a bit more about.

00:49:09.516 --> 00:49:16.516 A:middle
[ Applause ]

00:49:17.016 --> 00:49:18.146 A:middle
So, for the demo that we just

00:49:18.146 --> 00:49:20.666 A:middle
saw, the way that we implemented

00:49:21.006 --> 00:49:23.066 A:middle
multi GPU was by dividing the

00:49:23.066 --> 00:49:25.546 A:middle
screen into a set of small tiles

00:49:26.536 --> 00:49:27.676 A:middle
and then we mapped these tiles

00:49:27.676 --> 00:49:29.036 A:middle
onto the different GPUs.

00:49:29.636 --> 00:49:32.396 A:middle
Now in the visualization here

00:49:32.396 --> 00:49:33.826 A:middle
I'm using different colors to

00:49:33.826 --> 00:49:35.066 A:middle
show you how the tiles are

00:49:35.066 --> 00:49:35.716 A:middle
distributed.

00:49:36.256 --> 00:49:38.166 A:middle
So, one GPU renders the tiles in

00:49:38.166 --> 00:49:38.716 A:middle
red.

00:49:39.316 --> 00:49:40.176 A:middle
Another does the tiles in

00:49:40.176 --> 00:49:40.696 A:middle
yellow, and so on.

00:49:40.696 --> 00:49:43.286 A:middle
And after all GPUs are finished,

00:49:43.286 --> 00:49:45.906 A:middle
we just composite those results

00:49:45.906 --> 00:49:47.396 A:middle
together to form our final

00:49:47.396 --> 00:49:47.766 A:middle
image.

00:49:47.766 --> 00:49:50.716 A:middle
So, if we take a step back and

00:49:50.716 --> 00:49:53.186 A:middle
look at what we have here

00:49:53.226 --> 00:49:54.546 A:middle
there's two things that jump

00:49:54.546 --> 00:49:54.826 A:middle
out.

00:49:54.826 --> 00:49:57.806 A:middle
So firstly, in the image on the

00:49:57.806 --> 00:49:59.126 A:middle
left, so the way that we're

00:49:59.126 --> 00:50:00.006 A:middle
assigning tiles to GPUs, it

00:49:59.126 --> 00:50:00.006 A:middle
assigning tiles to GPUs, it

00:50:00.006 --> 00:50:00.716 A:middle
looks a bit strange.

00:50:01.086 --> 00:50:03.766 A:middle
So why are we doing it like

00:50:03.766 --> 00:50:04.156 A:middle
that?

00:50:05.066 --> 00:50:08.136 A:middle
And secondly, for those small

00:50:08.136 --> 00:50:11.056 A:middle
tiles the implication of that is

00:50:11.056 --> 00:50:12.736 A:middle
that each GPU is going to render

00:50:12.736 --> 00:50:14.436 A:middle
a block of pixels there and then

00:50:14.436 --> 00:50:15.336 A:middle
a block of pixels somewhere

00:50:15.336 --> 00:50:15.546 A:middle
else.

00:50:16.476 --> 00:50:17.646 A:middle
And that just feels like it's

00:50:17.646 --> 00:50:19.246 A:middle
going to be bad for things like

00:50:19.246 --> 00:50:21.336 A:middle
ray coherency, cache hit ratios.

00:50:21.336 --> 00:50:22.126 A:middle
All that kind of stuff.

00:50:23.116 --> 00:50:25.036 A:middle
So, let's deal with these in

00:50:27.016 --> 00:50:27.126 A:middle
turn.

00:50:27.326 --> 00:50:30.226 A:middle
So, imagine we have four GPUs.

00:50:30.226 --> 00:50:31.986 A:middle
The simple way to do multi GPU

00:50:31.986 --> 00:50:34.046 A:middle
here is just to split the screen

00:50:34.046 --> 00:50:34.886 A:middle
into quadrants.

00:50:35.826 --> 00:50:38.156 A:middle
Now the issue with that is that

00:50:38.156 --> 00:50:39.506 A:middle
some parts of a scene will be

00:50:39.506 --> 00:50:40.816 A:middle
much easier to render than

00:50:40.816 --> 00:50:41.106 A:middle
others.

00:50:41.986 --> 00:50:43.896 A:middle
So, if we assume that the street

00:50:43.896 --> 00:50:45.226 A:middle
and the building on the left

00:50:45.226 --> 00:50:47.026 A:middle
there are much easier to render

00:50:47.026 --> 00:50:48.266 A:middle
than the tram on the right.

00:50:49.316 --> 00:50:50.946 A:middle
It stands to reason that the red

00:50:50.946 --> 00:50:52.316 A:middle
and yellow GPUs will finish

00:50:52.316 --> 00:50:54.046 A:middle
before the green and purple

00:50:54.046 --> 00:50:54.226 A:middle
GPUs.

00:50:54.226 --> 00:50:57.926 A:middle
Now we can fix this just by

00:50:57.926 --> 00:50:59.116 A:middle
splitting the screen into

00:50:59.116 --> 00:50:59.926 A:middle
smaller tiles.

00:50:59.926 --> 00:51:02.866 A:middle
Then we can split each of those

00:50:59.926 --> 00:51:02.866 A:middle
Then we can split each of those

00:51:02.866 --> 00:51:05.286 A:middle
into smaller tiles and so on.

00:51:05.436 --> 00:51:06.946 A:middle
Until we reach some minimum tile

00:51:06.996 --> 00:51:07.326 A:middle
size.

00:51:07.946 --> 00:51:10.836 A:middle
Now this has the effect of

00:51:10.836 --> 00:51:13.706 A:middle
distributing work really evenly

00:51:13.706 --> 00:51:14.196 A:middle
across the GPUs.

00:51:14.926 --> 00:51:16.456 A:middle
So, if one part of the screen is

00:51:16.456 --> 00:51:17.566 A:middle
particularly difficult to

00:51:17.566 --> 00:51:19.276 A:middle
render, it just doesn't matter,

00:51:19.626 --> 00:51:21.586 A:middle
because every GPU will be

00:51:21.586 --> 00:51:24.026 A:middle
assigned tiles from that part of

00:51:25.056 --> 00:51:25.506 A:middle
the screen.

00:51:25.956 --> 00:51:27.406 A:middle
Now in practice, this regular

00:51:27.406 --> 00:51:29.126 A:middle
tiling pattern that you see here

00:51:29.126 --> 00:51:30.616 A:middle
probably isn't the way to go.

00:51:31.166 --> 00:51:32.506 A:middle
Because you can get cases where

00:51:32.506 --> 00:51:33.886 A:middle
the tiling aligns with the

00:51:33.886 --> 00:51:34.936 A:middle
geometry in your scene.

00:51:36.396 --> 00:51:37.606 A:middle
And so, we randomize a bit.

00:51:38.186 --> 00:51:39.936 A:middle
And I'll give a few more details

00:51:39.936 --> 00:51:40.726 A:middle
on how we're doing that in a

00:51:40.726 --> 00:51:41.126 A:middle
second.

00:51:41.626 --> 00:51:44.606 A:middle
And one of the really

00:51:44.606 --> 00:51:45.826 A:middle
interesting things about this

00:51:45.826 --> 00:51:47.956 A:middle
approach is that the mapping of

00:51:47.956 --> 00:51:50.106 A:middle
tiles to GPUs, it does not

00:51:50.106 --> 00:51:50.616 A:middle
change.

00:51:51.886 --> 00:51:53.716 A:middle
So, the same GPU will process

00:51:53.716 --> 00:51:55.586 A:middle
the same tiles every frame.

00:51:56.316 --> 00:51:57.566 A:middle
And this is great.

00:51:57.626 --> 00:51:59.106 A:middle
So, you can just calculate that

00:51:59.106 --> 00:52:00.666 A:middle
mapping when your application

00:51:59.106 --> 00:52:00.666 A:middle
mapping when your application

00:52:00.666 --> 00:52:02.666 A:middle
initializes or when you resize

00:52:02.666 --> 00:52:04.066 A:middle
the window and that's it.

00:52:04.636 --> 00:52:05.906 A:middle
You don't need to think about

00:52:05.906 --> 00:52:07.946 A:middle
multi GPU load balancing anymore

00:52:07.946 --> 00:52:09.056 A:middle
and there's nothing to monitor.

00:52:09.056 --> 00:52:10.626 A:middle
Nothing to recalculate in your

00:52:10.626 --> 00:52:12.226 A:middle
application's main loop.

00:52:14.176 --> 00:52:17.366 A:middle
So, if we know that small tiles

00:52:17.616 --> 00:52:19.126 A:middle
distribute the work more evenly,

00:52:19.576 --> 00:52:20.626 A:middle
why not just take it to the

00:52:20.626 --> 00:52:22.306 A:middle
extreme and make them a pixel.

00:52:22.946 --> 00:52:25.956 A:middle
So, the problem with that is

00:52:25.956 --> 00:52:27.446 A:middle
that we need to give each GPU

00:52:27.766 --> 00:52:29.356 A:middle
nice coherent blocks of pixels

00:52:29.356 --> 00:52:30.076 A:middle
to be working on.

00:52:31.326 --> 00:52:33.476 A:middle
So, the tradeoff there between

00:52:33.476 --> 00:52:35.276 A:middle
balancing the load evenly and

00:52:35.276 --> 00:52:36.786 A:middle
making sure that each GPU can

00:52:36.786 --> 00:52:38.166 A:middle
run as efficiently as possible.

00:52:38.746 --> 00:52:41.606 A:middle
So, to better understand that

00:52:41.606 --> 00:52:43.276 A:middle
tradeoff we did a simple

00:52:43.276 --> 00:52:43.866 A:middle
experiment.

00:52:44.446 --> 00:52:46.756 A:middle
We took one of the new Mac Pros

00:52:46.756 --> 00:52:49.336 A:middle
with a pair of the Vega II Duo

00:52:49.336 --> 00:52:51.066 A:middle
GPUs, so that's four GPUs in

00:52:51.066 --> 00:52:53.386 A:middle
total, and we tried rendering

00:52:53.386 --> 00:52:54.496 A:middle
the same scene with various

00:52:54.496 --> 00:52:56.146 A:middle
tiles sizes to see how that

00:52:56.146 --> 00:52:57.256 A:middle
effected performance.

00:52:57.476 --> 00:53:00.826 A:middle
Now of course, your mileage may

00:52:57.476 --> 00:53:00.826 A:middle
Now of course, your mileage may

00:53:00.826 --> 00:53:03.756 A:middle
vary here, but what we found is

00:53:03.756 --> 00:53:05.056 A:middle
that the performance window is

00:53:05.056 --> 00:53:06.116 A:middle
actually really wide.

00:53:07.076 --> 00:53:09.566 A:middle
So, efficiency drops off if you

00:53:09.566 --> 00:53:11.486 A:middle
make your tiles very small or if

00:53:11.486 --> 00:53:12.856 A:middle
you make them very, very large.

00:53:13.766 --> 00:53:15.446 A:middle
But anywhere in the middle keeps

00:53:15.446 --> 00:53:16.626 A:middle
us pretty close to peak

00:53:16.626 --> 00:53:17.246 A:middle
performance.

00:53:20.936 --> 00:53:22.386 A:middle
So now we have our tile size

00:53:22.386 --> 00:53:23.966 A:middle
pinned down, what we need to do

00:53:23.966 --> 00:53:25.686 A:middle
next is assign them to the

00:53:25.686 --> 00:53:27.486 A:middle
various GPUs.

00:53:28.196 --> 00:53:30.186 A:middle
Now to do this, we start by

00:53:30.186 --> 00:53:31.936 A:middle
generating a random number for

00:53:31.936 --> 00:53:34.236 A:middle
each tile and then we compare

00:53:34.236 --> 00:53:36.006 A:middle
those random numbers to a set of

00:53:36.006 --> 00:53:36.736 A:middle
thresholds.

00:53:38.036 --> 00:53:39.406 A:middle
And whichever range the random

00:53:39.406 --> 00:53:41.106 A:middle
number lands in, that gives us

00:53:41.106 --> 00:53:43.066 A:middle
the GPU to use for that tile.

00:53:43.506 --> 00:53:46.606 A:middle
So as an example, here, if the

00:53:46.606 --> 00:53:49.026 A:middle
random number is .4, we assign

00:53:49.026 --> 00:53:49.786 A:middle
it to GPU 1.

00:53:50.796 --> 00:53:53.736 A:middle
If it's .55, it goes on GPU 2.

00:53:54.146 --> 00:53:54.886 A:middle
And so on.

00:53:56.236 --> 00:53:58.186 A:middle
Now, once we've done this for

00:53:58.186 --> 00:54:00.406 A:middle
every tile the output is a list

00:53:58.186 --> 00:54:00.406 A:middle
every tile the output is a list

00:54:00.406 --> 00:54:01.876 A:middle
of tiles that we need each GPU

00:54:01.876 --> 00:54:02.266 A:middle
to render.

00:54:03.016 --> 00:54:06.676 A:middle
As you can see down the bottom

00:54:07.226 --> 00:54:08.146 A:middle
there the ranges that we're

00:54:08.146 --> 00:54:10.216 A:middle
using for each GPU are equal.

00:54:11.476 --> 00:54:13.616 A:middle
So, when assigning tiles to GPUs

00:54:13.716 --> 00:54:15.016 A:middle
they are all equally likely to

00:54:15.016 --> 00:54:15.486 A:middle
be chosen.

00:54:16.146 --> 00:54:19.346 A:middle
But in practice, you almost

00:54:19.346 --> 00:54:20.936 A:middle
certainly don't want this.

00:54:20.936 --> 00:54:23.346 A:middle
For example, you might need to

00:54:23.346 --> 00:54:25.536 A:middle
reserve capacity on one of your

00:54:25.536 --> 00:54:27.286 A:middle
GPUs for non-ray tracing tasks

00:54:27.806 --> 00:54:29.736 A:middle
such as denoising or tone

00:54:31.206 --> 00:54:31.366 A:middle
mapping.

00:54:31.916 --> 00:54:33.536 A:middle
Or you might be using GPUs with

00:54:33.536 --> 00:54:34.536 A:middle
different performance.

00:54:34.906 --> 00:54:35.866 A:middle
In which case you'll want to

00:54:35.866 --> 00:54:37.246 A:middle
send more tiles to the more

00:54:37.246 --> 00:54:37.976 A:middle
powerful GPUs.

00:54:39.846 --> 00:54:41.096 A:middle
And you can account for this

00:54:41.346 --> 00:54:43.226 A:middle
really easily by just adjusting

00:54:43.226 --> 00:54:43.676 A:middle
the ranges.

00:54:44.996 --> 00:54:46.416 A:middle
So now if we go ahead and

00:54:46.416 --> 00:54:47.906 A:middle
reassign the same tiles we used

00:54:47.906 --> 00:54:49.946 A:middle
before, you can see here that

00:54:49.946 --> 00:54:51.886 A:middle
now GPU 2 takes on a much

00:54:51.886 --> 00:54:52.886 A:middle
greater share of the work.

00:54:52.886 --> 00:54:57.966 A:middle
Now, for the actual implantation

00:54:57.966 --> 00:54:59.696 A:middle
of this there was a lot of

00:54:59.696 --> 00:55:01.296 A:middle
really useful information in our

00:54:59.696 --> 00:55:01.296 A:middle
really useful information in our

00:55:01.296 --> 00:55:02.696 A:middle
Metal for Pro Apps session

00:55:02.696 --> 00:55:03.466 A:middle
earlier this week.

00:55:03.766 --> 00:55:05.256 A:middle
So, I won't go over that again

00:55:05.256 --> 00:55:05.496 A:middle
here.

00:55:06.086 --> 00:55:08.356 A:middle
But it is definitely useful to

00:55:08.356 --> 00:55:10.016 A:middle
highlight just a couple of areas

00:55:10.106 --> 00:55:11.016 A:middle
that can have a really big

00:55:11.016 --> 00:55:12.286 A:middle
impact on performance.

00:55:12.846 --> 00:55:16.616 A:middle
So firstly, you'll probably want

00:55:16.616 --> 00:55:17.976 A:middle
to composite your tiles together

00:55:17.976 --> 00:55:19.436 A:middle
on the GPU that's driving the

00:55:19.436 --> 00:55:19.896 A:middle
display.

00:55:21.216 --> 00:55:22.886 A:middle
So, it's important to find out

00:55:22.886 --> 00:55:25.056 A:middle
which GPU that is and then work

00:55:25.056 --> 00:55:27.086 A:middle
backwards to figure out how to

00:55:27.086 --> 00:55:28.416 A:middle
get your data there efficiently.

00:55:28.936 --> 00:55:31.326 A:middle
So, if the GPUs are in the same

00:55:31.326 --> 00:55:33.176 A:middle
peer group then you can copy

00:55:33.176 --> 00:55:34.916 A:middle
between them directly using our

00:55:34.916 --> 00:55:36.196 A:middle
new peer group APIs.

00:55:37.186 --> 00:55:38.646 A:middle
Otherwise you'll need to go by

00:55:38.646 --> 00:55:39.216 A:middle
the CPU.

00:55:41.926 --> 00:55:44.476 A:middle
Now secondly, it can often take

00:55:44.476 --> 00:55:46.056 A:middle
a few milliseconds to copy data

00:55:46.056 --> 00:55:48.156 A:middle
between GPUs and we definitely

00:55:48.276 --> 00:55:50.016 A:middle
don't want to block waiting for

00:55:50.016 --> 00:55:51.126 A:middle
those transfers to complete.

00:55:52.356 --> 00:55:54.526 A:middle
So, to give you an example of

00:55:54.526 --> 00:55:56.426 A:middle
how we're dealing with that we

00:55:56.426 --> 00:55:58.256 A:middle
have two GPUs here and we're

00:55:58.256 --> 00:55:59.466 A:middle
using the tiling scheme that I

00:55:59.466 --> 00:56:01.136 A:middle
was just talking about to spread

00:55:59.466 --> 00:56:01.136 A:middle
was just talking about to spread

00:56:01.136 --> 00:56:02.786 A:middle
the rendering across the two

00:56:02.786 --> 00:56:02.956 A:middle
GPUs.

00:56:04.666 --> 00:56:06.876 A:middle
Now in GPU 0 at the top there we

00:56:06.876 --> 00:56:08.066 A:middle
have two queues.

00:56:08.306 --> 00:56:10.066 A:middle
One is just flat out doing

00:56:10.066 --> 00:56:11.146 A:middle
back-to-back Ray Tracing.

00:56:11.876 --> 00:56:13.116 A:middle
And then we have a second queue

00:56:13.606 --> 00:56:15.076 A:middle
that copies the completed tiles

00:56:15.076 --> 00:56:16.976 A:middle
over to GPU 1 asynchronously.

00:56:20.266 --> 00:56:21.956 A:middle
Now, we'll assume that GPU 1 at

00:56:21.956 --> 00:56:23.166 A:middle
the bottom there is the one

00:56:23.166 --> 00:56:24.206 A:middle
that's driving our display.

00:56:24.896 --> 00:56:26.246 A:middle
And here things are a bit

00:56:26.246 --> 00:56:26.596 A:middle
different.

00:56:27.086 --> 00:56:30.626 A:middle
This GPU is also Ray Tracing

00:56:30.746 --> 00:56:32.996 A:middle
part of frame 0, but we can't go

00:56:32.996 --> 00:56:34.596 A:middle
ahead and present that frame

00:56:35.076 --> 00:56:36.746 A:middle
until the rest of our tiles have

00:56:36.746 --> 00:56:37.936 A:middle
been copied over from the other

00:56:37.936 --> 00:56:38.476 A:middle
GPU.

00:56:39.596 --> 00:56:42.076 A:middle
So rather than wait, we just

00:56:42.076 --> 00:56:43.226 A:middle
start work on the next frame.

00:56:44.716 --> 00:56:46.126 A:middle
And then a bit later on when our

00:56:46.126 --> 00:56:47.996 A:middle
tiles arrive from the other GPU,

00:56:48.836 --> 00:56:50.186 A:middle
that's when we go ahead and

00:56:50.186 --> 00:56:51.386 A:middle
composite everything together.

00:56:52.716 --> 00:56:53.906 A:middle
So, I'll show you that one more

00:56:53.906 --> 00:56:54.286 A:middle
time here.

00:56:54.286 --> 00:56:57.396 A:middle
So, you can see that we end up

00:56:57.396 --> 00:56:59.316 A:middle
in this steady state where we

00:56:59.316 --> 00:57:01.146 A:middle
render frame N and then we

00:56:59.316 --> 00:57:01.146 A:middle
render frame N and then we

00:57:01.146 --> 00:57:02.756 A:middle
composite frame N minus 1.

00:57:04.376 --> 00:57:06.326 A:middle
So essentially, what we're doing

00:57:06.326 --> 00:57:07.656 A:middle
here is latency hiding.

00:57:08.796 --> 00:57:10.186 A:middle
And this together with the

00:57:10.186 --> 00:57:11.626 A:middle
tiling scheme I was showing you

00:57:11.626 --> 00:57:13.196 A:middle
to load balance between the

00:57:13.596 --> 00:57:15.236 A:middle
GPUs, this is enabling us to

00:57:15.236 --> 00:57:16.796 A:middle
achieve really great performance

00:57:16.796 --> 00:57:18.526 A:middle
for our Ray Tracing workloads on

00:57:18.526 --> 00:57:19.886 A:middle
our multi GPU systems.

00:57:20.396 --> 00:57:23.186 A:middle
And with that, we come to the

00:57:23.186 --> 00:57:23.796 A:middle
end of the talk.

00:57:24.926 --> 00:57:26.896 A:middle
We began with a quick refresher

00:57:26.896 --> 00:57:28.286 A:middle
of how Ray Tracing works in

00:57:28.286 --> 00:57:30.696 A:middle
Metal and then we focused on a

00:57:30.756 --> 00:57:31.696 A:middle
few features of the

00:57:31.696 --> 00:57:33.536 A:middle
MPSRayIntersector that are there

00:57:33.616 --> 00:57:34.846 A:middle
to really help with dynamic

00:57:34.846 --> 00:57:35.376 A:middle
scenes.

00:57:35.796 --> 00:57:36.886 A:middle
So that's the Two-Level

00:57:36.886 --> 00:57:38.886 A:middle
Acceleration Structures along

00:57:38.886 --> 00:57:40.226 A:middle
with our GPU Accelerated

00:57:40.226 --> 00:57:41.766 A:middle
Rebuilds and Refitting.

00:57:42.376 --> 00:57:45.216 A:middle
We also introduced the new Metal

00:57:45.216 --> 00:57:45.656 A:middle
Denoiser.

00:57:45.786 --> 00:57:48.026 A:middle
And then we talked through a few

00:57:48.026 --> 00:57:49.716 A:middle
Ray Tracing use cases such as

00:57:49.716 --> 00:57:51.826 A:middle
Shadows, Ambient Occlusion, and

00:57:51.826 --> 00:57:52.716 A:middle
Global Illumination.

00:57:53.716 --> 00:57:55.806 A:middle
When then showed you how to

00:57:55.806 --> 00:57:57.736 A:middle
debug and profile Ray Tracing

00:57:57.736 --> 00:57:58.866 A:middle
workloads using Xcode.

00:57:58.866 --> 00:58:00.856 A:middle
And then, we finished by talking

00:57:58.866 --> 00:58:00.856 A:middle
And then, we finished by talking

00:58:00.856 --> 00:58:02.946 A:middle
about how to take advantage of

00:58:02.946 --> 00:58:05.086 A:middle
multiple GPUs in your Ray

00:58:05.086 --> 00:58:06.136 A:middle
Tracing applications.

00:58:06.166 --> 00:58:08.026 A:middle
Now, for more information be

00:58:08.026 --> 00:58:08.606 A:middle
sure to visit

00:58:08.606 --> 00:58:10.996 A:middle
developer.apple.com and there

00:58:10.996 --> 00:58:12.666 A:middle
you'll also find a new sample

00:58:12.666 --> 00:58:13.646 A:middle
demonstrating some of the

00:58:13.646 --> 00:58:14.826 A:middle
features that we've talked about

00:58:14.826 --> 00:58:15.046 A:middle
today.

00:58:16.066 --> 00:58:17.926 A:middle
If you're new to Ray Tracing be

00:58:18.226 --> 00:58:19.506 A:middle
sure to check out our talk from

00:58:19.506 --> 00:58:20.236 A:middle
last year.

00:58:20.586 --> 00:58:21.926 A:middle
And finally, we have our lab

00:58:21.926 --> 00:58:23.336 A:middle
session coming up next at 12.

00:58:23.446 --> 00:58:24.886 A:middle
So, I hope you can join us for

00:58:24.886 --> 00:58:24.976 A:middle
that.

00:58:26.366 --> 00:58:27.456 A:middle
So, thank you all for coming and

00:58:27.456 --> 00:58:28.796 A:middle
I'll see you in the lab shortly.

00:58:29.016 --> 00:58:31.000 A:middle
[ Applause ]
