WEBVTT

00:00:00.506 --> 00:00:05.500 A:middle
[ Music ]

00:00:10.516 --> 00:00:13.566 A:middle
[ Applause ]

00:00:14.066 --> 00:00:15.196 A:middle
&gt;&gt; Lionel Lemarie: Hi, folks.

00:00:16.146 --> 00:00:17.296 A:middle
Welcome to our Metal session.

00:00:18.096 --> 00:00:18.996 A:middle
I'm Lionel.

00:00:19.076 --> 00:00:20.386 A:middle
I'm in the GPU software

00:00:20.386 --> 00:00:21.766 A:middle
performance team here at Apple.

00:00:22.736 --> 00:00:25.546 A:middle
And with my friends Max and

00:00:25.546 --> 00:00:27.066 A:middle
Sarah, we'll be guiding you

00:00:27.066 --> 00:00:29.056 A:middle
through how to bring your OpenGL

00:00:29.056 --> 00:00:29.636 A:middle
app to Metal.

00:00:30.326 --> 00:00:33.496 A:middle
So last year we announced that

00:00:33.606 --> 00:00:36.936 A:middle
OpenGL, OpenGL ES, and OpenCL

00:00:37.056 --> 00:00:37.966 A:middle
are deprecated.

00:00:38.976 --> 00:00:39.926 A:middle
They will continue to be

00:00:39.926 --> 00:00:43.436 A:middle
supported in iOS 13 and macOS

00:00:43.436 --> 00:00:46.496 A:middle
Catalina, but now is the time to

00:00:46.496 --> 00:00:46.746 A:middle
move.

00:00:47.926 --> 00:00:49.476 A:middle
New projects should target Metal

00:00:49.476 --> 00:00:50.436 A:middle
from their inception.

00:00:50.816 --> 00:00:52.496 A:middle
But if you have an OpenGL app

00:00:52.826 --> 00:00:54.176 A:middle
that you want to port to Metal,

00:00:54.716 --> 00:00:57.696 A:middle
you've come to the right place.

00:00:58.266 --> 00:00:59.836 A:middle
So we first introduced Metal in

00:00:59.936 --> 00:01:03.266 A:middle
2014 as our new low-overhead,

00:00:59.936 --> 00:01:03.266 A:middle
2014 as our new low-overhead,

00:01:03.546 --> 00:01:04.635 A:middle
high-efficiency,

00:01:04.926 --> 00:01:06.976 A:middle
high-performance GPU programming

00:01:06.976 --> 00:01:07.266 A:middle
API.

00:01:07.726 --> 00:01:10.936 A:middle
Over the past five years,

00:01:11.386 --> 00:01:13.726 A:middle
Apple's core frameworks have

00:01:13.726 --> 00:01:15.706 A:middle
adopted Metal and they're

00:01:15.706 --> 00:01:17.146 A:middle
getting really great results.

00:01:17.586 --> 00:01:19.306 A:middle
If your application is built on

00:01:19.306 --> 00:01:21.216 A:middle
top of layers like SpriteKit,

00:01:21.546 --> 00:01:23.846 A:middle
SceneKit, RealityKit, Core

00:01:23.846 --> 00:01:25.616 A:middle
Image, Core Animation, then

00:01:25.616 --> 00:01:26.666 A:middle
you're already using Metal.

00:01:28.796 --> 00:01:30.326 A:middle
We've also been working closely

00:01:30.326 --> 00:01:31.986 A:middle
with vendors on engines like

00:01:31.986 --> 00:01:34.036 A:middle
Unity, Unreal Engine 4, and

00:01:34.036 --> 00:01:36.446 A:middle
Lumberyard to really take

00:01:36.446 --> 00:01:37.326 A:middle
advantage of Metal.

00:01:37.836 --> 00:01:38.846 A:middle
If you're using one of these

00:01:38.846 --> 00:01:41.556 A:middle
engines, you're already up to

00:01:41.556 --> 00:01:41.836 A:middle
speed.

00:01:45.316 --> 00:01:47.656 A:middle
But if you've built your own

00:01:47.656 --> 00:01:49.656 A:middle
renderer, then Metal gives you a

00:01:49.656 --> 00:01:50.946 A:middle
lot of great benefits.

00:01:51.926 --> 00:01:54.036 A:middle
Metal combines the graphics of

00:01:54.036 --> 00:01:56.376 A:middle
OpenGL and compute of OpenCL

00:01:56.516 --> 00:01:57.816 A:middle
into a unified API.

00:01:59.336 --> 00:02:01.436 A:middle
It allows you to use multithread

00:01:59.336 --> 00:02:01.436 A:middle
It allows you to use multithread

00:02:01.436 --> 00:02:02.936 A:middle
rendering in your application.

00:02:04.136 --> 00:02:05.766 A:middle
Whenever there are CPU

00:02:05.766 --> 00:02:07.226 A:middle
operations that need to take

00:02:07.226 --> 00:02:09.096 A:middle
place that are expensive, we

00:02:09.096 --> 00:02:10.366 A:middle
made sure that they happen as

00:02:10.366 --> 00:02:11.876 A:middle
infrequently as possible to

00:02:11.876 --> 00:02:13.786 A:middle
reduce overhead during your

00:02:13.786 --> 00:02:14.616 A:middle
app's execution.

00:02:16.666 --> 00:02:18.746 A:middle
Metal's shading language is C++

00:02:18.796 --> 00:02:20.756 A:middle
based and all the shaders used

00:02:20.756 --> 00:02:23.036 A:middle
in your application can be

00:02:23.036 --> 00:02:25.176 A:middle
precompiled, making it easier to

00:02:25.176 --> 00:02:27.586 A:middle
have a wide variety of material

00:02:27.586 --> 00:02:28.556 A:middle
shaders, for example.

00:02:29.066 --> 00:02:32.056 A:middle
And last but not least, we have

00:02:32.056 --> 00:02:33.786 A:middle
a full suite of debugging and

00:02:33.786 --> 00:02:35.736 A:middle
optimization tools built right

00:02:35.736 --> 00:02:36.426 A:middle
into Xcode.

00:02:37.936 --> 00:02:39.316 A:middle
So once you have ported to

00:02:39.316 --> 00:02:40.936 A:middle
Metal, you have full support to

00:02:40.936 --> 00:02:42.366 A:middle
make your application even

00:02:42.366 --> 00:02:42.656 A:middle
better.

00:02:43.786 --> 00:02:44.506 A:middle
So let's dive in.

00:02:45.036 --> 00:02:46.826 A:middle
In this session we'll take a

00:02:46.826 --> 00:02:48.046 A:middle
look at the different steps

00:02:48.046 --> 00:02:51.376 A:middle
involved in migrating from GL

00:02:51.376 --> 00:02:52.906 A:middle
into Metal, and we'll do that by

00:02:52.906 --> 00:02:55.556 A:middle
comparing a typical GL app to a

00:02:55.656 --> 00:02:57.286 A:middle
Metal app.

00:02:57.706 --> 00:03:00.076 A:middle
As an overview, let's quickly

00:02:57.706 --> 00:03:00.076 A:middle
As an overview, let's quickly

00:03:00.736 --> 00:03:02.836 A:middle
look through the steps of our GL

00:03:02.836 --> 00:03:03.036 A:middle
app.

00:03:03.996 --> 00:03:06.686 A:middle
First, you set up a window that

00:03:06.686 --> 00:03:07.656 A:middle
you'll use for rendering.

00:03:08.326 --> 00:03:09.716 A:middle
Then you create your resources

00:03:09.716 --> 00:03:11.066 A:middle
like buffers, textures,

00:03:11.146 --> 00:03:11.806 A:middle
samplers.

00:03:12.536 --> 00:03:13.866 A:middle
You implement all your shaders

00:03:14.146 --> 00:03:15.276 A:middle
written in GLSL.

00:03:16.466 --> 00:03:17.726 A:middle
Before you can render anything

00:03:17.726 --> 00:03:19.126 A:middle
in GL, you may have to create

00:03:19.126 --> 00:03:20.746 A:middle
certain object states, such as

00:03:20.746 --> 00:03:22.216 A:middle
GL programs, GL frame buffer

00:03:22.216 --> 00:03:24.736 A:middle
objects, vertex array objects.

00:03:25.976 --> 00:03:28.026 A:middle
So once you've initialized your

00:03:28.106 --> 00:03:30.416 A:middle
resources, the render loop

00:03:30.416 --> 00:03:32.646 A:middle
starts and you draw your frames.

00:03:33.356 --> 00:03:35.206 A:middle
For each frame, you start by

00:03:35.206 --> 00:03:38.046 A:middle
updating your resources, bind a

00:03:38.046 --> 00:03:40.346 A:middle
specific frame buffer, set the

00:03:40.346 --> 00:03:41.996 A:middle
graphic state, and make your

00:03:41.996 --> 00:03:42.526 A:middle
draw calls.

00:03:43.536 --> 00:03:44.756 A:middle
You repeat this process for each

00:03:44.756 --> 00:03:46.156 A:middle
frame buffer you have.

00:03:46.416 --> 00:03:47.816 A:middle
You may have shadow maps, a

00:03:47.816 --> 00:03:49.026 A:middle
lighting pass, some

00:03:49.026 --> 00:03:49.906 A:middle
post-processing.

00:03:50.486 --> 00:03:52.246 A:middle
So potentially quite a few

00:03:52.666 --> 00:03:53.396 A:middle
render passes.

00:03:53.936 --> 00:03:56.696 A:middle
And then finally, you present

00:03:57.096 --> 00:03:58.846 A:middle
the final rendered image.

00:03:59.466 --> 00:04:00.376 A:middle
It's pretty easy.

00:03:59.466 --> 00:04:00.376 A:middle
It's pretty easy.

00:04:01.436 --> 00:04:02.646 A:middle
And as you can see, the Metal

00:04:02.646 --> 00:04:04.226 A:middle
flow looks very similar.

00:04:04.976 --> 00:04:06.656 A:middle
We updated some of the original

00:04:06.656 --> 00:04:08.616 A:middle
concepts and introduced a few

00:04:08.616 --> 00:04:09.216 A:middle
new things.

00:04:09.446 --> 00:04:12.066 A:middle
But overall, the flow is much

00:04:12.066 --> 00:04:12.416 A:middle
the same.

00:04:12.626 --> 00:04:13.936 A:middle
It's not a complete rewrite of

00:04:13.936 --> 00:04:17.046 A:middle
the engine; it works in the same

00:04:17.046 --> 00:04:17.305 A:middle
manner.

00:04:18.995 --> 00:04:21.625 A:middle
So we will reintroduce the new

00:04:21.625 --> 00:04:23.366 A:middle
concepts while drawing parallels

00:04:23.366 --> 00:04:26.216 A:middle
between GL and Metal, comparing

00:04:26.216 --> 00:04:28.206 A:middle
and contrasting the two API's to

00:04:28.206 --> 00:04:29.786 A:middle
help you successfully make the

00:04:29.786 --> 00:04:30.276 A:middle
transition.

00:04:30.846 --> 00:04:34.436 A:middle
When you're walking through any

00:04:34.436 --> 00:04:36.496 A:middle
tutorial on graphics, then the

00:04:36.566 --> 00:04:39.396 A:middle
first thing you learn is how to

00:04:39.636 --> 00:04:41.586 A:middle
create and draw to a window.

00:04:42.476 --> 00:04:43.496 A:middle
So let's start with the window

00:04:43.496 --> 00:04:44.046 A:middle
subsystem.

00:04:44.426 --> 00:04:45.726 A:middle
Both GL and Metal have this

00:04:45.726 --> 00:04:47.816 A:middle
concept, but it's accomplished a

00:04:47.816 --> 00:04:48.716 A:middle
little differently.

00:04:49.316 --> 00:04:52.226 A:middle
The application is required to

00:04:52.226 --> 00:04:53.456 A:middle
set up and present a drawing

00:04:53.456 --> 00:04:54.006 A:middle
surface.

00:04:54.076 --> 00:04:55.576 A:middle
And view and view delegates

00:04:55.606 --> 00:04:57.396 A:middle
manage the interface between the

00:04:57.396 --> 00:04:59.286 A:middle
API and the underlying window

00:04:59.286 --> 00:04:59.636 A:middle
system.

00:04:59.636 --> 00:05:02.726 A:middle
You might be using these

00:04:59.636 --> 00:05:02.726 A:middle
You might be using these

00:05:02.726 --> 00:05:04.786 A:middle
frameworks to manage your GL

00:05:04.786 --> 00:05:06.196 A:middle
views, so we have equivalent

00:05:06.246 --> 00:05:07.336 A:middle
frameworks in Metal.

00:05:08.466 --> 00:05:11.606 A:middle
NSOpenGLView and GLKView map to

00:05:11.606 --> 00:05:12.366 A:middle
MTKView.

00:05:13.156 --> 00:05:14.306 A:middle
And if you are using Core

00:05:14.306 --> 00:05:15.866 A:middle
Animation in your application

00:05:15.866 --> 00:05:17.636 A:middle
with the EAGLLayer, then there's

00:05:17.636 --> 00:05:19.416 A:middle
an equivalent CAMetalLayer.

00:05:19.416 --> 00:05:23.086 A:middle
As an example, let's say you are

00:05:23.086 --> 00:05:24.266 A:middle
using GLKView.

00:05:25.566 --> 00:05:27.386 A:middle
It has a single entry point with

00:05:27.386 --> 00:05:27.976 A:middle
the draw rate.

00:05:28.336 --> 00:05:29.646 A:middle
So you need it to check if the

00:05:29.646 --> 00:05:31.366 A:middle
resolution of your target is

00:05:31.366 --> 00:05:32.876 A:middle
unchanged since the last frame,

00:05:32.996 --> 00:05:34.616 A:middle
update your render target sizes

00:05:34.876 --> 00:05:36.626 A:middle
as needed, right from within the

00:05:36.626 --> 00:05:37.136 A:middle
render loop.

00:05:38.496 --> 00:05:40.456 A:middle
In MetalKit, it's a bit updated.

00:05:40.456 --> 00:05:41.686 A:middle
There's a separate function for

00:05:41.686 --> 00:05:44.706 A:middle
whenever the drawable needs to

00:05:44.706 --> 00:05:45.806 A:middle
change, such as when you're

00:05:45.806 --> 00:05:47.606 A:middle
rotating the screen or resizing

00:05:47.606 --> 00:05:48.136 A:middle
your window.

00:05:48.456 --> 00:05:49.876 A:middle
So you don't need to check if

00:05:49.876 --> 00:05:51.036 A:middle
your resources need to be

00:05:51.036 --> 00:05:54.076 A:middle
reallocated inside your draw

00:05:54.076 --> 00:05:55.646 A:middle
function; it's dedicated to

00:05:55.646 --> 00:05:55.956 A:middle
render code.

00:05:59.276 --> 00:06:00.396 A:middle
If you need additional

00:05:59.276 --> 00:06:00.396 A:middle
If you need additional

00:06:00.396 --> 00:06:02.236 A:middle
flexibility, we provide the

00:06:02.286 --> 00:06:05.556 A:middle
CAMetalLayer, which you use as

00:06:05.596 --> 00:06:07.466 A:middle
the backing layer for your view.

00:06:08.876 --> 00:06:11.216 A:middle
While the CAEAGLLayer defined

00:06:11.216 --> 00:06:12.576 A:middle
the properties of your drawable

00:06:12.656 --> 00:06:15.636 A:middle
such as its color format, the

00:06:15.636 --> 00:06:18.186 A:middle
CAMetalLayer allows you to set

00:06:18.186 --> 00:06:20.616 A:middle
up your drawable size, pixel

00:06:20.616 --> 00:06:22.176 A:middle
format, color space, and more.

00:06:23.146 --> 00:06:25.056 A:middle
Importantly, the CAMetalLayer

00:06:25.056 --> 00:06:28.016 A:middle
maintains a pool of textures and

00:06:28.016 --> 00:06:29.646 A:middle
you call next drawable to get

00:06:29.646 --> 00:06:30.796 A:middle
the drawable to render your

00:06:30.796 --> 00:06:31.206 A:middle
frame to.

00:06:31.586 --> 00:06:32.846 A:middle
It's an important concept that

00:06:32.846 --> 00:06:34.646 A:middle
we'll revisit in a short while

00:06:34.896 --> 00:06:37.876 A:middle
when it's time to present.

00:06:37.976 --> 00:06:38.986 A:middle
So now we have a window.

00:06:39.546 --> 00:06:42.066 A:middle
Next we're going to introduce

00:06:42.066 --> 00:06:43.286 A:middle
some new concepts in Metal.

00:06:43.536 --> 00:06:45.006 A:middle
So the command queues, command

00:06:45.006 --> 00:06:46.396 A:middle
buffers, command encoders.

00:06:46.976 --> 00:06:48.896 A:middle
These objects work together in

00:06:48.896 --> 00:06:50.626 A:middle
Metal to submit work to the GPU.

00:06:51.436 --> 00:06:52.616 A:middle
They're new because the

00:06:52.616 --> 00:06:55.056 A:middle
underlying glContexts managed

00:06:55.166 --> 00:06:56.366 A:middle
the submission for you.

00:06:56.366 --> 00:07:02.096 A:middle
GL is an implicit API, meaning

00:06:56.366 --> 00:07:02.096 A:middle
GL is an implicit API, meaning

00:07:02.096 --> 00:07:03.596 A:middle
that there is no code that tells

00:07:03.596 --> 00:07:06.406 A:middle
GL when to schedule the work.

00:07:06.676 --> 00:07:08.126 A:middle
As a developer, you have very

00:07:08.126 --> 00:07:09.626 A:middle
little control about when

00:07:09.626 --> 00:07:11.586 A:middle
graphics work really happens,

00:07:11.746 --> 00:07:13.376 A:middle
such as when shaders are

00:07:13.376 --> 00:07:15.436 A:middle
compiled, when resource storage

00:07:15.436 --> 00:07:18.236 A:middle
is allocated, when validation

00:07:18.236 --> 00:07:20.366 A:middle
occurs, or when work is actually

00:07:20.366 --> 00:07:21.576 A:middle
submitted to the GPU.

00:07:22.106 --> 00:07:24.106 A:middle
The glContext is a big

00:07:24.106 --> 00:07:25.026 A:middle
[state] machine, and a

00:07:25.026 --> 00:07:26.346 A:middle
typical workflow would look like

00:07:26.346 --> 00:07:26.656 A:middle
this.

00:07:27.306 --> 00:07:28.886 A:middle
Your application creates a

00:07:28.886 --> 00:07:31.056 A:middle
glContext, sets it on the

00:07:31.126 --> 00:07:32.926 A:middle
thread, and then calls arbitrary

00:07:32.926 --> 00:07:33.676 A:middle
GL comments.

00:07:34.276 --> 00:07:35.556 A:middle
The comments are recorded by the

00:07:35.586 --> 00:07:37.106 A:middle
context under the hood and would

00:07:37.106 --> 00:07:38.826 A:middle
get executed at some point in

00:07:38.826 --> 00:07:39.056 A:middle
time.

00:07:39.846 --> 00:07:40.966 A:middle
Let's take a closer look to see

00:07:40.966 --> 00:07:41.866 A:middle
what actually goes on.

00:07:43.186 --> 00:07:46.056 A:middle
Say your application just send

00:07:46.056 --> 00:07:47.856 A:middle
GL these calls, a few state

00:07:47.856 --> 00:07:49.356 A:middle
changes, a few draw calls.

00:07:50.096 --> 00:07:51.236 A:middle
In a perfect scenario, the

00:07:51.236 --> 00:07:52.686 A:middle
context would translate this

00:07:52.966 --> 00:07:54.676 A:middle
into GPU comments to fill up an

00:07:54.676 --> 00:07:55.726 A:middle
internal buffer.

00:07:56.126 --> 00:07:57.436 A:middle
And then when it's full, it

00:07:57.436 --> 00:07:58.786 A:middle
would send it to the GPU.

00:07:59.566 --> 00:08:02.276 A:middle
If you insert a glFlush to

00:07:59.566 --> 00:08:02.276 A:middle
If you insert a glFlush to

00:08:02.276 --> 00:08:03.856 A:middle
enforce execution, you know for

00:08:03.856 --> 00:08:05.426 A:middle
sure they'll be kicked off by

00:08:05.426 --> 00:08:05.876 A:middle
that point.

00:08:06.456 --> 00:08:07.606 A:middle
But actually, the GPU could

00:08:07.606 --> 00:08:09.186 A:middle
start execution at any point

00:08:09.186 --> 00:08:09.626 A:middle
beforehand.

00:08:10.706 --> 00:08:11.116 A:middle
Alright.

00:08:11.116 --> 00:08:12.766 A:middle
So, for example, if we change

00:08:12.766 --> 00:08:14.376 A:middle
one draw call introducing every

00:08:14.376 --> 00:08:16.356 A:middle
dependency, suddenly execution

00:08:16.356 --> 00:08:18.306 A:middle
is kicked off at that point and

00:08:18.306 --> 00:08:19.546 A:middle
you could experience massive

00:08:19.546 --> 00:08:20.036 A:middle
stalls.

00:08:21.476 --> 00:08:22.686 A:middle
So, again, when does work

00:08:22.686 --> 00:08:23.896 A:middle
actually get submitted?

00:08:23.896 --> 00:08:25.386 A:middle
It depends.

00:08:25.686 --> 00:08:26.666 A:middle
And that was one of the

00:08:26.666 --> 00:08:28.956 A:middle
downsides of OpenGL -- wasn't

00:08:28.956 --> 00:08:30.946 A:middle
consistent in performance.

00:08:31.456 --> 00:08:33.366 A:middle
Any one small change could force

00:08:33.366 --> 00:08:35.676 A:middle
you down a bad path.

00:08:36.265 --> 00:08:37.916 A:middle
Metal, on the other hand, is an

00:08:37.916 --> 00:08:39.785 A:middle
explicit API, meaning the

00:08:39.785 --> 00:08:41.256 A:middle
application gets to decide

00:08:41.256 --> 00:08:43.905 A:middle
exactly what work goes to the

00:08:43.986 --> 00:08:46.856 A:middle
GPU and when.

00:08:47.576 --> 00:08:49.066 A:middle
Metal splits the concept of a

00:08:49.066 --> 00:08:51.856 A:middle
glContext into a collection of

00:08:51.856 --> 00:08:53.136 A:middle
internal working objects.

00:08:54.026 --> 00:08:55.996 A:middle
The first object an app creates

00:08:56.766 --> 00:08:59.646 A:middle
is a Metal device object, which

00:08:59.646 --> 00:09:00.806 A:middle
is just an abstract

00:08:59.646 --> 00:09:00.806 A:middle
is just an abstract

00:09:01.296 --> 00:09:02.676 A:middle
representation of the GPU.

00:09:03.276 --> 00:09:05.666 A:middle
Then it creates a key object

00:09:05.666 --> 00:09:07.006 A:middle
called a Metal command queue.

00:09:07.656 --> 00:09:08.696 A:middle
The Metal command queue

00:09:08.696 --> 00:09:11.426 A:middle
maintains the order of commands

00:09:11.546 --> 00:09:13.556 A:middle
sent to the GPU by allocating

00:09:13.906 --> 00:09:15.016 A:middle
command buffers to fill.

00:09:15.566 --> 00:09:18.596 A:middle
And a command buffer is simply a

00:09:18.596 --> 00:09:19.916 A:middle
list of GPU commands your app

00:09:19.976 --> 00:09:21.606 A:middle
will fill to send to the GPU for

00:09:21.606 --> 00:09:22.106 A:middle
execution.

00:09:22.996 --> 00:09:24.286 A:middle
So we saw this command buffer

00:09:24.286 --> 00:09:26.086 A:middle
concept in GL -- in the GL

00:09:26.086 --> 00:09:27.126 A:middle
example we just studied.

00:09:28.156 --> 00:09:29.536 A:middle
Let's work with that command

00:09:29.536 --> 00:09:32.746 A:middle
buffer from this point on.

00:09:33.066 --> 00:09:34.406 A:middle
But an app doesn't write the

00:09:34.406 --> 00:09:35.976 A:middle
commands directly to the command

00:09:35.976 --> 00:09:38.856 A:middle
buffer; instead, it creates a

00:09:38.856 --> 00:09:40.016 A:middle
Metal command encoder.

00:09:40.886 --> 00:09:42.096 A:middle
Let's look at the main three

00:09:42.096 --> 00:09:43.356 A:middle
types of encoders.

00:09:44.406 --> 00:09:46.236 A:middle
First one we'll use will be

00:09:46.236 --> 00:09:48.206 A:middle
filled with blit commands that

00:09:48.206 --> 00:09:49.906 A:middle
are used to copy resources

00:09:49.906 --> 00:09:50.216 A:middle
around.

00:09:50.816 --> 00:09:53.816 A:middle
The command encoder translates

00:09:53.866 --> 00:09:56.236 A:middle
API codes into GPU instructions

00:09:56.666 --> 00:09:57.876 A:middle
and then writes them to the

00:09:57.876 --> 00:09:58.476 A:middle
command buffer.

00:09:59.286 --> 00:10:00.596 A:middle
After a series of commands have

00:09:59.286 --> 00:10:00.596 A:middle
After a series of commands have

00:10:00.596 --> 00:10:01.946 A:middle
been encoded, for example,

00:10:01.946 --> 00:10:03.216 A:middle
series of blits to copy

00:10:03.216 --> 00:10:05.136 A:middle
resources, then your app will

00:10:05.136 --> 00:10:07.406 A:middle
end encoding, which releases the

00:10:07.406 --> 00:10:08.676 A:middle
encoder object.

00:10:10.676 --> 00:10:13.136 A:middle
Additionally, Metal supports a

00:10:13.136 --> 00:10:14.786 A:middle
compute encoder for parallel

00:10:14.786 --> 00:10:16.056 A:middle
work that you would normally

00:10:16.056 --> 00:10:17.876 A:middle
have done in OpenCL before.

00:10:19.056 --> 00:10:21.196 A:middle
You enqueue a number of kernels

00:10:22.096 --> 00:10:23.496 A:middle
that get written to the command

00:10:23.496 --> 00:10:25.046 A:middle
buffer and you run the

00:10:25.046 --> 00:10:26.746 A:middle
encoder to release it.

00:10:28.196 --> 00:10:30.336 A:middle
Lastly, let's use a render

00:10:30.336 --> 00:10:31.996 A:middle
encoder for your familiar

00:10:31.996 --> 00:10:32.936 A:middle
rendering commands.

00:10:34.336 --> 00:10:35.776 A:middle
You enqueue your state changes

00:10:35.776 --> 00:10:38.036 A:middle
and your draw calls and end the

00:10:38.036 --> 00:10:38.536 A:middle
encoder.

00:10:41.356 --> 00:10:43.816 A:middle
So here we have a command buffer

00:10:44.116 --> 00:10:45.696 A:middle
full of different workloads, but

00:10:45.696 --> 00:10:47.396 A:middle
the GPU hasn't done any work

00:10:47.396 --> 00:10:47.556 A:middle
yet.

00:10:48.346 --> 00:10:50.246 A:middle
Metal has created the objects

00:10:50.586 --> 00:10:52.516 A:middle
and encoded commands all within

00:10:52.516 --> 00:10:53.036 A:middle
the CPU.

00:10:53.956 --> 00:10:55.516 A:middle
It's only after your application

00:10:55.566 --> 00:10:56.946 A:middle
has finished encoding comments

00:10:57.136 --> 00:10:58.556 A:middle
and explicitly committed the

00:10:58.556 --> 00:11:00.456 A:middle
command buffer that the GPU

00:10:58.556 --> 00:11:00.456 A:middle
command buffer that the GPU

00:11:00.456 --> 00:11:02.146 A:middle
begins to work and executes

00:11:02.556 --> 00:11:03.186 A:middle
those commands.

00:11:04.376 --> 00:11:05.516 A:middle
So now that we have encoded

00:11:05.516 --> 00:11:08.366 A:middle
commands, let's now compare and

00:11:08.366 --> 00:11:10.396 A:middle
contrast GL and Metal's command

00:11:10.396 --> 00:11:10.966 A:middle
submissions.

00:11:12.176 --> 00:11:14.006 A:middle
In GL there's no direct control

00:11:14.006 --> 00:11:16.006 A:middle
of when work gets submitted to

00:11:16.006 --> 00:11:17.586 A:middle
the GPU -- you rely on big

00:11:17.586 --> 00:11:19.456 A:middle
hammers like glFlush and

00:11:19.456 --> 00:11:20.706 A:middle
glFinish to ensure code

00:11:20.706 --> 00:11:23.196 A:middle
execution; glFlush submits the

00:11:23.196 --> 00:11:25.306 A:middle
commands and poses the CPU

00:11:25.306 --> 00:11:26.836 A:middle
threads until they're scheduled,

00:11:27.226 --> 00:11:28.806 A:middle
and glFinish poses the CPU

00:11:28.806 --> 00:11:30.756 A:middle
thread until the GPU is

00:11:30.756 --> 00:11:31.586 A:middle
completely finished.

00:11:32.716 --> 00:11:34.466 A:middle
Work can still get submitted at

00:11:34.466 --> 00:11:35.936 A:middle
any time before these commands

00:11:35.936 --> 00:11:38.096 A:middle
happen, introducing potential

00:11:38.096 --> 00:11:39.626 A:middle
stalls and slowdowns.

00:11:40.416 --> 00:11:42.536 A:middle
And Metal has equivalent

00:11:42.536 --> 00:11:43.786 A:middle
versions of these functions; you

00:11:43.786 --> 00:11:45.386 A:middle
can still explicitly commit and

00:11:45.386 --> 00:11:46.896 A:middle
wait for a command buffer to be

00:11:46.896 --> 00:11:48.126 A:middle
scheduled or completed.

00:11:48.636 --> 00:11:51.156 A:middle
But these wait commands are not

00:11:51.156 --> 00:11:52.976 A:middle
recommended unless you

00:11:52.976 --> 00:11:55.396 A:middle
absolutely need them.

00:11:55.576 --> 00:11:56.956 A:middle
Instead, we suggest that you

00:11:56.956 --> 00:11:58.526 A:middle
simply commit your command

00:11:58.526 --> 00:12:01.356 A:middle
buffer and then add a callback

00:11:58.526 --> 00:12:01.356 A:middle
buffer and then add a callback

00:12:01.356 --> 00:12:02.786 A:middle
so that your application can be

00:12:02.786 --> 00:12:04.466 A:middle
notified later when the command

00:12:04.466 --> 00:12:05.976 A:middle
buffer has been completed on the

00:12:05.976 --> 00:12:06.376 A:middle
GPU.

00:12:07.106 --> 00:12:08.976 A:middle
This frees your CPU to continue

00:12:08.976 --> 00:12:09.886 A:middle
doing other work.

00:12:10.486 --> 00:12:14.606 A:middle
So now that we have reviewed

00:12:15.006 --> 00:12:16.686 A:middle
command queue, command buffer,

00:12:16.936 --> 00:12:19.036 A:middle
command encoder, let's move on

00:12:19.336 --> 00:12:20.446 A:middle
and talk about resource

00:12:20.446 --> 00:12:20.836 A:middle
creation.

00:12:23.196 --> 00:12:25.206 A:middle
There are three main types of

00:12:25.206 --> 00:12:28.206 A:middle
resources that any graphic app

00:12:28.206 --> 00:12:30.166 A:middle
is likely to use: Buffers,

00:12:30.476 --> 00:12:31.906 A:middle
textures, and samplers.

00:12:32.666 --> 00:12:34.106 A:middle
Let's take a look at buffers

00:12:34.106 --> 00:12:34.426 A:middle
first.

00:12:35.476 --> 00:12:37.426 A:middle
In GL, you have a buffer object

00:12:37.576 --> 00:12:38.986 A:middle
and the memory associated with

00:12:38.986 --> 00:12:39.146 A:middle
it.

00:12:39.716 --> 00:12:42.536 A:middle
The API codes you use can modify

00:12:42.536 --> 00:12:45.036 A:middle
the object state, the memory, or

00:12:45.036 --> 00:12:45.756 A:middle
both together.

00:12:46.366 --> 00:12:50.186 A:middle
So here, for example,

00:12:50.186 --> 00:12:51.826 A:middle
glBufferData can be used to

00:12:51.826 --> 00:12:53.916 A:middle
modify both the memory and the

00:12:53.916 --> 00:12:54.886 A:middle
state of the object.

00:12:55.666 --> 00:12:56.986 A:middle
The buffer dimensions can be

00:12:56.986 --> 00:12:58.936 A:middle
modified again later by calling

00:12:58.936 --> 00:13:01.696 A:middle
glBufferData, in which case the

00:12:58.936 --> 00:13:01.696 A:middle
glBufferData, in which case the

00:13:01.696 --> 00:13:03.726 A:middle
old object and its contents will

00:13:03.726 --> 00:13:05.726 A:middle
be discarded internally by

00:13:05.726 --> 00:13:06.216 A:middle
OpenGL.

00:13:06.816 --> 00:13:11.036 A:middle
In Metal, the API to create and

00:13:11.036 --> 00:13:12.416 A:middle
fill a buffer looks very

00:13:12.416 --> 00:13:14.406 A:middle
similar, but the main difference

00:13:14.406 --> 00:13:16.336 A:middle
lies in the fact that the

00:13:16.336 --> 00:13:18.186 A:middle
produced subject is immutable.

00:13:18.556 --> 00:13:20.456 A:middle
If at any point you need to

00:13:20.456 --> 00:13:22.156 A:middle
resize the buffer, you simply

00:13:22.156 --> 00:13:23.756 A:middle
need to create a new one and

00:13:23.756 --> 00:13:25.186 A:middle
discard the old one.

00:13:26.896 --> 00:13:29.946 A:middle
Both OpenGL and Metal have ways

00:13:29.946 --> 00:13:31.526 A:middle
to indicate how you intend to

00:13:31.526 --> 00:13:35.096 A:middle
use an object; however, in GL

00:13:35.096 --> 00:13:36.966 A:middle
the enum is simply a usage hint

00:13:37.346 --> 00:13:40.626 A:middle
about how the data in a buffer

00:13:40.626 --> 00:13:42.166 A:middle
object would be accessed.

00:13:42.926 --> 00:13:44.896 A:middle
The driver uses that hint to

00:13:44.896 --> 00:13:46.416 A:middle
decide where to base the locate

00:13:46.646 --> 00:13:48.106 A:middle
memory for the buffer, but

00:13:48.106 --> 00:13:49.856 A:middle
there's no direct control over

00:13:49.956 --> 00:13:50.356 A:middle
storage.

00:13:51.156 --> 00:13:53.776 A:middle
OpenGL ultimately decides where

00:13:53.776 --> 00:13:56.000 A:middle
to store the objects.

00:13:57.386 --> 00:13:59.356 A:middle
In Metal, the API allows you to

00:13:59.356 --> 00:14:01.716 A:middle
specify a storage mode which

00:13:59.356 --> 00:14:01.716 A:middle
specify a storage mode which

00:14:01.716 --> 00:14:03.296 A:middle
maps to a specific memory

00:14:03.296 --> 00:14:04.336 A:middle
allocation behavior.

00:14:05.436 --> 00:14:06.936 A:middle
Metal gives you control, since

00:14:06.936 --> 00:14:08.746 A:middle
you know best how your objects

00:14:08.776 --> 00:14:09.696 A:middle
are going to be used.

00:14:10.036 --> 00:14:13.026 A:middle
It's an important concept in an

00:14:13.026 --> 00:14:14.756 A:middle
object creation, so we'll come

00:14:14.756 --> 00:14:16.816 A:middle
back to it in a short moment

00:14:16.816 --> 00:14:18.976 A:middle
right after we look at texture

00:14:19.836 --> 00:14:20.000 A:middle
API's.

00:14:22.246 --> 00:14:23.916 A:middle
In GL, each texture has an

00:14:23.916 --> 00:14:26.196 A:middle
internal sampler object, an

00:14:26.196 --> 00:14:28.716 A:middle
app's commonly set up sampling

00:14:28.716 --> 00:14:29.926 A:middle
mode through that sampler.

00:14:30.516 --> 00:14:31.816 A:middle
But you also have the option to

00:14:31.816 --> 00:14:33.416 A:middle
create a separate sampler object

00:14:33.646 --> 00:14:34.656 A:middle
outside of your texture.

00:14:35.916 --> 00:14:38.086 A:middle
Here's an example for creating

00:14:38.086 --> 00:14:39.236 A:middle
and binding your texture,

00:14:39.836 --> 00:14:41.906 A:middle
setting up your sampler, and

00:14:41.906 --> 00:14:43.836 A:middle
then finally filling in the

00:14:43.836 --> 00:14:44.156 A:middle
data.

00:14:44.786 --> 00:14:47.826 A:middle
One thing worth mentioning is

00:14:47.826 --> 00:14:50.016 A:middle
that GL has a lot of API calls

00:14:50.066 --> 00:14:52.496 A:middle
to create initialized textures

00:14:52.536 --> 00:14:53.006 A:middle
with data.

00:14:54.166 --> 00:14:55.756 A:middle
It also has what are called

00:14:55.866 --> 00:14:57.616 A:middle
named resource versions of the

00:14:57.616 --> 00:14:58.196 A:middle
same API.

00:14:59.716 --> 00:15:01.366 A:middle
There's even more API's when it

00:14:59.716 --> 00:15:01.366 A:middle
There's even more API's when it

00:15:01.366 --> 00:15:02.636 A:middle
comes to managing samplers.

00:15:02.636 --> 00:15:07.046 A:middle
The list just goes on and on.

00:15:07.316 --> 00:15:09.116 A:middle
One of the design goals with

00:15:09.116 --> 00:15:11.606 A:middle
Metal was to give a simpler API

00:15:11.606 --> 00:15:13.646 A:middle
that would maintain all of the

00:15:13.646 --> 00:15:14.326 A:middle
flexibility.

00:15:14.976 --> 00:15:17.176 A:middle
So in Metal, texture and sampler

00:15:17.176 --> 00:15:19.386 A:middle
objects are always separate and

00:15:19.386 --> 00:15:20.916 A:middle
immutable after creation.

00:15:21.546 --> 00:15:25.756 A:middle
To create a texture, we create a

00:15:25.756 --> 00:15:27.916 A:middle
descriptor, set various

00:15:27.916 --> 00:15:29.646 A:middle
properties to define texture

00:15:29.646 --> 00:15:31.476 A:middle
dimensions like pixelFormat and

00:15:31.476 --> 00:15:33.606 A:middle
sizes, amongst others.

00:15:35.096 --> 00:15:37.026 A:middle
Again, an important property we

00:15:37.026 --> 00:15:39.016 A:middle
said is the storage mode to

00:15:39.016 --> 00:15:40.806 A:middle
specify where in memory to store

00:15:40.806 --> 00:15:41.406 A:middle
the texture.

00:15:42.466 --> 00:15:43.736 A:middle
And finally, we use that

00:15:43.866 --> 00:15:45.706 A:middle
descriptor to create an

00:15:45.706 --> 00:15:46.526 A:middle
immutable object.

00:15:47.056 --> 00:15:50.686 A:middle
In a similar fashion, you start

00:15:51.016 --> 00:15:52.816 A:middle
with a sampler descriptor, set

00:15:52.816 --> 00:15:55.206 A:middle
its properties, and create the

00:15:55.726 --> 00:15:57.056 A:middle
immutable sampler object.

00:15:58.086 --> 00:15:59.296 A:middle
It's pretty easy.

00:16:00.556 --> 00:16:02.826 A:middle
To fill a texture's image data,

00:16:02.946 --> 00:16:05.186 A:middle
we calculate the bytes per row.

00:16:05.326 --> 00:16:06.896 A:middle
And just like we did in OpenGL,

00:16:06.956 --> 00:16:08.626 A:middle
we specify the region to load.

00:16:09.486 --> 00:16:10.986 A:middle
Then we call the textures

00:16:11.086 --> 00:16:13.626 A:middle
replaceRegion method, which

00:16:13.626 --> 00:16:15.676 A:middle
copies the data into the texture

00:16:15.806 --> 00:16:18.066 A:middle
from a pointer we specify.

00:16:21.116 --> 00:16:22.776 A:middle
Once you load your first

00:16:22.776 --> 00:16:24.046 A:middle
texture, you're likely to

00:16:24.046 --> 00:16:25.896 A:middle
observe that it's upside down.

00:16:27.286 --> 00:16:28.656 A:middle
That's because in Metal the

00:16:28.656 --> 00:16:30.366 A:middle
texture coordinates are flipped on the

00:16:30.366 --> 00:16:31.896 A:middle
y-axis compared to GL.

00:16:33.056 --> 00:16:34.726 A:middle
And it's also worth mentioning

00:16:34.946 --> 00:16:38.066 A:middle
that Metal API's don't perform

00:16:38.066 --> 00:16:40.526 A:middle
any pixelFormat transformation

00:16:40.526 --> 00:16:41.056 A:middle
under the hood.

00:16:41.286 --> 00:16:42.336 A:middle
So you need to upload your

00:16:42.336 --> 00:16:43.896 A:middle
textures in the exact format

00:16:44.016 --> 00:16:44.976 A:middle
that you intend to use.

00:16:49.466 --> 00:16:51.916 A:middle
Now let's get back to storage

00:16:51.916 --> 00:16:52.266 A:middle
modes.

00:16:52.726 --> 00:16:55.626 A:middle
As mentioned, in GL the driver

00:16:55.626 --> 00:16:57.396 A:middle
has to make a best guess on how

00:16:57.396 --> 00:16:58.886 A:middle
you wanted to use your

00:16:58.886 --> 00:16:59.456 A:middle
resources.

00:16:59.986 --> 00:17:01.396 A:middle
As a developer, you can provide

00:16:59.986 --> 00:17:01.396 A:middle
As a developer, you can provide

00:17:01.396 --> 00:17:03.096 A:middle
hints in some cases, like when

00:17:03.096 --> 00:17:04.496 A:middle
you created a buffer or by

00:17:04.496 --> 00:17:07.906 A:middle
creating render buffer objects

00:17:07.906 --> 00:17:09.276 A:middle
for frame buffer attachments.

00:17:09.836 --> 00:17:11.856 A:middle
But in all cases, these were

00:17:11.856 --> 00:17:13.556 A:middle
still hints and the

00:17:13.556 --> 00:17:15.546 A:middle
implementation details are

00:17:15.546 --> 00:17:16.195 A:middle
hidden from you.

00:17:16.806 --> 00:17:18.925 A:middle
A few minutes ago, we briefly

00:17:18.925 --> 00:17:20.665 A:middle
saw the additional storage mode

00:17:20.695 --> 00:17:22.246 A:middle
property Metal that you can set

00:17:22.246 --> 00:17:25.626 A:middle
on a texture descriptor and also

00:17:25.626 --> 00:17:27.435 A:middle
when creating a buffer.

00:17:28.376 --> 00:17:29.796 A:middle
Let's look at the main use cases

00:17:29.796 --> 00:17:30.236 A:middle
for those.

00:17:31.596 --> 00:17:34.536 A:middle
Simplest option is to use shared

00:17:34.536 --> 00:17:36.716 A:middle
storage mode, which gives both

00:17:36.716 --> 00:17:38.576 A:middle
the CPU and GPU access to the

00:17:38.576 --> 00:17:39.146 A:middle
resource.

00:17:39.806 --> 00:17:41.396 A:middle
For buffers, this means you get

00:17:41.396 --> 00:17:43.196 A:middle
to point here to the memory

00:17:43.196 --> 00:17:44.256 A:middle
backing of the object.

00:17:45.146 --> 00:17:48.136 A:middle
For textures on iOS, this means

00:17:48.636 --> 00:17:49.956 A:middle
you can call some easy-to-use

00:17:49.956 --> 00:17:51.916 A:middle
functions to set and retrieve

00:17:52.126 --> 00:17:52.706 A:middle
image data.

00:17:53.356 --> 00:17:57.466 A:middle
You can also use a private

00:17:57.466 --> 00:17:59.736 A:middle
storage mode, which gives the

00:17:59.736 --> 00:18:02.316 A:middle
GPU exclusive access to the

00:17:59.736 --> 00:18:02.316 A:middle
GPU exclusive access to the

00:18:02.316 --> 00:18:02.606 A:middle
data.

00:18:03.156 --> 00:18:05.696 A:middle
It allows Metal to apply some

00:18:05.696 --> 00:18:07.236 A:middle
optimizations that it wouldn't

00:18:07.236 --> 00:18:09.256 A:middle
normally have been able to use

00:18:09.746 --> 00:18:11.766 A:middle
if the CPU had access to it.

00:18:12.676 --> 00:18:14.896 A:middle
But only the GPU can directly

00:18:14.896 --> 00:18:16.736 A:middle
fill the contents of the data.

00:18:17.716 --> 00:18:19.046 A:middle
So you can indirectly fill the

00:18:19.046 --> 00:18:21.056 A:middle
data from the CPU by using a

00:18:21.056 --> 00:18:22.836 A:middle
blitEncoder from a second

00:18:22.836 --> 00:18:25.006 A:middle
intermediate resource that uses

00:18:25.216 --> 00:18:26.016 A:middle
shared storage.

00:18:26.556 --> 00:18:30.256 A:middle
On the voices with dedicated

00:18:30.256 --> 00:18:31.676 A:middle
video memory, setting the

00:18:31.676 --> 00:18:33.616 A:middle
resource to use private storage

00:18:34.256 --> 00:18:36.316 A:middle
allocates it in video memory

00:18:36.316 --> 00:18:37.656 A:middle
only, single copy.

00:18:38.236 --> 00:18:42.386 A:middle
On macOS there's a managed

00:18:42.386 --> 00:18:44.176 A:middle
storage mode which allows both

00:18:44.176 --> 00:18:46.476 A:middle
the CPU and GPU to access an

00:18:46.476 --> 00:18:47.146 A:middle
object's data.

00:18:48.436 --> 00:18:50.326 A:middle
And on systems with dedicated

00:18:50.326 --> 00:18:52.526 A:middle
video memory, Metal may have to

00:18:52.526 --> 00:18:55.206 A:middle
create a second mirrored memory

00:18:55.206 --> 00:18:57.576 A:middle
backing for efficient access by

00:18:57.576 --> 00:18:58.516 A:middle
both processes.

00:18:59.276 --> 00:19:01.046 A:middle
So because of this, explicit

00:18:59.276 --> 00:19:01.046 A:middle
So because of this, explicit

00:19:01.046 --> 00:19:02.406 A:middle
codes are necessary to ensure

00:19:02.406 --> 00:19:03.666 A:middle
that your data is synchronized

00:19:03.946 --> 00:19:06.426 A:middle
for CPU and GPU access, for

00:19:06.426 --> 00:19:07.976 A:middle
example, using didModifyRange.

00:19:11.156 --> 00:19:14.046 A:middle
So to recap, we reviewed some of

00:19:14.046 --> 00:19:16.216 A:middle
the typical uses for each mode.

00:19:17.306 --> 00:19:20.146 A:middle
On macOS you would use the

00:19:20.146 --> 00:19:22.176 A:middle
private storage mode for static

00:19:22.176 --> 00:19:24.606 A:middle
assets and your render targets.

00:19:25.826 --> 00:19:28.316 A:middle
Your small dynamic buffers could

00:19:28.316 --> 00:19:30.366 A:middle
use the shared storage mode.

00:19:31.216 --> 00:19:32.896 A:middle
And your larger buffers with

00:19:32.896 --> 00:19:34.906 A:middle
small updates would use the

00:19:34.906 --> 00:19:35.886 A:middle
managed storage mode.

00:19:36.396 --> 00:19:40.086 A:middle
On iOS, your static data and

00:19:40.086 --> 00:19:42.416 A:middle
rendering targets can use the

00:19:42.416 --> 00:19:43.326 A:middle
private storage mode.

00:19:43.816 --> 00:19:47.026 A:middle
And since our devices use

00:19:47.456 --> 00:19:50.596 A:middle
unified memory, dynamic data of

00:19:50.596 --> 00:19:52.566 A:middle
any size can use the shared

00:19:52.566 --> 00:19:54.716 A:middle
storage mode and still get great

00:19:54.776 --> 00:19:55.456 A:middle
performance.

00:19:59.716 --> 00:20:02.136 A:middle
Next, let's talk about

00:19:59.716 --> 00:20:02.136 A:middle
Next, let's talk about

00:20:02.136 --> 00:20:03.896 A:middle
developing shaders for your

00:20:03.896 --> 00:20:05.086 A:middle
graphics application and what

00:20:05.086 --> 00:20:07.796 A:middle
API's you use to work with

00:20:07.796 --> 00:20:08.336 A:middle
shaders.

00:20:08.866 --> 00:20:12.326 A:middle
When it comes to shader

00:20:12.326 --> 00:20:13.996 A:middle
compilation in GL, you have to

00:20:13.996 --> 00:20:17.696 A:middle
create a shader object, replace

00:20:17.996 --> 00:20:20.206 A:middle
the ShaderSource in the object,

00:20:20.586 --> 00:20:22.756 A:middle
make just in time compilation,

00:20:23.156 --> 00:20:25.276 A:middle
and verify that the compilation

00:20:25.276 --> 00:20:25.806 A:middle
succeeded.

00:20:25.866 --> 00:20:28.726 A:middle
And while this workflow has its

00:20:28.726 --> 00:20:30.586 A:middle
benefits, your application had

00:20:30.586 --> 00:20:32.176 A:middle
to pay the performance costs of

00:20:32.176 --> 00:20:34.266 A:middle
compiling all your shaders every

00:20:36.736 --> 00:20:36.936 A:middle
time.

00:20:37.056 --> 00:20:39.206 A:middle
One of the key ways in which

00:20:39.206 --> 00:20:42.036 A:middle
Metal achieves its efficiency is

00:20:42.036 --> 00:20:44.076 A:middle
by doing work earlier and less

00:20:44.076 --> 00:20:44.596 A:middle
frequently.

00:20:45.296 --> 00:20:46.816 A:middle
At build time, Xcode will

00:20:46.816 --> 00:20:48.346 A:middle
compile all the Metal

00:20:48.636 --> 00:20:50.096 A:middle
ShaderSource files into a

00:20:50.096 --> 00:20:52.196 A:middle
default Metal library file and

00:20:52.196 --> 00:20:53.946 A:middle
place it in your app bundle for

00:20:53.946 --> 00:20:54.966 A:middle
retrieval at runtime.

00:20:55.836 --> 00:20:57.216 A:middle
So this removes the need to

00:20:57.216 --> 00:20:59.946 A:middle
compile a lot of it at runtime

00:21:00.026 --> 00:21:01.556 A:middle
and cuts the compilation time

00:21:02.086 --> 00:21:03.736 A:middle
when your application runs in

00:21:04.726 --> 00:21:04.936 A:middle
half.

00:21:05.206 --> 00:21:07.436 A:middle
All you need to do is create a

00:21:07.436 --> 00:21:09.276 A:middle
Metal library from a file

00:21:09.276 --> 00:21:10.986 A:middle
bundled with your application

00:21:11.486 --> 00:21:13.666 A:middle
and fetch the shader function

00:21:13.876 --> 00:21:14.826 A:middle
from it.

00:21:17.656 --> 00:21:19.976 A:middle
In GL you use GLSL, which is

00:21:19.976 --> 00:21:21.756 A:middle
based on the C programming

00:21:21.756 --> 00:21:22.236 A:middle
language.

00:21:23.696 --> 00:21:25.326 A:middle
The Metal shading language or

00:21:25.326 --> 00:21:27.536 A:middle
MSL is based on C++.

00:21:27.776 --> 00:21:29.466 A:middle
So it should look reasonably

00:21:29.466 --> 00:21:31.176 A:middle
familiar to most GL developers.

00:21:32.206 --> 00:21:34.216 A:middle
Its foundation in C++ means that

00:21:34.216 --> 00:21:35.446 A:middle
you can create classes,

00:21:35.636 --> 00:21:36.726 A:middle
templates, and stretches.

00:21:36.726 --> 00:21:38.886 A:middle
You can define enums and

00:21:38.886 --> 00:21:40.000 A:middle
namespaces.

00:21:41.216 --> 00:21:43.546 A:middle
And like GLSL, there are

00:21:43.546 --> 00:21:45.466 A:middle
built-in vector and matrix

00:21:45.516 --> 00:21:47.136 A:middle
types, numerous built-in

00:21:47.186 --> 00:21:48.726 A:middle
functions and operations come in

00:21:48.726 --> 00:21:49.826 A:middle
and use for graphics.

00:21:50.396 --> 00:21:52.596 A:middle
And there are classes to operate

00:21:52.836 --> 00:21:54.786 A:middle
on textures that specify sampler

00:21:54.786 --> 00:21:54.976 A:middle
state.

00:22:01.146 --> 00:22:03.796 A:middle
Like Metal, MSL is also unified

00:22:03.936 --> 00:22:05.936 A:middle
for graphics and compute.

00:22:07.276 --> 00:22:09.156 A:middle
And finally, since shaders are

00:22:09.156 --> 00:22:11.776 A:middle
pre-compiled, Xcode is able to

00:22:11.776 --> 00:22:13.586 A:middle
give you errors, warning, and

00:22:13.586 --> 00:22:15.206 A:middle
guidance to help you debug at

00:22:15.306 --> 00:22:16.456 A:middle
build time.

00:22:17.576 --> 00:22:19.596 A:middle
So let's take a look at actual

00:22:19.596 --> 00:22:22.306 A:middle
code for MSL and compare it with

00:22:22.306 --> 00:22:22.986 A:middle
GLSL.

00:22:24.176 --> 00:22:25.886 A:middle
We're going to walk through a

00:22:25.886 --> 00:22:28.436 A:middle
simple vertex shader, GLSL on

00:22:28.436 --> 00:22:29.746 A:middle
top, MSL on the bottom.

00:22:30.266 --> 00:22:33.936 A:middle
Let's start defining our

00:22:33.936 --> 00:22:34.526 A:middle
shaders.

00:22:34.566 --> 00:22:35.736 A:middle
These are the prototypes.

00:22:36.006 --> 00:22:37.586 A:middle
In GLSL, void main.

00:22:38.266 --> 00:22:39.656 A:middle
There's nothing in the shader

00:22:39.656 --> 00:22:41.556 A:middle
that specifies the shader stage.

00:22:42.146 --> 00:22:43.656 A:middle
It's purely determined by the

00:22:43.656 --> 00:22:46.136 A:middle
shader type passed into the

00:22:46.136 --> 00:22:47.416 A:middle
glCreateShader call.

00:22:48.776 --> 00:22:50.836 A:middle
In MSL the shader stage is

00:22:50.836 --> 00:22:52.486 A:middle
explicitly specified in the

00:22:52.486 --> 00:22:53.036 A:middle
shader code.

00:22:53.426 --> 00:22:54.916 A:middle
Here the vertex qualifier

00:22:54.916 --> 00:22:56.006 A:middle
indicates that it will be

00:22:56.006 --> 00:22:57.336 A:middle
executed for each vertex

00:22:57.476 --> 00:22:59.116 A:middle
generating perfect examples.

00:23:00.916 --> 00:23:03.726 A:middle
In GLSL, every shader entry

00:23:03.726 --> 00:23:05.486 A:middle
point has to be called main and

00:23:05.616 --> 00:23:06.806 A:middle
accept and return void.

00:23:07.526 --> 00:23:09.866 A:middle
In MSL each entry point has a

00:23:09.866 --> 00:23:10.796 A:middle
distinct name.

00:23:11.176 --> 00:23:13.256 A:middle
And when you're building shaders

00:23:13.256 --> 00:23:15.076 A:middle
with Xcode, the compiler can

00:23:15.076 --> 00:23:16.876 A:middle
resolve include statement in the

00:23:16.876 --> 00:23:18.926 A:middle
preprocessing stage the same it

00:23:18.926 --> 00:23:20.546 A:middle
would do for regular C++ code.

00:23:21.266 --> 00:23:22.926 A:middle
At runtime you can query

00:23:23.296 --> 00:23:24.916 A:middle
functions by their distinct name

00:23:25.586 --> 00:23:27.216 A:middle
from the precompiled Metal

00:23:27.216 --> 00:23:27.596 A:middle
library.

00:23:27.656 --> 00:23:31.376 A:middle
Then let's talk about inputs.

00:23:32.416 --> 00:23:34.216 A:middle
Because each entry point in GLSL

00:23:34.216 --> 00:23:35.716 A:middle
is a main function with no

00:23:35.716 --> 00:23:38.016 A:middle
argument, all of the inputs are

00:23:38.016 --> 00:23:39.476 A:middle
passed as global arguments.

00:23:40.226 --> 00:23:41.876 A:middle
This applies to both vertex

00:23:41.876 --> 00:23:43.246 A:middle
attributes and uniform

00:23:43.246 --> 00:23:43.836 A:middle
variables.

00:23:45.056 --> 00:23:48.186 A:middle
In Metal all the inputs to the

00:23:48.186 --> 00:23:50.266 A:middle
shaded stage are arguments to

00:23:50.266 --> 00:23:51.126 A:middle
the entry function.

00:23:51.546 --> 00:23:54.276 A:middle
The double brackets declare C++

00:23:54.276 --> 00:23:54.816 A:middle
attributes.

00:23:54.916 --> 00:23:56.000 A:middle
We'll look at them in a second.

00:23:57.676 --> 00:23:59.366 A:middle
One of the inputs here that we

00:23:59.366 --> 00:24:00.956 A:middle
have is a model view projection

00:23:59.366 --> 00:24:00.956 A:middle
have is a model view projection

00:24:00.956 --> 00:24:01.496 A:middle
matrix.

00:24:02.006 --> 00:24:05.966 A:middle
In OpenGL, your application had

00:24:05.966 --> 00:24:07.986 A:middle
to be aware of the GLSL names

00:24:08.816 --> 00:24:11.546 A:middle
within the C++ code in order to

00:24:11.546 --> 00:24:13.306 A:middle
bind data to these variables.

00:24:14.146 --> 00:24:15.826 A:middle
And that made shader development

00:24:16.276 --> 00:24:16.796 A:middle
error-prone.

00:24:17.376 --> 00:24:21.076 A:middle
In MSL the uniform binding

00:24:21.076 --> 00:24:22.446 A:middle
indices are explicitly

00:24:22.446 --> 00:24:24.096 A:middle
controlled by the developer

00:24:24.096 --> 00:24:25.906 A:middle
within the shader, so an

00:24:25.906 --> 00:24:28.006 A:middle
application can bind directly to

00:24:28.076 --> 00:24:29.156 A:middle
a specific slot.

00:24:29.646 --> 00:24:31.166 A:middle
In the example here, slot number

00:24:31.166 --> 00:24:31.376 A:middle
one.

00:24:32.816 --> 00:24:34.106 A:middle
The keyword constant here

00:24:34.106 --> 00:24:36.836 A:middle
indicates that the intention for

00:24:36.836 --> 00:24:38.446 A:middle
the model view projection is to

00:24:38.446 --> 00:24:40.256 A:middle
be uniform for all vertices.

00:24:42.276 --> 00:24:44.086 A:middle
The other input to the shader is

00:24:44.086 --> 00:24:45.576 A:middle
a set of vertex attributes.

00:24:46.266 --> 00:24:48.136 A:middle
In GLSL you typically use

00:24:48.396 --> 00:24:50.136 A:middle
separate attribute inputs.

00:24:50.476 --> 00:24:52.416 A:middle
The main difference here is that

00:24:52.416 --> 00:24:54.896 A:middle
MSL uses a structure of your own

00:24:54.896 --> 00:24:55.256 A:middle
design.

00:24:56.136 --> 00:24:57.746 A:middle
The staging keywords suggest

00:24:57.826 --> 00:24:59.066 A:middle
that each invocation of the

00:24:59.066 --> 00:25:01.036 A:middle
shader will receive its own

00:24:59.066 --> 00:25:01.036 A:middle
shader will receive its own

00:25:01.036 --> 00:25:01.660 A:middle
arguments.

00:25:03.806 --> 00:25:05.146 A:middle
Once you have all the inputs to

00:25:05.146 --> 00:25:06.756 A:middle
the shaders set up, you can

00:25:06.756 --> 00:25:08.016 A:middle
actually perform all the

00:25:08.016 --> 00:25:08.736 A:middle
calculations.

00:25:10.416 --> 00:25:12.556 A:middle
Then for the outputs, in GLSL

00:25:12.556 --> 00:25:14.316 A:middle
the output is split between

00:25:14.316 --> 00:25:16.436 A:middle
varying attributes like

00:25:16.436 --> 00:25:18.866 A:middle
glTexCoord and predefined

00:25:18.866 --> 00:25:21.146 A:middle
variables, in this case gl

00:25:21.146 --> 00:25:21.596 A:middle
Position.

00:25:22.176 --> 00:25:25.886 A:middle
In MSL, the vertex shader output

00:25:26.106 --> 00:25:27.526 A:middle
is combined into your own

00:25:27.526 --> 00:25:27.966 A:middle
structure.

00:25:29.576 --> 00:25:31.866 A:middle
So we've used a vertex and

00:25:31.866 --> 00:25:32.976 A:middle
vertex output structure.

00:25:33.406 --> 00:25:34.976 A:middle
Let's scroll up in the MSL code

00:25:35.046 --> 00:25:36.696 A:middle
to see what they actually look

00:25:37.236 --> 00:25:37.386 A:middle
like.

00:25:39.436 --> 00:25:41.926 A:middle
As mentioned previously, GLSL

00:25:41.926 --> 00:25:44.536 A:middle
defines the input vertex

00:25:44.536 --> 00:25:46.756 A:middle
attributes separately, and Metal

00:25:46.756 --> 00:25:48.646 A:middle
allows you to define them within

00:25:48.646 --> 00:25:49.166 A:middle
a structure.

00:25:49.776 --> 00:25:52.836 A:middle
In MSL there are a few special

00:25:52.836 --> 00:25:54.356 A:middle
keywords for vertex shader

00:25:54.356 --> 00:25:54.696 A:middle
input.

00:25:55.196 --> 00:25:57.966 A:middle
We mark each structure member

00:25:57.966 --> 00:25:59.686 A:middle
with an attribute keyword and

00:25:59.686 --> 00:26:02.306 A:middle
assign an attribute index to it.

00:25:59.686 --> 00:26:02.306 A:middle
assign an attribute index to it.

00:26:02.816 --> 00:26:05.286 A:middle
Similar to GLSL, these indices

00:26:05.636 --> 00:26:07.296 A:middle
are used in the Metal API to

00:26:07.396 --> 00:26:09.106 A:middle
assign the vertex buffer streams

00:26:09.256 --> 00:26:11.836 A:middle
to your vertex attributes.

00:26:15.556 --> 00:26:18.066 A:middle
And GLSL predefines special

00:26:18.066 --> 00:26:20.456 A:middle
keywords like GL position to

00:26:20.456 --> 00:26:23.166 A:middle
indicate which variable contains

00:26:23.606 --> 00:26:25.086 A:middle
vertex coordinates that have

00:26:25.086 --> 00:26:26.396 A:middle
been transformed with the model

00:26:26.396 --> 00:26:27.576 A:middle
view projection matrix.

00:26:29.046 --> 00:26:30.256 A:middle
Similarly, for the vertex

00:26:30.256 --> 00:26:32.576 A:middle
output, a structure in MSL, the

00:26:32.576 --> 00:26:35.206 A:middle
special keyword position signals

00:26:35.206 --> 00:26:36.506 A:middle
that the vertex shader output

00:26:36.726 --> 00:26:38.246 A:middle
position is stored in that

00:26:38.656 --> 00:26:39.356 A:middle
structure member.

00:26:42.656 --> 00:26:46.296 A:middle
Similar to GLSL vector type, MSL

00:26:46.296 --> 00:26:48.326 A:middle
defines a number of simd types

00:26:48.486 --> 00:26:50.996 A:middle
via the simd.h header that can

00:26:50.996 --> 00:26:53.366 A:middle
be shared between your CPU and

00:26:53.366 --> 00:26:53.896 A:middle
GPU code.

00:26:55.186 --> 00:26:56.376 A:middle
But there's a few things you

00:26:56.376 --> 00:26:57.536 A:middle
need to remember about them.

00:26:58.926 --> 00:27:01.036 A:middle
Vector and matrix types in your

00:26:58.926 --> 00:27:01.036 A:middle
Vector and matrix types in your

00:27:01.036 --> 00:27:03.706 A:middle
buffers are aligned to 16 bytes

00:27:03.906 --> 00:27:05.396 A:middle
or 8 bytes for half precision.

00:27:06.146 --> 00:27:07.276 A:middle
So they're not necessarily

00:27:07.276 --> 00:27:09.256 A:middle
packed, for example, a float3

00:27:09.256 --> 00:27:11.576 A:middle
has a size of 12 bytes but is

00:27:11.576 --> 00:27:12.726 A:middle
aligned to 16 bytes.

00:27:13.346 --> 00:27:15.246 A:middle
This is to ensure that the data

00:27:15.246 --> 00:27:17.536 A:middle
is aligned for optimal CPU and

00:27:17.536 --> 00:27:18.276 A:middle
GPU access.

00:27:19.686 --> 00:27:21.486 A:middle
There are specific backed

00:27:21.486 --> 00:27:23.186 A:middle
formats you can use if you need

00:27:23.186 --> 00:27:23.406 A:middle
them.

00:27:23.786 --> 00:27:25.406 A:middle
But you will need to unpack them

00:27:25.466 --> 00:27:29.966 A:middle
in the shader before using them.

00:27:30.166 --> 00:27:32.306 A:middle
So we've just reviewed the main

00:27:32.306 --> 00:27:34.726 A:middle
differences between GLSL and

00:27:34.726 --> 00:27:35.176 A:middle
MSL.

00:27:35.876 --> 00:27:38.536 A:middle
And to make this transition

00:27:38.536 --> 00:27:41.006 A:middle
smooth and easy, my colleague

00:27:41.006 --> 00:27:42.986 A:middle
Max will show you a really cool

00:27:42.986 --> 00:27:44.536 A:middle
tool to help you breeze through

00:27:44.536 --> 00:27:44.603 A:middle
it.

00:27:45.146 --> 00:27:45.426 A:middle
Thank you.

00:27:46.516 --> 00:27:51.796 A:middle
[ Applause ]

00:27:52.296 --> 00:27:53.286 A:middle
&gt;&gt; Good evening.

00:27:54.616 --> 00:27:57.106 A:middle
Metal, it's not just an API and

00:27:57.346 --> 00:27:59.516 A:middle
a shading language, it is also a

00:27:59.516 --> 00:28:01.666 A:middle
powerful collection of tools.

00:27:59.516 --> 00:28:01.666 A:middle
powerful collection of tools.

00:28:02.686 --> 00:28:04.556 A:middle
My name is Max, and I'm going to

00:28:04.556 --> 00:28:06.656 A:middle
minimize your hassle porting to

00:28:06.656 --> 00:28:07.016 A:middle
Metal.

00:28:07.586 --> 00:28:11.546 A:middle
Let's take a look at this scene.

00:28:11.846 --> 00:28:13.976 A:middle
This is the very first draw call

00:28:13.976 --> 00:28:16.296 A:middle
from an old OpenGL demo that we

00:28:16.296 --> 00:28:17.976 A:middle
here at Apple also ported to

00:28:17.976 --> 00:28:18.376 A:middle
Metal.

00:28:19.126 --> 00:28:21.656 A:middle
It's drawing a model of a temple

00:28:21.656 --> 00:28:23.926 A:middle
and a tree, both illuminated by

00:28:23.976 --> 00:28:25.016 A:middle
a global light source.

00:28:25.316 --> 00:28:26.516 A:middle
Let's port the fragment shader

00:28:26.516 --> 00:28:26.976 A:middle
together.

00:28:31.046 --> 00:28:32.916 A:middle
So the very first thing I did, I

00:28:32.916 --> 00:28:34.926 A:middle
just copy and pasted my entire

00:28:34.926 --> 00:28:37.616 A:middle
old OpenGL code directly into my

00:28:37.616 --> 00:28:38.676 A:middle
Metal shader file.

00:28:39.886 --> 00:28:41.556 A:middle
Based on this, I've already

00:28:41.556 --> 00:28:44.476 A:middle
created my input structure, as

00:28:44.476 --> 00:28:46.026 A:middle
well as my function prototype.

00:28:47.536 --> 00:28:48.076 A:middle
Let's begin.

00:28:49.266 --> 00:28:50.896 A:middle
So what we are going to do is

00:28:50.896 --> 00:28:52.656 A:middle
just copy and paste the contents

00:28:52.656 --> 00:28:55.186 A:middle
of the main function directly

00:28:55.396 --> 00:28:56.846 A:middle
into our Metal function.

00:28:58.166 --> 00:29:00.436 A:middle
And here we see the very first

00:28:58.166 --> 00:29:00.436 A:middle
And here we see the very first

00:29:00.436 --> 00:29:02.016 A:middle
powerful thing about Metal.

00:29:03.336 --> 00:29:04.116 A:middle
Because the shader's

00:29:04.216 --> 00:29:06.176 A:middle
precompiled, we are getting

00:29:06.176 --> 00:29:07.406 A:middle
errors instantly.

00:29:07.816 --> 00:29:09.646 A:middle
Let's take a closer look.

00:29:10.456 --> 00:29:12.336 A:middle
Of course, the building vector

00:29:12.336 --> 00:29:13.806 A:middle
types have different names now.

00:29:14.416 --> 00:29:17.276 A:middle
So vec2 becomes a float2; the

00:29:17.326 --> 00:29:20.616 A:middle
vec3 becomes the float3; and the

00:29:20.616 --> 00:29:22.786 A:middle
vec4 becomes a float4.

00:29:23.416 --> 00:29:24.776 A:middle
So we quickly fix that.

00:29:28.296 --> 00:29:29.826 A:middle
The next error we are going to

00:29:29.826 --> 00:29:31.956 A:middle
see is that like all of our

00:29:31.956 --> 00:29:33.316 A:middle
input structures -- all of our

00:29:33.316 --> 00:29:35.346 A:middle
global variables are now coming

00:29:35.396 --> 00:29:36.496 A:middle
from our input structure.

00:29:36.936 --> 00:29:38.336 A:middle
And because I just used a

00:29:38.446 --> 00:29:39.996 A:middle
similar naming scheme, this is

00:29:39.996 --> 00:29:40.976 A:middle
also very easy.

00:29:48.596 --> 00:29:50.146 A:middle
And, of course, we have to do

00:29:50.146 --> 00:29:51.786 A:middle
the exact same thing for our

00:29:51.786 --> 00:29:52.716 A:middle
uniforms.

00:29:58.186 --> 00:29:59.466 A:middle
The next error is a little bit

00:29:59.466 --> 00:30:00.426 A:middle
more complex.

00:29:59.466 --> 00:30:00.426 A:middle
more complex.

00:30:01.106 --> 00:30:02.916 A:middle
Sampling in Metal is different,

00:30:02.916 --> 00:30:04.186 A:middle
so let's take a look.

00:30:05.336 --> 00:30:06.576 A:middle
We are going to start from

00:30:06.576 --> 00:30:07.216 A:middle
scratch.

00:30:07.956 --> 00:30:10.406 A:middle
So we directly can call a sample

00:30:10.406 --> 00:30:12.976 A:middle
function on our colorMap.

00:30:13.136 --> 00:30:15.286 A:middle
And here we can see how powerful

00:30:15.286 --> 00:30:16.416 A:middle
it is to have full auto

00:30:16.416 --> 00:30:17.016 A:middle
completion.

00:30:18.166 --> 00:30:19.736 A:middle
So this function expects us to

00:30:19.736 --> 00:30:21.586 A:middle
put in a sampler and a texture

00:30:21.586 --> 00:30:21.966 A:middle
coordinate.

00:30:21.966 --> 00:30:23.816 A:middle
We already have the texture

00:30:23.816 --> 00:30:24.246 A:middle
coordinate.

00:30:25.416 --> 00:30:27.316 A:middle
We could pass in the sampler as

00:30:27.316 --> 00:30:30.036 A:middle
an argument to our function or,

00:30:30.036 --> 00:30:31.636 A:middle
conveniently in Metal, we can

00:30:31.636 --> 00:30:33.446 A:middle
just declare one in code like

00:30:33.496 --> 00:30:33.696 A:middle
this.

00:30:34.286 --> 00:30:37.556 A:middle
We need to do the exact same

00:30:37.626 --> 00:30:39.636 A:middle
thing for our normalMap.

00:30:48.236 --> 00:30:49.296 A:middle
The last error that we are

00:30:49.416 --> 00:30:52.026 A:middle
seeing is that we are writing

00:30:52.026 --> 00:30:54.326 A:middle
into, like, one of many OpenGL

00:30:54.326 --> 00:30:55.386 A:middle
magic variables.

00:30:55.716 --> 00:30:57.256 A:middle
Instead, we are just going to

00:30:57.256 --> 00:30:59.846 A:middle
return our final computed color.

00:31:04.356 --> 00:31:06.036 A:middle
We can also see that all the

00:31:06.036 --> 00:31:07.966 A:middle
other functions, like normalize,

00:31:08.356 --> 00:31:09.936 A:middle
dot product, and my favorite

00:31:09.936 --> 00:31:12.096 A:middle
function max, are still exactly

00:31:12.096 --> 00:31:12.556 A:middle
the same.

00:31:13.976 --> 00:31:15.136 A:middle
Our shader now compiled

00:31:15.166 --> 00:31:15.946 A:middle
successfully.

00:31:16.516 --> 00:31:16.976 A:middle
Let's run it.

00:31:23.326 --> 00:31:24.486 A:middle
Something went wrong.

00:31:25.056 --> 00:31:28.436 A:middle
In OpenGL when you're

00:31:28.836 --> 00:31:30.256 A:middle
experiencing an error with your

00:31:30.256 --> 00:31:31.936 A:middle
shader, what you usually do is,

00:31:31.936 --> 00:31:33.906 A:middle
like, you look at your source

00:31:33.976 --> 00:31:36.396 A:middle
code, you look at your output,

00:31:36.836 --> 00:31:38.356 A:middle
and you think really hard.

00:31:39.146 --> 00:31:40.076 A:middle
We're just going to use the

00:31:40.076 --> 00:31:41.266 A:middle
shader debugger instead.

00:31:42.736 --> 00:31:44.106 A:middle
Clicking on the little camera

00:31:44.106 --> 00:31:46.426 A:middle
icon in the debug area will

00:31:46.426 --> 00:31:47.756 A:middle
capture a GPU trace.

00:31:48.526 --> 00:31:51.536 A:middle
This is a recording of every

00:31:51.536 --> 00:31:52.986 A:middle
Metal API call we made.

00:31:53.876 --> 00:31:55.996 A:middle
And we can now navigate to our

00:31:55.996 --> 00:31:56.826 A:middle
draw calls.

00:31:57.156 --> 00:31:58.376 A:middle
Here we are drawing the tree.

00:31:59.566 --> 00:32:00.946 A:middle
And here we are drawing the

00:31:59.566 --> 00:32:00.946 A:middle
And here we are drawing the

00:32:00.946 --> 00:32:01.416 A:middle
temple.

00:32:01.926 --> 00:32:04.616 A:middle
Let me long press on the stairs

00:32:04.616 --> 00:32:06.436 A:middle
of the temple to bring up the

00:32:06.436 --> 00:32:08.526 A:middle
pixel inspector, which allows us

00:32:08.526 --> 00:32:10.046 A:middle
to start the shader debugger.

00:32:14.116 --> 00:32:16.596 A:middle
What we are seeing here now is

00:32:16.596 --> 00:32:18.906 A:middle
the values per line for the code

00:32:18.906 --> 00:32:20.646 A:middle
that we have ported together and

00:32:20.646 --> 00:32:21.746 A:middle
for the pixel we have just

00:32:21.836 --> 00:32:22.266 A:middle
selected.

00:32:22.266 --> 00:32:24.326 A:middle
Let's take a look at our

00:32:24.326 --> 00:32:25.566 A:middle
colorMap first.

00:32:25.976 --> 00:32:29.086 A:middle
We can see this looks like a

00:32:29.086 --> 00:32:30.026 A:middle
reasonable texture.

00:32:30.206 --> 00:32:32.066 A:middle
And we can also see that our

00:32:32.146 --> 00:32:33.466 A:middle
stairs are, like, in the upper

00:32:33.466 --> 00:32:36.096 A:middle
half of this texture; however,

00:32:36.486 --> 00:32:37.896 A:middle
if we were taking a look at our

00:32:37.896 --> 00:32:40.046 A:middle
texture coordinate, we can see

00:32:40.226 --> 00:32:41.486 A:middle
that we are sampling from the

00:32:41.486 --> 00:32:43.066 A:middle
lower half.

00:32:43.126 --> 00:32:44.696 A:middle
Let me quickly verify if this is

00:32:44.696 --> 00:32:45.066 A:middle
the case.

00:32:46.376 --> 00:32:48.096 A:middle
What we are going to do is to

00:32:48.096 --> 00:32:50.846 A:middle
invert the y coordinate of our

00:32:50.846 --> 00:32:51.256 A:middle
texture.

00:32:52.056 --> 00:32:56.966 A:middle
We can now update our shaders --

00:32:57.566 --> 00:33:00.606 A:middle
looks reasonable -- and we can

00:32:57.566 --> 00:33:00.606 A:middle
looks reasonable -- and we can

00:33:00.606 --> 00:33:02.046 A:middle
continue our execution.

00:33:02.506 --> 00:33:03.496 A:middle
There, much better.

00:33:03.596 --> 00:33:08.696 A:middle
This is a pretty common error

00:33:08.746 --> 00:33:10.106 A:middle
that you will experience when

00:33:10.106 --> 00:33:11.686 A:middle
porting from OpenGL to Metal.

00:33:13.086 --> 00:33:15.096 A:middle
And, of course, the real fix is

00:33:15.096 --> 00:33:16.536 A:middle
you go into your texture loading

00:33:16.536 --> 00:33:18.396 A:middle
code and make sure your texture

00:33:18.446 --> 00:33:20.356 A:middle
is loaded at the right origin so

00:33:20.356 --> 00:33:21.726 A:middle
you don't have to do this fix in

00:33:21.726 --> 00:33:22.336 A:middle
every shader.

00:33:23.416 --> 00:33:25.466 A:middle
However, the combination of a

00:33:25.466 --> 00:33:27.536 A:middle
feature-rich editor and mighty

00:33:27.536 --> 00:33:29.686 A:middle
debugging tools will also help

00:33:29.686 --> 00:33:31.666 A:middle
you port in your games to Metal

00:33:31.666 --> 00:33:32.256 A:middle
finally.

00:33:33.676 --> 00:33:34.866 A:middle
Thank you very much.

00:33:35.386 --> 00:33:36.796 A:middle
My colleague Sarah will now

00:33:36.846 --> 00:33:37.776 A:middle
guide you through the rest of

00:33:37.816 --> 00:33:38.246 A:middle
the slides.

00:33:39.516 --> 00:33:43.616 A:middle
[ Applause ]

00:33:44.116 --> 00:33:45.066 A:middle
&gt;&gt; Sarah Clawson: Thanks, Max.

00:33:45.066 --> 00:33:46.286 A:middle
Hi, I'm Sarah Clawson.

00:33:46.286 --> 00:33:48.216 A:middle
And I'm here to take you through

00:33:48.216 --> 00:33:49.856 A:middle
the rest of the port from GL to

00:33:49.856 --> 00:33:50.076 A:middle
Metal.

00:33:50.616 --> 00:33:53.686 A:middle
So far in the life of a graphics

00:33:53.686 --> 00:33:55.116 A:middle
app, we've gone through a lot of

00:33:55.116 --> 00:33:55.366 A:middle
setup.

00:33:56.176 --> 00:33:57.796 A:middle
We've got a window to render to,

00:33:58.006 --> 00:33:59.386 A:middle
a way to get your commands to

00:33:59.386 --> 00:34:02.156 A:middle
the GPU, and a set of resources

00:33:59.386 --> 00:34:02.156 A:middle
the GPU, and a set of resources

00:34:02.326 --> 00:34:03.466 A:middle
and shaders ready to go.

00:34:04.436 --> 00:34:05.946 A:middle
Next up, we're going to talk

00:34:05.946 --> 00:34:07.596 A:middle
about setting up the state for

00:34:07.596 --> 00:34:08.726 A:middle
your render loop.

00:34:10.826 --> 00:34:13.085 A:middle
OpenGL has several key concepts

00:34:13.085 --> 00:34:13.786 A:middle
when it comes to state

00:34:13.786 --> 00:34:14.226 A:middle
management.

00:34:14.976 --> 00:34:16.786 A:middle
The vertex array object defines

00:34:16.815 --> 00:34:17.996 A:middle
both the vertex attribute

00:34:17.996 --> 00:34:19.176 A:middle
layout, as well as the vertex

00:34:19.216 --> 00:34:19.556 A:middle
buffers.

00:34:20.396 --> 00:34:21.536 A:middle
The program is a link

00:34:21.536 --> 00:34:23.056 A:middle
combination of vertex and

00:34:23.056 --> 00:34:23.735 A:middle
fragment shaders.

00:34:24.676 --> 00:34:27.235 A:middle
And the framebuffer is a set of

00:34:27.286 --> 00:34:28.446 A:middle
color and depth stencil

00:34:28.446 --> 00:34:29.476 A:middle
attachments that your

00:34:29.556 --> 00:34:30.696 A:middle
application intends to render

00:34:30.696 --> 00:34:30.876 A:middle
to.

00:34:31.946 --> 00:34:33.726 A:middle
These state objects are created

00:34:33.946 --> 00:34:35.545 A:middle
during initialization and are

00:34:35.545 --> 00:34:36.786 A:middle
used throughout your frames.

00:34:37.436 --> 00:34:40.295 A:middle
Let's walk through an example to

00:34:40.295 --> 00:34:42.946 A:middle
show how OpenGL manages state.

00:34:44.616 --> 00:34:46.106 A:middle
Here we have a sample render

00:34:46.106 --> 00:34:48.616 A:middle
loop where an OpenGL application

00:34:48.616 --> 00:34:50.656 A:middle
binds a framebuffer, sets a

00:34:50.656 --> 00:34:52.606 A:middle
program, and then makes other

00:34:52.606 --> 00:34:53.786 A:middle
state modifications, like

00:34:53.786 --> 00:34:56.005 A:middle
enabling depth, or face culling,

00:34:56.476 --> 00:34:57.746 A:middle
or changing the colorMap before

00:34:57.746 --> 00:35:00.326 A:middle
making a draw call.

00:34:57.746 --> 00:35:00.326 A:middle
making a draw call.

00:35:00.506 --> 00:35:02.216 A:middle
If you look at this same API

00:35:02.256 --> 00:35:04.176 A:middle
trace from OpenGL's perspective,

00:35:04.176 --> 00:35:06.126 A:middle
it has to track all these

00:35:06.126 --> 00:35:08.116 A:middle
changes on each API call.

00:35:08.276 --> 00:35:10.596 A:middle
And then when a draw call

00:35:10.596 --> 00:35:12.276 A:middle
happens, it has to stop and

00:35:12.276 --> 00:35:13.496 A:middle
validate to be sure that the

00:35:13.496 --> 00:35:14.916 A:middle
previous changes to primitive

00:35:14.916 --> 00:35:16.476 A:middle
assembly, depth state,

00:35:16.556 --> 00:35:18.566 A:middle
rasterizer, and programmable

00:35:18.566 --> 00:35:20.036 A:middle
stages are all compatible with

00:35:20.036 --> 00:35:20.846 A:middle
each other.

00:35:21.436 --> 00:35:23.966 A:middle
This validation can be super

00:35:23.966 --> 00:35:24.526 A:middle
expensive.

00:35:24.526 --> 00:35:26.296 A:middle
And while OpenGL does try to

00:35:26.296 --> 00:35:27.676 A:middle
minimize its negative impact,

00:35:28.066 --> 00:35:29.436 A:middle
there's limited opportunity to

00:35:29.496 --> 00:35:30.356 A:middle
do so.

00:35:31.366 --> 00:35:33.496 A:middle
It is worth noting that the open

00:35:33.496 --> 00:35:35.036 A:middle
OpenGL state objects were ahead

00:35:35.036 --> 00:35:35.856 A:middle
of the curve when they were

00:35:35.856 --> 00:35:36.556 A:middle
first introduced.

00:35:37.946 --> 00:35:39.616 A:middle
Framebuffer objects combine

00:35:39.616 --> 00:35:40.626 A:middle
attached render targets,

00:35:41.606 --> 00:35:42.936 A:middle
programs linked fragment and

00:35:42.936 --> 00:35:45.906 A:middle
vertex shaders together, and

00:35:45.906 --> 00:35:47.886 A:middle
vertex array objects were larger

00:35:47.886 --> 00:35:49.146 A:middle
objects combining some of the

00:35:49.146 --> 00:35:50.876 A:middle
vertex attribute API's and

00:35:50.876 --> 00:35:52.126 A:middle
vertex buffer setup.

00:35:52.896 --> 00:35:54.546 A:middle
But even with all these changes,

00:35:54.736 --> 00:35:55.936 A:middle
although they yielded positive

00:35:55.936 --> 00:35:58.106 A:middle
results, OpenGL still has to

00:35:58.106 --> 00:35:59.746 A:middle
validate many things on a draw

00:35:59.746 --> 00:36:04.236 A:middle
call, such as will the -- can

00:35:59.746 --> 00:36:04.236 A:middle
call, such as will the -- can

00:36:04.236 --> 00:36:05.666 A:middle
the ColorMask help optimize the

00:36:05.666 --> 00:36:06.276 A:middle
fragment shader?

00:36:06.776 --> 00:36:09.016 A:middle
Is the fragment shader output

00:36:09.016 --> 00:36:10.246 A:middle
compatible with the attached

00:36:10.246 --> 00:36:10.716 A:middle
frame buffer?

00:36:11.276 --> 00:36:14.156 A:middle
Is the vertex layout compatible

00:36:14.156 --> 00:36:15.136 A:middle
with the bound program?

00:36:16.406 --> 00:36:17.526 A:middle
Or are the attached render

00:36:17.526 --> 00:36:18.346 A:middle
targets blendable?

00:36:18.896 --> 00:36:22.036 A:middle
So as we redesigned the graphic

00:36:22.086 --> 00:36:24.206 A:middle
state management for Metal, we

00:36:24.316 --> 00:36:25.846 A:middle
took the program shaders

00:36:26.206 --> 00:36:27.966 A:middle
combined with the vertex input

00:36:27.966 --> 00:36:29.556 A:middle
layouts from the VertexArray

00:36:29.556 --> 00:36:31.906 A:middle
objects and added the

00:36:31.906 --> 00:36:33.256 A:middle
information about attachment

00:36:33.256 --> 00:36:35.486 A:middle
pixelFormat and blend state, and

00:36:35.486 --> 00:36:38.486 A:middle
we combined them into one object

00:36:38.536 --> 00:36:40.686 A:middle
called the PipelineDescriptor.

00:36:41.556 --> 00:36:43.176 A:middle
This structure describes all the

00:36:43.176 --> 00:36:45.156 A:middle
relevant states in the graphics

00:36:45.196 --> 00:36:45.596 A:middle
pipeline.

00:36:46.836 --> 00:36:48.716 A:middle
To set up the descriptor, first

00:36:49.106 --> 00:36:49.796 A:middle
you initialize it.

00:36:50.466 --> 00:36:52.146 A:middle
And then you set all the state

00:36:52.146 --> 00:36:53.486 A:middle
we just talked about, like

00:36:53.556 --> 00:36:54.796 A:middle
vertex and fragment shaders,

00:36:55.686 --> 00:36:57.336 A:middle
vertex information, pixel

00:36:57.336 --> 00:36:58.526 A:middle
formats, and blend state.

00:36:58.626 --> 00:37:01.836 A:middle
And then you take that

00:36:58.626 --> 00:37:01.836 A:middle
And then you take that

00:37:01.836 --> 00:37:03.286 A:middle
descriptor and you create what

00:37:03.286 --> 00:37:04.426 A:middle
is called a pipeline state

00:37:04.426 --> 00:37:05.766 A:middle
object or PSO.

00:37:06.636 --> 00:37:08.406 A:middle
This immutable object fully

00:37:08.406 --> 00:37:09.796 A:middle
describes the render state.

00:37:09.796 --> 00:37:11.226 A:middle
And what's great about it is

00:37:11.226 --> 00:37:12.846 A:middle
that you create it once, have it

00:37:12.846 --> 00:37:14.386 A:middle
validated for correctness, and

00:37:14.386 --> 00:37:15.326 A:middle
then use it throughout your

00:37:15.326 --> 00:37:15.696 A:middle
program.

00:37:16.276 --> 00:37:19.866 A:middle
In a similar way, we combined

00:37:19.866 --> 00:37:20.556 A:middle
all the depth and

00:37:20.556 --> 00:37:22.206 A:middle
stencil-related settings into a

00:37:22.206 --> 00:37:23.526 A:middle
depth/stencil state descriptor.

00:37:24.326 --> 00:37:26.896 A:middle
And, again, it is a collection

00:37:26.896 --> 00:37:28.266 A:middle
of all the depth/stencil state.

00:37:28.326 --> 00:37:30.186 A:middle
And you take this descriptor and

00:37:30.186 --> 00:37:32.086 A:middle
you create what's called a

00:37:32.086 --> 00:37:33.306 A:middle
depth/stensil state object.

00:37:34.496 --> 00:37:35.996 A:middle
This object is also immutable

00:37:36.096 --> 00:37:36.966 A:middle
and used throughout your

00:37:36.966 --> 00:37:37.876 A:middle
program.

00:37:38.876 --> 00:37:40.756 A:middle
So the render loop we were

00:37:40.756 --> 00:37:43.136 A:middle
looking at in OpenGL now looks

00:37:43.136 --> 00:37:44.026 A:middle
like this in Metal.

00:37:44.836 --> 00:37:46.176 A:middle
With all of the prevalidated

00:37:46.246 --> 00:37:47.906 A:middle
state objects, there's no longer

00:37:47.906 --> 00:37:49.966 A:middle
any state validation or

00:37:49.966 --> 00:37:50.396 A:middle
tracking.

00:37:51.606 --> 00:37:53.306 A:middle
Let's look through the

00:37:55.236 --> 00:37:55.566 A:middle
comparison.

00:37:55.566 --> 00:37:57.436 A:middle
In Metal, the render encoder is

00:37:57.436 --> 00:37:58.716 A:middle
the start of a render pass,

00:37:59.166 --> 00:38:00.166 A:middle
similar to binding your frame

00:37:59.166 --> 00:38:00.166 A:middle
similar to binding your frame

00:38:00.166 --> 00:38:00.446 A:middle
buffer.

00:38:01.006 --> 00:38:03.196 A:middle
Now that your depth state is

00:38:03.346 --> 00:38:05.016 A:middle
prebaked into an object, you

00:38:05.016 --> 00:38:05.966 A:middle
simply set it on the

00:38:05.966 --> 00:38:06.616 A:middle
renderEncoder.

00:38:07.176 --> 00:38:10.056 A:middle
The PipelineState object

00:38:10.056 --> 00:38:11.766 A:middle
represents and combination of

00:38:11.846 --> 00:38:13.986 A:middle
program shaders, VertexArray

00:38:13.986 --> 00:38:15.716 A:middle
properties, and a pixelFormat.

00:38:15.716 --> 00:38:17.786 A:middle
And it's also set on the

00:38:17.786 --> 00:38:18.406 A:middle
renderEncoder.

00:38:18.406 --> 00:38:21.346 A:middle
And now the renderEncoder

00:38:21.346 --> 00:38:22.846 A:middle
manages your rasterizer state

00:38:22.846 --> 00:38:23.316 A:middle
directly.

00:38:24.296 --> 00:38:25.746 A:middle
And it's important to note here

00:38:25.746 --> 00:38:27.296 A:middle
that there is still flexibility

00:38:27.296 --> 00:38:28.596 A:middle
in your pipeline, as not

00:38:28.596 --> 00:38:30.046 A:middle
everything is prebaked into your

00:38:30.046 --> 00:38:30.936 A:middle
PipelineState object.

00:38:31.356 --> 00:38:34.156 A:middle
Here's the list of state that

00:38:34.156 --> 00:38:35.336 A:middle
we've just been discussing that

00:38:35.336 --> 00:38:37.596 A:middle
you prebake into your PSO: State

00:38:37.596 --> 00:38:38.586 A:middle
like vertex and fragment

00:38:38.586 --> 00:38:39.816 A:middle
functions and pixel formats,

00:38:39.856 --> 00:38:40.156 A:middle
etc.

00:38:41.356 --> 00:38:42.956 A:middle
On the other hand, here's all

00:38:42.956 --> 00:38:44.106 A:middle
the state that you still set

00:38:44.106 --> 00:38:45.686 A:middle
while drawing -- state like

00:38:46.746 --> 00:38:47.736 A:middle
primitive culling mode and

00:38:47.736 --> 00:38:49.136 A:middle
direction, fill mode.

00:38:49.736 --> 00:38:51.216 A:middle
Scissor and viewport areas are

00:38:51.216 --> 00:38:53.156 A:middle
still set just like in OpenGL.

00:38:53.156 --> 00:38:56.906 A:middle
And ultimately, the draw calls

00:38:56.906 --> 00:38:57.446 A:middle
remain the same.

00:38:58.216 --> 00:38:59.706 A:middle
The main difference here is that

00:38:59.706 --> 00:39:01.236 A:middle
instead of enabling new state,

00:38:59.706 --> 00:39:01.236 A:middle
instead of enabling new state,

00:39:01.396 --> 00:39:02.366 A:middle
which could incur hidden

00:39:02.366 --> 00:39:04.366 A:middle
validation costs, you simply

00:39:04.446 --> 00:39:06.186 A:middle
swap out a new PipelineState

00:39:06.186 --> 00:39:07.826 A:middle
object that had blending enabled

00:39:07.906 --> 00:39:08.516 A:middle
in its descriptor.

00:39:11.186 --> 00:39:12.556 A:middle
I want to discuss one more

00:39:12.556 --> 00:39:13.876 A:middle
possible optimization that you

00:39:13.876 --> 00:39:15.916 A:middle
may have used in OpenGL in order

00:39:15.916 --> 00:39:17.636 A:middle
to hide certain expensive

00:39:18.006 --> 00:39:18.666 A:middle
operations.

00:39:19.996 --> 00:39:21.836 A:middle
As an OpenGL developer, you may

00:39:21.836 --> 00:39:23.226 A:middle
have seen that your render loop

00:39:23.296 --> 00:39:25.256 A:middle
has an unexpected hiccup on the

00:39:25.306 --> 00:39:27.316 A:middle
first draw call after making a

00:39:27.316 --> 00:39:28.206 A:middle
bunch of state changes.

00:39:29.096 --> 00:39:30.596 A:middle
And if this is the case, you

00:39:30.596 --> 00:39:32.216 A:middle
probably use an optimization to

00:39:32.216 --> 00:39:33.616 A:middle
hide that called shader

00:39:33.616 --> 00:39:34.126 A:middle
pre-warming.

00:39:35.546 --> 00:39:36.726 A:middle
In shader pre-warming, an

00:39:36.806 --> 00:39:38.346 A:middle
application uses dummy draw

00:39:38.346 --> 00:39:39.666 A:middle
calls for the most common GL

00:39:39.666 --> 00:39:42.276 A:middle
programs in order to have OpenGL

00:39:42.606 --> 00:39:43.676 A:middle
create all the state that's

00:39:43.676 --> 00:39:44.846 A:middle
necessary ahead of time.

00:39:45.856 --> 00:39:47.246 A:middle
If you were doing this in your

00:39:47.406 --> 00:39:48.706 A:middle
engine already, then it's going

00:39:48.706 --> 00:39:50.326 A:middle
to be very easy for you to

00:39:50.326 --> 00:39:54.286 A:middle
replace it with PSO creation.

00:39:54.386 --> 00:39:55.966 A:middle
Now shader pre-warming in Metal

00:39:56.296 --> 00:39:58.196 A:middle
is accomplished through creating

00:39:58.196 --> 00:39:59.476 A:middle
separate PSO objects with

00:39:59.516 --> 00:40:00.396 A:middle
different state enabled.

00:39:59.516 --> 00:40:00.396 A:middle
different state enabled.

00:40:00.876 --> 00:40:03.326 A:middle
First, you create your

00:40:03.326 --> 00:40:05.436 A:middle
descriptor, and then you set all

00:40:05.436 --> 00:40:06.776 A:middle
of the state up until the first

00:40:06.776 --> 00:40:08.316 A:middle
draw call and create your first

00:40:08.316 --> 00:40:09.276 A:middle
PipelineState object.

00:40:10.036 --> 00:40:11.596 A:middle
Then you can take that same

00:40:11.596 --> 00:40:13.146 A:middle
descriptor, change a bit of

00:40:13.206 --> 00:40:14.306 A:middle
state on it -- like here we're

00:40:14.306 --> 00:40:15.886 A:middle
enabling blending -- and you

00:40:15.886 --> 00:40:17.316 A:middle
create a second PipelineState

00:40:17.316 --> 00:40:17.706 A:middle
object.

00:40:18.966 --> 00:40:20.506 A:middle
Both of these are prevalidated

00:40:20.726 --> 00:40:22.736 A:middle
so that during draw time you can

00:40:22.736 --> 00:40:24.206 A:middle
just swap them out between draw

00:40:24.206 --> 00:40:24.466 A:middle
calls.

00:40:25.806 --> 00:40:27.036 A:middle
Hopefully if you're porting from

00:40:27.036 --> 00:40:28.826 A:middle
OpenGL to Metal, this is a

00:40:28.826 --> 00:40:29.796 A:middle
straightforward change.

00:40:29.796 --> 00:40:33.666 A:middle
Now, as we conclude the setup

00:40:33.666 --> 00:40:35.896 A:middle
stage of our application, I'd

00:40:35.896 --> 00:40:37.146 A:middle
like to bring up one of the main

00:40:37.146 --> 00:40:38.486 A:middle
benefits of porting your app

00:40:38.516 --> 00:40:40.446 A:middle
from OpenGL to Metal, and it is

00:40:40.446 --> 00:40:41.856 A:middle
that it will start doing

00:40:41.946 --> 00:40:43.896 A:middle
expensive operations less often.

00:40:44.456 --> 00:40:47.656 A:middle
In OpenGL, your application

00:40:47.656 --> 00:40:48.846 A:middle
would have to wait until draw

00:40:48.916 --> 00:40:50.686 A:middle
time in order to do things like

00:40:50.826 --> 00:40:52.146 A:middle
compile and link shaders or

00:40:52.146 --> 00:40:54.346 A:middle
validate states, which means

00:40:54.346 --> 00:40:55.846 A:middle
that these expensive operations

00:40:55.846 --> 00:40:57.396 A:middle
happen many times per frame.

00:40:57.976 --> 00:41:00.626 A:middle
Once you port your app to Metal,

00:40:57.976 --> 00:41:00.626 A:middle
Once you port your app to Metal,

00:41:01.276 --> 00:41:02.506 A:middle
your application moves these

00:41:02.506 --> 00:41:04.106 A:middle
operations to different stages

00:41:04.106 --> 00:41:04.876 A:middle
of its lifetime.

00:41:05.876 --> 00:41:07.516 A:middle
With precompiled shaders, shader

00:41:07.516 --> 00:41:09.166 A:middle
compilation has moved out of

00:41:09.166 --> 00:41:10.556 A:middle
initialization and into build

00:41:10.616 --> 00:41:11.656 A:middle
time so it's only done once.

00:41:13.046 --> 00:41:14.426 A:middle
Then with PSO's, state

00:41:14.426 --> 00:41:16.486 A:middle
definition is moved to content

00:41:16.486 --> 00:41:16.806 A:middle
loading.

00:41:17.046 --> 00:41:18.256 A:middle
So that leaves your draw time

00:41:18.316 --> 00:41:19.556 A:middle
free to actually make draw

00:41:19.556 --> 00:41:19.806 A:middle
calls.

00:41:19.806 --> 00:41:23.936 A:middle
So now that we've completed the

00:41:23.936 --> 00:41:25.516 A:middle
setup stage of your application,

00:41:25.976 --> 00:41:27.416 A:middle
let's talk about using all these

00:41:27.956 --> 00:41:30.386 A:middle
resources, shaders, and objects

00:41:30.426 --> 00:41:31.006 A:middle
to render frames.

00:41:33.396 --> 00:41:35.006 A:middle
In order to draw a single frame,

00:41:35.306 --> 00:41:36.916 A:middle
your application needs to first

00:41:37.136 --> 00:41:38.586 A:middle
update textures and buffers,

00:41:39.486 --> 00:41:40.786 A:middle
then establish a render target

00:41:40.786 --> 00:41:42.506 A:middle
to render to, and then make

00:41:42.506 --> 00:41:43.836 A:middle
several render passes before

00:41:43.836 --> 00:41:45.006 A:middle
finally presenting your work.

00:41:46.236 --> 00:41:47.656 A:middle
Let's talk about updating

00:41:47.656 --> 00:41:48.096 A:middle
resources.

00:41:49.316 --> 00:41:50.796 A:middle
Typically, at least some

00:41:50.796 --> 00:41:52.506 A:middle
resources have to be updated

00:41:52.506 --> 00:41:53.596 A:middle
continuously throughout your

00:41:53.596 --> 00:41:54.606 A:middle
render loop.

00:41:55.916 --> 00:41:57.536 A:middle
Such examples are shader

00:41:57.536 --> 00:41:59.116 A:middle
constants, vertex and index

00:41:59.146 --> 00:42:00.436 A:middle
buffers, and textures.

00:41:59.146 --> 00:42:00.436 A:middle
buffers, and textures.

00:42:00.436 --> 00:42:04.096 A:middle
And these modifications can be

00:42:04.096 --> 00:42:05.476 A:middle
accomplished between frames

00:42:05.806 --> 00:42:07.506 A:middle
through synchronization between

00:42:07.506 --> 00:42:08.586 A:middle
the GPU and the CPU.

00:42:08.586 --> 00:42:11.836 A:middle
A typical GL resource update can

00:42:12.096 --> 00:42:13.866 A:middle
be any combination of the

00:42:13.866 --> 00:42:17.126 A:middle
following calls: A buffer can be

00:42:17.126 --> 00:42:20.236 A:middle
updated by the CPU; or you can

00:42:20.236 --> 00:42:21.886 A:middle
update a buffer through the GPU

00:42:21.886 --> 00:42:23.126 A:middle
via buffer-to-buffer copy.

00:42:24.436 --> 00:42:26.416 A:middle
Similarly, a texture can be

00:42:26.416 --> 00:42:29.576 A:middle
updated by the CPU or it can be

00:42:29.576 --> 00:42:31.006 A:middle
updated via texture-to-texture

00:42:31.006 --> 00:42:32.076 A:middle
copy on the GPU.

00:42:32.536 --> 00:42:35.916 A:middle
At a glance, Metal offers

00:42:35.916 --> 00:42:36.966 A:middle
similar functionality.

00:42:37.386 --> 00:42:38.886 A:middle
But as Lionel mentioned earlier,

00:42:39.226 --> 00:42:40.466 A:middle
the containers for buffers and

00:42:40.466 --> 00:42:42.426 A:middle
textures are immutable and are

00:42:42.426 --> 00:42:43.826 A:middle
created during initialization;

00:42:44.326 --> 00:42:45.736 A:middle
however, their contents can be

00:42:45.736 --> 00:42:47.496 A:middle
modified through any combination

00:42:47.496 --> 00:42:48.096 A:middle
of the following.

00:42:48.686 --> 00:42:52.306 A:middle
A buffer with shared or managed

00:42:52.306 --> 00:42:54.086 A:middle
storage mode can be updated

00:42:54.456 --> 00:42:56.766 A:middle
through its contents property on

00:42:56.766 --> 00:42:57.246 A:middle
the CPU.

00:42:58.006 --> 00:43:00.786 A:middle
And on the GPU, the blitEncoder

00:42:58.006 --> 00:43:00.786 A:middle
And on the GPU, the blitEncoder

00:43:00.786 --> 00:43:02.426 A:middle
is in charge of doing all data

00:43:02.426 --> 00:43:02.946 A:middle
copying.

00:43:03.506 --> 00:43:05.226 A:middle
And so you can update a buffer

00:43:05.226 --> 00:43:06.996 A:middle
from the GPU via the

00:43:07.036 --> 00:43:08.916 A:middle
copyFromBuffer methods on the

00:43:08.916 --> 00:43:09.436 A:middle
blitEncoder.

00:43:10.896 --> 00:43:12.766 A:middle
Similarly, a texture with shared

00:43:12.766 --> 00:43:14.296 A:middle
or managed storage mode can be

00:43:14.296 --> 00:43:16.056 A:middle
updated on the CPU through its

00:43:16.056 --> 00:43:17.056 A:middle
replaceRegion method.

00:43:18.246 --> 00:43:20.436 A:middle
Or on the GPU, you can update a

00:43:20.436 --> 00:43:21.416 A:middle
texture through the

00:43:21.706 --> 00:43:23.186 A:middle
copyFromTexture methods on the

00:43:23.186 --> 00:43:23.716 A:middle
blitEncoder.

00:43:24.246 --> 00:43:27.646 A:middle
Note that storage mode matters

00:43:27.726 --> 00:43:28.746 A:middle
here when it comes to these

00:43:28.746 --> 00:43:31.236 A:middle
updates as only buffers and

00:43:31.236 --> 00:43:32.506 A:middle
textures with shared or managed

00:43:32.506 --> 00:43:33.976 A:middle
storage modes can be updated by

00:43:34.216 --> 00:43:35.000 A:middle
the CPU.

00:43:37.326 --> 00:43:38.406 A:middle
OpenGL managed the

00:43:38.406 --> 00:43:39.906 A:middle
synchronization between the GPU

00:43:39.906 --> 00:43:41.156 A:middle
and CPU for you, though

00:43:41.226 --> 00:43:42.886 A:middle
sometimes at exorbitant costs to

00:43:42.886 --> 00:43:44.156 A:middle
your application as it waited

00:43:44.156 --> 00:43:45.446 A:middle
for one or the other to be done.

00:43:46.736 --> 00:43:48.336 A:middle
In Metal, because you control

00:43:48.396 --> 00:43:49.936 A:middle
how the memory is stored, you

00:43:49.936 --> 00:43:51.746 A:middle
also control how and when the

00:43:51.746 --> 00:43:52.606 A:middle
data is synchronized.

00:43:53.156 --> 00:43:54.076 A:middle
And this is true for both

00:43:54.076 --> 00:43:54.926 A:middle
buffers and textures.

00:43:55.656 --> 00:43:59.676 A:middle
If you port your GL app to Metal

00:43:59.676 --> 00:44:01.956 A:middle
and only use a single buffer for

00:43:59.676 --> 00:44:01.956 A:middle
and only use a single buffer for

00:44:01.956 --> 00:44:03.806 A:middle
your resource updates, the flow

00:44:03.806 --> 00:44:06.306 A:middle
will look like this.

00:44:06.506 --> 00:44:08.176 A:middle
First, your CPU will update your

00:44:08.176 --> 00:44:09.706 A:middle
resources during the setup of a

00:44:09.706 --> 00:44:10.106 A:middle
render pass.

00:44:10.846 --> 00:44:12.046 A:middle
And then once complete, the

00:44:12.046 --> 00:44:13.346 A:middle
buffer will be available for the

00:44:13.346 --> 00:44:15.006 A:middle
GPU to consume during the

00:44:15.006 --> 00:44:16.326 A:middle
execution of that render pass.

00:44:17.086 --> 00:44:18.886 A:middle
However, while the GPU is

00:44:18.886 --> 00:44:20.056 A:middle
reading from this buffer, the

00:44:20.056 --> 00:44:21.736 A:middle
CPU may begin setting up for the

00:44:21.736 --> 00:44:22.826 A:middle
following render pass and will

00:44:22.826 --> 00:44:24.126 A:middle
need to update the same buffer,

00:44:25.056 --> 00:44:26.666 A:middle
which is a clear race condition.

00:44:27.646 --> 00:44:28.886 A:middle
So let's look at one approach to

00:44:28.886 --> 00:44:29.606 A:middle
solve this problem.

00:44:30.186 --> 00:44:32.436 A:middle
A simple solution would be to

00:44:32.436 --> 00:44:34.466 A:middle
commit this resource to the GPU

00:44:34.766 --> 00:44:36.906 A:middle
with the waitUntilCompleted call

00:44:37.026 --> 00:44:38.246 A:middle
on the commandBuffer it is used

00:44:38.246 --> 00:44:38.426 A:middle
in.

00:44:39.466 --> 00:44:40.766 A:middle
As we discussed earlier, this is

00:44:40.816 --> 00:44:43.456 A:middle
similar to glFinish and it

00:44:43.456 --> 00:44:45.456 A:middle
places a semaphore on all CPU

00:44:45.456 --> 00:44:47.176 A:middle
work until the GPU is done

00:44:47.346 --> 00:44:49.256 A:middle
executing the render pass that

00:44:49.256 --> 00:44:49.926 A:middle
uses that buffer.

00:44:49.986 --> 00:44:52.506 A:middle
After the execution is

00:44:52.506 --> 00:44:54.336 A:middle
completed, a call back is

00:44:54.336 --> 00:44:56.476 A:middle
received from the GPU, and this

00:44:56.476 --> 00:44:58.046 A:middle
way you can ensure that your

00:44:58.046 --> 00:44:59.466 A:middle
single buffer will not be

00:44:59.466 --> 00:45:01.476 A:middle
stomped on by the CPU or the

00:44:59.466 --> 00:45:01.476 A:middle
stomped on by the CPU or the

00:45:01.476 --> 00:45:02.006 A:middle
GPU.

00:45:03.536 --> 00:45:07.416 A:middle
However, as you can see, the CPU

00:45:07.416 --> 00:45:09.016 A:middle
is idle while the GPU is

00:45:09.016 --> 00:45:10.996 A:middle
executing, and the GPU is

00:45:10.996 --> 00:45:12.476 A:middle
starved waiting for the CPU to

00:45:12.476 --> 00:45:12.946 A:middle
commit work.

00:45:13.786 --> 00:45:15.266 A:middle
So while this can be helpful for

00:45:15.266 --> 00:45:16.506 A:middle
you at the beginning while

00:45:16.506 --> 00:45:18.036 A:middle
you're working out these race

00:45:18.036 --> 00:45:19.426 A:middle
conditions, it is not

00:45:19.426 --> 00:45:20.446 A:middle
recommended to use

00:45:20.446 --> 00:45:21.766 A:middle
waitUntilCompleted as it

00:45:21.766 --> 00:45:23.126 A:middle
introduces latency into your

00:45:23.126 --> 00:45:24.146 A:middle
program.

00:45:25.136 --> 00:45:27.646 A:middle
Instead, an efficient way to

00:45:27.716 --> 00:45:29.526 A:middle
synchronize your updates is to

00:45:29.526 --> 00:45:30.826 A:middle
use two or more buffers

00:45:31.796 --> 00:45:32.986 A:middle
depending on your application's

00:45:32.986 --> 00:45:34.776 A:middle
needs so that the CPU can write

00:45:34.876 --> 00:45:36.616 A:middle
to one while the GPU reads from

00:45:36.616 --> 00:45:36.946 A:middle
another.

00:45:38.126 --> 00:45:39.406 A:middle
Let's look at a simple triple

00:45:39.406 --> 00:45:40.286 A:middle
buffering example.

00:45:40.756 --> 00:45:43.736 A:middle
So here we start with the first

00:45:43.736 --> 00:45:45.596 A:middle
resource ready to go for the --

00:45:45.956 --> 00:45:48.006 A:middle
to be consumed by the GPU.

00:45:48.856 --> 00:45:49.566 A:middle
But instead of

00:45:49.636 --> 00:45:51.346 A:middle
waitUntilCompleted, we just add

00:45:51.346 --> 00:45:53.826 A:middle
a completion handler so that

00:45:53.826 --> 00:45:55.196 A:middle
once the corresponding frame is

00:45:55.196 --> 00:45:57.006 A:middle
finished on the GPU, it can let

00:45:57.006 --> 00:46:00.156 A:middle
the CPU know that it is done.

00:45:57.006 --> 00:46:00.156 A:middle
the CPU know that it is done.

00:46:00.236 --> 00:46:01.466 A:middle
But now we don't have to wait

00:46:01.666 --> 00:46:02.456 A:middle
for it to be done.

00:46:03.546 --> 00:46:04.976 A:middle
While the GPU is executing, with

00:46:04.976 --> 00:46:06.286 A:middle
triple buffering the CPU can

00:46:06.286 --> 00:46:08.686 A:middle
jump two updates ahead because

00:46:08.686 --> 00:46:09.656 A:middle
it's in different buffers.

00:46:11.046 --> 00:46:12.906 A:middle
So here we are with the -- with

00:46:12.906 --> 00:46:15.036 A:middle
the frame done executing on the

00:46:15.036 --> 00:46:17.106 A:middle
GPU, and this is where the

00:46:17.106 --> 00:46:18.176 A:middle
completion handler comes in.

00:46:19.106 --> 00:46:20.606 A:middle
It notifies that GPU work is

00:46:20.606 --> 00:46:22.016 A:middle
done and then returns the buffer

00:46:22.016 --> 00:46:24.676 A:middle
to the buffer pool so that it

00:46:24.676 --> 00:46:26.796 A:middle
can be used by the CPU in the

00:46:26.796 --> 00:46:28.096 A:middle
next frame while the GPU

00:46:28.096 --> 00:46:29.166 A:middle
continues execution.

00:46:29.636 --> 00:46:31.586 A:middle
I think most developers will

00:46:31.586 --> 00:46:32.456 A:middle
find that they'll need to

00:46:32.456 --> 00:46:33.876 A:middle
implement triple buffering to

00:46:33.876 --> 00:46:35.056 A:middle
achieve optimal performance.

00:46:35.536 --> 00:46:38.996 A:middle
As for implementation, for

00:46:38.996 --> 00:46:40.106 A:middle
triple buffering, of course, you

00:46:40.106 --> 00:46:41.116 A:middle
need to start with a queue of

00:46:41.266 --> 00:46:41.856 A:middle
three buffers.

00:46:43.706 --> 00:46:45.266 A:middle
You also need to initialize your

00:46:45.306 --> 00:46:46.726 A:middle
frameBoundarySemaphore with a

00:46:46.726 --> 00:46:47.676 A:middle
starting value of three.

00:46:47.676 --> 00:46:49.616 A:middle
And this semaphore will be

00:46:49.616 --> 00:46:51.616 A:middle
signaled at each frame boundary

00:46:51.616 --> 00:46:53.166 A:middle
when the GPU is done executing,

00:46:54.016 --> 00:46:55.336 A:middle
letting the CPU know that it is

00:46:55.336 --> 00:46:56.596 A:middle
safe to override that buffer.

00:46:57.026 --> 00:46:59.466 A:middle
And finally, we need to

00:46:59.466 --> 00:47:01.016 A:middle
initialize the buffer index to

00:46:59.466 --> 00:47:01.016 A:middle
initialize the buffer index to

00:47:01.016 --> 00:47:03.146 A:middle
point at the current frame's

00:47:03.996 --> 00:47:04.136 A:middle
buffer.

00:47:04.316 --> 00:47:06.696 A:middle
Inside the render loop, before

00:47:06.696 --> 00:47:08.026 A:middle
we write to a buffer, we need to

00:47:08.026 --> 00:47:09.456 A:middle
ensure that the GPU is

00:47:09.546 --> 00:47:11.506 A:middle
completely done executing the

00:47:11.506 --> 00:47:12.446 A:middle
corresponding frame.

00:47:13.666 --> 00:47:15.086 A:middle
So at the beginning of each

00:47:15.536 --> 00:47:17.746 A:middle
render pass, we need to wait on

00:47:17.746 --> 00:47:18.976 A:middle
our frameBoundarySemaphore.

00:47:18.976 --> 00:47:20.966 A:middle
And then once the signal has

00:47:20.996 --> 00:47:23.316 A:middle
been received, we know that it's

00:47:23.376 --> 00:47:24.536 A:middle
safe to grab its buffer and

00:47:24.536 --> 00:47:25.626 A:middle
reuse it for new frame data.

00:47:26.216 --> 00:47:29.946 A:middle
And now we encode commands and

00:47:29.946 --> 00:47:31.806 A:middle
bind this resource to the GPU to

00:47:31.806 --> 00:47:33.466 A:middle
be used in the next frame.

00:47:34.556 --> 00:47:36.026 A:middle
But before we commit it, we have

00:47:36.026 --> 00:47:37.386 A:middle
to add our completion handler to

00:47:37.386 --> 00:47:39.876 A:middle
the commandBuffer and then we

00:47:39.876 --> 00:47:40.906 A:middle
commit it.

00:47:41.636 --> 00:47:43.116 A:middle
And once the GPU has finished

00:47:43.116 --> 00:47:44.446 A:middle
executing, our completion

00:47:44.486 --> 00:47:46.006 A:middle
handler will signal our frame

00:47:46.066 --> 00:47:48.436 A:middle
semaphore, allowing the CPU to

00:47:48.436 --> 00:47:49.766 A:middle
know that it is done and it can

00:47:49.766 --> 00:47:50.936 A:middle
reuse the buffer for the next

00:47:50.936 --> 00:47:51.596 A:middle
frame's encoding.

00:47:52.146 --> 00:47:54.816 A:middle
And this is a simple triple

00:47:54.816 --> 00:47:56.886 A:middle
buffer implementation that you

00:47:56.886 --> 00:47:58.446 A:middle
can adopt for any dynamic

00:47:58.536 --> 00:47:59.256 A:middle
resource updates.

00:47:59.796 --> 00:47:59.896 A:middle
Okay.

00:48:01.176 --> 00:48:04.186 A:middle
So now we have our resources

00:48:04.186 --> 00:48:06.146 A:middle
updated, so let's talk about

00:48:06.146 --> 00:48:07.026 A:middle
render targets.

00:48:08.196 --> 00:48:10.456 A:middle
In OpenGL, framebuffer objects

00:48:10.456 --> 00:48:11.716 A:middle
are the destination for

00:48:11.716 --> 00:48:12.386 A:middle
rendering commands.

00:48:13.416 --> 00:48:14.896 A:middle
An FBO collects a number of

00:48:14.946 --> 00:48:16.136 A:middle
textures and render buffer

00:48:16.136 --> 00:48:17.596 A:middle
objects under one umbrella and

00:48:17.596 --> 00:48:19.516 A:middle
facilitates rendering into them.

00:48:20.076 --> 00:48:21.576 A:middle
The state of a framebuffer is

00:48:21.576 --> 00:48:23.736 A:middle
mutable, and the render pass is

00:48:23.736 --> 00:48:25.116 A:middle
loosely outlined by binding a

00:48:25.176 --> 00:48:26.346 A:middle
framebuffer and ultimately

00:48:26.416 --> 00:48:27.306 A:middle
swapping them for display.

00:48:27.406 --> 00:48:30.756 A:middle
This is a typical OpenGL

00:48:30.756 --> 00:48:32.066 A:middle
workflow with framebuffers.

00:48:33.566 --> 00:48:34.506 A:middle
During the application's

00:48:34.506 --> 00:48:36.036 A:middle
initialization stage, a

00:48:36.036 --> 00:48:37.126 A:middle
framebuffer is created.

00:48:37.386 --> 00:48:38.836 A:middle
And then you make it current by

00:48:38.836 --> 00:48:39.206 A:middle
binding it.

00:48:39.206 --> 00:48:41.546 A:middle
And then you attach resources

00:48:41.546 --> 00:48:43.106 A:middle
like textures and then check the

00:48:43.106 --> 00:48:44.336 A:middle
framebuffer status to make sure

00:48:44.336 --> 00:48:45.706 A:middle
it's valid to use.

00:48:46.976 --> 00:48:49.056 A:middle
During draw time, you make a

00:48:49.056 --> 00:48:50.246 A:middle
framebuffer current by binding

00:48:50.246 --> 00:48:51.956 A:middle
it, which is implicit start to a

00:48:51.956 --> 00:48:52.466 A:middle
render pass.

00:48:53.236 --> 00:48:54.566 A:middle
And then you have to clear it

00:48:55.286 --> 00:48:56.746 A:middle
before you make any draw calls

00:48:56.826 --> 00:48:57.086 A:middle
to it.

00:48:57.086 --> 00:48:59.796 A:middle
And then at the end you can

00:48:59.886 --> 00:49:01.296 A:middle
signal that certain attachments

00:48:59.886 --> 00:49:01.296 A:middle
signal that certain attachments

00:49:01.296 --> 00:49:03.276 A:middle
can be discarded to let OpenGL

00:49:03.276 --> 00:49:04.606 A:middle
know that it's not necessary to

00:49:04.606 --> 00:49:05.596 A:middle
store these contents into

00:49:05.596 --> 00:49:05.976 A:middle
memory.

00:49:06.796 --> 00:49:08.396 A:middle
These discard events can serve

00:49:09.146 --> 00:49:11.036 A:middle
as hints to end the render pass,

00:49:11.416 --> 00:49:12.506 A:middle
but it's not a guarantee.

00:49:15.536 --> 00:49:17.286 A:middle
In Metal, the render command

00:49:17.286 --> 00:49:18.886 A:middle
encoder is the destination for

00:49:18.886 --> 00:49:19.546 A:middle
rendering commands.

00:49:20.506 --> 00:49:21.686 A:middle
A render command encoder is

00:49:21.686 --> 00:49:22.776 A:middle
created from a render pass

00:49:22.776 --> 00:49:24.826 A:middle
descriptor, which, similar to an

00:49:24.996 --> 00:49:26.496 A:middle
FBO, collects a number of

00:49:26.546 --> 00:49:27.746 A:middle
rendering destinations for a

00:49:27.746 --> 00:49:28.976 A:middle
render pass and facilitates

00:49:28.976 --> 00:49:29.616 A:middle
rendering into them.

00:49:30.966 --> 00:49:32.116 A:middle
A render command encoder is

00:49:32.116 --> 00:49:33.346 A:middle
directly responsible for

00:49:33.376 --> 00:49:34.666 A:middle
generating the hardware commands

00:49:34.666 --> 00:49:36.736 A:middle
for your GPU, and a render pass

00:49:36.736 --> 00:49:38.496 A:middle
is explicitly delineated by the

00:49:38.556 --> 00:49:39.926 A:middle
starting and ending of encoders.

00:49:40.496 --> 00:49:43.296 A:middle
Here's a render pass in Metal.

00:49:44.356 --> 00:49:45.426 A:middle
You start by creating your

00:49:45.426 --> 00:49:46.306 A:middle
renderPassDescriptor.

00:49:46.306 --> 00:49:48.686 A:middle
And the renderPassDescriptor

00:49:48.686 --> 00:49:49.986 A:middle
describes all the attached

00:49:50.176 --> 00:49:52.936 A:middle
resources and also specifies the

00:49:52.936 --> 00:49:54.076 A:middle
operations that happen at the

00:49:54.076 --> 00:49:55.316 A:middle
beginning and end of a render

00:49:55.316 --> 00:49:57.266 A:middle
pass -- these are called load

00:49:57.266 --> 00:49:58.176 A:middle
and store actions.

00:49:59.086 --> 00:50:01.736 A:middle
In contrast to GL, in Metal you

00:49:59.086 --> 00:50:01.736 A:middle
In contrast to GL, in Metal you

00:50:01.736 --> 00:50:03.146 A:middle
do not clear a resource

00:50:03.216 --> 00:50:06.106 A:middle
directly; instead, you specify a

00:50:06.106 --> 00:50:07.996 A:middle
load action to clear it and also

00:50:07.996 --> 00:50:08.406 A:middle
the color.

00:50:08.936 --> 00:50:11.756 A:middle
Here, it is black.

00:50:11.756 --> 00:50:13.586 A:middle
The store action here is don't

00:50:13.626 --> 00:50:16.296 A:middle
care, which is similar to GL

00:50:16.296 --> 00:50:17.876 A:middle
discard framebuffer in our GL

00:50:17.876 --> 00:50:18.306 A:middle
example.

00:50:19.646 --> 00:50:21.016 A:middle
If you want to store the results

00:50:21.016 --> 00:50:21.946 A:middle
to memory, you would use the

00:50:21.946 --> 00:50:23.146 A:middle
store action here instead.

00:50:23.686 --> 00:50:27.266 A:middle
And at render time, you use your

00:50:27.266 --> 00:50:28.306 A:middle
descriptor to create your

00:50:28.306 --> 00:50:31.016 A:middle
encoder so the state is set.

00:50:31.226 --> 00:50:33.136 A:middle
You make all your draw calls and

00:50:33.136 --> 00:50:34.956 A:middle
then explicitly end encoding.

00:50:35.436 --> 00:50:37.436 A:middle
But before discarding

00:50:37.436 --> 00:50:39.336 A:middle
framebuffers or ending encoding,

00:50:39.676 --> 00:50:40.976 A:middle
let's actually draw something.

00:50:41.986 --> 00:50:44.366 A:middle
A series of render commands is

00:50:44.366 --> 00:50:45.546 A:middle
often referred to as a render

00:50:45.546 --> 00:50:45.706 A:middle
pass.

00:50:46.866 --> 00:50:48.336 A:middle
Inside the render pass, you set

00:50:48.336 --> 00:50:49.596 A:middle
up state and draw call inputs

00:50:49.596 --> 00:50:51.186 A:middle
like textures and buffers and

00:50:51.186 --> 00:50:52.916 A:middle
then issue your draw commands.

00:50:54.016 --> 00:50:56.176 A:middle
This is a typical OpenGL draw

00:50:56.246 --> 00:50:56.536 A:middle
sequence.

00:50:57.706 --> 00:50:59.606 A:middle
A well-behaved OpenGL app tries

00:50:59.606 --> 00:51:00.856 A:middle
to set all of its state ahead of

00:50:59.606 --> 00:51:00.856 A:middle
to set all of its state ahead of

00:51:00.896 --> 00:51:03.236 A:middle
time, and then it binds its

00:51:03.566 --> 00:51:07.476 A:middle
target and a GL program to link

00:51:07.476 --> 00:51:07.826 A:middle
shaders.

00:51:08.446 --> 00:51:11.166 A:middle
Then it will bind resources such

00:51:11.166 --> 00:51:13.086 A:middle
as vertex buffers, uniforms, and

00:51:13.086 --> 00:51:14.696 A:middle
textures to different stages in

00:51:14.696 --> 00:51:15.216 A:middle
the program.

00:51:16.576 --> 00:51:17.846 A:middle
And finally, it will draw.

00:51:21.356 --> 00:51:22.806 A:middle
As we've discussed a few moments

00:51:22.806 --> 00:51:25.216 A:middle
ago, OpenGL state changes can

00:51:25.216 --> 00:51:26.336 A:middle
cause hidden validation checks.

00:51:26.336 --> 00:51:28.266 A:middle
And if you're already grouping

00:51:28.266 --> 00:51:29.896 A:middle
your state changes together in

00:51:29.896 --> 00:51:31.146 A:middle
OpenGL to avoid these

00:51:31.196 --> 00:51:32.596 A:middle
performance hits, then you'll

00:51:32.596 --> 00:51:33.916 A:middle
get the most out of Metal's

00:51:34.186 --> 00:51:35.456 A:middle
pre-validated state objects.

00:51:36.846 --> 00:51:38.636 A:middle
In Metal, because validation

00:51:38.636 --> 00:51:39.776 A:middle
only happens when you create

00:51:39.776 --> 00:51:41.376 A:middle
your PipelineState object and

00:51:41.376 --> 00:51:42.926 A:middle
because shaders are precompiled,

00:51:43.296 --> 00:51:44.696 A:middle
your render loop becomes much

00:51:44.926 --> 00:51:45.276 A:middle
smaller.

00:51:45.866 --> 00:51:48.446 A:middle
But for a programmer, there's

00:51:48.476 --> 00:51:49.706 A:middle
not that many changes to do.

00:51:50.866 --> 00:51:52.326 A:middle
Here is the same code that we

00:51:52.326 --> 00:51:53.576 A:middle
looked at in OpenGL but now in

00:51:53.576 --> 00:51:53.846 A:middle
Metal.

00:51:55.586 --> 00:51:57.006 A:middle
You start with your render

00:51:57.006 --> 00:51:58.776 A:middle
command encoder, which is an

00:51:58.776 --> 00:51:59.946 A:middle
equivalent to setting the GL

00:51:59.946 --> 00:52:00.486 A:middle
framebuffer.

00:51:59.946 --> 00:52:00.486 A:middle
framebuffer.

00:52:00.486 --> 00:52:03.696 A:middle
And then you set your prebuilt

00:52:03.696 --> 00:52:05.026 A:middle
PipelineState object, which is

00:52:05.026 --> 00:52:06.466 A:middle
equivalent to GL use program.

00:52:06.656 --> 00:52:09.356 A:middle
And after that, we assign

00:52:09.356 --> 00:52:10.776 A:middle
resources for our Metal program,

00:52:10.966 --> 00:52:12.196 A:middle
starting with the VertexBuffer

00:52:12.696 --> 00:52:13.346 A:middle
and uniforms.

00:52:13.946 --> 00:52:15.366 A:middle
And you can note here that you

00:52:15.366 --> 00:52:16.986 A:middle
have to set your uniforms per

00:52:17.506 --> 00:52:20.326 A:middle
shader stage instead of like in

00:52:20.326 --> 00:52:22.116 A:middle
GL you set it for the GL

00:52:22.116 --> 00:52:22.586 A:middle
program.

00:52:23.726 --> 00:52:24.936 A:middle
And here, because we ported it

00:52:24.936 --> 00:52:26.256 A:middle
directly from OpenGL, we're

00:52:26.256 --> 00:52:27.216 A:middle
sending the same set of

00:52:27.216 --> 00:52:29.726 A:middle
uniforms; but in Metal you can

00:52:29.726 --> 00:52:30.876 A:middle
send different ones if you want.

00:52:31.236 --> 00:52:33.506 A:middle
And then you set your textures

00:52:33.506 --> 00:52:35.306 A:middle
and issue the draw call.

00:52:35.366 --> 00:52:36.816 A:middle
And finally, once you've done

00:52:36.876 --> 00:52:38.376 A:middle
all the draw calls, you can end

00:52:38.376 --> 00:52:39.626 A:middle
your render pass.

00:52:41.776 --> 00:52:43.146 A:middle
And now, once the work is

00:52:43.196 --> 00:52:44.586 A:middle
submitted, there's still the

00:52:44.586 --> 00:52:45.526 A:middle
matter of presenting.

00:52:46.156 --> 00:52:49.716 A:middle
As the GPU renders the scene, it

00:52:49.716 --> 00:52:50.796 A:middle
writes out to a framebuffer to

00:52:50.796 --> 00:52:51.136 A:middle
display.

00:52:52.236 --> 00:52:54.516 A:middle
In OpenGL, in order to present a

00:52:54.516 --> 00:52:56.746 A:middle
rendered frame, when you return

00:52:56.746 --> 00:52:58.386 A:middle
from drawInRect, the context

00:52:58.746 --> 00:53:00.536 A:middle
calls the presetRenderBuffer for

00:52:58.746 --> 00:53:00.536 A:middle
calls the presetRenderBuffer for

00:53:00.536 --> 00:53:00.706 A:middle
you.

00:53:01.906 --> 00:53:03.136 A:middle
Metal, on the other hand,

00:53:03.136 --> 00:53:04.596 A:middle
accomplishes this directly

00:53:04.656 --> 00:53:06.046 A:middle
through Core Animations pool of

00:53:06.046 --> 00:53:06.486 A:middle
drawables.

00:53:07.296 --> 00:53:08.796 A:middle
And drawables are textures for

00:53:08.796 --> 00:53:09.646 A:middle
on-screen display.

00:53:10.206 --> 00:53:13.036 A:middle
And you can encode a render pass

00:53:13.086 --> 00:53:14.076 A:middle
to encode to drawables.

00:53:15.126 --> 00:53:16.376 A:middle
You fetch the current drawable,

00:53:16.376 --> 00:53:17.726 A:middle
and then after your render loop

00:53:18.036 --> 00:53:19.216 A:middle
tell the command buffer to

00:53:19.216 --> 00:53:22.146 A:middle
present it.

00:53:22.346 --> 00:53:24.126 A:middle
Remember our code from the very,

00:53:24.126 --> 00:53:26.296 A:middle
very beginning of this talk when

00:53:26.296 --> 00:53:27.306 A:middle
we were talking about the

00:53:27.306 --> 00:53:28.156 A:middle
windows subsystem.

00:53:29.006 --> 00:53:30.396 A:middle
Here we're going to dive into

00:53:30.396 --> 00:53:33.856 A:middle
glkView and drawInMTKView to see

00:53:33.916 --> 00:53:34.916 A:middle
how you can present what you've

00:53:34.916 --> 00:53:35.196 A:middle
rendered.

00:53:35.806 --> 00:53:37.956 A:middle
So here it is.

00:53:38.706 --> 00:53:40.396 A:middle
In glkView you bind your

00:53:40.396 --> 00:53:42.336 A:middle
framebuffer; perform your render

00:53:42.336 --> 00:53:43.986 A:middle
commands; and then when you

00:53:43.986 --> 00:53:45.466 A:middle
return from drawInRect, the

00:53:45.466 --> 00:53:46.546 A:middle
present is managed for you.

00:53:47.996 --> 00:53:49.926 A:middle
In Metal it's much the same: You

00:53:49.926 --> 00:53:51.186 A:middle
create your commandBuffer,

00:53:51.586 --> 00:53:52.916 A:middle
perform your render commands by

00:53:52.916 --> 00:53:55.456 A:middle
creating ending encoders, and

00:53:55.456 --> 00:53:56.796 A:middle
then the one extra step you have

00:53:56.836 --> 00:53:58.966 A:middle
to take is to call

00:53:58.966 --> 00:54:00.926 A:middle
presentDrawable yourself before

00:53:58.966 --> 00:54:00.926 A:middle
presentDrawable yourself before

00:54:00.926 --> 00:54:01.766 A:middle
finally committing your

00:54:02.096 --> 00:54:02.726 A:middle
commandBuffer.

00:54:02.776 --> 00:54:05.416 A:middle
And if your render loop is very

00:54:05.416 --> 00:54:06.806 A:middle
simple with a single encoder,

00:54:07.126 --> 00:54:08.296 A:middle
then this is all you have to do;

00:54:09.066 --> 00:54:10.446 A:middle
however, if you do have a more

00:54:10.446 --> 00:54:12.106 A:middle
complex app, you may want to

00:54:12.106 --> 00:54:13.416 A:middle
check out the talk we have on

00:54:13.416 --> 00:54:14.956 A:middle
delivering optimized Metal apps

00:54:14.956 --> 00:54:16.716 A:middle
and games for how to handle your

00:54:16.716 --> 00:54:17.166 A:middle
drawables.

00:54:17.166 --> 00:54:20.346 A:middle
And that concludes our frame.

00:54:20.706 --> 00:54:21.776 A:middle
So we've shown how the window

00:54:21.776 --> 00:54:23.156 A:middle
subsystem can be migrated

00:54:23.156 --> 00:54:23.626 A:middle
easily.

00:54:24.446 --> 00:54:25.706 A:middle
We've gone over the resource

00:54:25.706 --> 00:54:26.406 A:middle
creation steps.

00:54:26.956 --> 00:54:28.456 A:middle
We've ported our shaders and

00:54:28.456 --> 00:54:29.916 A:middle
used the great tools to quickly

00:54:29.916 --> 00:54:30.586 A:middle
find issues.

00:54:31.136 --> 00:54:33.596 A:middle
We created our render command

00:54:33.656 --> 00:54:34.946 A:middle
queue, command buffers, and

00:54:34.946 --> 00:54:36.516 A:middle
command encoders to set up our

00:54:36.516 --> 00:54:37.266 A:middle
render passes.

00:54:37.516 --> 00:54:39.036 A:middle
And we created our prevalidated

00:54:39.036 --> 00:54:39.726 A:middle
state objects.

00:54:40.166 --> 00:54:42.496 A:middle
Then to render each frame, we

00:54:42.496 --> 00:54:43.866 A:middle
used triple buffering to update

00:54:43.866 --> 00:54:44.626 A:middle
our resources.

00:54:45.576 --> 00:54:46.536 A:middle
We used the render command

00:54:46.536 --> 00:54:47.936 A:middle
encoders for our command -- for

00:54:47.936 --> 00:54:49.706 A:middle
our render passes where we drew

00:54:49.706 --> 00:54:51.776 A:middle
our geometry before ultimately

00:54:51.816 --> 00:54:53.156 A:middle
presenting the rendered frame.

00:54:53.696 --> 00:54:56.106 A:middle
We've walked through the life of

00:54:56.106 --> 00:54:57.516 A:middle
a graphics app and showed how

00:54:57.516 --> 00:54:59.066 A:middle
Metal is a natural evolution.

00:54:59.906 --> 00:55:01.936 A:middle
Many of OpenGL's established

00:54:59.906 --> 00:55:01.936 A:middle
Many of OpenGL's established

00:55:02.286 --> 00:55:03.866 A:middle
concepts have migrated into

00:55:03.866 --> 00:55:05.476 A:middle
Metal to work alongside new

00:55:05.476 --> 00:55:07.136 A:middle
concepts that we've added to

00:55:07.136 --> 00:55:09.156 A:middle
address specific problems raised

00:55:09.156 --> 00:55:10.066 A:middle
in the graphics community.

00:55:11.086 --> 00:55:12.756 A:middle
If you can take one thing away

00:55:12.756 --> 00:55:14.296 A:middle
from this session, we hope it's

00:55:14.296 --> 00:55:15.706 A:middle
that porting your applications

00:55:15.706 --> 00:55:17.516 A:middle
from OpenGL to Metal is not

00:55:17.516 --> 00:55:19.246 A:middle
intimidating and that your

00:55:19.246 --> 00:55:20.896 A:middle
application will actually

00:55:20.896 --> 00:55:21.626 A:middle
benefit from it.

00:55:23.006 --> 00:55:24.666 A:middle
But if you have room for two

00:55:24.666 --> 00:55:26.596 A:middle
things, it's that Metal also

00:55:26.596 --> 00:55:28.516 A:middle
offers an awesome set of tools

00:55:29.626 --> 00:55:30.846 A:middle
to enhance your developing

00:55:30.846 --> 00:55:31.326 A:middle
experience.

00:55:32.226 --> 00:55:34.736 A:middle
Max already demoed Xcode's

00:55:34.736 --> 00:55:35.836 A:middle
built-in frame capture and

00:55:35.836 --> 00:55:38.756 A:middle
shader debugger to offer deeper

00:55:38.756 --> 00:55:40.166 A:middle
insight into subtle issues

00:55:40.166 --> 00:55:40.866 A:middle
within your code.

00:55:41.366 --> 00:55:43.456 A:middle
But Xcode also offers the new

00:55:43.456 --> 00:55:46.076 A:middle
GPU memory viewer to understand

00:55:46.076 --> 00:55:47.796 A:middle
and optimize how to use memory

00:55:47.796 --> 00:55:48.566 A:middle
in your application.

00:55:50.026 --> 00:55:51.406 A:middle
In instruments we have a game

00:55:51.406 --> 00:55:52.456 A:middle
performance template that

00:55:52.456 --> 00:55:53.826 A:middle
includes the Metal system trace

00:55:54.256 --> 00:55:56.016 A:middle
to visualize submission issues

00:55:56.466 --> 00:55:57.826 A:middle
which might cause frame drops.

00:55:59.216 --> 00:56:02.246 A:middle
And new this year we also have

00:55:59.216 --> 00:56:02.246 A:middle
And new this year we also have

00:56:02.606 --> 00:56:04.066 A:middle
support for Metal in the

00:56:04.066 --> 00:56:04.606 A:middle
simulator.

00:56:06.466 --> 00:56:07.476 A:middle
Yay, you can get excited.

00:56:08.016 --> 00:56:10.436 A:middle
[laughs]

00:56:10.936 --> 00:56:13.026 A:middle
New with Xcode 11 on macOS

00:56:13.026 --> 00:56:15.226 A:middle
Catalina, we have full hardware

00:56:15.226 --> 00:56:17.356 A:middle
acceleration to run your games

00:56:17.356 --> 00:56:20.226 A:middle
and apps for iOS and tvOS

00:56:20.646 --> 00:56:21.806 A:middle
simulator using Metal.

00:56:23.186 --> 00:56:24.356 A:middle
The simulator supports the

00:56:24.356 --> 00:56:26.766 A:middle
MTLGPUFamilyApple2 feature set

00:56:26.766 --> 00:56:28.356 A:middle
and should meet the majority of

00:56:28.406 --> 00:56:30.096 A:middle
your needs to run all of your

00:56:30.166 --> 00:56:31.696 A:middle
apps and games in all available

00:56:31.696 --> 00:56:32.586 A:middle
screen resolutions.

00:56:33.086 --> 00:56:36.246 A:middle
For a deeper dive into the

00:56:36.316 --> 00:56:37.746 A:middle
simulator and how it achieves

00:56:37.746 --> 00:56:39.846 A:middle
hardware acceleration, please

00:56:39.846 --> 00:56:41.026 A:middle
check out the simulator talk

00:56:41.286 --> 00:56:41.966 A:middle
tomorrow morning.

00:56:42.946 --> 00:56:44.016 A:middle
If you're looking to solve a

00:56:44.016 --> 00:56:45.946 A:middle
specific issue with Metal, you

00:56:45.946 --> 00:56:47.746 A:middle
can see our many, many sessions

00:56:47.746 --> 00:56:48.306 A:middle
online.

00:56:50.096 --> 00:56:52.496 A:middle
For more information, you can

00:56:52.496 --> 00:56:54.326 A:middle
check out our documentation on

00:56:54.326 --> 00:56:56.126 A:middle
our website or you can visit us

00:56:56.126 --> 00:56:57.056 A:middle
in the Metal lab tomorrow

00:56:57.056 --> 00:56:57.386 A:middle
morning.

00:56:58.416 --> 00:57:00.136 A:middle
And with that, thank you all for

00:56:58.416 --> 00:57:00.136 A:middle
And with that, thank you all for

00:57:00.136 --> 00:57:01.416 A:middle
coming, and I hope to see you at

00:57:01.416 --> 00:57:01.956 A:middle
the bash.

00:57:02.516 --> 00:57:05.500 A:middle
[ Applause ]
