WEBVTT

00:00:00.506 --> 00:00:04.500 A:middle
[ Music ]

00:00:13.131 --> 00:00:15.131 A:middle
[Applause]

00:00:15.246 --> 00:00:15.906 A:middle
&gt;&gt; Good Morning.

00:00:16.856 --> 00:00:18.716 A:middle
Welcome to What's New in Swift.

00:00:19.786 --> 00:00:21.086 A:middle
Today we're going to talk about

00:00:21.146 --> 00:00:23.186 A:middle
two important and exciting Swift

00:00:23.186 --> 00:00:23.856 A:middle
releases.

00:00:24.276 --> 00:00:26.056 A:middle
Swift 5, which was recently

00:00:26.056 --> 00:00:28.876 A:middle
released in March, and Swift 5.1

00:00:29.036 --> 00:00:30.546 A:middle
which is available now as a

00:00:30.546 --> 00:00:32.906 A:middle
developer preview in Xcode 11.

00:00:34.196 --> 00:00:36.326 A:middle
Combined together, these two

00:00:36.326 --> 00:00:38.436 A:middle
releases further unleash the

00:00:38.436 --> 00:00:41.156 A:middle
potential of Swift as a language

00:00:41.216 --> 00:00:42.986 A:middle
and technology that both Apple

00:00:43.276 --> 00:00:45.616 A:middle
and all of you can build upon.

00:00:46.666 --> 00:00:49.326 A:middle
And that comes in the form of

00:00:49.326 --> 00:00:51.406 A:middle
really powerhouse story with

00:00:51.406 --> 00:00:54.666 A:middle
Swift and APIs.

00:00:55.756 --> 00:00:58.136 A:middle
With a shared Swift runtime for

00:00:58.206 --> 00:00:59.876 A:middle
third-party apps now shipped in

00:00:59.876 --> 00:01:02.356 A:middle
Apple's operating system, and

00:00:59.876 --> 00:01:02.356 A:middle
Apple's operating system, and

00:01:02.356 --> 00:01:03.726 A:middle
binary frameworks written in

00:01:03.726 --> 00:01:05.716 A:middle
Swift that can now be deployed,

00:01:06.326 --> 00:01:08.416 A:middle
we see the appearance of marquee

00:01:08.616 --> 00:01:10.476 A:middle
Swift-only frameworks from

00:01:10.476 --> 00:01:10.856 A:middle
Apple.

00:01:11.926 --> 00:01:14.136 A:middle
Further, the integrated support

00:01:14.486 --> 00:01:15.826 A:middle
of the Swift Package Manager

00:01:15.826 --> 00:01:17.296 A:middle
within Xcode brings Swift

00:01:17.296 --> 00:01:19.256 A:middle
packages directly into the core

00:01:19.256 --> 00:01:21.516 A:middle
workflows for app development.

00:01:22.166 --> 00:01:23.496 A:middle
And the Swift language itself

00:01:23.496 --> 00:01:25.066 A:middle
has grown new affordances for

00:01:25.066 --> 00:01:27.886 A:middle
building beautiful and rich APIs

00:01:28.396 --> 00:01:30.016 A:middle
and capabilities for expressing

00:01:30.016 --> 00:01:31.216 A:middle
API evolution.

00:01:31.716 --> 00:01:33.096 A:middle
It's a really, really exciting

00:01:33.096 --> 00:01:35.846 A:middle
time for the language and in the

00:01:35.846 --> 00:01:36.306 A:middle
story.

00:01:36.966 --> 00:01:38.716 A:middle
So let's kick things off by

00:01:38.716 --> 00:01:40.436 A:middle
talking more about binary

00:01:40.506 --> 00:01:42.296 A:middle
frameworks, in particular, dig

00:01:42.296 --> 00:01:43.806 A:middle
into some of the core

00:01:43.806 --> 00:01:45.666 A:middle
ingredients that made that

00:01:45.666 --> 00:01:46.176 A:middle
happen.

00:01:46.846 --> 00:01:48.536 A:middle
And those ingredients are ABI

00:01:48.536 --> 00:01:50.256 A:middle
and module stability.

00:01:51.516 --> 00:01:54.276 A:middle
ABI stands for Application

00:01:54.436 --> 00:01:56.496 A:middle
Binary Interface and it's the

00:01:56.496 --> 00:01:57.966 A:middle
rules that governs the nuts and

00:01:57.966 --> 00:01:59.906 A:middle
bolts of how compiled code can

00:01:59.956 --> 00:02:01.766 A:middle
interact together at runtime.

00:01:59.956 --> 00:02:01.766 A:middle
interact together at runtime.

00:02:02.576 --> 00:02:04.636 A:middle
So details like a function call.

00:02:04.916 --> 00:02:06.796 A:middle
How does it actually work?

00:02:07.416 --> 00:02:08.836 A:middle
How are the values in the

00:02:08.836 --> 00:02:11.586 A:middle
arguments passed off from caller

00:02:11.996 --> 00:02:12.636 A:middle
to callee?

00:02:13.086 --> 00:02:14.386 A:middle
What is the available metadata?

00:02:14.386 --> 00:02:15.506 A:middle
How is it laid out in memory?

00:02:15.626 --> 00:02:16.766 A:middle
All of these details are

00:02:16.766 --> 00:02:18.506 A:middle
necessary for compiled code to

00:02:18.506 --> 00:02:19.436 A:middle
interact together.

00:02:19.766 --> 00:02:21.526 A:middle
So to kind of illustrate this

00:02:21.526 --> 00:02:23.326 A:middle
idea, imagine you have a program

00:02:23.326 --> 00:02:24.116 A:middle
written in Swift.

00:02:24.236 --> 00:02:25.626 A:middle
It's an app, could be command

00:02:25.626 --> 00:02:26.926 A:middle
line tool, it doesn't really

00:02:26.926 --> 00:02:27.246 A:middle
matter.

00:02:27.246 --> 00:02:28.876 A:middle
It's just some executable.

00:02:29.706 --> 00:02:31.416 A:middle
And it uses a framework that is

00:02:31.416 --> 00:02:33.756 A:middle
also written in Swift, and all

00:02:33.756 --> 00:02:35.066 A:middle
of this, you know, compiled code

00:02:35.066 --> 00:02:36.866 A:middle
is running together within a

00:02:36.866 --> 00:02:37.786 A:middle
running process.

00:02:37.876 --> 00:02:40.926 A:middle
So the executable is using APIs

00:02:41.116 --> 00:02:42.146 A:middle
from the framework and they have

00:02:42.186 --> 00:02:43.386 A:middle
to be able to talk to each other

00:02:43.696 --> 00:02:44.456 A:middle
at runtime.

00:02:45.246 --> 00:02:46.966 A:middle
Well, in order for this to work,

00:02:46.966 --> 00:02:48.186 A:middle
they have to have a compatible

00:02:48.186 --> 00:02:49.896 A:middle
ABI, like these two, you know,

00:02:49.896 --> 00:02:50.926 A:middle
pieces are compiled

00:02:51.006 --> 00:02:52.696 A:middle
independently but that compiled

00:02:52.736 --> 00:02:53.856 A:middle
code needs to work together.

00:02:54.436 --> 00:02:56.296 A:middle
Before ABI stability, the only

00:02:56.296 --> 00:02:58.876 A:middle
guarantee we had is that these

00:02:59.066 --> 00:03:00.546 A:middle
would have a compatible ABI if

00:02:59.066 --> 00:03:00.546 A:middle
would have a compatible ABI if

00:03:00.546 --> 00:03:02.406 A:middle
they were built with the same

00:03:02.406 --> 00:03:02.966 A:middle
compiler.

00:03:03.056 --> 00:03:04.826 A:middle
And this was the case because we

00:03:04.826 --> 00:03:06.616 A:middle
were really evolving the core

00:03:06.616 --> 00:03:08.176 A:middle
fundamentals of Swift, making

00:03:08.176 --> 00:03:09.746 A:middle
sure all the building blocks

00:03:09.746 --> 00:03:10.996 A:middle
that we wanted to have in place

00:03:11.416 --> 00:03:13.096 A:middle
to build upon in the future were

00:03:13.096 --> 00:03:14.106 A:middle
in the right place.

00:03:14.766 --> 00:03:16.226 A:middle
Well, in Swift 5, we've

00:03:16.226 --> 00:03:18.286 A:middle
crystallized those details and

00:03:18.386 --> 00:03:20.436 A:middle
Swift now has ABI stability,

00:03:20.436 --> 00:03:22.286 A:middle
meaning these two components no

00:03:22.286 --> 00:03:23.796 A:middle
longer need to be built with the

00:03:23.796 --> 00:03:25.826 A:middle
same compiler as long as they're

00:03:25.826 --> 00:03:27.166 A:middle
built with the Swift 5 compiler

00:03:27.626 --> 00:03:28.106 A:middle
or later.

00:03:28.676 --> 00:03:31.386 A:middle
The second important ingredient

00:03:31.386 --> 00:03:33.346 A:middle
is module stability and this is

00:03:33.346 --> 00:03:35.146 A:middle
a compiled time concept.

00:03:35.146 --> 00:03:36.996 A:middle
So if you take a Swift framework

00:03:37.156 --> 00:03:38.966 A:middle
using of all the APIs in that

00:03:38.966 --> 00:03:40.516 A:middle
framework, those are part of a

00:03:40.516 --> 00:03:42.496 A:middle
shared namespace called a

00:03:42.496 --> 00:03:43.076 A:middle
module.

00:03:43.466 --> 00:03:45.396 A:middle
And when the Swift compiler is

00:03:45.396 --> 00:03:48.296 A:middle
used to build that framework, it

00:03:48.296 --> 00:03:50.786 A:middle
produces a manifest of all the

00:03:50.786 --> 00:03:53.716 A:middle
APIs in that framework that can

00:03:53.716 --> 00:03:55.756 A:middle
be then consumed by clients of

00:03:55.756 --> 00:03:56.326 A:middle
that framework.

00:03:56.636 --> 00:03:57.826 A:middle
And that manifest is called a

00:03:57.826 --> 00:03:58.776 A:middle
Swift module file.

00:03:59.196 --> 00:04:00.666 A:middle
So if we return back to this

00:03:59.196 --> 00:04:00.666 A:middle
So if we return back to this

00:04:00.666 --> 00:04:02.586 A:middle
example, imagine where-- you

00:04:02.586 --> 00:04:03.346 A:middle
know, we're compiling the

00:04:03.386 --> 00:04:04.716 A:middle
program so we have, you know, a

00:04:04.716 --> 00:04:06.396 A:middle
source file, it references the

00:04:06.466 --> 00:04:08.206 A:middle
framework, and what happens is

00:04:08.206 --> 00:04:09.216 A:middle
the compiler goes and reads

00:04:09.256 --> 00:04:10.756 A:middle
Swift module file, gets the

00:04:10.756 --> 00:04:11.416 A:middle
available APIs.

00:04:11.416 --> 00:04:14.246 A:middle
But the details in this module

00:04:14.246 --> 00:04:17.326 A:middle
file are really rich and in many

00:04:17.326 --> 00:04:18.766 A:middle
ways very tightly coupled to the

00:04:18.766 --> 00:04:19.826 A:middle
compiler itself.

00:04:19.826 --> 00:04:21.716 A:middle
So we had the same problem as

00:04:21.716 --> 00:04:22.746 A:middle
with ABI stability.

00:04:22.746 --> 00:04:24.016 A:middle
The only thing that worked is

00:04:24.016 --> 00:04:25.266 A:middle
that these two pieces had to

00:04:25.266 --> 00:04:27.446 A:middle
compile with the same compiler.

00:04:28.026 --> 00:04:31.236 A:middle
On Swift 5.1, we've introduced a

00:04:31.236 --> 00:04:33.446 A:middle
new complementary manifest.

00:04:33.936 --> 00:04:35.506 A:middle
It's called a Swift module

00:04:35.506 --> 00:04:36.396 A:middle
interface file.

00:04:36.996 --> 00:04:38.766 A:middle
And it can be used by frameworks

00:04:39.186 --> 00:04:40.906 A:middle
to provide a stable interface

00:04:41.356 --> 00:04:42.896 A:middle
that clients can consume.

00:04:43.666 --> 00:04:45.736 A:middle
It's a-- If you, you know, crack

00:04:45.736 --> 00:04:47.246 A:middle
it open, it looks like Swift

00:04:47.296 --> 00:04:47.816 A:middle
source code.

00:04:47.866 --> 00:04:49.196 A:middle
So it's also built on the notion

00:04:49.196 --> 00:04:50.836 A:middle
of source stability that we've

00:04:50.836 --> 00:04:52.446 A:middle
had in Swift for quite some

00:04:52.446 --> 00:04:52.776 A:middle
time.

00:04:53.086 --> 00:04:54.946 A:middle
So with these two ingredients,

00:04:55.186 --> 00:04:57.626 A:middle
you get Swift frameworks that

00:04:57.626 --> 00:04:59.776 A:middle
can be deployed and shared with

00:04:59.776 --> 00:05:00.296 A:middle
others.

00:04:59.776 --> 00:05:00.296 A:middle
others.

00:05:01.516 --> 00:05:06.546 A:middle
[Applause]

00:05:07.046 --> 00:05:08.096 A:middle
Now there's a lot of really

00:05:08.096 --> 00:05:09.576 A:middle
interesting details about ABI

00:05:09.576 --> 00:05:10.786 A:middle
stability, was something that

00:05:10.786 --> 00:05:12.346 A:middle
was in the works for quite some

00:05:12.946 --> 00:05:13.216 A:middle
time.

00:05:13.216 --> 00:05:14.386 A:middle
If you're interested in finding

00:05:14.386 --> 00:05:15.896 A:middle
out a lot more details and we're

00:05:15.896 --> 00:05:16.946 A:middle
going to talk about today,

00:05:16.946 --> 00:05:19.326 A:middle
swift.org is a great resource.

00:05:19.326 --> 00:05:22.236 A:middle
This is the homepage of Swift

00:05:22.236 --> 00:05:23.056 A:middle
open source project.

00:05:23.056 --> 00:05:24.136 A:middle
And there's a couple of really

00:05:24.136 --> 00:05:25.766 A:middle
great blog posts about ABI

00:05:25.816 --> 00:05:26.276 A:middle
stability.

00:05:27.816 --> 00:05:29.286 A:middle
Also, if you're interested in

00:05:29.286 --> 00:05:31.156 A:middle
putting binary frameworks to

00:05:31.576 --> 00:05:33.576 A:middle
use, you know, for your own use

00:05:33.576 --> 00:05:34.416 A:middle
like, you know, sharing with

00:05:34.416 --> 00:05:35.866 A:middle
others, there's a great talk

00:05:35.866 --> 00:05:37.176 A:middle
later this week called Binary

00:05:37.176 --> 00:05:38.976 A:middle
Frameworks in Swift.

00:05:39.276 --> 00:05:40.256 A:middle
And it talks about some of the

00:05:40.256 --> 00:05:41.666 A:middle
considerations you should have

00:05:41.996 --> 00:05:43.566 A:middle
when sharing frameworks with

00:05:43.566 --> 00:05:44.036 A:middle
others.

00:05:45.316 --> 00:05:46.476 A:middle
Now binary frameworks are just

00:05:46.476 --> 00:05:48.286 A:middle
one part of that API story,

00:05:48.286 --> 00:05:50.296 A:middle
another big piece are Swift

00:05:50.566 --> 00:05:51.116 A:middle
packages.

00:05:51.946 --> 00:05:53.336 A:middle
And with the integration of the

00:05:53.336 --> 00:05:55.216 A:middle
Swift Package Manager now into

00:05:55.626 --> 00:05:56.646 A:middle
Xcode, they're part of the core

00:05:56.646 --> 00:05:58.816 A:middle
workflows of building apps.

00:05:59.666 --> 00:06:00.826 A:middle
Two great talks this week about

00:05:59.666 --> 00:06:00.826 A:middle
Two great talks this week about

00:06:00.826 --> 00:06:02.326 A:middle
both creating and adopting

00:06:02.326 --> 00:06:04.206 A:middle
packages within Xcode.

00:06:04.296 --> 00:06:06.356 A:middle
And so the combination of binary

00:06:06.356 --> 00:06:07.766 A:middle
frameworks and Swift packages

00:06:07.766 --> 00:06:09.346 A:middle
provides a really rich set of

00:06:09.346 --> 00:06:12.276 A:middle
options for sharing APIs with

00:06:12.276 --> 00:06:12.766 A:middle
others.

00:06:14.556 --> 00:06:15.966 A:middle
So let's shift gears and talk

00:06:15.966 --> 00:06:17.386 A:middle
about performance.

00:06:18.066 --> 00:06:20.386 A:middle
Swift language was built to be a

00:06:20.386 --> 00:06:22.326 A:middle
modern, safe, but very

00:06:22.326 --> 00:06:24.216 A:middle
performant programming language.

00:06:24.856 --> 00:06:25.856 A:middle
And there are some key

00:06:25.856 --> 00:06:27.106 A:middle
performance benefits that came

00:06:27.106 --> 00:06:28.376 A:middle
out of ABI stability.

00:06:29.706 --> 00:06:30.976 A:middle
One of them comes down to having

00:06:30.976 --> 00:06:32.696 A:middle
that shared Swift runtime for

00:06:32.696 --> 00:06:34.676 A:middle
apps in the OS, and this came

00:06:34.676 --> 00:06:37.206 A:middle
out in March and so for macOS,

00:06:37.206 --> 00:06:38.676 A:middle
iOS, tvOS, watchOS and now

00:06:38.756 --> 00:06:41.086 A:middle
iPadOS, as of these releases,

00:06:41.406 --> 00:06:42.666 A:middle
there's a shared Swift runtime

00:06:42.666 --> 00:06:45.176 A:middle
in US that, well, third-party

00:06:45.176 --> 00:06:46.046 A:middle
apps, first-party apps,

00:06:46.046 --> 00:06:47.936 A:middle
everything in the system uses.

00:06:48.526 --> 00:06:51.546 A:middle
So what-- how does this actually

00:06:51.546 --> 00:06:53.296 A:middle
work, when does this come into

00:06:54.096 --> 00:06:54.196 A:middle
play?

00:06:54.406 --> 00:06:56.376 A:middle
If your app is built with Swift

00:06:56.376 --> 00:06:58.656 A:middle
5 or later, it will always use

00:06:58.716 --> 00:07:00.496 A:middle
the shared runtime in the OS

00:06:58.716 --> 00:07:00.496 A:middle
the shared runtime in the OS

00:07:00.916 --> 00:07:02.486 A:middle
when it is present.

00:07:03.636 --> 00:07:05.336 A:middle
However, you may still be

00:07:05.336 --> 00:07:06.826 A:middle
building your app to deploy back

00:07:06.826 --> 00:07:08.496 A:middle
to an earlier OS release that

00:07:08.496 --> 00:07:09.546 A:middle
doesn't have that runtime.

00:07:10.886 --> 00:07:12.396 A:middle
In that case, Xcode will

00:07:12.396 --> 00:07:13.976 A:middle
continue to bundle a copy of the

00:07:13.976 --> 00:07:15.986 A:middle
runtime in your app so it can

00:07:15.986 --> 00:07:17.466 A:middle
continue to run on those older

00:07:17.466 --> 00:07:18.596 A:middle
OS releases.

00:07:19.796 --> 00:07:22.406 A:middle
But, we will always prefer to

00:07:22.406 --> 00:07:24.166 A:middle
use a copy that's in the OS

00:07:24.166 --> 00:07:25.986 A:middle
itself, so that, you know, that

00:07:25.986 --> 00:07:27.956 A:middle
copy in the app will be inert

00:07:28.566 --> 00:07:29.806 A:middle
when running on newer system.

00:07:30.536 --> 00:07:33.976 A:middle
And as an optimization, the iOS

00:07:34.156 --> 00:07:36.556 A:middle
App Store will send out that

00:07:36.716 --> 00:07:37.906 A:middle
copy, the runtime from your app

00:07:38.356 --> 00:07:39.766 A:middle
when downloading into a device

00:07:39.976 --> 00:07:41.926 A:middle
that has the runtime in the OS.

00:07:41.926 --> 00:07:43.756 A:middle
So your users don't have to pay

00:07:43.756 --> 00:07:44.966 A:middle
that download cost.

00:07:45.606 --> 00:07:48.566 A:middle
So that's a really important

00:07:48.566 --> 00:07:51.286 A:middle
code size benefit, but the real

00:07:51.286 --> 00:07:52.796 A:middle
win about having that runtime in

00:07:52.796 --> 00:07:54.526 A:middle
the OS is now it can be

00:07:54.586 --> 00:07:56.476 A:middle
optimized as part of the

00:07:56.476 --> 00:07:58.126 A:middle
operating system itself.

00:07:58.126 --> 00:07:59.586 A:middle
And then those benefits can then

00:07:59.586 --> 00:08:01.136 A:middle
be imparted onto apps

00:07:59.586 --> 00:08:01.136 A:middle
be imparted onto apps

00:08:01.216 --> 00:08:01.676 A:middle
themselves.

00:08:03.226 --> 00:08:04.986 A:middle
And one important benefit is

00:08:04.986 --> 00:08:06.096 A:middle
launch time.

00:08:06.336 --> 00:08:08.506 A:middle
So let's rewind back in time, a

00:08:08.506 --> 00:08:10.926 A:middle
year ago, we talked about Swift

00:08:10.926 --> 00:08:11.496 A:middle
4.2.

00:08:12.996 --> 00:08:14.926 A:middle
And if you take an Objective C

00:08:14.926 --> 00:08:17.506 A:middle
app, it does nothing, it just

00:08:17.506 --> 00:08:19.166 A:middle
starts up, does nothing at all

00:08:19.716 --> 00:08:21.346 A:middle
and a Swift app that's, you

00:08:21.346 --> 00:08:22.526 A:middle
know, similarly has no function,

00:08:22.526 --> 00:08:23.386 A:middle
it just starts up.

00:08:23.796 --> 00:08:25.446 A:middle
There's about a 5% overhead of

00:08:25.446 --> 00:08:27.326 A:middle
using Swift because of the work

00:08:27.356 --> 00:08:29.256 A:middle
needed to, you know, handle that

00:08:29.256 --> 00:08:30.116 A:middle
embedded runtime.

00:08:30.306 --> 00:08:32.546 A:middle
But when your app is recompiled

00:08:32.546 --> 00:08:34.265 A:middle
with Swift 5 compiler and runs

00:08:34.265 --> 00:08:35.506 A:middle
on an OS with that shared

00:08:35.506 --> 00:08:37.466 A:middle
runtime, that overhead

00:08:38.035 --> 00:08:38.686 A:middle
disappears.

00:08:39.515 --> 00:08:43.216 A:middle
[Applause]

00:08:43.716 --> 00:08:44.536 A:middle
This is really, really

00:08:44.536 --> 00:08:45.676 A:middle
important.

00:08:45.676 --> 00:08:47.006 A:middle
I mean, that latency is the

00:08:47.006 --> 00:08:48.886 A:middle
difference between users wanting

00:08:48.886 --> 00:08:50.156 A:middle
to-- you know, the moment they

00:08:50.156 --> 00:08:51.196 A:middle
want to start using your app,

00:08:51.626 --> 00:08:52.996 A:middle
and them starting experiencing

00:08:53.796 --> 00:08:53.866 A:middle
it.

00:08:54.996 --> 00:08:56.856 A:middle
Another important area that

00:08:56.856 --> 00:08:58.476 A:middle
we've optimized is further

00:08:58.476 --> 00:09:01.396 A:middle
tuning the committed, you know,

00:08:58.476 --> 00:09:01.396 A:middle
tuning the committed, you know,

00:09:01.396 --> 00:09:02.686 A:middle
code from the compilers.

00:09:02.686 --> 00:09:03.676 A:middle
It reduces-- further reduce the

00:09:03.676 --> 00:09:06.026 A:middle
code size of Swift applications.

00:09:06.026 --> 00:09:07.776 A:middle
And this really has been like

00:09:07.776 --> 00:09:09.356 A:middle
fine tuning, like looking at

00:09:09.386 --> 00:09:11.126 A:middle
specific patterns in Swift

00:09:11.126 --> 00:09:13.086 A:middle
applications like chess, how our

00:09:13.086 --> 00:09:14.306 A:middle
dictionary literals like

00:09:14.306 --> 00:09:15.556 A:middle
represented, you know, when

00:09:15.556 --> 00:09:16.656 A:middle
their code generated and so

00:09:16.656 --> 00:09:18.516 A:middle
forth, and just trying to make

00:09:18.516 --> 00:09:19.696 A:middle
sure that, you know, the output

00:09:19.696 --> 00:09:22.346 A:middle
of the compiler is optimized for

00:09:22.346 --> 00:09:23.406 A:middle
those use cases.

00:09:23.786 --> 00:09:24.756 A:middle
And so with an assortment of

00:09:24.756 --> 00:09:26.776 A:middle
optimizations we see up to a 10%

00:09:26.776 --> 00:09:29.546 A:middle
reduction in code size when--

00:09:29.546 --> 00:09:30.956 A:middle
well, with the Swift 5.1

00:09:30.956 --> 00:09:31.506 A:middle
compiler.

00:09:31.846 --> 00:09:32.846 A:middle
And if you have optimized your

00:09:32.846 --> 00:09:35.936 A:middle
size, it's about a 15% reduction

00:09:35.936 --> 00:09:36.566 A:middle
code size.

00:09:36.976 --> 00:09:39.086 A:middle
So some pretty significant ones.

00:09:40.076 --> 00:09:42.786 A:middle
We've also continued to refine,

00:09:42.786 --> 00:09:44.136 A:middle
you know, the performance of

00:09:44.136 --> 00:09:44.536 A:middle
bridging.

00:09:45.156 --> 00:09:46.246 A:middle
And by bridging I'm talking

00:09:46.246 --> 00:09:47.856 A:middle
about the bridging between Swift

00:09:48.296 --> 00:09:49.046 A:middle
and Objective-C.

00:09:49.046 --> 00:09:49.956 A:middle
There's a really deep

00:09:49.956 --> 00:09:51.776 A:middle
inoperability between those two

00:09:51.776 --> 00:09:52.456 A:middle
languages.

00:09:54.556 --> 00:09:56.666 A:middle
So both Swift and Objective-C

00:09:56.666 --> 00:09:58.396 A:middle
have what we call common

00:09:58.446 --> 00:10:00.206 A:middle
currency types, that are used

00:09:58.446 --> 00:10:00.206 A:middle
currency types, that are used

00:10:00.256 --> 00:10:01.786 A:middle
throughout the API space.

00:10:02.326 --> 00:10:04.206 A:middle
Things like String and NSString,

00:10:04.556 --> 00:10:06.356 A:middle
Dictionary and NSDictionary.

00:10:06.356 --> 00:10:08.516 A:middle
And the inoperability between

00:10:08.516 --> 00:10:10.296 A:middle
those currency types is pretty

00:10:10.296 --> 00:10:11.136 A:middle
fundamental as part of the

00:10:11.136 --> 00:10:12.796 A:middle
inoperability between Swift and

00:10:12.796 --> 00:10:13.706 A:middle
Objective-C.

00:10:14.246 --> 00:10:15.646 A:middle
Objective-C APIs that use their

00:10:15.646 --> 00:10:16.886 A:middle
currency types are re-mapped

00:10:16.886 --> 00:10:18.486 A:middle
into Swift using Swift's

00:10:18.486 --> 00:10:19.326 A:middle
currency types.

00:10:19.506 --> 00:10:21.166 A:middle
Now this is a compiler-- this is

00:10:21.166 --> 00:10:23.006 A:middle
a combination of compiler work

00:10:23.566 --> 00:10:24.696 A:middle
but also there's a runtime

00:10:24.696 --> 00:10:26.116 A:middle
aspect when you pass a value of

00:10:26.116 --> 00:10:28.696 A:middle
one type off for another across

00:10:28.726 --> 00:10:29.956 A:middle
these API boundaries.

00:10:31.026 --> 00:10:32.076 A:middle
This is the part that we have

00:10:32.076 --> 00:10:33.626 A:middle
further attuned as part of Swift

00:10:33.676 --> 00:10:35.246 A:middle
being now part of the operating

00:10:35.246 --> 00:10:35.756 A:middle
system.

00:10:36.676 --> 00:10:39.106 A:middle
For example, bridging between

00:10:39.106 --> 00:10:40.256 A:middle
NSDictionary and Dictionary is

00:10:40.256 --> 00:10:42.156 A:middle
now 1.6 times faster.

00:10:43.186 --> 00:10:44.966 A:middle
And if you're passing a Swift

00:10:44.966 --> 00:10:47.416 A:middle
string off to Objective-C and it

00:10:47.416 --> 00:10:49.346 A:middle
bridges over as an NSString and

00:10:49.346 --> 00:10:50.206 A:middle
it's used, you know, from the

00:10:50.206 --> 00:10:52.676 A:middle
Objective-C side, its operations

00:10:52.706 --> 00:10:55.566 A:middle
can be up to 15 times faster.

00:10:56.516 --> 00:11:01.096 A:middle
[ Applause ]

00:10:56.516 --> 00:11:01.096 A:middle
[ Applause ]

00:11:01.596 --> 00:11:03.116 A:middle
And all these like little bit--

00:11:03.116 --> 00:11:04.666 A:middle
all these benefits really do add

00:11:04.666 --> 00:11:05.896 A:middle
up because these are types that

00:11:05.896 --> 00:11:07.286 A:middle
are used, you know, throughout

00:11:07.286 --> 00:11:08.436 A:middle
the API ecosystem.

00:11:09.076 --> 00:11:12.326 A:middle
Now speaking of strings, we

00:11:12.326 --> 00:11:13.986 A:middle
continue to refine their core

00:11:13.986 --> 00:11:15.316 A:middle
representation and we made a

00:11:15.316 --> 00:11:17.546 A:middle
major change to the string type

00:11:17.976 --> 00:11:18.826 A:middle
in Swift 5.

00:11:19.786 --> 00:11:20.856 A:middle
And this was an under-the-hood

00:11:20.856 --> 00:11:21.896 A:middle
change where we change the

00:11:21.896 --> 00:11:23.346 A:middle
unicode representation of

00:11:23.346 --> 00:11:29.326 A:middle
strings from UTF-16 to UTF-8.

00:11:30.206 --> 00:11:31.866 A:middle
Now this is completely

00:11:31.866 --> 00:11:33.416 A:middle
performance motivated.

00:11:34.296 --> 00:11:35.416 A:middle
There's a lot of rich detail

00:11:35.416 --> 00:11:36.226 A:middle
about this change.

00:11:36.226 --> 00:11:37.206 A:middle
If you're interested in finding

00:11:37.206 --> 00:11:38.506 A:middle
out a lot more than what I'm

00:11:38.506 --> 00:11:40.406 A:middle
about to say, swift.org, there's

00:11:40.406 --> 00:11:41.566 A:middle
a blog post that goes into the

00:11:41.566 --> 00:11:42.896 A:middle
actual technical changes and

00:11:42.896 --> 00:11:43.666 A:middle
what motivate it.

00:11:44.196 --> 00:11:44.946 A:middle
Well, I'll highlight a few

00:11:44.946 --> 00:11:45.766 A:middle
important things.

00:11:46.816 --> 00:11:49.556 A:middle
First, we created Swift as a

00:11:49.556 --> 00:11:50.936 A:middle
language you could reach for,

00:11:50.936 --> 00:11:52.996 A:middle
for C-like performance.

00:11:54.256 --> 00:11:55.536 A:middle
But a key aspect of that is that

00:11:55.536 --> 00:11:56.846 A:middle
we want Swift to have great

00:11:56.846 --> 00:11:58.716 A:middle
inoperability with an existing

00:11:58.716 --> 00:12:00.266 A:middle
ecosystem of C APIs.

00:11:58.716 --> 00:12:00.266 A:middle
ecosystem of C APIs.

00:12:00.266 --> 00:12:02.286 A:middle
And when Swift strings were

00:12:02.286 --> 00:12:05.016 A:middle
using the UTF-16, when you pass

00:12:05.016 --> 00:12:08.866 A:middle
a string off to a C API, there--

00:12:09.186 --> 00:12:10.936 A:middle
unbeknownst to maybe to you, you

00:12:10.936 --> 00:12:12.796 A:middle
had to do-- there was an

00:12:12.796 --> 00:12:14.556 A:middle
allocation and a copy and a

00:12:14.556 --> 00:12:15.776 A:middle
transcoding just to put it in a

00:12:15.776 --> 00:12:16.996 A:middle
compatible format that can be

00:12:17.046 --> 00:12:17.746 A:middle
passed up to six.

00:12:17.746 --> 00:12:18.916 A:middle
So this is like a lot of

00:12:18.916 --> 00:12:19.366 A:middle
overhead.

00:12:20.176 --> 00:12:22.346 A:middle
By moving to UTF-8, we can just

00:12:22.346 --> 00:12:23.436 A:middle
now pull a pass off a

00:12:23.436 --> 00:12:25.396 A:middle
null-terminated UTF-8 string to

00:12:25.396 --> 00:12:26.036 A:middle
C APIs.

00:12:26.396 --> 00:12:28.896 A:middle
No allocations, no copies, zero

00:12:28.896 --> 00:12:29.276 A:middle
overhead.

00:12:30.886 --> 00:12:32.666 A:middle
We've also been able to expand

00:12:32.666 --> 00:12:33.736 A:middle
out the optimizations of the

00:12:33.736 --> 00:12:34.816 A:middle
string type itself.

00:12:35.576 --> 00:12:37.396 A:middle
So string has a small string

00:12:37.396 --> 00:12:39.376 A:middle
optimization where if the number

00:12:39.376 --> 00:12:40.436 A:middle
of characters in the string are

00:12:40.436 --> 00:12:41.796 A:middle
about like 15 characters or

00:12:41.796 --> 00:12:43.646 A:middle
less, we don't need a separate

00:12:43.646 --> 00:12:44.746 A:middle
allocation to care-- you know,

00:12:44.746 --> 00:12:45.816 A:middle
to have that, that payload of

00:12:45.816 --> 00:12:47.016 A:middle
characters, we can just pack it

00:12:47.016 --> 00:12:48.156 A:middle
right into the string value

00:12:48.156 --> 00:12:48.546 A:middle
itself.

00:12:48.706 --> 00:12:49.726 A:middle
So this is a real win.

00:12:49.836 --> 00:12:51.566 A:middle
With Swift 5, we'd be able to

00:12:51.566 --> 00:12:53.026 A:middle
expand this optimization out to

00:12:53.026 --> 00:12:54.216 A:middle
include, you know, essentially

00:12:54.216 --> 00:12:55.716 A:middle
all unicode characters not just,

00:12:55.716 --> 00:12:57.806 A:middle
you know, ASCII, which means it

00:12:57.806 --> 00:12:59.776 A:middle
now applies to languages with

00:12:59.776 --> 00:13:00.946 A:middle
non-Roman characters.

00:12:59.776 --> 00:13:00.946 A:middle
non-Roman characters.

00:13:01.506 --> 00:13:03.596 A:middle
And we've done this while

00:13:03.596 --> 00:13:06.236 A:middle
maintaining great inoperability

00:13:06.456 --> 00:13:08.036 A:middle
between NSStrings and String at

00:13:08.036 --> 00:13:08.876 A:middle
a performance level.

00:13:10.216 --> 00:13:11.456 A:middle
But the really exciting to hear

00:13:11.456 --> 00:13:13.446 A:middle
is this is really all about

00:13:13.446 --> 00:13:13.906 A:middle
performance.

00:13:13.906 --> 00:13:14.966 A:middle
I've said it several times.

00:13:16.056 --> 00:13:17.486 A:middle
A great example that benchmarks

00:13:17.556 --> 00:13:18.916 A:middle
this is SwiftNIO.

00:13:18.916 --> 00:13:20.266 A:middle
For those of you who are not

00:13:20.266 --> 00:13:21.756 A:middle
familiar with it, SwiftNIO comes

00:13:21.756 --> 00:13:23.086 A:middle
from the Swift on server world

00:13:23.566 --> 00:13:25.556 A:middle
and it is a cross-platform

00:13:25.556 --> 00:13:26.786 A:middle
framework for building network

00:13:26.836 --> 00:13:27.976 A:middle
protocols and services.

00:13:28.246 --> 00:13:29.966 A:middle
And it's really been tuned for

00:13:29.966 --> 00:13:30.486 A:middle
speed.

00:13:31.676 --> 00:13:35.156 A:middle
And by switching to UTF-8, we

00:13:35.226 --> 00:13:37.776 A:middle
see a 20% increase in the

00:13:37.776 --> 00:13:39.646 A:middle
throughput of a web server built

00:13:39.646 --> 00:13:40.266 A:middle
on SwiftNIO.

00:13:40.266 --> 00:13:41.236 A:middle
So this is just like, you know,

00:13:41.666 --> 00:13:43.446 A:middle
just a benchmark of textual text

00:13:43.446 --> 00:13:44.136 A:middle
processing.

00:13:44.736 --> 00:13:46.726 A:middle
And this really resonates with

00:13:46.726 --> 00:13:47.926 A:middle
we want string to be a type that

00:13:47.926 --> 00:13:51.406 A:middle
you can use for high performance

00:13:51.566 --> 00:13:54.216 A:middle
intensive string operations but

00:13:54.216 --> 00:13:56.326 A:middle
also just it's user friendly and

00:13:56.386 --> 00:13:59.906 A:middle
easy to use.

00:14:00.366 --> 00:14:01.576 A:middle
And before I hand the stage off

00:14:01.696 --> 00:14:03.266 A:middle
to Anna, who will talk about

00:14:03.266 --> 00:14:04.636 A:middle
mainly the language changes in

00:14:04.636 --> 00:14:06.536 A:middle
Swift 5 and Swift 5.1, I want to

00:14:06.536 --> 00:14:07.636 A:middle
talk about some of the core tool

00:14:07.636 --> 00:14:09.556 A:middle
and improvements and part of

00:14:09.556 --> 00:14:11.946 A:middle
those being a key aspect of the

00:14:11.946 --> 00:14:12.846 A:middle
open source project.

00:14:14.416 --> 00:14:16.766 A:middle
Now Swift being open source is

00:14:16.766 --> 00:14:18.936 A:middle
more than just the day to day,

00:14:18.936 --> 00:14:20.096 A:middle
you know, engineering work on a

00:14:20.096 --> 00:14:20.556 A:middle
project.

00:14:20.886 --> 00:14:22.216 A:middle
It's about Swift being part of a

00:14:22.216 --> 00:14:23.926 A:middle
much broader and diverse

00:14:23.986 --> 00:14:25.886 A:middle
ecosystem of software.

00:14:26.536 --> 00:14:28.816 A:middle
So for example, the Swift

00:14:28.816 --> 00:14:30.566 A:middle
community came together and

00:14:30.566 --> 00:14:32.746 A:middle
created official Docker images

00:14:32.926 --> 00:14:34.346 A:middle
for Swift that are hosted on

00:14:34.496 --> 00:14:35.786 A:middle
Docker Hub.

00:14:36.446 --> 00:14:37.546 A:middle
And if you have Docker installed

00:14:37.546 --> 00:14:38.636 A:middle
on your Mac, which is a few

00:14:38.636 --> 00:14:40.606 A:middle
keystrokes, you can have-- you

00:14:40.606 --> 00:14:42.016 A:middle
can pull down a Docker, this

00:14:42.016 --> 00:14:43.406 A:middle
Docker image and have, you know,

00:14:43.406 --> 00:14:45.066 A:middle
working Docker Linux container

00:14:45.466 --> 00:14:46.896 A:middle
on your Mac that includes a

00:14:46.896 --> 00:14:48.866 A:middle
compiler and the package

00:14:48.866 --> 00:14:50.356 A:middle
manager, everything you need to

00:14:50.356 --> 00:14:50.866 A:middle
get going.

00:14:51.366 --> 00:14:52.566 A:middle
And this was done because

00:14:52.626 --> 00:14:53.986 A:middle
containers are viewed as an

00:14:53.986 --> 00:14:56.306 A:middle
intrinsic part of building

00:14:56.406 --> 00:14:58.396 A:middle
services today.

00:14:59.736 --> 00:15:01.816 A:middle
Another important technology

00:14:59.736 --> 00:15:01.816 A:middle
Another important technology

00:15:01.816 --> 00:15:03.006 A:middle
that is open source is

00:15:03.006 --> 00:15:03.516 A:middle
SourceKit.

00:15:03.936 --> 00:15:05.536 A:middle
And it's a semantic code engine

00:15:05.656 --> 00:15:07.286 A:middle
behind Xcode's features like

00:15:07.426 --> 00:15:08.426 A:middle
code completion,

00:15:08.426 --> 00:15:10.496 A:middle
jump-to-definition, refactoring,

00:15:10.936 --> 00:15:11.376 A:middle
and more.

00:15:12.116 --> 00:15:13.066 A:middle
And it's something that we

00:15:13.066 --> 00:15:14.406 A:middle
continue to refine.

00:15:14.406 --> 00:15:15.546 A:middle
We want to make the results of

00:15:15.546 --> 00:15:17.276 A:middle
code completion, so forth, much

00:15:17.276 --> 00:15:17.826 A:middle
better.

00:15:19.186 --> 00:15:20.496 A:middle
So something we continually to,

00:15:20.496 --> 00:15:21.406 A:middle
you know, iterate upon.

00:15:22.266 --> 00:15:23.886 A:middle
But also we want to make it

00:15:23.886 --> 00:15:25.466 A:middle
reliable and robust.

00:15:27.296 --> 00:15:28.556 A:middle
One of the efforts that we did,

00:15:28.556 --> 00:15:29.546 A:middle
part of the open source project

00:15:29.546 --> 00:15:31.006 A:middle
this year was build a new stress

00:15:31.006 --> 00:15:32.526 A:middle
tester tool for SourceKit.

00:15:33.676 --> 00:15:35.946 A:middle
What it does is it just pummels

00:15:36.126 --> 00:15:37.696 A:middle
SourceKit with all the queries

00:15:37.696 --> 00:15:40.086 A:middle
the IDE could issue to flush out

00:15:40.136 --> 00:15:42.296 A:middle
issues with SourceKit.

00:15:42.856 --> 00:15:43.816 A:middle
So things like crashes,

00:15:43.816 --> 00:15:44.756 A:middle
assertions, it creates

00:15:44.796 --> 00:15:46.476 A:middle
reproducible test cases for us.

00:15:46.896 --> 00:15:48.836 A:middle
And there's something very Meta

00:15:48.836 --> 00:15:49.106 A:middle
here.

00:15:50.466 --> 00:15:52.086 A:middle
We believe in building the first

00:15:52.086 --> 00:15:55.096 A:middle
in class tools with Swift for

00:15:55.096 --> 00:15:56.996 A:middle
all of you and investing in

00:15:56.996 --> 00:15:58.396 A:middle
tools as part of our own

00:15:58.396 --> 00:15:59.386 A:middle
workflows is like, you know,

00:15:59.386 --> 00:16:01.146 A:middle
we're eating our own philosophy

00:15:59.386 --> 00:16:01.146 A:middle
we're eating our own philosophy

00:16:01.786 --> 00:16:04.386 A:middle
and efforts like this are now a

00:16:04.486 --> 00:16:06.686 A:middle
core part of, you know, our day

00:16:06.686 --> 00:16:07.996 A:middle
to day engineering with the

00:16:08.546 --> 00:16:08.766 A:middle
project.

00:16:10.906 --> 00:16:12.986 A:middle
And I like to talk about a

00:16:12.986 --> 00:16:14.626 A:middle
future looking investment with

00:16:14.626 --> 00:16:16.046 A:middle
SourceKit, and that's in

00:16:16.046 --> 00:16:17.246 A:middle
adopting the language server

00:16:17.246 --> 00:16:17.676 A:middle
protocol.

00:16:18.386 --> 00:16:20.446 A:middle
So take this example slide

00:16:20.446 --> 00:16:20.896 A:middle
before.

00:16:21.576 --> 00:16:23.546 A:middle
You could take Xcode and really

00:16:23.546 --> 00:16:24.896 A:middle
generalize this picture, be

00:16:24.896 --> 00:16:27.146 A:middle
about really any kind of editor

00:16:27.146 --> 00:16:27.636 A:middle
or tool.

00:16:27.636 --> 00:16:29.086 A:middle
I mean SourceKit is open source.

00:16:29.406 --> 00:16:30.776 A:middle
It's designed to be used as a

00:16:30.776 --> 00:16:32.606 A:middle
reusable component for building

00:16:32.606 --> 00:16:33.116 A:middle
tools.

00:16:34.196 --> 00:16:37.386 A:middle
So this could work, right, but

00:16:37.386 --> 00:16:39.636 A:middle
this is really kind of an old

00:16:39.636 --> 00:16:40.016 A:middle
model.

00:16:40.236 --> 00:16:41.646 A:middle
You imagine that there's a wide

00:16:41.646 --> 00:16:43.996 A:middle
range of tools and editors and

00:16:43.996 --> 00:16:45.806 A:middle
IDs out there and they want to

00:16:45.806 --> 00:16:47.046 A:middle
wire up to a variety of

00:16:47.046 --> 00:16:48.056 A:middle
different, you know, language

00:16:48.056 --> 00:16:48.816 A:middle
services.

00:16:49.246 --> 00:16:50.316 A:middle
And so while they could directly

00:16:50.316 --> 00:16:51.526 A:middle
wire up logic to talk to

00:16:51.526 --> 00:16:53.466 A:middle
SourceKit, this is all very ad

00:16:53.466 --> 00:16:53.836 A:middle
hoc.

00:16:53.836 --> 00:16:54.926 A:middle
You have to have each editor

00:16:54.926 --> 00:16:57.096 A:middle
wire up its own support and they

00:16:57.096 --> 00:16:58.136 A:middle
have to understand the SourceKit

00:16:58.136 --> 00:16:58.926 A:middle
and then they have to understand

00:16:58.926 --> 00:17:00.056 A:middle
all the other services they want

00:16:58.926 --> 00:17:00.056 A:middle
all the other services they want

00:17:00.056 --> 00:17:00.526 A:middle
to connect to.

00:17:00.526 --> 00:17:02.446 A:middle
So this isn't a very scalable

00:17:02.446 --> 00:17:02.776 A:middle
model.

00:17:03.296 --> 00:17:04.576 A:middle
But like most problems in

00:17:04.576 --> 00:17:05.626 A:middle
computer science, you can solve

00:17:05.626 --> 00:17:06.486 A:middle
everything with a layer of

00:17:06.486 --> 00:17:08.546 A:middle
indirection, (except

00:17:08.546 --> 00:17:11.776 A:middle
performance), and an industry

00:17:11.776 --> 00:17:12.886 A:middle
standard solution called the

00:17:12.886 --> 00:17:14.465 A:middle
Language Service Protocol has

00:17:14.465 --> 00:17:15.596 A:middle
emerged or LSP.

00:17:15.596 --> 00:17:18.056 A:middle
And the idea is, is that if the

00:17:18.056 --> 00:17:20.205 A:middle
editors speak LSP, which is a

00:17:20.205 --> 00:17:22.056 A:middle
standard set of queries and the

00:17:22.056 --> 00:17:23.846 A:middle
services, you know, can speak it

00:17:23.846 --> 00:17:25.286 A:middle
back, you can just mash, make

00:17:25.286 --> 00:17:26.056 A:middle
them up together.

00:17:27.576 --> 00:17:28.976 A:middle
This is an active effort that's

00:17:28.976 --> 00:17:31.136 A:middle
underway, also an open source,

00:17:31.376 --> 00:17:32.236 A:middle
you can check it out.

00:17:32.846 --> 00:17:34.446 A:middle
But to give you a taste of

00:17:34.446 --> 00:17:36.806 A:middle
what's there, this animation

00:17:36.806 --> 00:17:39.146 A:middle
shows code completion support

00:17:39.146 --> 00:17:41.596 A:middle
working in them using SourceKit

00:17:41.596 --> 00:17:44.296 A:middle
LSP and there's also support for

00:17:44.296 --> 00:17:45.536 A:middle
various other editors.

00:17:45.536 --> 00:17:47.256 A:middle
You can find instructions on the

00:17:47.256 --> 00:17:48.006 A:middle
GitHub page.

00:17:49.516 --> 00:17:54.616 A:middle
[ Applause ]

00:17:55.116 --> 00:17:56.476 A:middle
It's investments like this that

00:17:56.476 --> 00:17:57.906 A:middle
are really exciting for us,

00:17:57.906 --> 00:17:59.416 A:middle
because Swift is really-- it's a

00:17:59.416 --> 00:18:00.976 A:middle
language that we built for

00:17:59.416 --> 00:18:00.976 A:middle
language that we built for

00:18:00.976 --> 00:18:02.936 A:middle
general, you know, computing,

00:18:03.076 --> 00:18:03.326 A:middle
right?

00:18:03.326 --> 00:18:05.166 A:middle
It has an immense amount of

00:18:05.216 --> 00:18:07.616 A:middle
potential and this is really

00:18:07.616 --> 00:18:10.036 A:middle
about making Swift really thrive

00:18:10.036 --> 00:18:11.636 A:middle
in a diverse software ecosystem.

00:18:12.126 --> 00:18:13.766 A:middle
With that I'd like to hand the

00:18:13.766 --> 00:18:15.146 A:middle
stage off to my colleague Anna

00:18:15.146 --> 00:18:16.496 A:middle
Zaks [phonetic], who will talk

00:18:16.496 --> 00:18:18.146 A:middle
about the language changes in

00:18:18.146 --> 00:18:18.516 A:middle
Swift.

00:18:19.516 --> 00:18:24.056 A:middle
[ Applause ]

00:18:24.556 --> 00:18:25.146 A:middle
&gt;&gt; Thank you, Ted.

00:18:25.756 --> 00:18:26.526 A:middle
Ted talked about the

00:18:26.526 --> 00:18:27.996 A:middle
improvements to the project and

00:18:27.996 --> 00:18:28.586 A:middle
the compiler.

00:18:28.956 --> 00:18:30.366 A:middle
Now let me tell you about

00:18:30.526 --> 00:18:32.136 A:middle
improvements we've made to the

00:18:32.136 --> 00:18:33.516 A:middle
Swift language and the standard

00:18:33.516 --> 00:18:35.176 A:middle
library in Swift 5 and Swift

00:18:35.176 --> 00:18:36.006 A:middle
5.1.

00:18:37.126 --> 00:18:38.836 A:middle
Many of these features continued

00:18:38.836 --> 00:18:40.416 A:middle
refining the core parts of the

00:18:40.416 --> 00:18:41.576 A:middle
language and the library.

00:18:42.256 --> 00:18:43.956 A:middle
Also, aligned with Apple

00:18:43.956 --> 00:18:45.556 A:middle
shipping several major Swift

00:18:45.556 --> 00:18:47.086 A:middle
frameworks this year, we've

00:18:47.086 --> 00:18:48.626 A:middle
added features that support

00:18:48.626 --> 00:18:50.386 A:middle
creation of better Swift APIs.

00:18:51.356 --> 00:18:52.876 A:middle
As many of you know, Swift

00:18:52.876 --> 00:18:54.556 A:middle
language goes through open

00:18:54.556 --> 00:18:55.516 A:middle
evolution process.

00:18:56.006 --> 00:18:57.676 A:middle
And these SE numbers you see on

00:18:57.676 --> 00:18:59.716 A:middle
the slide correspond to the

00:18:59.716 --> 00:19:01.006 A:middle
feature documents that you can

00:18:59.716 --> 00:19:01.006 A:middle
feature documents that you can

00:19:01.006 --> 00:19:02.396 A:middle
find on the Swift evolution

00:19:02.396 --> 00:19:02.916 A:middle
website.

00:19:03.926 --> 00:19:05.146 A:middle
It's a great resource if you

00:19:05.146 --> 00:19:06.346 A:middle
want to learn more about these

00:19:06.346 --> 00:19:06.786 A:middle
features.

00:19:07.306 --> 00:19:08.486 A:middle
But now, let me give you a

00:19:08.486 --> 00:19:11.096 A:middle
glimpse into some of them.

00:19:11.256 --> 00:19:12.726 A:middle
We'll start with a few examples

00:19:12.726 --> 00:19:14.376 A:middle
that I just fill in the missing

00:19:14.376 --> 00:19:14.726 A:middle
blocks.

00:19:15.296 --> 00:19:18.046 A:middle
Many of you love the simplicity

00:19:18.046 --> 00:19:19.546 A:middle
of single expression closure

00:19:19.546 --> 00:19:20.026 A:middle
syntax.

00:19:20.606 --> 00:19:22.036 A:middle
So they need to write a return

00:19:22.216 --> 00:19:24.226 A:middle
in single expression, functions,

00:19:24.226 --> 00:19:27.066 A:middle
methods, and subscripts might

00:19:27.156 --> 00:19:28.896 A:middle
feel like unnecessary burden.

00:19:29.216 --> 00:19:31.456 A:middle
Well now, you can use the simple

00:19:31.456 --> 00:19:32.676 A:middle
syntax everywhere.

00:19:33.516 --> 00:19:38.476 A:middle
[ Applause ]

00:19:38.976 --> 00:19:40.466 A:middle
Another [inaudible] was fixed by

00:19:40.466 --> 00:19:41.876 A:middle
an open source contributor,

00:19:42.156 --> 00:19:43.416 A:middle
Alejandro Alonso.

00:19:43.766 --> 00:19:45.716 A:middle
And what's amazing, he is just

00:19:45.716 --> 00:19:46.856 A:middle
finishing high school.

00:19:47.766 --> 00:19:49.146 A:middle
Consider this struct that

00:19:49.146 --> 00:19:50.806 A:middle
conveniently defines default

00:19:50.806 --> 00:19:51.906 A:middle
values for both of its

00:19:51.906 --> 00:19:52.436 A:middle
properties.

00:19:53.396 --> 00:19:54.896 A:middle
Previously, you could call an

00:19:54.896 --> 00:19:56.546 A:middle
initializer and pass it no

00:19:56.546 --> 00:19:57.146 A:middle
arguments.

00:19:57.806 --> 00:19:58.776 A:middle
You could also call an

00:19:58.776 --> 00:20:00.216 A:middle
initializer and pass it all

00:19:58.776 --> 00:20:00.216 A:middle
initializer and pass it all

00:20:00.216 --> 00:20:02.326 A:middle
arguments, but you could not

00:20:02.356 --> 00:20:04.196 A:middle
call an initializer and pass it

00:20:04.196 --> 00:20:05.406 A:middle
only some of the arguments.

00:20:06.266 --> 00:20:08.236 A:middle
As of Swift 5, this problem is

00:20:08.236 --> 00:20:08.626 A:middle
fixed.

00:20:09.506 --> 00:20:11.106 A:middle
Everything works as you expect

00:20:11.606 --> 00:20:15.736 A:middle
[applause].

00:20:16.236 --> 00:20:18.286 A:middle
And the compiler generates

00:20:18.506 --> 00:20:19.766 A:middle
initializers for all of these

00:20:19.766 --> 00:20:20.156 A:middle
cases.

00:20:21.116 --> 00:20:23.176 A:middle
Another imported area is high

00:20:23.176 --> 00:20:24.206 A:middle
performance computing.

00:20:25.106 --> 00:20:26.896 A:middle
In Swift 5 the standard library

00:20:26.896 --> 00:20:29.006 A:middle
added support for SIMD, Single

00:20:29.006 --> 00:20:30.396 A:middle
Instruction Multiple Data

00:20:30.496 --> 00:20:31.576 A:middle
instructions and types.

00:20:32.496 --> 00:20:33.986 A:middle
These are often used for writing

00:20:33.986 --> 00:20:36.056 A:middle
low level performance sensitive

00:20:36.056 --> 00:20:38.116 A:middle
code for graphics, such as image

00:20:38.116 --> 00:20:39.766 A:middle
processing or AR.

00:20:40.276 --> 00:20:41.706 A:middle
In fact, the new RealityKit

00:20:41.706 --> 00:20:43.036 A:middle
library we're shipping this year

00:20:43.276 --> 00:20:44.496 A:middle
is using these types.

00:20:45.226 --> 00:20:47.716 A:middle
The new SIMD types represent

00:20:47.916 --> 00:20:49.486 A:middle
fixed size SIMD vectors.

00:20:50.136 --> 00:20:51.786 A:middle
And as you expect, you can use

00:20:51.786 --> 00:20:53.566 A:middle
the standard library integer and

00:20:53.606 --> 00:20:55.756 A:middle
floating-point types as elements

00:20:55.756 --> 00:20:55.966 A:middle
here.

00:20:56.916 --> 00:20:58.396 A:middle
Let me give you a taste of what

00:20:58.396 --> 00:21:01.916 A:middle
you can do with these types.

00:20:58.396 --> 00:21:01.916 A:middle
you can do with these types.

00:21:02.096 --> 00:21:03.876 A:middle
You can initialize SIMD vector

00:21:03.876 --> 00:21:04.786 A:middle
from array literals.

00:21:05.626 --> 00:21:07.676 A:middle
Here we have array of size four,

00:21:08.156 --> 00:21:09.386 A:middle
actually two arrays of size

00:21:09.386 --> 00:21:09.696 A:middle
four.

00:21:09.696 --> 00:21:11.816 A:middle
And the new dot operators allow

00:21:11.816 --> 00:21:14.046 A:middle
you to perform pointwise

00:21:14.096 --> 00:21:16.096 A:middle
operations on these vectors,

00:21:16.706 --> 00:21:17.946 A:middle
such as equality and

00:21:17.946 --> 00:21:18.676 A:middle
comparisons.

00:21:19.296 --> 00:21:20.906 A:middle
For example here, we are

00:21:20.906 --> 00:21:23.636 A:middle
checking if x is greater than y

00:21:23.936 --> 00:21:24.616 A:middle
pointwise.

00:21:25.406 --> 00:21:27.136 A:middle
And the result tells us that x

00:21:27.136 --> 00:21:29.076 A:middle
is greater than y only at the

00:21:29.076 --> 00:21:30.076 A:middle
last two points.

00:21:30.676 --> 00:21:33.076 A:middle
The result is stored in another

00:21:33.076 --> 00:21:36.136 A:middle
type called SIMDMask and the dot

00:21:36.136 --> 00:21:37.906 A:middle
operators on the SIMDMask type

00:21:37.906 --> 00:21:40.096 A:middle
allow you to manipulate these

00:21:40.496 --> 00:21:42.036 A:middle
resulting masks further.

00:21:42.246 --> 00:21:43.226 A:middle
For example here, we are

00:21:43.226 --> 00:21:44.356 A:middle
negating the result of the

00:21:44.356 --> 00:21:45.466 A:middle
previous computation.

00:21:48.376 --> 00:21:50.456 A:middle
Swift 5 also gives you more

00:21:50.456 --> 00:21:52.206 A:middle
expressivity for manipulating

00:21:53.426 --> 00:21:53.576 A:middle
text.

00:21:53.806 --> 00:21:55.246 A:middle
String interpolation has been

00:21:55.246 --> 00:21:56.946 A:middle
redesigned in Swift 5.

00:21:57.506 --> 00:22:00.346 A:middle
The new design is up to 1.7

00:21:57.506 --> 00:22:00.346 A:middle
The new design is up to 1.7

00:22:00.346 --> 00:22:03.376 A:middle
times faster and further, you

00:22:03.376 --> 00:22:05.256 A:middle
can customize the built

00:22:05.256 --> 00:22:07.116 A:middle
interpolation by providing your

00:22:07.116 --> 00:22:08.676 A:middle
own helpers and you can

00:22:08.676 --> 00:22:10.956 A:middle
initialize your own types with

00:22:10.956 --> 00:22:12.946 A:middle
interpolated strings, giving

00:22:12.946 --> 00:22:14.356 A:middle
string interpolation cost and

00:22:14.356 --> 00:22:14.786 A:middle
meanings.

00:22:15.886 --> 00:22:17.576 A:middle
Swift can support the string

00:22:17.576 --> 00:22:18.726 A:middle
interpolation from the very

00:22:18.726 --> 00:22:19.116 A:middle
beginning.

00:22:19.466 --> 00:22:20.666 A:middle
If you write the backslash

00:22:21.016 --> 00:22:22.266 A:middle
followed by some parenthesized

00:22:22.266 --> 00:22:23.566 A:middle
quote inside of a string

00:22:23.566 --> 00:22:25.166 A:middle
literal, the compiler will

00:22:25.166 --> 00:22:26.636 A:middle
execute the code and insert the

00:22:26.636 --> 00:22:28.476 A:middle
string and insert the value into

00:22:28.476 --> 00:22:28.916 A:middle
the string.

00:22:28.916 --> 00:22:31.246 A:middle
This has always worked but there

00:22:31.246 --> 00:22:32.546 A:middle
were some limitations as well.

00:22:33.556 --> 00:22:35.736 A:middle
For example, using an

00:22:35.736 --> 00:22:37.816 A:middle
interpolated string enclosed to

00:22:37.816 --> 00:22:40.056 A:middle
NSLocalizedString does not work.

00:22:41.236 --> 00:22:43.346 A:middle
The interpolation happens before

00:22:43.346 --> 00:22:44.276 A:middle
the translation.

00:22:44.946 --> 00:22:46.986 A:middle
And for example here, the string

00:22:46.986 --> 00:22:48.996 A:middle
file does not contain a

00:22:48.996 --> 00:22:51.246 A:middle
translation of this string with

00:22:51.296 --> 00:22:52.896 A:middle
every single integer inserted

00:22:52.896 --> 00:22:53.306 A:middle
into it.

00:22:53.726 --> 00:22:57.636 A:middle
So, you have 10 apples will not

00:22:57.636 --> 00:22:58.466 A:middle
get translated.

00:22:59.576 --> 00:23:01.016 A:middle
Instead what you need to do is

00:22:59.576 --> 00:23:01.016 A:middle
Instead what you need to do is

00:23:01.016 --> 00:23:02.586 A:middle
first construct the

00:23:02.636 --> 00:23:03.416 A:middle
formatString.

00:23:05.146 --> 00:23:07.166 A:middle
Next, localize it.

00:23:08.176 --> 00:23:10.046 A:middle
And only after that, insert the

00:23:10.046 --> 00:23:11.716 A:middle
value into the localized string.

00:23:12.836 --> 00:23:14.376 A:middle
This is the right way to do

00:23:14.376 --> 00:23:16.726 A:middle
string localization with UIKit

00:23:16.726 --> 00:23:17.406 A:middle
and AppKit.

00:23:18.456 --> 00:23:20.476 A:middle
But the new string interpolation

00:23:20.476 --> 00:23:22.236 A:middle
design lets us take it another

00:23:22.236 --> 00:23:24.526 A:middle
step forward and design really

00:23:24.526 --> 00:23:26.946 A:middle
expressive APIs like text from

00:23:26.946 --> 00:23:28.036 A:middle
the SwiftUI framework.

00:23:28.706 --> 00:23:30.666 A:middle
Text is used to represent label

00:23:30.666 --> 00:23:32.906 A:middle
in SwiftUI and we want that

00:23:32.906 --> 00:23:33.506 A:middle
localized.

00:23:34.616 --> 00:23:35.606 A:middle
Let's see how that works.

00:23:36.336 --> 00:23:39.096 A:middle
Here we are passing an

00:23:39.096 --> 00:23:40.256 A:middle
interpolated string to the

00:23:40.256 --> 00:23:41.526 A:middle
initializer of text.

00:23:42.506 --> 00:23:44.126 A:middle
And the trick here is that the

00:23:44.126 --> 00:23:46.656 A:middle
text initializer does not take a

00:23:46.656 --> 00:23:48.046 A:middle
string type as its input.

00:23:48.616 --> 00:23:50.026 A:middle
It takes another type called

00:23:50.146 --> 00:23:52.456 A:middle
LocalizedStringKey that is

00:23:52.456 --> 00:23:54.166 A:middle
defined inside of a SwiftUI

00:23:54.166 --> 00:23:54.616 A:middle
framework.

00:23:54.726 --> 00:23:56.916 A:middle
Because of this, the Swift

00:23:56.946 --> 00:23:58.316 A:middle
compiler uses the cost and

00:23:58.316 --> 00:24:00.186 A:middle
conformance to the expressible

00:23:58.316 --> 00:24:00.186 A:middle
conformance to the expressible

00:24:00.186 --> 00:24:02.026 A:middle
by string interpolation protocol

00:24:02.236 --> 00:24:03.876 A:middle
to process this interpolation.

00:24:04.896 --> 00:24:06.496 A:middle
Once it knows which conformance

00:24:06.496 --> 00:24:08.656 A:middle
to use, the compiler translates

00:24:08.656 --> 00:24:10.606 A:middle
this string interpolation with

00:24:10.606 --> 00:24:12.156 A:middle
this autogenerated code.

00:24:13.306 --> 00:24:14.746 A:middle
Let step three to understand

00:24:14.746 --> 00:24:15.276 A:middle
what it does.

00:24:16.166 --> 00:24:18.546 A:middle
First, Swift creates an instance

00:24:18.596 --> 00:24:21.296 A:middle
for a builder specifically for

00:24:21.296 --> 00:24:23.076 A:middle
the LocalizedStringKey.

00:24:23.566 --> 00:24:25.396 A:middle
This instance will contain two

00:24:25.396 --> 00:24:27.876 A:middle
things, formatKey and an

00:24:27.876 --> 00:24:29.276 A:middle
argument array separately.

00:24:30.756 --> 00:24:33.216 A:middle
Next we build up the string by

00:24:33.716 --> 00:24:35.566 A:middle
processing the segments of the

00:24:35.566 --> 00:24:36.336 A:middle
interpolation.

00:24:37.076 --> 00:24:38.666 A:middle
First, we have a string literal

00:24:38.786 --> 00:24:40.036 A:middle
and we add it to the formatKey.

00:24:41.296 --> 00:24:43.506 A:middle
Second, on processing quantity,

00:24:43.646 --> 00:24:45.856 A:middle
restore the format specifier in

00:24:45.856 --> 00:24:48.256 A:middle
the formatKey and the value

00:24:48.256 --> 00:24:49.596 A:middle
inside of the arguments array

00:24:49.636 --> 00:24:50.186 A:middle
separately.

00:24:51.666 --> 00:24:53.356 A:middle
Last, we add another literal to

00:24:53.356 --> 00:24:54.046 A:middle
the formatKey.

00:24:55.346 --> 00:24:57.466 A:middle
And finally, the initializer for

00:24:57.466 --> 00:24:58.626 A:middle
the LocalizedStringKey is

00:24:58.626 --> 00:24:58.946 A:middle
called.

00:24:58.946 --> 00:25:00.806 A:middle
At this point you have enough

00:24:58.946 --> 00:25:00.806 A:middle
At this point you have enough

00:25:00.806 --> 00:25:02.826 A:middle
information to properly localize

00:25:02.826 --> 00:25:03.306 A:middle
the string.

00:25:05.356 --> 00:25:06.856 A:middle
So, SwiftUI can use this

00:25:06.856 --> 00:25:08.326 A:middle
language feature to localize the

00:25:08.386 --> 00:25:11.236 A:middle
text, and the user can read the

00:25:11.236 --> 00:25:11.776 A:middle
message.

00:25:12.076 --> 00:25:12.646 A:middle
Pretty cool.

00:25:13.516 --> 00:25:19.036 A:middle
[ Applause ]

00:25:19.536 --> 00:25:21.266 A:middle
This example only scratches the

00:25:21.266 --> 00:25:22.796 A:middle
surface of what you can do with

00:25:22.796 --> 00:25:23.886 A:middle
string interpolation.

00:25:24.296 --> 00:25:26.196 A:middle
And if you're as excited as us

00:25:26.196 --> 00:25:27.886 A:middle
about this new feature, a good

00:25:27.916 --> 00:25:29.456 A:middle
place to get started is reading

00:25:29.456 --> 00:25:30.646 A:middle
documentation for the

00:25:30.646 --> 00:25:32.426 A:middle
ExpressibleByStringInterpolation

00:25:32.426 --> 00:25:33.056 A:middle
protocol.

00:25:35.166 --> 00:25:36.926 A:middle
Now, let's talk about focus.

00:25:37.506 --> 00:25:39.896 A:middle
Part of API design is deciding

00:25:39.896 --> 00:25:42.806 A:middle
what to exclude from your API.

00:25:42.876 --> 00:25:44.766 A:middle
And in Swift 5.1, we've

00:25:44.866 --> 00:25:46.256 A:middle
specifically made improvements

00:25:46.256 --> 00:25:47.466 A:middle
around returned types.

00:25:47.986 --> 00:25:50.146 A:middle
While it's important that the

00:25:50.146 --> 00:25:51.636 A:middle
returned type represents

00:25:51.636 --> 00:25:53.166 A:middle
capabilities of the type that

00:25:53.166 --> 00:25:54.956 A:middle
the user of your API should

00:25:54.956 --> 00:25:57.416 A:middle
reason about, sometimes we want

00:25:57.416 --> 00:25:59.246 A:middle
to abstract what we return.

00:26:00.246 --> 00:26:01.906 A:middle
A function could return multiple

00:26:01.906 --> 00:26:05.066 A:middle
times at runtime, or maybe it

00:26:05.066 --> 00:26:06.736 A:middle
always returns the same type,

00:26:07.366 --> 00:26:08.716 A:middle
but that type might leak

00:26:08.716 --> 00:26:11.296 A:middle
implementation detail about your

00:26:11.296 --> 00:26:11.426 A:middle
API,

00:26:12.456 --> 00:26:14.446 A:middle
exposing something that the user

00:26:14.446 --> 00:26:15.806 A:middle
of your API should not reason

00:26:15.806 --> 00:26:16.186 A:middle
about.

00:26:17.026 --> 00:26:18.456 A:middle
Let's take a look at the options

00:26:18.666 --> 00:26:20.326 A:middle
that Swift provides for these

00:26:20.326 --> 00:26:20.766 A:middle
cases.

00:26:22.226 --> 00:26:23.846 A:middle
We'll use the simple shape API

00:26:24.176 --> 00:26:25.106 A:middle
in our examples.

00:26:25.626 --> 00:26:27.116 A:middle
Here as you'd expect we have a

00:26:27.116 --> 00:26:29.626 A:middle
shape protocol and we have types

00:26:29.626 --> 00:26:31.696 A:middle
that define basic shapes like

00:26:31.696 --> 00:26:34.616 A:middle
circle, oval, and square.

00:26:35.736 --> 00:26:37.226 A:middle
Further we have structs that

00:26:37.226 --> 00:26:40.136 A:middle
manipulate shapes creating their

00:26:40.136 --> 00:26:42.256 A:middle
union and transforming them.

00:26:42.916 --> 00:26:44.476 A:middle
Consider this face shape

00:26:44.476 --> 00:26:45.076 A:middle
example.

00:26:45.796 --> 00:26:47.906 A:middle
Note that this API returns

00:26:47.946 --> 00:26:50.206 A:middle
different types depending on the

00:26:50.296 --> 00:26:53.016 A:middle
type of your shape-- face but

00:26:53.216 --> 00:26:55.166 A:middle
all of them conform to the shape

00:26:55.166 --> 00:26:55.686 A:middle
protocol.

00:26:55.996 --> 00:26:57.806 A:middle
So it's a great place to use the

00:26:57.876 --> 00:26:59.246 A:middle
protocol type as our returned

00:26:59.246 --> 00:26:59.466 A:middle
type.

00:27:00.086 --> 00:27:02.726 A:middle
Now, what about this example

00:27:02.916 --> 00:27:05.126 A:middle
where we're constructing an

00:27:05.216 --> 00:27:07.696 A:middle
eight-pointed star by creating a

00:27:07.696 --> 00:27:09.566 A:middle
union of a square and the

00:27:09.566 --> 00:27:10.596 A:middle
transformed square?

00:27:11.866 --> 00:27:13.476 A:middle
Declaring the concrete return

00:27:13.476 --> 00:27:15.376 A:middle
type here, will leak most of the

00:27:15.376 --> 00:27:16.696 A:middle
implementation details to the

00:27:16.696 --> 00:27:19.726 A:middle
client and expose-- exposing

00:27:19.726 --> 00:27:21.546 A:middle
this unnecessary detail will

00:27:21.546 --> 00:27:23.706 A:middle
make the API hard to reason

00:27:23.706 --> 00:27:24.106 A:middle
about.

00:27:25.626 --> 00:27:27.406 A:middle
However, using a protocol type

00:27:27.406 --> 00:27:29.216 A:middle
shape here is also not so great.

00:27:29.606 --> 00:27:30.236 A:middle
Let's see why.

00:27:31.706 --> 00:27:33.226 A:middle
When the protocol type is

00:27:33.226 --> 00:27:34.856 A:middle
returned, there is no guarantee

00:27:34.856 --> 00:27:36.516 A:middle
that the same type will be

00:27:36.516 --> 00:27:38.046 A:middle
returned from every call to the

00:27:38.046 --> 00:27:40.606 A:middle
API, which, in addition to the

00:27:40.606 --> 00:27:42.486 A:middle
Swift generic's model, brings us

00:27:42.486 --> 00:27:44.086 A:middle
these fundamental limitations.

00:27:44.806 --> 00:27:46.906 A:middle
If you have two values of

00:27:46.906 --> 00:27:49.046 A:middle
eight-pointed star, return from

00:27:49.046 --> 00:27:51.336 A:middle
the same API but two different

00:27:51.336 --> 00:27:53.526 A:middle
calls to this API, they might

00:27:53.526 --> 00:27:54.976 A:middle
not have the same type so you

00:27:54.976 --> 00:27:56.236 A:middle
cannot compare them for

00:27:56.236 --> 00:27:56.766 A:middle
equality.

00:27:57.636 --> 00:27:59.296 A:middle
The returned type cannot have

00:27:59.296 --> 00:28:01.766 A:middle
any associated types nor it can

00:27:59.296 --> 00:28:01.766 A:middle
any associated types nor it can

00:28:01.766 --> 00:28:03.096 A:middle
have requirements that involve

00:28:03.096 --> 00:28:03.486 A:middle
self.

00:28:04.526 --> 00:28:06.606 A:middle
Further, losing this type

00:28:06.606 --> 00:28:07.926 A:middle
identity may prevent some

00:28:07.926 --> 00:28:08.976 A:middle
compiler optimizations.

00:28:11.496 --> 00:28:14.216 A:middle
Swift 5.1 introduces another

00:28:14.216 --> 00:28:16.666 A:middle
concept called opaque results

00:28:16.716 --> 00:28:17.126 A:middle
types.

00:28:17.706 --> 00:28:19.476 A:middle
It's a great feat for APIs that

00:28:19.476 --> 00:28:21.476 A:middle
are known to return the same

00:28:21.476 --> 00:28:24.406 A:middle
concrete type, but might want to

00:28:24.406 --> 00:28:26.396 A:middle
hide them, this type from their

00:28:26.396 --> 00:28:26.816 A:middle
users.

00:28:27.876 --> 00:28:29.126 A:middle
And opaque result type is

00:28:29.126 --> 00:28:31.576 A:middle
spelled some shape and it

00:28:31.576 --> 00:28:33.736 A:middle
conveys that a specific shape

00:28:33.736 --> 00:28:35.266 A:middle
type is returned from this API.

00:28:36.936 --> 00:28:38.996 A:middle
This guarantee of type identity

00:28:39.316 --> 00:28:40.536 A:middle
also allows us to perform

00:28:40.536 --> 00:28:42.326 A:middle
stronger type checking inside of

00:28:42.326 --> 00:28:43.586 A:middle
the body of the API.

00:28:44.516 --> 00:28:46.296 A:middle
So, if you have several return

00:28:46.296 --> 00:28:48.046 A:middle
statements that return different

00:28:48.046 --> 00:28:50.946 A:middle
types, the compiler will cache

00:28:51.256 --> 00:28:52.796 A:middle
that and remind you to fix the

00:28:52.796 --> 00:28:53.246 A:middle
problem.

00:28:54.606 --> 00:28:55.996 A:middle
Opaque result types are

00:28:55.996 --> 00:28:58.476 A:middle
available in Swift 5.1 and you

00:28:58.476 --> 00:28:59.846 A:middle
can read more about them in our

00:28:59.846 --> 00:29:00.626 A:middle
documentation.

00:28:59.846 --> 00:29:00.626 A:middle
documentation.

00:29:01.806 --> 00:29:03.296 A:middle
Note that this feature requires

00:29:03.296 --> 00:29:04.336 A:middle
new Swift runtime.

00:29:05.086 --> 00:29:06.626 A:middle
So it will only work on newer

00:29:06.626 --> 00:29:07.366 A:middle
Swift OS.

00:29:08.356 --> 00:29:09.796 A:middle
If you had caught that backward

00:29:09.796 --> 00:29:11.636 A:middle
deploy, you can use this feature

00:29:11.636 --> 00:29:13.686 A:middle
but you need to guard their uses

00:29:13.986 --> 00:29:15.656 A:middle
with static availability checks.

00:29:17.816 --> 00:29:19.766 A:middle
Now let's talk about code reuse,

00:29:19.866 --> 00:29:21.126 A:middle
and the new feature called

00:29:21.216 --> 00:29:22.306 A:middle
property wrappers.

00:29:23.636 --> 00:29:25.296 A:middle
Custom patterns for accessing

00:29:25.296 --> 00:29:26.306 A:middle
properties are common.

00:29:26.856 --> 00:29:28.816 A:middle
Some of you-- Some of these

00:29:28.816 --> 00:29:30.246 A:middle
patterns have first class

00:29:30.246 --> 00:29:32.426 A:middle
language support, such as lazy,

00:29:32.866 --> 00:29:34.206 A:middle
but you are also probably

00:29:34.206 --> 00:29:35.466 A:middle
writing your own custom

00:29:35.466 --> 00:29:35.826 A:middle
wrappers.

00:29:36.716 --> 00:29:39.066 A:middle
Maybe you have some storage that

00:29:39.106 --> 00:29:41.406 A:middle
access a thread local

00:29:41.406 --> 00:29:42.396 A:middle
[inaudible].

00:29:42.396 --> 00:29:43.686 A:middle
Maybe you have computed

00:29:43.686 --> 00:29:45.046 A:middle
properties to store your user

00:29:45.046 --> 00:29:45.536 A:middle
defaults.

00:29:46.956 --> 00:29:48.666 A:middle
We write custom getters and

00:29:48.666 --> 00:29:50.476 A:middle
setters all the time, but

00:29:50.476 --> 00:29:52.146 A:middle
sometimes that code is repeated.

00:29:53.106 --> 00:29:54.636 A:middle
For example here, I have two

00:29:54.636 --> 00:29:57.046 A:middle
properties that specify my user

00:29:57.046 --> 00:29:57.506 A:middle
default.

00:29:58.436 --> 00:29:59.696 A:middle
But most of this code is just

00:29:59.696 --> 00:30:02.206 A:middle
copy and pasted.

00:29:59.696 --> 00:30:02.206 A:middle
copy and pasted.

00:30:02.336 --> 00:30:03.856 A:middle
With property wrappers, we can

00:30:03.856 --> 00:30:06.756 A:middle
declare one type that specifies

00:30:06.756 --> 00:30:07.896 A:middle
the access pattern.

00:30:09.446 --> 00:30:10.816 A:middle
Let's call it user default.

00:30:12.186 --> 00:30:13.846 A:middle
Further, we tell the compiler

00:30:13.846 --> 00:30:15.416 A:middle
that this type is special.

00:30:16.256 --> 00:30:18.246 A:middle
Its primary purpose is to wrap a

00:30:18.246 --> 00:30:20.776 A:middle
property, specify its access

00:30:20.826 --> 00:30:21.236 A:middle
pattern.

00:30:22.486 --> 00:30:24.646 A:middle
What that gives us is this type

00:30:24.646 --> 00:30:26.056 A:middle
will allow us to use a custom

00:30:26.106 --> 00:30:28.796 A:middle
attribute to declare properties

00:30:28.796 --> 00:30:30.786 A:middle
that use-- user default access

00:30:30.786 --> 00:30:31.126 A:middle
pattern.

00:30:32.486 --> 00:30:33.556 A:middle
Let's take a closer look.

00:30:33.806 --> 00:30:35.326 A:middle
With the property wrappers in

00:30:35.326 --> 00:30:38.746 A:middle
place, we can rewrite that two

00:30:38.746 --> 00:30:40.116 A:middle
user default properties from

00:30:40.116 --> 00:30:41.096 A:middle
before was this code.

00:30:41.216 --> 00:30:43.626 A:middle
There is no repetition here.

00:30:43.626 --> 00:30:44.886 A:middle
It's very clean.

00:30:45.386 --> 00:30:47.196 A:middle
All I needed to do is add the

00:30:47.196 --> 00:30:50.546 A:middle
custom attributes, and also know

00:30:50.546 --> 00:30:52.236 A:middle
that these properties still are

00:30:52.236 --> 00:30:53.436 A:middle
declared a type Bool.

00:30:53.716 --> 00:30:55.296 A:middle
So you can use them as if they

00:30:55.296 --> 00:30:56.826 A:middle
were simple Boolean values.

00:30:58.516 --> 00:31:04.276 A:middle
[ Applause ]

00:30:58.516 --> 00:31:04.276 A:middle
[ Applause ]

00:31:04.776 --> 00:31:06.236 A:middle
Property wrappers allow us to

00:31:06.236 --> 00:31:08.096 A:middle
define custom access patterns

00:31:08.486 --> 00:31:09.856 A:middle
and a property can opt into

00:31:09.856 --> 00:31:11.776 A:middle
using them by just adding a

00:31:11.776 --> 00:31:13.086 A:middle
custom attributes to its

00:31:13.086 --> 00:31:13.726 A:middle
declaration.

00:31:16.136 --> 00:31:18.046 A:middle
We reach for specific tools to

00:31:18.046 --> 00:31:19.396 A:middle
solve specific problems.

00:31:19.926 --> 00:31:21.796 A:middle
They each are useful in their

00:31:21.796 --> 00:31:22.486 A:middle
own domains.

00:31:23.526 --> 00:31:25.776 A:middle
Similarly, DSLs play an

00:31:25.776 --> 00:31:26.956 A:middle
important role in programmer's

00:31:26.956 --> 00:31:27.256 A:middle
lives.

00:31:27.936 --> 00:31:29.536 A:middle
We use them to query databases

00:31:30.006 --> 00:31:31.646 A:middle
and build graphs.

00:31:31.646 --> 00:31:33.256 A:middle
We love the declarative style

00:31:33.546 --> 00:31:35.116 A:middle
that allows us to simply and

00:31:35.116 --> 00:31:38.166 A:middle
concisely declare our layout for

00:31:38.166 --> 00:31:39.126 A:middle
our web pages.

00:31:40.016 --> 00:31:41.686 A:middle
However, they are also

00:31:41.686 --> 00:31:42.146 A:middle
different.

00:31:43.176 --> 00:31:44.626 A:middle
Every time we use one as a

00:31:44.626 --> 00:31:46.806 A:middle
contact Switch, each language

00:31:46.806 --> 00:31:48.276 A:middle
comes with its own syntax and

00:31:48.426 --> 00:31:48.966 A:middle
semantics.

00:31:50.166 --> 00:31:51.546 A:middle
They each have unique powerful

00:31:51.546 --> 00:31:52.746 A:middle
tools that support them.

00:31:53.456 --> 00:31:55.576 A:middle
It's very easy if an HTML tag is

00:31:55.576 --> 00:31:57.496 A:middle
missing, if you're inside of an

00:31:57.496 --> 00:31:58.806 A:middle
HTML editor.

00:31:59.916 --> 00:32:01.426 A:middle
However, because syntax and

00:31:59.916 --> 00:32:01.426 A:middle
However, because syntax and

00:32:01.456 --> 00:32:03.436 A:middle
semantics are tuned to specific

00:32:03.506 --> 00:32:05.986 A:middle
purposes, the tools that support

00:32:05.986 --> 00:32:07.386 A:middle
them are also often domain

00:32:07.386 --> 00:32:08.036 A:middle
specific.

00:32:09.196 --> 00:32:10.946 A:middle
So when we need to integrate

00:32:10.946 --> 00:32:12.636 A:middle
these DSLs into our projects,

00:32:13.496 --> 00:32:14.776 A:middle
the options are not so great.

00:32:16.066 --> 00:32:17.586 A:middle
In some cases, we add custom

00:32:17.586 --> 00:32:20.336 A:middle
build phases but often we reach

00:32:20.336 --> 00:32:21.336 A:middle
out to this solution.

00:32:22.456 --> 00:32:23.826 A:middle
I'm sure it looks familiar.

00:32:23.826 --> 00:32:25.296 A:middle
It's a string literal that

00:32:25.296 --> 00:32:26.376 A:middle
represents HTML.

00:32:27.666 --> 00:32:28.946 A:middle
We gained integration but we

00:32:28.946 --> 00:32:29.936 A:middle
lost tool support.

00:32:30.566 --> 00:32:32.726 A:middle
The compiler code completion see

00:32:32.726 --> 00:32:33.606 A:middle
this as a string.

00:32:34.476 --> 00:32:35.866 A:middle
There is no type checking here.

00:32:36.186 --> 00:32:37.776 A:middle
It's a blob of text to the Swift

00:32:37.776 --> 00:32:38.176 A:middle
compiler.

00:32:39.046 --> 00:32:40.526 A:middle
So silly mistakes like

00:32:40.526 --> 00:32:42.836 A:middle
forgetting a closing tag go

00:32:42.836 --> 00:32:44.286 A:middle
unnoticed until runtime.

00:32:45.306 --> 00:32:47.316 A:middle
We want the power of these DSLs

00:32:47.736 --> 00:32:49.146 A:middle
but we also want them to

00:32:49.276 --> 00:32:50.926 A:middle
integrate well in our language

00:32:51.026 --> 00:32:51.526 A:middle
and tools.

00:32:53.316 --> 00:32:55.466 A:middle
In Swift 5.1, we are bringing

00:32:55.466 --> 00:32:57.626 A:middle
the power to define embedded

00:32:57.626 --> 00:32:58.766 A:middle
DSLs into Swift.

00:32:59.516 --> 00:33:06.516 A:middle
[ Applause ]

00:32:59.516 --> 00:33:06.516 A:middle
[ Applause ]

00:33:07.016 --> 00:33:08.256 A:middle
Let's take a look at this code

00:33:08.256 --> 00:33:10.116 A:middle
that defines an HTML object.

00:33:10.656 --> 00:33:12.476 A:middle
One of my colleagues prototype

00:33:12.476 --> 00:33:15.636 A:middle
support for the HTML DSL, just

00:33:15.636 --> 00:33:17.906 A:middle
for fun, in a few hours, using

00:33:17.906 --> 00:33:19.236 A:middle
this new Swift feature.

00:33:20.056 --> 00:33:21.706 A:middle
As you can see here, this code

00:33:21.706 --> 00:33:23.796 A:middle
looks like Swift, but your eyes

00:33:23.796 --> 00:33:25.496 A:middle
are drawn to the HTML elements

00:33:25.496 --> 00:33:26.276 A:middle
is defining.

00:33:26.536 --> 00:33:29.886 A:middle
Here you can see the familiar

00:33:29.886 --> 00:33:32.186 A:middle
Swift concepts like closures and

00:33:32.186 --> 00:33:32.646 A:middle
method calls.

00:33:33.076 --> 00:33:34.596 A:middle
We are using the variables from

00:33:34.596 --> 00:33:35.956 A:middle
our Swift program.

00:33:36.756 --> 00:33:38.496 A:middle
The tools will ensure there are

00:33:38.496 --> 00:33:40.366 A:middle
no unbalanced text and provide

00:33:40.366 --> 00:33:41.536 A:middle
syntax highlights and

00:33:41.536 --> 00:33:42.816 A:middle
refactoring actions.

00:33:43.946 --> 00:33:45.666 A:middle
Our vision is that not only

00:33:45.666 --> 00:33:47.126 A:middle
you'll be able to declare a list

00:33:47.126 --> 00:33:49.366 A:middle
of elements, but you could use

00:33:49.426 --> 00:33:51.506 A:middle
Swift control statements like

00:33:51.506 --> 00:33:54.116 A:middle
this, right here in this DSL.

00:33:56.306 --> 00:33:56.456 A:middle
OK.

00:33:58.516 --> 00:34:02.316 A:middle
[ Applause ]

00:33:58.516 --> 00:34:02.316 A:middle
[ Applause ]

00:34:02.816 --> 00:34:04.386 A:middle
Let's take a look at how this is

00:34:04.386 --> 00:34:05.706 A:middle
implemented under the hood.

00:34:06.256 --> 00:34:07.926 A:middle
The DSL implementer added a

00:34:07.986 --> 00:34:10.116 A:middle
function to construct each HTML

00:34:10.206 --> 00:34:10.565 A:middle
element.

00:34:11.545 --> 00:34:12.676 A:middle
These functions, they're

00:34:12.676 --> 00:34:13.356 A:middle
closures.

00:34:14.216 --> 00:34:16.626 A:middle
And the interesting part here is

00:34:16.626 --> 00:34:18.216 A:middle
that these closures are special.

00:34:18.815 --> 00:34:20.106 A:middle
They all have this custom

00:34:20.106 --> 00:34:22.806 A:middle
attribute, @HTMLBuilder, that

00:34:22.806 --> 00:34:24.656 A:middle
tells the compiler to use the

00:34:24.656 --> 00:34:27.025 A:middle
HTML builder type to process

00:34:27.096 --> 00:34:27.896 A:middle
these closures.

00:34:29.576 --> 00:34:30.826 A:middle
Let's see how disclosure

00:34:30.826 --> 00:34:32.706 A:middle
containing DSL code gets

00:34:32.706 --> 00:34:34.246 A:middle
translated into a normal Swift

00:34:34.286 --> 00:34:34.716 A:middle
closure.

00:34:36.056 --> 00:34:37.896 A:middle
What is this DSL closure doing?

00:34:38.386 --> 00:34:40.016 A:middle
Well, it's producing a batch of

00:34:40.016 --> 00:34:40.446 A:middle
values.

00:34:41.386 --> 00:34:42.806 A:middle
However, those values are not

00:34:42.806 --> 00:34:43.976 A:middle
used and there is no return

00:34:43.976 --> 00:34:45.716 A:middle
statement here either.

00:34:46.456 --> 00:34:48.126 A:middle
To make this work, the compiler

00:34:48.126 --> 00:34:51.286 A:middle
translates this code by first

00:34:51.896 --> 00:34:53.646 A:middle
collecting the unused values,

00:34:54.266 --> 00:34:57.196 A:middle
and second, calling into the

00:34:57.196 --> 00:34:59.036 A:middle
builder functions to combine

00:34:59.036 --> 00:34:59.226 A:middle
them.

00:35:00.686 --> 00:35:02.196 A:middle
These functions are provided by

00:35:02.196 --> 00:35:05.046 A:middle
the HTML builder type that you,

00:35:05.046 --> 00:35:08.076 A:middle
the DSL author, write and it can

00:35:08.146 --> 00:35:10.396 A:middle
construct any object that is

00:35:10.396 --> 00:35:11.576 A:middle
suitable for your DSL.

00:35:12.236 --> 00:35:14.196 A:middle
Here we are building HTML, so it

00:35:14.196 --> 00:35:15.676 A:middle
builds HTML objects.

00:35:17.976 --> 00:35:19.756 A:middle
We are very excited about this

00:35:19.756 --> 00:35:21.336 A:middle
feature and we use it to power

00:35:21.566 --> 00:35:23.796 A:middle
the declarative syntax that you

00:35:23.796 --> 00:35:25.606 A:middle
will use with the new SwiftUI

00:35:25.836 --> 00:35:26.286 A:middle
framework.

00:35:27.516 --> 00:35:33.266 A:middle
[ Applause ]

00:35:33.766 --> 00:35:35.366 A:middle
Here is an example of that

00:35:35.366 --> 00:35:37.616 A:middle
[inaudible] in SwiftUI using its

00:35:37.616 --> 00:35:39.896 A:middle
own custom Swift DSL.

00:35:41.196 --> 00:35:42.706 A:middle
This feature is available in

00:35:42.706 --> 00:35:44.596 A:middle
beta 1, and we'd like to see how

00:35:44.596 --> 00:35:46.146 A:middle
it will benefit you and what

00:35:46.146 --> 00:35:47.846 A:middle
cool DSLs you'll build with it.

00:35:48.886 --> 00:35:50.226 A:middle
We are discussing the details

00:35:50.226 --> 00:35:51.596 A:middle
behind this feature on the Swift

00:35:51.596 --> 00:35:52.526 A:middle
forums right now.

00:35:53.336 --> 00:35:54.356 A:middle
So if you're interested in

00:35:54.356 --> 00:35:55.776 A:middle
shaping the future of this

00:35:55.776 --> 00:35:57.416 A:middle
feature or other Swift features,

00:35:57.886 --> 00:35:59.306 A:middle
we welcome you to participate.

00:36:01.596 --> 00:36:03.216 A:middle
To conclude, many of the

00:36:03.216 --> 00:36:05.106 A:middle
improvements I talked about come

00:36:05.106 --> 00:36:06.996 A:middle
together in the new Swift

00:36:06.996 --> 00:36:08.136 A:middle
frameworks we are shipping this

00:36:08.136 --> 00:36:08.436 A:middle
year.

00:36:09.276 --> 00:36:11.186 A:middle
And we are excited to see how

00:36:11.186 --> 00:36:13.286 A:middle
they will benefit you, to make

00:36:13.286 --> 00:36:15.276 A:middle
your APIs expressive, clear and

00:36:15.276 --> 00:36:15.946 A:middle
easy to use.

00:36:16.776 --> 00:36:18.626 A:middle
Our colleagues will give a talk

00:36:18.626 --> 00:36:20.906 A:middle
on modern Swift API design where

00:36:20.906 --> 00:36:22.466 A:middle
they will share with you some of

00:36:22.466 --> 00:36:24.206 A:middle
the lessons learned when using

00:36:24.206 --> 00:36:26.076 A:middle
these features building Apple

00:36:26.076 --> 00:36:26.646 A:middle
frameworks.

00:36:27.446 --> 00:36:29.356 A:middle
But this is it from us, enjoy

00:36:29.356 --> 00:36:30.016 A:middle
the conference.

00:36:30.316 --> 00:36:30.816 A:middle
Thank you.

00:36:31.516 --> 00:36:36.500 A:middle
[ Applause ]
