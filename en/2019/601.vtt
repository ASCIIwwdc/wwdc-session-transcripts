WEBVTT

00:00:00.506 --> 00:00:05.500 A:middle
[ Music ]

00:00:10.516 --> 00:00:15.926 A:middle
[ Applause ]

00:00:16.426 --> 00:00:17.156 A:middle
&gt;&gt; Hi, everybody.

00:00:17.836 --> 00:00:19.206 A:middle
My name is Jaap van Muijden and

00:00:19.206 --> 00:00:21.336 A:middle
welcome to this session on

00:00:21.336 --> 00:00:22.696 A:middle
Modern Rendering with Metal.

00:00:23.336 --> 00:00:25.386 A:middle
In the first part of the

00:00:25.386 --> 00:00:27.176 A:middle
session, I will go over some of

00:00:27.176 --> 00:00:28.316 A:middle
the more advanced rendering

00:00:28.316 --> 00:00:30.236 A:middle
techniques that you can use in

00:00:30.236 --> 00:00:31.106 A:middle
your apps today.

00:00:32.076 --> 00:00:34.016 A:middle
Then my colleague, Srinivas

00:00:34.096 --> 00:00:36.526 A:middle
Dasari, will talk to you about

00:00:36.526 --> 00:00:39.266 A:middle
moving your CPU render loop to a

00:00:39.266 --> 00:00:40.906 A:middle
more GPU-driven pipeline.

00:00:42.196 --> 00:00:44.426 A:middle
We'll end the session by showing

00:00:44.426 --> 00:00:46.966 A:middle
you how we can use our new GPU

00:00:46.966 --> 00:00:49.186 A:middle
families to easily write cross

00:00:49.316 --> 00:00:49.976 A:middle
spectrum code.

00:00:52.916 --> 00:00:53.716 A:middle
Whether you're starting from

00:00:53.716 --> 00:00:55.936 A:middle
scratch or you want to improve

00:00:55.936 --> 00:00:58.246 A:middle
your existing Metal app, or you

00:00:58.246 --> 00:00:59.716 A:middle
have an amazing rendering engine

00:00:59.816 --> 00:01:01.066 A:middle
that you want to move onto the

00:00:59.816 --> 00:01:01.066 A:middle
that you want to move onto the

00:01:01.066 --> 00:01:03.486 A:middle
Metal platform, we'll show you

00:01:03.546 --> 00:01:05.416 A:middle
how you can make the best use of

00:01:05.416 --> 00:01:07.976 A:middle
the available hardware with the

00:01:07.976 --> 00:01:10.016 A:middle
rendering technique that fits

00:01:10.016 --> 00:01:10.616 A:middle
your needs.

00:01:11.966 --> 00:01:14.126 A:middle
We'll start by taking a look at

00:01:14.126 --> 00:01:16.856 A:middle
some of the range of rendering

00:01:16.856 --> 00:01:18.246 A:middle
techniques that are used by

00:01:18.246 --> 00:01:19.306 A:middle
games and apps today.

00:01:19.626 --> 00:01:22.926 A:middle
We'll start with basic deferred

00:01:22.926 --> 00:01:23.316 A:middle
rendering.

00:01:23.676 --> 00:01:25.356 A:middle
This is the most commonly used

00:01:25.356 --> 00:01:26.646 A:middle
rendering technique used by

00:01:26.646 --> 00:01:29.126 A:middle
games and graphical apps on all

00:01:29.126 --> 00:01:29.816 A:middle
platforms.

00:01:30.536 --> 00:01:31.946 A:middle
We'll discuss the classic

00:01:31.946 --> 00:01:32.966 A:middle
two-pass setup.

00:01:33.376 --> 00:01:34.716 A:middle
We will show you how to

00:01:34.746 --> 00:01:36.686 A:middle
implement this in Metal and how

00:01:36.686 --> 00:01:38.726 A:middle
to optimize this for the iOS

00:01:38.726 --> 00:01:39.126 A:middle
platform.

00:01:40.396 --> 00:01:41.556 A:middle
We'll then move on to tiled

00:01:41.556 --> 00:01:43.376 A:middle
deferred, which extends the

00:01:43.376 --> 00:01:44.856 A:middle
lighting pass of deferred

00:01:44.856 --> 00:01:47.206 A:middle
rendering and is perfect if your

00:01:47.206 --> 00:01:48.426 A:middle
art direction requires you to

00:01:48.426 --> 00:01:49.826 A:middle
have complex lighting setups.

00:01:51.476 --> 00:01:52.426 A:middle
We'll then take a look at

00:01:52.426 --> 00:01:53.276 A:middle
forward rendering.

00:01:53.806 --> 00:01:55.066 A:middle
That's a really good alternative

00:01:55.486 --> 00:01:57.606 A:middle
for the Metal apps that require

00:01:57.606 --> 00:01:58.686 A:middle
complex materials,

00:01:59.196 --> 00:02:01.706 A:middle
anti-aliasing, transparency, or

00:01:59.196 --> 00:02:01.706 A:middle
anti-aliasing, transparency, or

00:02:01.706 --> 00:02:02.456 A:middle
special performance

00:02:02.456 --> 00:02:03.276 A:middle
considerations.

00:02:04.706 --> 00:02:07.076 A:middle
Our last technique we're going

00:02:07.076 --> 00:02:08.776 A:middle
to talk about is visibility

00:02:08.776 --> 00:02:11.276 A:middle
buffer rendering, which defers

00:02:11.276 --> 00:02:12.906 A:middle
the geometry logic all the way

00:02:12.906 --> 00:02:14.606 A:middle
back to the lighting pass and

00:02:14.636 --> 00:02:16.356 A:middle
now in Metal 3, is easier to

00:02:16.356 --> 00:02:17.516 A:middle
implement than ever.

00:02:18.086 --> 00:02:19.926 A:middle
But before we get there, let's

00:02:19.926 --> 00:02:21.556 A:middle
start with deferred rendering.

00:02:23.476 --> 00:02:24.686 A:middle
Deferred rendering splits the

00:02:24.686 --> 00:02:26.086 A:middle
rendering of your scene up into

00:02:26.086 --> 00:02:26.856 A:middle
two passes.

00:02:28.246 --> 00:02:30.226 A:middle
There's the geometry pass, where

00:02:30.226 --> 00:02:31.446 A:middle
you basically render your entire

00:02:31.446 --> 00:02:33.116 A:middle
scene into an intermediate

00:02:33.116 --> 00:02:34.426 A:middle
geometry, or g-buffer.

00:02:34.526 --> 00:02:36.596 A:middle
And the textures in this buffer,

00:02:36.716 --> 00:02:39.046 A:middle
all the normal, the albedo, the

00:02:39.046 --> 00:02:41.266 A:middle
roughness, and any kind of

00:02:41.266 --> 00:02:42.446 A:middle
surface or material property

00:02:42.446 --> 00:02:43.446 A:middle
that you need in your writing

00:02:43.446 --> 00:02:45.006 A:middle
model or your postdressing

00:02:45.006 --> 00:02:45.416 A:middle
pipeline.

00:02:46.866 --> 00:02:50.206 A:middle
Then in the second pass, the

00:02:50.456 --> 00:02:51.866 A:middle
lighting pass renders the light

00:02:51.926 --> 00:02:54.026 A:middle
volumes of your scene and builds

00:02:54.026 --> 00:02:55.936 A:middle
up the final lit scene in

00:02:55.936 --> 00:02:56.886 A:middle
accumulation texture.

00:02:57.496 --> 00:02:59.716 A:middle
The deferred light shaders were

00:02:59.716 --> 00:03:01.146 A:middle
bind all the textures in your

00:02:59.716 --> 00:03:01.146 A:middle
bind all the textures in your

00:03:01.146 --> 00:03:03.016 A:middle
G-buffer to calculate their

00:03:03.016 --> 00:03:04.756 A:middle
contribution to the final lit

00:03:04.756 --> 00:03:05.366 A:middle
surface color.

00:03:06.226 --> 00:03:08.466 A:middle
So, let's define the data flow

00:03:08.466 --> 00:03:09.976 A:middle
of this technique and then move

00:03:09.976 --> 00:03:11.696 A:middle
onto a Metal implementation.

00:03:13.106 --> 00:03:14.286 A:middle
So, here we have our two render

00:03:14.286 --> 00:03:15.966 A:middle
passes, and we'll be running

00:03:15.966 --> 00:03:17.666 A:middle
these two consecutively on the

00:03:17.666 --> 00:03:18.106 A:middle
GPU.

00:03:18.106 --> 00:03:21.296 A:middle
In our geometry pass, we need to

00:03:21.296 --> 00:03:22.856 A:middle
write out depth.

00:03:23.506 --> 00:03:24.646 A:middle
The depth is used to do depth

00:03:24.646 --> 00:03:25.786 A:middle
calling during your geometry

00:03:25.786 --> 00:03:27.726 A:middle
pass, but it's also used to

00:03:27.726 --> 00:03:29.786 A:middle
calculate the pixel location and

00:03:29.786 --> 00:03:31.136 A:middle
world space for your lighting

00:03:31.136 --> 00:03:31.526 A:middle
pass.

00:03:32.186 --> 00:03:34.846 A:middle
And we also output our G-buffer

00:03:34.846 --> 00:03:35.586 A:middle
textures.

00:03:35.696 --> 00:03:37.366 A:middle
In our example here, we'll use

00:03:37.366 --> 00:03:39.556 A:middle
normal, albedo, and roughness

00:03:39.556 --> 00:03:40.276 A:middle
textures.

00:03:41.236 --> 00:03:42.736 A:middle
Then in our second pass, the

00:03:42.736 --> 00:03:44.986 A:middle
lighting pass, we read back the

00:03:44.986 --> 00:03:47.236 A:middle
G-buffer textures and then we

00:03:47.236 --> 00:03:48.416 A:middle
draw light volumes and

00:03:48.416 --> 00:03:50.086 A:middle
accumulate them in our output

00:03:50.086 --> 00:03:50.466 A:middle
texture.

00:03:51.586 --> 00:03:53.166 A:middle
So, let's see how we can

00:03:53.166 --> 00:03:54.136 A:middle
construct this data flow in

00:03:54.136 --> 00:03:54.386 A:middle
Metal.

00:03:55.706 --> 00:03:57.086 A:middle
To set up a render pass in

00:03:57.086 --> 00:03:58.816 A:middle
Metal, you have to start with a

00:03:58.816 --> 00:03:59.726 A:middle
Render Pass descriptor.

00:04:01.166 --> 00:04:02.896 A:middle
The most important part of a

00:04:02.926 --> 00:04:04.196 A:middle
Render Pass descriptor are its

00:04:04.196 --> 00:04:04.806 A:middle
outputs.

00:04:05.466 --> 00:04:06.886 A:middle
In Metal, these are defined with

00:04:06.886 --> 00:04:07.536 A:middle
attachments.

00:04:08.946 --> 00:04:10.066 A:middle
Every Render Pass can have

00:04:10.066 --> 00:04:11.456 A:middle
single depth attachments and

00:04:11.636 --> 00:04:12.946 A:middle
multiple color attachments.

00:04:13.706 --> 00:04:15.486 A:middle
For every attachment, we have to

00:04:15.486 --> 00:04:17.745 A:middle
define the texture which points

00:04:17.745 --> 00:04:18.805 A:middle
to the data that stores our

00:04:18.805 --> 00:04:19.426 A:middle
attachment data.

00:04:19.786 --> 00:04:21.956 A:middle
We have to define our load

00:04:21.956 --> 00:04:23.926 A:middle
action which shows us how to

00:04:23.926 --> 00:04:25.086 A:middle
load the existing data from the

00:04:25.086 --> 00:04:27.916 A:middle
texture and the store action is

00:04:27.916 --> 00:04:29.966 A:middle
how to store the results of your

00:04:29.966 --> 00:04:32.446 A:middle
rendering back into the texture.

00:04:33.406 --> 00:04:34.546 A:middle
When you've defined these

00:04:34.546 --> 00:04:35.596 A:middle
properties of all your

00:04:35.596 --> 00:04:37.916 A:middle
attachments, you can then create

00:04:38.296 --> 00:04:40.946 A:middle
your Render command encoder that

00:04:40.946 --> 00:04:43.136 A:middle
you can then use to finally draw

00:04:43.266 --> 00:04:44.616 A:middle
your objection to your Render

00:04:45.636 --> 00:04:45.966 A:middle
Pass.

00:04:46.196 --> 00:04:47.066 A:middle
Now, let's see how we build this

00:04:47.066 --> 00:04:48.106 A:middle
in Metal, starting with our

00:04:48.106 --> 00:04:48.636 A:middle
setup code.

00:04:49.876 --> 00:04:51.926 A:middle
So, here we have our setup

00:04:51.926 --> 00:04:52.446 A:middle
function.

00:04:53.096 --> 00:04:54.406 A:middle
We'll start by creating a Render

00:04:54.406 --> 00:04:55.136 A:middle
Pass descriptor.

00:04:55.686 --> 00:04:57.086 A:middle
And now we just start filling in

00:04:57.086 --> 00:04:57.986 A:middle
all these attachments.

00:04:58.166 --> 00:04:59.006 A:middle
So, we'll start with the depth

00:04:59.006 --> 00:04:59.506 A:middle
attachment.

00:04:59.606 --> 00:05:01.226 A:middle
And since we're using the depth

00:04:59.606 --> 00:05:01.226 A:middle
And since we're using the depth

00:05:01.226 --> 00:05:02.846 A:middle
attachment to do our depth

00:05:02.846 --> 00:05:03.936 A:middle
calling, we need to make sure

00:05:03.936 --> 00:05:05.056 A:middle
it's clear before we start

00:05:05.056 --> 00:05:05.896 A:middle
rendering our scene.

00:05:06.306 --> 00:05:07.896 A:middle
So, we set our load action to

00:05:07.896 --> 00:05:08.226 A:middle
clear.

00:05:08.766 --> 00:05:10.216 A:middle
Of course we want to store depth

00:05:10.526 --> 00:05:11.446 A:middle
for the second pass.

00:05:12.006 --> 00:05:13.576 A:middle
So, we set R, store action to

00:05:13.576 --> 00:05:13.966 A:middle
store.

00:05:15.206 --> 00:05:16.826 A:middle
Now, we move onto our color

00:05:16.826 --> 00:05:17.396 A:middle
attachments.

00:05:18.256 --> 00:05:19.856 A:middle
The color attachments, we need

00:05:19.856 --> 00:05:21.436 A:middle
one for every texture in our

00:05:21.436 --> 00:05:21.886 A:middle
G-buffer.

00:05:22.506 --> 00:05:23.596 A:middle
And because all these textures

00:05:23.596 --> 00:05:24.666 A:middle
are going to be handled kind of

00:05:24.666 --> 00:05:25.576 A:middle
the same way, we'll just show

00:05:25.576 --> 00:05:26.226 A:middle
you the albedo.

00:05:27.956 --> 00:05:30.506 A:middle
Because we're probably going to

00:05:30.646 --> 00:05:32.216 A:middle
be using like a skybox or a

00:05:32.216 --> 00:05:34.036 A:middle
background during rendering, so,

00:05:34.036 --> 00:05:35.866 A:middle
we're sure that we're going to

00:05:35.866 --> 00:05:37.316 A:middle
be overriding every pixel in our

00:05:37.316 --> 00:05:38.516 A:middle
frame, every frame.

00:05:38.926 --> 00:05:39.956 A:middle
Which means we don't really care

00:05:39.956 --> 00:05:42.156 A:middle
about any previous values in our

00:05:42.156 --> 00:05:43.146 A:middle
G-buffer textures.

00:05:43.196 --> 00:05:44.896 A:middle
So, we can set our load action

00:05:45.086 --> 00:05:45.686 A:middle
to dontcare.

00:05:47.196 --> 00:05:49.196 A:middle
Of course, we want to store the

00:05:49.196 --> 00:05:50.436 A:middle
results of our G-buffer, so we

00:05:50.436 --> 00:05:52.196 A:middle
set our store action to store.

00:05:53.136 --> 00:05:54.866 A:middle
Now we can start with our

00:05:54.866 --> 00:05:55.886 A:middle
lighting pass descriptor.

00:05:56.506 --> 00:05:57.526 A:middle
We create another descriptor

00:05:57.526 --> 00:06:00.096 A:middle
object, and then we defined

00:05:57.526 --> 00:06:00.096 A:middle
object, and then we defined

00:06:00.096 --> 00:06:01.546 A:middle
attachment for accumulation

00:06:01.546 --> 00:06:01.876 A:middle
buffer.

00:06:02.456 --> 00:06:03.976 A:middle
Since we're accumulating data,

00:06:03.976 --> 00:06:05.066 A:middle
we need to clear it before

00:06:05.066 --> 00:06:06.306 A:middle
starting so we put our load

00:06:06.306 --> 00:06:07.516 A:middle
action to clear.

00:06:08.576 --> 00:06:09.936 A:middle
And of course we want to save

00:06:09.936 --> 00:06:11.556 A:middle
our final image, so our store

00:06:11.556 --> 00:06:14.866 A:middle
action's going to be store.

00:06:14.866 --> 00:06:16.606 A:middle
Now, let's look at render loop

00:06:16.676 --> 00:06:17.776 A:middle
while we're using these Render

00:06:17.776 --> 00:06:19.366 A:middle
Passes to actually draw our

00:06:19.366 --> 00:06:19.706 A:middle
scene.

00:06:20.406 --> 00:06:21.896 A:middle
So, we'll start again with our

00:06:21.896 --> 00:06:22.706 A:middle
geometry pass.

00:06:23.236 --> 00:06:24.606 A:middle
We create our Render command

00:06:24.606 --> 00:06:25.956 A:middle
encoder using our descriptor.

00:06:26.406 --> 00:06:28.546 A:middle
And then we start just iterating

00:06:28.546 --> 00:06:29.436 A:middle
over all the measures in our

00:06:29.436 --> 00:06:29.826 A:middle
scene.

00:06:30.246 --> 00:06:32.116 A:middle
This is a very simple way of

00:06:32.116 --> 00:06:32.966 A:middle
rendering your scene.

00:06:34.506 --> 00:06:35.966 A:middle
And my colleague, Srinivas, will

00:06:35.966 --> 00:06:37.866 A:middle
show you in the second part of

00:06:37.866 --> 00:06:39.446 A:middle
this session how you can move

00:06:39.446 --> 00:06:42.436 A:middle
this basic CPU render loop into

00:06:42.436 --> 00:06:44.196 A:middle
a more GPU-driven pipeline with

00:06:44.196 --> 00:06:46.166 A:middle
all kinds of calling and LOD

00:06:46.166 --> 00:06:46.626 A:middle
selection.

00:06:47.466 --> 00:06:49.166 A:middle
Okay, so now we've encoded our

00:06:49.166 --> 00:06:50.396 A:middle
entire geometry buffer.

00:06:50.866 --> 00:06:52.766 A:middle
Sorry, our entire geometry pass,

00:06:53.366 --> 00:06:54.956 A:middle
and we move on to our lighting

00:06:54.956 --> 00:06:55.406 A:middle
pass.

00:06:55.456 --> 00:06:57.466 A:middle
We create another render command

00:06:57.466 --> 00:06:58.156 A:middle
encoder.

00:06:58.506 --> 00:06:59.426 A:middle
And we now we start iterating

00:06:59.426 --> 00:07:00.836 A:middle
over all the lights for our

00:06:59.426 --> 00:07:00.836 A:middle
over all the lights for our

00:07:00.836 --> 00:07:01.626 A:middle
lighting pass.

00:07:02.106 --> 00:07:03.936 A:middle
And every light, every deferred

00:07:03.936 --> 00:07:05.886 A:middle
light shader will bind those

00:07:05.886 --> 00:07:07.376 A:middle
textures from the G-buffer to

00:07:07.376 --> 00:07:08.536 A:middle
calculate its final light

00:07:08.576 --> 00:07:09.066 A:middle
colors.

00:07:10.136 --> 00:07:12.856 A:middle
Well, this two-pass system works

00:07:12.856 --> 00:07:15.716 A:middle
perfectly fine on macOS and iOS

00:07:16.056 --> 00:07:17.116 A:middle
across all platforms.

00:07:17.606 --> 00:07:18.856 A:middle
It's a really good fit for all

00:07:18.856 --> 00:07:19.656 A:middle
types of hardware.

00:07:20.186 --> 00:07:21.596 A:middle
But there are some things that

00:07:21.596 --> 00:07:23.696 A:middle
we can do to further optimize

00:07:23.696 --> 00:07:25.096 A:middle
our implementation on iOS.

00:07:25.546 --> 00:07:26.786 A:middle
So, let's step back from the

00:07:26.786 --> 00:07:29.236 A:middle
code back into our overview.

00:07:29.966 --> 00:07:32.416 A:middle
You can see there's this big

00:07:32.416 --> 00:07:34.366 A:middle
buffer between our two render

00:07:34.366 --> 00:07:34.866 A:middle
passes.

00:07:35.816 --> 00:07:37.656 A:middle
The geometry pass is storing all

00:07:37.656 --> 00:07:38.786 A:middle
its data into these G-buffer

00:07:38.786 --> 00:07:39.316 A:middle
textures.

00:07:40.186 --> 00:07:41.136 A:middle
And then the lighting pass is

00:07:41.136 --> 00:07:41.936 A:middle
bringing them all back.

00:07:42.486 --> 00:07:43.846 A:middle
And if we're having multiple

00:07:43.846 --> 00:07:44.896 A:middle
lights shining on a single

00:07:44.936 --> 00:07:47.166 A:middle
pixel, we're doing this readback

00:07:47.166 --> 00:07:48.026 A:middle
multiple times.

00:07:49.166 --> 00:07:50.666 A:middle
Using a technique called

00:07:50.696 --> 00:07:52.076 A:middle
programmable blending in Metal,

00:07:52.796 --> 00:07:53.546 A:middle
we can get rid of this

00:07:53.546 --> 00:07:55.666 A:middle
intermediate load store into

00:07:55.666 --> 00:07:58.496 A:middle
device memory by leveraging the

00:07:58.536 --> 00:07:59.936 A:middle
taut architecture of iOS

00:07:59.936 --> 00:08:00.526 A:middle
devices.

00:07:59.936 --> 00:08:00.526 A:middle
devices.

00:08:00.916 --> 00:08:02.426 A:middle
So, how do we take advantage of

00:08:02.426 --> 00:08:02.916 A:middle
this technique?

00:08:04.246 --> 00:08:05.326 A:middle
Well, to enable programmable

00:08:05.326 --> 00:08:07.656 A:middle
blending, we merge the geometry

00:08:07.706 --> 00:08:09.396 A:middle
and the lighting pass, and

00:08:09.396 --> 00:08:10.806 A:middle
create a single render encoder

00:08:11.046 --> 00:08:12.326 A:middle
for both Geometry and light

00:08:12.366 --> 00:08:12.746 A:middle
rules.

00:08:13.306 --> 00:08:15.846 A:middle
So, due to the nature of iOS

00:08:15.846 --> 00:08:18.156 A:middle
architecture, the attachments

00:08:18.376 --> 00:08:20.586 A:middle
are kept resident in tile memory

00:08:20.946 --> 00:08:22.386 A:middle
for the entire duration of our

00:08:22.386 --> 00:08:22.826 A:middle
encoder.

00:08:23.846 --> 00:08:25.886 A:middle
This means we can't only write

00:08:25.966 --> 00:08:27.036 A:middle
to our attachments but we can

00:08:27.036 --> 00:08:29.626 A:middle
actually read them back.

00:08:29.626 --> 00:08:31.046 A:middle
We can read back the values of

00:08:31.046 --> 00:08:32.395 A:middle
the same pixel we're writing,

00:08:32.395 --> 00:08:33.746 A:middle
and this is exactly what we

00:08:33.746 --> 00:08:34.076 A:middle
want.

00:08:34.076 --> 00:08:35.515 A:middle
We want, when we're calculating

00:08:36.046 --> 00:08:37.486 A:middle
the light in our lighting pass,

00:08:37.966 --> 00:08:39.876 A:middle
we want to retrieve the written

00:08:39.876 --> 00:08:41.135 A:middle
G-buffer attachments of the same

00:08:41.135 --> 00:08:41.535 A:middle
pixel.

00:08:42.556 --> 00:08:45.006 A:middle
So, let's see how this will

00:08:45.006 --> 00:08:46.216 A:middle
affect our light shaders.

00:08:47.346 --> 00:08:48.206 A:middle
So, here we have a light

00:08:48.206 --> 00:08:49.536 A:middle
fragment shader from our

00:08:49.536 --> 00:08:50.256 A:middle
lighting pass.

00:08:51.116 --> 00:08:53.516 A:middle
And as you might know, you just

00:08:53.516 --> 00:08:54.976 A:middle
start by binding all the

00:08:54.976 --> 00:08:58.296 A:middle
textures that you need to get

00:08:58.296 --> 00:08:58.996 A:middle
your G-buffer data.

00:08:58.996 --> 00:09:01.606 A:middle
And then you have to actually

00:08:58.996 --> 00:09:01.606 A:middle
And then you have to actually

00:09:01.606 --> 00:09:03.076 A:middle
read all these textures across

00:09:03.076 --> 00:09:04.556 A:middle
all your G-buffer textures to

00:09:04.556 --> 00:09:05.806 A:middle
get all the material and surface

00:09:05.806 --> 00:09:06.336 A:middle
information.

00:09:07.186 --> 00:09:09.396 A:middle
Only then can you push this into

00:09:09.396 --> 00:09:10.576 A:middle
your lighting model to get your

00:09:10.576 --> 00:09:11.686 A:middle
final vid color.

00:09:12.246 --> 00:09:13.966 A:middle
Now, let's see what happens if

00:09:13.966 --> 00:09:15.336 A:middle
we use programmable blending.

00:09:16.636 --> 00:09:17.996 A:middle
Instead of binding all the

00:09:17.996 --> 00:09:20.636 A:middle
textures, we simply bind all the

00:09:20.636 --> 00:09:21.576 A:middle
color attachments.

00:09:22.746 --> 00:09:24.526 A:middle
And now we can directly use

00:09:24.656 --> 00:09:26.276 A:middle
these values in our lighting

00:09:26.276 --> 00:09:26.606 A:middle
model.

00:09:27.816 --> 00:09:30.186 A:middle
As you can see, we've created a

00:09:30.186 --> 00:09:31.736 A:middle
new linear depth color

00:09:31.736 --> 00:09:33.186 A:middle
attachment for our G-buffer and

00:09:33.186 --> 00:09:34.326 A:middle
this is because when you're

00:09:34.326 --> 00:09:35.706 A:middle
using programmable blending, you

00:09:35.706 --> 00:09:36.836 A:middle
cannot access the depth

00:09:36.836 --> 00:09:37.396 A:middle
attachments.

00:09:39.376 --> 00:09:40.806 A:middle
So, now that we're no longer

00:09:40.806 --> 00:09:42.586 A:middle
binding or sampling any

00:09:42.586 --> 00:09:44.546 A:middle
textures, let's see how we can

00:09:44.546 --> 00:09:46.336 A:middle
use this to further optimize our

00:09:46.336 --> 00:09:46.956 A:middle
memory layout.

00:09:49.186 --> 00:09:50.266 A:middle
When using programmable

00:09:50.266 --> 00:09:51.516 A:middle
blending, we're no longer

00:09:51.516 --> 00:09:53.676 A:middle
writing or reading from the

00:09:53.676 --> 00:09:54.696 A:middle
G-buffer textures.

00:09:55.046 --> 00:09:56.516 A:middle
So, we can put the store action

00:09:56.516 --> 00:09:58.746 A:middle
of our color attachments to

00:09:58.746 --> 00:09:59.306 A:middle
dontcare.

00:10:00.816 --> 00:10:01.606 A:middle
Okay. So, this solves our

00:10:01.606 --> 00:10:03.426 A:middle
bandwith problem, but we still

00:10:03.426 --> 00:10:04.826 A:middle
have these Metal texture objects

00:10:04.826 --> 00:10:06.156 A:middle
taking up space in our device.

00:10:06.466 --> 00:10:08.436 A:middle
And we need to tell Metal that

00:10:08.586 --> 00:10:10.086 A:middle
we no longer need any physical

00:10:10.086 --> 00:10:11.456 A:middle
memory for our G-buffer

00:10:11.456 --> 00:10:12.036 A:middle
textures.

00:10:12.546 --> 00:10:14.486 A:middle
And we do this by setting the

00:10:14.486 --> 00:10:16.496 A:middle
storage mode of the texture to

00:10:16.496 --> 00:10:18.696 A:middle
memoryless and we tell Metal

00:10:18.976 --> 00:10:20.126 A:middle
that we're no longer going to

00:10:20.326 --> 00:10:21.326 A:middle
basically be performing any

00:10:21.326 --> 00:10:23.026 A:middle
store actions on it, so we don't

00:10:23.026 --> 00:10:23.956 A:middle
need to actually allocate the

00:10:23.956 --> 00:10:24.296 A:middle
memory.

00:10:25.756 --> 00:10:28.566 A:middle
With these steps, we've now end

00:10:28.566 --> 00:10:30.796 A:middle
up with an iOS implementation

00:10:31.106 --> 00:10:32.876 A:middle
that has all the benefits but

00:10:32.996 --> 00:10:34.206 A:middle
without any of the memory or

00:10:34.206 --> 00:10:36.886 A:middle
bandwith overhead of a G-buffer.

00:10:39.716 --> 00:10:40.676 A:middle
Before I move on to tile

00:10:40.676 --> 00:10:42.486 A:middle
deferred, let's summarize.

00:10:43.246 --> 00:10:45.986 A:middle
The separation of the geometry

00:10:45.986 --> 00:10:47.476 A:middle
and lighting pass makes this a

00:10:47.476 --> 00:10:48.646 A:middle
very versatile technique.

00:10:49.376 --> 00:10:50.956 A:middle
It handles both complex geometry

00:10:50.956 --> 00:10:52.056 A:middle
and lighting very well.

00:10:52.566 --> 00:10:54.956 A:middle
And a G-buffer can be used to

00:10:54.956 --> 00:10:56.566 A:middle
facilitate a really deep

00:10:56.676 --> 00:10:57.746 A:middle
postprocessing pipeline.

00:10:58.136 --> 00:10:59.796 A:middle
And an entire pipeline can be

00:10:59.796 --> 00:11:01.946 A:middle
put in line using this

00:10:59.796 --> 00:11:01.946 A:middle
put in line using this

00:11:01.946 --> 00:11:03.666 A:middle
programmable blending method.

00:11:04.276 --> 00:11:06.796 A:middle
On macOS, you still have to deal

00:11:07.016 --> 00:11:08.886 A:middle
with a G-buffer, memory, and

00:11:08.886 --> 00:11:09.576 A:middle
bandwith overhead.

00:11:10.456 --> 00:11:12.706 A:middle
So, now let's move on to tiled

00:11:12.706 --> 00:11:14.746 A:middle
lighting solution, which is

00:11:14.746 --> 00:11:16.216 A:middle
ideal for those of you who want

00:11:16.216 --> 00:11:17.316 A:middle
to render maximum amount of

00:11:17.316 --> 00:11:19.006 A:middle
light but you still want to

00:11:19.006 --> 00:11:21.996 A:middle
reduce your light pass overhead.

00:11:24.216 --> 00:11:26.336 A:middle
The tiled deferred rendering

00:11:26.336 --> 00:11:27.786 A:middle
technique tries to solve the

00:11:27.786 --> 00:11:29.746 A:middle
performance issues of rendering

00:11:29.746 --> 00:11:30.786 A:middle
large amounts of lights.

00:11:31.236 --> 00:11:32.916 A:middle
In classic deferred, we render

00:11:32.916 --> 00:11:34.996 A:middle
every light separately, and this

00:11:34.996 --> 00:11:36.056 A:middle
causes a lot of the G-buffer

00:11:36.056 --> 00:11:38.546 A:middle
overhead for overlapping lights.

00:11:39.216 --> 00:11:41.756 A:middle
Tile deferred rendering extends

00:11:41.756 --> 00:11:42.906 A:middle
the lighting with an additional

00:11:42.906 --> 00:11:45.226 A:middle
compute prepass that allows our

00:11:45.226 --> 00:11:46.686 A:middle
shading to happen not on a per

00:11:46.686 --> 00:11:48.446 A:middle
light level but on a per tile

00:11:48.446 --> 00:11:48.706 A:middle
level.

00:11:49.646 --> 00:11:51.796 A:middle
The prepass first divides our

00:11:51.796 --> 00:11:54.496 A:middle
screen into a 2D grid of

00:11:54.496 --> 00:11:56.786 A:middle
lighting tiles and generates a

00:11:56.786 --> 00:11:58.036 A:middle
light list per tile.

00:11:58.876 --> 00:12:00.676 A:middle
Then in a second step, the

00:11:58.876 --> 00:12:00.676 A:middle
Then in a second step, the

00:12:00.676 --> 00:12:02.606 A:middle
lighting step itself, these

00:12:02.606 --> 00:12:03.936 A:middle
lights are then used to

00:12:03.996 --> 00:12:06.616 A:middle
efficiently light the tile using

00:12:06.616 --> 00:12:08.286 A:middle
a single light fragment shader,

00:12:08.506 --> 00:12:09.666 A:middle
but it's ranging over the lights

00:12:09.666 --> 00:12:10.266 A:middle
in the light list.

00:12:11.006 --> 00:12:12.616 A:middle
Before we dive into the

00:12:12.616 --> 00:12:14.386 A:middle
implementation details, let's

00:12:14.386 --> 00:12:15.816 A:middle
take a quick look at how these

00:12:15.816 --> 00:12:17.206 A:middle
light lists are being generated.

00:12:18.206 --> 00:12:20.816 A:middle
Well, we first split up our view

00:12:20.816 --> 00:12:22.076 A:middle
frustums into these small

00:12:22.076 --> 00:12:24.306 A:middle
subfrustums, one for each tile.

00:12:25.566 --> 00:12:27.116 A:middle
Then we use our compute shader

00:12:27.336 --> 00:12:28.796 A:middle
to further fit down the

00:12:28.796 --> 00:12:30.756 A:middle
subfrustums using the location

00:12:30.756 --> 00:12:32.346 A:middle
of our tile, but also the depth

00:12:32.346 --> 00:12:33.476 A:middle
bounds of the tile.

00:12:34.026 --> 00:12:35.646 A:middle
And we can do this because we've

00:12:35.646 --> 00:12:38.156 A:middle
already ran the geometry pass.

00:12:38.826 --> 00:12:39.976 A:middle
So, the depth buffer is already

00:12:39.976 --> 00:12:40.516 A:middle
populated.

00:12:41.586 --> 00:12:43.076 A:middle
So, when we fitted down these

00:12:43.076 --> 00:12:44.826 A:middle
subfrustums, we can then just

00:12:45.056 --> 00:12:46.966 A:middle
test all the frustums against

00:12:46.966 --> 00:12:49.056 A:middle
the light volumes and add any

00:12:49.056 --> 00:12:50.186 A:middle
intersections to our light list.

00:12:51.516 --> 00:12:53.766 A:middle
This entire process can be done

00:12:53.766 --> 00:12:56.126 A:middle
in parallel across al the tiles

00:12:56.126 --> 00:12:58.036 A:middle
and is a perfect fit for a

00:12:58.036 --> 00:12:59.006 A:middle
compute kernel.

00:13:00.116 --> 00:13:01.936 A:middle
So, how do we integrate this

00:13:02.096 --> 00:13:03.456 A:middle
into our deferred pipeline we

00:13:03.456 --> 00:13:04.006 A:middle
showed before?

00:13:05.396 --> 00:13:06.696 A:middle
Well, before we had this

00:13:06.696 --> 00:13:07.876 A:middle
two-pass deferred setup.

00:13:08.296 --> 00:13:11.056 A:middle
And now we've added this compute

00:13:11.056 --> 00:13:13.146 A:middle
pass to the middle of it.

00:13:14.216 --> 00:13:15.426 A:middle
And that will create in the

00:13:15.426 --> 00:13:16.626 A:middle
light list for us and we need to

00:13:16.626 --> 00:13:18.886 A:middle
store these light lists in a

00:13:18.886 --> 00:13:20.106 A:middle
light list buffer to be stored

00:13:20.106 --> 00:13:20.886 A:middle
in device memory.

00:13:21.906 --> 00:13:24.936 A:middle
So, again, this solution works

00:13:24.936 --> 00:13:26.436 A:middle
fine on all platforms and it

00:13:26.436 --> 00:13:28.676 A:middle
simply requires us to create

00:13:28.676 --> 00:13:31.966 A:middle
additional compute and to move

00:13:31.966 --> 00:13:34.796 A:middle
our lighting logic from a single

00:13:34.796 --> 00:13:36.796 A:middle
light per shader to an iterative

00:13:36.796 --> 00:13:38.686 A:middle
loop in our lighting shader.

00:13:39.726 --> 00:13:40.946 A:middle
Just like with the previous

00:13:40.946 --> 00:13:42.866 A:middle
rendering, we can now take

00:13:42.866 --> 00:13:44.236 A:middle
advantage of the hardware tiling

00:13:44.236 --> 00:13:46.226 A:middle
on iOS to further optimize this.

00:13:46.696 --> 00:13:49.106 A:middle
So, let's take a look of how

00:13:49.106 --> 00:13:50.526 A:middle
this fits in our single encoder

00:13:50.736 --> 00:13:51.696 A:middle
iOS implementation.

00:13:53.186 --> 00:13:54.586 A:middle
So, here we have our single pass

00:13:54.586 --> 00:13:56.196 A:middle
solution we showed before, and

00:13:56.196 --> 00:13:57.406 A:middle
we need to get this computer in

00:13:57.406 --> 00:13:59.216 A:middle
there, but we need to stay

00:13:59.216 --> 00:14:00.226 A:middle
within the single render command

00:13:59.216 --> 00:14:00.226 A:middle
within the single render command

00:14:00.226 --> 00:14:01.616 A:middle
encoder to use the programmable

00:14:01.616 --> 00:14:01.946 A:middle
blending.

00:14:03.216 --> 00:14:05.796 A:middle
Metal provides an efficient way

00:14:06.436 --> 00:14:08.306 A:middle
of using tile-based hardware

00:14:08.306 --> 00:14:09.976 A:middle
architecture to render compute

00:14:09.976 --> 00:14:12.096 A:middle
work on each tile that we're

00:14:12.096 --> 00:14:12.696 A:middle
restorizing.

00:14:13.646 --> 00:14:16.646 A:middle
For this purpose on iOS, the

00:14:16.646 --> 00:14:18.096 A:middle
render command encoder can

00:14:18.096 --> 00:14:20.436 A:middle
encode tiler shader pipelines to

00:14:20.436 --> 00:14:21.596 A:middle
run the compute functions.

00:14:22.356 --> 00:14:24.176 A:middle
And this is a perfect fit for

00:14:24.176 --> 00:14:26.146 A:middle
outside lighting because now we

00:14:26.146 --> 00:14:27.506 A:middle
can take our lighting tile

00:14:27.506 --> 00:14:29.436 A:middle
concept and map that directly on

00:14:29.436 --> 00:14:30.256 A:middle
our hardware tiles.

00:14:31.546 --> 00:14:33.516 A:middle
So, now that our light calling

00:14:33.636 --> 00:14:35.386 A:middle
prepass can be run directly on

00:14:35.386 --> 00:14:37.236 A:middle
our hardware tile, we can use a

00:14:37.236 --> 00:14:39.916 A:middle
second Metal feature called

00:14:39.916 --> 00:14:41.146 A:middle
persistent thread group memory

00:14:41.756 --> 00:14:43.166 A:middle
to store the resulting light

00:14:43.166 --> 00:14:45.506 A:middle
list alongside our attachments

00:14:45.776 --> 00:14:46.486 A:middle
in tile memory.

00:14:48.256 --> 00:14:49.506 A:middle
Which then can be read back,

00:14:49.686 --> 00:14:51.516 A:middle
similarly to the attachments but

00:14:51.516 --> 00:14:52.716 A:middle
all the draws in the render

00:14:52.716 --> 00:14:53.426 A:middle
command encoder.

00:14:54.026 --> 00:14:55.856 A:middle
Which in our case is going to be

00:14:56.056 --> 00:14:57.156 A:middle
our per light draws.

00:15:00.096 --> 00:15:01.966 A:middle
We now move our lighting back

00:15:01.966 --> 00:15:04.096 A:middle
end to execute in line with our

00:15:04.096 --> 00:15:06.576 A:middle
graphics and completely within

00:15:06.576 --> 00:15:07.076 A:middle
tile memory.

00:15:08.246 --> 00:15:09.656 A:middle
So, what does this look like in

00:15:09.656 --> 00:15:10.006 A:middle
Metal?

00:15:10.636 --> 00:15:11.926 A:middle
Let's move back to our setup

00:15:11.926 --> 00:15:12.156 A:middle
code.

00:15:14.186 --> 00:15:16.076 A:middle
Creating a tile shader is very

00:15:16.076 --> 00:15:17.946 A:middle
similar to setting up a normal

00:15:17.946 --> 00:15:18.766 A:middle
render pipeline state.

00:15:19.786 --> 00:15:20.956 A:middle
We create our descriptor.

00:15:21.906 --> 00:15:22.886 A:middle
We set up all our color

00:15:22.886 --> 00:15:23.586 A:middle
attachments.

00:15:24.616 --> 00:15:26.816 A:middle
We then set up our compute

00:15:26.816 --> 00:15:28.026 A:middle
function we want to execute.

00:15:28.566 --> 00:15:29.376 A:middle
And we simply create our

00:15:29.376 --> 00:15:29.976 A:middle
pipeline state.

00:15:30.966 --> 00:15:32.006 A:middle
Because we are using the

00:15:32.006 --> 00:15:33.176 A:middle
precision thread group memory,

00:15:33.656 --> 00:15:34.746 A:middle
we need to reserve a little bit

00:15:34.746 --> 00:15:35.786 A:middle
of memory in our tile.

00:15:36.526 --> 00:15:38.296 A:middle
So, we go back to our render

00:15:38.296 --> 00:15:40.256 A:middle
pass descriptor and then we

00:15:40.256 --> 00:15:42.306 A:middle
simply reserve just enough data

00:15:42.576 --> 00:15:44.226 A:middle
to store our light list.

00:15:45.716 --> 00:15:47.096 A:middle
Now, let's move on to the render

00:15:47.096 --> 00:15:49.226 A:middle
loop to see the dispatch size of

00:15:49.226 --> 00:15:49.756 A:middle
these things.

00:15:50.926 --> 00:15:52.116 A:middle
So, our render loop starts this

00:15:52.116 --> 00:15:53.416 A:middle
time with a single render

00:15:53.416 --> 00:15:54.106 A:middle
command encoder.

00:15:54.746 --> 00:15:56.806 A:middle
And we again loop over all the

00:15:56.806 --> 00:15:59.406 A:middle
meshes in our scene.

00:16:00.026 --> 00:16:02.226 A:middle
And then instead of directly

00:16:02.226 --> 00:16:03.276 A:middle
going to the lighting pass, we

00:16:03.276 --> 00:16:04.386 A:middle
first have to execute our tile

00:16:04.386 --> 00:16:04.696 A:middle
shader.

00:16:05.806 --> 00:16:07.756 A:middle
So, we set up our pipeline

00:16:07.756 --> 00:16:10.136 A:middle
state, we set a buffer that

00:16:10.136 --> 00:16:11.866 A:middle
holds all the lights within our

00:16:11.866 --> 00:16:13.766 A:middle
scene, and then we bind the

00:16:13.766 --> 00:16:16.756 A:middle
thread group memory buffer into

00:16:16.756 --> 00:16:17.366 A:middle
our tile memory.

00:16:17.936 --> 00:16:20.036 A:middle
And then we simply dispatch our

00:16:20.036 --> 00:16:20.516 A:middle
tile shader.

00:16:21.456 --> 00:16:24.656 A:middle
Now that we've executed our tile

00:16:24.656 --> 00:16:26.646 A:middle
shader, the thread group memory

00:16:26.646 --> 00:16:29.086 A:middle
we hold, the light list, we can

00:16:29.086 --> 00:16:31.036 A:middle
then use in the lighting draw

00:16:31.816 --> 00:16:33.606 A:middle
where we can have every pixel

00:16:33.956 --> 00:16:36.016 A:middle
having access to its tiles light

00:16:36.016 --> 00:16:37.656 A:middle
list using the persistent thread

00:16:37.656 --> 00:16:39.776 A:middle
group memory and now very

00:16:39.776 --> 00:16:40.996 A:middle
efficiently can shade its

00:16:40.996 --> 00:16:41.446 A:middle
pixels.

00:16:41.716 --> 00:16:43.916 A:middle
Now finally, after all is set

00:16:43.916 --> 00:16:45.686 A:middle
up, let's see what this looks

00:16:45.686 --> 00:16:46.856 A:middle
like in our shaders.

00:16:48.126 --> 00:16:49.586 A:middle
So, here we have two shaders.

00:16:49.586 --> 00:16:51.226 A:middle
The top one is the tile shader.

00:16:52.206 --> 00:16:54.266 A:middle
It's binding the output light

00:16:54.266 --> 00:16:55.656 A:middle
list into a persistent thread

00:16:55.656 --> 00:16:56.356 A:middle
group memory buffer.

00:16:58.036 --> 00:17:01.006 A:middle
Then it basically loops over all

00:16:58.036 --> 00:17:01.006 A:middle
Then it basically loops over all

00:17:01.006 --> 00:17:02.396 A:middle
the lights in some way and it

00:17:02.396 --> 00:17:04.766 A:middle
outputs the light mask into the

00:17:04.766 --> 00:17:05.816 A:middle
persistent thread group memory,

00:17:07.256 --> 00:17:08.886 A:middle
which can then be read back by

00:17:08.886 --> 00:17:10.726 A:middle
the second shader, our actual

00:17:10.726 --> 00:17:11.356 A:middle
lighting shader.

00:17:12.596 --> 00:17:14.526 A:middle
And then it's right over all the

00:17:14.526 --> 00:17:16.336 A:middle
visible lights within its tile

00:17:16.965 --> 00:17:18.516 A:middle
and shade our pixels.

00:17:19.236 --> 00:17:21.026 A:middle
Now that we've seen all these

00:17:21.026 --> 00:17:23.406 A:middle
key points of implementing the

00:17:23.486 --> 00:17:26.146 A:middle
tiled lighting technique for our

00:17:26.146 --> 00:17:28.786 A:middle
tile deferred technique, let's

00:17:28.786 --> 00:17:29.486 A:middle
see how we can use this

00:17:29.486 --> 00:17:31.826 A:middle
principle to extend our renderer

00:17:32.436 --> 00:17:34.646 A:middle
to frame additional forward pass

00:17:35.176 --> 00:17:35.726 A:middle
efficiently.

00:17:37.296 --> 00:17:38.436 A:middle
Because we've set up our light

00:17:38.436 --> 00:17:40.086 A:middle
list in a persistent thread

00:17:40.146 --> 00:17:41.906 A:middle
group memory, we can use the

00:17:41.906 --> 00:17:43.936 A:middle
same data to accelerate an

00:17:43.936 --> 00:17:46.366 A:middle
effective tiled forward pass.

00:17:47.276 --> 00:17:48.756 A:middle
Whenever we're shading our

00:17:48.756 --> 00:17:50.296 A:middle
forward geometry in our forward

00:17:50.296 --> 00:17:52.756 A:middle
pass, we can simply use that

00:17:52.756 --> 00:17:54.956 A:middle
same persistent thread group

00:17:54.956 --> 00:17:56.386 A:middle
memory to read our tile light

00:17:56.386 --> 00:17:58.466 A:middle
list and use the same light loop

00:17:58.676 --> 00:17:59.766 A:middle
that we've been using in our

00:17:59.766 --> 00:18:01.726 A:middle
deferred lighting to very

00:17:59.766 --> 00:18:01.726 A:middle
deferred lighting to very

00:18:01.726 --> 00:18:03.816 A:middle
efficiently shade our forward

00:18:03.816 --> 00:18:04.236 A:middle
pixels.

00:18:05.436 --> 00:18:07.526 A:middle
This forward pass really rounds

00:18:07.526 --> 00:18:09.516 A:middle
out the capabilities and allows

00:18:09.516 --> 00:18:11.186 A:middle
for transparency, special

00:18:11.186 --> 00:18:12.586 A:middle
effects, and other complex

00:18:12.586 --> 00:18:13.766 A:middle
shading that would normally not

00:18:13.766 --> 00:18:14.976 A:middle
be possible with just deferred.

00:18:15.446 --> 00:18:17.766 A:middle
However, there's always some

00:18:17.766 --> 00:18:19.106 A:middle
limitations to a deferred

00:18:19.106 --> 00:18:19.586 A:middle
pipeline.

00:18:20.076 --> 00:18:20.936 A:middle
Anti-aliasing.

00:18:21.316 --> 00:18:23.916 A:middle
Complex material expressions are

00:18:23.916 --> 00:18:25.346 A:middle
still a problem due to the

00:18:25.346 --> 00:18:26.486 A:middle
intermediate G-buffer

00:18:26.906 --> 00:18:27.656 A:middle
representation.

00:18:28.246 --> 00:18:30.586 A:middle
What we have seen is using this

00:18:30.586 --> 00:18:31.946 A:middle
tile technique we can very

00:18:31.946 --> 00:18:34.616 A:middle
efficiently accelerate forward

00:18:34.616 --> 00:18:35.986 A:middle
rendering using the tiled

00:18:35.986 --> 00:18:36.616 A:middle
lighting technique.

00:18:37.546 --> 00:18:39.756 A:middle
So, let's take a step back and

00:18:39.756 --> 00:18:41.326 A:middle
focus purely on that forward

00:18:41.326 --> 00:18:43.476 A:middle
pass, because alongside with

00:18:43.476 --> 00:18:44.926 A:middle
tiled lighting, this becomes a

00:18:44.926 --> 00:18:46.426 A:middle
viable solution in its own

00:18:46.986 --> 00:18:47.126 A:middle
right.

00:18:48.116 --> 00:18:49.946 A:middle
To create a forward only

00:18:49.946 --> 00:18:51.986 A:middle
renderer, we simply remove the

00:18:51.986 --> 00:18:54.086 A:middle
deferred geometry and lighting

00:18:54.086 --> 00:18:54.506 A:middle
pass.

00:18:55.696 --> 00:18:57.676 A:middle
However, our light calling

00:18:57.676 --> 00:18:59.496 A:middle
technique needs that depth to

00:18:59.496 --> 00:19:00.716 A:middle
fit its subfrustums.

00:18:59.496 --> 00:19:00.716 A:middle
fit its subfrustums.

00:19:01.276 --> 00:19:03.966 A:middle
So, we need to replace our

00:19:03.966 --> 00:19:05.746 A:middle
geometry pass with a depth

00:19:05.776 --> 00:19:07.426 A:middle
prepass to fill this depth

00:19:07.426 --> 00:19:07.706 A:middle
buffer.

00:19:08.256 --> 00:19:10.226 A:middle
And if your engine already has

00:19:10.226 --> 00:19:12.276 A:middle
such a depth prepass, this is

00:19:12.276 --> 00:19:13.506 A:middle
the perfect solution for you.

00:19:14.896 --> 00:19:16.166 A:middle
So, if you have one beat for

00:19:16.166 --> 00:19:17.726 A:middle
overdraw, optimization,

00:19:17.726 --> 00:19:18.606 A:middle
inclusion calling, or

00:19:18.606 --> 00:19:20.276 A:middle
self-blending, this solution

00:19:20.276 --> 00:19:21.026 A:middle
will fit your needs.

00:19:22.236 --> 00:19:24.636 A:middle
However, on iOS hardware, such a

00:19:24.636 --> 00:19:26.476 A:middle
pass is often unnecessary.

00:19:26.526 --> 00:19:29.056 A:middle
And for those cases, a different

00:19:29.056 --> 00:19:30.196 A:middle
lighting solution, called

00:19:30.256 --> 00:19:31.826 A:middle
clustered lighting, might be a

00:19:31.826 --> 00:19:32.456 A:middle
better fit for you.

00:19:33.786 --> 00:19:35.696 A:middle
This clustered solution has a

00:19:35.696 --> 00:19:37.606 A:middle
different way of creating the

00:19:37.606 --> 00:19:38.956 A:middle
light lists that does not

00:19:38.956 --> 00:19:40.336 A:middle
require any depth.

00:19:41.436 --> 00:19:43.456 A:middle
Because for clustered lights, we

00:19:43.456 --> 00:19:45.316 A:middle
don't create any depth bounds

00:19:45.316 --> 00:19:47.136 A:middle
for our tiles but we simply

00:19:47.136 --> 00:19:49.236 A:middle
subdivide the frustums along the

00:19:49.236 --> 00:19:49.976 A:middle
depth axis.

00:19:50.456 --> 00:19:53.116 A:middle
And we then emit a 3D light list

00:19:53.116 --> 00:19:54.506 A:middle
map instead of a 2D light map.

00:19:55.676 --> 00:19:58.276 A:middle
It might not be as efficient as

00:19:58.276 --> 00:20:00.166 A:middle
our fitted subfrustums from our

00:19:58.276 --> 00:20:00.166 A:middle
our fitted subfrustums from our

00:20:00.166 --> 00:20:02.126 A:middle
tiled lighting but it will give

00:20:02.126 --> 00:20:03.426 A:middle
us a measurably improved

00:20:03.426 --> 00:20:05.356 A:middle
performance on lighting, where

00:20:05.356 --> 00:20:07.376 A:middle
every pixel is only shaded by a

00:20:07.376 --> 00:20:08.126 A:middle
local light list.

00:20:10.146 --> 00:20:12.396 A:middle
Using clustered calling combined

00:20:12.396 --> 00:20:14.066 A:middle
with tile shading and persistent

00:20:14.066 --> 00:20:15.676 A:middle
thread group memory, this gives

00:20:15.676 --> 00:20:17.206 A:middle
us very optimized forward

00:20:17.206 --> 00:20:17.516 A:middle
rendering.

00:20:18.116 --> 00:20:21.506 A:middle
We've seen now a few of the most

00:20:21.506 --> 00:20:23.226 A:middle
popular pipelines and how to

00:20:23.226 --> 00:20:24.066 A:middle
implement them on Metal.

00:20:24.066 --> 00:20:26.196 A:middle
Now we're going to look at the

00:20:26.196 --> 00:20:27.566 A:middle
visibility buffer rendering

00:20:27.566 --> 00:20:28.796 A:middle
technique that tackles the

00:20:28.796 --> 00:20:30.646 A:middle
G-buffer overhead in a different

00:20:30.646 --> 00:20:32.346 A:middle
way, making it more suitable for

00:20:32.346 --> 00:20:33.956 A:middle
old hardware that does not

00:20:33.956 --> 00:20:34.936 A:middle
support hardware tiling.

00:20:35.506 --> 00:20:38.626 A:middle
Let's go all the way back to our

00:20:38.626 --> 00:20:39.296 A:middle
deferred renderer.

00:20:39.836 --> 00:20:41.216 A:middle
So, most of the optimization

00:20:41.216 --> 00:20:43.146 A:middle
we've shown so far only work on

00:20:43.146 --> 00:20:44.996 A:middle
the iOS architecture.

00:20:46.556 --> 00:20:47.816 A:middle
The visibility buffer technique

00:20:48.076 --> 00:20:49.616 A:middle
tries to minimize the

00:20:49.616 --> 00:20:51.576 A:middle
intermediate buffer bottleneck

00:20:51.636 --> 00:20:53.556 A:middle
in another way, namely by

00:20:53.556 --> 00:20:55.486 A:middle
storing the absolute minimum

00:20:55.486 --> 00:20:57.116 A:middle
amount of data in that buffer.

00:20:58.176 --> 00:20:59.446 A:middle
Instead of storing all the

00:20:59.446 --> 00:21:01.096 A:middle
surface and material properties

00:20:59.446 --> 00:21:01.096 A:middle
surface and material properties

00:21:01.546 --> 00:21:03.926 A:middle
per pixel, we only store a

00:21:03.976 --> 00:21:05.826 A:middle
primitive identifier and

00:21:05.826 --> 00:21:06.826 A:middle
barycentric coordinates.

00:21:08.996 --> 00:21:10.396 A:middle
This data cannot be used

00:21:10.396 --> 00:21:11.956 A:middle
directly to shade your entire

00:21:11.956 --> 00:21:14.486 A:middle
scene, but it can be used to

00:21:14.486 --> 00:21:16.246 A:middle
reconstruct and interpolate the

00:21:16.246 --> 00:21:18.016 A:middle
original geometry, and then

00:21:18.016 --> 00:21:20.456 A:middle
locally run your entire material

00:21:20.456 --> 00:21:21.796 A:middle
logic within the lighting

00:21:21.796 --> 00:21:22.286 A:middle
shaders.

00:21:23.006 --> 00:21:24.636 A:middle
Since this reconstruction step

00:21:24.636 --> 00:21:26.626 A:middle
is very costly, this works very

00:21:26.626 --> 00:21:28.176 A:middle
well with the tiled lighting

00:21:28.176 --> 00:21:29.366 A:middle
technique because that

00:21:29.366 --> 00:21:30.296 A:middle
guarantees we're only going to

00:21:30.296 --> 00:21:32.066 A:middle
use reconstruction step once per

00:21:32.066 --> 00:21:32.366 A:middle
pixel.

00:21:32.926 --> 00:21:35.306 A:middle
When we're implementing this

00:21:35.306 --> 00:21:36.596 A:middle
technique, the biggest problem

00:21:36.596 --> 00:21:38.786 A:middle
is usually how to create these

00:21:38.786 --> 00:21:40.316 A:middle
primitive indices and how to

00:21:40.366 --> 00:21:41.276 A:middle
create these barycentric

00:21:41.276 --> 00:21:44.316 A:middle
coordinates without a lot of

00:21:44.586 --> 00:21:45.666 A:middle
additional processing.

00:21:46.806 --> 00:21:47.856 A:middle
We're now happy to tell you that

00:21:47.856 --> 00:21:50.116 A:middle
in Metal 3, you can now retrieve

00:21:50.116 --> 00:21:51.206 A:middle
the index of your current

00:21:51.206 --> 00:21:53.016 A:middle
primitive and the barycentric

00:21:53.016 --> 00:21:54.516 A:middle
coordinate of your current pixel

00:21:54.976 --> 00:21:56.026 A:middle
within your fragment shader

00:21:56.236 --> 00:21:57.376 A:middle
using these two new attributes.

00:21:58.796 --> 00:22:00.336 A:middle
The resulting geometry shader is

00:21:58.796 --> 00:22:00.336 A:middle
The resulting geometry shader is

00:22:00.336 --> 00:22:02.276 A:middle
now extremely simple, making

00:22:02.276 --> 00:22:03.576 A:middle
your geometry pass faster than

00:22:03.576 --> 00:22:05.976 A:middle
ever and making it easier to

00:22:05.976 --> 00:22:07.706 A:middle
implement than ever using Metal

00:22:07.706 --> 00:22:07.946 A:middle
3.

00:22:08.536 --> 00:22:11.276 A:middle
We've now gone over all these

00:22:11.276 --> 00:22:12.626 A:middle
different options that you can

00:22:12.626 --> 00:22:14.326 A:middle
use to render your scene in

00:22:14.326 --> 00:22:14.706 A:middle
Metal.

00:22:14.706 --> 00:22:16.836 A:middle
Now let's look at a little demo

00:22:16.836 --> 00:22:17.986 A:middle
that showcases some of these

00:22:17.986 --> 00:22:18.666 A:middle
rendering techniques.

00:22:19.246 --> 00:22:22.166 A:middle
So, here we have our test scene,

00:22:22.166 --> 00:22:23.576 A:middle
which has some rather complex

00:22:23.576 --> 00:22:25.926 A:middle
geometry and setup PBR materials

00:22:25.926 --> 00:22:27.166 A:middle
and array of different material

00:22:27.166 --> 00:22:27.746 A:middle
shaders.

00:22:28.226 --> 00:22:30.136 A:middle
We can use deferred or tile

00:22:30.136 --> 00:22:31.736 A:middle
deferred, or even forward to

00:22:31.736 --> 00:22:33.226 A:middle
render this scene on any of your

00:22:33.226 --> 00:22:33.766 A:middle
devices.

00:22:34.196 --> 00:22:37.076 A:middle
Let's start with the normal

00:22:37.076 --> 00:22:37.756 A:middle
deferred renderer.

00:22:38.076 --> 00:22:39.986 A:middle
The deferred renderer has two

00:22:39.986 --> 00:22:42.306 A:middle
passes, as we've shown before.

00:22:42.366 --> 00:22:43.606 A:middle
And the first pass is now

00:22:43.806 --> 00:22:44.716 A:middle
rendering everything through

00:22:44.716 --> 00:22:45.916 A:middle
these intermediate G-buffers.

00:22:46.446 --> 00:22:47.526 A:middle
Let's look at some of those

00:22:47.526 --> 00:22:48.466 A:middle
G-buffer textures now.

00:22:50.416 --> 00:22:52.186 A:middle
So, here we have the albedo.

00:22:52.236 --> 00:22:55.336 A:middle
We have the normal.

00:22:55.946 --> 00:22:59.196 A:middle
And we have the roughness

00:22:59.196 --> 00:23:00.136 A:middle
texture of our G-buffer.

00:22:59.196 --> 00:23:00.136 A:middle
texture of our G-buffer.

00:23:00.586 --> 00:23:02.016 A:middle
If you have temporal and

00:23:02.016 --> 00:23:03.316 A:middle
aliasing, or more complex

00:23:03.316 --> 00:23:05.156 A:middle
lighting models, you'll probably

00:23:05.156 --> 00:23:06.496 A:middle
need to store more in the

00:23:06.496 --> 00:23:06.986 A:middle
G-buffer.

00:23:07.526 --> 00:23:09.256 A:middle
The scene we're seeing right now

00:23:09.256 --> 00:23:10.856 A:middle
is being lit by that second

00:23:10.856 --> 00:23:12.056 A:middle
lighting pass.

00:23:12.266 --> 00:23:13.996 A:middle
So, let's go to a night scene to

00:23:13.996 --> 00:23:15.246 A:middle
visualize our lights a little

00:23:15.806 --> 00:23:16.776 A:middle
bit better.

00:23:17.386 --> 00:23:19.006 A:middle
Now, in this scene, to get it

00:23:19.006 --> 00:23:20.326 A:middle
lit up like this, we need to

00:23:20.326 --> 00:23:21.996 A:middle
render a lot of lights, which we

00:23:21.996 --> 00:23:23.216 A:middle
are visualizing here.

00:23:24.176 --> 00:23:25.506 A:middle
In normal deferred, we should be

00:23:25.506 --> 00:23:26.426 A:middle
rendering all of these lights

00:23:26.426 --> 00:23:28.196 A:middle
one at a time, which is very

00:23:28.196 --> 00:23:28.616 A:middle
inefficient.

00:23:28.616 --> 00:23:29.596 A:middle
And you can see there's lots of

00:23:29.596 --> 00:23:30.986 A:middle
overlap between the different

00:23:30.986 --> 00:23:31.326 A:middle
lights.

00:23:31.956 --> 00:23:33.996 A:middle
So, let's move on to a tile

00:23:33.996 --> 00:23:34.666 A:middle
deferred lighting.

00:23:35.246 --> 00:23:38.876 A:middle
So, here we have the same scene

00:23:39.226 --> 00:23:41.356 A:middle
rendering using tile deferred

00:23:41.416 --> 00:23:41.976 A:middle
renderer.

00:23:45.376 --> 00:23:47.136 A:middle
What we want to show here was

00:23:47.736 --> 00:23:49.686 A:middle
all the possible visualizations

00:23:49.686 --> 00:23:51.686 A:middle
we had for how the different

00:23:51.686 --> 00:23:54.456 A:middle
tiles, show you the amount of

00:23:54.456 --> 00:23:55.566 A:middle
lights that are being rendered

00:23:55.826 --> 00:23:56.576 A:middle
in each of these different

00:23:56.576 --> 00:23:56.876 A:middle
tiles.

00:23:56.876 --> 00:23:59.486 A:middle
And you can see that it really

00:23:59.606 --> 00:24:01.106 A:middle
makes a difference in using

00:23:59.606 --> 00:24:01.106 A:middle
makes a difference in using

00:24:01.106 --> 00:24:02.396 A:middle
these tiled subdivisions,

00:24:03.146 --> 00:24:04.946 A:middle
relative to just lighting all

00:24:04.946 --> 00:24:07.146 A:middle
the pixels with all the lights

00:24:07.686 --> 00:24:08.036 A:middle
at once.

00:24:08.036 --> 00:24:09.156 A:middle
Now, we've shown you some of

00:24:09.156 --> 00:24:09.896 A:middle
these possible rendering

00:24:09.896 --> 00:24:11.656 A:middle
techniques that you can use to

00:24:11.656 --> 00:24:12.616 A:middle
render your scene.

00:24:13.146 --> 00:24:14.506 A:middle
And now my colleague Srinivas

00:24:14.886 --> 00:24:16.026 A:middle
will show you in the next part

00:24:16.316 --> 00:24:18.046 A:middle
how you can turn your CPU heavy

00:24:18.046 --> 00:24:19.746 A:middle
render loop into a GPU-driven

00:24:19.746 --> 00:24:20.156 A:middle
pipeline.

00:24:22.301 --> 00:24:24.301 A:middle
[ Applause ]

00:24:24.586 --> 00:24:25.016 A:middle
&gt;&gt; Thanks, Al.

00:24:28.016 --> 00:24:30.326 A:middle
With Metal 2, we introduced the

00:24:30.326 --> 00:24:31.826 A:middle
GPU-driven pipelines which

00:24:31.826 --> 00:24:33.626 A:middle
consist of augment buffers and

00:24:33.626 --> 00:24:34.606 A:middle
indirect command buffers

00:24:35.326 --> 00:24:36.936 A:middle
with which you can now move your

00:24:37.016 --> 00:24:38.446 A:middle
CPU-based rendering operations

00:24:38.446 --> 00:24:39.216 A:middle
to the GPU.

00:24:39.786 --> 00:24:41.226 A:middle
My colleague just showed you how

00:24:41.226 --> 00:24:42.786 A:middle
to implement various advanced

00:24:42.786 --> 00:24:43.936 A:middle
rendering techniques with Metal.

00:24:44.746 --> 00:24:46.056 A:middle
In this talk, I'm going to show

00:24:46.056 --> 00:24:47.506 A:middle
you how to move your entire

00:24:47.596 --> 00:24:49.156 A:middle
CPU-based render loop to the

00:24:49.156 --> 00:24:49.676 A:middle
GPU.

00:24:50.456 --> 00:24:51.496 A:middle
Now, this will not only make

00:24:51.496 --> 00:24:52.906 A:middle
your render loop more efficient

00:24:53.216 --> 00:24:54.256 A:middle
but it allows you to free up

00:24:54.256 --> 00:24:55.956 A:middle
your CPU for any other

00:24:55.956 --> 00:24:57.146 A:middle
processing that you may want to

00:24:57.146 --> 00:24:58.726 A:middle
do, like complex physics

00:24:58.726 --> 00:25:00.146 A:middle
simulations REI.

00:24:58.726 --> 00:25:00.146 A:middle
simulations REI.

00:25:00.866 --> 00:25:02.556 A:middle
Now, before diving into details,

00:25:02.556 --> 00:25:04.416 A:middle
let's first see what operations

00:25:04.416 --> 00:25:05.686 A:middle
are usually performed in a

00:25:05.686 --> 00:25:06.346 A:middle
render loop.

00:25:07.646 --> 00:25:09.176 A:middle
Now, large scenes require

00:25:09.176 --> 00:25:10.446 A:middle
complex rendering operations.

00:25:10.616 --> 00:25:12.166 A:middle
So, usually you do a series of

00:25:12.166 --> 00:25:14.766 A:middle
operations to efficiently render

00:25:14.766 --> 00:25:15.236 A:middle
the scene.

00:25:15.756 --> 00:25:17.286 A:middle
So, the first thing that you do

00:25:17.286 --> 00:25:20.016 A:middle
is frustum culling, where you

00:25:20.016 --> 00:25:21.766 A:middle
remove the objects that fall

00:25:21.766 --> 00:25:22.796 A:middle
outside the view frustum.

00:25:23.236 --> 00:25:24.706 A:middle
We only show draw calls for

00:25:24.706 --> 00:25:25.116 A:middle
those.

00:25:25.736 --> 00:25:27.216 A:middle
Next, occlusion culling.

00:25:27.556 --> 00:25:29.146 A:middle
Here you eliminate the objects

00:25:29.456 --> 00:25:30.956 A:middle
that are occluded by other,

00:25:30.956 --> 00:25:31.746 A:middle
bigger objects.

00:25:32.546 --> 00:25:34.106 A:middle
Another thing that usually done

00:25:34.156 --> 00:25:36.456 A:middle
is level of detail selection,

00:25:36.636 --> 00:25:38.596 A:middle
where you select between a range

00:25:38.596 --> 00:25:40.146 A:middle
of levels of details of the

00:25:40.146 --> 00:25:42.066 A:middle
model based on its distance to

00:25:42.066 --> 00:25:42.496 A:middle
the camera.

00:25:43.316 --> 00:25:45.226 A:middle
So, your CPU-based render loop

00:25:45.226 --> 00:25:46.606 A:middle
with all these operations

00:25:46.726 --> 00:25:48.266 A:middle
typically looks like this.

00:25:49.556 --> 00:25:51.526 A:middle
Basically, you first encode your

00:25:51.526 --> 00:25:52.686 A:middle
occluded [draws] and

00:25:52.686 --> 00:25:55.116 A:middle
occlusion test into your command

00:25:55.186 --> 00:25:56.796 A:middle
buffer and you execute it in a

00:25:56.796 --> 00:25:59.016 A:middle
render pass on the GPU to

00:25:59.016 --> 00:26:00.276 A:middle
generate occlude data for the

00:25:59.016 --> 00:26:00.276 A:middle
generate occlude data for the

00:26:00.276 --> 00:26:00.866 A:middle
next frame.

00:26:01.776 --> 00:26:03.396 A:middle
Next, you do frustum culling,

00:26:03.766 --> 00:26:05.096 A:middle
eliminate the objects that are

00:26:05.096 --> 00:26:06.166 A:middle
outside the view frustum.

00:26:06.916 --> 00:26:09.266 A:middle
And LOD selection to pick a

00:26:09.266 --> 00:26:11.716 A:middle
level of detail of the model and

00:26:11.716 --> 00:26:13.416 A:middle
occlusion culling, to eliminate

00:26:13.416 --> 00:26:16.146 A:middle
the objects that are occluded

00:26:16.146 --> 00:26:17.066 A:middle
other, bigger objects.

00:26:17.886 --> 00:26:20.306 A:middle
So finally, you enclosed the

00:26:20.306 --> 00:26:22.006 A:middle
pass for visible objects and

00:26:22.006 --> 00:26:24.366 A:middle
execute it in a render pass to

00:26:24.366 --> 00:26:25.216 A:middle
generate your scene.

00:26:25.786 --> 00:26:27.676 A:middle
Now, this works fine but there

00:26:27.676 --> 00:26:29.196 A:middle
are a couple of inefficiencies

00:26:29.196 --> 00:26:29.416 A:middle
here.

00:26:29.896 --> 00:26:31.356 A:middle
First let's take occlusion

00:26:31.356 --> 00:26:31.586 A:middle
culling.

00:26:31.586 --> 00:26:33.936 A:middle
Now, to do occlusion culling,

00:26:33.936 --> 00:26:35.526 A:middle
you need occlude data for the

00:26:35.526 --> 00:26:36.056 A:middle
current frame.

00:26:36.826 --> 00:26:38.076 A:middle
But because you don't want to

00:26:38.076 --> 00:26:39.466 A:middle
introduce any synchronizations

00:26:39.466 --> 00:26:40.396 A:middle
in the current frame, you

00:26:40.736 --> 00:26:42.306 A:middle
usually rely on the previous

00:26:42.306 --> 00:26:43.836 A:middle
frame's occluder data, which is

00:26:43.836 --> 00:26:45.846 A:middle
usually obtained at a lower

00:26:45.846 --> 00:26:46.326 A:middle
resolution.

00:26:46.996 --> 00:26:48.026 A:middle
So, it can be approximate.

00:26:48.026 --> 00:26:49.856 A:middle
It can lead to false occlusion.

00:26:50.376 --> 00:26:51.786 A:middle
And so you probably have to take

00:26:51.826 --> 00:26:52.926 A:middle
some corrective steps in your

00:26:52.926 --> 00:26:53.266 A:middle
gains.

00:26:54.156 --> 00:26:56.106 A:middle
And second, there are operations

00:26:56.106 --> 00:26:57.346 A:middle
here that are highly

00:26:57.346 --> 00:26:57.966 A:middle
paralyzable.

00:26:58.066 --> 00:27:00.076 A:middle
For example, frustum culling.

00:26:58.066 --> 00:27:00.076 A:middle
For example, frustum culling.

00:27:01.146 --> 00:27:03.666 A:middle
On a single CPU thread it looks

00:27:03.666 --> 00:27:05.766 A:middle
like this, where you'll be doing

00:27:05.766 --> 00:27:07.166 A:middle
frustum culling of each object,

00:27:07.166 --> 00:27:08.246 A:middle
one after the other.

00:27:08.726 --> 00:27:09.706 A:middle
Now, you can definitely

00:27:09.706 --> 00:27:10.696 A:middle
distribute this processing

00:27:10.696 --> 00:27:13.716 A:middle
across multiple CPU threads but

00:27:14.086 --> 00:27:15.436 A:middle
there are only a few CPU threads

00:27:15.436 --> 00:27:15.946 A:middle
available.

00:27:16.436 --> 00:27:17.586 A:middle
And if you include all other

00:27:17.586 --> 00:27:18.686 A:middle
operations that you want to

00:27:18.686 --> 00:27:20.356 A:middle
perform per object, you'll

00:27:20.716 --> 00:27:21.906 A:middle
probably be doing something like

00:27:21.906 --> 00:27:22.366 A:middle
this.

00:27:23.326 --> 00:27:24.776 A:middle
But are these operations highly

00:27:24.776 --> 00:27:25.386 A:middle
paralyzable?

00:27:25.606 --> 00:27:26.906 A:middle
So, if you have more threads,

00:27:27.116 --> 00:27:28.836 A:middle
you can pretty much process all

00:27:28.836 --> 00:27:30.626 A:middle
the scenes, all the objects in

00:27:30.626 --> 00:27:32.286 A:middle
our scene in parallel.

00:27:32.896 --> 00:27:33.766 A:middle
But typically, there are

00:27:33.766 --> 00:27:35.206 A:middle
thousands of objects in a scene

00:27:35.266 --> 00:27:37.096 A:middle
and so to paralyze all of them,

00:27:37.096 --> 00:27:38.776 A:middle
you need thousands of threads.

00:27:39.376 --> 00:27:40.606 A:middle
So, the perfect choice for these

00:27:40.606 --> 00:27:42.416 A:middle
operations is the GPU.

00:27:43.616 --> 00:27:45.536 A:middle
Now, GPU is a massively parallel

00:27:45.596 --> 00:27:46.986 A:middle
processor with thousands of

00:27:46.986 --> 00:27:48.426 A:middle
threads available to schedule

00:27:48.426 --> 00:27:49.196 A:middle
operations on.

00:27:49.766 --> 00:27:50.956 A:middle
So, it is possible to assign an

00:27:50.956 --> 00:27:53.436 A:middle
object to a dedicated thread and

00:27:53.436 --> 00:27:54.726 A:middle
perform all the operations that

00:27:54.726 --> 00:27:55.826 A:middle
we want to perform on that

00:27:55.826 --> 00:27:56.176 A:middle
object.

00:27:56.446 --> 00:27:57.926 A:middle
And with thousands of threads,

00:27:57.926 --> 00:27:59.116 A:middle
you can process thousands of

00:27:59.116 --> 00:27:59.996 A:middle
objects in parallel.

00:28:00.626 --> 00:28:02.146 A:middle
So, your render loop is going to

00:28:02.146 --> 00:28:03.536 A:middle
be more efficient if you move it

00:28:03.536 --> 00:28:06.666 A:middle
from CPU to GPU and as I

00:28:06.666 --> 00:28:08.416 A:middle
mentioned before, it will also

00:28:08.466 --> 00:28:10.416 A:middle
be freeing up your CPU for any

00:28:10.416 --> 00:28:12.266 A:middle
other processing you want to do.

00:28:12.546 --> 00:28:14.066 A:middle
So, how do you move all these

00:28:14.066 --> 00:28:15.256 A:middle
operations to the GPU.

00:28:16.236 --> 00:28:17.526 A:middle
You can do it with a combination

00:28:17.526 --> 00:28:19.446 A:middle
of compute and render passes on

00:28:19.446 --> 00:28:21.726 A:middle
the GPU so that we can drive the

00:28:21.726 --> 00:28:23.406 A:middle
entire render loop on the GPU

00:28:23.406 --> 00:28:25.306 A:middle
without any CPU involvement.

00:28:25.946 --> 00:28:27.006 A:middle
This idea, I mean, this is what

00:28:27.006 --> 00:28:27.556 A:middle
we need.

00:28:27.876 --> 00:28:29.366 A:middle
The entire render loop here is

00:28:29.366 --> 00:28:30.086 A:middle
on the GPU.

00:28:30.086 --> 00:28:31.506 A:middle
It's completely GPU driven.

00:28:32.416 --> 00:28:33.476 A:middle
Now, let's go through these

00:28:33.526 --> 00:28:35.306 A:middle
passes to see how this

00:28:35.346 --> 00:28:37.366 A:middle
GPU-driven render loop really

00:28:38.296 --> 00:28:38.416 A:middle
works.

00:28:38.686 --> 00:28:40.626 A:middle
Now, we need occluder data for

00:28:40.626 --> 00:28:41.286 A:middle
occlusion culling.

00:28:41.566 --> 00:28:43.046 A:middle
So first we have a compute pass

00:28:43.706 --> 00:28:45.506 A:middle
that takes a scene data, does

00:28:45.506 --> 00:28:46.846 A:middle
frustum culling of occluders,

00:28:47.216 --> 00:28:48.776 A:middle
and enclodes commands for

00:28:48.776 --> 00:28:49.676 A:middle
rendering the occluders.

00:28:50.506 --> 00:28:51.946 A:middle
Now, these encoded occluded raw

00:28:51.946 --> 00:28:53.276 A:middle
commands are executed in a

00:28:53.276 --> 00:28:55.476 A:middle
render pass, so we generate any

00:28:55.476 --> 00:28:56.556 A:middle
required occluder data.

00:28:57.246 --> 00:28:58.556 A:middle
Now, this occluder data can be

00:28:58.556 --> 00:29:00.076 A:middle
in various forms, depending on

00:28:58.556 --> 00:29:00.076 A:middle
in various forms, depending on

00:29:00.076 --> 00:29:01.196 A:middle
how it gets generated.

00:29:01.666 --> 00:29:02.626 A:middle
So, you may want to further

00:29:02.626 --> 00:29:03.626 A:middle
process that data.

00:29:04.366 --> 00:29:05.706 A:middle
For that, we can have another

00:29:05.706 --> 00:29:06.436 A:middle
compute pass.

00:29:06.836 --> 00:29:08.726 A:middle
Now in this pass, the occluder

00:29:08.726 --> 00:29:10.206 A:middle
data can be converted into a

00:29:10.206 --> 00:29:11.876 A:middle
form that is more suitable for

00:29:12.176 --> 00:29:12.966 A:middle
occlusion culling.

00:29:13.936 --> 00:29:15.446 A:middle
We need one more compute pass

00:29:15.446 --> 00:29:17.196 A:middle
for the operations we talked

00:29:17.196 --> 00:29:17.636 A:middle
about.

00:29:17.636 --> 00:29:19.016 A:middle
That is, culling, a level of

00:29:19.016 --> 00:29:20.676 A:middle
detail selection and for

00:29:20.676 --> 00:29:22.196 A:middle
encoding of scene raw commands.

00:29:22.516 --> 00:29:24.206 A:middle
So, one thing to find out here

00:29:24.206 --> 00:29:25.916 A:middle
is that occlusion culling here

00:29:25.916 --> 00:29:27.736 A:middle
is no longer dependent on

00:29:27.816 --> 00:29:28.776 A:middle
previous frames' data.

00:29:29.556 --> 00:29:31.156 A:middle
Required occluder data is

00:29:31.156 --> 00:29:32.456 A:middle
generated for the current frame

00:29:32.686 --> 00:29:33.756 A:middle
in the first two passes that we

00:29:33.756 --> 00:29:34.766 A:middle
just talked about.

00:29:35.176 --> 00:29:36.206 A:middle
And also because we are

00:29:36.206 --> 00:29:37.216 A:middle
generating it for the current

00:29:37.216 --> 00:29:39.416 A:middle
frame, it's also more accurate.

00:29:39.926 --> 00:29:42.786 A:middle
And finally, we have another

00:29:42.786 --> 00:29:44.806 A:middle
render pass that executes a

00:29:44.806 --> 00:29:46.346 A:middle
scene raw commands for rendering

00:29:46.346 --> 00:29:46.946 A:middle
the scene.

00:29:47.636 --> 00:29:50.016 A:middle
So, in this GPU-driven render

00:29:50.016 --> 00:29:52.126 A:middle
loop, everything's happening on

00:29:52.126 --> 00:29:52.666 A:middle
the GPU.

00:29:52.836 --> 00:29:54.376 A:middle
There is no CPU-GPU

00:29:54.376 --> 00:29:55.946 A:middle
synchronization anywhere, no

00:29:56.206 --> 00:29:57.476 A:middle
previous frame dependencies.

00:29:58.366 --> 00:29:59.656 A:middle
So, how can we build this

00:29:59.656 --> 00:30:00.546 A:middle
GPU-driven pipeline?

00:29:59.656 --> 00:30:00.546 A:middle
GPU-driven pipeline?

00:30:01.526 --> 00:30:03.146 A:middle
Now, it is clear that we need at

00:30:03.146 --> 00:30:04.436 A:middle
least two things to be able to

00:30:04.436 --> 00:30:05.936 A:middle
build this render loop on the

00:30:05.936 --> 00:30:06.436 A:middle
GPU.

00:30:06.856 --> 00:30:08.726 A:middle
First, draw commands.

00:30:09.196 --> 00:30:11.206 A:middle
We need a way to encode draw

00:30:11.206 --> 00:30:13.546 A:middle
commands on the GPU so that the

00:30:13.546 --> 00:30:14.846 A:middle
compute pass can encode the

00:30:14.846 --> 00:30:15.926 A:middle
commands for the render pass.

00:30:16.676 --> 00:30:17.626 A:middle
And the building block that

00:30:17.626 --> 00:30:19.226 A:middle
Metal provides to support this

00:30:19.226 --> 00:30:20.546 A:middle
is indirect command buffers.

00:30:21.356 --> 00:30:22.976 A:middle
And we also need scene data.

00:30:23.866 --> 00:30:25.106 A:middle
We should be able to access the

00:30:25.106 --> 00:30:26.846 A:middle
encoded scene data on the GPU

00:30:26.846 --> 00:30:28.806 A:middle
through the frame wherever it is

00:30:28.806 --> 00:30:29.096 A:middle
needed.

00:30:29.766 --> 00:30:31.136 A:middle
And with this scene data, we

00:30:31.136 --> 00:30:32.106 A:middle
should be able to pretty much

00:30:32.106 --> 00:30:34.176 A:middle
describe the whole scene, like

00:30:34.176 --> 00:30:35.886 A:middle
geometry, shared arguments,

00:30:36.016 --> 00:30:37.996 A:middle
materials, etc. So, in the

00:30:37.996 --> 00:30:39.336 A:middle
building block that Metal

00:30:39.336 --> 00:30:41.666 A:middle
provides to support this is

00:30:41.666 --> 00:30:42.476 A:middle
argument buffers.

00:30:43.436 --> 00:30:44.706 A:middle
Now, let's take a more closer

00:30:44.706 --> 00:30:46.016 A:middle
look at these two building

00:30:46.016 --> 00:30:46.376 A:middle
blocks.

00:30:47.546 --> 00:30:49.556 A:middle
Now, argument buffers let you

00:30:49.556 --> 00:30:51.986 A:middle
describe the entire scene data

00:30:51.986 --> 00:30:53.516 A:middle
with complex data structures.

00:30:54.036 --> 00:30:55.226 A:middle
And they let you access the

00:30:55.316 --> 00:30:57.666 A:middle
scene data anywhere in the loop.

00:30:58.366 --> 00:30:59.566 A:middle
And indirect command buffers

00:30:59.566 --> 00:31:01.206 A:middle
allow you to build draw calls on

00:30:59.566 --> 00:31:01.206 A:middle
allow you to build draw calls on

00:31:01.206 --> 00:31:02.866 A:middle
the GPU and basically it

00:31:02.866 --> 00:31:03.646 A:middle
supports massive parallel

00:31:03.646 --> 00:31:05.666 A:middle
generation of commands on the

00:31:05.666 --> 00:31:06.126 A:middle
GPU.

00:31:06.826 --> 00:31:07.866 A:middle
Now, let's dive into these

00:31:07.866 --> 00:31:09.656 A:middle
argument buffers a little

00:31:09.656 --> 00:31:11.326 A:middle
further with an example scene

00:31:11.326 --> 00:31:11.956 A:middle
object model.

00:31:12.426 --> 00:31:14.866 A:middle
Now, the first thing that we

00:31:14.866 --> 00:31:16.986 A:middle
need is access to scene data.

00:31:17.766 --> 00:31:19.046 A:middle
So, what does scene data really

00:31:19.046 --> 00:31:19.526 A:middle
consist of?

00:31:20.066 --> 00:31:20.786 A:middle
First, meshes.

00:31:21.336 --> 00:31:22.686 A:middle
Now, here is the meshes.

00:31:23.186 --> 00:31:25.126 A:middle
It is an area of mesh objects,

00:31:25.196 --> 00:31:26.986 A:middle
each describing its geometry.

00:31:27.426 --> 00:31:30.136 A:middle
And Metal is an area of Metal

00:31:30.136 --> 00:31:32.196 A:middle
objects each with a set of Metal

00:31:32.196 --> 00:31:34.756 A:middle
properties, any textures it

00:31:34.756 --> 00:31:36.106 A:middle
needs, and the pipeline steered

00:31:36.106 --> 00:31:37.586 A:middle
object that describes the shadow

00:31:37.586 --> 00:31:38.056 A:middle
pipeline.

00:31:38.736 --> 00:31:40.186 A:middle
And scene also consists of an

00:31:40.186 --> 00:31:41.146 A:middle
area of models.

00:31:41.946 --> 00:31:44.686 A:middle
Here, each model can have an LOD

00:31:44.686 --> 00:31:47.256 A:middle
so in this example, we have each

00:31:47.256 --> 00:31:48.796 A:middle
model consisting of area of

00:31:49.426 --> 00:31:52.066 A:middle
meshes and materials, one per

00:31:52.066 --> 00:31:52.176 A:middle
LOD.

00:31:52.176 --> 00:31:55.256 A:middle
Finally, we have a scene object

00:31:55.256 --> 00:31:57.426 A:middle
that relates meshes, materials,

00:31:57.426 --> 00:31:59.106 A:middle
and models that are part of our

00:31:59.106 --> 00:31:59.596 A:middle
scene.

00:32:00.366 --> 00:32:02.396 A:middle
So, let's see how this object

00:32:02.396 --> 00:32:03.886 A:middle
model can be expressed with

00:32:04.046 --> 00:32:04.936 A:middle
argument buffers.

00:32:05.476 --> 00:32:08.436 A:middle
It is a very simple 1-to-1

00:32:08.436 --> 00:32:10.946 A:middle
mapping from our object model to

00:32:10.946 --> 00:32:11.666 A:middle
argument buffers.

00:32:11.776 --> 00:32:13.756 A:middle
For example, scene argument

00:32:13.756 --> 00:32:15.446 A:middle
buffer here simply consists of

00:32:15.446 --> 00:32:16.666 A:middle
the objects that we just

00:32:16.666 --> 00:32:18.366 A:middle
described in our object model.

00:32:19.026 --> 00:32:20.856 A:middle
That is areas of meshes,

00:32:20.956 --> 00:32:22.296 A:middle
materials, and models.

00:32:22.836 --> 00:32:24.436 A:middle
Basically, the entire scene can

00:32:24.436 --> 00:32:26.286 A:middle
now be described with argument

00:32:26.286 --> 00:32:26.736 A:middle
buffers.

00:32:27.726 --> 00:32:29.116 A:middle
Now, let's look at how this can

00:32:29.116 --> 00:32:31.216 A:middle
be constructed and accessed in

00:32:31.776 --> 00:32:33.916 A:middle
the shader.

00:32:34.126 --> 00:32:35.586 A:middle
Now, each of the argument

00:32:35.586 --> 00:32:37.046 A:middle
buffers we just discussed is

00:32:37.046 --> 00:32:38.576 A:middle
simply represented by a

00:32:38.576 --> 00:32:38.946 A:middle
structure.

00:32:39.636 --> 00:32:41.196 A:middle
That now contains members that

00:32:41.196 --> 00:32:42.526 A:middle
we have described in our object

00:32:42.526 --> 00:32:42.896 A:middle
model.

00:32:43.566 --> 00:32:45.696 A:middle
Since each argument buffer is a

00:32:45.696 --> 00:32:47.396 A:middle
structure that is completely

00:32:47.396 --> 00:32:49.376 A:middle
flexible, you can add things

00:32:49.376 --> 00:32:51.006 A:middle
like arrays, pointers, even

00:32:51.046 --> 00:32:52.166 A:middle
pointers to other argument

00:32:52.166 --> 00:32:52.616 A:middle
buffers.

00:32:52.816 --> 00:32:55.386 A:middle
For example, here's a Metal

00:32:55.386 --> 00:32:56.436 A:middle
argument buffer.

00:32:56.996 --> 00:32:58.456 A:middle
It can contain Metal Constants

00:32:58.586 --> 00:33:00.496 A:middle
any textures it needs, and of

00:32:58.586 --> 00:33:00.496 A:middle
any textures it needs, and of

00:33:00.526 --> 00:33:01.616 A:middle
course the pipeline straight

00:33:01.616 --> 00:33:03.406 A:middle
objects that describe the shadow

00:33:03.406 --> 00:33:03.856 A:middle
pipeline.

00:33:04.496 --> 00:33:05.806 A:middle
So everything that is needed for

00:33:05.806 --> 00:33:07.856 A:middle
a Metal is in one argument

00:33:07.896 --> 00:33:08.036 A:middle
buffer.

00:33:09.016 --> 00:33:10.626 A:middle
And the scene argument buffer is

00:33:10.626 --> 00:33:12.186 A:middle
just like how we described it in

00:33:12.186 --> 00:33:13.366 A:middle
our object model.

00:33:13.976 --> 00:33:15.166 A:middle
So, it's just very easy to

00:33:15.166 --> 00:33:17.136 A:middle
construct object models with

00:33:17.136 --> 00:33:17.976 A:middle
argument buffers.

00:33:18.866 --> 00:33:19.956 A:middle
Now, let's look at how we can

00:33:19.956 --> 00:33:21.846 A:middle
access these argument buffers in

00:33:21.846 --> 00:33:22.686 A:middle
the sharable.

00:33:23.266 --> 00:33:25.986 A:middle
Now, this is a compute kernel

00:33:25.986 --> 00:33:27.306 A:middle
that does frustum culling that

00:33:27.306 --> 00:33:28.216 A:middle
we just talked about.

00:33:28.646 --> 00:33:30.436 A:middle
It encodes the draw commands for

00:33:30.436 --> 00:33:31.916 A:middle
visible objects into an indirect

00:33:31.916 --> 00:33:32.356 A:middle
command offer.

00:33:33.286 --> 00:33:34.746 A:middle
Each thread that executes an

00:33:34.746 --> 00:33:36.026 A:middle
instance of this kernel

00:33:36.486 --> 00:33:38.436 A:middle
processes one object and encodes

00:33:38.436 --> 00:33:40.426 A:middle
a single draw call if it data

00:33:40.426 --> 00:33:41.946 A:middle
mines that object is visible.

00:33:42.516 --> 00:33:45.036 A:middle
So, let's see how this does it.

00:33:45.436 --> 00:33:47.376 A:middle
Now, first we pass in our

00:33:47.376 --> 00:33:49.246 A:middle
high-level scene argument buffer

00:33:49.336 --> 00:33:49.796 A:middle
to the share.

00:33:50.526 --> 00:33:51.896 A:middle
Now, once we have access to our

00:33:51.896 --> 00:33:54.326 A:middle
shader, our scene, then it is

00:33:54.326 --> 00:33:56.106 A:middle
very easy to access anything

00:33:56.106 --> 00:33:56.746 A:middle
else we need.

00:33:57.426 --> 00:33:59.546 A:middle
And command R here contains the

00:33:59.546 --> 00:34:00.786 A:middle
reference to the indirect

00:33:59.546 --> 00:34:00.786 A:middle
reference to the indirect

00:34:00.786 --> 00:34:02.086 A:middle
command buffer that we want to

00:34:02.126 --> 00:34:02.706 A:middle
encode into.

00:34:02.706 --> 00:34:06.346 A:middle
We first did the model from the

00:34:06.346 --> 00:34:08.266 A:middle
scene based on thread ID.

00:34:08.716 --> 00:34:10.726 A:middle
Notice that all threads of this

00:34:10.726 --> 00:34:12.255 A:middle
compute kernel are doing this in

00:34:12.255 --> 00:34:13.946 A:middle
parallel, each operating on a

00:34:13.946 --> 00:34:14.755 A:middle
particular object.

00:34:14.755 --> 00:34:17.516 A:middle
We do frustum culling to see if

00:34:17.516 --> 00:34:18.946 A:middle
the object is falling outside

00:34:18.946 --> 00:34:19.735 A:middle
the view frustum.

00:34:20.436 --> 00:34:21.666 A:middle
And once we determine that

00:34:21.666 --> 00:34:23.626 A:middle
object is visible, we calculate

00:34:23.626 --> 00:34:26.056 A:middle
its LOD based on its distance to

00:34:26.056 --> 00:34:26.456 A:middle
the camera.

00:34:27.476 --> 00:34:28.966 A:middle
So once we have the LOD, it's

00:34:28.966 --> 00:34:31.016 A:middle
very straightforward to read its

00:34:31.016 --> 00:34:32.766 A:middle
corresponding mesh and material

00:34:32.766 --> 00:34:34.626 A:middle
argument, argument buffers that

00:34:34.626 --> 00:34:35.886 A:middle
apply to that LOD.

00:34:36.616 --> 00:34:38.106 A:middle
This is straightforward mainly

00:34:38.106 --> 00:34:39.436 A:middle
because of the way argument

00:34:39.466 --> 00:34:41.056 A:middle
buffers lets us relate resources

00:34:41.326 --> 00:34:42.505 A:middle
that we need in our scene.

00:34:43.065 --> 00:34:44.606 A:middle
And we have acquired all the

00:34:44.606 --> 00:34:45.956 A:middle
information we need; now it's

00:34:45.956 --> 00:34:46.976 A:middle
time to encode.

00:34:47.735 --> 00:34:49.536 A:middle
Let's just see what encoding

00:34:49.536 --> 00:34:51.376 A:middle
into an indirect argument

00:34:51.376 --> 00:34:53.505 A:middle
buffer, indirect command buffer

00:34:53.505 --> 00:34:54.056 A:middle
really means.

00:34:56.815 --> 00:34:59.446 A:middle
So, indirect command buffer is

00:34:59.446 --> 00:35:00.746 A:middle
an area of render commands.

00:34:59.446 --> 00:35:00.746 A:middle
an area of render commands.

00:35:01.116 --> 00:35:02.416 A:middle
Each command can have different

00:35:02.416 --> 00:35:02.886 A:middle
properties.

00:35:03.706 --> 00:35:05.726 A:middle
A command can include a pipeline

00:35:05.726 --> 00:35:07.426 A:middle
straight object that describes a

00:35:07.426 --> 00:35:09.426 A:middle
shared pipeline and any vortex

00:35:09.426 --> 00:35:10.736 A:middle
and fragment buffers that the

00:35:10.736 --> 00:35:11.456 A:middle
draw call needs.

00:35:12.066 --> 00:35:13.076 A:middle
And the draw call itself.

00:35:13.536 --> 00:35:15.336 A:middle
So, encoding basically means

00:35:15.416 --> 00:35:16.756 A:middle
that once we determine that an

00:35:16.756 --> 00:35:18.996 A:middle
object is visible, we read it

00:35:18.996 --> 00:35:20.776 A:middle
with all its properties and

00:35:20.776 --> 00:35:23.026 A:middle
encode those into the indirect

00:35:23.026 --> 00:35:23.406 A:middle
mine buffer.

00:35:23.876 --> 00:35:25.686 A:middle
Now, each thread that processes

00:35:25.686 --> 00:35:27.876 A:middle
an object can encode into a

00:35:27.876 --> 00:35:29.446 A:middle
particular slot in this indirect

00:35:29.446 --> 00:35:29.996 A:middle
command buffer.

00:35:30.576 --> 00:35:31.866 A:middle
And since all threads are

00:35:31.866 --> 00:35:33.856 A:middle
running in parallel, commands

00:35:33.856 --> 00:35:35.346 A:middle
can be encoded concurrently.

00:35:36.386 --> 00:35:38.016 A:middle
Now, let's continue with our

00:35:38.016 --> 00:35:39.796 A:middle
culling kernel example to see an

00:35:39.796 --> 00:35:42.676 A:middle
actual example of the encoding.

00:35:43.056 --> 00:35:46.796 A:middle
Now, we first need a position in

00:35:46.796 --> 00:35:48.366 A:middle
the command buffer to encode the

00:35:48.366 --> 00:35:48.836 A:middle
raw command.

00:35:49.526 --> 00:35:51.456 A:middle
So, we use that raw ID to get

00:35:51.456 --> 00:35:53.466 A:middle
ourselves a slot in the indirect

00:35:53.466 --> 00:35:53.946 A:middle
command buffer.

00:35:54.806 --> 00:35:56.216 A:middle
And like we discussed, we need

00:35:56.216 --> 00:35:57.936 A:middle
to set any parameters that the

00:35:57.936 --> 00:35:58.676 A:middle
draw call needs.

00:35:59.376 --> 00:36:00.696 A:middle
Now, the material and mesh

00:35:59.376 --> 00:36:00.696 A:middle
Now, the material and mesh

00:36:00.696 --> 00:36:01.906 A:middle
argument buffers that we just

00:36:01.906 --> 00:36:03.196 A:middle
acquired have all the

00:36:03.196 --> 00:36:04.606 A:middle
information we need to set the

00:36:04.606 --> 00:36:05.026 A:middle
parameters.

00:36:05.696 --> 00:36:07.186 A:middle
So for example for material we

00:36:07.186 --> 00:36:08.296 A:middle
can set the pipeline straight

00:36:08.296 --> 00:36:10.136 A:middle
object that we need to set.

00:36:10.816 --> 00:36:12.626 A:middle
And from the mesh object, we can

00:36:12.626 --> 00:36:14.536 A:middle
set any vortex buffer or any

00:36:14.536 --> 00:36:15.836 A:middle
vortex uniforms that we need to

00:36:15.836 --> 00:36:16.196 A:middle
set.

00:36:16.936 --> 00:36:18.456 A:middle
And of course the fragment needs

00:36:18.516 --> 00:36:19.986 A:middle
the material, so we set that.

00:36:20.566 --> 00:36:22.006 A:middle
And finally this is how we

00:36:22.006 --> 00:36:22.916 A:middle
encode the draw.

00:36:23.396 --> 00:36:24.136 A:middle
So that's it.

00:36:24.196 --> 00:36:26.026 A:middle
Encoding the draw call is very

00:36:26.106 --> 00:36:27.716 A:middle
simple and easy.

00:36:28.306 --> 00:36:31.096 A:middle
Now, let's see how you can set

00:36:31.096 --> 00:36:32.966 A:middle
up your path in your game.

00:36:33.996 --> 00:36:36.026 A:middle
Now, we first need an indirect

00:36:36.026 --> 00:36:37.546 A:middle
command buffer to encode

00:36:37.546 --> 00:36:38.886 A:middle
occluder draw commands, because

00:36:38.886 --> 00:36:39.926 A:middle
that is the first thing that we

00:36:39.926 --> 00:36:42.626 A:middle
talked about when we discussed

00:36:42.626 --> 00:36:43.956 A:middle
our GPU-driven render loop.

00:36:44.576 --> 00:36:46.586 A:middle
So to render the occluders, we

00:36:46.586 --> 00:36:49.336 A:middle
start up a compute dispatch that

00:36:49.336 --> 00:36:50.886 A:middle
does custom culling of occulders

00:36:51.336 --> 00:36:52.676 A:middle
and encodes the occluder draw

00:36:52.676 --> 00:36:53.146 A:middle
commands.

00:36:53.976 --> 00:36:55.796 A:middle
And because each thread is doing

00:36:55.796 --> 00:36:59.096 A:middle
independently encoding a draw,

00:36:59.406 --> 00:37:01.446 A:middle
there can be multiple state

00:36:59.406 --> 00:37:01.446 A:middle
there can be multiple state

00:37:01.446 --> 00:37:02.736 A:middle
settings, written and state

00:37:02.736 --> 00:37:04.366 A:middle
settings in the indirect command

00:37:04.366 --> 00:37:04.606 A:middle
buffer.

00:37:05.376 --> 00:37:08.596 A:middle
So, optionally we optimize the

00:37:08.596 --> 00:37:10.136 A:middle
indirect command buffer to

00:37:10.136 --> 00:37:11.366 A:middle
remove any driven end stage

00:37:11.366 --> 00:37:11.686 A:middle
settings.

00:37:12.136 --> 00:37:14.386 A:middle
Now, this is a random pass that

00:37:14.386 --> 00:37:15.946 A:middle
executes the occluder draws in

00:37:15.946 --> 00:37:16.866 A:middle
the indirect command buffer.

00:37:17.916 --> 00:37:19.256 A:middle
And similarly, the rest of the

00:37:19.256 --> 00:37:20.766 A:middle
paths can be set up easily.

00:37:21.056 --> 00:37:25.576 A:middle
For example, here is our, the

00:37:25.686 --> 00:37:27.276 A:middle
main compute dispatch that

00:37:27.276 --> 00:37:30.756 A:middle
launches our culling kernel that

00:37:30.756 --> 00:37:32.326 A:middle
we just talked about that does

00:37:32.326 --> 00:37:34.206 A:middle
culling tests, LOD selection,

00:37:34.206 --> 00:37:35.366 A:middle
and encoding draw commands.

00:37:35.566 --> 00:37:37.096 A:middle
Now we are ready to launch our

00:37:37.096 --> 00:37:39.146 A:middle
final render pass that executes

00:37:39.146 --> 00:37:40.076 A:middle
the commands in the indirect

00:37:40.076 --> 00:37:40.506 A:middle
command buffer.

00:37:41.086 --> 00:37:41.546 A:middle
So that's it.

00:37:41.546 --> 00:37:43.076 A:middle
That's all it takes to draw the

00:37:43.076 --> 00:37:43.506 A:middle
scene.

00:37:44.236 --> 00:37:46.606 A:middle
Now, let's take a look and see

00:37:46.606 --> 00:37:47.866 A:middle
how the indirect command buffer

00:37:47.866 --> 00:37:49.156 A:middle
looks like after the encoding of

00:37:49.156 --> 00:37:49.966 A:middle
draw commands.

00:37:52.876 --> 00:37:54.486 A:middle
Now, it can be sparse with

00:37:54.486 --> 00:37:55.006 A:middle
holes.

00:37:55.366 --> 00:37:57.256 A:middle
This is mainly because as we

00:37:57.256 --> 00:37:58.476 A:middle
have just seen in our culling

00:37:58.476 --> 00:38:00.796 A:middle
kernel example, the thread that

00:37:58.476 --> 00:38:00.796 A:middle
kernel example, the thread that

00:38:00.796 --> 00:38:02.376 A:middle
is processing an object doesn't

00:38:02.376 --> 00:38:04.306 A:middle
encode the draw command if it

00:38:04.306 --> 00:38:05.526 A:middle
finds that object is not

00:38:05.526 --> 00:38:05.996 A:middle
visible.

00:38:06.716 --> 00:38:08.336 A:middle
For example, objects one and

00:38:08.336 --> 00:38:09.566 A:middle
three, in this case.

00:38:09.956 --> 00:38:11.686 A:middle
That means those slots in the

00:38:11.686 --> 00:38:12.626 A:middle
indirect command buffer are

00:38:13.006 --> 00:38:13.426 A:middle
empty.

00:38:14.036 --> 00:38:15.316 A:middle
So if you submit this command

00:38:15.316 --> 00:38:17.256 A:middle
buffer to the GPU, it'll end up

00:38:17.256 --> 00:38:18.656 A:middle
executing a bunch of empty

00:38:18.656 --> 00:38:20.656 A:middle
commands, which is not really

00:38:20.656 --> 00:38:21.046 A:middle
efficient.

00:38:21.736 --> 00:38:23.626 A:middle
So, the ideal thing to do is to

00:38:23.626 --> 00:38:25.496 A:middle
tightly pack the commands like

00:38:25.496 --> 00:38:25.816 A:middle
this.

00:38:26.486 --> 00:38:28.786 A:middle
That is, we need a way to pack

00:38:28.786 --> 00:38:30.526 A:middle
the commands as we encode the

00:38:30.526 --> 00:38:31.746 A:middle
draws.

00:38:31.746 --> 00:38:33.716 A:middle
For that, we have indirect

00:38:33.716 --> 00:38:34.216 A:middle
principle.

00:38:35.346 --> 00:38:37.676 A:middle
With indirect ranges, you can

00:38:37.676 --> 00:38:39.836 A:middle
tell the GPU with execute call

00:38:40.226 --> 00:38:41.216 A:middle
where to get the range of

00:38:41.216 --> 00:38:42.006 A:middle
commands to execute.

00:38:42.846 --> 00:38:44.696 A:middle
Basically, you can have indirect

00:38:44.696 --> 00:38:46.116 A:middle
range buffer that has a start

00:38:46.116 --> 00:38:48.086 A:middle
location and number of commands

00:38:48.086 --> 00:38:50.046 A:middle
to execute, and this buffer can

00:38:50.046 --> 00:38:51.846 A:middle
be populated on the GPU as

00:38:51.846 --> 00:38:53.446 A:middle
you're doing your encoding of

00:38:53.446 --> 00:38:54.106 A:middle
draw commands.

00:38:54.216 --> 00:38:56.096 A:middle
And the execute call will pick

00:38:56.096 --> 00:38:57.846 A:middle
up the start location and the

00:38:57.846 --> 00:38:59.466 A:middle
number of commands from this

00:38:59.466 --> 00:38:59.776 A:middle
buffer.

00:39:00.896 --> 00:39:02.256 A:middle
It can be used for both packing

00:39:02.256 --> 00:39:02.856 A:middle
and the range.

00:39:03.626 --> 00:39:04.926 A:middle
Now, let's go to an example and

00:39:04.926 --> 00:39:06.866 A:middle
see how this really works.

00:39:07.916 --> 00:39:10.106 A:middle
This is our culling kernel that

00:39:10.456 --> 00:39:12.156 A:middle
we just discussed before,

00:39:12.406 --> 00:39:14.316 A:middle
modified to use indirect range

00:39:14.466 --> 00:39:15.116 A:middle
buffer.

00:39:15.636 --> 00:39:16.916 A:middle
Let's see how this kernel packs

00:39:16.916 --> 00:39:17.706 A:middle
the draw commands.

00:39:18.146 --> 00:39:21.966 A:middle
We first pass in our pointer to

00:39:21.966 --> 00:39:22.976 A:middle
the length member of the

00:39:22.976 --> 00:39:23.786 A:middle
indirect range buffer.

00:39:24.346 --> 00:39:25.856 A:middle
And when we are retrieving the

00:39:26.176 --> 00:39:27.906 A:middle
command to encode, we can

00:39:27.906 --> 00:39:29.156 A:middle
automatically increment the

00:39:29.156 --> 00:39:29.396 A:middle
length.

00:39:30.096 --> 00:39:31.786 A:middle
Now, each thread is atomically

00:39:31.786 --> 00:39:33.396 A:middle
incrementing the length, and so

00:39:33.396 --> 00:39:34.876 A:middle
when this compute work is done,

00:39:35.306 --> 00:39:36.706 A:middle
the length is automatically set

00:39:36.706 --> 00:39:38.036 A:middle
up in the indirect range buffer.

00:39:38.906 --> 00:39:40.126 A:middle
At the same time, the draw

00:39:40.126 --> 00:39:41.176 A:middle
commands have been packed.

00:39:41.736 --> 00:39:43.386 A:middle
Because the indirect that is

00:39:43.386 --> 00:39:44.776 A:middle
returned by this atomic

00:39:44.776 --> 00:39:46.566 A:middle
instruction in this code is the

00:39:46.566 --> 00:39:47.716 A:middle
previous value of the length.

00:39:48.276 --> 00:39:50.466 A:middle
And so for example, if you start

00:39:50.466 --> 00:39:52.006 A:middle
at zero, the thread that is

00:39:52.006 --> 00:39:53.396 A:middle
using the zero slot is

00:39:53.396 --> 00:39:54.676 A:middle
incrementing the length to 1.

00:39:55.216 --> 00:39:56.336 A:middle
And the thread that is using the

00:39:56.396 --> 00:39:57.726 A:middle
first slot is incrementing the

00:39:57.726 --> 00:39:59.126 A:middle
length to 2 and so on.

00:39:59.776 --> 00:40:01.106 A:middle
So, this is great because now we

00:39:59.776 --> 00:40:01.106 A:middle
So, this is great because now we

00:40:01.106 --> 00:40:02.746 A:middle
not only pack the commands; we

00:40:02.746 --> 00:40:04.096 A:middle
also updated the range at the

00:40:04.096 --> 00:40:04.596 A:middle
same time.

00:40:05.596 --> 00:40:08.116 A:middle
Now, let's see how we can set up

00:40:08.116 --> 00:40:09.736 A:middle
the indirect range buffer in the

00:40:09.736 --> 00:40:10.146 A:middle
application.

00:40:11.596 --> 00:40:13.766 A:middle
First, you create a range buffer

00:40:13.766 --> 00:40:16.746 A:middle
for the compute pass to update

00:40:16.746 --> 00:40:17.196 A:middle
the range.

00:40:17.996 --> 00:40:19.686 A:middle
Next, you set up the range

00:40:19.686 --> 00:40:21.576 A:middle
buffer as a kernel argument for

00:40:21.576 --> 00:40:22.986 A:middle
the culling compute kernel.

00:40:24.066 --> 00:40:26.056 A:middle
And then we do the compute pass

00:40:26.096 --> 00:40:28.356 A:middle
that launches the culling kernel

00:40:28.636 --> 00:40:30.236 A:middle
that does the object first thing

00:40:30.346 --> 00:40:32.526 A:middle
and also updates the range

00:40:32.856 --> 00:40:33.556 A:middle
automatically.

00:40:34.236 --> 00:40:35.596 A:middle
And finally, you schedule the

00:40:35.596 --> 00:40:37.376 A:middle
pass with execute commands in

00:40:37.376 --> 00:40:39.476 A:middle
buffer with indirect range API.

00:40:39.946 --> 00:40:42.176 A:middle
Now, this call will pick up the

00:40:42.176 --> 00:40:43.546 A:middle
start location and the number of

00:40:43.546 --> 00:40:45.086 A:middle
commands that is executed from

00:40:45.086 --> 00:40:46.156 A:middle
this indirect range buffer.

00:40:46.806 --> 00:40:48.356 A:middle
So, with indirect ranges, you

00:40:48.356 --> 00:40:50.476 A:middle
can get more efficient execution

00:40:50.476 --> 00:40:51.786 A:middle
of indirect command buffers.

00:40:53.526 --> 00:40:55.876 A:middle
Now, so far in our GPU-driven

00:40:55.876 --> 00:40:57.706 A:middle
pipeline, all these draw

00:40:57.706 --> 00:40:58.966 A:middle
commands are built in compute

00:40:58.966 --> 00:41:00.176 A:middle
passes on the GPU.

00:40:58.966 --> 00:41:00.176 A:middle
passes on the GPU.

00:41:00.796 --> 00:41:02.266 A:middle
And these compute passes where

00:41:02.386 --> 00:41:04.016 A:middle
regular dispatch is happening in

00:41:04.016 --> 00:41:04.596 A:middle
your game.

00:41:05.126 --> 00:41:06.306 A:middle
So, one question that comes to

00:41:06.306 --> 00:41:07.706 A:middle
mind is building compute

00:41:07.706 --> 00:41:08.826 A:middle
dispatches on the GPU.

00:41:08.996 --> 00:41:11.476 A:middle
Can we encode compute dispatches

00:41:11.476 --> 00:41:12.406 A:middle
into indirect command buffer?

00:41:12.936 --> 00:41:14.306 A:middle
So, I'm very happy to let you

00:41:14.306 --> 00:41:16.446 A:middle
all know that a new addition we

00:41:16.446 --> 00:41:18.286 A:middle
are now putting into Metal 3 is

00:41:18.286 --> 00:41:19.996 A:middle
support for encoding compute

00:41:19.996 --> 00:41:20.656 A:middle
dispatches.

00:41:21.626 --> 00:41:22.836 A:middle
Now, you can build your compute

00:41:22.836 --> 00:41:24.216 A:middle
dispatches on the GPU too.

00:41:24.656 --> 00:41:25.766 A:middle
In terms of functionality,

00:41:25.796 --> 00:41:27.206 A:middle
compute indirect command buffers

00:41:27.746 --> 00:41:28.566 A:middle
are just like render.

00:41:28.796 --> 00:41:30.506 A:middle
They can also be built once and

00:41:30.506 --> 00:41:32.316 A:middle
can be reused again and again.

00:41:32.846 --> 00:41:34.746 A:middle
So, they also help in saving CPU

00:41:34.746 --> 00:41:35.296 A:middle
cycles.

00:41:35.296 --> 00:41:37.336 A:middle
And the great thing is both

00:41:37.636 --> 00:41:39.336 A:middle
render and compute can now be

00:41:39.336 --> 00:41:41.106 A:middle
driven on the GPU.

00:41:41.626 --> 00:41:43.426 A:middle
It's really great because now

00:41:43.426 --> 00:41:44.976 A:middle
you can build more flexible

00:41:44.976 --> 00:41:45.886 A:middle
GPU-driven pipelines.

00:41:46.746 --> 00:41:48.136 A:middle
Now, let's see an example with

00:41:48.226 --> 00:41:50.116 A:middle
this with the use case.

00:41:50.696 --> 00:41:53.666 A:middle
Per patch tessellation factors.

00:41:54.176 --> 00:41:55.736 A:middle
So, let's say we have a mesh

00:41:55.736 --> 00:41:57.276 A:middle
that is made up of a bunch of

00:41:57.276 --> 00:41:59.426 A:middle
patches and we want to generate

00:41:59.426 --> 00:42:00.586 A:middle
tessellation patches for each

00:41:59.426 --> 00:42:00.586 A:middle
tessellation patches for each

00:42:00.586 --> 00:42:01.016 A:middle
patch.

00:42:01.786 --> 00:42:03.176 A:middle
We can definitely do this in the

00:42:03.276 --> 00:42:04.796 A:middle
culling compute kernel that we

00:42:04.796 --> 00:42:06.296 A:middle
talked about that does culling

00:42:06.296 --> 00:42:08.096 A:middle
tasks and encodes draw commands.

00:42:08.606 --> 00:42:10.136 A:middle
That is a GPU thread that is

00:42:10.136 --> 00:42:11.726 A:middle
processing an object can go

00:42:11.726 --> 00:42:13.386 A:middle
through each patch of the object

00:42:14.006 --> 00:42:15.046 A:middle
and can generate tessellation

00:42:15.046 --> 00:42:15.516 A:middle
factors.

00:42:16.166 --> 00:42:17.186 A:middle
But that's not really an

00:42:17.186 --> 00:42:18.516 A:middle
efficient thing to do because

00:42:18.816 --> 00:42:20.426 A:middle
generating tessellation factors

00:42:20.476 --> 00:42:22.476 A:middle
is also a paralyzable operation

00:42:22.476 --> 00:42:22.996 A:middle
by itself.

00:42:23.786 --> 00:42:25.556 A:middle
So, the efficient thing would be

00:42:25.556 --> 00:42:27.226 A:middle
to distribute this per operation

00:42:27.226 --> 00:42:29.306 A:middle
across multiple threads so that

00:42:29.306 --> 00:42:30.666 A:middle
all patches are processed in

00:42:30.666 --> 00:42:31.036 A:middle
parallel.

00:42:31.866 --> 00:42:33.346 A:middle
That is, each thread of the

00:42:33.386 --> 00:42:35.186 A:middle
culling compute dispatch that is

00:42:35.186 --> 00:42:37.226 A:middle
processing an object can encode

00:42:37.226 --> 00:42:38.626 A:middle
compute dispatches for test

00:42:38.626 --> 00:42:39.526 A:middle
factor generation.

00:42:40.026 --> 00:42:41.646 A:middle
And those dispatches can be

00:42:41.896 --> 00:42:42.986 A:middle
executed on another compute

00:42:42.986 --> 00:42:44.956 A:middle
pass, paralyzing the operation.

00:42:45.646 --> 00:42:47.346 A:middle
So, with GPU-driven dispatches,

00:42:47.406 --> 00:42:48.336 A:middle
we can now do this.

00:42:48.876 --> 00:42:50.036 A:middle
So, let's see how we can

00:42:50.036 --> 00:42:51.866 A:middle
exchange our GPU-driven pipeline

00:42:51.866 --> 00:42:52.976 A:middle
to accommodate this processing.

00:42:56.416 --> 00:42:58.236 A:middle
Here is the main compute pass

00:42:58.236 --> 00:42:59.826 A:middle
that we talked about before that

00:42:59.826 --> 00:43:01.626 A:middle
does the culling tasks, LOD

00:42:59.826 --> 00:43:01.626 A:middle
does the culling tasks, LOD

00:43:01.626 --> 00:43:03.346 A:middle
selection and encoding of draw

00:43:03.346 --> 00:43:03.796 A:middle
commands.

00:43:04.416 --> 00:43:06.346 A:middle
We can now action this pass to

00:43:06.346 --> 00:43:08.496 A:middle
also encode dispatches for test

00:43:08.496 --> 00:43:09.256 A:middle
factor generation.

00:43:09.786 --> 00:43:12.146 A:middle
For example, after a thread

00:43:12.146 --> 00:43:14.176 A:middle
determines an object is visible,

00:43:14.366 --> 00:43:16.066 A:middle
it can encode dispatches for

00:43:16.066 --> 00:43:17.476 A:middle
test factor generation into an

00:43:17.476 --> 00:43:18.396 A:middle
indirect command buffer.

00:43:19.076 --> 00:43:21.426 A:middle
And then those commands can be

00:43:21.426 --> 00:43:23.106 A:middle
executed in another compute pass

00:43:23.336 --> 00:43:24.866 A:middle
before the main render pass.

00:43:25.756 --> 00:43:27.796 A:middle
So, the GPU-driven dispatches

00:43:27.906 --> 00:43:29.716 A:middle
combined with GPU-driven draws

00:43:30.286 --> 00:43:31.856 A:middle
lets us build more flexible

00:43:31.856 --> 00:43:32.866 A:middle
GPU-driven pipelines.

00:43:34.416 --> 00:43:36.296 A:middle
So, we built a sample to show

00:43:36.296 --> 00:43:37.446 A:middle
you what we talked about in

00:43:37.446 --> 00:43:37.976 A:middle
action.

00:43:38.326 --> 00:43:38.976 A:middle
Let's take a look.

00:43:41.706 --> 00:43:43.706 A:middle
Now, here is a bistro scene that

00:43:43.706 --> 00:43:44.436 A:middle
you saw before.

00:43:44.436 --> 00:43:47.566 A:middle
This, we are actually doing a

00:43:47.566 --> 00:43:48.826 A:middle
fly by through the street here.

00:43:49.326 --> 00:43:51.116 A:middle
This scene is made up of about

00:43:51.436 --> 00:43:53.666 A:middle
2.8 million polygons and close

00:43:53.666 --> 00:43:55.036 A:middle
to 8000 draw calls.

00:43:55.866 --> 00:43:57.886 A:middle
And that's for one view.

00:43:58.026 --> 00:43:59.206 A:middle
And if you consider the shadow

00:43:59.206 --> 00:44:00.526 A:middle
cascades that have been used

00:43:59.206 --> 00:44:00.526 A:middle
cascades that have been used

00:44:00.526 --> 00:44:03.156 A:middle
here for shadow processing, this

00:44:03.156 --> 00:44:04.546 A:middle
render is handling about four

00:44:04.546 --> 00:44:05.176 A:middle
such views.

00:44:05.686 --> 00:44:07.046 A:middle
So, that is quite a few API

00:44:07.046 --> 00:44:08.556 A:middle
calls if this scene gets

00:44:08.556 --> 00:44:10.376 A:middle
rendered on the CPU.

00:44:10.856 --> 00:44:12.616 A:middle
But in this sample, we are using

00:44:12.616 --> 00:44:14.936 A:middle
indirect command buffers and so

00:44:14.936 --> 00:44:16.466 A:middle
everything is on the GPU.

00:44:16.466 --> 00:44:17.826 A:middle
It's completely GPU driven.

00:44:18.246 --> 00:44:19.526 A:middle
The entire render loop is on the

00:44:19.526 --> 00:44:22.406 A:middle
GPU, and so it's saving the CPU

00:44:22.406 --> 00:44:24.906 A:middle
from a lot of work.

00:44:25.166 --> 00:44:27.936 A:middle
Let's look at one more view.

00:44:28.466 --> 00:44:29.716 A:middle
Now, we are looking at the same

00:44:29.716 --> 00:44:31.896 A:middle
view, same fly by, but we are

00:44:31.896 --> 00:44:33.086 A:middle
looking at the camera as it's

00:44:33.086 --> 00:44:34.186 A:middle
passing through the street here.

00:44:34.686 --> 00:44:36.466 A:middle
To be clear, we also are showing

00:44:36.466 --> 00:44:38.306 A:middle
the camera that white object,

00:44:38.306 --> 00:44:39.126 A:middle
that is the camera.

00:44:39.256 --> 00:44:42.746 A:middle
We are showing the geometry that

00:44:42.746 --> 00:44:45.146 A:middle
is tinted with magenta color is,

00:44:45.836 --> 00:44:48.386 A:middle
falling, geometry that is also

00:44:48.386 --> 00:44:49.546 A:middle
the view for some of the camera.

00:44:50.456 --> 00:44:51.756 A:middle
So, as you can see, as the

00:44:51.756 --> 00:44:52.856 A:middle
camera is passing through the

00:44:52.856 --> 00:44:53.886 A:middle
street, there's quite a bit of

00:44:53.886 --> 00:44:55.756 A:middle
geometry that is also the view

00:44:55.756 --> 00:44:56.996 A:middle
frustum of the camera.

00:44:57.596 --> 00:44:59.216 A:middle
And our culling compute dispatch

00:44:59.216 --> 00:45:01.036 A:middle
that does frustum culling on the

00:44:59.216 --> 00:45:01.036 A:middle
that does frustum culling on the

00:45:01.036 --> 00:45:03.946 A:middle
GPU determined this geometry,

00:45:03.946 --> 00:45:05.196 A:middle
this tinted geometry as

00:45:05.276 --> 00:45:05.986 A:middle
invisible.

00:45:06.196 --> 00:45:08.526 A:middle
And so this geometry doesn't get

00:45:08.526 --> 00:45:10.676 A:middle
processed or rendered on the

00:45:10.676 --> 00:45:12.046 A:middle
GPU, saving significant

00:45:12.046 --> 00:45:12.626 A:middle
rendering cost.

00:45:13.846 --> 00:45:15.626 A:middle
Let's look at one more final

00:45:15.626 --> 00:45:15.716 A:middle
view.

00:45:16.186 --> 00:45:18.866 A:middle
And here is one more view.

00:45:18.866 --> 00:45:20.646 A:middle
Here we are showing both frustum

00:45:20.646 --> 00:45:21.766 A:middle
and occlusion culling at work.

00:45:21.766 --> 00:45:24.996 A:middle
We are, we tinted the geometry

00:45:24.996 --> 00:45:27.196 A:middle
that is occluded with cyan color

00:45:27.946 --> 00:45:30.606 A:middle
and the geometry in magenta is

00:45:30.606 --> 00:45:32.046 A:middle
outside the view frustum.

00:45:32.346 --> 00:45:33.646 A:middle
And you can see there's quite a

00:45:33.646 --> 00:45:34.686 A:middle
bit of geometry on the right

00:45:34.686 --> 00:45:35.786 A:middle
here that is occluded by the

00:45:35.786 --> 00:45:37.556 A:middle
bistro, so it is in cyan color.

00:45:38.446 --> 00:45:39.516 A:middle
And as you can see, there's a

00:45:39.516 --> 00:45:41.106 A:middle
lot of geometry here.

00:45:41.106 --> 00:45:42.816 A:middle
Also the view frustum are, is

00:45:42.816 --> 00:45:43.956 A:middle
occluded.

00:45:44.246 --> 00:45:46.036 A:middle
And again, our culling compute

00:45:46.036 --> 00:45:47.996 A:middle
kernel that does both frustum

00:45:47.996 --> 00:45:49.816 A:middle
and occlusion culling on the GPU

00:45:50.186 --> 00:45:52.546 A:middle
determined these geometry to be

00:45:52.546 --> 00:45:53.006 A:middle
invisible.

00:45:53.006 --> 00:45:55.406 A:middle
So, this tinted geometry doesn't

00:45:55.406 --> 00:45:58.366 A:middle
get processed or rendered on the

00:45:58.366 --> 00:45:59.646 A:middle
GPU, saving significant

00:45:59.646 --> 00:46:00.936 A:middle
rendering cost and increasing

00:45:59.646 --> 00:46:00.936 A:middle
rendering cost and increasing

00:46:01.006 --> 00:46:01.556 A:middle
performance.

00:46:06.416 --> 00:46:09.556 A:middle
So, before we end this talk, I'm

00:46:09.556 --> 00:46:10.636 A:middle
going to show you one more

00:46:10.636 --> 00:46:11.046 A:middle
thing.

00:46:11.046 --> 00:46:13.266 A:middle
I'm going to show you how we are

00:46:13.266 --> 00:46:14.806 A:middle
making it easier than ever to

00:46:14.806 --> 00:46:16.596 A:middle
write a cross ref on Metal core.

00:46:16.706 --> 00:46:18.436 A:middle
I'm also going to show you how

00:46:18.436 --> 00:46:20.376 A:middle
to more easily target features

00:46:20.606 --> 00:46:23.196 A:middle
that are iOS, tvOS and macOS

00:46:23.196 --> 00:46:23.696 A:middle
specific.

00:46:24.346 --> 00:46:26.156 A:middle
And before we do that, let's

00:46:26.156 --> 00:46:27.826 A:middle
take a quick look at Metal

00:46:27.826 --> 00:46:28.926 A:middle
features that are now available

00:46:28.926 --> 00:46:29.976 A:middle
across all our platforms.

00:46:32.446 --> 00:46:34.046 A:middle
Now, we have several features

00:46:34.046 --> 00:46:35.616 A:middle
new to iOS and tvOS.

00:46:36.656 --> 00:46:38.536 A:middle
In the previous sections, we

00:46:38.536 --> 00:46:40.136 A:middle
showed you how setting pipeline

00:46:40.136 --> 00:46:41.536 A:middle
states in indirect command

00:46:41.536 --> 00:46:44.286 A:middle
buffers helps you to fully

00:46:44.286 --> 00:46:45.846 A:middle
utilize GPU-driven pipelines.

00:46:46.626 --> 00:46:48.436 A:middle
We also showed you how indirect

00:46:48.436 --> 00:46:51.556 A:middle
ranges allow you to more easily

00:46:51.556 --> 00:46:53.466 A:middle
and more efficiently pack and

00:46:53.466 --> 00:46:54.976 A:middle
execute indirect commands.

00:46:55.666 --> 00:46:57.456 A:middle
And finally, we are bringing

00:46:57.506 --> 00:46:59.906 A:middle
16-bit depth texture support to

00:46:59.906 --> 00:47:01.066 A:middle
iOS and tvOS.

00:46:59.906 --> 00:47:01.066 A:middle
iOS and tvOS.

00:47:04.196 --> 00:47:05.266 A:middle
This has been a popular request

00:47:05.266 --> 00:47:06.036 A:middle
that helps to optimize shadow

00:47:06.036 --> 00:47:06.366 A:middle
map rendering.

00:47:07.026 --> 00:47:08.776 A:middle
We also have several important

00:47:08.776 --> 00:47:10.126 A:middle
features new to macOS.

00:47:11.546 --> 00:47:12.786 A:middle
We can render now without

00:47:12.786 --> 00:47:14.586 A:middle
attachments in cases where you

00:47:14.586 --> 00:47:16.266 A:middle
need more flexible outputs to

00:47:16.266 --> 00:47:17.106 A:middle
memory buffers.

00:47:17.776 --> 00:47:19.156 A:middle
You can query the time your

00:47:19.186 --> 00:47:20.786 A:middle
command buffer takes on the GPU

00:47:21.236 --> 00:47:22.196 A:middle
so you can adjust your

00:47:22.196 --> 00:47:23.236 A:middle
representation intervals

00:47:23.236 --> 00:47:24.276 A:middle
dynamically.

00:47:24.896 --> 00:47:26.906 A:middle
And finally, macOS now supports

00:47:26.956 --> 00:47:28.846 A:middle
casting between sRGB and

00:47:28.846 --> 00:47:30.896 A:middle
non-sRGB views to better

00:47:30.896 --> 00:47:32.206 A:middle
accommodate linear versus

00:47:32.206 --> 00:47:33.176 A:middle
nonlinear lighting.

00:47:34.506 --> 00:47:36.196 A:middle
So, now let's take a look at the

00:47:36.196 --> 00:47:38.316 A:middle
new GPU family API.

00:47:41.206 --> 00:47:42.856 A:middle
Now, you previously used Metal

00:47:42.856 --> 00:47:44.156 A:middle
feature set queries to condition

00:47:44.446 --> 00:47:46.676 A:middle
your applications based on

00:47:46.676 --> 00:47:48.266 A:middle
available features and limits.

00:47:48.816 --> 00:47:50.156 A:middle
But the number of features,

00:47:50.296 --> 00:47:52.206 A:middle
feature sets has grown and they

00:47:52.206 --> 00:47:53.996 A:middle
currently number, numbers in the

00:47:53.996 --> 00:47:54.516 A:middle
dozens.

00:47:55.156 --> 00:47:57.076 A:middle
The GPU family queries replace

00:47:57.076 --> 00:47:58.986 A:middle
feature sets and makes it easier

00:47:58.986 --> 00:48:00.426 A:middle
to query the capabilities of the

00:47:58.986 --> 00:48:00.426 A:middle
to query the capabilities of the

00:48:00.426 --> 00:48:00.826 A:middle
system.

00:48:01.396 --> 00:48:03.256 A:middle
First, we have consolidated into

00:48:03.256 --> 00:48:05.456 A:middle
four families and organized them

00:48:05.456 --> 00:48:07.076 A:middle
to simplify cross-platform

00:48:07.076 --> 00:48:07.486 A:middle
development.

00:48:08.386 --> 00:48:10.236 A:middle
Second, each family supports a

00:48:10.236 --> 00:48:12.336 A:middle
hierarchy of features organized

00:48:12.336 --> 00:48:13.596 A:middle
into one or more instances.

00:48:14.066 --> 00:48:15.496 A:middle
So, support for one instance

00:48:15.866 --> 00:48:17.686 A:middle
means all earlier instances are

00:48:17.686 --> 00:48:18.146 A:middle
supported.

00:48:19.096 --> 00:48:21.586 A:middle
Third, the new API separates out

00:48:21.586 --> 00:48:23.246 A:middle
Metal software version query to

00:48:23.246 --> 00:48:25.106 A:middle
track how to instances of a

00:48:25.106 --> 00:48:26.996 A:middle
given family change our software

00:48:26.996 --> 00:48:27.326 A:middle
delivers.

00:48:28.496 --> 00:48:30.406 A:middle
And finally, a GPU family

00:48:30.406 --> 00:48:33.226 A:middle
defines a small set of device

00:48:33.226 --> 00:48:35.786 A:middle
queries for optional features

00:48:35.886 --> 00:48:37.446 A:middle
that don't neatly fit into

00:48:37.446 --> 00:48:37.926 A:middle
families.

00:48:39.036 --> 00:48:40.406 A:middle
Now, with that said, let's take

00:48:40.406 --> 00:48:42.106 A:middle
a closer look at the new GPU

00:48:42.106 --> 00:48:43.196 A:middle
family definitions.

00:48:45.356 --> 00:48:47.446 A:middle
All iOS and tvOS features are

00:48:47.446 --> 00:48:49.016 A:middle
now organized into their family,

00:48:49.016 --> 00:48:50.306 A:middle
a single family of five

00:48:50.306 --> 00:48:50.896 A:middle
instances.

00:48:51.576 --> 00:48:53.066 A:middle
With each instance supporting

00:48:53.066 --> 00:48:54.966 A:middle
all features included within the

00:48:54.966 --> 00:48:56.076 A:middle
earlier instances.

00:48:56.866 --> 00:48:58.346 A:middle
So, I'm not going to enumerate

00:48:58.346 --> 00:48:59.786 A:middle
all the features here, but the

00:48:59.786 --> 00:49:01.756 A:middle
resource section of this talk

00:48:59.786 --> 00:49:01.756 A:middle
resource section of this talk

00:49:01.756 --> 00:49:03.586 A:middle
will have a table that'll map

00:49:04.006 --> 00:49:05.696 A:middle
features to families and

00:49:05.696 --> 00:49:06.396 A:middle
instances.

00:49:07.316 --> 00:49:08.566 A:middle
Mac features are similarly

00:49:08.566 --> 00:49:10.156 A:middle
organized around only two

00:49:10.156 --> 00:49:10.656 A:middle
instances.

00:49:11.326 --> 00:49:13.476 A:middle
Again, the Mac II supports all

00:49:13.476 --> 00:49:14.456 A:middle
the features from Mac I.

00:49:14.456 --> 00:49:17.786 A:middle
Now querying these features,

00:49:17.786 --> 00:49:18.886 A:middle
these families greatly

00:49:18.886 --> 00:49:20.296 A:middle
simplifies writing flat,

00:49:20.296 --> 00:49:21.556 A:middle
unspecific code.

00:49:22.066 --> 00:49:23.206 A:middle
But what about when you want to

00:49:23.206 --> 00:49:24.386 A:middle
target all of the platforms?

00:49:25.086 --> 00:49:26.916 A:middle
For that, we have the new common

00:49:26.916 --> 00:49:27.286 A:middle
families.

00:49:28.546 --> 00:49:30.126 A:middle
The common family organizes

00:49:30.356 --> 00:49:31.586 A:middle
Metal features into

00:49:31.586 --> 00:49:32.846 A:middle
cross-platform hierarchy.

00:49:33.576 --> 00:49:34.946 A:middle
Common 1 is universally

00:49:34.946 --> 00:49:37.216 A:middle
supported by all Metal GPUs and

00:49:37.216 --> 00:49:38.866 A:middle
is a great choice for apps that

00:49:39.096 --> 00:49:40.856 A:middle
only use Metal lightly.

00:49:41.696 --> 00:49:44.066 A:middle
Common 2 provides all the

00:49:44.066 --> 00:49:45.716 A:middle
building blocks necessary for

00:49:45.716 --> 00:49:47.426 A:middle
great game development such as

00:49:48.196 --> 00:49:49.656 A:middle
indirect draw, counting

00:49:49.656 --> 00:49:51.636 A:middle
occlusion queries, tessellation,

00:49:51.976 --> 00:49:53.596 A:middle
and Metal performance shadow

00:49:53.596 --> 00:49:53.966 A:middle
support.

00:49:54.946 --> 00:49:56.816 A:middle
And common 3 provides all the

00:49:56.866 --> 00:49:58.656 A:middle
features needed by advanced

00:49:58.656 --> 00:50:00.486 A:middle
applications such as indirect

00:49:58.656 --> 00:50:00.486 A:middle
applications such as indirect

00:50:00.486 --> 00:50:02.196 A:middle
command buffers, layered

00:50:02.196 --> 00:50:04.036 A:middle
rendering, cube map arrays, and

00:50:04.036 --> 00:50:05.176 A:middle
vortex position invariants.

00:50:06.096 --> 00:50:08.346 A:middle
And finally, Metal 3 provides a

00:50:08.346 --> 00:50:10.466 A:middle
special family for iPad apps

00:50:11.156 --> 00:50:13.206 A:middle
targeting the Mac.

00:50:13.206 --> 00:50:15.016 A:middle
That is, tuned for that

00:50:15.016 --> 00:50:15.586 A:middle
experience.

00:50:15.816 --> 00:50:20.726 A:middle
The two iOS mac instances

00:50:20.726 --> 00:50:21.916 A:middle
support a combination of

00:50:21.916 --> 00:50:23.586 A:middle
features critical for great

00:50:23.586 --> 00:50:24.446 A:middle
performance on the Mac.

00:50:25.266 --> 00:50:26.286 A:middle
In particular, they make

00:50:26.286 --> 00:50:28.466 A:middle
available the Mac-specific block

00:50:28.466 --> 00:50:30.346 A:middle
compression pixel formats and

00:50:30.346 --> 00:50:32.246 A:middle
manage texture modes for use

00:50:32.246 --> 00:50:33.756 A:middle
within an otherwise completely

00:50:33.756 --> 00:50:34.646 A:middle
iOS application.

00:50:35.366 --> 00:50:37.946 A:middle
Now, iOS Mac 1 supports all the

00:50:37.946 --> 00:50:39.226 A:middle
features of Common 2 plus

00:50:39.556 --> 00:50:41.356 A:middle
several features from Common 3.

00:50:41.976 --> 00:50:44.786 A:middle
Besides the BC pixel format and

00:50:44.786 --> 00:50:47.846 A:middle
managed textures, it supports

00:50:47.846 --> 00:50:50.096 A:middle
cube texture arrays, read/write

00:50:50.096 --> 00:50:51.676 A:middle
textures, layered rendering,

00:50:51.906 --> 00:50:53.456 A:middle
multiple viewport rendering, and

00:50:53.456 --> 00:50:54.246 A:middle
indirect tessellation.

00:50:56.036 --> 00:50:58.086 A:middle
iOS Mac II supports all the

00:50:58.086 --> 00:51:00.686 A:middle
features of Common 3 in addition

00:50:58.086 --> 00:51:00.686 A:middle
features of Common 3 in addition

00:51:00.686 --> 00:51:02.536 A:middle
to the BC pixel formats and

00:51:02.966 --> 00:51:03.796 A:middle
managed textures.

00:51:04.516 --> 00:51:05.566 A:middle
So, that's the four new

00:51:05.566 --> 00:51:05.996 A:middle
families.

00:51:06.906 --> 00:51:08.416 A:middle
Now, let's take a look at how

00:51:08.416 --> 00:51:10.746 A:middle
you'll use the new QD API in

00:51:10.746 --> 00:51:11.286 A:middle
practice.

00:51:11.666 --> 00:51:14.896 A:middle
Now, in this example we'll check

00:51:14.896 --> 00:51:16.186 A:middle
whether the Mac II features are

00:51:16.186 --> 00:51:16.726 A:middle
available.

00:51:17.216 --> 00:51:20.646 A:middle
We start by checking whether the

00:51:20.646 --> 00:51:22.626 A:middle
OS supports the new family API.

00:51:23.306 --> 00:51:25.116 A:middle
And if the new family API is

00:51:25.116 --> 00:51:27.226 A:middle
available, then we use to check

00:51:27.316 --> 00:51:28.666 A:middle
for Metal 3 features that are

00:51:28.666 --> 00:51:29.086 A:middle
available.

00:51:29.396 --> 00:51:30.986 A:middle
Since Metal 3 is new, you don't

00:51:30.986 --> 00:51:32.396 A:middle
need to strictly check for it,

00:51:32.396 --> 00:51:33.726 A:middle
but that's a good practice.

00:51:33.996 --> 00:51:36.816 A:middle
And if Metal 3 is available,

00:51:36.816 --> 00:51:39.306 A:middle
then we check for the family we

00:51:39.306 --> 00:51:40.106 A:middle
would like to use.

00:51:40.476 --> 00:51:42.296 A:middle
Cross-platform applications

00:51:42.296 --> 00:51:43.426 A:middle
here, check for one of the

00:51:43.426 --> 00:51:45.406 A:middle
common families, as well as one

00:51:45.406 --> 00:51:47.336 A:middle
or more Apple or Mac-specific

00:51:47.336 --> 00:51:47.696 A:middle
families.

00:51:48.956 --> 00:51:51.086 A:middle
If either the API or the

00:51:51.086 --> 00:51:53.066 A:middle
version are not available,

00:51:53.066 --> 00:51:54.856 A:middle
then we fall back to the

00:51:54.856 --> 00:51:56.186 A:middle
older feature set API on

00:51:56.186 --> 00:51:57.556 A:middle
earlier Metal versions.

00:51:58.716 --> 00:52:00.396 A:middle
So, now let's take a look at the

00:51:58.716 --> 00:52:00.396 A:middle
So, now let's take a look at the

00:52:00.396 --> 00:52:02.376 A:middle
setup option features you can

00:52:02.376 --> 00:52:02.926 A:middle
query for.

00:52:03.036 --> 00:52:06.676 A:middle
Now, when a family specifies a

00:52:06.676 --> 00:52:08.516 A:middle
general behavior of GPUs in that

00:52:08.516 --> 00:52:10.816 A:middle
family but some important

00:52:10.816 --> 00:52:12.336 A:middle
features and limits are not

00:52:12.336 --> 00:52:13.846 A:middle
supported uniformly across a

00:52:13.846 --> 00:52:14.186 A:middle
family.

00:52:14.676 --> 00:52:16.436 A:middle
Such as a depth 24 stencil 8

00:52:16.436 --> 00:52:18.196 A:middle
pixel formats, and the number of

00:52:18.286 --> 00:52:19.586 A:middle
MSA samples in a pixel.

00:52:20.396 --> 00:52:22.906 A:middle
So to handle those cases, the

00:52:22.906 --> 00:52:25.146 A:middle
Metal device provides an API to

00:52:25.146 --> 00:52:26.766 A:middle
query for each of those features

00:52:26.766 --> 00:52:27.216 A:middle
directly.

00:52:27.886 --> 00:52:29.496 A:middle
But as you can see, that is not

00:52:29.496 --> 00:52:31.376 A:middle
many features that fall into

00:52:31.376 --> 00:52:32.056 A:middle
this category.

00:52:33.516 --> 00:52:35.726 A:middle
So, to end this section, let's

00:52:35.726 --> 00:52:37.106 A:middle
look at how the many techniques

00:52:37.106 --> 00:52:38.696 A:middle
we have discussed so far are

00:52:38.696 --> 00:52:40.236 A:middle
supported by the new GPU

00:52:40.236 --> 00:52:40.646 A:middle
families.

00:52:42.596 --> 00:52:44.706 A:middle
Classic deferred shading is

00:52:44.706 --> 00:52:45.836 A:middle
supported across all our

00:52:45.836 --> 00:52:47.786 A:middle
platforms and programmable

00:52:47.786 --> 00:52:49.516 A:middle
blending is supported across all

00:52:49.516 --> 00:52:51.566 A:middle
Apple GPUs, making it a good

00:52:51.566 --> 00:52:52.826 A:middle
default choice for your games.

00:52:53.866 --> 00:52:55.286 A:middle
Tile deferred and forward

00:52:55.286 --> 00:52:56.646 A:middle
rendering are also broadly

00:52:56.646 --> 00:52:58.436 A:middle
supported with Apple-specific

00:52:58.436 --> 00:53:00.656 A:middle
optimizations requiring more

00:52:58.436 --> 00:53:00.656 A:middle
optimizations requiring more

00:53:00.656 --> 00:53:01.586 A:middle
recent hardware.

00:53:02.396 --> 00:53:04.246 A:middle
And finally, the visibility

00:53:04.246 --> 00:53:05.876 A:middle
buffer technique is only

00:53:05.876 --> 00:53:07.276 A:middle
supported by the Mac family.

00:53:07.926 --> 00:53:09.886 A:middle
It just happened to have very

00:53:09.886 --> 00:53:10.776 A:middle
demanding resolution

00:53:10.776 --> 00:53:11.356 A:middle
requirements.

00:53:12.536 --> 00:53:14.666 A:middle
Now, let's end this section by

00:53:14.666 --> 00:53:16.416 A:middle
looking at how our GPU-drive

00:53:16.416 --> 00:53:17.876 A:middle
pipeline features are supported

00:53:17.876 --> 00:53:18.726 A:middle
across our families.

00:53:19.146 --> 00:53:22.816 A:middle
Now, some features require broad

00:53:22.816 --> 00:53:25.046 A:middle
support to become a core part of

00:53:25.046 --> 00:53:26.926 A:middle
render engines, and we believe

00:53:26.926 --> 00:53:28.586 A:middle
that GPU-driven pipelines

00:53:28.586 --> 00:53:29.836 A:middle
require that kind of support.

00:53:30.556 --> 00:53:32.066 A:middle
So, we are therefore very happy

00:53:32.066 --> 00:53:33.566 A:middle
to let you all know that

00:53:33.566 --> 00:53:35.046 A:middle
argument buffers and indirect

00:53:35.046 --> 00:53:36.646 A:middle
command buffers for both

00:53:36.646 --> 00:53:38.636 A:middle
graphics and compute are now

00:53:38.636 --> 00:53:40.946 A:middle
supported by a Common family 2

00:53:41.446 --> 00:53:43.616 A:middle
and later.

00:53:43.826 --> 00:53:45.576 A:middle
Now that brings us to the end of

00:53:45.576 --> 00:53:47.146 A:middle
this session on Model Rendering

00:53:47.146 --> 00:53:47.716 A:middle
with Metal.

00:53:48.416 --> 00:53:50.246 A:middle
We hope you can apply all these

00:53:50.246 --> 00:53:51.756 A:middle
techniques to your games and

00:53:51.756 --> 00:53:52.176 A:middle
apps.

00:53:52.326 --> 00:53:53.446 A:middle
Let's do quick recap.

00:53:55.246 --> 00:53:56.696 A:middle
My colleague, Jaap, just showed

00:53:56.696 --> 00:53:57.816 A:middle
you how to implement many

00:53:57.816 --> 00:53:58.906 A:middle
advanced rendering techniques

00:53:58.906 --> 00:54:00.646 A:middle
with Metal, techniques like

00:53:58.906 --> 00:54:00.646 A:middle
with Metal, techniques like

00:54:01.006 --> 00:54:02.626 A:middle
deferred shading, tile forward

00:54:02.626 --> 00:54:04.346 A:middle
rendering are excellent matches

00:54:04.346 --> 00:54:06.726 A:middle
for iOS when combined with and

00:54:06.726 --> 00:54:09.496 A:middle
optimized with programmable

00:54:09.496 --> 00:54:10.766 A:middle
blending and tile sharing.

00:54:11.556 --> 00:54:13.386 A:middle
On Mac, you can use the new

00:54:13.386 --> 00:54:14.806 A:middle
barycentric coordinates and

00:54:14.806 --> 00:54:17.186 A:middle
query LOD to implement the

00:54:17.186 --> 00:54:18.616 A:middle
visibility buffer technique and

00:54:18.616 --> 00:54:19.966 A:middle
render it high resolutions.

00:54:20.956 --> 00:54:22.256 A:middle
But no matter what technique you

00:54:22.256 --> 00:54:24.586 A:middle
choose to use, you can move your

00:54:24.586 --> 00:54:26.566 A:middle
entire render loop to the GPU.

00:54:27.146 --> 00:54:28.426 A:middle
Frustrum culling, occlusion

00:54:28.426 --> 00:54:29.886 A:middle
culling, LOD selection, can all

00:54:29.886 --> 00:54:32.726 A:middle
be done on the GPU with argument

00:54:32.726 --> 00:54:33.556 A:middle
buffers and indirect command

00:54:33.556 --> 00:54:34.046 A:middle
buffers.

00:54:34.746 --> 00:54:37.326 A:middle
And now we can also encode

00:54:37.326 --> 00:54:39.706 A:middle
compute dispatches into indirect

00:54:39.706 --> 00:54:41.346 A:middle
command buffers on the GPU.

00:54:42.156 --> 00:54:44.546 A:middle
Whether you want to target a

00:54:44.546 --> 00:54:46.036 A:middle
wide range of hardware on both

00:54:46.036 --> 00:54:48.306 A:middle
iOS or macOS, or only want to

00:54:48.306 --> 00:54:49.966 A:middle
use a few advanced Metal

00:54:49.966 --> 00:54:51.816 A:middle
features, you can now use the

00:54:51.816 --> 00:54:54.126 A:middle
newly redesigned GPU family API

00:54:54.716 --> 00:54:55.776 A:middle
to check for feature

00:54:55.776 --> 00:54:56.976 A:middle
availability at runtime.

00:54:59.146 --> 00:55:00.866 A:middle
Now, please visit our session

00:54:59.146 --> 00:55:00.866 A:middle
Now, please visit our session

00:55:00.866 --> 00:55:02.576 A:middle
website to learn more about

00:55:03.016 --> 00:55:04.766 A:middle
Metal features and GPU-driven

00:55:04.766 --> 00:55:05.236 A:middle
pipelines.

00:55:05.816 --> 00:55:06.916 A:middle
We will be posting the sample

00:55:06.916 --> 00:55:08.636 A:middle
app that we used in this talk.

00:55:09.006 --> 00:55:10.276 A:middle
You can explore those techniques

00:55:10.276 --> 00:55:11.576 A:middle
and integrate them into your

00:55:11.576 --> 00:55:13.796 A:middle
apps and games and please join

00:55:13.796 --> 00:55:14.536 A:middle
us in our labs.

00:55:14.536 --> 00:55:15.596 A:middle
In fact, there is one right

00:55:15.596 --> 00:55:16.396 A:middle
after this talk.

00:55:17.736 --> 00:55:19.016 A:middle
Thank you, and have a great

00:55:19.016 --> 00:55:19.456 A:middle
conference.

00:55:19.646 --> 00:55:19.926 A:middle
Thank you.

00:55:20.516 --> 00:55:23.500 A:middle
[ Applause ]
