WEBVTT

00:00:00.506 --> 00:00:04.500 A:middle
[ Music ]

00:00:09.366 --> 00:00:11.366 A:middle
[ Applause ]

00:00:11.716 --> 00:00:13.256 A:middle
&gt;&gt; So, over the past year, we've

00:00:13.686 --> 00:00:15.256 A:middle
been working really hard on

00:00:15.256 --> 00:00:16.926 A:middle
adding some great new features

00:00:16.926 --> 00:00:17.656 A:middle
to the compiler.

00:00:18.526 --> 00:00:20.906 A:middle
I'm Jessica, and today, me and

00:00:20.906 --> 00:00:23.366 A:middle
my colleagues, JF and Devin, are

00:00:23.366 --> 00:00:24.516 A:middle
going to share some of those

00:00:24.516 --> 00:00:26.376 A:middle
great features with all of you.

00:00:27.406 --> 00:00:28.536 A:middle
So, we've got a lot of ground to

00:00:28.536 --> 00:00:29.096 A:middle
cover today.

00:00:29.646 --> 00:00:30.996 A:middle
We're going to talk about new

00:00:30.996 --> 00:00:33.356 A:middle
platform support, some low-level

00:00:33.356 --> 00:00:35.466 A:middle
code size optimizations, some

00:00:35.466 --> 00:00:36.906 A:middle
language-level code size

00:00:36.906 --> 00:00:39.156 A:middle
optimizations, some great new

00:00:39.156 --> 00:00:40.956 A:middle
diagnostics, and then we're

00:00:40.956 --> 00:00:42.066 A:middle
going to finish up with some

00:00:42.066 --> 00:00:43.826 A:middle
great new static analyzer checks

00:00:43.826 --> 00:00:45.406 A:middle
that will help you find bugs in

00:00:45.406 --> 00:00:45.836 A:middle
your code.

00:00:46.276 --> 00:00:48.006 A:middle
So, let's get started with new

00:00:48.006 --> 00:00:48.816 A:middle
platform support.

00:00:49.966 --> 00:00:51.776 A:middle
Specifically, I'd like to talk

00:00:51.776 --> 00:00:53.436 A:middle
about the Series 4 Watch.

00:00:55.056 --> 00:00:57.496 A:middle
The Series 4 watch usually a

00:00:57.496 --> 00:00:59.786 A:middle
fully 64-bit chip.

00:01:00.356 --> 00:01:02.986 A:middle
But yet, all of the App Store

00:01:02.986 --> 00:01:04.946 A:middle
apps are 32 bit.

00:01:06.276 --> 00:01:08.576 A:middle
The curious thing about this is

00:01:08.576 --> 00:01:10.796 A:middle
that on day one, all of your

00:01:10.796 --> 00:01:13.286 A:middle
apps worked seamlessly on the

00:01:13.286 --> 00:01:14.216 A:middle
Series 4 Watch.

00:01:14.846 --> 00:01:17.886 A:middle
This seems kind of like magic.

00:01:18.296 --> 00:01:19.596 A:middle
You didn't have to recompile

00:01:19.596 --> 00:01:19.936 A:middle
anything.

00:01:20.686 --> 00:01:23.956 A:middle
But yet, all of the apps worked.

00:01:24.126 --> 00:01:25.276 A:middle
How did this happen?

00:01:25.686 --> 00:01:27.256 A:middle
Now, it would be awesome if I

00:01:27.256 --> 00:01:28.496 A:middle
could get the front row or any

00:01:28.496 --> 00:01:29.456 A:middle
row of the audience to give me a

00:01:29.456 --> 00:01:30.986 A:middle
drum roll like this, but if you

00:01:30.986 --> 00:01:31.956 A:middle
don't want to it's fine.

00:01:32.766 --> 00:01:34.456 A:middle
Da da da da da da da da da, the

00:01:34.456 --> 00:01:35.846 A:middle
answer is Bitcode.

00:01:35.846 --> 00:01:35.913 A:middle
[applause]

00:01:35.913 --> 00:01:39.386 A:middle
And I explained absolutely

00:01:39.416 --> 00:01:39.656 A:middle
nothing.

00:01:39.656 --> 00:01:42.346 A:middle
So, allow me to explain this to

00:01:42.346 --> 00:01:42.486 A:middle
you.

00:01:42.646 --> 00:01:45.586 A:middle
Let's take some source code,

00:01:45.586 --> 00:01:46.506 A:middle
your favorite language.

00:01:46.796 --> 00:01:48.496 A:middle
What we're going to do is we're

00:01:48.496 --> 00:01:49.526 A:middle
going to hand that off to the

00:01:49.526 --> 00:01:50.066 A:middle
compiler.

00:01:50.746 --> 00:01:52.216 A:middle
Now, normally what you would do

00:01:52.256 --> 00:01:54.266 A:middle
here is you would continue the

00:01:54.266 --> 00:01:56.036 A:middle
standard compilation process,

00:01:56.036 --> 00:01:58.136 A:middle
and you would get like a binary

00:01:58.136 --> 00:01:59.826 A:middle
or something, but we're not

00:01:59.826 --> 00:02:00.366 A:middle
going to do that.

00:01:59.826 --> 00:02:00.366 A:middle
going to do that.

00:02:00.536 --> 00:02:03.196 A:middle
What we're going to do instead

00:02:03.196 --> 00:02:03.966 A:middle
is we're going to stop the

00:02:03.966 --> 00:02:05.996 A:middle
compilation process early, and

00:02:06.306 --> 00:02:08.576 A:middle
we're going to produce LLVM

00:02:08.576 --> 00:02:09.086 A:middle
Bitcode.

00:02:09.675 --> 00:02:13.556 A:middle
So, what's cool about LLVM

00:02:13.556 --> 00:02:16.416 A:middle
Bitcode is it encodes an

00:02:16.416 --> 00:02:18.136 A:middle
intermediate state in the

00:02:18.136 --> 00:02:18.706 A:middle
compiler.

00:02:19.296 --> 00:02:21.676 A:middle
And what you can do with this

00:02:21.676 --> 00:02:24.686 A:middle
intermediate state is you can

00:02:24.686 --> 00:02:26.846 A:middle
actually pick up the compilation

00:02:26.846 --> 00:02:28.736 A:middle
process where you left it off.

00:02:29.826 --> 00:02:31.016 A:middle
So, that's what we do, except

00:02:31.466 --> 00:02:33.466 A:middle
this time we do it in the App

00:02:33.716 --> 00:02:33.866 A:middle
Store.

00:02:35.026 --> 00:02:36.646 A:middle
By doing this, we could take one

00:02:36.646 --> 00:02:38.546 A:middle
Bitcode for one app and produce

00:02:38.876 --> 00:02:40.576 A:middle
two different apps from it, one

00:02:40.576 --> 00:02:42.966 A:middle
to run on a 32-bit chip, and one

00:02:42.966 --> 00:02:44.666 A:middle
to run on the fancy new 64-bit

00:02:44.666 --> 00:02:45.456 A:middle
chip as well.

00:02:47.036 --> 00:02:49.636 A:middle
Now, there kind of is a problem

00:02:49.636 --> 00:02:49.946 A:middle
here.

00:02:50.596 --> 00:02:51.736 A:middle
The problem is is that the

00:02:51.736 --> 00:02:53.726 A:middle
compiler doesn't actually know

00:02:53.726 --> 00:02:54.666 A:middle
that you're going to be

00:02:54.666 --> 00:02:56.896 A:middle
executing code on a 64-bit

00:02:57.006 --> 00:02:59.926 A:middle
device, and if it knew that, it

00:02:59.926 --> 00:03:01.036 A:middle
could actually leverage that

00:02:59.926 --> 00:03:01.036 A:middle
could actually leverage that

00:03:01.036 --> 00:03:03.246 A:middle
information to optimize the app

00:03:03.246 --> 00:03:03.776 A:middle
even more.

00:03:04.306 --> 00:03:05.666 A:middle
And so to get around that, what

00:03:05.666 --> 00:03:07.936 A:middle
we do is we collect Bitcode for

00:03:07.936 --> 00:03:09.696 A:middle
the 64-bit chip as well.

00:03:10.426 --> 00:03:11.796 A:middle
This allows us to create a

00:03:11.796 --> 00:03:14.036 A:middle
really, really fast app just

00:03:14.036 --> 00:03:14.696 A:middle
from the Bitcode.

00:03:15.366 --> 00:03:17.286 A:middle
Now, this is pretty cool.

00:03:17.286 --> 00:03:19.996 A:middle
This is like-- this is one of

00:03:19.996 --> 00:03:21.056 A:middle
the things that makes compilers

00:03:21.056 --> 00:03:21.856 A:middle
kind of magical.

00:03:22.196 --> 00:03:24.766 A:middle
It's pretty awesome, eh?

00:03:25.006 --> 00:03:27.196 A:middle
Now, let's move onto Code Size

00:03:27.196 --> 00:03:27.956 A:middle
Improvements.

00:03:27.956 --> 00:03:28.856 A:middle
This is one of my favorite

00:03:28.856 --> 00:03:29.326 A:middle
topics.

00:03:30.276 --> 00:03:32.086 A:middle
We've been hard at work having

00:03:32.086 --> 00:03:33.546 A:middle
the compiler actually produce as

00:03:33.546 --> 00:03:34.686 A:middle
small of code as possible for

00:03:34.686 --> 00:03:34.876 A:middle
you.

00:03:35.816 --> 00:03:38.196 A:middle
Now, code size is pretty

00:03:38.196 --> 00:03:40.686 A:middle
important because bigger code

00:03:40.726 --> 00:03:42.976 A:middle
means bigger, slower downloads,

00:03:42.976 --> 00:03:45.076 A:middle
and bigger apps take up more

00:03:45.076 --> 00:03:47.266 A:middle
space on users' devices, and you

00:03:47.266 --> 00:03:48.066 A:middle
notice this kind of thing.

00:03:48.686 --> 00:03:51.006 A:middle
So, to support users that

00:03:51.006 --> 00:03:53.236 A:middle
actually want to prioritize code

00:03:53.236 --> 00:03:56.956 A:middle
size over all other metrics, we

00:03:56.956 --> 00:03:59.216 A:middle
added a new optimization level

00:03:59.296 --> 00:03:59.926 A:middle
to Xcode.

00:04:00.806 --> 00:04:03.666 A:middle
And that optimization level is

00:04:03.786 --> 00:04:04.106 A:middle
-Oz.

00:04:05.266 --> 00:04:07.226 A:middle
And I'm going to keep saying -Oz

00:04:07.226 --> 00:04:09.226 A:middle
because I'm Canadian, so we

00:04:09.226 --> 00:04:10.666 A:middle
might as well call it Oh Canada.

00:04:11.516 --> 00:04:15.746 A:middle
[ Applause ]

00:04:16.245 --> 00:04:17.435 A:middle
What I'd like to show you today

00:04:17.435 --> 00:04:18.875 A:middle
is an example of the kind of

00:04:18.875 --> 00:04:21.076 A:middle
optimization that appears at

00:04:21.766 --> 00:04:23.376 A:middle
-Oz, but before doing that, I'm

00:04:24.346 --> 00:04:26.306 A:middle
going to do my best to tell all

00:04:26.306 --> 00:04:28.136 A:middle
of you how a compiler works in a

00:04:28.136 --> 00:04:28.936 A:middle
couple of minutes flat.

00:04:29.526 --> 00:04:33.116 A:middle
So, when you compile some code,

00:04:33.116 --> 00:04:35.616 A:middle
the initial representation is

00:04:35.616 --> 00:04:37.056 A:middle
very, very target independent.

00:04:37.056 --> 00:04:37.806 A:middle
It's source code.

00:04:38.626 --> 00:04:39.786 A:middle
When you put that into the

00:04:39.786 --> 00:04:42.516 A:middle
compiler, it gets lowered to an

00:04:42.516 --> 00:04:43.956 A:middle
IR, an intermediate

00:04:43.956 --> 00:04:44.756 A:middle
representation.

00:04:45.286 --> 00:04:47.166 A:middle
This intermediate representation

00:04:47.166 --> 00:04:48.736 A:middle
is still mostly target

00:04:48.736 --> 00:04:51.016 A:middle
independent, but it does have

00:04:51.016 --> 00:04:52.286 A:middle
some target-dependent features

00:04:52.286 --> 00:04:52.876 A:middle
built in.

00:04:53.616 --> 00:04:55.326 A:middle
It looks kind of like a generic

00:04:55.326 --> 00:04:55.806 A:middle
assembly.

00:04:56.746 --> 00:04:58.676 A:middle
At this point, you could just

00:04:58.676 --> 00:05:00.586 A:middle
stop the compilation process and

00:04:58.676 --> 00:05:00.586 A:middle
stop the compilation process and

00:05:00.586 --> 00:05:02.566 A:middle
spit out some Bitcode, but we're

00:05:02.566 --> 00:05:03.266 A:middle
not going to do that.

00:05:03.266 --> 00:05:04.126 A:middle
We're going to keep going.

00:05:05.616 --> 00:05:07.676 A:middle
That representation is further

00:05:07.676 --> 00:05:10.116 A:middle
lowered to what we call MIR,

00:05:10.206 --> 00:05:12.276 A:middle
which is short for Machine IR.

00:05:13.246 --> 00:05:15.046 A:middle
At the end of this process, the

00:05:15.046 --> 00:05:16.846 A:middle
Machine IR looks almost

00:05:16.846 --> 00:05:18.366 A:middle
identical to the assembly for

00:05:18.366 --> 00:05:20.826 A:middle
the target, in this case arm 64

00:05:20.826 --> 00:05:21.286 A:middle
assembly.

00:05:21.996 --> 00:05:23.106 A:middle
We could put the code side by

00:05:23.106 --> 00:05:23.986 A:middle
side, for example.

00:05:25.486 --> 00:05:27.766 A:middle
Now, in the optimization that

00:05:27.766 --> 00:05:29.856 A:middle
we're going to talk about, we're

00:05:29.856 --> 00:05:31.276 A:middle
going to be working with the

00:05:31.276 --> 00:05:34.306 A:middle
Machine IR, but for the sake of

00:05:34.306 --> 00:05:35.916 A:middle
familiarity, I'm just going to

00:05:35.916 --> 00:05:37.056 A:middle
do all of our examples in

00:05:37.056 --> 00:05:38.726 A:middle
assembly, because that's less

00:05:38.726 --> 00:05:39.136 A:middle
scary.

00:05:39.786 --> 00:05:42.236 A:middle
What I'd like to tell you about

00:05:42.496 --> 00:05:43.936 A:middle
is the code size optimization

00:05:43.936 --> 00:05:45.226 A:middle
called Function Outlining.

00:05:46.626 --> 00:05:48.966 A:middle
Function Outlining is one of

00:05:48.966 --> 00:05:50.346 A:middle
those optimizations that's going

00:05:50.346 --> 00:05:51.586 A:middle
to do everything it can to save

00:05:51.586 --> 00:05:52.426 A:middle
you some size.

00:05:52.946 --> 00:05:54.296 A:middle
It's very, very late in the

00:05:54.296 --> 00:05:54.916 A:middle
compiler.

00:05:55.296 --> 00:05:56.976 A:middle
It doesn't actually rely on any

00:05:56.976 --> 00:05:58.306 A:middle
sort of a source code language.

00:05:58.956 --> 00:06:00.516 A:middle
The best way to explain what

00:05:58.956 --> 00:06:00.516 A:middle
The best way to explain what

00:06:00.516 --> 00:06:02.286 A:middle
this does is by example.

00:06:03.356 --> 00:06:05.266 A:middle
So, let's say that you have some

00:06:05.266 --> 00:06:06.336 A:middle
assembly like this.

00:06:07.016 --> 00:06:08.836 A:middle
hasse and kakutani are two

00:06:08.836 --> 00:06:10.186 A:middle
random functions in some random

00:06:10.376 --> 00:06:10.806 A:middle
program.

00:06:11.856 --> 00:06:13.226 A:middle
Now, what's interesting about

00:06:13.226 --> 00:06:15.836 A:middle
hasse and kakutani is they have

00:06:15.836 --> 00:06:18.026 A:middle
some identical instructions.

00:06:19.276 --> 00:06:20.826 A:middle
What we can do with this is we

00:06:20.826 --> 00:06:22.226 A:middle
could take those identical

00:06:22.226 --> 00:06:25.076 A:middle
instructions and factor them out

00:06:25.076 --> 00:06:26.116 A:middle
into a new function.

00:06:27.036 --> 00:06:28.726 A:middle
After we factor them out into a

00:06:28.726 --> 00:06:31.756 A:middle
new function, what we can do is

00:06:31.756 --> 00:06:33.336 A:middle
we can replace the sequences

00:06:33.336 --> 00:06:35.586 A:middle
that we found with calls or

00:06:35.586 --> 00:06:36.456 A:middle
branches.

00:06:37.196 --> 00:06:39.036 A:middle
As a result of this, we end up

00:06:39.036 --> 00:06:39.966 A:middle
with a smaller program.

00:06:41.056 --> 00:06:42.006 A:middle
And how much smaller?

00:06:42.416 --> 00:06:46.446 A:middle
Well, up to 25 percent on our

00:06:46.726 --> 00:06:48.376 A:middle
test programs.

00:06:48.376 --> 00:06:50.196 A:middle
[applause]

00:06:50.196 --> 00:06:51.706 A:middle
Now, some of you might be

00:06:51.706 --> 00:06:53.096 A:middle
wondering, okay, well where do

00:06:53.096 --> 00:06:54.566 A:middle
these savings come from?

00:06:55.126 --> 00:06:56.516 A:middle
Is it because of copied and

00:06:56.516 --> 00:06:57.416 A:middle
pasted code?

00:06:57.806 --> 00:06:58.966 A:middle
Is it because your code needs to

00:06:58.966 --> 00:06:59.816 A:middle
be refactored?

00:07:00.406 --> 00:07:01.886 A:middle
Well, no, there's actually

00:07:01.886 --> 00:07:03.516 A:middle
something a bit deeper happening

00:07:03.516 --> 00:07:03.826 A:middle
here.

00:07:04.086 --> 00:07:05.286 A:middle
If you do have a bunch of code

00:07:05.286 --> 00:07:07.296 A:middle
copied and pasted around, that

00:07:07.356 --> 00:07:08.946 A:middle
will impact outlining behavior,

00:07:09.016 --> 00:07:10.496 A:middle
but that's not really the most

00:07:10.496 --> 00:07:11.086 A:middle
important thing.

00:07:11.726 --> 00:07:13.466 A:middle
Let's look at another example.

00:07:14.886 --> 00:07:16.316 A:middle
Say you have this function.

00:07:17.456 --> 00:07:18.346 A:middle
It doesn't matter what this

00:07:18.346 --> 00:07:20.346 A:middle
function does, but what I'd like

00:07:20.346 --> 00:07:23.536 A:middle
to address is what happens if we

00:07:23.536 --> 00:07:25.266 A:middle
take this function and we put it

00:07:25.266 --> 00:07:26.046 A:middle
into the compiler.

00:07:26.346 --> 00:07:27.156 A:middle
We get some assembly.

00:07:27.386 --> 00:07:30.516 A:middle
Well, you might get something

00:07:30.516 --> 00:07:32.406 A:middle
that looks kind of like this.

00:07:33.416 --> 00:07:34.926 A:middle
Once again, you don't really

00:07:34.926 --> 00:07:36.106 A:middle
need to understand this

00:07:36.106 --> 00:07:38.446 A:middle
assembly, but what I'd like to

00:07:38.446 --> 00:07:40.246 A:middle
draw attention to is the

00:07:40.246 --> 00:07:42.026 A:middle
instructions at the beginning

00:07:42.026 --> 00:07:43.316 A:middle
and the end of the function.

00:07:44.796 --> 00:07:46.176 A:middle
These are called the function

00:07:46.176 --> 00:07:47.226 A:middle
prologue and epilogue.

00:07:47.826 --> 00:07:48.996 A:middle
These instructions don't

00:07:48.996 --> 00:07:50.856 A:middle
correspond to any individual

00:07:50.856 --> 00:07:51.786 A:middle
lines of source code.

00:07:52.666 --> 00:07:53.856 A:middle
These are instructions that are

00:07:53.856 --> 00:07:56.356 A:middle
inserted by the compiler to meet

00:07:56.356 --> 00:07:57.196 A:middle
some sort of system

00:07:57.196 --> 00:07:57.956 A:middle
requirements.

00:07:59.376 --> 00:08:00.976 A:middle
So, these types of things, like

00:07:59.376 --> 00:08:00.976 A:middle
So, these types of things, like

00:08:00.976 --> 00:08:03.806 A:middle
these stores and these loads

00:08:04.026 --> 00:08:05.306 A:middle
could appear in many places

00:08:05.306 --> 00:08:07.446 A:middle
throughout your program, and

00:08:07.446 --> 00:08:09.186 A:middle
this is the kind of thing that

00:08:09.186 --> 00:08:10.316 A:middle
the outliner can actually

00:08:10.316 --> 00:08:11.986 A:middle
leverage to reduce the size of

00:08:12.036 --> 00:08:12.906 A:middle
the overall program.

00:08:14.066 --> 00:08:17.136 A:middle
There are some gotchas to do

00:08:17.136 --> 00:08:17.656 A:middle
with this though.

00:08:18.596 --> 00:08:22.826 A:middle
First off, when you outline, you

00:08:22.826 --> 00:08:24.026 A:middle
change the control flow of your

00:08:24.026 --> 00:08:24.466 A:middle
program.

00:08:25.326 --> 00:08:27.436 A:middle
Here, you might initially have

00:08:27.436 --> 00:08:30.206 A:middle
ulam called collatz, but then

00:08:30.206 --> 00:08:31.946 A:middle
you could outline the call to

00:08:31.946 --> 00:08:32.556 A:middle
collatz.

00:08:33.265 --> 00:08:35.626 A:middle
The thing about what happens

00:08:35.626 --> 00:08:37.796 A:middle
here is we've changed the

00:08:37.796 --> 00:08:38.986 A:middle
control of flow of the program.

00:08:40.076 --> 00:08:42.525 A:middle
So, the problem with this is

00:08:42.525 --> 00:08:45.856 A:middle
what happens if you crash inside

00:08:45.946 --> 00:08:46.586 A:middle
collatz?

00:08:47.756 --> 00:08:49.246 A:middle
Well, what's going to happen is

00:08:49.246 --> 00:08:50.166 A:middle
you're going to go and you're

00:08:50.166 --> 00:08:51.486 A:middle
going to take your program and

00:08:51.486 --> 00:08:53.016 A:middle
you're going to throw it into

00:08:54.156 --> 00:08:54.756 A:middle
LLDB, and you're going to

00:08:54.756 --> 00:08:56.516 A:middle
see the added outline function

00:08:56.516 --> 00:08:57.506 A:middle
in your back trace.

00:08:57.506 --> 00:08:58.786 A:middle
So, this is something you have

00:08:58.846 --> 00:09:00.386 A:middle
to watch out for if you're

00:08:58.846 --> 00:09:00.386 A:middle
to watch out for if you're

00:09:00.386 --> 00:09:03.126 A:middle
actually outlining code.

00:09:03.336 --> 00:09:05.086 A:middle
Another thing is that outlining

00:09:05.086 --> 00:09:06.746 A:middle
can increase the execution time

00:09:06.746 --> 00:09:07.366 A:middle
of your program.

00:09:08.736 --> 00:09:10.306 A:middle
You're adding calls, and calls

00:09:10.306 --> 00:09:11.396 A:middle
could have an execution time

00:09:11.396 --> 00:09:11.846 A:middle
overhead.

00:09:12.786 --> 00:09:14.536 A:middle
And this is actually okay though

00:09:14.536 --> 00:09:17.446 A:middle
because -Oz prioritizes size

00:09:17.446 --> 00:09:18.816 A:middle
over everything else.

00:09:19.296 --> 00:09:20.366 A:middle
When you're going through -Oz,

00:09:20.366 --> 00:09:21.766 A:middle
you're saying, make it small.

00:09:22.586 --> 00:09:25.296 A:middle
Because of this, we don't

00:09:25.296 --> 00:09:26.966 A:middle
recommend that you compile

00:09:27.486 --> 00:09:29.036 A:middle
performance sensitive code with

00:09:29.036 --> 00:09:29.216 A:middle
-Oz.

00:09:30.186 --> 00:09:31.656 A:middle
If execution time is king in

00:09:31.656 --> 00:09:33.536 A:middle
your program, -Oz is not the

00:09:33.536 --> 00:09:34.426 A:middle
best thing to use.

00:09:35.596 --> 00:09:38.256 A:middle
However, we do recommend that

00:09:38.306 --> 00:09:39.716 A:middle
you use instruments.

00:09:40.316 --> 00:09:41.256 A:middle
What instruments is going to

00:09:41.256 --> 00:09:43.226 A:middle
tell you is where the hot spots

00:09:43.226 --> 00:09:44.616 A:middle
in your program are, and this

00:09:44.616 --> 00:09:46.156 A:middle
can allow you to make the best

00:09:46.156 --> 00:09:48.136 A:middle
decisions with respect to

00:09:48.136 --> 00:09:49.906 A:middle
optimization for your app.

00:09:50.916 --> 00:09:52.596 A:middle
The compiler has lots of

00:09:52.596 --> 00:09:53.856 A:middle
different optimization levels,

00:09:55.326 --> 00:09:57.036 A:middle
and those optimization levels

00:09:58.236 --> 00:09:59.776 A:middle
all prioritize different things.

00:10:00.726 --> 00:10:05.616 A:middle
For example, -Oz prioritizes

00:10:05.616 --> 00:10:07.516 A:middle
size at all cost, and as a

00:10:07.516 --> 00:10:10.406 A:middle
result, you might have some

00:10:10.406 --> 00:10:12.176 A:middle
slightly slower execution time.

00:10:12.656 --> 00:10:15.896 A:middle
But on the other end of the

00:10:15.896 --> 00:10:17.136 A:middle
spectrum, you have -O3.

00:10:17.186 --> 00:10:19.626 A:middle
-O3 is going to prioritize the

00:10:19.626 --> 00:10:20.966 A:middle
execution time of your program

00:10:20.966 --> 00:10:22.866 A:middle
at all costs, and as a result,

00:10:22.866 --> 00:10:26.646 A:middle
you might get a larger program.

00:10:26.646 --> 00:10:30.676 A:middle
-Os is the default optimization

00:10:30.676 --> 00:10:32.856 A:middle
level in Xcode because it has a

00:10:33.156 --> 00:10:35.406 A:middle
good balance between speed and

00:10:35.406 --> 00:10:35.826 A:middle
size.

00:10:36.926 --> 00:10:38.266 A:middle
But, you know, you might have

00:10:38.266 --> 00:10:39.866 A:middle
different optimization needs,

00:10:39.916 --> 00:10:41.246 A:middle
and so you can use instruments

00:10:41.246 --> 00:10:43.686 A:middle
to figure this out.

00:10:43.936 --> 00:10:45.416 A:middle
The compiler also offers some

00:10:45.416 --> 00:10:47.586 A:middle
extra optimizations that I don't

00:10:47.586 --> 00:10:48.826 A:middle
have a lot of time to talk about

00:10:48.826 --> 00:10:49.796 A:middle
but I would like to cover a

00:10:49.796 --> 00:10:50.896 A:middle
little bit about anyway.

00:10:51.446 --> 00:10:54.006 A:middle
It offers PGO, which is

00:10:54.056 --> 00:10:55.406 A:middle
Profile-Guided Optimization.

00:10:56.376 --> 00:10:58.116 A:middle
PGO is pretty cool because it

00:10:58.116 --> 00:10:59.816 A:middle
allows you to actually execute

00:10:59.816 --> 00:11:02.016 A:middle
your program and then collect

00:10:59.816 --> 00:11:02.016 A:middle
your program and then collect

00:11:02.016 --> 00:11:03.466 A:middle
information about how your

00:11:03.466 --> 00:11:04.206 A:middle
program runs.

00:11:04.636 --> 00:11:06.546 A:middle
Then you can use that to guide

00:11:06.656 --> 00:11:08.546 A:middle
the compiler when you compile it

00:11:08.546 --> 00:11:08.796 A:middle
again.

00:11:10.016 --> 00:11:11.816 A:middle
It also offers LTO, which is

00:11:11.816 --> 00:11:12.976 A:middle
Link-Time Optimization.

00:11:13.586 --> 00:11:14.926 A:middle
What's cool about Link-Time

00:11:14.926 --> 00:11:17.156 A:middle
Optimization is at the cost of

00:11:17.156 --> 00:11:18.616 A:middle
some compile time, what you can

00:11:18.616 --> 00:11:20.636 A:middle
do is you can tell the compiler,

00:11:21.096 --> 00:11:23.496 A:middle
okay, let's wait until we have

00:11:23.726 --> 00:11:26.316 A:middle
every single file in the program

00:11:26.316 --> 00:11:29.136 A:middle
and use that to say provide

00:11:29.136 --> 00:11:30.676 A:middle
better inlining and outlining.

00:11:31.206 --> 00:11:32.806 A:middle
Optimizations like inlining and

00:11:32.806 --> 00:11:34.476 A:middle
outlining do better when they

00:11:34.476 --> 00:11:36.276 A:middle
have more context, so LTO could

00:11:36.276 --> 00:11:36.756 A:middle
help there.

00:11:37.596 --> 00:11:39.576 A:middle
You can also combine these extra

00:11:39.576 --> 00:11:41.776 A:middle
optimizations with the existing

00:11:41.776 --> 00:11:43.876 A:middle
optimization levels to get some

00:11:43.876 --> 00:11:45.436 A:middle
really, really good actual

00:11:45.436 --> 00:11:46.156 A:middle
performance.

00:11:47.636 --> 00:11:48.606 A:middle
Because I don't have a lot of

00:11:48.686 --> 00:11:49.746 A:middle
time to actually cover what

00:11:49.746 --> 00:11:51.786 A:middle
these things do, I recommend

00:11:51.786 --> 00:11:53.516 A:middle
that you check out the previous

00:11:53.516 --> 00:11:55.116 A:middle
What's New in LLVM talk so that

00:11:55.116 --> 00:11:56.986 A:middle
you can learn a bit more about

00:11:58.396 --> 00:11:58.496 A:middle
them.

00:11:58.716 --> 00:11:59.866 A:middle
After all that, you might be

00:11:59.866 --> 00:12:01.336 A:middle
wondering, okay, how do I enable

00:11:59.866 --> 00:12:01.336 A:middle
wondering, okay, how do I enable

00:12:01.336 --> 00:12:01.516 A:middle
-Oz?

00:12:01.516 --> 00:12:03.386 A:middle
Well, just go to your project's

00:12:03.536 --> 00:12:05.936 A:middle
build settings and select -Oz as

00:12:05.976 --> 00:12:07.196 A:middle
the optimization level.

00:12:08.166 --> 00:12:10.256 A:middle
You can also enable -Oz or other

00:12:10.256 --> 00:12:12.106 A:middle
optimization levels on specific

00:12:12.186 --> 00:12:14.466 A:middle
files in Xcode by going to your

00:12:14.466 --> 00:12:16.516 A:middle
project's build phases, going to

00:12:16.516 --> 00:12:18.356 A:middle
the compile sources list, and

00:12:18.356 --> 00:12:19.636 A:middle
setting the compiler flags.

00:12:20.006 --> 00:12:20.366 A:middle
All right.

00:12:21.256 --> 00:12:23.136 A:middle
So, I just told you a lot of

00:12:23.136 --> 00:12:23.456 A:middle
stuff.

00:12:23.456 --> 00:12:24.336 A:middle
You're probably wondering, okay,

00:12:24.336 --> 00:12:26.026 A:middle
how does this impact my app's

00:12:26.026 --> 00:12:26.566 A:middle
code size?

00:12:26.866 --> 00:12:28.246 A:middle
How do I figure out this kind of

00:12:28.246 --> 00:12:28.856 A:middle
information?

00:12:29.596 --> 00:12:32.996 A:middle
Well, to figure out code size, I

00:12:32.996 --> 00:12:34.836 A:middle
recommend a little tool called

00:12:35.036 --> 00:12:35.396 A:middle
size.

00:12:36.996 --> 00:12:38.326 A:middle
I use this tool a lot.

00:12:38.326 --> 00:12:39.606 A:middle
It's a nice little terminal app.

00:12:40.146 --> 00:12:41.836 A:middle
So, size is going to give you

00:12:41.836 --> 00:12:43.936 A:middle
some nice low-level binary

00:12:43.936 --> 00:12:45.946 A:middle
information about your app.

00:12:46.516 --> 00:12:47.826 A:middle
It is not going to tell you the

00:12:47.826 --> 00:12:49.366 A:middle
actual total size of your app,

00:12:49.366 --> 00:12:50.336 A:middle
because it doesn't include

00:12:50.386 --> 00:12:52.056 A:middle
things like assets, for example.

00:12:52.436 --> 00:12:54.206 A:middle
If you have like a giant picture

00:12:54.206 --> 00:12:55.556 A:middle
in your app, and you have like a

00:12:55.556 --> 00:12:56.756 A:middle
hello world of code, the

00:12:56.756 --> 00:12:58.046 A:middle
compiler can't help you with

00:12:59.346 --> 00:12:59.486 A:middle
that.

00:12:59.966 --> 00:13:01.206 A:middle
But, let's say you want to use

00:12:59.966 --> 00:13:01.206 A:middle
But, let's say you want to use

00:13:01.206 --> 00:13:01.686 A:middle
size.

00:13:02.426 --> 00:13:03.056 A:middle
Here's how you do it.

00:13:03.056 --> 00:13:03.776 A:middle
It's easy.

00:13:03.776 --> 00:13:06.106 A:middle
You just say size, and here's

00:13:06.106 --> 00:13:07.056 A:middle
the path to my binary.

00:13:07.896 --> 00:13:09.316 A:middle
What it's going to do is it's

00:13:09.316 --> 00:13:10.276 A:middle
going to give you some nice

00:13:10.356 --> 00:13:11.576 A:middle
output like this.

00:13:12.306 --> 00:13:13.636 A:middle
What it's going to do is it's

00:13:13.636 --> 00:13:14.816 A:middle
going to tell you the size of

00:13:14.816 --> 00:13:17.036 A:middle
each segment in your binary, and

00:13:17.036 --> 00:13:17.726 A:middle
it's going to tell you the

00:13:17.786 --> 00:13:19.226 A:middle
overall size of the binary as

00:13:19.226 --> 00:13:19.476 A:middle
well.

00:13:20.526 --> 00:13:23.646 A:middle
But, the thing is, is each

00:13:23.646 --> 00:13:25.886 A:middle
segment in a binary is actually

00:13:25.886 --> 00:13:27.496 A:middle
comprised of many sections.

00:13:28.736 --> 00:13:30.706 A:middle
I only care about executable

00:13:30.706 --> 00:13:32.166 A:middle
instructions in this example.

00:13:32.166 --> 00:13:34.286 A:middle
So, what I'm going to do then,

00:13:34.816 --> 00:13:36.416 A:middle
is I'm going to give size a

00:13:36.416 --> 00:13:37.446 A:middle
couple extra flags.

00:13:38.006 --> 00:13:41.246 A:middle
Those extra flags are the -l and

00:13:41.246 --> 00:13:42.336 A:middle
the -m flags.

00:13:42.916 --> 00:13:44.836 A:middle
When I do this, what size is

00:13:44.836 --> 00:13:46.276 A:middle
going to do is it's going to

00:13:46.276 --> 00:13:47.866 A:middle
give me a per section breakdown.

00:13:48.406 --> 00:13:49.736 A:middle
If I want to find out more about

00:13:49.736 --> 00:13:51.686 A:middle
executable instructions, then I

00:13:51.686 --> 00:13:53.456 A:middle
can just look at the text

00:13:55.276 --> 00:13:55.496 A:middle
section.

00:13:55.606 --> 00:13:57.356 A:middle
So, I hope that all of this

00:13:57.356 --> 00:13:58.686 A:middle
helps you with gaining some more

00:13:58.686 --> 00:13:59.906 A:middle
insight into the code size of

00:13:59.906 --> 00:14:00.946 A:middle
your apps.

00:13:59.906 --> 00:14:00.946 A:middle
your apps.

00:14:01.036 --> 00:14:02.316 A:middle
Now, I'm going to leave, and I'm

00:14:02.316 --> 00:14:03.436 A:middle
going to hand it off to my

00:14:03.436 --> 00:14:05.376 A:middle
fellow Canadian, JF, who's going

00:14:05.376 --> 00:14:06.126 A:middle
to tell you about some

00:14:06.126 --> 00:14:07.506 A:middle
language-level Code Size

00:14:07.506 --> 00:14:08.226 A:middle
Improvements.

00:14:08.281 --> 00:14:10.281 A:middle
[applause]

00:14:10.336 --> 00:14:10.876 A:middle
&gt;&gt; Thanks, Jessica.

00:14:11.376 --> 00:14:13.376 A:middle
[applause]

00:14:13.876 --> 00:14:14.686 A:middle
&gt;&gt; So, I'm Jeff, and I'm going

00:14:14.686 --> 00:14:16.256 A:middle
to tell you about Language-Level

00:14:16.256 --> 00:14:16.826 A:middle
Optimization.

00:14:17.056 --> 00:14:18.356 A:middle
So, Jessica told you about

00:14:18.526 --> 00:14:20.306 A:middle
low-level, kind of assembly-ish

00:14:20.306 --> 00:14:22.206 A:middle
optimizations, and I'm going to

00:14:22.206 --> 00:14:23.066 A:middle
tell you about the stuff that

00:14:23.066 --> 00:14:24.116 A:middle
happens when you use the

00:14:24.116 --> 00:14:25.286 A:middle
language itself, right, so the

00:14:25.346 --> 00:14:26.496 A:middle
constructs that you write your

00:14:26.496 --> 00:14:26.756 A:middle
code in.

00:14:26.756 --> 00:14:27.786 A:middle
I'm going to tell you about four

00:14:27.786 --> 00:14:28.906 A:middle
of those optimizations today

00:14:29.136 --> 00:14:30.626 A:middle
that also affect code size.

00:14:31.626 --> 00:14:33.446 A:middle
The first one is related to

00:14:33.446 --> 00:14:34.786 A:middle
objective C, when you use

00:14:34.786 --> 00:14:35.696 A:middle
blocks, right.

00:14:35.696 --> 00:14:36.826 A:middle
So blocks has a bunch of

00:14:36.826 --> 00:14:38.456 A:middle
associated metadata that the

00:14:38.456 --> 00:14:39.956 A:middle
compiler generates for you.

00:14:40.726 --> 00:14:43.016 A:middle
It has metadata as well as

00:14:43.016 --> 00:14:44.906 A:middle
helper functions, and we'll go

00:14:44.906 --> 00:14:46.266 A:middle
into a few examples to see what

00:14:46.266 --> 00:14:46.776 A:middle
that looks like.

00:14:47.436 --> 00:14:48.936 A:middle
So, say you write some code, and

00:14:49.096 --> 00:14:50.736 A:middle
it looks something like this.

00:14:51.306 --> 00:14:51.506 A:middle
Right.

00:14:52.036 --> 00:14:53.816 A:middle
So, you'll notice that I have

00:14:53.896 --> 00:14:55.226 A:middle
two blocks in two different

00:14:55.226 --> 00:14:56.546 A:middle
functions, and the code doesn't

00:14:56.546 --> 00:14:57.916 A:middle
really matter, but the important

00:14:57.916 --> 00:15:00.086 A:middle
bit to notice is that the blocks

00:14:57.916 --> 00:15:00.086 A:middle
bit to notice is that the blocks

00:15:00.086 --> 00:15:01.496 A:middle
do completely different things,

00:15:01.496 --> 00:15:01.586 A:middle
right.

00:15:01.586 --> 00:15:02.706 A:middle
The code has nothing to do with

00:15:02.706 --> 00:15:04.146 A:middle
each other, but they have fairly

00:15:04.146 --> 00:15:05.456 A:middle
similar struct in that the

00:15:05.546 --> 00:15:07.506 A:middle
capture for the blocks is

00:15:07.506 --> 00:15:07.886 A:middle
similar.

00:15:07.976 --> 00:15:09.696 A:middle
In this case, I capture two

00:15:09.766 --> 00:15:11.326 A:middle
arc-strong pointers.

00:15:12.196 --> 00:15:13.556 A:middle
Now, I told you that there is

00:15:13.556 --> 00:15:15.296 A:middle
metadata associated with each

00:15:15.336 --> 00:15:15.756 A:middle
block.

00:15:15.756 --> 00:15:16.596 A:middle
What does that look like?

00:15:17.146 --> 00:15:18.666 A:middle
Well, this is the metadata that

00:15:18.666 --> 00:15:19.856 A:middle
we're talking about, right.

00:15:19.856 --> 00:15:21.416 A:middle
So the compiler generates this

00:15:21.556 --> 00:15:22.846 A:middle
automatically for you when you

00:15:22.846 --> 00:15:24.746 A:middle
use blocks to track a bunch of

00:15:24.796 --> 00:15:26.076 A:middle
information about the blocks and

00:15:26.076 --> 00:15:27.246 A:middle
give them the behavior that the

00:15:27.246 --> 00:15:28.046 A:middle
language guarantees.

00:15:28.926 --> 00:15:29.846 A:middle
What you'll notice is there's a

00:15:29.846 --> 00:15:30.716 A:middle
block size in there.

00:15:30.996 --> 00:15:32.066 A:middle
There's a copy helper and a

00:15:32.066 --> 00:15:33.316 A:middle
destroy helper, which are two

00:15:33.316 --> 00:15:35.226 A:middle
methods that we'll go into in a

00:15:35.226 --> 00:15:36.616 A:middle
bit, and there's a block method

00:15:36.616 --> 00:15:37.826 A:middle
signature as well as the block

00:15:37.826 --> 00:15:38.566 A:middle
layout info.

00:15:38.566 --> 00:15:39.266 A:middle
All right.

00:15:39.616 --> 00:15:40.686 A:middle
And if you look at the example

00:15:40.686 --> 00:15:42.396 A:middle
that I have on the screen, this

00:15:42.396 --> 00:15:44.146 A:middle
is actually the synthesized code

00:15:44.146 --> 00:15:45.206 A:middle
that the compiler generates.

00:15:45.426 --> 00:15:46.766 A:middle
Now, that looks like a bunch of

00:15:46.766 --> 00:15:48.066 A:middle
gobbledygook, but what really

00:15:48.066 --> 00:15:50.116 A:middle
matters is that the struct

00:15:50.116 --> 00:15:51.856 A:middle
itself is the same, so we can

00:15:51.856 --> 00:15:53.326 A:middle
duplicate in a lot of cases.

00:15:53.646 --> 00:15:54.896 A:middle
Now, you'll notice in this case

00:15:54.896 --> 00:15:56.856 A:middle
we can't because despite

00:15:56.856 --> 00:15:58.746 A:middle
capturing two arc-strong

00:15:58.806 --> 00:16:00.206 A:middle
pointers, there's other captures

00:15:58.806 --> 00:16:00.206 A:middle
pointers, there's other captures

00:16:00.206 --> 00:16:01.836 A:middle
in there, and the block size

00:16:01.836 --> 00:16:02.686 A:middle
itself is different.

00:16:03.286 --> 00:16:03.506 A:middle
All right.

00:16:03.746 --> 00:16:05.556 A:middle
So, we can't merge these cases,

00:16:05.646 --> 00:16:05.766 A:middle
right.

00:16:05.766 --> 00:16:07.086 A:middle
But in general, there's some

00:16:07.086 --> 00:16:08.346 A:middle
cases where we can end up

00:16:08.346 --> 00:16:09.896 A:middle
merging these things, right.

00:16:10.256 --> 00:16:11.896 A:middle
You'll notice in this example

00:16:11.896 --> 00:16:14.856 A:middle
though, we have the functions,

00:16:14.856 --> 00:16:16.146 A:middle
right, so the copy helper and

00:16:16.146 --> 00:16:17.916 A:middle
destroy helper can be merged,

00:16:18.486 --> 00:16:18.936 A:middle
right.

00:16:19.046 --> 00:16:19.796 A:middle
And you'll notice that as of

00:16:19.796 --> 00:16:21.146 A:middle
Xcode 11, we do merge them,

00:16:21.356 --> 00:16:21.496 A:middle
right.

00:16:21.496 --> 00:16:22.306 A:middle
So, those are the same.

00:16:22.746 --> 00:16:23.626 A:middle
What does that mean?

00:16:23.626 --> 00:16:25.576 A:middle
Well, the copy helper is there

00:16:25.786 --> 00:16:26.676 A:middle
to help you when you move a

00:16:26.676 --> 00:16:28.316 A:middle
block around, right, and destroy

00:16:28.316 --> 00:16:29.866 A:middle
helper is there to help you when

00:16:29.866 --> 00:16:31.386 A:middle
the block goes away, right.

00:16:31.636 --> 00:16:32.956 A:middle
And the code that the compiler

00:16:32.956 --> 00:16:34.546 A:middle
synthesizes when you do this

00:16:35.086 --> 00:16:36.926 A:middle
looks about something like this.

00:16:38.016 --> 00:16:38.926 A:middle
All right, so in the example I

00:16:38.926 --> 00:16:40.366 A:middle
had, you'll remember I said we

00:16:40.366 --> 00:16:42.616 A:middle
have two strong arc pointers,

00:16:42.866 --> 00:16:43.776 A:middle
and the code we generate is

00:16:43.776 --> 00:16:44.776 A:middle
something like that, and we copy

00:16:44.776 --> 00:16:45.226 A:middle
it around.

00:16:45.226 --> 00:16:46.726 A:middle
You retain, and when you destroy

00:16:46.726 --> 00:16:47.556 A:middle
it, you release.

00:16:47.976 --> 00:16:49.236 A:middle
Now, there's a bunch of other

00:16:49.236 --> 00:16:51.086 A:middle
things that blocks end up having

00:16:51.086 --> 00:16:52.446 A:middle
to do when you copy or destroy.

00:16:52.716 --> 00:16:54.266 A:middle
You might have C++ objects, in

00:16:54.266 --> 00:16:55.396 A:middle
which case you have to color

00:16:55.396 --> 00:16:55.736 A:middle
copy constructor.

00:16:56.356 --> 00:16:57.906 A:middle
You might have-- and the

00:16:57.906 --> 00:16:58.896 A:middle
destructors, right.

00:16:58.896 --> 00:17:00.736 A:middle
You might have some weak arc

00:16:58.896 --> 00:17:00.736 A:middle
You might have some weak arc

00:17:00.786 --> 00:17:01.266 A:middle
pointers.

00:17:01.266 --> 00:17:03.056 A:middle
You might have nontrivial C

00:17:03.056 --> 00:17:04.266 A:middle
types or something like that,

00:17:04.376 --> 00:17:04.486 A:middle
right.

00:17:04.486 --> 00:17:05.156 A:middle
So, there's a bunch of other

00:17:05.156 --> 00:17:06.806 A:middle
stuff that needs to happen, but

00:17:06.806 --> 00:17:07.986 A:middle
basically you write code using

00:17:07.986 --> 00:17:09.445 A:middle
blocks, and when the compiler

00:17:09.445 --> 00:17:10.366 A:middle
detects that there is

00:17:10.366 --> 00:17:12.096 A:middle
redundancy, we try to eliminate

00:17:12.096 --> 00:17:13.195 A:middle
as much of it as we can.

00:17:13.695 --> 00:17:15.205 A:middle
Now, how much does this pay off?

00:17:15.205 --> 00:17:16.816 A:middle
We found that in objective C

00:17:16.816 --> 00:17:18.486 A:middle
applications, it's roughly a 2

00:17:18.486 --> 00:17:19.726 A:middle
to 7 percent code size

00:17:19.726 --> 00:17:21.486 A:middle
reduction, right, and that comes

00:17:21.486 --> 00:17:21.876 A:middle
for free.

00:17:22.066 --> 00:17:22.976 A:middle
It's just enabled by default.

00:17:23.516 --> 00:17:26.736 A:middle
[ Applause ]

00:17:27.236 --> 00:17:28.195 A:middle
The second optimization I'm

00:17:28.195 --> 00:17:29.456 A:middle
going to tell you about is

00:17:29.456 --> 00:17:31.226 A:middle
related to Instance Variables of

00:17:31.226 --> 00:17:33.436 A:middle
Direct Subclasses of NSObject.

00:17:33.796 --> 00:17:35.376 A:middle
Now, that's a mouthful, and I've

00:17:35.376 --> 00:17:36.376 A:middle
got to give you an example and

00:17:36.376 --> 00:17:37.266 A:middle
explain what that actually

00:17:37.266 --> 00:17:37.956 A:middle
means, all right.

00:17:38.266 --> 00:17:39.326 A:middle
So let's say I'm writing a card

00:17:39.326 --> 00:17:40.466 A:middle
game, and I write code that

00:17:40.466 --> 00:17:41.356 A:middle
looks something like this.

00:17:41.356 --> 00:17:42.876 A:middle
The key thing to remember here

00:17:42.876 --> 00:17:44.346 A:middle
is I'm deriving directly from

00:17:44.346 --> 00:17:45.386 A:middle
NSObject, right.

00:17:45.736 --> 00:17:47.266 A:middle
When I write the objective C

00:17:47.266 --> 00:17:49.836 A:middle
code, my properties corresponds

00:17:49.866 --> 00:17:51.756 A:middle
to instance variables, right.

00:17:51.756 --> 00:17:52.756 A:middle
So there's instance variables

00:17:52.756 --> 00:17:54.126 A:middle
generated automatically to back

00:17:54.126 --> 00:17:55.216 A:middle
up the properties that I have

00:17:55.216 --> 00:17:56.176 A:middle
here, right.

00:17:56.626 --> 00:17:58.276 A:middle
Now, the class itself that I

00:17:58.276 --> 00:18:00.286 A:middle
wrote, the compiler looks at it

00:17:58.276 --> 00:18:00.286 A:middle
wrote, the compiler looks at it

00:18:00.286 --> 00:18:01.666 A:middle
and generates a struct that

00:18:01.666 --> 00:18:03.096 A:middle
looks something like this

00:18:03.096 --> 00:18:03.716 A:middle
roughly, right.

00:18:03.846 --> 00:18:06.046 A:middle
It lays out the members, one

00:18:06.046 --> 00:18:06.616 A:middle
after the other.

00:18:06.926 --> 00:18:09.236 A:middle
Now, the thing in objective C is

00:18:09.236 --> 00:18:11.106 A:middle
that you can have a base class

00:18:11.236 --> 00:18:12.816 A:middle
derived from it and then change

00:18:12.816 --> 00:18:14.906 A:middle
the code in one framework to the

00:18:14.906 --> 00:18:17.036 A:middle
other, and the base class

00:18:17.096 --> 00:18:18.376 A:middle
changes, has new members and

00:18:18.376 --> 00:18:19.396 A:middle
whatever, and the derived

00:18:19.436 --> 00:18:20.926 A:middle
classes don't break, right.

00:18:20.926 --> 00:18:22.516 A:middle
And the objective, in C++ you

00:18:22.516 --> 00:18:23.246 A:middle
can't really do that.

00:18:23.246 --> 00:18:25.206 A:middle
If you derive, then the base

00:18:25.246 --> 00:18:26.486 A:middle
class's layout changes.

00:18:26.486 --> 00:18:27.226 A:middle
You have new sizes.

00:18:27.846 --> 00:18:29.166 A:middle
Now, here I'm deriving from

00:18:29.246 --> 00:18:29.796 A:middle
NSObject.

00:18:30.426 --> 00:18:32.696 A:middle
NSObject is effectively part of

00:18:32.696 --> 00:18:34.046 A:middle
the ABI of the platform.

00:18:34.156 --> 00:18:35.136 A:middle
So, we know it's not going to

00:18:35.136 --> 00:18:36.176 A:middle
change, right.

00:18:36.496 --> 00:18:38.546 A:middle
So, we have this layout of the

00:18:38.546 --> 00:18:39.986 A:middle
class, and when we're

00:18:40.046 --> 00:18:41.596 A:middle
implementing the class, right,

00:18:41.596 --> 00:18:43.306 A:middle
so implement this initWithName

00:18:43.306 --> 00:18:45.216 A:middle
method, I know exactly the

00:18:45.216 --> 00:18:46.496 A:middle
layout of everything in my

00:18:46.496 --> 00:18:47.416 A:middle
class, right.

00:18:47.666 --> 00:18:49.706 A:middle
So, the compiler, as of Xcode

00:18:49.896 --> 00:18:51.586 A:middle
11, can go in and say, I know

00:18:51.586 --> 00:18:52.386 A:middle
where the offsets are.

00:18:52.386 --> 00:18:53.226 A:middle
I can hardcode them.

00:18:53.726 --> 00:18:54.976 A:middle
Well, okay, what does that

00:18:54.976 --> 00:18:55.446 A:middle
actually mean?

00:18:55.846 --> 00:18:57.316 A:middle
So, I look at this initWithName

00:18:57.316 --> 00:18:57.626 A:middle
method.

00:18:59.086 --> 00:19:00.246 A:middle
It'll look something like this,

00:18:59.086 --> 00:19:00.246 A:middle
It'll look something like this,

00:19:00.596 --> 00:19:00.806 A:middle
right.

00:19:00.806 --> 00:19:02.816 A:middle
So, I have self.name = name.

00:19:02.996 --> 00:19:04.976 A:middle
Now, the setter, to generate a

00:19:04.976 --> 00:19:06.256 A:middle
code for that looks about

00:19:06.256 --> 00:19:07.856 A:middle
something like this before Xcode

00:19:07.856 --> 00:19:08.486 A:middle
11, right.

00:19:08.486 --> 00:19:10.536 A:middle
So, it synthesizes a lookup into

00:19:10.536 --> 00:19:12.296 A:middle
a table to know the offset of

00:19:12.296 --> 00:19:14.106 A:middle
the name property or the name

00:19:14.176 --> 00:19:14.826 A:middle
IVAR rather.

00:19:15.416 --> 00:19:16.836 A:middle
Now, that's a small amount of

00:19:16.836 --> 00:19:18.656 A:middle
code, but what we do as of Xcode

00:19:18.656 --> 00:19:19.706 A:middle
11 is something like this

00:19:19.706 --> 00:19:20.316 A:middle
instead, right.

00:19:20.316 --> 00:19:21.636 A:middle
So, we just hardcode the offset

00:19:21.636 --> 00:19:23.506 A:middle
when you're implementing the

00:19:23.506 --> 00:19:24.776 A:middle
method that's a direct

00:19:24.776 --> 00:19:25.936 A:middle
derivative of an S object.

00:19:26.426 --> 00:19:27.036 A:middle
That makes sense.

00:19:27.036 --> 00:19:28.056 A:middle
We know it's not going to change

00:19:28.056 --> 00:19:28.996 A:middle
because we're implementing the

00:19:28.996 --> 00:19:29.886 A:middle
thing that you just wrote.

00:19:30.146 --> 00:19:31.346 A:middle
And it seems pretty trivial;

00:19:31.346 --> 00:19:32.396 A:middle
it's just one instruction out of

00:19:32.396 --> 00:19:32.996 A:middle
three, right.

00:19:33.266 --> 00:19:34.506 A:middle
But it turns out to be roughly a

00:19:34.506 --> 00:19:35.466 A:middle
2 percent saving in

00:19:35.466 --> 00:19:36.146 A:middle
applications.

00:19:36.696 --> 00:19:38.416 A:middle
It's pretty s sweet.

00:19:38.466 --> 00:19:40.466 A:middle
[applause]

00:19:40.516 --> 00:19:41.796 A:middle
The next size optimization I'm

00:19:41.886 --> 00:19:43.356 A:middle
going to tell you about is

00:19:43.356 --> 00:19:45.146 A:middle
improved debuggability for C++

00:19:45.176 --> 00:19:45.516 A:middle
types.

00:19:45.516 --> 00:19:46.466 A:middle
Now, you're going to go, wait,

00:19:46.466 --> 00:19:47.666 A:middle
that's not size.

00:19:47.816 --> 00:19:48.096 A:middle
It is.

00:19:48.286 --> 00:19:49.436 A:middle
Just let me get to it.

00:19:49.856 --> 00:19:51.246 A:middle
So, I say I write some code.

00:19:51.876 --> 00:19:52.956 A:middle
Fairly straightforward code

00:19:52.956 --> 00:19:53.186 A:middle
here.

00:19:53.426 --> 00:19:54.556 A:middle
It's a command line application,

00:19:54.876 --> 00:19:57.336 A:middle
right, and what I'm doing is I'm

00:19:57.336 --> 00:19:58.596 A:middle
taking the parameters from a

00:19:58.596 --> 00:19:59.866 A:middle
command line as strings,

00:20:00.206 --> 00:20:02.156 A:middle
transforming them as integers,

00:20:02.206 --> 00:20:03.756 A:middle
putting them into a std::vector

00:20:03.866 --> 00:20:05.316 A:middle
and then printing them out one

00:20:05.316 --> 00:20:06.166 A:middle
after the other, right.

00:20:06.286 --> 00:20:07.196 A:middle
Really straightforward demo

00:20:07.196 --> 00:20:07.656 A:middle
application.

00:20:08.206 --> 00:20:10.556 A:middle
Now, what important here is I'm

00:20:10.556 --> 00:20:11.706 A:middle
using the standard library's

00:20:11.826 --> 00:20:12.256 A:middle
types.

00:20:12.576 --> 00:20:14.276 A:middle
Specifically I'm using vector

00:20:14.326 --> 00:20:15.546 A:middle
push back, and I want to go in

00:20:15.546 --> 00:20:16.886 A:middle
and put a breakpoint here.

00:20:17.396 --> 00:20:19.226 A:middle
Now, this used to not to work

00:20:19.226 --> 00:20:21.226 A:middle
really well before Xcode 11.

00:20:21.356 --> 00:20:22.666 A:middle
The reason was that we were

00:20:22.666 --> 00:20:25.246 A:middle
controlling the visibility of

00:20:25.356 --> 00:20:28.626 A:middle
lib C++'s methods just like push

00:20:28.656 --> 00:20:30.656 A:middle
back by force inlining them into

00:20:30.656 --> 00:20:31.636 A:middle
your code, right.

00:20:31.636 --> 00:20:32.606 A:middle
Now, generally that works pretty

00:20:32.606 --> 00:20:32.766 A:middle
well.

00:20:32.766 --> 00:20:34.106 A:middle
The problem is push back is

00:20:34.106 --> 00:20:35.346 A:middle
giant, and then the optimizer

00:20:35.346 --> 00:20:36.906 A:middle
goes to town, moves around,

00:20:36.906 --> 00:20:38.106 A:middle
deletes some code, and the

00:20:38.106 --> 00:20:39.776 A:middle
debugger, when you tell it break

00:20:39.776 --> 00:20:40.796 A:middle
on push back, you're not trying

00:20:40.796 --> 00:20:42.106 A:middle
to step into push back, you just

00:20:42.106 --> 00:20:43.016 A:middle
want to put a breakpoint on that

00:20:43.016 --> 00:20:43.276 A:middle
line.

00:20:43.276 --> 00:20:44.466 A:middle
The debugger doesn't really know

00:20:44.466 --> 00:20:45.416 A:middle
where push back is because it's

00:20:45.466 --> 00:20:46.656 A:middle
been splat all over the place,

00:20:46.986 --> 00:20:47.166 A:middle
right.

00:20:47.506 --> 00:20:50.536 A:middle
So, what we do as of Xcode 11 is

00:20:50.536 --> 00:20:52.046 A:middle
that we don't force inlining.

00:20:52.046 --> 00:20:53.916 A:middle
We let the inliner decide when

00:20:53.916 --> 00:20:55.036 A:middle
inlining should happen instead,

00:20:55.386 --> 00:20:55.496 A:middle
right.

00:20:55.496 --> 00:20:56.946 A:middle
So, what used to happen in this

00:20:56.946 --> 00:20:58.476 A:middle
specific example, before Xcode

00:20:58.476 --> 00:21:00.286 A:middle
11 is the breakpoint that you

00:20:58.476 --> 00:21:00.286 A:middle
11 is the breakpoint that you

00:21:00.286 --> 00:21:01.516 A:middle
put there would actually break

00:21:01.516 --> 00:21:02.856 A:middle
on the second loop, right,

00:21:02.856 --> 00:21:04.486 A:middle
because the pushbacks are just

00:21:04.486 --> 00:21:04.946 A:middle
everywhere now.

00:21:05.226 --> 00:21:07.056 A:middle
So, as of Xcode 11, we don't

00:21:07.056 --> 00:21:08.536 A:middle
force inlining, and this is what

00:21:08.536 --> 00:21:09.676 A:middle
the debugging session would look

00:21:09.676 --> 00:21:09.866 A:middle
like.

00:21:10.076 --> 00:21:12.026 A:middle
So, say I run lldb, I run my

00:21:12.026 --> 00:21:13.146 A:middle
program, and I say put a

00:21:13.146 --> 00:21:14.546 A:middle
breakpoint on line 12.

00:21:15.326 --> 00:21:15.506 A:middle
Right.

00:21:15.616 --> 00:21:16.526 A:middle
Pretty straightforward.

00:21:17.256 --> 00:21:18.426 A:middle
Bugger goes in, says yep,

00:21:18.606 --> 00:21:19.216 A:middle
breakpoint, got it.

00:21:19.716 --> 00:21:21.366 A:middle
Now, I hit run.

00:21:21.366 --> 00:21:22.176 A:middle
This is what happens now.

00:21:22.176 --> 00:21:23.606 A:middle
All right.

00:21:23.826 --> 00:21:25.976 A:middle
So, I break on line 12.

00:21:26.166 --> 00:21:26.376 A:middle
Cool.

00:21:26.376 --> 00:21:27.386 A:middle
It just works, right.

00:21:27.386 --> 00:21:28.376 A:middle
It's kind of a boring demo

00:21:28.506 --> 00:21:31.276 A:middle
because it does what you expect.

00:21:31.276 --> 00:21:31.846 A:middle
It used not to.

00:21:32.126 --> 00:21:34.206 A:middle
So, the cool thing now is I'm

00:21:34.206 --> 00:21:34.946 A:middle
talking about code size

00:21:34.946 --> 00:21:35.726 A:middle
optimizations, right.

00:21:35.726 --> 00:21:37.156 A:middle
Well, this, because we don't

00:21:37.156 --> 00:21:38.356 A:middle
force inline really big things,

00:21:38.406 --> 00:21:40.086 A:middle
if you use the stl a lot in your

00:21:40.086 --> 00:21:42.336 A:middle
code, you create quite a big

00:21:42.336 --> 00:21:43.206 A:middle
amount of code bloat.

00:21:43.646 --> 00:21:44.856 A:middle
And so what we've measured is on

00:21:44.906 --> 00:21:47.046 A:middle
big applications release mode up

00:21:47.046 --> 00:21:48.386 A:middle
to a 7 percent code size

00:21:48.386 --> 00:21:49.526 A:middle
reduction when you do this.

00:21:49.636 --> 00:21:51.036 A:middle
Now, again, this is in release

00:21:51.036 --> 00:21:51.746 A:middle
mode, right.

00:21:52.066 --> 00:21:53.166 A:middle
So, that's a pretty good amount

00:21:53.166 --> 00:21:55.206 A:middle
of code savings and better

00:21:55.206 --> 00:21:55.606 A:middle
debugging.

00:21:55.966 --> 00:21:56.456 A:middle
That's nice.

00:21:56.806 --> 00:21:58.746 A:middle
The last code size saving I want

00:21:58.746 --> 00:22:00.556 A:middle
to tell you about is C++ static

00:21:58.746 --> 00:22:00.556 A:middle
to tell you about is C++ static

00:22:00.596 --> 00:22:01.546 A:middle
destructor suppression.

00:22:02.456 --> 00:22:04.346 A:middle
And again, let me walk through

00:22:04.346 --> 00:22:05.466 A:middle
an example to show you what I

00:22:05.466 --> 00:22:06.096 A:middle
actually mean here.

00:22:06.976 --> 00:22:08.686 A:middle
So, say I write some really

00:22:08.686 --> 00:22:09.666 A:middle
generic C++ code.

00:22:09.666 --> 00:22:11.266 A:middle
Most applications end up having

00:22:11.266 --> 00:22:12.716 A:middle
a logger, something like this,

00:22:12.766 --> 00:22:12.976 A:middle
right.

00:22:13.266 --> 00:22:14.356 A:middle
And when you do logging, you

00:22:14.356 --> 00:22:15.486 A:middle
don't want to pass a logger

00:22:15.486 --> 00:22:16.026 A:middle
around throughout your

00:22:16.026 --> 00:22:17.256 A:middle
application, so you have just a

00:22:17.256 --> 00:22:18.466 A:middle
global variable called logger.

00:22:18.856 --> 00:22:20.476 A:middle
Fairly straightforward stuff.

00:22:20.596 --> 00:22:21.596 A:middle
Now in C++ when you have a

00:22:21.596 --> 00:22:22.986 A:middle
global like this, it'll have a

00:22:22.986 --> 00:22:24.426 A:middle
destructor that'll run at the

00:22:24.426 --> 00:22:25.536 A:middle
end of the application's

00:22:25.536 --> 00:22:26.016 A:middle
lifetime.

00:22:26.566 --> 00:22:26.756 A:middle
Right.

00:22:27.106 --> 00:22:28.146 A:middle
And you'll notice, the logger

00:22:28.146 --> 00:22:29.126 A:middle
contains a buffer that's a

00:22:29.126 --> 00:22:30.466 A:middle
std::vector of string, so that's

00:22:30.466 --> 00:22:32.206 A:middle
what the destructor is going to

00:22:32.206 --> 00:22:32.346 A:middle
do.

00:22:32.346 --> 00:22:33.206 A:middle
It's going to destroy that

00:22:33.206 --> 00:22:34.516 A:middle
vector of strings, right.

00:22:34.786 --> 00:22:35.826 A:middle
Straightforward thing so far.

00:22:36.256 --> 00:22:37.526 A:middle
Now, I go into my application,

00:22:37.886 --> 00:22:38.896 A:middle
and it's a game.

00:22:39.366 --> 00:22:39.556 A:middle
Right.

00:22:39.556 --> 00:22:40.666 A:middle
So I add this code here.

00:22:40.666 --> 00:22:41.286 A:middle
It's just a game.

00:22:41.416 --> 00:22:42.866 A:middle
So, again, I just have one

00:22:42.866 --> 00:22:44.636 A:middle
application and one game, and so

00:22:44.636 --> 00:22:46.376 A:middle
I just have a global here for my

00:22:46.376 --> 00:22:46.626 A:middle
game.

00:22:47.126 --> 00:22:48.716 A:middle
Totally sensible code, right.

00:22:49.246 --> 00:22:51.996 A:middle
Now, the problem is if I go in

00:22:51.996 --> 00:22:53.956 A:middle
and I add some logging code to

00:22:53.956 --> 00:22:56.086 A:middle
the struct of the game, well,

00:22:56.086 --> 00:22:57.996 A:middle
you'll notice, I have the logger

00:22:57.996 --> 00:22:58.626 A:middle
that's global.

00:22:58.626 --> 00:22:59.646 A:middle
I have the game that's global.

00:23:00.056 --> 00:23:01.386 A:middle
That might not work out so well.

00:23:01.576 --> 00:23:03.376 A:middle
The reason is in C++, between

00:23:03.376 --> 00:23:05.196 A:middle
different translation units, the

00:23:05.196 --> 00:23:06.586 A:middle
order in which the destructors

00:23:06.706 --> 00:23:08.336 A:middle
are called is not guaranteed,

00:23:08.466 --> 00:23:08.606 A:middle
right.

00:23:08.606 --> 00:23:09.776 A:middle
In a lot of cases, you'll

00:23:09.776 --> 00:23:11.216 A:middle
destroy the logger before you

00:23:11.216 --> 00:23:11.826 A:middle
destroy the game.

00:23:11.826 --> 00:23:13.126 A:middle
What's going to happen, this is

00:23:13.126 --> 00:23:15.276 A:middle
going to crash, not good, right.

00:23:15.656 --> 00:23:16.876 A:middle
So, that's kind of a headache

00:23:16.876 --> 00:23:17.336 A:middle
right here.

00:23:17.336 --> 00:23:19.066 A:middle
And then dig a bit more into how

00:23:19.066 --> 00:23:21.366 A:middle
C++ works, and this is my mental

00:23:21.366 --> 00:23:23.236 A:middle
view of what that is, right.

00:23:23.546 --> 00:23:25.246 A:middle
So, you start adding thread

00:23:25.246 --> 00:23:26.056 A:middle
local storage.

00:23:26.056 --> 00:23:27.056 A:middle
You start adding threads.

00:23:27.326 --> 00:23:29.336 A:middle
There's like the graph for C++

00:23:29.336 --> 00:23:30.986 A:middle
destructor ordering is really

00:23:30.986 --> 00:23:31.746 A:middle
complicated, and it's

00:23:31.746 --> 00:23:33.036 A:middle
complicated enough that even

00:23:33.036 --> 00:23:34.136 A:middle
like compiler people who are

00:23:34.136 --> 00:23:35.126 A:middle
supposed to know how that works,

00:23:35.666 --> 00:23:36.336 A:middle
we have no idea.

00:23:36.336 --> 00:23:37.526 A:middle
I had to fix a bug a few months

00:23:37.526 --> 00:23:39.186 A:middle
ago in Clang where Clang would

00:23:39.186 --> 00:23:41.266 A:middle
in really rare cases crash upon

00:23:41.266 --> 00:23:42.546 A:middle
termination when trying to clean

00:23:42.546 --> 00:23:43.586 A:middle
itself up, right.

00:23:43.586 --> 00:23:44.766 A:middle
That's kind of embarrassing, but

00:23:44.766 --> 00:23:46.226 A:middle
it's just to show like it's not

00:23:46.226 --> 00:23:47.786 A:middle
like a trivial thing to get

00:23:47.786 --> 00:23:48.676 A:middle
destruction order correct.

00:23:48.676 --> 00:23:49.936 A:middle
All right.

00:23:50.206 --> 00:23:51.346 A:middle
And let's go a bit further.

00:23:51.346 --> 00:23:52.926 A:middle
On iOS, this is what the

00:23:52.926 --> 00:23:54.096 A:middle
lifecycle in an application

00:23:54.096 --> 00:23:54.446 A:middle
looks like.

00:23:54.446 --> 00:23:54.546 A:middle
Right.

00:23:54.766 --> 00:23:56.146 A:middle
There's not really a logical

00:23:56.206 --> 00:23:57.776 A:middle
time for the application to shut

00:23:57.846 --> 00:23:58.116 A:middle
down.

00:23:58.246 --> 00:23:59.226 A:middle
There's times when it goes to

00:23:59.286 --> 00:24:00.286 A:middle
foreground, it goes to

00:23:59.286 --> 00:24:00.286 A:middle
foreground, it goes to

00:24:00.286 --> 00:24:01.726 A:middle
background, and it goes away,

00:24:01.936 --> 00:24:03.706 A:middle
but like destruction, like the

00:24:03.706 --> 00:24:05.056 A:middle
application shutting down is not

00:24:05.056 --> 00:24:06.726 A:middle
really a thing that makes sense

00:24:06.796 --> 00:24:08.066 A:middle
with that type of lifecycle.

00:24:08.546 --> 00:24:09.976 A:middle
What you end up having is you

00:24:09.976 --> 00:24:11.776 A:middle
implement callbacks, something

00:24:11.776 --> 00:24:13.176 A:middle
like this, right, and then

00:24:13.176 --> 00:24:14.026 A:middle
you're told you're going to go

00:24:14.026 --> 00:24:14.776 A:middle
like in the background, you're

00:24:14.776 --> 00:24:15.516 A:middle
going to come back, something

00:24:15.516 --> 00:24:15.806 A:middle
like that.

00:24:16.076 --> 00:24:17.376 A:middle
Destructors don't really run in

00:24:17.376 --> 00:24:18.456 A:middle
a logical place.

00:24:19.086 --> 00:24:20.456 A:middle
So, if we go back to the code we

00:24:20.456 --> 00:24:21.156 A:middle
had earlier, right.

00:24:21.156 --> 00:24:21.906 A:middle
It's an application.

00:24:22.146 --> 00:24:22.856 A:middle
It has a logger.

00:24:23.326 --> 00:24:25.026 A:middle
This is what we wrote, well

00:24:25.706 --> 00:24:26.886 A:middle
there's not really a logical

00:24:26.886 --> 00:24:28.666 A:middle
time for this logger to flush

00:24:28.666 --> 00:24:29.676 A:middle
its buffer, right.

00:24:30.006 --> 00:24:32.596 A:middle
But the, like in the destructor.

00:24:32.696 --> 00:24:33.906 A:middle
What you really want to do is

00:24:33.906 --> 00:24:34.676 A:middle
say well, if you're going to go

00:24:34.676 --> 00:24:35.816 A:middle
in the background, please flush

00:24:35.816 --> 00:24:36.956 A:middle
the buffer first, right.

00:24:37.076 --> 00:24:38.466 A:middle
So you don't have any cleanup to

00:24:38.466 --> 00:24:39.466 A:middle
do in the destructor.

00:24:39.716 --> 00:24:40.766 A:middle
It's kind of silly to have a

00:24:40.766 --> 00:24:41.326 A:middle
destructor.

00:24:41.466 --> 00:24:42.306 A:middle
There's a bunch of code that

00:24:42.306 --> 00:24:43.406 A:middle
gets generated for nothing,

00:24:43.816 --> 00:24:43.986 A:middle
right.

00:24:44.206 --> 00:24:45.836 A:middle
So, we added, as of Xcode 11 is

00:24:45.836 --> 00:24:46.986 A:middle
an attribute that allows you to

00:24:46.986 --> 00:24:48.336 A:middle
say, hey, don't destroy this

00:24:48.336 --> 00:24:48.906 A:middle
thing, right.

00:24:48.966 --> 00:24:49.606 A:middle
It's global.

00:24:49.726 --> 00:24:50.346 A:middle
It doesn't need to have a

00:24:50.346 --> 00:24:50.806 A:middle
destructor.

00:24:51.506 --> 00:24:53.116 A:middle
Of course, you're still going to

00:24:53.116 --> 00:24:54.826 A:middle
flush manually when a callback

00:24:54.826 --> 00:24:55.916 A:middle
happens, and you can go into

00:24:55.916 --> 00:24:58.046 A:middle
your entire application in Xcode

00:24:58.046 --> 00:24:59.626 A:middle
and use the setting to do that

00:24:59.626 --> 00:25:01.006 A:middle
for the entire application.

00:24:59.626 --> 00:25:01.006 A:middle
for the entire application.

00:25:01.366 --> 00:25:02.756 A:middle
It seems pretty trivial, but it

00:25:02.756 --> 00:25:03.816 A:middle
gives you, depending on how much

00:25:03.816 --> 00:25:05.216 A:middle
C++ you use in your code, maybe

00:25:05.216 --> 00:25:06.356 A:middle
like a 1 percent code size

00:25:06.356 --> 00:25:07.316 A:middle
reduction, right, which is

00:25:07.356 --> 00:25:08.386 A:middle
pretty nice.

00:25:08.516 --> 00:25:10.626 A:middle
So, let's move on from code size

00:25:10.626 --> 00:25:11.836 A:middle
reduction and talk about

00:25:11.896 --> 00:25:13.616 A:middle
diagnostics instead, right.

00:25:13.616 --> 00:25:15.266 A:middle
So, I'm going to tell you about

00:25:15.266 --> 00:25:16.986 A:middle
five diagnostics that are all on

00:25:16.986 --> 00:25:19.176 A:middle
by default in Xcode 11.

00:25:19.666 --> 00:25:21.386 A:middle
The first one is

00:25:21.476 --> 00:25:23.276 A:middle
call-to-pure-virtual function

00:25:23.376 --> 00:25:24.786 A:middle
from a constructor or a

00:25:24.786 --> 00:25:25.266 A:middle
destructor.

00:25:25.666 --> 00:25:26.806 A:middle
What does that mean?

00:25:26.806 --> 00:25:27.556 A:middle
So let's write some good

00:25:27.556 --> 00:25:29.146 A:middle
object-oriented code starting

00:25:29.146 --> 00:25:29.656 A:middle
with a table.

00:25:29.656 --> 00:25:30.456 A:middle
All right.

00:25:30.636 --> 00:25:32.126 A:middle
So, I have this table here, and

00:25:32.126 --> 00:25:33.376 A:middle
I go and I want to have a pure

00:25:33.376 --> 00:25:34.586 A:middle
virtual function to illustrate

00:25:34.586 --> 00:25:35.246 A:middle
what I'm talking about.

00:25:35.246 --> 00:25:36.596 A:middle
So, I'm going to go and write

00:25:36.596 --> 00:25:38.216 A:middle
this galahad function that's

00:25:38.256 --> 00:25:39.946 A:middle
pure virtual, and I'm going to

00:25:39.946 --> 00:25:41.336 A:middle
have a destructor for the table,

00:25:41.336 --> 00:25:42.066 A:middle
and when the table gets

00:25:42.066 --> 00:25:42.726 A:middle
destroyed, I'm going to say,

00:25:42.726 --> 00:25:43.836 A:middle
galahad, please go and find the

00:25:43.836 --> 00:25:44.756 A:middle
grip, right.

00:25:45.186 --> 00:25:46.036 A:middle
It makes a lot of sense.

00:25:46.106 --> 00:25:48.116 A:middle
So, I do that, and I get a

00:25:48.156 --> 00:25:48.406 A:middle
warning.

00:25:48.916 --> 00:25:49.966 A:middle
The reason you get this new

00:25:49.966 --> 00:25:51.736 A:middle
warning as of Xcode 11 is

00:25:51.736 --> 00:25:53.336 A:middle
because calling a pure virtual

00:25:53.336 --> 00:25:54.566 A:middle
function from a constructor or a

00:25:54.566 --> 00:25:56.026 A:middle
destructor really doesn't make

00:25:56.026 --> 00:25:56.336 A:middle
sense.

00:25:56.336 --> 00:25:57.416 A:middle
There's nothing to call.

00:25:57.766 --> 00:25:59.716 A:middle
Because the table is the base

00:25:59.716 --> 00:26:01.046 A:middle
class, and the most derived

00:25:59.716 --> 00:26:01.046 A:middle
class, and the most derived

00:26:01.206 --> 00:26:02.316 A:middle
classes have already been

00:26:02.316 --> 00:26:04.236 A:middle
destroyed in this case, right.

00:26:04.236 --> 00:26:05.996 A:middle
So there's no implementation of

00:26:05.996 --> 00:26:07.586 A:middle
this galahad function to call

00:26:07.886 --> 00:26:08.296 A:middle
anymore.

00:26:08.986 --> 00:26:10.286 A:middle
So, how would you fix this?

00:26:10.286 --> 00:26:11.496 A:middle
Well, you could go, and in the

00:26:11.496 --> 00:26:12.596 A:middle
derived class that implements

00:26:12.596 --> 00:26:14.206 A:middle
galahad, its destructor could

00:26:14.266 --> 00:26:17.156 A:middle
call find galahad and return a

00:26:17.156 --> 00:26:18.506 A:middle
grail or something like that.

00:26:18.616 --> 00:26:19.996 A:middle
So that makes some sense.

00:26:20.586 --> 00:26:20.966 A:middle
All right.

00:26:21.236 --> 00:26:22.036 A:middle
Let's move onto another

00:26:22.036 --> 00:26:22.656 A:middle
diagnostic.

00:26:24.276 --> 00:26:25.416 A:middle
Memset with transposed

00:26:25.416 --> 00:26:26.026 A:middle
arguments.

00:26:26.526 --> 00:26:27.876 A:middle
So, say I have this struct

00:26:27.876 --> 00:26:30.146 A:middle
called inbox, right, and I have

00:26:30.146 --> 00:26:31.116 A:middle
a bunch of emails in it.

00:26:31.236 --> 00:26:32.556 A:middle
I come back from vacation, and

00:26:32.556 --> 00:26:33.666 A:middle
I'll get to inbox 0.

00:26:33.836 --> 00:26:34.566 A:middle
What do I do?

00:26:34.566 --> 00:26:35.696 A:middle
Well, I just memset the whole

00:26:35.696 --> 00:26:36.406 A:middle
inbox to 0.

00:26:36.746 --> 00:26:37.786 A:middle
Now, I wrote this code.

00:26:37.786 --> 00:26:39.136 A:middle
Who can spot the bug?

00:26:40.226 --> 00:26:40.376 A:middle
Right.

00:26:40.376 --> 00:26:41.806 A:middle
I've transposed the argument to

00:26:41.806 --> 00:26:42.336 A:middle
memset.

00:26:42.626 --> 00:26:44.106 A:middle
Like, I make that mistake

00:26:44.106 --> 00:26:45.236 A:middle
semi-frequently because I have

00:26:45.236 --> 00:26:46.616 A:middle
no idea what the order of

00:26:46.616 --> 00:26:47.806 A:middle
argument to memset is.

00:26:47.806 --> 00:26:49.616 A:middle
Whether the value I'm trying to

00:26:49.616 --> 00:26:52.096 A:middle
set destruct to is the first

00:26:52.096 --> 00:26:53.536 A:middle
argument or whether it's the

00:26:53.536 --> 00:26:54.526 A:middle
second one, right.

00:26:54.836 --> 00:26:55.996 A:middle
Whether it's the size that I'm

00:26:55.996 --> 00:26:56.636 A:middle
trying to set it to.

00:26:56.636 --> 00:26:58.176 A:middle
And so we now detect that as

00:26:58.176 --> 00:26:59.296 A:middle
Xcode 11, and we tell you about

00:26:59.296 --> 00:26:59.396 A:middle
it.

00:26:59.696 --> 00:27:00.366 A:middle
How do you fix it?

00:26:59.696 --> 00:27:00.366 A:middle
How do you fix it?

00:27:00.366 --> 00:27:01.236 A:middle
It's pretty simple; you just

00:27:01.316 --> 00:27:02.116 A:middle
flip the arguments around,

00:27:02.786 --> 00:27:02.966 A:middle
right.

00:27:03.476 --> 00:27:04.746 A:middle
Now, one thing you might want to

00:27:04.746 --> 00:27:06.166 A:middle
consider here is instead of

00:27:06.166 --> 00:27:07.446 A:middle
using memset, which is hard to

00:27:07.446 --> 00:27:08.736 A:middle
get, and even like look at that

00:27:08.736 --> 00:27:09.696 A:middle
code, it's still not obvious

00:27:09.696 --> 00:27:10.886 A:middle
that it's correct, right.

00:27:11.256 --> 00:27:12.016 A:middle
What you might want to do

00:27:12.016 --> 00:27:13.196 A:middle
instead is use something like

00:27:13.196 --> 00:27:13.696 A:middle
std::fill.

00:27:13.696 --> 00:27:15.006 A:middle
In some cases it makes sense.

00:27:15.356 --> 00:27:16.256 A:middle
You rewrite the code to look

00:27:16.256 --> 00:27:18.306 A:middle
something like that, and now

00:27:18.306 --> 00:27:19.306 A:middle
it's much harder to get wrong,

00:27:19.306 --> 00:27:20.996 A:middle
and it's easier to get what it's

00:27:21.046 --> 00:27:21.296 A:middle
doing.

00:27:21.686 --> 00:27:21.886 A:middle
Right.

00:27:21.886 --> 00:27:22.466 A:middle
So, that's kind of neat.

00:27:23.266 --> 00:27:24.806 A:middle
The third warning I want to tell

00:27:24.806 --> 00:27:27.536 A:middle
you about, return of std move.

00:27:27.666 --> 00:27:29.356 A:middle
So, move is a bit complicated in

00:27:29.356 --> 00:27:30.766 A:middle
C++, but there's a bunch of

00:27:30.766 --> 00:27:32.406 A:middle
diagnostics over time that help

00:27:32.406 --> 00:27:33.686 A:middle
you really use it the proper

00:27:33.686 --> 00:27:34.496 A:middle
way, right.

00:27:34.856 --> 00:27:35.686 A:middle
So, again, let's write an

00:27:35.686 --> 00:27:37.196 A:middle
object-oriented code to

00:27:37.196 --> 00:27:38.136 A:middle
understand what I'm talking

00:27:38.136 --> 00:27:38.516 A:middle
about here.

00:27:38.676 --> 00:27:40.626 A:middle
So, say I have three structs,

00:27:40.626 --> 00:27:42.636 A:middle
lion, goat, and snake, and love

00:27:42.636 --> 00:27:43.586 A:middle
object orientation, I'm going to

00:27:43.586 --> 00:27:44.696 A:middle
compose them into a chimara,

00:27:45.206 --> 00:27:45.376 A:middle
right.

00:27:45.886 --> 00:27:46.386 A:middle
Good code.

00:27:46.876 --> 00:27:49.356 A:middle
So, I go in and assign

00:27:49.516 --> 00:27:50.536 A:middle
bellerophon and I want to go

00:27:50.536 --> 00:27:51.746 A:middle
slay the chimara, and then

00:27:51.746 --> 00:27:52.986 A:middle
return with proof that I've

00:27:52.986 --> 00:27:53.376 A:middle
slain it.

00:27:53.676 --> 00:27:55.096 A:middle
Well, I now have a diagnostic

00:27:55.096 --> 00:27:56.146 A:middle
that tells me, hey, you know

00:27:56.146 --> 00:27:56.496 A:middle
what?

00:27:56.706 --> 00:27:58.366 A:middle
Like you're returning a chimara,

00:27:58.706 --> 00:28:00.556 A:middle
but you're just, like the return

00:27:58.706 --> 00:28:00.556 A:middle
but you're just, like the return

00:28:00.636 --> 00:28:01.536 A:middle
type that you're returning is

00:28:01.536 --> 00:28:02.936 A:middle
actually just a goat, right.

00:28:02.936 --> 00:28:03.916 A:middle
So, I'm going to take that

00:28:03.916 --> 00:28:05.196 A:middle
vector, copy it over, because it

00:28:05.196 --> 00:28:06.606 A:middle
doesn't make sense to slice out

00:28:06.656 --> 00:28:08.186 A:middle
the vector out of the chimara

00:28:08.186 --> 00:28:10.086 A:middle
and put it into a goat instead.

00:28:10.316 --> 00:28:12.676 A:middle
Right. So, what you're doing

00:28:12.676 --> 00:28:13.956 A:middle
here, the code you wrote is

00:28:13.956 --> 00:28:14.726 A:middle
basically what you've been

00:28:14.726 --> 00:28:15.916 A:middle
trained to do related to

00:28:15.916 --> 00:28:16.586 A:middle
std::move.

00:28:16.786 --> 00:28:18.576 A:middle
You're trained to rely on

00:28:18.576 --> 00:28:19.236 A:middle
copy elision, right.

00:28:19.446 --> 00:28:21.496 A:middle
And most times, you don't need

00:28:21.496 --> 00:28:22.586 A:middle
to put a std::move when you do

00:28:22.586 --> 00:28:22.946 A:middle
return.

00:28:22.946 --> 00:28:24.516 A:middle
In this case you do because it

00:28:24.516 --> 00:28:25.416 A:middle
does a copy, right.

00:28:25.416 --> 00:28:26.596 A:middle
The language says returning,

00:28:26.596 --> 00:28:27.866 A:middle
just slicing out a part of the

00:28:27.866 --> 00:28:29.416 A:middle
class is kind of weird anyways.

00:28:29.666 --> 00:28:31.026 A:middle
Move shouldn't be implicit,

00:28:31.596 --> 00:28:31.806 A:middle
right.

00:28:31.806 --> 00:28:32.966 A:middle
So the warning tells that you

00:28:33.016 --> 00:28:34.606 A:middle
probably don't want to do this,

00:28:34.886 --> 00:28:35.076 A:middle
right.

00:28:35.356 --> 00:28:36.956 A:middle
So, first way to fix it, you go

00:28:36.956 --> 00:28:38.106 A:middle
in, you call std::move.

00:28:39.596 --> 00:28:39.956 A:middle
Right.

00:28:39.956 --> 00:28:41.806 A:middle
Now, that will move the vector

00:28:41.806 --> 00:28:43.186 A:middle
into the goat, right.

00:28:43.186 --> 00:28:44.646 A:middle
So it's much more efficient to

00:28:44.646 --> 00:28:45.476 A:middle
do the move this way.

00:28:46.096 --> 00:28:47.816 A:middle
So, another thing you might want

00:28:47.816 --> 00:28:49.136 A:middle
to do is well instead of

00:28:49.136 --> 00:28:50.426 A:middle
returning just the goat and

00:28:50.426 --> 00:28:51.716 A:middle
having like people trust you

00:28:51.716 --> 00:28:52.666 A:middle
that that's actually a chimara,

00:28:52.896 --> 00:28:53.796 A:middle
well you can just return a

00:28:53.796 --> 00:28:54.116 A:middle
chimara.

00:28:54.116 --> 00:28:55.256 A:middle
That makes sense, and here you

00:28:55.256 --> 00:28:55.986 A:middle
get copy elision, right.

00:28:56.316 --> 00:28:57.826 A:middle
If you were to add std::move,

00:28:57.826 --> 00:28:58.836 A:middle
the compiler would tell you that

00:28:58.836 --> 00:29:00.036 A:middle
you're pessimizing things by

00:28:58.836 --> 00:29:00.036 A:middle
you're pessimizing things by

00:29:00.036 --> 00:29:00.736 A:middle
adding the move.

00:29:01.446 --> 00:29:02.276 A:middle
Another thing you might want to

00:29:02.276 --> 00:29:03.166 A:middle
do because you're not sure if

00:29:03.166 --> 00:29:04.416 A:middle
you're going to get a chimara or

00:29:04.416 --> 00:29:05.766 A:middle
not is you might want to return

00:29:05.766 --> 00:29:06.876 A:middle
a std::optional with chimara,

00:29:06.876 --> 00:29:07.836 A:middle
which again does the right

00:29:07.836 --> 00:29:08.026 A:middle
thing.

00:29:08.026 --> 00:29:09.586 A:middle
It's not slicing things out of

00:29:09.586 --> 00:29:10.616 A:middle
the class and so the language

00:29:10.616 --> 00:29:12.446 A:middle
says, yes, this gets implicit

00:29:13.416 --> 00:29:13.666 A:middle
copy elision.

00:29:13.666 --> 00:29:13.886 A:middle
All right.

00:29:14.186 --> 00:29:15.216 A:middle
Another diagnostic I want to

00:29:15.216 --> 00:29:16.026 A:middle
tell you about,

00:29:16.026 --> 00:29:17.176 A:middle
size-of-pointer-div.

00:29:17.876 --> 00:29:18.616 A:middle
What does this look like?

00:29:18.616 --> 00:29:20.126 A:middle
Well, say I write this code.

00:29:20.716 --> 00:29:21.676 A:middle
Totally fine code.

00:29:21.916 --> 00:29:23.736 A:middle
No problem right now, right.

00:29:23.956 --> 00:29:24.886 A:middle
So, what I'm saying is I have

00:29:24.886 --> 00:29:25.426 A:middle
this array.

00:29:25.936 --> 00:29:27.546 A:middle
Take the size of the array

00:29:27.546 --> 00:29:29.286 A:middle
divided by the 0th element, and

00:29:29.286 --> 00:29:30.276 A:middle
that gives you the number of

00:29:30.276 --> 00:29:31.416 A:middle
elements inside the array.

00:29:31.816 --> 00:29:33.236 A:middle
That's really standard code for

00:29:33.236 --> 00:29:36.166 A:middle
C style code, right, a really

00:29:36.166 --> 00:29:36.876 A:middle
common idiom.

00:29:36.876 --> 00:29:38.716 A:middle
So, the problem here is if I

00:29:38.716 --> 00:29:40.876 A:middle
refactor this code and I do

00:29:40.876 --> 00:29:41.606 A:middle
something like this.

00:29:41.606 --> 00:29:42.976 A:middle
So, I pass the array as a

00:29:42.976 --> 00:29:44.036 A:middle
parameter instead.

00:29:44.596 --> 00:29:46.276 A:middle
Well, what happens here is that

00:29:46.356 --> 00:29:48.366 A:middle
the C rules say that the array

00:29:48.366 --> 00:29:49.596 A:middle
now decays to a pointer.

00:29:49.596 --> 00:29:51.296 A:middle
And the new diagnostic tells

00:29:51.296 --> 00:29:52.456 A:middle
you, hey, this probably doesn't

00:29:52.456 --> 00:29:53.436 A:middle
do what you want, right.

00:29:53.436 --> 00:29:54.826 A:middle
This won't return you the number

00:29:54.886 --> 00:29:55.836 A:middle
of elements in the array.

00:29:56.646 --> 00:29:58.096 A:middle
So, that's a problem.

00:29:58.576 --> 00:29:59.856 A:middle
We catch it.

00:29:59.856 --> 00:30:01.376 A:middle
How would you actually fix it?

00:29:59.856 --> 00:30:01.376 A:middle
How would you actually fix it?

00:30:01.376 --> 00:30:02.836 A:middle
Well, you could have written the

00:30:02.836 --> 00:30:03.606 A:middle
code a bit differently.

00:30:03.606 --> 00:30:05.116 A:middle
So, instead of using that idiom,

00:30:05.716 --> 00:30:06.686 A:middle
right, you could have gone in

00:30:06.986 --> 00:30:07.836 A:middle
and used something like

00:30:07.836 --> 00:30:09.136 A:middle
std::size, which means that

00:30:09.256 --> 00:30:10.886 A:middle
instead of refactoring the code

00:30:10.966 --> 00:30:12.896 A:middle
wrongly, you would have caught

00:30:12.896 --> 00:30:13.916 A:middle
that problem when you tried to

00:30:13.916 --> 00:30:14.676 A:middle
refactor it, right.

00:30:14.676 --> 00:30:16.056 A:middle
So std::size just does the right

00:30:16.136 --> 00:30:16.576 A:middle
thing here.

00:30:16.576 --> 00:30:17.756 A:middle
So that's a kind of a neat

00:30:17.756 --> 00:30:19.996 A:middle
warning that catches errors.

00:30:20.106 --> 00:30:22.006 A:middle
The last diagnostic I want to

00:30:22.006 --> 00:30:22.706 A:middle
tell you about is

00:30:22.706 --> 00:30:24.016 A:middle
defaulted-function-delete.

00:30:24.116 --> 00:30:25.626 A:middle
So, again, say I write this

00:30:25.626 --> 00:30:27.056 A:middle
beautiful code here, all right.

00:30:27.056 --> 00:30:27.726 A:middle
So, I have this struct

00:30:27.726 --> 00:30:28.376 A:middle
aberration.

00:30:28.456 --> 00:30:29.746 A:middle
It has some floating eyestalks,

00:30:29.746 --> 00:30:31.286 A:middle
some eyes and mouth, and I'm

00:30:31.286 --> 00:30:32.346 A:middle
like I want to default

00:30:32.346 --> 00:30:32.866 A:middle
aberration.

00:30:32.976 --> 00:30:33.796 A:middle
Please give me a default

00:30:33.796 --> 00:30:34.206 A:middle
aberration.

00:30:34.616 --> 00:30:35.706 A:middle
Well, the compiler comes in now

00:30:35.706 --> 00:30:37.026 A:middle
and tells you, hey I don't know

00:30:37.026 --> 00:30:38.156 A:middle
what a default aberration is.

00:30:38.156 --> 00:30:39.656 A:middle
Why not? Well, I have a float

00:30:39.656 --> 00:30:40.596 A:middle
reference, and I can't

00:30:40.596 --> 00:30:42.206 A:middle
synthesize the fault constructor

00:30:42.206 --> 00:30:43.106 A:middle
for that reference.

00:30:43.636 --> 00:30:45.466 A:middle
It's a type that I can't default

00:30:45.616 --> 00:30:46.166 A:middle
create.

00:30:46.616 --> 00:30:46.816 A:middle
Right.

00:30:47.096 --> 00:30:48.076 A:middle
So there's a bunch of other

00:30:48.076 --> 00:30:49.606 A:middle
ways, not just references in

00:30:49.606 --> 00:30:51.226 A:middle
C++, to create things that can't

00:30:51.226 --> 00:30:52.506 A:middle
be default constructed, and the

00:30:52.506 --> 00:30:53.826 A:middle
compiler now tells you about it.

00:30:53.966 --> 00:30:54.956 A:middle
If you ask for a default

00:30:54.956 --> 00:30:56.116 A:middle
constructor, and I can't give

00:30:56.116 --> 00:30:57.106 A:middle
you a default constructor, it'll

00:30:57.106 --> 00:30:57.416 A:middle
tell you.

00:30:57.916 --> 00:30:58.846 A:middle
So, how would you fix this?

00:30:58.846 --> 00:31:00.606 A:middle
Well, one way is to just create

00:30:58.846 --> 00:31:00.606 A:middle
Well, one way is to just create

00:31:01.096 --> 00:31:02.416 A:middle
the constructor yourself.

00:31:02.536 --> 00:31:04.066 A:middle
As you pass in the eyestalks,

00:31:04.066 --> 00:31:04.936 A:middle
that creates a reference

00:31:04.936 --> 00:31:05.426 A:middle
automatically.

00:31:05.776 --> 00:31:06.906 A:middle
That's kind of neat.

00:31:06.906 --> 00:31:08.786 A:middle
But personally, I think like

00:31:08.876 --> 00:31:09.736 A:middle
beauty is in the eye of the

00:31:09.736 --> 00:31:11.306 A:middle
beholder, but maybe this

00:31:11.306 --> 00:31:12.346 A:middle
aberration should be coded

00:31:12.346 --> 00:31:14.186 A:middle
differently and not have a float

00:31:14.186 --> 00:31:15.016 A:middle
reference, and maybe you should

00:31:15.016 --> 00:31:16.226 A:middle
just do this instead, right.

00:31:16.226 --> 00:31:17.606 A:middle
That makes a lot of sense,

00:31:17.876 --> 00:31:18.066 A:middle
right.

00:31:18.246 --> 00:31:19.906 A:middle
So, now I can default create to

00:31:19.906 --> 00:31:20.556 A:middle
the aberration.

00:31:21.146 --> 00:31:21.516 A:middle
All right.

00:31:21.516 --> 00:31:23.126 A:middle
So, that was the diagnostics I

00:31:23.126 --> 00:31:23.876 A:middle
wanted to the tell you about.

00:31:23.876 --> 00:31:25.156 A:middle
Now, I'm going to hand it off to

00:31:25.196 --> 00:31:26.176 A:middle
Devin, who's going to tell you

00:31:26.176 --> 00:31:27.406 A:middle
about New Static Analyzer

00:31:27.436 --> 00:31:27.956 A:middle
Checks.

00:31:28.516 --> 00:31:32.546 A:middle
[ Applause ]

00:31:33.046 --> 00:31:34.106 A:middle
&gt;&gt; Up until this point in the

00:31:34.106 --> 00:31:35.676 A:middle
talk, the warnings that we've

00:31:35.676 --> 00:31:36.956 A:middle
told you about have come from

00:31:36.956 --> 00:31:38.476 A:middle
the compiler when you build.

00:31:39.186 --> 00:31:40.566 A:middle
But we have other tools that can

00:31:40.566 --> 00:31:41.556 A:middle
help you find bugs.

00:31:42.516 --> 00:31:43.806 A:middle
One of them is the static

00:31:43.806 --> 00:31:44.286 A:middle
analyzer.

00:31:44.876 --> 00:31:48.656 A:middle
The analyzer finds deep bugs in

00:31:48.656 --> 00:31:50.026 A:middle
your code, and it can do it

00:31:50.076 --> 00:31:51.656 A:middle
without even running your app.

00:31:52.476 --> 00:31:53.966 A:middle
This makes it great at testing

00:31:54.176 --> 00:31:54.956 A:middle
and catching those

00:31:55.136 --> 00:31:57.156 A:middle
hard-to-reproduce bugs that you

00:31:57.156 --> 00:31:58.886 A:middle
never even thought to write

00:31:58.886 --> 00:31:59.386 A:middle
tests for.

00:32:00.136 --> 00:32:01.496 A:middle
And it can even show you the

00:32:01.496 --> 00:32:03.556 A:middle
sequence of steps along which

00:32:03.586 --> 00:32:04.456 A:middle
the bug manifests.

00:32:05.206 --> 00:32:06.646 A:middle
This makes it easy to understand

00:32:06.646 --> 00:32:08.886 A:middle
the problem and fix it.

00:32:09.996 --> 00:32:11.486 A:middle
Today, I'm going to tell you

00:32:11.516 --> 00:32:13.606 A:middle
about three new C++ checks that

00:32:13.606 --> 00:32:14.066 A:middle
we've added.

00:32:14.856 --> 00:32:16.346 A:middle
A check for use after move bugs,

00:32:16.896 --> 00:32:18.216 A:middle
a check for dangling C string

00:32:18.216 --> 00:32:20.506 A:middle
pointers with C++ std::string

00:32:20.536 --> 00:32:22.246 A:middle
and to check for reference

00:32:22.246 --> 00:32:23.606 A:middle
counting bugs in the new

00:32:23.606 --> 00:32:25.556 A:middle
DriverKit and in IOKit.

00:32:26.866 --> 00:32:28.446 A:middle
Let's start with use after move.

00:32:29.116 --> 00:32:34.296 A:middle
In C++, moves allow you to avoid

00:32:34.296 --> 00:32:35.626 A:middle
unwanted copies.

00:32:35.626 --> 00:32:36.956 A:middle
And here's an example of where

00:32:36.956 --> 00:32:39.266 A:middle
you might want to do that.

00:32:39.266 --> 00:32:40.476 A:middle
Let's suppose that I have

00:32:40.526 --> 00:32:42.466 A:middle
written a novel, and for those

00:32:42.466 --> 00:32:43.526 A:middle
of you who know me, I can be

00:32:43.566 --> 00:32:44.586 A:middle
quite verbose.

00:32:45.056 --> 00:32:46.716 A:middle
And so, I don't want to pay the

00:32:46.716 --> 00:32:48.656 A:middle
performance cost of copying the

00:32:48.656 --> 00:32:50.566 A:middle
entire text of the novel when I

00:32:50.566 --> 00:32:51.846 A:middle
hand it off to my publisher.

00:32:52.466 --> 00:32:54.446 A:middle
So, I'll use a move.

00:32:55.786 --> 00:32:57.396 A:middle
This moves from the source

00:32:57.396 --> 00:33:00.526 A:middle
variable rather than copying it.

00:32:57.396 --> 00:33:00.526 A:middle
variable rather than copying it.

00:33:00.526 --> 00:33:01.886 A:middle
And what's great about this is

00:33:01.886 --> 00:33:03.866 A:middle
that it allows me to enforce a

00:33:03.866 --> 00:33:06.056 A:middle
unique ownership semantics where

00:33:06.056 --> 00:33:07.836 A:middle
there's no confusion about who

00:33:07.836 --> 00:33:08.986 A:middle
has the latest version of the

00:33:08.986 --> 00:33:10.936 A:middle
novel, me or my publisher.

00:33:12.236 --> 00:33:13.666 A:middle
But I do need to be careful

00:33:13.666 --> 00:33:16.106 A:middle
here, and that's because moves

00:33:16.106 --> 00:33:17.316 A:middle
leave the source in an

00:33:17.386 --> 00:33:18.856 A:middle
unspecified state.

00:33:19.286 --> 00:33:24.026 A:middle
Let's see how this can go wrong.

00:33:24.226 --> 00:33:26.146 A:middle
Suppose I were to add a call to

00:33:26.146 --> 00:33:28.226 A:middle
spell check my novel after I

00:33:28.226 --> 00:33:29.406 A:middle
published it.

00:33:30.896 --> 00:33:32.656 A:middle
This can have unexpected results

00:33:32.656 --> 00:33:34.526 A:middle
or even crash depending on the

00:33:34.526 --> 00:33:36.266 A:middle
implementation of the book type.

00:33:37.626 --> 00:33:39.666 A:middle
Fortunately, the static analyzer

00:33:39.856 --> 00:33:41.226 A:middle
can now catch this bug.

00:33:41.826 --> 00:33:44.916 A:middle
To fix this, what I should do is

00:33:44.976 --> 00:33:45.986 A:middle
reorder the code.

00:33:46.796 --> 00:33:48.676 A:middle
It really does make sense to

00:33:48.676 --> 00:33:50.776 A:middle
spell check the novel before I

00:33:50.776 --> 00:33:52.046 A:middle
publish it.

00:33:53.456 --> 00:33:54.466 A:middle
All right.

00:33:55.556 --> 00:33:57.386 A:middle
Let's move on to dangling

00:33:57.846 --> 00:34:00.736 A:middle
pointers from std::string.

00:33:57.846 --> 00:34:00.736 A:middle
pointers from std::string.

00:34:00.916 --> 00:34:02.886 A:middle
Those of you who have mixed C++

00:34:02.886 --> 00:34:04.616 A:middle
and C strings know that this can

00:34:04.616 --> 00:34:07.056 A:middle
be really tricky, and here's an

00:34:07.056 --> 00:34:07.456 A:middle
example.

00:34:08.076 --> 00:34:10.156 A:middle
I've created this

00:34:10.216 --> 00:34:11.606 A:middle
generateGreeting function.

00:34:11.656 --> 00:34:13.746 A:middle
It takes in a C string name and

00:34:13.746 --> 00:34:15.706 A:middle
returns a C string greeting.

00:34:16.676 --> 00:34:17.966 A:middle
And in the implementation of

00:34:17.966 --> 00:34:19.626 A:middle
this function, I've chosen to

00:34:19.626 --> 00:34:22.186 A:middle
use a C++ std::string because

00:34:22.186 --> 00:34:23.485 A:middle
it's easier to manipulate.

00:34:24.646 --> 00:34:25.866 A:middle
I declare a std::string local

00:34:25.866 --> 00:34:26.946 A:middle
variable, initialize it to

00:34:26.946 --> 00:34:30.096 A:middle
hello, append the passed in name

00:34:30.766 --> 00:34:32.746 A:middle
and then, because the function

00:34:32.746 --> 00:34:35.456 A:middle
returns a C string, I call the c

00:34:35.456 --> 00:34:38.376 A:middle
str method on the C++ string,

00:34:38.576 --> 00:34:40.016 A:middle
and that's where things start to

00:34:40.016 --> 00:34:40.556 A:middle
go wrong.

00:34:41.485 --> 00:34:42.896 A:middle
And the key thing to note here

00:34:43.156 --> 00:34:45.326 A:middle
is that c str returns an inner

00:34:45.406 --> 00:34:47.585 A:middle
pointer to a buffer inside of

00:34:47.585 --> 00:34:48.335 A:middle
the std::string.

00:34:49.456 --> 00:34:51.476 A:middle
And this buffer is deallocated

00:34:51.716 --> 00:34:53.196 A:middle
when the std::string goes out of

00:34:53.196 --> 00:34:53.525 A:middle
scope.

00:34:54.025 --> 00:34:56.876 A:middle
What this means is that I'm

00:34:56.876 --> 00:34:58.556 A:middle
returning a pointer to memory

00:34:58.686 --> 00:35:00.836 A:middle
that will be deallocated, and

00:34:58.686 --> 00:35:00.836 A:middle
that will be deallocated, and

00:35:00.836 --> 00:35:02.656 A:middle
then when I use that memory, the

00:35:02.656 --> 00:35:03.886 A:middle
program could crash.

00:35:04.416 --> 00:35:07.366 A:middle
The static analyzer can now

00:35:07.366 --> 00:35:08.146 A:middle
catch this bug.

00:35:08.706 --> 00:35:11.896 A:middle
So how should I fix this?

00:35:12.936 --> 00:35:14.846 A:middle
Well, we recommend matching the

00:35:14.846 --> 00:35:17.096 A:middle
lifetimes of your C++ and C

00:35:17.096 --> 00:35:17.696 A:middle
strings.

00:35:18.906 --> 00:35:20.116 A:middle
Here, I have changed the

00:35:20.116 --> 00:35:21.616 A:middle
generateGreeting function to

00:35:21.616 --> 00:35:24.276 A:middle
return a std::string, and then I

00:35:24.276 --> 00:35:26.676 A:middle
store the result into a local

00:35:27.096 --> 00:35:27.346 A:middle
variable.

00:35:28.196 --> 00:35:29.696 A:middle
This means that when I call the

00:35:29.696 --> 00:35:32.406 A:middle
c str method that local variable

00:35:32.726 --> 00:35:34.446 A:middle
stays in scope for as long as I

00:35:34.446 --> 00:35:35.646 A:middle
need to use the C string.

00:35:36.196 --> 00:35:38.306 A:middle
In essence, what I have done

00:35:38.306 --> 00:35:39.526 A:middle
here is change the scope of the

00:35:39.526 --> 00:35:41.556 A:middle
std::string to last as long as I

00:35:41.556 --> 00:35:42.486 A:middle
need it.

00:35:43.196 --> 00:35:45.746 A:middle
And I will note that it's often

00:35:45.746 --> 00:35:47.716 A:middle
easier to stay within the C++

00:35:47.716 --> 00:35:50.586 A:middle
world as long as possible and

00:35:50.586 --> 00:35:51.926 A:middle
only get the C string out at

00:35:51.986 --> 00:35:53.766 A:middle
exactly the moment where I need

00:35:54.376 --> 00:35:54.446 A:middle
it.

00:35:56.256 --> 00:35:56.796 A:middle
All right.

00:35:57.316 --> 00:35:59.316 A:middle
So, let's move on to the third

00:35:59.316 --> 00:36:00.346 A:middle
and final check I'm going to

00:35:59.316 --> 00:36:00.346 A:middle
and final check I'm going to

00:36:00.346 --> 00:36:02.046 A:middle
tell you about, for Reference

00:36:02.046 --> 00:36:04.736 A:middle
Counting bugs in DriverKit and

00:36:05.616 --> 00:36:05.786 A:middle
IOKit.

00:36:07.676 --> 00:36:09.386 A:middle
These driver frameworks use

00:36:09.456 --> 00:36:11.676 A:middle
Manual Retain/Release for their

00:36:11.676 --> 00:36:12.736 A:middle
memory management.

00:36:13.396 --> 00:36:14.436 A:middle
And for those of you who are

00:36:14.436 --> 00:36:16.386 A:middle
familiar with CoreFoundation or

00:36:16.386 --> 00:36:17.806 A:middle
with Objective-C without

00:36:17.806 --> 00:36:18.986 A:middle
Automated Reference Counting,

00:36:19.296 --> 00:36:20.556 A:middle
it's very similar.

00:36:22.006 --> 00:36:23.396 A:middle
Manual Retain/Release gives you

00:36:23.396 --> 00:36:25.066 A:middle
a lot of control over memory

00:36:25.066 --> 00:36:27.096 A:middle
management, but it does come

00:36:27.096 --> 00:36:27.826 A:middle
with some additional

00:36:27.826 --> 00:36:28.786 A:middle
responsibilities.

00:36:30.216 --> 00:36:31.646 A:middle
You need to be careful to not

00:36:31.646 --> 00:36:34.156 A:middle
over release memory, because if

00:36:34.156 --> 00:36:35.626 A:middle
you do so, it could be

00:36:35.626 --> 00:36:37.576 A:middle
deallocated, and then when you

00:36:37.576 --> 00:36:39.636 A:middle
use it, your program could

00:36:41.296 --> 00:36:41.756 A:middle
crash.

00:36:42.056 --> 00:36:43.096 A:middle
Similarly, you should not

00:36:43.096 --> 00:36:44.256 A:middle
under-release your memory

00:36:44.666 --> 00:36:46.176 A:middle
because the memory could leak.

00:36:46.746 --> 00:36:50.046 A:middle
Let me give you an example of a

00:36:50.046 --> 00:36:50.386 A:middle
leak.

00:36:51.756 --> 00:36:53.016 A:middle
Here, I've written some code

00:36:53.146 --> 00:36:55.576 A:middle
that allocates a new array of

00:36:55.576 --> 00:36:56.206 A:middle
devices.

00:36:56.906 --> 00:36:58.596 A:middle
It then fills in those devices

00:36:58.926 --> 00:36:59.796 A:middle
and sets them up.

00:37:01.206 --> 00:37:02.586 A:middle
And the key thing to note here

00:37:02.926 --> 00:37:04.766 A:middle
is that OSArray::withCapacity,

00:37:05.296 --> 00:37:06.926 A:middle
it allocates a new array and

00:37:06.926 --> 00:37:08.446 A:middle
returns it retained.

00:37:09.766 --> 00:37:11.566 A:middle
What this means is that the

00:37:11.566 --> 00:37:13.526 A:middle
array will leak if it's not

00:37:13.586 --> 00:37:14.096 A:middle
released.

00:37:14.636 --> 00:37:18.316 A:middle
The analyzer can now catch this

00:37:18.386 --> 00:37:18.656 A:middle
bug.

00:37:19.226 --> 00:37:21.216 A:middle
So, how should I fix this?

00:37:22.116 --> 00:37:24.056 A:middle
All I need to do is make sure to

00:37:24.276 --> 00:37:26.046 A:middle
release the array when I'm done

00:37:26.766 --> 00:37:28.306 A:middle
with it.

00:37:29.066 --> 00:37:31.236 A:middle
Now, the memory management rules

00:37:31.236 --> 00:37:32.896 A:middle
are all based around naming

00:37:32.896 --> 00:37:34.786 A:middle
conventions, and these are very

00:37:34.786 --> 00:37:36.426 A:middle
similar in spirit to

00:37:36.426 --> 00:37:38.166 A:middle
CoreFoundation and Objective-C

00:37:38.166 --> 00:37:39.566 A:middle
under Manual Retain/Release.

00:37:40.546 --> 00:37:42.516 A:middle
But I do want to point out one

00:37:42.516 --> 00:37:44.436 A:middle
key difference for IOKit and

00:37:44.436 --> 00:37:47.426 A:middle
DriverKit, and that is that the

00:37:47.426 --> 00:37:49.356 A:middle
default convention is to return

00:37:49.506 --> 00:37:50.056 A:middle
retained.

00:37:50.516 --> 00:37:51.786 A:middle
Or, as we sometimes call it, at

00:37:51.946 --> 00:37:52.586 A:middle
+1.

00:37:53.726 --> 00:37:55.526 A:middle
What this means is that clients

00:37:55.526 --> 00:37:57.776 A:middle
must call release on the result

00:37:58.016 --> 00:37:59.176 A:middle
of a method that they call.

00:38:00.206 --> 00:38:01.666 A:middle
Otherwise, the object could

00:38:02.356 --> 00:38:02.446 A:middle
leak.

00:38:03.756 --> 00:38:05.616 A:middle
An important exception to this

00:38:05.616 --> 00:38:07.366 A:middle
rule is that getters return

00:38:07.466 --> 00:38:09.566 A:middle
unretained, or as we call it, at

00:38:09.566 --> 00:38:10.206 A:middle
+0.

00:38:11.096 --> 00:38:13.146 A:middle
Clients should not release the

00:38:13.146 --> 00:38:17.656 A:middle
result of a getter.

00:38:17.836 --> 00:38:19.536 A:middle
Now, you might write code that

00:38:19.616 --> 00:38:21.756 A:middle
differs from this convention,

00:38:21.756 --> 00:38:22.746 A:middle
and here's an example of some

00:38:22.746 --> 00:38:24.146 A:middle
code that I wrote.

00:38:25.116 --> 00:38:26.766 A:middle
This method finds the first

00:38:26.766 --> 00:38:30.536 A:middle
device in an array, and it has

00:38:30.536 --> 00:38:31.486 A:middle
the default convention.

00:38:31.486 --> 00:38:32.626 A:middle
It should return retained.

00:38:33.896 --> 00:38:34.686 A:middle
But if we look at the

00:38:34.686 --> 00:38:36.996 A:middle
implementation, it returns the

00:38:36.996 --> 00:38:39.666 A:middle
result of a getter, and getters

00:38:39.666 --> 00:38:40.816 A:middle
return unretained.

00:38:41.546 --> 00:38:43.356 A:middle
So, there's a mismatch here.

00:38:44.036 --> 00:38:45.636 A:middle
Fortunately, the analyzer can

00:38:45.636 --> 00:38:47.166 A:middle
tell us about this.

00:38:47.976 --> 00:38:49.396 A:middle
So, how should I fix this?

00:38:50.456 --> 00:38:52.346 A:middle
Well, I have three different

00:38:52.426 --> 00:38:52.996 A:middle
options.

00:38:53.796 --> 00:38:55.666 A:middle
The first is to change the

00:38:55.666 --> 00:38:56.666 A:middle
behavior to follow the

00:38:56.666 --> 00:38:57.216 A:middle
convention.

00:38:58.096 --> 00:38:59.236 A:middle
Here, the convention is that the

00:38:59.236 --> 00:39:00.546 A:middle
method should return retained,

00:38:59.236 --> 00:39:00.546 A:middle
method should return retained,

00:39:00.986 --> 00:39:02.886 A:middle
so I could retain the result

00:39:03.096 --> 00:39:04.566 A:middle
before returning it.

00:39:05.556 --> 00:39:08.076 A:middle
Another possibility is to rename

00:39:08.076 --> 00:39:08.536 A:middle
the method.

00:39:09.646 --> 00:39:10.686 A:middle
And if I look at this

00:39:10.686 --> 00:39:12.796 A:middle
findFirstDevice method, it looks

00:39:12.796 --> 00:39:14.256 A:middle
a lot like a getter.

00:39:14.906 --> 00:39:16.176 A:middle
So, I could just rename it to

00:39:16.176 --> 00:39:17.736 A:middle
getFirstDevice, and that would

00:39:17.736 --> 00:39:18.866 A:middle
follow the guidelines.

00:39:19.386 --> 00:39:22.236 A:middle
But you might have a method that

00:39:22.236 --> 00:39:23.706 A:middle
has the behavior that you want,

00:39:24.006 --> 00:39:25.396 A:middle
and it has the perfect name.

00:39:25.756 --> 00:39:27.556 A:middle
You don't want to change it, and

00:39:27.686 --> 00:39:28.596 A:middle
that's okay.

00:39:29.536 --> 00:39:30.756 A:middle
What you should do in this case

00:39:30.996 --> 00:39:33.166 A:middle
is add an annotation to tell

00:39:33.166 --> 00:39:35.426 A:middle
both readers of your code and

00:39:35.426 --> 00:39:37.206 A:middle
the analyzer that you're not

00:39:37.206 --> 00:39:38.556 A:middle
following the convention on

00:39:38.556 --> 00:39:38.986 A:middle
purpose.

00:39:39.556 --> 00:39:42.546 A:middle
In this case, I can add the

00:39:42.546 --> 00:39:44.176 A:middle
DRIVERKIT RETURNS NOT RETAINED

00:39:44.176 --> 00:39:47.166 A:middle
annotation to express my intent.

00:39:48.496 --> 00:39:50.566 A:middle
So, if you have an IOKit driver

00:39:50.726 --> 00:39:51.826 A:middle
or you're writing a new

00:39:51.826 --> 00:39:54.016 A:middle
DriverKit driver, I highly

00:39:54.016 --> 00:39:55.176 A:middle
encourage you to run the

00:39:55.176 --> 00:39:56.516 A:middle
analyzer on your code.

00:39:57.886 --> 00:39:59.626 A:middle
To do that, all you need to do

00:39:59.626 --> 00:40:01.516 A:middle
is go to Xcode's product menu

00:39:59.626 --> 00:40:01.516 A:middle
is go to Xcode's product menu

00:40:01.806 --> 00:40:03.246 A:middle
and choose analyze.

00:40:04.066 --> 00:40:06.056 A:middle
And you can even have Xcode run

00:40:06.056 --> 00:40:07.736 A:middle
the analyzer every time you hit

00:40:07.736 --> 00:40:09.926 A:middle
build by going to your target's

00:40:09.926 --> 00:40:11.396 A:middle
build settings and enabling

00:40:11.616 --> 00:40:12.916 A:middle
Analyze During Build.

00:40:13.896 --> 00:40:14.786 A:middle
This will help you catch your

00:40:14.786 --> 00:40:16.656 A:middle
bugs before you even commit

00:40:17.286 --> 00:40:17.376 A:middle
them.

00:40:19.716 --> 00:40:21.696 A:middle
All right, so we told you about

00:40:21.696 --> 00:40:22.536 A:middle
a lot today.

00:40:23.546 --> 00:40:25.236 A:middle
We showed you how LLVM Bitcode

00:40:25.236 --> 00:40:27.056 A:middle
enabled a seamless 64-bit

00:40:27.056 --> 00:40:29.376 A:middle
transition for watchOS where

00:40:29.376 --> 00:40:31.456 A:middle
your 32-bit apps worked on day

00:40:31.456 --> 00:40:33.436 A:middle
one with Series 4 watches.

00:40:34.836 --> 00:40:35.976 A:middle
We showed you how to reduce code

00:40:35.976 --> 00:40:37.026 A:middle
size with new compiler

00:40:37.026 --> 00:40:38.096 A:middle
optimizations and language

00:40:38.096 --> 00:40:39.686 A:middle
features and how to run the

00:40:39.686 --> 00:40:42.026 A:middle
static analyzer on your code.

00:40:42.656 --> 00:40:44.406 A:middle
For more information, please

00:40:44.406 --> 00:40:45.666 A:middle
check out our session website,

00:40:46.086 --> 00:40:47.186 A:middle
and we really look forward to

00:40:47.186 --> 00:40:48.676 A:middle
talking with you in the labs.

00:40:49.116 --> 00:40:49.686 A:middle
Thank you.

00:40:50.516 --> 00:40:53.500 A:middle
[ Applause ]
