WEBVTT

00:00:00.506 --> 00:00:04.500 A:middle
[ Music ]

00:00:10.516 --> 00:00:15.086 A:middle
[ Applause ]

00:00:15.586 --> 00:00:16.586 A:middle
&gt;&gt; Good morning and welcome

00:00:16.586 --> 00:00:17.136 A:middle
everyone.

00:00:17.326 --> 00:00:18.856 A:middle
I am Guillem Vinals Gangolells

00:00:18.856 --> 00:00:20.356 A:middle
from the Metal Ecosystem Team.

00:00:21.086 --> 00:00:22.486 A:middle
This past year, we have been

00:00:22.486 --> 00:00:23.406 A:middle
working with many game

00:00:23.406 --> 00:00:25.536 A:middle
developers and identified some

00:00:25.536 --> 00:00:26.216 A:middle
common issues.

00:00:26.896 --> 00:00:28.836 A:middle
As a result, we decided to put

00:00:28.836 --> 00:00:29.746 A:middle
this talk together.

00:00:30.446 --> 00:00:32.386 A:middle
Today, I will be presenting a

00:00:32.436 --> 00:00:34.316 A:middle
total of 18 best practices to

00:00:34.316 --> 00:00:36.246 A:middle
help you improve your Metal app.

00:00:37.486 --> 00:00:39.246 A:middle
Notice that I will not present

00:00:39.456 --> 00:00:42.736 A:middle
OK practices or acceptable

00:00:42.736 --> 00:00:45.216 A:middle
practices, and most definitely

00:00:45.566 --> 00:00:47.316 A:middle
not practices that will just do

00:00:47.316 --> 00:00:47.786 A:middle
the trick.

00:00:49.056 --> 00:00:51.336 A:middle
The focus today will be on Metal

00:00:51.336 --> 00:00:52.196 A:middle
Best Practices.

00:00:52.616 --> 00:00:55.786 A:middle
So, please follow them.

00:00:55.996 --> 00:00:57.346 A:middle
Before we get started, I would

00:00:57.346 --> 00:00:58.496 A:middle
like to thank our friends at

00:00:58.496 --> 00:01:00.356 A:middle
Digital Legends, our very

00:00:58.496 --> 00:01:00.356 A:middle
Digital Legends, our very

00:01:00.356 --> 00:01:01.776 A:middle
talented team from Barcelona.

00:01:02.476 --> 00:01:03.936 A:middle
They are the developers of

00:01:03.936 --> 00:01:04.626 A:middle
Afterpulse.

00:01:05.146 --> 00:01:07.236 A:middle
Afterpulse is an awesome great

00:01:07.236 --> 00:01:07.876 A:middle
looking game.

00:01:08.406 --> 00:01:09.606 A:middle
It uses many rendering

00:01:09.606 --> 00:01:11.266 A:middle
techniques such as cascaded

00:01:11.266 --> 00:01:13.186 A:middle
shadow maps, a fully-featured

00:01:13.186 --> 00:01:14.966 A:middle
deferred render as well as

00:01:14.966 --> 00:01:16.566 A:middle
post-process such as bloom and

00:01:16.566 --> 00:01:16.796 A:middle
FXAA.

00:01:16.846 --> 00:01:19.356 A:middle
We will use Afterpulse

00:01:19.356 --> 00:01:21.116 A:middle
throughout this presentation to

00:01:21.116 --> 00:01:22.366 A:middle
demo our tools and highlight

00:01:22.366 --> 00:01:23.606 A:middle
some of our best practices.

00:01:25.206 --> 00:01:26.366 A:middle
We have split the talk into

00:01:26.366 --> 00:01:28.116 A:middle
three sections, general

00:01:28.116 --> 00:01:30.346 A:middle
performance, memory bandwidth,

00:01:31.226 --> 00:01:32.216 A:middle
and memory footprint.

00:01:33.056 --> 00:01:34.316 A:middle
So, let's get started with some

00:01:34.316 --> 00:01:35.776 A:middle
general performance advice.

00:01:40.076 --> 00:01:41.666 A:middle
In this section, I will talk

00:01:41.666 --> 00:01:43.076 A:middle
about choosing the right

00:01:43.076 --> 00:01:45.586 A:middle
resolution, avoiding overdraw,

00:01:45.586 --> 00:01:46.876 A:middle
reduce the amount of fragment

00:01:46.876 --> 00:01:48.396 A:middle
shader invocations per pixel

00:01:48.396 --> 00:01:48.846 A:middle
written.

00:01:49.876 --> 00:01:51.076 A:middle
We'll also talk about GPU

00:01:51.076 --> 00:01:52.936 A:middle
submissions, resource streaming,

00:01:53.206 --> 00:01:54.446 A:middle
and also a bit about thermals.

00:01:55.956 --> 00:01:56.986 A:middle
So, let's get started with the

00:01:57.086 --> 00:01:58.156 A:middle
first best practice.

00:01:58.536 --> 00:01:59.876 A:middle
Choose the right resolution.

00:02:01.006 --> 00:02:02.446 A:middle
Notice that each effect in your

00:02:02.446 --> 00:02:04.036 A:middle
game may require a different

00:02:04.036 --> 00:02:04.656 A:middle
resolution.

00:02:05.266 --> 00:02:06.436 A:middle
So, it is very important that

00:02:06.436 --> 00:02:07.836 A:middle
you consider the image quality

00:02:07.836 --> 00:02:09.606 A:middle
and performance trade-off of

00:02:09.606 --> 00:02:11.266 A:middle
each resolution and choose them

00:02:11.296 --> 00:02:11.816 A:middle
carefully.

00:02:12.626 --> 00:02:14.966 A:middle
Also, composite the game UI at

00:02:14.996 --> 00:02:17.146 A:middle
native resolution or close to

00:02:17.146 --> 00:02:18.966 A:middle
native, so the UI will look

00:02:19.036 --> 00:02:20.526 A:middle
crisp no matter the display

00:02:20.526 --> 00:02:20.916 A:middle
size.

00:02:21.556 --> 00:02:23.986 A:middle
We can check the resolutions

00:02:23.986 --> 00:02:25.226 A:middle
with the Metal Frame Debugger.

00:02:26.676 --> 00:02:28.166 A:middle
Within the metal frame debugger,

00:02:28.166 --> 00:02:29.086 A:middle
we will want to use the

00:02:29.086 --> 00:02:31.066 A:middle
Dependency Viewer, which will

00:02:31.066 --> 00:02:32.356 A:middle
show a graph of every render

00:02:32.356 --> 00:02:32.816 A:middle
pass.

00:02:33.486 --> 00:02:34.806 A:middle
In this case, we are using a

00:02:34.806 --> 00:02:36.186 A:middle
Metal example application.

00:02:37.216 --> 00:02:38.346 A:middle
To access the Dependency Viewer,

00:02:38.346 --> 00:02:39.526 A:middle
we will select the command

00:02:39.526 --> 00:02:39.916 A:middle
buffer.

00:02:40.546 --> 00:02:43.626 A:middle
And, in this case, you can see

00:02:43.626 --> 00:02:44.936 A:middle
that this example Metal

00:02:44.936 --> 00:02:46.346 A:middle
application is using several

00:02:46.346 --> 00:02:48.166 A:middle
effects within different

00:02:48.166 --> 00:02:49.106 A:middle
resolution each.

00:02:49.906 --> 00:02:51.836 A:middle
For example, Shadow Maps and

00:02:51.976 --> 00:02:53.976 A:middle
SSAO have a different resolution

00:02:53.976 --> 00:02:55.126 A:middle
than the main lighting pass.

00:02:55.776 --> 00:02:57.536 A:middle
Also, the UI is composed of

00:02:57.536 --> 00:02:58.676 A:middle
native resolution, so it will

00:02:58.676 --> 00:02:59.336 A:middle
always look sharp.

00:03:00.646 --> 00:03:02.696 A:middle
These resolutions look great and

00:03:02.696 --> 00:03:04.056 A:middle
perform well for this Metal

00:03:04.056 --> 00:03:04.716 A:middle
application.

00:03:05.186 --> 00:03:06.306 A:middle
We're asking for you to do a

00:03:06.306 --> 00:03:07.956 A:middle
similar choice for your game.

00:03:08.926 --> 00:03:10.026 A:middle
So, let's move on to best

00:03:10.026 --> 00:03:12.026 A:middle
practice number 2.

00:03:12.436 --> 00:03:13.986 A:middle
Minimize non-opaque overdraw.

00:03:15.086 --> 00:03:16.326 A:middle
Overdraw is the amount of

00:03:16.416 --> 00:03:17.866 A:middle
fragment shader's process for

00:03:17.866 --> 00:03:18.836 A:middle
each pixel written.

00:03:19.706 --> 00:03:21.776 A:middle
iOS GPUs are excellent at

00:03:21.776 --> 00:03:23.256 A:middle
reducing opaque overdraw.

00:03:23.616 --> 00:03:25.006 A:middle
We just need to help a bit.

00:03:25.606 --> 00:03:28.096 A:middle
So, the best practice here is to

00:03:28.096 --> 00:03:30.326 A:middle
render opaque meshes first and

00:03:30.326 --> 00:03:31.676 A:middle
translucent meshes later.

00:03:32.296 --> 00:03:33.916 A:middle
Also, do not render fully

00:03:33.916 --> 00:03:35.956 A:middle
transparent or invisible meshes.

00:03:36.256 --> 00:03:38.326 A:middle
We will, once again, use the

00:03:38.326 --> 00:03:40.006 A:middle
Metal Frame Debugger to help us.

00:03:40.636 --> 00:03:42.176 A:middle
This time, we will look at the

00:03:42.176 --> 00:03:44.656 A:middle
GPU Counters gauge to verify the

00:03:44.656 --> 00:03:45.966 A:middle
overdraw for a given render

00:03:45.966 --> 00:03:46.436 A:middle
pass.

00:03:47.286 --> 00:03:48.486 A:middle
We will want to focus on the

00:03:48.486 --> 00:03:49.946 A:middle
main lighting pass of our Metal

00:03:49.946 --> 00:03:50.856 A:middle
Demo application.

00:03:52.306 --> 00:03:54.126 A:middle
In order to calculate overdraw,

00:03:54.506 --> 00:03:55.576 A:middle
we will look at the number of

00:03:55.576 --> 00:03:57.036 A:middle
fragment shader invocations

00:03:57.036 --> 00:03:58.416 A:middle
divided by the amount of pixel

00:03:58.416 --> 00:03:58.756 A:middle
store.

00:03:59.536 --> 00:04:00.786 A:middle
We can use the filter bar at the

00:03:59.536 --> 00:04:00.786 A:middle
We can use the filter bar at the

00:04:00.786 --> 00:04:02.066 A:middle
bottom to quickly look for

00:04:02.066 --> 00:04:03.216 A:middle
performance counters where

00:04:03.216 --> 00:04:03.596 A:middle
after.

00:04:04.206 --> 00:04:06.866 A:middle
In this case, it's a fully

00:04:06.866 --> 00:04:07.536 A:middle
opaque scene.

00:04:07.536 --> 00:04:09.026 A:middle
So, there's nothing else to

00:04:09.026 --> 00:04:09.516 A:middle
verify.

00:04:09.516 --> 00:04:10.846 A:middle
There's no overdraw and we are

00:04:10.846 --> 00:04:11.396 A:middle
good to go.

00:04:11.946 --> 00:04:12.896 A:middle
We're asking for you to do

00:04:12.896 --> 00:04:14.386 A:middle
something similar with your game

00:04:14.756 --> 00:04:16.026 A:middle
and verify that you're also good

00:04:16.026 --> 00:04:16.396 A:middle
to go.

00:04:17.606 --> 00:04:19.156 A:middle
So, let's move on to the next

00:04:20.206 --> 00:04:21.755 A:middle
best practice.

00:04:21.846 --> 00:04:23.376 A:middle
Submit GPU work early.

00:04:26.146 --> 00:04:27.556 A:middle
Scheduling all the off-screen

00:04:27.556 --> 00:04:29.056 A:middle
GPU work early is very

00:04:29.056 --> 00:04:29.706 A:middle
important.

00:04:30.206 --> 00:04:31.576 A:middle
It will improve the latency and

00:04:31.576 --> 00:04:33.076 A:middle
responsiveness of your game and

00:04:33.266 --> 00:04:34.816 A:middle
it will also allow the system to

00:04:34.816 --> 00:04:36.076 A:middle
adapt to the workload much

00:04:36.126 --> 00:04:36.496 A:middle
better.

00:04:37.456 --> 00:04:38.496 A:middle
So, it is important that you

00:04:38.496 --> 00:04:40.396 A:middle
have multiple GPU submissions in

00:04:40.396 --> 00:04:40.976 A:middle
your frame.

00:04:41.516 --> 00:04:43.416 A:middle
In particular, you will want an

00:04:43.456 --> 00:04:45.656 A:middle
early GPU submission before

00:04:46.176 --> 00:04:47.626 A:middle
waiting for the drawables and

00:04:47.626 --> 00:04:49.546 A:middle
some would stall the render set.

00:04:50.376 --> 00:04:52.416 A:middle
And after you get the drawable

00:04:52.416 --> 00:04:53.336 A:middle
which will be as late as

00:04:53.366 --> 00:04:55.116 A:middle
possible in the frame, you will

00:04:55.116 --> 00:04:57.626 A:middle
then have a late GPU submission

00:04:58.106 --> 00:04:59.216 A:middle
where you will schedule all the

00:04:59.216 --> 00:05:00.986 A:middle
on-screen work, potentially, the

00:04:59.216 --> 00:05:00.986 A:middle
on-screen work, potentially, the

00:05:00.986 --> 00:05:02.306 A:middle
UI Composition Pass.

00:05:03.476 --> 00:05:04.426 A:middle
Since, it's a bit tricky to

00:05:04.426 --> 00:05:05.976 A:middle
explain, we have demo prepared.

00:05:06.726 --> 00:05:08.186 A:middle
So, let's do a quick demo and

00:05:08.186 --> 00:05:09.396 A:middle
I'll show you how to identify

00:05:09.396 --> 00:05:10.746 A:middle
this with Metal System Trace.

00:05:13.656 --> 00:05:16.316 A:middle
Cool. What we see here is a

00:05:16.346 --> 00:05:18.366 A:middle
capture of Afterpulse which we

00:05:18.366 --> 00:05:20.256 A:middle
took last year with an older

00:05:20.256 --> 00:05:21.046 A:middle
build of the game.

00:05:21.696 --> 00:05:23.096 A:middle
This was taken with a game

00:05:23.096 --> 00:05:24.216 A:middle
performance template.

00:05:24.446 --> 00:05:26.046 A:middle
We introduced this template last

00:05:26.046 --> 00:05:26.296 A:middle
year.

00:05:26.786 --> 00:05:28.036 A:middle
So, you're already familiar with

00:05:28.036 --> 00:05:29.336 A:middle
some of the instruments here.

00:05:29.336 --> 00:05:31.166 A:middle
New this year, we have added the

00:05:31.166 --> 00:05:33.056 A:middle
Thermal State as well as the

00:05:33.056 --> 00:05:34.506 A:middle
Metal Resource Allocations.

00:05:34.676 --> 00:05:35.986 A:middle
We'll talk about this later.

00:05:36.796 --> 00:05:38.166 A:middle
For now, what we want to focus

00:05:38.166 --> 00:05:40.346 A:middle
on, our potential stutters or

00:05:40.346 --> 00:05:40.816 A:middle
issues.

00:05:41.396 --> 00:05:42.716 A:middle
In this case, we want to look at

00:05:42.716 --> 00:05:44.196 A:middle
the Display panel and see that

00:05:44.196 --> 00:05:46.086 A:middle
there's lots of events at the

00:05:46.086 --> 00:05:48.006 A:middle
bottom with-- where surfaces

00:05:48.006 --> 00:05:49.236 A:middle
have been on-screen for longer

00:05:49.236 --> 00:05:49.986 A:middle
than expected.

00:05:50.576 --> 00:05:51.766 A:middle
So, maybe that's a problem and

00:05:51.766 --> 00:05:52.606 A:middle
we should look at it.

00:05:53.276 --> 00:05:54.536 A:middle
What we will do is zoom in to

00:05:54.536 --> 00:05:56.706 A:middle
one of these regions holding the

00:05:56.706 --> 00:06:00.396 A:middle
Option key and dragging the--

00:05:56.706 --> 00:06:00.396 A:middle
Option key and dragging the--

00:06:00.836 --> 00:06:02.036 A:middle
our cursor over it.

00:06:02.126 --> 00:06:04.806 A:middle
So, in this case, we can see

00:06:04.806 --> 00:06:07.456 A:middle
that there's two frames that

00:06:07.456 --> 00:06:09.536 A:middle
seem to be later than we would

00:06:09.536 --> 00:06:12.106 A:middle
expect, at the same time, that

00:06:12.106 --> 00:06:14.176 A:middle
the GPU is idle for a long time.

00:06:14.756 --> 00:06:16.046 A:middle
So, that potentially is the

00:06:16.046 --> 00:06:17.656 A:middle
cause of the issue we are trying

00:06:17.656 --> 00:06:18.306 A:middle
to debug here.

00:06:18.306 --> 00:06:19.756 A:middle
So, let's look into more detail.

00:06:20.576 --> 00:06:22.736 A:middle
We'll do that by disclosing all

00:06:22.736 --> 00:06:24.406 A:middle
the tracks in Metal System Trace

00:06:24.406 --> 00:06:25.836 A:middle
which you're already familiar

00:06:25.836 --> 00:06:26.086 A:middle
with.

00:06:26.976 --> 00:06:29.236 A:middle
So, what we are seeing here are

00:06:30.046 --> 00:06:31.616 A:middle
how our application is encoding

00:06:31.616 --> 00:06:33.716 A:middle
work and also how our GPU is

00:06:33.716 --> 00:06:34.756 A:middle
processing this work.

00:06:35.286 --> 00:06:36.636 A:middle
So, let's focus on this orange

00:06:36.636 --> 00:06:37.036 A:middle
frame.

00:06:37.746 --> 00:06:39.006 A:middle
As you can see here, there's a

00:06:39.006 --> 00:06:41.176 A:middle
lot of work being encoded by the

00:06:41.176 --> 00:06:42.466 A:middle
apps, so we have the Shadow

00:06:42.466 --> 00:06:45.066 A:middle
Maps, the Deferred Pass as well

00:06:45.066 --> 00:06:46.366 A:middle
as part of the bloom chain, et

00:06:46.366 --> 00:06:46.726 A:middle
cetera.

00:06:47.436 --> 00:06:50.116 A:middle
So, the GPU is not actually

00:06:50.116 --> 00:06:51.836 A:middle
processing that work, at the

00:06:51.836 --> 00:06:54.396 A:middle
same time that the threat is

00:06:54.396 --> 00:06:55.696 A:middle
waiting for the drawable.

00:06:56.206 --> 00:06:57.426 A:middle
So that's what this causing this

00:06:57.426 --> 00:06:59.506 A:middle
idle gap, but we already have

00:06:59.506 --> 00:07:00.586 A:middle
some work encoded.

00:06:59.506 --> 00:07:00.586 A:middle
some work encoded.

00:07:00.946 --> 00:07:02.336 A:middle
We just didn't submit it.

00:07:03.136 --> 00:07:04.056 A:middle
So, that's what the best

00:07:04.056 --> 00:07:05.926 A:middle
practice was about you

00:07:05.926 --> 00:07:07.286 A:middle
submitting all the off-screen

00:07:07.286 --> 00:07:09.356 A:middle
work which you can encode ahead

00:07:09.356 --> 00:07:10.776 A:middle
of time before waiting for the

00:07:10.776 --> 00:07:11.256 A:middle
drawable.

00:07:11.866 --> 00:07:13.166 A:middle
So, the solution would be to do

00:07:13.166 --> 00:07:14.686 A:middle
one GPU submission here.

00:07:15.296 --> 00:07:16.866 A:middle
Notice that there's only one GPU

00:07:16.866 --> 00:07:18.696 A:middle
submission which we can see here

00:07:19.066 --> 00:07:20.256 A:middle
towards the end of the frame.

00:07:20.346 --> 00:07:22.126 A:middle
So, all the GPU work just

00:07:22.126 --> 00:07:23.046 A:middle
happens at the end.

00:07:23.836 --> 00:07:25.616 A:middle
Unfortunately, this is very easy

00:07:25.656 --> 00:07:27.656 A:middle
to simple-- very easy to fix.

00:07:27.686 --> 00:07:29.406 A:middle
And, in fact, Digital Legends

00:07:29.406 --> 00:07:30.266 A:middle
has already fixed it.

00:07:30.266 --> 00:07:31.476 A:middle
So, let's look at the new trace

00:07:31.476 --> 00:07:33.186 A:middle
of Afterpulse and see how it

00:07:33.186 --> 00:07:33.636 A:middle
looks like.

00:07:34.876 --> 00:07:36.486 A:middle
OK. So, let's zoom in.

00:07:37.546 --> 00:07:38.786 A:middle
In this case, we can see that

00:07:38.786 --> 00:07:40.926 A:middle
there's no idle time while we

00:07:40.926 --> 00:07:42.046 A:middle
are waiting for the drawable.

00:07:42.846 --> 00:07:44.096 A:middle
So, let's disclose the Metal

00:07:44.096 --> 00:07:45.506 A:middle
System Trace tracks as we did

00:07:45.506 --> 00:07:45.966 A:middle
before.

00:07:47.196 --> 00:07:48.456 A:middle
And, in this case, we can see

00:07:48.456 --> 00:07:50.766 A:middle
that the GPU is processing the

00:07:50.766 --> 00:07:52.196 A:middle
work that we have already

00:07:52.196 --> 00:07:54.946 A:middle
scheduled before getting the

00:07:54.946 --> 00:07:55.426 A:middle
drawable.

00:07:56.266 --> 00:07:58.126 A:middle
So, in this case, the idle time

00:07:58.126 --> 00:07:59.766 A:middle
is much smaller.

00:07:59.766 --> 00:08:01.216 A:middle
So, this allows the system to

00:07:59.766 --> 00:08:01.216 A:middle
So, this allows the system to

00:08:01.216 --> 00:08:02.316 A:middle
adapt to the workload much

00:08:02.316 --> 00:08:04.406 A:middle
better and there's no problems.

00:08:04.926 --> 00:08:07.486 A:middle
So, after this, we know we are

00:08:07.486 --> 00:08:09.466 A:middle
good to go and we are-- we

00:08:09.466 --> 00:08:11.536 A:middle
already have multiple GPU

00:08:11.536 --> 00:08:13.676 A:middle
submissions which do not cause

00:08:13.676 --> 00:08:15.106 A:middle
any stall because we do them

00:08:15.296 --> 00:08:16.476 A:middle
before waiting for the drawable.

00:08:16.526 --> 00:08:17.796 A:middle
So, let's go back to the slides.

00:08:19.736 --> 00:08:21.356 A:middle
OK. So, the fix for that is

00:08:21.356 --> 00:08:22.876 A:middle
actually quite simple much

00:08:22.876 --> 00:08:23.826 A:middle
easier than explaining the

00:08:23.866 --> 00:08:25.166 A:middle
problem in the first place.

00:08:25.926 --> 00:08:26.976 A:middle
What we will want to do is

00:08:26.976 --> 00:08:28.616 A:middle
simply create multiple command

00:08:28.616 --> 00:08:29.606 A:middle
buffers per frame.

00:08:30.356 --> 00:08:31.686 A:middle
So, we'll want to first create

00:08:31.686 --> 00:08:33.126 A:middle
the command buffer to encode all

00:08:33.126 --> 00:08:34.856 A:middle
the off-screen work which will

00:08:34.856 --> 00:08:37.176 A:middle
be our early GPU submission.

00:08:37.356 --> 00:08:38.765 A:middle
We will commit the command

00:08:38.765 --> 00:08:40.996 A:middle
buffer and then wait for the

00:08:40.996 --> 00:08:42.926 A:middle
next drawable, which will stall

00:08:42.926 --> 00:08:43.336 A:middle
our thread.

00:08:43.336 --> 00:08:45.956 A:middle
After we have the drawable, we

00:08:45.956 --> 00:08:48.586 A:middle
will create one final command

00:08:48.586 --> 00:08:49.946 A:middle
buffer where we will encode all

00:08:49.946 --> 00:08:52.026 A:middle
the on-screen work and present

00:08:52.026 --> 00:08:52.606 A:middle
the drawable.

00:08:53.446 --> 00:08:55.776 A:middle
This will be our final CPU-- GPU

00:08:55.776 --> 00:08:56.446 A:middle
submission.

00:08:57.256 --> 00:08:58.736 A:middle
And this will also ensure that

00:08:58.736 --> 00:09:00.146 A:middle
the frame pacing is actually

00:08:58.736 --> 00:09:00.146 A:middle
the frame pacing is actually

00:09:00.146 --> 00:09:01.096 A:middle
good enough as well.

00:09:02.676 --> 00:09:04.126 A:middle
It's as simple as that.

00:09:04.126 --> 00:09:05.286 A:middle
Just use multiple command

00:09:05.286 --> 00:09:05.646 A:middle
buffers.

00:09:06.496 --> 00:09:07.666 A:middle
So, let's move on to the best

00:09:07.666 --> 00:09:09.716 A:middle
practice number 4, stream

00:09:09.716 --> 00:09:10.836 A:middle
resources efficiently.

00:09:11.746 --> 00:09:13.336 A:middle
Allocating resources does take

00:09:13.386 --> 00:09:13.726 A:middle
time.

00:09:14.476 --> 00:09:16.256 A:middle
And streaming resources from the

00:09:16.256 --> 00:09:17.896 A:middle
render thread may cause stalls.

00:09:18.346 --> 00:09:19.606 A:middle
So, the best practice here is

00:09:19.606 --> 00:09:21.146 A:middle
for you to consider the memory

00:09:21.146 --> 00:09:22.956 A:middle
and performance trade-off of

00:09:22.956 --> 00:09:23.766 A:middle
your resource streaming

00:09:23.766 --> 00:09:26.036 A:middle
algorithm and make sure that you

00:09:26.116 --> 00:09:27.906 A:middle
allocate and load GPU resources

00:09:27.906 --> 00:09:29.216 A:middle
at launch time since you will

00:09:29.216 --> 00:09:30.426 A:middle
not need to allocate them at

00:09:30.426 --> 00:09:31.006 A:middle
runtime.

00:09:31.916 --> 00:09:33.316 A:middle
And any resource that you need

00:09:33.316 --> 00:09:35.336 A:middle
to stream at runtime, make sure

00:09:35.336 --> 00:09:36.826 A:middle
you do so from a dedicated

00:09:36.886 --> 00:09:37.146 A:middle
thread.

00:09:37.786 --> 00:09:39.266 A:middle
It is very important that you do

00:09:39.266 --> 00:09:40.726 A:middle
so in order to avoid stalls.

00:09:41.216 --> 00:09:43.266 A:middle
We will revisit resource

00:09:43.266 --> 00:09:44.936 A:middle
streaming later on in the memory

00:09:44.996 --> 00:09:47.216 A:middle
footprint section and reevaluate

00:09:47.216 --> 00:09:48.326 A:middle
the memory and performance

00:09:48.386 --> 00:09:48.936 A:middle
trade-off.

00:09:49.656 --> 00:09:51.406 A:middle
For now, let's just use Metal

00:09:51.406 --> 00:09:52.726 A:middle
System Trace to tune our

00:09:52.726 --> 00:09:53.516 A:middle
resource streaming.

00:09:54.516 --> 00:09:56.066 A:middle
New this year, we're having an

00:09:56.066 --> 00:09:57.836 A:middle
Allocations Track which will

00:09:57.836 --> 00:09:59.166 A:middle
show you an event for each

00:09:59.166 --> 00:10:00.646 A:middle
resource allocation and the

00:09:59.166 --> 00:10:00.646 A:middle
resource allocation and the

00:10:00.646 --> 00:10:02.866 A:middle
allocation in the same timeline

00:10:02.866 --> 00:10:04.116 A:middle
as all the other instruments.

00:10:05.046 --> 00:10:06.526 A:middle
This will allow you to identify

00:10:06.526 --> 00:10:07.746 A:middle
all those resources which you

00:10:07.746 --> 00:10:08.866 A:middle
are streaming from the main

00:10:08.866 --> 00:10:10.476 A:middle
render thread which could

00:10:10.476 --> 00:10:11.676 A:middle
potentially cause a stall.

00:10:12.786 --> 00:10:14.806 A:middle
Something else you should tune

00:10:14.806 --> 00:10:16.686 A:middle
as well is for thermals.

00:10:17.366 --> 00:10:18.936 A:middle
It is important that you design

00:10:18.936 --> 00:10:20.006 A:middle
your game for sustained

00:10:20.006 --> 00:10:20.716 A:middle
performance.

00:10:21.206 --> 00:10:22.466 A:middle
This will improve the overall

00:10:22.566 --> 00:10:24.466 A:middle
thermals of the system as well

00:10:24.466 --> 00:10:25.256 A:middle
as the stability and

00:10:25.256 --> 00:10:26.666 A:middle
responsiveness of your game.

00:10:27.526 --> 00:10:28.736 A:middle
So, the best practice will be

00:10:28.816 --> 00:10:31.026 A:middle
for you to test your game under

00:10:31.026 --> 00:10:32.166 A:middle
serious thermal state.

00:10:32.906 --> 00:10:34.856 A:middle
Also, consider tuning your game

00:10:35.216 --> 00:10:36.666 A:middle
for this serious thermal state

00:10:36.666 --> 00:10:38.086 A:middle
since that will hopefully help

00:10:38.086 --> 00:10:39.756 A:middle
you to know the thermal

00:10:39.756 --> 00:10:40.186 A:middle
throttle.

00:10:41.656 --> 00:10:44.256 A:middle
So, new this year, we're adding

00:10:44.256 --> 00:10:46.036 A:middle
Device Conditions into Xcode,

00:10:46.476 --> 00:10:47.816 A:middle
which will allow you to set the

00:10:47.876 --> 00:10:50.166 A:middle
serious thermal state directly

00:10:50.206 --> 00:10:51.396 A:middle
from the device's window.

00:10:52.596 --> 00:10:54.106 A:middle
There is a talk at the bottom

00:10:54.106 --> 00:10:55.066 A:middle
where this topic we'll be

00:10:55.066 --> 00:10:56.436 A:middle
covering to more detail and I

00:10:56.436 --> 00:10:57.506 A:middle
encourage you to watch.

00:10:59.896 --> 00:11:01.626 A:middle
Also, we can use the Xcode

00:10:59.896 --> 00:11:01.626 A:middle
Also, we can use the Xcode

00:11:01.626 --> 00:11:03.206 A:middle
Energy Gauge to verify the

00:11:03.206 --> 00:11:04.736 A:middle
thermal state that the device is

00:11:04.736 --> 00:11:05.166 A:middle
running at.

00:11:05.976 --> 00:11:07.126 A:middle
In this example, we are

00:11:07.126 --> 00:11:08.556 A:middle
conditioning our device to run

00:11:08.556 --> 00:11:10.576 A:middle
at serious thermal state and we

00:11:10.576 --> 00:11:11.966 A:middle
are effectively verifying that

00:11:11.966 --> 00:11:13.406 A:middle
the device get into serious

00:11:13.446 --> 00:11:14.056 A:middle
thermal state.

00:11:14.416 --> 00:11:15.336 A:middle
It just takes a couple of

00:11:15.336 --> 00:11:16.736 A:middle
seconds to ramp-up to that.

00:11:17.906 --> 00:11:19.386 A:middle
Cool. So, now let's move on to

00:11:19.386 --> 00:11:21.016 A:middle
the second part of our talk.

00:11:21.816 --> 00:11:23.416 A:middle
In this section, we'll talk

00:11:23.416 --> 00:11:25.266 A:middle
about memory bandwidth.

00:11:27.016 --> 00:11:28.146 A:middle
Memory bandwidth is very

00:11:28.146 --> 00:11:28.816 A:middle
important.

00:11:29.236 --> 00:11:30.936 A:middle
That is because memory transfers

00:11:30.936 --> 00:11:31.606 A:middle
are costly.

00:11:32.156 --> 00:11:33.836 A:middle
They consume power and generate

00:11:33.906 --> 00:11:34.166 A:middle
heat.

00:11:35.206 --> 00:11:37.346 A:middle
To help mitigate in that, iOS

00:11:37.346 --> 00:11:38.876 A:middle
devices have shared system

00:11:38.876 --> 00:11:40.476 A:middle
memory between the CPU and the

00:11:40.476 --> 00:11:43.056 A:middle
GPU as well as dedicated Tile

00:11:43.056 --> 00:11:44.416 A:middle
Memory for the GPU.

00:11:45.336 --> 00:11:46.926 A:middle
Metal is designed to help you

00:11:46.926 --> 00:11:48.376 A:middle
leverage both.

00:11:49.026 --> 00:11:50.786 A:middle
So, now, let's see how by start

00:11:50.786 --> 00:11:52.416 A:middle
looking into textures.

00:11:53.406 --> 00:11:55.166 A:middle
Texture sampling is probably the

00:11:55.166 --> 00:11:57.026 A:middle
main bandwidth consumer in your

00:11:57.026 --> 00:11:57.376 A:middle
game.

00:11:57.956 --> 00:11:59.376 A:middle
So, we have some best practices

00:11:59.376 --> 00:12:00.496 A:middle
for you to configure your

00:11:59.376 --> 00:12:00.496 A:middle
for you to configure your

00:12:00.496 --> 00:12:01.366 A:middle
textures correctly.

00:12:02.416 --> 00:12:03.876 A:middle
In this section, we will talk

00:12:03.876 --> 00:12:04.946 A:middle
about offline texture

00:12:04.946 --> 00:12:07.466 A:middle
compression for game assets, GPU

00:12:07.466 --> 00:12:09.486 A:middle
texture compression as well as

00:12:09.486 --> 00:12:10.816 A:middle
how to choose the correct pixel

00:12:10.816 --> 00:12:11.286 A:middle
format.

00:12:11.946 --> 00:12:13.026 A:middle
So, let's start with texture

00:12:13.026 --> 00:12:13.526 A:middle
assets.

00:12:14.056 --> 00:12:16.756 A:middle
It is very important for you to

00:12:16.756 --> 00:12:18.106 A:middle
compress your texture assets.

00:12:18.846 --> 00:12:20.886 A:middle
That is because sampling large

00:12:20.886 --> 00:12:23.066 A:middle
textures may be inefficient and

00:12:23.066 --> 00:12:24.196 A:middle
your assets may also be

00:12:24.196 --> 00:12:25.016 A:middle
arbitrarily large.

00:12:25.716 --> 00:12:26.756 A:middle
So make sure they are all

00:12:26.756 --> 00:12:29.446 A:middle
compressed and also generate

00:12:29.446 --> 00:12:30.916 A:middle
midmaps for all the textures

00:12:30.916 --> 00:12:31.996 A:middle
which may be minified.

00:12:32.476 --> 00:12:34.346 A:middle
So, let's see the memory savings

00:12:34.346 --> 00:12:35.396 A:middle
of texture compression.

00:12:35.976 --> 00:12:38.306 A:middle
This is one of the largest

00:12:38.336 --> 00:12:39.606 A:middle
textures of Afterpulse.

00:12:40.486 --> 00:12:42.326 A:middle
If this texture were to be

00:12:42.326 --> 00:12:44.226 A:middle
uncompressed, it would take

00:12:44.226 --> 00:12:46.296 A:middle
about 16 megabytes of memory to

00:12:46.296 --> 00:12:46.606 A:middle
load.

00:12:47.846 --> 00:12:49.886 A:middle
By using texture compression, we

00:12:49.886 --> 00:12:51.846 A:middle
can lower let-- this to less

00:12:51.846 --> 00:12:54.036 A:middle
than 3 megabytes including the

00:12:54.036 --> 00:12:55.106 A:middle
full mipmap chain.

00:12:55.876 --> 00:12:57.446 A:middle
Those are great memory savings.

00:12:58.546 --> 00:13:00.176 A:middle
Notice though, that Afterpulse

00:12:58.546 --> 00:13:00.176 A:middle
Notice though, that Afterpulse

00:13:00.176 --> 00:13:02.416 A:middle
is using PVRTC because it runs

00:13:02.576 --> 00:13:05.496 A:middle
on A7 devices such as the iPhone

00:13:05.496 --> 00:13:06.126 A:middle
5S.

00:13:07.066 --> 00:13:08.496 A:middle
If your game targets newer

00:13:08.496 --> 00:13:10.996 A:middle
devices, using STC instead since

00:13:10.996 --> 00:13:12.496 A:middle
it offers better compression

00:13:12.496 --> 00:13:13.726 A:middle
ratio in image quality.

00:13:15.206 --> 00:13:16.596 A:middle
To verify that our assets our

00:13:16.596 --> 00:13:18.736 A:middle
compressed correctly, we can use

00:13:18.736 --> 00:13:19.596 A:middle
the Memory Viewer.

00:13:21.026 --> 00:13:22.186 A:middle
The Metal Memory Viewer is a

00:13:22.186 --> 00:13:23.636 A:middle
great tool which I will fully

00:13:23.636 --> 00:13:24.636 A:middle
introduce in the memory

00:13:24.636 --> 00:13:25.496 A:middle
footprint section.

00:13:26.166 --> 00:13:28.446 A:middle
For now, will you-- we will use

00:13:28.446 --> 00:13:30.086 A:middle
it to inspect all of our assets.

00:13:30.566 --> 00:13:31.626 A:middle
We can double check they are

00:13:31.626 --> 00:13:33.796 A:middle
compressed, mipmapped, and also

00:13:33.796 --> 00:13:34.886 A:middle
look great.

00:13:36.216 --> 00:13:38.246 A:middle
But what happens with all those

00:13:38.246 --> 00:13:40.166 A:middle
textures which you cannot

00:13:40.216 --> 00:13:42.676 A:middle
compress ahead of time such as

00:13:42.676 --> 00:13:43.956 A:middle
render targets or all the

00:13:43.956 --> 00:13:47.566 A:middle
textures generated at runtime?

00:13:47.566 --> 00:13:49.316 A:middle
The latest iOS GPU support

00:13:49.316 --> 00:13:50.626 A:middle
lossless texture compression,

00:13:51.146 --> 00:13:52.706 A:middle
which allows the GPU to compress

00:13:52.706 --> 00:13:54.126 A:middle
textures for faster access.

00:13:55.486 --> 00:13:56.806 A:middle
So, the next best practice is

00:13:57.076 --> 00:13:58.216 A:middle
for you to optimize your

00:13:58.286 --> 00:13:59.906 A:middle
textures so the GPU can have

00:13:59.906 --> 00:14:00.716 A:middle
faster access.

00:13:59.906 --> 00:14:00.716 A:middle
faster access.

00:14:01.646 --> 00:14:02.856 A:middle
It is very important that you

00:14:02.856 --> 00:14:03.986 A:middle
configure your textures

00:14:03.986 --> 00:14:04.466 A:middle
correctly.

00:14:05.106 --> 00:14:06.406 A:middle
You will want to use private

00:14:06.406 --> 00:14:08.486 A:middle
storage mode, so only the GPU

00:14:08.486 --> 00:14:10.036 A:middle
has access to the texture data

00:14:10.146 --> 00:14:11.986 A:middle
and it allows it to optimize the

00:14:11.986 --> 00:14:12.506 A:middle
contents.

00:14:12.966 --> 00:14:14.956 A:middle
Also, do not set the unknown

00:14:14.956 --> 00:14:16.796 A:middle
usage flag and avoid setting

00:14:16.796 --> 00:14:18.516 A:middle
unnecessary usage flag such as

00:14:18.516 --> 00:14:21.056 A:middle
shaderWrite or pixelView, since

00:14:21.056 --> 00:14:22.246 A:middle
those may disable this

00:14:22.246 --> 00:14:22.836 A:middle
compression.

00:14:23.716 --> 00:14:25.706 A:middle
Shared textures which can be

00:14:25.706 --> 00:14:27.866 A:middle
acces by the CPU and the GPU

00:14:28.246 --> 00:14:29.916 A:middle
should explicitly be optimized

00:14:30.376 --> 00:14:32.166 A:middle
after any CPU update on their

00:14:32.166 --> 00:14:32.556 A:middle
data.

00:14:32.936 --> 00:14:34.226 A:middle
It is also important for you to

00:14:34.226 --> 00:14:34.616 A:middle
do so.

00:14:35.206 --> 00:14:36.516 A:middle
So, let's see how can we do both

00:14:36.516 --> 00:14:37.446 A:middle
things with a little bit of

00:14:37.536 --> 00:14:37.836 A:middle
code.

00:14:38.146 --> 00:14:39.966 A:middle
And it really is just a little

00:14:39.966 --> 00:14:40.476 A:middle
bit of code.

00:14:41.036 --> 00:14:42.996 A:middle
To create an optimal texture, we

00:14:42.996 --> 00:14:44.266 A:middle
will want to set the storage

00:14:44.266 --> 00:14:45.076 A:middle
mode as private.

00:14:45.276 --> 00:14:46.986 A:middle
So, only the GPU has access to

00:14:48.126 --> 00:14:48.336 A:middle
it.

00:14:48.336 --> 00:14:49.826 A:middle
And also, we will want to set

00:14:50.296 --> 00:14:53.126 A:middle
explicit yet conservative usage

00:14:53.126 --> 00:14:53.436 A:middle
flags.

00:14:54.746 --> 00:14:56.156 A:middle
In this case, we want to use the

00:14:56.156 --> 00:14:57.346 A:middle
texture as an intermediate

00:14:57.346 --> 00:14:58.786 A:middle
render targets so we do not need

00:14:58.786 --> 00:14:59.806 A:middle
any other usage flag.

00:15:00.306 --> 00:15:03.106 A:middle
But what about shared textures?

00:15:03.806 --> 00:15:05.076 A:middle
Well, those are a bit trickier.

00:15:05.726 --> 00:15:07.016 A:middle
So, shared textures can be

00:15:07.016 --> 00:15:08.836 A:middle
accessed by both the CPU and the

00:15:08.836 --> 00:15:09.486 A:middle
GPU.

00:15:10.386 --> 00:15:12.946 A:middle
So, if the CPU updates a region

00:15:12.946 --> 00:15:14.236 A:middle
of the texture or any of the

00:15:14.276 --> 00:15:16.906 A:middle
texture data, we may need to

00:15:16.906 --> 00:15:18.806 A:middle
explicitly ask the GPU to

00:15:18.806 --> 00:15:20.236 A:middle
optimize its contents.

00:15:21.046 --> 00:15:22.406 A:middle
Notice that there is a trade-off

00:15:22.406 --> 00:15:24.036 A:middle
here between how many times does

00:15:24.036 --> 00:15:25.836 A:middle
the CPU update the data and how

00:15:25.836 --> 00:15:27.336 A:middle
many times does the GPU need to

00:15:27.336 --> 00:15:28.346 A:middle
access it afterwards.

00:15:29.026 --> 00:15:32.096 A:middle
So the Memory Viewer will

00:15:32.096 --> 00:15:33.556 A:middle
actually be a great tool again

00:15:33.726 --> 00:15:34.796 A:middle
to help us with this.

00:15:35.396 --> 00:15:37.086 A:middle
That is because we can configure

00:15:37.086 --> 00:15:39.196 A:middle
the Memory Viewer to show both

00:15:39.196 --> 00:15:40.756 A:middle
the Storage Mode and Usage flag

00:15:40.826 --> 00:15:41.866 A:middle
for all of our textures.

00:15:42.556 --> 00:15:44.096 A:middle
From this single screen we can

00:15:44.096 --> 00:15:46.356 A:middle
see our compressed textures and

00:15:46.356 --> 00:15:47.866 A:middle
identify all of those which

00:15:47.946 --> 00:15:49.486 A:middle
could be configured correctly.

00:15:50.426 --> 00:15:51.276 A:middle
It is a great tool.

00:15:52.506 --> 00:15:54.596 A:middle
At this point we are almost done

00:15:54.596 --> 00:15:55.796 A:middle
configuring our textures.

00:15:56.516 --> 00:15:57.926 A:middle
We just need to choose the right

00:15:57.926 --> 00:15:58.846 A:middle
pixel format.

00:16:00.386 --> 00:16:02.006 A:middle
Larger pixel format will use

00:16:02.006 --> 00:16:03.656 A:middle
more bandwidth, so the best

00:16:03.656 --> 00:16:05.536 A:middle
practice will be for you to

00:16:05.536 --> 00:16:07.096 A:middle
avoid using pixel formats with

00:16:07.096 --> 00:16:09.346 A:middle
unnecessary channels and also

00:16:09.346 --> 00:16:10.926 A:middle
try to lower precision whenever

00:16:10.926 --> 00:16:11.436 A:middle
possible.

00:16:12.706 --> 00:16:14.176 A:middle
Notice though that the sampling

00:16:14.176 --> 00:16:16.166 A:middle
rate itself will also depend on

00:16:16.166 --> 00:16:17.176 A:middle
the pixel format.

00:16:18.176 --> 00:16:20.526 A:middle
In this case, we can see how the

00:16:20.616 --> 00:16:22.586 A:middle
pixel format has a direct impact

00:16:22.586 --> 00:16:24.166 A:middle
on the texture sampling rate of

00:16:24.166 --> 00:16:24.936 A:middle
our GPUs.

00:16:25.656 --> 00:16:27.566 A:middle
Particularly, you will want to

00:16:27.566 --> 00:16:30.456 A:middle
watch out for 128-bit formats

00:16:30.906 --> 00:16:33.576 A:middle
such as RGBA 32-bit float, since

00:16:33.576 --> 00:16:34.876 A:middle
those are sampled at quarter

00:16:34.876 --> 00:16:35.216 A:middle
rate.

00:16:36.176 --> 00:16:37.856 A:middle
Oftentimes these high precision

00:16:37.856 --> 00:16:39.236 A:middle
formats are used for noise

00:16:39.236 --> 00:16:41.246 A:middle
textures or lookup tables for

00:16:41.246 --> 00:16:43.086 A:middle
the post-process effects.

00:16:44.406 --> 00:16:45.926 A:middle
Once again we can use the Memory

00:16:45.926 --> 00:16:47.266 A:middle
Viewer to help us with that.

00:16:48.116 --> 00:16:49.416 A:middle
The Memory Viewer will let us

00:16:49.416 --> 00:16:51.276 A:middle
filter textures by name or pixel

00:16:51.276 --> 00:16:51.726 A:middle
format.

00:16:52.706 --> 00:16:54.046 A:middle
So, we will verify that our

00:16:54.046 --> 00:16:56.486 A:middle
Metal Demo is using 16-bit

00:16:56.586 --> 00:16:57.826 A:middle
formats for the SSAO

00:16:57.826 --> 00:16:58.696 A:middle
implementation.

00:16:59.536 --> 00:17:00.886 A:middle
This is very important for the

00:16:59.536 --> 00:17:00.886 A:middle
This is very important for the

00:17:00.886 --> 00:17:01.696 A:middle
noise textures.

00:17:03.026 --> 00:17:04.296 A:middle
Notice something else though,

00:17:04.346 --> 00:17:06.786 A:middle
and this that in this example

00:17:07.226 --> 00:17:08.435 A:middle
most of the textures are

00:17:08.435 --> 00:17:09.726 A:middle
actually render targets.

00:17:10.746 --> 00:17:12.626 A:middle
So as games become more complex,

00:17:12.626 --> 00:17:13.866 A:middle
the texture used as render

00:17:13.945 --> 00:17:16.006 A:middle
targets may actually consume a

00:17:16.006 --> 00:17:17.796 A:middle
lot of bandwidth as well, so

00:17:17.796 --> 00:17:18.866 A:middle
let's have a closer look.

00:17:19.356 --> 00:17:22.046 A:middle
In this section, we will review

00:17:22.046 --> 00:17:23.195 A:middle
render pass load and store

00:17:23.195 --> 00:17:25.276 A:middle
actions, paying close attention

00:17:25.356 --> 00:17:27.695 A:middle
to MSAA and also talk a bit

00:17:27.695 --> 00:17:28.596 A:middle
about Tile Memory.

00:17:29.866 --> 00:17:31.006 A:middle
So let's get started with

00:17:31.186 --> 00:17:32.446 A:middle
optimizing load and store

00:17:32.446 --> 00:17:32.936 A:middle
actions.

00:17:34.916 --> 00:17:36.336 A:middle
You should avoid loading or

00:17:36.336 --> 00:17:37.546 A:middle
storing render targets

00:17:37.546 --> 00:17:38.326 A:middle
unnecessary.

00:17:39.356 --> 00:17:40.706 A:middle
Render target load and store

00:17:40.706 --> 00:17:42.076 A:middle
actions are very easy to

00:17:42.076 --> 00:17:44.026 A:middle
overlook and may actually quite

00:17:44.026 --> 00:17:45.306 A:middle
quickly become a problem.

00:17:45.996 --> 00:17:47.866 A:middle
So please make sure to keep

00:17:47.866 --> 00:17:48.586 A:middle
those in check.

00:17:49.516 --> 00:17:50.926 A:middle
And it is actually quite easy to

00:17:50.926 --> 00:17:52.706 A:middle
do so, with again just a little

00:17:52.706 --> 00:17:53.606 A:middle
tiny bit of code.

00:17:54.496 --> 00:17:55.756 A:middle
In this case, we are configuring

00:17:55.756 --> 00:17:57.806 A:middle
a render pass descriptor and we

00:17:57.806 --> 00:17:59.296 A:middle
want the color attachment 1 to

00:17:59.296 --> 00:18:00.656 A:middle
be transient, which means we

00:17:59.296 --> 00:18:00.656 A:middle
be transient, which means we

00:18:00.656 --> 00:18:01.806 A:middle
don't want to load or store

00:18:01.806 --> 00:18:02.536 A:middle
anything from it.

00:18:03.426 --> 00:18:05.556 A:middle
It is a simple as setting the

00:18:05.596 --> 00:18:07.146 A:middle
correct load and store actions.

00:18:07.706 --> 00:18:09.336 A:middle
We want the load action to be

00:18:09.336 --> 00:18:11.136 A:middle
clear, so no later gets transfer

00:18:12.036 --> 00:18:13.166 A:middle
to the on chip GPU.

00:18:13.646 --> 00:18:16.296 A:middle
And we want to store action to

00:18:16.296 --> 00:18:17.106 A:middle
be, DontCare.

00:18:17.686 --> 00:18:19.536 A:middle
So no data needs to be written

00:18:19.536 --> 00:18:20.716 A:middle
at the end of the render pass.

00:18:21.536 --> 00:18:22.726 A:middle
That's all there is to it,

00:18:23.396 --> 00:18:24.676 A:middle
verifying that we have done the

00:18:24.676 --> 00:18:26.456 A:middle
right thing is also very simple,

00:18:27.246 --> 00:18:28.476 A:middle
we can use the Dependency

00:18:28.476 --> 00:18:28.846 A:middle
Viewer.

00:18:29.416 --> 00:18:32.726 A:middle
In this case, our Metal example

00:18:32.806 --> 00:18:34.336 A:middle
is storing the color attachment

00:18:34.336 --> 00:18:35.876 A:middle
1, even though it's not used

00:18:35.876 --> 00:18:36.436 A:middle
later on.

00:18:37.246 --> 00:18:38.716 A:middle
The Dependency Viewer will show

00:18:38.716 --> 00:18:40.286 A:middle
an issue icon to highlight this

00:18:40.326 --> 00:18:40.786 A:middle
problem.

00:18:41.746 --> 00:18:42.996 A:middle
We should simply set the

00:18:42.996 --> 00:18:44.786 A:middle
DontCare store action as we have

00:18:44.786 --> 00:18:46.216 A:middle
just seen in the previous slide

00:18:46.216 --> 00:18:48.026 A:middle
and the problem will go away.

00:18:48.556 --> 00:18:51.476 A:middle
It is really as simple as that.

00:18:51.996 --> 00:18:54.016 A:middle
This is particularly important

00:18:54.626 --> 00:18:56.006 A:middle
for multi-sampled render

00:18:56.076 --> 00:18:56.546 A:middle
targets.

00:18:57.076 --> 00:19:00.446 A:middle
iOS devices have very fast MSAA,

00:18:57.076 --> 00:19:00.446 A:middle
iOS devices have very fast MSAA,

00:19:01.116 --> 00:19:02.466 A:middle
that is because the result

00:19:02.756 --> 00:19:04.396 A:middle
happens from Tile Memory, so it

00:19:04.396 --> 00:19:05.946 A:middle
does not consume any extra

00:19:05.946 --> 00:19:06.356 A:middle
bandwidth.

00:19:07.306 --> 00:19:09.046 A:middle
This also allows us to declare

00:19:09.176 --> 00:19:10.726 A:middle
the multisampled textures fully

00:19:10.726 --> 00:19:11.316 A:middle
transient.

00:19:11.836 --> 00:19:13.216 A:middle
In fact, we don't even need a

00:19:13.216 --> 00:19:14.816 A:middle
system memory allocation to back

00:19:14.816 --> 00:19:15.796 A:middle
it in the first place.

00:19:15.956 --> 00:19:17.816 A:middle
So the best practice will be for

00:19:17.816 --> 00:19:19.766 A:middle
you to consider MSAA over native

00:19:19.766 --> 00:19:21.186 A:middle
resolution, since it's very

00:19:21.186 --> 00:19:23.486 A:middle
efficient, and also make sure to

00:19:23.486 --> 00:19:24.646 A:middle
not load or store the

00:19:24.646 --> 00:19:25.876 A:middle
multisample texture.

00:19:26.686 --> 00:19:27.876 A:middle
And since you're at it set the

00:19:27.876 --> 00:19:29.476 A:middle
storage mode of the multisample

00:19:29.476 --> 00:19:30.766 A:middle
texture to memoryless.

00:19:31.766 --> 00:19:32.746 A:middle
I will fully introduce

00:19:32.746 --> 00:19:34.246 A:middle
memoryless later on the talk.

00:19:34.246 --> 00:19:35.726 A:middle
For now, let's see how can we

00:19:35.726 --> 00:19:37.396 A:middle
configure a multisample texture

00:19:37.396 --> 00:19:38.666 A:middle
and the render pass that uses

00:19:38.666 --> 00:19:38.896 A:middle
it.

00:19:39.376 --> 00:19:42.066 A:middle
In this case, we just need to

00:19:42.066 --> 00:19:43.616 A:middle
set the memoryless storage mode,

00:19:44.516 --> 00:19:46.006 A:middle
and also make sure that the

00:19:46.006 --> 00:19:48.286 A:middle
render pass is using it, clears

00:19:48.286 --> 00:19:49.976 A:middle
its contents and discards the

00:19:49.976 --> 00:19:50.576 A:middle
samples.

00:19:51.286 --> 00:19:53.076 A:middle
We only want the multisample

00:19:53.076 --> 00:19:54.676 A:middle
texture to resolve from.

00:19:55.086 --> 00:19:56.426 A:middle
We do not need to store it.

00:19:56.556 --> 00:19:57.936 A:middle
We do not want that intermediate

00:19:57.936 --> 00:19:58.806 A:middle
data to be stored.

00:19:59.476 --> 00:20:01.446 A:middle
Only the final resolve texture

00:19:59.476 --> 00:20:01.446 A:middle
Only the final resolve texture

00:20:01.446 --> 00:20:02.116 A:middle
should be stored.

00:20:03.316 --> 00:20:04.586 A:middle
We can once more use the

00:20:04.586 --> 00:20:06.436 A:middle
Dependency Viewer to help us

00:20:06.436 --> 00:20:08.396 A:middle
verify that we are doing the

00:20:08.726 --> 00:20:10.046 A:middle
right thing.

00:20:10.166 --> 00:20:12.026 A:middle
In this case, our Metal example

00:20:12.026 --> 00:20:13.216 A:middle
is loading and starting the

00:20:13.216 --> 00:20:15.436 A:middle
multisample texture which is

00:20:15.436 --> 00:20:16.326 A:middle
very costly.

00:20:17.526 --> 00:20:18.946 A:middle
After setting the correct flag

00:20:19.056 --> 00:20:21.006 A:middle
just as I've shown you, we will

00:20:21.006 --> 00:20:24.896 A:middle
save our 85 memory, sorry, 85

00:20:24.966 --> 00:20:27.246 A:middle
megabytes of memory bandwidth

00:20:27.246 --> 00:20:28.426 A:middle
and also footprint.

00:20:29.536 --> 00:20:30.806 A:middle
And this is very important for

00:20:30.806 --> 00:20:32.306 A:middle
you to verify the multisample

00:20:32.306 --> 00:20:32.986 A:middle
attachments.

00:20:33.836 --> 00:20:36.486 A:middle
But notice that those savings

00:20:36.596 --> 00:20:39.156 A:middle
are only possible because we are

00:20:39.156 --> 00:20:41.056 A:middle
implicitly leveraging Tile

00:20:42.226 --> 00:20:44.386 A:middle
Memory by using MSAA.

00:20:45.286 --> 00:20:46.776 A:middle
So the next best practice is for

00:20:46.776 --> 00:20:48.636 A:middle
you to explicitly leverage Tile

00:20:48.636 --> 00:20:49.036 A:middle
Memory.

00:20:50.186 --> 00:20:51.696 A:middle
Metal provides access to Tile

00:20:51.696 --> 00:20:53.736 A:middle
Memory for several features such

00:20:53.736 --> 00:20:55.616 A:middle
as programmable blending, image

00:20:55.616 --> 00:20:57.166 A:middle
block, and tile shaders.

00:20:57.996 --> 00:21:00.256 A:middle
The best practice is for you to

00:20:57.996 --> 00:21:00.256 A:middle
The best practice is for you to

00:21:00.256 --> 00:21:01.646 A:middle
explicitly utilize it,

00:21:02.146 --> 00:21:04.416 A:middle
particularly to implement more

00:21:04.416 --> 00:21:05.886 A:middle
advanced rendering techniques.

00:21:06.886 --> 00:21:08.926 A:middle
The Modern Rendering with Metal

00:21:08.926 --> 00:21:10.536 A:middle
talk will cover-- has covered

00:21:10.536 --> 00:21:11.586 A:middle
some of these techniques in

00:21:11.586 --> 00:21:11.926 A:middle
detail.

00:21:13.046 --> 00:21:14.366 A:middle
For now we will just have a

00:21:14.416 --> 00:21:15.826 A:middle
quick look at deferred shading.

00:21:17.436 --> 00:21:19.676 A:middle
Deferred shading is considered

00:21:19.676 --> 00:21:22.206 A:middle
to be very bandwidth heavy that

00:21:22.206 --> 00:21:24.166 A:middle
is because traditionally it

00:21:24.166 --> 00:21:25.626 A:middle
requires the application to

00:21:25.626 --> 00:21:27.196 A:middle
store the geometry information

00:21:27.466 --> 00:21:29.846 A:middle
or G-Buffer as a set of textures

00:21:29.846 --> 00:21:31.426 A:middle
representing several pixel

00:21:31.486 --> 00:21:32.056 A:middle
properties.

00:21:32.966 --> 00:21:34.796 A:middle
Those textures are then sampled

00:21:34.796 --> 00:21:36.066 A:middle
in the second lighting pass,

00:21:36.576 --> 00:21:37.826 A:middle
where the final color is

00:21:37.826 --> 00:21:39.396 A:middle
accumulated in a render target.

00:21:40.316 --> 00:21:42.686 A:middle
Notice that we are storing and

00:21:42.686 --> 00:21:44.776 A:middle
then loading all this data from

00:21:44.776 --> 00:21:46.186 A:middle
the G-Buffer, so that's why it's

00:21:46.226 --> 00:21:47.016 A:middle
bandwidth heavy.

00:21:47.356 --> 00:21:50.136 A:middle
iOS allows you to be much more

00:21:50.136 --> 00:21:52.646 A:middle
efficient than that.

00:21:53.576 --> 00:21:54.956 A:middle
On iOS, we can leverage

00:21:54.986 --> 00:21:56.876 A:middle
programmable blending, a feature

00:21:56.876 --> 00:21:58.606 A:middle
that allows fragment shaders to

00:21:58.606 --> 00:22:01.076 A:middle
access pixel data directly from

00:21:58.606 --> 00:22:01.076 A:middle
access pixel data directly from

00:22:01.076 --> 00:22:01.746 A:middle
Tile Memory.

00:22:02.646 --> 00:22:04.096 A:middle
This means that the G-buffer

00:22:04.096 --> 00:22:05.756 A:middle
data can be stored on Tile

00:22:05.756 --> 00:22:07.766 A:middle
Memory and access within the

00:22:07.766 --> 00:22:10.026 A:middle
same render pass by all the

00:22:10.026 --> 00:22:11.456 A:middle
light accumulation shaders.

00:22:12.196 --> 00:22:13.896 A:middle
It is a very powerful feature

00:22:15.116 --> 00:22:16.526 A:middle
which Digital Legends has been

00:22:16.526 --> 00:22:17.936 A:middle
utilizing for years.

00:22:18.776 --> 00:22:20.246 A:middle
This is how the single pass

00:22:20.246 --> 00:22:21.946 A:middle
deferred render of Afterpulse

00:22:22.306 --> 00:22:23.256 A:middle
looks like through the

00:22:23.256 --> 00:22:24.726 A:middle
Dependency Viewer, it's

00:22:24.726 --> 00:22:25.276 A:middle
beautiful.

00:22:25.926 --> 00:22:27.296 A:middle
The four G-Buffer attachments

00:22:27.296 --> 00:22:29.266 A:middle
are fully transient, and only

00:22:29.266 --> 00:22:31.056 A:middle
the final color and depth are

00:22:31.056 --> 00:22:32.146 A:middle
stored, so it's not only

00:22:32.146 --> 00:22:33.806 A:middle
beautiful it's also efficient.

00:22:34.686 --> 00:22:36.006 A:middle
So, now, please let's welcome

00:22:36.006 --> 00:22:37.856 A:middle
Samuel on stage for the demo of

00:22:37.856 --> 00:22:38.756 A:middle
the Dependency Viewer.

00:22:39.516 --> 00:22:43.500 A:middle
[ Applause ]

00:22:48.636 --> 00:22:49.516 A:middle
&gt;&gt; Thanks Guillem.

00:22:50.076 --> 00:22:51.616 A:middle
So, we've just captured an old

00:22:51.616 --> 00:22:53.206 A:middle
version of Afterpulse and want

00:22:53.206 --> 00:22:54.106 A:middle
to see if there are any

00:22:54.106 --> 00:22:55.746 A:middle
optimizations that we can make

00:22:56.006 --> 00:22:57.146 A:middle
to improve its performance.

00:22:58.556 --> 00:22:59.866 A:middle
I'm now going to use the

00:22:59.866 --> 00:23:01.586 A:middle
Dependency Viewer in the Metal

00:22:59.866 --> 00:23:01.586 A:middle
Dependency Viewer in the Metal

00:23:01.586 --> 00:23:03.166 A:middle
Frame Debugger to show some of

00:23:03.166 --> 00:23:04.536 A:middle
the issues that Guillem just

00:23:04.536 --> 00:23:04.916 A:middle
mentioned.

00:23:05.676 --> 00:23:08.846 A:middle
So to begin, let's click on the

00:23:08.846 --> 00:23:10.556 A:middle
CommandBuffer to open the

00:23:10.556 --> 00:23:12.206 A:middle
Dependency Viewer.

00:23:12.856 --> 00:23:16.576 A:middle
The Dependency Viewer shows us

00:23:16.576 --> 00:23:18.856 A:middle
all of the GPU passes encoded by

00:23:19.686 --> 00:23:20.646 A:middle
an app.

00:23:20.926 --> 00:23:22.656 A:middle
We can see that Afterpulse has

00:23:22.656 --> 00:23:24.816 A:middle
one CommandBuffer and begins its

00:23:24.816 --> 00:23:26.606 A:middle
frame by rendering a Shadow Map.

00:23:27.356 --> 00:23:30.606 A:middle
Followed by Deferred Phase, this

00:23:30.606 --> 00:23:31.596 A:middle
feeds into Luminance

00:23:31.596 --> 00:23:33.286 A:middle
Calculations, Particle

00:23:33.286 --> 00:23:35.286 A:middle
Simulations, and a Bloom Chain

00:23:35.886 --> 00:23:37.196 A:middle
which is used by the final

00:23:37.196 --> 00:23:38.646 A:middle
screen pass.

00:23:39.516 --> 00:23:40.666 A:middle
Now, the Dependency Viewer is

00:23:40.666 --> 00:23:42.276 A:middle
much more compact this year if

00:23:42.276 --> 00:23:44.046 A:middle
you have groups, and it's really

00:23:44.046 --> 00:23:46.096 A:middle
easy to see at a high level, how

00:23:46.096 --> 00:23:46.966 A:middle
the frame is rendered.

00:23:48.026 --> 00:23:49.806 A:middle
We can even go deeper into any

00:23:49.806 --> 00:23:51.656 A:middle
group if we want more detail.

00:23:52.416 --> 00:23:54.396 A:middle
So, in reality this Bloom Chain

00:23:54.956 --> 00:23:56.496 A:middle
is actually 12 passes.

00:23:57.066 --> 00:24:00.016 A:middle
Now, the Dependency Viewer is a

00:23:57.066 --> 00:24:00.016 A:middle
Now, the Dependency Viewer is a

00:24:00.016 --> 00:24:01.516 A:middle
great place to find some of the

00:24:01.516 --> 00:24:02.656 A:middle
issues that Guillem mentioned.

00:24:03.166 --> 00:24:04.606 A:middle
And we can see a few on this

00:24:04.606 --> 00:24:05.296 A:middle
final screen pass.

00:24:05.296 --> 00:24:08.026 A:middle
So let's click on the issue icon

00:24:08.306 --> 00:24:09.106 A:middle
to find out more.

00:24:09.746 --> 00:24:12.656 A:middle
So, it looks like one of the

00:24:12.656 --> 00:24:14.466 A:middle
load store action issues that

00:24:14.466 --> 00:24:15.446 A:middle
Guillem mentioned earlier.

00:24:16.496 --> 00:24:17.856 A:middle
So they've set the store action

00:24:17.856 --> 00:24:19.866 A:middle
to store, but they're not using

00:24:19.866 --> 00:24:20.936 A:middle
this texture again in this

00:24:20.936 --> 00:24:21.196 A:middle
frame.

00:24:22.066 --> 00:24:23.626 A:middle
So the issue recommends we

00:24:23.626 --> 00:24:24.946 A:middle
should instead set it to

00:24:24.946 --> 00:24:27.056 A:middle
DontCare and we'll get back

00:24:27.056 --> 00:24:28.886 A:middle
almost 14 megabytes of memory

00:24:28.886 --> 00:24:30.806 A:middle
bandwidth for these two textures

00:24:30.806 --> 00:24:31.286 A:middle
combined.

00:24:31.906 --> 00:24:34.676 A:middle
So this year we've made it even

00:24:34.676 --> 00:24:36.336 A:middle
easier to find all of the issues

00:24:36.376 --> 00:24:38.436 A:middle
in the graph, simply click on

00:24:38.436 --> 00:24:39.966 A:middle
the new issues button on the

00:24:39.966 --> 00:24:42.786 A:middle
bottom right to see a list of

00:24:46.156 --> 00:24:46.316 A:middle
issues.

00:24:46.466 --> 00:24:47.726 A:middle
Now, another best practice that

00:24:47.726 --> 00:24:48.956 A:middle
Guillem mentioned was choosing

00:24:48.956 --> 00:24:51.016 A:middle
the correct pixel format.

00:24:51.556 --> 00:24:52.936 A:middle
So this year on iOS we've

00:24:52.936 --> 00:24:54.756 A:middle
introduced the new Depth 16

00:24:54.756 --> 00:24:56.806 A:middle
Format, so let's use the new

00:24:56.806 --> 00:24:58.996 A:middle
search to look for Depth 32

00:24:58.996 --> 00:25:00.246 A:middle
textures.

00:24:58.996 --> 00:25:00.246 A:middle
textures.

00:25:03.266 --> 00:25:04.666 A:middle
So it looks like they're using

00:25:04.736 --> 00:25:06.636 A:middle
36 megabytes of memory for the

00:25:06.636 --> 00:25:07.596 A:middle
Shadow Map texture.

00:25:08.506 --> 00:25:09.536 A:middle
So when the team at Digital

00:25:09.536 --> 00:25:11.356 A:middle
Legends gets back to Barcelona

00:25:11.356 --> 00:25:12.836 A:middle
after Dub-Dub, they can

00:25:12.836 --> 00:25:14.316 A:middle
investigate using this new

00:25:14.316 --> 00:25:16.646 A:middle
format and potentially save half

00:25:16.686 --> 00:25:18.126 A:middle
the memory if their shadow

00:25:18.126 --> 00:25:20.196 A:middle
requirements allow for it.

00:25:20.746 --> 00:25:22.166 A:middle
If we continue searching through

00:25:22.166 --> 00:25:24.046 A:middle
the graph, where you can see

00:25:24.046 --> 00:25:25.596 A:middle
that there's plenty of potential

00:25:25.596 --> 00:25:26.396 A:middle
memory savings.

00:25:27.066 --> 00:25:29.436 A:middle
So if you use the Dependency

00:25:29.436 --> 00:25:30.576 A:middle
Viewer in the Metal Frame

00:25:30.576 --> 00:25:32.566 A:middle
Debugger to find and diagnose a

00:25:32.616 --> 00:25:34.736 A:middle
few issues in the old version of

00:25:34.736 --> 00:25:35.276 A:middle
Afterpulse.

00:25:36.116 --> 00:25:37.146 A:middle
So, Digital Legends have

00:25:37.146 --> 00:25:38.326 A:middle
actually made some of these

00:25:38.326 --> 00:25:39.026 A:middle
improvements.

00:25:39.386 --> 00:25:40.386 A:middle
So let's take a quick look.

00:25:40.976 --> 00:25:43.906 A:middle
We can immediately see that they

00:25:43.906 --> 00:25:45.226 A:middle
are now using multiple command

00:25:45.226 --> 00:25:45.686 A:middle
buffers.

00:25:46.376 --> 00:25:47.746 A:middle
So this will fix the issue that

00:25:47.746 --> 00:25:49.196 A:middle
Guillem showed us earlier where

00:25:49.196 --> 00:25:51.056 A:middle
the CPU was blocked waiting for

00:25:51.056 --> 00:25:52.776 A:middle
the next drawable and the GPU

00:25:52.776 --> 00:25:53.276 A:middle
was idle.

00:25:53.866 --> 00:25:56.006 A:middle
If we zoom in to the final

00:25:56.006 --> 00:25:58.586 A:middle
screen pass, we can see that

00:25:58.586 --> 00:25:59.936 A:middle
they've fixed the store action

00:25:59.936 --> 00:26:00.276 A:middle
issue.

00:25:59.936 --> 00:26:00.276 A:middle
issue.

00:26:01.386 --> 00:26:02.886 A:middle
In fact, because these two

00:26:02.886 --> 00:26:04.906 A:middle
textures are fully transient and

00:26:04.906 --> 00:26:06.136 A:middle
they've set the storage mode to

00:26:06.136 --> 00:26:08.116 A:middle
memoryless, they're not using

00:26:08.116 --> 00:26:09.616 A:middle
any system memory at all.

00:26:11.016 --> 00:26:13.326 A:middle
So, Dependency really is a great

00:26:13.366 --> 00:26:14.916 A:middle
place to start debugging your

00:26:14.916 --> 00:26:15.636 A:middle
render pipeline.

00:26:16.526 --> 00:26:17.856 A:middle
Back to Guillem who will talk

00:26:17.856 --> 00:26:18.926 A:middle
about some amazing best

00:26:18.926 --> 00:26:20.936 A:middle
practices in optimizing your

00:26:20.936 --> 00:26:21.926 A:middle
apps memory footprint.

00:26:22.516 --> 00:26:29.056 A:middle
[ Applause ]

00:26:29.556 --> 00:26:30.986 A:middle
&gt;&gt; Thank you Sam that was an

00:26:30.986 --> 00:26:31.756 A:middle
awesome demo.

00:26:31.886 --> 00:26:33.156 A:middle
I hope you guys will also use

00:26:33.156 --> 00:26:34.116 A:middle
the Dependency Viewer.

00:26:35.296 --> 00:26:36.556 A:middle
Cool. So, let's move on to the

00:26:36.556 --> 00:26:38.906 A:middle
last part of the talk, memory

00:26:38.906 --> 00:26:39.476 A:middle
footprint.

00:26:40.786 --> 00:26:42.216 A:middle
Memory footprint is actually

00:26:42.216 --> 00:26:43.676 A:middle
very important for your game.

00:26:44.616 --> 00:26:46.696 A:middle
That is because iOS enforces a

00:26:46.696 --> 00:26:48.436 A:middle
strict application memory limit

00:26:48.896 --> 00:26:50.506 A:middle
in order to keep both the system

00:26:50.506 --> 00:26:52.066 A:middle
on your application responsive.

00:26:52.756 --> 00:26:56.016 A:middle
As some of you may have noticed

00:26:56.016 --> 00:26:58.326 A:middle
iOS 12 introduce some changes in

00:26:58.326 --> 00:26:59.706 A:middle
the way memory is accounted.

00:27:00.816 --> 00:27:02.606 A:middle
This accounting change affects

00:27:02.606 --> 00:27:03.946 A:middle
mostly Metal resources.

00:27:04.976 --> 00:27:06.736 A:middle
Metal resources such as buffers

00:27:06.736 --> 00:27:08.836 A:middle
or textures may be the bulk of

00:27:08.876 --> 00:27:09.976 A:middle
your application's memory

00:27:09.976 --> 00:27:10.496 A:middle
footprint.

00:27:10.946 --> 00:27:12.346 A:middle
So, it is important for you to

00:27:12.346 --> 00:27:13.636 A:middle
measure the memory footprint of

00:27:13.636 --> 00:27:14.166 A:middle
your game.

00:27:14.916 --> 00:27:16.356 A:middle
You will want to do, so using

00:27:16.356 --> 00:27:17.656 A:middle
the Xcode Memory Gauge.

00:27:18.746 --> 00:27:20.486 A:middle
The Xcode Memory Gauge will

00:27:20.516 --> 00:27:22.576 A:middle
report the existing number that

00:27:22.576 --> 00:27:24.266 A:middle
the system also uses to measure

00:27:24.266 --> 00:27:25.626 A:middle
your game's memory footprint.

00:27:26.396 --> 00:27:28.036 A:middle
It is very important that you

00:27:28.036 --> 00:27:29.536 A:middle
use it to verify where your

00:27:29.536 --> 00:27:30.176 A:middle
games at.

00:27:31.126 --> 00:27:32.956 A:middle
Now, new this year it will also

00:27:32.956 --> 00:27:34.496 A:middle
display the application memory

00:27:34.496 --> 00:27:36.656 A:middle
limit as your game gets closer

00:27:36.736 --> 00:27:37.626 A:middle
to it.

00:27:38.896 --> 00:27:40.566 A:middle
But what if we want to focus

00:27:40.566 --> 00:27:43.206 A:middle
specifically on the memory used

00:27:43.206 --> 00:27:44.546 A:middle
by our Metal resources?

00:27:45.156 --> 00:27:47.696 A:middle
New this year, we are

00:27:47.696 --> 00:27:49.266 A:middle
introducing the Memory Viewer.

00:27:50.496 --> 00:27:52.366 A:middle
We have added it into the Metal

00:27:52.366 --> 00:27:53.106 A:middle
Frame Debugger.

00:27:54.346 --> 00:27:56.006 A:middle
The Memory Viewer itself has two

00:27:56.006 --> 00:27:58.776 A:middle
parts, first, a bar chart at the

00:27:58.836 --> 00:28:01.006 A:middle
top which shows resources, group

00:27:58.836 --> 00:28:01.006 A:middle
top which shows resources, group

00:28:01.006 --> 00:28:03.146 A:middle
by categories such as type,

00:28:03.596 --> 00:28:05.606 A:middle
storage mode, and usage.

00:28:06.256 --> 00:28:08.136 A:middle
We can also use this bar chart

00:28:08.756 --> 00:28:09.966 A:middle
to quickly navigate through the

00:28:09.966 --> 00:28:11.656 A:middle
largest resources which are then

00:28:11.656 --> 00:28:13.006 A:middle
highlighted and the time they

00:28:13.006 --> 00:28:13.606 A:middle
were shown.

00:28:14.706 --> 00:28:16.346 A:middle
Second, there is a table at the

00:28:16.346 --> 00:28:18.116 A:middle
bottom which will show the

00:28:18.176 --> 00:28:19.726 A:middle
resources that we have filtered.

00:28:19.726 --> 00:28:22.596 A:middle
It includes several properties

00:28:22.646 --> 00:28:24.786 A:middle
specific to resource type such

00:28:24.786 --> 00:28:26.506 A:middle
as pixel format and resolution

00:28:26.506 --> 00:28:27.216 A:middle
for textures.

00:28:28.046 --> 00:28:29.686 A:middle
There is also filter bar at the

00:28:29.686 --> 00:28:31.606 A:middle
bottom to help you narrow down

00:28:31.606 --> 00:28:33.156 A:middle
your investigation even further.

00:28:33.886 --> 00:28:36.056 A:middle
It is a very powerful tool and

00:28:36.056 --> 00:28:37.606 A:middle
we hope that you will utilize it

00:28:37.666 --> 00:28:38.916 A:middle
to understand the memory

00:28:38.916 --> 00:28:40.716 A:middle
footprint of all your GPU

00:28:40.716 --> 00:28:41.326 A:middle
resources.

00:28:43.056 --> 00:28:45.476 A:middle
Also another great tool that we

00:28:45.476 --> 00:28:47.456 A:middle
are introducing this year is the

00:28:47.456 --> 00:28:49.016 A:middle
Metal Resource Allocation

00:28:49.046 --> 00:28:49.736 A:middle
Instrument.

00:28:51.086 --> 00:28:52.076 A:middle
It has three different

00:28:52.076 --> 00:28:54.726 A:middle
components, a Metal Resources

00:28:54.726 --> 00:28:56.226 A:middle
Allocations track which will

00:28:56.226 --> 00:28:57.836 A:middle
show the current Metal memory

00:28:57.906 --> 00:29:00.226 A:middle
footprint of your game, an

00:28:57.906 --> 00:29:00.226 A:middle
footprint of your game, an

00:29:00.226 --> 00:29:02.056 A:middle
allocations track which will

00:29:02.056 --> 00:29:03.546 A:middle
show an event for each resource

00:29:03.546 --> 00:29:05.606 A:middle
allocation and deallocation as

00:29:05.606 --> 00:29:06.856 A:middle
well as some information.

00:29:08.106 --> 00:29:10.266 A:middle
And also a detailed table view

00:29:10.536 --> 00:29:11.446 A:middle
which will show you more

00:29:11.446 --> 00:29:12.816 A:middle
information about all the

00:29:12.816 --> 00:29:14.136 A:middle
allocations captured.

00:29:15.146 --> 00:29:16.416 A:middle
Both these tools are very

00:29:16.416 --> 00:29:18.506 A:middle
powerful and will give you great

00:29:18.506 --> 00:29:20.596 A:middle
overview of the memory footprint

00:29:20.596 --> 00:29:22.006 A:middle
in your game and how-- well,

00:29:22.006 --> 00:29:23.716 A:middle
also how it changes over time.

00:29:24.226 --> 00:29:26.446 A:middle
But some of you have also been

00:29:26.446 --> 00:29:28.476 A:middle
asking for other features, in

00:29:28.476 --> 00:29:29.726 A:middle
particular, one of them you have

00:29:29.756 --> 00:29:31.146 A:middle
been asking for a long time.

00:29:31.726 --> 00:29:33.006 A:middle
And I'm very happy to tell you

00:29:33.006 --> 00:29:34.466 A:middle
that new this year, we have a

00:29:34.466 --> 00:29:36.636 A:middle
C-based API to query available

00:29:36.636 --> 00:29:37.696 A:middle
memory at runtime.

00:29:38.566 --> 00:29:40.206 A:middle
This will enable your game to

00:29:40.206 --> 00:29:41.266 A:middle
stream resources more

00:29:41.266 --> 00:29:43.776 A:middle
effectively and also avoid

00:29:43.776 --> 00:29:46.156 A:middle
memory spikes which may cause

00:29:46.156 --> 00:29:47.626 A:middle
the game to go over the

00:29:47.626 --> 00:29:48.566 A:middle
application limit.

00:29:49.456 --> 00:29:51.296 A:middle
Another cool API that we're

00:29:51.296 --> 00:29:53.206 A:middle
introducing this year is the

00:29:53.286 --> 00:29:55.436 A:middle
on-device GPU capture, which

00:29:55.436 --> 00:29:56.116 A:middle
will allow you to

00:29:56.186 --> 00:29:57.816 A:middle
programmatically trigger a GPU

00:29:57.816 --> 00:30:00.326 A:middle
capture for which Xcode is not

00:29:57.816 --> 00:30:00.326 A:middle
capture for which Xcode is not

00:30:00.326 --> 00:30:00.856 A:middle
required.

00:30:01.446 --> 00:30:02.936 A:middle
So we think it will be ideal for

00:30:02.936 --> 00:30:04.776 A:middle
game testers in the QA process.

00:30:05.456 --> 00:30:07.286 A:middle
To enable it you will just need

00:30:07.336 --> 00:30:09.136 A:middle
to add MetalCaptureEnabled into

00:30:09.136 --> 00:30:10.026 A:middle
the info.plist.

00:30:10.026 --> 00:30:10.856 A:middle
It's very simple.

00:30:12.086 --> 00:30:13.206 A:middle
So, now, let's see how we can

00:30:13.206 --> 00:30:15.876 A:middle
combine both APIs into some

00:30:15.876 --> 00:30:17.466 A:middle
short piece of code.

00:30:18.766 --> 00:30:20.596 A:middle
In this case, we will want to

00:30:20.626 --> 00:30:22.196 A:middle
check if the application is

00:30:22.196 --> 00:30:23.856 A:middle
close to the memory limit, maybe

00:30:23.856 --> 00:30:25.946 A:middle
because of a memory spike and

00:30:25.946 --> 00:30:27.656 A:middle
capture a GPU trace of our game,

00:30:27.656 --> 00:30:29.136 A:middle
so we can use the Memory Viewer

00:30:29.196 --> 00:30:30.086 A:middle
to fully debug it.

00:30:30.756 --> 00:30:31.686 A:middle
So let's go for it.

00:30:32.116 --> 00:30:33.876 A:middle
First, we'll check if the

00:30:33.876 --> 00:30:35.166 A:middle
application is getting close to

00:30:35.166 --> 00:30:35.696 A:middle
the limit.

00:30:36.436 --> 00:30:38.806 A:middle
And if it is we will then want

00:30:39.126 --> 00:30:41.276 A:middle
to capture the next frame, which

00:30:41.276 --> 00:30:43.036 A:middle
we will just render normally as

00:30:43.036 --> 00:30:44.286 A:middle
we would do so otherwise.

00:30:45.716 --> 00:30:47.516 A:middle
By the end of the frame, if we

00:30:47.516 --> 00:30:49.636 A:middle
captured it, we will then stop

00:30:49.636 --> 00:30:51.486 A:middle
the capture and handle the GPU

00:30:51.486 --> 00:30:53.506 A:middle
trace, it's up to you how you

00:30:53.506 --> 00:30:54.806 A:middle
handle the GPU trace.

00:30:55.516 --> 00:30:57.416 A:middle
Potentially you may also want to

00:30:57.416 --> 00:30:59.836 A:middle
either exit the game or disable

00:30:59.836 --> 00:31:01.346 A:middle
the GPU captures for this

00:30:59.836 --> 00:31:01.346 A:middle
the GPU captures for this

00:31:01.346 --> 00:31:02.716 A:middle
session, since you may not want

00:31:02.716 --> 00:31:04.506 A:middle
to capture every single frame at

00:31:04.506 --> 00:31:05.026 A:middle
that point.

00:31:06.246 --> 00:31:08.016 A:middle
So this will give you a great

00:31:08.016 --> 00:31:10.536 A:middle
way to use both APIs and to, you

00:31:10.536 --> 00:31:12.076 A:middle
know, like further drill down on

00:31:12.076 --> 00:31:12.856 A:middle
memory footprint.

00:31:13.296 --> 00:31:15.556 A:middle
Which is great, so let's do

00:31:15.556 --> 00:31:16.346 A:middle
exactly that.

00:31:16.346 --> 00:31:17.776 A:middle
Let's look into how can we

00:31:17.776 --> 00:31:19.286 A:middle
reduce memory footprint.

00:31:19.866 --> 00:31:21.656 A:middle
For that we also have a bunch of

00:31:21.656 --> 00:31:22.526 A:middle
best practices.

00:31:23.516 --> 00:31:25.026 A:middle
In this section, we will talk

00:31:25.026 --> 00:31:26.886 A:middle
about memoryless render targets,

00:31:27.256 --> 00:31:29.486 A:middle
resource streaming, a bit more

00:31:29.486 --> 00:31:31.216 A:middle
about game assets and also

00:31:31.306 --> 00:31:32.656 A:middle
memory-intensive effects.

00:31:33.396 --> 00:31:34.986 A:middle
So, let's get started with

00:31:34.986 --> 00:31:36.406 A:middle
memoryless render targets.

00:31:36.786 --> 00:31:39.206 A:middle
This is kind of where we left it

00:31:39.206 --> 00:31:40.716 A:middle
in the memory bandwidth section.

00:31:42.096 --> 00:31:43.466 A:middle
Notice the transient render

00:31:43.466 --> 00:31:45.386 A:middle
targets are not loaded or stored

00:31:45.386 --> 00:31:46.316 A:middle
on system memory.

00:31:47.076 --> 00:31:49.056 A:middle
So they actually do not need a

00:31:49.056 --> 00:31:50.476 A:middle
system memory allocation in the

00:31:50.476 --> 00:31:52.286 A:middle
first place, that's why you

00:31:52.286 --> 00:31:53.816 A:middle
should use memoryless storage

00:31:53.816 --> 00:31:55.996 A:middle
mode, in particular, for all the

00:31:55.996 --> 00:31:57.456 A:middle
multisampled attachments.

00:31:58.316 --> 00:31:59.646 A:middle
So let's see how can we do that

00:31:59.646 --> 00:32:01.716 A:middle
with, again, just a little bit

00:31:59.646 --> 00:32:01.716 A:middle
with, again, just a little bit

00:32:02.116 --> 00:32:02.956 A:middle
of code.

00:32:03.146 --> 00:32:04.806 A:middle
In this case, is as simple as

00:32:04.806 --> 00:32:06.126 A:middle
setting memoryless into the

00:32:06.126 --> 00:32:07.096 A:middle
texture descriptor.

00:32:07.906 --> 00:32:09.726 A:middle
Also we will want to make sure

00:32:09.906 --> 00:32:11.836 A:middle
that our render pass configures

00:32:11.836 --> 00:32:13.066 A:middle
that render target as fully

00:32:13.066 --> 00:32:13.626 A:middle
transient.

00:32:14.106 --> 00:32:15.586 A:middle
In this case, we want to

00:32:15.586 --> 00:32:16.856 A:middle
configure the G-Buffers

00:32:16.856 --> 00:32:17.406 A:middle
transients.

00:32:17.406 --> 00:32:18.776 A:middle
So, we just need to set the load

00:32:18.776 --> 00:32:20.646 A:middle
action clear and the store

00:32:20.646 --> 00:32:21.606 A:middle
action to DontCare.

00:32:22.096 --> 00:32:23.326 A:middle
So we are not storing the

00:32:23.326 --> 00:32:23.856 A:middle
G-buffer.

00:32:24.426 --> 00:32:27.156 A:middle
So we can see how Digital

00:32:27.156 --> 00:32:28.686 A:middle
Legends did it by having another

00:32:28.686 --> 00:32:29.676 A:middle
look at Afterpulse.

00:32:30.516 --> 00:32:32.406 A:middle
At the top we can see an older

00:32:32.406 --> 00:32:35.006 A:middle
version of Afterpulse, it has a

00:32:35.006 --> 00:32:37.096 A:middle
transient G-buffer but it's

00:32:37.096 --> 00:32:38.816 A:middle
being backed by system memory.

00:32:39.426 --> 00:32:41.766 A:middle
At the bottom, we can see a

00:32:41.766 --> 00:32:43.396 A:middle
newer version of Afterpulse

00:32:43.796 --> 00:32:45.076 A:middle
which actually has a larger

00:32:45.076 --> 00:32:45.626 A:middle
G-buffer.

00:32:46.446 --> 00:32:48.616 A:middle
But this G-buffer though is

00:32:48.616 --> 00:32:51.336 A:middle
fully transient and this time

00:32:51.706 --> 00:32:53.306 A:middle
not backed by system memory,

00:32:53.766 --> 00:32:55.296 A:middle
they are utilizing memoryless

00:32:55.296 --> 00:32:56.936 A:middle
storage mode for all the

00:32:56.936 --> 00:32:57.996 A:middle
intermediate G-buffer

00:32:57.996 --> 00:32:58.636 A:middle
attachments.

00:32:58.966 --> 00:33:00.576 A:middle
And this is great because the

00:32:58.966 --> 00:33:00.576 A:middle
And this is great because the

00:33:00.576 --> 00:33:02.896 A:middle
newer version of Afterpulse is

00:33:02.896 --> 00:33:04.876 A:middle
saving about 60 megabytes of

00:33:04.906 --> 00:33:07.256 A:middle
memory footprint just by setting

00:33:07.256 --> 00:33:09.336 A:middle
that one flag, it's awesome.

00:33:10.096 --> 00:33:12.066 A:middle
And it comes with no compromise,

00:33:12.656 --> 00:33:13.906 A:middle
there is nothing being lost

00:33:13.906 --> 00:33:15.066 A:middle
here, there's no trade-off to be

00:33:15.066 --> 00:33:16.676 A:middle
made, it just works.

00:33:17.126 --> 00:33:17.676 A:middle
And it's great.

00:33:18.496 --> 00:33:19.976 A:middle
So, now, let's move on to the

00:33:19.976 --> 00:33:22.386 A:middle
rest of the best practices,

00:33:22.616 --> 00:33:24.126 A:middle
which some of those we will do

00:33:24.126 --> 00:33:26.576 A:middle
come with a, you know, memory

00:33:26.576 --> 00:33:27.956 A:middle
and performance trade-off or

00:33:27.956 --> 00:33:29.086 A:middle
memory and image quality

00:33:29.086 --> 00:33:29.596 A:middle
trade-off.

00:33:30.366 --> 00:33:31.916 A:middle
In this case, we are back to

00:33:31.916 --> 00:33:32.696 A:middle
resource streaming.

00:33:34.076 --> 00:33:35.306 A:middle
Notice that loading all the

00:33:35.306 --> 00:33:37.246 A:middle
assets into memory will increase

00:33:37.246 --> 00:33:38.806 A:middle
the memory footprint, so you

00:33:38.806 --> 00:33:40.216 A:middle
should consider the memory and

00:33:40.216 --> 00:33:42.596 A:middle
performance trade-off and only

00:33:42.596 --> 00:33:43.856 A:middle
load all the assets that you

00:33:43.856 --> 00:33:45.666 A:middle
know will be used, particularly

00:33:45.666 --> 00:33:46.996 A:middle
when you are memory limited.

00:33:48.036 --> 00:33:50.006 A:middle
Also you may want to free all

00:33:50.006 --> 00:33:51.856 A:middle
the resources as long-- as soon

00:33:51.856 --> 00:33:53.406 A:middle
as they are not used anymore,

00:33:53.736 --> 00:33:55.356 A:middle
potentially like splash screen

00:33:55.356 --> 00:33:56.796 A:middle
or tutorial UI would be great

00:33:56.796 --> 00:33:57.826 A:middle
candidates for that.

00:33:58.806 --> 00:34:00.916 A:middle
And this is a hard decision to

00:33:58.806 --> 00:34:00.916 A:middle
And this is a hard decision to

00:34:00.916 --> 00:34:03.056 A:middle
make but fortunately the Memory

00:34:03.056 --> 00:34:04.406 A:middle
Viewer is also a great tool to

00:34:04.406 --> 00:34:05.326 A:middle
help us with that.

00:34:06.926 --> 00:34:08.755 A:middle
We can use the filters to

00:34:08.755 --> 00:34:10.166 A:middle
quickly focus on unused

00:34:10.216 --> 00:34:10.846 A:middle
resources.

00:34:11.996 --> 00:34:14.016 A:middle
By doing so, the table at the

00:34:14.016 --> 00:34:15.716 A:middle
bottom will be updated and then

00:34:15.846 --> 00:34:17.085 A:middle
we can focus on all these

00:34:17.085 --> 00:34:18.636 A:middle
resources which are not used in

00:34:18.636 --> 00:34:19.146 A:middle
this frame.

00:34:19.315 --> 00:34:21.616 A:middle
And we will talk more about this

00:34:21.616 --> 00:34:22.866 A:middle
and use them off the Memory

00:34:22.866 --> 00:34:24.235 A:middle
Viewer towards the end of the

00:34:24.266 --> 00:34:24.576 A:middle
talk.

00:34:25.656 --> 00:34:26.976 A:middle
So, now, let's move on to best

00:34:26.976 --> 00:34:28.275 A:middle
practice number 14.

00:34:29.106 --> 00:34:30.505 A:middle
Use smaller assets.

00:34:31.186 --> 00:34:33.246 A:middle
In fact, you should only make

00:34:33.246 --> 00:34:35.426 A:middle
the assets as large as necessary

00:34:36.286 --> 00:34:37.726 A:middle
and consider again the image

00:34:37.775 --> 00:34:39.396 A:middle
quality and memory trade-off of

00:34:39.396 --> 00:34:40.335 A:middle
your asset sizes.

00:34:40.866 --> 00:34:42.335 A:middle
Make sure that both textures and

00:34:42.335 --> 00:34:43.406 A:middle
meshes are compressed.

00:34:44.196 --> 00:34:45.376 A:middle
And potentially if you are

00:34:45.376 --> 00:34:47.666 A:middle
getting memory limited you may

00:34:47.666 --> 00:34:49.886 A:middle
want to only load the smaller

00:34:49.886 --> 00:34:51.525 A:middle
mipmap levels of your textures,

00:34:52.306 --> 00:34:53.926 A:middle
or the lower LODs for your

00:34:53.926 --> 00:34:54.386 A:middle
meshes.

00:34:55.005 --> 00:34:57.456 A:middle
But there is a trade-off here

00:34:57.456 --> 00:34:58.426 A:middle
that we are making, between

00:34:58.426 --> 00:35:00.016 A:middle
image quality and memory.

00:34:58.426 --> 00:35:00.016 A:middle
image quality and memory.

00:35:00.136 --> 00:35:02.246 A:middle
It's up to you to decide, when

00:35:02.246 --> 00:35:03.746 A:middle
do you want to take it?

00:35:04.496 --> 00:35:07.026 A:middle
The next best practice number 15

00:35:07.106 --> 00:35:08.206 A:middle
is very similar.

00:35:08.666 --> 00:35:10.806 A:middle
We will want to simplify

00:35:10.996 --> 00:35:12.506 A:middle
memory-intensive effects.

00:35:12.996 --> 00:35:16.066 A:middle
Some effects may require large

00:35:16.066 --> 00:35:17.746 A:middle
off-screen buffers, such as

00:35:17.746 --> 00:35:19.416 A:middle
Shadow Maps and SSAO.

00:35:19.726 --> 00:35:21.956 A:middle
So the best practice will be for

00:35:21.956 --> 00:35:23.146 A:middle
you to consider the image

00:35:23.146 --> 00:35:24.736 A:middle
quality and memory trade-off of

00:35:24.736 --> 00:35:25.936 A:middle
all of those effects.

00:35:27.086 --> 00:35:28.726 A:middle
Potentially lower the resolution

00:35:28.726 --> 00:35:29.946 A:middle
of all these large off-screen

00:35:29.946 --> 00:35:30.436 A:middle
buffers.

00:35:31.316 --> 00:35:32.526 A:middle
And if you are very memory

00:35:32.526 --> 00:35:34.606 A:middle
constrained then just disable

00:35:34.606 --> 00:35:36.026 A:middle
all those effects all together.

00:35:37.506 --> 00:35:38.696 A:middle
That is a trade-off to be made

00:35:38.776 --> 00:35:39.906 A:middle
here and you need to be

00:35:39.906 --> 00:35:41.006 A:middle
conscious about it.

00:35:41.256 --> 00:35:42.486 A:middle
But sometimes there's no other

00:35:42.486 --> 00:35:42.946 A:middle
choice.

00:35:44.536 --> 00:35:46.476 A:middle
The next best practices that we

00:35:46.476 --> 00:35:48.256 A:middle
are going to cover here are

00:35:48.256 --> 00:35:49.336 A:middle
slightly different.

00:35:50.146 --> 00:35:52.896 A:middle
In this last section, I will

00:35:52.896 --> 00:35:54.456 A:middle
introduce a couple of more

00:35:54.456 --> 00:35:56.106 A:middle
advanced concepts that will help

00:35:56.106 --> 00:35:58.036 A:middle
us further reducing the memory

00:35:58.076 --> 00:35:58.586 A:middle
footprint.

00:35:59.526 --> 00:36:00.946 A:middle
We will talk about metal

00:35:59.526 --> 00:36:00.946 A:middle
We will talk about metal

00:36:00.986 --> 00:36:04.556 A:middle
resource heaps, purgeable memory

00:36:04.806 --> 00:36:06.066 A:middle
as well as pipeline state

00:36:06.066 --> 00:36:06.576 A:middle
objects.

00:36:07.476 --> 00:36:09.286 A:middle
So, let's get started with metal

00:36:09.286 --> 00:36:10.066 A:middle
resource heaps.

00:36:11.256 --> 00:36:12.746 A:middle
metal resource heaps will allow

00:36:12.746 --> 00:36:13.946 A:middle
your application to take

00:36:13.946 --> 00:36:16.346 A:middle
explicit control over the large

00:36:16.376 --> 00:36:18.496 A:middle
memory allocation that happens

00:36:18.496 --> 00:36:19.056 A:middle
up front.

00:36:20.016 --> 00:36:21.516 A:middle
In this case, we will go from

00:36:21.516 --> 00:36:23.526 A:middle
three separate textures which

00:36:23.526 --> 00:36:25.686 A:middle
have their own allocation into a

00:36:25.806 --> 00:36:28.086 A:middle
single metal resource heap which

00:36:28.086 --> 00:36:29.596 A:middle
is a single allocation that will

00:36:29.596 --> 00:36:30.886 A:middle
hold these three textures

00:36:30.886 --> 00:36:31.526 A:middle
separately.

00:36:32.536 --> 00:36:34.406 A:middle
This will also allow the system

00:36:34.406 --> 00:36:35.966 A:middle
to pack those textures together,

00:36:36.066 --> 00:36:37.346 A:middle
so we're already saving some

00:36:37.346 --> 00:36:37.806 A:middle
memory.

00:36:38.346 --> 00:36:41.986 A:middle
But the great memory savings

00:36:41.986 --> 00:36:45.096 A:middle
will come from using aliasing.

00:36:46.136 --> 00:36:47.566 A:middle
So, notice that rendering a

00:36:47.566 --> 00:36:49.276 A:middle
frame may require a lot of

00:36:49.276 --> 00:36:51.176 A:middle
intermediate memory, in

00:36:51.176 --> 00:36:52.886 A:middle
particular, is your game scales

00:36:52.886 --> 00:36:54.236 A:middle
in the post-process pipeline.

00:36:55.066 --> 00:36:56.486 A:middle
So it is very important for you

00:36:56.486 --> 00:36:58.076 A:middle
to use metal resource heaps for

00:36:58.076 --> 00:37:00.316 A:middle
those effects and alias as much

00:36:58.076 --> 00:37:00.316 A:middle
those effects and alias as much

00:37:00.316 --> 00:37:01.646 A:middle
of that memory as possible.

00:37:02.346 --> 00:37:03.596 A:middle
For example, you may want to

00:37:03.596 --> 00:37:05.396 A:middle
reutilize the memory for all

00:37:05.396 --> 00:37:06.776 A:middle
those resources which have no

00:37:06.776 --> 00:37:09.406 A:middle
dependencies, potentially like

00:37:09.406 --> 00:37:11.076 A:middle
those you would find in SSAO and

00:37:11.076 --> 00:37:11.756 A:middle
Depth of Field.

00:37:12.296 --> 00:37:15.106 A:middle
So, now, let's look how would

00:37:15.106 --> 00:37:15.866 A:middle
that look like.

00:37:16.566 --> 00:37:18.346 A:middle
In this case, we have the same

00:37:18.346 --> 00:37:19.946 A:middle
metal resource heap as before.

00:37:21.116 --> 00:37:23.136 A:middle
But if the three textures are

00:37:23.136 --> 00:37:24.986 A:middle
not used at the same time we can

00:37:24.986 --> 00:37:26.256 A:middle
potentially alias them.

00:37:26.796 --> 00:37:28.156 A:middle
And by doing so, we will save a

00:37:28.156 --> 00:37:29.076 A:middle
lot of memory.

00:37:30.146 --> 00:37:31.886 A:middle
And this will really help your

00:37:31.886 --> 00:37:33.956 A:middle
game scale with a much more

00:37:33.956 --> 00:37:35.786 A:middle
complex post-process pipeline

00:37:36.346 --> 00:37:37.946 A:middle
without having to pay a huge

00:37:37.946 --> 00:37:39.646 A:middle
memory price for all those

00:37:39.646 --> 00:37:41.136 A:middle
intermediate render targets and

00:37:41.136 --> 00:37:42.276 A:middle
all the intermediate memory.

00:37:43.266 --> 00:37:44.576 A:middle
So it is great, it's a great

00:37:44.576 --> 00:37:45.886 A:middle
feature that you should consider

00:37:45.886 --> 00:37:46.506 A:middle
leveraging.

00:37:47.076 --> 00:37:49.426 A:middle
Now, let's talk about another

00:37:49.426 --> 00:37:50.706 A:middle
advanced concept that of

00:37:50.856 --> 00:37:51.816 A:middle
purgeable memory.

00:37:53.306 --> 00:37:54.826 A:middle
Purgeable memory has three

00:37:54.826 --> 00:37:58.186 A:middle
states, non-volatile, volatile,

00:37:58.626 --> 00:37:59.336 A:middle
and empty.

00:38:00.576 --> 00:38:02.516 A:middle
Notice that volatile and empty

00:38:02.516 --> 00:38:05.156 A:middle
allocations do not count towards

00:38:05.156 --> 00:38:06.246 A:middle
the application memory

00:38:06.326 --> 00:38:06.826 A:middle
footprint.

00:38:07.806 --> 00:38:09.506 A:middle
That is because the system can

00:38:09.506 --> 00:38:10.976 A:middle
either reclaim that memory at

00:38:10.976 --> 00:38:12.366 A:middle
some point, in the case of

00:38:12.396 --> 00:38:14.366 A:middle
volatile or has already

00:38:14.426 --> 00:38:15.806 A:middle
reclaimed it in the past, in the

00:38:15.806 --> 00:38:16.676 A:middle
case of empty.

00:38:17.216 --> 00:38:18.766 A:middle
So you may need to regenerate

00:38:18.766 --> 00:38:19.656 A:middle
those resources.

00:38:21.106 --> 00:38:22.456 A:middle
But that makes this kind of

00:38:22.496 --> 00:38:24.756 A:middle
memory ideal for resource

00:38:24.756 --> 00:38:25.176 A:middle
caches.

00:38:26.226 --> 00:38:28.616 A:middle
So the best practice number 17

00:38:28.616 --> 00:38:30.226 A:middle
is for you to mark resources as

00:38:30.226 --> 00:38:30.936 A:middle
volatile.

00:38:31.676 --> 00:38:33.836 A:middle
Temporary resources may become a

00:38:33.836 --> 00:38:35.126 A:middle
large part of your game's

00:38:35.126 --> 00:38:35.646 A:middle
footprint.

00:38:36.936 --> 00:38:38.526 A:middle
And Metal will allow you to

00:38:38.526 --> 00:38:40.566 A:middle
explicitly manage those, set the

00:38:40.566 --> 00:38:41.726 A:middle
purgeable state of all the

00:38:41.726 --> 00:38:43.686 A:middle
resources explicitly.

00:38:44.516 --> 00:38:46.136 A:middle
So you will want to focus on

00:38:46.136 --> 00:38:48.406 A:middle
your caches particularly all of

00:38:48.406 --> 00:38:49.836 A:middle
those which hold mostly idle

00:38:49.836 --> 00:38:52.006 A:middle
memory and carefully manage

00:38:52.036 --> 00:38:54.076 A:middle
their purgeable state, so they

00:38:54.076 --> 00:38:55.066 A:middle
will not count towards the

00:38:55.066 --> 00:38:55.956 A:middle
game's footprint.

00:38:56.976 --> 00:38:59.336 A:middle
Let's see a very short bit of

00:38:59.446 --> 00:39:01.036 A:middle
code that will give you an

00:38:59.446 --> 00:39:01.036 A:middle
code that will give you an

00:39:01.036 --> 00:39:02.336 A:middle
example on how to do so.

00:39:03.026 --> 00:39:04.446 A:middle
In this case, we have a texture

00:39:04.446 --> 00:39:06.116 A:middle
cache, could have also been a

00:39:06.116 --> 00:39:06.876 A:middle
buffer cache.

00:39:07.686 --> 00:39:09.456 A:middle
And we will set the purgeable

00:39:09.456 --> 00:39:10.766 A:middle
state of all the textures in

00:39:11.116 --> 00:39:13.456 A:middle
that cache as volatile because

00:39:13.456 --> 00:39:15.716 A:middle
we know that cache is mostly

00:39:15.716 --> 00:39:16.086 A:middle
idle.

00:39:16.216 --> 00:39:18.386 A:middle
We only use a texture from now

00:39:18.386 --> 00:39:19.836 A:middle
and then but not very often.

00:39:20.296 --> 00:39:22.786 A:middle
So if we need to use a resource

00:39:22.786 --> 00:39:24.736 A:middle
from that cache, we will then

00:39:24.736 --> 00:39:26.686 A:middle
need to mark it as non-volatile

00:39:27.246 --> 00:39:28.916 A:middle
that will ensure that the system

00:39:29.296 --> 00:39:30.806 A:middle
doesn't remove its backing data.

00:39:32.166 --> 00:39:34.166 A:middle
And in the case, it was empty

00:39:34.656 --> 00:39:36.636 A:middle
which was the previous state

00:39:36.776 --> 00:39:37.926 A:middle
that the one we just said.

00:39:38.556 --> 00:39:39.776 A:middle
We may actually need to

00:39:39.776 --> 00:39:42.256 A:middle
regenerate the data potentially

00:39:42.256 --> 00:39:42.496 A:middle
not.

00:39:42.496 --> 00:39:44.116 A:middle
It depends on what type of cache

00:39:44.116 --> 00:39:44.826 A:middle
you're managing.

00:39:45.446 --> 00:39:47.676 A:middle
But after we do so, we can just

00:39:47.676 --> 00:39:49.236 A:middle
utilize the resource normally as

00:39:49.236 --> 00:39:50.196 A:middle
we would otherwise.

00:39:52.256 --> 00:39:56.676 A:middle
A very good practice will be for

00:39:56.676 --> 00:39:58.406 A:middle
you to also check the common

00:39:58.406 --> 00:40:01.416 A:middle
buffer completion and get to

00:39:58.406 --> 00:40:01.416 A:middle
buffer completion and get to

00:40:01.416 --> 00:40:02.936 A:middle
handle when the common buffer is

00:40:02.936 --> 00:40:04.876 A:middle
completed and then potentially

00:40:04.876 --> 00:40:06.936 A:middle
you flag that resource as

00:40:06.936 --> 00:40:07.936 A:middle
volatile again.

00:40:08.486 --> 00:40:10.006 A:middle
So it does not keep counting

00:40:10.006 --> 00:40:11.346 A:middle
towards your memory footprint.

00:40:12.516 --> 00:40:14.786 A:middle
You can be explicit and in fact

00:40:14.786 --> 00:40:16.116 A:middle
you should be very aggressive

00:40:16.226 --> 00:40:17.926 A:middle
particularly when you have lots

00:40:17.926 --> 00:40:19.716 A:middle
of caches of mostly idle memory.

00:40:20.306 --> 00:40:23.596 A:middle
So let's introduce one last

00:40:23.596 --> 00:40:25.746 A:middle
concept that of pipeline state

00:40:25.746 --> 00:40:26.306 A:middle
objects.

00:40:27.486 --> 00:40:28.846 A:middle
Most of you are already familiar

00:40:28.846 --> 00:40:29.466 A:middle
with those.

00:40:29.946 --> 00:40:32.216 A:middle
PSOs encapsulate most of the

00:40:32.216 --> 00:40:33.226 A:middle
Metal render state.

00:40:34.276 --> 00:40:35.326 A:middle
They are constructed with a

00:40:35.326 --> 00:40:36.826 A:middle
description-- a descriptor which

00:40:36.826 --> 00:40:38.486 A:middle
contains vertex and fragment

00:40:38.486 --> 00:40:40.306 A:middle
functions as well as other

00:40:40.306 --> 00:40:42.366 A:middle
states such as the blend state

00:40:42.796 --> 00:40:44.016 A:middle
and the vertex descriptor.

00:40:45.026 --> 00:40:46.636 A:middle
All of these will get compiled

00:40:46.636 --> 00:40:48.286 A:middle
into final Metal PSO.

00:40:49.686 --> 00:40:51.906 A:middle
We only need this final Metal

00:40:51.906 --> 00:40:53.796 A:middle
PSO in order to render.

00:40:54.466 --> 00:40:56.466 A:middle
So the next best practice is for

00:40:56.466 --> 00:40:58.506 A:middle
you to explicitly leverage that.

00:40:59.456 --> 00:41:00.606 A:middle
Since Metal allows your

00:40:59.456 --> 00:41:00.606 A:middle
Since Metal allows your

00:41:00.606 --> 00:41:02.336 A:middle
application to load most of the

00:41:02.336 --> 00:41:04.176 A:middle
rendering state up front, you

00:41:04.176 --> 00:41:04.896 A:middle
should do so.

00:41:05.386 --> 00:41:06.246 A:middle
That will be great for

00:41:06.246 --> 00:41:07.166 A:middle
performance.

00:41:07.966 --> 00:41:09.536 A:middle
But then consider the memory

00:41:09.536 --> 00:41:10.716 A:middle
trade-off of doing that.

00:41:11.656 --> 00:41:12.756 A:middle
If you are getting memory

00:41:12.756 --> 00:41:15.016 A:middle
limited make sure do not hold on

00:41:15.016 --> 00:41:17.556 A:middle
to PSO references that you know

00:41:17.556 --> 00:41:18.856 A:middle
they are not needed anymore.

00:41:19.616 --> 00:41:21.876 A:middle
And very important also do not

00:41:21.876 --> 00:41:23.246 A:middle
hold on to Metal function

00:41:23.246 --> 00:41:24.946 A:middle
references after you have

00:41:25.026 --> 00:41:26.426 A:middle
created the PSO cache.

00:41:26.936 --> 00:41:28.326 A:middle
Since those are not needed to

00:41:28.326 --> 00:41:29.926 A:middle
render they are only needed to

00:41:29.926 --> 00:41:30.936 A:middle
create new PSOs.

00:41:31.766 --> 00:41:33.456 A:middle
So let's see what I mean by

00:41:33.456 --> 00:41:35.316 A:middle
looking at the descriptor again.

00:41:36.086 --> 00:41:37.466 A:middle
This is the pipeline state

00:41:37.466 --> 00:41:38.756 A:middle
object as well as the pipeline

00:41:38.756 --> 00:41:39.946 A:middle
state object descriptor.

00:41:40.326 --> 00:41:41.616 A:middle
And what this best practice is

00:41:41.616 --> 00:41:43.826 A:middle
asking you to do is to free the

00:41:43.826 --> 00:41:45.616 A:middle
reference of both the vertex and

00:41:45.616 --> 00:41:46.966 A:middle
fragment functions after you

00:41:46.966 --> 00:41:49.136 A:middle
create the PSOs, potentially

00:41:49.136 --> 00:41:50.356 A:middle
only hold on to those when

00:41:50.356 --> 00:41:52.896 A:middle
you're populating the main PSO

00:41:52.896 --> 00:41:53.866 A:middle
cache at load time.

00:41:54.926 --> 00:41:56.876 A:middle
And then consider also freeing

00:41:56.876 --> 00:41:58.976 A:middle
the PSO itself when you are

00:41:58.976 --> 00:42:00.866 A:middle
getting memory limited if you

00:41:58.976 --> 00:42:00.866 A:middle
getting memory limited if you

00:42:00.866 --> 00:42:02.736 A:middle
know that that PSO is no longer

00:42:03.886 --> 00:42:04.056 A:middle
needed.

00:42:04.616 --> 00:42:06.136 A:middle
Now, let's, please welcome

00:42:06.136 --> 00:42:07.716 A:middle
Onyechi on stage for an awesome

00:42:07.716 --> 00:42:08.936 A:middle
demo of the Memory Viewer.

00:42:09.516 --> 00:42:15.006 A:middle
[ Applause ]

00:42:15.506 --> 00:42:16.256 A:middle
&gt;&gt; Thank you Guillem.

00:42:16.466 --> 00:42:17.646 A:middle
Hello everyone.

00:42:19.086 --> 00:42:21.076 A:middle
So you already have the brief

00:42:21.076 --> 00:42:22.066 A:middle
introduction to the Memory

00:42:22.066 --> 00:42:23.136 A:middle
Viewer from the previous slides.

00:42:23.276 --> 00:42:24.846 A:middle
Now, I'm going to show you how

00:42:24.846 --> 00:42:26.246 A:middle
to use it to understand your

00:42:26.246 --> 00:42:27.566 A:middle
memory footprint that's

00:42:27.566 --> 00:42:28.746 A:middle
optimized for better memory

00:42:28.746 --> 00:42:29.466 A:middle
performance.

00:42:29.986 --> 00:42:32.816 A:middle
So here we are again with a

00:42:32.816 --> 00:42:34.486 A:middle
capture of a frame from the same

00:42:35.026 --> 00:42:36.086 A:middle
early version of the game

00:42:36.296 --> 00:42:37.016 A:middle
Afterpulse.

00:42:37.786 --> 00:42:39.026 A:middle
Then the top left there are the

00:42:39.026 --> 00:42:40.746 A:middle
debug navigates that you'll find

00:42:40.746 --> 00:42:42.716 A:middle
in your Memory Gauge which when

00:42:42.716 --> 00:42:44.856 A:middle
I click on it, it takes me into

00:42:44.856 --> 00:42:45.436 A:middle
the Memory Viewer.

00:42:45.436 --> 00:42:48.326 A:middle
Now this shows us the state of

00:42:48.326 --> 00:42:50.116 A:middle
all live Metal resources for the

00:42:50.116 --> 00:42:50.616 A:middle
captured frame.

00:42:51.386 --> 00:42:52.596 A:middle
And my goal is to find

00:42:52.596 --> 00:42:53.886 A:middle
opportunities to reduce its

00:42:53.886 --> 00:42:54.526 A:middle
memory footprint.

00:42:55.326 --> 00:42:57.956 A:middle
So to begin, let's take a look

00:42:57.956 --> 00:42:59.956 A:middle
at the orange bars in the graph.

00:42:59.956 --> 00:43:01.336 A:middle
This shows how our resources are

00:42:59.956 --> 00:43:01.336 A:middle
This shows how our resources are

00:43:01.336 --> 00:43:02.606 A:middle
distributed by type.

00:43:02.606 --> 00:43:04.856 A:middle
And we can see that textures

00:43:04.856 --> 00:43:05.956 A:middle
make up the largest proportion,

00:43:05.956 --> 00:43:06.156 A:middle
right?

00:43:07.186 --> 00:43:08.916 A:middle
There's about 440 megabytes of

00:43:08.916 --> 00:43:09.116 A:middle
them.

00:43:09.506 --> 00:43:10.946 A:middle
Now, I want to focus in these

00:43:10.946 --> 00:43:12.186 A:middle
sections and I can simply do

00:43:12.186 --> 00:43:14.236 A:middle
that by clicking on the filter

00:43:14.236 --> 00:43:14.666 A:middle
button.

00:43:15.046 --> 00:43:18.176 A:middle
Now, both the graph and the

00:43:18.176 --> 00:43:19.576 A:middle
table have been updated to show

00:43:19.576 --> 00:43:20.276 A:middle
textures only.

00:43:20.926 --> 00:43:23.266 A:middle
So, next, Guillem mentioned that

00:43:23.266 --> 00:43:24.336 A:middle
when looking to reduce our

00:43:24.336 --> 00:43:26.666 A:middle
memory footprint starting at

00:43:26.666 --> 00:43:28.276 A:middle
unused resources that was a

00:43:28.336 --> 00:43:29.346 A:middle
great place to begin.

00:43:29.536 --> 00:43:30.736 A:middle
So, let's do that.

00:43:30.736 --> 00:43:33.266 A:middle
Let's look at the blue bars this

00:43:33.856 --> 00:43:33.966 A:middle
time.

00:43:34.186 --> 00:43:36.596 A:middle
This represents our usage and we

00:43:36.596 --> 00:43:37.926 A:middle
see that we have about 200

00:43:37.926 --> 00:43:39.356 A:middle
megabytes, so unused texture.

00:43:40.476 --> 00:43:43.406 A:middle
So as a reminder, unused

00:43:43.406 --> 00:43:44.616 A:middle
resources are resources that do

00:43:44.616 --> 00:43:45.936 A:middle
not contribute to the final

00:43:45.936 --> 00:43:47.566 A:middle
output of this rendered frame.

00:43:47.566 --> 00:43:49.296 A:middle
That means they're not accessed

00:43:49.296 --> 00:43:49.996 A:middle
by the GPU.

00:43:51.806 --> 00:43:54.176 A:middle
OK. So, I can easily do that

00:43:54.176 --> 00:43:55.156 A:middle
again by just clicking on the

00:43:55.156 --> 00:43:56.276 A:middle
unused filter, so that we're

00:43:56.276 --> 00:43:57.986 A:middle
looking on unused textures now.

00:43:59.276 --> 00:44:01.096 A:middle
Next, I will sort the table by

00:43:59.276 --> 00:44:01.096 A:middle
Next, I will sort the table by

00:44:01.096 --> 00:44:03.076 A:middle
allocated size, so that we're

00:44:03.076 --> 00:44:04.286 A:middle
focused in our largest texture.

00:44:04.286 --> 00:44:07.046 A:middle
And we can see straight away

00:44:07.046 --> 00:44:08.606 A:middle
that our largest texture which

00:44:08.606 --> 00:44:10.956 A:middle
is about 13 megabytes has an

00:44:10.956 --> 00:44:11.386 A:middle
issue.

00:44:12.176 --> 00:44:13.816 A:middle
So, issues work here just like

00:44:13.816 --> 00:44:15.406 A:middle
in Dependency Viewer you saw in

00:44:15.406 --> 00:44:16.226 A:middle
the previous demo.

00:44:16.766 --> 00:44:17.856 A:middle
So let's click it to see what

00:44:17.856 --> 00:44:18.396 A:middle
it's about.

00:44:20.026 --> 00:44:21.436 A:middle
OK. So, this says we have a

00:44:21.436 --> 00:44:22.546 A:middle
large unused texture.

00:44:23.406 --> 00:44:25.106 A:middle
It's not accessed by the CPU and

00:44:25.556 --> 00:44:26.796 A:middle
has never been bound to a

00:44:26.796 --> 00:44:28.486 A:middle
command encoder with a

00:44:28.486 --> 00:44:30.246 A:middle
recommendation to avoid loading

00:44:30.246 --> 00:44:32.076 A:middle
the resource or to make it

00:44:32.076 --> 00:44:32.636 A:middle
volatile.

00:44:33.806 --> 00:44:35.476 A:middle
So, we can also confront this by

00:44:35.476 --> 00:44:37.256 A:middle
looking at the properties, CPU

00:44:37.256 --> 00:44:38.576 A:middle
Access and Times since Last

00:44:38.576 --> 00:44:38.976 A:middle
Bound.

00:44:38.976 --> 00:44:41.366 A:middle
And we can clearly see that this

00:44:41.366 --> 00:44:42.536 A:middle
section is definitely never been

00:44:42.536 --> 00:44:44.396 A:middle
accessed by either the CPU or

00:44:44.396 --> 00:44:44.946 A:middle
the GPU.

00:44:45.406 --> 00:44:46.396 A:middle
So, therefore, we can say with

00:44:46.396 --> 00:44:47.506 A:middle
confidence now this is a

00:44:47.736 --> 00:44:49.406 A:middle
resource that it should be under

00:44:49.406 --> 00:44:51.756 A:middle
down, till it's actually needed.

00:44:52.066 --> 00:44:53.186 A:middle
OK. So, that's encouraging, we

00:44:53.186 --> 00:44:54.686 A:middle
very quickly identify 13

00:44:54.726 --> 00:44:56.086 A:middle
megabytes of memory savings.

00:44:56.846 --> 00:44:58.226 A:middle
Let's check out the next issue.

00:44:58.866 --> 00:45:01.476 A:middle
So, in this case, texture has

00:44:58.866 --> 00:45:01.476 A:middle
So, in this case, texture has

00:45:01.476 --> 00:45:03.036 A:middle
been identified as a temporary

00:45:03.036 --> 00:45:03.566 A:middle
resource.

00:45:03.886 --> 00:45:05.726 A:middle
It's not accessed by the CPU and

00:45:05.726 --> 00:45:06.966 A:middle
has not been bound to a command

00:45:06.966 --> 00:45:08.966 A:middle
encoder for over 47 seconds.

00:45:09.666 --> 00:45:10.936 A:middle
So, in other words, this texture

00:45:10.966 --> 00:45:12.606 A:middle
has not been using this frame or

00:45:12.606 --> 00:45:13.986 A:middle
in any other frame in the last

00:45:13.986 --> 00:45:14.986 A:middle
47 seconds.

00:45:15.536 --> 00:45:16.606 A:middle
So this is a pretty good

00:45:16.606 --> 00:45:18.196 A:middle
candidate for a resource that

00:45:18.196 --> 00:45:19.846 A:middle
should be made volatile if

00:45:19.886 --> 00:45:21.796 A:middle
possible since it occasionally

00:45:21.796 --> 00:45:22.916 A:middle
contributes to a frame.

00:45:23.816 --> 00:45:26.726 A:middle
OK. So, this is fantastic.

00:45:27.056 --> 00:45:30.826 A:middle
We've very quickly found about

00:45:30.826 --> 00:45:32.526 A:middle
14 megabytes of memory savings

00:45:33.006 --> 00:45:35.796 A:middle
and indeed when looking to

00:45:35.796 --> 00:45:36.876 A:middle
reduce our memory footprint

00:45:37.256 --> 00:45:39.086 A:middle
looking at unused resources is a

00:45:39.086 --> 00:45:41.026 A:middle
great place to begin on issues

00:45:41.026 --> 00:45:41.926 A:middle
that will help you to quickly

00:45:41.926 --> 00:45:43.586 A:middle
identify the best candidates to

00:45:43.586 --> 00:45:43.906 A:middle
remove.

00:45:44.976 --> 00:45:45.916 A:middle
But you should also pay

00:45:45.916 --> 00:45:47.166 A:middle
attention to the properties

00:45:47.566 --> 00:45:51.256 A:middle
Times since Last Bound to figure

00:45:51.256 --> 00:45:52.246 A:middle
out which of your unused

00:45:52.246 --> 00:45:53.456 A:middle
resources have never been

00:45:53.456 --> 00:45:55.396 A:middle
submitted to the GPU even though

00:45:55.396 --> 00:45:56.556 A:middle
they may have been accessed by

00:45:56.556 --> 00:45:57.156 A:middle
the CPU.

00:45:59.196 --> 00:46:00.236 A:middle
OK. Let's switch things up a

00:45:59.196 --> 00:46:00.236 A:middle
OK. Let's switch things up a

00:46:00.236 --> 00:46:00.506 A:middle
bit.

00:46:00.836 --> 00:46:02.726 A:middle
Let's see what issues or what

00:46:02.726 --> 00:46:04.736 A:middle
memory savings we can discover,

00:46:04.736 --> 00:46:06.096 A:middle
where textures are actually in

00:46:06.096 --> 00:46:06.476 A:middle
used.

00:46:06.786 --> 00:46:08.696 A:middle
OK. I'm going to switch to the

00:46:08.696 --> 00:46:09.876 A:middle
used filter this time, so we're

00:46:09.876 --> 00:46:11.166 A:middle
looking at used textures.

00:46:11.956 --> 00:46:12.996 A:middle
And we see that one of our

00:46:12.996 --> 00:46:14.446 A:middle
largest textures which is about

00:46:14.446 --> 00:46:16.536 A:middle
18 megabytes has two issues.

00:46:17.296 --> 00:46:18.306 A:middle
So, let's see what they are.

00:46:18.306 --> 00:46:20.666 A:middle
OK. So, the first one is about

00:46:20.736 --> 00:46:22.586 A:middle
lossless compression.

00:46:22.666 --> 00:46:24.176 A:middle
Texture has opted out of

00:46:24.206 --> 00:46:26.106 A:middle
lossless compressions because of

00:46:26.106 --> 00:46:27.466 A:middle
the presence of a ShaderWrite

00:46:27.526 --> 00:46:29.486 A:middle
usage flag, even though it's

00:46:29.486 --> 00:46:31.026 A:middle
being used exclusively as a

00:46:31.026 --> 00:46:31.696 A:middle
render target.

00:46:32.706 --> 00:46:34.566 A:middle
The second issue is about

00:46:34.566 --> 00:46:35.156 A:middle
storage mode.

00:46:36.086 --> 00:46:37.996 A:middle
Our texture the render target

00:46:37.996 --> 00:46:39.246 A:middle
has been identified as being

00:46:39.246 --> 00:46:41.316 A:middle
transient which obviously means

00:46:41.316 --> 00:46:42.766 A:middle
that no loads to actions are

00:46:42.766 --> 00:46:43.586 A:middle
required for this texture.

00:46:44.176 --> 00:46:45.586 A:middle
But unfortunately it has a

00:46:45.586 --> 00:46:47.496 A:middle
storage mode shared when really

00:46:47.496 --> 00:46:48.676 A:middle
it should be memoryless.

00:46:49.826 --> 00:46:51.596 A:middle
So, we have two different

00:46:51.596 --> 00:46:52.386 A:middle
recommendations here.

00:46:53.196 --> 00:46:55.186 A:middle
And if you think about it, we

00:46:55.186 --> 00:46:56.416 A:middle
can only really choose one of

00:46:56.416 --> 00:46:56.506 A:middle
them.

00:46:57.596 --> 00:46:58.536 A:middle
But at this point I should

00:46:58.536 --> 00:46:59.626 A:middle
emphasize that these

00:46:59.626 --> 00:47:01.446 A:middle
recommendations presented by the

00:46:59.626 --> 00:47:01.446 A:middle
recommendations presented by the

00:47:01.446 --> 00:47:03.496 A:middle
Memory Viewer are based on data

00:47:03.496 --> 00:47:04.686 A:middle
gathered up to the current

00:47:04.686 --> 00:47:04.996 A:middle
frame.

00:47:05.906 --> 00:47:07.836 A:middle
However, you know better by how

00:47:07.836 --> 00:47:09.226 A:middle
you intend to use your resource

00:47:09.296 --> 00:47:10.306 A:middle
beyond the current frame.

00:47:11.386 --> 00:47:13.876 A:middle
So, with that said if we are

00:47:13.876 --> 00:47:15.386 A:middle
certain that this texture will

00:47:15.386 --> 00:47:17.336 A:middle
remain transient and say a

00:47:17.336 --> 00:47:19.416 A:middle
future render passes then

00:47:19.556 --> 00:47:20.786 A:middle
switching to memoryless is the

00:47:20.786 --> 00:47:21.586 A:middle
superior option.

00:47:21.706 --> 00:47:23.716 A:middle
And doing so would reduce our

00:47:23.716 --> 00:47:24.956 A:middle
memory footprint by the size of

00:47:24.956 --> 00:47:26.186 A:middle
the texture which is 18

00:47:26.186 --> 00:47:26.736 A:middle
megabytes.

00:47:27.676 --> 00:47:29.426 A:middle
If on the other hand, our

00:47:29.426 --> 00:47:32.276 A:middle
texture will not be transient in

00:47:32.276 --> 00:47:34.436 A:middle
future render passes then we

00:47:34.436 --> 00:47:36.056 A:middle
should seriously consider opting

00:47:36.056 --> 00:47:37.246 A:middle
into lossless compression

00:47:37.876 --> 00:47:39.076 A:middle
because doing so would have a

00:47:39.076 --> 00:47:40.426 A:middle
positive impact on our memory

00:47:40.426 --> 00:47:41.656 A:middle
bandwidth as suggested by

00:47:41.656 --> 00:47:42.006 A:middle
Guillem.

00:47:42.866 --> 00:47:44.706 A:middle
And, in this case, simply

00:47:44.706 --> 00:47:46.016 A:middle
removing the redundant

00:47:46.016 --> 00:47:48.206 A:middle
ShaderWrite flag should do the

00:47:49.336 --> 00:47:49.476 A:middle
trick.

00:47:49.656 --> 00:47:52.636 A:middle
So, we've only just scratched

00:47:52.636 --> 00:47:54.116 A:middle
the surface of what's possible

00:47:54.236 --> 00:47:54.996 A:middle
with the Memory Viewer.

00:47:55.556 --> 00:47:56.556 A:middle
You've seen how with just a few

00:47:56.556 --> 00:47:57.716 A:middle
mouse clicks it makes it very

00:47:57.716 --> 00:47:59.496 A:middle
easy for you to understand your

00:47:59.496 --> 00:48:01.266 A:middle
memory usage and also it makes

00:47:59.496 --> 00:48:01.266 A:middle
memory usage and also it makes

00:48:01.266 --> 00:48:02.596 A:middle
it very quick for you to

00:48:02.596 --> 00:48:04.516 A:middle
identify those hard to find

00:48:04.516 --> 00:48:05.696 A:middle
issues that may affect your

00:48:05.696 --> 00:48:06.266 A:middle
performance.

00:48:06.536 --> 00:48:07.876 A:middle
And with that I'm going to

00:48:07.876 --> 00:48:09.096 A:middle
welcome Guillem back to the

00:48:09.096 --> 00:48:09.456 A:middle
stage.

00:48:09.666 --> 00:48:09.856 A:middle
Thank you.

00:48:10.516 --> 00:48:14.886 A:middle
[ Applause ]

00:48:15.386 --> 00:48:16.856 A:middle
&gt;&gt; Thank you that was also an

00:48:16.856 --> 00:48:17.516 A:middle
awesome demo.

00:48:18.856 --> 00:48:22.146 A:middle
Cool. So, we have seen a lot of

00:48:22.146 --> 00:48:23.126 A:middle
best practices today.

00:48:23.126 --> 00:48:25.666 A:middle
We've been through a total of 18

00:48:25.666 --> 00:48:27.146 A:middle
of them which is quite a lot of

00:48:27.146 --> 00:48:28.506 A:middle
content to go through really.

00:48:29.416 --> 00:48:30.916 A:middle
Notice that most of this best

00:48:30.916 --> 00:48:32.336 A:middle
practices are actually quite

00:48:32.336 --> 00:48:33.146 A:middle
related, right?

00:48:33.206 --> 00:48:35.656 A:middle
So, most of the memory bandwidth

00:48:35.656 --> 00:48:37.426 A:middle
best practices, will also help

00:48:37.426 --> 00:48:38.416 A:middle
you reducing the memory

00:48:38.466 --> 00:48:39.086 A:middle
footprint.

00:48:39.866 --> 00:48:42.496 A:middle
So, maybe the best way to

00:48:42.496 --> 00:48:44.056 A:middle
actually think about all this

00:48:44.056 --> 00:48:46.506 A:middle
content, this is a checklist of

00:48:46.506 --> 00:48:48.166 A:middle
optimizations for your Metal

00:48:48.166 --> 00:48:49.236 A:middle
gamer application.

00:48:50.386 --> 00:48:53.416 A:middle
And when you carefully take all

00:48:53.416 --> 00:48:56.076 A:middle
of these elements, you too will

00:48:56.076 --> 00:48:58.236 A:middle
be delivering optimized Metal

00:48:58.266 --> 00:49:00.396 A:middle
games and apps, which was all

00:48:58.266 --> 00:49:00.396 A:middle
games and apps, which was all

00:49:00.396 --> 00:49:02.486 A:middle
that this talk is all about.

00:49:02.836 --> 00:49:05.026 A:middle
For more information please see

00:49:05.026 --> 00:49:07.146 A:middle
our documentation online and

00:49:07.146 --> 00:49:08.996 A:middle
come visit us at the lab today

00:49:08.996 --> 00:49:09.406 A:middle
at 3.

00:49:10.456 --> 00:49:11.696 A:middle
Thank you very much and I hope

00:49:11.696 --> 00:49:12.766 A:middle
you enjoy the rest of the show.

00:49:12.766 --> 00:49:12.956 A:middle
Thank you.

00:49:13.508 --> 00:49:15.508 A:middle
[ Applause ]
