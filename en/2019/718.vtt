WEBVTT

00:00:00.506 --> 00:00:06.456 A:middle
[ Music ]

00:00:06.955 --> 00:00:08.486 A:middle
&gt;&gt; Hello. My name is Simon

00:00:08.486 --> 00:00:09.886 A:middle
Gladman and I'm with the Vector

00:00:09.886 --> 00:00:10.696 A:middle
and Numerics group.

00:00:11.316 --> 00:00:12.396 A:middle
In this presentation, I'll be

00:00:12.396 --> 00:00:14.276 A:middle
talking about two topics.

00:00:14.546 --> 00:00:16.736 A:middle
First, our new Swift Overlay for

00:00:16.736 --> 00:00:17.426 A:middle
Accelerate.

00:00:17.466 --> 00:00:19.086 A:middle
And second, measuring

00:00:19.086 --> 00:00:20.636 A:middle
Accelerate's performance using

00:00:20.636 --> 00:00:21.816 A:middle
the Linpack benchmark.

00:00:22.166 --> 00:00:23.396 A:middle
Before we dive into the Swift

00:00:23.396 --> 00:00:25.806 A:middle
Overlay, let's recap exactly

00:00:25.806 --> 00:00:27.106 A:middle
what the Accelerate framework

00:00:27.106 --> 00:00:27.506 A:middle
is.

00:00:27.826 --> 00:00:30.476 A:middle
The primary purpose of

00:00:30.476 --> 00:00:31.796 A:middle
Accelerate is to provide

00:00:31.796 --> 00:00:33.486 A:middle
thousands of low-level math

00:00:33.486 --> 00:00:35.676 A:middle
primitives that run on a CPU and

00:00:35.676 --> 00:00:36.776 A:middle
support image and signal

00:00:36.776 --> 00:00:38.676 A:middle
processing, vector arithmetic,

00:00:38.866 --> 00:00:40.466 A:middle
linear algebra, and machine

00:00:40.466 --> 00:00:41.006 A:middle
learning.

00:00:41.716 --> 00:00:42.816 A:middle
Most of these primitives are

00:00:42.816 --> 00:00:43.956 A:middle
hand tuned to the

00:00:43.956 --> 00:00:45.076 A:middle
microarchitecture of the

00:00:45.076 --> 00:00:45.646 A:middle
processor.

00:00:46.206 --> 00:00:47.416 A:middle
This means we get excellent

00:00:47.416 --> 00:00:49.636 A:middle
performance and this performance

00:00:49.636 --> 00:00:51.356 A:middle
translates directly into energy

00:00:51.356 --> 00:00:52.036 A:middle
savings.

00:00:52.276 --> 00:00:54.776 A:middle
So, if you're an app developer

00:00:54.886 --> 00:00:56.096 A:middle
and you use the Accelerate

00:00:56.096 --> 00:00:57.666 A:middle
framework, not only will your

00:00:57.666 --> 00:00:59.456 A:middle
application run faster, but

00:00:59.456 --> 00:01:00.836 A:middle
you'll also use less battery

00:00:59.456 --> 00:01:00.836 A:middle
you'll also use less battery

00:01:00.836 --> 00:01:01.196 A:middle
life.

00:01:03.366 --> 00:01:05.215 A:middle
We provide the primitives across

00:01:05.215 --> 00:01:06.696 A:middle
all of Apple's platforms.

00:01:06.986 --> 00:01:09.616 A:middle
This includes not only macOS and

00:01:09.616 --> 00:01:13.966 A:middle
iOS but watchOS and tVOS as

00:01:13.966 --> 00:01:14.316 A:middle
well.

00:01:15.766 --> 00:01:17.236 A:middle
This means your users are going

00:01:17.236 --> 00:01:18.526 A:middle
to have an overall better

00:01:18.526 --> 00:01:19.296 A:middle
experience.

00:01:20.746 --> 00:01:22.856 A:middle
Accelerate's libraries are

00:01:22.856 --> 00:01:24.556 A:middle
immensely powerful but up until

00:01:24.556 --> 00:01:26.226 A:middle
now, their interfaces weren't

00:01:26.226 --> 00:01:27.266 A:middle
that friendly to Swift

00:01:27.266 --> 00:01:27.996 A:middle
developers.

00:01:28.516 --> 00:01:30.196 A:middle
We've looked at four libraries

00:01:30.196 --> 00:01:32.506 A:middle
and created new Swift-friendly

00:01:32.506 --> 00:01:33.946 A:middle
APIs to make using Acclerate in

00:01:33.946 --> 00:01:35.646 A:middle
Swift projects really easy.

00:01:36.446 --> 00:01:37.906 A:middle
The four libraries we focused on

00:01:37.906 --> 00:01:41.386 A:middle
are vDSP that provides digital

00:01:41.386 --> 00:01:42.806 A:middle
signal processing routines

00:01:42.966 --> 00:01:44.256 A:middle
including arithmetic on large

00:01:44.256 --> 00:01:46.506 A:middle
vectors, Fourier transforms,

00:01:46.696 --> 00:01:48.216 A:middle
biquadratic filtering, and

00:01:48.216 --> 00:01:49.696 A:middle
powerful type conversion.

00:01:49.876 --> 00:01:53.536 A:middle
vForce that provides arithmetic

00:01:53.536 --> 00:01:54.956 A:middle
and transcendental functions

00:01:54.956 --> 00:01:56.606 A:middle
including trig and logarithmic

00:01:56.606 --> 00:01:57.306 A:middle
routines.

00:01:57.686 --> 00:02:00.206 A:middle
Quadrature, that's dedicated to

00:01:57.686 --> 00:02:00.206 A:middle
Quadrature, that's dedicated to

00:02:00.206 --> 00:02:01.706 A:middle
the numerical integration of

00:02:01.706 --> 00:02:02.456 A:middle
functions.

00:02:02.836 --> 00:02:05.726 A:middle
And vImage, that provides a huge

00:02:05.726 --> 00:02:07.126 A:middle
selection of image processing

00:02:07.126 --> 00:02:09.096 A:middle
functions and integrates easily

00:02:09.096 --> 00:02:10.336 A:middle
with core graphics and core

00:02:10.336 --> 00:02:10.686 A:middle
video.

00:02:11.476 --> 00:02:13.716 A:middle
Accelerate gets its performance

00:02:13.716 --> 00:02:15.636 A:middle
benefits by using vectorization.

00:02:15.946 --> 00:02:18.806 A:middle
To understand vectorization,

00:02:18.876 --> 00:02:20.306 A:middle
let's first look at a simple

00:02:20.306 --> 00:02:21.956 A:middle
calculation over the elements of

00:02:21.956 --> 00:02:23.606 A:middle
an array using scalar code.

00:02:24.666 --> 00:02:26.576 A:middle
If, for example, you're writing

00:02:26.576 --> 00:02:28.006 A:middle
code that multiplies each

00:02:28.006 --> 00:02:29.916 A:middle
element of one array with the

00:02:29.916 --> 00:02:31.176 A:middle
corresponding element in

00:02:31.176 --> 00:02:32.936 A:middle
another, and you're using a four

00:02:32.936 --> 00:02:34.886 A:middle
loop, each pair of elements are

00:02:34.886 --> 00:02:36.676 A:middle
separately loaded, multiplied

00:02:36.676 --> 00:02:37.906 A:middle
together, and the results

00:02:37.906 --> 00:02:38.306 A:middle
stored.

00:02:39.496 --> 00:02:41.376 A:middle
So, after the first elements in

00:02:41.376 --> 00:02:42.866 A:middle
A and B are multiplied together

00:02:42.866 --> 00:02:44.166 A:middle
to calculate the first element

00:02:44.166 --> 00:02:46.026 A:middle
in C, the second pair are

00:02:46.026 --> 00:02:46.686 A:middle
processed.

00:02:47.256 --> 00:02:49.196 A:middle
Then, the third.

00:02:49.906 --> 00:02:54.686 A:middle
And, finally, the fourth.

00:02:55.006 --> 00:02:56.466 A:middle
However, if you're processing

00:02:56.466 --> 00:02:57.736 A:middle
the elements of an array using

00:02:57.736 --> 00:02:59.826 A:middle
Accelerate, your calculation is

00:02:59.826 --> 00:03:01.396 A:middle
performed on single instruction

00:02:59.826 --> 00:03:01.396 A:middle
performed on single instruction

00:03:01.396 --> 00:03:03.156 A:middle
multiple data, or simD

00:03:03.156 --> 00:03:03.816 A:middle
registers.

00:03:04.616 --> 00:03:05.886 A:middle
These registers can perform the

00:03:05.886 --> 00:03:07.506 A:middle
same instruction on multiple

00:03:07.506 --> 00:03:09.606 A:middle
items of data by packing those

00:03:09.606 --> 00:03:10.896 A:middle
multiple items into a single

00:03:10.896 --> 00:03:11.416 A:middle
register.

00:03:12.096 --> 00:03:14.676 A:middle
For example, a single 128-bit

00:03:14.676 --> 00:03:17.116 A:middle
register can actually store four

00:03:17.116 --> 00:03:19.486 A:middle
32-bit floating point values.

00:03:19.876 --> 00:03:21.146 A:middle
So, a vectorized multiply

00:03:21.146 --> 00:03:22.916 A:middle
operation can simultaneously

00:03:22.916 --> 00:03:24.666 A:middle
multiply four pairs of elements

00:03:24.666 --> 00:03:25.226 A:middle
at a time.

00:03:26.256 --> 00:03:27.636 A:middle
This means that not only will

00:03:27.636 --> 00:03:29.236 A:middle
the task be quicker, it will

00:03:29.236 --> 00:03:30.936 A:middle
also be significantly more

00:03:30.936 --> 00:03:31.756 A:middle
energy efficient.

00:03:34.276 --> 00:03:35.926 A:middle
The multiply function we just

00:03:35.926 --> 00:03:37.456 A:middle
looked at part of Accelerate's

00:03:37.456 --> 00:03:38.686 A:middle
digital signal processing

00:03:38.686 --> 00:03:40.146 A:middle
library, vDSP.

00:03:40.766 --> 00:03:42.236 A:middle
So, let's begin by looking at

00:03:42.236 --> 00:03:44.486 A:middle
how the new Swift API simplifies

00:03:44.486 --> 00:03:46.146 A:middle
using vDSP.

00:03:47.496 --> 00:03:51.176 A:middle
vDSP provides vectorized digital

00:03:51.176 --> 00:03:52.516 A:middle
signal processing functions

00:03:52.516 --> 00:03:53.956 A:middle
including Fourier transforms,

00:03:53.956 --> 00:03:56.116 A:middle
biquadratic filtering,

00:03:56.256 --> 00:03:58.496 A:middle
convolution, and correlation.

00:03:59.676 --> 00:04:02.226 A:middle
Furthermore, vDSP also provides

00:03:59.676 --> 00:04:02.226 A:middle
Furthermore, vDSP also provides

00:04:02.226 --> 00:04:03.506 A:middle
some powerful, more general

00:04:03.506 --> 00:04:05.166 A:middle
functions including element-wise

00:04:05.166 --> 00:04:07.326 A:middle
arithmetic and type conversion.

00:04:09.056 --> 00:04:10.656 A:middle
So, even if you don't have an

00:04:10.656 --> 00:04:12.396 A:middle
immediate need to, for example,

00:04:12.396 --> 00:04:13.686 A:middle
compute the coherence of two

00:04:13.686 --> 00:04:16.305 A:middle
signals, you may find that

00:04:16.305 --> 00:04:17.676 A:middle
vDSP's general computation

00:04:17.676 --> 00:04:19.586 A:middle
routines offer a solution to

00:04:19.586 --> 00:04:21.315 A:middle
improve your app's performance.

00:04:24.616 --> 00:04:26.096 A:middle
Let's take a look at some basic

00:04:26.096 --> 00:04:26.816 A:middle
arithmetic.

00:04:27.206 --> 00:04:29.776 A:middle
An example could be given four

00:04:29.776 --> 00:04:31.056 A:middle
arrays of single-precision

00:04:31.056 --> 00:04:33.066 A:middle
values, you need to calculate

00:04:33.066 --> 00:04:34.456 A:middle
the element-wise sum of two of

00:04:34.456 --> 00:04:36.266 A:middle
the array's the element-wise

00:04:36.266 --> 00:04:37.806 A:middle
difference in the other two, and

00:04:37.806 --> 00:04:40.306 A:middle
multiply those results with each

00:04:40.846 --> 00:04:40.966 A:middle
other.

00:04:41.666 --> 00:04:43.446 A:middle
Using a four loop is a perfectly

00:04:43.446 --> 00:04:44.496 A:middle
reasonable solution to this

00:04:44.496 --> 00:04:46.126 A:middle
problem and calculates the

00:04:46.126 --> 00:04:47.106 A:middle
expected results.

00:04:47.906 --> 00:04:49.706 A:middle
Here's how you perform that

00:04:49.706 --> 00:04:52.096 A:middle
calculation using vDSP's classic

00:04:52.096 --> 00:04:52.416 A:middle
API.

00:04:53.526 --> 00:04:55.276 A:middle
Using vDSP is approximately

00:04:55.276 --> 00:04:57.166 A:middle
three times faster than the four

00:04:57.166 --> 00:04:57.536 A:middle
loop.

00:04:59.536 --> 00:05:00.926 A:middle
Here's the same computation

00:04:59.536 --> 00:05:00.926 A:middle
Here's the same computation

00:05:00.926 --> 00:05:02.566 A:middle
using our new Swift API for

00:05:02.566 --> 00:05:03.206 A:middle
vDSP.

00:05:03.206 --> 00:05:05.426 A:middle
We're exposing the new

00:05:05.426 --> 00:05:06.906 A:middle
Swift-friendly functions through

00:05:06.906 --> 00:05:09.076 A:middle
our vDSP namespace and you can

00:05:09.076 --> 00:05:10.366 A:middle
see the function and parameter

00:05:10.366 --> 00:05:11.896 A:middle
names explain the operation.

00:05:12.806 --> 00:05:14.176 A:middle
Because the new functions work

00:05:14.176 --> 00:05:15.626 A:middle
with familiar types including

00:05:15.626 --> 00:05:17.146 A:middle
arrays and array slices rather

00:05:17.146 --> 00:05:18.866 A:middle
than pointers, you no longer

00:05:18.866 --> 00:05:20.296 A:middle
need to explicitly pass the

00:05:20.296 --> 00:05:20.736 A:middle
count.

00:05:21.246 --> 00:05:22.536 A:middle
So, the entire function call is

00:05:22.536 --> 00:05:24.616 A:middle
clearer and more concise.

00:05:25.776 --> 00:05:28.676 A:middle
Passing an initialized result

00:05:28.676 --> 00:05:29.686 A:middle
array offers the best

00:05:29.686 --> 00:05:31.236 A:middle
performance and you can

00:05:31.236 --> 00:05:32.936 A:middle
obviously reuse that array in

00:05:32.936 --> 00:05:34.476 A:middle
other operations for further

00:05:34.476 --> 00:05:35.646 A:middle
performance benefits.

00:05:36.446 --> 00:05:38.946 A:middle
However, we're also providing

00:05:38.946 --> 00:05:40.726 A:middle
self-allocating functions.

00:05:41.096 --> 00:05:42.846 A:middle
These make use of Swift's new

00:05:42.846 --> 00:05:44.596 A:middle
ability to access an array's

00:05:44.596 --> 00:05:46.786 A:middle
uninitialized buffer to return

00:05:46.786 --> 00:05:48.156 A:middle
the result of a computation.

00:05:48.936 --> 00:05:50.496 A:middle
Although not quite as fast as

00:05:50.496 --> 00:05:52.386 A:middle
passing existing storage, it's

00:05:52.386 --> 00:05:53.936 A:middle
still faster than the scalar

00:05:53.936 --> 00:05:55.936 A:middle
approach and, in some cases,

00:05:55.936 --> 00:05:58.846 A:middle
will simplify your code.

00:06:00.076 --> 00:06:02.006 A:middle
Another common task that vDSP

00:06:02.006 --> 00:06:03.286 A:middle
can vectorize is type

00:06:03.286 --> 00:06:03.976 A:middle
conversion.

00:06:04.536 --> 00:06:06.416 A:middle
This example converts an array

00:06:06.416 --> 00:06:07.566 A:middle
containing double precision

00:06:07.566 --> 00:06:10.256 A:middle
values to 16-bit unsigned

00:06:10.256 --> 00:06:11.846 A:middle
integer values rounding toward

00:06:11.846 --> 00:06:12.326 A:middle
zero.

00:06:13.676 --> 00:06:16.796 A:middle
The scalar version uses map with

00:06:16.796 --> 00:06:17.776 A:middle
explicit rounding.

00:06:18.136 --> 00:06:20.026 A:middle
Again, this is a perfectly

00:06:20.026 --> 00:06:21.776 A:middle
reasonable technique to use, but

00:06:21.776 --> 00:06:24.156 A:middle
vDSP can vectorize this task to

00:06:24.156 --> 00:06:25.266 A:middle
improve performance.

00:06:25.806 --> 00:06:29.196 A:middle
In this example, vDSP is

00:06:29.196 --> 00:06:31.036 A:middle
approximately four times faster

00:06:31.036 --> 00:06:32.616 A:middle
than the previous scalar

00:06:32.616 --> 00:06:33.446 A:middle
implementation.

00:06:34.876 --> 00:06:37.386 A:middle
The new Swift version of the

00:06:37.386 --> 00:06:38.996 A:middle
vDSP function offers a clear

00:06:38.996 --> 00:06:39.746 A:middle
interface.

00:06:40.596 --> 00:06:42.166 A:middle
The function accepts a source

00:06:42.166 --> 00:06:42.486 A:middle
array.

00:06:42.916 --> 00:06:44.116 A:middle
The integer type you ought to

00:06:44.116 --> 00:06:46.036 A:middle
convert each element to, and an

00:06:46.036 --> 00:06:47.636 A:middle
enumeration to specify the

00:06:47.636 --> 00:06:48.196 A:middle
rounding.

00:06:51.936 --> 00:06:54.416 A:middle
vDSP provides Fourier transforms

00:06:54.416 --> 00:06:55.946 A:middle
for transforming one-dimensional

00:06:56.056 --> 00:06:57.966 A:middle
and two-dimensional data between

00:06:57.966 --> 00:06:59.176 A:middle
the time domain and the

00:06:59.176 --> 00:07:00.176 A:middle
frequency domain.

00:06:59.176 --> 00:07:00.176 A:middle
frequency domain.

00:07:00.456 --> 00:07:03.276 A:middle
A forward Fourier transform of a

00:07:03.276 --> 00:07:05.286 A:middle
signal decomposes it into its

00:07:05.286 --> 00:07:06.486 A:middle
component sign waves.

00:07:06.896 --> 00:07:08.106 A:middle
That's the frequency domain

00:07:08.106 --> 00:07:08.926 A:middle
representation.

00:07:10.006 --> 00:07:12.056 A:middle
Conversely, an inverse transform

00:07:12.056 --> 00:07:13.076 A:middle
of that frequency domain

00:07:13.076 --> 00:07:14.886 A:middle
representation recreates the

00:07:14.886 --> 00:07:16.506 A:middle
original signal and that's the

00:07:16.506 --> 00:07:17.986 A:middle
time domain representation.

00:07:18.446 --> 00:07:20.576 A:middle
Fourier transforms have many

00:07:20.576 --> 00:07:22.296 A:middle
uses in both signal and image

00:07:22.296 --> 00:07:22.936 A:middle
processing.

00:07:23.436 --> 00:07:24.936 A:middle
For example, once an audio

00:07:24.936 --> 00:07:26.146 A:middle
signal has been forward

00:07:26.146 --> 00:07:27.816 A:middle
transformed, you can easily

00:07:27.816 --> 00:07:29.726 A:middle
reduce or increase certain

00:07:29.726 --> 00:07:31.026 A:middle
frequencies to equalize the

00:07:31.026 --> 00:07:31.406 A:middle
audio.

00:07:33.136 --> 00:07:35.056 A:middle
The classic API is reasonably

00:07:35.056 --> 00:07:36.086 A:middle
easy to follow if you're

00:07:36.086 --> 00:07:36.666 A:middle
familiar with it.

00:07:37.116 --> 00:07:38.686 A:middle
You begin by creating a setup

00:07:38.686 --> 00:07:40.346 A:middle
object specifying the number of

00:07:40.346 --> 00:07:41.666 A:middle
elements you want to transform

00:07:41.746 --> 00:07:42.766 A:middle
and the direction.

00:07:43.386 --> 00:07:45.166 A:middle
Then, after creating two arrays

00:07:45.166 --> 00:07:46.886 A:middle
to receive results, you call the

00:07:46.886 --> 00:07:47.776 A:middle
execute function.

00:07:47.776 --> 00:07:49.496 A:middle
Once you're done, you need to

00:07:49.496 --> 00:07:51.036 A:middle
remember to destroy the setup to

00:07:51.036 --> 00:07:52.796 A:middle
free the resources allocated to

00:07:53.256 --> 00:07:53.326 A:middle
it.

00:07:53.956 --> 00:07:56.476 A:middle
The new API simplifies the

00:07:56.476 --> 00:07:57.946 A:middle
instantiation of the setup

00:07:57.946 --> 00:08:00.596 A:middle
object and the transform itself

00:07:57.946 --> 00:08:00.596 A:middle
object and the transform itself

00:08:00.596 --> 00:08:02.536 A:middle
is a method with parameter names

00:08:02.606 --> 00:08:04.016 A:middle
on the DFT instance.

00:08:04.016 --> 00:08:06.336 A:middle
And now you don't need to worry

00:08:06.336 --> 00:08:07.576 A:middle
about freeing the resources.

00:08:07.576 --> 00:08:08.546 A:middle
We do that for you.

00:08:10.376 --> 00:08:12.686 A:middle
And much like the vDSP functions

00:08:12.686 --> 00:08:14.046 A:middle
we've looked at, there's a

00:08:14.046 --> 00:08:15.626 A:middle
self-allocating version of the

00:08:15.626 --> 00:08:17.796 A:middle
transform function that creates

00:08:17.796 --> 00:08:19.516 A:middle
and returns the result's arrays

00:08:19.516 --> 00:08:20.046 A:middle
for you.

00:08:23.996 --> 00:08:25.796 A:middle
If you work with audio data, you

00:08:25.796 --> 00:08:27.596 A:middle
may be familiar with biquadratic

00:08:27.596 --> 00:08:28.776 A:middle
or biquad filtering.

00:08:29.606 --> 00:08:31.036 A:middle
Biquad filters can be used to

00:08:31.036 --> 00:08:32.655 A:middle
equalize audio to shape the

00:08:32.655 --> 00:08:34.216 A:middle
frequency response, allowing you

00:08:34.216 --> 00:08:36.506 A:middle
to, for example, remove either

00:08:36.506 --> 00:08:37.966 A:middle
low or high frequencies.

00:08:39.186 --> 00:08:41.966 A:middle
vDSP's biquad feature operates

00:08:41.966 --> 00:08:43.395 A:middle
on single and multichannel

00:08:43.395 --> 00:08:45.356 A:middle
signals, and uses a set of

00:08:45.386 --> 00:08:46.996 A:middle
individual filter objects called

00:08:46.996 --> 00:08:47.716 A:middle
sections.

00:08:48.286 --> 00:08:49.986 A:middle
The filters are cascaded; that

00:08:49.986 --> 00:08:51.156 A:middle
is, they are set up in a

00:08:51.156 --> 00:08:53.006 A:middle
sequence and the entire signal

00:08:53.006 --> 00:08:54.476 A:middle
passes through each filter in

00:08:54.476 --> 00:08:54.956 A:middle
turn.

00:08:55.956 --> 00:08:57.166 A:middle
The filters are defined by a

00:08:57.166 --> 00:08:59.086 A:middle
series of coefficients that plug

00:08:59.086 --> 00:09:00.286 A:middle
into the equation shown here.

00:08:59.086 --> 00:09:00.286 A:middle
into the equation shown here.

00:09:00.896 --> 00:09:05.336 A:middle
In this example, these values

00:09:05.336 --> 00:09:07.286 A:middle
form a low pass filter; that is,

00:09:07.286 --> 00:09:08.756 A:middle
a filter that reduces high

00:09:08.756 --> 00:09:09.456 A:middle
frequencies.

00:09:09.876 --> 00:09:11.906 A:middle
Here's the code using vDSP's

00:09:11.906 --> 00:09:13.816 A:middle
classic API to create the biquad

00:09:13.816 --> 00:09:15.516 A:middle
setup using the coefficients in

00:09:15.516 --> 00:09:16.446 A:middle
the previous slide.

00:09:17.196 --> 00:09:19.506 A:middle
And here's the code to apply

00:09:19.506 --> 00:09:21.386 A:middle
that biquad filter to an array

00:09:21.386 --> 00:09:23.056 A:middle
named signal, returning the

00:09:23.056 --> 00:09:25.086 A:middle
result to an array named output.

00:09:25.086 --> 00:09:27.006 A:middle
Let's look at the same

00:09:27.006 --> 00:09:28.696 A:middle
functionality implemented with a

00:09:28.696 --> 00:09:29.436 A:middle
new API.

00:09:31.716 --> 00:09:33.906 A:middle
As you can see, the new API

00:09:34.036 --> 00:09:35.866 A:middle
vastly simplifies the creation

00:09:35.866 --> 00:09:36.846 A:middle
of the biquad structure.

00:09:37.596 --> 00:09:39.196 A:middle
You simply pass the coefficients

00:09:39.196 --> 00:09:40.896 A:middle
to the biquad initializer and

00:09:40.896 --> 00:09:42.466 A:middle
specify the number of channels

00:09:42.466 --> 00:09:43.326 A:middle
and sections.

00:09:44.286 --> 00:09:46.346 A:middle
Applying the biquad filter to a

00:09:46.346 --> 00:09:47.926 A:middle
signal is a single function

00:09:47.926 --> 00:09:48.226 A:middle
call.

00:09:51.496 --> 00:09:54.456 A:middle
Now, let's look at the new API

00:09:54.456 --> 00:09:55.686 A:middle
we've created for Accelerate's

00:09:55.686 --> 00:09:57.356 A:middle
library for fast mathematical

00:09:57.356 --> 00:09:58.856 A:middle
operations on large arrays,

00:09:59.146 --> 00:09:59.956 A:middle
vForce.

00:10:01.896 --> 00:10:03.856 A:middle
vForce provides transcendental

00:10:03.856 --> 00:10:05.976 A:middle
functions not included in vDSP.

00:10:06.526 --> 00:10:08.196 A:middle
These include exponential,

00:10:08.346 --> 00:10:09.576 A:middle
logarithmic, and trig

00:10:09.576 --> 00:10:10.376 A:middle
operations.

00:10:12.256 --> 00:10:13.996 A:middle
A typical example of vForce

00:10:13.996 --> 00:10:15.496 A:middle
would be to calculate the square

00:10:15.496 --> 00:10:16.956 A:middle
root of each element in a large

00:10:16.956 --> 00:10:17.356 A:middle
array.

00:10:18.006 --> 00:10:19.556 A:middle
The scalar version of this code

00:10:19.556 --> 00:10:20.466 A:middle
could use map.

00:10:22.196 --> 00:10:24.116 A:middle
vForce provides a vectorized

00:10:24.116 --> 00:10:25.806 A:middle
function to calculate the square

00:10:25.806 --> 00:10:27.666 A:middle
roots that in some situations

00:10:27.666 --> 00:10:29.436 A:middle
can be up to 10 times faster

00:10:29.586 --> 00:10:31.096 A:middle
than the scalar implementation.

00:10:32.856 --> 00:10:34.996 A:middle
The new Swift overlay offers an

00:10:34.996 --> 00:10:36.756 A:middle
API that's consistent with the

00:10:36.756 --> 00:10:39.536 A:middle
new vDSP functions and provides

00:10:39.536 --> 00:10:40.806 A:middle
the performance and energy

00:10:40.806 --> 00:10:41.866 A:middle
efficiency benefits of

00:10:41.866 --> 00:10:42.756 A:middle
vectorization.

00:10:43.296 --> 00:10:46.186 A:middle
And much like we've seen

00:10:46.186 --> 00:10:46.846 A:middle
earlier, there's a

00:10:46.846 --> 00:10:48.746 A:middle
self-allocating version that

00:10:48.746 --> 00:10:50.486 A:middle
returns an array containing the

00:10:50.486 --> 00:10:51.806 A:middle
square roots of each element in

00:10:51.806 --> 00:10:53.000 A:middle
the supplied array.

00:10:57.056 --> 00:10:58.256 A:middle
Next, we'll take a look at the

00:10:58.256 --> 00:11:01.036 A:middle
new API we've created for

00:10:58.256 --> 00:11:01.036 A:middle
new API we've created for

00:11:01.736 --> 00:11:02.456 A:middle
Quadrature.

00:11:02.566 --> 00:11:04.516 A:middle
Quadrature is a historic term

00:11:04.516 --> 00:11:06.006 A:middle
for determining the area under a

00:11:06.006 --> 00:11:06.416 A:middle
curve.

00:11:07.246 --> 00:11:09.126 A:middle
It provides an approximation of

00:11:09.126 --> 00:11:10.266 A:middle
the definite integrative

00:11:10.266 --> 00:11:11.946 A:middle
function over a finite or

00:11:11.946 --> 00:11:12.956 A:middle
infinite interval.

00:11:13.556 --> 00:11:15.736 A:middle
In this example, we'll use

00:11:15.736 --> 00:11:17.186 A:middle
Quadrature to approximate the

00:11:17.186 --> 00:11:19.046 A:middle
area of a semicircle, shown here

00:11:19.046 --> 00:11:21.026 A:middle
in green, by integrating the

00:11:21.026 --> 00:11:22.536 A:middle
functions shown.

00:11:24.396 --> 00:11:26.836 A:middle
Much like the Biquad code for

00:11:26.836 --> 00:11:28.896 A:middle
vDSP, there's a fair amount of

00:11:28.896 --> 00:11:30.376 A:middle
code required to use the

00:11:30.376 --> 00:11:31.926 A:middle
existing Quadrature API.

00:11:32.616 --> 00:11:35.006 A:middle
The first step is to define a

00:11:35.006 --> 00:11:36.346 A:middle
structure that describes a

00:11:36.346 --> 00:11:37.616 A:middle
function to integrate.

00:11:39.076 --> 00:11:41.716 A:middle
The second step is to define the

00:11:41.716 --> 00:11:43.456 A:middle
integration options including

00:11:43.456 --> 00:11:44.726 A:middle
the integration algorithm.

00:11:45.496 --> 00:11:48.296 A:middle
Finally, with the function on

00:11:48.296 --> 00:11:50.416 A:middle
options defined, you can perform

00:11:50.416 --> 00:11:51.566 A:middle
the integration using the

00:11:51.566 --> 00:11:53.016 A:middle
Quadrature integrate function.

00:11:55.946 --> 00:11:58.386 A:middle
The new API simplifies the code.

00:11:58.886 --> 00:12:00.476 A:middle
One great advantage is that you

00:11:58.886 --> 00:12:00.476 A:middle
One great advantage is that you

00:12:00.476 --> 00:12:02.256 A:middle
can specify the integrand, that

00:12:02.256 --> 00:12:03.196 A:middle
is, the function to be

00:12:03.196 --> 00:12:05.246 A:middle
integrated, as a trading closure

00:12:05.426 --> 00:12:06.626 A:middle
rather than as a C function

00:12:06.626 --> 00:12:07.066 A:middle
pointer.

00:12:07.636 --> 00:12:09.186 A:middle
This means you can easily pass

00:12:09.186 --> 00:12:10.646 A:middle
values into the integrand.

00:12:11.606 --> 00:12:13.716 A:middle
Also note that integrators are

00:12:13.716 --> 00:12:15.616 A:middle
now enumerations with associated

00:12:15.616 --> 00:12:16.286 A:middle
values.

00:12:16.736 --> 00:12:18.146 A:middle
So, there's no need to supply

00:12:18.146 --> 00:12:19.986 A:middle
unnecessary points for interval

00:12:20.016 --> 00:12:21.446 A:middle
or maximum intervals here.

00:12:21.806 --> 00:12:24.896 A:middle
For example, you can pass the

00:12:24.896 --> 00:12:26.236 A:middle
enumeration for the globally

00:12:26.236 --> 00:12:28.376 A:middle
adaptive integrator specifying

00:12:28.456 --> 00:12:29.596 A:middle
the points for interval and

00:12:29.596 --> 00:12:30.686 A:middle
maximum intervals.

00:12:33.456 --> 00:12:36.676 A:middle
Now, let's look at the new API

00:12:36.806 --> 00:12:38.316 A:middle
we've created for Accelerate's

00:12:38.316 --> 00:12:39.536 A:middle
image processing library,

00:12:39.536 --> 00:12:40.216 A:middle
vImage.

00:12:41.876 --> 00:12:43.606 A:middle
vImage is a library containing a

00:12:43.606 --> 00:12:44.936 A:middle
rich collection of image

00:12:44.936 --> 00:12:45.906 A:middle
processing tools.

00:12:46.536 --> 00:12:48.456 A:middle
It's designed to work seamlessly

00:12:48.456 --> 00:12:51.186 A:middle
with both core graphics and core

00:12:51.186 --> 00:12:51.736 A:middle
video.

00:12:51.786 --> 00:12:54.506 A:middle
It includes operations such as

00:12:54.506 --> 00:12:56.966 A:middle
alpha blending, format

00:12:56.966 --> 00:12:59.216 A:middle
conversions, histogram

00:12:59.216 --> 00:13:01.696 A:middle
operations, convolution,

00:12:59.216 --> 00:13:01.696 A:middle
operations, convolution,

00:13:02.596 --> 00:13:05.216 A:middle
geometry, and morphology.

00:13:07.516 --> 00:13:10.336 A:middle
Our new Swift API introduces

00:13:10.336 --> 00:13:11.806 A:middle
lots of new features that makes

00:13:11.806 --> 00:13:14.116 A:middle
using vImage in Swift easier and

00:13:14.116 --> 00:13:15.006 A:middle
more concise.

00:13:15.556 --> 00:13:16.906 A:middle
We've implemented flags as an

00:13:16.906 --> 00:13:17.576 A:middle
option set.

00:13:18.236 --> 00:13:20.436 A:middle
vImages throw Swift errors.

00:13:20.436 --> 00:13:21.886 A:middle
And we've hidden some of the

00:13:21.886 --> 00:13:23.466 A:middle
requirements for mutability and

00:13:23.466 --> 00:13:25.236 A:middle
working with unmanaged types.

00:13:27.646 --> 00:13:28.696 A:middle
If you're working with core

00:13:28.696 --> 00:13:30.076 A:middle
graphics images, there's a

00:13:30.076 --> 00:13:31.606 A:middle
common workflow to get that

00:13:31.606 --> 00:13:33.356 A:middle
image data into a vImage buffer.

00:13:35.076 --> 00:13:36.706 A:middle
First, you need to create a

00:13:36.706 --> 00:13:38.386 A:middle
description of the CG images

00:13:38.386 --> 00:13:38.916 A:middle
format.

00:13:40.286 --> 00:13:42.166 A:middle
Then, instantiate a vImage

00:13:42.166 --> 00:13:42.596 A:middle
buffer.

00:13:43.366 --> 00:13:44.766 A:middle
Initialize that buffer from the

00:13:44.766 --> 00:13:45.246 A:middle
image.

00:13:45.246 --> 00:13:46.986 A:middle
And finally, check for errors in

00:13:46.986 --> 00:13:48.426 A:middle
a non-Swift way.

00:13:48.696 --> 00:13:50.656 A:middle
And that's a lot of boilerplate

00:13:50.656 --> 00:13:52.236 A:middle
code for a common operation.

00:13:53.226 --> 00:13:55.936 A:middle
The new API wraps up all of that

00:13:55.936 --> 00:13:58.056 A:middle
code into a single throwable

00:13:58.056 --> 00:13:58.696 A:middle
initializer.

00:13:59.906 --> 00:14:02.396 A:middle
However, since we're going to

00:13:59.906 --> 00:14:02.396 A:middle
However, since we're going to

00:14:02.396 --> 00:14:04.196 A:middle
use a CG images format later,

00:14:04.356 --> 00:14:05.896 A:middle
here's similar functionality

00:14:05.966 --> 00:14:07.516 A:middle
implemented in two steps with a

00:14:07.516 --> 00:14:07.976 A:middle
new API.

00:14:08.726 --> 00:14:10.876 A:middle
We've added a new initializer to

00:14:10.876 --> 00:14:12.686 A:middle
CG image format using a CG

00:14:12.686 --> 00:14:15.086 A:middle
image, and an alternative buffer

00:14:15.086 --> 00:14:16.976 A:middle
initializer that accepts a CG

00:14:16.976 --> 00:14:18.716 A:middle
image and an explicit format

00:14:18.716 --> 00:14:19.266 A:middle
description.

00:14:19.666 --> 00:14:22.546 A:middle
Once you're finished working

00:14:22.546 --> 00:14:23.806 A:middle
with a buffer, here's the

00:14:23.806 --> 00:14:25.236 A:middle
classic vImage function to

00:14:25.236 --> 00:14:26.716 A:middle
create a CG image from the

00:14:26.716 --> 00:14:27.736 A:middle
buffer's contents.

00:14:28.696 --> 00:14:30.856 A:middle
And our new API simplifies that

00:14:30.856 --> 00:14:33.336 A:middle
operation too with a new create

00:14:33.336 --> 00:14:34.796 A:middle
CG image method that uses the

00:14:34.796 --> 00:14:36.296 A:middle
format we've just generated from

00:14:36.296 --> 00:14:36.776 A:middle
the image.

00:14:37.876 --> 00:14:40.156 A:middle
One important use case for

00:14:40.156 --> 00:14:41.916 A:middle
vImage is converting between

00:14:41.916 --> 00:14:43.286 A:middle
different domains and different

00:14:43.286 --> 00:14:44.026 A:middle
formats.

00:14:44.576 --> 00:14:46.636 A:middle
vImage's any-to-any convertors

00:14:46.636 --> 00:14:48.246 A:middle
can convert between core video

00:14:48.246 --> 00:14:50.206 A:middle
and core graphics, and convert

00:14:50.206 --> 00:14:51.966 A:middle
between different core graphics

00:14:51.966 --> 00:14:52.586 A:middle
formats.

00:14:53.926 --> 00:14:55.926 A:middle
For example, you might want to

00:14:55.926 --> 00:14:57.956 A:middle
convert a CMYK core graphics

00:14:57.956 --> 00:14:59.876 A:middle
image to RGB.

00:15:01.056 --> 00:15:03.706 A:middle
The existing API to create a

00:15:03.706 --> 00:15:05.516 A:middle
convertor accepts the source and

00:15:05.516 --> 00:15:06.756 A:middle
destination formats for the

00:15:06.756 --> 00:15:08.446 A:middle
conversion and returns an

00:15:08.446 --> 00:15:09.646 A:middle
unmanaged convertor.

00:15:11.036 --> 00:15:12.486 A:middle
You take the managed reference

00:15:12.486 --> 00:15:14.126 A:middle
of the convertor and pass that

00:15:14.126 --> 00:15:15.116 A:middle
to the function that does the

00:15:15.116 --> 00:15:15.756 A:middle
conversion.

00:15:17.216 --> 00:15:19.906 A:middle
Our new API adds a new static

00:15:19.906 --> 00:15:21.276 A:middle
make function to the existing

00:15:21.276 --> 00:15:22.996 A:middle
convertor type that returns a

00:15:22.996 --> 00:15:24.336 A:middle
convertor instance.

00:15:25.006 --> 00:15:27.566 A:middle
The conversion is done with the

00:15:27.566 --> 00:15:29.156 A:middle
convert method on the convertor

00:15:29.156 --> 00:15:29.856 A:middle
instance.

00:15:31.076 --> 00:15:33.176 A:middle
Finally, let's look at working

00:15:33.176 --> 00:15:34.896 A:middle
with core video image formats.

00:15:35.456 --> 00:15:37.396 A:middle
In a typical example, you may

00:15:37.396 --> 00:15:39.176 A:middle
want to create an image format

00:15:39.176 --> 00:15:40.926 A:middle
description from a core video

00:15:40.926 --> 00:15:43.276 A:middle
pixel buffer and calculate its

00:15:43.276 --> 00:15:43.996 A:middle
channel count.

00:15:45.406 --> 00:15:46.786 A:middle
Here's the code required by the

00:15:46.786 --> 00:15:49.366 A:middle
classic vImage API to create an

00:15:49.366 --> 00:15:50.756 A:middle
image format description from a

00:15:50.756 --> 00:15:52.406 A:middle
pixel buffer and get its channel

00:15:52.406 --> 00:15:52.766 A:middle
count.

00:15:53.216 --> 00:15:55.976 A:middle
The new API provides the same

00:15:55.976 --> 00:15:57.516 A:middle
functionality in two lines of

00:15:57.516 --> 00:15:57.946 A:middle
code.

00:15:58.756 --> 00:16:00.446 A:middle
You create an instance of a core

00:15:58.756 --> 00:16:00.446 A:middle
You create an instance of a core

00:16:00.446 --> 00:16:01.946 A:middle
video image format from a pixel

00:16:01.946 --> 00:16:03.826 A:middle
buffer using a new static make

00:16:03.826 --> 00:16:04.316 A:middle
function.

00:16:04.956 --> 00:16:07.136 A:middle
And simply access its channel

00:16:07.136 --> 00:16:11.866 A:middle
count as a property.

00:16:13.266 --> 00:16:14.806 A:middle
That was a quick tour of a

00:16:14.806 --> 00:16:15.936 A:middle
fraction of the new API.

00:16:16.426 --> 00:16:18.506 A:middle
Let's now take a look at Linpack

00:16:18.506 --> 00:16:20.126 A:middle
Benchmark and see just how much

00:16:20.126 --> 00:16:22.036 A:middle
faster and more energy efficient

00:16:22.036 --> 00:16:23.016 A:middle
Accelerate can be.

00:16:24.076 --> 00:16:25.696 A:middle
The Linpack Benchmark came out

00:16:25.696 --> 00:16:27.146 A:middle
of the Linpack library which

00:16:27.146 --> 00:16:28.776 A:middle
started as a set of routines for

00:16:28.776 --> 00:16:31.026 A:middle
providing fast computational

00:16:31.026 --> 00:16:31.856 A:middle
linear algebra.

00:16:32.206 --> 00:16:34.576 A:middle
This was later subsumed by a

00:16:34.576 --> 00:16:36.006 A:middle
library called LApack, which

00:16:36.006 --> 00:16:37.216 A:middle
stands for Linear algebra

00:16:37.216 --> 00:16:37.796 A:middle
package.

00:16:38.396 --> 00:16:40.536 A:middle
LApack was developed to take

00:16:40.536 --> 00:16:42.006 A:middle
advantage of these new things at

00:16:42.006 --> 00:16:43.066 A:middle
the time called caches.

00:16:43.066 --> 00:16:45.506 A:middle
LApack is comprised of many

00:16:45.616 --> 00:16:46.436 A:middle
blocked algorithms.

00:16:46.436 --> 00:16:48.426 A:middle
These algorit6thms are built on

00:16:48.426 --> 00:16:49.496 A:middle
top of another library called

00:16:49.496 --> 00:16:51.036 A:middle
BLAS, which stands for basic

00:16:51.036 --> 00:16:52.786 A:middle
linear algebra subroutines.

00:16:52.956 --> 00:16:55.416 A:middle
We'll talk more about BLAS later

00:16:55.416 --> 00:16:56.366 A:middle
in this presentation.

00:16:56.786 --> 00:16:58.806 A:middle
For now, keep in mind that the

00:16:58.806 --> 00:17:00.536 A:middle
Linpack Benchmark runs on top of

00:16:58.806 --> 00:17:00.536 A:middle
Linpack Benchmark runs on top of

00:17:00.536 --> 00:17:02.246 A:middle
LApack, which runs on top of

00:17:02.246 --> 00:17:03.000 A:middle
BLAS.

00:17:05.955 --> 00:17:07.435 A:middle
The Linpack Benchmark measures

00:17:07.435 --> 00:17:09.396 A:middle
how quickly a platform can solve

00:17:09.396 --> 00:17:10.675 A:middle
a general system of linear

00:17:10.675 --> 00:17:11.376 A:middle
equations.

00:17:12.156 --> 00:17:13.806 A:middle
It is comprised of two steps.

00:17:14.116 --> 00:17:15.896 A:middle
The matrix factorization step,

00:17:16.036 --> 00:17:17.665 A:middle
followed by the backsole step.

00:17:18.425 --> 00:17:19.935 A:middle
By fixing the algorithm, we're

00:17:19.935 --> 00:17:21.336 A:middle
able to see how well different

00:17:21.336 --> 00:17:22.596 A:middle
platforms are at running the

00:17:22.596 --> 00:17:23.146 A:middle
algorithm.

00:17:24.036 --> 00:17:25.415 A:middle
This provides us with a method

00:17:25.415 --> 00:17:26.425 A:middle
of comparing different

00:17:26.425 --> 00:17:27.096 A:middle
platforms.

00:17:27.776 --> 00:17:29.036 A:middle
The Linpack Benchmark has

00:17:29.036 --> 00:17:30.086 A:middle
evolved over time.

00:17:30.666 --> 00:17:32.626 A:middle
Originally, it solved a 100 by

00:17:32.626 --> 00:17:35.746 A:middle
100 system, and later a 1000 by

00:17:35.746 --> 00:17:36.826 A:middle
1000 system.

00:17:37.426 --> 00:17:39.556 A:middle
The variant most often used

00:17:39.556 --> 00:17:41.326 A:middle
today is the no holds barred

00:17:41.326 --> 00:17:43.476 A:middle
variant, where the problem size

00:17:43.536 --> 00:17:44.696 A:middle
can be as large as you want.

00:17:45.366 --> 00:17:47.206 A:middle
This is the variant we will be

00:17:47.206 --> 00:17:47.876 A:middle
running today.

00:17:48.476 --> 00:17:51.026 A:middle
We are now going to compare

00:17:51.026 --> 00:17:52.726 A:middle
Linpack performance on an iPhone

00:17:52.726 --> 00:17:53.316 A:middle
10S.

00:17:53.806 --> 00:17:55.876 A:middle
At the top in orange, we're

00:17:55.876 --> 00:17:57.676 A:middle
going to run an unoptimized

00:17:57.676 --> 00:17:58.226 A:middle
Linpack.

00:17:58.996 --> 00:18:00.656 A:middle
This Linpack Benchmark does not

00:17:58.996 --> 00:18:00.656 A:middle
This Linpack Benchmark does not

00:18:00.656 --> 00:18:01.766 A:middle
make use of the accelerate

00:18:01.766 --> 00:18:02.306 A:middle
framework.

00:18:02.966 --> 00:18:04.366 A:middle
It relies on software that is

00:18:04.366 --> 00:18:05.846 A:middle
not tuned to the process that it

00:18:05.846 --> 00:18:06.796 A:middle
is running on.

00:18:07.106 --> 00:18:10.976 A:middle
Let's see what that looks like.

00:18:11.046 --> 00:18:12.446 A:middle
We are now going to compare that

00:18:12.446 --> 00:18:13.436 A:middle
with using the Accelerate

00:18:13.436 --> 00:18:15.636 A:middle
framework; that is, we're going

00:18:15.636 --> 00:18:17.486 A:middle
to run the same benchmark on the

00:18:17.486 --> 00:18:19.346 A:middle
same platform, but using the

00:18:19.346 --> 00:18:21.086 A:middle
Accelerate framework which is

00:18:21.086 --> 00:18:22.286 A:middle
tuned to the platform.

00:18:25.856 --> 00:18:27.456 A:middle
We can see that by using the

00:18:27.456 --> 00:18:29.096 A:middle
Accelerate framework, we are

00:18:29.096 --> 00:18:30.996 A:middle
over 24 times faster.

00:18:31.836 --> 00:18:33.376 A:middle
This will not only save time,

00:18:33.376 --> 00:18:35.416 A:middle
but also energy, which improves

00:18:35.416 --> 00:18:36.166 A:middle
battery life.

00:18:36.936 --> 00:18:38.436 A:middle
We're now going to shift gears

00:18:38.436 --> 00:18:39.606 A:middle
and take a look at the primary

00:18:39.606 --> 00:18:40.876 A:middle
workhorse routine for the

00:18:40.876 --> 00:18:42.716 A:middle
Linpack Benchmark called GEMM.

00:18:44.396 --> 00:18:46.916 A:middle
As I mentioned earlier, Linpack,

00:18:47.166 --> 00:18:49.316 A:middle
which runs on LApack, is built

00:18:49.316 --> 00:18:50.276 A:middle
on top of BLAS.

00:18:51.036 --> 00:18:52.746 A:middle
Within BLAS is a routine called

00:18:52.746 --> 00:18:54.346 A:middle
GEMM, which stands for general

00:18:54.346 --> 00:18:55.446 A:middle
matrix multiplier.

00:18:56.086 --> 00:18:58.156 A:middle
This routine is used to

00:18:58.156 --> 00:18:59.746 A:middle
implement several other blocked

00:18:59.746 --> 00:19:01.866 A:middle
routines in BLAS, which are used

00:18:59.746 --> 00:19:01.866 A:middle
routines in BLAS, which are used

00:19:01.866 --> 00:19:03.536 A:middle
inside the blocked algorithms at

00:19:03.596 --> 00:19:06.106 A:middle
LApack, most notably the matrix

00:19:06.106 --> 00:19:07.556 A:middle
factorization and solver

00:19:07.556 --> 00:19:08.256 A:middle
routines.

00:19:09.516 --> 00:19:11.006 A:middle
Because of this, GEMM is

00:19:11.006 --> 00:19:12.746 A:middle
sometimes used as a proxy for

00:19:12.746 --> 00:19:13.456 A:middle
performance.

00:19:13.456 --> 00:19:15.246 A:middle
For this presentation, we are

00:19:15.246 --> 00:19:16.436 A:middle
specifically going to look at

00:19:16.436 --> 00:19:18.146 A:middle
the single-precision variant of

00:19:18.146 --> 00:19:18.526 A:middle
GEMM.

00:19:20.466 --> 00:19:21.846 A:middle
Here, we're going to compare the

00:19:21.846 --> 00:19:23.516 A:middle
performance of the Eigen library

00:19:23.516 --> 00:19:24.606 A:middle
with that of Accelerate.

00:19:25.436 --> 00:19:26.916 A:middle
Both the Eigen library and the

00:19:26.916 --> 00:19:28.856 A:middle
Accelerate framework will run on

00:19:28.856 --> 00:19:30.456 A:middle
top of an iPhone 10S.

00:19:30.916 --> 00:19:32.006 A:middle
Both will be performing a

00:19:32.006 --> 00:19:33.286 A:middle
single-precision matrix

00:19:33.286 --> 00:19:33.836 A:middle
multiplier.

00:19:34.236 --> 00:19:38.536 A:middle
Let's see how well Eigen does.

00:19:38.536 --> 00:19:40.346 A:middle
Eigen tops out at about 51

00:19:40.346 --> 00:19:41.096 A:middle
gigaflops.

00:19:41.296 --> 00:19:43.086 A:middle
Now, let's see how well

00:19:43.086 --> 00:19:43.916 A:middle
Accelerate does.

00:19:44.476 --> 00:19:47.616 A:middle
We can see that the Accelerate

00:19:47.616 --> 00:19:48.916 A:middle
framework is almost two and a

00:19:48.916 --> 00:19:50.716 A:middle
half times faster than Eigen on

00:19:50.716 --> 00:19:51.606 A:middle
the same platform.

00:19:52.636 --> 00:19:53.996 A:middle
This is because the Accelerate

00:19:53.996 --> 00:19:55.696 A:middle
framework is hand-tuned to the

00:19:55.696 --> 00:19:57.706 A:middle
platform, allowing us to fully

00:19:57.706 --> 00:19:59.146 A:middle
take advantage of what the

00:19:59.146 --> 00:20:01.046 A:middle
platform can offer.

00:19:59.146 --> 00:20:01.046 A:middle
platform can offer.

00:20:01.046 --> 00:20:03.706 A:middle
So, if you're a developer, using

00:20:03.706 --> 00:20:04.876 A:middle
Accelerate in your app will

00:20:04.876 --> 00:20:05.996 A:middle
offer better performance.

00:20:06.486 --> 00:20:08.106 A:middle
This performance translates into

00:20:08.106 --> 00:20:09.676 A:middle
less energy, which means better

00:20:09.676 --> 00:20:11.696 A:middle
battery life and an overall

00:20:11.886 --> 00:20:13.056 A:middle
better experience for your

00:20:13.056 --> 00:20:13.566 A:middle
users.

00:20:15.586 --> 00:20:17.896 A:middle
In summary, Accelerate provides

00:20:17.896 --> 00:20:19.036 A:middle
functions for performing

00:20:19.036 --> 00:20:20.756 A:middle
large-scale mathematical

00:20:20.756 --> 00:20:22.166 A:middle
computations and image

00:20:22.166 --> 00:20:24.136 A:middle
calculations that are fast and

00:20:24.136 --> 00:20:24.966 A:middle
energy efficient.

00:20:25.296 --> 00:20:27.006 A:middle
And now we've added a

00:20:27.006 --> 00:20:29.136 A:middle
Swift-friendly API that makes

00:20:29.136 --> 00:20:30.616 A:middle
Accelerate's libraries super

00:20:30.616 --> 00:20:32.396 A:middle
easy to work with so your users

00:20:32.396 --> 00:20:33.256 A:middle
will benefit from that

00:20:33.256 --> 00:20:34.536 A:middle
performance and energy

00:20:34.536 --> 00:20:35.126 A:middle
efficiency.

00:20:36.516 --> 00:20:37.866 A:middle
Please visit our site where we

00:20:37.866 --> 00:20:39.536 A:middle
have samples, articles, and

00:20:39.536 --> 00:20:41.036 A:middle
extensive reference material

00:20:41.036 --> 00:20:42.496 A:middle
that covers the entire

00:20:42.536 --> 00:20:43.906 A:middle
Accelerate framework.

00:20:44.266 --> 00:20:45.176 A:middle
Thank you very much.
