WEBVTT

00:00:00.516 --> 00:00:05.000 A:middle
[ Music ]

00:00:07.516 --> 00:00:11.500 A:middle
[ Applause ]

00:00:12.786 --> 00:00:13.366 A:middle
&gt;&gt; Hi, everybody.

00:00:14.736 --> 00:00:15.946 A:middle
I'm Ben. And together with my

00:00:15.946 --> 00:00:17.066 A:middle
colleague Doug, we're going to

00:00:17.066 --> 00:00:19.136 A:middle
talk to you about API design in

00:00:19.136 --> 00:00:19.496 A:middle
Swift.

00:00:20.326 --> 00:00:21.786 A:middle
So, with the introduction of

00:00:21.786 --> 00:00:24.136 A:middle
both binary and module stability

00:00:24.536 --> 00:00:26.096 A:middle
we're really excited that for

00:00:26.096 --> 00:00:27.746 A:middle
the first time we can introduce

00:00:28.126 --> 00:00:29.586 A:middle
frameworks that make full use of

00:00:29.586 --> 00:00:31.176 A:middle
Swift to provide rich,

00:00:31.436 --> 00:00:33.406 A:middle
efficient, and easy to use APIs

00:00:33.406 --> 00:00:36.006 A:middle
as part of Apple's SDK.

00:00:36.556 --> 00:00:37.956 A:middle
Now, we've learned a few things

00:00:38.076 --> 00:00:39.566 A:middle
as part of designing these APIs

00:00:39.566 --> 00:00:40.506 A:middle
that we want to talk to you

00:00:40.506 --> 00:00:40.986 A:middle
about today.

00:00:40.986 --> 00:00:43.116 A:middle
So, we're going to cover a

00:00:43.116 --> 00:00:44.746 A:middle
couple of fundamental concepts

00:00:45.606 --> 00:00:47.396 A:middle
and understand how they affect

00:00:47.396 --> 00:00:48.306 A:middle
your API designs.

00:00:48.746 --> 00:00:49.516 A:middle
And then we're going to take a

00:00:49.516 --> 00:00:51.066 A:middle
deep dive into some of the new

00:00:51.066 --> 00:00:53.516 A:middle
features in Swift 5.1 and see

00:00:53.516 --> 00:00:54.996 A:middle
how they can help you make your

00:00:54.996 --> 00:00:56.476 A:middle
APIs more expressive.

00:00:57.406 --> 00:00:58.246 A:middle
Along the way we're going to

00:00:58.246 --> 00:00:59.976 A:middle
show you some examples from some

00:00:59.976 --> 00:01:01.486 A:middle
of our latest Swift frameworks,

00:00:59.976 --> 00:01:01.486 A:middle
of our latest Swift frameworks,

00:01:01.756 --> 00:01:03.796 A:middle
including SwiftUI and

00:01:04.036 --> 00:01:04.686 A:middle
RealityKit.

00:01:06.496 --> 00:01:08.476 A:middle
Now, we talked about API design

00:01:08.476 --> 00:01:08.926 A:middle
before.

00:01:09.116 --> 00:01:11.096 A:middle
In particular, in 2016, when we

00:01:11.096 --> 00:01:13.276 A:middle
introduced the Swift API Design

00:01:13.276 --> 00:01:13.856 A:middle
Guidelines.

00:01:14.546 --> 00:01:15.926 A:middle
And these were available on the

00:01:15.926 --> 00:01:17.106 A:middle
Swift.org website.

00:01:17.466 --> 00:01:18.626 A:middle
And they contain some really

00:01:18.626 --> 00:01:21.076 A:middle
useful advice around how to name

00:01:21.166 --> 00:01:22.046 A:middle
and document your API.

00:01:22.086 --> 00:01:24.256 A:middle
But I'm not going to recap here

00:01:24.786 --> 00:01:26.186 A:middle
except to say that if there's

00:01:26.186 --> 00:01:27.306 A:middle
one message they're trying to

00:01:27.306 --> 00:01:30.466 A:middle
achieve, it's this: Clarity at

00:01:30.466 --> 00:01:32.406 A:middle
the point of use is your most

00:01:32.406 --> 00:01:34.136 A:middle
important goal as an API

00:01:34.196 --> 00:01:34.606 A:middle
designer.

00:01:35.166 --> 00:01:37.096 A:middle
You want to make it so that when

00:01:37.096 --> 00:01:39.116 A:middle
you read code using your API

00:01:39.736 --> 00:01:40.886 A:middle
it's obvious what it's doing.

00:01:41.756 --> 00:01:43.506 A:middle
And you want to make it easy for

00:01:43.626 --> 00:01:45.146 A:middle
your API to be used correctly.

00:01:46.136 --> 00:01:48.696 A:middle
And good naming and readability

00:01:48.696 --> 00:01:50.016 A:middle
is a critical part of this.

00:01:50.756 --> 00:01:53.036 A:middle
And there's one new thing around

00:01:53.036 --> 00:01:53.886 A:middle
naming that we want to talk

00:01:53.886 --> 00:01:55.366 A:middle
about, which is that going

00:01:55.366 --> 00:01:57.146 A:middle
forward, we're not going to be

00:01:57.146 --> 00:01:59.366 A:middle
using prefixes in the Swift

00:01:59.366 --> 00:02:00.986 A:middle
types in our Swift-only APIs.

00:01:59.366 --> 00:02:00.986 A:middle
types in our Swift-only APIs.

00:02:00.986 --> 00:02:04.136 A:middle
Now, this really helps give

00:02:04.266 --> 00:02:06.956 A:middle
these APIs a much cleaner, more

00:02:07.016 --> 00:02:07.766 A:middle
readable feel.

00:02:07.766 --> 00:02:11.756 A:middle
Now, in C and Objective-C, we

00:02:11.756 --> 00:02:13.866 A:middle
had to use prefixes because

00:02:14.026 --> 00:02:15.816 A:middle
every symbol was in the global

00:02:15.816 --> 00:02:17.546 A:middle
name space with no good way to

00:02:17.546 --> 00:02:18.346 A:middle
disambiguate.

00:02:19.376 --> 00:02:20.766 A:middle
And for that reason, both Apple

00:02:21.036 --> 00:02:22.966 A:middle
and developers had to stick to a

00:02:22.966 --> 00:02:24.456 A:middle
really strict prefixing

00:02:24.456 --> 00:02:24.946 A:middle
convention.

00:02:25.736 --> 00:02:27.386 A:middle
And for consistency, we're going

00:02:27.386 --> 00:02:29.406 A:middle
to keep using prefixes on the

00:02:29.406 --> 00:02:31.536 A:middle
Swift versions of APIs that also

00:02:31.536 --> 00:02:32.686 A:middle
have an equivalent in

00:02:32.686 --> 00:02:33.446 A:middle
Objective-C.

00:02:35.516 --> 00:02:37.626 A:middle
But Swift's module system does

00:02:37.626 --> 00:02:40.106 A:middle
allow for disambiguation by

00:02:40.106 --> 00:02:41.556 A:middle
prepending the module name in

00:02:41.556 --> 00:02:42.256 A:middle
front of the type.

00:02:42.256 --> 00:02:44.046 A:middle
And for this reason, the

00:02:44.046 --> 00:02:45.396 A:middle
standard library has never had

00:02:45.396 --> 00:02:46.076 A:middle
prefixes.

00:02:46.356 --> 00:02:47.816 A:middle
And many of you have found that

00:02:47.876 --> 00:02:48.986 A:middle
you could drop them from your

00:02:48.986 --> 00:02:49.926 A:middle
Swift frameworks, too.

00:02:50.496 --> 00:02:53.886 A:middle
And bear in mind that you do

00:02:53.886 --> 00:02:55.326 A:middle
still have to be a little bit

00:02:55.326 --> 00:02:56.986 A:middle
careful even then.

00:02:57.996 --> 00:02:59.966 A:middle
A very general name will cause

00:02:59.966 --> 00:03:01.776 A:middle
your users to have to manually

00:02:59.966 --> 00:03:01.776 A:middle
your users to have to manually

00:03:01.776 --> 00:03:03.336 A:middle
disambiguate in the case of

00:03:03.336 --> 00:03:04.046 A:middle
conflicts.

00:03:04.926 --> 00:03:06.846 A:middle
And always remember clarity at

00:03:06.846 --> 00:03:07.776 A:middle
the point of use.

00:03:08.736 --> 00:03:10.266 A:middle
A general name from a specific

00:03:10.266 --> 00:03:11.856 A:middle
framework can look a little bit

00:03:11.856 --> 00:03:13.496 A:middle
confusing when you see it out of

00:03:13.536 --> 00:03:14.166 A:middle
context.

00:03:14.626 --> 00:03:17.686 A:middle
Now, we're going to talk about a

00:03:17.686 --> 00:03:19.116 A:middle
couple of topics: Values and

00:03:19.116 --> 00:03:20.956 A:middle
references and protocols and

00:03:20.956 --> 00:03:21.476 A:middle
generics.

00:03:21.926 --> 00:03:23.216 A:middle
And then we're going to cover

00:03:23.216 --> 00:03:24.656 A:middle
our two new features, key path

00:03:24.656 --> 00:03:26.626 A:middle
member lookup and property

00:03:26.626 --> 00:03:27.126 A:middle
wrappers.

00:03:28.096 --> 00:03:29.356 A:middle
So let's start by talking a bit

00:03:29.356 --> 00:03:30.896 A:middle
about values and references.

00:03:31.016 --> 00:03:32.416 A:middle
First a very quick recap.

00:03:32.666 --> 00:03:34.616 A:middle
Swift has three basic concepts

00:03:34.616 --> 00:03:36.856 A:middle
for creating a type: Classes,

00:03:37.096 --> 00:03:38.426 A:middle
Structs, and Enums.

00:03:39.776 --> 00:03:41.456 A:middle
Classes are reference types.

00:03:41.456 --> 00:03:42.236 A:middle
And that means when you have a

00:03:42.236 --> 00:03:44.076 A:middle
variable, it just refers to the

00:03:44.076 --> 00:03:45.496 A:middle
object that actually holds the

00:03:45.496 --> 00:03:46.006 A:middle
values.

00:03:46.796 --> 00:03:48.266 A:middle
And when you copy it, you're

00:03:48.266 --> 00:03:50.006 A:middle
just copying that reference.

00:03:50.466 --> 00:03:51.726 A:middle
And that means that when you

00:03:51.726 --> 00:03:53.066 A:middle
change a value through the

00:03:53.066 --> 00:03:55.416 A:middle
reference, you're changing the

00:03:55.416 --> 00:03:57.086 A:middle
same object to which both

00:03:57.086 --> 00:03:57.976 A:middle
variables refer.

00:03:59.436 --> 00:04:00.756 A:middle
And so they both see the change.

00:03:59.436 --> 00:04:00.756 A:middle
And so they both see the change.

00:04:01.296 --> 00:04:04.926 A:middle
Structs and Enums, on the other

00:04:04.926 --> 00:04:06.446 A:middle
hand, are value types.

00:04:06.446 --> 00:04:07.356 A:middle
And when you copy them, they

00:04:07.476 --> 00:04:09.556 A:middle
copy their entire contents.

00:04:09.946 --> 00:04:11.196 A:middle
And that means that when you

00:04:11.196 --> 00:04:12.626 A:middle
make a change, you're just

00:04:12.626 --> 00:04:14.036 A:middle
changing that one copy.

00:04:15.086 --> 00:04:16.866 A:middle
Now, using value types in your

00:04:16.866 --> 00:04:18.416 A:middle
API can bring a lot of benefits

00:04:18.486 --> 00:04:20.055 A:middle
in terms of clarity at the point

00:04:20.055 --> 00:04:20.555 A:middle
of use.

00:04:20.995 --> 00:04:21.846 A:middle
If you know you're getting a

00:04:21.846 --> 00:04:24.166 A:middle
fresh, unique copy every time,

00:04:24.556 --> 00:04:25.746 A:middle
then you don't need to worry

00:04:25.746 --> 00:04:27.206 A:middle
about where the value came from

00:04:27.436 --> 00:04:29.006 A:middle
and whether somebody has a

00:04:29.006 --> 00:04:30.126 A:middle
reference to it still where they

00:04:30.126 --> 00:04:31.246 A:middle
might change it behind your

00:04:31.246 --> 00:04:31.556 A:middle
back.

00:04:32.426 --> 00:04:34.426 A:middle
You don't need, for example, to

00:04:34.426 --> 00:04:36.346 A:middle
make a defensive copy.

00:04:36.346 --> 00:04:37.686 A:middle
Now, given this, a common

00:04:37.686 --> 00:04:38.866 A:middle
question comes up, which is:

00:04:39.066 --> 00:04:40.966 A:middle
Should I be using a reference or

00:04:40.966 --> 00:04:43.336 A:middle
a value type in my particular

00:04:43.336 --> 00:04:43.956 A:middle
piece of code?

00:04:44.276 --> 00:04:45.986 A:middle
And every use case is different.

00:04:45.986 --> 00:04:47.646 A:middle
So there are no hard rules here.

00:04:48.036 --> 00:04:49.006 A:middle
But here's some general

00:04:49.006 --> 00:04:50.686 A:middle
guidance, which is that in

00:04:50.686 --> 00:04:52.856 A:middle
general, you should prefer using

00:04:52.856 --> 00:04:54.716 A:middle
Structs over classes unless you

00:04:54.716 --> 00:04:56.066 A:middle
have a good reason for using a

00:04:56.066 --> 00:04:56.496 A:middle
class.

00:04:57.216 --> 00:04:58.736 A:middle
If you default to using a class

00:04:58.736 --> 00:04:59.996 A:middle
whenever you create a type, try

00:04:59.996 --> 00:05:01.086 A:middle
flipping that default in your

00:04:59.996 --> 00:05:01.086 A:middle
flipping that default in your

00:05:01.086 --> 00:05:02.386 A:middle
code going forward and see how

00:05:02.386 --> 00:05:02.886 A:middle
you get on.

00:05:03.956 --> 00:05:05.496 A:middle
Now, classes still play a

00:05:05.496 --> 00:05:06.896 A:middle
critical role in Swift.

00:05:07.426 --> 00:05:08.956 A:middle
They're essential if you need to

00:05:09.076 --> 00:05:10.786 A:middle
manage resources through

00:05:10.786 --> 00:05:11.656 A:middle
reference counting.

00:05:12.146 --> 00:05:13.316 A:middle
Though often you'll want to wrap

00:05:13.536 --> 00:05:14.976 A:middle
that class inside a struct, as

00:05:14.976 --> 00:05:15.706 A:middle
we'll see shortly.

00:05:16.896 --> 00:05:18.816 A:middle
They're also a useful construct

00:05:18.816 --> 00:05:20.316 A:middle
if something is fundamentally

00:05:20.316 --> 00:05:22.046 A:middle
stored and shared.

00:05:22.836 --> 00:05:24.826 A:middle
And importantly, if your type

00:05:24.826 --> 00:05:26.046 A:middle
has identity.

00:05:26.196 --> 00:05:28.316 A:middle
And that notion of identity is

00:05:28.316 --> 00:05:29.656 A:middle
separate from its value.

00:05:30.386 --> 00:05:32.106 A:middle
That's often a sign that a class

00:05:32.106 --> 00:05:33.566 A:middle
might make sense.

00:05:34.766 --> 00:05:36.796 A:middle
Now, a good place where we had

00:05:36.796 --> 00:05:38.806 A:middle
to make this decision was in

00:05:38.876 --> 00:05:39.646 A:middle
RealityKit.

00:05:40.526 --> 00:05:42.506 A:middle
RealityKit's API revolves around

00:05:42.506 --> 00:05:44.016 A:middle
these things called entities.

00:05:44.636 --> 00:05:46.896 A:middle
And these represent objects that

00:05:46.896 --> 00:05:48.276 A:middle
appear in scenes.

00:05:48.686 --> 00:05:50.656 A:middle
And they are stored centrally

00:05:50.656 --> 00:05:52.156 A:middle
inside RealityKit's engine.

00:05:52.156 --> 00:05:53.356 A:middle
And they have identity.

00:05:54.086 --> 00:05:55.776 A:middle
And when you manipulate a scene

00:05:55.836 --> 00:05:57.956 A:middle
by changing an object's

00:05:57.956 --> 00:06:00.336 A:middle
appearance or moving them

00:05:57.956 --> 00:06:00.336 A:middle
appearance or moving them

00:06:00.336 --> 00:06:01.946 A:middle
around, then you're manipulating

00:06:01.946 --> 00:06:04.126 A:middle
objects directly in that engine.

00:06:04.546 --> 00:06:05.666 A:middle
You can think of the reference

00:06:05.666 --> 00:06:08.706 A:middle
types as like handles into the

00:06:08.706 --> 00:06:10.226 A:middle
actual object stored within

00:06:10.346 --> 00:06:11.076 A:middle
RealityKit.

00:06:11.556 --> 00:06:13.106 A:middle
So this is a perfect use for a

00:06:13.106 --> 00:06:13.846 A:middle
reference type.

00:06:14.536 --> 00:06:17.446 A:middle
But the attributes of those

00:06:17.446 --> 00:06:19.546 A:middle
entities, such as their location

00:06:19.546 --> 00:06:21.676 A:middle
or orientation in a scene, those

00:06:21.676 --> 00:06:23.636 A:middle
are modeled as value types.

00:06:24.396 --> 00:06:25.276 A:middle
Now, let's have a look at how

00:06:25.276 --> 00:06:26.096 A:middle
this looks in code.

00:06:26.896 --> 00:06:28.416 A:middle
So let's say we want to create

00:06:28.776 --> 00:06:30.546 A:middle
this scene here.

00:06:31.146 --> 00:06:33.646 A:middle
So, we would first create a

00:06:33.646 --> 00:06:34.406 A:middle
material type.

00:06:34.916 --> 00:06:36.906 A:middle
And then we'd create two boxes

00:06:36.906 --> 00:06:38.286 A:middle
out of it.

00:06:38.416 --> 00:06:39.576 A:middle
And then we need to anchor them

00:06:39.576 --> 00:06:40.426 A:middle
within the scene.

00:06:41.196 --> 00:06:42.476 A:middle
And then, once we've done this,

00:06:42.576 --> 00:06:43.796 A:middle
we can manipulate the scene

00:06:43.836 --> 00:06:45.896 A:middle
directly using code so we can

00:06:46.086 --> 00:06:47.486 A:middle
move the smaller box up along

00:06:47.486 --> 00:06:48.286 A:middle
the y-axis.

00:06:48.336 --> 00:06:50.926 A:middle
Or rotate the larger box by 45

00:06:50.926 --> 00:06:51.426 A:middle
degrees.

00:06:51.836 --> 00:06:53.096 A:middle
And as we're performing these

00:06:53.096 --> 00:06:54.776 A:middle
operations on these reference

00:06:54.776 --> 00:06:56.096 A:middle
types, we're directly

00:06:56.096 --> 00:06:57.296 A:middle
manipulating the scene.

00:06:57.296 --> 00:06:59.056 A:middle
And this feels fairly intuitive.

00:07:00.376 --> 00:07:02.676 A:middle
Now, supposing then want to do

00:07:02.676 --> 00:07:03.786 A:middle
what we've got here, which is to

00:07:03.786 --> 00:07:04.616 A:middle
make one of the boxes a

00:07:04.616 --> 00:07:05.276 A:middle
different color.

00:07:05.816 --> 00:07:07.006 A:middle
One way we might do that is by

00:07:07.046 --> 00:07:10.526 A:middle
changing the material color to

00:07:10.526 --> 00:07:11.066 A:middle
be red.

00:07:11.886 --> 00:07:14.576 A:middle
Now, what do I expect, as a user

00:07:14.576 --> 00:07:16.056 A:middle
of this API, to happen at this

00:07:16.056 --> 00:07:16.366 A:middle
point?

00:07:17.206 --> 00:07:19.556 A:middle
Should both boxes change because

00:07:19.776 --> 00:07:21.026 A:middle
I've changed the variable they

00:07:21.026 --> 00:07:22.186 A:middle
were both created out of?

00:07:23.066 --> 00:07:24.516 A:middle
Or should only the subsequent

00:07:24.516 --> 00:07:26.706 A:middle
box that I create make use of

00:07:26.706 --> 00:07:27.396 A:middle
this new change?

00:07:27.796 --> 00:07:29.526 A:middle
That is, should material act

00:07:29.836 --> 00:07:32.156 A:middle
like a reference type or a value

00:07:32.156 --> 00:07:32.446 A:middle
type?

00:07:33.216 --> 00:07:35.666 A:middle
And either model would be a

00:07:35.736 --> 00:07:37.166 A:middle
reasonable design for an API.

00:07:37.166 --> 00:07:39.636 A:middle
The benefit of using value types

00:07:39.636 --> 00:07:40.766 A:middle
for this, though, is that if

00:07:40.766 --> 00:07:41.966 A:middle
there's a long distance in your

00:07:42.036 --> 00:07:43.776 A:middle
code between when you first

00:07:43.776 --> 00:07:45.176 A:middle
created and used the material

00:07:45.176 --> 00:07:46.666 A:middle
type and when you change it,

00:07:47.226 --> 00:07:48.536 A:middle
then you might forget that you

00:07:48.536 --> 00:07:49.526 A:middle
had used it previously.

00:07:49.526 --> 00:07:50.976 A:middle
And you might end up changing a

00:07:50.976 --> 00:07:51.816 A:middle
part of the scene that you

00:07:51.816 --> 00:07:52.766 A:middle
didn't expect.

00:07:53.596 --> 00:07:54.726 A:middle
And so for that reason,

00:07:54.726 --> 00:07:56.086 A:middle
RealityKit does choose to make

00:07:56.116 --> 00:07:57.946 A:middle
material a value type.

00:07:58.926 --> 00:08:00.316 A:middle
But reference semantics also

00:07:58.926 --> 00:08:00.316 A:middle
But reference semantics also

00:08:00.316 --> 00:08:01.956 A:middle
make sense for other APIs like

00:08:01.956 --> 00:08:03.246 A:middle
we've seen with entities.

00:08:04.236 --> 00:08:06.666 A:middle
What's important is that your

00:08:06.666 --> 00:08:09.906 A:middle
API has an easy to explain model

00:08:10.066 --> 00:08:12.536 A:middle
for how things behave and why.

00:08:13.246 --> 00:08:16.006 A:middle
And most importantly, how that

00:08:16.006 --> 00:08:17.636 A:middle
behavior works should not be

00:08:17.636 --> 00:08:19.676 A:middle
driven by incidental

00:08:19.676 --> 00:08:21.556 A:middle
implementation details of the

00:08:21.556 --> 00:08:22.056 A:middle
types.

00:08:22.296 --> 00:08:22.896 A:middle
But instead should be a

00:08:22.896 --> 00:08:24.686 A:middle
conscious choice based on the

00:08:24.686 --> 00:08:25.296 A:middle
use cases.

00:08:26.626 --> 00:08:27.736 A:middle
So, what do I mean by an

00:08:27.736 --> 00:08:28.896 A:middle
accidental implementation

00:08:28.896 --> 00:08:29.236 A:middle
detail?

00:08:29.236 --> 00:08:30.966 A:middle
Well, let's have a look at an

00:08:30.966 --> 00:08:32.096 A:middle
example type.

00:08:32.426 --> 00:08:33.765 A:middle
Let's say a material type.

00:08:33.996 --> 00:08:36.836 A:middle
And I want it to act like a

00:08:36.836 --> 00:08:38.296 A:middle
value, so I make it a struct.

00:08:38.506 --> 00:08:39.635 A:middle
And I give it a couple of simple

00:08:39.635 --> 00:08:41.106 A:middle
properties such as roughness.

00:08:41.106 --> 00:08:43.006 A:middle
And then I give it a texture

00:08:43.006 --> 00:08:43.476 A:middle
property.

00:08:43.856 --> 00:08:45.376 A:middle
And let's say that that texture

00:08:45.376 --> 00:08:46.536 A:middle
property needs to manage

00:08:46.536 --> 00:08:48.056 A:middle
resources with reference

00:08:48.056 --> 00:08:48.486 A:middle
counting.

00:08:48.486 --> 00:08:50.816 A:middle
So I decide to make it a class.

00:08:52.106 --> 00:08:53.906 A:middle
Now, we said a moment ago that

00:08:53.906 --> 00:08:55.246 A:middle
when you make a copy of a value

00:08:55.246 --> 00:08:56.936 A:middle
type, you copy all of its stored

00:08:56.936 --> 00:08:57.426 A:middle
properties.

00:08:58.086 --> 00:08:59.196 A:middle
But that when you copy a

00:08:59.196 --> 00:09:00.926 A:middle
reference type, you're just

00:08:59.196 --> 00:09:00.926 A:middle
reference type, you're just

00:09:00.926 --> 00:09:02.376 A:middle
copying that reference.

00:09:03.226 --> 00:09:04.936 A:middle
And so when you make a copy of

00:09:04.936 --> 00:09:06.776 A:middle
this material type, what will

00:09:06.776 --> 00:09:08.296 A:middle
end up happening is that they

00:09:08.296 --> 00:09:09.656 A:middle
make a copy of the reference.

00:09:09.686 --> 00:09:10.996 A:middle
And so the two types end up

00:09:11.226 --> 00:09:13.186 A:middle
sharing the same texture object.

00:09:14.576 --> 00:09:16.096 A:middle
Now, whether that's okay or not

00:09:16.626 --> 00:09:17.356 A:middle
really depends on the

00:09:17.356 --> 00:09:18.726 A:middle
implementation of texture.

00:09:19.106 --> 00:09:21.016 A:middle
If textures are immutable, then

00:09:21.016 --> 00:09:21.966 A:middle
it's perfectly fine.

00:09:21.966 --> 00:09:23.576 A:middle
In fact, it's pretty desirable

00:09:23.576 --> 00:09:24.696 A:middle
from a sharing perspective.

00:09:26.066 --> 00:09:27.326 A:middle
But if texture were

00:09:27.326 --> 00:09:28.996 A:middle
fundamentally a mutable type,

00:09:29.806 --> 00:09:30.876 A:middle
then what I've created here is

00:09:30.876 --> 00:09:32.116 A:middle
actually slightly strange.

00:09:32.116 --> 00:09:33.256 A:middle
It behaves neither like a

00:09:33.256 --> 00:09:35.016 A:middle
reference, nor a value.

00:09:35.426 --> 00:09:37.076 A:middle
I can make changes to properties

00:09:37.236 --> 00:09:37.886 A:middle
on the struct.

00:09:38.936 --> 00:09:40.276 A:middle
And it just affects one of the

00:09:40.276 --> 00:09:40.826 A:middle
variables.

00:09:40.856 --> 00:09:43.086 A:middle
But if I make changes through

00:09:43.086 --> 00:09:46.286 A:middle
the texture reference to the

00:09:46.286 --> 00:09:48.296 A:middle
object, then it affects both

00:09:48.296 --> 00:09:48.846 A:middle
variables.

00:09:49.066 --> 00:09:49.936 A:middle
And this can be really

00:09:49.936 --> 00:09:51.416 A:middle
surprising for users of your

00:09:51.416 --> 00:09:51.736 A:middle
API.

00:09:51.736 --> 00:09:53.336 A:middle
And probably more confusing than

00:09:53.336 --> 00:09:54.296 A:middle
if you had just stuck with

00:09:54.356 --> 00:09:56.006 A:middle
reference semantics all the way

00:09:56.006 --> 00:09:56.356 A:middle
through.

00:09:56.936 --> 00:09:59.466 A:middle
And so here we need to make a

00:09:59.466 --> 00:10:01.896 A:middle
really key distinction between

00:09:59.466 --> 00:10:01.896 A:middle
really key distinction between

00:10:01.896 --> 00:10:03.906 A:middle
value and reference types,

00:10:04.306 --> 00:10:06.856 A:middle
Structs versus classes, and

00:10:06.856 --> 00:10:08.836 A:middle
value and reference semantics,

00:10:09.116 --> 00:10:10.836 A:middle
how the type behaves.

00:10:12.376 --> 00:10:13.916 A:middle
Just because something is a

00:10:13.916 --> 00:10:15.146 A:middle
value type, like a struct,

00:10:15.286 --> 00:10:16.856 A:middle
doesn't necessarily meant that

00:10:16.856 --> 00:10:18.826 A:middle
you automatically get value

00:10:18.826 --> 00:10:20.266 A:middle
behavior from it.

00:10:20.496 --> 00:10:22.006 A:middle
One way that you might not, not

00:10:22.006 --> 00:10:23.386 A:middle
the only way, but a common way,

00:10:23.866 --> 00:10:25.966 A:middle
is if you include a mutable

00:10:26.376 --> 00:10:27.826 A:middle
reference type as part of its

00:10:27.866 --> 00:10:28.616 A:middle
public API.

00:10:28.616 --> 00:10:31.086 A:middle
So the first question if you

00:10:31.086 --> 00:10:32.176 A:middle
wanted something to behave like

00:10:32.176 --> 00:10:33.456 A:middle
a value is: Are any of the

00:10:33.456 --> 00:10:35.486 A:middle
reference it exposes mutable?

00:10:36.686 --> 00:10:38.416 A:middle
And bear in mind, this isn't

00:10:38.416 --> 00:10:39.466 A:middle
always obvious.

00:10:40.056 --> 00:10:41.446 A:middle
If we were dealing with a

00:10:41.446 --> 00:10:43.696 A:middle
non-final class, then what you

00:10:43.696 --> 00:10:46.046 A:middle
might actually have is a mutable

00:10:46.226 --> 00:10:47.036 A:middle
subclass.

00:10:47.436 --> 00:10:49.536 A:middle
Luckily there are lots of

00:10:49.536 --> 00:10:51.436 A:middle
techniques we have to avoid

00:10:51.436 --> 00:10:52.496 A:middle
problems like this.

00:10:53.616 --> 00:10:55.986 A:middle
So the easiest one is to do what

00:10:55.986 --> 00:10:56.946 A:middle
we've always done with reference

00:10:56.946 --> 00:10:58.016 A:middle
types, which is to make a

00:10:58.016 --> 00:10:58.956 A:middle
defensive copy.

00:10:59.316 --> 00:11:00.846 A:middle
So we could switch our texture

00:10:59.316 --> 00:11:00.846 A:middle
So we could switch our texture

00:11:00.846 --> 00:11:02.396 A:middle
stored property to be private.

00:11:03.476 --> 00:11:05.526 A:middle
And then instead have a computed

00:11:05.526 --> 00:11:05.966 A:middle
property.

00:11:06.296 --> 00:11:08.816 A:middle
And inside the setter, we just

00:11:08.816 --> 00:11:10.346 A:middle
make a copy of the texture

00:11:10.346 --> 00:11:10.726 A:middle
object.

00:11:11.286 --> 00:11:12.996 A:middle
And this avoids the mutable

00:11:12.996 --> 00:11:14.226 A:middle
subclass problem.

00:11:15.176 --> 00:11:16.396 A:middle
But, it doesn't solve the

00:11:16.396 --> 00:11:17.566 A:middle
problem if texture is

00:11:17.566 --> 00:11:19.506 A:middle
fundamentally a mutable type

00:11:20.036 --> 00:11:21.366 A:middle
because you could still mutate

00:11:21.366 --> 00:11:22.426 A:middle
it just through the getter

00:11:22.426 --> 00:11:22.916 A:middle
property.

00:11:22.976 --> 00:11:24.166 A:middle
That's how references work.

00:11:25.036 --> 00:11:26.806 A:middle
And so let's consider another

00:11:26.806 --> 00:11:29.886 A:middle
option, which is to not expose

00:11:29.886 --> 00:11:31.436 A:middle
the reference type at all.

00:11:31.766 --> 00:11:34.326 A:middle
And instead, to just expose the

00:11:34.326 --> 00:11:36.346 A:middle
properties we want on the object

00:11:36.866 --> 00:11:38.526 A:middle
as computed properties on our

00:11:38.526 --> 00:11:40.046 A:middle
material value type.

00:11:41.006 --> 00:11:42.676 A:middle
So, we can create a computed

00:11:42.676 --> 00:11:43.156 A:middle
property.

00:11:43.156 --> 00:11:44.496 A:middle
And in the getter, we just

00:11:44.496 --> 00:11:45.916 A:middle
forward on to the relevant

00:11:45.916 --> 00:11:46.846 A:middle
property of the object.

00:11:47.486 --> 00:11:50.196 A:middle
But in the setter, we can first

00:11:50.196 --> 00:11:53.106 A:middle
check if the object is known to

00:11:53.106 --> 00:11:54.226 A:middle
be uniquely referenced.

00:11:54.476 --> 00:11:56.836 A:middle
And if it's not, at that point

00:11:57.006 --> 00:11:59.026 A:middle
we can make a full copy of the

00:11:59.026 --> 00:12:01.226 A:middle
texture object before going on

00:11:59.026 --> 00:12:01.226 A:middle
texture object before going on

00:12:01.226 --> 00:12:02.446 A:middle
and making our mutation.

00:12:03.556 --> 00:12:05.516 A:middle
By adding this one line to check

00:12:05.516 --> 00:12:06.756 A:middle
for uniqueness, we've

00:12:06.756 --> 00:12:09.216 A:middle
implemented full copy-on-write

00:12:09.396 --> 00:12:10.906 A:middle
value semantics while still

00:12:10.906 --> 00:12:12.276 A:middle
exposing the properties we want

00:12:12.566 --> 00:12:14.326 A:middle
on our reference type.

00:12:16.556 --> 00:12:17.996 A:middle
So next, let's talk a bit about

00:12:17.996 --> 00:12:19.546 A:middle
protocols and generics.

00:12:20.276 --> 00:12:21.976 A:middle
So, we've seen how value types

00:12:22.166 --> 00:12:24.676 A:middle
can add clarity at the point of

00:12:24.676 --> 00:12:25.856 A:middle
use to your API.

00:12:26.686 --> 00:12:28.356 A:middle
But, value types aren't new.

00:12:28.356 --> 00:12:30.306 A:middle
We've had types like CGPoint or

00:12:30.376 --> 00:12:32.366 A:middle
CGrect in Objective-C all along.

00:12:33.036 --> 00:12:33.786 A:middle
So what's different?

00:12:33.836 --> 00:12:35.646 A:middle
Well, what's different in Swift

00:12:36.036 --> 00:12:37.236 A:middle
is the ability to apply

00:12:37.436 --> 00:12:39.896 A:middle
protocols to Structs and Enums

00:12:40.506 --> 00:12:41.966 A:middle
as well as just classes.

00:12:42.506 --> 00:12:43.976 A:middle
And that means you can share

00:12:43.976 --> 00:12:45.726 A:middle
code across a variety of types

00:12:46.036 --> 00:12:47.016 A:middle
using generics.

00:12:47.816 --> 00:12:49.376 A:middle
And so if you feel you need to

00:12:49.376 --> 00:12:50.406 A:middle
share some code between

00:12:50.406 --> 00:12:51.586 A:middle
different types, don't feel like

00:12:51.586 --> 00:12:53.576 A:middle
you have to create a class

00:12:53.576 --> 00:12:55.466 A:middle
hierarchy with a base class that

00:12:55.466 --> 00:12:57.106 A:middle
has that shared functionality.

00:12:58.286 --> 00:13:00.756 A:middle
Instead, as the saying goes, in

00:12:58.286 --> 00:13:00.756 A:middle
Instead, as the saying goes, in

00:13:00.756 --> 00:13:02.876 A:middle
Swift, start with a protocol.

00:13:04.176 --> 00:13:06.906 A:middle
But, that doesn't mean that when

00:13:06.906 --> 00:13:08.596 A:middle
you open up XCode and you've got

00:13:08.596 --> 00:13:09.816 A:middle
an empty source file you type

00:13:09.816 --> 00:13:11.036 A:middle
the keyword "protocol" as your

00:13:11.036 --> 00:13:12.356 A:middle
first thing.

00:13:12.986 --> 00:13:14.766 A:middle
In Swift API design, like any

00:13:14.766 --> 00:13:16.606 A:middle
Swift design, first explore the

00:13:16.606 --> 00:13:18.546 A:middle
use case with concrete types.

00:13:18.546 --> 00:13:20.376 A:middle
And understand what code it is

00:13:20.376 --> 00:13:21.466 A:middle
that you want to share when you

00:13:21.466 --> 00:13:23.686 A:middle
find yourself repeating multiple

00:13:23.686 --> 00:13:25.086 A:middle
functions on different types.

00:13:25.706 --> 00:13:27.516 A:middle
And then factor that shared code

00:13:27.516 --> 00:13:29.196 A:middle
out using generics.

00:13:30.106 --> 00:13:32.026 A:middle
Now, that might mean creating

00:13:32.026 --> 00:13:32.906 A:middle
new protocols.

00:13:33.336 --> 00:13:35.616 A:middle
But first, consider composing

00:13:35.616 --> 00:13:37.516 A:middle
what you need out of existing

00:13:37.516 --> 00:13:38.186 A:middle
protocols.

00:13:38.296 --> 00:13:39.096 A:middle
And when you're designing

00:13:39.096 --> 00:13:40.446 A:middle
protocols, make sure that they

00:13:40.446 --> 00:13:41.426 A:middle
are composable.

00:13:42.106 --> 00:13:44.876 A:middle
And as an alternative to

00:13:44.876 --> 00:13:46.866 A:middle
creating a protocol, consider

00:13:47.376 --> 00:13:49.506 A:middle
creating a generic type instead.

00:13:50.456 --> 00:13:51.896 A:middle
So let's have a look at some

00:13:51.896 --> 00:13:53.256 A:middle
examples that show some of these

00:13:53.256 --> 00:13:53.816 A:middle
different things.

00:13:54.466 --> 00:13:56.316 A:middle
So, let's say I wanted to create

00:13:56.316 --> 00:13:57.236 A:middle
a geometry API.

00:13:57.546 --> 00:13:59.206 A:middle
And as part of that, I wanted to

00:13:59.206 --> 00:14:01.516 A:middle
create operations on geometric

00:13:59.206 --> 00:14:01.516 A:middle
create operations on geometric

00:14:01.516 --> 00:14:02.036 A:middle
vectors.

00:14:02.036 --> 00:14:05.186 A:middle
I might start off by creating a

00:14:05.186 --> 00:14:06.706 A:middle
protocol for a geometric vector.

00:14:07.086 --> 00:14:08.096 A:middle
And I could give it the

00:14:08.096 --> 00:14:09.156 A:middle
operations that I want to

00:14:09.156 --> 00:14:11.816 A:middle
define, like dot product or the

00:14:11.816 --> 00:14:13.356 A:middle
distance between two vectors.

00:14:15.726 --> 00:14:17.556 A:middle
Now, I need to store the

00:14:17.556 --> 00:14:18.636 A:middle
dimensions of the vector.

00:14:18.636 --> 00:14:21.176 A:middle
So I might make my geometric

00:14:21.176 --> 00:14:23.656 A:middle
vector refine the SIMD protocol.

00:14:23.956 --> 00:14:25.226 A:middle
If you're not already familiar

00:14:25.226 --> 00:14:26.326 A:middle
with SIMD types, they're

00:14:26.326 --> 00:14:27.466 A:middle
basically like kind of

00:14:27.466 --> 00:14:28.616 A:middle
homogenous tuples that can

00:14:28.616 --> 00:14:30.016 A:middle
very efficiently perform

00:14:30.016 --> 00:14:32.256 A:middle
calculations on every element at

00:14:32.256 --> 00:14:32.816 A:middle
once.

00:14:33.656 --> 00:14:34.836 A:middle
And they've got a lot great new

00:14:34.836 --> 00:14:36.246 A:middle
features in Swift 5.1.

00:14:36.676 --> 00:14:38.186 A:middle
And they're perfect for doing

00:14:38.276 --> 00:14:39.346 A:middle
geometry calculations.

00:14:39.776 --> 00:14:40.696 A:middle
So, we're going to store our

00:14:40.696 --> 00:14:42.166 A:middle
dimensions in that base SIMD

00:14:42.166 --> 00:14:42.656 A:middle
type.

00:14:42.656 --> 00:14:44.086 A:middle
And we'll also want to constrain

00:14:44.086 --> 00:14:46.636 A:middle
it to only work on scalar SIMDs

00:14:46.896 --> 00:14:47.526 A:middle
so that we can do the

00:14:47.526 --> 00:14:49.716 A:middle
calculations we want.

00:14:49.926 --> 00:14:50.896 A:middle
Now, once we've defined this

00:14:50.896 --> 00:14:52.476 A:middle
protocol, we could then go and

00:14:52.476 --> 00:14:53.396 A:middle
implement default

00:14:53.396 --> 00:14:55.066 A:middle
implementations for all of the

00:14:55.066 --> 00:14:56.266 A:middle
operations we want to do on

00:14:56.266 --> 00:14:56.816 A:middle
vectors.

00:14:57.706 --> 00:14:59.796 A:middle
And then we want to give a

00:14:59.796 --> 00:15:02.716 A:middle
conformance to this protocol to

00:14:59.796 --> 00:15:02.716 A:middle
conformance to this protocol to

00:15:02.946 --> 00:15:04.046 A:middle
each of the types that we want

00:15:04.046 --> 00:15:05.616 A:middle
to get these new capabilities.

00:15:06.286 --> 00:15:08.586 A:middle
And this three-step process of

00:15:08.826 --> 00:15:10.666 A:middle
defining the protocol, giving it

00:15:10.666 --> 00:15:12.346 A:middle
a default implementation, and

00:15:12.346 --> 00:15:13.696 A:middle
then adding a conformance to

00:15:13.696 --> 00:15:15.016 A:middle
multiple types, it's actually

00:15:15.056 --> 00:15:15.906 A:middle
kind of tedious.

00:15:16.316 --> 00:15:17.436 A:middle
And it's worth taking a step

00:15:17.436 --> 00:15:18.516 A:middle
back for a second and saying:

00:15:19.076 --> 00:15:20.566 A:middle
Was the protocol really

00:15:20.566 --> 00:15:21.296 A:middle
necessary?

00:15:22.136 --> 00:15:23.756 A:middle
The fact that none of these

00:15:23.756 --> 00:15:25.276 A:middle
conformances actually have their

00:15:25.276 --> 00:15:27.476 A:middle
own custom implementation is

00:15:27.476 --> 00:15:28.986 A:middle
actually kind of a warning sign

00:15:29.086 --> 00:15:30.366 A:middle
that maybe the protocol isn't

00:15:30.366 --> 00:15:30.786 A:middle
useful.

00:15:30.966 --> 00:15:31.946 A:middle
There's no per type

00:15:31.976 --> 00:15:33.186 A:middle
customization going on.

00:15:33.586 --> 00:15:34.916 A:middle
And in fact, this operation

00:15:34.916 --> 00:15:36.456 A:middle
works on every different kind of

00:15:36.456 --> 00:15:37.136 A:middle
SIMD type.

00:15:38.156 --> 00:15:39.906 A:middle
So, is the protocol really

00:15:39.906 --> 00:15:40.696 A:middle
giving us anything?

00:15:42.146 --> 00:15:43.506 A:middle
If we take a step back, and

00:15:43.506 --> 00:15:45.116 A:middle
instead of writing our default

00:15:45.116 --> 00:15:46.116 A:middle
implementation on our new

00:15:46.116 --> 00:15:48.856 A:middle
protocol, we just write it as an

00:15:48.856 --> 00:15:51.296 A:middle
extension directly on the SIMD

00:15:51.296 --> 00:15:52.136 A:middle
protocol with the same

00:15:52.136 --> 00:15:54.316 A:middle
constraints, then we're done.

00:15:54.366 --> 00:15:55.836 A:middle
In this single page of code

00:15:56.056 --> 00:15:57.746 A:middle
we've automatically given all of

00:15:57.746 --> 00:15:59.776 A:middle
the capabilities we need to all

00:15:59.776 --> 00:16:01.086 A:middle
of the SIMD types that contain

00:15:59.776 --> 00:16:01.086 A:middle
of the SIMD types that contain

00:16:01.086 --> 00:16:01.616 A:middle
floats.

00:16:03.406 --> 00:16:04.846 A:middle
It might feel tempting sometimes

00:16:04.846 --> 00:16:06.236 A:middle
to create this elaborate

00:16:06.236 --> 00:16:08.046 A:middle
hierarchy of protocols and to

00:16:08.046 --> 00:16:09.796 A:middle
classify the different types

00:16:09.866 --> 00:16:10.916 A:middle
into this hierarchy.

00:16:11.416 --> 00:16:12.986 A:middle
But this sort of type zoology,

00:16:12.986 --> 00:16:14.536 A:middle
which it feels satisfying, isn't

00:16:14.536 --> 00:16:16.106 A:middle
always necessary.

00:16:17.186 --> 00:16:19.226 A:middle
And there's also a practical

00:16:19.226 --> 00:16:20.076 A:middle
consideration here.

00:16:20.706 --> 00:16:22.646 A:middle
This simpler extension-based

00:16:22.646 --> 00:16:24.246 A:middle
approach without the protocol is

00:16:24.246 --> 00:16:25.886 A:middle
a lot easier for the compiler to

00:16:25.886 --> 00:16:26.566 A:middle
process.

00:16:27.186 --> 00:16:28.276 A:middle
And your binary sites will be

00:16:28.276 --> 00:16:29.486 A:middle
smaller without a bunch of

00:16:29.486 --> 00:16:30.816 A:middle
unnecessary protocol witness

00:16:30.816 --> 00:16:31.436 A:middle
tables in it.

00:16:32.746 --> 00:16:34.056 A:middle
In fact, we've found that on

00:16:34.146 --> 00:16:36.006 A:middle
very large projects, with a

00:16:36.006 --> 00:16:38.186 A:middle
large number of complex protocol

00:16:38.186 --> 00:16:40.686 A:middle
types, we could significantly

00:16:40.686 --> 00:16:42.296 A:middle
improve the compile time of

00:16:42.296 --> 00:16:45.306 A:middle
those applications by taking

00:16:45.306 --> 00:16:46.636 A:middle
this simplification approach and

00:16:46.636 --> 00:16:47.406 A:middle
reducing the number of

00:16:47.406 --> 00:16:48.056 A:middle
protocols.

00:16:50.186 --> 00:16:52.856 A:middle
Now, this extension approach is

00:16:52.856 --> 00:16:54.046 A:middle
good for a small number of

00:16:54.046 --> 00:16:54.576 A:middle
helpers.

00:16:54.946 --> 00:16:56.296 A:middle
But it does hit a scalability

00:16:56.296 --> 00:16:57.596 A:middle
problem when you're designing a

00:16:57.596 --> 00:16:58.416 A:middle
fuller API.

00:16:58.416 --> 00:17:01.516 A:middle
Earlier when we're thinking

00:16:58.416 --> 00:17:01.516 A:middle
Earlier when we're thinking

00:17:01.516 --> 00:17:03.676 A:middle
about creating a protocol, we

00:17:03.676 --> 00:17:05.636 A:middle
said that we'd define geometric

00:17:05.636 --> 00:17:07.836 A:middle
vector and make it refine SIMD,

00:17:08.136 --> 00:17:09.636 A:middle
which we'd use for our storage.

00:17:10.455 --> 00:17:11.846 A:middle
But is that really right?

00:17:11.976 --> 00:17:14.336 A:middle
Is this an Is-a relationship?

00:17:14.336 --> 00:17:16.046 A:middle
Can we really say a geometric

00:17:16.046 --> 00:17:18.415 A:middle
vector "is a" SIMD type?

00:17:18.415 --> 00:17:20.786 A:middle
I mean, some operations make

00:17:20.786 --> 00:17:21.096 A:middle
sense.

00:17:21.096 --> 00:17:22.836 A:middle
You can add and subtract

00:17:22.836 --> 00:17:23.326 A:middle
vectors.

00:17:23.965 --> 00:17:24.776 A:middle
But others don't.

00:17:24.776 --> 00:17:26.546 A:middle
You can't multiply two vectors

00:17:26.546 --> 00:17:27.296 A:middle
by each other.

00:17:27.296 --> 00:17:29.826 A:middle
Or add the number 1 to a vector.

00:17:29.826 --> 00:17:31.886 A:middle
But these operations are

00:17:31.886 --> 00:17:33.736 A:middle
available on all SIMD types.

00:17:33.946 --> 00:17:35.266 A:middle
And have other definitions that

00:17:35.266 --> 00:17:37.276 A:middle
do make sense in other contexts.

00:17:37.276 --> 00:17:38.626 A:middle
Just not in the context of

00:17:38.676 --> 00:17:39.206 A:middle
geometry.

00:17:40.326 --> 00:17:41.986 A:middle
And so if we were designing an

00:17:41.986 --> 00:17:43.856 A:middle
API that would be easy to use,

00:17:44.126 --> 00:17:45.316 A:middle
then we might consider another

00:17:45.316 --> 00:17:46.586 A:middle
option, which is instead of an

00:17:46.586 --> 00:17:48.906 A:middle
Is-a relationship to implement

00:17:48.906 --> 00:17:50.366 A:middle
as a has-a relationship.

00:17:50.856 --> 00:17:53.236 A:middle
That is, to wrap a SIMD value

00:17:53.676 --> 00:17:55.256 A:middle
inside a generic struct.

00:17:55.866 --> 00:17:57.666 A:middle
So we could create instead a

00:17:57.666 --> 00:17:59.506 A:middle
struct of geometric vector.

00:17:59.786 --> 00:18:02.096 A:middle
And we make it generic over our

00:17:59.786 --> 00:18:02.096 A:middle
And we make it generic over our

00:18:02.096 --> 00:18:03.936 A:middle
SIMD storage type so that it can

00:18:03.936 --> 00:18:05.816 A:middle
handle any floating point type

00:18:06.086 --> 00:18:07.226 A:middle
and any different number of

00:18:07.226 --> 00:18:07.736 A:middle
dimensions.

00:18:08.366 --> 00:18:11.166 A:middle
And then once we've done this,

00:18:11.166 --> 00:18:13.086 A:middle
we have much more fine-grained

00:18:13.086 --> 00:18:15.116 A:middle
control over exactly what API we

00:18:15.116 --> 00:18:16.586 A:middle
expose on our new type.

00:18:17.566 --> 00:18:19.956 A:middle
So we can define addition of two

00:18:19.956 --> 00:18:20.926 A:middle
vectors to each other.

00:18:21.296 --> 00:18:23.096 A:middle
But not addition of a single

00:18:23.096 --> 00:18:24.126 A:middle
number to a vector.

00:18:24.416 --> 00:18:26.556 A:middle
Or we can define multiplication

00:18:27.056 --> 00:18:29.156 A:middle
of a vector by a scaling factor,

00:18:29.156 --> 00:18:31.386 A:middle
but not multiplication of two

00:18:31.386 --> 00:18:33.196 A:middle
vectors by each other.

00:18:35.286 --> 00:18:36.946 A:middle
And we can still use generic

00:18:36.946 --> 00:18:37.546 A:middle
extensions.

00:18:37.546 --> 00:18:39.376 A:middle
So our implementations of dot

00:18:39.426 --> 00:18:41.226 A:middle
product and distance remain

00:18:41.226 --> 00:18:42.256 A:middle
pretty much the same as they did

00:18:42.256 --> 00:18:42.676 A:middle
before.

00:18:43.306 --> 00:18:45.876 A:middle
Now, we've actually used this

00:18:45.876 --> 00:18:47.006 A:middle
technique within the standard

00:18:47.006 --> 00:18:47.796 A:middle
library.

00:18:47.796 --> 00:18:49.906 A:middle
For example, we just have one

00:18:49.906 --> 00:18:50.966 A:middle
SIMD protocol.

00:18:51.166 --> 00:18:53.406 A:middle
And then we have Structs that

00:18:53.406 --> 00:18:54.766 A:middle
are generic that represent each

00:18:54.766 --> 00:18:56.716 A:middle
of the different sizes of SIMD

00:18:56.716 --> 00:18:56.996 A:middle
type.

00:18:57.466 --> 00:19:00.676 A:middle
Notice that there's no SIMD2 or

00:18:57.466 --> 00:19:00.676 A:middle
Notice that there's no SIMD2 or

00:19:00.716 --> 00:19:02.016 A:middle
SIMD3 protocol here.

00:19:02.016 --> 00:19:02.966 A:middle
They wouldn't necessarily add

00:19:02.966 --> 00:19:03.616 A:middle
much value.

00:19:04.626 --> 00:19:06.166 A:middle
Users can still write generic

00:19:06.166 --> 00:19:08.216 A:middle
code for a specific size of SIMD

00:19:08.756 --> 00:19:11.136 A:middle
by extending, say, the SIMD3

00:19:11.136 --> 00:19:12.846 A:middle
type with the cross product

00:19:12.846 --> 00:19:14.146 A:middle
operation you would only want to

00:19:14.146 --> 00:19:16.146 A:middle
define on three-dimensional SIMD

00:19:17.046 --> 00:19:17.176 A:middle
types.

00:19:17.856 --> 00:19:19.486 A:middle
So hopefully this gives you a

00:19:19.486 --> 00:19:21.376 A:middle
feel for how generic types can

00:19:21.376 --> 00:19:22.966 A:middle
be just as powerful and

00:19:22.966 --> 00:19:25.096 A:middle
extensible as protocols can be.

00:19:25.906 --> 00:19:27.236 A:middle
Now, we're still using the power

00:19:27.236 --> 00:19:28.006 A:middle
of protocols here.

00:19:28.976 --> 00:19:30.106 A:middle
We have our floating point

00:19:30.106 --> 00:19:31.896 A:middle
protocol constraining the scalar

00:19:31.896 --> 00:19:33.666 A:middle
type on the generic SIMD that

00:19:33.666 --> 00:19:34.776 A:middle
gives us the building blocks

00:19:34.776 --> 00:19:38.726 A:middle
that we need to write this code.

00:19:39.276 --> 00:19:40.796 A:middle
Now, we could write this same

00:19:40.796 --> 00:19:42.656 A:middle
cross product operation on our

00:19:42.656 --> 00:19:43.856 A:middle
geometric vector type.

00:19:44.426 --> 00:19:45.706 A:middle
But when we do, the

00:19:45.706 --> 00:19:47.276 A:middle
implementation looks a little

00:19:47.276 --> 00:19:48.116 A:middle
bit ugly.

00:19:48.606 --> 00:19:49.486 A:middle
Because we keep having to

00:19:49.536 --> 00:19:51.006 A:middle
indirect through the value

00:19:51.006 --> 00:19:52.356 A:middle
storage in order to get at the

00:19:52.356 --> 00:19:54.156 A:middle
x, y, and z coordinates.

00:19:54.496 --> 00:19:56.046 A:middle
And so it would be nice if we

00:19:56.046 --> 00:19:56.806 A:middle
could clean this up.

00:19:57.246 --> 00:19:58.616 A:middle
Now, obviously we could just

00:19:58.616 --> 00:19:59.946 A:middle
write computed properties on our

00:19:59.946 --> 00:20:01.516 A:middle
vector type for x, y, and z.

00:19:59.946 --> 00:20:01.516 A:middle
vector type for x, y, and z.

00:20:01.576 --> 00:20:02.896 A:middle
But there's actually a new

00:20:02.896 --> 00:20:05.846 A:middle
feature in Swift 5.1 called Key

00:20:05.846 --> 00:20:07.876 A:middle
Path Member Lookup that allows

00:20:07.876 --> 00:20:09.696 A:middle
you to write a single subscript

00:20:09.696 --> 00:20:11.446 A:middle
operation that exposes multiple

00:20:11.636 --> 00:20:13.766 A:middle
different computed properties on

00:20:13.766 --> 00:20:15.286 A:middle
a type all in one go.

00:20:15.286 --> 00:20:18.096 A:middle
And so we could use this if we

00:20:18.096 --> 00:20:20.426 A:middle
chose to, if it made sense, to

00:20:20.426 --> 00:20:22.256 A:middle
expose all of the properties on

00:20:22.256 --> 00:20:25.266 A:middle
SIMD on our geometric vector all

00:20:25.266 --> 00:20:25.836 A:middle
in one swoop.

00:20:26.396 --> 00:20:27.366 A:middle
Let's have a look at how we'd do

00:20:27.366 --> 00:20:27.536 A:middle
that.

00:20:28.506 --> 00:20:31.296 A:middle
So first we tag our geometric

00:20:31.296 --> 00:20:32.646 A:middle
vector type with the dynamic

00:20:32.706 --> 00:20:33.886 A:middle
member lookup attribute.

00:20:34.686 --> 00:20:37.936 A:middle
And then next, the compiler will

00:20:37.936 --> 00:20:39.146 A:middle
prompt us to write a special

00:20:39.236 --> 00:20:40.546 A:middle
dynamic member subscript.

00:20:41.136 --> 00:20:44.516 A:middle
And this subscript takes a key

00:20:44.866 --> 00:20:44.966 A:middle
path.

00:20:44.966 --> 00:20:46.206 A:middle
And the effect of implementing

00:20:46.206 --> 00:20:47.746 A:middle
this subscript is that any

00:20:47.806 --> 00:20:49.606 A:middle
property that is accessible via

00:20:49.606 --> 00:20:52.096 A:middle
that key path automatically is

00:20:52.096 --> 00:20:53.826 A:middle
exposed as a computed property

00:20:54.256 --> 00:20:56.436 A:middle
on our geometric vector type.

00:20:56.946 --> 00:20:58.336 A:middle
So in our case, we want to take

00:20:58.386 --> 00:21:00.556 A:middle
a key path into the SIMD storage

00:20:58.386 --> 00:21:00.556 A:middle
a key path into the SIMD storage

00:21:00.556 --> 00:21:02.086 A:middle
type and have it return a

00:21:02.086 --> 00:21:02.496 A:middle
scalar.

00:21:02.956 --> 00:21:04.336 A:middle
And then we just use that key

00:21:04.336 --> 00:21:05.766 A:middle
path to forward on and retrieve

00:21:05.766 --> 00:21:08.076 A:middle
the value from our value storage

00:21:08.076 --> 00:21:08.516 A:middle
and return it.

00:21:08.516 --> 00:21:11.076 A:middle
And once we've done this,

00:21:11.156 --> 00:21:12.946 A:middle
automatically our geometric

00:21:12.946 --> 00:21:13.826 A:middle
vector gets all of the

00:21:13.826 --> 00:21:15.216 A:middle
properties that SIMD has.

00:21:16.036 --> 00:21:17.806 A:middle
So for example, it gets the x,

00:21:17.806 --> 00:21:18.816 A:middle
y, and z coordinates.

00:21:18.996 --> 00:21:20.036 A:middle
And they even appear in

00:21:20.036 --> 00:21:21.646 A:middle
autocompletion in Xcode.

00:21:22.646 --> 00:21:24.386 A:middle
And if you tried this feature in

00:21:24.386 --> 00:21:25.446 A:middle
Swift 5 when it was

00:21:25.446 --> 00:21:27.066 A:middle
string-based, the difference

00:21:27.066 --> 00:21:28.526 A:middle
here is that this version is

00:21:28.526 --> 00:21:29.876 A:middle
completely type safe.

00:21:30.556 --> 00:21:31.586 A:middle
And a lot more of it is done at

00:21:31.586 --> 00:21:34.806 A:middle
compile time.

00:21:35.046 --> 00:21:36.016 A:middle
Now that we have access to the

00:21:36.016 --> 00:21:37.306 A:middle
x, y, and z properties, we can

00:21:37.306 --> 00:21:38.916 A:middle
clean up the implementation of

00:21:39.346 --> 00:21:41.176 A:middle
our cross product operation

00:21:41.486 --> 00:21:41.936 A:middle
quite a bit.

00:21:42.436 --> 00:21:44.466 A:middle
There, that's much nicer.

00:21:44.756 --> 00:21:45.996 A:middle
Now, this dynamic member

00:21:46.296 --> 00:21:48.266 A:middle
capability is not just useful

00:21:48.266 --> 00:21:49.606 A:middle
for forwarding onto properties.

00:21:49.606 --> 00:21:51.626 A:middle
You can also put complex logic

00:21:51.626 --> 00:21:52.436 A:middle
into the subscript.

00:21:52.436 --> 00:21:53.916 A:middle
So, let's look at one more

00:21:53.916 --> 00:21:54.376 A:middle
example.

00:21:54.986 --> 00:21:57.536 A:middle
Let's go back to our example

00:21:57.536 --> 00:21:59.576 A:middle
from earlier where we exposed a

00:21:59.576 --> 00:22:01.296 A:middle
specific property from texture

00:21:59.576 --> 00:22:01.296 A:middle
specific property from texture

00:22:01.636 --> 00:22:03.036 A:middle
with copy on write value

00:22:03.036 --> 00:22:03.616 A:middle
semantics.

00:22:04.146 --> 00:22:05.296 A:middle
Now, this works for one

00:22:05.296 --> 00:22:05.746 A:middle
property.

00:22:05.746 --> 00:22:07.106 A:middle
But it would be unfortunate if

00:22:07.106 --> 00:22:08.646 A:middle
we had to write this same code

00:22:08.646 --> 00:22:09.566 A:middle
every single time.

00:22:10.606 --> 00:22:11.846 A:middle
What if it wanted to expose all

00:22:11.846 --> 00:22:13.726 A:middle
of the properties on texture as

00:22:13.926 --> 00:22:15.476 A:middle
properties on our material type

00:22:15.786 --> 00:22:16.996 A:middle
with copy-on-write semantics?

00:22:16.996 --> 00:22:18.296 A:middle
Well, we can do it with dynamic

00:22:18.296 --> 00:22:18.896 A:middle
member lookup.

00:22:19.766 --> 00:22:21.696 A:middle
So first we add to the dynamic

00:22:21.696 --> 00:22:23.456 A:middle
member attribute to our type.

00:22:24.986 --> 00:22:26.926 A:middle
And then we implement the

00:22:26.926 --> 00:22:27.946 A:middle
subscript operation.

00:22:27.946 --> 00:22:29.496 A:middle
And we're going to make it take

00:22:29.666 --> 00:22:30.926 A:middle
a writable key path because we

00:22:30.926 --> 00:22:32.846 A:middle
want to be able to both get and

00:22:32.846 --> 00:22:33.856 A:middle
set the properties.

00:22:34.816 --> 00:22:35.866 A:middle
And we're going to make it

00:22:36.066 --> 00:22:37.346 A:middle
generic on the return type

00:22:37.616 --> 00:22:38.636 A:middle
because we want to get any

00:22:38.636 --> 00:22:40.366 A:middle
different type out of the

00:22:40.366 --> 00:22:40.806 A:middle
texture.

00:22:41.376 --> 00:22:44.006 A:middle
And then we implement the getter

00:22:44.006 --> 00:22:44.526 A:middle
and setter.

00:22:44.666 --> 00:22:45.896 A:middle
In the getter, we just forward

00:22:45.896 --> 00:22:46.956 A:middle
on like we did before.

00:22:47.576 --> 00:22:49.506 A:middle
But in the setter, before we do

00:22:49.506 --> 00:22:51.696 A:middle
our mutation, we add the unique

00:22:51.696 --> 00:22:53.846 A:middle
referencing check and full copy

00:22:53.846 --> 00:22:54.256 A:middle
of texture.

00:22:55.036 --> 00:22:57.056 A:middle
And by doing this, in one

00:22:57.056 --> 00:22:58.606 A:middle
subscript method that's not too

00:22:58.606 --> 00:23:00.416 A:middle
long, we expose every single

00:22:58.606 --> 00:23:00.416 A:middle
long, we expose every single

00:23:00.416 --> 00:23:02.726 A:middle
property on texture with full

00:23:02.726 --> 00:23:04.606 A:middle
copy-on-write semantics on our

00:23:04.606 --> 00:23:05.416 A:middle
material type.

00:23:06.036 --> 00:23:07.526 A:middle
And this is a really useful way

00:23:07.526 --> 00:23:08.936 A:middle
to get value semantics out of

00:23:08.936 --> 00:23:09.996 A:middle
your types.

00:23:11.916 --> 00:23:14.286 A:middle
This new feature has lots of

00:23:14.286 --> 00:23:15.126 A:middle
different applications.

00:23:15.126 --> 00:23:16.616 A:middle
And it actually composes really

00:23:16.616 --> 00:23:18.856 A:middle
well with a new feature in 5.1

00:23:19.126 --> 00:23:20.436 A:middle
called Property Wrappers that

00:23:20.436 --> 00:23:21.826 A:middle
Doug is going to you about next.

00:23:22.366 --> 00:23:22.586 A:middle
Doug.

00:23:23.516 --> 00:23:30.356 A:middle
[ Applause ]

00:23:30.856 --> 00:23:31.446 A:middle
&gt;&gt; Thank you, Ben.

00:23:32.926 --> 00:23:36.416 A:middle
So, Swift is designed for clear

00:23:36.416 --> 00:23:38.566 A:middle
concise code and to build

00:23:38.566 --> 00:23:40.846 A:middle
expressive APIs, right?

00:23:40.886 --> 00:23:42.066 A:middle
It's also there for code reuse.

00:23:42.066 --> 00:23:42.826 A:middle
We've been talking about

00:23:42.896 --> 00:23:44.956 A:middle
generics and protocols.

00:23:44.956 --> 00:23:46.106 A:middle
And they're there so you can

00:23:46.406 --> 00:23:48.766 A:middle
create generic code, so for your

00:23:48.766 --> 00:23:50.636 A:middle
functions, for your types, that

00:23:50.636 --> 00:23:51.476 A:middle
can be reused.

00:23:51.866 --> 00:23:54.026 A:middle
So property wrappers is a new

00:23:54.026 --> 00:23:55.766 A:middle
feature in Swift 5.1.

00:23:56.486 --> 00:23:58.066 A:middle
And the idea behind property

00:23:58.066 --> 00:23:59.796 A:middle
wrappers is to effectively get

00:23:59.796 --> 00:24:01.566 A:middle
code reuse out of the computed

00:23:59.796 --> 00:24:01.566 A:middle
code reuse out of the computed

00:24:01.566 --> 00:24:02.456 A:middle
properties you write.

00:24:03.456 --> 00:24:05.706 A:middle
Things like this large pile of

00:24:05.746 --> 00:24:06.376 A:middle
code here.

00:24:07.486 --> 00:24:10.266 A:middle
And what is going on here?

00:24:10.266 --> 00:24:12.936 A:middle
So, all we tried to do was

00:24:13.356 --> 00:24:15.526 A:middle
expose a public property, right?

00:24:16.276 --> 00:24:16.946 A:middle
And here we have it.

00:24:16.946 --> 00:24:17.976 A:middle
We just want an image property

00:24:17.976 --> 00:24:18.526 A:middle
that's public.

00:24:18.916 --> 00:24:20.256 A:middle
But we don't want all of our

00:24:20.606 --> 00:24:22.236 A:middle
users, our clients, to be able

00:24:22.236 --> 00:24:23.616 A:middle
to go and write whatever value

00:24:23.616 --> 00:24:23.966 A:middle
in there.

00:24:24.226 --> 00:24:25.676 A:middle
We want to describe some policy.

00:24:25.746 --> 00:24:27.016 A:middle
So it's a computed property.

00:24:27.326 --> 00:24:29.616 A:middle
And our actual storage is back

00:24:29.616 --> 00:24:31.116 A:middle
here in this internal image

00:24:31.116 --> 00:24:32.056 A:middle
storage property.

00:24:32.646 --> 00:24:34.106 A:middle
All the access to that storage

00:24:34.366 --> 00:24:36.416 A:middle
is gated through the getters and

00:24:36.416 --> 00:24:36.926 A:middle
setters.

00:24:37.636 --> 00:24:39.566 A:middle
This is a lot of code.

00:24:39.706 --> 00:24:40.686 A:middle
You've had a few seconds with

00:24:40.686 --> 00:24:40.926 A:middle
it.

00:24:41.396 --> 00:24:42.256 A:middle
Some of you have probably

00:24:42.256 --> 00:24:43.556 A:middle
recognized what this is.

00:24:44.446 --> 00:24:45.966 A:middle
It's a really long-winded way to

00:24:45.966 --> 00:24:48.436 A:middle
say this is just a lazy variable

00:24:48.696 --> 00:24:49.176 A:middle
image.

00:24:50.616 --> 00:24:52.446 A:middle
Now, this is so much better.

00:24:53.696 --> 00:24:55.216 A:middle
It's one line of code instead of

00:24:55.276 --> 00:24:57.316 A:middle
two properties with a mess of

00:24:57.456 --> 00:24:58.816 A:middle
sort of policy logic for

00:24:58.816 --> 00:24:59.436 A:middle
accessing.

00:24:59.936 --> 00:25:02.256 A:middle
And we have this nice modifier

00:24:59.936 --> 00:25:02.256 A:middle
And we have this nice modifier

00:25:02.376 --> 00:25:04.626 A:middle
"lazy" there to tell you here's

00:25:04.626 --> 00:25:06.146 A:middle
what the actual semantics are.

00:25:07.266 --> 00:25:07.996 A:middle
This is important.

00:25:07.996 --> 00:25:08.936 A:middle
It's better documenting.

00:25:08.936 --> 00:25:09.866 A:middle
It's easier to read.

00:25:10.776 --> 00:25:11.826 A:middle
That's why "lazy" has been in

00:25:11.826 --> 00:25:13.376 A:middle
the language since Swift 1.

00:25:14.136 --> 00:25:18.856 A:middle
Now, the problem is, this is one

00:25:19.256 --> 00:25:20.746 A:middle
instance of a more general

00:25:20.786 --> 00:25:21.226 A:middle
problem.

00:25:21.346 --> 00:25:23.306 A:middle
So, let's take a look at another

00:25:23.306 --> 00:25:24.556 A:middle
example here, the code

00:25:24.556 --> 00:25:24.996 A:middle
structure.

00:25:25.716 --> 00:25:26.856 A:middle
Basically identical.

00:25:28.006 --> 00:25:29.746 A:middle
But the policy, what's actually

00:25:29.746 --> 00:25:30.986 A:middle
implemented here in the getter

00:25:30.986 --> 00:25:32.556 A:middle
and setter, is different.

00:25:32.856 --> 00:25:33.956 A:middle
So if you're looking through the

00:25:33.956 --> 00:25:35.646 A:middle
logic here, you see this is sort

00:25:35.646 --> 00:25:37.396 A:middle
of a late initialization

00:25:37.396 --> 00:25:37.836 A:middle
pattern.

00:25:37.836 --> 00:25:39.476 A:middle
You have to set this thing once,

00:25:40.236 --> 00:25:41.956 A:middle
or initialize it once before you

00:25:41.956 --> 00:25:42.436 A:middle
can read it.

00:25:42.436 --> 00:25:43.456 A:middle
Otherwise you get a failure.

00:25:43.456 --> 00:25:45.006 A:middle
This is a fairly common thing.

00:25:46.206 --> 00:25:47.196 A:middle
This kind of code shows up in a

00:25:47.196 --> 00:25:47.916 A:middle
lot of places.

00:25:48.456 --> 00:25:50.816 A:middle
We couldn't go and extend Swift

00:25:50.816 --> 00:25:52.676 A:middle
with another language feature

00:25:53.226 --> 00:25:55.296 A:middle
that attacks this one problem.

00:25:56.266 --> 00:25:57.326 A:middle
But really, we want to solve

00:25:57.326 --> 00:25:58.476 A:middle
this more generally, because we

00:25:58.476 --> 00:25:59.606 A:middle
want people to be able to build

00:25:59.606 --> 00:26:00.906 A:middle
libraries of these things, where

00:25:59.606 --> 00:26:00.906 A:middle
libraries of these things, where

00:26:00.906 --> 00:26:02.026 A:middle
they have the notion of

00:26:02.026 --> 00:26:03.476 A:middle
separating the policy for

00:26:03.476 --> 00:26:05.356 A:middle
accessing a value out.

00:26:05.986 --> 00:26:07.716 A:middle
And so this is the idea behind

00:26:07.716 --> 00:26:09.076 A:middle
property wrappers, to eliminate

00:26:09.076 --> 00:26:10.936 A:middle
this boilerplate and get more

00:26:10.936 --> 00:26:12.356 A:middle
expressive APIs.

00:26:13.556 --> 00:26:14.656 A:middle
So, they look a little like

00:26:14.656 --> 00:26:15.006 A:middle
this.

00:26:15.716 --> 00:26:17.706 A:middle
And the idea here is we want to

00:26:17.706 --> 00:26:19.296 A:middle
capture the notion of you're

00:26:19.296 --> 00:26:20.206 A:middle
declaring a property.

00:26:20.206 --> 00:26:22.236 A:middle
So here it is this public text

00:26:22.236 --> 00:26:26.316 A:middle
variable, and applying the late

00:26:26.316 --> 00:26:28.136 A:middle
initialized property wrapper to

00:26:28.136 --> 00:26:29.876 A:middle
give it a particular set of

00:26:29.876 --> 00:26:30.936 A:middle
semantics, to give it a

00:26:30.936 --> 00:26:32.176 A:middle
particular policy.

00:26:33.696 --> 00:26:35.266 A:middle
Now, this at-LateInitialized,

00:26:35.266 --> 00:26:36.686 A:middle
this is a custom attribute.

00:26:36.686 --> 00:26:37.906 A:middle
It's a new notion that we're

00:26:37.906 --> 00:26:38.986 A:middle
using a bit in Swift.

00:26:39.406 --> 00:26:41.496 A:middle
And essentially, it's saying:

00:26:41.686 --> 00:26:42.836 A:middle
Apply this late initialized

00:26:42.836 --> 00:26:43.686 A:middle
pattern, whatever it is.

00:26:43.686 --> 00:26:44.406 A:middle
We'll get back to that in a

00:26:44.406 --> 00:26:44.876 A:middle
moment.

00:26:45.516 --> 00:26:47.316 A:middle
But just from the code

00:26:47.316 --> 00:26:49.116 A:middle
perspective, this is a whole lot

00:26:49.116 --> 00:26:49.726 A:middle
like lazy.

00:26:49.726 --> 00:26:51.046 A:middle
And it's giving us all the same

00:26:51.106 --> 00:26:52.166 A:middle
benefits as lazy.

00:26:52.736 --> 00:26:53.786 A:middle
We've gotten rid of all that

00:26:53.866 --> 00:26:54.506 A:middle
boilerplate.

00:26:55.516 --> 00:26:57.796 A:middle
But also we've documented at the

00:26:57.886 --> 00:26:58.866 A:middle
point where we declare this

00:26:58.866 --> 00:26:59.916 A:middle
thing, what are the actual

00:26:59.916 --> 00:27:00.426 A:middle
semantics.

00:26:59.916 --> 00:27:00.426 A:middle
semantics.

00:27:00.426 --> 00:27:01.996 A:middle
This is far easier to read and

00:27:01.996 --> 00:27:04.126 A:middle
reason about than that mess of

00:27:04.126 --> 00:27:04.406 A:middle
code.

00:27:05.386 --> 00:27:05.986 A:middle
All right.

00:27:06.506 --> 00:27:07.626 A:middle
Enough talking about this one

00:27:07.626 --> 00:27:08.466 A:middle
little line of code.

00:27:08.636 --> 00:27:09.916 A:middle
Let's see what LateInitialized

00:27:09.916 --> 00:27:10.866 A:middle
actually looks like.

00:27:11.776 --> 00:27:13.206 A:middle
And what you'll see here it's a

00:27:13.206 --> 00:27:13.816 A:middle
bit of code.

00:27:13.816 --> 00:27:15.386 A:middle
But it's the same code we just

00:27:15.446 --> 00:27:15.976 A:middle
saw.

00:27:15.976 --> 00:27:17.936 A:middle
It's the same policy pattern

00:27:18.276 --> 00:27:20.076 A:middle
behind late initialization.

00:27:21.136 --> 00:27:22.466 A:middle
You've got the getter and setter

00:27:22.466 --> 00:27:22.776 A:middle
here.

00:27:22.956 --> 00:27:24.306 A:middle
The set is just updating the

00:27:24.306 --> 00:27:24.846 A:middle
storage.

00:27:24.876 --> 00:27:25.876 A:middle
The getter is checking to make

00:27:25.876 --> 00:27:27.376 A:middle
sure we've set it at least once,

00:27:27.376 --> 00:27:28.276 A:middle
and then returning the value

00:27:28.276 --> 00:27:28.916 A:middle
when we have.

00:27:29.716 --> 00:27:30.416 A:middle
Fairly direct.

00:27:31.176 --> 00:27:33.476 A:middle
Now, what makes this simple

00:27:33.476 --> 00:27:35.716 A:middle
generic type interesting is that

00:27:35.756 --> 00:27:37.216 A:middle
it is a property wrapper.

00:27:37.686 --> 00:27:39.196 A:middle
It's indicated as such by the

00:27:39.306 --> 00:27:40.786 A:middle
property wrapper attribute here

00:27:40.786 --> 00:27:41.256 A:middle
at the top.

00:27:42.376 --> 00:27:43.606 A:middle
Now, what that's doing is it's

00:27:43.606 --> 00:27:45.396 A:middle
enabling the custom attribute

00:27:45.396 --> 00:27:47.086 A:middle
syntax to say we can apply this

00:27:47.086 --> 00:27:49.086 A:middle
thing to some other property.

00:27:49.936 --> 00:27:50.986 A:middle
Now, with the property wrapper

00:27:50.986 --> 00:27:52.356 A:middle
attribute come a couple of

00:27:52.356 --> 00:27:52.936 A:middle
requirements.

00:27:53.096 --> 00:27:55.036 A:middle
The main one is to have this

00:27:55.286 --> 00:27:56.406 A:middle
value property.

00:27:57.056 --> 00:27:58.776 A:middle
This is where all the policy is

00:27:58.776 --> 00:27:59.336 A:middle
implemented.

00:27:59.386 --> 00:28:01.146 A:middle
So all accesses to a late

00:27:59.386 --> 00:28:01.146 A:middle
So all accesses to a late

00:28:01.146 --> 00:28:02.436 A:middle
initialized property go through

00:28:02.436 --> 00:28:02.686 A:middle
here.

00:28:03.876 --> 00:28:05.386 A:middle
And we can see that the actual

00:28:05.386 --> 00:28:06.836 A:middle
notation is finding some

00:28:06.836 --> 00:28:08.356 A:middle
extracted notion of what late

00:28:08.356 --> 00:28:09.416 A:middle
initialized is.

00:28:10.156 --> 00:28:11.166 A:middle
The other interesting thing in

00:28:11.166 --> 00:28:12.756 A:middle
this particular example is that

00:28:12.756 --> 00:28:14.706 A:middle
we've declared an initializer

00:28:14.706 --> 00:28:15.956 A:middle
that takes no parameters.

00:28:17.716 --> 00:28:19.016 A:middle
Now, this is optional with the

00:28:19.016 --> 00:28:19.756 A:middle
property wrapper.

00:28:19.906 --> 00:28:21.506 A:middle
But when you have it there, what

00:28:21.506 --> 00:28:22.756 A:middle
it's saying is that properties

00:28:22.756 --> 00:28:24.516 A:middle
that are applying this wrapper

00:28:25.036 --> 00:28:26.806 A:middle
get implicit initialization for

00:28:26.806 --> 00:28:28.056 A:middle
free going through this

00:28:28.056 --> 00:28:29.136 A:middle
particular initializer.

00:28:32.076 --> 00:28:32.166 A:middle
&gt;&gt; Okay.

00:28:33.986 --> 00:28:35.116 A:middle
Let's actually use this thing.

00:28:35.426 --> 00:28:37.006 A:middle
So, when you use a property

00:28:37.006 --> 00:28:38.176 A:middle
wrapper by applying it to a

00:28:38.176 --> 00:28:39.886 A:middle
particular property, the

00:28:39.886 --> 00:28:41.546 A:middle
compiler is going to translate

00:28:41.546 --> 00:28:44.466 A:middle
that code into two separate

00:28:44.466 --> 00:28:44.856 A:middle
properties.

00:28:44.856 --> 00:28:46.876 A:middle
We're essentially expanding out

00:28:46.876 --> 00:28:48.076 A:middle
into that pattern we saw in the

00:28:48.076 --> 00:28:48.716 A:middle
beginning here.

00:28:49.426 --> 00:28:51.416 A:middle
So you have the backing storage

00:28:51.416 --> 00:28:53.346 A:middle
property with this $ prefix.

00:28:53.346 --> 00:28:55.826 A:middle
So $text. And the type of this

00:28:56.116 --> 00:28:57.776 A:middle
is an instance of the property

00:28:57.776 --> 00:28:58.396 A:middle
wrapper type.

00:28:58.456 --> 00:28:59.276 A:middle
So now we have a late

00:28:59.276 --> 00:29:00.806 A:middle
initialized string.

00:28:59.276 --> 00:29:00.806 A:middle
initialized string.

00:29:01.826 --> 00:29:03.246 A:middle
That's providing the storage.

00:29:04.616 --> 00:29:05.976 A:middle
It's going to be initialized

00:29:06.256 --> 00:29:08.236 A:middle
implicitly by the compiler by

00:29:08.236 --> 00:29:09.646 A:middle
calling that no parameter

00:29:09.646 --> 00:29:10.956 A:middle
initializer that we just talked

00:29:10.956 --> 00:29:11.256 A:middle
about.

00:29:11.586 --> 00:29:12.836 A:middle
Because it's there, now we get

00:29:12.836 --> 00:29:13.996 A:middle
implicit initialization.

00:29:14.546 --> 00:29:15.776 A:middle
And late initialize is free to

00:29:15.776 --> 00:29:16.586 A:middle
do whatever it wants.

00:29:16.866 --> 00:29:18.706 A:middle
As you might recall, it set the

00:29:18.706 --> 00:29:19.666 A:middle
storage to nil.

00:29:21.136 --> 00:29:21.966 A:middle
The other thing that the

00:29:21.966 --> 00:29:23.596 A:middle
compiler is doing here is it's

00:29:23.596 --> 00:29:26.076 A:middle
translating text into a computed

00:29:26.076 --> 00:29:26.526 A:middle
property.

00:29:27.286 --> 00:29:28.706 A:middle
And so the getter it's going to

00:29:28.706 --> 00:29:31.066 A:middle
create is accessing $text.

00:29:31.506 --> 00:29:33.776 A:middle
And then retrieving the value

00:29:33.776 --> 00:29:36.056 A:middle
out of $text by calling the

00:29:36.056 --> 00:29:36.926 A:middle
getter for value.

00:29:36.976 --> 00:29:39.346 A:middle
And we do the same thing for the

00:29:39.346 --> 00:29:41.016 A:middle
setter, writing the new value

00:29:41.236 --> 00:29:42.686 A:middle
into $text.value.

00:29:43.026 --> 00:29:44.756 A:middle
And so this is what allows your

00:29:44.756 --> 00:29:46.356 A:middle
property wrapper type to have

00:29:46.356 --> 00:29:47.496 A:middle
its own storage, however it

00:29:47.496 --> 00:29:48.296 A:middle
wants to store it, either

00:29:48.296 --> 00:29:49.416 A:middle
locally or somewhere else.

00:29:49.986 --> 00:29:52.796 A:middle
And then enforce whatever policy

00:29:52.796 --> 00:29:54.886 A:middle
you should have about accessing

00:29:54.886 --> 00:29:56.566 A:middle
that data through the getter and

00:29:56.566 --> 00:29:57.386 A:middle
setter value.

00:29:58.756 --> 00:30:00.656 A:middle
So overall, this is really nice.

00:29:58.756 --> 00:30:00.656 A:middle
So overall, this is really nice.

00:30:00.656 --> 00:30:02.576 A:middle
We've teased apart the policy,

00:30:02.736 --> 00:30:04.236 A:middle
put it in one place in the late

00:30:04.236 --> 00:30:06.316 A:middle
initialized wrapper from the

00:30:06.316 --> 00:30:07.736 A:middle
application of that policy,

00:30:07.966 --> 00:30:10.156 A:middle
which we can do on any number of

00:30:10.156 --> 00:30:11.466 A:middle
different properties of whatever

00:30:11.466 --> 00:30:14.006 A:middle
types we want, making it far

00:30:14.006 --> 00:30:14.986 A:middle
simpler and having less

00:30:14.986 --> 00:30:15.506 A:middle
boilerplate.

00:30:17.196 --> 00:30:18.896 A:middle
So, let's take a look at another

00:30:18.896 --> 00:30:19.316 A:middle
example.

00:30:20.236 --> 00:30:21.546 A:middle
Ben was talking a bit about

00:30:21.546 --> 00:30:23.276 A:middle
value and reference semantics.

00:30:23.866 --> 00:30:24.606 A:middle
Now, when you're dealing with

00:30:24.606 --> 00:30:26.196 A:middle
reference semantics and mutable

00:30:26.196 --> 00:30:27.516 A:middle
state, you're going to find

00:30:27.516 --> 00:30:28.866 A:middle
yourself doing defensive copying

00:30:28.866 --> 00:30:29.436 A:middle
at some point.

00:30:30.046 --> 00:30:31.486 A:middle
Of course, we could manually do

00:30:31.486 --> 00:30:32.866 A:middle
that wherever we need it.

00:30:32.866 --> 00:30:34.086 A:middle
But why not go and build a

00:30:34.086 --> 00:30:35.036 A:middle
property wrapper for it?

00:30:35.506 --> 00:30:38.506 A:middle
So, here the property wrapper,

00:30:38.506 --> 00:30:40.146 A:middle
the shape of it, is basically

00:30:40.146 --> 00:30:41.526 A:middle
the same as we've seen before.

00:30:41.526 --> 00:30:42.546 A:middle
It had some kind of storage.

00:30:42.546 --> 00:30:43.786 A:middle
And it has a value property.

00:30:44.306 --> 00:30:45.636 A:middle
All of the policy for this

00:30:45.676 --> 00:30:47.906 A:middle
property wrapper is here in the

00:30:47.906 --> 00:30:48.276 A:middle
setter.

00:30:48.536 --> 00:30:49.766 A:middle
When we get a new value, go

00:30:49.766 --> 00:30:50.836 A:middle
ahead and copy the value.

00:30:51.216 --> 00:30:52.876 A:middle
And since we're using NSCopying

00:30:52.876 --> 00:30:54.906 A:middle
to do our copies, it just goes

00:30:54.906 --> 00:30:56.436 A:middle
ahead and calls that copy method

00:30:56.436 --> 00:30:57.166 A:middle
and does the cast.

00:30:58.516 --> 00:30:59.736 A:middle
The other interesting thing with

00:30:59.736 --> 00:31:02.246 A:middle
defensive copying is it provides

00:30:59.736 --> 00:31:02.246 A:middle
defensive copying is it provides

00:31:02.246 --> 00:31:04.196 A:middle
an initial value initializer.

00:31:04.816 --> 00:31:06.086 A:middle
This is like that no-parameter

00:31:06.086 --> 00:31:06.746 A:middle
initializer.

00:31:06.746 --> 00:31:08.086 A:middle
You don't have to have it in

00:31:08.086 --> 00:31:08.996 A:middle
your property wrapper.

00:31:09.436 --> 00:31:11.546 A:middle
But when it's there, it lets you

00:31:11.546 --> 00:31:13.976 A:middle
provide a default value on any

00:31:13.976 --> 00:31:15.076 A:middle
property that's wrapped with

00:31:15.076 --> 00:31:15.926 A:middle
this property wrapper.

00:31:16.336 --> 00:31:18.026 A:middle
That default gets fed into this

00:31:18.026 --> 00:31:18.776 A:middle
initializer.

00:31:19.106 --> 00:31:20.406 A:middle
And we can enforce whatever

00:31:20.406 --> 00:31:21.376 A:middle
policy we want on

00:31:21.376 --> 00:31:22.206 A:middle
initialization.

00:31:22.826 --> 00:31:24.116 A:middle
In our case, it's the same as

00:31:24.116 --> 00:31:25.076 A:middle
the set policy.

00:31:25.356 --> 00:31:27.766 A:middle
We want to go ahead and create a

00:31:27.766 --> 00:31:30.926 A:middle
copy defensively and assign that

00:31:33.296 --> 00:31:34.376 A:middle
a result then.

00:31:35.206 --> 00:31:35.946 A:middle
Let's take a look.

00:31:36.436 --> 00:31:38.636 A:middle
So, if we go define some

00:31:38.636 --> 00:31:40.116 A:middle
defensive copying UIBezierPath.

00:31:40.956 --> 00:31:41.716 A:middle
What's going to happen?

00:31:41.716 --> 00:31:43.036 A:middle
Well, the compiler is going to

00:31:43.306 --> 00:31:44.956 A:middle
translate this into the two

00:31:44.956 --> 00:31:45.896 A:middle
different definitions.

00:31:46.256 --> 00:31:46.976 A:middle
We're going to have an

00:31:46.976 --> 00:31:48.756 A:middle
initializer here first.

00:31:49.386 --> 00:31:51.256 A:middle
So here, whenever we create this

00:31:51.256 --> 00:31:53.006 A:middle
path, it has a default of the

00:31:53.006 --> 00:31:54.366 A:middle
UIBezierPath.

00:31:54.886 --> 00:31:56.056 A:middle
Just an empty instance that's

00:31:56.086 --> 00:31:56.536 A:middle
created.

00:31:56.956 --> 00:31:58.366 A:middle
And then when we go ahead and

00:31:58.366 --> 00:32:00.056 A:middle
explode this out into multiple

00:31:58.366 --> 00:32:00.056 A:middle
explode this out into multiple

00:32:00.056 --> 00:32:01.826 A:middle
properties, there's the backing

00:32:01.826 --> 00:32:03.186 A:middle
stored property, $path.

00:32:03.856 --> 00:32:04.646 A:middle
And notice how we're

00:32:04.646 --> 00:32:05.326 A:middle
initializing it.

00:32:05.406 --> 00:32:06.936 A:middle
We're feeding the initial value

00:32:06.936 --> 00:32:09.026 A:middle
that the user gave into the

00:32:09.026 --> 00:32:11.576 A:middle
initial value initializer so it

00:32:11.576 --> 00:32:12.756 A:middle
can be defensively copied.

00:32:13.566 --> 00:32:14.556 A:middle
The getter and setter look

00:32:14.556 --> 00:32:15.376 A:middle
exactly the same.

00:32:15.376 --> 00:32:16.376 A:middle
We're just going through

00:32:16.376 --> 00:32:18.466 A:middle
$path.value for both get and

00:32:18.466 --> 00:32:18.686 A:middle
set.

00:32:19.836 --> 00:32:21.666 A:middle
Now, this is of course the right

00:32:21.666 --> 00:32:22.616 A:middle
semantics by default.

00:32:22.616 --> 00:32:24.106 A:middle
Defensive copying should go

00:32:24.106 --> 00:32:24.846 A:middle
ahead and copy.

00:32:25.486 --> 00:32:26.786 A:middle
In this case, well we know

00:32:26.786 --> 00:32:27.936 A:middle
something about our default

00:32:27.936 --> 00:32:28.356 A:middle
value.

00:32:28.516 --> 00:32:29.546 A:middle
It's creating a new object.

00:32:29.716 --> 00:32:30.846 A:middle
Why would we go and copy that

00:32:30.876 --> 00:32:31.086 A:middle
thing?

00:32:31.486 --> 00:32:33.606 A:middle
So, let's optimize this a little

00:32:33.606 --> 00:32:34.766 A:middle
bit just because we can.

00:32:35.796 --> 00:32:36.766 A:middle
So we can extend defensive

00:32:36.796 --> 00:32:37.286 A:middle
copying.

00:32:37.326 --> 00:32:37.956 A:middle
It's just a type.

00:32:38.046 --> 00:32:39.066 A:middle
There's nothing magical about

00:32:39.066 --> 00:32:39.966 A:middle
this type other than the fact

00:32:39.966 --> 00:32:40.906 A:middle
that it's behaving like a

00:32:40.906 --> 00:32:42.226 A:middle
property wrapper when used that

00:32:42.226 --> 00:32:42.466 A:middle
way.

00:32:42.946 --> 00:32:44.176 A:middle
And so we can give it this

00:32:44.246 --> 00:32:45.686 A:middle
withoutCopying initializer.

00:32:46.286 --> 00:32:49.516 A:middle
When we want to use that, we can

00:32:49.516 --> 00:32:50.936 A:middle
go ahead and write an

00:32:50.936 --> 00:32:52.246 A:middle
initializer for our type.

00:32:53.256 --> 00:32:54.796 A:middle
And what we're doing here is

00:32:54.796 --> 00:32:57.666 A:middle
we're assigning to $path to call

00:32:57.666 --> 00:32:59.586 A:middle
the defensive withoutCopying

00:32:59.586 --> 00:33:01.416 A:middle
initializer so we can avoid that

00:32:59.586 --> 00:33:01.416 A:middle
initializer so we can avoid that

00:33:01.416 --> 00:33:02.056 A:middle
extra copy.

00:33:03.146 --> 00:33:04.256 A:middle
So there's really nothing more

00:33:04.256 --> 00:33:06.076 A:middle
magic that's going on here.

00:33:06.266 --> 00:33:08.206 A:middle
$path is just a stored property.

00:33:08.256 --> 00:33:09.516 A:middle
It's only magical in the sense

00:33:09.516 --> 00:33:11.136 A:middle
that the compiler generated it

00:33:11.246 --> 00:33:13.586 A:middle
for you as part of applying this

00:33:13.586 --> 00:33:14.896 A:middle
property wrapper pattern.

00:33:15.456 --> 00:33:16.766 A:middle
But you can go and treat it like

00:33:16.766 --> 00:33:18.766 A:middle
a normal variable whenever you

00:33:18.766 --> 00:33:20.436 A:middle
want, including setting up your

00:33:20.436 --> 00:33:21.256 A:middle
own initialization.

00:33:21.866 --> 00:33:24.056 A:middle
Now, this is a little bit

00:33:24.256 --> 00:33:25.396 A:middle
boilerplatey, still.

00:33:25.396 --> 00:33:26.476 A:middle
It's unfortunate that we had to

00:33:26.476 --> 00:33:27.446 A:middle
write that initializer.

00:33:27.516 --> 00:33:28.256 A:middle
So there's one other

00:33:28.256 --> 00:33:29.356 A:middle
initialization form that you

00:33:29.356 --> 00:33:29.816 A:middle
might see.

00:33:30.546 --> 00:33:32.786 A:middle
And that is that when you are

00:33:32.786 --> 00:33:34.126 A:middle
declaring the customer

00:33:34.156 --> 00:33:34.926 A:middle
attribute, so

00:33:34.926 --> 00:33:36.446 A:middle
at-DefensiveCopying, you can

00:33:36.446 --> 00:33:37.826 A:middle
actually initialize right there

00:33:37.826 --> 00:33:39.056 A:middle
in the properties declaration

00:33:39.206 --> 00:33:40.266 A:middle
with whatever you want.

00:33:40.686 --> 00:33:42.636 A:middle
So here we can go and call the

00:33:42.636 --> 00:33:44.186 A:middle
withoutCopying initializer to

00:33:44.186 --> 00:33:45.446 A:middle
initialize the backing storage

00:33:45.446 --> 00:33:47.296 A:middle
property with exactly what we

00:33:47.296 --> 00:33:47.606 A:middle
want.

00:33:47.966 --> 00:33:48.806 A:middle
It's one nice little

00:33:48.806 --> 00:33:49.536 A:middle
declaration.

00:33:49.936 --> 00:33:51.236 A:middle
And you get the benefits of

00:33:51.236 --> 00:33:52.386 A:middle
getting the default in the

00:33:52.386 --> 00:33:54.076 A:middle
memorize initializers for free,

00:33:54.076 --> 00:33:54.326 A:middle
still.

00:33:56.436 --> 00:33:57.016 A:middle
All right.

00:33:58.046 --> 00:34:00.016 A:middle
So, property wrappers are

00:33:58.046 --> 00:34:00.016 A:middle
So, property wrappers are

00:34:00.016 --> 00:34:01.576 A:middle
actually fairly powerful.

00:34:01.836 --> 00:34:03.756 A:middle
They abstract away this notion

00:34:03.756 --> 00:34:06.326 A:middle
of policy to access your data.

00:34:06.536 --> 00:34:07.886 A:middle
So you can decide how your data

00:34:07.886 --> 00:34:08.416 A:middle
is stored.

00:34:08.656 --> 00:34:09.886 A:middle
And you can decide how your data

00:34:09.886 --> 00:34:10.626 A:middle
is accessed.

00:34:11.106 --> 00:34:12.766 A:middle
And all your users need to do

00:34:12.766 --> 00:34:14.016 A:middle
with your property wrapper is

00:34:14.156 --> 00:34:15.846 A:middle
use that custom attribute syntax

00:34:16.266 --> 00:34:17.366 A:middle
to tie into your system.

00:34:17.616 --> 00:34:19.616 A:middle
So as we've been developing

00:34:19.616 --> 00:34:20.906 A:middle
property wrappers, we've found a

00:34:20.906 --> 00:34:22.755 A:middle
lot of different uses for them

00:34:23.335 --> 00:34:24.716 A:middle
all around this sort of general

00:34:24.716 --> 00:34:26.496 A:middle
notion of data access.

00:34:27.246 --> 00:34:28.525 A:middle
So for example, you may have

00:34:28.525 --> 00:34:29.886 A:middle
seen the user defaults example.

00:34:30.306 --> 00:34:31.525 A:middle
And here's where we're setting

00:34:31.525 --> 00:34:32.626 A:middle
up a relationship between a

00:34:32.626 --> 00:34:34.246 A:middle
well-typed property here in

00:34:34.246 --> 00:34:35.795 A:middle
Swift that you just referred to

00:34:35.795 --> 00:34:37.466 A:middle
as a Bool and some

00:34:37.466 --> 00:34:38.726 A:middle
stringly-typed entity.

00:34:39.045 --> 00:34:40.085 A:middle
So we describe in the

00:34:40.085 --> 00:34:41.636 A:middle
construction arguments exactly

00:34:41.815 --> 00:34:43.476 A:middle
how to go ahead and access that

00:34:43.476 --> 00:34:43.815 A:middle
thing.

00:34:44.246 --> 00:34:46.255 A:middle
And all of the logic for dealing

00:34:46.255 --> 00:34:47.926 A:middle
with user defaults, that's over

00:34:47.926 --> 00:34:49.505 A:middle
in this user default property

00:34:50.005 --> 00:34:50.136 A:middle
wrapper.

00:34:51.076 --> 00:34:53.196 A:middle
So we built thread-specific.

00:34:53.196 --> 00:34:54.036 A:middle
If you want thread local

00:34:54.036 --> 00:34:54.446 A:middle
storage.

00:34:55.356 --> 00:34:55.966 A:middle
You can apply the

00:34:55.966 --> 00:34:56.886 A:middle
thread-specific property

00:34:56.886 --> 00:34:57.206 A:middle
wrapper.

00:34:57.296 --> 00:34:58.426 A:middle
All the details of dealing with

00:34:58.426 --> 00:35:00.176 A:middle
the system's thread-specific

00:34:58.426 --> 00:35:00.176 A:middle
the system's thread-specific

00:35:00.176 --> 00:35:01.466 A:middle
storage are there in the

00:35:01.466 --> 00:35:02.376 A:middle
property wrapper once.

00:35:02.556 --> 00:35:03.796 A:middle
You can just think of this thing

00:35:03.906 --> 00:35:05.766 A:middle
like a local memory pool.

00:35:06.756 --> 00:35:08.326 A:middle
And also, from the Swift

00:35:08.326 --> 00:35:09.106 A:middle
community, as we've been

00:35:09.106 --> 00:35:10.636 A:middle
building this feature, we found

00:35:11.376 --> 00:35:13.026 A:middle
that this actually works really

00:35:13.026 --> 00:35:14.226 A:middle
well for describing command line

00:35:14.226 --> 00:35:14.696 A:middle
arguments.

00:35:14.696 --> 00:35:15.496 A:middle
If you're building a command

00:35:15.496 --> 00:35:17.376 A:middle
line tool with a library out

00:35:17.376 --> 00:35:18.906 A:middle
there that uses this kind of

00:35:19.256 --> 00:35:20.476 A:middle
shorthand syntax, just say,

00:35:20.476 --> 00:35:21.926 A:middle
well, I want a minimum value.

00:35:22.106 --> 00:35:23.016 A:middle
Here's how I describe the

00:35:23.016 --> 00:35:23.426 A:middle
option.

00:35:24.156 --> 00:35:25.276 A:middle
Here's the strings that the user

00:35:25.276 --> 00:35:26.406 A:middle
passes, where they're short,

00:35:26.406 --> 00:35:27.516 A:middle
what the documentation is.

00:35:27.596 --> 00:35:28.776 A:middle
All the extra stuff that you

00:35:28.776 --> 00:35:31.026 A:middle
need to very, very succinctly

00:35:31.026 --> 00:35:32.426 A:middle
declare your command line

00:35:32.426 --> 00:35:32.936 A:middle
options.

00:35:33.636 --> 00:35:34.666 A:middle
There's a ton of really cool

00:35:34.666 --> 00:35:35.916 A:middle
stuff that we can do with

00:35:35.916 --> 00:35:37.046 A:middle
property wrappers because we

00:35:37.046 --> 00:35:38.756 A:middle
have this nice, clean syntax for

00:35:38.756 --> 00:35:39.616 A:middle
factoring stuff out.

00:35:40.816 --> 00:35:42.456 A:middle
Now, as you probably noticed

00:35:42.456 --> 00:35:44.386 A:middle
from another session, we use

00:35:44.386 --> 00:35:46.086 A:middle
property wrappers extensively

00:35:46.386 --> 00:35:48.636 A:middle
throughout SwiftUI to describe

00:35:48.636 --> 00:35:50.536 A:middle
the data dependencies of your

00:35:50.536 --> 00:35:50.906 A:middle
view.

00:35:52.016 --> 00:35:54.116 A:middle
And there's several of these

00:35:54.116 --> 00:35:55.326 A:middle
different property wrappers that

00:35:55.326 --> 00:35:56.896 A:middle
exist within Swift UI.

00:35:57.036 --> 00:35:58.556 A:middle
So here we have State for

00:35:58.556 --> 00:35:59.806 A:middle
introducing view local state.

00:36:00.186 --> 00:36:01.716 A:middle
We have Binding for a sort of

00:36:01.716 --> 00:36:02.986 A:middle
first class reference out to

00:36:02.986 --> 00:36:04.236 A:middle
state that's somewhere else.

00:36:04.516 --> 00:36:05.036 A:middle
You've probably seen

00:36:05.036 --> 00:36:06.176 A:middle
Environment, an environment

00:36:06.176 --> 00:36:06.586 A:middle
object.

00:36:07.676 --> 00:36:08.816 A:middle
All of these things are property

00:36:08.816 --> 00:36:09.206 A:middle
wrappers.

00:36:09.206 --> 00:36:10.636 A:middle
And the really nice thing about

00:36:10.636 --> 00:36:12.196 A:middle
describing them that way in

00:36:12.196 --> 00:36:15.216 A:middle
Swift is that you're stating

00:36:15.216 --> 00:36:17.216 A:middle
your policy for where this data

00:36:17.216 --> 00:36:19.326 A:middle
is and how it's accessed in one

00:36:19.326 --> 00:36:20.506 A:middle
place in the declaration.

00:36:21.106 --> 00:36:22.306 A:middle
But when you go and build your

00:36:22.306 --> 00:36:24.586 A:middle
view, you don't care about that.

00:36:24.716 --> 00:36:25.766 A:middle
You don't care where the data

00:36:25.766 --> 00:36:26.386 A:middle
is.

00:36:26.556 --> 00:36:27.966 A:middle
It's managed by the system for

00:36:27.966 --> 00:36:28.136 A:middle
you.

00:36:28.926 --> 00:36:30.536 A:middle
You just can refer to the

00:36:30.536 --> 00:36:32.216 A:middle
particular slide I'm on in my

00:36:32.216 --> 00:36:32.806 A:middle
keynote deck.

00:36:33.536 --> 00:36:34.266 A:middle
Pull out its number.

00:36:34.716 --> 00:36:35.696 A:middle
If you want to go and edit

00:36:35.696 --> 00:36:38.426 A:middle
something, you can use $ and get

00:36:39.376 --> 00:36:41.726 A:middle
back at the actual binding.

00:36:42.776 --> 00:36:45.996 A:middle
So, all of the logic for dealing

00:36:45.996 --> 00:36:47.736 A:middle
with the data and watching for

00:36:47.776 --> 00:36:49.096 A:middle
change updates and maybe even

00:36:49.096 --> 00:36:50.256 A:middle
storing the data on the side,

00:36:50.476 --> 00:36:51.946 A:middle
that's all handled off in the

00:36:51.946 --> 00:36:53.256 A:middle
policy in the property wrapper

00:36:53.256 --> 00:36:53.696 A:middle
types.

00:36:53.976 --> 00:36:55.026 A:middle
You don't have to think about

00:36:55.026 --> 00:36:55.116 A:middle
it.

00:36:55.336 --> 00:36:56.766 A:middle
You just worry about working

00:36:56.766 --> 00:36:57.626 A:middle
with your actual data.

00:36:58.306 --> 00:37:00.136 A:middle
Now, there's one thing that's a

00:36:58.306 --> 00:37:00.136 A:middle
Now, there's one thing that's a

00:37:00.136 --> 00:37:01.486 A:middle
little bit interesting on this

00:37:01.486 --> 00:37:01.796 A:middle
slide.

00:37:02.436 --> 00:37:04.906 A:middle
So, there's $slide.title.

00:37:05.546 --> 00:37:06.736 A:middle
We're passing down so we can

00:37:06.876 --> 00:37:08.266 A:middle
edit the slide title in a text

00:37:08.266 --> 00:37:08.506 A:middle
field.

00:37:09.986 --> 00:37:12.256 A:middle
$slide -- well, we've seen that

00:37:12.256 --> 00:37:12.566 A:middle
before.

00:37:12.646 --> 00:37:14.066 A:middle
That's the backing storage

00:37:14.066 --> 00:37:14.486 A:middle
property.

00:37:14.486 --> 00:37:15.356 A:middle
That's what the compiler is

00:37:15.356 --> 00:37:16.836 A:middle
synthesizing on our behalf

00:37:17.176 --> 00:37:19.546 A:middle
because we applied the binding

00:37:19.546 --> 00:37:20.436 A:middle
property wrapper here.

00:37:21.826 --> 00:37:23.236 A:middle
But that's a binding.

00:37:23.686 --> 00:37:24.676 A:middle
It doesn't have a title.

00:37:26.066 --> 00:37:27.306 A:middle
Title is something that's part

00:37:27.306 --> 00:37:28.096 A:middle
of my data model.

00:37:28.096 --> 00:37:29.096 A:middle
I have a slide data model.

00:37:29.186 --> 00:37:29.646 A:middle
What gives?

00:37:30.086 --> 00:37:32.426 A:middle
So, this is actually a

00:37:32.426 --> 00:37:34.446 A:middle
combination of both property

00:37:34.446 --> 00:37:36.716 A:middle
wrappers and the key path member

00:37:36.716 --> 00:37:38.636 A:middle
lookup feature that Ben talked

00:37:38.636 --> 00:37:39.226 A:middle
about earlier.

00:37:39.806 --> 00:37:42.256 A:middle
And so, let's actually focus in

00:37:42.306 --> 00:37:43.896 A:middle
on binding, the thing that's in

00:37:43.896 --> 00:37:45.526 A:middle
Swift UI and provides this first

00:37:45.526 --> 00:37:46.816 A:middle
class reference.

00:37:47.136 --> 00:37:49.646 A:middle
First and foremost, binding is a

00:37:49.646 --> 00:37:50.416 A:middle
property wrapper.

00:37:50.946 --> 00:37:53.736 A:middle
So, it has the standard value.

00:37:53.736 --> 00:37:55.166 A:middle
It's parameterized over any type

00:37:55.166 --> 00:37:56.056 A:middle
because you can have a binding

00:37:56.056 --> 00:37:56.786 A:middle
to anything.

00:37:57.096 --> 00:37:59.046 A:middle
It has whatever the access

00:37:59.046 --> 00:37:59.416 A:middle
pattern is.

00:37:59.416 --> 00:38:00.106 A:middle
It doesn't matter.

00:37:59.416 --> 00:38:00.106 A:middle
It doesn't matter.

00:38:00.276 --> 00:38:02.456 A:middle
We don't know what it is because

00:38:02.456 --> 00:38:03.466 A:middle
it's handled by the framework

00:38:03.466 --> 00:38:04.426 A:middle
for us.

00:38:04.536 --> 00:38:07.646 A:middle
But, binding also supports key

00:38:07.646 --> 00:38:09.306 A:middle
path member lookup with this

00:38:09.346 --> 00:38:10.496 A:middle
generic subscript.

00:38:11.766 --> 00:38:12.716 A:middle
These generic subscripts are

00:38:12.766 --> 00:38:13.506 A:middle
kind of a mouthful.

00:38:13.566 --> 00:38:14.486 A:middle
And we don't have to know what

00:38:14.486 --> 00:38:15.756 A:middle
the implementation is, but we

00:38:15.756 --> 00:38:16.466 A:middle
should look at the type

00:38:16.466 --> 00:38:17.606 A:middle
signature a little more closely

00:38:17.606 --> 00:38:18.676 A:middle
because it is interesting.

00:38:19.096 --> 00:38:21.006 A:middle
So, what we're taking in is a

00:38:21.006 --> 00:38:21.476 A:middle
key path.

00:38:21.986 --> 00:38:24.096 A:middle
It's rooted at our particular

00:38:24.266 --> 00:38:24.966 A:middle
value type.

00:38:24.966 --> 00:38:26.766 A:middle
So the thing that we're binding,

00:38:27.006 --> 00:38:30.656 A:middle
like a slide, and accessing any

00:38:30.656 --> 00:38:32.856 A:middle
property within that particular

00:38:32.996 --> 00:38:33.466 A:middle
entity.

00:38:34.186 --> 00:38:36.076 A:middle
Now, returning is not a value

00:38:36.076 --> 00:38:38.176 A:middle
that's referring to like

00:38:38.176 --> 00:38:39.146 A:middle
something in there.

00:38:39.396 --> 00:38:41.256 A:middle
We're returning a new binding

00:38:41.666 --> 00:38:43.426 A:middle
that is focused in on just one

00:38:43.426 --> 00:38:45.976 A:middle
particular property of the outer

00:38:45.976 --> 00:38:47.836 A:middle
binding, still maintaining that

00:38:47.836 --> 00:38:48.936 A:middle
data dependency there.

00:38:52.806 --> 00:38:53.836 A:middle
So, how does this work in

00:38:53.836 --> 00:38:54.356 A:middle
practice.

00:38:54.356 --> 00:38:56.556 A:middle
Well, we had our slide, which is

00:38:56.556 --> 00:38:57.776 A:middle
a binding into one of our slide

00:38:57.776 --> 00:38:58.206 A:middle
types.

00:38:58.916 --> 00:39:00.696 A:middle
And primarily we think about

00:38:58.916 --> 00:39:00.696 A:middle
And primarily we think about

00:39:00.696 --> 00:39:01.526 A:middle
this as the value.

00:39:01.526 --> 00:39:02.636 A:middle
So we can refer to slide, we get

00:39:02.636 --> 00:39:03.496 A:middle
an instance of slide.

00:39:03.496 --> 00:39:04.986 A:middle
We can refer to slide.title and

00:39:04.986 --> 00:39:06.406 A:middle
get an instance of that string.

00:39:06.676 --> 00:39:07.626 A:middle
All the while tracking

00:39:08.186 --> 00:39:10.176 A:middle
modifications behind the scenes.

00:39:10.756 --> 00:39:13.376 A:middle
If we enter $Slide, well, we get

00:39:13.436 --> 00:39:14.846 A:middle
that binding instance to the

00:39:14.846 --> 00:39:15.336 A:middle
slide.

00:39:15.946 --> 00:39:19.506 A:middle
When we enter $slide.title, well

00:39:19.506 --> 00:39:20.626 A:middle
now we're looking for a property

00:39:20.626 --> 00:39:22.316 A:middle
that's not there on binding, so

00:39:22.316 --> 00:39:24.056 A:middle
the compiler's rewriting this

00:39:24.126 --> 00:39:26.266 A:middle
into a use of the dynamic number

00:39:26.266 --> 00:39:28.696 A:middle
subscript, passing in a key path

00:39:29.216 --> 00:39:30.276 A:middle
to slide.title.

00:39:31.536 --> 00:39:33.126 A:middle
The way this is resolved is one

00:39:33.126 --> 00:39:34.586 A:middle
of these focused bindings

00:39:34.866 --> 00:39:37.846 A:middle
pointing into the string

00:39:37.956 --> 00:39:39.776 A:middle
property within the previous

00:39:39.806 --> 00:39:40.826 A:middle
binding following all the data

00:39:40.826 --> 00:39:41.706 A:middle
dependencies throughout.

00:39:42.656 --> 00:39:44.946 A:middle
And so, if we step away from the

00:39:44.946 --> 00:39:46.246 A:middle
language mechanism that we've

00:39:46.246 --> 00:39:48.136 A:middle
been focusing on and sort of

00:39:48.136 --> 00:39:49.286 A:middle
look at the high level code that

00:39:49.286 --> 00:39:51.246 A:middle
we did here, it's really nice.

00:39:51.246 --> 00:39:52.416 A:middle
We established our data

00:39:52.416 --> 00:39:54.096 A:middle
dependency using this custom

00:39:54.096 --> 00:39:54.876 A:middle
attribute in the property

00:39:54.876 --> 00:39:55.216 A:middle
wrapper.

00:39:55.976 --> 00:39:57.086 A:middle
We have primary access to our

00:39:57.086 --> 00:39:59.276 A:middle
data very easily to go read it

00:39:59.276 --> 00:39:59.906 A:middle
or modify it.

00:39:59.906 --> 00:40:01.546 A:middle
And if we want a pass down a

00:39:59.906 --> 00:40:01.546 A:middle
And if we want a pass down a

00:40:01.546 --> 00:40:02.536 A:middle
first class reference through

00:40:02.536 --> 00:40:04.506 A:middle
our binding, we put this prefix

00:40:04.506 --> 00:40:05.796 A:middle
of $ at the front of it.

00:40:05.876 --> 00:40:06.806 A:middle
And the effect we get is we

00:40:06.806 --> 00:40:07.836 A:middle
always get to pass down a

00:40:07.836 --> 00:40:09.886 A:middle
binding to some other view.

00:40:11.616 --> 00:40:15.416 A:middle
So, we've talked about a couple

00:40:15.416 --> 00:40:16.146 A:middle
of different topics.

00:40:16.146 --> 00:40:17.586 A:middle
We talked about value semantics

00:40:17.646 --> 00:40:19.556 A:middle
and reference semantics, when to

00:40:19.556 --> 00:40:21.096 A:middle
use each of them and how to make

00:40:21.096 --> 00:40:21.936 A:middle
them work together.

00:40:23.076 --> 00:40:24.116 A:middle
We've talked about the use of

00:40:24.116 --> 00:40:25.596 A:middle
generics and protocols.

00:40:26.336 --> 00:40:27.376 A:middle
And remember, protocols are

00:40:27.376 --> 00:40:28.476 A:middle
extremely powerful.

00:40:28.596 --> 00:40:30.686 A:middle
But use them for code reuse.

00:40:30.686 --> 00:40:31.716 A:middle
That's what they're there for.

00:40:32.086 --> 00:40:33.606 A:middle
Not for classification and

00:40:33.606 --> 00:40:34.966 A:middle
building big hierarchies because

00:40:34.966 --> 00:40:35.696 A:middle
those are going to get in your

00:40:35.696 --> 00:40:35.906 A:middle
way.

00:40:35.986 --> 00:40:37.706 A:middle
You're not going to need it.

00:40:37.996 --> 00:40:39.776 A:middle
And finally, we went into a

00:40:39.776 --> 00:40:41.326 A:middle
little deep dive into the

00:40:41.326 --> 00:40:43.526 A:middle
property wrappers language

00:40:43.526 --> 00:40:45.746 A:middle
feature and how we can use it to

00:40:45.796 --> 00:40:47.186 A:middle
abstract access to data.

00:40:48.476 --> 00:40:48.776 A:middle
All right.

00:40:48.876 --> 00:40:49.846 A:middle
Thank you very much.

00:40:50.416 --> 00:40:51.816 A:middle
Come see us in the labs if you'd

00:40:51.816 --> 00:40:53.466 A:middle
like to chat about any of these.

00:40:54.516 --> 00:40:59.500 A:middle
[ Applause ]
