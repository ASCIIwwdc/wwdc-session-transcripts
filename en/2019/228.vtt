WEBVTT

00:00:00.506 --> 00:00:05.500 A:middle
[ Music ]

00:00:12.496 --> 00:00:14.496 A:middle
[ Applause ]

00:00:14.976 --> 00:00:16.666 A:middle
&gt;&gt; Good morning, and thank you

00:00:16.666 --> 00:00:17.616 A:middle
for coming to our session.

00:00:19.206 --> 00:00:21.996 A:middle
At Apple, we build technologies.

00:00:22.936 --> 00:00:24.436 A:middle
We build technologies so that

00:00:24.436 --> 00:00:26.236 A:middle
you can make great apps with

00:00:26.236 --> 00:00:27.356 A:middle
amazing experiences.

00:00:27.886 --> 00:00:30.916 A:middle
And my favorite apps are the

00:00:30.916 --> 00:00:32.296 A:middle
ones that seamlessly blend those

00:00:32.296 --> 00:00:34.096 A:middle
technologies and really immerse

00:00:34.096 --> 00:00:35.166 A:middle
us in the experience.

00:00:36.956 --> 00:00:39.496 A:middle
Today we'd like to talk to you

00:00:39.496 --> 00:00:40.946 A:middle
about two of these technologies:

00:00:41.446 --> 00:00:43.036 A:middle
Core ML and ARKit.

00:00:43.586 --> 00:00:47.026 A:middle
Both of these help our devices

00:00:47.116 --> 00:00:48.666 A:middle
gain a level of understanding

00:00:48.666 --> 00:00:50.466 A:middle
about the world around us.

00:00:51.696 --> 00:00:54.216 A:middle
They help us blend the physical

00:00:54.216 --> 00:00:54.976 A:middle
and virtual worlds.

00:00:57.216 --> 00:00:58.646 A:middle
Today we're going to take you on

00:00:58.646 --> 00:00:59.926 A:middle
a journey of building an app

00:00:59.926 --> 00:01:02.046 A:middle
that does just that.

00:00:59.926 --> 00:01:02.046 A:middle
that does just that.

00:01:02.516 --> 00:01:04.245 A:middle
Along the way, we're going to

00:01:04.245 --> 00:01:05.296 A:middle
look at some challenges that we

00:01:05.296 --> 00:01:07.076 A:middle
faced and how we overcame them,

00:01:07.636 --> 00:01:09.136 A:middle
and we're going to look at some

00:01:09.136 --> 00:01:11.266 A:middle
themes that arose from facing

00:01:11.266 --> 00:01:12.066 A:middle
those challenges.

00:01:13.836 --> 00:01:17.596 A:middle
The first, being the question,

00:01:17.676 --> 00:01:19.486 A:middle
can machine learning help?

00:01:20.656 --> 00:01:23.016 A:middle
Well, okay, if I said no, then

00:01:23.016 --> 00:01:23.886 A:middle
this would be a pretty short

00:01:23.886 --> 00:01:24.166 A:middle
session.

00:01:24.806 --> 00:01:27.286 A:middle
But I can't just say a blanket

00:01:27.286 --> 00:01:29.946 A:middle
yes, because the answer really

00:01:29.946 --> 00:01:31.996 A:middle
depends on the type of problem

00:01:31.996 --> 00:01:33.396 A:middle
you're trying to solve and the

00:01:33.396 --> 00:01:34.836 A:middle
data you have to solve it,

00:01:36.276 --> 00:01:37.366 A:middle
because machine learning is

00:01:37.366 --> 00:01:38.646 A:middle
about understanding data.

00:01:38.646 --> 00:01:40.506 A:middle
It's about understanding

00:01:40.596 --> 00:01:42.486 A:middle
patterns in data, patterns in

00:01:42.486 --> 00:01:44.476 A:middle
data that may be difficult to

00:01:44.476 --> 00:01:45.816 A:middle
write down programmatically.

00:01:46.246 --> 00:01:48.876 A:middle
And this data exists in your

00:01:49.556 --> 00:01:49.746 A:middle
apps.

00:01:50.106 --> 00:01:51.576 A:middle
Your users enter it every day.

00:01:52.236 --> 00:01:53.836 A:middle
They use the keyboard and they

00:01:53.836 --> 00:01:55.246 A:middle
enter text.

00:01:56.216 --> 00:01:57.706 A:middle
They use the microphone and they

00:01:57.706 --> 00:01:58.536 A:middle
record sound.

00:02:00.456 --> 00:02:01.976 A:middle
They use the camera and they

00:02:01.976 --> 00:02:03.726 A:middle
capture video and pictures.

00:02:04.246 --> 00:02:07.006 A:middle
So when facing a problem, asking

00:02:07.006 --> 00:02:08.466 A:middle
yourself, can machine learning

00:02:08.466 --> 00:02:10.265 A:middle
help, is a good question to ask.

00:02:10.705 --> 00:02:12.536 A:middle
Now, you need to take a close

00:02:12.536 --> 00:02:13.256 A:middle
look at the problem you're

00:02:13.256 --> 00:02:15.016 A:middle
trying to solve and the data you

00:02:15.016 --> 00:02:16.726 A:middle
have available to solve it.

00:02:19.656 --> 00:02:20.986 A:middle
The second theme that we're

00:02:20.986 --> 00:02:22.806 A:middle
going to look at today is

00:02:22.806 --> 00:02:23.886 A:middle
understanding the behavior of

00:02:23.886 --> 00:02:25.076 A:middle
your model.

00:02:25.996 --> 00:02:28.276 A:middle
These models are trained to

00:02:28.276 --> 00:02:30.326 A:middle
expect certain inputs in certain

00:02:30.326 --> 00:02:33.376 A:middle
formats and to provide outputs

00:02:33.426 --> 00:02:35.036 A:middle
in certain formats.

00:02:35.616 --> 00:02:38.806 A:middle
And so if your input is not in

00:02:38.806 --> 00:02:40.176 A:middle
the format that's expected for

00:02:40.176 --> 00:02:42.856 A:middle
the model, then the output is

00:02:42.856 --> 00:02:44.046 A:middle
going to be unexpected as well.

00:02:44.046 --> 00:02:48.046 A:middle
And speaking of outputs, if you

00:02:48.046 --> 00:02:49.026 A:middle
don't understand what's being

00:02:49.026 --> 00:02:50.326 A:middle
output from your model, it's

00:02:50.326 --> 00:02:51.736 A:middle
going to be difficult to use it

00:02:52.176 --> 00:02:53.616 A:middle
to make that magical experience

00:02:53.616 --> 00:02:54.886 A:middle
in your app.

00:02:56.136 --> 00:02:57.396 A:middle
We're going to look at a couple

00:02:57.396 --> 00:02:59.316 A:middle
ways that you can visualize the

00:02:59.316 --> 00:03:01.186 A:middle
inputs and the outputs of some

00:02:59.316 --> 00:03:01.186 A:middle
inputs and the outputs of some

00:03:01.186 --> 00:03:01.726 A:middle
models.

00:03:02.206 --> 00:03:04.836 A:middle
But for now, on with our

00:03:04.836 --> 00:03:05.116 A:middle
journey.

00:03:06.166 --> 00:03:07.666 A:middle
We said that we're going to

00:03:07.666 --> 00:03:09.456 A:middle
combine technologies to blend

00:03:09.456 --> 00:03:10.776 A:middle
the physical and virtual worlds,

00:03:10.836 --> 00:03:12.786 A:middle
and what better context to do

00:03:12.786 --> 00:03:14.606 A:middle
this in than an app?

00:03:14.706 --> 00:03:16.986 A:middle
We thought that it would be fun

00:03:17.276 --> 00:03:18.716 A:middle
to build an educational game app

00:03:18.806 --> 00:03:20.526 A:middle
for children to practice their

00:03:20.526 --> 00:03:23.376 A:middle
math skills, like counting, or

00:03:23.376 --> 00:03:24.986 A:middle
addition, or multiplication.

00:03:25.796 --> 00:03:28.306 A:middle
And we know that children

00:03:28.306 --> 00:03:29.746 A:middle
sometimes use dice to practice

00:03:29.746 --> 00:03:30.266 A:middle
these skills.

00:03:30.906 --> 00:03:32.266 A:middle
Now, we could've just put

00:03:32.616 --> 00:03:35.036 A:middle
virtual dice in the app and let

00:03:35.036 --> 00:03:36.406 A:middle
those roll around on the screen,

00:03:36.656 --> 00:03:37.806 A:middle
but we thought, wouldn't it be a

00:03:37.806 --> 00:03:39.946 A:middle
lot more fun if the children

00:03:39.946 --> 00:03:41.236 A:middle
could play with physical dice

00:03:41.236 --> 00:03:42.856 A:middle
and roll those on the table and

00:03:43.396 --> 00:03:45.086 A:middle
then interact with our app?

00:03:46.336 --> 00:03:47.996 A:middle
So that's what we did.

00:03:48.296 --> 00:03:50.586 A:middle
And the first challenge that we

00:03:50.586 --> 00:03:54.396 A:middle
ran into was, how do you get an

00:03:54.396 --> 00:03:55.646 A:middle
app to recognize dice?

00:03:56.146 --> 00:03:58.676 A:middle
Well, there's a couple

00:03:58.676 --> 00:03:59.306 A:middle
approaches.

00:04:00.266 --> 00:04:01.906 A:middle
Let's start programmatically.

00:04:02.526 --> 00:04:04.666 A:middle
But this is going to be a little

00:04:05.046 --> 00:04:05.306 A:middle
difficult.

00:04:06.616 --> 00:04:08.106 A:middle
If we constrain our problem to

00:04:08.106 --> 00:04:10.256 A:middle
only six-sided dice, we can

00:04:10.256 --> 00:04:11.446 A:middle
start to look at the properties

00:04:11.446 --> 00:04:11.726 A:middle
of a die.

00:04:12.536 --> 00:04:14.666 A:middle
For instance, the die behind me,

00:04:14.666 --> 00:04:15.606 A:middle
its color is gray.

00:04:16.935 --> 00:04:19.466 A:middle
But not all dice are gray, so

00:04:19.466 --> 00:04:21.536 A:middle
that's not necessarily helpful.

00:04:22.856 --> 00:04:24.926 A:middle
If you look at it in a 2D plane,

00:04:25.476 --> 00:04:26.876 A:middle
it's a hexagon shape and it has

00:04:26.986 --> 00:04:28.596 A:middle
three skewed squares for sides.

00:04:30.206 --> 00:04:31.926 A:middle
But those move and change as the

00:04:31.926 --> 00:04:33.176 A:middle
die rolls around on the table.

00:04:33.836 --> 00:04:36.416 A:middle
If we take a closer look at each

00:04:36.416 --> 00:04:38.396 A:middle
side, there's a number of dots

00:04:38.396 --> 00:04:40.096 A:middle
on them; but again, that's

00:04:40.256 --> 00:04:41.426 A:middle
different depending on the side

00:04:41.426 --> 00:04:42.966 A:middle
you're looking at and depending

00:04:42.966 --> 00:04:44.236 A:middle
on your perspective of the die.

00:04:45.426 --> 00:04:47.066 A:middle
So with all of these properties

00:04:47.346 --> 00:04:49.476 A:middle
changing, it's going to be

00:04:49.476 --> 00:04:50.726 A:middle
pretty difficult to write a

00:04:50.876 --> 00:04:52.476 A:middle
program to recognize dice.

00:04:52.866 --> 00:04:56.106 A:middle
So let's take a look at the

00:04:56.106 --> 00:04:56.976 A:middle
machine learning approach.

00:05:00.536 --> 00:05:02.376 A:middle
We could train an image

00:05:02.376 --> 00:05:04.216 A:middle
classification model to

00:05:04.216 --> 00:05:06.146 A:middle
recognize dice in an image.

00:05:06.706 --> 00:05:10.996 A:middle
But we want to know how many

00:05:10.996 --> 00:05:12.766 A:middle
dice are in an image -- not just

00:05:12.766 --> 00:05:14.346 A:middle
the existence of dice in an

00:05:14.346 --> 00:05:14.706 A:middle
image.

00:05:15.896 --> 00:05:17.356 A:middle
So instead, we looked at using

00:05:17.356 --> 00:05:18.426 A:middle
an object detection model.

00:05:18.986 --> 00:05:21.056 A:middle
An object detection model will

00:05:21.056 --> 00:05:22.316 A:middle
tell us if there's dice in an

00:05:22.316 --> 00:05:24.366 A:middle
image, but it will also tell us

00:05:24.366 --> 00:05:26.076 A:middle
where it is in the image; and if

00:05:26.076 --> 00:05:27.176 A:middle
we know where the dice are in

00:05:27.176 --> 00:05:29.446 A:middle
the image, then we can count

00:05:30.476 --> 00:05:30.606 A:middle
them.

00:05:30.786 --> 00:05:32.596 A:middle
To do this, we needed to get

00:05:32.596 --> 00:05:34.846 A:middle
data, so we took a bunch of

00:05:34.846 --> 00:05:37.336 A:middle
pictures of dice rolling around

00:05:37.606 --> 00:05:38.116 A:middle
on the table.

00:05:38.606 --> 00:05:41.436 A:middle
Next, we took those pictures and

00:05:41.436 --> 00:05:43.286 A:middle
we annotated them with bounding

00:05:43.286 --> 00:05:44.886 A:middle
boxes, indicating where the dice

00:05:44.886 --> 00:05:45.906 A:middle
are in the images.

00:05:46.226 --> 00:05:49.486 A:middle
After that, we used the new

00:05:49.486 --> 00:05:51.276 A:middle
Create ML to train our custom

00:05:51.276 --> 00:05:52.246 A:middle
object detection model.

00:05:54.716 --> 00:05:56.026 A:middle
If you'd like to learn more

00:05:56.026 --> 00:05:57.966 A:middle
about this training, please see

00:05:57.966 --> 00:05:59.046 A:middle
the Create ML for Object

00:05:59.046 --> 00:05:59.936 A:middle
Detection and Sound

00:05:59.936 --> 00:06:00.876 A:middle
Classification session.

00:05:59.936 --> 00:06:00.876 A:middle
Classification session.

00:06:00.876 --> 00:06:04.806 A:middle
Now I'd like to invite Scott up

00:06:04.806 --> 00:06:06.356 A:middle
to show you this in action.

00:06:07.596 --> 00:06:07.896 A:middle
Scott?

00:06:08.516 --> 00:06:13.036 A:middle
[ Applause ]

00:06:13.536 --> 00:06:14.496 A:middle
&gt;&gt; Good morning, everyone.

00:06:14.936 --> 00:06:15.176 A:middle
&gt;&gt; Morning!

00:06:17.136 --> 00:06:18.246 A:middle
&gt;&gt; As Brent discussed, we're

00:06:18.246 --> 00:06:19.916 A:middle
going to be exploring adding the

00:06:19.916 --> 00:06:21.516 A:middle
ability for our app to count

00:06:21.516 --> 00:06:23.006 A:middle
dice using a machine learning

00:06:23.006 --> 00:06:24.006 A:middle
technique called object

00:06:24.006 --> 00:06:24.446 A:middle
detection.

00:06:25.066 --> 00:06:26.396 A:middle
And I'm sure you're all eager to

00:06:26.396 --> 00:06:27.726 A:middle
see it in action, so let's get

00:06:27.726 --> 00:06:29.000 A:middle
right to it.

00:06:38.536 --> 00:06:40.736 A:middle
So here, we have a very simple

00:06:40.946 --> 00:06:41.996 A:middle
app that's wired with a live

00:06:41.996 --> 00:06:43.586 A:middle
camera view, and we've added our

00:06:43.586 --> 00:06:44.866 A:middle
object detector trained to

00:06:44.866 --> 00:06:46.516 A:middle
detect dice so that we can count

00:06:46.516 --> 00:06:46.706 A:middle
them.

00:06:47.196 --> 00:06:48.236 A:middle
So let's see what happens when

00:06:48.236 --> 00:06:49.366 A:middle
we add dice to the frame.

00:06:50.766 --> 00:06:55.896 A:middle
One, two, three, and four.

00:06:56.056 --> 00:06:59.056 A:middle
We can even take a roll for more

00:06:59.056 --> 00:06:59.366 A:middle
fun.

00:07:00.066 --> 00:07:02.416 A:middle
So this is great.

00:07:02.416 --> 00:07:04.446 A:middle
Our app is able to count dice

00:07:04.786 --> 00:07:05.866 A:middle
using object detection.

00:07:06.476 --> 00:07:07.836 A:middle
But one of the themes that we

00:07:07.836 --> 00:07:09.066 A:middle
want to discuss with you today

00:07:09.066 --> 00:07:10.476 A:middle
is understanding your model's

00:07:10.506 --> 00:07:10.966 A:middle
behavior.

00:07:11.416 --> 00:07:13.616 A:middle
So let's actually take a look at

00:07:13.616 --> 00:07:15.286 A:middle
a debug visualization of what

00:07:15.286 --> 00:07:16.436 A:middle
the model is seeing.

00:07:17.006 --> 00:07:18.096 A:middle
As you can see, we're drawing

00:07:18.096 --> 00:07:20.066 A:middle
bounding boxes around each of

00:07:20.066 --> 00:07:21.926 A:middle
the detected objects -- in this

00:07:21.926 --> 00:07:23.576 A:middle
case, dice -- on the board.

00:07:23.576 --> 00:07:25.216 A:middle
And if we move them around,

00:07:25.566 --> 00:07:28.396 A:middle
those boxes will move as well.

00:07:28.606 --> 00:07:30.346 A:middle
This is important to you because

00:07:30.346 --> 00:07:32.756 A:middle
if you are training an object

00:07:32.756 --> 00:07:34.606 A:middle
detector and you start playing

00:07:34.606 --> 00:07:35.946 A:middle
around with it, and you don't

00:07:35.946 --> 00:07:37.416 A:middle
notice certain boxes around

00:07:37.416 --> 00:07:38.556 A:middle
objects that aren't what you're

00:07:38.556 --> 00:07:40.826 A:middle
trying to detect, or you're not

00:07:40.886 --> 00:07:42.156 A:middle
seeing boxes around the objects

00:07:42.156 --> 00:07:43.436 A:middle
that you are trying to detect,

00:07:43.846 --> 00:07:45.276 A:middle
this is probably the opportunity

00:07:45.276 --> 00:07:46.536 A:middle
for you to go and collect more

00:07:46.536 --> 00:07:47.866 A:middle
data in this kind of lighting.

00:07:48.376 --> 00:07:49.746 A:middle
You may want to collect more

00:07:49.746 --> 00:07:50.726 A:middle
data with different kinds of

00:07:50.726 --> 00:07:52.786 A:middle
backgrounds, different lighting,

00:07:53.096 --> 00:07:54.276 A:middle
with a different number of

00:07:54.276 --> 00:07:55.756 A:middle
objects -- in this case, we have

00:07:55.836 --> 00:07:56.716 A:middle
four, but you may want to

00:07:56.716 --> 00:07:58.486 A:middle
collect with five, six, up to

00:07:58.486 --> 00:08:00.706 A:middle
ten dice, or less, or even

00:07:58.486 --> 00:08:00.706 A:middle
ten dice, or less, or even

00:08:00.706 --> 00:08:02.066 A:middle
images without them to train it

00:08:02.066 --> 00:08:03.746 A:middle
to not recognize other objects.

00:08:07.076 --> 00:08:09.116 A:middle
Let's take a look at some code

00:08:09.116 --> 00:08:11.346 A:middle
to do this.

00:08:11.506 --> 00:08:12.566 A:middle
When you use your object

00:08:12.566 --> 00:08:13.536 A:middle
detector that you've trained

00:08:13.536 --> 00:08:15.186 A:middle
with Create ML, in the Vision

00:08:15.186 --> 00:08:16.796 A:middle
framework, what you get back as

00:08:16.796 --> 00:08:18.056 A:middle
a result is a list of VN

00:08:18.056 --> 00:08:19.586 A:middle
recognized object observations.

00:08:20.316 --> 00:08:21.536 A:middle
So here we have a function that

00:08:21.536 --> 00:08:22.846 A:middle
handles those observations and

00:08:22.846 --> 00:08:23.946 A:middle
does a couple things for us.

00:08:24.526 --> 00:08:25.746 A:middle
The first one is the easiest:

00:08:26.286 --> 00:08:27.146 A:middle
we're just counting dice.

00:08:27.606 --> 00:08:29.106 A:middle
And this just is as simple as

00:08:29.106 --> 00:08:29.806 A:middle
counting the number of

00:08:29.806 --> 00:08:31.076 A:middle
observations because we have one

00:08:31.156 --> 00:08:31.766 A:middle
per die.

00:08:32.326 --> 00:08:34.716 A:middle
Next, we have a couple helper

00:08:34.716 --> 00:08:36.035 A:middle
functions that help us draw

00:08:36.035 --> 00:08:37.566 A:middle
these bounding boxes on screen

00:08:37.676 --> 00:08:39.666 A:middle
based on these recognized object

00:08:39.666 --> 00:08:40.346 A:middle
observations.

00:08:40.936 --> 00:08:43.145 A:middle
We have a first function that

00:08:43.145 --> 00:08:44.636 A:middle
matched the bounds you get from

00:08:44.636 --> 00:08:46.316 A:middle
each recognized object

00:08:46.316 --> 00:08:47.826 A:middle
observation, which come in

00:08:47.966 --> 00:08:50.186 A:middle
normalized coordinates based on

00:08:50.186 --> 00:08:51.656 A:middle
the input image you provide to

00:08:51.656 --> 00:08:53.936 A:middle
Vision, so that function maps

00:08:54.006 --> 00:08:55.316 A:middle
those back to our view

00:08:55.316 --> 00:08:56.496 A:middle
controller's views coordinate

00:08:56.496 --> 00:08:57.366 A:middle
system so that we can

00:08:57.366 --> 00:08:58.546 A:middle
appropriately draw them on

00:08:58.606 --> 00:09:00.606 A:middle
screen, overlaying them on top

00:08:58.606 --> 00:09:00.606 A:middle
screen, overlaying them on top

00:09:00.606 --> 00:09:01.466 A:middle
of the actual objects.

00:09:03.026 --> 00:09:04.376 A:middle
Next we have a helper function

00:09:04.376 --> 00:09:06.836 A:middle
that creates our beautiful

00:09:07.106 --> 00:09:08.416 A:middle
rounded rectangles that we

00:09:08.416 --> 00:09:10.326 A:middle
display on screen, which is a

00:09:10.396 --> 00:09:13.276 A:middle
CALayer, and we add that CALayer

00:09:13.276 --> 00:09:15.256 A:middle
to an overlay layer to be

00:09:15.256 --> 00:09:15.986 A:middle
rendered on screen.

00:09:16.656 --> 00:09:17.886 A:middle
All this code is available in

00:09:17.886 --> 00:09:19.276 A:middle
the sample app associated with

00:09:19.276 --> 00:09:20.536 A:middle
this session, which I encourage

00:09:20.536 --> 00:09:22.876 A:middle
you to check out.

00:09:23.136 --> 00:09:25.246 A:middle
So this is really promising: our

00:09:25.486 --> 00:09:27.566 A:middle
app is able to count dice using

00:09:27.566 --> 00:09:28.296 A:middle
object detection.

00:09:29.216 --> 00:09:30.716 A:middle
But you may have already

00:09:30.716 --> 00:09:32.686 A:middle
realized or thought about the

00:09:32.686 --> 00:09:34.236 A:middle
fact that games typically don't

00:09:34.236 --> 00:09:35.886 A:middle
rely on the count of dice; they

00:09:35.886 --> 00:09:37.196 A:middle
typically rely on the values

00:09:37.236 --> 00:09:37.866 A:middle
displayed on them.

00:09:38.796 --> 00:09:40.436 A:middle
So we need to take this one step

00:09:40.486 --> 00:09:42.416 A:middle
further and figure out how to

00:09:42.416 --> 00:09:43.706 A:middle
recognize the values displayed

00:09:43.706 --> 00:09:45.586 A:middle
on these dice.

00:09:45.796 --> 00:09:47.166 A:middle
This is ultimately the goal that

00:09:47.166 --> 00:09:49.446 A:middle
we want our app to have: we want

00:09:49.446 --> 00:09:50.376 A:middle
it to be able to tell that the

00:09:50.376 --> 00:09:52.476 A:middle
die on the right side is a 5 and

00:09:52.476 --> 00:09:55.156 A:middle
the one on the left is a 1.

00:09:55.366 --> 00:09:57.166 A:middle
Luckily for us, as Brent

00:09:57.166 --> 00:09:59.476 A:middle
mentioned, object detectors can

00:09:59.576 --> 00:10:01.106 A:middle
not only detect but classify

00:09:59.576 --> 00:10:01.106 A:middle
not only detect but classify

00:10:01.106 --> 00:10:02.626 A:middle
objects, because they're built

00:10:02.626 --> 00:10:04.196 A:middle
to be able to recognize all

00:10:04.196 --> 00:10:05.496 A:middle
sorts of different objects and

00:10:05.496 --> 00:10:05.916 A:middle
images.

00:10:06.666 --> 00:10:09.636 A:middle
So we went ahead and updated all

00:10:09.636 --> 00:10:11.186 A:middle
our training data to actually

00:10:11.186 --> 00:10:12.936 A:middle
consider dice with different

00:10:12.936 --> 00:10:14.376 A:middle
values to be of a different

00:10:14.376 --> 00:10:16.246 A:middle
class, just like you can see on

00:10:16.246 --> 00:10:16.766 A:middle
the screen.

00:10:18.796 --> 00:10:21.136 A:middle
So this sounded really

00:10:21.136 --> 00:10:22.856 A:middle
promising, and so we gave it a

00:10:22.856 --> 00:10:24.246 A:middle
try in our app.

00:10:24.246 --> 00:10:26.286 A:middle
Let's take a look at some of the

00:10:26.286 --> 00:10:27.516 A:middle
examples that we ran into.

00:10:27.566 --> 00:10:30.406 A:middle
In most cases, it worked

00:10:30.446 --> 00:10:31.126 A:middle
perfectly fine.

00:10:31.416 --> 00:10:32.566 A:middle
As you can see in the picture

00:10:32.866 --> 00:10:34.866 A:middle
behind me, our object detector

00:10:34.866 --> 00:10:36.396 A:middle
is able to correctly and

00:10:36.436 --> 00:10:38.036 A:middle
accurately detect and classify

00:10:38.036 --> 00:10:39.026 A:middle
the dice on the left of the

00:10:39.026 --> 00:10:42.446 A:middle
screen; but if we focus in on

00:10:42.446 --> 00:10:44.506 A:middle
the other side, we can see that

00:10:44.506 --> 00:10:45.846 A:middle
our object detector is actually

00:10:45.846 --> 00:10:47.736 A:middle
detecting the 6 and the 4 as one

00:10:47.766 --> 00:10:48.266 A:middle
single die.

00:10:49.816 --> 00:10:50.766 A:middle
And if we think a little bit

00:10:50.766 --> 00:10:52.986 A:middle
about what's happening, it's

00:10:52.986 --> 00:10:54.616 A:middle
clear that the model isn't able

00:10:54.616 --> 00:10:56.476 A:middle
to tell those apart as two

00:10:56.476 --> 00:10:58.986 A:middle
separate dice, and it really

00:10:58.986 --> 00:11:00.246 A:middle
comes down to the fact that the

00:10:58.986 --> 00:11:00.246 A:middle
comes down to the fact that the

00:11:00.246 --> 00:11:01.966 A:middle
4 is being occluded by the one

00:11:01.966 --> 00:11:02.346 A:middle
in front.

00:11:03.646 --> 00:11:05.266 A:middle
So after thinking about this a

00:11:05.266 --> 00:11:06.936 A:middle
little bit, what we realized was

00:11:06.936 --> 00:11:09.356 A:middle
that we really care about the

00:11:09.356 --> 00:11:11.296 A:middle
tops of these dice, and those

00:11:11.296 --> 00:11:12.796 A:middle
are always visible in our frame.

00:11:13.946 --> 00:11:15.916 A:middle
So we went ahead and we helped

00:11:15.916 --> 00:11:17.396 A:middle
our model a little bit.

00:11:17.846 --> 00:11:19.616 A:middle
We updated all our training data

00:11:19.776 --> 00:11:21.436 A:middle
to actually focus in on the tops

00:11:21.436 --> 00:11:21.896 A:middle
of these dice.

00:11:22.566 --> 00:11:24.616 A:middle
So now we're actually training

00:11:24.616 --> 00:11:26.256 A:middle
an object detector, not to

00:11:26.256 --> 00:11:27.996 A:middle
detect dice, but to detect tops

00:11:27.996 --> 00:11:28.316 A:middle
of dice.

00:11:29.406 --> 00:11:30.506 A:middle
So let's take a look at what

00:11:30.506 --> 00:11:31.326 A:middle
happened when we did that.

00:11:31.756 --> 00:11:34.326 A:middle
As you can see, our model was

00:11:34.326 --> 00:11:36.646 A:middle
still able to correctly predict

00:11:36.766 --> 00:11:39.206 A:middle
and classify the same dice as

00:11:39.206 --> 00:11:41.726 A:middle
before, but now it's also able

00:11:41.726 --> 00:11:43.786 A:middle
to correctly detect and identify

00:11:43.786 --> 00:11:44.516 A:middle
the dice on the right.

00:11:47.476 --> 00:11:48.916 A:middle
We wanted to share with you

00:11:48.916 --> 00:11:49.926 A:middle
another anecdote today.

00:11:51.396 --> 00:11:53.396 A:middle
At some point along our journey,

00:11:53.886 --> 00:11:55.946 A:middle
we noticed this behavior, where

00:11:55.946 --> 00:11:57.466 A:middle
our model was actually detecting

00:11:57.726 --> 00:11:58.896 A:middle
the left side of the dice,

00:11:59.046 --> 00:11:59.666 A:middle
consistently.

00:12:01.076 --> 00:12:02.146 A:middle
This was very confusing at

00:12:02.146 --> 00:12:04.096 A:middle
first, but if we actually rotate

00:12:04.096 --> 00:12:05.936 A:middle
this image, we can understand

00:12:06.006 --> 00:12:07.106 A:middle
how the model thought these were

00:12:07.106 --> 00:12:07.616 A:middle
the tops.

00:12:08.496 --> 00:12:09.816 A:middle
This was super easy to realize

00:12:10.056 --> 00:12:10.986 A:middle
as soon as we looked at the

00:12:10.986 --> 00:12:12.356 A:middle
input of our model.

00:12:13.146 --> 00:12:14.486 A:middle
We were simply not handling the

00:12:14.486 --> 00:12:15.966 A:middle
image orientation according to

00:12:15.966 --> 00:12:17.426 A:middle
our device's orientation, which

00:12:17.426 --> 00:12:18.616 A:middle
is a very common problem for

00:12:18.616 --> 00:12:20.266 A:middle
Vision tasks.

00:12:20.266 --> 00:12:21.926 A:middle
So the key lesson here is, if

00:12:21.926 --> 00:12:23.506 A:middle
you notice odd behavior in your

00:12:23.506 --> 00:12:25.046 A:middle
model's output, it doesn't hurt

00:12:25.046 --> 00:12:26.056 A:middle
to take a look at the input.

00:12:26.896 --> 00:12:29.336 A:middle
It may be as simple as rotating

00:12:29.336 --> 00:12:30.466 A:middle
your image based on the

00:12:30.466 --> 00:12:33.276 A:middle
orientation of the device.

00:12:33.446 --> 00:12:34.756 A:middle
So let's see this new model in

00:12:34.796 --> 00:12:35.000 A:middle
action.

00:12:43.696 --> 00:12:45.026 A:middle
So here we have the same app,

00:12:45.686 --> 00:12:47.356 A:middle
but we updated it to have our

00:12:47.546 --> 00:12:49.326 A:middle
model that's able to detect and

00:12:49.356 --> 00:12:51.666 A:middle
classify diced as well.

00:12:51.766 --> 00:12:52.816 A:middle
For simplicity, I'm going to

00:12:52.816 --> 00:12:53.756 A:middle
focus on three dice.

00:12:54.216 --> 00:12:56.286 A:middle
We can see that our model is

00:12:56.716 --> 00:12:58.406 A:middle
predicting 6, 5 and 2.

00:12:59.426 --> 00:12:59.976 A:middle
So let's take a roll.

00:13:02.996 --> 00:13:04.476 A:middle
Four, 6 and 5.

00:13:05.316 --> 00:13:06.566 A:middle
Awesome. This is really

00:13:06.566 --> 00:13:06.936 A:middle
promising.

00:13:07.516 --> 00:13:10.716 A:middle
[ Applause ]

00:13:11.216 --> 00:13:12.076 A:middle
So I want to bring your

00:13:12.076 --> 00:13:13.756 A:middle
attention to a detail here that

00:13:13.806 --> 00:13:14.856 A:middle
I think is very important.

00:13:15.606 --> 00:13:17.296 A:middle
If I move the dice around, you

00:13:17.296 --> 00:13:18.656 A:middle
can see that the list updates.

00:13:19.146 --> 00:13:20.816 A:middle
We're actually displaying the

00:13:20.816 --> 00:13:22.566 A:middle
list of values according to the

00:13:22.566 --> 00:13:24.146 A:middle
order in which the dice are laid

00:13:24.146 --> 00:13:24.786 A:middle
out on the table.

00:13:25.476 --> 00:13:26.916 A:middle
This is a minor design detail,

00:13:27.396 --> 00:13:29.426 A:middle
but it really brings consistency

00:13:29.426 --> 00:13:30.576 A:middle
to the experience, because the

00:13:30.576 --> 00:13:32.166 A:middle
user is seeing these dice laid

00:13:32.166 --> 00:13:33.266 A:middle
out in that fashion on the

00:13:33.266 --> 00:13:33.586 A:middle
table.

00:13:34.126 --> 00:13:36.196 A:middle
So since we're blending the

00:13:36.196 --> 00:13:37.506 A:middle
physical and virtual worlds,

00:13:38.186 --> 00:13:40.976 A:middle
we're actually giving the user a

00:13:42.246 --> 00:13:43.876 A:middle
very consistent display of the

00:13:43.876 --> 00:13:44.406 A:middle
predictions.

00:13:45.536 --> 00:13:46.436 A:middle
There's another thing we need to

00:13:46.436 --> 00:13:48.446 A:middle
figure out: when does a roll

00:13:48.446 --> 00:13:48.696 A:middle
end?

00:13:49.626 --> 00:13:51.466 A:middle
Again, games typically don't

00:13:51.466 --> 00:13:53.936 A:middle
rely on transient states of a

00:13:53.936 --> 00:13:55.516 A:middle
roll; they rely on the result of

00:13:55.516 --> 00:13:55.636 A:middle
a roll.

00:13:55.636 --> 00:13:57.086 A:middle
When you play a game, you roll

00:13:57.086 --> 00:13:58.546 A:middle
some dice, and based on the

00:13:58.546 --> 00:14:00.836 A:middle
result of that, your pawn either

00:13:58.546 --> 00:14:00.836 A:middle
result of that, your pawn either

00:14:00.836 --> 00:14:02.696 A:middle
moves or you make some decision.

00:14:02.776 --> 00:14:04.276 A:middle
In this case, we may want to

00:14:04.366 --> 00:14:05.806 A:middle
animate something or provide

00:14:05.876 --> 00:14:06.996 A:middle
feedback to the user.

00:14:07.276 --> 00:14:08.386 A:middle
And you may have noticed in the

00:14:08.386 --> 00:14:10.036 A:middle
demos that I just showed, I

00:14:10.036 --> 00:14:11.516 A:middle
didn't show the numbers until

00:14:11.516 --> 00:14:12.326 A:middle
the roll had ended.

00:14:13.086 --> 00:14:14.726 A:middle
So how do we do this?

00:14:15.656 --> 00:14:16.736 A:middle
Well, first we need to ask our

00:14:16.736 --> 00:14:18.336 A:middle
self, what do we observe?

00:14:19.906 --> 00:14:21.756 A:middle
In this case, we notice that the

00:14:21.756 --> 00:14:23.816 A:middle
dice stop moving and the values

00:14:23.816 --> 00:14:25.336 A:middle
are stable between different

00:14:25.336 --> 00:14:26.026 A:middle
camera frames.

00:14:27.196 --> 00:14:28.696 A:middle
So can machine learning help us

00:14:28.696 --> 00:14:28.926 A:middle
here?

00:14:29.966 --> 00:14:32.716 A:middle
Perhaps we could build a

00:14:32.716 --> 00:14:34.056 A:middle
sequential model that takes in

00:14:34.096 --> 00:14:36.026 A:middle
frames and decides when the roll

00:14:36.026 --> 00:14:37.636 A:middle
has ended, but we already have a

00:14:37.636 --> 00:14:38.886 A:middle
model that has a really good

00:14:38.886 --> 00:14:40.126 A:middle
understanding of dice on the

00:14:40.126 --> 00:14:40.416 A:middle
table.

00:14:40.816 --> 00:14:42.466 A:middle
So what we really need to do is

00:14:42.466 --> 00:14:43.496 A:middle
interpret the output of our

00:14:43.496 --> 00:14:43.816 A:middle
model.

00:14:46.256 --> 00:14:47.746 A:middle
So let's take a look at how to

00:14:47.746 --> 00:14:50.386 A:middle
do this in code.

00:14:50.586 --> 00:14:51.956 A:middle
Here we have a function that

00:14:51.956 --> 00:14:54.046 A:middle
takes in two lists of object

00:14:54.046 --> 00:14:55.416 A:middle
observations: one from the

00:14:55.416 --> 00:14:56.906 A:middle
current camera frame and one

00:14:56.966 --> 00:14:58.286 A:middle
from the previous camera frame.

00:14:59.336 --> 00:15:00.276 A:middle
So there's a few things we need

00:14:59.336 --> 00:15:00.276 A:middle
So there's a few things we need

00:15:00.276 --> 00:15:01.746 A:middle
to check in order to decide that

00:15:01.776 --> 00:15:02.526 A:middle
the roll has ended.

00:15:03.476 --> 00:15:05.396 A:middle
The first is, do we have as many

00:15:05.396 --> 00:15:06.946 A:middle
dice now as we had before?

00:15:07.996 --> 00:15:10.046 A:middle
If not, maybe one die has

00:15:10.046 --> 00:15:11.206 A:middle
entered the camera frame, so we

00:15:11.206 --> 00:15:12.346 A:middle
now have more than before.

00:15:12.836 --> 00:15:14.226 A:middle
If we have less than before,

00:15:14.536 --> 00:15:15.796 A:middle
maybe one of them is bouncing

00:15:15.796 --> 00:15:17.186 A:middle
around so the detector isn't

00:15:17.186 --> 00:15:18.526 A:middle
picking that up.

00:15:19.216 --> 00:15:21.246 A:middle
So if we don't have as many now

00:15:21.376 --> 00:15:22.986 A:middle
as before, the roll is still

00:15:23.016 --> 00:15:23.336 A:middle
happening.

00:15:23.816 --> 00:15:26.036 A:middle
Next we're going to compare each

00:15:26.036 --> 00:15:27.366 A:middle
of the observations in the

00:15:27.366 --> 00:15:29.586 A:middle
previous prediction and in the

00:15:29.586 --> 00:15:30.136 A:middle
current one.

00:15:31.516 --> 00:15:32.876 A:middle
If the values represented on top

00:15:32.876 --> 00:15:35.606 A:middle
of the dice aren't the same, our

00:15:35.606 --> 00:15:37.306 A:middle
roll has not ended yet.

00:15:38.036 --> 00:15:40.186 A:middle
And we also check that the

00:15:40.186 --> 00:15:41.456 A:middle
bounding boxes overlap between

00:15:41.456 --> 00:15:42.666 A:middle
these predictions by more than

00:15:42.666 --> 00:15:43.366 A:middle
85%.

00:15:44.296 --> 00:15:45.576 A:middle
If the bounding boxes between

00:15:45.576 --> 00:15:46.776 A:middle
the prediction we're looking at

00:15:46.776 --> 00:15:48.036 A:middle
and the one we're comparing it

00:15:48.036 --> 00:15:49.736 A:middle
with don't overlap, either we're

00:15:49.736 --> 00:15:50.666 A:middle
looking at two completely

00:15:50.666 --> 00:15:54.086 A:middle
different dice, or it's the same

00:15:54.086 --> 00:15:55.036 A:middle
one that has moved by a

00:15:55.096 --> 00:15:55.846 A:middle
significant amount.

00:15:57.106 --> 00:15:59.726 A:middle
Finally, if we have as many

00:15:59.726 --> 00:16:01.306 A:middle
matches now as we have dice on

00:15:59.726 --> 00:16:01.306 A:middle
matches now as we have dice on

00:16:01.306 --> 00:16:02.956 A:middle
the table, the roll has ended.

00:16:03.466 --> 00:16:07.966 A:middle
So now that our app can find,

00:16:08.126 --> 00:16:11.156 A:middle
count, recognize dice on a table

00:16:11.196 --> 00:16:13.516 A:middle
and figuring out the end of a

00:16:13.516 --> 00:16:15.486 A:middle
roll, we have a foundation for

00:16:15.756 --> 00:16:16.576 A:middle
building something more.

00:16:17.206 --> 00:16:18.246 A:middle
And it's time to talk about the

00:16:18.246 --> 00:16:19.186 A:middle
next steps of our journey.

00:16:19.976 --> 00:16:21.536 A:middle
To do that, I'd like to welcome

00:16:21.536 --> 00:16:22.516 A:middle
Brent back up to the stage.

00:16:23.516 --> 00:16:26.036 A:middle
[ Applause ]

00:16:26.536 --> 00:16:27.036 A:middle
&gt;&gt; Thank you, Scott.

00:16:29.406 --> 00:16:30.456 A:middle
All right.

00:16:30.456 --> 00:16:33.436 A:middle
As Scott said, our app can now

00:16:33.436 --> 00:16:34.816 A:middle
recognize dice on the table.

00:16:35.906 --> 00:16:36.836 A:middle
The next thing we need to look

00:16:36.836 --> 00:16:39.076 A:middle
at is, how do we handle user

00:16:39.076 --> 00:16:39.426 A:middle
input?

00:16:39.426 --> 00:16:42.706 A:middle
We know that our users are going

00:16:42.706 --> 00:16:44.016 A:middle
to be entering numbers into our

00:16:44.016 --> 00:16:45.046 A:middle
app, because we're practicing

00:16:45.046 --> 00:16:45.776 A:middle
math skills.

00:16:45.846 --> 00:16:48.716 A:middle
And we could've just put a large

00:16:48.716 --> 00:16:50.146 A:middle
number pad up on the screen and

00:16:50.146 --> 00:16:51.386 A:middle
have them tap in the numbers,

00:16:51.716 --> 00:16:53.816 A:middle
but we wanted to facilitate a

00:16:53.816 --> 00:16:55.656 A:middle
more natural interaction with

00:16:55.656 --> 00:16:55.896 A:middle
the app.

00:16:56.146 --> 00:16:58.226 A:middle
And remember: we're working with

00:16:58.226 --> 00:17:00.116 A:middle
children here, and children are

00:16:58.226 --> 00:17:00.116 A:middle
children here, and children are

00:17:00.116 --> 00:17:01.386 A:middle
also practicing writing their

00:17:01.386 --> 00:17:01.936 A:middle
numbers.

00:17:02.596 --> 00:17:04.846 A:middle
So we thought, why not just let

00:17:04.846 --> 00:17:06.435 A:middle
them draw directly on the

00:17:06.435 --> 00:17:06.856 A:middle
screen?

00:17:06.856 --> 00:17:10.516 A:middle
Well, to do this, we're going to

00:17:10.516 --> 00:17:11.256 A:middle
need our app to be able to

00:17:11.256 --> 00:17:12.806 A:middle
recognize handwritten digits.

00:17:13.976 --> 00:17:15.506 A:middle
Fortunately, machine learning is

00:17:15.506 --> 00:17:16.695 A:middle
already doing a very good job at

00:17:16.695 --> 00:17:18.786 A:middle
solving this problem; in fact,

00:17:19.106 --> 00:17:20.236 A:middle
there's an entire dataset

00:17:20.236 --> 00:17:22.156 A:middle
available to let you train your

00:17:22.156 --> 00:17:23.205 A:middle
own models to recognize

00:17:23.266 --> 00:17:24.026 A:middle
handwritten digits.

00:17:24.026 --> 00:17:25.086 A:middle
It's called MNIST.

00:17:26.396 --> 00:17:28.185 A:middle
Well, we did that, and we put

00:17:28.185 --> 00:17:29.726 A:middle
that model on our new Core ML

00:17:29.726 --> 00:17:30.406 A:middle
Models page.

00:17:31.576 --> 00:17:33.346 A:middle
So let's take a look in code at

00:17:33.346 --> 00:17:34.436 A:middle
how we'd use this model.

00:17:35.336 --> 00:17:36.396 A:middle
We're going to use Vision and

00:17:36.396 --> 00:17:37.076 A:middle
PencilKit here.

00:17:37.676 --> 00:17:40.696 A:middle
We set up Vision to use our Core

00:17:40.696 --> 00:17:42.226 A:middle
ML model; in this case,

00:17:42.226 --> 00:17:43.066 A:middle
MNISTClassifier.

00:17:43.536 --> 00:17:47.756 A:middle
Next, we get our image from the

00:17:47.756 --> 00:17:48.796 A:middle
PencilKit canvas view.

00:17:48.966 --> 00:17:52.876 A:middle
After that, we set up our Vision

00:17:52.876 --> 00:17:54.436 A:middle
request handler to use that

00:17:54.436 --> 00:17:54.906 A:middle
image.

00:17:56.356 --> 00:17:59.286 A:middle
Then, we perform the request and

00:17:59.286 --> 00:18:00.076 A:middle
we get the results.

00:17:59.286 --> 00:18:00.076 A:middle
we get the results.

00:18:00.076 --> 00:18:00.976 A:middle
It's as easy as that.

00:18:03.576 --> 00:18:04.956 A:middle
So we integrated this into our

00:18:04.956 --> 00:18:07.916 A:middle
model, and it started working

00:18:08.076 --> 00:18:08.616 A:middle
pretty well.

00:18:08.616 --> 00:18:10.716 A:middle
We were recognizing quite a few

00:18:10.716 --> 00:18:11.596 A:middle
handwritten digits.

00:18:14.276 --> 00:18:15.976 A:middle
But as we started drawing some

00:18:15.976 --> 00:18:17.506 A:middle
larger digits, we noticed

00:18:17.506 --> 00:18:19.856 A:middle
something interesting: our model

00:18:19.856 --> 00:18:20.766 A:middle
was sometimes getting the

00:18:20.766 --> 00:18:21.906 A:middle
predictions incorrect.

00:18:22.696 --> 00:18:24.566 A:middle
So what's happening?

00:18:24.946 --> 00:18:27.646 A:middle
Well, to understand, we need to

00:18:27.646 --> 00:18:30.236 A:middle
see what image is being input to

00:18:30.236 --> 00:18:30.706 A:middle
our model.

00:18:30.706 --> 00:18:33.186 A:middle
And we can do that in Xcode.

00:18:34.286 --> 00:18:36.626 A:middle
So we set a break point where we

00:18:36.626 --> 00:18:38.096 A:middle
get the image from PencilKit,

00:18:38.096 --> 00:18:40.886 A:middle
and we use Xcode's quick view to

00:18:41.206 --> 00:18:42.406 A:middle
actually look at what that image

00:18:42.406 --> 00:18:42.826 A:middle
is.

00:18:42.956 --> 00:18:44.996 A:middle
And when we did, we saw

00:18:44.996 --> 00:18:47.456 A:middle
something interesting: our 7s

00:18:47.456 --> 00:18:49.766 A:middle
from the example are not looking

00:18:49.766 --> 00:18:51.126 A:middle
like 7s to the model.

00:18:51.786 --> 00:18:52.956 A:middle
They're looking a lot more like

00:18:52.956 --> 00:18:53.446 A:middle
1s.

00:18:54.006 --> 00:18:56.396 A:middle
So what's happening here?

00:18:56.396 --> 00:19:00.066 A:middle
We need to think about what the

00:18:56.396 --> 00:19:00.066 A:middle
We need to think about what the

00:19:00.066 --> 00:19:01.506 A:middle
model's expecting for an input.

00:19:02.956 --> 00:19:05.506 A:middle
This model is expecting a 28 by

00:19:05.506 --> 00:19:08.796 A:middle
28 pixel image, but the image

00:19:08.796 --> 00:19:10.156 A:middle
that we get drawn on the screen

00:19:10.156 --> 00:19:11.846 A:middle
is much bigger than that.

00:19:13.096 --> 00:19:14.406 A:middle
So to get the image in the right

00:19:14.456 --> 00:19:15.836 A:middle
format, we have to downscale it.

00:19:16.656 --> 00:19:18.716 A:middle
But as we downscaled it, we lost

00:19:18.716 --> 00:19:20.026 A:middle
information about the strokes

00:19:20.026 --> 00:19:20.836 A:middle
that were being drawn on the

00:19:20.836 --> 00:19:23.006 A:middle
screen, and our 7s started

00:19:23.006 --> 00:19:24.316 A:middle
looking a lot more like 1s.

00:19:24.716 --> 00:19:28.376 A:middle
Once we knew that, the fix was

00:19:28.406 --> 00:19:29.786 A:middle
pretty easy: we just needed to

00:19:29.786 --> 00:19:31.016 A:middle
have a thicker stroke on the

00:19:31.016 --> 00:19:31.476 A:middle
screen.

00:19:31.556 --> 00:19:35.046 A:middle
And when we did that, after we

00:19:35.046 --> 00:19:37.006 A:middle
downscaled, our images going to

00:19:37.006 --> 00:19:38.806 A:middle
the model looked a lot more like

00:19:38.806 --> 00:19:39.776 A:middle
what was being drawn on the

00:19:39.776 --> 00:19:41.766 A:middle
screen, and the model started

00:19:41.766 --> 00:19:43.446 A:middle
getting the predictions correct.

00:19:44.836 --> 00:19:46.386 A:middle
PencilKit makes this really

00:19:46.386 --> 00:19:46.616 A:middle
easy.

00:19:47.786 --> 00:19:49.746 A:middle
Here we have allowsFingerDrawing

00:19:49.746 --> 00:19:51.436 A:middle
set to true, since we're drawing

00:19:51.436 --> 00:19:52.726 A:middle
on the screen with our fingers;

00:19:52.856 --> 00:19:56.826 A:middle
and then, we set the tool to be

00:19:56.906 --> 00:19:57.556 A:middle
something like a marker with a

00:19:57.556 --> 00:19:57.976 A:middle
thicker stroke.

00:20:01.356 --> 00:20:01.976 A:middle
All right.

00:20:01.976 --> 00:20:04.416 A:middle
Our model is now predicting

00:20:05.426 --> 00:20:07.706 A:middle
single digits really well, but

00:20:08.396 --> 00:20:09.906 A:middle
we have another couple

00:20:09.906 --> 00:20:10.536 A:middle
challenges.

00:20:11.396 --> 00:20:13.766 A:middle
Some digits are written with

00:20:13.766 --> 00:20:14.976 A:middle
multiple strokes.

00:20:15.506 --> 00:20:19.096 A:middle
Our model takes a static image

00:20:19.176 --> 00:20:20.796 A:middle
of a digit, not stroke

00:20:20.796 --> 00:20:21.926 A:middle
information about that digit.

00:20:23.016 --> 00:20:24.466 A:middle
So how do we know when to take

00:20:24.766 --> 00:20:26.126 A:middle
what's being drawn on the screen

00:20:26.196 --> 00:20:28.416 A:middle
and pass it to our model to get

00:20:29.126 --> 00:20:30.276 A:middle
a prediction?

00:20:30.276 --> 00:20:33.816 A:middle
Additionally, since we're adding

00:20:33.816 --> 00:20:35.246 A:middle
dice or possibly multiplying

00:20:35.246 --> 00:20:36.576 A:middle
dice, we may be working with

00:20:36.576 --> 00:20:37.566 A:middle
numbers that have multiple

00:20:37.566 --> 00:20:39.896 A:middle
digits, and our model is only

00:20:39.896 --> 00:20:41.116 A:middle
trained to recognize single

00:20:41.116 --> 00:20:43.236 A:middle
digits, not multiple digits.

00:20:44.096 --> 00:20:45.726 A:middle
So how do we handle that?

00:20:46.496 --> 00:20:47.586 A:middle
We could've used machine

00:20:47.586 --> 00:20:48.606 A:middle
learning to solve these

00:20:48.606 --> 00:20:48.956 A:middle
problems.

00:20:48.956 --> 00:20:50.456 A:middle
We could've trained a model to

00:20:50.456 --> 00:20:51.796 A:middle
recognize stroke information

00:20:51.796 --> 00:20:54.156 A:middle
about digits, or we could've

00:20:54.156 --> 00:20:55.686 A:middle
trained a model to recognize

00:20:55.686 --> 00:20:56.936 A:middle
numbers with multiple digits,

00:20:56.986 --> 00:20:58.826 A:middle
but we already know a lot of

00:20:58.826 --> 00:21:00.086 A:middle
information about what's being

00:20:58.826 --> 00:21:00.086 A:middle
information about what's being

00:21:00.086 --> 00:21:00.876 A:middle
drawn on the screen.

00:21:01.386 --> 00:21:03.236 A:middle
So instead, we decided to solve

00:21:03.236 --> 00:21:04.576 A:middle
this problem programmatically,

00:21:04.876 --> 00:21:05.896 A:middle
and I'll show you how.

00:21:06.426 --> 00:21:08.676 A:middle
Let's take this example.

00:21:09.736 --> 00:21:11.116 A:middle
Someone draws the first stroke

00:21:11.116 --> 00:21:12.426 A:middle
of a 1 on the screen.

00:21:12.426 --> 00:21:15.406 A:middle
We take that, we pass it as an

00:21:15.406 --> 00:21:16.626 A:middle
image to our model, and we get a

00:21:16.626 --> 00:21:17.796 A:middle
prediction, and it's a 1.

00:21:19.246 --> 00:21:20.766 A:middle
Next, they draw the second

00:21:20.766 --> 00:21:23.766 A:middle
stroke of a 1, the base.

00:21:23.966 --> 00:21:25.616 A:middle
We look to see if any of that

00:21:25.616 --> 00:21:27.676 A:middle
stroke is overlapping any of the

00:21:27.676 --> 00:21:28.216 A:middle
first stroke.

00:21:29.086 --> 00:21:30.836 A:middle
Since it is, we know that it's

00:21:30.836 --> 00:21:32.976 A:middle
the same number, so we get rid

00:21:32.976 --> 00:21:34.716 A:middle
of the first prediction, we

00:21:34.716 --> 00:21:35.916 A:middle
combine the first stroke with

00:21:35.916 --> 00:21:37.756 A:middle
the second stroke into one

00:21:37.756 --> 00:21:39.296 A:middle
image, and we pass that entire

00:21:39.296 --> 00:21:40.026 A:middle
image to the model.

00:21:40.136 --> 00:21:41.916 A:middle
And that gets predicted to be a

00:21:41.916 --> 00:21:42.156 A:middle
1.

00:21:42.696 --> 00:21:45.536 A:middle
Next, the user draws another

00:21:45.536 --> 00:21:46.326 A:middle
stroke on the screen.

00:21:47.546 --> 00:21:49.176 A:middle
We look at that third stroke and

00:21:49.176 --> 00:21:51.926 A:middle
see if any of it overlaps either

00:21:51.926 --> 00:21:52.876 A:middle
of the first two strokes.

00:21:53.746 --> 00:21:55.306 A:middle
Since it doesn't, we know that

00:21:55.306 --> 00:21:56.906 A:middle
it's a separate number, so we

00:21:56.906 --> 00:21:58.226 A:middle
pass it separately to the model,

00:21:58.226 --> 00:22:02.356 A:middle
and it gets predicted to be a 2.

00:21:58.226 --> 00:22:02.356 A:middle
and it gets predicted to be a 2.

00:22:02.596 --> 00:22:03.516 A:middle
Now I'd like to invite Scott

00:22:03.516 --> 00:22:05.756 A:middle
back up to show you this in the

00:22:05.826 --> 00:22:06.126 A:middle
app.

00:22:06.126 --> 00:22:06.416 A:middle
Scott?

00:22:07.516 --> 00:22:11.416 A:middle
[ Applause ]

00:22:11.916 --> 00:22:12.316 A:middle
&gt;&gt; Thanks, Brent.

00:22:13.136 --> 00:22:15.166 A:middle
We now have an updated app that

00:22:15.266 --> 00:22:16.876 A:middle
still has our object detector

00:22:16.876 --> 00:22:18.316 A:middle
that's able to detect and

00:22:18.536 --> 00:22:20.716 A:middle
classify dice and their values,

00:22:21.136 --> 00:22:22.536 A:middle
but we've also added the ability

00:22:22.606 --> 00:22:23.856 A:middle
to draw input just like Brent

00:22:23.856 --> 00:22:24.486 A:middle
discussed with you.

00:22:25.716 --> 00:22:27.576 A:middle
So I think it's time to do some

00:22:27.576 --> 00:22:27.726 A:middle
math.

00:22:30.276 --> 00:22:31.796 A:middle
Here, the user has the option to

00:22:31.796 --> 00:22:33.426 A:middle
either add the values displayed

00:22:33.426 --> 00:22:34.986 A:middle
on the dice or multiply them.

00:22:35.306 --> 00:22:36.726 A:middle
And so to keep things simple,

00:22:36.726 --> 00:22:37.406 A:middle
I'm going to start with

00:22:37.406 --> 00:22:37.816 A:middle
addition.

00:22:38.426 --> 00:22:40.066 A:middle
So let's see how input handling

00:22:40.066 --> 00:22:40.266 A:middle
works.

00:22:44.896 --> 00:22:45.036 A:middle
Yes.

00:22:46.516 --> 00:22:50.626 A:middle
[ Applause ]

00:22:51.126 --> 00:22:53.516 A:middle
So if we multiply these values,

00:22:53.516 --> 00:22:55.036 A:middle
I'm pretty sure we get 24.

00:22:56.036 --> 00:22:56.876 A:middle
Now, that's an interesting

00:22:56.876 --> 00:22:57.316 A:middle
number.

00:22:57.826 --> 00:22:58.666 A:middle
I want you to pay close

00:22:58.666 --> 00:23:00.146 A:middle
attention to what happens when I

00:22:58.666 --> 00:23:00.146 A:middle
attention to what happens when I

00:23:00.146 --> 00:23:01.226 A:middle
draw the 4 on screen.

00:23:02.756 --> 00:23:04.236 A:middle
If you think about a 4 that's

00:23:04.236 --> 00:23:06.076 A:middle
drawn with two strokes, our

00:23:06.076 --> 00:23:07.086 A:middle
model's going to have a pretty

00:23:07.086 --> 00:23:08.336 A:middle
hard time figuring out that's a

00:23:08.456 --> 00:23:10.046 A:middle
4 when it only sees the first

00:23:10.046 --> 00:23:11.746 A:middle
stroke, so it may predict some

00:23:11.746 --> 00:23:13.396 A:middle
other digit until I draw the

00:23:13.396 --> 00:23:13.966 A:middle
second stroke.

00:23:15.066 --> 00:23:15.626 A:middle
Let's have a look.

00:23:21.276 --> 00:23:22.646 A:middle
Did you notice that the first

00:23:22.646 --> 00:23:24.046 A:middle
stroke of my 4 was predicted as

00:23:24.046 --> 00:23:25.676 A:middle
a 1, but as soon as I had the

00:23:25.726 --> 00:23:27.176 A:middle
second stroke, that was a 4?

00:23:27.946 --> 00:23:30.646 A:middle
There's one other answer that is

00:23:30.716 --> 00:23:33.026 A:middle
always correct, and I just want

00:23:33.026 --> 00:23:34.376 A:middle
to show you more 4s, so let's

00:23:34.546 --> 00:23:34.746 A:middle
try it.

00:23:40.426 --> 00:23:43.846 A:middle
Cool. So our app can recognize

00:23:43.846 --> 00:23:45.316 A:middle
dice on the table, understand a

00:23:45.316 --> 00:23:47.576 A:middle
roll, it can check our math, we

00:23:47.576 --> 00:23:50.806 A:middle
can input that using drawing to

00:23:50.996 --> 00:23:52.716 A:middle
draw the digits on screen, but

00:23:52.716 --> 00:23:53.896 A:middle
we're talking about blending the

00:23:53.896 --> 00:23:55.246 A:middle
physical and virtual worlds

00:23:55.246 --> 00:23:56.846 A:middle
together, so we thought it would

00:23:56.846 --> 00:23:58.526 A:middle
be a lot of fun and also very

00:23:58.526 --> 00:24:01.036 A:middle
interactive if the kids playing

00:23:58.526 --> 00:24:01.036 A:middle
interactive if the kids playing

00:24:01.036 --> 00:24:02.606 A:middle
with our game could input their

00:24:02.606 --> 00:24:04.116 A:middle
answers in the form of voice.

00:24:04.786 --> 00:24:07.766 A:middle
So let's take a look at that.

00:24:07.766 --> 00:24:09.416 A:middle
Again, I'm going to add or

00:24:09.416 --> 00:24:10.756 A:middle
multiply these two together and

00:24:10.756 --> 00:24:11.516 A:middle
get 24.

00:24:11.926 --> 00:24:13.646 A:middle
And let's do that using speech.

00:24:14.906 --> 00:24:16.096 A:middle
Twenty-four.

00:24:17.616 --> 00:24:18.466 A:middle
Cool.

00:24:21.276 --> 00:24:22.686 A:middle
This is super easy to do using

00:24:22.686 --> 00:24:23.396 A:middle
the speech framework.

00:24:23.966 --> 00:24:29.836 A:middle
And new this year in speech, we

00:24:29.836 --> 00:24:32.166 A:middle
have offline speech recognition.

00:24:33.096 --> 00:24:34.406 A:middle
This means that speech

00:24:34.406 --> 00:24:35.756 A:middle
recognition can work in your app

00:24:36.126 --> 00:24:37.566 A:middle
even when your device is not

00:24:37.566 --> 00:24:38.516 A:middle
connected to the internet.

00:24:39.566 --> 00:24:41.586 A:middle
And if you really want your

00:24:41.586 --> 00:24:43.746 A:middle
user's data to remain on their

00:24:43.746 --> 00:24:45.696 A:middle
device, you can actually require

00:24:45.696 --> 00:24:47.236 A:middle
speech recognition to happen on

00:24:47.236 --> 00:24:48.226 A:middle
device by setting

00:24:48.506 --> 00:24:50.026 A:middle
requiresOnDeviceRecognition to

00:24:50.026 --> 00:24:50.946 A:middle
true on your speech recognizer.

00:24:54.406 --> 00:24:56.326 A:middle
So now our app can understand a

00:24:56.326 --> 00:24:58.206 A:middle
dice roll and handle input in

00:24:58.206 --> 00:25:00.716 A:middle
various different ways, but we

00:24:58.206 --> 00:25:00.716 A:middle
various different ways, but we

00:25:00.716 --> 00:25:02.706 A:middle
need to move on with our journey

00:25:02.796 --> 00:25:04.856 A:middle
and finish this up.

00:25:05.116 --> 00:25:06.206 A:middle
So I'd like to welcome Brent

00:25:06.206 --> 00:25:06.956 A:middle
back up to the stage.

00:25:07.516 --> 00:25:10.536 A:middle
[ Applause ]

00:25:11.036 --> 00:25:11.546 A:middle
&gt;&gt; Thank you, Scott.

00:25:17.576 --> 00:25:21.566 A:middle
As Scott mentioned, we have our

00:25:21.566 --> 00:25:24.616 A:middle
app recognizing dice, and we

00:25:24.616 --> 00:25:26.696 A:middle
know how to handle user input.

00:25:27.366 --> 00:25:29.156 A:middle
But we said this was going to be

00:25:29.156 --> 00:25:29.896 A:middle
a game, right?

00:25:30.626 --> 00:25:34.026 A:middle
So let's make it that.

00:25:34.026 --> 00:25:36.066 A:middle
Next we're going to integrate in

00:25:36.066 --> 00:25:38.196 A:middle
ARKit and really finalize the

00:25:38.196 --> 00:25:39.116 A:middle
whole experience.

00:25:39.666 --> 00:25:45.266 A:middle
Of course, any game needs rules,

00:25:45.546 --> 00:25:48.566 A:middle
so let's go over those first.

00:25:50.416 --> 00:25:52.706 A:middle
Our game is played on a circular

00:25:52.706 --> 00:25:54.516 A:middle
board with nine sections.

00:25:55.206 --> 00:25:58.026 A:middle
Each player starts on section

00:25:58.026 --> 00:26:00.606 A:middle
one, and the goal is to move

00:25:58.026 --> 00:26:00.606 A:middle
one, and the goal is to move

00:26:00.606 --> 00:26:02.486 A:middle
clockwise around the board and

00:26:02.486 --> 00:26:04.666 A:middle
land directly on section nine.

00:26:05.286 --> 00:26:09.536 A:middle
A roll that's too small, and you

00:26:09.536 --> 00:26:11.226 A:middle
don't go far enough.

00:26:12.656 --> 00:26:14.556 A:middle
A roll that's too large, and

00:26:14.556 --> 00:26:16.396 A:middle
you're going to overshoot your

00:26:18.596 --> 00:26:18.706 A:middle
goal.

00:26:18.906 --> 00:26:20.256 A:middle
During each player's turn, they

00:26:20.256 --> 00:26:22.616 A:middle
roll the dice, and they have two

00:26:22.616 --> 00:26:25.496 A:middle
options: they can take the sum

00:26:25.496 --> 00:26:27.516 A:middle
of that dice and move that

00:26:27.516 --> 00:26:28.836 A:middle
number in a clockwise direction,

00:26:29.666 --> 00:26:30.856 A:middle
or they can take the difference

00:26:30.856 --> 00:26:33.006 A:middle
of the dice and move that number

00:26:33.046 --> 00:26:33.926 A:middle
in a clockwise direction.

00:26:35.166 --> 00:26:38.426 A:middle
So Scott, you up for a game?

00:26:39.516 --> 00:26:43.500 A:middle
[ Applause ]

00:26:50.356 --> 00:26:51.496 A:middle
&gt;&gt; So we've now integrated our

00:26:51.496 --> 00:26:53.766 A:middle
virtual board into our ARKit

00:26:53.806 --> 00:26:56.246 A:middle
game that's also using Core ML

00:26:56.576 --> 00:26:57.366 A:middle
to recognize dice.

00:26:58.036 --> 00:26:59.366 A:middle
How about you start off, Brent?

00:26:59.666 --> 00:27:00.126 A:middle
&gt;&gt; Sounds good.

00:26:59.666 --> 00:27:00.126 A:middle
&gt;&gt; Sounds good.

00:27:01.306 --> 00:27:02.456 A:middle
All right.

00:27:02.976 --> 00:27:06.356 A:middle
The 5 -- I've got a 5 and a 2.

00:27:06.356 --> 00:27:07.046 A:middle
All right.

00:27:07.046 --> 00:27:09.976 A:middle
I think I'm going to add those.

00:27:15.376 --> 00:27:15.686 A:middle
&gt;&gt; All right.

00:27:16.446 --> 00:27:17.656 A:middle
Ooh, you got really close.

00:27:17.726 --> 00:27:17.976 A:middle
&gt;&gt; Close.

00:27:22.056 --> 00:27:24.996 A:middle
&gt;&gt; So we got 6 and 1; I can

00:27:24.996 --> 00:27:27.116 A:middle
either subtract these and get 5

00:27:27.186 --> 00:27:29.436 A:middle
or add them and join Brent on

00:27:29.436 --> 00:27:30.966 A:middle
the 8 slot, so let's add these.

00:27:37.796 --> 00:27:38.276 A:middle
&gt;&gt; All right.

00:27:38.516 --> 00:27:41.236 A:middle
I don't think I'm going to be

00:27:41.236 --> 00:27:42.626 A:middle
able to get a 1.

00:27:42.626 --> 00:27:42.806 A:middle
Let's see.

00:27:47.776 --> 00:27:49.316 A:middle
I think I'll subtract this time.

00:27:49.316 --> 00:27:49.826 A:middle
Let me do a 2.

00:27:59.676 --> 00:28:01.446 A:middle
&gt;&gt; Okay. So I got 6 and 1 again.

00:27:59.676 --> 00:28:01.446 A:middle
&gt;&gt; Okay. So I got 6 and 1 again.

00:28:01.686 --> 00:28:02.746 A:middle
This time I'm going to change it

00:28:02.746 --> 00:28:04.546 A:middle
up and do a 5.

00:28:05.506 --> 00:28:07.746 A:middle
And Brent really thinks -- yeah.

00:28:08.866 --> 00:28:10.066 A:middle
Brent thinks I draw funny 5s.

00:28:10.926 --> 00:28:13.946 A:middle
&gt;&gt; You know, this game could

00:28:13.946 --> 00:28:16.496 A:middle
probably go on pretty long, but

00:28:16.986 --> 00:28:18.876 A:middle
I think Scott might've mentioned

00:28:18.876 --> 00:28:20.786 A:middle
something about a number always

00:28:20.786 --> 00:28:23.366 A:middle
being correct, so let's see if

00:28:23.366 --> 00:28:23.926 A:middle
this works in our game.

00:28:28.326 --> 00:28:29.646 A:middle
&gt;&gt; Ah, you found the secret,

00:28:29.646 --> 00:28:29.966 A:middle
Brent.

00:28:30.976 --> 00:28:31.536 A:middle
Good job.

00:28:31.776 --> 00:28:31.976 A:middle
&gt;&gt; Success.

00:28:32.516 --> 00:28:37.500 A:middle
[ Applause ]

00:28:43.626 --> 00:28:44.086 A:middle
All right.

00:28:44.736 --> 00:28:47.466 A:middle
Today we looked at combining

00:28:47.516 --> 00:28:49.686 A:middle
multiple technologies together

00:28:49.806 --> 00:28:51.376 A:middle
to blend our physical and

00:28:51.376 --> 00:28:52.186 A:middle
virtual worlds.

00:28:53.436 --> 00:28:54.686 A:middle
We built an experience that goes

00:28:54.686 --> 00:28:56.566 A:middle
beyond any single technology and

00:28:57.016 --> 00:28:58.646 A:middle
it let us play this fun game in

00:28:58.646 --> 00:28:59.996 A:middle
this enhanced new world.

00:29:01.366 --> 00:29:03.606 A:middle
We used object detection to

00:29:03.606 --> 00:29:07.326 A:middle
recognize dice on the table.

00:29:07.466 --> 00:29:09.476 A:middle
We used image classification to

00:29:09.476 --> 00:29:11.246 A:middle
recognize handwritten digits on

00:29:11.246 --> 00:29:11.706 A:middle
the screen.

00:29:12.916 --> 00:29:14.556 A:middle
We used speech recognition as

00:29:14.556 --> 00:29:15.606 A:middle
another way to interact with our

00:29:15.606 --> 00:29:15.886 A:middle
app.

00:29:16.266 --> 00:29:18.636 A:middle
And we brought in ARKit to

00:29:18.636 --> 00:29:19.976 A:middle
really finalize the whole

00:29:19.976 --> 00:29:20.666 A:middle
experience.

00:29:22.376 --> 00:29:23.996 A:middle
If you'd like more information,

00:29:24.766 --> 00:29:26.856 A:middle
please see our session 228 on

00:29:26.856 --> 00:29:28.616 A:middle
the developer website or come

00:29:28.676 --> 00:29:30.096 A:middle
talk to us in the labs tomorrow.

00:29:30.716 --> 00:29:32.416 A:middle
Thank you, and have a great rest

00:29:32.416 --> 00:29:32.756 A:middle
of the show.

00:29:33.508 --> 00:29:35.508 A:middle
[ Applause ]
