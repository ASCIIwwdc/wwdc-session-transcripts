WEBVTT

00:00:06.360 --> 00:00:11.020
>> Hello, and welcome to part 2 of Delivering
Audio and Video Using Web Standards.

00:00:11.020 --> 00:00:13.370
My name is Jer Noble.

00:00:13.370 --> 00:00:21.070
I'm a Safari and WebKit engineer, and I'm just going to pick
up right where Vicki left off from part 1, specifically,

00:00:21.070 --> 00:00:26.790
last part of the session we covered basic
<video> element playback in your webpage,

00:00:26.790 --> 00:00:31.800
specifically how to add using the video
tag, a <video> element to your site

00:00:31.800 --> 00:00:37.300
and a few JavaScript functions to
control playback of your media.

00:00:37.300 --> 00:00:42.300
And from there, we're going to take all of the things
she talked about, build upon them and add a whole lot

00:00:42.300 --> 00:00:46.400
of more additional functionality to
the <video> element in your webpage.

00:00:46.400 --> 00:00:49.170
So, where we left off?

00:00:49.170 --> 00:00:54.600
Just a quick recap for people who may have missed the last
session, the adding of <video> element to your site is

00:00:54.600 --> 00:00:57.590
as easy as the video tag or the single source attribute.

00:00:57.590 --> 00:01:01.850
With this alone, you get HTML5
video embedded in your webpage.

00:01:01.850 --> 00:01:09.900
But for additional functionality, if you want to let your
browsers choose between the most appropriate video content,

00:01:09.900 --> 00:01:13.260
adding multiple source tags to your
video tag will allow you to do that.

00:01:13.260 --> 00:01:19.130
And finally, controlling the video playback
is as easy as a Play and Pause of it,

00:01:19.130 --> 00:01:21.740
or Play and Pause function on your <video> element.

00:01:21.740 --> 00:01:23.550
So, that's where we left off.

00:01:23.550 --> 00:01:31.490
The last demo was a video with a big Play/Pause button
and, while, that's cool and all, we're going to take all

00:01:31.490 --> 00:01:36.490
of those stuff and pump up to awesome,
the video playback experience.

00:01:36.490 --> 00:01:42.570
So we're going to add or we're going to fill out
the custom JavaScript and HTML and CSS controllers

00:01:42.570 --> 00:01:46.750
so it reproduces most, if not all of the
functionality of the built-in controller.

00:01:46.750 --> 00:01:52.770
Once that's done, we're going to add some
subtitles and closed captions to your video.

00:01:52.770 --> 00:01:59.940
We're going to cover how to add bumper clips to your video
within playback, and we're also going to talk about how

00:01:59.940 --> 00:02:05.250
to take the video from your website
and embed it someone else's website.

00:02:05.250 --> 00:02:09.150
So step 1, so we have a big Play/Pause button.

00:02:09.150 --> 00:02:13.420
Something that exists in the built-in controllers
that you might want to add through JavaScript

00:02:13.420 --> 00:02:18.130
and CSS is a progress meter, so you might
be asking, "What's a progress meter?"

00:02:18.130 --> 00:02:21.670
Well, you have your big Play button,
you have your piece of video.

00:02:21.670 --> 00:02:25.500
The progress meter would be something
like this, that when the user hits Play,

00:02:25.500 --> 00:02:28.620
[background sound] it starts playing
the video and the time continues.

00:02:28.620 --> 00:02:33.230
I know it's really cute, you'll be seeing a lot of it.

00:02:33.230 --> 00:02:40.990
Anyway, so, to implement this JavaScript based
playback meter, you'll need a few pieces of API.

00:02:40.990 --> 00:02:43.010
First of all, there's a timeupdate event.

00:02:43.010 --> 00:02:47.440
Now this is fired occasionally, 4 times
a second or so, during regular playback,

00:02:47.440 --> 00:02:50.270
when you're playing back at a constant rate.

00:02:50.270 --> 00:02:56.950
Also, it gets fired more continuously as the user perhaps
changed the time with the built-in timeline controller.

00:02:56.950 --> 00:03:01.990
Once you catch this timeupdate event, you'll
need to query the currentTime attribute

00:03:01.990 --> 00:03:04.970
to pull the current time out of the video.

00:03:04.970 --> 00:03:10.050
And to calculate a percentage of the way through the
video that your playback has currently progressed,

00:03:10.050 --> 00:03:13.670
it will pull the duration attribute
out of the video as well.

00:03:13.670 --> 00:03:19.580
Now, there's an additional attribute called
startTime that for almost all cases will be zero.

00:03:19.580 --> 00:03:23.420
So for normal playback, you got a
media file on a server somewhere.

00:03:23.420 --> 00:03:27.470
You put it in a <video> element, the startTime will be zero.

00:03:27.470 --> 00:03:33.990
The cases where this is not the case is in HTTP live
streaming, because the startTime is going to change based

00:03:33.990 --> 00:03:37.360
on when the user starts playing their content.

00:03:37.360 --> 00:03:42.960
And as Vicki described in the first session, there's the
durationchange event that fires when the browser notices

00:03:42.960 --> 00:03:45.620
that the duration of the video has changed.

00:03:45.620 --> 00:03:49.790
Again, in most cases, the durationchange
event will only get fired once.

00:03:49.790 --> 00:03:56.040
The cases where it doesn't or it gets fired
mobile times is again, like HTTP live streaming.

00:03:56.040 --> 00:04:00.920
OK, so to implement this in JavaScript, first
we're going to make an updateProgress function.

00:04:00.920 --> 00:04:05.790
We're going to ignore the start time and
assume it 0, and calculate the percentage based

00:04:05.790 --> 00:04:09.300
on dividing the current time of the video by its duration.

00:04:09.300 --> 00:04:15.630
And again, we're going to take the simplest case of
representing the progress meter by stuffing that percentage

00:04:15.630 --> 00:04:18.870
in the style attribute of a div called progressDiv.

00:04:18.870 --> 00:04:23.070
Now this is the most, like again, the simplest
case, but you could represent the current time

00:04:23.070 --> 00:04:25.630
as a string placed anywhere on your website.

00:04:25.630 --> 00:04:31.260
You could do it as a pie chart, a bar
chart, the possibilities are endless here.

00:04:31.260 --> 00:04:37.520
So, we'll catch the timeupdate event from the
<video> element and call updateProgress occasionally.

00:04:37.520 --> 00:04:41.170
And to cover our bases, we'll also
listen to the durationchange event.

00:04:41.170 --> 00:04:47.160
And when that changes, recalculate the
width of the div, and it's simple as that.

00:04:47.160 --> 00:04:49.060
So you have working progress meter.

00:04:49.060 --> 00:04:53.850
Something else that's in the built-in controls that you
might want to add to your custom controls is the way

00:04:53.850 --> 00:04:56.750
of showing how much of the video has loaded.

00:04:56.750 --> 00:05:00.980
In part 1, there was an indeterminate
progress meter spinning,

00:05:00.980 --> 00:05:03.340
but we're going to show you how to add a determinate one.

00:05:03.340 --> 00:05:05.290
So-- but why should you care?

00:05:05.290 --> 00:05:08.670
Again, Vicki kind of covered this in the first part of this.

00:05:08.670 --> 00:05:13.540
But if you don't display "what" ...
to the user the state of their movie,

00:05:13.540 --> 00:05:15.680
whether it's loading or not, what it's doing.

00:05:15.680 --> 00:05:20.110
They might get bored waiting for a video to start playing
if they're on a slow connection and it's a big movie.

00:05:20.110 --> 00:05:25.430
So, you can add an indeterminate state, but
we're going to show you a way of doing a--

00:05:25.430 --> 00:05:28.540
showing how much of the video as a percentage is loaded.

00:05:28.540 --> 00:05:33.330
And again, if you're a good internet citizen and you
have a page full of videos, and you don't want them all

00:05:33.330 --> 00:05:38.780
to start loading at once to-- so that the first one the
user clicks on loads faster, you will have like a Click

00:05:38.780 --> 00:05:42.150
To Play button like we showed you last
time, and it might look something like this.

00:05:42.150 --> 00:05:45.960
User clicks the Click To Play, the movie
starts loading and at some point in the future,

00:05:45.960 --> 00:05:48.020
the user says, "Oh, I can play, awesome!"

00:05:48.020 --> 00:05:50.860
[background sound] and the movie plays, awesome.

00:05:50.860 --> 00:05:56.560
You know, I just can't get enough of that.

00:05:56.560 --> 00:05:57.670
[Laughter] Anyway, OK.

00:05:57.670 --> 00:06:00.560
So, how would you implement this
script to your other script?

00:06:00.560 --> 00:06:04.820
Well, an event that's fired occasionally
by the video element is the progress event.

00:06:04.820 --> 00:06:10.190
It's fired no more often than about 1/3 a second
and no less often than every byte that's loaded.

00:06:10.190 --> 00:06:12.970
Hopefully, you're not getting progress
events for every byte that's loaded.

00:06:12.970 --> 00:06:15.670
It indicates your user is on a very slow connection.

00:06:15.670 --> 00:06:22.000
But you'll catch this event and then query
the buffered attribute of the video element.

00:06:22.000 --> 00:06:27.470
Now the buffered attribute is implemented
in terms of this type called TimeRanges.

00:06:27.470 --> 00:06:30.280
It is a single object even though it's a plural name.

00:06:30.280 --> 00:06:33.260
It is like an array but not quite an array.

00:06:33.260 --> 00:06:39.080
It has a linked attribute and a couple of functions
called start and end that allow you to pull out of

00:06:39.080 --> 00:06:45.260
that TimeRanges object the start and end points
of a range of time that the browser has loaded

00:06:45.260 --> 00:06:48.040
and has a data available for immediate playback.

00:06:48.040 --> 00:06:51.540
Now these ranges could be discontinuous.

00:06:51.540 --> 00:06:56.910
The user could have jumped ahead of the downloading stream
and the user or the browser started downloading a new area

00:06:56.910 --> 00:07:03.250
of the movie, but they'll always be
nonoverlapping and they'll always increase in time.

00:07:03.250 --> 00:07:08.890
You can be guaranteed that the last
item in the timeranges object will be

00:07:08.890 --> 00:07:11.900
after the first item, and every item in between.

00:07:11.900 --> 00:07:18.410
So, to implement this piece of JavaScript, we're
going to have a function called updateLoadState.

00:07:18.410 --> 00:07:20.980
And for our purposes, again the very simple case,

00:07:20.980 --> 00:07:28.770
we just want to know what the maximum allowed time that's
been loaded, and so we'll check to see if there is any area

00:07:28.770 --> 00:07:34.110
of the film that has currently been buffered,
grab the last item, ask it for its end time,

00:07:34.110 --> 00:07:38.390
and use that as the maximum loaded value.

00:07:38.390 --> 00:07:42.400
And just like in the progress example,
we'll calculate a simple percentage

00:07:42.400 --> 00:07:46.930
and set that as the width of a
div somewhere else in our webpage.

00:07:46.930 --> 00:07:52.580
OK, listen for the progress event, and every time the
browser tells us that it's loaded a little bit more

00:07:52.580 --> 00:07:58.030
of the movie, we'll update the load
state of our custom controller.

00:07:58.030 --> 00:08:02.600
OK, so you have a progress meter, you have a load state.

00:08:02.600 --> 00:08:05.270
Something else that's in the built-in
controls that you might want

00:08:05.270 --> 00:08:10.630
to re-implement is a Scrubber a Scrubbing
slider, and why do you need a Scrubber?

00:08:10.630 --> 00:08:15.970
Well if-- like most people, they'll have favorite
parts of your movie and you might want your users

00:08:15.970 --> 00:08:19.260
to jump to any random point in the timeline.

00:08:19.260 --> 00:08:28.650
And as long as your server supports byte range requests, the
browser can immediately pick up where your user requested

00:08:28.650 --> 00:08:33.320
at a current time and start loading times past that.

00:08:34.870 --> 00:08:37.790
So, just like in the progress event, you'll need--

00:08:37.790 --> 00:08:42.280
or the progress meter, you'll need the currentTime
attribute this time to set the current time

00:08:42.280 --> 00:08:46.750
and cause the browser to jump to a specific point.

00:08:46.750 --> 00:08:52.650
There's also the duration attribute which like in the
first example, we'll need to calculate a percentage.

00:08:52.650 --> 00:08:57.660
And there's another attribute called seekable.

00:08:57.660 --> 00:09:03.790
Now, when buffered, it tells you what parts of the
video are currently loaded, but there's no restriction

00:09:03.790 --> 00:09:05.750
on jumping past the end of the loaded state.

00:09:05.750 --> 00:09:12.170
The browser will notice, it will start downloading a new
portion of the movie, except for the seekable attribute.

00:09:12.170 --> 00:09:15.540
For most cases, seekable will define
the entire range of the video.

00:09:15.540 --> 00:09:18.240
There'll be no restrictions on where the user can jump.

00:09:18.240 --> 00:09:23.260
In special cases like HTTP streaming,
this attribute will contain a range--

00:09:23.260 --> 00:09:31.200
or a set of ranges of time which define where
the available data lies in your video content.

00:09:31.200 --> 00:09:36.390
Now-- and when you're live streaming for example,
30 seconds in the future hasn't been filmed yet,

00:09:36.390 --> 00:09:40.780
so there's no way for the user to
jump past like what is considered now.

00:09:40.780 --> 00:09:45.500
And perhaps the user has thrown away all the data from 30
seconds ago and won't let the users scrub back to there.

00:09:45.500 --> 00:09:48.990
In that case, the seekable attribute will
define a very narrow range of time that you want

00:09:48.990 --> 00:09:54.860
to make your slider the min and
maximum amounts on that slider.

00:09:54.860 --> 00:10:01.240
Now, it's reasonably difficult to implement
a slider with straight HTML and CSS.

00:10:01.240 --> 00:10:07.740
However, new in HTML5 is a new type of input
that is of the type range normally rendered

00:10:07.740 --> 00:10:11.130
as like a normal slider from whatever your OS is.

00:10:11.130 --> 00:10:17.230
However, in Safari and WebKit, this input element
is completely styleable through CSS.

00:10:17.230 --> 00:10:22.640
So we're going to use the input range element
to allow the users to control the portion

00:10:22.640 --> 00:10:24.530
of the movie that they're currently playing back.

00:10:24.530 --> 00:10:28.830
So for this element, it takes a minimum and a maximum.

00:10:28.830 --> 00:10:33.530
Because we're working at percentages already,
we're just going to set min to 0 and max to 1

00:10:33.530 --> 00:10:39.230
and use the value attribute of the input element
to extract what the current state of the input is

00:10:39.230 --> 00:10:45.770
and, as the time changes, to shove a new value in
and have the input element reflect that change.

00:10:45.770 --> 00:10:50.000
And as the user is dragging the input slider
around, it will generate these change events

00:10:50.000 --> 00:10:52.260
and that's what we'll use to set the current time.

00:10:52.260 --> 00:10:55.900
So this is what it would look like in JavaScript.

00:10:55.900 --> 00:10:59.050
On the scrubber side, we'll listen for the change event.

00:10:59.050 --> 00:11:02.180
Its value is something between 0 and 1, an easy percentage.

00:11:02.180 --> 00:11:06.330
So we will just multiply it by the duration,
set with the current time, and Bob's your uncle,

00:11:06.330 --> 00:11:10.120
you've got a working slider in your ... in your HTML video.

00:11:10.120 --> 00:11:14.420
And on the-- from the other direction,
as the video's time changes,

00:11:14.420 --> 00:11:18.350
we'll want to occasionally update the
value of the slider with its new position.

00:11:18.350 --> 00:11:23.870
And again, since it's a percentage arranged from 0 to 1,
it's as easy as dividing the current time by the duration

00:11:23.870 --> 00:11:27.930
and setting that to the value of the slider.

00:11:27.930 --> 00:11:30.730
And in order to demonstrate these techniques,

00:11:30.730 --> 00:11:34.880
all of the last 3 I'd like to call Eric
up, and he has got a few demos to show you.

00:11:34.880 --> 00:11:37.340
[ Applause ]

00:11:37.340 --> 00:11:42.860
>> So, we have got our adorable baby here with a controller.

00:11:42.860 --> 00:11:47.380
We're going to be logging the events
over on the right-hand side.

00:11:47.380 --> 00:11:54.510
We click Play, we click Pause,
we see the events coming through.

00:11:54.510 --> 00:11:59.590
You can see the progress indicator here.

00:11:59.590 --> 00:12:03.830
We have got a thumb, we drag it back and forth.

00:12:03.830 --> 00:12:09.540
You can see that we're getting seek events
and timeupdate events just as you expect.

00:12:09.540 --> 00:12:18.690
One more thing that we added just for a little
bit of extra bling, is as we move the mouse off

00:12:18.690 --> 00:12:22.710
of the video, we show and hide the controller.

00:12:22.710 --> 00:12:26.050
And that's as easy because we have CSS.

00:12:26.050 --> 00:12:34.270
That's as easy as setting a couple of properties on the CSS.

00:12:34.270 --> 00:12:42.980
So you can see in the video controls
attribute, we initially have the--

00:12:42.980 --> 00:12:55.240
we've initially set the opacity of the controls to
0, and we've set the Y translate to 100 percent,

00:12:55.240 --> 00:12:59.520
which pushes it off the-- pushes
it off the bottom of the screen.

00:12:59.520 --> 00:13:10.040
And we've also set WebKit transitions
on both opacity and WebKit transform.

00:13:10.040 --> 00:13:20.100
So that when the user hovers the mouse over the player,
when we change the opacity to 1 to make it visible,

00:13:20.100 --> 00:13:29.690
and translate Y to 0 to bring it back up,
that transition will take a half a second.

00:13:29.690 --> 00:13:33.420
So again, we move the mouse over it, it shows.

00:13:33.420 --> 00:13:35.330
We move the mouse off and it hides.

00:13:35.330 --> 00:13:42.990
And it's literally as simple as adding
just that, that little bit of CSS.

00:13:42.990 --> 00:13:45.730
[ Applause ]

00:13:45.730 --> 00:13:46.050
>> Alright.

00:13:46.050 --> 00:13:46.990
Thanks, Eric.

00:13:46.990 --> 00:13:52.600
OK, so we have most of the basic functionality
of the built-in controller now done

00:13:52.600 --> 00:13:54.690
through JavaScript, accessible through CSS.

00:13:54.690 --> 00:13:57.100
Style it however you want.

00:13:57.100 --> 00:14:01.940
For the next step, we're going to push
past what the built-in controller can do

00:14:01.940 --> 00:14:06.380
and add functionality that it never
could in the first place.

00:14:06.380 --> 00:14:09.530
So subtitles, why should you care about subtitles?

00:14:09.530 --> 00:14:15.780
For one reason, perhaps you have Americans with
Disabilities Act requirements that require your video

00:14:15.780 --> 00:14:20.500
and your entire website to be accessible to
users for whom the audio is not very useful.

00:14:20.500 --> 00:14:26.770
So you might need to present closed captions on top of
the video describing what is happening in the scene.

00:14:26.770 --> 00:14:29.430
So that's something called descriptive audio.

00:14:29.430 --> 00:14:35.950
You might also have video content, the audio which isn't
in the same language as your user's native language

00:14:35.950 --> 00:14:40.090
and you want to have translations
appear on top of your video.

00:14:40.090 --> 00:14:46.310
In this case, she doesn't speak any English
[background sound], we'll need to translate.

00:14:46.310 --> 00:14:48.780
That's mama, and mama again.

00:14:50.240 --> 00:14:52.050
OK, so how are we going to do this?

00:14:52.050 --> 00:14:58.420
Well, before we start, I'd like to point out that this is
an active area of development in the "what" working group.

00:14:58.420 --> 00:15:02.990
And they're currently writing the spec that
will define how, in the future, these subtitles

00:15:02.990 --> 00:15:06.810
and its closed captions will be built in to future browsers.

00:15:06.810 --> 00:15:11.960
Now, however, even though this is a future part of
the spec that's not even very well defined right now,

00:15:11.960 --> 00:15:18.950
all of this is perfectly capable with the HTML and video
element as it exists today in Safari and other browsers.

00:15:18.950 --> 00:15:26.750
So to start off, if you have a piece of video content
that already has closed caption tracks built in,

00:15:26.750 --> 00:15:32.720
there are few methods you can use to detect that there
is closed caption tracks and enable them or disable them

00:15:32.720 --> 00:15:35.990
in the video itself, and that's this webkitHasClosedCaptions

00:15:35.990 --> 00:15:40.190
and webkitClosedCaptionsVisible
attributes of the video element.

00:15:40.190 --> 00:15:45.030
Now this allows you to make visible a
single closed caption track in your video.

00:15:45.030 --> 00:15:48.370
And that's great for people who have
existing content with closed captions.

00:15:48.370 --> 00:15:50.660
However, it's not exactly dynamic.

00:15:50.660 --> 00:15:53.730
It allows you to turn on or off
a single closed caption track.

00:15:53.730 --> 00:15:58.300
And if you want to support multiple languages of
closed captions, you will need multiple videos.

00:15:58.300 --> 00:16:03.030
So we're going to show you a technique that will work with
video that does not have anything built in and will work

00:16:03.030 --> 00:16:06.960
for any language you care to insert through this method.

00:16:06.960 --> 00:16:11.850
So meanwhile, we're going to embed
the subtitles directly in the HTML.

00:16:11.850 --> 00:16:14.910
For the purposes of, you know, very
simple demo, this is the quickest way

00:16:14.910 --> 00:16:17.180
to get your subtitles built in to your video content.

00:16:17.180 --> 00:16:20.270
But there is no reason why you have
to embed the subtitles in HTML.

00:16:20.270 --> 00:16:22.130
You could pull them down through JSON.

00:16:22.130 --> 00:16:25.620
You could use XML HTTP requests.

00:16:25.620 --> 00:16:32.760
And as we saw yesterday in the Safari state of the
union, someone from being implemented in pure HTML5,

00:16:32.760 --> 00:16:35.450
a way of doing live translations of selected text,

00:16:35.450 --> 00:16:40.590
there is no reason why you couldn't have translated
the subtitles available completely dynamically

00:16:40.590 --> 00:16:44.440
through an API provided by a language translation service.

00:16:44.440 --> 00:16:47.650
But for our case, we're just going to
embed it in HTML, and we're going to listen

00:16:47.650 --> 00:16:51.330
for the same timeupdate event we
use to track the progress meter.

00:16:51.330 --> 00:16:55.700
And as that event is fired, we'll check the current
time, figure out what subtitle is supposed

00:16:55.700 --> 00:16:59.050
to be visible at that time and mark it as display.

00:16:59.050 --> 00:17:04.120
For a long, long list of subtitles, that might
be something of an expensive proposition.

00:17:04.120 --> 00:17:11.760
So if you have a set of subtitles, you can use the built-in
setTimeout and clearTimeout functions to schedule a subtitle

00:17:11.760 --> 00:17:17.300
to be visible some time in the future and use the built-in
properties of the video element to figure out when

00:17:17.300 --> 00:17:22.040
that subtitle will need to be displayed to the
screen, making things slightly more performing.

00:17:22.040 --> 00:17:24.190
Again for a simple case, we only have a few subtitles,

00:17:24.190 --> 00:17:30.090
so we're just going to calculate the correct
subtitle every time we catch the timeupdate event.

00:17:30.090 --> 00:17:36.560
So here are some basic HTML code, you have a
<video> element, and a few divs that have start

00:17:36.560 --> 00:17:41.290
and end attributes defining when they should be
made visible through the playback of the video.

00:17:41.290 --> 00:17:47.190
In this case, a 1-second subtitle, and then
another 1-second subtitle 1 second later.

00:17:47.190 --> 00:17:50.590
For the CSS part of your HTML code, well by default,

00:17:50.590 --> 00:17:55.820
make these subtitles display absolute
nothing, the bottom center of the screen.

00:17:55.820 --> 00:18:02.570
But again, because this is completely dynamic done in HTML
and CSS, you are not limited to overlaying your video.

00:18:02.570 --> 00:18:06.380
You can have the subtitles appear in
a different part of the same page,

00:18:06.380 --> 00:18:10.190
or even in a pop-up page maybe movable around by the user.

00:18:10.190 --> 00:18:13.060
For the JavaScript portion, we're going
to listen to the timeupdate event.

00:18:13.060 --> 00:18:19.810
And just like in the progress meter example, plot
the current time, the time considered to be now.

00:18:19.810 --> 00:18:24.070
And then iterate through all of
the elements marked as subtitles.

00:18:24.070 --> 00:18:29.560
And for each one of them pull out their start
and their end attributes, compare them to now.

00:18:29.560 --> 00:18:38.320
And when we find a subtitle whose start and end times
{current time}, set the display rule for its CSS style

00:18:38.320 --> 00:18:43.270
to be inherent overwriting the
display none in our CSS style sheet.

00:18:43.270 --> 00:18:47.200
Otherwise, we'll set it back to display
none and that subtitle will hide.

00:18:47.200 --> 00:18:52.250
And to demonstrate this technique, I'd like
to call Eric back up to do another demo.

00:18:52.250 --> 00:18:54.610
[ Applause ]

00:18:54.610 --> 00:18:57.280
>> OK, this time there is not much to show.

00:18:57.280 --> 00:19:03.370
You have seen the code, but let's see it in action.

00:19:03.370 --> 00:19:06.920
We'll start our video playing.

00:19:06.920 --> 00:19:14.440
There she says mama, and she coos at the end.

00:19:14.440 --> 00:19:24.560
Because we're changing the display of these
through the events that are emitted by the element,

00:19:24.560 --> 00:19:30.200
it works the same when we're playing
it as when we drag on the thumb.

00:19:30.200 --> 00:19:36.810
Because the element as you can see from the
events on the side, emits the events so we know

00:19:36.810 --> 00:19:40.760
when to show it and we know when to hide it.

00:19:40.760 --> 00:19:44.700
It makes your coding really simple.

00:19:44.700 --> 00:19:54.520
You just listen for the events to be emitted by
that element and you take action based on that.

00:19:54.520 --> 00:19:55.000
Jer?

00:19:55.000 --> 00:19:57.160
[ Applause ]

00:19:57.160 --> 00:19:57.850
>> Thanks, Eric.

00:19:57.850 --> 00:20:04.600
So, to reiterate, it's an entirely flexible technique
that allows you to do closed captions, subtitles,

00:20:04.600 --> 00:20:10.020
apply styles as you saw on the example, to
make your subtitles look however you like.

00:20:10.020 --> 00:20:12.100
And it works not only for subtitles, this could--

00:20:12.100 --> 00:20:17.030
the same technique could work to cause events
to fire as you progress through the movie.

00:20:17.030 --> 00:20:20.060
Put overlays on top of your video at specific times.

00:20:20.060 --> 00:20:23.330
Cause different parts of your page
to change as the movie progresses.

00:20:23.330 --> 00:20:30.210
We can use this technique for just about any
dynamic action you want to occur on your webpage.

00:20:30.210 --> 00:20:33.040
So, let's recap.

00:20:33.040 --> 00:20:36.720
We've got working JavaScript controller, we have subtitles.

00:20:36.720 --> 00:20:42.240
Something else you might want to do with
your video playback is add a bumper clip.

00:20:42.240 --> 00:20:47.060
And you might be asking yourself, what is he talking about?

00:20:47.060 --> 00:20:51.710
Well, a bumper clip is a piece of video
industry jargon that refers to a secondary piece

00:20:51.710 --> 00:20:54.840
of video inserted in between two other video clips.

00:20:54.840 --> 00:20:59.100
Now, we might know this more colloquially as advertising.

00:20:59.100 --> 00:21:02.300
So, a lot of video playback sites are doing this now.

00:21:02.300 --> 00:21:07.830
YouTube, specifically I just saw the other day, inserting
advertisement at the beginning of video playback.

00:21:07.830 --> 00:21:13.950
And you might want to know how to do this
if through HTML5 video on your own site.

00:21:13.950 --> 00:21:17.450
So, there's a few different techniques to
getting your advertisements or your bumpers

00:21:17.450 --> 00:21:22.460
or completely non-advertising these
things into your video playback.

00:21:22.460 --> 00:21:27.600
The easiest approach is just to burn in the
advertising into your video content directly.

00:21:27.600 --> 00:21:31.740
Do that QuickTime Player Pro or if
you have Final Cut Pro or even iMovie.

00:21:31.740 --> 00:21:37.390
You can embed one video in another with
some nice transitions and do it that way.

00:21:37.390 --> 00:21:39.050
That's great as far as it stands.

00:21:39.050 --> 00:21:43.330
It's a little static, so we're going to show
you a couple of techniques to use if you want

00:21:43.330 --> 00:21:46.160
to do a more dynamic way of inserting video.

00:21:46.160 --> 00:21:53.260
So, if you're already doing HTTP Live Streaming, you can
insert some video content into your live stream directly.

00:21:53.260 --> 00:21:57.130
And for this technique, I advise you to stick
around for the session following this one

00:21:57.130 --> 00:21:59.700
that talks more about HTTP Live Streaming.

00:21:59.700 --> 00:22:06.690
If you just want something to work completely client
side with no service added requirements whatsoever,

00:22:06.690 --> 00:22:11.880
we're going to show you a technique that involves
switching sources of the video content during playback

00:22:11.880 --> 00:22:15.430
to have the videos chained together one after the other.

00:22:15.430 --> 00:22:18.600
It would require APIs like this one.

00:22:18.600 --> 00:22:24.220
So first of all, there's an event inspired by the video
element as the playback reaches the end of your video,

00:22:24.220 --> 00:22:28.000
and that's the ended event, named very well, I might say.

00:22:28.000 --> 00:22:33.620
So, the source attribute is not only-- it's read/write,
and what we're going to do is shove a new source

00:22:33.620 --> 00:22:37.530
into the video once the last video ended.

00:22:37.530 --> 00:22:41.090
And then as the video sources change,
'cause the video act to play,

00:22:41.090 --> 00:22:45.700
and if you're on a fast connection you'll see a very
seamless transition from video clip to video clip.

00:22:45.700 --> 00:22:48.260
So, it looks something like this.

00:22:48.260 --> 00:22:55.400
We have an array of sources, 4 or 3 different movies that we
want to play in a row, and an index into that array pointing

00:22:55.400 --> 00:23:01.010
to the current playing movie, and the function which
advances those self sources from one to the other.

00:23:01.010 --> 00:23:09.120
It simply increments the index, pulls the new source
out, sets it to the video and then cause play to occur.

00:23:09.120 --> 00:23:14.660
And in this case, we're going listen to
the ended event and cause the advance

00:23:14.660 --> 00:23:18.300
to occur only when the last movie ends playback.

00:23:18.300 --> 00:23:19.710
There's no reason why you're limited to this.

00:23:19.710 --> 00:23:23.920
You can have the next video source
come in the middle of your playback.

00:23:23.920 --> 00:23:26.970
You could have something played in
the beginning and when the advertising

00:23:26.970 --> 00:23:30.640
or whatever your bumper is finishes
playing, move on to the next video.

00:23:30.640 --> 00:23:36.830
You can even have different links in the same
webpage cause different sources to be loaded

00:23:36.830 --> 00:23:39.900
without taking the user out of the current page.

00:23:39.900 --> 00:23:43.040
And to demonstrate this technique one more
time, we're going to have Eric come up.

00:23:43.040 --> 00:23:45.110
[ Applause ]

00:23:45.110 --> 00:23:56.980
>> In this case, we're just using the default
controls so that it's easy to see what's happening.

00:23:56.980 --> 00:24:06.650
So, if you watch the current time thumb on the default
controls, watch what happens as we play through.

00:24:06.650 --> 00:24:10.290
So we start our first movie.

00:24:10.290 --> 00:24:12.220
It reaches the end.

00:24:12.220 --> 00:24:15.400
If you watch fast, you can see
that the ended event was fired.

00:24:15.400 --> 00:24:17.810
Our next movie loads.

00:24:17.810 --> 00:24:21.760
It gets to the end and it goes back to another movie.

00:24:21.760 --> 00:24:31.740
Now, you may want to customize the experience, make it
look to the user like they're just watching a single movie.

00:24:31.740 --> 00:24:38.900
In that case, you would want to use a default controller,
but that would just use the same techniques using

00:24:38.900 --> 00:24:43.010
for the custom controls up to this point.

00:24:43.010 --> 00:24:46.950
Let's take a look here.

00:24:46.950 --> 00:24:49.780
We'll see the same thing on the iPad.

00:24:49.780 --> 00:24:51.920
Not too much of a surprise.

00:24:51.920 --> 00:24:57.870
We start the movie, it reaches the
end, it goes to the next movie.

00:24:57.870 --> 00:24:59.180
It plays through.

00:24:59.180 --> 00:25:02.310
Isn't she cute?

00:25:02.310 --> 00:25:06.960
And it goes to the last movie.

00:25:06.960 --> 00:25:17.440
Now, if you're paying attention in the last session, you'll
recall that Vicki said that playback was strictly under--

00:25:17.440 --> 00:25:21.850
playback is strictly under user control on iOS.

00:25:21.850 --> 00:25:33.990
That is a script is not allowed to start or stop
a movie unless it's called from a user gesture.

00:25:33.990 --> 00:25:47.570
And yet, what we have here is when the
ended event fires, our function is called.

00:25:47.570 --> 00:25:52.490
We change the source to the next source.

00:25:52.490 --> 00:25:57.240
We call load on the element and we call play.

00:25:57.240 --> 00:26:07.100
The ended event isn't the user event and so you
would think that this wouldn't work but it does

00:26:07.100 --> 00:26:14.550
because the user initiated playback on
this element when we first started to play.

00:26:14.550 --> 00:26:23.870
So from that point on, the scripts are in fact allowed
to start and stop playback without user control

00:26:23.870 --> 00:26:27.550
because the user initiated that initial playback.

00:26:27.550 --> 00:26:34.440
So, that's one important point
that you want to keep in mind.

00:26:34.440 --> 00:26:34.800
Jer?

00:26:34.800 --> 00:26:35.340
[ Applause ]

00:26:35.340 --> 00:26:36.290
>> Awesome.

00:26:36.290 --> 00:26:42.420
Thanks, Eric.

00:26:42.420 --> 00:26:45.460
OK, so we have a working JavaScript controller.

00:26:45.460 --> 00:26:46.450
We have subtitles.

00:26:46.450 --> 00:26:48.840
We have learned how to embed different clips and--

00:26:48.840 --> 00:26:52.950
or not how to embed, we're getting to that,
how to combine different clips together.

00:26:52.950 --> 00:26:58.890
The next step you might want to consider is if you have a
video page or if you have a webpage with some video elements

00:26:58.890 --> 00:27:03.230
in it and your users come to that site and they see
something that it's really awesome and they want

00:27:03.230 --> 00:27:07.060
to embed that same clip into their own site.

00:27:07.060 --> 00:27:08.490
This is called embedding.

00:27:08.490 --> 00:27:15.350
And originally, it referred to inserting a plug-in into
a webpage that was running native code but was hosted

00:27:15.350 --> 00:27:18.530
in the interpretative code of the webpage.

00:27:18.530 --> 00:27:23.720
However, it also allows you to insert one page into
another, and this is the technique we're going to use

00:27:23.720 --> 00:27:30.750
to embed HTML5 video into a page that was
maybe not originally coded to HTML5 standards.

00:27:30.750 --> 00:27:38.350
Because you embedded one webpage into another, it should
allow your users to copy and paste a very short line of code

00:27:38.350 --> 00:27:42.730
to get that video into their page instead
of having to copy and paste like, you know,

00:27:42.730 --> 00:27:46.070
the entirety of your page web and
your CSS and your JavaScript.

00:27:46.070 --> 00:27:48.640
We'll get this with just one single small line.

00:27:48.640 --> 00:27:53.940
So, the technique we're going to
use for this is the <iframe> tag.

00:27:53.940 --> 00:27:59.100
And the <iframe> tag takes a source, and to make it
slightly more dynamic, we're going pass the argument

00:27:59.100 --> 00:28:03.580
of the video we would like the iframe to
play back in the fragment portion of the URL.

00:28:03.580 --> 00:28:08.900
That's the one after the octothorpe, the
hash mark, the sharp, the pound, that thing.

00:28:08.900 --> 00:28:11.970
And on the client side, it might look something like this.

00:28:11.970 --> 00:28:13.610
They have an existing HTML page.

00:28:13.610 --> 00:28:18.100
They've got a body, they've got a bunch of content, and
they want to put your video right in the middle of that,

00:28:18.100 --> 00:28:20.940
and they're going to do that with the <iframe> tag.

00:28:20.940 --> 00:28:28.900
As a source attribute, in this case, an
embed-- a link to an embedded specific website.

00:28:28.900 --> 00:28:35.130
And in our case, we're going to pass the argument as
the entirety of the URL after the fragment portion.

00:28:35.130 --> 00:28:43.140
If you're interested in doing server side scripting, you can
pass any number of normal query arguments in that same URL.

00:28:43.140 --> 00:28:47.650
If you're still doing it, like, all
through JavaScript, you can still do arguments

00:28:47.650 --> 00:28:49.960
after the fragment and parse them out yourself.

00:28:49.960 --> 00:28:53.250
And this is the technique, actually this is
the most simple technique in the slides here

00:28:53.250 --> 00:28:59.720
but Eric has a slightly more complicated technique that's
going to involve passing arguments in this fragment.

00:28:59.720 --> 00:29:06.060
However, on the HTML code on your side, if you're doing
a very simple video tag embed, you'll have a video tag

00:29:06.060 --> 00:29:10.710
with no source content and an onload handler for the body.

00:29:10.710 --> 00:29:17.600
In this case, init, that will set everything up to
the way the user who embedded your URL requested.

00:29:17.600 --> 00:29:23.860
So, the JavaScript to get this to work that's hosted on
your site, the init function might look something like this.

00:29:23.860 --> 00:29:31.100
We're going to pull out the video element by its ID and, in
the simplest case, it will be as easy as setting the source

00:29:31.100 --> 00:29:35.690
to the substring of the fragment,
everything after the hash mark.

00:29:35.690 --> 00:29:41.940
And this alone will allow users to link to an
embedded HTML5 video page to get a video playback.

00:29:41.940 --> 00:29:48.210
And to show you a slightly more
complicated piece of sample code,

00:29:48.210 --> 00:29:51.680
Eric is going to-- has a great embedded video demo.

00:29:51.680 --> 00:29:54.100
[ Applause ]

00:29:54.100 --> 00:30:00.100
>> First, what we have is our--
the page that we've been using.

00:30:00.100 --> 00:30:12.560
And what we've done is we've added a little bit
of JavaScript that queries the movie in the page,

00:30:12.560 --> 00:30:21.830
pulls out the URL, pulls out the poster frame, if there
is one, gets the width and the height of the video

00:30:21.830 --> 00:30:27.280
and puts it into this text area in a page.

00:30:27.280 --> 00:30:33.360
And we've done that so that a user can come to the page.

00:30:33.360 --> 00:30:43.720
For example, a user with the site
cutebabyfaces.com, which is nice,

00:30:43.720 --> 00:30:48.600
but it's not very cute without the face of the baby.

00:30:48.600 --> 00:31:09.080
Go to our blog, we'll open up our demo, our blog, and we'll
just paste in the iframe that we pulled out of the webpage.

00:31:09.080 --> 00:31:18.700
We can reload it and there's our cute little baby.

00:31:18.700 --> 00:31:27.720
Now, this is fine but this doesn't work
so well with the layout of the page.

00:31:27.720 --> 00:31:35.750
The video is a bit wide for the layout that we have here.

00:31:35.750 --> 00:31:44.720
But because the width and the height of the iframe are
parts of the iframe element, we can easily come in here

00:31:44.720 --> 00:32:00.490
and change this, down here, scale it by 75 percent
in this case, reload our page and there she is.

00:32:00.490 --> 00:32:02.490
It works like it always did.

00:32:02.490 --> 00:32:10.230
In this case again, we're showing the
default controls to make it slightly simpler

00:32:10.230 --> 00:32:14.080
but it would work just as well with custom controls.

00:32:14.080 --> 00:32:24.200
Let's look at it on the iPhone and we'll reload the page.

00:32:24.200 --> 00:32:30.170
And you can see, again, it works just
the same as it does on the desktop.

00:32:30.170 --> 00:32:38.440
So, allowing somebody to come to your site and use
your content on their own site without actually having

00:32:38.440 --> 00:32:41.450
to understand how all the technology works.

00:32:41.450 --> 00:32:42.040
[ Applause ]

00:32:42.040 --> 00:32:43.310
>> Awesome.

00:32:44.910 --> 00:32:46.650
Thanks, Eric.

00:32:46.650 --> 00:32:53.380
OK, while you're still up here, however, I'd like
you to give the example we came up with that took all

00:32:53.380 --> 00:32:58.080
of these different techniques and pulled them on
together to something that's slightly more refined

00:32:58.080 --> 00:33:00.490
than the examples that we've been using so far.

00:33:00.490 --> 00:33:08.250
As much as I like that baby, there's a limited
audience, so something a little bit more well polished.

00:33:08.250 --> 00:33:18.320
>> So, what we've done here is we have the same Dartmoor video that Vicki showed in the first example,

00:33:18.320 --> 00:33:22.320
and we have put our own custom controller on it.

00:33:22.320 --> 00:33:28.140
It's slightly different than the one that we saw last time.

00:33:28.140 --> 00:33:29.830
We have a button.

00:33:29.830 --> 00:33:39.680
We've added a button that allows us
to scale it up and to scale it back.

00:33:39.680 --> 00:33:47.570
And as Vicki noted in the first
session, Safari 5 has full screen.

00:33:47.570 --> 00:33:51.140
So if we wanted to, we could take this element.

00:33:51.140 --> 00:34:00.140
We could ask WebKit, we could ask Safari
to fill the entire screen with this.

00:34:00.140 --> 00:34:09.590
But when that happens, we take just the
video element full screen and, in this case,

00:34:09.590 --> 00:34:16.190
we actually want to have-- we want
to be able to show titles on it.

00:34:16.190 --> 00:34:29.510
And if we were to show that in full screen, because only
that video element shows that those subtitles wouldn't work.

00:34:29.510 --> 00:34:38.060
We'll start it playing.

00:34:38.060 --> 00:34:41.170
Subtitles are helpful.

00:34:43.090 --> 00:34:46.560
Maybe we want to see them in a different language.

00:34:52.620 --> 00:35:02.820
Notice that because this is HTML5 and the
video element is just another element,

00:35:02.820 --> 00:35:10.420
we have flipped the element around using the CSS transform.

00:35:10.420 --> 00:35:19.980
We have another element on the back with our subtitles
controls and it is not a hundred percent opaque

00:35:19.980 --> 00:35:30.040
so the video is showing through and
you'll notice that it actually is--

00:35:30.040 --> 00:35:35.490
the video is actually playing backwards
because we've flipped it around.

00:35:35.490 --> 00:35:40.130
And that's not because QuickTime knows
how to play this thing backwards,

00:35:40.130 --> 00:35:44.800
it's because it's a video, it's just another element.

00:35:44.800 --> 00:35:50.890
And so of course when you flip it around,
it behaves the way that it should.

00:35:52.820 --> 00:35:57.460
Back to English.

00:35:57.460 --> 00:35:57.980
[ Laughter ]

00:35:57.980 --> 00:36:10.480
[ Pause ]

00:36:10.480 --> 00:36:15.580
[ Laughter ]

00:36:15.580 --> 00:36:18.580
>> I don't know, maybe you guys
can tell me what that thing was.

00:36:18.580 --> 00:36:26.510
It's not a fossilized pig face.

00:36:26.510 --> 00:36:31.220
So this happens to be a fairly high data rate movie.

00:36:31.220 --> 00:36:40.600
It's 1280 by 544 pixels at 1875
kilobit, and look at the performance.

00:36:40.600 --> 00:36:43.200
It's really stunning.

00:36:43.200 --> 00:36:47.350
I take it big and small.

00:36:47.350 --> 00:36:51.020
You see playback is smooth.

00:36:51.020 --> 00:36:55.080
It's really spectacular.

00:36:56.480 --> 00:37:03.250
[ Applause ]

00:37:03.250 --> 00:37:04.540
>> Please contact Vicki Murley.

00:37:04.540 --> 00:37:08.820
She's our Safari Technologies Evangelist,
as well as check the documentation

00:37:08.820 --> 00:37:11.610
on the apple.com developer page for Safari.

00:37:11.610 --> 00:37:18.150
Specifically, there's a whole section on HTML5 audio
and video in the Safari HTML5 audio and video guide.

00:37:18.150 --> 00:37:25.190
As well as the, what working webpage-- the W3C also has a
working draft of the HTML5 spec which you can check out.

00:37:25.190 --> 00:37:31.980
And the brand new developer forums for
Safari are available at devforums.apple.com.

00:37:31.980 --> 00:37:38.250
So, in the session directly following this one, it
will be a whole talk on advances in HTTP streaming.

00:37:38.250 --> 00:37:40.720
And I highly encourage you to stick around for that one.

00:37:40.720 --> 00:37:46.890
Later today, there are-- as a two part session on CSS
effects, we'll talk about all the special CSS3 stylings

00:37:46.890 --> 00:37:50.150
that we put into these webpages to make them super awesome.

00:37:50.150 --> 00:37:52.150
[ Applause ]

