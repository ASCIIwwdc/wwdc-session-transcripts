1
00:00:06,960 --> 00:00:07,850
>> Erik Neuenschwander: Hi everyone!

2
00:00:07,850 --> 00:00:11,700
Welcome to Performance Optimization on iPhone OS.

3
00:00:11,700 --> 00:00:15,710
My name is Erik Neuenschwander I manage one of
the software performance teams on iOS and heading

4
00:00:15,710 --> 00:00:19,720
across the stage is Ben Weintraub who
is with me today to do a bunch of demos.

5
00:00:19,720 --> 00:00:22,100
Ben's a Performance Engineer for us.

6
00:00:22,100 --> 00:00:24,110
So, thank you all for coming.

7
00:00:24,110 --> 00:00:28,860
We're really excited to be here and
have a great hour ahead for you.

8
00:00:28,860 --> 00:00:33,870
I hope you are here already because you think performance
is important or maybe you wandered into the wrong talk

9
00:00:33,870 --> 00:00:39,110
in which case take a seat and we're going to spend the next
hour trying to convince you that performance is important.

10
00:00:39,110 --> 00:00:43,950
And one of those reasons is that performance
is a key aspect of App Store reviews.

11
00:00:43,950 --> 00:00:49,670
If you think about when an application is slow or just
not fun to use that's going to drive down your reviews,

12
00:00:49,670 --> 00:00:53,400
that drives down sales and we want you to
make money and that's why we're here today

13
00:00:53,400 --> 00:00:56,800
to tell you how to get superb performance in your app.

14
00:00:56,800 --> 00:01:01,660
Luckily you already have the tools in the form
of instruments and Xcode to get good performance

15
00:01:01,660 --> 00:01:05,070
and you already have the skills just with
your software development background.

16
00:01:05,070 --> 00:01:10,360
And so, what Ben and I are going to do today is focus
on some common cases where performance can be an issue

17
00:01:10,360 --> 00:01:13,870
and give you some clear strategies
to get good performance in those.

18
00:01:13,870 --> 00:01:19,110
So we'll start by kind of the most important thing which
is just talking about how to test and how to measure

19
00:01:19,110 --> 00:01:25,100
in performance scenarios then we'll spend a lot
of time with three key scenarios, namely launches,

20
00:01:25,100 --> 00:01:28,630
scrolling, and keeping your memory footprint low.

21
00:01:28,630 --> 00:01:32,740
Lastly, because we know that you have things to do other
than performance in your development we're going to talk

22
00:01:32,740 --> 00:01:35,370
about how to prioritize performance issues.

23
00:01:35,370 --> 00:01:39,250
So let me start with measuring performance.

24
00:01:39,250 --> 00:01:45,350
Probably the most important thing I can say is when you're
dealing with performance issues you need to measure first.

25
00:01:45,350 --> 00:01:49,160
By measuring that will give you an idea of
where you can most efficiently put your time

26
00:01:49,160 --> 00:01:51,640
in to improve your app's performance.

27
00:01:51,640 --> 00:01:53,260
And measuring doesn't have to be hard.

28
00:01:53,260 --> 00:01:55,860
You can do it just through manual
testing of your application.

29
00:01:55,860 --> 00:01:59,940
Use it. Find scenarios you are unhappy
with and start working on them.

30
00:01:59,940 --> 00:02:03,150
But new in iOS 4 we also offer automated testing.

31
00:02:03,150 --> 00:02:07,680
And automated testing can give you ways
to get repeatable, more repeatable results

32
00:02:07,680 --> 00:02:10,930
and kind of more efficiently execute your test cases.

33
00:02:10,930 --> 00:02:15,870
But whether you are collecting your data manually
or automatically you have to measure numbers

34
00:02:15,870 --> 00:02:20,720
and it may seem kind of daunting because
everything affects performance, the CPU, GPU, disk,

35
00:02:20,720 --> 00:02:23,780
network latency, it can seem overwhelming.

36
00:02:23,780 --> 00:02:27,300
But you can take a step back and
just recognize that trying to guess

37
00:02:27,300 --> 00:02:30,560
where your performance issues lie is-- that's overrated.

38
00:02:30,560 --> 00:02:35,340
You really just need to focus on a scenario
that you find to be bad and then measure each

39
00:02:35,340 --> 00:02:37,880
of those components in turn looking for a bottleneck.

40
00:02:37,880 --> 00:02:43,230
When you think you've found it, you make a change and then
of course you retest to see if you've improved the scenario.

41
00:02:43,230 --> 00:02:47,000
In the end, all you're trying to do is get
something which is going to feel right.

42
00:02:47,000 --> 00:02:50,690
So to gather data you have a lot of options.

43
00:02:50,690 --> 00:02:52,060
One of them is just logging.

44
00:02:52,060 --> 00:02:55,480
NSLog is probably a method you are already familiar with.

45
00:02:55,480 --> 00:03:00,790
You can just take a time stamp at the beginning of some
activity and then at the end write out how long it took.

46
00:03:00,790 --> 00:03:05,860
You can write that out to CISLOG which you can view through
the organizer in Xcode or to a file that you collect

47
00:03:05,860 --> 00:03:08,670
in some other way, whatever is going to work for you.

48
00:03:08,670 --> 00:03:13,750
But you also have more sophisticated tools like
instruments which we'll spend a lot of time on today

49
00:03:13,750 --> 00:03:16,720
and also the simulator which I'm
sure you're familiar with it.

50
00:03:16,720 --> 00:03:22,550
But the simulator is maybe not always the most
appropriate choice when it comes to performance.

51
00:03:22,550 --> 00:03:26,990
You've used sit for a no doubt prototyping your
interfaces and features but you should consider

52
00:03:26,990 --> 00:03:33,240
that the simulator uses the Mac hardware, that's
the Mac CPU, GPU, disk, the Fast Ethernet,

53
00:03:33,240 --> 00:03:39,260
that's going to give you an unrealistic idea of how
your application is going to perform on the device.

54
00:03:39,260 --> 00:03:42,000
Now one exception to that is when
you're dealing with memory issues.

55
00:03:42,000 --> 00:03:44,420
And there actually the simulator can be good.

56
00:03:44,420 --> 00:03:48,900
It's great for finding memory leaks and looking
at your footprint and in fact the desktop offers

57
00:03:48,900 --> 00:03:53,350
in some cases more features like Zombie Detection
compared to what you what you get on the device.

58
00:03:53,350 --> 00:03:57,860
But what you need to remember is that the
device is the final arbiter of performance.

59
00:03:57,860 --> 00:04:03,260
Your customers will be running your application on a device
and so that's where you need to be doing your testing.

60
00:04:03,260 --> 00:04:06,560
In fact you should do all of your
speed related testing on the device.

61
00:04:06,560 --> 00:04:08,750
And when you fix memory issues that you find

62
00:04:08,750 --> 00:04:12,350
in the simulator make sure those are
playing out as you expect on the device.

63
00:04:12,350 --> 00:04:15,250
That's really what's important.

64
00:04:15,250 --> 00:04:20,760
So, lastly, I want to say that you should measure
early and measure often with the idea of trying

65
00:04:20,760 --> 00:04:23,520
to collect numbers when you have a scenario that you like.

66
00:04:23,520 --> 00:04:28,640
When you get a good result you want to record that as a
baseline and just have those numbers in your back pocket

67
00:04:28,640 --> 00:04:34,770
so that later on when you discover that some scenario
has regressed you can go back and look at those numbers

68
00:04:34,770 --> 00:04:37,930
and get an idea of where the problem might be.

69
00:04:37,930 --> 00:04:43,980
I talked a minute ago about logging and logging is great
but of course doing anything has some performance hit

70
00:04:43,980 --> 00:04:46,770
and logging is something that doesn't
benefit your customers at all.

71
00:04:46,770 --> 00:04:53,500
So you want to turn off or otherwise remove the logging
from the apps that you submit to put up on the App Store.

72
00:04:53,500 --> 00:04:55,700
I talked about testing on the device.

73
00:04:55,700 --> 00:04:59,760
It's the final arbiter so you should really
test on every device you are going to support.

74
00:04:59,760 --> 00:05:04,120
And that kind of sounds like I'm telling you to
buy one of everything we make which would be great

75
00:05:04,120 --> 00:05:06,430
but for a lot of you that's probably unrealistic.

76
00:05:06,430 --> 00:05:11,110
And so at a minimum you want to test on the
oldest device that you are planning to support.

77
00:05:11,110 --> 00:05:15,540
That's likely to be the slowest and today
for most of you that would be the iPhone 3G.

78
00:05:15,540 --> 00:05:21,020
So now let's hit those key scenarios
starting with speedy launches.

79
00:05:21,020 --> 00:05:25,260
Launch is a very important performance scenario.

80
00:05:25,260 --> 00:05:29,610
If you think about it, first of all, when a user buys
your application, the icon appears on the screen.

81
00:05:29,610 --> 00:05:31,160
They tap that icon to launch.

82
00:05:31,160 --> 00:05:32,000
This is the hello.

83
00:05:32,000 --> 00:05:34,480
This is the out of the box experience for your application.

84
00:05:34,480 --> 00:05:38,020
So you want the user to have a
good experience from the get go.

85
00:05:38,020 --> 00:05:42,010
Or if you think about when somebody who has your app
says, "Hey, hey look at this", and they reach out,

86
00:05:42,010 --> 00:05:45,090
they show their phone to their friend,
they're going to launch your application.

87
00:05:45,090 --> 00:05:48,660
And again that's the first thing a
potential customer is going to see.

88
00:05:48,660 --> 00:05:52,240
So even aside from that, launch is a very common scenario.

89
00:05:52,240 --> 00:05:58,110
For non-multitasking devices every time a user switches away
to do something else it's going to quit your application.

90
00:05:58,110 --> 00:06:02,030
So, when they tap on that icon again
it's going to be a launch scenario.

91
00:06:02,030 --> 00:06:06,220
On devices which support multitasking,
instead of launch it's more often a resume,

92
00:06:06,220 --> 00:06:09,820
a transition out at the background state but
you'll find that in your code there's a lot

93
00:06:09,820 --> 00:06:13,210
of shared work between launch and resume scenarios.

94
00:06:13,210 --> 00:06:17,520
So everything Ben and I talk about today
will still apply to resume as well.

95
00:06:17,520 --> 00:06:19,530
Lastly, there is a stick.

96
00:06:19,530 --> 00:06:23,580
If your application is too slow then the
operating system will actually terminate it.

97
00:06:23,580 --> 00:06:26,050
And that's to keep the system responsiveness up.

98
00:06:26,050 --> 00:06:28,300
If you think about it we don't want
a device where the user is reaching

99
00:06:28,300 --> 00:06:30,860
out tapping, nothing is happening, it seems hung.

100
00:06:30,860 --> 00:06:35,160
And so if an application is behaving too
slowly the OS will actually terminate it.

101
00:06:35,160 --> 00:06:38,400
And we do that with the system service we call Watchdog.

102
00:06:38,400 --> 00:06:41,650
So Watchdog is constantly looking
at an application and measuring the

103
00:06:41,650 --> 00:06:44,800
"wall clock" time to reach certain checkpoints or dates.

104
00:06:44,800 --> 00:06:49,630
And "wall clock" time if you are not familiar with the
term is just seconds ticking by on the clock on the wall.

105
00:06:49,630 --> 00:06:52,010
It's not CPU time or anything fancy.

106
00:06:52,010 --> 00:06:55,500
It's literally just the time that your
user is waiting for something to happen.

107
00:06:55,500 --> 00:06:59,290
So these values that you see on screen,
they're subject to change, right.

108
00:06:59,290 --> 00:07:03,330
Ideally you want to keep these things as short as
possible because all it is, is the user waiting.

109
00:07:03,330 --> 00:07:07,840
But when we're talking about launch your
application has up to 20 seconds to be able

110
00:07:07,840 --> 00:07:10,260
to return from applicationDidFinishLaunching.

111
00:07:10,260 --> 00:07:11,250
It's quite a long time.

112
00:07:11,250 --> 00:07:12,800
You really want to be far below that.

113
00:07:12,800 --> 00:07:14,620
But that is the upper limit.

114
00:07:14,620 --> 00:07:20,480
For Resume and also for Suspend there's less work
to do so that time out goes down to 10 seconds

115
00:07:20,480 --> 00:07:25,100
and Quit is actually the shortest time out because
well you should already be saving out your state

116
00:07:25,100 --> 00:07:30,970
on a regular basis anyway so there should be very
little to do when you actually quit the application.

117
00:07:30,970 --> 00:07:37,470
Also new in iOS 4, there's the complete operation,
multitasking scenario, and for that say uploading photos

118
00:07:37,470 --> 00:07:41,050
to a social networking site or
something, you get 10 minutes.

119
00:07:41,050 --> 00:07:46,170
And if you watched the multitasking talks you can also
find out more about how to handle and avoid that time out,

120
00:07:46,170 --> 00:07:49,200
suspending your background operation gracefully.

121
00:07:50,330 --> 00:07:54,510
So, when you want to collect the data to
figure out how close you are to those numbers,

122
00:07:54,510 --> 00:07:59,290
figure out how to get it down, you want to make
sure that you are testing with a realistic data set.

123
00:07:59,290 --> 00:08:02,890
Your application may launch or resume
really, really quick with no data.

124
00:08:02,890 --> 00:08:08,250
So, instead you want to think about a user who's been using
your application for 6 months and has a lot of bookmarks

125
00:08:08,250 --> 00:08:12,360
or photos or clips or whatever it is
that's your application's data set

126
00:08:12,360 --> 00:08:16,290
and create a stable realistic data
set that you can use for that.

127
00:08:16,290 --> 00:08:19,630
To collect the data you will use
the Time Profiler instrument.

128
00:08:19,630 --> 00:08:25,210
Time Profiler works with iOS 4 devices and it
collects back traces at regular intervals showing

129
00:08:25,210 --> 00:08:28,560
at that instant in time what your application is doing.

130
00:08:28,560 --> 00:08:34,300
You can then look at them n aggregate and get a pretty
complete picture of where the execution time of your app is.

131
00:08:34,300 --> 00:08:36,790
And you are really looking for two things primarily.

132
00:08:36,790 --> 00:08:41,680
First if we're talking about launch you want to
look for work that you just don't need to do,

133
00:08:41,680 --> 00:08:46,940
work that you can take out of launch defer until
just slightly later or maybe even on demand,

134
00:08:46,940 --> 00:08:51,710
waiting until the user does something that's going to
request the work that you're doing currently during launch.

135
00:08:51,710 --> 00:08:53,990
So move that out of the launch path.

136
00:08:53,990 --> 00:08:57,120
But the other work that you'll see is work
that-- you look at that function and you say,

137
00:08:57,120 --> 00:08:59,070
I got to call that function as part of launch.

138
00:08:59,070 --> 00:09:00,180
That's necessary work.

139
00:09:00,180 --> 00:09:05,010
And then you want to sort by running time and
look for the thing which is taking the most time.

140
00:09:05,010 --> 00:09:09,000
Because that's where there's the most upside
for your effort to make your app fast.

141
00:09:09,000 --> 00:09:16,110
So, to show you using the Time Profiler instrument to get a
demo application running faster we'll turn you over to Ben.

142
00:09:16,110 --> 00:09:17,400
>> Ben Weintraub: Alright, thanks Erik.

143
00:09:17,400 --> 00:09:21,400
So in order to show you guys what we're
going to be doing with instruments,

144
00:09:21,400 --> 00:09:24,570
we've created a sample demo application here.

145
00:09:24,570 --> 00:09:28,860
So let me just show you the app quickly
first so you get a feel for what it does.

146
00:09:28,860 --> 00:09:32,470
So, basically you select photos from
your photo roll or from the camera.

147
00:09:32,470 --> 00:09:35,300
And then for each of those photos
you can create a composition.

148
00:09:35,300 --> 00:09:40,830
So if I select one of these I get this nice
Andy Warhol style composition and for each one

149
00:09:40,830 --> 00:09:46,150
of these tiles I can adjust the threshold
here and then change these colors.

150
00:09:46,150 --> 00:09:48,070
And that's about all the app does.

151
00:09:48,070 --> 00:09:49,390
It's pretty simple.

152
00:09:49,390 --> 00:09:53,360
OK, so now let's take a look at
how it launches on the devices.

153
00:09:53,360 --> 00:09:55,570
I have an iPhone 3G is here.

154
00:09:55,570 --> 00:09:57,440
I'm just going to go ahead and launch the app.

155
00:09:57,440 --> 00:10:03,000
Again I'm using a realistic data set with a number
of compositions in there to simulate what it would be

156
00:10:03,000 --> 00:10:06,410
like if the user had been using your app for a while.

157
00:10:06,410 --> 00:10:11,880
So, you can see that that takes quite a
while to launch even on an iPhone 3GS.

158
00:10:11,880 --> 00:10:19,830
So, in order to figure out where all that time is
going we're going to switch back to instruments here

159
00:10:19,830 --> 00:10:23,570
and we're going to use the Time Profiler
instrument that Erik was talking about.

160
00:10:23,570 --> 00:10:29,840
So, if you've used Shark or the CPU sampler instrument
in the past Time Profiler is similar in concept

161
00:10:29,840 --> 00:10:35,370
but its lower overhead and it's now the
preferred way of looking at CPU bound operations.

162
00:10:35,370 --> 00:10:40,480
The first thing I'm going to do is select the
app that I want to have instruments launched

163
00:10:40,480 --> 00:10:42,610
for me because we're looking at launch times.

164
00:10:42,610 --> 00:10:45,960
I'm going to have Instruments launch
the application on my behalf

165
00:10:45,960 --> 00:10:48,840
and then it'll start collecting data as soon as it launches.

166
00:10:48,840 --> 00:10:50,460
Let's go ahead and watch.

167
00:10:50,460 --> 00:11:00,380
Alright, so you can see now as Instruments is working there
is data being populated into this Call Tree View down here

168
00:11:00,380 --> 00:11:02,990
and then it looks like we're finished launching now.

169
00:11:02,990 --> 00:11:04,550
So I'm going to stop the trace.

170
00:11:04,550 --> 00:11:11,580
OK so let me expand this Timeline view out a little
bit so you can see what's going on a little better.

171
00:11:11,580 --> 00:11:16,690
Alright, so the first thing we notice is in this Timeline
view the purple bars are showing us an approximate amount

172
00:11:16,690 --> 00:11:20,110
of CPU utilization over time.

173
00:11:20,110 --> 00:11:27,290
And if I go to the very end here where I stop running
the CPU it's about 3.7 seconds after the launch.

174
00:11:27,290 --> 00:11:32,580
So I can use the Call Tree View down here to try
and figure out where that time is actually going.

175
00:11:32,580 --> 00:11:37,950
So, the first thing I'm going to do is
if you take a look at these check boxes

176
00:11:37,950 --> 00:11:41,530
over here there's one check right
now that's called Invert Call Tree.

177
00:11:41,530 --> 00:11:46,040
So that-- see that a little better?

178
00:11:46,040 --> 00:11:49,980
So I actually want to see the methods
in the order that they were called.

179
00:11:49,980 --> 00:12:00,100
So, I'm going to uncheck that box and now you see I
have-- Now I have a more reasonable back trace here.

180
00:12:00,100 --> 00:12:05,000
But most of these symbols are not things that I
immediately recognize, these are system libraries that end

181
00:12:05,000 --> 00:12:06,670
up being called through to get to my code.

182
00:12:06,670 --> 00:12:11,430
So the next thing I'm going to do is check
this box that says hide system libraries.

183
00:12:11,430 --> 00:12:15,310
OK, so what that will do is filter the Call Tree's View

184
00:12:15,310 --> 00:12:20,100
down to only the stack frames that
are from my application itself.

185
00:12:20,100 --> 00:12:27,540
So it looks like I'm spending about 2.8 seconds of CPU
time under my root view controller's viewDidLoad method

186
00:12:27,540 --> 00:12:32,730
and specifically almost all that time is under
this generate composition thumbnails call.

187
00:12:32,730 --> 00:12:38,550
So let's switch over to Xcode and take a
look at how that-- what that code is doing.

188
00:12:38,550 --> 00:12:42,100
Alright so, here's my viewDidLoad at the end.

189
00:12:42,100 --> 00:12:47,920
I'm just calling generate composition thumbnails and all
that's doing is iterating over each of the compositions

190
00:12:47,920 --> 00:12:51,580
from my data set and generating a thumbnail for each one.

191
00:12:51,580 --> 00:12:57,190
So, and this is necessary in order to show those
thumbnails in the table view that we saw before.

192
00:12:57,190 --> 00:13:01,430
So, even though I do want to eventually
show those, this isn't something that I want

193
00:13:01,430 --> 00:13:05,140
to block the entire launch of the application on.

194
00:13:05,140 --> 00:13:12,640
So, in order to have my app launched a little bit more
quickly and be responsive immediately I'm actually going

195
00:13:12,640 --> 00:13:16,540
to put this work on to a background thread
using a technology that's available now

196
00:13:16,540 --> 00:13:20,500
in iOS 4 which is Grand Central Dispatch.

197
00:13:20,500 --> 00:13:27,890
So, the first thing I want to do is get
something up on the screen right away

198
00:13:27,890 --> 00:13:30,100
as soon as the user launches the application.

199
00:13:30,100 --> 00:13:34,370
So in order to accomplish that I'm going
to create a set of placeholder images here

200
00:13:34,370 --> 00:13:39,170
and those placeholder images are going to stand in
for my thumbnails while I'm generating the thumbnails.

201
00:13:39,170 --> 00:13:40,740
Alright, so that's great.

202
00:13:40,740 --> 00:13:46,540
The next thing I want to do is actually
get this call into a background thread.

203
00:13:46,540 --> 00:13:52,800
So, I'm going to do that by wrapping
in the call to dispatch_async

204
00:13:52,800 --> 00:13:56,320
and so dispatch_async is an API from Grand Central Dispatch.

205
00:13:56,320 --> 00:14:00,630
And I'm going to put it on a low priority background
thread because I really don't want it to interfere

206
00:14:00,630 --> 00:14:03,470
with the responsiveness of my application.

207
00:14:03,470 --> 00:14:07,560
So I'm just passing on a block here that
calls generate composition thumbnails.

208
00:14:07,560 --> 00:14:12,800
Now, in order to make this method work from a background
thread there's one other thing I need to change.

209
00:14:12,800 --> 00:14:19,210
So this thumbnails array is now accessed from two
different threads and so I need to serialize those accesses

210
00:14:19,210 --> 00:14:25,730
in some way and I can do that using a lock
or again I could use Grand Central Dispatch.

211
00:14:25,730 --> 00:14:28,440
So that's actually what I'm going to do in this case.

212
00:14:28,440 --> 00:14:31,860
So I'm just going to replace the body of this for loop.

213
00:14:31,860 --> 00:14:38,420
Alright, so now you see that I'm still doing the
heavy lifting here which is generating the thumbnail

214
00:14:38,420 --> 00:14:45,830
on the background thread but when it comes time to do my
updates to the UI thread I called dispatch_get_main_queue

215
00:14:45,830 --> 00:14:51,230
in order to send this work inside of
this block back over to the main thread.

216
00:14:51,230 --> 00:14:56,040
So that should make sure that there's no
synchronization issues or anything like that.

217
00:14:56,040 --> 00:15:02,410
Alright, so now let's switch back over to the
device and take a look at the effects of my changes.

218
00:15:02,410 --> 00:15:06,280
So, I have a version of the app
with these changes ready to go.

219
00:15:06,280 --> 00:15:07,560
So let me just launch it.

220
00:15:07,560 --> 00:15:10,930
Alright, so that was much faster.

221
00:15:10,930 --> 00:15:18,240
So the final thing we should do though is make sure that
we can actually quantify that change in Instruments.

222
00:15:18,240 --> 00:15:23,230
So, I'm going to select the modified version of my app.

223
00:15:23,230 --> 00:15:25,510
And again have Instruments launch it for me.

224
00:15:25,510 --> 00:15:31,040
[ Pause ]

225
00:15:31,040 --> 00:15:36,910
Alright, so you can see that we're still spinning the CPU
for quite a bit of time here and that's expected actually

226
00:15:36,910 --> 00:15:41,260
because we still need to do that work of generating
the thumbnails but the difference is that now it's

227
00:15:41,260 --> 00:15:45,430
on a background thread and we can
see that easily in instruments

228
00:15:45,430 --> 00:15:48,190
if we check this separated by thread check box here.

229
00:15:48,190 --> 00:15:51,050
So, I'm going to go ahead and do that.

230
00:15:51,050 --> 00:15:54,490
OK, so now if we look at our main
thread and expand that out.

231
00:15:54,490 --> 00:15:59,380
We can see that viewDidLoad is only
taking about 185 millisecond of CPU time

232
00:15:59,380 --> 00:16:04,150
and all of the real heavy work is
happening on this background thread

233
00:16:04,150 --> 00:16:07,010
that we created using Grand Central Dispatch.

234
00:16:07,010 --> 00:16:11,930
Alright, so that's an example of how you can use Time
Profiler to help speed up the launch of your application.

235
00:16:11,930 --> 00:16:13,230
So, back to you Erik.

236
00:16:13,230 --> 00:16:17,740
[ Applause ]

237
00:16:17,740 --> 00:16:19,680
>> Erik Neuenschwander: Thanks Ben.

238
00:16:19,680 --> 00:16:24,810
So, to get your launches going fast you first have
to remember that the system Watchdog is out there

239
00:16:24,810 --> 00:16:28,530
but you really want to be well below those
levels I was talking about a minute ago.

240
00:16:28,530 --> 00:16:32,400
What you can do is collect a trace using the
Time Profiler instrument like you saw Ben do

241
00:16:32,400 --> 00:16:36,820
and in his case he did less work by deferring
the work out of startup and that's one way

242
00:16:36,820 --> 00:16:39,280
that you'll commonly be able to solve that problem.

243
00:16:39,280 --> 00:16:43,860
But sometimes there's work that you have to do and
that operation maybe slow and you want to make sure

244
00:16:43,860 --> 00:16:47,240
that in one way should they perform you
never block on those slow operations.

245
00:16:47,240 --> 00:16:49,890
In particular, never do networking on your main thread.

246
00:16:49,890 --> 00:16:54,970
If you think about it you don't control how quickly that
server is going to respond so this is a prime candidate

247
00:16:54,970 --> 00:16:57,640
for moving it off to some non blocking thread.

248
00:16:57,640 --> 00:17:02,610
But if you're doing a lot of work you need to optimize
those time consuming activities and make sure--

249
00:17:02,610 --> 00:17:06,710
I talked about a realistic data set but
you should think about what realistic is.

250
00:17:06,710 --> 00:17:11,420
If you're data set is going to keep growing
endlessly over time eventually it will get slow.

251
00:17:11,420 --> 00:17:15,570
So think about the data set that you are looking
at on launch and think of someway to make sure

252
00:17:15,570 --> 00:17:17,620
that that size always remains constrained.

253
00:17:17,620 --> 00:17:22,510
And then like you saw Ben do, collect a new trace
after you've made a change and quantify your results.

254
00:17:22,510 --> 00:17:24,400
So that's speedy launches.

255
00:17:24,400 --> 00:17:26,370
Let's talk about scrolling next.

256
00:17:26,370 --> 00:17:28,630
And scrolling is another really important scenario.

257
00:17:28,630 --> 00:17:31,050
I mean how many of you have used UITableView, right?

258
00:17:31,050 --> 00:17:33,110
It's a very popular class.

259
00:17:33,110 --> 00:17:39,060
And this is because you want to show large amounts
of data and both on the iPhone, iPad, iPod Touch.

260
00:17:39,060 --> 00:17:40,370
It's a great way to do it.

261
00:17:40,370 --> 00:17:45,930
But because we have this direct manipulation UI when a
user reaches out and wants to scroll through that you want

262
00:17:45,930 --> 00:17:48,530
that to seem like they're actually manipulating those cells.

263
00:17:48,530 --> 00:17:53,490
And if it stutters that will break that kind of
seamlessness that you want in your application

264
00:17:53,490 --> 00:17:57,960
and that's going to create a bad scenario for the user.

265
00:17:57,960 --> 00:18:01,980
So the way that we measure if scrolling
is going well or not is frames per second.

266
00:18:01,980 --> 00:18:05,730
Which is abbreviated as FPS and we pronounce that fips.

267
00:18:05,730 --> 00:18:08,820
And if you're looking for a good
FPS number the magic number is 60.

268
00:18:08,820 --> 00:18:11,290
60 FPS is completely smooth.

269
00:18:11,290 --> 00:18:14,740
You can use the Core Animation
Instrument to collect that FPS data.

270
00:18:14,740 --> 00:18:16,940
It does measurement of FPS in real time.

271
00:18:16,940 --> 00:18:21,010
And if you have any animation which goes on
for longer than a second it's very, very easy.

272
00:18:21,010 --> 00:18:25,160
You just look at the number that is
presented to you and that's your FPS count.

273
00:18:25,160 --> 00:18:30,210
The Core Animation Instrument can also work for subsecond
animations but then you have to do a little bit of math.

274
00:18:30,210 --> 00:18:36,190
If you think about a 0.3 second animation which only
draws 18 frames well then Core Animation is going

275
00:18:36,190 --> 00:18:37,170
to report 18 FPS.

276
00:18:37,170 --> 00:18:39,800
That's all that happened during that second.

277
00:18:39,800 --> 00:18:44,030
But if you think to yourself well,
alright 18 times 10 divided by 3 aha!

278
00:18:44,030 --> 00:18:44,890
that's 60 FPS.

279
00:18:44,890 --> 00:18:49,400
So, you can kind of go through that but if you
have an opportunity to make your animations longer

280
00:18:49,400 --> 00:18:53,150
at least for testing it will save you that math.

281
00:18:53,150 --> 00:18:57,620
In addition to doing FPS measurement Core
Animation also has a set of check boxes

282
00:18:57,620 --> 00:19:01,090
that can show you visual cues about
how rendering is happening.

283
00:19:01,090 --> 00:19:03,800
And in particular one of those is Color Blended Layers.

284
00:19:03,800 --> 00:19:05,190
And we'll show that today.

285
00:19:05,190 --> 00:19:10,110
But there are many others and there have been some great
talks on instrument specifically and I'd refer you to those

286
00:19:10,110 --> 00:19:13,270
to learn more in depth about the Core Animation instrument.

287
00:19:13,270 --> 00:19:16,020
But to show you collecting some
FPS data with that same demo app.

288
00:19:16,020 --> 00:19:17,520
I'll send it back over to Ben.

289
00:19:17,520 --> 00:19:24,770
>> Ben Weintraub: So, here's our
application and so if we scroll

290
00:19:24,770 --> 00:19:29,520
through these we can see that the
scrolling is not too great.

291
00:19:29,520 --> 00:19:35,350
It's pretty chunky and it can certainly be improved upon.

292
00:19:35,350 --> 00:19:43,160
Alright, so going back to instruments now, we're going
to use the Core Animation Instrument as Erik mentioned

293
00:19:43,160 --> 00:19:48,230
to sample the frames per second that
we're getting out of this application.

294
00:19:48,230 --> 00:19:55,280
So I'm going to just select that application as
our target and actually with the Core Animation

295
00:19:55,280 --> 00:20:00,660
because we already have the app running we don't need to
have Instruments launch it for us so we can use this attach

296
00:20:00,660 --> 00:20:06,570
to process feature and I'll just start recording.

297
00:20:06,570 --> 00:20:12,670
Alright, and now all I'm going to do is just scroll
down through that list that you saw previously.

298
00:20:12,670 --> 00:20:16,750
Scroll to the bottom and scroll back up to the top.

299
00:20:16,750 --> 00:20:20,850
Maybe do a little bit more so we get some more data here.

300
00:20:20,850 --> 00:20:22,480
OK, great.

301
00:20:23,810 --> 00:20:28,430
So let's stop the trace now.

302
00:20:28,430 --> 00:20:33,620
Alright, so if you look over this frames per second
column here you can see that the numbers we're getting

303
00:20:33,620 --> 00:20:37,170
for FPS are not that great, when we're scrolling here.

304
00:20:37,170 --> 00:20:44,330
We're certainly nowhere near the 60 frames per second
that Erik was talking about as the-- should be your goal.

305
00:20:44,330 --> 00:20:49,550
So in order to diagnose why that's happening you
have a number of different tools available to you

306
00:20:49,550 --> 00:20:54,710
but one of the most common problems with scrolling
performance is if you're creating a lot of objects

307
00:20:54,710 --> 00:20:57,840
and then throwing those objects away immediately.

308
00:20:57,840 --> 00:21:03,220
So, we can use the Allocations Instruments
in order to diagnose a problem like this.

309
00:21:03,220 --> 00:21:09,180
So, I'm going to start a new trace with the
Allocations Instrument and again select my app

310
00:21:09,180 --> 00:21:15,100
and then I'm just going to start recording.

311
00:21:15,100 --> 00:21:19,260
So, the allocations instrument
is going to collect back traces

312
00:21:19,260 --> 00:21:22,950
of every allocation that happens inside of my application.

313
00:21:22,950 --> 00:21:27,670
So that's anytime that you allocinit a new
object or when you call malloc directly

314
00:21:27,670 --> 00:21:29,260
or calloc or any of those other functions.

315
00:21:29,260 --> 00:21:36,520
And then it's going to aggregate all that information
together in this nice statistics view for us.

316
00:21:36,520 --> 00:21:45,780
So, what I'm going to do now is scroll through a bunch
of the table view cells that I've got here just scroll

317
00:21:45,780 --> 00:21:51,320
to the bottom of my table view and you'll notice
when you do this on your device is if you try it

318
00:21:51,320 --> 00:21:58,580
out that the performance of your application will be
somewhat degraded while you do this and that's OK.

319
00:21:58,580 --> 00:22:05,180
It's actually to be expected because of the amount of
data that the Allocations Instrument is collecting.

320
00:22:05,180 --> 00:22:10,940
Like I said it's getting back traces from every allocation
inside of your app so that's quite a bit of data.

321
00:22:10,940 --> 00:22:15,370
Alright, so I'm going to just stop the trace now.

322
00:22:15,370 --> 00:22:21,060
OK. So the first thing that I want to do is restrict
the portion of the timeline that I'm looking

323
00:22:21,060 --> 00:22:24,200
at to only show the area where I was scrolling.

324
00:22:24,200 --> 00:22:28,890
So, if you recall we waited until
this big spike here sort of went away.

325
00:22:28,890 --> 00:22:36,860
So, I'm going to move the cursor to about the point
where I think we started scrolling and now I'm going

326
00:22:36,860 --> 00:22:41,330
to use the inspection range tool to have
Instruments only look at this portion

327
00:22:41,330 --> 00:22:44,210
of the timeline that's highlighted in blue.

328
00:22:44,210 --> 00:22:51,660
Alright, so now if I look in the statistics view down here
each one of these lines represents one category or one type

329
00:22:51,660 --> 00:22:57,700
of object that I maybe created in my application
and Instruments is giving me some statistics

330
00:22:57,700 --> 00:23:00,210
about each type of object that I created.

331
00:23:00,210 --> 00:23:04,950
So in this case what I'm looking for are objects
that I create and then throw away immediately.

332
00:23:04,950 --> 00:23:10,800
So those, we call transitory objects because
they're-- they have a short lifetime.

333
00:23:10,800 --> 00:23:13,940
So, I'm going to sort by the number
of transitory objects here.

334
00:23:13,940 --> 00:23:19,010
And if I look up at the top I see
a bunch of malloc allocations.

335
00:23:19,010 --> 00:23:23,820
I see some pretty generic looking
things CALayer, CF basic cache.

336
00:23:23,820 --> 00:23:27,140
None of these really means a whole lot to me to begin with.

337
00:23:27,140 --> 00:23:31,600
So what I'm actually going to do is
use the search functionality instrument

338
00:23:31,600 --> 00:23:34,980
to search for a class from my application.

339
00:23:36,310 --> 00:23:44,090
So because my application is called compositions I have
a class in here called composition table view cell.

340
00:23:44,090 --> 00:23:51,860
And if I take a look at this particular class I see
that I have 93 transitory instances of that class.

341
00:23:51,860 --> 00:23:55,160
So, what that probably means is that every
time I need to bring a new table view cell

342
00:23:55,160 --> 00:24:02,130
onto the screen I'm creating a
new one just for that purpose.

343
00:24:02,130 --> 00:24:08,360
So if I actually get rid of this search
and then look at the objects adjacent

344
00:24:08,360 --> 00:24:16,490
to that composition table view cell class I see that
I have 93 of a bunch of different objects that look

345
00:24:16,490 --> 00:24:22,440
like they might be associated like UIButton,
UIView, UITableViewLabel for instance.

346
00:24:22,440 --> 00:24:26,730
So these things are probably being
created along with my UITableView cells.

347
00:24:26,730 --> 00:24:30,930
So, Erik's going to talk about an API that we have
that will actually help you avoid this problem.

348
00:24:30,930 --> 00:24:35,470
>> Erik Neuenschwander: So I'm going to show you actually
visually what Ben will show you in code in just a minute

349
00:24:35,470 --> 00:24:38,210
which is making use of what we call cell reuse.

350
00:24:38,210 --> 00:24:43,000
So, the way the application is behaving now and you see
that with all the transitory cells getting created is

351
00:24:43,000 --> 00:24:47,050
that we create them, they scroll onto the
screen, they scroll off the screen exactly

352
00:24:47,050 --> 00:24:49,430
as you'd expect and then they get deleted.

353
00:24:49,430 --> 00:24:55,150
And then they have to get recreated, they come back on the
screen and so we want to avoid doing all those allocations

354
00:24:55,150 --> 00:24:59,590
because that's contending with the scrolling
and giving the poor FPS that you're seeing.

355
00:24:59,590 --> 00:25:04,070
So if you use cell reuse which is
an API that Ben will show shortly.

356
00:25:04,070 --> 00:25:05,540
These cells still have to get created.

357
00:25:05,540 --> 00:25:06,490
There's no avoiding that.

358
00:25:06,490 --> 00:25:10,030
They scroll on, they scroll off but then they get recycled,

359
00:25:10,030 --> 00:25:12,970
because it's just more of the same
that's going on to the device.

360
00:25:12,970 --> 00:25:16,880
So after you've created that initial set
of cells you actually have a steady state

361
00:25:16,880 --> 00:25:18,980
as they come on to and off of the screen.

362
00:25:18,980 --> 00:25:21,220
So that's a little graphical showing of that.

363
00:25:21,220 --> 00:25:24,000
I'm going to send you back to Ben to
show you both how to do cell reuse

364
00:25:24,000 --> 00:25:26,760
and then some other tricks to get us some good FPS numbers.

365
00:25:26,760 --> 00:25:29,900
>> Ben Weintraub: Alright, thanks Erik.

366
00:25:29,900 --> 00:25:34,240
So, if we take a look at our table view
cell per row at index path method here.

367
00:25:34,240 --> 00:25:40,250
We can see that right now we're just-- every time we call
it we're creating a new Autoreleased composition table view

368
00:25:40,250 --> 00:25:44,930
cell that's a subclass of UITableView
cell that's custom to our app.

369
00:25:44,930 --> 00:25:48,930
And so instead of doing that we're going to
go ahead and use the API that Erik mentioned.

370
00:25:48,930 --> 00:25:51,040
So, let me show you how that looks.

371
00:25:51,040 --> 00:25:52,900
Alright, so there's a couple of things here.

372
00:25:52,900 --> 00:25:55,710
The first thing to note is this reuse identifier.

373
00:25:55,710 --> 00:26:01,890
So this is just an arbitrary string that you
can give whatever value you want but the idea is

374
00:26:01,890 --> 00:26:06,620
if you have multiple types of table view cells
in your table view with different lay outs

375
00:26:06,620 --> 00:26:11,860
for instance then you can uniquely identify
those different types using reuse identifier.

376
00:26:11,860 --> 00:26:17,090
So the next step is before we create
a new table view cell we're going

377
00:26:17,090 --> 00:26:23,320
to call this dequeueReusableCellWithIdentifier
method on UITableView and that's going

378
00:26:23,320 --> 00:26:29,740
to ask the table view whether it has any reusable cells
for us to use rather than having to create a new one.

379
00:26:29,740 --> 00:26:37,210
And then if that fails we'll go ahead and create a new
table view cell which is OK because we do need to have

380
00:26:37,210 --> 00:26:41,980
as many cells as are visible on
screen at any given point in time.

381
00:26:41,980 --> 00:26:45,140
OK, so let's take a look at how
that looks on the device now.

382
00:26:45,140 --> 00:26:50,560
I have a version of my app with this change.

383
00:26:55,390 --> 00:27:03,540
OK, so as you can see the scrolling is a little bit
better but still not as good as it could be probably.

384
00:27:03,540 --> 00:27:10,820
So, in order to figure out why that is, we're going to use
one of the other features of the Core Animation Instrument

385
00:27:10,820 --> 00:27:17,310
and that's this check box over here
that's labeled as Color Blended Layers.

386
00:27:17,310 --> 00:27:21,640
So it's probably easier if I just show
you what this looks like on the device.

387
00:27:21,640 --> 00:27:27,590
I'm going to check this check box and then immediately
you'll see what the results look like on the device.

388
00:27:27,590 --> 00:27:35,220
OK, so now you can see we have a number of views here
that are colored red and some that are colored green.

389
00:27:35,220 --> 00:27:39,290
So, the green views are good in
this case, the red views are bad.

390
00:27:39,290 --> 00:27:45,900
The green views mean that-- those are views
that are opaque and red ones are not opaque.

391
00:27:45,900 --> 00:27:51,610
And what those non opaque views or layers mean is that
the graphics hardware actually has to do more work

392
00:27:51,610 --> 00:27:56,930
in order blend them with the views that are behind them.

393
00:27:56,930 --> 00:28:01,350
So, this Color Blended Layers check box
can be really useful in identifying that.

394
00:28:01,350 --> 00:28:07,560
Alright, so let's switch back over to Xcode
and see if we can fix those two instances

395
00:28:07,560 --> 00:28:10,640
of non opaque views that we had in our table view cells.

396
00:28:10,640 --> 00:28:17,810
So the first one of them was this thumbnail, so the
thumbnails I know are generated inside of this class

397
00:28:17,810 --> 00:28:23,100
and specifically in my thumbnail with size method here.

398
00:28:23,100 --> 00:28:29,460
So, in this case in order to generate those thumbnails
with the cropping I'm calling UIGraphicsBeginImageContext

399
00:28:29,460 --> 00:28:35,980
in order to start a new image context stuff and
by default this will give me back an image context

400
00:28:35,980 --> 00:28:39,750
that has an alpha channel which means it will be non opaque.

401
00:28:39,750 --> 00:28:42,130
So in this case I actually don't need that.

402
00:28:42,130 --> 00:28:47,520
And so, I'm going to go ahead and call
a different variant of this method.

403
00:28:47,520 --> 00:28:54,410
So, UIGraphicsBeginImageContextWithOptions allows
me to pass in a flag here that's this yes parameter

404
00:28:54,410 --> 00:28:58,120
that will specify that I want an opaque image context.

405
00:28:58,120 --> 00:29:03,090
And that means that the UIImage that I
returned from here will also be opaque.

406
00:29:03,090 --> 00:29:06,840
OK, so that should fix the thumbnails.

407
00:29:06,840 --> 00:29:11,960
And let's take a look at those date labels
you probably noticed were also not opaque

408
00:29:11,960 --> 00:29:16,330
and so that's in my composition table view cell class.

409
00:29:16,330 --> 00:29:21,430
Alright, so here in the initializer I'm
just manually setting them to be non opaque

410
00:29:21,430 --> 00:29:23,290
and setting the background colors to nil.

411
00:29:23,290 --> 00:29:28,440
So this may seem a little bit silly but this can
actually happen and does happen relatively frequently

412
00:29:28,440 --> 00:29:34,420
when you are playing around with different
layouts and maybe you wanted them to be nonopaque

413
00:29:34,420 --> 00:29:38,080
for one particular layout and then
you forgot to switch them back.

414
00:29:38,080 --> 00:29:46,400
Another way it sometimes happens is people think that they
need to set the UILabel instances to be non opaque in order

415
00:29:46,400 --> 00:29:50,780
to get that nice blue highlight color to show
through when you select the table view cell.

416
00:29:50,780 --> 00:29:52,660
And that's not actually the case.

417
00:29:52,660 --> 00:29:57,030
UIKit will handle that for you automatically
so you don't need to worry about that.

418
00:29:57,030 --> 00:30:04,250
So I'm going to get rid of these two lines because
there's no reason for those labels to be opaque.

419
00:30:04,250 --> 00:30:07,910
So let's go back over to Instruments now.

420
00:30:07,910 --> 00:30:13,120
And again, I'm going to run a version of
my app with these changes and we're going

421
00:30:13,120 --> 00:30:16,930
to check the Color Blended Layers
check box and see how it looks.

422
00:30:16,930 --> 00:30:19,250
So, let's switch over to the device.

423
00:30:22,810 --> 00:30:29,030
Alright. So, here's a versions of the app after
we made those transparency related changes.

424
00:30:29,030 --> 00:30:32,470
And I'll just check Color Blended
Layers, and now you can see

425
00:30:32,470 --> 00:30:35,200
that those thumbnails and the date labels are both green.

426
00:30:35,200 --> 00:30:36,220
So that's great.

427
00:30:36,220 --> 00:30:43,990
So, now that we've made all of these changes we want
to try and quantify what the impact to that was.

428
00:30:43,990 --> 00:30:51,760
So, if we go back to instruments-- we can use the Core
Animation Instrument again to measure the frame per second

429
00:30:51,760 --> 00:30:54,210
that we're getting with our modified app.

430
00:30:54,210 --> 00:31:03,250
So in order to do that I need to select the running copy
of the app and just hit Record and then all I'm going

431
00:31:03,250 --> 00:31:07,260
to do is scroll down to the bottom of this Table View.

432
00:31:07,260 --> 00:31:11,510
And then back up to top again.

433
00:31:11,510 --> 00:31:17,150
[ Pause ]

434
00:31:17,150 --> 00:31:23,920
Alright. So, you notice that we still have a little
bit of room for improvement but we're getting

435
00:31:23,920 --> 00:31:26,720
into the 50s now in our frames per second.

436
00:31:26,720 --> 00:31:31,020
So that's certainly a great improvement
over where we we're previously.

437
00:31:31,020 --> 00:31:33,410
Alright. So, back to you, Erik.

438
00:31:33,410 --> 00:31:34,560
>> Erik Neuenschwander: Thanks, Ben.

439
00:31:34,560 --> 00:31:37,750
That's actually the best behaved
that application spend with the FPS.

440
00:31:37,750 --> 00:31:39,380
It's actually a live demo there.

441
00:31:39,380 --> 00:31:42,700
And Ben practiced very well to get a
scroll that gives us some good numbers.

442
00:31:42,700 --> 00:31:47,100
So, you see we didn't quiet reach 60 there but
hopefully you could see the visual improvement

443
00:31:47,100 --> 00:31:49,120
when Ben went back to the application.

444
00:31:49,120 --> 00:31:53,370
And also we can see quantitatively that
we went to the 20s and 30s up to more

445
00:31:53,370 --> 00:31:56,650
in the 50s and so that's a big improvement.

446
00:31:56,650 --> 00:32:02,010
So, when you're thinking about scrolling you need to test
scrolling scenarios and you can to that with manual testing

447
00:32:02,010 --> 00:32:05,890
or using automated testing with
flip gestures to get scrolling

448
00:32:05,890 --> 00:32:10,230
through a data sets that's going to give a good scenario.

449
00:32:10,230 --> 00:32:14,650
When you're scrolling, you want to launch the Core
Animation Instrument and use it to measure FPS.

450
00:32:14,650 --> 00:32:19,020
And remember 60 FPS is kind of the gold
standard that's what you shooting for.

451
00:32:19,020 --> 00:32:24,370
Ben made a couple of changes there, first of all,
we have that API to reuse cells and so you can do

452
00:32:24,370 --> 00:32:29,320
that using the UITableView method and it with
style reuse identifier you just want to pass

453
00:32:29,320 --> 00:32:35,290
in a non-nil reuse identifier something that
identifies the kind of cell that that is.

454
00:32:35,290 --> 00:32:39,470
And then, instead of just unconditionally
allocing a cell you want

455
00:32:39,470 --> 00:32:44,100
to use the UITableView method
dequeueReusableCellWithIndentifier passing

456
00:32:44,100 --> 00:32:48,850
that same identifier and if you've already created
and stopped using a cell in the past you'll get back

457
00:32:48,850 --> 00:32:51,460
that instance and be able to avoid the allocation.

458
00:32:51,460 --> 00:32:55,740
Such one key thing that you should be doing pretty
much constantly whenever you have the same kind

459
00:32:55,740 --> 00:32:58,180
of cell that's going past in the list.

460
00:32:58,180 --> 00:33:01,990
But the other thing is to use that Color
Blended Layers and if I can make you sit

461
00:33:01,990 --> 00:33:05,400
through a rather bad rhyme you want the screen to be green.

462
00:33:05,400 --> 00:33:09,640
Right? You're trying to get as much as
green you can on the device because that's

463
00:33:09,640 --> 00:33:12,470
when the device is doing as little work as possible.

464
00:33:12,470 --> 00:33:18,230
And that's true even for you UILabel like Ben said just
through testing you can sometimes turn off opacity.

465
00:33:18,230 --> 00:33:20,400
Set Opaque is Yes by default.

466
00:33:20,400 --> 00:33:22,560
You should leave it that way whatever you can.

467
00:33:22,560 --> 00:33:28,520
And in fact even for you UILabel the system performs some
magic on your behalf, that even if you have opaque labels

468
00:33:28,520 --> 00:33:33,610
when you select in there's that blue background
it will still kind of bleed through the label even

469
00:33:33,610 --> 00:33:35,360
without you setting it to be transparent.

470
00:33:35,360 --> 00:33:39,450
So, there's no need to do that and I hope you
keep the screen green and keep your FPS up.

471
00:33:39,450 --> 00:33:41,200
So that's Smooth Scrolling.

472
00:33:41,200 --> 00:33:45,370
So, let me move on to talked about memory footprint.

473
00:33:45,370 --> 00:33:50,530
And keeping your memory footprint low is
also important because iOS has no swap.

474
00:33:50,530 --> 00:33:55,790
So you maybe familiar from the desktop that when
enough memory is needed that it exhaust physical,

475
00:33:55,790 --> 00:34:01,080
it will go out to the disk and that slows things down
somewhat but there is at least that escape valve.

476
00:34:01,080 --> 00:34:03,410
And on these devices, we don't have that.

477
00:34:03,410 --> 00:34:07,070
So that means that we can have memory
pressure meaning that we're just running

478
00:34:07,070 --> 00:34:10,000
out of any free memory available on the system.

479
00:34:10,000 --> 00:34:15,180
And so again, to preserve system stability the OS
will step in and it will terminate applications

480
00:34:15,180 --> 00:34:17,870
when the device gets under high memory pressure.

481
00:34:17,870 --> 00:34:20,970
The service that does that termination is called Jetsam.

482
00:34:20,970 --> 00:34:25,570
Jetsam is constantly watching memory pressure
and it provides instant lightweight termination

483
00:34:25,570 --> 00:34:28,620
of applications when memory pressure gets too high.

484
00:34:28,620 --> 00:34:32,020
This becomes even more important in multitasking scenarios.

485
00:34:32,020 --> 00:34:37,390
You think about multitasking we do have more applications
that are present in memory so that in general is going

486
00:34:37,390 --> 00:34:39,820
to cause more memory pressure on the device.

487
00:34:39,820 --> 00:34:46,390
So there are some capabilities to preserve applications
with smaller Footprints longer to keep more of them running.

488
00:34:46,390 --> 00:34:49,550
So that's a little bit of care to
keep your footprint low because on--

489
00:34:49,550 --> 00:34:54,140
especially on multitasking devices that
will help your apps stay around longer.

490
00:34:54,140 --> 00:34:59,080
The general reason to keep your memory footprint low is
that it is a shared resource and so you really want to use

491
00:34:59,080 --> 00:35:03,640
as little as possible because that will give
the over all best experience for the user.

492
00:35:03,640 --> 00:35:08,100
If you want to think of it just really tersely
it's that you can stay safe from Jetsam

493
00:35:08,100 --> 00:35:11,170
if your stay low it terms of your memory usage.

494
00:35:12,450 --> 00:35:17,810
There are three areas that we'd like to suggest
you look at as ways to keep your memory usage low.

495
00:35:17,810 --> 00:35:22,990
And the first to talk about is avoidable
spikes and then secondly we'll go into leaks.

496
00:35:22,990 --> 00:35:26,880
Leaks is probably the one your most
familiar with and that third term will talk

497
00:35:26,880 --> 00:35:29,000
about in some detail because it might be new to you.

498
00:35:29,000 --> 00:35:30,030
And that's abandoned memory.

499
00:35:30,030 --> 00:35:32,990
But let me start off talking about those avoidable spikes.

500
00:35:32,990 --> 00:35:36,550
And this is just a bunch of individual, maybe they are small

501
00:35:36,550 --> 00:35:39,710
but very brief allocations which
are all present simultaneously.

502
00:35:39,710 --> 00:35:43,840
So, you get a spike and if that spike
causes memory pressure then even though

503
00:35:43,840 --> 00:35:48,170
in the future a millisecond later you might have
gotten rid of all of it, the OS can't know that.

504
00:35:48,170 --> 00:35:51,510
And so if memory pressure gets
too high you'll be terminated.

505
00:35:51,510 --> 00:35:55,650
So, you want to avoid that and two cases
where it's likely to come up for you.

506
00:35:55,650 --> 00:35:58,730
Is first if your processing large quantities of data.

507
00:35:58,730 --> 00:36:04,690
One example that might come into mind is a video playback
but there you get to use the API in the OS which manages

508
00:36:04,690 --> 00:36:07,950
to play the whole video without
actually causing a lot memory use.

509
00:36:07,950 --> 00:36:11,210
But if you're ever processing large
quantities of data in some other way

510
00:36:11,210 --> 00:36:14,340
in some other way downloading a big
XML document or something like that.

511
00:36:14,340 --> 00:36:19,430
You want to try to approach it as small
individual batches that you can work on in pieces

512
00:36:19,430 --> 00:36:22,540
to keep your over all memory footprint low.

513
00:36:22,540 --> 00:36:27,230
Another case for memory pressure can come up for you
is when you are using a lot of Autorelease objects

514
00:36:27,230 --> 00:36:33,600
that causes object lifetime to grows somewhat and so the
key there is to find a way to reduce object lifetimes.

515
00:36:33,600 --> 00:36:36,630
Let me going to Autorelease in a little bit more detail.

516
00:36:36,630 --> 00:36:40,970
And so for some of you, you may think of
Autorelease as just a way to avoid retain/release.

517
00:36:40,970 --> 00:36:41,320
It's great.

518
00:36:41,320 --> 00:36:44,910
You call Autorelease magic happens and
you don't have to think about it anymore.

519
00:36:44,910 --> 00:36:50,100
But I'd like to kind of pitch it you in a little bit of
a different way which is to think of about Autorelease

520
00:36:50,100 --> 00:36:53,950
as a way to return objects without retaining them.

521
00:36:53,950 --> 00:36:58,050
That way you leave it up to your caller
to retain the object only if necessary.

522
00:36:58,050 --> 00:37:04,980
So, when you actually call Autorelease what happens
is that instance gets added to the NSAutoreleasePool

523
00:37:04,980 --> 00:37:10,880
and that Pool then is going to keep a whole list of these
objects and maintain them or maintain references to them

524
00:37:10,880 --> 00:37:16,150
so they can call release but that release
call happens at the next turn on the runloop.

525
00:37:16,150 --> 00:37:21,870
Of course when they call release as you probably know if the
retain count drops to zero the object will deallocated then

526
00:37:21,870 --> 00:37:26,830
but it's in that instant in between when you call
Autorelease in the turn of the runloop during

527
00:37:26,830 --> 00:37:30,790
that time you can have a bunch of
objects whose retain count is 1.

528
00:37:30,790 --> 00:37:35,800
And they will be deallocated when the
AutoreleasePool gets around to it but in the meantime

529
00:37:35,800 --> 00:37:40,670
when memory can actually spike as you have all
these objects that are soon to be deallocated.

530
00:37:40,670 --> 00:37:44,240
And so, Autorelease is the common cause of memory spikes.

531
00:37:44,240 --> 00:37:48,030
So, to show you an instrument that can help you
identify this and ways to get around it I'll turn

532
00:37:48,030 --> 00:37:50,910
over to Ben and the Allocations Instrument.

533
00:37:50,910 --> 00:37:51,600
>> Ben Weintraub: Alright.

534
00:37:51,600 --> 00:37:52,620
Thanks, Erik.

535
00:37:52,620 --> 00:37:57,870
So, you may have noticed previously when we launch
our application under the Allocations Instrument

536
00:37:57,870 --> 00:38:01,710
that we had this big spike in memory
right when we started up.

537
00:38:01,710 --> 00:38:06,730
So, we're going to try and investigate what's
going on there and see if we can fix it.

538
00:38:06,730 --> 00:38:13,880
So again, we are using the Allocations Instrument,
we're going to launch the right version of it and again,

539
00:38:13,880 --> 00:38:21,870
what Instruments is doing now is just collecting back
traces for every allocation that happens inside of this app.

540
00:38:21,870 --> 00:38:25,220
And this Timeline view is going to
show us graphical representation

541
00:38:25,220 --> 00:38:29,280
of the amount of memory that was used over time.

542
00:38:29,280 --> 00:38:36,530
OK. So, we have this big spike here and then it drops
back down as you just saw it do, so let me stop this trace

543
00:38:36,530 --> 00:38:41,200
and make this a little bigger so it's easier to see.

544
00:38:41,200 --> 00:38:48,990
OK. So, you can see that over the first couple of seconds of
our application's lifetime our memory usage is just growing

545
00:38:48,990 --> 00:38:52,370
and growing and then we have this big drop off here.

546
00:38:52,370 --> 00:38:59,690
So, if we want to figure out where all these allocations are
coming from again I'm going to use the inspection range tool

547
00:38:59,690 --> 00:39:02,590
in order to only look at a portion of the timeline.

548
00:39:02,590 --> 00:39:06,660
So, I've moved my cursor to right near the end of the spike.

549
00:39:06,660 --> 00:39:08,840
Oops, I want the other one actually.

550
00:39:08,840 --> 00:39:15,040
And now I'm selecting just the portion of
the timeline that involves that memory spike.

551
00:39:15,040 --> 00:39:20,240
And then, in this case I actually
want to look at this Call Trees View.

552
00:39:20,240 --> 00:39:25,640
So, the Call Trees View will show me the call
trees under which all these allocations took place.

553
00:39:25,640 --> 00:39:35,130
So, by default, as you'll see the separate by category box
is checked here which means that these Call Trees are sorted

554
00:39:35,130 --> 00:39:37,730
or bucketed by what type of allocation they where.

555
00:39:37,730 --> 00:39:41,470
I'm just going to turn that off because I
want to see them all aggregated together.

556
00:39:41,470 --> 00:39:47,700
And again I'm going to check hide system
libraries so I just see my application's code.

557
00:39:47,700 --> 00:39:52,110
Alright. So, now if I expand the heaviest path here,

558
00:39:52,110 --> 00:39:58,740
it looks like almost all these allocations are
again coming from my thumbnail OS size method.

559
00:39:58,740 --> 00:40:09,050
So, let's switch over to Xcode and take a look at
that method and see if we can improve upon it all.

560
00:40:09,050 --> 00:40:18,220
OK. So, looks like we lost our changes from the previous
time with dispatch and everything but that's OK.

561
00:40:18,220 --> 00:40:25,070
We can still show what we need to do in order
to get around that memory usage problem.

562
00:40:25,070 --> 00:40:30,580
So, what I'm going to do for each iteration of
this for loop when I generate these thumbnails,

563
00:40:30,580 --> 00:40:36,820
that's causing a bunch of Autoreleased
UIImages to be created and then those UIImages

564
00:40:36,820 --> 00:40:40,230
as Erik are all present simultaneously
and they don't get released

565
00:40:40,230 --> 00:40:42,530
until the Autorelease pool for this thread is popped.

566
00:40:42,530 --> 00:40:48,180
So, what I'm going to do in order to fix
this is go ahead and wrap each iteration

567
00:40:48,180 --> 00:40:50,620
of this for loop in its own Autorelease pool.

568
00:40:50,620 --> 00:40:56,470
So at the top of the for loop, I'm just
going to alloc init a new Autorelease pool

569
00:40:56,470 --> 00:40:59,700
and then down at the bottom, I'm
just going to call drain on it.

570
00:40:59,700 --> 00:41:04,490
So, one thing that's important to note
about this API is that when you call drain,

571
00:41:04,490 --> 00:41:07,020
that also releases the NSAutoreleasePool.

572
00:41:07,020 --> 00:41:12,110
It's a common misconception that you
need to call drain and then call release.

573
00:41:12,110 --> 00:41:13,700
You don't actually need to do that.

574
00:41:13,700 --> 00:41:16,480
You just call drain and then it'll release for you.

575
00:41:16,480 --> 00:41:21,060
Alright, so now, we have a modified
version of this app on the device.

576
00:41:21,060 --> 00:41:26,860
So, let's go back over to instruments and take a
look at how it compares with the original here.

577
00:41:26,860 --> 00:41:33,140
Alright. So, I'll just press Record
and start a new trace here.

578
00:41:33,140 --> 00:41:42,130
So, you can see that our memory usage is still growing
somewhat when we launched but that's to be expected.

579
00:41:42,130 --> 00:41:47,860
I mean we do need some memory to do our work
and it looks like we don't have the same kind

580
00:41:47,860 --> 00:41:50,760
of long-term growth that you saw previously.

581
00:41:50,760 --> 00:41:56,160
So, let me stop this trace and one of the nice things
about instruments is that you can take multiple runs

582
00:41:56,160 --> 00:41:59,940
of the same operation and then compare them side by side.

583
00:41:59,940 --> 00:42:07,400
So, by expanding this disclosure triangle over here, I can
now see my previous run in comparison to the current run

584
00:42:07,400 --> 00:42:12,230
and I can see that I've reduced my
peak memory usage substantially.

585
00:42:12,230 --> 00:42:17,080
So previously, we're up at about
2.8 megabytes and now it looks

586
00:42:17,080 --> 00:42:22,130
like our peak memory usage doesn't
get more than 1.4 megabytes or so.

587
00:42:22,130 --> 00:42:27,770
So, that's an example of how you can use
the allocations instrument to diagnose

588
00:42:27,770 --> 00:42:31,590
and help fix memory-related spikes in your application.

589
00:42:31,590 --> 00:42:32,900
So back to you, Erik.

590
00:42:32,900 --> 00:42:34,240
>> Erik Neuenschwander: Thanks, Ben.

591
00:42:34,240 --> 00:42:38,430
You can really see when you compare between those
two runs a big difference between the memory sections

592
00:42:38,430 --> 00:42:43,150
so that's a great way, probably one of the clearest
ways that you can see your memory usage change.

593
00:42:43,150 --> 00:42:49,050
So, to talk, to kind of wrap up
Autorelease, you should use Autorelease.

594
00:42:49,050 --> 00:42:53,850
It's a feature but it is a little bit more
expensive than your typical retain-release and so,

595
00:42:53,850 --> 00:42:57,870
you only want to use Autorelease when it's
appropriate and there are really two cases you need

596
00:42:57,870 --> 00:43:01,060
to consider for that, your code and API usage.

597
00:43:01,060 --> 00:43:05,790
In your code, you'd like to use Autorelease at
framework boundaries with inside your project.

598
00:43:05,790 --> 00:43:09,820
Basically, if you're ever handing
back an object to some other object,

599
00:43:09,820 --> 00:43:13,360
that's going to maintain the lifetime
of your return value on its own.

600
00:43:13,360 --> 00:43:17,700
If you're ever having some say, member of
a class and you're going to maintain that.

601
00:43:17,700 --> 00:43:21,230
You're going to allocate, say in your
init, release it in your dealloc.

602
00:43:21,230 --> 00:43:27,060
This is something where you control the entire lifetime
of that object and so, you can just use retain and release

603
00:43:27,060 --> 00:43:30,750
to manage it that way and get a little bit
more efficiency and some very good control

604
00:43:30,750 --> 00:43:33,440
over how long that object will be around.

605
00:43:33,440 --> 00:43:37,350
But the other cases when you're using
API like in Ben's example there.

606
00:43:37,350 --> 00:43:41,710
API will return to you an Autoreleased object and
well, there's really nothing you can do about that.

607
00:43:41,710 --> 00:43:47,940
They did it because they wanted you to be able to retain
it if necessary but in that case, as Ben showed you,

608
00:43:47,940 --> 00:43:53,380
you can use nested Autorelease pools to get some
control over that and really shorten down the lifetime

609
00:43:53,380 --> 00:43:57,290
so that we were still seeing those individual
spikes as the thumbnails loaded but overall,

610
00:43:57,290 --> 00:44:00,080
there wasn't that same sort of
triangular memory growth, right?

611
00:44:00,080 --> 00:44:08,070
And that'll help keep your overall maximum memory lower and
that'll keep you avoiding jetsam and keep your app around.

612
00:44:08,070 --> 00:44:10,940
So, let's talk about that second
area to keep your memory usage low

613
00:44:10,940 --> 00:44:13,260
and leaks is probably something you're familiar with.

614
00:44:13,260 --> 00:44:19,980
In fact, if you attended the advanced memory-- the advanced
instruments talked that focused on memory performance.

615
00:44:19,980 --> 00:44:22,050
They gave a really great demo of the leaks instruments.

616
00:44:22,050 --> 00:44:26,520
So, we're not going to do that here but I'll just
kind of give you the quick summary which is that well,

617
00:44:26,520 --> 00:44:29,180
leaks are just memory that you can't get at anymore.

618
00:44:29,180 --> 00:44:29,940
It's gone.

619
00:44:29,940 --> 00:44:33,820
You have no references to it and
so, we have an instrument for that.

620
00:44:33,820 --> 00:44:37,350
It's the leaks instrument and if
you launch your application with it.

621
00:44:37,350 --> 00:44:41,080
It's able to give you all the points
at which that memory was allocated.

622
00:44:41,080 --> 00:44:45,550
So, the point where the memory is allocated
is never really going to be your bug.

623
00:44:45,550 --> 00:44:51,180
After all, you probably allocated that object for
some reason but it does give you context to understand

624
00:44:51,180 --> 00:44:56,590
where your problem is likely to happen and you can dig in
and actually look at the individual retains and releases

625
00:44:56,590 --> 00:45:00,650
and the code where that happens to try
to understand where things went awry.

626
00:45:00,650 --> 00:45:03,550
There are two common ways in which
people end up with memory leaks.

627
00:45:03,550 --> 00:45:06,130
The first of which is just an unbalanced retain-release.

628
00:45:06,130 --> 00:45:09,110
Typically, well more retains than releases.

629
00:45:09,110 --> 00:45:14,040
But there's actually a subset of that which in the
new Objective-C 2.0 run time you can hit which is

630
00:45:14,040 --> 00:45:18,100
when you're using properties and that's
if you forget to release the value

631
00:45:18,100 --> 00:45:21,710
that that property had before retaining
the new value that came in.

632
00:45:21,710 --> 00:45:26,390
So a little trick that you need to make sure that somebody
isn't setting the property to the same value and again,

633
00:45:26,390 --> 00:45:30,750
that other talk which focuses on the leaks instrument
can show you very clearly in code how to do that.

634
00:45:30,750 --> 00:45:34,210
But using the leaks instrument, you can
quickly get on top of memory leaks in your app

635
00:45:34,210 --> 00:45:37,830
and use that again to keep your memory usage well.

636
00:45:37,830 --> 00:45:42,500
So let me talk about that third one which is
abandoned memory and this may be a new term to you

637
00:45:42,500 --> 00:45:45,740
but abandoned memory is almost like a leak but not quite.

638
00:45:45,740 --> 00:45:48,330
It's a memory which you still have an act of reference too.

639
00:45:48,330 --> 00:45:51,920
So you can still access it but
at this point, it's left over.

640
00:45:51,920 --> 00:45:56,180
It's a memory that you are actually never going
to choose to access again, and so therefore,

641
00:45:56,180 --> 00:46:00,900
you might as well release it, free it up and
get it out of your application's memory space.

642
00:46:00,900 --> 00:46:07,730
So the allocations instrument is the right tool for the job
here and it offers an additional feature called Heapshot.

643
00:46:07,730 --> 00:46:13,110
Using Heapshot, you can take a snapshot of while
you're heap and then run through a set of operations

644
00:46:13,110 --> 00:46:17,940
and take a second snapshot and then compare
the heap between those two operations.

645
00:46:17,940 --> 00:46:20,990
And what you're looking for are
differences that you don't expect.

646
00:46:20,990 --> 00:46:26,500
You don't really expect that that object was still hanging
around in that second Heapshot and you can then figure

647
00:46:26,500 --> 00:46:29,410
out how to free it and keep your memory usage low.

648
00:46:29,410 --> 00:46:31,190
So I'm going to send it back to Ben one more time.

649
00:46:31,190 --> 00:46:34,330
We have one more little problem in our
demo application and he'll show you how

650
00:46:34,330 --> 00:46:37,860
to use Heapshot in the allocations instrument.

651
00:46:37,860 --> 00:46:38,700
>> Ben Weintraub: Alright, great.

652
00:46:38,700 --> 00:46:39,860
Thanks Erik.

653
00:46:39,860 --> 00:46:44,790
So, we're going to use the allocations
instrument again as Erik mentioned and I'm going

654
00:46:44,790 --> 00:46:49,540
to select my application and just go ahead and launch it.

655
00:46:49,540 --> 00:46:55,660
So, the best way to go about finding abandoned memory
problems is to choose some common user scenario

656
00:46:55,660 --> 00:46:59,820
in your application and then to run that scenario once.

657
00:46:59,820 --> 00:47:04,580
Mark the heap using this Mark Heap button here.

658
00:47:04,580 --> 00:47:08,520
And then run the scenario again
and mark the heap a second time.

659
00:47:08,520 --> 00:47:13,220
And then, instruments will allow you to look
at the deltas between those two operations.

660
00:47:13,220 --> 00:47:16,420
So, let's switch over to the device
for a second and I'm just going

661
00:47:16,420 --> 00:47:19,380
to show you the operation that I've chosen to do here.

662
00:47:19,380 --> 00:47:21,880
So it's a pretty common one in my app.

663
00:47:21,880 --> 00:47:26,610
I'm just going to select one of
these compositions, select the tile,

664
00:47:26,610 --> 00:47:31,440
cycle through a few colors here and
then go back to the main table view.

665
00:47:31,440 --> 00:47:37,310
So as a user, I wouldn't expect there to be any increased
memory usage from just doing that operation once.

666
00:47:37,310 --> 00:47:43,110
So after I've done that once, let's switch back
over to instruments and I'm going to mark the heap.

667
00:47:43,110 --> 00:47:47,320
And then I'm just going to do that one more time quickly.

668
00:47:47,320 --> 00:47:56,550
Alright, so I'm just selecting a tile, cycling through
these colors, and now I'm back to my table view.

669
00:47:56,550 --> 00:48:01,120
Alright, so now, I'm going to mark the heap a second time.

670
00:48:01,120 --> 00:48:06,530
Alright, so let's stop this trace
and make it a little bigger again.

671
00:48:06,530 --> 00:48:14,100
So, you can see these red flags in the timeline
here and those represent the points in the timeline

672
00:48:14,100 --> 00:48:19,370
when I took those two Heapshots and the first
one is labeled as baseline by instruments.

673
00:48:19,370 --> 00:48:24,580
So if I expand that out then each of these
lines corresponds again to some type of object

674
00:48:24,580 --> 00:48:30,290
in my application's memory space and I could see how many
of them were live and how much memory they're taking up.

675
00:48:30,290 --> 00:48:33,330
So that I'm not particularly interested in
at the moment because what I really want

676
00:48:33,330 --> 00:48:36,740
to see is the delta between these two points in time.

677
00:48:36,740 --> 00:48:41,280
So in order to see that, I want to look at
this Heapshot 1 snapshot here so I'm going

678
00:48:41,280 --> 00:48:44,700
to click the arrow next to it in order to focus on it.

679
00:48:44,700 --> 00:48:50,280
So now, all of the objects that are listed here are
actually objects that were added at some point between,

680
00:48:50,280 --> 00:48:54,910
or they were allocated at some point between these
two red flags on the timeline and are still alive

681
00:48:54,910 --> 00:48:58,300
at the point when I took the second snapshot.

682
00:48:58,300 --> 00:49:07,240
So, it looks like the biggest by far category of
allocations I have here under the non-object category.

683
00:49:07,240 --> 00:49:13,550
So I'm going to expand that out and I'm just
going to sort of scan down this heap growth column

684
00:49:13,550 --> 00:49:19,830
until I see something that's big and then there's a
40-kilobyte allocation out of a total of about 255 kilobytes

685
00:49:19,830 --> 00:49:25,230
of heap growth between those two flags and
so that certainly stands out to my eye.

686
00:49:25,230 --> 00:49:30,920
So I'm going to select that allocation and
then click on the expanded detail view here.

687
00:49:30,920 --> 00:49:35,510
And what that will do is bring in the
backtrace under which this object was allocated.

688
00:49:35,510 --> 00:49:43,800
So if you take a look at this backtrace, you see that we're
calling malloc from this tile backing initWithImage method.

689
00:49:43,800 --> 00:49:51,810
So tile backing objects in my application are actually
grayscale bitmaps that are used to generate those threshold

690
00:49:51,810 --> 00:49:54,290
and colorized tiles that you see in the app.

691
00:49:54,290 --> 00:50:00,410
And I know that I'm doing some caching of those
objects in my imageForTile with size method.

692
00:50:00,410 --> 00:50:06,260
So let's head over to Xcode and take a
look at the cache strategy that I have.

693
00:50:06,260 --> 00:50:12,970
OK, so here's my imageForTile with size method and this
is actually a reasonable place the cache and the reason

694
00:50:12,970 --> 00:50:17,740
for that is when I adjust the threshold as
you saw in the very beginning of the demo.

695
00:50:17,740 --> 00:50:23,040
I don't want to have to regenerating the
grayscale version of these tiles every time.

696
00:50:23,040 --> 00:50:24,890
So there's some reason to have this cache.

697
00:50:24,890 --> 00:50:29,340
And so what I'm going is I'm just generating
these strings that are cache identifiers

698
00:50:29,340 --> 00:50:31,550
and I'm using those as the keys in my cache.

699
00:50:31,550 --> 00:50:34,200
I have just a mutable dictionary here.

700
00:50:34,200 --> 00:50:40,460
And then the values are the tile backing objects themselves
which can be quite large because they're again bitmaps.

701
00:50:40,460 --> 00:50:42,720
And so in this case, it looks like what I'm--

702
00:50:42,720 --> 00:50:47,100
the way I'm generating those cache keys
is by taking the three color components,

703
00:50:47,100 --> 00:50:53,130
the RG&B components for the tile color
that I'm generating along with the width

704
00:50:53,130 --> 00:50:55,540
and height of the tile that I'm generating.

705
00:50:55,540 --> 00:50:58,510
But as I mentioned before, these
are actually grayscale bitmaps.

706
00:50:58,510 --> 00:51:04,900
So the tile backing object for a red tile is going to be
exactly the same as the tile backing object for a blue tile

707
00:51:04,900 --> 00:51:10,190
and there's no real reason for me
to have to cache them separately.

708
00:51:10,190 --> 00:51:16,710
What I end up doing in this cache is just caching
the same thing multiple times under different names

709
00:51:16,710 --> 00:51:18,900
and this is actually a common problem with caches.

710
00:51:18,900 --> 00:51:24,360
So I'm going to go ahead and get ride of
these portions of the cache identifier

711
00:51:24,360 --> 00:51:27,420
and change my format strings so I no longer need those.

712
00:51:27,420 --> 00:51:31,740
Alright, so that should help somewhat.

713
00:51:31,740 --> 00:51:37,770
The other thing to keep in mind though is that I'm caching
in one of my model objects and these model objects stay

714
00:51:37,770 --> 00:51:41,570
around for the lifetime of my application in my case.

715
00:51:41,570 --> 00:51:46,600
And so there's actually no reason to be caching
these tile backings once the user has gone back

716
00:51:46,600 --> 00:51:50,470
to that main table view screen in my app.

717
00:51:50,470 --> 00:51:58,620
They can just be regenerated the next time
that the user selects a different composition.

718
00:51:58,620 --> 00:52:05,200
So, the next thing I want to do is actually add a method
that will allow me to flush out this cache entirely.

719
00:52:05,200 --> 00:52:06,470
So, that's pretty simple.

720
00:52:06,470 --> 00:52:08,780
I just added a flush caches method.

721
00:52:08,780 --> 00:52:18,870
All it does is to release my cache and set it nil and
that I need to add that to the header file as well.

722
00:52:18,870 --> 00:52:24,880
Alright, and then the final thing I need to do is
actually call this method from my view controller.

723
00:52:24,880 --> 00:52:31,100
So in my compose view controller which is what the view
controller that handles the screen with all the tiles on it.

724
00:52:31,100 --> 00:52:38,870
I have a view will disappear method and at the end of that
method, I'm just going to go ahead and call flush caches

725
00:52:38,870 --> 00:52:45,610
on the current composition and that will make sure that
those tile backing objects don't hang around for too long.

726
00:52:45,610 --> 00:52:49,490
Alright, so we're running a little bit short on time.

727
00:52:49,490 --> 00:52:58,800
So I have a saved version of this trace
that I'm just going ahead to show you.

728
00:52:58,800 --> 00:53:07,240
Alright. So this is-- I performed
the same operation twice and again,

729
00:53:07,240 --> 00:53:10,860
we can see this nice side by side view with instruments.

730
00:53:10,860 --> 00:53:12,040
Oops, alright.

731
00:53:12,040 --> 00:53:24,910
So here's the-- below, you can see the original version and
you can see there are memories growing constantly overtime

732
00:53:24,910 --> 00:53:33,380
and above, you can see the version with the changes
that we just made and so you can actually tell that--

733
00:53:33,380 --> 00:53:39,250
you can just see visually that we're not growing our
memory usage overtime as we were in the previous version.

734
00:53:39,250 --> 00:53:45,940
And then the other thing, the other way that quantified
this is-- so if we look at our original trace,

735
00:53:45,940 --> 00:53:51,450
we see that the heap growth, for
Heapshot is listed as about 430k.

736
00:53:51,450 --> 00:53:58,940
If we look at our second trace, we can see
that the heap growth is listed at about 13k.

737
00:53:58,940 --> 00:54:01,410
So that's a pretty significant improvement.

738
00:54:01,410 --> 00:54:08,140
So that's an example of how you can use the
new Heapshot feature that's new in iOS 4

739
00:54:08,140 --> 00:54:10,690
to help diagnose abandoned memory problems.

740
00:54:10,690 --> 00:54:12,020
So back to you Erik.

741
00:54:12,020 --> 00:54:13,470
>> Erik Neuenschwander: Alright, thanks, Ben.

742
00:54:13,470 --> 00:54:16,470
We have a lot of demos there, so I
appreciate you guys not applauding

743
00:54:16,470 --> 00:54:19,510
but that was Ben's last run so let's give him hand.

744
00:54:19,510 --> 00:54:24,270
[ Applause ]

745
00:54:24,270 --> 00:54:27,430
Alright, we'll just finish up with a couple
of comments on that and prioritizing.

746
00:54:27,430 --> 00:54:32,340
So, when we're talking about keeping your memory usage
low, I want to remind you about jetsam being out there.

747
00:54:32,340 --> 00:54:35,270
It will kill your application if
memory pressure gets too high.

748
00:54:35,270 --> 00:54:38,790
So you can focus on three areas:
leaks, abandonments, and spikes.

749
00:54:38,790 --> 00:54:43,190
We talked about all three of those and showed you
instruments that you can use to get on top of that.

750
00:54:43,190 --> 00:54:48,170
The leaks instrument is great for leaks and the
allocations instruments is all around useful including

751
00:54:48,170 --> 00:54:53,120
that Heapshot feature to show you as Ben
showed you overactive caches or other ways

752
00:54:53,120 --> 00:54:55,620
in which you're abandoning memory which you can reclaim.

753
00:54:55,620 --> 00:54:58,760
A way that you can often end up
with spikes is through Autorelease.

754
00:54:58,760 --> 00:55:04,020
So you want to target, limit your use of Autorelease
but if you're using an API which is a heavy user

755
00:55:04,020 --> 00:55:08,760
of Autorelease objects then you can have nested
Autorelease pools and that works out great.

756
00:55:08,760 --> 00:55:13,310
So, we know that you have things to do other than
just work on performance in your applications

757
00:55:13,310 --> 00:55:17,670
so let's talk a little bit about how to prioritize
performance issues relative to the features

758
00:55:17,670 --> 00:55:19,360
and bugs and everything else that you have to do.

759
00:55:19,360 --> 00:55:26,390
And so at least on the iOS team, we believe more or
less that there can be show stopping performance issues.

760
00:55:26,390 --> 00:55:29,880
Ones where performance is so bad,
we won't even ship the release.

761
00:55:29,880 --> 00:55:34,770
And part of how we do that is by establishing goals
early on in the release and getting consensus around that

762
00:55:34,770 --> 00:55:37,170
so that everybody knows what we're trying to head for.

763
00:55:37,170 --> 00:55:42,150
And so that's certainly something you can do
within your development team to get agreement

764
00:55:42,150 --> 00:55:45,070
about what performance issues you've really got to fix.

765
00:55:45,070 --> 00:55:48,740
But to prioritize them, you really
want to look at it in two dimensions.

766
00:55:48,740 --> 00:55:52,210
First is just the frequency at which
the performance problem comes up.

767
00:55:52,210 --> 00:55:56,490
May be it's a scenario which is very common, for
instance launch or scrolling through your main list

768
00:55:56,490 --> 00:55:59,910
of composition say, in our demo application.

769
00:55:59,910 --> 00:56:04,320
And so if it's a common scenario that means
it's going to hit your user pretty frequently.

770
00:56:04,320 --> 00:56:08,280
You also want to think about not just the
scenario but how often it performs poorly.

771
00:56:08,280 --> 00:56:14,380
Maybe it's just slow every so often and that's going
to be less severe than if it's slow every time.

772
00:56:14,380 --> 00:56:17,390
And the second dimension, you want
to consider is the severity.

773
00:56:17,390 --> 00:56:21,970
If the application is unresponsive for several
seconds, well, that's going to be pretty bad

774
00:56:21,970 --> 00:56:26,970
or may be it's single-digit FIPS in an animation
and we're here to tell you that that looks awful.

775
00:56:26,970 --> 00:56:32,710
Or it could be that one of those things they talk about,
the watchdog or the jetsam is happening to your application

776
00:56:32,710 --> 00:56:38,260
and that's bad because to a user, those
terminations look exactly like crashes.

777
00:56:38,260 --> 00:56:39,760
Your user can't tell.

778
00:56:39,760 --> 00:56:44,030
And so it may be that if you're getting feedback from
your customers that your application crashes a lot

779
00:56:44,030 --> 00:56:48,910
and you can't figure out what's going on, it
may be that your top crash isn't a crash at all.

780
00:56:48,910 --> 00:56:52,080
It's either one of these watchdogs or these jetsams.

781
00:56:52,080 --> 00:56:56,700
We have one more tool that will work out
well for you there and that's iTunes Connect.

782
00:56:56,700 --> 00:57:01,050
You already know about iTunes Connect, it's how you
get your applications on the store in the first place.

783
00:57:01,050 --> 00:57:07,190
But I hope you've also noticed that we offer third party
crash reports and that crash report gives you, of course,

784
00:57:07,190 --> 00:57:09,410
traditional crashes but down at the bottom,

785
00:57:09,410 --> 00:57:14,580
there's also this bar that shows you the
frequency of different kinds of diagnostic events.

786
00:57:14,580 --> 00:57:20,560
Now, this is picked from just one internal Apple app
on one of the QA servers and you can see in this case,

787
00:57:20,560 --> 00:57:23,680
crashes are the dominant feature of this application.

788
00:57:23,680 --> 00:57:29,750
93% of the time it's in actual crash but we have
7% where a watchdog is happening and then at least

789
00:57:29,750 --> 00:57:33,030
in this case, we have a very few or no jetsam events.

790
00:57:33,030 --> 00:57:34,920
Your bar is probably going to look different

791
00:57:34,920 --> 00:57:38,950
and if that blue bar is small then you
want to dig in to the other two areas.

792
00:57:38,950 --> 00:57:44,890
So for watchdogs, also on that same report page, there's
a breakdown of the different kinds of watchdog events

793
00:57:44,890 --> 00:57:49,820
that are generated, say launched or quit and there's
that button to the right, it says Download Report.

794
00:57:49,820 --> 00:57:54,200
If you click that, you will get reports
from your users out in the field

795
00:57:54,200 --> 00:57:56,560
and it will have the backtrace of your application.

796
00:57:56,560 --> 00:58:00,390
You'll be able to see what it was so busy
doing that the application had to come in

797
00:58:00,390 --> 00:58:03,040
or that the operating system had to come in and watchdog it.

798
00:58:03,040 --> 00:58:08,960
So that can be very helpful for understanding how your
application is getting watchdog of what's going on.

799
00:58:08,960 --> 00:58:15,200
That other class is the jetsam events and there
we offer two pieces of data for you to look at.

800
00:58:15,200 --> 00:58:19,820
One of which is the average memory usage of
your application at the time it was jettisoned.

801
00:58:19,820 --> 00:58:25,330
So if you see that number and it looks a lot higher than
the numbers that you're seeing in your internal testing,

802
00:58:25,330 --> 00:58:31,330
that means that maybe you're not using a realistic dataset
for your users or that you have some database that's growing

803
00:58:31,330 --> 00:58:34,020
without bound and taking up a lot
of memory in your application.

804
00:58:34,020 --> 00:58:37,080
So you want to kind of think about
the test scenarios that you're doing.

805
00:58:37,080 --> 00:58:41,850
That second number, the largest, gives you an
idea of maybe there's some overall memory leak

806
00:58:41,850 --> 00:58:43,680
that you just haven't caught in your application.

807
00:58:43,680 --> 00:58:49,350
So you can use this if you see a lot of green in
that bar to decide to go investigate the memory usage

808
00:58:49,350 --> 00:58:54,240
of your application and as far as your users are
concerned, this is the same thing as fixing a crash.

809
00:58:54,240 --> 00:58:55,820
So it's really worth doing.

810
00:58:55,820 --> 00:59:02,160
Let's wrap up and I hope that you either
came in believing or you'll leave a believer

811
00:59:02,160 --> 00:59:04,540
that performance is critical for your application.

812
00:59:04,540 --> 00:59:08,440
We showed you a lot of different instruments and
ways to use them that you can measure and get data

813
00:59:08,440 --> 00:59:13,890
to improve performance in your app and I want to remind
you one last time that performance testing really needs

814
00:59:13,890 --> 00:59:18,380
to be done on the device and ideally, you should
do it on the oldest device you're going to support.

815
00:59:18,380 --> 00:59:24,740
Three key areas we talked about, launched, very
important, scrolling first constantly and memory usage.

816
00:59:24,740 --> 00:59:27,040
Like I said, your application will get terminated.

817
00:59:27,040 --> 00:59:32,300
So, if you develop clear performance goals then you won't
fight at the end of your development cycle about what to fix

818
00:59:32,300 --> 00:59:36,290
and please visit iTunes Connect
for performance-related reports.

819
00:59:36,290 --> 00:59:41,990
Let me point out three related sessions, we have one later
today and also one tomorrow morning that are advanced going

820
00:59:41,990 --> 00:59:44,620
into much greater depth about performance issues.

821
00:59:44,620 --> 00:59:47,230
Also, if you're a heavy core data user, you can optimize it.

822
00:59:47,230 --> 00:59:50,760
You can find out about that at the talk and there
are three other ones, there are instrument talks

823
00:59:50,760 --> 00:59:53,120
which have already happened sadly so those are on video.

824
00:59:53,120 --> 00:59:58,180
There's more information with these evangelists, I hope you
know, documentation on the website, a link you can click.

825
00:59:58,180 --> 00:59:58,440
Let me--

