1
00:00:07,040 --> 00:00:07,710
>> Ed Voas: Well, good afternoon.

2
00:00:07,710 --> 00:00:13,180
And welcome to Session 136, Calendar
Integration With EventKit.

3
00:00:13,180 --> 00:00:17,870
I'm Ed Voas, and I work on Calendar for iOS.

4
00:00:17,870 --> 00:00:23,700
So, in this session, you're going to learn about EventKit,
what it is, and how you can use it in your applications.

5
00:00:23,700 --> 00:00:26,220
So, first, what is it?

6
00:00:26,220 --> 00:00:33,380
Well, first and foremost, it's a high level API and allows
you to get access to the calendar data on the device.

7
00:00:33,380 --> 00:00:37,040
It's split into two parts, mostly as
a function of the way we built our OS.

8
00:00:37,040 --> 00:00:39,260
But we have a non-UI side and a UI side.

9
00:00:39,260 --> 00:00:45,030
So, in EventKit, we have all of the APIs that allow you
to get at the calendar data itself, you know, calendars,

10
00:00:45,030 --> 00:00:52,530
events, etc. And, in the UI side, we offer a couple of view
controllers which you can use to display and edit events.

11
00:00:52,530 --> 00:00:54,470
It's not a low-level syncing API, though.

12
00:00:54,470 --> 00:00:56,180
It's very high level.

13
00:00:56,180 --> 00:01:02,970
But for anything that you modify in one of our, you know,
calendars, if you happen to modify an event that's in, like,

14
00:01:02,970 --> 00:01:06,400
an Exchange calendar or CalDAV calendar,
syncing will just happen automatically.

15
00:01:06,400 --> 00:01:09,100
You don't need to think about it at all.

16
00:01:09,100 --> 00:01:12,710
One thing I want to call up is
that, you know, it isn't your data.

17
00:01:12,710 --> 00:01:14,620
It's really the user's data.

18
00:01:14,620 --> 00:01:18,920
So if you're going to modify the calendar
in some way, make it painfully obvious

19
00:01:18,920 --> 00:01:22,280
to the user that that's what you're doing.

20
00:01:22,280 --> 00:01:26,070
So I want to show a brief picture
of the way this is put together.

21
00:01:26,070 --> 00:01:30,910
So, ultimately, we have a calendar database; and that
lives off in a protected area of the file system.

22
00:01:30,910 --> 00:01:33,230
So it's sandboxed off from your application.

23
00:01:33,230 --> 00:01:35,800
So how do we talk to it?

24
00:01:35,800 --> 00:01:40,700
Well, through EventKit, what we do is we
actually talk to a daemon called iCalX SD.

25
00:01:40,700 --> 00:01:43,350
And that's the thing that actually talks to the database.

26
00:01:43,350 --> 00:01:49,100
iCalX SD and the sync daemons are pretty much the only
things that are allowed to talk to the database directly.

27
00:01:49,100 --> 00:01:53,530
So let's start delving into some APIs.

28
00:01:53,530 --> 00:01:59,830
So here's just an object diagram showing
all the major players that we have here.

29
00:01:59,830 --> 00:02:03,070
EKRecurrenceDayOfWeek on the bottom
there, I'm not going to talk about.

30
00:02:03,070 --> 00:02:05,850
But I'm just showing it here because
it's one of our classes.

31
00:02:05,850 --> 00:02:08,980
So the first one I want to talk about is EKEventStore.

32
00:02:08,980 --> 00:02:11,450
This is basically where it all starts.

33
00:02:11,450 --> 00:02:13,240
It's your connection to the database.

34
00:02:13,240 --> 00:02:17,530
When you instantiate one of these objects,
you are effectively opening the database.

35
00:02:17,530 --> 00:02:24,240
And, just like the slide a couple slides
ago, because we're talking to a daemon,

36
00:02:24,240 --> 00:02:27,460
it will actually spin the daemon up on demand, if necessary.

37
00:02:27,460 --> 00:02:29,450
Most of the time, it's probably running.

38
00:02:29,450 --> 00:02:32,840
But just be aware it's not exactly a lightweight operation.

39
00:02:32,840 --> 00:02:36,920
So, generally, you want to have these
objects around for as long as you can.

40
00:02:36,920 --> 00:02:44,560
The other factor in this is that, when you get objects
out of this EKEventStore, they're tied to this EventStore.

41
00:02:44,560 --> 00:02:48,240
So if you close it, if you release it
and then you try to open it back up again

42
00:02:48,240 --> 00:02:51,380
and save an event, for example, you won't be able to do it.

43
00:02:51,380 --> 00:02:55,590
They're tied to the EventStore from which they came.

44
00:02:55,590 --> 00:02:58,850
And to get one alloc init and you have an EventStore.

45
00:02:58,850 --> 00:03:02,930
Hooray. So now we'll look at Calendar.

46
00:03:02,930 --> 00:03:05,310
So, EKCalendar.

47
00:03:05,310 --> 00:03:12,120
So, obviously, we support multiple calendar
types on iOS: Exchange, CalDAV, MobileMe,

48
00:03:12,120 --> 00:03:16,560
etc. Again, sync is automatic for these types.

49
00:03:16,560 --> 00:03:19,840
We support read-only versus read/write calendars.

50
00:03:19,840 --> 00:03:22,140
So most calendars are read/write.

51
00:03:22,140 --> 00:03:25,730
You can add events to them and
change the events that are in them.

52
00:03:25,730 --> 00:03:30,200
But we also have read-only calendars; and those
would be such things as Subscribe calendars

53
00:03:30,200 --> 00:03:35,310
or the Birthday calendar, which is a new calendar in iOS 4.

54
00:03:35,310 --> 00:03:39,020
One thing that I want to point out is you
can't create new calendars in this release.

55
00:03:39,020 --> 00:03:43,590
It's definitely a limitation, but just be aware of it.

56
00:03:43,590 --> 00:03:45,600
We also have the notion of a default calendar.

57
00:03:45,600 --> 00:03:49,030
And it usually sets this in settings, as you can see here.

58
00:03:49,030 --> 00:03:52,020
If they have more than one calendar, they
can set which calendar is the default.

59
00:03:52,020 --> 00:03:55,870
And when you're in, like, the Calendar
application and you add a new event,

60
00:03:55,870 --> 00:03:57,640
this is the calendar that it's automatically set to.

61
00:03:57,640 --> 00:04:00,230
And you have access to this calendar.

62
00:04:00,230 --> 00:04:03,490
So, to get a calendar, it's really simple.

63
00:04:03,490 --> 00:04:07,750
First off, you just create an instance of
EKEventStore at some point in your application.

64
00:04:07,750 --> 00:04:10,370
Using that EventStore, you just call store.calendars.

65
00:04:10,370 --> 00:04:13,060
And now you have an array of calendars.

66
00:04:13,060 --> 00:04:19,370
Or, if you want the default calendar that I just
talked about, you can call defaultCalendarForNewEvents.

67
00:04:19,370 --> 00:04:23,880
Once you have your calendar, you can get
information from it: title, color, type.

68
00:04:23,880 --> 00:04:28,540
Type would be something such as Exchange or CalDAV.

69
00:04:28,540 --> 00:04:34,940
And, then, if you to want find out if it's read-only,
you can query the allowsContentModifications property.

70
00:04:34,940 --> 00:04:37,510
And if that returns yes, it's writable.

71
00:04:37,510 --> 00:04:42,420
[ Pause ]

72
00:04:42,420 --> 00:04:47,420
Okay. Now let's start talking about
EKEvent, which is the core of most of this.

73
00:04:47,420 --> 00:04:50,420
An instance of EKEvent represents an occurrence of an event.

74
00:04:50,420 --> 00:04:55,190
So if you have an event that repeats
weekly, each one of those events

75
00:04:55,190 --> 00:04:58,550
that would occur is represented by an individual EKEvent.

76
00:04:58,550 --> 00:05:00,770
And, from there, you can get and set most of the properties

77
00:05:00,770 --> 00:05:04,490
that you're intimately familiar
with, probably from using the device.

78
00:05:04,490 --> 00:05:07,560
So, obviously, you have title, location, start and end date.

79
00:05:07,560 --> 00:05:09,010
You can set whether it's an all-day event.

80
00:05:09,010 --> 00:05:14,470
You can set how it repeats, alarms, calendar, availability.

81
00:05:14,470 --> 00:05:15,540
We also -- obviously, notes.

82
00:05:15,540 --> 00:05:17,140
You can't see it because it's scrolled off screen.

83
00:05:17,140 --> 00:05:18,870
But we also allow things like status.

84
00:05:18,870 --> 00:05:20,110
You can get the status of an event.

85
00:05:20,110 --> 00:05:24,770
You can find out if it's canceled.

86
00:05:24,770 --> 00:05:27,290
So creating events is dead simple.

87
00:05:27,290 --> 00:05:31,390
Obviously, we start with our EventStore again.

88
00:05:31,390 --> 00:05:33,860
We just call EKEvent eventWithEventStore.

89
00:05:33,860 --> 00:05:35,520
So now we've created a new event.

90
00:05:35,520 --> 00:05:37,660
It's bound to that EventStore.

91
00:05:37,660 --> 00:05:39,500
And then we set some data.

92
00:05:39,500 --> 00:05:42,030
So title, start date, end date, and calendar.

93
00:05:42,030 --> 00:05:46,090
And here I'm setting the calendar to
be the defaultCalendarForNewEvents.

94
00:05:46,090 --> 00:05:51,670
Now, startDate, endDate in Calendar are required.

95
00:05:51,670 --> 00:05:56,350
So if you're going to try to save one of
these events, you must fill these fields in.

96
00:05:56,350 --> 00:06:01,340
And, if you don't, it will actually give you an error; and
it will probably tell you exactly what you didn't fill in.

97
00:06:01,340 --> 00:06:07,670
And, to save the event, you call
EKEventStore saveEvent span error.

98
00:06:07,670 --> 00:06:11,660
The span, whenever you're saving a new event,
really doesn't matter what you pass there.

99
00:06:11,660 --> 00:06:13,740
But it does matter when you modify and remove events.

100
00:06:13,740 --> 00:06:15,830
And we're going to see how it affects things later on.

101
00:06:15,830 --> 00:06:25,120
Every event in the database is-- has a unique identifier.

102
00:06:25,120 --> 00:06:26,740
So it's unique across the entire database.

103
00:06:26,740 --> 00:06:32,620
It's only valid if the event has
actually been saved into the EventStore.

104
00:06:32,620 --> 00:06:34,780
But they can change.

105
00:06:34,780 --> 00:06:38,970
If you happen to move an event
across calendars, specifically,

106
00:06:38,970 --> 00:06:42,050
it's across accounts, but we don't
expose accounts right now.

107
00:06:42,050 --> 00:06:48,020
But if it moves calendars, you might want to refetch the
ID to make sure that you have the latest ID for that item.

108
00:06:48,020 --> 00:06:51,270
Now, of course, it goes into the calendar,
anybody could have changed that, any other app.

109
00:06:51,270 --> 00:06:54,420
So maybe the user saw it in calendar
and did something with it.

110
00:06:54,420 --> 00:07:02,170
In that case, you might not have -- you might not be able
to find that event anymore, because now it's been changed.

111
00:07:02,170 --> 00:07:05,060
And, if that's the case, you might
want to resort to sort of a backup plan

112
00:07:05,060 --> 00:07:09,140
and just save off some identifying information
about the event and search for it later.

113
00:07:09,140 --> 00:07:15,240
And to get the eventIdentifier, it's just .eventIdentifier.

114
00:07:15,240 --> 00:07:17,980
We're clever that way.

115
00:07:17,980 --> 00:07:22,630
Deleting events, pretty much just as easy as saving events.

116
00:07:22,630 --> 00:07:24,090
So we have our EventStore.

117
00:07:24,090 --> 00:07:27,880
And, then, here we're actually going to look the
event up by its identifier that we just talked about.

118
00:07:27,880 --> 00:07:32,930
So EKEventStore eventWithIdentifier,
pass the identifier, get an event.

119
00:07:32,930 --> 00:07:34,440
Fair trade.

120
00:07:34,440 --> 00:07:38,510
And then you just call removeEvent span error.

121
00:07:38,510 --> 00:07:42,440
And, again, the span is meaningful
mostly for repeating events.

122
00:07:42,440 --> 00:07:46,040
But, for single events, you can just kind of pass anything.

123
00:07:46,040 --> 00:07:52,260
This event is usually the most common thing to pass.

124
00:07:52,260 --> 00:07:55,680
Okay. Every event can have an alarm.

125
00:07:55,680 --> 00:08:01,550
The alarms are generally relative to the start
date, and you specify them in negative seconds.

126
00:08:01,550 --> 00:08:04,980
They always display the standard calendar alert right now.

127
00:08:04,980 --> 00:08:06,600
So enjoy it.

128
00:08:06,600 --> 00:08:13,930
One thing to note is that different calendars can have
different limits to the number of alarms that they can have.

129
00:08:13,930 --> 00:08:18,570
For example, a CalDAV calendar can
have pretty much infinite alarms.

130
00:08:18,570 --> 00:08:21,780
And an Exchange calendar, we only have one alarm.

131
00:08:21,780 --> 00:08:26,830
And our UI enforces this, but we don't currently
have a way to expose that through our API right now.

132
00:08:26,830 --> 00:08:31,380
So it's best to assume that there's just one
that you can set, at least for the duration.

133
00:08:31,380 --> 00:08:37,070
Sometimes there's confusion between
alarms and UILocalNotifications.

134
00:08:37,070 --> 00:08:41,730
Like when EventKit was first kind of
introduced to developers, people thought, Oh,

135
00:08:41,730 --> 00:08:46,160
I can use that to put up an alert and, you
know, then I can call my application later.

136
00:08:46,160 --> 00:08:48,000
And that's not what it's used for.

137
00:08:48,000 --> 00:08:51,830
I mean, if you're going to -- if you're
going to make an alarm, you're going to --

138
00:08:51,830 --> 00:08:53,240
first off, you're going to have to make an event.

139
00:08:53,240 --> 00:08:54,710
That event's going to be in the calendar.

140
00:08:54,710 --> 00:08:56,020
You're just going to see that.

141
00:08:56,020 --> 00:08:57,520
They could delete that.

142
00:08:57,520 --> 00:09:02,500
And, then, when you press the Action button
on that alert that comes up, it's going to go

143
00:09:02,500 --> 00:09:06,000
and show you the event, which is probably not what you want.

144
00:09:06,000 --> 00:09:09,220
If you want something more general, you
should be using UILocalNotifications.

145
00:09:09,220 --> 00:09:12,190
And they don't involve the calendar, and
the Action button will just call your app.

146
00:09:12,190 --> 00:09:18,450
So, if it doesn't belong in the calendar,
you shouldn't be using EventKit for it.

147
00:09:18,450 --> 00:09:20,440
To add an alarm, it's pretty simple.

148
00:09:20,440 --> 00:09:24,400
To create one, you just say EKAlarm alarmWithRelativeOffset.

149
00:09:24,400 --> 00:09:29,930
-900 in this case means 15 minutes
before the start of the meeting.

150
00:09:29,930 --> 00:09:31,880
Call EKEvent addAlarm.

151
00:09:31,880 --> 00:09:37,110
And, then, again, our favorite saveEvent span error.

152
00:09:40,730 --> 00:09:42,640
Okay. Now we're going to touch on participants.

153
00:09:42,640 --> 00:09:48,430
A participant is basically either the
organizer or an invitee of an event.

154
00:09:48,430 --> 00:09:50,890
With these objects, you can check
to see what their status is.

155
00:09:50,890 --> 00:09:53,910
You can see whether they've accepted the
meeting, whether they've declined it,

156
00:09:53,910 --> 00:09:56,370
or maybe they've just marked it tentative.

157
00:09:56,370 --> 00:10:00,120
But not all servers tell us the
information, so you might get unknown.

158
00:10:00,120 --> 00:10:06,180
So, if you have an event that's on Exchange 2003
or 2007, you won't be able to get that data.

159
00:10:06,180 --> 00:10:09,520
If it's 2010 or later or if it's
on CalDAV, you will get that data.

160
00:10:09,520 --> 00:10:13,770
So just be aware that sometimes
you might not always get the data.

161
00:10:13,770 --> 00:10:16,150
Once you have the participant, you
can get an Address Book record.

162
00:10:16,150 --> 00:10:19,050
And we do that by email lookup.

163
00:10:19,050 --> 00:10:21,100
So it's kind of a loose coupling.

164
00:10:21,100 --> 00:10:22,300
It's not really very tight.

165
00:10:22,300 --> 00:10:25,740
So it does a pretty decent job, though.

166
00:10:25,740 --> 00:10:28,870
And they're read-only in this release.

167
00:10:28,870 --> 00:10:35,080
So you can't modify a participant nor
can you set participants on an event.

168
00:10:35,080 --> 00:10:38,040
And the implication there is it
means to, at least programmatically,

169
00:10:38,040 --> 00:10:41,830
you can't create invites in this 1.0 release of the API.

170
00:10:41,830 --> 00:10:42,770
You can through the UI.

171
00:10:42,770 --> 00:10:45,420
If you use our UI, it does support invite creation.

172
00:10:45,420 --> 00:10:50,190
But, right now, we don't have the APIs available to you.

173
00:10:50,190 --> 00:10:54,700
And to get at these things, it's just
event.organizer, event.attendees.

174
00:10:54,700 --> 00:10:56,890
Simple. All right.

175
00:10:56,890 --> 00:11:02,190
So now we've kind of covered the basic
-- the basic concept of everything.

176
00:11:02,190 --> 00:11:06,250
So, you know, now you want to see what can we do with
the APIs that we've already seen in a real application.

177
00:11:06,250 --> 00:11:07,840
And with me to help do that is Glen Steele.

178
00:11:07,840 --> 00:11:08,510
Glen.

179
00:11:08,510 --> 00:11:13,250
[ Applause ]

180
00:11:13,250 --> 00:11:14,130
>> Glen Steele: Thanks, Ed.

181
00:11:14,130 --> 00:11:18,750
So, so far you've seen most of the basic APIs that
are available to you as developers in EventKit.

182
00:11:18,750 --> 00:11:21,110
But, of course, we want to flesh
those out in some examples for you.

183
00:11:21,110 --> 00:11:23,320
So we're going to show you a demo.

184
00:11:23,320 --> 00:11:28,010
And, for the purpose of this demo, I'd like you
to imagine for a moment that you're a loan shark.

185
00:11:28,010 --> 00:11:31,720
And, for the parents among you,
there's no imagination necessary.

186
00:11:31,720 --> 00:11:35,110
But, for our purposes, just think
of yourself as a loan shark.

187
00:11:35,110 --> 00:11:39,790
And you're no fool, so you want to keep track of these
loans that you hand out to people pretty closely.

188
00:11:39,790 --> 00:11:42,880
So the good news is that there's an
app for that, and we can help you.

189
00:11:42,880 --> 00:11:43,930
And it's called Sharkster.

190
00:11:43,930 --> 00:11:46,050
So I'm going to show it to you now.

191
00:11:46,050 --> 00:11:47,230
Okay. So I'll just launch it.

192
00:11:47,230 --> 00:11:49,980
And this is a table-driven application.

193
00:11:49,980 --> 00:11:54,060
And it's created using -- it's backed by Core Data.

194
00:11:54,060 --> 00:11:55,640
And it's pretty simple.

195
00:11:55,640 --> 00:12:00,500
We can just tap on any one of our loans
here to see the details of the loan.

196
00:12:00,500 --> 00:12:02,590
We get the contact of the person, the amount.

197
00:12:02,590 --> 00:12:05,980
And we can drill down a little bit
further and see the payment schedule

198
00:12:05,980 --> 00:12:11,200
and how much each payment it is --
each payment is and when it's due.

199
00:12:11,200 --> 00:12:15,190
So we can back out here and hit the plus
button if we want to create a new one.

200
00:12:15,190 --> 00:12:17,630
And we can choose a contact if we want.

201
00:12:17,630 --> 00:12:22,160
And then choose the amount and, you know,
some -- whatever interest rate we want.

202
00:12:22,160 --> 00:12:27,920
And then we can pick the payment schedule, you know,
whether it's daily, weekly, monthly, what have you.

203
00:12:27,920 --> 00:12:28,950
And then save that.

204
00:12:28,950 --> 00:12:35,140
And, then, to delete, it's just a simple, you know, swipe --
whoops -- swipe to delete paradigm or edit or what have you.

205
00:12:35,140 --> 00:12:38,020
So that's the basics of the app.

206
00:12:38,020 --> 00:12:42,510
And so now I'd just like to show you a little
bit about the Xcode project that makes this up.

207
00:12:42,510 --> 00:12:47,090
[ Pause ]

208
00:12:47,090 --> 00:12:48,300
Okay. So here we are in Xcode.

209
00:12:48,300 --> 00:12:50,460
And I'll just show you a few things.

210
00:12:50,460 --> 00:12:53,920
The first thing is, in the resources
here, let's take a look at the data model.

211
00:12:53,920 --> 00:12:57,640
As I said, this is a Core Data driven application.

212
00:12:57,640 --> 00:12:59,800
So we just take a look.

213
00:12:59,800 --> 00:13:04,590
What I want you to see here is just basically
we're dealing with loans and payments.

214
00:13:04,590 --> 00:13:11,790
And we have NSManagedObject subclasses that
deal with these and we pass these around.

215
00:13:11,790 --> 00:13:14,620
So the loans have a one-to-many
relationship with the payments.

216
00:13:14,620 --> 00:13:18,370
And so, if you see, these are what we're moving around.

217
00:13:18,370 --> 00:13:24,670
And, then, in our supporting classes folder here,
this is just basically what makes up the structure

218
00:13:24,670 --> 00:13:32,470
of the application, the table views and the
cells and etc. And, then, in EventKit stuff,

219
00:13:32,470 --> 00:13:34,480
we have this thing called a Loan Event Scheduler.

220
00:13:34,480 --> 00:13:40,240
And so this represents the funnel point for
us for all our interactions with EventKit.

221
00:13:40,240 --> 00:13:43,810
And this kind of thing may or may not
make sense for you in your application.

222
00:13:43,810 --> 00:13:49,700
But, for us, it's a nice way to just sort of coalesce
all our EventKit interactions into one place.

223
00:13:49,700 --> 00:13:50,850
All right.

224
00:13:50,850 --> 00:13:54,750
So what are we going to do with EventKit
to make our app a little bit better?

225
00:13:54,750 --> 00:14:01,550
Well, the obvious thing is, in our payments, we'd like to
be able to schedule each one of those into the calendar.

226
00:14:01,550 --> 00:14:06,640
And so the place to do that is when the user taps Save,
that's when we go and create those payment objects.

227
00:14:06,640 --> 00:14:09,200
And we'd like to actually put those
into the calendar as they do that.

228
00:14:09,200 --> 00:14:17,320
So saving happens in our Loan View
Controller in the aptly named save method.

229
00:14:17,320 --> 00:14:19,190
And this thing is pretty simple right now.

230
00:14:19,190 --> 00:14:23,400
All it does is call this generate payments helper method.

231
00:14:23,400 --> 00:14:30,790
And that thing goes out and creates the individual Core Data
payment objects and calculates the date on which each one

232
00:14:30,790 --> 00:14:38,240
of those is going to land and then -- and puts those into
the database and relates them back to our loan object.

233
00:14:38,240 --> 00:14:43,140
And, then, once we finish doing that, we just
call the delegate, which basically has the effect

234
00:14:43,140 --> 00:14:46,310
of dismissing us and calling a save on the database.

235
00:14:46,310 --> 00:14:46,590
All right.

236
00:14:46,590 --> 00:14:49,730
So how are we going to modify this thing to add scheduling?

237
00:14:49,730 --> 00:14:53,660
Well, let's go ahead and implement a new save method.

238
00:14:53,660 --> 00:14:57,570
And this is it here, and I just
left the old one up for comparison.

239
00:14:57,570 --> 00:15:00,240
So we're still going to generate those payments.

240
00:15:00,240 --> 00:15:03,950
But, before we do that, we're going to
create one of our loan event schedulers.

241
00:15:03,950 --> 00:15:09,810
Once we do that, we'll call schedule all events
for payments and pass in the ordered payments.

242
00:15:09,810 --> 00:15:16,480
And the job of this thing is to go in and basically create
all the EKEvents for each one of those individual payments.

243
00:15:16,480 --> 00:15:21,820
Then it's just a matter of releasing -- releasing
that and then we still call the delegate.

244
00:15:21,820 --> 00:15:26,390
So I'm going to delete that old method and save this.

245
00:15:26,390 --> 00:15:30,880
And, then, now we're going to go ahead and
delete this new method in our event scheduler.

246
00:15:30,880 --> 00:15:31,990
All right.

247
00:15:31,990 --> 00:15:34,680
So let's declare that.

248
00:15:34,680 --> 00:15:38,420
And I'm going to create an instance
variable called EventStore.

249
00:15:38,420 --> 00:15:40,270
So this is our EKEventStore.

250
00:15:40,270 --> 00:15:44,740
And as Ed mentioned, this represents
our connection to the calendar database.

251
00:15:44,740 --> 00:15:50,840
So now that we've done that, let's
go and initialize this thing.

252
00:15:50,840 --> 00:15:57,220
And, then, don't forget to release it.

253
00:15:57,220 --> 00:16:00,950
And now we've got all our setup out
of the way, we can actually go ahead

254
00:16:00,950 --> 00:16:02,620
and implement this new method that we have.

255
00:16:02,620 --> 00:16:05,590
So, as I said, it's called schedule all events for payments.

256
00:16:05,590 --> 00:16:07,770
It takes an array of payments.

257
00:16:07,770 --> 00:16:11,510
And what we're going to do is just
iterate through each one of those.

258
00:16:11,510 --> 00:16:14,560
And, as we do that, we're going to create a new EKEvent.

259
00:16:14,560 --> 00:16:19,180
So we do that with EKEvent, eventWithEventStore.

260
00:16:19,180 --> 00:16:23,280
And then we set the properties on that new event.

261
00:16:23,280 --> 00:16:28,350
Now, as Ed mentioned, the required ones are
the calendar, the start date, and the end date.

262
00:16:28,350 --> 00:16:30,510
So we make sure we set those.

263
00:16:30,510 --> 00:16:35,610
And we're just going to use the default calendar for
new events, which is that property on the EventStore.

264
00:16:35,610 --> 00:16:39,390
And that's the default calendar
that the user sets in Settings

265
00:16:39,390 --> 00:16:43,180
or is just provided automatically
if they only have one calendar.

266
00:16:43,180 --> 00:16:46,360
So, once we've done that, we can set the title.

267
00:16:46,360 --> 00:16:50,530
And we've just got a helper method
that returns the string for the title

268
00:16:50,530 --> 00:16:55,180
and includes basically the contact
name and the amount for that payment.

269
00:16:55,180 --> 00:16:57,620
And that's it for setting those properties.

270
00:16:57,620 --> 00:17:02,570
But what we'd also like to do is set an alarm so
that, you know, when we wake up in the morning,

271
00:17:02,570 --> 00:17:08,150
we get all the alarms for the people who owe us money and
we can, you know, send a muscle to go and extract them.

272
00:17:08,150 --> 00:17:12,300
And we're going to do that with just a relative
offset of 0; because we want those to fire,

273
00:17:12,300 --> 00:17:16,850
you know, right away first thing in the morning.

274
00:17:16,850 --> 00:17:22,630
Okay. So now that we've set our new alarm,
we can call saveEvent and providing a span --

275
00:17:22,630 --> 00:17:28,030
and, as Ed said, we'll go into those a little
more later -- and a pointer to an error.

276
00:17:28,030 --> 00:17:31,610
And we check the return Boolean.

277
00:17:31,610 --> 00:17:38,280
And if it didn't save and there's an error, in our case,
we're just going to print out that error description.

278
00:17:38,280 --> 00:17:40,420
You may need to do more in your app.

279
00:17:40,420 --> 00:17:44,300
And, then, the last thing we need to
do is save aside that eventIdentifier.

280
00:17:44,300 --> 00:17:47,630
So now that we've created our new
event, we want to reference that later.

281
00:17:47,630 --> 00:17:54,280
So we're going to take the eventIdentifier that
we created and put that into our payment object.

282
00:17:54,280 --> 00:17:54,890
Okay, great.

283
00:17:54,890 --> 00:17:57,770
So now we're creating new EKEvents.

284
00:17:57,770 --> 00:17:59,410
We're storing them in the calendar.

285
00:17:59,410 --> 00:18:02,520
But there's one thing we're missing
and that's deletion, right?

286
00:18:02,520 --> 00:18:05,700
So deletion happens on that root view controller.

287
00:18:05,700 --> 00:18:13,720
And, specifically, it happens here in the commit
editing style for row and index path method.

288
00:18:13,720 --> 00:18:18,950
So this project was created from, you know, one
of our Xcode templates, and it's already populated

289
00:18:18,950 --> 00:18:25,310
with basically everything that's needed
to remove those loans from our database.

290
00:18:25,310 --> 00:18:28,730
But we want to add just one more thing
here and that's to delete all the payments

291
00:18:28,730 --> 00:18:31,730
that are associated with that loan in the calendar.

292
00:18:31,730 --> 00:18:35,360
So, to do that, we're going to
create a new loan event scheduler

293
00:18:35,360 --> 00:18:41,170
and then call a new method called delete all events
for payments and pass in those ordered payments.

294
00:18:41,170 --> 00:18:41,480
All right.

295
00:18:41,480 --> 00:18:42,800
So we're done here.

296
00:18:42,800 --> 00:18:46,120
Let's go and declare that new method.

297
00:18:47,500 --> 00:18:52,660
And let's implement it.

298
00:18:52,660 --> 00:18:54,670
Okay. So, again, this is pretty simple.

299
00:18:54,670 --> 00:18:58,510
We're going to iterate in a four loop
through each one of those payments,

300
00:18:58,510 --> 00:19:03,360
get our pointer to the EKEvent using
EventStore, eventWithIdentifier.

301
00:19:03,360 --> 00:19:07,360
Remember we saved this aside when
we created our event before.

302
00:19:07,360 --> 00:19:11,550
And then it's just a matter of
calling EventStore removeEvent,

303
00:19:11,550 --> 00:19:15,680
and we're just using that EKSpanThisEvent
span for the moment.

304
00:19:15,680 --> 00:19:23,180
And same thing, pass in an error, check the result,
and print out or log any issues that might come up.

305
00:19:23,180 --> 00:19:23,650
Okay, great.

306
00:19:23,650 --> 00:19:25,810
So it looks like we're done.

307
00:19:25,810 --> 00:19:26,280
And, phew.

308
00:19:26,280 --> 00:19:26,940
It builds.

309
00:19:26,940 --> 00:19:28,140
That's good.

310
00:19:28,140 --> 00:19:31,820
And we're going to build that and
send it over to the device.

311
00:19:31,820 --> 00:19:37,720
So what we'd expect to happen now is, when we create a
new event, we should see that pop up in our loan table.

312
00:19:37,720 --> 00:19:43,420
Should be able to look at that and then flip over to
the calendar and those new events should show up for us.

313
00:19:43,420 --> 00:19:46,240
Let's see if it works.

314
00:19:46,240 --> 00:19:49,910
So let's create one for Claire.

315
00:19:49,910 --> 00:19:56,080
We'll do 5,000 and some exorbitant interest rate.

316
00:19:56,080 --> 00:19:57,600
[ Laughter ]

317
00:19:57,600 --> 00:19:58,530
I know. Ouch, right?

318
00:19:58,530 --> 00:20:09,800
We're just going to choose a loan length of three days,
and we'll just do the three payments, 2,000 apiece.

319
00:20:09,800 --> 00:20:10,680
So we saved it.

320
00:20:10,680 --> 00:20:13,350
Here's our new loan.

321
00:20:13,350 --> 00:20:15,020
And pops up here.

322
00:20:15,020 --> 00:20:16,670
We can see the loan payment schedule.

323
00:20:16,670 --> 00:20:18,550
Looks like it's going to show up tomorrow.

324
00:20:18,550 --> 00:20:21,830
But, of course, the real question
is: Did it show up in the calendar?

325
00:20:21,830 --> 00:20:24,560
So let's flip over the calendar and, hey, presto.

326
00:20:24,560 --> 00:20:25,820
There it is.

327
00:20:25,820 --> 00:20:31,040
So our payment shows up there and it looks good to go.

328
00:20:31,040 --> 00:20:35,280
And we can see on each payment we created that alert,

329
00:20:35,280 --> 00:20:39,370
and it shows that we're going to get
an alert on the day of the event.

330
00:20:39,370 --> 00:20:40,720
Okay. Good stuff.

331
00:20:40,720 --> 00:20:42,510
So now --

332
00:20:42,510 --> 00:20:46,480
[ Applause ]

333
00:20:46,480 --> 00:20:49,130
-- Now we're going to try and delete
that, and let's see if this works.

334
00:20:49,130 --> 00:20:52,580
So we'll delete that and flip back to the calendar.

335
00:20:52,580 --> 00:20:57,890
And after that snapshot loads, we see
those events have now disappeared.

336
00:20:57,890 --> 00:21:00,350
Okay, great.

337
00:21:01,720 --> 00:21:05,650
So that's adding and deleting simple events using EventKit.

338
00:21:05,650 --> 00:21:11,370
And, to do that, to insert an event, we just
create a new EKEvent using EKEventStore.

339
00:21:11,370 --> 00:21:17,600
Set the properties on those events on the
event and then we save using EKEvent saveEvent.

340
00:21:17,600 --> 00:21:19,850
Now, to delete, it's pretty simple too.

341
00:21:19,850 --> 00:21:25,830
We can fetch the event using the eventIdentifier that we
saved aside and then just remove using EKEvent removeEvent.

342
00:21:25,830 --> 00:21:27,420
So that the adding and removing.

343
00:21:27,420 --> 00:21:28,510
Back to you, Ed.

344
00:21:28,510 --> 00:21:32,040
[ Applause ]

345
00:21:32,040 --> 00:21:34,870
>> Ed Voas: Thanks, Glen.

346
00:21:34,870 --> 00:21:36,850
Okay. Now we've seen easy events.

347
00:21:36,850 --> 00:21:37,740
Let's get a little harder.

348
00:21:37,740 --> 00:21:40,370
We're going to talk about recurrence rules.

349
00:21:40,370 --> 00:21:43,690
So recurrence rules ultimately
tell you how an event repeats.

350
00:21:43,690 --> 00:21:47,790
And, you know, our UI, as you can see here,
does really simple rules every day, every week,

351
00:21:47,790 --> 00:21:53,400
etc. But the API will allow you to do far more
complex things, such as the examples here.

352
00:21:53,400 --> 00:21:57,410
So we're going to just do a simple one.

353
00:21:57,410 --> 00:22:00,100
We actually have two init functions on recurrence rule.

354
00:22:00,100 --> 00:22:03,000
We have a simple one and then we
have, like, the mind-blowing one.

355
00:22:03,000 --> 00:22:05,850
So we're going to go with the simple one for right now.

356
00:22:05,850 --> 00:22:08,150
So let's -- we want to create a
weekly meeting that never ends.

357
00:22:08,150 --> 00:22:09,370
[ Laughter ]

358
00:22:09,370 --> 00:22:16,240
So we use EKRecurrenceRule initWithRecurrenceFrequency
internal end.

359
00:22:16,240 --> 00:22:20,820
So, in this case, we're going to pass a recurrence
frequency of weekly and an interval of 1.

360
00:22:20,820 --> 00:22:21,420
So that's every week.

361
00:22:21,420 --> 00:22:25,630
If we passed an interval of 2, that's every
other week, etc., etc. And the end is nil.

362
00:22:25,630 --> 00:22:28,790
So no end in sight for this meeting, sorry to say.

363
00:22:28,790 --> 00:22:36,770
And we just set our recurrence rule; and,
again, our favorite, saveEvent, span and error.

364
00:22:36,770 --> 00:22:40,590
But, you know, sometimes you want this meeting to end maybe.

365
00:22:40,590 --> 00:22:42,090
So there's two ways to do that.

366
00:22:42,090 --> 00:22:47,490
The first is by creating -- well, in every case,
you always create an EKRecurrenceEnd object.

367
00:22:47,490 --> 00:22:50,500
But the two ways that you can do
that is the first one is by dates.

368
00:22:50,500 --> 00:22:55,270
You can call EKRecurrenceEnd, recurrenceEndWithEndDate,
pass the date.

369
00:22:55,270 --> 00:22:58,840
And, then, the second variance is a number of times.

370
00:22:58,840 --> 00:23:02,550
So you can say EKRecurrenceEnd
recurrenceEndWithOccurrenceCount.

371
00:23:02,550 --> 00:23:08,440
So, in this case, I want the meeting
to happen five times and that's it.

372
00:23:08,440 --> 00:23:11,290
And just like last time, call the same init method.

373
00:23:11,290 --> 00:23:16,100
But this time we're passing the end
object in for the end parameter.

374
00:23:16,100 --> 00:23:17,910
Fancy that way.

375
00:23:17,910 --> 00:23:25,860
And then we just set the rule and save the event.

376
00:23:25,860 --> 00:23:29,140
Okay. So we've kind of discussed how to get events in.

377
00:23:29,140 --> 00:23:30,050
How do we get events out?

378
00:23:30,050 --> 00:23:33,880
Well, we've already seen one way, and that's by ID.

379
00:23:33,880 --> 00:23:36,700
So I mentioned every event has an identifier.

380
00:23:36,700 --> 00:23:41,220
And you can use that by calling EKEventStore
eventWithIdentifier and get the event back.

381
00:23:41,220 --> 00:23:43,720
That will give you the very first occurrence of that event.

382
00:23:43,720 --> 00:23:48,350
So, if it was a repeating event, it will be
the very first, you know, occurrence of that.

383
00:23:48,350 --> 00:23:51,120
So, if it was somebody's birthday,
it's actually the day of their birth,

384
00:23:51,120 --> 00:23:53,900
not the anniversary of their birth many years later.

385
00:23:53,900 --> 00:24:00,050
But what you're probably going to use more
often than not is search for your predicate,

386
00:24:00,050 --> 00:24:02,460
especially if you want to show, you
know, something across a date range.

387
00:24:02,460 --> 00:24:06,890
So this -- we offer one predicate right now,
predicateForEventsWithStartDate, endDate, and calendars.

388
00:24:06,890 --> 00:24:11,930
So you can search across a date range
and across a number of calendars.

389
00:24:11,930 --> 00:24:14,520
And because it's the only predicate we have right now,

390
00:24:14,520 --> 00:24:19,500
if you want to do a more fine-grained search,
you will have to postfilter that list.

391
00:24:19,500 --> 00:24:23,460
So an example here is to just create one.

392
00:24:23,460 --> 00:24:27,670
You go EKEventStore predicateForEventsWithStartDate,
endDate, and calendars.

393
00:24:27,670 --> 00:24:29,570
And I'm just, you know, whatever
the start date and end date are.

394
00:24:29,570 --> 00:24:31,030
And then I'm passing store.calendars.

395
00:24:31,030 --> 00:24:34,760
So I want to search across all calendars.

396
00:24:34,760 --> 00:24:36,650
You then call eventsMatchingPredicate.

397
00:24:36,650 --> 00:24:41,890
That will go out, find the appropriate
events, and return them as an array.

398
00:24:41,890 --> 00:24:44,520
But that array has no guaranteed order.

399
00:24:44,520 --> 00:24:46,960
So now you probably want to sort it.

400
00:24:46,960 --> 00:24:52,350
Well, we have a convenience method for that
on EKEvent called compareStartDateWithEvent.

401
00:24:52,350 --> 00:24:55,260
So all you need to do is just make
a mutable copy of the array

402
00:24:55,260 --> 00:24:58,890
and then just call sortUsingSelector
passing compareStartDateWithEvent.

403
00:24:58,890 --> 00:25:01,320
And now everything's in start order -- in start date order,

404
00:25:01,320 --> 00:25:07,570
which is probably the most common
way that you'd want to sort them.

405
00:25:07,570 --> 00:25:11,260
Now, eventsWithPredicate is synchronous.

406
00:25:11,260 --> 00:25:16,580
It will block your app for as long as it takes to operate,
and it could take almost no time or it could take a lot

407
00:25:16,580 --> 00:25:20,640
of time, depending on what you're
searching for and how big your database is.

408
00:25:20,640 --> 00:25:24,020
So more often than not, you're going
to want to do this asynchronously.

409
00:25:24,020 --> 00:25:26,470
And we don't offer any specific asynchronous function.

410
00:25:26,470 --> 00:25:33,440
Instead, you know, we say, if you want asynchronous
behavior, you know, use an asynchronous mechanism

411
00:25:33,440 --> 00:25:37,930
such as NSOperation or my favorite, dispatch_async.

412
00:25:37,930 --> 00:25:40,030
So, if you're familiar with Grand Central Dispatch --

413
00:25:40,030 --> 00:25:46,370
I think there was a session on it yesterday
-- dispatch_async is my new best friend.

414
00:25:46,370 --> 00:25:50,710
So when you're doing -- I'm just going to
show you an example of using dispatch_async.

415
00:25:50,710 --> 00:25:56,950
So, whenever you want to start some
sort of task or whatever in Dispatch,

416
00:25:56,950 --> 00:26:00,090
all you need to do is get your
hands on a queue to run it on.

417
00:26:00,090 --> 00:26:03,730
So the first thing I'm going to do is
what's called dispatch_get_global_queue.

418
00:26:03,730 --> 00:26:06,870
I'm using the standard priority queue.

419
00:26:06,870 --> 00:26:09,420
Then I call dispatch_async, passing the queue.

420
00:26:09,420 --> 00:26:13,410
So you want to send a block of code over to this queue.

421
00:26:13,410 --> 00:26:14,220
And what does it do?

422
00:26:14,220 --> 00:26:15,750
Exactly what you already saw.

423
00:26:15,750 --> 00:26:19,710
We're just going to call EventStore eventsMatchingPredicate.

424
00:26:19,710 --> 00:26:24,430
Now, someplace over in the system
there's this thread that has this array.

425
00:26:24,430 --> 00:26:26,700
Now, how do we get them back to the main thread?

426
00:26:26,700 --> 00:26:28,430
Dispatch_async.

427
00:26:28,430 --> 00:26:30,530
And here we just pass get_main_queue instead.

428
00:26:30,530 --> 00:26:32,210
So we want to throw it back to the main thread.

429
00:26:32,210 --> 00:26:36,700
And we're going to call a method on
our object called setEvents:array.

430
00:26:36,700 --> 00:26:39,780
It's very simple.

431
00:26:39,780 --> 00:26:44,530
I mean, the last three lines could actually be replaced
with something like perform selector on main thread.

432
00:26:44,530 --> 00:26:47,670
But dispatch_async is far more flexible,
because it doesn't restrict you to the number

433
00:26:47,670 --> 00:26:50,510
of parameters that you can pass to that selector.

434
00:26:50,510 --> 00:26:55,050
[ Pause ]

435
00:26:55,050 --> 00:26:56,470
Okay. Modifying events.

436
00:26:56,470 --> 00:27:02,180
I mean, modifying events is basically you get an event; you
set the properties; you save it; and, well, you're done.

437
00:27:02,180 --> 00:27:04,390
Okay. And that's fine for simple events.

438
00:27:04,390 --> 00:27:09,710
But repeating events get a little complicated.

439
00:27:09,710 --> 00:27:13,470
When you -- this is where we talked
about the span parameter.

440
00:27:13,470 --> 00:27:16,810
When you modify a repeating event, the
span parameter then really matters.

441
00:27:16,810 --> 00:27:20,900
And you -- and we offer two of them:
SpanThisEvent, SpanFutureEvents.

442
00:27:20,900 --> 00:27:25,550
And they correspond to the two buttons that you
see there on that standard alert sheet that we put

443
00:27:25,550 --> 00:27:30,350
up whenever you do modify a repeating
event in the Calendar application.

444
00:27:30,350 --> 00:27:31,480
They behave very differently.

445
00:27:31,480 --> 00:27:35,390
And we're going to see an example of how they behave.

446
00:27:35,390 --> 00:27:36,440
They're very valid.

447
00:27:36,440 --> 00:27:38,770
I mean, both are equally valid
whenever you change something.

448
00:27:38,770 --> 00:27:45,030
However, if you change the recurrence information on an
event, then only the EKSpanFutureEvents span is valid

449
00:27:45,030 --> 00:27:50,090
because SpanThisEvent actually doesn't
make any sense in that context.

450
00:27:50,090 --> 00:27:52,890
So let's take the case of simple detachment.

451
00:27:52,890 --> 00:27:59,650
So if I -- if I save an event and I say SpanThisEvent,
that creates what's called a detached event.

452
00:27:59,650 --> 00:28:04,590
So let's say I want to take the event on August 5th
and move it from 11 a.m. to 2 p.m. So I do that.

453
00:28:04,590 --> 00:28:07,350
So what happens is we actually
go out and create a new event,

454
00:28:07,350 --> 00:28:11,970
but we tie it to the original series;
and it's considered part of the series.

455
00:28:11,970 --> 00:28:15,370
It's effectively a child of the original series.

456
00:28:15,370 --> 00:28:19,690
So now if I go back to July 1st
and I say DeleteFutureEvents,

457
00:28:19,690 --> 00:28:22,360
that event will actually go away, as well.

458
00:28:22,360 --> 00:28:28,000
In contrast, if you pass EKSpanFutureEvents
and I say, from August 5th on,

459
00:28:28,000 --> 00:28:33,010
meeting's at 2 p.m. What happens
is we actually get a new event.

460
00:28:33,010 --> 00:28:36,140
It's a completely separate entity
and has no relation to the original.

461
00:28:36,140 --> 00:28:42,680
So now if I go back to July 1st and say DeleteFuture,
only the events up through July 29th will get deleted.

462
00:28:42,680 --> 00:28:47,680
Everything from August 5th will stay.

463
00:28:47,680 --> 00:28:53,890
If I delete passing EKSpanThisEvent,
all we do is set an exception date.

464
00:28:53,890 --> 00:28:55,550
So August 5th, we're not having that meeting.

465
00:28:55,550 --> 00:28:56,570
Forget it.

466
00:28:56,570 --> 00:29:03,480
And now we just set an exception date and now we
know not to generate a recurrence on that date.

467
00:29:03,480 --> 00:29:05,470
DeleteFuture, it's very similar.

468
00:29:05,470 --> 00:29:09,980
So everything, you know, after
July 29th, we don't want; gone.

469
00:29:09,980 --> 00:29:13,750
And so we just modify the recurrence
rules to end on that date.

470
00:29:13,750 --> 00:29:19,020
So it's kind of important to kind of get a feel
for, like, what happens when you modify events.

471
00:29:19,020 --> 00:29:23,820
Because it does change things in
certain ways, especially since, like,

472
00:29:23,820 --> 00:29:29,090
the deletion behavior is a little
different, it's important to know.

473
00:29:29,090 --> 00:29:30,600
Okay. So we've talked about recurrences.

474
00:29:30,600 --> 00:29:33,890
So let's see if we can actually take advantage
of recurrences in our demo application.

475
00:29:33,890 --> 00:29:34,560
Glen.

476
00:29:34,560 --> 00:29:37,970
>> Glen Steele: So, so far we've been creating and
deleting simple events in our Sharkster application.

477
00:29:37,970 --> 00:29:41,820
It would be great if we could leverage some
of this recurrence stuff since, you know,

478
00:29:41,820 --> 00:29:45,450
loan payments typically happen,
you know, on a repeating basis.

479
00:29:45,450 --> 00:29:49,410
So this is where you want to think kind of
carefully about how you architect your application.

480
00:29:49,410 --> 00:29:54,950
And whether using recurrences makes sense
or whether it's better to use simple events,

481
00:29:54,950 --> 00:30:01,080
it's important to remember that, for single events, you
get an eventIdentifier for each one of those, right?

482
00:30:01,080 --> 00:30:06,580
So it's easy to reference those later if you need
to because you have an eventIdentifier that points

483
00:30:06,580 --> 00:30:10,290
to that specific occurrence; whereas, with recurrences,

484
00:30:10,290 --> 00:30:14,340
each recurrence of the original event
inherits the same eventIdentifier.

485
00:30:14,340 --> 00:30:18,420
So if you want to locate that later, it's a
little bit more difficult because you may have

486
00:30:18,420 --> 00:30:22,100
to perform a search using the eventIdentifier
around the specific date.

487
00:30:22,100 --> 00:30:24,640
And you've got to know where that
occurrence is going to land.

488
00:30:24,640 --> 00:30:26,780
So it's something you really want to think about,

489
00:30:26,780 --> 00:30:31,430
whether using recurrences makes sense
or using single events makes sense.

490
00:30:31,430 --> 00:30:33,080
We're going to try and use recurrences now, though.

491
00:30:33,080 --> 00:30:36,270
So I'll switch back to the Xcode project.

492
00:30:36,270 --> 00:30:40,530
And the first thing we're going
to do is update our save method.

493
00:30:40,530 --> 00:30:44,700
So here's the old one, and I'm
just going to start a new one here.

494
00:30:44,700 --> 00:30:50,600
So, in the prior version, we created our loan event
scheduler and then we called generate payments

495
00:30:50,600 --> 00:30:54,870
and then we went and scheduled the
events based on those payments.

496
00:30:54,870 --> 00:30:59,050
Well, we're going to change our thinking a little
bit, because we actually want EventKit to do the work

497
00:30:59,050 --> 00:31:03,280
of scheduling the dates for us so that we don't have to.

498
00:31:03,280 --> 00:31:08,460
In generate payments, we were using NSCalendar to go
and figure out what dates each event needed to fall on.

499
00:31:08,460 --> 00:31:10,540
Well, now we're going to have EventKit do the work for us.

500
00:31:10,540 --> 00:31:15,430
So, instead of generating the payments
first and then calling schedule events,

501
00:31:15,430 --> 00:31:20,170
we're going to call a new method called schedule
payment events using recurrence for loan.

502
00:31:20,170 --> 00:31:25,750
And we're going to expect that that returns
to us an array of scheduled EKEvents.

503
00:31:25,750 --> 00:31:35,480
And once we have that in hand, we can go ahead and
generate our payments based on each one of those.

504
00:31:35,480 --> 00:31:39,320
So the next thing we do is call generate
payments for events and pass in that array.

505
00:31:39,320 --> 00:31:43,810
And once we've done that, we have
to deal with a special case.

506
00:31:43,810 --> 00:31:47,720
And it's the case of that last loan
payment being slightly different.

507
00:31:47,720 --> 00:31:54,280
So if the loan amount doesn't divide evenly into
the number of payments, we may be in a situation

508
00:31:54,280 --> 00:31:58,750
where the very last payment is a slightly
different amount, right, to make up the difference.

509
00:31:58,750 --> 00:32:02,530
And so we have a convenience method
on our loan object that tells us

510
00:32:02,530 --> 00:32:05,500
if that last payment is going to
be slightly different amount.

511
00:32:05,500 --> 00:32:12,880
And, based on that, if that turns out to be true, we're
going to call a method called update event with payment.

512
00:32:12,880 --> 00:32:14,040
And this is very simple.

513
00:32:14,040 --> 00:32:16,310
All it does is take in one of our EKEvents.

514
00:32:16,310 --> 00:32:21,310
And it takes in a payment object, and it
basically puts in the new properties based on --

515
00:32:21,310 --> 00:32:24,670
or the new amount based on that payment, right?

516
00:32:24,670 --> 00:32:27,550
So it's essentially just going
to update the title of that event

517
00:32:27,550 --> 00:32:30,690
to reflect that, hey, this one's got a different amount.

518
00:32:30,690 --> 00:32:37,490
Well, let's get rid of that old save
method and go ahead and implement these.

519
00:32:37,490 --> 00:32:42,580
So first we need to declare the scheduled
payment events using recurrence for loan.

520
00:32:42,580 --> 00:32:44,230
That's a bit of a tongue twister.

521
00:32:44,230 --> 00:32:47,510
And then update event with payment.

522
00:32:47,510 --> 00:32:55,140
[ Pause ]

523
00:32:55,140 --> 00:32:59,420
Okay. So, as I said before, we're expecting
scheduled payment events using recurrence

524
00:32:59,420 --> 00:33:01,830
for loan to return an NSArray.

525
00:33:01,830 --> 00:33:04,920
So we're just going to declare that.

526
00:33:04,920 --> 00:33:08,260
Whoops. Okay.

527
00:33:08,260 --> 00:33:15,030
And once we do that, we're going to create our
first EKEvent using EKEvent, event with store.

528
00:33:15,030 --> 00:33:21,560
Set the properties, just as we did before;
set up that alarm, just as we did before.

529
00:33:21,560 --> 00:33:23,770
And here's where it starts to diverge a little bit.

530
00:33:23,770 --> 00:33:26,190
We're going to create a recurrence rule.

531
00:33:26,190 --> 00:33:30,090
And the way we do that is using EKRecurrenceRule.

532
00:33:30,090 --> 00:33:34,750
And EventKit defines recurrences using two parameters.

533
00:33:34,750 --> 00:33:37,600
It takes a frequency and an interval.

534
00:33:37,600 --> 00:33:41,740
And so, for instance if you had a
payment that was due on a biweekly basis,

535
00:33:41,740 --> 00:33:45,000
you'd have a frequency of weekly and an interval of two.

536
00:33:45,000 --> 00:33:48,040
But we don't present the UI to the user in that way, right?

537
00:33:48,040 --> 00:33:52,900
They can just choose, well, I want it every three days
or I want it every week or biweekly or what have you.

538
00:33:52,900 --> 00:33:59,720
So we just need some helper functions to translate our
concept of that in the UI to what EventKit expects.

539
00:33:59,720 --> 00:34:05,730
So, to do that, we've got these two helper methods,
EventKit frequency for loan and EventKit interval for loan.

540
00:34:05,730 --> 00:34:12,590
And I'll just show you really quickly, if the
user chooses a biweekly frequency for their loan,

541
00:34:12,590 --> 00:34:18,700
we return a frequency of weekly and an interval of two.

542
00:34:18,700 --> 00:34:21,590
And so these are just basically translation functions here.

543
00:34:21,590 --> 00:34:23,570
All right.

544
00:34:23,570 --> 00:34:28,410
So we've actually done all we need
to do to create a recurrence rule.

545
00:34:28,410 --> 00:34:31,240
But there's one thing that we need
to define, and that's the end.

546
00:34:31,240 --> 00:34:34,110
And we could have done that right
here in this last parameter.

547
00:34:34,110 --> 00:34:36,230
But I just broke it out just for clarity.

548
00:34:36,230 --> 00:34:39,220
So all we do is create an EKRecurrenceEnd.

549
00:34:39,220 --> 00:34:46,620
And our loan objects are able to calculate
what the end date is, so we just pass that in.

550
00:34:46,620 --> 00:34:50,180
Once we've done that, we set that on the recurrence rule.

551
00:34:50,180 --> 00:34:54,280
And then we've got a complete recurrence
rule that we can set on the EKEvent.

552
00:34:54,280 --> 00:34:57,110
Okay. So we're done setting up our EKEvent.

553
00:34:57,110 --> 00:35:01,270
And the next thing we need to do is just save it.

554
00:35:01,270 --> 00:35:07,760
So, just as before, we're going to save
our event using EventStore saveEvent.

555
00:35:07,760 --> 00:35:09,200
Check for any errors.

556
00:35:09,200 --> 00:35:17,800
And assuming that all goes well, now we just need
to -- let's just lay that out a little nicer --

557
00:35:17,800 --> 00:35:22,440
we're not quite done yet, because we've
got to return that array of events, right?

558
00:35:22,440 --> 00:35:29,220
So we've now scheduled this in the calendar, but we --
our caller is expecting an array of scheduled events back.

559
00:35:29,220 --> 00:35:30,230
And so how do we do that?

560
00:35:30,230 --> 00:35:31,870
Well, we've got to find them.

561
00:35:31,870 --> 00:35:35,440
So, to do that, we create an NSPredicate.

562
00:35:35,440 --> 00:35:40,920
And, as Ed mentioned, EventStore
has a prebaked predicate for us.

563
00:35:40,920 --> 00:35:47,790
So we just call predicate for events with start date, and
we provide the start date of the loan and the end date

564
00:35:47,790 --> 00:35:51,180
of the loan and the calendar that we want to search.

565
00:35:51,180 --> 00:35:57,400
So once we call EventStore eventsMatchingPredicate,
basically, what we're going to get is every event

566
00:35:57,400 --> 00:36:01,440
between the start date of the loan and the end
date of the loan, which is not what we want.

567
00:36:01,440 --> 00:36:02,310
So what do we need to do?

568
00:36:02,310 --> 00:36:04,490
We need to postfilter this array.

569
00:36:04,490 --> 00:36:09,850
So we created a mutable copy of it immediately
so we can just filter that in place.

570
00:36:09,850 --> 00:36:13,710
And, to do that, we create another predicate.

571
00:36:13,710 --> 00:36:20,050
And we're going to search based on the eventIdentifier
that we got given when we created that first event.

572
00:36:20,050 --> 00:36:24,390
So, remember, each recurrence of the event
has the same eventIdentifier as the first one.

573
00:36:24,390 --> 00:36:30,340
So if we can say, hey, our recurrence lands on this date and
it's got this identifier, we'll get the one that we want.

574
00:36:30,340 --> 00:36:33,120
That gives us an unsorted list.

575
00:36:33,120 --> 00:36:39,900
So now we need to call sortUsingSelector, and we have
that prebaked selector called compareStartDateWithEvent.

576
00:36:39,900 --> 00:36:43,430
And that will give us an ordered
list of our scheduled payments,

577
00:36:43,430 --> 00:36:47,190
which we can then use to generate
our payment objects in our database.

578
00:36:47,190 --> 00:36:55,680
Okay. So we're finished with that method, and now we
just have to implement this update event with payment.

579
00:36:55,680 --> 00:36:56,790
So this is very simple.

580
00:36:56,790 --> 00:36:59,510
I just pasted the whole thing in right away.

581
00:36:59,510 --> 00:37:05,190
Essentially, we're taking an EKEvent; we're taking in a
payment; we're figuring out what the new title needs to be;

582
00:37:05,190 --> 00:37:07,950
and we're setting the properties on the event.

583
00:37:07,950 --> 00:37:12,890
Once that's done, we just call EventStore
saveEvent and check for success.

584
00:37:12,890 --> 00:37:18,910
And now that we've detached this from our series, we're
going to get a slightly different eventIdentifier.

585
00:37:18,910 --> 00:37:22,690
So we're going to save that aside,
too, in our payment object.

586
00:37:22,690 --> 00:37:24,880
Okay. So this looks all good.

587
00:37:24,880 --> 00:37:31,940
So we're creating events with recurrences; we're
handling the case of that different last payment amount.

588
00:37:31,940 --> 00:37:35,250
But there's one thing left, and we've
got to handle deletion correctly.

589
00:37:35,250 --> 00:37:38,010
So we need to update our delete method a little bit.

590
00:37:38,010 --> 00:37:42,430
I'll leave the old one up there and paste in the new one.

591
00:37:42,430 --> 00:37:44,890
And this looks just a little bit different now.

592
00:37:44,890 --> 00:37:50,930
So, previously, we were iterating through each one
of our payment objects, grabbing the eventIdentifier

593
00:37:50,930 --> 00:37:54,970
and then removing each one of those
EKEvents based on that eventIdentifier.

594
00:37:54,970 --> 00:37:56,420
We don't need to do that anymore, right?

595
00:37:56,420 --> 00:37:59,570
We've got a single event that's
recurring, maybe another event --

596
00:37:59,570 --> 00:38:03,040
that's that last one -- so we just
need to take care of those.

597
00:38:03,040 --> 00:38:09,360
So, to do that, we're going to call
value for key on the payments array.

598
00:38:09,360 --> 00:38:15,150
So this has the effect of calling the event
ID method on every object in that array,

599
00:38:15,150 --> 00:38:18,800
and that will give us an array of all the event IDs, right?

600
00:38:18,800 --> 00:38:24,060
But the problem there is that we basically got
a list of the same event identifiers, right?

601
00:38:24,060 --> 00:38:26,350
So we need to unique those.

602
00:38:26,350 --> 00:38:29,080
And an easy way to do that is to make a set with the array,

603
00:38:29,080 --> 00:38:33,960
and that will have the effect of
uniquing all the event identifiers.

604
00:38:33,960 --> 00:38:39,850
Now, once we have that, we can loop through those
event identifiers, get the EKEvent using event

605
00:38:39,850 --> 00:38:43,650
with eventIdentifier, and then call remove.

606
00:38:43,650 --> 00:38:50,810
This time, we're using the EKSpanFutureEvents parameter
for the span argument so that we blow away all

607
00:38:50,810 --> 00:38:53,270
of the recurrences for future events, right?

608
00:38:53,270 --> 00:38:58,640
Now, it's worth noting here, actually,
there's a little caveat to this.

609
00:38:58,640 --> 00:39:03,440
And because, when we created this recurrence we used --

610
00:39:03,440 --> 00:39:08,600
when we updated that last event, we
used the EKSpanThisEvent parameter.

611
00:39:08,600 --> 00:39:13,830
When we detached that from our series,
it still remained a child of that series;

612
00:39:13,830 --> 00:39:16,740
because we didn't use the EKSpanFutureEvent parameter.

613
00:39:16,740 --> 00:39:22,980
So, actually, the first time through this loop,
we are effectively deleting the entire thing.

614
00:39:22,980 --> 00:39:28,930
So it's just worth noting that I'm leaving
the loop in place because, you know,

615
00:39:28,930 --> 00:39:36,140
in case we did decide to detach using EKSpanFutureEvents or
something, we want to just take care of blowing it all away.

616
00:39:36,140 --> 00:39:36,880
All right.

617
00:39:36,880 --> 00:39:42,160
So let's delete this old version, save this, builds.

618
00:39:42,160 --> 00:39:45,270
And let's build and send that over to the device.

619
00:39:45,270 --> 00:39:49,120
Okay. So now what we should expect to
happen is we can create new events.

620
00:39:49,120 --> 00:39:50,980
We should see them pop up in the calendar.

621
00:39:50,980 --> 00:39:55,700
And, if we examine each one of those, we'll be able
to see that they're actually a recurring event.

622
00:39:55,700 --> 00:39:58,410
And, then, hopefully, when we delete
them, they'll get taken away too.

623
00:39:58,410 --> 00:40:01,920
So I'll create a new loan here.

624
00:40:03,230 --> 00:40:03,900
All right.

625
00:40:03,900 --> 00:40:06,040
Let's choose Claire.

626
00:40:06,040 --> 00:40:11,810
And I'll just choose some random amount.

627
00:40:11,810 --> 00:40:18,730
And hopefully this will give us a payment schedule that
will give us a slightly different last payment, right?

628
00:40:18,730 --> 00:40:20,620
Because we just want to test that functionality.

629
00:40:20,620 --> 00:40:24,970
So this gives us two payments of 440.13 and one of 440.12.

630
00:40:24,970 --> 00:40:28,220
So that will go through that code
that updates that last payment for us.

631
00:40:28,220 --> 00:40:31,100
And, then, let's hit Save.

632
00:40:31,100 --> 00:40:32,220
All right.

633
00:40:32,220 --> 00:40:33,090
Take a look.

634
00:40:33,090 --> 00:40:35,620
And everything looks good here.

635
00:40:35,620 --> 00:40:40,930
Let's jump over to the calendar and see if they show up.

636
00:40:40,930 --> 00:40:42,520
And, indeed, they do.

637
00:40:42,520 --> 00:40:46,700
And if I hit the Edit button here, I'll
actually see that there's a repeat rule

638
00:40:46,700 --> 00:40:49,060
which shows us that the recurrence worked.

639
00:40:49,060 --> 00:40:54,200
And let's look at that very last payment.

640
00:40:54,200 --> 00:40:55,210
And we can see, yes.

641
00:40:55,210 --> 00:40:56,690
That is a slightly different amount.

642
00:40:56,690 --> 00:40:58,690
So that worked too.

643
00:40:58,690 --> 00:41:04,080
Now, let's jump back to Sharkster and try and delete this.

644
00:41:04,080 --> 00:41:07,360
So we hit Delete, move back to the calendar.

645
00:41:07,360 --> 00:41:08,160
And, hey, look at that.

646
00:41:08,160 --> 00:41:09,510
They all disappeared.

647
00:41:09,510 --> 00:41:16,050
[ Applause ]

648
00:41:16,050 --> 00:41:20,330
Okay. So that's creating and deleting
events using recurrences in EventKit.

649
00:41:20,330 --> 00:41:25,100
And so, to do that, you create the initial
event, set the properties on that event,

650
00:41:25,100 --> 00:41:29,000
set the recurrence rule, and then
save using EKEvent saveEvent.

651
00:41:29,000 --> 00:41:34,450
And, then, to delete, you want to get the event
using the eventIdentifier or a search predicate

652
00:41:34,450 --> 00:41:38,460
so you can do searching, and remove
using EKEvent removeEvent.

653
00:41:38,460 --> 00:41:42,900
But you've got to use that EKSpanFutureEvents
argument to blow the whole series away.

654
00:41:42,900 --> 00:41:44,270
All right, that's it.

655
00:41:44,270 --> 00:41:45,510
Thank, Ed.

656
00:41:45,510 --> 00:41:51,040
[ Applause ]

657
00:41:51,040 --> 00:41:52,890
>> Ed Voas: Thanks, Glen.

658
00:41:52,890 --> 00:41:57,170
So right now we've been operating in a vacuum
as if you're the only person on, you know,

659
00:41:57,170 --> 00:41:59,670
on the device who's modifying the calendar database.

660
00:41:59,670 --> 00:42:01,010
And you're not.

661
00:42:01,010 --> 00:42:04,880
So, when other people modify the
database, you need to be told.

662
00:42:04,880 --> 00:42:06,120
And you need to react.

663
00:42:06,120 --> 00:42:11,300
And we do that by sending you a notification
called EKEventStoreChangedNotification.

664
00:42:11,300 --> 00:42:14,930
Again, we're very original with our naming.

665
00:42:14,930 --> 00:42:16,580
It can happen at any time.

666
00:42:16,580 --> 00:42:21,230
And even though, like, calendar
might be suspended, sync is not.

667
00:42:21,230 --> 00:42:23,930
So if something happens and sync
decides that it needs to bring something

668
00:42:23,930 --> 00:42:26,140
down into the database, you need to be informed.

669
00:42:26,140 --> 00:42:27,870
You need to react to that.

670
00:42:27,870 --> 00:42:29,080
They're very coarse-grained, though.

671
00:42:29,080 --> 00:42:32,910
It barely tells you that something
happened but you have no idea what.

672
00:42:32,910 --> 00:42:34,650
Welcome to my world.

673
00:42:34,650 --> 00:42:36,680
And they're coalesced.

674
00:42:36,680 --> 00:42:42,710
So if you happen to be suspended and stuff changes out
behind your back, when you resume, you'll get the event.

675
00:42:42,710 --> 00:42:48,830
So when you receive it, what you should do is effectively
treat your EKEvent and EKCalendar things as invalid.

676
00:42:48,830 --> 00:42:51,580
So all the food in the fridge is
bad; throw it out and go shopping.

677
00:42:51,580 --> 00:42:53,810
So that's what you want to do.

678
00:42:53,810 --> 00:42:58,160
So -- but we also have a method called
EKEvent refresh which you can use.

679
00:42:58,160 --> 00:43:01,280
It returns a Boolean and tells you
whether the event is still valid or not.

680
00:43:01,280 --> 00:43:06,110
And, after the database is changed, if that
event had happened to have its data updated,

681
00:43:06,110 --> 00:43:12,460
it will repopulate the properties of that event with
the latest values, unless you've modified something.

682
00:43:12,460 --> 00:43:15,850
So, if you've modified title and
location, those will stay intact.

683
00:43:15,850 --> 00:43:18,530
But everything that you haven't modified will get reloaded.

684
00:43:18,530 --> 00:43:19,670
But it's kind of a pricey call.

685
00:43:19,670 --> 00:43:21,780
And you don't want to call it on
hundreds or thousands of event.

686
00:43:21,780 --> 00:43:23,150
It's just not worth it.

687
00:43:23,150 --> 00:43:27,160
So the rule of thumb that we use is,
generally, if you are actively viewing

688
00:43:27,160 --> 00:43:30,010
or editing an event, you call EKEvent refresh.

689
00:43:30,010 --> 00:43:34,280
And if you're not, just refetch your events.

690
00:43:34,280 --> 00:43:36,730
Okay. So that's all of the non-UI side of things.

691
00:43:36,730 --> 00:43:40,680
So let's look at the two view controllers
that we provide for you.

692
00:43:40,680 --> 00:43:41,740
The first is Detail View.

693
00:43:41,740 --> 00:43:44,120
You've seen it before.

694
00:43:44,120 --> 00:43:47,550
EKEventViewControllers, how it's exposed to you.

695
00:43:47,550 --> 00:43:49,470
It's the same view you've ever seen.

696
00:43:49,470 --> 00:43:54,220
It does everything that you've seen it do in Calendar.

697
00:43:54,220 --> 00:43:56,070
So you can respond to invites, the whole thing.

698
00:43:56,070 --> 00:43:59,160
It can allow editing, optionally.

699
00:43:59,160 --> 00:44:01,460
You have the Edit button up here.

700
00:44:01,460 --> 00:44:04,780
And it listens to those notifications
we just talked about for you.

701
00:44:04,780 --> 00:44:08,280
So, if the event changes, it will just refresh itself.

702
00:44:08,280 --> 00:44:12,220
If the event is deleted, it will pop
itself off of the navigation stack.

703
00:44:12,220 --> 00:44:15,990
To put one up, really easy.

704
00:44:15,990 --> 00:44:24,770
Just alloc and init, set the event, tell it whether you want
editing or not, and then call pushViewController animated.

705
00:44:24,770 --> 00:44:29,010
And now you have Detail View.

706
00:44:29,010 --> 00:44:31,580
Likewise, we supply you with the standard editor.

707
00:44:31,580 --> 00:44:34,460
And this, again, the exact same editor
that we use in the Calendar application.

708
00:44:34,460 --> 00:44:38,910
It's exposed through EKEventEditViewController.

709
00:44:38,910 --> 00:44:42,430
So you can edit existing events or it
can use this to create brand new events.

710
00:44:42,430 --> 00:44:48,330
To do that, you could just not pass us an event and we will
make one, or you can pass in a partially constructed event.

711
00:44:48,330 --> 00:44:49,880
So consider the case of data detectors.

712
00:44:49,880 --> 00:44:55,190
So you tap on a date in Mail, and it has some certain
fields that it wants to prepopulate the event with.

713
00:44:55,190 --> 00:45:01,190
It just fills that in and just invokes
this view controller with that information.

714
00:45:01,190 --> 00:45:04,590
If you don't pass us anything, we
will fill in defaults as needed.

715
00:45:04,590 --> 00:45:10,670
So we'll fill in a default date, start and end
time; and we'll also always use the default calendar

716
00:45:10,670 --> 00:45:14,530
for new events that we keep talking about.

717
00:45:14,530 --> 00:45:15,690
It also relies on a delegate.

718
00:45:15,690 --> 00:45:20,910
It will tell you when the user has canceled or
saved the event or whether the event was deleted.

719
00:45:20,910 --> 00:45:24,830
And deleted can come from two sources:
either the user actually deleted it,

720
00:45:24,830 --> 00:45:29,720
or we picked up one of those notifications we talked
about, determined that the event had been deleted,

721
00:45:29,720 --> 00:45:33,750
and we want to tell you it's gone now, please close me.

722
00:45:33,750 --> 00:45:36,530
We also allow you to override the
default calendar that we'll use.

723
00:45:36,530 --> 00:45:42,530
So you might just supply a calendar before you,
you know, pass it into this view controller.

724
00:45:42,530 --> 00:45:47,370
But let's say you did that and now sync
came along and decided, You know what?

725
00:45:47,370 --> 00:45:50,250
You went and deleted that calendar on
a different device, and it's gone now.

726
00:45:50,250 --> 00:45:50,760
So what do you do?

727
00:45:50,760 --> 00:45:53,950
Well, we'll call the delegate and say,
well, we need a new default calendar.

728
00:45:53,950 --> 00:45:55,240
What should we use?

729
00:45:55,240 --> 00:45:59,240
And if you don't fill -- if you don't actually override
this method, we'll just use default calendar for new events.

730
00:45:59,240 --> 00:46:02,430
But it's there if you want to hook it in.

731
00:46:02,430 --> 00:46:04,920
Explain the editors, it's just as easy.

732
00:46:04,920 --> 00:46:08,750
Create it and just set the event
in the EventStore this time.

733
00:46:08,750 --> 00:46:13,370
And then you set edit view delegate to
whatever is appropriate for your application.

734
00:46:13,370 --> 00:46:18,980
And then it's packaged as a UI navigation
controller, and it's meant to be presented modally.

735
00:46:18,980 --> 00:46:23,640
So you want to call presentModalViewController animated.

736
00:46:23,640 --> 00:46:28,450
And, likewise, when you want to dismiss
it, you just dismiss modal view controller.

737
00:46:28,450 --> 00:46:35,070
Okay. Let's just see a quick sample of
actually using Detail View in our application.

738
00:46:35,070 --> 00:46:36,510
Glen.

739
00:46:36,510 --> 00:46:40,040
[ Pause ]

740
00:46:40,040 --> 00:46:40,270
>> Glen Steele: Okay.

741
00:46:40,270 --> 00:46:44,840
So, really quickly, we're just going to add
the EKEventViewController to our application.

742
00:46:44,840 --> 00:46:48,200
And so we want to do this in the
list of payments that we have.

743
00:46:48,200 --> 00:46:53,370
We'd like to be able to tap on one of those
and get shown, basically, the Calendar UI.

744
00:46:53,370 --> 00:46:57,850
So that view controller is actually
the payment schedule view controller.

745
00:46:57,850 --> 00:47:02,110
And the first thing we want to do is
just update our configure cell method.

746
00:47:02,110 --> 00:47:06,140
We want to make sure that we show
that little disclosure chevron.

747
00:47:06,140 --> 00:47:13,540
So, to do that, we just set the cell accessory type
to UI table view cell accessory disclosure indicator.

748
00:47:13,540 --> 00:47:19,850
And the next thing we need to do is update
our did select row at index path method.

749
00:47:19,850 --> 00:47:21,260
All right.

750
00:47:22,930 --> 00:47:29,480
So what we're going to do here is grab our payment object
that's associated with the payment that we just tapped.

751
00:47:29,480 --> 00:47:33,950
And we do that using our core data
magic and our fetch results controller.

752
00:47:33,950 --> 00:47:38,080
And then we need to create a loan event scheduler

753
00:47:38,080 --> 00:47:43,420
so that we can actually find the EKEvent
that's associated would this payment.

754
00:47:43,420 --> 00:47:47,580
So we're going to define a new method
called event recurrence for payment.

755
00:47:47,580 --> 00:47:50,970
And that's going to return our EKEvent.

756
00:47:50,970 --> 00:47:56,450
Once we've got that, we can create our new event
view controller and then set the properties

757
00:47:56,450 --> 00:48:00,230
on it, the most important one being the event.

758
00:48:00,230 --> 00:48:02,780
And set the allows editing property.

759
00:48:02,780 --> 00:48:04,900
Now, you know, I had this set as no.

760
00:48:04,900 --> 00:48:09,620
But I'm going to set it to yes just so that you
can see how easy it is to put the Edit button

761
00:48:09,620 --> 00:48:12,480
up there and get the edit view controller.

762
00:48:12,480 --> 00:48:16,310
And once that's done, it's just a matter of
pushing it onto our navigation controller.

763
00:48:16,310 --> 00:48:18,490
So we're done here.

764
00:48:18,490 --> 00:48:21,510
Let's just go and implement this
event recurrence for payment method.

765
00:48:21,510 --> 00:48:28,270
[ Pause ]

766
00:48:28,270 --> 00:48:30,210
Okay. So this is very simple.

767
00:48:30,210 --> 00:48:32,450
Actually, you've seen this code before.

768
00:48:32,450 --> 00:48:37,580
This is the code that we use to search for
events once we had created the recurring event,

769
00:48:37,580 --> 00:48:39,430
and it's pretty much the same thing.

770
00:48:39,430 --> 00:48:41,870
All we're doing is creating a search predicate,

771
00:48:41,870 --> 00:48:48,470
calling eventsMatchingPredicate using
a mutable copy to postfilter in place.

772
00:48:48,470 --> 00:48:54,430
And, then, we know that we're going
to get basically one event, right?

773
00:48:54,430 --> 00:48:59,780
So we're just going to take the first event and return that.

774
00:49:01,990 --> 00:49:02,730
All right.

775
00:49:02,730 --> 00:49:03,660
So let's build.

776
00:49:03,660 --> 00:49:05,350
Everything went okay.

777
00:49:05,350 --> 00:49:06,390
Send that over to the device.

778
00:49:06,390 --> 00:49:16,090
And now what we should expect to see is we should be able
to create a loan and look at our payment schedule controller

779
00:49:16,090 --> 00:49:20,660
and tap on any one of those payments and we
should see EventKitUI for each one of those.

780
00:49:20,660 --> 00:49:27,090
So let's go ahead and do that, create
a new loan for Charlie this time.

781
00:49:27,090 --> 00:49:31,580
We'll be a bit more ambitious.

782
00:49:31,580 --> 00:49:42,190
And let's do it over a month and do
payments every -- let's say every three days.

783
00:49:42,190 --> 00:49:49,590
Hit Save. And now, if we tap on this and look at the
payment schedule, it looks like our chevrons showed up.

784
00:49:49,590 --> 00:49:54,220
And we should be able to tap on any one of
these and, hey look, we get the event UI for it.

785
00:49:54,220 --> 00:50:02,620
And we can tap on the Edit button and that
gives us the event UI edit controller.

786
00:50:02,620 --> 00:50:04,510
Okay.

787
00:50:04,510 --> 00:50:09,060
[ Applause ]

788
00:50:09,060 --> 00:50:09,220
All right.

789
00:50:09,220 --> 00:50:13,830
So that's using EventKitUI to show
EventKitUI in your application.

790
00:50:13,830 --> 00:50:14,940
And it's pretty easy.

791
00:50:14,940 --> 00:50:20,200
You just need to find the event using the eventIdentifier
or search for it using the predicate methods;

792
00:50:20,200 --> 00:50:27,390
create a new EKEventViewController; and then set the
controller properties, mainly your event property;

793
00:50:27,390 --> 00:50:31,640
and push that onto your navigation stack.

794
00:50:31,640 --> 00:50:33,850
All right, thanks.

795
00:50:33,850 --> 00:50:36,500
>> Ed Voas: Thanks, Glen.

796
00:50:36,500 --> 00:50:40,070
Okay. So that's pretty much the bulk of the API.

797
00:50:40,070 --> 00:50:43,180
It doesn't really take a lot and you
can still get a bunch of stuff done.

798
00:50:43,180 --> 00:50:45,700
I just want to mention some facts
about working with the simulator.

799
00:50:45,700 --> 00:50:51,870
So, in the simulator, the SDK, we don't
have the Calendar application there.

800
00:50:51,870 --> 00:50:54,270
So it's a little difficult to manufacture events.

801
00:50:54,270 --> 00:51:00,430
So one way that you could do that is just write --
you know, we saw how easy it is to generate events.

802
00:51:00,430 --> 00:51:04,230
You can just write some code and
just populate the database that way.

803
00:51:04,230 --> 00:51:08,610
Or you can actually use the birthday calendar
which I believe does work in the simulator.

804
00:51:08,610 --> 00:51:14,120
So you can just add some contacts, give them birthdays,
and the birthday calendar will just autopopulate.

805
00:51:14,120 --> 00:51:21,520
And that would be an example of a read-only
calendar that you could poke around with.

806
00:51:21,520 --> 00:51:24,880
So the bottom line here is we have,
like, really easy to use,

807
00:51:24,880 --> 00:51:29,530
very high-level APIs that allow you
to get at calendar data on a device.

808
00:51:29,530 --> 00:51:31,620
We have a couple of view controllers.

809
00:51:31,620 --> 00:51:34,700
They do everything that you can
do in the Calendar application.

810
00:51:34,700 --> 00:51:38,920
And one of the things that we don't demonstrate
is that they're fully rotatable now in iOS 4.

811
00:51:38,920 --> 00:51:44,950
And, obviously, this is just the first release of this API.

812
00:51:44,950 --> 00:51:48,410
We want to do more stuff as time progresses.

813
00:51:48,410 --> 00:51:53,160
But it's up to you to help us to figure
out what we should do first, all right?

814
00:51:53,160 --> 00:51:57,100
So the best way to do that is to file bugs.

815
00:51:57,100 --> 00:52:00,820
Now, many people file a bug and
say, I need an API that gives me X.

816
00:52:00,820 --> 00:52:01,820
It's like, Okay.

817
00:52:01,820 --> 00:52:03,370
But what are you really trying to do?

818
00:52:03,370 --> 00:52:07,460
So if you could tell us, you know, exactly what you're
trying to get at, you know, what you're trying to do

819
00:52:07,460 --> 00:52:13,800
with the API, we can then see how we
can best fit that into the public API.

820
00:52:13,800 --> 00:52:19,740
And we take all of those requests; and, obviously, the most
popular features, the most oft-requested things are the ones

821
00:52:19,740 --> 00:52:25,220
that we prioritize first rather than last.

822
00:52:25,220 --> 00:52:31,980
So tomorrow there's a lab at 9 a.m. -- God help me -- Lab B.

823
00:52:31,980 --> 00:52:37,160
Yesterday, there was a talk on GCD.

824
00:52:37,160 --> 00:52:41,830
So, if you missed that, you can catch it
later on in the -- on the web, I guess.

825
00:52:41,830 --> 00:52:50,130
There was also a session which I neglected to put here on
UILocalNotifications which you might also be interested in.

826
00:52:50,130 --> 00:52:56,850
If you need to contact someone,
I pick Mark Malone.

827
00:52:56,850 --> 00:52:59,440
So if you have questions on Calendar, you can contact him.

828
00:52:59,440 --> 00:53:04,350
We also have documentation on developer.Apple.com.

829
00:53:04,350 --> 00:53:11,020
And the -- on the Dev Forums, I'm patrolling that,
too, and trying to answer questions as best as I can.

830
00:53:11,020 --> 00:53:13,650
So you can always use that as a way to talk to us.

