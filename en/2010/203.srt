1
00:00:06,650 --> 00:00:08,180
>> Thane: So I'm Thane Norton.

2
00:00:08,180 --> 00:00:10,440
I'm with the I/O Kit Team.

3
00:00:10,440 --> 00:00:16,360
And I want to talk to you a little bit about
designing and debugging device drivers on OS X.

4
00:00:16,360 --> 00:00:25,210
What I'm going to talk about today is how you can
drive hardware from user space or kernel space,

5
00:00:25,210 --> 00:00:28,450
the kinds of drivers that have to be in the kernel.

6
00:00:28,450 --> 00:00:34,120
And some ways you can debug kernel level
code, and some of the special challenges

7
00:00:34,120 --> 00:00:38,200
that are involved in doing your own I/O Kit user client.

8
00:00:38,200 --> 00:00:39,990
So what is I/O Kit?

9
00:00:39,990 --> 00:00:45,340
I/O Kit is the set of frameworks
that Apple uses for driving hardware.

10
00:00:45,340 --> 00:00:51,210
There's a piece in the kernel and
it percolates up into user space.

11
00:00:51,210 --> 00:00:59,720
Not only is it the device driver model, but it's also a
framework that applications can use to drive hardware.

12
00:00:59,720 --> 00:01:04,460
Now I/O Kit is only available on OS X.

13
00:01:04,460 --> 00:01:07,470
It is not available for the iPhone.

14
00:01:07,470 --> 00:01:15,230
If you want to know how to drive devices on the iPhone,
you want to go watch the Developing Apps That Work

15
00:01:15,230 --> 00:01:18,750
with iPhone Accessories session that happened earlier today.

16
00:01:18,750 --> 00:01:30,180
So the best possible place for you to support
hardware is in your application in user space.

17
00:01:30,180 --> 00:01:34,550
If you just need to drive hardware
from your particular application,

18
00:01:34,550 --> 00:01:38,770
you can just link against the I/O
Kit libraries, the I/O Kit framework

19
00:01:38,770 --> 00:01:42,110
and build the support straight into your application.

20
00:01:42,110 --> 00:01:47,490
This gives you the benefit of being
able to do a drag-and-drop install

21
00:01:47,490 --> 00:01:50,250
and not having to have a special installer.

22
00:01:50,250 --> 00:01:56,870
And even if you have multiple applications that share
the hardware, I/O Kit can arbitrate that sharing for you,

23
00:01:56,870 --> 00:02:00,540
and you don't have to worry about all the nitty details.

24
00:02:01,580 --> 00:02:09,660
Now, if you have multiple applications that need to share
the same device support code, then you're probably going

25
00:02:09,660 --> 00:02:12,600
to want to create some kind of framework.

26
00:02:12,600 --> 00:02:17,710
You can still build that into your application, letting
you have the drag-and-drop install by putting it

27
00:02:17,710 --> 00:02:22,960
in the resource folder of your application, otherwise
you're going to need some kind of installer to put it

28
00:02:22,960 --> 00:02:27,030
in the right place, so all of the applications can use it.

29
00:02:27,030 --> 00:02:38,440
The last way to support hardware from user space is when
you need to do some kind of services, moving the cursor,

30
00:02:38,440 --> 00:02:48,250
generating keyboard events, or other services to the system,
you need to have some kind of background application.

31
00:02:48,250 --> 00:02:49,810
Launchd is your friend.

32
00:02:49,810 --> 00:02:58,510
It is a utility that can be used to create
launch-on-demand applications that anybody can connect to.

33
00:02:58,510 --> 00:03:04,830
It's very well documented in the
man pages, such as launchd.plist,

34
00:03:04,830 --> 00:03:10,000
and you want to go to the Launch-on-Demand
session, which I'm pretty sure hasn't happened yet.

35
00:03:10,000 --> 00:03:19,780
Now what being in user space buys you is your
device support will be a lot easier to debug.

36
00:03:19,780 --> 00:03:26,020
Not only will it be easier to debug, when you
have bugs your application will be more robust.

37
00:03:26,020 --> 00:03:34,170
If your application exits suddenly, the user can
relaunch it or the background service can be relaunched.

38
00:03:34,170 --> 00:03:40,580
If your kernel driver exits unexpectedly,
the user's going to reboot

39
00:03:40,580 --> 00:03:42,420
and they're going to lose whatever they were working on.

40
00:03:42,420 --> 00:03:46,730
You also have a lot more access to system services.

41
00:03:46,730 --> 00:03:51,290
You can choose to use Objective-C,
which you cannot do in the kernel.

42
00:03:51,290 --> 00:03:57,320
You have access to better logging
facilities, such as the ASL log system.

43
00:03:57,320 --> 00:04:00,820
You can create your own log file
and log your messages out to that.

44
00:04:00,820 --> 00:04:04,160
And you should not be able to cause panics.

45
00:04:04,160 --> 00:04:08,300
This is not to say that you won't, but if
you do you're going to want to log a bug

46
00:04:08,300 --> 00:04:12,280
against it and then try and work around it.

47
00:04:12,280 --> 00:04:20,220
Now from user space,- you can get nearly
full access to any I/O Kit driven hardware.

48
00:04:20,220 --> 00:04:23,540
Almost any USB device can be supported.

49
00:04:23,540 --> 00:04:25,760
You get much better memory management.

50
00:04:25,760 --> 00:04:27,870
You can actually page memory in and out.

51
00:04:27,870 --> 00:04:30,640
You don't have to worry about your
memory all being wired down.

52
00:04:30,640 --> 00:04:41,380
And one common misconception is that kernel threads get
special treatment when it comes to thread scheduling.

53
00:04:41,380 --> 00:04:42,670
That is untrue.

54
00:04:42,670 --> 00:04:48,190
At a given priority, kernel threads and
user space threads get the same scheduling.

55
00:04:48,190 --> 00:04:57,620
So that doesn't; being user space versus kernel space
does not buy you anything in terms of priority of access.

56
00:04:57,620 --> 00:05:02,430
And you end up with a testing matrix that
is very similar to any other application.

57
00:05:02,430 --> 00:05:08,830
You do some testing on both processors on
all the versions of the OS that you support.

58
00:05:08,830 --> 00:05:16,110
When I say all the versions of the OS you support, I would
highly recommend only supporting the most recent revision.

59
00:05:16,110 --> 00:05:19,530
Have your users update to whatever the latest revision is.

60
00:05:19,530 --> 00:05:23,560
It collapses your testing matrix significantly.

61
00:05:24,600 --> 00:05:33,100
Now you can't drive hardware from user space if the
hardware is supplying services to someone in the kernel;

62
00:05:33,100 --> 00:05:37,840
for example, if you are writing a file system driver.

63
00:05:37,840 --> 00:05:43,000
If you require access to other kernel resources
that are not published through I/O Kit,

64
00:05:43,000 --> 00:05:45,580
you're going to have to be in the kernel to get those.

65
00:05:45,580 --> 00:05:49,970
And if you need to respond directly
to primary interrupts, that is to say,

66
00:05:49,970 --> 00:05:54,300
if you are a PCI driver you're
going to have to be in the kernel.

67
00:05:54,300 --> 00:05:57,810
There's just no other way to handle it.

68
00:05:57,810 --> 00:06:02,870
If you have to be in the kernel,
you're going to need to write a kext.

69
00:06:02,870 --> 00:06:08,310
Even if you're just thinking about writing a kext, if you've
already written a kext and you haven't done this already,

70
00:06:08,310 --> 00:06:11,930
go read the Kernel Extension Programming Topics.

71
00:06:11,930 --> 00:06:14,940
It has a lot of very good walkthroughs.

72
00:06:14,940 --> 00:06:20,570
Going through that over the course of a day, you
can get a very good workflow for building your kext,

73
00:06:20,570 --> 00:06:25,380
installing it on your test machine,
testing it, debugging it.

74
00:06:25,380 --> 00:06:29,190
It's an excellent set of tutorials.

75
00:06:30,680 --> 00:06:37,170
All memory that you allocate in
a kext is, by default, wired.

76
00:06:37,170 --> 00:06:44,390
What that means is if you had a memory leak in your
driver in the kernel, you're going to take the user system

77
00:06:44,390 --> 00:06:49,070
down just by depriving other applications of memory.

78
00:06:49,070 --> 00:06:51,730
Memory from user space is not wired.

79
00:06:51,730 --> 00:06:55,460
As I was saying, user space applications can page.

80
00:06:55,460 --> 00:07:04,000
But, since the driver, since kexts, expect memory to
be wired, you have to, before you do any direct I/O

81
00:07:04,000 --> 00:07:09,420
on memory passed in from user space, you
have to make sure that it's wired down

82
00:07:09,420 --> 00:07:12,960
and then unwire it after the operation completes.

83
00:07:12,960 --> 00:07:16,220
When you're in the kernel, logging is very limited.

84
00:07:16,220 --> 00:07:19,220
Most of the system logs use some kind of ring buffer.

85
00:07:19,220 --> 00:07:25,280
Which means to you, that if you try and log a lot
of messages, you're going to overflow the buffer,

86
00:07:25,280 --> 00:07:30,970
the messages are going to get garbled, things will be
dropped, you're not going to see what you expect to see.

87
00:07:30,970 --> 00:07:36,240
You can't use ASL, which is a very nice logging system.

88
00:07:36,240 --> 00:07:39,900
Now you can use kprintf to do FireWire logging.

89
00:07:39,900 --> 00:07:43,280
This is not a solution that you can deploy.

90
00:07:43,280 --> 00:07:46,130
This is something that is very handy to use in a test setup,

91
00:07:46,130 --> 00:07:49,730
so that you get all of the message coming,
the messages coming out of your driver.

92
00:07:49,730 --> 00:07:54,390
If you want to learn how to do that,
the place to look is the man page

93
00:07:54,390 --> 00:08:02,250
for fwkpfv, which is the FireWire kprintf something.

94
00:08:03,970 --> 00:08:07,190
Your test cycle's going to be longer.

95
00:08:07,190 --> 00:08:10,810
Often it will require a reboot,
especially when you encounter a bug,

96
00:08:10,810 --> 00:08:14,530
because you'll have to be rebooting your system.

97
00:08:14,530 --> 00:08:17,700
It requires advance preparation.

98
00:08:17,700 --> 00:08:20,510
You need to have two machines.

99
00:08:20,510 --> 00:08:23,800
That's going to be your best debug solution.

100
00:08:23,800 --> 00:08:28,730
You're going to connect them either
through Ethernet or through FireWire.

101
00:08:28,730 --> 00:08:33,070
Ethernet tends to be more convenient, because
all your machines are hooked up all ready.

102
00:08:33,070 --> 00:08:39,650
FireWire is available earlier in the boot time, so
it just depends on what kind of environment you need.

103
00:08:39,650 --> 00:08:47,350
Additionally, you can download the kernel debug
kit for the specific kernel that you're running on.

104
00:08:47,350 --> 00:08:53,680
And that will give you the ability to step
through Apple code as your driver uses it.

105
00:08:53,680 --> 00:09:00,320
So you can see what's going on and who
is expecting that pointer to be not null.

106
00:09:00,320 --> 00:09:03,930
Again, read the Kernel Extension Programming Topics.

107
00:09:03,930 --> 00:09:07,180
This will show you how to set up a two-machine environment.

108
00:09:07,180 --> 00:09:17,240
If you wanted to use FireWire, another FireWire utility,
fwkdp, very handy for getting FireWire up and running.

109
00:09:17,240 --> 00:09:25,530
You must test your kext on every
supported kernel, every release.

110
00:09:25,530 --> 00:09:31,930
I tell you from experience, it is very
easy to build a kext that will not run

111
00:09:31,930 --> 00:09:35,690
because you linked against something that isn't there.

112
00:09:35,690 --> 00:09:40,320
Your kext also must match the kernel
architecture that you're running on.

113
00:09:40,320 --> 00:09:43,790
You don't get to choose if you're
going to run 64-bit or 32-bit.

114
00:09:43,790 --> 00:09:46,140
If it's a 32-bit kernel, you run 32-bit.

115
00:09:46,140 --> 00:09:49,790
If it's 64-bit, you run 64-bit.

116
00:09:49,790 --> 00:09:53,590
So this expands your testing matrix slightly.

117
00:09:53,590 --> 00:09:58,970
Each of these tests is going to be a little
more involved as you're testing to make sure

118
00:09:58,970 --> 00:10:04,900
that your kexts runs on the various kernels proper.

119
00:10:04,900 --> 00:10:13,210
One of the problems you can run into is that various
functions have changed, for example, memory descriptors.

120
00:10:13,210 --> 00:10:21,140
They had to change in 10.5 to support x86
user processes, or 64-bit user processes.

121
00:10:21,140 --> 00:10:25,600
The kernel was still 32-bit, and so we had
to deal with the memory address translations.

122
00:10:25,600 --> 00:10:31,400
To do that, you have to use conditional
compilations and availability macros.

123
00:10:31,400 --> 00:10:37,820
Weak linking doesn't really exist in
the kernel for all intents and purposes.

124
00:10:37,820 --> 00:10:42,150
Now when you're deploying a kext, one
way you can support multiple platforms is

125
00:10:42,150 --> 00:10:46,120
by having multiple kexts nested inside of one package.

126
00:10:46,120 --> 00:10:48,280
Dean will talk about this a little more later,

127
00:10:48,280 --> 00:10:54,520
but it can make things very easy for
the system to find the proper kext.

128
00:10:54,520 --> 00:10:59,680
You can fairly easily support all
Leopard or better kernels with one kext.

129
00:10:59,680 --> 00:11:02,570
You can support earlier kernels.

130
00:11:02,570 --> 00:11:08,830
And if you want to do that, you're going to want to go
back and look at last years Creating I/O Kit Drivers

131
00:11:08,830 --> 00:11:11,820
for Multiple Architectures and OS Versions.

132
00:11:11,820 --> 00:11:17,780
They have a very detailed overview of how you have to
link them all together and munge them so that they work.

133
00:11:17,780 --> 00:11:21,050
When you're working in the kernel
you have to deal with panics.

134
00:11:21,050 --> 00:11:24,640
Panics are even harder to debug than
your regular kernel environment.

135
00:11:24,640 --> 00:11:27,120
You've got a static slice of the operating system.

136
00:11:27,120 --> 00:11:33,150
You can poke around, you can look around, but it's sort
of like CSI, you're trying to figure out who killed you.

137
00:11:33,150 --> 00:11:36,740
Again, two machine works well if you already have it set up.

138
00:11:36,740 --> 00:11:38,960
Once the panics happen, too late.

139
00:11:38,960 --> 00:11:44,300
One thing that can be very handy
is having your system dump core.

140
00:11:44,300 --> 00:11:50,170
What this means is, it, you can set it up so that
it will write out the kernel memory to a core file

141
00:11:50,170 --> 00:11:54,750
that you can then look at later, or at a different location.

142
00:11:54,750 --> 00:12:02,970
So, anyhow, if you have a panic that happens infrequently,
you can set up a bunch of test machines and when they crash,

143
00:12:02,970 --> 00:12:05,370
they can dump core and you can take a look at them.

144
00:12:05,370 --> 00:12:13,200
If you want to know how to set up a kernel system
for dumping core, you want to see Tech Note 2118`.

145
00:12:13,200 --> 00:12:16,770
That will show you how to set up an Ethernet core dump.

146
00:12:16,770 --> 00:12:22,860
And again, fwkdp is how you can dump core over FireWire.

147
00:12:22,860 --> 00:12:26,560
All of the panic debugging is covered in Tech Note 2063.

148
00:12:26,560 --> 00:12:33,470
It's a very good place to look
to figure out what went wrong.

149
00:12:33,470 --> 00:12:39,440
And it is another one of those things I would highly
recommend that anybody working in the kernel reads.

150
00:12:39,440 --> 00:12:41,830
So why do you work in the kernel?

151
00:12:41,830 --> 00:12:44,920
For whatever reason you need to
have closer access to hardware.

152
00:12:44,920 --> 00:12:47,960
You need kernel resources.

153
00:12:47,960 --> 00:12:51,910
The kernel, being in the kernel
gets you that special access.

154
00:12:51,910 --> 00:12:54,060
It's more challenging than user space.

155
00:12:54,060 --> 00:12:57,740
I'm sure that's not a surprise to anybody here.

156
00:12:57,740 --> 00:13:06,080
It opens up, you up to a whole new class of defects, panics,
which can deprive your user of the use of their system.

157
00:13:06,080 --> 00:13:09,900
And you get much more limited access to system resources.

158
00:13:09,900 --> 00:13:14,410
You can't hit the hard drive, for
example, and access config files.

159
00:13:14,410 --> 00:13:28,240
If you need a custom interface for crossing the user kernel
boundary, you may need to write your own custom user client.

160
00:13:28,240 --> 00:13:36,020
This is even harder to debug than a kext, because you've
got two separate processes in two separate memory spaces

161
00:13:36,020 --> 00:13:42,870
with two separate debuggers attached to them, and
figuring out who's calling whom can be very confusing.

162
00:13:42,870 --> 00:13:46,540
There is almost always a better choice.

163
00:13:46,540 --> 00:13:50,120
I would highly recommend that you not do this.

164
00:13:50,120 --> 00:13:53,790
Code running in the kernel is inherently trusted.

165
00:13:53,790 --> 00:14:01,020
So if you create, the reason you create an I/O
User Client is to cross that trust boundary.

166
00:14:01,020 --> 00:14:05,640
If you make your own user client, you become the gatekeeper.

167
00:14:05,640 --> 00:14:09,270
What that means is, you have to validate everything.

168
00:14:09,270 --> 00:14:13,520
Any data that comes in from user space, you
have to check to make sure that it makes sense.

169
00:14:13,520 --> 00:14:19,030
Any pointers that you pass out, you cannot trust
them to be the same pointer that comes back in.

170
00:14:19,030 --> 00:14:25,450
Even if just a connect, an application connecting to
your user client, if that could elevate privileges

171
00:14:25,450 --> 00:14:29,010
or affect another user task, you need to verify

172
00:14:29,010 --> 00:14:34,430
that the connecting application has
the right to access your user client.

173
00:14:34,430 --> 00:14:39,480
If you want to know how to do any
of this, the SimpleUserClient

174
00:14:39,480 --> 00:14:43,660
and the AppleSamplePCI driver are both very good examples.

175
00:14:43,660 --> 00:14:50,910
And this is another big reason you don't
want to do it; your test matrix explodes.

176
00:14:50,910 --> 00:14:56,440
You have to test all the various architectures
of user clients on all the various architectures

177
00:14:56,440 --> 00:15:02,680
of kernels, and it just becomes a testing nightmare.

178
00:15:02,680 --> 00:15:07,470
You can remove Rosetta support,
but this only helps a little bit.

179
00:15:07,470 --> 00:15:11,030
It's not a big win.

180
00:15:11,030 --> 00:15:13,350
And now for something completely different.

181
00:15:13,350 --> 00:15:18,290
I've been asked by members of the team to
give a couple of public service announcements.

182
00:15:18,290 --> 00:15:23,990
If you're doing a PCI driver, you want to
try and use Message-Signaled Interrupts.

183
00:15:23,990 --> 00:15:29,660
They are preferred, because there is
less interrupt sharing and it allows us

184
00:15:29,660 --> 00:15:34,740
to demux the interrupts, so that
only one driver gets called.

185
00:15:34,740 --> 00:15:46,650
The way you enable MSI is by supplying an index that
is greater than 1 to your I/O interrupt event source.

186
00:15:46,650 --> 00:15:49,260
When you do that, you don't need to supply a filter.

187
00:15:49,260 --> 00:15:55,320
So you can use the root class I/O interrupt
event source, interrupt event source.

188
00:15:55,320 --> 00:15:59,900
If you enable MSI, you disable the standard interrupts.

189
00:15:59,900 --> 00:16:04,600
If you've set them up, don't expect them to be called.

190
00:16:05,660 --> 00:16:08,080
This is supported on all Intel hardware.

191
00:16:08,080 --> 00:16:17,590
So as long, if you're still supporting Power PC, you're
going to have to still do some filtered interrupt support.

192
00:16:17,590 --> 00:16:24,720
Power Management: If you're in user space,
better performance equals better battery life.

193
00:16:24,720 --> 00:16:28,510
Periodic activity is worse than batching your activity.

194
00:16:28,510 --> 00:16:35,730
If you're constantly pinging the hard drive, it's going to
keep it from spinning down; it's going to use more power.

195
00:16:35,730 --> 00:16:40,960
If you can do all of your access and then let it go
to sleep, this is going to be better for your users.

196
00:16:40,960 --> 00:16:44,600
Another tool you have available to
you is the System Load Advisory API.

197
00:16:44,600 --> 00:16:53,610
Now this is as it might sound, an advisory API to
let you know what kind of power save is the user in?

198
00:16:53,610 --> 00:16:56,210
Is this a good time to do background tasks?

199
00:16:56,210 --> 00:16:57,340
Is this a bad time?

200
00:16:57,340 --> 00:17:01,100
Is it kind of OK?

201
00:17:01,100 --> 00:17:08,300
Some users, the way they use their system, it
never is a good time to do background tasks.

202
00:17:08,300 --> 00:17:13,560
So you want to use this to guide your behavior, but you're
going to want to have some kind of time out, so that,

203
00:17:13,560 --> 00:17:17,610
you know, OK, I've waited long enough,
I've got to just go ahead and do it.

204
00:17:17,610 --> 00:17:21,460
If you need to know about wake and sleep,

205
00:17:21,460 --> 00:17:26,980
the IO Kit.framework lets you subscribe
to the system power messages.

206
00:17:26,980 --> 00:17:35,180
If you need to prevent the system from going to
sleep, you want to use the IOPMAssertion APIs.

207
00:17:35,180 --> 00:17:41,340
They can set it so that your screen won't go to
sleep, for example, if your users watching a movie.

208
00:17:41,340 --> 00:17:44,930
Or that the system won't go to sleep,
if the users listening to music,

209
00:17:44,930 --> 00:17:47,100
the screen will still darken, the music will still play.

210
00:17:47,100 --> 00:17:50,950
And for those of you who know about SafeSleep,

211
00:17:50,950 --> 00:17:57,740
this is what happens when the system runs
out of battery when it's already asleep.

212
00:17:57,740 --> 00:18:00,040
You should not have to do anything different.

213
00:18:00,040 --> 00:18:04,180
It should look just the same to you: the
system went to sleep, it woke back up,

214
00:18:04,180 --> 00:18:07,190
the hardware was turned off, it got turned back on.

215
00:18:07,190 --> 00:18:09,180
There shouldn't be anything special that happens.

216
00:18:09,180 --> 00:18:13,780
If it looks like there's something
special, there's probably something wrong.

217
00:18:13,780 --> 00:18:20,410
Now Power Management's slightly different in the kext.

218
00:18:20,410 --> 00:18:27,040
Since any sleep can become SafeSleep, in the kernel,
you again, should not have to do anything different.

219
00:18:27,040 --> 00:18:29,910
It should look just the same to you.

220
00:18:29,910 --> 00:18:38,110
You can use IOService APIs to join the power tree so that
you can be notified of Power Management state changes.

221
00:18:38,110 --> 00:18:41,620
Most kexts don't need to know that,
so they're not part of that tree.

222
00:18:41,620 --> 00:18:48,230
It's important that your kext, anything in
your kext, only implements the mechanism.

223
00:18:48,230 --> 00:18:51,460
You do not want to hard code policy into your kext.

224
00:18:51,460 --> 00:18:59,640
Have a user space daemon that pushes information to
the kext and lets it know what the policy should be.

225
00:18:59,640 --> 00:19:06,290
You'll have some default policy in your kext, but you
definitely want to be pushing policy from user space.

226
00:19:06,290 --> 00:19:11,930
You also may have noticed that in Snow Leopard
we introduced something called maintenance wake.

227
00:19:11,930 --> 00:19:15,670
This was added for Bonjour sleep proxy.

228
00:19:15,670 --> 00:19:25,530
So your system could go to sleep and still maintain system
resources, or network resources, available on the web.

229
00:19:25,530 --> 00:19:31,380
Sleep Proxy, the Maintenance Wake is a
brief wake with the screen and audio off.

230
00:19:31,380 --> 00:19:34,250
It will not last more than 30 seconds.

231
00:19:34,250 --> 00:19:39,330
If you try and do something that takes longer
than that, you're just not going to get to.

232
00:19:39,330 --> 00:19:43,380
And it's only, again, it's only triggered
by Bonjour sleep proxy being active.

233
00:19:43,380 --> 00:19:47,360
And with that, I will hand it off to Dean.

234
00:19:47,360 --> 00:19:47,590
>> Dean: Hi.

235
00:19:47,590 --> 00:19:48,750
Thanks Thane.

236
00:19:48,750 --> 00:19:54,770
I'm going to talk to you a little bit about
taking your driver sort of the next step.

237
00:19:54,770 --> 00:19:55,490
You've got it written.

238
00:19:55,490 --> 00:19:57,600
It's working in your lab.

239
00:19:57,600 --> 00:20:01,290
But how do you take it from your
prototype all the way to being a product?

240
00:20:01,290 --> 00:20:03,870
What do you need to do to harden it and prepare it?

241
00:20:03,870 --> 00:20:08,600
And also, what resources Apple has to
help you if you get stuck along the way.

242
00:20:08,600 --> 00:20:12,280
So how to qualify a driver is an interesting question.

243
00:20:12,280 --> 00:20:16,590
And most engineers have a pretty good intuitive
sense of things that they need to test,

244
00:20:16,590 --> 00:20:19,900
because they know what the challenges
were when they were with the driver.

245
00:20:19,900 --> 00:20:26,680
But there's a lot of basic correctness tests that
often get overlooked, because they seem very basic.

246
00:20:26,680 --> 00:20:30,330
But I work with a lot of developers
and I see a lot of kernel extensions

247
00:20:30,330 --> 00:20:33,330
that have been shipped with some
pretty silly common mistakes.

248
00:20:33,330 --> 00:20:36,860
And as soon as we point them out to the developer,
it's like, oh yeah, of course, I need to fix that.

249
00:20:36,860 --> 00:20:40,830
But I'm going to go through kind of a laundry
list of things that you might want to look

250
00:20:40,830 --> 00:20:45,990
at before you even consider putting a driver into full QA.

251
00:20:45,990 --> 00:20:49,800
And also I recommend keeping records of
a lot of these results between releases,

252
00:20:49,800 --> 00:20:54,900
because we've found it's actually valuable to
compare from release to release how we're doing,

253
00:20:54,900 --> 00:20:59,110
particularly with Power Management
and with general performance.

254
00:20:59,110 --> 00:21:05,250
It can be very instructive, and you can start to notice
trends, and particularly if something steps out of line.

255
00:21:05,250 --> 00:21:10,860
So first on the sort of easy checks
is, look at the Info.plist.

256
00:21:10,860 --> 00:21:18,090
This is an XML file inside your kext bundle that is
sort of used by the kext management system to know

257
00:21:18,090 --> 00:21:22,430
under what conditions to load your kernel extension,
how to load it, what it depends on, and so on.

258
00:21:22,430 --> 00:21:27,110
But there's a few particular properties
I want to call your attention to.

259
00:21:27,110 --> 00:21:28,460
IOKitDebug.

260
00:21:28,460 --> 00:21:32,930
This is a property you can add to
your personalities in your plist,

261
00:21:32,930 --> 00:21:35,870
to turn on some additional logging
messages in the IOKit system.

262
00:21:35,870 --> 00:21:41,810
And its value is the decimal number;
I believe it's from zero to 65535.

263
00:21:41,810 --> 00:21:47,930
Well you need to either make sure that it's been
absent or set to zero when you ship your kext,

264
00:21:47,930 --> 00:21:52,540
because you don't want these additional
messages clogging up your users logs.

265
00:21:52,540 --> 00:21:57,960
And it's slowing down their system, because it
has to write these out to the disk at some point.

266
00:21:57,960 --> 00:21:59,830
Did you advance your version number?

267
00:21:59,830 --> 00:22:03,590
This is important, because it's one of
two properties that the kext system uses

268
00:22:03,590 --> 00:22:06,030
to uniquely identify your kernel extension.

269
00:22:06,030 --> 00:22:09,740
If you have two different versions
of your kext on the system,

270
00:22:09,740 --> 00:22:14,770
this is how the computer can differentiate
between them and load the newest one.

271
00:22:14,770 --> 00:22:20,360
It's also handy for support, when somebody calls in
with an issue you'll know exactly what they're running.

272
00:22:20,360 --> 00:22:26,530
In the CFBundleIdentifier is the other property used to
uniquely identify your kernel extension to the system.

273
00:22:26,530 --> 00:22:28,180
Make sure it's correctly formed.

274
00:22:28,180 --> 00:22:35,910
Make sure that you're using a reverse DNS style
identifier, com.yourcompanynamehere.driver.whatever.

275
00:22:35,910 --> 00:22:41,760
We don't want to see a bunch of kexts out there
with their CFBundleIdentifier being com.mydriver,

276
00:22:41,760 --> 00:22:44,410
or something like that from one of the examples.

277
00:22:44,410 --> 00:22:47,720
Because, again, if these collide, the
kext management system doesn't know

278
00:22:47,720 --> 00:22:50,090
that they're different kexts, it
assumes that they're the same.

279
00:22:50,090 --> 00:22:57,280
Two additional properties that have been misused
over the years, OSBundleCompatibleVersion.

280
00:22:57,280 --> 00:22:59,600
This is perhaps confusingly named.

281
00:22:59,600 --> 00:23:04,770
This is what tells the kext management
system that the kext is a library kext.

282
00:23:04,770 --> 00:23:11,500
It is describing the lower bound of a version
range that that text is binary compatible with.

283
00:23:11,500 --> 00:23:15,760
If it's presenting and interface
vessel or lower bound to the range.

284
00:23:15,760 --> 00:23:19,310
The actual CFBundleVersion being the upper bound.

285
00:23:19,310 --> 00:23:21,610
But if your kext is not a libary kext, and most

286
00:23:21,610 --> 00:23:25,600
of you probably are not making library
kext, then you do not need this property.

287
00:23:25,600 --> 00:23:31,010
Having it in there means the system will keep around
additional information assuming it's going to need the link.

288
00:23:31,010 --> 00:23:33,100
Use that information for linking later.

289
00:23:33,100 --> 00:23:39,710
So make sure that property is absent unless
you know you need it, because you're a library.

290
00:23:39,710 --> 00:23:42,700
And then also the OSBundleRequired property.

291
00:23:42,700 --> 00:23:48,900
This is used to determine if the booter has to load
your driver, or if it can be left later for the kernel.

292
00:23:48,900 --> 00:23:54,580
The only reason that the booter has to load
the driver is if it's necessary in order to go

293
00:23:54,580 --> 00:23:58,160
about mounting the root file system,
so that other drivers can be found.

294
00:23:58,160 --> 00:24:02,680
So most of your drivers probably don't need
to have the OSBundleRequired property, either.

295
00:24:02,680 --> 00:24:09,950
But if you've kind of developed your driver by cutting
and pasting from some other drivers you might have kind

296
00:24:09,950 --> 00:24:14,910
of absorbed these properties along the
way and you want to review their use.

297
00:24:14,910 --> 00:24:17,160
Bundle structure.

298
00:24:17,160 --> 00:24:21,090
Run Find on your kext and look
at every file that's in there.

299
00:24:21,090 --> 00:24:25,520
There's really only two files that have to be
there: there's the Info.plist and then the binary

300
00:24:25,520 --> 00:24:27,990
that actually gets loaded into the kernels.

301
00:24:27,990 --> 00:24:31,510
You should be able to account for
every file that's in the bundle.

302
00:24:31,510 --> 00:24:35,210
I've seen kernel extensions ship with header files in them.

303
00:24:35,210 --> 00:24:38,260
That their build process somehow copied in there.

304
00:24:38,260 --> 00:24:43,120
I've seen lots of stuff in there, a
GDB debug sessions files left in there.

305
00:24:43,120 --> 00:24:50,580
Yeah, go through and do some hygiene there and make sure
those files are all removed if they don't need to be there.

306
00:24:50,580 --> 00:24:54,320
And of course, ownership and permissions,
you kext won't even load if these are wrong.

307
00:24:54,320 --> 00:24:58,130
But this is a good opportunity to make
sure they're owned by root, group is wheel,

308
00:24:58,130 --> 00:25:01,440
and they're set up so they can't
be modified by any other user.

309
00:25:01,440 --> 00:25:09,030
Kextutil-tn is a great tool to help you find,
sort of structural problems with your kext.

310
00:25:09,030 --> 00:25:15,190
Any kind of an issue that, you know, maybe would be
fatal, maybe even not fatal, maybe it's just a warning.

311
00:25:15,190 --> 00:25:19,860
But it does; the t means test the kext,
perform the strictest test that it can.

312
00:25:19,860 --> 00:25:21,960
And n means don't actually load it.

313
00:25:21,960 --> 00:25:26,630
So this is just doing all the proofing
that it would do before it loads the kext.

314
00:25:26,630 --> 00:25:29,680
So that's kextutil on Snow Leopard and later.

315
00:25:29,680 --> 00:25:32,480
Prior to Snow Leopard, that's kextload.

316
00:25:32,480 --> 00:25:37,700
In Snow Leopard we split out the
developer tool into kextutil.

317
00:25:37,700 --> 00:25:40,020
We also have a tool called kextlibs.

318
00:25:40,020 --> 00:25:43,450
And this is a great way to find out
what your dependencies ought to be.

319
00:25:43,450 --> 00:25:47,820
If you don't know exactly what other
library kext you should be linking on,

320
00:25:47,820 --> 00:25:54,740
the kextlibs tool will actually even give you the little
XML blurb that you can copy and past right into your plist

321
00:25:54,740 --> 00:25:56,310
to make sure you got your dependencies right.

322
00:25:56,310 --> 00:26:03,050
So we would hope you'd use that to make sure
your dependencies are as tight as they can be.

323
00:26:03,050 --> 00:26:09,020
Now the binary inside the bundle is
the PC gets loaded into the kernel.

324
00:26:09,020 --> 00:26:11,790
And, but it also contains a lot of symbolic information.

325
00:26:11,790 --> 00:26:16,080
Obviously we have to link that into the kernel, so you
got to have all your undefined symbols defined there.

326
00:26:16,080 --> 00:26:19,800
And if you're a library you have to have
your exported symbols there as well.

327
00:26:19,800 --> 00:26:25,690
But you want to make sure that that was built
with the release configuration of Xcode.

328
00:26:25,690 --> 00:26:29,680
Because if you have it set to debug,
you're going to get a lot of debug symbols.

329
00:26:29,680 --> 00:26:33,170
You're going to get like ten times as large
a symbol table as you would actually need.

330
00:26:33,170 --> 00:26:35,310
So the binary gets very large.

331
00:26:35,310 --> 00:26:39,840
And you're actually leaking a lot of
information about the structure of your code.

332
00:26:39,840 --> 00:26:43,010
You're also going to want to verify
that your architectures are correct.

333
00:26:43,010 --> 00:26:47,920
Make sure that every architecture you need is present,
and that none that you don't need are present.

334
00:26:47,920 --> 00:26:54,870
So there's three that you would encounter in
this development space: i386 for 32-bit Intel,

335
00:26:54,870 --> 00:26:59,170
x86_64 for 64-bit Intel, and ppc for 32-bit par PC.

336
00:26:59,170 --> 00:27:02,560
You should also run nm on the kernel.

337
00:27:02,560 --> 00:27:08,700
Nm is the, on the kext, nm is the utility that
dumps all the symbols in the symbol table.

338
00:27:08,700 --> 00:27:11,320
And there's a variety of options
and other things you can do.

339
00:27:11,320 --> 00:27:20,310
I've given you a line here that runs it through a filter
to convert the C++ mangled names into human readable names.

340
00:27:20,310 --> 00:27:23,530
And then removes all of the undefined symbols.

341
00:27:23,530 --> 00:27:28,910
So what you're going to be left with here
is a list of symbols that your kext defines.

342
00:27:28,910 --> 00:27:30,870
Make sure that they're named correctly.

343
00:27:30,870 --> 00:27:36,460
You really want all your global symbols to have a
prefix that uniquely identifies them to your kext.

344
00:27:36,460 --> 00:27:40,950
Ideally the reverse DNS that matches
your CFBundleIdentifier,

345
00:27:40,950 --> 00:27:44,010
but with the periods replaced with under bars.

346
00:27:44,010 --> 00:27:48,500
And the reason for this is the kernel
uses a single, flat name space.

347
00:27:48,500 --> 00:27:53,880
All the kexts, when they link, link against all their
libraries, and those all link against the kernel.

348
00:27:53,880 --> 00:27:57,920
If you have any symbol collision along the
way, it won't load your kernel extension.

349
00:27:57,920 --> 00:28:05,550
So if you have a function called qsort and then a version of
our kernel Apps qsort, which I think we actually view now,

350
00:28:05,550 --> 00:28:09,000
your kext will not load, because you have duplicate symbols.

351
00:28:09,000 --> 00:28:15,500
So you want to make sure that your
global names are all well qualified.

352
00:28:15,500 --> 00:28:18,360
OK, so far we've just been looking at the kext passively.

353
00:28:18,360 --> 00:28:21,500
Now we actually want to try loading
it, and here's some things you can do.

354
00:28:21,500 --> 00:28:26,720
Watch the system log and kernel logs while
you're loading your kernel extension.

355
00:28:26,720 --> 00:28:30,250
Look for any warnings, or errors, or
any other kind of messages that come

356
00:28:30,250 --> 00:28:32,120
out that seem scary, and go chase those down.

357
00:28:32,120 --> 00:28:33,920
Figure out why they're there.

358
00:28:33,920 --> 00:28:37,300
The messages that we spit out are usually meaningful.

359
00:28:37,300 --> 00:28:38,590
They usually are important.

360
00:28:38,590 --> 00:28:41,140
And if you're having trouble understanding what they mean,

361
00:28:41,140 --> 00:28:46,010
the various mail lists that our own
lists can usually help shine a light.

362
00:28:46,010 --> 00:28:47,940
Also, unload your kext.

363
00:28:47,940 --> 00:28:52,090
I recommend getting this working very early
in your development cycle, and here's why.

364
00:28:52,090 --> 00:28:57,560
When you're developing the kernel, you want to
be able to load your kext, try something out,

365
00:28:57,560 --> 00:29:00,330
unload your kext, make a few changes, reload.

366
00:29:00,330 --> 00:29:03,760
You know, hopefully you won't panic every
time and have to reboot the computer.

367
00:29:03,760 --> 00:29:09,600
So some of the time unload can save you, can
actually make your development cycle much more rapid.

368
00:29:09,600 --> 00:29:13,310
But it's also important to make unload
work, because it really helps ensure

369
00:29:13,310 --> 00:29:16,140
that you've got a lot of your references right.

370
00:29:16,140 --> 00:29:18,120
You're not leaking references to your objects.

371
00:29:18,120 --> 00:29:20,840
You're not leaving dangling objects around.

372
00:29:20,840 --> 00:29:26,970
So if unload won't work, that probably means that either
somebody is holding a reference to one of your objects

373
00:29:26,970 --> 00:29:30,380
or you've leaked a instance of an
object and we won't unload you.

374
00:29:30,380 --> 00:29:36,450
Also, you know, while you're doing this, make sure that the
system sleeps and wakes correctly while your kext is loaded.

375
00:29:36,450 --> 00:29:39,920
And make sure your driver will unload
after the device has gone away.

376
00:29:39,920 --> 00:29:44,600
If you unplug your device after about a minute,
your driver should automatically unload.

377
00:29:44,600 --> 00:29:49,300
And also try Safe Boot, that's where
you boot holding down the Shift key.

378
00:29:49,300 --> 00:29:54,910
This bypasses the kernel caches, the kext caches,
and actually tells the system to rebuild them.

379
00:29:54,910 --> 00:30:00,760
But that has the booter load the drivers
individually as opposed to a cache.

380
00:30:00,760 --> 00:30:04,390
And this gives you a way of testing
a few more configurations

381
00:30:04,390 --> 00:30:08,100
that your users will encounter under some circumstances.

382
00:30:08,100 --> 00:30:10,660
Now cycling is a really powerful tool.

383
00:30:10,660 --> 00:30:14,920
This is something we use pretty extensively
at Apple and we find a lot of things.

384
00:30:14,920 --> 00:30:17,940
This helps us harden the code quite a bit.

385
00:30:17,940 --> 00:30:21,020
But it's not just about repeating
a task over and over again,

386
00:30:21,020 --> 00:30:25,170
it's about watching the impact of that task on the system.

387
00:30:25,170 --> 00:30:30,430
If you load and unload your kext one time, it's
unlikely that you're going to notice any leaked memory,

388
00:30:30,430 --> 00:30:33,560
because it's probably not a lot of memory.

389
00:30:33,560 --> 00:30:38,540
But if you load it and unload it
1,000 times, you can see a pattern.

390
00:30:38,540 --> 00:30:42,450
So we have some tools like ioclasscount,
ioalloccount, zprint,

391
00:30:42,450 --> 00:30:46,190
and top that all monitor various things around the system.

392
00:30:46,190 --> 00:30:51,420
And if you can cycle some of these
activities, then you can watch for trends.

393
00:30:51,420 --> 00:30:57,240
You can look for, you know, some particular
zone of memory blowing up, and realize,

394
00:30:57,240 --> 00:30:59,620
OK, maybe I am leaking some resource here.

395
00:30:59,620 --> 00:31:00,890
These are important things to fix.

396
00:31:00,890 --> 00:31:06,250
As Thane pointed out, kernel memory
allocated by kext is, by default, wired.

397
00:31:06,250 --> 00:31:11,160
And so that's memory that if it gets leaked, the only
way to recover that memory is to reboot the computer.

398
00:31:11,160 --> 00:31:14,940
It's gone as far as the kernel is considered, as concerned.

399
00:31:14,940 --> 00:31:18,770
So take leaks like that very seriously please.

400
00:31:18,770 --> 00:31:24,900
And of course, you know, I've listed a few things
you can cycle here: sleep, wake, attach, detach.

401
00:31:24,900 --> 00:31:28,540
But your product, obviously, is going
to have some very common operations.

402
00:31:28,540 --> 00:31:30,060
Cycle those as well.

403
00:31:30,060 --> 00:31:36,020
We give you a tool in the developer's tools called
SleepX that will allow you to do sleep cycling.

404
00:31:36,020 --> 00:31:40,290
So that is actually a very powerful
tool for checking that transition.

405
00:31:40,290 --> 00:31:41,220
And set a goal.

406
00:31:41,220 --> 00:31:43,800
I mean this is pretty basic test methodology, right?

407
00:31:43,800 --> 00:31:46,410
We usually try to start at 1,000.

408
00:31:46,410 --> 00:31:49,420
Sometimes some of our goals are up over 10,000 cycles.

409
00:31:49,420 --> 00:31:52,170
It really just depends on how long it
takes to get through a cycle of something.

410
00:31:52,170 --> 00:31:54,430
But this is another area to keep records.

411
00:31:54,430 --> 00:31:58,430
You know, how many thousands of cycles can
this go, and let it go over the weekend,

412
00:31:58,430 --> 00:32:02,210
and helps you see if your quality is improving.

413
00:32:02,210 --> 00:32:05,770
Okay, so you've hammered out your kext.

414
00:32:05,770 --> 00:32:06,690
You've tested it.

415
00:32:06,690 --> 00:32:13,380
You've got it hardened by cycling, and now
you're ready to put it into your users hands.

416
00:32:13,380 --> 00:32:15,130
What do you need to do to do that?

417
00:32:15,130 --> 00:32:21,510
Well we have a tool called Package Maker that will
create a .pkg file that the Apple Installer knows about.

418
00:32:21,510 --> 00:32:26,620
And it automatically does all the
right things to install a kext, right?

419
00:32:26,620 --> 00:32:32,290
So if you don't want to have to worry about
setting owners and permissions correctly, you know,

420
00:32:32,290 --> 00:32:35,570
you don't want to deal with touching the
extensions folder, all of those other things

421
00:32:35,570 --> 00:32:38,680
that you might have seen on Apple Tech Notes.

422
00:32:38,680 --> 00:32:42,750
The Package Maker will generate a package
that does all the right things for you.

423
00:32:42,750 --> 00:32:49,520
And as it turns out there's a nice walkthrough
that describes exactly how to go about doing this

424
00:32:49,520 --> 00:32:52,750
in the Packaging a Kernel Extension
for Distribution and Installation.

425
00:32:52,750 --> 00:32:54,220
It's a very straightforward title.

426
00:32:54,220 --> 00:32:55,360
It says exactly what it's about.

427
00:32:55,360 --> 00:32:59,410
But it walks you through packaging up an example kext.

428
00:33:00,510 --> 00:33:06,880
Now, what's actually going on behind the scenes here is that
your kext is being copied into system library extensions,

429
00:33:06,880 --> 00:33:10,630
which is the folder for auto loaded kernel extensions.

430
00:33:10,630 --> 00:33:15,590
Please do not install kext in library extensions.

431
00:33:15,590 --> 00:33:20,620
There have been a few discussions on the mail lists
about, you know, why doesn't Apple use library extensions,

432
00:33:20,620 --> 00:33:27,690
because it should, because other file system
domains include libraries as opposed to just system library.

433
00:33:27,690 --> 00:33:29,910
And this is a decision that was made early on.

434
00:33:29,910 --> 00:33:32,130
We've revisited it a few times.

435
00:33:32,130 --> 00:33:35,400
But we want to keep library extensions for future use.

436
00:33:35,400 --> 00:33:37,500
We think we might want to use it in the future.

437
00:33:37,500 --> 00:33:43,390
But if you're installing kernel extensions there
now, that limits how we could use it in the future.

438
00:33:43,390 --> 00:33:47,110
Plus, there's no reason to install them there
now, because it doesn't actually mean anything.

439
00:33:47,110 --> 00:33:48,830
It's just a folder.

440
00:33:48,830 --> 00:33:52,660
So put them in system library extensions
if you want them to auto load.

441
00:33:52,660 --> 00:33:58,580
If they're tied to an application, if you have a
kernel extension that really is only there in support

442
00:33:58,580 --> 00:34:03,650
of a specific application, then you
can put the kext inside the app.

443
00:34:03,650 --> 00:34:13,390
It can be inside its resources, or plug-ins folder, and
the app can load it programmatically by running kext load.

444
00:34:13,390 --> 00:34:18,810
Thane had mentioned earlier that you can nest kernel
extensions, and the reason you might want to do that is

445
00:34:18,810 --> 00:34:23,090
to have one top-level kext with
a family of supporting kexts.

446
00:34:23,090 --> 00:34:26,360
We will support up to one level
of nesting for kernel extensions.

447
00:34:26,360 --> 00:34:32,190
So inside the plug-ins folder of a kext you can have
as many kexts as you need for your suite of drivers,

448
00:34:32,190 --> 00:34:35,480
and deliver them as if they were one kext.

449
00:34:35,480 --> 00:34:37,640
It's actually pretty handy if you, say,

450
00:34:37,640 --> 00:34:41,880
have an older version of the kernel
extension that's supported PPC hardware,

451
00:34:41,880 --> 00:34:45,030
and you don't want to re-QA it and redevelop it.

452
00:34:45,030 --> 00:34:54,400
You can just shift that as a subkext of your main
kext or new shiny Intel 64-bit kernel extension.

453
00:34:54,400 --> 00:34:59,670
And that, the subkext will be used on the
64-bit, or excuse me, on PAR PC systems,

454
00:34:59,670 --> 00:35:02,990
and the main one will be used on Intel 64 systems.

455
00:35:02,990 --> 00:35:07,350
The talk, last years talk that Thane
referenced earlier will describe exactly the ins

456
00:35:07,350 --> 00:35:09,870
and outs of how to make all that work.

457
00:35:09,870 --> 00:35:16,780
After you've installed a kernel extension, or modified one,
or removed one, you need to touch the extensions folder.

458
00:35:16,780 --> 00:35:23,480
This changes its modification date and allows the caching
system to know that it's time to regenerate the caches.

459
00:35:23,480 --> 00:35:25,970
You shouldn't directly manage the caches.

460
00:35:25,970 --> 00:35:29,000
The caches for every release of MAC OS X have changed.

461
00:35:29,000 --> 00:35:34,550
We've constantly been refining them and it's
difficult for you to try to manage them,

462
00:35:34,550 --> 00:35:36,810
because you have to do something different on every release.

463
00:35:36,810 --> 00:35:38,400
You should not need to.

464
00:35:38,400 --> 00:35:43,600
If you encounter a situation where you really do need to
manage the caches to get your product to work correctly,

465
00:35:43,600 --> 00:35:46,510
please file a bug that would be a bug on us.

466
00:35:46,510 --> 00:35:50,230
Because the caches should always
reflect what's in the extensions folder.

467
00:35:50,230 --> 00:35:54,820
Assuming you've honored the contract
of touching system library extensions.

468
00:35:54,820 --> 00:35:59,210
Now if you want to have a kext immediately
available for use without requiring a reboot,

469
00:35:59,210 --> 00:36:02,830
there's a tech note for that, a Technical Q&A 1319.

470
00:36:02,830 --> 00:36:07,120
What it boils down to is you want to
send the SIGHUP to kext D.

471
00:36:07,120 --> 00:36:13,450
And the tech note, or the Technical Q&A describes
exactly under what OS releases you can do that,

472
00:36:13,450 --> 00:36:19,090
and how you go about finding its process ID,
and, and, it's pretty straightforward though.

473
00:36:19,090 --> 00:36:25,070
Now if you can't use Package Maker, if you need to
install your kext through some other installation utility

474
00:36:25,070 --> 00:36:27,980
for whatever reason, you can certainly do that.

475
00:36:27,980 --> 00:36:30,440
But there's a few things you need to make sure of.

476
00:36:30,440 --> 00:36:37,830
First off, make sure that the installed version
of your kext exactly matches what you built.

477
00:36:37,830 --> 00:36:43,030
I've seen installers that modify kernel, or
modify files that get installed they send them,

478
00:36:43,030 --> 00:36:48,380
because they think they need, don't need all the
binaries, or they change the permissions in odd ways.

479
00:36:48,380 --> 00:36:55,600
You should go and make sure that not only the data, but the
meta data, the, the ownership and permissions and ACLs,

480
00:36:55,600 --> 00:37:00,310
[phonetic] and extended attributes, and
anything else on those files are correct.

481
00:37:00,310 --> 00:37:04,190
And also make sure that it does touch the
extensions folder to update the mod date.

482
00:37:04,190 --> 00:37:06,720
And there's a common trap here that I'll warn you about.

483
00:37:06,720 --> 00:37:12,690
The first time you install a kext, that effectively
creates a new subdirectory in the extensions folder

484
00:37:12,690 --> 00:37:16,300
that guarantees the mod date of
the extensions folder gets updated.

485
00:37:16,300 --> 00:37:21,200
But when you reinstall that kext,
it's just overlaying the same files.

486
00:37:21,200 --> 00:37:28,570
The folder, the .kext folder that was created during
the first install doesn't get reinstalled, right?

487
00:37:28,570 --> 00:37:29,590
It's already there.

488
00:37:29,590 --> 00:37:34,290
So the extensions folder mod date
doesn't change in that case.

489
00:37:34,290 --> 00:37:37,910
So that's why you want to make sure that the
installer works after an upgrade as well.

490
00:37:37,910 --> 00:37:40,590
The second time after the kext is already present,

491
00:37:40,590 --> 00:37:45,670
you want to make sure it's still touching the
extensions folder, so the caching can take over.

492
00:37:45,670 --> 00:37:51,110
And you also want to make sure that if you are doing
an upgrade install that if you have any old resources

493
00:37:51,110 --> 00:37:56,040
or old files from your previous kext, until they get
removed, obviously you don't want anything bleeding

494
00:37:56,040 --> 00:38:01,430
through from a previous version,
because that can lead to who knows what.

495
00:38:01,430 --> 00:38:06,210
OK, if you get stuck along the way, if you
need some help, there's a large variety

496
00:38:06,210 --> 00:38:09,500
of resources available in the Apple Developer Community.

497
00:38:09,500 --> 00:38:15,330
And I'm going to start you off at the Hardware
and Drivers page off of developer.apple.com.

498
00:38:15,330 --> 00:38:18,190
This is probably going to be your
hub for doing driver development.

499
00:38:18,190 --> 00:38:22,980
Pretty much all the resources that Thane and I have
talked about today are referenced through there.

500
00:38:22,980 --> 00:38:30,620
There are, there are developer
forums, developer.apple.com/devforums,

501
00:38:30,620 --> 00:38:34,210
and they haven't been used extensively
for device support to date.

502
00:38:34,210 --> 00:38:39,820
We do have a forum on there for 64-bit
migration, and it is suitable and appropriate

503
00:38:39,820 --> 00:38:43,260
to talk about 64-bit kernel issues there.

504
00:38:43,260 --> 00:38:48,440
There's certainly the mail lists that are pretty common,
the darwin mail lists: darwin-kernel, darwin-drivers,

505
00:38:48,440 --> 00:38:52,240
and development that'll be suitable for any of these topics.

506
00:38:52,240 --> 00:38:57,800
And then there's application or domain
specific ones like USB, FireWire, ata-scsi-dev,

507
00:38:57,800 --> 00:39:01,240
where you can ask questions about those specific areas.

508
00:39:01,240 --> 00:39:06,490
And of course, at any point along the way, if you
think that something is not behaving correctly,

509
00:39:06,490 --> 00:39:10,020
or not behaving as documented, please file a bug report.

510
00:39:10,020 --> 00:39:12,320
This is how we know what we need to do.

511
00:39:12,320 --> 00:39:15,110
This is important communication.

512
00:39:15,110 --> 00:39:20,210
I know it feels sometimes like a one-way street where
you file a bug and you never hear back about it.

513
00:39:20,210 --> 00:39:25,360
But understand that that's a voice that comes
in and gets added to a lot of other voices.

514
00:39:25,360 --> 00:39:30,130
And it helps us understand maybe collectively
where we should be putting our resources.

515
00:39:30,130 --> 00:39:36,540
So it does help us understand how to focus
on, or what to focus on, I should say.

516
00:39:36,540 --> 00:39:41,310
So please don't be shy about filing bug reports
if you think you've encountered a defect.

517
00:39:41,310 --> 00:39:44,800
You probably shouldn't be filing bug
reports just to get answers, right?

518
00:39:44,800 --> 00:39:48,580
If something isn't working, because
you don't quite understand it,

519
00:39:48,580 --> 00:39:51,030
that's not the same as something
isn't working, you understand it,

520
00:39:51,030 --> 00:39:53,880
you're following the directions, and it's just not working.

521
00:39:53,880 --> 00:39:59,520
If you're not sure and you want some one-on-one
help, you can always request a DTS Incident.

522
00:39:59,520 --> 00:40:04,500
These are paid support sessions where an
Apple engineer will work with you to try

523
00:40:04,500 --> 00:40:07,510
to resolve the problem that you're having.

524
00:40:07,510 --> 00:40:12,370
All of these methods have been used to great
effect by many of the developers I've worked with.

525
00:40:12,370 --> 00:40:13,970
So please use your community.

