WEBVTT

00:00:07.070 --> 00:00:07.890
>> Gregory Hughes: Good morning.

00:00:07.890 --> 00:00:10.910
My name is Gregory Hughes and I'm
a software engineer at Apple.

00:00:10.910 --> 00:00:14.750
I'm really excited to be able to have the
opportunity to speak to you this morning,

00:00:14.750 --> 00:00:18.250
and today you're going to learn how
to use universal design principles

00:00:18.250 --> 00:00:21.490
to make your applications better and more accessible.

00:00:21.490 --> 00:00:25.500
And I want to start off by explaining
what I mean by universal design.

00:00:25.500 --> 00:00:30.230
And to illustrate universal design, I thought I
would use something we're all very familiar with,

00:00:30.230 --> 00:00:33.490
and that's the kitchen stove.

00:00:33.490 --> 00:00:36.700
I'm sure most of you use the kitchen
stove on a very regular basis

00:00:36.700 --> 00:00:40.960
and most people accept the design of the kitchen stove.

00:00:40.960 --> 00:00:47.950
However, it turns out that the design is actually quite
poor, specifically the row of knobs across the front

00:00:47.950 --> 00:00:51.310
and the back of the stove that
are used to control the burners.

00:00:51.310 --> 00:00:58.650
Each of these knobs requires a small icon or a localized
label to tell a user what burner that knob controls.

00:00:58.650 --> 00:01:02.720
Now I know with this design I personally
have accidentally turned on the wrong burner

00:01:02.720 --> 00:01:05.290
and this is a really, really common mistake.

00:01:05.290 --> 00:01:10.250
And in the case of a stove, it can
actually be a very dangerous mistake.

00:01:10.250 --> 00:01:13.200
Now, users make this mistake for a number of reasons.

00:01:13.200 --> 00:01:17.300
Perhaps, they're in a hurry preparing dinner
for guests, maybe water is boiling over

00:01:17.300 --> 00:01:19.960
or maybe the user just forgot their glasses in another room.

00:01:19.960 --> 00:01:25.260
However, with this design, there are
also a number of accessibility concerns.

00:01:25.260 --> 00:01:28.540
For someone with low vision, it can be
very difficult to read these labels.

00:01:28.540 --> 00:01:33.630
For someone who is completely blind, it could be really
difficult to figure out which knob controls which burner.

00:01:33.630 --> 00:01:38.830
And for someone with a cognitive impairment, it
can be very difficult to create the mental mapping

00:01:38.830 --> 00:01:42.360
between this row of knobs and the matrix of burners.

00:01:42.360 --> 00:01:48.200
So if we design the stove more universally, if we
think about the needs of all users including users

00:01:48.200 --> 00:01:51.250
with disabilities, we can end up making a much better stove.

00:01:51.250 --> 00:01:56.200
If we rearrange the knobs so that
they're in the same order as the burners,

00:01:56.200 --> 00:01:59.220
the stove becomes much easier to use for everyone.

00:01:59.220 --> 00:02:00.810
You no longer need to read a label.

00:02:00.810 --> 00:02:03.950
You instantly know which knob controls which burner.

00:02:03.950 --> 00:02:09.400
It's now also more accessible because someone with
low vision doesn't need to read a label and someone

00:02:09.400 --> 00:02:14.770
who is blind is able to feel the knobs and
know exactly which burner that knob controls.

00:02:14.770 --> 00:02:20.320
And equally, someone with a cognitive impairment will
have a much easier time making the mental mapping

00:02:20.320 --> 00:02:23.700
between the arrangement of knobs
and the arrangement of burners.

00:02:23.700 --> 00:02:29.040
In the case of the stove, an equally valid
design choice may be to rearrange the burners

00:02:29.040 --> 00:02:31.420
so that they're in the same order as the knobs.

00:02:31.420 --> 00:02:37.070
So we see here by applying some universal design
principles, by looking at the needs of all of our users,

00:02:37.070 --> 00:02:41.090
we end up making a much more usable,
much better product for everyone

00:02:41.090 --> 00:02:46.250
that everyone will have an easier time
using and will reduce user frustrations.

00:02:46.250 --> 00:02:51.550
And so that's what I would like to talk to you today
about: How you can apply these universal design principles

00:02:51.550 --> 00:02:57.960
to your software to make it better for everyone so that your
users experience less frustrations in using your software.

00:02:57.960 --> 00:03:01.940
At the same time, you'll be making
your software more accessible.

00:03:01.940 --> 00:03:06.730
And to talk about that today, I have three main focus areas.

00:03:06.730 --> 00:03:08.580
First are the end users.

00:03:08.580 --> 00:03:13.960
Now with all design, you want to start thinking
about the needs and requirements of your users.

00:03:13.960 --> 00:03:23.010
Oftentimes universal design goes hand in hand with the term
user-centric design, and that's design focused on the users.

00:03:23.010 --> 00:03:28.180
So, not only do you want to think about the users here
but you want to think about how and where and potentially

00:03:28.180 --> 00:03:31.780
when they'll be using your software
and under what circumstances.

00:03:31.780 --> 00:03:38.360
So then, I'd like to speak about some of the accessible
technologies that Apple has built into a number

00:03:38.360 --> 00:03:45.440
of our products, and these help highlight how
accessible technologies also make products better.

00:03:45.440 --> 00:03:51.810
These universal design features are making the operating
system and our portable products better for everyone.

00:03:51.810 --> 00:04:00.460
And last, I want to talk about how you the developers
specifically can make enhancements to your applications

00:04:00.460 --> 00:04:03.770
to make them better for everyone
and more universally designed.

00:04:03.770 --> 00:04:07.830
So, let's start with the users.

00:04:07.830 --> 00:04:13.920
And to get an idea of what we're talking about
here, I want to start off with some statistics.

00:04:13.920 --> 00:04:20.630
In the U.S., 10 million people have a vision
impairment, 31 million people have hearing impairment,

00:04:20.630 --> 00:04:23.640
and 12 million people have a learning disability.

00:04:23.640 --> 00:04:29.260
And what that means is that 1 in 5
people in the U.S. has a disability.

00:04:30.310 --> 00:04:33.060
That's 50 million people.

00:04:33.060 --> 00:04:40.360
Let's stop and think about that for a minute, 50
million people have a disability in the U.S. alone.

00:04:40.360 --> 00:04:45.460
By making yourself more universally designed
and more accessible, you're going to be able

00:04:45.460 --> 00:04:49.600
to have a much easier time reaching
this huge percentage of the population.

00:04:49.600 --> 00:04:53.970
At the same time, you can have an easier time
entering government and education markets,

00:04:53.970 --> 00:04:57.290
which often require your software to be accessible.

00:04:57.290 --> 00:05:05.650
So there's a huge potential audience here
especially world-- including worldwide.

00:05:05.650 --> 00:05:11.080
So to look at this audience, there are
4 main areas we want to think about.

00:05:11.080 --> 00:05:16.390
First are visual considerations, and these
are considerations pertaining to vision.

00:05:16.390 --> 00:05:22.290
These are considerations for users that perhaps have
reduced visual acuity, users that are maybe color blind,

00:05:22.290 --> 00:05:29.020
or users that are completely blind, and even users
that just don't have their glasses with them.

00:05:29.020 --> 00:05:34.350
Then, we have auditory considerations and these are
considerations for users with hearing impairments.

00:05:34.350 --> 00:05:39.640
Users who can't hear as well as the average
user or users who can only hear out of one ear.

00:05:39.640 --> 00:05:43.930
This also includes users who are completely deaf.

00:05:43.930 --> 00:05:47.830
And then we have physical considerations,
and these are considerations for users

00:05:47.830 --> 00:05:50.580
that have a hard time physically
interacting with a computer.

00:05:50.580 --> 00:05:54.830
These are users who have a difficult
time using the keyboard or mouse.

00:05:54.830 --> 00:05:58.690
And then cognitive considerations,
and these are consideration

00:05:58.690 --> 00:06:03.230
for how a user thinks when they're using your software.

00:06:03.230 --> 00:06:08.790
This potentially includes users with
learning disabilities and other users

00:06:08.790 --> 00:06:14.310
who just need an easier time using your software
who would benefit from a more simplified interface.

00:06:14.310 --> 00:06:20.880
So we've now talked a little bit
about the users and let's look at some

00:06:20.880 --> 00:06:24.670
of the technologies that Apple has to address these users.

00:06:25.860 --> 00:06:31.840
First is a very common universal design feature that
you'll see a lot this week, and that's Fullscreen Zoom.

00:06:31.840 --> 00:06:38.060
This is used a lot in presentations to highlight a
specific portion of the screen, but it's also indispensable

00:06:38.060 --> 00:06:43.790
for a user with a vision impairment because they're
able to zoom in on various areas and enlarge the font.

00:06:43.790 --> 00:06:49.050
There's a number of these large
font solutions across the OS.

00:06:49.050 --> 00:06:51.570
In Address Book, you can make phone numbers large print.

00:06:51.570 --> 00:06:56.850
This is great if you're sending a fax from across the
room but also wonderful for someone with lower vision.

00:06:56.850 --> 00:07:01.050
In the Dock, the Icon Magnification helps
someone with low vision see the icons,

00:07:01.050 --> 00:07:03.640
but it's also really aesthetically pleasing.

00:07:03.640 --> 00:07:06.590
So we see how these features make the software more usable

00:07:06.590 --> 00:07:09.820
and at the same time have the benefit
of making it more accessible.

00:07:09.820 --> 00:07:17.670
We have closed captioning in iTunes, iPods, iPads,
iPhones and pretty much everywhere we have video.

00:07:17.670 --> 00:07:22.680
This is obviously really important for someone who
is deaf, but it's also crucial if you're trying

00:07:22.680 --> 00:07:27.120
to watch something while on the gym or in the airport
and you don't have the ability to wear headphones.

00:07:27.120 --> 00:07:32.000
Or maybe you want to want a documentary in the
library and you can't listen to the sound there.

00:07:32.000 --> 00:07:39.120
So, again another universal design feature that's helping
everyone but is also increasing the accessibility of video.

00:07:39.120 --> 00:07:46.460
There's also-- we have talking iPods, and this originally
was designed for people who are completely blind

00:07:46.460 --> 00:07:53.310
so they could interact with the iPod and listen to their
music, navigate through the menus, but it's also very usable

00:07:53.310 --> 00:07:57.460
for someone who's driving a car perhaps and
they just want to scroll through their music

00:07:57.460 --> 00:08:00.750
without diverting their visual attention.

00:08:00.750 --> 00:08:07.440
And now this interface turned out to be so usable and so
successful it's the only interface on the new iPod shuffle.

00:08:07.440 --> 00:08:13.340
So it's a great, great universal design feature that turned
out to be the only method of interaction in newer hardware.

00:08:13.340 --> 00:08:19.780
And then we have VoiceOver, and VoiceOver
is Apple's screen reading solution.

00:08:19.780 --> 00:08:25.630
And what this does is it converts all of the wonderful
graphical information on the screen into spoken information

00:08:25.630 --> 00:08:28.230
so that someone who is blind can use a computer.

00:08:28.230 --> 00:08:33.730
And VoiceOver now has been shipping for 5
years and it's installed on millions of Macs.

00:08:33.730 --> 00:08:39.750
And this number is really important because the
VoiceOver now is installed on more computers than all

00:08:39.750 --> 00:08:42.550
of the other screen reading solutions combined.

00:08:42.550 --> 00:08:48.480
And that's really important because it shows what a huge
role Apple is playing in the assistive technology market

00:08:48.480 --> 00:08:53.880
and how important it is for you as
well to make your software accessible.

00:08:53.880 --> 00:09:00.050
VoiceOver now is also shipping on the
iPhone as of the iPhone 3GS and on the iPad,

00:09:00.050 --> 00:09:05.430
along with a slew of other universal
design features that help all users,

00:09:05.430 --> 00:09:08.200
and most of these you don't even think about.

00:09:08.200 --> 00:09:10.500
For example, Pinch to Zoom in Safari.

00:09:10.500 --> 00:09:14.890
We all use that but it's a great feature
for someone who is visually impaired.

00:09:14.890 --> 00:09:20.190
And so if we think about some more of these features
that we can add, we end up making better software.

00:09:21.590 --> 00:09:25.950
So with that, I'd like to look at
how we can make better software.

00:09:25.950 --> 00:09:33.790
What you can do to your applications and how to look at your
applications to find these areas that could be improved.

00:09:33.790 --> 00:09:40.150
So remember, we have these 4 groups:
visual, auditory, physical, and cognitive.

00:09:40.150 --> 00:09:46.150
And when looking at these 4 groups, we
have 4 categories that we want to think of.

00:09:46.150 --> 00:09:47.430
The first is perceivable.

00:09:47.430 --> 00:09:52.050
Can the user perceive the information
you're trying to present?

00:09:52.050 --> 00:09:56.530
Do they have the ability to get the information?

00:09:56.530 --> 00:10:01.070
This is generally going to deal
with the output of your application.

00:10:01.070 --> 00:10:02.710
Is your software operable?

00:10:02.710 --> 00:10:05.160
Does the user have the ability to operate your software?

00:10:05.160 --> 00:10:09.740
Can they provide the input that you're expecting?

00:10:09.740 --> 00:10:11.780
Is it understandable?

00:10:11.780 --> 00:10:14.480
Does the user understand what you're
trying to present to them?

00:10:14.480 --> 00:10:15.890
Do they understand the UI?

00:10:15.890 --> 00:10:19.400
And is it robust?

00:10:19.400 --> 00:10:25.810
Can your software adapt to the very needs of users in the
varying situations where they might use your software?

00:10:25.810 --> 00:10:30.540
And so, this ends up forming a nice grid and you
can actually use this as a report card to go through

00:10:30.540 --> 00:10:34.580
and look at your software, and it helps you
to think about all these different areas

00:10:34.580 --> 00:10:38.490
and we would love you to get A+
marks across this report card.

00:10:38.490 --> 00:10:46.230
And if that's the case, you end up having much better,
much more well-designed software for all of your users.

00:10:46.230 --> 00:10:53.070
And throughout this talk, I'm going to use a small sample
app to highlight some of these universal design features.

00:10:53.070 --> 00:10:55.290
This is a portfolio watcher.

00:10:55.290 --> 00:10:59.920
It just watches some stock, shows me how
they're doing and gives me my day's change,

00:10:59.920 --> 00:11:03.520
and we'll see how we can improve
this through universal design.

00:11:03.520 --> 00:11:11.030
So first let's look at these-- the visual
considerations, and generally these considerations fall

00:11:11.030 --> 00:11:14.240
into the perceivable category because
we're dealing with vision.

00:11:14.240 --> 00:11:17.820
Can a user perceive the output
that you're trying to present?

00:11:17.820 --> 00:11:21.730
And to start, let's look at iTunes.

00:11:21.730 --> 00:11:28.780
Now, iTunes has a wonderful high resolution interface and
in the iTunes Store, they're displaying a lot of content.

00:11:28.780 --> 00:11:34.150
And you can resize the iTunes window
and resize even smaller.

00:11:34.150 --> 00:11:40.660
And as it turns out, this is really important for
accessibility because a very common technique for someone

00:11:40.660 --> 00:11:44.210
with low vision is to increase the screen resolution.

00:11:44.210 --> 00:11:51.200
And so having your window be resizable, usable at all
resolutions, it makes your application much more accessible,

00:11:51.200 --> 00:11:55.140
and at the same time it gives all users
the ability to control the window size

00:11:55.140 --> 00:12:00.140
and it lets the user select what
window size works best for them.

00:12:00.140 --> 00:12:07.300
So generally, we recommend that your
applications be usable down to at least 1024x768.

00:12:07.300 --> 00:12:11.970
And the important distinction here is
that it's usable at that low resolution.

00:12:11.970 --> 00:12:19.640
We really want you to develop beautiful high resolution
interfaces to take advantage of our large displays,

00:12:19.640 --> 00:12:23.710
but you always want to keep in mind that
some users are using these lower resolutions,

00:12:23.710 --> 00:12:27.410
so you want all of your features to
be accessible at these resolutions.

00:12:27.410 --> 00:12:30.620
This is also going to help when presenting your software.

00:12:30.620 --> 00:12:35.470
You never know when you're going to connect to a
projector that's 800x600 and you don't want to be caught

00:12:35.470 --> 00:12:40.440
in a situation where you're giving an important presentation
only to have half of your features inaccessible.

00:12:40.440 --> 00:12:47.580
And that's going to help pretty much anyone who is reducing
their resolution to help release-- relieve eye strain.

00:12:47.580 --> 00:12:51.590
I know a lot of travelers do this
often when working on an airplane.

00:12:51.590 --> 00:12:54.920
It's really, really simple to do right at Interface Builder.

00:12:54.920 --> 00:12:57.060
You just want to set the minimum size of your window

00:12:57.060 --> 00:13:01.840
to the absolute minimum size usable
and then check your application.

00:13:01.840 --> 00:13:07.110
And sometimes this might involve adding some scroll areas
here or there, but in general it's really, really easy.

00:13:07.110 --> 00:13:12.230
So next, I want to look at Mail.

00:13:12.230 --> 00:13:17.440
And here's a screenshot of Mail and I'm sure it's very
difficult to see especially if you're sitting in the back.

00:13:17.440 --> 00:13:23.330
And if I blur it a little bit, it helps us to simulate what
it might look like to someone with a vision impairment,

00:13:23.330 --> 00:13:27.490
and now it becomes absolutely impossible to read.

00:13:27.490 --> 00:13:33.200
Now, Mail has a wonderful feature that's
used by everyone and it makes Mail better.

00:13:33.200 --> 00:13:36.050
You can adjust all of the font sizes in Mail.

00:13:36.050 --> 00:13:43.640
And now this is great for any user or someone who's
presenting Mail and showing off the interface,

00:13:43.640 --> 00:13:47.370
and you can make that even bigger, which
is wonderful for someone with low vision.

00:13:47.370 --> 00:13:53.550
And so this is a really, really important
feature that makes the software much more robust.

00:13:53.550 --> 00:13:56.870
And you'll see this across a number of Apple applications.

00:13:56.870 --> 00:14:01.260
In the System Preferences, you can often
change the font from the Key Content area.

00:14:01.260 --> 00:14:03.620
Sorry, in the Application Preferences.

00:14:03.620 --> 00:14:07.120
And the Key Content area is the important distinction here.

00:14:07.120 --> 00:14:11.930
You want to look at your application and figure
out where users spends most of their time visually,

00:14:11.930 --> 00:14:19.470
and concentrate your attention on trying to make the
fonts in that area larger or at least user sizeable.

00:14:19.470 --> 00:14:23.590
So in an application like Safari, the
Key Content area is easy to determine,

00:14:23.590 --> 00:14:28.110
it's the large web area, but sometimes
it's a bit more difficult.

00:14:28.110 --> 00:14:30.800
So this obviously is going to help users with low vision.

00:14:30.800 --> 00:14:34.630
It's going to help elderly users, users who
don't have their glasses with them, and again,

00:14:34.630 --> 00:14:37.490
it's going to help you if you're ever
presenting your software so that users,

00:14:37.490 --> 00:14:43.670
so that people in the audience are able
to see what you're presenting to them.

00:14:43.670 --> 00:14:45.640
It's really, really simple to do.

00:14:45.640 --> 00:14:49.240
What I recommend is creating one
bottleneck in your application.

00:14:49.240 --> 00:14:54.440
And at this point I do want to mention that all of
the source code I'll be presenting here is available

00:14:54.440 --> 00:14:58.380
on the WWDC web site so you don't need
to worry about copying any of it down.

00:14:58.380 --> 00:15:01.830
So if you create a single point in your application,

00:15:01.830 --> 00:15:07.330
you can always ask that method for
the current user to find font size.

00:15:07.330 --> 00:15:09.940
And here is just a quick example, I'm asking System--

00:15:09.940 --> 00:15:17.920
or asking my Application Preferences for the font size, then
bounds checking it and returning the user desired font size.

00:15:17.920 --> 00:15:19.900
To use it is easy.

00:15:19.900 --> 00:15:25.720
I'm going to ask NSFont for a system font of that
size and I'll get back a valid NSFont that matches all

00:15:25.720 --> 00:15:34.250
of my other system fonts, and then I can just apply
that to any NSTextField really, really easily.

00:15:34.250 --> 00:15:37.940
Now, the other very common area
for adjusting fonts is in tables,

00:15:37.940 --> 00:15:42.510
and tables are slightly more involved
but still not that difficult at all.

00:15:42.510 --> 00:15:46.580
For a table, remember we have columns
and so we need to iterate

00:15:46.580 --> 00:15:49.310
through the columns and set the font for each data cell.

00:15:49.310 --> 00:15:51.740
So we go through that here.

00:15:51.740 --> 00:15:55.820
Going through the columns we grab the data
cell and then set the font for the data cell.

00:15:55.820 --> 00:16:01.310
And then the only slightly tricky part is now that we're
increasing the font, we need to change the row height.

00:16:01.310 --> 00:16:06.660
So in order to do that, we can ask
NSLayoutManager for the line height for our font

00:16:06.660 --> 00:16:08.700
and then set the row height appropriately.

00:16:08.700 --> 00:16:13.760
So as you can see a bit more involved, but still
really, really simple and not much work at all

00:16:13.760 --> 00:16:16.480
to make the fonts in your application resizeable.

00:16:16.480 --> 00:16:23.310
Next, I want to look at another interface
that probably looks very common to you.

00:16:23.310 --> 00:16:29.020
So let's just demonstrate-- this interface is
showing two stocks and showing their day's change.

00:16:29.020 --> 00:16:34.570
However, for a user who is color blind, this
interface doesn't convey any information.

00:16:34.570 --> 00:16:37.610
I don't know if the stock is going up or going down.

00:16:37.610 --> 00:16:44.020
So the important thing here to keep in mind is
never to use color alone to convey information.

00:16:44.020 --> 00:16:49.590
So using color is just fine and it's a really,
really nice way to quickly convey information.

00:16:49.590 --> 00:16:51.910
Just don't use color alone.

00:16:51.910 --> 00:16:54.530
And oftentimes this is simple to solve.

00:16:54.530 --> 00:17:00.440
In this case, if we add a plus and a minus
sign, it now will tell a user who is color blind

00:17:00.440 --> 00:17:02.850
which stock is going up and which is going down.

00:17:02.850 --> 00:17:08.290
So the difference is very, very small here but it
can make a world of difference to a lot of users

00:17:08.290 --> 00:17:12.420
who are using your software, and it's also going
to make your software easier for everyone to use

00:17:12.420 --> 00:17:15.800
because it's now going to be quicker
to glance at because we have color.

00:17:15.800 --> 00:17:21.270
And if you're looking at it more closely,
you have the plus and the minus sign.

00:17:21.270 --> 00:17:27.210
So all of that is really good for our low vision
users, but what about users who can't see anything?

00:17:27.210 --> 00:17:29.930
How are they going to access this visual information?

00:17:29.930 --> 00:17:35.320
And as we saw with the case of color, we don't
want to convey information with color alone.

00:17:35.320 --> 00:17:39.280
As it turns out, we don't want to
convey information through vision alone.

00:17:39.280 --> 00:17:43.680
We want to be able to provide a
spoken interface to every application.

00:17:43.680 --> 00:17:50.620
And on that front, all of the hard work is actually
already done, and that's done through VoiceOver.

00:17:50.620 --> 00:17:57.330
Remember, VoiceOver is the screen reader which is going to
convert all the visual information into spoken information.

00:17:57.330 --> 00:18:02.210
But sometimes it requires a bit of work on
your part to make your application more usable

00:18:02.210 --> 00:18:05.910
with VoiceOver, and that's really easy to do as well.

00:18:05.910 --> 00:18:11.710
In Interface Builder, you can set the
Accessibility Description, Help Tag, Title Element

00:18:11.710 --> 00:18:15.410
and Linked Element without ever leaving IB.

00:18:15.410 --> 00:18:21.170
So it's really, really simple to do this for
any of your controls that you have right in IB.

00:18:21.170 --> 00:18:23.820
As well, there's a programmatic way to do this.

00:18:23.820 --> 00:18:29.060
You can use the convenience method set accessibility
override, and here you can set the override for any

00:18:29.060 --> 00:18:37.340
of your standard controls for its Accessibility
Description, Help Tag, Title, or Linked Element.

00:18:37.340 --> 00:18:44.740
Now, if you have a control that is your own custom view,
you will need to do a bit more work for accessibility,

00:18:44.740 --> 00:18:47.200
and there's some great past talks on that.

00:18:47.200 --> 00:18:52.190
I encourage you to look at the WWDC 2009
talks, and they go into great depth on how

00:18:52.190 --> 00:18:56.380
to make your custom views more
accessible and usable by VoiceOver.

00:18:56.380 --> 00:19:00.190
But for today, let's just look at the standard cases.

00:19:01.270 --> 00:19:08.180
So, with that, I'd like to show you here how we can
apply some of these techniques to our sample application.

00:19:08.180 --> 00:19:09.390
So, here we have Xcode.

00:19:09.390 --> 00:19:17.880
If I run my app here, it's the sample app that I
showed you in the slides and we can look at this window

00:19:17.880 --> 00:19:22.250
and I can't resize it much more than this, which
can be frustrating for any user who just wants

00:19:22.250 --> 00:19:25.910
to make the window small and push
it to the side of the screen.

00:19:25.910 --> 00:19:32.640
So let's go into IB and fix that.

00:19:32.640 --> 00:19:35.030
So here we have our window.

00:19:35.030 --> 00:19:48.430
If we bring up the inspector for the window size-- but
here it's already set to a minimum size of 900 and I know

00:19:48.430 --> 00:19:52.770
that my application can be resized all the way down to 450.

00:19:52.770 --> 00:19:59.750
So really, really simple to change,
we switch and look at that now.

00:19:59.750 --> 00:20:02.220
I can resize the window quite a bit smaller.

00:20:02.220 --> 00:20:08.270
So a small change has a significant impact for the
accessibility and usability of your application.

00:20:08.270 --> 00:20:11.880
Next, let's take a look at fonts.

00:20:11.880 --> 00:20:14.500
So here, if I look at my Preference window,

00:20:14.500 --> 00:20:18.150
I see that someone has already left me
a convenient place for a font slider.

00:20:18.150 --> 00:20:32.480
So if we bring up the library here and add a slider,
you see that the designer has also already decided

00:20:32.480 --> 00:20:38.650
that we want a font size between 8 and 40, and this range
will probably be dependent on your application but 8

00:20:38.650 --> 00:20:41.910
and 40 is probably a pretty decent range to be considering.

00:20:41.910 --> 00:20:50.350
And I want to make sure that my bounds of the slider
are the same so I'm going to set those to 8 and 40.

00:20:50.350 --> 00:20:54.590
And I also want it to update continuously.

00:20:54.590 --> 00:21:02.370
And now for my slider, I'm going to bind it to my delegate
and I'm going to bind it to the font size property.

00:21:05.590 --> 00:21:13.890
So if we save that, we can now go into Xcode and look
at the methods that we need to control the font size.

00:21:13.890 --> 00:21:18.360
So let's bring up the delegate, and I'm
sure if you have ever worked with bindings,

00:21:18.360 --> 00:21:22.710
you know the first thing you'd really want to do is make
sure you add your getter and setter for the property.

00:21:22.710 --> 00:21:24.720
So let's add those now.

00:21:24.720 --> 00:21:29.060
Here we have first a very simple setter.

00:21:29.060 --> 00:21:32.640
We're going to take in a value, and first because
we never want to be dealing with fractions

00:21:32.640 --> 00:21:35.210
of a point, we're going to round the value.

00:21:35.210 --> 00:21:40.570
Then store in Preferences, Synchronize Preferences,
and update the fonts for my application.

00:21:40.570 --> 00:21:42.910
The getter is equally simple.

00:21:42.910 --> 00:21:47.340
I load the value from Preferences then
bounds check it against my lower bounds.

00:21:47.340 --> 00:21:52.950
You may also want to check your upper bounds and then again
return a rounded value because I want to just doubly check

00:21:52.950 --> 00:21:55.950
that I'm never dealing with fractions of a point.

00:21:55.950 --> 00:22:00.740
So now we need to get a system font, an NSFont of that size.

00:22:04.070 --> 00:22:06.410
So that as well is really easy.

00:22:06.410 --> 00:22:11.560
We're going to get the font size that the user
wanted and ask for a system font of that size.

00:22:11.560 --> 00:22:15.710
And now we have our method here which
is going to do the updating for tables.

00:22:15.710 --> 00:22:17.920
Remember, we're going to iterate over the columns,

00:22:17.920 --> 00:22:23.090
apply the font to each data cell and
then lastly update the row height.

00:22:23.090 --> 00:22:26.730
So a bit more involved for tables
but still really, really easily.

00:22:26.730 --> 00:22:32.630
And now the last thing we need is
the actual method to do the work.

00:22:32.630 --> 00:22:39.680
And if we add this method here, we see for our
three text labels, we're going to set the new font

00:22:39.680 --> 00:22:43.450
and then for our two tables, we're
going to set the font of those tables.

00:22:43.450 --> 00:22:46.800
And now to make sure I always have
the current user preference,

00:22:46.800 --> 00:22:50.660
I want to make sure to call updateFonts
in my awakeFromNib method.

00:22:50.660 --> 00:23:02.020
So at the end of awakeFromNib, I'm going to
call update fonts and let's run the application.

00:23:06.090 --> 00:23:12.590
So now if I bring up our Preferences here, I have this font
slider and I can adjust all of the fonts of my application.

00:23:12.590 --> 00:23:14.760
And you'll see here we have a slight problem.

00:23:14.760 --> 00:23:17.120
Our two labels are being cut off.

00:23:17.120 --> 00:23:18.510
And let's go and fix that.

00:23:18.510 --> 00:23:26.320
[ Pause ]

00:23:26.320 --> 00:23:30.700
So in our updateFonts method, we
just need to also update the layout

00:23:30.700 --> 00:23:34.820
of our UI, so I'm going to call self updateLayout.

00:23:37.610 --> 00:23:40.440
And now that's going to call a
method that I've already written.

00:23:40.440 --> 00:23:44.450
The method is a bit long but the
logic is really, really simple.

00:23:44.450 --> 00:23:50.560
It's all just basic math, laying out the controls
appropriately within my view, and when possible,

00:23:50.560 --> 00:23:56.460
letting Interface Builder take advantage of all
the springs and structs that I've already defined.

00:23:56.460 --> 00:23:59.480
So let's take another quick look.

00:24:03.310 --> 00:24:08.960
So now when I adjust my font, all of my
controls layout and resize appropriately,

00:24:08.960 --> 00:24:10.980
and I think that's probably a good font size.

00:24:10.980 --> 00:24:15.290
If I'm demoing my software, now it's
much easier for everyone to read.

00:24:15.290 --> 00:24:21.410
So next I spoke about VoiceOver and how we want to
make sure our application has this audible output.

00:24:21.410 --> 00:24:26.120
Now, there're some really great tutorials on
how to use VoiceOver built right into the Mac.

00:24:26.120 --> 00:24:30.450
When you turn on VoiceOver, you'll have the
opportunity to learn how to use VoiceOver.

00:24:30.450 --> 00:24:36.890
But for today, I just want to let you listen to what a
VoiceOver user might hear when navigating our application.

00:24:36.890 --> 00:24:42.830
>> Unknown: VoiceOver on portfolio watcher
window, portfolio watcher edit text, add a symbol.

00:24:42.830 --> 00:24:46.870
>> Gregory Hughes: So here we hear add a symbol,
and if I go through the UI we'll hear each element.

00:24:46.870 --> 00:24:49.330
>> Unknown: Edit text, blank button.

00:24:49.330 --> 00:24:52.170
>> Gregory Hughes: So here we see one
problem, VoiceOver just says button.

00:24:52.170 --> 00:24:55.730
VoiceOver doesn't have enough information
to tell the user what this button does.

00:24:55.730 --> 00:24:59.030
And so we'll have to go in and
add a description for that button.

00:24:59.030 --> 00:25:00.240
Let's continue along.

00:25:00.240 --> 00:25:04.890
>> Unknown: Table one row selected, symbol AAPL, name Apple.

00:25:04.890 --> 00:25:08.070
>> Gregory Hughes: So it works fine for the
table and you'll find that it works fine

00:25:08.070 --> 00:25:11.510
for any standard Cocoa control,
especially the text controls.

00:25:11.510 --> 00:25:16.510
It's generally your custom controls or any graphical
elements that you'll need to do a little bit of work for.

00:25:16.510 --> 00:25:19.830
>> Unknown: Days change zero dollars
and 82 cents, zero button.

00:25:19.830 --> 00:25:21.680
>> Gregory Hughes: And so again we have this other button.

00:25:21.680 --> 00:25:24.250
And those aren't accessible because they
have images and we're just going to need

00:25:24.250 --> 00:25:27.110
to provide a quick description for those buttons.

00:25:27.110 --> 00:25:27.990
Let's do that now.

00:25:27.990 --> 00:25:29.210
>> Unknown: VoiceOver off.

00:25:29.210 --> 00:25:35.660
>> Gregory Hughes: If we're going to Interface Builder,
I can have the description for one button right here.

00:25:35.660 --> 00:25:43.220
Right here under accessibility description,
I'm going to call this the Fullscreen button.

00:25:43.220 --> 00:25:50.660
And just to show how to do it, I'll
label the other button programmatically.

00:25:50.660 --> 00:25:59.770
So if we switch back to Xcode and I have a small
two line method here to update the other button,

00:25:59.770 --> 00:26:04.890
we see we're going to grab a localized string
because just like our UI it needs to be localized.

00:26:04.890 --> 00:26:11.480
Our strings for VoiceOver need to be localized, and I'll
set that string as the description for the button cell.

00:26:11.480 --> 00:26:17.260
I also need to make sure to call this method when I
awakeFromNib just like I wanted to update my fonts.

00:26:17.260 --> 00:26:35.460
So at the end of my awakeFromNib I'm going to call self
updateAccessibility and let's take a quick look at that.

00:26:35.460 --> 00:26:39.600
>> Unknown: VoiceOver on portfolio
watcher window, portfo-- add stock button.

00:26:39.600 --> 00:26:41.890
>> Gregory Hughes: So here we now
have a description for this button.

00:26:41.890 --> 00:26:43.810
>> Unknown: Take date fullscreen button.

00:26:43.810 --> 00:26:45.490
>> Gregory Hughes: And a description for our other button.

00:26:45.490 --> 00:26:49.590
So you can see adding this basic accessibility
really doesn't take that long at all.

00:26:49.590 --> 00:26:55.030
It just involves going through your application, finding
the areas that need a little bit of work and updating them

00:26:55.030 --> 00:26:58.810
so that VoiceOver has something
to speak for all of your controls.

00:26:58.810 --> 00:26:59.470
>> Unknown: VoiceOver off.

00:26:59.470 --> 00:27:06.300
>> Gregory Hughes: So next I want to talk about audio
considerations, and again these are considerations for users

00:27:06.300 --> 00:27:12.400
with hearing impairments, users who are perhaps
using mono audio or users who are completely deaf.

00:27:12.400 --> 00:27:15.510
And to start out, I want to show a quick video.

00:27:15.510 --> 00:27:21.700
[ Pause ]

00:27:21.700 --> 00:27:27.520
Now, I'm willing to bet you can't get a whole lot of
information from this video because the only means

00:27:27.520 --> 00:27:30.480
of output is audio and I muted the video.

00:27:30.480 --> 00:27:34.560
So you can see how difficult it would be
for someone who's working in a library

00:27:34.560 --> 00:27:37.980
or someone who's deaf to access that video.

00:27:37.980 --> 00:27:40.510
Let's take another look at it.

00:27:40.510 --> 00:27:54.570
[ Pause]

00:27:54.570 --> 00:27:59.410
And now actually, this demonstration worked out pretty
well because there was actually supposed to be audio

00:27:59.410 --> 00:28:07.380
with that second video, and it shows how important it is to
make sure that everything you're presenting is accessible.

00:28:07.380 --> 00:28:11.450
You were still able to get the information
out of that video by reading the subtitles.

00:28:11.450 --> 00:28:20.640
So the important part of audio is to make sure that
you're never presenting information using audio alone,

00:28:20.640 --> 00:28:25.520
that you always have some other method of
conveying that same piece of information.

00:28:25.520 --> 00:28:28.850
You also want to be aware that
some users are using mono audio,

00:28:28.850 --> 00:28:33.540
that they don't have the ability
to hear the two stereo channels.

00:28:33.540 --> 00:28:37.560
And also some users have sensitivity or
can't hear higher or lower frequencies,

00:28:37.560 --> 00:28:42.710
so you may want to consider having
assignable user sounds in your preferences.

00:28:42.710 --> 00:28:45.010
This is going to be up to your application and, you know,

00:28:45.010 --> 00:28:48.940
how much flexibility you have with
what sounds are being played.

00:28:48.940 --> 00:28:56.070
So if we want to make sure that we always have this
visual counterpart to our audio, how do you do it?

00:28:56.070 --> 00:29:00.720
Well, one very convenient and easy way is to use NSBeep.

00:29:00.720 --> 00:29:05.930
Now with NSBeep, there's a systemwide preference
that someone who's hard of hearing can set so that

00:29:05.930 --> 00:29:08.160
when NSBeep is called, the screen will flash.

00:29:08.160 --> 00:29:13.580
It looks a bit like this.

00:29:13.580 --> 00:29:20.440
So, whenever you're going to use something where there's
going to be sound, if you want to play the system sound

00:29:20.440 --> 00:29:26.960
but also provide that visual feedback, always use NSBeep
because it's going to give you that accessibility for free

00:29:26.960 --> 00:29:31.640
for those users who have the need for the screen flash.

00:29:31.640 --> 00:29:36.960
But there are a lot of other ways that you can display
visual information to go along with your sounds.

00:29:36.960 --> 00:29:41.370
One of the really great ways is to use your Dock Icon.

00:29:41.370 --> 00:29:45.710
For example, I've been demonstrating
the stock watching application.

00:29:45.710 --> 00:29:50.240
If my application, if my stock portfolio dropped
a huge percent in a small amount of time,

00:29:50.240 --> 00:29:55.100
I might play a sound to warn the user, or
I could also change my Dock Icon to be red,

00:29:55.100 --> 00:29:59.670
and it provides that visual feedback
that goes along with the sound.

00:29:59.670 --> 00:30:04.000
Equally, I may change the Icon to green
if the portfolio is doing well, again,

00:30:04.000 --> 00:30:07.160
providing visual feedback to go along with the sound.

00:30:07.160 --> 00:30:13.000
And so we see here the importance of providing these
multiple methods of information output to a user and it ends

00:30:13.000 --> 00:30:17.920
up making the application much more
usable for everyone, much nicer to use

00:30:17.920 --> 00:30:22.960
and it helps convey all the information
you want to convey in an easy manner.

00:30:22.960 --> 00:30:26.070
So, changing your Dock Icon is really, really simple.

00:30:26.070 --> 00:30:31.980
In two lines of code given the PNG, you can set your
Dock Icon to pretty much whatever you would like.

00:30:31.980 --> 00:30:36.590
But there's a lot more that can be done with the Dock Icon.

00:30:36.590 --> 00:30:40.970
You can badge your Icon, and this is a
really convenient way and very common way

00:30:40.970 --> 00:30:43.990
of conveying visual-- conveying new information.

00:30:43.990 --> 00:30:50.550
For example when you get a new mail message, you hear the
new mail message sound but it's combined with the updating

00:30:50.550 --> 00:30:52.580
of your unread message count in the Dock.

00:30:52.580 --> 00:30:58.710
So it's that visual and audible component to the
information that mail is trying to present to you.

00:30:58.710 --> 00:31:05.280
And you can also bounce your Dock Icon, and
this is a great way to visually tell a user

00:31:05.280 --> 00:31:08.420
that your application wants attention
while it's in the background.

00:31:08.420 --> 00:31:11.840
Maybe this goes along with an error
sound or some other method

00:31:11.840 --> 00:31:14.880
of informing the user that you want-- you want attention.

00:31:14.880 --> 00:31:24.000
So, I'd like to quickly show you now how
we can apply some of those techniques

00:31:24.000 --> 00:31:27.510
and making our application more accessible
to users who are hard of hearing.

00:31:27.510 --> 00:31:38.470
[ Pause ]

00:31:38.470 --> 00:31:45.290
So here, if I go to my non-audible feedback section,
first, I'm going to add a method that calls NSBeep.

00:31:45.290 --> 00:31:46.770
You can see how simple it is.

00:31:46.770 --> 00:31:50.230
We'll just take a look at what that
looks and sounds like on a real system.

00:31:50.230 --> 00:32:01.670
Next, we have how to change the Dock Icon and this
method looks a bit long but it's really, really simple.

00:32:01.670 --> 00:32:03.940
All I'm doing is a bit of string coercion here.

00:32:03.940 --> 00:32:11.330
My method takes in a number between negative 1 and positive
1 and then displays an icon that varies from red to blue

00:32:11.330 --> 00:32:14.750
to green to represent the status of my portfolio.

00:32:14.750 --> 00:32:16.660
So here, I take in the number.

00:32:16.660 --> 00:32:19.800
I then find the appropriate image name for that number

00:32:19.800 --> 00:32:24.780
and then these two lines here do all the
actual work of setting on your Dock Icon.

00:32:24.780 --> 00:32:28.020
So, really, really simple here to change your Dock Icon.

00:32:28.020 --> 00:32:30.900
Obviously now, I want to call this method from somewhere.

00:32:30.900 --> 00:32:33.970
In my application, I have a timer
going to update my portfolio.

00:32:33.970 --> 00:32:39.810
So, let me call that from my refresh method.

00:32:44.050 --> 00:32:56.560
At the end of this method here, I'll call self
setDockIcon and I'll set to change percent sometimes 5.

00:32:59.930 --> 00:33:09.320
So, in dealing with nonaudible feedback, you also want to
think about your application and what you might be able

00:33:09.320 --> 00:33:16.490
to do to make your audible feedback
have some visual component to it,

00:33:16.490 --> 00:33:18.630
and this could be different for every application.

00:33:18.630 --> 00:33:22.480
This could be some animation that you provide
to go along with your audible feedback.

00:33:22.480 --> 00:33:27.960
And just as a quick example of an animation that I chose,

00:33:27.960 --> 00:33:31.910
here I have a message that's going
to flash my window different colors.

00:33:31.910 --> 00:33:38.560
And so, I'm going to cycle through a few
colors and flash the window that color.

00:33:38.560 --> 00:33:43.730
And so, just as playing sounds can sometimes be annoying,
some of these animations could be annoying to a lot

00:33:43.730 --> 00:33:50.530
of your users and in that case, you want to make sure to
put them behind User Preferences, and that will allow a user

00:33:50.530 --> 00:33:53.130
who needs this option to enable it where appropriate.

00:33:53.130 --> 00:33:58.490
And the last one I want to show was bouncing a Dock Icon.

00:33:58.490 --> 00:34:02.630
And because my application used to be in
the background to bounce my Dock Icon,

00:34:02.630 --> 00:34:09.240
I'm going to call this on a delayed performSelector,
and then there's just one line to bounce my Dock Icon.

00:34:09.240 --> 00:34:14.630
So, let's take a look at this now.

00:34:14.630 --> 00:34:20.080
So we see here, first my Dock Icon is
green because my portfolio is positive.

00:34:20.080 --> 00:34:26.730
If I now bring up the Preferences, we can
see what NSBeep looks and sounds like.

00:34:26.730 --> 00:34:32.790
So, a great way to provide that visual feedback
automatically and it lets the user select

00:34:32.790 --> 00:34:36.680
which sound they would like to hear,
which sound works best for them.

00:34:36.680 --> 00:34:47.520
It can also bounce the Dock Icon, so a
great way of telling the user visually

00:34:47.520 --> 00:34:50.150
that your application would like attention.

00:34:50.150 --> 00:34:55.830
And lastly, just a quick very, very rough
animation, I can flash my window different colors.

00:34:55.830 --> 00:34:59.920
And this might just tell the user different
statuses or different things have changed.

00:34:59.920 --> 00:35:03.250
So there we have it, some very, very
simple changes that you can make

00:35:03.250 --> 00:35:06.480
that will greatly help users with hearing impairments.

00:35:06.480 --> 00:35:13.420
So now, let's talk about users with physical
impairments, the physical considerations

00:35:13.420 --> 00:35:15.810
that we need to think about with our software.

00:35:15.810 --> 00:35:18.340
These generally fall into the operable category.

00:35:18.340 --> 00:35:19.950
Can a user operate your software?

00:35:19.950 --> 00:35:23.480
Can they provide you with the input that you expect?

00:35:23.480 --> 00:35:28.620
And when thinking about this category, we
want to look at the keyboard and the mouse.

00:35:28.620 --> 00:35:32.800
These are generally the two primary
methods of providing input on Mac OS X.

00:35:32.800 --> 00:35:38.630
And we want to think about users who perhaps
don't have the keyboard or can't use the keyboard,

00:35:38.630 --> 00:35:43.580
or maybe users that don't have the
fine motor ability to use the mouse.

00:35:43.580 --> 00:35:46.190
Meekly, we want to consider users that don't have either one

00:35:46.190 --> 00:35:49.990
and are potentially using speech
input to control your applications.

00:35:49.990 --> 00:35:56.600
As it turns out, there's a lot of permutations here
of the various input methods that could be used,

00:35:56.600 --> 00:36:04.270
but they're all very simple to address. And you can address
them by providing full keyboard access to your application.

00:36:04.270 --> 00:36:05.700
This is really simple to test.

00:36:05.700 --> 00:36:09.040
Just try to use your application without using the mouse.

00:36:09.040 --> 00:36:13.110
Try to make sure that you can use all the features
and all the functionality with just the keyboard.

00:36:13.110 --> 00:36:17.280
That you can navigate to every single
control and use every single control.

00:36:17.280 --> 00:36:22.340
Some of the tactics here to do this are to
provide keyboard shortcuts for the menu items

00:36:22.340 --> 00:36:28.000
so that you can quickly activate
various options in your app.

00:36:28.000 --> 00:36:34.550
So here, this is a great case where this universal design
feature is going to strongly or greatly help your super--

00:36:34.550 --> 00:36:40.430
or your power users who want quick keyboard access to
the very commonly used features and at the same time,

00:36:40.430 --> 00:36:43.630
you're going to be helping users with physical disabilities.

00:36:43.630 --> 00:36:50.060
Now, two of the common areas that I've often
seen where full keyboard access is difficult are

00:36:50.060 --> 00:36:53.680
in reordering lists and doing dragging and dropping.

00:36:53.680 --> 00:36:59.590
Now, reordering lists is common-- are commonly done
by dragging one row and dropping it in a new position,

00:36:59.590 --> 00:37:01.950
so somewhat difficult to do with the keyboard.

00:37:01.950 --> 00:37:04.670
It turns out the solution is quite simple.

00:37:04.670 --> 00:37:10.490
If you just add a moveUp and a moveDown command to your
Edit menu, you now allow a user to use their keyboard

00:37:10.490 --> 00:37:13.310
to reorder any list that you have in your application.

00:37:13.310 --> 00:37:19.200
And equally here, you'll see I've also bound this to
a keystroke, so the menu item has a keyboard shortcut

00:37:19.200 --> 00:37:21.980
which is also going to help my power users.

00:37:21.980 --> 00:37:27.460
Now, for dragging and dropping, for
example, an application that requires that--

00:37:27.460 --> 00:37:33.470
where a user is going to move a photo from one album-- photo
album to another, instead of dragging it from that album

00:37:33.470 --> 00:37:38.860
and dropping it in a different album, I could simply
cut it from one album and paste it in another.

00:37:38.860 --> 00:37:41.840
So, by fully implementing cut, copy and paste,

00:37:41.840 --> 00:37:47.360
we help get around the keyboard navigation
problems of drag and drop interfaces.

00:37:47.360 --> 00:37:54.320
So, this is really, really easy to do and
it's implementing NSPasteboard protocol

00:37:54.320 --> 00:37:58.680
and there's some great documentation online
on how to do this for your application.

00:37:58.680 --> 00:38:04.410
So, I also said you want to be able to make sure that
you can get to all of the controls in your application

00:38:04.410 --> 00:38:07.030
that you can Tab through your application.

00:38:07.030 --> 00:38:11.880
And when doing this, you want to make sure to enable
full keyboard access, and what this is is a feature

00:38:11.880 --> 00:38:17.460
in the operating system to allow a user to navigate
the entire operating system using the keyboard alone.

00:38:17.460 --> 00:38:23.030
And in keyboard-- in system preferences under
keyboard preferences, you'll see here at the bottom,

00:38:23.030 --> 00:38:27.040
there's a small checkbox to enable
full keyboard access to all controls.

00:38:27.040 --> 00:38:33.590
You want to try this on when testing your application
to make sure that you can Tab to everything.

00:38:33.590 --> 00:38:37.840
So, let's take a look at that now.

00:38:37.840 --> 00:38:40.380
So, first let's take a look at reordering lists.

00:38:40.380 --> 00:38:41.890
I'm going to go into Interface Builder.

00:38:41.890 --> 00:38:46.120
I've already implemented the drag and
drop portion of reordering my list

00:38:46.120 --> 00:38:49.530
and now, I need to add the keyboard access to it.

00:38:49.530 --> 00:38:58.510
So, I'm going to bring up my Edit menu here
and add two items, moveUp and moveDown--

00:38:58.510 --> 00:39:09.530
[ Pause ]

00:39:09.530 --> 00:39:12.540
-- and also provide them with keyboard shortcuts.

00:39:12.540 --> 00:39:19.430
Now, I've already written the prototypes for
these methods so I can go ahead and bind them.

00:39:26.490 --> 00:39:30.260
And now, let's look at the work
that needs to be done in Xcode.

00:39:30.260 --> 00:39:35.160
So, I've already written all of the methods, as I said,
for the actual dragging and dropping implementation

00:39:35.160 --> 00:39:38.750
and the key here is that it's already architected well.

00:39:38.750 --> 00:39:41.230
Here's my method that's dealing with the actual drop.

00:39:41.230 --> 00:39:44.210
I mutate the numbers a bit to get
them in the format I expect

00:39:44.210 --> 00:39:46.910
and then call my one method that does all of the work.

00:39:46.910 --> 00:39:50.240
The method is called Moves Dock at Index to Index.

00:39:50.240 --> 00:39:54.380
So, this is the method that's actually
going to do the work of reordering the rows.

00:39:54.380 --> 00:39:59.230
And given this architecture, adding a moveUp
and moveDown command is really, really simple.

00:39:59.230 --> 00:40:01.530
So we see here, moveUp is two lines.

00:40:01.530 --> 00:40:09.230
We get the currently selected index in the table and then
we move that index to the currently selected index minus 1.

00:40:09.230 --> 00:40:12.450
MoveDown is just as simple, we're just going to add 1.

00:40:12.450 --> 00:40:15.620
So here, we see with 4 lines of code, we're going

00:40:15.620 --> 00:40:19.860
to have greatly increased the keyboard
navigation of our application.

00:40:19.860 --> 00:40:26.070
So, if I now Tab to my table, I can Arrow to my
table and then with Command and the Arrow keys,

00:40:26.070 --> 00:40:28.600
I can move one of these stocks up or down in my list.

00:40:28.600 --> 00:40:34.390
So you see, this is going to be great for yours-- your power
users who want to get it on to your application quickly,

00:40:34.390 --> 00:40:39.360
but it's also going to be the way that users with physical
disabilities are going to be interacting with your software,

00:40:39.360 --> 00:40:42.800
and so you want to make sure it's
all usable with just the keyboard.

00:40:42.800 --> 00:40:46.610
And so now, we want to look at Tab navigation.

00:40:46.610 --> 00:40:50.610
We want to make sure we can get to all of the
controls, and so the first thing here as I said,

00:40:50.610 --> 00:40:54.000
we want to go to System Preferences and
make sure turn on full keyboard access.

00:40:54.000 --> 00:40:58.390
So, we're going to turn on all controls here.

00:40:58.390 --> 00:41:03.610
And now, I'm going to Tab through my application
and just make sure I can get to everything.

00:41:03.610 --> 00:41:07.820
So, at the Add a Symbol field, I move
to Add a Stock button to the table

00:41:07.820 --> 00:41:10.580
and then to this Fullscreen button at the bottom.

00:41:10.580 --> 00:41:12.260
So, I can get to everything just fine here.

00:41:12.260 --> 00:41:19.060
If I open up the Preferences, I'm starting
here at the Tab control at the top.

00:41:19.060 --> 00:41:24.170
Pressing Tab moves me to the font slider,
and Tab again moves me to the negative color

00:41:24.170 --> 00:41:26.260
and then backwards to the positive color.

00:41:26.260 --> 00:41:31.510
And so, something is wrong there with the automatic
Tab ordering that was created by the operating system.

00:41:31.510 --> 00:41:35.480
So, you always want to check your application,
make sure the Tab ordering is correct.

00:41:35.480 --> 00:41:40.940
As it turns out actually, in this case, I had to play some
really evil tricks to get the Tab ordering to be incorrect.

00:41:40.940 --> 00:41:42.850
So almost always, it will be fine.

00:41:42.850 --> 00:41:47.570
But let me show you how you would
fix it if it were incorrect.

00:41:47.570 --> 00:41:56.980
If I go into Interface Builder here and I look at my
Preferences window, what I want to do is first start

00:41:56.980 --> 00:42:04.170
at the window, and I'm going to set the initial
key to this initialFirstResponder to my Tab control

00:42:04.170 --> 00:42:13.980
and then for the Tab control, I want to set
the initial first responder to the slider.

00:42:13.980 --> 00:42:24.690
From there, the slider's next key
view will be the positive color.

00:42:24.690 --> 00:42:29.420
And from the positive color, the next
key view will be the negative color.

00:42:29.420 --> 00:42:34.170
From the negative color, you want to make sure to make a
full loop, so we're going to go back up to the Tab control

00:42:34.170 --> 00:42:36.800
and set the next key view to the Tab control.

00:42:36.800 --> 00:42:40.170
So, let's take a quick look now.

00:42:45.550 --> 00:42:50.300
So if I press Tab, I move from the
button at the top to the slider--

00:42:50.300 --> 00:42:56.210
oh, and I didn't do something right,
so let's take another look here.

00:42:56.210 --> 00:43:00.070
So from the slider, we want to go to the positive color.

00:43:00.070 --> 00:43:12.480
Positive color to the negative color and
then negative color back up to the top.

00:43:12.480 --> 00:43:15.820
So, if I press Tab from the button
at the top, I go to the slider,

00:43:15.820 --> 00:43:19.020
then the positive color then to negative color and back up.

00:43:19.020 --> 00:43:25.530
So really, really simple to test, really simple to fix
and it greatly improves the usability of your application,

00:43:25.530 --> 00:43:31.370
again for those power users who want to get around quickly
and for users who don't have the ability to use the mouse.

00:43:31.370 --> 00:43:34.870
As well as I said, this is going
to solve all of your input issues.

00:43:34.870 --> 00:43:39.740
For users who are using speech input, they're going to now
be able to use Apple scripts to control your application

00:43:39.740 --> 00:43:42.760
because it's fully navigable with the keyboard.

00:43:42.760 --> 00:43:51.070
So, we solved a lot of problems
with a very small amount of work.

00:43:51.070 --> 00:43:56.530
So, next are cognitive considerations,
and these are considerations

00:43:56.530 --> 00:43:59.370
for how user thinks when they're using your software.

00:43:59.370 --> 00:44:03.030
These are considerations for users
that perhaps have disabilities

00:44:03.030 --> 00:44:07.300
like learning disabilities or maybe
even just the type of user.

00:44:07.300 --> 00:44:10.220
For example, a student is probably going
to use your software in a different way

00:44:10.220 --> 00:44:12.200
than a teacher is going to use your software.

00:44:12.200 --> 00:44:16.420
And so, to look at cognitive considerations,
I want to look at iPhoto.

00:44:16.420 --> 00:44:22.640
Now, iPhoto has a great interface and it's a
very, very powerful photo management application.

00:44:22.640 --> 00:44:24.940
And it also allows me to edit my photos.

00:44:24.940 --> 00:44:30.300
Now this interface can actually be a bit confusing
and overwhelming to some users because all you want

00:44:30.300 --> 00:44:32.260
to do is just browse and look at your photos.

00:44:32.260 --> 00:44:36.430
And iPhoto has done a great job solving this.

00:44:36.430 --> 00:44:43.220
To do it, iPhoto has implemented Fullscreen mode and
in Fullscreen view, you can go through your album,

00:44:43.220 --> 00:44:47.270
look at all of your photos and
eliminate all of the distractions.

00:44:47.270 --> 00:44:50.610
Now, while in this mode, you can
also get to a lot of the UI.

00:44:50.610 --> 00:44:56.020
You can get to the photo chooser by going up
to the top or the edit controls at the bottom.

00:44:56.020 --> 00:45:03.330
So, this is really important because iPhoto is presenting
only the controls that the user needs when they need them.

00:45:03.330 --> 00:45:07.300
So, it's eliminating distractions
and also hiding unnecessary UI

00:45:07.300 --> 00:45:10.240
when it doesn't-- the user doesn't need the UI.

00:45:10.240 --> 00:45:16.220
As it turns out here, entering this
Fullscreen mode is super, super easy.

00:45:16.220 --> 00:45:18.580
You can do it with one line of code.

00:45:18.580 --> 00:45:23.960
Given an NSView, you just say enterFullScreen
mode, provide it a screen

00:45:23.960 --> 00:45:27.230
and there are few options that you can pass in as well.

00:45:27.230 --> 00:45:33.870
So, really, really easy to implement this, a very,
very powerful way of making your application easier,

00:45:33.870 --> 00:45:39.980
simpler to use for everyone, but also more
accessible to those users with cognitive impairments.

00:45:41.600 --> 00:45:48.510
Now, I said iPhoto is hiding some UI and
hiding UI is really, really important here.

00:45:48.510 --> 00:45:54.140
We want to make sure not to overwhelm a user with UI, so
you want to think about what options are more advanced,

00:45:54.140 --> 00:45:59.840
what options are less used and see if you
can come up with ways to hide those options.

00:45:59.840 --> 00:46:02.480
A great tactic is to use a contextual menu.

00:46:02.480 --> 00:46:08.610
So perhaps you have a lot of buttons and 50 percent
of those are used by 2 percent of your users.

00:46:08.610 --> 00:46:12.560
Consider putting those options in a contextual menu instead.

00:46:12.560 --> 00:46:21.690
Another great way of hiding more complicated
or less used UI is to use menu alternates.

00:46:21.690 --> 00:46:23.860
What this is, it's something we've probably all seen.

00:46:23.860 --> 00:46:27.310
When you open up any menu in OS
X, you can press the Option key

00:46:27.310 --> 00:46:30.970
and it will display different menu
items if they're provided.

00:46:30.970 --> 00:46:36.200
For example here in the Apple menu, if I press
the Option key, a few of the items change.

00:46:36.200 --> 00:46:41.110
Now, that was actually pretty difficult to notice
in the slide, but if we look at the two menus,

00:46:41.110 --> 00:46:44.360
we see that about this Mac change the system profiler.

00:46:44.360 --> 00:46:50.420
The system profiler is something that most users
never ever need but we still provide that option.

00:46:50.420 --> 00:46:56.880
So, the important thing here is that you don't really want
to take away features from the user but at the same time,

00:46:56.880 --> 00:47:02.540
you want to balance that with making your UI simple,
making all of the features used by 90 percent

00:47:02.540 --> 00:47:06.700
of the users available all the time
and maybe hiding those other features

00:47:06.700 --> 00:47:08.650
that are used by only 10 percent of your users.

00:47:08.650 --> 00:47:14.300
So the-- to add a menu alternate,
you simply add a new menu item

00:47:14.300 --> 00:47:17.700
and in Interface Builder say this is an alternate menu item.

00:47:17.700 --> 00:47:23.620
What that means is that that menu item will replace
the previous menu item when a user presses the option,

00:47:23.620 --> 00:47:29.590
so really, really simple to do and very powerful
nice way of hiding more advanced or less used UI.

00:47:29.590 --> 00:47:36.020
So, let's take a look now at how to
do Fullscreen mode in our application.

00:47:39.090 --> 00:47:44.510
So, if we switch over here to the application,
I have a place for the Fullscreen method.

00:47:44.510 --> 00:47:55.180
[ Pause ]

00:47:55.180 --> 00:47:57.160
So we see again very, very simple method.

00:47:57.160 --> 00:47:58.890
I already have the button in the UI.

00:47:58.890 --> 00:48:03.560
The buttons are already wired up,
so let's take a look at it.

00:48:07.210 --> 00:48:14.840
So we see here now, we've able to enter Fullscreen mode
really, really easily, eliminated all distractions for user.

00:48:14.840 --> 00:48:19.940
But the same time here now, we see how a
lot of our work today has come together.

00:48:19.940 --> 00:48:21.890
We're now able to make the font sizes larger.

00:48:21.890 --> 00:48:27.460
We're using color and the plus and the minus sign
to convey information quickly and to all users.

00:48:27.460 --> 00:48:33.820
And we've generally made our software more
usable, more robust, and easier for everyone.

00:48:33.820 --> 00:48:37.530
We've just made the software better
because there are more options to the user.

00:48:37.530 --> 00:48:42.240
Someone now could set this on a second monitor
and just watch their portfolio all day long rather

00:48:42.240 --> 00:48:44.630
than having to search through windows to look at it.

00:48:44.630 --> 00:48:49.420
So, you're going to make your applications much better
and much more liked by our users because you're going

00:48:49.420 --> 00:48:54.320
to eliminate some of those frustrations that
users often run into when using your application.

00:48:54.320 --> 00:49:00.300
So, in summary today, we've talked about 4 groups.

00:49:00.300 --> 00:49:04.200
We've talked about visual considerations,
auditory considerations,

00:49:04.200 --> 00:49:08.090
physical considerations, and cognitive considerations.

00:49:08.090 --> 00:49:11.890
For visual considerations, remember,
we want to keep in mind the resolution.

00:49:11.890 --> 00:49:16.170
We want our application to be usable at lower resolutions.

00:49:16.170 --> 00:49:21.700
Whee possible-- we want the font size of the key
content area to be adjustable by the end user.

00:49:21.700 --> 00:49:26.280
We're going to make sure we keep in mind
colors that are used in our application,

00:49:26.280 --> 00:49:29.110
never use color alone to convey information.

00:49:29.110 --> 00:49:33.570
And lastly, we want to make sure that the
application is accessible to VoiceOver

00:49:33.570 --> 00:49:38.720
by implementing the NSAccessibility protocol
on any custom classes and providing information

00:49:38.720 --> 00:49:43.470
in Interface Builder for any standard Cocoa controls.

00:49:43.470 --> 00:49:50.890
For auditory considerations, you want to make sure to
always provide information through multiple channels.

00:49:50.890 --> 00:49:53.600
Never provide information through audio alone.

00:49:53.600 --> 00:49:58.880
Always be aware that some users are using mono
audio, and you also want to make sure that any videos

00:49:58.880 --> 00:50:01.750
that you're presenting have closed captions.

00:50:02.910 --> 00:50:08.440
For physical considerations, you want to consider
users that aren't using the keyboard and mouse.

00:50:08.440 --> 00:50:13.430
And to do this, you want to make sure that your
application is fully navigable using the keyboard alone.

00:50:13.430 --> 00:50:17.810
Some tricks here are to use many
alternates and always make--

00:50:17.810 --> 00:50:24.620
sorry, many shortcuts, and always make sure that
any mouse actions have a keyboard alternate.

00:50:24.620 --> 00:50:28.650
Lastly, we have cognitive considerations.

00:50:28.650 --> 00:50:32.650
These are considerations again how a user
is going to think when using your software.

00:50:32.650 --> 00:50:35.420
You want to make your UI as simple as possible.

00:50:35.420 --> 00:50:37.610
And to do this, you can use things like Fullscreen mode.

00:50:37.610 --> 00:50:45.110
You want to also consider hiding more advanced to less used
UI by either contextual menus or making menu alternates.

00:50:45.110 --> 00:50:54.860
So, if you have more questions, there's a ton of information
available regarding both accessibility and universal design.

00:50:54.860 --> 00:50:58.210
I strongly recommend that you join
the Accessibility Mailing List.

00:50:58.210 --> 00:51:02.920
It's a very well trafficked and friendly
mailing list for any of your questions.

00:51:02.920 --> 00:51:07.880
There's also great documentation in which
you can get to via the WWDC website.

00:51:07.880 --> 00:51:13.100
And Apple also has a really wonderful accessibility
web page which talks about accessibility

00:51:13.100 --> 00:51:16.120
and accessible interfaces in all of our products.

00:51:16.120 --> 00:51:21.210
It also provides you with links to
any documentation that you may need.

00:51:21.210 --> 00:51:24.190
We also had some related sessions this week.

00:51:24.190 --> 00:51:30.480
There's a session on iPhone accessibility
tomorrow afternoon and we have two labs.

00:51:30.480 --> 00:51:34.370
Now, both of these labs are the ones
that says OS X and ones for the iPhone.

00:51:34.370 --> 00:51:38.740
The entire team of engineers that work on
accessibility will be at both of these labs.

00:51:38.740 --> 00:51:44.450
So, if you have any questions, whether they're iPhone or OS
X, please come to the labs and talk to any one of us.

00:51:44.450 --> 00:51:46.450
We'll all be there.

00:51:46.450 --> 00:51:49.660
And I'd like to thank you very
much for your time this morning.

00:51:49.660 --> 00:51:51.300
It's been a pleasure talking to you.

