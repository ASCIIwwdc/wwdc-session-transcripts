WEBVTT

00:00:06.170 --> 00:00:10.150
>> I'm Jacob and I'm going to be joined by my
colleagues Chris and Darryl to talk to you today

00:00:10.150 --> 00:00:13.260
about implementing push and local notifications.

00:00:13.260 --> 00:00:16.550
So there's a bit of dilemma with iOS apps here.

00:00:16.550 --> 00:00:19.610
Your app can't always be running when you need it to run

00:00:19.610 --> 00:00:23.660
but you might have an important message
that you need to get to the user.

00:00:23.660 --> 00:00:29.210
For example, your game might want to tell the user that
there're crops ready on their farm that they need to pick;

00:00:29.210 --> 00:00:37.090
or, I know you guys all love that game, your baseball
game is about to start and you want to watch it;

00:00:37.090 --> 00:00:41.290
or they might have gotten a message
from their friend on your service.

00:00:41.290 --> 00:00:45.330
How do you get these messages to
the user if your app isn't running?

00:00:45.330 --> 00:00:48.080
The solution on iOS is to use notifications.

00:00:48.080 --> 00:00:51.970
There's three different styles of notifications on iOS.

00:00:51.970 --> 00:00:54.480
The first is that you can set a badge.

00:00:54.480 --> 00:00:57.440
The badge lets the user know that there's
a little bit of data waiting for them

00:00:57.440 --> 00:01:01.440
in your app. The second style is an alert.

00:01:01.440 --> 00:01:09.160
You can pop up an alert or send a short message
to the user. The third style is a sound.

00:01:09.160 --> 00:01:12.550
You can play a sound that will get the user's attention.

00:01:12.550 --> 00:01:18.250
Note that one notification can contain any
combination of these three styles of notifications,

00:01:18.250 --> 00:01:22.150
so you can play a sound and set a badge at the same time.

00:01:22.150 --> 00:01:26.090
We have two ways of creating notifications on iOS.

00:01:26.090 --> 00:01:30.580
In iPhone OS 3 we introduced push notifications.

00:01:30.580 --> 00:01:35.310
Push notifications are a way for your server
to get a notification onto the device.

00:01:35.310 --> 00:01:41.670
It does this by talking to the APNs Apple Push
Notification Servers who forward the message onto the phone

00:01:41.670 --> 00:01:44.040
through a connection that they keep open all the time.

00:01:44.040 --> 00:01:48.370
In iOS 4 we've introduced local notifications.

00:01:48.370 --> 00:01:53.480
Local notifications are a way for you to create these
same notifications but without the network connection.

00:01:53.480 --> 00:01:55.450
They're similar in a couple of ways.

00:01:55.450 --> 00:01:59.340
The first is that they look the same to
the user no matter how you create them.

00:01:59.340 --> 00:02:03.350
If you create the notification through push
or locally, they're going to appear the same.

00:02:03.350 --> 00:02:09.000
You have a badge, you can display
an alert, or you can play a sound.

00:02:09.000 --> 00:02:13.830
Also in both cases, the iPhone OS
is acting on behalf of your app.

00:02:13.830 --> 00:02:16.750
Your app doesn't need to be running
for a notification to happen.

00:02:16.750 --> 00:02:20.710
There are some differences between
push and local notifications however.

00:02:20.710 --> 00:02:28.930
The biggest is that push notifications come from a
server while local notifications are created by your app.

00:02:28.930 --> 00:02:33.500
This means push notifications are much better
suited for any sort of network-based service.

00:02:33.500 --> 00:02:39.550
You can keep the user connected to a service through
push notifications even if your app isn't running.

00:02:39.550 --> 00:02:44.760
With local notifications they're scheduled so they're
much better for any sort of time-based notification.

00:02:44.760 --> 00:02:54.780
Also local notifications can be set to repeat so they can
occur every day or every week indefinitely into the future.

00:02:54.780 --> 00:02:57.100
With push notifications it's a single shot deal.

00:02:57.100 --> 00:02:59.980
The server sends one notification
and it appears on the phone.

00:02:59.980 --> 00:03:02.880
So why would you want to use notifications?

00:03:02.880 --> 00:03:05.100
Well they're a great way to get the user's attention.

00:03:05.100 --> 00:03:08.510
It's standard behavior on the OS
and users are used to these.

00:03:08.510 --> 00:03:11.220
It's also a great way to improve the battery life.

00:03:11.220 --> 00:03:18.390
Since your app doesn't need to be running you aren't
using up any CPU and the battery life improves.

00:03:18.390 --> 00:03:23.520
Finally, push notifications are a great way for
your app to stay connected with a network service.

00:03:23.520 --> 00:03:28.260
Your app doesn't need to stay running or keep
a network connection open to your servers.

00:03:28.260 --> 00:03:33.830
The phone iOS will do it on behalf of your app.

00:03:33.830 --> 00:03:39.020
So now Darryl's going to come up and talk to you guys
about how to implement push notifications on the phone.

00:03:39.020 --> 00:03:39.850
>> Hi my name is Darryl.

00:03:39.850 --> 00:03:44.980
I'm one of the engineers that works on the
service which allows you to send notifications

00:03:44.980 --> 00:03:48.500
from your server directly to an
application running on the device.

00:03:48.500 --> 00:03:51.710
So just a few things I'm going to talk about today.

00:03:51.710 --> 00:03:56.650
One of them is just to give you a brief overview
of how the notification architecture works.

00:03:56.650 --> 00:04:02.120
After that I'm going to tell you a little bit about the
things we've been working on and how you can make use

00:04:02.120 --> 00:04:05.990
of them to provide an even better experience for your users.

00:04:05.990 --> 00:04:09.640
So first of all: How the Push Notification System Works.

00:04:09.640 --> 00:04:13.370
Now if you're already using the Push
Notification Service, this is just going to serve

00:04:13.370 --> 00:04:15.690
as a brief reacquaintance to how it works.

00:04:15.690 --> 00:04:20.570
If you haven't used it, then this will
be a bit of an introduction for you.

00:04:20.570 --> 00:04:24.530
So to make use of the service you require two things.

00:04:24.530 --> 00:04:31.820
You require a device with your application running on it
and you require a server which will send notifications.

00:04:32.840 --> 00:04:38.500
Once you have those two things you're ready
to make use of the Push Notification Service.

00:04:38.500 --> 00:04:43.010
So just any particular device you
need to know that device is Token.

00:04:43.010 --> 00:04:47.510
This Token is available to you by the APIs on the device.

00:04:47.510 --> 00:04:55.850
Once you have that token you would tell your server about
it and when your server has a Payload ready to send,

00:04:55.850 --> 00:05:03.100
you combine the Token and Payload together into a
notification and send it to the Push Notification Service.

00:05:03.100 --> 00:05:07.380
From there, the service will route
the notification as appropriate.

00:05:07.380 --> 00:05:13.890
Let's take a closer look at that communication
between your server and the Push Notification Service.

00:05:13.890 --> 00:05:21.070
The protocol used here is a Binary Protocol
and it consists of a couple of things.

00:05:21.070 --> 00:05:27.790
There's the Device Token, there's the
Payload which is specified in JSON

00:05:27.790 --> 00:05:33.390
and there's the Command Identifier
so in this case it's simply 0.

00:05:33.390 --> 00:05:38.910
The prefix to the Token and the
Payload are their respective lengths.

00:05:38.910 --> 00:05:41.950
This makes up the entirety of a notification.

00:05:41.950 --> 00:05:45.020
All right some considerations for sending notifications.

00:05:45.020 --> 00:05:50.060
First of all the system was designed
entirely with performance in mind.

00:05:50.060 --> 00:05:54.940
As such the communication with
the service is unidirectional.

00:05:54.940 --> 00:05:59.140
It's also a streaming protocol which means
that you'll send multiple communications back

00:05:59.140 --> 00:06:01.670
to back over the same connection.

00:06:01.670 --> 00:06:10.130
It also features a store and forward mechanism
such that notifications which are sent

00:06:10.130 --> 00:06:16.600
to devices not currently online will be
redelivered when that device reconnects.

00:06:16.600 --> 00:06:20.450
The system also presents some debugging challenges.

00:06:20.450 --> 00:06:25.880
And this is mostly due to the fact that the
system terminates connections on invalid data.

00:06:25.880 --> 00:06:39.670
Let's take a bit of a look at how that becomes a challenge--
when your server establishes a connection with APNs

00:06:39.670 --> 00:06:43.010
and notifications flow over that connection.

00:06:43.010 --> 00:06:47.780
Let's take a closer look at what is
actually happening on your server.

00:06:47.780 --> 00:06:54.550
We can actually think about that as your service which
communicates to the operating system running your service.

00:06:54.550 --> 00:07:01.740
When you have a notification ready to send, you're
actually sending that to the operating system

00:07:01.740 --> 00:07:05.250
and it's up to the operating system to
manage the particulars of that connection.

00:07:05.250 --> 00:07:10.900
If we have multiple notifications in flight
and there is a problem with a notification,

00:07:10.900 --> 00:07:14.500
then the push service will simply terminate the connection.

00:07:14.500 --> 00:07:19.440
This can lead us to an issue where we have an orphan
notification and it's a challenge for your service

00:07:19.440 --> 00:07:21.510
to do something intelligent in that case.

00:07:21.510 --> 00:07:27.170
As such we have an enhanced Binary Interface
which will provide you with increased feedback.

00:07:27.170 --> 00:07:30.060
Along the way we've preserved what's best.

00:07:30.060 --> 00:07:32.700
This is still a high performance protocol.

00:07:32.700 --> 00:07:39.760
It maintains the same streaming capability but
now we will provide you with concise feedback.

00:07:39.760 --> 00:07:43.960
This is not a pure request response
system as that would impair performance.

00:07:43.960 --> 00:07:49.210
Rather we've designed this system to provide you
a response only in the case of an air condition.

00:07:49.210 --> 00:07:52.300
So let's take a look at how that would work.

00:07:52.300 --> 00:07:57.180
In the same case as we had before, your
service has two notifications to send.

00:07:57.180 --> 00:08:04.870
We still send those to the operating system but if
you'll notice, we are keeping track of a sliding window

00:08:04.870 --> 00:08:09.690
of notifications we have sent as well as
we have an ID associated with each one.

00:08:09.690 --> 00:08:12.910
In this case to keep things simple we have ID 1 and 2.

00:08:12.910 --> 00:08:17.640
Now when those notifications are sent if there's
an issue with any particular notification,

00:08:17.640 --> 00:08:24.180
before disconnecting the connection, the Push Notification
Service will send you a response which contains

00:08:24.180 --> 00:08:30.140
that notification along with a little bit of information
to tell you what was wrong with the notification.

00:08:30.140 --> 00:08:37.290
From there, you can know that there was
an issue with that particular notification

00:08:37.290 --> 00:08:40.660
but the notifications sent subsequent
to it still need to be redelivered.

00:08:40.660 --> 00:08:44.110
We're going to talk a little bit
about the Store and Forward mechanism.

00:08:44.110 --> 00:08:50.740
As mentioned the Push Notification System accepts
notifications for devices which are not currently online.

00:08:50.740 --> 00:08:57.820
And will store them for a limited amount of time
and redeliver them when a device reconnects.

00:08:57.820 --> 00:09:06.480
However, this is potentially problematic as the information
contained within any notification may be sensitive to time;

00:09:06.480 --> 00:09:13.320
and yet we will deliver it potentially after
too much time has passed even perhaps after days

00:09:13.320 --> 00:09:17.130
after the information in the notification was useful.

00:09:17.130 --> 00:09:21.990
When you can imagine having, say, a restaurant
application that lets you know when your table is ready,

00:09:21.990 --> 00:09:30.060
if you turn off your device it's not useful for you to
receive information that your table is ready tomorrow.

00:09:30.060 --> 00:09:33.360
And so with the Enhanced Binary Interface,

00:09:33.360 --> 00:09:38.720
you can now specify a maximum useful
lifetime for any particular notification.

00:09:38.720 --> 00:09:47.180
And if a device reconnects after that expired period
has passed, that notification will not be delivered.

00:09:47.180 --> 00:09:52.770
So note that we will always attempt to
deliver a notification at least one time.

00:09:52.770 --> 00:09:56.870
So you can make use of this for a
fire and forget type notification

00:09:56.870 --> 00:10:00.650
by simply setting the date to a time in the past or to 0.

00:10:00.650 --> 00:10:04.430
Also note that while you are specifying
a lifetime, you'll still not be able

00:10:04.430 --> 00:10:09.660
to exceed the maximum default expiry
for the Push Notification System.

00:10:09.660 --> 00:10:17.040
And some further considerations for
the expiry, it's specified in seconds

00:10:17.040 --> 00:10:22.350
since epoch, this is the number
of seconds since January 1, 1970.

00:10:22.350 --> 00:10:29.340
You can still make use of the existing message command which
essentially is the same as using the command with the expiry

00:10:29.340 --> 00:10:35.490
and saying please store this as long as you can.

00:10:35.490 --> 00:10:41.050
Also note that this system also expects time coordination on
your server; so you want to make sure that you're making use

00:10:41.050 --> 00:10:46.560
of the Network Time Protocol so that your server time
is in sync with the Apple Push Notification Server time;

00:10:46.560 --> 00:10:52.040
so putting that altogether the existing message
command as we've looked at looks something like this.

00:10:52.040 --> 00:10:59.660
There's the Device Token, the Payload, the
Command Identifier and the Prefix Links.

00:10:59.660 --> 00:11:03.370
To make use of the enhanced Binary
Interface we change a few things.

00:11:03.370 --> 00:11:09.710
First of all it's a new command
ID and instead of 0 it's now 1.

00:11:09.710 --> 00:11:16.510
You will then add in your particular
identifier and your expiry time.

00:11:16.510 --> 00:11:22.640
This makes up the entirety of the
enhanced Binary Interface Protocol.

00:11:22.640 --> 00:11:29.250
The last thing I have to talk to you about today
is receiving notifications over a Wi-Fi connection.

00:11:29.250 --> 00:11:37.570
As some you have noticed, prior to iOS 4 devices
which were connected by a Wi-Fi and sleeping resorted

00:11:37.570 --> 00:11:43.350
to a polling behavior in order to receive notifications.

00:11:43.350 --> 00:11:49.460
However, with iOS 4 we now fully support
push notifications over Wi-Fi connections.

00:11:49.460 --> 00:11:54.870
This requires an iPod, iPad or iPhone 3GS or newer.

00:11:54.870 --> 00:12:01.470
So in summary we have the Enhanced Binary Interface
which will alleviate some unknown disconnection issues

00:12:01.470 --> 00:12:08.930
for developers as well as allowing you control
over the lifetime in any particular notification.

00:12:08.930 --> 00:12:15.110
Also all of this is available right now.

00:12:15.110 --> 00:12:20.700
You can use this new message command as soon as you exit.

00:12:20.700 --> 00:12:29.030
As well we have Enhanced Device Support such
that we now support push notifications over Wi-Fi

00:12:29.030 --> 00:12:35.150
with iOS 4 on iPod, iPad and iPhone 3GS or newer.

00:12:35.150 --> 00:12:40.210
All right that's all I have to talk to you about today.

00:12:40.210 --> 00:12:42.820
Back to Jacob to tell you more about local notifications.

00:12:42.820 --> 00:12:43.090
>> Jacob: Great.

00:12:43.090 --> 00:12:44.730
Thanks Darryl.

00:12:44.730 --> 00:12:49.910
So now I'm going to talk to you guys about
implementing local notifications in your app.

00:12:49.910 --> 00:12:55.320
Just to recap real quick local
notifications are new to iOS 4.

00:12:55.320 --> 00:13:01.310
They're scheduled to occur at some point in the
future and you can also mark them as repeating.

00:13:01.310 --> 00:13:05.020
You can also cancel your local notification at any time.

00:13:05.020 --> 00:13:08.640
So when would you want to use a local notification?

00:13:08.640 --> 00:13:11.630
Let's go over some examples of apps that might use them.

00:13:11.630 --> 00:13:14.380
The first is a Alarm Clock app.

00:13:14.380 --> 00:13:17.460
You want an alarm to happen every morning at the same time.

00:13:17.460 --> 00:13:23.420
This is a great example of a repeating notification
because you want it to happen every day of the week.

00:13:23.420 --> 00:13:25.720
Another example is a Reminder App.

00:13:25.720 --> 00:13:30.580
You want to be reminded to not
forget something before a big trip.

00:13:31.690 --> 00:13:34.780
The last example is a Location Based App.

00:13:34.780 --> 00:13:40.570
Using the new location services in iOS 4
you can provide location in the background.

00:13:40.570 --> 00:13:45.640
If your background app figures something out like
your friend is near, it can use a local notification

00:13:45.640 --> 00:13:48.730
to display an alert and let the user know.

00:13:50.670 --> 00:13:55.380
There are some times, however, when we
don't want you to use local notifications.

00:13:55.380 --> 00:13:59.250
The biggest is for any sort of in-app
errors or confirmation dialogues.

00:13:59.250 --> 00:14:06.850
For that it's best to use UIAlertView or
just make your own feedback in your own UI.

00:14:06.850 --> 00:14:12.510
Also if you want to alert the user about a calendar-based
event, we recommend that you look at using EventKit.

00:14:12.510 --> 00:14:17.750
It will allow you to create an event in the user's
calendar and you can set an alarm on that event.

00:14:17.750 --> 00:14:21.350
The user will get notified by the system
when that event is about to occur.

00:14:21.350 --> 00:14:25.660
So now let's take a look at the API for UILocalNotification.

00:14:25.660 --> 00:14:33.200
If you remember there's three different styles
of notifications-- a badge, an alert and a sound.

00:14:33.200 --> 00:14:36.480
So we have properties for each of those.

00:14:36.480 --> 00:14:41.330
Once you've set that up you're going to want to schedule
your notification to happen at some point in the future

00:14:41.330 --> 00:14:45.100
and you may also want to mark it as repeating.

00:14:45.100 --> 00:14:51.040
Notifications also provide a userInfo Dictionary so you
can add any extra metadata that your app might need.

00:14:51.040 --> 00:14:57.630
So let's start by taking a look at the three
different styles you can set on a notification.

00:14:58.770 --> 00:15:00.720
The first is a badge.

00:15:00.720 --> 00:15:08.130
If you set the applicationIconBadgeNumber property when
the notification fires, you'll get a badge on your icon.

00:15:08.130 --> 00:15:10.050
There is one trick to this though.

00:15:10.050 --> 00:15:13.280
If you set zero your badge won't get cleared.

00:15:13.280 --> 00:15:16.350
To clear your badge or to change it
once your app is running you'll want

00:15:16.350 --> 00:15:20.530
to use UIApplications applicationIconBadge property.

00:15:21.710 --> 00:15:27.090
The next style of notification is an alert.

00:15:27.090 --> 00:15:33.860
If you set an alert string as an alertBody in your
notification, an alert will pop up with a single button.

00:15:33.860 --> 00:15:37.800
When the user taps that button the alert will be dismissed.

00:15:37.800 --> 00:15:41.120
You can also set actions on your alerts.

00:15:41.120 --> 00:15:48.320
What actions do is allow the user to tap
on that extra button on the notification

00:15:48.320 --> 00:15:56.340
to launch directly into your app - just like that.

00:15:56.340 --> 00:15:58.560
So there's one note here.

00:15:58.560 --> 00:16:03.030
Since you're displaying strings to the user,
it's always a good idea to localize them.

00:16:03.030 --> 00:16:05.770
Even if your app isn't currently
shipping in multiple countries,

00:16:05.770 --> 00:16:09.940
it will make your life a lot easier if
you decide to do that in the future.

00:16:09.940 --> 00:16:12.850
We've made this really easy to do on iOS 4.

00:16:12.850 --> 00:16:18.580
Just create a localized strings file and add key
value pairs of the strings that you want localized.

00:16:18.580 --> 00:16:22.800
When you make your alert use those
keys as the content of the alert.

00:16:22.800 --> 00:16:26.130
Note that we are not localizing the strings right now.

00:16:26.130 --> 00:16:29.800
This is important because if the user
changes their language between now

00:16:29.800 --> 00:16:34.190
and when the alert fires, they'll
get the right localized alert.

00:16:34.190 --> 00:16:39.750
The OS will localize it on behalf when the alert fires.

00:16:39.750 --> 00:16:42.450
The last property for alerts is a launch Image.

00:16:42.450 --> 00:16:45.690
This is new to iOS for both push and local notifications.

00:16:45.690 --> 00:16:52.480
So those of you that aren't even planning on doing
local notifications might be interested in this.

00:16:52.480 --> 00:16:57.080
When an alert fires and the user taps on that
button, your app is going to get launched

00:16:57.080 --> 00:17:00.490
as if they had tapped on the icon from the home screen.

00:17:00.490 --> 00:17:05.760
This means you'll see the default launch image or you
may see a screenshot of your app in its previous state.

00:17:05.760 --> 00:17:07.370
This might not always be what you want though.

00:17:07.370 --> 00:17:11.530
You might want to take the user directly
into the thing you notified them for.

00:17:11.530 --> 00:17:14.530
To do this, you set an alertLaunchImage.

00:17:14.530 --> 00:17:21.280
In the case of our example app here we're telling the
user about a baseball game that they want to watch.

00:17:21.280 --> 00:17:24.340
If they hit the view button, we want
to take them directly into the view

00:17:24.340 --> 00:17:26.960
where we're showing them the baseball game in progress.

00:17:26.960 --> 00:17:32.070
So we take a screenshot of that view
and we set that as our alertLaunchImage.

00:17:32.070 --> 00:17:37.050
When the user taps the button the app will be
launched and the transition will be seamless

00:17:37.050 --> 00:17:41.700
between the application launching and your view coming up.

00:17:41.700 --> 00:17:47.230
Finally, the last style of notification
you can create is a sound [glass chime].

00:17:47.230 --> 00:17:52.610
You can play any sound in your apps bundle or if you
don't have your own sound you can just play the system

00:17:52.610 --> 00:17:53.930
default sound.

00:17:53.930 --> 00:17:57.040
If the sound is working it sounds
like this [background sound].

00:17:57.040 --> 00:18:04.310
Cool. That's it for the different
styles of local notifications.

00:18:04.310 --> 00:18:08.400
Now you're going to want to schedule that
notification so let's look at how you do that.

00:18:08.400 --> 00:18:14.270
To schedule a notification you just set the fire
date and time zone property of the notification.

00:18:14.270 --> 00:18:16.360
There's one catch though.

00:18:16.360 --> 00:18:19.760
Try not to do your own time-based math here.

00:18:19.760 --> 00:18:25.920
This time tomorrow isn't necessarily going to be sixty
seconds times 60 minutes times 24 hours from now.

00:18:25.920 --> 00:18:31.370
If say Daylight Savings Time happened tonight you'd
end up an hour off tomorrow when your alert fired.

00:18:31.370 --> 00:18:38.170
Instead, you should use NSDateComponents to set the
specific date you want the notification to fire at.

00:18:38.170 --> 00:18:40.970
Then the OS can handle all the
tricky time-based math for you.

00:18:40.970 --> 00:18:48.790
So I want to take a minute to step aside
and talk about the different kinds of times

00:18:48.790 --> 00:18:51.220
that you can set a notification to fire at.

00:18:51.220 --> 00:18:56.300
This gets a little tricky but hopefully
we can figure it out.

00:18:56.300 --> 00:18:58.960
There are two different kinds of times.

00:18:58.960 --> 00:19:02.550
The first is what I'm going to call a Universal Time.

00:19:02.550 --> 00:19:07.740
A Universal Time happens at the same instant
no matter where you are in the world.

00:19:07.740 --> 00:19:10.970
It doesn't have anything to do
with the time zone you are in.

00:19:10.970 --> 00:19:16.550
A Wall Time is whatever is on the clock
on the wall where you are right now.

00:19:16.550 --> 00:19:18.930
So let's look at a Universal Time first.

00:19:18.930 --> 00:19:27.740
To make a notification with the Universal
Time, just set the date and no time zone.

00:19:27.740 --> 00:19:32.840
When you do that the notification will happen
at the same instant all around the world.

00:19:32.840 --> 00:19:35.360
A great example of this is a baseball game.

00:19:35.360 --> 00:19:41.220
Baseball games start at the same time whether you're in
San Francisco or in New York so we just set an NSDate

00:19:41.220 --> 00:19:48.510
on this notification and when the notification
fires the time in San Francisco may be 2PM

00:19:48.510 --> 00:19:51.560
but at the same instant it's going to be 5PM in New York.

00:19:51.560 --> 00:19:55.010
The other kind of time is a Wall Time.

00:19:55.010 --> 00:19:59.530
A Wall Time has a date and a time zone set on it.

00:19:59.530 --> 00:20:03.950
This time is going to get changed
depending on what time zone you move to.

00:20:03.950 --> 00:20:07.930
So an example of this is an Alarm
Clock that wakes you up every morning.

00:20:07.930 --> 00:20:15.640
You always want that to happen at the same time so
you set a date and a time zone on that notification.

00:20:15.640 --> 00:20:19.890
Now when you're in San Francisco
for WWDC this week it happens at 9AM

00:20:19.890 --> 00:20:23.350
and when you move back to New York it still happens at 9AM.

00:20:23.350 --> 00:20:31.020
So just to review that-- if you don't
have a time zone it's a Universal Time.

00:20:31.020 --> 00:20:36.250
A couple examples of this are a
Baseball game or a Conference call

00:20:36.250 --> 00:20:38.890
or an event like the close of the Stock Market.

00:20:38.890 --> 00:20:44.570
These all happen in a single instance
regardless of what time zone you are in.

00:20:44.570 --> 00:20:47.750
The other kind of time is a Wall Time.

00:20:47.750 --> 00:20:57.860
A couple examples of this are an Alarm Clock, or New Year's
Eve or a TV show that happens at the same time every day.

00:20:57.860 --> 00:21:01.270
All right getting back to scheduling notifications.

00:21:01.270 --> 00:21:04.980
You can also mark your notifications
to repeat at certain intervals.

00:21:04.980 --> 00:21:09.010
To do this just set the repeatInterval on your notification.

00:21:09.010 --> 00:21:12.500
You can use any NSCalendarUnit to do that.

00:21:12.500 --> 00:21:17.090
So in this example we're using NSDayCalendarUnit
and the notification will repeat every day.

00:21:17.090 --> 00:21:23.050
But you could also use NSWeekCalendarUnit;
now it repeats every week.

00:21:23.050 --> 00:21:28.410
One thing to note here is the repeatCalendar
that's also associated with it.

00:21:28.410 --> 00:21:34.860
Not all users use the Gregorian calendar, so if you're doing
something that assumes that a year is a certain length,

00:21:34.860 --> 00:21:39.550
you want to also set the calendar that you're
expecting otherwise you might get the wrong repeat

00:21:39.550 --> 00:21:43.320
for a user using a different calendar.

00:21:43.320 --> 00:21:49.340
So that's how you schedule a notification.

00:21:49.340 --> 00:21:54.290
The last property in a local notification is the userInfo.

00:21:54.290 --> 00:22:00.500
The userInfo is just an NSDictionary that you can store
any additional keys that your application might need.

00:22:00.500 --> 00:22:06.620
A couple examples of what you might want to put here an
identifier for the notification or possibly some information

00:22:06.620 --> 00:22:09.510
for your app of what view it should launch into.

00:22:09.510 --> 00:22:13.590
You can put anything in here that
can be stored in an NSDictionary.

00:22:15.110 --> 00:22:23.400
All right so we now have a local notification and we
want to get that to actually appear on the system.

00:22:23.400 --> 00:22:26.450
How do we do that?

00:22:26.450 --> 00:22:28.350
Well it's really simple.

00:22:28.350 --> 00:22:32.410
Just call schedule notification on UIApplication.

00:22:32.410 --> 00:22:36.350
There's also a matching cancel call.

00:22:36.350 --> 00:22:41.450
We've also provided a couple of convenience methods
for you so you can get all your local notifications

00:22:41.450 --> 00:22:46.590
and you can cancel them all with one call.

00:22:46.590 --> 00:22:52.870
Finally, UILocalNotifications implement
the NSCoding Protocol

00:22:52.870 --> 00:22:57.020
so you can serialize them out to
your database and use them later.

00:22:57.020 --> 00:23:01.710
Now let's look at the different
cases where your notification fires.

00:23:01.710 --> 00:23:06.290
There are three different possible states for
your application when the notification happens.

00:23:06.290 --> 00:23:13.910
You could be not running or suspended, your app could be
in the foreground or you could be one of the special types

00:23:13.910 --> 00:23:19.390
of apps that runs in the background
like a location or audio-based app.

00:23:19.390 --> 00:23:24.180
So let's look at the first case where
your app has never run or it's suspended.

00:23:24.180 --> 00:23:30.580
When the notification fires, iOS will
handle that notification on your behalf.

00:23:30.580 --> 00:23:36.790
The notification will pop up and if the user
decides to tap on that button and launch your app,

00:23:36.790 --> 00:23:40.050
your app will get brought to the foreground.

00:23:40.050 --> 00:23:44.900
When your app launches you'll get the
application:didFinishLaunchingWithOptionsCallback

00:23:44.900 --> 00:23:47.730
and the notification will be in there.

00:23:47.730 --> 00:23:51.030
Your app can then do whatever it needs
to do to respond to that notification.

00:23:51.030 --> 00:23:54.410
The next case is an app that's
already running in the foreground.

00:23:54.410 --> 00:24:00.870
In this case the notification will still come in
but the iOS won't do anything on behalf of your app.

00:24:00.870 --> 00:24:04.420
No alert will pop up or no badge will be set.

00:24:04.420 --> 00:24:09.130
Instead we know that your app is going to be
smarter about displaying the appropriate UI

00:24:09.130 --> 00:24:12.460
or just going straight to the view that you need to go to.

00:24:12.460 --> 00:24:17.140
So in this case the notification comes in

00:24:17.140 --> 00:24:21.400
and your application receives
application:didReceiveLocalNotification.

00:24:21.400 --> 00:24:24.880
Your application can then do the appropriate thing.

00:24:24.880 --> 00:24:29.220
In this case we want to display a subtle little
reminder about the baseball game that's going on.

00:24:29.220 --> 00:24:33.430
Finally, there's the third case where
your app is running in the background.

00:24:33.430 --> 00:24:39.510
If you're one of the applications using the new
multitasking API in iOS 4 you may be running

00:24:39.510 --> 00:24:45.040
in the background for location, Voice Over IP, or Audio.

00:24:45.040 --> 00:24:51.560
If you are one of these apps and something
causes you to want to alert the user,

00:24:51.560 --> 00:24:54.020
you'll want to schedule a local
notification with an action button.

00:24:54.020 --> 00:25:01.130
This is a good way for the user to be given
the option to jump straight into your app.

00:25:01.130 --> 00:25:05.900
So you can schedule a local notification now
rather than scheduling it for in the future.

00:25:05.900 --> 00:25:10.800
This gives the user the ability to launch your app.

00:25:10.800 --> 00:25:15.210
Note however that if you aren't one of these special
background apps, this probably isn't what you want.

00:25:15.210 --> 00:25:20.940
If you call scheduleLocalNotificationNow and you're already
in the foreground, the system is just going to turn right

00:25:20.940 --> 00:25:24.390
around and call didReceiveLocalNotification
and nothing's going to happen.

00:25:24.390 --> 00:25:27.150
All right so a quick word on alerts.

00:25:28.890 --> 00:25:31.400
Be wise with your alerts.

00:25:31.400 --> 00:25:32.280
Don't bother the user.

00:25:32.280 --> 00:25:37.620
We'd hate for them to delete your app because you
displayed too many alerts and you bothered them.

00:25:37.620 --> 00:25:40.930
With push alerts they can also
just turn off push for your app

00:25:40.930 --> 00:25:45.370
and then you can't get any information
to them so be nice to the users.

00:25:45.370 --> 00:25:49.180
If you can, use a badge instead of an alert.

00:25:49.180 --> 00:25:54.220
It still lets the user know that there's information
there for them, but it's a little less intrusive.

00:25:54.220 --> 00:26:00.260
All right so now Chris is going to come up
and give us a demo of what we just learned.

00:26:00.260 --> 00:26:01.380
>> Hi I'm Chris Marcellino.

00:26:01.380 --> 00:26:06.030
I'm one of the iPhone iOS Software Engineers and
I'm going to talk to you and show you a few tips

00:26:06.030 --> 00:26:10.380
about some UILocalNotification coding in your apps.

00:26:10.380 --> 00:26:14.060
If you were here last year you might
remember that we showed you the Squawkr app

00:26:14.060 --> 00:26:16.740
and we showed you how to extend
it to use push notifications.

00:26:16.740 --> 00:26:21.130
Well this year I'm going to show you how
to extend it to use local notifications.

00:26:21.130 --> 00:26:27.290
So Squawkr is your standard social networking app
except it's an app that's all about complaining.

00:26:27.290 --> 00:26:33.890
As you see here I'm complaining about my bad day
and my lunch and other things that occurred to me.

00:26:33.890 --> 00:26:38.120
I have some of my friends complaining
about stuff going on in their lives too.

00:26:38.120 --> 00:26:42.720
So I took the Squawkr app and I
decided that I really wanted the ability

00:26:42.720 --> 00:26:46.360
to let users say they want to be reminded when to Squawk.

00:26:46.360 --> 00:26:50.000
So I added a button that brings up a view controller,

00:26:50.000 --> 00:26:55.050
lets the user pick just really simply how
far in the future they want to be reminded.

00:26:55.050 --> 00:26:59.870
And what I did is I wired up this
Schedule button to the schedule IV action

00:26:59.870 --> 00:27:03.190
in the schedule view controller that runs to this code.

00:27:03.190 --> 00:27:09.810
So say once I click Schedule this action
is going to get called and first I'm going

00:27:09.810 --> 00:27:15.060
to cancel all the existing notifications just because
my app only wants one notification active at once.

00:27:15.060 --> 00:27:20.980
And I'm going to get the countdown duration from the date
picker and then speed it up a little bit for purposes

00:27:20.980 --> 00:27:25.060
of this demo; and then finally I'm
going to create my local notification.

00:27:25.060 --> 00:27:29.660
Now this local notification doesn't use any calendar.

00:27:29.660 --> 00:27:31.460
It's just a simple time in the future.

00:27:31.460 --> 00:27:37.190
So I create a new NSDate with the time interval
nSeconds in the future and set that as the fireDate

00:27:37.190 --> 00:27:43.180
on the UILocalNotification and then I get my
localized strings from my alertBody and alertAction.

00:27:43.180 --> 00:27:48.350
And as Jacob talked about these are strings that are
in my Localizable.strings file in my apps bundle.

00:27:48.350 --> 00:27:53.590
So here's my English strings and you of course could have
strings for every language that you're using or supporting;

00:27:53.590 --> 00:27:58.870
and then I have a custom sound here that
I want to set as my soundName so we hear

00:27:58.870 --> 00:28:02.770
that when the switch is on sound on the phone.

00:28:02.770 --> 00:28:08.730
And finally I have a custom launch image because when I'm
launching the app for the user to create a new Squawk I want

00:28:08.730 --> 00:28:15.390
to make sure the UI doesn't glitch that it goes straight
from the right default PNG showing the creation UI seamlessly

00:28:15.390 --> 00:28:20.410
to the UI without showing the old snapshot beforehand.

00:28:20.410 --> 00:28:24.950
And finally, I add in a little bit
of user info to give me some context

00:28:24.950 --> 00:28:28.410
about what this local notification
was for when the app's resuming.

00:28:28.410 --> 00:28:34.400
So I just put in an NS Boolean Bool:Yes with
the createSquawk key and I'll look in a second.

00:28:34.400 --> 00:28:38.130
And of course I schedule it, release it and
then dismiss view controller [sound effects].

00:28:38.130 --> 00:28:48.840
Okay, so let's look at the application
delegate of my application.

00:28:48.840 --> 00:28:53.870
So in my SquawkrAppDelegate class, I
have two methods I've added code for.

00:28:53.870 --> 00:28:59.350
I've added application didFinishLaunchingWithOptions,
it's a delegate callback, your application gets on launch

00:28:59.350 --> 00:29:05.070
to implement it; and I also have
application didReceiveLocalNotification.

00:29:05.070 --> 00:29:11.800
So let's say that I schedule a notification
and quit the app [sound effects].

00:29:11.800 --> 00:29:16.450
Now the app wasn't running as you saw
that I terminated it in the App Switcher.

00:29:16.450 --> 00:29:20.270
But here I launched the app it's going to launch fresh

00:29:20.270 --> 00:29:24.500
and the application didFinishLaunchingOptions
delegate callback is going to get called.

00:29:24.500 --> 00:29:28.530
So in my application didFinishLaunchingWithOptions
delegate callback,

00:29:28.530 --> 00:29:34.030
what you see here is that I get the local notification
out of the launch dictionary, and I check to see

00:29:34.030 --> 00:29:37.050
if the userInfo key has my createSquawk key.

00:29:37.050 --> 00:29:41.630
If it does then I'm going to go
straight to my Squawk creation UI.

00:29:42.730 --> 00:29:48.380
And you'll notice that you saw nothing but a seamless
transition from my default PNG to my Squawk UI.

00:29:48.380 --> 00:29:50.060
Now let me show you another case.

00:29:50.060 --> 00:29:58.580
If, for example, instead of launching fresh, my application is
running if it supports multitasking it's linked on iOS 4.0,

00:29:58.580 --> 00:30:08.070
when I schedule a notification and spin the app, once
the Squawk fires [sound effect] and I resume the app,

00:30:08.070 --> 00:30:08.490
you're going to see

00:30:08.490 --> 00:30:13.240
that my application didReceiveLocalNotification
delegate callback is going to get called.

00:30:13.240 --> 00:30:16.650
And I'm stuck here in the debugger
we're broken, this is the default PNG

00:30:16.650 --> 00:30:20.010
that looks just like my UI that I'm going to launch to.

00:30:20.010 --> 00:30:22.510
But that's actually the image itself-- not real UI.

00:30:22.510 --> 00:30:26.020
I took a screenshot of my app when I was developing it.

00:30:26.020 --> 00:30:30.420
So here I am in this delegate callback
didReceiveLocalNotification,

00:30:30.420 --> 00:30:34.120
and one thing that you may have encountered if
you've already started using local notifications

00:30:34.120 --> 00:30:40.680
in the developer seed, is that you want to know sometimes
if your app is structured this way whether you're resuming

00:30:40.680 --> 00:30:45.300
in response to a local notification or if you've
just received a local notification while your app was

00:30:45.300 --> 00:30:46.900
already foregrounded.

00:30:46.900 --> 00:30:49.210
The way to tell apart those two situations is

00:30:49.210 --> 00:30:55.190
to call the UIApplication ApplicationState
property and get the current application state.

00:30:55.190 --> 00:30:59.590
So the application state has three
return values that you can get.

00:30:59.590 --> 00:31:06.480
You can get active, inactive or background; and the only
time you're going to get this delegate notification call is

00:31:06.480 --> 00:31:10.080
when either you're active already or you're inactive.

00:31:10.080 --> 00:31:15.730
Now if you get this callback and application state
returns inactive, that means the user launched your app

00:31:15.730 --> 00:31:21.300
with the action button in your notification and the
application is resuming a response to the notification.

00:31:21.300 --> 00:31:27.010
So if your UI was to normally maybe ask user confirmation
while the app was already foregrounded you might not want

00:31:27.010 --> 00:31:32.660
to do that if the app is resuming because the user already
acknowledged your notification and indicated they want

00:31:32.660 --> 00:31:34.670
to launch your app you go straight to that UI.

00:31:34.670 --> 00:31:38.700
So that's how you can tell the
difference between those two cases.

00:31:38.700 --> 00:31:43.910
Again I checked my createSquawk key in case I had multiple
notifications and wanted to differentiate between each

00:31:43.910 --> 00:31:48.540
of them; and in this case when I have
state UIApplicationStateInactive

00:31:48.540 --> 00:31:54.290
and I have shouldSquawk, we launched right to the Squawk UI.

00:31:54.290 --> 00:32:05.680
As you see here I'm right in the Squawk
UI and I can create a new Squawk.

00:32:05.680 --> 00:32:09.970
So another thing I'd like to note is if you receive a
notification while your application is already running

00:32:09.970 --> 00:32:14.990
foregrounded, one thing you should do is not
just if you can help it display a UIAlertView.

00:32:14.990 --> 00:32:18.590
Try to do something custom like take the
user to the right part of your application

00:32:18.590 --> 00:32:24.710
or have your existing custom UI reflect
the fact that local notification fired.

00:32:26.710 --> 00:32:31.760
So one other thing you may have noticed is that when I
cancelled all notifications here I wasn't really specific

00:32:31.760 --> 00:32:33.900
about which one I wanted to cancel or anything.

00:32:33.900 --> 00:32:37.520
But if you do start cancelling specific
notifications or maybe you have one

00:32:37.520 --> 00:32:42.150
of those background apps that's using notification services
or audio, and you're targeting certain notifications

00:32:42.150 --> 00:32:47.430
to cancel, one thing you should keep in mind is
that if a notification alert is already up on screen

00:32:47.430 --> 00:32:53.570
and you cancel it, iOS will tear down the
existing already visible notification alert

00:32:53.570 --> 00:32:56.240
so the user will kind of maybe wonder why it disappeared.

00:32:56.240 --> 00:32:59.430
This might be useful if you have notification
data that's no longer valid and you want

00:32:59.430 --> 00:33:01.640
to actually make it go away and
maybe replace it with a new one.

00:33:01.640 --> 00:33:05.340
But if you don't and say the notifications
just fired, don't bother cancelling it

00:33:05.340 --> 00:33:09.270
as the operating system will cancel it for you.

00:33:09.270 --> 00:33:17.580
The final note I want to make on UILocalNotification
is that as Jacob mentioned it's for copying and coding.

00:33:17.580 --> 00:33:21.860
Coding gives you a lot of power in that
your application can serialize instances

00:33:21.860 --> 00:33:26.600
of UILocalNotification using NSKeyArchiver
and NSKeyUnarchiver and store those

00:33:26.600 --> 00:33:31.550
in any existing data model you might have
like a core disk or a database on disk.

00:33:31.550 --> 00:33:37.340
When you restore those local notifications
when you re-create them using Key Unarchiver,

00:33:37.340 --> 00:33:43.390
you can compare them using is equal to the existing
ones you have running via scheduled local notifications

00:33:43.390 --> 00:33:48.700
or any other ones you might have in your model or even
make copies of those and change them to suit your needs.

00:33:48.700 --> 00:33:55.250
One consequence of this is that UILocalNotification
implements is equal on hatch in the deep sense.

00:33:55.250 --> 00:34:01.130
Two different instances of UILocalNotification will be
equal if all of their properties are the same so you can use

00:34:01.130 --> 00:34:05.040
that to compare an instance you may have gotten from
the system versus one you had in your data store

00:34:05.040 --> 00:34:07.580
or one you created by hand to see if they're equal.

00:34:07.580 --> 00:34:15.300
Equivalently you can ask the system to cancel notifications
where you've unarchived an instance from your date store.

00:34:15.300 --> 00:34:20.910
If you change any property of the notification, you're
going to find your notifications are no longer equal.

00:34:20.910 --> 00:34:26.110
And of course the system implementing has correctly on
UILocalNotification means you can use your own dictionaries

00:34:26.110 --> 00:34:30.120
and your own sets to be able to
correlate and find your notifications.

00:34:30.120 --> 00:34:32.550
That's all I have for you today.

00:34:32.550 --> 00:34:35.570
I'm going to hand it back to Jacob
for more on local notifications.

00:34:35.570 --> 00:34:37.510
>> Jacob Farkas: All right thanks Chris.

00:34:37.510 --> 00:34:45.560
So in summary, local notifications and push
notifications are great ways to get the user's attention.

00:34:45.560 --> 00:34:50.940
It gives you all the functionality of being a background
app without you actually having to use any CPU.

00:34:50.940 --> 00:34:54.570
This saves on battery life and users like it.

00:34:54.570 --> 00:34:59.280
If you want to stay connected with a network
service, think about using push notifications.

00:34:59.280 --> 00:35:03.230
Your server can send messages to the phone.

00:35:03.230 --> 00:35:09.550
If you want to notify the user about something
that's time-based, use local notifications.

00:35:09.550 --> 00:35:11.600
Remember to always localize.

00:35:11.600 --> 00:35:16.680
It will save you a lot of work if you
ever decide to ship in other countries.

00:35:16.680 --> 00:35:21.110
Also, remember the difference between
Universal Times and Wall Times.

00:35:21.110 --> 00:35:26.490
notifications can fire at different
instances depending on how you set them up.

00:35:26.490 --> 00:35:32.090
And finally, if your app is already in the
foreground no UI is going to be shown on your behalf.

00:35:32.090 --> 00:35:36.510
You should handle that notification and
do something appropriate for your app.

00:35:36.510 --> 00:35:39.860
If you'd like any more information on
this Mark Malone is our Evangelist.

00:35:39.860 --> 00:35:43.620
We also have information up on the forms.

00:35:43.620 --> 00:35:47.720
There's some related sessions you might be interested
in; the Multitasking session will tell you all

00:35:47.720 --> 00:35:52.100
about being a background app which
you can use local notifications with;

00:35:52.100 --> 00:35:55.250
and there's an EventKit Session later today.

