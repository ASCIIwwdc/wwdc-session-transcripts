WEBVTT

00:00:06.430 --> 00:00:08.140
>> David Myszewski: Welcome to the multitasking talk.

00:00:08.140 --> 00:00:12.800
I'm David Myszewski and I manage
one of the iPhone performance teams.

00:00:12.800 --> 00:00:16.720
I've been working on performance for
about four years and we're going to talk

00:00:16.720 --> 00:00:20.100
to you all about multitasking in today's talk.

00:00:21.620 --> 00:00:26.290
Also joining me will be David Goodwin, who is an
engineer on my team and spent a lot of time thinking

00:00:26.290 --> 00:00:30.050
about multitasking for the last, last year or so.

00:00:30.050 --> 00:00:33.810
So, to give you a little, brief
introduction into multitasking,

00:00:33.810 --> 00:00:40.430
multitasking is of course a really,
really huge feature of iPhone, of iOS 4.

00:00:40.430 --> 00:00:45.510
It's one that we hope that all of you will
adopt in your applications and in fact,

00:00:45.510 --> 00:00:49.430
in order to best have the user experience on the iPhone,

00:00:49.430 --> 00:00:53.240
we expect really all the apps on the
App Store to adopt multitasking.

00:00:53.240 --> 00:01:00.300
And this is part one of a two part series and we'll
talk a little bit about what that means in a little bit.

00:01:00.300 --> 00:01:04.560
Now of course, multitasking dramatically
improves the user experience.

00:01:04.560 --> 00:01:09.010
Switching back and forth between apps
is really, really seamless on iOS 4.

00:01:09.010 --> 00:01:12.570
And applications that you have are just that much better.

00:01:12.570 --> 00:01:16.660
Because the user can return immediately to where
they were and they don't have to wait at all.

00:01:16.660 --> 00:01:20.720
So it's often the case that your application
will be just sitting around in the background

00:01:20.720 --> 00:01:24.250
and the user comes right back to your
application and it's right where you left it.

00:01:24.250 --> 00:01:27.440
So it makes existing apps just that much better.

00:01:27.440 --> 00:01:32.940
And in addition to that, we're enabling a whole new
category of applications that couldn't have been written

00:01:32.940 --> 00:01:38.490
on previous OSs and this will make the
overall user experience a lot better on iOS.

00:01:38.490 --> 00:01:43.180
And as I said, every single application
on the store should adopt multitasking.

00:01:43.180 --> 00:01:46.520
And today, in this particular talk,
we're going to focus on the features

00:01:46.520 --> 00:01:53.820
that we think everybody who's developing
applications for iOS 4, should take advantage of.

00:01:53.820 --> 00:01:55.330
So today you'll learn a few things.

00:01:55.330 --> 00:02:01.000
First of all, we'll give you an overview about what
multitasking means on iOS 4 and then of course,

00:02:01.000 --> 00:02:04.310
we'll describe to you how to enable
multitasking in your application.

00:02:04.310 --> 00:02:06.320
And that's going to be a combination of things.

00:02:06.320 --> 00:02:12.610
We have provided a bunch of fantastic APIs for you to
adopt and we'll talk to you about what the workflow

00:02:12.610 --> 00:02:18.720
of those APIs is, as well as how your application can
fit in really well with the rest of the operating system.

00:02:18.720 --> 00:02:22.060
So we'll have some responsibilities
and best practices that we'll discuss

00:02:22.060 --> 00:02:26.580
so that your application can be
that much better on the iPhone.

00:02:26.580 --> 00:02:31.070
And then finally, we'll describe to you a little
bit about some development tools that allow you

00:02:31.070 --> 00:02:37.430
to more easily adopt multitasking and
figure out what your application is doing.

00:02:37.430 --> 00:02:42.540
So, to start things off, David Goodwin is
going to give us a little bit of a demo.

00:02:47.950 --> 00:02:50.300
>> David Goodwin: Good morning everyone.

00:02:50.300 --> 00:02:50.570
[ applause ]

00:02:50.570 --> 00:02:53.730
So, here we have two iPhones, 3GSs.

00:02:53.730 --> 00:02:57.500
One has iOS 4 on it and one has iPhone OS 3.

00:02:57.500 --> 00:02:58.580
You can probably tell which is which.

00:02:58.580 --> 00:03:07.070
What we are going to show today, just a brief overview of
what multitasking can do for every single app out there.

00:03:07.070 --> 00:03:09.100
Every single app on the App Store.

00:03:09.100 --> 00:03:13.270
So first let's, what we have for a
demo here is a pretty simple app.

00:03:13.270 --> 00:03:17.330
It's just a little journaling app, that you can like
make little notes in and attach a little photo to

00:03:17.330 --> 00:03:19.280
and I'm going to launch that on each device.

00:03:19.280 --> 00:03:20.540
And here it launches up.

00:03:20.540 --> 00:03:25.970
You can see we have our entries for just a
few things that I've been journaling about.

00:03:25.970 --> 00:03:27.350
Then we can look into them.

00:03:27.350 --> 00:03:29.450
Like there's this little kayak trip.

00:03:29.450 --> 00:03:30.890
That was pretty nice.

00:03:30.890 --> 00:03:35.140
OK, oh I did notice back there
actually though, this Irwin's wedding.

00:03:35.140 --> 00:03:39.150
I was, I see that I'm thinking oh, I had
some other photos about Irwin's wedding.

00:03:39.150 --> 00:03:40.710
Wouldn't it be great, I want to
go check those out right now.

00:03:40.710 --> 00:03:42.020
That just reminded me.

00:03:42.020 --> 00:03:47.220
Well, iPhone OS 3 of course, we would
return to SpringBoard and we'd find photos

00:03:47.220 --> 00:03:50.690
and we'd launch it and go into the wedding.

00:03:50.690 --> 00:03:54.380
In iPhone OS4 of course, we have
the great, new multitasking UI.

00:03:54.380 --> 00:03:58.460
So I can just double-tap that.

00:03:58.460 --> 00:04:03.580
Photos, which it turns out, one thing you'll notice
here, not only did I switch quickly into photos,

00:04:03.580 --> 00:04:05.070
but I had been looking at photos earlier.

00:04:05.070 --> 00:04:07.110
Maybe a couple days ago, maybe even a week ago.

00:04:07.110 --> 00:04:07.520
I don't know.

00:04:07.520 --> 00:04:10.190
It could have been running in the
background for a long time.

00:04:10.190 --> 00:04:10.980
But right there it is.

00:04:10.980 --> 00:04:13.380
I can quickly get to that, my photo library.

00:04:13.380 --> 00:04:17.550
In this case I want to look at some of
Irwin and Jill's photos from that wedding.

00:04:17.550 --> 00:04:20.430
And now I want to, OK but I want to go back to my journal.

00:04:20.430 --> 00:04:26.990
Again, iPhone OS 3 you leave the photos app
and find journal here again and launch it,

00:04:26.990 --> 00:04:32.890
iPhone OS4 I'm going to use this great
multitasking UI and I'm going to go right back.

00:04:32.890 --> 00:04:37.800
Now one thing I noticed here is, I didn't do the best
job I could have writing this application, did I?

00:04:37.800 --> 00:04:42.100
Because when I returned on iPhone OS
3 and I relaunched the journal app,

00:04:42.100 --> 00:04:45.210
actually didn't bring the user
right back to where they were.

00:04:45.210 --> 00:04:46.760
Now that's my mistake as a developer.

00:04:46.760 --> 00:04:48.270
I could have done a better job.

00:04:48.270 --> 00:04:55.030
But on iOS 4, we help you out a little bit there
and we actually came right back to that same spot.

00:04:55.030 --> 00:05:00.720
Now, let's look, another interesting thing here, let's,
this hike at Lake Tahoe, it has a little, a URL in it.

00:05:00.720 --> 00:05:03.760
My journal app let's you put URLs in.

00:05:03.760 --> 00:05:07.780
And I can again, I can follow an URL link in each of these.

00:05:07.780 --> 00:05:13.170
And again, I switch right into Safari there, with the UI.

00:05:13.170 --> 00:05:15.570
Whoops, well I didn't go Wi-Fi.

00:05:15.570 --> 00:05:19.500
We don't have any Wi-Fi problems I hope.

00:05:19.500 --> 00:05:26.640
And again, once again, following URLs or switching
quickly between apps, it's much quicker, much easier,

00:05:26.640 --> 00:05:32.900
much better user experience for all your
applications in iOS 4, compared to iPhone OS 3.

00:05:32.900 --> 00:05:38.640
And so hopefully that demonstration there
helped you see why, how compelling it will be

00:05:38.640 --> 00:05:41.250
for you to adopt multitasking for your app.

00:05:41.250 --> 00:05:42.620
Now back to Dave.

00:05:42.620 --> 00:05:48.120
>> Dave Myszewski: So, we have a particular view
on multitasking for iOS 4 and in particular,

00:05:48.120 --> 00:05:52.970
we don't believe that general purpose
concurrency is the solution for mobile devices.

00:05:52.970 --> 00:05:55.340
Mobile devices have limited resources.

00:05:55.340 --> 00:06:03.090
They have limited CPU, they have limited RAM and so
we think that in the application that you just saw,

00:06:03.090 --> 00:06:08.810
that really the important thing for that application wasn't
that the app was actually doing something in the background,

00:06:08.810 --> 00:06:13.630
the really important thing was that when the
user returned to the app, the state was preserved

00:06:13.630 --> 00:06:16.690
and the user could immediately interact with the app.

00:06:16.690 --> 00:06:21.990
And for all of the applications on the App
Store, we believe that that will be true.

00:06:21.990 --> 00:06:28.290
That you really want to be able to quickly switch to
particular applications and return to exactly where you were

00:06:28.290 --> 00:06:31.110
and be able to immediately interact with the app.

00:06:32.270 --> 00:06:38.250
And so in fact, that's, if you look at a pie
chart, that would be our pie chart, 100%.

00:06:38.250 --> 00:06:43.550
But you know, there are obviously some applications
that boy, you really need to run in the background

00:06:43.550 --> 00:06:45.510
in order to accomplish the particular task.

00:06:45.510 --> 00:06:51.430
And so what we've done with multitasking is we've created
a little slice of the pie that applications that benefit

00:06:51.430 --> 00:06:56.010
from background execution and we
have enabled certain categories

00:06:56.010 --> 00:06:58.980
of applications to continue running into the background.

00:06:58.980 --> 00:07:02.770
And these ones will be described in great
detail in the second talk and in particular,

00:07:02.770 --> 00:07:07.130
the ability to finish some task that you
are in the middle of, play background audio

00:07:07.130 --> 00:07:10.130
and do some location in VoIP, also in the background.

00:07:10.130 --> 00:07:17.030
So, with multitasking we've provided a solution that works
very well for all developers, for quickly switching back

00:07:17.030 --> 00:07:23.430
and forth between applications and then also
enabled some new categories of applications.

00:07:23.430 --> 00:07:29.890
Now of course, we still have push notifications, which are
a fantastic way for the server to do all the heavy lifting

00:07:29.890 --> 00:07:34.400
and the processing and the pulling, the things that
would consume battery life and then send a notification

00:07:34.400 --> 00:07:39.520
to the device when some interesting data
that the user should know about, arrives.

00:07:39.520 --> 00:07:45.360
So push notifications still are a fantastic
tool to use, even in the multitasking world.

00:07:45.360 --> 00:07:51.460
Because we are pushing all of the heavy lifting
for CPU and battery life, onto the servers.

00:07:51.460 --> 00:07:57.930
So as you saw, we have a lot of benefits
for what we're calling fast app switching,

00:07:57.930 --> 00:08:03.490
which is that the application resumes really quickly,
all of the state was preserved exactly where you left it.

00:08:03.490 --> 00:08:08.790
We provide some great APIs to integrate really
well with the multitasking UI and of course,

00:08:08.790 --> 00:08:12.840
all of the apps on the App Store, we think
will update to this and so, you know,

00:08:12.840 --> 00:08:17.700
the whole OS just behaves better if
everybody has adopted multitasking.

00:08:17.700 --> 00:08:20.190
So I'll give you a brief overview of the services.

00:08:20.190 --> 00:08:24.480
The one that we're going to focus on for this
particular talk is what we call, fast app switching.

00:08:24.480 --> 00:08:29.460
The ability that you saw to resume
quickly and preserve state.

00:08:29.460 --> 00:08:34.640
Push notifications, of course, are still relevant
in the multitasking world, as I just described.

00:08:34.640 --> 00:08:40.770
Local notifications, which are a nice tool in which
you can provide the services of push notifications,

00:08:40.770 --> 00:08:49.100
so displaying an alert, badging your icon, playing a sound
at a predetermined time and then a few different services

00:08:49.100 --> 00:08:54.370
for which applications can take advantage of that
will be described in great detail in the second talk,

00:08:54.370 --> 00:09:01.410
which are background audio, so the ability to play audio
in the background, as you saw in the keynote yesterday.

00:09:01.410 --> 00:09:08.440
Task completion, which basically it recognizes that there
is a category of apps for which the user initiated a task

00:09:08.440 --> 00:09:14.100
in the foreground, like uploading a photo or downloading
some content and you really want that operation

00:09:14.100 --> 00:09:19.820
to complete before, without the user having
to keep the application in the background.

00:09:19.820 --> 00:09:25.690
So we're calling that task completion, the ability
to complete a specific task in the background.

00:09:25.690 --> 00:09:28.710
And we have a couple of location services.

00:09:28.710 --> 00:09:34.620
One that's focused on navigation, which allows
you to use GPS in the background and give very,

00:09:34.620 --> 00:09:43.250
very precise notifications of location changes and some new
services, which we're calling significant location changes

00:09:43.250 --> 00:09:52.790
and region monitoring, which are low power abilities to
figure out when the location changes in the background.

00:09:52.790 --> 00:09:59.830
And then the last one is Voice Over IP, which allows
you to both continue while on the call in the background

00:09:59.830 --> 00:10:02.940
and of course receive calls in the background.

00:10:02.940 --> 00:10:07.250
So together, all of these services
comprise our multitasking solution.

00:10:07.250 --> 00:10:11.740
And as I said, we're going to focus
on fast app switching in this talk.

00:10:11.740 --> 00:10:19.570
In the second talk, we'll go through all of those services
in that second slide that we were just looking at.

00:10:19.570 --> 00:10:22.940
So, if you're a developer, how do you enable multitasking?

00:10:22.940 --> 00:10:25.000
Well it's really simple.

00:10:25.000 --> 00:10:27.640
Just build with the iPhone SDK4.

00:10:27.640 --> 00:10:33.340
Fast app switching is enabled by default and
so we think that every app should adopt it

00:10:33.340 --> 00:10:38.930
and so we made it the default behavior
when you compile with iPhone SDK4.

00:10:38.930 --> 00:10:43.320
And of course, if you have some of the other
services like background audio, location and VoIP,

00:10:43.320 --> 00:10:49.550
then we require that you have an explicit
declaration in the apps Info.plist.

00:10:49.550 --> 00:10:56.270
So, your app lifecycle changes a lot with
multitasking, so to describe in very great detail

00:10:56.270 --> 00:11:00.110
about how the app lifecycle behaves
in this new multitasking world,

00:11:00.110 --> 00:11:03.760
David Goodwin is going to come back on
stage and describe how it all works.

00:11:03.760 --> 00:11:06.890
>> David Goodwin: So, iOS 4 give us
these great multitasking services.

00:11:06.890 --> 00:11:11.440
As Dave said, today we're going to focus mostly on
fast app switching, although a lot of what we'll talk

00:11:11.440 --> 00:11:13.200
about as well will be kind of general things.

00:11:13.200 --> 00:11:17.990
Responsibilities, best practices, that you need
to be aware of when you're writing your app.

00:11:17.990 --> 00:11:21.290
Before we go into those responsibilities and best practices,

00:11:21.290 --> 00:11:24.470
we're going to go into detailed
walk about how your app behaves.

00:11:24.470 --> 00:11:28.840
Now you might know this from your iPhone OS 3
development, in fact we're going to review that first

00:11:28.840 --> 00:11:31.650
and then go into the detail of the iOS 4.

00:11:31.650 --> 00:11:34.640
You know, how your application
acts, how the user interacts with it

00:11:34.640 --> 00:11:37.880
and how your application interacts with this lifecycle.

00:11:37.880 --> 00:11:40.210
So let's start again.

00:11:40.210 --> 00:11:43.760
We'll start with the review of iPhone OS 3.

00:11:43.760 --> 00:11:47.360
Now iPhone OS 3 basically has three
states that your application can be in.

00:11:47.360 --> 00:11:49.580
The not running state, which is pretty obvious.

00:11:49.580 --> 00:11:52.620
And then two running states, inactive and active.

00:11:52.620 --> 00:11:58.760
So let's review how when the user interacts with the device,
how your application transitions between these states.

00:11:58.760 --> 00:12:01.610
Again, initially your application
is in the not running state.

00:12:01.610 --> 00:12:03.270
User launches your application.

00:12:03.270 --> 00:12:06.330
As an example we'll use Maps in this case.

00:12:06.330 --> 00:12:07.840
Map starts running.

00:12:07.840 --> 00:12:14.110
Your application transitions through an inactive
state and then into the active running state.

00:12:14.110 --> 00:12:17.140
So this is the normal foreground running state.

00:12:17.140 --> 00:12:20.660
Your app's in the foreground, the user can interact with it.

00:12:20.660 --> 00:12:26.380
But what can also happen while your app is in the foreground
is for example, you can receive an SMS or some other alert,

00:12:26.380 --> 00:12:32.520
push notification, incoming phone call or the user
can lock the device over top of your application.

00:12:32.520 --> 00:12:38.070
In all those cases what happens is, your
application moves into the inactive state.

00:12:38.070 --> 00:12:41.930
Now your application is still running, it's still
in the foreground, but it's kind of obscured

00:12:41.930 --> 00:12:48.960
or there's something else on top of it,
that puts it into this inactive state.

00:12:48.960 --> 00:12:56.550
Now from the inactive state, the user can take some
action to move it either back into the active state

00:12:56.550 --> 00:12:58.490
or potentially into the not running state.

00:12:58.490 --> 00:13:03.430
For example with an SMS, if the user choose to
reply to the SMS, the SMS app is going to launch

00:13:03.430 --> 00:13:06.630
and your application would go into the not running state.

00:13:06.630 --> 00:13:11.490
In this case, let's assume the user pushes the Close
button, so he's not going to look at the SMS right now.

00:13:11.490 --> 00:13:16.570
That returns your application back into the active state.

00:13:16.570 --> 00:13:20.740
And of course, the last thing a user can do is to
leave your application by hitting the Home button.

00:13:20.740 --> 00:13:26.870
In that case, your application
transitions into the not running state.

00:13:26.870 --> 00:13:28.070
So again, this is very familiar.

00:13:28.070 --> 00:13:32.940
This is the way your applications have been
interacting with the user and

00:13:32.940 --> 00:13:39.090
with the application lifecycle in iPhone
OS 3 and so let's compare that with iOS 4.

00:13:39.090 --> 00:13:43.060
We'll start with the familiar states we just talked about

00:13:43.060 --> 00:13:46.870
and in fact the device mostly behaves
the same way with respect to those.

00:13:46.870 --> 00:13:49.670
So your application is not running.

00:13:49.670 --> 00:13:50.460
The user launches it.

00:13:50.460 --> 00:13:52.660
Again, we're using Maps.

00:13:52.660 --> 00:13:54.010
Moves into the active state.

00:13:54.010 --> 00:14:02.780
Now, as before there's an inactive state that your
app can enter and that's the same as in iPhone OS 3

00:14:02.780 --> 00:14:05.210
or an SMS, incoming phone call, et cetera.

00:14:05.210 --> 00:14:10.580
There's a new inactive, a new way to enter into the
inactive state and that's through the multitasking UI.

00:14:10.580 --> 00:14:16.590
So if the user brings up the multitasking UI, your
application will again enter the inactive state.

00:14:16.590 --> 00:14:22.760
If they dismiss the multitasking UI or any
of those other SMS, just like in iPhone OS 3,

00:14:22.760 --> 00:14:25.910
your application will return to the active state.

00:14:25.910 --> 00:14:32.990
Now, together, because your app is in the foreground,
you know it is running, we group together the active

00:14:32.990 --> 00:14:37.810
and the inactive states together,
as the foreground execution state.

00:14:37.810 --> 00:14:43.470
Of course, the exciting new thing, most exciting new thing
about this application lifecycle with regard to iOS 4,

00:14:43.470 --> 00:14:46.690
is that we're going to introduce two new background states.

00:14:46.690 --> 00:14:52.890
And these are, we're calling them the background
running and the background suspended states.

00:14:52.890 --> 00:14:57.930
The background running state, as you
can imagine, is when your application is

00:14:57.930 --> 00:15:00.660
in the background, but is allowed to continue running.

00:15:00.660 --> 00:15:06.210
Now as Dave mentioned, there's some services, some
categories of multitasking that where it's beneficial

00:15:06.210 --> 00:15:12.210
to allow your application to continue running and those
applications then would be in the background running state.

00:15:12.210 --> 00:15:18.280
This background suspended state, is the state that the
system uses, when it really wants to minimize the impact

00:15:18.280 --> 00:15:21.730
that your application has on the entire system as a whole.

00:15:21.730 --> 00:15:27.390
So your application is not terminated, it moves into
the suspended state where it reduces your system use,

00:15:27.390 --> 00:15:30.580
resource usage and remains in the background.

00:15:30.580 --> 00:15:36.610
And this is the one which we'll talk about a
lot more with regards to fast app switching.

00:15:36.610 --> 00:15:42.680
So, let's say the user there had
the Maps app was in the front

00:15:42.680 --> 00:15:46.370
and now they hit the Home button in iOS 4, to dismiss that.

00:15:46.370 --> 00:15:50.080
So unlike iOS 3, they're not terminating the
application anymore, what are they doing?

00:15:50.080 --> 00:15:54.660
Well instead the application moves into the background.

00:15:54.660 --> 00:16:00.640
Now all applications will be in the background running
state, even if it's temporary and we're going to talk

00:16:00.640 --> 00:16:06.760
about more of this in a minute, and from the background
running state the system may move your application

00:16:06.760 --> 00:16:12.000
into the background suspended state.

00:16:12.000 --> 00:16:17.500
Now, here's a difference, another
difference from the iPhone OS 3 lifecycle,

00:16:17.500 --> 00:16:21.060
whereas before when your application
would terminate from either the active

00:16:21.060 --> 00:16:23.800
or the inactive state and move into the not running state.

00:16:23.800 --> 00:16:28.580
In iOS 4, your application moves into the not running state,

00:16:28.580 --> 00:16:32.130
from either the background running
or the background suspended states.

00:16:32.130 --> 00:16:37.290
And we're going to talk in more detail
in just a minute about how that happens.

00:16:37.290 --> 00:16:43.360
OK, so what we just described is, the user is
interacting with the phone, they're launching,

00:16:43.360 --> 00:16:46.020
they're using multitasking UI,
they're returning to SpringBoard

00:16:46.020 --> 00:16:50.600
and we saw how those user actions effected your application.

00:16:50.600 --> 00:16:53.100
How it moved it through its lifecycle.

00:16:53.100 --> 00:16:57.920
Well, so but as the application developer, how are you
going to be aware of these lifecycle changes and respond

00:16:57.920 --> 00:17:01.080
to these lifecycle changes and take
the necessary actions that you need to?

00:17:01.080 --> 00:17:06.640
Well just like an iPhone OS 3, we have UI
application delegate callbacks and notifications,

00:17:06.640 --> 00:17:11.110
which are used to inform your application
of these transitions.

00:17:11.110 --> 00:17:14.280
So let's walk through them and
we'll start with the familiar ones.

00:17:14.280 --> 00:17:18.990
Again which are more or less identical
to what you have in iPhone OS 3.

00:17:18.990 --> 00:17:20.340
So you're in the not running state again.

00:17:20.340 --> 00:17:22.520
We're going to use Maps as our example again.

00:17:22.520 --> 00:17:25.480
The user launches it and what happens?

00:17:25.480 --> 00:17:32.850
Your application receives, the application did
finish launching with options, delegate callback,

00:17:32.850 --> 00:17:35.800
as an indication that the application is being launched.

00:17:35.800 --> 00:17:39.530
Transitions briefly into the inactive state.

00:17:39.530 --> 00:17:45.500
Continues the launching process, your application
will receive, application did become active.

00:17:45.500 --> 00:17:53.670
At which time now it is transitioned completely into
the active state of the foreground active running task.

00:17:53.670 --> 00:17:58.440
Let's say again that some interruption occurs like
the multitasking UI or something else that causes it

00:17:58.440 --> 00:18:03.030
to transition into the inactive state and of course
you'll receive, just like today, you'll receive,

00:18:03.030 --> 00:18:05.740
the application will resign active callback.

00:18:05.740 --> 00:18:10.680
OK, so that's all very familiar to
us, let's look at something new.

00:18:10.680 --> 00:18:17.090
So again, here's your application Maps that's
running in the foreground, user hits the Home button.

00:18:17.090 --> 00:18:22.980
So you're in the active state, they hit
the Home button, the application now moves

00:18:22.980 --> 00:18:25.470
through into the inactive state again temporarily.

00:18:25.470 --> 00:18:29.740
You get, your application will resign
active callback, followed by a new callback,

00:18:29.740 --> 00:18:34.470
new for iOS 4, called applicationDidEnterBackground.

00:18:34.470 --> 00:18:39.650
This is an important callback, as you
can see from our lifecycle diagram.

00:18:39.650 --> 00:18:44.720
This is the indication to your application that it's
moving from a foreground state into the background.

00:18:44.720 --> 00:18:49.870
Now we're going to talk, we're going to talk about
responsibilities and best practices here in a few minutes,

00:18:49.870 --> 00:18:53.970
you're going to see that this is a very
important point in your application's lifecycle.

00:18:53.970 --> 00:19:00.890
This is the point where you would save application state for
example, try to reduce your memory usage and other things,

00:19:00.890 --> 00:19:04.410
other responsibilities which we're
going to talk about later.

00:19:04.410 --> 00:19:11.130
So now, as I said, your application after it's moved
into the background running state and depending

00:19:11.130 --> 00:19:16.020
on which services your application benefits from,
it could remain in this background running state.

00:19:16.020 --> 00:19:22.180
However, for a fast app switching application, the
transition is going to continue and the system is going

00:19:22.180 --> 00:19:24.460
to move it into the background suspended state.

00:19:24.460 --> 00:19:26.630
Now this box is empty.

00:19:26.630 --> 00:19:31.600
This is a very important point of your application's
lifecycle is that your application and the user

00:19:31.600 --> 00:19:35.570
for that matter, is not going to have any
indication of when the application transitioned

00:19:35.570 --> 00:19:39.660
from the background running state
into the background suspended state.

00:19:39.660 --> 00:19:45.580
And the implications of this, there's going to be
implications of this about when you need to reduce memory,

00:19:45.580 --> 00:19:50.660
when you need to save your state, which again we're
going to talk about in the responsibilities section.

00:19:50.660 --> 00:19:52.070
So let's do the other way around here.

00:19:52.070 --> 00:19:56.460
If your application is, it's running,
so it was launched earlier.

00:19:56.460 --> 00:20:03.060
It's in the background in the suspended state and now
the user reselects the icon or selects it from the,

00:20:03.060 --> 00:20:07.920
from SpringBoard or from the multitasking
UI, basically launches it again, resumes it,

00:20:07.920 --> 00:20:11.440
we have kind of the reverse set of steps.

00:20:11.440 --> 00:20:16.160
Again, the system is going to first move your
application into the background running state.

00:20:16.160 --> 00:20:19.820
There's not going to be any indication to
you or to the user that this is happening.

00:20:19.820 --> 00:20:22.100
You as the application developer, your application.

00:20:22.100 --> 00:20:25.560
You're going to receive a new, another
new ApplicationDelegate callback,

00:20:25.560 --> 00:20:30.730
applicationWillEnterForeground, again a very important
callback, because this is the indication to your application

00:20:30.730 --> 00:20:35.940
that the, that the app itself is transitioning
from the background into the foreground.

00:20:35.940 --> 00:20:43.910
Briefly through the inactive state and then back into
the active state with applicationDidBecomeActive.

00:20:46.930 --> 00:20:51.540
So then we saw how we transitioned,
the normal transitions for launching.

00:20:51.540 --> 00:20:55.580
We saw the transitions into the
foreground, into the background.

00:20:55.580 --> 00:20:58.010
So what about termination?

00:20:58.010 --> 00:21:03.100
The user doesn't terminate your application every
time they hit the Home button anymore, obviously.

00:21:03.100 --> 00:21:08.580
So what, but there is still a not running state in iOS 4.

00:21:08.580 --> 00:21:10.810
Your applications don't run indefinitely.

00:21:10.810 --> 00:21:19.490
So, one way that the user or the way that the user can
move your application from the background running state

00:21:19.490 --> 00:21:24.110
into the suspended state or into the not
running state, is through the multitasking UI.

00:21:24.110 --> 00:21:28.700
So in this case let's assume that we have iPod
actually running and playing audio at this point.

00:21:28.700 --> 00:21:31.960
So it's actually in the background running state.

00:21:31.960 --> 00:21:34.780
Using the background audio service to play its audio.

00:21:34.780 --> 00:21:43.330
And the user uses the little minus
sign there to stop, to terminate iPod.

00:21:43.330 --> 00:21:49.400
Well the transition into the not running state
and this delegate callback you're familiar with,

00:21:49.400 --> 00:21:52.460
this is the applicationWillTerminateDelegate
callback that you had today,

00:21:52.460 --> 00:21:54.720
it's just occurring at a different point in the lifecycle.

00:21:54.720 --> 00:21:59.410
Well let's look at another background state.

00:21:59.410 --> 00:22:00.850
So we also have Maps down here.

00:22:00.850 --> 00:22:05.220
Now Maps, Maps does not have any benefit from running
in the background, so it actually is suspended

00:22:05.220 --> 00:22:07.380
by the system when it's in the background.

00:22:07.380 --> 00:22:09.390
So it's sitting there in the background suspended state.

00:22:09.390 --> 00:22:14.430
But what if the user you know,
closes it now with the minus sign?

00:22:14.430 --> 00:22:21.340
Well here's another case of that, the system will transition
Maps into the not running state, it will terminate Maps,

00:22:21.340 --> 00:22:25.790
but there's not going to be any indication
to Maps that it just got terminated.

00:22:25.790 --> 00:22:31.430
So again, this has implications in that once
your application enters the suspended state,

00:22:31.430 --> 00:22:37.000
it had better have done all the cleanup, all the
saving, all the bookkeeping that it needs to have done.

00:22:37.000 --> 00:22:41.130
Because once it's entered the suspended state,
it can be moved into the not running state,

00:22:41.130 --> 00:22:44.290
without ever getting the chance to execute any code again.

00:22:44.290 --> 00:22:48.380
So that's a very important principle that's going to
guide some of our best practices and responsibilities.

00:22:48.380 --> 00:22:52.890
Now as I mentioned, this is a little bit of an eye chart.

00:22:52.890 --> 00:22:58.330
But you have these UI applicationDelegate callbacks,
along with each one there's a corresponding notification

00:22:58.330 --> 00:23:04.170
and so for the two new delegate callbacks, we've
added two new notifications for the foreground

00:23:04.170 --> 00:23:07.540
and background transitions and you can
look these up in the documentation.

00:23:07.540 --> 00:23:12.330
The way that you use these notifications
is identical to how you did in iPhone OS 3.

00:23:12.330 --> 00:23:18.250
OK, so I've eluded a lot to responsibilities
and best practices and so,

00:23:18.250 --> 00:23:22.040
we're going to start talking about those now.

00:23:22.040 --> 00:23:26.860
It's important to keep in mind that a lot of these are
phrased, although we're focusing on fast app switching

00:23:26.860 --> 00:23:31.140
in this talk, with the lifecycle I just
talked about and all these responsibilities

00:23:31.140 --> 00:23:35.690
and best practices, apply to all multitasking applications.

00:23:35.690 --> 00:23:41.060
Now there might be slight variations that we'll talk
about, so if your background audio app or a VoIP app,

00:23:41.060 --> 00:23:46.040
that the second talk will cover any
exceptions or details that you need to know.

00:23:46.040 --> 00:23:51.870
But in general, what we're going to talk about here applies
to all multitasking apps, not just fast app switching.

00:23:51.870 --> 00:23:57.550
So, before we get to the details, let's talk
a little about system resource management.

00:23:57.550 --> 00:24:05.620
So, of course a big goal at Apple, with our
multitasking implementation and as Dave eluded to before,

00:24:05.620 --> 00:24:10.610
we think that a kind of general purpose
concurrency, general purpose background execution,

00:24:10.610 --> 00:24:15.760
that's not appropriate for these type of mobile devices.

00:24:15.760 --> 00:24:18.490
Because we really want to do two things.

00:24:18.490 --> 00:24:23.790
We want to preserve battery life, obviously and
you know, in the keynote there was a great quote

00:24:23.790 --> 00:24:29.300
from Sergei, I think, about how
just having these background tasks running wild,

00:24:29.300 --> 00:24:35.690
running free in the background, that's not
good for the battery and we agree 100%.

00:24:35.690 --> 00:24:41.370
The other big thing is those background, free running
kind of background tasks, Wild West background tasks,

00:24:41.370 --> 00:24:45.480
it's not good for the device's usability.

00:24:45.480 --> 00:24:46.310
Its responsiveness.

00:24:46.310 --> 00:24:53.570
And so those are our two goals with some of these
responsibilities and best practices and indeed,

00:24:53.570 --> 00:24:56.640
the general design of the multitasking as a whole.

00:24:56.640 --> 00:25:01.660
And of course the system resources are
shared by all the apps and that goes

00:25:01.660 --> 00:25:06.650
without saying and there are limited resources.

00:25:06.650 --> 00:25:11.400
And so, you should really try, when you're thinking
about your app that's running in the background

00:25:11.400 --> 00:25:18.280
or even if it's going to be suspended in the background,
you need to think about minimizing your resource usage.

00:25:18.280 --> 00:25:22.740
And we're going to give you some best practices and point
out some places where you can, you can help out with that.

00:25:22.740 --> 00:25:28.730
And this is not completely something that
oh, we want you to do this for the system.

00:25:28.730 --> 00:25:35.430
You'll see how that by doing these best practices and
adopting and taking these responsibilities seriously,

00:25:35.430 --> 00:25:40.620
you'll make your application work better
in this whole multitasking environment.

00:25:40.620 --> 00:25:45.930
You'll, it can be a differentiating factor when people
use your application, they'll notice that oh, when I come,

00:25:45.930 --> 00:25:50.270
his application whenever I go back
to it, it's right where I left it.

00:25:50.270 --> 00:25:53.740
And we'll see how you can do that.

00:25:53.740 --> 00:25:54.810
So here's an outline of the thing.

00:25:54.810 --> 00:25:57.260
So I've kind of grouped them into two categories.

00:25:57.260 --> 00:26:00.660
Some responsibilities and best practices
for when your application is making

00:26:00.660 --> 00:26:03.780
that transition from the foreground into the background.

00:26:03.780 --> 00:26:05.170
And we'll go through these in detail.

00:26:05.170 --> 00:26:11.720
And then there's a kind of corresponding set, shorter
but, when your application, it's been in the background

00:26:11.720 --> 00:26:13.460
and now the user is bringing it to the foreground again,

00:26:13.460 --> 00:26:16.320
there is some things that you need
to take care of and be aware of.

00:26:16.320 --> 00:26:17.050
So let's start here.

00:26:17.050 --> 00:26:22.340
We'll start with a big one, which
is saving application state.

00:26:23.790 --> 00:26:35.690
So, I mentioned earlier that it's important, that once
your application enters the background and it moves

00:26:35.690 --> 00:26:41.890
into the suspended state, your application
isn't necessarily going to get another chance

00:26:41.890 --> 00:26:44.780
to execute any code before it can be terminated.

00:26:44.780 --> 00:26:49.280
And so you know, a big implication of that is that
when your application goes through that transition

00:26:49.280 --> 00:26:55.760
into the background, as indicated by the callback or the
notification, you need to save your application state.

00:26:55.760 --> 00:27:00.030
Because if your application is terminated,
whatever you saved at that last transition there,

00:27:00.030 --> 00:27:04.370
that's what you're going to you know, your app's going to
have when it starts back up again, when it's relaunched.

00:27:04.370 --> 00:27:06.750
But that might not be sufficient.

00:27:06.750 --> 00:27:14.080
As with all these UI applicationDelegate callbacks and this
is true in iPhone OS 3 as well and it continues to be true

00:27:14.080 --> 00:27:19.590
in iOS 4, there's a limited amount of time that your
application can spend in those delegate callbacks.

00:27:19.590 --> 00:27:21.350
A few seconds.

00:27:21.350 --> 00:27:28.000
And so if you have such a large amount of application state
or other work that would need to be done on this transition

00:27:28.000 --> 00:27:32.090
into the background, you know you might not have
time to always save all your state in that time

00:27:32.090 --> 00:27:35.750
and that would be a lot of state, but it's something
you need to be aware of and so you might need

00:27:35.750 --> 00:27:38.280
to adopt some other state saving strategies as well.

00:27:38.280 --> 00:27:43.200
Save part of your state incrementally
or you know, as you go along.

00:27:43.200 --> 00:27:46.760
This makes a lot of sense, especially in
something like a turn-by-turn game for example.

00:27:46.760 --> 00:27:52.120
It's very natural to save your state
at check points or levels and what not.

00:27:52.120 --> 00:27:55.730
OK so that's one responsibility.

00:27:55.730 --> 00:27:59.510
Another one is reduced memory usage.

00:27:59.510 --> 00:28:01.780
This is also a very important one.

00:28:01.780 --> 00:28:02.620
Let's get into this.

00:28:02.620 --> 00:28:11.340
So system memory, it's a limited resource on these devices.

00:28:11.340 --> 00:28:18.200
And so as such, the system, when
it needs more system memory,

00:28:18.200 --> 00:28:23.720
the way it frees up more system memory
is by terminating an application.

00:28:23.720 --> 00:28:30.810
So as I showed in those lifecycle diagrams earlier
on, there were transitions from background running

00:28:30.810 --> 00:28:36.240
and background suspended into the not running state
and one way to get those transitions to occur is

00:28:36.240 --> 00:28:38.420
from the user's action as I showed in the multitasking UI.

00:28:38.420 --> 00:28:44.810
Of course another way those transitions can occur
is that the system needs to free up some memory.

00:28:44.810 --> 00:28:49.330
The user is launching a new app that they hadn't,
that hadn't been launched, memory is all used up.

00:28:49.330 --> 00:28:55.930
Well, you know, this new app's going to need some memory
and so the system it prioritizes how it goes about deciding

00:28:55.930 --> 00:29:03.490
which app will be terminated to free up the system
memory needed for by say this newly launched app.

00:29:03.490 --> 00:29:05.800
And roughly the prioritization goes something like this.

00:29:05.800 --> 00:29:10.670
We have, again we have some apps that are in the
background suspended and some in the background running.

00:29:10.670 --> 00:29:15.650
Let's roughly categorize those apps into ones that
are using a lot of memory, a lot of memory usage

00:29:15.650 --> 00:29:18.380
and some that are using you know, a small amount of memory.

00:29:18.380 --> 00:29:25.160
And the system is going to greatly prefer to
terminate the high memory using applications.

00:29:25.160 --> 00:29:32.050
The other point to make here is that this memory,
termination due to a low memory condition,

00:29:32.050 --> 00:29:36.720
this is the normal state of the device in iOS 4.

00:29:36.720 --> 00:29:40.350
When users leave an app and go into another app,
the app they just left, it's still there in memory.

00:29:40.350 --> 00:29:46.270
Now they go to the next app, the next, you know, four,
five, six, ten, all those apps are going to remain in memory

00:29:46.270 --> 00:29:52.390
until the system memory resource is exhausted
and the system is required to terminate one.

00:29:52.390 --> 00:29:56.330
So, it's an important point that it's a normal condition.

00:29:56.330 --> 00:30:02.160
So, now we see that, so your application can be
terminated because of this low memory condition.

00:30:02.160 --> 00:30:09.220
So of course, using less memory from a system point of view,
from a usability point of view, from a user happiness point

00:30:09.220 --> 00:30:14.590
of view, if all the apps together are doing their best
to use less memory, well the user is going to be able

00:30:14.590 --> 00:30:20.270
to have basically a greater working set of
apps that can stay resident on the device,

00:30:20.270 --> 00:30:23.990
before the system needs to do any of these terminations.

00:30:23.990 --> 00:30:30.420
So, you can think about in your own usage, what's
your working set of apps and wouldn't it be great

00:30:30.420 --> 00:30:35.210
if the large working set you know, when I
go back to it, it's right where I left it.

00:30:35.210 --> 00:30:38.850
It's been resident in memory you
know, for hours, for days, for weeks.

00:30:38.850 --> 00:30:46.570
Now here's the part though, this is again, it's not just
kind of a touchy feely kind of oh we whatever system thing,

00:30:46.570 --> 00:30:49.600
it's very important for your individual
app to do this as well.

00:30:49.600 --> 00:30:56.270
Because of that prioritization we saw about apps that
use a lot of memory are much more likely to be chosen

00:30:56.270 --> 00:31:03.510
for termination than the ones that use low memory, it's in
the interest of your app to reduce its memory usage as much

00:31:03.510 --> 00:31:08.210
as possible when it's in the background, so
that the system decides not to pick your app.

00:31:08.210 --> 00:31:13.720
And again this comes back to if your app is terminated,
the next time the user goes back to it, well it relaunches

00:31:13.720 --> 00:31:17.960
and depending on how good a job you've done about saving
state you know, maybe you just take them right back

00:31:17.960 --> 00:31:21.820
to the home screen, maybe you kind of navigate
them down to the appropriate point in the UI

00:31:21.820 --> 00:31:25.190
or back to the beginning of the
level they were on or whatever.

00:31:25.190 --> 00:31:27.360
But in any, it would still have to relaunch.

00:31:27.360 --> 00:31:30.740
And as opposed to an app that didn't get terminated,

00:31:30.740 --> 00:31:33.150
when they go back to it it's going
to be exactly where they left it.

00:31:33.150 --> 00:31:37.530
It's going to resume very quickly and it's
going to be exactly where the user left it.

00:31:37.530 --> 00:31:39.700
And so you want your app to be in that latter category.

00:31:39.700 --> 00:31:46.900
You want the you know, you want it to be the last app on
the system that gets terminated, when the system is looking

00:31:46.900 --> 00:31:55.140
for an app to terminate for a low memory condition,
you want your app to be the one it chooses last.

00:31:55.140 --> 00:32:01.770
And again, because as we saw in the
priorities, the prioritization is only for apps

00:32:01.770 --> 00:32:03.890
that are in the background will get terminated.

00:32:03.890 --> 00:32:07.200
You know, you need to take care of the stuff we're
going to talk about, about reducing your memory,

00:32:07.200 --> 00:32:10.170
you need to take care of that while your
application is entering the background,

00:32:10.170 --> 00:32:13.820
which is in the applicationDidEnterBackground callback.

00:32:13.820 --> 00:32:17.000
Now we have a great tool in Instruments.

00:32:17.000 --> 00:32:20.370
You might have used Instruments for many things before.

00:32:20.370 --> 00:32:25.100
It's a great tool for doing a lot of performance type work.

00:32:25.100 --> 00:32:28.250
And you can use it also, there's
this tool, this VM Tracker tool,

00:32:28.250 --> 00:32:34.210
which you can use to help you first off determine how
much memory you're using when you're in the background

00:32:34.210 --> 00:32:38.920
and then as you're working to reduce it, you can you
know, use this tool kind of to measure your progress.

00:32:38.920 --> 00:32:46.090
What you're interested in and I've circled
in yellow here, there's a row marked dirty,

00:32:46.090 --> 00:32:47.690
then over on the right there's a dirty size.

00:32:47.690 --> 00:32:55.190
In this case it's 6.04MB and that's the number, this
is the dirty memory, so this is basically the number

00:32:55.190 --> 00:32:59.640
that the system is going to use, when it's looking
at your app, this is the one that's going to say oh,

00:32:59.640 --> 00:33:03.750
he's using that much memory and that's what
it's going to use to prioritize your app.

00:33:03.750 --> 00:33:09.520
So, again your goal would be, when you're trying
to reduce your memory usage in the background,

00:33:09.520 --> 00:33:11.870
is to drive that number down as low as you can.

00:33:11.870 --> 00:33:14.050
But there are some trade-offs which
I'll talk about with that

00:33:14.050 --> 00:33:17.870
and let's talk a little bit more
generally first about app memory usage.

00:33:17.870 --> 00:33:20.140
This is to say, this is the journal
app which I showed earlier.

00:33:20.140 --> 00:33:21.670
It could be any application.

00:33:21.670 --> 00:33:25.560
Let's just talk generally about
you know, memory usage in an app.

00:33:25.560 --> 00:33:26.650
Well you have some App State.

00:33:26.650 --> 00:33:27.830
This is app specific state.

00:33:27.830 --> 00:33:32.430
You know in the journal it was
images that were those photos,

00:33:32.430 --> 00:33:35.630
the entries themselves, the text
and the titles and what not.

00:33:35.630 --> 00:33:43.130
You know and those are probably backed by some kind of
store on disk store, that could be, could be using SQLite

00:33:43.130 --> 00:33:49.710
or Core Data, you know there's cache or you might have
you know, flat, I'm just going to call it flat file.

00:33:49.710 --> 00:33:53.900
Your own custom file format that
you're using to save this data.

00:33:53.900 --> 00:33:56.070
Whatever it is, you have some kind of backing store.

00:33:56.070 --> 00:34:01.350
Now for your UI, you have views and
layers and those are backed by a store.

00:34:01.350 --> 00:34:04.990
The system in order to render those
graphic, render the UI correctly,

00:34:04.990 --> 00:34:08.690
it has its own backing store which
it maintains for your views.

00:34:08.690 --> 00:34:12.230
And finally you have some kind of controllers,
view controllers, maybe other kinds of controllers,

00:34:12.230 --> 00:34:15.670
which kind of ties it altogether,
ties your model together with your UI.

00:34:15.670 --> 00:34:20.420
So that's just kind of an abstract
look at memory usage by an application.

00:34:20.420 --> 00:34:24.970
Well, when your application is making
this transition into the background,

00:34:24.970 --> 00:34:27.280
the system is going to do some things for you.

00:34:27.280 --> 00:34:30.950
You know, because we want to really help you
out, again it's beneficial to the entire system,

00:34:30.950 --> 00:34:37.640
it's beneficial to your app, the usability of your app,
the happiness of our users, so the system is going to try

00:34:37.640 --> 00:34:40.840
to do what it can for you and it can do some things.

00:34:40.840 --> 00:34:45.890
So the system is kind of maintaining this backing graphic
store for you and once you move into the background,

00:34:45.890 --> 00:34:50.220
you're not going to have, your UI is not going to be
displayed anymore, so the system is going to go ahead

00:34:50.220 --> 00:34:53.970
and free that up for you and that
actually saves quite a bit of memory.

00:34:53.970 --> 00:35:00.140
If you have views that are not visible, off screen
or whatever, we're going to free those up as well.

00:35:00.140 --> 00:35:00.930
That'll save a little bit.

00:35:00.930 --> 00:35:10.680
And if you're using the image named cache, the APIs to
manage your images, we're going to flush that as well.

00:35:10.680 --> 00:35:14.630
Although there is still a responsibility, you
have to release those images that you are using

00:35:14.630 --> 00:35:17.130
from the image named cache, which
we'll talk about in a second.

00:35:17.130 --> 00:35:23.470
You know, if you're using SQLite or Core Data, NSCache,

00:35:23.470 --> 00:35:28.530
the way those frameworks are implemented
is efficient in its uses of memory.

00:35:28.530 --> 00:35:35.440
They have some caching and so as much as we
can, the system is going to flush those caches,

00:35:35.440 --> 00:35:40.440
move that data out of memory and
so free up as much as it can.

00:35:40.440 --> 00:35:45.910
That being said, so the system can do some
things for you, it can't do everything of course,

00:35:45.910 --> 00:35:50.190
so there's going to be some things that
your app is going to need to do for itself.

00:35:50.190 --> 00:35:51.530
As I mentioned earlier, release images.

00:35:51.530 --> 00:36:00.190
Whether you're using image named APIs or other
image APIs, images can take a large amount of memory

00:36:00.190 --> 00:36:03.900
and so it's important, in most cases, in almost all cases,

00:36:03.900 --> 00:36:06.560
for you to release your images when
you're going into the background.

00:36:06.560 --> 00:36:14.130
Now if you have your own caches, not necessarily the SQLite
or Core Data caches that are maintaining on your behalf,

00:36:14.130 --> 00:36:20.550
if you cache some stuff yourself, from your own
file, it's good to flush these caches and again,

00:36:20.550 --> 00:36:25.770
there's a little bit of a trade-off here in that you
know, if your caches are very expensive to create

00:36:25.770 --> 00:36:31.950
and the reason you have those caches is because they're
very expensive and you don't and if you flush them,

00:36:31.950 --> 00:36:36.530
then when the app comes back to the foreground,
you're going to have to regenerate them all again.

00:36:36.530 --> 00:36:37.790
Well so here's the trade-off you know.

00:36:37.790 --> 00:36:41.300
How much memory are you going to save versus
how long is it going to take on resume

00:36:41.300 --> 00:36:44.630
to regenerate this data and that's,
that's an app by app call.

00:36:44.630 --> 00:36:46.580
But it's something you should at least consider.

00:36:46.580 --> 00:36:52.340
And the other things is, for this flat
file, if your backing store is a flat file,

00:36:52.340 --> 00:36:58.460
not using some of these other technologies, you should
consider instead of saying f open it or opening it

00:36:58.460 --> 00:37:04.150
and reading the whole thing into your, into your
app's address space and using it and you know,

00:37:04.150 --> 00:37:07.340
when you modify things or save
state you write the whole thing out.

00:37:07.340 --> 00:37:15.510
That can be much less efficient than using some of the
memory mapping technologies through the mmap family of APIs.

00:37:15.510 --> 00:37:22.580
So especially if you're doing a lot of read
only access, but even if you're writing,

00:37:22.580 --> 00:37:27.790
the system can be much more intelligent about which
parts of your flat file are moved into memory,

00:37:27.790 --> 00:37:33.620
it can move some parts you know, back out of memory as
necessary, without requiring termination of your app.

00:37:33.620 --> 00:37:40.140
So again, something to consider if using a custom file
format as your backing store for your application state,

00:37:40.140 --> 00:37:44.330
you know to consider if memory
mapping would be appropriate for that.

00:37:44.330 --> 00:37:47.540
Because there are some benefits that
the system can provide for that.

00:37:47.540 --> 00:37:56.920
So I mentioned a couple times about
trade-offs and other, so there's trade-offs

00:37:56.920 --> 00:37:59.210
and there's other small memory usages in your application.

00:37:59.210 --> 00:38:02.430
So a trade-off, we haven't mentioned view controllers yet.

00:38:02.430 --> 00:38:05.290
Now view controllers are typically
not that large in memory usage.

00:38:05.290 --> 00:38:07.690
I mean often you hang a lot of
things off the view controller,

00:38:07.690 --> 00:38:10.770
some of your model data and some
other data that can be large.

00:38:10.770 --> 00:38:12.270
That we just talked about.

00:38:12.270 --> 00:38:14.810
View controllers themselves are typically not that large.

00:38:14.810 --> 00:38:17.070
So you typically don't want to
release your view controllers.

00:38:17.070 --> 00:38:22.250
If for no other reason than it can be kind of tricky
to maybe reconstruct them correctly and everything.

00:38:22.250 --> 00:38:24.530
So typically you wouldn't need to release those.

00:38:24.530 --> 00:38:31.130
And you might have some other state in your app, where
there's a trade-off versus, that I mentioned earlier

00:38:31.130 --> 00:38:33.500
about memory savings versus time to recreate.

00:38:33.500 --> 00:38:46.450
And for this trade-off, for those things,
unfortunately we can't give you a 100% correct answer

00:38:46.450 --> 00:38:51.360
of what you should do there, although we're going to have
some suggestions in just a few minutes for some technique

00:38:51.360 --> 00:38:53.810
that might work, that might help you in a few cases.

00:38:53.810 --> 00:38:57.530
But before we get to that, I wanted
to talk about preparing your UI.

00:38:57.530 --> 00:39:01.800
So this is another responsibility you
have when you're entering the background.

00:39:01.800 --> 00:39:07.990
So, so again, you're going into the background,
your UI is not going to visible anymore,

00:39:07.990 --> 00:39:10.970
so what things do you need to do to prepare your app?

00:39:10.970 --> 00:39:16.310
Well you might want to pause your app and even
today, you do this if you have a game especially.

00:39:16.310 --> 00:39:20.140
It makes sense if the SMS comes
in or an incoming call you know,

00:39:20.140 --> 00:39:24.780
it's very polite to the user, to pause your application.

00:39:24.780 --> 00:39:31.130
And you typically do this in the applicationDidResignActive
callback and this continues in IOS 4 you still want to,

00:39:31.130 --> 00:39:37.000
if you use alerts and action sheets in your app
and your app is and the user hits the Home button

00:39:37.000 --> 00:39:42.310
to send your application to the background,
if one of those action sheets or alerts is up,

00:39:42.310 --> 00:39:47.030
you need to think about whether it makes sense to
leave it up or to kind of cancel it and take it down.

00:39:47.030 --> 00:39:51.940
So say in my journal app, I had a way for you
to delete an entry and when you said Delete,

00:39:51.940 --> 00:39:57.430
I pop up an action sheet and you
know say, are you sure, yes, no.

00:39:57.430 --> 00:40:05.130
Well, if the user did that and then left the app, hit the
Home button and came back a week later and the app popped up

00:40:05.130 --> 00:40:10.470
and all he saw was this dialog which said are you sure,
yes, no and that wouldn't be the best user experience.

00:40:10.470 --> 00:40:15.030
I mean the worse case they could actually oh, yes I'm
sure and then they delete something they don't know.

00:40:15.030 --> 00:40:19.880
So in that case it would make sense probably for
that app to, when you're entering the background,

00:40:19.880 --> 00:40:23.080
to just dismiss that programmatically,
as if they had hit no.

00:40:23.080 --> 00:40:26.730
And when they come back to the app, if they
have to reselect the entry and hit Delete again,

00:40:26.730 --> 00:40:29.690
that's a much better user experience
than just having this alert box.

00:40:29.690 --> 00:40:31.570
So that's something to keep aware of.

00:40:31.570 --> 00:40:35.250
And finally, the system is going to
automatically take a screenshot of your app.

00:40:35.250 --> 00:40:41.390
When your application returns from
applicationDidEnterBackground,

00:40:41.390 --> 00:40:47.360
the system is going to take a screenshot and it's going to
use that screenshot when it's animating back into your app.

00:40:47.360 --> 00:40:52.040
And so if you have sensitive information on
there or some kind of animations or something,

00:40:52.040 --> 00:40:57.340
some kind of UI that you don't want to be visible
during that animation, then this is your chance

00:40:57.340 --> 00:41:03.280
and this is the time to update
your UI so it doesn't show that.

00:41:03.280 --> 00:41:10.790
OK, now there's three responsibilities which I have grouped
together, which we'll go through now about networking

00:41:10.790 --> 00:41:13.730
in Bonjour and some other system resources.

00:41:13.730 --> 00:41:19.110
So if you're using listening sockets in your app, so you're
opening up a listening socket system, external server

00:41:19.110 --> 00:41:25.020
or another device can connect to your application,
to get access maybe to some service you're providing,

00:41:25.020 --> 00:41:32.480
well you have to be aware that if your application is
you know, in the suspended state in the background,

00:41:32.480 --> 00:41:34.860
it's not going to be able to respond
to those connection attempts.

00:41:34.860 --> 00:41:38.320
So you know, this external server or whatever
might connect, might try to communicate

00:41:38.320 --> 00:41:41.230
with your application, well your app can't communicate.

00:41:41.230 --> 00:41:42.910
And so that's a bad user experience.

00:41:42.910 --> 00:41:48.330
Who knows what the server is going to do when
it gets to this situation and so it's best just

00:41:48.330 --> 00:41:53.970
to close those listening sockets as your
application, before your application is suspended.

00:41:53.970 --> 00:41:56.080
And if you're a fast app switching application,

00:41:56.080 --> 00:42:01.940
again your last chance before your application is
suspended is when you're entering the background.

00:42:01.940 --> 00:42:06.890
And of course, then if you, when the
user brings your application back

00:42:06.890 --> 00:42:11.330
to the foreground, you can restore that listening socket.

00:42:11.330 --> 00:42:13.360
Re-open it.

00:42:13.360 --> 00:42:19.690
Now Bonjour, if your application is using Bonjour,
to either advertise a service or to browse

00:42:19.690 --> 00:42:23.650
for a service, so there are two things with Bonjour.

00:42:23.650 --> 00:42:26.060
One is the first is similar to the listening sockets.

00:42:26.060 --> 00:42:32.800
If you're advertising a service and then your
app is suspended and someone, some you know,

00:42:32.800 --> 00:42:37.390
someone external sees oh, this device is
advertising a service, I'm going to connect to it

00:42:37.390 --> 00:42:39.430
and try to you know, connect to that service.

00:42:39.430 --> 00:42:45.260
Well, they make the connection, but they're not going
to be able to communicate with your application.

00:42:45.260 --> 00:42:51.130
And so that's a bad user experience and what's more,
especially in the case of browsing for a service,

00:42:51.130 --> 00:42:54.190
if you leave your application browsing
for a service when it's suspended,

00:42:54.190 --> 00:42:59.420
that's going to be using a lot of
power on the device, for no benefit.

00:42:59.420 --> 00:43:04.090
Because since your application is
suspended, even if it discovers some service

00:43:04.090 --> 00:43:05.880
out there, it can't take advantage of that.

00:43:05.880 --> 00:43:07.620
It's not allowed to execute any code.

00:43:07.620 --> 00:43:14.850
And so because of these two usability and battery
life problems with Bonjour and suspended apps,

00:43:14.850 --> 00:43:24.100
the system can choose to cancel those Bonjour, either
your publish or your browse, while the app is suspended.

00:43:24.100 --> 00:43:27.660
And so what does that mean for you if you're using Bonjour?

00:43:27.660 --> 00:43:32.560
Well, when your app resumes, you need
to be prepared for errors on Bonjour,

00:43:32.560 --> 00:43:37.640
because those operations might have been
canceled by the system while it was suspended.

00:43:37.640 --> 00:43:41.660
And that may mean you need to restart your
Bonjour, you might need to update the UI,

00:43:41.660 --> 00:43:47.970
if you were showing something Bonjour related in your UI,
now you might need to update that as part of your resume.

00:43:47.970 --> 00:43:48.810
You'll see there's a reference.

00:43:48.810 --> 00:43:54.030
There's a couple talks for networking in Bonjour, that
we have references to at the end of the presentation

00:43:54.030 --> 00:44:00.260
that they're going to talk more about these interactions
between multitasking and networking in Bonjour.

00:44:00.260 --> 00:44:04.820
OK, so another big one, another big thing you need to
be aware of when your application is in the background,

00:44:04.820 --> 00:44:09.190
either background running or background
suspended is, don't use the GPU.

00:44:09.190 --> 00:44:10.340
So it's off limits.

00:44:10.340 --> 00:44:16.960
So for instance, if you do something like create
an EAGL context or you just issue OpenGL commands,

00:44:16.960 --> 00:44:20.340
the system is going to be required to terminate.

00:44:20.340 --> 00:44:24.660
Is going to terminate your application.

00:44:24.660 --> 00:44:28.260
The GL, the GPU was reserved for the
use of the foreground application.

00:44:28.260 --> 00:44:32.180
Again this is something we did with multitasking to ensure

00:44:32.180 --> 00:44:39.310
that that front application remains
responsible, responsive and usable for the user.

00:44:39.310 --> 00:44:46.860
And again, it's enforced in the background running state
and again, the natural thing, the easiest way to do this

00:44:46.860 --> 00:44:49.360
and the way you should take care of this
is when you're entering the background,

00:44:49.360 --> 00:44:52.390
you're going to need to stop your GPU usage.

00:44:52.390 --> 00:44:56.200
And generally need to stop drawing
altogether, stop using OpenGL altogether.

00:44:56.200 --> 00:45:02.550
And the last of these kind or another of these
little responsibilities is shared system data.

00:45:02.550 --> 00:45:10.420
So this is another case where the system will unfortunately
be required to terminate your application when it's

00:45:10.420 --> 00:45:16.590
in the background, in this case when it's in background
suspended or when it enters background suspended,

00:45:16.590 --> 00:45:20.100
if it's holding exclusive access to some shared system data.

00:45:20.100 --> 00:45:24.020
So what do I mean by shared?

00:45:24.020 --> 00:45:25.190
What's shared system data?

00:45:25.190 --> 00:45:31.360
Well we have a number of APIs that allow you to access
Calendar, Address Book, music and media libraries.

00:45:31.360 --> 00:45:36.660
Those are all, all those APIs are basically
wrapping access to some shared system data.

00:45:36.660 --> 00:45:41.830
You know, your address book, your contacts are
shared, any app on the system can access those.

00:45:41.830 --> 00:45:47.620
And so the system can't allow a suspended app to hold
exclusive access to any of those or else you know,

00:45:47.620 --> 00:45:49.980
some other apps wouldn't be able to use that resource.

00:45:49.980 --> 00:45:55.250
And so it enforces this again, as your
application is entering the suspended state,

00:45:55.250 --> 00:45:57.680
it enforces this by terminating your application.

00:45:57.680 --> 00:45:59.520
And once again, our old friend,

00:45:59.520 --> 00:46:03.750
applicationDidEnterBackground is
the place to take care of this.

00:46:03.750 --> 00:46:06.240
OK, so now let's talk quickly about some on resume.

00:46:06.240 --> 00:46:09.440
When your app comes back to the foreground.

00:46:09.440 --> 00:46:12.010
Well it's kind of the converse of what we talked about.

00:46:12.010 --> 00:46:14.120
The system is going to take care of some things.

00:46:14.120 --> 00:46:18.580
The things that it kind of freed for you or flushed
for you, it's going to restore them for you.

00:46:18.580 --> 00:46:21.440
The backing store, you know, it's going to
recognize that your app is coming to the front,

00:46:21.440 --> 00:46:25.150
you're going to need to draw your UI, it's
going to restore that backing store for you.

00:46:25.150 --> 00:46:32.730
If you're using image named, that cache is going to
repopulate as you create images, as you request images.

00:46:32.730 --> 00:46:37.280
If you're using these other technologies, some of
these other technologies, SQLite, Core Data, NSCache,

00:46:37.280 --> 00:46:41.010
those are restored as needed, on demand,
as necessary the information will be pulled

00:46:41.010 --> 00:46:44.400
from your backing store into your application's memory.

00:46:44.400 --> 00:46:50.380
Same thing if you're using a flat file, but if you're
memory mapping it again, the system as you access that file,

00:46:50.380 --> 00:46:57.000
read and write it, it will move the, it will move the
data as necessary from the backing file into memory.

00:46:57.000 --> 00:46:59.250
So again, those are some things we give you for free.

00:46:59.250 --> 00:47:02.560
Some things you need to do on restore.

00:47:02.560 --> 00:47:06.840
Unfortunately, you know, we can't give you
just oh, here's the right way to do it.

00:47:06.840 --> 00:47:09.560
Always do x, y, z, you'll be fine restoring.

00:47:09.560 --> 00:47:14.040
It's very dependent upon what your application
data is, what your application state looks like.

00:47:14.040 --> 00:47:19.700
So again, it's this trade-off between the memory
size you'll save by freeing up your application state

00:47:19.700 --> 00:47:23.840
and the time it will take when your
application resumes to restore all that.

00:47:23.840 --> 00:47:30.770
But one quick thing we'll show you and many
of you, you know, will be familiar with this,

00:47:30.770 --> 00:47:34.010
is to do what the system was doing
for you in some of those cases.

00:47:34.010 --> 00:47:35.600
So basically, lazy.

00:47:35.600 --> 00:47:37.830
It's a lazy restore of your data.

00:47:37.830 --> 00:47:44.340
If you use a lazy kind of implementation for at least some
of your data, it might not make sense for all your data,

00:47:44.340 --> 00:47:48.560
but for some of your data, this will allow you to
basically release objects when you go into the background

00:47:48.560 --> 00:47:53.060
and free up that memory and then when you resume you
don't have to do anything explicit at resume time like oh,

00:47:53.060 --> 00:47:55.390
I need to regenerate this data and that data and that data.

00:47:55.390 --> 00:47:57.100
I hope I didn't forget anything.

00:47:57.100 --> 00:48:02.490
But just on demand, as that data is needed,
it'll be resumed, you can restore it.

00:48:02.490 --> 00:48:05.960
So here's a very simple example of lazy state restore.

00:48:05.960 --> 00:48:14.240
I have my application state, I'm just, it's an array of
these my data types and when I want to access one of these,

00:48:14.240 --> 00:48:19.520
instead of just indexing directly into the array saying
grabbing it, I use this simple accessor function which,

00:48:19.520 --> 00:48:24.110
first check to see whether it's been initialized,
if it hasn't it goes out to my backing store,

00:48:24.110 --> 00:48:27.660
which I have wrapped with that data
controller here and just initializes my

00:48:27.660 --> 00:48:31.270
in memory representation of that object and returns that.

00:48:31.270 --> 00:48:37.430
So that's done, so now when I want to access
some data, I don't' need to, I just access it.

00:48:37.430 --> 00:48:40.080
The first time I access it, it'll get restored.

00:48:40.080 --> 00:48:45.730
For instance, it's not there and so when I
go into the background, I just, I can release

00:48:45.730 --> 00:48:48.340
and free them all up and free up all that memory.

00:48:48.340 --> 00:48:53.710
And so again, for some of your applications state, this
will make sense and for some it won't and just on a case

00:48:53.710 --> 00:48:56.960
by case basis, it's just another
tool that you can potentially use.

00:48:56.960 --> 00:48:58.520
So system changes.

00:48:58.520 --> 00:49:06.210
So, so when your application is suspended
you know, the whole world doesn't stop.

00:49:06.210 --> 00:49:10.310
Things are going on all around your device.

00:49:10.310 --> 00:49:15.450
The networking is changing you
know, your locale might change,

00:49:15.450 --> 00:49:18.190
other changes might happen, the user might change settings.

00:49:18.190 --> 00:49:23.350
And so when your app, what the system does for you,
while your app is suspended, it's going to collect these,

00:49:23.350 --> 00:49:28.020
it's not going to throw them away so that you're like
unaware, but it's going to collect them and coalesce them.

00:49:28.020 --> 00:49:34.350
Your application is completely suspended so it can't, it
doesn't receive those notifications while it's suspended,

00:49:34.350 --> 00:49:37.200
but when your application resumes all those notifications,

00:49:37.200 --> 00:49:40.440
those system change notifications,
will be delivered to the application.

00:49:40.440 --> 00:49:46.720
And so your application must be prepared to
handle this burst of notifications coming in.

00:49:46.720 --> 00:49:50.330
And so you want to make sure that whatever code
you have that deals with these notifications,

00:49:50.330 --> 00:49:55.490
that it's not going to take too long to execute,
because that could delay the resuming of your app.

00:49:55.490 --> 00:49:57.700
It could make the app seem sluggish when it resumes.

00:49:57.700 --> 00:50:02.940
It can make your UI flash and rapidly update as
it responds to all these notification changes.

00:50:02.940 --> 00:50:08.910
And a great technology, I'm not sure if the talk has already
happened, if it has you can see it on video or check your,

00:50:08.910 --> 00:50:13.600
the schedule, is the Grand Central Dispatch and Blocks Talk.

00:50:13.600 --> 00:50:18.840
That's a great way to move work off the main thread
and it might help you in, to handle this situation.

00:50:18.840 --> 00:50:22.410
And so, this is a little bit of an eye
chart, but these are basically all,

00:50:22.410 --> 00:50:24.140
you can look in the documentation and see all these.

00:50:24.140 --> 00:50:25.310
These are all documents.

00:50:25.310 --> 00:50:28.830
These are basically all the types of
changes that can concur while your system,

00:50:28.830 --> 00:50:31.720
while your app is suspended and
that you'll need to deal with.

00:50:31.720 --> 00:50:35.580
So last I want to talk about, very
quickly, is network connections.

00:50:35.580 --> 00:50:39.600
Network connections while your app is suspended,
this is kind of like the system change notifications,

00:50:39.600 --> 00:50:42.200
you can lose your network connections for a lot of reasons.

00:50:42.200 --> 00:50:47.360
You know, the network conditions can change, your
location can change, all sorts of things can happen.

00:50:47.360 --> 00:50:54.750
So this could even happen today of course, with your app
when the say the device is locked and sleeping, when you're,

00:50:54.750 --> 00:50:57.400
but it's much more likely to happen
when your app is suspended.

00:50:57.400 --> 00:51:04.480
So when your app is resumed, you need to be ready, on all
your network connections, you need to be ready for errors.

00:51:04.480 --> 00:51:07.990
You know, because those connections could be lost
and you need to handle those errors correctly.

00:51:07.990 --> 00:51:10.360
Don't ignore the errors.

00:51:10.360 --> 00:51:11.990
And you know, you have to take the right action.

00:51:11.990 --> 00:51:18.900
Often it will just mean oh, you know, I lost my
connection to the server so I just need to you know,

00:51:18.900 --> 00:51:21.720
close that one down and just reestablish connection.

00:51:21.720 --> 00:51:22.550
It's often that easy.

00:51:22.550 --> 00:51:28.320
But it's definitely something you need to test for
and be aware of in this multitasking environment.

00:51:28.320 --> 00:51:29.460
Now here's a quick code example.

00:51:29.460 --> 00:51:33.950
This is not meant to be like a template which
for every application you would put in there

00:51:33.950 --> 00:51:37.280
and it would be the exact way that you would
want to do your applicationDidEnterBackground,

00:51:37.280 --> 00:51:39.840
where a lot of these responsibilities are implemented.

00:51:39.840 --> 00:51:44.580
It's just kind of give you the idea that you know,
you're going to have a lot of things that you need to do

00:51:44.580 --> 00:51:48.090
or several things that we talk about
that you need to do here, save state,

00:51:48.090 --> 00:51:52.770
reduce your memory usage, prepare your UI if appropriate.

00:51:52.770 --> 00:51:58.690
Maybe if you're using some listening sockets
or what not, you might want to close them down.

00:51:58.690 --> 00:52:01.730
And on the resume side there's
a shorter list because let's say

00:52:01.730 --> 00:52:07.880
for example we're using this lazy state restore technique
and so actually you don't need to do anything for state.

00:52:07.880 --> 00:52:12.530
Again that's not going to necessarily solve
everyone's problem but it's something to keep in mind.

00:52:12.530 --> 00:52:16.440
And again, in the earlier example, I closed
the listening socket when I was going

00:52:16.440 --> 00:52:19.120
to background, so I want to open it back up again.

00:52:19.120 --> 00:52:25.680
And so now that's kind of, that was the responsibilities and
best practices and now I'm going to turn it back to Dave,

00:52:25.680 --> 00:52:29.610
who's going to talk a little bit about the
multitasking and development tools that you can use

00:52:29.610 --> 00:52:31.540
to help with your multitasking development.

00:52:31.540 --> 00:52:32.370
>> David Myszewski: Thanks

00:52:32.370 --> 00:52:38.220
[ applause ]

00:52:38.220 --> 00:52:43.540
So as part of multitasking, we've enhanced some of
our development tools that will help you introspect

00:52:43.540 --> 00:52:49.910
to the feature, the states of your application and
figure out what's going on at any given point in time.

00:52:49.910 --> 00:52:55.810
One key tool that we provide is Instruments and Instruments
provides this nice timeline view, things like memory usage

00:52:55.810 --> 00:52:59.620
and CPU usage over time and one of the
great new features of Instruments is

00:52:59.620 --> 00:53:03.070
that your application lifecycle events are flagged.

00:53:03.070 --> 00:53:09.810
So if I am sitting here running stocks and I hit
the Home button, then Instruments will flag the fact

00:53:09.810 --> 00:53:15.240
that the application for a short period of time went
to the background running state and then it cleaned up,

00:53:15.240 --> 00:53:18.110
it saved state, paused UI, things like that.

00:53:18.110 --> 00:53:21.300
And then the application was suspended.

00:53:21.300 --> 00:53:26.270
Then maybe later on the user might hit your application icon

00:53:26.270 --> 00:53:30.180
and then Instruments will show that
your application is running again.

00:53:30.180 --> 00:53:33.830
The two states that are going to background
running and to background suspended,

00:53:33.830 --> 00:53:37.110
you may want to watch your memory
usage between those two states.

00:53:37.110 --> 00:53:42.210
Because that's where you'd be freeing up all your memory
and so you can use something like the object outlook tool

00:53:42.210 --> 00:53:45.070
to see just how much memory you
freed during that time period.

00:53:45.070 --> 00:53:50.140
So Instruments provides a nice want to integrate with your
apps so that you can see what it's doing in these states.

00:53:50.140 --> 00:53:54.860
You know, maybe you have a function call that
was too expensive or maybe you have some memory

00:53:54.860 --> 00:53:59.200
that you think we should really release, then
Instruments will allow you to see exactly what's going

00:53:59.200 --> 00:54:04.560
on in your application, as the user
transitions between states in your app.

00:54:04.560 --> 00:54:06.590
A few notes about the simulator.

00:54:06.590 --> 00:54:10.890
Much like we say in other talks, the simulator
is not a complete replacement for the device.

00:54:10.890 --> 00:54:15.560
It's always important when you write your applications,
to test them fully on the device because that's

00:54:15.560 --> 00:54:19.560
where everything will be exactly how the customer sees it.

00:54:19.560 --> 00:54:24.750
We integrate most of our multitasking, most of the
multitasking features that you as developers will need

00:54:24.750 --> 00:54:30.610
into the simulator, so fast app switching is fully
supported, task completion, local modifications

00:54:30.610 --> 00:54:36.150
and if you want to test any sort of integration with your
multitasking UI, you can all do that in the simulator.

00:54:36.150 --> 00:54:41.410
But there are a few things that we don't provide
for multitasking, in particular background audio,

00:54:41.410 --> 00:54:46.840
location and VoIP services and the significant
location changes, aren't provided in the simulator.

00:54:46.840 --> 00:54:51.950
Your Mac doesn't have a GPS chip, so can't
provide that and of course, push notifications,

00:54:51.950 --> 00:54:56.140
much like in iPhone OS 3, still
aren't supported in the simulator.

00:54:56.140 --> 00:55:00.850
But for most of the work that most of you will be
doing, the simulator is a great environment for testing

00:55:00.850 --> 00:55:04.060
out multitasking, just make sure
that you try it on the device.

00:55:04.060 --> 00:55:09.660
Then the debugger changes just a couple of
things about how your application behaves,

00:55:09.660 --> 00:55:14.830
so that you as developers, can
better debug your applications.

00:55:14.830 --> 00:55:19.860
So, it is important to test your app outside
of the debugger, not just in the debugger.

00:55:19.860 --> 00:55:21.220
So what are the changes?

00:55:21.220 --> 00:55:27.180
Well those new applicationDelegate callbacks, we only
have a few seconds to get through those callbacks

00:55:27.180 --> 00:55:31.710
and let's say you have a problem in one of those
callbacks, it may be a bug or maybe you want

00:55:31.710 --> 00:55:33.750
to see well why am I not freeing up memory.

00:55:33.750 --> 00:55:38.330
Well it would be really unfortunate if we
only gave you six seconds to debug your app.

00:55:38.330 --> 00:55:42.220
That's you know, I'm sure you're a fantastic
developer, so are we, but six seconds isn't long enough.

00:55:42.220 --> 00:55:46.160
So it's probably not long enough for anybody.

00:55:46.160 --> 00:55:50.500
So we don't enforce the time limits there and
in the test completion expiration handler,

00:55:50.500 --> 00:55:54.580
which you'll hear more about in the second
talk, we also don't have any sort of time limit.

00:55:54.580 --> 00:56:00.690
So the debugger resumes or allows you to
debug your apps a lot more effectively,

00:56:00.690 --> 00:56:03.470
but that means you need to test
things on the device as well.

00:56:03.470 --> 00:56:10.790
So to conclude, we went over a bunch of the best, the
behaviors that you want to implement for fast app switching,

00:56:10.790 --> 00:56:15.730
the API that you need to adopt and these are
APIs that every application should be adopting.

00:56:15.730 --> 00:56:20.020
You'll want to do it regardless of whether or not you're
the type of application that doesn't need to execute code

00:56:20.020 --> 00:56:23.870
in the background and just needs to be there
so that the user can quickly resume to it

00:56:23.870 --> 00:56:26.220
or if you're an application that runs in the background.

00:56:26.220 --> 00:56:30.780
You still want to do all of these things that we
mentioned in the talk, like reduce memory usage.

00:56:30.780 --> 00:56:36.920
All applications on the store can benefit from fast
app switching because you can resume really quickly,

00:56:36.920 --> 00:56:42.900
we can preserve your state and we have you know,
great integration with the multitasking UI.

00:56:42.900 --> 00:56:49.390
But we have those other services that allow you
to execute code in the background and do things

00:56:49.390 --> 00:56:52.710
that you couldn't have done before
and for that we have the second talk

00:56:52.710 --> 00:56:57.200
which will describe those services,
in a lot of detail, this afternoon.

00:56:57.200 --> 00:57:01.720
So that's in the Mission at 3:15.

00:57:01.720 --> 00:57:04.920
We also have a few other different
talks that might be interesting.

00:57:04.920 --> 00:57:09.390
Various tools, learning how to, what some
of the new features and instruments are

00:57:09.390 --> 00:57:12.300
so that you can intersect your app even more.

00:57:12.300 --> 00:57:17.690
Blocks and Grand Central Dispatch, which
David mentioned, to free up your UI.

00:57:17.690 --> 00:57:22.740
Simplifying networking and another networking
talk that will tell you a little bit more detail

00:57:22.740 --> 00:57:25.540
about how to handle various network conditions.

00:57:25.540 --> 00:57:30.850
So thanks for coming.

