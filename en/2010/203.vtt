WEBVTT

00:00:06.650 --> 00:00:08.180
>> Thane: So I'm Thane Norton.

00:00:08.180 --> 00:00:10.440
I'm with the I/O Kit Team.

00:00:10.440 --> 00:00:16.360
And I want to talk to you a little bit about
designing and debugging device drivers on OS X.

00:00:16.360 --> 00:00:25.210
What I'm going to talk about today is how you can
drive hardware from user space or kernel space,

00:00:25.210 --> 00:00:28.450
the kinds of drivers that have to be in the kernel.

00:00:28.450 --> 00:00:34.120
And some ways you can debug kernel level
code, and some of the special challenges

00:00:34.120 --> 00:00:38.200
that are involved in doing your own I/O Kit user client.

00:00:38.200 --> 00:00:39.990
So what is I/O Kit?

00:00:39.990 --> 00:00:45.340
I/O Kit is the set of frameworks
that Apple uses for driving hardware.

00:00:45.340 --> 00:00:51.210
There's a piece in the kernel and
it percolates up into user space.

00:00:51.210 --> 00:00:59.720
Not only is it the device driver model, but it's also a
framework that applications can use to drive hardware.

00:00:59.720 --> 00:01:04.460
Now I/O Kit is only available on OS X.

00:01:04.460 --> 00:01:07.470
It is not available for the iPhone.

00:01:07.470 --> 00:01:15.230
If you want to know how to drive devices on the iPhone,
you want to go watch the Developing Apps That Work

00:01:15.230 --> 00:01:18.750
with iPhone Accessories session that happened earlier today.

00:01:18.750 --> 00:01:30.180
So the best possible place for you to support
hardware is in your application in user space.

00:01:30.180 --> 00:01:34.550
If you just need to drive hardware
from your particular application,

00:01:34.550 --> 00:01:38.770
you can just link against the I/O
Kit libraries, the I/O Kit framework

00:01:38.770 --> 00:01:42.110
and build the support straight into your application.

00:01:42.110 --> 00:01:47.490
This gives you the benefit of being
able to do a drag-and-drop install

00:01:47.490 --> 00:01:50.250
and not having to have a special installer.

00:01:50.250 --> 00:01:56.870
And even if you have multiple applications that share
the hardware, I/O Kit can arbitrate that sharing for you,

00:01:56.870 --> 00:02:00.540
and you don't have to worry about all the nitty details.

00:02:01.580 --> 00:02:09.660
Now, if you have multiple applications that need to share
the same device support code, then you're probably going

00:02:09.660 --> 00:02:12.600
to want to create some kind of framework.

00:02:12.600 --> 00:02:17.710
You can still build that into your application, letting
you have the drag-and-drop install by putting it

00:02:17.710 --> 00:02:22.960
in the resource folder of your application, otherwise
you're going to need some kind of installer to put it

00:02:22.960 --> 00:02:27.030
in the right place, so all of the applications can use it.

00:02:27.030 --> 00:02:38.440
The last way to support hardware from user space is when
you need to do some kind of services, moving the cursor,

00:02:38.440 --> 00:02:48.250
generating keyboard events, or other services to the system,
you need to have some kind of background application.

00:02:48.250 --> 00:02:49.810
Launchd is your friend.

00:02:49.810 --> 00:02:58.510
It is a utility that can be used to create
launch-on-demand applications that anybody can connect to.

00:02:58.510 --> 00:03:04.830
It's very well documented in the
man pages, such as launchd.plist,

00:03:04.830 --> 00:03:10.000
and you want to go to the Launch-on-Demand
session, which I'm pretty sure hasn't happened yet.

00:03:10.000 --> 00:03:19.780
Now what being in user space buys you is your
device support will be a lot easier to debug.

00:03:19.780 --> 00:03:26.020
Not only will it be easier to debug, when you
have bugs your application will be more robust.

00:03:26.020 --> 00:03:34.170
If your application exits suddenly, the user can
relaunch it or the background service can be relaunched.

00:03:34.170 --> 00:03:40.580
If your kernel driver exits unexpectedly,
the user's going to reboot

00:03:40.580 --> 00:03:42.420
and they're going to lose whatever they were working on.

00:03:42.420 --> 00:03:46.730
You also have a lot more access to system services.

00:03:46.730 --> 00:03:51.290
You can choose to use Objective-C,
which you cannot do in the kernel.

00:03:51.290 --> 00:03:57.320
You have access to better logging
facilities, such as the ASL log system.

00:03:57.320 --> 00:04:00.820
You can create your own log file
and log your messages out to that.

00:04:00.820 --> 00:04:04.160
And you should not be able to cause panics.

00:04:04.160 --> 00:04:08.300
This is not to say that you won't, but if
you do you're going to want to log a bug

00:04:08.300 --> 00:04:12.280
against it and then try and work around it.

00:04:12.280 --> 00:04:20.220
Now from user space,- you can get nearly
full access to any I/O Kit driven hardware.

00:04:20.220 --> 00:04:23.540
Almost any USB device can be supported.

00:04:23.540 --> 00:04:25.760
You get much better memory management.

00:04:25.760 --> 00:04:27.870
You can actually page memory in and out.

00:04:27.870 --> 00:04:30.640
You don't have to worry about your
memory all being wired down.

00:04:30.640 --> 00:04:41.380
And one common misconception is that kernel threads get
special treatment when it comes to thread scheduling.

00:04:41.380 --> 00:04:42.670
That is untrue.

00:04:42.670 --> 00:04:48.190
At a given priority, kernel threads and
user space threads get the same scheduling.

00:04:48.190 --> 00:04:57.620
So that doesn't; being user space versus kernel space
does not buy you anything in terms of priority of access.

00:04:57.620 --> 00:05:02.430
And you end up with a testing matrix that
is very similar to any other application.

00:05:02.430 --> 00:05:08.830
You do some testing on both processors on
all the versions of the OS that you support.

00:05:08.830 --> 00:05:16.110
When I say all the versions of the OS you support, I would
highly recommend only supporting the most recent revision.

00:05:16.110 --> 00:05:19.530
Have your users update to whatever the latest revision is.

00:05:19.530 --> 00:05:23.560
It collapses your testing matrix significantly.

00:05:24.600 --> 00:05:33.100
Now you can't drive hardware from user space if the
hardware is supplying services to someone in the kernel;

00:05:33.100 --> 00:05:37.840
for example, if you are writing a file system driver.

00:05:37.840 --> 00:05:43.000
If you require access to other kernel resources
that are not published through I/O Kit,

00:05:43.000 --> 00:05:45.580
you're going to have to be in the kernel to get those.

00:05:45.580 --> 00:05:49.970
And if you need to respond directly
to primary interrupts, that is to say,

00:05:49.970 --> 00:05:54.300
if you are a PCI driver you're
going to have to be in the kernel.

00:05:54.300 --> 00:05:57.810
There's just no other way to handle it.

00:05:57.810 --> 00:06:02.870
If you have to be in the kernel,
you're going to need to write a kext.

00:06:02.870 --> 00:06:08.310
Even if you're just thinking about writing a kext, if you've
already written a kext and you haven't done this already,

00:06:08.310 --> 00:06:11.930
go read the Kernel Extension Programming Topics.

00:06:11.930 --> 00:06:14.940
It has a lot of very good walkthroughs.

00:06:14.940 --> 00:06:20.570
Going through that over the course of a day, you
can get a very good workflow for building your kext,

00:06:20.570 --> 00:06:25.380
installing it on your test machine,
testing it, debugging it.

00:06:25.380 --> 00:06:29.190
It's an excellent set of tutorials.

00:06:30.680 --> 00:06:37.170
All memory that you allocate in
a kext is, by default, wired.

00:06:37.170 --> 00:06:44.390
What that means is if you had a memory leak in your
driver in the kernel, you're going to take the user system

00:06:44.390 --> 00:06:49.070
down just by depriving other applications of memory.

00:06:49.070 --> 00:06:51.730
Memory from user space is not wired.

00:06:51.730 --> 00:06:55.460
As I was saying, user space applications can page.

00:06:55.460 --> 00:07:04.000
But, since the driver, since kexts, expect memory to
be wired, you have to, before you do any direct I/O

00:07:04.000 --> 00:07:09.420
on memory passed in from user space, you
have to make sure that it's wired down

00:07:09.420 --> 00:07:12.960
and then unwire it after the operation completes.

00:07:12.960 --> 00:07:16.220
When you're in the kernel, logging is very limited.

00:07:16.220 --> 00:07:19.220
Most of the system logs use some kind of ring buffer.

00:07:19.220 --> 00:07:25.280
Which means to you, that if you try and log a lot
of messages, you're going to overflow the buffer,

00:07:25.280 --> 00:07:30.970
the messages are going to get garbled, things will be
dropped, you're not going to see what you expect to see.

00:07:30.970 --> 00:07:36.240
You can't use ASL, which is a very nice logging system.

00:07:36.240 --> 00:07:39.900
Now you can use kprintf to do FireWire logging.

00:07:39.900 --> 00:07:43.280
This is not a solution that you can deploy.

00:07:43.280 --> 00:07:46.130
This is something that is very handy to use in a test setup,

00:07:46.130 --> 00:07:49.730
so that you get all of the message coming,
the messages coming out of your driver.

00:07:49.730 --> 00:07:54.390
If you want to learn how to do that,
the place to look is the man page

00:07:54.390 --> 00:08:02.250
for fwkpfv, which is the FireWire kprintf something.

00:08:03.970 --> 00:08:07.190
Your test cycle's going to be longer.

00:08:07.190 --> 00:08:10.810
Often it will require a reboot,
especially when you encounter a bug,

00:08:10.810 --> 00:08:14.530
because you'll have to be rebooting your system.

00:08:14.530 --> 00:08:17.700
It requires advance preparation.

00:08:17.700 --> 00:08:20.510
You need to have two machines.

00:08:20.510 --> 00:08:23.800
That's going to be your best debug solution.

00:08:23.800 --> 00:08:28.730
You're going to connect them either
through Ethernet or through FireWire.

00:08:28.730 --> 00:08:33.070
Ethernet tends to be more convenient, because
all your machines are hooked up all ready.

00:08:33.070 --> 00:08:39.650
FireWire is available earlier in the boot time, so
it just depends on what kind of environment you need.

00:08:39.650 --> 00:08:47.350
Additionally, you can download the kernel debug
kit for the specific kernel that you're running on.

00:08:47.350 --> 00:08:53.680
And that will give you the ability to step
through Apple code as your driver uses it.

00:08:53.680 --> 00:09:00.320
So you can see what's going on and who
is expecting that pointer to be not null.

00:09:00.320 --> 00:09:03.930
Again, read the Kernel Extension Programming Topics.

00:09:03.930 --> 00:09:07.180
This will show you how to set up a two-machine environment.

00:09:07.180 --> 00:09:17.240
If you wanted to use FireWire, another FireWire utility,
fwkdp, very handy for getting FireWire up and running.

00:09:17.240 --> 00:09:25.530
You must test your kext on every
supported kernel, every release.

00:09:25.530 --> 00:09:31.930
I tell you from experience, it is very
easy to build a kext that will not run

00:09:31.930 --> 00:09:35.690
because you linked against something that isn't there.

00:09:35.690 --> 00:09:40.320
Your kext also must match the kernel
architecture that you're running on.

00:09:40.320 --> 00:09:43.790
You don't get to choose if you're
going to run 64-bit or 32-bit.

00:09:43.790 --> 00:09:46.140
If it's a 32-bit kernel, you run 32-bit.

00:09:46.140 --> 00:09:49.790
If it's 64-bit, you run 64-bit.

00:09:49.790 --> 00:09:53.590
So this expands your testing matrix slightly.

00:09:53.590 --> 00:09:58.970
Each of these tests is going to be a little
more involved as you're testing to make sure

00:09:58.970 --> 00:10:04.900
that your kexts runs on the various kernels proper.

00:10:04.900 --> 00:10:13.210
One of the problems you can run into is that various
functions have changed, for example, memory descriptors.

00:10:13.210 --> 00:10:21.140
They had to change in 10.5 to support x86
user processes, or 64-bit user processes.

00:10:21.140 --> 00:10:25.600
The kernel was still 32-bit, and so we had
to deal with the memory address translations.

00:10:25.600 --> 00:10:31.400
To do that, you have to use conditional
compilations and availability macros.

00:10:31.400 --> 00:10:37.820
Weak linking doesn't really exist in
the kernel for all intents and purposes.

00:10:37.820 --> 00:10:42.150
Now when you're deploying a kext, one
way you can support multiple platforms is

00:10:42.150 --> 00:10:46.120
by having multiple kexts nested inside of one package.

00:10:46.120 --> 00:10:48.280
Dean will talk about this a little more later,

00:10:48.280 --> 00:10:54.520
but it can make things very easy for
the system to find the proper kext.

00:10:54.520 --> 00:10:59.680
You can fairly easily support all
Leopard or better kernels with one kext.

00:10:59.680 --> 00:11:02.570
You can support earlier kernels.

00:11:02.570 --> 00:11:08.830
And if you want to do that, you're going to want to go
back and look at last years Creating I/O Kit Drivers

00:11:08.830 --> 00:11:11.820
for Multiple Architectures and OS Versions.

00:11:11.820 --> 00:11:17.780
They have a very detailed overview of how you have to
link them all together and munge them so that they work.

00:11:17.780 --> 00:11:21.050
When you're working in the kernel
you have to deal with panics.

00:11:21.050 --> 00:11:24.640
Panics are even harder to debug than
your regular kernel environment.

00:11:24.640 --> 00:11:27.120
You've got a static slice of the operating system.

00:11:27.120 --> 00:11:33.150
You can poke around, you can look around, but it's sort
of like CSI, you're trying to figure out who killed you.

00:11:33.150 --> 00:11:36.740
Again, two machine works well if you already have it set up.

00:11:36.740 --> 00:11:38.960
Once the panics happen, too late.

00:11:38.960 --> 00:11:44.300
One thing that can be very handy
is having your system dump core.

00:11:44.300 --> 00:11:50.170
What this means is, it, you can set it up so that
it will write out the kernel memory to a core file

00:11:50.170 --> 00:11:54.750
that you can then look at later, or at a different location.

00:11:54.750 --> 00:12:02.970
So, anyhow, if you have a panic that happens infrequently,
you can set up a bunch of test machines and when they crash,

00:12:02.970 --> 00:12:05.370
they can dump core and you can take a look at them.

00:12:05.370 --> 00:12:13.200
If you want to know how to set up a kernel system
for dumping core, you want to see Tech Note 2118`.

00:12:13.200 --> 00:12:16.770
That will show you how to set up an Ethernet core dump.

00:12:16.770 --> 00:12:22.860
And again, fwkdp is how you can dump core over FireWire.

00:12:22.860 --> 00:12:26.560
All of the panic debugging is covered in Tech Note 2063.

00:12:26.560 --> 00:12:33.470
It's a very good place to look
to figure out what went wrong.

00:12:33.470 --> 00:12:39.440
And it is another one of those things I would highly
recommend that anybody working in the kernel reads.

00:12:39.440 --> 00:12:41.830
So why do you work in the kernel?

00:12:41.830 --> 00:12:44.920
For whatever reason you need to
have closer access to hardware.

00:12:44.920 --> 00:12:47.960
You need kernel resources.

00:12:47.960 --> 00:12:51.910
The kernel, being in the kernel
gets you that special access.

00:12:51.910 --> 00:12:54.060
It's more challenging than user space.

00:12:54.060 --> 00:12:57.740
I'm sure that's not a surprise to anybody here.

00:12:57.740 --> 00:13:06.080
It opens up, you up to a whole new class of defects, panics,
which can deprive your user of the use of their system.

00:13:06.080 --> 00:13:09.900
And you get much more limited access to system resources.

00:13:09.900 --> 00:13:14.410
You can't hit the hard drive, for
example, and access config files.

00:13:14.410 --> 00:13:28.240
If you need a custom interface for crossing the user kernel
boundary, you may need to write your own custom user client.

00:13:28.240 --> 00:13:36.020
This is even harder to debug than a kext, because you've
got two separate processes in two separate memory spaces

00:13:36.020 --> 00:13:42.870
with two separate debuggers attached to them, and
figuring out who's calling whom can be very confusing.

00:13:42.870 --> 00:13:46.540
There is almost always a better choice.

00:13:46.540 --> 00:13:50.120
I would highly recommend that you not do this.

00:13:50.120 --> 00:13:53.790
Code running in the kernel is inherently trusted.

00:13:53.790 --> 00:14:01.020
So if you create, the reason you create an I/O
User Client is to cross that trust boundary.

00:14:01.020 --> 00:14:05.640
If you make your own user client, you become the gatekeeper.

00:14:05.640 --> 00:14:09.270
What that means is, you have to validate everything.

00:14:09.270 --> 00:14:13.520
Any data that comes in from user space, you
have to check to make sure that it makes sense.

00:14:13.520 --> 00:14:19.030
Any pointers that you pass out, you cannot trust
them to be the same pointer that comes back in.

00:14:19.030 --> 00:14:25.450
Even if just a connect, an application connecting to
your user client, if that could elevate privileges

00:14:25.450 --> 00:14:29.010
or affect another user task, you need to verify

00:14:29.010 --> 00:14:34.430
that the connecting application has
the right to access your user client.

00:14:34.430 --> 00:14:39.480
If you want to know how to do any
of this, the SimpleUserClient

00:14:39.480 --> 00:14:43.660
and the AppleSamplePCI driver are both very good examples.

00:14:43.660 --> 00:14:50.910
And this is another big reason you don't
want to do it; your test matrix explodes.

00:14:50.910 --> 00:14:56.440
You have to test all the various architectures
of user clients on all the various architectures

00:14:56.440 --> 00:15:02.680
of kernels, and it just becomes a testing nightmare.

00:15:02.680 --> 00:15:07.470
You can remove Rosetta support,
but this only helps a little bit.

00:15:07.470 --> 00:15:11.030
It's not a big win.

00:15:11.030 --> 00:15:13.350
And now for something completely different.

00:15:13.350 --> 00:15:18.290
I've been asked by members of the team to
give a couple of public service announcements.

00:15:18.290 --> 00:15:23.990
If you're doing a PCI driver, you want to
try and use Message-Signaled Interrupts.

00:15:23.990 --> 00:15:29.660
They are preferred, because there is
less interrupt sharing and it allows us

00:15:29.660 --> 00:15:34.740
to demux the interrupts, so that
only one driver gets called.

00:15:34.740 --> 00:15:46.650
The way you enable MSI is by supplying an index that
is greater than 1 to your I/O interrupt event source.

00:15:46.650 --> 00:15:49.260
When you do that, you don't need to supply a filter.

00:15:49.260 --> 00:15:55.320
So you can use the root class I/O interrupt
event source, interrupt event source.

00:15:55.320 --> 00:15:59.900
If you enable MSI, you disable the standard interrupts.

00:15:59.900 --> 00:16:04.600
If you've set them up, don't expect them to be called.

00:16:05.660 --> 00:16:08.080
This is supported on all Intel hardware.

00:16:08.080 --> 00:16:17.590
So as long, if you're still supporting Power PC, you're
going to have to still do some filtered interrupt support.

00:16:17.590 --> 00:16:24.720
Power Management: If you're in user space,
better performance equals better battery life.

00:16:24.720 --> 00:16:28.510
Periodic activity is worse than batching your activity.

00:16:28.510 --> 00:16:35.730
If you're constantly pinging the hard drive, it's going to
keep it from spinning down; it's going to use more power.

00:16:35.730 --> 00:16:40.960
If you can do all of your access and then let it go
to sleep, this is going to be better for your users.

00:16:40.960 --> 00:16:44.600
Another tool you have available to
you is the System Load Advisory API.

00:16:44.600 --> 00:16:53.610
Now this is as it might sound, an advisory API to
let you know what kind of power save is the user in?

00:16:53.610 --> 00:16:56.210
Is this a good time to do background tasks?

00:16:56.210 --> 00:16:57.340
Is this a bad time?

00:16:57.340 --> 00:17:01.100
Is it kind of OK?

00:17:01.100 --> 00:17:08.300
Some users, the way they use their system, it
never is a good time to do background tasks.

00:17:08.300 --> 00:17:13.560
So you want to use this to guide your behavior, but you're
going to want to have some kind of time out, so that,

00:17:13.560 --> 00:17:17.610
you know, OK, I've waited long enough,
I've got to just go ahead and do it.

00:17:17.610 --> 00:17:21.460
If you need to know about wake and sleep,

00:17:21.460 --> 00:17:26.980
the IO Kit.framework lets you subscribe
to the system power messages.

00:17:26.980 --> 00:17:35.180
If you need to prevent the system from going to
sleep, you want to use the IOPMAssertion APIs.

00:17:35.180 --> 00:17:41.340
They can set it so that your screen won't go to
sleep, for example, if your users watching a movie.

00:17:41.340 --> 00:17:44.930
Or that the system won't go to sleep,
if the users listening to music,

00:17:44.930 --> 00:17:47.100
the screen will still darken, the music will still play.

00:17:47.100 --> 00:17:50.950
And for those of you who know about SafeSleep,

00:17:50.950 --> 00:17:57.740
this is what happens when the system runs
out of battery when it's already asleep.

00:17:57.740 --> 00:18:00.040
You should not have to do anything different.

00:18:00.040 --> 00:18:04.180
It should look just the same to you: the
system went to sleep, it woke back up,

00:18:04.180 --> 00:18:07.190
the hardware was turned off, it got turned back on.

00:18:07.190 --> 00:18:09.180
There shouldn't be anything special that happens.

00:18:09.180 --> 00:18:13.780
If it looks like there's something
special, there's probably something wrong.

00:18:13.780 --> 00:18:20.410
Now Power Management's slightly different in the kext.

00:18:20.410 --> 00:18:27.040
Since any sleep can become SafeSleep, in the kernel,
you again, should not have to do anything different.

00:18:27.040 --> 00:18:29.910
It should look just the same to you.

00:18:29.910 --> 00:18:38.110
You can use IOService APIs to join the power tree so that
you can be notified of Power Management state changes.

00:18:38.110 --> 00:18:41.620
Most kexts don't need to know that,
so they're not part of that tree.

00:18:41.620 --> 00:18:48.230
It's important that your kext, anything in
your kext, only implements the mechanism.

00:18:48.230 --> 00:18:51.460
You do not want to hard code policy into your kext.

00:18:51.460 --> 00:18:59.640
Have a user space daemon that pushes information to
the kext and lets it know what the policy should be.

00:18:59.640 --> 00:19:06.290
You'll have some default policy in your kext, but you
definitely want to be pushing policy from user space.

00:19:06.290 --> 00:19:11.930
You also may have noticed that in Snow Leopard
we introduced something called maintenance wake.

00:19:11.930 --> 00:19:15.670
This was added for Bonjour sleep proxy.

00:19:15.670 --> 00:19:25.530
So your system could go to sleep and still maintain system
resources, or network resources, available on the web.

00:19:25.530 --> 00:19:31.380
Sleep Proxy, the Maintenance Wake is a
brief wake with the screen and audio off.

00:19:31.380 --> 00:19:34.250
It will not last more than 30 seconds.

00:19:34.250 --> 00:19:39.330
If you try and do something that takes longer
than that, you're just not going to get to.

00:19:39.330 --> 00:19:43.380
And it's only, again, it's only triggered
by Bonjour sleep proxy being active.

00:19:43.380 --> 00:19:47.360
And with that, I will hand it off to Dean.

00:19:47.360 --> 00:19:47.590
>> Dean: Hi.

00:19:47.590 --> 00:19:48.750
Thanks Thane.

00:19:48.750 --> 00:19:54.770
I'm going to talk to you a little bit about
taking your driver sort of the next step.

00:19:54.770 --> 00:19:55.490
You've got it written.

00:19:55.490 --> 00:19:57.600
It's working in your lab.

00:19:57.600 --> 00:20:01.290
But how do you take it from your
prototype all the way to being a product?

00:20:01.290 --> 00:20:03.870
What do you need to do to harden it and prepare it?

00:20:03.870 --> 00:20:08.600
And also, what resources Apple has to
help you if you get stuck along the way.

00:20:08.600 --> 00:20:12.280
So how to qualify a driver is an interesting question.

00:20:12.280 --> 00:20:16.590
And most engineers have a pretty good intuitive
sense of things that they need to test,

00:20:16.590 --> 00:20:19.900
because they know what the challenges
were when they were with the driver.

00:20:19.900 --> 00:20:26.680
But there's a lot of basic correctness tests that
often get overlooked, because they seem very basic.

00:20:26.680 --> 00:20:30.330
But I work with a lot of developers
and I see a lot of kernel extensions

00:20:30.330 --> 00:20:33.330
that have been shipped with some
pretty silly common mistakes.

00:20:33.330 --> 00:20:36.860
And as soon as we point them out to the developer,
it's like, oh yeah, of course, I need to fix that.

00:20:36.860 --> 00:20:40.830
But I'm going to go through kind of a laundry
list of things that you might want to look

00:20:40.830 --> 00:20:45.990
at before you even consider putting a driver into full QA.

00:20:45.990 --> 00:20:49.800
And also I recommend keeping records of
a lot of these results between releases,

00:20:49.800 --> 00:20:54.900
because we've found it's actually valuable to
compare from release to release how we're doing,

00:20:54.900 --> 00:20:59.110
particularly with Power Management
and with general performance.

00:20:59.110 --> 00:21:05.250
It can be very instructive, and you can start to notice
trends, and particularly if something steps out of line.

00:21:05.250 --> 00:21:10.860
So first on the sort of easy checks
is, look at the Info.plist.

00:21:10.860 --> 00:21:18.090
This is an XML file inside your kext bundle that is
sort of used by the kext management system to know

00:21:18.090 --> 00:21:22.430
under what conditions to load your kernel extension,
how to load it, what it depends on, and so on.

00:21:22.430 --> 00:21:27.110
But there's a few particular properties
I want to call your attention to.

00:21:27.110 --> 00:21:28.460
IOKitDebug.

00:21:28.460 --> 00:21:32.930
This is a property you can add to
your personalities in your plist,

00:21:32.930 --> 00:21:35.870
to turn on some additional logging
messages in the IOKit system.

00:21:35.870 --> 00:21:41.810
And its value is the decimal number;
I believe it's from zero to 65535.

00:21:41.810 --> 00:21:47.930
Well you need to either make sure that it's been
absent or set to zero when you ship your kext,

00:21:47.930 --> 00:21:52.540
because you don't want these additional
messages clogging up your users logs.

00:21:52.540 --> 00:21:57.960
And it's slowing down their system, because it
has to write these out to the disk at some point.

00:21:57.960 --> 00:21:59.830
Did you advance your version number?

00:21:59.830 --> 00:22:03.590
This is important, because it's one of
two properties that the kext system uses

00:22:03.590 --> 00:22:06.030
to uniquely identify your kernel extension.

00:22:06.030 --> 00:22:09.740
If you have two different versions
of your kext on the system,

00:22:09.740 --> 00:22:14.770
this is how the computer can differentiate
between them and load the newest one.

00:22:14.770 --> 00:22:20.360
It's also handy for support, when somebody calls in
with an issue you'll know exactly what they're running.

00:22:20.360 --> 00:22:26.530
In the CFBundleIdentifier is the other property used to
uniquely identify your kernel extension to the system.

00:22:26.530 --> 00:22:28.180
Make sure it's correctly formed.

00:22:28.180 --> 00:22:35.910
Make sure that you're using a reverse DNS style
identifier, com.yourcompanynamehere.driver.whatever.

00:22:35.910 --> 00:22:41.760
We don't want to see a bunch of kexts out there
with their CFBundleIdentifier being com.mydriver,

00:22:41.760 --> 00:22:44.410
or something like that from one of the examples.

00:22:44.410 --> 00:22:47.720
Because, again, if these collide, the
kext management system doesn't know

00:22:47.720 --> 00:22:50.090
that they're different kexts, it
assumes that they're the same.

00:22:50.090 --> 00:22:57.280
Two additional properties that have been misused
over the years, OSBundleCompatibleVersion.

00:22:57.280 --> 00:22:59.600
This is perhaps confusingly named.

00:22:59.600 --> 00:23:04.770
This is what tells the kext management
system that the kext is a library kext.

00:23:04.770 --> 00:23:11.500
It is describing the lower bound of a version
range that that text is binary compatible with.

00:23:11.500 --> 00:23:15.760
If it's presenting and interface
vessel or lower bound to the range.

00:23:15.760 --> 00:23:19.310
The actual CFBundleVersion being the upper bound.

00:23:19.310 --> 00:23:21.610
But if your kext is not a libary kext, and most

00:23:21.610 --> 00:23:25.600
of you probably are not making library
kext, then you do not need this property.

00:23:25.600 --> 00:23:31.010
Having it in there means the system will keep around
additional information assuming it's going to need the link.

00:23:31.010 --> 00:23:33.100
Use that information for linking later.

00:23:33.100 --> 00:23:39.710
So make sure that property is absent unless
you know you need it, because you're a library.

00:23:39.710 --> 00:23:42.700
And then also the OSBundleRequired property.

00:23:42.700 --> 00:23:48.900
This is used to determine if the booter has to load
your driver, or if it can be left later for the kernel.

00:23:48.900 --> 00:23:54.580
The only reason that the booter has to load
the driver is if it's necessary in order to go

00:23:54.580 --> 00:23:58.160
about mounting the root file system,
so that other drivers can be found.

00:23:58.160 --> 00:24:02.680
So most of your drivers probably don't need
to have the OSBundleRequired property, either.

00:24:02.680 --> 00:24:09.950
But if you've kind of developed your driver by cutting
and pasting from some other drivers you might have kind

00:24:09.950 --> 00:24:14.910
of absorbed these properties along the
way and you want to review their use.

00:24:14.910 --> 00:24:17.160
Bundle structure.

00:24:17.160 --> 00:24:21.090
Run Find on your kext and look
at every file that's in there.

00:24:21.090 --> 00:24:25.520
There's really only two files that have to be
there: there's the Info.plist and then the binary

00:24:25.520 --> 00:24:27.990
that actually gets loaded into the kernels.

00:24:27.990 --> 00:24:31.510
You should be able to account for
every file that's in the bundle.

00:24:31.510 --> 00:24:35.210
I've seen kernel extensions ship with header files in them.

00:24:35.210 --> 00:24:38.260
That their build process somehow copied in there.

00:24:38.260 --> 00:24:43.120
I've seen lots of stuff in there, a
GDB debug sessions files left in there.

00:24:43.120 --> 00:24:50.580
Yeah, go through and do some hygiene there and make sure
those files are all removed if they don't need to be there.

00:24:50.580 --> 00:24:54.320
And of course, ownership and permissions,
you kext won't even load if these are wrong.

00:24:54.320 --> 00:24:58.130
But this is a good opportunity to make
sure they're owned by root, group is wheel,

00:24:58.130 --> 00:25:01.440
and they're set up so they can't
be modified by any other user.

00:25:01.440 --> 00:25:09.030
Kextutil-tn is a great tool to help you find,
sort of structural problems with your kext.

00:25:09.030 --> 00:25:15.190
Any kind of an issue that, you know, maybe would be
fatal, maybe even not fatal, maybe it's just a warning.

00:25:15.190 --> 00:25:19.860
But it does; the t means test the kext,
perform the strictest test that it can.

00:25:19.860 --> 00:25:21.960
And n means don't actually load it.

00:25:21.960 --> 00:25:26.630
So this is just doing all the proofing
that it would do before it loads the kext.

00:25:26.630 --> 00:25:29.680
So that's kextutil on Snow Leopard and later.

00:25:29.680 --> 00:25:32.480
Prior to Snow Leopard, that's kextload.

00:25:32.480 --> 00:25:37.700
In Snow Leopard we split out the
developer tool into kextutil.

00:25:37.700 --> 00:25:40.020
We also have a tool called kextlibs.

00:25:40.020 --> 00:25:43.450
And this is a great way to find out
what your dependencies ought to be.

00:25:43.450 --> 00:25:47.820
If you don't know exactly what other
library kext you should be linking on,

00:25:47.820 --> 00:25:54.740
the kextlibs tool will actually even give you the little
XML blurb that you can copy and past right into your plist

00:25:54.740 --> 00:25:56.310
to make sure you got your dependencies right.

00:25:56.310 --> 00:26:03.050
So we would hope you'd use that to make sure
your dependencies are as tight as they can be.

00:26:03.050 --> 00:26:09.020
Now the binary inside the bundle is
the PC gets loaded into the kernel.

00:26:09.020 --> 00:26:11.790
And, but it also contains a lot of symbolic information.

00:26:11.790 --> 00:26:16.080
Obviously we have to link that into the kernel, so you
got to have all your undefined symbols defined there.

00:26:16.080 --> 00:26:19.800
And if you're a library you have to have
your exported symbols there as well.

00:26:19.800 --> 00:26:25.690
But you want to make sure that that was built
with the release configuration of Xcode.

00:26:25.690 --> 00:26:29.680
Because if you have it set to debug,
you're going to get a lot of debug symbols.

00:26:29.680 --> 00:26:33.170
You're going to get like ten times as large
a symbol table as you would actually need.

00:26:33.170 --> 00:26:35.310
So the binary gets very large.

00:26:35.310 --> 00:26:39.840
And you're actually leaking a lot of
information about the structure of your code.

00:26:39.840 --> 00:26:43.010
You're also going to want to verify
that your architectures are correct.

00:26:43.010 --> 00:26:47.920
Make sure that every architecture you need is present,
and that none that you don't need are present.

00:26:47.920 --> 00:26:54.870
So there's three that you would encounter in
this development space: i386 for 32-bit Intel,

00:26:54.870 --> 00:26:59.170
x86_64 for 64-bit Intel, and ppc for 32-bit par PC.

00:26:59.170 --> 00:27:02.560
You should also run nm on the kernel.

00:27:02.560 --> 00:27:08.700
Nm is the, on the kext, nm is the utility that
dumps all the symbols in the symbol table.

00:27:08.700 --> 00:27:11.320
And there's a variety of options
and other things you can do.

00:27:11.320 --> 00:27:20.310
I've given you a line here that runs it through a filter
to convert the C++ mangled names into human readable names.

00:27:20.310 --> 00:27:23.530
And then removes all of the undefined symbols.

00:27:23.530 --> 00:27:28.910
So what you're going to be left with here
is a list of symbols that your kext defines.

00:27:28.910 --> 00:27:30.870
Make sure that they're named correctly.

00:27:30.870 --> 00:27:36.460
You really want all your global symbols to have a
prefix that uniquely identifies them to your kext.

00:27:36.460 --> 00:27:40.950
Ideally the reverse DNS that matches
your CFBundleIdentifier,

00:27:40.950 --> 00:27:44.010
but with the periods replaced with under bars.

00:27:44.010 --> 00:27:48.500
And the reason for this is the kernel
uses a single, flat name space.

00:27:48.500 --> 00:27:53.880
All the kexts, when they link, link against all their
libraries, and those all link against the kernel.

00:27:53.880 --> 00:27:57.920
If you have any symbol collision along the
way, it won't load your kernel extension.

00:27:57.920 --> 00:28:05.550
So if you have a function called qsort and then a version of
our kernel Apps qsort, which I think we actually view now,

00:28:05.550 --> 00:28:09.000
your kext will not load, because you have duplicate symbols.

00:28:09.000 --> 00:28:15.500
So you want to make sure that your
global names are all well qualified.

00:28:15.500 --> 00:28:18.360
OK, so far we've just been looking at the kext passively.

00:28:18.360 --> 00:28:21.500
Now we actually want to try loading
it, and here's some things you can do.

00:28:21.500 --> 00:28:26.720
Watch the system log and kernel logs while
you're loading your kernel extension.

00:28:26.720 --> 00:28:30.250
Look for any warnings, or errors, or
any other kind of messages that come

00:28:30.250 --> 00:28:32.120
out that seem scary, and go chase those down.

00:28:32.120 --> 00:28:33.920
Figure out why they're there.

00:28:33.920 --> 00:28:37.300
The messages that we spit out are usually meaningful.

00:28:37.300 --> 00:28:38.590
They usually are important.

00:28:38.590 --> 00:28:41.140
And if you're having trouble understanding what they mean,

00:28:41.140 --> 00:28:46.010
the various mail lists that our own
lists can usually help shine a light.

00:28:46.010 --> 00:28:47.940
Also, unload your kext.

00:28:47.940 --> 00:28:52.090
I recommend getting this working very early
in your development cycle, and here's why.

00:28:52.090 --> 00:28:57.560
When you're developing the kernel, you want to
be able to load your kext, try something out,

00:28:57.560 --> 00:29:00.330
unload your kext, make a few changes, reload.

00:29:00.330 --> 00:29:03.760
You know, hopefully you won't panic every
time and have to reboot the computer.

00:29:03.760 --> 00:29:09.600
So some of the time unload can save you, can
actually make your development cycle much more rapid.

00:29:09.600 --> 00:29:13.310
But it's also important to make unload
work, because it really helps ensure

00:29:13.310 --> 00:29:16.140
that you've got a lot of your references right.

00:29:16.140 --> 00:29:18.120
You're not leaking references to your objects.

00:29:18.120 --> 00:29:20.840
You're not leaving dangling objects around.

00:29:20.840 --> 00:29:26.970
So if unload won't work, that probably means that either
somebody is holding a reference to one of your objects

00:29:26.970 --> 00:29:30.380
or you've leaked a instance of an
object and we won't unload you.

00:29:30.380 --> 00:29:36.450
Also, you know, while you're doing this, make sure that the
system sleeps and wakes correctly while your kext is loaded.

00:29:36.450 --> 00:29:39.920
And make sure your driver will unload
after the device has gone away.

00:29:39.920 --> 00:29:44.600
If you unplug your device after about a minute,
your driver should automatically unload.

00:29:44.600 --> 00:29:49.300
And also try Safe Boot, that's where
you boot holding down the Shift key.

00:29:49.300 --> 00:29:54.910
This bypasses the kernel caches, the kext caches,
and actually tells the system to rebuild them.

00:29:54.910 --> 00:30:00.760
But that has the booter load the drivers
individually as opposed to a cache.

00:30:00.760 --> 00:30:04.390
And this gives you a way of testing
a few more configurations

00:30:04.390 --> 00:30:08.100
that your users will encounter under some circumstances.

00:30:08.100 --> 00:30:10.660
Now cycling is a really powerful tool.

00:30:10.660 --> 00:30:14.920
This is something we use pretty extensively
at Apple and we find a lot of things.

00:30:14.920 --> 00:30:17.940
This helps us harden the code quite a bit.

00:30:17.940 --> 00:30:21.020
But it's not just about repeating
a task over and over again,

00:30:21.020 --> 00:30:25.170
it's about watching the impact of that task on the system.

00:30:25.170 --> 00:30:30.430
If you load and unload your kext one time, it's
unlikely that you're going to notice any leaked memory,

00:30:30.430 --> 00:30:33.560
because it's probably not a lot of memory.

00:30:33.560 --> 00:30:38.540
But if you load it and unload it
1,000 times, you can see a pattern.

00:30:38.540 --> 00:30:42.450
So we have some tools like ioclasscount,
ioalloccount, zprint,

00:30:42.450 --> 00:30:46.190
and top that all monitor various things around the system.

00:30:46.190 --> 00:30:51.420
And if you can cycle some of these
activities, then you can watch for trends.

00:30:51.420 --> 00:30:57.240
You can look for, you know, some particular
zone of memory blowing up, and realize,

00:30:57.240 --> 00:30:59.620
OK, maybe I am leaking some resource here.

00:30:59.620 --> 00:31:00.890
These are important things to fix.

00:31:00.890 --> 00:31:06.250
As Thane pointed out, kernel memory
allocated by kext is, by default, wired.

00:31:06.250 --> 00:31:11.160
And so that's memory that if it gets leaked, the only
way to recover that memory is to reboot the computer.

00:31:11.160 --> 00:31:14.940
It's gone as far as the kernel is considered, as concerned.

00:31:14.940 --> 00:31:18.770
So take leaks like that very seriously please.

00:31:18.770 --> 00:31:24.900
And of course, you know, I've listed a few things
you can cycle here: sleep, wake, attach, detach.

00:31:24.900 --> 00:31:28.540
But your product, obviously, is going
to have some very common operations.

00:31:28.540 --> 00:31:30.060
Cycle those as well.

00:31:30.060 --> 00:31:36.020
We give you a tool in the developer's tools called
SleepX that will allow you to do sleep cycling.

00:31:36.020 --> 00:31:40.290
So that is actually a very powerful
tool for checking that transition.

00:31:40.290 --> 00:31:41.220
And set a goal.

00:31:41.220 --> 00:31:43.800
I mean this is pretty basic test methodology, right?

00:31:43.800 --> 00:31:46.410
We usually try to start at 1,000.

00:31:46.410 --> 00:31:49.420
Sometimes some of our goals are up over 10,000 cycles.

00:31:49.420 --> 00:31:52.170
It really just depends on how long it
takes to get through a cycle of something.

00:31:52.170 --> 00:31:54.430
But this is another area to keep records.

00:31:54.430 --> 00:31:58.430
You know, how many thousands of cycles can
this go, and let it go over the weekend,

00:31:58.430 --> 00:32:02.210
and helps you see if your quality is improving.

00:32:02.210 --> 00:32:05.770
Okay, so you've hammered out your kext.

00:32:05.770 --> 00:32:06.690
You've tested it.

00:32:06.690 --> 00:32:13.380
You've got it hardened by cycling, and now
you're ready to put it into your users hands.

00:32:13.380 --> 00:32:15.130
What do you need to do to do that?

00:32:15.130 --> 00:32:21.510
Well we have a tool called Package Maker that will
create a .pkg file that the Apple Installer knows about.

00:32:21.510 --> 00:32:26.620
And it automatically does all the
right things to install a kext, right?

00:32:26.620 --> 00:32:32.290
So if you don't want to have to worry about
setting owners and permissions correctly, you know,

00:32:32.290 --> 00:32:35.570
you don't want to deal with touching the
extensions folder, all of those other things

00:32:35.570 --> 00:32:38.680
that you might have seen on Apple Tech Notes.

00:32:38.680 --> 00:32:42.750
The Package Maker will generate a package
that does all the right things for you.

00:32:42.750 --> 00:32:49.520
And as it turns out there's a nice walkthrough
that describes exactly how to go about doing this

00:32:49.520 --> 00:32:52.750
in the Packaging a Kernel Extension
for Distribution and Installation.

00:32:52.750 --> 00:32:54.220
It's a very straightforward title.

00:32:54.220 --> 00:32:55.360
It says exactly what it's about.

00:32:55.360 --> 00:32:59.410
But it walks you through packaging up an example kext.

00:33:00.510 --> 00:33:06.880
Now, what's actually going on behind the scenes here is that
your kext is being copied into system library extensions,

00:33:06.880 --> 00:33:10.630
which is the folder for auto loaded kernel extensions.

00:33:10.630 --> 00:33:15.590
Please do not install kext in library extensions.

00:33:15.590 --> 00:33:20.620
There have been a few discussions on the mail lists
about, you know, why doesn't Apple use library extensions,

00:33:20.620 --> 00:33:27.690
because it should, because other file system
domains include libraries as opposed to just system library.

00:33:27.690 --> 00:33:29.910
And this is a decision that was made early on.

00:33:29.910 --> 00:33:32.130
We've revisited it a few times.

00:33:32.130 --> 00:33:35.400
But we want to keep library extensions for future use.

00:33:35.400 --> 00:33:37.500
We think we might want to use it in the future.

00:33:37.500 --> 00:33:43.390
But if you're installing kernel extensions there
now, that limits how we could use it in the future.

00:33:43.390 --> 00:33:47.110
Plus, there's no reason to install them there
now, because it doesn't actually mean anything.

00:33:47.110 --> 00:33:48.830
It's just a folder.

00:33:48.830 --> 00:33:52.660
So put them in system library extensions
if you want them to auto load.

00:33:52.660 --> 00:33:58.580
If they're tied to an application, if you have a
kernel extension that really is only there in support

00:33:58.580 --> 00:34:03.650
of a specific application, then you
can put the kext inside the app.

00:34:03.650 --> 00:34:13.390
It can be inside its resources, or plug-ins folder, and
the app can load it programmatically by running kext load.

00:34:13.390 --> 00:34:18.810
Thane had mentioned earlier that you can nest kernel
extensions, and the reason you might want to do that is

00:34:18.810 --> 00:34:23.090
to have one top-level kext with
a family of supporting kexts.

00:34:23.090 --> 00:34:26.360
We will support up to one level
of nesting for kernel extensions.

00:34:26.360 --> 00:34:32.190
So inside the plug-ins folder of a kext you can have
as many kexts as you need for your suite of drivers,

00:34:32.190 --> 00:34:35.480
and deliver them as if they were one kext.

00:34:35.480 --> 00:34:37.640
It's actually pretty handy if you, say,

00:34:37.640 --> 00:34:41.880
have an older version of the kernel
extension that's supported PPC hardware,

00:34:41.880 --> 00:34:45.030
and you don't want to re-QA it and redevelop it.

00:34:45.030 --> 00:34:54.400
You can just shift that as a subkext of your main
kext or new shiny Intel 64-bit kernel extension.

00:34:54.400 --> 00:34:59.670
And that, the subkext will be used on the
64-bit, or excuse me, on PAR PC systems,

00:34:59.670 --> 00:35:02.990
and the main one will be used on Intel 64 systems.

00:35:02.990 --> 00:35:07.350
The talk, last years talk that Thane
referenced earlier will describe exactly the ins

00:35:07.350 --> 00:35:09.870
and outs of how to make all that work.

00:35:09.870 --> 00:35:16.780
After you've installed a kernel extension, or modified one,
or removed one, you need to touch the extensions folder.

00:35:16.780 --> 00:35:23.480
This changes its modification date and allows the caching
system to know that it's time to regenerate the caches.

00:35:23.480 --> 00:35:25.970
You shouldn't directly manage the caches.

00:35:25.970 --> 00:35:29.000
The caches for every release of MAC OS X have changed.

00:35:29.000 --> 00:35:34.550
We've constantly been refining them and it's
difficult for you to try to manage them,

00:35:34.550 --> 00:35:36.810
because you have to do something different on every release.

00:35:36.810 --> 00:35:38.400
You should not need to.

00:35:38.400 --> 00:35:43.600
If you encounter a situation where you really do need to
manage the caches to get your product to work correctly,

00:35:43.600 --> 00:35:46.510
please file a bug that would be a bug on us.

00:35:46.510 --> 00:35:50.230
Because the caches should always
reflect what's in the extensions folder.

00:35:50.230 --> 00:35:54.820
Assuming you've honored the contract
of touching system library extensions.

00:35:54.820 --> 00:35:59.210
Now if you want to have a kext immediately
available for use without requiring a reboot,

00:35:59.210 --> 00:36:02.830
there's a tech note for that, a Technical Q&A 1319.

00:36:02.830 --> 00:36:07.120
What it boils down to is you want to
send the SIGHUP to kext D.

00:36:07.120 --> 00:36:13.450
And the tech note, or the Technical Q&A describes
exactly under what OS releases you can do that,

00:36:13.450 --> 00:36:19.090
and how you go about finding its process ID,
and, and, it's pretty straightforward though.

00:36:19.090 --> 00:36:25.070
Now if you can't use Package Maker, if you need to
install your kext through some other installation utility

00:36:25.070 --> 00:36:27.980
for whatever reason, you can certainly do that.

00:36:27.980 --> 00:36:30.440
But there's a few things you need to make sure of.

00:36:30.440 --> 00:36:37.830
First off, make sure that the installed version
of your kext exactly matches what you built.

00:36:37.830 --> 00:36:43.030
I've seen installers that modify kernel, or
modify files that get installed they send them,

00:36:43.030 --> 00:36:48.380
because they think they need, don't need all the
binaries, or they change the permissions in odd ways.

00:36:48.380 --> 00:36:55.600
You should go and make sure that not only the data, but the
meta data, the, the ownership and permissions and ACLs,

00:36:55.600 --> 00:37:00.310
[phonetic] and extended attributes, and
anything else on those files are correct.

00:37:00.310 --> 00:37:04.190
And also make sure that it does touch the
extensions folder to update the mod date.

00:37:04.190 --> 00:37:06.720
And there's a common trap here that I'll warn you about.

00:37:06.720 --> 00:37:12.690
The first time you install a kext, that effectively
creates a new subdirectory in the extensions folder

00:37:12.690 --> 00:37:16.300
that guarantees the mod date of
the extensions folder gets updated.

00:37:16.300 --> 00:37:21.200
But when you reinstall that kext,
it's just overlaying the same files.

00:37:21.200 --> 00:37:28.570
The folder, the .kext folder that was created during
the first install doesn't get reinstalled, right?

00:37:28.570 --> 00:37:29.590
It's already there.

00:37:29.590 --> 00:37:34.290
So the extensions folder mod date
doesn't change in that case.

00:37:34.290 --> 00:37:37.910
So that's why you want to make sure that the
installer works after an upgrade as well.

00:37:37.910 --> 00:37:40.590
The second time after the kext is already present,

00:37:40.590 --> 00:37:45.670
you want to make sure it's still touching the
extensions folder, so the caching can take over.

00:37:45.670 --> 00:37:51.110
And you also want to make sure that if you are doing
an upgrade install that if you have any old resources

00:37:51.110 --> 00:37:56.040
or old files from your previous kext, until they get
removed, obviously you don't want anything bleeding

00:37:56.040 --> 00:38:01.430
through from a previous version,
because that can lead to who knows what.

00:38:01.430 --> 00:38:06.210
OK, if you get stuck along the way, if you
need some help, there's a large variety

00:38:06.210 --> 00:38:09.500
of resources available in the Apple Developer Community.

00:38:09.500 --> 00:38:15.330
And I'm going to start you off at the Hardware
and Drivers page off of developer.apple.com.

00:38:15.330 --> 00:38:18.190
This is probably going to be your
hub for doing driver development.

00:38:18.190 --> 00:38:22.980
Pretty much all the resources that Thane and I have
talked about today are referenced through there.

00:38:22.980 --> 00:38:30.620
There are, there are developer
forums, developer.apple.com/devforums,

00:38:30.620 --> 00:38:34.210
and they haven't been used extensively
for device support to date.

00:38:34.210 --> 00:38:39.820
We do have a forum on there for 64-bit
migration, and it is suitable and appropriate

00:38:39.820 --> 00:38:43.260
to talk about 64-bit kernel issues there.

00:38:43.260 --> 00:38:48.440
There's certainly the mail lists that are pretty common,
the darwin mail lists: darwin-kernel, darwin-drivers,

00:38:48.440 --> 00:38:52.240
and development that'll be suitable for any of these topics.

00:38:52.240 --> 00:38:57.800
And then there's application or domain
specific ones like USB, FireWire, ata-scsi-dev,

00:38:57.800 --> 00:39:01.240
where you can ask questions about those specific areas.

00:39:01.240 --> 00:39:06.490
And of course, at any point along the way, if you
think that something is not behaving correctly,

00:39:06.490 --> 00:39:10.020
or not behaving as documented, please file a bug report.

00:39:10.020 --> 00:39:12.320
This is how we know what we need to do.

00:39:12.320 --> 00:39:15.110
This is important communication.

00:39:15.110 --> 00:39:20.210
I know it feels sometimes like a one-way street where
you file a bug and you never hear back about it.

00:39:20.210 --> 00:39:25.360
But understand that that's a voice that comes
in and gets added to a lot of other voices.

00:39:25.360 --> 00:39:30.130
And it helps us understand maybe collectively
where we should be putting our resources.

00:39:30.130 --> 00:39:36.540
So it does help us understand how to focus
on, or what to focus on, I should say.

00:39:36.540 --> 00:39:41.310
So please don't be shy about filing bug reports
if you think you've encountered a defect.

00:39:41.310 --> 00:39:44.800
You probably shouldn't be filing bug
reports just to get answers, right?

00:39:44.800 --> 00:39:48.580
If something isn't working, because
you don't quite understand it,

00:39:48.580 --> 00:39:51.030
that's not the same as something
isn't working, you understand it,

00:39:51.030 --> 00:39:53.880
you're following the directions, and it's just not working.

00:39:53.880 --> 00:39:59.520
If you're not sure and you want some one-on-one
help, you can always request a DTS Incident.

00:39:59.520 --> 00:40:04.500
These are paid support sessions where an
Apple engineer will work with you to try

00:40:04.500 --> 00:40:07.510
to resolve the problem that you're having.

00:40:07.510 --> 00:40:12.370
All of these methods have been used to great
effect by many of the developers I've worked with.

00:40:12.370 --> 00:40:13.970
So please use your community.

