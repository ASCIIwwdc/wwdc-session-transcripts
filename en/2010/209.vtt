WEBVTT

00:00:07.390 --> 00:00:07.960
>> John Wright: Hello, everyone.

00:00:07.960 --> 00:00:09.920
My name is John Wright.

00:00:09.920 --> 00:00:13.920
I'm part of Platform Technologies in Core OS.

00:00:13.920 --> 00:00:18.850
We're responsible for a lot of the
security infrastructure in iOS.

00:00:18.850 --> 00:00:25.840
And today, we're going to talk about-- a
little bit about protecting data on the phone.

00:00:25.840 --> 00:00:28.160
So we're going to go over-- this is our agenda.

00:00:28.160 --> 00:00:32.750
So first, I'm going to talk a little bit about what data
protection is and what security mechanisms we have in place

00:00:32.750 --> 00:00:36.160
in iOS and kind of how they've
evolved over the different releases.

00:00:36.160 --> 00:00:43.620
And then we're going to kind of do a deep dive
into the design of our data protection mechanisms,

00:00:43.620 --> 00:00:46.080
and this is more for your security analysis.

00:00:46.080 --> 00:00:49.310
This is not something that you actually need to know.

00:00:49.310 --> 00:00:50.860
It's all done under the covers.

00:00:50.860 --> 00:00:59.060
But I think a lot of you that are kind of in the
trust-but-verify hats, really want to know this information.

00:00:59.060 --> 00:01:05.870
Then we're going to talk a little bit about enabling
data protection, both from a user standpoint

00:01:05.870 --> 00:01:10.230
and from an enterprised standpoint of managing a device.

00:01:10.230 --> 00:01:14.210
And then we're going to talk a
little bit about the API's that you--

00:01:14.210 --> 00:01:24.380
that we want you to adopt in your applications to be
in data protection and how to protect your user's data.

00:01:24.380 --> 00:01:32.320
So these devices that we have, these phones and iPads
and iPod touches, they're very personal devices,

00:01:32.320 --> 00:01:39.690
and they have a lot of-- more data on them than we've
ever had before ringing around people's pockets.

00:01:39.690 --> 00:01:44.860
And one of the things that is kind of
a challenge here is that them being

00:01:44.860 --> 00:01:49.150
so mobile also means they're more easily stolen by someone.

00:01:49.150 --> 00:01:51.120
And you have a lot of different data on here.

00:01:51.120 --> 00:01:57.790
You have all your messages from your messaging systems,
you have your accounts for those social networks,

00:01:57.790 --> 00:02:04.240
you might have accounts for financial information,
and you might have even enterprised apps

00:02:04.240 --> 00:02:08.460
that you're actually responsible for
protecting your company's information.

00:02:08.460 --> 00:02:16.360
So this has become very, very important, being able to
protect this data, especially in a mobile environment.

00:02:17.450 --> 00:02:26.730
So what we introduced last year on iPhone
3GS was all the data was encrypted in place.

00:02:26.730 --> 00:02:34.010
Now, we actually added special hardware to these
devices that would have no performance impact.

00:02:34.010 --> 00:02:38.340
Basically, it's you know, hardware encryption
engines in the hardware that would do it

00:02:38.340 --> 00:02:41.510
for no performance, no battery life impact whatsoever.

00:02:41.510 --> 00:02:49.390
Now, the big reason that we did this was we
want a really fast experience of Remote Wiping.

00:02:49.390 --> 00:02:54.880
So Remote Wipe is that you can send a signal to
the phone as long as that phone is still online

00:02:54.880 --> 00:02:57.030
that it will erase all that customer's data.

00:02:57.030 --> 00:03:00.120
So you can do this from, you know, if the device is lost.

00:03:00.120 --> 00:03:02.890
And we wanted that to be very, very fast.

00:03:02.890 --> 00:03:08.930
And if you encrypt all the data, you can
just throw away the keys, makes it very fast.

00:03:08.930 --> 00:03:14.200
Now, it also has this concept of
protecting the data at rest.

00:03:14.200 --> 00:03:20.590
Now, this is kind of a concept that evolved from desktops.

00:03:20.590 --> 00:03:28.340
And the idea on desktops is that a lot of desktops, you
can image your data and move it to somewhere else to try

00:03:28.340 --> 00:03:32.730
to compromise, or someone can steal a hard drive out of it.

00:03:32.730 --> 00:03:34.980
Now, this doesn't really apply
to a lot of these mobile devices.

00:03:34.980 --> 00:03:42.230
So it makes-- if you have that device, it makes
that device still very vulnerable to a local attack.

00:03:42.230 --> 00:03:49.610
Now, the other thing that we added
last year was encrypted backups.

00:03:49.610 --> 00:03:54.940
And this means that the data is protected when it is
off the device and being backed up to a host machine.

00:03:54.940 --> 00:04:00.630
So what we're introducing for iOS 4.

00:04:00.630 --> 00:04:03.860
We have this goal to keep the data
safe even if the device is compromised.

00:04:03.860 --> 00:04:10.240
So what we did is we added the ability to tie
the encrypted data to the user's passcode.

00:04:10.240 --> 00:04:15.250
So this means that it's actually something that
the user knows themselves that unlocks that data,

00:04:15.250 --> 00:04:20.520
so that data is only available when the device is unlocked.

00:04:20.520 --> 00:04:26.170
Now, we added API's in so you can choose data
availability, whether it's only available

00:04:26.170 --> 00:04:29.370
when the device is unlocked, or it's available all the time.

00:04:29.370 --> 00:04:34.470
And we went about adopting this in iOS 4 in
mail, which is by far, the most complicated app

00:04:34.470 --> 00:04:38.150
and does the most complicated background activity.

00:04:38.150 --> 00:04:45.890
And we're making those API's available for you to adopt in
your apps, so you can tie into the same security mechanism.

00:04:45.890 --> 00:04:53.160
And I want to emphasize here again, there's absolutely no
performance impact to this because we're doing this all

00:04:53.160 --> 00:04:55.820
in the hardware engine itself,
and it's all just streamlining

00:04:55.820 --> 00:04:58.090
with how the data reads and writes out of the hardware.

00:04:58.090 --> 00:05:02.130
Now, I also want to mention that we
still had to enable encrypted backups,

00:05:02.130 --> 00:05:05.560
and we actually had retool all
of our infrastructure to do this.

00:05:05.560 --> 00:05:08.290
But we got one big benefit.

00:05:08.290 --> 00:05:13.960
We now can allow the key chain to be migrated
between devices if they are in an encrypted backup.

00:05:13.960 --> 00:05:21.290
So this was kind the last kind of excuse not to use
the Keychain is that your credentials wouldn't move

00:05:21.290 --> 00:05:23.530
from device to device when your users upgrade.

00:05:23.530 --> 00:05:24.700
Well, now they do.

00:05:24.700 --> 00:05:28.000
In an encrypted back-up scheme, they just move right across.

00:05:28.000 --> 00:05:33.400
So passcodes, we are tying this to the passcodes.

00:05:33.400 --> 00:05:38.760
But I want to remind everyone that the passcode
is only as good as you make the passcode.

00:05:38.760 --> 00:05:40.580
And passcodes can be pretty forced.

00:05:40.580 --> 00:05:46.470
So if you choose one, two, three, four as
your passcode, it's not gonna be very strong.

00:05:46.470 --> 00:05:47.470
Someone is going to guess that.

00:05:47.470 --> 00:05:53.180
So we put a bunch of mitigations in place.

00:05:53.180 --> 00:05:59.310
Now, the first mitigation that we've always had in
place is that we have back off between failed attempts

00:05:59.310 --> 00:06:02.390
on using the UI to putting someone's passcode.

00:06:02.390 --> 00:06:06.000
So it's kind of incremental as you have failed attempts.

00:06:06.000 --> 00:06:10.270
But by the sixth failed attempt, it takes
like, 10 minutes for the UI to come back up

00:06:10.270 --> 00:06:12.300
and offer to you to put your passcode here.

00:06:12.300 --> 00:06:15.980
So this makes, you know, someone who's
stolen your device, if they are just trying

00:06:15.980 --> 00:06:19.420
to punch the numbers it makes it
pretty difficult for them to guess.

00:06:19.420 --> 00:06:22.070
It takes them a long time.

00:06:23.400 --> 00:06:28.470
Now, we've also had the ability to
force complex passcodes on the device.

00:06:28.470 --> 00:06:32.690
We've had this for a while with configuration profiles.

00:06:32.690 --> 00:06:39.070
Now, what's new for iOS 4 is we actually give
you a user-configurable setting in the settings--

00:06:39.070 --> 00:06:47.110
on the settings tab to actually force the
complex-- or to actually use a complex passcode.

00:06:47.110 --> 00:06:52.310
Also, we've had the ability to force
and erase of all the user's data

00:06:52.310 --> 00:06:54.840
after a failed numbers of attempts at the passcode.

00:06:54.840 --> 00:07:03.700
This is also something in iOS 4 that
we've made user-configurable in settings.

00:07:03.700 --> 00:07:10.320
Now, another thing that we did in tying
all the data to the passcode is we, not--

00:07:10.320 --> 00:07:16.690
didn't just tie it to the passcode itself, we also
tied it into a set of device keys in the hardware.

00:07:16.690 --> 00:07:24.420
And the reason that we did this is that it makes it--
it prevents people from taking the data off the device

00:07:24.420 --> 00:07:29.030
and trying to brute force passcodes
there, since it's actually encrypted also

00:07:29.030 --> 00:07:31.710
with a key that's only available in the hardware.

00:07:31.710 --> 00:07:36.990
That means that you actually have to-- someone would
actually have to do an attack on that hardware itself.

00:07:36.990 --> 00:07:40.680
And our hardware is fast, but it's not as fast as a botnet.

00:07:40.680 --> 00:07:45.550
So this actually limits the speed
of an attack on these passcodes.

00:07:48.410 --> 00:07:53.820
So I want to kind of just run through
what technologies we put in iOS

00:07:53.820 --> 00:07:59.510
and kind of why we put them there
over the generations of releases.

00:07:59.510 --> 00:08:04.100
So obviously, we have had, since
the first iPhone, a passcode.

00:08:04.100 --> 00:08:09.550
And this was really, you know, at that
time meant to prevent casual device access.

00:08:09.550 --> 00:08:12.090
It was meant to stop someone, kind of, at the door

00:08:12.090 --> 00:08:15.870
and make them know one number before
they could actually use that device.

00:08:15.870 --> 00:08:21.620
Now, even at that point in time, we had
some Privilege Separation and Sandboxing.

00:08:21.620 --> 00:08:28.350
And what Privilege Separation is, it means that
applications, either in the OS or third party applications,

00:08:28.350 --> 00:08:33.070
only have access to those services
that they have privileges for.

00:08:33.070 --> 00:08:42.140
And Sandboxing is that basically, they only have access
to those documents or API's that they have privileges for.

00:08:42.140 --> 00:08:49.820
Now, this has kind of evolved over time because obviously,
in the first release of iOS, there was no third party apps.

00:08:49.820 --> 00:08:57.350
And as we added third party apps, we added more
Sandboxing, we put those apps in the Sandbox.

00:08:57.350 --> 00:09:02.470
Now, for iOS 2, we also added Code Signing.

00:09:02.470 --> 00:09:06.020
And the reason that we did this
is that now, the user knows that--

00:09:06.020 --> 00:09:12.080
they know that there is known origins
for every piece of code on their device.

00:09:12.080 --> 00:09:17.970
This makes it much more difficult to spread around viruses
and the like because you can actually trace it back

00:09:17.970 --> 00:09:25.030
to whether it's an enterprise, inhouse app, or whether it's
an app from the App Store, or whether it's code from Apple.

00:09:25.030 --> 00:09:28.160
We also added Remote Wipe at that time.

00:09:28.160 --> 00:09:31.650
Now this would, you know, like I said
before, erases all the data in the phone,

00:09:31.650 --> 00:09:34.280
if that phone is still online, you can send it a signal.

00:09:34.280 --> 00:09:41.030
And obviously, at that time, what has to
happen is we actually had to overwrite the data

00:09:41.030 --> 00:09:43.960
with zeros essentially, to erase that data.

00:09:43.960 --> 00:09:50.110
And then actually, it was a pretty long process,
especially for the larger storage devices.

00:09:50.110 --> 00:09:52.830
So last year, we added encrypted storage.

00:09:52.830 --> 00:09:57.270
The main reason for that is to
make Remote Wipe very, very fast,

00:09:57.270 --> 00:10:04.210
and we added encrypted backups, which
protects the data off the device.

00:10:04.210 --> 00:10:07.040
And now, we're adding data protection.

00:10:07.040 --> 00:10:15.480
And this really means that even if a device is compromised
in some way, it's stolen and it's a compromised device,

00:10:15.480 --> 00:10:21.290
that user's data is still protected because it's
protected with something that only that user knows.

00:10:21.290 --> 00:10:25.530
So you can see where this is all going here.

00:10:25.530 --> 00:10:32.580
We want all the apps to adopt data protection, both
throughout the OS and throughout all of your apps.

00:10:32.580 --> 00:10:36.460
So we start it with Mail which is the most complex app,

00:10:36.460 --> 00:10:40.980
and we want you to go through your app
and choose how your data is protected.

00:10:40.980 --> 00:10:46.610
Now, the big thing here is that for app surges
in the foreground, when the device is locked

00:10:46.610 --> 00:10:52.230
and not doing anything, it's pretty easy to choose
they want their data protected by the passcode.

00:10:52.230 --> 00:10:56.920
If you are doing some kind of multitasking
app that has some kind of background task,

00:10:56.920 --> 00:10:58.730
you have to be a little bit more careful with your data,

00:10:58.730 --> 00:11:04.290
and you have to choose a few different
classes to figure out how to do that.

00:11:04.290 --> 00:11:09.130
But we want you to start adopting these
API's and these concepts into your apps

00:11:09.130 --> 00:11:15.020
because our real ultimate goal here is
that when the user puts on their passcode,

00:11:15.020 --> 00:11:18.540
they know all their data is protected no matter what.

00:11:18.540 --> 00:11:21.960
So I'd like to invite up Mitch Adler,
one of our Security Architects,

00:11:21.960 --> 00:11:25.160
to talk a little bit about-- more
about the mechanism behind us.

00:11:25.160 --> 00:11:25.730
[ Applause ]

00:11:25.730 --> 00:11:31.070
>> Mitch Adler: Thanks, John.

00:11:31.070 --> 00:11:36.250
As John said, I'm going to take you on a little deeper
dive into the mechanisms we put together in our system

00:11:36.250 --> 00:11:39.580
to help protect the user's data with their passcode.

00:11:39.580 --> 00:11:45.540
It-- the goal, as John said, is that when
the device is locked, the user should be able

00:11:45.540 --> 00:11:47.570
to be confident that their device is protected.

00:11:47.570 --> 00:11:53.490
And in iOS 3, we were relatively confident that if
I-- my device is locked and I hand it to somebody

00:11:53.490 --> 00:11:57.640
and I watch them not penetrate the defense of
the device, they're not going to be able to get

00:11:57.640 --> 00:12:02.750
through my passcode very easily because we limit the
tries and all of the mitigations that John talked about.

00:12:02.750 --> 00:12:08.150
But for iOS 4, we want to provide a mechanism that the user
can be confident that even if they've lost their device,

00:12:08.150 --> 00:12:12.180
if their passcode, if their device is
locked, that their data is actually protected

00:12:12.180 --> 00:12:15.060
with their passcode, the strength to their passcode.

00:12:15.060 --> 00:12:21.380
That requires that we actually encrypt their
data with some derivation of their passcode.

00:12:21.380 --> 00:12:24.690
And this is very useful, but we run into a problem.

00:12:24.690 --> 00:12:30.820
And that problem is that applications want to use
some of that data sometimes when the device is locked.

00:12:30.820 --> 00:12:37.040
So we needed to provide a mechanism for applications to
specify jar system how they want given data protected.

00:12:37.040 --> 00:12:41.150
That mechanism is data protection classes.

00:12:41.150 --> 00:12:46.920
There are three data protection classes that
we have established in our system in our API.

00:12:46.920 --> 00:12:50.110
The first class is available and unlocked.

00:12:50.110 --> 00:12:51.650
That's the most protecting class.

00:12:51.650 --> 00:12:56.760
The availability and the protection are kind of reverse
of each other, when something is available to the system

00:12:56.760 --> 00:13:00.150
than an attacker who manages to
get through our outer protections

00:13:00.150 --> 00:13:04.510
and get inside the system can masquerade
as an application and access that data.

00:13:04.510 --> 00:13:09.510
So if you set your data be able-- if you
set your protection class to one that to--

00:13:09.510 --> 00:13:14.650
WhenUnlocked, we'll protect the data
cryptographically when the system is locked,

00:13:14.650 --> 00:13:17.640
and we'll make it available to your app when it's unlocked.

00:13:17.640 --> 00:13:20.650
The second class is available after fist unlock.

00:13:20.650 --> 00:13:23.370
This is the kind of compromise class.

00:13:23.370 --> 00:13:28.490
We noted that many of the attacks on the device that
compromise devices and get access to running code

00:13:28.490 --> 00:13:30.570
on the device requires the device reboot.

00:13:30.570 --> 00:13:36.170
In the process of rebooting, we can
reset things that have been exposed.

00:13:36.170 --> 00:13:41.830
So we add the second class, so that if there is data that
you need to continue accessing while the device is locked,

00:13:41.830 --> 00:13:46.390
for example, credentials to reconnect to your server because
you've changed networks and now you need to reconnect

00:13:46.390 --> 00:13:53.210
and revalidate, you can protect those credentials
better than not at all, but still have them available

00:13:53.210 --> 00:13:56.700
when the device locks and unlocks, because after
the first unlock, it will be available for you.

00:13:56.700 --> 00:14:02.410
And then if somebody attacks the device and then
forces it to reboot, we'll reprotect that data.

00:14:02.410 --> 00:14:05.990
The last availability class is what we've
had traditionally on all of our storage

00:14:05.990 --> 00:14:09.820
up to this date, which is it's available always.

00:14:09.820 --> 00:14:14.090
It is no less protected than it has been in the past,
but it doesn't gain anything from data protection.

00:14:14.090 --> 00:14:18.900
But it's a way to express that need, if I
need my data to be exactly the same as it is.

00:14:18.900 --> 00:14:26.860
So the two major clients of these classes that present
them to you in the file system, which presents availability

00:14:26.860 --> 00:14:34.450
for WhenUnlock called ProtectionComplete and
that available always called ProtectionNone,

00:14:34.450 --> 00:14:42.900
under the Keychain which provides availability for
all three, WhenUnlocked, AfterFirstUnlock, and Always.

00:14:42.900 --> 00:14:52.770
So these two clients, there is some risk that if the
two clients were sharing all of their keys and classes,

00:14:52.770 --> 00:14:57.190
that if I were a client of one of the systems, I could
use it to attack data stored in the other system.

00:14:57.190 --> 00:15:00.840
So for that reason, we make these very much independent.

00:15:00.840 --> 00:15:03.370
They have very intentionally similar semantics.

00:15:03.370 --> 00:15:05.840
So when you're thinking about how you store your data,

00:15:05.840 --> 00:15:08.620
you can think about the problem
the same way for the two systems.

00:15:08.620 --> 00:15:13.050
But from the point of view of how the data is
protected, we use completely separate class keys

00:15:13.050 --> 00:15:15.880
to represent those classes, so we can isolate--

00:15:15.880 --> 00:15:20.010
the people can access the Keychain from the people
who are allowed to access the data on the file system.

00:15:20.010 --> 00:15:28.130
I'm going to run through a quick example to
demonstrate how we take some data that the user has

00:15:28.130 --> 00:15:33.410
and protect it through our new design system in iOS 4.

00:15:33.410 --> 00:15:41.190
So here's an example of a file, a mail that I happen
to compose on the device, and it needs to be protected.

00:15:41.190 --> 00:15:47.420
In iOS 4, every file in the file system or
how it's made is protected with a file key.

00:15:47.420 --> 00:15:51.840
This is slightly different than it was in iOS 3 and
that the whole file system is protected by a key.

00:15:51.840 --> 00:15:57.780
But in iOS 4, there's a randomly generated
new key for every file that gets created.

00:15:57.780 --> 00:16:01.160
That file key is stored in the files metadata.

00:16:01.160 --> 00:16:04.220
That file key is, in turn, protected by a class key.

00:16:04.220 --> 00:16:06.420
This is a class-- a key that was randomly generated

00:16:06.420 --> 00:16:10.860
at the time the class was established,
and it protects the file key.

00:16:10.860 --> 00:16:12.900
If you don't have the class key, can't see the file key.

00:16:12.900 --> 00:16:16.100
If you don't have the file key, you
can't see the contents of the file.

00:16:16.100 --> 00:16:21.960
Each class key is protected by an appropriate set
of keys in the system depending on its semantics.

00:16:21.960 --> 00:16:29.050
In this particular case, this is a-- protected with the
user pin key, it's protected by two keys, the device key,

00:16:29.050 --> 00:16:36.100
to make attacks off the device less practical,
and the user passcode key which is the tie

00:16:36.100 --> 00:16:39.850
that ties the protection of the file back to the passcode.

00:16:39.850 --> 00:16:43.810
The file is protected by the file key, the
file key is protected by the class key,

00:16:43.810 --> 00:16:47.170
the class key is protected by the user passcode key.

00:16:47.170 --> 00:16:51.420
There's one more thing that we needed
to support in this architecture,

00:16:51.420 --> 00:16:55.530
and that was the ability to do fast Remote Wipe.

00:16:55.530 --> 00:16:59.070
In the past we have thrown away the one
master file system key and it erased--

00:16:59.070 --> 00:17:01.430
cryptographically erased the entire file system.

00:17:01.430 --> 00:17:07.520
Now that we don't have exactly one master key, we had
to build one back in, and that's on all the metadata.

00:17:07.520 --> 00:17:12.030
The file metadata has file system
key, that key, when erased,

00:17:12.030 --> 00:17:14.980
makes it cryptographically impossible
to view the data on the file.

00:17:14.980 --> 00:17:24.940
So to take this particular example, and show you
how we take a collection of data and protect it,

00:17:24.940 --> 00:17:28.990
for an entire file system, we can have one
file, like we just showed you, protected,

00:17:28.990 --> 00:17:34.640
the file protected by it's file key, the file key protected
by it's class key, and the class key protected appropriately

00:17:34.640 --> 00:17:37.460
by a device key in our user passcode key.

00:17:37.460 --> 00:17:42.940
But since we've gone through this class key, we can
have as many files as we'd like protected in this class.

00:17:42.940 --> 00:17:48.480
So there's no limit, the class-- the-- each
file can specify it belongs to this class.

00:17:48.480 --> 00:17:51.570
We also don't have to limit ourselves
to how many classes we want.

00:17:51.570 --> 00:17:56.370
We can have a second class with exactly the same
protections and maybe some different semantics

00:17:56.370 --> 00:18:01.790
on how you get the class key, and we can store
it on the same data storage, same file system.

00:18:01.790 --> 00:18:03.630
We can have a third class with different semantics.

00:18:03.630 --> 00:18:06.400
In this particular example, this would be accessed always.

00:18:06.400 --> 00:18:09.980
There's no protection that extends from
the user passcode key to this class key.

00:18:09.980 --> 00:18:15.000
So this is how we store on our system things that are
always available that are protected by the device key,

00:18:15.000 --> 00:18:17.280
but they're not protected by the user passcode key.

00:18:17.280 --> 00:18:24.330
The collection of classes that protect
data on the system, we call a keybag.

00:18:24.330 --> 00:18:31.430
The-- that collection of class keys is an
important structure in our architecture.

00:18:31.430 --> 00:18:36.350
It's what embodies locking, unlocking,
and protection states.

00:18:36.350 --> 00:18:41.410
There are three kinds of keybags
we operate in our system with.

00:18:41.410 --> 00:18:46.020
There's the System Keybag, there's a Backup
Keybag, and there's an Escrow Keybag.

00:18:46.020 --> 00:18:49.670
The first two are relatively important
for everybody to understand.

00:18:49.670 --> 00:18:54.320
The last one is an interesting detail for anybody
who wants to do security analysis on their device.

00:18:55.850 --> 00:18:59.320
System keybags, these are the ones
you'd imagine, as I've just described,

00:18:59.320 --> 00:19:01.480
they're sitting on the system,
they're protecting your system.

00:19:01.480 --> 00:19:06.240
They hold the class keys for all
the data that's on your system.

00:19:06.240 --> 00:19:08.180
They have one tweak they do.

00:19:08.180 --> 00:19:13.500
They force all of the class keys, and
then to be protected with the device key

00:19:13.500 --> 00:19:18.090
that makes it hard to attack this keybag off the device.

00:19:18.090 --> 00:19:20.150
They're stored on the system.

00:19:20.150 --> 00:19:24.630
They're actually stored on the file system, which
is interesting, because the fact that they're stored

00:19:24.630 --> 00:19:31.790
in the file system means that if you use a weak
passcode that's trying to protect this keybag,

00:19:31.790 --> 00:19:38.410
and we leave that data on the file system, somebody later
can come and find it even if we've moved on to a new keybag

00:19:38.410 --> 00:19:41.700
and use that old keybag to try and steal your class keys.

00:19:41.700 --> 00:19:44.220
Because when passcodes change,
we don't change the class keys.

00:19:44.220 --> 00:19:49.000
That way, we don't have to scour the entire file
system trying to update it for this metadata.

00:19:49.000 --> 00:19:54.950
So in order to mitigate that attack, we
actually protect the storage of the keybag

00:19:54.950 --> 00:19:58.610
on the file system with a key that we can erase.

00:19:58.610 --> 00:20:03.380
Every time the user changes the
passcode, we destroy the old key,

00:20:03.380 --> 00:20:07.540
we write a new copy of the Keychain out of
the keybag out, and we write a new--

00:20:07.540 --> 00:20:10.040
we use a new key, and we randomly generate a key.

00:20:10.040 --> 00:20:15.060
So we've cryptographically erased the old
keybag so that it's older, maybe weaker,

00:20:15.060 --> 00:20:18.550
passcode protection is not exposing my device anymore.

00:20:18.550 --> 00:20:26.070
The system keybag is also responsible for
managing the lock and unlock state of the system.

00:20:26.070 --> 00:20:32.110
When the user enters their passcode, the system keybag
is asked to expose the class keys that should be exposed

00:20:32.110 --> 00:20:38.690
when the device unlocked, and when it's told the device is
locking, it discards those keys, forgets those class keys.

00:20:38.690 --> 00:20:44.840
So it's-- this is the center of the universe of the device
locking and unlocking and protecting the user's data.

00:20:44.840 --> 00:20:50.330
But in order for us to maintain our encrypted
backups and to maintain our protection

00:20:50.330 --> 00:20:53.950
through it, we also created backup keybags.

00:20:53.950 --> 00:20:57.650
Backup keybags are created new for every back up.

00:20:57.650 --> 00:21:03.840
Their class keys are generated randomly and are
different for every backup you've-you storeon your host.

00:21:03.840 --> 00:21:08.440
This holds the class keys that protects the data
while it sits in the backup on those machine.

00:21:08.440 --> 00:21:15.630
These class keys, instead of being protected by
the pin, are protected by the backup password.

00:21:15.630 --> 00:21:20.100
So when you have a protected backup, we-- everyone
who would have used the pin on the device are going

00:21:20.100 --> 00:21:24.120
to be using the backup password
in the protected backup keybag.

00:21:24.120 --> 00:21:30.560
We happened to use PBKDF2, for
those who care to generate the key.

00:21:30.560 --> 00:21:36.050
I don't remember the number of iterations off top of my
head, happy to look it up for you if you want to know.

00:21:36.050 --> 00:21:43.280
If you don't choose to have a backup password though, we do
one thing to protect credentials that are on the Keychain.

00:21:43.280 --> 00:21:50.260
If you don't choose to protect your backup, we protect
some of the Keychain class keys with the device key,

00:21:50.260 --> 00:21:53.310
and not the backup password key,
causing them not to be able to migrate,

00:21:53.310 --> 00:21:55.870
and we'll get into that in more detail later in Adoption.

00:21:55.870 --> 00:22:04.090
The last kind of keybag is a keybag
we created to enhance user experience.

00:22:04.090 --> 00:22:07.180
It was created for systems to be able to hold on to.

00:22:07.180 --> 00:22:08.510
It's called the Escrow Keybag.

00:22:08.510 --> 00:22:12.620
It was created for other systems to
hold on to improve user experience.

00:22:12.620 --> 00:22:18.700
The downside is that the improved user experience
we want is systems that sync with your device,

00:22:18.700 --> 00:22:21.680
can sync without you having to
enter the passcode on your device.

00:22:21.680 --> 00:22:27.420
And right there conceptually, is a security issue, in that
now there is data in the world that can unlock my device.

00:22:27.420 --> 00:22:29.720
So we did a few things to mitigate it.

00:22:29.720 --> 00:22:34.160
First, we considered that the system
that you're storing the Escrow Keybag

00:22:34.160 --> 00:22:36.660
on is a system you're already syncing you data to.

00:22:36.660 --> 00:22:41.760
So if somebody can compromise that system and
get your Escrow Keybag, additionally being able

00:22:41.760 --> 00:22:48.060
to compromise your device, if they can get their hands
on your device, is not a big leap in security weakness.

00:22:48.060 --> 00:22:52.870
It's a little-- it's irritating and annoying
but it's not of great loss, because most likely,

00:22:52.870 --> 00:22:56.150
all of your sync data is sitting
on that host that was compromised.

00:22:56.150 --> 00:23:00.540
Them getting your Escrow Keybag is a
potential future problem, but immediately,

00:23:00.540 --> 00:23:04.270
they've probably already taken all of your data.

00:23:04.270 --> 00:23:11.860
The other thing we do is that we keep a key on the
original device so we can invalidate the Escrow Keybag.

00:23:11.860 --> 00:23:15.370
It's part of the protection.

00:23:15.370 --> 00:23:22.040
The class keys in this keybag are protected with a device
key, so this keybag can't be brute force except with access

00:23:22.040 --> 00:23:27.630
to the device, and the key we generated when we
made the Escrow Keybag and stored on the device.

00:23:27.630 --> 00:23:30.720
So if we could throw that key away on the device,

00:23:30.720 --> 00:23:36.220
we can make that Escrow Keybag cryptographically
incapable of reading the data on the device.

00:23:36.220 --> 00:23:40.070
So anytime we decide that somebody's not worthy
of trust, we can throw away the key, of course,

00:23:40.070 --> 00:23:44.660
part of the Escrow Keybag, and
they can't access our data anymore.

00:23:44.660 --> 00:23:50.650
Something I didn't mention is the Escrow Keybag
does contain actual copies of the master class keys

00:23:50.650 --> 00:23:55.960
for the devices classes, which is why it can
unlock the device without the user's passcode.

00:23:55.960 --> 00:24:06.790
So to dive a little deeper into the filesystem
protection, all of the filesystem data is encrypted.

00:24:06.790 --> 00:24:07.980
Everything on the filesystem.

00:24:07.980 --> 00:24:10.460
It has been since iOS 3.

00:24:10.460 --> 00:24:14.580
We've changed how we encrypt out the data on the filesystem.

00:24:14.580 --> 00:24:17.570
The metadata uses the filesystem
key as I showed you in the diagram.

00:24:17.570 --> 00:24:25.650
That's what destroyed on Remote Wipe and breaks the chain
of cryptographic exposure, so we-- your data is not exposed.

00:24:25.650 --> 00:24:31.330
The files are encrypted to an individual
file key which is stored in the metadata.

00:24:31.330 --> 00:24:34.960
The default, when you're creating a
new file in iOS 4, is ProtectionNone.

00:24:34.960 --> 00:24:37.980
This is mostly for compatibility with applications,

00:24:37.980 --> 00:24:41.660
we don't want you to break all the
applications that do anything across lock.

00:24:41.660 --> 00:24:45.270
We want them to opt in and decide what
they-- how they want to protect it.

00:24:45.270 --> 00:24:47.480
And again, a reminder, there's no performance impact.

00:24:47.480 --> 00:24:49.990
We are already encrypting and decrypting.

00:24:49.990 --> 00:24:56.610
We've just changed what keys we're using in the process
of pushing stuff back and forth to the file system.

00:24:56.610 --> 00:25:07.770
The Keychain-- it's also protected by classes just for the
Keychain, as the concept of migratable and not migratable.

00:25:07.770 --> 00:25:13.540
That as-- that actually doubles the number of classes that
are available for the Keychain because you can put a piece

00:25:13.540 --> 00:25:17.570
of data into any of the three classes,
and either migratable or not migratable.

00:25:17.570 --> 00:25:23.010
The default on the Keychain will remove
data from back to a device by iOS 4,

00:25:23.010 --> 00:25:29.950
or if you create data without adopting data
protection, will be always as migratable.

00:25:29.950 --> 00:25:34.960
The three new classes that aren't
migratable have the suffix ThisDeviceOnly.

00:25:34.960 --> 00:25:41.860
So WhenUnlock, ThisDeviceOnly, WhenUnlock--
AfterFirstUnlock, ThisDeviceOnly, AlwaysThisDeviceOnly.

00:25:41.860 --> 00:25:47.060
So this is a change that is in significance to people who
want to protect data and don't want it to move form device

00:25:47.060 --> 00:25:51.910
to device, because our default now is going to
allow things to migrate through a protected backup.

00:25:51.910 --> 00:25:54.680
We thought that was the right compromise
for user experience.

00:25:54.680 --> 00:26:01.220
But if you have data that is really not supposed to migrate
off of this device ever, you'll need to update your use

00:26:01.220 --> 00:26:08.370
to annotate that data and say it's not supposed to migrate.

00:26:08.370 --> 00:26:10.640
Handling of the passcode.

00:26:10.640 --> 00:26:17.020
So one of the most critical things in trying to keep
the user secret a secret is how we handle the passcode,

00:26:17.020 --> 00:26:19.620
because we have given that secret,
and we have it for a while,

00:26:19.620 --> 00:26:21.580
and we really don't want to keep
it because it's the user secret.

00:26:21.580 --> 00:26:23.590
It's not our secret.

00:26:23.590 --> 00:26:27.740
So we do two things to try and
help protect that user secret.

00:26:27.740 --> 00:26:37.630
The first thing we do is try and make it difficult to
brute force attack the key that we derive from the passcode

00:26:37.630 --> 00:26:41.160
to avoid simple brute forcing the-- a user's passcode.

00:26:41.160 --> 00:26:45.960
And as John mentioned, we take a hardware key, something
that's actually embedded in hardware individual

00:26:45.960 --> 00:26:53.120
to a given device, we do a derivation with that
hardware key which resembles PBKDF2, but isn't exactly,

00:26:53.120 --> 00:27:03.220
and do a bunch of iterations to make you need to use
that device in order to be able to attack the passcode.

00:27:03.220 --> 00:27:08.500
This means that an attacker whose managed to get access
to your device, broken through our outer defenses,

00:27:08.500 --> 00:27:13.840
gotten to the point where he's got a copy of
your system keybag and wants to try to unlock it,

00:27:13.840 --> 00:27:17.130
and knows what it should look like-- what the
header it should look like if it's unlocked,

00:27:17.130 --> 00:27:21.490
actually has to keep trying on
that device to unlock that keybag.

00:27:21.490 --> 00:27:28.530
This helps us be able to control
the time it takes to attack once.

00:27:28.530 --> 00:27:33.840
For example on an iPhone 4, on a new
hardware, we use 50,000 hardware operations

00:27:33.840 --> 00:27:37.010
to drive the key from the original passcode.

00:27:37.010 --> 00:27:39.730
It takes about 50 milliseconds, give or take.

00:27:39.730 --> 00:27:44.180
And if you do the math from there, for a
reasonable passcode somebody's put on the device,

00:27:44.180 --> 00:27:48.420
it starts taking significant amounts of time,
cryptographically interesting amounts in time,

00:27:48.420 --> 00:27:51.970
for you to brute force somebody's passcode.

00:27:51.970 --> 00:27:59.090
The other thing we do is we handle the
passcode and the passcode key very carefully.

00:27:59.090 --> 00:28:04.890
When we've given the passcode, and we to return it into a
passcode key, we're careful to erase remnants to make sure

00:28:04.890 --> 00:28:07.180
that the user secrets stays the user secret.

00:28:07.180 --> 00:28:12.430
The thing we retain when the device
unlocks, are the exposed class keys.

00:28:12.430 --> 00:28:17.890
So when we move from state to state, class keys
come and go, and they're available and they're not.

00:28:17.890 --> 00:28:23.800
Example of this, a device boot, we start
out-- we don't know the user's passcode,

00:28:23.800 --> 00:28:26.470
he's never entered it, we're fresh and clean.

00:28:26.470 --> 00:28:34.960
The only class that is available is the always class,
ProtectionNone, AlwaysThisDeviceOnly are available,

00:28:34.960 --> 00:28:37.820
the first two protection classes
aren't available yet because we don't--

00:28:37.820 --> 00:28:40.380
we haven't been able to unwrap the class keys.

00:28:40.380 --> 00:28:45.640
When the user enters their passcode,
we unwrap the class keys, we--

00:28:45.640 --> 00:28:51.740
if we get their passcode and their passcode key that help
protect the class keys, but we keep this class keys around.

00:28:51.740 --> 00:28:54.070
So now, all of the classes are available.

00:28:54.070 --> 00:28:59.720
WhenUnlock, AfterFirstUnlock, they're all available,
the device operates, people do their normal operations.

00:28:59.720 --> 00:29:04.860
But at some point, the device gets
locked, either by idling to lock

00:29:04.860 --> 00:29:08.600
or by the user clicking the lock button
and wanting the device to lock itself.

00:29:08.600 --> 00:29:12.840
When that happens we forget the
class keys for the first class.

00:29:12.840 --> 00:29:17.390
So that things that are only available when unlocked
are no longer available, the device is locked.

00:29:17.390 --> 00:29:23.770
Note that the second class stays around as is defined
after FirstUnlock, it remains available until we reboot,

00:29:23.770 --> 00:29:27.860
then we'll get back into the initial
state, we've lost all the class keys.

00:29:27.860 --> 00:29:35.500
So in summary about our mechanism and how we put this
all together, our protection extends through a keybag,

00:29:35.500 --> 00:29:40.490
it comes from the user's secrets and device keys
to bind it to the device and bind it to the user,

00:29:40.490 --> 00:29:44.640
it goes to the filesystem in the Keychain
and the data stored in those places.

00:29:44.640 --> 00:29:51.720
The passcode key derivation has been made resistant to
brute force attack to help protect the user's passcode.

00:29:51.720 --> 00:29:56.300
And the Keychain contents have been made
migratable when we have protected backups.

00:29:56.300 --> 00:30:03.250
And with that, I'll hand it back to John
to talk some more about configuration.

00:30:03.250 --> 00:30:04.510
>> John Wright: Thanks, Mitch.

00:30:04.510 --> 00:30:11.040
[ Applause ]

00:30:11.040 --> 00:30:17.880
. So for user-enabled data protection,
actually on an iPhone 4, it's extremely simple.

00:30:17.880 --> 00:30:19.750
The formats already there in the device.

00:30:19.750 --> 00:30:26.270
All they have to do is set a passcode,
and data protection is enabled.

00:30:26.270 --> 00:30:35.110
Now, on our last generation of devices, including iPhone
3GS and the iPod touch, the 3rd generation iPod touch,

00:30:35.110 --> 00:30:43.200
it's a little bit more complicated and that we don't
have the right file system format on those devices,

00:30:43.200 --> 00:30:44.890
and you have to upgrade the file system format.

00:30:44.890 --> 00:30:47.460
And the way we do that is with an Erase Install.

00:30:47.460 --> 00:30:54.680
And so, the user has to backup their device, do a
full Erase Install, and then restore from that backup.

00:30:54.680 --> 00:31:04.160
And of course, the iPad is also capable of doing
this, and it will inherit this feature with iOS 4,

00:31:04.160 --> 00:31:09.020
and it will also require an Erase
Install to get that feature.

00:31:09.020 --> 00:31:16.180
Now, to check to see if Data Protection is enabled
if you go to Settings-> General-> Passcode Lock,

00:31:16.180 --> 00:31:25.950
and there is a picture right there, if you look at
that little string at the very bottom of that screen,

00:31:25.950 --> 00:31:27.940
it basically says Data Protection is enabled.

00:31:27.940 --> 00:31:29.650
So now, you know you have it on that device.

00:31:29.650 --> 00:31:35.010
Now, I want to point out a couple
of other things on this screen.

00:31:35.010 --> 00:31:43.440
So I told you before that users now can configure their
device to be able to Wipe if-- on 10 failed passcode events.

00:31:43.440 --> 00:31:45.520
That is that setting right there.

00:31:45.520 --> 00:31:54.110
And they're also able to set a arbitrary complex
passcode by turning off the simple passcode,

00:31:54.110 --> 00:31:58.790
and then the dialog that comes up to change
their passcode is a full alpha numeric keyboard,

00:31:58.790 --> 00:32:02.520
and they can choose what size length complexity they want.

00:32:06.400 --> 00:32:13.940
Now, for devices that are being managed and our system
to manage these devices is-- our Configuration Profiles.

00:32:13.940 --> 00:32:18.670
You can set this Configuration Profiles
to enforce certain security requirements,

00:32:18.670 --> 00:32:21.510
and I'd like to point a few of those out there.

00:32:21.510 --> 00:32:26.940
So, the first one is that you can require
data protection to be enabled on that device.

00:32:26.940 --> 00:32:34.370
You can also require a passcode be set, the link of
that passcode, and the complexity of that passcode.

00:32:34.370 --> 00:32:40.830
You can also require a minimum passcode grace
period, and the grace period is how long a user has

00:32:40.830 --> 00:32:48.320
from the time they turn off the screen to when they
turn on the screen again that it requires a passcode.

00:32:51.710 --> 00:32:58.710
And you can also inquire that all the backups
from that device are encrypted backups.

00:32:58.710 --> 00:33:07.670
Now, something else that we're introducing with
iOS 4 is a way to manage your mobile devices,

00:33:07.670 --> 00:33:14.150
a bunch of API's actually use these
Configuration Profiles with third party servers

00:33:14.150 --> 00:33:17.520
and third party device management systems.

00:33:17.520 --> 00:33:26.040
And these device management systems will be capable of
doing initial device configuration and automatic updates

00:33:26.040 --> 00:33:31.490
of these Configuration Profiles, and then also be
able to implement their own Remote Wipe capabilities.

00:33:31.490 --> 00:33:37.610
And there was a whole session on Tuesday
that went over how these API's work.

00:33:37.610 --> 00:33:44.410
And we've assumed that third parties will be
adopting these into their device management systems.

00:33:44.410 --> 00:33:51.430
So that really makes a very capable
management system for you guys to be able

00:33:51.430 --> 00:33:55.780
to implement these security type-- or
these security requirements as well.

00:33:58.870 --> 00:34:03.220
So the whole idea here is that we want
configurations to be dead-simple for any users.

00:34:03.220 --> 00:34:06.300
We really don't want them to think about
it other than they set their passcode.

00:34:06.300 --> 00:34:11.780
And we want these security requirements
to be fully manageable by enterprises.

00:34:11.780 --> 00:34:16.970
And that's really the whole configuration story there.

00:34:16.970 --> 00:34:23.090
So I'm going to turn it over to Mitch to talk a
little bit about adoption of these API's in your apps

00:34:25.770 --> 00:34:30.680
>> Mitch Adler: So I'm going to talk a bit about
how you adopt Data Protection in your application.

00:34:30.680 --> 00:34:36.740
To go back to what John was talking about a little
bit, we really want to protect your customer's data,

00:34:36.740 --> 00:34:41.980
we want to protect all of our mutual customer's data,
we want you to assume the data needs protection.

00:34:41.980 --> 00:34:46.170
You don't actually know what data users
are going to decide to put inside your app.

00:34:46.170 --> 00:34:49.190
If you're making a note-taking app, they might
put their credit card number in your app.

00:34:49.190 --> 00:34:53.860
It doesn't seem like a good idea
to me, but they might do it.

00:34:53.860 --> 00:34:57.150
We need you to help put the data into the right class.

00:34:57.150 --> 00:35:02.820
Since we don't automatically try and protect all your
data to preserve functionality of your application,

00:35:02.820 --> 00:35:05.360
we need help from you to know how
you want that data protected,

00:35:05.360 --> 00:35:08.720
so that we can do the best protection we can for the user.

00:35:08.720 --> 00:35:11.460
We recommend you find the most protected
class, and we'll get it to how you decide

00:35:11.460 --> 00:35:12.780
on what's the most protective class you can.

00:35:12.780 --> 00:35:14.380
It's here.

00:35:14.380 --> 00:35:19.530
We also want you to help put the user data back
into places that's protected because the file system

00:35:19.530 --> 00:35:22.690
and the Keychain are protected by Data Protection.

00:35:22.690 --> 00:35:26.510
RAM, you have your user's information and
it's not protected by Data Protection.

00:35:26.510 --> 00:35:32.000
So somebody can attack the device and get
into your process, which is not an easy feat.

00:35:32.000 --> 00:35:34.090
But if they can do it, they can steal data that's in RAM.

00:35:34.090 --> 00:35:39.240
So we recommend that you push the data out of RAM, push
it into the protected containers when the device locks.

00:35:39.240 --> 00:35:43.540
So one of the first things you're
going to have to do when you're going

00:35:43.540 --> 00:35:48.250
to adopt is analyze your data to
figure out what you need to protect.

00:35:48.250 --> 00:35:51.670
You pretty much need to answer these four
questions, and you can figure out what class

00:35:51.670 --> 00:35:54.650
and what location and how you want to protect that data.

00:35:54.650 --> 00:35:59.320
The questions are what data of the users do I
have, do I need it when it's locked, you know,

00:35:59.320 --> 00:36:05.070
does it belong in the Keychain, should it move from
device to device, and we'll get in to each one of these.

00:36:05.070 --> 00:36:07.460
So how do I answer what data of the users do I have.

00:36:07.460 --> 00:36:08.820
Well, it's everything they create.

00:36:08.820 --> 00:36:14.740
It's all the data users are entering, and it's the
credentials that they enter to connect to things,

00:36:14.740 --> 00:36:19.050
and it's credentials you create on their behalf, if you
make a connection and then wanted to create credentials

00:36:19.050 --> 00:36:23.410
to make a persisting connection,
or reestablishable connection,

00:36:23.410 --> 00:36:27.660
those credentials are data of the
users because it represents them.

00:36:28.850 --> 00:36:32.300
Do I need that data when the device is locked?

00:36:32.300 --> 00:36:34.420
Well, for most app writers, the answer is no.

00:36:34.420 --> 00:36:38.860
If the device locks, your app doesn't do much, it's
waiting for the user to come back and interact with it.

00:36:38.860 --> 00:36:40.300
So you don't.

00:36:40.300 --> 00:36:45.490
But some background-aware applications are going to
need things like credentials, and they're going to want

00:36:45.490 --> 00:36:51.090
to put those credentials in such a way that they
get protected, but they're still accessible.

00:36:51.090 --> 00:36:54.960
Which is why we have the compromise
of AccessibleAfterFirstUnlock,

00:36:54.960 --> 00:37:00.110
which is a good place to put things like credentials
you want to use and be able to reuse as users move

00:37:00.110 --> 00:37:07.090
around their networks but want to get some protection from
the classical kinds of compromises, which involve a reboot.

00:37:07.090 --> 00:37:08.970
Then you have to ask does it belong on the Keychain.

00:37:08.970 --> 00:37:11.870
This is a question we've talking about for a very long time.

00:37:11.870 --> 00:37:16.040
Credentials belong on the Keychain, particularly,
things that you want to migrate around.

00:37:16.040 --> 00:37:22.080
Things like passwords, keys, identities you've
establish for the user or imported for the user.

00:37:22.080 --> 00:37:27.750
Large bulk data doesn't really
belong on the Keychain itself.

00:37:27.750 --> 00:37:32.420
Should it move from device to device?

00:37:32.420 --> 00:37:34.180
Well, the simple answer is yes.

00:37:34.180 --> 00:37:36.950
The user wants their stuff to move from device to device.

00:37:36.950 --> 00:37:41.990
But the more complex answer is, well, unless you have
some compelling reason then it doesn't, and you'll--

00:37:41.990 --> 00:37:45.310
you in this room will probably aware of
why you would want that to be the case.

00:37:45.310 --> 00:37:55.960
We have an example on our system when you import VPN
configuration profile, and you set up a VPN identity,

00:37:55.960 --> 00:37:58.490
that's the identity of the device, not of the user.

00:37:58.490 --> 00:38:00.510
So those identities stay on the device.

00:38:00.510 --> 00:38:02.840
They are not permitted to migrate from device to device.

00:38:02.840 --> 00:38:07.120
But we have to make our system aware of the fact
that those might go away if I restore a backup.

00:38:07.120 --> 00:38:13.850
I'll get half the data back, but I won't get the migrated
VPN identity, and I'll have to deal with that state.

00:38:13.850 --> 00:38:19.230
So if you don't have a compelling reason to make
it non-migratable, make your data migratable.

00:38:19.230 --> 00:38:22.960
So we'll go through a few examples to help clarify this.

00:38:22.960 --> 00:38:26.290
The first example I have is a theoretical game.

00:38:26.290 --> 00:38:29.540
I have a game that has some online
play, it has some credentials it stores.

00:38:29.540 --> 00:38:31.460
It has some saved games it stores.

00:38:31.460 --> 00:38:33.650
That's pretty much all the data we have from the user.

00:38:33.650 --> 00:38:37.340
So for each one of these, I've gone through the questions.

00:38:37.340 --> 00:38:41.150
Do I need access to the credentials
when the device is locked?

00:38:41.150 --> 00:38:43.190
Well, no, my game has stopped and the device is locked.

00:38:43.190 --> 00:38:44.840
I don't need to connect to my server.

00:38:44.840 --> 00:38:47.420
It's-- we're done at that point.

00:38:47.420 --> 00:38:48.440
Do I need it to migrate?

00:38:48.440 --> 00:38:51.130
Well, it's credentials and the user would
like to be able to reconnect to our server

00:38:51.130 --> 00:38:53.930
if they migrate to a new piece of hardware.

00:38:53.930 --> 00:38:55.770
So, yeah, I'd like it to migrate.

00:38:55.770 --> 00:38:57.070
Does it belong in the Keychain?

00:38:57.070 --> 00:38:57.960
It's a credential.

00:38:57.960 --> 00:38:59.200
It belongs on the Keychain.

00:38:59.200 --> 00:39:01.210
So I'm going to put it on the Keychain and I'm going

00:39:01.210 --> 00:39:07.300
to give it the attribute AccessibleWhenUnlocked,
the best protection I can.

00:39:07.300 --> 00:39:10.190
I also have saved games which have similar attributes.

00:39:10.190 --> 00:39:16.340
Yes I-- actually, no, I do not need access to them
when they're locked, yes, I want them to migrate,

00:39:16.340 --> 00:39:18.500
but, no, they don't belong on the Keychain.

00:39:18.500 --> 00:39:22.020
So the protection class I give them is
ProtectionComplete, and I use their location

00:39:22.020 --> 00:39:24.000
on the file system to control their migration.

00:39:24.000 --> 00:39:28.430
I put them in my documents folder in my app, and those
automatically get me moved into my backup and moved back

00:39:28.430 --> 00:39:35.190
to my app, and they're accessible when
I won't migrate from device to device.

00:39:35.190 --> 00:39:38.430
Second example is an online service.

00:39:38.430 --> 00:39:41.190
So suppose I have an online service
that has decided to participate

00:39:41.190 --> 00:39:51.390
in a new background task completion multitasking type, and
it has some credentials, it has some data that is trying

00:39:51.390 --> 00:39:55.430
to push up to the server in the background, or it's trying
to not burden the user with failing to push my photo

00:39:55.430 --> 00:39:59.530
up to the server, and it has some
cash data it wants to display

00:39:59.530 --> 00:40:03.230
because it's got some stuff it's pulled
down from the server for fast access.

00:40:03.230 --> 00:40:06.080
And all of these are user data.

00:40:06.080 --> 00:40:07.820
So start with the service credentials.

00:40:07.820 --> 00:40:11.900
I have some service credentials that I do need
when it's locked because I'm participating

00:40:11.900 --> 00:40:15.390
in background task completion, and I might
change networks and need to reconnect

00:40:15.390 --> 00:40:19.180
to actually complete the operation I'm doing with my server.

00:40:19.180 --> 00:40:22.550
So next question is do I want to migrate this data?

00:40:22.550 --> 00:40:26.680
Well, it's credentials, they belong to a user, I'm-- I
pretty much want it to migrate so my service will work

00:40:26.680 --> 00:40:29.330
on the new device it get to right out the box.

00:40:29.330 --> 00:40:30.460
And does it belong in the Keychain?

00:40:30.460 --> 00:40:31.490
Well, yes, it's a credential.

00:40:31.490 --> 00:40:33.700
It belongs in the Keychain.

00:40:33.700 --> 00:40:39.600
So the protection I give it is AccessibleAfterFirstUnlocked.

00:40:39.600 --> 00:40:41.400
This is the second category of protection.

00:40:41.400 --> 00:40:45.460
It's not quite as good, as AlwaysIsProtectedWhenUnlocked,

00:40:45.460 --> 00:40:49.220
but it does give us some protection
against the task that require a reboot.

00:40:49.220 --> 00:40:52.930
So we choose the second best protection
because we want the user experience to be good.

00:40:52.930 --> 00:40:55.290
The second class of data we have
is a data that's being uploaded.

00:40:55.290 --> 00:40:58.500
So I have some data the users put in the background.

00:40:58.500 --> 00:41:00.830
Do I want this access to the data when it's locked?

00:41:00.830 --> 00:41:04.130
Yes. Do I want this data to migrate?

00:41:04.130 --> 00:41:05.680
No, this is an in-process operation.

00:41:05.680 --> 00:41:06.980
This data's going to go up to the server.

00:41:06.980 --> 00:41:08.610
I don't need this data to move.

00:41:08.610 --> 00:41:09.760
Does it belong on the Keychain?

00:41:09.760 --> 00:41:11.550
No it doesn't belong on the Keychain.

00:41:11.550 --> 00:41:13.380
It's bulk data, it's a big file.

00:41:13.380 --> 00:41:16.740
So I have to put it on the file
system, and I've put in ProtectionNone.

00:41:16.740 --> 00:41:23.190
We have to admit we did not provide file
system API's to get to the second class.

00:41:23.190 --> 00:41:26.150
We didn't think they were as valuable as they might be,

00:41:26.150 --> 00:41:30.540
and if you find reasons why they are
interesting to you, we'd love to hear them.

00:41:30.540 --> 00:41:36.700
This is a case where it might be interesting, but in
this case, we choose ProtectionNone and we put the file

00:41:36.700 --> 00:41:40.870
in a place it doesn't migrate, which would be the
cache's directory in your application, for example.

00:41:40.870 --> 00:41:46.800
Cash data, on the other hand, we don't need when the device
is locked, because it's for-- presenting data to the user.

00:41:46.800 --> 00:41:49.570
And when the device is locked, we
don't present anything to the user.

00:41:49.570 --> 00:41:54.380
We don't need this to migrate, it's caches.

00:41:54.380 --> 00:41:55.110
We might choose to.

00:41:55.110 --> 00:41:57.150
But in this case, we don't care to.

00:41:57.150 --> 00:41:59.230
Does not belong on the Keychain.

00:41:59.230 --> 00:42:01.000
It's large data.

00:42:01.000 --> 00:42:05.970
So we put it in ProtectionComplete which
protects it when the device is locked,

00:42:05.970 --> 00:42:09.450
and we put in it our caches directory so it doesn't migrate.

00:42:09.450 --> 00:42:13.260
The final example is a relative
simple example if I make a diary.

00:42:13.260 --> 00:42:17.280
It's a place somebody can record their
thoughts, whatever they want to put in there,

00:42:17.280 --> 00:42:20.710
their credit numbers because they are crazy.

00:42:20.710 --> 00:42:26.560
So I have this diary which is on the device, and we
don't need it when it's locked because it's for the user.

00:42:26.560 --> 00:42:31.880
We do want it to migrate, and we don't want another Keychain

00:42:31.880 --> 00:42:35.260
because its large unknown pictures,
whatever they use or want to enter.

00:42:35.260 --> 00:42:36.860
But we do want to protect it.

00:42:36.860 --> 00:42:39.520
So we put it in ProtectionComplete.

00:42:39.520 --> 00:42:43.850
This allows it to be protected with Data
Protection, and we put it in our documents folder

00:42:43.850 --> 00:42:47.570
for our app, probably the simplest example of all.

00:42:47.570 --> 00:42:52.000
So once you've made your protection choices, and you've put
your data into an appropriate class, there is one more thing

00:42:52.000 --> 00:42:55.980
that you want to do when you adopt,
particularly, if you are an app that's running

00:42:55.980 --> 00:42:57.840
on the background or running while the systems is locked.

00:42:57.840 --> 00:43:02.450
Your app does not really care with the systems is locked,
and just pretty much left this data on the file system

00:43:02.450 --> 00:43:06.750
and tries to quit if the system locks,
you'd-- there's not a lot you have to do here.

00:43:06.750 --> 00:43:10.640
But if you are a background app, or want to
operate while the system is heading towards lock,

00:43:10.640 --> 00:43:12.720
there are some stuff you need to do.

00:43:12.720 --> 00:43:14.390
There is a notification that comes through.

00:43:14.390 --> 00:43:18.500
There is actually a symmetric one for this also,
that says protection data will become unavailable.

00:43:18.500 --> 00:43:22.070
This is a symmetric one that says become
available, but it's less interesting.

00:43:22.070 --> 00:43:26.270
It's just telling you, you get your data back, and
then you can choose to access your data at that point.

00:43:26.270 --> 00:43:30.140
This one is relatively important
because it does give you a moment

00:43:30.140 --> 00:43:32.990
in which you can help enforce the security of the users' data.

00:43:32.990 --> 00:43:39.140
In response to this notification, we ask that you
purge the data in memory that is not necessarily--

00:43:39.140 --> 00:43:41.540
that is not necessary when the device is locked.

00:43:41.540 --> 00:43:46.120
Specifically, we want you to take the data that
needs protection, put it back into the containers

00:43:46.120 --> 00:43:49.700
that it's supposed to be protected
in, and close those containers.

00:43:49.700 --> 00:43:54.280
So you push it back in the file system, you push it back
on the Keychain, you get it out of your local address base,

00:43:54.280 --> 00:44:00.330
so that if somebody is clever enough to grovel
your memory, they won't get that data either.

00:44:00.330 --> 00:44:06.000
In order to make our system actually have a predictable
behavior about locking, we have to give an upper bound

00:44:06.000 --> 00:44:09.930
to how long an application can hold us off
from causing the system to actually lock.

00:44:09.930 --> 00:44:12.580
So you actually have-- only have 10
seconds to complete this notification.

00:44:12.580 --> 00:44:18.660
If you don't complete this operation in 10
seconds, we're going to lock the device behind you.

00:44:18.660 --> 00:44:21.840
The reason why that is interesting
is once the device is locked,

00:44:21.840 --> 00:44:26.510
you don't get access to the data
that's in the highest protection class.

00:44:26.510 --> 00:44:31.550
You will actually get errors trying to reach in the files
to get EPERM errors saying, no, can't read that data.

00:44:31.550 --> 00:44:37.630
We want you to be resilient to those kinds of failures,
not necessarily your app has to keep chugging along

00:44:37.630 --> 00:44:44.980
and doing great, but don't crash, don't do spectacularly
bad things for the user, considering that that might happen.

00:44:47.810 --> 00:44:50.530
To move on to some interfaces in the file system.

00:44:50.530 --> 00:44:53.850
So how do I create and set this attributes.

00:44:53.850 --> 00:44:56.460
I need to help the system know.

00:44:56.460 --> 00:45:00.940
There are two API's we've added to help
you communicate to the file system,

00:45:00.940 --> 00:45:03.330
what protection class, you want your data in.

00:45:03.330 --> 00:45:09.240
The first is in NSData writeToFile,
there are new options added.

00:45:09.240 --> 00:45:15.570
The file that is created will get the ProtectionComplete
or ProtectionNone, depending on the option you include.

00:45:15.570 --> 00:45:22.690
The second is NSFileManager, has an API to set an
attribute of the file, which is the protection key,

00:45:22.690 --> 00:45:26.300
which will then set the class of the
file, the protection class of the file.

00:45:26.300 --> 00:45:30.630
You can use this on any existing file on the file system.

00:45:30.630 --> 00:45:31.300
It's sticky.

00:45:31.300 --> 00:45:36.810
And then once you set the class for the file, it retains
that class in the file, you don't have to tell us again.

00:45:36.810 --> 00:45:42.930
And most importantly, you can use any other file system
access you want to, and then it will operate normally,

00:45:42.930 --> 00:45:47.640
except for the fact that if the device locks, and it's in
a locked class, we'll get errors when trying to access it.

00:45:47.640 --> 00:45:52.050
So if you are creating a file to hand
off to another subsystem on your device,

00:45:52.050 --> 00:45:54.500
you can set its class before you hand it off.

00:45:54.500 --> 00:46:01.860
If you know you've requested a file you created by
some other system, you can find it, set its class.

00:46:01.860 --> 00:46:07.180
The other thing we need to point out is that your
existing files that have been run long, your documents

00:46:07.180 --> 00:46:11.820
and your documents folder are not going to have
any protection classes except ProtectionAlways.

00:46:11.820 --> 00:46:17.770
So if you want to protect that data for the user, which
we hope you do, you need to actually find those documents

00:46:17.770 --> 00:46:22.430
and set the protection class on
the files in those documents.

00:46:22.430 --> 00:46:26.780
So choosing your protection on the file
system, this actually will be simple.

00:46:26.780 --> 00:46:30.420
Use ProtectionComplete, you know, protect the user's data.

00:46:30.420 --> 00:46:34.670
Right up until you find a good reason
that you can't protect their data.

00:46:34.670 --> 00:46:38.450
You need to use it when you are in the
background, this is probably the most popular.

00:46:38.450 --> 00:46:40.400
I really can't think of many other
reasons why you wouldn't want

00:46:40.400 --> 00:46:44.870
to protect the user's data, although
you might come up with some.

00:46:44.870 --> 00:46:50.050
The Keychain has new interfaces, now just
new attributes on its existing interfaces.

00:46:50.050 --> 00:46:57.330
SecItemAdd and SecItemUpdate have always taken
a query with the dictionary of parameters in it.

00:46:57.330 --> 00:47:03.200
There's a new attribute case like accessibility.

00:47:03.200 --> 00:47:10.010
You can give it one of these values, and that
will set the accessibility of your Keychain item.

00:47:10.010 --> 00:47:14.040
Just like the file system, the
Keychain needs update if you want

00:47:14.040 --> 00:47:18.620
to change the accessibility class of a given Keychain item.

00:47:18.620 --> 00:47:24.390
By default, when we move the Keychain back to the device
it came from because all backups that are currently

00:47:24.390 --> 00:47:28.880
out in the world, can only move back to the same device,
all the Keychains out there will go back to the same device.

00:47:28.880 --> 00:47:36.780
But when it returns to that device, we set all the data
to AccessibleAlways, which you should note is migratable.

00:47:36.780 --> 00:47:42.750
So if you really, don't want it to be migratable, you
should hit it with the hammer and tell it not to migrate.

00:47:42.750 --> 00:47:46.110
If you think it should be less protected because
you want to operate in the background now,

00:47:46.110 --> 00:47:48.830
your app's updating and wants to upgrade in the background.

00:47:48.830 --> 00:47:54.000
You may want to set its protection class
to be type to, AccessibleAfterFirstUnlock.

00:47:54.000 --> 00:48:02.050
If you don't need the data at all, except when you are
running unlocked, set it to AccessibleWhenUnlocked.

00:48:02.050 --> 00:48:04.920
So summarize that basic decision tree, the other direction.

00:48:04.920 --> 00:48:09.530
When you have data and you are trying to consider on
the Keychain, how am I going to protect this data?

00:48:09.530 --> 00:48:15.290
You should start with the most restrictive, but we
recommend migratable, which is AccessibleWhenUnlocked.

00:48:15.290 --> 00:48:18.880
That's probably the right class for the vast
majority of the data that is on the Keychain.

00:48:18.880 --> 00:48:25.770
But if you find reasons that you need to access a
credential when it's locked, the most obvious one I thought

00:48:25.770 --> 00:48:29.520
of is I need to get back to that server
because I was just told the network changed

00:48:29.520 --> 00:48:32.560
and I still have stuff to talk to that server about.

00:48:32.560 --> 00:48:37.600
Use AccessibleAfterFirstUnlock, that still
maintains some protection for the user's data,

00:48:37.600 --> 00:48:40.850
but let's you do the background operation.

00:48:40.850 --> 00:48:45.510
And if you really create data for this device
only, and really, if you create device--

00:48:45.510 --> 00:48:48.290
for this device only, be sure it's for this device only.

00:48:48.290 --> 00:48:55.380
And then you can make the user experience with that
data appropriate, and make it for this device only.

00:48:55.380 --> 00:48:59.910
But if you suddenly discover that that data was for the
user, when they go to a new device, they won't get it.

00:48:59.910 --> 00:49:03.110
So we recommended you think seriously
if you want it to stay on this device.

00:49:03.110 --> 00:49:03.720
But you will know.

00:49:03.720 --> 00:49:07.840
I mean, if you create a data that's for the device and
not for the user, that will be relatively obvious too.

00:49:07.840 --> 00:49:12.660
So a quick example of modifying the access a SecItemAdd,

00:49:12.660 --> 00:49:15.450
those of you who are using the
Keychain already will recognize this.

00:49:15.450 --> 00:49:21.580
You build the query, you called SecItemAdd
with that query as data to the Keychain.

00:49:21.580 --> 00:49:27.430
All you have to do is add one more set of attributes you put
in the query dictionary, kSecAttrAccessible, in this case,

00:49:27.430 --> 00:49:30.840
accessible and unlocked is the--
actually what we're requesting.

00:49:30.840 --> 00:49:32.460
And then you can use that SecItemAdd.

00:49:32.460 --> 00:49:34.860
You can also use the SecItemUpdate.

00:49:36.240 --> 00:49:41.550
So some way in our adoption, it's
relatively straightforward.

00:49:41.550 --> 00:49:47.970
We're asking you to protect your users' data, we're asking
you to choose the strongest protection class you can,

00:49:47.970 --> 00:49:53.620
and we're asking you to update the existing data
protection on the file system and on Keychain.

00:49:53.620 --> 00:49:55.790
We're also asking that you use the Keychain.

00:49:55.790 --> 00:49:57.700
It supports migration now.

00:49:57.700 --> 00:49:59.060
That was a big hindrance before.

00:49:59.060 --> 00:50:03.280
If people would put on the Keychain, they're-- you'd
migrate to a new device, your passwords would all be lost.

00:50:03.280 --> 00:50:04.460
It was really irritating for users.

00:50:04.460 --> 00:50:05.690
That's gone now.

00:50:05.690 --> 00:50:13.540
So we think we have all the reasons
or mood to now use the Keychain.

00:50:13.540 --> 00:50:20.050
So what we talked about today, John started talking
about why we want to help protect the user's data.

00:50:20.050 --> 00:50:28.190
These devices are all more mobile, they're much more
active, they actively do access in the background.

00:50:28.190 --> 00:50:31.130
The data on these devices are more
personal, and there's a lot more of it.

00:50:31.130 --> 00:50:34.940
So it has higher value, particularly to an appointed
attack, and it looks and says, hey, I want Mitch's data,

00:50:34.940 --> 00:50:39.500
I'm going to steal his phone, and get his data off of it.

00:50:39.500 --> 00:50:43.620
And we're willing to help deal with this,
we want to tie the data to a user's secret.

00:50:43.620 --> 00:50:50.170
That way, the user owns the secret, not us and not
our system, not penetrating the owner's system.

00:50:50.170 --> 00:50:55.030
The data protection model is to
protect the data with the passcode.

00:50:55.030 --> 00:51:00.500
So all the user data is supposed to protected with a
passcode to strengthen against devices that get compromised.

00:51:00.500 --> 00:51:04.160
So if somebody takes my device, they can break through
the front barriers that we think are pretty strong,

00:51:04.160 --> 00:51:07.330
but are not perfect, if they get through that,

00:51:07.330 --> 00:51:12.250
they still have to get through the
cryptographic protection with the user's passcode.

00:51:12.250 --> 00:51:20.580
We also protect the user passcode by tying its derivation to
a key to the hardware, so that brute force on that passcode,

00:51:20.580 --> 00:51:23.790
even if I have all the data inside the
device, if I've gotten into the device,

00:51:23.790 --> 00:51:26.660
requires I do operations on the device to attack it.

00:51:26.660 --> 00:51:32.450
I can't send it out to my botnet and get
a factor of a million on my attacks speed.

00:51:32.450 --> 00:51:35.040
We want data protection to always be on.

00:51:35.040 --> 00:51:40.070
It is always on when the user set his passcode.

00:51:40.070 --> 00:51:40.990
You can't have it off.

00:51:40.990 --> 00:51:44.430
You got a new passcode, data protection comes on.

00:51:44.430 --> 00:51:47.900
And to reiterate again, there is no performance impact.

00:51:47.900 --> 00:51:53.890
We're already encrypting and decrypting data as it goes
to and from the file system, and to and from the Keychain.

00:51:53.890 --> 00:51:58.040
All we've done in this update is change
the architecture of what keys we use

00:51:58.040 --> 00:52:02.520
when we push the data in and out of the storage systems.

00:52:02.520 --> 00:52:09.750
And lastly, we talked about was how you guys adopt
and help us make all the user's data protected.

00:52:09.750 --> 00:52:13.150
We're asking that all applications protect the user's data.

00:52:13.150 --> 00:52:17.790
Since user information is all over the place, any
application where I can have a text deal and enter data,

00:52:17.790 --> 00:52:19.900
I could put something that I want protected.

00:52:19.900 --> 00:52:21.600
We're adopting it.

00:52:21.600 --> 00:52:24.450
We're adopting it as quickly as we can.

00:52:24.450 --> 00:52:29.640
We chose mail first since it was one of our most
complicated ones to prove out that the technology worked.

00:52:29.640 --> 00:52:33.760
We're definitely going to be adding more apps.

00:52:33.760 --> 00:52:42.570
We're asking you to put your data into appropriate classes,
to update your existing data into the appropriate classes,

00:52:42.570 --> 00:52:45.450
and we really are trying to encourage
you to use the Keychain.

00:52:45.450 --> 00:52:49.420
We think there are no excuses left to
not use the Keychain for credentials.

00:52:49.420 --> 00:52:54.990
So if you are interested in any more
information about the presentation,

00:52:54.990 --> 00:52:58.410
you can contact our Evangelist
or you can check out the forms.

00:52:58.410 --> 00:53:02.830
There are few related sessions.

00:53:02.830 --> 00:53:09.900
The first ones of the Multitasking on iPhone have already
occurred, but there is rerun of them tomorrow morning.

00:53:09.900 --> 00:53:14.990
And, if you want to pay attention to
how you handle being a multitasking app,

00:53:14.990 --> 00:53:18.960
because those moments will be interesting
for you to decide about data protection.

00:53:18.960 --> 00:53:22.340
The Managing Mobile Devices session was last Tuesday.

00:53:22.340 --> 00:53:24.440
You can catch the replay when they are posted.

00:53:24.440 --> 00:53:26.850
It talks about how to configure
devices and manage them remotely.

