WEBVTT

00:00:06.460 --> 00:00:07.760
>> Ben Nham: Hi I'm Ben Nham.

00:00:07.760 --> 00:00:10.410
I'm an engineer on the iPhone Performance team.

00:00:10.410 --> 00:00:14.880
This is Advanced Performance Optimization
on iPhone OS Part 2.

00:00:14.880 --> 00:00:21.110
Yesterday, we had Part 1 where we talked about making
your animations fluid, making your app responsive

00:00:21.110 --> 00:00:23.860
and also optimizing the power usage of your app.

00:00:23.860 --> 00:00:28.550
So if you didn't get a chance to go to that yesterday,
I highly recommend you take a look at that on video.

00:00:28.550 --> 00:00:33.140
Today, we're going to be talking
about working with data efficiently.

00:00:33.140 --> 00:00:40.830
And we're going to focus on working with that data both
in memory data structures and also taking that data

00:00:40.830 --> 00:00:47.960
and putting it on and off disk using
serialization and deserialization routines.

00:00:47.960 --> 00:00:50.270
We're going to focus on a few main themes.

00:00:50.270 --> 00:00:52.130
The first is measurement tools.

00:00:52.130 --> 00:00:57.710
We want you to be able to use our tools to find hot spots
in your code and then use those same tools to verify

00:00:57.710 --> 00:01:03.830
that any fix you've made has actually
had the desired impact.

00:01:03.830 --> 00:01:05.520
The next is mental models.

00:01:05.520 --> 00:01:09.710
We want you to build up some intuition about
how the system is put together and how it works.

00:01:09.710 --> 00:01:12.810
So you can preemptively write perform at code.

00:01:12.810 --> 00:01:15.490
And finally, there are a lot of frameworks on our system.

00:01:15.490 --> 00:01:19.150
So we're going to over a few of the best
practices for using these frameworks.

00:01:19.150 --> 00:01:25.940
We're going to start by talking about how to use memory
efficiently and then move on to talking about how

00:01:25.940 --> 00:01:29.940
to use the foundation framework
to manipulate data efficiently.

00:01:29.940 --> 00:01:36.420
We'll talk about how to profile the file system to make sure
you get the maximum amount of I/O speed from your device.

00:01:36.420 --> 00:01:40.470
Then move on to working with large datasets and databases.

00:01:40.470 --> 00:01:43.650
And finally, making sure your application works well

00:01:43.650 --> 00:01:48.780
with those large datasets and scales
to ever larger sizes of data.

00:01:48.780 --> 00:01:51.900
So let's start with memory.

00:01:51.900 --> 00:01:55.260
iOS isn't a desktop OS.

00:01:55.260 --> 00:01:57.780
iOS devices aren't desktop devices.

00:01:57.780 --> 00:02:03.320
As you can see in the chart, there's less memory
in an iOS device than on a desktop device.

00:02:03.320 --> 00:02:07.700
In addition, there are some architectural
differences between iOS and the desktop OS.

00:02:07.700 --> 00:02:10.720
For example, we have virtual memory
but we have no swap file.

00:02:10.720 --> 00:02:15.650
This actually has some interesting
implications that we'll get into later.

00:02:15.650 --> 00:02:19.400
There are also some features in iOS
that are not present on the desktop

00:02:19.400 --> 00:02:22.290
such as low memory notifications
which you have to handle gracefully.

00:02:22.290 --> 00:02:29.030
So let's take a look at a 128-megabyte
device such as the iPhone 3G.

00:02:29.030 --> 00:02:34.440
You can see that there are a lot of processes and
applications that are running in the background

00:02:34.440 --> 00:02:39.900
which you don't really have any control over that
are using memory even if your app isn't running.

00:02:39.900 --> 00:02:44.490
So in this example, a certain amount of
memory is wired in by the kernel depending

00:02:44.490 --> 00:02:47.930
on how much file activity or network activity you have.

00:02:47.930 --> 00:02:50.340
It could be a little more or a little less.

00:02:50.340 --> 00:02:54.810
There's always 12 megabytes allocated by the graphics card.

00:02:54.810 --> 00:02:58.230
Some amount of memory used by Daemons.

00:02:58.230 --> 00:03:00.870
Some may go away such as the sinking Daemons.

00:03:00.870 --> 00:03:08.550
Some of them stay around forever such as the ones
that listen to your phone calls or listen on--

00:03:10.550 --> 00:03:17.740
[laughter] the ones that listen on waiting for your
phone calls so you can listen to your phone calls.

00:03:17.740 --> 00:03:25.680
Of course, there's other programs even on iPhone 3G
which can run all the time such as phone, mail, iPad,

00:03:25.680 --> 00:03:31.990
and especially Safari which if you load a complex
web page can really take up quite a bit of memory.

00:03:31.990 --> 00:03:35.790
So your app might be asked to launch and
run in a pretty limited memory window.

00:03:35.790 --> 00:03:38.740
So it really pays to use memory efficiently.

00:03:38.740 --> 00:03:44.950
So let's go over a few of the vocabulary
terms that you'll have to understand

00:03:44.950 --> 00:03:48.110
to be able to really use our memory tools well.

00:03:48.110 --> 00:03:50.700
Let's start with Paging.

00:03:50.700 --> 00:03:57.600
Your process is split into 4 kilobyte chunks called
pages and those pages can be either nonresident,

00:03:57.600 --> 00:04:01.570
resident and clean, or resident and dirty.

00:04:01.570 --> 00:04:04.330
Page is resident if it's in physical memory.

00:04:04.330 --> 00:04:07.490
If it's nonresident, it's not using physical memory.

00:04:07.490 --> 00:04:11.730
And when you touch that nonresident
page, the kernel will take a page fault

00:04:11.730 --> 00:04:16.060
and bring that nonresident page into physical memory.

00:04:17.350 --> 00:04:22.280
Once that page is resident, it can either be clean or dirty.

00:04:22.280 --> 00:04:24.870
If it's dirty, it's probably anonymous memory.

00:04:24.870 --> 00:04:27.580
In other words, it just came out of thin air.

00:04:27.580 --> 00:04:29.880
For example, malloc memory.

00:04:29.880 --> 00:04:35.380
There's no file backing it at least on iOS so
that means that once a resident page is dirty,

00:04:35.380 --> 00:04:40.250
it just stays around forever until you
deallocate it or your application quits.

00:04:40.250 --> 00:04:44.830
So it's really important to keep
your dirty memory usage down.

00:04:44.830 --> 00:04:51.970
There's also file-backed memory such as the memory that
backs your code or if you explicitly memory map to file.

00:04:51.970 --> 00:04:54.710
And generally, this stays clean unless you modify it.

00:04:54.710 --> 00:04:59.690
And what that means is that the kernel can
drop references to those pages at will.

00:04:59.690 --> 00:05:03.930
So it's relatively free to use clean memory.

00:05:03.930 --> 00:05:08.130
Now if you use too much dirty memory,
it'll actually crowd out the clean memory

00:05:08.130 --> 00:05:11.370
that you have and that includes code pages.

00:05:11.370 --> 00:05:15.470
So if you use too much dirty memory, it turns
out that just bringing in the code needed

00:05:15.470 --> 00:05:18.750
to execute your program could take longer.

00:05:19.790 --> 00:05:24.960
So let's go through an example and just as a caveat,
some of these examples are a little dependent

00:05:24.960 --> 00:05:30.880
on your memory allocator but as a
simplification, most of these concepts are true.

00:05:30.880 --> 00:05:37.870
So in this case I've allocated two
pages from my malloc allocator.

00:05:37.870 --> 00:05:44.100
I've use valloc here which actually gives a page
align address but otherwise it's the same as malloc.

00:05:44.100 --> 00:05:46.490
So at first, those two pages are nonresident.

00:05:46.490 --> 00:05:48.710
They're not taking up any physical memory.

00:05:48.710 --> 00:05:53.500
As soon as I write to-- for example
the first byte in the first page,

00:05:53.500 --> 00:05:57.050
that page turns from nonresident into a resident dirty page.

00:05:57.050 --> 00:06:02.700
So it's going to stick around until
either my app exits or I free this memory.

00:06:02.700 --> 00:06:06.800
And similarly if I modify the second
page, it will take a page fault.

00:06:06.800 --> 00:06:15.370
It will be brought into physical memory and that page
will turn from nonresident into resident and dirty.

00:06:15.370 --> 00:06:19.760
With file-backed memory, if we map it
read-only which is the general case.

00:06:19.760 --> 00:06:25.550
If we explicitly map this file in
this example which is two-pages long

00:06:25.550 --> 00:06:29.430
into memory using dataWithContentsOfMappedFile.

00:06:29.430 --> 00:06:35.930
Again, those pages start out as nonresident if we
don't actually access the data from those pages.

00:06:35.930 --> 00:06:43.600
The moment we take any data from the first page, we're
going to bring the data from the file into memory

00:06:43.600 --> 00:06:47.540
and that page turns from nonresident to resident and clean.

00:06:47.540 --> 00:06:54.210
And similarly, the moment we reference any data
on the second page, we'll take another page fault

00:06:54.210 --> 00:06:59.700
and that page turns from nonresident to
resident and clean in physical memory.

00:06:59.700 --> 00:07:06.140
So where these concepts are really
useful are in our VM Tracker tool.

00:07:06.140 --> 00:07:13.900
This is part of the allocations template in Instruments
and these VM snapshots basically take a snapshot

00:07:13.900 --> 00:07:19.270
of you virtual memory usage out of
particular point in time in your application.

00:07:19.270 --> 00:07:25.710
You can either ask Instruments to snapshot
automatically at a time interval or by default,

00:07:25.710 --> 00:07:30.470
you actually have to trigger the snapshot
manually by clicking the snapshot Now button.

00:07:30.470 --> 00:07:38.860
As a word of caution, this actually works best in the
simulator right now in our particular build of iOS 4.

00:07:38.860 --> 00:07:45.190
So once you've taken these samples,
you'll get different samples over time.

00:07:45.190 --> 00:07:49.800
And what you're really looking for are
you'll see the different regions of memory

00:07:49.800 --> 00:07:53.020
in your application which we'll go over in a second.

00:07:53.020 --> 00:07:58.060
But what you're really looking for is
growing dirty memory usage over time.

00:07:58.060 --> 00:08:00.920
So in this case, I've started with 16 megabytes.

00:08:00.920 --> 00:08:05.630
I took another snapshot a little while
later and now I have 20 megabytes

00:08:05.630 --> 00:08:09.510
and now a little while later, I have 24 megabytes used.

00:08:09.510 --> 00:08:13.830
So this is indicative of perhaps a memory leak.

00:08:13.830 --> 00:08:19.260
Next we want to see which region was growing
in size, in this case, the malloc large region.

00:08:19.260 --> 00:08:22.790
So as you can see it's growing in size over time.

00:08:22.790 --> 00:08:28.540
So this is sort of indicating to you that this is
probably a region of memory that you want to focus on.

00:08:28.540 --> 00:08:34.720
So if you see malloc growing, we have a lot
of great tools to help you deal with that.

00:08:34.720 --> 00:08:41.620
There's the allocations template, the leaks template,
those are all great for looking for leaks in your heap.

00:08:41.620 --> 00:08:45.810
If you have Growing dirty_DATA, that's pretty unusual.

00:08:45.810 --> 00:08:49.050
Those are generally global variables that you've modified.

00:08:49.050 --> 00:08:53.540
So if you do have global variables, try to make sure
if they're constant, that they're really constant

00:08:53.540 --> 00:08:56.820
and then we'll put them into a read-only region.

00:08:56.820 --> 00:09:01.100
If you see Core Animation growing up
over time, you might have a view leak

00:09:01.100 --> 00:09:04.680
because each view is backed by Core Animation layer.

00:09:04.680 --> 00:09:10.460
And just as a final note, if you see TC malloc
taking up about 200 kilobytes in your application,

00:09:10.460 --> 00:09:13.320
you shouldn't be worried because that's fixed.

00:09:13.320 --> 00:09:17.790
JavaScript core uses that to execute
JavaScript and it always takes at least

00:09:17.790 --> 00:09:20.290
around 200 kilobytes even if you're not using a web view.

00:09:20.290 --> 00:09:27.800
I'm not going to have time to talk about all
these other memory measurement tools we had.

00:09:27.800 --> 00:09:33.640
We had an advanced memory analysis with Instruments
talk yesterday, that you should take a look at on video

00:09:33.640 --> 00:09:38.610
to learn more about these tools, there's
the leaks template, the allocations template

00:09:38.610 --> 00:09:41.680
and the zombies template which runs on the simulator.

00:09:41.680 --> 00:09:43.020
These help you find leaks.

00:09:43.020 --> 00:09:49.190
They help you find back traces for every single memory
allocation you've made in you applications lifetime

00:09:49.190 --> 00:09:54.910
and they also help you find any
references to over released memory.

00:09:54.910 --> 00:09:59.480
So please take a look at that talk if
you want to learn more about these tools.

00:09:59.480 --> 00:10:04.110
What I'm going to focus on is something
that's unique to iOS 4 if you're coming

00:10:04.110 --> 00:10:07.280
through the desktop and that's low memory warnings.

00:10:07.280 --> 00:10:15.010
If your application or perhaps the cumulative effect of all
the applications on the system, use too much dirty memory,

00:10:15.010 --> 00:10:21.620
a low memory warning will be fired and you have to
respond to this low memory warning in a graceful way.

00:10:21.620 --> 00:10:25.480
So let's go over how this works.

00:10:25.480 --> 00:10:31.860
As a total dirty memory in the system gets to a certain
threshold, your application will receive a warning.

00:10:31.860 --> 00:10:38.300
If it gets to another threshold, then you'll get
another warning and background apps will exit

00:10:38.300 --> 00:10:41.690
as we try to free up memory for your app.

00:10:41.690 --> 00:10:47.290
As you continue using dirty memory, for
example if you a leak that eventually will get

00:10:47.290 --> 00:10:51.550
to a critical threshold that can kill your app.

00:10:51.550 --> 00:10:57.870
So when you get a low memory warning, make sure
to release any objects that you can release,

00:10:57.870 --> 00:11:01.650
anything that can be reconstructed, anything that's cached.

00:11:01.650 --> 00:11:07.590
Don't ask the user to restart the app or restart the device.

00:11:07.590 --> 00:11:12.430
So there are a few places where you
can respond to low memory warnings.

00:11:12.430 --> 00:11:17.320
If you have-- or if you're using UIView
controllers, override viewDidUnload.

00:11:17.320 --> 00:11:21.600
Your app delegate will get an
applicationDidReceiveMemoryWarning callback

00:11:21.600 --> 00:11:27.080
and any object can register for a UIApplication
DidReceiveMemoryWarningNotification.

00:11:27.080 --> 00:11:34.510
Now I'm going to go over overriding
viewDidUnload in a bit more detail,

00:11:34.510 --> 00:11:38.770
because this can be a bit tricky
if you're new to the platform.

00:11:38.770 --> 00:11:45.130
When view controllers get a memory warning, if they're not
at the top of the navigation stack or if they're obscured

00:11:45.130 --> 00:11:48.640
in some way, they'll automatically release their views.

00:11:48.640 --> 00:11:58.020
But if you've retained subviews in some instance variables
or some outlets, you have to release those subviews for us.

00:11:58.020 --> 00:11:59.760
Let's go over an example.

00:11:59.760 --> 00:12:02.590
Suppose I have this navigation controller based app.

00:12:02.590 --> 00:12:07.960
At the bottom of the view controller
hierarchy, we have a ComposeViewController.

00:12:07.960 --> 00:12:13.290
And suppose I click on that photo and
slide a PhotoViewController on top.

00:12:13.290 --> 00:12:15.010
And now we get a memory warning.

00:12:15.010 --> 00:12:21.260
Well the ComposeViewController when it gets a
memory warning because it's not visible on screen,

00:12:21.260 --> 00:12:25.400
it'll automatically release the
view associated with it for you.

00:12:25.400 --> 00:12:30.620
But if you've retained the subviews
here, in this case, these are IBOutlets,

00:12:30.620 --> 00:12:35.290
these button labels and textViews, those won't go away.

00:12:35.290 --> 00:12:39.340
You have to manually release those in viewdidUnload.

00:12:39.340 --> 00:12:48.390
So assuming I have these four outlets here, titleLabel,
locationLabel, textView, imageButton as properties,

00:12:48.390 --> 00:12:55.950
in my viewDidUnload, to properly respond to the memory
warning, I'm going to set each of these properties to nil

00:12:55.950 --> 00:13:02.100
and as a side effect, that release my
references to each of these subviews.

00:13:03.190 --> 00:13:11.170
So now, when my ComposeViewController gets a memory warning,
it'll automatically release the view associated with it

00:13:11.170 --> 00:13:17.680
and then our viewDidUnload will release the remaining
references to the subviews and that's what we want.

00:13:17.680 --> 00:13:23.060
So it's really important that you test
out low memory warnings in the simulator.

00:13:23.060 --> 00:13:29.380
We've seen a lot of interesting behavior in responding
to low memory warnings even in the labs here.

00:13:29.380 --> 00:13:33.560
So make sure you test this out in many different ways.

00:13:33.560 --> 00:13:37.020
I just want to make a quick note
about interacting with multitasking.

00:13:37.020 --> 00:13:44.740
Of course, we've had several sessions on multitasking
here but when your application goes into the background,

00:13:44.740 --> 00:13:48.210
we don't preemptively, for example,
send a low memory warning.

00:13:48.210 --> 00:13:50.080
We let you make the tradeoff.

00:13:50.080 --> 00:13:55.180
And the tradeoff is multitasking is
supposed to be a fast app switching.

00:13:55.180 --> 00:13:59.610
So we want users to be able to
get back into your app quickly.

00:13:59.610 --> 00:14:04.100
But on the other hand, when your app is
in the background, it's using up memory.

00:14:04.100 --> 00:14:12.420
So you should try to release any easily reconstructed
resources in you applicationDidEnterBackrground call.

00:14:12.420 --> 00:14:16.580
On the other hand, if you release some
resource that's really expensive to recreate,

00:14:16.580 --> 00:14:19.610
that kind of defeats the purpose of
fast app switching because then you have

00:14:19.610 --> 00:14:23.490
to expensively recreate it when you become foreground.

00:14:23.490 --> 00:14:25.700
So this is a tradeoff you'll have to make.

00:14:25.700 --> 00:14:29.950
Make sure you play with this a
bit and release as many resources

00:14:29.950 --> 00:14:38.010
as you can possibly do reasonably
without making fast app switching slow.

00:14:41.630 --> 00:14:44.720
Now, I just want to talk a bit about image memory as well.

00:14:44.720 --> 00:14:49.720
In the past, we've had a slide here that has a
chart that doesn't really go over all the subtleties

00:14:49.720 --> 00:14:53.700
of image memory and really can cause a lot of confusion.

00:14:53.700 --> 00:14:58.560
So I've alleviated by removing the chart.

00:14:58.560 --> 00:15:01.470
And I'm just going to give you this general advice.

00:15:01.470 --> 00:15:08.810
If you use UIImage imageNamed, use that for read-only
resources that come out of your app bundle and are used

00:15:08.810 --> 00:15:12.820
as say background images for buttons
or you're going to use them to draw

00:15:12.820 --> 00:15:17.600
on the table view cells, things
that are used in UI elements.

00:15:17.600 --> 00:15:22.650
For everything else, UIImage, imageWithContentsOfFile
is generally good enough.

00:15:22.650 --> 00:15:26.290
We've removed a lot of the performance
differences between these methods

00:15:26.290 --> 00:15:29.260
so that this general advice is generally good enough.

00:15:29.260 --> 00:15:35.130
One thing I'd like to point out is that in iOS 4,

00:15:35.130 --> 00:15:40.340
we've made public the ImageIO framework
which has been on OS X since Tiger.

00:15:40.340 --> 00:15:47.020
And one of the nice features of ImageIO is if
you're creating thumbnails of large images,

00:15:47.020 --> 00:15:53.660
it can do so quickly in both-- or
efficiently in both space and time.

00:15:53.660 --> 00:16:02.140
So to use this, you create a CGUmageSourceRef which
encapsulates the deserialization of the image.

00:16:02.140 --> 00:16:09.450
And then you pass in this options dictionary which asks
the image source to create a thumbnail and also the size

00:16:09.450 --> 00:16:14.780
of that thumbnail and out pops a
CGImageRef that's the thumbnail.

00:16:14.780 --> 00:16:22.800
And this is as I said efficiently uses memory so that if
you create a thumbnail out of a say 2 megapixel image,

00:16:22.800 --> 00:16:28.280
you'll use much less memory than if you
just deserialize that 2 megapixel image

00:16:28.280 --> 00:16:32.830
and then use ports to draw that into a 44 by 44 context.

00:16:32.830 --> 00:16:35.520
So if you want to know more about this,

00:16:35.520 --> 00:16:40.450
refer to the Creating a Thumbnail Image
section of the Image I/O Programming Guide.

00:16:40.450 --> 00:16:47.780
This is a code snippet but that it'll go over all
the caveats of using CGImageSource in this way.

00:16:47.780 --> 00:16:54.750
So in summary, drive down the dirty
memory usage of your app.

00:16:54.750 --> 00:16:56.060
It causes memory warnings.

00:16:56.060 --> 00:17:02.340
It crowds out clean memory that could be
used to for example execute code in your app.

00:17:02.340 --> 00:17:03.970
Respond to memory warnings correctly.

00:17:03.970 --> 00:17:09.630
And release resources as necessary
when entering a background.

00:17:09.630 --> 00:17:15.570
We have a few additional user guides but really
what I'd really urge you to do is to take a look

00:17:15.570 --> 00:17:20.200
at Advanced Memory Analysis with
Instruments talk on video afterwards.

00:17:20.200 --> 00:17:24.840
So next let's talk about Foundation.

00:17:24.840 --> 00:17:29.350
Foundation has a lot of the objects
we care about including NSObject.

00:17:29.350 --> 00:17:34.190
But let's go over some of the collection
performance characteristics

00:17:34.190 --> 00:17:38.150
of the collections inside Foundation
starting with NSMutableArray.

00:17:38.150 --> 00:17:44.340
Arrays have pretty textbook performance
characteristics in our system

00:17:44.340 --> 00:17:49.440
but there is one unique performance characteristics that
I want to point out which is that inserting or deleting

00:17:49.440 --> 00:17:55.330
at the beginning of an array is amortized constant
time which means you can use an array as a queue

00:17:55.330 --> 00:17:57.910
or as double ended queue pretty efficiently.

00:17:57.910 --> 00:18:03.160
This is of course not true for most arrays you've probably
dealt with in the past if you're new to our framework.

00:18:03.160 --> 00:18:09.360
So before rolling your own queue, you can try
NSMutableArray first and it probably will be good enough.

00:18:09.360 --> 00:18:14.590
There is also another interesting thing which is
that if you insert 250,000 elements into your array,

00:18:14.590 --> 00:18:22.240
it becomes a tree but if you did that, let us know.

00:18:22.240 --> 00:18:24.340
Strings work a lot like arrays.

00:18:24.340 --> 00:18:26.400
Indexed access is constant time.

00:18:26.400 --> 00:18:30.540
It's going to be a load plus a load at an offset probably.

00:18:30.540 --> 00:18:32.710
Inserting or deleting the middle is linear time.

00:18:32.710 --> 00:18:35.200
Inserting or deleting at the end is constant time.

00:18:35.200 --> 00:18:42.190
This is all pretty similar to any other mutable
string class you've probably dealt with in the past.

00:18:42.190 --> 00:18:45.640
Dictionaries also work like most
other well-behaved dictionaries.

00:18:45.640 --> 00:18:53.210
If you have a good hash function, all the major mutation
functions or lookup functions such as lookup, insertion,

00:18:53.210 --> 00:18:57.690
replacement, removal, those are all constant time.

00:18:57.690 --> 00:19:01.420
But with a bad hash function, you
turn your dictionary into an array.

00:19:01.420 --> 00:19:06.500
And in particular, that means that
a lookup turns into a linear search.

00:19:06.500 --> 00:19:10.930
So what do I mean by bad hash function?

00:19:10.930 --> 00:19:16.270
If your return a constant value, that's a bad hash function.

00:19:16.270 --> 00:19:21.010
If you return a random value, that's a broken hash function.

00:19:21.010 --> 00:19:26.310
It's actually really hard to give good general advice about
hash functions because there are whole courses about how

00:19:26.310 --> 00:19:34.770
to write optimal hash functions but most of you apply the
making custom objects that are compositions of objects

00:19:34.770 --> 00:19:38.460
that we give you such as UIViews or arrays or dictionaries.

00:19:38.460 --> 00:19:45.660
In this case, I have this example where we have this array
dict that has instance variables and array and a dictionary.

00:19:45.660 --> 00:19:51.770
And of course we implement hash for you on
these objects efficiently and correctly.

00:19:51.770 --> 00:19:57.410
So if you don't know any better, you can try just
XORing the hash of each of these instance variables

00:19:57.410 --> 00:20:03.570
that you have and that's usually good enough.

00:20:03.570 --> 00:20:06.250
In addition, you should make sure
the hash function runs quickly,

00:20:06.250 --> 00:20:10.050
because as the dictionary grows we may have
to increase the size of the dictionary.

00:20:10.050 --> 00:20:14.580
At which point, we have to rehash all
the existing values in the dictionary.

00:20:14.580 --> 00:20:19.880
So stick to pretty fast operations
adding, shifting, masking or XORing.

00:20:19.880 --> 00:20:26.450
And remember the API contract, when you call
-setObject:forKey, your key will be copied.

00:20:26.450 --> 00:20:30.830
So respond to NSCopying in some same way.

00:20:30.830 --> 00:20:35.220
In addition, objects that are equal
must return the same hash.

00:20:35.220 --> 00:20:38.230
If you don't follow this, your dictionary won't work.

00:20:38.230 --> 00:20:41.810
Now that we've talked about some of the
performance characteristics of these collections,

00:20:41.810 --> 00:20:44.970
let's take a look at some of these
perhaps tips and tricks about how

00:20:44.970 --> 00:20:48.460
to use this collections in the most performant way.

00:20:48.460 --> 00:20:56.530
And the first is if you're storing a lot of integers into
your collection, one way to do it is by boxing each integer

00:20:56.530 --> 00:21:02.170
into an NS number and passing it on to
your NSSet or NSMutableArray or so forth.

00:21:02.170 --> 00:21:07.550
But you can actually bypass this integer boxing
step by using the correct data structure.

00:21:07.550 --> 00:21:12.230
So NSIndexSet is built to work with integers natively.

00:21:12.230 --> 00:21:18.930
In addition, core foundation collections can work
with pointer size integers if you cast those integers

00:21:18.930 --> 00:21:27.120
into pointers by passing NULL into the
callbacks parameter of the constructor.

00:21:27.120 --> 00:21:34.010
So in this example, to create an array that stores
integers natively without boxing to NSNumbers,

00:21:34.010 --> 00:21:42.450
I can call CFArrayCreateMutable using default allocator
with no capacity restriction and NULL as the callbacks.

00:21:42.450 --> 00:21:50.900
And I just cast my integer into a pointer and I can
just add and remove and modify my array without boxing.

00:21:50.900 --> 00:21:56.300
So if you do this enough, it can actually add up.

00:21:56.300 --> 00:21:59.290
These timings are taken from the iPhone 3G.

00:21:59.290 --> 00:22:05.290
If you box and store 1000 NSNumbers
into a set, it takes 30 milliseconds.

00:22:05.290 --> 00:22:08.670
If you don't box the integers and just store them natively

00:22:08.670 --> 00:22:14.630
into a mutable index set or a mutable
set, it's 10 times faster.

00:22:14.630 --> 00:22:20.290
So these are one of those things that might add up over
time if you box a lot of integers in your application.

00:22:20.290 --> 00:22:25.470
Next, let's talk about bulk operations.

00:22:25.470 --> 00:22:32.130
I've told you that some of these methods such as
objectAtIndex or characterAtIndex are efficient.

00:22:32.130 --> 00:22:34.350
They're constant time.

00:22:34.350 --> 00:22:38.570
But there is a message sending overhead to
calling these methods over and over again.

00:22:38.570 --> 00:22:43.580
So for example, if you want to call NSString
characterAtIndex over and over again,

00:22:43.580 --> 00:22:49.800
perhaps you should instead call getCharacters
range and just inspect the range you care about.

00:22:49.800 --> 00:22:55.940
Get that range into a C buffer and inspect
the buffer using standard C indexing.

00:22:55.940 --> 00:22:58.260
That can be up to 3 times faster.

00:22:58.260 --> 00:23:05.210
Even better, hopefully there's a method inside these
classes that does exactly what you want such as

00:23:05.210 --> 00:23:10.170
if you want prefix search, you might just want
to call hasPrefix rather than writing your own.

00:23:10.170 --> 00:23:16.190
So make sure you inspect the API and
select the highest level API possible

00:23:16.190 --> 00:23:20.350
because it's probably already implemented
in the most performant way for you.

00:23:20.350 --> 00:23:31.420
One thing I want to point out in particular is that strings
now have regular expression support finally in iOS 4.

00:23:31.420 --> 00:23:34.010
We've made them really easy for
you to use regular expressions.

00:23:34.010 --> 00:23:40.280
You can use the existing NSString methods and pass this
NSRegularExpression search option and all of a sudden,

00:23:40.280 --> 00:23:43.510
your substring search turns into
a regular expression search.

00:23:43.510 --> 00:23:45.840
And this is great for one-off searches.

00:23:45.840 --> 00:23:51.230
But if you're going to look for the same
pattern in many different strings, use--

00:23:51.230 --> 00:23:53.880
create an NSRegularExpression object

00:23:53.880 --> 00:23:59.030
and use the enumerateMatchesInString
options range using block method instead.

00:23:59.030 --> 00:24:04.200
And the reason for that is parsing
a regular expression takes some time

00:24:04.200 --> 00:24:08.070
and sets up some state that you
don't want to continually pay.

00:24:08.070 --> 00:24:14.810
If you use the regular expression object, you
additionally had these options NSMatchingReportProgress.

00:24:14.810 --> 00:24:21.460
We'll call this block back even if you don't get
a match periodically and you can write to the stop

00:24:21.460 --> 00:24:28.420
out parameter the-- you can write yes to the stop
out parameter to stop the search prematurely.

00:24:28.420 --> 00:24:34.510
Regular expressions are an example of objects
which are a bit expensive to reinitialize

00:24:34.510 --> 00:24:36.340
over and over again with the same parameters.

00:24:36.340 --> 00:24:42.350
They are examples of objects that you should keep
around if you're going to use again and again.

00:24:42.350 --> 00:24:47.100
Date formatters and number formatters
are the other usual example of this.

00:24:47.100 --> 00:24:54.030
So here's an example where we have a table view
cell that shows a month and one way to do this is

00:24:54.030 --> 00:24:59.490
to just create a table-- create a date formatter
for every table view cell that comes on screen.

00:24:59.490 --> 00:25:03.710
Set its date format to the month
day format and use that formatter

00:25:03.710 --> 00:25:09.090
to format the month string and
this works but it's not performant.

00:25:09.090 --> 00:25:13.550
Instead, you should lazily create that date formatter
if you're going to use it over and over again.

00:25:13.550 --> 00:25:18.770
In this sample code, the first time you call
monthFormatter, it will create the monthFormatter.

00:25:18.770 --> 00:25:21.930
Every subsequent time, it'll return the
monthFormatter that's already created

00:25:21.930 --> 00:25:27.950
and then we can use this function
to format our date performantly.

00:25:31.510 --> 00:25:34.690
There are some gotchas with doing this.

00:25:34.690 --> 00:25:41.150
In particular in iOS 4, the user can change
their locale without exiting your app.

00:25:41.150 --> 00:25:43.200
So you have to listen

00:25:43.200 --> 00:25:48.130
to the NSCurrentLocaleDidChangeNotification
if you're caching date formatters.

00:25:48.130 --> 00:25:52.490
In this case, I've just released and
nilled out the formatter I created

00:25:52.490 --> 00:25:56.250
so that it'll be recreated after
the user changes their locale.

00:25:56.250 --> 00:26:02.260
In addition, date and number formatters aren't thread-safe
so you need to either use locking or create a separate one

00:26:02.260 --> 00:26:05.840
for each thread that you're using these cache formatters on.

00:26:05.840 --> 00:26:10.970
But do note that regular expressions and data detectors
are thread-safe so you don't have to worry about locking

00:26:10.970 --> 00:26:14.720
or creating different ones for different threads there.

00:26:18.410 --> 00:26:23.770
So again, just to drive this point home, if you
would take 100 date formatters and use each of them

00:26:23.770 --> 00:26:30.110
to format the same date one time, it's about five to
six times slower that taking a single day formatter

00:26:30.110 --> 00:26:34.120
and formatting-- and using that to format 100 dates.

00:26:36.790 --> 00:26:38.830
Next, let's talk about property lists.

00:26:38.830 --> 00:26:44.580
These are really convenient way of serializing
and deserializing object graphs in Foundation.

00:26:44.580 --> 00:26:49.940
They're so convenient that you might be tempted to
use the right to file atomically methods on each

00:26:49.940 --> 00:26:53.450
of these collections, arrays, dictionaries, and strings.

00:26:53.450 --> 00:26:58.860
These are really convenient but you shouldn't
use them because they produce XML plists.

00:26:58.860 --> 00:27:03.270
And XML plists are two to three times
slower to decode that binary plists.

00:27:03.270 --> 00:27:10.300
So if you create plist at run time, make sure you
use NSPropertyListSerialization and explicitly pass

00:27:10.300 --> 00:27:18.400
in the NSPropertyListBinaryFormat_v1_0-- that'll
create a binary plist from your object graph.

00:27:18.400 --> 00:27:23.510
And then from that, the data you get back,
you can write that out to disk as you please.

00:27:23.510 --> 00:27:30.360
[ Pause ]

00:27:30.360 --> 00:27:33.310
So plists are not an incremental format.

00:27:33.310 --> 00:27:39.640
What that means is if you want to access a single value
out of a plist, we have to take that entire object graph

00:27:39.640 --> 00:27:45.180
into the plist, bring in some memory
before you can access that one element.

00:27:45.180 --> 00:27:49.810
Similarly, when you're writing out the plist,
if you modify a single element in the plist,

00:27:49.810 --> 00:27:55.080
we have to write out the entire object
graph just to signify that one change.

00:27:55.080 --> 00:28:03.890
So plists are great for small sets of objects, dozens of
objects, maybe hundreds of objects, no more than that.

00:28:03.890 --> 00:28:08.810
If you need to really encode a really large object
graph, you should probably be looking at a database

00:28:08.810 --> 00:28:11.880
or Core Data because those will be incremental.

00:28:11.880 --> 00:28:18.600
They'll only bring the data you care about into memory
and only write the changes that you made out to disk.

00:28:18.600 --> 00:28:20.690
Related to plist is NSCoding.

00:28:20.690 --> 00:28:25.480
NSCoding has the advantage that it's
not restricted to plistable types.

00:28:25.480 --> 00:28:34.190
It's-- You can define your own archiver essentially,
or your own encoder to encode your own custom types.

00:28:34.190 --> 00:28:39.070
And again this is generally not an incremental format.

00:28:39.070 --> 00:28:46.170
To access one object out of an archive, you generally have
to bring-- deserialize all the objects out of that archive.

00:28:46.170 --> 00:28:48.630
Keep this to small object graphs.

00:28:48.630 --> 00:28:55.040
Don't encode thousands of objects using NSCoding and this
is a time profile I actually pulled from a top 10 app.

00:28:55.040 --> 00:29:00.840
I know this was quitting pretty slowly and you can
actually see it's taking about 400 milliseconds

00:29:00.840 --> 00:29:05.120
to archive some large object graph at quit time.

00:29:05.120 --> 00:29:14.830
So really runtime profiler, make sure you're not blocked
on CPU and encoding or decoding these large object graphs

00:29:14.830 --> 00:29:20.760
with NSCoding because they can take
quite a while to encode or decode.

00:29:20.760 --> 00:29:26.820
Even if you don't explicitly use NSCoding, you're
probably implicitly using them by using NIBs.

00:29:26.820 --> 00:29:33.100
And the way you can keep the NSCoding usage down
in NIBs just to make sure your NIBs are lean,

00:29:33.100 --> 00:29:39.520
don't put objects in your NIB that aren't
associated with the files owner of that NIB.

00:29:42.950 --> 00:29:49.950
In iOS 4, we've added this new class called
UINib that actually lets you deserialize objects

00:29:49.950 --> 00:29:55.010
from the same NIB repeatedly over
and over again much faster.

00:29:55.010 --> 00:29:59.050
This is mostly used for table view cell NIBs.

00:29:59.050 --> 00:30:06.040
So in this example, I took this table view cell from the
advanced table view cells example and that's on the left.

00:30:06.040 --> 00:30:10.260
On the right, you can see the NIB
that that table view cell came from.

00:30:10.260 --> 00:30:16.220
So in our tableView cellForRowAtIndexPath, we have to
load the cell from the NIB if it's not in the reuse queue.

00:30:16.220 --> 00:30:25.530
So the previous way of doing this would be the-- called the
Foundation method, loadNibNamed, owner, options on NSBundle

00:30:25.530 --> 00:30:31.050
and this works if you're only viewing it once, if
you're only creating an object out of this NIB once.

00:30:31.050 --> 00:30:33.280
This is perfectly fine.

00:30:33.280 --> 00:30:37.690
But if you're creating for example a table
view cell, you're probably going to create

00:30:37.690 --> 00:30:40.500
that table view cell out of the NIB many times.

00:30:40.500 --> 00:30:48.570
So you want to use the UINib class to cache some
state associated with repeatedly instantiating NIBs

00:30:48.570 --> 00:30:56.980
and ask the UINib instance for the objects in that NIB
instead of asking the bundle for the objects in that NIB.

00:30:59.740 --> 00:31:06.380
And again, this takes-- this makes NIB loading
about 33 percent faster if you're going

00:31:06.380 --> 00:31:10.720
to load the same resource out of a NIB over and over again.

00:31:10.720 --> 00:31:18.330
So in summary, most of the Foundation types have
pretty good performance if you use them correctly.

00:31:18.330 --> 00:31:20.630
So understand the API.

00:31:20.630 --> 00:31:24.290
Make sure you call the highest level API possible.

00:31:24.290 --> 00:31:29.220
Avoid reinitializing expensive classes
such as date formatters over and over again

00:31:29.220 --> 00:31:32.300
if you're going to use them over and over again.

00:31:32.300 --> 00:31:39.540
And finally, make sure you restrict your use plist
and NSCoding to relatively small object graphs.

00:31:39.540 --> 00:31:48.740
We ship a lot of user guides with our SDK that let you know
how to use collections, property lists, NSCoding and NIBs,

00:31:48.740 --> 00:31:52.250
so take a look at those if you have more questions.

00:31:52.250 --> 00:31:55.570
We also had an Understanding Foundation session yesterday

00:31:55.570 --> 00:31:58.960
that you should look at on video
if you're new to Foundation.

00:31:58.960 --> 00:32:01.710
Next, let's talk about the filesystem.

00:32:01.710 --> 00:32:09.510
The first thing you should probably do if you think you have
a filesystem performance issue is run the System Usage tool.

00:32:09.510 --> 00:32:12.060
And what this does is it prints out a list

00:32:12.060 --> 00:32:17.140
of all the filesystem related system
calls your application has made along

00:32:17.140 --> 00:32:20.520
with the backtrace that caused that system call.

00:32:20.520 --> 00:32:31.310
So this is a great place to look for unexpected I/O and
figure out what backtrace caused that unexpected I/O.

00:32:31.310 --> 00:32:36.090
There's one caveat with this which is that if you're
using memory mapped files, it doesn't yet show bytes

00:32:36.090 --> 00:32:41.510
that were read in-- caused by paging
in bytes from the memory mapped file.

00:32:41.510 --> 00:32:45.560
So some best practices for working with the Filesystem,

00:32:45.560 --> 00:32:50.170
you should definitely test your
application on different types of devices.

00:32:50.170 --> 00:32:57.040
We've advertised that the 3GS is two times
faster than the 3G in CPU and there are--

00:32:57.040 --> 00:33:01.880
also very significant performance
differences in read and write performance.

00:33:01.880 --> 00:33:08.900
So you really need to make sure you test application
on an iPhone 3G if you're targeting an iPhone 3G.

00:33:08.900 --> 00:33:16.950
In addition, if you're doing really long blocking
I/Os just as with any other long blocking operation,

00:33:16.950 --> 00:33:21.350
move them off the main thread using
any of our threading APIs,

00:33:21.350 --> 00:33:25.530
Grand Central Dispatch, NSOperations queues and so forth.

00:33:25.530 --> 00:33:31.490
But if you are really doing a really long
I/O, say with NSData dataWithContentsOfFile,

00:33:31.490 --> 00:33:35.370
you might not want to call that
method with a really large file.

00:33:35.370 --> 00:33:39.940
For example, if I call dataWithContentsOfFile
on a 10 megabyte file,

00:33:39.940 --> 00:33:44.860
we're going to allocate a 10 megabyte
buffer inside your application.

00:33:44.860 --> 00:33:51.640
We're going to block your application until we can read all
those 10 megabytes into that buffer in your application.

00:33:51.640 --> 00:33:55.290
Instead, you should probably use
dataWithContentsofMappedFile

00:33:55.290 --> 00:33:59.110
and that will return almost immediately.

00:33:59.110 --> 00:34:03.820
And we'll use the virtual memory subsystem
to demand page in data from that file

00:34:03.820 --> 00:34:07.270
as you touch the data as we talked
about earlier in the talk.

00:34:07.270 --> 00:34:13.010
In addition, if we you want to use standard
seat based I/O, you can use NSFileHandle.

00:34:13.010 --> 00:34:21.610
One last point here is that if you're repeatedly opening
or statting a path inside the system usage instrument,

00:34:21.610 --> 00:34:28.590
you probably shouldn't do that because opening or
statting paths incurs an additional permissions check

00:34:28.590 --> 00:34:33.150
above the usual UNIX permissions
check in our system where we base--

00:34:33.150 --> 00:34:37.860
we recheck whether your app has access to that path.

00:34:37.860 --> 00:34:42.630
So don't recursively enumerate a
directory with say a thousand files

00:34:42.630 --> 00:34:45.110
and ask for the modification date on all those files.

00:34:45.110 --> 00:34:47.390
That's probably going to be a bit slow.

00:34:47.390 --> 00:34:58.640
To actually get paths into Filesystem, we have a few APIs,
NSBundle gives you paths inside your read-only app bundle.

00:34:58.640 --> 00:35:02.550
If you want to store user defaults, you
probably should use NSUserDefaults rather

00:35:02.550 --> 00:35:07.570
than any home-grown default system
because those will be backed up for you.

00:35:07.570 --> 00:35:13.920
If you want writable paths, usually you'll
use NSSearchPathForDirectoriesInDomain

00:35:13.920 --> 00:35:17.900
and you should pick the right directory
for the type of data you're storing.

00:35:17.900 --> 00:35:24.380
If you're storing persistent user-related data,
use NSDocumentDirectory because it gets backed up.

00:35:24.380 --> 00:35:29.460
It stays between launches and it's always there.

00:35:29.460 --> 00:35:31.980
NSUserDefaults is the same.

00:35:31.980 --> 00:35:37.720
If you just need some data that can be reconstructed,
you should probably put in NSCachesDirectory

00:35:37.720 --> 00:35:42.040
because it won't be backed up and won't
affect the user backup performance.

00:35:42.040 --> 00:35:49.130
And finally, if you just need to scribble somewhere for this
particular invocation of the app, use NSTemporaryDirectory.

00:35:49.130 --> 00:35:55.000
One thing I want to point is that you should
not be constructing arbitrary paths outside

00:35:55.000 --> 00:35:58.100
of your application sandbox and writing to them.

00:35:58.100 --> 00:36:02.490
That's a system protected interface
and it's not guaranteed to work.

00:36:02.490 --> 00:36:07.810
Even if you can write to a particular path outside
of your sandbox now and in the next release,

00:36:07.810 --> 00:36:14.630
you might not be able to and your app will break, the
customers will get angry, all sorts of sadness will ensue.

00:36:14.630 --> 00:36:18.250
So don't do that.

00:36:18.250 --> 00:36:24.180
So in summary, start with the System Usage
tool, look for any unexpected I/Os and figure

00:36:24.180 --> 00:36:28.110
out from the backtrace what caused those unexpected I/Os.

00:36:28.110 --> 00:36:35.110
If you have really large files, try to pick an incremental
format or you can try using the memory mapped file option

00:36:35.110 --> 00:36:39.850
to demand page in that large file as necessary.

00:36:39.850 --> 00:36:46.240
And as with any other long lasting operation,
perform your long I/Os off the main thread.

00:36:49.430 --> 00:36:53.850
Next, let's talk about manipulating
large datasets and databases.

00:36:54.970 --> 00:36:59.090
We really like databases because they let
you bring just the information you care

00:36:59.090 --> 00:37:02.940
about into memory rather than entire data set into memory.

00:37:02.940 --> 00:37:10.690
There're also additional features that databases give
you, transactional storage, isolation, durability,

00:37:10.690 --> 00:37:14.570
those are all great properties for a persistent data store.

00:37:14.570 --> 00:37:20.500
And we really recommend you use Core Data if possible if
you're creating a new application because we've taken a lot

00:37:20.500 --> 00:37:24.050
of the grudge work of using databases in Core Data.

00:37:24.050 --> 00:37:25.820
There is automatic schema management.

00:37:25.820 --> 00:37:31.410
There is also iPhone specific enhancements for
example table view section loading is faster

00:37:31.410 --> 00:37:35.560
in Core Data because we especially optimized it.

00:37:35.560 --> 00:37:41.680
The Native SQLite library is available if you
want to work with databases directly but just note

00:37:41.680 --> 00:37:46.380
that it's much more low level and requires more care.

00:37:46.380 --> 00:37:50.220
No matter what framework you choose
though, you must have the same data model.

00:37:50.220 --> 00:37:53.690
So understand some of the basic concepts in data modeling.

00:37:53.690 --> 00:38:00.470
I've referenced this object modeling guide inside
the Cocoa Fundamentals Guide which talks about some

00:38:00.470 --> 00:38:06.420
of the key concepts such as one-to-one relationships,
one-to-many relationships, many-to-many relationships.

00:38:06.420 --> 00:38:10.890
You should understand these if you want to
be able to create a performant data model.

00:38:10.890 --> 00:38:17.240
What I'm going to talk about a bit more is actually
SQLite because we haven't had as much coverage of SQLite

00:38:17.240 --> 00:38:21.460
and we know that some of you are
still using it rather than Core Data.

00:38:21.460 --> 00:38:27.680
If you are using Core Data, please watch the Understanding
Performance in Core Data session from yesterday.

00:38:27.680 --> 00:38:35.740
So the first thing you should do if you have a performance
issue in SQLite is to run the sqlite3_profile function

00:38:35.740 --> 00:38:44.110
and this will install a profiling method which calls back
the profile function every time a statement executes along

00:38:44.110 --> 00:38:48.050
with an estimate of how long that statement took to execute.

00:38:48.050 --> 00:38:54.570
So in this case, the profile function just prints out
the SQL statement along with how long it took to execute.

00:38:54.570 --> 00:38:59.810
This is really helpful for finding
out if you have a lot of slow queries

00:38:59.810 --> 00:39:06.630
or maybe just one really slow query
that you should be concentrating on.

00:39:06.630 --> 00:39:11.770
In addition, you should keep in mind that prepared
statements in SQLite are really little programs.

00:39:11.770 --> 00:39:20.500
Every time you call SQLite3 prepare, you're really
compiling a little program for a SQLite to interpret.

00:39:20.500 --> 00:39:24.610
So you can actually even see the
instructions of this program

00:39:24.610 --> 00:39:30.520
by prepending the statement with
EXPLAIN in the SQLite shell tool.

00:39:30.520 --> 00:39:35.410
So what this means is you probably don't want
to recompile programs over and over again.

00:39:35.410 --> 00:39:39.300
So likewise, you don't want to prepare
statements over and over again.

00:39:39.300 --> 00:39:45.380
So if you're going to use a prepared
statement repeatedly, keep it in memory.

00:39:45.380 --> 00:39:50.800
Conversely, if you're not going to use the prepared
statement over and over again, you should release it.

00:39:50.800 --> 00:39:56.630
We've actually seen some applications that keep every
single prepared statement they've ever created in memory

00:39:56.630 --> 00:40:04.260
and then 1,000, 2,000, 3,000 statements later, the app
gets terminated because that memory was never released.

00:40:06.710 --> 00:40:17.230
So if you used sqlite3_profile to find an offending
query and you've prepared your query efficiently,

00:40:17.230 --> 00:40:23.740
the next thing you want to do is use EXPLAIN QUERY PLAN or
EXPLAIN to actually understand what SQLite is doing execute

00:40:23.740 --> 00:40:30.790
that query and you could do this by
opening your database on your Mac

00:40:30.790 --> 00:40:35.280
and prepending the statement with
EXPLAIN QUERY PLAN or EXPLAIN.

00:40:35.280 --> 00:40:41.040
And one of the things you'll notice when you do this
is that if you switch the order of tables in a JOIN,

00:40:41.040 --> 00:40:46.880
you might not be able to affect the order in which SQLite
traverses the table, so this might be something you want

00:40:46.880 --> 00:40:50.940
to play with if you have a JOIN that's slow.

00:40:50.940 --> 00:40:55.100
In addition, watch out for transient tables.

00:40:55.100 --> 00:41:01.370
If you explain a statement and you see an OpenEphemeral
instruction, you've created a temporary table

00:41:01.370 --> 00:41:05.010
for the lifetime of that particular statement.

00:41:05.010 --> 00:41:12.610
So these can cause pretty big performance issues if you've
created a temporarily table of many thousands of rows in it.

00:41:12.610 --> 00:41:18.530
Usually these come from sorting a
table without an index or subselects

00:41:18.530 --> 00:41:24.490
and that can cause the first sqlite3_step
to take a pretty long time.

00:41:24.490 --> 00:41:27.250
So let's go over an example.

00:41:27.250 --> 00:41:31.810
Here we have a sample schema from a music player.

00:41:31.810 --> 00:41:33.300
There's a track.

00:41:33.300 --> 00:41:35.170
Each track has an album.

00:41:35.170 --> 00:41:37.400
Albums could have many tracks.

00:41:37.400 --> 00:41:46.480
Each track also has an artist and
artists could have authored many tracks.

00:41:46.480 --> 00:41:51.780
So without any indices, a Naive
query plan might look like this.

00:41:51.780 --> 00:41:57.850
I open my database up in the SQLite
tool on my Mac and I EXPLAIN QUERY PLAN,

00:41:57.850 --> 00:42:03.250
SELECT * FROM Track WHERE AlbumID is a
particular album ordered by AlbumOrder

00:42:03.250 --> 00:42:09.400
and what that means is select all the tracks
in an album and sort that album by track order.

00:42:09.400 --> 00:42:12.780
That's a pretty simple and reasonable query.

00:42:12.780 --> 00:42:18.960
Without any indices, it's telling me that it's going to
do a table scan of track and what that's going to look

00:42:18.960 --> 00:42:25.610
like is actually we're going to go over every row
in that table and then we're going to find the rows

00:42:25.610 --> 00:42:30.490
that match the album we care about,
in this case AlbumID of 2.

00:42:30.490 --> 00:42:36.060
We're going to move that result set into
a transient table and then we're going

00:42:36.060 --> 00:42:39.430
to sort it to satisfy the order by criterion.

00:42:39.430 --> 00:42:41.040
And that's pretty inefficient.

00:42:41.040 --> 00:42:51.060
So perhaps you've worked with databases
before and, you know, well,

00:42:51.060 --> 00:42:55.260
I have a where clause on this albumID,
I need an index on albumID.

00:42:55.260 --> 00:43:02.220
And that's great because now when we look for all
albums with AlbumID=2, we're got a logarithmic--

00:43:02.220 --> 00:43:10.440
in logarithmic time, we're going to jump to AlbumID=2 in the
index and we're going to use that to select all the albums,

00:43:10.440 --> 00:43:13.820
all the tracks in that album from the track table.

00:43:13.820 --> 00:43:22.780
But again, we've iterated over those tracks in unsorted
order so we have to create a temporary table that holds

00:43:22.780 --> 00:43:30.030
that entire result set and then sort all those
results before giving you back the pointer

00:43:30.030 --> 00:43:33.330
to that first result in this result set.

00:43:33.330 --> 00:43:38.210
So there's a lot going on there before
that first sqlite3_step returned.

00:43:38.210 --> 00:43:46.020
So in this particular case, what you really want is
an index that sorts all the tracks first by the album

00:43:46.020 --> 00:43:48.900
and then by the track order within that album.

00:43:48.900 --> 00:43:56.130
So here we've created an index,
TrackAlbumIDOrderIndex ON Track(AlbumID, AlbumOrder).

00:43:56.130 --> 00:44:04.150
And now when we try to select all the tracks in the
album, ordered by the track order in that album,

00:44:04.150 --> 00:44:13.920
we'll first look at the index and in logarithmic
time, we'll jump to the first track in that album

00:44:13.920 --> 00:44:21.300
and now we can just iterate over
the track table in sorted order.

00:44:21.300 --> 00:44:25.440
And you can see that EXPLAIN QUERY
PLAN has showed this to us by saying,

00:44:25.440 --> 00:44:31.510
table track with index the index we created
ORDER BY which means that we're iterating

00:44:31.510 --> 00:44:38.510
over to the track table using this index and also
using that index to satisfy the order by criterion.

00:44:38.510 --> 00:44:47.040
[ Pause ]

00:44:47.040 --> 00:44:53.060
The last thing I want to point out here is
that the query planner also works with Joins.

00:44:53.060 --> 00:44:57.910
So, if you have a query that joins two tables,

00:44:57.910 --> 00:45:01.940
it'll actually tell you the order in
which it's visiting those two tables.

00:45:01.940 --> 00:45:06.610
I won't go over this in detail but as
you can se in this particular query plan,

00:45:06.610 --> 00:45:10.790
we visit the track table using an index and then we join

00:45:10.790 --> 00:45:16.150
on to the artist table using the
built-in primary key index of artist.

00:45:16.150 --> 00:45:20.220
One last concept that I'm going to
talk about in SQLite is the page cache.

00:45:20.220 --> 00:45:29.450
When you have a SQLite database file, it's split into a set
of contiguous pages, each generally 4 kilobytes in length.

00:45:29.450 --> 00:45:35.330
And it's just like any other file,
just a contiguous array of bytes.

00:45:35.330 --> 00:45:44.520
But logically, what those contiguous array of bytes mean is
a set of B-Trees for each table and index in your database.

00:45:44.520 --> 00:45:50.370
So, each of the nodes in that B-Tree is a separate page.

00:45:50.370 --> 00:45:59.890
When we want to actually access any page in that B-Tree, we
actually have to bring it into memory into a data structure

00:45:59.890 --> 00:46:04.720
that SQLite maintains for you called the page cache.

00:46:04.720 --> 00:46:10.760
So in this case, if we are doing an
in order traversal of this B-Tree,

00:46:10.760 --> 00:46:13.910
we're actually going to overwrite
the existing contents of what was

00:46:13.910 --> 00:46:18.190
in the page cache with the pages that are in this table.

00:46:22.690 --> 00:46:28.920
So, what this means is that if you want to
access say a byte from a table in SQLite,

00:46:28.920 --> 00:46:35.820
what you're actually doing is you're bringing
the entire page around that byte into memory.

00:46:39.810 --> 00:46:47.570
So, you should keep this in mind when performing operations
with SQLite, I/O is done in page-sized increments.

00:46:47.570 --> 00:46:54.260
In particular, if you're updating or modifying the
database in any way, you should surround your updates

00:46:54.260 --> 00:47:04.230
with transactions, because otherwise, each UPDATE
or INSERT will modify a page in the page cache.

00:47:04.230 --> 00:47:14.100
It'll journal out or copy the page that's being modified
from the database file out to a journal file, and finally,

00:47:14.100 --> 00:47:16.940
you'll be able to modify the page you cared about.

00:47:16.940 --> 00:47:24.120
So, there's a lot of IO going on, a lot of page-sized
IO going on for just your little small update.

00:47:25.930 --> 00:47:31.380
In addition, because this page cache
is a fixed size, 1 megabyte by default,

00:47:31.380 --> 00:47:33.820
you shouldn't use your database as a filesystem.

00:47:33.820 --> 00:47:37.800
You shouldn't store large BLOBs inside your database.

00:47:37.800 --> 00:47:44.310
For example, assume you stored a 1 megabyte BLOB
inside your database, if your page cache is 1 megabyte,

00:47:44.310 --> 00:47:48.800
you've actually just blown out the entire page
cache and replaced it with that 1 megabyte BLOB,

00:47:48.800 --> 00:47:54.950
and that will make your joins slower
and your subsequent selects slower.

00:47:54.950 --> 00:48:01.170
In addition, because SQLite is
journaled, you'll pay a double cost

00:48:01.170 --> 00:48:05.730
in journaling the data before actually writing it to disk.

00:48:05.730 --> 00:48:12.420
So, instead of using the database as a filesystem, you
should probably store pointers to the filesystem instead,

00:48:12.420 --> 00:48:15.960
and store those large BLOBs in the filesystem.

00:48:19.970 --> 00:48:26.320
And just to drive this point home, if you don't
surround your batch updates with transactions,

00:48:26.320 --> 00:48:28.570
you can really shoot yourself in the foot.

00:48:28.570 --> 00:48:32.830
In this case, I took a pretty simple database
and made a thousand updates and left it

00:48:32.830 --> 00:48:42.660
in the standard autocommit mode, which means one transaction
for every modification, and I did 24 megabytes of I/O.

00:48:42.660 --> 00:48:49.070
Whereas if I surrounded those same 1000 updates with
a single transaction, I did 40 kilobytes of I/O.

00:48:49.070 --> 00:48:51.350
So, really look out for this.

00:48:51.350 --> 00:48:53.620
You'll actually see this in the System Usage instrument.

00:48:53.620 --> 00:48:57.940
If you see a lot of journal or a SQLite database activity,

00:48:57.940 --> 00:49:02.400
make sure you've surrounded your
modifications with transactions.

00:49:05.510 --> 00:49:10.620
So in summary, if you're using
databases, use Core Data if possible.

00:49:10.620 --> 00:49:13.420
It takes out a lot of the grudge work for you.

00:49:13.420 --> 00:49:21.120
If you are using SQLite directly and you have a performance
problem, first start by using a sqlite3_profile to figure

00:49:21.120 --> 00:49:24.490
out what statement is causing the performance issue.

00:49:24.490 --> 00:49:29.190
Once you know the statement that's causing the
performance issue, use EXPLAIN QUERY PLAN to figure

00:49:29.190 --> 00:49:32.350
out what SQLite is doing to execute that query.

00:49:32.350 --> 00:49:37.360
If you're doing a lot of modifications,
make sure your transactions--

00:49:37.360 --> 00:49:41.620
make sure you're using transactions
to surround the modifications

00:49:41.620 --> 00:49:47.390
so you amortize the cost of all those page-sized I/Os.

00:49:47.390 --> 00:49:55.600
If you want more resources on using SQLite or Core Data
directly, we had a few sessions on Core Data yesterday.

00:49:55.600 --> 00:50:02.030
In addition, if you're using SQLite directly, I highly
recommend you take a look at the YouTube video by D.

00:50:02.030 --> 00:50:05.530
Richard Hipp that-- where he gives
an introduction to SQLite.

00:50:05.530 --> 00:50:09.660
He wrote the framework, so he knows how to use it.

00:50:09.660 --> 00:50:18.360
And there's also a lot of documentation on the website for
all the key features, journaling, file format and so forth.

00:50:18.360 --> 00:50:22.210
So, take a look at that if you need more help.

00:50:22.210 --> 00:50:26.690
Finally, let's talk about making your
app scale well with large data sets.

00:50:26.690 --> 00:50:35.820
Your app could be faced with an extremely
large data set, thousands of items.

00:50:35.820 --> 00:50:40.410
And so, to make this-- your app perform well in the
face of that data set, make sure you're thinking

00:50:40.410 --> 00:50:45.910
about the minimum amount of work needed
to make the critical methods fast.

00:50:45.910 --> 00:50:49.120
And as an example, we'll take a
look at the Contacts application.

00:50:49.120 --> 00:50:59.580
So, I took a few timings of launching Contacts with 30
contacts, 300 contacts and 3000 contacts on an iPhone 3G.

00:50:59.580 --> 00:51:05.100
And as you can see, the launch time is pretty much
the same no matter how much data you throw at it.

00:51:05.100 --> 00:51:09.140
Now, if your app deals with a lot of data,
you should probably do this with your app,

00:51:09.140 --> 00:51:12.840
increase the data size by an order
of magnitude over and over again,

00:51:12.840 --> 00:51:17.130
and see how your launch time or
other critical operations respond.

00:51:17.130 --> 00:51:21.730
Ideally, you want something that looks like this,
something that stays relatively constant even

00:51:21.730 --> 00:51:25.320
as you're increasing the size of your data set.

00:51:28.110 --> 00:51:33.390
So, in launching applications,
there are a few critical methods.

00:51:33.390 --> 00:51:39.990
Most of the performance is driven by this
tableView that you see when you launch Contacts.

00:51:39.990 --> 00:51:44.570
The first thing you have to do is tell
the tableView how many sections are

00:51:44.570 --> 00:51:46.600
in your tableView and the title for those sections.

00:51:46.600 --> 00:51:52.490
You also have to tell the tableView
the number of rows in each section.

00:51:52.490 --> 00:51:59.160
If you have an index bar as in Contacts, you
have to give the tableView the index bar.

00:51:59.160 --> 00:52:07.370
And finally, for each of these visible cells on screen,
you're going to have to load and create the tableView cells.

00:52:10.470 --> 00:52:19.110
So, let's go over how to make each of these operations
fast or at least how we've made them fast in Contacts.

00:52:19.110 --> 00:52:25.100
So, to load sections quickly, the naive approach would
be to take your entire data set, suck it into memory,

00:52:25.100 --> 00:52:28.010
and then post-process them into sections.

00:52:28.010 --> 00:52:32.490
And that works for small data sets, but of course
it grows linearly with the size of your data set.

00:52:32.490 --> 00:52:38.500
If you have 10 times more data, it's going to take
at least 10 times longer to load your sections.

00:52:38.500 --> 00:52:42.540
So, a better idea if you're faced with large
data sets is to cache those sections counts

00:52:42.540 --> 00:52:46.180
to make this critical section count method fast.

00:52:46.180 --> 00:52:52.300
In Contacts, we actually have a separate table that we
maintain by triggers that maintains those section counts.

00:52:52.300 --> 00:52:55.980
It's actually a little hard to do right if
you're targeting multiple localizations.

00:52:55.980 --> 00:53:02.790
So, take a look at the DerivedProperty example on
our Developer Sample Code website to get an idea

00:53:02.790 --> 00:53:06.910
of how to deal with differing localizations.

00:53:06.910 --> 00:53:12.890
Good news for Core Data users is they
get them-- they get this for free.

00:53:12.890 --> 00:53:21.240
If you pass in the-- if you use the cache name parameter
from NSFetchedResultsController initWithFetchRequest

00:53:21.240 --> 00:53:29.810
to managedObjectContext setionNameKeyPath cacheNname,
it'll save those section counts off to a side file outside

00:53:29.810 --> 00:53:35.440
of the database, actually, and use that
cache file if it matches your fetch request.

00:53:35.440 --> 00:53:40.780
Otherwise, it'll cache the results of the fetch request
so that the next time you make that fetch request,

00:53:40.780 --> 00:53:45.140
maybe the next time you'd launch the
application, it'll be really fast.

00:53:48.410 --> 00:53:51.350
Next, we need to load the index bar quickly.

00:53:51.350 --> 00:53:55.160
You can do what we do in Contacts and cheat.

00:53:55.160 --> 00:53:56.790
You could always just load the same index bar.

00:53:56.790 --> 00:54:01.360
Even if you have no Contacts, you'll
notice that we always put A to Z and number

00:54:01.360 --> 00:54:05.470
as your index bar, and that's perfectly fine.

00:54:05.470 --> 00:54:10.010
Otherwise, if your index bar is going to change
based on the number of sections you have,

00:54:10.010 --> 00:54:15.700
anything you've done to make section loading faster
will also make your index bar loading faster.

00:54:19.080 --> 00:54:23.610
And finally, let's look at loading the cells
that are visible on the screen quickly.

00:54:23.610 --> 00:54:31.220
And this is where, if you're using a database, some of the
profiling tools that I showed you earlier might help you.

00:54:31.220 --> 00:54:36.840
What you really don't want to do is to
bring in the entire table all at once just

00:54:36.840 --> 00:54:40.430
to retrieve one cell's worth of information.

00:54:40.430 --> 00:54:43.650
So, what we do in Contacts is we actually do something

00:54:43.650 --> 00:54:48.790
where we select the Contacts and
batches as you're scrolling along.

00:54:48.790 --> 00:54:54.100
It turns out LIMIT and OFFSET is
not particularly fast in SQLite.

00:54:54.100 --> 00:54:56.960
There's a pretty long section on this on the website.

00:54:56.960 --> 00:55:02.450
But if you're iterating over a
small index, it generally works OK.

00:55:02.450 --> 00:55:04.760
There's also a document on the website called the--

00:55:04.760 --> 00:55:09.450
that describes the scrolling cursor
method that you might want to use.

00:55:09.450 --> 00:55:14.990
So, if you're having trouble loading cells quickly,
for example, you use time profile or you find

00:55:14.990 --> 00:55:21.380
that you're spending a lot of time in tableView
cellForRowAtIndexPath, take a look at these documents.

00:55:21.380 --> 00:55:25.580
And again, this is really where
proper indices will help you.

00:55:25.580 --> 00:55:28.380
If you have a proper index, hopefully, you only have

00:55:28.380 --> 00:55:33.340
to touch very little data to get
one cell's worth of information.

00:55:33.340 --> 00:55:39.030
If you don't have a proper index, you do a transient sort
over your entire result set just to get the first table cell

00:55:39.030 --> 00:55:46.020
on the tableView, then it's probably
going to be a bit slower.

00:55:46.020 --> 00:55:53.140
So, in summary, test and profile you apps with different
data set sizes, and only bring in the data necessary

00:55:53.140 --> 00:55:57.530
to satisfy the critical methods in your application.

00:55:57.530 --> 00:55:59.610
I've only looked at one example here.

00:55:59.610 --> 00:56:05.510
This is really something that you've got to do that's
custom to your app to figure out what methods are critical,

00:56:05.510 --> 00:56:08.360
and make sure you're only doing what's necessary.

00:56:08.360 --> 00:56:15.400
So, in summary, reduce the dirty memory usage in your app.

00:56:15.400 --> 00:56:17.470
Dirty memory causes low memory warnings.

00:56:17.470 --> 00:56:24.170
It crowds out clean memory that might be--
that you might be using for executing code.

00:56:24.170 --> 00:56:27.430
Adhere to the Foundation API best practices.

00:56:27.430 --> 00:56:31.820
Foundation is generally pretty performant,
but you do have to use it correctly

00:56:31.820 --> 00:56:34.670
to get the maximum performance out of it.

00:56:34.670 --> 00:56:41.990
If you have filesystem or database performance issues, use
our profiling tools to figure out where the bottlenecks are.

00:56:41.990 --> 00:56:47.700
If you have a critical query or a critical file that's
taking a really long time to load, and hopefully,

00:56:47.700 --> 00:56:55.220
that'll give you an idea of where to start to
make that critical query or file faster to load.

00:56:55.220 --> 00:56:59.010
And finally, make sure to test your
apps on different types of devices

00:56:59.010 --> 00:57:02.590
because each device has different
performance characteristics.

00:57:02.590 --> 00:57:11.130
If you have more questions, please
contact our evangelist, Michael Jurewitz.

00:57:11.130 --> 00:57:13.600
And you can always talk to us on the Developer Forums.

00:57:13.600 --> 00:57:18.390
I want to point you to some of these related sessions.

00:57:18.390 --> 00:57:25.280
These of course are all in the past, but
you can watch them on video afterwards.

00:57:25.280 --> 00:57:27.800
We had a Performance Optimization on iPhone OS session,

00:57:27.800 --> 00:57:31.720
that's more of a first timer session,
if you're new to the tools.

00:57:31.720 --> 00:57:32.630
Please take a look at that.

00:57:32.630 --> 00:57:34.550
We have a lot of demos there.

00:57:34.550 --> 00:57:37.090
There's the first part of this talk,
it was yesterday where we talked

00:57:37.090 --> 00:57:42.790
about animations and optimizing power and responsiveness.

00:57:42.790 --> 00:57:49.910
If you want to learn to use the memory tools or
other instruments, attend these Instruments talks.

00:57:49.910 --> 00:57:57.510
And finally, we have a Core Data talk if you
have Core Data performance issues and that's all.

00:57:57.510 --> 00:57:59.630
[ Applause ]

