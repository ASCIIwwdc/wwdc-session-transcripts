WEBVTT

00:00:06.680 --> 00:00:11.590
>> My name is Chris Kane and I'm an
engineer with the Cocoa Frameworks team.

00:00:11.590 --> 00:00:24.500
Today, I'm going to be talking about what has changed
in Foundation for iPhone, not iPhone OS 4, iOS 4.

00:00:24.500 --> 00:00:29.930
iOS 4's Foundation represents the
first major update to Foundation

00:00:29.930 --> 00:00:36.280
that you folks working with the iOS SDK will have seen.

00:00:36.280 --> 00:00:46.680
In iPhone OS 2 and iPhone OS 3, we saw a Foundation
in the system which was essentially the system,

00:00:46.680 --> 00:00:55.500
the Foundation that was in the Mac OS X, 10.5 with, you
know, a few changes here and there; some APIs were missing

00:00:55.500 --> 00:00:57.710
and there were a few of the little additions.

00:00:57.710 --> 00:01:07.840
In iOS 4, now we have a Foundation which more or less
corresponds to the Foundation in Mac OS X, 10.6 with,

00:01:07.840 --> 00:01:14.970
you know, some things that are, you know,
different still, including some new APIs

00:01:14.970 --> 00:01:20.560
that haven't yet appeared in Mac OS X itself.

00:01:20.560 --> 00:01:23.260
Now there have been a lot of changes.

00:01:23.260 --> 00:01:26.410
I can't cover all of them so I'm going
to be covering the highlights here.

00:01:26.410 --> 00:01:34.180
I'm going to begin by talking about blocks and new
block-based APIs that we've added to Foundation

00:01:34.180 --> 00:01:39.100
and then I'm going to cover some
additional changes that we've done.

00:01:39.100 --> 00:01:41.590
So I'm beginning with blocks.

00:01:41.590 --> 00:01:48.440
Why? Well, blocks are a very interesting,
new functionality that we've added

00:01:48.440 --> 00:01:55.950
and they're a very important new functionality as well
but another key reason that I'm beginning with blocks is

00:01:55.950 --> 00:02:07.180
that as we, we'll see a little bit today but also going into
the future, block-based APIs are going to be very important.

00:02:07.180 --> 00:02:14.630
And as we move forward, it's very likely
that a block-based API may be the only way

00:02:14.630 --> 00:02:17.150
to get access to certain functionality.

00:02:17.150 --> 00:02:25.850
So it's very important that you understand blocks
and understand how to use them properly in order

00:02:25.850 --> 00:02:31.430
to access all the available functionality in the system.

00:02:31.430 --> 00:02:37.320
Well, for those of you who may not have seen
all of the public materials that we've had,

00:02:37.320 --> 00:02:47.200
out since at least Snow Leopard was released back in August
last year, I'm going to do a little review of blocks.

00:02:47.200 --> 00:02:49.720
So what are blocks?

00:02:49.720 --> 00:02:54.860
Well, a block is an object which represents a chunk of code.

00:02:54.860 --> 00:02:58.570
A block is used much like a function.

00:02:58.570 --> 00:03:05.770
If you're familiar with say functional
programming languages, you may have seen closures.

00:03:05.770 --> 00:03:12.730
In C++, you may have run across things that,
constructs that are called function objects.

00:03:12.730 --> 00:03:19.180
You know, certain ways you write C++ classes
and those things are very similar to blocks,

00:03:19.180 --> 00:03:23.270
not quite the same though but very
similar in spirit to blocks.

00:03:23.270 --> 00:03:29.130
Well, blocks are objects with some code,
that know how to execute some code.

00:03:29.130 --> 00:03:34.150
The key interesting thing Ob-C
is that they are like NSObjects.

00:03:34.150 --> 00:03:37.940
They respond to all the NSObject methods.

00:03:37.940 --> 00:03:43.320
But blocks are not simply an Objective-C
bit of functionality.

00:03:43.320 --> 00:03:51.360
Blocks are available to all the C-based languages
for which Apple ships a compiler, that's C, C++,

00:03:51.360 --> 00:03:55.360
as well as Objective-C and Objective-C++.

00:03:55.360 --> 00:04:02.700
Now, as I say blocks are bits of code.

00:04:02.700 --> 00:04:06.150
Blocks are used a lot like function pointers.

00:04:06.150 --> 00:04:14.220
Here, I'm going to demonstrate the basic syntax of
using a block or declaring a block, I should say.

00:04:14.220 --> 00:04:20.490
First, I have a variable there on the left
called myBlock and in front of it is a carat.

00:04:20.490 --> 00:04:26.700
The carat is the signal to the compiler
that you're intending to declare a block.

00:04:26.700 --> 00:04:33.140
Block-type declarations look a lot
like function pointer declarations

00:04:33.140 --> 00:04:37.650
with the star or the asterisk replaced with a carat.

00:04:37.650 --> 00:04:46.190
In this case, the block returns an int, so that's the return
value, the return type I should say, there on the left

00:04:46.190 --> 00:04:48.570
and it takes one argument, which is also int.

00:04:48.570 --> 00:04:50.940
So a very simple block.

00:04:50.940 --> 00:04:59.640
On the right side of the assignment operator, we have a
block literal and you'll see, you'll be seeing these a lot

00:04:59.640 --> 00:05:03.290
and you'll be writing these a lot in your code.

00:05:03.290 --> 00:05:09.540
At the left side of the block literal,
we have the carat sign followed

00:05:09.540 --> 00:05:14.950
by the parenthesized argument list
just like a function argument list.

00:05:14.950 --> 00:05:22.430
In this case, we have of course the one argument
which is called num and then inside the curly braces,

00:05:22.430 --> 00:05:29.490
just like a function has, you know, curly braces surrounding
its body, we have all the statements of the block.

00:05:29.490 --> 00:05:31.270
myBlock in this case is very simple.

00:05:31.270 --> 00:05:37.400
It's just got one return statement in it and all
the return statement does is multiply num by,

00:05:37.400 --> 00:05:43.480
which is the argument, by this variable called multiplier.

00:05:43.480 --> 00:05:53.870
Now, this particular case, the block is very simple but
you can have many lines of code within the curly braces

00:05:53.870 --> 00:05:59.380
but for the purposes of my talk, I have to keep
the blocks nice and short to fit on the slides.

00:05:59.380 --> 00:06:05.780
So I'm not going to be showing a lot
of multiline blocks in this talk.

00:06:05.780 --> 00:06:07.930
Well, I didn't explain what this was.

00:06:07.930 --> 00:06:13.560
I said it was a variable called multiplier which,
you know, you can obviously see for yourself.

00:06:13.560 --> 00:06:17.600
Well, all this is, is a local variable.

00:06:17.600 --> 00:06:26.700
One of the most interesting things about blocks is that they
can access and capture variables' values that are in scope.

00:06:26.700 --> 00:06:33.440
So in this case, I have a local variable called
multiplier which the block can sort of access out.

00:06:33.440 --> 00:06:38.010
It doesn't have to be declared within the block.

00:06:38.010 --> 00:06:43.240
In this case, it's being declared outside the block but
the block can still get at it because it's in scope.

00:06:43.240 --> 00:06:50.830
Now, if I want to use myBlock which I've
declared, I call it like a function.

00:06:50.830 --> 00:06:55.330
So in this case you see myBlock with
the parenthesized list of arguments.

00:06:55.330 --> 00:07:00.340
In this case, I'm going to pass
in 3 for the integer argument.

00:07:00.340 --> 00:07:07.860
Now, if I change multiplier after declaring
the block, nothing's going to happen.

00:07:07.860 --> 00:07:10.970
That has no effect on the block.

00:07:10.970 --> 00:07:19.600
That's the reason I talk about this as being
capture, capturing the values that are in scope.

00:07:19.600 --> 00:07:24.140
So at the point where the block has been
declared up there on the line above,

00:07:24.140 --> 00:07:28.490
the value in multiplier was 7 and that value is captured.

00:07:28.490 --> 00:07:33.550
Now in this particular case, I just have a constant
value there but it doesn't have to be constant.

00:07:33.550 --> 00:07:41.260
I could have gotten multiplier by, initialized by,
you know, calling a function or something like that.

00:07:41.260 --> 00:07:45.940
But at the point where the block has
been declared, the value is captured.

00:07:45.940 --> 00:07:51.130
So I can change multiplier after that
and it will not affect the block.

00:07:51.130 --> 00:07:55.300
In this particular example, I'll always get 21.

00:07:55.300 --> 00:08:04.670
That is 3 X the multiplier 7 as a result of my printf
statement, even though I've changed multiplier afterwards.

00:08:06.350 --> 00:08:12.730
Blocks can be used, of course, then as arguments to
Objective-C methods and now we're going to begin seeing

00:08:12.730 --> 00:08:16.310
where we've added new APIs within Foundation.

00:08:16.310 --> 00:08:22.440
In this case, I have a new method,
enumerateObjectsUsingBlock.

00:08:22.440 --> 00:08:31.010
This method will call the block, invoke the
block once for every object in the collection.

00:08:31.010 --> 00:08:37.410
So here we see the first bug in the
slides if you're paying close attention.

00:08:37.410 --> 00:08:45.800
The method is called enumerateObjectsUsingBlock and
then there's a block argument following it with a type.

00:08:45.800 --> 00:08:53.450
Well, that blue box in the second line which is
enclosing NSUInteger index should be extended really

00:08:53.450 --> 00:08:56.580
over all of the parenthesized material.

00:08:56.580 --> 00:09:01.710
That is the whole type of the block,
that big long mess in parentheses there

00:09:01.710 --> 00:09:06.720
and then on the far right we just
have the name of the argument block.

00:09:08.220 --> 00:09:13.820
Well, within the block type, we have the return value, void.

00:09:13.820 --> 00:09:21.160
We have the carat then and then we have the
parenthesized argument list, just as if you would pass

00:09:21.160 --> 00:09:28.170
in a function pointer to the method as an
argument, the first argument being an object,

00:09:28.170 --> 00:09:35.900
the second argument being an NSUInteger and
the third argument being a pointer to a BOOL.

00:09:35.900 --> 00:09:40.330
So let me give an example of how
I would use this new method.

00:09:40.330 --> 00:09:43.440
As I say, this method will be invoked once, oh, I'm sorry,

00:09:43.440 --> 00:09:47.890
the block will be invoked once for
every object in the collection.

00:09:47.890 --> 00:09:49.990
In this case we have an array.

00:09:49.990 --> 00:10:00.000
So first, I begin, I have a nameToSearchFor,
some sort of NSString and for every object

00:10:00.000 --> 00:10:04.020
in the collection, I want to ask the object for its name.

00:10:04.020 --> 00:10:09.310
I'm going to assume that the, or I know that
the objects will respond to name and I'm going

00:10:09.310 --> 00:10:12.500
to compare that with the name I'm searching for.

00:10:12.500 --> 00:10:18.070
So I may be searching for the name
Bob, for example and I'm going to look

00:10:18.070 --> 00:10:22.590
at all the objects and find the objects whose name is Bob.

00:10:22.590 --> 00:10:27.550
In this case I'm going to do something
trivial, I'm just going to NSLog out the index

00:10:27.550 --> 00:10:31.800
so that's the second argument that
I'm getting in this block.

00:10:31.800 --> 00:10:36.130
I'm just going to NSLog the index
of that object within the array.

00:10:36.130 --> 00:10:37.870
Well, that's very boring.

00:10:37.870 --> 00:10:46.310
Instead, what I really want to do is I want to search for an
object whose name's Bob, say, and then I want to remember it

00:10:46.310 --> 00:10:49.020
and do something with it after the method returns.

00:10:49.020 --> 00:10:57.210
So what I've done is I've added a new local variable
called found, and in this case I've initialized it to nil.

00:10:57.210 --> 00:11:09.080
And within myBlock now, I'm going to set found to be
the object that I find and I'm going to set stop to yes,

00:11:09.080 --> 00:11:11.190
and I'll explain what that means in a minute.

00:11:11.190 --> 00:11:20.540
But if I do that, I'm going to get a compile error because
as I said before, the local variables which are outside

00:11:20.540 --> 00:11:28.090
of the block which are being captured by the block are sort
of, in the sense having their values copied into the block.

00:11:28.090 --> 00:11:33.640
So I can't write to that because essentially what
the compiler's done is it's captured the value

00:11:33.640 --> 00:11:36.210
of nil and put that in the block.

00:11:36.210 --> 00:11:42.960
So this is like writing nil equals object
and that's going to give me a compile error.

00:11:42.960 --> 00:11:49.610
To tell the compiler that I want to,
really do want to write out as it were

00:11:49.610 --> 00:11:58.050
to the enclosing scope, I need
to add a new keyword, __block.

00:11:58.050 --> 00:12:09.000
This is a new type qualifier that tells the compiler that
found should be compiled in such a way that I can read it

00:12:09.000 --> 00:12:13.330
in the block but also write out to it as well.

00:12:13.330 --> 00:12:21.710
Now that stop parameter that I'm using at the
bottom of the block, let me explain that briefly.

00:12:21.710 --> 00:12:24.220
What that allows me to do is stop the enumeration.

00:12:24.220 --> 00:12:31.880
So I'm writing through that pointer that myBlock has been
given and I'm writing yes in order to stop the enumeration.

00:12:31.880 --> 00:12:39.090
If I have say a million element array and I,
you know, find after element 3 that I don't need

00:12:39.090 --> 00:12:44.740
to continue the enumeration, well, it's very nice
to be able to stop it rather than having to proceed

00:12:44.740 --> 00:12:46.900
through all million elements of the array.

00:12:46.900 --> 00:12:51.650
So that's all that BOOL and stop parameter is for.

00:12:51.650 --> 00:12:57.670
After this method returns, if found is no
longer nil, I know that the block set it

00:12:57.670 --> 00:13:03.090
to something and I can go operate on it then.

00:13:03.090 --> 00:13:07.030
Well, there are many new collection
APIs that are using blocks.

00:13:07.030 --> 00:13:14.130
These are various methods on the collection
classes, arrays, dictionaries, sets and index sets.

00:13:14.130 --> 00:13:21.800
We've seen one example so far, which is one
example of the enumeration class of new methods.

00:13:21.800 --> 00:13:30.950
Enumerations are, enumeration methods are there to
invoke a block once for each object in a collection.

00:13:30.950 --> 00:13:42.650
Before I go on, let me do an aside here which will help,
you know, make you understand or allow you to understand,

00:13:42.650 --> 00:13:48.320
you know, some of our naming conventions
with these new block methods.

00:13:48.320 --> 00:13:55.590
Well, in the case of an array, you have objects in the
array so the method is called enumerateObjectsUsingBlock

00:13:55.590 --> 00:13:59.720
and in the case of Dictionary,
dictionaries have keys and objects

00:13:59.720 --> 00:14:05.790
and so the methods are obviously called
Keys, enumerateKeysAndObjectsUsingBlock.

00:14:05.790 --> 00:14:09.740
The type signature of the block argument which is taken

00:14:09.740 --> 00:14:14.410
by these methods is also different
based on the particular collection.

00:14:14.410 --> 00:14:20.560
Arrays are ordered collections and so they
have objects but they also have indexes.

00:14:20.560 --> 00:14:28.900
The index of each object is interesting and so we pass both
pieces of information into the block so you don't have to,

00:14:28.900 --> 00:14:32.670
you know, somehow compute the index yourself if you need it.

00:14:32.670 --> 00:14:38.280
In the case of dictionary, well, dictionaries have keys
and objects so we pass in both of those into the block

00:14:38.280 --> 00:14:46.300
so you get them both at once and don't have
to go, say looking up the object as you do say

00:14:46.300 --> 00:14:52.140
if you're using the foreign syntax
to enumerate over a dictionary.

00:14:53.620 --> 00:14:59.310
Well, in NSArray for example, and this
is true in the other collections as well,

00:14:59.310 --> 00:15:04.490
and NSArray is just being an example
here, we also have extended methods.

00:15:04.490 --> 00:15:09.300
So for example, there's a method that takes some options.

00:15:09.300 --> 00:15:17.480
There are different ways you can enumerate an
array so we provide a method that takes options.

00:15:17.480 --> 00:15:27.140
For an array or an index set which are ordered collections,
you can also choose to enumerate only over a subset

00:15:27.140 --> 00:15:33.990
of that collection and you do that by specifying an
NS index set for those collections which are ordered.

00:15:33.990 --> 00:15:40.400
Well, what are those enumeration options I mentioned?

00:15:40.400 --> 00:15:46.870
Well, for an array or an NS index set, of course sometimes
it's interesting to be able to enumerate the collection

00:15:46.870 --> 00:15:50.400
in reverse so there's an option for that.

00:15:50.400 --> 00:15:55.130
But the more interesting option is NSEnumerationConcurrent.

00:15:55.130 --> 00:16:03.200
This allows you to enumerate a collection but
concurrently, that is your block may be invoked

00:16:03.200 --> 00:16:12.250
on multiple threads simultaneously as the enumeration
algorithm enumerates, that is calls the block once

00:16:12.250 --> 00:16:18.780
for every object in the collection but it may
call it once on multiple threads simultaneously.

00:16:18.780 --> 00:16:24.300
And this can result in a nice little
performance boost because you can, you know,

00:16:24.300 --> 00:16:29.750
do things simultaneously for every object in the block.

00:16:29.750 --> 00:16:33.870
Now your block when you use this
option needs to be thread-safe.

00:16:33.870 --> 00:16:45.500
You need to take care of the thread safety of what the block
is doing and what the block is accessing inside the block.

00:16:45.500 --> 00:16:53.320
Well, in addition to enumeration, we have other
classes of new methods which are used in blocks.

00:16:53.320 --> 00:16:54.970
One class is searching.

00:16:54.970 --> 00:17:00.520
I've already illustrated searching
but using the enumeration API.

00:17:00.520 --> 00:17:09.240
Previously, we were searching for a name whose
object or whose name matched a certain value.

00:17:09.240 --> 00:17:13.520
Well, we packaged that kind of
thing up into other sets of methods,

00:17:13.520 --> 00:17:19.570
one example is this NSArray method,
indexesOfObjectsPassingTest.

00:17:19.570 --> 00:17:29.460
The interesting thing about this method is
that instead of void, the block returns a BOOL.

00:17:29.460 --> 00:17:35.260
So the block is going to be given the same arguments,
that is it's going to be given the object in the index

00:17:35.260 --> 00:17:42.400
and the Boolean point or stop value but what the
block is supposed to do in this case is it's supposed

00:17:42.400 --> 00:17:51.260
to test each object and return yes if the object matches
some sort of test that you want to apply to every object

00:17:51.260 --> 00:17:54.050
or return no if the object doesn't match.

00:17:54.050 --> 00:18:00.140
The NSArray algorithm in this case behind
this method is going to collect all

00:18:00.140 --> 00:18:04.620
of those objects' indexes for which the block returns yes.

00:18:04.620 --> 00:18:11.630
It's going to collect them all and when the enumeration
is done, it's going to return an NS index set

00:18:11.630 --> 00:18:19.930
and so then you have the indexes of all the
objects which match your particular predicate.

00:18:19.930 --> 00:18:24.910
The enumeration objects' options
apply to these methods as well.

00:18:24.910 --> 00:18:29.310
So for example you can do this
searching concurrently if you want.

00:18:29.310 --> 00:18:39.130
Blocks can also be used in typedefs so you can create
a new type which is a block type using typedef.

00:18:39.130 --> 00:18:44.920
In this case, we have a new API which I'm
going to illustrate called NSComparator.

00:18:44.920 --> 00:18:52.380
This is a new type in our API which takes
two parameters, two objects and it's supposed

00:18:52.380 --> 00:18:55.700
to compare them and return an NSComparisonResult.

00:18:55.700 --> 00:19:01.080
An NSComparisonResult, that's an
existing type that is an enumeration

00:19:01.080 --> 00:19:04.870
which is either less than, equal to or greater than.

00:19:04.870 --> 00:19:09.490
So basically a comparator block is
given two objects and it's supposed

00:19:09.490 --> 00:19:14.750
to return whether the objects are less
than, equal to or greater than one another.

00:19:15.800 --> 00:19:17.630
Well, where do we use this?

00:19:17.630 --> 00:19:20.970
Clearly, an interesting place is in sorting.

00:19:20.970 --> 00:19:26.820
So an NSArray has several sorting methods
and we've added some more using blocks

00:19:26.820 --> 00:19:30.380
as the comparison function essentially.

00:19:30.380 --> 00:19:35.720
One example here is the sortedArrayUsingComparator method.

00:19:35.720 --> 00:19:42.300
This returns a new array which is the
sorted version of the receiving array.

00:19:42.300 --> 00:19:48.350
I have an example here at the bottom of the
slide showing how I'm going to call that.

00:19:48.350 --> 00:19:53.990
Suppose I have an array called myArray FullOfStrings.

00:19:53.990 --> 00:19:58.660
Well, I'm going to call sortedArrayUsingComparator
and pass in a comparator block.

00:19:58.660 --> 00:20:09.320
So the block begins with the proper declaration for an
NSComparator, that is the two parameters have to be id

00:20:09.320 --> 00:20:17.700
of the block and within the block, in this case, all I'm
going to do is I'm going to pass the two strings essentially

00:20:17.700 --> 00:20:23.490
to the localizedStandardCompare method
and return whatever its result is.

00:20:23.490 --> 00:20:33.200
So in this case, my block is fairly simple but you
can see here the power of the new block syntax.

00:20:33.200 --> 00:20:39.510
Instead of having a comparator function or comparator
selector which is implemented off somewhere else

00:20:39.510 --> 00:20:53.110
within the API, you can put the comparison logic right there
with the sorted array, you know, method that you're calling.

00:20:53.110 --> 00:20:59.670
So the logic doesn't have to be separated, the logic that's
being used for the comparison doesn't have to be separated

00:20:59.670 --> 00:21:05.720
from the actual creation of the sorted array itself.

00:21:07.050 --> 00:21:11.260
Well, just as with enumeration,
there are some sorting options.

00:21:11.260 --> 00:21:16.300
The first option, you can sort
concurrently if you want and this again,

00:21:16.300 --> 00:21:20.390
just like with enumeration can
provide you with a speed boost.

00:21:20.390 --> 00:21:28.670
If you pass in this option, again, your
comparison block needs to be thread-safe

00:21:28.670 --> 00:21:32.980
and what this does then internally is it
invokes a completely different algorithm

00:21:32.980 --> 00:21:36.290
for sorting which sorts concurrently.

00:21:36.290 --> 00:21:43.610
It uses, you know, up to all the cores
on your machine in order to do the sort.

00:21:43.610 --> 00:21:48.760
There is also a new option we've
added which has long been requested,

00:21:48.760 --> 00:21:52.570
one for stable sorts, if you want to do a stable sort.

00:21:52.570 --> 00:21:56.360
We've also provided a new option for that.

00:21:57.490 --> 00:22:03.490
Another new API we've added, in this
case to NSArray is binary search.

00:22:03.490 --> 00:22:12.500
Here we have indexOfObject inSortedRange options
usingComparator and you pass in again a comparator block

00:22:12.500 --> 00:22:17.660
to do the comparison in order to
implement the actual binary search.

00:22:17.660 --> 00:22:27.760
So this is an example of a new API for
which there isn't a non-block alternative.

00:22:30.240 --> 00:22:32.390
Strings can also be enumerated.

00:22:32.390 --> 00:22:38.690
We've added a new API to enumerate
pieces or chunks out of a string.

00:22:38.690 --> 00:22:47.440
The new enumerateSubstringsInRange options usingBlock method
takes a block which gets several arguments passed to it

00:22:47.440 --> 00:22:52.880
as you can see there and you can choose
to enumerate the lines in a string

00:22:52.880 --> 00:22:57.740
or the paragraphs but also the words or the sentences.

00:22:57.740 --> 00:23:04.060
Now clearly for words and sentences, some form
of linguistic analysis is going on because

00:23:04.060 --> 00:23:10.650
of course the string might have different kinds of
languages embedded within it, texts of different languages.

00:23:10.650 --> 00:23:14.450
And so some linguistic analysis is
going on and that's another new piece

00:23:14.450 --> 00:23:20.120
of functionality that's been added to iPhone iOS 4.

00:23:20.120 --> 00:23:21.660
So that's blocks.

00:23:21.660 --> 00:23:28.340
Now I'm going to go on to some of the other new
functionality we've found, we've added, sorry,

00:23:28.340 --> 00:23:34.360
in iOS 4, beginning with regular expressions.

00:23:34.360 --> 00:23:44.230
Regular expression has long been a requested
feature and now we are getting around to adding it.

00:23:44.230 --> 00:23:49.100
The new NS regular expression class
represents a regular expression.

00:23:49.100 --> 00:23:57.640
Basically, you can think of it as compiling the regular
expression if you've used other regular expression APIs.

00:23:57.640 --> 00:24:06.400
So we have in this example, a new regular
expression being created with the pattern of ..d,

00:24:06.400 --> 00:24:13.420
that is any character followed by any character
followed by d and that will be our regular expression.

00:24:13.420 --> 00:24:21.170
So that regular expression will match any two
characters followed by the literal letter d.

00:24:21.170 --> 00:24:23.600
Well, what do you do with regular expressions?

00:24:23.600 --> 00:24:31.550
Well, the most important thing is you find matches to the
regular expression within a string and so in this example,

00:24:31.550 --> 00:24:39.420
I have a string called, with the contents good
food today and I'm going to look for matches

00:24:39.420 --> 00:24:43.310
for my regular expression pattern in this string.

00:24:43.310 --> 00:24:51.350
So I ask the regular expression for, to return me
the matches in string options and give it the range,

00:24:51.350 --> 00:24:54.590
in this case the entire range of the string.

00:24:54.590 --> 00:24:56.200
And what does that return me?

00:24:56.200 --> 00:25:04.680
Well, that will return me an array with three matches
in it and here I've shown the regular expression

00:25:04.680 --> 00:25:09.990
above the resulting matches within the string.

00:25:09.990 --> 00:25:12.450
Well, how are these, what's in this array?

00:25:12.450 --> 00:25:15.920
How are these matches represented?

00:25:15.920 --> 00:25:22.510
Well, we do that by using a new, another
new class which is NSTextCheckingResult.

00:25:22.510 --> 00:25:28.910
So the array will contain three NSTextCheckingResult
objects and these objects represent the,

00:25:28.910 --> 00:25:34.080
describe I should say, the overall
range and the ranges of capture groups.

00:25:34.080 --> 00:25:42.330
Capture groups are an advanced functionality of
regular expressions that I can't go into today.

00:25:42.330 --> 00:25:48.770
Well, instead of getting an array back with a
list of all the matches, you can with a block

00:25:48.770 --> 00:25:56.830
and this new block-based API, enumerate through all
the matches of a regular expression in a string.

00:25:56.830 --> 00:26:04.060
And so that's what this new API is for and it also
gets passed in NSTextCheckingResult to represent,

00:26:04.060 --> 00:26:12.270
to describe the range of each match and some
additional bits of information in the flags.

00:26:12.270 --> 00:26:20.460
The second most common thing that you do with a regular
expression is you replace the matches that have been found.

00:26:20.460 --> 00:26:25.300
Well, one of the new methods, not all of them
but one of the new methods that allow you to do

00:26:25.300 --> 00:26:30.460
that is this new string by replacingMatchesInString method.

00:26:30.460 --> 00:26:38.750
This takes a string that you give it, that's the first
argument there and will return you the new resulting string

00:26:38.750 --> 00:26:45.660
after all the regular expression matches
have been replaced with the template.

00:26:45.660 --> 00:26:49.880
Now it's called a template because it's not
simply a literal string that you can replace in,

00:26:49.880 --> 00:26:57.900
that you can replace all the matches with but if
you are using capture groups and that functionality

00:26:57.900 --> 00:27:05.000
within your regular expression, the
template can also be used to, you know,

00:27:05.000 --> 00:27:09.130
say where you want each capture group to be substituted.

00:27:09.130 --> 00:27:11.560
But in this case I'm not using capture groups.

00:27:11.560 --> 00:27:18.180
I'm just using a very simple regular expression and
I'm going to replace with a very simple string #.

00:27:18.180 --> 00:27:26.400
Now I don't know why you'd want to take the regular
expression like any character, any character,

00:27:26.400 --> 00:27:41.440
d and replace it with #, but if you do that,
you get something like this and a g# f# #ay.

00:27:41.440 --> 00:27:46.290
Well, and a string also has some new
convenience methods on it that allow you

00:27:46.290 --> 00:27:54.390
to access the regular expression functionality that's
primarily embodied by the NS regular expression class.

00:27:54.390 --> 00:28:03.810
The rangeOfString method now takes a new option called
NSRegularExpressionSearch and that says to the method

00:28:03.810 --> 00:28:09.870
if you pass that argument in or that option in, that
says to the method, hey, the pattern I'm looking

00:28:09.870 --> 00:28:13.600
for is actually a regular expression not a literal string.

00:28:13.600 --> 00:28:20.730
And that was actually added in,
if you were paying close attention

00:28:20.730 --> 00:28:27.970
to the iPhone 3.2 SDK, that was actually added in 3.2.

00:28:27.970 --> 00:28:31.790
That also applies though to 4.0, of course as well.

00:28:31.790 --> 00:28:41.870
The new option also applies to all the find and
replace methods in iOS 4 although it didn't in 3.2.

00:28:41.870 --> 00:28:48.230
Now that's all I can go into as far as regular
expression although that's a very interesting topic.

00:28:48.230 --> 00:28:56.380
So if you want to know more, I'm going to have to pass you
off to Doug Davidson who's giving an Advanced Text Handling

00:28:56.380 --> 00:29:06.880
for iOS, I guess that should say, talk later
today, this afternoon at 4:30 in the Nob Hill Hall.

00:29:06.880 --> 00:29:15.050
So what are some of the other changes
that we've done in Foundation?

00:29:15.050 --> 00:29:18.610
So I'm going to do some surveying of
some of the more interesting changes.

00:29:18.610 --> 00:29:26.010
The first is delegate, I want to
talk about delegate protocols.

00:29:26.010 --> 00:29:30.080
Historically, we used to describe delegate protocols,

00:29:30.080 --> 00:29:38.020
that is the methods that a delegate object
could be sent by using a category on NSObject.

00:29:38.020 --> 00:29:44.640
So you would see this kind of thing in the header, where
there was @interface NSObject followed by the category name

00:29:44.640 --> 00:29:50.540
and then a list of methods and that was supposed
to document the methods that a delegate,

00:29:50.540 --> 00:29:55.690
in this case an XML parser delegate, could receive.

00:29:55.690 --> 00:30:02.260
Well, we've switched that to using
formal protocols in iOS 4.

00:30:02.260 --> 00:30:06.130
And so now what you see in the
header is a @protocol declaration,

00:30:06.130 --> 00:30:12.210
in this case for a protocol called NSXMLParserDelegate.

00:30:12.210 --> 00:30:18.470
And again, with the list of methods that
the, you know, delegate can receive,

00:30:18.470 --> 00:30:21.300
most of those methods being optional methods.

00:30:21.300 --> 00:30:25.690
Occasionally there might be a required
delegate method that you have to implement

00:30:25.690 --> 00:30:29.130
but usually delegate methods are optional.

00:30:29.130 --> 00:30:39.740
We've also updated the types that the delegate method
returns and the set delegate method takes as far as the,

00:30:39.740 --> 00:30:42.150
you know, what the type of the delegate is.

00:30:42.150 --> 00:30:48.600
So this is telling the compiler, hey, check to make
sure that the delegate, that this person setting

00:30:48.600 --> 00:30:52.600
on this object actually conforms to the new protocol.

00:30:52.600 --> 00:31:04.100
Well, what you may have to do in iOS 4 then is update
your delegate objects to conform to the new NS, well,

00:31:04.100 --> 00:31:07.810
in this case, NSXMLParserDelegate protocol.

00:31:07.810 --> 00:31:15.210
Of course, every delegate has its own protocol but you might
get compiler warnings that you can only shut up by making,

00:31:15.210 --> 00:31:20.570
declaring that is the delegate
as conforming to the protocol.

00:31:20.570 --> 00:31:28.650
In NSPropertyListSerialization, we've
introduced some new methods that return NSErrors.

00:31:28.650 --> 00:31:36.750
The older methods in NSPropertyListSerialization which
allow you to parse and create flattened property lists,

00:31:36.750 --> 00:31:41.440
the older methods used to return
NSStrings by reference as errors.

00:31:41.440 --> 00:31:47.050
So the new methods return NSErrors
by reference, if there's an error

00:31:47.050 --> 00:31:54.170
and this allows much more rich error
information to be returned to you.

00:31:54.170 --> 00:32:00.920
We've also introduced new stream-based methods
so you can pass in say an NSInputStream

00:32:00.920 --> 00:32:08.730
and have the NSPropertyListSerialization
class parse a property list off of the stream.

00:32:08.730 --> 00:32:15.740
In this particular example, I'm going to use the
propertyListWithStream method, I'm passing there

00:32:15.740 --> 00:32:24.760
and NSInputStream which I've created and opened and
so it's got the contents, presumably has the contents

00:32:24.760 --> 00:32:28.050
which should be parsed, you know, ready to go.

00:32:28.050 --> 00:32:35.240
And I'm going to, you know, let me pass in other arguments
including the pointer to the error that should be filled

00:32:35.240 --> 00:32:42.680
in non-error and if I get back non
nil from this, everything worked.

00:32:42.680 --> 00:32:49.040
But if plist is still nil after this method
returns, then there was an error and I should go off

00:32:49.040 --> 00:32:57.950
and look at the error argument or the
NSError variable that I passed in.

00:32:57.950 --> 00:33:00.680
NSData has a new method.

00:33:00.680 --> 00:33:09.660
Just like you can search for a string within another
NSString, now you can search for bytes within NSData

00:33:09.660 --> 00:33:14.670
and you can search for one data within another data.

00:33:14.670 --> 00:33:23.070
Just like with string, where you can search for a string,
you can pass in a few different arguments, or I'm sorry,

00:33:23.070 --> 00:33:26.880
a few different options as one of the arguments.

00:33:26.880 --> 00:33:35.580
In the case of data, we support the Backwards and Anchored
options, Backwards of course allowing you to search

00:33:35.580 --> 00:33:43.960
from the end of the data to find matches and Anchored
allows you to, say, hey, only tell me that there's a match

00:33:43.960 --> 00:33:52.540
if the match occurs at the beginning or in
the case of backwards, at the end of the data.

00:33:52.540 --> 00:33:54.910
NSString has a new compare method.

00:33:54.910 --> 00:34:01.810
I actually used this in an earlier example
in the talk, localizedStandardCompare.

00:34:01.810 --> 00:34:05.630
We've added this method in order
to encapsulate what we consider

00:34:05.630 --> 00:34:11.740
to be the standard comparison of the system, if you will.

00:34:11.740 --> 00:34:21.080
So if you want to sort something in the UI, usually it would
be sorting for the, you know, UI presentation to the user,

00:34:21.080 --> 00:34:25.810
you could use this new method to compare your strings.

00:34:25.810 --> 00:34:31.620
Now the exact behavior of this method
is not strictly defined because we,

00:34:31.620 --> 00:34:40.660
of course may want to change what we consider to be the
standard system sorting behavior from release to release.

00:34:40.660 --> 00:34:46.600
So you can't use this if you really need
to depend on a specific sorting order.

00:34:46.600 --> 00:34:55.810
What you're using this method for is if you want to
match what, you know, say Apple's apps are showing

00:34:55.810 --> 00:34:59.870
when they present sorted lists to the user.

00:34:59.870 --> 00:35:03.840
NSAttributedString is a new class that we've added.

00:35:03.840 --> 00:35:11.000
We actually added this in iPhone OS 3.2
but it's still there of course in iOS 4

00:35:11.000 --> 00:35:21.350
and NSAttributedString represents a string plus ranges
of attributes that apply to various chunks of the string.

00:35:21.350 --> 00:35:26.360
The easiest way to think about this
is in terms of say mark-up text.

00:35:26.360 --> 00:35:33.490
In this particular example that I'm going to show you,
I'm going to use various text and font attributes.

00:35:33.490 --> 00:35:41.910
So I have a string here, which is this text is green
and bold and the last half of the string has some sort

00:35:41.910 --> 00:35:45.910
of green text color attribute added to it.

00:35:45.910 --> 00:35:47.190
I don't know what that attribute is.

00:35:47.190 --> 00:35:50.520
I'm not going to define any such attribute.

00:35:50.520 --> 00:35:56.420
You just have some sort of attribute
which has changed its display to be green.

00:35:56.420 --> 00:36:05.260
The last word, the word bold has had, has some sort of
bold font attribute added to it or applied to that chunk

00:36:05.260 --> 00:36:11.820
of the string and so the word is also
appearing in bold as well as green.

00:36:11.820 --> 00:36:19.210
So you can see the ranges of mark-up can overlap as
well and so that's what NSAttributedString is for.

00:36:19.210 --> 00:36:24.010
Another class that we've added is NSFileWrapper.

00:36:24.010 --> 00:36:29.500
NSFileWrapper exists in the AppKit
over in Mac OS X where we've brought it

00:36:29.500 --> 00:36:33.790
into the phone and, but added it to Foundation.

00:36:33.790 --> 00:36:42.080
File wrappers are generally used to represent
a collection of files as a single file

00:36:42.080 --> 00:36:45.770
or as a way to group multiple files together.

00:36:45.770 --> 00:36:54.320
For example, you have a directory which contains multiple
files, the main primary document file along with a set

00:36:54.320 --> 00:37:00.740
of subordinate files which are like
associated somehow with that main document

00:37:00.740 --> 00:37:05.010
so that for example, as I say here, images.

00:37:05.010 --> 00:37:10.480
So if you have a document with some associated
images that, you know, go with the document,

00:37:10.480 --> 00:37:18.150
you can group them all together into an NSFileWrapper
directory and use NSFileWrapper to access those.

00:37:18.150 --> 00:37:23.370
One of the key advantages of using an
NSFileWrapper and any file wrapper API is

00:37:23.370 --> 00:37:28.750
that it offers fast incremental saving of a document.

00:37:28.750 --> 00:37:36.740
So if you've only changed say one file within a document,
NSFileWrapper document, and you need to resave it,

00:37:36.740 --> 00:37:44.050
the saving is much quicker than rewriting all of the files.

00:37:44.050 --> 00:37:49.160
NSOperation has had a few new methods added to it.

00:37:49.160 --> 00:37:54.650
For an NSOperation, now you can wait until
it is finished, if you really need to.

00:37:54.650 --> 00:38:03.570
What this does is simply blocks the current thread,
waiting for the NSOperation to go into its finished state.

00:38:03.570 --> 00:38:13.060
Now as with all blocking, we caution you against using
this without some careful thought because any sort

00:38:13.060 --> 00:38:22.910
of blocking can ultimately involve, you know, chains of
things blocking against one another and thus deadlocks.

00:38:22.910 --> 00:38:32.780
If you want, another thing we've added to NSOperation
is if you want to have some block of code run

00:38:32.780 --> 00:38:39.460
when the operation finishes, we've added a convenience for
that, a new property where you can set a completion block

00:38:39.460 --> 00:38:45.340
and after the operation goes into its
finished state, this block will be executed.

00:38:45.340 --> 00:38:52.420
So that can be a convenient way to say do some final
work for the operation or to start new operations

00:38:52.420 --> 00:38:56.220
as a result of this operation having been finished.

00:38:56.220 --> 00:39:03.840
We've also added a new subclass of
NSOperation called NSBlockOperation.

00:39:03.840 --> 00:39:11.670
Just like NSInvocationOperation class takes an
NSInvocation to execute as the work of the block

00:39:11.670 --> 00:39:18.330
and NSBlockOperation takes one or more blocks to execute.

00:39:18.330 --> 00:39:24.420
And those blocks become the work of the
operation, when those blocks are all done

00:39:24.420 --> 00:39:30.790
after the operation has been started, when they're all
done then the operation goes into its finished state.

00:39:30.790 --> 00:39:35.640
So this is a convenience method to
create a block operation with a block

00:39:35.640 --> 00:39:40.420
but you can also add many blocks
to an operation, a block operation.

00:39:40.420 --> 00:39:48.260
If you add many blocks, all those blocks are going
to be executed concurrently and so this is a way

00:39:48.260 --> 00:39:54.220
to have an operation do a kind of little
fan-out of work across multiple cores

00:39:54.220 --> 00:39:57.370
by executing multiple blocks simultaneously.

00:39:57.370 --> 00:40:05.900
When all of those blocks have finished, then the
operation as I say will go into its finished state.

00:40:07.400 --> 00:40:16.830
NSOperationQueue in iOS 4 has been re-implemented
in terms of grand central dispatch or GCD.

00:40:16.830 --> 00:40:24.810
Now I, unfortunately, I don't have time to go into
GCD today but there will be another talk tomorrow

00:40:24.810 --> 00:40:30.150
on grand central dispatch if you're curious about that.

00:40:30.150 --> 00:40:39.750
Two new methods that we've added to NSOperationQueue
are operationCounts and addOperations:waitUntilFinished.

00:40:39.750 --> 00:40:48.460
What we've found for the first one that a lot of people were
asking an operation queue for its list of all its operations

00:40:48.460 --> 00:40:54.870
and then just asking that array for its count, to
get the count of operations in an operation queue.

00:40:54.870 --> 00:40:59.930
And then they were throwing, of course the array away
so rather than do all that work to create the array

00:40:59.930 --> 00:41:07.680
of operations, we provide direct access to
that piece of information now via a new method.

00:41:07.680 --> 00:41:16.380
The second method there allows you to add, do a sort
of bulk add of many operations at once and if you wish,

00:41:16.380 --> 00:41:25.230
you can pass in yes to the waitUntilFinished argument
and this method will wait until all those specific,

00:41:25.230 --> 00:41:29.870
those specific operations that you added have finished.

00:41:33.200 --> 00:41:39.470
Because, you know, we've added a lot of block API, of
course, we felt that we should offer a convenience method

00:41:39.470 --> 00:41:45.010
to add a block to an operation queue so you
don't have to create an NSOperation object

00:41:45.010 --> 00:41:49.150
and so we offer a new convenience
method, addOperationWithBlock.

00:41:49.150 --> 00:41:54.740
And it takes a block, if the block doesn't take
any parameters, it doesn't have any return value.

00:41:54.740 --> 00:42:00.620
It's just a chunk of code to be run and eventually that
will, you know, percolate through the operation queue

00:42:00.620 --> 00:42:07.090
and be executed by the operation
queue on some thread rather.

00:42:07.090 --> 00:42:12.540
We also added two new special queues to the system.

00:42:12.540 --> 00:42:16.260
The first is we've added a method
to return the current queue.

00:42:16.260 --> 00:42:25.410
Well, the current queue isn't any particular special
queue but when code is running within the context

00:42:25.410 --> 00:42:34.520
of an NSOperation, that is an NSOperation is calling
some code, well, that NSOperation has a queue.

00:42:34.520 --> 00:42:39.690
And so, this method, currentQueue will return non nil.

00:42:39.690 --> 00:42:48.170
It will return that queue that the code is running in when
that code is running in the context of an operation queue.

00:42:48.170 --> 00:42:52.960
Of course, you might have a method which
can be called outside of an NSOperation

00:42:52.960 --> 00:42:59.330
and then this method might return nil because
it's not running in the context of an operation.

00:42:59.330 --> 00:43:05.390
But this can be a useful way to get a hold
of the current queue if you, you know,

00:43:05.390 --> 00:43:10.250
need to do some more work with the current queue.

00:43:10.250 --> 00:43:14.770
The second new method is mainQueue.

00:43:14.770 --> 00:43:17.270
The mainQueue does represent a special queue.

00:43:17.270 --> 00:43:24.490
It's a special queue that only executes
its operations on the main thread.

00:43:24.490 --> 00:43:30.520
Of course, because there's only one thread involved,
that is the main thread, this is a serial queue.

00:43:30.520 --> 00:43:37.380
And so you can use the mainQueue method to get a hold of a
queue which will execute its operations on the main thread.

00:43:37.380 --> 00:43:45.480
So this is a way, a new way to execute
stuff on the main thread if you need to.

00:43:45.480 --> 00:43:54.970
Well, one place you sometimes need to execute code
on the main thread is in response to notifications

00:43:54.970 --> 00:44:03.970
and so what we have here is a new method
that allows you to pass in a block

00:44:03.970 --> 00:44:08.870
as the observer essentially of a notification.

00:44:09.980 --> 00:44:14.750
So in the last argument position there, we have the block.

00:44:14.750 --> 00:44:18.490
The block just gets the NSNotification object

00:44:19.520 --> 00:44:27.290
and essentially what you do is you're asking the
system add an observer to the notification center

00:44:27.290 --> 00:44:31.530
for me using this block and the system will do that.

00:44:31.530 --> 00:44:41.020
The system then returns that observer in effect in the
return value, that is the return value being id here.

00:44:41.020 --> 00:44:51.470
This is the observer essentially that the system
has wrapped the block with and is returning to you.

00:44:51.470 --> 00:44:59.270
So the return value in this case is retained by the
system so as long as you don't remove this observer

00:44:59.270 --> 00:45:10.300
from the notification center, the block will receive the
notifications, the notification name that you've asked for.

00:45:10.300 --> 00:45:19.520
To remove or stop the block from getting called, you need
to use the removeObserver method with that return value

00:45:19.520 --> 00:45:27.110
as the parameter to removeObserver in order
to unregister, that's cancel the registration.

00:45:27.110 --> 00:45:37.840
The third interesting thing about this new
method is that strange queue parameter.

00:45:37.840 --> 00:45:44.520
So you can pass in nil to this parameter
and nothing different will happen

00:45:44.520 --> 00:45:49.260
from the existing addObserver method
that you might already be familiar with.

00:45:49.260 --> 00:45:58.020
But if you do pass in non nil, that is you pass in a
valid NSOperationQueue, what will happen is that when it,

00:45:58.020 --> 00:46:05.100
when that notification is posted, your block
that you've passed in here will be executed

00:46:05.100 --> 00:46:09.380
on that queue, or in the context of that queue.

00:46:09.380 --> 00:46:16.670
Essentially what will happen is the
NSNotificationCenter implementation will say oh,

00:46:16.670 --> 00:46:18.820
you know, this block needs to be invoked.

00:46:18.820 --> 00:46:22.780
This notification is being posted and
here's a block that needs to be invoked.

00:46:22.780 --> 00:46:31.660
Well, the block will simply be thrown on the queue by the
NSNotificationCenter implementation and then the block,

00:46:31.660 --> 00:46:37.230
or the notification center will continue
looking for more observers to notify.

00:46:37.230 --> 00:46:47.630
So what happens is that queue arguments open up the
possibility for asynchronous handling of the notifications

00:46:47.630 --> 00:46:56.460
or also concurrent handling of notifications, that is if
there are many different observers registered with a block,

00:46:56.460 --> 00:47:03.710
they might all end up having their block run
simultaneously on different threads, you know,

00:47:03.710 --> 00:47:06.770
to do their handling of the notification.

00:47:08.170 --> 00:47:14.830
But posting, that is the, there is a
thread which is posting a notification

00:47:14.830 --> 00:47:18.230
and of course the observers have
to receive the notification.

00:47:18.230 --> 00:47:22.220
The posting thread is still blocks in the posting operation

00:47:22.220 --> 00:47:27.560
until all the observers have completed
their handling of the notification.

00:47:27.560 --> 00:47:35.870
So even though the block here is being en-queued off on
a queue and eventually will percolate through the queue

00:47:35.870 --> 00:47:42.220
and then ultimately get run by the queue,
hopefully that happens quickly but not necessarily.

00:47:42.220 --> 00:47:48.630
The posting operation still has to block waiting for
all of the observers to have handled the notification,

00:47:48.630 --> 00:47:58.760
to have seen it before the posting can
continue and return control to you.

00:47:58.760 --> 00:48:02.920
Other changes that have occurred in
Foundation, well, in NSDateFormatter,

00:48:02.920 --> 00:48:07.870
we've added two new bits of long-requested functionality.

00:48:07.870 --> 00:48:16.060
The first is that given a set of components
that you want a format string for,

00:48:16.060 --> 00:48:23.520
we now have a new API that will return you an
appropriate format string given those components.

00:48:23.520 --> 00:48:32.840
So currently, we offer these different styles, you know,
short, medium, long, and full styles for formatting dates.

00:48:32.840 --> 00:48:41.460
But sometimes you have a specific set of components
which you want to appear in your format strings,

00:48:41.460 --> 00:48:49.490
in your formatted dates, but you don't of course
want to depend on the short format always, you know,

00:48:49.490 --> 00:48:53.170
say providing those specific components that
you wanted, or the medium format.

00:48:53.170 --> 00:48:55.820
Those things can change over time.

00:48:55.820 --> 00:49:04.360
Instead, if you have say in this example, I want to
display the month and the day and the hour and the minute.

00:49:04.360 --> 00:49:11.160
So I specified the format specifiers
Mdjm and of course, you may say j,

00:49:11.160 --> 00:49:16.930
well that's not an hour specifier if
you're familiar with NSDateFormatter.

00:49:16.930 --> 00:49:25.040
J is a special character that says well, I want the hour in
there but I don't know whether I want 24-hour or 12-hour.

00:49:25.040 --> 00:49:28.120
Just give me whatever is appropriate for the locale.

00:49:28.120 --> 00:49:33.590
So j is a special character for this particular method.

00:49:33.590 --> 00:49:44.830
So having asked for, now my locale is U.S. English when I
run things on my computer so what I get is a date format

00:49:44.830 --> 00:49:52.720
which is the U.S. English form that is the one
that contains month and days, hours and minutes.

00:49:52.720 --> 00:49:54.050
You notice at the end that there's an a.

00:49:54.050 --> 00:50:04.750
The a is the AM/PM designator and it
gave me the 12-hour h-format specifier.

00:50:04.750 --> 00:50:10.270
So even though I didn't ask for the AM/PM designator,
the method is smart enough to add it in there

00:50:10.270 --> 00:50:16.370
because it knows it should go with
the 12-hour hour format specifier.

00:50:17.410 --> 00:50:24.040
Well, once you have one of these format strings, typically
you turn around and you set it in a date formatter in order

00:50:24.040 --> 00:50:31.200
to format your date so in this case, I've set it in
the date formatter and I'm going to call stringFromDate

00:50:31.200 --> 00:50:42.950
with the current time and if I'm on schedule for this
talk, the current time is around 11:02 AM on June 8.

00:50:42.950 --> 00:50:52.070
The other interesting bit of functionality we've added to
NSDateFormatter is yesterday, today and tomorrow formatting

00:50:52.070 --> 00:51:00.690
of the date so rather than say, you know,
always saying 6/8 is the date, which is today,

00:51:00.690 --> 00:51:05.720
the text today for, you know, U.S. English would appear.

00:51:05.720 --> 00:51:13.100
Of course, if your user is running in, say Japanese
locale or Thai locale or what have you, you know,

00:51:13.100 --> 00:51:16.070
of course the appropriate thing
for that locale would appear.

00:51:16.070 --> 00:51:22.530
So if you have say dates which
are appearing like this normally,

00:51:22.530 --> 00:51:30.600
instead if you turn on the doesRelativeDateFormatting
property, what you'd get would be something like this.

00:51:30.600 --> 00:51:37.090
And of course, don't assume that a locale
has three special dates that is today

00:51:37.090 --> 00:51:41.250
and then the day before and then the day after today.

00:51:41.250 --> 00:51:49.270
Some locales actually have special formatting for today
plus or minus two days or plus or minus three days

00:51:49.270 --> 00:51:56.150
so it's not always just today plus or minus
one day where special formatting might occur.

00:51:57.180 --> 00:52:06.940
Finally, we have a new class called NSCache in Foundation
and this is a class to help you with caching of objects.

00:52:06.940 --> 00:52:14.970
Now sometimes you have some expensive objects, objects that
were expensive to create and you want to keep them around

00:52:14.970 --> 00:52:25.070
but you don't want to induce so much memory pressure
that you're app is going to be jettisoned for example.

00:52:25.070 --> 00:52:36.210
So NSCache will discard automatically some of the older
or least recently used objects if there's memory pressure.

00:52:36.210 --> 00:52:45.620
So while an NSCache is like an NSDictionary in that you put
objects in it with said object for key and you get objects

00:52:45.620 --> 00:52:54.720
out by using the objectForKey method and the objects
are still retained just like in an NSDictionary,

00:52:54.720 --> 00:53:02.240
if there's memory pressure, the objects
may disappear from the cache automatically.

00:53:02.240 --> 00:53:10.380
The other interesting thing about NSCache is that NSCache
is naturally thread-safe and so you can access them

00:53:10.380 --> 00:53:14.830
on multiple threads safely, simultaneously.

00:53:15.990 --> 00:53:19.830
Well, that brings me to my conclusion.

00:53:19.830 --> 00:53:22.280
So I talked a bit about blocks.

00:53:22.280 --> 00:53:28.910
I've introduced blocks and then a bunch of
other of the new Foundation API changes.

00:53:28.910 --> 00:53:37.490
Now, I didn't, I wasn't able to go into a lot of the more
interesting things about blocks within this short time.

00:53:37.490 --> 00:53:43.040
For example, I didn't talk at all about
block life cycle, where blocks live in memory

00:53:43.040 --> 00:53:49.580
and how you hold on to them and how you destroy blocks.

00:53:49.580 --> 00:54:00.130
So you have to go to the documentation to get more
information on those things or there's also some links,

00:54:00.130 --> 00:54:04.740
if you want to find out more about some of
the other API changes that have occurred.

00:54:04.740 --> 00:54:12.330
There are some links for this particular session
in the session database, some bits of, you know,

00:54:12.330 --> 00:54:22.100
information like the complete API dif have been linked in
there, if you go to say the developer.apple.com website

00:54:22.100 --> 00:54:26.100
and look at the information for this particular session.

00:54:26.100 --> 00:54:31.870
So there are some related sessions which
are interesting and I want to point out.

00:54:31.870 --> 00:54:39.420
Now, at 9:00 AM this morning, there was a What's
New in Cocoa session over in Mission here.

00:54:39.420 --> 00:54:43.780
If you missed that, you may want
to catch the repeat of that.

00:54:43.780 --> 00:54:52.570
This particularly focuses on Cocoa Touch and
what's new in Cocoa Touch on iPhone OS, iOS 4.

00:54:52.570 --> 00:54:58.980
I've already mentioned the Advanced
Text Handling talk later today at 4:30.

00:54:58.980 --> 00:55:05.480
If you want to know more about
Objective-C or delve more into Objective-C,

00:55:05.480 --> 00:55:10.460
there's an Objective-C talk in
Pacific Heights tomorrow at 9:00 AM.

00:55:10.460 --> 00:55:16.680
If you want to know more about blocks or grand
central dispatch, there's an Introducing Blocks

00:55:16.680 --> 00:55:25.030
and Grand Central Dispatch on iPhone talk
tomorrow at 11:30 AM in Russian Hill.

00:55:25.030 --> 00:55:32.820
Now, because this of course is a new, is a major update
to Foundation, you might find yourself being burned

00:55:32.820 --> 00:55:41.390
by assumptions you made about how Foundation APIs behave
and so if you do find yourself having been burned,

00:55:41.390 --> 00:55:46.810
one talk you may want to go to,
to maybe find out some more things

00:55:46.810 --> 00:55:53.900
about how it can be a little bit more perhaps
robust is the Future Proofing Your Application talk

00:55:53.900 --> 00:55:58.500
on Thursday at 2:00 in Pacific Heights.

00:55:58.500 --> 00:56:07.530
Finally, there's a related talk which will talk about
some of the API decisions and some of the naming patterns

00:56:07.530 --> 00:56:17.000
that we've used in Foundation called API Design for Cocoa
and Cocoa Touch and that's in Marina on Thursday at 4:30 PM.

00:56:17.000 --> 00:56:22.270
And that talk may give you some insight into, you know,
why we have adopted some of the kind of conventions

00:56:22.270 --> 00:56:29.850
and what the conventions are that we've
adopted in creating these Foundation APIs.

