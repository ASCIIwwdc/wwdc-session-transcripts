WEBVTT

00:00:06.900 --> 00:00:08.170
>> Ali Ozer: Good afternoon, everyone.

00:00:08.170 --> 00:00:11.600
Welcome to API Design for Cocoa and Cocoa Touch.

00:00:11.600 --> 00:00:12.530
My name is Ali Ozer.

00:00:12.530 --> 00:00:17.120
I'm the Manager of the Cocoa Frameworks team at Apple.

00:00:17.120 --> 00:00:25.750
OK. So first, there's lot of you here, let's just make sure
we're on the same page with regards to what we mean by API.

00:00:25.750 --> 00:00:26.950
Now, I looked it up.

00:00:26.950 --> 00:00:29.020
API turns out to have many meanings.

00:00:29.020 --> 00:00:32.680
But we're not here talking about
Active Pharmaceutical Ingredients.

00:00:32.680 --> 00:00:36.650
We're not talking about Armor-Piercing Incendiaries.

00:00:36.650 --> 00:00:39.940
Definitely not the American Pirate Industries.

00:00:39.940 --> 00:00:42.070
And it's not the American Pain Institute.

00:00:42.070 --> 00:00:45.830
Now, these all sound like fun topics for
talks, but this is not what we're covering.

00:00:45.830 --> 00:00:49.970
Instead, we're talking about Application
Programming Interfaces.

00:00:49.970 --> 00:00:56.420
Now, APIs, Application Programming Interfaces, are very
important because they allow your code to interface

00:00:56.420 --> 00:01:02.380
with the system, you know, let you use
the facilities of the operating system.

00:01:02.380 --> 00:01:05.410
But well-designed APIs go much further.

00:01:05.410 --> 00:01:07.170
They make you more productive.

00:01:07.170 --> 00:01:11.980
When you're using well-designed APIs, you don't
have to look at documentation for every single API.

00:01:11.980 --> 00:01:14.020
You've learned how the APIs work in general.

00:01:14.020 --> 00:01:16.530
You can predict how they're going to behave.

00:01:16.530 --> 00:01:19.330
Well-designed APIs allow you to leverage existing code.

00:01:19.330 --> 00:01:24.880
Not only can you reuse something, you can
go ahead and extend it to your own needs.

00:01:24.880 --> 00:01:29.700
Well-designed APIs also let your write
code that works as the user expects.

00:01:29.700 --> 00:01:32.330
That's because well-designed APIs set policy.

00:01:32.330 --> 00:01:39.320
And by using these APIs, you make apps that,
for instance, do the HI guidelines correctly,

00:01:39.320 --> 00:01:42.800
so the user is happy because your
code works like other code.

00:01:42.800 --> 00:01:47.980
Now, APIs live for a long time so that's
why we consider API design very important.

00:01:47.980 --> 00:01:51.870
Once we've put an API out here and it's
adopted, it's very hard for us to get rid of it.

00:01:51.870 --> 00:01:55.740
So, if we made some mistake, it takes
a while to correct that mistake.

00:01:55.740 --> 00:02:01.710
And one final factor is that API
design is UI design for developers.

00:02:01.710 --> 00:02:05.740
So, just like Apple takes UI design of its software

00:02:05.740 --> 00:02:10.380
and its hardware very seriously, we
also take API design very seriously.

00:02:10.380 --> 00:02:18.900
Here are the five factors we consider important when we're
designing APIs, and the talk is going to cover, it's going--

00:02:18.900 --> 00:02:23.060
the talk is going to have these
five sections covering these areas.

00:02:23.060 --> 00:02:27.820
Each section is going to start with why
these areas are, these factors are important,

00:02:27.820 --> 00:02:34.150
and now I'm going to give examples of how
these factors are reflected in our APIs,

00:02:34.150 --> 00:02:39.860
and how you yourself can also use these--
use these factors in your own APIs as well.

00:02:39.860 --> 00:02:46.610
Now, this talk assumes knowledge of Objective-C, and
you've hopefully programmed a bit in Cocoa or Cocoa Touch.

00:02:46.610 --> 00:02:52.060
A lot of the examples I'm going to use are from Foundation,
since it's a common substrate to AppKit and UIKit.

00:02:52.060 --> 00:02:56.870
However, in some cases, we'll also use
examples from AppKit or UIKit as well.

00:02:56.870 --> 00:03:02.430
OK. So with that, let's begin to our
first section which is consistency.

00:03:02.430 --> 00:03:07.830
And the main topic in this section is naming conventions.

00:03:07.830 --> 00:03:10.480
Now, I'll just cover some of the
naming conventions we use in our APIs.

00:03:10.480 --> 00:03:15.090
Now, why is consistency important?

00:03:15.090 --> 00:03:20.530
Well, as I said earlier, it eliminates the need
to refer to documentation for every single API.

00:03:20.530 --> 00:03:24.120
You can read about the general guidelines,
the general rules, the general philosophy,

00:03:24.120 --> 00:03:28.050
and now you don't have to look up every
single API to understand what it does

00:03:28.050 --> 00:03:32.200
or what other APIs there might be with it.

00:03:32.200 --> 00:03:36.180
Consistency also allows different subsystems
to plug-in to each other more easily.

00:03:36.180 --> 00:03:40.660
You know if you get one Objective-C API from
someone and another one from someone else,

00:03:40.660 --> 00:03:43.550
with this consistency, it should work well together.

00:03:43.550 --> 00:03:48.140
And finally as, well not finally because there
are many, many reasons why it's important,

00:03:48.140 --> 00:03:50.650
but one other way it's important is that being--

00:03:50.650 --> 00:03:56.320
having consistent APIs actually can
improve performance as we'll see later.

00:03:56.320 --> 00:03:59.180
OK. So let's dive into naming conventions.

00:03:59.180 --> 00:04:01.940
And the first thing I want to talk
about is naming of classes.

00:04:01.940 --> 00:04:09.610
I'm sure many of you have seen some of the classes we
have in our APIs: NSString, UIView, CLLocation, et cetera.

00:04:09.610 --> 00:04:12.010
And typically, class names are nouns.

00:04:12.010 --> 00:04:15.170
And one thing you'll notice is that we use prefixes.

00:04:15.170 --> 00:04:20.560
Now, prefixes protect against collisions,
and they also differentiate functional areas.

00:04:20.560 --> 00:04:24.230
A name like view or location is highly generic.

00:04:24.230 --> 00:04:29.260
It's possible that two different
developers might use the same name.

00:04:29.260 --> 00:04:33.050
But in addition, using the prefix like
CL allows you to immediately recognize

00:04:33.050 --> 00:04:36.500
that this class comes from Core Location.

00:04:36.500 --> 00:04:43.220
So in your own designs, in your application, you don't have
to use prefixes since you're managing the whole namespace,

00:04:43.220 --> 00:04:48.390
but it might be a good idea for you to use prefixes as well
in which case I recommend either using three-letter prefixes

00:04:48.390 --> 00:04:56.340
or maybe even more complete longer prefixes for your class
names, where it may be it's the name of your company.

00:04:56.340 --> 00:05:00.910
Method names, you've undoubtedly seen many
methods if not before during this week.

00:05:00.910 --> 00:05:02.440
Here are some examples.

00:05:02.440 --> 00:05:05.090
With method names, we focus on readability.

00:05:05.090 --> 00:05:07.050
For instance, the name "is Editable" there.

00:05:07.050 --> 00:05:13.010
We put the "is" in there as a general rule because
it makes it easier to read, myTextField.isEditable.

00:05:13.010 --> 00:05:14.900
That reads very naturally.

00:05:14.900 --> 00:05:16.760
Now, some other things you'll notice here.

00:05:16.760 --> 00:05:18.830
We use camel case.

00:05:18.830 --> 00:05:25.170
What camel case means is the subwords
inside our names are actually capitalized.

00:05:25.170 --> 00:05:27.150
We don't use underbars or anything like that.

00:05:27.150 --> 00:05:29.470
We actually use uppercase letters.

00:05:29.470 --> 00:05:33.860
And one other thing you might notice
is we choose clarity over brevity.

00:05:33.860 --> 00:05:40.280
In some cases, our names are not short
and we also name all the arguments.

00:05:40.280 --> 00:05:43.210
Now, I'll talk about these last two now.

00:05:43.210 --> 00:05:48.090
So, here's an example method from
NSMutableArray removeObjectAtIndex.

00:05:48.090 --> 00:05:51.070
You might be wondering why all those words.

00:05:51.070 --> 00:05:56.360
Well, this method is trying to communicate to you that
removes an object at an index, so the argument is an index.

00:05:56.360 --> 00:06:00.190
In fact, we have another method called
removeObject which removes an object.

00:06:00.190 --> 00:06:06.190
So you can immediately see that these two are distinguished
by those words, and it's really clear what each one does.

00:06:06.190 --> 00:06:10.600
So, those of you wondering why isn't there just a
method called remove, well you can now understand why

00:06:10.600 --> 00:06:14.380
that the method remove would be ambiguous
in the presence of these other two methods.

00:06:14.380 --> 00:06:18.260
Remove by itself just does not
communicate either one of these.

00:06:18.260 --> 00:06:24.090
And for that reason, we often try to name, you
know, with a noun what the argument is about.

00:06:24.090 --> 00:06:25.540
Naming all the arguments.

00:06:25.540 --> 00:06:28.920
Here's a method that's not the longer
method names in our frameworks.

00:06:28.920 --> 00:06:32.740
It comes from NSBitmapImageRep, in AppKit.

00:06:32.740 --> 00:06:37.010
You can see all the keywords I'm talking about,
you know, the pixelsWide, pixelsHigh and so on.

00:06:37.010 --> 00:06:39.520
Now, here's a secret, but I don't
want you to take it out of this room.

00:06:39.520 --> 00:06:43.370
In fact, you should forget about it
after the beer bash wil help with that.

00:06:43.370 --> 00:06:46.030
I want you to forget about it after you see it.

00:06:46.030 --> 00:06:50.930
But you can create a method name like this
where you actually removed all those keywords.

00:06:50.930 --> 00:06:52.320
But we don't want you to do that.

00:06:52.320 --> 00:06:58.330
As you can see, you immediately start losing, you
know, some of the what-- you're trying to communicate.

00:06:58.330 --> 00:07:00.910
When you're using this method in
code, here's what this looks like.

00:07:00.910 --> 00:07:04.740
You know, you have all these numbers like 32 YES, NO, 0.

00:07:04.740 --> 00:07:09.570
Without those names, you know,
really this will be lot less clear.

00:07:09.570 --> 00:07:12.010
In fact, let me give you a concrete example.

00:07:12.010 --> 00:07:19.510
Back about year 2000, we're experimenting with Java and,
you know, a lot of other people were a lot of crazy kids.

00:07:19.510 --> 00:07:21.180
But we didn't inhale.

00:07:21.180 --> 00:07:24.300
[ Laughter ]

00:07:24.300 --> 00:07:27.420
[ Applause ]

00:07:27.420 --> 00:07:32.290
Anyway, so here's what this-- and we have this
class method actually existed in Java as well.

00:07:32.290 --> 00:07:33.120
Here is what it look like.

00:07:33.120 --> 00:07:40.140
New NSBitmapImageRep, and as you can see, you immediately
lose all what all those arguments mean - 32, true, false --

00:07:40.140 --> 00:07:42.100
you know, you have to go and look up what this means.

00:07:42.100 --> 00:07:46.040
So, this is the reason why those arguments are important.

00:07:46.040 --> 00:07:49.260
OK. Naming accessors, getters, and setters.

00:07:49.260 --> 00:07:55.100
Here are some examples:- color,
setColor, isEditable, setEditable, so on.

00:07:55.100 --> 00:08:00.190
Now, one thing to note, as I mentioned earlier, for boolean
properties that are adjectives, we use "is" on the getter.

00:08:00.190 --> 00:08:03.420
So, it's "setEditable", but the getter is "isEditable".

00:08:03.420 --> 00:08:08.900
Another thing you might notice is that we do not
embellish the getter with "get" or other verbs.

00:08:08.900 --> 00:08:14.560
So, for instance, the color method is not called "getColor".

00:08:14.560 --> 00:08:16.770
It just reads better to have it be "color".

00:08:16.770 --> 00:08:20.980
Another example is we don't put words
like "compute" on the accessors.

00:08:20.980 --> 00:08:25.430
For instance, the last one here, even if
the thumbnail image is computed, you know,

00:08:25.430 --> 00:08:29.980
when you ask an object for its thumbnail image,
even if that object computes the thumbnail image,

00:08:29.980 --> 00:08:33.760
it's usually not interesting to communicate
the fact that it's being computed.

00:08:33.760 --> 00:08:37.190
Just have the property, call it
ThumbnailImage and that's good enough.

00:08:37.190 --> 00:08:43.290
Only in the cases where it is important to communicate that
or distinguish it would you want to put those words in.

00:08:43.290 --> 00:08:49.510
Now, there are some acceptable uses of
"get", and that's one case is when we use,

00:08:49.510 --> 00:08:52.740
we use get on accessors that return values by reference.

00:08:52.740 --> 00:08:59.220
For instance, the NSData method getBytes: which returns
an arbitrary number of bytes given the range argument,

00:08:59.220 --> 00:09:01.680
it really needs a buffer so to get method.

00:09:01.680 --> 00:09:03.810
Another example is this method from UIBezierPath

00:09:03.810 --> 00:09:08.610
which returns three related arguments,
three related properties at once.

00:09:08.610 --> 00:09:12.810
In this case, we actually have a get
method that returns three different values.

00:09:12.810 --> 00:09:14.820
They are all by reference.

00:09:14.820 --> 00:09:22.050
You'll note that the caller can pass NULL in
for the arguments they don't want in such cases.

00:09:22.050 --> 00:09:25.860
For accessors, the simple accessors, you
can certainly go ahead and use @property

00:09:25.860 --> 00:09:28.140
and we encourage that whenever it's possible.

00:09:28.140 --> 00:09:33.420
You know, our accessors in this case would
look like this, property (copy) UIColor *color.

00:09:33.420 --> 00:09:38.930
For the editable one, we have a special getter because
@property does not know about our rule about putting "is",

00:09:38.930 --> 00:09:42.510
so you might have seen this in our
APIs where we specify a special getter.

00:09:42.510 --> 00:09:44.370
Now, let me talk a bit about functions.

00:09:44.370 --> 00:09:46.740
Function names you probably seen a few.

00:09:46.740 --> 00:09:48.730
Here's what they look like.

00:09:48.730 --> 00:09:54.140
Typically, for functions, the rule is to use a framework
prefix followed by the type or functionality area,

00:09:54.140 --> 00:09:56.040
and then followed by whatever is happening.

00:09:56.040 --> 00:10:01.110
For instance, CFRangeMake, CGPathAddLines.

00:10:01.110 --> 00:10:07.010
And the common prefix allows easier
searching, sorting, et cetera.

00:10:07.010 --> 00:10:09.210
Enum values and constants are very similar.

00:10:09.210 --> 00:10:11.160
Here are some examples.

00:10:11.160 --> 00:10:14.710
Now, we also have sometimes common suffixes.

00:10:14.710 --> 00:10:16.210
Notification is one of them.

00:10:16.210 --> 00:10:18.420
We use that for NSNotification contants.

00:10:18.420 --> 00:10:21.070
Key is another one.

00:10:21.070 --> 00:10:25.360
That's for symbols that are dictionary keys.

00:10:25.360 --> 00:10:30.380
Now, one thing to note about functions, enum values and
constants, and it's actually true for some other APIs,

00:10:30.380 --> 00:10:33.890
our naming conventions have evolved over time.

00:10:33.890 --> 00:10:39.820
So, although we have some examples of, you know,
great naming, which follow our conventions,

00:10:39.820 --> 00:10:43.110
you will also occasionally run
across names that are not that great.

00:10:43.110 --> 00:10:47.710
These are mostly some of the older names that
we haven't either had a chance to deprecate

00:10:47.710 --> 00:10:49.640
or we're just leaving it in there for old time sake.

00:10:49.640 --> 00:10:51.700
You can see some examples here.

00:10:51.700 --> 00:10:58.390
So, not everything you run across especially in some of
the older APIs may be correct but, you know, in general,

00:10:58.390 --> 00:11:00.960
for new APIs, we definitely follow the latest conventions.

00:11:00.960 --> 00:11:04.750
Do not abbreviate arbitrarily.

00:11:04.750 --> 00:11:07.820
Here is a fine-looking method,
which is maybe a little too wordy,

00:11:07.820 --> 00:11:10.440
but you know, as I said again, there is value in that.

00:11:10.440 --> 00:11:15.380
You might make it just a little bad
by arbitrarily abbreviating point

00:11:15.380 --> 00:11:18.500
to pnt, you know, setFloatingPntFormat, OK.

00:11:18.500 --> 00:11:22.130
I mean this generally help you because
Xcode usually helps you at typing.

00:11:22.130 --> 00:11:27.070
Or you can make it really ugly by removing all
the vowels out of it, if you're a vowel hater.

00:11:27.070 --> 00:11:30.090
But you know, we don't recommend this.

00:11:30.090 --> 00:11:32.890
So, the first one is really the best one here.

00:11:32.890 --> 00:11:36.750
Now, there are some acceptable abbreviations
though, and it's good to be consistent.

00:11:36.750 --> 00:11:42.160
Our documentation lists some of these acceptable
abbreviations: alloc, dealloc, et cetera.

00:11:42.160 --> 00:11:47.280
There are also commonly used acronyms such
PDF and USB, and we recommend you use these.

00:11:47.280 --> 00:11:50.250
Because if you went ahead and spelled
out portable document formats,

00:11:50.250 --> 00:11:52.140
some people might not even know what you're referring to.

00:11:52.140 --> 00:11:56.340
You know, people are so used to terms like
USB and PDF, so it's best to stick to them.

00:11:56.340 --> 00:11:58.920
It's also good to stick to consistent terminology.

00:11:58.920 --> 00:12:04.710
Earlier, I gave you the example of remove, you know,
maybe one possibility is, hey, instead of remove objects,

00:12:04.710 --> 00:12:07.970
let's use delete, and instead of remove
this way, let's use some other term.

00:12:07.970 --> 00:12:11.930
So, you know, there might be a tendency to
look in the source and come up with synonyms.

00:12:11.930 --> 00:12:13.310
There are a lot of great synonyms.

00:12:13.310 --> 00:12:15.700
You know, vaporizeObjectsAtIndex, sounds great.

00:12:15.700 --> 00:12:16.520
[ Laughter ]

00:12:16.520 --> 00:12:22.990
However, it really does make APIs less predictable,
so it's, you know, good to stick to consistent words

00:12:22.990 --> 00:12:26.800
and use more descriptive words
to describe your functionality.

00:12:26.800 --> 00:12:30.600
And avoid names that are ambiguous.

00:12:30.600 --> 00:12:36.090
You know, at first glance, these
names don't look so bad, but sendPort,

00:12:36.090 --> 00:12:41.840
is that a method that sends a port
or is that a port used for sending?

00:12:41.840 --> 00:12:46.840
displayName, is this a directive to display
a name or is it name used for display?

00:12:46.840 --> 00:12:49.650
Center, is that a verb or is it a noun?

00:12:49.650 --> 00:12:56.600
It turns out center is a verb in AppKit and a noun
in UIKit, so there's one we missed out of the gate.

00:12:56.600 --> 00:13:00.610
So, it's good to try to disambiguate these
names and choose a little more clear names.

00:13:00.610 --> 00:13:02.440
Here are some suggestions here.

00:13:02.440 --> 00:13:04.540
One is this portForSending.

00:13:04.540 --> 00:13:07.780
localizedNames is actually one we do use whenever we can.

00:13:07.780 --> 00:13:13.190
And a middle, maybe center as a noun, middle might be a
better term, we don't use it, but maybe we should consider.

00:13:13.190 --> 00:13:17.630
And let me talk a bit about Block naming.

00:13:17.630 --> 00:13:22.120
Blocks, as you know, are new in Snow Leopard and iOS 4.

00:13:22.120 --> 00:13:27.630
Block itself can be ambiguous because Block as a
verb is like block, you know stop, block processing.

00:13:27.630 --> 00:13:29.410
So, we try to be careful with that.

00:13:29.410 --> 00:13:34.920
So, we use the term Block only in generic
cases such as enumerateObjectsusingBlock.

00:13:34.920 --> 00:13:41.590
But in other cases where we can have more descriptive
names, we have come up with a list of names that we use.

00:13:41.590 --> 00:13:49.250
For instance, indexOfObjectsPassingTest, a Block that
returns a boolean that cites or testing is a test.

00:13:49.250 --> 00:13:54.790
We also have Comparator, handler,
completionHandler, ExpirationHandler, et cetera.

00:13:54.790 --> 00:13:58.160
So, these are some of the terms
we are using to describe blocks.

00:13:58.160 --> 00:14:04.100
OK. So, the last item I want to discuss
in this section is object ownership.

00:14:04.100 --> 00:14:09.350
Now, most of you are probably familiar with object
ownership rules in Cocoa and the memory management rules.

00:14:09.350 --> 00:14:15.720
Object ownership is not transferred across calls,
and the only methods that actually do are exemptions

00:14:15.720 --> 00:14:24.340
to this rule are methods whose names begin with
alloc, new, copy.mutableCopy or the retain method.

00:14:24.340 --> 00:14:28.740
So, what this means is whenever you're looking
an API, you never have to ask the question,

00:14:28.740 --> 00:14:31.600
do I have to release the results from calling this method.

00:14:31.600 --> 00:14:37.280
And similarly, if you're designing your
own API, you have a good guideline.

00:14:37.280 --> 00:14:42.610
Now, there might be mistakes in APIs especially if a
subsystem was designed without API guidelines in mind,

00:14:42.610 --> 00:14:46.210
maybe it's an internal subsystem of your application.

00:14:46.210 --> 00:14:53.610
And if you're on the Clang Static Analyzer, it will
mark these erroneous names and give you warnings

00:14:53.610 --> 00:14:56.820
that you're over-releasing an object
or you're not releasing it enough.

00:14:56.820 --> 00:15:01.590
We do have some attribute, a decorator
you can add to methods for this purpose.

00:15:01.590 --> 00:15:07.110
For instance, if you had a method name, full name
that erroneously returned and retained object,

00:15:07.110 --> 00:15:10.070
you could put NS_RETURNS_RETAINED
on there to sort of describe

00:15:10.070 --> 00:15:13.200
to the analyzer, hey, this returns your retained object.

00:15:13.200 --> 00:15:17.730
However, please use this only for
Static Analyzer's purposes.

00:15:17.730 --> 00:15:21.800
You know, do not use it to define
bad APIs or just iffy APIs.

00:15:21.800 --> 00:15:26.100
We intend not to have any APIs, you know,
in this system that use this, for instance.

00:15:26.100 --> 00:15:30.180
If we did, that would be an error and we'd want to fix it.

00:15:30.180 --> 00:15:33.720
OK. With that, let's get to the performance section.

00:15:33.720 --> 00:15:44.210
In here, we're going to talk about Impedance matching, I'll
describe what I mean by that, mutability, and concurrency.

00:15:44.210 --> 00:15:48.780
So, first of all, why is performance important?

00:15:48.780 --> 00:15:51.110
Well, you know, it seems like that's an obvious question.

00:15:51.110 --> 00:15:55.970
Users love it, you know, when the applications are
fast in response, so that seems like a clear one.

00:15:55.970 --> 00:16:04.760
But another reason performance is important is that even
though an application might seem responsive and fast,

00:16:04.760 --> 00:16:10.320
maybe it's not fast enough or maybe it's not doing things
fast enough where it's using more power than needed.

00:16:10.320 --> 00:16:16.550
So, being especially focused on performance, you
know, making sure you're getting everything as fast

00:16:16.550 --> 00:16:19.630
as possible can improve battery life and make users happier.

00:16:19.630 --> 00:16:24.360
So, let me talk about impedance matching.

00:16:24.360 --> 00:16:29.780
Impedance matching, to describe what it means, it's a term,
I think, from electrical engineering where it's talking

00:16:29.780 --> 00:16:35.270
about input and output connections,
and it's done in such a way

00:16:35.270 --> 00:16:40.110
that the power is maximized, the throughput is maximized.

00:16:40.110 --> 00:16:45.100
So, it's basically a term that, you know, where you
can connect things together with highest efficiency.

00:16:45.100 --> 00:16:52.050
You might think of it as plug and
play, really, easy plug and play.

00:16:52.050 --> 00:16:59.650
Now, what I mean here is this concept of using small number
of basic data types in APIs, and not having redundancy.

00:16:59.650 --> 00:17:03.030
That improves consistency.

00:17:03.030 --> 00:17:06.370
You can plug things together more easily.

00:17:06.370 --> 00:17:08.220
Code fits together more easily.

00:17:08.220 --> 00:17:10.980
In addition, it eliminates the need to do conversions.

00:17:10.980 --> 00:17:15.900
If you have two different representations for the
same concept, every time you cross an API boundary,

00:17:15.900 --> 00:17:19.660
you have to do conversions on those,
and that just reduces performance.

00:17:19.660 --> 00:17:24.010
So, for to this end, we have a small
number of basic data types for strings.

00:17:24.010 --> 00:17:27.850
You know, we use NSStrings everywhere,
in all API for strings.

00:17:27.850 --> 00:17:30.040
NSDates for dates.

00:17:30.040 --> 00:17:33.110
NSURLs to represent file paths.

00:17:33.110 --> 00:17:39.970
For ordered collections or association tables
or map tables, we use NSArray, NSDictionary.

00:17:39.970 --> 00:17:44.220
There's also NSSet, but it is used less commonly in APIs.

00:17:44.220 --> 00:17:48.930
In addition, we have this other
higher level types, UIColor and UIKit,

00:17:48.930 --> 00:17:53.390
NSColor in AppKit, and types for font and image as well.

00:17:53.390 --> 00:17:59.360
So, I recommend that anytime you want to represent an image
in your application or in you API, you use either UIImage

00:17:59.360 --> 00:18:06.230
or NSImage with regard to UIKit or AppKit,
and there are few other types that fit here.

00:18:08.440 --> 00:18:11.080
Now, not all basic data types are objects.

00:18:11.080 --> 00:18:14.260
You might know that we have some
C types in our APIs as well.

00:18:14.260 --> 00:18:17.210
For instance, NSInteger and NSUInteger.

00:18:17.210 --> 00:18:21.470
These are actually simple typedefs on top of int or long.

00:18:21.470 --> 00:18:23.320
CGFloat is another type like that.

00:18:23.320 --> 00:18:25.500
It's either a float or a double.

00:18:25.500 --> 00:18:27.450
Now, we do have an NSNumber type.

00:18:27.450 --> 00:18:29.360
It's an object to represent numbers.

00:18:29.360 --> 00:18:35.690
But you've probably have noticed that we do not use
NSNumbers in our APIs to represent numerical quantities,

00:18:35.690 --> 00:18:40.250
we only use NSNumbers to wrap these
basic types when necessary, for instance,

00:18:40.250 --> 00:18:43.750
when you're putting them in dictionaries or arrays.

00:18:43.750 --> 00:18:47.470
Now, we also have some struct types.

00:18:47.470 --> 00:18:54.410
And for widely use types, you know, things they are using
all over the place where abstraction is not important,

00:18:54.410 --> 00:18:57.140
it's not valuable, it's OK to use structs.

00:18:57.140 --> 00:19:02.430
We have four widely use structs,
points, ranges, sizes, and rects.

00:19:02.430 --> 00:19:06.060
Consider this point, you know, CGPoint, it's got X and a Y.

00:19:06.060 --> 00:19:10.920
We have, you know, we do not pretend
that anybody will want to extend CGPoint,

00:19:10.920 --> 00:19:13.360
nobody is going to want to subclass CGPoint.

00:19:13.360 --> 00:19:15.320
We have a bunch of utility functions and that's good enough.

00:19:15.320 --> 00:19:19.600
It's OK for you to go in there and group
the X and the Y values, you know, it's OK.

00:19:19.600 --> 00:19:23.670
It's a public struct, we all understand it,
it works well, points aren't going to change.

00:19:23.670 --> 00:19:25.950
With that in mind, structs are OK.

00:19:25.950 --> 00:19:32.780
Structs are good because you can, you know, stack allocate
them, and you can use them, you know, pretty flexibly.

00:19:32.780 --> 00:19:36.360
Now, once upon a time when we were
designing some of the basic types,

00:19:36.360 --> 00:19:39.620
we made the mistake of designing
the color type to be a struct.

00:19:39.620 --> 00:19:44.440
So, it was basically a struct with RGBA,
and we quickly realized our mistake,

00:19:44.440 --> 00:19:48.170
you know, and color is much richer type than that.

00:19:48.170 --> 00:19:50.610
You know, you have different color representation, CMYK.

00:19:50.610 --> 00:19:52.160
You have color matching information.

00:19:52.160 --> 00:19:55.050
So, we could quickly dump that
idea and switch to a color object.

00:19:55.050 --> 00:20:00.050
So that was an example where our struct is not OK.

00:20:00.050 --> 00:20:05.710
Now, so far, I've been start talking about reducing a number
of types, you know, et cetera, but then I'm also talking

00:20:05.710 --> 00:20:11.060
about sometimes multiple types that seem equivalent
and that seems to violate what I'm saying.

00:20:11.060 --> 00:20:14.220
So, you know, what's up with CGPoint and NSPoint?

00:20:14.220 --> 00:20:16.760
Why do I have two types to represent points?

00:20:16.760 --> 00:20:22.550
Well, those of you working on UIKit probably have never
even come across NSPoint because that's an Appkit concept.

00:20:22.550 --> 00:20:26.410
NSPoint was the original type for NSPoint in Appkit.

00:20:26.410 --> 00:20:27.870
CGPoint was added later.

00:20:27.870 --> 00:20:34.500
In fact, we have made the two equivalent in our
64-bit by making them the exact same typedef.

00:20:34.500 --> 00:20:38.930
So, for all purposes, these two should be
considered equal when you're working in Appkit.

00:20:38.930 --> 00:20:41.070
And in UIKit, you only have CGPoint.

00:20:41.070 --> 00:20:44.890
How about NSInteger and NSUInteger?

00:20:44.890 --> 00:20:48.570
These represent signed and unsigned integer value.

00:20:48.570 --> 00:20:49.490
Why do you we have these?

00:20:49.490 --> 00:20:52.010
Why don't we just use int?

00:20:52.010 --> 00:20:58.290
Well, our API is used to all the in terms of ints
or unsigned ints, but then when we moved to 64-bit

00:20:58.290 --> 00:21:03.730
on the desktop, we decided to add these
typedefs to sort of abstract that away.

00:21:03.730 --> 00:21:07.670
So, all our APIs are not in terms
of NSInteger or NSUInteger,

00:21:07.670 --> 00:21:13.370
and these are defined to be int
or long as needed by the platform.

00:21:13.370 --> 00:21:17.770
So again, these are just basic types on
those and they are just simple covers.

00:21:17.770 --> 00:21:21.190
And finally, the CFStringRef versus NSString.

00:21:21.190 --> 00:21:26.710
Some of you might have played with Core
Foundation, used the CFStringRef type for instance,

00:21:26.710 --> 00:21:30.190
and you might be wondering why
do we have two types for strings.

00:21:30.190 --> 00:21:34.600
Well, it turns out these two types
are actually totally equivalent.

00:21:34.600 --> 00:21:37.940
You can just typecast between them,
no conversion is necessary.

00:21:37.940 --> 00:21:43.020
The reason we have CFStringRef is to satisfy
the needs of very low level implementations

00:21:43.020 --> 00:21:45.150
that do not use object-oriented programming.

00:21:45.150 --> 00:21:50.750
For all object-oriented implementations
based on foundation or above, use NSString.

00:21:50.750 --> 00:21:54.260
It plays much better with the object-oriented environment.

00:21:54.260 --> 00:21:56.700
And it's also on the desktop, especially.

00:21:56.700 --> 00:21:57.470
This is important.

00:21:57.470 --> 00:22:01.040
It's garbage collection ready out of the box.

00:22:01.040 --> 00:22:06.000
So, we refer to this relationship between
these two types as toll-free bridging.

00:22:06.000 --> 00:22:15.490
And this relationship also exists for CFArray and NSArray
or CFDictionary, NSDictionary and also a few other types.

00:22:15.490 --> 00:22:19.170
OK. So with that, let me talk about mutability.

00:22:19.170 --> 00:22:24.550
Now, mutable means changeable,
sort of like the term "mutate."

00:22:24.550 --> 00:22:29.730
Many objects are by nature mutable-- only
mutable, for instance, NSWindow or UIScrollView.

00:22:29.730 --> 00:22:34.400
It's got many properties that can
change, and it's a changeable object,

00:22:34.400 --> 00:22:38.040
you can't even think of it as an
unchangeable, immutable object.

00:22:38.040 --> 00:22:41.820
But then there are other types such as
strings or colors that can be considered

00:22:41.820 --> 00:22:45.620
in immutable forms and these are usually value objects.

00:22:45.620 --> 00:22:53.350
And what I mean by a value object is object whose important
characteristic is its value not its object identity.

00:22:53.350 --> 00:23:01.110
If you have two strings and their contents are both "hello",
you would consider those two strings to be equal, right?

00:23:01.110 --> 00:23:02.340
So, those are value objects.

00:23:02.340 --> 00:23:06.760
And in those cases, the immutable approach makes sense.

00:23:06.760 --> 00:23:13.260
And in some cases, having both a mutable
and an immutable variant also make sense.

00:23:13.260 --> 00:23:15.680
An example is NSString.

00:23:15.680 --> 00:23:21.280
If you have an immutable NSString, here is how
you would append to it, you have your string,

00:23:21.280 --> 00:23:26.860
you call stringByAppendingString and you
get back a new string that has a result.

00:23:26.860 --> 00:23:31.270
If you have an NSMutableString and you want to
append to it, you would just call appendString

00:23:31.270 --> 00:23:34.840
and it just modifies that sting in place.

00:23:34.840 --> 00:23:36.620
So, looking at that, you're like, "Hm.

00:23:36.620 --> 00:23:39.480
Mutable string seems more efficient here.

00:23:39.480 --> 00:23:42.040
We don't have to create an intermediate object.

00:23:42.040 --> 00:23:45.430
Why do we even have the immutable version?"

00:23:45.430 --> 00:23:52.020
Well, there are some reasons and
actually performance is one of them.

00:23:52.020 --> 00:23:57.860
If you have a string which has five characters in it
like hello and you know it's never going to change,

00:23:57.860 --> 00:24:00.060
the storage for that string can be very optimized.

00:24:00.060 --> 00:24:03.090
It can store those five characters in its base object.

00:24:03.090 --> 00:24:06.840
In fact it doesn't even have to create
another malloc block for instance.

00:24:06.840 --> 00:24:10.300
This also yields to simpler implementation.

00:24:10.300 --> 00:24:11.510
No mutation is needed.

00:24:11.510 --> 00:24:15.240
You don't have to keep track of all sorts of editing state.

00:24:15.240 --> 00:24:17.130
This yields to thread safety.

00:24:17.130 --> 00:24:21.040
You know, if you're not changing,
you can be a lot more thread safe.

00:24:21.040 --> 00:24:24.680
And this also allows for easier analysis of program logic.

00:24:24.680 --> 00:24:29.460
If you have an object at point A whose value is hello
and it's immutable, you know that later at point B,

00:24:29.460 --> 00:24:38.130
it's going to have the same value, so that makes
some things about your program easier to understand.

00:24:38.130 --> 00:24:40.640
OK. Now, which one to use in APIs?

00:24:40.640 --> 00:24:45.110
For instance, let's say you're a window or a button and
you have a title, here's what your API could look like.

00:24:45.110 --> 00:24:51.840
NSString title to give you a new title, you
know, the callers exactly give you a new title.

00:24:51.840 --> 00:24:57.160
Or you can have an API like this, NSMutableString
title where the expectation is that if somebody wants

00:24:57.160 --> 00:25:01.110
to change your title, they basically
reach in there and mutate that string.

00:25:01.110 --> 00:25:04.900
As you probably realize, this latter is not what we'd like.

00:25:04.900 --> 00:25:11.730
We almost always recommend the immutable version; that's
because sort of having immutable title and reaching in there

00:25:11.730 --> 00:25:17.380
to change it feels like you're totally breaking
the encapsulation of a window or a button object.

00:25:17.380 --> 00:25:23.520
However, oh, and by the way, this is-- if you're using
properties, which as I said is usually, you know, good idea,

00:25:23.520 --> 00:25:28.010
this adheres to the way how you would declare
this property, property (copy) NSString*(title).

00:25:28.010 --> 00:25:31.450
Now, there are few exceptions to this.

00:25:31.450 --> 00:25:34.670
For instance, there's an NSAttributedString class.

00:25:34.670 --> 00:25:42.120
It has a string method, however, its subclass
NSMutableAttributedString has a mutableString method.

00:25:42.120 --> 00:25:48.710
And this method, just because it's so special, it
returns NSMutableString value and has the word "mutable"

00:25:48.710 --> 00:25:51.720
in the name actually expects you to mutate that.

00:25:51.720 --> 00:25:53.820
It's ready for you to mutate that.

00:25:53.820 --> 00:25:58.780
So, this is, and in this case, when you mutate that
string, the containing mutable attributed string,

00:25:58.780 --> 00:26:01.440
it sees the changes and takes appropriate action.

00:26:01.440 --> 00:26:05.950
So, these exceptions are almost always going to be
named with the word "mutable" in them one way or another

00:26:05.950 --> 00:26:11.340
to make it clear to you that yes, this is OK to mutate.

00:26:11.340 --> 00:26:13.950
OK. Let me now talk about concurrency.

00:26:13.950 --> 00:26:19.780
Now, concurrency is a way to achieve
higher performance on multi-core machines.

00:26:19.780 --> 00:26:25.420
As you know, on the desktop, we're adding more
and more cores instead of cranking up CPU speeds.

00:26:25.420 --> 00:26:31.380
So, being able to run things concurrently
means you can achieve higher performance.

00:26:31.380 --> 00:26:35.540
Now, we've-- you know, all along we
have various ways to do concurrency --

00:26:35.540 --> 00:26:40.670
we had thread objects, we had runloop objects,
we had notification queues, and so on.

00:26:40.670 --> 00:26:50.470
But now we have a way to represent even more granular,
smaller grained work, and blocks are of course that tool.

00:26:50.470 --> 00:26:53.400
Blocks are a good fit for presenting concurrent work.

00:26:53.400 --> 00:26:55.810
They can be processed by Grand Central Dispatch.

00:26:55.810 --> 00:26:58.900
They can be executed by NSOperationQueue.

00:26:58.900 --> 00:27:01.610
But even more importantly, they can capture state.

00:27:01.610 --> 00:27:07.550
Now, if you're going to have some concurrent work
happening, it's great to be able to encapsulate that work,

00:27:07.550 --> 00:27:11.360
throw it out there, and have that
block capture all the state it needs

00:27:11.360 --> 00:27:13.990
so it doesn't rely on you staying around anymore.

00:27:13.990 --> 00:27:18.000
So, from that point of view, blocks
are also good hit for concurrent work,

00:27:18.000 --> 00:27:23.190
but note that not all block usage is necessarily
concurrent, and we'll see examples of this later.

00:27:23.190 --> 00:27:31.700
Now, in our-- in the APIs we're adding, when we want to
enable concurrency, there's often an explicit option,

00:27:31.700 --> 00:27:34.550
for instance, enumeration, sorting, searching.

00:27:34.550 --> 00:27:39.890
Here's an NSArray method
enumerateObjectsWithOptions:usingBlock.

00:27:39.890 --> 00:27:43.060
Here's a usage case for it.

00:27:43.060 --> 00:27:49.800
If you provide the option NSEnumerationConcurrent, the
block is executed concurrently with elements in that array,

00:27:49.800 --> 00:27:55.850
so that's an explicit way to get
concurrency out of enumeration.

00:27:55.850 --> 00:28:01.950
If you're at the What's New In Foundation talk, Tuesday,
you probably saw this in a lot of the other related APIs

00:28:01.950 --> 00:28:04.600
that we introduced in iOS 4 and Snow Leopard.

00:28:04.600 --> 00:28:08.580
Here's another example, NSNotifications.

00:28:08.580 --> 00:28:12.930
Observers can now indicate that they want
to receive notifications concurrently.

00:28:12.930 --> 00:28:17.810
For that, we have a new method,
addObserverForName object queue usingBlock.

00:28:17.810 --> 00:28:26.960
If the observer indicates a non-nil queue, the block
will be executed concurrently for that observer.

00:28:26.960 --> 00:28:31.020
So, this is again, an explicit way to
indicate your find for concurrency.

00:28:31.020 --> 00:28:36.920
And here's one more example out of
the spell, NSSpellChecker class.

00:28:36.920 --> 00:28:40.110
NSSpellChecker can do the spell checking.

00:28:40.110 --> 00:28:42.870
This class does the spell checking,
grammar checking, et cetera.

00:28:42.870 --> 00:28:51.940
It can do the checking either in a synchronous fashion with
this method where this method simply returns the result

00:28:51.940 --> 00:28:58.060
as its return value, which makes sense for a synchronous
approach, and then returns additional results here

00:28:58.060 --> 00:29:04.290
in these two argument, or it can do it asynchronously
with this method where the results are communicated

00:29:04.290 --> 00:29:07.690
in the completion handler block at a later time,

00:29:07.690 --> 00:29:11.980
and the results are returned in
these arguments, passed to the block.

00:29:11.980 --> 00:29:17.880
And also note one more thing, the sequence number passed to
the block is actually the integer value that was returned

00:29:17.880 --> 00:29:23.840
by this method so that you can associate the request
and the reply at a later time when the reply comes in.

00:29:23.840 --> 00:29:26.800
OK. So, with that, we get to our safety section.

00:29:26.800 --> 00:29:34.330
And here, I'm going to talk about runtime
errors, programming errors, and also atomicity.

00:29:34.330 --> 00:29:41.980
So, safety is important because, you know, you can
reduce the chance of crashes with safer programming.

00:29:41.980 --> 00:29:49.260
You can make debugger, debugging more easy, and also
writing more robust apps, which even if errors occur,

00:29:49.260 --> 00:29:54.650
it can indicate to the user why errors occur
then allow the user to recover is a good idea.

00:29:54.650 --> 00:30:03.140
Now, there are two types of errors that we're going to talk
about, expected errors which we also call runtime errors

00:30:03.140 --> 00:30:09.740
and programming errors which are sort of these unexpected
errors that are caused by often bugs in the program.

00:30:09.740 --> 00:30:13.670
Now runtime errors are errors that are expected to occur.

00:30:13.670 --> 00:30:18.540
For instance unreadable file, a file gets corrupt,
the user tries to open it, they get an error --

00:30:18.540 --> 00:30:26.050
out of disc space, user is trying to save a file but the
disk was full, lost network connection, invalid user input,

00:30:26.050 --> 00:30:31.250
you're trying to make a trade and you indicate
billions instead of millions you know it might happen.

00:30:31.250 --> 00:30:35.330
So these are the kind of errors that
your program should guard against.

00:30:35.330 --> 00:30:40.160
Now these are typically handled with
return values in an optional NSerror.

00:30:40.160 --> 00:30:46.200
The return value is often a boolean or an object
that returns an initialized object or nil.

00:30:46.200 --> 00:30:52.170
And in cases where you want to report an error
you would use NSError argument, here's an example.

00:30:52.170 --> 00:30:58.620
Here the ID returns, you know, returns in your
object, if it returns nil then the error argument,

00:30:58.620 --> 00:31:03.690
NSError** that's a by reference
argument indicates what the error is.

00:31:03.690 --> 00:31:12.640
And of course as before you can pass NULL here
if you don't want to hear about that error.

00:31:12.640 --> 00:31:17.830
Now sometimes NSErrors can be passed by other means
for instance here is a UIWebView delegate method,

00:31:17.830 --> 00:31:24.120
if an error occurs during loading, this delegate method
is called and the error is simply passed to the delegate.

00:31:24.120 --> 00:31:26.680
And here's another example: NSWorkspace.

00:31:26.680 --> 00:31:34.000
This is a method to NSWorkspace to make copies of
files just like the finder does on the desktop.

00:31:34.000 --> 00:31:41.540
This is an asynchronous call in a way to you pass
the URLs to copy and the completion handler is called

00:31:41.540 --> 00:31:49.300
with the NSDictionary indicating to you what the new
names of the copied files are and in addition NSError

00:31:49.300 --> 00:31:54.490
which could be nil if no error occurred or maybe
an error that indicates a partial error like 3

00:31:54.490 --> 00:31:56.770
of the files could not be copied but the rest were.

00:31:56.770 --> 00:32:01.730
So this is actually a pretty novel way
of using and indicating a partial error.

00:32:01.730 --> 00:32:07.230
Now not all APIs need NSError in fact if you look

00:32:07.230 --> 00:32:11.240
at our APIs you probably see only a
few percent of them have NSErrors.

00:32:11.240 --> 00:32:18.200
That's because NSError usage is really best confined
to API's you know where you really want the caller

00:32:18.200 --> 00:32:22.670
to either look at the error and make
decision based on the error type.

00:32:22.670 --> 00:32:27.670
But even that's a chore you know having to look through the
NSError, figure out the code, have a big switch statement

00:32:27.670 --> 00:32:31.830
and then in the future new codes
are added you know that's not fun.

00:32:31.830 --> 00:32:37.930
So the other, the more compelling reason to add
NSError is that the error may be reported to the user.

00:32:37.930 --> 00:32:40.830
What I mean by that is you get an error from an API.

00:32:40.830 --> 00:32:46.450
You know, you can just put it up to the user and
in fact have the error automatically provide ways

00:32:46.450 --> 00:32:50.380
of recovery from that error and NSError has that.

00:32:50.380 --> 00:32:54.700
It has the failure reason which is
localized and it's got recovery suggestion

00:32:54.700 --> 00:32:58.480
and even a way to provide recovery options.

00:32:58.480 --> 00:33:05.840
And the errors we provide out of our frameworks
usually have well localized error messages

00:33:05.840 --> 00:33:08.040
and sometimes recovery suggestions as well.

00:33:08.040 --> 00:33:11.040
And if you're using the App Kit there's this responder API

00:33:11.040 --> 00:33:14.760
that will let you present an error
either modally or as a sheet.

00:33:14.760 --> 00:33:17.560
But on UIKit as well you can actually take an NSError

00:33:17.560 --> 00:33:22.120
and show the various localized
pieces in whatever fashion you want.

00:33:22.120 --> 00:33:25.710
OK. So let's talk about programming errors.

00:33:25.710 --> 00:33:29.190
And these are errors often caused by misuse of APIs.

00:33:29.190 --> 00:33:30.190
Here's an example.

00:33:30.190 --> 00:33:33.320
This is out of bounds access into an array.

00:33:33.320 --> 00:33:38.040
Here's another example where you're calling a method which
expects a caller but you're calling it with a string,

00:33:38.040 --> 00:33:41.220
you know sort of maybe looks like a caller.

00:33:41.220 --> 00:33:47.860
And an invalid parameter value, we often consider
nil not to be a valid string when passed to APIs

00:33:47.860 --> 00:33:50.410
and you know this is a bad call here setStringValue of nil.

00:33:50.410 --> 00:33:58.270
Now we do not indicate programming errors by return values
because programming errors are really errors in programming

00:33:58.270 --> 00:34:04.580
in program logic and these should be fixed and
dealt with before you ship the application.

00:34:04.580 --> 00:34:08.710
It's not something that you'd expect to
deal with on the user's machine at runtime.

00:34:08.710 --> 00:34:13.080
You want to deal with it before you ship so you, you
know, you test, you find these bugs, you fix them.

00:34:13.080 --> 00:34:15.730
So there's no need to deal with them at runtime.

00:34:15.730 --> 00:34:21.090
So therefore you will never see an API like this,
setBackgroundColor, which returns an error code.

00:34:21.090 --> 00:34:26.180
And if you happen to pass in a string instead, it
will return an error indicating a string passed in.

00:34:26.180 --> 00:34:29.940
I mean how do you deal with the set runtime is just
like why would you do that, you just fix this bug.

00:34:29.940 --> 00:34:31.810
In fact, the compiler will probably tell you

00:34:31.810 --> 00:34:36.850
that you're passing a wrong argument
if you have a type checking happening.

00:34:36.850 --> 00:34:38.710
So, not a good idea.

00:34:38.710 --> 00:34:45.330
We indicate these errors via exceptions using NSException
and it's important to note that in this fashion,

00:34:45.330 --> 00:34:51.200
Cocoa uses exceptions in somewhat different ways than
some other frameworks than some other platforms do,

00:34:51.200 --> 00:34:55.050
so that is the difference in the way
exceptions are used on our system.

00:34:55.050 --> 00:34:58.680
And you know, we do not expect you to handle exceptions.

00:34:58.680 --> 00:35:02.990
For instance, you shouldn't have to write code where you
set a background color and then put that tri-cache block

00:35:02.990 --> 00:35:06.530
around it just in case a string was passed
and so you can cache it or run deal with it.

00:35:06.530 --> 00:35:08.590
Again. don't write this kind of code.

00:35:08.590 --> 00:35:14.090
Just listen to the compiler and try to fix these bugs--
discover and fix this bug before you ship your application.

00:35:14.090 --> 00:35:19.890
Now, it might still be a good idea to have a
top-level exception handling in your application.

00:35:19.890 --> 00:35:26.460
So if these kinds of exceptions do occur for the
user, you know, you should be aware, hopefully.

00:35:26.460 --> 00:35:31.230
You can alert the user something bad happened
or you can try to recover and let them say--

00:35:31.230 --> 00:35:37.740
now, if you write the Cocoa chips-- Tips and Tricks
Talk on Tuesday at 2 p.m., you saw a technique a way

00:35:37.740 --> 00:35:40.870
of doing this on the-- in the context AppKit.

00:35:40.870 --> 00:35:45.010
So, the last safety topic I want to talk about is atomicity.

00:35:45.010 --> 00:35:53.400
Objective-C 2.0 properties are by default atomic but they
can be made non-atomic by putting non-atomic keywords.

00:35:53.400 --> 00:36:02.040
And many APIs in iOS, in iPhone OS are
actually have non-atomic properties.

00:36:02.040 --> 00:36:04.360
Now, here's what atomic does.

00:36:04.360 --> 00:36:08.180
It guarantees that when one thread is setting or another--

00:36:08.180 --> 00:36:13.680
and another thread is getting a value,
you're guaranteed to get a good value.

00:36:13.680 --> 00:36:21.330
And the good value is either the previous value or the next
value, but you're guaranteed not to get some corrupt value

00:36:21.330 --> 00:36:27.720
that will make you crash or some half-set value,
for instance a rectangle whose origin comes

00:36:27.720 --> 00:36:30.320
from some place and size comes from some place else.

00:36:30.320 --> 00:36:32.710
So that's what atomic guarantee is.

00:36:32.710 --> 00:36:33.960
It's not very much.

00:36:33.960 --> 00:36:40.350
So it gives you a basic low-level of thread safety for
single property but it can actually prevent crashes

00:36:40.350 --> 00:36:43.700
in the presence of threading in your application.

00:36:43.700 --> 00:36:45.450
So it's a good idea.

00:36:45.450 --> 00:36:49.280
Now, it's important to note, this does not
provide consistency between properties.

00:36:49.280 --> 00:36:51.780
It does not give you high level of thread safety.

00:36:51.780 --> 00:36:57.170
For instance, let's say you have one part of your program
setting the first name and last name on an object,

00:36:57.170 --> 00:37:02.000
on a person object and some other part of your
program reading the first name and last name.

00:37:02.000 --> 00:37:06.270
If this guy sets the first name while-- and then
this guy comes in and then fetches the first name

00:37:06.270 --> 00:37:09.470
and last name, it will get back an invalid name.

00:37:09.470 --> 00:37:11.790
That's what I mean by how to look consistency.

00:37:11.790 --> 00:37:17.410
You know, it might get back a name like Bill Jobs
or Steve Gates, you know, that would be good.

00:37:17.410 --> 00:37:18.700
An abomination.

00:37:18.700 --> 00:37:24.230
[Laughter] So you want to-- you know, that's
that high-level consistency I'm taking about.

00:37:24.230 --> 00:37:27.770
Now, atomicity is still often a good idea to use.

00:37:27.770 --> 00:37:29.760
Leave properties atomic.

00:37:29.760 --> 00:37:31.500
It is safer.

00:37:31.500 --> 00:37:37.060
When you might concern an atomic is, if you
notice when you do use instruments for instance,

00:37:37.060 --> 00:37:44.340
if you know this calls to objc_getProperty or setProperty
keep appearing in your back traces and taking some CPU time.

00:37:44.340 --> 00:37:47.500
That's when you might want to concern using anatomic.

00:37:47.500 --> 00:37:53.520
Another case you might want to drop atomic is if
you already have higher level synchronization.

00:37:53.520 --> 00:37:57.230
You know, I just mentioned an example of where
you might use higher level synchronization.

00:37:57.230 --> 00:38:02.520
So if you already have locks or if you're already using
cues or if you already have single-threaded access

00:38:02.520 --> 00:38:05.950
to your objects, you know, as long
as those objects are confined

00:38:05.950 --> 00:38:09.920
to those contexts, you might want to non-atomic properties.

00:38:09.920 --> 00:38:15.020
The Cocoa Performance Techniques talk, from
two years ago, if you can find the video

00:38:15.020 --> 00:38:20.470
in our developer's site, has some more about this topic.

00:38:20.470 --> 00:38:25.370
OK. So with that, I want to move to the
next major section which is Reusability.

00:38:25.370 --> 00:38:28.140
And by Reusability, I also mean Extensibility.

00:38:28.140 --> 00:38:35.610
In this section, we'll talk about subclassing
categories on patterns for communicating changes.

00:38:35.610 --> 00:38:37.650
So why is Reusability important?

00:38:37.650 --> 00:38:41.600
Well, clearly, there's no need
reinvent the wheel over and over.

00:38:41.600 --> 00:38:44.390
If you can reuse something that
somebody else did, that's good.

00:38:44.390 --> 00:38:51.880
And from our point of view, we want to give you API's
that allow you to do what every application does,

00:38:51.880 --> 00:38:56.370
so that you can go ahead write the code on
top of it that distinguishes your application.

00:38:56.370 --> 00:38:59.260
So we want you to be able to reuse
our code as much as possible

00:38:59.260 --> 00:39:03.530
so you can do the creative things
that make your application shine.

00:39:03.530 --> 00:39:06.730
And also, you, yourself, can write
code which can be reused elsewhere.

00:39:06.730 --> 00:39:09.700
Maybe you can write some objects in
this application and then use them

00:39:09.700 --> 00:39:13.700
in another project you're doing by writing reusable code.

00:39:13.700 --> 00:39:19.630
So subclassing is the fundamental object-oriented
programming feature, of course, for your Reusability.

00:39:19.630 --> 00:39:21.780
You know, we all know about it.

00:39:21.780 --> 00:39:26.300
But it's not very commonly used in
Cocoa and Cocoa Touch for customization.

00:39:26.300 --> 00:39:31.550
Most of our classes are concrete, meaning they're
usable as is and they're fairly customizable.

00:39:31.550 --> 00:39:34.840
So often, rather than using subclassing
to customize objects,

00:39:34.840 --> 00:39:38.940
you just set various properties to
make them behave in different ways.

00:39:38.940 --> 00:39:42.320
However, we do have some classes
which are meant for subclassing.

00:39:42.320 --> 00:39:46.050
Sometimes, they're abstract, meaning
you have to subclass them.

00:39:46.050 --> 00:39:52.170
And other times, they're semi-abstract, meaning their
functional as is, but they probably want to be subclassed.

00:39:52.170 --> 00:39:56.970
Examples are NSObject, UIView, et cetera, NSDocument.

00:39:56.970 --> 00:39:59.240
These are classes that often subclassed.

00:39:59.240 --> 00:40:04.430
In these cases you want to identify
which methods are there for overwriting.

00:40:04.430 --> 00:40:07.130
NSObject init for instance, if you
don't have a custom initialization.

00:40:07.130 --> 00:40:12.960
If you don't have custom drawing in
your UI view, drawRect, and so on.

00:40:12.960 --> 00:40:18.500
But then there's this other subtle scenario that we have
in our frameworks, and I wanted to talk about that now.

00:40:18.500 --> 00:40:25.500
Some foundation classes such as NSString, NSData, et
cetera, are absesetract, but they're also fully usable,

00:40:25.500 --> 00:40:30.860
which means you can alloc init these and you
will get back a fully functional instance.

00:40:30.860 --> 00:40:34.360
You know, you've done this many
times in your code, I'm sure.

00:40:34.360 --> 00:40:39.060
However, if you try to subclass these, you find
that subclasses do not work unless you've gone ahead

00:40:39.060 --> 00:40:46.260
and implemented a few methods, overridden a few methods,
and these are Primitive-- what we call Primitive methods.

00:40:46.260 --> 00:40:50.870
Primitive methods are the minimal
API to implement a new subclass.

00:40:50.870 --> 00:40:55.050
In the case of NSString, there is just two methods.

00:40:55.050 --> 00:40:59.670
Just by overriding these two methods in your subclass
of NSString, you have a fully functional NSString

00:40:59.670 --> 00:41:04.770
that does everything any NSString can do.

00:41:04.770 --> 00:41:06.430
So why do we have this approach?

00:41:06.430 --> 00:41:09.130
Why are these classes abstract?

00:41:09.130 --> 00:41:10.430
Well, for one reason.

00:41:10.430 --> 00:41:18.460
We have a bunch private implementation classes that are
hidden behind a facade, like NSString, an abstract class,

00:41:18.460 --> 00:41:22.760
and we don't want to expose those private classes.

00:41:22.760 --> 00:41:26.560
So we have this behavior where subclassing
is actually giving you the abstract class.

00:41:26.560 --> 00:41:31.860
But another important reason is that we do not want to
encourage subclassing these classes for the wrong reason,

00:41:31.860 --> 00:41:36.690
and the wrong reason being to add additional properties.

00:41:36.690 --> 00:41:42.440
And that's because it changes fundamental
meaning of this object, what this object stores.

00:41:42.440 --> 00:41:44.900
And let me explain that to you.

00:41:44.900 --> 00:41:49.120
Here's NSString, it's got two fundamental
methods, length and characterAtIndex.

00:41:49.120 --> 00:41:51.610
This is how an NSString is defined.

00:41:51.610 --> 00:41:56.770
Let's say you subclass NSString with a RichString
because you-- RichString is just like a string.

00:41:56.770 --> 00:42:00.910
It's got length, characterAtIndex, but it also has a font.

00:42:00.910 --> 00:42:02.980
Now, let's try to use these two classes in a program.

00:42:02.980 --> 00:42:07.110
You create a string, its value is hello.

00:42:07.110 --> 00:42:12.120
You create a RichString, its value is
hello, but it also has the font, Helvetica.

00:42:12.120 --> 00:42:15.620
Now you ask the string, is it equal to the RichString?

00:42:15.620 --> 00:42:18.810
So the string says, "Hey, my contests are hello.

00:42:18.810 --> 00:42:20.780
That other strings contents are hello."

00:42:20.780 --> 00:42:24.680
because it only knows how to look at the
character values, and it says, "Yeah, sure.

00:42:24.680 --> 00:42:25.260
We're equal."

00:42:25.260 --> 00:42:31.110
Of course, if you ask the RichString, "Are you equal
to this poor string, the RichString puts on a monocle,

00:42:31.110 --> 00:42:34.570
takes a look and says, "No, that string is not Helvetica.

00:42:34.570 --> 00:42:35.870
We're not equal."

00:42:35.870 --> 00:42:41.180
So suddenly, you're violating some law, law of physics
or math, I don't know, but you have A is equal to B--

00:42:41.180 --> 00:42:42.000
[ Laughter ]

00:42:42.000 --> 00:42:45.540
But B is not equal to A, and that's
just a very bad thing in programming.

00:42:45.540 --> 00:42:47.630
So therefore, this is a bad idea.

00:42:47.630 --> 00:42:55.130
Let's take a look at NSString versus NSAttributedSring
and how we designed those just to solve this problem.

00:42:55.130 --> 00:42:57.400
So NSString has length and characterAtIndex.

00:42:57.400 --> 00:43:00.260
We have this other class NSAttributedString,
I already mentioned.

00:43:00.260 --> 00:43:05.190
It has a string and it has attributesAtIndex
to represent the attributes.

00:43:05.190 --> 00:43:11.080
So rather than NSAttributedString being
a subclass of NSString, it has a string.

00:43:11.080 --> 00:43:16.330
And both of these are subclasses of NSObject,
and that solves this problem I'm talking about.

00:43:16.330 --> 00:43:19.910
So this is a good design here.

00:43:19.910 --> 00:43:24.430
OK. So then, the question is, why would
you subclass NSString, NSData, et cetera,

00:43:24.430 --> 00:43:26.480
if you know, we're making it hard to subclass?

00:43:26.480 --> 00:43:32.080
Well, there're still reasons to subclass it, and the biggest
one is that you want to provide your own implementation.

00:43:32.080 --> 00:43:33.970
For instance, you could override the Primitives

00:43:33.970 --> 00:43:38.420
and have your own storage your data,
for instance, goes to a file lazily.

00:43:38.420 --> 00:43:43.790
You know, I often get the question, how can you make
NSString read a four gigabyte file and efficiently?

00:43:43.790 --> 00:43:48.660
Well, you know, you could subclass it to do that, or
various other ways of approaching large data storage.

00:43:48.660 --> 00:43:51.080
You can have NSString with a tree
backing storage if you want.

00:43:51.080 --> 00:43:54.560
Just by overriding those two methods,
you get that behaviors.

00:43:54.560 --> 00:44:00.720
The Class Clusters documentation from the Cocoa Fundamentals
Guide goes into more details on this Class Cluster approach.

00:44:00.720 --> 00:44:04.580
So we were talking about subclassing so far,
and that's one way we can extend our classes.

00:44:04.580 --> 00:44:07.760
But another way we extend our classes is via Categories.

00:44:07.760 --> 00:44:11.480
Categories is a language feature,
and it allows adding methods

00:44:11.480 --> 00:44:14.780
on existing classes where all instances are affected.

00:44:14.780 --> 00:44:16.960
This enables several things.

00:44:16.960 --> 00:44:22.700
One of them is that you can actually distribute your
methods across multiple header files, which is nice.

00:44:22.700 --> 00:44:27.450
But the other more interesting behavior is that
you can extend a class without subclassing,

00:44:27.450 --> 00:44:32.120
so that all instances of that class are affected.

00:44:32.120 --> 00:44:34.420
For instance, NSString isn't Foundation.

00:44:34.420 --> 00:44:38.550
Foundation knows nothing about
drawing, so NSString cannot draw.

00:44:38.550 --> 00:44:44.240
However, both UIKit and AppKit add new
functionality, add joint functionality to NSString.

00:44:44.240 --> 00:44:50.200
For instance, UIKit adds methods,
drawInRect withFont, drawAtPoint withFont.

00:44:50.200 --> 00:44:53.560
So let me show you how this works.

00:44:53.560 --> 00:44:56.690
Let's say we have a drawable string subclass.

00:44:56.690 --> 00:45:01.270
So here's NSString, its got length,
characterAtIndex, and bunch of other methods.

00:45:01.270 --> 00:45:06.010
We go ahead and give you a drawable string subclass
which knows how to drink-- how-- not to drink.

00:45:06.010 --> 00:45:06.780
How to--

00:45:06.780 --> 00:45:07.000
[ Laughter ]

00:45:07.000 --> 00:45:09.990
How to draw.

00:45:09.990 --> 00:45:12.530
[ Laughter ]

00:45:12.530 --> 00:45:15.070
[ Applause ]

00:45:15.070 --> 00:45:20.670
OK. And then if you create, if you have other
subclasses, some subclass and another subclass,

00:45:20.670 --> 00:45:26.940
you can see that these subclasses do not know how to draw,
so to draw a string you'd have to take these other instances

00:45:26.940 --> 00:45:30.530
and convert them to drawable strings before they can draw.

00:45:30.530 --> 00:45:33.300
So this sort of violates that all
impedance matching thing, you know,

00:45:33.300 --> 00:45:36.010
where you have to convert types just to make them draw.

00:45:36.010 --> 00:45:43.620
So, this is not a very good design, but by using categories,
you have NSString, the category is added into the string

00:45:43.620 --> 00:45:48.030
at runtime so some of the NSString knows how to draw.

00:45:48.030 --> 00:45:50.970
It replies to drawInRect, drawAtPoint, et cetera.

00:45:50.970 --> 00:45:56.760
And then your subclasses are now magically also able
to draw although, you know they have nothing to do it

00:45:56.760 --> 00:46:00.010
because these methods are part of the super implementation.

00:46:00.010 --> 00:46:01.840
So that's what categories enable.

00:46:01.840 --> 00:46:07.030
Now, in addition to subclassing and
categories, one other way to, of course--

00:46:07.030 --> 00:46:12.840
another way to extend behaviors of classes
is to have helper classes, helper objects.

00:46:12.840 --> 00:46:16.610
And so, we have several patterns for communicating changes.

00:46:16.610 --> 00:46:21.600
You're probably familiar with these: delegation,
notification, key-value observing, target-action.

00:46:21.600 --> 00:46:24.070
If not, we do have some good documentation on this

00:46:24.070 --> 00:46:28.320
in the Cocoa Design Patterns documentation
in the Cocoa Fundamentals Guide.

00:46:28.320 --> 00:46:33.210
But let me just go over how these
are used to extend behaviors.

00:46:33.210 --> 00:46:36.800
Delegation allows an object to act on behalf of another.

00:46:36.800 --> 00:46:39.430
It's not a language feature unlike categories.

00:46:39.430 --> 00:46:41.620
Classes explicitly support delegates.

00:46:41.620 --> 00:46:47.650
UITextView for instance declares that it has a
delegate as you can see here with this @property

00:46:47.650 --> 00:46:52.250
and the delegate responds to a protocol
and this protocol lists the methods

00:46:52.250 --> 00:46:55.830
that the delegate is expected to implement.

00:46:55.830 --> 00:46:59.900
In this case, they're all optional so delegate
might choose to implement only some of them.

00:46:59.900 --> 00:47:02.350
For instance, textViewShouldBeginEditing, et cetera.

00:47:02.350 --> 00:47:06.460
Now, delegation allows an object to help another object.

00:47:06.460 --> 00:47:09.530
It even allows one object to help many other objects.

00:47:09.530 --> 00:47:15.100
For instance, you might have one text
view and you might have a delegate.

00:47:15.100 --> 00:47:18.440
You might have another text view and
it might share the same delegate.

00:47:18.440 --> 00:47:23.150
In fact, you might have a table view and
it also might share the same delegate.

00:47:23.150 --> 00:47:28.490
If you do this, of course, that delegate should
respond to the UITableView delegate protocol as well.

00:47:28.490 --> 00:47:30.750
As you can see I just added, they are in that bubble.

00:47:30.750 --> 00:47:33.110
Now, delegates are also flexible.

00:47:33.110 --> 00:47:39.410
There are other object that are also sort of like
delegates, for instance UITableView also has a data source

00:47:39.410 --> 00:47:43.810
and that could be another object, even
a distinct object then its delegate.

00:47:43.810 --> 00:47:50.130
So delegation allows proper subdivision of
responsibility and it's fairly flexible.

00:47:50.130 --> 00:47:51.990
You can make it flexible.

00:47:51.990 --> 00:47:54.180
So delegation, you know, if I were to give you an analogy,

00:47:54.180 --> 00:47:58.870
a delegate is like almost your doctor
or your lawyer or maybe your spouse.

00:47:58.870 --> 00:48:04.900
You know somebody who you trust in and somebody who makes
some of the decisions for you or maybe gives you some advice

00:48:04.900 --> 00:48:09.520
on how to do things, so that's sort of
an appropriate analogy for delegation.

00:48:09.520 --> 00:48:13.510
You know, for instance, if you have an
NSWindow and the NSWindow is being closed,

00:48:13.510 --> 00:48:18.280
decision whether that window should be closed or
not, it's not really the window's place to decide.

00:48:18.280 --> 00:48:23.990
It's really the place of whoever has content being displayed
in that window to decide whether it's OK to close that.

00:48:23.990 --> 00:48:28.360
So that's why the window asks its
delegate should the window close.

00:48:28.360 --> 00:48:30.660
Notification is another pattern.

00:48:30.660 --> 00:48:36.310
Notification allows-- I was going to use the word
"event" here but "event" is so overloaded I said

00:48:36.310 --> 00:48:38.470
"happenings," which is an interesting word.

00:48:38.470 --> 00:48:42.010
It allows happenings to be broadcast
to a set of unrelated observers.

00:48:42.010 --> 00:48:44.530
These observers observe but they don't interfere.

00:48:44.530 --> 00:48:48.860
This is unlike delegation where the
delegates do have the ability to interfere.

00:48:48.860 --> 00:48:50.570
This also is in a language feature.

00:48:50.570 --> 00:48:56.630
There is a class NSNotification center and classes
have to explicitly declare notifications they post.

00:48:56.630 --> 00:49:01.410
For instance, we have many notifications
both in UIKit and AppKit,

00:49:01.410 --> 00:49:05.960
UIPasteboardChangedNotification,
NSWindowWillCloseNotification and so on.

00:49:05.960 --> 00:49:14.110
Now, note that sometimes delegate methods, you know they
might also be delegate methods that correspond to this

00:49:14.110 --> 00:49:18.490
and so the delegate might also
act as an observer in some cases.

00:49:18.490 --> 00:49:21.620
Now notifications is pretty flexible.

00:49:21.620 --> 00:49:23.160
You know you can have multiple observers.

00:49:23.160 --> 00:49:29.290
There is an indirection between the objects so that
observers can actually choose to observe any notification

00:49:29.290 --> 00:49:34.490
from a particular object or a notification from any object.

00:49:34.490 --> 00:49:36.410
That's because, you know, here are the objects we have.

00:49:36.410 --> 00:49:37.460
Here are observers.

00:49:37.460 --> 00:49:39.680
There is intermediate notification center.

00:49:39.680 --> 00:49:45.580
All the notifications are posted there and the
notification center sends the notifications

00:49:45.580 --> 00:49:48.530
to appropriate interested objects.

00:49:48.530 --> 00:49:53.750
So, if I were to give an analogy here, this is
almost like, you know, somebody whose twittering

00:49:53.750 --> 00:49:57.970
or I know you're doing it now, but it's
almost like twittering or blogging.

00:49:57.970 --> 00:50:01.880
Let's say your blogging away telling the world
about interesting things that happen to you.

00:50:01.880 --> 00:50:06.790
That might turn out nobody is reading your blog
or maybe some people signed up for your RSS feeds.

00:50:06.790 --> 00:50:10.260
So those are the observers, and you actually
don't even know how many observers you have.

00:50:10.260 --> 00:50:15.050
You know, they are just independently signing up
for your blog and you're just telling the world

00:50:15.050 --> 00:50:17.410
of what you think is important,
so that's like notifications.

00:50:17.410 --> 00:50:22.640
You choose to tell the world what's important
and they choose to listen if they want to.

00:50:22.640 --> 00:50:26.730
Key-value observing is another pattern,
I'll just quickly go over this one.

00:50:26.730 --> 00:50:30.770
This one allows objects to broadcast
updates to individual properties.

00:50:30.770 --> 00:50:33.640
You know, like a window can say, my title changed.

00:50:33.640 --> 00:50:36.790
An employee can say, my salary changed, and so on.

00:50:36.790 --> 00:50:39.010
This also is on a language feature.

00:50:39.010 --> 00:50:41.780
Classes decide which properties
they want to implement this for.

00:50:41.780 --> 00:50:44.730
However, unlike delegation notification,

00:50:44.730 --> 00:50:49.950
this doesn't require defining any new APIs,
any new symbols, and any new protocols.

00:50:49.950 --> 00:50:55.140
You know, a class just says, hey, you
know, my salary property is observable.

00:50:55.140 --> 00:51:01.650
In fact, if those properties are key-value coding compliant,
which is pretty much automatic if you use that property

00:51:01.650 --> 00:51:08.380
for instance, the key-value observing is
also automatically available in most cases.

00:51:08.380 --> 00:51:15.260
Now, key-value observing is most appropriate when
you have UIElements showing various properties.

00:51:15.260 --> 00:51:17.980
For instance, you have a text field showing the salary.

00:51:17.980 --> 00:51:22.740
That text field is interested in hearing a lot
of changes to that salary field and, you know,

00:51:22.740 --> 00:51:25.620
not necessarily any other notifications
coming from that object,

00:51:25.620 --> 00:51:30.910
so you would use key-value observing for cases like that.

00:51:30.910 --> 00:51:35.880
And finally, target action, this is
a fairly specialized simple approach.

00:51:35.880 --> 00:51:38.370
It allows UIControl syndicate user interaction.

00:51:38.370 --> 00:51:41.210
It's simple and it works well in Interface Builder.

00:51:41.210 --> 00:51:46.950
You know, control simply sends a
customizable action to a customizable target.

00:51:46.950 --> 00:51:53.950
This becomes more flexible when you have your target
specified as nil because then the responder chain is used

00:51:53.950 --> 00:51:57.100
to find the appropriate target at runtime.

00:51:57.100 --> 00:52:03.010
That's why for instance when you hit command
C, an application to copy, the appropriate,

00:52:03.010 --> 00:52:06.620
whatever the current text field
is active, gets to command C.

00:52:06.620 --> 00:52:10.260
We don't have to specify that target
ahead of time and continuously change it.

00:52:10.260 --> 00:52:15.930
The responder chain is a fairly powerful concept that
you can also use for your own purposes if you need to.

00:52:15.930 --> 00:52:18.570
For instance, we use a responder
chain also in error presentation.

00:52:18.570 --> 00:52:23.460
We just throw the error down the responder chain in
the appropriate window, and if there's no window,

00:52:23.460 --> 00:52:25.740
maybe the application will be shown there.

00:52:25.740 --> 00:52:30.680
The one final thing I'm going to talk about in this
section is Model View Controller and this is a huge topic.

00:52:30.680 --> 00:52:32.340
In fact, I talked about it earlier.

00:52:32.340 --> 00:52:33.890
I just want to have one slide.

00:52:33.890 --> 00:52:40.390
Model-View-Controller is a pattern that defines three clear
functional roles for objects, the model which owns the data,

00:52:40.390 --> 00:52:45.990
view which displays and lets the user edit the
data, and the controller which coordinates things.

00:52:45.990 --> 00:52:50.150
Each piece is separately replaceable, customizable,
and that's why this pattern is so powerful.

00:52:50.150 --> 00:52:53.550
You can choose to replace the model or the view.

00:52:53.550 --> 00:52:59.210
For instance if you're going to write a cross platform
app that works well on the iPad, the iPhone, and the Mac,

00:52:59.210 --> 00:53:05.190
you would use the ModelViewController paradigm to split
your pieces so you can reuse your model, for instance.

00:53:05.190 --> 00:53:10.640
This is used for overall app design, but also
various subsystems through our APIs use this pattern.

00:53:10.640 --> 00:53:16.570
The Cocoa text system, the bindings architecture,
UITableView, so individual classes even like UITableView,

00:53:16.570 --> 00:53:19.770
NSTableView, UIViewController use this pattern.

00:53:19.770 --> 00:53:25.940
So two talks during the week touched upon
this pattern, the model-view controller talk

00:53:25.940 --> 00:53:33.930
and Advanced Cocoa Text Tips & Tricks talks both
showed examples of how we use MVC in our APIs.

00:53:33.930 --> 00:53:40.570
OK, so with that, now we're in the convenience section,
we're going to talk about convenience APIs and blocks.

00:53:40.570 --> 00:53:43.600
So, why is convenience important?

00:53:43.600 --> 00:53:45.960
Well, there are three reasons.

00:53:45.960 --> 00:53:47.740
One is that it allows you to be more productive.

00:53:47.740 --> 00:53:51.610
Convenience APIs allow you to do more with even less code.

00:53:51.610 --> 00:53:53.850
It also makes coding fun, you know, effortless.

00:53:53.850 --> 00:53:57.420
You know, it seems more easy to do things.

00:53:57.420 --> 00:54:02.570
Now, the third reason is that I found out when I was looking
at a definition of convenience, I don't know why I did that.

00:54:02.570 --> 00:54:05.540
Apparently convenience means public
toilet in British English.

00:54:05.540 --> 00:54:05.890
[ Laughter ]

00:54:05.890 --> 00:54:07.450
And that's important.

00:54:07.450 --> 00:54:08.710
[ Laughter ]

00:54:08.710 --> 00:54:11.870
And let me use it in a sentence.

00:54:11.870 --> 00:54:17.720
At the bash tonight, you will probably need
a convenience if you drink too much beer.

00:54:17.720 --> 00:54:28.020
Anyway, so with that-- so, convenience APIs are APIs that
simplify or combine a number of other calls into one.

00:54:28.020 --> 00:54:32.370
For instance, here's an NSString method that
does comparisons and it's got four arguments.

00:54:32.370 --> 00:54:36.990
We have a convenience method on it,
compare: that just has one argument

00:54:36.990 --> 00:54:39.880
and basically fills in the other three arguments.

00:54:42.860 --> 00:54:47.320
Now, we clearly don't have convenience
APIs everywhere we could.

00:54:47.320 --> 00:54:51.140
You know, otherwise, sometimes, you look for a
convenience API and you don't see it and you have

00:54:51.140 --> 00:54:53.800
to call a bigger method and you're like,
I wish there was a convenience API.

00:54:53.800 --> 00:54:58.510
You know if you had convenience APIs
everywhere possible, that'd be a lot of APIs,

00:54:58.510 --> 00:55:06.450
so we usually consider these APIs only in cases
where the implementation is more than two lines

00:55:06.450 --> 00:55:12.130
or there are some additional value in the convenience
or there's some valuable abstraction in the convenience,

00:55:12.130 --> 00:55:16.500
and let me explain what I mean by those last two.

00:55:16.500 --> 00:55:18.860
Here are the two methods I showed you earlier.

00:55:18.860 --> 00:55:22.630
Here's the way the compare method, the
single argument one is implemented.

00:55:22.630 --> 00:55:27.980
It simply calls the four argument method
with a bunch of default arguments.

00:55:27.980 --> 00:55:30.990
I mean, if you look at it, it's really
a one line implementation, right?

00:55:30.990 --> 00:55:33.340
I mean I graphed it so it looks
good, but it's really one line.

00:55:33.340 --> 00:55:35.890
You know, you're thinking why is
there a convenience method here?

00:55:35.890 --> 00:55:39.100
Well, that's because there is additional
value in this method.

00:55:39.100 --> 00:55:45.430
The compare method allows you-- allows--
you know it can be used in sorting methods.

00:55:45.430 --> 00:55:47.950
For instance, NSArray has sort using selector.

00:55:47.950 --> 00:55:51.230
It takes a selector with one argument.

00:55:51.230 --> 00:55:55.490
So, you can just pass the compare method right in there.

00:55:55.490 --> 00:56:00.580
In fact, we have more NSString comparison
conveniences such as case insensitive compare,

00:56:00.580 --> 00:56:02.780
localized compare and so on just for this purpose.

00:56:02.780 --> 00:56:08.100
So the-- there's additional value in
these methods, in these conveniences.

00:56:08.100 --> 00:56:11.170
Another reason is valuable abstraction.

00:56:11.170 --> 00:56:14.800
Here's a method we recently added in Snow Leopard and iOS 4.

00:56:14.800 --> 00:56:22.410
This does a comparison just like the system does and we
described that this method's behavior may change over time.

00:56:22.410 --> 00:56:23.820
Here's the implementation we tell you.

00:56:23.820 --> 00:56:27.330
This is-- if you look in the release nodes,
this is the exact implementation today.

00:56:27.330 --> 00:56:30.910
However, as I said, we may change
this implementation over time.

00:56:30.910 --> 00:56:37.100
So here, this method is valuable because of its
abstraction that the implementation may change,

00:56:37.100 --> 00:56:41.330
so it's more than in fact the convenience in this case.

00:56:41.330 --> 00:56:46.900
By using it, you will get this abstraction
of comparing just like the system does.

00:56:46.900 --> 00:56:50.790
OK, so the next topic here is blocks.

00:56:50.790 --> 00:56:54.840
Now, when you think about it, blocks
are mostly for convenience.

00:56:54.840 --> 00:56:58.640
Blocks do not really enable anything
that was impossible before.

00:56:58.640 --> 00:57:00.740
You know, they bring a lot of convenience.

00:57:00.740 --> 00:57:02.450
You can specify a piece of code in line.

00:57:02.450 --> 00:57:10.310
You don't have to create an extra function, and they have
this ability to capture state, which you can also emulate.

00:57:10.310 --> 00:57:11.650
Now, I don't want to sell blocks short.

00:57:11.650 --> 00:57:12.980
Blocks are an amazing feature.

00:57:12.980 --> 00:57:15.560
In fact they are so amazing we added them to the language.

00:57:15.560 --> 00:57:19.900
In fact, we added them to C, you know, for which the
bar is pretty high, so they are an amazing feature.

00:57:19.900 --> 00:57:23.090
But in the end, they really bring a lot of convenience.

00:57:23.090 --> 00:57:29.860
For instance, we use blocks as callbacks and we're
replacing the places where they appear as callbacks.

00:57:29.860 --> 00:57:34.780
In fact, all those compare variants
are really not that necessary anymore.

00:57:34.780 --> 00:57:39.770
For instance before, if you did not have a compare
method you might have wanted like a numeric search,

00:57:39.770 --> 00:57:45.900
you would have had to go and define your
own custom function and then pass it

00:57:45.900 --> 00:57:49.370
to myArray, you know, NSArray sort using function.

00:57:49.370 --> 00:57:55.220
While before with blocks, you can just do
sortUsingComparator and pass the block right in there

00:57:55.220 --> 00:57:58.340
and the code you want to do is right
in there, so this is pretty convenient.

00:57:58.340 --> 00:58:01.180
You don't need all those compare variants anymore.

00:58:02.700 --> 00:58:05.410
Another thing we use blocks for is completions,

00:58:05.410 --> 00:58:11.190
for instance new APIs for presenting
sheets in AppKit and in the same panel.

00:58:11.190 --> 00:58:16.280
Here's what the Leopard API looks like and
here's what the Snow Leopard API looks like.

00:58:16.280 --> 00:58:17.880
It's considerably simpler.

00:58:17.880 --> 00:58:24.920
Note that we replace these last three arguments to delegate
the selector and the context in full with just the block.

00:58:24.920 --> 00:58:29.510
Also note that one thing we've done here is
get rid of this pesky void star argument.

00:58:29.510 --> 00:58:34.650
Refining that, void star arguments are really more trouble
than they're worth and we're looking at getting rid of them

00:58:34.650 --> 00:58:41.660
from our APIs as much as possible, and for one thing they
really do not behave very well under GC for instance.

00:58:41.660 --> 00:58:48.020
Here, one final example of blocks as
conveniences, the new APIs we've added in UIView,

00:58:48.020 --> 00:58:52.810
for instance animateWithDuration
animation looks fairly convenient.

00:58:52.810 --> 00:58:59.470
In fact, it replaces three lines of boilerplate code
like here, that this is the code you would have had to use

00:58:59.470 --> 00:59:05.450
on iPhone OS 3 with just one line where you're
specifying the animations you want right there in the body

00:59:05.450 --> 00:59:09.070
of the block, so again, super convenient.

00:59:09.070 --> 00:59:16.020
Hopefully, here you've heard about how good API is
very important part of Cocoa and Cocoa Touch design.

00:59:16.020 --> 00:59:20.750
We take a good API design very seriously and I
hope I've been able to communicate how we do that

00:59:20.750 --> 00:59:25.110
and how you can also do it yourself in your
own applications and in your own designs.

00:59:25.110 --> 00:59:30.420
Now modeling your APIs as ours will
allow your APIs to be more predictable

00:59:30.420 --> 00:59:36.660
so you can actually know almost all the new method names, just
roll off your tongue, you don't have to worry about them.

00:59:36.660 --> 00:59:40.270
Widely reusable, you can use it in
other projects, give it to other people,

00:59:40.270 --> 00:59:44.630
and they will also be better performing
as you hopefully saw.

00:59:44.630 --> 00:59:48.860
And one final warning, you know,
API design is an evolving art.

00:59:48.860 --> 00:59:52.550
We have examples of some APIs that are not perfectly named.

00:59:52.550 --> 00:59:56.390
So, if you ever run across something
that looks a bit fishy, maybe it is.

00:59:56.390 --> 01:00:02.730
So don't take, you know, everything strictly, but again
most of our APIs are going in the right direction.

01:00:02.730 --> 01:00:08.300
For more information, you know, you can contact
our evangelist and we have lot of great documentation,

01:00:08.300 --> 01:00:10.460
just the starting point, developer.apple.com.

01:00:10.460 --> 01:00:17.150
You can do searches for the various keywords I gave you, and
there is a lot of great background stuff on this.

