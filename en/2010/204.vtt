WEBVTT

00:00:06.620 --> 00:00:09.130
>> Welcome to Creating Secure Applications.

00:00:09.130 --> 00:00:10.600
I'm Matt Murphy.

00:00:10.600 --> 00:00:13.210
I'm an engineer on the Product Security Team.

00:00:13.210 --> 00:00:14.810
Thank you for coming.

00:00:15.980 --> 00:00:18.960
So why are you here?

00:00:18.960 --> 00:00:23.650
You probably know if you're in the audience
but, you know, it helps to go over it.

00:00:23.650 --> 00:00:27.640
So you're here because you want to avoid
the consequences of security issues.

00:00:27.640 --> 00:00:31.890
Things like negative press, lost revenue, and so on.

00:00:31.890 --> 00:00:34.570
You realize that security is a complicated business.

00:00:34.570 --> 00:00:41.610
We're dealing with more and more connected devices, you
know, things like MacBooks, iPhones, iPads and so on.

00:00:41.610 --> 00:00:45.190
And those environments demand a
lot of special care and attention.

00:00:45.190 --> 00:00:49.260
You're here because you wanted to determine
the optimal ways to prevent security issues.

00:00:49.260 --> 00:00:53.650
And if you're developing for our
platform, who better to ask?

00:00:53.650 --> 00:01:00.360
Finally, you want to maximize the benefits in terms of
security with your available resources because we all know

00:01:00.360 --> 00:01:04.330
that security is not really what you want to
do unless you're writing security software.

00:01:04.330 --> 00:01:08.390
You want to develop cool applications
and cool features for your customers.

00:01:08.390 --> 00:01:13.180
And finally, if you make a security
mistake, it's really expensive.

00:01:13.180 --> 00:01:14.780
Believe me, we know.

00:01:14.780 --> 00:01:17.580
[ Laughter ]

00:01:17.580 --> 00:01:24.350
>> So in this part of presentation, I'm going
to cover some design tips for secure software.

00:01:24.350 --> 00:01:29.820
I'm going to give you some tools that you
can use to help find bugs in your code.

00:01:29.820 --> 00:01:34.310
And some tips to avoid frequently seen security issues.

00:01:34.310 --> 00:01:40.280
And then later on, I'm going to hand it over to David who
will discuss a little bit about Objective-C and Cocoa

00:01:40.280 --> 00:01:45.360
and we'll also give you some practical examples of how
to apply some of the theoretical stuff that I'm going

00:01:45.360 --> 00:01:49.190
to discuss in the first part of the presentation.

00:01:49.190 --> 00:01:53.770
So the discussion will flow in
term of the Security Lifecycle.

00:01:53.770 --> 00:02:03.220
The four distinct components of a secure piece
of software--design, code, test, and maintain.

00:02:03.220 --> 00:02:12.860
Now, we're not going to cover the maintenance part
here. That is, as we say, an exercise to the reader.

00:02:12.860 --> 00:02:18.640
But that involves things like fixing bugs
and delivering fixes to you customers.

00:02:18.640 --> 00:02:22.900
Now, this is what I'm going to cover in
the design portion of the discussion.

00:02:22.900 --> 00:02:28.570
Now, as you'll note in the last bullet, there's quite
a bit of information about designing security software

00:02:28.570 --> 00:02:30.620
that we don't have time to cover in an hour.

00:02:30.620 --> 00:02:35.980
So we encourage you to look at the Secure Coding
Guide which is available on Apple Developer web site.

00:02:35.980 --> 00:02:40.320
And contrary to its name, it actually
has some very useful design tips as well

00:02:40.320 --> 00:02:42.510
as cutting instructions that you can use.

00:02:42.510 --> 00:02:47.710
First, we're going to talk a little
bit about privilege separation.

00:02:47.710 --> 00:02:54.230
Now, privilege separation is the art,
shall we say, of separating your code

00:02:54.230 --> 00:02:57.440
into privileged and non-privileged components.

00:02:57.440 --> 00:03:01.680
So that an ordinary user like me
can walk up to your Mac and use it.

00:03:01.680 --> 00:03:07.190
The first thing you want to know about
supporting privilege separation is what not to do.

00:03:07.190 --> 00:03:14.000
And the first thing you want to not do is you want to
not use the AuthorizationExecuteWithPrivileges API,

00:03:14.000 --> 00:03:18.700
because I've seen many, many developers
say, "Oh, but this is so easy."

00:03:18.700 --> 00:03:23.970
And they use it and they introduce security bugs
or they introduce complexity into their software.

00:03:23.970 --> 00:03:28.560
What you want to do instead is want to factor
privilege code into a background service.

00:03:28.560 --> 00:03:32.590
And we'll discuss that in a little more detail here.

00:03:32.590 --> 00:03:40.480
So you want to use launchd and you want to use the
service management APIs to set up your background service,

00:03:40.480 --> 00:03:46.170
things like SMJobBless, SMJobSubmit, those
are good reference points for you to look

00:03:46.170 --> 00:03:49.730
out if you're looking at writing privilege code.

00:03:49.730 --> 00:03:57.320
You can also see, the SampleD example which gives you
a starting point for how to write a launchd service.

00:03:57.320 --> 00:03:59.490
And it's available from the Apple Developer web site.

00:03:59.490 --> 00:04:07.130
Next, we want to cover a little bit about reduced
privilege, which is sort of practical consequence

00:04:07.130 --> 00:04:12.360
of privilege separation but it's important enough
that it gets its own section and here's why.

00:04:12.360 --> 00:04:15.910
The most important thing about
running with reduced privilege

00:04:15.910 --> 00:04:19.200
on the Mac OS is you want to test as a standard user.

00:04:19.200 --> 00:04:23.890
So many developers don't do this and they unwittingly
introduce dependencies that require the users

00:04:23.890 --> 00:04:26.520
to run as administrators to run their software.

00:04:26.520 --> 00:04:27.610
You don't want to do that.

00:04:27.610 --> 00:04:31.520
It is important for you to be a part of
good security posture as it is for you

00:04:31.520 --> 00:04:34.000
to avoid introducing bugs in your own code.

00:04:34.000 --> 00:04:39.160
When you're testing as a standard user,
your application should just work.

00:04:39.160 --> 00:04:44.620
I should be able to walk up to it and that should work the
same as a standard user as it would as an administrator

00:04:44.620 --> 00:04:49.870
with perhaps a few exceptions if you have
really truly privileged functionality.

00:04:49.870 --> 00:04:54.500
If that doesn't happen, you found
a bug and you should fix that bug

00:04:54.500 --> 00:04:58.450
because your user should be able to
run your software as a standard user.

00:04:58.450 --> 00:05:03.390
Now, a corollary to that is you don't want to rely
on the special capabilities of administrators.

00:05:03.390 --> 00:05:08.980
These are usually things like places on the file system
that you can modify when you're running as an administrator.

00:05:08.980 --> 00:05:14.030
And obviously, you can't if you're
a standard user as we just noted.

00:05:14.030 --> 00:05:19.960
But also these kinds of things might
break in the future for administrators.

00:05:19.960 --> 00:05:25.660
So we're constantly tightening the permissions of
the file system and what administrator users can do

00:05:25.660 --> 00:05:29.950
without explicitly authorizing
and gaining elevated privilege.

00:05:29.950 --> 00:05:35.730
So what I mean when I say places
on the file system you can write

00:05:35.730 --> 00:05:40.570
to /Applications including your own application bundle.

00:05:40.570 --> 00:05:45.660
If you have one user who installs you
application for example and another user

00:05:45.660 --> 00:05:48.390
who runs it, it won't be writable to that other user.

00:05:48.390 --> 00:05:54.660
Also, you know, the administrator of the system may
change the permissions on your bundle to be tighter.

00:05:54.660 --> 00:05:57.060
For example, the ownership may be root.

00:05:57.060 --> 00:06:02.270
And if your application attempts to write
into that bundle, that is going to break.

00:06:02.270 --> 00:06:07.650
/Applications/Utilities unless you are writing
and you're are installing a system utility.

00:06:07.650 --> 00:06:10.900
If you're writing a system utility
you don't want to be modifying things

00:06:10.900 --> 00:06:14.720
in that directory at runtime, only at install time.

00:06:14.720 --> 00:06:16.720
/Library and its sub-directories.

00:06:16.720 --> 00:06:24.460
Now, that's a huge list but there're a couple of common
culprits that we see people write to all the time.

00:06:24.460 --> 00:06:30.580
One is /Library/Application Support
and the other is /Library/Preferences.

00:06:30.580 --> 00:06:33.200
But as I mentioned there's quite a few others.

00:06:33.200 --> 00:06:40.080
So there are several reasons why you might write to one
of those directories and they're not always obvious.

00:06:40.080 --> 00:06:45.320
So three of the most common problems that we see
that prevent applications from running properly

00:06:45.320 --> 00:06:51.580
in a reduced privilege environment are
registration, things like serial numbers

00:06:51.580 --> 00:06:56.770
and license keys are installed in a
global directory at the first run.

00:06:56.770 --> 00:07:02.090
And so if the person running your application
is a standard user-- oops, that just broke.

00:07:02.090 --> 00:07:07.240
What you should do instead is if your--
you're going to ask for a serial number

00:07:07.240 --> 00:07:10.240
or license key during your application's launch.

00:07:10.240 --> 00:07:15.220
You should do it at the install time because your
installer has privilege and then you can save that file

00:07:15.220 --> 00:07:20.770
and then every run of the application can
simply consult it and make sure that it's there.

00:07:21.780 --> 00:07:24.520
Second, things like global preferences.

00:07:24.520 --> 00:07:30.790
A lot of applications rely on /Library/Preferences,
for example, being writable as I mentioned previously.

00:07:30.790 --> 00:07:34.890
And this will break-- you know, if
you're running as a non-administrator.

00:07:34.890 --> 00:07:41.330
So if you have a preference that you truly want
to have in effect for all users of the system

00:07:41.330 --> 00:07:46.750
and you want standard users to be able to use
your application, you should have a background job

00:07:46.750 --> 00:07:49.360
and you should protect it with authorization as necessary.

00:07:49.360 --> 00:07:55.440
Again, you can use launchd in the service
management APIs to facilitate that.

00:07:55.440 --> 00:08:01.750
Finally, and this is the most complicated
one, is the case of a custom installer.

00:08:01.750 --> 00:08:08.740
We'll see an application that you just double click and
run and it throws a bunch of files around somewhere.

00:08:08.740 --> 00:08:15.610
And most of the time that works because the user is
running as an administrator but it doesn't always.

00:08:15.610 --> 00:08:20.180
So what you want to do if you're
going to write an installer.

00:08:20.180 --> 00:08:24.690
The first thing we recommend that you do, obviously,
is use PackageMaker and the Apple Installer

00:08:24.690 --> 00:08:28.050
or one of the third party installers
that's already available.

00:08:28.050 --> 00:08:33.180
But if you need to write a custom
installer and some people do,

00:08:33.180 --> 00:08:42.710
you can also have your custom installer UI use the installer
command under the hood, basically, making your installer UI

00:08:42.710 --> 00:08:45.450
around the package system that's already there.

00:08:45.450 --> 00:08:51.780
And finally, if you can't do that, you can run
your-- you can run your installer as a launchd job

00:08:51.780 --> 00:08:54.480
and then remove it when the install completes.

00:08:54.480 --> 00:09:00.380
Now, that's a little bit hackie but it will work
for you and it will get around the privilege issue

00:09:00.380 --> 00:09:06.130
and allow your application to run properly in a reduced
privilege environment which is really important.

00:09:06.130 --> 00:09:09.670
Next, I'm going to talk a little bit about avoiding setuid.

00:09:09.670 --> 00:09:16.860
And setuid is a security curse
because it's an attacker's dream.

00:09:16.860 --> 00:09:25.200
So the attacker controls tons of things that are input to a
setuid program file descriptors, the environment, and so on.

00:09:25.200 --> 00:09:32.330
And because of the way setuid works, there can be
bugs in your code that can be exploited by an attacker

00:09:32.330 --> 00:09:38.580
or there can be bugs in third party code or
even our code that you expose by being setuid.

00:09:38.580 --> 00:09:45.400
A great many of the system frameworks for example,
don't expect to be loaded into a setuid binary.

00:09:45.400 --> 00:09:49.610
You don't want to write self-repairing tools.

00:09:49.610 --> 00:09:52.380
We've seen self-repairing tools written many, many times.

00:09:52.380 --> 00:09:56.100
Hey, if I don't have the setuid bit
AuthorizationExecuteWithPrivileges

00:09:56.100 --> 00:09:58.000
and then I'll restore the setuid bit.

00:09:58.000 --> 00:09:58.590
That's great.

00:09:58.590 --> 00:10:00.300
Right? No.

00:10:00.300 --> 00:10:02.010
Please don't do it.

00:10:02.010 --> 00:10:06.440
A local user can alter your self-repairing
binary because usually

00:10:06.440 --> 00:10:09.440
if the setuid bit is gone, the permissions are wrong.

00:10:09.440 --> 00:10:16.560
And once the local user can do that, your self-repair
will happily set the setuid bit on that modified binary

00:10:16.560 --> 00:10:19.470
and elevate the malicious code
to root the next time it runs.

00:10:19.470 --> 00:10:20.760
It is great for an attacker.

00:10:20.760 --> 00:10:23.040
Not so great for the user.

00:10:23.040 --> 00:10:28.690
So what you want to do instead of self-repairing tool is
you want to have an installer package and you want to have

00:10:28.690 --> 00:10:35.130
that installer package set the setuid bit on your file
at install time requesting RootAuthorization to do so.

00:10:35.130 --> 00:10:38.730
So that it does not subvert the privilege model.

00:10:38.730 --> 00:10:44.650
Now, to give you an idea of why we want you to
avoid setuid, we have a little diagram here.

00:10:44.650 --> 00:10:47.730
Now, to user a setuid is very simple interaction.

00:10:47.730 --> 00:10:48.750
Hey, I run a tool.

00:10:48.750 --> 00:10:49.570
It does something.

00:10:49.570 --> 00:10:52.130
I don't even really know what it does but it works.

00:10:52.130 --> 00:10:55.440
So you might not even realize that
you're running such a tool.

00:10:55.440 --> 00:10:58.130
Now to an attacker, it's a lot more interesting.

00:10:58.130 --> 00:11:06.280
An attacker has control of I/O and your setiud
tool, command-line arguments, environment variables,

00:11:06.280 --> 00:11:18.370
the working directory, file descriptors, the file mode
mask, the emask, interval timers, signal mask, mach ports,

00:11:18.370 --> 00:11:21.080
and there's more that I couldn't fit the diagram.

00:11:21.080 --> 00:11:24.870
So, you know, it is a very complicated interaction.

00:11:24.870 --> 00:11:26.120
You don't want to do it.

00:11:26.120 --> 00:11:32.070
So finally, and perhaps the most important point of
the security design discussion for a network task

00:11:32.070 --> 00:11:35.880
and particularly those of you developing
on iPhone is to protect data in transit.

00:11:35.880 --> 00:11:40.480
You have to assume users of applications
are mobile, as I mentioned before.

00:11:40.480 --> 00:11:44.170
You know, MacBooks, iPhones, iPod touches, iPads.

00:11:44.170 --> 00:11:52.390
The days where users are sitting on a desktop, they're not
quite long gone yet but they're on the way out the door.

00:11:52.390 --> 00:11:57.350
So you have to be suspicious of things like the
Domain Name System and the local network in general.

00:11:57.350 --> 00:12:01.500
Now, you know, if I am sitting at
Starbucks and I'm running your application,

00:12:01.500 --> 00:12:03.490
you know, I think, I think I am pretty safe.

00:12:03.490 --> 00:12:09.500
You know, I am on a network that I know and, you know,
I am sipping my latte and having great, great time.

00:12:09.500 --> 00:12:13.870
But what's bad about those networks is that they can be--

00:12:13.870 --> 00:12:18.640
traffic on those networks can be monitored
and can be tampered with by third party

00:12:18.640 --> 00:12:24.540
from the network relatively easily and there
are a lot of third parties on those networks.

00:12:24.540 --> 00:12:26.610
So what you want to do is any kind of sensitive data

00:12:26.610 --> 00:12:29.980
that your application is transmitting
or receiving protects it with SSL.

00:12:29.980 --> 00:12:32.910
Now, there are two really easy ways to do that.

00:12:32.910 --> 00:12:41.750
One is NSURLConnection with an https: URL and the
other is CFReadStream with the SSL extensions.

00:12:41.750 --> 00:12:46.610
Now, here is something you don't want to
do if you're protecting data in transit.

00:12:46.610 --> 00:12:49.190
Don't disable chain validation.

00:12:49.190 --> 00:12:54.090
Now, that's really important because if you disable chain
validation, you've basically told the certificate system,

00:12:54.090 --> 00:12:56.750
"Hey, any certificate is acceptable here.

00:12:56.750 --> 00:13:00.240
I don't care where it came from, anything."

00:13:00.240 --> 00:13:06.090
So I can get a certificate, present it to your
application and the system will say, "Sure, OK."

00:13:06.090 --> 00:13:07.780
So here's what that looks like.

00:13:07.780 --> 00:13:11.160
I wanted to give you an example
because I've seen it recommended a lot

00:13:11.160 --> 00:13:15.220
and people don't call it disabling
chain validation but that's what it is.

00:13:15.220 --> 00:13:20.240
And so if you see code the sets this constant
a kCFStreamSSLValidatesCertificateChain,

00:13:20.240 --> 00:13:24.230
yes I know it is a mouthful, to false, no.

00:13:24.230 --> 00:13:28.010
You need to rethink the design angle there.

00:13:28.010 --> 00:13:35.950
Now, the one case that you may want to do this is if you
are expecting to use a self sign-certificate for example.

00:13:35.950 --> 00:13:42.180
But you have to validate specifically that the
certificate you've been presented is the one you expected

00:13:42.180 --> 00:13:44.560
and that is a very complicated process.

00:13:44.560 --> 00:13:48.650
But you cannot simply disable chain
validation and plug and go.

00:13:48.650 --> 00:13:53.960
You will have introduced a vulnerability
and you'll have effectively neutered SSL.

00:13:53.960 --> 00:14:00.210
It's also important-- you know, this isn't necessarily
sensitive data per se, but it's integrity critical.

00:14:00.210 --> 00:14:05.760
So if you have code or other content that your
application will download on demand such as updates,

00:14:05.760 --> 00:14:11.110
it's really important that you sign that stuff
so that the application can verify, "Hey,

00:14:11.110 --> 00:14:14.260
this hasn't been manipulated in transit."

00:14:14.260 --> 00:14:19.830
It's very important when you're doing code
signing that you verify the signing certificate,

00:14:19.830 --> 00:14:24.150
because this poses a similar problem
to chain validation in SSL.

00:14:24.150 --> 00:14:28.560
Anyone can get a code signing certificate
and say, "Hey, this code is signed by me."

00:14:28.560 --> 00:14:33.040
I can get a certificate that says,
"Hey, Matthew Murphy signed this code."

00:14:33.040 --> 00:14:37.430
And your application will accept
it unless you explicitly validate

00:14:37.430 --> 00:14:40.980
that you've received a signature
from a particular certificate.

00:14:40.980 --> 00:14:44.170
You don't want me signing out on
packages for your applications.

00:14:44.170 --> 00:14:51.790
Trust me. So now we have talked a little bit about,
you know, designing your application securely.

00:14:51.790 --> 00:14:55.720
So there are some coding tips that I wanted to cover next.

00:14:55.720 --> 00:14:58.780
And we're going to talk about a few
different things in the coding section.

00:14:58.780 --> 00:15:02.000
But again, highly recommend reading the Secure Coding Guide.

00:15:02.000 --> 00:15:03.800
I really like it.

00:15:03.800 --> 00:15:06.020
It's great stuff.

00:15:06.020 --> 00:15:08.600
First, let's talk a little bit about safe file handling.

00:15:08.600 --> 00:15:14.810
Now the biggest part of safe file handling is
using a safe temporary or cache file directory.

00:15:14.810 --> 00:15:16.120
Now what do I mean by safe?

00:15:16.120 --> 00:15:20.840
Well, you can get them from confstr or NSTemporaryDirectory.

00:15:20.840 --> 00:15:24.790
Those are going to be good safe
directories for your application to use.

00:15:24.790 --> 00:15:26.380
Now what's an unsafe directory?

00:15:26.380 --> 00:15:35.010
It's a world-writable directory, something like say,
/tmp or /Library/Caches where other users can dump files

00:15:35.010 --> 00:15:39.090
and can potentially interfere with
your applications expectations.

00:15:39.090 --> 00:15:43.920
If you have to use these directories, these
world-writable directories--and be very, very careful--

00:15:43.920 --> 00:15:50.660
it's important to note that the higher level APIs like
the writeToFile method on NSString and NSDictionary

00:15:50.660 --> 00:15:55.450
and NSFileManager, those are not safe
to use in a world-writable directory.

00:15:55.450 --> 00:15:57.490
You'll introduce race conditions.

00:15:57.490 --> 00:16:01.580
So what you have to do is you have
to use a lower level open API.

00:16:01.580 --> 00:16:05.530
It's also important to note that
you can't open existing files

00:16:05.530 --> 00:16:09.390
in a world-writable directory in a security critical way.

00:16:09.390 --> 00:16:15.540
You have to create those files yourself to ensure
that you're manipulating the file you expect.

00:16:15.540 --> 00:16:19.030
And you have to use the exclusive flag
I've highlighted on the slide here

00:16:19.030 --> 00:16:22.480
to ensure that you don't follow links for example.

00:16:23.490 --> 00:16:26.810
Next let's cover a little bit about permissions.

00:16:26.810 --> 00:16:32.650
Now on the Mac like most Unix-like platforms,
files are actually world-readable by default.

00:16:32.650 --> 00:16:36.640
Now this stuns some people but the
most important thing to note here is

00:16:36.640 --> 00:16:42.110
that the directory structure is largely what
controls-- what controls access to a file.

00:16:42.110 --> 00:16:48.520
If you can't execute through the parent directory of a
particular file, you can't see the file much less read it.

00:16:48.520 --> 00:16:53.150
However, world-read permissions
are not appropriate for everything.

00:16:53.150 --> 00:16:59.340
So if you have a file where world-read permissions
aren't appropriate or simply aren't necessary,

00:16:59.340 --> 00:17:03.330
we encourage you to set tighter
permissions when you're creating a file.

00:17:04.480 --> 00:17:09.240
Please, please, please, please, please,
avoid creating world-writable files.

00:17:09.240 --> 00:17:11.110
Don't do it.

00:17:11.110 --> 00:17:16.150
The reason why you don't want to do it is
because it's subject to race conditions.

00:17:16.150 --> 00:17:19.410
Your file can be deleted and replaced for example.

00:17:19.410 --> 00:17:23.680
It can be substituted with a link and your program
will follow the link and so on and so forth.

00:17:23.680 --> 00:17:28.680
Also, an unprivileged user can simply
destroy the file if they want to,

00:17:28.680 --> 00:17:31.690
which is not good for your application stability.

00:17:31.690 --> 00:17:36.860
What you want to do instead, again, you want to have a
background service that your application can make calls

00:17:36.860 --> 00:17:44.270
to when it runs as any user that will edit a file under the
hood and you don't want to have that file be world-writable.

00:17:44.270 --> 00:17:48.060
Next, I'm going to talk a little bit about bounds checking.

00:17:48.060 --> 00:17:51.750
So bounds checking is a classic
defensive programming technique

00:17:51.750 --> 00:17:55.500
and it's designed to stop buffer overflow vulnerabilities.

00:17:55.500 --> 00:18:00.490
Buffer overflow is a bug where you have a piece of data
that's too large for the memory buffer you've allocated

00:18:00.490 --> 00:18:04.320
into it and your application attempts to copy it anyway.

00:18:04.320 --> 00:18:10.360
So you have to perform a lot of sanity checks
on any kind of untrusted or unvalidated input,

00:18:10.360 --> 00:18:13.540
things that come off the network from files and so on.

00:18:13.540 --> 00:18:17.120
And you have to use the safe string functions.

00:18:17.120 --> 00:18:30.260
The safe string functions are listed here for you, things
like strlcat, strlcpy, snprintf and vsnprintf, and fgets.

00:18:30.260 --> 00:18:37.760
Also the functions that we recommend you avoid using
are on the left under the X here, strcat, strcpy.

00:18:37.760 --> 00:18:42.400
Now you may be surprised to see
strncat and strncpy on that list.

00:18:42.400 --> 00:18:48.600
Gee, I thought those were bounded functions and they are
but they're bounded in such a way that makes it really easy

00:18:48.600 --> 00:18:52.920
to introduce security bugs and we'll
show you that on the next slide.

00:18:52.920 --> 00:19:00.500
But also on the list are obvious suspects like
sprintf and vsprintf, and of course the gets function,

00:19:00.500 --> 00:19:04.920
which is the source of one of the oldest
compiler warnings in the book for security.

00:19:04.920 --> 00:19:09.990
Now to give you an example of what I mean and
why we don't recommend you use this strncpy

00:19:09.990 --> 00:19:12.980
and strncat functions, consider this example.

00:19:12.980 --> 00:19:17.120
Here we have a 5 byte destination
buffer and a 6 byte string.

00:19:17.120 --> 00:19:21.530
Obviously, if we copy the entire string into the
destination buffer, we're going to cause an overflow.

00:19:21.530 --> 00:19:23.110
This is not good.

00:19:23.110 --> 00:19:27.440
So here we have three prospective copies that we can make.

00:19:27.440 --> 00:19:33.080
Of this source string into this
destination buffer one, using each function.

00:19:33.080 --> 00:19:35.230
First let's look at strcpy.

00:19:35.230 --> 00:19:38.940
Notice how it copies right on pass the end of the buffer.

00:19:38.940 --> 00:19:44.100
So you've just corrupted memory and potentially
allowed an attacker to execute arbitrary code.

00:19:44.100 --> 00:19:49.840
Not good. Now let's look at strncpy and see what it does.

00:19:49.840 --> 00:19:53.610
Notice how it copies 5 bytes but the last byte is the E.

00:19:53.610 --> 00:19:55.770
There's no null terminator.

00:19:55.770 --> 00:19:58.950
That's not good either because the
next time you manipulate that string,

00:19:58.950 --> 00:20:00.660
you're going to get a read right off the end of it.

00:20:00.660 --> 00:20:03.580
And you may even introduce an exploitable security hole.

00:20:03.580 --> 00:20:05.740
Now let's look at what strlcpy does.

00:20:05.740 --> 00:20:10.870
You can see it also copies only 5 bytes, but the
last byte is the null terminator so that you end

00:20:10.870 --> 00:20:13.920
up with a properly terminated string
and this is why we recommend

00:20:13.920 --> 00:20:17.770
that you use strlcpy instead of
strncpy and strcat and strlcat.

00:20:17.770 --> 00:20:22.590
Next let's cover a little bit about integer overflows.

00:20:22.590 --> 00:20:27.060
Now, an integer overflow occurs when an
arithmetic operation produces a value that's larger

00:20:27.060 --> 00:20:28.480
than an integer type can hold.

00:20:28.480 --> 00:20:31.330
Now that's a big complicated dictionary definition.

00:20:31.330 --> 00:20:33.800
So let's explain it with a little bit of code.

00:20:33.800 --> 00:20:39.230
Here, we have a structure that has an N entries
value in it, that is potentially hostile.

00:20:39.230 --> 00:20:41.410
We'll say it came from the network.

00:20:41.410 --> 00:20:47.000
And then we have an NSData initializer
which says dataWithLength, N entries times,

00:20:47.000 --> 00:20:50.140
you know, this size up here which is a constant.

00:20:50.140 --> 00:20:54.680
Now if that N entries is really,
really large that integer will overflow

00:20:54.680 --> 00:21:00.360
and the allocation will be unexpectedly
small then the memcpy down here which is done

00:21:00.360 --> 00:21:04.630
in a loop will copy right on past
the end of the allocated buffer.

00:21:04.630 --> 00:21:11.140
To show you exactly why that happens, here's an example
of what we get if we specify a particular large value.

00:21:11.140 --> 00:21:15.770
And you can see we have an editor
here that has 33 significant bits.

00:21:15.770 --> 00:21:22.670
So the 1 that would be at the high end of that integer
simply gets truncated away and we end up with a four

00:21:22.670 --> 00:21:27.480
by allocation and into which we're
copying tens of millions of entries.

00:21:27.480 --> 00:21:29.430
That's not good.

00:21:29.430 --> 00:21:34.300
So what we recommend that you do to avoid
integer overflows is use our checkint API

00:21:34.300 --> 00:21:37.270
which has been available since Leopard.

00:21:37.270 --> 00:21:42.840
So you can see the code now includes the
checkint.h but the meat of it is down here

00:21:42.840 --> 00:21:50.250
where we have this check_uint32_mul function which
will set an error condition bit in the error value

00:21:50.250 --> 00:21:54.310
if the multiplication results in an overflow.

00:21:54.310 --> 00:21:59.550
Now you can see it says CHECKINT_NO_ERROR
here so we can succeed.

00:21:59.550 --> 00:22:02.570
Now we know this multiplication was safe.

00:22:02.570 --> 00:22:04.860
So that's integer overflows.

00:22:04.860 --> 00:22:10.090
Now I can give you a little bit of background on
how to test your application through security.

00:22:10.090 --> 00:22:12.700
Now, there're obviously two components of testing.

00:22:12.700 --> 00:22:16.170
One of which is manual auditing and
David will cover a little bit more

00:22:16.170 --> 00:22:18.490
about manual auditing in his section of the talk.

00:22:18.490 --> 00:22:22.480
But I want to give you some useful automated testing tools.

00:22:22.480 --> 00:22:25.820
So we're going to cover two different type of tools.

00:22:25.820 --> 00:22:29.960
We're going to cover static analysis
and we're going to cover fuzzing.

00:22:29.960 --> 00:22:33.040
So the Developer Tools include a static analyzer for you.

00:22:33.040 --> 00:22:38.100
You can run it with Build and Analyze menu item in Xcode.

00:22:38.100 --> 00:22:41.950
Checks your code for some really
common bugs, memory management issues,

00:22:41.950 --> 00:22:44.520
things like reference counting, that sort of thing.

00:22:44.520 --> 00:22:49.160
A small subset of buffer overflows, it
won't catch them all, which is important

00:22:49.160 --> 00:22:55.130
and some non-security bugs, things
like dead stores and so on.

00:22:55.130 --> 00:23:02.300
There's really detailed warnings when it finds a bug that
help you document the data flow through your application.

00:23:02.300 --> 00:23:09.950
The rules aren't very detailed yet, but we're
improving them with each updates the Developer Tools.

00:23:09.950 --> 00:23:14.140
So you can see an example here of
where the analyzer has found a bug.

00:23:14.140 --> 00:23:23.860
I have an NSString value that I don't initialize and I pass
to NSLog and then I built my code with Build and Analyze.

00:23:23.860 --> 00:23:28.420
So Build and Analyze has flagged this and said,
"Hey, you declared this but didn't initialize it

00:23:28.420 --> 00:23:30.970
and then you passed it to a by value function.

00:23:30.970 --> 00:23:36.680
Now this example is obviously pretty contrive
but the analyzer can catch some more details

00:23:36.680 --> 00:23:40.490
and more sophisticated example of this same type of bug.

00:23:40.490 --> 00:23:44.160
So the important thing about the analyzer
is that we recommend you use it often.

00:23:44.160 --> 00:23:48.140
If you run it all the time, you're going
to catch any new bugs that you introduced,

00:23:48.140 --> 00:23:51.570
at least bugs that the analyzer, again, has rules to catch.

00:23:51.570 --> 00:23:52.690
So that's important.

00:23:52.690 --> 00:23:54.040
Also, we keep adding rules.

00:23:54.040 --> 00:23:55.710
So even if your code isn't changing.

00:23:55.710 --> 00:24:00.650
It's important that you run this periodically
to get the benefit of the new rules.

00:24:00.650 --> 00:24:03.290
There's a project configuration option that you can use

00:24:03.290 --> 00:24:07.930
that will let you run the analyzer
with every build of your project.

00:24:07.930 --> 00:24:10.380
And you can see that here in this screen shot.

00:24:10.380 --> 00:24:14.860
In the build options, there's a pretty self
explanatory option called the Runs Static Analyzer

00:24:14.860 --> 00:24:20.150
and you can see I have checked it in my project
which has made it turn fold because it's non-default.

00:24:20.150 --> 00:24:25.990
But when I build my project now,
the analyzer will run automatically.

00:24:25.990 --> 00:24:31.480
Other important class of automated testing for
you to be doing with your software is fuzzing.

00:24:31.480 --> 00:24:34.440
So fuzzing is where you subtly alter valid program inputs.

00:24:34.440 --> 00:24:40.070
If I have data that comes from a file or from
the network, great candidates for fuzzing.

00:24:40.070 --> 00:24:46.040
It doesn't have to complicated, change a bit
here, right there, a couple of bytes there,

00:24:46.040 --> 00:24:50.850
you've got a fuzz file that could
potentially cause havoc in your application.

00:24:50.850 --> 00:24:55.960
And as you might guess, the most likely thing that your
application is going to do if you find a bug is crash.

00:24:55.960 --> 00:24:59.970
So if it crashes, there you go, you found a bug.

00:24:59.970 --> 00:25:04.850
And our CrashWrangler tool can help you prioritize
to determine which of those bugs are important

00:25:04.850 --> 00:25:08.430
for you or most important for you to fix.

00:25:08.430 --> 00:25:14.090
So you can run CrashWrangler with either crash logs
or with a live target and that is an application,

00:25:14.090 --> 00:25:16.990
it's running and it's being hit with data.

00:25:16.990 --> 00:25:23.710
And it has a heuristic for identifying exploitable
bugs things like out of bounds rights, double freeze,

00:25:23.710 --> 00:25:27.360
so on so forth, from nonexploitable simple crashes.

00:25:27.360 --> 00:25:31.660
Things like null pointer to your references and the like.

00:25:31.660 --> 00:25:38.210
And you can download it from the Apple Developer website
at connect.apple.com you just search for CrashWrangler.

00:25:38.210 --> 00:25:42.600
And it's available for you to use today.

00:25:42.600 --> 00:25:47.470
So we've covered three of the four
pieces of the security life cycle.

00:25:47.470 --> 00:25:51.190
We've covered design, we've covered
code and we've covered testing.

00:25:51.190 --> 00:25:58.760
And now I want to hand it over to David for a little
more detail on practical applications of these things

00:25:58.760 --> 00:26:02.560
and what you can do with Cocoa and Objective-C specifically.

00:26:02.560 --> 00:26:05.990
[ Applause ]

00:26:05.990 --> 00:26:09.790
>> Hi I'm David Remahl and I'm a product security engineer.

00:26:09.790 --> 00:26:13.940
I think it will be instructive to
try to apply some of the techniques

00:26:13.940 --> 00:26:17.630
that Matt has talked about to a real world application.

00:26:17.630 --> 00:26:22.770
And the application we'll be talking
about today is called Naivete.

00:26:22.770 --> 00:26:29.500
It's a magical and revolutionary feed reader for Atom feeds.

00:26:30.810 --> 00:26:37.090
It supports some of the Atom feeds on the
web, it's not perfect yet, it's a version 1.0.

00:26:37.090 --> 00:26:44.160
It has a ground breaking feature that's an industry first,
it's document-based using the Cocoa document architecture.

00:26:44.160 --> 00:26:49.860
It opens this new URL format that we've invented naive:.

00:26:49.860 --> 00:26:55.970
It has a gorgeous icon and if it
crashes that's a feature not a bug.

00:26:55.970 --> 00:27:01.810
Now I don't anticipate that the App
Store reviewers will take that excuse.

00:27:01.810 --> 00:27:12.730
And that's why we've put this program app on the sample
code sites for WWDC as an example of code not to write.

00:27:12.730 --> 00:27:17.000
So now I want to demo some of the
features of this application.

00:27:17.000 --> 00:27:19.630
Let's start it here from the dark.

00:27:19.630 --> 00:27:25.460
It opens up a blank document, and it
has these bookmarks pop-up where we can

00:27:25.460 --> 00:27:30.100
for example load the hot news feed from apple.com.

00:27:30.100 --> 00:27:35.020
Here we go, it's a simple RSS reader or Atom in this case.

00:27:35.020 --> 00:27:38.120
You select the stories in the source list here.

00:27:38.120 --> 00:27:49.620
It even supports sorting on the dates or the title
and if you hit a link it will open it up in Safari.

00:27:49.620 --> 00:27:58.270
I also prepared a feature feed that demonstrates
some other unique features of this application.

00:27:58.270 --> 00:28:04.510
It supports HTML5 and the proof of that is this.

00:28:04.510 --> 00:28:10.040
[ Laughter ]

00:28:10.040 --> 00:28:15.330
>> If you load an Atom feed that contains a
podcast file it supports downloading that so

00:28:15.330 --> 00:28:23.750
if I hit download here you'll see the podcast file arrived
in my Downloads folder and that works for pictures as well.

00:28:23.750 --> 00:28:29.150
Oh, I forgot to show you the document support.

00:28:29.150 --> 00:28:31.230
If I save this--

00:28:32.510 --> 00:28:38.190
[ Pause ]

00:28:38.190 --> 00:28:44.980
>> Here's the file, if we close this
you'll be right back at this feed.

00:28:46.120 --> 00:28:53.570
Now let's go back to the slides and think
about the security of this application.

00:28:53.570 --> 00:28:57.830
So as we're going through this part
of the presentation we'll be filling

00:28:57.830 --> 00:29:01.310
out this security scorecard for the application.

00:29:01.310 --> 00:29:06.310
I'll be returning to this periodically
and will see how it fairs.

00:29:06.310 --> 00:29:10.680
It's important when you're developing
an application as early as possible,

00:29:10.680 --> 00:29:18.570
at the design phase to understand the attacks and the
environment that your application will be exposed to.

00:29:18.570 --> 00:29:20.880
And we call this the attack surface.

00:29:20.880 --> 00:29:26.830
And one way of understanding the attack surface is
to enumerate the entry points to the application.

00:29:26.830 --> 00:29:29.850
In this case we have the naive: URLs.

00:29:29.850 --> 00:29:37.530
If I click on a naive link in Safari, it
will open up that feed in the application.

00:29:37.530 --> 00:29:46.350
Documents, users love to share documents among each other
so that's a way that an attacker might attack the user.

00:29:46.350 --> 00:29:53.900
Feeds of course are downloaded from the web and could
potentially be used in attacks against the application.

00:29:53.900 --> 00:29:57.650
And finally in this case, we support enclosures.

00:29:59.300 --> 00:30:08.320
In order to understand the attacks that might be used
against us, one way is to enumerate the APIs that we use.

00:30:08.320 --> 00:30:12.650
In this case, the stories are loaded in the WebView.

00:30:12.650 --> 00:30:16.100
It's-- you need to know that a WebView--
that the entire security modeling

00:30:16.100 --> 00:30:19.770
of the WebView is based on the document origin.

00:30:19.770 --> 00:30:28.640
Since this deals with HTML and other web formats,
we need to be concerned with cross-site scripting.

00:30:28.640 --> 00:30:36.420
This is normally an issue that web application
developers or browser vendors are tasked to solve.

00:30:36.420 --> 00:30:43.450
But when we make connected applications that embed WebViews
for either for internal use or for viewing web contents,

00:30:43.450 --> 00:30:52.000
then cross-site scripting becomes important to
desktop or iPhone iOS application developers.

00:30:52.000 --> 00:30:57.120
External links, we, of course, need to be
careful when we're dealing with those.

00:30:57.120 --> 00:31:00.460
And we could fill an entire session on WebKit security.

00:31:00.460 --> 00:31:05.060
So this will be some of the things we focus on today.

00:31:05.060 --> 00:31:12.410
URL handlers naturally have to be written to expect
some malicious input and do careful input validation.

00:31:12.410 --> 00:31:16.940
And we also need-- for the documents, we
need to think about the serialization format

00:31:16.940 --> 00:31:20.720
and make sure that that's aptly chosen to be secure.

00:31:20.720 --> 00:31:28.260
And as Matt has often referred you to the Secure
Coding Guide, this is where you will find the source

00:31:28.260 --> 00:31:32.730
of security concentrations for the APIs that you are using.

00:31:32.730 --> 00:31:37.290
So let's go back to the application and see
how it fares against some of these attacks.

00:31:37.290 --> 00:31:44.680
I've prepared an attack feed here that tests
some of the attacks we were talking about.

00:31:44.680 --> 00:31:52.640
So as you've seen, the application
handles links from feed contents.

00:31:52.640 --> 00:31:57.650
But what if someone would try to link
to an application on the local disk?

00:31:57.650 --> 00:32:02.760
I've prepared this item here, and when I
click this link, we will see what happens.

00:32:02.760 --> 00:32:09.260
Uh-oh. That launched the application, and that's
probably not something we intended in this application

00:32:09.260 --> 00:32:13.380
because we wanted it to open up in Safari.

00:32:13.380 --> 00:32:16.670
So we've found a bug.

00:32:16.670 --> 00:32:20.160
Let's go to the code and fix that.

00:32:20.160 --> 00:32:28.760
So when the user clicks on a link in the
WebView, this Web Policy Delegate gets evoked.

00:32:28.760 --> 00:32:35.250
And we see here that if the source of the
navigation was a user click, then we do this.

00:32:35.250 --> 00:32:40.190
We use NSWorkspace openURL to open the URL of the request.

00:32:40.190 --> 00:32:48.580
And if you read the NSWorkspace documentation,
you'll see that openURL has a dual purpose.

00:32:48.580 --> 00:32:53.430
One is to open safe URLs like as HTTP or AFP.

00:32:53.430 --> 00:32:57.290
And another is to open local files.

00:32:57.290 --> 00:33:04.180
So it's one of the recommended APIs
for opening up a local document.

00:33:04.180 --> 00:33:11.880
In this case, we only want the safe case, and
we want to handle the file URLs separately.

00:33:11.880 --> 00:33:17.750
So I've written some code here
that addresses this vulnerability.

00:33:17.750 --> 00:33:23.140
We check whether the scheme of the
URL is equal to the file scheme.

00:33:23.140 --> 00:33:29.900
And if so, we select the file and the finder
instead of opening it up through NSWorkspace.

00:33:29.900 --> 00:33:32.510
So we build and run this.

00:33:32.510 --> 00:33:44.040
[ Pause ]

00:33:44.040 --> 00:33:49.340
>> Attacks, and now, the file gets
selected instead, which is what we want.

00:33:49.340 --> 00:33:52.780
There is a bug still in this code.

00:33:52.780 --> 00:33:58.170
I don't know if you spotted it, but here's a hint.

00:33:58.170 --> 00:34:00.190
Someone saw it?

00:34:00.190 --> 00:34:06.220
So if the scheme starts with all capital
letters, then we still have a bug.

00:34:06.220 --> 00:34:11.710
And we could solve this by doing
a case insensitive comparison.

00:34:11.710 --> 00:34:20.770
But a better way is to use the NSURL API as
filed URL, which handles all these cases,

00:34:20.770 --> 00:34:24.170
regardless of capitalization or future changes or whatever.

00:34:24.170 --> 00:34:26.510
It will do the right thing.

00:34:26.510 --> 00:34:34.200
[ Pause ]

00:34:34.200 --> 00:34:36.670
>> Now we handle that case correctly too.

00:34:38.280 --> 00:34:45.180
I mentioned JavaScript injection
and the importance of the origin.

00:34:45.180 --> 00:34:52.400
In this case, I've wrote a great script that
tries to first print the origin of the document,

00:34:52.400 --> 00:34:55.520
and we see that it's served from an applewebdata URL.

00:34:55.520 --> 00:35:01.030
And then it tries to get the EDC
password database or any other local file.

00:35:01.030 --> 00:35:08.920
And since applewebdata live file is handled especially
by WebKit, it was allowed to get this database.

00:35:08.920 --> 00:35:11.160
And it could, potentially upload it to the web.

00:35:11.160 --> 00:35:16.510
In order to fix this we need to
do something about the origin.

00:35:16.510 --> 00:35:23.250
[ Pause ]

00:35:23.250 --> 00:35:31.040
>> So we're using this API loadHTMLString passing in the
feed contents, and then we pass and analyze the base URL.

00:35:31.040 --> 00:35:40.790
What we want to do is to pass in the URL of the original
feed, and that's available as this property on the document.

00:35:40.790 --> 00:35:44.510
So now, if we try this exploit again.

00:35:44.510 --> 00:35:49.210
[ Pause ]

00:35:49.210 --> 00:35:58.010
>> The origin is now an http: URL, and it was no longer
able to access the user database, which is what we want.

00:35:58.010 --> 00:36:03.270
The fourth attack I want to talk
about now is against enclosures.

00:36:03.270 --> 00:36:10.480
So I'm sure you've seen this feature in Safari
where it tags files with the download source.

00:36:10.480 --> 00:36:19.360
So when I downloaded this file in Safari, this is a shell
script, and when I start it, the user gets this warning.

00:36:19.360 --> 00:36:23.490
So if he wasn't expecting a shell
script, maybe an image or something,

00:36:23.490 --> 00:36:28.390
then he is alerted to that something, something is strange.

00:36:28.390 --> 00:36:32.210
Let's see if we get the same support from Naivete.

00:36:32.210 --> 00:36:33.510
Downloading closure

00:36:33.510 --> 00:36:40.060
[ Pause ]

00:36:40.060 --> 00:36:42.050
>> Running arbitrary code.

00:36:42.050 --> 00:36:42.730
>> Yeah, so--

00:36:42.730 --> 00:36:43.950
[ Laughter ]

00:36:43.950 --> 00:36:49.500
>> This shell script just ran without
warning the user at all.

00:36:49.500 --> 00:36:51.280
Fortunately, the face is very simple.

00:36:51.280 --> 00:36:56.510
You just go into the info.plist
and check the file quarantine flag.

00:36:56.510 --> 00:37:14.090
[ Pause ]

00:37:14.090 --> 00:37:15.270
>> So, there is the warning.

00:37:15.270 --> 00:37:18.690
If every bug was this easy to fix, we'd all be out of work.

00:37:18.690 --> 00:37:19.200
[ Laughter ]

00:37:19.200 --> 00:37:26.510
>> So let's go back to the slides
and look at the Score Card.

00:37:26.510 --> 00:37:30.540
Well, we had a fail for the Cross-Site Scripting initially.

00:37:30.540 --> 00:37:37.320
Local URLs, both of the applewebdata variety
and the file variety, were mishandled,

00:37:37.320 --> 00:37:42.070
and it didn't provide adequate protections against Trojans.

00:37:42.070 --> 00:37:49.600
File URLs are special, both to
the WebView and to NSWorkspace.

00:37:49.600 --> 00:37:55.380
And the lesson of this is partially to be
aware of that fact, but to read the document--

00:37:55.380 --> 00:38:03.400
API documentation of every API you are using and
understand the security consequences of the documentation.

00:38:03.400 --> 00:38:10.300
And finally, if your application downloads
files, you should be using file quarantine.

00:38:10.300 --> 00:38:19.150
And the simple info.plist fix provides most of the
security benefits, and it's very easy to turn on.

00:38:19.150 --> 00:38:24.640
But if you want to provide the user with even
more information, such as the source of the file,

00:38:24.640 --> 00:38:29.190
then you can use the Launch Services API on the slide.

00:38:29.190 --> 00:38:31.750
Next talk-- let's talk about file formats.

00:38:31.750 --> 00:38:37.810
You can consider file formats and documents from two levels.

00:38:37.810 --> 00:38:43.590
First, there's the semantic content, which is the
information that you want to encode in your document.

00:38:43.590 --> 00:38:51.080
And then there's the serialization format, which describes
how this semantic contents match the bytes on disk.

00:38:51.080 --> 00:38:55.100
So what signifies a secure serialization format?

00:38:55.100 --> 00:39:03.620
First of all, we want it to be simple and predictable
because security issues tend to thrive in complexity.

00:39:03.620 --> 00:39:08.750
We want the attack surface to be small,
and that means that we don't want--

00:39:08.750 --> 00:39:15.110
we want as few lines of code to be running basically,
because there will be fewer lines to have bugs in them.

00:39:15.110 --> 00:39:21.250
And we want to be sure that the format
parser was written to expect malicious input,

00:39:21.250 --> 00:39:27.040
or potentially malicious input, and
do the appropriate input audition.

00:39:27.040 --> 00:39:30.950
Now, I want to look at the format path that Naivete uses.

00:39:30.950 --> 00:39:37.750
So we already saved this features file, and I
happen to know that this is a property list.

00:39:37.750 --> 00:39:42.920
So we can view it in the Property List Editor.

00:39:42.920 --> 00:39:48.290
This first line is a cue-- is a clue to
what format the application is using.

00:39:48.290 --> 00:39:54.600
It's says NSKeyedArchiver, and that means that
it's a Cocoa Archive using NSKeyedArchiving.

00:39:54.600 --> 00:40:04.300
Keyed archiving is a relatively complicated format
that can encode an arbitrary graph of objects.

00:40:04.300 --> 00:40:06.040
It's very easy to use.

00:40:06.040 --> 00:40:09.170
You just pass it the root object that you want to encode.

00:40:09.170 --> 00:40:18.820
But it has some curious properties that makes it
unsuitable for use as a general purpose document format.

00:40:18.820 --> 00:40:28.170
For example, here, we see the NSURL string, and you might
wonder, "What happens if I change this to some other class?"

00:40:28.170 --> 00:40:35.700
Let's use something that the application will not expect.

00:40:35.700 --> 00:40:42.630
So this means that any object that implements
initWithCoder, the NS coding protocol,

00:40:42.630 --> 00:40:48.970
will be exposed to potentially
malicious data coming from your document.

00:40:48.970 --> 00:41:03.080
And we can see what happens if we open up this document
that I prepared that replaces the URL with a button.

00:41:03.080 --> 00:41:08.190
In this case, we just got some warnings
about an unrecognized selective being sent

00:41:08.190 --> 00:41:10.720
to the object, because the code was expecting an NSURL.

00:41:10.720 --> 00:41:13.130
It found an NSButton.

00:41:13.130 --> 00:41:23.220
This can be-- get worse, and I'm just experienced
log message a document that doesn't load.

00:41:23.220 --> 00:41:29.180
And I won't show you the details on how
this works, but this document managed

00:41:29.180 --> 00:41:35.090
to start an application that could have run any code.

00:41:35.090 --> 00:41:41.930
So the fix we want to apply in this case,
is to replace the serialization format.

00:41:41.930 --> 00:41:45.220
And it started out looking pretty good.

00:41:45.220 --> 00:41:46.520
This was a Property List.

00:41:46.520 --> 00:41:49.610
And Property Lists are fine to use for untrusted input.

00:41:49.610 --> 00:41:53.760
The problem was that it was a keyed archive.

00:41:53.760 --> 00:41:59.510
So we will replace this document
serialization code and loading code with--

00:41:59.510 --> 00:42:05.070
[ Pause ]

00:42:05.070 --> 00:42:10.510
>> With some code that uses just
a plain property list instead.

00:42:10.510 --> 00:42:22.050
[ Pause ]

00:42:22.050 --> 00:42:33.540
>> So if we open this up in Property List
Editor, we'll see a much simpler hierarchy here,

00:42:33.540 --> 00:42:37.090
encoding just the information that we wanted to contain.

00:42:37.090 --> 00:42:43.210
And there are no class names to replace, for example.

00:42:44.930 --> 00:42:52.520
So for the document serialization, it was another X because
it allowed arbitrary code execution from a document.

00:42:54.400 --> 00:42:59.980
So, some of the formats that are safe to use, if
you use them correctly, are XML Property List,

00:42:59.980 --> 00:43:04.510
Binary Property Lists, and spotless serialization basically.

00:43:04.510 --> 00:43:09.900
There is NSXML which is made to deal with untrusted XML,

00:43:09.900 --> 00:43:14.250
and Core Data is also appropriate as
a general purpose document format.

00:43:14.250 --> 00:43:18.500
So you should use these for your
document formats, your natural protocols,

00:43:18.500 --> 00:43:23.190
and other cases when you share
data across privileged boundaries.

00:43:23.190 --> 00:43:29.130
There are some things you shouldn't use, and we've
already talked about the NSArchiver and NSKeyedArchiver.

00:43:29.130 --> 00:43:36.240
And if you're using this class, it's way overdue
to be replaced because it was deprecated in 10.2.

00:43:36.240 --> 00:43:42.610
These APIs, with the exception on NSSerialization, might
still be appropriate to use in your internal storage,

00:43:42.610 --> 00:43:49.130
like preference files, or if you're doing something
similar to Interface Builder with frozen code,

00:43:49.130 --> 00:43:52.700
or if you have an IPC connection where you're passing--

00:43:52.700 --> 00:44:00.440
serializing data to pass across a connection
where there's no real trust boundary.

00:44:00.440 --> 00:44:05.770
Now, let's move on to the code
part of the development cycle.

00:44:05.770 --> 00:44:11.090
And connect cleanups in here.

00:44:13.170 --> 00:44:28.220
So first, we'll use the Build and Analyze menu item to see
if the static analyzer will catch any bugs for free for us.

00:44:30.210 --> 00:44:34.720
So we got one warning and one static analyzer warning.

00:44:34.720 --> 00:44:37.420
Let's start with the warning.

00:44:37.420 --> 00:44:47.140
In this case, we're calling NSLog in
the handler for the naivete: URL format.

00:44:47.140 --> 00:44:53.420
And we're taking the URL and passing
it as the first argument to NSLog.

00:44:53.420 --> 00:44:55.710
NSLog takes a format string.

00:44:55.710 --> 00:45:04.820
And format strings are some of the oldest
and most obnoxious security bugs out there.

00:45:04.820 --> 00:45:09.870
In C, they are usually exploited using the %n specifier.

00:45:09.870 --> 00:45:12.530
Cocoa does not support %n.

00:45:12.530 --> 00:45:19.290
But what it does support is the
%at operator which sends a message.

00:45:19.290 --> 00:45:25.510
So first, I'll show an example of how this bug can trigger.

00:45:25.510 --> 00:45:36.140
[ Pause ]

00:45:36.140 --> 00:45:38.710
>> Actually, I will show you that later on a different bug.

00:45:38.710 --> 00:45:45.170
The problem with sending messages
to an object off of the stack

00:45:45.170 --> 00:45:50.250
when we are not passing any object
beyond the first parameter here,

00:45:50.250 --> 00:45:57.410
so it will just take some random value off the stacks,
send as message, and when Objective-C message send picks

00:45:57.410 --> 00:46:04.660
up that pointer, it does a series of pointer references,
and finally arrives at the IMP which is a function pointer.

00:46:04.660 --> 00:46:13.630
And if the attacker is able to control any of these pointers
along that path that Objective-C message send traverses,

00:46:13.630 --> 00:46:19.230
then he might be able to point execution
to his code, which would obviously be bad.

00:46:19.230 --> 00:46:21.750
The fix is very simple.

00:46:21.750 --> 00:46:29.180
We just use a static string as format specifier and
pass the document-- the object that we want to print.

00:46:29.180 --> 00:46:30.740
That is the second one.

00:46:30.740 --> 00:46:36.830
Or in this case, it is just debug codes so we can remove it.

00:46:36.830 --> 00:46:39.370
Remove your debug code before shipping.

00:46:39.370 --> 00:46:50.680
The other warning we need to-- run the analyzer again.

00:46:50.680 --> 00:46:54.060
Here's the analyzer warning.

00:46:54.060 --> 00:46:57.150
We get an error on the return line here.

00:46:57.150 --> 00:47:03.710
It says that an object had order release sent too
many times, and of course, this is a stupid bug.

00:47:03.710 --> 00:47:09.840
I called order release on an object
that was returned already, or released.

00:47:09.840 --> 00:47:11.630
Fix is very simple.

00:47:11.630 --> 00:47:19.290
As Matt mentioned, the static analyzer will catch a
lot, but it definitely would not catch everything.

00:47:19.290 --> 00:47:24.340
Actually, there is another format
string vulnerability on this line,

00:47:24.340 --> 00:47:28.330
and that is what I wanted to show you a minute ago.

00:47:28.330 --> 00:47:37.710
When I load this format string URL, it contains some %x
specifiers that's translated into random data off the sack

00:47:37.710 --> 00:47:41.100
in this very dialog when we are using NSAlert.

00:47:41.100 --> 00:47:50.900
And as an example, when that causes a potential security
vulnerability, if we are using this %at specifier, yep,

00:47:50.900 --> 00:47:56.400
we got a crash, and the debugger has broken.

00:47:56.400 --> 00:47:58.810
That's bad.

00:47:58.810 --> 00:48:01.310
The fix though is as simple.

00:48:01.310 --> 00:48:06.190
Just like that.

00:48:06.190 --> 00:48:12.630
The order release case was a reference counting mistake.

00:48:12.630 --> 00:48:16.620
And reference counting mistakes can become pretty hairy.

00:48:16.620 --> 00:48:28.850
And one example of that is when I'm using NSURLConnection
in this document, I set the document as the delegates.

00:48:28.850 --> 00:48:35.950
And as you will know, if you have read NSURLConnections
documentation, the connection retains its delegate.

00:48:35.950 --> 00:48:45.840
So even if the user closes the document, the object--
if the URLConnection finishes or causes an error,

00:48:45.840 --> 00:48:50.890
the object will still be around to get that message.

00:48:50.890 --> 00:48:52.670
So we should be OK.

00:48:52.670 --> 00:49:02.680
So let's see what happens if we try to connect
to a fake web server here that will just hang.

00:49:02.680 --> 00:49:05.510
We have the spinner here showing
that something is happening.

00:49:05.510 --> 00:49:14.100
The user gets impatient, closes the
window, and then this connection closes.

00:49:14.100 --> 00:49:16.170
Ah,we crashed.

00:49:16.170 --> 00:49:16.950
Why did we crash?

00:49:16.950 --> 00:49:19.500
The document is still around.

00:49:19.500 --> 00:49:25.530
And indeed, the document did get the
message about the connection failing.

00:49:25.530 --> 00:49:31.630
The problem is that when the window was closed,
the-- any IBOutlets to that window got invalid,

00:49:31.630 --> 00:49:40.120
because the IBOutlets are typically-- unless you have
retained them specifically-- they're weak references.

00:49:40.120 --> 00:49:46.460
So when we're sending a message to this
release progress indicator, we get a bug.

00:49:46.460 --> 00:49:51.930
And again, if the attacker is able to fill
the address space with malicious data,

00:49:51.930 --> 00:49:54.290
he might be able to highjack execution here.

00:49:54.290 --> 00:50:00.200
The solution in this case is too complicated
to show in a demo, but it involves making sure

00:50:00.200 --> 00:50:08.660
that the connection gets canceled before
any referenced objects get released.

00:50:08.660 --> 00:50:13.180
And as I mentioned, this code is all up
on the [inaudible] site of sample code.

00:50:13.180 --> 00:50:17.260
So, there are some vulnerabilities
that I won't be able to show you today

00:50:17.260 --> 00:50:26.880
but if you're curious, you can
look at them in the sample code.

00:50:26.880 --> 00:50:33.380
So, format strings and reference counting, another X there.

00:50:33.380 --> 00:50:36.980
Static analyzing your code is a great aid.

00:50:36.980 --> 00:50:40.120
It will find some bugs but it definitely
won't catch everything.

00:50:40.120 --> 00:50:45.250
So you need to stay vigilant and
make sure that you code correctly.

00:50:45.250 --> 00:50:48.330
Be careful with format strings.

00:50:48.330 --> 00:50:52.910
It's very easy to-- whenever you don't
pass a static string as a format string,

00:50:52.910 --> 00:50:56.460
it's likely that there might be a vulnerability there.

00:50:56.460 --> 00:51:04.980
And the complier will give you warnings in most cases but
not all format string methods and functions are annotated.

00:51:04.980 --> 00:51:08.290
And reference counting and weak references are hard.

00:51:08.290 --> 00:51:14.060
It's easy to get mixed up, especially
around the edge cases like in this case

00:51:14.060 --> 00:51:19.210
when the download hang and the user close the document.

00:51:19.210 --> 00:51:22.270
Using Garbage Collection on the Mac might help.

00:51:22.270 --> 00:51:29.300
On the other hand, it might introduce other
edge cases and it's not available on the phone.

00:51:29.300 --> 00:51:33.760
Next apply-- let's play some fuzzing
techniques that Matt talked about.

00:51:33.760 --> 00:51:41.150
It's a very simple and effective technique
and I wrote a fuzzer for a general--

00:51:41.150 --> 00:51:46.190
in generic fuzzer for binary and XML
property list in less than an hour.

00:51:46.190 --> 00:51:50.100
It's about a hundred lines of code really simple Python.

00:51:50.100 --> 00:51:56.830
It enumerates a plist and at each element, it
does the number of permutations to it to try

00:51:56.830 --> 00:52:03.990
to confuse the application that
will later be reading on the file.

00:52:03.990 --> 00:52:12.660
And I won't be doing that now but you can run it
with CrashWrangler in order to find duplicate crashes

00:52:12.660 --> 00:52:16.970
or to determine whether they are
likely to be exploitable or not.

00:52:16.970 --> 00:52:24.520
So, I'll just quickly run this fuzzer against
one of our documents that we've created.

00:52:26.810 --> 00:52:30.660
This is also available at sample code for this session.

00:52:30.660 --> 00:52:36.330
And it's easy to run.

00:52:36.330 --> 00:52:44.200
So now you'll see that it created 20 files here that
are all subtle variations of the original document.

00:52:44.200 --> 00:52:51.510
And when I open them up, you'll see some perhaps
unexpected behavior from-- we're still crashed.

00:52:51.510 --> 00:53:01.010
[ Pause ]

00:53:01.010 --> 00:53:01.730
[ Laughter ]

00:53:01.730 --> 00:53:08.070
>> Yeah, so some of these were not expected

00:53:08.070 --> 00:53:15.830
and I think there are some log messages
emitted about in other selectors being invoked.

00:53:15.830 --> 00:53:24.470
So there are other vulnerabilities in this
code and they're all listed in the sample code.

00:53:24.470 --> 00:53:31.630
Fuzzing, spending an hour fuzzing this application would
have eliminated a number of security vulnerabilities.

00:53:32.820 --> 00:53:36.990
So, fuzzing is important and should
be part of your testing strategy

00:53:36.990 --> 00:53:40.390
and use multiple fuzzers because
they excel at different things.

00:53:40.390 --> 00:53:51.650
This one just generated a lot of valid XML, valid
properties XML but you will want to try some binary fuzzers

00:53:51.650 --> 00:54:00.330
and you want to try a fuzzer that focuses on boundary
values and maybe one that just does random permutations.

00:54:00.330 --> 00:54:06.040
And if you are developing a protocol,
then you might have a fuzzer that does--

00:54:06.040 --> 00:54:14.320
that has a deep understanding of the protocol and another
one that just does dumb manipulation of the traffic.

00:54:14.320 --> 00:54:21.270
You shouldn't only rely on fuzzing, of course. You should
also be writing unit tests and focus on the edge cases.

00:54:21.270 --> 00:54:27.560
Not the ones that the user will most often hit
but the ones that an attacker will focus on.

00:54:27.560 --> 00:54:32.850
Penetration testing, which is pretty much
what we started this part of the talk doing.

00:54:32.850 --> 00:54:38.310
Trying some different attacks and seeing
how the application responds to them.

00:54:38.310 --> 00:54:42.750
Even if you think you've mitigated the
vulnerability it doesn't hurt to verify it.

00:54:42.750 --> 00:54:49.350
So, in summary you should think about security
throughout the entire development process from design

00:54:49.350 --> 00:54:53.520
to code, to testing, and then post release.

00:54:53.520 --> 00:54:58.020
Be aware of the security properties of the API CUs.

00:54:58.020 --> 00:55:07.160
Read the Secure Coding Guide with the API DOCs, talk
to others and have a deep understanding of the APIs.

00:55:07.160 --> 00:55:11.590
Understand the attacks that affect your application space.

00:55:11.590 --> 00:55:18.430
So, in this case we were dealing with a feed reader
and the bugs we were looking at had a lot to do

00:55:18.430 --> 00:55:23.440
with cross-site scripting, URLs, input validation.

00:55:23.440 --> 00:55:25.940
Your application will be different.

00:55:25.940 --> 00:55:29.290
It might be running on different devices.

00:55:29.290 --> 00:55:36.890
It might be in a completely different problem space and
it's up to you to have a deep understanding of that space.

00:55:36.890 --> 00:55:42.530
And take advantage of the hardening
techniques and security APIs like key chained

00:55:42.530 --> 00:55:47.870
and content protection on the phone because why not?

00:55:47.870 --> 00:55:52.090
It might save your users from being exploited.

00:55:52.090 --> 00:55:56.580
What are some simple steps that you can go out and do today?

00:55:56.580 --> 00:55:59.470
First of all, you can visit the Dev Forum Security sections.

00:55:59.470 --> 00:56:04.230
There's a lot of helpful people there
that will answers your questions.

00:56:04.230 --> 00:56:13.160
Read the Secure Coding Guide if you haven't already
and run the static analyzer against your application.

00:56:13.160 --> 00:56:16.300
You might find one bug, you might find 20.

00:56:16.300 --> 00:56:19.470
It's definitely worth the time investment.

00:56:19.470 --> 00:56:21.850
And finally fuzz your application.

00:56:21.850 --> 00:56:28.400
Use one of the commercially available fuzzers or
write your own, it doesn't take a lot of work.

00:56:28.400 --> 00:56:35.310
And that will put you on the path to giving
your application a clean security score card.

00:56:35.310 --> 00:56:40.660
Here are some other sessions that
might be interesting to you for launchd

00:56:40.660 --> 00:56:46.820
or if you're writing network applications
specifically for iOS.

00:56:46.820 --> 00:56:53.450
And there's the iPhone securing your application
data session which might be interesting to you.

00:56:53.450 --> 00:56:53.760
Thank you.

00:56:53.760 --> 00:57:05.730
[ Applause ]

