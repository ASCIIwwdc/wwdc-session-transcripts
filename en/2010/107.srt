1
00:00:06,320 --> 00:00:07,910
>> Corbin Dunn: Hello.

2
00:00:07,910 --> 00:00:13,650
Welcome to Cocoa Tips and Tricks, where we're
going to talk about some cool Cocoa code.

3
00:00:13,650 --> 00:00:18,880
My name is Corbin Dunn, and I am a Cocoa
Software Engineer, and I work on the AppKit team.

4
00:00:18,880 --> 00:00:20,480
So what's this talk about?

5
00:00:20,480 --> 00:00:25,470
Well, we're going to have a bunch of little quick
tips and tricks on some neat Cocoa and AppKit things.

6
00:00:25,470 --> 00:00:27,320
It's focused mainly on AppKit classes.

7
00:00:27,320 --> 00:00:30,220
So if you're expecting something else,
well, this isn't the place to be.

8
00:00:30,220 --> 00:00:31,790
Hopefully you'll learn something new.

9
00:00:31,790 --> 00:00:33,380
That's the goal with this talk.

10
00:00:33,380 --> 00:00:37,120
Alright, so what are you going to learn
and what are we going to cover?

11
00:00:37,120 --> 00:00:43,430
Well, we're going to talk about some TableView tips,
nib tips, accessibility, image tips, document tips,

12
00:00:43,430 --> 00:00:46,870
PathControls, SplitViews, CollectionViews ... tons of stuff.

13
00:00:46,870 --> 00:00:48,250
So don't panic.

14
00:00:48,250 --> 00:00:52,680
We're going to actually have a lot
of little sample code tips and pieces

15
00:00:52,680 --> 00:00:56,610
that you can just take back home
and play with and big around with.

16
00:00:56,610 --> 00:01:02,020
It's associated with this session, so go ahead
and download it and play around with those.

17
00:01:02,020 --> 00:01:04,030
So let's jump right into it with some TableView tips.

18
00:01:04,030 --> 00:01:08,940
Links in a TableView.

19
00:01:08,940 --> 00:01:14,370
Something commonly requested is how do a get link inside
the TableView and make it work like a regular link?

20
00:01:14,370 --> 00:01:16,820
Well, let's talk about how to do that.

21
00:01:16,820 --> 00:01:20,850
Well, the first way is you actually use an
NSAttributedString to get it to look like a link

22
00:01:20,850 --> 00:01:24,110
and to have an actual URL embedded in it.

23
00:01:24,110 --> 00:01:29,600
Then if we're going to use a regular NSTextFieldCell,
we want it to work like a button, so we'll go ahead

24
00:01:29,600 --> 00:01:34,210
and overwrite some methods and do some custom tracking
to actually make it so you can click on the link

25
00:01:34,210 --> 00:01:37,580
and tell the delegate that link was clicked
on so the app can do whatever it wants.

26
00:01:37,580 --> 00:01:41,390
So how do you go ahead and create a link?

27
00:01:41,390 --> 00:01:42,310
Well, it's really easy.

28
00:01:42,310 --> 00:01:45,950
You'll just go ahead and create an
NSAttributedString, or in this case,

29
00:01:45,950 --> 00:01:48,920
an NSMutableAttributedString alloc initWithString,

30
00:01:48,920 --> 00:01:53,160
and the actual string you're passing
here is going to be the title link.

31
00:01:53,160 --> 00:01:56,720
Then the key to doing it is using the NSLinkAttributeName.

32
00:01:56,720 --> 00:01:57,930
You don't actually see this.

33
00:01:57,930 --> 00:02:01,860
It's just the NS URL embedded inside the AttributedString.

34
00:02:01,860 --> 00:02:04,770
Then you can actually set other
things to make it look like a link.

35
00:02:04,770 --> 00:02:09,570
You probably want it blue and underlined, so you
can use things like the ForegroundColorAttributeName

36
00:02:09,570 --> 00:02:14,550
and the NSUnderLineStyleAttributeName
to make it look like a link.

37
00:02:14,550 --> 00:02:18,520
Something important with this, I'm talking about how
to do it in tables, but it actually applies anywhere.

38
00:02:18,520 --> 00:02:22,370
So that's a great tip that you can use in just about
anywhere in your application where you want a link.

39
00:02:22,370 --> 00:02:28,590
So you have to have a custom cell to
make that link actually clickable.

40
00:02:28,590 --> 00:02:29,860
So how will you do that?

41
00:02:29,860 --> 00:02:35,880
There's a couple of methods you could override, such as the
end tracking, continue tracking and what not within a cell.

42
00:02:35,880 --> 00:02:40,200
But we're going to go ahead and override
trackMouse inRect ofView untilMouseUp.

43
00:02:40,200 --> 00:02:44,710
And this is in a sample code called
LinkTextFieldCell that you can download and play with.

44
00:02:44,710 --> 00:02:51,210
And we override this method because it passes some
information we want, like the cell frame and what not.

45
00:02:51,210 --> 00:02:54,070
So what we're going to do is we're going
to go ahead and call super trackMouse.

46
00:02:54,070 --> 00:02:58,300
So when you go ahead and click on that button or
that link, which we want it to work like a button,

47
00:02:58,300 --> 00:03:00,850
it's going to do all the tracking
of the mouse until you let go.

48
00:03:00,850 --> 00:03:06,630
And then at that point, sample code does a few more things,
like make sure you actually click on the link and the text.

49
00:03:06,630 --> 00:03:08,550
We're going to gloss over that
and look at the important details.

50
00:03:08,550 --> 00:03:13,750
So we're going to just grab the
AttributedStringValue from the cell and kind of extract

51
00:03:13,750 --> 00:03:16,770
that in this LinkAttributeName to get that link.

52
00:03:16,770 --> 00:03:17,780
So you have that link.

53
00:03:17,780 --> 00:03:21,940
You need to get this information from this
cell in the table back over to the delegate

54
00:03:21,940 --> 00:03:24,410
or data source so it can do something with it.

55
00:03:24,410 --> 00:03:27,320
So what's the best way to do that?

56
00:03:27,320 --> 00:03:29,700
Well, a great way of doing that is to use blocks.

57
00:03:29,700 --> 00:03:33,820
You can use them as like a Click
Handler, sort of like a target action,

58
00:03:33,820 --> 00:03:39,260
except the advantage of using a block is you can pass as
many parameters or additional information as you want.

59
00:03:39,260 --> 00:03:44,660
So in this case, in our Custom Cell, the LinkTextFieldCell,
we're going to add a Private Eye Bar called

60
00:03:44,660 --> 00:03:51,970
under bar LinkClickedHandler, picking a couple parameters,
the NSURL and the ID of the sender, which is the cell.

61
00:03:51,970 --> 00:03:55,580
We then go ahead and declare our property for it.

62
00:03:55,580 --> 00:03:57,350
And, again, it looks pretty much the same.

63
00:03:57,350 --> 00:04:01,490
The key thing to note here is that
we're using copy in this property.

64
00:04:01,490 --> 00:04:04,580
It's important to use copy when you're using blocks.

65
00:04:04,580 --> 00:04:06,330
Otherwise, things may not work as you expect.

66
00:04:06,330 --> 00:04:10,020
And we're going to talk a little
about this more in detail later.

67
00:04:10,020 --> 00:04:14,180
So now you have that LinkClickedHandler.

68
00:04:14,180 --> 00:04:18,150
Inside the cell, you actually will make sure
that's not nil, and then just go ahead and call it.

69
00:04:18,150 --> 00:04:23,330
So that's a really easy way of actually invoking an action.

70
00:04:23,330 --> 00:04:25,730
All right, so how do you set this cell up?

71
00:04:25,730 --> 00:04:28,130
If you're not familiar, this is a great tip here.

72
00:04:28,130 --> 00:04:32,750
Inside Interface Builder, control shift click, and it
shows you a little view hierarchy of what you clicked on.

73
00:04:32,750 --> 00:04:36,530
So then you can go ahead and select something
like the actual cell down there at the bottom.

74
00:04:36,530 --> 00:04:43,350
Here is a screen shot of it actually
selected in the nib, the LinkTextFieldCell.

75
00:04:43,350 --> 00:04:50,480
And once it's selected, you can actually see
in the Inspector, inside of Interface Builder,

76
00:04:50,480 --> 00:04:53,180
the identity tab has a little class section.

77
00:04:53,180 --> 00:04:56,760
And this is where you would actually
put your custom class in.

78
00:04:56,760 --> 00:04:59,050
In this case, we call it the LinkTextFieldCell.

79
00:04:59,050 --> 00:05:02,640
So that hooks the cell up to actually
use it inside Interface Builder.

80
00:05:02,640 --> 00:05:06,280
So you have your cell hooked up.

81
00:05:06,280 --> 00:05:11,720
How do you actually do the work you want
to do inside your delegate or data source?

82
00:05:11,720 --> 00:05:17,820
You'll probably implement something like
tableView willDisplayCell forTableColumn, -row,

83
00:05:17,820 --> 00:05:19,520
which hopefully you're pretty familiar with.

84
00:05:19,520 --> 00:05:24,060
And you can do things to make sure it's the
right kind of row and column that you want.

85
00:05:24,060 --> 00:05:28,550
And then you can actually just set the block
implementation right here in line, the LinkClickedHandler,

86
00:05:28,550 --> 00:05:30,660
which we call it when the user clicks on a link.

87
00:05:30,660 --> 00:05:31,950
You could do whatever you want in here.

88
00:05:31,950 --> 00:05:36,780
You could say have a link that opens up another
part of UI, or it could put up a dialogue.

89
00:05:36,780 --> 00:05:40,710
Or more typically, you're just going to want
to open that URL in the default application.

90
00:05:40,710 --> 00:05:44,390
So the easiest way to do that, and another great tip,

91
00:05:44,390 --> 00:05:51,410
is to just use NSWorkspace sharedWorkspace
openURL opens URL up in the default app.

92
00:05:51,410 --> 00:05:54,210
Really easy to do.

93
00:05:54,210 --> 00:05:56,960
All right, so those were a couple tips on how to use links.

94
00:05:56,960 --> 00:05:59,120
I'd like to bring Mark up on stage.

95
00:05:59,120 --> 00:06:03,660
>> Mark Piccirelli: So the first thing I want
to talk to you about today is NSDocument.

96
00:06:03,660 --> 00:06:07,800
And more specifically, overriding
NSDocument methods correctly.

97
00:06:07,800 --> 00:06:10,900
NSDocument has a lot of methods for overriding.

98
00:06:10,900 --> 00:06:13,030
It's a very customizable class.

99
00:06:13,030 --> 00:06:17,770
But I want to let you know that you should
try to override as little as possible.

100
00:06:17,770 --> 00:06:22,200
For example, don't override one of the
methods whose names start with save,

101
00:06:22,200 --> 00:06:28,680
when instead you could override something more
specific, like one of the methods that start with write.

102
00:06:28,680 --> 00:06:33,240
And if you want to find out like what
calls what, see the documentation.

103
00:06:33,240 --> 00:06:40,100
There's really great sequence diagrams in the section
called "Message Flow in the Document Architecture."

104
00:06:40,100 --> 00:06:43,110
And also, see the comments in the header
file, if you've never looked at them before.

105
00:06:43,110 --> 00:06:49,210
They are just full of details about what calls what and what
all the default and limitations of NSDocument methods do.

106
00:06:49,210 --> 00:06:53,750
And the reason I bring this up is because
we keep adding features to NSDocument.

107
00:06:53,750 --> 00:06:56,070
We're definitely not done working on it, that's for sure.

108
00:06:56,070 --> 00:07:05,220
And the less customization you do, the more
features we're able to inject into your application.

109
00:07:07,140 --> 00:07:12,250
As well as not overriding too much,
override NSDocument methods correctly.

110
00:07:12,250 --> 00:07:18,740
This is something I've seen the write and
save methods are passed the URL and type.

111
00:07:18,740 --> 00:07:21,230
But I've seen a lot of code that doesn't use them.

112
00:07:21,230 --> 00:07:28,820
I've seen instead code that invokes self fileURL
and self fileType and uses those values instead.

113
00:07:28,820 --> 00:07:34,040
And what's wrong with that is that the
way safe saving works in NSDocument,

114
00:07:34,040 --> 00:07:36,110
number one, it changes from release to release.

115
00:07:36,110 --> 00:07:40,520
So where we're asking you to write
your document during saving changes.

116
00:07:40,520 --> 00:07:46,070
And also because we do things like having you
save to a temporary folder and things like that.

117
00:07:46,070 --> 00:07:52,340
You've really got to pay attention to the URL that's
passed in, and also the type name that's passed in.

118
00:07:52,340 --> 00:07:58,160
And another thing, when you override write
methods, don't set values in write methods.

119
00:07:58,160 --> 00:08:01,040
Don't mutate your document unnecessarily.

120
00:08:01,040 --> 00:08:07,620
It works, but like not overriding too
much, it's sort of a future proof thing.

121
00:08:07,620 --> 00:08:11,970
It allows us to add features without
breaking your app, when you don't do that.

122
00:08:11,970 --> 00:08:15,360
Write methods should just write.

123
00:08:16,390 --> 00:08:21,490
So we added blocks in the last release of Mac OS 10.

124
00:08:21,490 --> 00:08:24,320
But AppKit still has a lot of methods that look like this.

125
00:08:24,320 --> 00:08:25,490
This is an NSDocument method.

126
00:08:25,490 --> 00:08:29,220
SaveDocumentWithDelegate didSaveSelector contextInfo.

127
00:08:29,220 --> 00:08:33,660
And, you know, we follow that pattern
everywhere that a class might show a sheet.

128
00:08:33,660 --> 00:08:39,840
And, you know, the work that the thing does
isn't necessarily done when the method returns.

129
00:08:39,840 --> 00:08:40,770
And that works great.

130
00:08:40,770 --> 00:08:44,070
But you have to add a method just
to find out when the work is done.

131
00:08:44,070 --> 00:08:48,020
So that's a little more coding that you might
not, you know, that you'd like to avoid.

132
00:08:48,020 --> 00:08:54,410
So with blocks, even though we haven't changed our API
yet, you can add a few generic methods and use them over

133
00:08:54,410 --> 00:08:57,660
and over again to make your stuff work with this pattern.

134
00:08:57,660 --> 00:09:03,800
And the way you do it, in a subclass NSDocument,
for instance, add a method like this one,

135
00:09:03,800 --> 00:09:06,330
document succeeded with completionHandler.

136
00:09:06,330 --> 00:09:11,800
And that follows the method signature that's
required of something that is passed to one

137
00:09:11,800 --> 00:09:13,850
of the saving methods or something like that.

138
00:09:13,850 --> 00:09:20,550
And as you can see, what it does, it's passed a block,
that is the context info, and it just invokes the block

139
00:09:20,550 --> 00:09:22,820
and it calls Block_release when it's done.

140
00:09:22,820 --> 00:09:27,740
And if you've written something like that, notice that's
a class method, by the way, because you want to, you know,

141
00:09:27,740 --> 00:09:31,770
when you're watching your own code work, you want to
make sure that something like that isn't touching any

142
00:09:31,770 --> 00:09:34,720
of your instance variables, just to cut
down on the number of things you have

143
00:09:34,720 --> 00:09:37,440
to pay attention to while you're debugging the testing.

144
00:09:37,440 --> 00:09:42,150
But a class method like that, you can reuse
it as is shown on the bottom of this slide.

145
00:09:42,150 --> 00:09:46,270
If you invoke something like saveDocumentWithDelegate,
you pass it the class,

146
00:09:46,270 --> 00:09:50,780
and then you pass it the method signature for that method.

147
00:09:50,780 --> 00:09:56,560
And then in the contextInfo, you call
Block_copy, passing that a block.

148
00:09:56,560 --> 00:09:57,810
And you can do whatever you want there.

149
00:09:57,810 --> 00:10:04,260
And that way, you keep the code that, you know, is executed
when saving is done really close to where saving is started.

150
00:10:04,260 --> 00:10:13,100
And the reason you have to Block_copy and Block_release
is because the types of the contextInfo are all void star,

151
00:10:13,100 --> 00:10:17,880
so there's no retaining or releasing going on there.

152
00:10:17,880 --> 00:10:22,060
Another bit of advice for apps that are
document based is use file packages.

153
00:10:22,060 --> 00:10:28,220
If you're inventing a new file format, for example, and
it's an application that allows the user to create documents

154
00:10:28,220 --> 00:10:32,370
that have great big attachments in them,
use file packages, which, you know,

155
00:10:32,370 --> 00:10:37,640
Mac OS 10's trick for making directories
look, to the user, just like files.

156
00:10:37,640 --> 00:10:40,890
So it'-- there's a lot of performance benefits to it.

157
00:10:40,890 --> 00:10:46,820
And the code in Cocoa that lets you use file
packages easily is the class NS file wrapper.

158
00:10:46,820 --> 00:10:52,020
It wasn't too popular before, but it got
a lot of improvement in Snow Leopard.

159
00:10:52,020 --> 00:10:55,750
It got modernized, using NSURLs
and NS errors and things like that.

160
00:10:55,750 --> 00:10:59,410
And also, we added this hard link optimization.

161
00:10:59,410 --> 00:11:05,670
So when safe saving is done by NSDocument, for
example, and it's writing the new revision onto disc,

162
00:11:05,670 --> 00:11:10,630
and then it's going to, you know, move that on
top of the old revision in one atomic operation,

163
00:11:10,630 --> 00:11:13,770
NS file wrapper is smart enough not to just, you know,

164
00:11:13,770 --> 00:11:16,900
rewrite the entire contents, all
the files of that file packages.

165
00:11:16,900 --> 00:11:18,330
It just makes hard links.

166
00:11:18,330 --> 00:11:20,660
So it's very quick.

167
00:11:20,660 --> 00:11:25,160
So check out the Mac OS 10.6 AppKit
release notes for information about that.

168
00:11:25,160 --> 00:11:26,400
There's a lot there.

169
00:11:26,400 --> 00:11:32,700
And the last thing I want to ask you to
do for NSDocument is turn on AutoSaving.

170
00:11:32,700 --> 00:11:34,130
We added this feature a while ago.

171
00:11:34,130 --> 00:11:34,570
It's great.

172
00:11:34,570 --> 00:11:40,940
It provides crash protection and also protection
against power losses and things like that.

173
00:11:40,940 --> 00:11:43,790
And, you know, a quick snippet of how
you turn it on is there's a single method

174
00:11:43,790 --> 00:11:46,900
in NSDocumentController called setAutosavingDelay.

175
00:11:46,900 --> 00:11:52,400
And what that sets is how long should the
document go unsaved after the user changed it?

176
00:11:52,400 --> 00:11:56,440
So check out the Mac OS 10.4 AppKit release notes for this.

177
00:11:56,440 --> 00:12:00,260
And, you know, along with the, you know,
paying attention to what you override

178
00:12:00,260 --> 00:12:02,820
in NSDocument, you know, that's for future proofing.

179
00:12:02,820 --> 00:12:05,000
This is actually also for a little bit of future proofing.

180
00:12:05,000 --> 00:12:08,330
If you make your application work
with this Autosaving feature,

181
00:12:08,330 --> 00:12:10,700
it's going to work with things we add in the future, too.

182
00:12:10,700 --> 00:12:15,800
And if you want an example of this,
Text Edit, of course, has Autosaving.

183
00:12:15,800 --> 00:12:22,400
So in the preferences, there is a simple little bit of UI
for just letting the user pick how often it auto saves.

184
00:12:22,400 --> 00:12:28,370
And the source code of that, of course, is
available and developed, for example, is text edit.

185
00:12:28,370 --> 00:12:33,840
So the next thing I want to talk to you about
is exceptions and error handling in Cocoa apps.

186
00:12:33,840 --> 00:12:39,440
So, unlike a lot of frameworks in the world,
exceptions are for programming errors.

187
00:12:39,440 --> 00:12:43,430
For starters, you certainly shouldn't
use them for normal control flow.

188
00:12:43,430 --> 00:12:49,260
And if you want a benchmark for whether or not you're
using exceptions too much, here is one I recommend.

189
00:12:49,260 --> 00:12:54,460
If you have a good test feed for your application, and you
know you do, or at least you should if you haven't already,

190
00:12:54,460 --> 00:12:58,280
your test should be able to run, you know,
successfully with no exceptions thrown.

191
00:12:58,280 --> 00:13:03,960
That's how you know when it's really working, or
when you follow the rules that we recommend properly.

192
00:13:03,960 --> 00:13:07,840
And, you know, there are, you know,
outs or exceptions to these rules.

193
00:13:07,840 --> 00:13:10,730
You know, you can use them in your own subsystems.

194
00:13:10,730 --> 00:13:16,500
Just make sure that you don't-- no exceptions
get, you know, thrown up out of your subsystem.

195
00:13:16,500 --> 00:13:18,170
So a little bit more advice.

196
00:13:18,170 --> 00:13:21,050
Be careful about catching and not rethrowing.

197
00:13:21,050 --> 00:13:26,540
This makes debugging your problems harder, when an exception
is thrown, something catches it and just swallows it,

198
00:13:26,540 --> 00:13:29,400
something went wrong, you don't
even notice it during testing.

199
00:13:29,400 --> 00:13:33,790
So it's a good thing, as I mentioned,
to do at some subsystem boundaries.

200
00:13:33,790 --> 00:13:39,600
For example, if you're using Grand Central
Dispatch, you know, libdispatch, and, you know,

201
00:13:39,600 --> 00:13:45,070
you've passed a block to it, you'd better not let
an exception get thrown up through that block.

202
00:13:45,070 --> 00:13:51,800
So catching and not rethrowing is,
you know, a good idea in a few places.

203
00:13:51,800 --> 00:13:53,960
But in general, it's bad almost everywhere else.

204
00:13:53,960 --> 00:13:57,800
And at least log, you know, when you swallow an exception,

205
00:13:57,800 --> 00:14:04,180
so that when you're debugging your
own code, you can see it happen.

206
00:14:04,180 --> 00:14:08,990
And during your debugging, catching
exceptions in the debugger is pretty easy.

207
00:14:08,990 --> 00:14:12,230
This is the function to break on, objc_exception_throw.

208
00:14:12,230 --> 00:14:16,880
And also in X Code, there's a menu
item, "Stop on Objective-C Exceptions."

209
00:14:16,880 --> 00:14:21,760
And one little tip, when you do this, you
might see Accessibility throw an exception

210
00:14:21,760 --> 00:14:27,520
or two when an Accessibility client has happened,
or an Accessibility client has experienced an error.

211
00:14:27,520 --> 00:14:29,690
But in general, it doesn't happen that much.

212
00:14:29,690 --> 00:14:30,870
So reporting exceptions.

213
00:14:30,870 --> 00:14:36,670
One thing that a lot of apps do, and it's a good thing for
you to do too, is during your own testing and debugging,

214
00:14:36,670 --> 00:14:41,690
certainly, when an exception is thrown, let the user
see it, if they're the kind of user that can report bugs

215
00:14:41,690 --> 00:14:45,060
on your application, put up an alert, you
know, with the stack trace and all that.

216
00:14:45,060 --> 00:14:49,470
And the way you do that, there's
a simple way in the AppKit apps.

217
00:14:49,470 --> 00:14:52,440
Override NSApplication reportException.

218
00:14:52,440 --> 00:14:58,950
And the sample code for this is,
you know, up on the website.

219
00:14:58,950 --> 00:15:05,220
When you subclass NSApplication, by the way,
to override something like that, you have to,

220
00:15:05,220 --> 00:15:13,390
in your info P list information, tell AppKit what
the name of the class is to use for the application.

221
00:15:13,390 --> 00:15:14,650
And it's down here.

222
00:15:14,650 --> 00:15:16,420
It's the Principal class.

223
00:15:16,420 --> 00:15:19,800
So that was exceptions.

224
00:15:19,800 --> 00:15:22,420
Now, there's a whole other thing; errors.

225
00:15:22,420 --> 00:15:25,520
In particular, the AppKit or the Foundation Class NSError.

226
00:15:25,520 --> 00:15:27,130
And the errors are for showing to the user.

227
00:15:27,130 --> 00:15:33,810
They're really supposed to be presentable to the user, you
know, right away, when they're returned by some method.

228
00:15:33,810 --> 00:15:40,010
So we use them in a lot of places in Cocoa now, NSDocument
and NSFileWrapper and NSData and a whole bunch of places.

229
00:15:40,010 --> 00:15:45,480
And, you know, everywhere we do that, we strive
to do something, you know, put strings in there,

230
00:15:45,480 --> 00:15:50,460
that if you show them to the user without doing
any customization, the result will be pretty good.

231
00:15:50,460 --> 00:15:53,610
So the presentability of NSErrors is very important.

232
00:15:53,610 --> 00:15:57,250
And the way you present errors
to the user, there's two methods.

233
00:15:57,250 --> 00:15:58,110
They're pretty handy.

234
00:15:58,110 --> 00:16:05,290
They're on NSResponder, presentError modelForWindow delegate
didPresentSelector contextInfo for putting up as a sheet,

235
00:16:05,290 --> 00:16:09,160
and this is another good place to
use that tip for how to use blocks.

236
00:16:09,160 --> 00:16:12,420
And another one, presentError for presenting them apmodally.

237
00:16:12,420 --> 00:16:17,910
So just like with exceptions, don't swallow NSErrors either.

238
00:16:17,910 --> 00:16:19,500
Show them to the user.

239
00:16:19,500 --> 00:16:22,430
So that's it for me.

240
00:16:22,430 --> 00:16:23,510
I'll hand it back to Corbin.

241
00:16:23,510 --> 00:16:24,220
Thank you.

242
00:16:24,220 --> 00:16:28,210
[ Applause ]

243
00:16:28,210 --> 00:16:29,140
>> Corbin Dunn: Thanks, Mark.

244
00:16:29,140 --> 00:16:30,910
So I want to do a couple of Nib Tips.

245
00:16:30,910 --> 00:16:36,860
If you aren't familiar with it, NSWindowController
and NSViewController is a great way for taking things

246
00:16:36,860 --> 00:16:41,470
like separate windows and separate views and
dropping them into another nib to help kind

247
00:16:41,470 --> 00:16:43,870
of organize your application really well.

248
00:16:43,870 --> 00:16:45,470
It's really easy to use those.

249
00:16:45,470 --> 00:16:51,190
You just alloc initWithWindowNibName, and you
can load to Nib with the WindowController.

250
00:16:51,190 --> 00:16:56,920
The cool thing about this, top level objects are
automatically freed for you, and it's really easy to use.

251
00:16:56,920 --> 00:16:59,500
Now, what if you want manually load some nibs?

252
00:16:59,500 --> 00:17:01,070
What and how do you do this?

253
00:17:01,070 --> 00:17:02,640
Well, why would you do it?

254
00:17:02,640 --> 00:17:07,390
You would probably want to do this if you have say a view
and a nib and a want to kind of use it like a factory.

255
00:17:07,390 --> 00:17:10,660
You want to cash the nib and just
pump out one view, another view,

256
00:17:10,660 --> 00:17:15,390
another view and another view, or
Windows or whatever else you want.

257
00:17:15,390 --> 00:17:16,980
So it's really easy to do that.

258
00:17:16,980 --> 00:17:23,490
You can just go ahead and alloc initWithNibName
of the actual nib and say cache it.

259
00:17:23,490 --> 00:17:27,550
Then you can just do instantiateNibWithOwner
topLevelObjects,

260
00:17:27,550 --> 00:17:29,570
and you can pass it to whatever owner you want.

261
00:17:29,570 --> 00:17:33,390
And that owner will then get all
its outlets hooked up at that time.

262
00:17:33,390 --> 00:17:39,380
So in this particular case of this code here, the
owner has a _secondWindow outlet hooked up to a window.

263
00:17:39,380 --> 00:17:42,970
And you could do something like
makeKeyAndOrderFront to show it.

264
00:17:42,970 --> 00:17:48,730
Now, we could go ahead and call out again,
nib instantiateWithOwner topLevelObjects

265
00:17:48,730 --> 00:17:53,760
and pass the same owner in, because we want to
reuse the same owner for some particular reason.

266
00:17:53,760 --> 00:17:59,520
At that point, the previous outlets will be overwritten, and
you can reuse that same outlet for the actual new instance

267
00:17:59,520 --> 00:18:05,340
of the window and do things like show that window again.

268
00:18:05,340 --> 00:18:10,590
Now, if you are doing something like that, it's
important to know what happens in awakeFromNib.

269
00:18:10,590 --> 00:18:14,090
So that owner object is probably in a nib itself.

270
00:18:14,090 --> 00:18:19,460
So if we add some code that goes ahead and logs
how many times awakeFromNib is getting called,

271
00:18:19,460 --> 00:18:22,320
let's take a look at what we'll actually get.

272
00:18:22,320 --> 00:18:24,590
Well, the owner is in a nib, is it's going to get it once.

273
00:18:24,590 --> 00:18:29,660
And then we pass that owner as the owner,
or sorry, pass that object as the owner

274
00:18:29,660 --> 00:18:32,540
to two other calls in that previous little example.

275
00:18:32,540 --> 00:18:38,250
So I would expect to see this print out a log
three separate times; once for the owner itself,

276
00:18:38,250 --> 00:18:41,240
and twice for when it was actually passed as the owner.

277
00:18:41,240 --> 00:18:46,930
It's important to know that just because
awakeFromNib might be called more than once.

278
00:18:46,930 --> 00:18:49,200
Now, if you are manually loading
nibs, it's important to know

279
00:18:49,200 --> 00:18:53,450
that all top level objects you have to release manually.

280
00:18:53,450 --> 00:18:57,280
So that was a quick on nibs.

281
00:18:57,280 --> 00:18:59,310
I'd like to bring my colleague, Kevin, up to stage.

282
00:18:59,310 --> 00:19:01,440
[ Applause ]

283
00:19:01,440 --> 00:19:04,600
>> Kevin Perry: Hi there.

284
00:19:04,600 --> 00:19:07,250
I'm Kevin Perry, also on the AppKit team.

285
00:19:07,250 --> 00:19:13,280
And I have a couple of really quick tips
on three different classes in AppKit.

286
00:19:13,280 --> 00:19:18,920
And since Corbin just talked about nibs, let's
talk about Nib-Based CollectionViewItems.

287
00:19:18,920 --> 00:19:25,660
NSCollectionViewItem is the class that acts as
a controller between the represented objects

288
00:19:25,660 --> 00:19:30,990
in a CollectionView's content, and the
views that are represented visually

289
00:19:30,990 --> 00:19:34,320
in the CollectionView for each of those items.

290
00:19:34,320 --> 00:19:40,470
And in Leopard, it's an NSObject, a subclass of NSObject.

291
00:19:40,470 --> 00:19:47,460
And another role of NSCollectionViewItem is also to
replicate each of the item views from a prototype view.

292
00:19:47,460 --> 00:19:53,510
The way this worked in Leopard is that every time you added
an object to your NSCollectionView, you would actually,

293
00:19:53,510 --> 00:20:00,120
we would actually archive and unarchive that prototype view
and attempt to copy over all the connections and bindings

294
00:20:00,120 --> 00:20:02,460
from the prototype view to the item view.

295
00:20:02,460 --> 00:20:08,910
Now, this process sometimes dropped a few of those
connections or bindings or did them inappropriately.

296
00:20:08,910 --> 00:20:12,940
So in Snow Leopard, we have a new approach.

297
00:20:12,940 --> 00:20:17,140
We made NSCollectionViewItem as
subclass of NSViewController instead.

298
00:20:17,140 --> 00:20:22,870
So we can use a nib to contain our prototype view.

299
00:20:22,870 --> 00:20:27,210
And when we add objects to our CollectionView,
we instantiate that nib for each one

300
00:20:27,210 --> 00:20:35,630
and get a perfect replication of that prototype
view with bindings and connections all intact.

301
00:20:35,630 --> 00:20:44,350
Now let me illustrate how you would move from the Leopard
style CollectionViewItem to Snow Leopard Nib-Based style.

302
00:20:44,350 --> 00:20:53,250
In Leopard, you would have your main nib, which contain your
CollectionView and had a connection to the item prototype,

303
00:20:53,250 --> 00:20:55,190
which had a connection to your prototype view.

304
00:20:55,190 --> 00:21:01,340
And, in turn, that prototype view would be bound back to the
item prototype and the represented object that it contains.

305
00:21:01,340 --> 00:21:03,200
So this is Leopard.

306
00:21:03,200 --> 00:21:10,550
To go to this new Snow Leopard style,
you will create a separate View nib.

307
00:21:10,550 --> 00:21:15,670
And in that nib, you'll change the File's
Owners class to NSCollectionViewItem.

308
00:21:15,670 --> 00:21:20,230
And this will represent the individual
instance that's associated

309
00:21:20,230 --> 00:21:24,110
with a single object in your CollectionView's content.

310
00:21:24,110 --> 00:21:29,730
What you'll do next is cut and paste your
prototype view over to that new nib and redo all

311
00:21:29,730 --> 00:21:34,590
of the connections and bindings with the File's Owner.

312
00:21:34,590 --> 00:21:43,610
The last thing is to set the nib name of the item
prototype, your main nib, to be that of your new View nib.

313
00:21:43,610 --> 00:21:44,770
And it's really that simple.

314
00:21:44,770 --> 00:21:47,700
You'll start using this new approach immediately.

315
00:21:47,700 --> 00:21:50,760
Now, what about Leopard compatibility?

316
00:21:50,760 --> 00:21:53,700
I've got a little trick for that, as well.

317
00:21:53,700 --> 00:21:59,940
One thing you can do is override
NSCollectionViewItems copyWithZone method.

318
00:21:59,940 --> 00:22:03,340
And the first thing you're going to do is
alloc init an instance of your subclass.

319
00:22:03,340 --> 00:22:06,850
It's important to note you're not going to call super here.

320
00:22:06,850 --> 00:22:08,940
And from somewhere, you're going to get an NS Nib.

321
00:22:08,940 --> 00:22:15,300
Like Corbin talked about, we can use a single NS Nib as
sort of a factory for multiple instances of the same view.

322
00:22:15,300 --> 00:22:21,090
So you'll probably just want to have
one NS Nib instance for your subclass.

323
00:22:21,090 --> 00:22:23,720
And you're going to instantiate that nib

324
00:22:23,720 --> 00:22:28,550
with the NSCollectionViewItem subclass
instance as the owner for that nib.

325
00:22:28,550 --> 00:22:32,700
And that will set up all the bindings and
connections properly for that instance.

326
00:22:32,700 --> 00:22:35,770
And then just return it.

327
00:22:35,770 --> 00:22:40,560
Now, in Snow Leopard, loadView is a
method on NSViewController, which,

328
00:22:40,560 --> 00:22:43,080
in its collection view item, will inherit.

329
00:22:43,080 --> 00:22:48,160
And loadView is where NSViewController
attempts to load a nib.

330
00:22:48,160 --> 00:22:52,280
So you don't want nib-loading code in two places.

331
00:22:52,280 --> 00:22:58,380
So one thing to get around that is
to override loadView to do nothing.

332
00:22:58,380 --> 00:23:03,400
Another option would be to make
copyWithZone conditional only on Leopard.

333
00:23:03,400 --> 00:23:06,350
Let's move on to another class, NSPathControl.

334
00:23:06,350 --> 00:23:09,100
The first tip is that such a class exists.

335
00:23:09,100 --> 00:23:12,680
It's a relatively new class, and I think a
lot of people aren't familiar with it yet.

336
00:23:12,680 --> 00:23:15,950
But it's a very convenient class for
displaying file paths to the user.

337
00:23:15,950 --> 00:23:24,520
As you can see here, we have a single cell for each
component in the path, which is showed sequentially,

338
00:23:24,520 --> 00:23:29,150
and throw away some of the information
that the path components at the beginning

339
00:23:29,150 --> 00:23:32,760
that the user usually isn't interested
about, like slash users.

340
00:23:32,760 --> 00:23:41,710
We also grab the file icons from the file system
automatically and use the localized file names.

341
00:23:41,710 --> 00:23:44,890
The PathControl has some really great
animation, so it still remains usable,

342
00:23:44,890 --> 00:23:49,020
when the amount of space you have
in your user interface is limited.

343
00:23:49,020 --> 00:23:52,260
Now, there's three different styles of PathControl, as well.

344
00:23:52,260 --> 00:23:54,440
You see, this is the bezel style.

345
00:23:54,440 --> 00:23:59,290
We also have a non-bezel style and a popup button style.

346
00:23:59,290 --> 00:24:04,330
The next tip is that NSPathControl is
useful for more than just file paths.

347
00:24:04,330 --> 00:24:09,890
If your application has any sort of hierarchical
data, which your users can navigate through,

348
00:24:09,890 --> 00:24:14,510
you can show that current path that
they're looking at with an NSPathControl.

349
00:24:14,510 --> 00:24:21,630
You can do that by using setStringValue and
passing any string, which has forward slashes

350
00:24:21,630 --> 00:24:24,540
that delimit the different components in the path.

351
00:24:24,540 --> 00:24:31,440
And to set up an image, you just call setImage on each of
the NS pathComponentCells, since we're not going to be able

352
00:24:31,440 --> 00:24:35,200
to grab those icons automatically
from the file system for you.

353
00:24:35,200 --> 00:24:42,530
You can also do custom drawing in a PathControl
by providing a custom pathComponentCell.

354
00:24:42,530 --> 00:24:44,000
And you can do layout

355
00:24:44,000 --> 00:24:47,890
with rectOfPathComponentCell:withFrame:inView
if you want to do custom layout.

356
00:24:47,890 --> 00:24:50,340
Alright, let's move on to NSSplitView.

357
00:24:50,340 --> 00:24:54,480
NSSplitView is often used to implement
sidebars, like we see here.

358
00:24:54,480 --> 00:25:00,850
We've got two sidebars on either side of the
window and a main content view in the middle.

359
00:25:00,850 --> 00:25:06,830
And when you resize this window, you're going to
expect, usually, the sidebars to remain the same size

360
00:25:06,830 --> 00:25:10,840
and the ContentView to resize, as seen here.

361
00:25:10,840 --> 00:25:18,150
Now, by default, when you resize a SplitView,
the AdjustSubviews method is called.

362
00:25:18,150 --> 00:25:23,090
AdjustSubviews attempts to resize all of
the subviews proportionally to each other.

363
00:25:23,090 --> 00:25:25,630
In this case, this isn't what we want.

364
00:25:25,630 --> 00:25:33,250
So in Leopard, before you would have to implement the
SplitView resizeSubviewWithOldSize delegate method.

365
00:25:33,250 --> 00:25:42,200
And the result of this was you essentially overriding
all of the AdjustSubviews methods implementation.

366
00:25:42,200 --> 00:25:46,010
You would have to do all of that yourself, as you see here.

367
00:25:46,010 --> 00:25:49,140
This isn't an insignificant amount of code.

368
00:25:49,140 --> 00:25:52,340
So we wanted to make this a lot simpler to do.

369
00:25:52,340 --> 00:25:55,220
And we did that in Snow Leopard.

370
00:25:55,220 --> 00:25:59,270
By adding this delegate method, SplitView
should have just sized at Subview.

371
00:25:59,270 --> 00:26:04,420
This method allows you to simply
specify a subset of your subviews,

372
00:26:04,420 --> 00:26:07,130
which should be resized by the AdjustSubviews method.

373
00:26:07,130 --> 00:26:11,700
And here, we see, for this case that I showed you
before, we returned yes for the middle view only.

374
00:26:11,700 --> 00:26:13,070
And that's all we need to do.

375
00:26:13,070 --> 00:26:14,230
It's very simple.

376
00:26:14,230 --> 00:26:19,090
All right, so let's move over back to Corbin.

377
00:26:19,090 --> 00:26:22,440
[ Applause ]

378
00:26:22,440 --> 00:26:22,590
>> Corbin Dunn: Cool.

379
00:26:22,590 --> 00:26:23,990
Thanks, Kevin.

380
00:26:23,990 --> 00:26:27,740
So let's do a couple quick Objective-C Tips.

381
00:26:27,740 --> 00:26:30,290
Now, you could have static methods in Objective-C.

382
00:26:30,290 --> 00:26:32,850
And you're probably thinking, wait a
minute, what are you talking about?

383
00:26:32,850 --> 00:26:39,960
Well, really all I mean is you can just have a Static-C
function inside of your implementation section here.

384
00:26:39,960 --> 00:26:40,960
Why would you want to do this?

385
00:26:40,960 --> 00:26:46,850
Well, you might want to take advantage of some compiler
time optimizations, like inlining code or some other things

386
00:26:46,850 --> 00:26:51,970
which help with performance or data abstraction
and hiding the implementation of a method.

387
00:26:51,970 --> 00:26:56,090
Now, what's interesting about this,
notice that in this method,

388
00:26:56,090 --> 00:27:03,000
we are accessing the self-dereference_window,
which is a private Ivar in the class.

389
00:27:03,000 --> 00:27:07,600
Now, this compiles fine if you have this
C-method inside the App Implemenation section.

390
00:27:07,600 --> 00:27:13,580
If you have it outside of that, you'll get a compile time
error or warning, depending on how you have things set up.

391
00:27:13,580 --> 00:27:19,090
So that's a cool and quick great tip on how to actually
do static methods, and calling them, of course,

392
00:27:19,090 --> 00:27:24,750
just like call a C-method, where you pass
the self and any parameters you want.

393
00:27:24,750 --> 00:27:27,540
Another quick Objective-C tip, OBJC_HELP.

394
00:27:27,540 --> 00:27:35,670
If you aren't familiar with this, go ahead and set
the environment variable exportobjc_help to yes.

395
00:27:35,670 --> 00:27:38,570
Run any Cocoa or Objective-C application.

396
00:27:38,570 --> 00:27:43,370
And you're going to see a ton of other
Objective-C run time variables that you can set.

397
00:27:43,370 --> 00:27:49,140
If you set any of these at the run time, they will actually
show you more cool debugging features enhancements,

398
00:27:49,140 --> 00:27:54,910
I just recommend remembering OBJC_HELP and
looking up the others if you need some stuff.

399
00:27:54,910 --> 00:27:57,100
All right, so I'd like to do a quick demo.

400
00:27:57,100 --> 00:28:00,340
Okay, so I'm going to show a couple
of the tips I like to use

401
00:28:00,340 --> 00:28:04,590
for actually developing inside of
AppKit and things I do all the time.

402
00:28:04,590 --> 00:28:09,250
First of all, take a look at this class here,
where this is the TableView links sample code,

403
00:28:09,250 --> 00:28:14,110
where it has the implementation and NSTableView
delegate and the TableView data source.

404
00:28:14,110 --> 00:28:17,310
If I go to the implementation section, a real cool tip.

405
00:28:17,310 --> 00:28:27,010
If you type dash and start typing in prefix like
TableView, you can see all the TableView delegate methods,

406
00:28:27,010 --> 00:28:30,500
because Xcode knows that you actually
want to implement those.

407
00:28:30,500 --> 00:28:36,880
And you can easily select one and it will toss in the
implementation declaration, so you can just instantly add it

408
00:28:36,880 --> 00:28:40,210
without having to actually go to the header
and type everything and getting any typos.

409
00:28:40,210 --> 00:28:42,370
So that's a great tip.

410
00:28:42,370 --> 00:28:45,910
Another cool one that I like is I use #pragma mark a lot.

411
00:28:45,910 --> 00:28:47,720
A dash will be a separator.

412
00:28:47,720 --> 00:28:51,860
And you can use #pragma mark and some actual title string.

413
00:28:51,860 --> 00:28:57,540
And what this does, it's really small font, so it's hard to
see, but inside of the little method popup here in Xcode,

414
00:28:57,540 --> 00:29:00,320
it will show those names and sections that you actually add.

415
00:29:00,320 --> 00:29:01,840
It's a great way for organizing your code.

416
00:29:01,840 --> 00:29:03,340
A great tip for here.

417
00:29:03,340 --> 00:29:05,150
This is actually a type selectable.

418
00:29:05,150 --> 00:29:11,850
So if I want to go to a number of rows in TableView, I
just start typing number of rows and actually go to it.

419
00:29:11,850 --> 00:29:16,530
Another tip is I'll frequently be working on a
wim.m file, and I want to go to the implementation

420
00:29:16,530 --> 00:29:19,550
of a method, and not any calling locations of it.

421
00:29:19,550 --> 00:29:23,540
So frequently what I'll do is I'll
hit Command F and type the right paren

422
00:29:23,540 --> 00:29:26,040
and then the method name that I want to go to.

423
00:29:26,040 --> 00:29:29,030
Select number of rows.

424
00:29:29,030 --> 00:29:34,260
So by using that and specific code formatting that I
always use, I can instantly go to just the implementation

425
00:29:34,260 --> 00:29:37,840
of the method really quickly in one
particular file that I'm working in.

426
00:29:37,840 --> 00:29:42,080
All right, now I'd like to bring up
my colleague, James, to the stage.

427
00:29:42,080 --> 00:29:48,530
[ Applause ]

428
00:29:48,530 --> 00:29:50,020
>> James Dempsey: Thank you, Corbin.

429
00:29:50,020 --> 00:29:54,740
So I'm James Dempsey from the Cocoa Frameworks
Team, and the next couple of tips are

430
00:29:54,740 --> 00:29:57,890
about the secret life of your app's user interface.

431
00:29:57,890 --> 00:30:00,620
Because I know if my app's user interface was out running

432
00:30:00,620 --> 00:30:06,100
around with some other process behind my
back, I'd want somebody to tell me about it.

433
00:30:06,100 --> 00:30:08,380
So let me explain.

434
00:30:08,380 --> 00:30:15,450
So now, when we think about our application's user
interface, we tend to think about its visual representation.

435
00:30:15,450 --> 00:30:21,440
But your app's user interface is a whole lot
more than just a bitmap and a frame buffer.

436
00:30:21,440 --> 00:30:26,970
I mean, this is also a bitmap and a frame buffer,
but it doesn't have anywhere near the density

437
00:30:26,970 --> 00:30:31,000
of information that's conveyed by your app's user interface.

438
00:30:31,000 --> 00:30:38,740
Because your app's user interface is really this
collection, this rich collection of structural information,

439
00:30:38,740 --> 00:30:47,480
functional information, semantic information, all
sorts of information that's all conveyed to the user

440
00:30:47,480 --> 00:30:51,770
by just a particular arrangement of color values.

441
00:30:51,770 --> 00:30:59,290
So that's the life of our user interface
that we're all pretty much familiar with.

442
00:30:59,290 --> 00:31:04,020
But now let's think about the experience of a blind user.

443
00:31:04,020 --> 00:31:11,360
Now, suddenly a bitmap is a pretty poor
way to communicate all of that information.

444
00:31:11,360 --> 00:31:15,060
And for that particular reason or that primary reason,

445
00:31:15,060 --> 00:31:21,620
every application on Mac OS 10 provides
another representation of the user interface.

446
00:31:21,620 --> 00:31:26,520
And this representation can be accessed
programmatically from another process.

447
00:31:26,520 --> 00:31:35,130
It is a structured and explicit representation of all of
that information that we saw on our app's user interface.

448
00:31:35,130 --> 00:31:39,940
And I call it the secret life of your app's
user interface because you may not know

449
00:31:39,940 --> 00:31:43,750
that your app's been spewing this stuff out all along.

450
00:31:43,750 --> 00:31:47,970
And spew, I mean delivering.

451
00:31:47,970 --> 00:31:55,460
So your application is a server
for user interface information.

452
00:31:55,460 --> 00:32:03,000
And other processes on the system, such as the screen
reader voiceover, use a client API to make requests

453
00:32:03,000 --> 00:32:08,370
of your application, tell me about your UI,
maybe to click a button or set some values,

454
00:32:08,370 --> 00:32:12,600
like moving a window around, and
your app sends back a response.

455
00:32:12,600 --> 00:32:16,590
It's a pretty straightforward client/server relationship.

456
00:32:16,590 --> 00:32:23,140
Now, voiceover ships with Mac OS 10,
but those client APIs, they're public.

457
00:32:23,140 --> 00:32:24,610
So there's a variety.

458
00:32:24,610 --> 00:32:30,250
Once you have this representation of your app's user
interface and other process, that's pretty useful.

459
00:32:30,250 --> 00:32:34,580
In fact, gooey scripting relies upon
this, as well as numerous other tools

460
00:32:34,580 --> 00:32:38,760
and utilities available from Apple and third parties.

461
00:32:38,760 --> 00:32:46,310
So now that you know that your app has this secret life that
you might not have been aware of, what do you do about it?

462
00:32:46,310 --> 00:32:52,480
Well, the first thing is if you're
using standard AppKit controls,

463
00:32:52,480 --> 00:32:56,030
the frameworks provide great accessibility support.

464
00:32:56,030 --> 00:33:01,470
Now, even if you're doing so, any custom
images, we don't know what it's an image of.

465
00:33:01,470 --> 00:33:04,460
And so adding descriptions is a great thing to do.

466
00:33:04,460 --> 00:33:08,420
And I'll show you a quick demo of how to
do that really easily in Snow Leopard.

467
00:33:08,420 --> 00:33:15,230
And then if you have custom views in your app, we don't
know what you're doing in that custom view exactly,

468
00:33:15,230 --> 00:33:24,400
so use the NSAccessibility protocol to reveal the
interior of your custom views so that voiceover and things

469
00:33:24,400 --> 00:33:27,190
like gooey scripting know what's going on.

470
00:33:27,190 --> 00:33:30,610
And with that, let's jump into a
couple of really quick tip demos.

471
00:33:30,610 --> 00:33:36,240
So first, image descriptions.

472
00:33:36,240 --> 00:33:41,900
Now, what I have here is a small little demo app.

473
00:33:41,900 --> 00:33:45,290
And it shows reviews of appliances.

474
00:33:45,290 --> 00:33:48,710
So across the top, I have different appliance categories.

475
00:33:48,710 --> 00:33:53,800
And then for various products,
ratings in separate categories.

476
00:33:53,800 --> 00:34:00,210
Now, what I have here is a slightly modified version of
our Accessibility Inspector, which is going to tell us

477
00:34:00,210 --> 00:34:04,210
if the thing I'm pointing at on screen
has an accessibility description.

478
00:34:04,210 --> 00:34:07,930
And as you can see here, nothing.

479
00:34:07,930 --> 00:34:16,650
So a voiceover user who downloads this app is going to
think it really sucks, because to them, it really does suck.

480
00:34:16,650 --> 00:34:20,500
Because none of this information is available.

481
00:34:20,500 --> 00:34:27,410
Now, because image descriptions are such an important
part, we've tried to make that as easy as possible.

482
00:34:27,410 --> 00:34:33,450
In Snow Leopard, we've added an image and
accessibility description property to NSImage.

483
00:34:33,450 --> 00:34:37,270
You set it there, and it will show up
wherever it shows up in the interface.

484
00:34:37,270 --> 00:34:43,130
But in addition, since so many of
the images we use are named images,

485
00:34:43,130 --> 00:34:49,900
we have a specially named strings
file, accessibility image descriptions.

486
00:34:49,900 --> 00:34:54,930
The keys are just the image names that
you're going to call by image names.

487
00:34:54,930 --> 00:34:58,020
The values are the accessibility descriptions.

488
00:34:58,020 --> 00:35:06,010
You pop this strings file with the particular
name into your project, you recompile.

489
00:35:06,010 --> 00:35:13,150
And now this is actually a great app for voiceover users,
because all of these images are completely accessible.

490
00:35:13,150 --> 00:35:13,840
Feel free.

491
00:35:13,840 --> 00:35:14,840
Please, clap.

492
00:35:14,840 --> 00:35:20,750
[ Applause ]

493
00:35:20,750 --> 00:35:24,830
Just short of reading your mind, I
don't know how we could get that easier.

494
00:35:26,320 --> 00:35:32,790
Okay, now, one other tip here.

495
00:35:32,790 --> 00:35:36,010
And this is a sample app called Dicey.

496
00:35:36,010 --> 00:35:38,260
It's a little dice game.

497
00:35:38,260 --> 00:35:43,980
And it is a code sample we've had for a while that
shows you how to make a custom view accessible.

498
00:35:43,980 --> 00:35:46,620
This dice area is a custom view.

499
00:35:46,620 --> 00:35:54,880
And, again, for a voiceover user who's relying on that
accessibility information to drive the app, this app is,

500
00:35:54,880 --> 00:36:01,790
if we didn't make it accessible, would be useless,
because they wouldn't know any of the values of the dice.

501
00:36:01,790 --> 00:36:08,250
So that code sample, and many others that show you how to
make your custom views accessible, are already available.

502
00:36:08,250 --> 00:36:09,620
Please check them out.

503
00:36:09,620 --> 00:36:14,350
Now, if you do go and make-- or when you
do go make your custom views accessible,

504
00:36:14,350 --> 00:36:21,180
there's a nice little development benefit as well,
and that's user interface automation testing.

505
00:36:21,180 --> 00:36:28,140
Now, what I have here is an AppleScript that's
using the system events AppleScript dictionary

506
00:36:28,140 --> 00:36:31,920
to drive the user interface automatically.

507
00:36:31,920 --> 00:36:36,640
And this is handy for doing stress testing of
your app, for doing user interface testing.

508
00:36:36,640 --> 00:36:37,820
Oh, sure, play again.

509
00:36:37,820 --> 00:36:43,840
User interface testing for parts of your app
that maybe users don't hit as frequently.

510
00:36:43,840 --> 00:36:51,600
And in addition to AppleScript, using the scripting
bridge, you can also do the scripting in Ruby and Python.

511
00:36:51,600 --> 00:36:58,170
And so those are two accessibility tips and a heads-up
about the secret life of your app's user interface.

512
00:36:58,170 --> 00:36:58,990
Thank you.

513
00:36:58,990 --> 00:37:01,600
[ Applause ]

514
00:37:01,600 --> 00:37:04,610
I'll turn it back over to Corbin for blurry views.

515
00:37:04,610 --> 00:37:04,940
>> Corbin Dunn: Cool.

516
00:37:04,940 --> 00:37:06,230
Thanks, James.

517
00:37:06,230 --> 00:37:08,850
So I want to talk about blurry views.

518
00:37:08,850 --> 00:37:10,780
So what is this?

519
00:37:10,780 --> 00:37:14,020
And this is a blurry view, but note
that this image is kind of simulated.

520
00:37:14,020 --> 00:37:15,610
It's really not that bad.

521
00:37:15,610 --> 00:37:19,710
But have you seen this before and wonder
why your views are just slightly blurry?

522
00:37:19,710 --> 00:37:20,980
What causes that?

523
00:37:20,980 --> 00:37:24,500
Well, here's what we want it to look like, nice and crisp.

524
00:37:24,500 --> 00:37:30,500
So if we take a look at the cause of that, it's
because we have non-integral pixel alignment.

525
00:37:30,500 --> 00:37:35,850
So what that means is if you look at the frame
for your view inside a pixel coordinate system,

526
00:37:35,850 --> 00:37:40,900
the X and the Y is probably something
like 200 1/2 or 200 1/2 and what not.

527
00:37:40,900 --> 00:37:44,320
And that's the cause of why that happens.

528
00:37:44,320 --> 00:37:45,790
How do you fix that?

529
00:37:45,790 --> 00:37:49,270
Well, there's two easy solutions
that are resolution-independent.

530
00:37:49,270 --> 00:37:51,950
The first way is to use centerScanRect.

531
00:37:51,950 --> 00:37:54,700
And so what you'll do is you'll
just grab your imageViews frame.

532
00:37:54,700 --> 00:37:58,540
Now, your frame is with respect to
your appearance coordinate system.

533
00:37:58,540 --> 00:38:04,120
So you'll grab your superview and do a centerScanRect on
that frame, and it gives you a resolution-independent frame

534
00:38:04,120 --> 00:38:08,700
that you can then set back on imageView,
and it fixes the problem.

535
00:38:08,700 --> 00:38:12,150
Sometimes centerScanRect might
not do what you want it to do.

536
00:38:12,150 --> 00:38:17,310
It might round or seal or floor it not
in the direction you want it to go.

537
00:38:17,310 --> 00:38:20,840
So if you want more explicit control,
here is another way of doing that.

538
00:38:20,840 --> 00:38:27,050
Again, you grab your frame, you convert it to pixel
space using convertRectToBase, again, on the superview.

539
00:38:27,050 --> 00:38:32,100
At that point, you can actually do your floor, round or ceil

540
00:38:32,100 --> 00:38:37,180
or whatever you think you need to do
to round it onto pixel boundaries.

541
00:38:37,180 --> 00:38:42,190
Then you can convert it back into your view's
coordinate system by using the convertRectFromBase.

542
00:38:42,190 --> 00:38:44,940
And then, of course, set the frame.

543
00:38:44,940 --> 00:38:47,750
Now, you might be wondering, well,
why do you actually have to do that,

544
00:38:47,750 --> 00:38:51,830
convertRectToBase and convertRectFromBase back and forth?

545
00:38:51,830 --> 00:38:54,230
Well, again, it's important for resolution independence.

546
00:38:54,230 --> 00:38:59,220
All right, now I'd like to bring
my colleague, Ken, up onto stage.

547
00:38:59,220 --> 00:38:59,710
[ Applause ]

548
00:38:59,710 --> 00:39:05,010
>> Ken Ferry: Thank you, Corbin.

549
00:39:06,160 --> 00:39:07,570
Thanks, Corbin.

550
00:39:07,570 --> 00:39:10,200
So I'd like to talk about images for a little bit.

551
00:39:10,200 --> 00:39:13,410
The first thing I'd like to look at is flippedness.

552
00:39:13,410 --> 00:39:20,600
The issue with flippedness is that if you have a flipped
view like this and you've got to do some custom drawing

553
00:39:20,600 --> 00:39:24,940
in that flipped view in your drawRect and you have
images, you're very likely to come up with this.

554
00:39:24,940 --> 00:39:29,490
And so the question is, what do we do about it?

555
00:39:29,490 --> 00:39:31,030
So as a 10.6, this is not bad.

556
00:39:31,030 --> 00:39:36,340
We added a drawing method on this image that
takes explicitly a parameter respect flipped.

557
00:39:36,340 --> 00:39:39,830
If you pass the S for this, then it will adjust the context

558
00:39:39,830 --> 00:39:42,680
for its flippedness before drawing the
image, draw the image and put it back.

559
00:39:42,680 --> 00:39:43,810
So that's easy.

560
00:39:43,810 --> 00:39:46,770
And if it is that easy, why is this worth talking about?

561
00:39:46,770 --> 00:39:53,170
Well, unfortunately, because there's a lot of existing
code in the world, that doesn't really do this quite right.

562
00:39:53,170 --> 00:39:55,730
You'll see people use methods that start with composite.

563
00:39:55,730 --> 00:39:58,610
And you'll also see people try to use setFlipped for this.

564
00:39:58,610 --> 00:40:01,850
And these don't actually do what you want them to do.

565
00:40:01,850 --> 00:40:09,150
They're both depricated as of 10.6, though you
should-- they were sort of equally depricated before.

566
00:40:09,150 --> 00:40:12,880
We just didn't say they were depricated.

567
00:40:12,880 --> 00:40:14,540
So it's not new.

568
00:40:14,540 --> 00:40:18,180
You don't want to use these.

569
00:40:18,180 --> 00:40:23,280
They may appear to do the right thing sometimes, but
sometimes they won't, and it's not really what you want.

570
00:40:23,280 --> 00:40:26,530
In fact, just the fact the composite
behaves differently from draw

571
00:40:26,530 --> 00:40:30,520
in the first place should be a tipoff
that something is a little bit strange.

572
00:40:30,520 --> 00:40:35,660
Okay, for more information, see
the AppKit Release Notes, please.

573
00:40:35,660 --> 00:40:39,290
Okay, let's talk about a mutation a little bit, okay?

574
00:40:39,290 --> 00:40:44,680
So suppose that you did go and take your image in
your flipped view and you called setFlipped yes on it.

575
00:40:44,680 --> 00:40:46,750
And sometimes that will look like it works.

576
00:40:46,750 --> 00:40:48,840
Sometimes it won't, but sometimes it will.

577
00:40:48,840 --> 00:40:54,420
But after you've done that, it's pretty common,
unfortunately, then to go happen to look at some other part

578
00:40:54,420 --> 00:40:59,480
of your user interface, you pull down a menu,
and suddenly there's an image that's upside down.

579
00:40:59,480 --> 00:41:02,330
And unless you happen to do these
within three minutes of each other,

580
00:41:02,330 --> 00:41:04,150
you might not realize there's any connection there,

581
00:41:04,150 --> 00:41:09,670
which can be pretty frustrating,
because it looks like a framework bug.

582
00:41:09,670 --> 00:41:13,720
And the problem, of course, is that it's the same
image that's being used in two different places.

583
00:41:13,720 --> 00:41:19,050
So when you mutated one, you affected the
other, and that's not what you wanted to do.

584
00:41:19,050 --> 00:41:23,690
SetFlipped is depricated, but this applies
to all mutations, including set size,

585
00:41:23,690 --> 00:41:26,920
and also lock focus on this image is a mutation.

586
00:41:26,920 --> 00:41:29,750
So how are you supposed to-- okay,
so I'm saying you shouldn't do this.

587
00:41:29,750 --> 00:41:32,570
So how are you supposed to use these mutating methods?

588
00:41:32,570 --> 00:41:35,110
Well, the answer is that basically you aren't.

589
00:41:35,110 --> 00:41:37,900
We think of them as being part of the setup of an image.

590
00:41:37,900 --> 00:41:44,210
So you would alloc and initialize an image, set a bunch
of things to configure it, and then you stop touching it.

591
00:41:44,210 --> 00:41:47,420
Or if you need to-- if you have an
existing image that you need to--

592
00:41:47,420 --> 00:41:49,980
that you're in a sort of situation where you would copy it,

593
00:41:49,980 --> 00:41:54,850
modify the copy that is still just
local to you, and then stop touching it.

594
00:41:54,850 --> 00:42:00,090
If you just receive an image in some method that's
already sort of connected to your application

595
00:42:00,090 --> 00:42:03,250
at large, you'll want to treat that as immutable.

596
00:42:03,250 --> 00:42:05,500
That's the intended model.

597
00:42:05,500 --> 00:42:11,840
Okay, so last for today, I'd like to
talk about performance a little bit.

598
00:42:11,840 --> 00:42:15,760
Pretty much everything that has to do with
performance in NSImage stems from one rule,

599
00:42:15,760 --> 00:42:20,860
which is that if you're doing the same drawing,
you'll want to be using the same image.

600
00:42:20,860 --> 00:42:21,980
And what does that mean?

601
00:42:21,980 --> 00:42:26,970
Well, suppose that you have a window, like this one on
the left here, and you're live resizing it, all right?

602
00:42:26,970 --> 00:42:34,160
So the images are drawing over and over and over, images
that look the same, like everything you see in this window.

603
00:42:34,160 --> 00:42:37,230
As a user, you cannot tell if one
of two things is happening.

604
00:42:37,230 --> 00:42:41,150
It's possible that every single time an image
draws, it's actually a new image instance.

605
00:42:41,150 --> 00:42:45,330
Somebody alloc and initialized an image,
make locked focus on it, whatever, drew it.

606
00:42:45,330 --> 00:42:50,500
Or it could be that the developer
just called setImage on some cell,

607
00:42:50,500 --> 00:42:54,040
and it's just one image that's just
sitting there being drawn over and over.

608
00:42:54,040 --> 00:42:58,590
From the user's point of view, you
can't tell unless the app is slow.

609
00:42:58,590 --> 00:43:02,820
Because the second case is the fast
one and the first one is the slow one.

610
00:43:02,820 --> 00:43:08,420
And this is quite obvious if you start
looking at it with Shark and such.

611
00:43:08,420 --> 00:43:13,630
And the reason for this is basically
caching, and all the way down the system.

612
00:43:13,630 --> 00:43:20,940
Certainly, every time you draw say a CG image, it will cache
the color match data against wherever you're drawing it.

613
00:43:20,940 --> 00:43:25,210
Or we might, in some circumstances, we actually
need to take that data and upload it to OpenGL.

614
00:43:25,210 --> 00:43:30,590
And if you're always making new images, all
of this work is happening every single time.

615
00:43:30,590 --> 00:43:36,650
And the drawing system is sort of shockingly fast,
but it's shockingly fast when the cache is hit.

616
00:43:36,650 --> 00:43:37,990
So be careful.

617
00:43:37,990 --> 00:43:43,950
Okay, that's pretty much all I want to talk about today.

618
00:43:43,950 --> 00:43:46,380
If you would like more information,
there are a couple good sources.

619
00:43:46,380 --> 00:43:48,410
You can take a look at the AppKit 10.6 Release Notes.

620
00:43:48,410 --> 00:43:54,080
And also, we gave a talk about NSImage last
year at WWDC that was actually quite in depth.

621
00:43:54,080 --> 00:44:01,880
The reason for this is that NSImage was actually pretty
much rewritten for 10.6 with a focus on transparency.

622
00:44:01,880 --> 00:44:07,680
It should behave the way it looks like it's
behaving, which required some deprication,

623
00:44:07,680 --> 00:44:11,020
and performance, and also impedance matching with core graphics.

624
00:44:11,020 --> 00:44:17,640
So please take a look at those resources, if you can.

625
00:44:17,640 --> 00:44:18,090
[ Applause ]

626
00:44:18,090 --> 00:44:18,870
>> Corbin Dunn: Thanks, Ken.

627
00:44:18,870 --> 00:44:19,650
So it's me again.

628
00:44:19,650 --> 00:44:24,520
And I'm going to talk more about TableView
and give a couple more TableView tips.

629
00:44:24,520 --> 00:44:25,640
Variable row heights.

630
00:44:25,640 --> 00:44:28,420
If you aren't familiar with this, we
have a delegate method to do this now,

631
00:44:28,420 --> 00:44:31,730
so you don't have to override a row or what not.

632
00:44:31,730 --> 00:44:37,510
So how do you actually do this properly and
what's the fast and easy way to do this?

633
00:44:37,510 --> 00:44:43,750
Well, you can implement the TableView Delegate Method,
tableView heightOfRow and return the appropriate row height.

634
00:44:43,750 --> 00:44:50,580
So the easy way to do that is just go ahead and ask the
TableView for a prepared cell at whatever column you want

635
00:44:50,580 --> 00:44:53,980
to actually measure, and the particular
row that we're asking for the height of.

636
00:44:53,980 --> 00:45:01,230
So that gives you a cell ready to draw or do whatever you
want with, which has everything set on it appropriately.

637
00:45:01,230 --> 00:45:06,120
So what you want to do is you want to
create a rect that has a specific width

638
00:45:06,120 --> 00:45:09,240
for that particular column or whatever
else you're measuring.

639
00:45:09,240 --> 00:45:14,590
In this case, we're using _tableColumnWidth, where we're
caching the width of the column we want to measure.

640
00:45:14,590 --> 00:45:18,120
We're going to give it that constrained
width and an unconstrained height.

641
00:45:18,120 --> 00:45:21,300
So we're using CGFLOAT_MAX to just give it big large height.

642
00:45:21,300 --> 00:45:26,620
And with that particular rect, we're going
to ask the cell, how big do you want to be?

643
00:45:26,620 --> 00:45:27,850
What's your natural size?

644
00:45:27,850 --> 00:45:34,910
So we're going to say cellSizeForBounds with that
constrainedBounds on the width and see what it says.

645
00:45:34,910 --> 00:45:38,240
Then we'll just go ahead and return
that actual height that it wants to be.

646
00:45:38,240 --> 00:45:41,650
Great, easy want to implement variable row heights.

647
00:45:41,650 --> 00:45:46,950
Now, when you actually want to change the
heights, you need to tell the TableView.

648
00:45:46,950 --> 00:45:51,410
Every time that delegate method you just saw
is called, you need to return the same height.

649
00:45:51,410 --> 00:45:54,070
TableView may or may not cache the value.

650
00:45:54,070 --> 00:45:59,560
So you will need to return the same height until
you tell it that the actual height has changed.

651
00:45:59,560 --> 00:46:05,110
So a great place to do that is probably
to implement TableViewColumnDidResize.

652
00:46:05,110 --> 00:46:11,560
So when you go ahead and resize the column and
the user lets go, this delegate method's called.

653
00:46:11,560 --> 00:46:17,850
At that point, you can grab the table column with whatever
identifier is being resized and get the width and store it

654
00:46:17,850 --> 00:46:23,370
in an Ivar, and then you can tell the table,
note height of rows with index has changed,

655
00:46:23,370 --> 00:46:28,830
and pass the index set for all the rows in the table to
let it know it needs to recalculate all of the heights.

656
00:46:28,830 --> 00:46:34,560
So that's a great fast and easy way
to implement variable row heights.

657
00:46:34,560 --> 00:46:40,570
All right, so in summary, we had a lot of
tips in this application, or in this talk,

658
00:46:40,570 --> 00:46:42,640
and hopefully you learned a few new things.

659
00:46:42,640 --> 00:46:46,670
If not, go ahead and download the
sample code associated with it,

660
00:46:46,670 --> 00:46:49,760
because a lot of these tips have
little tiny sample code apps

661
00:46:49,760 --> 00:46:53,670
that you can play around with and digest and figure out.

662
00:46:53,670 --> 00:46:55,680
So download that and play with it.

663
00:46:55,680 --> 00:47:01,540
Now, I'd like to have a--

664
00:47:01,540 --> 00:47:01,600
[ Applause ]

665
00:47:01,600 --> 00:47:08,610
We have an informal WWDC tradition, so
I'd like to bring James back on stage.

666
00:47:08,610 --> 00:47:09,060
[ Applause ]

667
00:47:09,060 --> 00:47:11,410
>> James Dempsey: Good afternoon.

668
00:47:15,520 --> 00:47:18,020
How is everybody's week going?

669
00:47:18,020 --> 00:47:25,410
Good. So this session, we had a lot
of kind of shorter tips and tricks.

670
00:47:25,410 --> 00:47:28,900
So I thought I'd bring in appropriate instruments.

671
00:47:29,920 --> 00:47:38,220
And very often, we were telling you in the session
talking about a lot of wonderful things that you can do.

672
00:47:38,220 --> 00:47:44,420
I thought, for a change, maybe a little song
about some stuff maybe you shouldn't do.

673
00:47:44,420 --> 00:47:48,500
So let's do it.

674
00:47:48,500 --> 00:52:18,070
[ Music ]

675
00:52:18,070 --> 00:52:22,410
>> I have to introduce, of course, the breakpoints.

676
00:52:22,410 --> 00:52:25,750
We're down to one breakpoint this particular year.

677
00:52:25,750 --> 00:52:30,600
Victor Alexander, the best slide
advance man in the business on keyboard.

678
00:52:30,600 --> 00:52:37,660
Big hand for Victor.

679
00:52:37,660 --> 00:52:37,720
[ Applause ]

680
00:52:37,720 --> 00:52:40,930
And just to note with Victor, because we've
been doing this for many years, people say,

681
00:52:40,930 --> 00:52:43,980
why is he the best slide advance man in the business?

682
00:52:43,980 --> 00:52:49,740
The reason is that he usually gets to slides
about 23 minutes before we walk on stage.

683
00:52:49,740 --> 00:52:51,040
And he does a wonderful job.

684
00:52:51,040 --> 00:53:00,730
So another round for Victor.

685
00:53:00,730 --> 00:53:00,790
[ Applause ]

686
00:53:00,790 --> 00:53:02,320
And thank you, again.

687
00:53:02,320 --> 00:53:04,060
Please make your apps accessible.

688
00:53:04,060 --> 00:53:06,160
And I hope you've enjoyed the session.

689
00:53:06,160 --> 00:53:06,480
Thanks.

