1
00:00:06,460 --> 00:00:07,760
>> Ben Nham: Hi I'm Ben Nham.

2
00:00:07,760 --> 00:00:10,410
I'm an engineer on the iPhone Performance team.

3
00:00:10,410 --> 00:00:14,880
This is Advanced Performance Optimization
on iPhone OS Part 2.

4
00:00:14,880 --> 00:00:21,110
Yesterday, we had Part 1 where we talked about making
your animations fluid, making your app responsive

5
00:00:21,110 --> 00:00:23,860
and also optimizing the power usage of your app.

6
00:00:23,860 --> 00:00:28,550
So if you didn't get a chance to go to that yesterday,
I highly recommend you take a look at that on video.

7
00:00:28,550 --> 00:00:33,140
Today, we're going to be talking
about working with data efficiently.

8
00:00:33,140 --> 00:00:40,830
And we're going to focus on working with that data both
in memory data structures and also taking that data

9
00:00:40,830 --> 00:00:47,960
and putting it on and off disk using
serialization and deserialization routines.

10
00:00:47,960 --> 00:00:50,270
We're going to focus on a few main themes.

11
00:00:50,270 --> 00:00:52,130
The first is measurement tools.

12
00:00:52,130 --> 00:00:57,710
We want you to be able to use our tools to find hot spots
in your code and then use those same tools to verify

13
00:00:57,710 --> 00:01:03,830
that any fix you've made has actually
had the desired impact.

14
00:01:03,830 --> 00:01:05,520
The next is mental models.

15
00:01:05,520 --> 00:01:09,710
We want you to build up some intuition about
how the system is put together and how it works.

16
00:01:09,710 --> 00:01:12,810
So you can preemptively write perform at code.

17
00:01:12,810 --> 00:01:15,490
And finally, there are a lot of frameworks on our system.

18
00:01:15,490 --> 00:01:19,150
So we're going to over a few of the best
practices for using these frameworks.

19
00:01:19,150 --> 00:01:25,940
We're going to start by talking about how to use memory
efficiently and then move on to talking about how

20
00:01:25,940 --> 00:01:29,940
to use the foundation framework
to manipulate data efficiently.

21
00:01:29,940 --> 00:01:36,420
We'll talk about how to profile the file system to make sure
you get the maximum amount of I/O speed from your device.

22
00:01:36,420 --> 00:01:40,470
Then move on to working with large datasets and databases.

23
00:01:40,470 --> 00:01:43,650
And finally, making sure your application works well

24
00:01:43,650 --> 00:01:48,780
with those large datasets and scales
to ever larger sizes of data.

25
00:01:48,780 --> 00:01:51,900
So let's start with memory.

26
00:01:51,900 --> 00:01:55,260
iOS isn't a desktop OS.

27
00:01:55,260 --> 00:01:57,780
iOS devices aren't desktop devices.

28
00:01:57,780 --> 00:02:03,320
As you can see in the chart, there's less memory
in an iOS device than on a desktop device.

29
00:02:03,320 --> 00:02:07,700
In addition, there are some architectural
differences between iOS and the desktop OS.

30
00:02:07,700 --> 00:02:10,720
For example, we have virtual memory
but we have no swap file.

31
00:02:10,720 --> 00:02:15,650
This actually has some interesting
implications that we'll get into later.

32
00:02:15,650 --> 00:02:19,400
There are also some features in iOS
that are not present on the desktop

33
00:02:19,400 --> 00:02:22,290
such as low memory notifications
which you have to handle gracefully.

34
00:02:22,290 --> 00:02:29,030
So let's take a look at a 128-megabyte
device such as the iPhone 3G.

35
00:02:29,030 --> 00:02:34,440
You can see that there are a lot of processes and
applications that are running in the background

36
00:02:34,440 --> 00:02:39,900
which you don't really have any control over that
are using memory even if your app isn't running.

37
00:02:39,900 --> 00:02:44,490
So in this example, a certain amount of
memory is wired in by the kernel depending

38
00:02:44,490 --> 00:02:47,930
on how much file activity or network activity you have.

39
00:02:47,930 --> 00:02:50,340
It could be a little more or a little less.

40
00:02:50,340 --> 00:02:54,810
There's always 12 megabytes allocated by the graphics card.

41
00:02:54,810 --> 00:02:58,230
Some amount of memory used by Daemons.

42
00:02:58,230 --> 00:03:00,870
Some may go away such as the sinking Daemons.

43
00:03:00,870 --> 00:03:08,550
Some of them stay around forever such as the ones
that listen to your phone calls or listen on--

44
00:03:10,550 --> 00:03:17,740
[laughter] the ones that listen on waiting for your
phone calls so you can listen to your phone calls.

45
00:03:17,740 --> 00:03:25,680
Of course, there's other programs even on iPhone 3G
which can run all the time such as phone, mail, iPad,

46
00:03:25,680 --> 00:03:31,990
and especially Safari which if you load a complex
web page can really take up quite a bit of memory.

47
00:03:31,990 --> 00:03:35,790
So your app might be asked to launch and
run in a pretty limited memory window.

48
00:03:35,790 --> 00:03:38,740
So it really pays to use memory efficiently.

49
00:03:38,740 --> 00:03:44,950
So let's go over a few of the vocabulary
terms that you'll have to understand

50
00:03:44,950 --> 00:03:48,110
to be able to really use our memory tools well.

51
00:03:48,110 --> 00:03:50,700
Let's start with Paging.

52
00:03:50,700 --> 00:03:57,600
Your process is split into 4 kilobyte chunks called
pages and those pages can be either nonresident,

53
00:03:57,600 --> 00:04:01,570
resident and clean, or resident and dirty.

54
00:04:01,570 --> 00:04:04,330
Page is resident if it's in physical memory.

55
00:04:04,330 --> 00:04:07,490
If it's nonresident, it's not using physical memory.

56
00:04:07,490 --> 00:04:11,730
And when you touch that nonresident
page, the kernel will take a page fault

57
00:04:11,730 --> 00:04:16,060
and bring that nonresident page into physical memory.

58
00:04:17,350 --> 00:04:22,280
Once that page is resident, it can either be clean or dirty.

59
00:04:22,280 --> 00:04:24,870
If it's dirty, it's probably anonymous memory.

60
00:04:24,870 --> 00:04:27,580
In other words, it just came out of thin air.

61
00:04:27,580 --> 00:04:29,880
For example, malloc memory.

62
00:04:29,880 --> 00:04:35,380
There's no file backing it at least on iOS so
that means that once a resident page is dirty,

63
00:04:35,380 --> 00:04:40,250
it just stays around forever until you
deallocate it or your application quits.

64
00:04:40,250 --> 00:04:44,830
So it's really important to keep
your dirty memory usage down.

65
00:04:44,830 --> 00:04:51,970
There's also file-backed memory such as the memory that
backs your code or if you explicitly memory map to file.

66
00:04:51,970 --> 00:04:54,710
And generally, this stays clean unless you modify it.

67
00:04:54,710 --> 00:04:59,690
And what that means is that the kernel can
drop references to those pages at will.

68
00:04:59,690 --> 00:05:03,930
So it's relatively free to use clean memory.

69
00:05:03,930 --> 00:05:08,130
Now if you use too much dirty memory,
it'll actually crowd out the clean memory

70
00:05:08,130 --> 00:05:11,370
that you have and that includes code pages.

71
00:05:11,370 --> 00:05:15,470
So if you use too much dirty memory, it turns
out that just bringing in the code needed

72
00:05:15,470 --> 00:05:18,750
to execute your program could take longer.

73
00:05:19,790 --> 00:05:24,960
So let's go through an example and just as a caveat,
some of these examples are a little dependent

74
00:05:24,960 --> 00:05:30,880
on your memory allocator but as a
simplification, most of these concepts are true.

75
00:05:30,880 --> 00:05:37,870
So in this case I've allocated two
pages from my malloc allocator.

76
00:05:37,870 --> 00:05:44,100
I've use valloc here which actually gives a page
align address but otherwise it's the same as malloc.

77
00:05:44,100 --> 00:05:46,490
So at first, those two pages are nonresident.

78
00:05:46,490 --> 00:05:48,710
They're not taking up any physical memory.

79
00:05:48,710 --> 00:05:53,500
As soon as I write to-- for example
the first byte in the first page,

80
00:05:53,500 --> 00:05:57,050
that page turns from nonresident into a resident dirty page.

81
00:05:57,050 --> 00:06:02,700
So it's going to stick around until
either my app exits or I free this memory.

82
00:06:02,700 --> 00:06:06,800
And similarly if I modify the second
page, it will take a page fault.

83
00:06:06,800 --> 00:06:15,370
It will be brought into physical memory and that page
will turn from nonresident into resident and dirty.

84
00:06:15,370 --> 00:06:19,760
With file-backed memory, if we map it
read-only which is the general case.

85
00:06:19,760 --> 00:06:25,550
If we explicitly map this file in
this example which is two-pages long

86
00:06:25,550 --> 00:06:29,430
into memory using dataWithContentsOfMappedFile.

87
00:06:29,430 --> 00:06:35,930
Again, those pages start out as nonresident if we
don't actually access the data from those pages.

88
00:06:35,930 --> 00:06:43,600
The moment we take any data from the first page, we're
going to bring the data from the file into memory

89
00:06:43,600 --> 00:06:47,540
and that page turns from nonresident to resident and clean.

90
00:06:47,540 --> 00:06:54,210
And similarly, the moment we reference any data
on the second page, we'll take another page fault

91
00:06:54,210 --> 00:06:59,700
and that page turns from nonresident to
resident and clean in physical memory.

92
00:06:59,700 --> 00:07:06,140
So where these concepts are really
useful are in our VM Tracker tool.

93
00:07:06,140 --> 00:07:13,900
This is part of the allocations template in Instruments
and these VM snapshots basically take a snapshot

94
00:07:13,900 --> 00:07:19,270
of you virtual memory usage out of
particular point in time in your application.

95
00:07:19,270 --> 00:07:25,710
You can either ask Instruments to snapshot
automatically at a time interval or by default,

96
00:07:25,710 --> 00:07:30,470
you actually have to trigger the snapshot
manually by clicking the snapshot Now button.

97
00:07:30,470 --> 00:07:38,860
As a word of caution, this actually works best in the
simulator right now in our particular build of iOS 4.

98
00:07:38,860 --> 00:07:45,190
So once you've taken these samples,
you'll get different samples over time.

99
00:07:45,190 --> 00:07:49,800
And what you're really looking for are
you'll see the different regions of memory

100
00:07:49,800 --> 00:07:53,020
in your application which we'll go over in a second.

101
00:07:53,020 --> 00:07:58,060
But what you're really looking for is
growing dirty memory usage over time.

102
00:07:58,060 --> 00:08:00,920
So in this case, I've started with 16 megabytes.

103
00:08:00,920 --> 00:08:05,630
I took another snapshot a little while
later and now I have 20 megabytes

104
00:08:05,630 --> 00:08:09,510
and now a little while later, I have 24 megabytes used.

105
00:08:09,510 --> 00:08:13,830
So this is indicative of perhaps a memory leak.

106
00:08:13,830 --> 00:08:19,260
Next we want to see which region was growing
in size, in this case, the malloc large region.

107
00:08:19,260 --> 00:08:22,790
So as you can see it's growing in size over time.

108
00:08:22,790 --> 00:08:28,540
So this is sort of indicating to you that this is
probably a region of memory that you want to focus on.

109
00:08:28,540 --> 00:08:34,720
So if you see malloc growing, we have a lot
of great tools to help you deal with that.

110
00:08:34,720 --> 00:08:41,620
There's the allocations template, the leaks template,
those are all great for looking for leaks in your heap.

111
00:08:41,620 --> 00:08:45,810
If you have Growing dirty_DATA, that's pretty unusual.

112
00:08:45,810 --> 00:08:49,050
Those are generally global variables that you've modified.

113
00:08:49,050 --> 00:08:53,540
So if you do have global variables, try to make sure
if they're constant, that they're really constant

114
00:08:53,540 --> 00:08:56,820
and then we'll put them into a read-only region.

115
00:08:56,820 --> 00:09:01,100
If you see Core Animation growing up
over time, you might have a view leak

116
00:09:01,100 --> 00:09:04,680
because each view is backed by Core Animation layer.

117
00:09:04,680 --> 00:09:10,460
And just as a final note, if you see TC malloc
taking up about 200 kilobytes in your application,

118
00:09:10,460 --> 00:09:13,320
you shouldn't be worried because that's fixed.

119
00:09:13,320 --> 00:09:17,790
JavaScript core uses that to execute
JavaScript and it always takes at least

120
00:09:17,790 --> 00:09:20,290
around 200 kilobytes even if you're not using a web view.

121
00:09:20,290 --> 00:09:27,800
I'm not going to have time to talk about all
these other memory measurement tools we had.

122
00:09:27,800 --> 00:09:33,640
We had an advanced memory analysis with Instruments
talk yesterday, that you should take a look at on video

123
00:09:33,640 --> 00:09:38,610
to learn more about these tools, there's
the leaks template, the allocations template

124
00:09:38,610 --> 00:09:41,680
and the zombies template which runs on the simulator.

125
00:09:41,680 --> 00:09:43,020
These help you find leaks.

126
00:09:43,020 --> 00:09:49,190
They help you find back traces for every single memory
allocation you've made in you applications lifetime

127
00:09:49,190 --> 00:09:54,910
and they also help you find any
references to over released memory.

128
00:09:54,910 --> 00:09:59,480
So please take a look at that talk if
you want to learn more about these tools.

129
00:09:59,480 --> 00:10:04,110
What I'm going to focus on is something
that's unique to iOS 4 if you're coming

130
00:10:04,110 --> 00:10:07,280
through the desktop and that's low memory warnings.

131
00:10:07,280 --> 00:10:15,010
If your application or perhaps the cumulative effect of all
the applications on the system, use too much dirty memory,

132
00:10:15,010 --> 00:10:21,620
a low memory warning will be fired and you have to
respond to this low memory warning in a graceful way.

133
00:10:21,620 --> 00:10:25,480
So let's go over how this works.

134
00:10:25,480 --> 00:10:31,860
As a total dirty memory in the system gets to a certain
threshold, your application will receive a warning.

135
00:10:31,860 --> 00:10:38,300
If it gets to another threshold, then you'll get
another warning and background apps will exit

136
00:10:38,300 --> 00:10:41,690
as we try to free up memory for your app.

137
00:10:41,690 --> 00:10:47,290
As you continue using dirty memory, for
example if you a leak that eventually will get

138
00:10:47,290 --> 00:10:51,550
to a critical threshold that can kill your app.

139
00:10:51,550 --> 00:10:57,870
So when you get a low memory warning, make sure
to release any objects that you can release,

140
00:10:57,870 --> 00:11:01,650
anything that can be reconstructed, anything that's cached.

141
00:11:01,650 --> 00:11:07,590
Don't ask the user to restart the app or restart the device.

142
00:11:07,590 --> 00:11:12,430
So there are a few places where you
can respond to low memory warnings.

143
00:11:12,430 --> 00:11:17,320
If you have-- or if you're using UIView
controllers, override viewDidUnload.

144
00:11:17,320 --> 00:11:21,600
Your app delegate will get an
applicationDidReceiveMemoryWarning callback

145
00:11:21,600 --> 00:11:27,080
and any object can register for a UIApplication
DidReceiveMemoryWarningNotification.

146
00:11:27,080 --> 00:11:34,510
Now I'm going to go over overriding
viewDidUnload in a bit more detail,

147
00:11:34,510 --> 00:11:38,770
because this can be a bit tricky
if you're new to the platform.

148
00:11:38,770 --> 00:11:45,130
When view controllers get a memory warning, if they're not
at the top of the navigation stack or if they're obscured

149
00:11:45,130 --> 00:11:48,640
in some way, they'll automatically release their views.

150
00:11:48,640 --> 00:11:58,020
But if you've retained subviews in some instance variables
or some outlets, you have to release those subviews for us.

151
00:11:58,020 --> 00:11:59,760
Let's go over an example.

152
00:11:59,760 --> 00:12:02,590
Suppose I have this navigation controller based app.

153
00:12:02,590 --> 00:12:07,960
At the bottom of the view controller
hierarchy, we have a ComposeViewController.

154
00:12:07,960 --> 00:12:13,290
And suppose I click on that photo and
slide a PhotoViewController on top.

155
00:12:13,290 --> 00:12:15,010
And now we get a memory warning.

156
00:12:15,010 --> 00:12:21,260
Well the ComposeViewController when it gets a
memory warning because it's not visible on screen,

157
00:12:21,260 --> 00:12:25,400
it'll automatically release the
view associated with it for you.

158
00:12:25,400 --> 00:12:30,620
But if you've retained the subviews
here, in this case, these are IBOutlets,

159
00:12:30,620 --> 00:12:35,290
these button labels and textViews, those won't go away.

160
00:12:35,290 --> 00:12:39,340
You have to manually release those in viewdidUnload.

161
00:12:39,340 --> 00:12:48,390
So assuming I have these four outlets here, titleLabel,
locationLabel, textView, imageButton as properties,

162
00:12:48,390 --> 00:12:55,950
in my viewDidUnload, to properly respond to the memory
warning, I'm going to set each of these properties to nil

163
00:12:55,950 --> 00:13:02,100
and as a side effect, that release my
references to each of these subviews.

164
00:13:03,190 --> 00:13:11,170
So now, when my ComposeViewController gets a memory warning,
it'll automatically release the view associated with it

165
00:13:11,170 --> 00:13:17,680
and then our viewDidUnload will release the remaining
references to the subviews and that's what we want.

166
00:13:17,680 --> 00:13:23,060
So it's really important that you test
out low memory warnings in the simulator.

167
00:13:23,060 --> 00:13:29,380
We've seen a lot of interesting behavior in responding
to low memory warnings even in the labs here.

168
00:13:29,380 --> 00:13:33,560
So make sure you test this out in many different ways.

169
00:13:33,560 --> 00:13:37,020
I just want to make a quick note
about interacting with multitasking.

170
00:13:37,020 --> 00:13:44,740
Of course, we've had several sessions on multitasking
here but when your application goes into the background,

171
00:13:44,740 --> 00:13:48,210
we don't preemptively, for example,
send a low memory warning.

172
00:13:48,210 --> 00:13:50,080
We let you make the tradeoff.

173
00:13:50,080 --> 00:13:55,180
And the tradeoff is multitasking is
supposed to be a fast app switching.

174
00:13:55,180 --> 00:13:59,610
So we want users to be able to
get back into your app quickly.

175
00:13:59,610 --> 00:14:04,100
But on the other hand, when your app is
in the background, it's using up memory.

176
00:14:04,100 --> 00:14:12,420
So you should try to release any easily reconstructed
resources in you applicationDidEnterBackrground call.

177
00:14:12,420 --> 00:14:16,580
On the other hand, if you release some
resource that's really expensive to recreate,

178
00:14:16,580 --> 00:14:19,610
that kind of defeats the purpose of
fast app switching because then you have

179
00:14:19,610 --> 00:14:23,490
to expensively recreate it when you become foreground.

180
00:14:23,490 --> 00:14:25,700
So this is a tradeoff you'll have to make.

181
00:14:25,700 --> 00:14:29,950
Make sure you play with this a
bit and release as many resources

182
00:14:29,950 --> 00:14:38,010
as you can possibly do reasonably
without making fast app switching slow.

183
00:14:41,630 --> 00:14:44,720
Now, I just want to talk a bit about image memory as well.

184
00:14:44,720 --> 00:14:49,720
In the past, we've had a slide here that has a
chart that doesn't really go over all the subtleties

185
00:14:49,720 --> 00:14:53,700
of image memory and really can cause a lot of confusion.

186
00:14:53,700 --> 00:14:58,560
So I've alleviated by removing the chart.

187
00:14:58,560 --> 00:15:01,470
And I'm just going to give you this general advice.

188
00:15:01,470 --> 00:15:08,810
If you use UIImage imageNamed, use that for read-only
resources that come out of your app bundle and are used

189
00:15:08,810 --> 00:15:12,820
as say background images for buttons
or you're going to use them to draw

190
00:15:12,820 --> 00:15:17,600
on the table view cells, things
that are used in UI elements.

191
00:15:17,600 --> 00:15:22,650
For everything else, UIImage, imageWithContentsOfFile
is generally good enough.

192
00:15:22,650 --> 00:15:26,290
We've removed a lot of the performance
differences between these methods

193
00:15:26,290 --> 00:15:29,260
so that this general advice is generally good enough.

194
00:15:29,260 --> 00:15:35,130
One thing I'd like to point out is that in iOS 4,

195
00:15:35,130 --> 00:15:40,340
we've made public the ImageIO framework
which has been on OS X since Tiger.

196
00:15:40,340 --> 00:15:47,020
And one of the nice features of ImageIO is if
you're creating thumbnails of large images,

197
00:15:47,020 --> 00:15:53,660
it can do so quickly in both-- or
efficiently in both space and time.

198
00:15:53,660 --> 00:16:02,140
So to use this, you create a CGUmageSourceRef which
encapsulates the deserialization of the image.

199
00:16:02,140 --> 00:16:09,450
And then you pass in this options dictionary which asks
the image source to create a thumbnail and also the size

200
00:16:09,450 --> 00:16:14,780
of that thumbnail and out pops a
CGImageRef that's the thumbnail.

201
00:16:14,780 --> 00:16:22,800
And this is as I said efficiently uses memory so that if
you create a thumbnail out of a say 2 megapixel image,

202
00:16:22,800 --> 00:16:28,280
you'll use much less memory than if you
just deserialize that 2 megapixel image

203
00:16:28,280 --> 00:16:32,830
and then use ports to draw that into a 44 by 44 context.

204
00:16:32,830 --> 00:16:35,520
So if you want to know more about this,

205
00:16:35,520 --> 00:16:40,450
refer to the Creating a Thumbnail Image
section of the Image I/O Programming Guide.

206
00:16:40,450 --> 00:16:47,780
This is a code snippet but that it'll go over all
the caveats of using CGImageSource in this way.

207
00:16:47,780 --> 00:16:54,750
So in summary, drive down the dirty
memory usage of your app.

208
00:16:54,750 --> 00:16:56,060
It causes memory warnings.

209
00:16:56,060 --> 00:17:02,340
It crowds out clean memory that could be
used to for example execute code in your app.

210
00:17:02,340 --> 00:17:03,970
Respond to memory warnings correctly.

211
00:17:03,970 --> 00:17:09,630
And release resources as necessary
when entering a background.

212
00:17:09,630 --> 00:17:15,570
We have a few additional user guides but really
what I'd really urge you to do is to take a look

213
00:17:15,570 --> 00:17:20,200
at Advanced Memory Analysis with
Instruments talk on video afterwards.

214
00:17:20,200 --> 00:17:24,840
So next let's talk about Foundation.

215
00:17:24,840 --> 00:17:29,350
Foundation has a lot of the objects
we care about including NSObject.

216
00:17:29,350 --> 00:17:34,190
But let's go over some of the collection
performance characteristics

217
00:17:34,190 --> 00:17:38,150
of the collections inside Foundation
starting with NSMutableArray.

218
00:17:38,150 --> 00:17:44,340
Arrays have pretty textbook performance
characteristics in our system

219
00:17:44,340 --> 00:17:49,440
but there is one unique performance characteristics that
I want to point out which is that inserting or deleting

220
00:17:49,440 --> 00:17:55,330
at the beginning of an array is amortized constant
time which means you can use an array as a queue

221
00:17:55,330 --> 00:17:57,910
or as double ended queue pretty efficiently.

222
00:17:57,910 --> 00:18:03,160
This is of course not true for most arrays you've probably
dealt with in the past if you're new to our framework.

223
00:18:03,160 --> 00:18:09,360
So before rolling your own queue, you can try
NSMutableArray first and it probably will be good enough.

224
00:18:09,360 --> 00:18:14,590
There is also another interesting thing which is
that if you insert 250,000 elements into your array,

225
00:18:14,590 --> 00:18:22,240
it becomes a tree but if you did that, let us know.

226
00:18:22,240 --> 00:18:24,340
Strings work a lot like arrays.

227
00:18:24,340 --> 00:18:26,400
Indexed access is constant time.

228
00:18:26,400 --> 00:18:30,540
It's going to be a load plus a load at an offset probably.

229
00:18:30,540 --> 00:18:32,710
Inserting or deleting the middle is linear time.

230
00:18:32,710 --> 00:18:35,200
Inserting or deleting at the end is constant time.

231
00:18:35,200 --> 00:18:42,190
This is all pretty similar to any other mutable
string class you've probably dealt with in the past.

232
00:18:42,190 --> 00:18:45,640
Dictionaries also work like most
other well-behaved dictionaries.

233
00:18:45,640 --> 00:18:53,210
If you have a good hash function, all the major mutation
functions or lookup functions such as lookup, insertion,

234
00:18:53,210 --> 00:18:57,690
replacement, removal, those are all constant time.

235
00:18:57,690 --> 00:19:01,420
But with a bad hash function, you
turn your dictionary into an array.

236
00:19:01,420 --> 00:19:06,500
And in particular, that means that
a lookup turns into a linear search.

237
00:19:06,500 --> 00:19:10,930
So what do I mean by bad hash function?

238
00:19:10,930 --> 00:19:16,270
If your return a constant value, that's a bad hash function.

239
00:19:16,270 --> 00:19:21,010
If you return a random value, that's a broken hash function.

240
00:19:21,010 --> 00:19:26,310
It's actually really hard to give good general advice about
hash functions because there are whole courses about how

241
00:19:26,310 --> 00:19:34,770
to write optimal hash functions but most of you apply the
making custom objects that are compositions of objects

242
00:19:34,770 --> 00:19:38,460
that we give you such as UIViews or arrays or dictionaries.

243
00:19:38,460 --> 00:19:45,660
In this case, I have this example where we have this array
dict that has instance variables and array and a dictionary.

244
00:19:45,660 --> 00:19:51,770
And of course we implement hash for you on
these objects efficiently and correctly.

245
00:19:51,770 --> 00:19:57,410
So if you don't know any better, you can try just
XORing the hash of each of these instance variables

246
00:19:57,410 --> 00:20:03,570
that you have and that's usually good enough.

247
00:20:03,570 --> 00:20:06,250
In addition, you should make sure
the hash function runs quickly,

248
00:20:06,250 --> 00:20:10,050
because as the dictionary grows we may have
to increase the size of the dictionary.

249
00:20:10,050 --> 00:20:14,580
At which point, we have to rehash all
the existing values in the dictionary.

250
00:20:14,580 --> 00:20:19,880
So stick to pretty fast operations
adding, shifting, masking or XORing.

251
00:20:19,880 --> 00:20:26,450
And remember the API contract, when you call
-setObject:forKey, your key will be copied.

252
00:20:26,450 --> 00:20:30,830
So respond to NSCopying in some same way.

253
00:20:30,830 --> 00:20:35,220
In addition, objects that are equal
must return the same hash.

254
00:20:35,220 --> 00:20:38,230
If you don't follow this, your dictionary won't work.

255
00:20:38,230 --> 00:20:41,810
Now that we've talked about some of the
performance characteristics of these collections,

256
00:20:41,810 --> 00:20:44,970
let's take a look at some of these
perhaps tips and tricks about how

257
00:20:44,970 --> 00:20:48,460
to use this collections in the most performant way.

258
00:20:48,460 --> 00:20:56,530
And the first is if you're storing a lot of integers into
your collection, one way to do it is by boxing each integer

259
00:20:56,530 --> 00:21:02,170
into an NS number and passing it on to
your NSSet or NSMutableArray or so forth.

260
00:21:02,170 --> 00:21:07,550
But you can actually bypass this integer boxing
step by using the correct data structure.

261
00:21:07,550 --> 00:21:12,230
So NSIndexSet is built to work with integers natively.

262
00:21:12,230 --> 00:21:18,930
In addition, core foundation collections can work
with pointer size integers if you cast those integers

263
00:21:18,930 --> 00:21:27,120
into pointers by passing NULL into the
callbacks parameter of the constructor.

264
00:21:27,120 --> 00:21:34,010
So in this example, to create an array that stores
integers natively without boxing to NSNumbers,

265
00:21:34,010 --> 00:21:42,450
I can call CFArrayCreateMutable using default allocator
with no capacity restriction and NULL as the callbacks.

266
00:21:42,450 --> 00:21:50,900
And I just cast my integer into a pointer and I can
just add and remove and modify my array without boxing.

267
00:21:50,900 --> 00:21:56,300
So if you do this enough, it can actually add up.

268
00:21:56,300 --> 00:21:59,290
These timings are taken from the iPhone 3G.

269
00:21:59,290 --> 00:22:05,290
If you box and store 1000 NSNumbers
into a set, it takes 30 milliseconds.

270
00:22:05,290 --> 00:22:08,670
If you don't box the integers and just store them natively

271
00:22:08,670 --> 00:22:14,630
into a mutable index set or a mutable
set, it's 10 times faster.

272
00:22:14,630 --> 00:22:20,290
So these are one of those things that might add up over
time if you box a lot of integers in your application.

273
00:22:20,290 --> 00:22:25,470
Next, let's talk about bulk operations.

274
00:22:25,470 --> 00:22:32,130
I've told you that some of these methods such as
objectAtIndex or characterAtIndex are efficient.

275
00:22:32,130 --> 00:22:34,350
They're constant time.

276
00:22:34,350 --> 00:22:38,570
But there is a message sending overhead to
calling these methods over and over again.

277
00:22:38,570 --> 00:22:43,580
So for example, if you want to call NSString
characterAtIndex over and over again,

278
00:22:43,580 --> 00:22:49,800
perhaps you should instead call getCharacters
range and just inspect the range you care about.

279
00:22:49,800 --> 00:22:55,940
Get that range into a C buffer and inspect
the buffer using standard C indexing.

280
00:22:55,940 --> 00:22:58,260
That can be up to 3 times faster.

281
00:22:58,260 --> 00:23:05,210
Even better, hopefully there's a method inside these
classes that does exactly what you want such as

282
00:23:05,210 --> 00:23:10,170
if you want prefix search, you might just want
to call hasPrefix rather than writing your own.

283
00:23:10,170 --> 00:23:16,190
So make sure you inspect the API and
select the highest level API possible

284
00:23:16,190 --> 00:23:20,350
because it's probably already implemented
in the most performant way for you.

285
00:23:20,350 --> 00:23:31,420
One thing I want to point out in particular is that strings
now have regular expression support finally in iOS 4.

286
00:23:31,420 --> 00:23:34,010
We've made them really easy for
you to use regular expressions.

287
00:23:34,010 --> 00:23:40,280
You can use the existing NSString methods and pass this
NSRegularExpression search option and all of a sudden,

288
00:23:40,280 --> 00:23:43,510
your substring search turns into
a regular expression search.

289
00:23:43,510 --> 00:23:45,840
And this is great for one-off searches.

290
00:23:45,840 --> 00:23:51,230
But if you're going to look for the same
pattern in many different strings, use--

291
00:23:51,230 --> 00:23:53,880
create an NSRegularExpression object

292
00:23:53,880 --> 00:23:59,030
and use the enumerateMatchesInString
options range using block method instead.

293
00:23:59,030 --> 00:24:04,200
And the reason for that is parsing
a regular expression takes some time

294
00:24:04,200 --> 00:24:08,070
and sets up some state that you
don't want to continually pay.

295
00:24:08,070 --> 00:24:14,810
If you use the regular expression object, you
additionally had these options NSMatchingReportProgress.

296
00:24:14,810 --> 00:24:21,460
We'll call this block back even if you don't get
a match periodically and you can write to the stop

297
00:24:21,460 --> 00:24:28,420
out parameter the-- you can write yes to the stop
out parameter to stop the search prematurely.

298
00:24:28,420 --> 00:24:34,510
Regular expressions are an example of objects
which are a bit expensive to reinitialize

299
00:24:34,510 --> 00:24:36,340
over and over again with the same parameters.

300
00:24:36,340 --> 00:24:42,350
They are examples of objects that you should keep
around if you're going to use again and again.

301
00:24:42,350 --> 00:24:47,100
Date formatters and number formatters
are the other usual example of this.

302
00:24:47,100 --> 00:24:54,030
So here's an example where we have a table view
cell that shows a month and one way to do this is

303
00:24:54,030 --> 00:24:59,490
to just create a table-- create a date formatter
for every table view cell that comes on screen.

304
00:24:59,490 --> 00:25:03,710
Set its date format to the month
day format and use that formatter

305
00:25:03,710 --> 00:25:09,090
to format the month string and
this works but it's not performant.

306
00:25:09,090 --> 00:25:13,550
Instead, you should lazily create that date formatter
if you're going to use it over and over again.

307
00:25:13,550 --> 00:25:18,770
In this sample code, the first time you call
monthFormatter, it will create the monthFormatter.

308
00:25:18,770 --> 00:25:21,930
Every subsequent time, it'll return the
monthFormatter that's already created

309
00:25:21,930 --> 00:25:27,950
and then we can use this function
to format our date performantly.

310
00:25:31,510 --> 00:25:34,690
There are some gotchas with doing this.

311
00:25:34,690 --> 00:25:41,150
In particular in iOS 4, the user can change
their locale without exiting your app.

312
00:25:41,150 --> 00:25:43,200
So you have to listen

313
00:25:43,200 --> 00:25:48,130
to the NSCurrentLocaleDidChangeNotification
if you're caching date formatters.

314
00:25:48,130 --> 00:25:52,490
In this case, I've just released and
nilled out the formatter I created

315
00:25:52,490 --> 00:25:56,250
so that it'll be recreated after
the user changes their locale.

316
00:25:56,250 --> 00:26:02,260
In addition, date and number formatters aren't thread-safe
so you need to either use locking or create a separate one

317
00:26:02,260 --> 00:26:05,840
for each thread that you're using these cache formatters on.

318
00:26:05,840 --> 00:26:10,970
But do note that regular expressions and data detectors
are thread-safe so you don't have to worry about locking

319
00:26:10,970 --> 00:26:14,720
or creating different ones for different threads there.

320
00:26:18,410 --> 00:26:23,770
So again, just to drive this point home, if you
would take 100 date formatters and use each of them

321
00:26:23,770 --> 00:26:30,110
to format the same date one time, it's about five to
six times slower that taking a single day formatter

322
00:26:30,110 --> 00:26:34,120
and formatting-- and using that to format 100 dates.

323
00:26:36,790 --> 00:26:38,830
Next, let's talk about property lists.

324
00:26:38,830 --> 00:26:44,580
These are really convenient way of serializing
and deserializing object graphs in Foundation.

325
00:26:44,580 --> 00:26:49,940
They're so convenient that you might be tempted to
use the right to file atomically methods on each

326
00:26:49,940 --> 00:26:53,450
of these collections, arrays, dictionaries, and strings.

327
00:26:53,450 --> 00:26:58,860
These are really convenient but you shouldn't
use them because they produce XML plists.

328
00:26:58,860 --> 00:27:03,270
And XML plists are two to three times
slower to decode that binary plists.

329
00:27:03,270 --> 00:27:10,300
So if you create plist at run time, make sure you
use NSPropertyListSerialization and explicitly pass

330
00:27:10,300 --> 00:27:18,400
in the NSPropertyListBinaryFormat_v1_0-- that'll
create a binary plist from your object graph.

331
00:27:18,400 --> 00:27:23,510
And then from that, the data you get back,
you can write that out to disk as you please.

332
00:27:23,510 --> 00:27:30,360
[ Pause ]

333
00:27:30,360 --> 00:27:33,310
So plists are not an incremental format.

334
00:27:33,310 --> 00:27:39,640
What that means is if you want to access a single value
out of a plist, we have to take that entire object graph

335
00:27:39,640 --> 00:27:45,180
into the plist, bring in some memory
before you can access that one element.

336
00:27:45,180 --> 00:27:49,810
Similarly, when you're writing out the plist,
if you modify a single element in the plist,

337
00:27:49,810 --> 00:27:55,080
we have to write out the entire object
graph just to signify that one change.

338
00:27:55,080 --> 00:28:03,890
So plists are great for small sets of objects, dozens of
objects, maybe hundreds of objects, no more than that.

339
00:28:03,890 --> 00:28:08,810
If you need to really encode a really large object
graph, you should probably be looking at a database

340
00:28:08,810 --> 00:28:11,880
or Core Data because those will be incremental.

341
00:28:11,880 --> 00:28:18,600
They'll only bring the data you care about into memory
and only write the changes that you made out to disk.

342
00:28:18,600 --> 00:28:20,690
Related to plist is NSCoding.

343
00:28:20,690 --> 00:28:25,480
NSCoding has the advantage that it's
not restricted to plistable types.

344
00:28:25,480 --> 00:28:34,190
It's-- You can define your own archiver essentially,
or your own encoder to encode your own custom types.

345
00:28:34,190 --> 00:28:39,070
And again this is generally not an incremental format.

346
00:28:39,070 --> 00:28:46,170
To access one object out of an archive, you generally have
to bring-- deserialize all the objects out of that archive.

347
00:28:46,170 --> 00:28:48,630
Keep this to small object graphs.

348
00:28:48,630 --> 00:28:55,040
Don't encode thousands of objects using NSCoding and this
is a time profile I actually pulled from a top 10 app.

349
00:28:55,040 --> 00:29:00,840
I know this was quitting pretty slowly and you can
actually see it's taking about 400 milliseconds

350
00:29:00,840 --> 00:29:05,120
to archive some large object graph at quit time.

351
00:29:05,120 --> 00:29:14,830
So really runtime profiler, make sure you're not blocked
on CPU and encoding or decoding these large object graphs

352
00:29:14,830 --> 00:29:20,760
with NSCoding because they can take
quite a while to encode or decode.

353
00:29:20,760 --> 00:29:26,820
Even if you don't explicitly use NSCoding, you're
probably implicitly using them by using NIBs.

354
00:29:26,820 --> 00:29:33,100
And the way you can keep the NSCoding usage down
in NIBs just to make sure your NIBs are lean,

355
00:29:33,100 --> 00:29:39,520
don't put objects in your NIB that aren't
associated with the files owner of that NIB.

356
00:29:42,950 --> 00:29:49,950
In iOS 4, we've added this new class called
UINib that actually lets you deserialize objects

357
00:29:49,950 --> 00:29:55,010
from the same NIB repeatedly over
and over again much faster.

358
00:29:55,010 --> 00:29:59,050
This is mostly used for table view cell NIBs.

359
00:29:59,050 --> 00:30:06,040
So in this example, I took this table view cell from the
advanced table view cells example and that's on the left.

360
00:30:06,040 --> 00:30:10,260
On the right, you can see the NIB
that that table view cell came from.

361
00:30:10,260 --> 00:30:16,220
So in our tableView cellForRowAtIndexPath, we have to
load the cell from the NIB if it's not in the reuse queue.

362
00:30:16,220 --> 00:30:25,530
So the previous way of doing this would be the-- called the
Foundation method, loadNibNamed, owner, options on NSBundle

363
00:30:25,530 --> 00:30:31,050
and this works if you're only viewing it once, if
you're only creating an object out of this NIB once.

364
00:30:31,050 --> 00:30:33,280
This is perfectly fine.

365
00:30:33,280 --> 00:30:37,690
But if you're creating for example a table
view cell, you're probably going to create

366
00:30:37,690 --> 00:30:40,500
that table view cell out of the NIB many times.

367
00:30:40,500 --> 00:30:48,570
So you want to use the UINib class to cache some
state associated with repeatedly instantiating NIBs

368
00:30:48,570 --> 00:30:56,980
and ask the UINib instance for the objects in that NIB
instead of asking the bundle for the objects in that NIB.

369
00:30:59,740 --> 00:31:06,380
And again, this takes-- this makes NIB loading
about 33 percent faster if you're going

370
00:31:06,380 --> 00:31:10,720
to load the same resource out of a NIB over and over again.

371
00:31:10,720 --> 00:31:18,330
So in summary, most of the Foundation types have
pretty good performance if you use them correctly.

372
00:31:18,330 --> 00:31:20,630
So understand the API.

373
00:31:20,630 --> 00:31:24,290
Make sure you call the highest level API possible.

374
00:31:24,290 --> 00:31:29,220
Avoid reinitializing expensive classes
such as date formatters over and over again

375
00:31:29,220 --> 00:31:32,300
if you're going to use them over and over again.

376
00:31:32,300 --> 00:31:39,540
And finally, make sure you restrict your use plist
and NSCoding to relatively small object graphs.

377
00:31:39,540 --> 00:31:48,740
We ship a lot of user guides with our SDK that let you know
how to use collections, property lists, NSCoding and NIBs,

378
00:31:48,740 --> 00:31:52,250
so take a look at those if you have more questions.

379
00:31:52,250 --> 00:31:55,570
We also had an Understanding Foundation session yesterday

380
00:31:55,570 --> 00:31:58,960
that you should look at on video
if you're new to Foundation.

381
00:31:58,960 --> 00:32:01,710
Next, let's talk about the filesystem.

382
00:32:01,710 --> 00:32:09,510
The first thing you should probably do if you think you have
a filesystem performance issue is run the System Usage tool.

383
00:32:09,510 --> 00:32:12,060
And what this does is it prints out a list

384
00:32:12,060 --> 00:32:17,140
of all the filesystem related system
calls your application has made along

385
00:32:17,140 --> 00:32:20,520
with the backtrace that caused that system call.

386
00:32:20,520 --> 00:32:31,310
So this is a great place to look for unexpected I/O and
figure out what backtrace caused that unexpected I/O.

387
00:32:31,310 --> 00:32:36,090
There's one caveat with this which is that if you're
using memory mapped files, it doesn't yet show bytes

388
00:32:36,090 --> 00:32:41,510
that were read in-- caused by paging
in bytes from the memory mapped file.

389
00:32:41,510 --> 00:32:45,560
So some best practices for working with the Filesystem,

390
00:32:45,560 --> 00:32:50,170
you should definitely test your
application on different types of devices.

391
00:32:50,170 --> 00:32:57,040
We've advertised that the 3GS is two times
faster than the 3G in CPU and there are--

392
00:32:57,040 --> 00:33:01,880
also very significant performance
differences in read and write performance.

393
00:33:01,880 --> 00:33:08,900
So you really need to make sure you test application
on an iPhone 3G if you're targeting an iPhone 3G.

394
00:33:08,900 --> 00:33:16,950
In addition, if you're doing really long blocking
I/Os just as with any other long blocking operation,

395
00:33:16,950 --> 00:33:21,350
move them off the main thread using
any of our threading APIs,

396
00:33:21,350 --> 00:33:25,530
Grand Central Dispatch, NSOperations queues and so forth.

397
00:33:25,530 --> 00:33:31,490
But if you are really doing a really long
I/O, say with NSData dataWithContentsOfFile,

398
00:33:31,490 --> 00:33:35,370
you might not want to call that
method with a really large file.

399
00:33:35,370 --> 00:33:39,940
For example, if I call dataWithContentsOfFile
on a 10 megabyte file,

400
00:33:39,940 --> 00:33:44,860
we're going to allocate a 10 megabyte
buffer inside your application.

401
00:33:44,860 --> 00:33:51,640
We're going to block your application until we can read all
those 10 megabytes into that buffer in your application.

402
00:33:51,640 --> 00:33:55,290
Instead, you should probably use
dataWithContentsofMappedFile

403
00:33:55,290 --> 00:33:59,110
and that will return almost immediately.

404
00:33:59,110 --> 00:34:03,820
And we'll use the virtual memory subsystem
to demand page in data from that file

405
00:34:03,820 --> 00:34:07,270
as you touch the data as we talked
about earlier in the talk.

406
00:34:07,270 --> 00:34:13,010
In addition, if we you want to use standard
seat based I/O, you can use NSFileHandle.

407
00:34:13,010 --> 00:34:21,610
One last point here is that if you're repeatedly opening
or statting a path inside the system usage instrument,

408
00:34:21,610 --> 00:34:28,590
you probably shouldn't do that because opening or
statting paths incurs an additional permissions check

409
00:34:28,590 --> 00:34:33,150
above the usual UNIX permissions
check in our system where we base--

410
00:34:33,150 --> 00:34:37,860
we recheck whether your app has access to that path.

411
00:34:37,860 --> 00:34:42,630
So don't recursively enumerate a
directory with say a thousand files

412
00:34:42,630 --> 00:34:45,110
and ask for the modification date on all those files.

413
00:34:45,110 --> 00:34:47,390
That's probably going to be a bit slow.

414
00:34:47,390 --> 00:34:58,640
To actually get paths into Filesystem, we have a few APIs,
NSBundle gives you paths inside your read-only app bundle.

415
00:34:58,640 --> 00:35:02,550
If you want to store user defaults, you
probably should use NSUserDefaults rather

416
00:35:02,550 --> 00:35:07,570
than any home-grown default system
because those will be backed up for you.

417
00:35:07,570 --> 00:35:13,920
If you want writable paths, usually you'll
use NSSearchPathForDirectoriesInDomain

418
00:35:13,920 --> 00:35:17,900
and you should pick the right directory
for the type of data you're storing.

419
00:35:17,900 --> 00:35:24,380
If you're storing persistent user-related data,
use NSDocumentDirectory because it gets backed up.

420
00:35:24,380 --> 00:35:29,460
It stays between launches and it's always there.

421
00:35:29,460 --> 00:35:31,980
NSUserDefaults is the same.

422
00:35:31,980 --> 00:35:37,720
If you just need some data that can be reconstructed,
you should probably put in NSCachesDirectory

423
00:35:37,720 --> 00:35:42,040
because it won't be backed up and won't
affect the user backup performance.

424
00:35:42,040 --> 00:35:49,130
And finally, if you just need to scribble somewhere for this
particular invocation of the app, use NSTemporaryDirectory.

425
00:35:49,130 --> 00:35:55,000
One thing I want to point is that you should
not be constructing arbitrary paths outside

426
00:35:55,000 --> 00:35:58,100
of your application sandbox and writing to them.

427
00:35:58,100 --> 00:36:02,490
That's a system protected interface
and it's not guaranteed to work.

428
00:36:02,490 --> 00:36:07,810
Even if you can write to a particular path outside
of your sandbox now and in the next release,

429
00:36:07,810 --> 00:36:14,630
you might not be able to and your app will break, the
customers will get angry, all sorts of sadness will ensue.

430
00:36:14,630 --> 00:36:18,250
So don't do that.

431
00:36:18,250 --> 00:36:24,180
So in summary, start with the System Usage
tool, look for any unexpected I/Os and figure

432
00:36:24,180 --> 00:36:28,110
out from the backtrace what caused those unexpected I/Os.

433
00:36:28,110 --> 00:36:35,110
If you have really large files, try to pick an incremental
format or you can try using the memory mapped file option

434
00:36:35,110 --> 00:36:39,850
to demand page in that large file as necessary.

435
00:36:39,850 --> 00:36:46,240
And as with any other long lasting operation,
perform your long I/Os off the main thread.

436
00:36:49,430 --> 00:36:53,850
Next, let's talk about manipulating
large datasets and databases.

437
00:36:54,970 --> 00:36:59,090
We really like databases because they let
you bring just the information you care

438
00:36:59,090 --> 00:37:02,940
about into memory rather than entire data set into memory.

439
00:37:02,940 --> 00:37:10,690
There're also additional features that databases give
you, transactional storage, isolation, durability,

440
00:37:10,690 --> 00:37:14,570
those are all great properties for a persistent data store.

441
00:37:14,570 --> 00:37:20,500
And we really recommend you use Core Data if possible if
you're creating a new application because we've taken a lot

442
00:37:20,500 --> 00:37:24,050
of the grudge work of using databases in Core Data.

443
00:37:24,050 --> 00:37:25,820
There is automatic schema management.

444
00:37:25,820 --> 00:37:31,410
There is also iPhone specific enhancements for
example table view section loading is faster

445
00:37:31,410 --> 00:37:35,560
in Core Data because we especially optimized it.

446
00:37:35,560 --> 00:37:41,680
The Native SQLite library is available if you
want to work with databases directly but just note

447
00:37:41,680 --> 00:37:46,380
that it's much more low level and requires more care.

448
00:37:46,380 --> 00:37:50,220
No matter what framework you choose
though, you must have the same data model.

449
00:37:50,220 --> 00:37:53,690
So understand some of the basic concepts in data modeling.

450
00:37:53,690 --> 00:38:00,470
I've referenced this object modeling guide inside
the Cocoa Fundamentals Guide which talks about some

451
00:38:00,470 --> 00:38:06,420
of the key concepts such as one-to-one relationships,
one-to-many relationships, many-to-many relationships.

452
00:38:06,420 --> 00:38:10,890
You should understand these if you want to
be able to create a performant data model.

453
00:38:10,890 --> 00:38:17,240
What I'm going to talk about a bit more is actually
SQLite because we haven't had as much coverage of SQLite

454
00:38:17,240 --> 00:38:21,460
and we know that some of you are
still using it rather than Core Data.

455
00:38:21,460 --> 00:38:27,680
If you are using Core Data, please watch the Understanding
Performance in Core Data session from yesterday.

456
00:38:27,680 --> 00:38:35,740
So the first thing you should do if you have a performance
issue in SQLite is to run the sqlite3_profile function

457
00:38:35,740 --> 00:38:44,110
and this will install a profiling method which calls back
the profile function every time a statement executes along

458
00:38:44,110 --> 00:38:48,050
with an estimate of how long that statement took to execute.

459
00:38:48,050 --> 00:38:54,570
So in this case, the profile function just prints out
the SQL statement along with how long it took to execute.

460
00:38:54,570 --> 00:38:59,810
This is really helpful for finding
out if you have a lot of slow queries

461
00:38:59,810 --> 00:39:06,630
or maybe just one really slow query
that you should be concentrating on.

462
00:39:06,630 --> 00:39:11,770
In addition, you should keep in mind that prepared
statements in SQLite are really little programs.

463
00:39:11,770 --> 00:39:20,500
Every time you call SQLite3 prepare, you're really
compiling a little program for a SQLite to interpret.

464
00:39:20,500 --> 00:39:24,610
So you can actually even see the
instructions of this program

465
00:39:24,610 --> 00:39:30,520
by prepending the statement with
EXPLAIN in the SQLite shell tool.

466
00:39:30,520 --> 00:39:35,410
So what this means is you probably don't want
to recompile programs over and over again.

467
00:39:35,410 --> 00:39:39,300
So likewise, you don't want to prepare
statements over and over again.

468
00:39:39,300 --> 00:39:45,380
So if you're going to use a prepared
statement repeatedly, keep it in memory.

469
00:39:45,380 --> 00:39:50,800
Conversely, if you're not going to use the prepared
statement over and over again, you should release it.

470
00:39:50,800 --> 00:39:56,630
We've actually seen some applications that keep every
single prepared statement they've ever created in memory

471
00:39:56,630 --> 00:40:04,260
and then 1,000, 2,000, 3,000 statements later, the app
gets terminated because that memory was never released.

472
00:40:06,710 --> 00:40:17,230
So if you used sqlite3_profile to find an offending
query and you've prepared your query efficiently,

473
00:40:17,230 --> 00:40:23,740
the next thing you want to do is use EXPLAIN QUERY PLAN or
EXPLAIN to actually understand what SQLite is doing execute

474
00:40:23,740 --> 00:40:30,790
that query and you could do this by
opening your database on your Mac

475
00:40:30,790 --> 00:40:35,280
and prepending the statement with
EXPLAIN QUERY PLAN or EXPLAIN.

476
00:40:35,280 --> 00:40:41,040
And one of the things you'll notice when you do this
is that if you switch the order of tables in a JOIN,

477
00:40:41,040 --> 00:40:46,880
you might not be able to affect the order in which SQLite
traverses the table, so this might be something you want

478
00:40:46,880 --> 00:40:50,940
to play with if you have a JOIN that's slow.

479
00:40:50,940 --> 00:40:55,100
In addition, watch out for transient tables.

480
00:40:55,100 --> 00:41:01,370
If you explain a statement and you see an OpenEphemeral
instruction, you've created a temporary table

481
00:41:01,370 --> 00:41:05,010
for the lifetime of that particular statement.

482
00:41:05,010 --> 00:41:12,610
So these can cause pretty big performance issues if you've
created a temporarily table of many thousands of rows in it.

483
00:41:12,610 --> 00:41:18,530
Usually these come from sorting a
table without an index or subselects

484
00:41:18,530 --> 00:41:24,490
and that can cause the first sqlite3_step
to take a pretty long time.

485
00:41:24,490 --> 00:41:27,250
So let's go over an example.

486
00:41:27,250 --> 00:41:31,810
Here we have a sample schema from a music player.

487
00:41:31,810 --> 00:41:33,300
There's a track.

488
00:41:33,300 --> 00:41:35,170
Each track has an album.

489
00:41:35,170 --> 00:41:37,400
Albums could have many tracks.

490
00:41:37,400 --> 00:41:46,480
Each track also has an artist and
artists could have authored many tracks.

491
00:41:46,480 --> 00:41:51,780
So without any indices, a Naive
query plan might look like this.

492
00:41:51,780 --> 00:41:57,850
I open my database up in the SQLite
tool on my Mac and I EXPLAIN QUERY PLAN,

493
00:41:57,850 --> 00:42:03,250
SELECT * FROM Track WHERE AlbumID is a
particular album ordered by AlbumOrder

494
00:42:03,250 --> 00:42:09,400
and what that means is select all the tracks
in an album and sort that album by track order.

495
00:42:09,400 --> 00:42:12,780
That's a pretty simple and reasonable query.

496
00:42:12,780 --> 00:42:18,960
Without any indices, it's telling me that it's going to
do a table scan of track and what that's going to look

497
00:42:18,960 --> 00:42:25,610
like is actually we're going to go over every row
in that table and then we're going to find the rows

498
00:42:25,610 --> 00:42:30,490
that match the album we care about,
in this case AlbumID of 2.

499
00:42:30,490 --> 00:42:36,060
We're going to move that result set into
a transient table and then we're going

500
00:42:36,060 --> 00:42:39,430
to sort it to satisfy the order by criterion.

501
00:42:39,430 --> 00:42:41,040
And that's pretty inefficient.

502
00:42:41,040 --> 00:42:51,060
So perhaps you've worked with databases
before and, you know, well,

503
00:42:51,060 --> 00:42:55,260
I have a where clause on this albumID,
I need an index on albumID.

504
00:42:55,260 --> 00:43:02,220
And that's great because now when we look for all
albums with AlbumID=2, we're got a logarithmic--

505
00:43:02,220 --> 00:43:10,440
in logarithmic time, we're going to jump to AlbumID=2 in the
index and we're going to use that to select all the albums,

506
00:43:10,440 --> 00:43:13,820
all the tracks in that album from the track table.

507
00:43:13,820 --> 00:43:22,780
But again, we've iterated over those tracks in unsorted
order so we have to create a temporary table that holds

508
00:43:22,780 --> 00:43:30,030
that entire result set and then sort all those
results before giving you back the pointer

509
00:43:30,030 --> 00:43:33,330
to that first result in this result set.

510
00:43:33,330 --> 00:43:38,210
So there's a lot going on there before
that first sqlite3_step returned.

511
00:43:38,210 --> 00:43:46,020
So in this particular case, what you really want is
an index that sorts all the tracks first by the album

512
00:43:46,020 --> 00:43:48,900
and then by the track order within that album.

513
00:43:48,900 --> 00:43:56,130
So here we've created an index,
TrackAlbumIDOrderIndex ON Track(AlbumID, AlbumOrder).

514
00:43:56,130 --> 00:44:04,150
And now when we try to select all the tracks in the
album, ordered by the track order in that album,

515
00:44:04,150 --> 00:44:13,920
we'll first look at the index and in logarithmic
time, we'll jump to the first track in that album

516
00:44:13,920 --> 00:44:21,300
and now we can just iterate over
the track table in sorted order.

517
00:44:21,300 --> 00:44:25,440
And you can see that EXPLAIN QUERY
PLAN has showed this to us by saying,

518
00:44:25,440 --> 00:44:31,510
table track with index the index we created
ORDER BY which means that we're iterating

519
00:44:31,510 --> 00:44:38,510
over to the track table using this index and also
using that index to satisfy the order by criterion.

520
00:44:38,510 --> 00:44:47,040
[ Pause ]

521
00:44:47,040 --> 00:44:53,060
The last thing I want to point out here is
that the query planner also works with Joins.

522
00:44:53,060 --> 00:44:57,910
So, if you have a query that joins two tables,

523
00:44:57,910 --> 00:45:01,940
it'll actually tell you the order in
which it's visiting those two tables.

524
00:45:01,940 --> 00:45:06,610
I won't go over this in detail but as
you can se in this particular query plan,

525
00:45:06,610 --> 00:45:10,790
we visit the track table using an index and then we join

526
00:45:10,790 --> 00:45:16,150
on to the artist table using the
built-in primary key index of artist.

527
00:45:16,150 --> 00:45:20,220
One last concept that I'm going to
talk about in SQLite is the page cache.

528
00:45:20,220 --> 00:45:29,450
When you have a SQLite database file, it's split into a set
of contiguous pages, each generally 4 kilobytes in length.

529
00:45:29,450 --> 00:45:35,330
And it's just like any other file,
just a contiguous array of bytes.

530
00:45:35,330 --> 00:45:44,520
But logically, what those contiguous array of bytes mean is
a set of B-Trees for each table and index in your database.

531
00:45:44,520 --> 00:45:50,370
So, each of the nodes in that B-Tree is a separate page.

532
00:45:50,370 --> 00:45:59,890
When we want to actually access any page in that B-Tree, we
actually have to bring it into memory into a data structure

533
00:45:59,890 --> 00:46:04,720
that SQLite maintains for you called the page cache.

534
00:46:04,720 --> 00:46:10,760
So in this case, if we are doing an
in order traversal of this B-Tree,

535
00:46:10,760 --> 00:46:13,910
we're actually going to overwrite
the existing contents of what was

536
00:46:13,910 --> 00:46:18,190
in the page cache with the pages that are in this table.

537
00:46:22,690 --> 00:46:28,920
So, what this means is that if you want to
access say a byte from a table in SQLite,

538
00:46:28,920 --> 00:46:35,820
what you're actually doing is you're bringing
the entire page around that byte into memory.

539
00:46:39,810 --> 00:46:47,570
So, you should keep this in mind when performing operations
with SQLite, I/O is done in page-sized increments.

540
00:46:47,570 --> 00:46:54,260
In particular, if you're updating or modifying the
database in any way, you should surround your updates

541
00:46:54,260 --> 00:47:04,230
with transactions, because otherwise, each UPDATE
or INSERT will modify a page in the page cache.

542
00:47:04,230 --> 00:47:14,100
It'll journal out or copy the page that's being modified
from the database file out to a journal file, and finally,

543
00:47:14,100 --> 00:47:16,940
you'll be able to modify the page you cared about.

544
00:47:16,940 --> 00:47:24,120
So, there's a lot of IO going on, a lot of page-sized
IO going on for just your little small update.

545
00:47:25,930 --> 00:47:31,380
In addition, because this page cache
is a fixed size, 1 megabyte by default,

546
00:47:31,380 --> 00:47:33,820
you shouldn't use your database as a filesystem.

547
00:47:33,820 --> 00:47:37,800
You shouldn't store large BLOBs inside your database.

548
00:47:37,800 --> 00:47:44,310
For example, assume you stored a 1 megabyte BLOB
inside your database, if your page cache is 1 megabyte,

549
00:47:44,310 --> 00:47:48,800
you've actually just blown out the entire page
cache and replaced it with that 1 megabyte BLOB,

550
00:47:48,800 --> 00:47:54,950
and that will make your joins slower
and your subsequent selects slower.

551
00:47:54,950 --> 00:48:01,170
In addition, because SQLite is
journaled, you'll pay a double cost

552
00:48:01,170 --> 00:48:05,730
in journaling the data before actually writing it to disk.

553
00:48:05,730 --> 00:48:12,420
So, instead of using the database as a filesystem, you
should probably store pointers to the filesystem instead,

554
00:48:12,420 --> 00:48:15,960
and store those large BLOBs in the filesystem.

555
00:48:19,970 --> 00:48:26,320
And just to drive this point home, if you don't
surround your batch updates with transactions,

556
00:48:26,320 --> 00:48:28,570
you can really shoot yourself in the foot.

557
00:48:28,570 --> 00:48:32,830
In this case, I took a pretty simple database
and made a thousand updates and left it

558
00:48:32,830 --> 00:48:42,660
in the standard autocommit mode, which means one transaction
for every modification, and I did 24 megabytes of I/O.

559
00:48:42,660 --> 00:48:49,070
Whereas if I surrounded those same 1000 updates with
a single transaction, I did 40 kilobytes of I/O.

560
00:48:49,070 --> 00:48:51,350
So, really look out for this.

561
00:48:51,350 --> 00:48:53,620
You'll actually see this in the System Usage instrument.

562
00:48:53,620 --> 00:48:57,940
If you see a lot of journal or a SQLite database activity,

563
00:48:57,940 --> 00:49:02,400
make sure you've surrounded your
modifications with transactions.

564
00:49:05,510 --> 00:49:10,620
So in summary, if you're using
databases, use Core Data if possible.

565
00:49:10,620 --> 00:49:13,420
It takes out a lot of the grudge work for you.

566
00:49:13,420 --> 00:49:21,120
If you are using SQLite directly and you have a performance
problem, first start by using a sqlite3_profile to figure

567
00:49:21,120 --> 00:49:24,490
out what statement is causing the performance issue.

568
00:49:24,490 --> 00:49:29,190
Once you know the statement that's causing the
performance issue, use EXPLAIN QUERY PLAN to figure

569
00:49:29,190 --> 00:49:32,350
out what SQLite is doing to execute that query.

570
00:49:32,350 --> 00:49:37,360
If you're doing a lot of modifications,
make sure your transactions--

571
00:49:37,360 --> 00:49:41,620
make sure you're using transactions
to surround the modifications

572
00:49:41,620 --> 00:49:47,390
so you amortize the cost of all those page-sized I/Os.

573
00:49:47,390 --> 00:49:55,600
If you want more resources on using SQLite or Core Data
directly, we had a few sessions on Core Data yesterday.

574
00:49:55,600 --> 00:50:02,030
In addition, if you're using SQLite directly, I highly
recommend you take a look at the YouTube video by D.

575
00:50:02,030 --> 00:50:05,530
Richard Hipp that-- where he gives
an introduction to SQLite.

576
00:50:05,530 --> 00:50:09,660
He wrote the framework, so he knows how to use it.

577
00:50:09,660 --> 00:50:18,360
And there's also a lot of documentation on the website for
all the key features, journaling, file format and so forth.

578
00:50:18,360 --> 00:50:22,210
So, take a look at that if you need more help.

579
00:50:22,210 --> 00:50:26,690
Finally, let's talk about making your
app scale well with large data sets.

580
00:50:26,690 --> 00:50:35,820
Your app could be faced with an extremely
large data set, thousands of items.

581
00:50:35,820 --> 00:50:40,410
And so, to make this-- your app perform well in the
face of that data set, make sure you're thinking

582
00:50:40,410 --> 00:50:45,910
about the minimum amount of work needed
to make the critical methods fast.

583
00:50:45,910 --> 00:50:49,120
And as an example, we'll take a
look at the Contacts application.

584
00:50:49,120 --> 00:50:59,580
So, I took a few timings of launching Contacts with 30
contacts, 300 contacts and 3000 contacts on an iPhone 3G.

585
00:50:59,580 --> 00:51:05,100
And as you can see, the launch time is pretty much
the same no matter how much data you throw at it.

586
00:51:05,100 --> 00:51:09,140
Now, if your app deals with a lot of data,
you should probably do this with your app,

587
00:51:09,140 --> 00:51:12,840
increase the data size by an order
of magnitude over and over again,

588
00:51:12,840 --> 00:51:17,130
and see how your launch time or
other critical operations respond.

589
00:51:17,130 --> 00:51:21,730
Ideally, you want something that looks like this,
something that stays relatively constant even

590
00:51:21,730 --> 00:51:25,320
as you're increasing the size of your data set.

591
00:51:28,110 --> 00:51:33,390
So, in launching applications,
there are a few critical methods.

592
00:51:33,390 --> 00:51:39,990
Most of the performance is driven by this
tableView that you see when you launch Contacts.

593
00:51:39,990 --> 00:51:44,570
The first thing you have to do is tell
the tableView how many sections are

594
00:51:44,570 --> 00:51:46,600
in your tableView and the title for those sections.

595
00:51:46,600 --> 00:51:52,490
You also have to tell the tableView
the number of rows in each section.

596
00:51:52,490 --> 00:51:59,160
If you have an index bar as in Contacts, you
have to give the tableView the index bar.

597
00:51:59,160 --> 00:52:07,370
And finally, for each of these visible cells on screen,
you're going to have to load and create the tableView cells.

598
00:52:10,470 --> 00:52:19,110
So, let's go over how to make each of these operations
fast or at least how we've made them fast in Contacts.

599
00:52:19,110 --> 00:52:25,100
So, to load sections quickly, the naive approach would
be to take your entire data set, suck it into memory,

600
00:52:25,100 --> 00:52:28,010
and then post-process them into sections.

601
00:52:28,010 --> 00:52:32,490
And that works for small data sets, but of course
it grows linearly with the size of your data set.

602
00:52:32,490 --> 00:52:38,500
If you have 10 times more data, it's going to take
at least 10 times longer to load your sections.

603
00:52:38,500 --> 00:52:42,540
So, a better idea if you're faced with large
data sets is to cache those sections counts

604
00:52:42,540 --> 00:52:46,180
to make this critical section count method fast.

605
00:52:46,180 --> 00:52:52,300
In Contacts, we actually have a separate table that we
maintain by triggers that maintains those section counts.

606
00:52:52,300 --> 00:52:55,980
It's actually a little hard to do right if
you're targeting multiple localizations.

607
00:52:55,980 --> 00:53:02,790
So, take a look at the DerivedProperty example on
our Developer Sample Code website to get an idea

608
00:53:02,790 --> 00:53:06,910
of how to deal with differing localizations.

609
00:53:06,910 --> 00:53:12,890
Good news for Core Data users is they
get them-- they get this for free.

610
00:53:12,890 --> 00:53:21,240
If you pass in the-- if you use the cache name parameter
from NSFetchedResultsController initWithFetchRequest

611
00:53:21,240 --> 00:53:29,810
to managedObjectContext setionNameKeyPath cacheNname,
it'll save those section counts off to a side file outside

612
00:53:29,810 --> 00:53:35,440
of the database, actually, and use that
cache file if it matches your fetch request.

613
00:53:35,440 --> 00:53:40,780
Otherwise, it'll cache the results of the fetch request
so that the next time you make that fetch request,

614
00:53:40,780 --> 00:53:45,140
maybe the next time you'd launch the
application, it'll be really fast.

615
00:53:48,410 --> 00:53:51,350
Next, we need to load the index bar quickly.

616
00:53:51,350 --> 00:53:55,160
You can do what we do in Contacts and cheat.

617
00:53:55,160 --> 00:53:56,790
You could always just load the same index bar.

618
00:53:56,790 --> 00:54:01,360
Even if you have no Contacts, you'll
notice that we always put A to Z and number

619
00:54:01,360 --> 00:54:05,470
as your index bar, and that's perfectly fine.

620
00:54:05,470 --> 00:54:10,010
Otherwise, if your index bar is going to change
based on the number of sections you have,

621
00:54:10,010 --> 00:54:15,700
anything you've done to make section loading faster
will also make your index bar loading faster.

622
00:54:19,080 --> 00:54:23,610
And finally, let's look at loading the cells
that are visible on the screen quickly.

623
00:54:23,610 --> 00:54:31,220
And this is where, if you're using a database, some of the
profiling tools that I showed you earlier might help you.

624
00:54:31,220 --> 00:54:36,840
What you really don't want to do is to
bring in the entire table all at once just

625
00:54:36,840 --> 00:54:40,430
to retrieve one cell's worth of information.

626
00:54:40,430 --> 00:54:43,650
So, what we do in Contacts is we actually do something

627
00:54:43,650 --> 00:54:48,790
where we select the Contacts and
batches as you're scrolling along.

628
00:54:48,790 --> 00:54:54,100
It turns out LIMIT and OFFSET is
not particularly fast in SQLite.

629
00:54:54,100 --> 00:54:56,960
There's a pretty long section on this on the website.

630
00:54:56,960 --> 00:55:02,450
But if you're iterating over a
small index, it generally works OK.

631
00:55:02,450 --> 00:55:04,760
There's also a document on the website called the--

632
00:55:04,760 --> 00:55:09,450
that describes the scrolling cursor
method that you might want to use.

633
00:55:09,450 --> 00:55:14,990
So, if you're having trouble loading cells quickly,
for example, you use time profile or you find

634
00:55:14,990 --> 00:55:21,380
that you're spending a lot of time in tableView
cellForRowAtIndexPath, take a look at these documents.

635
00:55:21,380 --> 00:55:25,580
And again, this is really where
proper indices will help you.

636
00:55:25,580 --> 00:55:28,380
If you have a proper index, hopefully, you only have

637
00:55:28,380 --> 00:55:33,340
to touch very little data to get
one cell's worth of information.

638
00:55:33,340 --> 00:55:39,030
If you don't have a proper index, you do a transient sort
over your entire result set just to get the first table cell

639
00:55:39,030 --> 00:55:46,020
on the tableView, then it's probably
going to be a bit slower.

640
00:55:46,020 --> 00:55:53,140
So, in summary, test and profile you apps with different
data set sizes, and only bring in the data necessary

641
00:55:53,140 --> 00:55:57,530
to satisfy the critical methods in your application.

642
00:55:57,530 --> 00:55:59,610
I've only looked at one example here.

643
00:55:59,610 --> 00:56:05,510
This is really something that you've got to do that's
custom to your app to figure out what methods are critical,

644
00:56:05,510 --> 00:56:08,360
and make sure you're only doing what's necessary.

645
00:56:08,360 --> 00:56:15,400
So, in summary, reduce the dirty memory usage in your app.

646
00:56:15,400 --> 00:56:17,470
Dirty memory causes low memory warnings.

647
00:56:17,470 --> 00:56:24,170
It crowds out clean memory that might be--
that you might be using for executing code.

648
00:56:24,170 --> 00:56:27,430
Adhere to the Foundation API best practices.

649
00:56:27,430 --> 00:56:31,820
Foundation is generally pretty performant,
but you do have to use it correctly

650
00:56:31,820 --> 00:56:34,670
to get the maximum performance out of it.

651
00:56:34,670 --> 00:56:41,990
If you have filesystem or database performance issues, use
our profiling tools to figure out where the bottlenecks are.

652
00:56:41,990 --> 00:56:47,700
If you have a critical query or a critical file that's
taking a really long time to load, and hopefully,

653
00:56:47,700 --> 00:56:55,220
that'll give you an idea of where to start to
make that critical query or file faster to load.

654
00:56:55,220 --> 00:56:59,010
And finally, make sure to test your
apps on different types of devices

655
00:56:59,010 --> 00:57:02,590
because each device has different
performance characteristics.

656
00:57:02,590 --> 00:57:11,130
If you have more questions, please
contact our evangelist, Michael Jurewitz.

657
00:57:11,130 --> 00:57:13,600
And you can always talk to us on the Developer Forums.

658
00:57:13,600 --> 00:57:18,390
I want to point you to some of these related sessions.

659
00:57:18,390 --> 00:57:25,280
These of course are all in the past, but
you can watch them on video afterwards.

660
00:57:25,280 --> 00:57:27,800
We had a Performance Optimization on iPhone OS session,

661
00:57:27,800 --> 00:57:31,720
that's more of a first timer session,
if you're new to the tools.

662
00:57:31,720 --> 00:57:32,630
Please take a look at that.

663
00:57:32,630 --> 00:57:34,550
We have a lot of demos there.

664
00:57:34,550 --> 00:57:37,090
There's the first part of this talk,
it was yesterday where we talked

665
00:57:37,090 --> 00:57:42,790
about animations and optimizing power and responsiveness.

666
00:57:42,790 --> 00:57:49,910
If you want to learn to use the memory tools or
other instruments, attend these Instruments talks.

667
00:57:49,910 --> 00:57:57,510
And finally, we have a Core Data talk if you
have Core Data performance issues and that's all.

668
00:57:57,510 --> 00:57:59,630
[ Applause ]

