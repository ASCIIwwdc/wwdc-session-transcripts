1
00:00:06,460 --> 00:00:10,970
>> Simon Fraser: Hi, my name is Simon Fraser and
I'm an engineer on the Safari and WebKit team.

2
00:00:10,970 --> 00:00:18,220
And you probably saw the first in this two-part
series on CSS effects by Jing just now.

3
00:00:18,220 --> 00:00:19,370
This is part two.

4
00:00:19,370 --> 00:00:24,820
And in this session we're going to focus on some slightly
more complex systems effects using a photo gallery

5
00:00:24,820 --> 00:00:25,610
as an example.

6
00:00:25,610 --> 00:00:32,620
But we'll look at keyframe animations
and 3D effects in some amount of detail.

7
00:00:32,620 --> 00:00:36,970
Now you've probably heard the term
HTML5 a lot in the news recently.

8
00:00:36,970 --> 00:00:43,140
And as we mentioned, HTML5 formally is the name of
a specification, which is the next version of HTML5.

9
00:00:43,140 --> 00:00:48,070
But informally, it's being used to cover a
sort of fairly broad range of web technologies.

10
00:00:48,070 --> 00:00:51,620
And today we're going to learn how to
use one of those web technologies, CSS3,

11
00:00:51,620 --> 00:00:56,110
to create some really rich, immersive web experiences.

12
00:00:56,110 --> 00:00:59,520
And you'll learn how to get really good
performance and really nice animation,

13
00:00:59,520 --> 00:01:03,040
both on iPhone, iPad, and on the desktop.

14
00:01:03,040 --> 00:01:07,340
And then we'll be using a little bit of
JavaScript to sort of glue things together

15
00:01:07,340 --> 00:01:10,070
and to create some of the really cool effects.

16
00:01:10,070 --> 00:01:19,020
So we first released support for dynamic
CSS effects in Safari 3.1 and in iPhone 2.0.

17
00:01:19,020 --> 00:01:22,150
And it's been really interesting to
see what people have used them for.

18
00:01:22,150 --> 00:01:27,810
Of course on www.apple.com we've been
putting these effects to great effect,

19
00:01:27,810 --> 00:01:31,020
creating lot of really neat interactive
content that lets people look

20
00:01:31,020 --> 00:01:34,870
at the new products and see all the details about them.

21
00:01:34,870 --> 00:01:38,580
And there are also people outside of
Apple who have been using these effects.

22
00:01:38,580 --> 00:01:43,500
This is the page from www.panic.com
that describes the Transmit application.

23
00:01:43,500 --> 00:01:46,880
And this makes really good use of transitions, transforms,

24
00:01:46,880 --> 00:01:51,170
and animations to let users explore
the features of this application.

25
00:01:51,170 --> 00:01:54,330
So from inside a web page, the user
can really get a feel for what it's

26
00:01:54,330 --> 00:01:58,200
like to use the actual application
once they've downloaded it.

27
00:01:58,200 --> 00:02:04,490
And then in the State of the Union
yesterday, you saw the HTML5 demos.

28
00:02:04,490 --> 00:02:07,940
These, again, make great use of CSS
effects so I encourage you to go

29
00:02:07,940 --> 00:02:13,070
and explore those and to download the code for those.

30
00:02:13,070 --> 00:02:16,920
So all of this stuff, you know,
obviously is just web development.

31
00:02:16,920 --> 00:02:22,120
If you already know a little bit
of CSS -- cascading style sheets --

32
00:02:22,120 --> 00:02:27,470
it's a very small amount of additional knowledge
to use CSS effects and really spice up your pages.

33
00:02:27,470 --> 00:02:32,750
In this session, pretty much everything I'm
going to talk to you about is CSS properties.

34
00:02:32,750 --> 00:02:36,430
There's a little bit of use of the
document object model -- that's the DOM API.

35
00:02:36,430 --> 00:02:42,930
And that's the API you use from JavaScript to modify
the page, listen for events, and things like that.

36
00:02:42,930 --> 00:02:47,700
And of course JavaScript is the programming
language that we use to drive all this stuff.

37
00:02:47,700 --> 00:02:57,360
And all of this works in Safari on iOS or on iPad, iPhone,
and iPod touch, and of course Safari on Mac and Windows.

38
00:02:57,360 --> 00:03:01,890
And then if you're embedding WebKit in
your native apps, in UIWebView, in iOS,

39
00:03:01,890 --> 00:03:05,690
and WebView on the desktop, all this stuff works as well.

40
00:03:05,690 --> 00:03:08,070
And also, there's another client now -- iAds.

41
00:03:08,070 --> 00:03:11,740
So if you're creating iAds, you'll probably
make really strong use of CSS effects.

42
00:03:11,740 --> 00:03:14,870
So let me take a minute to talk about open standards,

43
00:03:14,870 --> 00:03:17,780
and you've probably heard this
before, but I want to reinforce it.

44
00:03:17,780 --> 00:03:23,420
The way Apple advances web technology
is to participate in open standards

45
00:03:23,420 --> 00:03:26,010
and specifically we work with the standards groups.

46
00:03:26,010 --> 00:03:31,890
For example, we've worked very closely with the
WHATWG Group and the HTML working group of the W3C

47
00:03:31,890 --> 00:03:36,260
on the HTML5 specification, particularly
in terms of the audio and video elements.

48
00:03:36,260 --> 00:03:41,550
I'm actually a member of the CSS working group and all the
properties that I'm going to talk about today are included

49
00:03:41,550 --> 00:03:49,060
in specifications that we've submitted to the working
group for consideration, for inclusion in CSS3.

50
00:03:49,060 --> 00:03:54,850
Now because these are still specifications in draft
form, we do have the WebKit prefix on the properties

51
00:03:54,850 --> 00:03:58,490
and Jean mentioned in the previous
talk why we have this prefix.

52
00:03:58,490 --> 00:04:05,340
So let me show you -- or tell you --
what you'll learn in today's session.

53
00:04:05,340 --> 00:04:09,550
We're going to focus on two demos and use those to explain

54
00:04:09,550 --> 00:04:14,530
to you what CSS effects you can
use and why you want to use them.

55
00:04:14,530 --> 00:04:16,820
The first one is what we call a lightbox.

56
00:04:16,820 --> 00:04:17,890
It's a simple image viewer.

57
00:04:17,890 --> 00:04:22,520
You're probably really familiar with this -- you go to a
page with images or a gallery, you click on those images,

58
00:04:22,520 --> 00:04:28,460
and then get this sort of full screen overlay or
full window overlay and you focus just on the image.

59
00:04:28,460 --> 00:04:32,790
And in creating this lightbox, we'll see
how simple it is to use CSS transitions.

60
00:04:32,790 --> 00:04:37,420
And we'll show you how to get consistent
behavior between iPhone, iPad, and desktop.

61
00:04:37,420 --> 00:04:42,440
Now the second example is a photo gallery,
and this has some more dynamic content.

62
00:04:42,440 --> 00:04:45,310
We're loading images dynamically,
there's a bit more JavaScript.

63
00:04:45,310 --> 00:04:52,130
But we'll use this as a vehicle to show you the really
cool effects you can do with transitions, animations,

64
00:04:52,130 --> 00:04:55,020
and transforms -- some really nice cinematic stuff.

65
00:04:55,020 --> 00:04:59,000
And throughout the session I'll
give you some tips and tricks.

66
00:04:59,000 --> 00:05:04,270
So to show you these two demos that we
built, I'd like to invite my colleague,

67
00:05:04,270 --> 00:05:08,020
Enrica Casucci on stage to give you a demo.

68
00:05:08,020 --> 00:05:08,200
[ Applause ]

69
00:05:08,200 --> 00:05:13,650
>> Enrica Casucci: Hi, everyone.

70
00:05:13,650 --> 00:05:18,210
I'm going to show you today a simple example of a lightbox.

71
00:05:18,210 --> 00:05:28,490
As Simon said, a lightbox is a technique normally used to
display large images on top of a page using an overlay.

72
00:05:28,490 --> 00:05:32,780
It's something that looks more or less like this.

73
00:05:32,780 --> 00:05:41,270
Normally, the larger image is presented with a variety
of transitions, animations for positioning and sizing.

74
00:05:41,270 --> 00:05:51,750
And there's a number of existing frameworks that you can
use in order to easily add this functionality to your pages.

75
00:05:51,750 --> 00:05:56,110
The one we have used for this example is called FancyBox.

76
00:05:56,110 --> 00:06:01,370
But let's take a look a little bit
closely at the transition here.

77
00:06:01,370 --> 00:06:09,570
As I tap on the image, as you can see the transition
to the large image is not extremely smooth.

78
00:06:09,570 --> 00:06:14,430
And let me do this one more time.

79
00:06:14,430 --> 00:06:22,410
Notice that when the overlay comes up, there
is no opacity animation on the background.

80
00:06:22,410 --> 00:06:31,750
And also, normally these frameworks provide some sort of
loading indicator while the large image is being loaded.

81
00:06:31,750 --> 00:06:34,670
And let me show you this one slowly.

82
00:06:34,670 --> 00:06:40,790
As you can see, the progress indicator looks fairly static.

83
00:06:40,790 --> 00:06:45,570
What happens here is that even though -- I mean,
this is a great framework, don't get me wrong --

84
00:06:45,570 --> 00:06:54,460
but the problem that we are encountering here is
that JavaScript is used to drive the animation.

85
00:06:54,460 --> 00:07:03,490
What this means is that we normally have JavaScript
timers firing for each frame of the animation.

86
00:07:03,490 --> 00:07:14,220
Using CSS transitions and animation allow us to basically
let the rendering engine in the browser do the heavy lifting

87
00:07:14,220 --> 00:07:18,230
for us, taking advantage of the existing hardware

88
00:07:18,230 --> 00:07:22,630
and potentially leveraging hardware
acceleration when it's available.

89
00:07:22,630 --> 00:07:32,560
So let me show you now another example of another page
we've created using only CSS transitions and animations.

90
00:07:32,560 --> 00:07:42,060
Again, the look is very similar but as I tap over
the image, look how smooth the transition is.

91
00:07:42,060 --> 00:07:44,580
We've used a scaling transition here.

92
00:07:44,580 --> 00:07:48,500
Let me do this one more time so
that you can fully appreciate.

93
00:07:48,500 --> 00:07:57,840
And also check out the transition on the opacity of the
overlay, which adds a very nice touch and a polished look.

94
00:07:57,840 --> 00:08:07,770
And if I show you this first one that I've created with
a slow motion, look how smooth the progress animation is.

95
00:08:07,770 --> 00:08:14,380
And this is because we are truly leveraging
the power of the hardware acceleration.

96
00:08:14,380 --> 00:08:24,330
During the second part of the session, Simon is going to
talk about photo galleries and you will learn how to use 2D

97
00:08:24,330 --> 00:08:30,440
and 3D transforms and animations
to create some awesome effects.

98
00:08:30,440 --> 00:08:37,210
Since you're all developers, I'm pretty sure that at this
point you all want to jump to the code and take a look.

99
00:08:37,210 --> 00:08:39,340
But I want to tease you a little bit longer.

100
00:08:39,340 --> 00:08:47,050
Here is an example of a photo gallery that we
have created to showcase some of the effects

101
00:08:47,050 --> 00:08:51,220
that you can achieve with CSS transforms and animation.

102
00:08:51,220 --> 00:08:57,880
Using a transform on the opacity, you
can create a crossfade effect like this.

103
00:08:57,880 --> 00:09:06,410
Transform with translations allow you to create
push effects like this or a push down like this one.

104
00:09:06,410 --> 00:09:13,410
With rotation, you can achieve spin effects
but it's when you start using 3D transforms

105
00:09:13,410 --> 00:09:18,510
that you can truly add visual depth to your photo gallery.

106
00:09:18,510 --> 00:09:28,100
And with the same amount of effort, you can create,
like, a revolving door effect like this one, or a cube.

107
00:09:28,100 --> 00:09:36,530
A few lines of JavaScript will allow
you to do something like this --

108
00:09:36,530 --> 00:09:41,560
this amazing tile drop effect, unfolding effects, sorry.

109
00:09:41,560 --> 00:09:42,940
Isn't that awesome?

110
00:09:42,940 --> 00:09:49,180
[ Applause ]

111
00:09:49,180 --> 00:09:52,190
At this point, I'm going to hand it back to Simon,

112
00:09:52,190 --> 00:10:00,040
who will show you how to create these
amazing things with just a few lines of CSS.

113
00:10:00,040 --> 00:10:00,700
>> Simon Fraser: Thanks, Enrica.

114
00:10:00,700 --> 00:10:02,790
That looked really good.

115
00:10:02,790 --> 00:10:06,330
So let's start off by what we call
building a better lightbox.

116
00:10:06,330 --> 00:10:09,770
And as Enrica mentioned, there's lots of
lightbox implementations out there already.

117
00:10:09,770 --> 00:10:12,150
We're not trying to replicate the features of all those.

118
00:10:12,150 --> 00:10:17,930
We're not trying to reinvent the lightbox
but we wanted to focus on a few things here.

119
00:10:17,930 --> 00:10:23,210
The first thing is: how you can make use of CSS
transitions to get really nice, smooth, transition effects.

120
00:10:23,210 --> 00:10:25,930
And you saw a bunch of them in the lightbox example.

121
00:10:25,930 --> 00:10:30,630
The second one is: how we can create
a loading indicator just with CSS.

122
00:10:30,630 --> 00:10:39,040
And then finally: how to get consistent behavior and
consistent performance on desktop, iPad and iPhone.

123
00:10:39,040 --> 00:10:42,960
So all of this we can do in just 4 simple steps.

124
00:10:42,960 --> 00:10:46,710
The first step is something that any lightbox does --

125
00:10:46,710 --> 00:10:51,450
when the user clicks on one of the smaller images
on the page, we start loading the large image.

126
00:10:51,450 --> 00:10:55,980
And this is just some simple JavaScript you're
probably familiar with, creating new image element,

127
00:10:55,980 --> 00:11:01,120
registering an onload handler so we get notified when
the image loads, and then we set the source attribute

128
00:11:01,120 --> 00:11:03,690
to start loading the high-resolution image.

129
00:11:03,690 --> 00:11:06,070
Now the key here is we want to do this as soon as possible.

130
00:11:06,070 --> 00:11:09,660
We're going to have this overlay
that fades in over a period of time.

131
00:11:09,660 --> 00:11:14,210
So the sooner we kick off this load, the
sooner the user gets to see the final image.

132
00:11:14,210 --> 00:11:21,940
Okay, the second step -- that's to start fading in
the overlay, which is this sort of semi-opaque box

133
00:11:21,940 --> 00:11:25,450
that covers the rest of the page so we focus on this image.

134
00:11:25,450 --> 00:11:32,590
And here we start using a bit of CSS, we're matching the
element with the ID overlay, using the selector right there.

135
00:11:32,590 --> 00:11:35,990
And it starts off with an opacity zero, so it's transparent.

136
00:11:35,990 --> 00:11:41,490
And then when we apply the visible class
to that, it's going to fade to opacity 1.

137
00:11:41,490 --> 00:11:47,800
And as you probably saw in CSS Effects Part 1, normally
when CSS properties change, they change instantaneously.

138
00:11:47,800 --> 00:11:52,200
But this gives a very jarring, kind
of disruptive appearance to the user;

139
00:11:52,200 --> 00:11:55,470
it's much better if we can smooth out that change.

140
00:11:55,470 --> 00:11:57,560
And with one line of CSS, we can do this.

141
00:11:57,560 --> 00:12:02,860
We apply the transition property and we say that
we want opacity to transition over a half second.

142
00:12:02,860 --> 00:12:06,350
And that gives us this nice, smooth, even curve here.

143
00:12:06,350 --> 00:12:08,520
And if we wanted to, we could use
a linear timing function --

144
00:12:08,520 --> 00:12:11,480
that will give us a constant rate
of change in the opacity property.

145
00:12:11,480 --> 00:12:14,920
So it's very easy to get animations with transitions.

146
00:12:14,920 --> 00:12:17,910
And you've probably seen -- in fact,
you have seen the shorthand used a lot,

147
00:12:17,910 --> 00:12:21,000
WebKit transition but these are the longhand properties.

148
00:12:21,000 --> 00:12:24,660
The first one specifies which other
properties you want to transition.

149
00:12:24,660 --> 00:12:28,470
The second one specifies how long
the transition is going to take.

150
00:12:28,470 --> 00:12:32,520
And then transition timing function
allows you to control that easing function

151
00:12:32,520 --> 00:12:35,590
and you can do custom timing functions
with the cubic Bezier.

152
00:12:35,590 --> 00:12:38,480
There are a bunch of easing functions built in.

153
00:12:38,480 --> 00:12:42,350
And then as you saw in the previous
session, transition delay,

154
00:12:42,350 --> 00:12:44,320
which is really useful for these neat building effects.

155
00:12:44,320 --> 00:12:46,520
So let's go back to the overlay.

156
00:12:46,520 --> 00:12:54,480
Now, here we have to write a little bit of JavaScript
that's going to create the overlay for the first time

157
00:12:54,480 --> 00:12:56,710
and it uses createElement, which is one these DOM APIs.

158
00:12:56,710 --> 00:13:03,100
And it sets the IDs overlay so we can identify
it from JavaScript and style it in CSS.

159
00:13:03,100 --> 00:13:06,960
And then we append the overlay to the body element.

160
00:13:06,960 --> 00:13:12,570
Now you might think at this point that if you set
the visible class name, both styles will apply,

161
00:13:12,570 --> 00:13:16,130
the opacity one will give a nice transition.

162
00:13:16,130 --> 00:13:19,960
But in actual fact, that doesn't quite work as you expect.

163
00:13:19,960 --> 00:13:24,480
So let me take a moment to explain why
this doesn't behave quite as you expect.

164
00:13:24,480 --> 00:13:31,020
Now the reason is: browsers actually
do some style coalescing under the hood

165
00:13:31,020 --> 00:13:33,840
and I'll explain that with this example here.

166
00:13:33,840 --> 00:13:36,480
Imagine you have this JavaScript, it's
setting the background color to red

167
00:13:36,480 --> 00:13:38,850
and then immediately it sets the background color to blue.

168
00:13:38,850 --> 00:13:43,370
Now the question is: does the browser
ever actually render that red color?

169
00:13:43,370 --> 00:13:44,860
And the answer is no.

170
00:13:44,860 --> 00:13:48,580
The browser's essentially throwing
away redundant style changes.

171
00:13:48,580 --> 00:13:53,030
It batches up the style changes and red is
getting overwritten with blue right away.

172
00:13:53,030 --> 00:13:56,350
So the only thing it's going to
do here is render that blue color.

173
00:13:56,350 --> 00:13:59,830
Normally this doesn't matter but transitions are temporal.

174
00:13:59,830 --> 00:14:04,340
So there's this temporal component now that
means that this actually becomes important.

175
00:14:04,340 --> 00:14:07,770
Imagine we changed the JavaScript to something like this.

176
00:14:07,770 --> 00:14:13,330
So here we're setting the transition property and we're
saying that we want background color to transition.

177
00:14:13,330 --> 00:14:19,020
And now, again, do you expect to see an
animation between red and blue in this case?

178
00:14:19,020 --> 00:14:22,190
Well, the answer is no, we don't get one
here, either and for the same reason --

179
00:14:22,190 --> 00:14:27,660
the browser's coalescing those style changes and so the
only thing the browser actually renders is the blue color.

180
00:14:27,660 --> 00:14:29,080
And that transition rule is there.

181
00:14:29,080 --> 00:14:32,480
And so if we change the color later on
to something else, we'll get a transition

182
00:14:32,480 --> 00:14:37,530
but we won't actually ever see the
red-to-blue transition in this case.

183
00:14:37,530 --> 00:14:43,840
Now, there are a number of solutions to this problem
and the one we recommend using is setTimeout.

184
00:14:43,840 --> 00:14:48,520
And what this does is allow you to run
a little bit of code after a delay.

185
00:14:48,520 --> 00:14:52,020
In this case, we used the delay
zero but it's enough of a delay

186
00:14:52,020 --> 00:14:56,310
that the browser gets a chance
to render the initial red color.

187
00:14:56,310 --> 00:15:00,630
And now when the color changes to blue a little
bit later on, the browser is actually going

188
00:15:00,630 --> 00:15:05,800
to then run the transition between red and blue.

189
00:15:05,800 --> 00:15:08,620
So you get a nice transition there.

190
00:15:08,620 --> 00:15:09,700
So let's go back to our overlay.

191
00:15:09,700 --> 00:15:12,290
In this case the scenario is a little different

192
00:15:12,290 --> 00:15:15,260
but essentially we've just appended
this element to the document.

193
00:15:15,260 --> 00:15:19,620
But we're applying the visible class
right away so the browser's never going

194
00:15:19,620 --> 00:15:21,780
to have a chance to render the opacity zero.

195
00:15:21,780 --> 00:15:24,050
And so it won't run that transition.

196
00:15:24,050 --> 00:15:26,880
The solution is to use the setTimeout.

197
00:15:26,880 --> 00:15:33,200
And now we change the class name to Visible inside
the setTimeout and we'll see a nice transition here.

198
00:15:33,200 --> 00:15:38,500
So that's what this looks like.

199
00:15:38,500 --> 00:15:41,880
You get a nice, smooth fade, even
on the iPad as Enrica showed you.

200
00:15:41,880 --> 00:15:46,150
So our next step is to create this loading indicator.

201
00:15:46,150 --> 00:15:50,520
You see it's static in this picture,
but actually animated as you saw.

202
00:15:50,520 --> 00:15:53,610
So we want to be able to animate that.

203
00:15:53,610 --> 00:16:00,140
Now there are two CSS effects we can use to get a
really nice, smoothly animating loading indicator here.

204
00:16:00,140 --> 00:16:05,070
The first thing we can do is we can
use rotations by a CSS transforms

205
00:16:05,070 --> 00:16:09,230
and the second one is we can use CSS
keyframe animations to have this animation

206
00:16:09,230 --> 00:16:13,110
or this rotation continually repeat or continually animate.

207
00:16:13,110 --> 00:16:18,910
And the benefit of doing it this way is: first of all,
you can do it without any plugins or animated JIFs;

208
00:16:18,910 --> 00:16:20,980
you can use really nice, high-quality images,

209
00:16:20,980 --> 00:16:27,550
maybe a PNG with alpha so it lends
very nicely with the rest of the page.

210
00:16:27,550 --> 00:16:31,020
So let's see how we do this.

211
00:16:31,020 --> 00:16:33,500
So here's our image.

212
00:16:33,500 --> 00:16:37,140
And then to get the animation running,
there are two things we need to do.

213
00:16:37,140 --> 00:16:40,820
The first one is we describe the
animation in terms of a set of keyframes.

214
00:16:40,820 --> 00:16:44,100
So this uses a new at-rule and it has the -WebKit prefix.

215
00:16:44,100 --> 00:16:46,420
So it's @-WebKit-keyframes.

216
00:16:46,420 --> 00:16:48,450
And then the other name, spin, which we'll use later.

217
00:16:48,450 --> 00:16:53,740
And the keyframes are where we
described the states of the animation.

218
00:16:53,740 --> 00:16:58,520
So the front keyframe is the initial state
of this thing and it has a rotation of zero.

219
00:16:58,520 --> 00:17:02,780
And then the 2 keyframe, the final state,
has a rotation of 360 degrees, so one turn.

220
00:17:02,780 --> 00:17:07,530
And then as the animation's running, the
browser's going to interpolate between these two.

221
00:17:07,530 --> 00:17:14,420
So they'll do a nice interpolation between 0 and
360, causing our image to spin around one time.

222
00:17:14,420 --> 00:17:18,700
Now, it has this name "spin," which
is some name you give it.

223
00:17:18,700 --> 00:17:26,620
And then you can apply the animation, using the
WebKit animation property, namely the keyframe, spin.

224
00:17:26,620 --> 00:17:28,730
And then you give it a duration, so one second.

225
00:17:28,730 --> 00:17:31,630
And that's the duration of one cycle of animation.

226
00:17:31,630 --> 00:17:36,430
And in this case, we want this thing to spin around for
as long as we're waiting for that large image to load.

227
00:17:36,430 --> 00:17:38,530
So the repeat count we use here is infinite.

228
00:17:38,530 --> 00:17:41,560
But you could use 10 or 5 or 1 or whatever.

229
00:17:41,560 --> 00:17:45,980
And we want it to spin with a constant angular
velocity so we use a linear timing function.

230
00:17:45,980 --> 00:17:49,430
That gives us a nice, smooth spin out.

231
00:17:49,430 --> 00:17:50,870
So that's pretty much all we need to do.

232
00:17:50,870 --> 00:17:53,110
That gives us this nice spinning indicator.

233
00:17:53,110 --> 00:17:58,430
And that spinning indicator is going to stay there for
as long as you're waiting for the large image to load.

234
00:17:58,430 --> 00:18:04,880
But once that large image loads, then the next step
is to manage this transition to show the big image.

235
00:18:04,880 --> 00:18:09,850
This is a little more complicated, so
I'm not going to go into all the details.

236
00:18:09,850 --> 00:18:16,000
But the first thing you need to bear in mind is
we've got two things running here that are temporal:

237
00:18:16,000 --> 00:18:18,920
we've got the large image loading and the overlay is fading.

238
00:18:18,920 --> 00:18:22,210
And we need to have a little bit of logic in
our JavaScript that waits for both of these

239
00:18:22,210 --> 00:18:25,750
to finish before we do this final reveal on the image.

240
00:18:25,750 --> 00:18:33,010
And you can imagine you could use CSS transitions
on heightened width to do that scale of the image.

241
00:18:33,010 --> 00:18:38,050
And if you wanted to, you could do transitions
of maybe opacity to reveal the caption

242
00:18:38,050 --> 00:18:41,010
or maybe the caption could fall
down where the margin transition.

243
00:18:41,010 --> 00:18:48,280
And you could reveal the close button
somehow, maybe it pops in with a scale.

244
00:18:48,280 --> 00:18:53,120
So if you put all that stuff together, this is what it
looks like, although this is what it looks like on desktop.

245
00:18:53,120 --> 00:18:56,050
On iPad, you probably wouldn't get a very good frame rate.

246
00:18:56,050 --> 00:19:01,720
So let me talk a bit about optimizing for iPad and iPhone.

247
00:19:01,720 --> 00:19:07,580
Now, as Enrica mentioned, if you were animating
properties with JavaScript, essentially --

248
00:19:07,580 --> 00:19:12,000
many libraries do this, they're running timers
to change the style of an element, you know,

249
00:19:12,000 --> 00:19:15,960
multiple times to get an animation to run.

250
00:19:15,960 --> 00:19:20,970
The problem is the browser can't really optimize that
very well; it doesn't really know what the animation is.

251
00:19:20,970 --> 00:19:25,510
So if you use CSS transitions in
animations, we can hit a fast path.

252
00:19:25,510 --> 00:19:31,520
We know you're running an animation and
therefore, we can make it a lot more efficient.

253
00:19:31,520 --> 00:19:36,170
And so you'll get at least as good performance
using transitions and animations on most properties

254
00:19:36,170 --> 00:19:42,610
and you'll get significantly better performance if you
animate the transform property or the opacity properly

255
00:19:42,610 --> 00:19:45,230
for these we actually make use of hardware acceleration.

256
00:19:45,230 --> 00:19:49,990
We offload some of the compositing to the
GPU, so you get great performance with these

257
00:19:49,990 --> 00:19:55,680
and these are really useful for iPad and iPhone.

258
00:19:55,680 --> 00:19:59,750
So let me summarize what we learned
by building this better lightbox.

259
00:19:59,750 --> 00:20:06,340
First of all, CSS transitions can give you a really nice
cinematic experience and they're really easy to offer.

260
00:20:06,340 --> 00:20:10,750
Often it's just one line of the CSS to go from
a jarring transition to a nice, smooth one.

261
00:20:10,750 --> 00:20:14,370
And you can get really good performance on all platforms.

262
00:20:14,370 --> 00:20:18,680
Remember, the two properties you want to
stick to are WebKit-transform and opacity.

263
00:20:18,680 --> 00:20:24,880
And then the second thing we learned is we can get
this nice, loading indicator using a combination

264
00:20:24,880 --> 00:20:30,940
of a rotation transform and CSS animations
without any JavaScript, without any plugins.

265
00:20:30,940 --> 00:20:38,130
So, you know, this lightbox is a
great way of showing a single image.

266
00:20:38,130 --> 00:20:40,230
What if you want to show multiple images?

267
00:20:40,230 --> 00:20:50,500
Well, that takes us into the next section, which
is building really awesome photo galleries.

268
00:20:50,500 --> 00:20:54,510
And Enrica showed you some demos but here are
some of the effects we've put together here.

269
00:20:54,510 --> 00:20:57,730
Now, some of these have a sense of
depth, they have some 3D in them.

270
00:20:57,730 --> 00:21:05,730
And there are also some other kind of
interesting effects that we can get here.

271
00:21:05,730 --> 00:21:09,830
So you'll see how to build these later in this session.

272
00:21:12,670 --> 00:21:17,070
So before we delve into the details of
how to build a photo gallery like this,

273
00:21:17,070 --> 00:21:19,990
I'd like to step back a little
bit and talk about best practices.

274
00:21:19,990 --> 00:21:27,610
I think the most important thing when you're building
a photo gallery is to stay within the same page.

275
00:21:27,610 --> 00:21:31,730
If you force people to load a new page for
every image as they go through a gallery,

276
00:21:31,730 --> 00:21:35,390
that uses a lot of bandwidth, it's
very tedious for the user.

277
00:21:35,390 --> 00:21:37,630
If they're on a slow connection, it will be really slow.

278
00:21:37,630 --> 00:21:41,610
And there's no way you can do nice
transitions between images in that case.

279
00:21:41,610 --> 00:21:44,990
And you may think, "Well, if you stay on
the same page doing kind of Ajax-y stuff,

280
00:21:44,990 --> 00:21:49,230
don't you break history and bookmarking
and stuff like that?"

281
00:21:49,230 --> 00:21:55,710
Well, HTML5 now has APIs that let you solve those problems
-- it has a history API and a location object you can use

282
00:21:55,710 --> 00:22:00,870
to basically work around those
problems of bookmarking and history.

283
00:22:00,870 --> 00:22:08,200
The second thing I recommend is: load each image on
demand; don't force the user to wait for all the images

284
00:22:08,200 --> 00:22:11,670
in the gallery to load before they
can start stepping through it.

285
00:22:11,670 --> 00:22:16,080
And with a little bit of JavaScript, you can just kick
off those image loads as the user's moving through.

286
00:22:16,080 --> 00:22:17,580
It's quite straightforward.

287
00:22:17,580 --> 00:22:28,810
A technique we found very useful when creating slightly more
complex content is to make extensive use of CSS class names

288
00:22:28,810 --> 00:22:32,580
and specifically to use class names
to describe states in our content.

289
00:22:32,580 --> 00:22:38,540
So in this particular example, we
have two types of state we care about.

290
00:22:38,540 --> 00:22:44,820
When we're moving from one image to the next, we have a new
image that's coming in and we use an incoming class name

291
00:22:44,820 --> 00:22:51,490
to identify that, and then the old image -- the one that's
going away -- and that gets the outgoing class name.

292
00:22:51,490 --> 00:22:54,930
We also have the notion of initial and final states.

293
00:22:54,930 --> 00:23:00,780
The initial state is where everything is before we start
running that transition from the old image to the new image.

294
00:23:00,780 --> 00:23:06,050
And then the final state is where everything
is once we've finished that transition.

295
00:23:06,050 --> 00:23:14,030
And now because we've described the states and the content
using class names, our JavaScript becomes very small.

296
00:23:14,030 --> 00:23:19,630
Instead of having to write a lot of spaghetti JavaScript
that modifies style and does all this complicated stuff,

297
00:23:19,630 --> 00:23:25,460
we can use the JavaScript for two really simple
things: the first is to kick off these image loads

298
00:23:25,460 --> 00:23:31,050
so we have the dynamic image loading, and the second thing
that JavaScript does is just toggle these class names

299
00:23:31,050 --> 00:23:37,470
to basically move us between the states
that we've already described in CSS.

300
00:23:37,470 --> 00:23:43,110
So let's look at the actual markup or the structure
of the document we're going to use for this gallery.

301
00:23:43,110 --> 00:23:46,020
We have the main div, which we call photo container,

302
00:23:46,020 --> 00:23:50,050
which is just going to be the container
for the images we're showing.

303
00:23:50,050 --> 00:23:55,810
And then when we're running a particular move from
one image to the next, we have an incoming image

304
00:23:55,810 --> 00:24:02,310
which would give this class name incoming and the old
image that's going away gets the outgoing class name.

305
00:24:02,310 --> 00:24:07,860
So temporarily, our photo container has two children
-- two child elements -- which are these two images.

306
00:24:07,860 --> 00:24:12,360
And when the transition's done, we'll rip out
the old one and get left with just one image.

307
00:24:12,360 --> 00:24:16,120
And of course to do this, so the images don't stack
up, you'd use absolute positioning and that kind

308
00:24:16,120 --> 00:24:20,320
of thing so that they're in the right spot.

309
00:24:20,320 --> 00:24:25,700
So bearing that in mind, let's see how we build
a transition like this, a push down transition.

310
00:24:25,700 --> 00:24:30,370
So here's our photo container.

311
00:24:30,370 --> 00:24:35,520
And now we start describing the states
of the content using these class names.

312
00:24:35,520 --> 00:24:40,630
So the initial and final class names go on the photo
container because they apply to everything underneath it.

313
00:24:40,630 --> 00:24:46,240
And then here we start styling the incoming image.

314
00:24:46,240 --> 00:24:48,710
And we're using transforms, of course,
because we know they animate nicely.

315
00:24:48,710 --> 00:24:56,510
In this case, we'll use translateY, which is just a
shorthand for a vertical translate and the value is -100%.

316
00:24:56,510 --> 00:24:59,910
And that's a convenient way of
moving something up by its height.

317
00:24:59,910 --> 00:25:03,560
So you can use percentages in translates
and that's pretty useful.

318
00:25:03,560 --> 00:25:08,960
When the incoming image is in the final state,
it's front and center, it has a translateY(0).

319
00:25:08,960 --> 00:25:18,270
And then the outgoing image starts in that same
spot and moves to a positive 100% translate.

320
00:25:18,270 --> 00:25:19,430
So it goes down.

321
00:25:19,430 --> 00:25:23,310
And then the final thing we want to do here is, of course,

322
00:25:23,310 --> 00:25:28,720
tell the browser that all these style changes,
these state changes, should be animated.

323
00:25:28,720 --> 00:25:35,440
So we use the transition property to specify that we
want transform to animate over a half-second here.

324
00:25:35,440 --> 00:25:37,750
Now you may have noticed if you were
looking carefully in the previous slide

325
00:25:37,750 --> 00:25:40,900
that we're also doing some opacity
changes as we're doing this transition.

326
00:25:40,900 --> 00:25:47,510
I'm not showing this here for simplicity but
you can imagine it's pretty easy to add those.

327
00:25:47,510 --> 00:25:51,760
So then there's some JavaScript we
need to actually do the image loading

328
00:25:51,760 --> 00:25:55,930
and cause this transition to happen, so let's look at that.

329
00:25:55,930 --> 00:26:00,190
So the first thing we do is getElementById that
just gives us a reference to our photo container.

330
00:26:00,190 --> 00:26:04,500
And now we start setting these class names that
describe the states of things in our content.

331
00:26:04,500 --> 00:26:08,400
So the outgoing image, the old image, we know
is the first child of the photo container

332
00:26:08,400 --> 00:26:10,650
so we can add the outgoing class name to that one.

333
00:26:10,650 --> 00:26:15,460
And we have the incoming image that's already
loaded so we set the incoming class name

334
00:26:15,460 --> 00:26:17,510
on that and we're doing appendChild.

335
00:26:17,510 --> 00:26:19,660
So now our photo container has two children.

336
00:26:19,660 --> 00:26:26,690
And we set the initial class name to tell the browser
to render all those things in their initial states.

337
00:26:26,690 --> 00:26:29,430
And we use the setTimeout technique again.

338
00:26:29,430 --> 00:26:33,220
And all we have to do inside the setTimeout
is basically flip the class names.

339
00:26:33,220 --> 00:26:36,320
So remove the initial class name, add the final class name,

340
00:26:36,320 --> 00:26:40,860
and that will kick off all the transitions
that cause the effect to happen.

341
00:26:40,860 --> 00:26:45,590
Now there's a little bit of clean
up we need to do at the end.

342
00:26:45,590 --> 00:26:49,350
And the first thing we need to figure out was:
how do we know when this effect is finished,

343
00:26:49,350 --> 00:26:51,970
when the move from the old image
to the new image is completed?

344
00:26:51,970 --> 00:26:56,270
Well, transitions emit DOM events when they end.

345
00:26:56,270 --> 00:27:01,320
So we can register an event listener, using an
event listener for the WebKit transition end event.

346
00:27:01,320 --> 00:27:05,820
And we register a callback function
on that, which is transition done.

347
00:27:05,820 --> 00:27:08,340
So let's write that now.

348
00:27:08,340 --> 00:27:10,720
The first thing we do is remove the final class name.

349
00:27:10,720 --> 00:27:15,410
We're done, the transition's over, we can just
remove the class names; we don't need them anymore.

350
00:27:15,410 --> 00:27:21,090
And then we know the first child of the photo container
is the old image so we do a remove child, get rid of that.

351
00:27:21,090 --> 00:27:26,550
And then we can just take the class name
off the incoming image because we're done.

352
00:27:26,550 --> 00:27:31,000
Now the thing to note here is that this JavaScript
-- the JavaScript on the last two slides --

353
00:27:31,000 --> 00:27:34,140
is not going to change for the rest of this session.

354
00:27:34,140 --> 00:27:38,700
The JavaScript stays the same because
we've described all of the states in CSS.

355
00:27:38,700 --> 00:27:45,090
So all we have to do is change the CSS to
get lots of different kinds of effects.

356
00:27:45,090 --> 00:27:48,730
So let me show you some of those effects.

357
00:27:48,730 --> 00:27:52,780
This is a scale transition -- we saw
Enrica demo it, it's very simple.

358
00:27:52,780 --> 00:27:56,370
And here I'm just going to show you
the style for the incoming image,

359
00:27:56,370 --> 00:27:59,560
the outgoing image is pretty much just the reverse.

360
00:27:59,560 --> 00:28:03,120
So the incoming image starts with a
scale of zero, so it's like really tiny

361
00:28:03,120 --> 00:28:06,040
in the middle and then it zooms up to a scale of 1.

362
00:28:06,040 --> 00:28:09,110
And the outgoing image just does the reverse.

363
00:28:09,110 --> 00:28:14,840
And then this funky spin transition.

364
00:28:15,870 --> 00:28:22,550
Being an incoming image has initial rotation of
minus 180 degrees, that gives it a half turn.

365
00:28:22,550 --> 00:28:25,320
And then its final rotation is zero.

366
00:28:25,320 --> 00:28:28,480
And that's all we need to get that nice spin transition.

367
00:28:28,480 --> 00:28:34,330
So let me summarize what we've
learned from photo gallery so far.

368
00:28:34,330 --> 00:28:39,000
First of all, keep your user's window
the same page and then use JavaScript

369
00:28:39,000 --> 00:28:43,290
to dynamically load images as you move through the gallery.

370
00:28:43,290 --> 00:28:45,630
Use class names to describe states.

371
00:28:45,630 --> 00:28:55,110
So use this declarative technique where all the interesting
states are described as combinations of CSS classes

372
00:28:55,110 --> 00:28:56,970
and then your JavaScript becomes really small.

373
00:28:56,970 --> 00:29:00,050
All your JavaScript's doing is toggling these classes.

374
00:29:00,050 --> 00:29:07,250
And then to detect when transitions
end, use the transition end event.

375
00:29:07,250 --> 00:29:13,340
And finally, all you have to do is change the
CSS to get lots of neat transition effects.

376
00:29:13,340 --> 00:29:17,010
And transforms gives you all sorts of scales
and rotates you can do with the image.

377
00:29:17,010 --> 00:29:24,950
So in this case we just used the transform property but
we were able to get lots of different kinds of effects.

378
00:29:24,950 --> 00:29:29,910
So what about these effects that look
much more 3D to have this sense of depth?

379
00:29:29,910 --> 00:29:34,410
Well, let's look at how to create these.

380
00:29:34,410 --> 00:29:38,230
So, you know, these are obviously
doing some sort of 3D stuff.

381
00:29:38,230 --> 00:29:38,770
What does this mean?

382
00:29:38,770 --> 00:29:43,920
We have the ability to describe 3D transforms
in CSS now and this is pretty exciting.

383
00:29:43,920 --> 00:29:49,220
So what it does really is it doesn't really
give us a sort of 3D modeling environment --

384
00:29:49,220 --> 00:29:53,920
we don't have spheres and cubes and
cones and stuff but it does allow us

385
00:29:53,920 --> 00:29:56,420
to position elements in a three-dimensional space.

386
00:29:56,420 --> 00:29:59,400
Sometimes this is called "planes in space or 2.5D."

387
00:29:59,400 --> 00:30:07,280
And this is -- in addition to the x- and
y-axes, you have for doing transforms already,

388
00:30:07,280 --> 00:30:10,120
it gives you this z-axis, which is coming out of the screen.

389
00:30:10,120 --> 00:30:19,420
So, just to look at the properties for a moment, this uses
the same transform property that we've been using already

390
00:30:19,420 --> 00:30:23,510
but it has some new values, like
translate 3D, rotate 3D, scale 3D,

391
00:30:23,510 --> 00:30:27,860
and then there's some convenient
versions of these like rotateX, rotateY.

392
00:30:27,860 --> 00:30:32,870
Now 3D is a little more complex.

393
00:30:32,870 --> 00:30:38,750
There's a little more setup you have to do to actually
make things look 3D and handle some other issues.

394
00:30:38,750 --> 00:30:42,820
So the first property here that we
added is one called "perspective."

395
00:30:42,820 --> 00:30:45,950
And this allows us to control a sense of depth in the scene.

396
00:30:45,950 --> 00:30:49,510
And you'll see that in a moment.

397
00:30:49,510 --> 00:30:56,330
The second one is useful - it's transform style --
is useful when you're building hierarchies of objects

398
00:30:56,330 --> 00:30:59,410
and you want them to live in a
common three-dimensional space.

399
00:30:59,410 --> 00:31:02,540
Transform style allows you to control
whether there's flattening

400
00:31:02,540 --> 00:31:05,930
or whether these things live in a common 3D space.

401
00:31:05,930 --> 00:31:10,960
And the other slightly odd thing with 3D transforms
is it's actually possible to flip an element

402
00:31:10,960 --> 00:31:13,540
around so you can see the reverse side of it.

403
00:31:13,540 --> 00:31:15,930
And sometimes you want that but sometimes you don't.

404
00:31:15,930 --> 00:31:22,210
So back face visibility allows you to hide things
if they've definitely flipped all the way around.

405
00:31:22,210 --> 00:31:26,610
So let's go back building a revolving
door effect using 3D transforms.

406
00:31:26,610 --> 00:31:32,260
Now the first thing to note here is that with the revolving
door effect, it's like the hinges are on the right,

407
00:31:32,260 --> 00:31:35,130
the elements are sort of swinging
around that right-hand edge.

408
00:31:35,130 --> 00:31:38,290
So there's a little bit of setup
we have to do to make that work.

409
00:31:39,910 --> 00:31:41,430
Now, she mentioned this in her session.

410
00:31:41,430 --> 00:31:49,270
You can control the transform origin, in other
words, where the origin of the transform is,

411
00:31:49,270 --> 00:31:51,320
and by default it's in the center of the element.

412
00:31:51,320 --> 00:31:55,630
So if we rotated the element, you
noticed it rotated around the center.

413
00:31:55,630 --> 00:31:58,760
We can use the transform origin property to change that.

414
00:31:58,760 --> 00:32:00,490
So here we've used right 50%.

415
00:32:00,490 --> 00:32:03,870
So that puts the transform origin on the right-hand edge.

416
00:32:03,870 --> 00:32:10,040
And you can use pixel values, percentages,
or the keywords for this property.

417
00:32:10,040 --> 00:32:17,080
So now when it rotates, it hinges about
that right edge, which is what we want.

418
00:32:17,080 --> 00:32:24,380
And then, just as before, we use these class
names to set up the initial and the final states.

419
00:32:24,380 --> 00:32:30,520
The incoming image is going to start basically
rotated into the screen from where the user is.

420
00:32:30,520 --> 00:32:34,890
So that uses a rotation about the
y-axis, which is the vertical axis

421
00:32:34,890 --> 00:32:37,880
of 90 degrees, which pushes it back into the screen.

422
00:32:37,880 --> 00:32:43,570
And then the final state of the incoming
image is just flat on rotateY at 0.

423
00:32:43,570 --> 00:32:50,580
And then the outgoing image, you can probably guess, starts
with the rotateY at 0 and then its final state is coming

424
00:32:50,580 --> 00:32:54,990
out of the screen towards us, which
is rotateY of minus 90 degrees.

425
00:32:54,990 --> 00:32:59,720
So if we actually put that together,
what would it look like?

426
00:32:59,720 --> 00:33:02,510
Well, the answer is actually like this.

427
00:33:02,510 --> 00:33:03,620
That was a revolving door.

428
00:33:03,620 --> 00:33:05,760
This is an attempt at doing the cube transition.

429
00:33:05,760 --> 00:33:09,670
And it looks very flat, you don't see any depth there.

430
00:33:09,670 --> 00:33:15,150
And the reason is, we haven't described
any sort of depth in this scene.

431
00:33:15,150 --> 00:33:20,230
So that's where we use this perspective
property that I mentioned before.

432
00:33:20,230 --> 00:33:28,760
And what perspective does is it controls effectively
how far away the viewer is from the plane of the screen.

433
00:33:28,760 --> 00:33:34,930
And the default value is NaN, which means the
viewer's infinitely far away, everything looks flat.

434
00:33:34,930 --> 00:33:40,990
Then as we start setting that to actual
values -- it's like 4,000 pixels --

435
00:33:40,990 --> 00:33:43,830
we start getting some amount of foreshortening in the scene.

436
00:33:43,830 --> 00:33:47,820
And as the perspective gets smaller,
we get more and more foreshortening.

437
00:33:47,820 --> 00:33:54,970
So it's as if you're getting closer and closer and
you've got really sort of wild 3D in this case.

438
00:33:54,970 --> 00:33:59,650
So here we add the perspective and we get a nice 3D effect.

439
00:33:59,650 --> 00:34:05,900
Now, there's one thing to note here, that perspective
is added on the photo container, not on the images.

440
00:34:05,900 --> 00:34:13,470
Perspective affects the rendering of child
elements that have transformed in 3D.

441
00:34:13,470 --> 00:34:19,250
Essentially, you can think of perspective as
setting up a 3D space for the elements underneath.

442
00:34:19,250 --> 00:34:25,550
So far, all of the transitions we've done
have been simple blends, if you like,

443
00:34:25,550 --> 00:34:27,730
between an initial state and a final state.

444
00:34:27,730 --> 00:34:31,500
We've got some really neat ones, including
3D, but they're all just simple blends.

445
00:34:31,500 --> 00:34:35,140
What if we want to do something a little
more complex, like this bats animation?

446
00:34:35,140 --> 00:34:41,150
Well, this is another use for keyframe animations.

447
00:34:41,150 --> 00:34:45,930
We saw a keyframe animation earlier because it gave us the
ability to have something that's continually repeating.

448
00:34:45,930 --> 00:34:49,620
In this case, we're going to use keyframe animations

449
00:34:49,620 --> 00:34:55,130
because they let us specify more
complex moves, using multiple keyframes.

450
00:34:55,130 --> 00:35:00,100
And just like transitions, keyframe
animations emit DOM events when they complete

451
00:35:00,100 --> 00:35:01,840
but also when they start and when they loop.

452
00:35:01,840 --> 00:35:05,700
So we can hook into the same event notifications
to know when our transitions are complete.

453
00:35:05,700 --> 00:35:13,950
So the actual properties, you've seen these already, the
@-WebKit-keyframes is where you set up the keyframes.

454
00:35:13,950 --> 00:35:20,210
And then this is the longhand property here, animation
name, which is where you actually apply those keyframes.

455
00:35:20,210 --> 00:35:26,200
One cycle of animation -- or duration of one cycle -- is
controlled by animation duration and the number of cycles

456
00:35:26,200 --> 00:35:31,540
by animation duration count and this has that key word
"infinite" if you want to just keep going on forever.

457
00:35:31,540 --> 00:35:36,660
And there's some other things you can do to control
the sort of behavior when the animation is repeating.

458
00:35:36,660 --> 00:35:41,760
You can have every other cycle of animation go backwards
to give you some interesting back and forth behavior.

459
00:35:41,760 --> 00:35:47,910
And then just like transitions, we
have an animation delay property.

460
00:35:47,910 --> 00:35:52,270
And we'll see a really neat use case for that in a moment.

461
00:35:52,270 --> 00:35:56,680
So let's build that drop animation using some keyframes.

462
00:35:56,680 --> 00:35:58,750
Here's the initial div.

463
00:35:58,750 --> 00:36:04,050
And I will set up these keyframes to describe the
states of the animation as the keyframe is running.

464
00:36:04,050 --> 00:36:08,980
Our initial state -- or our from state or 0%, same thing --

465
00:36:08,980 --> 00:36:14,860
is again, a translateY of -100%,
which puts the image above the box.

466
00:36:14,860 --> 00:36:20,430
And then at 70% of the way through the animation,
it has a translateY(0), so it's down in the box.

467
00:36:20,430 --> 00:36:23,950
And then this is how we do the little
bounce: we have an 83% keyframe that moves it

468
00:36:23,950 --> 00:36:28,360
up by 10% and then it falls down again to 0%.

469
00:36:28,360 --> 00:36:32,360
So that's enough to give us this nice little bounce effect.

470
00:36:32,360 --> 00:36:38,440
And here we apply those keyframes, we're using
the shorthand here, animation drop 1 second.

471
00:36:38,440 --> 00:36:40,820
So this is just going to run once over1 second.

472
00:36:40,820 --> 00:36:43,840
Note that we didn't change any
JavaScript, so we're still using

473
00:36:43,840 --> 00:36:49,240
that same JavaScript code you saw earlier in the session.

474
00:36:49,240 --> 00:36:53,130
So we've got these two types of animation:
we've got transitions and keyframe animations.

475
00:36:53,130 --> 00:36:57,120
And you're probably wondering why they
are two types and why isn't it just one?

476
00:36:57,120 --> 00:37:00,980
So let me compare these to explain the differences.

477
00:37:00,980 --> 00:37:05,550
Now the main difference is how they're triggered.

478
00:37:05,550 --> 00:37:13,520
You saw from the lightbox example that we got this
nice overlay fade by changing opacity from 0 to 1

479
00:37:13,520 --> 00:37:18,610
and because there was a transition rule in effect,
when the opacity changed, the transition ran.

480
00:37:18,610 --> 00:37:21,850
So transitions are triggered by changes
in the underlying property values.

481
00:37:21,850 --> 00:37:25,170
In other words, they run automatically but they're implicit.

482
00:37:25,170 --> 00:37:32,510
Keyframe animations, on the other hand, run when they're
applied explicitly, using the animation name property.

483
00:37:32,510 --> 00:37:39,040
So you put animation name on an element and as long as that
matches some keyframes, that element starts to animate.

484
00:37:39,040 --> 00:37:44,960
So the notion with keyframe animations is you're really
using CSS to put an element into an animating state.

485
00:37:44,960 --> 00:37:47,100
So that's quite different from transitions.

486
00:37:47,100 --> 00:37:54,910
Both of these use timing functions for animations or
keyframe animations; the time function is within keyframes.

487
00:37:54,910 --> 00:38:00,260
Of course, if you need keyframes, if you need
these more complex moves with multiple points

488
00:38:00,260 --> 00:38:02,490
in them, keyframe animations are the way to go.

489
00:38:02,490 --> 00:38:05,470
And they also allow you to have this repeating behavior,

490
00:38:05,470 --> 00:38:09,480
which we used for the spinning
indicator and alternating behavior.

491
00:38:09,480 --> 00:38:18,710
So far, the contents of our photo
gallery have just been images.

492
00:38:18,710 --> 00:38:22,260
But since these effects apply to any HTML element --

493
00:38:22,260 --> 00:38:26,400
and that include video, so we could put
video in our gallery if we wanted to.

494
00:38:26,400 --> 00:38:29,310
We actually will -- you'll see that in a demo in a minute.

495
00:38:29,310 --> 00:38:37,250
Or you could use SVG inside of HTML or Canvas or basically
any HTML content you can apply these CSS effects to.

496
00:38:37,250 --> 00:38:41,880
This gives you a lot of scope, a lot
of capabilities to do neat stuff.

497
00:38:41,880 --> 00:38:46,400
And actually, we're going to use
this now to create this tile effect.

498
00:38:46,400 --> 00:38:49,520
And I'll show you how to build this tile effect.

499
00:38:49,520 --> 00:38:53,770
But here effectively what we're doing
is where we had a single image before,

500
00:38:53,770 --> 00:39:00,560
we're going to replace that with a little subtree
of nodes, using divs, to give us the tile effect.

501
00:39:00,560 --> 00:39:08,170
So the way we create these tile effects
are to build a div and we're going to call

502
00:39:08,170 --> 00:39:11,970
that "tile container" just so we can style it.

503
00:39:11,970 --> 00:39:17,610
And tile container is the container for this grid of tiles.

504
00:39:17,610 --> 00:39:20,440
So each of these is a div itself.

505
00:39:20,440 --> 00:39:27,570
And then the way we tessellate them to
make it look like they're a single image is

506
00:39:27,570 --> 00:39:32,600
to use background position and to set a background image.

507
00:39:32,600 --> 00:39:38,210
And so we use background position to make sure that
the right part of the image is rendered into each tile.

508
00:39:41,330 --> 00:39:44,710
So this is a kind of thing you
could do in mock-up if you wanted --

509
00:39:44,710 --> 00:39:49,900
you could have 16 or 24 tiles as divs in your HTML content.

510
00:39:49,900 --> 00:39:53,920
But this type of repetitive stuff is much
better done with little bit of JavaScript.

511
00:39:53,920 --> 00:39:57,140
So this is the script you would
write to generate these tiles.

512
00:39:57,140 --> 00:40:03,650
So we're just iterating through the rows and
columns and for each tile, creating a div element.

513
00:40:03,650 --> 00:40:08,730
And then we compute whether elements positioned inside
the grid based on the row and column and the tile height

514
00:40:08,730 --> 00:40:11,390
and the tile width, which we know in advance.

515
00:40:11,390 --> 00:40:15,220
And then the tiles are absolutely positioned
so we can position very easily to form a grid

516
00:40:15,220 --> 00:40:18,330
and we do that by setting the left and top properties.

517
00:40:18,330 --> 00:40:22,570
And then here's the key to make
it look like it's a single image.

518
00:40:22,570 --> 00:40:27,610
We set the background image property, and here I've used
a hard-coded image but you probably use the next image

519
00:40:27,610 --> 00:40:30,160
in your slide show, which you'd feed into this function.

520
00:40:30,160 --> 00:40:37,560
And then you set the background image property to
minus tileX, minus tileY and that gets the correct part

521
00:40:37,560 --> 00:40:40,080
of the image rendered into this particular tile.

522
00:40:40,080 --> 00:40:45,580
So the next thing we do -- we've got this grid of tiles --

523
00:40:45,580 --> 00:40:48,700
we want to cause these tiles to
animate in some interesting way.

524
00:40:48,700 --> 00:40:52,240
And in this case we'll use a drop animation,
which is very similar to the one we just saw.

525
00:40:52,240 --> 00:40:58,030
But before we were running it on a single image;
here it's running on each individual tile.

526
00:40:58,030 --> 00:41:00,250
So this is the same set of keyframes.

527
00:41:00,250 --> 00:41:03,480
There's a slight difference here,
which is they've both added opacity.

528
00:41:03,480 --> 00:41:07,610
So here opacity is going to animate
between the 0% and 70% keyframes.

529
00:41:07,610 --> 00:41:11,520
This just shows you that it's possible to animate
multiple properties inside of keyframes --

530
00:41:11,520 --> 00:41:13,620
you're not limited to animating just one.

531
00:41:13,620 --> 00:41:18,440
And then here's where we apply the animation.

532
00:41:18,440 --> 00:41:23,260
The selector's a little more complex because we have
to apply this to the divs, which are direct children

533
00:41:23,260 --> 00:41:26,230
of the tile container when the tile
container's in the incoming state.

534
00:41:26,230 --> 00:41:33,350
So if we actually did that, this is what it would look like.

535
00:41:33,350 --> 00:41:34,630
And we didn't see any tiles.

536
00:41:34,630 --> 00:41:35,060
You know, what's up?

537
00:41:35,060 --> 00:41:38,430
Well, we've got this grid of tiles but
they're all animating at the same time,

538
00:41:38,430 --> 00:41:40,910
they're all in synchrony, so they just fall down as a block.

539
00:41:40,910 --> 00:41:42,340
And that doesn't really look very interesting.

540
00:41:42,340 --> 00:41:45,990
So we can add one more line to our JavaScript loop.

541
00:41:45,990 --> 00:41:51,290
And that line is going to set animation delay.

542
00:41:51,290 --> 00:41:57,060
So just as in the previous session, you saw a use
of transition delay that causes menus to build in;

543
00:41:57,060 --> 00:42:01,660
here we set animation delay to cause things
to happen at slightly different times.

544
00:42:01,660 --> 00:42:05,260
And we're making use of Math.random,
which is a JavaScript function

545
00:42:05,260 --> 00:42:08,000
that gives you back a random number between 0 and 1.

546
00:42:08,000 --> 00:42:14,640
So this sets animation delay to somewhere between
0 and 1 second, independently for each tile.

547
00:42:14,640 --> 00:42:17,450
So now when we run the transition,
we get this really cool effect.

548
00:42:17,450 --> 00:42:28,830
So just to summarize what we've learned from this tile
effect stuff: we can replace the single image in our gallery

549
00:42:28,830 --> 00:42:34,440
with a grid of tile elements or a grid of divs representing
tiles, and use background image and background position

550
00:42:34,440 --> 00:42:37,400
to have each tile render the right part of the image.

551
00:42:37,400 --> 00:42:39,800
And then we see how useful delays are.

552
00:42:39,800 --> 00:42:42,730
In the previous session, you saw
transition delay being put to good use

553
00:42:42,730 --> 00:42:45,890
and here animation delay is really great
for doing these neat build effects.

554
00:42:45,890 --> 00:42:52,560
So at this point, I'd like to invite
Enrica back to show you the gallery

555
00:42:52,560 --> 00:43:01,960
that we got when we put all of this stuff together.

556
00:43:01,960 --> 00:43:02,070
[ Applause ]

557
00:43:02,070 --> 00:43:03,080
>> Enrica Casucci: Hi again.

558
00:43:03,080 --> 00:43:08,380
So we're back to our photo gallery example
that we have seen before on my iPad.

559
00:43:08,380 --> 00:43:12,520
But this time we're going to make a look at it from a Mac.

560
00:43:12,520 --> 00:43:22,500
So here is a photo gallery and you've just learned
from Simon how easy it is to combine CSS transforms

561
00:43:22,500 --> 00:43:26,580
and animations to create a series of amazing effects.

562
00:43:26,580 --> 00:43:37,260
And you know, we have seen how easy it is to create a
crossfade, a push, or a push down, scale transforms.

563
00:43:37,260 --> 00:43:46,720
I want you to really appreciate, in this case we are using
larger images than the ones we have used for the iPad demo.

564
00:43:46,720 --> 00:43:52,910
And notice how smooth the transition
is, even with these larger images.

565
00:43:56,210 --> 00:44:04,780
But what really makes a difference is when you start using
the 3D transforms because not only you create, you know,

566
00:44:04,780 --> 00:44:15,340
some very cool effects like this one, but it also opens
up a world of possibilities in terms of what you can do

567
00:44:15,340 --> 00:44:19,370
to present additional content that
is related to your images.

568
00:44:19,370 --> 00:44:25,730
Let's say for example you want to show some
text or date associated with the picture.

569
00:44:25,730 --> 00:44:31,160
And so why not simply flip the
image on the back and show it?

570
00:44:31,160 --> 00:44:32,290
Isn't that cool?

571
00:44:32,290 --> 00:44:37,210
[ Applause ]

572
00:44:37,210 --> 00:44:42,260
We've seen the revolving door, the swap, and the cube.

573
00:44:42,260 --> 00:44:46,870
And remember, all these transitions
that we have seen up to this point,

574
00:44:46,870 --> 00:44:52,290
they all use the same JavaScript;
we've only changed the CSS.

575
00:44:52,290 --> 00:45:02,350
And as Simon mentioned, with HTML5, video elements
have become first-class citizens in the web world.

576
00:45:02,350 --> 00:45:07,750
So all these effects that we have seen apply
to images can be applied to video elements

577
00:45:07,750 --> 00:45:12,340
as well, and we can have something like this.

578
00:45:12,340 --> 00:45:14,200
Notice that the video is playing.

579
00:45:14,200 --> 00:45:20,520
I can still flip it on the back and show my additional
information while the video is still playing.

580
00:45:20,520 --> 00:45:26,180
[ Applause ]

581
00:45:26,180 --> 00:45:31,240
Look, now that I'm showing you the transition
in slow motion that you can really appreciate

582
00:45:31,240 --> 00:45:35,400
that the video is playing while
the transition is taking place.

583
00:45:35,400 --> 00:45:38,010
I think this is absolutely awesome.

584
00:45:38,010 --> 00:45:49,570
Then with a little bit of JavaScript, you can easily
create this fantastic tiling effect that you have seen.

585
00:45:49,570 --> 00:45:56,820
And, you know, this is just a combination of rotation
with the same technique you have seen before.

586
00:45:56,820 --> 00:46:01,590
But now that you know how to slice
up the images, the sky's the limit.

587
00:46:01,590 --> 00:46:14,030
You can create unfolding effects like this one or this one
that you got a sneak preview before or something like this.

588
00:46:14,030 --> 00:46:17,020
This is when you're supposed to do "Wow."

589
00:46:17,020 --> 00:46:22,570
[ Applause ]

590
00:46:22,570 --> 00:46:29,230
Let me show it to you one more time in slow motion so
you can fully appreciate how smooth the transition is.

591
00:46:29,230 --> 00:46:30,340
>> Wow.

592
00:46:30,340 --> 00:46:30,980
>> Enrica Casucci: Thank you.

593
00:46:30,980 --> 00:46:34,790
That's what I wanted to hear.

594
00:46:34,790 --> 00:46:37,340
[ Laughter ]

595
00:46:37,340 --> 00:46:39,890
[ Applause ]

596
00:46:39,890 --> 00:46:44,610
I hope at this point I got you
all fired up and I hope I was able

597
00:46:44,610 --> 00:46:47,950
to communicate the excitement I have for this technology.

598
00:46:47,950 --> 00:46:56,350
We have some great labs tomorrow and we hope to see you all
there and come over and start playing with our sample code.

599
00:46:56,350 --> 00:46:58,290
I'll give you back to Simon.

600
00:46:58,290 --> 00:46:59,570
That is going to wrap up the session.

601
00:46:59,570 --> 00:47:00,020
Thank you.

602
00:47:00,020 --> 00:47:00,080
[ Applause ]

603
00:47:00,080 --> 00:47:02,110
>> Simone Fraser: Thank you, Enrica.

604
00:47:02,110 --> 00:47:06,990
I think that really was an awesome photo gallery.

605
00:47:06,990 --> 00:47:11,610
So let me just take a moment to summarize
where these things are supported.

606
00:47:11,610 --> 00:47:21,400
So I talked about four categories of CSS effects today:
2D transforms, 3D transforms, transitions, and animations.

607
00:47:21,400 --> 00:47:28,740
And all of these are supported on
iPhone and iPad since iPhone 2.0.

608
00:47:28,740 --> 00:47:33,490
Safari on Mac has supported all of these
since Safari 4 and now with Safari 5,

609
00:47:33,490 --> 00:47:36,120
we have support across the board on Mac and Windows.

610
00:47:36,120 --> 00:47:41,380
And then Chrome supports these;
they don't have 3D rendering.

611
00:47:41,380 --> 00:47:46,470
And some of the other browsers are catching up too, now
-- Opera and Firefox have 2D transforms and transitions.

612
00:47:46,470 --> 00:47:53,270
So let me summarize what we've learned in today's session.

613
00:47:53,270 --> 00:48:00,260
First of all, using CSS transitions and animations, you can
get really neat animations with very little authoring work.

614
00:48:00,260 --> 00:48:06,330
In many cases, it's just one line of CSS to go
from a jarring transition to a nice, smooth one.

615
00:48:06,330 --> 00:48:11,970
And you can get great performance
even on devices like iPhone and iPad.

616
00:48:11,970 --> 00:48:14,830
And you'll get generally much better
performance than you would if you used one

617
00:48:14,830 --> 00:48:18,250
of the JavaScript libraries that's running
JavaScript time as to do animation.

618
00:48:18,250 --> 00:48:25,970
And then with CSS transforms, we can position elements and
transform them both in two dimensions and three dimensions.

619
00:48:25,970 --> 00:48:30,910
And as Enrica mentioned, this opens all sorts of
possibilities for interesting ways of user interaction,

620
00:48:30,910 --> 00:48:34,450
flipping things around, building
things like cubes and rings.

621
00:48:34,450 --> 00:48:38,740
And you've probably seen a bunch of examples
and there's a lot of sample code for this.

622
00:48:38,740 --> 00:48:42,110
But another great thing about animations
-- sorry, about transforms --

623
00:48:42,110 --> 00:48:46,090
is that they work very well with transitions and animations.

624
00:48:46,090 --> 00:48:50,180
By running transitions between
different types of 3D transforms,

625
00:48:50,180 --> 00:48:54,050
you can get all sorts of really cool effects
and the animations run really smoothly.

626
00:48:54,050 --> 00:48:58,790
So there's a great synergy between these two things.

627
00:48:58,790 --> 00:49:03,270
And finally, not just images but as you saw,
we can have great performance running these

628
00:49:03,270 --> 00:49:08,080
on video as well and any other HTML element.

629
00:49:08,080 --> 00:49:13,330
So for more information, you can contact Vicki
Murley, the Safari Technologies Evangelist.

630
00:49:13,330 --> 00:49:16,710
And there's great documentation on the Safari Dev Center.

631
00:49:16,710 --> 00:49:21,440
If you want to go and look at the CSS specifications
and follow the workings of the CSS working group,

632
00:49:21,440 --> 00:49:23,210
you can look at the current work page there.

633
00:49:23,210 --> 00:49:27,220
And then the Apple developer forums are
another great place to go and get help.

