WEBVTT

00:00:06.150 --> 00:00:08.290
[ Applause ]

00:00:08.290 --> 00:00:09.470
>> Andrew Platzer: Good afternoon.

00:00:09.470 --> 00:00:14.000
Welcome to Optimizing Your iPhone
App for the new Retina Display.

00:00:14.000 --> 00:00:18.610
My name is Andrew Platzer, I work
on iOS application frameworks,

00:00:18.610 --> 00:00:21.610
and I'll be talking about the changes
you need make to your application

00:00:21.610 --> 00:00:24.590
on the UIKit side in order to support the new display.

00:00:24.590 --> 00:00:29.080
And then Richard Schreyer will be
talking about the OpenGL side of things.

00:00:29.080 --> 00:00:33.580
So hopefully you saw the talk, of course,
the Keynote, and you saw the new display.

00:00:33.580 --> 00:00:37.380
I guess you haven't had much chance to
actually see the display in real life,

00:00:37.380 --> 00:00:41.010
but it really looks good, it is just amazing.

00:00:41.010 --> 00:00:48.450
And we do a lot of stuff for you, but there's a lot of
stuff you can do to make your application look much better.

00:00:48.450 --> 00:00:54.060
With the new display, with the very high resolution,
it gives you a chance to really refine your visuals.

00:00:54.060 --> 00:00:56.940
We do some of that for you, we
give you the high resolution text.

00:00:56.940 --> 00:00:59.550
But you can provide high resolution images at the same time

00:00:59.550 --> 00:01:03.410
and make the app look like it was
designed for the new phone.

00:01:03.410 --> 00:01:08.940
It gives you a chance to make your
application a bit more immersive, you know,

00:01:08.940 --> 00:01:11.760
people completely forget that it's a phone.

00:01:11.760 --> 00:01:15.390
They won't see any pixels, all they
do is concentrate your application.

00:01:15.390 --> 00:01:18.670
And this is not just for games,
but for any kind of application.

00:01:18.670 --> 00:01:22.100
All they see is your content, your program.

00:01:22.100 --> 00:01:27.390
Of course now you have to support two different devices
with two different resolutions, which makes it a little bit

00:01:27.390 --> 00:01:30.000
of work, but not too much, hopefully, for you.

00:01:30.000 --> 00:01:31.690
And of course there are compatible issues.

00:01:31.690 --> 00:01:36.210
If you're going write code for the new resolution,
you're going to make sure that it continues to run

00:01:36.210 --> 00:01:42.030
on old applications -- or old hardware,
rather, so that it looks good on both.

00:01:42.030 --> 00:01:44.980
So I'll talk about the changes you need to make in UIKit.

00:01:44.980 --> 00:01:47.810
And here are the topics I'm going to cover.

00:01:47.810 --> 00:01:50.800
First I want to talk about how we're
going to implement compatibility

00:01:50.800 --> 00:01:55.320
so the application continues to
run on both old and new hardware.

00:01:55.320 --> 00:01:59.000
We'll talk about how you can provide
resolution images at the same time,

00:01:59.000 --> 00:02:03.140
still providing lower resolution images for older hardware.

00:02:03.140 --> 00:02:07.720
Talk a bit about how the view system
implements drawing in high resolution,

00:02:07.720 --> 00:02:14.790
what you can do when you're actually drawing your
view, to draw finer lines and so on, finer images.

00:02:14.790 --> 00:02:20.660
I'll talk a little bit about the underpinnings that Core
Graphics, and Core Animation that UIKit sits on top of,

00:02:20.660 --> 00:02:26.790
and how they implement high resolution, and finally, how
you can provide high resolution icons and launch images

00:02:26.790 --> 00:02:30.820
when the application is launching so it looks
like your application belongs on the new hardware.

00:02:30.820 --> 00:02:35.710
So first I want to talk about points not equal to pixels.

00:02:35.710 --> 00:02:39.850
What this really means is that in the old
days we would use these interchangeably.

00:02:39.850 --> 00:02:45.280
We would say I'm drawing a 100
pixel-wide image in 100 point sized view.

00:02:45.280 --> 00:02:46.560
And they'd be 1 to 1.

00:02:46.560 --> 00:02:49.670
And on the desktop and so on you're used to that too.

00:02:49.670 --> 00:02:50.680
It was pretty much a given.

00:02:50.680 --> 00:02:55.720
I mean, we didn't make any distinction about it.

00:02:55.720 --> 00:02:59.050
But now this is no longer true.

00:02:59.050 --> 00:03:05.200
We're now going use only points, but
these points are device independent.

00:03:05.200 --> 00:03:16.900
So your old application still uses the same values as it did
before, but now they're no longer a match for the pixels.

00:03:16.900 --> 00:03:27.550
So the Retina display has a 2x screen, exactly one point
now equals 2 pixels instead of 1 point equal 1 pixels.

00:03:27.550 --> 00:03:31.590
There's some advantages to having an exact 2x screen.

00:03:31.590 --> 00:03:33.230
You don't have to worry about fuzzy pixels.

00:03:33.230 --> 00:03:37.610
So for example if you're drawing a 1 point
line you won't get one-and-a-half pixels,

00:03:37.610 --> 00:03:43.910
and then you'll have half a pixel blur, maybe even spanning
3 pixels, depending on the size of the screen and so on.

00:03:43.910 --> 00:03:45.440
You don't have to worry about pixel cracks.

00:03:45.440 --> 00:03:48.150
That's where you're trying to put
two images right next to each other.

00:03:48.150 --> 00:03:53.040
But because one of the images doesn't quite fit
across the pixel boundary you'll see a thin line.

00:03:53.040 --> 00:03:58.960
And in fact on the device we have a special
mode where when the information is --

00:03:58.960 --> 00:04:04.040
when the image is sort of sent to the
screen at 2x, we don't do any interpolation.

00:04:04.040 --> 00:04:07.650
So you get an exact copy of what
you would see on an old device.

00:04:07.650 --> 00:04:12.650
Just every single pixel on the old device now
takes two pixels, 2x2 pixel grid on the new device.

00:04:12.650 --> 00:04:14.960
So it looks identical.

00:04:14.960 --> 00:04:22.710
But of course with the 2x resolution you have more memory
and you're moving more pixels around, more bits around.

00:04:22.710 --> 00:04:24.120
So you have to be aware of that.

00:04:24.120 --> 00:04:28.740
If you have a very graphics intensive application
where you have tons and tons of images,

00:04:28.740 --> 00:04:32.010
be aware you're going to have 4x
as much storage for those images.

00:04:32.010 --> 00:04:36.710
And if you're drawing a lot you're
going to be impacting your performance.

00:04:36.710 --> 00:04:38.140
Some of it helps with the newer hardware.

00:04:38.140 --> 00:04:42.670
But you know, it may not be enough.

00:04:42.670 --> 00:04:49.250
So here, for example, is a screen shot of Safari, taken
from the simulator running in the old hardware, simulator,

00:04:49.250 --> 00:04:51.780
and running with the new iPhone 4 simulator.

00:04:51.780 --> 00:04:54.690
I know you can't see very much, let's zoom up the first one.

00:04:54.690 --> 00:04:59.990
So you can start to see that there's a much better
quality of not just the text but the graphics.

00:04:59.990 --> 00:05:04.030
We can zoom in a little bit more, so you
can see really how much better it looks.

00:05:04.030 --> 00:05:09.590
You can see the text, not only is the text sharper, but
things like the Wi-Fi indicator, much, much sharper.

00:05:09.590 --> 00:05:13.230
The rounded corner on the text field, very nice and smooth.

00:05:13.230 --> 00:05:19.090
And even things like for example in the web
page itself, the word store looks much --

00:05:19.090 --> 00:05:23.460
you could actually read it on the new
display, it was just a blur on the old one.

00:05:23.460 --> 00:05:30.290
So there's a much better opportunity to present your
information without having to zoom in on it, if possible.

00:05:30.290 --> 00:05:34.350
And the user doesn't have to sit there
and zoom in all the time to see that.

00:05:34.350 --> 00:05:35.490
So what's the point.

00:05:35.490 --> 00:05:38.400
Well, we could give it a fancy
name like some other frameworks do.

00:05:38.400 --> 00:05:43.340
Call it, like, device-independent
measurement of pixel elements, or dimples.

00:05:43.340 --> 00:05:45.930
But maybe you don't want to say
that, so we'll just stick with point,

00:05:45.930 --> 00:05:48.960
so we'll just use the word point
because everybody's used to it.

00:05:48.960 --> 00:05:51.190
There's no fixed size to it, we're not going be pedantic,

00:05:51.190 --> 00:05:55.850
we're not going to say it's exactly
120 points to an inch or whatever.

00:05:55.850 --> 00:06:00.720
I mean, each different display has
a different resolution already.

00:06:00.720 --> 00:06:04.990
Different than iPhone 3GS, for example, and the iPad.

00:06:04.990 --> 00:06:08.290
So a good, you know, rule of thumb is
you know what a point is when you see it.

00:06:08.290 --> 00:06:18.560
10 point font is reasonably readable, you know, 45 -- 40
point by 40 point area is something that is easy to tap on.

00:06:18.560 --> 00:06:21.300
You don't want to get any smaller than that if possible.

00:06:21.300 --> 00:06:26.500
So as I said, we now work solely in points.

00:06:26.500 --> 00:06:29.210
So everything -- everything in the UIKit is just points.

00:06:29.210 --> 00:06:31.070
There's no mention of pixels.

00:06:31.070 --> 00:06:34.000
And so of course we start at the bottom, with UIScreen.

00:06:34.000 --> 00:06:36.800
UIScreen has a new read only property that's called scale.

00:06:36.800 --> 00:06:42.920
And of course on old hardware it's
1.0, and on new hardware it's 2.0.

00:06:42.920 --> 00:06:45.420
And so the points is in bounds.

00:06:45.420 --> 00:06:51.080
So you're no longer referring to the size of the pixels
in the screen you're referring to the point size.

00:06:51.080 --> 00:06:55.800
And so it's still 320x40, and of course the
advantage for that is there's no UI relayout.

00:06:55.800 --> 00:07:00.480
You don't have to suddenly multiply your
window size or your view sizes or anything

00:07:00.480 --> 00:07:02.630
by two in order to fit on the new screen.

00:07:02.630 --> 00:07:05.360
Everything just stays the same.

00:07:05.360 --> 00:07:11.120
This also means that UITouches, the location
and view, the point value, is in points.

00:07:11.120 --> 00:07:16.320
But this means you might get fractional
points, 10.5, for example.

00:07:16.320 --> 00:07:21.020
So if you're trying to too some exact integer comparison
for a particular location, you've got to watch out for that,

00:07:21.020 --> 00:07:23.730
because of course, you might be half a point off.

00:07:23.730 --> 00:07:28.090
And you'll notice this for example in the simulator,
especially where of course you can be exactly accurate

00:07:28.090 --> 00:07:31.920
on a half point boundary, a single pixel boundary.

00:07:31.920 --> 00:07:36.910
And it means of course that there's no UI
layout, UIWindow.frames are also in points.

00:07:36.910 --> 00:07:40.460
So 320x480 window is still full screen.

00:07:40.460 --> 00:07:44.970
And wherever you position your window, if
you have another window on top, for example,

00:07:44.970 --> 00:07:50.470
that doesn't fill the screen it still remains
in the same place on the new iPhone 4.

00:07:50.470 --> 00:07:55.180
So as I said, we're working with points only and not pixels.

00:07:55.180 --> 00:08:00.630
UIImage of course works with pixels,
it works in concert with Core Graphics.

00:08:00.630 --> 00:08:07.870
We -- the UIImage.size property which is already
there is as I said, everything else, in points.

00:08:07.870 --> 00:08:11.780
This means we have to add a new property,
just like we do in screen, called scale.

00:08:11.780 --> 00:08:17.780
And this maps from the point size that
we specify to the CG images pixel size.

00:08:17.780 --> 00:08:25.370
And so the -- if you're going to work with the pixels
directly, be warned that this value has changed.

00:08:25.370 --> 00:08:29.380
I've seen people actually use the
image size as a convenient way,

00:08:29.380 --> 00:08:32.750
after getting the CGImage in order to work with the size.

00:08:32.750 --> 00:08:36.910
Now you'll be rudely surprised when you only
get a quarter of your image, for example.

00:08:36.910 --> 00:08:42.160
If you want to, you should use CGImageGetWidth, GetHeight
in order to determine the actual pixel dimensions

00:08:42.160 --> 00:08:47.390
of the CGImage ref that's attached to the UIImage.

00:08:47.390 --> 00:08:52.710
So now you've got -- we can support
2x images using the scale property.

00:08:52.710 --> 00:08:54.800
You want to be able to load this.

00:08:54.800 --> 00:08:58.330
Well, we do a lot of it automatically for you.

00:08:58.330 --> 00:09:01.840
All you need to do is create a new file
with the same name as an existing file.

00:09:01.840 --> 00:09:07.870
So for example, if you have Button.png just
create a new file called Button@2x.png.

00:09:07.870 --> 00:09:09.050
Make it twice as big.

00:09:09.050 --> 00:09:16.420
So if you're got a 100x100 button, create a 200x200
pixel button and just drop it in the exact same place.

00:09:16.420 --> 00:09:17.880
We'll automatically load that.

00:09:17.880 --> 00:09:24.850
We'll insert that suffix before the extension,
the @2x, which things like call to imageNamed

00:09:24.850 --> 00:09:29.500
and imageWithContentsOfFile, and return
that scaled UIImage automatically.

00:09:29.500 --> 00:09:31.730
So you don't have to do anything in terms of code.

00:09:31.730 --> 00:09:34.510
We'll just return it.

00:09:34.510 --> 00:09:42.140
Note that if you do -- when we do load that
image in, for compatibility, we ignore the DPI.

00:09:42.140 --> 00:09:47.630
We had some applications when we were developing
this which actually provided us with 300 DPI images,

00:09:47.630 --> 00:09:51.330
which of course these appeared
very, very tiny on the screen.

00:09:51.330 --> 00:09:54.630
And since these images are intended
to be used by your interface,

00:09:54.630 --> 00:09:58.690
not as sort of a general image editing
program, we ignore the DPI completely.

00:09:58.690 --> 00:10:04.090
So we only look at whether there's an @2x
extension to determine if we need to scale up.

00:10:04.090 --> 00:10:07.790
Or if we need to set a 2x image scale.

00:10:07.790 --> 00:10:12.950
In iOS 4 now we've added a few new
methods and a few new behaviors.

00:10:12.950 --> 00:10:17.070
One of them is that you no longer need to
include the .png when you call image names.

00:10:17.070 --> 00:10:19.400
So just say imageNamed button, for example.

00:10:19.400 --> 00:10:23.020
That will save you having to remember to
type that all the time and be confused as to

00:10:23.020 --> 00:10:25.680
when your image doesn't load the first time.

00:10:25.680 --> 00:10:31.610
We added a couple of class on instance creation
methods that take both the scale and an orientation.

00:10:31.610 --> 00:10:37.460
So now you can create a full UIImage using your own
CGImage ref that has both the scale and orientation set.

00:10:37.460 --> 00:10:48.180
And one case where we do work with the DPI resolution is
when you ask for the NSData using UIImageJPEGRepresentation

00:10:48.180 --> 00:10:55.230
or PNGRepresentation, will actually take the scale, assume
a sort of standard of 72 dots per inch as a scale of 1.0,

00:10:55.230 --> 00:11:02.400
and we'll create a PNG that's marked as 144 DPI for
example, if you have a scale of 2.0 for that image set.

00:11:02.400 --> 00:11:06.250
Through again, if you were to read it in using
the standard calls we would ignore that DPI.

00:11:06.250 --> 00:11:13.680
I'll talk a bit how you can actually
get that DPI a bit later.

00:11:13.680 --> 00:11:20.530
If you wanted to draw an image off screen, we give
you a function called UIGraphicsBeginImageContent.

00:11:20.530 --> 00:11:25.100
And it took a single parameter which was the
size, and this size was effectively in pixels.

00:11:25.100 --> 00:11:30.070
Which meant there was an implicit scale of
1.0, and also that we automatically assumed

00:11:30.070 --> 00:11:33.470
that the image had some transparency in it.

00:11:33.470 --> 00:11:41.820
So when we created the CGImage ref underneath, we would
have an alpha info saying there was an alpha channel there.

00:11:41.820 --> 00:11:46.960
We've extended this a little bit in the
new iOS 4, we've added a new function

00:11:46.960 --> 00:11:50.810
with options called UIGraphicsBeginImageContextWithOptions.

00:11:50.810 --> 00:11:54.940
This function takes the size as before,
but as everything else in UIKit now,

00:11:54.940 --> 00:11:57.760
this is effectively in points and not pixels.

00:11:57.760 --> 00:11:59.400
It takes a scale.

00:11:59.400 --> 00:12:01.250
And the scale can be any value you want.

00:12:01.250 --> 00:12:04.140
But we do have a special meaning for the scale value of 0.

00:12:04.140 --> 00:12:07.860
This says use the same scale as the main screen.

00:12:07.860 --> 00:12:14.340
So on the new phone, this value will implicitly
be 2.0, on other older hardware, it will be 1.0.

00:12:14.340 --> 00:12:19.040
So you can just pass on 0 and stay compatible no
matter what kind of hardware you're running on.

00:12:19.040 --> 00:12:22.780
And we also provide you a simple Boolean opacity flag.

00:12:22.780 --> 00:12:29.540
And this just tells us when we're creating the
CGImage ref underneath that we don't have any alpha.

00:12:29.540 --> 00:12:31.690
Now this unfortunately is not a space saving.

00:12:31.690 --> 00:12:33.920
We still need some padding for efficiency.

00:12:33.920 --> 00:12:38.900
It's actually still faster to draw it,
if we include padding for the alpha.

00:12:38.900 --> 00:12:43.670
But it does let you gain some performance by
telling us that this image is completely opaque,

00:12:43.670 --> 00:12:47.830
so we don't need to do any blending when we draw the image.

00:12:47.830 --> 00:12:54.380
And one good thing now also in iOS 4, and the reason that
you can begin to really use this function everywhere,

00:12:54.380 --> 00:12:59.300
even on secondary threads, is we've
made drawing thread safe in iOS 4.

00:12:59.300 --> 00:13:05.220
This means that if you can use any combination of
UIColor, UIFont, the NSString drawing extensions

00:13:05.220 --> 00:13:11.690
for actually drawing strings, UIImage drawing, and
so on, UIBezierPath, you can use in any thread.

00:13:11.690 --> 00:13:13.350
Every thread has its own context.

00:13:13.350 --> 00:13:16.670
So if you call this function multiple
threads you'll get multiple contexts,

00:13:16.670 --> 00:13:21.080
and you can extract images from
each of those contexts at any time.

00:13:21.080 --> 00:13:23.830
You don't have to worry about any threading issues there.

00:13:23.830 --> 00:13:27.220
So this let's you really you know,
render stuff on a secondary thread.

00:13:27.220 --> 00:13:31.260
You're filling, you know, rendering the
contents for a table cell, you know,

00:13:31.260 --> 00:13:33.730
as it fills in because it takes a lot of time to render.

00:13:33.730 --> 00:13:41.230
You can do that in the background and then have your
interface appear right away and slowly fill things in.

00:13:41.230 --> 00:13:47.080
So now we've got some high resolution images which we
can load or we can create using off screen buffers.

00:13:47.080 --> 00:13:48.980
We'll want to be able to draw.

00:13:48.980 --> 00:13:55.250
We'll also want to draw other stuff in high
resolution directly when drawRect is called.

00:13:55.250 --> 00:13:59.370
So UIView has a new parameter,
one new one as well, also a scale.

00:13:59.370 --> 00:14:02.470
Now this one's named slightly differently
a little bit more complex.

00:14:02.470 --> 00:14:05.200
It's called UIView.contentScaleFactor.

00:14:05.200 --> 00:14:10.010
And the reason we call it that rather than
just scale is to differentiate what it effects.

00:14:10.010 --> 00:14:13.500
It does not effect anything but the content.

00:14:13.500 --> 00:14:16.230
This on the CALayer is the content's property.

00:14:16.230 --> 00:14:21.850
Which is usually something like a CGImage ref or the
contents that you generate when drawRect is called.

00:14:21.850 --> 00:14:28.470
It does not effect the geometry or the scales
or the transforms of the view or any subviews.

00:14:28.470 --> 00:14:32.580
So a view of a view with some subviews,
and you go from a 1.0

00:14:32.580 --> 00:14:37.050
to a 2.0 contentScaleFactor, none
of the subviews will change.

00:14:37.050 --> 00:14:43.400
If you already scaled the UIView setting an affine
transform, again, setting the consent scale factor,

00:14:43.400 --> 00:14:48.080
will not suddenly resize your view
twice as big or half as big or whatever.

00:14:48.080 --> 00:14:54.270
It just effects how the content of that view
usually whatever it is, an image or such,

00:14:54.270 --> 00:14:58.780
gets positioned and scaled inside that view.

00:14:58.780 --> 00:15:02.180
It always returns a nonzero value just so you can use it,

00:15:02.180 --> 00:15:07.710
divide by it safely without having
to worry about a divide by 0 case.

00:15:07.710 --> 00:15:10.410
And in general, it's 1.0.

00:15:10.410 --> 00:15:12.520
But there are a couple of cases where we do set it.

00:15:12.520 --> 00:15:13.720
The first is in the drawRect.

00:15:13.720 --> 00:15:19.980
So if you have UIView subclass that implements drawRect
where it's placed in a window that's on the screen,

00:15:19.980 --> 00:15:24.420
that's 2.0 scale, we will set the contentScaleFactor to 2.0.

00:15:24.420 --> 00:15:29.790
And this kicks off a bunch of things that
happen automatically to handle high resolution.

00:15:29.790 --> 00:15:38.250
Also UIImageView, when you set an UIImage into that image
view with the scale of 2.0 we tell the UIView that "Oh

00:15:38.250 --> 00:15:40.010
by of the way, you've got some content here."

00:15:40.010 --> 00:15:48.170
In this case, a fixed CGImage ref, or UIImage with
a CGImage ref that has a larger scale than 1.0.

00:15:48.170 --> 00:15:50.350
And in general, you know, you never need to set it.

00:15:50.350 --> 00:15:53.300
I mean, you're not setting content directly, really,

00:15:53.300 --> 00:15:57.910
you're either setting it using UIImageViews
or when we call you with the drawRecs.

00:15:57.910 --> 00:16:05.970
So it's something -- where it is writable
property, but you probably never need to set it.

00:16:05.970 --> 00:16:09.990
So with the drawRect call, most common
case where you're generating actual content

00:16:09.990 --> 00:16:14.260
for that particular view rather than
assembling it using other subviews.

00:16:14.260 --> 00:16:18.660
The rectangle we pass in, drawRect, is in points,
just like everything else, as I've mentioned.

00:16:18.660 --> 00:16:23.640
There's a bitmap buffer underneath which
is twice as big on the new iPhone 4.

00:16:23.640 --> 00:16:27.780
So if you have 100x100 view, you'll
get a 200x200 pixel buffer.

00:16:27.780 --> 00:16:32.820
Now what we do for that is that when we call
your drawing called, we set up a CG context ref,

00:16:32.820 --> 00:16:36.480
which is you get from UIGraphicsGetCurrentContext.

00:16:36.480 --> 00:16:41.220
And that will have a CTM, a current
transform matrix set up to have that scaling.

00:16:41.220 --> 00:16:48.690
So when you draw a 100x100 box, for example, it
scaled up twice as big to be 200x200 pixel box,

00:16:48.690 --> 00:16:51.980
when it finally gets rendered into the buffer.

00:16:51.980 --> 00:16:56.540
So this is all set up automatically for you when you set
up for you when you set up the view contents scale factor.

00:16:56.540 --> 00:16:59.470
We also set up some other internal parameters as necessary,

00:16:59.470 --> 00:17:05.850
so that text rendering when we generate the
actual text bitmap is at high resolution.

00:17:05.850 --> 00:17:10.730
And of course UIBezierPath which sits on
top of CG bezierPath is drawn much smoother.

00:17:10.730 --> 00:17:15.340
The aliasing, the line, as the curve
goes, where it's partially covered,

00:17:15.340 --> 00:17:18.750
much finer than it was before, so it looks much smoother.

00:17:18.750 --> 00:17:27.300
You can use the UIViewContentScaleFactor to determine
the size of a single pixel, so this is where, you know,

00:17:27.300 --> 00:17:29.490
it returns nonzero value, you can just use that.

00:17:29.490 --> 00:17:31.480
And I'll show you how those works.

00:17:31.480 --> 00:17:38.170
So for example, let's say you want to draw a single
one pixel wide horizontal line using UIRectFill.

00:17:38.170 --> 00:17:40.490
Pretty standard way of doing a horizontal line.

00:17:40.490 --> 00:17:46.110
Currently, you would do something like you know,
CGRectFill, CGRectMake, sorry, should be RectFill, sorry,

00:17:46.110 --> 00:17:49.660
CGRectMake 0.0, 0.0 width and then height of 1.0.

00:17:49.660 --> 00:17:53.060
And of course on the new display,
that will draw a two pixel high line.

00:17:53.060 --> 00:17:54.830
So you want something a little bit finer.

00:17:54.830 --> 00:18:00.220
All you need to do is get the content scale
factor which will be 2 on a view on a new display.

00:18:00.220 --> 00:18:02.290
And divide 1 -- divide that into 1.

00:18:02.290 --> 00:18:07.320
So you get 0.5, in this case, on a
new display, 1.0 on an old display.

00:18:07.320 --> 00:18:12.600
And then when you fill to that height you'll get a
single pixel no matter what display you're running on.

00:18:12.600 --> 00:18:16.130
Similarly with the UIBezierPath,
you know, you'll do the same thing.

00:18:16.130 --> 00:18:17.440
You'll get beziePath.

00:18:17.440 --> 00:18:21.680
You will set the path width to be 1
divided by the few content scale factor.

00:18:21.680 --> 00:18:25.130
So you know how the 0, it's going to be 1.0 or 0.5.

00:18:25.130 --> 00:18:31.320
And then here, for example, we've done a little code where
we've moved to (0,0), moved to the width, and we draw.

00:18:31.320 --> 00:18:36.060
Of course if you used bezierPath before, you'll
have run across which when you stroke it,

00:18:36.060 --> 00:18:41.010
that it actually spans multiple pixels
because the pen goes along that point.

00:18:41.010 --> 00:18:44.020
So, you'll just need to adjust the line a little bit.

00:18:44.020 --> 00:18:45.890
Shift it down by half a pixel.

00:18:45.890 --> 00:18:48.990
In this case, literally a quarter point.

00:18:48.990 --> 00:18:52.920
Because one point equals half a
-- half a point equals 1 pixel.

00:18:52.920 --> 00:18:58.180
And then stroke between those two lines to
get a nice thing, nice single pixel line.

00:18:58.180 --> 00:19:04.010
And of course if you're doing curves and such, you're
going to have, you know partial pixels along the way,

00:19:04.010 --> 00:19:07.850
and it will be very nice and smooth there too.

00:19:07.850 --> 00:19:11.060
UIImage, before as I said, has a scale value.

00:19:11.060 --> 00:19:16.490
The scale value is used whenever you call the
various draw methods, drawAtPoint or drawOnRect.

00:19:16.490 --> 00:19:23.500
DrawOnPoint uses the image size which is in
points, to draw, to determine how big to draw.

00:19:23.500 --> 00:19:30.840
And UIImageView as I mentioned before automatically
sets the contentScaleFactor to the image's scale factor.

00:19:30.840 --> 00:19:37.370
This is not as important, it's actually scaling to
fill because it was automatically scale the contents

00:19:37.370 --> 00:19:39.880
of the image to fit no matter what size you make it.

00:19:39.880 --> 00:19:45.000
But if you're using one of the other content
modes, let's say center or top left positioning,

00:19:45.000 --> 00:19:49.250
then you need to tell us how big the actual
image is, otherwise it will appear way too big.

00:19:49.250 --> 00:19:55.310
So for example, if you had a set to center mode and you
didn't tell us the scale was 2, then you would have an image

00:19:55.310 --> 00:19:59.170
that was twice as big, and it would probably
go past the edge of the bounds of the view.

00:19:59.170 --> 00:20:05.510
Whereas it will be shrunk to the correct size
when you have the image scale set to 2.0.

00:20:05.510 --> 00:20:08.540
You should, if you're going to
provide multiple images to UIView,

00:20:08.540 --> 00:20:14.640
and that can be done either via setting a highlighted image
and then setting the highlighted state on the UIImageView

00:20:14.640 --> 00:20:19.220
or providing an array of UIImages
that you're going to animate.

00:20:19.220 --> 00:20:21.210
They all should be the same scale factor.

00:20:21.210 --> 00:20:23.020
We don't sort of on the fly adjust.

00:20:23.020 --> 00:20:28.300
So if we're playing a set of animations from a set of
UIImages, we're not going to suddenly go from 2 to 1 to 2

00:20:28.300 --> 00:20:30.930
to 1 or whatever, as your image
goes, so you've got to make sure

00:20:30.930 --> 00:20:34.680
that all the images you provide
have all the same scale factor.

00:20:34.680 --> 00:20:37.150
And that's animate images.

00:20:37.150 --> 00:20:40.210
And just one side note, because I have seen people do this.

00:20:40.210 --> 00:20:42.900
Please don't override drawRect on UIImageView.

00:20:42.900 --> 00:20:48.310
It does confuse it, and sometimes you'll get cases where
it will draw low res at one point and then resolution later

00:20:48.310 --> 00:20:53.960
because the drawRect interferes with our
handling of the content scale factor.

00:20:53.960 --> 00:20:58.800
One other view that is effected by
the scaling is the UI scroll view.

00:20:58.800 --> 00:21:03.160
In order to get nice smooth scrolling as we
go, we try to scroll by one pixel at a time.

00:21:03.160 --> 00:21:08.790
So of course on a new display, on a Retina
display, we'll scale by half a point.

00:21:08.790 --> 00:21:14.730
So if you're rounding exactly to one point, be warned
that, you know, it might appear to jump or you know,

00:21:14.730 --> 00:21:21.010
you should try not to avoid rounding
if possible, just let us position it.

00:21:21.010 --> 00:21:23.800
So we've got stuff drawing, it's all nice, high resolution.

00:21:23.800 --> 00:21:28.270
I just wanted to talk a bit about the underpinning
of this Core Graphics and Core Animation.

00:21:28.270 --> 00:21:31.090
Core Graphics deals only in pixels.

00:21:31.090 --> 00:21:35.000
There's nothing about resolutions,
DPI or anything in Core Graphics.

00:21:35.000 --> 00:21:37.260
You only have CGImageGetWidthHeight.

00:21:37.260 --> 00:21:41.920
There's no CGImage get -- set resolution or so on.

00:21:41.920 --> 00:21:43.900
There's no way to do that.

00:21:43.900 --> 00:21:47.950
This means that if you do want a scaled
image you have to store it somewhere else.

00:21:47.950 --> 00:21:50.540
Which is what we do, of course, when we provide UIImages.

00:21:50.540 --> 00:21:53.930
Pretty much got one ivar which is the scale value.

00:21:53.930 --> 00:22:00.390
Some people, especially because if you've been
drawing on a background thread, you want to create --

00:22:00.390 --> 00:22:05.470
you create a CG context using CG bitmap context create.

00:22:05.470 --> 00:22:10.270
Well you know, we really, really should just
use UIGraphicsBeginImageContextWithOptions,

00:22:10.270 --> 00:22:15.440
because it gives you all this extra
functionality, it gives you all this, you know,

00:22:15.440 --> 00:22:17.550
behavior that you don't have to worry about.

00:22:17.550 --> 00:22:18.550
And it does all this set up.

00:22:18.550 --> 00:22:22.020
You know, if you're going to use
CGBitmapContextCreate you have

00:22:22.020 --> 00:22:24.730
to do all these steps in order to draw using UIKit on that.

00:22:24.730 --> 00:22:32.090
You have to -- you probably have to flip it in order to
match the UIKit's direction for the coordinate system,

00:22:32.090 --> 00:22:38.720
you need to set the scale, you'll need to push that context
and then later on when you get the CGImageRef out of it,

00:22:38.720 --> 00:22:41.790
you're going to have to put that
scale somewhere else as well.

00:22:41.790 --> 00:22:47.720
And there's really no performance gain because we do a
few little extra function calls, perhaps, but you know,

00:22:47.720 --> 00:22:51.690
when you're moving 1,000 or 100,000
pixels and blending them and all that,

00:22:51.690 --> 00:22:55.000
that is the real amount of time that you spend.

00:22:55.000 --> 00:22:59.670
So you know, especially now that
UIGraphicsBeginImageContext is thread safe.

00:22:59.670 --> 00:23:06.230
You know, there's really no necessity to
go all the way down to CGBitmapContext.

00:23:06.230 --> 00:23:11.880
Core Animation -- sorry -- ImageIO,
if you do want to read DPI just wanted

00:23:11.880 --> 00:23:17.850
to mention this other framework that's available now,
I believe starting with iPhone OS 3.2 called ImageIO.

00:23:17.850 --> 00:23:21.160
And it's the exact same framework
that's available in the desktop.

00:23:21.160 --> 00:23:23.870
And that let's you read and write
images, get full information,

00:23:23.870 --> 00:23:27.340
do multiple images per file like TIFF and so on.

00:23:27.340 --> 00:23:35.370
If you do want to read it, the DPI of the file, you can call
this function called CGImageSourceCopyPropertiesAtIndex.

00:23:35.370 --> 00:23:38.510
So for any particular image in a file you can get its DPI.

00:23:38.510 --> 00:23:42.620
It's just a property called kCGImagePropertyDPIWidth
and Height.

00:23:42.620 --> 00:23:45.860
And some formats allow different values for that.

00:23:45.860 --> 00:23:49.440
Generally, of course, people assume
72 is, you know, 1x scale.

00:23:49.440 --> 00:23:50.810
But you can do whatever.

00:23:50.810 --> 00:23:53.500
And just as a note for those who load in PNGs

00:23:53.500 --> 00:23:57.290
because they use pixel per centimeter,
sometimes you'll get 71.9 or whatever.

00:23:57.290 --> 00:24:02.610
So you'll have to make sure you want to round that
if it's close to an exact value of something like 72.

00:24:02.610 --> 00:24:08.480
And again, you can use that to set and if
you're doing more general image editing program,

00:24:08.480 --> 00:24:10.110
you'll want to use something like this.

00:24:10.110 --> 00:24:14.470
Because you know, it let's you keep things
like the x of data as well and so on.

00:24:14.470 --> 00:24:19.330
Image -- UIImage is really meant for
interface images and very simple images.

00:24:19.330 --> 00:24:21.380
It's not meant for a complex system.

00:24:21.380 --> 00:24:30.490
With Core Animation, because UIKit sits on top of Core
Animation, and UIView as an associated state layer,

00:24:30.490 --> 00:24:35.370
Core Animation has added its own
property called contentScale.

00:24:35.370 --> 00:24:41.120
Not quite the same as ours, but its equivalent
to content Scale Factor when we set UIView,

00:24:41.120 --> 00:24:45.250
you set the contentScaleFactor,
it gets sent down to the CALayer.

00:24:45.250 --> 00:24:47.920
And as I said just before, it's
automatically set for UIViews

00:24:47.920 --> 00:24:51.100
that implement drawRect and UIViews that have an image set.

00:24:51.100 --> 00:24:56.850
Because when we set the UIImageView we actually
just set the layers contents with that image.

00:24:56.850 --> 00:24:59.230
It's rare you're going to need to set this directly.

00:24:59.230 --> 00:25:03.730
But if you're going to work down at the CA level, the
Core Animation level, you're going to have to set this,

00:25:03.730 --> 00:25:08.250
for example, if you want to provide a
mask layer, which is a way of masking

00:25:08.250 --> 00:25:11.700
out a section of the content of the existing layer.

00:25:11.700 --> 00:25:16.870
And you probably want to match the resolution, that means
you're going to have to provide a high resolution mask,

00:25:16.870 --> 00:25:22.740
artwork for that mask, and set the
contentScaleFactor for that as well.

00:25:22.740 --> 00:25:28.120
And finally, I just want to talk about how
you can provide high resolution, icons,

00:25:28.120 --> 00:25:32.810
and launch images so that your application
looks like it's native for the iPhone 4,

00:25:32.810 --> 00:25:37.660
that people don't see blurry icons on the new hardware.

00:25:37.660 --> 00:25:41.420
Normally, you just create an image
that's an a particular size.

00:25:41.420 --> 00:25:46.450
So for an application icon you
normally create a 57x57 sized image.

00:25:46.450 --> 00:25:51.230
In this case, you'll just create a 2x image, 114x114.

00:25:51.230 --> 00:25:53.320
Now you can call it any name you want.

00:25:53.320 --> 00:25:57.470
Normally, when you currently just
provide a single image you create --

00:25:57.470 --> 00:26:00.390
you select something in the info.plist called Icon File,

00:26:00.390 --> 00:26:03.710
and that's a single string, that's
the name of the application icon.

00:26:03.710 --> 00:26:06.820
So you'll want to actually switch that to Icon Files.

00:26:06.820 --> 00:26:10.210
That will replace the single string
with an array of strings.

00:26:10.210 --> 00:26:12.960
And you can just specify them in whatever name you want.

00:26:12.960 --> 00:26:16.710
But you may as well use the @2x if you
feel, you know, just to be consistent.

00:26:16.710 --> 00:26:20.950
And it's automatically chosen based
on the size of the image.

00:26:20.950 --> 00:26:26.900
So if you've got a high resolution
display we will use 114x114 icon.

00:26:26.900 --> 00:26:30.200
Otherwise, we will use the 57x57.

00:26:30.200 --> 00:26:36.510
I was going to say here, all I did was just -- with
a pop up change the type from icon file to icon files

00:26:36.510 --> 00:26:42.170
and give a list, Appicon.png, and Appicon@2x.png.

00:26:42.170 --> 00:26:47.800
Similarly, for document icons, you
normally create a 22x29 sized icon.

00:26:47.800 --> 00:26:55.040
So you'll want to create twice as big image files, twice
as big icon files with ofcourse finer quality images.

00:26:55.040 --> 00:26:58.660
And just as before you'll need to modify the info.plist.

00:26:58.660 --> 00:27:04.560
Now you can enter this icon using
Xcode in one of the panels.

00:27:04.560 --> 00:27:08.150
I can't remember which one, you can center
that, but it only takes a single file.

00:27:08.150 --> 00:27:11.190
So you're going to have to go into
the info.plist and edit yourself.

00:27:11.190 --> 00:27:16.950
You're going to have to replace CFBundleTypeIconFile, which
is a single string with an array of strings, icon files.

00:27:16.950 --> 00:27:19.970
And again we choose the correct one based on the size.

00:27:19.970 --> 00:27:26.280
So here for example, we've got a dictionary, right
now we're listing one file type, one icon file,

00:27:26.280 --> 00:27:29.730
now we add the twice as high resolution, so we add the @.

00:27:29.730 --> 00:27:33.950
-- you know .icon@2Ix.png.

00:27:33.950 --> 00:27:38.830
And of course there's also settings icons for
those of you who provide settings or for searching.

00:27:38.830 --> 00:27:45.030
In both cases we use 29x29 icons
normally, so you provide 58x58.

00:27:45.030 --> 00:27:49.840
Again, you have to add an entry into the info.plist.

00:27:49.840 --> 00:27:53.220
Now these are chosen the same way that app icons are chosen.

00:27:53.220 --> 00:27:57.840
So you just add them into the icon
files list alone with your app icons.

00:27:57.840 --> 00:28:02.070
And again you're going to add in
@2x versions of the same icon.

00:28:02.070 --> 00:28:06.910
So you'll have settings icon@.png,
and settings icons@2x.png.

00:28:06.910 --> 00:28:15.200
And we'll just automatically choose the larger, higher
resolution one when you're running on new Retina display.

00:28:15.200 --> 00:28:22.120
And finally launch images, of course when your
application launches you want to provide images.

00:28:22.120 --> 00:28:28.270
You'll snapshot it using perhaps the simulator
or new iPhone, when you get a chance to get one.

00:28:28.270 --> 00:28:30.250
And you'll edit it or whatever.

00:28:30.250 --> 00:28:32.390
And you'll put it into the info.plist.

00:28:32.390 --> 00:28:35.500
Now normally you specify using launch images entry.

00:28:35.500 --> 00:28:42.490
And it's a base name, so we're already appending
-- modifying the name when we look for it.

00:28:42.490 --> 00:28:47.890
So for example, if you launch in landscape,
we'll look for LaunchImage-Landscape.png.

00:28:47.890 --> 00:28:52.550
You -- all you need to do now is
just like before, add and @2x.

00:28:52.550 --> 00:28:56.570
Now this really does need to the @2x because
that's how we can find the high resolution images.

00:28:56.570 --> 00:29:02.840
So if for example, you might have
Launch@2x.png or Launch-Landscape@2x.png,

00:29:02.840 --> 00:29:08.240
and we'll choose the right one based on
the orientation and the type of hardware,

00:29:08.240 --> 00:29:11.060
the Retina display or the older displays.

00:29:11.060 --> 00:29:15.710
So I just wanted to summarize in a couple of points.

00:29:15.710 --> 00:29:18.370
First sort of the bad news and the good news.

00:29:18.370 --> 00:29:23.260
Of the don'ts for high resolution are
don't assume points are equal to pixels.

00:29:23.260 --> 00:29:27.690
Especially when you're working across
directly with pixels using Core Graphics.

00:29:27.690 --> 00:29:32.250
You got to just make that break and
say we're now working in points only.

00:29:32.250 --> 00:29:37.120
This means that you can't assume as a set
explicitly that UIImage.size is the pixel size.

00:29:37.120 --> 00:29:41.250
I have seen cases, for example, where you
know, someone's using UIGraphicsBegin --

00:29:41.250 --> 00:29:47.460
CGBitmapContextCreate, and they pass in the
image.size, before they start calling in CG calls.

00:29:47.460 --> 00:29:53.370
And of course now your image is going to be clipped.

00:29:53.370 --> 00:29:59.580
You -- you don't want to assume that when you get the
CGContext when you're drawing it is exactly a 1.0 scale.

00:29:59.580 --> 00:30:04.210
You know, if we created twice as many --
twice as wide a pixel buffer underneath.

00:30:04.210 --> 00:30:08.700
So if you're going to start reading
the pixels from a CGBitmapContext,

00:30:08.700 --> 00:30:13.440
you're going to start missing pixels
if you've assumed the 1.0 scale.

00:30:13.440 --> 00:30:21.980
Please don't cram in a lot of information using
a smaller font or a smaller images or whatever.

00:30:21.980 --> 00:30:27.460
Yes, it's amazing that, a 5 point font is
actually quite legible on the new phone.

00:30:27.460 --> 00:30:33.070
But for those of us with older eyes that's
going to be very difficult to read, regardless.

00:30:33.070 --> 00:30:39.300
So just use it as a refinement, not as a
way of squeezing in additional information.

00:30:39.300 --> 00:30:44.620
And similarly, if you're providing high resolution
artwork, don't embellish the 2x artwork, you know,

00:30:44.620 --> 00:30:47.140
don't suddenly turn it purple when it's in high resolution.

00:30:47.140 --> 00:30:51.260
Because people might be using your app on older
hardware at the same time or on their iPad

00:30:51.260 --> 00:30:55.610
and will be using the smaller artwork
there, they want consistency.

00:30:55.610 --> 00:30:58.710
So what do you need in the end to support high resolution.

00:30:58.710 --> 00:31:04.590
Well first thing you do -- sorry -- is nothing.

00:31:04.590 --> 00:31:09.590
We automatically give you high resolution texts, high
resolution bezier path, all the system UI elements,

00:31:09.590 --> 00:31:13.210
the controls, nav bar, toolbars, standard icons for that.

00:31:13.210 --> 00:31:15.310
All redone in high resolution.

00:31:15.310 --> 00:31:19.850
So your application looks pretty good
already, especially if you draw a lot of text.

00:31:19.850 --> 00:31:24.100
If you're going to do more high
resolution work the first thing you want

00:31:24.100 --> 00:31:26.310
to do is actually no programming change at all.

00:31:26.310 --> 00:31:29.080
Just create @2x images.

00:31:29.080 --> 00:31:34.370
So go through all the images in your
project and see how you can scale them up.

00:31:34.370 --> 00:31:39.430
You know, if you've got lots and lots of images, just look
at the ones that really will benefit from scaling up first,

00:31:39.430 --> 00:31:43.740
the ones with angled shapes or lots of curves and so on.

00:31:43.740 --> 00:31:49.330
But you know, ideally you can do all of them, and everything
will look really, really sharp on the new display.

00:31:49.330 --> 00:31:52.260
Then if you're going to start generating
your own artwork using offscreen,

00:31:52.260 --> 00:31:55.600
please switch over to using
UIGraphicsBeginImageContextWithOptions,

00:31:55.600 --> 00:32:00.150
pass in a zero scale so you'll always
get compatible output UI images.

00:32:00.150 --> 00:32:03.880
An now everything will look really sharp,
even the stuff that you're generating.

00:32:03.880 --> 00:32:10.820
Then finally, if you really want, you can override --
you can add to your drawRect call, get the pixel size,

00:32:10.820 --> 00:32:15.060
the one divided by view contentScale
and start adjusting things there.

00:32:15.060 --> 00:32:22.840
Even just drawing, so that will get you a really, really
nice appearance throughout your whole application.

00:32:22.840 --> 00:32:26.880
So that's all you need for the UIKit side of things.

00:32:26.880 --> 00:32:33.510
Now I'll turn it over to Richard who will talk a
bit about things you need to work on with OpenGL.

00:32:33.510 --> 00:32:38.010
[ Applause ]

00:32:38.010 --> 00:32:39.110
[ Multiple voices speaking ]

00:32:39.110 --> 00:32:40.100
>> Richard Schreyer: Thank you.

00:32:40.100 --> 00:32:45.390
So obviously we're going to talk
about OpenGL on the Retina display.

00:32:45.390 --> 00:32:49.240
Some of you in here have probably
done some level of OpenGL development.

00:32:49.240 --> 00:32:51.430
Many of you probably haven't.

00:32:51.430 --> 00:32:54.620
Hopefully, I'm going to try to make this
approachable to pretty much everybody.

00:32:54.620 --> 00:32:59.410
So if you do find yourself doing some level of OpenGL
development in the future you'll have that little thing

00:32:59.410 --> 00:33:03.790
in the back of your head that says there was
something I should have been aware of here.

00:33:03.790 --> 00:33:08.070
So let's dive right in.

00:33:08.070 --> 00:33:10.240
You heard Andrew discuss Core Graphics.

00:33:10.240 --> 00:33:12.630
It's very much a pixel-based API.

00:33:12.630 --> 00:33:15.770
And so if you work at the Core Graphics
level you're biting off a little bit

00:33:15.770 --> 00:33:17.920
of manual effort to make that work correctly.

00:33:17.920 --> 00:33:20.230
You have to carry a scale factor along on your own.

00:33:20.230 --> 00:33:25.360
You have to really think about the size and
pixels as opposed to device independent points.

00:33:25.360 --> 00:33:28.350
OpenGL is pretty much exactly the same in that regard.

00:33:28.350 --> 00:33:31.630
It is very much a pixel-based API through and through.

00:33:31.630 --> 00:33:34.960
So it does pretty much nothing for you on this front.

00:33:34.960 --> 00:33:38.860
But fortunately, there's still
not that much that has to change.

00:33:38.860 --> 00:33:44.920
And so just to remind you, I've put up on screen,
to think -- the bounds times contentScaleFactor.

00:33:44.920 --> 00:33:48.600
Because this is -- this is the algorithm that's
used pretty much universally to determine --

00:33:48.600 --> 00:33:52.810
to determine how many pixels are in the
image that backs your various views.

00:33:52.810 --> 00:34:02.770
Whether you're talking about image views, content generated
to the drawRect, or content generated with OpenGL.

00:34:02.770 --> 00:34:07.370
So I mean, what are the steps, how do you
adopt high resolution displays on OpenGL.

00:34:07.370 --> 00:34:10.280
How do you make the most of the Retina display.

00:34:10.280 --> 00:34:14.690
Step one is to allocate a higher resolution color buffer.

00:34:14.690 --> 00:34:16.660
It's -- we want to fill more pixels.

00:34:16.660 --> 00:34:18.540
That's the advantage.

00:34:18.540 --> 00:34:25.160
Step two is that we found a fair number of applications
use various hard-coded sizes and dimensions.

00:34:25.160 --> 00:34:28.820
That becomes a compatibility concern,
and so we'll have to fix that.

00:34:28.820 --> 00:34:32.130
I'll point out a couple of most common trouble areas.

00:34:32.130 --> 00:34:37.560
And then finally, this is, you know, just
as we want to load higher resolution images

00:34:37.560 --> 00:34:42.660
and icon files OpenGL is also very heavy
on artwork and imagery that you provide.

00:34:42.660 --> 00:34:46.170
And so you'll also want to look
at higher resolution content here.

00:34:46.170 --> 00:34:49.910
So step one.

00:34:49.910 --> 00:34:51.630
You already actually know entirely how to do this,

00:34:51.630 --> 00:34:56.910
at the control via the same contentScaleFactor
property that controls everything else in UIKit.

00:34:56.910 --> 00:35:02.790
As Andrew said, for pretty much all of the
built in UIKit widgets, this is already set --

00:35:02.790 --> 00:35:05.160
this is pretty much already set exactly the way you want.

00:35:05.160 --> 00:35:07.260
It defaults to the scale of the screen.

00:35:07.260 --> 00:35:13.710
So in iPhone 3GS you're going -- your text view
is going to have a scale of 1, and on an iPhone 4,

00:35:13.710 --> 00:35:18.590
your text view is going to have a scale of 2,
and you'll get the right view on any platform.

00:35:18.590 --> 00:35:26.110
With OpenGL, the contentScaleFactor defaults to
1 everywhere, mostly for compatibility reasons.

00:35:26.110 --> 00:35:30.520
So the first step to adopting high resolution
is to set that scale factor yourself.

00:35:30.520 --> 00:35:34.090
This is perhaps one of the only places
where you will want to set a scale --

00:35:34.090 --> 00:35:37.800
set a contentScaleFactor in an application.

00:35:37.800 --> 00:35:41.210
In this -- in most cases, you know, the
goal is to match the scale of the screen.

00:35:41.210 --> 00:35:46.240
And so we'll pull that out of UIScreen
and copy that straight on through.

00:35:46.240 --> 00:35:51.550
The second line here is when you actually allocate
-- actually reallocate the OpenGL Renderbuffer.

00:35:51.550 --> 00:35:55.520
That's sort of our weird word for the
image you're going to be rendering into.

00:35:55.520 --> 00:36:02.170
So at the time you call RenderBufferStorage allocated,
Core Animation is going to snap shot the value of bounds,

00:36:02.170 --> 00:36:04.160
it's going to snap shot the value of scale.

00:36:04.160 --> 00:36:08.820
And that will become -- multiply them
together, and that will become the image size

00:36:08.820 --> 00:36:12.760
in pixels that you're going be making use of.

00:36:12.760 --> 00:36:19.310
Given that OpenGL is a pixel-based API, it's actually really
handy to know how many pixels you're actually drawing with.

00:36:19.310 --> 00:36:22.920
So you can do the bounds times scale derivation yourself.

00:36:22.920 --> 00:36:28.730
But usually it's even easier and more foolproof
to go ahead and ask what got allocated for me.

00:36:28.730 --> 00:36:32.640
And as I said, if you're just copying
to the scale of the screen,

00:36:32.640 --> 00:36:35.480
this will be different depending
on which device you're running on.

00:36:35.480 --> 00:36:40.560
So in this case, we'll take these pixel width and pixel
height, we'll stash them aside, they'll come in useful.

00:36:40.560 --> 00:36:45.030
That brings us on to step two.

00:36:45.030 --> 00:36:47.220
Fixing any hard coded sizes.

00:36:47.220 --> 00:36:51.630
This is what really sets OpenGL
apart from say UIKit drawing.

00:36:51.630 --> 00:36:57.550
Where in UIKit everything is in terms of points,
and so all of your layout functions unchanged.

00:36:57.550 --> 00:37:00.420
And this is a great out of box experience.

00:37:00.420 --> 00:37:03.240
With OpenGL, on the other hand,
there are quite a few functions

00:37:03.240 --> 00:37:05.700
that explicitly take parameters in terms of pixels.

00:37:05.700 --> 00:37:07.100
And even integer pixels.

00:37:07.100 --> 00:37:11.970
So we couldn't even really do anything
really -- really crazy behind your back.

00:37:11.970 --> 00:37:17.270
And so I put a bunch of -- the example -- probably some of
the most commonly used functions that take pixel arguments

00:37:17.270 --> 00:37:21.540
up on the screen, and these are really where you
have to make sure you're not hard coading anything.

00:37:21.540 --> 00:37:26.890
And the good news is if your application -- if you've
already made a universal application for both iPhone

00:37:26.890 --> 00:37:30.330
and iPad, you've probably already
found and fixed all of these cases,

00:37:30.330 --> 00:37:32.710
given that of the iPad also has a different sized screen.

00:37:32.710 --> 00:37:37.760
But I want to point out just a couple
of the most common trouble spots.

00:37:37.760 --> 00:37:40.870
So OpenGL has the concept of a depth buffer.

00:37:40.870 --> 00:37:46.550
It's another image, but rather than storing a
color per pixel it stores a distance per pixel.

00:37:46.550 --> 00:37:53.470
This is how we handle figuring out what's behind what, since
we're dealing with 3D scenes handling occlusion properly.

00:37:53.470 --> 00:37:59.110
Given that this is a per pixel value, it has to -- you
know, we have to allocate an equivalently matching amount

00:37:59.110 --> 00:38:05.580
of storage as compared to color buffers as
well, if you have hard coded 320x480 into here,

00:38:05.580 --> 00:38:09.750
then that's not going to match the dimensions of the
actual color buffer that Core Animation has allocated

00:38:09.750 --> 00:38:12.030
on your behalf, and things aren't going to work.

00:38:12.030 --> 00:38:15.800
Your drawing will actually be no opted
and errors start flying everywhere.

00:38:15.800 --> 00:38:19.390
So in this case, easiest thing to
do was grab our saved pixel

00:38:19.390 --> 00:38:22.780
within pixel height and pass them right on through.

00:38:22.780 --> 00:38:28.050
If you've been copying our sample code or using our OpenGL
template this is actually probably already working just fine

00:38:28.050 --> 00:38:31.300
out of the box.

00:38:31.300 --> 00:38:34.810
The second case that impacts every
application is a viewport.

00:38:34.810 --> 00:38:40.170
A viewport is a function that sets what sub region
of the view of your drawing is due at any given time.

00:38:40.170 --> 00:38:45.900
It's also -- most applications -- every application
is required to set a viewport at least once.

00:38:45.900 --> 00:38:50.200
And so if you've got exiting code
you'll find it in there somewhere.

00:38:50.200 --> 00:38:54.350
Most applications just use a single full screen
viewport, they want to fill the entire view.

00:38:54.350 --> 00:38:58.170
So once again, we'll just take our saved
values and pass them right on through.

00:38:58.170 --> 00:39:01.620
So it will be a common pattern.

00:39:01.620 --> 00:39:05.590
So I'll stop here in hard coded sizes,
because this is really going to have

00:39:05.590 --> 00:39:09.070
to be something that's a little bit
more of a self directed job to fix,

00:39:09.070 --> 00:39:11.180
depending on exactly what's going on in your application.

00:39:11.180 --> 00:39:14.690
So that takes us to step three, where it gets really fun.

00:39:14.690 --> 00:39:20.240
Now that you have an application that pretty much
works at native resolution on the Retina display,

00:39:20.240 --> 00:39:24.050
now is when you really want to make the
most of it and load high resolution content.

00:39:24.050 --> 00:39:30.640
Just as you want to load better UIViews, better icon
files and so forth, OpenGL is also really heavy on images.

00:39:30.640 --> 00:39:34.530
And you have a great opportunity to
show the user more detailed information.

00:39:34.530 --> 00:39:40.600
Again, if your application is universal you may have
already drawn a bunch of high resolution content.

00:39:40.600 --> 00:39:46.790
And for 3D graphics, that content may already be perfectly
applicable, so you might have an existing library of content

00:39:46.790 --> 00:39:51.390
that you can just leverage right out of the gate.

00:39:51.390 --> 00:39:56.210
So for example, I mean, OpenGL often
times uses a data structure like this.

00:39:56.210 --> 00:39:57.930
We call it a mipmap.

00:39:57.930 --> 00:40:02.570
It's pretty much an image followed by another image
that's the same content, but half the width and height.

00:40:02.570 --> 00:40:06.680
And recursively again and again and
again until you reach 1x1 pixel.

00:40:06.680 --> 00:40:10.680
GPUs love this kind of data structure for various reasons.

00:40:10.680 --> 00:40:18.400
Usually the easiest way to handle this is to
stick another base level on, right on the bottom.

00:40:18.400 --> 00:40:24.630
In this case, it's -- it ends up being very
noninvasive, and you also have the option of looking

00:40:24.630 --> 00:40:29.080
at which device you're running on, do I have a screen
where the user is actually going to benefit from this.

00:40:29.080 --> 00:40:30.930
And if so, leave it off.

00:40:30.930 --> 00:40:34.920
Because otherwise it's going to be --
it's just going to be a waste of memory.

00:40:34.920 --> 00:40:41.010
But if you just stick this new base level on, OpenGL
will automatically you know, will automatically be aware

00:40:41.010 --> 00:40:45.350
of the size of your screen, the size of the
textures, and will know when to use this more detail,

00:40:45.350 --> 00:40:47.750
this extra detail, whenever is appropriate.

00:40:47.750 --> 00:40:51.300
Just one word of warning.

00:40:51.300 --> 00:40:54.860
This is actually a slide you've
already seen, but I want to reiterate.

00:40:54.860 --> 00:40:58.020
There's a lot of code out there
that uses UIImage to load textures

00:40:58.020 --> 00:41:01.740
and UIImage .size returns its dimensions and points.

00:41:01.740 --> 00:41:04.900
Well you can't take those values and
just pipe them into tech image 2D.

00:41:04.900 --> 00:41:08.690
You'll either have to make sure to scale
it yourself, image size, image scale.

00:41:08.690 --> 00:41:13.640
Or drop down a level and just straight up ask for
the pixels with CGImageGetWidth and GetHeight.

00:41:13.640 --> 00:41:18.870
This is probably going to be something that's
screws up a fair number of applications.

00:41:20.500 --> 00:41:23.620
And then finally, there's performance.

00:41:23.620 --> 00:41:28.420
This is probably a much bigger deal for 3D
content than it is for UIKit level content.

00:41:28.420 --> 00:41:33.080
I mean, you really have to think about --
we've got four times as many pixels to fill.

00:41:33.080 --> 00:41:38.570
And that's usually the first question in determining
performance is how many pixels are you filling.

00:41:40.540 --> 00:41:45.420
So we found that there are some applications
that you know, you flip the switch

00:41:45.420 --> 00:41:49.080
and performance isn't really what
you want it to be any more.

00:41:49.080 --> 00:41:52.870
So we've actually -- I'm actually not
going to talk about performance tuning

00:41:52.870 --> 00:41:55.420
in much detail, because that's a gigantic topic.

00:41:55.420 --> 00:41:58.540
We actually had yesterday an entire
session on just this topic.

00:41:58.540 --> 00:42:01.850
So if this is of interest to you, you'll
want to go back and catch the video.

00:42:01.850 --> 00:42:05.500
We talk through both the methodology, where
start when doing performance analysis,

00:42:05.500 --> 00:42:07.360
as well as describing some brand new developer tools

00:42:07.360 --> 00:42:10.950
that can really help you understand
the behavior of an application.

00:42:10.950 --> 00:42:18.190
I mean, so you're going to want to look at, you know,
your control over how expensive it is to draw each pixel.

00:42:18.190 --> 00:42:23.650
In OpenGL you can run an arbitrary program for every pixel
to control exactly what color comes out the back-end.

00:42:23.650 --> 00:42:28.240
You have various controls over operations like
alpha test, which can be particularly expensive.

00:42:28.240 --> 00:42:29.250
Again, mipmaps.

00:42:29.250 --> 00:42:31.260
You know, bitmaps -- I said GPUs love mipmaps.

00:42:31.260 --> 00:42:33.460
It can make a huge difference in
the efficiency of the caches,

00:42:33.460 --> 00:42:37.280
it can make a tremendous difference
in overall application performance.

00:42:37.280 --> 00:42:44.230
But really, if you've followed our advice in tuned and
find yourself really not reaching your performance targets,

00:42:44.230 --> 00:42:50.070
30 frames a second, maybe each 60, then again the line
here to focus on is how many pixels are you drawing.

00:42:50.070 --> 00:42:52.830
You know, X and Y have gotten a lot bigger.

00:42:52.830 --> 00:42:57.580
And if you think about most applications, you're putting,
you know, you're stacking a bunch of blended objects.

00:42:57.580 --> 00:42:58.480
And those all add up too.

00:42:58.480 --> 00:43:00.240
So it's really X times Y times Z.

00:43:00.240 --> 00:43:02.720
And that number can get really big.

00:43:02.720 --> 00:43:07.140
But it's really X times Y that we have control over.

00:43:07.140 --> 00:43:14.690
And so if you find yourself with, you know, not reaching
your performance goals, usually here our suggestion is is

00:43:14.690 --> 00:43:18.100
that you actually don't go up to
match the entire size of the display.

00:43:18.100 --> 00:43:23.970
In this case, you can draw your game at 720 by 480 instead.

00:43:23.970 --> 00:43:29.720
This is still a significant step up in quality
over what you were drawing on iPhone 3GS.

00:43:29.720 --> 00:43:33.730
And yet on the other hand, you're
only filling about half as many pixels

00:43:33.730 --> 00:43:37.610
as you would be had you gone all
the way up to fill the display.

00:43:37.610 --> 00:43:41.620
Certainly wouldn't object to filling the whole
display, but that's just not always feasible,

00:43:41.620 --> 00:43:45.590
especially with really, really high end 3D content.

00:43:45.590 --> 00:43:48.140
So I mean, how do you actually make this work.

00:43:48.140 --> 00:43:54.260
You could just sort of allocate a 720x480 image
and stick in the middle and have some black bars.

00:43:54.260 --> 00:43:56.300
But not really.

00:43:56.300 --> 00:43:57.520
That's no good.

00:43:57.520 --> 00:43:59.110
What you really want to do is you want to scale it.

00:43:59.110 --> 00:44:03.930
You want to take your smaller image and you want to really,
really good job scaling it up to fit the whole display.

00:44:03.930 --> 00:44:07.420
So the user still gets a really immersive experience.

00:44:07.420 --> 00:44:10.000
And fortunately, you don't have to do that.

00:44:10.000 --> 00:44:13.220
Core Animation can handle this job
for you, and it can do a really,

00:44:13.220 --> 00:44:17.720
really fast job of it, and a really high quality job of it.

00:44:21.210 --> 00:44:25.910
So again, I mean, how too you actually -- you know,
if you find yourself wanting to reduce the pixel count

00:44:25.910 --> 00:44:30.330
in your applications for performance
reasons, how do you actually do that?

00:44:30.330 --> 00:44:34.780
Let's turn right back to our good new
friend the contentScaleFactor property.

00:44:34.780 --> 00:44:41.120
And just take note that this is how games and
other OpenGL content actually work out of the box.

00:44:41.120 --> 00:44:46.070
Just a reminder, for compatibility reasons, we
default the scale factor to 1 for OpenGL content.

00:44:46.070 --> 00:44:49.280
And so this scaling mode is already how
every single application has worked,

00:44:49.280 --> 00:44:52.710
every single GL application is working out of the box.

00:44:52.710 --> 00:44:56.710
So right off the bat, our goal was to provide
the same great performance you've always had

00:44:56.710 --> 00:45:00.520
and the same great visual quality you've always had.

00:45:00.520 --> 00:45:02.580
Not a bad place to start from.

00:45:02.580 --> 00:45:06.110
But if you think about it, as a
4x jump in the number of pixels.

00:45:06.110 --> 00:45:08.150
That's a pretty huge gulf.

00:45:08.150 --> 00:45:13.770
And there's going to be a class of applications where
you have some performance head room to really step it up.

00:45:13.770 --> 00:45:16.840
But maybe you can't absorb a 4x jump.

00:45:16.840 --> 00:45:22.810
And so there's a couple middle grounds I want to talk about,
where you can dial a knob, performance versus quality.

00:45:22.810 --> 00:45:29.190
You can stick with -- one of the really interesting
options is sticking with a contentScaleFactor of 1

00:45:29.190 --> 00:45:33.060
and adopting anti-aliasing within OpenGL itself.

00:45:33.060 --> 00:45:35.990
This is a new feature we've added in iOS 4.

00:45:35.990 --> 00:45:41.710
And it can really make a really big visual
-- visual improvement in visual quality.

00:45:41.710 --> 00:45:45.500
Our anti-aliasing features will smooth out the
edges of a polygon, it will smooth out lines.

00:45:45.500 --> 00:45:49.800
But it doesn't actually effect the
images applied to polygons so much.

00:45:49.800 --> 00:45:53.110
But it's actually a pretty good deal overall.

00:45:53.110 --> 00:45:57.850
What's really advantageous about this, though,
is that the performance impact is much,

00:45:57.850 --> 00:46:01.960
much less than if you had gone up and filled a 4x display.

00:46:01.960 --> 00:46:07.890
And the performance impact is much
less severe that if you had done so.

00:46:07.890 --> 00:46:11.000
Even better, this is actually back portable to 3GS.

00:46:11.000 --> 00:46:18.590
And finally, you also have more choices
for content scale factor than just 1 or 2.

00:46:18.590 --> 00:46:25.090
In fact, this is probably the only place in the entire API
where you do want to consider a noninteger scale factor.

00:46:25.090 --> 00:46:29.290
Think back to my original example
where I said let's render 720x480.

00:46:29.290 --> 00:46:32.360
Cut the pixel count in half, double performance.

00:46:32.360 --> 00:46:37.090
You know, in this case, getting that doubling of
performance, to do that, I had to write one line

00:46:37.090 --> 00:46:41.240
of code, I had to set contentScaleFactor to 1.5.

00:46:41.240 --> 00:46:46.580
This can be be a really big deal for a complex application.

00:46:46.580 --> 00:46:50.450
That's pretty much about the gist of it.

00:46:50.450 --> 00:46:53.210
I mean, you really do have to be
aware of points versus pixels,

00:46:53.210 --> 00:46:56.570
given that you're using an explicitly pixel-based API.

00:46:56.570 --> 00:46:59.120
You're going to get touch input in terms
of points and you might have to translate

00:46:59.120 --> 00:47:02.680
that yourself based on the views contenScaleFactor.

00:47:02.680 --> 00:47:09.770
Adoption, there's fix ups here and there that you may
need, but the core of it is to set contentScaleFactor.

00:47:09.770 --> 00:47:15.000
Get out, get -- if you care to, to get
out of the compatibility default of 1.0.

00:47:15.000 --> 00:47:17.220
Check your render buffer dimensions, make sure they match.

00:47:17.220 --> 00:47:21.760
If you turn this on and the first thing you see
is black, this is probably what you got wrong.

00:47:21.760 --> 00:47:23.630
And secondly, similar thing with viewport.

00:47:23.630 --> 00:47:25.990
If the first thing you see is the OpenGL content crammed

00:47:25.990 --> 00:47:31.140
up in the upper left corner, that's
what you probably missed there.

00:47:31.140 --> 00:47:35.990
So that brings us to the end of
discussion on the Retina display.

00:47:35.990 --> 00:47:39.110
If you have any questions you can
contact Bill Dudney directly.

00:47:39.110 --> 00:47:42.980
We have a whole new chapter on this in
the iPhone Application Programming Guide

00:47:42.980 --> 00:47:47.830
and there's also actually already a whole bunch of questions
being asked about this in the Apple Developer Forums.

00:47:47.830 --> 00:47:53.320
There's a What's New in Cocoa Touch
session happening tomorrow,

00:47:53.320 --> 00:47:55.560
which goes into the rest of what's changing in UIKit.

00:47:55.560 --> 00:48:00.310
And there's also the aforementioned tuning
-- OpenGL ES Tuning and Optimization session.

00:48:00.310 --> 00:48:06.400
Which is obviously your first choice for OpenGL tuning, as
opposed to simply dialing back on the screen resolution.

00:48:07.630 --> 00:48:12.710
So with that, I hope this was really useful to you,
and we look forward to seeing a lot of you at the labs.

00:48:12.710 --> 00:48:12.970
Thank you.

