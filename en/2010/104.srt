1
00:00:06,620 --> 00:00:09,160
>> Josh Shaffer: Alright, good morning guys.

2
00:00:09,160 --> 00:00:12,720
My name's Josh and I'll be joined
in just a little bit by Eliza,

3
00:00:12,720 --> 00:00:17,320
who once again has some more incredible
demos to share with you guys this year.

4
00:00:17,320 --> 00:00:22,910
If you came to see the mastering iPhone-- the
Mastering iPhone Scroll Views last year at WWDC,

5
00:00:22,910 --> 00:00:29,080
then you know we started out that by talk by getting into
a lot of the basics of how to configure a scroll view

6
00:00:29,080 --> 00:00:35,480
for just a bit of scrolling and zooming, the really
simple parts that, you know, that everyone has to do

7
00:00:35,480 --> 00:00:37,490
when they start out to configure a scroll view.

8
00:00:37,490 --> 00:00:41,700
So this year we're actually going to skip
over all of that introductory basic stuff.

9
00:00:41,700 --> 00:00:46,150
So if you weren't here last year or you're kind
of new to this, don't worry, it's no problem.

10
00:00:46,150 --> 00:00:47,960
There's plenty of sample code available,

11
00:00:47,960 --> 00:00:51,340
and the documentation is excellent
and it's actually really easy anyway.

12
00:00:51,340 --> 00:00:53,730
There're only a couple of things to do to configure it.

13
00:00:53,730 --> 00:00:59,500
But what we really want to do this year is jump right in to
some of the more advanced, exciting things that you can do

14
00:00:59,500 --> 00:01:03,600
with UIScrollView, when you really start
to use them in your applications the way

15
00:01:03,600 --> 00:01:06,990
that Apple uses the UIScrollView in our applications.

16
00:01:06,990 --> 00:01:15,120
So we're going to frame the rest of the talk around building
a photo browser that behaves exactly like the photo browser

17
00:01:15,120 --> 00:01:18,560
that you'll find in the Photos application in iPhone OS.

18
00:01:18,560 --> 00:01:22,670
Now, I see some of you kind of looking at me
thinking, "I don't have any photo browsers in my app.

19
00:01:22,670 --> 00:01:24,800
So maybe I just kind of get out here."

20
00:01:24,800 --> 00:01:27,010
But don't worry about it, it's not a problem.

21
00:01:27,010 --> 00:01:32,530
All the techniques we're going to talk about are perfectly
applicable to plenty of other types of applications.

22
00:01:32,530 --> 00:01:39,350
In fact, the things we're going to discuss
are used in Safari, in Maps, in Stocks,

23
00:01:39,350 --> 00:01:44,280
in Weather and all of these different
applications on iPhone.

24
00:01:44,280 --> 00:01:49,730
So we'll take a look at how we can use them, and we'll build
a photo browser and then you guys can go back and figure

25
00:01:49,730 --> 00:01:52,360
out how you can use them in your own applications.

26
00:01:52,360 --> 00:01:57,180
So let's get started by talking about
how we'll configure our UIScrollViews

27
00:01:57,180 --> 00:01:59,870
in order to behave like the photos application.

28
00:01:59,870 --> 00:02:02,120
So what is it that we want to get?

29
00:02:02,120 --> 00:02:04,040
Well hopefully, you've all already seen this.

30
00:02:04,040 --> 00:02:09,700
The basic idea is going to be, that you can
scroll around on photos and zoom in on them

31
00:02:09,700 --> 00:02:13,620
and view just these large great full screen photos.

32
00:02:13,620 --> 00:02:18,260
So of course, we've got the full screen
photo is the most important part of that.

33
00:02:18,260 --> 00:02:24,130
And you know that your users expect to be able to
swipe left and right to go between multiple photos.

34
00:02:24,130 --> 00:02:27,290
So let's add one to the left and one to the right there.

35
00:02:27,290 --> 00:02:34,010
Then they expect to be able to just swipe and have it move
over and swipe back to navigate around between their photos.

36
00:02:34,010 --> 00:02:38,910
When they're at a photo, they want to be
able to zoom in on that photo by pinching

37
00:02:38,910 --> 00:02:41,400
or by double tapping or two finger tapping.

38
00:02:41,400 --> 00:02:43,910
Now, you'll notice something interesting happened here.

39
00:02:43,910 --> 00:02:49,730
When I zoomed in on that photo, the two photos to the
left and to the right didn't actually move to make room

40
00:02:49,730 --> 00:02:53,610
for the thing that I just zoomed in,
they're off screen and not visible anyway.

41
00:02:53,610 --> 00:02:55,370
So it doesn't really matter where they are.

42
00:02:55,370 --> 00:02:57,370
Now this isn't just for the slide.

43
00:02:57,370 --> 00:03:03,190
This is kind of a setup to give you an idea of what to
expect for how we're going to end up implementing this.

44
00:03:03,190 --> 00:03:10,660
A lot of people start out by thinking that they really
need to move this entire set of photos as one large plane

45
00:03:10,660 --> 00:03:14,720
and it's not entirely obvious how
you might do that with UIScrollView.

46
00:03:14,720 --> 00:03:20,420
So a lot of people end up going back to UIView and
starting from scratch and just subclassing UIView

47
00:03:20,420 --> 00:03:24,420
and implementing raw touch handling
and doing everything from the ground

48
00:03:24,420 --> 00:03:27,630
up implementing an entire scrolling subclass.

49
00:03:27,630 --> 00:03:32,780
Even if you didn't do that, a lot of people we find
end up going out and looking for third party frameworks

50
00:03:32,780 --> 00:03:35,900
that provide this kind of functionality,
because it seems really hard

51
00:03:35,900 --> 00:03:38,600
and it's not something you'd want to take on, on your own.

52
00:03:38,600 --> 00:03:42,290
Well the important thing that we really want to
get across while we're talking about this today,

53
00:03:42,290 --> 00:03:43,780
is that you really don't have to do this.

54
00:03:43,780 --> 00:03:47,230
You don't have to start from scratch you
don't have to go to third party frameworks.

55
00:03:47,230 --> 00:03:50,820
You can use UIScrollView to get all this
behaviors that we're going to talk about here.

56
00:03:50,820 --> 00:03:56,640
Alright, so your users zoomed in on the photo, once they're
viewing it large, they can then swipe around on that photo

57
00:03:56,640 --> 00:03:59,470
to scroll around and view different parts of it, right?

58
00:03:59,470 --> 00:04:04,310
And when they get to the edge, they'll continue to
pull the photo and it will swipe back to next one

59
00:04:04,310 --> 00:04:09,010
and shrink the one they zoomed in
back down to its original size.

60
00:04:09,010 --> 00:04:14,480
OK, so that's the type of behavior
we're trying to end up with.

61
00:04:14,480 --> 00:04:17,950
What kind of view hierarchy to we
have to build in order to get to that?

62
00:04:17,950 --> 00:04:23,630
Well, we're actually going to take the two parts that
we're trying to accomplish and separate them out.

63
00:04:23,630 --> 00:04:28,790
We're going to look at paging independent from
zooming and consider them to be two different things.

64
00:04:28,790 --> 00:04:31,390
So we'll start out with implementing the paging.

65
00:04:31,390 --> 00:04:35,770
And to do that we'll use a paging UIScrollView
and if you use UIScrollView you know

66
00:04:35,770 --> 00:04:40,290
that that's just a normal UIScrollView
where you set the paging enabled bit to yes.

67
00:04:40,290 --> 00:04:44,000
And we'll create one that covers the entire iPhone screen.

68
00:04:44,000 --> 00:04:50,260
So in this case it's going to be 320 by
480 points, so it fills the entire display.

69
00:04:50,260 --> 00:04:54,460
Now we'll configure this for the sample we're
looking at here to display three photos.

70
00:04:54,460 --> 00:04:56,770
So if you've used paging scroll views before,

71
00:04:56,770 --> 00:05:01,700
you know that the page width is determined
simply by the bounds width of the scroll view.

72
00:05:01,700 --> 00:05:07,950
So in our case since our bounds width is 320 points,
we're going to have page width of 320 points.

73
00:05:07,950 --> 00:05:15,620
So we'll multiply by that 3 and set our content size
to 960 by 480, so we can swipe between three pages.

74
00:05:15,620 --> 00:05:19,280
Now that's all we actually have to do, to get
the paging behavior that we're trying to add.

75
00:05:19,280 --> 00:05:21,780
So on to zooming.

76
00:05:21,780 --> 00:05:29,520
For zooming, we're going to add separate UIScrollViews that
handle just that zooming and panning on the zoomed images.

77
00:05:29,520 --> 00:05:32,300
So we're going to add a new UIScrollView subview

78
00:05:32,300 --> 00:05:36,760
of our outer paging Scroll View
that again covers the entire screen.

79
00:05:36,760 --> 00:05:42,850
So it's going to be 320 by 480, and it will be a subview
of that paging ScrollView filling the entire screen.

80
00:05:42,850 --> 00:05:47,170
And since we've got two other photos that we're trying
to display as well, we'll add two more to the left--

81
00:05:47,170 --> 00:05:52,290
to the right rather, so that you can see a zooming--

82
00:05:52,290 --> 00:05:56,240
allowing the user to zoom in on
each one of these different photos.

83
00:05:56,240 --> 00:05:59,080
And finally, we need to actually display the photos.

84
00:05:59,080 --> 00:06:04,950
And if you've used UIScrollView to add zooming support
before, you'll be familiar with the delegate method view

85
00:06:04,950 --> 00:06:10,220
for zooming in Scroll View which is how you implement
zooming in a Scroll View, you basically return some subview

86
00:06:10,220 --> 00:06:13,830
of your UIScrollView that you want the user to be able zoom.

87
00:06:13,830 --> 00:06:19,950
So we're going to need to add a subview, so we'll just
add one UIImageView to each of these zooming scroll views,

88
00:06:19,950 --> 00:06:23,290
and we'll return those from the view for
zooming and scroll view delegate method

89
00:06:23,290 --> 00:06:24,530
so that they're the things that get zoomed.

90
00:06:24,530 --> 00:06:28,470
So we've kind of a built a bit of
a layer-- a set of layers up here.

91
00:06:28,470 --> 00:06:31,210
It's gotten a little bit complicated
and you can't see it all anymore.

92
00:06:31,210 --> 00:06:33,990
So let's step back and take a look
at everything we just did.

93
00:06:33,990 --> 00:06:37,600
We've got our outer paging scroll view at the bottom.

94
00:06:37,600 --> 00:06:39,800
That handles just the paging.

95
00:06:39,800 --> 00:06:44,290
We've got subviews to handle the zooming
and those are also UIScrollViews.

96
00:06:44,290 --> 00:06:46,840
And then finally, we've got the UIImageViews subviews

97
00:06:46,840 --> 00:06:50,450
of the zooming scroll views that
are actually displaying the photos.

98
00:06:50,450 --> 00:06:55,260
The combination of these three things just like
this is all you actually have to do in order

99
00:06:55,260 --> 00:07:01,140
to get the exact same paging, zooming, scrolling
behavior that you see in the photos app in iPhone OS.

100
00:07:01,140 --> 00:07:05,060
Just adding them as subviews takes care of everything.

101
00:07:05,060 --> 00:07:09,780
So the one thing that's missing before we go and
take a look at how you'll actually implement it is

102
00:07:09,780 --> 00:07:16,090
that the photos application, you'll notice actually
separates the photos a bit, there's a bit of black padding

103
00:07:16,090 --> 00:07:19,030
between each one of the photos to make
it very clear that there's a border

104
00:07:19,030 --> 00:07:21,580
where one photo ends and where the next begins.

105
00:07:21,580 --> 00:07:27,150
In our pictures of frogs here, they're all pretty green
and as you're scrolling between it's not entirely obvious

106
00:07:27,150 --> 00:07:30,390
where one ends and the next begins,
because they kind of bleed together.

107
00:07:30,390 --> 00:07:35,560
So in order to make them stand apart a bit,
we actually have to increase the page width

108
00:07:35,560 --> 00:07:38,400
so that there's more space between each page.

109
00:07:38,400 --> 00:07:40,100
But as I just said a minute ago, the page width

110
00:07:40,100 --> 00:07:44,430
of a scroll a scroll view is determined
by that scroll view's bounds width.

111
00:07:44,430 --> 00:07:49,860
So in order to get the page width bigger, we actually have
to increase the size of that outer paging scroll view.

112
00:07:49,860 --> 00:07:57,320
So I'm just going to change the bounds from 320
points up to 340 points and keep it centered on screen

113
00:07:57,320 --> 00:08:01,220
so there'll be 10 points hanging off on the left and
10 on the right but they're off the side of the screen

114
00:08:01,220 --> 00:08:03,050
and there's not going to be displayed there anyway.

115
00:08:03,050 --> 00:08:05,560
So it's really just to increase the page width.

116
00:08:05,560 --> 00:08:08,550
The zooming scroll views will stay the same size.

117
00:08:08,550 --> 00:08:11,770
So once we do that, you'll see they'll kind
of spread apart and we'll get a bit of padding

118
00:08:11,770 --> 00:08:14,660
between each photo, to frame the photo against black.

119
00:08:14,660 --> 00:08:18,020
Now it's a little hard to see so
we collapse it back down again.

120
00:08:18,020 --> 00:08:21,260
You can start to see that we now we can view a bit

121
00:08:21,260 --> 00:08:25,190
of that outer paging scroll view from
behind of the zooming scroll view.

122
00:08:25,190 --> 00:08:30,780
Zooming scroll view is still 320 points,
paging scroll view is now 340 points.

123
00:08:30,780 --> 00:08:32,760
And each of those zooming scroll views are just centered

124
00:08:32,760 --> 00:08:36,120
within their respective 340 points
of the paging scroll view.

125
00:08:36,120 --> 00:08:38,660
So that's the configuration.

126
00:08:38,660 --> 00:08:40,030
There's really not much else to it.

127
00:08:40,030 --> 00:08:47,350
With that, let's have Eliza come up and
show us how to actually build this in code.

128
00:08:47,350 --> 00:08:47,800
>>Eliza Block: Hi.

129
00:08:47,800 --> 00:08:51,150
I'm Eliza and I'm an Engineer on the Spring Board team.

130
00:08:51,150 --> 00:08:55,870
I'm going to show you how you can set this up
in code to do exactly what Josh just described.

131
00:08:55,870 --> 00:09:01,580
So we're going to start with a simple view base
application and we're going to do almost all of the work

132
00:09:01,580 --> 00:09:08,920
to configure the zooming and paging in the view
controller subclass that's our root view controller.

133
00:09:08,920 --> 00:09:11,910
So I'm going to switch here to the demo machine.

134
00:09:11,910 --> 00:09:18,830
Alright, so this is the header file for our view controller
and I'm going to add one instance variable to start us off,

135
00:09:18,830 --> 00:09:23,050
which is the paging scroll view
that we're going to be using.

136
00:09:23,050 --> 00:09:28,340
I'm now going to switch to the implementation,
and we can actually do all of the setup

137
00:09:28,340 --> 00:09:32,330
in the Load view method of our view controller.

138
00:09:32,330 --> 00:09:36,560
So we'll start by creating the Paging
Scroll View that we just declared.

139
00:09:36,560 --> 00:09:39,970
We need to figure out what its frame is going to be.

140
00:09:39,970 --> 00:09:43,080
So let's start with the screen bounds.

141
00:09:43,080 --> 00:09:49,080
But as Josh explained, we're going to want to have that
paging scroll view hang off the sides of the screen

142
00:09:49,080 --> 00:09:52,180
by 10 pixels so that we'll leave some space on either side.

143
00:09:52,180 --> 00:09:59,650
So I'm going to subtract 10 from its X
origin and I'm going to add 20 to its width.

144
00:09:59,650 --> 00:10:04,480
And the effect of that is it will now hang off
10 pixels on the left and 10 pixels on the right.

145
00:10:04,480 --> 00:10:12,100
So let's create the paging scroll view with that frame.

146
00:10:12,100 --> 00:10:14,090
We're going to set a few properties now.

147
00:10:14,090 --> 00:10:17,780
We need to set paging enabled as Josh explained.

148
00:10:17,780 --> 00:10:22,120
We need to set the background color to black.

149
00:10:22,120 --> 00:10:26,120
And finally, we need to set the content
size of this paging scroll view now.

150
00:10:26,120 --> 00:10:30,420
The content size is the property
that determines the scrollable area.

151
00:10:30,420 --> 00:10:37,250
So we want to make it wide enough to accommodate all of
the pages that we're going to insert in a minute here.

152
00:10:37,250 --> 00:10:45,850
So the width of this content size is going to be the size of
the width of a page times the number of images that we have

153
00:10:45,850 --> 00:10:47,980
and I've got a convenient method here, image count,

154
00:10:47,980 --> 00:10:50,260
which just returns the number of
images that we're going to display.

155
00:10:50,260 --> 00:10:54,450
And the height will just be the size-- the
height of the frame because we're not going

156
00:10:54,450 --> 00:10:57,320
to allow for scrolling in the vertical direction.

157
00:10:57,320 --> 00:11:00,790
Alright, we're in the load view method.

158
00:11:00,790 --> 00:11:02,340
We need to produce a view.

159
00:11:02,340 --> 00:11:05,380
So we can actually use this paging scroll view as our view.

160
00:11:05,380 --> 00:11:08,360
So I'll just set our view to the paging scroll view.

161
00:11:08,360 --> 00:11:10,790
So now the paging part is totally finished.

162
00:11:10,790 --> 00:11:13,730
This is going to work just fine but
it doesn't have any content yet.

163
00:11:13,730 --> 00:11:20,110
So the next thing we need to do is add some pages.

164
00:11:20,110 --> 00:11:27,350
Alright, now as a first pass, let's just go through
all the images we have and for each image we're going

165
00:11:27,350 --> 00:11:30,530
to make a page and insert it into the scroll view.

166
00:11:30,530 --> 00:11:34,570
So I'm going to just iterate through my images.

167
00:11:34,570 --> 00:11:38,780
And for each image, I'm going to
create a zooming scroll view.

168
00:11:38,780 --> 00:11:44,960
And now, I've made a custom subclass of UIScrollView
called imageScrollView and I'm going to use it.

169
00:11:44,960 --> 00:11:52,430
What this does is it sets up the zooming for you and--
but-- so I'm not going to show you the details of that now.

170
00:11:52,430 --> 00:11:55,170
But if you want to take look at it
in the sample code you can go ahead.

171
00:11:55,170 --> 00:12:01,100
Basically, it creates a zooming scroll view exactly as you
would if you weren't embedding it into a paging scroll view.

172
00:12:01,100 --> 00:12:03,490
It's just a straightforward zooming scroll view.

173
00:12:03,490 --> 00:12:08,550
And it sets itself up with the right minimum
and maximum zoom scale and everything.

174
00:12:08,550 --> 00:12:13,190
Alright, we're going to configure this page
for the particular index that we're at.

175
00:12:13,190 --> 00:12:17,530
And that's just going to set the
frame of the page appropriately.

176
00:12:17,530 --> 00:12:24,050
So the first page is going to go at the beginning of the
content of the paging scroll view and then as we go forward

177
00:12:24,050 --> 00:12:27,890
and index this we'll position them in a row.

178
00:12:27,890 --> 00:12:34,710
It's also going to find the image for that index and
tell the zooming scroll view to display that image.

179
00:12:34,710 --> 00:12:41,790
Finally, we need to add that page as a subview of
our paging scroll view and that's pretty much it.

180
00:12:41,790 --> 00:12:44,510
We can just go ahead and build this.

181
00:12:44,510 --> 00:12:51,620
[ Pause ]

182
00:12:51,620 --> 00:12:54,000
OK. So, we have a page here.

183
00:12:54,000 --> 00:12:57,570
We can zoom in and out on it.

184
00:12:57,570 --> 00:12:58,800
So the zooming part is working.

185
00:12:58,800 --> 00:13:04,500
As we get to the edge, we can page over and
you can see that the paging works as planned.

186
00:13:04,500 --> 00:13:13,140
There's one drawback here which is that the-- our
image when it gets to the landscape dimension is

187
00:13:13,140 --> 00:13:14,950
up at the top which isn't really what you'd want.

188
00:13:14,950 --> 00:13:20,000
So you'd actually kind of want as the image gets zoomed
out to be smaller than the screen you kind of want it

189
00:13:20,000 --> 00:13:23,470
to be centered in the screen rather
than hugging the upper left corner.

190
00:13:23,470 --> 00:13:28,630
So that some of you might be aware the default behavior
of UIScrollView is that as the image gets smaller

191
00:13:28,630 --> 00:13:31,530
than the bounds of the Scroll View it hugs the upper left.

192
00:13:31,530 --> 00:13:36,960
Actually a lot of people asked us last year after
our session whether there was a good way to fix that

193
00:13:36,960 --> 00:13:39,870
and what I'm going to do right
now is show you how to do that.

194
00:13:39,870 --> 00:13:45,660
So we're going to modify this so that the image
stays centered as you scroll out, zoom out on it.

195
00:13:45,660 --> 00:13:50,050
Alright so to do that, we're going to switch
over to this imageScrollView subclass.

196
00:13:50,050 --> 00:13:53,990
So I'm going to go grab the implementation file for that.

197
00:13:53,990 --> 00:13:58,400
And we can do that by overriding the layout subviews method.

198
00:13:58,400 --> 00:14:06,670
Now, the advantage of the layout subviews method is that
it's called at every frame of both zooming and scrolling.

199
00:14:06,670 --> 00:14:13,880
So if we want to keep a view centered,
this is the perfect place to do it.

200
00:14:15,230 --> 00:14:17,800
So the first thing to do when you're
overriding layout subviews

201
00:14:17,800 --> 00:14:21,150
in a UIScrollView subclass is to remember to call super.

202
00:14:21,150 --> 00:14:26,530
UIScrollView does a lot of important configuration in
its layout subview methods so don't forget to do that.

203
00:14:26,530 --> 00:14:32,160
And then we're going to need to figure out what is the size
of the bounds that I want to keep this thing centered in

204
00:14:32,160 --> 00:14:39,190
and that's going to be the bounds, my own bound
size, since I'm in this case, the UIScrollView.

205
00:14:39,190 --> 00:14:46,010
And then we need to grab the frame that we're going
to want to center which is the image view frame.

206
00:14:46,010 --> 00:14:50,950
So now we're just going to go ahead and center
this frame both horizontally and vertically.

207
00:14:50,950 --> 00:14:53,430
So here's the horizontal direction.

208
00:14:53,430 --> 00:15:02,400
Alright, as you're zooming out so
that your image is getting smaller,

209
00:15:02,400 --> 00:15:10,090
you only want to start centering it once it has
started to be smaller than the width of your bounds,

210
00:15:10,090 --> 00:15:12,000
otherwise you want to kind of leave it alone.

211
00:15:12,000 --> 00:15:16,140
So what we want to do is check.

212
00:15:16,140 --> 00:15:19,830
Is the frame smaller in width than the bounds?

213
00:15:19,830 --> 00:15:26,040
If so, we're going to adjust the origin of
our frame to keep it centered in the bounds.

214
00:15:26,040 --> 00:15:29,670
If it's not smaller, we're just going to put it back at zero where it started

215
00:15:29,670 --> 00:15:34,150
so that we don't leave it centered as we zoom back in again.

216
00:15:34,150 --> 00:15:38,590
Do the exact same thing for the vertical.

217
00:15:38,590 --> 00:15:43,340
And finally, we just need to use
the new frame that we calculated.

218
00:15:43,340 --> 00:15:45,510
So I'm going to build this again.

219
00:15:45,510 --> 00:15:54,160
[ Pause ]

220
00:15:54,160 --> 00:16:01,170
And now, as I scroll over, you can see that the
landscape images are centered as we'd hoped.

221
00:16:01,170 --> 00:16:07,870
And in fact if I zoom out on one of these, you can see
that it hugs the center rather than the upper left.

222
00:16:07,870 --> 00:16:12,070
Alright, so before I turn it back to Josh,
I want to just signal one big problem

223
00:16:12,070 --> 00:16:13,810
with the application as we've run it so far.

224
00:16:13,810 --> 00:16:20,040
So I'm just going to open the activity monitor
and take a look at our memory consumption here.

225
00:16:20,040 --> 00:16:27,920
So, alright, let me see whether I can zoom in
on this to show you the real memory here is--

226
00:16:27,920 --> 00:16:32,210
we're using 400, almost 450 megabytes, the real memory.

227
00:16:32,210 --> 00:16:36,200
Now the reason for that is that
these images are pretty large.

228
00:16:36,200 --> 00:16:42,170
They're 6 or 7 megabytes compressed which translates
to somewhere between 20 and 40 megabytes uncompressed

229
00:16:42,170 --> 00:16:45,940
and what we did was we loaded every
single one of them upfront.

230
00:16:45,940 --> 00:16:52,070
We added every single one of them to our paging scroll
view so we have them all open in memory at once.

231
00:16:52,070 --> 00:16:55,610
And an iPhone doesn't have this much memory at all.

232
00:16:55,610 --> 00:17:01,680
So you would crash before you even started if
you were to do it this way on the actual device.

233
00:17:01,680 --> 00:17:03,510
So I'm going to turn it back to Josh.

234
00:17:03,510 --> 00:17:09,510
He's going to talk a little bit
about how we can avoid this problem.

235
00:17:09,510 --> 00:17:16,130
[ Applause ]

236
00:17:16,130 --> 00:17:17,740
>> Josh Shaffer: Alright, thanks Eliza.

237
00:17:17,740 --> 00:17:22,070
So, now we've got all of our behaviors
exactly as we want them except for the part

238
00:17:22,070 --> 00:17:26,200
where our users can't really see them because the
app crashes before they can actually launch it.

239
00:17:26,200 --> 00:17:30,330
So, let's try and fix that problem so
that somebody could actually use our app.

240
00:17:30,330 --> 00:17:35,950
Now we talked a bit about one of these approaches
last year in the Mastering iPhone Scroll View session.

241
00:17:35,950 --> 00:17:41,660
And what we talked about was tiling
your content using subview tiling.

242
00:17:41,660 --> 00:17:44,720
So we're going to talk about two
different approaches to tiling this year.

243
00:17:44,720 --> 00:17:50,250
The first will be subview tiling again although we're
going to talk about it in a different context and use it

244
00:17:50,250 --> 00:17:52,330
for a different purpose than what we used it for last year.

245
00:17:52,330 --> 00:17:58,000
And then we're going to talk about
CATiledLayer and drawn tiling.

246
00:17:58,000 --> 00:18:00,190
So why do you want to tile first of all?

247
00:18:00,190 --> 00:18:02,080
Well, the first reason is what we just talked about.

248
00:18:02,080 --> 00:18:06,060
You may want to display more content
than you can actually fit in the memory.

249
00:18:06,060 --> 00:18:10,320
But you may also want to download additional
pieces of content as you need them.

250
00:18:10,320 --> 00:18:17,110
The Maps Application on iPhone OS for example downloads just
individual tiles of whole world map at multiple zoom scales

251
00:18:17,110 --> 00:18:21,210
and different resolutions, more data than
would probably even fit on the phone.

252
00:18:21,210 --> 00:18:24,110
So you may want to tile if you
have to do something like that.

253
00:18:24,110 --> 00:18:25,650
But it also improves load time.

254
00:18:25,650 --> 00:18:29,550
I'm not sure if you noticed when
Eliza was building and running there.

255
00:18:29,550 --> 00:18:32,860
But it actually took quite a while
for that app to launch the first time

256
00:18:32,860 --> 00:18:36,550
because it was uncompressing all those
images and that was on a really fast Mac Pro.

257
00:18:36,550 --> 00:18:39,230
On your device, it would take so long that you would--

258
00:18:39,230 --> 00:18:43,670
your app would get killed before it even launched
anyway, even if it didn't run out of memory.

259
00:18:43,670 --> 00:18:46,100
So we really don't want to do that.

260
00:18:46,100 --> 00:18:48,370
Alright, so two approaches.

261
00:18:48,370 --> 00:18:49,910
First, we've got subview tiling.

262
00:18:49,910 --> 00:18:53,680
So we'll leave our little frog for
later and we'll come back to him.

263
00:18:53,680 --> 00:18:59,470
Now if you've used UITableView before, you've
already seen subview tiling in one way.

264
00:18:59,470 --> 00:19:04,680
Table view, you know, when you implement your cell for
rowAtIndexPath method, the first thing that you try

265
00:19:04,680 --> 00:19:08,080
and do is dequeue a reusable cell with an identifier.

266
00:19:08,080 --> 00:19:12,810
And what's that doing is basically implementing
subview tiling for you on your behalf.

267
00:19:12,810 --> 00:19:18,410
So, as your user scrolls through their table
view, cells move off the top, you dequeue them

268
00:19:18,410 --> 00:19:20,970
and put new content in and they scroll in on the bottom.

269
00:19:20,970 --> 00:19:23,800
And this happens repeatedly.

270
00:19:23,800 --> 00:19:27,710
So we'd really like to do basically
the exact same thing for our photos app

271
00:19:27,710 --> 00:19:31,420
as the user is paging horizontally
one photo moves off screen.

272
00:19:31,420 --> 00:19:34,270
We no longer need that scroll view
to display it when it's not visible.

273
00:19:34,270 --> 00:19:37,520
We can reuse it and move it in to
display another photo on the right.

274
00:19:37,520 --> 00:19:41,650
So that's exactly what we're going to do.

275
00:19:41,650 --> 00:19:44,620
We've got this set up that we just looked at.

276
00:19:44,620 --> 00:19:51,110
Let's expand it again but now see only the
parts that we actually need at any given time.

277
00:19:51,110 --> 00:19:56,370
So the shaded version of our paging scroll view
is the frame that's actually visible on the phone.

278
00:19:56,370 --> 00:20:01,480
And so we only have one zooming scroll view
that's visible in that frame right now.

279
00:20:01,480 --> 00:20:04,050
And so we only have to load one photo.

280
00:20:04,050 --> 00:20:07,340
Now if we make it a little bigger so
that we can see this happen over time,

281
00:20:07,340 --> 00:20:11,960
as the user pages through our photos, at
any point there's only going to be a maximum

282
00:20:11,960 --> 00:20:15,350
of two different photos visible at any given time.

283
00:20:15,350 --> 00:20:20,000
So we can page through and as we do it you
can see we only ever have two photos visible

284
00:20:20,000 --> 00:20:23,350
and there is only ever two scroll
views created to show those photos.

285
00:20:23,350 --> 00:20:26,860
So it's going to be much less memory and
much less set up cost initially in order

286
00:20:26,860 --> 00:20:31,850
to even begin launching and displaying these things.

287
00:20:31,850 --> 00:20:32,940
So where do we want to do this?

288
00:20:32,940 --> 00:20:34,770
That's what we're trying to accomplish.

289
00:20:34,770 --> 00:20:38,130
Well, we could do it in the layout
subviews method that Eliza just showed us.

290
00:20:38,130 --> 00:20:43,360
But maybe we don't actually want to have to subclass
UIScrollView because it's really not even necessary

291
00:20:43,360 --> 00:20:44,790
for the zooming case that we just looked at.

292
00:20:44,790 --> 00:20:48,810
You could do that all without a subclass.

293
00:20:48,810 --> 00:20:52,860
So if we didn't want to subclass, we
could instead implement the view--

294
00:20:52,860 --> 00:20:58,280
scrollViewDidScroll delegate method which is called
under the same conditions as layout subviews.

295
00:20:58,280 --> 00:21:03,270
Basically, every time that the user scrolls any amount
through the scroll view, either by dragging their finger

296
00:21:03,270 --> 00:21:07,040
or by flicking or having it decelerate,
scrollViewDidScroll will be called

297
00:21:07,040 --> 00:21:10,720
for every frame before that frame
is actually drawn on screen.

298
00:21:10,720 --> 00:21:13,030
So you have a chance to add subviews if you're going to need

299
00:21:13,030 --> 00:21:17,870
to display more content before that
empty spot even becomes visible.

300
00:21:17,870 --> 00:21:19,230
So that's exactly what we'll do.

301
00:21:19,230 --> 00:21:21,610
And Eliza is going to come back
up to show us how to do that.

302
00:21:21,610 --> 00:21:26,060
>> Eliza Block: Alright, so we're going to just start
right where we left off with the same application.

303
00:21:26,060 --> 00:21:30,340
I've moved back to the view controller header
file because we're going to need to add a couple

304
00:21:30,340 --> 00:21:33,270
of new ibars in order to accomplish the tiling.

305
00:21:33,270 --> 00:21:38,110
So our strategy is going to be-- we're going to
keep track of what tiles are currently visible.

306
00:21:38,110 --> 00:21:41,840
So we're going to need a set to keep track of
the visible tiles and we're also going to--

307
00:21:41,840 --> 00:21:46,790
as we pull out tiles that are already used because
they've gone off screen, we're going to keep track

308
00:21:46,790 --> 00:21:50,150
of them in another set of recyclable tiles.

309
00:21:50,150 --> 00:21:56,050
So I'm going to add two ibars here.

310
00:21:56,050 --> 00:22:01,160
A recycled pages set and a visible pages set.

311
00:22:01,160 --> 00:22:03,730
I'm also going to declare two new methods.

312
00:22:03,730 --> 00:22:09,610
We are going to need a method will get us a
recycled page if there is one available so this is--

313
00:22:09,610 --> 00:22:15,110
I've named this by analogy with the
UITableView dequeue reusable cell method.

314
00:22:15,110 --> 00:22:22,660
So we'll get us a recycled page and we're also going
to need a method that actually accomplishes the tiling.

315
00:22:22,660 --> 00:22:26,420
So let me switch over back to the implementation.

316
00:22:26,420 --> 00:22:33,700
Alright, here's our load view method and at the bottom,
we have these lines of code that add all the pages in.

317
00:22:33,700 --> 00:22:36,110
We don't want to do that because that's
what was using up all of our memory.

318
00:22:36,110 --> 00:22:37,950
So I'm just going to delete that.

319
00:22:37,950 --> 00:22:44,750
And instead what we'll do here is first we'll actually
create our recycled pages and visible pages sets

320
00:22:44,750 --> 00:22:51,710
and then we'll just call tile pages once to get
the tiling started and that will have the effect

321
00:22:51,710 --> 00:22:56,840
of showing the first page since that's the page
that you start on when this view is loaded.

322
00:22:56,840 --> 00:23:02,070
Now as Josh has pointed out it's
not enough to tile the pages once.

323
00:23:02,070 --> 00:23:04,600
We need to tile them every time
that the scroll view scrolls.

324
00:23:04,600 --> 00:23:09,190
So for that purpose, I'm going to implement
this scrollViewDidScroll delegate method.

325
00:23:09,190 --> 00:23:14,560
So we need to set our view controller as
the delegate of the paging scroll view.

326
00:23:14,560 --> 00:23:17,480
And then we'll implement scrollViewDidScroll

327
00:23:17,480 --> 00:23:21,510
and all we'll do is call tile pages
again every time the scroll view scrolls.

328
00:23:21,510 --> 00:23:25,720
OK, so what does it look like to tile the pages?

329
00:23:25,720 --> 00:23:30,350
I'm going to scroll down here to give us some space.

330
00:23:30,350 --> 00:23:37,710
So the first thing that we need to do when
we're tiling the pages is to calculate how--

331
00:23:37,710 --> 00:23:42,450
which pages should be visible given the
current content offset of our scroll view.

332
00:23:42,450 --> 00:23:47,460
So for that purpose, what we're going to do
is grab the visible bounds of the scroll view.

333
00:23:47,460 --> 00:23:53,000
And once we have the visible bounds, you can think of that
as a rectangle of the content and we're going to take a look

334
00:23:53,000 --> 00:23:58,350
at that rectangle and you can think
of it as a bunch of columns of pixels.

335
00:23:58,350 --> 00:24:04,420
So we'll look at the first column of pixels and we'll
see which page is that column of pixels associated with.

336
00:24:04,420 --> 00:24:05,880
Which page is that column of pixels in?

337
00:24:05,880 --> 00:24:11,100
And that's going to be the first page that we need to
display and then we'll look at the last column of pixels

338
00:24:11,100 --> 00:24:14,630
and we'll find the page that that column is on.

339
00:24:14,630 --> 00:24:16,730
And so that's going to be our range of pages.

340
00:24:16,730 --> 00:24:17,880
That's the strategy.

341
00:24:17,880 --> 00:24:19,420
So I'm going to paste some math here.

342
00:24:19,420 --> 00:24:20,770
I don't want you to worry about it.

343
00:24:20,770 --> 00:24:23,550
You can take a look at the sample code
and go through it and see how it works.

344
00:24:23,550 --> 00:24:26,520
But what it's doing is, what I just described,

345
00:24:26,520 --> 00:24:31,750
it's calculating the first needed page
index and the last needed page index.

346
00:24:31,750 --> 00:24:37,760
Alright, so now that we know which pages
we need, let's first recycle the ones

347
00:24:37,760 --> 00:24:41,060
that we don't need but that we already have in our view.

348
00:24:41,060 --> 00:24:45,470
So for that, we're going to use
this visible pages set that we have.

349
00:24:45,470 --> 00:24:47,520
And we're going to look at each
of the pages that's currently

350
00:24:47,520 --> 00:24:51,830
in the visible pages set and find out is it needed or not.

351
00:24:51,830 --> 00:24:55,350
Now, I've taken advantage of the
fact that I have a custom subclass

352
00:24:55,350 --> 00:24:58,080
of UIScrollView that my pages are image scroll views.

353
00:24:58,080 --> 00:25:00,530
And I've taught them to know what index they are.

354
00:25:00,530 --> 00:25:02,450
So what page index they represent.

355
00:25:02,450 --> 00:25:04,310
So what we're going to do is use that here.

356
00:25:04,310 --> 00:25:08,890
We'll just ask the page that we're on, is
your index outside of our needed range?

357
00:25:08,890 --> 00:25:11,960
Is it less than the first or greater
than the last needed page?

358
00:25:11,960 --> 00:25:16,840
So if it is outside of the needed range, we're going
to recycle it by adding it to our recycled pages.

359
00:25:16,840 --> 00:25:25,290
We're going to remove it from the Super View and we also
want to now take note of the fact that it's no longer

360
00:25:25,290 --> 00:25:30,040
in our visible pages set so we want to
remove it from the visible pages set.

361
00:25:30,040 --> 00:25:34,070
But don't do that in that way because adding this line

362
00:25:34,070 --> 00:25:39,150
of code here would be mutating a
set while we're enumerating it.

363
00:25:39,150 --> 00:25:45,750
And that's a really bad idea once you've checked that bug
into Springboard you never make the same mistake again.

364
00:25:45,750 --> 00:25:50,480
[Laughter] So let's take that out and after the
four loops safely, when we're finished enumerating,

365
00:25:50,480 --> 00:25:55,060
we can take advantage of the fact that these
are sets and we can do a set subtraction

366
00:25:55,060 --> 00:26:01,180
and just remove all those recycled pages from the visible
pages and that's a safer way to handle that problem.

367
00:26:01,180 --> 00:26:08,280
So now that we've recycled our pages, we need to add the
ones that are needed, that aren't already in the view.

368
00:26:08,280 --> 00:26:17,390
So for that, we're going to iterate through from the
first to the last needed page and we'll ask is this--

369
00:26:17,390 --> 00:26:20,280
do we actually have a page that's indexed already?

370
00:26:20,280 --> 00:26:22,750
And I've made a convenience method here,

371
00:26:22,750 --> 00:26:24,420
isDisplayingPageForIndex.

372
00:26:24,420 --> 00:26:29,010
What that does is it actually just looks through the
visible pages and sees whether there is one at that index.

373
00:26:29,010 --> 00:26:36,710
So if there's not, so if we're missing this
page that we need, we're going to make the page,

374
00:26:36,710 --> 00:26:43,720
configure it for the right index, add it as a
subview of our scroll view just like we did before.

375
00:26:43,720 --> 00:26:48,300
And finally, we'll note that this
page is now in our visible set.

376
00:26:48,300 --> 00:26:49,900
OK, we're almost ready to go.

377
00:26:49,900 --> 00:26:52,850
This would work at least at first.

378
00:26:52,850 --> 00:26:57,710
But you'll notice that I'm actually not using my
recycled pages at all for every time that we discover

379
00:26:57,710 --> 00:27:00,750
that we need a new page, I'm creating one from scratch.

380
00:27:00,750 --> 00:27:05,920
So eventually, we would hit our same memory problem as
we had in the first version once we filled up-- had--

381
00:27:05,920 --> 00:27:08,200
you know, scrolled all the way over to the last page.

382
00:27:08,200 --> 00:27:11,870
So let's actually use the recycled pages here.

383
00:27:11,870 --> 00:27:17,690
We need to implement this dequeue
recycled page method that I declared.

384
00:27:17,690 --> 00:27:18,950
So here it is.

385
00:27:18,950 --> 00:27:27,220
I grab any object out of my recycled pages set
and I do a little memory management stuff here,

386
00:27:27,220 --> 00:27:31,830
because presumably the recycled pages
set owns the last retain on this page.

387
00:27:31,830 --> 00:27:35,490
So if I were to remove it from the
recycled pages set and then return it,

388
00:27:35,490 --> 00:27:38,500
it would actually go away before
it had a chance to be returned.

389
00:27:38,500 --> 00:27:44,850
So first, I retain and auto release it to guarantee
that that page is still there when we go try to use it.

390
00:27:44,850 --> 00:27:52,630
Alright, so scrolling back up to here, instead of creating a
page at this point, we're going to try to get a recycled one

391
00:27:52,630 --> 00:27:56,660
by calling that method and only if we fail to get one.

392
00:27:56,660 --> 00:28:00,470
So if there wasn't one available,
will we actually create a new one.

393
00:28:00,470 --> 00:28:11,000
Oops. Alright, so let me go ahead and build
this version and we'll see what happens.

394
00:28:11,000 --> 00:28:15,020
Alright, so I've got my same app.

395
00:28:15,020 --> 00:28:16,570
It looks the same.

396
00:28:16,570 --> 00:28:18,400
I can zoom in just as I could before.

397
00:28:18,400 --> 00:28:22,130
I can scroll to the next page.

398
00:28:23,150 --> 00:28:25,700
So, things seem OK.

399
00:28:25,700 --> 00:28:35,020
Let's take a look at the activity monitor and
see how much memory we're using this time.

400
00:28:35,020 --> 00:28:36,490
There it is.

401
00:28:36,490 --> 00:28:38,070
Just a little over a 100 megabytes.

402
00:28:38,070 --> 00:28:40,910
So we've cut our memory consumption
down by a significant amount.

403
00:28:40,910 --> 00:28:45,350
Enough that you could probably actually run
this version of this application on the device.

404
00:28:45,350 --> 00:28:47,220
But let me just signal a problem.

405
00:28:47,220 --> 00:28:50,970
I don't know if it was very apparent
when I was scrolling through here.

406
00:28:50,970 --> 00:28:57,120
But if you take a look at the arrow, as I scroll
there's a perceptible lag before the next page appears.

407
00:28:57,120 --> 00:29:00,920
And the experience of it, you really feel
like this thing isn't responding very well.

408
00:29:00,920 --> 00:29:09,300
The reason is that, I'm actually having to load
and decompress that huge image at the beginning

409
00:29:09,300 --> 00:29:12,050
of the scroll, as I'm getting to my next page.

410
00:29:12,050 --> 00:29:17,940
And so, you actually get a bad performance problem
on this really powerful Mac, it's perceptible.

411
00:29:17,940 --> 00:29:19,900
On the device it would be really unacceptable.

412
00:29:19,900 --> 00:29:25,090
So let's-- I'm going to turn you back over to
Josh who will tell us how we can fix that problem.

413
00:29:25,090 --> 00:29:25,670
[ Applause ]

414
00:29:25,670 --> 00:29:29,850
>> Josh Shaffer: Alright, thanks again Eliza.

415
00:29:29,850 --> 00:29:31,480
So, we're getting much closer.

416
00:29:31,480 --> 00:29:34,650
We're actually almost there.

417
00:29:34,650 --> 00:29:36,060
Now I'm sure this is familiar.

418
00:29:36,060 --> 00:29:39,400
You've got the maps application from
iPhone OS here and it shows you exactly

419
00:29:39,400 --> 00:29:42,420
where you are at, you know, any given time.

420
00:29:42,420 --> 00:29:47,210
And at some point later, it shows
you what else is where you are.

421
00:29:47,210 --> 00:29:54,260
The way that works is by using CATiled layer to
lazily load all of the different tiles that make

422
00:29:54,260 --> 00:29:56,480
up the map that you're currently viewing.

423
00:29:56,480 --> 00:30:01,460
And these tiles are loaded off the network on a background
thread and then get drawn when they are finally available.

424
00:30:01,460 --> 00:30:07,170
And see, a tiled layer is available for
use as public API in your own applications.

425
00:30:07,170 --> 00:30:09,740
So you can do the exact same thing.

426
00:30:09,740 --> 00:30:12,860
So we already looked at this first subview tiling example.

427
00:30:12,860 --> 00:30:18,790
And that's a great way to do tiling if you
need to tile more complicated view hierarchies.

428
00:30:18,790 --> 00:30:22,290
Things like whole table view cells that
are composed of multiple subviews and,

429
00:30:22,290 --> 00:30:24,400
you know, UILabels, and all these other things.

430
00:30:24,400 --> 00:30:28,600
Or in the case of our paging, we
needed to tile entire UIScrollViews.

431
00:30:28,600 --> 00:30:33,720
So if you need complicated view hierarchies, you
really want to do your own subview tiling like that.

432
00:30:33,720 --> 00:30:39,410
But if you can do your drawing in drawRect, then
CATiledLayer can make this significantly easier.

433
00:30:39,410 --> 00:30:45,260
It can remove almost all of the management code that we just
looked at and, basically, just leave you do draw your content

434
00:30:45,260 --> 00:30:50,230
when you're asked and handles things like caching
to make sure that it's only using the amount

435
00:30:50,230 --> 00:30:53,770
of memory that's reasonable given
what the user has looked at.

436
00:30:53,770 --> 00:30:57,170
It only asks you to draw things that are currently visible.

437
00:30:57,170 --> 00:30:58,930
It supports multiple zoom scales.

438
00:30:58,930 --> 00:31:04,160
So as your user pinches to zoom in and out, it will
ask you for new tiles at a different zoom scale based

439
00:31:04,160 --> 00:31:10,500
on how many different levels of detail you'd like to
be able to display. And it manages all these for you.

440
00:31:10,500 --> 00:31:15,150
It's very easy to configure and you don't
have to write any code to implement all that.

441
00:31:15,150 --> 00:31:17,990
So let's take a look at that guy.

442
00:31:17,990 --> 00:31:21,630
The idea here is that we're going to
start out at a 100 percent zoom scale

443
00:31:21,630 --> 00:31:25,020
and will assume that our tiles are 100 by 100.

444
00:31:25,020 --> 00:31:28,640
So obviously, that means that in this case for
this portion of this frog we're looking at,

445
00:31:28,640 --> 00:31:32,210
we've got 16 tiles to make up this
entire portion of the frog.

446
00:31:32,210 --> 00:31:35,250
And that total size is 400 by 400.

447
00:31:35,250 --> 00:31:41,940
So assuming this was all we were looking at, we would
have created a CATiledLayer with bounds of 400 by 400

448
00:31:41,940 --> 00:31:45,180
and we'd add that as a subview of our zooming scroll view.

449
00:31:45,180 --> 00:31:50,040
Now as the user pinches in, we're going to drop
down to the 50 percent zoom scale at some point

450
00:31:50,040 --> 00:31:53,420
because the user will have pinched enough
that we're now only viewing half as much

451
00:31:53,420 --> 00:31:56,470
or we're viewing the image at half the original size.

452
00:31:56,470 --> 00:32:00,940
Once that's happened, assuming you've configured
your tiled layer to support a second level of detail,

453
00:32:00,940 --> 00:32:03,060
you'll be asked to draw the content again.

454
00:32:03,060 --> 00:32:07,650
But now, you'll be asked to draw it
at 50 percent of its original size.

455
00:32:07,650 --> 00:32:11,050
When that happens, the tiles will still be 100 by 100.

456
00:32:11,050 --> 00:32:17,170
So that's going to remain the same for the entire
duration of our example here and we're going to try

457
00:32:17,170 --> 00:32:20,220
and draw the exact same portion of our original image.

458
00:32:20,220 --> 00:32:25,810
So in that same frog we just saw before, we're
drawing again, but now, using tiles that are only as--

459
00:32:25,810 --> 00:32:28,810
a quarter as big, half an inch dimension.

460
00:32:30,430 --> 00:32:38,110
What this is going to end up doing though is asking us
to draw it into a bounds that is still the original size

461
00:32:38,110 --> 00:32:43,900
because if you looked at CALayer's geometry or UIView
geometry, you know that when a transform is applied

462
00:32:43,900 --> 00:32:48,520
to a view, that modifies the view's
frame which is the view size

463
00:32:48,520 --> 00:32:52,080
and the view super view, but it
doesn't modify the view's bounds.

464
00:32:52,080 --> 00:32:57,340
Frame is computed from bounds and
transform among a couple other properties.

465
00:32:57,340 --> 00:33:03,110
So the bounds of that CATiledLayer is still 400 by 400 and
we're going to be asked to draw under those same bounds.

466
00:33:03,110 --> 00:33:10,240
So effectively, we're going to be asked to draw
this, 100 by 100 tiles into a 400 by 400 bounds.

467
00:33:10,240 --> 00:33:14,420
Now, it may seem like-- when you start thinking about this,
you're going to have to multiply by your scale and so,

468
00:33:14,420 --> 00:33:19,640
you'll draw your 100 by 100 tile and stretch
it to be 200 by 200, and that's true.

469
00:33:19,640 --> 00:33:27,100
But that won't actually end up causing any actual stretching
in the drawing because the context you'll be asked to draw

470
00:33:27,100 --> 00:33:31,710
in actually has the inverse scale on it that
will scale it back down by half the amount.

471
00:33:31,710 --> 00:33:37,790
So you'll stretch it out to 200 by 200 and CG when it goes
to draw it will then scale it back down to 100 by 100.

472
00:33:37,790 --> 00:33:41,820
And the final draw of that image
will just be a 1 to 1 pixel bit.

473
00:33:41,820 --> 00:33:45,290
So the backing store for this is actually 200 by 200.

474
00:33:45,290 --> 00:33:49,220
So you saved the memory and you don't
actually lose image quality by scaling.

475
00:33:49,220 --> 00:33:55,560
Now similarly, if we had another level of
detail below this, we could have 25 percent.

476
00:33:55,560 --> 00:34:01,290
Once we got there, we'd be asked to draw the entire image
that we the just looked at into a single 100 by 100 tile

477
00:34:01,290 --> 00:34:07,770
because we now have 1/16 the amount of pixels, 1/16
the amount of memory being used, we've saved a lot

478
00:34:07,770 --> 00:34:11,450
and the user has pinched down so far that it doesn't
matter that we don't have all those original pixels

479
00:34:11,450 --> 00:34:14,320
because they're not able to be drawn on screen anyway.

480
00:34:14,320 --> 00:34:19,110
Again, 100 by 100, we're going to stretch
it when we draw it to fill that 400 by 400.

481
00:34:19,110 --> 00:34:25,260
Now as I said, CA or Core Graphics rather, when
it actually does this drawing is really going

482
00:34:25,260 --> 00:34:28,320
to be drawing it into that 100 by 100 backing store.

483
00:34:28,320 --> 00:34:32,030
So that really is what you have
in memory, just a smaller amount.

484
00:34:32,030 --> 00:34:35,240
So at that point, assuming the user has
actually zoomed through all these things,

485
00:34:35,240 --> 00:34:38,650
Core Animation now has three different
sets of tiles to work with.

486
00:34:38,650 --> 00:34:43,350
And as the user pinches to zoom in and out or
double taps if you've got programmatic zooming,

487
00:34:43,350 --> 00:34:46,710
Core Animation will correctly swap
between which tile is necessary

488
00:34:46,710 --> 00:34:50,500
to optimally display whatever zoom
scale the user's currently looking at.

489
00:34:50,500 --> 00:34:54,960
And it's even cooler because if you do some
programmatic animations for the zoom scale changes,

490
00:34:54,960 --> 00:35:00,130
Core Animation does trilinear filtering to blend these
as they're animating between them and it's really,

491
00:35:00,130 --> 00:35:04,640
really cool and it's stuff that we'd take a long
time to actually implement on your own from scratch

492
00:35:04,640 --> 00:35:08,110
and you get it all for free just by using CATiledLayer.

493
00:35:08,110 --> 00:35:11,240
Alright, so hopefully that, you know,
kind of makes you want to use it.

494
00:35:11,240 --> 00:35:13,780
What is it that we actually have to do to use it?

495
00:35:13,780 --> 00:35:15,890
Well, turns out it's actually really easy.

496
00:35:15,890 --> 00:35:20,740
There are just two methods on UIView that you
have to implement to begin using a CATiledLayer.

497
00:35:20,740 --> 00:35:25,520
First off, you actually have to tell UIKit that
you want to use CATiledLayer, because by default,

498
00:35:25,520 --> 00:35:31,150
when a UIView is created, that UIView is
backed by a plain CALayer, not a subclass.

499
00:35:31,150 --> 00:35:37,460
So in order to change to a CATiledLayer, you implement a
class method in your UIView subclass called "layer class."

500
00:35:37,460 --> 00:35:41,370
And you just return CATiledLayer class from that method.

501
00:35:41,370 --> 00:35:42,480
Once you've done that, that's it.

502
00:35:42,480 --> 00:35:46,570
UIKit is creating a CATiledLayer
for you to back your UIView.

503
00:35:46,570 --> 00:35:50,430
So all that's left to do is actually draw
your content and you do that in drawRect,

504
00:35:50,430 --> 00:35:53,080
the same as you would with any other
layer that you were trying to draw.

505
00:35:53,080 --> 00:35:58,790
Now you need two pieces of information in order
to accurately draw what you're being asked.

506
00:35:58,790 --> 00:36:04,020
The first is the rect that comprises the tiles
you actually are being asked to draw right now.

507
00:36:04,020 --> 00:36:08,270
And the second is the zoom scale
that you're being asked to draw at.

508
00:36:08,270 --> 00:36:09,590
So the rect is easy.

509
00:36:09,590 --> 00:36:10,830
We've got it right there, right?

510
00:36:10,830 --> 00:36:16,110
And as we already said, keep in mind, this rect
is in the original bounds of that CATiledLayer

511
00:36:16,110 --> 00:36:18,500
because the bounds don't change while you're zooming.

512
00:36:18,500 --> 00:36:24,270
So how do we get the zoom scale though, there's no
property or no perimeter telling us what that is?

513
00:36:24,270 --> 00:36:25,980
Well, this is a little tricky.

514
00:36:25,980 --> 00:36:29,030
You actually have to pull the zoom
scale out of the current graphics--

515
00:36:29,030 --> 00:36:33,510
no, the current transform matrix of the current
graphics context associated with this drawRect.

516
00:36:33,510 --> 00:36:35,490
So what does that mean?

517
00:36:35,490 --> 00:36:41,620
Well, you can call UIGraphicsGetCurrentContext to
find out which context you're being asked to draw into

518
00:36:41,620 --> 00:36:46,220
and that'll be a CGContextRef that you're actually
going to draw into using core graphics calls.

519
00:36:46,220 --> 00:36:54,700
Then from that, you can get the current transform matrix
by calling CGContextGetCTM on the context we just got.

520
00:36:54,700 --> 00:36:57,980
And that's going to return the
CGAffineTransform which is the transform

521
00:36:57,980 --> 00:37:00,640
that is applied to all drawings done in that context.

522
00:37:00,640 --> 00:37:03,360
This is the bit I talked about where even
though you stretch out by multiplying

523
00:37:03,360 --> 00:37:07,100
by 2 this affine transform is going to scale back down by 2.

524
00:37:07,100 --> 00:37:09,620
So you'll end up actually not stretching.

525
00:37:09,620 --> 00:37:15,330
And in fact, that's exactly what we're looking for to
figure out which level of detail we're being asked to draw.

526
00:37:15,330 --> 00:37:19,440
We need to figure out what that scale
is that's on the CGAffineTransform.

527
00:37:19,440 --> 00:37:25,610
Now, I already know because we're using a
UIScrollView that were being scaled uniformly

528
00:37:25,610 --> 00:37:27,780
in the horizontal and vertical dimension.

529
00:37:27,780 --> 00:37:32,490
So we can greatly simplify the act of figuring out what
our scale is because we know that we can only zoom in--

530
00:37:32,490 --> 00:37:35,540
or that-- we can look at either because they're the same.

531
00:37:35,540 --> 00:37:37,410
And we know that there's no rotation on this transform.

532
00:37:37,410 --> 00:37:39,600
If there was, you'd have to do a bit more math.

533
00:37:39,600 --> 00:37:45,350
So this transform will assume just as the
scale that's applied by the UIScrollView.

534
00:37:45,350 --> 00:37:49,440
Given that, we can pull the scale out of the .a component--

535
00:37:49,440 --> 00:37:57,820
or .a field of this CGAffineTransform .a and .d are the two
scale fields, not too very important what that is right now.

536
00:37:57,820 --> 00:37:58,990
But we'll just get it out.

537
00:37:58,990 --> 00:38:02,830
So transform.a is the CGFloat that represents
the scale we're being asked to draw it.

538
00:38:02,830 --> 00:38:04,040
And that's it.

539
00:38:04,040 --> 00:38:05,940
We now have the rect we're being asked to draw.

540
00:38:05,940 --> 00:38:09,060
Make sure that you only draw that rect or
else you've negated the entire, you know,

541
00:38:09,060 --> 00:38:11,950
benefit of doing this because it's
only asking you to draw what's visible

542
00:38:11,950 --> 00:38:16,400
on screen and we also know what scale to draw in.

543
00:38:16,400 --> 00:38:18,840
So we can now draw our tiles.

544
00:38:18,840 --> 00:38:23,190
Now, I see some of you guys staring at me
and saying, "I tried this, didn't work."

545
00:38:23,190 --> 00:38:25,700
Well, that was actually true in iPhone OS 3.0.

546
00:38:25,700 --> 00:38:28,700
There was a little bit more that you
had to do in order to make that work.

547
00:38:28,700 --> 00:38:30,320
I've got a link to the tech note up here.

548
00:38:30,320 --> 00:38:36,510
If you want to deploy on iPhone OS 3.0, you can
check out this tech note at developer.apple.com.

549
00:38:36,510 --> 00:38:40,900
If you can't write it all down right now, you can
just search developer.apple.com for CATiledLayer.

550
00:38:40,900 --> 00:38:44,210
There're not a lot of references
so you can find it pretty quickly.

551
00:38:44,210 --> 00:38:45,780
But we'll ignore that for now.

552
00:38:45,780 --> 00:38:53,900
In iPhone OS or iOS 4, UIGraphicsGetCurrentContext as you
heard in the session earlier today is now thread safe.

553
00:38:53,900 --> 00:39:00,290
So even though CATiledLayer is going to call drawRect on
the background thread, that's now thread safe and you--

554
00:39:00,290 --> 00:39:03,500
you're UIGraphicsGetCurrentContext call will not be trampled

555
00:39:03,500 --> 00:39:06,490
by another drawRect happening on
your main thread simultaneously.

556
00:39:06,490 --> 00:39:09,790
Each one will have correctly their own current context.

557
00:39:09,790 --> 00:39:17,680
Also, UI image, UIColor, UIFont and the NSString
drawing additions in UIKit, they're also threadsafe now.

558
00:39:17,680 --> 00:39:21,410
So there's actually a lot of UIKit based
drawing that you can do in this drawRect even

559
00:39:21,410 --> 00:39:26,620
on your background thread that
CATiledLayer will call you on.

560
00:39:26,620 --> 00:39:31,510
So with that, let's have Eliza come back up and
want-- and make one final modification to her demo.

561
00:39:31,510 --> 00:39:39,180
[ Applause ]

562
00:39:39,180 --> 00:39:39,520
>> Eliza Block: Alright.

563
00:39:39,520 --> 00:39:41,680
So once again, we're going to start where we left off.

564
00:39:41,680 --> 00:39:48,260
We're going to modify this so that our zooming
scroll views instead of using image views as--

565
00:39:48,260 --> 00:39:51,890
in order to display an image, are going to use
a subclass of UIView that we're going to write

566
00:39:51,890 --> 00:39:55,190
in a moment and I called it a tiling view.

567
00:39:55,190 --> 00:40:00,740
Alright so before we get to the implementation of the
tiling view, there's one modification that we need to make

568
00:40:00,740 --> 00:40:03,440
to prepare to use tiles instead of full images.

569
00:40:03,440 --> 00:40:09,240
And that is-- this was a piece of
the demo that I didn't show you.

570
00:40:09,240 --> 00:40:15,810
But a part of configuring the zooming scroll view was
setting its content size for the zooming scroll view

571
00:40:15,810 --> 00:40:18,860
which we were setting to be the size
of the image that we were displaying.

572
00:40:18,860 --> 00:40:24,520
And conveniently, since we were displaying an entire
image, we could just grab the size right out of that image

573
00:40:24,520 --> 00:40:28,390
and use that to be the content
size of our zooming scroll view.

574
00:40:28,390 --> 00:40:33,640
Now, we don't want to open an entire image because
that was what was taking so long and making it--

575
00:40:33,640 --> 00:40:37,250
or delay when we were trying to page from page to page.

576
00:40:37,250 --> 00:40:42,760
So instead, we're going to not open the entire image
which means that in your own app, you would need some way

577
00:40:42,760 --> 00:40:46,870
to have access up front to the sizes of
the content that you're going to display.

578
00:40:46,870 --> 00:40:51,010
So I'm going to show you where
this change needs to take place.

579
00:40:51,010 --> 00:40:55,820
It's in this configurePage-forIndex method
that I keep calling, but I haven't shown you yet.

580
00:40:55,820 --> 00:40:58,200
So, let's scroll down to that method now.

581
00:40:58,200 --> 00:40:59,030
Here it is.

582
00:40:59,030 --> 00:41:00,010
It doesn't do much.

583
00:41:00,010 --> 00:41:05,750
It sets the index of the page which we used
if you remember for the subview tiling.

584
00:41:05,750 --> 00:41:10,870
It sets the frame for the page and it tells
the page to display an image which it looks

585
00:41:10,870 --> 00:41:13,610
up with this convenience imageAtIndex method.

586
00:41:13,610 --> 00:41:18,350
So this is the line we need to get rid of because we
don't want to be opening that whole image anymore instead,

587
00:41:18,350 --> 00:41:26,010
we're going to tell our page to display a tiled image
named something and it's going to use this name to figure

588
00:41:26,010 --> 00:41:32,120
out which tiles to load and we're also going to tell it
the size which I've added as metadata in this project

589
00:41:32,120 --> 00:41:36,670
because it's going to need to set the content size
on the scroll view and it's also going to need

590
00:41:36,670 --> 00:41:41,220
to correctly size our tiling view using that size.

591
00:41:41,220 --> 00:41:50,210
OK, so now with that done, we can switch over to
this tiling view implementation and we're going

592
00:41:50,210 --> 00:41:52,890
to do the steps that Josh already told you about.

593
00:41:52,890 --> 00:41:58,790
So first, we need to override the layer class method
to return a CATiledLayer so that this view is now going

594
00:41:58,790 --> 00:42:04,090
to be backed by a special CATiledLayer
rather than a regular CALayer.

595
00:42:04,090 --> 00:42:10,630
We also need to tell our view-- rather, tell the
TiledLayer in question how many levels of detail to display.

596
00:42:10,630 --> 00:42:14,330
So for that, I'm going to override initWithFrame.

597
00:42:14,330 --> 00:42:21,250
And in initWithFrame, I'm now going to grab the tiled layer
by asking for my own views layer property and I'm going

598
00:42:21,250 --> 00:42:23,820
to set the levels of-- the levels of detail to 4.

599
00:42:23,820 --> 00:42:29,510
Now what that means, is we're going to be asked in our
drawRect to draw at potentially four different scales.

600
00:42:29,510 --> 00:42:31,590
Each one is half the previous ones.

601
00:42:31,590 --> 00:42:35,700
So that the maximum scale is going to be
100 percent then we're going to get asked

602
00:42:35,700 --> 00:42:39,480
for 50 percent, 25 percent, and 12-1/2 percent tiles.

603
00:42:39,480 --> 00:42:43,240
And in fact, these images are so large
that you'll see that we only are going

604
00:42:43,240 --> 00:42:48,490
to need the 12-1/2 percent tiles for
quite a while as we first view them.

605
00:42:48,490 --> 00:42:53,120
So what is the drawRect look like?

606
00:42:53,120 --> 00:43:01,970
Alright so the first thing we're going to do is figure out
what is the scale that were currently being asked to draw at

607
00:43:01,970 --> 00:43:03,700
and I'm going to do that the way that Josh explained.

608
00:43:03,700 --> 00:43:10,310
We're going to get our current graphics context and
we're going to grab the scale out of that current context

609
00:43:10,310 --> 00:43:18,130
by getting the current transform matrix and
asking that transform for its A component.

610
00:43:18,130 --> 00:43:20,160
Alright, so now, we have our scale.

611
00:43:20,160 --> 00:43:24,100
We're also going to need-- in order to
figure out which tiles we need to draw

612
00:43:24,100 --> 00:43:26,320
in order to fill the rect that we've been passed.

613
00:43:26,320 --> 00:43:28,780
We're going to need to know how big the tiles are.

614
00:43:28,780 --> 00:43:31,400
And that's a property on CATiledLayer.

615
00:43:31,400 --> 00:43:37,000
So I will get my CATiledLayer and
I'll ask it for its tile size.

616
00:43:37,000 --> 00:43:40,550
Alright, so now comes the part that's perhaps the weirdest.

617
00:43:40,550 --> 00:43:47,990
It's not going to be good enough to use this tile size
as is because if we we're being asked to draw a scaled

618
00:43:47,990 --> 00:43:54,770
down version of our tiles, we need to adjust for the--
for the scale when we think about how big our tiles are.

619
00:43:54,770 --> 00:43:59,290
And the reason for that is what Josh explained
but I'll just talk about it briefly again.

620
00:43:59,290 --> 00:44:04,230
If we're being asked to draw at, say, the 50
percent scale, we still need to stretch those tiles

621
00:44:04,230 --> 00:44:07,820
out to fill the entire region of the original image.

622
00:44:07,820 --> 00:44:13,040
So although our tiles have less information in
them, we're going to stretch them out to be bigger

623
00:44:13,040 --> 00:44:15,510
than they really are to fill that full region.

624
00:44:15,510 --> 00:44:20,500
So we need to compensate for our
scale by adjusting our tile size.

625
00:44:20,500 --> 00:44:25,070
And we're going to do that by dividing
both the width and the height by the scale.

626
00:44:25,070 --> 00:44:31,410
So we're going to pretend that our tile size is
bigger as we get to smaller and smaller scales.

627
00:44:31,410 --> 00:44:39,640
So, alright, now that we've got our adjusted tile size, we
need to first figure out which of these tiles do we need

628
00:44:39,640 --> 00:44:42,100
in order to fill this rectangle that we've been passed.

629
00:44:42,100 --> 00:44:44,750
So this is again the same math that I did before.

630
00:44:44,750 --> 00:44:50,200
We're going to look at the rectangle that we need and we're
going to look at the top and bottom and left and right rows

631
00:44:50,200 --> 00:44:54,900
and columns of pixels and we're going to figure out which
tiles those are associated with and then we're going

632
00:44:54,900 --> 00:44:59,310
to iterate through the rows that we need
and draw all of the tiles that we need.

633
00:44:59,310 --> 00:45:04,060
So block of math calculating the
first column that we need of tiles

634
00:45:04,060 --> 00:45:09,370
and the last column and the first row and the last row.

635
00:45:09,370 --> 00:45:15,400
And now, we're just going to-- for each tile that
we need-- so for each row and within each row,

636
00:45:15,400 --> 00:45:19,780
for each column, we're going to draw that tile.

637
00:45:19,780 --> 00:45:22,950
OK, so I've got a convenience method
which will grab us the tile.

638
00:45:22,950 --> 00:45:27,900
What it does is it just looks at the scale, the row, and
the column and I've got a naming convention for my tiles

639
00:45:27,900 --> 00:45:36,050
that are saved as images here that will
grab us the right one for that purpose.

640
00:45:36,050 --> 00:45:41,140
Next, we need to calculate the rectangle that
we're going to use to draw this tile into.

641
00:45:41,140 --> 00:45:53,220
So the origin of the rectangle is just going to be the
column times the width of our adjusted tile size by the row

642
00:45:53,220 --> 00:45:55,380
that we're on times the height of the tile size.

643
00:45:55,380 --> 00:46:00,690
So we're going to move over and down by the appropriate
amount given what column and row that we're on.

644
00:46:00,690 --> 00:46:05,620
And the size of our rectangle is going
to just be the size of our tiles,

645
00:46:05,620 --> 00:46:12,010
but adjusted once again for the scale that we're drawing at.

646
00:46:12,010 --> 00:46:15,120
Alright, there's one caveat.

647
00:46:15,120 --> 00:46:17,230
This is going to cause some problems.

648
00:46:17,230 --> 00:46:19,650
Let me just show you a couple of these tiles.

649
00:46:19,650 --> 00:46:23,390
So, most of the tiles-- here's a
good example of our 12-1/2 percent.

650
00:46:23,390 --> 00:46:27,470
Here's a piece of a frog taking up a full tile.

651
00:46:27,470 --> 00:46:32,940
But the tile underneath this is actually only
a partial tile and the reason for that is just

652
00:46:32,940 --> 00:46:37,460
that my image is very unlikely to be
an exact multiple of my tile size.

653
00:46:37,460 --> 00:46:39,820
So you're always going to have at the bottom

654
00:46:39,820 --> 00:46:44,410
and at the right edge some partial tiles
that you don't want to stretch out.

655
00:46:44,410 --> 00:46:48,170
So if I were to draw going back to the code here.

656
00:46:48,170 --> 00:46:52,110
If I were to draw that partial tile
into the rectangle that I just computed,

657
00:46:52,110 --> 00:46:56,260
it would be stretched to fill the
entire square and it would look weird.

658
00:46:56,260 --> 00:46:59,190
It would look like your image was
kind of bleeding off at the edges.

659
00:46:59,190 --> 00:47:01,190
So we need to compensate for that.

660
00:47:01,190 --> 00:47:04,590
And we're going to do this by checking--
we kind of want to check,

661
00:47:04,590 --> 00:47:08,250
is the rectangle that we just computed,
is it going off of our bounds?

662
00:47:08,250 --> 00:47:09,520
Is it outside of our bounds?

663
00:47:09,520 --> 00:47:13,850
And if it is, then we need to truncate
it so that it stays within our bounds.

664
00:47:13,850 --> 00:47:19,330
And we can actually do that with one line of code just
by taking the rectangle intersection of our bounds

665
00:47:19,330 --> 00:47:21,670
and the tile rect that we're about to draw.

666
00:47:21,670 --> 00:47:24,750
So then we can just go ahead.

667
00:47:24,750 --> 00:47:28,800
Draw our tile and this is all you would really need to do.

668
00:47:28,800 --> 00:47:33,820
For demonstration purposes I'm going to add some
white lines over the tiles so that when I build this,

669
00:47:33,820 --> 00:47:37,520
you'll be able to see when we change
from one tile size to the next.

670
00:47:37,520 --> 00:47:42,360
So there are just a couple of lines that draw
white border around the tile that we just drew.

671
00:47:42,360 --> 00:47:49,850
OK, so let me just go ahead and run this.

672
00:47:49,850 --> 00:47:54,890
Alright, so we've got-- what we're
seeing here is the 12-1/2 percent scale.

673
00:47:54,890 --> 00:48:02,590
And you can see that you only need a total of actually four
tiles in order to draw the entire 12-1/2 percent image.

674
00:48:02,590 --> 00:48:11,560
As I zoom in, it razzed up to 25 percent and then as
I continue to zoom in, we get the 50 percent tiles,

675
00:48:11,560 --> 00:48:15,290
and finally we-- the 100 percent
tiles, look how big these images are.

676
00:48:15,290 --> 00:48:17,810
So here's the level of detail that we've got.

677
00:48:17,810 --> 00:48:23,270
You can see that at a 100 percent, this image
is huge and if you can imagine the entire image,

678
00:48:23,270 --> 00:48:27,360
how many of these 100 percent tiles are needed
to make-- to construct the entire image?

679
00:48:27,360 --> 00:48:31,090
That was what we were loading in the
previous version before we started tiling.

680
00:48:31,090 --> 00:48:34,990
We were loading all of the 100 percent
tiles in the form of one image.

681
00:48:34,990 --> 00:48:39,940
And then we were scaling that down to fit
the screen which was extraordinarily wasteful

682
00:48:39,940 --> 00:48:42,810
and that's why we were using so much memory.

683
00:48:42,810 --> 00:48:47,190
So let me just test this by scrolling around.

684
00:48:47,190 --> 00:48:48,700
I can scroll really fast.

685
00:48:48,700 --> 00:48:54,610
I can zoom in again and my center
ring still works even if I zoom out.

686
00:48:54,610 --> 00:48:57,770
So how much memory are we using now?

687
00:48:57,770 --> 00:49:04,650
Switch back to the activity monitor
and I'll just zoom in on that.

688
00:49:04,650 --> 00:49:14,060
A total of 16 megabytes of real memory [background
applause] even though I've zoomed in and out a ton.

689
00:49:14,060 --> 00:49:17,290
[Applause] Great. And that's all there is to it, so back to Josh.

690
00:49:17,290 --> 00:49:23,490
[ Applause ]

691
00:49:23,490 --> 00:49:24,520
>> Josh Shaffer: I got it.

692
00:49:24,520 --> 00:49:26,510
Alright, thanks Eliza.

693
00:49:26,510 --> 00:49:28,980
So that's pretty much there is to it, right?

694
00:49:28,980 --> 00:49:33,080
[Laughter] Simple, it's five lines of code.

695
00:49:33,080 --> 00:49:38,210
>> Josh Shaffer: Sample code is
available either now or soon after.

696
00:49:38,210 --> 00:49:43,380
It's already been gone through and will be up on the web,
available for download and also associated with the session

697
00:49:43,380 --> 00:49:45,420
through the developer-- WWDC, attendee site.

698
00:49:45,420 --> 00:49:51,140
If you have any other questions, Bill Dudney
is the Application Frameworks Evangelist.

699
00:49:51,140 --> 00:49:56,790
It's a long URL but UIScrollView has a whole class
reference that has all kinds of additional information

700
00:49:56,790 --> 00:50:01,030
about scroll view, and of course,
the Apple Developer Forums.

701
00:50:01,030 --> 00:50:04,540
There are a couple of related sessions later this week.

702
00:50:04,540 --> 00:50:10,700
If you're interested in how the photos
application does detection of taps and double taps

703
00:50:10,700 --> 00:50:13,870
and two-finger taps to do zooming in and out on images.

704
00:50:13,870 --> 00:50:18,900
There's a whole new framework for
doing it in iPhone OS 3.2 and 4.0.

705
00:50:18,900 --> 00:50:23,970
And that's the-- We're going to talk about in a Simplifying
Touch Event Handling with Gesture Recognizer session.

706
00:50:23,970 --> 00:50:26,530
And also, if you want more information about table views

707
00:50:26,530 --> 00:50:29,470
and how you can display just those
vertically scrolling bits of content.

708
00:50:29,470 --> 00:50:33,580
The Mastering Table View session is on Thursday at 11:30.

709
00:50:33,580 --> 00:50:34,930
Both of those are here.

710
00:50:34,930 --> 00:50:38,650
The Gesture Recognizer is tomorrow at 3:15.

711
00:50:38,650 --> 00:50:39,750
So that's about it.

712
00:50:39,750 --> 00:50:43,670
The only thing I'd like to say is, you
really don't have to write your own.

713
00:50:43,670 --> 00:50:45,400
You don't have to go looking for third party frameworks.

714
00:50:45,400 --> 00:50:48,900
You don't have to start from scratch with UIView.

715
00:50:48,900 --> 00:50:50,040
That's all.

716
00:50:50,040 --> 00:50:51,540
So, thanks a lot.

