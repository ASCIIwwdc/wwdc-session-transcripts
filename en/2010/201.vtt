WEBVTT

00:00:09.450 --> 00:00:15.490
>> This morning we're going to talk to you about
the many opportunities that iPhone OS provides

00:00:15.490 --> 00:00:19.320
for connecting applications to accessories.

00:00:19.320 --> 00:00:28.870
We're also going to specifically point out
the new opportunities that you have in iOS 4.

00:00:28.870 --> 00:00:33.880
There are three ways that accessories
can connect to iPhone OS devices.

00:00:33.880 --> 00:00:40.880
They can use the 30-pin dock connector,
Bluetooth, and Wi-Fi.

00:00:40.880 --> 00:00:47.750
Your application sits on the iPhone OS, and has
access to frameworks and services offered by that OS

00:00:47.750 --> 00:00:52.220
such as the External Accessory framework and Audio Services.

00:00:52.220 --> 00:01:02.850
Accessories then connect through the hardware interfaces,
the 30-pin with includes UART and USB, Bluetooth, and Wi-Fi.

00:01:02.850 --> 00:01:11.910
Over the 30-pin, the iPod Accessory Protocol
or iAP is used to communicate with the OS.

00:01:11.910 --> 00:01:15.390
iAP can also be used over Bluetooth.

00:01:15.390 --> 00:01:22.270
And then of course, over Bluetooth, we
also offer standard Bluetooth profiles.

00:01:22.270 --> 00:01:27.670
Because Wi-Fi, excuse me, uses
TCP/IP and standard network services,

00:01:27.670 --> 00:01:30.720
we won't be covering Wi-Fi in detail in this session.

00:01:30.720 --> 00:01:35.940
But there is a session on Bonjour that you
can attend if you're interested in that.

00:01:35.940 --> 00:01:43.930
I'm going to start by talking about the 30-pin and those
hardware interfaces, and then talk about iAP in some detail.

00:01:43.930 --> 00:01:49.390
Brian is then going to come up and
talk to you more about Bluetooth

00:01:49.390 --> 00:01:53.540
on iPhone OS devices and the profiles that we support.

00:01:53.540 --> 00:02:00.760
And then Paul is going to wrap up at the end and talk
in some detail about the External Accessory framework.

00:02:00.760 --> 00:02:07.700
I know that we have a lot of application developers in the
audience, and I know we also have some accessory developers.

00:02:07.700 --> 00:02:10.460
There are some of you overachievers that do both.

00:02:10.460 --> 00:02:12.910
We're going to have the information for all of you today.

00:02:12.910 --> 00:02:16.980
We'll try to be specific about who
we're talking to at which point.

00:02:16.980 --> 00:02:21.760
But again, this is information for both
accessory developers and application developers.

00:02:21.760 --> 00:02:25.430
So, first, the dock connector.

00:02:25.430 --> 00:02:31.770
The dock connector has been standard on iPod since 2003.

00:02:31.770 --> 00:02:34.840
We sold a lot, a lot of iPods with dock connectors.

00:02:34.840 --> 00:02:41.010
It's also on every iPhone, iPod touch, and iPad.

00:02:41.010 --> 00:02:51.230
The available interfaces on that 30-pin are UART and USB
as I explained for communication, and actually, on USB,

00:02:51.230 --> 00:02:56.540
the iPod or the iPhone OS device
can be a USB host or a USB device.

00:02:56.540 --> 00:03:02.310
We also offer, of course, audio and
video hardware interfaces and power.

00:03:02.310 --> 00:03:06.080
Accessories can charge the iPhone OS device.

00:03:06.080 --> 00:03:13.700
So, they can charge it and give it power to run off
of or they can be charged by the iPhone OS device.

00:03:13.700 --> 00:03:18.160
So, an accessory that doesn't have its own power source.

00:03:18.160 --> 00:03:25.340
For example, an FM transmitter or some other small
dongle like maybe a blood glucose monitor, they can get--

00:03:25.340 --> 00:03:28.880
those accessories can get power from the iPhone OS device.

00:03:28.880 --> 00:03:35.080
For those of you who might be new to accessory development
and who are interested in accessory development,

00:03:35.080 --> 00:03:42.220
we do have several reference designs available from some
of the MFi partners that can help to get you started.

00:03:42.220 --> 00:03:47.890
Now, I'm going to talk a little bit
about the iPod Accessory Protocol or iAP.

00:03:47.890 --> 00:03:58.430
iAP was put in place to allow accessories to
communicate with and control the iPhone OS device.

00:03:58.430 --> 00:04:03.370
I'm going to talk about the-- about iAP at
a high level and about some of the features

00:04:03.370 --> 00:04:06.490
that I think might be interesting for this audience.

00:04:06.490 --> 00:04:13.860
But the full details, all hundreds and hundreds of pages
of stack of it, are available through the MFi program.

00:04:13.860 --> 00:04:19.030
And if you are interested in learning about joining
the MFi program, we have a lab session this afternoon,

00:04:19.030 --> 00:04:21.890
and there'll be a lot of MFi representatives
there who can help you.

00:04:21.890 --> 00:04:31.980
So first, I'm going to talk about standard features that
you can use to communicate or that accessories can use

00:04:31.980 --> 00:04:37.740
to communicate with iPhone OS devices that
then make data available to your apps.

00:04:37.740 --> 00:04:45.460
These are-- these include: Audio, Video,
Location information, and then some new things

00:04:45.460 --> 00:04:51.330
for iOS 4 including Multimedia remote
control, Keyboards, and Accessibility.

00:04:51.330 --> 00:04:58.620
Then I'll talk about the possibility of sending
custom protocols over iAP so that an app

00:04:58.620 --> 00:05:03.760
and an accessory can communicate
arbitrary data between themselves.

00:05:03.760 --> 00:05:08.060
And we'll talk more about that at the end.

00:05:08.060 --> 00:05:08.560
So first, audio.

00:05:08.560 --> 00:05:21.570
Audio is routed to and from your application, to and from
your accessory via the most appropriate path by Core Audio.

00:05:21.570 --> 00:05:25.350
There are several hardware interfaces available for audio.

00:05:25.350 --> 00:05:26.240
They're listed here.

00:05:26.240 --> 00:05:30.580
You can see that there are analog and
digital forms for both input and output.

00:05:30.580 --> 00:05:40.490
I thought you might be interested in seeing
which devices support which audio interfaces.

00:05:40.490 --> 00:05:41.740
They're listed here.

00:05:41.740 --> 00:05:48.050
You can see that line out and the headset and USB
audio out are supported on all of our platforms.

00:05:48.050 --> 00:05:54.120
And the Bluetooth audio was added with the 2nd
generation iPod touch and with the iPhone 3G.

00:05:54.120 --> 00:05:58.530
Audio input is in a bit of a transition right now.

00:05:58.530 --> 00:06:01.620
So, some of our devices supported analog line in.

00:06:01.620 --> 00:06:07.190
So all of the iPod touches do and
iPhone through the iPhone 3GS.

00:06:07.190 --> 00:06:12.440
iPhone 4, however, does not support an
analog line in and neither does iPad.

00:06:12.440 --> 00:06:18.110
Those two devices support USB audio
in and digital audio input path.

00:06:18.110 --> 00:06:24.900
And we were able to get that feature back also
into 3rd generation iPod touch and the 3GS iPhone.

00:06:24.900 --> 00:06:36.150
We've had some exciting developments in the
video space with iPhone OS 3.2 and iOS 4.

00:06:36.150 --> 00:06:43.570
We have the possibility for applications
to send video to an external display.

00:06:43.570 --> 00:06:47.710
I think this creates a whole lot of opportunities for you.

00:06:47.710 --> 00:06:54.480
The applications to find out about attached
displays including the bounding rectangle,

00:06:54.480 --> 00:07:00.110
whether they have been attached and
when they're detached via UI screen.

00:07:00.110 --> 00:07:07.120
And really thinking about it, I think there are a lot of
things that applications might want to do when attached

00:07:07.120 --> 00:07:15.060
to a large monitor such as the television, perhaps,
to other monitors and cars and airplanes, you name it.

00:07:15.060 --> 00:07:21.410
So, here are the hardware interfaces
that are supported on iPhone OS devices.

00:07:21.410 --> 00:07:27.800
You can see that analog is supported on all the
devices including composite, S Video and component,

00:07:27.800 --> 00:07:35.250
and that we also are able to send video out
through our VGA Adapter on iPhone 4 and on iPad.

00:07:35.250 --> 00:07:43.320
Now, I'm going to talk a little bit about location.

00:07:43.320 --> 00:07:49.760
Accessories can communicate with iPhone OS
devices and provide them location information.

00:07:49.760 --> 00:07:59.440
So, you can imagine a car or a GPS puck like
a Bluetooth puck or a GPS hand-held device

00:07:59.440 --> 00:08:04.650
that might have nice big GPS antenna,
can provide very valuable,

00:08:04.650 --> 00:08:10.960
very accurate GPS information and
heading to an iPhone OS device.

00:08:10.960 --> 00:08:12.900
This includes an iPod touch.

00:08:12.900 --> 00:08:19.160
So, what that means for you as an app developer is that
your app shouldn't rely on the fact that you're running

00:08:19.160 --> 00:08:22.740
on an iPod touch and not use location services.

00:08:22.740 --> 00:08:24.680
These accessories are getting more popular.

00:08:24.680 --> 00:08:29.600
We're very excited to see what
developers are getting into the market.

00:08:29.600 --> 00:08:38.540
And your device very might-- very may well have an attached
accessory that allows it to have location information.

00:08:41.810 --> 00:08:50.080
New for iPhone OS 4 is the ability for your app
to receive multimedia remote control commands

00:08:50.080 --> 00:08:53.710
such as play and pause, next and previous.

00:08:53.710 --> 00:09:00.480
These commands previously were reserved for only the
iPod application, but now, if you have a multimedia app

00:09:00.480 --> 00:09:04.750
that registers for these commands,
you can also receive these commands

00:09:04.750 --> 00:09:07.820
from standard accessories that are already in the field.

00:09:07.820 --> 00:09:10.230
Of course, new accessories as well.

00:09:10.230 --> 00:09:18.960
So, again, speaker docks, cars, and a very popular
accessory, the headphone remote and mic system

00:09:18.960 --> 00:09:25.440
that so many people own already, sends these next and
previous commands and they can go straight to your app.

00:09:25.440 --> 00:09:30.750
So, you can imagine listening to music in your app
and having a user just be able to use their headset

00:09:30.750 --> 00:09:35.470
to press pause and having the music pause in your app.

00:09:35.470 --> 00:09:37.310
I think this is a great addition.

00:09:37.310 --> 00:09:43.540
And I'm excited to see a lot of apps develop
or, sorry, support this API in the near future.

00:09:43.540 --> 00:09:49.270
Next are keyboards.

00:09:49.270 --> 00:09:54.560
With iPhone OS 4, we expect to see a lot
of new keyboards, both 30-pin keyboards

00:09:54.560 --> 00:09:58.840
and standard Bluetooth keyboards in the market.

00:09:58.840 --> 00:10:03.870
For application developers, this
doesn't mean much at the surface.

00:10:03.870 --> 00:10:08.050
You're still going to get keyboard events
the same way that you've gotten them before.

00:10:08.050 --> 00:10:12.870
Now, you'll get UIKeyInput and UITextInput events.

00:10:12.870 --> 00:10:16.860
So, it doesn't mean that you'll get a new
kind of event, but what it does mean is

00:10:16.860 --> 00:10:22.160
that accessory developers might be coming up with
some great new form factors for keyboards or keyboards

00:10:22.160 --> 00:10:27.470
that are especially suited for particular
applications or particular use cases.

00:10:27.470 --> 00:10:35.510
I look forward to you guys using your imaginations
on this one and seeing what you can come up with.

00:10:35.510 --> 00:10:37.450
I'm excited to talk about accessibility.

00:10:37.450 --> 00:10:43.150
We just had some discussion of accessibility
in this session right before this one.

00:10:43.150 --> 00:10:49.530
Accessories can now leverage VoiceOver
technology to communicate with the phone

00:10:49.530 --> 00:10:53.420
and completely control the iPhone OS device.

00:10:53.420 --> 00:11:02.200
They can send commands such as moving to a particular X,Y
coordinates or moving to the next or previous UI element.

00:11:02.200 --> 00:11:07.440
And they can send those commands remotely,
and VoiceOver will perform those actions,

00:11:07.440 --> 00:11:12.460
and of course, use VoiceOver to provide feedback.

00:11:12.460 --> 00:11:21.440
This is exciting because you can imagine an accessory like
a joystick or a trackpad that sends these commands remote

00:11:21.440 --> 00:11:25.290
from the device, and then the device responds appropriately.

00:11:25.290 --> 00:11:31.660
Especially coupled with the video output
capability of apps, I think that there's a lot here.

00:11:31.660 --> 00:11:40.110
This is revolutionary for our users that can't see
or don't have the dexterity to manipulate the device.

00:11:40.110 --> 00:11:45.570
But I think that there are a lot of opportunities outside
of the traditional accessibility space with this feature.

00:11:45.570 --> 00:11:48.460
Now, what can you as an app developer do?

00:11:48.460 --> 00:11:51.620
You can make sure that your app is accessible.

00:11:51.620 --> 00:11:55.420
So, this means using the UIAccessibility API.

00:11:55.420 --> 00:12:02.980
For most of you, all that means is you need to fill-in a
few missing labels for UI elements that you might have.

00:12:02.980 --> 00:12:04.990
This should be a fairly easy task.

00:12:04.990 --> 00:12:14.280
And then whatever accessibility accessories come to
market, your app will automatically work with them.

00:12:14.280 --> 00:12:18.060
Now, we're going to move on to custom protocols over iAP.

00:12:18.060 --> 00:12:27.800
In the iPhone OS 4, we introduced the opportunity for apps
and accessories to communicate directly with each other,

00:12:27.800 --> 00:12:32.320
again, to send arbitrary data between the app and accessory.

00:12:32.320 --> 00:12:41.740
New to iPhone OS 4 is the possibility for
multiple apps to talk to the same accessory

00:12:41.740 --> 00:12:45.640
or multiple accessories to talk to the same apps.

00:12:45.640 --> 00:12:48.750
We've got this request a lot of times,
and we're really excited about it.

00:12:48.750 --> 00:12:57.140
We think that there will be a lot of new innovation in this
space as you guys mix it up in the app and accessory worlds.

00:12:58.290 --> 00:13:06.180
There's also the possibility under a very limited
circumstances for an accessory to launch an application.

00:13:06.180 --> 00:13:14.170
You can imagine a specific, you know, blood pressure cuff
or something that gets plugged into an iPhone OS device.

00:13:14.170 --> 00:13:18.350
And the reason it's getting plugged in is
because the user wants to use it immediately.

00:13:18.350 --> 00:13:21.730
So, it's appropriate for an app to be launched.

00:13:21.730 --> 00:13:26.890
And I think that this is very help-- can be very helpful
for the user and eliminates some steps especially

00:13:26.890 --> 00:13:30.830
for those who have a lot of apps on their device.

00:13:30.830 --> 00:13:38.890
Last feature is the capability for an accessory to
declare that it doesn't need an application to function.

00:13:38.890 --> 00:13:44.920
So, we don't pester users by asking them if they would
want to go to the app store too many times, if in fact,

00:13:44.920 --> 00:13:48.950
your accessory works well without an application.

00:13:48.950 --> 00:13:53.460
Now, Paul is going to talk in detail
about these custom protocols over iAP

00:13:53.460 --> 00:14:00.890
and what we call the External Accessory framework
in iPhone OS that allows these protocols to work.

00:14:00.890 --> 00:14:07.610
And he'll talk about them in a lot more
detail in the third section of this session.

00:14:07.610 --> 00:14:17.260
So, in summary, we've added a lot of features for you
to iOS 4 to allow accessories and apps to communicate.

00:14:17.260 --> 00:14:23.660
We're excited in particular about multimedia
remote control for multimedia applications.

00:14:23.660 --> 00:14:27.780
We're excited about seeing new form
factors of keyboards, 30-pin keyboards,

00:14:27.780 --> 00:14:31.850
and Bluetooth keyboards that your app can then use.

00:14:31.850 --> 00:14:35.960
We're definitely looking forward to seeing what happens

00:14:35.960 --> 00:14:39.410
in this accessibility space which
I think is wide open right now.

00:14:39.410 --> 00:14:42.870
And we have several new features for you in what has proven

00:14:42.870 --> 00:14:47.970
to be a very popular area of using
custom protocols over iAP.

00:14:47.970 --> 00:14:52.990
So with that, I'm going-- well,
first, I guess, mention reference--

00:14:52.990 --> 00:14:55.940
some sessions that might be of interest to you guys.

00:14:55.940 --> 00:15:01.330
If you were interested in some of the specific
technologies that I talked about, first for Wi-Fi,

00:15:01.330 --> 00:15:06.360
next for accessibility, and then the third one, if
you're interested in learning more about Core Audio.

00:15:06.360 --> 00:15:15.510
I'll now hand over to Brian Tucker who's
going to talk about Bluetooth on iPhone OS.

00:15:15.510 --> 00:15:20.050
[ Applause ]

00:15:20.050 --> 00:15:20.310
>> Good job.

00:15:20.310 --> 00:15:26.850
So, I'm Brian Tucker, and I'm the Senior Engineering
Manager for Bluetooth Technologies on all iOS platforms.

00:15:26.850 --> 00:15:31.820
That includes iPod, iPhone, and of course, the iPad.

00:15:31.820 --> 00:15:34.900
So, what are we going to get out of this session?

00:15:34.900 --> 00:15:41.210
Well, fundamentally, two groups hopefully
will benefit from these 20 minutes or so.

00:15:41.210 --> 00:15:42.990
First is accessory manufacturers.

00:15:42.990 --> 00:15:48.800
Obviously, Bluetooth is really not very interesting
if we don't communicate with the particular accessory.

00:15:48.800 --> 00:15:50.830
And then application developers.

00:15:50.830 --> 00:15:55.740
So, we have some technologies in the iOS
platform that give you the ability to communicate

00:15:55.740 --> 00:15:58.750
with your accessory directly or with another iPhone.

00:15:58.750 --> 00:16:00.350
So, for example, GameKit.

00:16:00.350 --> 00:16:05.770
We're going to talk about some things that you can do to
improve, hopefully, your game and the network throughput

00:16:05.770 --> 00:16:09.380
that you're getting in your game in these 20 minutes.

00:16:09.380 --> 00:16:16.050
So, kind of briefly talked about this, but we're going to
talk a little bit about the OS implementation of Bluetooth,

00:16:16.050 --> 00:16:22.220
and then I have some tips and tricks relating to
a few areas where hopefully it will benefit you

00:16:22.220 --> 00:16:26.250
as the accessory manufacturer or
as an application developer.

00:16:26.250 --> 00:16:30.860
And ultimately, I think the big point
here is that we as a community have

00:16:30.860 --> 00:16:35.340
to come together both the accessory
manufacturer, application developer,

00:16:35.340 --> 00:16:39.440
and within our engineering group to
create great Bluetooth platforms.

00:16:39.440 --> 00:16:46.390
We're only so good as the product that we're interacting
with or the customers interacting with at a particular time.

00:16:46.390 --> 00:16:47.420
So, we need to work together.

00:16:47.420 --> 00:16:52.390
So, what are we going to be covering today?

00:16:52.390 --> 00:16:56.370
So first off, I'm going to cover what's
new in the iPhone OS 4, specifically,

00:16:56.370 --> 00:16:59.660
I'll go through a few of the key
things that we're excited about.

00:16:59.660 --> 00:17:05.790
Then I'm going to give you kind of the state
of the union of what we have in iOS 4 for now.

00:17:05.790 --> 00:17:07.790
And then we'll go into my tips and tricks.

00:17:07.790 --> 00:17:15.450
And I have three things that we'll be covering
specifically with general Bluetooth, with GameKit,

00:17:15.450 --> 00:17:19.200
and with some coexistence discussions,
and we'll get into that more.

00:17:19.200 --> 00:17:20.360
So, what's new with iOS?

00:17:20.360 --> 00:17:21.990
So, Emily mentioned keyboards.

00:17:21.990 --> 00:17:25.640
And of course, we've added HID keyboards with iPad.

00:17:25.640 --> 00:17:31.410
But now with iOS, pretty much with any iOS
application, we support Bluetooth keyboards.

00:17:31.410 --> 00:17:34.220
And this is using HID, the HID profile.

00:17:34.220 --> 00:17:40.950
And pretty much anything you can do with the HID
keyboard you can do with an iOS piece of hardware.

00:17:42.130 --> 00:17:46.900
So, last year, we introduced A2DP or
Advanced Audio Distribution Profile.

00:17:46.900 --> 00:17:52.340
And this was the ability for you to stream
audio to an accessory, a car or a headset.

00:17:52.340 --> 00:17:58.670
Now, when you do A2DP, you have to do
a codec called SBC or Subband Coded.

00:17:58.670 --> 00:18:00.180
And it's OK.

00:18:00.180 --> 00:18:07.230
But to get a really decent audio quality, it takes about
330 kbps data rate in order to achieve an audio quality

00:18:07.230 --> 00:18:11.330
that we feel is acceptable for the customer.

00:18:11.330 --> 00:18:16.320
So, we thought, well, how do we implement a better
implementation that gives a lower throughput usage,

00:18:16.320 --> 00:18:23.050
better coexistence model, better power consumption
footprint, and we're using AAC for this.

00:18:23.050 --> 00:18:28.470
So, with iOS 4.0, we're now providing
an endpoint that does AAC encoding.

00:18:28.470 --> 00:18:37.120
And as you can see here, it's a 44.1 encoding, 128 kbps,
and it is VBR, so we can update data rate dynamically,

00:18:37.120 --> 00:18:41.950
and we will update that data rate
dynamically depending upon coexistence.

00:18:41.950 --> 00:18:44.520
We've also added voice commands over Bluetooth.

00:18:44.520 --> 00:18:52.890
Now, we kind of had this in the past with
the Bluetooth voice activation command.

00:18:52.890 --> 00:19:00.720
But with iOS 4.0, we're now providing a way for you to press
the Home button on your device and start the voice command,

00:19:00.720 --> 00:19:06.900
and if you're connected to a device that doesn't necessarily
support voice commands, we'll go ahead and enable that,

00:19:06.900 --> 00:19:10.660
and we do some trickery on the phone
to enable the voice commanding car kits

00:19:10.660 --> 00:19:13.310
that wouldn't necessarily be able to do this.

00:19:13.310 --> 00:19:15.290
We've added in-band ringtones.

00:19:15.290 --> 00:19:19.760
So, that awesome industrial death metal
ringtone that you have on your phone,

00:19:19.760 --> 00:19:25.420
you can now hear in your car probably
when your mom's in the car.

00:19:25.420 --> 00:19:26.550
Braille keyboards.

00:19:26.550 --> 00:19:31.370
So, what's interesting about Braille keyboards
is they don't use HID, they're not a HID device.

00:19:31.370 --> 00:19:34.200
Typically, they're based on the Serial Port Profile or SPP.

00:19:34.200 --> 00:19:40.950
And we've implemented a Braille implementation on a
lot of the real popular, there's quite a few of them,

00:19:40.950 --> 00:19:44.430
but a lot of the popular Braille keyboards in the market.

00:19:44.430 --> 00:19:50.630
And we've added support for multiple handsfree and A2DP
devices to be connected simultaneously to the device.

00:19:50.630 --> 00:19:55.570
A kind of a cool factor here is that you can have
a headset in your ear, you can get into the car,

00:19:55.570 --> 00:20:00.860
the headset won't disconnect, the car will connect, and
now you can route automatically the audio between the two.

00:20:00.860 --> 00:20:05.740
If you want to have a private conversation, you can
have it in the car, or you can have it in your ear

00:20:05.740 --> 00:20:08.580
and you can have it in the car, and you're
still going to have to pick up the phone.

00:20:08.580 --> 00:20:10.700
For example, in California I hear that's illegal.

00:20:10.700 --> 00:20:13.860
So, this will allow, you know, I guess
the routing, you have to touch the phone,

00:20:13.860 --> 00:20:16.410
but you don't bring it up to your ear, so.

00:20:16.410 --> 00:20:17.640
iPhone volume control.

00:20:17.640 --> 00:20:23.120
So, this is kind of a minor thing, but this
is huge for some accessory manufacturers

00:20:23.120 --> 00:20:27.690
that do not have an industrial design
that allows for localized volume control.

00:20:27.690 --> 00:20:31.870
So that what this gives you is a slider, just
like you would see on any other accessory

00:20:31.870 --> 00:20:34.510
on the phone itself as well as the physical buttons.

00:20:34.510 --> 00:20:40.200
So, it allows you to control the volume of the
localized output game being sent to the accessory.

00:20:40.200 --> 00:20:46.130
So, if you have like a little desktop speaker, you
can now control the volume of that on the phone.

00:20:46.130 --> 00:20:51.440
Or headset, some headsets are so small that
just physically cannot have a volume control,

00:20:51.440 --> 00:20:53.940
you can now can do that on the phone.

00:20:53.940 --> 00:20:55.900
So, where are we at?

00:20:55.900 --> 00:20:59.140
So, here's the Bluetooth profiles that we have today.

00:20:59.140 --> 00:21:04.100
So, Hands-Free Profile, the Phone Book Access
Profile, which is how we sync phone books

00:21:04.100 --> 00:21:07.960
to your device, your car or your Bluetooth device.

00:21:07.960 --> 00:21:14.230
The Advanced Audio Distribution Profile, HID or the
Human Interface Device, Personal Area Networking,

00:21:14.230 --> 00:21:19.700
which is what we use for GameKit as well as
for tethering, and then the Device ID Profile.

00:21:19.700 --> 00:21:24.230
I want to go into a little bit
more about DID here in a minute.

00:21:24.230 --> 00:21:27.170
And then we have some custom protocols.

00:21:27.170 --> 00:21:29.160
Emily touched on iAP.

00:21:29.160 --> 00:21:36.670
And what's cool about iAP is it's essentially, it's the
entire iPod Accessory Protocol implementation, wireless.

00:21:36.670 --> 00:21:45.200
So, all of the advantages you get with iAP in terms
of browsing the content of the phone or album art

00:21:45.200 --> 00:21:48.430
or any of the other events so custom protocols, for example.

00:21:48.430 --> 00:21:55.310
We see some implementations where people are adding value
to their traditional hands-free device by implementing iAP

00:21:55.310 --> 00:21:59.330
and doing some really interesting things
with the phone or with applications

00:21:59.330 --> 00:22:01.590
on the phone to interact with their device.

00:22:01.590 --> 00:22:02.180
It's pretty cool.

00:22:02.180 --> 00:22:08.120
And up to this point, if we adjusted a basic interface,
we wouldn't be able to provide you with the ability

00:22:08.120 --> 00:22:11.410
to do things like bring up apps
and all those kind of things.

00:22:11.410 --> 00:22:14.270
So, that's iAP over Bluetooth.

00:22:14.270 --> 00:22:20.460
Alright. So, now, I'd like to go to three areas
where hopefully we can improve Bluetooth together.

00:22:20.460 --> 00:22:24.920
So, we're going to cover some general
overall Bluetooth improvements.

00:22:24.920 --> 00:22:27.580
We're going to go through GameKit and
some of the things that you can do

00:22:27.580 --> 00:22:30.320
in GameKit hopefully to improve your network throughput.

00:22:30.320 --> 00:22:33.260
And then we're going to talk about Wi-Fi Coexistence.

00:22:33.260 --> 00:22:37.250
And if you don't know what that
is, you will in about 10 minutes.

00:22:37.250 --> 00:22:40.120
So, let's go over overall Bluetooth improvements.

00:22:40.120 --> 00:22:46.810
So, first-off, right now we're at Bluetooth 2.1 plus EDR.

00:22:46.810 --> 00:22:51.650
We see a lot of devices that are being-- no,
this is specifically for accessory manufacturers.

00:22:51.650 --> 00:22:56.720
But we see a lot of devices that are
still being implemented at a 1.1 level

00:22:56.720 --> 00:23:01.470
or at a 2.0 level, but not implementing extended data rate.

00:23:01.470 --> 00:23:08.080
And so for us, to interact with those, because we're
having to coexist with Wi-Fi, and we're having to coexist

00:23:08.080 --> 00:23:13.350
with multiple profiles connected simultaneously
either to your device or to another device,

00:23:13.350 --> 00:23:17.650
if you're not implementing EDR, it doesn't
leave a whole of time for the radio

00:23:17.650 --> 00:23:20.750
to do anything else other than communicate with your device.

00:23:20.750 --> 00:23:22.240
Implement EDR.

00:23:22.240 --> 00:23:23.810
Support Secure Simple Pairing.

00:23:23.810 --> 00:23:28.830
So, with SSP, the user no longer has to enter a pin code.

00:23:28.830 --> 00:23:30.940
This is a huge thing, right?

00:23:30.940 --> 00:23:37.350
All they have to do is find your device, click on that
device to get a little confirmation that says do you want

00:23:37.350 --> 00:23:40.950
to pair with that device, they say
yes, and now they're authenticated.

00:23:40.950 --> 00:23:41.720
It's that simple.

00:23:41.720 --> 00:23:45.070
They don't have to go find the manual
and figure out what pin code to enter.

00:23:45.070 --> 00:23:47.240
It's also a lot more secure.

00:23:47.240 --> 00:23:50.320
It keeps man-in-the-middle attacks
from occurring, for example.

00:23:50.320 --> 00:23:55.760
And so for car kits especially, a lot of times the car
kit implementation is that it'll generate a pin code,

00:23:55.760 --> 00:23:59.830
and then the user has to go to the
phone and type in the 6-digit pin code.

00:23:59.830 --> 00:24:02.470
But with Secure Simple Pairing,
you don't have to do that anymore.

00:24:02.470 --> 00:24:03.910
Big, big thing.

00:24:03.910 --> 00:24:05.200
Extended Inquiry Response.

00:24:05.200 --> 00:24:11.490
So, with 2.1 we get EIR, we get
extended responses from accessories.

00:24:11.490 --> 00:24:15.430
Now, normally, you just provide us with your Mac address.

00:24:15.430 --> 00:24:20.610
But if you put your Friendly Name in the EIR, we
no longer have to go back and keep talking to you

00:24:20.610 --> 00:24:23.880
about what's your name, what are you
capable off, and those kinds of things.

00:24:23.880 --> 00:24:28.970
This is a big win for the phone because it
doesn't have to keep talking to your device

00:24:28.970 --> 00:24:31.650
and to the next device and to the next device.

00:24:31.650 --> 00:24:34.280
Implement Friendly Name in EIR.

00:24:34.280 --> 00:24:36.250
Device ID Profile.

00:24:36.250 --> 00:24:40.270
So, this is a profile that some
people do, some people don't do.

00:24:40.270 --> 00:24:43.440
I know that this is kind of a religious
debate in the Bluetooth SIG.

00:24:43.440 --> 00:24:49.500
But we implement DID, which means that when you
connect to the phone, in the SDP inquiry response,

00:24:49.500 --> 00:24:51.910
we can tell you what you're connected to.

00:24:51.910 --> 00:24:56.910
We'll tell you the name of the device, we'll tell
you the version, we'll tell you the hardware version,

00:24:56.910 --> 00:25:02.120
so that you can add value to your products
that's based on what you're connected to.

00:25:02.120 --> 00:25:05.680
Well, inversely, we like to do the same with your products.

00:25:05.680 --> 00:25:08.910
So, if you implement DID in your products, we can say, oh,

00:25:08.910 --> 00:25:13.970
we're connected to that new Mercedes
2012 325 or whatever, that's a BMW.

00:25:13.970 --> 00:25:16.190
But any car like that.

00:25:16.190 --> 00:25:21.540
And we can now add value with you, and we're more
than willing to work with you, because for example,

00:25:21.540 --> 00:25:24.160
maybe you're doing iAP in the background as well.

00:25:24.160 --> 00:25:29.310
And if we know what device we're connected to,
we can again together add value to that product.

00:25:29.310 --> 00:25:32.980
Implement DID, it's a good thing.

00:25:32.980 --> 00:25:34.380
Role switch.

00:25:34.380 --> 00:25:37.910
So, with Bluetooth, there's a master-slave concept.

00:25:37.910 --> 00:25:40.330
And the master is responsible for a lot of things.

00:25:40.330 --> 00:25:42.040
It's responsible for power.

00:25:42.040 --> 00:25:44.540
It's responsible for frequency selection.

00:25:44.540 --> 00:25:49.790
It's responsible for many things in relation to the
piconet that's created between these two devices.

00:25:49.790 --> 00:25:52.780
We still run into devices that do not allow role switch.

00:25:52.780 --> 00:25:57.240
And this is not a good thing when the phone is
trying to connect to, again, multiple profiles

00:25:57.240 --> 00:26:00.840
and multiple devices as well as coexist with Wi-Fi.

00:26:00.840 --> 00:26:03.930
So, embrace slave mode, it's a great thing, trust me.

00:26:03.930 --> 00:26:06.330
Now, if you don't-- if you can't do it, in other words,

00:26:06.330 --> 00:26:09.510
you're connected to another phone or
whatever, that's fine, we understand.

00:26:09.510 --> 00:26:12.570
But 90 percent of the time, or even more than that,

00:26:12.570 --> 00:26:17.540
you don't have to be master, let
the phone be master, it'll be great.

00:26:17.540 --> 00:26:18.250
Support sniff.

00:26:18.250 --> 00:26:24.070
So, sniff intervals, for those who don't know,
is a way for us to kind of deterministically talk

00:26:24.070 --> 00:26:28.180
to your device in a very controlled method.

00:26:28.180 --> 00:26:31.950
And a lot of times we use sniff
for power saving, for example.

00:26:31.950 --> 00:26:34.950
Keyboards work in sniff mode.

00:26:34.950 --> 00:26:36.220
And they do some things.

00:26:36.220 --> 00:26:40.870
Some keyboards do some things where they implement
a variable sniff interval where, for example,

00:26:40.870 --> 00:26:45.680
they may use a relatively short sniff interval
when you're operating with the device.

00:26:45.680 --> 00:26:48.470
It's about 12 millisecond duty cycle.

00:26:48.470 --> 00:26:54.030
But then when you're asleep or when the phone screen
goes to sleep, the phone's going to actually ask you,

00:26:54.030 --> 00:26:56.600
"Hey by the way, can you go to a longer sniff interval?

00:26:56.600 --> 00:27:00.890
Let's see, 500 milliseconds or even
longer than that in some cases?"

00:27:00.890 --> 00:27:05.070
That's a huge win for two reasons:
Power, 'cause we don't want to have

00:27:05.070 --> 00:27:08.840
to turn the antenna on very often, and coexistence.

00:27:08.840 --> 00:27:15.490
So, the less we're using the Bluetooth side of the
radio or antenna, the more time we can give to Wi-Fi.

00:27:15.490 --> 00:27:19.070
I think you're seeing a theme here, right, with coexistence?

00:27:19.070 --> 00:27:25.810
And then a little thing but we think is a big win for some
of our customers is if somebody reaches for the power button

00:27:25.810 --> 00:27:31.370
on your keyboard, send us a disconnect
before you physically turn off.

00:27:31.370 --> 00:27:36.770
There's a supervision time-out that will kick in after
awhile, but if you can turn off right away rather

00:27:36.770 --> 00:27:41.130
than waiting for a supervision time-out, it's a big
win because you don't have to sit around waiting

00:27:41.130 --> 00:27:43.260
to see if your device is going to talk to us.

00:27:43.260 --> 00:27:47.040
Again, power savings and coexistence improvements.

00:27:47.040 --> 00:27:52.100
So, profiles, just two quick things: A2DP.

00:27:52.100 --> 00:27:54.440
I briefly touched on a couple of things here.

00:27:54.440 --> 00:27:58.610
But if you can't do AAC, try to
do a higher data rate of SBC.

00:27:58.610 --> 00:28:06.870
We see a lot of devices that are still using data rates
in the 200-- 220 kbps data rate, that doesn't sound good.

00:28:06.870 --> 00:28:13.440
And a lot of the negative implications
of A2DP or Bluetooth audio has been

00:28:13.440 --> 00:28:19.370
because people have implemented low data
rates in their SBC encoding or decoding.

00:28:19.370 --> 00:28:28.360
So, if you say to us, "I only support 180 kbps," which
is like SBC value of like somewhere in the 20s, well, so,

00:28:28.360 --> 00:28:33.430
the user, they're going to hear just
massive sound compression artifacts, right?

00:28:33.430 --> 00:28:35.190
So, shoot for 330.

00:28:35.190 --> 00:28:43.350
We find that somewhere in the bitpool value of 53, you're
going to produce an audio quality that really sounds great.

00:28:43.350 --> 00:28:47.890
However, if you can implement AAC, we
really, really want you to do this.

00:28:47.890 --> 00:28:55.070
This is a huge win for us again because
we saved throughput, it's only a 128 kbps.

00:28:55.070 --> 00:29:00.230
We saved power because we're-- we
have a highly, highly optimizing coder

00:29:00.230 --> 00:29:03.880
that reduces the system usage on the AAC encode period.

00:29:03.880 --> 00:29:06.070
And then it also saves in coexistence.

00:29:06.070 --> 00:29:08.350
Again that coexistence word.

00:29:08.350 --> 00:29:11.090
Oh, and then finally, AVDTP 1.3.

00:29:11.090 --> 00:29:18.470
So, when we're sending audio to your device,
we have no idea how long it takes your device

00:29:18.470 --> 00:29:21.280
to render that frame of audio, right?

00:29:21.280 --> 00:29:26.810
So, from the time that audio comes in to your
Bluetooth receiver to the point at which it's decoded,

00:29:26.810 --> 00:29:30.370
to the point at which it goes to the DDA, to
the point at which it goes to the transducer

00:29:30.370 --> 00:29:33.350
or speaker, we don't know how long that takes.

00:29:33.350 --> 00:29:40.280
So, we have to actually measure multiple devices,
and we determine realistically and try to figure

00:29:40.280 --> 00:29:43.520
out how long we think your device takes to render audio.

00:29:43.520 --> 00:29:52.390
And the reason we have to do that is because in most cases,
people are playing a game or people are watching video

00:29:52.390 --> 00:29:54.240
or watching a podcast or whatever they're doing.

00:29:54.240 --> 00:29:57.180
And if we don't keep those in sync, what happens?

00:29:57.180 --> 00:29:58.540
Lip-sync problems, right?

00:29:58.540 --> 00:30:02.660
They're talking and it's-- the bad
Japanese movie or a bad monster movie.

00:30:02.660 --> 00:30:08.040
So, what we have to do is we have to
improve latency by doing all these tricks.

00:30:08.040 --> 00:30:12.480
Well, actually, in Bluetooth, there's a way to
get-- for you to give this information back to us.

00:30:12.480 --> 00:30:15.080
We really like to see you implement that.

00:30:15.080 --> 00:30:22.130
And with HFP, I know I spoke about voice commands as
a feature that we support, but we'd really like you

00:30:22.130 --> 00:30:27.380
to implement the real way of doing it which is BVRA
or Bluetooth Voice Recognition Activation Command.

00:30:27.380 --> 00:30:33.110
Even if your car has the ability of doing
its own voice recognition, totally cool,

00:30:33.110 --> 00:30:37.070
but if the user wants to use the
phone's voice recognition activation,

00:30:37.070 --> 00:30:44.530
we like to be able to send the BVRA plus colon 1
command to you to say we want to do voice commands.

00:30:44.530 --> 00:30:49.170
And everybody wins, because you now understand
the state by which the phone is going into.

00:30:49.170 --> 00:30:54.500
And then eSCO, which is again going back to 2.1 in EDR.

00:30:54.500 --> 00:30:58.280
OK. So that's general Bluetooth
or overall Bluetooth improvements.

00:30:58.280 --> 00:31:00.810
So, let's get into GameKit.

00:31:00.810 --> 00:31:06.190
So, first off, GameKit is it's an interesting
implementation that we did last year.

00:31:06.190 --> 00:31:08.810
And a lot of people started by doing this kind

00:31:08.810 --> 00:31:14.730
of client-server client-server both are running
browsing and advertising simultaneously.

00:31:14.730 --> 00:31:20.200
By the way, this is really-- this talk is really
focused towards the application developer that's working

00:31:20.200 --> 00:31:23.220
on specific applications or uses of GameKit.

00:31:23.220 --> 00:31:27.840
So, when you implement a game, and
both of them come up, it's advertising,

00:31:27.840 --> 00:31:31.730
and they also are coming up in the browse, what happens?

00:31:31.730 --> 00:31:33.630
Well, contention happens, right?

00:31:33.630 --> 00:31:37.360
Because one device is advertising, another
device is advertising, one device is browsing,

00:31:37.360 --> 00:31:41.700
and the other device is browsing, and
there are times when they both browse,

00:31:41.700 --> 00:31:44.390
and when you're browsing, you're
not advertising, and guess what?

00:31:44.390 --> 00:31:46.510
It takes a long time to find each other.

00:31:46.510 --> 00:31:53.260
So, if you can, it's not always appropriate, but
if you can, try to use a client-server model.

00:31:53.260 --> 00:31:56.190
In other words, once side says, "Oh,
you want to play a game of checkers?"

00:31:56.190 --> 00:31:57.900
"Sure." So, you host a game.

00:31:57.900 --> 00:32:01.130
And the other side says let's browse for game of checkers.

00:32:01.130 --> 00:32:04.430
And then you find that game of
checkers and you connect with.

00:32:04.430 --> 00:32:06.620
It finds it much, much, much faster.

00:32:06.620 --> 00:32:11.170
And that's traditionally how Bluetooth is
supposed to work, a client-server model.

00:32:11.170 --> 00:32:17.340
So, in relation to that, only browse
when you want to find something, right?

00:32:17.340 --> 00:32:23.960
So, if you find that game of checkers and you start
playing the game of checkers, there's really no use for you

00:32:23.960 --> 00:32:26.750
to sit there and look for another
game of checkers unless you want

00:32:26.750 --> 00:32:29.410
to play five games of checkers, which I guess is OK.

00:32:29.410 --> 00:32:31.350
But 90 percent of the time, you're not, right?

00:32:31.350 --> 00:32:34.400
Or a large percent of the time
you're not going to want to do that.

00:32:34.400 --> 00:32:39.930
And inverse to that, only advertise
when you need to advertise.

00:32:39.930 --> 00:32:46.330
So that game of checkers, if you only support one
simultaneous act of game, as soon as the game starts,

00:32:46.330 --> 00:32:49.560
stop advertising with Bonjour or with GameKit.

00:32:49.560 --> 00:32:50.370
It's a big win.

00:32:50.370 --> 00:32:54.100
Because what's happening is when you're
advertising or when you're browsing,

00:32:54.100 --> 00:32:57.140
in the background, the radios are pinging out, right?

00:32:57.140 --> 00:33:01.280
They are either in advertise mode, which
means other devices can discover you,

00:33:01.280 --> 00:33:05.210
which means it has to respond to those inquiries, right.

00:33:05.210 --> 00:33:09.580
So, only advertise and browse when
you need to advertise and browse.

00:33:09.580 --> 00:33:14.730
So, to understand maximization or how to
maximize the network or Bluetooth network,

00:33:14.730 --> 00:33:21.420
I wanted to kind of go in to a brief explanation of
how Bluetooth packetizes its data across the network.

00:33:21.420 --> 00:33:24.710
You'll never ever, ever have to
deal with this as a game developer.

00:33:24.710 --> 00:33:30.890
But understanding the packet model hopefully
will help you maximize the throughput

00:33:30.890 --> 00:33:34.270
or latency reduction of latency of your games.

00:33:34.270 --> 00:33:39.310
And the key thing to remember here is that a
wireless network is not equal to a wired network.

00:33:39.310 --> 00:33:45.680
A wireless network, we have this weird thing called
time space, and we can only transmit a certain amount

00:33:45.680 --> 00:33:50.810
of data in a free airspace domain at a time.

00:33:50.810 --> 00:33:57.090
So, it's not just this dedicated wire that were sitting
there plus the data rates tend to be a little bit slower.

00:33:57.090 --> 00:33:58.670
So, let's look at the packet format.

00:33:58.670 --> 00:34:03.250
So, on the left-hand side, we have Time to Transmit
and on the bottom we have the amount of data

00:34:03.250 --> 00:34:05.830
that you can send at any particular time.

00:34:05.830 --> 00:34:07.540
I'm going to throw the packets up there.

00:34:07.540 --> 00:34:11.380
So, there's a lot of gobbledygook titles up there.

00:34:11.380 --> 00:34:16.600
The green are Basic Data Rate packets,
the blue are Extended Data Rate packets.

00:34:16.600 --> 00:34:23.610
And you can already see the advantage of using EDR
over BDR or Basic Data Rate or classic Bluetooth.

00:34:23.610 --> 00:34:26.990
So, we're not going to use BDR, so I'm going
to get rid of those packets right away.

00:34:26.990 --> 00:34:31.820
So, on the far right-hand side or
left-hand side to you, is a 3-DH5 packet,

00:34:31.820 --> 00:34:39.390
and that can contain about 1,000 bytes a data, it's a little
bit more, and it can send in at about 3.125 milliseconds.

00:34:39.390 --> 00:34:47.780
On the left-hand side, we have a 2-DH1 and a 3-DH1, we'll
focus on the 3-DH1, and that can send roughly, I think,

00:34:47.780 --> 00:34:52.000
it's about 80 bytes every 625 microseconds.

00:34:52.000 --> 00:34:57.470
So, we're going to get rid of the other ones, and
we're going to just focus on these particular extremes.

00:34:57.470 --> 00:34:58.580
And why is this important?

00:34:58.580 --> 00:35:00.100
I'll get to it in a second.

00:35:00.100 --> 00:35:04.770
So, let's look at a particular packet or
a 3-DH1 packet and the anatomy of this.

00:35:04.770 --> 00:35:08.580
So, this is how a typical packet looks
as it's flowing over the network.

00:35:08.580 --> 00:35:14.200
We have the baseband which is about 9 bytes
of data, L2CAP takes about 4 bytes of data,

00:35:14.200 --> 00:35:21.340
BNEP which is our networking layer or Bluetooth's way of
sending IP traffic data over the layer, it's about 9 bytes.

00:35:21.340 --> 00:35:27.760
In this case, IPv4 or the IPv6 can be used as
well which will even be more than 13 bytes.

00:35:27.760 --> 00:35:32.410
We're using UDP, so this is a UDP header that
we're using for this particular transmit,

00:35:32.410 --> 00:35:36.440
and then the CRC, which is about 2 bytes.

00:35:36.440 --> 00:35:39.630
So, the overhead of this packet is 45 bytes of information.

00:35:39.630 --> 00:35:41.730
Well, why is this important?

00:35:41.730 --> 00:35:47.880
Well, a 3-DH1 packet is only 83 bytes, so which
means we're only able to send 38 bytes of information

00:35:47.880 --> 00:35:55.940
on any one radio cycle, every 625 milliseconds--
microseconds we're sending, basically,

00:35:55.940 --> 00:35:58.460
38 bytes of the payload that you're sending to us.

00:35:58.460 --> 00:36:01.530
So, there's some key things that we can learn from this.

00:36:01.530 --> 00:36:08.880
If you're sending high bandwidth data, in other words,
if you're sending a file of if you're sending a contact

00:36:08.880 --> 00:36:17.600
to another phone using the GameKit model, try to keep
your MTU values or your payload values at about 980 bytes

00:36:17.600 --> 00:36:21.720
of data, and try to keep your duty
cycles at about 5 milliseconds.

00:36:21.720 --> 00:36:24.140
It's really about 3.125.

00:36:24.140 --> 00:36:28.750
But if you keep it 5, then we can deal with
contention and retries that are going to happen.

00:36:28.750 --> 00:36:32.610
So, what happens if you send it faster
than that, we end up with fragmentation.

00:36:32.610 --> 00:36:38.980
And if you send more MTUs that are larger than this,
let's say you send an MTU of about 1100 bytes, well,

00:36:38.980 --> 00:36:44.500
what's going to end up happening is we're going
to be able to send 1021 bytes and 100 bytes.

00:36:44.500 --> 00:36:50.750
So, the efficiency of the network becomes extremely low
because we're having to send a large packet, a small packer

00:36:50.750 --> 00:36:53.130
or a large packet or a small packet and so on.

00:36:53.130 --> 00:37:00.390
And inverse to that, if you need to send a lot of packet
data really fast and you're not sending a whole lot of data,

00:37:00.390 --> 00:37:05.280
it's about 30 bytes of data, and the duty
cycle of this is about 2.5 milliseconds.

00:37:05.280 --> 00:37:09.040
Again, it's really 625 microseconds.

00:37:09.040 --> 00:37:16.140
But in relation to the large packet data, you can see
that if you keep your packet small and your duty cycles

00:37:16.140 --> 00:37:20.730
within a cadence that's appropriate to Bluetooth,
you're really, really improving your efficiency

00:37:20.730 --> 00:37:26.210
which means your overall latency is going
to drop or the round trip is going to drop.

00:37:26.210 --> 00:37:30.130
So, a couple other things.

00:37:30.130 --> 00:37:31.600
Be a good wireless citizen.

00:37:31.600 --> 00:37:32.720
What does that mean?

00:37:32.720 --> 00:37:34.540
Only use the bandwidth you need.

00:37:34.540 --> 00:37:39.200
Don't slam the Bluetooth network if you don't
need to be slamming the Bluetooth network.

00:37:39.200 --> 00:37:42.040
Again, this is for coexistence.

00:37:42.040 --> 00:37:44.470
Only transmit when necessary.

00:37:44.470 --> 00:37:46.740
We kind of briefly talked about this.

00:37:46.740 --> 00:37:48.990
Performance of the Bluetooth and Wi-Fi are affected.

00:37:48.990 --> 00:37:54.810
And what I mean by this is if somebody's playing
your game, you're directly affecting the performance

00:37:54.810 --> 00:37:56.730
of everything else that's going on on the radio.

00:37:56.730 --> 00:37:59.560
You have to keep that in mind.

00:37:59.560 --> 00:38:03.550
And then avoid multicast, not everybody
needs to get the same packet of information

00:38:03.550 --> 00:38:06.590
if you're dealing with a multi-device game.

00:38:06.590 --> 00:38:09.580
So, that's working with GameKit.

00:38:09.580 --> 00:38:12.970
So, finally, I want to briefly talk about Wi-Fi Coexistence.

00:38:12.970 --> 00:38:18.410
So, for those of you that don't know, Bluetooth
and Wi-Fi exist within the same ISM band,

00:38:18.410 --> 00:38:23.630
and this is more for associate
manufacturers and application developers.

00:38:23.630 --> 00:38:27.100
We exist between the 2.4 and 2.5 gigahertz band.

00:38:27.100 --> 00:38:34.790
Wi-Fi consist of about 22 megahertz-- or consist of
specifically thirteen 22 megahertz channels that start

00:38:34.790 --> 00:38:42.330
at 2.4 just above 2.4 and move all the way up to
channel 11, in some parts of the world, channel 13.

00:38:42.330 --> 00:38:46.920
Bluetooth uses seventy-nine 1 megahertz
channels that do not overlap.

00:38:46.920 --> 00:38:49.140
One thing to keep in mind, Wi-Fi does overlap.

00:38:49.140 --> 00:38:52.780
So, one-- channel 1 and channel 2 overlap.

00:38:52.780 --> 00:38:58.530
So, typically, when you are selecting Wi-Fi channels, you
see 1 and then the next non-overlapped Wi-Fi channel at 6,

00:38:58.530 --> 00:39:01.650
and the next overlap Wi-Fi channel is 11.

00:39:01.650 --> 00:39:06.970
So in the case of yesterday in the
keynote, you guys were using every channel.

00:39:06.970 --> 00:39:08.110
It was crazy.

00:39:08.110 --> 00:39:12.780
So, let's look at what Bluetooth looks like maybe visually.

00:39:12.780 --> 00:39:16.510
So, this is 79 channels across the entire spectrum.

00:39:16.510 --> 00:39:20.900
And one of the things Bluetooth does
that tries to avoid interruption

00:39:20.900 --> 00:39:24.290
or interference is it uses adaptive frequency hopping.

00:39:24.290 --> 00:39:27.660
So, it doesn't transmit on all of
these frequency simultaneously,

00:39:27.660 --> 00:39:32.910
it's algorithmically choosing the
appropriate frequency to transmit on.

00:39:32.910 --> 00:39:35.710
So, it would look something like
this, where it's hopping around

00:39:35.710 --> 00:39:40.070
and picking frequencies depending
upon what is open or available to it.

00:39:40.070 --> 00:39:43.640
So, now, let's overlay 1, 6, and11 on top of this.

00:39:43.640 --> 00:39:52.810
So, now you can see when Wi-Fi is using a bunch of frequency
or spectrum, Bluetooth doesn't have a whole lot to live in.

00:39:52.810 --> 00:39:56.730
So, if we're hopping in this, you can
see we're really, really under duress.

00:39:56.730 --> 00:40:01.990
Our Bluetooth is really trying to
make it work for whoever is using it

00:40:01.990 --> 00:40:05.640
at that particular time, whether
it be Hands-Free or GameKit.

00:40:06.890 --> 00:40:09.870
So, briefly I wanted to mention how we transmit.

00:40:09.870 --> 00:40:12.870
So, Bluetooth and Wi-Fi use the same antenna in our devices.

00:40:12.870 --> 00:40:15.400
In all of our iOS devices, this is the case.

00:40:15.400 --> 00:40:17.220
We use the same exact antenna.

00:40:17.220 --> 00:40:23.470
So, if they both want to transmit and Bluetooth
has priority what happens is Wi-Fi can't transmit,

00:40:23.470 --> 00:40:25.450
and Bluetooth gets the antenna.

00:40:25.450 --> 00:40:29.980
Well, inverse to that, if Wi-Fi wants
to transmit and it has higher priority,

00:40:29.980 --> 00:40:33.800
then Bluetooth can transmit and it has the antenna.

00:40:33.800 --> 00:40:37.450
So, we have technology that we've
developed, and we have worked with our--

00:40:37.450 --> 00:40:45.290
with industry standard to do antenna arbitration so that
we smartly select the appropriate side of the radio,

00:40:45.290 --> 00:40:52.250
if you will, Wi-Fi or Bluetooth, and we try to fit
in Bluetooth transmits in line with Wi-Fi transmits

00:40:52.250 --> 00:40:56.020
so that Wi-Fi doesn't step on Bluetooth
and Bluetooth doesn't step on Wi-Fi.

00:40:56.020 --> 00:41:00.680
But there are some things that you can do to
help us make this easier for us in our products.

00:41:00.680 --> 00:41:01.310
Guess what?

00:41:01.310 --> 00:41:02.560
Implement 2.1.

00:41:02.560 --> 00:41:04.170
This is a big win for us.

00:41:04.170 --> 00:41:09.640
If you can transmit three times as
much data in the same amount of time,

00:41:09.640 --> 00:41:12.910
then you don't have to be transmitting as often, right?

00:41:12.910 --> 00:41:21.790
Or if you're transmitting 30 bytes of data every 625
microseconds rather than 10 bytes of data, again,

00:41:21.790 --> 00:41:26.340
it's a big win for coexistence, because
we don't have to do it as often, right?

00:41:26.340 --> 00:41:27.800
Support sniff.

00:41:27.800 --> 00:41:29.330
Sniff is deterministic.

00:41:29.330 --> 00:41:34.020
If we have a deterministic interval
and transmit, we know how to arbitrate

00:41:34.020 --> 00:41:39.080
or how to integrate Wi-Fi and BT
from a coexistence perspective.

00:41:39.080 --> 00:41:41.110
So, sniff is a big win for us.

00:41:41.110 --> 00:41:42.800
Optimize packet usage.

00:41:42.800 --> 00:41:49.110
Only send, and this goes back to my previous
section, only send what you need to send, right?

00:41:49.110 --> 00:41:51.170
Support lower bandwidth codecs.

00:41:51.170 --> 00:41:52.320
We talked about AAC.

00:41:52.320 --> 00:41:54.860
It's a huge win.

00:41:54.860 --> 00:42:00.770
The difference between 330 kbps and a 128
kbps or depending upon what we're doing,

00:42:00.770 --> 00:42:04.860
it could even be less than that is
just a huge win for coexistence.

00:42:04.860 --> 00:42:06.810
So that's Wi-fi Coexistence.

00:42:06.810 --> 00:42:13.540
And ultimately, that's the three areas that hopefully will
help you improve your products both application development

00:42:13.540 --> 00:42:18.110
as well as Bluetooth accessories to
hopefully create a great user experience

00:42:18.110 --> 00:42:23.090
between the iPhone OS platforms and
your software and your accessories.

00:42:23.090 --> 00:42:26.970
So, with that, I'm going to hand it over to
Paul who's going to go into External Frameworks.

00:42:26.970 --> 00:42:27.990
Thank you.

00:42:27.990 --> 00:42:32.110
[ Applause ]

00:42:32.110 --> 00:42:33.020
>> Good morning, everybody.

00:42:33.020 --> 00:42:36.680
My name is Paul Holden, working
in the iPhone Application Team.

00:42:36.680 --> 00:42:40.930
And I'm really excited to be here to talk to
you guys about the External Accessory framework.

00:42:40.930 --> 00:42:46.260
And particularly, I actually-- I saw some faces
that were here last year when we gave this talk.

00:42:46.260 --> 00:42:52.680
So, I'd like to briefly go over the architecture of--
I'll call it EA from now on instead of External Accessory,

00:42:52.680 --> 00:42:56.050
the EA architecture, and quickly go over the API.

00:42:56.050 --> 00:43:02.090
OK. And go over some of the-- things that people have sort
of sent bugs in it about and talk to us about in the lab

00:43:02.090 --> 00:43:04.450
so that we can try and give you guys some hints.

00:43:04.450 --> 00:43:10.100
Next, we'd like to go over what's new in iOS 4
with respect to the External Accessory framework.

00:43:10.100 --> 00:43:15.720
So, multitasking, and something that is very, very
popular with you guys, a lot of requests that we got were

00:43:15.720 --> 00:43:17.840
for different types of App Store interactions.

00:43:17.840 --> 00:43:22.600
So, we'll talk about those as well.

00:43:22.600 --> 00:43:27.560
So, going over the architecture, you've got a
physical accessory, and you've got your application.

00:43:27.560 --> 00:43:30.200
OK. So, here you're got physical
accessory, you've got an application,

00:43:30.200 --> 00:43:33.430
and your application will link
against the EA Framework, right?

00:43:33.430 --> 00:43:36.780
So that's the blue box that you see here.

00:43:36.780 --> 00:43:41.580
Now, when you connect your physical
accessory to the iPhone, you'll get--

00:43:41.580 --> 00:43:46.050
your accessory will enumerate the
protocols that it supports.

00:43:46.050 --> 00:43:49.770
Now, this is what Emily was talking about, about the
custom protocols where we don't really get in the way,

00:43:49.770 --> 00:43:56.870
we just give you guys channels to send input
and output to and from your accessory, right?

00:43:56.870 --> 00:44:04.380
And what happens is all of these your-- for example here
we've got three, you name them, you're in control of them,

00:44:04.380 --> 00:44:07.820
and your application is free to
use any of them that it wants.

00:44:07.820 --> 00:44:15.610
So, once that happens, once your accessory
enumerates, and with the protocols that it supports.

00:44:15.610 --> 00:44:18.190
In your application, you'll get a notification.

00:44:18.190 --> 00:44:22.970
And part of that notification will be an object
that will represent the physical accessory, OK.

00:44:22.970 --> 00:44:28.070
So, if you've got three accessories that are currently
connected, you'll get three of these kinds of blue boxes

00:44:28.070 --> 00:44:34.540
that will show up in your application, and they'll each
list all the protocols that are supported by your accessory.

00:44:34.540 --> 00:44:40.520
Next, when you want to actually send data, we've
got the gray boxes around here, the protocol.

00:44:40.520 --> 00:44:45.820
So, for example, here we've got the two, you'll
open what we call EASessions with these protocols,

00:44:45.820 --> 00:44:49.370
and then you'll be able to send input and
output to and from your accessory, OK.

00:44:49.370 --> 00:44:54.030
So that's the architecture really quickly.

00:44:54.030 --> 00:44:56.350
So next, let's talk about the API.

00:44:56.350 --> 00:44:58.270
So, very basic small API here.

00:44:58.270 --> 00:44:59.820
We can fit it all in just a few lines.

00:44:59.820 --> 00:45:07.180
So, we've got three classes: EAAccessoryManager,
EAAccessory, which also has a delegate, and EASession.

00:45:07.180 --> 00:45:10.090
So, let's start with EAAccessoryManager.

00:45:10.090 --> 00:45:15.800
So, when you guys look at this header file, you'll
see two notifications that pretty much every single

00:45:15.800 --> 00:45:19.540
of your applications that'll use additional
accessory framework will have to use,

00:45:19.540 --> 00:45:23.020
so the DidDisconnect and the DidConnectNotification.

00:45:23.020 --> 00:45:28.290
So when you receive these, you'll get them whenever
a physical accessory connects to your device

00:45:28.290 --> 00:45:30.830
and enumerates the protocols that it supports, OK.

00:45:30.830 --> 00:45:37.150
And anyone who's familiar with Foundation notifications
will see that there's a user info dictionary,

00:45:37.150 --> 00:45:41.590
and in the user info dictionary will be
that object that represents your accessory,

00:45:41.590 --> 00:45:44.840
the EAAccessory object which we'll get to the next slide.

00:45:44.840 --> 00:45:50.300
So, it is a singleton, so you use the
sharedAccessoryManager to get to it.

00:45:50.300 --> 00:45:54.740
And next, like you've seen in a lot of the other frameworks,
we asked you to register and unregister for notifications.

00:45:54.740 --> 00:45:57.040
That helps us do a little bit of authorization.

00:45:57.040 --> 00:46:05.910
And then next, when you connect-- when you actually startup
your application, we won't send you a DidConnectNotification

00:46:05.910 --> 00:46:08.920
for every single accessory that's already connected.

00:46:08.920 --> 00:46:13.000
What you'll get instead is you'll come
up and you'll register for notifications

00:46:13.000 --> 00:46:17.690
and you'll call the connectedAccessories protocol, and what
that'll do, well, that'll give you the list of accessories

00:46:17.690 --> 00:46:21.520
that are already connected to your iPhone.

00:46:21.520 --> 00:46:24.860
So next, the object that pretty much everyone use here.

00:46:24.860 --> 00:46:29.030
When you get the DidConnectNotification or when
you call the property connectedAccessories,

00:46:29.030 --> 00:46:31.300
in there you'll see these EAAccessory objects.

00:46:31.300 --> 00:46:35.240
So, if this is the one-- if this is
the accessory that you care about so,

00:46:35.240 --> 00:46:37.490
you'll check it to see if it supports the protocolString.

00:46:37.490 --> 00:46:42.380
So here, we've got three important protocols, the
connectionID, the protocolString and the delegate.

00:46:42.380 --> 00:46:47.260
So, if it is an accessory that you care about,
you'll go ahead and you'll retain and you'll use it.

00:46:47.260 --> 00:46:51.110
And then you'll probably use these three properties.

00:46:51.110 --> 00:46:54.240
So now, there's a lot of them in
there such as name, manufacturer,

00:46:54.240 --> 00:46:56.530
serial number, model number, all sorts of stuff.

00:46:56.530 --> 00:46:59.810
But generally, you'll use connectionID for you to know

00:46:59.810 --> 00:47:04.100
that this actually is a unique ID given
to that accessory for that connection.

00:47:04.100 --> 00:47:08.580
So, let's say you have a certain accessory
that connects, disconnects and reconnects,

00:47:08.580 --> 00:47:11.970
although the accessory will look the
same, the connectionID will be different.

00:47:11.970 --> 00:47:16.470
And then the protocolStrings is just an array
of all those custom protocols that it supports.

00:47:16.470 --> 00:47:20.700
And generally, we ask people to
name them in reverse DNS notations.

00:47:20.700 --> 00:47:22.980
So you'll get them here, it's just a list of strings.

00:47:22.980 --> 00:47:24.950
And finally, the delegate.

00:47:24.950 --> 00:47:26.800
So, what's the delegate used for?

00:47:26.800 --> 00:47:29.900
Two slides ago, we talked about
the DidDisconnectNotification.

00:47:29.900 --> 00:47:36.140
OK, what's great about the DidDisconnectNotification
is that you get it anytime an accessory disconnects.

00:47:36.140 --> 00:47:40.690
The bad thing about that notification is that
you get it every time an accessory disconnects.

00:47:40.690 --> 00:47:45.370
So, if you only care about one particular one that you've
retained, then you can go ahead and set the delegate

00:47:45.370 --> 00:47:51.680
on that EA object, on that EAAccessory object and you'll
get this called only when that accessory disconnects.

00:47:51.680 --> 00:47:54.070
So, hope you guys have all that.

00:47:54.070 --> 00:47:58.610
Next, where you'll spend most of
your time is with the EASession, OK.

00:47:58.610 --> 00:48:04.320
So, EASessions are what we'll use when
we actually want to talk to a protocol--

00:48:04.320 --> 00:48:06.990
when we talk over a protocol for a given accessory.

00:48:06.990 --> 00:48:10.600
So, the application developer,
you guys, will create it, right?

00:48:10.600 --> 00:48:12.520
So, use initWithAccessory forProtocol.

00:48:12.520 --> 00:48:17.700
So, you create one session forProtocol for one accessory.

00:48:17.700 --> 00:48:19.890
Next, how are you going to talk to your accessory?

00:48:19.890 --> 00:48:21.710
Well you'll use these two properties.

00:48:21.710 --> 00:48:24.050
You'll use the inputStream and the outputStream.

00:48:24.050 --> 00:48:30.970
So, these are NSInputStream and NSOutputStream
classes which are both subclasses of NSStream.

00:48:30.970 --> 00:48:32.420
We'll talk about those in a little bit.

00:48:32.420 --> 00:48:36.210
But basically, these are the main
objects that you'll use to communicate.

00:48:36.210 --> 00:48:42.270
Finally, you have one EASession
per EA Protocol per EAAccessory.

00:48:42.270 --> 00:48:46.160
That's kind of a mouthful, but even with
multitasking, this is still the case.

00:48:46.160 --> 00:48:52.820
So for example, if you the application developer, hold
the session to a certain protocol for a certain accessory,

00:48:52.820 --> 00:49:00.650
even if you go in the background, even if you
suspend, you will still own that protocol, right?

00:49:00.650 --> 00:49:04.790
So, no other application can come in and just
start talking to it until you release it.

00:49:04.790 --> 00:49:09.750
So, we talked about communicating
using NSInputStream and NSOutputStream.

00:49:09.750 --> 00:49:15.310
So, I'm bringing this up again because this was definitely
one of the most difficult points that when people had a lot

00:49:15.310 --> 00:49:17.520
of question or people had issues with their--

00:49:17.520 --> 00:49:23.170
writing their applications and trying to use the External
Accessory framework, a lot of them came to using this class.

00:49:23.170 --> 00:49:24.910
So, it's a subclass of NSStream.

00:49:24.910 --> 00:49:30.660
And I would say at least 80 percent of the
questions were somehow in this document.

00:49:30.660 --> 00:49:35.340
So, the "Introduction to Stream Programming
Guide for Cocoa," I encourage anyone who plans

00:49:35.340 --> 00:49:39.710
to use this framework to go read that, very, very useful.

00:49:39.710 --> 00:49:43.260
It describes it in a lot of detail, gives a lot of examples.

00:49:43.260 --> 00:49:49.880
And if I were to describe it very, very quickly,
what I would do is I would tell people that this is--

00:49:49.880 --> 00:49:54.180
it's delegate-based, and basically, whether
you have the inputStream or the outputStream,

00:49:54.180 --> 00:49:59.760
both are subclasses of NSStream, and that
NSStream basically just uses one subclass

00:49:59.760 --> 00:50:02.180
to communicate, and that's theStream handleEvent.

00:50:02.180 --> 00:50:09.620
And the types of events that you'll get are stream
open, stream close, stream had an error, stream ended,

00:50:09.620 --> 00:50:16.040
stream has data available, and stream has space
available for you to put data in it, right.

00:50:16.040 --> 00:50:20.970
So you can't just assume that when you open
a stream that there's enough space for you

00:50:20.970 --> 00:50:23.320
to put, you know, 25 megabytes in there, right.

00:50:23.320 --> 00:50:26.400
You send data, and it'll come back and
it'll tell you how much room is in it,

00:50:26.400 --> 00:50:28.870
how much you can-- how much data you can put in it.

00:50:28.870 --> 00:50:31.840
And then when the data is consumed,
you'll get a notification

00:50:31.840 --> 00:50:33.970
and then you're free to put more data in there, right.

00:50:33.970 --> 00:50:35.260
So definitely, check that out.

00:50:35.260 --> 00:50:37.050
It'll be really, really useful.

00:50:37.050 --> 00:50:40.580
So, what's new?

00:50:40.580 --> 00:50:46.000
We talked about the API and how
they've kind of stay the same.

00:50:46.000 --> 00:50:51.970
But generally, multitasking has had a few-- made
a few changes with respect to your accessory.

00:50:51.970 --> 00:50:55.880
So, one is there are no EA events in the background.

00:50:55.880 --> 00:50:57.360
So, how do we accomplish this?

00:50:57.360 --> 00:51:01.520
When your application gets the
UIApplicationDidEnterBackgroundNotification,

00:51:01.520 --> 00:51:02.290
we read that too.

00:51:02.290 --> 00:51:07.690
So, the External Accessory framework will read
that and what it'll do is it sends a disconnect

00:51:07.690 --> 00:51:11.880
for every single accessory that's
currently connected to your system.

00:51:11.880 --> 00:51:14.010
So you'd get this when you go into the background.

00:51:14.010 --> 00:51:19.260
Then when you come in to the foreground,
you'll get a DidConnectNotification

00:51:19.260 --> 00:51:22.420
for everything that's connected
when you come into the foreground.

00:51:22.420 --> 00:51:29.480
Now, why that's important is because this will
allow your programs to work seamlessly with iOS 4.0.

00:51:29.480 --> 00:51:35.380
So, even though-- let's say someone disconnects
and reconnects an accessory a hundred times

00:51:35.380 --> 00:51:39.980
and when you come back up or possibly if-- when you
come back up out of suspension or out of the background,

00:51:39.980 --> 00:51:42.940
that accessory is no longer there, you won't even notice it.

00:51:42.940 --> 00:51:45.950
It'll look just as if that accessory disconnected, OK.

00:51:45.950 --> 00:51:48.920
So, this will allow people to seamlessly
have their application work

00:51:48.920 --> 00:51:52.680
between 3 and 4 with one exception of course.

00:51:52.680 --> 00:51:59.170
So, if you don't release your session,
other clients aren't free to use it.

00:51:59.170 --> 00:52:04.600
So, it's very, very important that if you don't intend on
keeping a session around, that when you're done with it,

00:52:04.600 --> 00:52:07.830
you close it or when the accessory
disconnects, that you close it.

00:52:07.830 --> 00:52:13.620
Now, in 3.0, this wasn't-- for the iPhone
OS 3.0, this wasn't as important, right.

00:52:13.620 --> 00:52:19.040
Because when your-- when the use press the
Home button, your application went down

00:52:19.040 --> 00:52:20.770
and we did all the clean up everything, right.

00:52:20.770 --> 00:52:26.620
So, a lot of people-- we're looking
at most applications today.

00:52:26.620 --> 00:52:27.530
Most people did this.

00:52:27.530 --> 00:52:29.900
So, most of them will just get all this behavior for free.

00:52:29.900 --> 00:52:34.010
But not-- it's-- but if you didn't, it's very
important that you go ahead and clean up.

00:52:34.010 --> 00:52:36.890
So this-- so this is taken right
out of that programming guide,

00:52:36.890 --> 00:52:39.550
the Stream Programming Guide for
Cocoa that I brought earlier.

00:52:39.550 --> 00:52:44.280
So, for every session, you want to close them, remove
them from the runLoop and set the delegate the nil.

00:52:44.280 --> 00:52:47.740
And then finally, the last line
here, just release your session.

00:52:47.740 --> 00:52:53.410
So finally this, App Store Interactions, very,
very excited to be able to bring this to you guys.

00:52:53.410 --> 00:52:56.400
This was definitely one of the most
requested features that we had here.

00:52:56.400 --> 00:53:04.120
So, if I were to describe how we did this before, when
you connected an accessory to your iPhone, if there was--

00:53:04.120 --> 00:53:11.070
if for every protocol that you supported, there was not a
single application that handled anyone of those protocols.

00:53:11.070 --> 00:53:13.500
You got the alert that you see here.

00:53:13.500 --> 00:53:20.200
So, application unsold, you want to go to the App Store
and then sell it, and also in the Settings application,

00:53:20.200 --> 00:53:22.130
you got to find app for accessory, alright.

00:53:22.130 --> 00:53:27.360
So this worked for 90 percent of the people out there,
but we've got a lot of request for us to expand this

00:53:27.360 --> 00:53:29.030
and give them different kinds of options.

00:53:29.030 --> 00:53:36.800
So, before I go into those, I'd like to just talk
about how you get an application to be associated

00:53:36.800 --> 00:53:39.910
with your-- with the protocols that it supports.

00:53:39.910 --> 00:53:44.060
So, we have a key UISupportedExternalAccessoryProtocols.

00:53:44.060 --> 00:53:45.280
It goes in your Info.plist.

00:53:45.280 --> 00:53:54.010
You list all the protocols that your accessory supports,
and then from there, if there is a iPhone OS 3.0,

00:53:54.010 --> 00:53:58.310
if there is a protocol that's supported by
a single application, the alert disappears.

00:53:58.310 --> 00:54:01.890
But you still see the find application for accessory here.

00:54:01.890 --> 00:54:04.870
So, App Store Interactions.

00:54:04.870 --> 00:54:07.540
This is the mode, we've got pictures
later, so don't read this.

00:54:07.540 --> 00:54:11.790
But basically, we've got a bunch of new
interactions that'll help you work with that alert

00:54:11.790 --> 00:54:14.050
and help you work with the App Store a lot easier.

00:54:14.050 --> 00:54:22.180
What's important to mention is that we now add properties
to these protocols and this happens on the iAP layer.

00:54:22.180 --> 00:54:27.330
OK. It doesn't happen in the people who are writing
applications essentially have no control over this, right.

00:54:27.330 --> 00:54:34.360
When you're writing your accessory, when you are
enumerating your protocols over iAP, you'll go ahead

00:54:34.360 --> 00:54:39.030
and you'll add the-- you'll add a few
properties that'll give us hints about you want

00:54:39.030 --> 00:54:41.540
to do with respect to App Store Interactions.

00:54:41.540 --> 00:54:45.090
So, all of these happen over iAP.

00:54:45.090 --> 00:54:47.810
So, the first one is the one that we had in 3.0.

00:54:47.810 --> 00:54:50.430
So, Show Alert if no EA Protocol is supported.

00:54:50.430 --> 00:54:54.620
So let's say, your accessory supports three protocols.

00:54:54.620 --> 00:55:00.830
Not a single one of them is supported by any
app on the phone, then you'll get the alert.

00:55:00.830 --> 00:55:07.050
Next, we have a property-- oh, also to mention where--
I go back here, if you don't add any properties,

00:55:07.050 --> 00:55:09.310
you'll get the default behavior from the 3.0.

00:55:09.310 --> 00:55:13.280
So nothing-- you'll see your applications
going forward, they'll work.

00:55:13.280 --> 00:55:17.010
If you don't add anything, they'll
work just as they did in 3.0.

00:55:17.010 --> 00:55:21.790
So, going forward, you can also add a property that says,

00:55:21.790 --> 00:55:25.610
I want you to show the Alert if
EA Protocol x is not supported.

00:55:25.610 --> 00:55:31.460
So, let's say you have an accessory that has three
protocols and two of them aren't very important,

00:55:31.460 --> 00:55:36.920
they might also be supported by adaptation, but you have one
that's really, really, really important and you always want

00:55:36.920 --> 00:55:44.110
to show this alert if that particular one doesn't have
an accessory that has that protocol in it's Info.plist.

00:55:44.110 --> 00:55:49.990
So you can add this property to it, the Show Alert if
EA Protocol x is not supported and that'll always come

00:55:49.990 --> 00:55:54.060
up until that particular protocol is supported.

00:55:54.060 --> 00:55:55.580
Next, No Alert.

00:55:55.580 --> 00:56:00.250
So you can just tell us for this
particular protocol, I don't want an alert.

00:56:00.250 --> 00:56:01.380
That's fine, we won't show it.

00:56:01.380 --> 00:56:06.600
Next, if you want to be in total stealth
mode, you can just say No Action.

00:56:06.600 --> 00:56:15.370
And if you add that property to the protocol over iAP, we
will not show anything that has to do with the App Store.

00:56:15.370 --> 00:56:20.600
So that concludes the External
Accessory framework portion of it.

00:56:20.600 --> 00:56:24.250
If you have any more questions,
definitely talk to the Evangelist.

00:56:24.250 --> 00:56:28.250
If they don't know the answer or who to get you
the answer from, there probably is no answer.

00:56:28.250 --> 00:56:32.590
And then check out Developer Program
Documentation and the Apple Forums.

00:56:32.590 --> 00:56:37.850
Next, we also have a-- associated with
this session, we have a test application,

00:56:37.850 --> 00:56:41.600
and I definitely encourage everyone
to go through and see it.

00:56:41.600 --> 00:56:43.270
It's very, very general.

00:56:43.270 --> 00:56:48.750
It basically lets you form connections and
send data to any accessory that's out there.

00:56:48.750 --> 00:56:55.140
So, everyone can take advantage of the
application that's bundled with this presentation.

00:56:55.140 --> 00:56:56.550
So, definitely go look at it.

00:56:56.550 --> 00:57:03.050
In particular, there's an EAD so the program
is called EA Demo, so the prefix EAD.

00:57:03.050 --> 00:57:08.150
EAD session controller .h and .m.
Those are like plagiarized full proof.

00:57:08.150 --> 00:57:13.110
We want everyone to go through, read them and
possibly just copy them as-is into your application.

00:57:13.110 --> 00:57:18.640
They kind of abstract a little bit the NSStream stuff
so that you guys can go through and use that, alright?

