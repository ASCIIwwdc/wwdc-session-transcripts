WEBVTT

00:00:07.270 --> 00:00:08.120
>> Hi everyone.

00:00:08.120 --> 00:00:09.140
My name is Paul.

00:00:09.140 --> 00:00:13.770
And this is Adding Touch and Gesture
Detection to Web Pages on iPhone OS.

00:00:13.770 --> 00:00:16.570
I'm an engineer on Safari for iOS.

00:00:16.570 --> 00:00:18.810
Why are you here today?

00:00:18.810 --> 00:00:24.130
You're here because you have a website for
iPad, iPhone or you're thinking of building one.

00:00:24.130 --> 00:00:26.670
And you want it to feel great.

00:00:26.670 --> 00:00:28.330
iPad, iPhone, they're amazing.

00:00:28.330 --> 00:00:30.810
They let you hold the web in your hands.

00:00:30.810 --> 00:00:34.180
But maybe what's missing is you
can't touch your web content.

00:00:34.180 --> 00:00:39.390
Your users, your customers, and you want to be able to
build web content for fingers, things that you can move

00:00:39.390 --> 00:00:44.010
around the screen just by dragging them,
pinch to zoom or rotate with two fingers.

00:00:44.010 --> 00:00:48.480
We can do these things using just web
technologies, HTML, CSS, JavaScript.

00:00:48.480 --> 00:00:51.430
You don't need Objective-C, you don't a native application.

00:00:51.430 --> 00:00:52.800
We'll talk about how you can do that today.

00:00:52.800 --> 00:01:01.880
And we can build really amazing, rich web applications
for these platforms for iPhone, iPad, iPod touch.

00:01:01.880 --> 00:01:05.630
Things that when they're sitting on the
home screen of your customer's phones

00:01:05.630 --> 00:01:08.690
and devices, they feel just like native applications.

00:01:08.690 --> 00:01:12.500
We'll talk about some tips, techniques
and ways we can do that.

00:01:12.500 --> 00:01:14.420
So, we're going to cover three main things today.

00:01:14.420 --> 00:01:18.150
We're going to talk about the touch
event API and the touch event model.

00:01:18.150 --> 00:01:22.350
What touch events are, how they get delivered
to your application, how you use them.

00:01:22.350 --> 00:01:27.800
We're going to talk about building controls, reusable
interface widgets, a few really rich controllers

00:01:27.800 --> 00:01:31.660
that aren't part of the standard HTML5 repertoire.

00:01:31.660 --> 00:01:35.900
And along the way we're going to be using the
Document Object Model and some CSS transforms

00:01:35.900 --> 00:01:40.010
to build some really nice, complex, rich interfaces.

00:01:40.010 --> 00:01:44.520
So, hopefully everyone here is already
familiar with HTML, JavaScript, and CSS.

00:01:44.520 --> 00:01:48.890
This is going to be a very code heavy
presentation, but don't worry about trying

00:01:48.890 --> 00:01:51.420
to copy everything down in your notes, in your laptops.

00:01:51.420 --> 00:01:55.270
All the sample code that's presented here on
the slides today is attached to the session.

00:01:55.270 --> 00:01:57.610
You can get it from the WWDC Attendee site later.

00:01:57.610 --> 00:02:02.400
And hopefully you're familiar with the
basics of the Document Object Model.

00:02:02.400 --> 00:02:07.560
Now, you don't need to know the 15 parameters you need
to use in order to create a mouse event programmatically.

00:02:07.560 --> 00:02:16.190
Hopefully though you're able to use a document.get
ElementById to pull a DOM node out of a HTML document.

00:02:16.190 --> 00:02:18.620
So let's talk about touch events.

00:02:18.620 --> 00:02:20.250
The touch event API.

00:02:20.250 --> 00:02:22.170
Why do we even have these touch events?

00:02:22.170 --> 00:02:23.870
We already have mouse events.

00:02:23.870 --> 00:02:27.900
Why do we need a separate set of
events to describe your fingers?

00:02:27.900 --> 00:02:31.400
And the answer is your fingers are different from mice.

00:02:31.400 --> 00:02:33.220
There's a couple really big differences.

00:02:33.220 --> 00:02:35.900
First, you have more than one finger.

00:02:35.900 --> 00:02:38.240
Most computers only have one mouse.

00:02:38.240 --> 00:02:41.640
Second, you can remove your fingers
entirely from the equation.

00:02:41.640 --> 00:02:46.180
You can lift your fingers off the screen and put
them down in a completely different location.

00:02:46.180 --> 00:02:47.330
I'm talking too much.

00:02:47.330 --> 00:02:48.880
Let me show you what I'm talking about.

00:02:48.880 --> 00:02:50.680
And I have this really simple demo.

00:02:50.680 --> 00:02:53.920
It's got these three bubbles, mouse
down, mouse move, mouse up.

00:02:53.920 --> 00:02:58.290
And every time this page receives one of those
events from the browser, they're going to light up.

00:02:58.290 --> 00:03:02.960
So if I move the mouse around the screen,
we'll get a series of mouse-move events.

00:03:02.960 --> 00:03:08.530
And if I click, we'll get a mouse-down
event, followed by a mouse-up event.

00:03:08.530 --> 00:03:13.050
Now, on an iPad, iPhone or iPod touch
it works a little bit differently.

00:03:13.050 --> 00:03:17.600
Ok, I've got the exact same page loaded here on my iPad.

00:03:17.600 --> 00:03:18.610
Thank you.

00:03:18.610 --> 00:03:23.240
And I'm going to tap on the screen to click.

00:03:23.240 --> 00:03:26.360
And what happens is we get all
three of those events at once.

00:03:26.360 --> 00:03:31.410
We get a mouse move and a mouse down and
a mouse up all delivered at the same time.

00:03:31.410 --> 00:03:36.950
And in fact, if you notice, if I
tap there's a little bit of a delay.

00:03:36.950 --> 00:03:41.620
Safari for iOS needs just a brief second
to figure out what the user's trying to do.

00:03:41.620 --> 00:03:44.790
Is the user going to double tap to zoom in to an element?

00:03:44.790 --> 00:03:46.930
Is the user going to pan the page?

00:03:46.930 --> 00:03:51.070
It needs just that really brief delay to figure
out if we're trying to click on something

00:03:51.070 --> 00:03:54.650
or if we're using some other sort of gesture.

00:03:54.650 --> 00:03:57.870
So mouse events are different than touch events.

00:03:57.870 --> 00:04:01.610
Now I have another page right here with the touch events.

00:04:01.610 --> 00:04:03.750
Touch events are different than mouse events.

00:04:03.750 --> 00:04:07.570
Safari doesn't take any time to look at
the touches and figure out what's going on.

00:04:07.570 --> 00:04:09.350
It delivers them immediately.

00:04:09.350 --> 00:04:14.450
So if I place my finger down on the screen,
we'll immediately receive a touch startevent.

00:04:14.450 --> 00:04:19.480
And as I move my finger around the screen,
we'll receive a series of touchmove events.

00:04:19.480 --> 00:04:23.640
And when I lift my finger off the
screen, we'll receive a touchend event.

00:04:23.640 --> 00:04:26.400
These are dispatched to your web content first.

00:04:26.400 --> 00:04:29.220
You get a first crack at all of these input events.

00:04:29.220 --> 00:04:32.010
Now we have more than one finger,
I've mentioned this already.

00:04:32.010 --> 00:04:35.810
And we'll receive these events for each
finger and they might be interleaved.

00:04:35.810 --> 00:04:39.660
So if I put one finger down, I receive
a touchstart for that first finger.

00:04:39.660 --> 00:04:43.810
I put another finger down, I'll receive
a touchstart for that second finger.

00:04:43.810 --> 00:04:46.860
Then I'll receive touchmoves as
my fingers move on the screen.

00:04:46.860 --> 00:04:49.220
And touchend when I lift them.

00:04:49.220 --> 00:04:52.720
Now there's a fourth event on this
screen and it's called touchcancel.

00:04:52.720 --> 00:04:54.950
Touchcancel means something unusual kind of happened.

00:04:54.950 --> 00:04:56.620
Touches were interrupted.

00:04:56.620 --> 00:05:02.850
Maybe you got a phone call or you
hit the screen with your whole hand.

00:05:02.850 --> 00:05:04.990
Normally that works.

00:05:04.990 --> 00:05:07.520
Apparently I can't be unusual enough today.

00:05:07.520 --> 00:05:09.650
Touchcancel means something unusual happened.

00:05:09.650 --> 00:05:11.370
Your touches were interrupted.

00:05:11.370 --> 00:05:14.080
Basically all the touches are being reset.

00:05:14.080 --> 00:05:17.390
So if you're keeping track of any
state, you need to reset that.

00:05:17.390 --> 00:05:22.920
So I talked about four basic events in the touch event
model, four events that are delivered to your page.

00:05:22.920 --> 00:05:27.580
There's touchstart, that gets sent every time
a finger is placed on the screen; touchmove,

00:05:27.580 --> 00:05:34.650
gets sent every time a finger moves on the screen; touchend
when a finger is removed from the screen; and touchcancel,

00:05:34.650 --> 00:05:38.900
touches have been interrupted,
reset all of your state, start over.

00:05:40.690 --> 00:05:44.080
Using all of these things, we can build a button.

00:05:44.080 --> 00:05:48.940
"But wait," all of you are saying, "We have buttons.

00:05:48.940 --> 00:05:49.790
We have lots of buttons.

00:05:49.790 --> 00:05:55.030
We have input buttons and the button in element, why,
why do we need to build a button with touch events?"

00:05:55.030 --> 00:05:59.450
I can think of two reasons we might want to
build our own custom button with touch events.

00:05:59.450 --> 00:06:03.420
First, remember how there is that really
short delay while Safari is trying to figure

00:06:03.420 --> 00:06:06.970
out if you're trying to click on an element or pan around?

00:06:06.970 --> 00:06:09.610
If we use touch events, we get first crack at those events

00:06:09.610 --> 00:06:13.410
and we can build something that
responds immediately to user input.

00:06:13.410 --> 00:06:16.760
Second, all those mouse events come at once.

00:06:16.760 --> 00:06:20.240
If we want to build a button that say
looks depressed when you're pressing

00:06:20.240 --> 00:06:23.080
down on it, we'll need to use touch events for that.

00:06:23.080 --> 00:06:27.400
So, the markup for this is going to be really simple.

00:06:27.400 --> 00:06:29.270
We're going to build a button out of a div.

00:06:29.270 --> 00:06:33.030
You can use a button or an input element
if you'd like to be a little more semantic,

00:06:33.030 --> 00:06:35.470
but that brings with it some default browser style.

00:06:35.470 --> 00:06:39.280
For this example, we're just going to use a div element.

00:06:39.280 --> 00:06:43.720
And in the JavaScript side, we need a callback,
something that happens when that button is tapped.

00:06:43.720 --> 00:06:49.170
We could show or hide another part of the user
interface or take the user to a different page.

00:06:49.170 --> 00:06:53.910
Whatever happens when we tap that
button, that's our callback method.

00:06:53.910 --> 00:06:59.950
Then we'll use document.getElementById to find that
button on the DOM, hold onto a reference for the element

00:06:59.950 --> 00:07:04.500
and we'll add an event listener, touchstart
seems like a natural place to start.

00:07:04.500 --> 00:07:08.690
We'll pass in the callback so that when
we tap that button, we do something.

00:07:08.690 --> 00:07:10.460
Let's take a look at how this works.

00:07:10.460 --> 00:07:14.120
So this is a button, very simple,
it's a div with a touch start handler.

00:07:14.120 --> 00:07:18.460
And I'm going to place my finger
on it and the button was tapped.

00:07:18.460 --> 00:07:20.040
But that doesn't really feel right.

00:07:20.040 --> 00:07:23.040
The button is tapped as soon as I
put my finger down on the screen.

00:07:23.040 --> 00:07:27.100
Normally we want to put our finger down,
wait and then when we lift our finger,

00:07:27.100 --> 00:07:29.300
that's when we want the event to be dispatched.

00:07:29.300 --> 00:07:32.540
So we'll make a really quick modification to the code.

00:07:32.540 --> 00:07:39.020
Instead of registering on touchstart, let's listen
for a touchend event and see how that works instead.

00:07:39.020 --> 00:07:42.430
Modified button, I can place my finger down on the button

00:07:42.430 --> 00:07:46.020
and then when I lift my finger, we
get our callback function called.

00:07:46.020 --> 00:07:49.000
That feels a lot more natural.

00:07:49.000 --> 00:07:52.720
So far, there's nothing that complicated about this button.

00:07:52.720 --> 00:07:56.120
It doesn't really do much, it doesn't do any of
the really cool things that I said we could do,

00:07:56.120 --> 00:07:59.300
like make it look depressed when we're pressing down on it.

00:07:59.300 --> 00:08:01.930
And our code is already starting to get a little messy.

00:08:01.930 --> 00:08:06.670
We're pulling out elements individually, we're
registering these sort of floating methods.

00:08:06.670 --> 00:08:08.130
We want to keep our code clean.

00:08:08.130 --> 00:08:13.990
We want to keep it reusable, especially with touch
events where we have to keep track of a lot of details.

00:08:13.990 --> 00:08:16.000
So let's wrap it all up into a JavaScript class.

00:08:16.000 --> 00:08:22.700
I have a constructor, capital B button it takes
in 2 parameters, an elementID and a callback.

00:08:22.700 --> 00:08:28.650
We'll use the exact same getelementbyID to pull
the element out of the DOM, store it for later use.

00:08:28.650 --> 00:08:30.330
We'll keep the callback around for later use.

00:08:30.330 --> 00:08:35.070
And then we'll add our event listener
near a touchstart and touchend.

00:08:35.070 --> 00:08:38.770
There is something kind of unusual
about this form of addEventListener.

00:08:38.770 --> 00:08:41.170
Normally addEventListener takes three properties.

00:08:41.170 --> 00:08:45.850
It takes the name of the event, it takes
the callback method and then it takes

00:08:45.850 --> 00:08:49.160
in this false Boolean that we always pass in.

00:08:49.160 --> 00:08:50.910
But here I'm passing in an object.

00:08:50.910 --> 00:08:52.590
I'm passing in this.

00:08:52.590 --> 00:08:55.150
This is a somewhat unusual form of addEventListener.

00:08:55.150 --> 00:09:01.930
But what happens is if you register events
passing in an object, when that event occurs,

00:09:01.930 --> 00:09:05.980
the handleEvent method, it's a special name, handleEvent.

00:09:05.980 --> 00:09:08.920
That gets called on the object in question.

00:09:08.920 --> 00:09:13.740
So instead of having to keep around the
closure and store this and put it into self

00:09:13.740 --> 00:09:21.770
and create anonymous inline function so we can call on the
right object later, this is one way we can get around that.

00:09:21.770 --> 00:09:24.940
I want to do something kind of tricky
to keep our code a little simple.

00:09:24.940 --> 00:09:31.360
Event.type on a DOM event is the name of the
event, touchstart or touchend, something like that.

00:09:31.360 --> 00:09:39.060
I'm using subscript notation to look on this on our button
instance to find a property named touchstart or touchend.

00:09:39.060 --> 00:09:41.830
And then I'm going to make sure it's a function.

00:09:41.830 --> 00:09:45.090
And if it is, I'm going to call it.

00:09:45.090 --> 00:09:50.610
This is a bit unusual but what this means is we don't
have to sit around and register touchstart handler

00:09:50.610 --> 00:09:57.510
for touchstart events and touchend handler for touchend
events on our, on our button class, on our prototype,

00:09:57.510 --> 00:09:59.990
we just create methods called touchstart and touchend.

00:09:59.990 --> 00:10:03.410
And those get called when we get our events.

00:10:03.410 --> 00:10:07.120
In order to do our highlighted state,
I'm just going to set a classing,

00:10:07.120 --> 00:10:09.770
add a new class highlighted on the actual element.

00:10:09.770 --> 00:10:12.080
Then in CSS we can do whatever we need to do.

00:10:12.080 --> 00:10:18.650
We can change the background image or make it a
different color or make it explode into 1000 tiny pieces.

00:10:18.650 --> 00:10:21.660
And on touchend we also want to call our callback function.

00:10:21.660 --> 00:10:29.480
In the CSS, I'm using something kind
of neat to create this lozenge shape.

00:10:29.480 --> 00:10:35.160
If you set a height and then use a -border-radius to
round off those edges, you can get a lozenge shape

00:10:35.160 --> 00:10:37.430
without having to use any sort of images.

00:10:37.430 --> 00:10:43.840
And then the background I'm using webkit-gradient to
create that sort of really nice, light to dark effect.

00:10:43.840 --> 00:10:48.630
When the button is highlighted, you just reverse
the gradient so it looks depressed instead.

00:10:48.630 --> 00:10:54.670
It's really simple way to create a button that looks
really nice, looks very visual without using any images.

00:10:54.670 --> 00:10:59.730
So let's take a look at how this button works now.

00:10:59.730 --> 00:11:09.050
With our new event handlers and that extra CSS styling,
when I tap down on the button, it looks depressed.

00:11:09.050 --> 00:11:14.460
It responds immediately and when I remove my
finger, it pops back out, the callback gets called.

00:11:14.460 --> 00:11:18.380
It's a really nice way of keeping your code simple.

00:11:18.380 --> 00:11:23.710
Now, we've handled touchstart and touchend, but
there's that fourth mysterious touchcancel event.

00:11:23.710 --> 00:11:25.850
We need to make sure we handle this.

00:11:25.850 --> 00:11:28.500
Touchcancel can happen for a variety of reasons.

00:11:28.500 --> 00:11:32.240
A JavaScript alert pops up, you get a phone
call while you're using your web page.

00:11:32.240 --> 00:11:36.620
And it's important that you reset any state,
anything that you're doing with touch events.

00:11:36.620 --> 00:11:40.740
So in this case, on touchcancel,
we'll simply remove that extra class.

00:11:40.740 --> 00:11:44.790
Otherwise you might come back from a phone
call and your button is stuck depressed.

00:11:44.790 --> 00:11:51.410
And that's one way that we can build a button
that responds immediately to touch events.

00:11:51.410 --> 00:11:54.300
So we've talked about the four basic touch events.

00:11:54.300 --> 00:11:56.990
Touchstart, fingers placed on the screen.

00:11:56.990 --> 00:11:59.580
Touchmove, a finger on the screen moves.

00:11:59.580 --> 00:12:02.570
Touchend, a finger has been removed from the screen.

00:12:02.570 --> 00:12:07.140
And touchcancel, touches have been
interrupted, don't forget to handle this.

00:12:07.140 --> 00:12:11.510
For the rest of the examples I'm not going to
walk through explicitly what I do on touchcancel.

00:12:11.510 --> 00:12:14.860
But look at the sample code and
make sure you handle touchcancel.

00:12:14.860 --> 00:12:17.990
But that's just the start.

00:12:17.990 --> 00:12:20.810
It tells us when fingers on the screen, what they're doing,

00:12:20.810 --> 00:12:23.960
but it doesn't really give us information
about the fingers themselves.

00:12:23.960 --> 00:12:27.040
What if we need to know where a finger is on the screen?

00:12:27.040 --> 00:12:33.790
If we think back to mouse events and we look at
a mouse event object, it looks pretty familiar.

00:12:33.790 --> 00:12:39.080
We can immediately look at that object and figure out
what button is down, the left or the right mouse button,

00:12:39.080 --> 00:12:43.590
where on the screen the cursor is, whether
or not any modifier keys are being held down.

00:12:43.590 --> 00:12:47.640
But if we look at a touch event, it looks really small.

00:12:47.640 --> 00:12:48.680
There's not much there.

00:12:48.680 --> 00:12:50.580
What is this changedTtouches?

00:12:50.580 --> 00:12:52.570
Where are my screen coordinates?

00:12:52.570 --> 00:12:58.790
The important thing to remember is that a touch event,
because we have multiple fingers, is a list of touches.

00:12:58.790 --> 00:13:01.890
What you're given is actually a list of touches.

00:13:01.890 --> 00:13:04.100
There are three lists actually.

00:13:04.100 --> 00:13:05.790
There's the touches list.

00:13:05.790 --> 00:13:10.090
That's all the touches that are
currently active or down on the screen.

00:13:10.090 --> 00:13:15.140
So if I have five fingers on the screen, those
five finger will be in the touches array.

00:13:15.140 --> 00:13:16.980
There's changedTouches.

00:13:16.980 --> 00:13:21.190
These are the fingers that have
changed since the last event.

00:13:21.190 --> 00:13:26.090
If I have two fingers on the screen and I'm
moving one, and the other is staying still,

00:13:26.090 --> 00:13:29.170
changedTouches will contain only the finger that's moving.

00:13:29.170 --> 00:13:31.970
And touches will contain both of them.

00:13:31.970 --> 00:13:34.440
And lastly there's targetTouches.

00:13:34.440 --> 00:13:36.950
These are touches that are inside the target element.

00:13:36.950 --> 00:13:43.170
So if I'm tapping on an image for example,
then the fingers that are inside the bounds

00:13:43.170 --> 00:13:45.410
of that image are inside of targetTouches.

00:13:45.410 --> 00:13:50.640
Now these lists are more or less array
like, so they have a length property.

00:13:50.640 --> 00:13:57.120
So you could look at e.touches.length, event.touches.length
and that's the number of fingers currently on the screen.

00:13:57.120 --> 00:14:00.800
Or if we wanted to get the first
finger inside the target element,

00:14:00.800 --> 00:14:03.870
we can use subscript notation, loop over them with arrays.

00:14:03.870 --> 00:14:09.330
All those sorts of things we're familiar with,
with arrays, will work on these touch lists.

00:14:09.330 --> 00:14:14.440
So a touch event is a list of objects, is a list of touches.

00:14:14.440 --> 00:14:17.450
Let's look at the individual touch.

00:14:17.450 --> 00:14:20.630
The first property on a touch is an identifier.

00:14:20.630 --> 00:14:25.670
This is a unique number that you can use to keep
track of a single finger across multiple events.

00:14:25.670 --> 00:14:29.700
Don't hold onto a touch object itself, you'll
prevent it from being garbage collected.

00:14:29.700 --> 00:14:34.440
Hold on to this number instead if you need
to keep track of an individual finger.

00:14:34.440 --> 00:14:35.620
Then there's target.

00:14:35.620 --> 00:14:37.690
This is the DOM node that is the target.

00:14:37.690 --> 00:14:41.460
So if we're tapping on that image,
then this will be the image.

00:14:41.460 --> 00:14:46.530
And then there's two sets of coordinates,
screen coordinates and page coordinates.

00:14:46.530 --> 00:14:54.510
If we tap here on this iPhone 4, screen
coordinates are the position of the tap

00:14:54.510 --> 00:14:57.470
from the top right hand corner of the screen.

00:14:57.470 --> 00:15:03.890
And if we double tap to zoom in say and we tap in
the same location, page coordinates are the location

00:15:03.890 --> 00:15:07.840
of that tap relative from the top
right hand corner of the page.

00:15:07.840 --> 00:15:09.670
This is in CSS pixels.

00:15:09.670 --> 00:15:13.150
So if you're going to be moving an
element around to respond to a tap,

00:15:13.150 --> 00:15:15.730
this is probably the set of coordinates you want to use.

00:15:15.730 --> 00:15:20.060
If you're simply interested in whether or not the
user is tapping in the top half or the bottom half

00:15:20.060 --> 00:15:22.590
of the screen, that's what screen coordinates are for.

00:15:22.590 --> 00:15:27.040
With all this information we can go on and
build another really cool control, a slider.

00:15:27.040 --> 00:15:32.020
Something that has a track and a
knob and we can move it around.

00:15:32.020 --> 00:15:33.980
Mark up is going to be really simple.

00:15:33.980 --> 00:15:39.570
We're going to use a container div and then inside of
that two divs, one for our track, one for our knob.

00:15:39.570 --> 00:15:41.670
We'll have classes so we can get to those.

00:15:41.670 --> 00:15:44.300
And then there's the constructor.

00:15:44.300 --> 00:15:49.910
We're going to bundle this up to an object just
like we did on the button so we can reuse it.

00:15:49.910 --> 00:15:56.400
We'll pull the main parent, the container div
out of the documents tree with getElementById.

00:15:56.400 --> 00:16:00.760
Then we'll pull the knob out by getting
getElementsByClassname, because we want to have more

00:16:00.760 --> 00:16:05.330
than one slider on the page, we need to use class
names and not IDs in order to pull these out.

00:16:05.330 --> 00:16:11.610
Let's also look at the width of that knob, offsetWidth
is the actual width of that inside the rendered tree.

00:16:11.610 --> 00:16:17.270
We'll use this to do a little bit of math so we
don't drag the knob off the end of the track.

00:16:17.270 --> 00:16:23.610
And then we'll also grab the bar out with
getElementsByClassname and look at its width too.

00:16:23.610 --> 00:16:27.360
The touchstart handler is going to be really simple.

00:16:27.360 --> 00:16:31.380
At the start, we're going to look at the
event and look into that targetTouches array.

00:16:31.380 --> 00:16:36.090
Remember targetTouches is the list of
fingers that is inside the target element.

00:16:36.090 --> 00:16:44.740
We'll grab the first finger and grab its page X
coordinate, location in CSS pixels on the page.

00:16:44.740 --> 00:16:49.930
And we'll store that and then we'll
call this method, this.moveKnobTo.

00:16:49.930 --> 00:16:53.750
We'll get to this, but this is where
we're actually going to do all the work.

00:16:53.750 --> 00:17:01.170
Then on touchmove, we're just going to call moveKnobTo
and again we're going to look at the targetTouches array,

00:17:01.170 --> 00:17:04.950
pull the first finger out, get its page location.

00:17:04.950 --> 00:17:10.270
The moveKnobTo method is where
all the work is going to be done.

00:17:10.270 --> 00:17:13.240
First, we need to figure out how far the finger is moved.

00:17:13.240 --> 00:17:19.510
So we stored that start X at the beginning
when we, we got our first touchstart.

00:17:19.510 --> 00:17:23.380
And we're just going to figure out how
far the finger is from where it started.

00:17:23.380 --> 00:17:26.760
Then we're going to do a little bit of math to make sure

00:17:26.760 --> 00:17:29.680
that we clamp the position of the
knob to the ends of the track.

00:17:29.680 --> 00:17:33.030
We don't want to be able to drag the
knob all the way off to the right.

00:17:33.030 --> 00:17:37.940
And then we'll just set the left
style property inline of the knob.

00:17:37.940 --> 00:17:41.410
And that's going to position it along the track.

00:17:41.410 --> 00:17:46.500
We'll hold onto the starting position for the next time we
call it through this loop and then we'll notify our callback

00:17:46.500 --> 00:17:52.110
and say now that the slider has been moved,
here's where it is, do whatever you need to do.

00:17:52.110 --> 00:17:58.040
Now, for performance reasons, instead of
setting the left property on that, on that knob,

00:17:58.040 --> 00:18:01.560
we might want to use this instead, a webkitTransform.

00:18:01.560 --> 00:18:05.260
Left will work, but if we want
the best possible performance,

00:18:05.260 --> 00:18:08.730
this is really important for building
user interface widgets.

00:18:08.730 --> 00:18:13.070
Use webkitTransform instead with a translate3d property.

00:18:13.070 --> 00:18:19.850
We'll construct a string, set the X transform
to the X offset and then Y and Z offsets to 0.

00:18:19.850 --> 00:18:26.030
Under certain conditions this will actually
trigger hardware compositing, so we'll reload,

00:18:26.030 --> 00:18:29.100
we'll offload the positioning of this knob to the GPU.

00:18:29.100 --> 00:18:30.980
It'll work super fast.

00:18:30.980 --> 00:18:37.010
And that's the basics of building
something that will track your finger.

00:18:37.010 --> 00:18:38.390
I've been talking too much.

00:18:38.390 --> 00:18:42.500
So, instead of showing you this myself, I'd
like to invite up Greg Bolsinga, my coworker.

00:18:42.500 --> 00:18:46.270
And he's going to show you these controls and
a few others in a demo we've been working on.

00:18:46.270 --> 00:18:47.510
Greg?

00:18:47.510 --> 00:18:51.050
[ Applause ]

00:18:51.050 --> 00:19:00.180
>> Hello, I'm Greg Bolsinga, I work
on iPhone or iOS, WebKit, and Safari.

00:19:00.180 --> 00:19:07.790
So with all those parts that Paul put together
for us, I built this little scrapbook application.

00:19:07.790 --> 00:19:11.040
It's just a web page, we have an image here.

00:19:11.040 --> 00:19:20.720
And what you can do to this is play with your
image and move it around with single touches.

00:19:20.720 --> 00:19:27.660
And I created this only using HTML, JavaScript, and CSS.

00:19:27.660 --> 00:19:32.660
The only non-text, non-code portions are these images.

00:19:32.660 --> 00:19:38.960
So the first thing that I set up was
playing with some of the CSS properties.

00:19:38.960 --> 00:19:43.440
And what I can do is set the border width of the picture.

00:19:43.440 --> 00:19:45.850
These are all regular CSS properties.

00:19:45.850 --> 00:19:50.300
I can set the border radius, if
you can see that curving down here.

00:19:50.300 --> 00:19:56.170
Another thing you can do is I played with the box shadow.

00:19:56.170 --> 00:20:01.670
I have this little scroller here where we could
see more properties that I could set on here.

00:20:01.670 --> 00:20:07.250
And with the box shadow we could
pop it out either direction.

00:20:07.250 --> 00:20:09.300
We'll move it down here.

00:20:09.300 --> 00:20:14.620
Put a little blur on it so it looks
pretty, looks blurry up there.

00:20:14.620 --> 00:20:17.030
And so we have our image.

00:20:17.030 --> 00:20:22.980
The other thing that I did with this is with
the multitouch I could move these things around

00:20:22.980 --> 00:20:27.270
and I'm setting the CSS transforms that Paul mentioned.

00:20:27.270 --> 00:20:31.060
And I'm just translating it here,
but we also support gesture events.

00:20:31.060 --> 00:20:39.460
So as soon as you put more than one finger down, I could
start rotating this image as well as scaling it in.

00:20:39.460 --> 00:20:44.550
And what I'll play with now is I have these masks.

00:20:44.550 --> 00:20:50.160
These masks are all HTML canvases.

00:20:50.160 --> 00:20:51.680
So I drew all these masks.

00:20:51.680 --> 00:20:57.990
I'm going to be using the same canvas that
drew these buttons as I'll have on here.

00:20:57.990 --> 00:21:04.210
So for example, I can mask the image with just a circle.

00:21:04.210 --> 00:21:15.180
Or I can pick other fun shapes like the star
and I could still interact with the image here.

00:21:15.180 --> 00:21:21.480
Zoom in and rotate it, even through the mask.

00:21:21.480 --> 00:21:28.930
And I'm going to take the mask off so
we can see the other images that I have.

00:21:28.930 --> 00:21:29.150
[ Silence ]

00:21:29.150 --> 00:21:30.660
Re-translate this.

00:21:30.660 --> 00:21:40.900
And what I have here is another little scroller
inside of a scroller and you could pick new images.

00:21:40.900 --> 00:21:44.160
And do the same fun effects with it.

00:21:44.160 --> 00:21:49.290
This will all, the code and the pictures
for this will all be up on our website.

00:21:49.290 --> 00:21:59.510
So again, that's all HTML, JavaScript, and CSS using touch
events, gesture events and CSS effects and transforms.

00:21:59.510 --> 00:22:06.160
[ Applause ]

00:22:06.160 --> 00:22:07.000
>> Thanks Greg.

00:22:07.000 --> 00:22:11.980
Greg mentioned this, but the only images in
that demo are the four photos on the thumbnails.

00:22:11.980 --> 00:22:17.840
Everything else was canvas, CSS,
really cool tricks like that.

00:22:17.840 --> 00:22:24.070
So Greg introduced something that I've been kind of
talking about a lot and these are multitouch devices.

00:22:24.070 --> 00:22:27.330
You can have more than one finger,
but we haven't talked about that yet.

00:22:27.330 --> 00:22:31.360
We haven't talked about dealing with a second finger.

00:22:31.360 --> 00:22:35.860
There's a separate set of events that you receive
once a second finger comes into the picture.

00:22:35.860 --> 00:22:40.500
And this is very much like the earlier event
demos, the button, the bubbles just highlight

00:22:40.500 --> 00:22:42.240
when we receive one of these events on the page.

00:22:42.240 --> 00:22:44.900
And there's three gesture events.

00:22:44.900 --> 00:22:48.910
Gesture events start once a second
finger is placed on the screen.

00:22:48.910 --> 00:22:50.630
So I'll place one finger on the screen.

00:22:50.630 --> 00:22:55.680
And when I place the second finger on the
screen, we receive a gesturestart event.

00:22:55.680 --> 00:23:01.340
And so then I have two fingers on the screen and I move
them around and receive a series of gesturechange events.

00:23:01.340 --> 00:23:05.850
And then when I remove a second
finger, we get a gestureend event.

00:23:05.850 --> 00:23:08.590
Now these events are not exclusive from touch events.

00:23:08.590 --> 00:23:11.550
We'll receive both at the same time.

00:23:11.550 --> 00:23:19.000
So here both touch events and gesture event bubbles
first finger on the screen will send a touchstart.

00:23:19.000 --> 00:23:25.110
Second finger on the screen will send a
gesturestart and a touchstart for the second finger.

00:23:25.110 --> 00:23:30.470
We'll receive both touchmoves and
gesturechanges as I move my fingers.

00:23:30.470 --> 00:23:35.290
And we'll receive touchends and gestureends
for all of those as I remove them.

00:23:35.290 --> 00:23:40.530
One more time, touchstart, second finger
sends both touchstart and gesturestart.

00:23:40.530 --> 00:23:42.340
These events are all interleaved.

00:23:42.340 --> 00:23:47.720
And gestureend and touchends when I remove those fingers.

00:23:47.720 --> 00:23:51.280
So there are three events in the gesture event model.

00:23:51.280 --> 00:23:54.670
Gesturestart, second finger on the screen.

00:23:54.670 --> 00:23:58.080
Gesturechange, something is going
on with those multiple fingers.

00:23:58.080 --> 00:24:01.260
Gestureend, second finger removed from the screen.

00:24:01.260 --> 00:24:05.930
There's one thing missing here you might notice,
gesturecancel, there is no gesturecancel.

00:24:05.930 --> 00:24:11.930
But because you receive both touch events and gesture
events at the same time, you still need to handle it,

00:24:11.930 --> 00:24:17.400
listen for touchcancel even if all
you're doing is gesture handling events.

00:24:17.400 --> 00:24:22.490
The gesture event object is actually really
simple and looks a lot more familiar.

00:24:22.490 --> 00:24:24.660
First, there's scale.

00:24:24.660 --> 00:24:27.430
Scale is multiplier, it's a float.

00:24:27.430 --> 00:24:32.390
If I put two fingers on the screen and they're 100
pixels apart, and I move those two fingers apart

00:24:32.390 --> 00:24:37.570
so they're now 200 pixels apart, then
that scale property is going to be 2.0.

00:24:37.570 --> 00:24:41.350
My fingers are twice as far as
when I put them on the screen.

00:24:41.350 --> 00:24:44.770
If I put my fingers down at 100
pixels apart and bring them together

00:24:44.770 --> 00:24:49.170
so they're only 50 pixels apart,
that scale is going to be 0.5.

00:24:49.170 --> 00:24:52.860
My fingers are half as far apart as they used to be.

00:24:52.860 --> 00:24:54.800
Then there's rotation.

00:24:54.800 --> 00:24:57.350
Rotation is, are you ready for this?

00:24:57.350 --> 00:25:01.230
Degrees clockwise relative to the starting position.

00:25:01.230 --> 00:25:07.780
So if I have 2 fingers and I rotate my fingers
like this, that rotation is going to be 90,

00:25:07.780 --> 00:25:12.010
90 degrees clockwise relative from the starting position.

00:25:12.010 --> 00:25:14.400
And then there's page coordinates.

00:25:14.400 --> 00:25:21.190
Again these are coordinates from the top right hand corner
of the page, they're in CSS pixels and this is the center

00:25:21.190 --> 00:25:24.990
of the gesture or the center of where all your fingers are.

00:25:24.990 --> 00:25:30.970
So with all of that, we now have the information
we need to build the rest of the picture frame.

00:25:30.970 --> 00:25:34.950
We've already basically built the
translation, the panning of the picture.

00:25:34.950 --> 00:25:40.750
That's just tracking fingers in their X and Y
coordinates, but the multitouch part which is new.

00:25:40.750 --> 00:25:44.080
The picture frame is actually deceptively easy to build.

00:25:44.080 --> 00:25:46.520
It contains only two parts.

00:25:48.630 --> 00:25:51.490
The image is actually larger than the frame.

00:25:51.490 --> 00:25:55.930
We can use something like overflow: none
on the frame to crop the image down.

00:25:55.930 --> 00:26:00.530
But the frame is a separate element that contains the image.

00:26:00.530 --> 00:26:01.670
It's just a div.

00:26:01.670 --> 00:26:05.870
We give it a class pictureFrame and
then underneath it is the image.

00:26:05.870 --> 00:26:09.530
That's it, they're the only two parts
to building this frame, two elements.

00:26:09.530 --> 00:26:12.620
When we set overflow: none on that frame, we crop the image.

00:26:12.620 --> 00:26:16.630
And when we do all these panning
effects and these rotation effects,

00:26:16.630 --> 00:26:19.630
all we're doing is we're moving the image behind the frame.

00:26:19.630 --> 00:26:21.620
The frame stays in the same place.

00:26:21.620 --> 00:26:26.560
We're scaling the image, applying these webkitTransforms.

00:26:26.560 --> 00:26:34.950
And when overflow: none is in effect, we get
this really nice sort of in frame editing effect.

00:26:34.950 --> 00:26:42.370
So the mark up is super simple, container
div, image on the inside of that.

00:26:42.370 --> 00:26:47.720
Our constructor is going to take just one parameter
element, we don't really have a callback for this.

00:26:47.720 --> 00:26:50.900
And we're going to hold on to a little more state.

00:26:50.900 --> 00:26:57.390
Gesture events, the information they report, the scale and
the rotation, they're relative to the start of the gesture.

00:26:57.390 --> 00:27:02.270
So we'll hold on both to the current scale
and rotation of the picture and the scale

00:27:02.270 --> 00:27:05.510
and the rotation when the gesture starts.

00:27:05.510 --> 00:27:08.330
And then we pull the image out with getElementsByTagName.

00:27:08.330 --> 00:27:11.500
And then we listen for gesturechange events.

00:27:11.500 --> 00:27:14.500
Again this is just for the rotation and the scaling.

00:27:14.500 --> 00:27:18.130
The panning we want to use touch events.

00:27:18.130 --> 00:27:21.480
Gesturechange is going to be really straight forward.

00:27:21.480 --> 00:27:24.070
We look at the scale of when we started the gesture.

00:27:24.070 --> 00:27:27.420
And we multiply it by the gesture scale.

00:27:27.420 --> 00:27:35.590
So if the image starts out at 200% and we bring our fingers
together so that the scale on the gesture event is 0.5,

00:27:35.590 --> 00:27:40.360
we multiply them and we shrink our
image back down to original size.

00:27:40.360 --> 00:27:46.100
Then rotation, there are degrees relative from
the starting location, so we just add that.

00:27:46.100 --> 00:27:49.240
And then we call this mysterious transformImage method.

00:27:49.240 --> 00:27:53.460
TransformImage is where we're actually going
to apply the properties and do the work.

00:27:53.460 --> 00:27:55.250
It's a single line.

00:27:55.250 --> 00:28:00.300
We're going to set an inline webkitTransform
style and build up this string.

00:28:00.300 --> 00:28:01.960
First we're going to translate the image.

00:28:01.960 --> 00:28:09.850
If we're positioning it 100 pixels left, 100 pixels
up, we're going to set both X and Y transforms there.

00:28:09.850 --> 00:28:12.030
Then we're going to scale the image.

00:28:12.030 --> 00:28:16.390
WebkitTransform takes in the same sort of
units that the gesture event will report.

00:28:16.390 --> 00:28:18.970
So it's easy just to translate this over into CSS.

00:28:18.970 --> 00:28:24.490
And then the rotation, the unit
for rotation is degrees, deg.

00:28:24.490 --> 00:28:28.780
And we're going to build up this string, that
concatenation is really kind of ugly in code.

00:28:28.780 --> 00:28:31.170
But what we're building is a string that looks like this.

00:28:31.170 --> 00:28:36.700
Translate3d, X and Y coordinate, scale, and rotate.

00:28:36.700 --> 00:28:37.580
And that's it.

00:28:37.580 --> 00:28:40.370
That's all we need to do to build our picture.

00:28:40.370 --> 00:28:45.270
All we need to do to handle scaling and rotation.

00:28:45.270 --> 00:28:48.390
I want to step back and talk about the DOM Event Model.

00:28:48.390 --> 00:28:54.790
All of these events, mouse events, touch events, gesture
events, these all fall under the system called DOM events.

00:28:54.790 --> 00:28:56.400
Here we have a DOM tree.

00:28:56.400 --> 00:29:01.030
There's two of these picture frame
controllers in the same document.

00:29:01.030 --> 00:29:07.430
And we're going to send an event down to say
we tap on the second picture frame control.

00:29:07.430 --> 00:29:14.420
So we have an event and using hit testing or something
like that, we figure out where this event is going.

00:29:14.420 --> 00:29:17.050
It's going to that second image in the document.

00:29:17.050 --> 00:29:19.000
The event is going to start at the top.

00:29:19.000 --> 00:29:22.720
It's going to start at your Window object,
from the browser and it's going to work its way

00:29:22.720 --> 00:29:24.860
down to the specific event it's trying to get to.

00:29:24.860 --> 00:29:26.710
It's going to work its way down to the <img>.

00:29:26.710 --> 00:29:29.360
This is called the capture phase.

00:29:29.360 --> 00:29:35.260
This event is going to be dispatched to every one of these
elements all the way from Window to Document, <html>,

00:29:35.260 --> 00:29:40.290
<body>, then eventually our picture frame
control, the containing <div>, and then the <img>.

00:29:40.290 --> 00:29:47.320
And any one of these elements that have a capture
phase event listener we'll get to handle this event.

00:29:47.320 --> 00:29:52.880
The event will reach our target element, the image, and
then it's going to start working its way back the other way.

00:29:52.880 --> 00:29:54.620
This is called the bubbling phase.

00:29:54.620 --> 00:29:59.920
The event starts at the most specific element
and starts working its way back up to the top.

00:29:59.920 --> 00:30:04.370
Once it reaches the top, returns
to the browser from whence it came.

00:30:04.370 --> 00:30:08.200
Normally we only work in the bubbling phase.

00:30:08.200 --> 00:30:10.520
Remember how addEventListener has three properties.

00:30:10.520 --> 00:30:15.170
It takes in the name of the event,
the callback or object and then false.

00:30:15.170 --> 00:30:17.180
We always just put false in there.

00:30:17.180 --> 00:30:23.560
That third Boolean is whether or not we're adding our
event listener to the capture phase or the bubble phase.

00:30:23.560 --> 00:30:29.280
If it's false, it's in the bubble phase and if
it's true, we're listening in the capture phase.

00:30:29.280 --> 00:30:30.310
We normally don't want that.

00:30:30.310 --> 00:30:36.600
We normally want to start from the most specific element
and then let event bubble up to less specific elements.

00:30:36.600 --> 00:30:39.220
But occasionally capture events are a really useful thing.

00:30:39.220 --> 00:30:42.410
If you're having a problem with a web
page and you're trying to debug it,

00:30:42.410 --> 00:30:45.480
you might want to add a capture event listener on document.

00:30:45.480 --> 00:30:51.120
It'll see basically every event
that goes down into your page.

00:30:51.120 --> 00:30:54.250
So with this in mind, let's go back to
these really cool controls we're building

00:30:54.250 --> 00:30:57.550
and we'll talk about this single finger scrolling pane.

00:30:57.550 --> 00:31:03.570
Now on desktop, if we want this area where we
have content and we can scroll it and it stays

00:31:03.570 --> 00:31:09.470
within this nice little frame, one way we might do
that is by using a div with overflow set to auto.

00:31:09.470 --> 00:31:14.220
The child contents larger than the,
than the div, we'll get scroll bars,

00:31:14.220 --> 00:31:17.420
we can use scroll wheels, all that sort of stuff.

00:31:17.420 --> 00:31:21.090
This actually works on iPhone and iOS.

00:31:21.090 --> 00:31:24.820
But you have to use two fingers
at once to scroll that content.

00:31:24.820 --> 00:31:26.240
It's not really discoverable.

00:31:26.240 --> 00:31:28.300
A lot of people have trouble finding that.

00:31:28.300 --> 00:31:33.270
So instead we're going to build an area that we can
scroll using just one finger, using touch events.

00:31:33.270 --> 00:31:37.620
So the mark up or the actual implementation
for this is extremely simple.

00:31:37.620 --> 00:31:39.810
In fact we've basically already built it.

00:31:39.810 --> 00:31:41.100
It's got two parts.

00:31:41.100 --> 00:31:43.970
It has the content underneath.

00:31:43.970 --> 00:31:47.560
The child layer, the content layer I suppose we can call it.

00:31:47.560 --> 00:31:49.730
This contains whatever we need it to contain.

00:31:49.730 --> 00:31:56.340
It could be lists, it could be images, it could be other
scrolling panes because we're programs, we like recursion,

00:31:56.340 --> 00:31:59.190
we like putting things into things because we can.

00:31:59.190 --> 00:32:01.670
And then outside of that there's the panel container.

00:32:01.670 --> 00:32:07.240
This'll have overflow: none set, it'll stay fixed
on the page and when we receive touch events,

00:32:07.240 --> 00:32:13.170
we'll simply translate that content layer, we'll
move that content layer around using webkitTransform.

00:32:13.170 --> 00:32:17.130
And we'll get a really nice single finger scrolling area.

00:32:17.130 --> 00:32:19.430
The mark up we're going to use for this is really simple.

00:32:19.430 --> 00:32:22.910
There's an outer scrollable class,
this is the, this is the frame.

00:32:22.910 --> 00:32:25.740
And then inside of that is our content layer.

00:32:25.740 --> 00:32:29.240
It can contain whatever we want it to contain.

00:32:29.240 --> 00:32:30.620
So let's take a look at this.

00:32:30.620 --> 00:32:35.810
I have here one of these scrolling views,
these scroll panels, scroll containers.

00:32:35.810 --> 00:32:39.190
And inside of it, it's a list, it just counts from 1 to 8.

00:32:39.190 --> 00:32:48.520
And I'm going to use a single finger and start
scrolling and that doesn't work very well.

00:32:48.520 --> 00:32:54.550
As I'm scrolling, as I'm trying to scroll
this container, the page is panning too.

00:32:54.550 --> 00:32:55.700
What's going on here?

00:32:55.700 --> 00:33:00.420
It really helps if we go back to the DOM Event
Model, the DOM tree to understand what's going on.

00:33:00.420 --> 00:33:05.820
This is a DOM tree where we have two of these scrolling
containers and we're receiving a touchmove event.

00:33:05.820 --> 00:33:08.730
Touchmove is how we're panning that content.

00:33:08.730 --> 00:33:15.120
So the touchmove starts the Content, it moves to the
Container, we actually do something like scroll our content.

00:33:15.120 --> 00:33:16.520
And then the event keeps going.

00:33:16.520 --> 00:33:17.810
It keeps bubbling.

00:33:17.810 --> 00:33:21.780
It goes all the way back up to the
browser and the browser gets to handle it.

00:33:21.780 --> 00:33:23.690
Safari gets a crack at that event.

00:33:23.690 --> 00:33:29.390
Now Safari's default action, what Safari usually
does on a touchmove event is it pans the page.

00:33:29.390 --> 00:33:36.840
This isn't necessarily the case with say a desktop browser
where a mouse move pans, pans the page or scrolls the page.

00:33:36.840 --> 00:33:43.790
But these default actions always bubble up to the
browser and the browser does its default thing.

00:33:43.790 --> 00:33:49.000
Instead of letting that happen, what we really
want to do is after we handle the touchmove event,

00:33:49.000 --> 00:33:55.000
after we scroll out content, we want to let
Safari know that we've handled the event.

00:33:55.000 --> 00:33:56.150
We've taken care of it.

00:33:56.150 --> 00:33:58.270
Safari shouldn't do its default thing.

00:33:58.270 --> 00:33:59.960
And there's a method for that.

00:33:59.960 --> 00:34:01.790
It's called preventDefault.

00:34:01.790 --> 00:34:05.450
We call this on the event, the event gets canceled.

00:34:05.450 --> 00:34:08.050
It's marked as already having been handled.

00:34:08.050 --> 00:34:13.430
The event will still continue to propagate, it'll go all
the way back up to Safari, but once it reaches there,

00:34:13.430 --> 00:34:17.890
Safari will see the event has been handled
and it won't do its default action.

00:34:17.890 --> 00:34:26.330
So if we go back to our scroller and we add that
preventDefault call and we try sending touchmoves to scroll.

00:34:26.330 --> 00:34:28.010
Now it works great.

00:34:28.010 --> 00:34:30.680
We have this pane that we can scroll
with just a single finger.

00:34:30.680 --> 00:34:35.150
Now I said we can put anything we want in here.

00:34:35.150 --> 00:34:37.500
We can put another scroller perhaps.

00:34:37.500 --> 00:34:39.560
So let's try that.

00:34:39.560 --> 00:34:42.750
Here's another scroller, the individual
items are a little bit larger,

00:34:42.750 --> 00:34:45.780
but we still have these same numbers and we're counting up.

00:34:45.780 --> 00:34:52.500
And then I have this imbedded lists that counts
letters instead, you can count letters I suppose.

00:34:52.500 --> 00:34:56.120
And let's try scrolling, we're going to see that it works.

00:34:56.120 --> 00:35:00.220
Terribly. They're both scrolling.

00:35:00.220 --> 00:35:02.770
They're both scrolling at the same time.

00:35:02.770 --> 00:35:04.920
If I scroll on the outer one, it's fine.

00:35:04.920 --> 00:35:13.370
But as I'm trying to scroll this internal, this interior
letter list, both scrollers are trying to scroll.

00:35:13.370 --> 00:35:15.790
What's going on here?

00:35:15.790 --> 00:35:20.950
Again, it really helps if we go back to the DOM
Event Model, see what's going on with these events.

00:35:20.950 --> 00:35:26.320
Touchmove starts at the interior scroller, it
moves up to the Container and we cancel it.

00:35:26.320 --> 00:35:27.930
We mark it as handled.

00:35:27.930 --> 00:35:29.960
But then the event keeps propagating.

00:35:29.960 --> 00:35:35.480
It goes to the exterior container, the
exterior scroller and that also scrolls.

00:35:35.480 --> 00:35:37.130
Now we could do a couple of things here.

00:35:37.130 --> 00:35:42.710
We could say check to see if the event has been
canceled and not scroll our outer container,

00:35:42.710 --> 00:35:45.840
or we could do something a little bit different.

00:35:45.840 --> 00:35:49.520
Once we've handled the touchmove event,
we're done with that touchmove event.

00:35:49.520 --> 00:35:52.700
We really don't want anything else
to get that touchmove event.

00:35:52.700 --> 00:35:54.430
So we call this other method.

00:35:54.430 --> 00:35:56.110
StopPropagation.

00:35:56.110 --> 00:35:57.820
It does what it says on the box.

00:35:57.820 --> 00:35:59.480
It destroys the event.

00:35:59.480 --> 00:36:03.460
No other event handler will receive that touchmove event.

00:36:03.460 --> 00:36:06.550
We'll be the last bit of code to see that event.

00:36:06.550 --> 00:36:08.780
So the outer container never sees it.

00:36:08.780 --> 00:36:12.500
It never acknowledges that exists.

00:36:12.500 --> 00:36:15.290
We can give this a try.

00:36:15.290 --> 00:36:21.310
Instead of calling just preventDefault, let's call
stopPropagation on that interior scroller first.

00:36:21.310 --> 00:36:25.390
The outer one works and the inner one works too.

00:36:25.390 --> 00:36:28.540
So we can scroll our two lists independently of each other.

00:36:28.540 --> 00:36:34.050
[ Applause ]

00:36:34.050 --> 00:36:35.990
This is one of those things that you actually have to try.

00:36:35.990 --> 00:36:37.940
You actually have to feel.

00:36:37.940 --> 00:36:44.660
It's amazing how with CSS transforms and touch
events you can get this really responsive.

00:36:44.660 --> 00:36:46.550
And we've built our scrolling pane.

00:36:46.550 --> 00:36:52.920
We now have these areas that we can scroll
with just one finger in our web content.

00:36:54.050 --> 00:36:57.330
So we've talked about a ton of things today.

00:36:57.330 --> 00:36:59.800
And since I've got you all looking at
me and paying attention still, I hope,

00:36:59.800 --> 00:37:07.290
while I've got your attention I want to talk, just share
a couple of last minute totally super awesome tips.

00:37:07.290 --> 00:37:10.310
First, go try this.

00:37:10.310 --> 00:37:14.520
There's a lot of details that are always
inherent when you're building any kind

00:37:14.520 --> 00:37:16.900
of UI, especially any kind of really rich UI.

00:37:16.900 --> 00:37:17.880
Give it a try.

00:37:17.880 --> 00:37:19.200
Download the sample code.

00:37:19.200 --> 00:37:26.180
All of those event bubbles and that scrapbook demo,
they're both available from the WWDC attendee site.

00:37:26.180 --> 00:37:32.290
If you log in, find this session number 508 and
then click the More Info inside that grid view,

00:37:32.290 --> 00:37:36.050
you can download the sample code, check it out.

00:37:36.050 --> 00:37:40.500
We're doing a few other things, a few that
we kind of glossed over in this presentation.

00:37:40.500 --> 00:37:42.340
So give it a try.

00:37:42.340 --> 00:37:46.470
As you're experimenting, remember, multitouch.

00:37:46.470 --> 00:37:48.550
So the touch event that you get, the touch event

00:37:48.550 --> 00:37:54.450
that your event handler has delivered is a
list of touches and there's three of them.

00:37:54.450 --> 00:37:58.460
Second, I stopped doing this, I got
lazy part way through the presentation.

00:37:58.460 --> 00:37:59.970
Don't get lazy yourselves.

00:37:59.970 --> 00:38:01.350
Handle touchcancel.

00:38:01.350 --> 00:38:03.270
They're going to come when you least expect it.

00:38:03.270 --> 00:38:05.180
It means you have to reset state.

00:38:05.180 --> 00:38:11.040
So if you need to reset any variables that you're
holding onto or maybe reset some CSS styles,

00:38:11.040 --> 00:38:14.120
make sure you do that handle touchcancel.

00:38:14.120 --> 00:38:18.300
And lastly, actually test on your iPhone on your iPad.

00:38:18.300 --> 00:38:20.240
The simulator is an awesome tool.

00:38:20.240 --> 00:38:26.160
I love using it for development work, but nothing
really beats actually trying this stuff on hardware.

00:38:26.160 --> 00:38:28.950
You're going to find things that you didn't
realize when you're using the simulator

00:38:28.950 --> 00:38:32.180
like maybe your buttons are too small for your fingers.

00:38:32.180 --> 00:38:34.070
Or maybe your text needs to be bigger.

00:38:34.070 --> 00:38:37.720
Or maybe your hand obscures more of
the screen than you think it did.

00:38:37.720 --> 00:38:42.480
When we're building sites for desktop, we might
build a menu that pops underneath the mouse cursor.

00:38:42.480 --> 00:38:49.260
But if you think about how your hands work, if you tap
that menu, it's going to pop underneath your hands.

00:38:49.260 --> 00:38:50.980
That's not so good.

00:38:50.980 --> 00:38:54.590
Instead you might want to build a menu
that pops above where you're touching.

00:38:54.590 --> 00:38:57.120
So test on hardware.

00:38:57.120 --> 00:38:59.880
We've talked about a bunch of things today.

00:38:59.880 --> 00:39:03.070
We've talked about touch events and gesture events.

00:39:03.070 --> 00:39:10.660
The APIs, how they're delivered, what they look like, four
touch events, three gesture events, they come interleaved.

00:39:10.660 --> 00:39:14.130
We've talked about strategies for
building reusable interface components,

00:39:14.130 --> 00:39:17.860
how to keep your code organized with this sort of code.

00:39:17.860 --> 00:39:21.830
You try using an object as that
second parameter to addEventListener.

00:39:21.830 --> 00:39:25.770
You'd be surprised how much it can
really clean up your event handling code.

00:39:25.770 --> 00:39:31.870
And lastly, there is a ton of built in power
to CSS transforms and the DOM Event Model.

00:39:31.870 --> 00:39:37.350
Instead of reinventing the wheel and building
additional state handling information tracking events

00:39:37.350 --> 00:39:39.610
by hand, use what's already there.

00:39:39.610 --> 00:39:41.260
Use the power that's already there.

00:39:41.260 --> 00:39:42.810
Try this out.

00:39:42.810 --> 00:39:48.540
Really, there's, for touch events especially,
nothing beats actually writing code yourself.

00:39:48.540 --> 00:39:53.800
If you have additional questions, you can always contact
Vicky Murley, our Safari Technologies Evangelist.

00:39:53.800 --> 00:39:58.880
There's documentation on developer.apple.com/safari,
information about touch events

00:39:58.880 --> 00:40:02.470
and the touch event model and how they're delivered.

00:40:02.470 --> 00:40:06.140
If you're really interested in learning
more about DOM events and how they work,

00:40:06.140 --> 00:40:12.440
the DOM Level 3 Events Specification spells all of
this and all of it is regular specification gory.

00:40:12.440 --> 00:40:17.580
If you're really interested, try starting
with the DOM Level 2 Event Specification.

00:40:17.580 --> 00:40:20.880
It contains all the stuff we talked
about today like stopPropagation,

00:40:20.880 --> 00:40:24.030
preventDefault, but it's a bit easier to read.

00:40:24.030 --> 00:40:25.740
And there's the Developer Forums.

00:40:25.740 --> 00:40:26.710
You can ask questions in there.

00:40:26.710 --> 00:40:29.870
There's a forum specifically for
building web applications for iPhone.

