1
00:00:06,220 --> 00:00:13,380
>> Josh Shaffer: So we just got done talking about the
basic UIGesture recognizer subclasses provided by UIKit.

2
00:00:13,380 --> 00:00:21,800
Now we want to talk a bit more about how gesture recognizers
added to your views will affect the delivery of touches

3
00:00:21,800 --> 00:00:27,860
to those views using the existing UITouch,
UIEvent, touchesBegan, Moved, Ended,

4
00:00:27,860 --> 00:00:31,350
and Cancelled methods, and UIResponder delivery.

5
00:00:31,350 --> 00:00:34,160
And after we spend a bit of time on that we're going to talk

6
00:00:34,160 --> 00:00:37,570
about how you can write your own
gesture recognizer subclasses.

7
00:00:37,570 --> 00:00:44,680
Because while pinch, pan, rotate, swipe, tap, double-tap,
all these things are great, you may have some ideas

8
00:00:44,680 --> 00:00:49,120
of your own for gesture recognizers or some
existing code that you actually just want to wrap

9
00:00:49,120 --> 00:00:54,770
up in a gesture recognizer and make use of all of
the runtime behaviors that it's providing for you.

10
00:00:54,770 --> 00:00:57,010
So let's get started.

11
00:00:57,010 --> 00:01:00,130
We're going cover, as I said, view interaction
and then we'll get into subclassing.

12
00:01:00,130 --> 00:01:02,670
So first UIResponder review.

13
00:01:02,670 --> 00:01:07,600
Right? We already know how this works, we've
been seeing it for two years since iPhone OS 2.0.

14
00:01:07,600 --> 00:01:11,260
When a touch comes down on the screen
your touch is delivered to your UIView

15
00:01:11,260 --> 00:01:15,440
through the touchesBegan, moved,
ended, and cancelled methods.

16
00:01:15,440 --> 00:01:21,170
Now this is delivered to whichever view
was hit-tested when that touch came down.

17
00:01:21,170 --> 00:01:25,100
If you came to the touch event
session last year you may remember

18
00:01:25,100 --> 00:01:29,500
that these methods are actually
called by UIWindows sendEvent method.

19
00:01:29,500 --> 00:01:34,090
And UIWindows sendEvent, in turn, is
called by UIApplication sendEvent.

20
00:01:34,090 --> 00:01:37,490
And this has been the case since iPhone
OS 2.0, it's always worked this way.

21
00:01:37,490 --> 00:01:40,540
So I'm sure you've already used
these things and know how they work.

22
00:01:40,540 --> 00:01:43,830
But quickly, visually, this is what goes on.

23
00:01:43,830 --> 00:01:49,990
Your application sendEvent, when a touch comes down calls
UIWindows sendEvent, which calls touchesBegan, moved, ended,

24
00:01:49,990 --> 00:01:53,090
and cancelled on the UIView that the touch is in.

25
00:01:53,090 --> 00:01:57,430
So how is this modified by the
presence of an UIGesture recognizer.

26
00:01:57,430 --> 00:02:01,480
Well, to find out let's add a couple of
UIGesture recognizers to this view hierarchy.

27
00:02:01,480 --> 00:02:08,480
Here I've got an UIViewController's view and that view
has two subviews, these two UIViews at the top and bottom.

28
00:02:08,480 --> 00:02:16,790
So let's add an UI tap gesture recognizer to that bottom
UIView subview, and let's add an UI pinch gesture recognizer

29
00:02:16,790 --> 00:02:21,190
to that UIViewController's view, the super
view of those two subviews that we've got.

30
00:02:21,190 --> 00:02:25,570
And now let's put that exact same
touch down in that lower UIView.

31
00:02:25,570 --> 00:02:30,280
New application sendEvent, just as in the
other case, will call UIWindow sendEvent.

32
00:02:30,280 --> 00:02:36,410
But now UIWindows sendEvent, instead of calling
touchesBegan, moved, ended, and cancelled on that UIView,

33
00:02:36,410 --> 00:02:41,660
it's first going to call those exact same
methods on those two UIGesture recognizers.

34
00:02:41,660 --> 00:02:48,240
So as Brad talked about, the reason why these two UIGesture
recognizers both see the touch is because the touch is

35
00:02:48,240 --> 00:02:52,610
down in that UIView that has the tap
gesture recognizer, so the tap sees it.

36
00:02:52,610 --> 00:02:56,910
And the pinch is attached to that View
Controller's super view, one of its ancestors.

37
00:02:56,910 --> 00:03:00,420
So that pinch gesture recognizer
also gets to see that touch.

38
00:03:00,420 --> 00:03:04,600
So touchesBegan, moved, ended, and cancelled
sent to the two gesture recognizers.

39
00:03:04,600 --> 00:03:09,550
Now assuming nothing has changed, we'll talk
about what these changes are in just a minute.

40
00:03:09,550 --> 00:03:14,480
That UIWindow sendEvent will then call
the same touchesBegan, moved, ended,

41
00:03:14,480 --> 00:03:18,660
and cancelled methods on the UIView
that the touch is actually bound to.

42
00:03:18,660 --> 00:03:24,000
So the only difference is that these gesture
recognizers get to see the touch before the UI does.

43
00:03:24,000 --> 00:03:28,020
And that's important, and we'll see why in just a second.

44
00:03:28,020 --> 00:03:32,850
So the reason for that, actually right now, being
important is that there are two ways that the presence

45
00:03:32,850 --> 00:03:39,720
of an UIGestureRecognizer on a view can affect
delivery of touches to that view or you know,

46
00:03:39,720 --> 00:03:42,790
whichever view the touch was actually bound to.

47
00:03:42,790 --> 00:03:48,990
The first way is the gesture recognizer can actually
cause that touch to get cancelled on the view.

48
00:03:48,990 --> 00:03:53,230
So let's take a look at the sequence of events that
will happen and how that touch cancellation will work.

49
00:03:53,230 --> 00:03:57,210
So in order to see it, we're going to put down two touches,

50
00:03:57,210 --> 00:04:01,090
one in each of those two subviews,
one at the top and one at the bottom.

51
00:04:01,090 --> 00:04:06,950
Our gesture recognizers will both receive touchesBegan
withEvent, they're both going to remain in state possible,

52
00:04:06,950 --> 00:04:12,580
because a touch coming down in either of these views is
not enough to determine that we've got a tap or a pinch.

53
00:04:12,580 --> 00:04:16,200
So both gesture recognizers are still
possible, nothing's been determined yet.

54
00:04:16,200 --> 00:04:19,040
So the UIView that each of these is associated

55
00:04:19,040 --> 00:04:26,190
with will receive a touchesBegan withEvent
method, for its appropriate touch.

56
00:04:26,190 --> 00:04:30,310
Next, let's assume that the users move
their fingers a bit closer together.

57
00:04:30,310 --> 00:04:35,660
So we get touchesMoved withEvent delivered to both of
those UIGesture recognizers, the tap and the pinch.

58
00:04:35,660 --> 00:04:41,260
The tap obviously only sees the one touch at the
bottom that's in its view, the pinch sees both.

59
00:04:41,260 --> 00:04:43,860
Both gesture recognizers remain in state possible.

60
00:04:43,860 --> 00:04:50,570
Because tap allows a little bit of movement in its
touch before it fails, and pinch requires a little bit

61
00:04:50,570 --> 00:04:53,310
of movement in its touches before it recognizes.

62
00:04:53,310 --> 00:04:56,810
So a little bit of pinching together is
not enough, they're both still possible.

63
00:04:56,810 --> 00:05:01,610
So the UIViews each receive touchesMoved
withEvent for their appropriate touches.

64
00:05:01,610 --> 00:05:05,040
Now let's assume the user continues
to move their fingers together.

65
00:05:05,040 --> 00:05:07,990
Both UIGesture recognizers receive touchesMoved withEvent.

66
00:05:07,990 --> 00:05:14,550
At this point the tap's touch has moved far
enough that the tap says I'm out, and it fails.

67
00:05:14,550 --> 00:05:16,200
Can't be a tap anymore.

68
00:05:16,200 --> 00:05:20,480
The pinch gesture recognizer, however, has seen
these two touches moving closer and closer together,

69
00:05:20,480 --> 00:05:23,670
and now decides that it's actually
a pinch that's really happening.

70
00:05:23,670 --> 00:05:26,070
So it moves to state began.

71
00:05:26,070 --> 00:05:33,200
Now because that pinch gesture recognizer has recognized the
touches will now actually get cancelled on their UIViews.

72
00:05:33,200 --> 00:05:37,490
So both UIViews get touchesCancelled withEvent sent to them,

73
00:05:37,490 --> 00:05:40,130
each for the touches that are, you
know, associated with their view.

74
00:05:40,130 --> 00:05:46,200
So the top UIView gets touchesCancelled for its view,
and the bottom UIView gets touchesCancelled for its view.

75
00:05:46,200 --> 00:05:49,350
So as far as those views are concerned
now these touches are done.

76
00:05:49,350 --> 00:05:51,550
It's not going to be informed of them any more.

77
00:05:51,550 --> 00:05:52,670
They're gone.

78
00:05:52,670 --> 00:06:00,240
However, the UIGesture recognizers do still know about the
touches, and the pinch will continue to track over time.

79
00:06:00,240 --> 00:06:05,800
So now as we move farther and farther together, we're
going to have touchesMoved withEvent called again.

80
00:06:05,800 --> 00:06:10,880
But now it's only going to be called on the pinch
gesture recognizer, because the tap has already failed.

81
00:06:10,880 --> 00:06:16,950
It's already indicated it's not interested in being a
tap, it doesn't get updated about this touch any more.

82
00:06:16,950 --> 00:06:18,690
This is an important thing to keep in mind

83
00:06:18,690 --> 00:06:22,350
as you're sub classing UIGestureRecognizer,
which we'll see in just a few minutes.

84
00:06:22,350 --> 00:06:27,490
Because the implication is that a gesture recognizer
may not actually see a full touch sequence.

85
00:06:27,490 --> 00:06:32,170
If it fails before the touch has ended it won't
be notified about the rest of the touch sequence.

86
00:06:32,170 --> 00:06:36,810
So the pinch now is in state changed, because
these touches have moved together even further,

87
00:06:36,810 --> 00:06:38,580
and it's now updated at scale.

88
00:06:38,580 --> 00:06:43,990
So it's in a new updated state and needs to notify
its target actions that the state has changed.

89
00:06:43,990 --> 00:06:45,820
So pinch is in state change.

90
00:06:45,820 --> 00:06:50,100
UIView, as I said, touch is already
cancelled, it gets nothing.

91
00:06:50,100 --> 00:06:54,080
Now when the touches lift, we get
touchesEnded withEvent with the pan gesture --

92
00:06:54,080 --> 00:06:56,220
sorry, the pinch gesture recognizer for the same reason.

93
00:06:56,220 --> 00:06:58,590
It's the only one left that's still seeing these touches.

94
00:06:58,590 --> 00:07:02,310
And it moves to state ended because
both the touches have lifted.

95
00:07:02,310 --> 00:07:04,730
Now this is the default behavior.

96
00:07:04,730 --> 00:07:07,660
And in almost every case it's what you're going to want.

97
00:07:07,660 --> 00:07:11,940
Because if a gesture recognizer is recognizing,
we've determined that the user is trying

98
00:07:11,940 --> 00:07:15,780
to perform some particular action, we've recognized
that they're pinching their fingers together

99
00:07:15,780 --> 00:07:18,640
and we want to do something in response to that.

100
00:07:18,640 --> 00:07:23,760
You don't, at that point usually want to be
tracking those same touches on the UIViews

101
00:07:23,760 --> 00:07:27,610
that the touches were associated with, because
then you might start doing some other actions

102
00:07:27,610 --> 00:07:30,410
or performing something else when
really you're just trying to pinch.

103
00:07:30,410 --> 00:07:33,350
So normally, you do want those touches to get cancelled.

104
00:07:33,350 --> 00:07:38,520
But if for some reason you don't, say you're adding
some gesture recognizers to your existing application

105
00:07:38,520 --> 00:07:42,330
and you've already got your own touch processing
that you want to keep using at the same time,

106
00:07:42,330 --> 00:07:44,430
and you really don't want those touches getting cancelled,

107
00:07:44,430 --> 00:07:48,050
you can adjust this with the cancel
touches in view property.

108
00:07:48,050 --> 00:07:53,580
So from the example we just looked at, we had set our
pinch gesture recognizer's cancels touches in view property

109
00:07:53,580 --> 00:07:58,320
to no instead of the default yes, the touches
would not have gotten cancelled on the views.

110
00:07:58,320 --> 00:08:02,750
And we can see that here, it's highlighted in yellow,
the difference between the last slide and this one.

111
00:08:02,750 --> 00:08:07,440
Now when the pinch gesture recognizer
moved to began, UIView,

112
00:08:07,440 --> 00:08:11,610
both UIViews continued to receive touchesMoved
withEvent all the way through touchesMoved to event.

113
00:08:11,610 --> 00:08:15,830
They got the entire touch sequence as if
the gesture weren't recognizing at all.

114
00:08:15,830 --> 00:08:20,890
So in most cases you want to leave this and the next
properties we're going to talk to in their default states.

115
00:08:20,890 --> 00:08:25,460
Because we've picked them very specifically because
they generally provide the behavior that you want.

116
00:08:25,460 --> 00:08:30,110
But if for some reason you've determined that's
not the case it's available to be changed.

117
00:08:30,110 --> 00:08:35,900
So the next two properties to talk about are
sort of identified the second of the two ways

118
00:08:35,900 --> 00:08:39,560
that gesture recognizers can affect
delivery of touches to their views.

119
00:08:39,560 --> 00:08:43,630
And this is by actually delaying
deliver of the touches to their views.

120
00:08:43,630 --> 00:08:50,990
The presence of a gesture recognizer can cause the view to
only see the touch information after some period of delay

121
00:08:50,990 --> 00:08:56,640
when the gesture has determined that's it's not actually
going to happen, that the gesture won't recognize.

122
00:08:56,640 --> 00:08:59,640
And the two ways -- there are actually
two ways that delaying can happen.

123
00:08:59,640 --> 00:09:03,330
You can either delay touchesBegan or delay touchesEnded.

124
00:09:03,330 --> 00:09:08,570
So by default, gesture recognizers actually
delay touchesEnded and not touchesBegan.

125
00:09:08,570 --> 00:09:12,210
So delays touchesEnded is actually true by default.

126
00:09:12,210 --> 00:09:19,510
And what this is, it means if a touch ends and a
gesture recognizer hasn't yet failed or recognized,

127
00:09:19,510 --> 00:09:25,980
so it's still possible, the touches ended
will not be send immediately to the UIView.

128
00:09:25,980 --> 00:09:31,030
It's best to see an example to understand,
it's not entirely clear why that would be.

129
00:09:31,030 --> 00:09:38,070
The most common case where you'll find this
happening is in a double-tap, because a first --

130
00:09:38,070 --> 00:09:44,260
a single tap must have happened before a double-tap happens,
and maybe you still want to be able to cancel the touch

131
00:09:44,260 --> 00:09:46,270
after a double-tap has happened, the first touch.

132
00:09:46,270 --> 00:09:51,090
Well, we can't have delivered touchesEnded to the view
for the first touch if we want to cancel it later.

133
00:09:51,090 --> 00:09:55,900
So delays touchesEnded holds off on delivering
touchesEnded so we can still cancel it.

134
00:09:55,900 --> 00:10:01,360
Delays touchesBegan is the alternative, and this effectively
delays the delivery of the entire touch sequence.

135
00:10:01,360 --> 00:10:09,580
Just the simple presence of an UIGestureRecognizer on a
view with delays touchesBegan set to yes will cause the view

136
00:10:09,580 --> 00:10:15,330
to not see touchesBegan until that gesture
recognizer has either failed or recognized.

137
00:10:15,330 --> 00:10:19,800
So let's actually look at that on a
timeline, it should be a little more clear.

138
00:10:19,800 --> 00:10:22,360
So first delays touchesEnded, this
is the default configuration.

139
00:10:22,360 --> 00:10:25,580
An UIGestureRecognizer will delay touchesEnded.

140
00:10:25,580 --> 00:10:29,590
So I've changed our tap gesture recognizer
that we looked at now, same view hierarchy,

141
00:10:29,590 --> 00:10:33,300
but now our tap gesture recognizer
is a double-tap gesture recognizer.

142
00:10:33,300 --> 00:10:38,620
So let's put down a single touch in that lower
UIView with our double-tap gesture recognizer.

143
00:10:38,620 --> 00:10:42,000
Both recognizers receive touchesBegan,
double-tap still possible,

144
00:10:42,000 --> 00:10:45,980
pinch still possible, and UIView receives touchesBegan.

145
00:10:45,980 --> 00:10:51,680
That finger moves just a little bit, but that's OK
because a tap can allow a bit of movement in its touch.

146
00:10:51,680 --> 00:10:55,590
So the recognizers both receive touchesMoved withEvent.

147
00:10:55,590 --> 00:10:57,350
They're both still possible.

148
00:10:57,350 --> 00:11:00,280
And the UIView receives touchesMoved withEvent.

149
00:11:00,280 --> 00:11:03,650
But now let's say that that finger lifts.

150
00:11:03,650 --> 00:11:06,240
Both UIGestureRecognizers receive touchesEnded.

151
00:11:06,240 --> 00:11:11,250
The double-tap now is still possible,
because a double-tap can't recognize

152
00:11:11,250 --> 00:11:14,650
until two fingers -- or a finger has tapped twice.

153
00:11:14,650 --> 00:11:18,250
So it's waiting now for a bit to
see if another finger comes down.

154
00:11:18,250 --> 00:11:20,870
So there's going to be a timer set
internally in the gesture recognizer

155
00:11:20,870 --> 00:11:24,260
and if a finger doesn't come down soon enough it will fail.

156
00:11:24,260 --> 00:11:28,280
But right now, it's just possible,
waiting for that to happen.

157
00:11:28,280 --> 00:11:32,970
The pinch gesture recognizer has now failed,
because all fingers have lifted, can't be a pinch.

158
00:11:32,970 --> 00:11:38,760
But because we have delays touchesEnded, the UIView has
not been informed about that touch ending, still delayed.

159
00:11:38,760 --> 00:11:45,710
So now some time period passes, the tap gesture recognizer
says not a double-tap, user didn't put another finger down.

160
00:11:45,710 --> 00:11:47,360
So it fails.

161
00:11:47,360 --> 00:11:50,780
Once that's happened, then we deliver
touchesEnded to the UIView.

162
00:11:50,780 --> 00:11:57,920
So it can introduce some latency in your touch processing
if you've got RAW Touch Handling on your UIViews.

163
00:11:57,920 --> 00:11:59,860
So now let's take a look at delays touchesBegan.

164
00:11:59,860 --> 00:12:04,510
This is no by default for a very important reason.

165
00:12:04,510 --> 00:12:08,600
And it's because it will actually guarantee
to introduce latency in your event handling.

166
00:12:08,600 --> 00:12:15,950
For example, if you've got an UI button in your
view, UI buttons highlight themselves, excuse me --

167
00:12:15,950 --> 00:12:21,170
on touchesBegan withEvent, there's no
gesture recognizer on an UI button,

168
00:12:21,170 --> 00:12:24,620
it's just highlighting when the touch
comes down that it receives touchesBegan.

169
00:12:24,620 --> 00:12:29,260
So if you have a gesture recognizer on that
view that's delaying delivery of touchesBegan,

170
00:12:29,260 --> 00:12:32,410
when the user puts their finger down they
won't see any visual feedback in the button

171
00:12:32,410 --> 00:12:35,190
that they're actually pressing,
which is going to be unexpected.

172
00:12:35,190 --> 00:12:38,650
So unless you've got a really specific
reason for setting delays touchesBegan,

173
00:12:38,650 --> 00:12:41,700
I strongly encourage you to leave it turned off.

174
00:12:41,700 --> 00:12:46,400
Because it really does end up with a not
very good user experience in most cases.

175
00:12:46,400 --> 00:12:48,630
But anyway, let's see what effect it has.

176
00:12:48,630 --> 00:12:53,540
So we've got the same view hierarchy again, but
I've gone back to a single tap gesture recognizer.

177
00:12:53,540 --> 00:12:57,510
I've set delays touchesBegan now on
just that single tap gesture recognizer.

178
00:12:57,510 --> 00:13:00,560
The pinch is still configured in the default way.

179
00:13:00,560 --> 00:13:02,300
So we put our finger down.

180
00:13:02,300 --> 00:13:06,470
Both gesture recognizer receive touchesBegan
withEvent, and they're still possible

181
00:13:06,470 --> 00:13:07,840
for all the same reasons that we just saw.

182
00:13:07,840 --> 00:13:12,830
But the UIView has seen nothing, it
doesn't even know that that touch exists.

183
00:13:12,830 --> 00:13:17,720
So now the user moves their finger a little bit, same
deal, touchesMoved withEvent to the gesture recognizers.

184
00:13:17,720 --> 00:13:21,010
They're both still possible.

185
00:13:21,010 --> 00:13:24,020
Now the user moves their finger even a bit more.

186
00:13:24,020 --> 00:13:27,750
We get touchesMoved withEvent delivered
to both the gesture recognizer.

187
00:13:27,750 --> 00:13:34,400
The tap now fails because you've moved far enough that the
tap recognizer realizes it's not a tap, so it's failed.

188
00:13:34,400 --> 00:13:37,780
Pinch gesture recognizer is still possible,
because that's OK because we had it

189
00:13:37,780 --> 00:13:41,070
in its default configuration, it's
not the one delaying touchesBegan.

190
00:13:41,070 --> 00:13:47,620
The tap is the one that was delaying touchesBegan, and now
that it's failed there's no reason to continue delaying.

191
00:13:47,620 --> 00:13:51,370
So at this point the UIView gets touchesBegan withEvent.

192
00:13:51,370 --> 00:13:55,520
And at some point after the finger had actually come
down, and in fact it's moved quite a bit already,

193
00:13:55,520 --> 00:14:01,230
so the one thing to make note here is that I've actually
got a ghosted version of that touch up in the UIView.

194
00:14:01,230 --> 00:14:05,230
That -- the important point here is that
when we deliver touchesBegan withEvent

195
00:14:05,230 --> 00:14:10,140
after this delay it actually has these state
that the touch had when it first came down.

196
00:14:10,140 --> 00:14:15,780
So the touch -- or the view receives touchesBegan withEvent
in its current location and the time stamp on the touch

197
00:14:15,780 --> 00:14:18,880
when it's being delivered is the original time stamp.

198
00:14:18,880 --> 00:14:24,000
So it's actually kind of important to keep in
mind here that if you're using gesture recognizers

199
00:14:24,000 --> 00:14:29,450
that are delaying touches and you're actually doing
calculations of velocity or things that are time-based

200
00:14:29,450 --> 00:14:33,620
in your touch handling, you should really be
doing those calculations based off the time stamps

201
00:14:33,620 --> 00:14:37,530
of the touches not off of wall
time when you receive the event.

202
00:14:37,530 --> 00:14:39,510
Because there may have actually been a delay.

203
00:14:39,510 --> 00:14:45,320
And if you want to get correct velocity calculations
you really have to have used the actual event times.

204
00:14:45,320 --> 00:14:49,740
So we got touchesBegan withEvent, but
the view is kind of out of sync, right?

205
00:14:49,740 --> 00:14:52,610
The view still thinks the touch is down where it started.

206
00:14:52,610 --> 00:14:57,180
So in addition to touchesBegan withEvent in the
same turn of the run loop, right afterwards,

207
00:14:57,180 --> 00:15:00,300
you're actually going to get touchesMoved
withEvent on that UIView.

208
00:15:00,300 --> 00:15:05,210
To update the touch -- to update the view
with the location that the touch is at now.

209
00:15:05,210 --> 00:15:06,980
So another important thing to keep in mind here is

210
00:15:06,980 --> 00:15:12,230
that we will only send one touchesMoved
withEvent in order to get you updated.

211
00:15:12,230 --> 00:15:17,500
So if you're delaying touchesBegan and there's a really
long delay before that gesture recognizer failed,

212
00:15:17,500 --> 00:15:21,150
even if that touch was moving all over the
place and there's a huge amount of swipes,

213
00:15:21,150 --> 00:15:25,400
they wrote their name, the view
is only going to get one event.

214
00:15:25,400 --> 00:15:28,330
So you just lost all that information
about the intermediate state.

215
00:15:28,330 --> 00:15:31,950
It would just be too expensive to
queue it up and deliver all of it.

216
00:15:31,950 --> 00:15:36,110
So another reason to avoid delaying
touchesBegan, if at all possible.

217
00:15:36,110 --> 00:15:39,140
Anyway, now we're back into the
normal stream of events, right?

218
00:15:39,140 --> 00:15:44,250
Our tap gesture recognizer has failed, we delivered
touchesBegan and touchesMoved to the UIView.

219
00:15:44,250 --> 00:15:45,610
So we just continue as normal.

220
00:15:45,610 --> 00:15:51,030
The touch moves some more, we get touchesMoved withEvent
to our pinch gesture recognizer, which is still possible.

221
00:15:51,030 --> 00:15:52,860
The taps failed, so it gets nothing.

222
00:15:52,860 --> 00:15:57,290
But now the UIView is also getting touchesMoved
withEvent, just as if nothing had happened.

223
00:15:57,290 --> 00:16:02,260
Finally, when the touch lifts we get
touchesEnded on the pinch gesture recognizer.

224
00:16:02,260 --> 00:16:03,600
It fails because the touches have all lifted.

225
00:16:03,600 --> 00:16:08,600
And the UIView also gets touchesEnded withEvent.

226
00:16:08,600 --> 00:16:13,600
That's pretty much all there is to the effects of
UIGestureRecognizer on delivery of touches to UIView.

227
00:16:13,600 --> 00:16:14,570
Just those three things.

228
00:16:14,570 --> 00:16:23,370
It cancels touches in view for touch cancellation and
delays touchesEnded and delays touchesBegan for touch delay.

229
00:16:23,370 --> 00:16:25,600
So let's move on to more interesting things now.

230
00:16:25,600 --> 00:16:29,840
You've got your own touch code or you've got ideas
for gestures you want to define and you want to play

231
00:16:29,840 --> 00:16:35,180
with our gesture recognizing system and coordinate
with our gestures and get the same exclusivity rules

232
00:16:35,180 --> 00:16:39,770
and failure requirements and all this kind
of stuff that UIGestureRecognizer provides.

233
00:16:39,770 --> 00:16:42,590
So how do you subclass UIGestureRecognizer.

234
00:16:42,590 --> 00:16:45,390
Well, the first thing that you have to do any time you go

235
00:16:45,390 --> 00:16:50,970
to subclass UIGestureRecognizer is pound
import UIGestureRecognizer subclass level H.

236
00:16:50,970 --> 00:16:57,850
So why? Well, there's a bunch of things in
UIGestureRecognizer subclass.h that are intended only

237
00:16:57,850 --> 00:17:00,960
for use by subclasses of UIGestureRecognizer.

238
00:17:00,960 --> 00:17:07,740
We really, really, really don't want code outside of
implementations of gesture recognizers using these methods.

239
00:17:07,740 --> 00:17:09,610
They're just -- I can't stress this enough.

240
00:17:09,610 --> 00:17:12,700
They're intended specifically for use in your subclasses.

241
00:17:12,700 --> 00:17:18,160
So pound import UIKit, UIKit.h does not
include gesture recognizer subclass.h.

242
00:17:18,160 --> 00:17:22,820
Because we don't even want your autocomplete showing
you the methods that are defined in this header.

243
00:17:22,820 --> 00:17:28,900
So when you actually go to implement gesture recognizer,
just pound import, and then you have access to everything.

244
00:17:28,900 --> 00:17:31,790
So what -- what do you have to do.

245
00:17:31,790 --> 00:17:33,290
Subclass UIGestureRecognizer.

246
00:17:33,290 --> 00:17:35,400
All right, what do I implement.

247
00:17:35,400 --> 00:17:41,830
Well, there's just one single most important thing to --
well actually sorry -- we have to get to that in one second.

248
00:17:41,830 --> 00:17:47,850
Before we do that, keep in mind that UIGestureRecognizer
is actually not a subclass of UIResponder,

249
00:17:47,850 --> 00:17:52,590
which is pretty unusual for touch delivery
as we've been seeing it in the iPhone OS.

250
00:17:52,590 --> 00:18:01,090
UIView, UIViewController, UIControl, UIApplication,
UIWindow, these things are all subclasses of UIResponder,

251
00:18:01,090 --> 00:18:06,900
and it's actually UIResponder which defines those
touchesBegan, moved, ended, and cancelled withEvent methods.

252
00:18:06,900 --> 00:18:10,630
But I already said that UIGestureRecognizers
receive those methods.

253
00:18:10,630 --> 00:18:14,340
And how does that work if they're
not subclasses of UIResponder.

254
00:18:14,340 --> 00:18:17,960
Well, UIGestureRecognizer actually
declares these methods as well.

255
00:18:17,960 --> 00:18:19,980
It just declares them with the exact same prototype.

256
00:18:19,980 --> 00:18:23,920
So same methods that you can implement, even
though you're not an UIResponder subclass.

257
00:18:23,920 --> 00:18:26,280
You've seen these before in your touch handling.

258
00:18:26,280 --> 00:18:33,060
The reason it's not an UIResponder is because there's
no responder chain involved in gesture recognition.

259
00:18:33,060 --> 00:18:38,830
We're simultaneously delivering touchesBegan,
moved, ended, and cancelled to multiple recognizers,

260
00:18:38,830 --> 00:18:43,540
even if you call super touchesMoved, we're not
forwarding that event on to some other object.

261
00:18:43,540 --> 00:18:46,400
The gesture recognizers are end points for these deliveries.

262
00:18:46,400 --> 00:18:52,050
So yeah, not a subclass of UIResponder, doesn't
participate in the responder change, it's just on the side

263
00:18:52,050 --> 00:18:54,830
and affects it the way we just talked about.

264
00:18:54,830 --> 00:19:00,310
So sorry, now the most important thing that you have to
remember when you go in subclass UIGestureRecognizer.

265
00:19:00,310 --> 00:19:04,250
The one thing that you absolutely have to do,
and in fact the only thing that you really have

266
00:19:04,250 --> 00:19:07,980
to do, is change the gesture recognizer state.

267
00:19:07,980 --> 00:19:12,140
Brad, if you were in the last session, talked about the
different states that gesture recognizers might be in,

268
00:19:12,140 --> 00:19:17,590
those are UIGestureRecognizerStatePossible,
Failed, Recognized, Began, Changed, and Ended.

269
00:19:17,590 --> 00:19:20,260
And we'll see those a lot in just a minute.

270
00:19:20,260 --> 00:19:22,260
So don't worry that I said them and you didn't see them.

271
00:19:22,260 --> 00:19:28,880
But some of you may be thinking if you looked at the
UIGestureRecognizer header that state is read only,

272
00:19:28,880 --> 00:19:36,620
which actually is true UIGestureRecognizer.h defines at
property not atomic, read only, UIGestureRecognizer state.

273
00:19:36,620 --> 00:19:38,320
So how can you change it?

274
00:19:38,320 --> 00:19:44,320
Well, UIGestureRecognizer subclass.h
redefines the property as read write.

275
00:19:44,320 --> 00:19:49,050
Another reason that it's in the subclass and not
included by default, we don't want people outside

276
00:19:49,050 --> 00:19:53,970
of the gesture recognizer changing your gesture
recognizer state because it's state that you're defining.

277
00:19:53,970 --> 00:19:59,930
You're creating a state machine in this gesture recognizer
to determine how far along in the recognition you are.

278
00:19:59,930 --> 00:20:03,240
You don't want some other code somewhere
else trying to change the state on you.

279
00:20:03,240 --> 00:20:08,850
That just breaks encapsulation and can totally throw
everything out of whack on your own internal state tracking.

280
00:20:08,850 --> 00:20:13,770
So when you subclass, import the header,
and it will be redeclared read/write

281
00:20:13,770 --> 00:20:19,390
so you can move the gesture recognizer state through this
defined state machine that we'll see in just a minute.

282
00:20:19,390 --> 00:20:22,310
So how do we move it, what can we do?

283
00:20:22,310 --> 00:20:26,910
Well all gesture recognizers always start
in UIGestureRecognizerStatePossible.

284
00:20:26,910 --> 00:20:31,600
This is the default state, where they're just -- it
may be happening, I haven't seen any touches yet,

285
00:20:31,600 --> 00:20:35,540
or maybe I have seen some touches,
but I don't know if I'm recognized.

286
00:20:35,540 --> 00:20:37,050
So we start there.

287
00:20:37,050 --> 00:20:40,120
Now failure is the most common thing you're going to do.

288
00:20:40,120 --> 00:20:42,310
And we really do hope that you fail quickly.

289
00:20:42,310 --> 00:20:50,970
So you want to move from UIGestureRecognizerStatePossible to
UIGestureRecognizerStateFailed as soon as you possibly can

290
00:20:50,970 --> 00:20:53,720
for all the reasons we just looked at with touch delaying.

291
00:20:53,720 --> 00:20:57,200
If someone were to set delays touchesBegan
on your gesture recognizer,

292
00:20:57,200 --> 00:21:00,710
if you don't fail quickly the touches
will be delayed for a long time.

293
00:21:00,710 --> 00:21:06,210
So fail as quickly as possible, and as Brad said failure
is the most common thing that's going to happen here.

294
00:21:06,210 --> 00:21:10,640
Touches come down on the screen, user is
probably not performing your gesture right now,

295
00:21:10,640 --> 00:21:13,560
so you're just going to fail.

296
00:21:13,560 --> 00:21:17,460
And then from failed you'll end up back
in UIGestureRecognizerStatePossible.

297
00:21:17,460 --> 00:21:22,340
Now I've left state possible -- actually I colored
it the same as the original state responsible,

298
00:21:22,340 --> 00:21:27,750
but that transition is different from the transition to
failed because you don't actually have to perform it.

299
00:21:27,750 --> 00:21:30,560
And we'll see it in just a second when it happens.

300
00:21:30,560 --> 00:21:36,020
But keep in mind you'll never be in charge of moving
your gesture recognizer back to state possible.

301
00:21:36,020 --> 00:21:39,030
You just have to get to state failed or one of
these other states we're about to talk about.

302
00:21:39,030 --> 00:21:41,360
So that's the first.

303
00:21:41,360 --> 00:21:45,450
Now what happens if a gesture recognizer actually
does recognize the gesture it was looking for.

304
00:21:45,450 --> 00:21:47,740
User taps and we recognize the tap.

305
00:21:47,740 --> 00:21:53,560
Well then we move from UIGestureRecognizerStatePossible
to UIGestureRecognizerStateRecognized.

306
00:21:53,560 --> 00:21:56,110
Now state recognized is for discrete gestures.

307
00:21:56,110 --> 00:22:02,460
Gestures that happen as a result of some action at a
discrete point in time and do not update over time.

308
00:22:02,460 --> 00:22:05,280
So a tap, a swipe, these things are discrete.

309
00:22:05,280 --> 00:22:08,260
They aren't going to continue after they've been recognized.

310
00:22:08,260 --> 00:22:11,530
So we've moved to UIGestureRecognizerStateRecognized,
and we're done.

311
00:22:11,530 --> 00:22:15,150
From there we get moved back to
UIGestureRecognizerStatePossible automatically.

312
00:22:15,150 --> 00:22:20,550
So what if you have a gesture recognizer
that needs to report changes over time,

313
00:22:20,550 --> 00:22:23,650
something like a pinch or a swipe or a pan.

314
00:22:23,650 --> 00:22:29,750
User has moved their fingers together, but as they continue
to move you continue to report new state about the pinch.

315
00:22:29,750 --> 00:22:31,070
Well then you have a continuous gesture.

316
00:22:31,070 --> 00:22:33,290
And there's a different set of states for that.

317
00:22:33,290 --> 00:22:35,670
So we start again in state possible.

318
00:22:35,670 --> 00:22:37,710
And move to state began.

319
00:22:37,710 --> 00:22:40,730
Now it's important to keep in mind here
that you don't actually have to define ahead

320
00:22:40,730 --> 00:22:44,250
of time whether your gesture recognizer
is discrete or continuous.

321
00:22:44,250 --> 00:22:49,370
Just determining which one of these states you want to
move to is enough to let us know what you're trying to do.

322
00:22:49,370 --> 00:22:53,150
So you move from state possible
to UIGestureRecognizerStateBegan.

323
00:22:53,150 --> 00:22:55,360
From began then, you may move to state changed.

324
00:22:55,360 --> 00:23:02,220
So as the user has pinched some more, you want to update
your targets about this change, move to state changed.

325
00:23:02,220 --> 00:23:05,580
From state changed, then, you'll go
to UIGestureRecognizerStateEnded.

326
00:23:05,580 --> 00:23:08,620
Once you've completed your recognition.

327
00:23:08,620 --> 00:23:11,980
Now usually this has happened when
the user lifts their fingers.

328
00:23:11,980 --> 00:23:17,450
But maybe some other state in your gesture recognizer
has caused ended to happen and you just set that state.

329
00:23:17,450 --> 00:23:23,310
If it happens while the touches are down, as we saw before,
you will not actually see the entire touch sequence.

330
00:23:23,310 --> 00:23:28,110
Then from UIGestureRecognizerStateBegan,
you can also go directly to state ended.

331
00:23:28,110 --> 00:23:31,470
If it happened fast enough that
there was no change in between.

332
00:23:31,470 --> 00:23:33,930
And then finally, you'll end up back in state possible.

333
00:23:33,930 --> 00:23:37,000
Again, you don't have to worry about that transition.

334
00:23:37,000 --> 00:23:42,840
Another possibility is that last state that we
didn't talk about, UIGestureRecognizerStateCancelled.

335
00:23:42,840 --> 00:23:48,340
So from state began or state changed, if something happens
that causes you to realize that your gesture needs to fail

336
00:23:48,340 --> 00:23:52,800
or at this point you can't fail because
you've already recognized, you want to cancel.

337
00:23:52,800 --> 00:23:58,060
So that's if a phone call comes in, you've received
touchesCancelled withEvent, you want to cancel.

338
00:23:58,060 --> 00:24:01,990
So from either of those states you can
move to UIGestureRecognizerStateCancelled.

339
00:24:01,990 --> 00:24:04,910
And then from there you'll also
end up back in state possible.

340
00:24:04,910 --> 00:24:07,170
So that was kind of a lot and it
was spread over a couple of slides.

341
00:24:07,170 --> 00:24:12,150
So for those of you who were a little more visual or like
the state machine kind of thing, we've got some pictures.

342
00:24:12,150 --> 00:24:15,170
We've got start in state possible always.

343
00:24:15,170 --> 00:24:17,390
Most common, we're going to state failed.

344
00:24:17,390 --> 00:24:20,010
If you've got a discrete recognizer,
you'll be in state recognized.

345
00:24:20,010 --> 00:24:25,780
And if you've got a continuous recognizer reporting
changes over time you'll end up in one of these, you know,

346
00:24:25,780 --> 00:24:32,460
loops over here, began, spend some time
in changed, end up in cancelled and ended.

347
00:24:32,460 --> 00:24:38,130
So I mentioned already that changing your state
is the most important thing that you're going

348
00:24:38,130 --> 00:24:40,620
to do in subclassing your gesture recognizer.

349
00:24:40,620 --> 00:24:44,150
Now of this most important thing the
most, most important thing that you have

350
00:24:44,150 --> 00:24:47,190
to do is end up in one of those four end states.

351
00:24:47,190 --> 00:24:51,930
You must get to UIGestureRecognizerStateRecognized,
Failed, Cancelled, or Ended.

352
00:24:51,930 --> 00:24:55,310
Any is fine, but get to one of them.

353
00:24:55,310 --> 00:25:00,830
The reason for this is that as I mentioned, the runtime
is going to put you back in state possible automatically.

354
00:25:00,830 --> 00:25:03,560
UIKit handles that for you, you
don't have to worry about it.

355
00:25:03,560 --> 00:25:09,580
But getting to one of these end states is important to
let UIKit know that you have either failed to recognize

356
00:25:09,580 --> 00:25:13,660
or finished recognizing so that we
can satisfy failure dependencies

357
00:25:13,660 --> 00:25:17,560
or deliver delayed touches or cancel touches on views.

358
00:25:17,560 --> 00:25:22,850
If you don't end up in one of these states you can
basically end up hanging your entire touch processing loop

359
00:25:22,850 --> 00:25:28,220
because you've got one gesture recognizer sitting
there and everyone else is waiting on it to fail

360
00:25:28,220 --> 00:25:32,110
and it's just hanging along, has no
touches, never going to do anything.

361
00:25:32,110 --> 00:25:34,640
So you really have to end up in one of these states.

362
00:25:34,640 --> 00:25:36,090
Once you do, then you'll end up back

363
00:25:36,090 --> 00:25:40,220
in UIGestureRecognizerStatePossible, we
take care of that transition for you.

364
00:25:40,220 --> 00:25:43,280
So what does it mean that we take care of it for you.

365
00:25:43,280 --> 00:25:49,730
Well, there's this automatic reset that UIKit handles
that puts the gesture recognizer back in a default state,

366
00:25:49,730 --> 00:25:54,670
back into state possible, to be ready for
another attempt to recognize the gesture.

367
00:25:54,670 --> 00:25:57,930
So that's this automatic reset,
and the first thing that happens

368
00:25:57,930 --> 00:26:01,970
with automatic reset is that we
put it back to state possible.

369
00:26:01,970 --> 00:26:08,180
You also have an opportunity to reset any of your
own state that you may have been hanging on to

370
00:26:08,180 --> 00:26:10,530
in your current attempt to recognize the gesture.

371
00:26:10,530 --> 00:26:16,370
If you had some state that you were tracking, touch
locations, the zoom scale of a pinch, that kind of a thing.

372
00:26:16,370 --> 00:26:21,530
When reset happens and you want to go back and
start another attempt to recognize the gesture,

373
00:26:21,530 --> 00:26:28,320
you may want to clear out these ivars or cancel timers,
anything you may have done in the previous attempt.

374
00:26:28,320 --> 00:26:31,560
So you get an opportunity to do this in your subclass.

375
00:26:31,560 --> 00:26:35,680
And you can do that by subclassing
and overriding the reset method.

376
00:26:35,680 --> 00:26:43,260
Now this is also defined in UIGestureRecognizer subclass.h.
And is specifically for use to be called by UIKit, us,

377
00:26:43,260 --> 00:26:46,690
on your gesture recognizer subclass for you to reset things.

378
00:26:46,690 --> 00:26:51,260
It is not intended for you to call in
attempt to reset the gesture recognizer.

379
00:26:51,260 --> 00:26:53,360
Doing so is just not supported.

380
00:26:53,360 --> 00:26:54,800
So don't even try it.

381
00:26:54,800 --> 00:27:00,610
But do subclass and implement, you know, whatever
you need to clean up in the reset method.

382
00:27:00,610 --> 00:27:05,930
In addition to this, all failure requirements
will then have to be fulfilled again.

383
00:27:05,930 --> 00:27:08,000
If you saw Brad's session just before this,

384
00:27:08,000 --> 00:27:12,290
he talked a little bit about failure
requirements for tap and double-tap.

385
00:27:12,290 --> 00:27:18,170
A tap may require a double-tap to fail so that if
a double-tap happens the tap doesn't actually fire.

386
00:27:18,170 --> 00:27:24,790
The automatic reset will reset those failure requirements
so that on the next attempt to recognize these gestures

387
00:27:24,790 --> 00:27:28,110
that failure requirement has to be met again.

388
00:27:28,110 --> 00:27:33,980
An important thing to keep -- make note of when looking
at this automatic reset is that failure requirements,

389
00:27:33,980 --> 00:27:40,230
their presence, will basically tie the automatic
reset of those two gesture recognizers together.

390
00:27:40,230 --> 00:27:47,010
So if a tap requires a double-tap to fail, and the
user double-taps, even though the first tap has gone

391
00:27:47,010 --> 00:27:53,050
into the recognized state long before the second one has
actually finished, the reset method will not be called

392
00:27:53,050 --> 00:27:59,780
on that first tap gesture recognizer until its
dependent, its failure requirement actually also finishes.

393
00:27:59,780 --> 00:28:02,280
And then both will be reset at the same time.

394
00:28:02,280 --> 00:28:06,890
This is just to make sure that there's never a case where
one will have been reset and sort of end up depending

395
00:28:06,890 --> 00:28:08,730
on another that hasn't even finished yet.

396
00:28:08,730 --> 00:28:11,870
They're always reset simultaneously,
if you've set up failure requirements.

397
00:28:11,870 --> 00:28:16,430
So if your reset method seems to be getting
called later than you expect it might be

398
00:28:16,430 --> 00:28:20,960
because you've got a failure requirement set up.

399
00:28:20,960 --> 00:28:26,380
Additionally, all existing touches on that gesture
recognizer are ignored, and I kind of glossed over this,

400
00:28:26,380 --> 00:28:31,700
but we did see it originally, when we talked
about how touch delivery on UIViews is affected.

401
00:28:31,700 --> 00:28:36,700
Once a gesture recognizer fails or gets
the state ended, cancelled, or recognized,

402
00:28:36,700 --> 00:28:40,190
all the existing touches on that view will now be ignored.

403
00:28:40,190 --> 00:28:42,770
They're no longer delivered to the UIGestureRecognizer.

404
00:28:42,770 --> 00:28:46,450
And I'm just repeating it because
it's really important to keep in mind.

405
00:28:46,450 --> 00:28:50,490
You may receive touchesBegan and
touchesMoved and never received touchesEnded

406
00:28:50,490 --> 00:28:53,780
or cancelled in your subclass of UIGestureRecognizer.

407
00:28:53,780 --> 00:28:56,670
In place of that, though, you will
have the reset method called.

408
00:28:56,670 --> 00:29:01,540
So if you're not going to see the rest you'll know that
you got reset and you should just go back to a new state

409
00:29:01,540 --> 00:29:03,080
and be prepared for another attempt to recognize.

410
00:29:03,080 --> 00:29:06,810
Which is also -- it's actually quite good.

411
00:29:06,810 --> 00:29:13,000
Because it means that if your gesture recognizer has failed,
and you're now ignoring these touches and you've been reset,

412
00:29:13,000 --> 00:29:14,870
you're not going to continue seeing that touch

413
00:29:14,870 --> 00:29:18,850
which you've already determined was
whatever gesture you were looking for.

414
00:29:18,850 --> 00:29:21,700
So you can at that point you don't
even have to keep tracking it,

415
00:29:21,700 --> 00:29:27,110
it's effectively gone as far as the
gesture recognizer is concerned.

416
00:29:27,110 --> 00:29:35,030
Ignoring touches happens automatically in reset, but you
can also determine earlier without even moving to one

417
00:29:35,030 --> 00:29:38,130
of those end states that you would like to ignore a touch.

418
00:29:38,130 --> 00:29:41,500
And you can do that by calling ignoreTouch forEvent.

419
00:29:41,500 --> 00:29:45,240
So you might want to do this if you're
implementing a pinch gesture recognizer.

420
00:29:45,240 --> 00:29:50,040
And you've already got two touches and you're tracking
a pinch, and you don't want to track any more.

421
00:29:50,040 --> 00:29:54,390
So if you're already tracking those two and
you get another touchesBegan withEvent method

422
00:29:54,390 --> 00:30:00,320
on your gesture recognizer you can just call self ignoreTouch
forEvent and pass the touch that you want to ignore

423
00:30:00,320 --> 00:30:04,370
and the event that got passed into the touchesBegan method.

424
00:30:04,370 --> 00:30:08,920
And from that point forward it will behave exactly
the same as the ignoring we just talked about.

425
00:30:08,920 --> 00:30:13,150
You will not be updated with that
touch information any more.

426
00:30:13,150 --> 00:30:18,150
But manually calling ignoreTouch forEvent with this method has one additional effect.

427
00:30:18,150 --> 00:30:22,670
And that is that the touch that you're
ignoring will not be cancelled on the view,

428
00:30:22,670 --> 00:30:25,240
even if your gesture recognizer recognizes.

429
00:30:25,240 --> 00:30:29,730
So it basically is a way to filter out
touches in your gesture recognizer itself

430
00:30:29,730 --> 00:30:31,870
that you don't want to be part of the gesture.

431
00:30:31,870 --> 00:30:37,190
So if you have your own tracking logic in the view
and you've got another gesture recognizer on top

432
00:30:37,190 --> 00:30:43,000
that you've added since you want to recognize some
additional gesture, you can still pass some touches

433
00:30:43,000 --> 00:30:47,610
through to the view and ignore them on the gesture
recognizer, so that even if the recognizer recognizes,

434
00:30:47,610 --> 00:30:49,870
the touch handling code will still see it.

435
00:30:49,870 --> 00:30:53,790
Moving through these states is the most
important thing that you do, right?

436
00:30:53,790 --> 00:30:56,170
What happens when you actually move to these states?

437
00:30:56,170 --> 00:30:59,570
Well, there's a couple things, and it's
pretty much the stuff we already talked about.

438
00:30:59,570 --> 00:31:03,610
There's the actions being performed
and the resets being performed.

439
00:31:03,610 --> 00:31:07,240
So the only thing left to talk about
with that is when they actually happen.

440
00:31:07,240 --> 00:31:12,460
So in UIGestureRecognizerStatePossible, obviously we're not
going to be performing any actions and there's not going

441
00:31:12,460 --> 00:31:17,230
to be any resets because this is the default state ,
we've already been reset, we're back in state possible.

442
00:31:17,230 --> 00:31:19,440
So nothing happens there.

443
00:31:19,440 --> 00:31:21,280
In UIGestureRecognizerStateBegan.

444
00:31:21,280 --> 00:31:24,870
When you move to state began your
action methods will be performed.

445
00:31:24,870 --> 00:31:30,990
So if clients of your gesture recognizer have allocated
your gesture recognizer and set up target action pairs

446
00:31:30,990 --> 00:31:36,960
on your gesture recognizer, just moving to state
began is enough to have those target actions called.

447
00:31:36,960 --> 00:31:38,950
Which is great, because it means you don't have to worry

448
00:31:38,950 --> 00:31:42,080
about calling them yourself or
worrying about when to call them.

449
00:31:42,080 --> 00:31:45,470
Just move through of the state machine
and everything's taken care of for you.

450
00:31:45,470 --> 00:31:52,110
Your action methods will be permed at the correct
time by the UIGestureRecognizer runtime and UIKit.

451
00:31:52,110 --> 00:31:55,320
Also we've got the UIGestureRecognizerStateChanged.

452
00:31:55,320 --> 00:31:56,010
Same deal.

453
00:31:56,010 --> 00:31:58,290
Actions are performed automatically.

454
00:31:58,290 --> 00:32:03,040
The important thing to keep in mind with state changed
is that this actually happens for you regard last

455
00:32:03,040 --> 00:32:06,890
of whether you've continued to assign to the state property.

456
00:32:06,890 --> 00:32:13,040
So if you implement touchesMoved withEvent,
and you're already in state changed,

457
00:32:13,040 --> 00:32:17,330
and you receive another touchesMoved withEvent,
because the user has moved their fingers some more.

458
00:32:17,330 --> 00:32:23,400
Even if you don't assign state changes again to the property
that's already changed, which would be kind of redundant

459
00:32:23,400 --> 00:32:30,000
and not really have any effect anyway, we'll still perform
the action method every time the user moves their finger.

460
00:32:30,000 --> 00:32:33,380
So for continuous gesture recognizers
that are in state began and changed,

461
00:32:33,380 --> 00:32:35,470
every time the user moves their finger it --

462
00:32:35,470 --> 00:32:40,980
targets and actions are going to get called to give
your target action pairs an opportunity to adjust

463
00:32:40,980 --> 00:32:43,660
for the new state of your gesture recognizer.

464
00:32:43,660 --> 00:32:48,900
Now finally, we've got UIGestureRecognizerStateEnded
for the continuous gesture recognizers.

465
00:32:48,900 --> 00:32:54,880
Again, your actions will be performed because the
target action methods need a chance to clean up anything

466
00:32:54,880 --> 00:32:58,810
that may need cleaning up as a result
of the gesture recognizer finishing.

467
00:32:58,810 --> 00:33:03,130
So gesture recognizer state ended,
performs actions, and then resets.

468
00:33:03,130 --> 00:33:09,230
For cancellation, UIGestureRecognizerStateCancelled,
it's the exact same thing.

469
00:33:09,230 --> 00:33:12,260
The target action pairs need to know
that the gesture recognizer isn't going

470
00:33:12,260 --> 00:33:14,140
to end, that it's actually been cancelled.

471
00:33:14,140 --> 00:33:18,800
And give the code that's in that action
method an attempt to cancel anything

472
00:33:18,800 --> 00:33:21,570
that it was doing as a result of the gesture recognizer.

473
00:33:21,570 --> 00:33:25,760
So actions are performed and the
reset happens right afterwards.

474
00:33:25,760 --> 00:33:29,350
For discrete gesture recognizers, we've
got UIGestureRecognizerStateRecognized.

475
00:33:29,350 --> 00:33:31,120
And the exact same thing happens.

476
00:33:31,120 --> 00:33:34,700
Action methods perform automatically,
reset happens automatically.

477
00:33:34,700 --> 00:33:39,580
And finally, for UIGestureRecognizerStateFailed,
no actions are performed.

478
00:33:39,580 --> 00:33:43,500
The failure of a gesture recognizer is not
something that gets reported to the target

479
00:33:43,500 --> 00:33:45,950
and action methods of that gesture recognizer.

480
00:33:45,950 --> 00:33:50,150
So if you're implementing an action method for the
gesture recognizer you know that's been recognized,

481
00:33:50,150 --> 00:33:52,020
you don't have to worry about failure.

482
00:33:52,020 --> 00:33:58,570
However, we do reset automatically, as a result
of moving to UIGestureRecognizerStateFailed.

483
00:33:58,570 --> 00:34:02,060
All right, so that's the concept.

484
00:34:02,060 --> 00:34:04,650
And it's -- there's not much to it, really.

485
00:34:04,650 --> 00:34:06,340
You just move through the state machine.

486
00:34:06,340 --> 00:34:10,060
You -- as you're writing your recognizer, you do whatever
it is that you're trying to do in your touch processing

487
00:34:10,060 --> 00:34:11,910
to figure out if the gesture's happening.

488
00:34:11,910 --> 00:34:16,410
But as far as interacting with UIKit and
the important things to do as a subclasser,

489
00:34:16,410 --> 00:34:17,930
you just move through that state machine.

490
00:34:17,930 --> 00:34:18,320
That's it.

491
00:34:18,320 --> 00:34:20,290
Just assign new states.

492
00:34:20,290 --> 00:34:22,270
So now let's look at actually writing one.

493
00:34:22,270 --> 00:34:29,440
I want to stress before I actually show you this
code that you should never actually do this.

494
00:34:29,440 --> 00:34:32,160
What I'm about to show you is how to recognize a tap.

495
00:34:32,160 --> 00:34:34,060
But really, it's how not to recognize a tap.

496
00:34:34,060 --> 00:34:36,600
Because we've already written the UI tap gesture recognizer.

497
00:34:36,600 --> 00:34:40,570
And it's significantly better than anything
we could write here in a couple of slides.

498
00:34:40,570 --> 00:34:45,710
And it knows how to handle multiple taps, multiple
fingers, multiple fingers tapping multiple times.

499
00:34:45,710 --> 00:34:50,160
It's really configurable, and it has the exact same
definition that everyone else's tap is going to have.

500
00:34:50,160 --> 00:34:54,510
So you know, we're going to show you how
to do this, but please never do this.

501
00:34:54,510 --> 00:34:58,140
[ Laughter ]

502
00:34:58,140 --> 00:35:02,130
>> Josh Shaffer: Sorry, it's the simplest
gesture recognizer I could come up with.

503
00:35:02,130 --> 00:35:05,790
All right, so we've got the simple tap gesture recognizer.

504
00:35:05,790 --> 00:35:09,660
First #import UIKit, UIKit subclass.h. Right?

505
00:35:09,660 --> 00:35:11,030
First thing we have to do.

506
00:35:11,030 --> 00:35:16,570
Then we'll declare our interface: @interface
SimpleTapRecognizer : UIGestureRecognizer.

507
00:35:16,570 --> 00:35:21,540
And we don't need any ivars, because this
is the simple tap gesture recognizer.

508
00:35:21,540 --> 00:35:25,420
So we're going to implement first
touchesEnded and touchesCancelled.

509
00:35:25,420 --> 00:35:28,650
In fact, touchesEnded is the minimum
that we would have to implement in order

510
00:35:28,650 --> 00:35:30,890
to have a functioning tap gesture recognizer.

511
00:35:30,890 --> 00:35:34,780
Because that's when taps actually
occur, when the user lifts their finger.

512
00:35:34,780 --> 00:35:40,440
So in touchesEnded, we're going to implement the exact same
thing that we saw in UIResponder, touchesEnded withEvent.

513
00:35:40,440 --> 00:35:43,770
And then we're going to check to see if we're a tap.

514
00:35:43,770 --> 00:35:52,650
And I'm kind of cheating a bit here by using UITouch's tap
count property so I can actually avoid having any state.

515
00:35:52,650 --> 00:35:57,280
So we'll ask the event for all the
touches for gesture recognizer self.

516
00:35:57,280 --> 00:35:59,410
So that's our subclass.

517
00:35:59,410 --> 00:36:01,360
And get their count.

518
00:36:01,360 --> 00:36:05,990
So if the event knows that there's more than one touch
in the gesture recognizer, it's not a single tap.

519
00:36:05,990 --> 00:36:09,850
We're actually -- for a simple tap, we're
just looking for a single finger, single tap.

520
00:36:09,850 --> 00:36:12,540
So if there's more than one touch we're not a tap.

521
00:36:12,540 --> 00:36:18,800
Also then, once we know that there's exactly one touch we
can call touches anyObject, because we know there's only one

522
00:36:18,800 --> 00:36:22,980
to get the UITouch out and get
its tap count and see if it's 1.

523
00:36:22,980 --> 00:36:27,910
So if we have 1 touch and that 1 touch is
a tap, then we know we recognize the tap.

524
00:36:27,910 --> 00:36:31,900
So set our state to UIGestureRecognizerStateRecognized.

525
00:36:31,900 --> 00:36:33,650
If that's not the case then we must have failed.

526
00:36:33,650 --> 00:36:36,440
We either have too many touches or the touch wasn't a tap.

527
00:36:36,440 --> 00:36:42,780
So in that case, self.state = UIGestureRecognizerStateFailed
to indicate that we failed.

528
00:36:42,780 --> 00:36:46,860
Now you know, this is all right,
but we're not failing very quickly.

529
00:36:46,860 --> 00:36:51,200
And in fact we've also ignored the
whole case of touch cancellation.

530
00:36:51,200 --> 00:36:57,170
So first let's introduce touchesCancelled withEvent, to
make sure that we don't drop any touches on the floor

531
00:36:57,170 --> 00:37:01,720
and fail to move to one of those four end states which
could end up hanging the rest of our recognition.

532
00:37:01,720 --> 00:37:03,280
So touchesCancelled withEvent.

533
00:37:03,280 --> 00:37:06,070
If the touch is being cancelled
we definitely aren't tapping.

534
00:37:06,070 --> 00:37:06,980
Touch is being cancelled.

535
00:37:06,980 --> 00:37:12,230
So unconditionally, we can set our
state to UIGestureRecognizerStateFailed.

536
00:37:12,230 --> 00:37:15,880
But now we really want to, you know, fail quickly.

537
00:37:15,880 --> 00:37:17,330
Because we like to fail.

538
00:37:17,330 --> 00:37:24,410
So UI -- sorry, touchesBegan withEvent is the
first place we have the opportunity to fail.

539
00:37:24,410 --> 00:37:28,130
So in this case we want to see
if we've got more than one touch.

540
00:37:28,130 --> 00:37:33,380
So the same thing we did in touchesEnded, we'll call it
event, touches for gesture recognizer self, get the count.

541
00:37:33,380 --> 00:37:39,150
And if it's greater than 1, we'll set our state
to failed so that we failed really, really soon.

542
00:37:39,150 --> 00:37:43,620
But even if there's only one finger on screen
we can fail if that finger's moved really far.

543
00:37:43,620 --> 00:37:46,420
So we'll implement touchesMoved withEvent.

544
00:37:46,420 --> 00:37:50,020
And we'll check to see if that touch is still a tap.

545
00:37:50,020 --> 00:37:55,240
So we already know that there's only one touch, because
we failed in state began if that wasn't the case.

546
00:37:55,240 --> 00:37:59,150
So we can call touches anyObject, and get its tap count.

547
00:37:59,150 --> 00:38:02,700
And if it's not 1 then we're no longer a tap.

548
00:38:02,700 --> 00:38:06,550
So we can set self.state = UIGestureRecognizerStateFailed.

549
00:38:06,550 --> 00:38:08,050
So now we're actually failing quickly.

550
00:38:08,050 --> 00:38:12,040
And it's -- you know, incrementally better
implementation than what we started with.

551
00:38:12,040 --> 00:38:14,190
But still not nearly as good as UI tap gesture recognizer.

552
00:38:14,190 --> 00:38:16,240
So you know, don't do it.

553
00:38:16,240 --> 00:38:22,430
All right, so now, another thing Brad talked
about, if you were here in the last session,

554
00:38:22,430 --> 00:38:26,430
is that tap gesture recognizers should usually be stackable.

555
00:38:26,430 --> 00:38:31,440
If you tap twice you've had both a
single tap and a double-tap happen.

556
00:38:31,440 --> 00:38:34,950
And usually you want to fire action
methods for both of those things.

557
00:38:34,950 --> 00:38:40,020
But as we have it implemented, a single tap gesture
recognizer will always exclude a double-tap,

558
00:38:40,020 --> 00:38:42,300
because the single tap will be recognized first.

559
00:38:42,300 --> 00:38:45,640
So, you know, that's not ideal.

560
00:38:45,640 --> 00:38:46,970
So how can we fix that.

561
00:38:46,970 --> 00:38:49,940
Well, you could require all your users to actually implement

562
00:38:49,940 --> 00:38:54,010
that gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: method.

563
00:38:54,010 --> 00:38:57,710
But then they might spend the rest of their time
writing that method because it's so ridiculously long.

564
00:38:57,710 --> 00:39:01,750
So you probably want to prevent
this on your own in the subclass.

565
00:39:01,750 --> 00:39:09,350
And we provided two methods that you can override
to affect the exclusivity rules in your subclass.

566
00:39:09,350 --> 00:39:13,690
The first is -- canPreventGestureRecognizer.

567
00:39:13,690 --> 00:39:17,580
And in order to see this, we're going to pretend
that we've now rewritten our code in touchesBegan,

568
00:39:17,580 --> 00:39:19,680
moved, and ended to support multiple taps.

569
00:39:19,680 --> 00:39:27,800
So we'll add this number of taps required property so that
we can set a single or double-tap, tap gesture recognizer.

570
00:39:27,800 --> 00:39:34,540
So now we can implement canPreventGestureRecognizer to allow a single tap

571
00:39:34,540 --> 00:39:37,240
and a double-tap to happen at the same time.

572
00:39:37,240 --> 00:39:40,260
So in order to do that, we really just want to make sure --

573
00:39:40,260 --> 00:39:43,920
and this is in our subclass, so self
is a simple tap gesture recognizer.

574
00:39:43,920 --> 00:39:49,520
We want to make sure that our tap count
is -- are they greater or less than --

575
00:39:49,520 --> 00:39:54,620
though I should probably see, because I forget.

576
00:39:54,620 --> 00:39:59,100
First we should make sure that we are kind
of class, simple tap gesture recognizer.

577
00:39:59,100 --> 00:40:04,310
And if -- sorry, if the other --
yeah, let's start over here.

578
00:40:04,310 --> 00:40:06,750
We should see if the other gestures
recognizers we're finding

579
00:40:06,750 --> 00:40:09,620
out about preventing is a simple tap gesture recognizer.

580
00:40:09,620 --> 00:40:13,390
If it is, we know that it implements that
number of taps required method as well.

581
00:40:13,390 --> 00:40:19,180
So we can see if the other gesture recognizer's
number of taps required is greater than ours.

582
00:40:19,180 --> 00:40:23,650
So we are a single tap gesture recognizer, and
this other one is a double-tap gesture recognizer.

583
00:40:23,650 --> 00:40:26,960
In that case we do not want to prevent it.

584
00:40:26,960 --> 00:40:28,820
So we return no.

585
00:40:28,820 --> 00:40:34,200
And if that's not the case then either the other
thing is not a simple tap gesture recognizer,

586
00:40:34,200 --> 00:40:37,620
or it has a lower tap count than us,
in which case we do want to prevent it.

587
00:40:37,620 --> 00:40:39,540
So we'll just go back to the default, then.

588
00:40:39,540 --> 00:40:41,070
And return yes.

589
00:40:41,070 --> 00:40:44,960
Now I mention that there's two methods provided here,
and the other one is just kind of the inverse of this.

590
00:40:44,960 --> 00:40:48,780
It's canBePreventedByGestureRecognizer
which gives you the other way.

591
00:40:48,780 --> 00:40:52,840
So this let's you determine if you want to prevent
another gesture recognizer and can be prevented

592
00:40:52,840 --> 00:40:57,530
by let's you determine if you want to be
prevented by another gesture recognizer.

593
00:40:57,530 --> 00:41:02,540
So the delegate methods should recognize
simultaneously with just -- oh man, too many words --

594
00:41:02,540 --> 00:41:07,300
the delegate method gesture recognizer should
recognize simultaneously with gesture recognizer,

595
00:41:07,300 --> 00:41:09,610
is basically both of these combined, right?

596
00:41:09,610 --> 00:41:13,500
You can determine that two things
can recognize at the same time.

597
00:41:13,500 --> 00:41:17,190
This gives you slightly more control in that you
can determine which one should exclude the other.

598
00:41:17,190 --> 00:41:22,370
So as a subclass, you've got a bit
more control than as the delegate.

599
00:41:22,370 --> 00:41:29,570
So before we have Brad come up and show us how to actually
implement some of this stuff there's a couple of points

600
00:41:29,570 --> 00:41:33,570
that are pretty important to keep in mind
while you're writing your gesture recognizers.

601
00:41:33,570 --> 00:41:41,550
The first is that as much as you can, you should perform
your calculations for recognition in screen coordinates.

602
00:41:41,550 --> 00:41:45,300
Now you might be thinking why is this important?

603
00:41:45,300 --> 00:41:49,010
Well, we actually found this out sort of
by accident with trial and error over time,

604
00:41:49,010 --> 00:41:51,680
so we want you to learn from our mistakes.

605
00:41:51,680 --> 00:41:54,770
We implemented UI long press gesture recognizer,

606
00:41:54,770 --> 00:41:58,770
doing its recognition in the coordinate
space of the view it was attached to.

607
00:41:58,770 --> 00:42:00,670
And that seemed great, everything worked fine.

608
00:42:00,670 --> 00:42:06,160
You would put your finger down and after some period of time
the action method would fire because it was a long press.

609
00:42:06,160 --> 00:42:13,510
But then we put long press gesture recognizers inside of
an UI scroll view, a view that's in an UI scroll view.

610
00:42:13,510 --> 00:42:18,320
So we would start scrolling around and
some time later our long press would fire

611
00:42:18,320 --> 00:42:23,150
because the long press gesture recognizer was calculating
the coordinate space of the view it was attached to,

612
00:42:23,150 --> 00:42:26,670
which was moving with our finger because
the scroll view was scrolling it.

613
00:42:26,670 --> 00:42:30,240
So that's not really a long press, I mean,
your finger is moving all over the place.

614
00:42:30,240 --> 00:42:34,590
If we had done the calculations in screen coordinates
we would have avoided that problem entirely.

615
00:42:34,590 --> 00:42:39,320
So you know, perform calculations for
recognition in screen coordinates.

616
00:42:39,320 --> 00:42:46,910
But then when you go to actually use the values, so
if you're applying -- reporting a scale or a rotation,

617
00:42:46,910 --> 00:42:51,390
you generally then want to convert back to local
view coordinates to report those coordinates

618
00:42:51,390 --> 00:42:54,680
to the code using your gesture recognizer.

619
00:42:54,680 --> 00:42:59,640
So an example of that is UI pan gesture recognizer,
which provides the translation, actually,

620
00:42:59,640 --> 00:43:04,190
through a method called translation in view that let's
your user determine what coordinate space they want

621
00:43:04,190 --> 00:43:05,530
to the translation in.

622
00:43:05,530 --> 00:43:09,060
If you don't offer the coordinate
space you probably just want

623
00:43:09,060 --> 00:43:11,620
to pick the view that you're attached to as the default.

624
00:43:11,620 --> 00:43:14,760
But it can be useful to let the user decide to.

625
00:43:14,760 --> 00:43:18,790
Not the user, but the other code
using your gesture recognizer.

626
00:43:18,790 --> 00:43:24,090
So yeah, that's kind of our best practices,
stuff we've seen that we've done wrong.

627
00:43:24,090 --> 00:43:26,120
Hopefully you guys don't fall into the same trap.

628
00:43:26,120 --> 00:43:29,120
So with that in mind, I'd just like
to have Brad come up and show us how

629
00:43:29,120 --> 00:43:33,010
to actually write an UIGestureRecognizer subclass.

630
00:43:33,010 --> 00:43:34,500
[ Applause ]

631
00:43:34,500 --> 00:43:36,040
>> Brad Moore: All right, thank you, Josh.

632
00:43:36,040 --> 00:43:41,070
Here we have a project that's made the
rounds at WWDC and most recently was featured

633
00:43:41,070 --> 00:43:45,390
at Stamford CS193P iPhone programming course.

634
00:43:45,390 --> 00:43:47,090
And I'll just show you what it looks like.

635
00:43:47,090 --> 00:43:49,050
Kind of familiar if you were here for the last session.

636
00:43:49,050 --> 00:43:55,260
It's a Lightroom-like app, where you manipulate
images, you can translate them, you can put two fingers

637
00:43:55,260 --> 00:43:58,490
down at the same time and translate both together.

638
00:43:58,490 --> 00:44:00,880
And you can even pinch and scale.

639
00:44:00,880 --> 00:44:03,960
So pretty cool, right?

640
00:44:03,960 --> 00:44:06,850
This was done before gesture recognizers existed.

641
00:44:06,850 --> 00:44:09,490
So I'll show you briefly how it's implemented.

642
00:44:09,490 --> 00:44:21,420
We have a View Controller that adds three
touch image views to its subview, to its view.

643
00:44:21,420 --> 00:44:28,580
And touch image view is a subclass of UIImageView.

644
00:44:28,580 --> 00:44:35,500
And touch image view exploits this really cute property
of coordinate systems where if you have two points

645
00:44:35,500 --> 00:44:40,310
at one coordinate system and the same two points
in another coordinate system you can figure

646
00:44:40,310 --> 00:44:44,060
out an outline transform to transform one to the other.

647
00:44:44,060 --> 00:44:50,440
It's really convenient and it's especially
convenient, because UIView has a transform property.

648
00:44:50,440 --> 00:44:54,680
So if we go and look at the code -- well
first let's look at the instance variables.

649
00:44:54,680 --> 00:45:01,750
We save the original transform and we have a
dictionary mapping the touches to the initial points.

650
00:45:01,750 --> 00:45:07,130
And as we go and look at the code and
here I'll just focus on the touch methods,

651
00:45:07,130 --> 00:45:11,390
in touchesBegan, we save away those initial points.

652
00:45:11,390 --> 00:45:17,200
In touchesMoved, we compute an incremental transform
using that property of coordinate systems I mentioned,

653
00:45:17,200 --> 00:45:21,860
and then we just set the transform
on the view because this is a view.

654
00:45:21,860 --> 00:45:25,890
In touchesEnded we clean up state,
in touchesCancelled, we do the same.

655
00:45:25,890 --> 00:45:28,710
Now look again at touchesMoved.

656
00:45:28,710 --> 00:45:34,610
This is a really easy way to handle a Lightroom-style app.

657
00:45:34,610 --> 00:45:36,950
We just say self transform.

658
00:45:36,950 --> 00:45:43,130
But the handling of the method, this one
line self-transform is very tightly coupled

659
00:45:43,130 --> 00:45:47,510
to all the recognition that's going on of their transform.

660
00:45:47,510 --> 00:45:53,690
And it would be nice if we could decouple them and use
this transform property across all manner of views.

661
00:45:53,690 --> 00:45:55,860
So that's what we're going to try to do today.

662
00:45:55,860 --> 00:45:58,350
And so first I'm going to add a new file.

663
00:45:58,350 --> 00:46:03,940
I'm going to call it transform gesture recognizer.

664
00:46:03,940 --> 00:46:12,250
And transform gesture recognizer is just
a basic subclass of UIGestureRecognizer.

665
00:46:12,250 --> 00:46:13,650
And look at the implementation.

666
00:46:13,650 --> 00:46:16,830
There's nothing here, it's just scaffolding.

667
00:46:16,830 --> 00:46:23,730
And I'm going to go through and paste in
everything we had in the touch image view.

668
00:46:23,730 --> 00:46:28,880
So the first thing is an original
transform and touch begin points.

669
00:46:28,880 --> 00:46:31,370
Well, we still need those here absolutely.

670
00:46:31,370 --> 00:46:39,120
One additional ivar I want to add is the ivar that
was on the touch image view as part of its view.

671
00:46:39,120 --> 00:46:40,830
It had a transform property.

672
00:46:40,830 --> 00:46:46,200
Well, we don't have a transform property on
transform gesture recognizer, in UIGestureRecognizer.

673
00:46:46,200 --> 00:46:48,350
So we need to implement that.

674
00:46:48,350 --> 00:46:50,910
So we'll add storage for that.

675
00:46:50,910 --> 00:46:53,360
And let's go ahead and declare a property.

676
00:46:53,360 --> 00:47:00,320
It's a cgf line transform, which maps between coordinate
systems, and note here that I've made it read/write.

677
00:47:00,320 --> 00:47:04,960
Strictly speaking, it could just be read only
and it really wouldn't change the implementation.

678
00:47:04,960 --> 00:47:06,730
But if you were here for the last session you saw

679
00:47:06,730 --> 00:47:14,560
that as a convenience making these properties writable
really simplifies what you have to do in your action method.

680
00:47:14,560 --> 00:47:20,060
So if you have a continuous gesture recognizer
consider making properties like this writable.

681
00:47:20,060 --> 00:47:21,690
OK, so into the Implementation file.

682
00:47:21,690 --> 00:47:29,280
All right, the very first thing I'm going to
do is import UIGestureRecognizer subclass.

683
00:47:29,280 --> 00:47:34,440
And this is crucially important, because the
job of this gesture recognizer is going to be --

684
00:47:34,440 --> 00:47:38,060
to manipulate both its transform state, but to interact

685
00:47:38,060 --> 00:47:44,050
with the gesture recognizer runtime
we need to manipulate the state.

686
00:47:44,050 --> 00:47:48,810
And the state is a read only property, as
Josh mentioned, in UIGestureRecognizer.h.

687
00:47:48,810 --> 00:47:52,620
When we import the subclass header
we can start manipulating it.

688
00:47:52,620 --> 00:47:56,820
OK, so let's get started.

689
00:47:56,820 --> 00:48:03,740
First I want to add an initializer and I'll set the identity
-- I'll set the transforms to identity to start with.

690
00:48:03,740 --> 00:48:07,980
And I'll initialize a dictionary
that I can manipulate later.

691
00:48:07,980 --> 00:48:11,750
And similarly, I'll clean it up in dealloc.

692
00:48:11,750 --> 00:48:17,900
Now let's go through one at a time pasting methods
from that other file where gesture recognition

693
00:48:17,900 --> 00:48:20,760
and gesture handling were tightly coupled.

694
00:48:20,760 --> 00:48:23,610
So first, touchesBegan.

695
00:48:23,610 --> 00:48:25,820
Can we use this exactly as it is?

696
00:48:25,820 --> 00:48:27,360
Well, nearly.

697
00:48:27,360 --> 00:48:32,240
But we need to change event touches
for view to something else.

698
00:48:32,240 --> 00:48:35,590
Event touches for recognizer is a better fit for us.

699
00:48:35,590 --> 00:48:39,840
And so if I just paste that in we're done with touchesBegan.

700
00:48:39,840 --> 00:48:42,020
Another really has to change.

701
00:48:42,020 --> 00:48:45,040
Note, however, that if we were to try to do something

702
00:48:45,040 --> 00:48:49,050
like call super touches begin, it
would have absolutely no effect here.

703
00:48:49,050 --> 00:48:54,330
Whereas in the UIView subclass it might do
something interesting with the responder chain.

704
00:48:54,330 --> 00:48:56,670
OK, so that's touchesBegan.

705
00:48:56,670 --> 00:48:59,590
Let's go into touchesMoved.

706
00:48:59,590 --> 00:49:03,980
Well, similarly here, I'm using event touches for view.

707
00:49:03,980 --> 00:49:06,880
Again, that's not really appropriate
for the gesture recognizer.

708
00:49:06,880 --> 00:49:09,980
I could pull the view property off of my gesture recognizer.

709
00:49:09,980 --> 00:49:13,580
But what I really want is touches for gesture recognizer.

710
00:49:13,580 --> 00:49:18,080
And while I'm creating incremental
transform variable on the stack here,

711
00:49:18,080 --> 00:49:21,650
there's no reason I can't just directly
assign it to my instance variable.

712
00:49:21,650 --> 00:49:23,820
So I'll go ahead and do that.

713
00:49:23,820 --> 00:49:33,680
And this key method -- sorry, this key line, self.transform,
that's the tightly-coupled handling from the view subclass.

714
00:49:33,680 --> 00:49:34,730
We don't want to do that here.

715
00:49:34,730 --> 00:49:37,440
So let's just remove it.

716
00:49:37,440 --> 00:49:42,070
And I could stop here and continue on to touchesEnded.

717
00:49:42,070 --> 00:49:45,360
But I want to point out that it's
our job to update the state.

718
00:49:45,360 --> 00:49:52,070
So the very important thing I'm going to do here is update
my state so that the gesture recognizer is recognized.

719
00:49:52,070 --> 00:49:57,920
If I'm in state possible, then it's probably
appropriate to move to the began state now.

720
00:49:57,920 --> 00:50:01,940
I'm going to make sure first that
it's not the identity transform,

721
00:50:01,940 --> 00:50:07,780
if that's the case then it's not really a transform
gesture recognizer, a transform gesture yet.

722
00:50:07,780 --> 00:50:13,470
And if I'm not in the possible state then
I must already be in a recognized state.

723
00:50:13,470 --> 00:50:16,720
So let's just update the state to changed.

724
00:50:16,720 --> 00:50:19,450
And that's it for touchesMoved.

725
00:50:19,450 --> 00:50:22,960
So now I'm going to paste in touchesEnded.

726
00:50:22,960 --> 00:50:27,590
And again, I've got two places
where I'm using touchesForView.

727
00:50:27,590 --> 00:50:30,960
Instead, I'll use touches for recognizer.

728
00:50:30,960 --> 00:50:36,220
And now I need to be very, very careful
that I always get into a terminal state.

729
00:50:36,220 --> 00:50:41,290
If I have just implemented the state
transitions in touchesMoved I'd be left

730
00:50:41,290 --> 00:50:45,450
with my target action pairs firing continuously.

731
00:50:45,450 --> 00:50:53,520
So I need to go in and say if I'm out of the possible
state already and if my remaining touches have dropped

732
00:50:53,520 --> 00:50:56,600
to zero, well definitely go into the state ended.

733
00:50:56,600 --> 00:51:02,290
And this is going to allow a lot of
things, like touches to be delivered,

734
00:51:02,290 --> 00:51:05,610
cancelled, and it will allow for automatic reset.

735
00:51:05,610 --> 00:51:07,250
Crucially important.

736
00:51:07,250 --> 00:51:09,900
And let's just paste in touchesCancelled.

737
00:51:09,900 --> 00:51:13,690
And here we're calling through directly to touchesEnded.

738
00:51:13,690 --> 00:51:19,180
We could go ahead and set the state to
UIGestureRecognizerStateCancelled instead.

739
00:51:19,180 --> 00:51:23,200
But because we have some knowledge of how
the transform gesture recognizer is going

740
00:51:23,200 --> 00:51:28,030
to be used it's not really reasonable
to set it back to the cancelled state.

741
00:51:28,030 --> 00:51:30,340
So it's fine to leave it like this.

742
00:51:30,340 --> 00:51:33,570
So I've pasted over my UIResponder methods.

743
00:51:33,570 --> 00:51:34,750
Am I done?

744
00:51:34,750 --> 00:51:37,570
Well, if this were a responder, that really would be it.

745
00:51:37,570 --> 00:51:41,580
I could fill in the helper methods and
there would be nothing further to do.

746
00:51:41,580 --> 00:51:46,920
But because this is an UIGestureRecognizer, I can't
rely on receiving the entire sequence of touch input.

747
00:51:46,920 --> 00:51:50,600
So it's crucially important to implement the reset method.

748
00:51:50,600 --> 00:51:52,130
And I'll do two things here.

749
00:51:52,130 --> 00:51:58,320
I'm going to clear out the dictionary mapping touches
to point, and here I'm just using a block enumerator

750
00:51:58,320 --> 00:52:02,090
to free some objects I put on the heap, some points.

751
00:52:02,090 --> 00:52:03,720
And I remove values.

752
00:52:03,720 --> 00:52:08,120
And then I'm going to set the transforms back to identity.

753
00:52:08,120 --> 00:52:13,720
And while I'm in the neighborhood, let's just
quickly implement the transform property.

754
00:52:13,720 --> 00:52:21,280
The getters is going to take the original transform and
concatenate incremental transform and setter is just going

755
00:52:21,280 --> 00:52:26,850
to replace the original transform with the
new transform and throw away the incremental.

756
00:52:26,850 --> 00:52:31,590
OK, so now all that remains is
to add in the helper scaffolding.

757
00:52:31,590 --> 00:52:33,580
I'll do that now.

758
00:52:33,580 --> 00:52:38,930
So we still want this convenience category
on UITouch that makes it easy to sort.

759
00:52:38,930 --> 00:52:46,100
We want this -- this method, incremental
transform with touches, is the meat of the math.

760
00:52:46,100 --> 00:52:49,660
It takes those two points in one coordinate system,

761
00:52:49,660 --> 00:52:52,810
takes two points in another coordinate
system and comes up with a transform.

762
00:52:52,810 --> 00:53:00,310
So I'm just going to go through here and update location
and view to use location and view, self view super view.

763
00:53:00,310 --> 00:53:05,020
Notice what I did, we used to be relying on self super view.

764
00:53:05,020 --> 00:53:08,870
And that's no longer appropriate, because
this is a gesture recognizer, not a view.

765
00:53:08,870 --> 00:53:11,860
But we have access to the view.

766
00:53:11,860 --> 00:53:22,320
So self view super view, and similarly, we don't
want center on ourselves, we want center of our view.

767
00:53:22,320 --> 00:53:26,460
And none of the other math has to change, we're done here.

768
00:53:26,460 --> 00:53:35,930
So continuing to add these helpers, well, this
actually is an update, original transform for touches.

769
00:53:35,930 --> 00:53:39,240
What we're doing when a second
finger or a third finger comes

770
00:53:39,240 --> 00:53:42,200
down on the screen we're kind of recentering the transform.

771
00:53:42,200 --> 00:53:46,860
If you saw the previous example
in the last session it's like re--

772
00:53:46,860 --> 00:53:53,640
adjusting the anchor input so we're going
to go here and do something similar,

773
00:53:53,640 --> 00:53:57,960
but we don't want to set the transaction form on ourselves.

774
00:53:57,960 --> 00:54:02,570
We want to -- this was previously
updating in the view itself.

775
00:54:02,570 --> 00:54:08,530
So we're going to go through here and
yes, compute incremental transform.

776
00:54:08,530 --> 00:54:16,490
We're going to update the original transform and we'll
then set the incremental transform back to identity.

777
00:54:16,490 --> 00:54:19,320
So couple of other helpers.

778
00:54:19,320 --> 00:54:22,160
We want to store away the begin points.

779
00:54:22,160 --> 00:54:27,860
Nothing changes except we want to do this in
an actual view, not in a super view property

780
00:54:27,860 --> 00:54:30,400
that doesn't existent on UIView gesture recognizer.

781
00:54:30,400 --> 00:54:35,290
And we want to remove touches from
the caches at certain points.

782
00:54:35,290 --> 00:54:37,480
And there's absolutely nothing here that needs to change.

783
00:54:37,480 --> 00:54:40,280
So there's still a lot of code in this class.

784
00:54:40,280 --> 00:54:43,760
Most of it was just copy, pasted blatantly.

785
00:54:43,760 --> 00:54:49,080
But now we have an object that is reusable
and can work in a wide variety of views.

786
00:54:49,080 --> 00:54:53,610
So let's go back to the View Controller
and start changing things.

787
00:54:53,610 --> 00:54:56,020
Well firstly we don't need touch image view any more.

788
00:54:56,020 --> 00:55:05,450
So it's kind of satisfying to go and delete this,
although we've really just migrated most of the code.

789
00:55:05,450 --> 00:55:14,760
So any implementation will change what we're
importing to be our new transform gesture recognizer.

790
00:55:14,760 --> 00:55:22,100
And then here where we're allocating touch image
views we're just going to use vanilla UIImageViews.

791
00:55:22,100 --> 00:55:27,880
Note that I'm setting the user interaction enabled
property to yes, because UIImageView's default

792
00:55:27,880 --> 00:55:32,490
to not being interactive, and so the
gesture recognizer wouldn't receive it.

793
00:55:32,490 --> 00:55:35,520
OK, do the same here.

794
00:55:35,520 --> 00:55:38,260
And do the same here.

795
00:55:38,260 --> 00:55:41,980
And I'm going to attach a gesture recognizer, at the same --

796
00:55:41,980 --> 00:55:46,830
well, gesture recognizers of the
same type to each of these views.

797
00:55:46,830 --> 00:55:49,220
And I'll add a helper method to do that.

798
00:55:49,220 --> 00:55:55,740
So assuming that helper method exists, I'm just going to
go through down the line, add transform gesture to view.

799
00:55:55,740 --> 00:56:02,200
And let's go ahead and actually add that implementation.

800
00:56:02,200 --> 00:56:08,330
And that just allocates a transform gesture recognizer,
sets the target to self, the View Controller,

801
00:56:08,330 --> 00:56:11,400
and gives a handle transform action method.

802
00:56:11,400 --> 00:56:15,400
It adds it to the view and releases
it, because it's retained by the view.

803
00:56:15,400 --> 00:56:20,710
OK? Let's actually implement that handler.

804
00:56:20,710 --> 00:56:27,280
Well, what we saw before in the tightly-coupled code was we
just took a transform and applied it straight to the view.

805
00:56:27,280 --> 00:56:31,790
And we can pull the transform out of the
transform recognizer, and that works great.

806
00:56:31,790 --> 00:56:33,760
We could just set it here.

807
00:56:33,760 --> 00:56:39,380
But what we'd really like to do is
concatenate it to the initial view state.

808
00:56:39,380 --> 00:56:41,580
We don't want to keep resetting back to zero.

809
00:56:41,580 --> 00:56:47,850
So let's look at the state and if it's in
the began state pull out the transform,

810
00:56:47,850 --> 00:56:51,580
concatenate it to the original transform,
and then set the transform again.

811
00:56:51,580 --> 00:56:58,700
So we're using that writable property to really
not store additional state in this View Controller.

812
00:56:58,700 --> 00:57:07,990
And then finally we just set -- the view -- gesture
recognizers views transform to that transform.

813
00:57:07,990 --> 00:57:15,410
So we've done all this work, and we're working
with UIImageViews now instead of touch image views.

814
00:57:15,410 --> 00:57:19,160
And we get you know, basically the same behavior.

815
00:57:19,160 --> 00:57:23,940
And it's like, well, why do you go to this trouble,
it worked before, what's the point of doing this.

816
00:57:23,940 --> 00:57:29,890
And I think you know what's coming, as in
the previous example in the last session,

817
00:57:29,890 --> 00:57:32,910
we can now add this gesture recognizer to other things.

818
00:57:32,910 --> 00:57:37,670
So I'm going to take this View
Controller's view and add the gesture to it.

819
00:57:37,670 --> 00:57:39,270
And let's see what happens.

820
00:57:39,270 --> 00:57:46,820
OK? And now I can translate the entire thing, I
can pinch the entire thing, I can pinch and scale

821
00:57:46,820 --> 00:57:50,170
and rotate the entire thing, and specific subviews.

822
00:57:50,170 --> 00:57:58,350
What happens when I put one finger or one mouse in one
view and the outer view, and another in an inner view.

823
00:57:58,350 --> 00:58:01,310
Well, it actually translates.

824
00:58:01,310 --> 00:58:04,270
Which wasn't exactly what I expected.

825
00:58:04,270 --> 00:58:09,490
And to understand why this is happening, you need to
remember the rules of gesture recognizer precedence.

826
00:58:09,490 --> 00:58:14,790
And so the deepest gesture recognizer in the
view hierarchy, the one that's a leaf node,

827
00:58:14,790 --> 00:58:19,180
will get precedence for this touch,
even if they recognize at the same time.

828
00:58:19,180 --> 00:58:27,310
So what we can do is go back to our gesture recognizer
and in touchesMoved, we're already doing some work

829
00:58:27,310 --> 00:58:33,190
to make sure we don't transition to the
began state if it's an identity transfer.

830
00:58:33,190 --> 00:58:39,600
We can make it a little more judicious
in transitioning to the began state.

831
00:58:39,600 --> 00:58:46,290
So if this is merely a translation transform then
we can say well, it has to pass some threshold.

832
00:58:46,290 --> 00:58:57,120
And that's not a bad idea, because UIGestureRecognizers
that automatically go to the began state as soon

833
00:58:57,120 --> 00:59:00,810
as touches move are going to recognize almost immediately.

834
00:59:00,810 --> 00:59:05,020
It's like recognizing as soon as
any touch comes down on the screen.

835
00:59:05,020 --> 00:59:16,390
And so we'll add this additional filtering and go
and look at the done up, and now I can do things

836
00:59:16,390 --> 00:59:21,900
like pinch the outer view, translate
something, translate views independently,

837
00:59:21,900 --> 00:59:27,630
but rotate views when I've got fingers, two fingers down.

838
00:59:27,630 --> 00:59:29,400
And things just work.

839
00:59:29,400 --> 00:59:35,120
And I've completely decoupled my implementation
and handling from the transform gesture recognizer

840
00:59:35,120 --> 00:59:36,680
which has this really convenient property.

841
00:59:36,680 --> 00:59:43,190
So now I can go ahead and add Lightroom
behavior to any view I can conceive of.

842
00:59:43,190 --> 00:59:45,120
OK, and that's really it for the demo.

843
00:59:45,120 --> 00:59:47,380
So I'll turn it back over to the Josh.

844
00:59:47,380 --> 00:59:49,240
>> Josh Shaffer: All right.

845
00:59:49,240 --> 00:59:50,260
Thanks, Brad.

846
00:59:50,260 --> 00:59:55,630
So I hope that that kind of gave you a feel for the fact
that it's actually really easy to take the existing code

847
00:59:55,630 --> 00:59:58,810
that you've got and migrate it into a gesture recognizer.

848
00:59:58,810 --> 01:00:03,560
The only real additions Brad made were the movement
through the states, and the only changes were

849
01:00:03,560 --> 01:00:06,970
to change those couple methods
to touches for gesture recognizer.

850
01:00:06,970 --> 01:00:10,710
So if you want more information, Bill Dudney
is our Application Frameworks Evangelist,

851
01:00:10,710 --> 01:00:15,640
there's plenty of documentation on UIGestureRecognizer,
and obviously the Dev Forums are there,

852
01:00:15,640 --> 01:00:18,570
we answer questions as much as we can and
it's a great place to help each other.

853
01:00:18,570 --> 01:00:24,720
There's some related sessions, obviously right before this
we had Simplifying Touch Handling With Gesture Recognizers,

854
01:00:24,720 --> 01:00:31,340
tomorrow there's a Mastering Table View Session at the
same room at 11:30 a.m., and they're going to be talking

855
01:00:31,340 --> 01:00:35,570
about plenty of stuff with Table views,
which really cool, but also getting into some

856
01:00:35,570 --> 01:00:41,540
of how you might use just the recognizers
inside of Table view, which is also really cool.

857
01:00:41,540 --> 01:00:41,880
Thanks.

