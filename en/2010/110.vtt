WEBVTT

00:00:06.350 --> 00:00:06.660
>> Douglas Davidson: All right.

00:00:06.660 --> 00:00:08.180
Good afternoon, everyone.

00:00:08.180 --> 00:00:09.370
I'm Doug Davidson.

00:00:09.370 --> 00:00:14.710
And along with my colleague, Julio Gonzalez,
I'm here to talk to you about text handling.

00:00:14.710 --> 00:00:20.450
So, just about every application has to
deal with text in one form or another.

00:00:20.450 --> 00:00:26.030
For many applications, it's enough to just use
standard controls, text field, text view, web view,

00:00:26.030 --> 00:00:29.510
drag them in the Interface Builder,
and you're done, that's fine.

00:00:29.510 --> 00:00:37.450
This session though is for applications that want to
go a little deeper, either through detailed analysis

00:00:37.450 --> 00:00:41.170
of the content of text or through custom presentation of it.

00:00:41.170 --> 00:00:44.860
You know, we have a great system
here for text and topography.

00:00:44.860 --> 00:00:47.190
It's worth putting a little extra effort into it.

00:00:47.190 --> 00:00:52.040
We're going to be concentrating
on the APIs that are new in iOS 4.

00:00:52.040 --> 00:00:58.490
You can refer back to the last year's sessions for more
detailed information about some of the earlier APIs.

00:00:58.490 --> 00:01:05.410
So, first of all, I'll be talking about some of
the APIs that we have for analysis of text content,

00:01:05.410 --> 00:01:10.970
and Julio will be coming up and talking
about fonts and text rendering and display.

00:01:10.970 --> 00:01:16.520
Before we start, I want to take a brief moment to
orient us as to where we are in the operating system.

00:01:16.520 --> 00:01:21.740
So, up in the top, we have UIKit which
is where those standard controls,

00:01:21.740 --> 00:01:23.910
the text fields and text views and so on, live.

00:01:23.910 --> 00:01:31.420
Down at the bottom, we have CoreFoundation, which is the
low level procedural interface to some of the basic objects

00:01:31.420 --> 00:01:35.500
in the system, things like the
collections and strings, and so forth.

00:01:35.500 --> 00:01:41.300
And in between, we have Foundation,
which is the object-oriented interface

00:01:41.300 --> 00:01:45.310
to the collections and strings and a few other things.

00:01:45.310 --> 00:01:50.720
And we also have Quartz, which is
the low level 2D graphics framework.

00:01:50.720 --> 00:01:55.930
And then above that, Core Text, which
is our low level text layout framework.

00:01:55.930 --> 00:02:01.900
Now, those of you who have this experience with the
desktop operating system may recognize some of these

00:02:01.900 --> 00:02:08.680
because everything below UIKit here is essentially common
to, well, to phone and the desktop operating systems.

00:02:08.680 --> 00:02:13.150
So, you can pay attention to this for both.

00:02:13.150 --> 00:02:17.070
Now, in my part, I'm going to be spending most
of time in the left-hand side of this dealing

00:02:17.070 --> 00:02:18.840
with CoreFoundation, Foundation, and UIKit.

00:02:18.840 --> 00:02:25.200
So, at the bottom, we have CoreFoundation, which I say
is the low level of procedural interface to arrays,

00:02:25.200 --> 00:02:28.490
and collections, and strings, and so forth.

00:02:28.490 --> 00:02:33.720
Above that Foundation, where I'm going to be spending
most of my time, is the object-oriented interface

00:02:33.720 --> 00:02:37.990
to that same functionality, but also
it has a few other things with it.

00:02:37.990 --> 00:02:41.500
And on top, there is UIKit.

00:02:41.500 --> 00:02:47.990
So, first, I want to give a brief
introduction to our string objects.

00:02:47.990 --> 00:02:54.930
The basic object for handling text
in our operating systems is NSString.

00:02:54.930 --> 00:02:56.670
This is our fundamental string object.

00:02:56.670 --> 00:03:00.180
And into it, we have poured everything
we know about Unicode.

00:03:00.180 --> 00:03:05.370
And remember that Apple has been working
with Unicode from the very beginning.

00:03:05.370 --> 00:03:08.050
So, you use NSString.

00:03:08.050 --> 00:03:12.000
We do the Unicode heavy-lifting, so you don't have to.

00:03:12.000 --> 00:03:14.970
Now, when I say NSString, I'm actually
referring to a number of different things.

00:03:14.970 --> 00:03:22.420
First, there is NSString class itself, the NSString
class in Foundation, that is also the toll-free bridged

00:03:22.420 --> 00:03:26.900
to the corresponding CFCoreFoundation type, CFString.

00:03:26.900 --> 00:03:29.910
When I say the toll-free bridge, what I
mean is they're essentially the same thing.

00:03:29.910 --> 00:03:34.260
These are two different interfaces
to the same underlying objects.

00:03:34.260 --> 00:03:38.310
So, a CFString can be passed to
NSString APIs and vice versa.

00:03:38.310 --> 00:03:41.540
You can deal with them both on the same basis.

00:03:41.540 --> 00:03:45.370
And now in addition, these are immutable strings.

00:03:45.370 --> 00:03:46.710
We also have mutable versions.

00:03:46.710 --> 00:03:50.320
So, at the Foundation level, there is NSMutableString.

00:03:50.320 --> 00:03:55.420
And again, that's toll-free bridged to the
CoreFoundation-type equivalent, the CFMutableString.

00:03:55.420 --> 00:03:59.370
So, anything you could do on NSString, I'll
be describing things you can do on NSString,

00:03:59.370 --> 00:04:02.890
but you can also do to all these other objects.

00:04:02.890 --> 00:04:08.300
Now, in addition to strings, we also have
something that we call attributed strings.

00:04:08.300 --> 00:04:13.420
And an attributed string is a string plus something else.

00:04:13.420 --> 00:04:20.600
That "something else" is a set of dictionaries of
attributes applied to various portions of the string.

00:04:20.600 --> 00:04:24.200
In this example, the first word
on the string has attributes.

00:04:24.200 --> 00:04:26.490
The font is Times 48, the color is white.

00:04:26.490 --> 00:04:30.880
The middle portion has a different
font, same color and it is underlined.

00:04:30.880 --> 00:04:33.750
The last word has a different font still, it's yellow.

00:04:33.750 --> 00:04:36.640
Again, for attributed strings, we
have the same sort of hierarchy,

00:04:36.640 --> 00:04:41.600
there's an NSAttributedString toll-free
bridged to the CFAttributedString.

00:04:41.600 --> 00:04:43.590
Those are the immutable versions.

00:04:43.590 --> 00:04:47.940
There's also mutable versions NSMutableString
toll-free bridge CFMutableAttributedString.

00:04:47.940 --> 00:04:56.970
What I want you to remember in particular about attributed
strings is that every attributed string has a string.

00:04:56.970 --> 00:05:00.450
You can get it with the string method.

00:05:00.450 --> 00:05:05.610
It's-- you don't get a copy of it, you get
a direct proxy to the underlying characters.

00:05:05.610 --> 00:05:12.820
And also every MutableAttributedString has a mutable
string, again, direct proxy to the underlying characters.

00:05:12.820 --> 00:05:16.260
So, anything you can do with the string, you can also do

00:05:16.260 --> 00:05:20.310
with an attributed string by working
on its underlying string.

00:05:20.310 --> 00:05:21.790
And anything you can do with the mutable string,

00:05:21.790 --> 00:05:25.500
you can do with the MutableAttributedString
by acting on its mutable string.

00:05:25.500 --> 00:05:31.950
So, I'll be talking about working with NSStrings, but I
actually mean working with any of these types of objects.

00:05:31.950 --> 00:05:35.970
Now, what is in these NSString objects?

00:05:35.970 --> 00:05:42.230
Formally and conceptually, an NSString
is just a UTF-16 sequence.

00:05:42.230 --> 00:05:49.760
But I really want discourage people from thinking
of the strings as sequences of characters.

00:05:49.760 --> 00:05:51.370
That's too low level.

00:05:51.370 --> 00:05:58.330
What I want to encourage instead is that you think
of the strings as being composed of sequences

00:05:58.330 --> 00:06:06.850
of meaningful elements, each of which is represented by a
range in the string, a range of characters in the string.

00:06:06.850 --> 00:06:08.740
So, what sort of meaningful elements do I need?

00:06:08.740 --> 00:06:16.220
Well, in Unicode, in general, a single
character doesn't necessarily stand on its own.

00:06:16.220 --> 00:06:23.270
You might, for example, have a base character
followed by some number of combining accents.

00:06:23.270 --> 00:06:31.260
And these combine together to form what we call technically
a grapheme cluster which is what appears to the user

00:06:31.260 --> 00:06:34.360
as a character, but it is actually several characters.

00:06:34.360 --> 00:06:37.280
It is a range in the underlying string.

00:06:37.280 --> 00:06:43.220
Now, some people think that if they just use enough
normalization, they won't have to deal with this sort

00:06:43.220 --> 00:06:46.990
of thing, but that's not true,
and it can't be true in general.

00:06:46.990 --> 00:06:48.620
The combinatorics just don't work out.

00:06:48.620 --> 00:06:53.260
There are too many possible base
characters, too many possible accents.

00:06:53.260 --> 00:06:57.270
In general, you always have to consider
the possibility that you're dealing

00:06:57.270 --> 00:07:00.500
with several characters in your grapheme cluster.

00:07:00.500 --> 00:07:02.980
Also, there are-- it's not just accents.

00:07:02.980 --> 00:07:06.010
There are languages that have other forms of combination.

00:07:06.010 --> 00:07:12.210
In addition, because we're dealing with UTF-16, if
you have a character that's outside the basic plane,

00:07:12.210 --> 00:07:18.460
then you might have a surrogate pair where it
takes two UTF-16 units to form a single character,

00:07:18.460 --> 00:07:21.600
and that would also be a part of this cluster.

00:07:21.600 --> 00:07:24.700
These things have to be dealt with together.

00:07:24.700 --> 00:07:27.720
You can't separate the two halves of the surrogate pair.

00:07:27.720 --> 00:07:30.630
You don't want to separate the
accents from the base character.

00:07:30.630 --> 00:07:35.250
So, this is the smallest independently
meaningful unit to deal with.

00:07:35.250 --> 00:07:39.640
Now, these clusters then combine
into larger units like words.

00:07:39.640 --> 00:07:48.170
And words are the basic unit for many,
many different kinds of string processing.

00:07:48.170 --> 00:07:53.910
The words, in general, are not necessarily strings
of letters separated by punctuation or white space.

00:07:53.910 --> 00:08:00.650
In a number of different languages, there isn't
going to be any white space to separate words.

00:08:00.650 --> 00:08:05.110
Now, then these words combine into
larger units such as paragraphs.

00:08:05.110 --> 00:08:08.770
And paragraphs are particularly
important because in Unicode,

00:08:08.770 --> 00:08:13.560
the Unicode algorithms generally
don't go beyond paragraph boundaries.

00:08:13.560 --> 00:08:19.220
So, the paragraph is sort of the largest
basic unit for string processing.

00:08:19.220 --> 00:08:22.130
Now, how can I deal with these?

00:08:22.130 --> 00:08:28.490
Well, one of the big new features in iOS 4 is blocks.

00:08:28.490 --> 00:08:33.350
And blocks are pretty much tailor-made for text processing.

00:08:33.350 --> 00:08:41.550
Because what they allow you to do is to go through and
apply a chunk of code to each piece of your text in turn.

00:08:41.550 --> 00:08:44.270
And that's what this particular API here does.

00:08:44.270 --> 00:08:48.710
This is enumerateSubstringsInRange options usingBlock.

00:08:48.710 --> 00:08:53.400
And you fill in the block with whatever
code you want, and it gets called.

00:08:53.400 --> 00:08:59.450
Here I have chosen the option NSStringEnumerationByWords,
it gets to it and, it gets called for each word

00:08:59.450 --> 00:09:01.080
in the range of the string you apply it to.

00:09:01.080 --> 00:09:08.250
And you get passed in the substring, that's the word,
or you can choose not to if you don't want that.

00:09:08.250 --> 00:09:11.460
You get the range of it in the overall string.

00:09:11.460 --> 00:09:16.200
You get an enclosingRange, so for words
that would include the enter word spaces

00:09:16.200 --> 00:09:19.300
as well, if you need to know about those.

00:09:19.300 --> 00:09:21.100
And what can you do with it?

00:09:21.100 --> 00:09:22.220
Just about anything you want.

00:09:22.220 --> 00:09:26.770
You can put any code you need to
do to handle it in this block.

00:09:26.770 --> 00:09:32.460
So, for example, if you wanted to count words, I've
shown that here, you can declare a count variable.

00:09:32.460 --> 00:09:37.270
You have to give it the block attribute
if you want to modify it within the block.

00:09:37.270 --> 00:09:41.420
And you increment it as you go through in this block.

00:09:41.420 --> 00:09:43.570
You also have the option of early exit.

00:09:43.570 --> 00:09:48.000
That's what this Boolean pointer stop variable is for.

00:09:48.000 --> 00:09:53.140
So, the trivial example I showed here is you
count up through the first 100 words, after that,

00:09:53.140 --> 00:09:56.130
you set the stop variable to YES, and you exit.

00:09:56.130 --> 00:10:01.010
And so, for example, if I'm going through this
string by words, your block would be executed first

00:10:01.010 --> 00:10:07.010
for the first word, then for the second word, then for
the third word, then for the fourth word, and so on.

00:10:07.010 --> 00:10:08.770
But it's not just words.

00:10:08.770 --> 00:10:12.790
You can do this for many different basic types of elements.

00:10:12.790 --> 00:10:14.570
You can do it for the grapheme clusters.

00:10:14.570 --> 00:10:21.960
You can go through your string by those, by words, by
sentences if you like, or by lines or by paragraphs.

00:10:21.960 --> 00:10:26.930
Or you could even take several of
these and nest them together, and so,

00:10:26.930 --> 00:10:32.020
go through your string by several different
types, finer and finer granularity,

00:10:32.020 --> 00:10:36.550
and do whatever it is you need to
do to these pieces of the text.

00:10:36.550 --> 00:10:46.250
NSString has many other APIs that are very flexible in
general and provide Unicode savvy processing for things

00:10:46.250 --> 00:10:48.840
like matching and searching and comparisons.

00:10:48.840 --> 00:10:53.310
So, here's one of the big ones,
the rangeOfString family methods.

00:10:53.310 --> 00:10:59.910
These are what you can use for matching
a string within a larger string.

00:10:59.910 --> 00:11:02.870
So, that's the example I've shown here.

00:11:02.870 --> 00:11:04.980
I choose the NSAnchoredSearch option.

00:11:04.980 --> 00:11:08.050
So, it will do matching, it'll
match only at the place I look.

00:11:08.050 --> 00:11:10.210
I chose CaseInsensitiveSearch.

00:11:10.210 --> 00:11:17.090
So, I'm looking for the string "resume", and it'll
find it no matter what the case of the letters is.

00:11:17.090 --> 00:11:25.860
I chose the DiacriticInsensitiveSearch option, which
means maybe it'll also find resume with accents.

00:11:25.860 --> 00:11:30.420
And the WidthInsensitiveSearch option
which is important in Japanese context.

00:11:30.420 --> 00:11:35.160
And if I do the same sort of thing without the
AnchoredSearch option, then I'll go through

00:11:35.160 --> 00:11:42.240
and look for the first match of this anywhere
in the range of the string that I specify.

00:11:42.240 --> 00:11:45.420
Now, this is-- these are very powerful APIs.

00:11:45.420 --> 00:11:49.190
They've been in on NSString for a long time.

00:11:49.190 --> 00:11:55.480
So, for iOS 4, we thought, well,
what can we do to extend these?

00:11:55.480 --> 00:12:00.960
And well, maybe, how about adding
regular expression support.

00:12:00.960 --> 00:12:03.510
So, actually, the first thing we did--

00:12:03.510 --> 00:12:08.040
[ Applause ]

00:12:08.040 --> 00:12:14.610
The first thing we did was actually in 3.2, which
is to add the NSRegularExpressionSearch option

00:12:14.610 --> 00:12:21.680
to this particular range of string APIs that
allow you to treat the string you're trying

00:12:21.680 --> 00:12:24.530
to match as a regular expression pattern.

00:12:24.530 --> 00:12:28.290
We're using the ICU Regular Expression syntax.

00:12:28.290 --> 00:12:33.440
For those of you who may not have heard of it,
ICU is the International Components for Unicode.

00:12:33.440 --> 00:12:37.170
It's a very, very important open source
library for dealing with Unicode.

00:12:37.170 --> 00:12:41.060
Some of you actually might have
already been using ICU directly

00:12:41.060 --> 00:12:45.640
for regular expression operations,
but that's not very convenient.

00:12:45.640 --> 00:12:47.340
This is a lot easier.

00:12:47.340 --> 00:12:55.310
In addition, we've actually gone in and added hooks in ICU
to make it easier for it to deal directly with NSStrings.

00:12:55.310 --> 00:12:59.560
So, this is not only easier than using ICU
directly, it's probably more efficient.

00:12:59.560 --> 00:13:07.390
So, in this particular case, this is a
very simple, sort of trivial example.

00:13:07.390 --> 00:13:14.130
The pattern I've chosen here starts with a
backslash b that matches the word "boundary."

00:13:14.130 --> 00:13:18.750
The actual syntax is backslash b, but because
here it appears in a string literally,

00:13:18.750 --> 00:13:22.780
you have to escape the backslash
so you have to have two of them.

00:13:22.780 --> 00:13:31.370
That's followed by (i|o) that matches an I or an O,
(f|n) that matches an F or N, in other word, boundary.

00:13:31.370 --> 00:13:38.150
So, this particular example matches two other
words that start with I or O and end with F or N.

00:13:38.150 --> 00:13:45.180
And I chose the CaseInsensitiveSearch option,
so it will match these upper or lower case.

00:13:45.180 --> 00:13:52.690
And I'll find-- so, for example in a string like
this, the things that it might find are these.

00:13:52.690 --> 00:13:58.960
For iOS 4, we extended this by adding
in search and replace functionality.

00:13:58.960 --> 00:14:03.210
So, these are pre-existing APIs on, in a string.

00:14:03.210 --> 00:14:06.090
There are two here.

00:14:06.090 --> 00:14:10.170
One takes an immutable string and returns a modified copy.

00:14:10.170 --> 00:14:13.370
The other one takes a mutable string
and mutates it in place.

00:14:13.370 --> 00:14:16.800
And the previous versions of these
just fit out little strings.

00:14:16.800 --> 00:14:24.240
For iOS 4, we added support for NSRegularExpressionSearch
option which means when you add it to these,

00:14:24.240 --> 00:14:30.100
that the string you're looking for is treated
as a regular expression pattern, but also,

00:14:30.100 --> 00:14:33.530
the string that you're replacing
it with is fitted as a template.

00:14:33.530 --> 00:14:38.130
Now, there's one more thing I have to
explain and that is that the things

00:14:38.130 --> 00:14:43.180
in parentheses in the pattern here are capture groups.

00:14:43.180 --> 00:14:48.390
So, the first set of parentheses, the
I or O is the first capture group.

00:14:48.390 --> 00:14:50.610
In this case, it's the first letter of the word.

00:14:50.610 --> 00:14:54.550
And the second set of parentheses is
the section capture group, F or N.

00:14:54.550 --> 00:14:56.840
So, that would be the second letter.

00:14:56.840 --> 00:15:03.600
And then the template syntax is a sort
of standard thing where $0 gets replaced

00:15:03.600 --> 00:15:07.420
by the whole match of the regular expression.

00:15:07.420 --> 00:15:10.730
$ of 1 gets replaced by the contents
of the first capture group.

00:15:10.730 --> 00:15:15.070
$2, the contents of the second capture
group, and so on if you have more of them.

00:15:15.070 --> 00:15:21.470
So here, $2 and $1 takes the second capture group, follows
it with the parenthesis of the first capture group.

00:15:21.470 --> 00:15:25.990
So, those of you who are familiar with this
have already guessed what this is going to do.

00:15:25.990 --> 00:15:32.190
I didn't have room in the previous slide to
specify case insensitive, but assume that I did.

00:15:32.190 --> 00:15:40.180
What it would do to this is just reverse the letters
in each of those two-letter words, very simple example.

00:15:40.180 --> 00:15:45.850
But now, you may be saying, this is all well
and good, but that doesn't cover everything

00:15:45.850 --> 00:15:48.010
that I would want to do with regular expressions.

00:15:48.010 --> 00:15:48.840
That's true.

00:15:48.840 --> 00:15:54.520
We figured that you would want a complete regular
expression support, and so we have given you

00:15:54.520 --> 00:15:59.110
that as well with the NSRegularExpression class.

00:15:59.110 --> 00:16:06.430
Now, an NSRegularExpression object
encapsulates a pattern plus various options.

00:16:06.430 --> 00:16:10.420
So, in this example I've used the
CaseInsensitive option again.

00:16:10.420 --> 00:16:12.400
There is actually a long list of options.

00:16:12.400 --> 00:16:16.970
You can look at the documentation in the headers,
and it covers everything you would expect

00:16:16.970 --> 00:16:20.430
through this sort of thing plus probably a few more.

00:16:20.430 --> 00:16:26.750
And when you create a regular expression
object, you control by creating it

00:16:26.750 --> 00:16:31.250
when the pattern gets compiled into its internal form.

00:16:31.250 --> 00:16:34.950
These NSRegularExpression objects
are immutable and thread safe.

00:16:34.950 --> 00:16:38.510
You can create one at the beginning,
and then just use it wherever you want.

00:16:38.510 --> 00:16:42.650
Now, what can you do with it?

00:16:42.650 --> 00:16:49.410
Well, the most general and the most flexible
API on NSRegularExpression is-- guess what?

00:16:49.410 --> 00:16:51.770
It's a block iteration.

00:16:51.770 --> 00:16:59.250
EnumerateMatchesInString options: range: usingBlock:
goes through that range of the string and calls the block

00:16:59.250 --> 00:17:02.940
on each match of the regular expression in that range.

00:17:02.940 --> 00:17:05.580
So, you can do whatever it is you want to it there.

00:17:05.580 --> 00:17:10.060
Your block gets passed in an objective
class NSTextCheckingResult

00:17:10.060 --> 00:17:13.540
which describes everything you need to know about the match.

00:17:13.540 --> 00:17:19.030
And then you can do whatever it is you want by
putting your code, arbitrary code, in the block.

00:17:19.030 --> 00:17:25.940
So, for example, if you were to apply it to this string,
your block would be called first on the first match

00:17:25.940 --> 00:17:30.660
and the second and so on, and so on, and so on.

00:17:30.660 --> 00:17:34.640
And what are these NSTextCheckingResult objects?

00:17:34.640 --> 00:17:40.800
We use this in a number of different places to express
different things that might have been located in a piece

00:17:40.800 --> 00:17:44.930
of text, and they are of different types.

00:17:44.930 --> 00:17:49.530
Well, when you use them with regular expressions,
they're all the same type, the regular expression type.

00:17:49.530 --> 00:17:52.020
And they have different-- various properties.

00:17:52.020 --> 00:17:57.550
They all have a range property, it
describes the overall range of the match.

00:17:57.550 --> 00:18:01.620
The regular expression results also have the ranges

00:18:01.620 --> 00:18:06.420
of the various capture groups that's
expressed by the rangeAtIndex method.

00:18:06.420 --> 00:18:13.380
So rangeAtIndex is 0 is just the overall range of the match,
rangeAtIndex 1 is the range of the first capture group,

00:18:13.380 --> 00:18:16.910
rangeAtIndex 2 is the second, and then so on and so forth.

00:18:16.910 --> 00:18:23.090
And that is what you need to understand how
your regular expression has been matched.

00:18:23.090 --> 00:18:31.700
So, as you go through, for each match, you can inquire
of this text checking results what is your overall range,

00:18:31.700 --> 00:18:34.850
what is the range of the first capture
group, second capture group, and so on.

00:18:34.850 --> 00:18:36.670
From there, it's easy to do whatever you want.

00:18:36.670 --> 00:18:39.850
You can get-- you know, you can ask for
a substring without range if you need

00:18:39.850 --> 00:18:42.090
to extract substring and so on and so forth.

00:18:42.090 --> 00:18:48.870
Now, I said that the block iteration is the most
general and flexible method on NSRegularExpression.

00:18:48.870 --> 00:18:52.970
But of course, there are going to be cases when
you don't need all that power and flexibility,

00:18:52.970 --> 00:18:55.780
so we have some simpler APIs for simpler cases.

00:18:55.780 --> 00:18:59.790
If you want to get all the matches
as an array, you can do that.

00:18:59.790 --> 00:19:03.560
If you just want to count them and get the
number, there's also a method for that.

00:19:03.560 --> 00:19:08.050
If you want to get the first one, that you
can do that too, or if you just want to need--

00:19:08.050 --> 00:19:11.340
all you need is the range of the
first one, we have that as well.

00:19:11.340 --> 00:19:18.620
And at that point, we're sort of back down to the
level of the initial NSString APIs that I showed you.

00:19:18.620 --> 00:19:23.430
So for example, the equivalent of that using
NSRegularExpression would be something like this:

00:19:23.430 --> 00:19:27.310
rangeOfFirstMatchInString:options:range:,
that will just find you the first--

00:19:27.310 --> 00:19:30.420
the range-- overall range of the first batch.

00:19:30.420 --> 00:19:37.350
And of course, on NSRegularExpression, we also
have, again, the search and replace methods.

00:19:37.350 --> 00:19:39.240
Again, there are two of them.

00:19:39.240 --> 00:19:44.660
One that takes an immutable string and returns a
modified copy, another, that takes a mutable string

00:19:44.660 --> 00:19:49.210
and modifies its place just the same way
as the previous APIs that I mentioned.

00:19:49.210 --> 00:19:53.700
OK. So, that's regular expressions.

00:19:53.700 --> 00:19:55.330
What else do we have?

00:19:55.330 --> 00:19:56.660
How about data detectors?

00:19:56.660 --> 00:20:05.740
You might be familiar with data detectors as the things
that in your e-mail maybe find interesting things like dates

00:20:05.740 --> 00:20:12.070
and addresses and phone numbers, and
give you options to do things with them.

00:20:12.070 --> 00:20:20.100
But up until now, we haven't had API access to
the underlying data detectors functionality.

00:20:20.100 --> 00:20:21.420
Well, that's changed.

00:20:21.420 --> 00:20:24.870
With iOS 4, we now have an NSDataDetector class.

00:20:24.870 --> 00:20:32.290
And NSDataDetector is just a subclass
of NSRegularExpression.

00:20:32.290 --> 00:20:37.020
You don't create it with a regular expression
pattern, instead, you just create it with a set

00:20:37.020 --> 00:20:41.090
of the data detector types that you want to have it detect.

00:20:41.090 --> 00:20:46.650
So, in this example here, I chose the
type, the link type which detects URLs,

00:20:46.650 --> 00:20:49.070
and the phone number type which detects phone numbers.

00:20:49.070 --> 00:20:54.240
So, this data detector object will
detect URLs and phone numbers.

00:20:54.240 --> 00:21:00.530
So, for example, in this string, it would
detect one phone number and one URL.

00:21:00.530 --> 00:21:05.280
Now, you might be tempted to use a
regular expression for this sort of thing,

00:21:05.280 --> 00:21:10.580
but the data detectors knows a
wide variety of different formats.

00:21:10.580 --> 00:21:15.730
For example, a wide variety of international
phone number formats and it's highly optimized.

00:21:15.730 --> 00:21:22.270
So, you would not be able to match its performance's
sophistication with a regular expression.

00:21:22.270 --> 00:21:24.130
It's very good at what it does.

00:21:24.130 --> 00:21:30.380
The types of things that it can detect:
Dates, addresses, URLs, phone numbers.

00:21:30.380 --> 00:21:35.080
The transient information type generally detects
the flight numbers, airline flight numbers.

00:21:35.080 --> 00:21:44.390
And since it is just a subclass of
NSRegularExpression, it uses all of the same APIs.

00:21:44.390 --> 00:21:52.610
So, the same block iteration will, in this case,
go through and call your block for each match

00:21:52.610 --> 00:21:55.260
that the data detector finds in the string.

00:21:55.260 --> 00:21:59.360
For example, in this case, first your
block will be called on the first thing,

00:21:59.360 --> 00:22:02.390
then on the second thing that it detects.

00:22:02.390 --> 00:22:08.870
And what it passed in, again, it's an
NSTextCheckingResult that describes the match.

00:22:08.870 --> 00:22:14.890
But it's not the regular expression type of
TextCheckingResult, instead there's a special type

00:22:14.890 --> 00:22:18.540
of TextCheckingResult for each of
these different data detectors type,

00:22:18.540 --> 00:22:21.900
each of the different things that data detectors can detect.

00:22:21.900 --> 00:22:28.960
There's the date type, the address type, the phone
number type, link type for URLs, and so on and so forth.

00:22:28.960 --> 00:22:32.150
And each of these has properties appropriate to it.

00:22:32.150 --> 00:22:35.620
So, for example, the date type has a date property.

00:22:35.620 --> 00:22:40.790
The address type has a components property, that's
a dictionary of the various pieces of the address.

00:22:40.790 --> 00:22:43.110
The link type has a URL property.

00:22:43.110 --> 00:22:46.430
The phone number type has a phone number property.

00:22:46.430 --> 00:22:51.940
So, as I go through in my block, for each
result, I can ask it what type are you.

00:22:51.940 --> 00:22:58.110
In this case, if the type is the link type, then it
should have a URL, I can do whatever I want with that.

00:22:58.110 --> 00:23:00.050
If it's a phone number type, it should have a phone number.

00:23:00.050 --> 00:23:01.860
I can do whatever with that.

00:23:01.860 --> 00:23:05.730
In addition to other properties like the overall range.

00:23:05.730 --> 00:23:11.400
And again, since this is just a subclass of
NSRegularExpression, it has all the same convenience APIs

00:23:11.400 --> 00:23:17.230
for getting all the matches or the number of the
first match, the range of the first match just exactly

00:23:17.230 --> 00:23:20.160
in the same way that I showed before
for NSRegularExpression.

00:23:20.160 --> 00:23:28.490
Now, I'm going to demo that, but before I do this, there's
one more thing I want to mention and that is spellchecking,

00:23:28.490 --> 00:23:35.570
which you may have noticed as being
available by default on standard text entry.

00:23:35.570 --> 00:23:41.150
But we have also made it available
programmatically starting in 3.2.

00:23:41.150 --> 00:23:46.830
Now this actually is at the UIKit
level with the UITextChecker class.

00:23:46.830 --> 00:23:53.210
And what you'd do with one of these is go through
a piece of text and find words that are likely

00:23:53.210 --> 00:23:56.490
to be misspelled in a particular language.

00:23:56.490 --> 00:24:05.430
Once you've found one of those, you can ask for a set of
potential replacements that might be what the user intended.

00:24:05.430 --> 00:24:13.090
You can learn words, you can ignore words, forget
words, all the basic functionality for text checking.

00:24:13.090 --> 00:24:17.900
Now, I want to go over to the demo
and briefly show some of this.

00:24:17.900 --> 00:24:25.680
So, this is a very simple test application, and I've
entered in that regular expression that I showed before.

00:24:25.680 --> 00:24:35.780
And what I'm going to have this code do is highlight
everything that it finds in this piece of text.

00:24:35.780 --> 00:24:38.240
Oh, there it is.

00:24:38.240 --> 00:24:45.200
All the 2-letter words that start with I or
O and end with N or F, it's case insensitive.

00:24:45.200 --> 00:24:51.660
This will also do the same sort
of thing with NSDataDetector.

00:24:51.660 --> 00:25:04.820
So, in case I want to detect phone numbers and highlight
those phone numbers or dates or URLs if I like.

00:25:04.820 --> 00:25:09.570
And that's very simple, but what I want
to show you is how simple this really is.

00:25:09.570 --> 00:25:15.240
So, here is the business piece of this test code.

00:25:15.240 --> 00:25:23.930
This is the invocation of the enumerate matches and
string block iterator for the regular expression.

00:25:23.930 --> 00:25:28.640
And it's basically just two lines of code.

00:25:28.640 --> 00:25:31.360
So, it enumerates the matches in the string.

00:25:31.360 --> 00:25:38.500
Now, remember what I said earlier about attributed strings,
this test app happens to deal with attributed strings,

00:25:38.500 --> 00:25:44.300
but I can apply the same APIs to the attributed
strings just by asking for its string.

00:25:44.300 --> 00:25:47.360
Then I enumerate through it using this block.

00:25:47.360 --> 00:25:58.070
And the content of the block is just one line that calls
my custom view here to have that range highlighted.

00:25:58.070 --> 00:26:05.630
There's another piece of code that does the same
thing for the data detector's piece of this.

00:26:05.630 --> 00:26:10.590
And you'll notice it's essentially just the same code

00:26:10.590 --> 00:26:15.810
because again NSDataDetectors is
a subclass of NSRegularExpression.

00:26:15.810 --> 00:26:21.710
Again, just about two lines of code to go
through and do something for each instance

00:26:21.710 --> 00:26:25.160
that the data detectors finds in the string.

00:26:25.160 --> 00:26:26.720
OK, let me go back to the slides.

00:26:26.720 --> 00:26:33.610
And so, that is we have to say about
text processing, analyzing strings.

00:26:33.610 --> 00:26:39.510
Let me bring Julio Gonzalez up
to talk about fonts and display.

00:26:39.510 --> 00:26:46.610
[ Applause ]

00:26:46.610 --> 00:26:47.090
>> Julio Gonzalez: Thanks, Doug.

00:26:47.090 --> 00:26:50.640
I'm Julio Gonzalez, Manager of the Type Team.

00:26:50.640 --> 00:26:54.930
And I'm going to talk to you about drawing with Core Text.

00:26:54.930 --> 00:27:01.060
First, I'll start with what the text architecture is
especially with the drawing side, give you a bird's eye view

00:27:01.060 --> 00:27:04.650
of Core Text, what it does, capabilities, principles.

00:27:04.650 --> 00:27:12.200
How it differs from the version that's present in the Mac OS
X, and hopefully, give you a nice demo of some of the things

00:27:12.200 --> 00:27:14.570
that I'll discuss during this presentation.

00:27:14.570 --> 00:27:19.880
So again, this is the same slide that Doug
showed you earlier with all the text components.

00:27:19.880 --> 00:27:23.360
I want to focus on the layers that have to do with drawing.

00:27:23.360 --> 00:27:28.190
We have Quartz, Core Text, and UIKit.

00:27:28.190 --> 00:27:29.870
The lowest level is Quartz.

00:27:29.870 --> 00:27:31.250
It's a rendering engine.

00:27:31.250 --> 00:27:35.000
It's the same rendering engine
on iPhone and iOS and Mac OS X.

00:27:35.000 --> 00:27:42.050
If you want to get access to any text supports, you
first need a font reference, that's the CGFontRef.

00:27:42.050 --> 00:27:46.520
It's the most fundamental object to get an access to fonts.

00:27:46.520 --> 00:27:52.170
And one thing I want you to note is that Quartz,
even though you can use it to render text,

00:27:52.170 --> 00:27:55.350
it's truly isn't a text rendering engine.

00:27:55.350 --> 00:27:57.580
It is a graphics engine.

00:27:57.580 --> 00:27:59.550
It's a glyph rendering engine.

00:27:59.550 --> 00:28:01.500
That's an important distinction.

00:28:01.500 --> 00:28:05.820
Now, you may have gone into Quartz,
and looked at the CG APIs and notice

00:28:05.820 --> 00:28:10.330
that there are some APIs
that claim to process text.

00:28:10.330 --> 00:28:10.990
Well, they don't.

00:28:10.990 --> 00:28:14.850
They know how to handle ASCII text,
that's about all they know how to do.

00:28:14.850 --> 00:28:16.880
They don't know how to handle any Unicode.

00:28:16.880 --> 00:28:19.560
You won't be able to use any NSStrings with this.

00:28:19.560 --> 00:28:27.450
Also, you don't have any access to font substitution which
is something that you would expect a normal text engine to do.

00:28:27.450 --> 00:28:29.710
So, now you ask, why would I use this?

00:28:29.710 --> 00:28:31.210
Well, there are reasons.

00:28:31.210 --> 00:28:35.900
If you know exactly what glyphs you're
going to put on the screen and exactly

00:28:35.900 --> 00:28:38.830
where you're going to put them, then you use Quartz.

00:28:38.830 --> 00:28:44.180
Well, that means that you have your own layout
engine, otherwise, you have no business being here.

00:28:44.180 --> 00:28:48.680
Now, at the opposite end is UIKit.

00:28:48.680 --> 00:28:52.460
That's where 99.5 percent of developers are going to be.

00:28:52.460 --> 00:28:54.960
You have a bunch of text, it deals with it beautifully.

00:28:54.960 --> 00:28:59.680
You want to get to some text, you have
the UIFont, you have to specify the font,

00:28:59.680 --> 00:29:04.400
and that boils down essentially
into CGFontRef at some point.

00:29:04.400 --> 00:29:06.040
Now, it is a place to be.

00:29:06.040 --> 00:29:08.890
There are great classes available to you.

00:29:08.890 --> 00:29:09.940
They are easy to use.

00:29:09.940 --> 00:29:15.210
UILabels, TextViews, easily accessible from IB.

00:29:15.210 --> 00:29:21.420
You also have the advantage that with this
you have a lot of things built in for free.

00:29:21.420 --> 00:29:25.550
You have text editing in the case of
text views, you have copy and paste,

00:29:25.550 --> 00:29:28.430
you have voice-over support, you have spellchecking.

00:29:28.430 --> 00:29:31.280
All of these are available to you at this level.

00:29:31.280 --> 00:29:34.380
Now, you do lack some things at this level.

00:29:34.380 --> 00:29:38.320
For example, you can't have multistyle
text unless you go to a web view.

00:29:38.320 --> 00:29:44.100
But it might be that the source that you're
dealing with is not HTML, or the things

00:29:44.100 --> 00:29:48.120
that you want to do to render, HTML can't handle.

00:29:48.120 --> 00:29:52.190
That's when you need to go a little bit
lower down and that's when you use Core Text.

00:29:52.190 --> 00:29:58.740
So, Core Text is the low-level Unicode
layout engine in Mac OS X and iOS, OK.

00:29:58.740 --> 00:30:00.300
It's been around for a while.

00:30:00.300 --> 00:30:04.270
It's been there since Mac OS 10.5.

00:30:04.270 --> 00:30:10.680
And from the very beginning, it was built for speed in mind
and for threading, which is very important to some of you.

00:30:10.680 --> 00:30:16.440
And it also, it's internally, it's divided into 2
subcomponents, the font and the layout components,

00:30:16.440 --> 00:30:20.780
and it provides a very, very rich set
of API set that wasn't available to you.

00:30:20.780 --> 00:30:28.050
You can get access to a lot of font features, and
you get access to a lot of APIs that allow you

00:30:28.050 --> 00:30:32.410
to control what you get on the screen very precisely.

00:30:32.410 --> 00:30:35.950
So, there are some differences between both versions

00:30:35.950 --> 00:30:42.570
of Core Text primarily that's less
capable on the iOS at least for now.

00:30:42.570 --> 00:30:44.720
The first one is we have no font management.

00:30:44.720 --> 00:30:50.890
And what I mean by that is you don't have the ability
to register and unregister fonts programatically

00:30:50.890 --> 00:30:55.150
or to enable or disable font faces in a font family.

00:30:55.150 --> 00:30:58.210
Also, we don't have OpenType shaping support.

00:30:58.210 --> 00:30:59.770
We do support OpenType.

00:30:59.770 --> 00:31:03.040
In fact Hiragino, our Japanese font is an OpenType font.

00:31:03.040 --> 00:31:09.330
However, we just don't support the font
features or the layout capabilities of OpenType.

00:31:09.330 --> 00:31:13.360
Also, we do not support vertical glyphs in the iOS.

00:31:13.360 --> 00:31:19.430
So, unfortunately, you won't be able to create
vertical text views very easily using Core Text in iOS.

00:31:19.430 --> 00:31:25.290
And finally, the font substitution mechanism
is not as rich as it is in Mac OS X,

00:31:25.290 --> 00:31:29.260
but it is better than what you have
currently available in UIKit or with WebViews,

00:31:29.260 --> 00:31:31.730
and I'll talk about that a little bit later.

00:31:31.730 --> 00:31:33.940
So, let's start with the basics, the font system.

00:31:33.940 --> 00:31:41.330
So, our primary object for referencing fonts is the
CTFontRef, and you create that by specifying a postscript name.

00:31:41.330 --> 00:31:47.980
That differs from a UIFont which you typically
use a font family name to create a font reference.

00:31:47.980 --> 00:31:59.120
Also a CTFontRef is not toll-free bridged to a UIFont
unlike on OS X where it's toll-free bridged to an NSFont.

00:31:59.120 --> 00:32:02.040
Now, this API allows you different ways to get out fonts.

00:32:02.040 --> 00:32:07.420
One of them is using FontDescriptors, and
think of them as a search mechanism for fonts.

00:32:07.420 --> 00:32:11.590
You're not very specific about the font you
want, you can be a little bit more ambiguous.

00:32:11.590 --> 00:32:16.920
You can create a FontDescriptor that says I
want a font that is bold, that is mono spaced,

00:32:16.920 --> 00:32:22.650
that supports German, for example, just to say something.

00:32:22.650 --> 00:32:26.590
And you can call-- you can then
derive a font from this descriptor

00:32:26.590 --> 00:32:30.840
and Core Text will find the best
matching font for this descriptor.

00:32:30.840 --> 00:32:35.920
Also, this is the recommend that we suggest
for you to store any font references

00:32:35.920 --> 00:32:39.050
in document, it's both in iOS and Mac OS X.

00:32:39.050 --> 00:32:45.120
And the reason is because if you have a
FontDescriptor, you typically will want

00:32:45.120 --> 00:32:47.640
to create a very rich description about what the font is.

00:32:47.640 --> 00:32:52.740
And if you go to another platform and the font that you
wanted to use is not there, you have extra information there

00:32:52.740 --> 00:32:57.650
to make an educated guess as to
what font could be substituted.

00:32:57.650 --> 00:33:03.280
Another object that is available to you
in the Core Text space is FontCollections.

00:33:03.280 --> 00:33:04.960
These are list of font descriptors.

00:33:04.960 --> 00:33:11.150
And we use this in Mac OS X to create the
font panel or to implement the font panel.

00:33:11.150 --> 00:33:13.430
We don't have such a capability in iOS.

00:33:13.430 --> 00:33:18.330
And if you created an app that
wanted to provide a font picker,

00:33:18.330 --> 00:33:21.970
you might consider using FontCollections to implement that.

00:33:21.970 --> 00:33:26.470
So, what are the benefits of this API
from what you knew or had already?

00:33:26.470 --> 00:33:34.090
Well, I don't know if you've noticed, but we've
shipped a good set of new fonts with the iPad.

00:33:34.090 --> 00:33:38.640
And with these fonts, there is--
with these families of fonts,

00:33:38.640 --> 00:33:41.700
there are some of these families have a lot of font faces.

00:33:41.700 --> 00:33:46.800
And you may have noticed that you only have
access to four of these font faces through UIKit.

00:33:46.800 --> 00:33:52.400
You only have access to the regular, the
bold, the bold italic, and the italic.

00:33:52.400 --> 00:33:55.300
With Core Text, you'll have access to all those font faces,

00:33:55.300 --> 00:33:59.000
and there are some that are extended,
regular-- I'm sorry, light.

00:33:59.000 --> 00:34:00.850
So, all of these will be accessible.

00:34:00.850 --> 00:34:03.020
The other thing is font substitution.

00:34:03.020 --> 00:34:05.830
Like I said earlier, it's not as rich as it is in Mac OS X,

00:34:05.830 --> 00:34:10.090
but it is richer than what you
have with WebViews or with UIKit.

00:34:10.090 --> 00:34:15.370
Instead of just matching based on whether your font
can handle a character that the other font didn't,

00:34:15.370 --> 00:34:19.070
it will match based on styles from
the font or traits from the font.

00:34:19.070 --> 00:34:22.510
So, if you were starting with serif font,
it will match to another serif font.

00:34:22.510 --> 00:34:27.060
If you had an italic face, it will
try to get you an italic face.

00:34:27.060 --> 00:34:29.300
But that's not all.

00:34:29.300 --> 00:34:35.660
Also, you have the ability to tell Core Text
what kind of fallback you want to take place.

00:34:35.660 --> 00:34:36.800
You have control over that.

00:34:36.800 --> 00:34:43.690
And to use that, you create what we call a cascade list,
and you specify that cascade list in the font descriptor,

00:34:43.690 --> 00:34:48.570
and now you have full control over
what the font fallback is going to be.

00:34:48.570 --> 00:34:54.680
Another thing that the Core Text API provides is
full access to typographic features in the font.

00:34:54.680 --> 00:34:58.320
These are features that some high-end fonts
have, and we ship some of them with the iPad.

00:34:58.320 --> 00:35:02.180
And they are typically options that are hidden in the font

00:35:02.180 --> 00:35:06.890
that in Mac OS X you could make
available by using the typography panel.

00:35:06.890 --> 00:35:14.340
Some of these features are things like small caps, so
you can draw all your lower case letters with small capitals.

00:35:14.340 --> 00:35:19.820
You can use non-proportional numbers and some
proportional numbers, different serifs and so forth.

00:35:19.820 --> 00:35:22.970
All of these will be accessible
to use with the Core Text API.

00:35:22.970 --> 00:35:30.410
And finally, it is the Core Text API, in regards
to the font, is a very rich API.

00:35:30.410 --> 00:35:34.030
It gives you full access to all
the font metrics information.

00:35:34.030 --> 00:35:36.930
It gives you access to character, to glyph mapping.

00:35:36.930 --> 00:35:45.770
In short, it's-- you should be able to create a very
rich typographic experience by using these APIs.

00:35:45.770 --> 00:35:50.180
Now, let's move on to the other side of Core
Text which is the drawing side, the layout side.

00:35:50.180 --> 00:35:55.120
The first thing to note is that Core Text
operates on a flipped coordinate system.

00:35:55.120 --> 00:36:02.170
Typically, your views, the origin is at the
bottom left, and it grows up and to the right.

00:36:02.170 --> 00:36:03.510
Core Text does the opposite.

00:36:03.510 --> 00:36:07.780
The origin is at the top left and
it grows down and to the right.

00:36:07.780 --> 00:36:12.270
Typically, that's the way text would
flow, that's the reason we do it.

00:36:12.270 --> 00:36:15.950
Now, the input for all drawing into
Core Text is the attributed string.

00:36:15.950 --> 00:36:19.610
It's the same string that Doug spoke about earlier.

00:36:19.610 --> 00:36:26.230
And there are four objects in the layout
API that you need to be familiar with.

00:36:26.230 --> 00:36:30.430
The framesetter, typesetter, the
line, and the run, the glyph run.

00:36:30.430 --> 00:36:32.650
The framesetter is the highest level object.

00:36:32.650 --> 00:36:37.200
The object of the framesetter is to
create frames which are shapes of text.

00:36:37.200 --> 00:36:43.560
And it fills those shapes with lines of text and
applies any paragraph styles that you may have provided.

00:36:43.560 --> 00:36:46.540
It internally created types-- it creates a typesetter.

00:36:46.540 --> 00:36:51.360
The typesetter is what does all the
heavy-lifting in the layout engine.

00:36:51.360 --> 00:36:52.820
It's what measures text.

00:36:52.820 --> 00:37:00.330
It figures out words with just line breaks, figures
out alignment, figures out where line direction goes.

00:37:00.330 --> 00:37:01.810
It's all done by this object.

00:37:01.810 --> 00:37:06.470
Now, these two objects, like I said, are
the heavy-lifters of the layout operation,

00:37:06.470 --> 00:37:13.040
and you want to hang on to these objects for dear life
because that's where all your performance comes from.

00:37:13.040 --> 00:37:14.920
Now, next object is the line.

00:37:14.920 --> 00:37:19.870
You can create one of these lines directly, and
it's very simple by passing an attributed string.

00:37:19.870 --> 00:37:23.060
And lines are just a collection of glyph runs.

00:37:23.060 --> 00:37:28.570
And what a glyph run is is a series of
glyphs that all share the same attributes.

00:37:28.570 --> 00:37:30.760
So, let me show you the typical flow.

00:37:30.760 --> 00:37:34.330
First, you start with your attributed string.

00:37:34.330 --> 00:37:36.540
From there, you could create your framesetter.

00:37:36.540 --> 00:37:40.200
The framesetter only takes a single
input which is the attributed string.

00:37:40.200 --> 00:37:42.530
It internally creates a typesetter.

00:37:42.530 --> 00:37:45.980
Now, the only thing you need at this
point is where you going to draw it.

00:37:45.980 --> 00:37:48.420
So, you require a shape, that's a CGPath.

00:37:48.420 --> 00:37:53.500
And note, the only shape Core Text supports
at the moment it is a rectangle, OK.

00:37:53.500 --> 00:37:57.720
So, now, you have your path, you have
your framesetter, you can create a frame.

00:37:57.720 --> 00:38:02.390
And once you have the frame that takes the typesetter
goes to town and starts generating all those lines

00:38:02.390 --> 00:38:05.730
and the framesetter applies any
paragraph styles that you need.

00:38:05.730 --> 00:38:11.850
Now, at this point in time, you have
full access to the frame, the lines,

00:38:11.850 --> 00:38:15.090
the glyph runs to make any adjustments that you want.

00:38:15.090 --> 00:38:17.580
Or you can just draw it at this stage.

00:38:17.580 --> 00:38:22.940
Now, let's assume that you had a document that
had multipage document and have multiple columns,

00:38:22.940 --> 00:38:25.740
and not all your text fit into that single frame.

00:38:25.740 --> 00:38:31.340
Well, the only thing you need to do now is specify
another frame, another shape, another rectangle.

00:38:31.340 --> 00:38:37.950
And once you have that, you use that same framesetter that
you created before which is, you know, at a heavy cost,

00:38:37.950 --> 00:38:40.860
and now you just draw into this
frame, and it does the same operation.

00:38:40.860 --> 00:38:43.490
And you keep repeating this process over and over.

00:38:43.490 --> 00:38:46.500
I'll show you some of this in the demo later on.

00:38:46.500 --> 00:38:50.710
So, what does this look like in
code or how you go about it in code?

00:38:50.710 --> 00:38:52.650
First thing you need is a font.

00:38:52.650 --> 00:38:57.060
And here are three examples of how you
create a font reference in Core Text.

00:38:57.060 --> 00:39:00.580
The top API allows you to create a system UIFont.

00:39:00.580 --> 00:39:06.400
The middle API is what you typically use to use an
arbitrary font, and you specify the postscript name.

00:39:06.400 --> 00:39:12.930
The last API creates a font from an existing font,
and it does so by morphing the style traits in it.

00:39:12.930 --> 00:39:16.550
In this case, we wanted to go from
a bold face to an italic face.

00:39:16.550 --> 00:39:20.570
Once we have our font, we create an attributed string.

00:39:20.570 --> 00:39:25.520
Now, note, it seems like a lot of code to create a
single string, this is not typically what you do.

00:39:25.520 --> 00:39:30.840
You typically have a higher level object, the same thing
I do on my demo that creates this attributed string,

00:39:30.840 --> 00:39:34.600
but I'll show you how you create one from scratch.

00:39:34.600 --> 00:39:36.970
First, you start with your base NSString.

00:39:36.970 --> 00:39:39.590
I'm grabbing one from my localized file.

00:39:39.590 --> 00:39:43.090
Then optionally, you want to apply
some attributes to this string.

00:39:43.090 --> 00:39:49.190
In this case, I want to-- I want it to be blue and
have a dotted underline, so I create a colored object

00:39:49.190 --> 00:39:53.930
for blue and an object for the underline.

00:39:53.930 --> 00:39:56.430
Now, I specify the dictionary of attributes.

00:39:56.430 --> 00:40:03.340
And in this dictionary, I'm going to specify my font that
I created in my previous slide, the color and the line.

00:40:03.340 --> 00:40:08.060
So now I have my base string, I
have my dictionary of attributes.

00:40:08.060 --> 00:40:10.920
I create my attributed string, OK.

00:40:10.920 --> 00:40:13.650
So, now we're ready to draw.

00:40:13.650 --> 00:40:20.090
Like I said, Core Text operates on a flipped coordinate
system, so the first thing that you do when you are

00:40:20.090 --> 00:40:26.160
on your view, ready to draw, or in a layer is to
make sure that your context is set up appropriately.

00:40:26.160 --> 00:40:31.490
Now, one thing I didn't mention that is good
practice to do is set up your text matrix.

00:40:31.490 --> 00:40:35.020
This text matrix might have been modified
by somebody else before you got to it.

00:40:35.020 --> 00:40:39.630
This is especially important in OS X where
we're dealing typically dealing with Cocoa,

00:40:39.630 --> 00:40:42.180
and the Cocoa text system modifies the text matrix.

00:40:42.180 --> 00:40:46.410
In iOS, it's not necessary, but it's a good practice to do.

00:40:46.410 --> 00:40:51.170
Then the next two lines translate the CPM,
which is what flips the coordinate system.

00:40:51.170 --> 00:40:53.480
So, now, we're ready to draw with Core Text.

00:40:53.480 --> 00:40:58.380
So, to draw a simple line, the only thing
you need to do is to create a line object,

00:40:58.380 --> 00:41:03.760
and you create the line object with
CTLineCreateWithAttributedString.

00:41:03.760 --> 00:41:06.250
And at this point, you're ready to draw it.

00:41:06.250 --> 00:41:10.030
You can-- there's other APIs that let you
manipulate the line where you draw it.

00:41:10.030 --> 00:41:14.920
But otherwise, you just set your position where
you want to draw it and go ahead and draw it.

00:41:14.920 --> 00:41:19.820
Now, what if we wanted to draw
paragraphs, a longer set of text.

00:41:19.820 --> 00:41:21.780
Well, it's not that much more difficult.

00:41:21.780 --> 00:41:24.570
We start the same way, we set up our context.

00:41:24.570 --> 00:41:27.500
And the first thing we do is we create our framesetter.

00:41:27.500 --> 00:41:33.000
Once we have our framesetter, now we just need to define
the shape that we're going to draw in, a rectangle.

00:41:33.000 --> 00:41:35.970
We define it from the bounds of the view, whatever.

00:41:35.970 --> 00:41:37.070
Now, we have a frame.

00:41:37.070 --> 00:41:41.170
And once we have the frame, we can
either manipulate it or draw it.

00:41:41.170 --> 00:41:44.410
So, you'll see some of that in the demo later.

00:41:44.410 --> 00:41:50.090
So, now, there are some more objects that
are available to you to customize the text.

00:41:50.090 --> 00:41:52.440
The first one is the ParagraphStyle object.

00:41:52.440 --> 00:41:56.040
And this is an object where you can
specify attributes a lot of style.

00:41:56.040 --> 00:42:02.290
You can specify things such as indentation,
line height, justification, alignment.

00:42:02.290 --> 00:42:08.250
You can specify TabStops which is the next object, which
is a conceptual object where you can specify things

00:42:08.250 --> 00:42:10.730
such as in a ruler or you specify the tab stops.

00:42:10.730 --> 00:42:13.940
You can specify the tab stops into your ParagraphStyle.

00:42:13.940 --> 00:42:17.510
And the ParagraphStyle is something
you include in your NSAttributedString.

00:42:17.510 --> 00:42:21.350
And later on, the framesetter will
apply to the frames as it's drawing it.

00:42:21.350 --> 00:42:25.130
Now, there are some other lower
level objects that are powerful.

00:42:25.130 --> 00:42:28.080
The GlyphInfo object is a pretty nice object.

00:42:28.080 --> 00:42:33.190
It allows you to override the character to
glyph mapping characteristics of a font.

00:42:33.190 --> 00:42:37.560
So for example, you can say, Core Text,
if you ever see the word "copyright",

00:42:37.560 --> 00:42:41.690
we replace copyright with the copyright
glyph inside of the font.

00:42:41.690 --> 00:42:43.660
Also, you have RunDelegate.

00:42:43.660 --> 00:42:47.520
The RunDelegate is only available in iPhone OS.

00:42:47.520 --> 00:42:54.600
And what this allows you to do is to
override the metrics for a single glyph.

00:42:54.600 --> 00:42:59.370
And the way you use it at a low
level is you can make the metrics

00:42:59.370 --> 00:43:03.530
for this glyph large thus creating a space in your run.

00:43:03.530 --> 00:43:08.390
In this way, you can attach a picture or a movie
or whatever in the middle of your document.

00:43:08.390 --> 00:43:14.420
This is something similar to what the
Cocoa text system does in Mac OS X.

00:43:14.420 --> 00:43:17.650
So, what are the benefits of this
layout API, this drawing API?

00:43:17.650 --> 00:43:24.640
Well for one, as you've seen, by using attributed
string, we have full access to multistyle text.

00:43:24.640 --> 00:43:27.950
We also have access to all the font features in the font.

00:43:27.950 --> 00:43:32.700
And more importantly, is we have a good set
of APIs that allows to control frames, lines,

00:43:32.700 --> 00:43:38.320
and so forth to render that fine level of
control that you might need in your application.

00:43:38.320 --> 00:43:39.780
And finally, it's thread safe.

00:43:39.780 --> 00:43:45.530
So, if you have a very large document that you need to
display to your users, the last thing you want to do is

00:43:45.530 --> 00:43:49.600
to layout the entire document and while
the user waits for the document to layout.

00:43:49.600 --> 00:43:53.170
So, you can be sure that you can
use Core Text safely in threads.

00:43:53.170 --> 00:43:57.740
So with that, let me move to a demo.

00:43:57.740 --> 00:44:05.500
So, what I have here is a very simple page
layout application, here is my project.

00:44:05.500 --> 00:44:09.550
And the first thing I want you
to note is my-- this XML file.

00:44:09.550 --> 00:44:12.150
Basically, I have a set of XML files here.

00:44:12.150 --> 00:44:16.290
Let's see if I-- I don't know if you can see that.

00:44:16.290 --> 00:44:22.940
And this is what I use as input to my application.

00:44:22.940 --> 00:44:32.410
And on the side, I have what the XML file looks like and
it just describes every single thing in the document.

00:44:32.410 --> 00:44:36.790
And from here, I can create an
NSAttributedString very simply.

00:44:36.790 --> 00:44:43.120
It also has features such as what the pages look
like or how many columns I want and so forth.

00:44:43.120 --> 00:44:53.140
Now, one thing I want you to note, something that's new
in 3.2 is the ability to add fonts to your applications.

00:44:53.140 --> 00:45:00.120
You can copy any set of fonts to your resources and they
get copied into your bundle once the application is built.

00:45:00.120 --> 00:45:03.670
However, they're not automatically available to you.

00:45:03.670 --> 00:45:08.200
What you need to do is you need to modify the plist file.

00:45:08.200 --> 00:45:09.290
Yeah, and let me blow that up.

00:45:09.290 --> 00:45:15.590
So you can create this key, the fonts provided by the
application, and then you list all the fonts that you want

00:45:15.590 --> 00:45:18.460
to be able to make accessible to your app.

00:45:18.460 --> 00:45:21.400
Note, I included here about four font faces.

00:45:21.400 --> 00:45:22.840
That's about right.

00:45:22.840 --> 00:45:26.390
If you wanted to add more font faces,
you just need to be a little bit careful.

00:45:26.390 --> 00:45:31.190
If you add 20, 30 font faces, now you're
eating into your launch time for your app.

00:45:31.190 --> 00:45:39.770
Because at launch time the font subsystem will need to
parse through all these fonts to figure out what's available

00:45:39.770 --> 00:45:42.870
and make it available to the rest of the system.

00:45:42.870 --> 00:45:46.700
So, now let me run this app.

00:45:51.410 --> 00:45:53.560
Hide all these.

00:45:53.560 --> 00:45:56.120
OK, so again, a very simple page layout.

00:45:56.120 --> 00:46:01.880
In this case for this particular sample,
I decided to create some static frames.

00:46:01.880 --> 00:46:05.940
Here are some text, a picture frame, free flow text.

00:46:05.940 --> 00:46:11.240
And for those of you who have a keen eye on fonts, you
will notice that it's using Futura Medium Condensed.

00:46:11.240 --> 00:46:14.160
It's something that is not available to you through UIKit.

00:46:14.160 --> 00:46:16.870
Let me switch to a different sample.

00:46:16.870 --> 00:46:20.890
Set in to portrait mode, landscape mode.

00:46:20.890 --> 00:46:27.940
And here, this sample shows that flow diagram
that I showed you earlier in the slides.

00:46:27.940 --> 00:46:33.780
I have two columns up and pages flow from one to the other.

00:46:33.780 --> 00:46:37.350
And it is very easy to construct using those APIs.

00:46:37.350 --> 00:46:40.860
I'll show you the code a little bit later.

00:46:40.860 --> 00:46:45.750
Now, something else that you get
access to is font and font features.

00:46:45.750 --> 00:46:52.920
So let me set this text to Dido, and Dido has
access to some of these typographic features.

00:46:52.920 --> 00:46:57.890
So, look what it looks like right now, and
I'm going to switch now to use small caps,

00:46:57.890 --> 00:47:00.590
and now you have access to small caps in Dido.

00:47:00.590 --> 00:47:02.740
I'll use some more dramatic example here.

00:47:02.740 --> 00:47:07.190
I'll switch to Zapfino, which has this
font that's full of different features.

00:47:07.190 --> 00:47:11.130
And I'll instead use some stylistic variance.

00:47:11.130 --> 00:47:11.910
Here we go.

00:47:11.910 --> 00:47:13.070
It's completely different.

00:47:13.070 --> 00:47:18.250
So you can really create some really nice
typographic applications using Core Text.

00:47:18.250 --> 00:47:25.560
So, I want to show you what this code looks like
and I could go back to my keynote to show you that,

00:47:25.560 --> 00:47:30.100
but I have a text viewing application, so
why don't I just show you here in line.

00:47:30.100 --> 00:47:31.640
So, yeah. Nice.

00:47:31.640 --> 00:47:31.870
[ Applause ]

00:47:31.870 --> 00:47:45.750
So, the first thing to note is that this quote-unquote
slide is being rendered using the font that I included

00:47:45.750 --> 00:47:49.390
in the bundle, not something available to the iPad.

00:47:49.390 --> 00:47:51.120
So, let's get into the code.

00:47:51.120 --> 00:47:52.780
So, it's a very simple piece of code.

00:47:52.780 --> 00:47:54.890
I just defined the type of frames.

00:47:54.890 --> 00:47:58.420
One of them are fixed frames, other
are text full frames or picture frames.

00:47:58.420 --> 00:48:06.350
But the next object that I create for my code is the view
frame object, which is how I keep track of all my frames.

00:48:06.350 --> 00:48:09.590
And please note that I'm keeping track of the framesetter.

00:48:09.590 --> 00:48:17.700
Like I said, I hang on to this object for dear life
because it's what does the heavy layout in the process.

00:48:17.700 --> 00:48:20.480
Now, from there on, it's quite simple.

00:48:20.480 --> 00:48:26.330
I have a document object that basically reads those
XML files and keeps track of all the attributed strings

00:48:26.330 --> 00:48:30.120
and also keeps track of pages and where frames layout.

00:48:30.120 --> 00:48:37.450
So, not that we need to go to this line by line, but just
keep in mind that I can get my frames from this object

00:48:37.450 --> 00:48:41.590
and store them away in my frame info object.

00:48:41.590 --> 00:48:42.960
Then I could get the values.

00:48:42.960 --> 00:48:46.510
Once I get the values for text as my attributed string,

00:48:46.510 --> 00:48:51.090
I can create my framesetter and
stash it away for later drawing.

00:48:51.090 --> 00:49:00.500
In the case where I'm not using static frames where I'm
just using free flow of text, just in the second example

00:49:00.500 --> 00:49:02.590
that I provided you, there was two columns up.

00:49:02.590 --> 00:49:09.040
So in this case, I'll just-- my document says that I want
two columns up, I just divide the balance of the view

00:49:09.040 --> 00:49:18.090
into two columns and figure out what the rects are and
I just keep track of those frames in the same object.

00:49:18.090 --> 00:49:22.350
Then once I'm ready to draw, I
have everything at my disposal.

00:49:22.350 --> 00:49:25.510
I have the framesetter all ready.

00:49:25.510 --> 00:49:32.480
I have my path or my CGPath so I
can create a frame and draw it.

00:49:32.480 --> 00:49:39.170
So in the case where I am flowing text to-- from
column to column, it's not that much more complex.

00:49:39.170 --> 00:49:44.360
The only thing we need to figure out is how
much text fits into each one of those columns.

00:49:44.360 --> 00:49:47.710
And I keep track of that with this current index value.

00:49:47.710 --> 00:49:50.570
I create my first frame, draw it.

00:49:50.570 --> 00:49:55.400
Actually, I don't quite need to draw it before
I measure it but I can measure it with this API.

00:49:55.400 --> 00:50:02.470
The frame gets visible string range, and it will
tell me how much of the string fit into that frame.

00:50:02.470 --> 00:50:08.210
Notice at the very end I update my current index
and pretend I'm in a four loop or in a while loop

00:50:08.210 --> 00:50:12.400
and I just repeat the process here
until I exhaust all the text.

00:50:12.400 --> 00:50:18.020
Let's see, I do have some time and I will pray to
the demo gods that this works because I was sitting

00:50:18.020 --> 00:50:21.440
in the couch just doing this a minute ago.

00:50:21.440 --> 00:50:23.520
Sorry, I didn't mean to do that.

00:50:23.520 --> 00:50:26.370
But, the other thing I talked about was threading.

00:50:26.370 --> 00:50:31.390
So here I have a very long document that I created.

00:50:31.390 --> 00:50:34.030
Just notice how long it gets stuck at.

00:50:34.030 --> 00:50:35.700
It has a bunch of Arabic text.

00:50:35.700 --> 00:50:39.740
It's got a bunch of Japanese text,
Hebrew text, English text.

00:50:39.740 --> 00:50:48.420
It's got 385 pages, that's how long it took for Core
Text to layout all that information and display.

00:50:48.420 --> 00:50:52.470
Instead of doing this, I'll just switch back
so you know that I'm not playing tricks on you.

00:50:52.470 --> 00:50:57.510
I can do this by loading the frame asynchronously, OK.

00:50:57.510 --> 00:51:03.350
So, I'll just turn that on and I'll
switch to the long text and there it goes.

00:51:03.350 --> 00:51:07.940
And to see that I'm not playing tricks, see
it's at page 155, and I can keep going.

00:51:07.940 --> 00:51:11.780
So, this is a kind of a user experience you want to provide.

00:51:11.780 --> 00:51:17.180
You want to take advantage of Core Text
threading capabilities to get this done.

00:51:17.180 --> 00:51:19.510
So with that--

00:51:19.510 --> 00:51:24.560
[ Applause ]

00:51:24.560 --> 00:51:38.730
Oops, I forgot my-- so in short, Doug showed you
a great set of APIs and we highly encourage you

00:51:38.730 --> 00:51:46.540
to use these APIs, the NSString API especially,
along with the block APIs that we have for them.

00:51:46.540 --> 00:51:52.850
And also, this great new set of APIs
for RegEx and data detection.

00:51:52.850 --> 00:51:54.320
We've done a lot of the hard work.

00:51:54.320 --> 00:51:58.600
There is no reason for you to try to
go and re-implement this yourself.

00:51:58.600 --> 00:52:02.210
On the Core Text side of things, it's slightly different.

00:52:02.210 --> 00:52:12.910
It does provide a lot of power like you've seen, gives you a
lot of flexibility but it does come at a cost and I want you

00:52:12.910 --> 00:52:15.630
to make sure that you understand what that cost is.

00:52:15.630 --> 00:52:18.750
Once you go down to the Core Text
level, you're giving up a lot.

00:52:18.750 --> 00:52:22.700
You're giving up text editing,
you're giving up spell checking,

00:52:22.700 --> 00:52:26.810
you're giving up voice over support,
you're giving up copy and paste.

00:52:26.810 --> 00:52:34.280
So if your experience is to provide the user with some--
you know, a great view and text experience, great.

00:52:34.280 --> 00:52:39.790
But then if you have to be able to edit, then this is
something that you need to be aware of that it's going

00:52:39.790 --> 00:52:43.840
to come bite you, but you might
need it, it's well worth it.

00:52:43.840 --> 00:52:48.800
Some related sessions, especially if you're new to iOS.

00:52:48.800 --> 00:52:51.860
I recommend that you attend the Foundation sessions.

00:52:51.860 --> 00:52:57.380
You'll get a pretty good understanding of
the foundation of all the APIs that we use.

00:52:57.380 --> 00:53:01.840
The Internationalization Data on Mac
and iPhone will get your applications

00:53:01.840 --> 00:53:04.650
to be world ready so I recommend that a lot.

00:53:04.650 --> 00:53:06.760
And if you're doing cross-platform development,

00:53:06.760 --> 00:53:11.560
I recommend you attend the Cocoa Text
session as well to get some nice tips.

00:53:11.560 --> 00:53:19.210
Any feedback, any suggestions, gripes that you have,
please contact Bill Dudney, he's our Evangelist.

00:53:19.210 --> 00:53:24.030
And documentation, the documentation up
on the web is pretty robust and stable.

00:53:24.030 --> 00:53:25.150
I recommend that you go there.

00:53:25.150 --> 00:53:27.460
You can access it through developer.apple.com.

