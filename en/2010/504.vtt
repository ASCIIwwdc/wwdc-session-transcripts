WEBVTT

00:00:06.460 --> 00:00:10.970
>> Simon Fraser: Hi, my name is Simon Fraser and
I'm an engineer on the Safari and WebKit team.

00:00:10.970 --> 00:00:18.220
And you probably saw the first in this two-part
series on CSS effects by Jing just now.

00:00:18.220 --> 00:00:19.370
This is part two.

00:00:19.370 --> 00:00:24.820
And in this session we're going to focus on some slightly
more complex systems effects using a photo gallery

00:00:24.820 --> 00:00:25.610
as an example.

00:00:25.610 --> 00:00:32.620
But we'll look at keyframe animations
and 3D effects in some amount of detail.

00:00:32.620 --> 00:00:36.970
Now you've probably heard the term
HTML5 a lot in the news recently.

00:00:36.970 --> 00:00:43.140
And as we mentioned, HTML5 formally is the name of
a specification, which is the next version of HTML5.

00:00:43.140 --> 00:00:48.070
But informally, it's being used to cover a
sort of fairly broad range of web technologies.

00:00:48.070 --> 00:00:51.620
And today we're going to learn how to
use one of those web technologies, CSS3,

00:00:51.620 --> 00:00:56.110
to create some really rich, immersive web experiences.

00:00:56.110 --> 00:00:59.520
And you'll learn how to get really good
performance and really nice animation,

00:00:59.520 --> 00:01:03.040
both on iPhone, iPad, and on the desktop.

00:01:03.040 --> 00:01:07.340
And then we'll be using a little bit of
JavaScript to sort of glue things together

00:01:07.340 --> 00:01:10.070
and to create some of the really cool effects.

00:01:10.070 --> 00:01:19.020
So we first released support for dynamic
CSS effects in Safari 3.1 and in iPhone 2.0.

00:01:19.020 --> 00:01:22.150
And it's been really interesting to
see what people have used them for.

00:01:22.150 --> 00:01:27.810
Of course on www.apple.com we've been
putting these effects to great effect,

00:01:27.810 --> 00:01:31.020
creating lot of really neat interactive
content that lets people look

00:01:31.020 --> 00:01:34.870
at the new products and see all the details about them.

00:01:34.870 --> 00:01:38.580
And there are also people outside of
Apple who have been using these effects.

00:01:38.580 --> 00:01:43.500
This is the page from www.panic.com
that describes the Transmit application.

00:01:43.500 --> 00:01:46.880
And this makes really good use of transitions, transforms,

00:01:46.880 --> 00:01:51.170
and animations to let users explore
the features of this application.

00:01:51.170 --> 00:01:54.330
So from inside a web page, the user
can really get a feel for what it's

00:01:54.330 --> 00:01:58.200
like to use the actual application
once they've downloaded it.

00:01:58.200 --> 00:02:04.490
And then in the State of the Union
yesterday, you saw the HTML5 demos.

00:02:04.490 --> 00:02:07.940
These, again, make great use of CSS
effects so I encourage you to go

00:02:07.940 --> 00:02:13.070
and explore those and to download the code for those.

00:02:13.070 --> 00:02:16.920
So all of this stuff, you know,
obviously is just web development.

00:02:16.920 --> 00:02:22.120
If you already know a little bit
of CSS -- cascading style sheets --

00:02:22.120 --> 00:02:27.470
it's a very small amount of additional knowledge
to use CSS effects and really spice up your pages.

00:02:27.470 --> 00:02:32.750
In this session, pretty much everything I'm
going to talk to you about is CSS properties.

00:02:32.750 --> 00:02:36.430
There's a little bit of use of the
document object model -- that's the DOM API.

00:02:36.430 --> 00:02:42.930
And that's the API you use from JavaScript to modify
the page, listen for events, and things like that.

00:02:42.930 --> 00:02:47.700
And of course JavaScript is the programming
language that we use to drive all this stuff.

00:02:47.700 --> 00:02:57.360
And all of this works in Safari on iOS or on iPad, iPhone,
and iPod touch, and of course Safari on Mac and Windows.

00:02:57.360 --> 00:03:01.890
And then if you're embedding WebKit in
your native apps, in UIWebView, in iOS,

00:03:01.890 --> 00:03:05.690
and WebView on the desktop, all this stuff works as well.

00:03:05.690 --> 00:03:08.070
And also, there's another client now -- iAds.

00:03:08.070 --> 00:03:11.740
So if you're creating iAds, you'll probably
make really strong use of CSS effects.

00:03:11.740 --> 00:03:14.870
So let me take a minute to talk about open standards,

00:03:14.870 --> 00:03:17.780
and you've probably heard this
before, but I want to reinforce it.

00:03:17.780 --> 00:03:23.420
The way Apple advances web technology
is to participate in open standards

00:03:23.420 --> 00:03:26.010
and specifically we work with the standards groups.

00:03:26.010 --> 00:03:31.890
For example, we've worked very closely with the
WHATWG Group and the HTML working group of the W3C

00:03:31.890 --> 00:03:36.260
on the HTML5 specification, particularly
in terms of the audio and video elements.

00:03:36.260 --> 00:03:41.550
I'm actually a member of the CSS working group and all the
properties that I'm going to talk about today are included

00:03:41.550 --> 00:03:49.060
in specifications that we've submitted to the working
group for consideration, for inclusion in CSS3.

00:03:49.060 --> 00:03:54.850
Now because these are still specifications in draft
form, we do have the WebKit prefix on the properties

00:03:54.850 --> 00:03:58.490
and Jean mentioned in the previous
talk why we have this prefix.

00:03:58.490 --> 00:04:05.340
So let me show you -- or tell you --
what you'll learn in today's session.

00:04:05.340 --> 00:04:09.550
We're going to focus on two demos and use those to explain

00:04:09.550 --> 00:04:14.530
to you what CSS effects you can
use and why you want to use them.

00:04:14.530 --> 00:04:16.820
The first one is what we call a lightbox.

00:04:16.820 --> 00:04:17.890
It's a simple image viewer.

00:04:17.890 --> 00:04:22.520
You're probably really familiar with this -- you go to a
page with images or a gallery, you click on those images,

00:04:22.520 --> 00:04:28.460
and then get this sort of full screen overlay or
full window overlay and you focus just on the image.

00:04:28.460 --> 00:04:32.790
And in creating this lightbox, we'll see
how simple it is to use CSS transitions.

00:04:32.790 --> 00:04:37.420
And we'll show you how to get consistent
behavior between iPhone, iPad, and desktop.

00:04:37.420 --> 00:04:42.440
Now the second example is a photo gallery,
and this has some more dynamic content.

00:04:42.440 --> 00:04:45.310
We're loading images dynamically,
there's a bit more JavaScript.

00:04:45.310 --> 00:04:52.130
But we'll use this as a vehicle to show you the really
cool effects you can do with transitions, animations,

00:04:52.130 --> 00:04:55.020
and transforms -- some really nice cinematic stuff.

00:04:55.020 --> 00:04:59.000
And throughout the session I'll
give you some tips and tricks.

00:04:59.000 --> 00:05:04.270
So to show you these two demos that we
built, I'd like to invite my colleague,

00:05:04.270 --> 00:05:08.020
Enrica Casucci on stage to give you a demo.

00:05:08.020 --> 00:05:08.200
[ Applause ]

00:05:08.200 --> 00:05:13.650
>> Enrica Casucci: Hi, everyone.

00:05:13.650 --> 00:05:18.210
I'm going to show you today a simple example of a lightbox.

00:05:18.210 --> 00:05:28.490
As Simon said, a lightbox is a technique normally used to
display large images on top of a page using an overlay.

00:05:28.490 --> 00:05:32.780
It's something that looks more or less like this.

00:05:32.780 --> 00:05:41.270
Normally, the larger image is presented with a variety
of transitions, animations for positioning and sizing.

00:05:41.270 --> 00:05:51.750
And there's a number of existing frameworks that you can
use in order to easily add this functionality to your pages.

00:05:51.750 --> 00:05:56.110
The one we have used for this example is called FancyBox.

00:05:56.110 --> 00:06:01.370
But let's take a look a little bit
closely at the transition here.

00:06:01.370 --> 00:06:09.570
As I tap on the image, as you can see the transition
to the large image is not extremely smooth.

00:06:09.570 --> 00:06:14.430
And let me do this one more time.

00:06:14.430 --> 00:06:22.410
Notice that when the overlay comes up, there
is no opacity animation on the background.

00:06:22.410 --> 00:06:31.750
And also, normally these frameworks provide some sort of
loading indicator while the large image is being loaded.

00:06:31.750 --> 00:06:34.670
And let me show you this one slowly.

00:06:34.670 --> 00:06:40.790
As you can see, the progress indicator looks fairly static.

00:06:40.790 --> 00:06:45.570
What happens here is that even though -- I mean,
this is a great framework, don't get me wrong --

00:06:45.570 --> 00:06:54.460
but the problem that we are encountering here is
that JavaScript is used to drive the animation.

00:06:54.460 --> 00:07:03.490
What this means is that we normally have JavaScript
timers firing for each frame of the animation.

00:07:03.490 --> 00:07:14.220
Using CSS transitions and animation allow us to basically
let the rendering engine in the browser do the heavy lifting

00:07:14.220 --> 00:07:18.230
for us, taking advantage of the existing hardware

00:07:18.230 --> 00:07:22.630
and potentially leveraging hardware
acceleration when it's available.

00:07:22.630 --> 00:07:32.560
So let me show you now another example of another page
we've created using only CSS transitions and animations.

00:07:32.560 --> 00:07:42.060
Again, the look is very similar but as I tap over
the image, look how smooth the transition is.

00:07:42.060 --> 00:07:44.580
We've used a scaling transition here.

00:07:44.580 --> 00:07:48.500
Let me do this one more time so
that you can fully appreciate.

00:07:48.500 --> 00:07:57.840
And also check out the transition on the opacity of the
overlay, which adds a very nice touch and a polished look.

00:07:57.840 --> 00:08:07.770
And if I show you this first one that I've created with
a slow motion, look how smooth the progress animation is.

00:08:07.770 --> 00:08:14.380
And this is because we are truly leveraging
the power of the hardware acceleration.

00:08:14.380 --> 00:08:24.330
During the second part of the session, Simon is going to
talk about photo galleries and you will learn how to use 2D

00:08:24.330 --> 00:08:30.440
and 3D transforms and animations
to create some awesome effects.

00:08:30.440 --> 00:08:37.210
Since you're all developers, I'm pretty sure that at this
point you all want to jump to the code and take a look.

00:08:37.210 --> 00:08:39.340
But I want to tease you a little bit longer.

00:08:39.340 --> 00:08:47.050
Here is an example of a photo gallery that we
have created to showcase some of the effects

00:08:47.050 --> 00:08:51.220
that you can achieve with CSS transforms and animation.

00:08:51.220 --> 00:08:57.880
Using a transform on the opacity, you
can create a crossfade effect like this.

00:08:57.880 --> 00:09:06.410
Transform with translations allow you to create
push effects like this or a push down like this one.

00:09:06.410 --> 00:09:13.410
With rotation, you can achieve spin effects
but it's when you start using 3D transforms

00:09:13.410 --> 00:09:18.510
that you can truly add visual depth to your photo gallery.

00:09:18.510 --> 00:09:28.100
And with the same amount of effort, you can create,
like, a revolving door effect like this one, or a cube.

00:09:28.100 --> 00:09:36.530
A few lines of JavaScript will allow
you to do something like this --

00:09:36.530 --> 00:09:41.560
this amazing tile drop effect, unfolding effects, sorry.

00:09:41.560 --> 00:09:42.940
Isn't that awesome?

00:09:42.940 --> 00:09:49.180
[ Applause ]

00:09:49.180 --> 00:09:52.190
At this point, I'm going to hand it back to Simon,

00:09:52.190 --> 00:10:00.040
who will show you how to create these
amazing things with just a few lines of CSS.

00:10:00.040 --> 00:10:00.700
>> Simon Fraser: Thanks, Enrica.

00:10:00.700 --> 00:10:02.790
That looked really good.

00:10:02.790 --> 00:10:06.330
So let's start off by what we call
building a better lightbox.

00:10:06.330 --> 00:10:09.770
And as Enrica mentioned, there's lots of
lightbox implementations out there already.

00:10:09.770 --> 00:10:12.150
We're not trying to replicate the features of all those.

00:10:12.150 --> 00:10:17.930
We're not trying to reinvent the lightbox
but we wanted to focus on a few things here.

00:10:17.930 --> 00:10:23.210
The first thing is: how you can make use of CSS
transitions to get really nice, smooth, transition effects.

00:10:23.210 --> 00:10:25.930
And you saw a bunch of them in the lightbox example.

00:10:25.930 --> 00:10:30.630
The second one is: how we can create
a loading indicator just with CSS.

00:10:30.630 --> 00:10:39.040
And then finally: how to get consistent behavior and
consistent performance on desktop, iPad and iPhone.

00:10:39.040 --> 00:10:42.960
So all of this we can do in just 4 simple steps.

00:10:42.960 --> 00:10:46.710
The first step is something that any lightbox does --

00:10:46.710 --> 00:10:51.450
when the user clicks on one of the smaller images
on the page, we start loading the large image.

00:10:51.450 --> 00:10:55.980
And this is just some simple JavaScript you're
probably familiar with, creating new image element,

00:10:55.980 --> 00:11:01.120
registering an onload handler so we get notified when
the image loads, and then we set the source attribute

00:11:01.120 --> 00:11:03.690
to start loading the high-resolution image.

00:11:03.690 --> 00:11:06.070
Now the key here is we want to do this as soon as possible.

00:11:06.070 --> 00:11:09.660
We're going to have this overlay
that fades in over a period of time.

00:11:09.660 --> 00:11:14.210
So the sooner we kick off this load, the
sooner the user gets to see the final image.

00:11:14.210 --> 00:11:21.940
Okay, the second step -- that's to start fading in
the overlay, which is this sort of semi-opaque box

00:11:21.940 --> 00:11:25.450
that covers the rest of the page so we focus on this image.

00:11:25.450 --> 00:11:32.590
And here we start using a bit of CSS, we're matching the
element with the ID overlay, using the selector right there.

00:11:32.590 --> 00:11:35.990
And it starts off with an opacity zero, so it's transparent.

00:11:35.990 --> 00:11:41.490
And then when we apply the visible class
to that, it's going to fade to opacity 1.

00:11:41.490 --> 00:11:47.800
And as you probably saw in CSS Effects Part 1, normally
when CSS properties change, they change instantaneously.

00:11:47.800 --> 00:11:52.200
But this gives a very jarring, kind
of disruptive appearance to the user;

00:11:52.200 --> 00:11:55.470
it's much better if we can smooth out that change.

00:11:55.470 --> 00:11:57.560
And with one line of CSS, we can do this.

00:11:57.560 --> 00:12:02.860
We apply the transition property and we say that
we want opacity to transition over a half second.

00:12:02.860 --> 00:12:06.350
And that gives us this nice, smooth, even curve here.

00:12:06.350 --> 00:12:08.520
And if we wanted to, we could use
a linear timing function --

00:12:08.520 --> 00:12:11.480
that will give us a constant rate
of change in the opacity property.

00:12:11.480 --> 00:12:14.920
So it's very easy to get animations with transitions.

00:12:14.920 --> 00:12:17.910
And you've probably seen -- in fact,
you have seen the shorthand used a lot,

00:12:17.910 --> 00:12:21.000
WebKit transition but these are the longhand properties.

00:12:21.000 --> 00:12:24.660
The first one specifies which other
properties you want to transition.

00:12:24.660 --> 00:12:28.470
The second one specifies how long
the transition is going to take.

00:12:28.470 --> 00:12:32.520
And then transition timing function
allows you to control that easing function

00:12:32.520 --> 00:12:35.590
and you can do custom timing functions
with the cubic Bezier.

00:12:35.590 --> 00:12:38.480
There are a bunch of easing functions built in.

00:12:38.480 --> 00:12:42.350
And then as you saw in the previous
session, transition delay,

00:12:42.350 --> 00:12:44.320
which is really useful for these neat building effects.

00:12:44.320 --> 00:12:46.520
So let's go back to the overlay.

00:12:46.520 --> 00:12:54.480
Now, here we have to write a little bit of JavaScript
that's going to create the overlay for the first time

00:12:54.480 --> 00:12:56.710
and it uses createElement, which is one these DOM APIs.

00:12:56.710 --> 00:13:03.100
And it sets the IDs overlay so we can identify
it from JavaScript and style it in CSS.

00:13:03.100 --> 00:13:06.960
And then we append the overlay to the body element.

00:13:06.960 --> 00:13:12.570
Now you might think at this point that if you set
the visible class name, both styles will apply,

00:13:12.570 --> 00:13:16.130
the opacity one will give a nice transition.

00:13:16.130 --> 00:13:19.960
But in actual fact, that doesn't quite work as you expect.

00:13:19.960 --> 00:13:24.480
So let me take a moment to explain why
this doesn't behave quite as you expect.

00:13:24.480 --> 00:13:31.020
Now the reason is: browsers actually
do some style coalescing under the hood

00:13:31.020 --> 00:13:33.840
and I'll explain that with this example here.

00:13:33.840 --> 00:13:36.480
Imagine you have this JavaScript, it's
setting the background color to red

00:13:36.480 --> 00:13:38.850
and then immediately it sets the background color to blue.

00:13:38.850 --> 00:13:43.370
Now the question is: does the browser
ever actually render that red color?

00:13:43.370 --> 00:13:44.860
And the answer is no.

00:13:44.860 --> 00:13:48.580
The browser's essentially throwing
away redundant style changes.

00:13:48.580 --> 00:13:53.030
It batches up the style changes and red is
getting overwritten with blue right away.

00:13:53.030 --> 00:13:56.350
So the only thing it's going to
do here is render that blue color.

00:13:56.350 --> 00:13:59.830
Normally this doesn't matter but transitions are temporal.

00:13:59.830 --> 00:14:04.340
So there's this temporal component now that
means that this actually becomes important.

00:14:04.340 --> 00:14:07.770
Imagine we changed the JavaScript to something like this.

00:14:07.770 --> 00:14:13.330
So here we're setting the transition property and we're
saying that we want background color to transition.

00:14:13.330 --> 00:14:19.020
And now, again, do you expect to see an
animation between red and blue in this case?

00:14:19.020 --> 00:14:22.190
Well, the answer is no, we don't get one
here, either and for the same reason --

00:14:22.190 --> 00:14:27.660
the browser's coalescing those style changes and so the
only thing the browser actually renders is the blue color.

00:14:27.660 --> 00:14:29.080
And that transition rule is there.

00:14:29.080 --> 00:14:32.480
And so if we change the color later on
to something else, we'll get a transition

00:14:32.480 --> 00:14:37.530
but we won't actually ever see the
red-to-blue transition in this case.

00:14:37.530 --> 00:14:43.840
Now, there are a number of solutions to this problem
and the one we recommend using is setTimeout.

00:14:43.840 --> 00:14:48.520
And what this does is allow you to run
a little bit of code after a delay.

00:14:48.520 --> 00:14:52.020
In this case, we used the delay
zero but it's enough of a delay

00:14:52.020 --> 00:14:56.310
that the browser gets a chance
to render the initial red color.

00:14:56.310 --> 00:15:00.630
And now when the color changes to blue a little
bit later on, the browser is actually going

00:15:00.630 --> 00:15:05.800
to then run the transition between red and blue.

00:15:05.800 --> 00:15:08.620
So you get a nice transition there.

00:15:08.620 --> 00:15:09.700
So let's go back to our overlay.

00:15:09.700 --> 00:15:12.290
In this case the scenario is a little different

00:15:12.290 --> 00:15:15.260
but essentially we've just appended
this element to the document.

00:15:15.260 --> 00:15:19.620
But we're applying the visible class
right away so the browser's never going

00:15:19.620 --> 00:15:21.780
to have a chance to render the opacity zero.

00:15:21.780 --> 00:15:24.050
And so it won't run that transition.

00:15:24.050 --> 00:15:26.880
The solution is to use the setTimeout.

00:15:26.880 --> 00:15:33.200
And now we change the class name to Visible inside
the setTimeout and we'll see a nice transition here.

00:15:33.200 --> 00:15:38.500
So that's what this looks like.

00:15:38.500 --> 00:15:41.880
You get a nice, smooth fade, even
on the iPad as Enrica showed you.

00:15:41.880 --> 00:15:46.150
So our next step is to create this loading indicator.

00:15:46.150 --> 00:15:50.520
You see it's static in this picture,
but actually animated as you saw.

00:15:50.520 --> 00:15:53.610
So we want to be able to animate that.

00:15:53.610 --> 00:16:00.140
Now there are two CSS effects we can use to get a
really nice, smoothly animating loading indicator here.

00:16:00.140 --> 00:16:05.070
The first thing we can do is we can
use rotations by a CSS transforms

00:16:05.070 --> 00:16:09.230
and the second one is we can use CSS
keyframe animations to have this animation

00:16:09.230 --> 00:16:13.110
or this rotation continually repeat or continually animate.

00:16:13.110 --> 00:16:18.910
And the benefit of doing it this way is: first of all,
you can do it without any plugins or animated JIFs;

00:16:18.910 --> 00:16:20.980
you can use really nice, high-quality images,

00:16:20.980 --> 00:16:27.550
maybe a PNG with alpha so it lends
very nicely with the rest of the page.

00:16:27.550 --> 00:16:31.020
So let's see how we do this.

00:16:31.020 --> 00:16:33.500
So here's our image.

00:16:33.500 --> 00:16:37.140
And then to get the animation running,
there are two things we need to do.

00:16:37.140 --> 00:16:40.820
The first one is we describe the
animation in terms of a set of keyframes.

00:16:40.820 --> 00:16:44.100
So this uses a new at-rule and it has the -WebKit prefix.

00:16:44.100 --> 00:16:46.420
So it's @-WebKit-keyframes.

00:16:46.420 --> 00:16:48.450
And then the other name, spin, which we'll use later.

00:16:48.450 --> 00:16:53.740
And the keyframes are where we
described the states of the animation.

00:16:53.740 --> 00:16:58.520
So the front keyframe is the initial state
of this thing and it has a rotation of zero.

00:16:58.520 --> 00:17:02.780
And then the 2 keyframe, the final state,
has a rotation of 360 degrees, so one turn.

00:17:02.780 --> 00:17:07.530
And then as the animation's running, the
browser's going to interpolate between these two.

00:17:07.530 --> 00:17:14.420
So they'll do a nice interpolation between 0 and
360, causing our image to spin around one time.

00:17:14.420 --> 00:17:18.700
Now, it has this name "spin," which
is some name you give it.

00:17:18.700 --> 00:17:26.620
And then you can apply the animation, using the
WebKit animation property, namely the keyframe, spin.

00:17:26.620 --> 00:17:28.730
And then you give it a duration, so one second.

00:17:28.730 --> 00:17:31.630
And that's the duration of one cycle of animation.

00:17:31.630 --> 00:17:36.430
And in this case, we want this thing to spin around for
as long as we're waiting for that large image to load.

00:17:36.430 --> 00:17:38.530
So the repeat count we use here is infinite.

00:17:38.530 --> 00:17:41.560
But you could use 10 or 5 or 1 or whatever.

00:17:41.560 --> 00:17:45.980
And we want it to spin with a constant angular
velocity so we use a linear timing function.

00:17:45.980 --> 00:17:49.430
That gives us a nice, smooth spin out.

00:17:49.430 --> 00:17:50.870
So that's pretty much all we need to do.

00:17:50.870 --> 00:17:53.110
That gives us this nice spinning indicator.

00:17:53.110 --> 00:17:58.430
And that spinning indicator is going to stay there for
as long as you're waiting for the large image to load.

00:17:58.430 --> 00:18:04.880
But once that large image loads, then the next step
is to manage this transition to show the big image.

00:18:04.880 --> 00:18:09.850
This is a little more complicated, so
I'm not going to go into all the details.

00:18:09.850 --> 00:18:16.000
But the first thing you need to bear in mind is
we've got two things running here that are temporal:

00:18:16.000 --> 00:18:18.920
we've got the large image loading and the overlay is fading.

00:18:18.920 --> 00:18:22.210
And we need to have a little bit of logic in
our JavaScript that waits for both of these

00:18:22.210 --> 00:18:25.750
to finish before we do this final reveal on the image.

00:18:25.750 --> 00:18:33.010
And you can imagine you could use CSS transitions
on heightened width to do that scale of the image.

00:18:33.010 --> 00:18:38.050
And if you wanted to, you could do transitions
of maybe opacity to reveal the caption

00:18:38.050 --> 00:18:41.010
or maybe the caption could fall
down where the margin transition.

00:18:41.010 --> 00:18:48.280
And you could reveal the close button
somehow, maybe it pops in with a scale.

00:18:48.280 --> 00:18:53.120
So if you put all that stuff together, this is what it
looks like, although this is what it looks like on desktop.

00:18:53.120 --> 00:18:56.050
On iPad, you probably wouldn't get a very good frame rate.

00:18:56.050 --> 00:19:01.720
So let me talk a bit about optimizing for iPad and iPhone.

00:19:01.720 --> 00:19:07.580
Now, as Enrica mentioned, if you were animating
properties with JavaScript, essentially --

00:19:07.580 --> 00:19:12.000
many libraries do this, they're running timers
to change the style of an element, you know,

00:19:12.000 --> 00:19:15.960
multiple times to get an animation to run.

00:19:15.960 --> 00:19:20.970
The problem is the browser can't really optimize that
very well; it doesn't really know what the animation is.

00:19:20.970 --> 00:19:25.510
So if you use CSS transitions in
animations, we can hit a fast path.

00:19:25.510 --> 00:19:31.520
We know you're running an animation and
therefore, we can make it a lot more efficient.

00:19:31.520 --> 00:19:36.170
And so you'll get at least as good performance
using transitions and animations on most properties

00:19:36.170 --> 00:19:42.610
and you'll get significantly better performance if you
animate the transform property or the opacity properly

00:19:42.610 --> 00:19:45.230
for these we actually make use of hardware acceleration.

00:19:45.230 --> 00:19:49.990
We offload some of the compositing to the
GPU, so you get great performance with these

00:19:49.990 --> 00:19:55.680
and these are really useful for iPad and iPhone.

00:19:55.680 --> 00:19:59.750
So let me summarize what we learned
by building this better lightbox.

00:19:59.750 --> 00:20:06.340
First of all, CSS transitions can give you a really nice
cinematic experience and they're really easy to offer.

00:20:06.340 --> 00:20:10.750
Often it's just one line of the CSS to go from
a jarring transition to a nice, smooth one.

00:20:10.750 --> 00:20:14.370
And you can get really good performance on all platforms.

00:20:14.370 --> 00:20:18.680
Remember, the two properties you want to
stick to are WebKit-transform and opacity.

00:20:18.680 --> 00:20:24.880
And then the second thing we learned is we can get
this nice, loading indicator using a combination

00:20:24.880 --> 00:20:30.940
of a rotation transform and CSS animations
without any JavaScript, without any plugins.

00:20:30.940 --> 00:20:38.130
So, you know, this lightbox is a
great way of showing a single image.

00:20:38.130 --> 00:20:40.230
What if you want to show multiple images?

00:20:40.230 --> 00:20:50.500
Well, that takes us into the next section, which
is building really awesome photo galleries.

00:20:50.500 --> 00:20:54.510
And Enrica showed you some demos but here are
some of the effects we've put together here.

00:20:54.510 --> 00:20:57.730
Now, some of these have a sense of
depth, they have some 3D in them.

00:20:57.730 --> 00:21:05.730
And there are also some other kind of
interesting effects that we can get here.

00:21:05.730 --> 00:21:09.830
So you'll see how to build these later in this session.

00:21:12.670 --> 00:21:17.070
So before we delve into the details of
how to build a photo gallery like this,

00:21:17.070 --> 00:21:19.990
I'd like to step back a little
bit and talk about best practices.

00:21:19.990 --> 00:21:27.610
I think the most important thing when you're building
a photo gallery is to stay within the same page.

00:21:27.610 --> 00:21:31.730
If you force people to load a new page for
every image as they go through a gallery,

00:21:31.730 --> 00:21:35.390
that uses a lot of bandwidth, it's
very tedious for the user.

00:21:35.390 --> 00:21:37.630
If they're on a slow connection, it will be really slow.

00:21:37.630 --> 00:21:41.610
And there's no way you can do nice
transitions between images in that case.

00:21:41.610 --> 00:21:44.990
And you may think, "Well, if you stay on
the same page doing kind of Ajax-y stuff,

00:21:44.990 --> 00:21:49.230
don't you break history and bookmarking
and stuff like that?"

00:21:49.230 --> 00:21:55.710
Well, HTML5 now has APIs that let you solve those problems
-- it has a history API and a location object you can use

00:21:55.710 --> 00:22:00.870
to basically work around those
problems of bookmarking and history.

00:22:00.870 --> 00:22:08.200
The second thing I recommend is: load each image on
demand; don't force the user to wait for all the images

00:22:08.200 --> 00:22:11.670
in the gallery to load before they
can start stepping through it.

00:22:11.670 --> 00:22:16.080
And with a little bit of JavaScript, you can just kick
off those image loads as the user's moving through.

00:22:16.080 --> 00:22:17.580
It's quite straightforward.

00:22:17.580 --> 00:22:28.810
A technique we found very useful when creating slightly more
complex content is to make extensive use of CSS class names

00:22:28.810 --> 00:22:32.580
and specifically to use class names
to describe states in our content.

00:22:32.580 --> 00:22:38.540
So in this particular example, we
have two types of state we care about.

00:22:38.540 --> 00:22:44.820
When we're moving from one image to the next, we have a new
image that's coming in and we use an incoming class name

00:22:44.820 --> 00:22:51.490
to identify that, and then the old image -- the one that's
going away -- and that gets the outgoing class name.

00:22:51.490 --> 00:22:54.930
We also have the notion of initial and final states.

00:22:54.930 --> 00:23:00.780
The initial state is where everything is before we start
running that transition from the old image to the new image.

00:23:00.780 --> 00:23:06.050
And then the final state is where everything
is once we've finished that transition.

00:23:06.050 --> 00:23:14.030
And now because we've described the states and the content
using class names, our JavaScript becomes very small.

00:23:14.030 --> 00:23:19.630
Instead of having to write a lot of spaghetti JavaScript
that modifies style and does all this complicated stuff,

00:23:19.630 --> 00:23:25.460
we can use the JavaScript for two really simple
things: the first is to kick off these image loads

00:23:25.460 --> 00:23:31.050
so we have the dynamic image loading, and the second thing
that JavaScript does is just toggle these class names

00:23:31.050 --> 00:23:37.470
to basically move us between the states
that we've already described in CSS.

00:23:37.470 --> 00:23:43.110
So let's look at the actual markup or the structure
of the document we're going to use for this gallery.

00:23:43.110 --> 00:23:46.020
We have the main div, which we call photo container,

00:23:46.020 --> 00:23:50.050
which is just going to be the container
for the images we're showing.

00:23:50.050 --> 00:23:55.810
And then when we're running a particular move from
one image to the next, we have an incoming image

00:23:55.810 --> 00:24:02.310
which would give this class name incoming and the old
image that's going away gets the outgoing class name.

00:24:02.310 --> 00:24:07.860
So temporarily, our photo container has two children
-- two child elements -- which are these two images.

00:24:07.860 --> 00:24:12.360
And when the transition's done, we'll rip out
the old one and get left with just one image.

00:24:12.360 --> 00:24:16.120
And of course to do this, so the images don't stack
up, you'd use absolute positioning and that kind

00:24:16.120 --> 00:24:20.320
of thing so that they're in the right spot.

00:24:20.320 --> 00:24:25.700
So bearing that in mind, let's see how we build
a transition like this, a push down transition.

00:24:25.700 --> 00:24:30.370
So here's our photo container.

00:24:30.370 --> 00:24:35.520
And now we start describing the states
of the content using these class names.

00:24:35.520 --> 00:24:40.630
So the initial and final class names go on the photo
container because they apply to everything underneath it.

00:24:40.630 --> 00:24:46.240
And then here we start styling the incoming image.

00:24:46.240 --> 00:24:48.710
And we're using transforms, of course,
because we know they animate nicely.

00:24:48.710 --> 00:24:56.510
In this case, we'll use translateY, which is just a
shorthand for a vertical translate and the value is -100%.

00:24:56.510 --> 00:24:59.910
And that's a convenient way of
moving something up by its height.

00:24:59.910 --> 00:25:03.560
So you can use percentages in translates
and that's pretty useful.

00:25:03.560 --> 00:25:08.960
When the incoming image is in the final state,
it's front and center, it has a translateY(0).

00:25:08.960 --> 00:25:18.270
And then the outgoing image starts in that same
spot and moves to a positive 100% translate.

00:25:18.270 --> 00:25:19.430
So it goes down.

00:25:19.430 --> 00:25:23.310
And then the final thing we want to do here is, of course,

00:25:23.310 --> 00:25:28.720
tell the browser that all these style changes,
these state changes, should be animated.

00:25:28.720 --> 00:25:35.440
So we use the transition property to specify that we
want transform to animate over a half-second here.

00:25:35.440 --> 00:25:37.750
Now you may have noticed if you were
looking carefully in the previous slide

00:25:37.750 --> 00:25:40.900
that we're also doing some opacity
changes as we're doing this transition.

00:25:40.900 --> 00:25:47.510
I'm not showing this here for simplicity but
you can imagine it's pretty easy to add those.

00:25:47.510 --> 00:25:51.760
So then there's some JavaScript we
need to actually do the image loading

00:25:51.760 --> 00:25:55.930
and cause this transition to happen, so let's look at that.

00:25:55.930 --> 00:26:00.190
So the first thing we do is getElementById that
just gives us a reference to our photo container.

00:26:00.190 --> 00:26:04.500
And now we start setting these class names that
describe the states of things in our content.

00:26:04.500 --> 00:26:08.400
So the outgoing image, the old image, we know
is the first child of the photo container

00:26:08.400 --> 00:26:10.650
so we can add the outgoing class name to that one.

00:26:10.650 --> 00:26:15.460
And we have the incoming image that's already
loaded so we set the incoming class name

00:26:15.460 --> 00:26:17.510
on that and we're doing appendChild.

00:26:17.510 --> 00:26:19.660
So now our photo container has two children.

00:26:19.660 --> 00:26:26.690
And we set the initial class name to tell the browser
to render all those things in their initial states.

00:26:26.690 --> 00:26:29.430
And we use the setTimeout technique again.

00:26:29.430 --> 00:26:33.220
And all we have to do inside the setTimeout
is basically flip the class names.

00:26:33.220 --> 00:26:36.320
So remove the initial class name, add the final class name,

00:26:36.320 --> 00:26:40.860
and that will kick off all the transitions
that cause the effect to happen.

00:26:40.860 --> 00:26:45.590
Now there's a little bit of clean
up we need to do at the end.

00:26:45.590 --> 00:26:49.350
And the first thing we need to figure out was:
how do we know when this effect is finished,

00:26:49.350 --> 00:26:51.970
when the move from the old image
to the new image is completed?

00:26:51.970 --> 00:26:56.270
Well, transitions emit DOM events when they end.

00:26:56.270 --> 00:27:01.320
So we can register an event listener, using an
event listener for the WebKit transition end event.

00:27:01.320 --> 00:27:05.820
And we register a callback function
on that, which is transition done.

00:27:05.820 --> 00:27:08.340
So let's write that now.

00:27:08.340 --> 00:27:10.720
The first thing we do is remove the final class name.

00:27:10.720 --> 00:27:15.410
We're done, the transition's over, we can just
remove the class names; we don't need them anymore.

00:27:15.410 --> 00:27:21.090
And then we know the first child of the photo container
is the old image so we do a remove child, get rid of that.

00:27:21.090 --> 00:27:26.550
And then we can just take the class name
off the incoming image because we're done.

00:27:26.550 --> 00:27:31.000
Now the thing to note here is that this JavaScript
-- the JavaScript on the last two slides --

00:27:31.000 --> 00:27:34.140
is not going to change for the rest of this session.

00:27:34.140 --> 00:27:38.700
The JavaScript stays the same because
we've described all of the states in CSS.

00:27:38.700 --> 00:27:45.090
So all we have to do is change the CSS to
get lots of different kinds of effects.

00:27:45.090 --> 00:27:48.730
So let me show you some of those effects.

00:27:48.730 --> 00:27:52.780
This is a scale transition -- we saw
Enrica demo it, it's very simple.

00:27:52.780 --> 00:27:56.370
And here I'm just going to show you
the style for the incoming image,

00:27:56.370 --> 00:27:59.560
the outgoing image is pretty much just the reverse.

00:27:59.560 --> 00:28:03.120
So the incoming image starts with a
scale of zero, so it's like really tiny

00:28:03.120 --> 00:28:06.040
in the middle and then it zooms up to a scale of 1.

00:28:06.040 --> 00:28:09.110
And the outgoing image just does the reverse.

00:28:09.110 --> 00:28:14.840
And then this funky spin transition.

00:28:15.870 --> 00:28:22.550
Being an incoming image has initial rotation of
minus 180 degrees, that gives it a half turn.

00:28:22.550 --> 00:28:25.320
And then its final rotation is zero.

00:28:25.320 --> 00:28:28.480
And that's all we need to get that nice spin transition.

00:28:28.480 --> 00:28:34.330
So let me summarize what we've
learned from photo gallery so far.

00:28:34.330 --> 00:28:39.000
First of all, keep your user's window
the same page and then use JavaScript

00:28:39.000 --> 00:28:43.290
to dynamically load images as you move through the gallery.

00:28:43.290 --> 00:28:45.630
Use class names to describe states.

00:28:45.630 --> 00:28:55.110
So use this declarative technique where all the interesting
states are described as combinations of CSS classes

00:28:55.110 --> 00:28:56.970
and then your JavaScript becomes really small.

00:28:56.970 --> 00:29:00.050
All your JavaScript's doing is toggling these classes.

00:29:00.050 --> 00:29:07.250
And then to detect when transitions
end, use the transition end event.

00:29:07.250 --> 00:29:13.340
And finally, all you have to do is change the
CSS to get lots of neat transition effects.

00:29:13.340 --> 00:29:17.010
And transforms gives you all sorts of scales
and rotates you can do with the image.

00:29:17.010 --> 00:29:24.950
So in this case we just used the transform property but
we were able to get lots of different kinds of effects.

00:29:24.950 --> 00:29:29.910
So what about these effects that look
much more 3D to have this sense of depth?

00:29:29.910 --> 00:29:34.410
Well, let's look at how to create these.

00:29:34.410 --> 00:29:38.230
So, you know, these are obviously
doing some sort of 3D stuff.

00:29:38.230 --> 00:29:38.770
What does this mean?

00:29:38.770 --> 00:29:43.920
We have the ability to describe 3D transforms
in CSS now and this is pretty exciting.

00:29:43.920 --> 00:29:49.220
So what it does really is it doesn't really
give us a sort of 3D modeling environment --

00:29:49.220 --> 00:29:53.920
we don't have spheres and cubes and
cones and stuff but it does allow us

00:29:53.920 --> 00:29:56.420
to position elements in a three-dimensional space.

00:29:56.420 --> 00:29:59.400
Sometimes this is called "planes in space or 2.5D."

00:29:59.400 --> 00:30:07.280
And this is -- in addition to the x- and
y-axes, you have for doing transforms already,

00:30:07.280 --> 00:30:10.120
it gives you this z-axis, which is coming out of the screen.

00:30:10.120 --> 00:30:19.420
So, just to look at the properties for a moment, this uses
the same transform property that we've been using already

00:30:19.420 --> 00:30:23.510
but it has some new values, like
translate 3D, rotate 3D, scale 3D,

00:30:23.510 --> 00:30:27.860
and then there's some convenient
versions of these like rotateX, rotateY.

00:30:27.860 --> 00:30:32.870
Now 3D is a little more complex.

00:30:32.870 --> 00:30:38.750
There's a little more setup you have to do to actually
make things look 3D and handle some other issues.

00:30:38.750 --> 00:30:42.820
So the first property here that we
added is one called "perspective."

00:30:42.820 --> 00:30:45.950
And this allows us to control a sense of depth in the scene.

00:30:45.950 --> 00:30:49.510
And you'll see that in a moment.

00:30:49.510 --> 00:30:56.330
The second one is useful - it's transform style --
is useful when you're building hierarchies of objects

00:30:56.330 --> 00:30:59.410
and you want them to live in a
common three-dimensional space.

00:30:59.410 --> 00:31:02.540
Transform style allows you to control
whether there's flattening

00:31:02.540 --> 00:31:05.930
or whether these things live in a common 3D space.

00:31:05.930 --> 00:31:10.960
And the other slightly odd thing with 3D transforms
is it's actually possible to flip an element

00:31:10.960 --> 00:31:13.540
around so you can see the reverse side of it.

00:31:13.540 --> 00:31:15.930
And sometimes you want that but sometimes you don't.

00:31:15.930 --> 00:31:22.210
So back face visibility allows you to hide things
if they've definitely flipped all the way around.

00:31:22.210 --> 00:31:26.610
So let's go back building a revolving
door effect using 3D transforms.

00:31:26.610 --> 00:31:32.260
Now the first thing to note here is that with the revolving
door effect, it's like the hinges are on the right,

00:31:32.260 --> 00:31:35.130
the elements are sort of swinging
around that right-hand edge.

00:31:35.130 --> 00:31:38.290
So there's a little bit of setup
we have to do to make that work.

00:31:39.910 --> 00:31:41.430
Now, she mentioned this in her session.

00:31:41.430 --> 00:31:49.270
You can control the transform origin, in other
words, where the origin of the transform is,

00:31:49.270 --> 00:31:51.320
and by default it's in the center of the element.

00:31:51.320 --> 00:31:55.630
So if we rotated the element, you
noticed it rotated around the center.

00:31:55.630 --> 00:31:58.760
We can use the transform origin property to change that.

00:31:58.760 --> 00:32:00.490
So here we've used right 50%.

00:32:00.490 --> 00:32:03.870
So that puts the transform origin on the right-hand edge.

00:32:03.870 --> 00:32:10.040
And you can use pixel values, percentages,
or the keywords for this property.

00:32:10.040 --> 00:32:17.080
So now when it rotates, it hinges about
that right edge, which is what we want.

00:32:17.080 --> 00:32:24.380
And then, just as before, we use these class
names to set up the initial and the final states.

00:32:24.380 --> 00:32:30.520
The incoming image is going to start basically
rotated into the screen from where the user is.

00:32:30.520 --> 00:32:34.890
So that uses a rotation about the
y-axis, which is the vertical axis

00:32:34.890 --> 00:32:37.880
of 90 degrees, which pushes it back into the screen.

00:32:37.880 --> 00:32:43.570
And then the final state of the incoming
image is just flat on rotateY at 0.

00:32:43.570 --> 00:32:50.580
And then the outgoing image, you can probably guess, starts
with the rotateY at 0 and then its final state is coming

00:32:50.580 --> 00:32:54.990
out of the screen towards us, which
is rotateY of minus 90 degrees.

00:32:54.990 --> 00:32:59.720
So if we actually put that together,
what would it look like?

00:32:59.720 --> 00:33:02.510
Well, the answer is actually like this.

00:33:02.510 --> 00:33:03.620
That was a revolving door.

00:33:03.620 --> 00:33:05.760
This is an attempt at doing the cube transition.

00:33:05.760 --> 00:33:09.670
And it looks very flat, you don't see any depth there.

00:33:09.670 --> 00:33:15.150
And the reason is, we haven't described
any sort of depth in this scene.

00:33:15.150 --> 00:33:20.230
So that's where we use this perspective
property that I mentioned before.

00:33:20.230 --> 00:33:28.760
And what perspective does is it controls effectively
how far away the viewer is from the plane of the screen.

00:33:28.760 --> 00:33:34.930
And the default value is NaN, which means the
viewer's infinitely far away, everything looks flat.

00:33:34.930 --> 00:33:40.990
Then as we start setting that to actual
values -- it's like 4,000 pixels --

00:33:40.990 --> 00:33:43.830
we start getting some amount of foreshortening in the scene.

00:33:43.830 --> 00:33:47.820
And as the perspective gets smaller,
we get more and more foreshortening.

00:33:47.820 --> 00:33:54.970
So it's as if you're getting closer and closer and
you've got really sort of wild 3D in this case.

00:33:54.970 --> 00:33:59.650
So here we add the perspective and we get a nice 3D effect.

00:33:59.650 --> 00:34:05.900
Now, there's one thing to note here, that perspective
is added on the photo container, not on the images.

00:34:05.900 --> 00:34:13.470
Perspective affects the rendering of child
elements that have transformed in 3D.

00:34:13.470 --> 00:34:19.250
Essentially, you can think of perspective as
setting up a 3D space for the elements underneath.

00:34:19.250 --> 00:34:25.550
So far, all of the transitions we've done
have been simple blends, if you like,

00:34:25.550 --> 00:34:27.730
between an initial state and a final state.

00:34:27.730 --> 00:34:31.500
We've got some really neat ones, including
3D, but they're all just simple blends.

00:34:31.500 --> 00:34:35.140
What if we want to do something a little
more complex, like this bats animation?

00:34:35.140 --> 00:34:41.150
Well, this is another use for keyframe animations.

00:34:41.150 --> 00:34:45.930
We saw a keyframe animation earlier because it gave us the
ability to have something that's continually repeating.

00:34:45.930 --> 00:34:49.620
In this case, we're going to use keyframe animations

00:34:49.620 --> 00:34:55.130
because they let us specify more
complex moves, using multiple keyframes.

00:34:55.130 --> 00:35:00.100
And just like transitions, keyframe
animations emit DOM events when they complete

00:35:00.100 --> 00:35:01.840
but also when they start and when they loop.

00:35:01.840 --> 00:35:05.700
So we can hook into the same event notifications
to know when our transitions are complete.

00:35:05.700 --> 00:35:13.950
So the actual properties, you've seen these already, the
@-WebKit-keyframes is where you set up the keyframes.

00:35:13.950 --> 00:35:20.210
And then this is the longhand property here, animation
name, which is where you actually apply those keyframes.

00:35:20.210 --> 00:35:26.200
One cycle of animation -- or duration of one cycle -- is
controlled by animation duration and the number of cycles

00:35:26.200 --> 00:35:31.540
by animation duration count and this has that key word
"infinite" if you want to just keep going on forever.

00:35:31.540 --> 00:35:36.660
And there's some other things you can do to control
the sort of behavior when the animation is repeating.

00:35:36.660 --> 00:35:41.760
You can have every other cycle of animation go backwards
to give you some interesting back and forth behavior.

00:35:41.760 --> 00:35:47.910
And then just like transitions, we
have an animation delay property.

00:35:47.910 --> 00:35:52.270
And we'll see a really neat use case for that in a moment.

00:35:52.270 --> 00:35:56.680
So let's build that drop animation using some keyframes.

00:35:56.680 --> 00:35:58.750
Here's the initial div.

00:35:58.750 --> 00:36:04.050
And I will set up these keyframes to describe the
states of the animation as the keyframe is running.

00:36:04.050 --> 00:36:08.980
Our initial state -- or our from state or 0%, same thing --

00:36:08.980 --> 00:36:14.860
is again, a translateY of -100%,
which puts the image above the box.

00:36:14.860 --> 00:36:20.430
And then at 70% of the way through the animation,
it has a translateY(0), so it's down in the box.

00:36:20.430 --> 00:36:23.950
And then this is how we do the little
bounce: we have an 83% keyframe that moves it

00:36:23.950 --> 00:36:28.360
up by 10% and then it falls down again to 0%.

00:36:28.360 --> 00:36:32.360
So that's enough to give us this nice little bounce effect.

00:36:32.360 --> 00:36:38.440
And here we apply those keyframes, we're using
the shorthand here, animation drop 1 second.

00:36:38.440 --> 00:36:40.820
So this is just going to run once over1 second.

00:36:40.820 --> 00:36:43.840
Note that we didn't change any
JavaScript, so we're still using

00:36:43.840 --> 00:36:49.240
that same JavaScript code you saw earlier in the session.

00:36:49.240 --> 00:36:53.130
So we've got these two types of animation:
we've got transitions and keyframe animations.

00:36:53.130 --> 00:36:57.120
And you're probably wondering why they
are two types and why isn't it just one?

00:36:57.120 --> 00:37:00.980
So let me compare these to explain the differences.

00:37:00.980 --> 00:37:05.550
Now the main difference is how they're triggered.

00:37:05.550 --> 00:37:13.520
You saw from the lightbox example that we got this
nice overlay fade by changing opacity from 0 to 1

00:37:13.520 --> 00:37:18.610
and because there was a transition rule in effect,
when the opacity changed, the transition ran.

00:37:18.610 --> 00:37:21.850
So transitions are triggered by changes
in the underlying property values.

00:37:21.850 --> 00:37:25.170
In other words, they run automatically but they're implicit.

00:37:25.170 --> 00:37:32.510
Keyframe animations, on the other hand, run when they're
applied explicitly, using the animation name property.

00:37:32.510 --> 00:37:39.040
So you put animation name on an element and as long as that
matches some keyframes, that element starts to animate.

00:37:39.040 --> 00:37:44.960
So the notion with keyframe animations is you're really
using CSS to put an element into an animating state.

00:37:44.960 --> 00:37:47.100
So that's quite different from transitions.

00:37:47.100 --> 00:37:54.910
Both of these use timing functions for animations or
keyframe animations; the time function is within keyframes.

00:37:54.910 --> 00:38:00.260
Of course, if you need keyframes, if you need
these more complex moves with multiple points

00:38:00.260 --> 00:38:02.490
in them, keyframe animations are the way to go.

00:38:02.490 --> 00:38:05.470
And they also allow you to have this repeating behavior,

00:38:05.470 --> 00:38:09.480
which we used for the spinning
indicator and alternating behavior.

00:38:09.480 --> 00:38:18.710
So far, the contents of our photo
gallery have just been images.

00:38:18.710 --> 00:38:22.260
But since these effects apply to any HTML element --

00:38:22.260 --> 00:38:26.400
and that include video, so we could put
video in our gallery if we wanted to.

00:38:26.400 --> 00:38:29.310
We actually will -- you'll see that in a demo in a minute.

00:38:29.310 --> 00:38:37.250
Or you could use SVG inside of HTML or Canvas or basically
any HTML content you can apply these CSS effects to.

00:38:37.250 --> 00:38:41.880
This gives you a lot of scope, a lot
of capabilities to do neat stuff.

00:38:41.880 --> 00:38:46.400
And actually, we're going to use
this now to create this tile effect.

00:38:46.400 --> 00:38:49.520
And I'll show you how to build this tile effect.

00:38:49.520 --> 00:38:53.770
But here effectively what we're doing
is where we had a single image before,

00:38:53.770 --> 00:39:00.560
we're going to replace that with a little subtree
of nodes, using divs, to give us the tile effect.

00:39:00.560 --> 00:39:08.170
So the way we create these tile effects
are to build a div and we're going to call

00:39:08.170 --> 00:39:11.970
that "tile container" just so we can style it.

00:39:11.970 --> 00:39:17.610
And tile container is the container for this grid of tiles.

00:39:17.610 --> 00:39:20.440
So each of these is a div itself.

00:39:20.440 --> 00:39:27.570
And then the way we tessellate them to
make it look like they're a single image is

00:39:27.570 --> 00:39:32.600
to use background position and to set a background image.

00:39:32.600 --> 00:39:38.210
And so we use background position to make sure that
the right part of the image is rendered into each tile.

00:39:41.330 --> 00:39:44.710
So this is a kind of thing you
could do in mock-up if you wanted --

00:39:44.710 --> 00:39:49.900
you could have 16 or 24 tiles as divs in your HTML content.

00:39:49.900 --> 00:39:53.920
But this type of repetitive stuff is much
better done with little bit of JavaScript.

00:39:53.920 --> 00:39:57.140
So this is the script you would
write to generate these tiles.

00:39:57.140 --> 00:40:03.650
So we're just iterating through the rows and
columns and for each tile, creating a div element.

00:40:03.650 --> 00:40:08.730
And then we compute whether elements positioned inside
the grid based on the row and column and the tile height

00:40:08.730 --> 00:40:11.390
and the tile width, which we know in advance.

00:40:11.390 --> 00:40:15.220
And then the tiles are absolutely positioned
so we can position very easily to form a grid

00:40:15.220 --> 00:40:18.330
and we do that by setting the left and top properties.

00:40:18.330 --> 00:40:22.570
And then here's the key to make
it look like it's a single image.

00:40:22.570 --> 00:40:27.610
We set the background image property, and here I've used
a hard-coded image but you probably use the next image

00:40:27.610 --> 00:40:30.160
in your slide show, which you'd feed into this function.

00:40:30.160 --> 00:40:37.560
And then you set the background image property to
minus tileX, minus tileY and that gets the correct part

00:40:37.560 --> 00:40:40.080
of the image rendered into this particular tile.

00:40:40.080 --> 00:40:45.580
So the next thing we do -- we've got this grid of tiles --

00:40:45.580 --> 00:40:48.700
we want to cause these tiles to
animate in some interesting way.

00:40:48.700 --> 00:40:52.240
And in this case we'll use a drop animation,
which is very similar to the one we just saw.

00:40:52.240 --> 00:40:58.030
But before we were running it on a single image;
here it's running on each individual tile.

00:40:58.030 --> 00:41:00.250
So this is the same set of keyframes.

00:41:00.250 --> 00:41:03.480
There's a slight difference here,
which is they've both added opacity.

00:41:03.480 --> 00:41:07.610
So here opacity is going to animate
between the 0% and 70% keyframes.

00:41:07.610 --> 00:41:11.520
This just shows you that it's possible to animate
multiple properties inside of keyframes --

00:41:11.520 --> 00:41:13.620
you're not limited to animating just one.

00:41:13.620 --> 00:41:18.440
And then here's where we apply the animation.

00:41:18.440 --> 00:41:23.260
The selector's a little more complex because we have
to apply this to the divs, which are direct children

00:41:23.260 --> 00:41:26.230
of the tile container when the tile
container's in the incoming state.

00:41:26.230 --> 00:41:33.350
So if we actually did that, this is what it would look like.

00:41:33.350 --> 00:41:34.630
And we didn't see any tiles.

00:41:34.630 --> 00:41:35.060
You know, what's up?

00:41:35.060 --> 00:41:38.430
Well, we've got this grid of tiles but
they're all animating at the same time,

00:41:38.430 --> 00:41:40.910
they're all in synchrony, so they just fall down as a block.

00:41:40.910 --> 00:41:42.340
And that doesn't really look very interesting.

00:41:42.340 --> 00:41:45.990
So we can add one more line to our JavaScript loop.

00:41:45.990 --> 00:41:51.290
And that line is going to set animation delay.

00:41:51.290 --> 00:41:57.060
So just as in the previous session, you saw a use
of transition delay that causes menus to build in;

00:41:57.060 --> 00:42:01.660
here we set animation delay to cause things
to happen at slightly different times.

00:42:01.660 --> 00:42:05.260
And we're making use of Math.random,
which is a JavaScript function

00:42:05.260 --> 00:42:08.000
that gives you back a random number between 0 and 1.

00:42:08.000 --> 00:42:14.640
So this sets animation delay to somewhere between
0 and 1 second, independently for each tile.

00:42:14.640 --> 00:42:17.450
So now when we run the transition,
we get this really cool effect.

00:42:17.450 --> 00:42:28.830
So just to summarize what we've learned from this tile
effect stuff: we can replace the single image in our gallery

00:42:28.830 --> 00:42:34.440
with a grid of tile elements or a grid of divs representing
tiles, and use background image and background position

00:42:34.440 --> 00:42:37.400
to have each tile render the right part of the image.

00:42:37.400 --> 00:42:39.800
And then we see how useful delays are.

00:42:39.800 --> 00:42:42.730
In the previous session, you saw
transition delay being put to good use

00:42:42.730 --> 00:42:45.890
and here animation delay is really great
for doing these neat build effects.

00:42:45.890 --> 00:42:52.560
So at this point, I'd like to invite
Enrica back to show you the gallery

00:42:52.560 --> 00:43:01.960
that we got when we put all of this stuff together.

00:43:01.960 --> 00:43:02.070
[ Applause ]

00:43:02.070 --> 00:43:03.080
>> Enrica Casucci: Hi again.

00:43:03.080 --> 00:43:08.380
So we're back to our photo gallery example
that we have seen before on my iPad.

00:43:08.380 --> 00:43:12.520
But this time we're going to make a look at it from a Mac.

00:43:12.520 --> 00:43:22.500
So here is a photo gallery and you've just learned
from Simon how easy it is to combine CSS transforms

00:43:22.500 --> 00:43:26.580
and animations to create a series of amazing effects.

00:43:26.580 --> 00:43:37.260
And you know, we have seen how easy it is to create a
crossfade, a push, or a push down, scale transforms.

00:43:37.260 --> 00:43:46.720
I want you to really appreciate, in this case we are using
larger images than the ones we have used for the iPad demo.

00:43:46.720 --> 00:43:52.910
And notice how smooth the transition
is, even with these larger images.

00:43:56.210 --> 00:44:04.780
But what really makes a difference is when you start using
the 3D transforms because not only you create, you know,

00:44:04.780 --> 00:44:15.340
some very cool effects like this one, but it also opens
up a world of possibilities in terms of what you can do

00:44:15.340 --> 00:44:19.370
to present additional content that
is related to your images.

00:44:19.370 --> 00:44:25.730
Let's say for example you want to show some
text or date associated with the picture.

00:44:25.730 --> 00:44:31.160
And so why not simply flip the
image on the back and show it?

00:44:31.160 --> 00:44:32.290
Isn't that cool?

00:44:32.290 --> 00:44:37.210
[ Applause ]

00:44:37.210 --> 00:44:42.260
We've seen the revolving door, the swap, and the cube.

00:44:42.260 --> 00:44:46.870
And remember, all these transitions
that we have seen up to this point,

00:44:46.870 --> 00:44:52.290
they all use the same JavaScript;
we've only changed the CSS.

00:44:52.290 --> 00:45:02.350
And as Simon mentioned, with HTML5, video elements
have become first-class citizens in the web world.

00:45:02.350 --> 00:45:07.750
So all these effects that we have seen apply
to images can be applied to video elements

00:45:07.750 --> 00:45:12.340
as well, and we can have something like this.

00:45:12.340 --> 00:45:14.200
Notice that the video is playing.

00:45:14.200 --> 00:45:20.520
I can still flip it on the back and show my additional
information while the video is still playing.

00:45:20.520 --> 00:45:26.180
[ Applause ]

00:45:26.180 --> 00:45:31.240
Look, now that I'm showing you the transition
in slow motion that you can really appreciate

00:45:31.240 --> 00:45:35.400
that the video is playing while
the transition is taking place.

00:45:35.400 --> 00:45:38.010
I think this is absolutely awesome.

00:45:38.010 --> 00:45:49.570
Then with a little bit of JavaScript, you can easily
create this fantastic tiling effect that you have seen.

00:45:49.570 --> 00:45:56.820
And, you know, this is just a combination of rotation
with the same technique you have seen before.

00:45:56.820 --> 00:46:01.590
But now that you know how to slice
up the images, the sky's the limit.

00:46:01.590 --> 00:46:14.030
You can create unfolding effects like this one or this one
that you got a sneak preview before or something like this.

00:46:14.030 --> 00:46:17.020
This is when you're supposed to do "Wow."

00:46:17.020 --> 00:46:22.570
[ Applause ]

00:46:22.570 --> 00:46:29.230
Let me show it to you one more time in slow motion so
you can fully appreciate how smooth the transition is.

00:46:29.230 --> 00:46:30.340
>> Wow.

00:46:30.340 --> 00:46:30.980
>> Enrica Casucci: Thank you.

00:46:30.980 --> 00:46:34.790
That's what I wanted to hear.

00:46:34.790 --> 00:46:37.340
[ Laughter ]

00:46:37.340 --> 00:46:39.890
[ Applause ]

00:46:39.890 --> 00:46:44.610
I hope at this point I got you
all fired up and I hope I was able

00:46:44.610 --> 00:46:47.950
to communicate the excitement I have for this technology.

00:46:47.950 --> 00:46:56.350
We have some great labs tomorrow and we hope to see you all
there and come over and start playing with our sample code.

00:46:56.350 --> 00:46:58.290
I'll give you back to Simon.

00:46:58.290 --> 00:46:59.570
That is going to wrap up the session.

00:46:59.570 --> 00:47:00.020
Thank you.

00:47:00.020 --> 00:47:00.080
[ Applause ]

00:47:00.080 --> 00:47:02.110
>> Simone Fraser: Thank you, Enrica.

00:47:02.110 --> 00:47:06.990
I think that really was an awesome photo gallery.

00:47:06.990 --> 00:47:11.610
So let me just take a moment to summarize
where these things are supported.

00:47:11.610 --> 00:47:21.400
So I talked about four categories of CSS effects today:
2D transforms, 3D transforms, transitions, and animations.

00:47:21.400 --> 00:47:28.740
And all of these are supported on
iPhone and iPad since iPhone 2.0.

00:47:28.740 --> 00:47:33.490
Safari on Mac has supported all of these
since Safari 4 and now with Safari 5,

00:47:33.490 --> 00:47:36.120
we have support across the board on Mac and Windows.

00:47:36.120 --> 00:47:41.380
And then Chrome supports these;
they don't have 3D rendering.

00:47:41.380 --> 00:47:46.470
And some of the other browsers are catching up too, now
-- Opera and Firefox have 2D transforms and transitions.

00:47:46.470 --> 00:47:53.270
So let me summarize what we've learned in today's session.

00:47:53.270 --> 00:48:00.260
First of all, using CSS transitions and animations, you can
get really neat animations with very little authoring work.

00:48:00.260 --> 00:48:06.330
In many cases, it's just one line of CSS to go
from a jarring transition to a nice, smooth one.

00:48:06.330 --> 00:48:11.970
And you can get great performance
even on devices like iPhone and iPad.

00:48:11.970 --> 00:48:14.830
And you'll get generally much better
performance than you would if you used one

00:48:14.830 --> 00:48:18.250
of the JavaScript libraries that's running
JavaScript time as to do animation.

00:48:18.250 --> 00:48:25.970
And then with CSS transforms, we can position elements and
transform them both in two dimensions and three dimensions.

00:48:25.970 --> 00:48:30.910
And as Enrica mentioned, this opens all sorts of
possibilities for interesting ways of user interaction,

00:48:30.910 --> 00:48:34.450
flipping things around, building
things like cubes and rings.

00:48:34.450 --> 00:48:38.740
And you've probably seen a bunch of examples
and there's a lot of sample code for this.

00:48:38.740 --> 00:48:42.110
But another great thing about animations
-- sorry, about transforms --

00:48:42.110 --> 00:48:46.090
is that they work very well with transitions and animations.

00:48:46.090 --> 00:48:50.180
By running transitions between
different types of 3D transforms,

00:48:50.180 --> 00:48:54.050
you can get all sorts of really cool effects
and the animations run really smoothly.

00:48:54.050 --> 00:48:58.790
So there's a great synergy between these two things.

00:48:58.790 --> 00:49:03.270
And finally, not just images but as you saw,
we can have great performance running these

00:49:03.270 --> 00:49:08.080
on video as well and any other HTML element.

00:49:08.080 --> 00:49:13.330
So for more information, you can contact Vicki
Murley, the Safari Technologies Evangelist.

00:49:13.330 --> 00:49:16.710
And there's great documentation on the Safari Dev Center.

00:49:16.710 --> 00:49:21.440
If you want to go and look at the CSS specifications
and follow the workings of the CSS working group,

00:49:21.440 --> 00:49:23.210
you can look at the current work page there.

00:49:23.210 --> 00:49:27.220
And then the Apple developer forums are
another great place to go and get help.

