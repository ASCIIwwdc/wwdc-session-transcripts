WEBVTT

00:00:07.020 --> 00:00:08.740
>> Stuart Cheshire: Good morning ladies and gentlemen.

00:00:08.740 --> 00:00:10.490
It's good to see you all here today.

00:00:10.490 --> 00:00:14.350
My name is Stuart Cheshire and I'm the architect of Bonjour.

00:00:14.350 --> 00:00:21.820
I'm going to be telling you today about Bonjour
and related technologies and particularly

00:00:21.820 --> 00:00:24.700
about how it interacts with multitasking on iOS 4.

00:00:24.700 --> 00:00:30.330
Let me ask how many people are here at their first WWDC.

00:00:30.330 --> 00:00:33.410
Can I see a show of hands?

00:00:33.410 --> 00:00:34.510
That is amazing.

00:00:34.510 --> 00:00:36.410
That's more than half the room.

00:00:36.410 --> 00:00:41.400
And how many are here for the first
time at a Bonjour presentation.

00:00:41.400 --> 00:00:49.270
OK. Then I'm glad we have some overview because this is the
first time for I'd say about 80% of the people in the room.

00:00:49.270 --> 00:00:54.830
In previous years, what I'm going to talk about is the
overview would have been the entire hour-long presentation.

00:00:54.830 --> 00:01:00.800
We have a lot more stuff to talk about today so it's going
to be very condensed but I hope it'll give you the flavor

00:01:00.800 --> 00:01:07.430
of what it's about and at least point you in the right
direction for more documentation to find out more details.

00:01:08.610 --> 00:01:16.840
Rory McGuire, my colleague will be telling you about some
specific details of Bonjour on iPhone OS and will be talking

00:01:16.840 --> 00:01:21.350
about some other developments because
Bonjour is not just a Mac technology.

00:01:21.350 --> 00:01:23.570
It's not just an Apple technology.

00:01:23.570 --> 00:01:28.430
We have Bonjour on Windows and there are many
third party products using Bonjour as well.

00:01:28.430 --> 00:01:29.760
It is an open standard.

00:01:29.760 --> 00:01:35.890
The source code is open source under the Apache
2 license and all the specifications of public.

00:01:35.890 --> 00:01:41.810
We'll wrap up with some tips and reminders
of common mistakes that which developers make

00:01:41.810 --> 00:01:44.670
so that you can avoid making the same mistakes.

00:01:47.360 --> 00:01:50.490
So let's start with the high level goal.

00:01:50.490 --> 00:01:58.310
TCP/IP, the technology of the internet clearly won out
against all the other wide area of technologies like DECnet

00:01:58.310 --> 00:02:06.920
and XNS, X.25, ISDN and it was a great
achievement to build a global scale network.

00:02:06.920 --> 00:02:11.450
But where it lacked was ease of
use and the canonical example I

00:02:11.450 --> 00:02:16.360
like to give is you take a USB printer,
you take the cable, you plug it in.

00:02:16.360 --> 00:02:22.230
Nobody has to type addresses and subnet masks and
configuration parameters to make that USB work.

00:02:22.230 --> 00:02:26.880
And there's no technical reason why
IP can't be just as easy as that.

00:02:26.880 --> 00:02:32.350
The only reason is that all the people working on it
in the early days were so focused on the challenge

00:02:32.350 --> 00:02:39.520
of building a global network to rival the telephone system
that they totally neglected worrying about the details

00:02:39.520 --> 00:02:43.310
of two computers connected with a cable
because that seems so trivial in comparison.

00:02:43.310 --> 00:02:51.420
What we did with Bonjour and zero configuration
networking is to go back and fill in that missing piece.

00:02:51.420 --> 00:02:55.420
So when you're designing your application
or your hardware product,

00:02:55.420 --> 00:02:59.750
if you have any doubts about a certain
design decision, kind of mentally think,

00:02:59.750 --> 00:03:01.910
if I plug it into USB, what would I expect.

00:03:01.910 --> 00:03:08.420
We would like the same user experience with an Ethernet
cable or with Wi-Fi or with IP or with Bluetooth.

00:03:08.420 --> 00:03:12.440
So that's the goal.

00:03:12.440 --> 00:03:15.530
We want networking where you just plug it and it works.

00:03:15.530 --> 00:03:17.800
This is how we achieve that goal.

00:03:17.800 --> 00:03:25.300
And there are three legs of technology that make up the
foundation for Bonjour, zero configuration networking

00:03:25.300 --> 00:03:33.900
and that foundation is what lets you developers write
applications where you can rely on networking being present

00:03:33.900 --> 00:03:39.710
and functional and not have to worry about
a lot of failure modes that you used to have

00:03:39.710 --> 00:03:42.490
and I'll start up with one of those failure modes.

00:03:42.490 --> 00:03:44.080
DHCP is great.

00:03:44.080 --> 00:03:51.550
We are not competing with DHCP at all and if you have a DHCP
server on the network handing out addresses, that's great.

00:03:51.550 --> 00:03:58.310
But if you don't, if you just have two devices connected
with an Ethernet cable or some devices connected

00:03:58.310 --> 00:04:02.230
to a simple Ethernet switch, then there's no DHCP server.

00:04:02.230 --> 00:04:05.390
And in the past, most devices would just give up.

00:04:05.390 --> 00:04:11.050
So you can't find DHCP server and refuse
to work until the user fix the problem.

00:04:11.050 --> 00:04:16.920
Now for desktop computer with a screen and a
keyboard, that's annoying but it's not fatal

00:04:16.920 --> 00:04:19.110
because the user can configure a manual address.

00:04:19.110 --> 00:04:25.500
But for devices that don't have a screen and a keyboard,
for device like an AirPort Extreme Base Station

00:04:25.500 --> 00:04:30.390
where it's only user interface for
controlling it is over the network.

00:04:30.390 --> 00:04:32.400
It has got to get itself on the network.

00:04:32.400 --> 00:04:35.350
Because if its network is misconfigured
so it can't communicate,

00:04:35.350 --> 00:04:38.430
you have no way of communicating with it to fix that.

00:04:38.430 --> 00:04:41.200
So IPv6 has link-local addressing.

00:04:41.200 --> 00:04:47.900
Every IPv6 device configures itself a link-local address
on every interface which is not configured by the user.

00:04:47.900 --> 00:04:55.040
The user can't break that so you can rely
on it to have an address and with RC3927,

00:04:55.040 --> 00:05:00.010
we have the same thing in IPv4
and you've probably seen this now.

00:05:00.010 --> 00:05:00.940
This is not new.

00:05:00.940 --> 00:05:03.760
Ten years ago when we're talking about this, this was new.

00:05:03.760 --> 00:05:07.820
These days everyone in the room is probably
familiar with those addresses 169.254

00:05:07.820 --> 00:05:13.830
and that means the machine picked its own address because
it couldn't find the DHCP server to give it another address.

00:05:13.830 --> 00:05:15.320
So this is a good start.

00:05:15.320 --> 00:05:20.640
We can have two or three or five machines
all with self-assigned unique addresses

00:05:20.640 --> 00:05:23.000
but it doesn't really help you if
you don't know what the address is

00:05:23.000 --> 00:05:27.090
and nobody likes typing addresses especially IPv6 addresses.

00:05:27.090 --> 00:05:31.800
With conventional IP, people are
used to using DNS host names.

00:05:31.800 --> 00:05:38.270
So following a similar principle that we want to
stay as close as possible to our current practices,

00:05:38.270 --> 00:05:45.070
we use Multicast DNS which uses the same naming syntax,
the same record types, the same resource record types

00:05:45.070 --> 00:05:49.530
and the same packet format of standard
DNS but without a central server.

00:05:49.530 --> 00:05:53.210
And every device on the network has a piece of software

00:05:53.210 --> 00:05:57.690
which is the Multicast DNS responder
which knows that device its own name.

00:05:57.690 --> 00:06:01.160
And when the client multicast a
query to every device on the network,

00:06:01.160 --> 00:06:06.530
the one that recognizes its name says,
hey, that's me and it answers the query.

00:06:06.530 --> 00:06:08.770
Now that's good.

00:06:08.770 --> 00:06:14.080
That's got us to parity with what people expected of the
internet 10 years ago but you still have to know the name

00:06:14.080 --> 00:06:18.170
to type and if you type it wrong, it
doesn't work and you don't really know why.

00:06:18.170 --> 00:06:22.180
So we wanted to go one step beyond that
and that's the third item on this list

00:06:22.180 --> 00:06:25.230
of technologies and that's service discovery.

00:06:25.230 --> 00:06:31.200
Building on the Multicast DNS mechanisms, we
can also multicast queries to the network.

00:06:31.200 --> 00:06:34.010
Not for specific host name but for type of service.

00:06:34.010 --> 00:06:36.030
Say, I want to print.

00:06:36.030 --> 00:06:39.370
What devices out there can meet that need for me?

00:06:39.370 --> 00:06:45.010
What printers are out there that I can turn a printer up
too that results in sheets of printed paper coming out.

00:06:45.010 --> 00:06:50.850
And that service discovery is the
third leg and that's the level that you

00:06:50.850 --> 00:06:53.620
as developers will generally be interacting with this.

00:06:53.620 --> 00:06:59.770
Because the addressing is handled by the OS, so unless
you're building hardware devices, you don't need to do that

00:06:59.770 --> 00:07:03.670
and the host name lookup is an OS level function.

00:07:03.670 --> 00:07:11.060
But if you are offering services on the network and
that means if you have a socket that's listening

00:07:11.060 --> 00:07:16.910
or if you're making connections on the network, you'll
want to interact with the service discovery APIs

00:07:16.910 --> 00:07:24.340
that Bonjour provides on the Mac, on
iOS, on Windows and on other platforms.

00:07:24.340 --> 00:07:28.150
So here's an overview.

00:07:28.150 --> 00:07:31.270
You have a piece of software that's
listening for connections.

00:07:31.270 --> 00:07:37.180
That's great and you can make the user write down
the port number on a post-it note but it's better

00:07:37.180 --> 00:07:41.190
to use the technology we have to
advertise that fact on the network.

00:07:41.190 --> 00:07:46.330
When your service starts up or when the machine
wakes from sleep or when you connect the network,

00:07:46.330 --> 00:07:51.360
it sends out a couple of announcement packets to let clients

00:07:51.360 --> 00:07:53.870
that may be listening know that
this service is now on the network.

00:07:53.870 --> 00:07:59.230
Now it's not continuously broadcasting its pockets
because that would add up to a lot of wasted bandwidth

00:07:59.230 --> 00:08:02.960
but it does send out a few packets on startup.

00:08:02.960 --> 00:08:06.620
Now suppose a client comes along
and were looking for that service.

00:08:06.620 --> 00:08:15.140
The client will do a browse operation and these
APIs were available in C and in Cocoa and in Java,

00:08:15.140 --> 00:08:20.950
in different languages, but they all have the
common property that you browse the services

00:08:20.950 --> 00:08:24.860
and the server responds if it has
an instance of that service type.

00:08:24.860 --> 00:08:30.430
So this lets the client build a list to
present to the user so the user can pick

00:08:30.430 --> 00:08:33.380
which particular instance they want to connect to.

00:08:33.380 --> 00:08:39.980
And then the second step is resolving that name
service to get the current IP address and port number

00:08:39.980 --> 00:08:45.240
where that service can be reached and this
is a very important point with Bonjour.

00:08:45.240 --> 00:08:50.530
Browsing and resolving are separate, other service
discovery protocols didn't make this separation

00:08:50.530 --> 00:08:57.580
and the reason it's important is because, I'll
go back to the familiar example of printing.

00:08:57.580 --> 00:09:01.380
Browsing the network defined which printers
are available and picking the one you're going

00:09:01.380 --> 00:09:04.000
to use most of time is your default prints out.

00:09:04.000 --> 00:09:06.980
It's an operation that people do relatively infrequently.

00:09:06.980 --> 00:09:08.720
Some people may only do it once a year.

00:09:08.720 --> 00:09:12.290
They pick a printer and then they don't change it at work.

00:09:12.290 --> 00:09:20.220
But with DHCP, with link-local addressing, addresses and
ports can change overtime and if your printer preferences

00:09:20.220 --> 00:09:24.210
on your machine have stored the address and
port number, that might not work tomorrow.

00:09:24.210 --> 00:09:26.990
But the names are stable overtime.

00:09:26.990 --> 00:09:32.530
So by storing the name and then resolving on
use, you get the current address information.

00:09:32.530 --> 00:09:35.810
So this is very important, we'll come back to this later.

00:09:35.810 --> 00:09:42.420
Browse to show the use of the list but then resolve a
connection time to find the most up-to-date information.

00:09:42.420 --> 00:09:46.630
That was on the local network.

00:09:46.630 --> 00:09:49.270
One of the questions we knew that would come up is,

00:09:49.270 --> 00:09:54.380
well this is great on the local link
but what about across the internet.

00:09:54.380 --> 00:10:01.850
What if I'm behind the NAT Gateway and the
answer is the same Bonjour APIs that work

00:10:01.850 --> 00:10:08.000
with link-local Multicast DNS also work with
wide area Bonjour and the area where most

00:10:08.000 --> 00:10:14.160
of you are probably most familiar with this, is this is the
underlying technology between Back to My Mac in MobileMe.

00:10:14.160 --> 00:10:20.910
So when you're using screen sharing and file sharing to
access your machine across the other side of the country,

00:10:20.910 --> 00:10:26.780
it's wide area Bonjour and the standard Bonjour APIs that
are doing that for you and if you have an application

00:10:26.780 --> 00:10:29.500
that registers with Bonjour and browses with Bonjour,

00:10:29.500 --> 00:10:34.820
then your application will work
planet-wide using Back to My Mac as well.

00:10:34.820 --> 00:10:36.430
It's not just screen sharing and file sharing.

00:10:36.430 --> 00:10:40.950
It supports all of your apps as well.

00:10:40.950 --> 00:10:42.750
This is the API architecture.

00:10:42.750 --> 00:10:51.080
On top of the kernel, we have a daemon called
mDNSResponder running and clients talk to that daemon

00:10:51.080 --> 00:10:54.320
to advertise services and browse the services.

00:10:54.320 --> 00:11:01.340
There are three main levels of API here not counting
Java and Python and Ruby and some of the other languages.

00:11:01.340 --> 00:11:06.140
There's the dns_sd.h which is the
low-level C programming API.

00:11:06.140 --> 00:11:12.050
That's available on Mac, Linux, Windows and on the iPhone.

00:11:12.050 --> 00:11:18.210
The next level up is core foundation
CFNetServices and the highest layer is NSNetServices

00:11:18.210 --> 00:11:21.020
which is the foundation layers used by Cocoa.

00:11:21.020 --> 00:11:26.980
And for most of you in this room doing iOS development,
you'll probably be working at the NSNetServices layer

00:11:26.980 --> 00:11:29.930
but they are all available on the iPhone.

00:11:29.930 --> 00:11:34.190
So if you got existing code, you can still use that.

00:11:34.190 --> 00:11:42.520
So Bonjour started off as replacing the AppleTalk
Chooser to define what's on the local network.

00:11:42.520 --> 00:11:46.100
But when you use the Bonjour APIs
you get a lot more than that.

00:11:46.100 --> 00:11:48.300
I've talked about discovering local things.

00:11:48.300 --> 00:11:51.520
I've talked about discovering remote
things by Back to My Mac.

00:11:51.520 --> 00:11:55.110
I'm going to tell you about discovering
devices that may be asleep.

00:11:55.110 --> 00:11:58.930
This is the new feature we introduced with
Snow Leopard, we talked about last year.

00:11:58.930 --> 00:12:01.630
I'll give a little recap of that now.

00:12:01.630 --> 00:12:09.750
And we keep inventing new communication technologies
and they come along with their own sets of APIs

00:12:09.750 --> 00:12:16.880
and their own addressing syntax and their own model for how
they work and that can be a burden for developers to have

00:12:16.880 --> 00:12:19.230
to keep supporting whatever the new thing is.

00:12:19.230 --> 00:12:22.790
So one of the great things I was
very excited about last year

00:12:22.790 --> 00:12:29.010
with iPhone OS 3 is peer-to-peer Bonjour over Bluetooth.

00:12:29.010 --> 00:12:30.610
So you don't have to pair Bluetooth.

00:12:30.610 --> 00:12:31.880
You don't have to configure it.

00:12:31.880 --> 00:12:35.420
You don't have to set up the Bluetooth
panel, configure the IP addresses.

00:12:35.420 --> 00:12:41.590
You just use the Bonjour APIs and when you're resolved,
we will actually bring up an IP network over Bluetooth

00:12:41.590 --> 00:12:44.980
on demand and then connect you to the other device.

00:12:44.980 --> 00:12:48.330
And this is what's used by the Game Kit on iPhone.

00:12:48.330 --> 00:12:52.780
But it's actually implemented as a Bonjour function
so all of your Bonjour apps get this for free as well.

00:12:52.780 --> 00:12:56.940
So let's talk about the sleeping case.

00:12:56.940 --> 00:13:03.300
Suppose I've got a USB printer plugged
into my Mac with printer sharing

00:13:03.300 --> 00:13:05.690
and this is great because I can print remotely.

00:13:05.690 --> 00:13:09.070
I can be sitting on the sofa with my laptop and I can print.

00:13:09.070 --> 00:13:12.360
But not if the computer is asleep.

00:13:12.360 --> 00:13:14.060
Back to My Mac, similar story.

00:13:14.060 --> 00:13:17.790
I can get to my computer remotely but not if it's asleep.

00:13:17.790 --> 00:13:27.010
Apple TV can access music and movies and photos of my
iTunes music collection on my iMac but not if it's asleep.

00:13:27.010 --> 00:13:33.430
So on the one hand, customers want to put their machines to
sleep so they're not wasting energy but on the other hand,

00:13:33.430 --> 00:13:39.240
we keep providing useful services to them that mean
they want to keep the machine awake and we wanted

00:13:39.240 --> 00:13:46.770
to resolve this tension and make it so that you can have
the best of both worlds and that's the Bonjour Sleep Proxy.

00:13:46.770 --> 00:13:52.220
The Bonjour Sleep Proxy runs on AirPort Base Stations.

00:13:52.220 --> 00:13:59.300
It runs on Apple TV because that's the device that's always
on, on your network and doesn't take very much power.

00:13:59.300 --> 00:14:03.460
If you're running internet sharing on your
Mac, then that will also act as a sleep proxy.

00:14:03.460 --> 00:14:09.660
Basically, any device that doesn't take much power
that's always on is a great candidate for a sleep proxy.

00:14:09.660 --> 00:14:13.440
It's open source so anybody can make
these but for most of you in the room,

00:14:13.440 --> 00:14:16.880
I'm guessing your AirPort Base
Station is going to be your proxy.

00:14:16.880 --> 00:14:23.650
When the Mac goes to sleep, it takes its Bonjour
service records and ships them in a packet to the proxy.

00:14:23.650 --> 00:14:29.490
Because those service records are a compact
representation of its role on the network, what its name is,

00:14:29.490 --> 00:14:34.730
what its address is, what services it offers, what
ports it's listening on, it takes all that information

00:14:34.730 --> 00:14:41.650
and ships it to the proxy and says this is me, I'm
going to sleep now, wake me up if anybody wants me.

00:14:41.650 --> 00:14:50.840
The iMac goes to sleep and the proxy sends out some proxy
out packets to say, I am now temporarily responsible

00:14:50.840 --> 00:14:55.260
for this IP address because I'm
proxying for the device that's asleep.

00:14:55.260 --> 00:14:59.080
Now on my other machine, I have
a document that I want to print.

00:14:59.080 --> 00:15:05.150
So it looks up the address and port, find the Bonjour result

00:15:05.150 --> 00:15:11.790
and it opens a TCP connection and
that TCP SYN goes to the proxy.

00:15:11.790 --> 00:15:17.600
Because the proxy is currently the owner of that IP address.

00:15:17.600 --> 00:15:25.470
The proxy inspects that packet and decides that this is
something that warrants waking up the sleeping machine.

00:15:25.470 --> 00:15:31.070
So it sends a wake-up-packet and the machine wakes up.

00:15:31.070 --> 00:15:37.220
It reclaims its IP address, TCP in the normal course
of operation will retransmit the packet which now goes

00:15:37.220 --> 00:15:43.220
to the newly awakened machine and
the document successfully prints.

00:15:43.220 --> 00:15:46.840
Many of you may have had this happen
without even realizing it

00:15:46.840 --> 00:15:52.500
because like all good networking technologies,
it's frequently completely invisible.

00:15:52.500 --> 00:15:53.840
You notice it when it fails.

00:15:53.840 --> 00:15:58.330
If you hit command-P and the document doesn't print
and you kind of curse, oh my, My Mac has gone to sleep,

00:15:58.330 --> 00:16:00.970
let me get up and wake it up, then you notice it.

00:16:00.970 --> 00:16:07.030
But if you hit Print and the page comes out, you may
never have even realized that your machine was asleep.

00:16:07.030 --> 00:16:10.170
It woke up to print the document
and then it went back to sleep.

00:16:10.170 --> 00:16:13.980
And this is really rewarding when
networking technology works that well.

00:16:13.980 --> 00:16:18.130
It can also be a little bit disappointing
that we're doing all this work

00:16:18.130 --> 00:16:20.300
to make this magic work and nobody even notices.

00:16:20.300 --> 00:16:20.810
[ Laughter ]

00:16:20.810 --> 00:16:27.190
So it's printed the document, my machine goes back to sleep.

00:16:27.190 --> 00:16:33.890
That was in the case where the client already knows about
the printer because I've set it up as my default printer

00:16:33.890 --> 00:16:40.030
but because of Bonjour service advertising, a friend
could come and visit my house with a laptop computer

00:16:40.030 --> 00:16:42.290
and they've never been on my network before.

00:16:42.290 --> 00:16:48.760
They've never used my printer before but when they do
Bonjour browsing operation, the proxy responds on behalf

00:16:48.760 --> 00:16:52.800
of the sleeping machine saying there's a
printing service on this network and it does

00:16:52.800 --> 00:16:55.020
that without even having to wake the machine.

00:16:55.020 --> 00:17:01.790
So unlike other Wake-on-LAN technologies
that have been around for a few years,

00:17:01.790 --> 00:17:04.380
you don't need manual setup in advance to configure this.

00:17:04.380 --> 00:17:10.510
You can walk into a network you've never been on before and
still discover services even on machines that are asleep.

00:17:10.510 --> 00:17:15.040
[ Pause ]

00:17:15.040 --> 00:17:20.380
Bonjour sleep proxy works with any
application that uses the Bonjour APIs.

00:17:20.380 --> 00:17:22.290
So we use it for printer sharing.

00:17:22.290 --> 00:17:27.060
We use it for Apple TV accessing iTunes.

00:17:27.060 --> 00:17:31.200
Even outside the house, if you want to get
back to your Mac at home and the Mac's asleep,

00:17:31.200 --> 00:17:34.820
the base station will wake it up
when an incoming connection comes in.

00:17:34.820 --> 00:17:40.460
With command-line ssh, this is not something that
normal users use but the developers tend to love this.

00:17:40.460 --> 00:17:47.300
You can be logged in to a machine with ssh and when you're
finished doing what you're doing, type pmset sleepnow

00:17:47.300 --> 00:17:51.350
and the machine will go to sleep
without losing your TCP connection.

00:17:51.350 --> 00:17:55.240
Sometime later, you type in that window,
first keystroke, the machine wakes back up,

00:17:55.240 --> 00:17:57.080
does what you want, put it back to sleep again.

00:17:57.080 --> 00:18:02.680
You can keep your connection open for days or weeks at
a time to a machine that will sleep and wake on demand

00:18:02.680 --> 00:18:08.030
and it doesn't have to awake consuming power 24 hours a
day bust because you've got an ssh log into that machine.

00:18:08.030 --> 00:18:15.900
And for all of your applications that advertise
services with Bonjour, if you advertise your service,

00:18:15.900 --> 00:18:18.080
we can transfer that data to the sleep proxy.

00:18:18.080 --> 00:18:24.040
If you don't advertise the service, we don't know
about you and we can't tell the proxy about you.

00:18:24.040 --> 00:18:28.580
So with that, I'd like to invite Rory McGuire to
come up on stage and tell you some specific details

00:18:28.580 --> 00:18:33.510
about Bonjour and multitasking in iPhone OS.

00:18:33.510 --> 00:18:38.690
[ Applause ]

00:18:38.690 --> 00:18:40.200
>> Rory McGuire: Thank you Stuart.

00:18:40.200 --> 00:18:45.980
My name is Rory and I'm here to help
you learn about Bonjour on iPhone OS.

00:18:45.980 --> 00:18:48.640
Specifically, we're going to go over three things.

00:18:48.640 --> 00:18:52.290
First is peer-to-peer networking, something
that Stuart talked about a little bit.

00:18:52.290 --> 00:18:54.240
I'll go into a little bit more detail.

00:18:54.240 --> 00:19:00.080
The second is a new API in iOS 4
called DNSServiceSetDispatchQueue.

00:19:00.080 --> 00:19:05.790
It's in our low-level C API and it allows
you to use GCD queues with Bonjour.

00:19:05.790 --> 00:19:08.760
It'll make things a lot easier for you, I'll get into that.

00:19:08.760 --> 00:19:17.040
And the new hotness for iOS 4 multitasking and what
that means for Bonjour and networking in general.

00:19:17.040 --> 00:19:19.350
Let's get to it.

00:19:19.350 --> 00:19:23.990
Peer-to-peer, this is something that we
introduced last year with iPhone OS 3.

00:19:23.990 --> 00:19:27.890
You may know this as being used by Game Kit.

00:19:27.890 --> 00:19:30.400
Well, what does it actually do?

00:19:30.400 --> 00:19:34.740
I'm sure we're all familiar with this Wi-Fi
selection UI, Wi-Fi network selection UI.

00:19:34.740 --> 00:19:38.820
Which network do I pick, right?

00:19:38.820 --> 00:19:44.510
Let's say for example that you're in a room with 576 MiFis.

00:19:44.510 --> 00:19:49.640
If I wanna use my game or use my service,
which one of these things do I pick?

00:19:51.590 --> 00:19:55.380
Well, we're going to solve that with no configuration.

00:19:55.380 --> 00:19:56.930
How are we going to do it?

00:19:56.930 --> 00:19:57.780
Bluetooth.

00:19:57.780 --> 00:19:58.540
But wait a second.

00:19:58.540 --> 00:20:02.120
This is the Bonjour session, what
are we doing talking about Bluetooth?

00:20:02.120 --> 00:20:06.360
Well it's Bonjour over Bluetooth.

00:20:06.360 --> 00:20:09.990
Again, like Stuart said, there's no manual pairing.

00:20:09.990 --> 00:20:15.190
Bonjour will automatically make the
devices connect when you do a resolve.

00:20:15.190 --> 00:20:19.280
Again, this is used by Game Kit but
it's not required that you use Game Kit.

00:20:19.280 --> 00:20:21.680
You only really have to use the Bonjour APIs.

00:20:21.680 --> 00:20:27.240
So if you already have the Bonjour APIs in your
app, you will get the Bluetooth stuff for free.

00:20:27.240 --> 00:20:30.470
How is it the same?

00:20:30.470 --> 00:20:37.400
Exactly the same APIs, NSNetService APIs,
CFNetService APIs and the dns_sd low-level C API.

00:20:37.400 --> 00:20:39.480
Your code will just work.

00:20:39.480 --> 00:20:44.710
How was it different?

00:20:44.710 --> 00:20:49.030
Well, Stuart talked a little bit about how Bonjour
actually separates browsing from resolving.

00:20:49.030 --> 00:20:53.400
This really worked well for us
to implement this over Bluetooth.

00:20:53.400 --> 00:20:59.050
Resolves may take a little bit longer because that's what
actually tells Bonjour to bring up the IP connection,

00:20:59.050 --> 00:21:01.960
the PAN connection between the two devices.

00:21:01.960 --> 00:21:06.250
So one of the things that you're going to want
to is make sure you use ResolveWithTimeout.0.

00:21:06.250 --> 00:21:12.850
It's going to take a little bit longer
than a connection, a resolve over Wi-Fi.

00:21:12.850 --> 00:21:18.050
Let the user decide when they've waited
long enough for this thing to come up.

00:21:18.050 --> 00:21:20.700
That's about it.

00:21:20.700 --> 00:21:25.610
So, let's go to little more detail about
the separation between browse and resolve.

00:21:25.610 --> 00:21:30.710
Browsing gets you a little bit of
information about a lot of service instances.

00:21:30.710 --> 00:21:34.290
It gets you the name of lots and lots of service instances.

00:21:34.290 --> 00:21:40.500
Resolve on the other hand gets you a little bit of info or
gets a lot of information about one particular instance.

00:21:40.500 --> 00:21:45.400
And in the case of Bonjour over Bluetooth, it
also brings up the Bluetooth PAN connection

00:21:45.400 --> 00:21:47.830
which is kind of a heavyweight operation.

00:21:47.830 --> 00:21:55.140
What you don't want to do is resolve every single service
that you find in the browse because that's going to fill

00:21:55.140 --> 00:22:00.090
in the whole table and it's going to be very costly.

00:22:00.090 --> 00:22:06.130
Don't browse continuously because that also
has some power and performance implications.

00:22:06.130 --> 00:22:07.520
Don't resolve every service.

00:22:07.520 --> 00:22:11.670
You can get a little bit more information about
the services by querying for the TXT record.

00:22:11.670 --> 00:22:18.050
There are APIs at the NS and CF layer to get the
TXT record for the services that your browses return

00:22:18.050 --> 00:22:21.490
so you can display a little bit
more information to the user.

00:22:21.490 --> 00:22:24.450
But let your user decide which
service they want to connect to.

00:22:24.450 --> 00:22:28.960
Don't just go off connecting to every single service because
you're going to be telling Bluetooth to go off and connect

00:22:28.960 --> 00:22:33.590
to these different PAN connections if
the thing was discovered over Bluetooth.

00:22:33.590 --> 00:22:38.100
You don't want your app to be known as
the one that drains the user's battery.

00:22:38.100 --> 00:22:47.080
Not to be outdone, the Wi-Fi guys are actually
working on something called Wi-Fi Direct.

00:22:47.080 --> 00:22:52.700
This is currently scheduled to have Bonjour in it.

00:22:52.700 --> 00:22:59.560
Alright, it does some exchange with these people
to actually have this work as well using Bonjour.

00:22:59.560 --> 00:23:03.670
What that's going to mean for you is
that you'll just use the Bonjour APIs.

00:23:03.670 --> 00:23:06.480
Just like over Bluetooth, it's just going to work.

00:23:06.480 --> 00:23:12.170
But of course, it's not out yet.

00:23:12.170 --> 00:23:15.620
Next topic, DNSServiceSetDispatchQueue.

00:23:15.620 --> 00:23:21.740
This a new API in iOS 4 and it's actually quite nice.

00:23:21.740 --> 00:23:23.480
It's very, very simple.

00:23:23.480 --> 00:23:30.010
You have a DNSServiceRef and you tell it,
this is the queue I want to put it on.

00:23:30.010 --> 00:23:34.790
Before this API, when you use the
low-level C APIs for Bonjour,

00:23:34.790 --> 00:23:39.010
you would have to create a CF socket
run loop source or you would have

00:23:39.010 --> 00:23:41.510
to have your own kqueue loop or your own select loop.

00:23:41.510 --> 00:23:45.530
You'd have to call DNSServiceProcessResult
or all these things you had to do

00:23:45.530 --> 00:23:48.700
in order to get it to work with the C API.

00:23:48.700 --> 00:23:52.410
Now, however, it's going to be just one line of code, right?

00:23:52.410 --> 00:23:56.430
You start up your browse like you did previously,
but now instead of creating and putting something

00:23:56.430 --> 00:24:02.350
in your select loop and calling
DNSServiceProcessResult or creating a CFRunLoop source,

00:24:02.350 --> 00:24:08.710
all you have to do is call the SetDispatchQueue with
your DNSServiceRef and the queue you want to put it on.

00:24:08.710 --> 00:24:12.060
In most cases, it's going to be the main queue.

00:24:12.060 --> 00:24:18.820
Now if you're new to iPhone development or
actually you're just new to iPhone OS 4, to iOS 4,

00:24:18.820 --> 00:24:21.740
GCD is seriously the coolest thing since sliced bread.

00:24:21.740 --> 00:24:23.380
I love GCD.

00:24:23.380 --> 00:24:29.610
There is the GCD on iOS session immediately
following this one in Russian Hill.

00:24:29.610 --> 00:24:32.760
I invite everybody to attend that, please.

00:24:32.760 --> 00:24:33.510
That's it for that API.

00:24:33.510 --> 00:24:35.100
It's really simple.

00:24:35.100 --> 00:24:37.380
Now on to the new hotness, multitasking.

00:24:37.380 --> 00:24:42.870
So we're going to go through a timeline here.

00:24:42.870 --> 00:24:46.290
What happens when your-- a standard multitask in your app.

00:24:46.290 --> 00:24:47.870
Now, there's some other kinds of apps you can be.

00:24:47.870 --> 00:24:48.820
You can be a VoIP app.

00:24:48.820 --> 00:24:51.360
You can do some things with locations, things like that.

00:24:51.360 --> 00:24:52.320
I'm not going to cover those.

00:24:52.320 --> 00:24:55.560
Those are covered by the multitasking sessions.

00:24:55.560 --> 00:24:59.400
I'm going to talk about general networking
in applications that are not VoIP

00:24:59.400 --> 00:25:02.730
and not doing audio streaming and things like that.

00:25:02.730 --> 00:25:06.430
The first thing that's going to happen when the
user hits the Home button is that you're going

00:25:06.430 --> 00:25:11.150
to get the applicationDidEnterBackground
callback on you application delegate.

00:25:11.150 --> 00:25:15.510
At some point after that, your
code is going to stop running.

00:25:15.510 --> 00:25:19.430
Now, you can request a task completion and
that'll extent the amount of time that you get

00:25:19.430 --> 00:25:22.380
to run but not really all that much, right.

00:25:22.380 --> 00:25:28.080
At some point, your app is going to be
not be scheduled anymore by the kernel.

00:25:28.080 --> 00:25:32.190
There is no indication when your
application actually stops running.

00:25:32.190 --> 00:25:37.470
The only indication that you get is that
your application did enter the background.

00:25:37.470 --> 00:25:44.490
Some point after your application stops running,
your Bonjour operations may be canceled.

00:25:44.490 --> 00:25:51.640
In order for us to do very efficient and effective
multitasking, the system is going to reclaim resources.

00:25:51.640 --> 00:25:55.950
Not necessarily always but it does this
so that the other applications that are

00:25:55.950 --> 00:25:59.690
in the foreground can actually get a much better experience.

00:25:59.690 --> 00:26:03.910
The other thing it may do is reclaim
the actual networking sockets.

00:26:03.910 --> 00:26:06.020
Now, it's not actually going to close your sockets.

00:26:06.020 --> 00:26:12.510
It's going to do something much more akin to a
shutdown and you don't know it's happening, right.

00:26:12.510 --> 00:26:14.620
Your application is not actually running right now.

00:26:14.620 --> 00:26:19.850
You're not scheduled on the processor so you have no
idea that this is going on and that this happened.

00:26:19.850 --> 00:26:21.210
And again, it doesn't always happen.

00:26:21.210 --> 00:26:24.870
This is when the system decides to reclaim some resources.

00:26:24.870 --> 00:26:29.020
So at some point in the future here, your
code is actually going to resume running.

00:26:29.020 --> 00:26:32.140
But again, you don't really get any
kind of notification this is happening.

00:26:32.140 --> 00:26:35.940
You're just going to get scheduled again
and your code's going to start running.

00:26:35.940 --> 00:26:42.030
What's important to note here is this is when you should
deal with the aftermath of these things happening, right.

00:26:42.030 --> 00:26:48.700
This is where you need to be robust to errors on your
networking sockets, errors in you Bonjour operations,

00:26:48.700 --> 00:26:56.790
all these things, because this may actually happen depending
on scheduling before you get applicationWillEnterForeground.

00:26:56.790 --> 00:27:01.760
Do not use applicationWillEnterForeground as a
notification that you need to clean up your world.

00:27:01.760 --> 00:27:05.650
Your world may be dirty before that because
your application actually started running

00:27:05.650 --> 00:27:09.280
on the processor before you got this callback.

00:27:09.280 --> 00:27:13.310
Now, in general you should be robust
to network issues, right?

00:27:13.310 --> 00:27:15.020
This is not just multitasking.

00:27:15.020 --> 00:27:22.640
I can walk across the room and now I'm closer to this set
of MiFis so my networking is going to be busted, right.

00:27:22.640 --> 00:27:26.380
So just the usual walking around
might have effects on networking.

00:27:26.380 --> 00:27:32.970
So be robust to networking issues, right including things
that happen when you get resumed after multitasking,

00:27:32.970 --> 00:27:36.400
after going in the background and coming back up.

00:27:36.400 --> 00:27:41.230
So merely building with iOS 4 gets you this behavior, right?

00:27:41.230 --> 00:27:45.820
Your application will go into the
background, it will get suspended.

00:27:45.820 --> 00:27:51.610
After a resume, all your Bonjour
networking may be broken for your app.

00:27:51.610 --> 00:27:53.220
You'll no longer be advertising anything.

00:27:53.220 --> 00:27:55.250
You'll no longer be discovering anything.

00:27:55.250 --> 00:27:58.690
Your network sockets might be closed.

00:27:58.690 --> 00:28:06.400
Detect and fix that broken state or the user experience with
your app is going to be worse than it was with iPhone OS 3.

00:28:06.400 --> 00:28:08.730
This is very, very important, right?

00:28:08.730 --> 00:28:15.190
There's no UI for users to go exit your app, at least
no UI that they're really going to understand, right.

00:28:15.190 --> 00:28:16.690
There's no Quit button.

00:28:16.690 --> 00:28:20.930
There's nothing that says I want
you to relaunch my app from scratch.

00:28:20.930 --> 00:28:26.390
If your app doesn't clean up the first time it
resumes, your app is going to be dead in the water.

00:28:26.390 --> 00:28:31.280
When the user switches back to your app at anytime
in the future, you don't want it to be host, right.

00:28:31.280 --> 00:28:32.210
You want it to work again.

00:28:32.210 --> 00:28:36.500
So be robust to these kinds of errors
even if you're not getting a resume.

00:28:36.500 --> 00:28:38.800
You might get networking errors for other reasons.

00:28:38.800 --> 00:28:46.630
So if you're using the NSNetService or the CFNetService
APIs, you'll get called back with an error code.

00:28:46.630 --> 00:28:51.720
When you get callback with that error code, restart
your Bonjour operations if that's where you are,

00:28:51.720 --> 00:28:53.470
if that's where you want your user to be.

00:28:53.470 --> 00:28:55.130
Again, you shouldn't be browsing all the time.

00:28:55.130 --> 00:28:58.770
You should be browsing or resolving
when the user actually wants

00:28:58.770 --> 00:29:03.030
to because there are some power
implications and things like that.

00:29:03.030 --> 00:29:07.720
With the lower-level C APIs, if you're
calling DNSServiceProcessResult yourself,

00:29:07.720 --> 00:29:12.530
check for the return code ServiceNotRunning
and then restart your Bonjour operations.

00:29:12.530 --> 00:29:19.390
If you're using the new SetDispatchQueue, it will
call all your callbacks with ServiceNotRunning

00:29:19.390 --> 00:29:22.980
because again you're not calling
DNSServiceProcessResult yourself.

00:29:22.980 --> 00:29:26.040
You're letting all the cool dispatch
stuff take care of that for you.

00:29:26.040 --> 00:29:29.370
When you get ServiceNotRunning,
restart all your Bonjour operations.

00:29:29.370 --> 00:29:35.540
If you're using the low-level C APIs, we highly
recommend that you use the new SetDispatchQueue API

00:29:35.540 --> 00:29:38.550
because it allows for us to do future improvements, right?

00:29:38.550 --> 00:29:41.600
In the future, we could automatically
start all the things back up for you

00:29:41.600 --> 00:29:44.080
and you will not even get errors when you resume.

00:29:44.080 --> 00:29:53.720
And the last thing is you can actually opt out of
this behavior by adding this thing to your info.plist.

00:29:53.720 --> 00:29:58.510
And now back to Stuart.

00:29:58.510 --> 00:30:04.990
[ Applause ]

00:30:04.990 --> 00:30:08.960
>> Stuart Cheshire: Thank you Rory.

00:30:08.960 --> 00:30:17.310
So, in other news we just released Bonjour for Windows
2.0.2 and this brings Bonjour on Windows to feature parity

00:30:17.310 --> 00:30:22.970
with Bonjour on Mac OS 10.6, Snow Leopard.

00:30:22.970 --> 00:30:26.940
It's installed with iTunes on Windows, with Safari.

00:30:26.940 --> 00:30:34.310
Now with Bonjour Print Services which lets
Windows machines share printers on your Mac.

00:30:34.310 --> 00:30:41.590
There's an SDK for developers which gives you
additional tools and the header files, the documentation.

00:30:41.590 --> 00:30:45.880
One of the key new things which you will be happy

00:30:45.880 --> 00:30:49.720
about if you're a Windows developer is
we have the new shared connection mode.

00:30:49.720 --> 00:30:51.880
And I'll talk in a minute about why that's useful.

00:30:51.880 --> 00:30:55.850
We have some stuff code to do weak-linking.

00:30:55.850 --> 00:30:57.410
I'll explain that.

00:30:57.410 --> 00:31:01.680
And it also supports Sleep Proxy just like Snow Leopard.

00:31:01.680 --> 00:31:04.410
You might ask why does Apple do Bonjour for Windows?

00:31:04.410 --> 00:31:12.550
Well, we want a world where network
products talk to each other effortlessly.

00:31:12.550 --> 00:31:22.870
And a lot of you guys are making applications for the iPhone
and a lot of those applications may want to synchronize data

00:31:22.870 --> 00:31:26.910
with information on the user's home computer.

00:31:26.910 --> 00:31:32.720
And we don't want you to have to do one set of
things for Macs and something different for Windows.

00:31:32.720 --> 00:31:39.820
So, you can use the same network protocol, a very
efficient, mature, robust service discovery protocol

00:31:39.820 --> 00:31:46.660
and have that available on Windows as well.

00:31:46.660 --> 00:31:52.520
On Mac OS X, adding event source to your run
loop is very easy and every Bonjour operation

00:31:52.520 --> 00:31:56.450
in the original API stands alone as its own event source.

00:31:56.450 --> 00:32:01.940
The feedback we have from Windows programmers
is that it's not so easy on Windows.

00:32:01.940 --> 00:32:08.540
The way you typically program on Windows is you make the
list of sources you're waiting for then you tell Windows

00:32:08.540 --> 00:32:11.640
to wait for something interesting
to happen with one of those sources

00:32:11.640 --> 00:32:17.530
and then when it returns you process the events.

00:32:17.530 --> 00:32:22.580
But having-- creating a new operation while
you're waiting means you've got to break out of

00:32:22.580 --> 00:32:24.990
that loop and make a new list and go back into it.

00:32:24.990 --> 00:32:25.950
And it's possible to do.

00:32:25.950 --> 00:32:29.360
Many people have done it but it is extra work.

00:32:29.360 --> 00:32:39.180
So, we have this new mode which is also available on Snow
Leopard and iOS which is where you make a shared connection

00:32:39.180 --> 00:32:43.730
and then you can add new Bonjour operations
to that one shared connection which means

00:32:43.730 --> 00:32:50.900
on application startup you make a single Windows events
source, put that in your WaitForMultipleObjects list

00:32:50.900 --> 00:32:55.380
and then you don't have to keep
adding and removing event sources.

00:32:55.380 --> 00:33:04.690
The way that works is first you call createConnection
on startup and then you copy that DNSServiceRef

00:33:04.690 --> 00:33:08.210
and do a new operation passing the shared connection flag.

00:33:08.210 --> 00:33:12.810
You can make another copy of that
service ref and start another operation.

00:33:12.810 --> 00:33:20.270
Each operation can have a different callback
function to handle the events or as in this case,

00:33:20.270 --> 00:33:24.630
they both have the same reply function
but they have a different context pointer

00:33:24.630 --> 00:33:30.760
which is how the reply function knows which particular
event has just happened relating to which operation.

00:33:30.760 --> 00:33:34.920
Typically, this context pointer would
be a pointer to your object or structure

00:33:34.920 --> 00:33:40.910
or something else defining the state
of that operation you're doing.

00:33:40.910 --> 00:33:46.550
I always like to show things at the developer conference
which are not made by Apple because this is an open standard

00:33:46.550 --> 00:33:50.860
and I'm always interested to see what
the other developers are doing with it.

00:33:50.860 --> 00:33:55.020
RealVNC is now using Bonjour in
their Windows and iPad products.

00:33:55.020 --> 00:33:58.360
I am going to show you that.

00:33:58.360 --> 00:34:09.370
Their server for Windows advertises with Bonjour and
their client on the iPad uses Bonjour to discover servers.

00:34:09.370 --> 00:34:13.630
RealVNC is using the weak-linking
capability that I talked about.

00:34:13.630 --> 00:34:20.810
On the Mac, since the day before OS X,
we had this concept called weak-linking.

00:34:20.810 --> 00:34:28.400
You could write an app that linked to some feature
that was new in Mac OS 10.6 and if the user ran it

00:34:28.400 --> 00:34:31.430
on 10.5 they wouldn't get a DLL link error.

00:34:31.430 --> 00:34:37.480
The application would still launch but its functions
would be effectively like null function pointers.

00:34:37.480 --> 00:34:43.490
And you as a developer could know that and check
those functions were not null before you called them

00:34:43.490 --> 00:34:45.470
and that way your application would still run.

00:34:45.470 --> 00:34:50.110
It just might miss some of the new functionality
but it's not going to fail to launch.

00:34:50.110 --> 00:34:52.940
It came as a surprise to us that Windows doesn't have that.

00:34:52.940 --> 00:34:59.450
So, that means developers have to roll their own
functionality and again this was feedback we heard

00:34:59.450 --> 00:35:04.030
from developers and in Bonjour for
Windows 2.0, we do that for you.

00:35:04.030 --> 00:35:10.530
We have helpers to help you link in your library and
it does the DLL calls to see if Bonjour is installed

00:35:10.530 --> 00:35:17.960
and if it's not installed then when you call the function
you get an error and so it uses that so you don't have

00:35:17.960 --> 00:35:22.090
to have Bonjour installed to use their
server and if it's not installed,

00:35:22.090 --> 00:35:27.510
their server will try to advertise the service and
get an error and it will continue and run correctly.

00:35:27.510 --> 00:35:30.910
But if Bonjour is installed then
the server will advertise with it.

00:35:30.910 --> 00:35:35.920
So let's see if I can show you that now.

00:35:35.920 --> 00:35:49.200
Okay, so, I have my machine here
running Windows and I have my iPad.

00:35:50.570 --> 00:36:01.750
I will-- this is the RealVNC VNCViewer and I can run
this and this is the out of the box configuration.

00:36:01.750 --> 00:36:03.960
Let's see what's available on the network.

00:36:03.960 --> 00:36:08.060
And without typing in any configuration information,

00:36:08.060 --> 00:36:13.240
this has used Bonjour to find a
couple of VNC servers it can talk to.

00:36:13.240 --> 00:36:15.710
This version displays the IP address.

00:36:15.710 --> 00:36:23.280
You wouldn't do that in a normal application but one
thing you will notice here is those addresses say 169.254

00:36:23.280 --> 00:36:28.700
and I'm pointing that out because I'm
not connected to any of the network here.

00:36:28.700 --> 00:36:31.610
This is just on my laptop here.

00:36:31.610 --> 00:36:35.040
I created a wireless network and on the iPad I joined it.

00:36:35.040 --> 00:36:37.050
There is no DXUP server.

00:36:37.050 --> 00:36:40.020
This is a TCP/IP network with 2 devices on it.

00:36:40.020 --> 00:36:43.180
They pick their own link local
addresses, they use Multicast DNS.

00:36:43.180 --> 00:36:52.860
They've discovered each other and this is a common developer
mistake to say wait, I better use the reachability APIs

00:36:52.860 --> 00:36:55.220
and make sure I can talk to the internet and oh no, I can't.

00:36:55.220 --> 00:36:58.360
I'm going to put up an error messages and refuse to work.

00:36:58.360 --> 00:37:03.260
You don't need to talk to the great
mainframe in the sky to do useful networking.

00:37:03.260 --> 00:37:06.280
Quite often you may have a device
that you just want to set up

00:37:06.280 --> 00:37:10.640
and VNC could be a great way of
doing that and talking to that.

00:37:10.640 --> 00:37:16.420
The reachability APIs are a great way to notify you.

00:37:16.420 --> 00:37:20.760
If you try to connect and you fail, you
can use reachability to get a notification

00:37:20.760 --> 00:37:22.730
about when the network environment has changed.

00:37:22.730 --> 00:37:25.060
So it might be good time to try again.

00:37:25.060 --> 00:37:30.810
But there are terrible preflight checks
because they can only ever make things worse.

00:37:30.810 --> 00:37:33.980
If you just try to connect you will either succeed or fail.

00:37:33.980 --> 00:37:41.730
If you use reachability as a preflight check before
that it can't ever make a failed connection succeed.

00:37:41.730 --> 00:37:47.740
A connection that would have failed will still fail but it
can make you not try in a case that would have succeeded.

00:37:47.740 --> 00:37:53.370
So general lesson here and I highly recommend going

00:37:53.370 --> 00:37:58.220
to the sessions this afternoon at
networking on iPhone OS, two parts.

00:37:58.220 --> 00:38:05.540
They cover a lot of details about dealing with networking in
a modern world, particularly networking on mobile devices.

00:38:05.540 --> 00:38:09.240
I recommend those.

00:38:09.240 --> 00:38:20.960
And let's see what happens when I connect to this.

00:38:20.960 --> 00:38:32.630
And so, with zero-configuration I have just
discovered and connected from an Apple iPad device

00:38:32.630 --> 00:38:38.510
to a Microsoft Windows machine
and you saw how easy that was.

00:38:38.510 --> 00:38:45.020
For any of you guys who've set up things like network
cameras and tried to configure IP address and things.

00:38:45.020 --> 00:38:48.250
You know it can be something that you
planned half a Saturday afternoon for.

00:38:48.250 --> 00:38:53.510
With Bonjour you just connect and
it works, so let's move on.

00:38:53.510 --> 00:39:00.530
[ Applause ]

00:39:00.530 --> 00:39:05.680
So I have-- this is not a shipping
product yet but I'm very excited.

00:39:05.680 --> 00:39:09.510
Oh I'm sorry, I'm getting ahead.

00:39:09.510 --> 00:39:19.640
So, you all know that the iPhone uses
WebKit as its HTML rendering engine.

00:39:19.640 --> 00:39:26.360
And I'm sure you know that Palm devices
and Android phones use WebKit as well.

00:39:26.360 --> 00:39:33.630
And you know that iPhone OS uses
Bonjour for its service discovery.

00:39:33.630 --> 00:39:40.500
Well I'm very happy to say that last month at
Palm's developers conference they announced

00:39:40.500 --> 00:39:49.870
that Palm will also be supporting the Bonjour APIs
and you can already get Android apps that use Bonjour

00:39:49.870 --> 00:39:54.090
by embedding a Java implementation of
Bonjour but by the end of the year,

00:39:54.090 --> 00:40:00.910
I'm told that Android OS will have Bonjour APIs itself
so that every app doesn't have to embed its own copy.

00:40:00.910 --> 00:40:05.880
So, you could use the same HTML
5 on all these mobile platforms

00:40:05.880 --> 00:40:11.300
and you can use the same Bonjour service
discovery on all these mobile platforms.

00:40:12.320 --> 00:40:18.140
Now I'm sure many people in this room have probably
experimented with the technology called X10.

00:40:18.140 --> 00:40:25.300
For those of you who don't know, it's a power line signaling
mechanism that's been around since the '70s, I think.

00:40:25.300 --> 00:40:26.830
And the idea is great.

00:40:26.830 --> 00:40:31.220
You can have a little module that you plug into
the wall and you plug your table lamp into it.

00:40:31.220 --> 00:40:34.560
And then you could have another device, a switch connected

00:40:34.560 --> 00:40:37.980
to the power lines that's not mechanically
switching the power on and off.

00:40:37.980 --> 00:40:44.860
It's sending signals over the power line to tell that
module to turn the lights on or off or brighten or dim.

00:40:44.860 --> 00:40:51.830
And this is a great idea for being more flexible
about how you control things in your house.

00:40:51.830 --> 00:40:54.520
But the protocol is slow and unreliable.

00:40:54.520 --> 00:40:55.380
There's no acknowledgment.

00:40:55.380 --> 00:40:56.970
There's no retransmission.

00:40:56.970 --> 00:41:00.540
So, for a lot of people it's a very frustrating experience.

00:41:00.540 --> 00:41:04.410
The promise is there but the reality
doesn't really live up to it.

00:41:04.410 --> 00:41:10.540
And time is long overdue I think for something
that is like X10 but works a lot better.

00:41:11.680 --> 00:41:18.370
These products and they are not on sale yet
so I'm not going to give the company name

00:41:18.370 --> 00:41:21.450
but look for these in the shops by Christmas, I hope.

00:41:21.450 --> 00:41:29.440
This is little module you plug in the power outlet and they
have Wi-Fi in them and Bonjour and there's an iPhone app

00:41:29.440 --> 00:41:36.760
which uses Bonjour to discover all of these modules
wirelessly, not over the power line over Wi-Fi.

00:41:36.760 --> 00:41:42.590
And from the iPhone app you can tell it to turn
on or off or brighten or dim but the difference

00:41:42.590 --> 00:41:50.850
because this is Wi-Fi is you don't press brighten
4 times and two of the packets got lost so you have

00:41:50.850 --> 00:41:53.850
to press a few more times to reach the right brightness.

00:41:53.850 --> 00:41:57.220
That kind of worked when a human is doing it
but when a computer is controlling things,

00:41:57.220 --> 00:42:02.050
it can't tell how bright the light is by looking
at it so you really need something reliable.

00:42:02.050 --> 00:42:08.320
So, you can send commands to the module to
turn on and turn off and brighten and dim.

00:42:08.320 --> 00:42:13.570
That circle on the front is actually
a push button so you can override it.

00:42:13.570 --> 00:42:17.520
So, if you don't want to dig out your phone
you can press the button to turn it on and off.

00:42:17.520 --> 00:42:23.480
And because it's all software controlled when you press
that button, it can signal back to the app on your iPhone

00:42:23.480 --> 00:42:27.260
or your computer that the button was
pushed which you can use as a trigger

00:42:27.260 --> 00:42:30.220
to turn other things on or off in the house.

00:42:30.220 --> 00:42:32.370
These things also have a power meter in them.

00:42:32.370 --> 00:42:35.320
Some of the people in this room have probably
bought power meters because they are curious

00:42:35.320 --> 00:42:38.610
about how much power their television and
their computer and their printer take.

00:42:38.610 --> 00:42:41.720
Well, these have power metering built into them.

00:42:41.720 --> 00:42:44.410
So you don't need a separate box with an LCD display.

00:42:44.410 --> 00:42:49.030
Just on your iPhone screen, you can see the amount
of power that's being consumed by each device plugged

00:42:49.030 --> 00:42:55.390
into these things and even chart it overtime to
see the refrigerator compressor cycling on and off.

00:42:55.390 --> 00:42:59.160
And you can use that as a trigger for
events so that when you turn the television

00:42:59.160 --> 00:43:06.410
on it senses the increased power draw and sends messages
to other modules to tell them to turn off the lights

00:43:06.410 --> 00:43:12.200
and turn on the amplifier and you can build all
of these things that communicate with each other

00:43:12.200 --> 00:43:15.820
and automate things in your home over Wi-Fi using Bonjour.

00:43:15.820 --> 00:43:19.970
So, the whole Bonjour team is very excited
about this and we're going to be first

00:43:19.970 --> 00:43:22.690
in line to buy these as soon as they go on sale.

00:43:22.690 --> 00:43:30.100
This was exactly the kind of thing that I hoped to see
happen when we started the Bonjour effort ten years ago.

00:43:30.100 --> 00:43:37.680
Bonjour is not just about desktop Macs and PCs, although
it's certainly good that we make those easier to use

00:43:37.680 --> 00:43:42.530
but where it's critically important is
devices like this where you can't hook

00:43:42.530 --> 00:43:44.600
up a screen and a keyboard to configure them.

00:43:44.600 --> 00:43:50.150
They absolutely have to be bullet proof and self
configuring and you can't afford the tech support costs

00:43:50.150 --> 00:43:52.400
of people calling up trying to
work at how to configure them.

00:43:52.400 --> 00:43:56.250
You have to just have them plug in and work.

00:43:56.250 --> 00:43:58.560
So with that, I'll get to our tips and reminders.

00:43:58.560 --> 00:44:06.330
You've heard this in other sessions
and I'm going to repeat it here.

00:44:06.330 --> 00:44:08.180
Make sure your applications work with IPv6.

00:44:08.180 --> 00:44:17.590
IPv4 has link-local addressing but it was
kind of an add-on after the fact to IPv4.

00:44:17.590 --> 00:44:22.280
IPv6 has had it built-in from the start
and the API supports it more elegantly.

00:44:22.280 --> 00:44:25.080
So, we wholeheartedly recommend IPv6.

00:44:25.080 --> 00:44:30.980
We use IPv6 in our own base stations,
that's how you configure AirPort Express is

00:44:30.980 --> 00:44:35.350
with an IPv6 link-local address to communicate with it.

00:44:35.350 --> 00:44:39.900
You'll hear this message in the iPhone networking sessions.

00:44:39.900 --> 00:44:41.690
Networking is asynchronous.

00:44:41.690 --> 00:44:46.270
Things don't always in the real world
like they might work in your lab.

00:44:46.270 --> 00:44:48.470
Here's one example.

00:44:48.470 --> 00:44:54.540
If you do asynchronous blocking DNS call on your main
thread and the DNS server happens to be not responsive

00:44:54.540 --> 00:44:58.690
for that user, the standard DNS time matches 30 seconds.

00:44:58.690 --> 00:45:02.770
Well, your app will get jettisoned
after 20 seconds if it's not responsive.

00:45:02.770 --> 00:45:05.520
So, your app dies.

00:45:05.520 --> 00:45:07.350
People say why don't you just make the timeout shorter?

00:45:07.350 --> 00:45:11.060
But that really isn't the answer because
even having your app unresponsive

00:45:11.060 --> 00:45:15.470
for 5 seconds is not a good user experience for the user.

00:45:15.470 --> 00:45:20.240
And 5 seconds may not be long enough for a slow DNS server.

00:45:20.240 --> 00:45:24.110
So, the answer is not synchronous blocking
calls and trying to get the time out right.

00:45:24.110 --> 00:45:28.810
The answer is to embrace the fact
that networking is asynchronous.

00:45:28.810 --> 00:45:36.580
Do things on a background thread or even better,
do things in an event driven basis using CFRunLoop

00:45:36.580 --> 00:45:40.820
or using the new libdispatch Grand Central Scheduling.

00:45:40.820 --> 00:45:48.470
Some that we see sometimes in Windows applications
is a Refresh button and we don't want to see

00:45:48.470 --> 00:45:54.290
that in Bonjour applications on Mac or Windows and
if you think about the iChat Bonjour Buddy List think

00:45:54.290 --> 00:46:00.470
about the sidebar on iTunes, think about the
Safari Bonjour list, there's no Refresh button.

00:46:00.470 --> 00:46:02.790
The list should always be fresh.

00:46:02.790 --> 00:46:05.880
So, the Bonjour APIs make this very easy.

00:46:05.880 --> 00:46:12.480
You start to browse you get out and remove
events for the lifetime of that browse.

00:46:12.480 --> 00:46:16.440
You don't have to have a timer the way you do when
you browse every minute to see what's changed.

00:46:16.440 --> 00:46:21.080
We've seen applications that do a browse for 10
seconds and then stop and then another one and then--

00:46:21.080 --> 00:46:25.990
That's actually harder on the network than just leaving
the browse running because the browse settles off

00:46:25.990 --> 00:46:32.900
to a low query rate and then just pays
attention to the events on the network.

00:46:32.900 --> 00:46:39.080
Generally, we recommend using the window so when the user
wants to connect to a service you may have a UI today

00:46:39.080 --> 00:46:41.810
where there's a field where they type in the host name.

00:46:41.810 --> 00:46:48.470
Well, you can still have that but next to that you can
have a Bonjour button which brings up a browsing list.

00:46:48.470 --> 00:46:53.400
And for the time that list is on
the screen it should be live.

00:46:53.400 --> 00:46:56.720
And then the user closes it and you stop the browse.

00:46:56.720 --> 00:47:03.990
We prefer a window to a pull down menu because while the
APIs exist from modifying a pull down menu while it's

00:47:03.990 --> 00:47:06.780
on the screen, it's disconcerting to use this.

00:47:06.780 --> 00:47:10.690
They're not really used to pulling down a menu and
seeing all the things jumble around and change.

00:47:10.690 --> 00:47:14.530
So we recommend using a window not a pull down menu.

00:47:14.530 --> 00:47:18.470
The way your client will discover instances of your service

00:47:18.470 --> 00:47:22.160
and not other services is that
every service has a unique name.

00:47:22.160 --> 00:47:24.380
You don't have to pay to register this.

00:47:24.380 --> 00:47:30.230
Just go to dns-sd.org and make sure you
register a unique identifier for your service.

00:47:30.230 --> 00:47:37.870
We often see in the wild on networks like WWDC here,
we look at the services that are being advertised

00:47:37.870 --> 00:47:41.180
and we always see a few that aren't
on the service type list.

00:47:41.180 --> 00:47:50.330
So, save yourself headaches by just going to that
webpage, send the email, register your service type.

00:47:50.330 --> 00:47:54.860
In the first version of Bonjour many
years ago we had a domain parameter.

00:47:54.860 --> 00:47:58.950
And it was there for future expansion
but it wasn't used at the time.

00:47:58.950 --> 00:48:05.510
Now, that we have wide area Bonjour and Back
to My Mac, don't ignore the domain parameter.

00:48:05.510 --> 00:48:13.830
When you do a browse you get back name, type, domain, and
the interface index and you need to store all of those

00:48:13.830 --> 00:48:18.450
or at least name, type, and domain and pass
those three unchanged to the resolve call.

00:48:18.450 --> 00:48:26.610
We have seen bugs where people ignore the domain or they
just hard code local and that works with local Bonjour

00:48:26.610 --> 00:48:30.880
but you're losing the benefits
of Back to My Mac if you do that.

00:48:32.290 --> 00:48:33.780
Don't ignore the port number.

00:48:33.780 --> 00:48:37.730
Historically, networking has had
the concept of well-known ports.

00:48:37.730 --> 00:48:40.150
Port80 is the web server.

00:48:40.150 --> 00:48:44.090
Well, you can only have one port80 on a machine.

00:48:44.090 --> 00:48:48.030
So with fast user switching, if there's
multiple application and multiple copies

00:48:48.030 --> 00:48:51.470
of the same application running they
can't all have the same port number.

00:48:51.470 --> 00:48:57.360
There are a lot of bits to software today
that use a webpage as their configuration UI

00:48:57.360 --> 00:49:01.270
which is great but again, they can't all have port80.

00:49:01.270 --> 00:49:08.150
When you've got multiple computers at home behind
the NAT Gateway, they're all sharing one IP address.

00:49:08.150 --> 00:49:11.120
There's only one port80 on that IP address.

00:49:11.120 --> 00:49:18.680
So, we knew this was going to happen and that's why the
Bonjour resolve call gives you back the port number.

00:49:18.680 --> 00:49:27.790
When you create your service, you can specify 0 when you
bind and the kernel will pick an unused port for you.

00:49:27.790 --> 00:49:33.590
The register API has a parameter for you to say
what port number you're listening on and that goes

00:49:33.590 --> 00:49:38.020
into the network packets and the resolve call
will tell the clients we have seen applications.

00:49:38.020 --> 00:49:39.360
They do the resolve.

00:49:39.360 --> 00:49:40.770
They get back the address in the port.

00:49:40.770 --> 00:49:46.080
They ignore the port and try to connect to the
well-known ports and that only works if you get lucky.

00:49:46.080 --> 00:49:50.170
The first copy of the application may get
the port at once but all the others won't.

00:49:50.170 --> 00:49:57.780
So, this creates situations with Back to My Mac or with
other wide area Bonjour things where you can only connect

00:49:57.780 --> 00:50:00.410
to one thing at the group but the other ones that aren't

00:50:00.410 --> 00:50:04.510
on the standard port don't work when
they connect to the wrong thing.

00:50:05.650 --> 00:50:11.920
For your marketing materials and
your packaging and your webpages,

00:50:11.920 --> 00:50:19.460
if you use Bonjour then you can license the Bonjour
logo for no cost just like the Made for iPhone

00:50:19.460 --> 00:50:24.290
and Made for iPad logos to let your customers
know that they can expect a painless,

00:50:24.290 --> 00:50:28.370
trouble-fee experience with your products.

00:50:28.370 --> 00:50:35.640
If you're using the Bonjour APIs on Mac
and Windows then you are good to go.

00:50:35.640 --> 00:50:42.460
If you are building pieces of hardware which we love to see
then we have a Bonjour conformance test which you can run

00:50:42.460 --> 00:50:46.220
to help you find bugs in your implementation and if you pass

00:50:46.220 --> 00:50:50.980
that test then you can also use
the Bonjour logo on your packaging.

00:50:50.980 --> 00:50:55.390
And I encourage you to run that test
because it does help you find bugs

00:50:55.390 --> 00:51:00.120
that might cause trouble for customers in the field.

00:51:00.120 --> 00:51:05.490
If you are doing something where you want a component
that runs on Windows you can license Bonjour for Windows

00:51:05.490 --> 00:51:10.030
and that is also free with iTunes being on so many machines.

00:51:10.030 --> 00:51:15.910
There are a hundred million copies of Bonjour for Windows
already out there so you may not even have to install it

00:51:15.910 --> 00:51:21.270
but if you want to include that with your
software you can license that for no fee.

00:51:21.270 --> 00:51:26.900
Safari on Windows has the same Bonjour
browsing that Safari on Mac OS X does.

00:51:26.900 --> 00:51:39.130
So to wrap up, especially with things like
peer-to-peer over Bluetooth on the phone,

00:51:39.130 --> 00:51:45.840
having an app that's constantly browsing all the
time in the background has a toll in battery life.

00:51:45.840 --> 00:51:52.170
So, when the user hits the button to bring up your browsing
list you start the browse and then leave the browse live

00:51:52.170 --> 00:51:55.150
so they're getting live information
but when the user dismisses, it stops.

00:51:55.150 --> 00:51:57.290
That's what we recommend.

00:51:57.290 --> 00:52:01.700
We know that not all apps from
Apple set the best example here.

00:52:01.700 --> 00:52:07.520
iTunes has the sidebar that's browsing all
the time but particularly on the phone,

00:52:07.520 --> 00:52:10.880
we recommend browsing when the user
is actually actively looking for stuff

00:52:10.880 --> 00:52:13.890
but otherwise, don't be browsing all the time.

00:52:13.890 --> 00:52:19.100
And in the same vein, don't resolve everything
you find because that could be very expensive.

00:52:19.100 --> 00:52:26.010
You're triggering a whole bunch of mechanism by
resolving there that you really don't need to trigger

00:52:26.010 --> 00:52:29.900
until you're actually ready to make a connection.

00:52:29.900 --> 00:52:33.460
Embrace the fact that networking is asynchronous.

00:52:33.460 --> 00:52:40.000
It can seem like a pain if you're used to non-network
programming where the computer is in charge

00:52:40.000 --> 00:52:42.310
where you say do this and then do this and then do this

00:52:42.310 --> 00:52:47.180
and you'll write nice sequential
programs the way we all learn to program.

00:52:47.180 --> 00:52:53.280
But networking like graphical user interfaces
is one area where you are not in charge.

00:52:53.280 --> 00:52:57.460
In GUIs, the user is deciding what
button to click next and in networking,

00:52:57.460 --> 00:53:01.150
the environment around you is deciding
what's going to happen next.

00:53:01.150 --> 00:53:06.210
And fighting against that is really unproductive.

00:53:06.210 --> 00:53:11.370
Pay attention to the multitasking
issues that Rory told you about.

00:53:11.370 --> 00:53:16.650
You have to pay attention to the network sockets
being broken because otherwise when your app resumes,

00:53:16.650 --> 00:53:22.270
it may not work and with no easy way for the user to quit
it, we don't want to be in a situation where users end

00:53:22.270 --> 00:53:29.250
up rebooting their phone because they don't know
how to fix the broken apps and use the Bonjour logo.

00:53:29.250 --> 00:53:35.980
This is the contact information
for our technology evangelists.

00:53:35.980 --> 00:53:39.460
We have documentation on the webpage.

00:53:39.460 --> 00:53:41.870
In the interest of full disclosure,
I was co-author on this book.

00:53:41.870 --> 00:53:45.940
This is the O'Reilly Zero Configuration
Networking book which is a--

00:53:45.940 --> 00:53:56.940
I'd like to say it's a more cohesive form of documentation
in the sense that you can read it safely in the bathtub.

00:53:58.990 --> 00:54:09.280
Later today we have the iPhone OS networking sessions
which I highly recommend, the Core OS Networking overview,

00:54:09.280 --> 00:54:14.700
you can watch on video and the Multitasking on
iPhone OS is going to be repeated on Friday.

