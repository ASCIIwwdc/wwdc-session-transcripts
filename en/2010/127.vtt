WEBVTT

00:00:07.470 --> 00:00:08.500
>> All right.

00:00:08.500 --> 00:00:09.450
Good morning everyone.

00:00:09.450 --> 00:00:10.000
[ Applause ]

00:00:10.000 --> 00:00:13.700
Welcome to Customizing Maps with Overlays.

00:00:13.700 --> 00:00:14.560
Thank you.

00:00:14.560 --> 00:00:18.990
I'm James Howard, I'm a software engineer on
the Map Kit Team, and I'm going to show you

00:00:18.990 --> 00:00:26.020
in this presentation today how to display geographic
data that covers an area on top of your map.

00:00:28.910 --> 00:00:33.870
So we're going to start with just a quick review of Map Kit
so we see where we came from, and then we're going to go

00:00:33.870 --> 00:00:37.260
into what's new in Map Kit, which is, primarily, overlays.

00:00:37.260 --> 00:00:40.120
And for this session I've prepared five demos.

00:00:40.120 --> 00:00:46.780
At this time I'd like you to go to the session
website, so if you go into session list and follow it

00:00:46.780 --> 00:00:51.250
down to this session, you'll see there's
a list of the sample code on the bottom.

00:00:51.250 --> 00:00:56.310
If you can, and you have your laptop, I'd encourage you
to go download that sample code so you can follow along.

00:00:56.310 --> 00:00:59.420
And I think the sample codes is going to be
really useful to you in your development.

00:00:59.420 --> 00:01:04.320
So get a hold of that right now.

00:01:04.320 --> 00:01:07.090
So while you're downloading that, let's do a quick review.

00:01:07.090 --> 00:01:08.360
What is Map Kit?

00:01:08.360 --> 00:01:10.780
Originally, it came out in iPhone OS 3.0.

00:01:10.780 --> 00:01:13.240
It lets you put a map in your application.

00:01:13.240 --> 00:01:15.150
You can programmatically control that map.

00:01:15.150 --> 00:01:17.770
So have it pan around.

00:01:17.770 --> 00:01:23.380
The user can interact with it by pinching or
panning, double tapping, two finger tapping.

00:01:23.380 --> 00:01:25.170
You can annotate the map however you like.

00:01:25.170 --> 00:01:30.160
So you can put pins or other annotations,
custom views, on top of map.

00:01:30.160 --> 00:01:31.560
And finally, there's reverse geocoding.

00:01:31.560 --> 00:01:35.790
So reverse geocoding is, you have a
point, so a latitude and longitude,

00:01:35.790 --> 00:01:38.360
and you want to find out what is the
address that corresponds to that.

00:01:38.360 --> 00:01:40.050
So that's reverse geocoding.

00:01:40.050 --> 00:01:45.460
So I've put together a couple of
videos here illustrating these points.

00:01:45.460 --> 00:01:58.880
So there's pan and zoom; annotations; user locations, so
you get that blue gem representing the user's location

00:01:58.880 --> 00:02:01.400
so we integrate with Core Location to do that.

00:02:01.400 --> 00:02:07.000
And then there's reverse geocoding, so we
dropped pin at that point and then figured

00:02:07.000 --> 00:02:08.500
out what is the address that corresponds to it.

00:02:08.500 --> 00:02:10.400
So you can do that all last year.

00:02:10.400 --> 00:02:12.420
Let's move on to what you can do this year.

00:02:12.420 --> 00:02:16.710
Overlays. So this is -- you have an area
and you want to draw something in it.

00:02:16.710 --> 00:02:22.360
An example of this is like a transit map or a
traffic overlay or national park overlay or a state

00:02:22.360 --> 00:02:27.920
or local boundaries, any of those sorts of things weren't
really possible to do with Map Kit before, now they are.

00:02:27.920 --> 00:02:32.910
We also have draggable annotations, so it's much easier
to put a pin on the map and allow the user to press

00:02:32.910 --> 00:02:34.680
and hold and then drag that thing around.

00:02:34.680 --> 00:02:35.630
So that's really nice.

00:02:35.630 --> 00:02:41.010
We also have a handful of new delegate messages that
make it easier to keep track of the user location,

00:02:41.010 --> 00:02:44.000
as well as when your annotations
are selected and deselected.

00:02:44.000 --> 00:02:46.120
So that's what's new.

00:02:46.120 --> 00:02:48.760
So on to annotations and overlays.

00:02:48.760 --> 00:02:54.200
So if you're familiar with Map Kit, if you've
programmed with it before, you know about annotations.

00:02:54.200 --> 00:02:55.680
They represent a single point.

00:02:55.680 --> 00:02:57.910
So we have this pin here stuck in California.

00:02:57.910 --> 00:03:02.340
It corresponds to a single latitude and longitude.

00:03:02.340 --> 00:03:05.000
New in iOS 4 is overlays.

00:03:05.000 --> 00:03:09.510
So I've put an overlay here that represents
the state of California, so it's this --

00:03:09.510 --> 00:03:14.720
[ Applause ]

00:03:14.720 --> 00:03:15.520
Yeah, it's great.

00:03:15.520 --> 00:03:16.730
It's really great.

00:03:16.730 --> 00:03:19.450
It's even better when you see it in action,
which I'm going to get to in just a moment.

00:03:19.450 --> 00:03:25.240
So yeah, it's covering this area, so as you pinch
on the map, it tracks the map and sticks with it.

00:03:25.240 --> 00:03:27.680
So it's really a very seamless experience.

00:03:27.680 --> 00:03:29.650
So that's overlays.

00:03:29.650 --> 00:03:33.800
So we have a handful of built in
overlays, so let me just run through those.

00:03:33.800 --> 00:03:37.520
There's circles, so you have a center and a radius.

00:03:37.520 --> 00:03:39.180
This is good for drawing.

00:03:39.180 --> 00:03:43.330
You can draw things like you have an
accuracy or just any sort of radius

00:03:43.330 --> 00:03:46.720
that you want to draw about some center, so circles.

00:03:46.720 --> 00:03:53.260
There's polylines, so if you have a route or a
path, a list of points, you can draw a polyline.

00:03:53.260 --> 00:03:57.730
Polygons. I have the polygon outlining
the Presidio, in San Francisco here.

00:03:57.730 --> 00:04:01.300
We also support polygons that have
cutouts in them, so Arlington,

00:04:01.300 --> 00:04:05.100
Texas is an example of a place that a polygon has a cutout.

00:04:05.100 --> 00:04:06.680
So we do that as well.

00:04:06.680 --> 00:04:08.300
And then finally, there's custom overlays.

00:04:08.300 --> 00:04:12.050
So you can really draw whatever
geographic data you want on top of the map.

00:04:12.050 --> 00:04:18.950
So this is an example of earthquake danger in
the United States that I've drawn on the map.

00:04:18.950 --> 00:04:20.250
So layer ordering.

00:04:20.250 --> 00:04:24.500
So initially when you put an MKMapView in
your application, you have the base map.

00:04:24.500 --> 00:04:31.890
So this is base map imagery, and then above that go
any overlays that you add so they sit right on top

00:04:31.890 --> 00:04:35.260
of map, and then above that are any annotations.

00:04:35.260 --> 00:04:38.430
So the thing to take away from this
is your annotations are always on top

00:04:38.430 --> 00:04:41.990
of your overlays are always on top of the base map.

00:04:41.990 --> 00:04:44.500
So how do you add an overlay to the map?

00:04:44.500 --> 00:04:48.530
Just like with annotations, you must add in model objects.

00:04:48.530 --> 00:04:51.550
So we have model objects corresponding to all our overlays.

00:04:51.550 --> 00:04:53.690
We add those to the map initially using addOverlay.

00:04:53.690 --> 00:04:57.970
So in this example we have a circle, we set
it with a center coordinate and a radius,

00:04:57.970 --> 00:05:01.280
so this is describing where in the world this circle lives.

00:05:01.280 --> 00:05:02.700
We add that to the map.

00:05:02.700 --> 00:05:05.430
That doesn't necessarily put it on screen.

00:05:05.430 --> 00:05:10.410
It's only when the map decides, "OK, this thing is getting
close to being in view, or it's now going to be in view,"

00:05:10.410 --> 00:05:15.420
at that point, we're going to call back to you on your Map
Views delegate, and you're going to get viewForOverlay.

00:05:15.420 --> 00:05:20.460
So at that point we're going to create the corresponding
view, so because we put an MKCircle in there,

00:05:20.460 --> 00:05:26.830
we need an MKCircleView, customize how that
looks, so let's make it red, and return that.

00:05:26.830 --> 00:05:28.740
So let's do a demo.

00:05:28.740 --> 00:05:37.080
So with my first demo, I'm just going to show
you the very like most basic use of this.

00:05:37.080 --> 00:05:37.820
So let me build and run.

00:05:37.820 --> 00:05:39.780
All right.

00:05:42.710 --> 00:05:47.890
So I've got the Presidio there, and I've got
a little walking route actually from here

00:05:47.890 --> 00:05:49.710
at the Moscone Center over to Golden Gate Park.

00:05:49.710 --> 00:05:56.840
And what I want to show you is, as you use your pinches
on this and zooms in, you get very nice, seamless zooming.

00:05:56.840 --> 00:05:59.300
It's as though it's a part of the map.

00:05:59.300 --> 00:06:03.470
So it's not like it's removed and then redrawn, it's as
though it's part of it, and if you were to double tap

00:06:03.470 --> 00:06:07.510
and zoom in you get a seamless
cross fading with your overlays.

00:06:07.510 --> 00:06:12.550
[ Applause ]

00:06:12.550 --> 00:06:13.510
Yeah. It's nice, huh.

00:06:13.510 --> 00:06:15.550
[ Laughter ]

00:06:15.550 --> 00:06:19.490
And also, as you zoom in and pan
along these things, they reveal.

00:06:19.490 --> 00:06:21.600
So it's really as though it's a part of the map.

00:06:21.600 --> 00:06:23.530
It's a very seamless experience.

00:06:23.530 --> 00:06:25.590
So what's the code necessary to do this?

00:06:25.590 --> 00:06:28.560
Let's hop into the view controller here really quickly.

00:06:28.560 --> 00:06:32.590
Let's hide the implementation of viewForOverlay
for a moment, just look at adding overlays.

00:06:32.590 --> 00:06:35.390
So I have a list of points comprising that Presidio.

00:06:35.390 --> 00:06:41.070
So I create a polygon corresponding to those
points, and then I simply add it to the map.

00:06:41.070 --> 00:06:43.110
And I do the same thing for the walking lines.

00:06:43.110 --> 00:06:45.500
So I create a polyline for that, add that to the map.

00:06:45.500 --> 00:06:47.470
So now I'm registering these two overlays with the map.

00:06:47.470 --> 00:06:50.540
It doesn't mean they're going to be displayed
right away, just that the map is aware

00:06:50.540 --> 00:06:52.470
that they live in that part one of the world.

00:06:52.470 --> 00:06:57.840
And then, finally, I'm going to position the map so that
those two things are both visible, and at that point,

00:06:57.840 --> 00:07:00.740
since the map is being positioned so
they're visible, we're going to need views.

00:07:00.740 --> 00:07:04.560
So viewForOverlay is going to be called,
and then we're going to inspect, "OK,

00:07:04.560 --> 00:07:06.310
for each of these overlays, what kind is it?"

00:07:06.310 --> 00:07:09.090
If it's a polyline, then we need a polylineView.

00:07:09.090 --> 00:07:11.510
So we do that.

00:07:11.510 --> 00:07:13.010
Return the corresponding polylineView.

00:07:13.010 --> 00:07:18.680
And if it's a polygon, return the corresponding polygonView.

00:07:18.680 --> 00:07:21.680
So just one more time.

00:07:21.680 --> 00:07:23.450
Build and run.

00:07:26.500 --> 00:07:28.160
And there we have them.

00:07:28.160 --> 00:07:32.790
So I've got one more demo I want to show you before
we go back to the slides, and this is a CAML Viewer.

00:07:32.790 --> 00:07:37.620
So we don't have CAML viewing built into
Map Kit, but I have this nice little sample.

00:07:37.620 --> 00:07:39.230
And you can take this and use this in your program.

00:07:39.230 --> 00:07:40.460
So what is CAML?

00:07:40.460 --> 00:07:44.510
CAML is XML file format for describing
geographic information.

00:07:44.510 --> 00:07:46.200
I have a couple of CAML files here.

00:07:46.200 --> 00:07:48.370
Let me just pop one of them open,
you can see what it looks like.

00:07:48.370 --> 00:07:56.230
So this is a route between Apple's campus
and Antonio's Nut House in Palo Alto.

00:07:56.230 --> 00:07:59.730
It's a bicycling route that I actually
exported from Google's website.

00:07:59.730 --> 00:08:03.500
And this CAML view, let me just build and run it.

00:08:03.500 --> 00:08:07.450
[ Building code ]

00:08:07.450 --> 00:08:09.550
Oh, that's not the one I wanted to show.

00:08:09.550 --> 00:08:12.180
Let's just switch this route.

00:08:12.180 --> 00:08:18.240
So there we go.

00:08:18.240 --> 00:08:23.710
We're displaying CAML, and I've got the way points
along here, and the route that we're showing.

00:08:23.710 --> 00:08:28.820
So I think that's a pretty nice way to display CAML, and if
you've downloaded the sample code, you'll be able to use it

00:08:28.820 --> 00:08:31.670
to display CAML in your own programs as well.

00:08:31.670 --> 00:08:34.670
So just really quick, let's look at the interface for this.

00:08:34.670 --> 00:08:40.360
You can parse a CAML file at a URL or a path, and then
you're going to get a list back of all the overlays

00:08:40.360 --> 00:08:43.210
and all the points, or all the annotations in that.

00:08:43.210 --> 00:08:48.400
And so how we use this in the view controller
is, we parse that CAML file in our bundle,

00:08:48.400 --> 00:08:51.830
so you already saw me parsing a different
one, and I just switched over to this one.

00:08:51.830 --> 00:08:56.550
Parse that, then add all the overlays,
add all the annotations,

00:08:56.550 --> 00:09:04.600
fly the map to an area that covers all those points, and
then finally, when we need to get a view for an overlay

00:09:04.600 --> 00:09:08.410
or a view for an annotation, we just
proxy that over to the CAML parser.

00:09:08.410 --> 00:09:12.350
So this is a nice way to display some
basic CAML files in your applications.

00:09:12.350 --> 00:09:16.680
Let me just switch that back to the other one.

00:09:16.680 --> 00:09:21.140
This is -- this other CAML file
is a running route that I got

00:09:21.140 --> 00:09:24.720
from our Map Kit Evangelist Mark
Malone who's sitting over there.

00:09:24.720 --> 00:09:27.830
He did a run, and he has a little, like, runner's GPS,

00:09:27.830 --> 00:09:32.460
and so it exported this CAML file,
so this is a run around a park in Japan.

00:09:32.460 --> 00:09:34.350
So pretty neat.

00:09:37.000 --> 00:09:39.500
Yeah. So that's the CAML Viewer.

00:09:39.500 --> 00:09:45.720
[ Applause ]

00:09:45.720 --> 00:09:48.630
So just to summarize: What is the
process for adding overlays?

00:09:48.630 --> 00:09:54.320
We take the model object and we add it to the map, and then
when the map is ready, it's going to call us and ask us

00:09:54.320 --> 00:09:56.350
for a view, and we provide the corresponding view.

00:09:56.350 --> 00:09:59.110
So very similar to the process for adding annotations.

00:09:59.110 --> 00:10:00.820
All right.

00:10:00.820 --> 00:10:04.190
So let's move on to the meat of it: Custom overlays.

00:10:04.190 --> 00:10:09.960
So if you want to implement a custom overlay, you need to
have a model object that implements the MKOverlay protocol.

00:10:09.960 --> 00:10:13.800
And the property that you need to
implement for this is the boundingMapRect.

00:10:13.800 --> 00:10:17.250
So you need to tell Map Kit, what
is the bounds of this thing.

00:10:17.250 --> 00:10:18.430
Where does it live in the world?

00:10:18.430 --> 00:10:20.060
So you return a boundingMapRect.

00:10:20.060 --> 00:10:22.880
So this is a new type, MKMapRect.

00:10:22.880 --> 00:10:27.780
I'm going to describe what this type is, but
it's a new coordinate system for Map Kit in iOS 4

00:10:27.780 --> 00:10:32.140
and that's the Core Net system you're
going to use to return the boundingMapRect.

00:10:32.140 --> 00:10:36.890
And then for the view, you're going to draw just a part
of the view at a time, so Map Kit's going to say, "OK,

00:10:36.890 --> 00:10:40.580
draw -- draw this MapRect at this zoom scale."

00:10:40.580 --> 00:10:42.130
So you're not necessarily drawing the whole thing.

00:10:42.130 --> 00:10:48.440
If you think about -- think back to that example of
the state of California, the outline of California,

00:10:48.440 --> 00:10:50.800
if you zoomed all the way in, that thing would be enormous.

00:10:50.800 --> 00:10:54.950
It would be thousands perhaps millions of
screen points that it's really consuming

00:10:54.950 --> 00:10:56.250
if you were to scroll along the length of that.

00:10:56.250 --> 00:10:57.560
So we can't draw that all at once.

00:10:57.560 --> 00:10:59.610
You can't make a view that's that big.

00:10:59.610 --> 00:11:04.890
So we cut it up into tiles, and we draw it just
the tiles corresponding to the area that we need.

00:11:04.890 --> 00:11:07.170
So that's drawMapRect.

00:11:07.170 --> 00:11:08.360
And there's one thing you need to know.

00:11:08.360 --> 00:11:14.380
So when I said -- we're introducing MKMapPoint
and MKMapRect as a new coordinate system,

00:11:14.380 --> 00:11:16.670
you need to know about the map projection that we use.

00:11:16.670 --> 00:11:24.430
So in Map Kit we use the Mercator projection to
map the 3D sphere of the Earth onto a 2D map.

00:11:24.430 --> 00:11:31.990
And this has a property that, as you go towards the pole,
the map is stretched in the latitudinal or the y direction.

00:11:31.990 --> 00:11:36.130
So this image up here sort of illustrates that.

00:11:36.130 --> 00:11:42.770
These circles are all the same size; they're all 500
kilometers in diameter or 250 kilometers in radius.

00:11:42.770 --> 00:11:46.820
And they're all spaced equally;
they're all 16 degrees apart.

00:11:46.820 --> 00:11:48.230
So how do you take advantage of this?

00:11:48.230 --> 00:11:54.060
You need to use MKMapPoint and MKMapRect to convert your
latitudes and longitudes and your distances into map points,

00:11:54.060 --> 00:11:59.210
which you can then draw, so you get -- you'll get
a nice overlay that corresponds to the base map.

00:11:59.210 --> 00:12:00.550
Because that's really what you want to do.

00:12:00.550 --> 00:12:03.550
You don't want to just draw something that's
not going to line up with the base map.

00:12:03.550 --> 00:12:05.180
This is real geographical data.

00:12:05.180 --> 00:12:09.190
It corresponds to somewhere in the
world, and so it needs to line up.

00:12:09.190 --> 00:12:10.050
So how do you do this?

00:12:10.050 --> 00:12:11.630
You use MKMapPoint.

00:12:11.630 --> 00:12:14.660
So your overlays must be drawn using these.

00:12:14.660 --> 00:12:18.860
And they can represent any point on the map, and
they have a linear relationship with screen points.

00:12:18.860 --> 00:12:23.990
So whereas latitude and longitude don't have a linear
relationship with screen points, MKMapPoint does.

00:12:23.990 --> 00:12:30.290
And MKMapPoint is a double precision type, so it has
sufficient precision to represent anywhere in the world.

00:12:30.290 --> 00:12:33.850
And you just use MKMapPoint for coordinate
to convert your latitude and longitudes

00:12:33.850 --> 00:12:37.320
into map points which you can then go ahead and draw.

00:12:37.320 --> 00:12:41.020
So one thing else I want to talk about is gridded data.

00:12:41.020 --> 00:12:45.540
So I'm going to show a demo in just
a minute of earthquake hazard data.

00:12:45.540 --> 00:12:47.740
I showed that just as a screen shot earlier.

00:12:47.740 --> 00:12:53.680
And this comes from the U.S. Geological Survey in a
regular grid, so it's every .05 degrees of latitude

00:12:53.680 --> 00:12:58.570
and longitude they have a square, and say, what is
the earthquake hazard likelihood in that square.

00:12:58.570 --> 00:13:03.660
So if you think about that it looks something like
this, like, you know, you can see in the middle here,

00:13:03.660 --> 00:13:07.360
this is a high hazard area, and then around that it's not.

00:13:07.360 --> 00:13:10.950
So in this case these are 10 degree square.

00:13:10.950 --> 00:13:12.090
What does that look like on a sphere?

00:13:12.090 --> 00:13:16.740
So depending on what angle you're looking at the sphere
of the Earth at, it may even look like a trapezoid.

00:13:16.740 --> 00:13:20.640
So even though it was a square in terms of
thinking about it in latitude and longitude,

00:13:20.640 --> 00:13:23.910
it's not necessarily a square depending
on how you look at the Earth.

00:13:23.910 --> 00:13:29.850
And it's not drawn as a square on the map, it's actually
a rectangle, but by just converting the corner coordinates

00:13:29.850 --> 00:13:34.890
to map points and then creating a MapRect
out of that, you'll get the correct MapRect

00:13:34.890 --> 00:13:36.710
that corresponds to the area that you're trying to draw.

00:13:36.710 --> 00:13:38.500
So let me show you a demo of how this works.

00:13:38.500 --> 00:13:47.060
[ Searching for demo ]

00:13:47.060 --> 00:13:47.750
There it is.

00:13:47.750 --> 00:13:53.260
So let me just build and run this
so you can see what it looks like.

00:13:53.260 --> 00:14:02.130
So I downloaded this off of the U.S. Geological
Survey website, and it's that .05 degree grid,

00:14:02.130 --> 00:14:06.920
so you can see that in California here,
we have a high earthquake likelihood.

00:14:06.920 --> 00:14:10.230
This is -- this is the edge of the data,
it's just the continental United States,

00:14:10.230 --> 00:14:12.390
so you can see there's sort of a sharp line there.

00:14:12.390 --> 00:14:15.430
I assume that out in the Pacific Ocean they
also have a high earthquake likelihood,

00:14:15.430 --> 00:14:20.280
but the U.S. just doesn't sample that,
so this is what we're displaying.

00:14:20.280 --> 00:14:23.720
And this is made up of tiny little
squares of latitude and longitudes.

00:14:23.720 --> 00:14:27.570
Those things actually become rectangles
when they're MapRects.

00:14:27.570 --> 00:14:30.430
So let me just show you my model object.

00:14:30.430 --> 00:14:35.010
So this is my object that's implementing
MKOverlay, and there's a bunch of coding here.

00:14:35.010 --> 00:14:40.050
There's I think a little over 600,000 earthquake
samples in the data file that we're reading.

00:14:40.050 --> 00:14:46.240
But when we actually get down to an individual one, we're
going to have, basically, an upper left and a lower right

00:14:46.240 --> 00:14:50.450
in terms of coordinates, so these are CL
location coordinates 2D, latitude and longitude.

00:14:50.450 --> 00:14:55.680
And we just need to convert that into a MapRect, so we find
the upper left and the lower right in terms of map points,

00:14:55.680 --> 00:15:00.830
and we convert that into a MapRect, and so that's the
thing that we're actually going to be able to draw.

00:15:00.830 --> 00:15:07.240
So if we flip over to the implementation of
the view, we're going to call that method,

00:15:07.240 --> 00:15:08.950
and so this is the method that goes in there.

00:15:08.950 --> 00:15:12.940
There's a bit of code for doing a little nearest
neighbor sub-sampling, because when we're zoomed way out,

00:15:12.940 --> 00:15:17.740
we don't need to display all 600,000 samples, we
can display a little less and still look fine.

00:15:17.740 --> 00:15:20.410
But basically what it's doing is
the code I just highlighted.

00:15:20.410 --> 00:15:25.450
So we get that list of earthquake values and
their boundaries, and then for each of those,

00:15:25.450 --> 00:15:29.650
we can just loop over them, so we have a boundary,
and we have the color that we need to color that.

00:15:29.650 --> 00:15:34.260
And at that point, now that we have as a MapRect,
we can just convert it into local coordinates,

00:15:34.260 --> 00:15:41.210
so this is a linear relationship between our MapRect and
our local coordinates, it's just offset a little bit,

00:15:41.210 --> 00:15:44.940
and at that point, we have a CGRect
which we can finally draw.

00:15:44.940 --> 00:15:50.640
So that's how you would go from latitude and longitude
to map points to a Rect that you can finally draw.

00:15:50.640 --> 00:15:56.740
And just to show you in the view controller how this
is used, it's just like with the built in overlay.

00:15:56.740 --> 00:16:04.510
We create our hazard map which is a model class, we add
it to the map, and then provide the corresponding view.

00:16:04.510 --> 00:16:06.540
So let me just run this one more time.

00:16:06.540 --> 00:16:14.270
And this time what I want to do is I want to zoom in really
close in on this, so .05 degrees seems pretty accurate,

00:16:14.270 --> 00:16:19.820
but you can actually zoom in way farther than a .05
degree resolution map because you actually start to see --

00:16:19.820 --> 00:16:23.450
look, here's the actual rectangles
in that data they've sampled,

00:16:23.450 --> 00:16:26.230
and what you can see is they're
not precisely squares anymore,

00:16:26.230 --> 00:16:29.200
they've become rectangles when they're projected on the map.

00:16:29.200 --> 00:16:32.320
But the nice thing is because we're doing
this, we're converting the map points,

00:16:32.320 --> 00:16:36.880
we know that this area right here, this is really what they
meant when they said, this is the sample that corresponds

00:16:36.880 --> 00:16:41.220
to that, so our data that we got from
the USGS is lining up with our base map.

00:16:41.220 --> 00:16:43.140
So that is the earthquake hazard map demo.

00:16:43.140 --> 00:16:45.000
So we'll quit that.

00:16:45.000 --> 00:16:45.080
[ Applause ]

00:16:45.080 --> 00:16:47.170
Thank you.

00:16:47.170 --> 00:16:50.780
[ Applause ]

00:16:50.780 --> 00:16:52.340
Close this.

00:16:52.340 --> 00:16:56.870
And let me go back to the slides.

00:16:56.870 --> 00:17:01.830
So subclassing MKOverlayView, that's the
first subclass I showed of MKOverlayView.

00:17:01.830 --> 00:17:05.190
There's a few things to know about doing this.

00:17:05.190 --> 00:17:10.860
The most important of which is drawing is asynchronous,
so that drawMapRect method is coming in asynchronously.

00:17:10.860 --> 00:17:20.160
In that demo it was pretty simple because the data that
we loaded was -- it was fixed, it didn't change over time.

00:17:20.160 --> 00:17:23.570
So we loaded off of disk, had it
in memory, and it's not mutable.

00:17:23.570 --> 00:17:26.540
So that's nice, we don't need to
do any locking on that data.

00:17:26.540 --> 00:17:30.990
But if your data does change, you're going to need to
protect it with a lock because you drawing is asynchronous.

00:17:30.990 --> 00:17:35.430
There may be one thread calling drawMapRect, there
may be two threads, there may be multiple threads,

00:17:35.430 --> 00:17:38.540
but none of those are your main application
thread, they're a background thread created

00:17:38.540 --> 00:17:41.070
by Map Kit, so you need to be aware of that.

00:17:41.070 --> 00:17:46.600
I use the Core Graphics drawing methods as you saw in there
to draw, so you're given a CG context to draw that into.

00:17:46.600 --> 00:17:50.760
The UIKit graphic context is so
-- is not automatically available,

00:17:50.760 --> 00:17:53.270
so if you using any of the UIKit drawing functions,

00:17:53.270 --> 00:17:59.310
you need to push that graphics context using
the UIGraphics content -- UIGraphicsPushContext.

00:17:59.310 --> 00:18:04.460
I recommend just using the Core Graphics drawing API, but
if there's something in UIKit that you really want to use,

00:18:04.460 --> 00:18:09.450
and you know it's thread safe, go ahead
and use this to make that available.

00:18:09.450 --> 00:18:14.580
And then the other nice thing is, there is -- what you've
already drawn are cached, so as we zoomed in and panned

00:18:14.580 --> 00:18:20.380
around on that map, what we've drawn, so the list of
rectangles, colored rectangles that we'd already drawn,

00:18:20.380 --> 00:18:24.410
when we pan back to them, they don't have to be
drawn again, it's stored in the cache for you.

00:18:24.410 --> 00:18:29.480
You can invalidate that using setNeedsDisplayInMapRect,
but do so sparingly.

00:18:29.480 --> 00:18:34.770
If it hasn't changed, there's no point invalidating,
you want to keep that cache around as long as possible.

00:18:34.770 --> 00:18:36.580
So mutable overlays.

00:18:36.580 --> 00:18:40.460
I know a lot of people have asked on the
forums or in bug reports, "How do you do this?"

00:18:40.460 --> 00:18:44.470
Well, as you know, or I'm telling you now,

00:18:44.470 --> 00:18:48.630
all of the overlays in Map Kit are
immutable, they don't change with time.

00:18:48.630 --> 00:18:51.090
So once you've created one and add
it to the map, it doesn't change.

00:18:51.090 --> 00:18:52.250
But you want to do it.

00:18:52.250 --> 00:18:55.530
Right? Well, I know at least some of you want to do this.

00:18:55.530 --> 00:18:58.890
So to give mutability, you're going
need to build your own custom overlay.

00:18:58.890 --> 00:19:01.790
Fortunately I've got sample code of
available for this session that does it,

00:19:01.790 --> 00:19:04.360
and we're going to get into that in just a moment.

00:19:04.360 --> 00:19:06.910
And as I mentioned, we're only
going to want to update the part

00:19:06.910 --> 00:19:11.370
of the map that's changed when
we -- when we mutate the data.

00:19:11.370 --> 00:19:15.100
And finally, because drawing is asynchronous,
so drawMapRect comes in asynchronously,

00:19:15.100 --> 00:19:18.600
if you're updating from the main thread, you
need to protect your model data with a lock.

00:19:18.600 --> 00:19:21.500
So let me show you a demo of a mutable overlay.

00:19:21.500 --> 00:19:32.260
[ Loading demo ]

00:19:32.260 --> 00:19:34.430
So I call this the "Breadcrumb Sample."

00:19:34.430 --> 00:19:37.440
It's an app for Hansel and Gretel.

00:19:37.440 --> 00:19:45.260
And they're going to -- they've upgraded, they've got
iPhones now, so they don't use breadcrumbs anymore.

00:19:45.260 --> 00:19:49.710
And they've also upgraded -- they don't walk, they
have a BMW, and they're driving up the 280 here,

00:19:49.710 --> 00:19:51.910
and they're leaving a nice trail behind them.

00:19:51.910 --> 00:19:55.950
So this is accomplished by using a mutable overlay.

00:19:55.950 --> 00:19:58.800
And I've called that the "Crumb Path."

00:19:58.800 --> 00:20:00.890
So to show the implementation of this.

00:20:00.890 --> 00:20:06.230
This is my model object, it implements
MKOverlay, and it's storing a list of points

00:20:06.230 --> 00:20:09.940
which can be modified and is protected
with a read-write lock.

00:20:09.940 --> 00:20:15.560
So when we get our first location update, we're going
to create it about that center coordinate, and, then,

00:20:15.560 --> 00:20:19.720
for each subsequent location update,
we're going to add a coordinate.

00:20:19.720 --> 00:20:23.420
And so at that point we're going
to need to acquire the write lock.

00:20:23.420 --> 00:20:26.670
And then when we're drawing, we'll get the read lock.

00:20:26.670 --> 00:20:28.840
So we may have multiple drawing threads.

00:20:28.840 --> 00:20:32.360
They can all draw simultaneously as
long as they're holding the read lock,

00:20:32.360 --> 00:20:35.590
and so then that read lock protects this list of points.

00:20:35.590 --> 00:20:37.500
So let me show you just in the view here.

00:20:37.500 --> 00:20:42.600
[ View running ]

00:20:42.600 --> 00:20:45.600
We're going to acquire that read lock.

00:20:45.600 --> 00:20:49.860
We're going to create a path based on those
points, and then we're going to let go

00:20:49.860 --> 00:20:51.640
of the read lock, and go ahead and start that path.

00:20:51.640 --> 00:20:56.920
So there's one method in here -- this is nice helper method
that you'll be able to use in your own programs independent

00:20:56.920 --> 00:21:00.060
of this even, and this is this
Create Path for Points method.

00:21:00.060 --> 00:21:08.630
This guy -- given a list of points and a clipping of MapRect
and a map zoom scale, this will allow you to create a CGpath

00:21:08.630 --> 00:21:10.180
that is the fastest way to draw that path.

00:21:10.180 --> 00:21:11.910
So this is -- it's doing two things.

00:21:11.910 --> 00:21:13.360
One is it's clipping.

00:21:13.360 --> 00:21:18.430
So it's saying, "Look, if we have 5000 points that
we're trying draw, and there's only 3 points that are

00:21:18.430 --> 00:21:21.350
in this MapRect, we only need to draw those 3 points."

00:21:21.350 --> 00:21:23.140
And then it's also doing simplification.

00:21:23.140 --> 00:21:28.730
So if you have 5000 map points again, and you're trying
to draw them into an area that's 100 screen points --

00:21:28.730 --> 00:21:33.110
and we know that because we're given the zoom scale,
and we know the zoom scale has a linear relationship

00:21:33.110 --> 00:21:37.840
with screen points -- we can say, "Look, we don't
need to draw 5000 points into 100 point area.

00:21:37.840 --> 00:21:40.710
We can do some simplification, we can skip some points.

00:21:40.710 --> 00:21:44.450
And get something that looks just
as good but draws much quicker."

00:21:44.450 --> 00:21:48.550
So there's -- there's this nice method that you'll
be able to incorporate into your own programs.

00:21:48.550 --> 00:21:53.640
And, then, just to flip over to the implementation
of the view controller, so we're using --

00:21:53.640 --> 00:21:58.220
as I mentioned earlier, we have a new delegate
callback for when that blue dot updates.

00:21:58.220 --> 00:22:03.500
This is going to be getUpdateToUserLocation, and when
that comes in, we're going to look at the user location,

00:22:03.500 --> 00:22:07.790
and if it's the first one, we're going to
create our crumb path, so this is our MKOverlay

00:22:07.790 --> 00:22:10.190
of model object, and we're going to add that to the map.

00:22:10.190 --> 00:22:15.270
And we're also going to zoom the
map to show the user's location.

00:22:15.270 --> 00:22:18.290
And then on subsequent updates, we're not going to move
the map, but what we are going to do is we're going

00:22:18.290 --> 00:22:24.720
to add a coordinate to that crumb path, so this is going
to acquire that write lock, add it to the list of points,

00:22:24.720 --> 00:22:29.620
and then it's going to release the write lock when it's
done, and it's going to give us back an updateRect,

00:22:29.620 --> 00:22:32.600
so this is this is just had area that's changed.

00:22:32.600 --> 00:22:39.970
And if it's not null -- oops, if it's not null, then
what we can do -- here's another nice one liner.

00:22:39.970 --> 00:22:46.160
We can find the current zoom scale, figure out
how wide we draw that line at that zoom scale,

00:22:46.160 --> 00:22:51.340
and we can just outset our updateRect by that, and
then now let's just update that invalidated area.

00:22:51.340 --> 00:22:55.490
So if we're going to build and run this again...

00:22:58.060 --> 00:23:02.950
So what's nice is, this guy's moving along, and
it's exposing a little bit more of that line.

00:23:02.950 --> 00:23:05.500
We're only redrawing just a tiny little part of the screen.

00:23:05.500 --> 00:23:12.990
We don't have to redraw all of this every time that updates,
so it makes it much more efficient to do it this way.

00:23:14.640 --> 00:23:18.500
So that's how you do a mutable overlay using Map Kit.

00:23:18.500 --> 00:23:23.410
[ Applause ]

00:23:23.410 --> 00:23:25.300
So what did we learn in that demo?

00:23:25.300 --> 00:23:27.730
You can do a mutable polyline.

00:23:27.730 --> 00:23:33.080
And the thing to take away from this is, I used a single
custom overlay rather than adding and re-adding a polyline.

00:23:33.080 --> 00:23:35.900
I know, I'd seen some bug reports
and, like, some forum posts.

00:23:35.900 --> 00:23:39.140
People were, like, "Well, every second,
I'm going to create a new MKPolyline.

00:23:39.140 --> 00:23:41.460
I'm going to remove my old one, I'm going to add a new one."

00:23:41.460 --> 00:23:42.380
That's not very efficient.

00:23:42.380 --> 00:23:46.610
It's much more efficient to use the
scheme that I've shown in the sample.

00:23:46.610 --> 00:23:48.780
And the data has to be protected with a lock.

00:23:48.780 --> 00:23:52.820
I'm using read-write lock because it's
very convenient for this sort of data.

00:23:52.820 --> 00:23:57.350
DrawMapRect is asynchronous, so you
need to protect your data with a lock

00:23:57.350 --> 00:24:00.280
because you're updating it from the main thread.

00:24:00.280 --> 00:24:02.720
And finally, simplify and clip to your list of points.

00:24:02.720 --> 00:24:09.250
Core Graphics will do clipping for you, so when you're asked
drawMapRect, there is already a clipping boundary set up,

00:24:09.250 --> 00:24:16.200
but it's a lot faster if you just avoid
creating such a large path in the first place.

00:24:16.200 --> 00:24:18.370
Yes. Raster map overlays.

00:24:18.370 --> 00:24:20.280
So I know some people are interested in doing this.

00:24:20.280 --> 00:24:26.360
This is -- you have an image, and you want to display
it on top of the map, so it may be available as a PDF,

00:24:26.360 --> 00:24:29.650
or you have it as a GeoTIFF or just a big image.

00:24:29.650 --> 00:24:32.240
Perhaps it's on a piece of paper and you need to scan it in.

00:24:32.240 --> 00:24:37.050
But you want to display your own maps, so this may be your
college campus map or your national park map or something

00:24:37.050 --> 00:24:41.730
like that, and you want to overlay
that on top of your map view.

00:24:41.730 --> 00:24:45.850
So one thing to know about this is, your
map has to be in the Mercator projection.

00:24:45.850 --> 00:24:50.620
We only have the Mercator projection in Map Kit, so if your
map's not in the Mercator projection, it has to be warped.

00:24:50.620 --> 00:24:54.290
Fortunately, there's a nice tool that's
available that will let you do this.

00:24:54.290 --> 00:24:58.690
So you can warp your image if it's
not already in Mercator projection.

00:24:58.690 --> 00:25:01.410
And your image is going to be cut into tiles.

00:25:01.410 --> 00:25:06.100
So if you have an image -- and in my
example I'm going to show in just a minute,

00:25:06.100 --> 00:25:12.250
I have an image that's like 120 MB image -- you're not
going to load 120 MB image into memory on an iPhone.

00:25:12.250 --> 00:25:13.370
It's not going to fit.

00:25:13.370 --> 00:25:17.170
So it needs to be cut into tiles that
are small enough, little bite-sized tiles

00:25:17.170 --> 00:25:21.050
that we can just load those individually
and display just what we need.

00:25:21.050 --> 00:25:26.110
And finally, the tiles they can be loaded another from your
applications bundle or you get them off of the network.

00:25:26.110 --> 00:25:31.900
In the example I'm going to show, we're going to load them
from the applications bundle, but you can do it either way.

00:25:31.900 --> 00:25:35.280
So this is the map that I want to put on top of Map Kit.

00:25:35.280 --> 00:25:38.210
It is a nautical chart of the San Francisco Bay.

00:25:38.210 --> 00:25:41.850
I got it from the National Oceanic
and Atmospheric Administration.

00:25:41.850 --> 00:25:45.120
And -- nice nautical chart here.

00:25:45.120 --> 00:25:47.320
And this thing's going to need to be cut into tiles.

00:25:47.320 --> 00:25:51.480
So there's a utility that does this, and the output
that it creates looks a little bit like this.

00:25:51.480 --> 00:25:54.190
So it has -- it corresponds to zoom levels.

00:25:54.190 --> 00:25:57.330
So at zoom level 10, it's just a tiny little guy.

00:25:57.330 --> 00:26:00.090
Zoom in, it gets twice as big.

00:26:00.090 --> 00:26:02.100
Zoom in again, it gets twice as big again.

00:26:02.100 --> 00:26:05.050
So it's going by powers of two.

00:26:05.050 --> 00:26:10.080
And so what you want to do is, there's this great open
source project, Geospatial Data Abstraction Library.

00:26:10.080 --> 00:26:11.480
I encourage you to download that.

00:26:11.480 --> 00:26:16.830
It's in MacPorts, so you can just do "port install
gdal" if you use MacPorts, and get this thing installed.

00:26:16.830 --> 00:26:23.090
And it comes with a great utility that someone did, I
think as some Google Summer of Code project last year.

00:26:23.090 --> 00:26:29.520
It's called GDAL2Tiles, and you put your image in it, it
will warp it to the Mercator projection if it's not already

00:26:29.520 --> 00:26:31.960
in a Mercator projection, and cut it into tiles.

00:26:31.960 --> 00:26:36.990
And then finally, it's going to -- it's going to export
tiles in a directory structure, and you can use those things

00:26:36.990 --> 00:26:39.980
with -- if you're already using,
like, Google Maps JavaScript API

00:26:39.980 --> 00:26:41.880
on the web, you can use those tiles with that.

00:26:41.880 --> 00:26:45.630
If you're using Microsoft's Virtual Earth JavaScript
API on the web, you can use the tiles with that.

00:26:45.630 --> 00:26:49.410
And now you're going to be able to
use tiles with Map Kit on the iPhone.

00:26:49.410 --> 00:26:53.060
So this is a really great utility, I recommend using it.

00:26:53.060 --> 00:26:57.500
So let me show you demo of that
nautical chart on top of Map View.

00:26:57.500 --> 00:27:05.520
[ Demo running ]

00:27:05.520 --> 00:27:07.500
Tile, Map.

00:27:07.500 --> 00:27:13.200
[ Demo running ]

00:27:13.200 --> 00:27:17.430
So there's our nautical chart overlaid
on the map, and so it's semi-transparent.

00:27:17.430 --> 00:27:22.800
You can zoom in and see that the thing
increases its detail as you zoom in.

00:27:22.800 --> 00:27:28.160
You can pinch, and it tracks the
coastline precisely as you go.

00:27:28.160 --> 00:27:31.100
You can actually even see ships navigating this chart.

00:27:31.100 --> 00:27:35.970
They're a little bit blurry, but this is the
satellite photo, you can see there's ship there.

00:27:35.970 --> 00:27:38.000
It's pretty cool.

00:27:38.000 --> 00:27:43.810
Zoom out. So one of the neat things about this demo is you
can actually -- if you were to download this sample code,

00:27:43.810 --> 00:27:48.320
and you run GDAL2Tiles on your own program,
this tiles directory in the resource port --

00:27:48.320 --> 00:27:51.810
resources here, just delete that
and put your own tiles directory,

00:27:51.810 --> 00:27:54.720
and now you have your own raster map on top of map kits.

00:27:54.720 --> 00:27:56.500
So it's - no code to modify it.

00:27:56.500 --> 00:28:01.940
[ Applause ]

00:28:01.940 --> 00:28:03.420
Yeah. That's pretty neat.

00:28:03.420 --> 00:28:07.850
I just want to show you a little bit about how this
works, though, in case you do download this code

00:28:07.850 --> 00:28:10.050
and you want to extend it, go further with it.

00:28:10.050 --> 00:28:12.430
So let me just show you the model class.

00:28:12.430 --> 00:28:14.370
So this is a tile overlay model class.

00:28:14.370 --> 00:28:19.370
It scans a directory of tiles, so scans that
directory of tiles out of the resources directory;

00:28:19.370 --> 00:28:26.560
figures out what is the boundingMapRect for all of those
tiles; and then for the view, it's able to return a list

00:28:26.560 --> 00:28:30.490
of tiles for a given MapRect because we're going to
get drawMapRect, get the MapRect in the ZoomScale,

00:28:30.490 --> 00:28:33.150
we need to know what are the images that correspond to this.

00:28:33.150 --> 00:28:34.860
And so we're going to need to get those.

00:28:34.860 --> 00:28:39.180
And there's one really useful function in
here that I want to call your attention to.

00:28:39.180 --> 00:28:48.390
Most of it is just details with reading files and so
on, but there's -- let's see where did I put that thing?

00:28:48.390 --> 00:28:49.650
Ah, I put it right here.

00:28:49.650 --> 00:28:50.950
ZoomScale to the zoom level.

00:28:50.950 --> 00:28:55.890
So if you've used Google Maps JavaScript on the
web, or you've used Virtual Earth JavaScript API

00:28:55.890 --> 00:28:58.390
on the web, you're familiar with zoom levels.

00:28:58.390 --> 00:29:01.040
So we don't use zoom levels in Map Kit, we use ZoomScale.

00:29:01.040 --> 00:29:04.880
ZoomScale is nice because it does have
that linear relationship between map points

00:29:04.880 --> 00:29:06.410
and screen points, so that's why we use it.

00:29:06.410 --> 00:29:12.630
But if you have data that's using Zoom Level as these
raster tiles do, you can convert between Map Kit ZoomScale

00:29:12.630 --> 00:29:15.300
and the Google or Microsoft convention of zoom level.

00:29:15.300 --> 00:29:20.860
So this is a really nice little function that you can
use in our own programs to do that if you need to do so.

00:29:20.860 --> 00:29:27.440
And then in the overlay view, let me
show you what this guy looks like.

00:29:27.440 --> 00:29:34.310
So when you're asked to draw a MapRect, it may not exactly
correspond to one of your tiles, it may be a list of tiles.

00:29:34.310 --> 00:29:34.670
That's OK.

00:29:34.670 --> 00:29:40.200
We're getting back this list of tiles as an array,
and we're going to loop over all of those things,

00:29:40.200 --> 00:29:42.840
and then we're just going to find,
OK, what is the image for it,

00:29:42.840 --> 00:29:46.470
what is the Rect that bounds it,
and draw that image into that Rect.

00:29:46.470 --> 00:29:51.720
One thing I noticed was, on the sample code
that I initially uploaded, and, I think,

00:29:51.720 --> 00:29:56.600
which is available on the session site right now,
doesn't have this Image Release at the end here.

00:29:56.600 --> 00:30:00.790
You're going to want to add that,
otherwise there's going to be a leak.

00:30:00.790 --> 00:30:02.750
So I'm sorry about that but, yeah, add that.

00:30:02.750 --> 00:30:06.160
And then let me just show you the view controller here.

00:30:06.160 --> 00:30:07.770
It's pretty straight forward.

00:30:07.770 --> 00:30:14.800
We just initialize with our tile directory, create
our overlay model object, and add it to the map.

00:30:14.800 --> 00:30:17.560
And we'll zoom the map just so that the tiles are visible.

00:30:17.560 --> 00:30:22.630
I zoom in one zoom level past the one that just bounds it.

00:30:22.630 --> 00:30:26.970
And then we Create and Return to View and
View for Overlay, and I set the tile alpha,

00:30:26.970 --> 00:30:30.830
so this is really the only property on the
view is the tile alpha, so it's 60% opacity.

00:30:30.830 --> 00:30:36.310
You can make it fully opaque or semitransparent
if you like, whatever works for you.

00:30:36.310 --> 00:30:40.500
So that's -- that's the Tile Map demo.

00:30:40.500 --> 00:30:46.230
[ Applause ]

00:30:46.230 --> 00:30:47.270
Let me just run that one more time.

00:30:47.270 --> 00:30:48.500
It's cool.

00:30:48.500 --> 00:30:54.690
[ Laughter ]

00:30:54.690 --> 00:30:56.000
It's nice.

00:30:56.000 --> 00:30:58.000
[ Laughter ]

00:30:58.000 --> 00:31:05.560
[ Applause ]

00:31:05.560 --> 00:31:06.690
So back to the slides.

00:31:06.690 --> 00:31:10.040
What did we learn from this?

00:31:10.040 --> 00:31:19.150
The image has to be cut into tiles, use GDAL to do
that; you can convert your ZoomScales to zoom levels,

00:31:19.150 --> 00:31:25.170
so if you have zoom level and you need to get ZoomScale
or vice versa, you can set up a mapping between those two;

00:31:25.170 --> 00:31:32.800
and you don't necessarily need to have an image that is so
detailed that you cover every zoom level that Map Kit does.

00:31:32.800 --> 00:31:39.430
So my image, even at 120 MB, and I think about 20,000
pixels on a side, still isn't enough to zoom all the way in

00:31:39.430 --> 00:31:42.460
or zoom all the way out, but that's OK.

00:31:42.460 --> 00:31:49.060
It will just show up when the map is positioned in the
right region; and the Map Kit tile size is independent

00:31:49.060 --> 00:31:54.870
from your tile size, so you may be using 256 pixel
tiles, that's what the GDAL2Tiles program outputs.

00:31:54.870 --> 00:31:56.540
Map Kit might be using a different size, but that's OK,

00:31:56.540 --> 00:32:01.700
you just draw the according number of
images that you need into that space.

00:32:01.700 --> 00:32:03.150
So loading your tiles on demand.

00:32:03.150 --> 00:32:05.120
That sample doesn't load its tiles on demand.

00:32:05.120 --> 00:32:09.550
It loads them out of the applications mode, but you can load
them on demand, and, in fact, we've built in some facility

00:32:09.550 --> 00:32:16.050
to MKOverlayView to make this practical, so loading
network resources and then drawing them as needed.

00:32:16.050 --> 00:32:19.440
And the key thing to know about this is canDrawMapRect.

00:32:19.440 --> 00:32:24.970
So canDrawMapRect is a method that you
can over ride in your MKOverlayView class.

00:32:24.970 --> 00:32:28.390
And when you get this, this is
an indication to you that a tile

00:32:28.390 --> 00:32:30.680
or a list of tiles corresponding to that area is needed.

00:32:30.680 --> 00:32:36.180
It means Map Kit's interested, so you should go
off and go to your web server and fetch that data.

00:32:36.180 --> 00:32:37.710
And what you're going to is while you're fetching the data,

00:32:37.710 --> 00:32:40.650
you're going to return No, and
say, "I can't draw that right now."

00:32:40.650 --> 00:32:45.530
And so we're not going to bother calling
drawMapRect, we're just going to wait

00:32:45.530 --> 00:32:48.180
for you to go ahead and download that data.

00:32:48.180 --> 00:32:51.830
Then once you have the data, you're
going to call setNeedsDisplayInMapRect

00:32:51.830 --> 00:32:54.250
and that's going to indicate, OK, things have changed.

00:32:54.250 --> 00:32:55.610
We're going to reevaluate.

00:32:55.610 --> 00:32:58.830
You're going to get canDrawMapRect again,
and this time you're going to return Yes

00:32:58.830 --> 00:33:02.110
because you have the data cached locally,
and then you're going to get drawMapRect,

00:33:02.110 --> 00:33:04.650
and you're going to have a chance to draw your own data.

00:33:04.650 --> 00:33:07.560
So there's a couple of things to know about this.

00:33:07.560 --> 00:33:10.350
You want to coalesce your request to
your web server into a fixed size stack.

00:33:10.350 --> 00:33:16.120
If the user pans really quickly, they could pan from,
you know, San Francisco all the way over to Idaho,

00:33:16.120 --> 00:33:22.720
and there's a lot of intermediate tiles that were passed
by, but they were on screen for just a fraction of a second.

00:33:22.720 --> 00:33:25.190
You don't want make a request to your web server for those.

00:33:25.190 --> 00:33:29.450
So if you coalesce your tile request and go to fixed
size stack, and then fire those off to your web server

00:33:29.450 --> 00:33:34.430
on a short timer, say like 0.1, 0.2
second timer, you can avoid drawing things

00:33:34.430 --> 00:33:38.350
or requesting things that the user
didn't really want to see.

00:33:38.350 --> 00:33:42.650
The most recent request is the most
important, so use a stack not a queue, right.

00:33:42.650 --> 00:33:44.950
If they pan over to Idaho, they want to see tiles in Idaho,

00:33:44.950 --> 00:33:48.570
they don't want to see things on
the way in Oregon, for instance.

00:33:48.570 --> 00:33:51.140
And, yeah, the old request may no longer be visible.

00:33:51.140 --> 00:33:53.200
It's off screen, they don't care anymore.

00:33:53.200 --> 00:33:56.930
And your stack size should be roughly twice the size
of the number of tiles needed to cover the screen.

00:33:56.930 --> 00:33:58.180
Why twice the size?

00:33:58.180 --> 00:34:00.140
Well, in Map Kit you can pinch.

00:34:00.140 --> 00:34:02.720
We don't have tightly delineated zoom levels.

00:34:02.720 --> 00:34:06.150
You can pinch so that things are just sort of
scaled down, and if you're right at the boundary,

00:34:06.150 --> 00:34:09.290
then you're going to need about twice as
many as you would expect to cover the screen.

00:34:09.290 --> 00:34:11.370
So that's why you use 2X.

00:34:11.370 --> 00:34:16.530
And when a request falls off the back of the stack, so let's
say you decide, "Oh, my stack should be 50 items deep,"

00:34:16.530 --> 00:34:23.070
and you get to the 51st item, call
setNeedsDisplayInMapRect again, and when you do that,

00:34:23.070 --> 00:34:26.500
it doesn't necessarily mean you're
going to get a drawMapRect right away,

00:34:26.500 --> 00:34:32.120
it just means you want to get another canDrawMapRect,
and so the time the user does pan back to that area,

00:34:32.120 --> 00:34:34.070
we're going to reevaluate, and then at that point,

00:34:34.070 --> 00:34:37.890
we may consider actually downloading
and then finally displaying it.

00:34:37.890 --> 00:34:40.880
So that's what you need to do to load your tiles on demand,

00:34:40.880 --> 00:34:45.800
and that pretty much wraps what I have
to say about raster tile overlays.

00:34:45.800 --> 00:34:50.890
For more information, you should send an email
to Mark Malone, that's his email address there.

00:34:50.890 --> 00:34:52.200
We have great documentation.

00:34:52.200 --> 00:34:54.960
It's been fully updated for Map Kit on iOS 4.

00:34:54.960 --> 00:34:57.190
I encourage you to read that.

00:34:57.190 --> 00:35:01.040
And the Developer Forums, I've been hanging out on
there, the other Map Kit engineers have been hanging

00:35:01.040 --> 00:35:04.340
out on there, so pop in there and post your questions.

00:35:04.340 --> 00:35:06.410
So in summary: What can you do with Map Kit overlays?

00:35:06.410 --> 00:35:09.090
You can add your lines and shapes to the map.

00:35:09.090 --> 00:35:12.140
And with custom overlays you can
really draw anything you want.

00:35:12.140 --> 00:35:17.350
And so I really hope to see everyone who's been
using Map Kit and has wished that they had had this

00:35:17.350 --> 00:35:21.410
in their applications, I'd like to see you update your
applications to take advantage of overlays for iOS 4.

00:35:21.410 --> 00:35:22.500
Thank you very much.

00:35:22.500 --> 00:35:24.800
[ Applause ]

