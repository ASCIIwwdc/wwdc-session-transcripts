1
00:00:07,180 --> 00:00:08,310
>> Greg Parker: Good morning.

2
00:00:08,310 --> 00:00:12,910
And welcome to one of the last sessions of WWDC 2010.

3
00:00:12,910 --> 00:00:16,570
This is Advanced Objective-C and
Garbage Collection Techniques.

4
00:00:16,570 --> 00:00:18,230
My name is Greg Parker.

5
00:00:18,230 --> 00:00:22,340
I'm the Runtime Wrangler for the Objective-C Runtime.

6
00:00:22,340 --> 00:00:23,830
So, let's get started.

7
00:00:23,830 --> 00:00:26,100
What are we going to talk about today?

8
00:00:26,100 --> 00:00:29,260
We're going to talk about the two faces of Objective-C.

9
00:00:29,260 --> 00:00:33,070
You get two Runtimes for one price of this language.

10
00:00:33,070 --> 00:00:37,220
We're going to talk about some techniques you
can use in you code with Language features

11
00:00:37,220 --> 00:00:39,610
and Runtime features that you can take advantage of.

12
00:00:39,610 --> 00:00:47,340
For those of you using blocks including all of you with
new in iPhone 4 and iOS 4, we're going to talk about some

13
00:00:47,340 --> 00:00:53,020
of the low-level details of blocks and some of
the edge cases of how to use them correctly.

14
00:00:53,020 --> 00:00:59,440
And finally, for you Mac garbage collection users,
we'll talk about optimizing garbage-collected memory

15
00:00:59,440 --> 00:01:06,230
and how to use Instruments in the Xcode preview you have
today to make your garbage collection code work better.

16
00:01:06,230 --> 00:01:09,730
The two faces of Objective-C.

17
00:01:09,730 --> 00:01:12,230
There are two Objective-C Runtimes.

18
00:01:12,230 --> 00:01:18,100
There's a Modern runtime which is used for
most of our platforms and architectures now.

19
00:01:18,100 --> 00:01:24,080
I say Modern because it was rewritten several
years ago when we started 64-bit development,

20
00:01:24,080 --> 00:01:29,420
and is designed to support new features that
the Legacy runtime which dates back to next step

21
00:01:29,420 --> 00:01:35,640
in the 1990s could not support
for binary compatibility reasons.

22
00:01:35,640 --> 00:01:39,230
Until this week, this was what the diagram looked like.

23
00:01:39,230 --> 00:01:43,930
The Legacy runtime was on 32-bit
Mac in the iPhone Simulator,

24
00:01:43,930 --> 00:01:49,080
the Modern runtime was on 64-bit Mac in iPhone devices.

25
00:01:49,080 --> 00:01:54,210
For those of you on iPhone, you know that the
mismatch between devices running one runtime,

26
00:01:54,210 --> 00:01:57,630
simulator running the other runtime was a problem.

27
00:01:57,630 --> 00:01:59,520
This week we fixed that.

28
00:01:59,520 --> 00:02:03,130
Shazam! The iPhone Simulator--

29
00:02:03,130 --> 00:02:05,500
[ Applause ]

30
00:02:05,500 --> 00:02:12,330
Thanks to heroic last minute work by the Simulator team,
now runs the Modern runtime, supports all the same features

31
00:02:12,330 --> 00:02:17,450
of Language features, runtime features
that are present on the iPhone devices.

32
00:02:17,450 --> 00:02:22,650
For those of you on 32-bit Mac, well, sorry.

33
00:02:22,650 --> 00:02:25,060
So, why do you care about the runtime?

34
00:02:25,060 --> 00:02:29,910
You care about the runtime because it affects
what language features you can use in some cases,

35
00:02:29,910 --> 00:02:34,360
C++ compatible exceptions, non-fragile istance variables.

36
00:02:34,360 --> 00:02:39,720
And some of the new features I'm going to be showing
you today are only available on the Modern runtime.

37
00:02:39,720 --> 00:02:46,410
So, if you're developing for Mac OS, and if you still need
to support 32-bit, then you're stuck with the legacy runtime

38
00:02:46,410 --> 00:02:51,970
on one of your application platforms, so you
have to be careful what features you use.

39
00:02:51,970 --> 00:02:57,470
For the iPhone developers or maybe I should call
them iOS developers now, I'm not quite sure.

40
00:02:57,470 --> 00:03:00,500
Now, as of this week, you don't care anymore.

41
00:03:00,500 --> 00:03:02,520
You can use the Modern runtime everywhere.

42
00:03:02,520 --> 00:03:05,430
It's present on all devices you run on, and it's present

43
00:03:05,430 --> 00:03:11,750
on SDK 4 simulators both the 3.2
simulator and the 4.0 simulator.

44
00:03:11,750 --> 00:03:17,460
In particular, what that means for iPhone
developers is you can build a single binary

45
00:03:17,460 --> 00:03:19,770
that runs on both simulator versions.

46
00:03:19,770 --> 00:03:26,530
So, you can test your universal iPhone, iPad app
without recompiling, without changing SDK targets.

47
00:03:26,530 --> 00:03:30,120
Language and Runtime Techniques.

48
00:03:30,120 --> 00:03:31,890
I mentioned some new language features.

49
00:03:31,890 --> 00:03:35,880
I'm also going to talk about a couple of old
language features you might not have seen.

50
00:03:35,880 --> 00:03:40,410
Some of the advanced techniques I'm going
to talk about include: Writing code,

51
00:03:40,410 --> 00:03:45,180
not writing code, and not executing code.

52
00:03:45,180 --> 00:03:50,500
So, this is really low-level nitty gritty session
but you'll actually get some more detail there.

53
00:03:50,500 --> 00:03:55,400
Writing code using class extensions
to organize the code the way you want

54
00:03:55,400 --> 00:04:00,140
to get access control splitting
among multiple files, et cetera.

55
00:04:00,140 --> 00:04:03,060
Not writing code using synthesized properties.

56
00:04:03,060 --> 00:04:07,930
Let the compiler write accessors
and instance variables for you.

57
00:04:07,930 --> 00:04:16,470
Not executing code, using weak-linked classes to write
an application that runs on a newer OS uses the features

58
00:04:16,470 --> 00:04:21,140
of the newer OS, but also is backward
compatible with an older OS version.

59
00:04:21,140 --> 00:04:23,220
It does not have those same features.

60
00:04:23,220 --> 00:04:26,200
Let's start with class extensions.

61
00:04:26,200 --> 00:04:27,790
What is a class extension?

62
00:04:27,790 --> 00:04:30,210
Not all of you have heard of this, I'm sure.

63
00:04:30,210 --> 00:04:37,690
A class extension is a second interface for your
class, or a third interface, or a fourth interface.

64
00:04:37,690 --> 00:04:40,600
It looks like this here on your right.

65
00:04:40,600 --> 00:04:44,140
It looks something like a category with no name.

66
00:04:44,140 --> 00:04:48,430
If it were a category, there'll be on
those parentheses, there's nothing there.

67
00:04:48,430 --> 00:04:54,670
In the class extension, you can declare
additional methods and additional properties

68
00:04:54,670 --> 00:04:57,940
that are not present in your public interface.

69
00:04:57,940 --> 00:05:05,490
So, it gives you a chance to have a private interface with
extra features or an internal-only interface for your--

70
00:05:05,490 --> 00:05:08,990
some of your clients, but not other
clients, that sort of change.

71
00:05:08,990 --> 00:05:16,360
It could be at a different header file if you want, but it
shares the same implementation as the rest of the class.

72
00:05:16,360 --> 00:05:20,220
So, let's look at an example of what
you can do with a class extension.

73
00:05:20,220 --> 00:05:23,160
This is a simple PetShopView class.

74
00:05:23,160 --> 00:05:25,920
And by the way, I should mention,
I'm a low-level programmer.

75
00:05:25,920 --> 00:05:30,990
The only thing I know about KVC is what the
letters stand for, so don't take this data

76
00:05:30,990 --> 00:05:34,990
and method layout and use it in your own code.

77
00:05:34,990 --> 00:05:36,800
Anyway, we have our PetShop class.

78
00:05:36,800 --> 00:05:39,850
It stores kittens and puppies that we sell.

79
00:05:39,850 --> 00:05:46,170
We have a property for the puppy food that we're feeding
the puppies, and we have a method for feeding the snake.

80
00:05:46,170 --> 00:05:51,000
Clearly, feeding the snake is a risky touchy operation.

81
00:05:51,000 --> 00:05:53,140
We don't want somebody doing this.

82
00:05:53,140 --> 00:05:55,570
We don't want to starve the puppies.

83
00:05:55,570 --> 00:06:00,990
We don't want them to feed the
snake with inappropriate items.

84
00:06:00,990 --> 00:06:04,080
So, we have this interface, but
all of our details are public.

85
00:06:04,080 --> 00:06:05,100
We don't want that.

86
00:06:05,100 --> 00:06:09,630
We can use a class extension to
hide some of the declarations.

87
00:06:09,630 --> 00:06:15,890
For the puppy food property, note that in the
public interface, the property is readonly,

88
00:06:15,890 --> 00:06:19,540
but in the private interface, we've
redeclared it as readwrite,

89
00:06:19,540 --> 00:06:24,950
which means publicly they can only read
it, but internally, we can write to it.

90
00:06:24,950 --> 00:06:29,850
Secondly, we have our snake feeding
method which is now a private method.

91
00:06:29,850 --> 00:06:34,420
There's no declaration in our public
header, but we can use it internally.

92
00:06:35,690 --> 00:06:42,130
What's new is being able to do this, declaring
your instance variables in the class extension.

93
00:06:42,130 --> 00:06:42,800
[ Applause ]

94
00:06:42,800 --> 00:06:48,150
I could see some people already
recognize what this will do for you.

95
00:06:48,150 --> 00:06:53,610
What this means is your interface does not have to
include your private instance variables anymore.

96
00:06:53,610 --> 00:06:57,430
You can-- your public interface only
includes what you really want to be public

97
00:06:57,430 --> 00:07:00,820
which is almost never your instance variables.

98
00:07:00,820 --> 00:07:05,800
So, ivars in Class Extensions, when can you use these?

99
00:07:05,800 --> 00:07:11,710
It is available only in the Modern runtime, which is
why I explained runtimes to you a couple of minutes ago.

100
00:07:11,710 --> 00:07:15,590
It is only available in the LLVM compiler.

101
00:07:15,590 --> 00:07:22,670
GCC is a difficult code base, and we're
not going to add this feature to it.

102
00:07:22,670 --> 00:07:27,120
In the Xcode Preview, this feature is not on by default.

103
00:07:27,120 --> 00:07:30,400
There's an extra compiler flag you need to set.

104
00:07:30,400 --> 00:07:36,690
I think Xcode 4 has a-- there's a
setting in the build settings for this

105
00:07:36,690 --> 00:07:42,390
or you can set other C Flags using these options out there.

106
00:07:42,390 --> 00:07:46,390
Next topic.

107
00:07:46,390 --> 00:07:49,470
Not writing code using @synthesize.

108
00:07:49,470 --> 00:07:53,030
Let's look again at a modified PetShopView class.

109
00:07:53,030 --> 00:07:57,100
Here, we're looking at the puppy food property.

110
00:07:57,100 --> 00:08:00,450
This is the normal implementation of a property.

111
00:08:00,450 --> 00:08:08,130
We have our declaration in our interface or possibly
a class extension, and we have our implementation

112
00:08:08,130 --> 00:08:13,890
where we use @synthesize to tell the compiler
add the method for us or get our method,

113
00:08:13,890 --> 00:08:18,320
add a setter method that match
the declaration of the property.

114
00:08:21,290 --> 00:08:23,420
You can also do this.

115
00:08:23,420 --> 00:08:26,760
We don't have an instance variable for our property.

116
00:08:26,760 --> 00:08:30,940
Instead, we let @synthesize add
the instance variable as well.

117
00:08:30,940 --> 00:08:35,110
So, now @synthesize is doing three things -
adds a setter method, adds a getter method,

118
00:08:35,110 --> 00:08:38,350
adds an ivar with the same name as the property.

119
00:08:38,350 --> 00:08:41,180
This has been available since Snow Leopard ship.

120
00:08:41,180 --> 00:08:46,490
Although for a while there was a bug where you
could not use the instance variable directly,

121
00:08:46,490 --> 00:08:49,880
now that works on all of our compilers.

122
00:08:49,880 --> 00:08:55,360
What's new in Xcode 4 is being able to do this.

123
00:08:55,360 --> 00:08:58,090
You don't even write @synthesize.

124
00:08:58,090 --> 00:09:00,540
You write your app property and nothing else.

125
00:09:00,540 --> 00:09:00,600
[ Applause ]

126
00:09:00,600 --> 00:09:05,740
The compiler builds all the rest of the code for you.

127
00:09:05,740 --> 00:09:10,490
Basically, what this does @synthesize
is the default for most properties.

128
00:09:10,490 --> 00:09:14,280
Now, the compiler writes your setter
method and writes your getter method.

129
00:09:14,280 --> 00:09:16,680
It writes the instance variable for you.

130
00:09:16,680 --> 00:09:20,050
All you did was write @property in your interface.

131
00:09:20,050 --> 00:09:22,540
Synthesize by default.

132
00:09:22,540 --> 00:09:25,690
Again, it only works in the Modern runtime.

133
00:09:25,690 --> 00:09:28,770
And again, it only works in the LLVM compiler.

134
00:09:28,770 --> 00:09:35,730
And again, in your Xcode Developer Preview, it only works
in the LLVM compiler when you turn on a compiler flag.

135
00:09:38,420 --> 00:09:43,230
Of course, you don't always want
to synthesize your properties,

136
00:09:43,230 --> 00:09:48,500
so you need to use one of the other alternatives
to synthesize that we've had all along.

137
00:09:48,500 --> 00:09:53,440
If you write accessor methods by hand,
the @synthesize will not take effect.

138
00:09:53,440 --> 00:10:01,830
The other alternative is to use the @dynamic keyword which
tells the compiler, "I'm not writing a method, but compiler,

139
00:10:01,830 --> 00:10:04,380
please do not write a method for me either.

140
00:10:04,380 --> 00:10:09,390
It'll be provided somewhere else
at runtime or at compile time."

141
00:10:09,390 --> 00:10:16,220
For example, it could be a forwarded message or you
could use dynamic method resolution to create the method,

142
00:10:16,220 --> 00:10:19,550
o perhaps you're doing a Core Data NSManagedObject.

143
00:10:19,550 --> 00:10:23,670
An NSManagedObject will create accessor methods for you.

144
00:10:23,670 --> 00:10:28,130
In any of those cases where you're relying
on somebody else to write the method,

145
00:10:28,130 --> 00:10:35,040
we synthesize by default you should make sure you
have @dynamic describing each of your properties.

146
00:10:35,040 --> 00:10:40,440
If you didn't have @dynamic previously and you didn't have
@synthesize, you should have gotten a compiler warning.

147
00:10:40,440 --> 00:10:44,950
So, as long as you're actually paying attention to
compiler warnings, that won't be a problem for you.

148
00:10:48,400 --> 00:10:52,860
Last topic for language and runtime
techniques is weak linking.

149
00:10:52,860 --> 00:10:56,990
Weak linking is a way to use an operating system feature,

150
00:10:56,990 --> 00:11:02,890
but still run your app on OS versions
that do not have that feature.

151
00:11:02,890 --> 00:11:05,720
So, this is a C example of weak linking.

152
00:11:05,720 --> 00:11:09,560
We have a C function called NSDrawNinePartImage.

153
00:11:09,560 --> 00:11:16,030
This is added in AppKit in Snow Leopard, I think, and
does not exist on Leopard, I think it's added in Leopard,

154
00:11:16,030 --> 00:11:20,000
I forgot, anyway, I don't program
AppKit, I program a low level.

155
00:11:20,000 --> 00:11:26,000
In any case, this is how you would use it if
you also want it to run on an older OS version.

156
00:11:26,000 --> 00:11:28,610
You check if the function pointer is NULL.

157
00:11:28,610 --> 00:11:34,780
If the function pointer is NULL, you don't call
the function, you have to do something else.

158
00:11:34,780 --> 00:11:40,780
You're-- ideally, you want to do the same thing
with Objective-C code and Objective-C classes.

159
00:11:40,780 --> 00:11:47,010
This is what you have to do today if you want
to use weak linking for Objective-C classes.

160
00:11:47,010 --> 00:11:57,820
UIPopoverController is a UIKit class that was added for the
iPad in 3.2, but did not exist on iPhone and iPhone 3.1.

161
00:11:57,820 --> 00:12:03,540
So, any of you who are iPhone developers know if you're
trying to write a single application that runs on both iPad

162
00:12:03,540 --> 00:12:08,830
and iPhone, you need to do something
with UIPopoverController to be able

163
00:12:08,830 --> 00:12:12,260
to use it and still run on an iPhone device.

164
00:12:12,260 --> 00:12:13,890
So, this is what the code looks like.

165
00:12:13,890 --> 00:12:20,590
You need to use NSClassFromString to look up the
class by name, store that in the local variable,

166
00:12:20,590 --> 00:12:24,860
and then always use the local variable
when you want to message the class.

167
00:12:24,860 --> 00:12:28,590
You cannot actually send the message to
the class directly because it'll fail

168
00:12:28,590 --> 00:12:32,550
at link time, and your program will not launch.

169
00:12:32,550 --> 00:12:41,890
In addition, in the second example on the bottom, you
cannot subclass a class that may be absent at runtime.

170
00:12:41,890 --> 00:12:47,970
If you try that, if you try to create your own controller,
there's a subclass of PopoverController, it just crashes.

171
00:12:47,970 --> 00:12:52,190
If you try and use your subclass,
well sorry, it just doesn't work.

172
00:12:52,190 --> 00:12:57,520
So, you'd rather have your code look something like this.

173
00:12:57,520 --> 00:13:00,310
In the top example, this is much cleaner.

174
00:13:00,310 --> 00:13:04,370
You're sending messages to the class
directly, you don't need ClassFromString.

175
00:13:04,370 --> 00:13:09,290
You don't need a local variable to store the
class pointer that you looked up earlier.

176
00:13:09,290 --> 00:13:11,400
You could just send the message to the class.

177
00:13:11,400 --> 00:13:15,100
The class will either respond normally
because it is present.

178
00:13:15,100 --> 00:13:22,120
Or the class will act like a message to nil as if the
class weren't there because in fact it's not there.

179
00:13:22,120 --> 00:13:27,920
So, in this example, I'm sending the class method
to the class to see if it's present or not,

180
00:13:27,920 --> 00:13:34,820
either that will return my class pointer or it will
return nil because I'm running on an older OS version.

181
00:13:34,820 --> 00:13:38,260
Secondly, you want subclasses to work.

182
00:13:38,260 --> 00:13:43,100
If you create a subclass of a class
that is not there or may not be there,

183
00:13:43,100 --> 00:13:49,950
you want the subclass to act the same way
not the subclass to basically hide itself,

184
00:13:49,950 --> 00:13:55,110
remove itself from the runtime if
its super class is not available.

185
00:13:55,110 --> 00:13:59,350
So, in this case, I'm sending alloc
and init to my new class.

186
00:13:59,350 --> 00:14:04,270
Of course if my class is nil, then
alloc returns nil, init returns nil,

187
00:14:04,270 --> 00:14:07,740
I don't get an object back and
I can check for that at runtime.

188
00:14:07,740 --> 00:14:10,990
So, this is the method you want to be able write your code.

189
00:14:10,990 --> 00:14:15,910
The good news is we are on our way to supporting this.

190
00:14:15,910 --> 00:14:23,720
So, summary of weak linking again - simplifies
deployment to multiple OS versions on iPhone and iPad

191
00:14:23,720 --> 00:14:29,480
or different Mac OS versions when you want to use
a new feature but still be able to run without it.

192
00:14:29,480 --> 00:14:33,870
The bad sign, bad news is implementation forthcoming.

193
00:14:33,870 --> 00:14:38,150
Here's the gory details behind implementation forthcoming.

194
00:14:38,150 --> 00:14:48,190
Compiler support, Xcode 4 all the compilers have the
necessary compiler work to support weak-linked classes.

195
00:14:48,190 --> 00:14:53,770
Runtime support, you need to be able to have the
runtime not to crash when it sees a null pointer.

196
00:14:53,770 --> 00:14:57,460
iPhone OS 3.1 support this.

197
00:14:57,460 --> 00:15:00,920
Mac OS does not yet support this but it will in the future.

198
00:15:00,920 --> 00:15:04,870
The big problem is SDK support.

199
00:15:04,870 --> 00:15:11,490
In order for weak linking to work, each class in the
header file needs to declare when it was available,

200
00:15:11,490 --> 00:15:16,410
which OS versions have worked with,
which OS versions it was not available.

201
00:15:16,410 --> 00:15:22,320
So, if you've looked in the header, you'll be seeing
availability macros, you know, OS X available starting,

202
00:15:22,320 --> 00:15:25,450
iPhone available starting, and that sort of thing.

203
00:15:25,450 --> 00:15:30,970
Those are the tags to tell weak linking
when a class is and is not available.

204
00:15:30,970 --> 00:15:38,220
Unfortunately, none of the headers that we've shipped on
any operating system actually declare this information.

205
00:15:38,220 --> 00:15:41,240
So, you could use weak-linked classes.

206
00:15:41,240 --> 00:15:46,140
You could run on iPhone OS, but it
only works with your own classes

207
00:15:46,140 --> 00:15:50,190
which you probably don't need to
weak link against in the first place.

208
00:15:50,190 --> 00:15:56,500
So, I wanted to have a big button on this
slide, this is WWDC 2011, but I didn't get that.

209
00:15:56,500 --> 00:16:01,080
So, hopefully when we're here next year, we'll be
able to tell you that this feature is supported

210
00:16:01,080 --> 00:16:06,310
and has been supported back at least to iPhone OS 3.1.

211
00:16:06,310 --> 00:16:12,300
So, that's all for a sort of language and runtime features.

212
00:16:12,300 --> 00:16:15,770
Let's talk about blocks because blocks are cool.

213
00:16:15,770 --> 00:16:18,470
And for those of you on the iPhone, blocks are new.

214
00:16:18,470 --> 00:16:23,050
And for those of you who didn't pay much attention
to Snow Leopard last year, blocks are also new.

215
00:16:23,050 --> 00:16:26,870
And for those of you who haven't been
to WWDC before, blocks are also new.

216
00:16:26,870 --> 00:16:30,280
And for those of you who blocks
are not new, blocks are hard.

217
00:16:30,280 --> 00:16:30,900
[ Laughter ]

218
00:16:30,900 --> 00:16:39,890
So let's look at some details of blocks, and to show you
an example of block memory, what happens to block objects

219
00:16:39,890 --> 00:16:43,400
and the variables they reference as you use blocks.

220
00:16:43,400 --> 00:16:47,470
We'll talk a little bit about copying
blocks, when and how to do it.

221
00:16:47,470 --> 00:16:53,440
And we'll talk a little bit about block storage
variables which are a really neat feature of blocks

222
00:16:53,440 --> 00:16:58,290
so you can't get any other way,
but are confusing to say the least.

223
00:16:58,290 --> 00:17:01,080
Let's look at an animation of blocks in action.

224
00:17:01,080 --> 00:17:07,810
You may have seen a similar animation to this in
some of the other presentations that cover blocks.

225
00:17:07,810 --> 00:17:11,780
That's because we want to show this
animation to you over and over and over again

226
00:17:11,780 --> 00:17:16,710
until you understand because it's
a really important feature.

227
00:17:16,710 --> 00:17:24,660
We have some code that creates a block on the stack,
and then it copies that block a couple of times.

228
00:17:24,660 --> 00:17:30,780
We can see our stack itself, which at this initial
point, has a local variable called captured

229
00:17:30,780 --> 00:17:34,230
and a local block scope variable called shared.

230
00:17:34,230 --> 00:17:37,040
So, let's see what happens as we execute the code.

231
00:17:37,040 --> 00:17:40,680
The first thing we do is create the block on the stack.

232
00:17:40,680 --> 00:17:44,210
It creates a block on the stack.

233
00:17:44,210 --> 00:17:52,110
It creates a copy of most of the variables it uses, but
it does not create a copy of the block scope variable.

234
00:17:52,110 --> 00:17:56,270
So that's the difference between your block
scope variable and an ordinary variable.

235
00:17:56,270 --> 00:17:58,500
So, we have our block object on the stack.

236
00:17:58,500 --> 00:18:01,400
It has made a copy to the variable called captured,

237
00:18:01,400 --> 00:18:08,440
and that variable captured is const inside
the block, you cannot change that variable.

238
00:18:08,440 --> 00:18:14,640
Next our original function changes
the value of its captured variable.

239
00:18:14,640 --> 00:18:22,580
So, the captured variable in the stack now becomes 20,
but the blocked object created a snapshot of the world

240
00:18:22,580 --> 00:18:27,620
as it was created, so it does not see
that change to the variable captured.

241
00:18:27,620 --> 00:18:32,210
It has its own copy which stays at 10.

242
00:18:32,210 --> 00:18:33,910
Now, let's copy the block.

243
00:18:33,910 --> 00:18:41,320
Copying the block makes a copy of the
block on the heap instead of on the stack.

244
00:18:41,320 --> 00:18:50,550
The other thing it does is move any block scope variables to
the heap because the lifetime of the block scope variables

245
00:18:50,550 --> 00:18:56,490
and the lifetime of the block need to be tied together
because the block scope variable needs to live at least

246
00:18:56,490 --> 00:19:00,960
as long as the block does so the
blocking can do to use that variable.

247
00:19:00,960 --> 00:19:07,370
In this code, we make a second copy
of our stacked block which works.

248
00:19:07,370 --> 00:19:09,430
We can do that.

249
00:19:09,430 --> 00:19:13,790
There's a big X here because you
really don't want to most of the time.

250
00:19:13,790 --> 00:19:18,520
Most of the time you want to create
only one heap copy of the block

251
00:19:18,520 --> 00:19:21,400
and not duplicate it any more times than necessary.

252
00:19:21,400 --> 00:19:23,730
So, let's change our code a little bit.

253
00:19:23,730 --> 00:19:27,960
As we see in yellow down there, we
now have our block2 being copied.

254
00:19:27,960 --> 00:19:34,010
So, we're creating a copy of the heaped block
rather than copying the stacked block again.

255
00:19:34,010 --> 00:19:43,640
When we do that, there's no new copy, instead, copying an
already copied block just synchronize the retain count.

256
00:19:43,640 --> 00:19:49,150
We don't need a second block object next
to the first block object we already have.

257
00:19:49,150 --> 00:19:52,720
We'll just reference the same block object twice.

258
00:19:52,720 --> 00:19:59,950
Note that in both these cases, when we
copied block, we did not copy the shared

259
00:19:59,950 --> 00:20:04,170
or the block scope variable, the purple one called shared.

260
00:20:04,170 --> 00:20:07,310
All the blocks, all the copies of these blocks

261
00:20:07,310 --> 00:20:12,390
and the original function all point
to the same copy of that variable.

262
00:20:12,390 --> 00:20:16,730
So, let's talk about cleanup.

263
00:20:16,730 --> 00:20:17,880
We have the stuff on the stack.

264
00:20:17,880 --> 00:20:19,240
We have the stuff on the heap.

265
00:20:19,240 --> 00:20:23,520
Some of it is going to live longer than
others, what happens when it goes away?

266
00:20:23,520 --> 00:20:28,280
One option is that the block objects are destroyed first.

267
00:20:28,280 --> 00:20:33,240
When the block objects are destroyed first, the
ones on the heap, I mean, the copied objects.

268
00:20:33,240 --> 00:20:39,110
For example, you passed them to dispatch
sink and dispatch around the blocks,

269
00:20:39,110 --> 00:20:42,690
and then it was done, so it deleted the blocks.

270
00:20:42,690 --> 00:20:44,640
That looks like this.

271
00:20:44,640 --> 00:20:52,800
Your block object on the heap goes away because its retain
count reached 0, but the blocks that go variable stays alive

272
00:20:52,800 --> 00:20:58,090
because that function still needs to use it,
still needs to point to that shared variable.

273
00:20:58,090 --> 00:21:02,480
And in fact, it might be reading the
value that the blocks wrote to it.

274
00:21:02,480 --> 00:21:07,370
The other example of cleanup, let's
go back to the pre-cleanup state.

275
00:21:07,370 --> 00:21:12,390
The other example is the function returns
first while the blocks are still alive.

276
00:21:12,390 --> 00:21:13,220
You can do this.

277
00:21:13,220 --> 00:21:19,670
That's the really neat things about blocks 'cause they
survive the scope of the function that created them.

278
00:21:19,670 --> 00:21:25,590
So, for this example, perhaps you called
dispatchAsync to call the block asynchronously,

279
00:21:25,590 --> 00:21:31,100
and then the function returns before the blocks finish
running while the blocks are still on the queue.

280
00:21:31,100 --> 00:21:33,010
What does that cleanup look like?

281
00:21:33,010 --> 00:21:36,820
Well, of course, the code in the stack variables go away.

282
00:21:36,820 --> 00:21:39,340
Oh, the code doesn't go away, it
just stop running in the function.

283
00:21:39,340 --> 00:21:40,500
You know what I mean.

284
00:21:40,500 --> 00:21:43,970
But the block objects are still alive.

285
00:21:43,970 --> 00:21:45,140
They may still be running.

286
00:21:45,140 --> 00:21:47,230
They may be on a queue to be run later.

287
00:21:47,230 --> 00:21:53,700
And the blocks covariable also stays alive
because those blocks may need to use it.

288
00:21:53,700 --> 00:21:57,010
This is why we copied the block to the heap.

289
00:21:57,010 --> 00:22:04,150
This is why we moved our blocks covariable to the heap
because we may want to use them after the function

290
00:22:04,150 --> 00:22:09,830
that created them goes away, after the
stack frame that created them goes away.

291
00:22:09,830 --> 00:22:15,290
When the blocks do finally get deallocated,
they go away and the block variable goes away.

292
00:22:15,290 --> 00:22:19,360
The blocks covariable lives until
the last one leaves and they turn

293
00:22:19,360 --> 00:22:23,640
out the lights and free the heap memory if necessary.

294
00:22:23,640 --> 00:22:25,640
So, that's block memory.

295
00:22:25,640 --> 00:22:29,990
That's the sum of what's going on behind
the scenes when you create a block,

296
00:22:29,990 --> 00:22:34,760
when you execute a block, and when
you create copies of the block.

297
00:22:34,760 --> 00:22:37,650
So, block copies that we just saw.

298
00:22:37,650 --> 00:22:40,170
You want to use them for two reasons.

299
00:22:40,170 --> 00:22:45,290
You want to copy a block if it needs to
outlive the function that created it.

300
00:22:45,290 --> 00:22:50,510
You want to copy a block if you want
to make it runnable on a second thread.

301
00:22:50,510 --> 00:22:57,520
In particular, if you run any garbage collection, you
must copy it if you want to run it on a second thread.

302
00:22:57,520 --> 00:23:04,350
If you don't copy it, the garbage collector, in a
particular the thread local collector will be confused

303
00:23:04,350 --> 00:23:07,110
that you created this block on
one thread, and then suddenly,

304
00:23:07,110 --> 00:23:10,250
it's running on some other thread that it was not expecting.

305
00:23:10,250 --> 00:23:17,520
You must copy it to say, "Hey Mr. Garbage Collector,
this block may be run on some other thread."

306
00:23:17,520 --> 00:23:18,230
So, that's true.

307
00:23:18,230 --> 00:23:23,800
Even if you're going to run asynchronously, even if the
function that created it will survive longer than the block,

308
00:23:23,800 --> 00:23:26,940
you still need to copy and to tell
the garbage collector what's going on.

309
00:23:26,940 --> 00:23:30,520
How do you create a copy of a block?

310
00:23:30,520 --> 00:23:35,200
The easy way to create a copy of the block is
use the copy method and the release method.

311
00:23:35,200 --> 00:23:42,290
Just like any other Objective-C object, all blocks
are objects, they respond to these messages.

312
00:23:42,290 --> 00:23:47,070
There are also C functions for copying and deleting blocks.

313
00:23:47,070 --> 00:23:52,570
If you're writing pure C code, you
can use those C functions instead.

314
00:23:52,570 --> 00:23:59,730
You should prefer to use the methods instead of the
functions especially if you're using garbage collection.

315
00:23:59,730 --> 00:24:05,800
Because of course in garbage collection, the release
method does nothing because it doesn't need to.

316
00:24:05,800 --> 00:24:11,900
So, it's easier to copy the block and then do
nothing, let the garbage collector clean it up,

317
00:24:11,900 --> 00:24:17,410
as opposed to doing the C function to copy the
block and then you must manually call the C function

318
00:24:17,410 --> 00:24:20,890
to release it even if you're running garbage collection.

319
00:24:20,890 --> 00:24:29,650
Let's talk about block scope variables and the
__block keyword, that's two underscores underneath.

320
00:24:29,650 --> 00:24:32,450
You can't see it with this font.

321
00:24:32,450 --> 00:24:38,230
Block scope variables, as we saw on the animation,
behave differently than a normal stack variable.

322
00:24:38,230 --> 00:24:41,480
They behave differently than a global variable.

323
00:24:41,480 --> 00:24:48,350
And they behave differently from any
local variable inside the block itself.

324
00:24:48,350 --> 00:24:54,130
So, block is a storage class for those of you
who know the C language and Objective-C language.

325
00:24:54,130 --> 00:24:57,470
Examples of storage class are static.

326
00:24:57,470 --> 00:25:04,300
A static variable, a global variable is a
particular storage class that differs from register,

327
00:25:04,300 --> 00:25:10,540
which in the old days would tell the compiler, "Put
this variable in the register instead of on the stack,"

328
00:25:10,540 --> 00:25:17,210
or oppose to auto, which in the really,
really old days, was a hint to the compiler

329
00:25:17,210 --> 00:25:20,790
to put it on the stack rather than somewhere else.

330
00:25:20,790 --> 00:25:28,450
So, block is not in registers, it's not on the stack,
it's not a global variable, it's something different.

331
00:25:28,450 --> 00:25:34,640
In implementation wise, it's usually on the stack
around the heap, but you don't need to know that.

332
00:25:34,640 --> 00:25:38,400
It's in its separate storage area.

333
00:25:38,400 --> 00:25:45,980
A block variable is mutable unlike any other
variables inside a block that are captured

334
00:25:45,980 --> 00:25:50,280
from the function that created it or from other globals.

335
00:25:50,280 --> 00:25:55,800
So, the block variable is mutable which means the block
variable can write to it, and the function will see

336
00:25:55,800 --> 00:26:00,680
that data because block variable is shared.

337
00:26:00,680 --> 00:26:03,460
It is shared with the function that created it.

338
00:26:03,460 --> 00:26:08,360
It is shared with any blocks that
reference it at any copies of those blocks.

339
00:26:08,360 --> 00:26:18,130
There's only one copy of that block variable
shared among everybody mutable for all of them.

340
00:26:18,130 --> 00:26:22,050
Some other gotchas about block variables.

341
00:26:22,050 --> 00:26:26,290
If you have a block variable that is an Objective-C pointer,

342
00:26:26,290 --> 00:26:31,350
that value is not retained which
differs from the captured objects.

343
00:26:31,350 --> 00:26:36,820
I didn't show this in the animation, but a
captured variable, the block will retain it

344
00:26:36,820 --> 00:26:41,730
if it's an Objective-C object and
release it when the block is destroyed.

345
00:26:41,730 --> 00:26:44,530
A block scope variable is not retained.

346
00:26:44,530 --> 00:26:50,100
You're on your own for managing the merry
management if you're not using the garbage collector.

347
00:26:50,100 --> 00:26:58,210
As we saw, a block variable may move from the stack
to the heap, which means its value maybe copied.

348
00:26:58,210 --> 00:27:04,710
If you're writing C++ code or objective
C++ code, that's an important fact.

349
00:27:04,710 --> 00:27:10,100
If you have a copy constructor or
something like that, it may be copied.

350
00:27:10,100 --> 00:27:16,410
Also, you don't want to take the address of any of
these variables because if it does move from the stack

351
00:27:16,410 --> 00:27:22,640
to the heap, the address you took is no longer
valid, you'll crash if you try and use it.

352
00:27:22,640 --> 00:27:26,530
Finally, block arrays are not allowed.

353
00:27:26,530 --> 00:27:32,810
Block arrays are not allowed because of
some corky edge cases in the C language

354
00:27:32,810 --> 00:27:36,340
or the C compiler does not know how big your array is.

355
00:27:36,340 --> 00:27:40,880
It knows it's an array, it knows it's a
pointer, it doesn't know how many bytes it has.

356
00:27:40,880 --> 00:27:45,330
And the C++, it doesn't know how many
elements would need to be copy constructed

357
00:27:45,330 --> 00:27:48,490
when the block is moved from the stack to the heap.

358
00:27:48,490 --> 00:27:51,780
So, you can't actually use an array to do that.

359
00:27:51,780 --> 00:28:00,190
As they work around, you can usually use a struct
containing an array, and use that as your block variable.

360
00:28:00,190 --> 00:28:05,630
And then the compiler will have enough
knowledge to copy it when it needs to.

361
00:28:08,540 --> 00:28:12,340
What do you use block scope variables for?

362
00:28:12,340 --> 00:28:18,880
You use block scope variables because they are
shared, because they live as long as the block

363
00:28:18,880 --> 00:28:22,010
or the function whichever survives longer.

364
00:28:22,010 --> 00:28:30,670
You can send values between different calls to the
same block or different copies of the same block.

365
00:28:30,670 --> 00:28:33,470
You can return values back to your caller.

366
00:28:33,470 --> 00:28:40,930
For example, if you're calling an API that takes a block
that returns void, of course, you can't return anything

367
00:28:40,930 --> 00:28:47,840
to your caller, but you could create a block variable
in your caller, have the block write to it as it runs,

368
00:28:47,840 --> 00:28:51,890
and then the caller can pick up that
information when it is completed.

369
00:28:51,890 --> 00:28:58,900
Of course, with any shared data, and a block, of
course, is shared with its function in any other blocks,

370
00:28:58,900 --> 00:29:01,210
you need to be aware of thread synchronization.

371
00:29:01,210 --> 00:29:04,890
You need to make sure that you
don't have multiple threads writing

372
00:29:04,890 --> 00:29:08,790
to the same variable and clobbering each other results.

373
00:29:08,790 --> 00:29:14,000
You need to make sure that if somebody writes
to the variable and somebody else reads,

374
00:29:14,000 --> 00:29:19,920
that there are some synchronization so that the reader knows
to wait until the writer is done, all that sort of thing.

375
00:29:19,920 --> 00:29:26,710
Same thing if you had a shared global variable or an
instance variable that was shared from multiple threads.

376
00:29:26,710 --> 00:29:28,980
So, let me go back to that.

377
00:29:28,980 --> 00:29:33,870
The thread synchronization mechanisms are, of
course, the same ones you would use anywhere else.

378
00:29:33,870 --> 00:29:40,510
You can use a pthread lock, you can use Objective-C locks,
you can use dispatch queues, you can use atomic operations,

379
00:29:40,510 --> 00:29:43,700
any of that stuff works just like
it would work anywhere else.

380
00:29:43,700 --> 00:29:50,320
The thing to remember is to remember
that you have to do this.

381
00:29:50,320 --> 00:29:55,620
Finally, let me talk about garbage
collected memory and optimizing it,

382
00:29:55,620 --> 00:30:00,510
in particular, optimizing memory you don't want.

383
00:30:00,510 --> 00:30:03,160
The garbage collector is not magic.

384
00:30:03,160 --> 00:30:08,730
It deletes a lot of memory you don't want, but
it cannot delete all the memory you don't want

385
00:30:08,730 --> 00:30:13,920
because it doesn't know what you know in
your head how you want the program to work.

386
00:30:15,040 --> 00:30:18,960
So, we can define two classes of memory you don't want.

387
00:30:18,960 --> 00:30:23,770
This applies to garbage collection as well as
non-garbage collections, useful terminology.

388
00:30:23,770 --> 00:30:25,520
We could define a leak.

389
00:30:25,520 --> 00:30:29,120
You know, leak is an allocation
that nobody points to anymore.

390
00:30:29,120 --> 00:30:31,110
It is not referenced anymore.

391
00:30:31,110 --> 00:30:34,130
Clearly, the program can't be using that memory.

392
00:30:34,130 --> 00:30:35,290
Clearly, you don't want it.

393
00:30:35,290 --> 00:30:37,810
Oh, as you referenced it.

394
00:30:39,130 --> 00:30:42,130
But sometimes, you have memory that is referenced.

395
00:30:42,130 --> 00:30:44,430
This is abandoned memory.

396
00:30:44,430 --> 00:30:46,700
Its allocation is referenced.

397
00:30:46,700 --> 00:30:51,500
There's still a pointer to it somewhere, but
nobody is actually going to use it anymore.

398
00:30:51,500 --> 00:30:52,170
It's done.

399
00:30:52,170 --> 00:30:59,460
And nobody is going to actually use that
reference for the rest of the program.

400
00:30:59,460 --> 00:31:01,340
So, leak detectors.

401
00:31:01,340 --> 00:31:04,060
The leaks tool, the leaks instrument.

402
00:31:04,060 --> 00:31:09,020
They can find leak memory because they scan
for allocations that are not referenced,

403
00:31:09,020 --> 00:31:14,910
but they don't find abandoned memory because
there are references to the abandoned memory.

404
00:31:14,910 --> 00:31:20,190
The leak detector doesn't know which ones you will use
in the future and which ones you won't use in the future.

405
00:31:20,190 --> 00:31:23,650
OK. Let's try a garbage collector.

406
00:31:23,650 --> 00:31:27,160
Garbage collector solves all memory problems, right?

407
00:31:27,160 --> 00:31:33,430
Well, no. A garbage collector automatically
deletes leaked memory.

408
00:31:33,430 --> 00:31:34,510
That's what it does.

409
00:31:34,510 --> 00:31:41,200
If an object is no longer referenced, or a group of
objects together are no longer referenced, it deletes them.

410
00:31:41,200 --> 00:31:42,500
That's garbage collectors are for.

411
00:31:42,500 --> 00:31:44,910
They're very good at it.

412
00:31:44,910 --> 00:31:49,410
Unfortunately, they cannot help you with abandoned memory.

413
00:31:49,410 --> 00:31:54,440
If you have a pointer to an object, the garbage
collector does not know whether you'll be using

414
00:31:54,440 --> 00:31:56,520
that pointer in the future.

415
00:31:56,520 --> 00:32:02,030
So, that's the problem with garbage
collector or even non-GC code--

416
00:32:02,030 --> 00:32:07,710
is we have tools and techniques and
garbage collectors to solve leaked memory,

417
00:32:07,710 --> 00:32:12,670
but the abandoned memory may still be a problem
and it can still kill your applications,

418
00:32:12,670 --> 00:32:16,290
swamp your machine just as fast as an actual leak would.

419
00:32:16,290 --> 00:32:20,270
Some examples of abandoned memory.

420
00:32:20,270 --> 00:32:25,670
And let me say, inside Apple, we
spent significant time at the end

421
00:32:25,670 --> 00:32:30,650
of Snow Leopard development looking specifically
for leaked memory and abandoned memory.

422
00:32:30,650 --> 00:32:33,400
These are some real world examples we saw.

423
00:32:33,400 --> 00:32:37,050
You probably have some of these
examples in your code as well.

424
00:32:37,050 --> 00:32:42,390
The first example, a write-only cache,
what the heck is a write-only cache?

425
00:32:42,390 --> 00:32:46,680
A write-only cache, and I'll withhold
the names to protect the guilty.

426
00:32:46,680 --> 00:32:52,320
A write-only cache is where you cache
some information, perhaps some images,

427
00:32:52,320 --> 00:32:55,580
and then you never actually use that cache.

428
00:32:55,580 --> 00:33:01,050
If you reread the same image, you reread the
same image, and put it in the cache again.

429
00:33:01,050 --> 00:33:03,920
Needless to say, this is not a recommended technique--

430
00:33:03,920 --> 00:33:04,420
[ Laughter ]

431
00:33:04,420 --> 00:33:11,980
But the garbage collector and the leak detectors
won't find it because your cache still has pointers

432
00:33:11,980 --> 00:33:16,440
to all these memory you allocated,
but you'll never going to use it.

433
00:33:16,440 --> 00:33:22,750
Similar example is an add-only container where we
have a container or a cache where we add objects

434
00:33:22,750 --> 00:33:25,540
to it, but we never actually remove from it.

435
00:33:25,540 --> 00:33:31,710
Eventually, this container will grow and grow
and grow, and eventually, occupy all your memory.

436
00:33:31,710 --> 00:33:40,460
An example of this was on iPhone previously
in older OS versions, the imageNamed function.

437
00:33:40,460 --> 00:33:47,880
I'm sure all you guys will boo and hiss at the old behavior
of imageNamed, which would allocate an image read from disk,

438
00:33:47,880 --> 00:33:53,430
and then never get rid of it even if your
program was not using that image anymore.

439
00:33:53,430 --> 00:33:57,560
So, the problem was, you know, you get
a memory warning 'cause you're running

440
00:33:57,560 --> 00:34:04,560
out of memory 'cause you have all these images, but
the imageNamed cache will hold on to all of them.

441
00:34:04,560 --> 00:34:08,190
Another example is a pointer to the current document.

442
00:34:08,190 --> 00:34:13,170
This is a particular problem in GC code,
but it's also the problem in non-GC.

443
00:34:13,170 --> 00:34:16,160
So, you have a variable storing the current document.

444
00:34:16,160 --> 00:34:20,880
Let's say you closed that document,
but you don't erase the pointer.

445
00:34:20,880 --> 00:34:25,050
Now, there's a variable that still points
to the document that should be closed,

446
00:34:25,050 --> 00:34:31,880
which means the garbage collector will not delete it because
there's still straight pointer out there pointing to it.

447
00:34:31,880 --> 00:34:36,180
This was an example when we first were
originally writing the garbage collector.

448
00:34:36,180 --> 00:34:39,980
We tried TextEdit as our-- a test application.

449
00:34:39,980 --> 00:34:42,710
We try and run TextEdit with the garbage collector.

450
00:34:42,710 --> 00:34:49,010
There was exactly one line of code that needed to be changed
not was because it had a pointer to the current document,

451
00:34:49,010 --> 00:34:53,640
it did not nil it out when the document was closed.

452
00:34:53,640 --> 00:34:58,030
Final common example is an un-drained autorelease pool.

453
00:34:58,030 --> 00:35:03,410
An autorelease pool will act like an
add-only container if you don't drain it.

454
00:35:03,410 --> 00:35:09,160
So, you can accumulate a large number
of objects in your autorelease pool.

455
00:35:09,160 --> 00:35:14,330
You don't need them clearly if the
autorelease pool were to drain, they'd go away.

456
00:35:14,330 --> 00:35:17,430
But in the meantime, the leak detector won't find them.

457
00:35:17,430 --> 00:35:23,470
And if you've organized your code so it doesn't
drain promptly, then those objects will live longer

458
00:35:23,470 --> 00:35:27,680
than you want, occupying memory you don't need them to.

459
00:35:27,680 --> 00:35:34,200
So, we have some tools for doing
abandoned memory better, for finding it.

460
00:35:34,200 --> 00:35:36,660
So, let me show you an example of that.

461
00:35:36,660 --> 00:35:41,030
I've written a program here that
leaks memory and abandons memory,

462
00:35:41,030 --> 00:35:44,350
and I'm going to show you how to
use Instruments to find that.

463
00:35:44,350 --> 00:35:49,900
In particular, some of the details you
need for garbage collected program.

464
00:35:49,900 --> 00:35:52,120
So, here's my application.

465
00:35:52,120 --> 00:35:53,270
We have a leak button.

466
00:35:53,270 --> 00:35:54,900
This leaks some memory.

467
00:35:54,900 --> 00:36:01,390
We have abandoned button which abandons some memory,
puts it in an array, doesn't get rid of it ever.

468
00:36:01,390 --> 00:36:09,080
This is a garbage-collected program, so
leaking is fine, but abandoning memory is not.

469
00:36:09,080 --> 00:36:14,740
So, I'm running the program in Instruments
with the garbage collection configuration.

470
00:36:14,740 --> 00:36:18,530
We have our object graph, we have our object allocations,

471
00:36:18,530 --> 00:36:24,360
and we have the garbage collection instrument
showing us when GC operations occur.

472
00:36:24,360 --> 00:36:31,080
I'm going to set my allocation's graph to
show the total bytes currently allocated just

473
00:36:31,080 --> 00:36:34,460
because it makes a pretty demo you can see.

474
00:36:34,460 --> 00:36:36,080
So, let's leak some memory.

475
00:36:36,080 --> 00:36:42,120
Of course, this a garbage-collected
application, so leaks should be mostly harmless.

476
00:36:42,120 --> 00:36:43,990
And in fact, they are.

477
00:36:43,990 --> 00:36:47,010
We can look closer at this graph.

478
00:36:48,240 --> 00:36:51,660
And we end up with the stereotypical sawtooth pattern.

479
00:36:51,660 --> 00:36:53,910
Every GC program would look like this.

480
00:36:53,910 --> 00:36:58,250
It'll allocate a bunch of memory, then the
garbage collector kicks in, memory drops,

481
00:36:58,250 --> 00:37:01,930
allocates more memory, garbage collector drops.

482
00:37:01,930 --> 00:37:04,570
You can see the garbage collector going on down here.

483
00:37:04,570 --> 00:37:08,850
This tick marks for when the garbage
collector collects some memory.

484
00:37:08,850 --> 00:37:13,750
Now, if these were a non-GC program,
the graph would not look like this.

485
00:37:13,750 --> 00:37:22,290
Instead, these are real leaks, and the
graph will go up and up and up and up.

486
00:37:22,290 --> 00:37:25,320
So, let's stop leaking for a while.

487
00:37:25,320 --> 00:37:27,570
Let's abandon memory instead.

488
00:37:27,570 --> 00:37:29,190
We're still allocating objects.

489
00:37:29,190 --> 00:37:32,960
But now, we're keeping pointers to those objects alive.

490
00:37:32,960 --> 00:37:34,170
And guess what?

491
00:37:34,170 --> 00:37:38,530
The graph goes up, the garbage collector
tries to do some work but nothing happen,

492
00:37:38,530 --> 00:37:40,940
it tries to do more work, nothing happens.

493
00:37:40,940 --> 00:37:46,000
You can't solve that memory because
there are still pointers to it.

494
00:37:46,000 --> 00:37:53,130
So, the trick here is be able to find which
memory was allocated and not destroyed.

495
00:37:53,130 --> 00:37:56,180
And here is where Instruments can really help us.

496
00:37:56,180 --> 00:37:59,620
There's something in Instruments knew called a heapshot.

497
00:37:59,620 --> 00:38:05,220
A heapshot is a snapshot of your
heap at a particular point in time.

498
00:38:05,220 --> 00:38:12,540
And the trick to finding abandoned memory is to take
multiple heapshots and compare them in multiple points

499
00:38:12,540 --> 00:38:15,970
in time around your program's operations.

500
00:38:15,970 --> 00:38:20,490
So, take a snapshot of your heap as
it is at a particular point in time.

501
00:38:20,490 --> 00:38:27,680
Do some work in your application that should result
in no change in memory, and then do another heapshot

502
00:38:27,680 --> 00:38:31,990
and compare them and see how the
memory in your application change.

503
00:38:31,990 --> 00:38:39,890
So, the usual way to set this up in testing is to have a
cycle that should do work but should not create memory.

504
00:38:39,890 --> 00:38:43,660
For example, open the document and then close it again.

505
00:38:43,660 --> 00:38:46,780
There should be no change in memory once that's done.

506
00:38:46,780 --> 00:38:51,340
Open the document, do some edits
to the file, save it, close it.

507
00:38:51,340 --> 00:38:56,010
Again, there should be no changes
to memory after you've done that.

508
00:38:56,010 --> 00:39:04,930
In my toy application, I have a cycle ones button,
and that does some leaks in some abandoned memory.

509
00:39:04,930 --> 00:39:10,690
Now ideally, that would have no change in
the heap, but because of abandoning memory,

510
00:39:10,690 --> 00:39:14,060
it does have a change in the heap
and Instruments can find that for us.

511
00:39:14,060 --> 00:39:16,070
Let's see that in action.

512
00:39:16,070 --> 00:39:17,610
We hit the cycle button.

513
00:39:17,610 --> 00:39:19,790
We see a big spike in memory.

514
00:39:19,790 --> 00:39:23,290
Because I leaked a whole lot of memory
and then the garbage collector kicked in

515
00:39:23,290 --> 00:39:26,640
and cleaned it up for us, so this looks pretty good.

516
00:39:26,640 --> 00:39:29,930
Of course that time, Instruments didn't cache the spike.

517
00:39:29,930 --> 00:39:35,050
Instruments only sometimes will see
the spike before it goes away again

518
00:39:35,050 --> 00:39:38,640
because the garbage collector is
pretty fast most of the time.

519
00:39:38,640 --> 00:39:43,870
So in these cases, it looks like that the
graph goes way up and then comes back down to

520
00:39:43,870 --> 00:39:46,650
where it started, but instrument is not fooled.

521
00:39:46,650 --> 00:39:49,600
Instruments knows-- can tell that your--

522
00:39:49,600 --> 00:39:56,820
that your altercation is allocating memory that isn't
going away, that that graph is not in fact flat.

523
00:39:56,820 --> 00:40:00,980
So, heapshot is part of the allocations instrument.

524
00:40:00,980 --> 00:40:04,600
It's this button here, mark heap-- let's do that now.

525
00:40:04,600 --> 00:40:05,740
Now, we have the baseline.

526
00:40:05,740 --> 00:40:09,800
All the objects are allocated up
to this point in the application.

527
00:40:09,800 --> 00:40:15,720
Now, we can run a cycle and take another heapshot.

528
00:40:15,720 --> 00:40:23,480
This compares the difference from the second
point in time to the earlier one, to our baseline,

529
00:40:23,480 --> 00:40:30,450
and we can see our heap grew almost 400
kilobytes over the duration of that cycle.

530
00:40:30,450 --> 00:40:34,640
Let's do it again and cycle again.

531
00:40:34,640 --> 00:40:36,980
Let's cycle a bunch of times.

532
00:40:36,980 --> 00:40:43,830
So, we get a bunch of memory spikes and the memory does not
go back down to where it was and heapshot can tell us that.

533
00:40:43,830 --> 00:40:51,470
The second heapshot is being compared to the one before
it, so it can see from the start of the application

534
00:40:51,470 --> 00:41:02,220
to the first heapshot was 300 kilobytes, the next one
was 3.7 megabytes, I guess I hit the button ten times.

535
00:41:02,220 --> 00:41:06,580
And so, you can do this in your
testing matrix in your testing work.

536
00:41:06,580 --> 00:41:12,510
You can even set this up automatically if your application
has scripting capabilities, something like that,

537
00:41:12,510 --> 00:41:20,460
is you can do the work and create snapshots and do the work
and create more snapshots and see what memory is leaking.

538
00:41:20,460 --> 00:41:25,330
Of course, if memory doesn't leak, we
get a heapshot that looks like this.

539
00:41:25,330 --> 00:41:28,950
No memory leaked that time because
I didn't hit the cycle button.

540
00:41:28,950 --> 00:41:32,400
We can run leaks.

541
00:41:32,400 --> 00:41:37,100
The garbage collector should be cleaning
this up, let's see if it actually does.

542
00:41:37,100 --> 00:41:38,650
They can create a heapshot.

543
00:41:38,650 --> 00:41:41,100
And yup, pretty much all the memory is gone.

544
00:41:41,100 --> 00:41:43,020
We can create more heapshots.

545
00:41:43,020 --> 00:41:44,610
All the memory is gone.

546
00:41:44,610 --> 00:41:50,360
So, the garbage collector, while we're
leaking is doing the work we needed to.

547
00:41:51,550 --> 00:41:54,680
Of course in Instruments, you can look at this memory.

548
00:41:54,680 --> 00:41:58,700
You can look at where it was allocated
from, what the objects are.

549
00:41:58,700 --> 00:42:05,410
So, let's look at one of our heapshots and see what were
the objects that were allocated between the first point

550
00:42:05,410 --> 00:42:10,880
and the last point and not destroyed
sometime in the middle or later.

551
00:42:10,880 --> 00:42:17,780
So, we have some CFArrays, twenty of
them were allocated or not destroyed.

552
00:42:17,780 --> 00:42:27,020
And of course, we can use Instruments to pull up our
stack trace of where they were allocated from, like this.

553
00:42:27,020 --> 00:42:35,300
Now, we can see it's in my application, in the cycle
method, in the do-abandon method, we allocated some arrays,

554
00:42:35,300 --> 00:42:40,100
and they were not destroyed between my two heapshots.

555
00:42:40,100 --> 00:42:46,240
And of course, some Instruments, we can pull
up the file and it shows us the source line.

556
00:42:46,240 --> 00:42:54,550
Here's my method that abandons memory, it creates a global
array, it adds stuff to it, and it never does anything else.

557
00:42:54,550 --> 00:43:00,810
So, Instruments is able to analyze the heap,
show us the difference in changes to the heap,

558
00:43:00,810 --> 00:43:03,900
and then show us the allocation points of those objects.

559
00:43:03,900 --> 00:43:08,820
And now, I can decide should that object
be alive or should it have been destroyed.

560
00:43:08,820 --> 00:43:11,730
And if it was not destroyed, why?

561
00:43:11,730 --> 00:43:18,930
At this point, you can go to the rest of Instruments to
see if your garbage collected, who has pointers to it.

562
00:43:18,930 --> 00:43:22,690
If you're not garbage collected, who
retained it and did not release it.

563
00:43:22,690 --> 00:43:25,560
You can find out why is this memory been abandoned.

564
00:43:25,560 --> 00:43:34,550
There's one final detail I want to show you
for garbage collection specifically in order

565
00:43:34,550 --> 00:43:37,560
to use this instrument to the best advantage.

566
00:43:37,560 --> 00:43:39,340
This is Xcode 4.

567
00:43:39,340 --> 00:43:45,290
I created a scheme, run scheme to run in this instrument.

568
00:43:45,290 --> 00:43:51,410
The thing I did is in the arguments,
I have an environment variable set.

569
00:43:51,410 --> 00:43:54,500
AUTO_USE_TLC = NO.

570
00:43:54,500 --> 00:43:56,020
What does this do?

571
00:43:56,020 --> 00:43:59,870
This turns off the thread local garbage collector.

572
00:43:59,870 --> 00:44:08,190
Because on Snow Leopard, the thread local garbage collector
and the heapshot instrument do not play nicely together.

573
00:44:08,190 --> 00:44:11,770
In particular, the thread local garbage collector--

574
00:44:11,770 --> 00:44:18,470
by the way, if you haven't heard of the thread local garbage
collector, it is an optimized mode for garbage collection

575
00:44:18,470 --> 00:44:24,130
for objects that are allocated on one
thread and never moved to another thread.

576
00:44:24,130 --> 00:44:29,880
So, your local variables, your temporary variables,
the garbage collector is extra fast at handling them.

577
00:44:29,880 --> 00:44:34,480
Unfortunately, heapshot and the
garbage collector don't cooperate.

578
00:44:34,480 --> 00:44:40,490
So, if you do not set this environment variable,
heapshot will think you have more objects allocated

579
00:44:40,490 --> 00:44:45,690
than you really do because it won't notice that
the thread local objects have actually gone away.

580
00:44:45,690 --> 00:44:47,380
It thinks they're still alive.

581
00:44:47,380 --> 00:44:52,460
So, set this environment variable and you
will get better precision from Instruments,

582
00:44:52,460 --> 00:44:59,960
and you will have better precision from the
leak detector in garbage collective code.

583
00:44:59,960 --> 00:45:05,650
So, that's the heapshot instrument or the
heapshot addition to the allocation instrument.

584
00:45:05,650 --> 00:45:07,750
It was available on Xcode 3.

585
00:45:07,750 --> 00:45:13,280
It works much better in Xcode 4, and is
more tuned for the workflows you need

586
00:45:13,280 --> 00:45:17,380
for analyzing garbage collected
and non-garbage collected memory.

587
00:45:17,380 --> 00:45:18,160
So--

588
00:45:18,160 --> 00:45:20,900
[ Applause ]

589
00:45:20,900 --> 00:45:27,350
So, abandoned memory, you can find it with Instruments, you
can debug it with Instruments, and you can fix your code.

590
00:45:27,350 --> 00:45:32,380
Of course, depending what kind of abandoned memory
you have, you need to use different techniques.

591
00:45:32,380 --> 00:45:38,950
You might need to limit your cache sizes or
shrink your caches when you get a memory warning.

592
00:45:38,950 --> 00:45:45,430
You may need an explicit invalidation protocol
particularly if you have a GC application,

593
00:45:45,430 --> 00:45:52,490
your closed document code may need to go out and
erase some pointers that you don't need anymore.

594
00:45:52,490 --> 00:45:54,450
You can also use weak pointers.

595
00:45:54,450 --> 00:46:00,490
That was how we fixed TextEdit with this pointer to
the current document, we made it a weak pointer so that

596
00:46:00,490 --> 00:46:05,810
when the document was closed, the garbage
collector erase the variable for us.

597
00:46:05,810 --> 00:46:13,360
And of course, if you have autorelease pool problems, you
may need additional autorelease pools to do your work.

598
00:46:13,360 --> 00:46:19,470
All these techniques work well with garbage
collected and non-garbage collected code.

599
00:46:19,470 --> 00:46:21,930
It's just more important with garbage collected code

600
00:46:21,930 --> 00:46:25,970
because the leak detectors do nothing
for you in garbage collected code.

601
00:46:25,970 --> 00:46:27,920
Actually, that's not quite true.

602
00:46:27,920 --> 00:46:33,580
Of course, in the garbage-collected application,
not everything uses the garbage collector.

603
00:46:33,580 --> 00:46:37,800
Your objects may use the garbage collector,
but perhaps, you call malloc somewhere

604
00:46:37,800 --> 00:46:41,020
and it uses just ordinary malloc and free.

605
00:46:41,020 --> 00:46:47,730
In that case, the leak detector is still a useful tool
for you to run against your garbage-collected application.

606
00:46:47,730 --> 00:46:54,560
If you do use that, you should also set
the AUTO_USE_TLC environment variable.

607
00:46:54,560 --> 00:46:56,900
So, let me show you that environment variable again.

608
00:46:56,900 --> 00:46:59,610
AUTO_USE_TLC = NO.

609
00:46:59,610 --> 00:47:03,670
I don't know if there's any documentation
of this anywhere, but now you know.

610
00:47:03,670 --> 00:47:04,060
[ Laughter ]

611
00:47:04,060 --> 00:47:09,920
This is what you pay the big bucks for, to see
what other people on the internet don't get to see.

612
00:47:09,920 --> 00:47:11,920
[ Applause ]

613
00:47:11,920 --> 00:47:14,380
So, you can use leak detectors.

614
00:47:14,380 --> 00:47:19,380
They work great in GC applications,
but only for the non-GC memory.

615
00:47:19,380 --> 00:47:24,190
You need to use heapshot to find the
abandoned memory and help fix it.

616
00:47:24,190 --> 00:47:28,460
So, that's it for Advanced Objective-C
and Garbage Collection Techniques.

617
00:47:28,460 --> 00:47:29,760
What have we seen today?

618
00:47:29,760 --> 00:47:34,350
We've seen runtime count and decrement
it Great for those here on iPhone,

619
00:47:34,350 --> 00:47:37,800
not so great for those of you still on 32-bit Mac.

620
00:47:37,800 --> 00:47:44,550
We see some old language features like class extensions and
@synthesize, but they've been given new twists available

621
00:47:44,550 --> 00:47:48,400
in the LLVM compiler with your Xcode Preview.

622
00:47:48,400 --> 00:47:51,640
We've explained some of the nitty
gritty behind block objects.

623
00:47:51,640 --> 00:47:55,250
Hopefully, you can fix some bugs
and you have your block usage code.

624
00:47:55,250 --> 00:48:03,340
And we've shown you how to optimize garbage-collected
memory using Instruments and some new heapshot capabilities.

625
00:48:03,340 --> 00:48:10,470
For more information about the programming language,
about programming the runtime and its low-level details,

626
00:48:10,470 --> 00:48:18,930
there's documentation, although I don't know if this is
AUTO_USE_TLC or not, available at Apple's Developer website.

627
00:48:18,930 --> 00:48:23,520
And if you visit the Apple Developer
Forums, I'm frequently there as G.

628
00:48:23,520 --> 00:48:30,660
Parker on the Core OS forums and some of the others,
and you can get some answers to your questions there.

