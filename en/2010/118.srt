1
00:00:06,710 --> 00:00:07,360
>> Good afternoon.

2
00:00:07,360 --> 00:00:10,440
Welcome to Session 118, Mastering Core Data.

3
00:00:10,440 --> 00:00:14,760
Please turn off your WiFi devices they make me nervous.

4
00:00:14,760 --> 00:00:16,660
Much better.

5
00:00:16,660 --> 00:00:22,950
I'm Miguel Sanchez, I'll be doing the first half of the
talk, and then pass it on to Adam Swift to wrap it up.

6
00:00:22,950 --> 00:00:31,450
So Core Data has been around on the desktop since
10.4 Tiger, on iPhone OS since 3.0 last year,

7
00:00:31,450 --> 00:00:35,930
and obviously on the iPad earlier this spring.

8
00:00:35,930 --> 00:00:41,090
The purpose of this session is to help you
become more proficient with our technology.

9
00:00:41,090 --> 00:00:43,820
We are, this is not an introductory session.

10
00:00:43,820 --> 00:00:46,830
We assume a basic level of knowledge with the framework.

11
00:00:46,830 --> 00:00:51,920
You could have attained that by reading the
documentation, or worked through an example.

12
00:00:51,920 --> 00:00:54,500
You certainly don't have to be a super expert.

13
00:00:54,500 --> 00:00:59,050
But we will not be covering the
most basic concepts of Core Data.

14
00:00:59,050 --> 00:01:02,330
This is our to do list for the session.

15
00:01:02,330 --> 00:01:04,730
And let's jump right in.

16
00:01:04,730 --> 00:01:10,340
So let's start out by talking about
some tips and tricks for modeling.

17
00:01:10,340 --> 00:01:12,130
Quick recap.

18
00:01:12,130 --> 00:01:19,040
The modeling, the model is how you describe
your data to us, and we help you manage it.

19
00:01:19,040 --> 00:01:24,080
So the better job you do at describing
that data, the more we're able to help you.

20
00:01:24,080 --> 00:01:29,200
The vocabulary you'll be using to describe your
model are the entities, which more or less correspond

21
00:01:29,200 --> 00:01:35,140
to the tables in your
store, attributes, and relationships.

22
00:01:35,140 --> 00:01:41,840
And you want to make sure that you design your model, not
around an ideal representation of what your data could be,

23
00:01:41,840 --> 00:01:49,390
but more around a practical implementation of how you're
going to be accessing that data with your application.

24
00:01:49,390 --> 00:01:58,050
Once you give us a model the data will be
presented to you as instances of NSManagedObject.

25
00:01:58,050 --> 00:02:00,280
Now you don't need to generate any code.

26
00:02:00,280 --> 00:02:03,000
You can just use the standard class that we provide.

27
00:02:03,000 --> 00:02:09,040
But we actually do want to encourage you
to start using ManagedObjects subclasses.

28
00:02:09,040 --> 00:02:18,090
Why? First, by moving away from the KVC access patterns,
you gain a lot more support from the compiler to tell you

29
00:02:18,090 --> 00:02:20,190
when you're accessing something incorrectly.

30
00:02:20,190 --> 00:02:26,730
It's better to use a more direct set name
accessor method, rather than to set value for key,

31
00:02:26,730 --> 00:02:29,350
and you might mistype name or something like that.

32
00:02:29,350 --> 00:02:31,470
This improves your code readability.

33
00:02:31,470 --> 00:02:35,960
And it's also faster at execution time, because
KVC doesn't have to do the dereferencing

34
00:02:35,960 --> 00:02:41,580
of the method, of the state that you want to access.

35
00:02:41,580 --> 00:02:46,800
Now when I say, please generate subclasses,
I don't mean write a lot of code.

36
00:02:46,800 --> 00:02:52,520
All you have to do is the modeling tool
allows you to generate the stub for the class.

37
00:02:52,520 --> 00:02:59,520
And it's really just a declaration of the properties, so
that the compiler can check them when you're accessing them.

38
00:02:59,520 --> 00:03:06,110
Here we have three properties up on the screen, a first
name, a simple string property, to one relationship manager,

39
00:03:06,110 --> 00:03:08,510
and a to-many relationship direct reports.

40
00:03:08,510 --> 00:03:12,670
Remember that to-many relationships are
represented as sets within Core Data.

41
00:03:12,670 --> 00:03:17,420
You don't even have to write the code for
the implementation for these properties.

42
00:03:17,420 --> 00:03:25,720
If you use the @dynamic compiler directive, we inject
the code at run time, the actual implementations

43
00:03:25,720 --> 00:03:35,920
of these methods for you, so you have; it's all
there for you, you don't have to write the accessors.

44
00:03:35,920 --> 00:03:42,770
Another thing we've seen people have questions around in the
Core Data forums is, once you do the initial implementation,

45
00:03:42,770 --> 00:03:46,520
the initial generation of your classes, what happens

46
00:03:46,520 --> 00:03:51,500
when you have additional properties
that you want to add to your entity?

47
00:03:51,500 --> 00:03:56,880
Do you need to regenerate your whole
classes and stomp over what you had before?

48
00:03:56,880 --> 00:03:58,350
The answer is no.

49
00:03:58,350 --> 00:04:03,520
Please be aware that the modeling tool
has this menu items, design data model,

50
00:04:03,520 --> 00:04:08,220
and then the 4 items where if you select
a particular property in your model,

51
00:04:08,220 --> 00:04:11,820
we generate either the implementation
or the header declaration

52
00:04:11,820 --> 00:04:14,740
for that property, and leave it on the pasteboard.

53
00:04:14,740 --> 00:04:18,530
Then you can go into your specific
file that you've pregenerated

54
00:04:18,530 --> 00:04:21,530
and paste the appropriate piece of code that you have.

55
00:04:21,530 --> 00:04:27,090
So you don't have to stomp, you don't
have to stomp over your preexisting file.

56
00:04:28,890 --> 00:04:33,300
A couple of more tips for working with Managed Objects.

57
00:04:33,300 --> 00:04:37,960
Remember that you are inheriting
from NSManagedObject and NSObject.

58
00:04:37,960 --> 00:04:43,330
So be careful not to use property names that might
conflict with properties that you're inheriting

59
00:04:43,330 --> 00:04:45,870
from these classes, such as Description and Deleted.

60
00:04:45,870 --> 00:04:50,210
Those are the two most common ones
that we see people have conflicts with.

61
00:04:50,210 --> 00:04:56,800
And also remember that, because these are KVC compliant
classes, it's not enough to avoid the property deleted,

62
00:04:56,800 --> 00:04:59,380
but also isDeleted, getDeleted, and setDeleted.

63
00:04:59,380 --> 00:05:03,590
So all the KVC resolutions for a particular name.

64
00:05:03,590 --> 00:05:08,750
So the initial generation of your object is pretty
straight forward, you declare the properties.

65
00:05:08,750 --> 00:05:12,150
But now let's start writing some more interesting code.

66
00:05:12,150 --> 00:05:17,180
A property, a type of property that's
available to you with Core Data are transients.

67
00:05:17,180 --> 00:05:20,130
Transient properties are declared in the model.

68
00:05:20,130 --> 00:05:27,700
You get the benefit of change tracking at memory,
during memory while Core Data is managing the objects.

69
00:05:27,700 --> 00:05:31,810
But their state is not persisted to the Store File.

70
00:05:31,810 --> 00:05:34,640
So you're independent from the source schema.

71
00:05:34,640 --> 00:05:39,170
You're able to add transient properties
without incurring a potential migration step,

72
00:05:39,170 --> 00:05:43,170
because you wouldn't be changing the store schema.

73
00:05:43,170 --> 00:05:50,580
Here's two examples, I mean I walked you through 2 slides
showing what people mostly do with transient properties.

74
00:05:50,580 --> 00:05:51,740
The first is the simplest.

75
00:05:51,740 --> 00:05:55,930
You're simply computing a full name
value from a first name and a last name.

76
00:05:55,930 --> 00:05:59,030
So the first name and the last
name are stored in the database,

77
00:05:59,030 --> 00:06:03,650
but your application requires the
display of this, it's a full name.

78
00:06:03,650 --> 00:06:10,530
So you would write an accessor like the following:
you would see if you've already precomputed that data

79
00:06:10,530 --> 00:06:14,110
by getting the primitive value of full name.

80
00:06:14,110 --> 00:06:20,240
And if you don't have that value yet, you simply concatenate
the first name and last name, and you return that.

81
00:06:20,240 --> 00:06:22,070
So this is a transient property.

82
00:06:22,070 --> 00:06:28,100
You now have access to the full name, even
though full name does not exist in your database.

83
00:06:28,100 --> 00:06:34,970
A more interesting use of transient properties, and
we've got some of this questions in the lab yesterday is,

84
00:06:34,970 --> 00:06:41,330
to reference external resources, which you are
building yourself within your core data instance.

85
00:06:41,330 --> 00:06:47,790
So let's say that you have a particular type that
Core Data doesn't handle, some document object.

86
00:06:47,790 --> 00:06:56,460
You can declare a transient property document object that
depends on a persisted property, persisted document path.

87
00:06:56,460 --> 00:07:02,650
So you are using Core Data to store the string
value of the path to access this resource.

88
00:07:02,650 --> 00:07:08,950
And then you do whatever you need to do
to fetch the actual object from that path,

89
00:07:08,950 --> 00:07:10,840
and you return that in your Core Data object.

90
00:07:10,840 --> 00:07:17,710
So you're using a persisted property, so as a locator for
something that you're going to go out into the file system

91
00:07:17,710 --> 00:07:23,450
and go load yourself in however mechanism you choose to use.

92
00:07:23,450 --> 00:07:28,540
Another type of property that we have
available are transformable attributes.

93
00:07:28,540 --> 00:07:32,490
You can see the list of types that
we support for the attributes

94
00:07:32,490 --> 00:07:36,120
in Core Data from integers though strings, booleans.

95
00:07:36,120 --> 00:07:43,460
If there's a particular type there that you don't
see that you want to use in your attributes.

96
00:07:43,460 --> 00:07:47,880
You can always pick Transformable at the very bottom there.

97
00:07:47,880 --> 00:07:52,620
A Transformable attribute is one
that is handled by Core Data.

98
00:07:52,620 --> 00:07:55,180
We are doing the storing of your data.

99
00:07:55,180 --> 00:07:57,850
But we're converting it into an instance of NSData,

100
00:07:57,850 --> 00:08:02,830
where it's basically binary data
that we're putting in the store file.

101
00:08:02,830 --> 00:08:07,840
But that data to you behaves as
whatever type you declare it to be.

102
00:08:07,840 --> 00:08:14,590
So here, for example, we're declaring a property that's a
NSColor, and we don't have NSColor support in Core Data.

103
00:08:14,590 --> 00:08:16,560
So you do the declaration of your property.

104
00:08:16,560 --> 00:08:19,260
Color is declared as a Transformable property.

105
00:08:19,260 --> 00:08:24,380
And we do the right thing behind the scenes of
archiving and unarchiving the color data for you.

106
00:08:24,380 --> 00:08:28,430
But from your code you're dealing with colors.

107
00:08:28,430 --> 00:08:38,050
When using Transformables we are using a custom,
I'm sorry, a default class of NSValueTransformer.

108
00:08:38,050 --> 00:08:45,340
When would you want to use your own subclass of a valid
transformer and put it into your transformable class?

109
00:08:45,340 --> 00:08:47,760
Core Data doesn't do any encryption of data.

110
00:08:47,760 --> 00:08:55,390
So if you want to archive something out in binary
format, and you want to add an encryption step,

111
00:08:55,390 --> 00:08:59,890
Subclassing ValueTransformer might
be a good way to put that code.

112
00:08:59,890 --> 00:09:03,630
You might not want the default behavior
that we use with keyed archiving.

113
00:09:03,630 --> 00:09:10,740
You might just want a straight write that bytes
data directly to the string that you're writing out to.

114
00:09:10,740 --> 00:09:18,190
And if you do that, make sure that you take into account
endianess between your, the byte ordering of your data,

115
00:09:18,190 --> 00:09:23,520
because your data might be stored in one
platform and fetched in a different platform.

116
00:09:23,520 --> 00:09:27,200
So make sure that if you do, are
writing your own transformer

117
00:09:27,200 --> 00:09:31,010
that you are taking into account the byte ordering issues.

118
00:09:31,010 --> 00:09:36,310
The last thing I want to talk about
Transformable Attributes is

119
00:09:36,310 --> 00:09:43,390
if you do Subclass NSValueTransformer this is the
convention that Core Data uses when calling those 2 methods

120
00:09:43,390 --> 00:09:46,910
that you, the primary methods in ValueTransformer.

121
00:09:46,910 --> 00:09:52,910
When we call Transform Value, we
are going from your type to NSData.

122
00:09:52,910 --> 00:09:58,450
And we're using the reverse transformation
to go from data to your type.

123
00:09:58,450 --> 00:10:04,430
So that's; people get this backwards some times.

124
00:10:04,430 --> 00:10:08,220
There's an example on how we do
this, the photo locations example,

125
00:10:08,220 --> 00:10:11,740
it's associated with this session
if you go to the attendee website.

126
00:10:11,740 --> 00:10:17,990
The last thing I want to touch on in this section
is adapting the model to your access patterns.

127
00:10:17,990 --> 00:10:25,680
So let's say that you have a problem of,
you want to search on titles of books.

128
00:10:25,680 --> 00:10:35,140
So your initial inclination might be to define an entity
book with a simple title property that's a string.

129
00:10:35,140 --> 00:10:36,360
And you want to search on titles.

130
00:10:36,360 --> 00:10:39,800
So searching means contains, right, in database terms.

131
00:10:39,800 --> 00:10:43,480
And you'll also want to strip out the
diacritical marks and case sensitivity,

132
00:10:43,480 --> 00:10:49,920
so you do Contains with the brackets,
DC that's the diacritical stripping.

133
00:10:49,920 --> 00:10:53,270
It turns out that Contains can
be pretty heavy, heavy weight.

134
00:10:53,270 --> 00:11:00,370
This is fully ICU compliant, localization aware,
basically regXmatching at the database level.

135
00:11:00,370 --> 00:11:02,510
So it's a pretty hefty operation.

136
00:11:02,510 --> 00:11:06,770
Not only that, you're doing it each time
you're searching for each row in your database.

137
00:11:06,770 --> 00:11:11,050
So if you have a large dataset you might
not get the performance that you want.

138
00:11:11,050 --> 00:11:14,060
Here's the, a secret for you guys.

139
00:11:14,060 --> 00:11:20,920
Apple, we ourselves on the phone specifically, on
mobile devices, we don't really do full text searching,

140
00:11:20,920 --> 00:11:24,080
full searching in some of the searchers that you're doing.

141
00:11:24,080 --> 00:11:26,730
We're doing prefix matching.

142
00:11:26,730 --> 00:11:31,360
So this is actually very good for most
of the functionalities that you want.

143
00:11:31,360 --> 00:11:37,950
So one trick that you can do is;
first, well actually two tricks here.

144
00:11:37,950 --> 00:11:42,520
You can take care of the normalization of the
data, right when you're setting the title.

145
00:11:42,520 --> 00:11:47,990
So you add a secondary attribute, normalize
title, where you do all of the stripping

146
00:11:47,990 --> 00:11:51,200
of the diacritical marks and standardizing on a case.

147
00:11:51,200 --> 00:11:59,160
And then you put that, you put your normalized title into
your book instance, and then you also index that property.

148
00:11:59,160 --> 00:12:02,010
You also index the normalized title property.

149
00:12:02,010 --> 00:12:09,710
And now you can write a much more efficient predicate
by searching on any normalized title that's greater than

150
00:12:09,710 --> 00:12:14,420
or equal to the prefix that your matching
on, or less than the subsequent prefix.

151
00:12:14,420 --> 00:12:23,600
For example, if your user is typing S T A R, star,
you can use the following predicate to much quicker go

152
00:12:23,600 --> 00:12:28,570
and find taking advantage of the index,
and you get back a much quicker result

153
00:12:28,570 --> 00:12:34,080
than if you're doing a regular contains predicate.

154
00:12:34,080 --> 00:12:41,450
So we also show you how to do this with the direct
property example, also associated with the website.

155
00:12:41,450 --> 00:12:48,170
One final step here, you'll notice that in the previous
slide we're now doing prefix matching on the title,

156
00:12:48,170 --> 00:12:54,190
but we're only matching on the first, on
the beginning of the title, basically.

157
00:12:54,190 --> 00:12:58,280
So what if you want to do the match
on any word on the title?

158
00:12:58,280 --> 00:13:04,030
One thing you can do is split all the words in
your title into a separate title words entity.

159
00:13:04,030 --> 00:13:06,460
And it's one-to-many relationship.

160
00:13:06,460 --> 00:13:08,530
Do the prenormalization.

161
00:13:08,530 --> 00:13:11,930
So you're storing the title words already normalized.

162
00:13:11,930 --> 00:13:15,150
You're still using the same predicate as before.

163
00:13:15,150 --> 00:13:17,870
But now the predicate is searching on title words.

164
00:13:17,870 --> 00:13:20,290
So you're matching on any word in the title.

165
00:13:20,290 --> 00:13:23,650
And whenever you find a match on the title word,

166
00:13:23,650 --> 00:13:29,140
you can just use the relationship back
to point to the book that it belongs to.

167
00:13:29,140 --> 00:13:35,650
Okay? So, this has been an example of how, what I meant by,

168
00:13:35,650 --> 00:13:39,380
see determine what the actual usage
pattern of your application is.

169
00:13:39,380 --> 00:13:40,450
Where is the bottleneck?

170
00:13:40,450 --> 00:13:47,610
Where do you need the fastest turn around
time, and adapt a model to do that.

171
00:13:47,610 --> 00:13:52,090
Let's move on to talk about the Managed Object Life Cycle.

172
00:13:53,170 --> 00:13:58,010
Remember Managed Objects are the instances
of your data that we're providing for you.

173
00:13:58,010 --> 00:13:59,820
They don't exist in a vacuum.

174
00:13:59,820 --> 00:14:04,480
They always exist with regards to
the context that is managing them.

175
00:14:04,480 --> 00:14:07,320
So anytime we talk about the life cycle of an object,

176
00:14:07,320 --> 00:14:11,530
it's always something that's happening
with regards to that context.

177
00:14:11,530 --> 00:14:18,490
So we're inserting a context where, I'm sorry, we're
inserting an object, we're inserting it into the context.

178
00:14:18,490 --> 00:14:22,630
If we're fetching an object, we're
fetching it from the store into the context.

179
00:14:22,630 --> 00:14:28,770
As we're updating our data, setting state on these objects,
the context is maintaining track of what's going on,

180
00:14:28,770 --> 00:14:33,480
so that if we ask it to undo a change,
the context is doing that undo.

181
00:14:33,480 --> 00:14:40,100
When we decide to clean up, there can be at a very high
level two kinds of clean up; either a direct deletion

182
00:14:40,100 --> 00:14:45,900
that you are asking us to perform, because you're
messaging the context, please delete this object.

183
00:14:45,900 --> 00:14:51,350
Or there's more memory level deletion where
we realize that there's no more references

184
00:14:51,350 --> 00:14:55,130
to your instances, so we turn them back into false.

185
00:14:55,130 --> 00:15:01,040
A thinner shell of those objects, that
doesn't use the full memory footprint.

186
00:15:01,040 --> 00:15:08,610
So what are your options for hooking
into this lifecycle of an object?

187
00:15:08,610 --> 00:15:10,520
You have three high level ones.

188
00:15:10,520 --> 00:15:18,280
First is, if you're dealing with per instance
actions your best bet is probably to override methods

189
00:15:18,280 --> 00:15:21,770
from NSManageObject, and I'll be talking about those.

190
00:15:21,770 --> 00:15:31,020
If you want to react to graph level changes, you probably
want to register with the Manage Object Context and listen

191
00:15:31,020 --> 00:15:35,580
for the notifications that it's posting
and react to those notifications.

192
00:15:35,580 --> 00:15:38,390
And thirdly, you remember that as you're asking the context

193
00:15:38,390 --> 00:15:42,090
to perform certain things, some
of those methods return errors.

194
00:15:42,090 --> 00:15:49,230
So make sure that you're inspecting those return values
and reacting to whatever the context is telling you.

195
00:15:49,230 --> 00:15:52,980
So let's go one by one in these.

196
00:15:52,980 --> 00:15:58,530
If you're going to override methods in NSManagedObject,

197
00:15:58,530 --> 00:16:02,010
let's say that you want to add
additional initialization code.

198
00:16:02,010 --> 00:16:08,090
The awake methods, the awake set of methods that you
see on the screen here is our good place to do that.

199
00:16:08,090 --> 00:16:12,010
Let's walk through each one of them independently.

200
00:16:12,010 --> 00:16:14,140
awakeFromInsert.

201
00:16:14,140 --> 00:16:18,300
awakeFromInsert will be called once
during the lifetime of your object

202
00:16:18,300 --> 00:16:23,830
when you do the initial insertion
of that object into a context.

203
00:16:23,830 --> 00:16:28,830
This is a good place to set baseline state for your object.

204
00:16:28,830 --> 00:16:36,190
There will be times, remember that when you're creating
the Managed Object Model we have text fields for each one

205
00:16:36,190 --> 00:16:40,680
of the properties that allow you to
set default values for your properties.

206
00:16:40,680 --> 00:16:43,660
There will be times when this is not enough for you.

207
00:16:43,660 --> 00:16:48,270
For example, if you are creating employees,

208
00:16:48,270 --> 00:16:52,860
when you're doing the model you can't tell
what the next employee ID is going to be.

209
00:16:52,860 --> 00:16:58,230
So the awakeFromInsert is a good place to put that
code where you're initializing the employee ID.

210
00:16:58,230 --> 00:17:04,350
This is the awakeFromInsert from Managed Object;
your own subclass that represents an employee, right?

211
00:17:04,350 --> 00:17:10,350
So this is something you can't put in a
model, so this is where you would put.

212
00:17:10,350 --> 00:17:16,300
awakeFromFetch is very similar to awakeFromInsert, except
that it's called each time that your data is fetched

213
00:17:16,300 --> 00:17:20,630
from the database and an object is created in a context.

214
00:17:20,630 --> 00:17:25,090
What do you want to put here if
you ever override this method?

215
00:17:25,090 --> 00:17:30,040
This is another good place to initialize
transient properties.

216
00:17:30,040 --> 00:17:32,960
Some slides back I showed you the full name method.

217
00:17:32,960 --> 00:17:38,250
That's sort of like an on demand
initialization of your full name property.

218
00:17:38,250 --> 00:17:43,280
But you could also choose to set that
value up once you know that you have all

219
00:17:43,280 --> 00:17:47,060
of your database state and you're awaking from a fetch.

220
00:17:47,060 --> 00:17:53,650
Finally, during the lifetime of your objects
there will be situations that require us

221
00:17:53,650 --> 00:17:57,440
to revert state to your object from a snapshot.

222
00:17:57,440 --> 00:18:02,260
But specifically if you're asking us
to refresh the object or to do an undo,

223
00:18:02,260 --> 00:18:07,410
so there will be times when the object will be
kind of reawakened with state that it had before.

224
00:18:07,410 --> 00:18:12,200
You will be notified of this with
the awakeFromSnapshotEvents method.

225
00:18:12,200 --> 00:18:16,920
This is a good place to put code that
might reset some of your cache data,

226
00:18:16,920 --> 00:18:20,680
so that you can compute it on demand again later on.

227
00:18:20,680 --> 00:18:26,410
So now we move onto the objects where,
I'm sorry, to the mechanisms that you have

228
00:18:26,410 --> 00:18:30,570
to react to states changes for the whole graph.

229
00:18:30,570 --> 00:18:37,350
NSManagedObjectContextObjectsDidChangeNotification
is how the context tells you that,

230
00:18:37,350 --> 00:18:39,500
of what's going on with your edits.

231
00:18:39,500 --> 00:18:43,450
It's post it's notification that informs
you, and a user info dictionary, you'll,

232
00:18:43,450 --> 00:18:48,310
give you the list of inserted objects,
updated objects, deleted objects.

233
00:18:48,310 --> 00:18:55,480
Please note that we're not telling you these are the
changes that have already been saved to your store.

234
00:18:55,480 --> 00:18:59,370
We're only telling you this is what's going
to happen the next time you do a save.

235
00:18:59,370 --> 00:19:06,870
Right? We've processed the changes in memory and this is
what we know about, but you still have to do the save.

236
00:19:06,870 --> 00:19:10,470
When do we; when will you be getting this notification?

237
00:19:10,470 --> 00:19:12,070
When is it posted?

238
00:19:12,070 --> 00:19:17,140
It's posted if you explicitly tell the
context to process all the pending changes.

239
00:19:17,140 --> 00:19:20,430
It will also be posted right before a save.

240
00:19:20,430 --> 00:19:25,510
But it's also posted, very frequently, at the end
of the event loop and anytime we're doing a fetch.

241
00:19:25,510 --> 00:19:30,610
So you're getting this notification
throughout the lifetime of your application.

242
00:19:30,610 --> 00:19:34,320
Other notifications that are posted
by the ManagedObjectContext,

243
00:19:34,320 --> 00:19:38,080
which are interesting for you to hook into.

244
00:19:38,080 --> 00:19:44,550
When we actually do a save you will get the
NSManagedObjectContextWillSaveNotification

245
00:19:44,550 --> 00:19:46,920
and DidSaveNotification.

246
00:19:46,920 --> 00:19:50,530
Some of you have asked on the forums
about time stamping your objects.

247
00:19:50,530 --> 00:19:55,600
So you want to put a timestamp on the
object right when it was last changed.

248
00:19:55,600 --> 00:19:57,080
This is a good place to do that.

249
00:19:57,080 --> 00:20:02,020
If you register to receive the
WillSaveNotification, you know that your graph

250
00:20:02,020 --> 00:20:06,240
of objects that's being communicated
to you is about to be saved.

251
00:20:06,240 --> 00:20:11,350
You can set the timestamp for each one
of those objects, and then we save it.

252
00:20:11,350 --> 00:20:13,690
This is also a good place to set up relationships.

253
00:20:13,690 --> 00:20:20,470
If you remember in the previous slides in the awake methods,
those were meant mostly for single instance manipulation.

254
00:20:20,470 --> 00:20:25,500
So by this point more of the objects are set up,
so you can set up relationships between them.

255
00:20:25,500 --> 00:20:30,600
Once the save does happen, you
will get the DidSaveNotification.

256
00:20:30,600 --> 00:20:37,020
This is a good place to put your code that needs to notify
others in your application that the save has happened.

257
00:20:37,020 --> 00:20:41,560
Let's say that you're managing
multiple context, multiple peer context.

258
00:20:41,560 --> 00:20:45,050
Once the save happens and you want another
secondary context to know about that save,

259
00:20:45,050 --> 00:20:52,670
you can start that messaging from
replying to this notification.

260
00:20:52,670 --> 00:20:54,030
How would you do that?

261
00:20:54,030 --> 00:20:56,700
Let's say that you have more than
one context in your application.

262
00:20:56,700 --> 00:21:04,250
You do a save in one context and you want to communicate
all of those edits that just happened onto another context.

263
00:21:04,250 --> 00:21:09,120
We have a method,
mergeChangesFromContextDidSaveNotification,

264
00:21:09,120 --> 00:21:14,260
which the notification you're sending, by the way,
is the one you got in the DidSaveNotification.

265
00:21:14,260 --> 00:21:19,790
You simply get that, take that notification, and then
you send this message to the other contexts that you want

266
00:21:19,790 --> 00:21:25,870
to have the exact same changes that were
just saved, and we do the merging for you.

267
00:21:25,870 --> 00:21:30,340
Now while we're in the topic of saving, don't forget

268
00:21:30,340 --> 00:21:34,770
that the save method returns a boolean,
and it also has an error parameter.

269
00:21:34,770 --> 00:21:38,800
So what kinds of things can go wrong when a save happens?

270
00:21:38,800 --> 00:21:40,670
The first is validation errors.

271
00:21:40,670 --> 00:21:47,830
Remember that as you were defining your model, you're able
to declare certain boundary conditions about the maximum

272
00:21:47,830 --> 00:21:53,570
and minimum value of your properties,
or optionality of certain values or not.

273
00:21:53,570 --> 00:21:59,960
So if there's any validation issues that we detect
while we're doing the save, we will fail the save

274
00:21:59,960 --> 00:22:03,710
and communicate this back to you in the error parameter.

275
00:22:03,710 --> 00:22:10,660
If there's more than one validation issue, they
will be chained in the NSDetailedErrorsKey.

276
00:22:10,660 --> 00:22:14,590
So be sure to inspect the User Info
Dictionary inside of each error

277
00:22:14,590 --> 00:22:18,760
and see if there's more than one validation problem.

278
00:22:18,760 --> 00:22:24,390
The second type of issue that can cause the
save to fail are optimistic locking failures.

279
00:22:24,390 --> 00:22:32,100
This is a mechanism that we use
to detect multi-writer conflicts.

280
00:22:32,100 --> 00:22:40,750
When we're doing a fetch from the store we
keep around a snapshot of the last value

281
00:22:40,750 --> 00:22:45,150
that we saw for a specific property in the store.

282
00:22:45,150 --> 00:22:52,480
So if anybody else changes that value underneath us in the
store, now that's any, that somebody else could be you.

283
00:22:52,480 --> 00:22:54,620
It could be another thread in your application.

284
00:22:54,620 --> 00:22:57,390
It could be another peer context that you're managing.

285
00:22:57,390 --> 00:23:01,290
It could be another application that's
still dealing with the same store.

286
00:23:01,290 --> 00:23:08,320
Whatever it is, there's a change
in the store, you tell us to save,

287
00:23:08,320 --> 00:23:15,910
and we detect that somebody's changed the value underneath
us, so we will raise an error and we will notify you.

288
00:23:15,910 --> 00:23:22,900
The default policy that Core Data has
is to raise an error when this happens.

289
00:23:22,900 --> 00:23:30,020
If this is not what you want to do, you can change
the merge policy on the Managed Object Context.

290
00:23:30,020 --> 00:23:32,680
And you have here the set of policies that you can set.

291
00:23:32,680 --> 00:23:39,630
If you want us to try to merge the changes from
the store and from changes that you have in memory,

292
00:23:39,630 --> 00:23:44,580
you can use one of the, the second or the third policy.

293
00:23:44,580 --> 00:23:48,280
And with each one of those you're
telling us who do we give priority

294
00:23:48,280 --> 00:23:51,660
to when we detect a conflict on
a property-by-property level.

295
00:23:51,660 --> 00:24:01,480
Do we take state from the store and stomp your memory state,
or do we state from the object and stomp your store state?

296
00:24:01,480 --> 00:24:06,610
Or do you just want us to take the whole object
from memory and override whatever was in the store?

297
00:24:06,610 --> 00:24:10,180
Or do you want us to take whatever was in the
store and override whatever was in memory?

298
00:24:10,180 --> 00:24:14,490
So, you get to pick whatever policy that you want.

299
00:24:14,490 --> 00:24:19,850
But please be aware that our default policy
is just to say this save doesn't work,

300
00:24:19,850 --> 00:24:23,930
because somebody changed the data underneath.

301
00:24:25,020 --> 00:24:26,020
Cleaning up.

302
00:24:26,020 --> 00:24:31,790
Like I said at the intro to this section, there
is two types of clean up, one is deletion.

303
00:24:31,790 --> 00:24:36,420
You're telling the context delete object, or delete.

304
00:24:36,420 --> 00:24:40,370
Remember that the delete doesn't happen
until you do the subsequent save.

305
00:24:40,370 --> 00:24:44,140
So you can tell a context, please delete this
object, but it's just marked for deletion,

306
00:24:44,140 --> 00:24:47,270
it's not actually deleted until you do the save.

307
00:24:47,270 --> 00:24:53,750
When you do the save you will be notified that the save
happened with the WillSave and DidSave notifications.

308
00:24:53,750 --> 00:25:00,420
By the time you're getting those notifications, we've
already done the delete propagation in your graph.

309
00:25:00,420 --> 00:25:05,880
So if you, you can't access the relationships
in your objects within those notifications.

310
00:25:05,880 --> 00:25:11,340
So if you want to keep around; if you want
to kind of take notes about what's going

311
00:25:11,340 --> 00:25:15,870
to be deleted for you to do secondary processing.

312
00:25:15,870 --> 00:25:18,140
For example, if you're managing your own resources,

313
00:25:18,140 --> 00:25:22,200
like that document path example I
showed with the transient properties.

314
00:25:22,200 --> 00:25:26,990
A good way to plug that code is
in the prepareForDeletion method.

315
00:25:26,990 --> 00:25:30,750
This is something you would override
in your NSManagedObject Subclass.

316
00:25:30,750 --> 00:25:34,240
So this is when we're telling you, hey,
we're going to eventually delete this object.

317
00:25:34,240 --> 00:25:36,710
This is where you would say, oh, this object is going away

318
00:25:36,710 --> 00:25:39,960
and I'm managing an external reference
for this object myself.

319
00:25:39,960 --> 00:25:44,350
So let me just keep track of this
path that will eventually be deleted.

320
00:25:44,350 --> 00:25:51,290
So that when I'm notified that the deletion actually
happened, I will go ahead and remove the data.

321
00:25:51,290 --> 00:25:57,210
The second kind of clean up that can
happen is kind of memory level cleanup.

322
00:25:57,210 --> 00:26:00,900
You're not telling us to delete
objects; we're simply cleaning up,

323
00:26:00,900 --> 00:26:04,160
because we don't see that you have referenced this to them.

324
00:26:04,160 --> 00:26:08,100
So please don't override the dealloc method.

325
00:26:08,100 --> 00:26:11,040
We don't quite guarantee at what
point that's going to be called.

326
00:26:11,040 --> 00:26:15,910
The equivalent for you Core Data developers
should be they will turn into fault.

327
00:26:15,910 --> 00:26:19,560
That's where you, that's the equivalent
of dealloc for you guys.

328
00:26:19,560 --> 00:26:22,520
This is where you want to clear
out your caches or any dependencies

329
00:26:22,520 --> 00:26:25,400
that you've registered for for a key value serving.

330
00:26:25,400 --> 00:26:34,450
Now turning something back into a fault happens when
either Core Data detects that we don't have any references

331
00:26:34,450 --> 00:26:39,530
and nobody has references to those objects, or
you're explicitly telling us to refresh an object

332
00:26:39,530 --> 00:26:43,150
by calling the following two methods
on the ManagedObjectContext.

333
00:26:43,150 --> 00:26:45,630
You're telling us to refresh the
object, or you're telling us

334
00:26:45,630 --> 00:26:49,030
to reset the context and turn everything back into a fault.

335
00:26:49,030 --> 00:26:54,050
Please don't call the refreshObject method and
tell us to ignore the merging of the changes

336
00:26:54,050 --> 00:26:59,140
when you have a dirty object, because the
consistency of your graph will get out of sync.

337
00:26:59,140 --> 00:27:05,940
The final thing I want to talk to you
about is multithreading with Core Data.

338
00:27:05,940 --> 00:27:12,140
Most of the time most likely you will be considering
introducing multithreading into your application

339
00:27:12,140 --> 00:27:16,220
to improve the UI responsiveness of your application.

340
00:27:16,220 --> 00:27:23,680
So you want to push; you want to make Core Data
applications, operations asynchronous by pushing them

341
00:27:23,680 --> 00:27:30,850
into a background thread, so that your UI is
free to continue to interact with the user.

342
00:27:30,850 --> 00:27:36,070
Be aware that there's always pitfalls when
working with multithreaded applications.

343
00:27:36,070 --> 00:27:37,150
It doesn't come for free.

344
00:27:37,150 --> 00:27:44,260
So just because you spawn off numerous threads,
all of these have a little bit of a cost

345
00:27:44,260 --> 00:27:46,870
as you're doing the context switching back and forth.

346
00:27:46,870 --> 00:27:50,890
Make sure that all of, even though you have multiple
threads executing, they're not all contending

347
00:27:50,890 --> 00:27:54,160
with the same resource, which defeats the purpose.

348
00:27:54,160 --> 00:28:00,680
And you're also introducing a little bit of complexity
into your application, specifically with the debugging.

349
00:28:00,680 --> 00:28:04,340
So this is not a free solution.

350
00:28:04,340 --> 00:28:11,840
But you do decide to go down this path, so the
golden rule that we want you to always remember is

351
00:28:11,840 --> 00:28:18,510
to give each managed object, each
thread its own Managed Object Context.

352
00:28:18,510 --> 00:28:22,010
And I quote thread here, because you
could be using Grand Central Dispatch.

353
00:28:22,010 --> 00:28:27,860
Basically each concurrent unit of execution
to get its own Managed Object Context.

354
00:28:27,860 --> 00:28:29,820
Managed Objects are not thread safe.

355
00:28:29,820 --> 00:28:33,910
You can't pass them around threads
and expect them to work properly.

356
00:28:33,910 --> 00:28:38,760
What is thread safe is the objectIDs
that each one of those have.

357
00:28:38,760 --> 00:28:40,630
So let me illustrate this.

358
00:28:40,630 --> 00:28:45,520
You have a UI thread interacting with
the user and the background fetching.

359
00:28:45,520 --> 00:28:49,570
The background thread is doing
the fetching of three objects.

360
00:28:49,570 --> 00:28:50,420
You're ready.

361
00:28:50,420 --> 00:28:52,760
You've warmed up the application.

362
00:28:52,760 --> 00:28:57,030
You don't just pass those instances
over into the main thread.

363
00:28:57,030 --> 00:29:00,630
You actually take the object IDs
from this object that you fetched.

364
00:29:00,630 --> 00:29:02,650
You pass that across the thread boundary.

365
00:29:02,650 --> 00:29:11,220
And then you use the method on the context, such as
objectWithID where we construct a local copy of that object.

366
00:29:11,220 --> 00:29:13,750
Now fear not, you're not doing a fetch from scratch here.

367
00:29:13,750 --> 00:29:19,800
Because the background thread was already warming up the
role caches that Core Data uses to create the objects.

368
00:29:19,800 --> 00:29:26,130
So creating an object in the first
context is actually very, very quick.

369
00:29:26,130 --> 00:29:30,890
You are taking advantage of the work that
you're doing with the background fetching.

370
00:29:30,890 --> 00:29:38,390
If your background threads are inserting new
objects, please remember to first save them

371
00:29:38,390 --> 00:29:45,300
to the store before you pass the object ID across
the thread boundary and ask us to fetch it.

372
00:29:45,300 --> 00:29:47,670
When you create an object, we pass a temporary ID.

373
00:29:47,670 --> 00:29:54,540
You can't pass a temporary ID to another context
and expect it to find it unless it's been saved.

374
00:29:54,540 --> 00:30:01,720
So once you do the save the ID becomes permanent
and we can get it from the other context.

375
00:30:01,720 --> 00:30:06,580
If you're doing this with Grand Central
Dispatch, the pattern is the same.

376
00:30:06,580 --> 00:30:08,970
Let's say that you have a serial queue.

377
00:30:08,970 --> 00:30:14,010
You know that blocks inside of a serial
queue will execute serially by definition.

378
00:30:14,010 --> 00:30:21,250
So all of your blocks can potentially share
the same context, instance of context 1 here.

379
00:30:21,250 --> 00:30:27,750
But, and this is a very important but, just because we have
serial queues doesn't mean that you don't have concurrency.

380
00:30:27,750 --> 00:30:31,970
Right? You might have more than serial
queue executing at the same time.

381
00:30:31,970 --> 00:30:38,220
So blocks within different serial queues
could potentially execute concurrently.

382
00:30:38,220 --> 00:30:41,850
So make sure that if you have more than one serial queue,

383
00:30:41,850 --> 00:30:46,550
the blocks in that second queue are
using a different instance of a context

384
00:30:46,550 --> 00:30:49,690
from the blocks in the first serial queue.

385
00:30:49,690 --> 00:30:53,330
And that's how you maintain the golden rule.

386
00:30:53,330 --> 00:30:57,560
Of course if you're using a concurrent
queue, you know that by definition block 4

387
00:30:57,560 --> 00:31:00,650
and block 6 could potentially execute concurrently,

388
00:31:00,650 --> 00:31:05,950
so you take care of giving them different
instances of a context to manipulate.

389
00:31:05,950 --> 00:31:09,630
The last thing I want to talk about
in this section is what happens

390
00:31:09,630 --> 00:31:16,370
when you're doing edits to your data in multiple threads?

391
00:31:16,370 --> 00:31:19,150
Well, what happens is that you
better know what you're doing.

392
00:31:19,150 --> 00:31:26,010
I mean, a lot of this has to do with doing, defining
a work, a good workflow in your application.

393
00:31:26,010 --> 00:31:32,370
Okay? This isn't so much Core Data's problem, it's
what does it mean for somebody to be editing an object

394
00:31:32,370 --> 00:31:34,920
that was deleted in the background, or vise versa, right?

395
00:31:34,920 --> 00:31:37,810
So a lot of that work is you guy's work.

396
00:31:37,810 --> 00:31:45,300
Well once you figure out what it means in your
application, the two mechanisms that Core Data gives you,

397
00:31:45,300 --> 00:31:51,830
and we've seen these methods before is, first if you want to
refresh the state of an object, turn it back into a fault,

398
00:31:51,830 --> 00:31:55,500
you do the refreshObject with mergeChanges method.

399
00:31:55,500 --> 00:32:01,490
Or if you did a lot of processing in a background thread,
in a background context, and now you want to push all

400
00:32:01,490 --> 00:32:06,120
of those changes over into another
context in another thread,

401
00:32:06,120 --> 00:32:11,580
remember that I mentioned the
mergeChangesFromContextDidSaveNotification.

402
00:32:11,580 --> 00:32:13,460
So you're passing all of the objects.

403
00:32:13,460 --> 00:32:17,590
Here, this is the one place where
objects are crossing the thread boundary.

404
00:32:17,590 --> 00:32:19,550
But because this is being handled by Core Data,

405
00:32:19,550 --> 00:32:24,300
we take care of doing the right thing
behind the scene so that nothing goes wrong.

406
00:32:24,300 --> 00:32:27,390
So this is what happens with multi-party edits and deletes.

407
00:32:27,390 --> 00:32:31,510
And now I'll pass it onto Adam to conclude the session.

408
00:32:31,510 --> 00:32:35,780
[ Applause ]

409
00:32:35,780 --> 00:32:37,770
>> Adam: Thank you Miguel.

410
00:32:37,770 --> 00:32:44,470
And now I'd like to dig a little
deeper into fetching and performance.

411
00:32:44,470 --> 00:32:50,550
So you know how critical performance is to providing
a great user experience for your application.

412
00:32:50,550 --> 00:32:56,330
You want your user interface to stay responsive,
even as you scale to dealing with a lot of data.

413
00:32:56,330 --> 00:33:04,770
And the two key strategies for achieving these performance
goals are limiting memory usage by only fetching the data

414
00:33:04,770 --> 00:33:12,020
that you actually are going to show in your user interface,
and amortizing your data base I/O by fetching in batches.

415
00:33:12,020 --> 00:33:18,920
So keep in mind fetching is performing disk I/O.

416
00:33:18,920 --> 00:33:25,200
So you will want to avoid the extremes of fetching
too much data all at once, and on the other hand,

417
00:33:25,200 --> 00:33:29,870
frequently fetching a little bit of
data and repeatedly calling out to I/O.

418
00:33:29,870 --> 00:33:36,990
You want to find that right middle balance where you're
fetching your data in objects and reasonable batches.

419
00:33:36,990 --> 00:33:44,050
And we can do that by leveraging
the strength of the database to do

420
00:33:44,050 --> 00:33:47,530
as much work as possible at the database layer.

421
00:33:48,930 --> 00:33:54,840
So we can use predicates and sort descriptors
to work across your entire data set

422
00:33:54,840 --> 00:33:59,400
at the database level and keep memory and I/O under control.

423
00:33:59,400 --> 00:34:06,380
So I want to walk you through a few examples
of how you can use predicates to do the work

424
00:34:06,380 --> 00:34:10,760
at the database level, and keep
your memory and I/O needs low.

425
00:34:10,760 --> 00:34:17,570
Let's start with an example of how you can avoid
fetching objects from a to-many relationship,

426
00:34:17,570 --> 00:34:22,840
when all you really want to know is how
many objects are in the relationship.

427
00:34:22,840 --> 00:34:31,170
You can use the account expression to avoid fetching those
objects, when all you want to know is how many there are.

428
00:34:31,170 --> 00:34:37,960
For example, if you have a list of music playlists and
you want to find all the playlists without any songs,

429
00:34:37,960 --> 00:34:44,980
you can use the @count expression, and a predicate
like this to look up those playlists without any songs.

430
00:34:44,980 --> 00:34:51,160
And you won't be fetching any of the song data back,
you're just fetching the playlist that match that query.

431
00:34:52,210 --> 00:34:59,580
If you want to work with the attribute value from
objects related through a to-many relationship,

432
00:34:59,580 --> 00:35:10,050
you can use a SUBQUERY expression to access the attributes
owned by the objects in the to-many relationships.

433
00:35:10,050 --> 00:35:14,530
And this gives you a powerful way to
test those attributes without, again,

434
00:35:14,530 --> 00:35:17,880
fetching of any of the objects from the relationship.

435
00:35:17,880 --> 00:35:24,000
So in this example we want to fetch all the
artists with songs longer than 10 minutes.

436
00:35:24,000 --> 00:35:34,280
And we do that with a SUBQUERY expression that takes the
songs, the name of the relationship as its first argument,

437
00:35:34,280 --> 00:35:38,350
and then tests if the song length
is greater than 10 minutes.

438
00:35:38,350 --> 00:35:44,390
If the results of that SUBQUERY, if the songs returned
by that SUBQUERY, affect the count of the songs

439
00:35:44,390 --> 00:35:52,920
that are returned by that SUBQUERY are greater than zero,
then we're going to return that artist in the fetch.

440
00:35:52,920 --> 00:35:58,300
You can also work with and fetch attribute values directly.

441
00:35:58,300 --> 00:36:04,910
So if you're only interested in fetching back
unique attributes from one of your entities,

442
00:36:04,910 --> 00:36:09,210
you can fetch back those unique
attributes as read only dictionaries,

443
00:36:09,210 --> 00:36:13,120
only fetching back the attribute
value without anything else.

444
00:36:13,120 --> 00:36:18,530
You're evaluating that work in the database, and
only fetching back the results you're interested in.

445
00:36:18,530 --> 00:36:23,560
So let's look at an example where we want
to fetch all of the unique album names.

446
00:36:23,560 --> 00:36:32,820
So we tell the request we want it to return distinct
results, we want the results returned as dictionaries,

447
00:36:32,820 --> 00:36:38,960
and all we want is the unique names from our album entity.

448
00:36:38,960 --> 00:36:47,450
And when you execute this fetch, you'll get back an
array of dictionaries with all of those names in it.

449
00:36:47,450 --> 00:36:52,980
You can go even further working with attribute
values directly in the database by calculating

450
00:36:52,980 --> 00:36:57,500
and evaluating aggregate data on those
attributes and returning dictionaries

451
00:36:57,500 --> 00:37:01,150
without fetching all of those objects into memory.

452
00:37:01,150 --> 00:37:06,010
This is a powerful technique for performing
a lot of work at the database level.

453
00:37:06,010 --> 00:37:13,640
So let's look at an example where we want to calculate
the total length of all of the songs in our music library.

454
00:37:13,640 --> 00:37:21,000
So the first thing we need to do is create an expression
that represents the function we want to evaluate.

455
00:37:21,000 --> 00:37:26,560
And in this case we want to take the
sum of the length of all of our songs.

456
00:37:26,560 --> 00:37:32,880
Then we need to wrap that expression in an expression
description that tells our fetch how to encode

457
00:37:32,880 --> 00:37:36,950
that information back in the dictionaries
that we're going to be returning.

458
00:37:36,950 --> 00:37:41,080
And in this case we want the results
back as a double with the name totalTime.

459
00:37:41,080 --> 00:37:50,590
The last thing we need to do is we need to configure our
fetch request to perform the fetch on the song entity,

460
00:37:50,590 --> 00:37:57,080
only search for the property that we've constructed here,
which is the function to calculate the sum of the length,

461
00:37:57,080 --> 00:38:01,150
and return those results as dictionaries.

462
00:38:01,150 --> 00:38:04,200
Again, we're doing an incredible
amount of work at the database level,

463
00:38:04,200 --> 00:38:08,500
and only fetching back the single
result we're interested in.

464
00:38:08,500 --> 00:38:12,960
Sometimes you just want to know how many
objects are going to be returned by a fetch.

465
00:38:12,960 --> 00:38:20,040
Either to display that number on screen, or to make space
for the objects that you're going to be fetching back later.

466
00:38:20,040 --> 00:38:28,600
And you can take any fetch request and ask the context
for the count for that fetch request to get that value.

467
00:38:28,600 --> 00:38:35,330
So in this case I'm showing a table that lists playlist
names, and we can use countForFetchRequest to look

468
00:38:35,330 --> 00:38:38,460
up the number of songs for each playlist.

469
00:38:38,460 --> 00:38:43,810
But then we can go a little bit further with
working in the database by using a sort descriptor

470
00:38:43,810 --> 00:38:47,280
and setting a fetch limit to fetch the first three songs.

471
00:38:47,280 --> 00:38:52,440
So now alongside the number of songs that
we've got, we can show our users a preview

472
00:38:52,440 --> 00:38:55,320
of the first three songs in each playlist.

473
00:38:55,320 --> 00:38:59,670
It's kind of improves the user experience, but
you're only fetching back a little bit more data,

474
00:38:59,670 --> 00:39:03,670
even though you've got a lot of data under the hood.

475
00:39:03,670 --> 00:39:08,650
So now let's take a closer look at what you're
doing when your fetching managed objects.

476
00:39:08,650 --> 00:39:11,730
There are a lot of options available
to you on a fetch request

477
00:39:11,730 --> 00:39:15,860
for how you're fetching objects and
what you're actually getting back.

478
00:39:15,860 --> 00:39:19,170
In the case that you're fetching objects
that you want to use in your working set,

479
00:39:19,170 --> 00:39:25,830
and you want to access the attribute data right away,
you want to fetch back fully faulted managed objects

480
00:39:25,830 --> 00:39:28,000
with all of their attribute values pre-populated.

481
00:39:28,000 --> 00:39:32,780
But you're not going to have to
fetch back all of the relationships,

482
00:39:32,780 --> 00:39:38,020
even though they're fully faulted managed objects,
the relationships are still represented as faults.

483
00:39:38,020 --> 00:39:43,370
So you're not paying the memory cost
for traversing too many relationships.

484
00:39:43,370 --> 00:39:47,890
To get back fully faulted managed objects,
you need to tell your fetch request

485
00:39:47,890 --> 00:39:51,200
that you want to ReturnObjectsAsFaults: NO.

486
00:39:51,200 --> 00:39:54,530
So why would you want to fetch back faults?

487
00:39:54,530 --> 00:39:56,320
Well faults are a very useful tool.

488
00:39:56,320 --> 00:40:00,390
They're a very lightweight placeholder for managed objects.

489
00:40:00,390 --> 00:40:03,460
And their attributes are fetched on demand.

490
00:40:03,460 --> 00:40:11,320
And when you turn a fault into a managed object,
and it fetches its attribute values on demand,

491
00:40:11,320 --> 00:40:17,700
it doesn't change its pointer address, so you're
still working with the same object in memory,

492
00:40:17,700 --> 00:40:21,490
so you can keep it in the array that you
had before; where it used to be lightweight,

493
00:40:21,490 --> 00:40:25,250
now it contains all of the information
from the managed object.

494
00:40:25,250 --> 00:40:32,220
And there's also a middle ground called partial faults,
where you can fetch faults, but specify that you want

495
00:40:32,220 --> 00:40:37,900
to prefetch or you want to specify
that faults should include some subset

496
00:40:37,900 --> 00:40:40,990
of the properties from your managed objects.

497
00:40:40,990 --> 00:40:48,000
So if we wanted to show a listing of song titles, but
we didn't want to fetch another heavier weight attribute

498
00:40:48,000 --> 00:40:56,160
from the song entity, we could tell the fetch request that
we want properties to fetch to include only the title.

499
00:40:56,160 --> 00:41:01,810
And the smallest representation for a
Managed Object is the Managed Object ID.

500
00:41:01,810 --> 00:41:04,420
These things are really small.

501
00:41:04,420 --> 00:41:07,280
Each Managed Object ID is only 16 bytes.

502
00:41:07,280 --> 00:41:11,100
So it's actually possible to work with
a large set of Managed Objects ID's

503
00:41:11,100 --> 00:41:15,680
that represent the Managed Objects
without taking up a lot of space.

504
00:41:15,680 --> 00:41:20,710
As Miguel mentioned before, the Managed Object IDs
are also thread safe, so it's a great way to pass

505
00:41:20,710 --> 00:41:24,550
that information between different threads.

506
00:41:24,550 --> 00:41:28,000
They're also perfectly suited for using in predicates.

507
00:41:28,000 --> 00:41:34,830
So any time you've got a predicate where you would
be supplying a Managed Object in the predicate,

508
00:41:34,830 --> 00:41:39,140
you can supply a Managed Object ID,
and Core Data handles it just fine.

509
00:41:39,140 --> 00:41:46,270
To get back Managed Object ID's you need to tell your fetch
request that you want the Managed Object ID result type.

510
00:41:46,270 --> 00:41:52,100
And then you want to tell the request
not to include the property values.

511
00:41:52,100 --> 00:41:57,640
And you might be thinking, wait a minute, I'm fetching
back Object ID's, they don't have property values.

512
00:41:57,640 --> 00:42:04,970
But by default, the fetch request assumes that
if you're fetching back Managed Object ID's,

513
00:42:04,970 --> 00:42:09,250
then you're probably going to want to use those
Managed Object values some time in the future.

514
00:42:09,250 --> 00:42:15,100
So even though the Managed Object ID doesn't store
the property values, the property values are fetched

515
00:42:15,100 --> 00:42:21,380
into the row cache, so if you later look up the
Managed Object for, or create a Managed Object

516
00:42:21,380 --> 00:42:28,230
for that Managed Object ID, it doesn't need to
do a fetch from the database to get those values.

517
00:42:28,230 --> 00:42:32,650
But if you really want to work with a large number
of Managed Object ID's and minimize the amount

518
00:42:32,650 --> 00:42:37,060
of memory you're using, you want to make sure to
tell the request not to include the property values.

519
00:42:37,060 --> 00:42:43,070
So back to talking about fully faulted managed objects.

520
00:42:43,070 --> 00:42:47,920
If you're not just working with the
attribute values in your working set,

521
00:42:47,920 --> 00:42:55,900
if you're not just displaying the attribute values in your
working set, but you also want to display related values

522
00:42:55,900 --> 00:43:02,140
on screen right now, then you want to prefetch
that relationship, so that as you're displaying,

523
00:43:02,140 --> 00:43:08,370
all of the managed objects in your working set, you're
not having to execute an individual fetch to fault

524
00:43:08,370 --> 00:43:13,590
in those relationships, which, getting
back to amortizing a database I/O,

525
00:43:13,590 --> 00:43:16,750
is incurring a round trip to do a fetch every single time.

526
00:43:16,750 --> 00:43:25,020
So you want to take advantage of prefetching to get
those related values ready for your working set of data.

527
00:43:25,020 --> 00:43:27,220
And I'll show you an example of how to do this.

528
00:43:27,220 --> 00:43:33,990
If you want to show a list of playlist songs, and
alongside the song show the album name for the song.

529
00:43:33,990 --> 00:43:37,320
You can tell the request that you
want to set the relationship keypads

530
00:43:37,320 --> 00:43:40,720
for prefetching to include the album relationship.

531
00:43:40,720 --> 00:43:49,480
So I've talked about a number of techniques you can use
to keep your memory usage low and amortize your I/O.

532
00:43:49,480 --> 00:43:53,290
But what about the times where you
can't control the access pattern?

533
00:43:53,290 --> 00:43:56,670
What about when you're trying to work with some sort of API

534
00:43:56,670 --> 00:44:01,270
that it takes the entire array of
objects that you want to fetch?

535
00:44:01,270 --> 00:44:08,630
How can you batch; how can you fetch your objects in
batches, when you're handing over the entire array?

536
00:44:08,630 --> 00:44:13,180
You might think that you're either handing over an
array of faults, in which case they'll be fetched one

537
00:44:13,180 --> 00:44:17,160
at a time and hit that frequent fetching pattern.

538
00:44:17,160 --> 00:44:20,020
Or you're fetching everything all
at once and handing it over.

539
00:44:20,020 --> 00:44:25,130
In which case you're doing that big
upfront fetch that you wanted to avoid.

540
00:44:25,130 --> 00:44:28,410
Well the fetch request can do this for you automatically.

541
00:44:28,410 --> 00:44:37,400
You can set the batch size, and when you execute your fetch
request, it will return an array subclass that's configured

542
00:44:37,400 --> 00:44:42,460
to automatically fetch your objects
in batches as they're accessed.

543
00:44:42,460 --> 00:44:48,760
And the way you do that is you tell your request,
set the fetch batch size to the size you want.

544
00:44:48,760 --> 00:44:54,770
So I hope you've gotten some good ideas about
things you can do to improve your performance,

545
00:44:54,770 --> 00:44:58,120
your fetching performance with Core Data.

546
00:44:58,120 --> 00:45:03,600
But before you dig in and start making changes
to your code, I want you to use the tools

547
00:45:03,600 --> 00:45:06,090
that are available to you to focus your efforts.

548
00:45:06,090 --> 00:45:11,900
The Core Data instruments and instruments can pinpoint
exactly where in your code you're hitting those fetching

549
00:45:11,900 --> 00:45:18,040
and faulting hotspots, so you can use your efforts
in the spots where you need to put the time.

550
00:45:18,040 --> 00:45:25,260
And I also encourage you to absolutely take a look at the
header files and class documentation for NSFetchRequest

551
00:45:25,260 --> 00:45:29,070
and its expression the Predicate Programming Guide.

552
00:45:29,070 --> 00:45:32,360
And make use of the developer forums as well.

553
00:45:32,360 --> 00:45:38,240
There's also, just searching on the net, you can come
up with all kinds of great information and resources.

554
00:45:38,240 --> 00:45:46,290
So I'm going to wrap up this session today
by looking at the topic of migration.

555
00:45:46,290 --> 00:45:49,770
First of all, why do you need to bother with migration?

556
00:45:49,770 --> 00:45:56,690
Well, think back to the beginning of this session where
Miguel was describing that the data model is your contract

557
00:45:56,690 --> 00:46:03,930
with Core Data that describes how your data
will be saved, and structured, and accessed.

558
00:46:03,930 --> 00:46:13,030
So any time you go to make a change to your data model,
that's going to change how that data is saved and accessed.

559
00:46:13,030 --> 00:46:17,030
So if you want access to your old
data, you need to adapt that old data

560
00:46:17,030 --> 00:46:21,150
to a new structure, and you do that with migration.

561
00:46:21,150 --> 00:46:28,430
In Leopard we introduced versioning and migration using
a custom mapping model that you could hand construct

562
00:46:28,430 --> 00:46:36,370
with flexible logic to translate objects from your old
data model to objects in your new data model, in memory,

563
00:46:36,370 --> 00:46:42,680
by fetching data from your old store with the old
data model, transforming them with the mapping model,

564
00:46:42,680 --> 00:46:45,660
and then saving them to the new
store with the new data model.

565
00:46:45,660 --> 00:46:52,800
In Snow Leopard and in iPhone OS 3
we introduced lightweight migration.

566
00:46:52,800 --> 00:46:59,790
And lightweight migration works by looking at your old data
model and your new data model, analyzing the differences,

567
00:46:59,790 --> 00:47:06,020
and inferring a mapping model automatically to
translate data from your old format to the new one.

568
00:47:06,020 --> 00:47:09,920
As an enormous huge benefit to
this, lightweight migration is able

569
00:47:09,920 --> 00:47:15,640
to perform this migration entirely in
the database using nothing but SQL.

570
00:47:15,640 --> 00:47:19,730
So what kind of changes are supported
with lightweight migration?

571
00:47:19,730 --> 00:47:27,290
Well you can add, or remove, or rename just about anything:
attributes, relationships, entities, all supported.

572
00:47:27,290 --> 00:47:31,860
You can also change the numerical type of
attributes, so you can change an int to a float.

573
00:47:31,860 --> 00:47:39,010
You can promote a relationship from a to-many, or from,
excuse me, you can promote a relationship from a to-one

574
00:47:39,010 --> 00:47:45,710
to a to-many, and preserve the
related objects in the new data model.

575
00:47:45,710 --> 00:47:50,880
You can't go the other direction, however, because
from a to-many to a to-one, there's no way to infer

576
00:47:50,880 --> 00:47:54,500
which objects should be saved and which ones to let go of.

577
00:47:54,500 --> 00:47:57,570
You can even make changes to the
entity inheritance hierarchy.

578
00:47:57,570 --> 00:48:06,350
So you can add a child entity, or a new parent, or you can
even take two peer entities, create a common new parent,

579
00:48:06,350 --> 00:48:12,130
and move properties up from each of the child
entities into the new parent, and into migration.

580
00:48:12,130 --> 00:48:14,280
All the data from those entities will be preserved.

581
00:48:14,280 --> 00:48:21,020
So what do you have to do to take
advantage of lightweight migration?

582
00:48:21,020 --> 00:48:24,770
First, you need to make sure you keep the old data models.

583
00:48:24,770 --> 00:48:26,870
We need this for two reasons.

584
00:48:26,870 --> 00:48:31,850
We need the old data model, so that we can compare
the old model to the new one to infer the changes.

585
00:48:31,850 --> 00:48:35,860
Second, we can't read the old data
without the old data model.

586
00:48:35,860 --> 00:48:40,970
So before you go to make any changes, go to
the Design menu in Xcode, choose Data Model,

587
00:48:40,970 --> 00:48:45,240
add Model Version, and start making changes on the new one.

588
00:48:45,240 --> 00:48:50,500
The second thing you need to do is set the
options when you load your persistent store.

589
00:48:50,500 --> 00:48:53,410
Set the migration options when
you load your persistent store.

590
00:48:53,410 --> 00:49:00,330
That's the migrate persistent stores automatically
option and the infer mapping model automatically option.

591
00:49:00,330 --> 00:49:03,540
Now if you've skipped over step
one you'll see an error like this,

592
00:49:03,540 --> 00:49:08,520
Cocoa error 134130, "Can't find model for source store."

593
00:49:08,520 --> 00:49:13,940
And that means Core Data couldn't find your
source model, so we can't do the migration.

594
00:49:13,940 --> 00:49:18,100
So I said you can rename just about anything.

595
00:49:18,100 --> 00:49:21,360
And I meant it, but you have to give us a hint.

596
00:49:21,360 --> 00:49:26,080
You have to give us a hint in your data model, so
that we can tell when you're renaming something,

597
00:49:26,080 --> 00:49:30,080
as opposed to when you've deleted
one attribute and added a new one.

598
00:49:30,080 --> 00:49:32,290
So I'll show you an example of how this works.

599
00:49:32,290 --> 00:49:37,420
You need to set the renaming identifier, and
we'll do that here to change a song's name,

600
00:49:37,420 --> 00:49:42,150
and our old model to its title in our new model.

601
00:49:42,150 --> 00:49:50,860
So you can see I've got the Xcode data modeling design
tool here, and I'm looking at the song title attribute.

602
00:49:50,860 --> 00:49:53,270
And this is version 2 of our data model.

603
00:49:53,270 --> 00:49:58,280
And I've highlighted where the naming
identifier appears in the inspector.

604
00:49:58,280 --> 00:50:05,520
So all we need to do to preserve the data that used to be
stored as the song name in our new model as the song title,

605
00:50:05,520 --> 00:50:08,440
is put name in as the renaming identifier.

606
00:50:08,440 --> 00:50:16,010
A couple of tips to keep in mind when you're dealing with
lightweight migration, changing a transient attribute

607
00:50:16,010 --> 00:50:20,620
to a persistent attribute is the same to
lightweight migration is adding a new one.

608
00:50:20,620 --> 00:50:23,400
A transient doesn't exist in the persistent store.

609
00:50:23,400 --> 00:50:28,520
So all of the same rules apply as
when you're creating a new attribute,

610
00:50:28,520 --> 00:50:31,420
that it needs to be optional or have a default value.

611
00:50:31,420 --> 00:50:34,940
Or for a new relationship it must be optional.

612
00:50:34,940 --> 00:50:38,040
There's a lot more information available about migration

613
00:50:38,040 --> 00:50:41,770
in the Core Data Model Versioning
and Data Migration Programming Guide.

614
00:50:41,770 --> 00:50:47,130
Covers both lightweight migration and
the custom mapping style of migration.

615
00:50:47,130 --> 00:50:50,020
Before I let you go there's one
more thing I wanted to highlight.

616
00:50:50,020 --> 00:50:56,750
This is a technique that's incredibly useful
for adding back some of that custom flexibility

617
00:50:56,750 --> 00:51:02,370
that you might miss, but doing it in lightweight migration.

618
00:51:02,370 --> 00:51:08,360
And the way it works is with a post-processing
step that you use after migration.

619
00:51:08,360 --> 00:51:15,190
So after you; the way it works is you open your store with
the migration options, check the metadata for a custom key

620
00:51:15,190 --> 00:51:18,570
that you've chosen, like DonePostProcessing.

621
00:51:18,570 --> 00:51:25,010
If the key isn't set, then you do your post-processing to
populate derived attributes, or insert or delete objects

622
00:51:25,010 --> 00:51:29,080
that you want present or removed from
your second, your new data model.

623
00:51:29,080 --> 00:51:34,020
And then set the store metadata, so that
you don't wind up post-processing again.

624
00:51:34,020 --> 00:51:38,260
Then save the changes in metadata and you're good to go.

625
00:51:38,260 --> 00:51:43,970
Now I'll show you a code sample to see,
so you can see exactly how this works.

626
00:51:43,970 --> 00:51:46,710
First we open the store with the migration options enabled.

627
00:51:46,710 --> 00:51:54,200
Then we check the store metadata for
our custom key, DonePostProcessing.

628
00:51:54,200 --> 00:52:00,880
And we check to see if the value for
DonePostProcessing is less than 2.

629
00:52:00,880 --> 00:52:06,760
If it's less than 2, then it's time for us
to update our normalized titles for books.

630
00:52:06,760 --> 00:52:10,940
So we go ahead and do that work to
populate the derived attributes.

631
00:52:10,940 --> 00:52:16,040
And then we make a copy of the metadata to update
our custom key, but preserve the other keys

632
00:52:16,040 --> 00:52:19,500
in the metadata, and set it back on the store.

633
00:52:19,500 --> 00:52:23,250
And finally we save.

634
00:52:23,250 --> 00:52:27,350
A really useful technique for adding back
some of that flexibility that you get

635
00:52:27,350 --> 00:52:30,760
with custom migrations in a lightweight migration form.

636
00:52:30,760 --> 00:52:37,640
So I hope this session has given you some
ideas on how, the many different ways

637
00:52:37,640 --> 00:52:41,350
that you can use Core Data to mature your application.

638
00:52:41,350 --> 00:52:48,690
And I want to stress that you want to invest the time
to come up with a good initial model for your data.

639
00:52:48,690 --> 00:52:52,880
And then Core Data will help you out,
as you need to adopt your application

640
00:52:52,880 --> 00:52:56,580
with evolving access patterns and
incremental changes over time.

641
00:52:56,580 --> 00:53:03,100
And if you do find yourself wanting
for some feature or encountering a bug,

642
00:53:03,100 --> 00:53:08,070
please use the bugreport.apple.com
website to report those to us.

643
00:53:08,070 --> 00:53:09,200
We read them.

644
00:53:09,200 --> 00:53:13,630
And the more information you can provide to help
us understand and reproduce the problem you see,

645
00:53:13,630 --> 00:53:20,250
or feature you'd like, the better
chance it has to be dealt with quickly.

646
00:53:20,250 --> 00:53:26,890
For more information please contact Michael Jurewitz,
our Developer Tools Evangelist, jurewitz@apple.com.

647
00:53:26,890 --> 00:53:29,390
And take a look at the Core Data documentation.

648
00:53:29,390 --> 00:53:35,440
There's great programming guides, examples, and
tutorials, and they're always being updated.

649
00:53:35,440 --> 00:53:39,470
And also take a look at the Apple Developer Forums.

650
00:53:39,470 --> 00:53:46,810
And if you want even more focus on performance on
iPhone applications, come to tomorrow's session at 4:30

651
00:53:46,810 --> 00:53:50,520
where Melissa will talk about Optimizing Core
Data Performance on iPhone OS in Presidio.

