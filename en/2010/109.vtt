WEBVTT

00:00:06.460 --> 00:00:07.780
>> Hello, everyone.

00:00:07.780 --> 00:00:11.530
Welcome to Adopting Multitasking on iPhone OS, Part Two.

00:00:11.530 --> 00:00:16.510
My name is Charles Srisuwananukorn, and I'm a
software engineer on the iPhone Performance Team.

00:00:16.510 --> 00:00:22.510
Joining me later in the talk will be David
Myszewski, who manages the iPhone Performance Team.

00:00:22.510 --> 00:00:25.550
Now, let's recap a little bit what we learned in Part One.

00:00:25.550 --> 00:00:32.820
Multitasking on iOS 4 doesn't mean that applications
need to run all of the time in the background.

00:00:32.820 --> 00:00:36.990
In fact, we believe that most applications don't
need to run all of the time in the background.

00:00:36.990 --> 00:00:42.900
Most applications only need to switch quickly between
each other, which we covered extensively in Part One.

00:00:42.900 --> 00:00:48.760
But, we recognize that there are some applications
that do benefit from executing in the background,

00:00:48.760 --> 00:00:51.470
and that's what we're going to focus on in this session.

00:00:51.470 --> 00:00:58.250
We're going to survey several new services in iOS 4
that you can use in your apps to run in the background

00:00:58.250 --> 00:01:02.490
and implement features that just
weren't possible before in iPhone OS 3.

00:01:02.490 --> 00:01:09.320
In particular, we'll look at the task completion service,
which allows your application to request some extra time

00:01:09.320 --> 00:01:15.240
to run in the background as it enters the
background to complete a task on behalf of a user.

00:01:15.240 --> 00:01:20.670
And then, we'll look at the background audio services,
which your applications can use to play audible content

00:01:20.670 --> 00:01:24.090
to the user in the background, and
respond to the remote control events.

00:01:24.090 --> 00:01:28.970
And then, we'll look at a few location based services.

00:01:28.970 --> 00:01:32.800
The first is a navigation service
for turn-by-turn navigation apps.

00:01:32.800 --> 00:01:36.830
And, a couple of location tracking
services, so your applications can respond

00:01:36.830 --> 00:01:39.080
to location changes while in the background.

00:01:39.080 --> 00:01:45.600
And finally, we'll look at some Voice over IP services
in iOS 4 that your applications can use to make

00:01:45.600 --> 00:01:50.470
and receive phone calls while in the background.

00:01:50.470 --> 00:01:53.040
Now, let's get started with task completion.

00:01:53.040 --> 00:01:58.260
As I said earlier, task completion allows
you to request some extra time to run

00:01:58.260 --> 00:02:01.040
in the background to complete a task on behalf of a user.

00:02:01.040 --> 00:02:07.310
So, when the user taps the Home button, for example, if
your application was in the middle of uploading some photos

00:02:07.310 --> 00:02:13.810
or videos, or applying an image filter to some photos, or
even downloading a digital asset like a magazine or a book,

00:02:13.810 --> 00:02:20.660
you can continue running in the background before
being suspended, so the user doesn't have to wait.

00:02:20.660 --> 00:02:27.030
In iPhone OS 3, your application would have had to
remain in the foreground while it finished these tasks,

00:02:27.030 --> 00:02:29.600
and so the user would have had to wait for your application

00:02:29.600 --> 00:02:33.680
to finish these tasks before using the
device or using another application.

00:02:33.680 --> 00:02:39.410
With task completion in iOS 4, you can do this in
the background and the user doesn't have to wait.

00:02:39.410 --> 00:02:44.890
But, if we let applications use the task completion API
to run arbitrarily or indefinitely in the background,

00:02:44.890 --> 00:02:46.660
that would be really bad for battery life.

00:02:46.660 --> 00:02:54.990
So, the amount of time you get to run in the background with
this API is limited, to prevent excessive battery drain.

00:02:54.990 --> 00:03:00.010
So, let's review the states that your application
goes through as it enters the background.

00:03:00.010 --> 00:03:05.010
On the left there, we have the state diagram
that we saw in Part One earlier this morning.

00:03:05.010 --> 00:03:11.260
When your application is in the foreground, it's in the
active state, and then when the user taps the Home button

00:03:11.260 --> 00:03:17.280
to dismiss your application, it transitions from
the active state into the inactive state briefly,

00:03:17.280 --> 00:03:23.630
and then into the background running state for a short
period of time, where it can prepare for suspension

00:03:23.630 --> 00:03:29.850
by saving out the application state
and reducing its memory usage.

00:03:29.850 --> 00:03:35.050
And then, after that short period of time in the background
running state, it transitions into the suspended state,

00:03:35.050 --> 00:03:38.560
where it's not actually executing,
but it is still resident in memory.

00:03:38.560 --> 00:03:46.080
But, what if your application was in the middle of
doing something; for example, uploading some photos?

00:03:46.080 --> 00:03:50.300
Well, with the task completion API, you
can ask the system to keep the application

00:03:50.300 --> 00:03:53.540
in the background running state
longer than it normally would.

00:03:53.540 --> 00:03:58.970
And so, you have some time while you're running there in
the background running state to finish that photo upload.

00:03:58.970 --> 00:04:03.660
And then, once you've finished the photo upload,
you tell the system that this task is complete,

00:04:03.660 --> 00:04:08.890
and your application will transition from the
background running state there into the suspended state,

00:04:08.890 --> 00:04:14.210
and then it stays in the suspended state
until it comes back to the foreground.

00:04:14.210 --> 00:04:20.880
To use the task completion API, all you have to do
is bracket the operation that you'd like to finish

00:04:20.880 --> 00:04:26.700
in the background, with calls to begin background
task with expiration handler, and end background task.

00:04:26.700 --> 00:04:30.540
And, we'll talk a little bit more about
what the expiration handler is later.

00:04:30.540 --> 00:04:38.300
But, in this code example here, assume the upload
photos method implements the photo uploading.

00:04:38.300 --> 00:04:45.110
Well, before we call upload photos, you simply
call beginBackgroundTaskWithExpirationHandler,

00:04:45.110 --> 00:04:50.020
which will return to you a handle for the background
task, and this tells the system that you're

00:04:50.020 --> 00:04:53.510
about to start an operation that
shouldn't be interrupted in the background.

00:04:53.510 --> 00:05:00.520
And, the system will try its best not to suspend your
application while that background task handle is active.

00:05:00.520 --> 00:05:06.820
And then, once upload photos finishes, you simply call
endBackgroundTask, passing the background task handle,

00:05:06.820 --> 00:05:09.540
and then the system will suspend your application.

00:05:10.830 --> 00:05:17.780
But, as I said earlier, you only have a certain
amount of time to finish this task in the background.

00:05:17.780 --> 00:05:24.840
And so, in our photo upload example, say the photo upload
is taking a little bit longer than it normally does.

00:05:24.840 --> 00:05:29.130
And, we run up against this timeout
that we have for task completion.

00:05:29.130 --> 00:05:33.710
Well, if you don't call endBackgroundTask
with passing it that background task handle,

00:05:33.710 --> 00:05:36.990
the system will then terminate your
application and generate a crash log.

00:05:36.990 --> 00:05:40.020
And of course, when that happens,
your application transitions

00:05:40.020 --> 00:05:43.800
from the background running state
into the not running state.

00:05:43.800 --> 00:05:52.590
To help prevent this ungraceful termination, you can
register what we call an expiration handler with the system.

00:05:52.590 --> 00:05:59.990
And, the expiration handler is just a block of code
that's executed immediately before you hit the timeout.

00:05:59.990 --> 00:06:05.640
And, when you get this call back, you can then
pause that long running task or the background task,

00:06:05.640 --> 00:06:09.780
and then call endBackgroundTask
to let your application suspend.

00:06:09.780 --> 00:06:15.540
Now, you should be aware that this expiration
handler may actually be called on a separate thread;

00:06:15.540 --> 00:06:18.550
on a different thread from the one
that's executing the background task.

00:06:18.550 --> 00:06:23.910
So, you may have some synchronization
issues that you need to be aware of.

00:06:23.910 --> 00:06:30.010
And so, again, because you're about to be suspended,
you should prepare for suspend by saving state

00:06:30.010 --> 00:06:32.860
and reducing memory usage, as you saw in Part One.

00:06:32.860 --> 00:06:38.150
And then again, just pause the background
task; in this case, the photo upload.

00:06:38.150 --> 00:06:41.880
And then, call endBackgroundTask
to let your application suspend.

00:06:41.880 --> 00:06:47.220
Now, here's the example we saw
earlier, in a little bit more detail.

00:06:47.220 --> 00:06:54.730
Again, we have the upload photos method, but imagine
now that this upload photos operation can be paused.

00:06:54.730 --> 00:07:00.560
And, when we pause the upload photos operation, it
remembers that it was uploading; it had uploaded,

00:07:00.560 --> 00:07:06.000
say three out of ten photos, and then it
returns from this upload photos method.

00:07:07.160 --> 00:07:09.630
And, here is the expiration handler,

00:07:09.630 --> 00:07:14.520
and beginBackgroundTaskWithExpirationHandler
takes a block as its first parameter.

00:07:14.520 --> 00:07:20.470
And, if you haven't seen blocks before, the syntax may
look a little bit odd, but for the purposes of this talk,

00:07:20.470 --> 00:07:25.830
it's similar to just passing a function pointer
to begin background task with expiration handler,

00:07:25.830 --> 00:07:30.320
except we can define that function in line,
as we do here between the curly braces.

00:07:30.320 --> 00:07:35.380
Now, there's actually a lot more to blocks than
I've just said, and if you'd like to learn more,

00:07:35.380 --> 00:07:40.900
I encourage you to come to the Introducing
Blocks and GCV on iPhone OS talk later this week.

00:07:40.900 --> 00:07:44.280
Now, back to the example here.

00:07:44.280 --> 00:07:50.240
This block here, these two lines here are the
expiration handler for our upload photos example.

00:07:50.240 --> 00:07:57.330
And, when the upload photos process takes too long
and the system is about to timeout the operation

00:07:57.330 --> 00:08:05.170
and terminate the application, it calls back the expiration
handler, which executes prepareForSuspend and pauseUpload.

00:08:05.170 --> 00:08:10.840
PrepareForSuspend is a helper function I have here that, say
just saves the application state and reduces memory usage,

00:08:10.840 --> 00:08:17.000
because we won't get another chance to save out
our state after our application has been suspended.

00:08:17.000 --> 00:08:25.440
And then pauseUpload there is the method that
will actually pause the photo upload, and again,

00:08:25.440 --> 00:08:31.280
this expiration handler may run on a separate
thread from the one that's running upload photos.

00:08:31.280 --> 00:08:35.750
And so, pauseUpload there handles all of the
synchronization and messages back to the upload thread,

00:08:35.750 --> 00:08:39.440
and then the upload thread returns from upload photos,

00:08:39.440 --> 00:08:43.960
and we call endBackgroundTask,
and then our application suspends.

00:08:43.960 --> 00:08:50.400
Now, there are a few things you should
be aware of with task completion.

00:08:50.400 --> 00:08:55.220
When your application is running using the
task completion API's in the background,

00:08:55.220 --> 00:09:00.800
the system will try to prioritize all foreground
activity above any background task completion activity.

00:09:00.800 --> 00:09:05.340
In particular, your application will be running
at a lower CPU priority, and your network

00:09:05.340 --> 00:09:10.230
and file I/O will be prioritized lower than the
foreground applications network and file I/O.

00:09:10.230 --> 00:09:17.900
And again, as we saw in Part One, the GPU and real-time
threads are off limits to background applications,

00:09:17.900 --> 00:09:22.880
and so if you try to use the GPU, the system
will actually terminate your application.

00:09:22.880 --> 00:09:28.000
That said, you should still try to minimize your
resource usage as much as you can in the background,

00:09:28.000 --> 00:09:31.510
and of course, this involves CPU and memory, as always.

00:09:31.510 --> 00:09:35.650
But, it's also important to end the
background task as soon as possible.

00:09:35.650 --> 00:09:43.700
So, as you saw in the upload photos example, we called
endBackgroundTask as soon as endUploadPhotos returned,

00:09:43.700 --> 00:09:48.700
whether or not we were about to
hit the background task timeout.

00:09:48.700 --> 00:09:54.070
And then, it's also important to make the background
task resumable in case we do hit that timeout

00:09:54.070 --> 00:09:58.230
and the expiration handler is called,
and we suspend the application.

00:09:58.230 --> 00:10:03.590
And finally, it's also important to avoid that
ungraceful termination due to timeout by making sure

00:10:03.590 --> 00:10:08.850
to end the background task in your expiration handler,
or as a consequence of calling the expiration handler.

00:10:08.850 --> 00:10:13.290
Now, I'd like to hand it over to Dave Myszewski, who's
going to tell us a little bit about background audio.

00:10:13.290 --> 00:10:15.570
[ Applause ]

00:10:15.570 --> 00:10:16.400
>> So, I'm David Myszewski.

00:10:16.400 --> 00:10:19.290
I manage one of the iPhone Performance Teams.

00:10:19.290 --> 00:10:22.710
And, we'll talk a little bit about
background audio, and in particular,

00:10:22.710 --> 00:10:26.030
in this section we'll focus on media playback applications.

00:10:26.030 --> 00:10:30.210
There are many different ways in which you can play
audio in the background, and this one will focus on kind

00:10:30.210 --> 00:10:35.440
of the long term, canonical media playback
apps, something like Pandora that you saw.

00:10:35.440 --> 00:10:41.620
So, this type of app will play audible content to the
user, while streaming the audio data over the network,

00:10:41.620 --> 00:10:44.860
and of course, continue playing audio in the background.

00:10:44.860 --> 00:10:49.970
And, one of the great things about our Multitasking
UI in this whole Multitasking solution is

00:10:49.970 --> 00:10:52.730
that we integrate really well with the remote controls.

00:10:52.730 --> 00:10:58.010
So, as you see in the screenshot there, when the user
swipes to the left, they have these media playback controls

00:10:58.010 --> 00:11:00.860
that are available to them, and these controls are available

00:11:00.860 --> 00:11:05.570
to the application that's currently playing
audio, or the last app that's playing audio.

00:11:05.570 --> 00:11:12.910
And, all of these remote controls handle a few different
types of controlling the audio, of media controls.

00:11:12.910 --> 00:11:17.360
There's the multitasking UI; there's,
of course, the lock screen controls.

00:11:17.360 --> 00:11:23.950
And, of course, integration with the headset, so we
can double-path to move to the next track, for example.

00:11:23.950 --> 00:11:28.490
So, we'll give you a very brief
overview about the audio system.

00:11:28.490 --> 00:11:32.550
The main thing is that the audio system
kind of acts like an air traffic controller

00:11:32.550 --> 00:11:35.320
to make sure that we have the best user experience.

00:11:35.320 --> 00:11:40.140
And, we do things like prioritize audio, so that
the right audio, the audio that the user expects,

00:11:40.140 --> 00:11:44.790
is playing at any given point in time, that
some audio mixes and ducks when necessary;

00:11:44.790 --> 00:11:46.700
we'll describe an example of that in a moment.

00:11:46.700 --> 00:11:50.680
And, of course, integrating well
with headsets and external speakers.

00:11:50.680 --> 00:11:57.650
So, today, like I said, we'll focus on the audio
services for a media player style application.

00:11:57.650 --> 00:12:00.930
So, to adopt background audio, it's fairly simple.

00:12:00.930 --> 00:12:03.870
The main thing is there's an info plist key.

00:12:03.870 --> 00:12:09.110
And, the info plist key, you just choose
the app Plays Audio Entry; and then,

00:12:09.110 --> 00:12:14.030
as long as your application is playing audio with
certain audio categories, it will continue playing

00:12:14.030 --> 00:12:19.570
when the user puts the application into the background.

00:12:19.570 --> 00:12:24.360
So, to give you an idea about what the application
life cycle looks for one of these applications,

00:12:24.360 --> 00:12:28.170
when the application is in the front,
it's of course in the active state.

00:12:28.170 --> 00:12:33.460
And then, when the user hits the Home button,
the application transitions from the active state

00:12:33.460 --> 00:12:37.460
through the inactive state and
in the background running state.

00:12:37.460 --> 00:12:44.870
Now, because the developer had chosen to add the audio
key list entry, the UI background modes, to the plist,

00:12:44.870 --> 00:12:49.160
the application continues playing in the
background, and you'll note that there's a Play icon

00:12:49.160 --> 00:12:53.100
in the upper right corner, denoting that there
is an application that's actively playing audio.

00:12:53.100 --> 00:12:58.640
Now, as long as the application is playing
audio, the application will continue to run,

00:12:58.640 --> 00:13:05.500
so when the user presses the Home button, it'll continue to
run until the point at which, say the user pauses the audio.

00:13:05.500 --> 00:13:11.180
When the user pauses the audio, then there's
no longer a need for the application to run,

00:13:11.180 --> 00:13:16.720
so when the music is paused, we transition the
application from the background running state

00:13:16.720 --> 00:13:21.120
to background suspended, to preserve system resources.

00:13:21.120 --> 00:13:24.680
So, how does all of this work?

00:13:24.680 --> 00:13:32.080
Well, every application can have an AV audio session
of singleton object, and some sort of delegate.

00:13:32.080 --> 00:13:35.750
Now, you need to set the correct
category on the AV audio session,

00:13:35.750 --> 00:13:40.180
which in this case is AVAudioSessionCategoryPlayback.

00:13:40.180 --> 00:13:45.590
This is what you would use for a long
term media playback sort of application.

00:13:45.590 --> 00:13:48.910
And, this particular category has
a certain number of behaviors.

00:13:48.910 --> 00:13:55.930
It silences other audio, so if, for example, the user was
playing the iPod app, and then they started using your app,

00:13:55.930 --> 00:14:00.110
you wouldn't want the iPod app to continue playing;
you want your app to be the one that's playing.

00:14:00.110 --> 00:14:06.300
So, this category says; well, we should silence
the iPod audio so that your music can play.

00:14:06.300 --> 00:14:10.240
It also allows you to play the audio behind
the locked screen, which is really desirable.

00:14:10.240 --> 00:14:13.830
When the user locks, if your app's the
front most, you want it to continue playing.

00:14:13.830 --> 00:14:17.050
We ignore the ringer switch, and
of course, for multitasking,

00:14:17.050 --> 00:14:19.580
we continue playing the audio in the background.

00:14:19.580 --> 00:14:23.020
So, all of these behaviors are
defined by the audio category,

00:14:23.020 --> 00:14:27.530
and audio categories help us get
the right user experience here.

00:14:27.530 --> 00:14:34.380
If you're a background audio app, you need
to handle audio interruptions appropriately,

00:14:34.380 --> 00:14:38.280
so that we get the correct kind of
behavior for the user experience.

00:14:38.280 --> 00:14:43.010
So, audio interruptions can happen in a few
different places; we'll describe one in a moment.

00:14:43.010 --> 00:14:48.010
But, during this interruption, the audio
system will silence your application.

00:14:48.010 --> 00:14:50.720
And, in that case, say you're running in the foreground.

00:14:50.720 --> 00:14:56.700
You'd want to, of course, update your UI appropriately
so that when they go to the app, the UI looks correctly.

00:14:56.700 --> 00:15:00.910
And, of course, you may want to resume
the audio after the interruption,

00:15:00.910 --> 00:15:04.320
if the audio system says that your application should.

00:15:04.320 --> 00:15:06.230
So, how does this all work?

00:15:06.230 --> 00:15:11.710
Well, again we have your audio session
delegate and the AV audio session objects.

00:15:11.710 --> 00:15:17.550
If there's an incoming phone call and your application
is playing audio in the background, so, it's Erwin.

00:15:17.550 --> 00:15:21.280
So, Erwin's our good friend; we're going
to accept the call and talk to him.

00:15:21.280 --> 00:15:28.750
When we hit the Accept button, then the AV audio session
will send a beginInterruption event to your application,

00:15:28.750 --> 00:15:33.020
and this denotes that your application was interrupted.

00:15:33.020 --> 00:15:35.020
And, you should do a few things here, of course.

00:15:35.020 --> 00:15:38.650
If you were busy downloading a stream from the
network; well, your audio isn't going to play,

00:15:38.650 --> 00:15:41.150
so you should stop downloading the stream.

00:15:41.150 --> 00:15:41.790
You should update the UI.

00:15:41.790 --> 00:15:46.310
Maybe your app was in the foreground, and so
you should toggle the Play/Pause button, et.

00:15:46.310 --> 00:15:49.690
cetera, just like you would; or,
the Play Time, things like that.

00:15:49.690 --> 00:15:53.550
And, of course, if you had some
sort of, maybe 3D visualization,

00:15:53.550 --> 00:15:57.350
you'd want to stop the visualization when this happens.

00:15:57.350 --> 00:16:03.350
So, then your audio will be interrupted, and
then let's say the user hits the End Call button.

00:16:03.350 --> 00:16:05.850
So, the user is no longer talking to the person.

00:16:05.850 --> 00:16:08.230
Your audio isn't playing.

00:16:08.230 --> 00:16:14.380
Now, the AV audio session will send you an endInterruption method; an endInterruption with flags.

00:16:14.380 --> 00:16:21.150
And, this will tell you that the interruption is over and
it's maybe time for your application to continue playing.

00:16:21.150 --> 00:16:28.790
In this particular method, there's a flag; the
AV audio session interruption flag should resume,

00:16:28.790 --> 00:16:32.910
and that's a flag that's set by the audio system
that tells you whether or not you should resume.

00:16:32.910 --> 00:16:37.150
So, as an example, for the phone call
case you would want to resume your audio.

00:16:37.150 --> 00:16:39.510
But, if the iPod were the one who interrupted you,

00:16:39.510 --> 00:16:42.550
then when the user stops playing the
iPod, you wouldn't want to resume.

00:16:42.550 --> 00:16:47.470
So, as long as you implement the right behavior with
this flag, your application will work really well

00:16:47.470 --> 00:16:55.440
with the audio system, and everything will
work just like the user really expected it to.

00:16:55.440 --> 00:17:01.930
So, we have these nice media playback controls, and
we give you some API's to take advantage of these.

00:17:01.930 --> 00:17:06.410
As I said before, that the last app that
was playing the audio receives the events.

00:17:06.410 --> 00:17:10.530
So, if the user paused your app, you
know, five hours ago and decides; boy,

00:17:10.530 --> 00:17:13.480
I want to hit the Play button,
I want to listen to some audio.

00:17:13.480 --> 00:17:19.300
The last app wins, so the user will
start playing your application's audio.

00:17:19.300 --> 00:17:24.700
All of these events are routed through the responder
chain; we'll show you which method to implement here.

00:17:24.700 --> 00:17:31.180
And, one of the things about audio behavior is, like we
showed before, once the user pauses your application,

00:17:31.180 --> 00:17:36.780
the application remains in the suspended state
until the user either relaunches your application

00:17:36.780 --> 00:17:41.640
or uses the media controls to play your application.

00:17:41.640 --> 00:17:42.810
So, how does this work?

00:17:42.810 --> 00:17:49.390
So, the user paused their application a few hours
ago, but the app is still alive in the background.

00:17:49.390 --> 00:17:52.180
So then, when the user; so, you're
in the background suspended state

00:17:52.180 --> 00:17:56.310
and then the user presses the Play
button in one of those media controls.

00:17:56.310 --> 00:18:03.510
Then, we resume your application for just a little bit
of time to allow you to handle this incoming event.

00:18:03.510 --> 00:18:07.460
So, we'll move your application
to the background running state.

00:18:07.460 --> 00:18:10.880
Then, let's say that you saw that;
oh, this was a play event.

00:18:10.880 --> 00:18:14.320
If it was a play event, you would start playing audio.

00:18:14.320 --> 00:18:18.000
And of course, if you start playing audio,
because you're a background audio app,

00:18:18.000 --> 00:18:21.370
you will continue running and playing
audio in the background.

00:18:21.370 --> 00:18:28.410
So, that's how the app life cycle works for
a media playback app with media controls.

00:18:28.410 --> 00:18:30.730
So, how do you implement this?

00:18:30.730 --> 00:18:32.320
Well, it's fairly easy.

00:18:32.320 --> 00:18:38.160
You have a UI application method called
beginReceivingRemoteControlEvents.

00:18:38.160 --> 00:18:44.210
This tells the system that your audio application
is interested in receiving these events that happen

00:18:44.210 --> 00:18:48.630
from the multitasking UI, the lock
screen controls and the headsets.

00:18:48.630 --> 00:18:54.960
And then, somewhere in the responder chain, you
implement this method; remoteControlReceivedWithEvent.

00:18:54.960 --> 00:19:00.040
The documentation for this is in UIEvent, but
there are several different event sub-types

00:19:00.040 --> 00:19:05.360
that you can handle appropriately, so one to
toggle Play and Pause, one to go to the next track,

00:19:05.360 --> 00:19:08.350
one to go to the previous track, and
there are about a dozen of these.

00:19:08.350 --> 00:19:14.100
And, you should implement any of these that are specific
to your application, that make sense for your application.

00:19:14.100 --> 00:19:21.800
It's also important to use these sub-types for exactly
the kind of behavior that the users would expect.

00:19:21.800 --> 00:19:25.840
So, Play/Pause should play/pause; you
shouldn't overload it with a different meaning.

00:19:25.840 --> 00:19:30.650
That way, everything behaves as correctly;
Play button really plays, et cetera.

00:19:30.650 --> 00:19:37.300
So, this is the method that will be called to handle
the event, if say your application is unsuspended.

00:19:37.300 --> 00:19:47.920
So, for the background audio solution, we make sure
that you, as developers, have access to all of the tools

00:19:47.920 --> 00:19:49.860
that you need in order to play background audio.

00:19:49.860 --> 00:19:55.820
So, if you, for example, are an
application that synthesizes audio;

00:19:55.820 --> 00:20:00.920
those applications have some really hard real-time deadlines
that have to be made, so we make sure that we allow you

00:20:00.920 --> 00:20:05.280
to play those kinds of apps, because we
want those kinds of apps to be available.

00:20:05.280 --> 00:20:09.140
And so, as part of this, it's really
important to minimize your resource usage,

00:20:09.140 --> 00:20:11.520
just as it is for any other background application.

00:20:11.520 --> 00:20:16.270
You know, we'll make sure that you get the CPU,
the file I/O, the networking that you need.

00:20:16.270 --> 00:20:20.570
And then, on the other side, if you can minimize your
resource consumption, then it'll be a better experience

00:20:20.570 --> 00:20:26.910
for all of the users because this is one system, and
so you should reduce your memory usage and CPU usage,

00:20:26.910 --> 00:20:30.490
since we have a lot of shared resources
that we need to have.

00:20:30.490 --> 00:20:33.970
And, a lot of the audio apps are really good about this.

00:20:35.730 --> 00:20:39.790
One important bit; if you're an application
that's streaming data to the network,

00:20:39.790 --> 00:20:46.040
it's really important to request
and download data in chunks.

00:20:46.040 --> 00:20:50.730
So, if I have, say a three-minute audio track,
it's probably a good idea to try to download,

00:20:50.730 --> 00:20:52.530
say all three megabytes of that audio track.

00:20:52.530 --> 00:20:59.000
And, the reason is, particularly over 3G,
it's very expensive to send and receive data.

00:20:59.000 --> 00:21:03.260
The radios are some of the most
power hungry parts of the system.

00:21:03.260 --> 00:21:09.740
So, as an example, let's say that I downloaded
maybe, I don't know, 30 seconds of the music.

00:21:09.740 --> 00:21:14.050
So, that's denoted by the orange box.

00:21:14.050 --> 00:21:18.080
Then, the red box shows how the 3G radio behaves.

00:21:18.080 --> 00:21:24.480
So, the cell towers tell the 3G radio to stay in a high
powered state shortly after the transmission is done.

00:21:24.480 --> 00:21:31.890
So, there's some period of time after which the last
byte is sent or received for which the 3G radio will stay

00:21:31.890 --> 00:21:36.670
on high power, because the cell towers said
that we needed to stay in the high power state.

00:21:36.670 --> 00:21:41.820
And then, at a certain period of time, the cell
towers will tell us to go into a lower power state.

00:21:41.820 --> 00:21:47.770
So, what that means is that if we're trying to
send and receive, say a few bytes at a time,

00:21:47.770 --> 00:21:52.030
then our 3G radio power will be pretty
high for a pretty long period of time.

00:21:52.030 --> 00:21:55.710
So, what you really want to do is just request data in bulk.

00:21:55.710 --> 00:22:02.470
Get all of the data that you can, and that way the 3G
radios kind of are, you know, are in the right power states.

00:22:02.470 --> 00:22:07.950
So, you want to send and receive data in bulk, and
that's true for anything; it's not just background audio.

00:22:07.950 --> 00:22:10.540
Send and receive data in bulk will be better for power.

00:22:10.540 --> 00:22:17.440
Now, the last thing about background audio is, of
course, we provide background audio recording as well.

00:22:17.440 --> 00:22:21.920
And, this works conceptually just the
same way the background playback does.

00:22:21.920 --> 00:22:24.230
There are a few quick differences.

00:22:24.230 --> 00:22:28.700
One is, of course, you need to use a
different audio category; the record category,

00:22:28.700 --> 00:22:33.040
which tells us that you're recording
audio in the background.

00:22:33.040 --> 00:22:37.200
And, on your behalf, if your application
is recording in the background,

00:22:37.200 --> 00:22:43.910
the system will create a double-height status bar that's
read, so that the user knows that there's some application

00:22:43.910 --> 00:22:47.720
out there recording audio; so, for privacy reasons.

00:22:47.720 --> 00:22:53.750
And then also, we provide great functionality to tap the
status bar, so that the user can return right to your app,

00:22:53.750 --> 00:22:57.740
and then maybe stop the recording or make a new recording.

00:22:57.740 --> 00:23:02.020
So, these are a couple of the capabilities
that we provide for background recording.

00:23:02.020 --> 00:23:06.570
And, so that's Background Audio, and Charles
is going to show you a quick example here.

00:23:06.570 --> 00:23:11.890
>> Charles Srisuwananukorn: So, I'd like to demo
now how to create a background audio application.

00:23:11.890 --> 00:23:16.300
But, since we only have a limited amount
of time, I'm going to cheat a little bit

00:23:16.300 --> 00:23:21.560
and start with some example code from developer.apple.com.

00:23:21.560 --> 00:23:25.650
So, let me switch over to the device here.

00:23:25.650 --> 00:23:33.230
And, here I have a slightly modified version of
the AV Touch sample from developer.apple.com.

00:23:33.230 --> 00:23:40.590
And, you'll notice that if I tap Play, [Music] the audio
starts playing and it shows the current track name,

00:23:40.590 --> 00:23:47.540
the play time of the track, and it has this nice level meter
visualization and actually uses GL to draw the level meter.

00:23:47.540 --> 00:23:54.160
But, if I tap the Home button now, to send it to the
background, the audio actually fades out and stops.

00:23:54.160 --> 00:24:00.120
So, let's look at how we can modify AV Touch so
that its audio continues to play in the background

00:24:00.120 --> 00:24:03.770
and it behaves well as a background audio application.

00:24:03.770 --> 00:24:06.820
So, I'm going to switch over to Xcode
now, and the first thing I'm going

00:24:06.820 --> 00:24:10.950
to do is edit the info plist for the AV Touch application.

00:24:10.950 --> 00:24:17.710
And so, I'm going to add a row down here, but now I'm
going to zoom in so that you can actually read that.

00:24:17.710 --> 00:24:22.440
And, I'm going to select the required
background modes key in the info plist.

00:24:22.440 --> 00:24:29.140
This is actually an array, so I have to drop down the
disclosure triangle there, and the first item that I'm going

00:24:29.140 --> 00:24:34.810
to add, or the only item I'm going to add for this
background audio application, is the App Plays audio value.

00:24:34.810 --> 00:24:37.280
And now, let me zoom up.

00:24:37.280 --> 00:24:43.750
Now, with this key, AV Touch can actually play audio in the
background, but if I build and deploy this to the device,

00:24:43.750 --> 00:24:48.040
I'll find that when I tap Home, the audio still stops.

00:24:48.040 --> 00:24:53.650
And if I take a look at the crash logs in
Xcode, or in the console in the Xcode organizer,

00:24:53.650 --> 00:24:59.540
it'll tell me that my application was using the
GPU in the background, for that GL level meter.

00:25:00.620 --> 00:25:07.690
So, what I need to do is stop the level
meter when AV Touch enters the background,

00:25:07.690 --> 00:25:10.610
and then resume the level meter when
AV Touch returns to the foreground.

00:25:10.610 --> 00:25:16.700
And, I'm going to do that in the Awake
from NIB of this AV Touch controller class,

00:25:16.700 --> 00:25:20.950
which is called when the AV Touch
controller is loaded from the NIB.

00:25:20.950 --> 00:25:28.090
And then, the first thing I'm going to do is register
for the UI application, didEnterBackgroundNotification,

00:25:28.090 --> 00:25:33.040
which was sent whenever AV Touch goes into the background,

00:25:33.040 --> 00:25:37.410
and I'm going to do that by grabbing the default
notification center and adding in observer

00:25:37.410 --> 00:25:42.370
on the default notification center that
calls this pause level meter helper function.

00:25:42.370 --> 00:25:47.320
So, this will actually pause the level meter when it goes
into the background, and so it can continue playing audio

00:25:47.320 --> 00:25:50.940
without terminating due to background GPU access.

00:25:50.940 --> 00:25:56.210
But, I also need to resume the level meter when it comes
back to the foreground, so to do that I'm going to register

00:25:56.210 --> 00:26:00.380
for the UI application, WillEnterForegroundNotification,
which as its name suggests,

00:26:00.380 --> 00:26:03.980
will be sent when the application
comes back to the foreground.

00:26:03.980 --> 00:26:09.860
And again, I do that by adding an observer to
the default notification center and this time,

00:26:09.860 --> 00:26:12.680
I'm going to call the resume level meter helper function.

00:26:12.680 --> 00:26:15.020
Now, I'm not going to show you
what these two helper functions do,

00:26:15.020 --> 00:26:19.900
because it actually touches quite a
few files and we don't have the time.

00:26:19.900 --> 00:26:25.740
But, it essentially stops the update timer
from my GL drawing, and if you'd like to see

00:26:25.740 --> 00:26:28.580
that in more detail, please come to the labs.

00:26:29.600 --> 00:26:32.440
Now I've paused the GPU access while in the background.

00:26:32.440 --> 00:26:37.400
The next thing I want to do is respond to
interruptions appropriately, as Dave mentioned earlier.

00:26:37.400 --> 00:26:42.600
And, I'm going to do that down here where we see

00:26:42.600 --> 00:26:48.640
that the AV Touch controller is already implementing
the beginInterruption and endInterruption methods.

00:26:48.640 --> 00:26:50.970
The beginInterruption method is okay,

00:26:50.970 --> 00:26:55.580
but the endInterruption method really
should be endInterruptionWithFlags.

00:26:55.580 --> 00:27:00.420
So, I'm going to replace this method
with endInterruptionWithFlags,

00:27:01.600 --> 00:27:09.930
and then in endInterruptionWithFlags, I check whether
the ShouldResume flag is set on the flags parameter sent

00:27:09.930 --> 00:27:14.160
to this delegate method, and if it's
set, then I call Start Playback.

00:27:14.160 --> 00:27:22.280
Now, the last thing I'd like to do as a background audio
application is respond to the remote control events.

00:27:22.280 --> 00:27:26.940
And, as we said earlier, the remote control events
are sent through the normal UI responder chain,

00:27:26.940 --> 00:27:30.590
so I'm going to edit the AV Touch view
controller, which is the view controller

00:27:30.590 --> 00:27:35.020
for that main view that you saw in AV Touch.

00:27:35.020 --> 00:27:39.520
And, the first thing I'm going to do
is override canBecomeFirstResponder,

00:27:39.520 --> 00:27:44.980
so that we can receive those remote control
events in this class, and I'm going to return Yes.

00:27:44.980 --> 00:27:49.750
And then, I need to tell the system
that my application is interested

00:27:49.750 --> 00:27:53.890
in these remote control events, and
handle the remote control events.

00:27:53.890 --> 00:27:59.180
So, I'm going to do that in the
viewDidAppear for this view controller,

00:27:59.180 --> 00:28:05.450
and I'm going to call beginReceivingRemoteControlEvents,
which tells the system to route remote control events

00:28:05.450 --> 00:28:09.360
to my application if I was the
last application to play audio.

00:28:09.360 --> 00:28:15.360
And then, I'm going to call becomeFirstResponder, which
makes the AV Touch view controller the first responder

00:28:15.360 --> 00:28:19.830
in the responder chain, so when those events
come to my application or come to AV Touch,

00:28:19.830 --> 00:28:24.630
the AV Touch view controller is the
first class to handle these events.

00:28:24.630 --> 00:28:29.540
Now, of course, I need to actually process the events,

00:28:29.540 --> 00:28:37.080
and I'm going to do that by overriding the
remoteControlReceivedWithEvent method from UI responder,

00:28:37.080 --> 00:28:39.330
and then switching on the event sub-type.

00:28:39.330 --> 00:28:43.520
And in this case, the only event that I'm
handling is the Toggle Play/Pause event,

00:28:43.520 --> 00:28:47.960
but I could also handle the previous
Track and Fast Forward Track if needed.

00:28:47.960 --> 00:28:50.680
So, I'm going to go ahead and build and run that.

00:28:50.680 --> 00:28:57.820
So, now when I press Play, [Music] you'll notice that again,
it has the track name and the play time, the level meter,

00:28:57.820 --> 00:29:03.720
but now in the upper right corner by the battery
meter, you see a little Play icon indicating

00:29:03.720 --> 00:29:06.930
that there's an application playing audio in the system.

00:29:06.930 --> 00:29:11.790
If I now tap Home, the audio continues playing.

00:29:11.790 --> 00:29:18.980
And now, if I double-tap to bring up the
multitasking UI, and slide over to the remote controls

00:29:18.980 --> 00:29:22.990
in the multitasking UI, I can actually pause it from here.

00:29:22.990 --> 00:29:26.950
And in addition, I can lock the device,

00:29:26.950 --> 00:29:35.620
bring up the controls on the lock screen,
resume playing from the lock screen.

00:29:35.620 --> 00:29:38.030
[Music] And also, one last thing.

00:29:38.030 --> 00:29:42.540
If you look at the remote controls in the
multitasking UI again, you notice that the icon next

00:29:42.540 --> 00:29:47.270
to the remote controls actually
changed to the icon for AV Touch.

00:29:47.270 --> 00:29:53.360
If I now tap the icon there next to the remote
controls, it returns me back to AV Touch.

00:29:53.360 --> 00:29:56.060
The track was looping there, it didn't stop playing; sorry.

00:29:56.060 --> 00:29:58.710
>>David Myszewski: So, that's Background Audio.

00:29:58.710 --> 00:30:04.300
So now, we have a few more categories that
we want to cover, starting with Navigation.

00:30:04.300 --> 00:30:07.910
So, Navigation works a lot like
Background Audio, as you'll see.

00:30:07.910 --> 00:30:14.290
So, we're going to create a very simple example application
here, which is kind of a turn-by-turn directions app.

00:30:14.290 --> 00:30:19.730
And, that app would want to keep the users informed
of their current location at a very granular level,

00:30:19.730 --> 00:30:25.720
so that we don't miss any turns, and
speak out turn-by-turn directions.

00:30:25.720 --> 00:30:27.800
So, how do we do this?

00:30:27.800 --> 00:30:32.420
Well, this type of application would want
to register for both background location

00:30:32.420 --> 00:30:34.500
and background audio in the info key list.

00:30:34.500 --> 00:30:36.920
So, there are entries for both of these.

00:30:36.920 --> 00:30:41.150
As Charles mentioned, this is an array
and you would simply add both location

00:30:41.150 --> 00:30:44.620
and audio to your UI background modes array.

00:30:44.620 --> 00:30:49.860
And, the application life cycle
works just like Background Audio.

00:30:49.860 --> 00:30:54.050
When the user has the application in the
foreground, they're in the active state.

00:30:54.050 --> 00:30:58.020
And then, when the user presses the
Home button, the application transitions

00:30:58.020 --> 00:31:02.300
through the foreground inactive state
to the background running state,

00:31:02.300 --> 00:31:08.620
and as long as the application was tracking your location,
the application remains running in the background.

00:31:09.740 --> 00:31:15.450
So, to put this on the timeline view,
if the user is updating your location,

00:31:15.450 --> 00:31:18.660
and then the user presses the Home
button, the application will continue

00:31:18.660 --> 00:31:21.850
to run until, say you reached your destination.

00:31:21.850 --> 00:31:27.950
Now, when you reach your destination, the application
might stop location services, as we recommend.

00:31:27.950 --> 00:31:34.540
And then, at that point, because you're not updating the
location constantly, then the application will be suspended.

00:31:34.540 --> 00:31:38.540
So, the application transitions from
background running to background suspended.

00:31:38.540 --> 00:31:41.720
So, how does all of this work?

00:31:41.720 --> 00:31:47.610
Well, we have the CL Location Manager,
just like we did in iPhone OS 3.

00:31:47.610 --> 00:31:54.860
And, you may have a delegate object here that's going to
call this particular method on the CL Location Manager

00:31:54.860 --> 00:31:57.890
to say that we really want the
best accuracy here for navigation.

00:31:57.890 --> 00:32:03.040
This will be the finest grain controls
that we have for location updates.

00:32:03.040 --> 00:32:10.190
Then, the CL Location Manager will provide updates
after you make this call to start updating the location.

00:32:10.190 --> 00:32:12.690
So, this tells us; great, let's turn on the GPS.

00:32:12.690 --> 00:32:16.440
Give me quick location updates.

00:32:16.440 --> 00:32:22.090
And, the CL Location Manager will send you these updates
to say that you've moved from one particular location

00:32:22.090 --> 00:32:29.690
or to one particular location from another, and so, you'll
get many of these as your location changes over time.

00:32:29.690 --> 00:32:36.450
Now, for Background Audio support, so
if we want to speak these directions,

00:32:36.450 --> 00:32:38.710
we want to do three things in the background.

00:32:38.710 --> 00:32:43.560
The first thing is we need to, as before, set
the appropriate audio session category, so again,

00:32:43.560 --> 00:32:47.200
we're going to use the AV audio session category playback.

00:32:47.200 --> 00:32:54.010
But, this time we're going to set a couple of properties
on the audio session so that we get the intended behavior.

00:32:54.010 --> 00:33:00.710
So, in particular, we're going to set the AV audio
session property OverrideCategoryMixWithOthers.

00:33:00.710 --> 00:33:07.370
That will say that we should mix with other sounds, so
you'll want this in an application that speaks location,

00:33:07.370 --> 00:33:14.190
because you may have other sounds that are going on at the
system at the same time, and so you want to mix with others.

00:33:14.190 --> 00:33:21.240
Then, there's also the property to mix with
others, or that other mixable audio should duck.

00:33:21.240 --> 00:33:25.660
The economical example her is sort of, you're listening
to your iPod app because you're moving down the road.

00:33:25.660 --> 00:33:28.850
You know, it's heavy metal; you
probably don't hear directions over that.

00:33:28.850 --> 00:33:35.010
So, what you really want is for that other mixable
audio, i.e., the iPod app, to duck a little bit,

00:33:35.010 --> 00:33:37.030
so that you can hear your directions,
because that's what you want to hear.

00:33:37.030 --> 00:33:38.030
You don't want to miss your turn.

00:33:38.030 --> 00:33:44.600
So, I think this property is important for a navigation app
and it'll allow the user to hear want you want them to hear

00:33:44.600 --> 00:33:50.680
for that brief period of time, as the iPod
app quiets down so that the user can hear it.

00:33:50.680 --> 00:33:53.430
For Navigation, we have the similar best practices.

00:33:53.430 --> 00:33:55.110
You should minimize CPU usage.

00:33:55.110 --> 00:34:00.450
Hopefully, it shouldn't need a whole lot of CPU
as you're updating from location to location.

00:34:00.450 --> 00:34:04.760
And, as we said before, for power reasons it's
great if you can turn off location updates

00:34:04.760 --> 00:34:09.960
after you reach the destination, because
GPS is a fairly high power operation.

00:34:09.960 --> 00:34:14.330
So, once you're there, then turn off location updates
and then if the user wants to navigate to another place,

00:34:14.330 --> 00:34:18.500
they can return to your app and
choose another place to go to.

00:34:18.500 --> 00:34:21.140
And, that's really all there is to Navigation.

00:34:21.140 --> 00:34:25.030
But, there are some other important location
categories, and Charles will describe all of those.

00:34:25.030 --> 00:34:27.050
[ Applause ]

00:34:27.050 --> 00:34:32.300
>> Charles Srisuwananukorn: So now, I'd like to talk
about a couple of new location tracking services in iOS 4

00:34:32.300 --> 00:34:37.050
that allow your application to
track the device as it moves around.

00:34:37.050 --> 00:34:42.440
To motivate these services though, imagine we're
implementing a location aware, Capture the Flag app.

00:34:42.440 --> 00:34:46.920
And, the first thing you do in this application
is set two coordinates as the two flags,

00:34:46.920 --> 00:34:51.100
and then set a couple of regions around each flag.

00:34:51.100 --> 00:34:56.370
And, to capture the opponent's flag, you
enter the region around your opponent's flag

00:34:56.370 --> 00:34:59.390
and then return to the region around your own flag.

00:34:59.390 --> 00:35:01.790
So, that's how that works, basically.

00:35:01.790 --> 00:35:07.330
But in addition, it can also display a map of all
of the players that are currently playing the game,

00:35:07.330 --> 00:35:11.080
and approximately where they are in the city.

00:35:11.080 --> 00:35:17.780
To implement this, we'll use two new services in Core
Location; one called Significant Location Changes,

00:35:17.780 --> 00:35:19.790
and the other one called Region Monitoring.

00:35:19.790 --> 00:35:24.770
Significant Location Changes will notify your
application when the device has moved cell towers,

00:35:24.770 --> 00:35:29.760
and we use cell towers as a proxy for when
the device moves a significant distance.

00:35:29.760 --> 00:35:34.750
The Region Monitoring API, on the other hand, will
notify your application when the device enters

00:35:34.750 --> 00:35:40.760
or exits certain geographic regions of interest that
you've previously registered with Core Location.

00:35:40.760 --> 00:35:47.670
Both services use less power than the standard location
services, because they are based on cell positioning.

00:35:47.670 --> 00:35:51.500
Both services will resume applications
that have been suspended.

00:35:51.500 --> 00:35:56.930
Both will also relaunch applications that have
been terminated for, say low memory conditions.

00:35:56.930 --> 00:36:00.220
But, there are also a couple of
caveats that you should be aware of.

00:36:00.220 --> 00:36:06.450
If the device is sleeping, significant location change
notifications may actually be coalesced or delayed,

00:36:06.450 --> 00:36:11.480
in order to preserve battery life, but
region monitoring notifications won't be.

00:36:11.480 --> 00:36:17.470
And also, since both services are based on cell positioning,
they're only available on devices with cell radios.

00:36:17.470 --> 00:36:21.570
But, in particular, region monitoring
is only available on iPhone 4,

00:36:21.570 --> 00:36:25.540
whereas significant location changes is
available on both iPhone 4 and iPhone 3GS.

00:36:25.540 --> 00:36:31.600
So, let's talk some more about the
Significant Location Changes API.

00:36:31.600 --> 00:36:37.130
So, as I said earlier, the Significant Location
Changes API is meant to send you a notification

00:36:37.130 --> 00:36:39.210
when a device has moved a significant distance.

00:36:39.210 --> 00:36:45.880
And, it does this by calculating an approximate position
for the device whenever the device changes cell towers,

00:36:45.880 --> 00:36:49.290
and then sends your application that approximate position.

00:36:49.290 --> 00:36:53.570
The accuracy of that position, of course,
will be similar to the cell positioning.

00:36:53.570 --> 00:36:55.190
And, also again, you should be aware

00:36:55.190 --> 00:37:00.150
that these notifications may be coalesced while the
device sleeps to prevent that excessive battery drain.

00:37:00.150 --> 00:37:06.260
So, our Capture the Flag application can then
use the significant location changes service

00:37:06.260 --> 00:37:09.420
to implement the player map that we saw earlier.

00:37:09.420 --> 00:37:15.310
And so, whenever a player enters a game, the first
thing our Capture the Flag application does is start

00:37:15.310 --> 00:37:18.030
up the significant location changes service.

00:37:18.030 --> 00:37:23.590
Then, when the player moves cell towers, this Core Location
will notify your application with that approximate,

00:37:23.590 --> 00:37:28.500
current location, and our application can
then upload that location to a server.

00:37:28.500 --> 00:37:33.990
And then, if they move cell towers again, the same
thing happens, and every time they move the cell towers,

00:37:33.990 --> 00:37:37.810
we can upload a new location to the server.

00:37:37.810 --> 00:37:44.070
Now to set this up, our application first creates a
CL location manager and a location manager delegate

00:37:44.070 --> 00:37:49.600
and associates the two together, and then
calls startMonitoringSignificantLocationChanges

00:37:49.600 --> 00:37:51.930
on the location manager.

00:37:51.930 --> 00:37:56.150
Once we've done this, whenever the
device changes cell towers again,

00:37:56.150 --> 00:37:59.360
the location manager will call back the delegates;

00:37:59.360 --> 00:38:03.920
locationManager:didUpdateToLocation:fromLocation:
delegate method.

00:38:03.920 --> 00:38:07.630
Now, this is the same method that's called
when you used the standard location services,

00:38:07.630 --> 00:38:10.820
as we saw earlier in the Navigation example.

00:38:10.820 --> 00:38:16.930
But, the position that it passes you is the
approximate position based on cell positioning.

00:38:16.930 --> 00:38:19.990
When you receive this notification, you
might actually be in the background,

00:38:19.990 --> 00:38:24.780
so you don't have much time to
run and process the notification.

00:38:24.780 --> 00:38:28.290
But, you can also use the Task
Completion API to continue running

00:38:28.290 --> 00:38:31.960
in the background while you upload
that location to the server.

00:38:32.990 --> 00:38:35.440
Now, let's talk more about region monitoring.

00:38:35.440 --> 00:38:40.890
Region Monitoring will send a notification to your app,
again, when it enters or exits a region of interest.

00:38:40.890 --> 00:38:46.750
And, the big benefit of region monitoring is that your
application can be suspended while it's moving around,

00:38:46.750 --> 00:38:50.980
and it's not crossing any of these
boundaries between the regions of interest.

00:38:50.980 --> 00:38:57.790
Again, this service is also based on cell positioning, so
it also uses less power than the standard location services,

00:38:57.790 --> 00:39:00.120
but your application is also limited
by the number of regions

00:39:00.120 --> 00:39:04.780
that you can register, and it is only supported on iPhone 4.

00:39:04.780 --> 00:39:12.410
So, now assume that this red pin over here, it
represents one of the flags in our Capture the Flag game,

00:39:12.410 --> 00:39:18.180
and we've registered a region of interest around
the flag, represented by those red circles.

00:39:18.180 --> 00:39:24.430
Now, and then assume that the Capture the Flag application
suspended, because there was nothing else to do.

00:39:24.430 --> 00:39:29.370
Now when the device moves, core
location won't notify your application,

00:39:29.370 --> 00:39:32.070
because it hasn't actually crossed into this region yet.

00:39:32.070 --> 00:39:39.750
It's not until the device actually enters the region that it
then sends a notification saying we've entered the region,

00:39:39.750 --> 00:39:42.890
and your application has a chance
to process this notification.

00:39:42.890 --> 00:39:51.050
So, to use region monitoring, again we create a CL location
manager and a delegate and associate the two together,

00:39:51.050 --> 00:39:56.350
and then call startMonitoringForRegion, passing
it a description of a geographic region.

00:39:56.350 --> 00:40:02.850
Now, whenever the device enters or exits one of
these regions, the location manager will call back;

00:40:02.850 --> 00:40:07.850
the locationManager:didEnter or
didExitRegion:, depending on what happened,

00:40:07.850 --> 00:40:11.010
and then your application can process those appropriately.

00:40:11.010 --> 00:40:14.250
In the case of the Capture the Flag
application, we may want to notify the user,

00:40:14.250 --> 00:40:16.560
saying; hey, you've entered your own base.

00:40:16.560 --> 00:40:18.390
Congratulations, you've won!

00:40:18.390 --> 00:40:25.740
But, your application may be in the background again, and so
it won't be able to actually display its own UI to the user,

00:40:25.740 --> 00:40:32.380
and instead, it can also use the local
notifications service to display an alert to the user,

00:40:32.380 --> 00:40:36.620
very similar to a push notification
alert, that the user can then use

00:40:36.620 --> 00:40:39.250
to bring the Capture the Flag app back to the foreground.

00:40:39.250 --> 00:40:47.710
Now, let's review what states the application
goes through as each of these events are received.

00:40:47.710 --> 00:40:53.430
Now, assume that the application is suspended again;
the Capture the Flag application is suspended again.

00:40:53.430 --> 00:41:00.020
And then, we either enter one of these regions
or we get a Significant Location Changes event.

00:41:00.020 --> 00:41:06.970
So, there we are in the suspended state, and the system
will unsuspend our application to handle the event,

00:41:06.970 --> 00:41:10.910
which transitions us from the suspended
state into the background running state.

00:41:10.910 --> 00:41:17.330
And then, once the event is handled, we can then transition
back from background running into the suspended state

00:41:17.330 --> 00:41:21.870
and we can be suspended until another
interesting location event happens.

00:41:21.870 --> 00:41:27.360
But, as I said earlier, your application
may also be relaunched.

00:41:27.360 --> 00:41:32.190
So, assume that the Capture the Flag app
had been terminated, again due to low memory

00:41:32.190 --> 00:41:36.430
or for some other reason, so that
it's in the not running state.

00:41:36.430 --> 00:41:41.390
Then the system will relaunch your application when
one of these events happens, which transitions your app

00:41:41.390 --> 00:41:44.080
from the not running state into
the background running state.

00:41:44.080 --> 00:41:48.030
And then, it'll deliver the event to
your application so you can handle it.

00:41:48.030 --> 00:41:53.550
And then, once you're done handling the event,
the application will then become suspended again,

00:41:53.550 --> 00:41:56.350
so we transition from background running to suspended,

00:41:56.350 --> 00:42:02.190
and then it's suspended until,
again, one of these events happens.

00:42:02.190 --> 00:42:07.700
But, your application may not want to start
location services every time your app is launched,

00:42:07.700 --> 00:42:13.220
and so to help you detect when you've been launched
in the background for one of these location updates,

00:42:13.220 --> 00:42:19.700
the iPhone iOS 4 will pass the, or will set
the UIApplicationLaunchOptionsLocationKey,

00:42:19.700 --> 00:42:23.990
in the options dictionary, pass to your
application, didFinishLaunchingWithOptions.

00:42:23.990 --> 00:42:30.760
So, you can then check this key and if
it's set, create a CL location manager

00:42:30.760 --> 00:42:36.570
and start monitoring those significant location
changes again, or start up the location services.

00:42:36.570 --> 00:42:43.020
So, a few best practices you should be aware of would
be services; you should use significant location changes

00:42:43.020 --> 00:42:47.010
and region monitoring only if possible,
and only use the standard location services

00:42:47.010 --> 00:42:50.590
if you need the extra precision or the extra accuracy.

00:42:50.590 --> 00:42:56.470
You could even do a somewhat hybrid approach
and fire up the standard location services

00:42:56.470 --> 00:43:03.210
when you receive a significant location changed
event, so that you'll only use the high power GPS

00:43:03.210 --> 00:43:08.090
when the device has actually moved a significant distance.

00:43:08.090 --> 00:43:11.370
And, even though these services use less power

00:43:11.370 --> 00:43:14.460
than the standard location services,
they still use some amount of power.

00:43:14.460 --> 00:43:18.300
So, it's best to stop using those
services as soon as they're not needed,

00:43:18.300 --> 00:43:22.740
and you can do that by calling Stop Significant
Location Changes on the location manager,

00:43:22.740 --> 00:43:26.210
or Stop Monitoring Region when the
region's no longer interesting.

00:43:26.210 --> 00:43:32.490
Now, the last multitasking service or set
of multitasking services I'd like to talk

00:43:32.490 --> 00:43:38.160
about today are those geared toward
VoIP, or Voice over IP applications.

00:43:38.160 --> 00:43:43.440
A VoIP application is an application that makes and
receives phone calls using an Internet connection.

00:43:43.440 --> 00:43:48.700
It notifies users of incoming calls, whether
it's in the foreground or in the background.

00:43:48.700 --> 00:43:51.270
It can receive calls in the background.

00:43:51.270 --> 00:43:56.300
And, it can stay on a call as it enters the background.

00:43:56.300 --> 00:44:01.560
And, the first thing you do as a VoIP application
is set the appropriate background modes in Xcode,

00:44:01.560 --> 00:44:08.580
and for a VoIP application, you want the App provides Voice
over IP services, which enables you to call the VoIP API's,

00:44:08.580 --> 00:44:14.180
and the App Plays Audio background mode, which allows you
to play the call's audio while it's in the background.

00:44:14.180 --> 00:44:18.500
And, almost every VoIP application
will probably need both of these keys.

00:44:18.500 --> 00:44:25.530
[ Silence ]

00:44:25.530 --> 00:44:30.150
So, there are a few things that every
VoIP application will want to do.

00:44:30.150 --> 00:44:34.520
First is respond to incoming calls quickly.

00:44:34.520 --> 00:44:41.510
If your VoIP application receives an incoming call,
the incoming call notification should be delivered

00:44:41.510 --> 00:44:45.160
to your application as quickly as possible.

00:44:45.160 --> 00:44:51.230
In the same vein, it also should maintain a
persistent signaling connection to the VoIP server,

00:44:51.230 --> 00:44:54.160
so that it doesn't have to reconnect and re-authenticate

00:44:54.160 --> 00:44:57.330
that signaling connection when
it receives the incoming call.

00:44:57.330 --> 00:45:03.300
It should notify the user of the incoming call,
whether it's in the foreground or in the background.

00:45:03.300 --> 00:45:09.250
And, if the user accepts the incoming call, it should
implement the appropriate audio behaviors for a VoIP call.

00:45:09.250 --> 00:45:12.650
And finally, it should integrate well with cellular calls,

00:45:12.650 --> 00:45:16.910
which usually means simply putting the VoIP
call on hold while you're on a cellular call.

00:45:16.910 --> 00:45:22.470
So, let's look now at how the system helps
you first respond to those incoming calls,

00:45:22.470 --> 00:45:24.610
or receive those incoming call notifications quickly.

00:45:24.610 --> 00:45:32.540
So, if the device receives an incoming call
notification intended for your VoIP app,

00:45:32.540 --> 00:45:39.210
it's much better if your VoIP app is already running, so we
don't have to relaunch the application and incur that delay

00:45:39.210 --> 00:45:42.440
of relaunching the application
before delivering the notification.

00:45:42.440 --> 00:45:47.740
And so, what the system does is on device
boot, it will actually launch your application,

00:45:47.740 --> 00:45:54.900
and it will also relaunch your application if it's been
terminated for, again, low memory or for some other reason.

00:45:54.900 --> 00:45:59.050
But, after it's done launching,
it can actually be suspended again

00:45:59.050 --> 00:46:02.650
until something interesting happens
for your VoIP application.

00:46:02.650 --> 00:46:10.170
For example, if your application receives an incoming
call, then the system will unsuspend your application,

00:46:10.170 --> 00:46:13.990
and as long as the user or the
application is on that incoming call,

00:46:13.990 --> 00:46:17.490
your application runs until the call completes.

00:46:17.490 --> 00:46:22.970
Once the call completes though, it can then suspend
again until some other event happens; for example,

00:46:22.970 --> 00:46:26.520
a network keep-alive, and we'll talk more
about what network keep-alives are in a second.

00:46:26.520 --> 00:46:31.560
But, they are a way for your application to
maintain this persistent network connection.

00:46:31.560 --> 00:46:35.490
And so, then when one of these events
happens, it unsuspends your application again

00:46:35.490 --> 00:46:40.520
to send the keep-alive, and then re-suspends it.

00:46:40.520 --> 00:46:46.360
Now, let's take a look at how to maintain
that persistent signaling connection so that

00:46:46.360 --> 00:46:49.770
when the incoming call notification
comes in to your application,

00:46:49.770 --> 00:46:55.130
you don't have to reconnect the connection
and re-authenticate the connection.

00:46:56.230 --> 00:47:02.380
So, the first thing you do is you create a CF stream, and to
create the CF stream, you can use any of the CF stream API's

00:47:02.380 --> 00:47:07.300
that we have, and in this case, I'm going to use
the CF stream, Create Pair With Socket To Host,

00:47:07.300 --> 00:47:11.250
which will return a read stream
and a write stream to this host.

00:47:11.250 --> 00:47:16.840
Then, I call this prepare stream method, passing
it both the read stream and the write stream.

00:47:16.840 --> 00:47:21.870
The prepare stream method then does all of the things you
would normally do with a stream, like setting the delegate,

00:47:21.870 --> 00:47:25.400
scheduling in the run loop, and
calling open on those streams.

00:47:25.400 --> 00:47:29.360
But, most importantly for our VoIP
app, it sets the NS stream,

00:47:29.360 --> 00:47:34.200
Network Service Type VoIP Property,
for the NS stream network service type.

00:47:34.200 --> 00:47:39.330
And, this tells the system, or iOS 4, that it should wake up

00:47:39.330 --> 00:47:44.700
or unsuspend your application for
any incoming data on this CF stream.

00:47:44.700 --> 00:47:51.190
So, in that way, you can actually be unsuspended
whenever there's incoming data on the stream.

00:47:51.190 --> 00:47:55.470
A couple of other notes about this
CF stream, or VoIP CF stream.

00:47:55.470 --> 00:48:00.130
As I said earlier, you can use any of the
CF stream API's that create CF streams.

00:48:00.130 --> 00:48:08.330
In addition, you can use the ones that wrap POSIX or
VSD sockets, which is a common question on the forums.

00:48:08.330 --> 00:48:12.910
And, you should be aware that the CF
stream API only supports TCP streams,

00:48:12.910 --> 00:48:20.230
but this is OK because you only need the
VoIP property on your signaling channel.

00:48:20.230 --> 00:48:24.900
If the call's audio channel uses UDP, for example,

00:48:24.900 --> 00:48:30.630
just by playing audio your application remains
unsuspended and you can continue to play the audio.

00:48:30.630 --> 00:48:38.060
But, even though your application is now unsuspended
whenever there's incoming data on this channel,

00:48:38.060 --> 00:48:44.430
it can still be subject to certain timeouts,
like NAT timeouts anywhere along the route,

00:48:44.430 --> 00:48:50.780
or it might even be using some protocol that requires
the client to check in with the VoIP server periodically,

00:48:50.780 --> 00:48:54.350
and if it doesn't, then the server
will close down the connection.

00:48:54.350 --> 00:49:02.030
So, to help your application maintain these connections,
you can register a keep-alive handler with the system

00:49:02.030 --> 00:49:07.030
by calling setKeepAliveTimeout:handler:
on the UI application class.

00:49:07.030 --> 00:49:09.500
And, so that KeepAliveTimeout:handler takes

00:49:09.500 --> 00:49:14.990
as its first parameter a time interval,
and a block as its second parameter.

00:49:14.990 --> 00:49:24.720
It will then unsuspend your application on the interval that
you specify, and execute that block that you've passed in.

00:49:24.720 --> 00:49:29.720
And so, using this you can actually
send periodic keep-alive packets

00:49:29.720 --> 00:49:32.450
to prevent these NAT timeouts or protocol level timeouts.

00:49:32.450 --> 00:49:39.860
And, you should also note that the minimum
keep-alive timeout for this mechanism is ten minutes.

00:49:39.860 --> 00:49:46.070
So, now we've set up this persistent signaling
connection and we can receive incoming call notifications,

00:49:46.070 --> 00:49:51.100
and we don't have to reconnect to the VoIP
server when we get an incoming call notification.

00:49:51.100 --> 00:49:57.310
But, how do we tell the user that they have an incoming
call, because your VoIP application may again be

00:49:57.310 --> 00:50:01.240
in the background, and so it can't
present any of its own UI?

00:50:01.240 --> 00:50:07.090
Well, again we have the local notification
service, which your VoIP app can use

00:50:07.090 --> 00:50:11.480
to present a push notification-like
alert in front of the user,

00:50:11.480 --> 00:50:22.010
and you do this by calling presentLocalNotificationNow,
which will actually display the alert that you see there.

00:50:22.010 --> 00:50:27.500
Note that you can also dismiss local notifications if the
user receives multiple calls before looking at the device

00:50:27.500 --> 00:50:30.060
to prevent these alerts from stacking up.

00:50:30.060 --> 00:50:32.100
So, we've alerted the user that they have an incoming call.

00:50:32.100 --> 00:50:38.950
Imagine now that the user clicks
Accept, and we have to connect the call

00:50:38.950 --> 00:50:43.780
and start playing the call's audio
and take input for the call.

00:50:43.780 --> 00:50:48.370
To do so, we have to implement the appropriate audio
behaviors, and so the first thing we have to do

00:50:48.370 --> 00:50:53.620
to implement the appropriate audio behaviors is set
the right audio category on our AV audio session.

00:50:53.620 --> 00:51:00.670
And for VoIP apps, the right audio category is the
AV audio session category, Play and Record category.

00:51:00.670 --> 00:51:08.240
This category is similar to the Playback category that we
saw earlier, but it allows simultaneous access to both input

00:51:08.240 --> 00:51:15.100
and output, so you can take an input for the call at
the same time as playing the output from the other side.

00:51:15.100 --> 00:51:19.590
Like Playback, it silences other
audio, so if you were playing iPod

00:51:19.590 --> 00:51:23.200
when you started the call, it will actually silence iPod.

00:51:23.200 --> 00:51:28.370
And, it also enables output to both the
receiver or the earpiece, and the speaker,

00:51:28.370 --> 00:51:31.280
so you can implement a speakerphone
in your VoIP app, if you like.

00:51:31.280 --> 00:51:42.660
But, we would also like other audio to resume after a VoIP
call ends, because this is the way that phone calls behave.

00:51:42.660 --> 00:51:48.670
So, if the user was playing the iPod before receiving
the VoIP call, and then we connect the VoIP call,

00:51:48.670 --> 00:51:52.850
when we end the VoIP call, iPod should resume playing again.

00:51:52.850 --> 00:51:53.690
And, to do that,

00:51:53.690 --> 00:51:58.590
you set the
AVAaudioSessionSetActiveFlags_NotifyOthersOnDeactivation

00:51:58.590 --> 00:52:04.060
flag when you deactivate the session after the call ends.

00:52:04.060 --> 00:52:07.740
And, what this does is it just tells other
applications that were playing audio,

00:52:07.740 --> 00:52:11.350
that had their audio interrupted,
that they need to resume their audio.

00:52:11.350 --> 00:52:17.830
And, more specifically what it does is it sets that
AVAudioSessionInterruptionFlags_ShouldResume flag

00:52:17.830 --> 00:52:23.740
when it calls those other applications
and interruption with flags methods.

00:52:23.740 --> 00:52:29.710
So finally, VoIP applications should
integrate with cellular calls, and again,

00:52:29.710 --> 00:52:34.070
usually that means just putting the VoIP
call on hold while on a cellular call.

00:52:34.070 --> 00:52:38.720
And so, in iOS 4, we provide the CoreTelephony framework,

00:52:38.720 --> 00:52:46.240
and in the CoreTelephony framework we have an API
called setCallEventHandler: on the CTCallCenter object.

00:52:46.240 --> 00:52:53.900
And, setCallEventHandler: takes a block that is executed
whenever the user receives an incoming cellular call,

00:52:53.900 --> 00:52:55.370
or ends the current cellular call.

00:52:55.370 --> 00:53:03.720
And so, your application can then use this to put the VoIP
app's call on hold whenever the user is on a cellular call.

00:53:03.720 --> 00:53:07.510
So, a couple of best practices for VoIP apps.

00:53:07.510 --> 00:53:10.190
VoIP apps are also audio applications.

00:53:10.190 --> 00:53:14.700
So, everything that we've said about audio
applications also applies to VoIP apps.

00:53:14.700 --> 00:53:22.520
In particular, we try to ensure that VoIP apps have all of
the CPU and all of the network and file I/O that they need

00:53:22.520 --> 00:53:28.490
to play the call smoothly, which means you should try
to minimize your resource usage as much as possible

00:53:28.490 --> 00:53:32.650
by minimizing your CPU, and to
avoid using large amounts of memory.

00:53:32.650 --> 00:53:36.250
And, more specifically to VoIP
applications, you should try to use as long

00:53:36.250 --> 00:53:39.940
of a keep-alive interval as you
can to maximize battery life.

00:53:39.940 --> 00:53:42.980
And, we've found empirically that
29 minutes is a pretty good tradeoff

00:53:42.980 --> 00:53:46.820
between timing out our sockets and battery life.

00:53:46.820 --> 00:53:51.510
Multitasking, again, on iOS 4 doesn't mean that
applications run all of the time, but, you know,

00:53:51.510 --> 00:53:55.100
there are some applications that do
benefit from executing in the background,

00:53:55.100 --> 00:53:59.970
and for those applications we provide some
new services to run in the background.

00:53:59.970 --> 00:54:05.750
We have the task completion API, which allows your
application to request extra time to finish up a task

00:54:05.750 --> 00:54:08.560
on behalf of the user while in the background.

00:54:08.560 --> 00:54:14.700
The background audio API, to play audible content to the
user and respond to remote control events in the background.

00:54:14.700 --> 00:54:19.720
The navigation service, to implement
turn-by-turn navigation applications.

00:54:19.720 --> 00:54:24.380
A couple of location tracking services;
significant location changes and region monitoring,

00:54:24.380 --> 00:54:29.250
to monitor the device's location in
the background in an efficient manner.

00:54:29.250 --> 00:54:33.040
And finally, the VoIP services,
which allow your application to make

00:54:33.040 --> 00:54:36.460
and receive phone calls using an Internet connection.

00:54:36.460 --> 00:54:42.350
And again, if you missed part one earlier today,
we'll be repeating part one on Friday at 9:00AM.

00:54:42.350 --> 00:54:50.470
And, we've covered a lot of ground today, and so we've only
scratched the surface what each of these services can do.

00:54:50.470 --> 00:54:55.840
If you'd like to learn more about each of those
services, please come to the related sessions here.

00:54:55.840 --> 00:55:00.680
In particular, we didn't cover push notifications at all,
so if you'd like to learn more about push notifications,

00:55:00.680 --> 00:55:03.680
please come to the Implementing
Local and Push Notifications session.

