WEBVTT

00:00:06.740 --> 00:00:08.140
>> OK, hello everybody.

00:00:08.140 --> 00:00:13.920
I'm Deborah Goldsmith and today we're going to
be talking about making your application ready

00:00:13.920 --> 00:00:20.220
for the entire world, or at least a big part of it.

00:00:20.220 --> 00:00:23.190
So why should you care about that?

00:00:23.190 --> 00:00:30.430
Well recently over half of Apple's revenue has been
coming from customers outside of the United States.

00:00:30.430 --> 00:00:35.580
And most of those customers don't use
English as their primary language.

00:00:35.580 --> 00:00:43.160
Now some foreign languages like French and German
are pretty close to English in the way they behave.

00:00:43.160 --> 00:00:49.760
But many of our biggest markets use languages
that follow very different rules from English.

00:00:49.760 --> 00:00:57.650
So it might be counter-intuitive about what you need to do
to your application in order to support those languages.

00:00:57.650 --> 00:01:01.200
Fortunately you don't need to figure
out what those rules are yourself.

00:01:01.200 --> 00:01:10.130
You can make your application ready for those markets
by calling system APIs that do all the work for you.

00:01:10.130 --> 00:01:15.990
And somewhat unusually today or at least in
prior years we're not going to be spending a lot

00:01:15.990 --> 00:01:19.270
of time talking about API details or code samples.

00:01:19.270 --> 00:01:23.850
Mostly we're going to be talking about
concepts that will help you understand

00:01:23.850 --> 00:01:28.580
when you should call system APIs
and which ones you should call.

00:01:28.580 --> 00:01:37.120
So today we're mostly going to be talking
about Internationalization not Localization.

00:01:37.120 --> 00:01:39.000
What's the difference?

00:01:39.000 --> 00:01:44.900
Localization is the process of translating
your application's user interface.

00:01:44.900 --> 00:01:52.540
So for example the text in the menus, the text in the
buttons, the text in other controls, those kinds of things,

00:01:52.540 --> 00:01:57.410
it's the language that your application
uses to talk to the user.

00:01:57.410 --> 00:01:59.590
Internationalization is different.

00:01:59.590 --> 00:02:05.910
Internationalization is about making
data in all the world's languages work

00:02:05.910 --> 00:02:08.630
and there's many different kinds of that data.

00:02:08.630 --> 00:02:15.960
For example there's text content, which may come
from the user or it may come from an external source.

00:02:15.960 --> 00:02:24.780
Dates, times, numbers, currency amounts, calendars
can vary and we're also going to be talking

00:02:24.780 --> 00:02:30.200
about time zones a little bit, because
those behave differently around the world.

00:02:31.220 --> 00:02:40.880
So the goal for this talk is to help you
understand how to make your application world ready.

00:02:40.880 --> 00:02:48.040
And the goal is to have one version of your application, not
a French version and a Chinese version, a Russian version,

00:02:48.040 --> 00:02:56.310
one binary that can support content in any
language and also can run its user interface in any

00:02:56.310 --> 00:02:59.410
of the languages that the system supports.

00:02:59.410 --> 00:03:05.800
So today again we'll be focusing on the
Internationalization part not how to do Localization.

00:03:05.800 --> 00:03:17.060
So content-- content is data that the user provides
or it comes from an external source, maybe a website.

00:03:17.060 --> 00:03:24.610
Content can be in multiple languages and the language
doesn't have to match the language of the user interface.

00:03:24.610 --> 00:03:27.030
That is the Localization language.

00:03:27.030 --> 00:03:32.350
And not only can it be in multiple languages it
can be in multiple languages at the same time

00:03:32.350 --> 00:03:36.300
in the same document or even in the same paragraph.

00:03:36.300 --> 00:03:41.610
Now this is something-- we're not going to be focusing
on this today but that's something to keep in mind

00:03:41.610 --> 00:03:46.340
as you figure out how your application processes text.

00:03:48.400 --> 00:03:56.690
OK, language and the language preference controls
the Localization, that is it controls the language

00:03:56.690 --> 00:04:00.540
of the menus controls of the user interface.

00:04:00.540 --> 00:04:09.590
The way it works is the user picks a primary language
in either the Language and Text pref pane in Mac OS X

00:04:09.590 --> 00:04:15.770
or in the Language Preference on iOS
and that will pick one lang.lproj

00:04:15.770 --> 00:04:21.000
out of your application or out of another kind of bundle.

00:04:21.000 --> 00:04:24.140
In addition the primary language
controls a few other things.

00:04:24.140 --> 00:04:31.360
It also controls the algorithm that is used to sort
words for presenting an ordered list to the user

00:04:31.360 --> 00:04:34.330
and it also controls word breaking behavior.

00:04:34.330 --> 00:04:37.780
On the desktop you can actually set those separately.

00:04:37.780 --> 00:04:41.900
I don't know if you can see it
peeking out from behind the iPhone,

00:04:41.900 --> 00:04:45.360
there's a little pop up there,
which is the order for sorted lists.

00:04:45.360 --> 00:04:52.450
Mac OS X lets you set that independent from the UI language,
although by default it's the same as the UI language.

00:04:52.450 --> 00:04:58.960
If you change the UI language you must
restart applications for it to take effect.

00:04:58.960 --> 00:05:04.270
And in the case of iOS it actually
restarts the device so that all

00:05:04.270 --> 00:05:07.610
of the user interface is running in the same language.

00:05:11.070 --> 00:05:18.590
OK the thing that we're going to be spending the most time
on today is controlled by the Locale or Region preference.

00:05:18.590 --> 00:05:26.990
Again that's in the Language and Text pref pane on the
desktop and it's in International Preferences on iOS.

00:05:26.990 --> 00:05:37.490
And this controls things like dates, times,
numbers, calendars and so on are formatted.

00:05:37.490 --> 00:05:41.780
There is a language component to
the Locale or Region and you usually

00:05:41.780 --> 00:05:47.360
that language component is the same as
the UI language, but it isn't always.

00:05:47.360 --> 00:05:55.810
Now one big difference between the Locale or Region
and the UI language is that you can change the Locale

00:05:55.810 --> 00:05:58.590
without having to re-launch applications.

00:05:58.590 --> 00:06:03.580
So that's what users are going to
expect in terms of correct behavior.

00:06:04.620 --> 00:06:11.660
So here's our cast of characters
or cast of classes in any case.

00:06:11.660 --> 00:06:16.370
These 6 classes are what we're going to be
spending the most time talking about today.

00:06:16.370 --> 00:06:21.160
NSLocale is kind of the controller class for all of this.

00:06:21.160 --> 00:06:26.800
It embodies the current region and format
preferences from the user and it has a lot

00:06:26.800 --> 00:06:30.500
of different properties that you can set individually.

00:06:30.500 --> 00:06:38.070
NSNumberFormatter as you might expect is a class that
you use to format numbers and also to parse them.

00:06:38.070 --> 00:06:45.420
NSDateFormatter does the same thing for dates and times
and you may have heard of all of these classes already.

00:06:45.420 --> 00:06:54.060
A couple of less familiar classes are
NSCalendar, which handles calendar operations

00:06:54.060 --> 00:07:01.130
and NSTimeZone, which encapsulates logic for time zones.

00:07:01.130 --> 00:07:07.380
And I'm assuming that you've all heard of NSString and
we're not going to be going over all of NSString today

00:07:07.380 --> 00:07:12.090
but just the parts that pertain
to natural language processing.

00:07:12.090 --> 00:07:17.660
So let's start with NSLocale.

00:07:17.660 --> 00:07:23.200
NSLocale again is set by the Region
Format preference in the pref pane

00:07:23.200 --> 00:07:28.080
and all Locales have an identifier associated with them.

00:07:28.080 --> 00:07:35.620
That identifier is a string, which kind of sums up
the part of the world that the Locale has to do with.

00:07:35.620 --> 00:07:44.150
So one example is the US English Locale and
the identifier for that is just en_US.

00:07:44.150 --> 00:07:47.740
Below that I have a more complex
example, which we'll go through in detail,

00:07:47.740 --> 00:07:53.610
which shows most of the parts of a Locale identifier.

00:07:53.610 --> 00:08:00.840
So every Locale identifier has a language
and in this case the language is Serbian

00:08:02.720 --> 00:08:07.810
as represented by the small sr there at the front.

00:08:07.810 --> 00:08:15.870
That part of the Locale identifier uses ISO language codes.

00:08:15.870 --> 00:08:24.110
Almost always there's also a region in this case
sort of counter-intuitively the RS stands for Serbia.

00:08:24.110 --> 00:08:31.920
As I said almost all Locales have
a region but sometimes they don't.

00:08:31.920 --> 00:08:34.860
For example there's an Esperanto Locale.

00:08:34.860 --> 00:08:36.810
Esperanto is an artificial language.

00:08:36.810 --> 00:08:46.350
It doesn't really correspond to any country and so
there is no country or region for the Esperanto Locale.

00:08:46.350 --> 00:08:50.200
Also a region doesn't necessarily have to be a country.

00:08:50.200 --> 00:08:56.570
There are letter-based codes, alphabetic codes
for countries but there are also numeric codes

00:08:56.570 --> 00:08:59.590
for regions that represent parts of the world.

00:08:59.590 --> 00:09:02.680
So for example, there is a region for all of Latin America.

00:09:02.680 --> 00:09:05.720
There is a region for all of Europe.

00:09:05.720 --> 00:09:12.020
Mostly we don't use those but it is
possible to have that in that position.

00:09:12.020 --> 00:09:17.040
Now something that you'll sometimes see
in a Locale identifier is the script

00:09:17.040 --> 00:09:21.400
and the script is there usually for one of two reasons.

00:09:21.400 --> 00:09:27.080
First and most importantly is if
you need it for disambiguation.

00:09:27.080 --> 00:09:36.900
So for example, Serbian is written about with equal
frequency in the Cyrillic script and the Latin script.

00:09:36.900 --> 00:09:44.930
So you always need to specify which script you're using
when you're specifying a Serbian Locale, so it's required.

00:09:44.930 --> 00:09:47.860
Sometimes you want it for overrides.

00:09:47.860 --> 00:09:52.360
For example, there are two kinds of Chinese
writing that we support in the system.

00:09:52.360 --> 00:09:56.540
There is the simplified Chinese set
and the traditional Chinese set.

00:09:56.540 --> 00:10:01.000
And usually you can infer which
one to use based on the region.

00:10:01.000 --> 00:10:08.460
So, for example, the Chinese in Hong Kong
region implies traditional Chinese.

00:10:08.460 --> 00:10:15.500
However, if you wanted to set your Region preference to
be Hong Kong using Chinese, but you wanted to force it

00:10:15.500 --> 00:10:21.720
to use the simplified version in that
case you'd specify the script explicitly.

00:10:21.720 --> 00:10:27.600
Sometimes there's a variant, very occasionally
and I'll give an example of that later on.

00:10:27.600 --> 00:10:30.080
I don't want to focus on it too much.

00:10:30.080 --> 00:10:37.140
Finally Locale identifiers can also have keywords
and in this case there's a keyword for the currency,

00:10:37.140 --> 00:10:42.070
which overrides the currency that
comes from the Locale data.

00:10:42.070 --> 00:10:45.210
So for example, in this case we're specifying that we want

00:10:45.210 --> 00:10:50.380
to use the Euro regardless of what
the default is for Serbia.

00:10:50.380 --> 00:10:56.820
You can also override the calendar using a keyword.

00:10:56.820 --> 00:10:59.280
So where do you get a Locale object from?

00:10:59.280 --> 00:11:06.570
Well you can create a Locale from the identifier string if
you want a specific Locale but the usual way to get one is

00:11:06.570 --> 00:11:15.450
to call CurrentLocale and that will give you a Locale object
that corresponds to the user's current Preference Settings.

00:11:15.450 --> 00:11:23.680
Now that object won't change after creation and remember
users expect that if they change the Preference Setting

00:11:23.680 --> 00:11:27.700
that the behavior of your application
will change almost immediately.

00:11:27.700 --> 00:11:33.400
So in order to react to that there's
a notification you can respond to,

00:11:33.400 --> 00:11:40.110
which is and its CurrentLocaleDidChangeNotification,
say that 10 times fast.

00:11:40.110 --> 00:11:47.130
And so your application can look for that and when you
receive it you can go through and update all your objects.

00:11:47.130 --> 00:11:54.330
There is a convenience function, which is the
autoupdatingCurrentLocale class method on NSLocale

00:11:54.330 --> 00:11:59.470
and that will give you an NSLocale that
responds to that notification itself

00:11:59.470 --> 00:12:03.670
so it will update itself when the
user changes their preference.

00:12:03.670 --> 00:12:11.380
In addition, if you set that Locale on a number formatter or
a date formatter or on any other kind of foundation object

00:12:11.380 --> 00:12:18.540
that takes a Locale, those objects will in turn
update automatically when the notification comes in.

00:12:18.540 --> 00:12:25.340
Now something you have to watch out for if you
are looking for the notification yourself is

00:12:25.340 --> 00:12:31.090
that the NSLocale is looking for the same notification
so you can get into a little bit of a race condition

00:12:31.090 --> 00:12:33.780
and I'll give you an example where that could occur.

00:12:33.780 --> 00:12:41.350
Let's say you have a window and that window shows
today's date at the top and you want that date to change

00:12:41.350 --> 00:12:49.270
when the user changes their Preference
so that it uses the proper Region format.

00:12:49.270 --> 00:12:56.210
So you might set up that date with an NSDate
formatter that's sent to the autoupdatingCurrentLocale

00:12:56.210 --> 00:13:01.690
and then you look for the LocaleDidChangeNotification
to repaint the window.

00:13:01.690 --> 00:13:06.670
Well the problem is that you and the locale
are both looking for the same notification

00:13:06.670 --> 00:13:12.310
and if you get it first you'll repaint the
window before the Locale has had a chance

00:13:12.310 --> 00:13:15.500
to update and you'll still get the old formatting.

00:13:15.500 --> 00:13:23.280
So, if you're using the autoupdatingCurrentLocale
and you're also looking for the notification,

00:13:23.280 --> 00:13:27.200
it's important to keep in mind that it's
non-deterministic who gets it first.

00:13:27.200 --> 00:13:37.950
So let's move on to talk about numbers
and some of the differences you might see

00:13:37.950 --> 00:13:41.140
in the way they're formatted between Locales.

00:13:41.140 --> 00:13:45.240
So, one important difference is the decimal point character

00:13:45.240 --> 00:13:50.410
and the grouping separator character,
but also the size of the groups.

00:13:50.410 --> 00:14:00.760
In the United States and in many other countries
groups are 3 digits in length so it's every 1,000

00:14:00.760 --> 00:14:07.980
but in some Locales groups are 4 digits in length
and in still other Locales different groups

00:14:07.980 --> 00:14:10.820
in the same number can have 4 digits or 3 digits.

00:14:10.820 --> 00:14:15.690
So the first group might have 4 digits
but subsequent groups might have 3 digits.

00:14:15.690 --> 00:14:24.030
In this case we have a U.S. English formatted number on the
left and we have a French formatted number on the right.

00:14:24.030 --> 00:14:27.720
The French number uses a non-breaking
space for the 1,000 separator,

00:14:27.720 --> 00:14:33.040
the grouping separator and a comma for the decimal point.

00:14:33.040 --> 00:14:40.540
Not every Locale uses the ASCII digits for
representing numbers, most do, but not all of them.

00:14:40.540 --> 00:14:46.070
In this case on the right we've got a number formatted
according to the Arabic Locale and you can see

00:14:46.070 --> 00:14:52.490
that it uses a completely different set of
digits in order to represent the number.

00:14:52.490 --> 00:14:59.100
Currency can also vary, not just the
symbol but also where it appears.

00:14:59.100 --> 00:15:05.400
So for example, again we've got a French formatted
currency amount on the right and the Euro appears,

00:15:05.400 --> 00:15:10.330
the currency appears after the
number and separated by a space.

00:15:10.330 --> 00:15:16.020
Another thing to keep in mind is that the currency
symbol can change even if the currency is the same.

00:15:16.020 --> 00:15:22.660
So for example, in the United States when we represent
an amount in dollars, we just use the dollar sign.

00:15:22.660 --> 00:15:29.260
But if you're representing that same amount in dollars
in say Australia then it would say U.S. dollars

00:15:29.260 --> 00:15:37.440
because in Australia a single dollar character
means the Australian dollar not the U.S. dollar.

00:15:37.440 --> 00:15:40.830
Percentages can also vary in the way they're formatted.

00:15:40.830 --> 00:15:47.110
Not just the digits used but as you can see
Arabic uses a different percent character

00:15:47.110 --> 00:15:51.880
than the Roman alphabet and also the different digits.

00:15:51.880 --> 00:15:59.950
Also the positioning of the percentage sign either
after or before the number can vary and finally even

00:15:59.950 --> 00:16:06.330
for floating point concepts like not a number
or infinity some Locales localize that data.

00:16:06.330 --> 00:16:14.800
So, for example, we use NAN for not a number in the U.S.
English Locale but Icelandic uses a different string,

00:16:14.800 --> 00:16:22.720
which I don't even know how to
pronounce but that's it on the right.

00:16:22.720 --> 00:16:30.190
So if your needs are simple for number formatting it's
very straightforward NSNumberFormatter has a class method

00:16:30.190 --> 00:16:35.950
and this is new in OS 10.6 and in iOS 4.

00:16:35.950 --> 00:16:43.770
All you have to do is pass in the NSNumber for your Number
and which Number style you want and you get a string back.

00:16:43.770 --> 00:16:46.080
No muss, no fuss.

00:16:46.080 --> 00:16:50.960
And there are 4 basic Number Formatting
paradigms that are supported.

00:16:50.960 --> 00:16:54.760
Paradigm is probably too big a word for this, styles.

00:16:54.760 --> 00:17:02.080
OK, general just formats things
in a general floating point number.

00:17:02.080 --> 00:17:08.560
There's the currency style, which uses the currency
symbol, there's percentage and you'll notice

00:17:08.560 --> 00:17:16.730
that for percentage the number is multiplied by 100 and
the reason is that you would use the percentage format

00:17:16.730 --> 00:17:24.020
to represent a number between 0 and 1 and that would
be formatted as a percentage between 0 and 100.

00:17:24.020 --> 00:17:26.000
And finally there's a scientific style

00:17:26.000 --> 00:17:32.440
if you want a scientific notation, and
again this can vary between Locales.

00:17:33.710 --> 00:17:40.580
There are some more advanced things that you might want
to do with numbers and for those advanced uses you want

00:17:40.580 --> 00:17:45.210
to create an NSNumberFormatter object and keep it.

00:17:45.210 --> 00:17:50.370
So one example is if you're formatting a lot
of numbers or creating one NSNumberFormatter

00:17:50.370 --> 00:17:56.170
and then calling it repeatedly is more
efficient than calling the class method.

00:17:56.170 --> 00:17:58.880
There's no class method for parsing numbers.

00:17:58.880 --> 00:18:04.740
So if you want to parse a string into a number
you need to create an NSNumberFormatter.

00:18:04.740 --> 00:18:11.560
And if you need to tweak the format for example,
controlling the number of significant digits,

00:18:11.560 --> 00:18:19.100
whether the fraction is shown, whether the decimal point
is always shown, how the sign is represented, etc., etc., etc.,

00:18:19.100 --> 00:18:25.320
there are accessor functions on
NSNumberFormatter that set that up

00:18:25.320 --> 00:18:32.130
and if you need to do that you need to create an object.

00:18:32.130 --> 00:18:37.890
Well what are some of the things that can
go wrong if you don't call system APIs?

00:18:37.890 --> 00:18:42.470
And we'll have several slides like
this and all of these are lifted

00:18:42.470 --> 00:18:47.230
from real examples that happened in real applications.

00:18:47.230 --> 00:18:54.650
So, one problem is using stringWithFormat or
printf or scanf for formatting or parsing numbers.

00:18:54.650 --> 00:19:03.100
The problem is that %e and %f will not handle non-ASCII
digits like the Arabic example that we saw earlier.

00:19:03.100 --> 00:19:09.640
So you cannot use these APIs to
format numbers in a localized way.

00:19:09.640 --> 00:19:16.930
People sometimes assume that the decimal point or the
grouping separator or the size of groups are the same

00:19:16.930 --> 00:19:23.570
as whatever country they are living in whereas
it varies considerably around the world.

00:19:23.570 --> 00:19:28.840
The same thing for percents; people
assume that a percent is always formatted

00:19:28.840 --> 00:19:33.730
as the ASCII digits 0 through 9 followed by an ASCII % sign.

00:19:33.730 --> 00:19:41.590
Sometimes people will create an NSNumberFormatter
and then set the pattern string and that's fine

00:19:41.590 --> 00:19:49.260
in some circumstances, but it will erase the
Locale specific formatting that you get for free

00:19:49.260 --> 00:19:55.140
and so all of a sudden your number
formatting is not localized any more.

00:19:55.140 --> 00:20:05.820
And finally, a problem that people can run into is let's say
you've got a document and its showing $2.00 and the U.S.,

00:20:05.820 --> 00:20:12.590
sorry the user goes and changes their Currency
preference to another currency, say the Euro.

00:20:12.590 --> 00:20:17.860
Well now you've got two Euros except
of course $2.00 is not two Euros.

00:20:17.860 --> 00:20:24.170
So if its user supplied data then that's
generally not something you need to worry about.

00:20:24.170 --> 00:20:30.450
But if you are writing an application where you could
be converting amounts between currencies it's important

00:20:30.450 --> 00:20:33.630
to realize that the system does not do that for you.

00:20:33.630 --> 00:20:41.360
All that's changing is the way the number is represented
and any currency conversions you have to handle yourself.

00:20:44.210 --> 00:20:53.410
OK, moving right along, let's talk about dates
and times and what differs between Locales.

00:20:53.410 --> 00:21:00.470
I mentioned that a Locale has a language associated
with it and that is the language that controls the names

00:21:00.470 --> 00:21:09.290
of the months, the days of the week, the AM/PM strings and
also relative terms like today, yesterday, or tomorrow.

00:21:09.290 --> 00:21:17.040
Now if I'm running my system in English but I set
my Region Preference to be a French Locale I'm going

00:21:17.040 --> 00:21:21.460
to get French month names because that
is what's associated with the Locale.

00:21:21.460 --> 00:21:28.190
So there's an example of today's date in the French Locale.

00:21:28.190 --> 00:21:32.530
Another thing that can differ between
Locales is the Calendar in use.

00:21:32.530 --> 00:21:37.900
So here again is today's date, except in
this case we're using the Japanese Locale

00:21:37.900 --> 00:21:47.530
and we have the Japanese Calendar set and it's
the date is the 22nd year of the Heisei era, June 10th.

00:21:47.530 --> 00:21:54.740
Another thing that can be different between
Locales is which day is the first day of the week.

00:21:54.740 --> 00:22:01.660
In the U.S. when you're representing days in a calendar
Sunday is on the left and Saturday is on the right.

00:22:01.660 --> 00:22:09.690
But in other places Monday is on the left
and Sunday is on the right so that can vary.

00:22:09.690 --> 00:22:14.650
Some places use 12-hour time like
the U.S. and other places like Japan

00:22:14.650 --> 00:22:19.200
or in Europe use 24-hour time and that also varies.

00:22:19.200 --> 00:22:24.050
Even if the language is the same the order
of the date elements can be different.

00:22:24.050 --> 00:22:40.410
So, for example, in the U.S. we say June 10, 2010,
but in the UK they write it like this 10 June 2010.

00:22:40.410 --> 00:22:45.960
So again there are some predefined styles
for date and time formatting and also parsing

00:22:45.960 --> 00:22:50.780
and those have the names Short, Medium, Long and Full.

00:22:50.780 --> 00:23:00.480
And as you can see as you go from Short to Full you get more
and more information represented in the resulting string.

00:23:00.480 --> 00:23:03.630
Now there are two ways you can use this.

00:23:03.630 --> 00:23:07.510
One is to just pick a style and stick with it.

00:23:07.510 --> 00:23:11.000
So say I'm always going to use the long date.

00:23:11.000 --> 00:23:18.400
But another thing you can do is start at a particular
length and then maybe make it smaller, for example,

00:23:18.400 --> 00:23:22.840
if the date is in the column and the user
shrinks the column, and we do this in the finder.

00:23:22.840 --> 00:23:30.550
We start with the longer forms of the date and time
and then as the user shrinks the column that represents

00:23:30.550 --> 00:23:42.210
that data we fall back from the Long to the Medium
and the Medium to the Short to take up less room.

00:23:42.210 --> 00:23:50.100
Starting in Mac OS X 10.6 and in iOS 4 we have
some new features, both of which are very useful

00:23:50.100 --> 00:23:53.580
and I'd like to spend a little
bit of time talking about them.

00:23:53.580 --> 00:24:02.250
So you've probably noticed that in different places
in the OS, for example the Finder or in Mail on the phone,

00:24:02.250 --> 00:24:08.010
you'll see relative terms like today or yesterday
and it hasn't been very easy to do that in the past

00:24:08.010 --> 00:24:15.610
but now we've got a property on NSDateFormatter with
a RelativeDateFormatting property and you can set that

00:24:15.610 --> 00:24:22.630
and your dates will do the same thing and there's
an example there, except it wasn't yesterday,

00:24:22.630 --> 00:24:25.650
it should have been June 9th, but never mind.

00:24:25.650 --> 00:24:31.780
Another new facility, which is very
useful is the Date Template Facility.

00:24:31.780 --> 00:24:34.330
Now what would you use that for?

00:24:34.330 --> 00:24:40.820
That is what you would use if the predefined date
formats or time formats doesn't meet your needs.

00:24:40.820 --> 00:24:49.370
If you need a different subset of the date elements and
what you do is you pass in a template string and a Locale

00:24:49.370 --> 00:24:56.180
and some options and this class method will return
a format string, which you can then turn around

00:24:56.180 --> 00:25:02.590
and set on your NSDateFormatter and that will
format things according to what you requested.

00:25:02.590 --> 00:25:12.330
So, for example, let's say I'm writing a Calendar application
and I want to put an hour view down or say a day view

00:25:12.330 --> 00:25:19.220
where I have hours down the left hand side, well, I
guess the left hand side would be over here for you guys,

00:25:19.220 --> 00:25:24.270
but I just want the hour, but I don't
know if it's 12- or 24-hour time.

00:25:24.270 --> 00:25:33.320
And before this API you had to do a lot of fussing around
with the date format string to try to figure out how

00:25:33.320 --> 00:25:36.720
to set up this piece of a date or time format.

00:25:36.720 --> 00:25:42.300
In this case though, you can just pass the
template string j, which is a meta-character

00:25:42.300 --> 00:25:47.930
that just says give me the hour
whether it's 12 or 24 and depending

00:25:47.930 --> 00:25:50.720
on the Locale you'll get back a different format string.

00:25:50.720 --> 00:26:00.220
So for English you may 12-hour hour followed by an
AM/PM indicator or you'd get the 24-hour hour character

00:26:00.220 --> 00:26:05.000
and you get the two different results you see on the right.

00:26:05.000 --> 00:26:13.400
Maybe my Calendar application has a month view and the month
view has the month and the year at the top, but I don't know

00:26:13.400 --> 00:26:16.140
if the months or the year are supposed to come first.

00:26:16.140 --> 00:26:21.540
If the user is using the Japanese
calendar, do I put the era in?

00:26:21.540 --> 00:26:23.650
This API takes care of that for you.

00:26:23.650 --> 00:26:29.440
So in this case you pass a template where I
say I want the shortest possible representation

00:26:29.440 --> 00:26:33.120
of the year but I want the full name of the month.

00:26:33.120 --> 00:26:42.100
And the strings you get back are for the U.S. Locale
you get the name of the month, a space and a year.

00:26:42.100 --> 00:26:47.690
But in the Japanese Locale using the Japanese
calendar I get the era, I get the year,

00:26:47.690 --> 00:26:56.550
I get the month and everything works out fine.

00:26:56.550 --> 00:27:02.850
So what are some of the kinds of errors that
we've seen people run into with dates and times?

00:27:02.850 --> 00:27:07.290
Well something that seems to happen a
lot is that people us NSDateFormatter

00:27:07.290 --> 00:27:11.330
for parsing or formatting non-localized dates.

00:27:11.330 --> 00:27:17.270
For example dates that you get off the Internet
or dates that appear in some internal data format

00:27:17.270 --> 00:27:26.960
and if you use NSDateFormatter that way without
understanding that it's localized you can get bad results.

00:27:26.960 --> 00:27:30.790
Typically dates like that aren't localized.

00:27:30.790 --> 00:27:38.000
Now to get an NSDateFormatter that you can use to parse or
format dates and times like that instead of getting one set

00:27:38.000 --> 00:27:47.100
to the current Locale, which is the default, just create a
new Locale, set it to this identifier and this is an example

00:27:47.100 --> 00:27:52.150
of the variant that we talked about earlier
when we were talking about Locale identifiers.

00:27:52.150 --> 00:28:00.420
So in this case this is the POSIX variant of the
U.S. English Locale and this is the Locale identifier

00:28:00.420 --> 00:28:04.240
that corresponds to the standard C Locale.

00:28:04.240 --> 00:28:12.090
This will always give you stuff back that uses English
names of months and is formatted in a standard way.

00:28:12.090 --> 00:28:18.920
So if you set your NSDateFormatter using
that Locale you'll get non-localized dates.

00:28:18.920 --> 00:28:27.240
Another option is to just call the BSD layer where there
are APIs for parsing and formatting dates and times

00:28:27.240 --> 00:28:35.570
and if you do use those, just pass NULL for the
Locale because that indicates again the C Locale

00:28:35.570 --> 00:28:42.520
and that make perfect sense because the primary purpose
of NSDateFormatter is to handle localized dates and times.

00:28:42.520 --> 00:28:50.230
If you're dealing with a non-localized date or time you can
set it up to do that but you don't really need to use it.

00:28:50.230 --> 00:28:55.390
Another thing that people sometimes
did is parse format strings.

00:28:55.390 --> 00:29:02.060
So, for example, if I were writing a Calendar application
and I wanted to put the months and the year at the top

00:29:02.060 --> 00:29:10.100
of the view, there was no way to get NSDateFormatter
to do that prior to these recent releases.

00:29:10.100 --> 00:29:15.430
So what people would do is they would set the full
date format, then they would extract the format string

00:29:15.430 --> 00:29:19.550
from the NSDateFormatter and then they
would go picking through it to try to figure

00:29:19.550 --> 00:29:24.490
out which pieces to use and that's very error prone.

00:29:24.490 --> 00:29:31.220
But now that there's a dateFormatFromTemplate
you don't need to do that anymore.

00:29:31.220 --> 00:29:37.580
Another thing that people do is use NSCalendarDate
at all, it's deprecated and you shouldn't use it.

00:29:37.580 --> 00:29:41.550
You can use NSDate to represent a date and time.

00:29:41.550 --> 00:29:48.910
In fact, that's its primary purpose but people have
used the description method on NSDate to format dates

00:29:48.910 --> 00:29:53.930
and it will not format a date in a proper localized fashion.

00:29:53.930 --> 00:30:00.550
So you should use NSDateFormatter whenever you're
parsing or formatting dates that are localized.

00:30:00.550 --> 00:30:06.930
And then another mistake that people have made is
assuming that the calendar is always Gregorian.

00:30:06.930 --> 00:30:10.740
OK there we go.

00:30:10.740 --> 00:30:17.390
So Calendars, let's talk about some of the things that
can differ from different Calendars and different Locales.

00:30:17.390 --> 00:30:18.770
Well one is the year.

00:30:18.770 --> 00:30:22.400
This is the year 2010 in the Gregorian calendar.

00:30:22.400 --> 00:30:27.330
However, in the Thai Buddhist calendar this is the year 2553

00:30:27.330 --> 00:30:33.890
and in various other calendars
the years are all over the place.

00:30:33.890 --> 00:30:36.210
Every Calendar has an implicit era.

00:30:36.210 --> 00:30:44.900
So for example in the Gregorian calendar we're in the
AD era, but usually we don't bother representing that.

00:30:44.900 --> 00:30:50.350
However, for some calendars like the Japanese
calendar the era changes rather more frequently

00:30:50.350 --> 00:30:53.160
and it's important to take that into account.

00:30:53.160 --> 00:30:57.600
So, for example, this is the 22nd year of the Heisei era.

00:30:57.600 --> 00:31:02.210
Another thing that can vary between
calendars is the number of months in a year.

00:31:02.210 --> 00:31:09.660
So for example, the Gregorian calendar always has 12
months but some calendars have 12 months or 13 months

00:31:09.660 --> 00:31:13.890
or even the number of months can vary from year to year.

00:31:13.890 --> 00:31:15.930
The lengths of months can also vary.

00:31:15.930 --> 00:31:22.790
You can remember of the names of the months of
the Gregorian calendar using the nursery rhyme

00:31:22.790 --> 00:31:29.590
but other calendars have a different set of
months and those months have different lengths

00:31:29.590 --> 00:31:31.950
than the lengths of the Gregorian calendar.

00:31:31.950 --> 00:31:39.200
Even the lengths of the months in the Gregorian calendar
can vary depending on whether it's a leap year or not.

00:31:39.200 --> 00:31:44.760
And some calendars, for example the Coptic
calendar, have months as short as 5 days.

00:31:44.760 --> 00:31:53.510
Another thing that you really wouldn't
expect is that the year can change other

00:31:53.510 --> 00:31:56.490
than at the first day of the first month of the year.

00:31:56.490 --> 00:32:00.820
So for example, in the Japanese
calendar the year changes when the reign

00:32:00.820 --> 00:32:05.140
of a new emperor begins, which
doesn't have to be January 1st.

00:32:05.140 --> 00:32:12.550
So for example, the day after January 7th of the 64th year

00:32:12.550 --> 00:32:18.860
of the Showa era is January 8th of
the first year of the Heisei era.

00:32:21.670 --> 00:32:26.110
Well fortunately an NSCalendar
takes care of all of this for you.

00:32:26.110 --> 00:32:32.600
It abstracts all the operations that you might want to
do on calendars or dates, determining how many days are

00:32:32.600 --> 00:32:39.000
in a particular month, how many months are in
a year, converting between calendar components

00:32:39.000 --> 00:32:46.880
and an absolute date/time, doing operations like what's the
date 3 days after this one, all sorts of things like that.

00:32:46.880 --> 00:32:54.950
Mac OS X 10.6 has support for a
large set of non-Gregorian calendars.

00:32:54.950 --> 00:33:05.410
iOS 4 supports what we call Gregorian-like non-Gregorian
calendars and those are Gregorian calendars where the set

00:33:05.410 --> 00:33:09.150
of months is the same but the year and era may be different.

00:33:09.150 --> 00:33:15.700
And at some point in the future we plan to expand
support of non-Gregorian calendars on iOS also.

00:33:15.700 --> 00:33:24.760
So what are some of the things that can go
wrong when you're doing Calendar operations

00:33:24.760 --> 00:33:26.690
and you don't let the system handle it for you?

00:33:26.690 --> 00:33:31.750
And again, these are all lifted from
real situations that we've seen.

00:33:31.750 --> 00:33:38.490
One is assuming Gregorian calendar, assuming
that there are always 12 months in a year.

00:33:38.490 --> 00:33:42.350
This is an interesting one, assuming
that month numbers are sequential.

00:33:42.350 --> 00:33:49.570
Remember that I mentioned that some calendars have
years with 12 months and years with 13 months?

00:33:49.570 --> 00:33:52.510
An example of that is an Arabic calendar.

00:33:52.510 --> 00:33:57.680
Well in the year that has 12 months
or rather the year that has 13 months

00:33:57.680 --> 00:34:00.610
that extra month is not at the end, it's in the middle.

00:34:00.610 --> 00:34:06.550
So in a year with 12 months that month is not there.

00:34:06.550 --> 00:34:11.880
So you skip over it when you're numbering
months in a year without that month.

00:34:11.880 --> 00:34:16.020
The same thing can happen with days,
even in the Gregorian calendar.

00:34:16.020 --> 00:34:24.110
For example, October 15, 82 in the Gregorian
calendar only has 21 days and you go straight

00:34:24.110 --> 00:34:28.860
from October 4th to October 21st I think.

00:34:28.860 --> 00:34:36.810
You can't assume that the error is
optional because just, for example,

00:34:36.810 --> 00:34:40.840
in the Japanese calendar seeing the
year 22 doesn't tell you anything

00:34:40.840 --> 00:34:45.380
if you don't know whether it's
Heisei or Showa or what have you.

00:34:45.380 --> 00:34:51.740
Some Apps assume that weeks always start on a Sunday.

00:34:51.740 --> 00:34:59.460
People have been tripped up by the fact that the year can
change other than on the first day of the first month.

00:34:59.460 --> 00:35:04.620
And something that's really tricky is recurrences.

00:35:04.620 --> 00:35:11.900
So again let's assume you're writing a Calendar application
and you want to allow the user to set up a meeting

00:35:11.900 --> 00:35:17.310
that happens once a month or somebody's
birthday, which is once a year

00:35:17.310 --> 00:35:23.100
or, for example, the last Tuesday of
the month or the second Thursday.

00:35:23.100 --> 00:35:28.960
Well what those terms mean changes
when you change the calendar.

00:35:28.960 --> 00:35:37.300
So, for example, if I have somebody's birthday
and it's a particular day of a particular month

00:35:37.300 --> 00:35:44.490
in a particular calendar that recurrence
relationship is different if I switch calendars.

00:35:44.490 --> 00:35:49.770
The day that is the second Tuesday of the month is not--

00:35:49.770 --> 00:35:55.320
the second Tuesday of the third month is not
the same in the Gregorian and Arabic calendars.

00:35:55.320 --> 00:35:57.100
They are different days.

00:35:57.100 --> 00:36:04.260
So if you're defining a recurrence relationship like
this in your calendar or a similar kind of application,

00:36:04.260 --> 00:36:09.400
it's important to keep track of the
calendar that was used to define it.

00:36:09.400 --> 00:36:14.460
So if the user set their birthday in the
Arabic calendar you should keep track

00:36:14.460 --> 00:36:18.190
of that fact that it was set in the Arabic calendar.

00:36:21.290 --> 00:36:25.090
OK let's spend a little time talking about Time Zones.

00:36:25.090 --> 00:36:27.260
Those can also be a little counter-intuitive.

00:36:27.260 --> 00:36:36.350
Every time someone has an offset from what's called
Greenwich Mean Time or universal coordinated time,

00:36:36.350 --> 00:36:41.500
although those are not precisely the same thing,
they're close enough for what we're talking about.

00:36:41.500 --> 00:36:47.320
There are also rules about whether daylight
time is observed and when it's observed.

00:36:47.320 --> 00:36:50.380
Every time zone has a unique identifier.

00:36:50.380 --> 00:36:56.660
Time Zone information in Mac OS X and iOS
come from something called the Olson database

00:36:56.660 --> 00:37:01.080
and that's used by a wide variety of computer systems.

00:37:01.080 --> 00:37:06.870
Every time zone in the Olson database
is uniquely identified by an ID.

00:37:06.870 --> 00:37:09.290
But time zones also have localized names.

00:37:09.290 --> 00:37:13.270
I will spend a little bit more time talking about that.

00:37:13.270 --> 00:37:21.950
And as Time Zone represents the abstraction of the Time Zone
and it will tell you the answers to all of those questions.

00:37:21.950 --> 00:37:33.220
So what are some of the errors that we've seen people
make in working with Time Zones in applications?

00:37:33.220 --> 00:37:40.440
One is assuming they know what the GMT offset is
or what the rules are for daylight savings time.

00:37:40.440 --> 00:37:47.750
So, for example, the U.S. as a country change the dates
where we observe daylight savings time a few years back.

00:37:47.750 --> 00:37:53.000
So those can be different based on
what time period you're observing.

00:37:53.000 --> 00:38:01.340
So if you're formatting a date that is back in say 2001 then
it's going to be different from formatting a date that's

00:38:01.340 --> 00:38:05.850
in 2010 in terms of when daylight savings time kicks in.

00:38:05.850 --> 00:38:11.980
In addition, historically whether you're
observing daylight savings time or when it happens

00:38:11.980 --> 00:38:15.790
or even what your DMT offset is can vary.

00:38:15.790 --> 00:38:21.330
So for example, for a long time Indiana
did not observe daylight savings time

00:38:21.330 --> 00:38:27.490
and then when the U.S. changed the rules a few years
back they decided that they would start observing it

00:38:27.490 --> 00:38:34.540
but at the same time different counties in Indiana
decided that they would switch their time zones.

00:38:34.540 --> 00:38:40.980
So for some counties that were previously Central
became Eastern and some that were Eastern became Central

00:38:40.980 --> 00:38:44.540
and so NSTimeZone takes care of that for you.

00:38:44.540 --> 00:38:50.450
It tracks it as long as a user sets a Time
Zone preference correctly it will keep track

00:38:50.450 --> 00:38:52.490
of all those historical changes.

00:38:52.490 --> 00:38:58.160
Another thing that people do is use
the Olson ID which is really more

00:38:58.160 --> 00:39:01.450
like a programming identifier to show to the end user.

00:39:01.450 --> 00:39:07.120
So, for example, the time zone that we're
in right now is called America/Los_Angeles.

00:39:07.120 --> 00:39:14.170
That's not really something that you
want to show to a user and NSTimeZone

00:39:14.170 --> 00:39:21.400
and NSDateFormatter will let you get a
localized name that will make more sense.

00:39:21.400 --> 00:39:26.370
If you do call NSTimeZone make sure that you're
getting the right version of the Time Zone name,

00:39:26.370 --> 00:39:31.110
the generic name versus the daylight
name versus the standard name.

00:39:31.110 --> 00:39:38.030
Another assumption that people sometimes make is
that the short IDs for time zones things like PST

00:39:38.030 --> 00:39:41.060
for Pacific Standard Time are unique, they are not.

00:39:41.060 --> 00:39:44.510
For example, PST is also used in Australia.

00:39:44.510 --> 00:39:53.980
So you can't look at something like PST and
assume you know what the full Time Zone is.

00:39:53.980 --> 00:40:00.560
OK, lastly we're going to spend some time talking
about Natural Language Processing with NSString.

00:40:00.560 --> 00:40:05.040
So there are two operations that
we're going to talk about today.

00:40:05.040 --> 00:40:10.990
One is Breaking a string into pieces
and the other is Sorting.

00:40:10.990 --> 00:40:21.590
So new in 10.6 and iOS 4 there is an API NSString
called enumerateSubstringsInRange:options:usingBlock:.

00:40:21.590 --> 00:40:27.670
And you can use that to perform lexical
operations on a string of Natural Language text.

00:40:27.670 --> 00:40:33.600
You can find word boundaries, line break
opportunities, sentence boundaries and so on.

00:40:33.600 --> 00:40:44.250
And this is one of the APIs that's controlled
by the UI language not by the Locale.

00:40:44.250 --> 00:40:49.820
Another thing that's controlled by
the UI language is the sort order.

00:40:49.820 --> 00:40:50.220
Excuse me.

00:40:50.220 --> 00:40:52.620
I'm just going to take a sip of water.

00:40:57.290 --> 00:41:03.160
[Sound effects] And that's important because
different languages can have very different sort orders

00:41:03.160 --> 00:41:07.750
and the way certain features are
handled varies between those languages.

00:41:07.750 --> 00:41:12.730
So, for example, the way diacritics are handled
when sorting English is completely different

00:41:12.730 --> 00:41:15.470
from the way it's handled when sorting French.

00:41:15.470 --> 00:41:24.780
And the API that you can use to do any kind of comparison
for sorting purposes is localizedStandardCompare.

00:41:24.780 --> 00:41:34.460
So here I have two examples of a sorted list just
to show you how different a sort order can be.

00:41:34.460 --> 00:41:36.710
On the left we have Hawaiian.

00:41:36.710 --> 00:41:45.300
Now that list may not look alphabetized to you, but it is
and the reason for that is that native Hawaiian uses a set

00:41:45.300 --> 00:41:52.780
of letters which is a subset of the 26 letters that
are used for English and words with those letters,

00:41:52.780 --> 00:41:58.520
that is native Hawaiian words, always
sort before words that use other letters.

00:41:58.520 --> 00:42:07.320
So in this case letters like B and C are not used in
native Hawaiian and therefore they sort at the end.

00:42:07.320 --> 00:42:14.500
Similarly for French the thing that's
different is the way that accents are handled.

00:42:14.500 --> 00:42:24.570
So if you look at the last three items in the
French list, in French the accent at the end

00:42:24.570 --> 00:42:28.750
of the word is more significant
than the accent at the beginning.

00:42:28.750 --> 00:42:35.320
And so you can see that those last three words are
sorted according to first to the accent at the end

00:42:35.320 --> 00:42:41.680
and then according to the accent at
the second position and it generalizes.

00:42:41.680 --> 00:42:47.810
You go through the accents in French
backwards in order to determine the sort order.

00:42:47.810 --> 00:42:54.080
So localizedStandardCompare will take care of
all of this for you as long as you call it.

00:42:56.190 --> 00:43:05.710
So what are the kinds of errors that we've seen people
make in applications by not calling the right APIs?

00:43:05.710 --> 00:43:12.620
One is that people often assume that words and lines are
always separated by whitespace, space, character, tab,

00:43:12.620 --> 00:43:24.320
return, etc. That's not true for many languages including
some in large markets like Japanese, Chinese and Thai.

00:43:24.320 --> 00:43:29.920
A very common mistake is to use NSString's
Compare method for sorting a list

00:43:29.920 --> 00:43:32.390
that is going to be shown to the end user.

00:43:32.390 --> 00:43:35.950
The problem is that Compare is not localized.

00:43:35.950 --> 00:43:40.040
It will not take any of those language
issues we just discussed into account.

00:43:40.040 --> 00:43:42.910
It just uses a fixed binary order.

00:43:42.910 --> 00:43:50.550
So Compare is great if you're doing something like building
a B tree index where you need a fixed comparison order

00:43:50.550 --> 00:43:54.600
and you don't want it to change when
the user changes their preference.

00:43:54.600 --> 00:44:01.350
But if you're sorting a list to show to users
then you need to use a localized comparison.

00:44:01.350 --> 00:44:07.190
There is an extended version of Compare that can do
localized compares if you need it for advanced use.

00:44:07.190 --> 00:44:14.780
So, for example, in that API is
compare:options:range:locale and you'll get a localized sort

00:44:14.780 --> 00:44:18.260
as long as you pass something for the Locale.

00:44:18.260 --> 00:44:26.100
An example of where you might want to use this, for
example, localizeStandardCompare turns on the option

00:44:26.100 --> 00:44:32.330
that we call numeric sorting and what that does is if
you have numbers that appear as part of the strings

00:44:32.330 --> 00:44:37.670
that you're sorting, it will compare
those as the actual numeric value.

00:44:37.670 --> 00:44:47.080
And that's what the finder uses so that for example,
if you File 1 through File 9, File 10 through 19,

00:44:47.080 --> 00:44:51.570
the finder will sort those in numeric order.

00:44:51.570 --> 00:44:58.090
If you don't want that, you can call the advanced
form of Compare and turn off that option.

00:44:58.090 --> 00:45:04.190
That's the kind of case where you might
want to call this more advanced API.

00:45:04.190 --> 00:45:10.900
Another error that we see people make
quite commonly is doing comparisons

00:45:10.900 --> 00:45:15.350
for sorting with diacritic-and case-insensitivity.

00:45:15.350 --> 00:45:22.140
Now those options are intended for searching
like a find dialogue, not for sorting a list.

00:45:22.140 --> 00:45:30.550
If you turn on diacritic-insensitivity that French
example that we saw will not be sorted properly.

00:45:30.550 --> 00:45:39.020
Similarly if you turn on case-insensitivity you will
not get the right order because some languages --

00:45:39.020 --> 00:45:43.440
the order in which upper and lower case versions
are shown differs based on the language.

00:45:43.440 --> 00:45:48.660
Some languages put the uppercase version first
and others put the lowercase version first.

00:45:48.660 --> 00:45:56.200
Again, if you turn on case-insensitivity when
you're sorting, the order in between upper

00:45:56.200 --> 00:45:58.690
and lower case will be essentially random.

00:45:58.690 --> 00:46:01.980
It's whatever falls out of your sort algorithm.

00:46:01.980 --> 00:46:08.090
So whenever you're doing a sort always make
sure that you are diacritic- and case-sensitive.

00:46:08.090 --> 00:46:14.110
OK we'll we're pretty much done.

00:46:14.110 --> 00:46:23.030
Two sessions that are related to this topic are Advanced
Text Handling for iPhone OS, which was Tuesday at 4:30

00:46:23.030 --> 00:46:27.520
and Understanding Foundation, which was
the session immediately before this one.

00:46:27.520 --> 00:46:32.380
So all of you get in your time machine and
get back and go and watch those sessions.

00:46:32.380 --> 00:46:38.660
But if you don't have a time machine and you didn't attend
the sessions already then you can find all the information

00:46:38.660 --> 00:46:43.310
about these sessions on the WWDC website.

00:46:43.310 --> 00:46:46.890
And for more information you can go
to the http://devforums.apple.com.

00:46:46.890 --> 00:46:48.730
I'm sure you all have this URL already.

