1
00:00:06,320 --> 00:00:06,880
>> Blaine Garst: Let's see.

2
00:00:06,880 --> 00:00:09,080
Oh yeah, that's my name, Blaine Garst.

3
00:00:09,080 --> 00:00:09,820
I'm Blaine Garst.

4
00:00:09,820 --> 00:00:15,430
On my business card it says "Wizard of Runtimes," and so on
the slides there's this little slot where you're supposed

5
00:00:15,430 --> 00:00:19,520
to put your title, and so I just
kind of copy/pasted it there.

6
00:00:19,520 --> 00:00:22,540
So, what does Wizard of Runtimes mean?

7
00:00:22,540 --> 00:00:23,690
Well, I don't know.

8
00:00:23,690 --> 00:00:28,920
I work on the runtimes for the
Objective-C language, primarily.

9
00:00:28,920 --> 00:00:32,270
And so, the runtimes is where all the coding happens.

10
00:00:32,270 --> 00:00:37,550
And since I'm a programmer just like you
guys, that's where I get to do my programming.

11
00:00:37,550 --> 00:00:40,930
So, my programming helps you guys do your programming.

12
00:00:40,930 --> 00:00:49,660
So, what's going to happen today is we're going to talk
about Objective-C, and about how you folks can learn more

13
00:00:49,660 --> 00:00:54,290
about the language and some of
the things behind the language,

14
00:00:54,290 --> 00:00:58,080
some of the things about the frameworks
underneath it or above it,

15
00:00:58,080 --> 00:01:01,730
Cocoa Touch, and learning how to use it effectively.

16
00:01:01,730 --> 00:01:11,740
So, the first thing we need to fix with the slide
is we're going to talk about iOS, not iPhone OS.

17
00:01:11,740 --> 00:01:24,320
In particular, the iOS platform applies
to the iPad, the iPhone, the iPod touch.

18
00:01:24,320 --> 00:01:30,630
You know, this is the description for
what this session is supposed to cover.

19
00:01:30,630 --> 00:01:40,670
And first of all, if we could raise the lights a
little bit, I'd like to get a feel for among you folks,

20
00:01:40,670 --> 00:01:46,140
how many of you have yet to ship your first app?

21
00:01:46,140 --> 00:01:53,180
Wow, OK. How many here have shipped maybe only 2 apps?

22
00:01:53,180 --> 00:01:59,690
And I assume the rest of you might actually be a little
more familiar with Objective-C than some of these folks.

23
00:01:59,690 --> 00:02:01,590
Thanks, that's enough for the lights.

24
00:02:01,590 --> 00:02:03,720
So, let me tell you what's going to happen.

25
00:02:03,720 --> 00:02:08,720
We're going to take a tour, a little bit of a tour
through Objective-C and some of the most effective ways

26
00:02:08,720 --> 00:02:15,360
to use Objective-C on Cocoa Touch, and I'm your tour guide.

27
00:02:15,360 --> 00:02:20,040
So, as your tour guide, let me
introduce myself a little bit more.

28
00:02:20,040 --> 00:02:22,610
I've been programming since 1973.

29
00:02:22,610 --> 00:02:24,180
I joined NeXT.

30
00:02:24,180 --> 00:02:24,270
[ Applause ]

31
00:02:24,270 --> 00:02:32,790
I joined NeXT Computer in 1990, and I had
a little bit of experience at that point

32
00:02:32,790 --> 00:02:36,570
and I started doing things with my practice and experience.

33
00:02:36,570 --> 00:02:44,340
I got to take some patterns of programming that
I really enjoy and I put them into the language,

34
00:02:44,340 --> 00:02:50,140
so that my techniques of programming
became standard practice.

35
00:02:50,140 --> 00:02:54,720
In particular, I helped to add
protocols to the Objective-C language.

36
00:02:54,720 --> 00:02:59,470
[ Applause ]

37
00:02:59,470 --> 00:03:05,560
>> This solved-- when adopted by Java, and
they were pretty much copy/pasted into Java.

38
00:03:05,560 --> 00:03:08,850
I have some quotes from Gosling on that.

39
00:03:08,850 --> 00:03:15,060
That solved the client-server problem for like servers and
stuff 'cause I could have this abstract design and stuff.

40
00:03:15,060 --> 00:03:17,760
And so, I've been doing things like this ever since.

41
00:03:17,760 --> 00:03:21,640
And so today, you're getting a tour by the tour guide.

42
00:03:21,640 --> 00:03:26,810
You know, I might look like a horse because what I speak
about in Objective-C is straight from the horse's mouth.

43
00:03:26,810 --> 00:03:29,620
It doesn't get any better than this.

44
00:03:29,620 --> 00:03:32,630
So, let's get started.

45
00:03:32,630 --> 00:03:36,570
The iPad, the iPhone, these are awesome things to program.

46
00:03:36,570 --> 00:03:37,730
There is so much fun.

47
00:03:37,730 --> 00:03:42,270
It's so exciting to have all of this
code out there that you can really play

48
00:03:42,270 --> 00:03:44,080
with them, make things happen on these devices.

49
00:03:44,080 --> 00:03:46,180
These devices are just awesome.

50
00:03:46,180 --> 00:03:51,810
To make things happen on these
devices, you need to learn Objective-C.

51
00:03:51,810 --> 00:03:57,730
It is the core, the center of how we make things happen,

52
00:03:57,730 --> 00:04:00,930
how you make GUI in particular
happen, graphical user interfaces.

53
00:04:00,930 --> 00:04:05,760
How you make Cocoa Touch do what you want to do.

54
00:04:05,760 --> 00:04:12,530
There are other languages out there and my presumption
is that you know at least one of these other languages

55
00:04:12,530 --> 00:04:15,700
because I'm not going to teach you Objective-C necessarily.

56
00:04:15,700 --> 00:04:23,360
I'm going to teach you differences between what you
know and what we do here-- what we do with Objective-C.

57
00:04:23,360 --> 00:04:26,160
In particular, when you think about
different languages, the first thing you think

58
00:04:26,160 --> 00:04:29,640
about is, well, you get syntax differences.

59
00:04:29,640 --> 00:04:34,980
They've got different kinds of control flow operator, you
know, operators and control flow primitives and things.

60
00:04:34,980 --> 00:04:38,430
In particular, some languages have exceptions.

61
00:04:38,430 --> 00:04:44,170
Some languages have these things called
closures, which for Objective-C, we call blocks.

62
00:04:44,170 --> 00:04:50,150
And if you know these patterns, what you
really need to know is how do I do this pattern

63
00:04:50,150 --> 00:04:53,340
in this new language or this different language?

64
00:04:53,340 --> 00:04:59,290
But beyond just the syntax, there's a lot of
other stuff that has to go on when you do--

65
00:04:59,290 --> 00:05:02,190
when you really need to make things happen.

66
00:05:02,190 --> 00:05:04,500
You've got-- you know, how do you do math?

67
00:05:04,500 --> 00:05:07,300
Do you have infinite precision numbers?

68
00:05:07,300 --> 00:05:11,290
Nah, we usually have integers and
floats, right, in some languages though.

69
00:05:11,290 --> 00:05:13,840
But, you know, we have strings at different levels.

70
00:05:13,840 --> 00:05:16,630
We have C strings, we've got these NSStrings.

71
00:05:16,630 --> 00:05:20,210
There are structures versus objects for aggregating data.

72
00:05:20,210 --> 00:05:26,100
If you have objects, you have different
inheritance models, you know, the list goes on.

73
00:05:26,100 --> 00:05:32,420
By the end of the list, when you talk about platform
things, Memory Management is very much tied to the platform

74
00:05:32,420 --> 00:05:35,710
and languages are often tied to a platform.

75
00:05:35,710 --> 00:05:38,870
And so, you have to learn more about the platform.

76
00:05:38,870 --> 00:05:45,350
It's sort of beyond the language and you definitely
need to learn about Memory Management on the iPhone.

77
00:05:45,350 --> 00:05:51,030
I hear this is a little bit perplexing to some folks,
and we're going to talk about that in particular.

78
00:05:51,030 --> 00:06:01,520
So, to summarize what I just said, I'm going to try to
map and go what you know in terms of familiar concepts

79
00:06:01,520 --> 00:06:06,030
with just a little bit of terminology difference
and clear a little bit of syntax difference.

80
00:06:06,030 --> 00:06:12,430
We're going to introduce and talk about Objective-C sort
of uncommon ideas, things that have not quite made it

81
00:06:12,430 --> 00:06:16,300
to the mainstream, yet unless you
consider Objective-C mainstream.

82
00:06:16,300 --> 00:06:21,780
It is, I think, the number 10 most popular
language now, at least by some definition.

83
00:06:21,780 --> 00:06:25,390
So these are the things we're going
to talk about to help you learn how

84
00:06:25,390 --> 00:06:30,210
to use our kits, UIKit, et cetera, to advantage.

85
00:06:30,210 --> 00:06:36,250
In particular, I want to talk a little
bit about what I consider be a pattern.

86
00:06:36,250 --> 00:06:39,300
Now, there are books out there, design patterns and stuff.

87
00:06:39,300 --> 00:06:46,520
And don't get worried, I'm not a boost kind of guy, but
we will talk about patterns that make sense in terms

88
00:06:46,520 --> 00:06:48,960
of how we design things and how you have to use those.

89
00:06:48,960 --> 00:06:52,450
So, that's what we're going to try to cover today.

90
00:06:52,450 --> 00:06:58,540
Again, Objective-C is at the core of
how you program the iPad, the iTouch--

91
00:06:58,540 --> 00:07:02,090
or the iPad, the iPhone, and the iPod touch.

92
00:07:02,090 --> 00:07:10,510
There are two other languages though, that you
interoperate with all the time, and those are C and C++.

93
00:07:10,510 --> 00:07:14,880
Now, the first topic I want to talk
about is this thing called blocks.

94
00:07:14,880 --> 00:07:18,450
Blocks has been added to the C language.

95
00:07:18,450 --> 00:07:24,210
And through this thing called language inheritance,
you get to use blocks also from Objective-C,

96
00:07:24,210 --> 00:07:29,970
which is a pure superset of C and C++ as
well because that's what our compilers do.

97
00:07:29,970 --> 00:07:37,310
And what blocks allow you to do is program
from any language you want and stick blocks

98
00:07:37,310 --> 00:07:41,330
that use your programming language
anywhere that a block is asked for.

99
00:07:41,330 --> 00:07:46,160
So, it's sort of a glue facility
of cross-languages to some extent.

100
00:07:46,160 --> 00:07:49,120
So, let's talk about blocks.

101
00:07:49,120 --> 00:07:59,200
I understand that this thing about multitasking is important
to you guys, and so the background task identifier,

102
00:07:59,200 --> 00:08:06,900
if you want to learn how to totally do background
tasking on the iPhone, you might have to learn this API.

103
00:08:06,900 --> 00:08:12,400
It's got this block thing at the end, this
void caret handler thing at the very end.

104
00:08:12,400 --> 00:08:26,850
And so, actually it got talked about earlier in the
week, so let's pick a different thing to talk about.

105
00:08:26,850 --> 00:08:28,670
There's quite a lot to choose from here.

106
00:08:28,670 --> 00:08:35,320
In fact, there's over a hundred
APIs in iPhone OS 4 that use blocks,

107
00:08:35,320 --> 00:08:38,420
so I'm not going to pretend to
go through any of them, honestly.

108
00:08:38,420 --> 00:08:45,960
But this is kind of just a motivation as to, you know,
why you might want to listen through this section.

109
00:08:45,960 --> 00:08:51,270
So, this is what blocks look like for the C language.

110
00:08:51,270 --> 00:09:00,170
We introduce this caret expression kind of syntax to mean
sort of a local function, a local function expression.

111
00:09:00,170 --> 00:09:04,470
You can write a function expression
where you would write other expressions

112
00:09:04,470 --> 00:09:06,310
and you pass them as parameters for the most part.

113
00:09:06,310 --> 00:09:12,180
In this case, what we're doing is we're going to send to
some function called repeat, this little block pattern

114
00:09:12,180 --> 00:09:17,690
that says do a putc on d, presumably 10 times.

115
00:09:17,690 --> 00:09:25,570
And the idea here is that d is going to go along with that.

116
00:09:25,570 --> 00:09:32,430
You know, d is a local variable and you're going to get to
use that within your block as it goes off and does things.

117
00:09:32,430 --> 00:09:36,080
Now, blocks are actually not a very new concept.

118
00:09:36,080 --> 00:09:39,350
That's what they look like in C.

119
00:09:39,350 --> 00:09:42,200
They are called blocks in Ruby and in Smalltalk.

120
00:09:42,200 --> 00:09:54,520
And in fact they were sort of invented in LISP--
in the scheme, actually, somewhere around 1973.

121
00:09:54,520 --> 00:10:01,830
They were called closures in Scheme and
there's a-- there's a lot of interest in this.

122
00:10:01,830 --> 00:10:08,350
In fact, there's a new standard coming
out for C++ and it's called C++0x.

123
00:10:08,350 --> 00:10:10,940
It's in final committee draft or something like that.

124
00:10:10,940 --> 00:10:13,120
And they have a construct called the lambda.

125
00:10:13,120 --> 00:10:23,530
Now a lambda only fits into templates, for example, and
that's the syntax you would use for the closure expression,

126
00:10:23,530 --> 00:10:27,650
but you can't actually use them-- you
can't pass them directly to functions.

127
00:10:27,650 --> 00:10:32,070
They're only useful within templates and they're different.

128
00:10:32,070 --> 00:10:35,180
They're not full closures, they're a little different.

129
00:10:35,180 --> 00:10:43,090
But the idea is coming along and we're happy and proud
to provide to you blocks, you know, on the phone,

130
00:10:43,090 --> 00:10:47,770
as we've had them on Mac OS for a year or so.

131
00:10:47,770 --> 00:10:55,500
So, here's another use of that repeat function, this time
using some Objective-C code where we're just going to,

132
00:10:55,500 --> 00:11:00,160
you know, append some strings to a mutableString.

133
00:11:00,160 --> 00:11:06,240
And the next box tells you how to
implement that repeat function.

134
00:11:06,240 --> 00:11:11,030
And so the syntax we use for blocks
is that of function pointers.

135
00:11:11,030 --> 00:11:19,550
Think function pointers with the caret symbol instead of
the star and you'll understand the syntax of block pointers.

136
00:11:19,550 --> 00:11:25,890
So, they're really block pointers just like we have function
pointers, except to use that caret thing for the syntax.

137
00:11:25,890 --> 00:11:31,420
And to use them, you just call them as if they
were function pointers as I've shown here.

138
00:11:31,420 --> 00:11:36,290
So, they're pretty easy to use, pretty
easy to implement and work around.

139
00:11:36,290 --> 00:11:38,260
And so that's why we use them all over the place.

140
00:11:38,260 --> 00:11:41,570
They're useful, they're fun.

141
00:11:41,570 --> 00:11:46,180
To summarize the syntax, we got a typical spot,

142
00:11:46,180 --> 00:11:50,410
sort of the function pointer return
value slot or the return value specified.

143
00:11:50,410 --> 00:11:55,630
You get some parameters some of the time and you got a body.

144
00:11:55,630 --> 00:12:02,800
In this case, we're returning-- I
don't know, it's a contrived example.

145
00:12:02,800 --> 00:12:10,640
Another-- a thing we did though to make life
easier, is we allow you to use abbreviated syntax.

146
00:12:10,640 --> 00:12:15,920
And so when the compiler sees a return statement,
it knows there has to be a return value.

147
00:12:15,920 --> 00:12:23,830
And so, if there's no return statement in that body, then
it can assume that it's a void, returning a void thing.

148
00:12:23,830 --> 00:12:30,390
But in any case, even if you do return something,
you don't have to specify that return value type.

149
00:12:30,390 --> 00:12:33,700
So, the second line is exactly equivalent to the first line.

150
00:12:33,700 --> 00:12:38,500
So, you don't have to say int, we infer this.

151
00:12:38,500 --> 00:12:40,890
So the same is true, as I just said.

152
00:12:40,890 --> 00:12:45,930
If you don't do a return at all, we assume
void, so you don't have to type void.

153
00:12:45,930 --> 00:12:50,990
And in the special case where you
return void and have no parameters,

154
00:12:50,990 --> 00:12:53,910
you don't have to put the parameter list in either.

155
00:12:53,910 --> 00:12:58,160
And so that's why you kind of see
different syntaxes for these block literals.

156
00:12:58,160 --> 00:13:05,640
And what this do is when a compiler encounters them, it
creates a structure on the stack, which is the block object,

157
00:13:05,640 --> 00:13:09,620
and leaves you a pointer to this structure on the stack.

158
00:13:09,620 --> 00:13:17,320
So, this is both fast and dangerous and so
we have to be a little careful about these.

159
00:13:17,320 --> 00:13:20,360
And we'll talk about that a little bit later.

160
00:13:20,360 --> 00:13:23,240
So, blocks are also objects.

161
00:13:23,240 --> 00:13:26,640
Even though stack-based things, you can send them messages.

162
00:13:26,640 --> 00:13:32,330
Now, there's only a couple of messages that are of
interest, and those are for primarily copy and release.

163
00:13:32,330 --> 00:13:41,210
Because copy says make a perma-- make a-- copy it to the
heap so that it can survive the stack frame of origin.

164
00:13:41,210 --> 00:13:48,110
So what that allows us to do, allows you to do is
write a block expression, pass it off to some API.

165
00:13:48,110 --> 00:13:58,360
And if the API wants to keep a hold of it, pass
that use, it can do a copy on it and preserve it.

166
00:13:58,360 --> 00:14:02,660
And that copy costs a little extra cycles.

167
00:14:02,660 --> 00:14:05,980
They have to alloc-- we have to allocate
memory off the heap and copy it in there.

168
00:14:05,980 --> 00:14:08,440
But sometimes you need to do that and sometimes you don't.

169
00:14:08,440 --> 00:14:12,580
And so for the times you don't, we don't
allocate heap storage for these things.

170
00:14:12,580 --> 00:14:17,690
So, they're very efficient and, yeah, we like that.

171
00:14:17,690 --> 00:14:19,840
We use them in many, many places.

172
00:14:19,840 --> 00:14:22,690
We use them to enumerate collections.

173
00:14:22,690 --> 00:14:27,080
We use them for what I call callback notifications.

174
00:14:27,080 --> 00:14:32,920
There's often I'd like to say with networking code where
you're going to go, you know, fetch URL in chunks, you know,

175
00:14:32,920 --> 00:14:36,310
and every chunk needs to be processed, and so you panned it.

176
00:14:36,310 --> 00:14:42,390
Now you had a block in and every chunk is passed to
your block, and that's a much nicer way to code it.

177
00:14:42,390 --> 00:14:48,880
There's going to be some more talks later this week which
give more examples of the code savings you get to use

178
00:14:48,880 --> 00:14:56,750
by just putting the codes you want in the block and
just handing it off to the API that needs it later.

179
00:14:56,750 --> 00:14:59,700
There's another whole facility
called Grand Central Dispatch.

180
00:14:59,700 --> 00:15:00,900
There're a couple of talks on that.

181
00:15:00,900 --> 00:15:02,150
There's one actually later today.

182
00:15:02,150 --> 00:15:04,290
I'll give references to this.

183
00:15:04,290 --> 00:15:11,860
Where we talked about two things: One is to move code
off the main thread, off the main dispatch queue,

184
00:15:11,860 --> 00:15:14,650
off the main run loop, whatever we call it nowadays.

185
00:15:14,650 --> 00:15:20,400
Because if you try to do too much
work there, then on the Mac,

186
00:15:20,400 --> 00:15:24,510
you get the spinning cursor, on the iPhone you get killed.

187
00:15:24,510 --> 00:15:26,400
So, you don't want to do that.

188
00:15:26,400 --> 00:15:30,360
So, you like-- you want to learn how
to move work off the main thread.

189
00:15:30,360 --> 00:15:32,910
And another thing, GCD is very powerful.

190
00:15:32,910 --> 00:15:38,010
And in general, if you can figure out how to do
things in parallel, GCD is the way to express

191
00:15:38,010 --> 00:15:45,070
that because what GCD does is optimize memory
and battery life and all kinds of things

192
00:15:45,070 --> 00:15:50,440
to make sure you just give enough resources
to get that job done under the circumstances.

193
00:15:50,440 --> 00:15:56,220
And so you just code to GCD queues and the system
kind of takes care of all the thread pooling

194
00:15:56,220 --> 00:15:57,980
and all the other kind of stuff going on.

195
00:15:57,980 --> 00:16:03,770
It's very nice, there're talks later
on, I'll give you a reference to those.

196
00:16:03,770 --> 00:16:07,300
What I showed you on the other
expressions is we capture the variable

197
00:16:07,300 --> 00:16:12,340
and we make a local sort of const copy in that block object.

198
00:16:12,340 --> 00:16:16,300
Sometimes though, you need to mutate the variable.

199
00:16:16,300 --> 00:16:21,610
And so, we actually introduced a new storage
class keyword called under-under Block,

200
00:16:21,610 --> 00:16:26,870
for those cases where you need to pull a
value back from something you sent off.

201
00:16:26,870 --> 00:16:30,590
And I'm not going to talk about
under-under Block here very much.

202
00:16:30,590 --> 00:16:38,420
It's there, it's useful, it's somewhat intuitive, it works,
and if you want to know more, we definitely will talk

203
00:16:38,420 --> 00:16:42,670
about that later to a great degree, on Friday in particular.

204
00:16:42,670 --> 00:16:46,660
So in this case, we're going through a dictionary.

205
00:16:46,660 --> 00:16:50,600
We're given a particular key and
we want to return the value.

206
00:16:50,600 --> 00:16:56,850
I'm sorry, we're given a value and we want to sort
of find the key that was associated with that value,

207
00:16:56,850 --> 00:17:00,420
and so we return the key back to the caller.

208
00:17:00,420 --> 00:17:05,860
So these are the two talks I've referenced.

209
00:17:05,860 --> 00:17:13,370
There's Introducing Blocks and Grand Central Dispatch at
11:30 today, and on Friday we have Advanced Objective-C

210
00:17:13,370 --> 00:17:18,760
and Garbage Collection Techniques, so that's
a little bit more of a Mac and a phone talk.

211
00:17:18,760 --> 00:17:22,780
We cover material for both.

212
00:17:24,030 --> 00:17:27,580
Here's another language construct, the for-in statement.

213
00:17:27,580 --> 00:17:30,770
There's a lot of ways to go through an array.

214
00:17:30,770 --> 00:17:35,200
Most people, we looked at code and many
people are doing this objectAtIndex,

215
00:17:35,200 --> 00:17:38,490
objectAtIndex, objectAtIndex to go through arrays.

216
00:17:38,490 --> 00:17:41,480
Arrays are the lingua franca for collections.

217
00:17:41,480 --> 00:17:44,360
We get arrays back from many, many different APIs.

218
00:17:44,360 --> 00:17:48,400
And going through arrays, we found
that's taking up too many cycles.

219
00:17:48,400 --> 00:17:54,710
So we introduced the language construct for-in that
is backed by a particular protocol which you can adopt

220
00:17:54,710 --> 00:18:04,310
in your codes so that your objects can be-- you can use the
for-in statement on your objects and have them, you know,

221
00:18:04,310 --> 00:18:08,360
rip through whatever kinds of items they might manage.

222
00:18:08,360 --> 00:18:13,700
But in particular, this is a best practice
because this is fast, fastest actually.

223
00:18:13,700 --> 00:18:18,580
This is safest because in the middle of that
iteration, we're actually checking to see

224
00:18:18,580 --> 00:18:23,230
if somebody changed the array underneath you
or changed the dictionary underneath you,

225
00:18:23,230 --> 00:18:25,730
which can generally cause crashes.

226
00:18:25,730 --> 00:18:31,330
And so we throw an exception when we detect a
change so that, you know, at least you don't crash.

227
00:18:31,330 --> 00:18:33,700
You get to figure out what-- you
know, how that exception happens.

228
00:18:33,700 --> 00:18:37,030
So that's, you know, that's a case
of a good practice that we pulled

229
00:18:37,030 --> 00:18:40,880
into the language, and that's the kind of thing we do.

230
00:18:40,880 --> 00:18:45,340
We try to make your job easier and
better and more concise and clear

231
00:18:45,340 --> 00:18:49,490
and all that, all in one little language construct.

232
00:18:49,490 --> 00:18:55,460
People ask me though, how do we get
two values out of the for-in statement?

233
00:18:55,460 --> 00:18:56,570
I couldn't figure out how.

234
00:18:56,570 --> 00:19:00,040
Well, I didn't want to do it the way I figured it out.

235
00:19:00,040 --> 00:19:02,760
We had a better way, and the better way is blocks.

236
00:19:02,760 --> 00:19:11,560
So, if you need more than one value at a time out of an
array or a dictionary, we've added block enumeration APIs

237
00:19:11,560 --> 00:19:15,720
and these are now the fastest way
to get more than one value out.

238
00:19:15,720 --> 00:19:22,000
So, in the case of arrays, I've
illustrated how to get an array reversed

239
00:19:22,000 --> 00:19:25,510
with the index, and that's the fastest way to do it.

240
00:19:25,510 --> 00:19:29,820
And then dictionaries, you often want to
get the key and the value at the same time,

241
00:19:29,820 --> 00:19:32,450
and so this is the fastest way to do that.

242
00:19:32,450 --> 00:19:39,570
These are also safe and are also extensible
because, I'll show how to extend them later.

243
00:19:39,570 --> 00:19:42,780
So anyway, this is best practice.

244
00:19:42,780 --> 00:19:46,620
Let's go back to the phone in these three languages.

245
00:19:46,620 --> 00:19:50,500
It turns out, there's another language on our system.

246
00:19:50,500 --> 00:19:53,890
It's called Objective-C++.

247
00:19:53,890 --> 00:19:59,160
And just as we add sort of an object layer
on top of C in the Objective-C language,

248
00:19:59,160 --> 00:20:06,110
we add that same different object layer on top of
C++ which has its own object, ideas about objects.

249
00:20:06,110 --> 00:20:14,350
And so, let me tell you about Objective-C++ for just a
minute, because if you already have a pile of C++ code,

250
00:20:14,350 --> 00:20:19,420
what you need to know is how to
get the GUI to respond to it.

251
00:20:19,420 --> 00:20:26,210
And so, what you typically do is you write a few files
in Objective C++ and they can talk to your C++ code

252
00:20:26,210 --> 00:20:32,160
and they can talk to the GUI code and, well, I don't
know, you can use Objective C++ for all your C++ code.

253
00:20:32,160 --> 00:20:35,170
And so in this example, it's again contrived.

254
00:20:35,170 --> 00:20:38,890
You signal that it's an Objective-C++ file by the .mm

255
00:20:38,890 --> 00:20:44,790
and a few other variations extension,
and you sort of get to mix and match.

256
00:20:44,790 --> 00:20:50,330
You can mix and match declarations,
instance variables, member variables.

257
00:20:50,330 --> 00:20:51,990
I haven't gotten the terminology slide yet.

258
00:20:51,990 --> 00:21:01,200
So, in this case, I have a C++ class called My Engine
and you can put a reference to your widget in there.

259
00:21:01,200 --> 00:21:06,410
Equivalently, you can have your widget
class and put your engine in there.

260
00:21:06,410 --> 00:21:09,750
So, that's pretty useful.

261
00:21:09,750 --> 00:21:17,420
So, even in Objective-C methods, you
can use the throw statement from C++.

262
00:21:17,420 --> 00:21:28,980
Objective-C has it's own @throw, @catch and @finally,
but the exceptions underneath, the runtime implementation

263
00:21:28,980 --> 00:21:31,940
of them is the same across both of the languages.

264
00:21:31,940 --> 00:21:41,090
And so you can throw from C++ and @catch
from Objective-C, which just works.

265
00:21:41,090 --> 00:21:49,020
The thing that you can't do is you can't sort of
subclass a C++ class in Objective-C or vice versa.

266
00:21:49,020 --> 00:21:52,270
You know, the object models are distinct.

267
00:21:52,270 --> 00:21:58,720
So, you don't get operator overloading in
Objective-C and you don't get selectors in C++.

268
00:21:58,720 --> 00:22:04,760
So, it's sort of a marriage of
convenience perhaps, I don't know.

269
00:22:05,970 --> 00:22:10,120
Let's go on a little bit.

270
00:22:10,120 --> 00:22:20,030
So, Objective-C has its own terminology for common
concepts, and it's hard to present this any other way.

271
00:22:20,030 --> 00:22:23,770
I mean, in Java C++, people talk about member variables.

272
00:22:23,770 --> 00:22:27,150
We talk about instance variables or ivars.

273
00:22:27,150 --> 00:22:34,070
A member function is a method or an
instance method perhaps, or a dash method.

274
00:22:34,070 --> 00:22:42,120
And unlike C++ and Java, they're
always virtual and they're never final.

275
00:22:43,550 --> 00:22:53,720
So, if you like those patterns, just do it by convention
and you're just not going to get compiler support for that.

276
00:22:53,720 --> 00:22:57,540
A static method is different in Objective-C.

277
00:22:57,540 --> 00:23:04,390
In Objective-C, we sort of have a meta-class,
and that the class actually is an object itself.

278
00:23:04,390 --> 00:23:11,000
You can have messages and you can do inheritance in your
plus methods, so you can call super within a plus method,

279
00:23:11,000 --> 00:23:13,510
which is kind of new, a little bit different.

280
00:23:13,510 --> 00:23:17,780
But still, the idea of having a
class method is not totally new,

281
00:23:17,780 --> 00:23:22,580
and so we have to have a terminology thing here
even though the behavior is slightly different.

282
00:23:22,580 --> 00:23:27,320
We have no equivalent to static variable as of yet at least.

283
00:23:27,320 --> 00:23:31,450
So, we just use globals, it works.

284
00:23:31,450 --> 00:23:38,090
What is called an interface, in other languages
it's called a protocol, in Objective-C even though--

285
00:23:38,090 --> 00:23:46,450
we wanted to call them @interface, but as you can see, what
we call a class, we introduced a class using @interface,

286
00:23:46,450 --> 00:23:50,320
so we couldn't use the @interface keyword
that long ago, but other people pick that up.

287
00:23:50,320 --> 00:23:52,490
There is no operator new.

288
00:23:52,490 --> 00:23:54,250
There are no stack objects.

289
00:23:54,250 --> 00:23:59,300
Everything is allocated off the heap
using an alloc method generally,

290
00:23:59,300 --> 00:24:05,240
or we have these things called convenience
constructors, other plus methods can build you things.

291
00:24:05,240 --> 00:24:09,350
I gave you an example already that NSMutableString string.

292
00:24:09,350 --> 00:24:16,380
That string is a plus method that did a sort of a
MutableString alloc init autorelease and return the result.

293
00:24:16,380 --> 00:24:18,930
And finally, we have no explicit destructors.

294
00:24:18,930 --> 00:24:20,720
We have something called the dealloc method.

295
00:24:20,720 --> 00:24:28,320
But unlike destructors, you should
never call the dealloc method yourself.

296
00:24:28,320 --> 00:24:32,370
The dealloc method is called by release;

297
00:24:32,370 --> 00:24:37,820
when release figures out that the last
release has happened, it calls dealloc.

298
00:24:37,820 --> 00:24:41,090
So, don't treat deallocs like destructors.

299
00:24:41,090 --> 00:24:46,430
You will get into a lot of trouble
really quick if you try that.

300
00:24:46,430 --> 00:24:48,690
So, let's do a little bit of review.

301
00:24:48,690 --> 00:24:52,620
We have single inheritance of instance behavior.

302
00:24:52,620 --> 00:24:55,820
So, we have NSObject, it's a got a hash function.

303
00:24:55,820 --> 00:24:58,160
So, we're going to have an airplane and an animal.

304
00:24:58,160 --> 00:25:02,410
We're going to have a fish and a
bird and we're going to have a duck.

305
00:25:02,410 --> 00:25:10,240
And what the language allows is
multiple inheritance of abstract methods,

306
00:25:10,240 --> 00:25:14,920
and so in this case we have a swimmer
that has one method called swim.

307
00:25:14,920 --> 00:25:22,310
We have a flyer and a machine, and as you
can see, the-- I'll see which one is it.

308
00:25:22,310 --> 00:25:27,720
One of these-- duck that multiply inherits
both swimmer and flyer effectively,

309
00:25:27,720 --> 00:25:30,490
and so this is the syntax we use to specify that.

310
00:25:30,490 --> 00:25:36,290
Duck inherits from bird and implements
the swimmer and the flyer protocols.

311
00:25:36,290 --> 00:25:38,710
There's something new though.

312
00:25:38,710 --> 00:25:42,530
Let's pretend that Apple provided animal and bird.

313
00:25:42,530 --> 00:25:49,160
As I said, there was a hash method, there's also
an isEqual method, isEqual is often overridden.

314
00:25:49,160 --> 00:25:52,490
There's a method on NSObject called self.

315
00:25:52,490 --> 00:25:58,230
And I've dimmed out self to sort of indicate
that you really never re-implement that method.

316
00:25:58,230 --> 00:26:01,420
You just inherit the implementation from NSObject.

317
00:26:01,420 --> 00:26:06,710
And so as you get deeper in the class hierarchy, you
get more and more behavior, more and more methods show

318
00:26:06,710 --> 00:26:11,620
up like you got a parents method out of
animal and out of bird, you get a fly method.

319
00:26:11,620 --> 00:26:14,670
And sometimes though-- well, and this is good.

320
00:26:14,670 --> 00:26:17,050
This is what most languages do.

321
00:26:17,050 --> 00:26:19,330
In your application, let's say
you're trying to build a dragon.

322
00:26:19,330 --> 00:26:30,070
And what would be nice, because you're going to animate
these things, it would be nice if you could ask--

323
00:26:30,070 --> 00:26:35,130
you're going to animate lots of objects
including the Apple provided ones and yours.

324
00:26:35,130 --> 00:26:41,640
It would be really nice, though, if you
could just ask, is this object mythical?

325
00:26:41,640 --> 00:26:46,940
Is this Apple provided object a mythical animal?

326
00:26:46,940 --> 00:26:56,120
So, you'd like to add the isMythical method
on to Apple's animal and you can do this.

327
00:26:56,120 --> 00:26:59,740
You do this with something called a category.

328
00:26:59,740 --> 00:27:03,710
Now category is never-- the term category
is never-- it's not in the language.

329
00:27:03,710 --> 00:27:07,560
It's just this funny syntax, and this is the funny syntax.

330
00:27:07,560 --> 00:27:10,140
You declare an extension.

331
00:27:10,140 --> 00:27:19,490
Here I labeled it MythicalExtra and you name a
method, and you promise to implement this somewhere.

332
00:27:19,490 --> 00:27:22,040
And so this is what the implementation would look like.

333
00:27:22,040 --> 00:27:26,010
For animal, it's not mythical, return no.

334
00:27:26,010 --> 00:27:36,020
But in your class, in your dragon class, you also
implement isMythical, and in this case you return yes.

335
00:27:36,020 --> 00:27:40,570
Now notice that bird is going to inherit
animal's implementation so you can--

336
00:27:40,570 --> 00:27:42,690
you know if the bird gets asked, are you mythical?

337
00:27:42,690 --> 00:27:50,640
It's going to inherit the implementation
on animal that you provided in your code.

338
00:27:50,640 --> 00:27:55,140
So, let me talk about categories a little bit more.

339
00:27:55,140 --> 00:28:01,460
So the add behavior to any class; use this judiciously.

340
00:28:01,460 --> 00:28:09,360
I would not recommend just using isMythical here
because you might borrow somebody else's code

341
00:28:09,360 --> 00:28:12,540
or Apple might insert an isMythical method or something.

342
00:28:12,540 --> 00:28:17,990
And so, when you choose method names to extend, make sure
they're really unique because we have a kind of a bug

343
00:28:17,990 --> 00:28:21,630
and we can get a little bit of collisions on these names.

344
00:28:21,630 --> 00:28:22,690
Use them judiciously.

345
00:28:22,690 --> 00:28:26,660
You can extend NSObject but it's not really recommended.

346
00:28:26,660 --> 00:28:31,890
We don't really want a thousand methods on NSObject,
it slows the whole system down a little bit.

347
00:28:31,890 --> 00:28:36,660
So use them where you need to, but
it's a very powerful technique.

348
00:28:36,660 --> 00:28:37,820
They act like normal methods.

349
00:28:37,820 --> 00:28:40,550
You can call super from them, in fact.

350
00:28:40,550 --> 00:28:48,040
And with a little bit of code, you can also add
data to sort of have kind of like a mix in model.

351
00:28:48,040 --> 00:28:55,100
And the way you add data with categories, this thing we call
associative references, and we'll talk about that on Friday.

352
00:28:55,100 --> 00:28:59,970
It's API, and I don't want to get in to too much API here.

353
00:28:59,970 --> 00:29:07,800
You can also use categories to split your implementation
of a class across several files, because technically,

354
00:29:07,800 --> 00:29:12,130
as long as you're within an app or a
framework, you actually have access

355
00:29:12,130 --> 00:29:16,120
to the private instance variables,
again, a little dangerous here.

356
00:29:16,120 --> 00:29:20,090
We don't allow that across frameworks, though.

357
00:29:20,090 --> 00:29:21,780
These categories are very useful.

358
00:29:21,780 --> 00:29:26,790
Let's talk about Memory Management.

359
00:29:26,790 --> 00:29:33,300
So why? Well, if you don't do it
well, you're going to crash.

360
00:29:33,300 --> 00:29:38,490
Memory Management is about keeping objects
around so you can use them when you need them.

361
00:29:38,490 --> 00:29:41,140
And if you don't keep them around, you're going to crash.

362
00:29:41,140 --> 00:29:46,550
On the other hand, if you keep them around forever,
your app gets more and more memory, it gets sluggish,

363
00:29:46,550 --> 00:29:50,620
it gets sluggish, and eventually that's
going to cause it to crash in a way itself.

364
00:29:50,620 --> 00:29:57,240
And so, Memory Management means using just
the right amount of memory and no more.

365
00:29:57,240 --> 00:30:03,510
So, the Cocoa Touch system that you use,
the retain, release, autorelease thing,

366
00:30:03,510 --> 00:30:10,850
was designed for use on a 8-megabyte
system, like 20 years ago.

367
00:30:10,850 --> 00:30:16,680
And, you know, we had to be very memory efficient
back then, and that's also true on the phone.

368
00:30:16,680 --> 00:30:21,360
So, you know, some things change
and some things don't change.

369
00:30:21,360 --> 00:30:24,300
So, it's been around for a while.

370
00:30:24,300 --> 00:30:31,030
So Memory Management, unfortunately, the design of
it starts at-- I mean, it starts at the design phase.

371
00:30:31,030 --> 00:30:36,710
If you just go build an app and you throw retains around
like crazy and then you have to come back and clean it up,

372
00:30:36,710 --> 00:30:42,870
you can be in trouble because you have to think
through your object patterns at the design phase,

373
00:30:42,870 --> 00:30:46,700
and you learn that on your second app probably.

374
00:30:46,700 --> 00:30:53,850
So, the way you design it is you design
object ownership as a directed acyclic graph.

375
00:30:53,850 --> 00:31:00,720
And the ownership of objects comes
from a very simple pattern,

376
00:31:00,720 --> 00:31:04,560
and that is we have few methods that transfer ownership.

377
00:31:04,560 --> 00:31:10,790
Alloc and init transfer ownership
of an object to their receiver.

378
00:31:10,790 --> 00:31:17,180
A copy method does the same thing and there
are a few plus new APIs that also do that.

379
00:31:17,180 --> 00:31:21,310
But otherwise, APIs do not transfer ownership.

380
00:31:21,310 --> 00:31:27,410
You just kind of use them because the objects are around.

381
00:31:27,410 --> 00:31:30,330
And as you saw in the-- if you did, I hope you did.

382
00:31:30,330 --> 00:31:39,560
As you saw in Monday's afternoon talk, the static-- LLVM
Static Analyzer can help you with your retains and releases

383
00:31:39,560 --> 00:31:45,010
by showing you where you got it
wrong, and that's a very cool tool.

384
00:31:45,010 --> 00:31:52,910
The Instrument application can also show you
where you got leaks, and that also was demo'd.

385
00:31:52,910 --> 00:31:57,610
In particular the heap shot command within the memory,

386
00:31:57,610 --> 00:32:07,290
within the allocation instrument can help you detect
unused memory that's just kind of hanging around.

387
00:32:07,290 --> 00:32:12,200
So, let's talk about that directed
acyclic graph a little bit.

388
00:32:12,200 --> 00:32:16,220
So, here's one of them, and it's kind of like a lattice.

389
00:32:16,220 --> 00:32:18,930
You know, pointers just keep pointing down.

390
00:32:18,930 --> 00:32:23,900
And I've illustrated the reference counts, you
know, the number of retains in each object this way.

391
00:32:23,900 --> 00:32:27,670
And let's say that these are all of
the references on the system right now.

392
00:32:27,670 --> 00:32:38,280
So, what happens when that top reference to part of
that graph goes way, the top object loses its ref count

393
00:32:38,280 --> 00:32:42,730
to zero then it lets go of its things on down.

394
00:32:42,730 --> 00:32:45,230
Now, did everybody see the pattern go down?

395
00:32:45,230 --> 00:32:47,100
Let's try that again.

396
00:32:47,100 --> 00:32:53,600
When we let go of that top reference, that top
object goes to zero, it lets go of things it owns.

397
00:32:53,600 --> 00:32:54,970
They let go of what they own.

398
00:32:54,970 --> 00:32:58,500
They let go of what they own, et cetera.

399
00:32:58,500 --> 00:33:02,190
And once you have retain count zero object,
it gets reclaimed and so your graph goes way.

400
00:33:02,190 --> 00:33:04,460
This is what you want to happen.

401
00:33:04,460 --> 00:33:11,420
If you accidentally set up a back pointer, an up pointer
that is retained, then what happens when you let go

402
00:33:11,420 --> 00:33:16,010
of that top reference is the top node
goes from ref count 2 to ref count 1.

403
00:33:16,010 --> 00:33:20,920
It sticks around forever, not what you want.

404
00:33:20,920 --> 00:33:25,580
I think it's obvious what happens if you
fail to do a retain count of an object

405
00:33:25,580 --> 00:33:29,520
and it goes away prematurely, that's also bad.

406
00:33:29,520 --> 00:33:38,280
So, the simple rules to make Memory Management
work well for you are that at the design phase

407
00:33:38,280 --> 00:33:43,880
for every instance variable you decide,
do I retain this one or do I not?

408
00:33:43,880 --> 00:33:45,310
Is it an up pointer?

409
00:33:45,310 --> 00:33:48,760
So, the general pattern is you
retain your instance variables.

410
00:33:48,760 --> 00:33:51,280
Only those up links get non-retained.

411
00:33:51,280 --> 00:34:00,670
And when you go to do assignments, you have to
release the old value on retain instance variables,

412
00:34:00,670 --> 00:34:06,390
and send the retain message to the new
value coming in unless the new value came

413
00:34:06,390 --> 00:34:10,340
from like one of those methods, init, or copy or new.

414
00:34:10,340 --> 00:34:17,350
Finally, sometimes if you're asked to provide a
result and you have to create a result on the fly,

415
00:34:17,350 --> 00:34:24,550
you stick it in the autorelease pool if you don't keep
it yourself, and so that your caller just seize it

416
00:34:24,550 --> 00:34:26,630
and it will go away after a little bit of time.

417
00:34:26,630 --> 00:34:29,880
Let me explain how autorelease pools work.

418
00:34:29,880 --> 00:34:35,150
So at the bottom of your stack, there's
a little bit of code that's going

419
00:34:35,150 --> 00:34:37,950
to get an event or something and call your code.

420
00:34:37,950 --> 00:34:39,390
It's going to call the process event.

421
00:34:39,390 --> 00:34:46,350
So, at the beginning, we created-- well, we have a
stack with some local variables and so we create a pool

422
00:34:46,350 --> 00:34:49,160
and we create-- and we get an event from somewhere.

423
00:34:49,160 --> 00:34:55,860
Now, in all likelihood, the event is also held in
that autorelease pool, but I'm not illustrating that.

424
00:34:55,860 --> 00:34:57,900
And so we start calling process.

425
00:34:57,900 --> 00:35:00,500
And let's say process needs a new date.

426
00:35:00,500 --> 00:35:06,540
It's going to call NSDate date and get
some value out of that and compute.

427
00:35:06,540 --> 00:35:08,730
We passed the event on up the stack.

428
00:35:08,730 --> 00:35:13,410
So inside NSDate, there's some
code that looks a lot like this.

429
00:35:13,410 --> 00:35:16,220
This is the alloc init autorelease pattern.

430
00:35:16,220 --> 00:35:17,280
That's very common.

431
00:35:17,280 --> 00:35:20,100
You guys should probably learn that one as well.

432
00:35:20,100 --> 00:35:25,640
So, at the very beginning, at the alloc init time,
what happens is sort of the stack holds a reference,

433
00:35:25,640 --> 00:35:31,650
a retain count reference to the object D,
that date, and then we send autorelease to it.

434
00:35:31,650 --> 00:35:38,790
And what that does is it transfers ownership down
into the autorelease pool, which is secretly around.

435
00:35:38,790 --> 00:35:41,120
You know, it's just there.

436
00:35:41,120 --> 00:35:46,690
When the date routine returns, you know, D
is returned on the stack, it gets processed

437
00:35:46,690 --> 00:35:49,720
and used, you know, it gets the value out of it.

438
00:35:49,720 --> 00:35:58,450
And when that frame goes away, the autorelease
pool is left with the reference to that date.

439
00:35:58,450 --> 00:36:01,830
It's still hanging around even
though nobody knows about it anymore.

440
00:36:01,830 --> 00:36:09,650
But eventually the pool is drained, which is how we get rid
of the objects within a pool and get rid of the pool itself.

441
00:36:09,650 --> 00:36:15,710
And so, the pool goes away and everything within
it goes away and that data object goes away

442
00:36:15,710 --> 00:36:20,290
and there's no memory loss, and so
that's how autorelease pools work.

443
00:36:20,290 --> 00:36:25,920
You can actually create them and use them yourself
when you know you're going to be creating a lot

444
00:36:25,920 --> 00:36:28,710
of objects, a lot of autorelease objects.

445
00:36:28,710 --> 00:36:35,820
You can create a pool and then drain it yourself, and
that's a well understood Memory Management technique

446
00:36:35,820 --> 00:36:39,800
that you use when tuning for performance.

447
00:36:39,800 --> 00:36:44,330
Let's talk about accessors.

448
00:36:44,330 --> 00:36:56,320
In Cocoa, we have had this pattern for 18 years of
balance and setBalance as the way we named our accessors.

449
00:36:56,320 --> 00:37:02,750
You have a backing instance variable called int balance,
and in the implementation you implement these methods.

450
00:37:02,750 --> 00:37:06,080
There's just a lot of typing of that balance word, right?

451
00:37:06,080 --> 00:37:11,460
So, to kind of make this simpler, what we
introduced was something called properties.

452
00:37:11,460 --> 00:37:15,300
And so to replace that code I just
showed you, this is what you need to do.

453
00:37:15,300 --> 00:37:18,680
You say @property int balance.

454
00:37:18,680 --> 00:37:26,370
And then in your implementation, you say @synthesize
balance, and because we now have the same runtime running

455
00:37:26,370 --> 00:37:30,820
in the Simulator, as you have on
the iPhone, we get to make use

456
00:37:30,820 --> 00:37:36,320
of this Objective-C 2 feature such
if that's all you have to do.

457
00:37:36,320 --> 00:37:41,220
The compiler will synthesize the
instance variable in your class

458
00:37:41,220 --> 00:37:47,090
and it will synthesize the implementations
of that setter and getter.

459
00:37:47,090 --> 00:37:52,010
In fact, though, we noticed, well,
why do even need the @synthesize?

460
00:37:52,010 --> 00:37:57,510
And so, in Xcode 4, in the new
LLVM compiler that comes with it--

461
00:37:57,510 --> 00:38:04,280
[ Applause ]

462
00:38:04,280 --> 00:38:05,830
-- it's on by default.

463
00:38:05,830 --> 00:38:09,060
So, let's talk a little bit more.

464
00:38:09,060 --> 00:38:14,670
To get to that new facility though, you
have to pass a special flag to the compiler.

465
00:38:14,670 --> 00:38:19,610
It's there but it's not quite integrated
in the IDE the way we would like it to be.

466
00:38:19,610 --> 00:38:20,520
It will be though.

467
00:38:20,520 --> 00:38:24,560
So, let's talk about properties
a little bit more specifically.

468
00:38:24,560 --> 00:38:26,970
Properties have attribute, so these things in parenthesis.

469
00:38:26,970 --> 00:38:31,410
In this case, we're going to say perhaps
balance was a read-only in customobject,

470
00:38:31,410 --> 00:38:38,990
and in a subclass of customobject called supercustom,
we want to make it read-write, that is allowed.

471
00:38:38,990 --> 00:38:43,110
Otherwise, whatever attribute you see sticks.

472
00:38:43,110 --> 00:38:49,780
It's an unchangeable property of
the property unchangeable attribute.

473
00:38:49,780 --> 00:38:52,490
Let's talk about what those all are about.

474
00:38:52,490 --> 00:38:59,120
So, if you don't like our names, if you don't like
set and if you like get or whatever, you can actually,

475
00:38:59,120 --> 00:39:04,490
in that parenthesized section, you know,
provide your own custom method names.

476
00:39:04,490 --> 00:39:10,310
The other-- the other thing you could do as an attribute
is particular if you're talking about an object property,

477
00:39:10,310 --> 00:39:18,750
is you have to tell the compiler whether it's a
retained object, whether it's simply assigned.

478
00:39:18,750 --> 00:39:24,250
Assigned is sort of a synonym for non-retained,
at least in the retain-release world.

479
00:39:24,250 --> 00:39:26,450
And the other option, the key option, is copy.

480
00:39:26,450 --> 00:39:32,840
Well, we'll get to copyable-- mutable
copy kinds of things later.

481
00:39:32,840 --> 00:39:37,150
But it's very important-- and copy
implies retain, by the way.

482
00:39:37,150 --> 00:39:44,360
So, that's how you get values into your object, you know,
but you can pass a mutable string in because it's going

483
00:39:44,360 --> 00:39:48,630
to be copy that we copied into
an immutable string and stored.

484
00:39:48,630 --> 00:39:52,610
Nonatomic is a keyword that sort of means single-threaded.

485
00:39:52,610 --> 00:39:56,000
It's kind of performance.

486
00:39:56,000 --> 00:40:04,490
There are some slight safety issues with it
but it's very prevalent on the iPhone, on iOS.

487
00:40:04,490 --> 00:40:08,680
But it's generally considered harmless.

488
00:40:08,680 --> 00:40:15,910
We'd prefer that you not use it though
because as dispatch queues and things go on,

489
00:40:15,910 --> 00:40:20,000
things are becoming more multithreaded all the time.

490
00:40:20,000 --> 00:40:24,410
Finally, I already talked about read-only and read-write.

491
00:40:24,410 --> 00:40:32,250
The idea with that property is you don't have to
trust the compiler to do any of the work at all.

492
00:40:32,250 --> 00:40:35,420
You can use an app property and fully implement it.

493
00:40:35,420 --> 00:40:39,010
You can have your secretBalance, you
can write your setter and getter.

494
00:40:39,010 --> 00:40:45,190
In this case, maybe you had, you know, a different
instance variable than something called balance.

495
00:40:45,190 --> 00:40:46,820
And so I illustrated that.

496
00:40:46,820 --> 00:40:52,920
And that pattern is common enough though
that we actually support that in the compiler

497
00:40:52,920 --> 00:40:58,230
by simply saying @synthesize balance=secretBalance.

498
00:40:58,230 --> 00:41:03,190
And if you didn't even provide
secretBalance, you could do that also

499
00:41:03,190 --> 00:41:07,960
and the compiler would synthesize
a secretBalance instance variable.

500
00:41:07,960 --> 00:41:13,840
So it's-- use it you know as much as you want, use
it for everything, use it for some other things.

501
00:41:13,840 --> 00:41:22,620
Finally, if you're going to be using that @property by
default, there are some rare cases where you don't want

502
00:41:22,620 --> 00:41:29,130
to provide an implementation at all because you know how to
use forwarding, because there's another hook you can use.

503
00:41:29,130 --> 00:41:34,460
And in those cases, you have to use @dynamic
or you will be required to use @dynamic

504
00:41:34,460 --> 00:41:38,180
to tell the compiler to not synthesize things.

505
00:41:38,180 --> 00:41:43,400
So, that's a keyword that's going to get
a little more use, I think, in the future.

506
00:41:43,400 --> 00:41:46,810
Again, advanced garbage collection, Advanced Objective-C

507
00:41:46,810 --> 00:41:49,960
and Garbage Collection talk is where
you're going to learn about that.

508
00:41:49,960 --> 00:41:53,500
Now, I cheated a little bit.

509
00:41:53,500 --> 00:41:57,170
I didn't talk about properties of objects.

510
00:41:57,170 --> 00:42:03,250
This is a pattern you have to write,
would have to write yourself in order

511
00:42:03,250 --> 00:42:11,260
to implement a correct property object
attribute, I'm sorry, correct object property.

512
00:42:11,260 --> 00:42:18,370
In particular, you need to synchronize, you need to make
sure that 2 threads aren't trying to set at the same time

513
00:42:18,370 --> 00:42:22,700
and one of them gets half the result and the other
one doesn't, or a getter is trying to come in

514
00:42:22,700 --> 00:42:26,390
and give a value that's being changed,
being released underneath it.

515
00:42:26,390 --> 00:42:29,350
And so, it's actually kind of complicated.

516
00:42:29,350 --> 00:42:34,100
And so, we actually want you to
use that synthesize, wants you to--

517
00:42:34,100 --> 00:42:38,110
you have the compiler in runtime
do the hard work for you on this.

518
00:42:38,110 --> 00:42:45,740
And in particular, you do need to write a little piece
of code in the dealloc method to get rid of that object.

519
00:42:45,740 --> 00:42:50,610
So, here you can just send title the
release message, which is typical.

520
00:42:50,610 --> 00:42:53,980
I also showed what we call our .syntax.

521
00:42:53,980 --> 00:43:02,840
Self.title = nil is some shorthand
for saying set title to nil.

522
00:43:02,840 --> 00:43:09,270
The compiler just turns that self.title
into self set title to nil.

523
00:43:09,270 --> 00:43:15,690
And that's-- the .syntax works,
you know, everywhere pretty much.

524
00:43:15,690 --> 00:43:20,200
And-- but it's just shorthand for
sending Objective-C messages around.

525
00:43:20,200 --> 00:43:25,850
We don't really do-- the compiler really doesn't,
you know, spit out the code to do it in line.

526
00:43:25,850 --> 00:43:33,230
It's just-- it's just a-- almost a macro for
calling-- calling the message explicitly.

527
00:43:33,230 --> 00:43:40,920
So, let me talk a little bit more about Cocoa patterns.

528
00:43:40,920 --> 00:43:45,550
So, selectors are kind of fun, they're
not really in any other language.

529
00:43:45,550 --> 00:43:51,200
Selectors are data structures that
represent sort of the slot name.

530
00:43:51,200 --> 00:43:55,470
There are some API's you can get to,
to get the actual string that's used.

531
00:43:55,470 --> 00:44:00,640
It's foo: bar: whatever, at the moment.

532
00:44:00,640 --> 00:44:03,980
They're not really too interesting.

533
00:44:03,980 --> 00:44:10,990
The id object type, that was the original object type
and the only object type when Objective-C was invented.

534
00:44:10,990 --> 00:44:19,130
It allows any message to be sent to it, without warning, by
the compiler, even ones that aren't going to be implemented.

535
00:44:19,130 --> 00:44:26,680
And we have invented or it was invented, this method called
respondsToSelector, and so in this case we have syntax

536
00:44:26,680 --> 00:44:29,920
for naming a selector on the fly called @selector here.

537
00:44:29,920 --> 00:44:35,060
We're going to ask, does object
respond to the selector fred?

538
00:44:35,060 --> 00:44:38,840
And if so, we're going to send fred to that object.

539
00:44:38,840 --> 00:44:44,620
Now that's kind of squirrelly you might think,
except within UIKit we use it all the time.

540
00:44:44,620 --> 00:44:47,390
Let me show you where.

541
00:44:47,390 --> 00:44:49,120
We use it for delegates.

542
00:44:49,120 --> 00:44:55,700
You know, an Interface Builder where you hook up
a delegate to a control, this is what's going on.

543
00:44:55,700 --> 00:45:00,790
You implement a particular method that you
want done at a particular piece of time.

544
00:45:00,790 --> 00:45:03,880
I pulled this one out of the action sheet thing.

545
00:45:03,880 --> 00:45:10,860
So, suppose you needed to overwrite and do something special
when the willPresentActionSheet message would come up.

546
00:45:10,860 --> 00:45:16,360
And so, you implement just that method and,
you know somewhere you set the delegate.

547
00:45:16,360 --> 00:45:21,660
And normally, you kind of do that in Interface
Builder, but you can do it by hand also.

548
00:45:21,660 --> 00:45:31,780
And again, the .delegate is our .syntax for
saying UIActionSheet setDelegate to self.

549
00:45:31,780 --> 00:45:35,060
So, this is your part on how to do delegation.

550
00:45:35,060 --> 00:45:47,880
Inside-- or not inside, but UIKit actually declares a
set of methods as optional methods within a protocol.

551
00:45:47,880 --> 00:45:51,330
Optional is not in other languages.

552
00:45:51,330 --> 00:45:53,880
Optional says these are sometimes implemented.

553
00:45:53,880 --> 00:45:56,290
This is the syntax for them.

554
00:45:56,290 --> 00:46:05,220
And so, UIActionSheet declares its
delegate as implementing this protocol.

555
00:46:05,220 --> 00:46:10,520
And so when you set the delegate,
you know, your class-- let's back up.

556
00:46:10,520 --> 00:46:13,660
Your class implements UIActionSheetDelegate.

557
00:46:13,660 --> 00:46:18,730
And so you get type safety when
you do that setDelegate method.

558
00:46:18,730 --> 00:46:29,000
And inside UIKit, when it comes time to ask to present
that sheet, it goes respondsToSelector, you know,

559
00:46:29,000 --> 00:46:32,190
whatever that meant that was, willPresentActionSheet.

560
00:46:32,190 --> 00:46:35,610
And if your object implements it,
then it will go send that to you.

561
00:46:35,610 --> 00:46:40,440
Or in other time, it's going to say
didPresentActionSheet and it goes respondsToSelector

562
00:46:40,440 --> 00:46:44,960
and you don't implement that, so
it says ah, don't bother, skip it.

563
00:46:44,960 --> 00:46:52,000
And so, respondsToSelector is a very powerful mechanism
to, you know, add optional behavior to things.

564
00:46:52,000 --> 00:46:57,640
And it simplifies your life because you could put a lot
of code in the delegate and not have to do subclassing

565
00:46:57,640 --> 00:46:59,780
and figure out how to do subclassing properly.

566
00:46:59,780 --> 00:47:01,910
So it's a pattern that we use a lot.

567
00:47:01,910 --> 00:47:05,490
Target action uses selectors all the time also.

568
00:47:05,490 --> 00:47:08,650
Let's talk about class clusters.

569
00:47:08,650 --> 00:47:20,410
A class cluster is sort of an abstract class, like NSString,
then that's all you want to know about strings is the things

570
00:47:20,410 --> 00:47:26,920
in NSString itself, even though under the covers what
we do is we actually have several implementations.

571
00:47:26,920 --> 00:47:31,540
They're concrete secret private
implementations and you don't care,

572
00:47:31,540 --> 00:47:34,040
except if you know how to build a string yourself,

573
00:47:34,040 --> 00:47:42,050
we tell you how to do that by implementing
sort of a key method in the abstract class.

574
00:47:42,050 --> 00:47:47,900
So, we don't typically subclass
NSString to add behavior to it.

575
00:47:47,900 --> 00:47:53,270
You know, you don't tell it to go do other
things too much, we use categories for that.

576
00:47:53,270 --> 00:47:58,940
So there're categories for, say, open this
string as a file rather than subclassing it,

577
00:47:58,940 --> 00:48:01,520
the sting to be a special file kind of thing.

578
00:48:01,520 --> 00:48:07,530
So categories let's you add behavior to things
like even NSString, and Apple does that.

579
00:48:07,530 --> 00:48:13,140
And you get to subclass primarily
for representational reasons.

580
00:48:14,270 --> 00:48:19,280
There is, and we hear about-- you see in the
documentation this thing called property lists.

581
00:48:19,280 --> 00:48:24,150
And property lists are value classes, including collections.

582
00:48:24,150 --> 00:48:32,850
So we have strings and data, we have
NSNumbers and we have dictionaries and dates.

583
00:48:32,850 --> 00:48:34,750
And so those are the property list classes.

584
00:48:34,750 --> 00:48:41,270
They are easily transcribed and onto disc or
into HTML or, you know, many different formats.

585
00:48:41,270 --> 00:48:43,540
And the key thing about them is they're immutable.

586
00:48:43,540 --> 00:48:44,680
They're a value class.

587
00:48:44,680 --> 00:48:51,780
You can use them freely across all those threads
that dispatch is offering you because, you know,

588
00:48:51,780 --> 00:48:55,220
there's not going to be no contention on them.

589
00:48:55,220 --> 00:48:59,910
Another pattern-- or this isn't really a
pattern, this is just part of the system.

590
00:48:59,910 --> 00:49:04,710
A pattern we have is sort of our mutable value pattern.

591
00:49:04,710 --> 00:49:13,930
Several of those classes, plus a couple of others and not
all of them, we have this abstract layer of immutability.

592
00:49:13,930 --> 00:49:16,840
Strings and arrays, you can't change.

593
00:49:16,840 --> 00:49:18,810
Data, you can't change.

594
00:49:18,810 --> 00:49:21,560
And so we have for each one of them an inheritance,

595
00:49:21,560 --> 00:49:27,010
and we have a mutable version of
them which you can change obviously.

596
00:49:27,010 --> 00:49:35,720
So when we designed these, we said we want to have a
mutableCopy method, and clearly a mutableCopy method

597
00:49:35,720 --> 00:49:40,600
when passed to a mutableString
should give you a mutableString back.

598
00:49:40,600 --> 00:49:48,620
And similarly, if you sent mutableCopy to an NSString,
you should get a mutable version back out of it.

599
00:49:48,620 --> 00:49:55,670
So, that led us to conclude that when
you send copy to an NSDictionary,

600
00:49:55,670 --> 00:49:58,900
you should get an immutable dictionary out of it.

601
00:49:58,900 --> 00:50:08,070
But surprisingly, when you send copy to a mutable
dictionary, you get an immutable value out of it.

602
00:50:08,070 --> 00:50:09,970
That's just the way we do things.

603
00:50:09,970 --> 00:50:13,350
It's a little surprising, you need to know this.

604
00:50:13,350 --> 00:50:16,890
We have protocols for both of those.

605
00:50:16,890 --> 00:50:19,130
And so you see the protocols adopted.

606
00:50:19,130 --> 00:50:25,000
NSObject for example does not implement the
copying protocol, so your objects do not have

607
00:50:25,000 --> 00:50:30,450
to implement copying although NSObject
does actually participate

608
00:50:30,450 --> 00:50:36,400
and actually does implement copy just
as a helper for those classes that do.

609
00:50:36,400 --> 00:50:40,610
So, I talked about the terminology for common concepts.

610
00:50:40,610 --> 00:50:47,180
I talked about our most important uncommon ideas,
you know, blocks and properties, categories.

611
00:50:47,180 --> 00:50:53,970
I touched on some of the other little-- little things
that are different about our language and how we use it.

612
00:50:53,970 --> 00:50:57,220
And finally, we talked about patterns a little bit.

613
00:50:57,220 --> 00:51:04,590
So, the related sessions of interest are Introducing
Blocks and Grand Central Dispatch where you learn how

614
00:51:04,590 --> 00:51:09,090
to move work off of your queue, that's later today at 11:30.

615
00:51:09,090 --> 00:51:16,280
API design for Cocoa and Cocoa Touch, we
have a review committee for APIs inside Apple

616
00:51:16,280 --> 00:51:19,950
to make sure they come out looking just right.

617
00:51:19,950 --> 00:51:23,010
And API design is hard.

618
00:51:23,010 --> 00:51:27,250
And so, Ali Ozer is going to give
this talk on Thursday at 4:30.

619
00:51:27,250 --> 00:51:28,730
I highly recommend it.

620
00:51:28,730 --> 00:51:32,460
Ali is just the best guy for this.

621
00:51:32,460 --> 00:51:36,580
Advanced Objective-C and Garbage
Collection Techniques is going to be given

622
00:51:36,580 --> 00:51:41,600
by my colleague, Greg Parker, on Friday at 11:30.

623
00:51:41,600 --> 00:51:49,080
We'll talk about how blocks really get copied to the
heap and, you know, some of the fun stuff that goes on.

624
00:51:49,080 --> 00:51:57,460
And for more information, you can contact your developer,
our developer tools evangelist, Michael Jurewitz.

625
00:51:57,460 --> 00:52:00,110
He calls me Blainecus
so I call him Michaelopolis.

