WEBVTT

00:00:06.280 --> 00:00:08.230
>> Morgan Grainger: Good morning.

00:00:08.230 --> 00:00:13.810
My name is Morgan Grainger and though my business cards say
"Dreamer," most people would call me a software engineer.

00:00:13.810 --> 00:00:19.560
I'm really excited to be here this morning to talk
to you about using Core Location in iPhone OS 4 or,

00:00:19.560 --> 00:00:23.200
as I would call it, how location
changes everything for your users

00:00:23.200 --> 00:00:26.500
and your applications, but not to set expectations too high.

00:00:26.500 --> 00:00:30.310
So let's start off by talking about you.

00:00:30.310 --> 00:00:32.330
Why are you here this morning?

00:00:32.330 --> 00:00:34.270
So I'm assuming that you're here because you want

00:00:34.270 --> 00:00:38.730
to make your applications more location
aware and that can mean a few things.

00:00:38.730 --> 00:00:43.910
Maybe it means taking your existing application
and adding location to make it more intuitive,

00:00:43.910 --> 00:00:50.530
easier to use to add new features or maybe it means
designing entirely new location-aware experiences

00:00:50.530 --> 00:00:51.930
for your users.

00:00:51.930 --> 00:00:58.340
Whatever your goal my goal is to help you get there
and so I hope you sit back and take in the information

00:00:58.340 --> 00:01:03.200
and if you have any questions,
I'd love to hear them at the end.

00:01:03.200 --> 00:01:05.440
So, I'm here to talk about four things today.

00:01:05.440 --> 00:01:08.900
The first thing I'm going to talk about is why location?

00:01:08.900 --> 00:01:10.200
Why is it important?

00:01:10.200 --> 00:01:11.470
Why does it matter?

00:01:11.470 --> 00:01:13.110
What can you get out of it?

00:01:13.110 --> 00:01:16.770
The second thing I need to discuss is how does it work?

00:01:16.770 --> 00:01:20.610
What are the technologies that
underlie location services on iOS?

00:01:20.610 --> 00:01:22.320
After that, I'll get into the details.

00:01:22.320 --> 00:01:23.040
How do you use it?

00:01:23.040 --> 00:01:25.490
How do you integrate location services
into your application?

00:01:25.490 --> 00:01:31.290
And the last thing I'm going to talk about
are several exciting new location services

00:01:31.290 --> 00:01:34.100
that we've integrated into iOS 4.

00:01:34.100 --> 00:01:36.240
So, let's get started.

00:01:36.240 --> 00:01:38.640
Why location?

00:01:38.640 --> 00:01:42.910
Now, location though you know it's
kind of a simple thing in principle,

00:01:42.910 --> 00:01:45.440
it's actually used for a lot of things in practice.

00:01:45.440 --> 00:01:48.170
On a basic level, location tells you where you are.

00:01:48.170 --> 00:01:54.610
The built-in Maps application on iPhone and iPad
you can hit a button and it shows you a map,

00:01:54.610 --> 00:01:56.260
maybe you use the compass to show your direction.

00:01:56.260 --> 00:01:59.220
It's a simple concept, but it's very powerful.

00:01:59.220 --> 00:02:03.990
Maps is one of the most used location-aware
apps on the platform.

00:02:03.990 --> 00:02:06.320
Location goes well beyond that though.

00:02:06.320 --> 00:02:12.630
Location can tell you where you want to go by providing
context, by saying well, I'm here if you enter some address

00:02:12.630 --> 00:02:18.720
where I want to get to, by using GPS and other location
services we can guide you along the way and making use

00:02:18.720 --> 00:02:26.890
of data we can use that to get the user towards their
destination step-by-step, but not only for just,

00:02:26.890 --> 00:02:30.100
it's not only good just for saying here's
where I am and here's where I want to go.

00:02:30.100 --> 00:02:36.640
Location is really powerful when it's integrated as a
piece of other applications to make them more intuitive.

00:02:36.640 --> 00:02:41.500
Applications like Yelp where, you know,
if I say I'm here I'm at the Moscone Center,

00:02:41.500 --> 00:02:44.690
I'm here for WWDC, I just want to find a place to eat.

00:02:44.690 --> 00:02:51.050
Without location, I'd have to go and say, yeah, I'm at
the Moscone Center, you know, in downtown San Francisco.

00:02:51.050 --> 00:02:55.850
Before it could load information about what's around
me, but with location I can just hit a button,

00:02:55.850 --> 00:02:59.280
give my authorization, and my location is right there.

00:02:59.280 --> 00:03:05.810
Even things like Kayak; I need to catch a flight out, if it
knows my location, it knows my nearest airport right away,

00:03:05.810 --> 00:03:08.240
and I can get on to specifying more details.

00:03:08.240 --> 00:03:09.980
It breaks down those barriers.

00:03:09.980 --> 00:03:14.120
And then the last thing it can do is social locations.

00:03:14.120 --> 00:03:16.940
The idea of sharing my location with others.

00:03:16.940 --> 00:03:24.130
I can add context, I can make my updates, the things
that I share richer by including location information.

00:03:24.130 --> 00:03:28.140
If I go up to the Golden Gate Bridge, you
know, I'm visiting San Francisco and I say,

00:03:28.140 --> 00:03:30.200
yeah, I'm here, this bridge is really red.

00:03:30.200 --> 00:03:32.620
Like they must have to paint it constantly.

00:03:32.620 --> 00:03:38.900
Because the application knows my location, it
already knows where I am, it can, you know,

00:03:38.900 --> 00:03:45.180
suggest places that I might want to, that I might want to
comment on and then it's easier for me to add my information

00:03:45.180 --> 00:03:50.620
to annotate that location, but it
builds a base that I can start with.

00:03:50.620 --> 00:03:54.310
So those are four things that location can do.

00:03:54.310 --> 00:03:58.150
In summary, location is important
because it provides context.

00:03:58.150 --> 00:04:03.800
It allows you to break down barriers between what
your user wants to do and how they can get there.

00:04:03.800 --> 00:04:08.360
It provides that information that otherwise it
would have to enter or tell you some other way.

00:04:08.360 --> 00:04:14.920
It makes your applications easier to use, and
more than that, it enables entirely new use cases.

00:04:14.920 --> 00:04:20.940
So, that's why location and that's the
first thing I wanted to talk about today.

00:04:20.940 --> 00:04:23.040
The next thing is how does it work?

00:04:23.040 --> 00:04:31.620
iOS is leading the way with location services in the mobile
space and there's actually a lot going on under the hood.

00:04:31.620 --> 00:04:38.620
So, I'm going to talk about three positioning technologies
that are in use on varying devices that run iOS in order

00:04:38.620 --> 00:04:43.660
to provide location services and then I'm going to
talk about what that means in your applications.

00:04:43.660 --> 00:04:49.400
In addition, we've made some pretty significant improvements
in each of the positioning technologies available

00:04:49.400 --> 00:04:55.270
in the past year, and I'm excited to tell you about how
they make your applications usable in more circumstances

00:04:55.270 --> 00:04:59.200
and improve the quality of services
that you can provide for your users.

00:04:59.200 --> 00:05:07.740
So we have three positioning methods of iPhone OS; cell
positioning, Wi-Fi positioning and GPS positioning.

00:05:07.740 --> 00:05:10.670
First one I am going to talk about is cell positioning.

00:05:10.670 --> 00:05:17.440
The way this works is that on devices with cellular radio,
we know which cell tower, we know the unique identifier

00:05:17.440 --> 00:05:19.720
of the cell tower that your device is connected to.

00:05:19.720 --> 00:05:26.760
If we have a database up in the cloud somewhere that
knows the position of that cell tower and we can go

00:05:26.760 --> 00:05:32.230
and retrieve it, but in turn we can
know approximately where your device is.

00:05:32.230 --> 00:05:39.690
Now the accuracy of this approach kind of the error,
the difference between where the reported location

00:05:39.690 --> 00:05:43.770
and where your user actually is
depends on the range of the cell tower.

00:05:43.770 --> 00:05:51.100
In urban areas where you've got high density, a lot of
cells, each cell will generally serve a smaller area

00:05:51.100 --> 00:05:55.040
and so the accuracy will be smaller;
maybe in the, it'll be more accurate.

00:05:55.040 --> 00:05:56.170
The error will be smaller.

00:05:56.170 --> 00:06:02.100
Maybe appropriately in the 500 meter range whereas in
more rural areas where you've got much larger distances

00:06:02.100 --> 00:06:08.010
between cells the errors can sometimes be greater.

00:06:08.010 --> 00:06:11.100
The great thing about cell positioning
though is that it's nearly ubiquitous.

00:06:11.100 --> 00:06:16.300
Anywhere that you've got, that you can get
cell coverage, we can potentially locate you.

00:06:16.300 --> 00:06:22.180
Whether you're indoors, whether you're outdoors, it's really
one of the most versatile location technologies around.

00:06:22.180 --> 00:06:25.460
So, that's cell positioning.

00:06:25.460 --> 00:06:27.160
Next up is Wi-Fi positioning.

00:06:27.160 --> 00:06:29.110
This is similar in concept.

00:06:29.110 --> 00:06:35.760
What we do is we do a scan to see what advertised
Wi-Fi hotspots are in range of your device and instead

00:06:35.760 --> 00:06:40.800
of associating with them as you would do if you were
trying to get data, we just note their unique identifier,

00:06:40.800 --> 00:06:48.380
their Mac address, and do the same sort of correlation going
to a server say what's the position of this Wi-Fi hotspot?

00:06:48.380 --> 00:06:53.390
And if it's in the database, we
can locate the user based on that.

00:06:53.390 --> 00:07:03.050
Because Wi-Fi hotspots tend to have a smaller range
say in generally around 100 meters or so, the accuracy,

00:07:03.050 --> 00:07:05.610
the estimated error is generally smaller.

00:07:05.610 --> 00:07:08.250
Often in the 100 meter range.

00:07:08.250 --> 00:07:12.750
The great thing about Wi-Fi positioning
is that most hotspots tend to be indoors

00:07:12.750 --> 00:07:16.710
and that's precisely the environment
in which GPS positioning,

00:07:16.710 --> 00:07:19.190
which I'm going to talk about next,
tends to struggle the most.

00:07:19.190 --> 00:07:25.700
As long as there are Wi-Fi hotspots in the
area, we can potentially locate your user.

00:07:25.700 --> 00:07:30.610
And so the third technology and the
one that people often thing of most

00:07:30.610 --> 00:07:35.280
when they think of location is GPS positioning.

00:07:35.280 --> 00:07:42.130
So, the iPhone 3GS, the iPhone 3G and the
iPhone 4 all have a built-in GPS receiver.

00:07:42.130 --> 00:07:47.410
Essentially what it does is it listens for signals from
satellites in orbit and if it can receive enough of them,

00:07:47.410 --> 00:07:50.400
it can triangulate to determine your position.

00:07:50.400 --> 00:07:55.560
One thing to note about our GPS is that it's
assisted and what that means is that we can make use

00:07:55.560 --> 00:08:00.490
of a data connection, either a Wi-Fi or a cell data
connection, to download assistance information.

00:08:00.490 --> 00:08:05.880
Things like where we expect the satellite
to be in the sky at a certain point in time.

00:08:05.880 --> 00:08:09.400
The other type of assistance we
provide is location assistance.

00:08:09.400 --> 00:08:13.860
If the receiver knows approximately where the
user is, they can use that information as input

00:08:13.860 --> 00:08:20.170
to narrow what satellites it should be seeing
and, thus, to give you a position more quickly.

00:08:20.170 --> 00:08:22.030
Three types of positioning.

00:08:22.030 --> 00:08:28.430
And while there are those three types from your
perspective there's one API, Core Location.

00:08:28.430 --> 00:08:33.730
We've taken these technologies each with their
situations where they work really well and situations

00:08:33.730 --> 00:08:38.340
where maybe other technologies would work better,
and we've integrated them into this one API.

00:08:38.340 --> 00:08:42.800
We've abstracted them away so from your perspective
in your application you just have to say I would

00:08:42.800 --> 00:08:45.650
like a location, and we provide that for you.

00:08:45.650 --> 00:08:54.840
Now, I've talked a little bit about comparing the methods,
comparing the positioning methods, and what we usually think

00:08:54.840 --> 00:08:58.530
of first when we think of location is precision.

00:08:58.530 --> 00:09:03.710
How close is the reported position
to where the user actually is?

00:09:03.710 --> 00:09:07.980
And so as I've noted GPS is generally the most precise.

00:09:07.980 --> 00:09:11.560
You can sometimes get positions within five or ten meters,

00:09:11.560 --> 00:09:17.200
but precision isn't the only criteria
on which to judge location technologies.

00:09:17.200 --> 00:09:19.990
There's a reason that we use all three of them.

00:09:19.990 --> 00:09:22.460
Another big one is power.

00:09:22.460 --> 00:09:26.120
When you just really want to use your application
and they want to get a benefit out of it,

00:09:26.120 --> 00:09:31.920
but they really want their battery to last all
day as well and while GPS is really precise,

00:09:31.920 --> 00:09:38.790
it also takes a lot of battery power when compared to
technologies like Wi-Fi positioning and cell positioning.

00:09:40.050 --> 00:09:47.650
The third way that I think it's worthwhile to compare
positioning technologies is with regards to time.

00:09:47.650 --> 00:09:51.250
How long does it take to get a position?

00:09:51.250 --> 00:09:53.750
And this is really important depending on your use case.

00:09:53.750 --> 00:09:59.620
If you have an application that uses location as a
means to an end as a way to get the user some result,

00:09:59.620 --> 00:10:03.240
something that they want to see, then
it may actually be more important to you

00:10:03.240 --> 00:10:06.770
to get a position quickly than to
get a really accurate position.

00:10:06.770 --> 00:10:12.070
If I want to see what movie theatres are around so I
can just, so I can go and see the latest new movie,

00:10:12.070 --> 00:10:16.090
I want to see what movie theaters are
approximately around me really quickly.

00:10:16.090 --> 00:10:19.930
Instead if I'm in an environment where GPS positioning
is more challenging and you really want to get

00:10:19.930 --> 00:10:24.800
that precise position, you know, it could be
15-20 seconds before you can show me information

00:10:24.800 --> 00:10:28.060
on the screen and that's not valuable to me as a user.

00:10:28.060 --> 00:10:31.280
So, it's important to look at these
technologies as complementary.

00:10:31.280 --> 00:10:37.090
They each work in different scenarios; they have different
characteristics in terms of precision, in terms of power

00:10:37.090 --> 00:10:39.980
and in terms of time so keep that in mind.

00:10:39.980 --> 00:10:46.610
Now, the other thing to consider is
that iOS is more than just iPhone.

00:10:46.610 --> 00:10:53.960
We have, you know, all three technologies are on the
iPhone and on the 3G iPad, but Core Location is also

00:10:53.960 --> 00:10:58.690
on the iPod touch and it's actually
also on Macs running Snow Leopard.

00:10:58.690 --> 00:11:06.860
And as I'm sure you're aware, there are significant number
of iPod touch devices in the world, just as an example,

00:11:06.860 --> 00:11:13.880
and while it may "only" have Wi-Fi positioning, there's
still a surprising amount you can do with that technology

00:11:13.880 --> 00:11:22.370
and it's a disservice to your user base to exclude,
you know, such a large percentage of your users just

00:11:22.370 --> 00:11:25.320
because they only have this one positioning technology.

00:11:25.320 --> 00:11:27.120
So, it's important to look at your goals.

00:11:27.120 --> 00:11:28.140
What are you trying to achieve?

00:11:28.140 --> 00:11:30.040
What is the use case of your application?

00:11:30.040 --> 00:11:32.290
What types of positions can you work with?

00:11:32.290 --> 00:11:34.730
And, say, well on this platform what can I do?

00:11:34.730 --> 00:11:40.020
And as a, you know, try and design applications in
a way such if they're useable in the widest variety

00:11:40.020 --> 00:11:43.640
of circumstances as possible rather
than to say I must have GPS,

00:11:43.640 --> 00:11:48.660
I must have these technologies in
order to use location services.

00:11:48.660 --> 00:11:52.840
So those are the three position technologies.

00:11:52.840 --> 00:11:58.520
Now, we've had each of these three
technologies since version 2.0,

00:11:58.520 --> 00:12:03.040
but in the past year we've made some pretty
exciting enhancements in each of these areas,

00:12:03.040 --> 00:12:07.710
and I'd like to tell you about
them one-by-one, by technology,

00:12:07.710 --> 00:12:10.540
and I'll start by talking about cell positioning.

00:12:10.540 --> 00:12:17.170
As I described cell positioning earlier, we
know what cell tower you're on and then in order

00:12:17.170 --> 00:12:23.180
to get the position we have to go to a server that knows
the position of that cell tower in order to locate the user.

00:12:23.180 --> 00:12:26.730
That begs the question, what if the
user doesn't have a data connection?

00:12:26.730 --> 00:12:32.370
This becomes important if say I'm, you know, going
on a backpacking trip across Europe and, you know,

00:12:32.370 --> 00:12:36.410
I'm just taking a trip, I'm taking my iPhone from the US,

00:12:36.410 --> 00:12:39.070
but I don't want to pay roaming
charges so I just have data turned off.

00:12:39.070 --> 00:12:42.260
I don't have a data connection,
but I still like to use location.

00:12:42.260 --> 00:12:51.940
And this is especially relevant in the world of the 3G iPad
where devices, where we usually have devices that are camped

00:12:51.940 --> 00:12:57.090
on the 3G Network, but maybe they haven't signed
up for data plan so there's no data connection,

00:12:57.090 --> 00:13:01.550
but we still know what cell they're on so we
could use that information for positioning.

00:13:01.550 --> 00:13:07.680
Well, we took a look at the way carriers setup their
networks and it turns out that cells are actually setup

00:13:07.680 --> 00:13:15.980
in groups and in addition to a unique cell identifier,
there's also an identifier that groups cells in chunks

00:13:15.980 --> 00:13:20.090
that generally take, you know, between 30 and 50 kilometers.

00:13:20.090 --> 00:13:24.740
It's kind of analogous to an area code where you've
got three digits that generally identify an area

00:13:24.740 --> 00:13:29.430
and then the latter seven, which
give a number within that area.

00:13:29.430 --> 00:13:36.380
And because of that if we just have the position of that
group of cells, then we can provide an approximate position

00:13:36.380 --> 00:13:43.670
for the user just based on that, and it turns out
that because there's so many cells that are under one

00:13:43.670 --> 00:13:49.800
of these identifiers, one of these areas, we can
actually store the location of the most used,

00:13:49.800 --> 00:13:53.820
the most often accessed cells right on the device itself.

00:13:53.820 --> 00:13:56.550
No data connection necessary.

00:13:56.550 --> 00:14:04.390
So, in this case if you look at the screen here, this
is a screen shot of me testing this out at Apple Campus

00:14:04.390 --> 00:14:10.660
in Cupertino, I get a position that shows me that
I'm in the San Francisco Bay area, and you know,

00:14:10.660 --> 00:14:12.740
if I'm traveling around that's still valuable information.

00:14:12.740 --> 00:14:18.650
It still gives an approximate location for my GEO
tag photos and videos and for your applications,

00:14:18.650 --> 00:14:21.030
it can still allow you to get some
idea of where the user is.

00:14:21.030 --> 00:14:27.110
So, this is generally accurate to between 10
and 50 kilometers; it depends on the area.

00:14:27.110 --> 00:14:31.130
Now, the question is, what areas
do we pre-cache positions on?

00:14:31.130 --> 00:14:38.780
Well, we went and took the locations, I guess the
groups of cells that our users access most often,

00:14:38.780 --> 00:14:40.830
and lowered them on the device themselves.

00:14:40.830 --> 00:14:45.430
If you look here I don't have a data connection,
and yet I was still able to get a position.

00:14:45.430 --> 00:14:49.840
So, we cover a good chunk of the US, a
good chunk of Europe and parts of Asian.

00:14:49.840 --> 00:14:52.670
Again, these are the areas where
people are using iPhones most

00:14:52.670 --> 00:14:57.160
and so in these areas we can get a
position without a data connection.

00:14:57.160 --> 00:15:01.870
We think this really expands the
potential for applications to make sure

00:15:01.870 --> 00:15:07.810
of course location information in
a much wider variety of settings.

00:15:07.810 --> 00:15:09.230
So, let's cell.

00:15:09.230 --> 00:15:12.210
Next up is Wi-Fi.

00:15:12.210 --> 00:15:20.150
The big news with regards to Wi-Fi goes back to, again,
to the notion of going up to a server, to a database.

00:15:20.150 --> 00:15:24.950
Wi-Fi positioning really only works if
a server knows where you're located.

00:15:24.950 --> 00:15:30.700
If a server knows, you say I can see these access
points, you need to know where those access points are

00:15:30.700 --> 00:15:36.680
and so what we focused on in the past year is really
improving our sources of data for Wi-Fi positioning.

00:15:36.680 --> 00:15:43.340
Our goal was to improve coverage in the
areas where people use iOS devices most.

00:15:43.340 --> 00:15:53.250
So, just to give you an idea of this, this is a map of
our coverage under iPhone OS 3.1, and now with iPhone 3.2

00:15:53.250 --> 00:15:58.520
and iOS 4, you'll notice that we significantly
improved our coverage in the United States.

00:15:58.520 --> 00:16:02.210
We cover significantly more areas, much better coverage.

00:16:02.210 --> 00:16:10.460
If we go and take a look at Europe and Asia, that was our
coverage in iPhone OS 3.1, but in iPhone OS 3.2 and iOS 4,

00:16:10.460 --> 00:16:14.110
again, our coverage is significantly improved, and again,

00:16:14.110 --> 00:16:18.420
this comes back to expanding the
circumstances in which you can locate your user.

00:16:18.420 --> 00:16:25.340
The closer we get to making location ubiquitous and always
available service, the more circumstances you're going

00:16:25.340 --> 00:16:27.650
to be able to improve the experience for your users.

00:16:27.650 --> 00:16:30.330
That's really our goal.

00:16:30.330 --> 00:16:36.850
The other thing we've done with Wi-Fi positioning goes back
to, again, this case where you don't have a data connection.

00:16:36.850 --> 00:16:42.530
So we take a look at this map here, the
center of this map is the Moscone Center.

00:16:42.530 --> 00:16:49.260
So, let's say I'm here, I've got my iPod touch, I go and
get my position I want to see what coffee shops are around,

00:16:49.260 --> 00:16:54.030
that's great, but as soon as I leave the
Moscone Center, I lose my data connection

00:16:54.030 --> 00:16:57.460
and I lose the ability to lookup Wi-Fi hotspots.

00:16:57.460 --> 00:17:02.780
So, what we've done is we've said,
well, sure, we'll download the position

00:17:02.780 --> 00:17:08.380
of the Wi-Fi hotspot you're currently on, the ones
that you can see, but what's also down on the position

00:17:08.380 --> 00:17:12.000
of Wi-Fi hotspots in the radius
around your current position.

00:17:12.000 --> 00:17:17.540
And so in this case, I'm at the Moscone Center the
server will go and download the location of hundreds

00:17:17.540 --> 00:17:22.570
of Wi-Fi access points that cover a several
block radius around the convention center.

00:17:22.570 --> 00:17:26.980
So, if I'm going down the street, you
know, I'm going finding a place to eat,

00:17:26.980 --> 00:17:33.020
I'm going and checking out different places, my device will
solely be able to locate me because of that information

00:17:33.020 --> 00:17:38.570
that it downloaded at a time that I had a data
connection and this is a high-intensity environment.

00:17:38.570 --> 00:17:41.970
In San Francisco, there are a lot of Wi-Fi
access points because there's a lot of people.

00:17:41.970 --> 00:17:47.450
If you take a look at a lower density environment, this is
just inside of Halfmoon Bay; it's on the coast, nice place.

00:17:47.450 --> 00:17:50.000
I'd recommend visiting.

00:17:50.000 --> 00:17:57.460
Again, if you're in a coffee shop you get a position, then
we download Wi-Fi hotspots and they cover the entire area

00:17:57.460 --> 00:18:02.440
so no matter where I am I can get a
position without a data connection.

00:18:02.440 --> 00:18:04.270
It takes this device so you may think, well,

00:18:04.270 --> 00:18:09.760
it only has data in certain areas,
and it makes location more ubiquitous.

00:18:09.760 --> 00:18:14.530
Again, going back to this idea that
we want location to work all the time.

00:18:14.530 --> 00:18:17.490
That's Wi-Fi positioning.

00:18:17.490 --> 00:18:20.540
The last one is GPS.

00:18:20.540 --> 00:18:26.120
Now, the iPhone 3G and the iPhone
3GS both have GPS receivers.

00:18:26.120 --> 00:18:28.640
So, does the iPhone 4.

00:18:28.640 --> 00:18:33.180
What we're really excited about is that
the iPhone 4 includes a new GPS receiver

00:18:33.180 --> 00:18:37.720
that has significantly improved
performance in a variety of ways.

00:18:37.720 --> 00:18:41.070
Now, again, performance means multiple things.

00:18:41.070 --> 00:18:46.250
And so I'm going to focus on three ways that
the GPS receiver in iPhone 4 and, again,

00:18:46.250 --> 00:18:49.420
it's also included in the iPad as
well, I should make that clear,

00:18:49.420 --> 00:18:54.420
improves on the receiver, the iPhone 3G and the iPhone 3GS.

00:18:54.420 --> 00:19:01.920
The first one is what we call acquisition sensitivity,
and in plain terms, that means when you can get a GPS fix.

00:19:01.920 --> 00:19:08.350
Because the receiver is more sensitive, the GPS
receiver on iPhone 4 will get a fix in more places.

00:19:08.350 --> 00:19:14.890
In challenging environments like dense, urban
canyon environments, when you're say kind of indoors

00:19:14.890 --> 00:19:21.260
but maybe you can still see some satellite signals,
the GPS in the iPad and iPhone 4 get to position

00:19:21.260 --> 00:19:28.170
in a much wider variety of circumstances and
when it does get a position, it's more accurate.

00:19:28.170 --> 00:19:34.170
The error between where the user actually is and
the reported location is significantly smaller.

00:19:34.170 --> 00:19:44.500
So just to give you a relative idea of the differences in
positioning, I think this chart kind of tells the story.

00:19:44.500 --> 00:19:50.630
In our drive test, the receiver in iPhone
4 has been up to three times as accurate

00:19:50.630 --> 00:19:53.840
as receiver in the iPhone 3G and the iPhone 3GS.

00:19:53.840 --> 00:20:00.980
That means that the error is only one-third
of what it was with the old receiver.

00:20:00.980 --> 00:20:03.400
So that's a second way to compare performance,

00:20:03.400 --> 00:20:07.980
but the third way of comparing performance
goes back to something I talked about earlier.

00:20:07.980 --> 00:20:09.820
It goes back to power.

00:20:09.820 --> 00:20:14.620
You just want to use your location where application
but they're really conscious of battery life.

00:20:14.620 --> 00:20:19.180
It's something that we take, that
we do a lot of work to maintain.

00:20:19.180 --> 00:20:25.300
And so that's really exciting is that this
new receiver uses significantly less power.

00:20:25.300 --> 00:20:27.880
In a lot of cases, one-third of the power.

00:20:27.880 --> 00:20:32.550
And this chart here shows tower during
acquisition when it's trying to get a signal.

00:20:32.550 --> 00:20:35.970
In favorable signal environments
when you've got an open sky,

00:20:35.970 --> 00:20:39.910
the new receiver has a little power
mode where it uses even less power.

00:20:39.910 --> 00:20:46.930
Now, just as a cautionary note here less you think
that we've solved the problem of GPS power consumption,

00:20:46.930 --> 00:20:52.470
there's still a significant difference
between GPS power, Wi-Fi power and cell power.

00:20:52.470 --> 00:20:58.040
Cell is almost free, we just have to do the lookups;
Wi-Fi we pay a little bit more for the scans,

00:20:58.040 --> 00:21:01.410
but it's still relatively cheap;
GPS is still more expensive,

00:21:01.410 --> 00:21:08.340
but the receiver in iPhone 4 we think really improves
the user's experience by conserving battery life.

00:21:08.340 --> 00:21:13.850
The last thing that I want to talk about with
regards to improving GPS performance is sensors.

00:21:13.850 --> 00:21:20.810
As you heard about at the keynote on Monday, iPhone 4
includes a gyroscope and while the use case shown there was

00:21:20.810 --> 00:21:28.380
for games, it turns out that the gyroscope along with the
other sensors on the device, the accelerometer among others,

00:21:28.380 --> 00:21:33.860
is really useful for kind of cross checking
the information that we get from the GPS.

00:21:33.860 --> 00:21:39.850
So, I want to show you this plot from a recent drive test
we did in downtown San Francisco and it's important to keep

00:21:39.850 --> 00:21:41.820
in mind this is a really challenging environment.

00:21:41.820 --> 00:21:46.400
You've got high density, you've got buildings,
you've got multi-path interference, you know,

00:21:46.400 --> 00:21:52.420
from signals arriving kind of, you know,
bouncing off buildings and so forth.

00:21:52.420 --> 00:21:56.130
So this is a challenging environment
for GPS, but it does pretty well.

00:21:56.130 --> 00:21:59.440
It has us on the road, it detects the turn.

00:21:59.440 --> 00:22:03.580
One of the things to note about this diagram is the
direction of the arrows is the course information.

00:22:03.580 --> 00:22:08.110
It's the direction of the GPS thought
that the user was heading,

00:22:08.110 --> 00:22:12.540
but by making use of sensor assistance,
we're able to correct the position.

00:22:12.540 --> 00:22:18.300
You'll notice that the new position stays on the road
better, but it also detects the turn a lot better as well.

00:22:18.300 --> 00:22:23.920
It can detect, you know, as a turn is occurring, and it
comes out of the turn with better positioning as well.

00:22:23.920 --> 00:22:29.200
A couple of notes about this; there is
an additional cost associated with this.

00:22:29.200 --> 00:22:35.150
We need to have those sensors running, we need to run
the algorithms that take the sensor information and,

00:22:35.150 --> 00:22:37.430
you know, correlate it with the GPS to improve it.

00:22:37.430 --> 00:22:38.570
So, there is an additional cost.

00:22:38.570 --> 00:22:43.150
It doesn't come for free, and as a
result, it isn't enabled by default.

00:22:43.150 --> 00:22:47.820
We think it's useful primarily for the
vehicular navigation cases where, you know,

00:22:47.820 --> 00:22:50.980
you've got high speeds, you know, driving is a good example.

00:22:50.980 --> 00:22:53.890
I'll show you how you can enable
this in your application later,

00:22:53.890 --> 00:22:57.180
but it's another way that we're making GPS more powerful.

00:22:57.180 --> 00:23:02.180
So, those are our three technologies
and that's how we've improved

00:23:02.180 --> 00:23:04.920
in the past year, and we're really excited about this.

00:23:04.920 --> 00:23:12.310
We think that it just opens up a lot more potentials
where location is a possibility where it wasn't before.

00:23:12.310 --> 00:23:15.790
So, enough with, you know, the
high level, how do you use it?

00:23:15.790 --> 00:23:18.250
How do you make your application location-aware?

00:23:18.250 --> 00:23:24.700
So, a few things I'm going to talk about I'm going to talk
about the primary components of our framework, the pieces;

00:23:24.700 --> 00:23:30.430
how they fit together to request and receive
location updates; how to configure location manager

00:23:30.430 --> 00:23:35.600
to tell it what type of location you need, what
accuracy, things like that; how to handle errors;

00:23:35.600 --> 00:23:42.920
how the user gives it permission in order to use location;
and some best practices for using location services on iOS.

00:23:42.920 --> 00:23:44.840
So, as for the components, it's pretty simple.

00:23:44.840 --> 00:23:49.880
There's, you know, on the base level there's your
application, which you're going to have some delegate object

00:23:49.880 --> 00:23:56.070
that interacts with the framework, and you've got the
framework itself and inside the framework the main object

00:23:56.070 --> 00:24:01.020
that you use to request location
services is the CLLocationManager object.

00:24:01.020 --> 00:24:04.730
You'll create one of those, you'll set
your delegate object at its delegate,

00:24:04.730 --> 00:24:09.590
your delegate needs to implement the
CLLocationManagerDelegate protocol and then in response,

00:24:09.590 --> 00:24:14.670
the location framework will send what are called CLLocation
objects, either data objects that give information

00:24:14.670 --> 00:24:18.100
with the location back to your delegate and callbacks.

00:24:18.100 --> 00:24:23.320
So, the first thing you do is you create
a CLLocationManager, you set a delegate

00:24:23.320 --> 00:24:26.120
and then you call the startUpdatingLocation method on it.

00:24:26.120 --> 00:24:32.340
This doesn't take any parameters, it doesn't return
anything, it just says I would like location updates.

00:24:32.340 --> 00:24:33.710
Updates are fully asynchronous.

00:24:33.710 --> 00:24:39.050
It's an asynchronous API and so when the framework
has a location and it's determined the position,

00:24:39.050 --> 00:24:43.850
it will call the
locationManager:didUpdateToLocation:fromLocation:

00:24:43.850 --> 00:24:45.580
delegate callback.

00:24:45.580 --> 00:24:52.050
It will call back each time a position comes in and so
you'll get these callbacks repeatedly as the user moves,

00:24:52.050 --> 00:24:55.420
as the framework determines more accurate positions.

00:24:55.420 --> 00:24:59.240
Now, the location manager is configurable.

00:24:59.240 --> 00:25:03.380
There are a couple of different ways that you can
tell it more about your use case about what type

00:25:03.380 --> 00:25:09.280
of accuracy you desire and so the
first thing is the accuracy.

00:25:09.280 --> 00:25:12.710
It's what is, kind of how precise a position do you need?

00:25:12.710 --> 00:25:19.340
And this is measured in the estimated, the difference
between where the user actually is and the position

00:25:19.340 --> 00:25:21.590
that you receive that you're willing to accept.

00:25:21.590 --> 00:25:24.160
So, this is in meters.

00:25:24.160 --> 00:25:29.060
The default is best accuracy, but there
are also constants for ten meters,

00:25:29.060 --> 00:25:32.540
hundred meters, kilometer accuracy and things like that.

00:25:32.540 --> 00:25:39.100
There's also a special constant that says best and then
also enable sensor assistance as I talked about earlier.

00:25:39.100 --> 00:25:44.470
It's important to set this to a value that
makes sense for your use case because, again,

00:25:44.470 --> 00:25:49.240
if you say you want the best accuracy position
possible then the framework is going to go

00:25:49.240 --> 00:25:54.460
and turn on ever positioning service it has available and,
again, so you're paying the cost for all of those services.

00:25:54.460 --> 00:25:59.540
So, if your application can really get a good position
with Wi-Fi positioning, then set it to say, you know,

00:25:59.540 --> 00:26:03.870
a hundred meters if that's the accuracy that you need.

00:26:03.870 --> 00:26:08.240
The second thing that you can provide
is a distance filter and this is useful

00:26:08.240 --> 00:26:12.120
for applications that want to know when the user moves.

00:26:12.120 --> 00:26:14.180
Maybe you don't need to know, you know, right away,

00:26:14.180 --> 00:26:18.350
you don't need to get a callback
every time they move a little bit.

00:26:18.350 --> 00:26:24.350
If you're just kind of keeping those callbacks and that's
a waste of CPU time, it's a waste of system resources

00:26:24.350 --> 00:26:29.220
and so by specifying distance filter you can say, well,
only tell me once the user's moved a hundred meters

00:26:29.220 --> 00:26:33.150
or only tell me once the user has moved 500 meters.

00:26:33.150 --> 00:26:39.640
One thing about the distance filter though is that let's
say we have a 500-meter accuracy position and then all

00:26:39.640 --> 00:26:44.710
of a sudden we get a 100-meter accuracy position,
the framework will tell your delegate object

00:26:44.710 --> 00:26:49.780
about that new location even if the distance filter
has been met, even if you haven't moved that far.

00:26:49.780 --> 00:26:55.650
That allows your application to make sure of the better
location information even if you have a distance filter set.

00:26:55.650 --> 00:27:00.540
So, you can set this and still be confident that
you will get the best positioning information

00:27:00.540 --> 00:27:03.060
that the location manager has determined.

00:27:03.060 --> 00:27:04.850
One other note is that you may want to check to see

00:27:04.850 --> 00:27:10.360
if location services are enabled prior
to calling startUpdatingLocation.

00:27:10.360 --> 00:27:14.820
I'll talk a little bit more about that later.

00:27:14.820 --> 00:27:19.660
Now, Core Location would always be able to determine
your position and there are two main errors,

00:27:19.660 --> 00:27:22.480
there are other errors as well,
but these are the two big ones.

00:27:22.480 --> 00:27:25.790
The first one is Location Unknown,
and very simply this just means

00:27:25.790 --> 00:27:30.750
that the framework couldn't determine
your position at that time.

00:27:30.750 --> 00:27:36.930
I'll talk a little bit more later about how to handle
this, but in brief you should call stopUpdatingLocation

00:27:36.930 --> 00:27:41.210
in response to this error because if you don't, the
framework will just keep spinning and spinning and spinning,

00:27:41.210 --> 00:27:46.730
trying to get a position, but if the user's environment
hasn't changed, you know, things are unlikely to, you know,

00:27:46.730 --> 00:27:50.210
to suddenly change and it'll suddenly be able to locate you.

00:27:50.210 --> 00:27:54.050
The other one which I'm going to talk more
about on the next slide is CLError Denied,

00:27:54.050 --> 00:28:01.250
and this means that the user is denied location
services authorization for your application.

00:28:01.250 --> 00:28:04.620
So in what circumstances does that happen?

00:28:04.620 --> 00:28:11.170
Well, the first time that you call startUpdatingLocation,
the system will pop up a dialog that says

00:28:11.170 --> 00:28:19.040
that your application wants to use the user's
location and these are two choices, OK or don't allow.

00:28:19.040 --> 00:28:25.150
As of iOS 4, this dialog will only appear once, the
user has to make a decision, and the decision sticks.

00:28:25.150 --> 00:28:27.540
Yes means yes; no means no.

00:28:27.540 --> 00:28:30.280
So, as long as they get to the dialog once,

00:28:30.280 --> 00:28:35.470
they won't be prompted again unless they,
unless they reset location warnings.

00:28:35.470 --> 00:28:38.680
So, one thing to note is this purpose property.

00:28:38.680 --> 00:28:39.930
So this is new.

00:28:39.930 --> 00:28:44.450
This allows you to tell the user why
your app needs to use location services.

00:28:44.450 --> 00:28:51.330
You may notice that the camera, for example, uses this to
tell users that it wants to GEO tag their photos and videos.

00:28:51.330 --> 00:28:56.810
That's something really useful, but it's not something that
I would think of the first time I'm opening the camera app.

00:28:56.810 --> 00:29:02.760
So, if your use of location is maybe not intuitive, it's
not something that the users would think of right away,

00:29:02.760 --> 00:29:06.790
this is especially important, but we
think that all applications can benefit

00:29:06.790 --> 00:29:09.410
from providing this information to the user.

00:29:09.410 --> 00:29:12.330
This is a property that you set on CLLocationManager.

00:29:12.330 --> 00:29:15.030
And the last thing is the status bar icon.

00:29:15.030 --> 00:29:21.020
This icon will show up whenever any application on the
system is using location services as the user's indication

00:29:21.020 --> 00:29:30.260
that their location is in use, but the user has to make that
initial decision, but they can change their mind as well.

00:29:30.260 --> 00:29:34.560
So, the location services enable
switch has always been available.

00:29:34.560 --> 00:29:42.990
It's allowed the user to say I don't want any applications
to use my location or, yes, enable location services,

00:29:42.990 --> 00:29:49.290
but in iOS 4 we've added the capability for
the user to indicate on an app-by-app basis

00:29:49.290 --> 00:29:56.780
which applications should be authorized to use location
services both in the initial pop up but also after the fact.

00:29:56.780 --> 00:30:02.790
One thing to note is that the location arrow, the
same one that would normally appear on the status bar,

00:30:02.790 --> 00:30:08.630
will show up next to any app that has requested the
user's location in the past 24 hours and it's designed

00:30:08.630 --> 00:30:13.510
to give user indication of what applications
have used their location recently.

00:30:13.510 --> 00:30:19.130
And then the last thing is the location
services enabled switch for that application.

00:30:19.130 --> 00:30:26.260
One thing to note in a multi-tasking world is that if the
user flips that switch to Off while your app is running,

00:30:26.260 --> 00:30:30.090
you will get the CLError denied
error from the location manager even

00:30:30.090 --> 00:30:32.380
if you had previously had been getting positions.

00:30:32.380 --> 00:30:36.810
So, as soon as that switch goes, your
app basically gets cut off from location

00:30:36.810 --> 00:30:40.040
and that sticks until the user changes their mind.

00:30:40.040 --> 00:30:44.310
A couple of best practices.

00:30:44.310 --> 00:30:49.890
Going back to what happens if you get that
unknown error, Core Location couldn't locate you.

00:30:49.890 --> 00:30:56.780
You really should call stopUpdatingLocation
in response to that error.

00:30:56.780 --> 00:31:02.760
If the user is in a subway tunnel they're, you know,
underground somewhere, they're in a parking lot

00:31:02.760 --> 00:31:08.530
in an underground parking garage, they're in an environment
where the situations aren't likely to change immediately

00:31:08.530 --> 00:31:15.890
and so the, I guess the return for
continuing to get location services isn't

00:31:15.890 --> 00:31:18.350
that great in comparison to the power cost.

00:31:18.350 --> 00:31:21.240
So, what we recommend is the call
stopUpdatingLocation and set a timer

00:31:21.240 --> 00:31:23.950
for some amount of time out, and try again later.

00:31:23.950 --> 00:31:27.810
At that point maybe the user's environment will
have changed, conditions will have improved,

00:31:27.810 --> 00:31:29.930
and will be able to determine their location.

00:31:29.930 --> 00:31:35.690
And a similar thing goes if your app really
wants a certain accuracy of position.

00:31:35.690 --> 00:31:42.340
If you really want, you know, 50-meter accurate position,
but all you're getting is 500-meter accurate position,

00:31:42.340 --> 00:31:45.930
you know, after a certain amount of time, after
a minute or so, something like that, you know,

00:31:45.930 --> 00:31:52.520
it's unlikely that in this current environment that
that precision of location information is available

00:31:52.520 --> 00:31:54.680
and so you should stop and, again, try again later.

00:31:54.680 --> 00:31:58.680
Make use of the information that's
available and then try again at a later time.

00:31:58.680 --> 00:32:03.920
And then one last note is to consider using MapKit.

00:32:03.920 --> 00:32:07.430
MapKit is a framework that makes it really
easy to integrate maps into your application.

00:32:07.430 --> 00:32:14.000
With only a few lines of code, you can
also make your map location aware just

00:32:14.000 --> 00:32:17.550
by setting one property it shows user location property.

00:32:17.550 --> 00:32:21.490
MapKit will take care of using CLLocation, Core Location,

00:32:21.490 --> 00:32:25.330
under the hood to determine the user's
location and display on the map.

00:32:25.330 --> 00:32:30.720
It's customizable; you can use Key-Value
Observing to get the location that's determined.

00:32:30.720 --> 00:32:35.500
So, if this is an option to your
app, it makes things a lot simpler.

00:32:35.500 --> 00:32:41.090
So that's the third thing that's how
to use location services on iPhone OS.

00:32:41.090 --> 00:32:42.270
Moving forward.

00:32:42.270 --> 00:32:48.290
We made some really great enhancements to location
services, but what I've talked about so far are things

00:32:48.290 --> 00:32:55.270
that were available on previous versions of iPhone
OS, but with iOS 4, we've really stepped it up.

00:32:55.270 --> 00:33:01.930
In a multi-tasking world, we want to move closer and closer
to this idea of always on location, of ubiquitous location.

00:33:01.930 --> 00:33:08.160
Applications that are location aware all the
time that users can be confident that, you know,

00:33:08.160 --> 00:33:13.780
no matter what they're doing that your application
is working, that it's providing the service

00:33:13.780 --> 00:33:20.210
that you've advertised for them and so I'm going to
walk through a few use cases where the enhancements

00:33:20.210 --> 00:33:25.450
that we've made in iOS 4 really open up new possibilities.

00:33:25.450 --> 00:33:27.060
So the first one is running.

00:33:27.060 --> 00:33:33.090
So, I'm a runner, I'm training for the San Francisco
Marathon next month although, you know, the iOS,

00:33:33.090 --> 00:33:38.090
the push to end of iOS really didn't help
my training, but I'm still hoping to do it,

00:33:38.090 --> 00:33:42.540
and I like to use my iPhone to track my runs.

00:33:42.540 --> 00:33:49.130
I want to, you know, it runs on GPS and as a result it knows
kind of how fast I was going, different points of the race,

00:33:49.130 --> 00:33:54.270
how far I traveled, things like that, but
say I get a quick phone call while running,

00:33:54.270 --> 00:33:58.860
hopefully not too long because I'm kind of out of breath
or, you know, I quickly switch over to another application,

00:33:58.860 --> 00:34:03.340
I really want my app to keep updating my location.

00:34:03.340 --> 00:34:10.890
With previous versions of the OS, the application
stops as soon as you exit it and location stops,

00:34:10.890 --> 00:34:16.470
but what I really want is I want the position
to continue updating no matter what I'm doing.

00:34:16.470 --> 00:34:22.550
My desire is to have the same experience with this
application whether it's foreground or background.

00:34:22.550 --> 00:34:27.300
So, we've added in support for what we
call continuous location applications.

00:34:27.300 --> 00:34:33.110
Applications like RunMonster here that
they really want to provide the user that same level

00:34:33.110 --> 00:34:39.410
of location experience regardless of their
state and using this is really straightforward.

00:34:39.410 --> 00:34:44.890
You just have to add this one key to your application's
info P list, it's a configuration file that you set,

00:34:44.890 --> 00:34:52.040
by adding the user's location background mode once that's
set, if your application is using location services,

00:34:52.040 --> 00:34:57.420
if you've called startUpdatingLocation and then your
app goes into the background, it will continue to run

00:34:57.420 --> 00:35:00.820
in the background as long as you're
still requesting location updates.

00:35:00.820 --> 00:35:05.080
So that means that you can still continue to track them.

00:35:05.080 --> 00:35:09.860
Now, we recommend that you, again, even if you're in
the background say you're doing a turn-by-turn nav app,

00:35:09.860 --> 00:35:14.470
something like that, they reached their destination,
turn off location services, you know, it's done.

00:35:14.470 --> 00:35:19.170
It's still expensive so, you know,
again keep the user's use case in mind,

00:35:19.170 --> 00:35:24.840
but for situations where the runner still wants this
information, the user really wants that information,

00:35:24.840 --> 00:35:32.240
you know, regardless of where they are in the system, this
is a great solution that enables these types of applications

00:35:32.240 --> 00:35:36.910
and it requires very little work on the developer's part.

00:35:36.910 --> 00:35:45.450
However, there are some situations in which I don't, you
know, I don't want to incur the cost of having, you know,

00:35:45.450 --> 00:35:51.590
high precision location services like GPS all the time,
but it would be really great if my applications knew kind

00:35:51.590 --> 00:35:54.850
of approximately where I was at any given point in time.

00:35:54.850 --> 00:36:00.430
So, let's say, again I'm going on a trip, I have an app
that say allows me to, you know, write entries, you know,

00:36:00.430 --> 00:36:06.580
annotate where I was, you know, I want to write an entry
that I was at the Golden Gate Bridge, I was at, you know,

00:36:06.580 --> 00:36:09.080
the Museum of Modern Art, and here's what I thought.

00:36:09.080 --> 00:36:14.860
Well, it would be really great if my application knew
where I was throughout the day and said, oh, yeah,

00:36:14.860 --> 00:36:18.830
you were about at the Golden Gate Bridge,
you were about there, and put those together

00:36:18.830 --> 00:36:25.140
and maybe reverse GEO code them for me so, you know,
it gives information, and I can annotate those.

00:36:25.140 --> 00:36:31.780
Well, if that app has to use GPS, then my battery isn't
going to last the day, but if we could use things,

00:36:31.780 --> 00:36:38.490
say cell positioning and detect when the user has moved
a relatively significant distance in order to, you know,

00:36:38.490 --> 00:36:44.260
and then kind of track their locations at that
point in time, that's a much lower cost solution.

00:36:44.260 --> 00:36:51.400
It's one that then, you know, more
adequately balances power versus utility.

00:36:51.400 --> 00:36:59.160
So, the way this works is the significant location change
API and it detects when a device changes cell towers.

00:36:59.160 --> 00:37:02.850
And so whenever the device changes cell
towers, the framework goes and says,

00:37:02.850 --> 00:37:06.490
well, has user moved a significant distance?

00:37:06.490 --> 00:37:13.250
And if it has, it notifies your application
of the new location in the background.

00:37:13.250 --> 00:37:17.930
So, even if it's not frontmost, even if it's suspended,
it will wake up your applications so they can deal

00:37:17.930 --> 00:37:23.990
with this new information and take whatever
action it needs to in response to it.

00:37:23.990 --> 00:37:31.430
So, again, this uses cell positioning so you should
expect location precision in accordance with that.

00:37:31.430 --> 00:37:36.230
So, again, it will tend to be better in urban areas
and more error in rural areas where the distance

00:37:36.230 --> 00:37:41.110
between cell towers is greater, but in general, you know,

00:37:41.110 --> 00:37:45.670
intermediary is 500 to 1,000 meters
would be something reasonable to expect.

00:37:45.670 --> 00:37:51.090
One other nice thing with significant location change is
that if another application in the system is using location,

00:37:51.090 --> 00:37:55.630
so say they have a turn-by-turn nav app open
and a more accurate position is available,

00:37:55.630 --> 00:37:59.930
your application will get that
application for free in a sense.

00:37:59.930 --> 00:38:06.870
You move, every 500 meters that the users
move we track based on GPS they move that far,

00:38:06.870 --> 00:38:09.060
your application will get woken up as a result of that.

00:38:09.060 --> 00:38:12.120
So, it makes use of the best information
available in the system,

00:38:12.120 --> 00:38:17.130
but if no location where applications are
running, it will use cell positioning.

00:38:17.130 --> 00:38:20.920
Now, we've created a demo app that makes use
of this functionality, and I'd like to turn it

00:38:20.920 --> 00:38:23.210
over to my colleague, Jay Bruins, to give you a demo of it.

00:38:23.210 --> 00:38:24.510
Jay?

00:38:24.510 --> 00:38:28.400
[Applause]

00:38:28.400 --> 00:38:30.130
>> Jay Bruins: Thanks, Morgan.

00:38:30.130 --> 00:38:33.860
So, I often wonder when a song comes on
the radio or something like that, hey,

00:38:33.860 --> 00:38:35.740
where was the last time I heard that song?

00:38:35.740 --> 00:38:43.490
And so I wrote a simple app using iOS 4 and it's a location
change API to basically record my location and when I do it,

00:38:43.490 --> 00:38:48.110
just go ahead and also record what actual
media is playing on my phone at the time.

00:38:48.110 --> 00:38:50.180
So, as a result, I can actually travel through the world

00:38:50.180 --> 00:38:53.760
and kind of get an idea for, you
know, what I was listening to where.

00:38:53.760 --> 00:38:56.710
So, it's relatively straightforward app.

00:38:56.710 --> 00:39:00.640
I'll start up here in the flip-side view, and you
see that the user has an option to turn on location.

00:39:00.640 --> 00:39:02.000
Turn on location.

00:39:02.000 --> 00:39:07.500
As soon as that happens, you'll go ahead and get the
notification with the purpose string explaining that, hey,

00:39:07.500 --> 00:39:13.080
this is going to stay on in the background, I'm going
to keep track of you basically until you turn me off.

00:39:13.080 --> 00:39:18.020
So, the user hopefully hits OK because I've
given them a clear expectation for what I'm doing

00:39:18.020 --> 00:39:22.170
and then they can go back into the map view.

00:39:22.170 --> 00:39:28.550
And so here you'll see that I've got a simulated trip going
down 280 and back down to Apple Campus from San Francisco,

00:39:28.550 --> 00:39:36.480
and you can get an idea of kind of the couple of positions
of pins that you would get and so each one of these,

00:39:36.480 --> 00:39:42.610
you know, is hitting, it's simulated so it's right
now, but you get access to the whole location stuff,

00:39:42.610 --> 00:39:47.530
it's standard callback, but it's a
little bit coarser than, you know,

00:39:47.530 --> 00:39:50.570
you might be used to, but it's really simple to wire up.

00:39:50.570 --> 00:39:55.910
I carried this demo application around in my phone for a
week and didn't really notice any drain on battery life.

00:39:55.910 --> 00:39:59.510
It was really simple to do and it was a great experience so.

00:39:59.510 --> 00:40:04.250
[ Applause ]

00:40:04.250 --> 00:40:04.860
>> Morgan Grainger: All right.

00:40:04.860 --> 00:40:07.920
So how do you integrate this into your application?

00:40:07.920 --> 00:40:09.810
This slide probably looks familiar.

00:40:09.810 --> 00:40:13.350
It's a slide I put up when I talked about
how to use regular location services.

00:40:13.350 --> 00:40:19.280
At a basic level, all you have to do is
replace this call to start updating location

00:40:19.280 --> 00:40:23.170
with one that's called
startMonitoringSignificantLocationChanges.

00:40:23.170 --> 00:40:29.240
That indicates to the framework that you want to use the
significant location change service, and then as a result,

00:40:29.240 --> 00:40:34.440
after you call that, you'll get the same location
manager didUpdateToLocation:fromLocation:

00:40:34.440 --> 00:40:39.820
callback whenever one of these significant change
events occurs and that's true whether the application is

00:40:39.820 --> 00:40:43.480
in the foreground, whether it's in the
background, if it's displayed in the background,

00:40:43.480 --> 00:40:46.880
it will be resumed in order to handle the notification.

00:40:46.880 --> 00:40:53.040
And so just by making this one change, your
application can take advantage of this API.

00:40:53.040 --> 00:40:57.280
We'll be posting sample code for both this
demo and the one that's coming up later today

00:40:57.280 --> 00:41:00.070
so you can take a look at this for yourself.

00:41:00.070 --> 00:41:01.460
It's only a few lines.

00:41:01.460 --> 00:41:08.540
Let's say I have an application where I'm really
only interested in, you know, certain locations.

00:41:08.540 --> 00:41:13.670
It's great if I know every time a user moved,
but in most cases there's only one spot that,

00:41:13.670 --> 00:41:17.020
only a few spots that are really
important to my application.

00:41:17.020 --> 00:41:21.440
So, just to give you a scenario, if I've got something
at the dry cleaners I need to go and pick it up, well,

00:41:21.440 --> 00:41:25.540
I'm kind of forgetful, I've got full days, and
I just keep forgetting to go and pick it up.

00:41:25.540 --> 00:41:32.780
It would be ideal if I had an application that could tell
me, hey, you're close to the dry cleaners, pickup your suit.

00:41:32.780 --> 00:41:39.930
Now, if I were to use the significant location change
service, then my application would have to, you know,

00:41:39.930 --> 00:41:42.110
get every position and say, all right, how far away is he?

00:41:42.110 --> 00:41:42.840
How far away is he?

00:41:42.840 --> 00:41:43.370
Is he close?

00:41:43.370 --> 00:41:44.150
Should I notify?

00:41:44.150 --> 00:41:46.800
When am I going to get another notification?

00:41:46.800 --> 00:41:50.990
But it would be really nice if there's a way to
just say, all right, I'm interested in this position

00:41:50.990 --> 00:41:57.400
with say this radius around and when the user gets
close, notify my application so I can take advantage

00:41:57.400 --> 00:42:01.130
of that information, take whatever action I need to do.

00:42:01.130 --> 00:42:05.080
What we have done to enable this sort of
application is to create a new service

00:42:05.080 --> 00:42:09.770
that we call the region monitoring service, and the
way that it works is it works in a very similar way

00:42:09.770 --> 00:42:16.180
to significant location change, you know, we still detect
when we change cell towers, but when we get on a cell tower

00:42:16.180 --> 00:42:20.730
that we know is close to something that you're
interested in, in this case a coffee house,

00:42:20.730 --> 00:42:24.020
we then notify you in that case and only in that case.

00:42:24.020 --> 00:42:28.850
Not whenever we switch cell towers, not
whenever you just move a specific distance,

00:42:28.850 --> 00:42:33.940
we'll notify you only when the user is close
to locations that your application cares about.

00:42:33.940 --> 00:42:38.030
So, you get notifications both on entry and exit.

00:42:38.030 --> 00:42:44.730
Again, it's based on cell positioning so expect that
sort of accuracy and one other thing that's important

00:42:44.730 --> 00:42:52.560
about this API is that it takes advantage of some new
functionality in the baseband software of IPhone 4

00:42:52.560 --> 00:42:57.800
so this is currently an iPhone 4 only feature,
but for users that have that hardware we think

00:42:57.800 --> 00:43:06.600
that this makes it really easy for your application to
get, to kind of focus in on the areas that are important

00:43:06.600 --> 00:43:09.080
to it rather than kind of getting woken up constantly.

00:43:09.080 --> 00:43:14.610
You only get notified when you get close
to a region that is important to your app.

00:43:14.610 --> 00:43:19.470
So, we built a second application that, again, takes
advantage of this functionality and, Jay, take it away.

00:43:19.470 --> 00:43:21.510
>> Jay Bruins: Thanks, Morgan.

00:43:21.510 --> 00:43:24.300
[ Applause ]

00:43:24.300 --> 00:43:27.160
>> Jay Bruins: So, I wrote a quick
app called the Reminders app

00:43:27.160 --> 00:43:29.890
that will basically help remind me
to do things based on my position.

00:43:29.890 --> 00:43:34.900
So, for example, let's say last night I got a little
crazy and my shirt got dirty and I dropped it off

00:43:34.900 --> 00:43:37.410
at the dry cleaners, but I want to remember that, you know,

00:43:37.410 --> 00:43:40.730
when I'm on my way out of the city that,
hey, I should probably go pick this up.

00:43:40.730 --> 00:43:45.090
So, what I can do is I can drop a pin that gives
me an opportunity to create a new reminder,

00:43:45.090 --> 00:43:50.930
I go ahead and open it up, and go ahead and
say, you know, something like pickup my shirt.

00:43:55.110 --> 00:44:01.510
And so what that allowed me to do is when I enter or exit
a region around this pin, it'll give me a notification.

00:44:01.510 --> 00:44:04.910
So, let me go ahead and leverage the fact that
when I exit it, I'm going to go ahead and do it

00:44:04.910 --> 00:44:09.790
and I'll just change the radius of the pin to something
relatively large because I don't really care if I'm hanging

00:44:09.790 --> 00:44:13.370
out tonight, but once I actually
go to leave the city, I will care.

00:44:13.370 --> 00:44:17.960
So, now I've got a relatively large pin, I've got
a relatively large, sorry, relatively large area,

00:44:17.960 --> 00:44:22.900
I can move it around to some other
place if I want to be more specific

00:44:22.900 --> 00:44:25.520
and as a result it just writes it out to Core Location.

00:44:25.520 --> 00:44:28.880
If you tell Core Location about this,
the app can quit, you can spin it up

00:44:28.880 --> 00:44:33.060
and you can actually query Core Location to get
all of the locations back and you can associate it

00:44:33.060 --> 00:44:35.420
with your own app data and start displaying stuff again.

00:44:35.420 --> 00:44:39.990
It was really easy to do, and it just,
you know, takes advantage of this.

00:44:39.990 --> 00:44:40.110
So.

00:44:40.110 --> 00:44:41.000
>> Morgan Grainger: All right.

00:44:41.000 --> 00:44:42.410
Thanks, Jay.

00:44:42.410 --> 00:44:43.510
So again.

00:44:43.510 --> 00:44:46.210
[ Applause ]

00:44:46.210 --> 00:44:51.140
As Jay mentioned, most of the code involved in
building this app was to get the stuff around it.

00:44:51.140 --> 00:44:55.400
The actual code that coordinates with the
location service is surprisingly simple.

00:44:55.400 --> 00:45:00.020
So, the first thing you need to do is to
create what's called a CLRegion object.

00:45:00.020 --> 00:45:08.290
A region is defined by three things: by a center, by kind
of a center point; by a radius, which is kind of a distance

00:45:08.290 --> 00:45:15.400
around that center which you kind of want the boundary to
be; and then an identifier so you can refer to it later.

00:45:15.400 --> 00:45:22.680
And once you've created the CLRegion object, then you call
startMonitoringForRegion on your CLLocationManager while,

00:45:22.680 --> 00:45:29.180
in fact, you're passing that region and then when the
location service detects that that region has been entered

00:45:29.180 --> 00:45:34.030
or exited, it calls the appropriate callback
on your delegate object to deliver that event.

00:45:34.030 --> 00:45:38.390
Again, this happens even if your app is in the
background, even if it's spinning it will be resumed,

00:45:38.390 --> 00:45:43.670
and you can take whatever action you would
like to in response to that notification.

00:45:44.680 --> 00:45:49.710
Now one other thing that's really advantageous
about these two new service both of them is

00:45:49.710 --> 00:45:54.090
that they will actually launch your
application if it isn't running.

00:45:54.090 --> 00:45:58.190
So, if your application got killed say because
of memory pressure or the device restarted

00:45:58.190 --> 00:46:03.500
and the user hasn't run your application
yet, then if one of these events comes in,

00:46:03.500 --> 00:46:06.140
the location service will actually launch your application

00:46:06.140 --> 00:46:10.380
and to explain this I think it's
helpful to take a larger system view.

00:46:10.380 --> 00:46:16.290
So far I've been talking about the Core Location framework,
but in reality the framework is actually communicating

00:46:16.290 --> 00:46:21.720
with the service that runs outside your
application's address space in its own process.

00:46:21.720 --> 00:46:27.290
And so that even if your app goes away, that location
service is still running, it's still tracking location

00:46:27.290 --> 00:46:31.260
and can still locate the user and
determine when events happened.

00:46:31.260 --> 00:46:36.690
Now when an event does come in, so let's say you're using
significant location change and it determines a location,

00:46:36.690 --> 00:46:40.110
the location service will tell it, will ask
the system to relaunch your application

00:46:40.110 --> 00:46:43.490
in the background in order to respond to the event.

00:46:43.490 --> 00:46:48.350
Well, there's still one piece missing.

00:46:48.350 --> 00:46:53.470
In order to deliver the event, your
application needs to create a CLLocationManager

00:46:53.470 --> 00:46:58.230
that the location service can communicate with
to deliver that event to your application.

00:46:58.230 --> 00:47:02.360
So, when launched in the background your application
needs to make sure the location manager gets created

00:47:02.360 --> 00:47:05.730
and then once that's done the location service
can pass the location off to the framework

00:47:05.730 --> 00:47:12.410
to the location manager object which
can then pass it to your delegate.

00:47:12.410 --> 00:47:17.620
Now, because your application is getting launched in the
background, it's worthwhile to go back and talk a little bit

00:47:17.620 --> 00:47:22.360
about the model view controller paradigm
on which iPhone OS applications are based.

00:47:22.360 --> 00:47:26.440
Generally you've got, you know, your model,
which is your data store, you've got your view,

00:47:26.440 --> 00:47:31.010
which is how it's displayed onscreen, and you've got
your controller, which kind of works between the two.

00:47:31.010 --> 00:47:36.470
It takes data from the model and displays in the view,
responds to events in the view, things like that.

00:47:36.470 --> 00:47:43.170
Now, what we've seen in a lot of applications is that the
location manager is actually a part of the view controller.

00:47:43.170 --> 00:47:47.690
Maybe the view controller is a delegate or you've got
some object that's hanging off the view controller,

00:47:47.690 --> 00:47:51.880
but when the application is launched in
the background because it's not onscreen,

00:47:51.880 --> 00:47:57.640
the view hierarchy doesn't get setup and so if you
create a location manager as part of your view hierarchy,

00:47:57.640 --> 00:48:02.060
as a part of a view controller, it's never
going to get created and as a result,

00:48:02.060 --> 00:48:04.330
you're never going to get that location event.

00:48:04.330 --> 00:48:07.630
So, you really need to make sure that in
case, in this background launching case,

00:48:07.630 --> 00:48:12.670
that you create a CLLocationManager location manager
and you configure it so it can receive the events.

00:48:12.670 --> 00:48:13.700
So how does this work?

00:48:13.700 --> 00:48:17.670
One of the first things that happens
after an application finishes launching is

00:48:17.670 --> 00:48:22.900
that the app delegate object gets the application
didFinishLaunchingWithOptions callback.

00:48:22.900 --> 00:48:24.180
Very appropriate.

00:48:24.180 --> 00:48:33.000
And one of the things that's passed as a part of that method
call is a dictionary called launch options and in the case

00:48:33.000 --> 00:48:36.690
where your application was launched
because of a location event,

00:48:36.690 --> 00:48:41.170
the system will pass the
UIApplicationLaunchOptionsLocationKey

00:48:41.170 --> 00:48:42.870
as a part of that dictionary.

00:48:42.870 --> 00:48:47.530
That's your signal that you're
launched because of a location event.

00:48:47.530 --> 00:48:52.370
However, it's not always wise to key off of that.

00:48:52.370 --> 00:48:57.320
If you started, you know, kind of background
location services that you want to keep running even

00:48:57.320 --> 00:48:59.920
for user launcher applications
you still want to start those up.

00:48:59.920 --> 00:49:03.380
So, while it's useful to know that you
were launched because of a location event,

00:49:03.380 --> 00:49:06.480
you can still setup your location
services kind of regardless of that key.

00:49:06.480 --> 00:49:08.340
It's kind of there as a heads up.

00:49:08.340 --> 00:49:17.010
What you really need to do in this method is to
ensure that a CLLocationManager object gets created.

00:49:17.010 --> 00:49:23.060
So, in my example here what I've done is I've created a, I
have my own object that I'm calling MyApplicationController

00:49:23.060 --> 00:49:25.170
that takes care of location services for my app.

00:49:25.170 --> 00:49:30.270
I knew to make sure it gets instantiated and then
as a result of that instantiation, it's going to go

00:49:30.270 --> 00:49:33.670
and create CLLocationManager and configure it.

00:49:33.670 --> 00:49:36.180
So let's take a look at that.

00:49:36.180 --> 00:49:43.150
So in this object init method, we're going to, you know,
call super init and then the first thing we're going

00:49:43.150 --> 00:49:45.890
to do is create a CLLocationManagerObject.

00:49:45.890 --> 00:49:49.960
We're going to set ourselves as a delegate
so it has some way of delivering events

00:49:49.960 --> 00:49:55.180
and then the last thing that's important to do if you
register for the significant location change service, is to,

00:49:55.180 --> 00:49:58.280
again, call startMonitoringSignificantLocationChanges.

00:49:58.280 --> 00:50:02.500
That tells the framework that it's
that location manager that's interested

00:50:02.500 --> 00:50:06.890
in receiving significant location change events
as opposed to, you can actually have more

00:50:06.890 --> 00:50:08.790
than one location manager in your system.

00:50:08.790 --> 00:50:12.040
So you need to call
startMonitoringSignificantLocationChanges on it again

00:50:12.040 --> 00:50:16.490
and then in response you will get the same
location manager did update your location

00:50:16.490 --> 00:50:20.730
from location callback even if
your app is in the background.

00:50:20.730 --> 00:50:24.420
If you're registered for region
monitoring, then there's no setup like this.

00:50:24.420 --> 00:50:25.330
You don't need to call start.

00:50:25.330 --> 00:50:31.400
It will just call your delegate callbacks immediately
after being created if an event has occurred.

00:50:31.400 --> 00:50:34.570
So that's a lot of stuff.

00:50:34.570 --> 00:50:36.850
There's a lot to be added, there's
a lot of things to think about.

00:50:36.850 --> 00:50:42.540
So I just want to summarize by saying that
location is important because it provides context.

00:50:42.540 --> 00:50:48.570
It makes your applications more intuitive and easier to use
by breaking down the barriers between the users wants to do

00:50:48.570 --> 00:50:50.750
and the steps they need to take to get there.

00:50:50.750 --> 00:50:52.630
By taking advantage of this context information,

00:50:52.630 --> 00:50:56.630
this location information is already
available you stay one step ahead of your user.

00:50:56.630 --> 00:50:59.760
You can customize your application for where they are

00:50:59.760 --> 00:51:03.530
and that's pretty powerful and
you can also enable new use cases.

00:51:03.530 --> 00:51:06.720
We're just starting to scratch the
surface of what location is capable of.

00:51:06.720 --> 00:51:12.790
We're seeing a social location services and I for
one am really excited to see what's coming up next,

00:51:12.790 --> 00:51:16.660
but it's really important that you use the
appropriate technology for your use case.

00:51:16.660 --> 00:51:21.180
Users are going to trust location services most
if the applications that use it are respectful

00:51:21.180 --> 00:51:27.150
to their system resources, that they use location in the
ways that they say that they will, and in order to surprise

00:51:27.150 --> 00:51:30.300
and delight your users you need to keep that in mind.

00:51:30.300 --> 00:51:34.920
You need to provide a compelling user
experience and be respectful of their resources.

00:51:34.920 --> 00:51:43.550
So for more information we have a wonderful evangelist, Mark
Malone, who would be more than happy to answer questions.

00:51:43.550 --> 00:51:45.120
His contact information is there.

00:51:45.120 --> 00:51:47.110
We have some great documentation as well.

00:51:47.110 --> 00:51:50.340
The Core Location Framework Reference is
your first stop for location information.

00:51:50.340 --> 00:51:56.140
There's documentation on every method in the framework
as well as Location Awareness Programming Guide,

00:51:56.140 --> 00:52:01.960
which gives a high-level overview of all of
the location related APIs available on iOS,

00:52:01.960 --> 00:52:04.390
including MapKit, and how they fit together.

00:52:04.390 --> 00:52:06.720
So take a look at those and then, again, the dev forums.

00:52:06.720 --> 00:52:12.250
The developer forums are a great place to help each other,
to get information, there are also some Apple engineers

00:52:12.250 --> 00:52:13.700
that contribute from time-to-time as well.

