WEBVTT

00:00:06.320 --> 00:00:06.880
>> Blaine Garst: Let's see.

00:00:06.880 --> 00:00:09.080
Oh yeah, that's my name, Blaine Garst.

00:00:09.080 --> 00:00:09.820
I'm Blaine Garst.

00:00:09.820 --> 00:00:15.430
On my business card it says "Wizard of Runtimes," and so on
the slides there's this little slot where you're supposed

00:00:15.430 --> 00:00:19.520
to put your title, and so I just
kind of copy/pasted it there.

00:00:19.520 --> 00:00:22.540
So, what does Wizard of Runtimes mean?

00:00:22.540 --> 00:00:23.690
Well, I don't know.

00:00:23.690 --> 00:00:28.920
I work on the runtimes for the
Objective-C language, primarily.

00:00:28.920 --> 00:00:32.270
And so, the runtimes is where all the coding happens.

00:00:32.270 --> 00:00:37.550
And since I'm a programmer just like you
guys, that's where I get to do my programming.

00:00:37.550 --> 00:00:40.930
So, my programming helps you guys do your programming.

00:00:40.930 --> 00:00:49.660
So, what's going to happen today is we're going to talk
about Objective-C, and about how you folks can learn more

00:00:49.660 --> 00:00:54.290
about the language and some of
the things behind the language,

00:00:54.290 --> 00:00:58.080
some of the things about the frameworks
underneath it or above it,

00:00:58.080 --> 00:01:01.730
Cocoa Touch, and learning how to use it effectively.

00:01:01.730 --> 00:01:11.740
So, the first thing we need to fix with the slide
is we're going to talk about iOS, not iPhone OS.

00:01:11.740 --> 00:01:24.320
In particular, the iOS platform applies
to the iPad, the iPhone, the iPod touch.

00:01:24.320 --> 00:01:30.630
You know, this is the description for
what this session is supposed to cover.

00:01:30.630 --> 00:01:40.670
And first of all, if we could raise the lights a
little bit, I'd like to get a feel for among you folks,

00:01:40.670 --> 00:01:46.140
how many of you have yet to ship your first app?

00:01:46.140 --> 00:01:53.180
Wow, OK. How many here have shipped maybe only 2 apps?

00:01:53.180 --> 00:01:59.690
And I assume the rest of you might actually be a little
more familiar with Objective-C than some of these folks.

00:01:59.690 --> 00:02:01.590
Thanks, that's enough for the lights.

00:02:01.590 --> 00:02:03.720
So, let me tell you what's going to happen.

00:02:03.720 --> 00:02:08.720
We're going to take a tour, a little bit of a tour
through Objective-C and some of the most effective ways

00:02:08.720 --> 00:02:15.360
to use Objective-C on Cocoa Touch, and I'm your tour guide.

00:02:15.360 --> 00:02:20.040
So, as your tour guide, let me
introduce myself a little bit more.

00:02:20.040 --> 00:02:22.610
I've been programming since 1973.

00:02:22.610 --> 00:02:24.180
I joined NeXT.

00:02:24.180 --> 00:02:24.270
[ Applause ]

00:02:24.270 --> 00:02:32.790
I joined NeXT Computer in 1990, and I had
a little bit of experience at that point

00:02:32.790 --> 00:02:36.570
and I started doing things with my practice and experience.

00:02:36.570 --> 00:02:44.340
I got to take some patterns of programming that
I really enjoy and I put them into the language,

00:02:44.340 --> 00:02:50.140
so that my techniques of programming
became standard practice.

00:02:50.140 --> 00:02:54.720
In particular, I helped to add
protocols to the Objective-C language.

00:02:54.720 --> 00:02:59.470
[ Applause ]

00:02:59.470 --> 00:03:05.560
>> This solved-- when adopted by Java, and
they were pretty much copy/pasted into Java.

00:03:05.560 --> 00:03:08.850
I have some quotes from Gosling on that.

00:03:08.850 --> 00:03:15.060
That solved the client-server problem for like servers and
stuff 'cause I could have this abstract design and stuff.

00:03:15.060 --> 00:03:17.760
And so, I've been doing things like this ever since.

00:03:17.760 --> 00:03:21.640
And so today, you're getting a tour by the tour guide.

00:03:21.640 --> 00:03:26.810
You know, I might look like a horse because what I speak
about in Objective-C is straight from the horse's mouth.

00:03:26.810 --> 00:03:29.620
It doesn't get any better than this.

00:03:29.620 --> 00:03:32.630
So, let's get started.

00:03:32.630 --> 00:03:36.570
The iPad, the iPhone, these are awesome things to program.

00:03:36.570 --> 00:03:37.730
There is so much fun.

00:03:37.730 --> 00:03:42.270
It's so exciting to have all of this
code out there that you can really play

00:03:42.270 --> 00:03:44.080
with them, make things happen on these devices.

00:03:44.080 --> 00:03:46.180
These devices are just awesome.

00:03:46.180 --> 00:03:51.810
To make things happen on these
devices, you need to learn Objective-C.

00:03:51.810 --> 00:03:57.730
It is the core, the center of how we make things happen,

00:03:57.730 --> 00:04:00.930
how you make GUI in particular
happen, graphical user interfaces.

00:04:00.930 --> 00:04:05.760
How you make Cocoa Touch do what you want to do.

00:04:05.760 --> 00:04:12.530
There are other languages out there and my presumption
is that you know at least one of these other languages

00:04:12.530 --> 00:04:15.700
because I'm not going to teach you Objective-C necessarily.

00:04:15.700 --> 00:04:23.360
I'm going to teach you differences between what you
know and what we do here-- what we do with Objective-C.

00:04:23.360 --> 00:04:26.160
In particular, when you think about
different languages, the first thing you think

00:04:26.160 --> 00:04:29.640
about is, well, you get syntax differences.

00:04:29.640 --> 00:04:34.980
They've got different kinds of control flow operator, you
know, operators and control flow primitives and things.

00:04:34.980 --> 00:04:38.430
In particular, some languages have exceptions.

00:04:38.430 --> 00:04:44.170
Some languages have these things called
closures, which for Objective-C, we call blocks.

00:04:44.170 --> 00:04:50.150
And if you know these patterns, what you
really need to know is how do I do this pattern

00:04:50.150 --> 00:04:53.340
in this new language or this different language?

00:04:53.340 --> 00:04:59.290
But beyond just the syntax, there's a lot of
other stuff that has to go on when you do--

00:04:59.290 --> 00:05:02.190
when you really need to make things happen.

00:05:02.190 --> 00:05:04.500
You've got-- you know, how do you do math?

00:05:04.500 --> 00:05:07.300
Do you have infinite precision numbers?

00:05:07.300 --> 00:05:11.290
Nah, we usually have integers and
floats, right, in some languages though.

00:05:11.290 --> 00:05:13.840
But, you know, we have strings at different levels.

00:05:13.840 --> 00:05:16.630
We have C strings, we've got these NSStrings.

00:05:16.630 --> 00:05:20.210
There are structures versus objects for aggregating data.

00:05:20.210 --> 00:05:26.100
If you have objects, you have different
inheritance models, you know, the list goes on.

00:05:26.100 --> 00:05:32.420
By the end of the list, when you talk about platform
things, Memory Management is very much tied to the platform

00:05:32.420 --> 00:05:35.710
and languages are often tied to a platform.

00:05:35.710 --> 00:05:38.870
And so, you have to learn more about the platform.

00:05:38.870 --> 00:05:45.350
It's sort of beyond the language and you definitely
need to learn about Memory Management on the iPhone.

00:05:45.350 --> 00:05:51.030
I hear this is a little bit perplexing to some folks,
and we're going to talk about that in particular.

00:05:51.030 --> 00:06:01.520
So, to summarize what I just said, I'm going to try to
map and go what you know in terms of familiar concepts

00:06:01.520 --> 00:06:06.030
with just a little bit of terminology difference
and clear a little bit of syntax difference.

00:06:06.030 --> 00:06:12.430
We're going to introduce and talk about Objective-C sort
of uncommon ideas, things that have not quite made it

00:06:12.430 --> 00:06:16.300
to the mainstream, yet unless you
consider Objective-C mainstream.

00:06:16.300 --> 00:06:21.780
It is, I think, the number 10 most popular
language now, at least by some definition.

00:06:21.780 --> 00:06:25.390
So these are the things we're going
to talk about to help you learn how

00:06:25.390 --> 00:06:30.210
to use our kits, UIKit, et cetera, to advantage.

00:06:30.210 --> 00:06:36.250
In particular, I want to talk a little
bit about what I consider be a pattern.

00:06:36.250 --> 00:06:39.300
Now, there are books out there, design patterns and stuff.

00:06:39.300 --> 00:06:46.520
And don't get worried, I'm not a boost kind of guy, but
we will talk about patterns that make sense in terms

00:06:46.520 --> 00:06:48.960
of how we design things and how you have to use those.

00:06:48.960 --> 00:06:52.450
So, that's what we're going to try to cover today.

00:06:52.450 --> 00:06:58.540
Again, Objective-C is at the core of
how you program the iPad, the iTouch--

00:06:58.540 --> 00:07:02.090
or the iPad, the iPhone, and the iPod touch.

00:07:02.090 --> 00:07:10.510
There are two other languages though, that you
interoperate with all the time, and those are C and C++.

00:07:10.510 --> 00:07:14.880
Now, the first topic I want to talk
about is this thing called blocks.

00:07:14.880 --> 00:07:18.450
Blocks has been added to the C language.

00:07:18.450 --> 00:07:24.210
And through this thing called language inheritance,
you get to use blocks also from Objective-C,

00:07:24.210 --> 00:07:29.970
which is a pure superset of C and C++ as
well because that's what our compilers do.

00:07:29.970 --> 00:07:37.310
And what blocks allow you to do is program
from any language you want and stick blocks

00:07:37.310 --> 00:07:41.330
that use your programming language
anywhere that a block is asked for.

00:07:41.330 --> 00:07:46.160
So, it's sort of a glue facility
of cross-languages to some extent.

00:07:46.160 --> 00:07:49.120
So, let's talk about blocks.

00:07:49.120 --> 00:07:59.200
I understand that this thing about multitasking is important
to you guys, and so the background task identifier,

00:07:59.200 --> 00:08:06.900
if you want to learn how to totally do background
tasking on the iPhone, you might have to learn this API.

00:08:06.900 --> 00:08:12.400
It's got this block thing at the end, this
void caret handler thing at the very end.

00:08:12.400 --> 00:08:26.850
And so, actually it got talked about earlier in the
week, so let's pick a different thing to talk about.

00:08:26.850 --> 00:08:28.670
There's quite a lot to choose from here.

00:08:28.670 --> 00:08:35.320
In fact, there's over a hundred
APIs in iPhone OS 4 that use blocks,

00:08:35.320 --> 00:08:38.420
so I'm not going to pretend to
go through any of them, honestly.

00:08:38.420 --> 00:08:45.960
But this is kind of just a motivation as to, you know,
why you might want to listen through this section.

00:08:45.960 --> 00:08:51.270
So, this is what blocks look like for the C language.

00:08:51.270 --> 00:09:00.170
We introduce this caret expression kind of syntax to mean
sort of a local function, a local function expression.

00:09:00.170 --> 00:09:04.470
You can write a function expression
where you would write other expressions

00:09:04.470 --> 00:09:06.310
and you pass them as parameters for the most part.

00:09:06.310 --> 00:09:12.180
In this case, what we're doing is we're going to send to
some function called repeat, this little block pattern

00:09:12.180 --> 00:09:17.690
that says do a putc on d, presumably 10 times.

00:09:17.690 --> 00:09:25.570
And the idea here is that d is going to go along with that.

00:09:25.570 --> 00:09:32.430
You know, d is a local variable and you're going to get to
use that within your block as it goes off and does things.

00:09:32.430 --> 00:09:36.080
Now, blocks are actually not a very new concept.

00:09:36.080 --> 00:09:39.350
That's what they look like in C.

00:09:39.350 --> 00:09:42.200
They are called blocks in Ruby and in Smalltalk.

00:09:42.200 --> 00:09:54.520
And in fact they were sort of invented in LISP--
in the scheme, actually, somewhere around 1973.

00:09:54.520 --> 00:10:01.830
They were called closures in Scheme and
there's a-- there's a lot of interest in this.

00:10:01.830 --> 00:10:08.350
In fact, there's a new standard coming
out for C++ and it's called C++0x.

00:10:08.350 --> 00:10:10.940
It's in final committee draft or something like that.

00:10:10.940 --> 00:10:13.120
And they have a construct called the lambda.

00:10:13.120 --> 00:10:23.530
Now a lambda only fits into templates, for example, and
that's the syntax you would use for the closure expression,

00:10:23.530 --> 00:10:27.650
but you can't actually use them-- you
can't pass them directly to functions.

00:10:27.650 --> 00:10:32.070
They're only useful within templates and they're different.

00:10:32.070 --> 00:10:35.180
They're not full closures, they're a little different.

00:10:35.180 --> 00:10:43.090
But the idea is coming along and we're happy and proud
to provide to you blocks, you know, on the phone,

00:10:43.090 --> 00:10:47.770
as we've had them on Mac OS for a year or so.

00:10:47.770 --> 00:10:55.500
So, here's another use of that repeat function, this time
using some Objective-C code where we're just going to,

00:10:55.500 --> 00:11:00.160
you know, append some strings to a mutableString.

00:11:00.160 --> 00:11:06.240
And the next box tells you how to
implement that repeat function.

00:11:06.240 --> 00:11:11.030
And so the syntax we use for blocks
is that of function pointers.

00:11:11.030 --> 00:11:19.550
Think function pointers with the caret symbol instead of
the star and you'll understand the syntax of block pointers.

00:11:19.550 --> 00:11:25.890
So, they're really block pointers just like we have function
pointers, except to use that caret thing for the syntax.

00:11:25.890 --> 00:11:31.420
And to use them, you just call them as if they
were function pointers as I've shown here.

00:11:31.420 --> 00:11:36.290
So, they're pretty easy to use, pretty
easy to implement and work around.

00:11:36.290 --> 00:11:38.260
And so that's why we use them all over the place.

00:11:38.260 --> 00:11:41.570
They're useful, they're fun.

00:11:41.570 --> 00:11:46.180
To summarize the syntax, we got a typical spot,

00:11:46.180 --> 00:11:50.410
sort of the function pointer return
value slot or the return value specified.

00:11:50.410 --> 00:11:55.630
You get some parameters some of the time and you got a body.

00:11:55.630 --> 00:12:02.800
In this case, we're returning-- I
don't know, it's a contrived example.

00:12:02.800 --> 00:12:10.640
Another-- a thing we did though to make life
easier, is we allow you to use abbreviated syntax.

00:12:10.640 --> 00:12:15.920
And so when the compiler sees a return statement,
it knows there has to be a return value.

00:12:15.920 --> 00:12:23.830
And so, if there's no return statement in that body, then
it can assume that it's a void, returning a void thing.

00:12:23.830 --> 00:12:30.390
But in any case, even if you do return something,
you don't have to specify that return value type.

00:12:30.390 --> 00:12:33.700
So, the second line is exactly equivalent to the first line.

00:12:33.700 --> 00:12:38.500
So, you don't have to say int, we infer this.

00:12:38.500 --> 00:12:40.890
So the same is true, as I just said.

00:12:40.890 --> 00:12:45.930
If you don't do a return at all, we assume
void, so you don't have to type void.

00:12:45.930 --> 00:12:50.990
And in the special case where you
return void and have no parameters,

00:12:50.990 --> 00:12:53.910
you don't have to put the parameter list in either.

00:12:53.910 --> 00:12:58.160
And so that's why you kind of see
different syntaxes for these block literals.

00:12:58.160 --> 00:13:05.640
And what this do is when a compiler encounters them, it
creates a structure on the stack, which is the block object,

00:13:05.640 --> 00:13:09.620
and leaves you a pointer to this structure on the stack.

00:13:09.620 --> 00:13:17.320
So, this is both fast and dangerous and so
we have to be a little careful about these.

00:13:17.320 --> 00:13:20.360
And we'll talk about that a little bit later.

00:13:20.360 --> 00:13:23.240
So, blocks are also objects.

00:13:23.240 --> 00:13:26.640
Even though stack-based things, you can send them messages.

00:13:26.640 --> 00:13:32.330
Now, there's only a couple of messages that are of
interest, and those are for primarily copy and release.

00:13:32.330 --> 00:13:41.210
Because copy says make a perma-- make a-- copy it to the
heap so that it can survive the stack frame of origin.

00:13:41.210 --> 00:13:48.110
So what that allows us to do, allows you to do is
write a block expression, pass it off to some API.

00:13:48.110 --> 00:13:58.360
And if the API wants to keep a hold of it, pass
that use, it can do a copy on it and preserve it.

00:13:58.360 --> 00:14:02.660
And that copy costs a little extra cycles.

00:14:02.660 --> 00:14:05.980
They have to alloc-- we have to allocate
memory off the heap and copy it in there.

00:14:05.980 --> 00:14:08.440
But sometimes you need to do that and sometimes you don't.

00:14:08.440 --> 00:14:12.580
And so for the times you don't, we don't
allocate heap storage for these things.

00:14:12.580 --> 00:14:17.690
So, they're very efficient and, yeah, we like that.

00:14:17.690 --> 00:14:19.840
We use them in many, many places.

00:14:19.840 --> 00:14:22.690
We use them to enumerate collections.

00:14:22.690 --> 00:14:27.080
We use them for what I call callback notifications.

00:14:27.080 --> 00:14:32.920
There's often I'd like to say with networking code where
you're going to go, you know, fetch URL in chunks, you know,

00:14:32.920 --> 00:14:36.310
and every chunk needs to be processed, and so you panned it.

00:14:36.310 --> 00:14:42.390
Now you had a block in and every chunk is passed to
your block, and that's a much nicer way to code it.

00:14:42.390 --> 00:14:48.880
There's going to be some more talks later this week which
give more examples of the code savings you get to use

00:14:48.880 --> 00:14:56.750
by just putting the codes you want in the block and
just handing it off to the API that needs it later.

00:14:56.750 --> 00:14:59.700
There's another whole facility
called Grand Central Dispatch.

00:14:59.700 --> 00:15:00.900
There're a couple of talks on that.

00:15:00.900 --> 00:15:02.150
There's one actually later today.

00:15:02.150 --> 00:15:04.290
I'll give references to this.

00:15:04.290 --> 00:15:11.860
Where we talked about two things: One is to move code
off the main thread, off the main dispatch queue,

00:15:11.860 --> 00:15:14.650
off the main run loop, whatever we call it nowadays.

00:15:14.650 --> 00:15:20.400
Because if you try to do too much
work there, then on the Mac,

00:15:20.400 --> 00:15:24.510
you get the spinning cursor, on the iPhone you get killed.

00:15:24.510 --> 00:15:26.400
So, you don't want to do that.

00:15:26.400 --> 00:15:30.360
So, you like-- you want to learn how
to move work off the main thread.

00:15:30.360 --> 00:15:32.910
And another thing, GCD is very powerful.

00:15:32.910 --> 00:15:38.010
And in general, if you can figure out how to do
things in parallel, GCD is the way to express

00:15:38.010 --> 00:15:45.070
that because what GCD does is optimize memory
and battery life and all kinds of things

00:15:45.070 --> 00:15:50.440
to make sure you just give enough resources
to get that job done under the circumstances.

00:15:50.440 --> 00:15:56.220
And so you just code to GCD queues and the system
kind of takes care of all the thread pooling

00:15:56.220 --> 00:15:57.980
and all the other kind of stuff going on.

00:15:57.980 --> 00:16:03.770
It's very nice, there're talks later
on, I'll give you a reference to those.

00:16:03.770 --> 00:16:07.300
What I showed you on the other
expressions is we capture the variable

00:16:07.300 --> 00:16:12.340
and we make a local sort of const copy in that block object.

00:16:12.340 --> 00:16:16.300
Sometimes though, you need to mutate the variable.

00:16:16.300 --> 00:16:21.610
And so, we actually introduced a new storage
class keyword called under-under Block,

00:16:21.610 --> 00:16:26.870
for those cases where you need to pull a
value back from something you sent off.

00:16:26.870 --> 00:16:30.590
And I'm not going to talk about
under-under Block here very much.

00:16:30.590 --> 00:16:38.420
It's there, it's useful, it's somewhat intuitive, it works,
and if you want to know more, we definitely will talk

00:16:38.420 --> 00:16:42.670
about that later to a great degree, on Friday in particular.

00:16:42.670 --> 00:16:46.660
So in this case, we're going through a dictionary.

00:16:46.660 --> 00:16:50.600
We're given a particular key and
we want to return the value.

00:16:50.600 --> 00:16:56.850
I'm sorry, we're given a value and we want to sort
of find the key that was associated with that value,

00:16:56.850 --> 00:17:00.420
and so we return the key back to the caller.

00:17:00.420 --> 00:17:05.860
So these are the two talks I've referenced.

00:17:05.860 --> 00:17:13.370
There's Introducing Blocks and Grand Central Dispatch at
11:30 today, and on Friday we have Advanced Objective-C

00:17:13.370 --> 00:17:18.760
and Garbage Collection Techniques, so that's
a little bit more of a Mac and a phone talk.

00:17:18.760 --> 00:17:22.780
We cover material for both.

00:17:24.030 --> 00:17:27.580
Here's another language construct, the for-in statement.

00:17:27.580 --> 00:17:30.770
There's a lot of ways to go through an array.

00:17:30.770 --> 00:17:35.200
Most people, we looked at code and many
people are doing this objectAtIndex,

00:17:35.200 --> 00:17:38.490
objectAtIndex, objectAtIndex to go through arrays.

00:17:38.490 --> 00:17:41.480
Arrays are the lingua franca for collections.

00:17:41.480 --> 00:17:44.360
We get arrays back from many, many different APIs.

00:17:44.360 --> 00:17:48.400
And going through arrays, we found
that's taking up too many cycles.

00:17:48.400 --> 00:17:54.710
So we introduced the language construct for-in that
is backed by a particular protocol which you can adopt

00:17:54.710 --> 00:18:04.310
in your codes so that your objects can be-- you can use the
for-in statement on your objects and have them, you know,

00:18:04.310 --> 00:18:08.360
rip through whatever kinds of items they might manage.

00:18:08.360 --> 00:18:13.700
But in particular, this is a best practice
because this is fast, fastest actually.

00:18:13.700 --> 00:18:18.580
This is safest because in the middle of that
iteration, we're actually checking to see

00:18:18.580 --> 00:18:23.230
if somebody changed the array underneath you
or changed the dictionary underneath you,

00:18:23.230 --> 00:18:25.730
which can generally cause crashes.

00:18:25.730 --> 00:18:31.330
And so we throw an exception when we detect a
change so that, you know, at least you don't crash.

00:18:31.330 --> 00:18:33.700
You get to figure out what-- you
know, how that exception happens.

00:18:33.700 --> 00:18:37.030
So that's, you know, that's a case
of a good practice that we pulled

00:18:37.030 --> 00:18:40.880
into the language, and that's the kind of thing we do.

00:18:40.880 --> 00:18:45.340
We try to make your job easier and
better and more concise and clear

00:18:45.340 --> 00:18:49.490
and all that, all in one little language construct.

00:18:49.490 --> 00:18:55.460
People ask me though, how do we get
two values out of the for-in statement?

00:18:55.460 --> 00:18:56.570
I couldn't figure out how.

00:18:56.570 --> 00:19:00.040
Well, I didn't want to do it the way I figured it out.

00:19:00.040 --> 00:19:02.760
We had a better way, and the better way is blocks.

00:19:02.760 --> 00:19:11.560
So, if you need more than one value at a time out of an
array or a dictionary, we've added block enumeration APIs

00:19:11.560 --> 00:19:15.720
and these are now the fastest way
to get more than one value out.

00:19:15.720 --> 00:19:22.000
So, in the case of arrays, I've
illustrated how to get an array reversed

00:19:22.000 --> 00:19:25.510
with the index, and that's the fastest way to do it.

00:19:25.510 --> 00:19:29.820
And then dictionaries, you often want to
get the key and the value at the same time,

00:19:29.820 --> 00:19:32.450
and so this is the fastest way to do that.

00:19:32.450 --> 00:19:39.570
These are also safe and are also extensible
because, I'll show how to extend them later.

00:19:39.570 --> 00:19:42.780
So anyway, this is best practice.

00:19:42.780 --> 00:19:46.620
Let's go back to the phone in these three languages.

00:19:46.620 --> 00:19:50.500
It turns out, there's another language on our system.

00:19:50.500 --> 00:19:53.890
It's called Objective-C++.

00:19:53.890 --> 00:19:59.160
And just as we add sort of an object layer
on top of C in the Objective-C language,

00:19:59.160 --> 00:20:06.110
we add that same different object layer on top of
C++ which has its own object, ideas about objects.

00:20:06.110 --> 00:20:14.350
And so, let me tell you about Objective-C++ for just a
minute, because if you already have a pile of C++ code,

00:20:14.350 --> 00:20:19.420
what you need to know is how to
get the GUI to respond to it.

00:20:19.420 --> 00:20:26.210
And so, what you typically do is you write a few files
in Objective C++ and they can talk to your C++ code

00:20:26.210 --> 00:20:32.160
and they can talk to the GUI code and, well, I don't
know, you can use Objective C++ for all your C++ code.

00:20:32.160 --> 00:20:35.170
And so in this example, it's again contrived.

00:20:35.170 --> 00:20:38.890
You signal that it's an Objective-C++ file by the .mm

00:20:38.890 --> 00:20:44.790
and a few other variations extension,
and you sort of get to mix and match.

00:20:44.790 --> 00:20:50.330
You can mix and match declarations,
instance variables, member variables.

00:20:50.330 --> 00:20:51.990
I haven't gotten the terminology slide yet.

00:20:51.990 --> 00:21:01.200
So, in this case, I have a C++ class called My Engine
and you can put a reference to your widget in there.

00:21:01.200 --> 00:21:06.410
Equivalently, you can have your widget
class and put your engine in there.

00:21:06.410 --> 00:21:09.750
So, that's pretty useful.

00:21:09.750 --> 00:21:17.420
So, even in Objective-C methods, you
can use the throw statement from C++.

00:21:17.420 --> 00:21:28.980
Objective-C has it's own @throw, @catch and @finally,
but the exceptions underneath, the runtime implementation

00:21:28.980 --> 00:21:31.940
of them is the same across both of the languages.

00:21:31.940 --> 00:21:41.090
And so you can throw from C++ and @catch
from Objective-C, which just works.

00:21:41.090 --> 00:21:49.020
The thing that you can't do is you can't sort of
subclass a C++ class in Objective-C or vice versa.

00:21:49.020 --> 00:21:52.270
You know, the object models are distinct.

00:21:52.270 --> 00:21:58.720
So, you don't get operator overloading in
Objective-C and you don't get selectors in C++.

00:21:58.720 --> 00:22:04.760
So, it's sort of a marriage of
convenience perhaps, I don't know.

00:22:05.970 --> 00:22:10.120
Let's go on a little bit.

00:22:10.120 --> 00:22:20.030
So, Objective-C has its own terminology for common
concepts, and it's hard to present this any other way.

00:22:20.030 --> 00:22:23.770
I mean, in Java C++, people talk about member variables.

00:22:23.770 --> 00:22:27.150
We talk about instance variables or ivars.

00:22:27.150 --> 00:22:34.070
A member function is a method or an
instance method perhaps, or a dash method.

00:22:34.070 --> 00:22:42.120
And unlike C++ and Java, they're
always virtual and they're never final.

00:22:43.550 --> 00:22:53.720
So, if you like those patterns, just do it by convention
and you're just not going to get compiler support for that.

00:22:53.720 --> 00:22:57.540
A static method is different in Objective-C.

00:22:57.540 --> 00:23:04.390
In Objective-C, we sort of have a meta-class,
and that the class actually is an object itself.

00:23:04.390 --> 00:23:11.000
You can have messages and you can do inheritance in your
plus methods, so you can call super within a plus method,

00:23:11.000 --> 00:23:13.510
which is kind of new, a little bit different.

00:23:13.510 --> 00:23:17.780
But still, the idea of having a
class method is not totally new,

00:23:17.780 --> 00:23:22.580
and so we have to have a terminology thing here
even though the behavior is slightly different.

00:23:22.580 --> 00:23:27.320
We have no equivalent to static variable as of yet at least.

00:23:27.320 --> 00:23:31.450
So, we just use globals, it works.

00:23:31.450 --> 00:23:38.090
What is called an interface, in other languages
it's called a protocol, in Objective-C even though--

00:23:38.090 --> 00:23:46.450
we wanted to call them @interface, but as you can see, what
we call a class, we introduced a class using @interface,

00:23:46.450 --> 00:23:50.320
so we couldn't use the @interface keyword
that long ago, but other people pick that up.

00:23:50.320 --> 00:23:52.490
There is no operator new.

00:23:52.490 --> 00:23:54.250
There are no stack objects.

00:23:54.250 --> 00:23:59.300
Everything is allocated off the heap
using an alloc method generally,

00:23:59.300 --> 00:24:05.240
or we have these things called convenience
constructors, other plus methods can build you things.

00:24:05.240 --> 00:24:09.350
I gave you an example already that NSMutableString string.

00:24:09.350 --> 00:24:16.380
That string is a plus method that did a sort of a
MutableString alloc init autorelease and return the result.

00:24:16.380 --> 00:24:18.930
And finally, we have no explicit destructors.

00:24:18.930 --> 00:24:20.720
We have something called the dealloc method.

00:24:20.720 --> 00:24:28.320
But unlike destructors, you should
never call the dealloc method yourself.

00:24:28.320 --> 00:24:32.370
The dealloc method is called by release;

00:24:32.370 --> 00:24:37.820
when release figures out that the last
release has happened, it calls dealloc.

00:24:37.820 --> 00:24:41.090
So, don't treat deallocs like destructors.

00:24:41.090 --> 00:24:46.430
You will get into a lot of trouble
really quick if you try that.

00:24:46.430 --> 00:24:48.690
So, let's do a little bit of review.

00:24:48.690 --> 00:24:52.620
We have single inheritance of instance behavior.

00:24:52.620 --> 00:24:55.820
So, we have NSObject, it's a got a hash function.

00:24:55.820 --> 00:24:58.160
So, we're going to have an airplane and an animal.

00:24:58.160 --> 00:25:02.410
We're going to have a fish and a
bird and we're going to have a duck.

00:25:02.410 --> 00:25:10.240
And what the language allows is
multiple inheritance of abstract methods,

00:25:10.240 --> 00:25:14.920
and so in this case we have a swimmer
that has one method called swim.

00:25:14.920 --> 00:25:22.310
We have a flyer and a machine, and as you
can see, the-- I'll see which one is it.

00:25:22.310 --> 00:25:27.720
One of these-- duck that multiply inherits
both swimmer and flyer effectively,

00:25:27.720 --> 00:25:30.490
and so this is the syntax we use to specify that.

00:25:30.490 --> 00:25:36.290
Duck inherits from bird and implements
the swimmer and the flyer protocols.

00:25:36.290 --> 00:25:38.710
There's something new though.

00:25:38.710 --> 00:25:42.530
Let's pretend that Apple provided animal and bird.

00:25:42.530 --> 00:25:49.160
As I said, there was a hash method, there's also
an isEqual method, isEqual is often overridden.

00:25:49.160 --> 00:25:52.490
There's a method on NSObject called self.

00:25:52.490 --> 00:25:58.230
And I've dimmed out self to sort of indicate
that you really never re-implement that method.

00:25:58.230 --> 00:26:01.420
You just inherit the implementation from NSObject.

00:26:01.420 --> 00:26:06.710
And so as you get deeper in the class hierarchy, you
get more and more behavior, more and more methods show

00:26:06.710 --> 00:26:11.620
up like you got a parents method out of
animal and out of bird, you get a fly method.

00:26:11.620 --> 00:26:14.670
And sometimes though-- well, and this is good.

00:26:14.670 --> 00:26:17.050
This is what most languages do.

00:26:17.050 --> 00:26:19.330
In your application, let's say
you're trying to build a dragon.

00:26:19.330 --> 00:26:30.070
And what would be nice, because you're going to animate
these things, it would be nice if you could ask--

00:26:30.070 --> 00:26:35.130
you're going to animate lots of objects
including the Apple provided ones and yours.

00:26:35.130 --> 00:26:41.640
It would be really nice, though, if you
could just ask, is this object mythical?

00:26:41.640 --> 00:26:46.940
Is this Apple provided object a mythical animal?

00:26:46.940 --> 00:26:56.120
So, you'd like to add the isMythical method
on to Apple's animal and you can do this.

00:26:56.120 --> 00:26:59.740
You do this with something called a category.

00:26:59.740 --> 00:27:03.710
Now category is never-- the term category
is never-- it's not in the language.

00:27:03.710 --> 00:27:07.560
It's just this funny syntax, and this is the funny syntax.

00:27:07.560 --> 00:27:10.140
You declare an extension.

00:27:10.140 --> 00:27:19.490
Here I labeled it MythicalExtra and you name a
method, and you promise to implement this somewhere.

00:27:19.490 --> 00:27:22.040
And so this is what the implementation would look like.

00:27:22.040 --> 00:27:26.010
For animal, it's not mythical, return no.

00:27:26.010 --> 00:27:36.020
But in your class, in your dragon class, you also
implement isMythical, and in this case you return yes.

00:27:36.020 --> 00:27:40.570
Now notice that bird is going to inherit
animal's implementation so you can--

00:27:40.570 --> 00:27:42.690
you know if the bird gets asked, are you mythical?

00:27:42.690 --> 00:27:50.640
It's going to inherit the implementation
on animal that you provided in your code.

00:27:50.640 --> 00:27:55.140
So, let me talk about categories a little bit more.

00:27:55.140 --> 00:28:01.460
So the add behavior to any class; use this judiciously.

00:28:01.460 --> 00:28:09.360
I would not recommend just using isMythical here
because you might borrow somebody else's code

00:28:09.360 --> 00:28:12.540
or Apple might insert an isMythical method or something.

00:28:12.540 --> 00:28:17.990
And so, when you choose method names to extend, make sure
they're really unique because we have a kind of a bug

00:28:17.990 --> 00:28:21.630
and we can get a little bit of collisions on these names.

00:28:21.630 --> 00:28:22.690
Use them judiciously.

00:28:22.690 --> 00:28:26.660
You can extend NSObject but it's not really recommended.

00:28:26.660 --> 00:28:31.890
We don't really want a thousand methods on NSObject,
it slows the whole system down a little bit.

00:28:31.890 --> 00:28:36.660
So use them where you need to, but
it's a very powerful technique.

00:28:36.660 --> 00:28:37.820
They act like normal methods.

00:28:37.820 --> 00:28:40.550
You can call super from them, in fact.

00:28:40.550 --> 00:28:48.040
And with a little bit of code, you can also add
data to sort of have kind of like a mix in model.

00:28:48.040 --> 00:28:55.100
And the way you add data with categories, this thing we call
associative references, and we'll talk about that on Friday.

00:28:55.100 --> 00:28:59.970
It's API, and I don't want to get in to too much API here.

00:28:59.970 --> 00:29:07.800
You can also use categories to split your implementation
of a class across several files, because technically,

00:29:07.800 --> 00:29:12.130
as long as you're within an app or a
framework, you actually have access

00:29:12.130 --> 00:29:16.120
to the private instance variables,
again, a little dangerous here.

00:29:16.120 --> 00:29:20.090
We don't allow that across frameworks, though.

00:29:20.090 --> 00:29:21.780
These categories are very useful.

00:29:21.780 --> 00:29:26.790
Let's talk about Memory Management.

00:29:26.790 --> 00:29:33.300
So why? Well, if you don't do it
well, you're going to crash.

00:29:33.300 --> 00:29:38.490
Memory Management is about keeping objects
around so you can use them when you need them.

00:29:38.490 --> 00:29:41.140
And if you don't keep them around, you're going to crash.

00:29:41.140 --> 00:29:46.550
On the other hand, if you keep them around forever,
your app gets more and more memory, it gets sluggish,

00:29:46.550 --> 00:29:50.620
it gets sluggish, and eventually that's
going to cause it to crash in a way itself.

00:29:50.620 --> 00:29:57.240
And so, Memory Management means using just
the right amount of memory and no more.

00:29:57.240 --> 00:30:03.510
So, the Cocoa Touch system that you use,
the retain, release, autorelease thing,

00:30:03.510 --> 00:30:10.850
was designed for use on a 8-megabyte
system, like 20 years ago.

00:30:10.850 --> 00:30:16.680
And, you know, we had to be very memory efficient
back then, and that's also true on the phone.

00:30:16.680 --> 00:30:21.360
So, you know, some things change
and some things don't change.

00:30:21.360 --> 00:30:24.300
So, it's been around for a while.

00:30:24.300 --> 00:30:31.030
So Memory Management, unfortunately, the design of
it starts at-- I mean, it starts at the design phase.

00:30:31.030 --> 00:30:36.710
If you just go build an app and you throw retains around
like crazy and then you have to come back and clean it up,

00:30:36.710 --> 00:30:42.870
you can be in trouble because you have to think
through your object patterns at the design phase,

00:30:42.870 --> 00:30:46.700
and you learn that on your second app probably.

00:30:46.700 --> 00:30:53.850
So, the way you design it is you design
object ownership as a directed acyclic graph.

00:30:53.850 --> 00:31:00.720
And the ownership of objects comes
from a very simple pattern,

00:31:00.720 --> 00:31:04.560
and that is we have few methods that transfer ownership.

00:31:04.560 --> 00:31:10.790
Alloc and init transfer ownership
of an object to their receiver.

00:31:10.790 --> 00:31:17.180
A copy method does the same thing and there
are a few plus new APIs that also do that.

00:31:17.180 --> 00:31:21.310
But otherwise, APIs do not transfer ownership.

00:31:21.310 --> 00:31:27.410
You just kind of use them because the objects are around.

00:31:27.410 --> 00:31:30.330
And as you saw in the-- if you did, I hope you did.

00:31:30.330 --> 00:31:39.560
As you saw in Monday's afternoon talk, the static-- LLVM
Static Analyzer can help you with your retains and releases

00:31:39.560 --> 00:31:45.010
by showing you where you got it
wrong, and that's a very cool tool.

00:31:45.010 --> 00:31:52.910
The Instrument application can also show you
where you got leaks, and that also was demo'd.

00:31:52.910 --> 00:31:57.610
In particular the heap shot command within the memory,

00:31:57.610 --> 00:32:07.290
within the allocation instrument can help you detect
unused memory that's just kind of hanging around.

00:32:07.290 --> 00:32:12.200
So, let's talk about that directed
acyclic graph a little bit.

00:32:12.200 --> 00:32:16.220
So, here's one of them, and it's kind of like a lattice.

00:32:16.220 --> 00:32:18.930
You know, pointers just keep pointing down.

00:32:18.930 --> 00:32:23.900
And I've illustrated the reference counts, you
know, the number of retains in each object this way.

00:32:23.900 --> 00:32:27.670
And let's say that these are all of
the references on the system right now.

00:32:27.670 --> 00:32:38.280
So, what happens when that top reference to part of
that graph goes way, the top object loses its ref count

00:32:38.280 --> 00:32:42.730
to zero then it lets go of its things on down.

00:32:42.730 --> 00:32:45.230
Now, did everybody see the pattern go down?

00:32:45.230 --> 00:32:47.100
Let's try that again.

00:32:47.100 --> 00:32:53.600
When we let go of that top reference, that top
object goes to zero, it lets go of things it owns.

00:32:53.600 --> 00:32:54.970
They let go of what they own.

00:32:54.970 --> 00:32:58.500
They let go of what they own, et cetera.

00:32:58.500 --> 00:33:02.190
And once you have retain count zero object,
it gets reclaimed and so your graph goes way.

00:33:02.190 --> 00:33:04.460
This is what you want to happen.

00:33:04.460 --> 00:33:11.420
If you accidentally set up a back pointer, an up pointer
that is retained, then what happens when you let go

00:33:11.420 --> 00:33:16.010
of that top reference is the top node
goes from ref count 2 to ref count 1.

00:33:16.010 --> 00:33:20.920
It sticks around forever, not what you want.

00:33:20.920 --> 00:33:25.580
I think it's obvious what happens if you
fail to do a retain count of an object

00:33:25.580 --> 00:33:29.520
and it goes away prematurely, that's also bad.

00:33:29.520 --> 00:33:38.280
So, the simple rules to make Memory Management
work well for you are that at the design phase

00:33:38.280 --> 00:33:43.880
for every instance variable you decide,
do I retain this one or do I not?

00:33:43.880 --> 00:33:45.310
Is it an up pointer?

00:33:45.310 --> 00:33:48.760
So, the general pattern is you
retain your instance variables.

00:33:48.760 --> 00:33:51.280
Only those up links get non-retained.

00:33:51.280 --> 00:34:00.670
And when you go to do assignments, you have to
release the old value on retain instance variables,

00:34:00.670 --> 00:34:06.390
and send the retain message to the new
value coming in unless the new value came

00:34:06.390 --> 00:34:10.340
from like one of those methods, init, or copy or new.

00:34:10.340 --> 00:34:17.350
Finally, sometimes if you're asked to provide a
result and you have to create a result on the fly,

00:34:17.350 --> 00:34:24.550
you stick it in the autorelease pool if you don't keep
it yourself, and so that your caller just seize it

00:34:24.550 --> 00:34:26.630
and it will go away after a little bit of time.

00:34:26.630 --> 00:34:29.880
Let me explain how autorelease pools work.

00:34:29.880 --> 00:34:35.150
So at the bottom of your stack, there's
a little bit of code that's going

00:34:35.150 --> 00:34:37.950
to get an event or something and call your code.

00:34:37.950 --> 00:34:39.390
It's going to call the process event.

00:34:39.390 --> 00:34:46.350
So, at the beginning, we created-- well, we have a
stack with some local variables and so we create a pool

00:34:46.350 --> 00:34:49.160
and we create-- and we get an event from somewhere.

00:34:49.160 --> 00:34:55.860
Now, in all likelihood, the event is also held in
that autorelease pool, but I'm not illustrating that.

00:34:55.860 --> 00:34:57.900
And so we start calling process.

00:34:57.900 --> 00:35:00.500
And let's say process needs a new date.

00:35:00.500 --> 00:35:06.540
It's going to call NSDate date and get
some value out of that and compute.

00:35:06.540 --> 00:35:08.730
We passed the event on up the stack.

00:35:08.730 --> 00:35:13.410
So inside NSDate, there's some
code that looks a lot like this.

00:35:13.410 --> 00:35:16.220
This is the alloc init autorelease pattern.

00:35:16.220 --> 00:35:17.280
That's very common.

00:35:17.280 --> 00:35:20.100
You guys should probably learn that one as well.

00:35:20.100 --> 00:35:25.640
So, at the very beginning, at the alloc init time,
what happens is sort of the stack holds a reference,

00:35:25.640 --> 00:35:31.650
a retain count reference to the object D,
that date, and then we send autorelease to it.

00:35:31.650 --> 00:35:38.790
And what that does is it transfers ownership down
into the autorelease pool, which is secretly around.

00:35:38.790 --> 00:35:41.120
You know, it's just there.

00:35:41.120 --> 00:35:46.690
When the date routine returns, you know, D
is returned on the stack, it gets processed

00:35:46.690 --> 00:35:49.720
and used, you know, it gets the value out of it.

00:35:49.720 --> 00:35:58.450
And when that frame goes away, the autorelease
pool is left with the reference to that date.

00:35:58.450 --> 00:36:01.830
It's still hanging around even
though nobody knows about it anymore.

00:36:01.830 --> 00:36:09.650
But eventually the pool is drained, which is how we get rid
of the objects within a pool and get rid of the pool itself.

00:36:09.650 --> 00:36:15.710
And so, the pool goes away and everything within
it goes away and that data object goes away

00:36:15.710 --> 00:36:20.290
and there's no memory loss, and so
that's how autorelease pools work.

00:36:20.290 --> 00:36:25.920
You can actually create them and use them yourself
when you know you're going to be creating a lot

00:36:25.920 --> 00:36:28.710
of objects, a lot of autorelease objects.

00:36:28.710 --> 00:36:35.820
You can create a pool and then drain it yourself, and
that's a well understood Memory Management technique

00:36:35.820 --> 00:36:39.800
that you use when tuning for performance.

00:36:39.800 --> 00:36:44.330
Let's talk about accessors.

00:36:44.330 --> 00:36:56.320
In Cocoa, we have had this pattern for 18 years of
balance and setBalance as the way we named our accessors.

00:36:56.320 --> 00:37:02.750
You have a backing instance variable called int balance,
and in the implementation you implement these methods.

00:37:02.750 --> 00:37:06.080
There's just a lot of typing of that balance word, right?

00:37:06.080 --> 00:37:11.460
So, to kind of make this simpler, what we
introduced was something called properties.

00:37:11.460 --> 00:37:15.300
And so to replace that code I just
showed you, this is what you need to do.

00:37:15.300 --> 00:37:18.680
You say @property int balance.

00:37:18.680 --> 00:37:26.370
And then in your implementation, you say @synthesize
balance, and because we now have the same runtime running

00:37:26.370 --> 00:37:30.820
in the Simulator, as you have on
the iPhone, we get to make use

00:37:30.820 --> 00:37:36.320
of this Objective-C 2 feature such
if that's all you have to do.

00:37:36.320 --> 00:37:41.220
The compiler will synthesize the
instance variable in your class

00:37:41.220 --> 00:37:47.090
and it will synthesize the implementations
of that setter and getter.

00:37:47.090 --> 00:37:52.010
In fact, though, we noticed, well,
why do even need the @synthesize?

00:37:52.010 --> 00:37:57.510
And so, in Xcode 4, in the new
LLVM compiler that comes with it--

00:37:57.510 --> 00:38:04.280
[ Applause ]

00:38:04.280 --> 00:38:05.830
-- it's on by default.

00:38:05.830 --> 00:38:09.060
So, let's talk a little bit more.

00:38:09.060 --> 00:38:14.670
To get to that new facility though, you
have to pass a special flag to the compiler.

00:38:14.670 --> 00:38:19.610
It's there but it's not quite integrated
in the IDE the way we would like it to be.

00:38:19.610 --> 00:38:20.520
It will be though.

00:38:20.520 --> 00:38:24.560
So, let's talk about properties
a little bit more specifically.

00:38:24.560 --> 00:38:26.970
Properties have attribute, so these things in parenthesis.

00:38:26.970 --> 00:38:31.410
In this case, we're going to say perhaps
balance was a read-only in customobject,

00:38:31.410 --> 00:38:38.990
and in a subclass of customobject called supercustom,
we want to make it read-write, that is allowed.

00:38:38.990 --> 00:38:43.110
Otherwise, whatever attribute you see sticks.

00:38:43.110 --> 00:38:49.780
It's an unchangeable property of
the property unchangeable attribute.

00:38:49.780 --> 00:38:52.490
Let's talk about what those all are about.

00:38:52.490 --> 00:38:59.120
So, if you don't like our names, if you don't like
set and if you like get or whatever, you can actually,

00:38:59.120 --> 00:39:04.490
in that parenthesized section, you know,
provide your own custom method names.

00:39:04.490 --> 00:39:10.310
The other-- the other thing you could do as an attribute
is particular if you're talking about an object property,

00:39:10.310 --> 00:39:18.750
is you have to tell the compiler whether it's a
retained object, whether it's simply assigned.

00:39:18.750 --> 00:39:24.250
Assigned is sort of a synonym for non-retained,
at least in the retain-release world.

00:39:24.250 --> 00:39:26.450
And the other option, the key option, is copy.

00:39:26.450 --> 00:39:32.840
Well, we'll get to copyable-- mutable
copy kinds of things later.

00:39:32.840 --> 00:39:37.150
But it's very important-- and copy
implies retain, by the way.

00:39:37.150 --> 00:39:44.360
So, that's how you get values into your object, you know,
but you can pass a mutable string in because it's going

00:39:44.360 --> 00:39:48.630
to be copy that we copied into
an immutable string and stored.

00:39:48.630 --> 00:39:52.610
Nonatomic is a keyword that sort of means single-threaded.

00:39:52.610 --> 00:39:56.000
It's kind of performance.

00:39:56.000 --> 00:40:04.490
There are some slight safety issues with it
but it's very prevalent on the iPhone, on iOS.

00:40:04.490 --> 00:40:08.680
But it's generally considered harmless.

00:40:08.680 --> 00:40:15.910
We'd prefer that you not use it though
because as dispatch queues and things go on,

00:40:15.910 --> 00:40:20.000
things are becoming more multithreaded all the time.

00:40:20.000 --> 00:40:24.410
Finally, I already talked about read-only and read-write.

00:40:24.410 --> 00:40:32.250
The idea with that property is you don't have to
trust the compiler to do any of the work at all.

00:40:32.250 --> 00:40:35.420
You can use an app property and fully implement it.

00:40:35.420 --> 00:40:39.010
You can have your secretBalance, you
can write your setter and getter.

00:40:39.010 --> 00:40:45.190
In this case, maybe you had, you know, a different
instance variable than something called balance.

00:40:45.190 --> 00:40:46.820
And so I illustrated that.

00:40:46.820 --> 00:40:52.920
And that pattern is common enough though
that we actually support that in the compiler

00:40:52.920 --> 00:40:58.230
by simply saying @synthesize balance=secretBalance.

00:40:58.230 --> 00:41:03.190
And if you didn't even provide
secretBalance, you could do that also

00:41:03.190 --> 00:41:07.960
and the compiler would synthesize
a secretBalance instance variable.

00:41:07.960 --> 00:41:13.840
So it's-- use it you know as much as you want, use
it for everything, use it for some other things.

00:41:13.840 --> 00:41:22.620
Finally, if you're going to be using that @property by
default, there are some rare cases where you don't want

00:41:22.620 --> 00:41:29.130
to provide an implementation at all because you know how to
use forwarding, because there's another hook you can use.

00:41:29.130 --> 00:41:34.460
And in those cases, you have to use @dynamic
or you will be required to use @dynamic

00:41:34.460 --> 00:41:38.180
to tell the compiler to not synthesize things.

00:41:38.180 --> 00:41:43.400
So, that's a keyword that's going to get
a little more use, I think, in the future.

00:41:43.400 --> 00:41:46.810
Again, advanced garbage collection, Advanced Objective-C

00:41:46.810 --> 00:41:49.960
and Garbage Collection talk is where
you're going to learn about that.

00:41:49.960 --> 00:41:53.500
Now, I cheated a little bit.

00:41:53.500 --> 00:41:57.170
I didn't talk about properties of objects.

00:41:57.170 --> 00:42:03.250
This is a pattern you have to write,
would have to write yourself in order

00:42:03.250 --> 00:42:11.260
to implement a correct property object
attribute, I'm sorry, correct object property.

00:42:11.260 --> 00:42:18.370
In particular, you need to synchronize, you need to make
sure that 2 threads aren't trying to set at the same time

00:42:18.370 --> 00:42:22.700
and one of them gets half the result and the other
one doesn't, or a getter is trying to come in

00:42:22.700 --> 00:42:26.390
and give a value that's being changed,
being released underneath it.

00:42:26.390 --> 00:42:29.350
And so, it's actually kind of complicated.

00:42:29.350 --> 00:42:34.100
And so, we actually want you to
use that synthesize, wants you to--

00:42:34.100 --> 00:42:38.110
you have the compiler in runtime
do the hard work for you on this.

00:42:38.110 --> 00:42:45.740
And in particular, you do need to write a little piece
of code in the dealloc method to get rid of that object.

00:42:45.740 --> 00:42:50.610
So, here you can just send title the
release message, which is typical.

00:42:50.610 --> 00:42:53.980
I also showed what we call our .syntax.

00:42:53.980 --> 00:43:02.840
Self.title = nil is some shorthand
for saying set title to nil.

00:43:02.840 --> 00:43:09.270
The compiler just turns that self.title
into self set title to nil.

00:43:09.270 --> 00:43:15.690
And that's-- the .syntax works,
you know, everywhere pretty much.

00:43:15.690 --> 00:43:20.200
And-- but it's just shorthand for
sending Objective-C messages around.

00:43:20.200 --> 00:43:25.850
We don't really do-- the compiler really doesn't,
you know, spit out the code to do it in line.

00:43:25.850 --> 00:43:33.230
It's just-- it's just a-- almost a macro for
calling-- calling the message explicitly.

00:43:33.230 --> 00:43:40.920
So, let me talk a little bit more about Cocoa patterns.

00:43:40.920 --> 00:43:45.550
So, selectors are kind of fun, they're
not really in any other language.

00:43:45.550 --> 00:43:51.200
Selectors are data structures that
represent sort of the slot name.

00:43:51.200 --> 00:43:55.470
There are some API's you can get to,
to get the actual string that's used.

00:43:55.470 --> 00:44:00.640
It's foo: bar: whatever, at the moment.

00:44:00.640 --> 00:44:03.980
They're not really too interesting.

00:44:03.980 --> 00:44:10.990
The id object type, that was the original object type
and the only object type when Objective-C was invented.

00:44:10.990 --> 00:44:19.130
It allows any message to be sent to it, without warning, by
the compiler, even ones that aren't going to be implemented.

00:44:19.130 --> 00:44:26.680
And we have invented or it was invented, this method called
respondsToSelector, and so in this case we have syntax

00:44:26.680 --> 00:44:29.920
for naming a selector on the fly called @selector here.

00:44:29.920 --> 00:44:35.060
We're going to ask, does object
respond to the selector fred?

00:44:35.060 --> 00:44:38.840
And if so, we're going to send fred to that object.

00:44:38.840 --> 00:44:44.620
Now that's kind of squirrelly you might think,
except within UIKit we use it all the time.

00:44:44.620 --> 00:44:47.390
Let me show you where.

00:44:47.390 --> 00:44:49.120
We use it for delegates.

00:44:49.120 --> 00:44:55.700
You know, an Interface Builder where you hook up
a delegate to a control, this is what's going on.

00:44:55.700 --> 00:45:00.790
You implement a particular method that you
want done at a particular piece of time.

00:45:00.790 --> 00:45:03.880
I pulled this one out of the action sheet thing.

00:45:03.880 --> 00:45:10.860
So, suppose you needed to overwrite and do something special
when the willPresentActionSheet message would come up.

00:45:10.860 --> 00:45:16.360
And so, you implement just that method and,
you know somewhere you set the delegate.

00:45:16.360 --> 00:45:21.660
And normally, you kind of do that in Interface
Builder, but you can do it by hand also.

00:45:21.660 --> 00:45:31.780
And again, the .delegate is our .syntax for
saying UIActionSheet setDelegate to self.

00:45:31.780 --> 00:45:35.060
So, this is your part on how to do delegation.

00:45:35.060 --> 00:45:47.880
Inside-- or not inside, but UIKit actually declares a
set of methods as optional methods within a protocol.

00:45:47.880 --> 00:45:51.330
Optional is not in other languages.

00:45:51.330 --> 00:45:53.880
Optional says these are sometimes implemented.

00:45:53.880 --> 00:45:56.290
This is the syntax for them.

00:45:56.290 --> 00:46:05.220
And so, UIActionSheet declares its
delegate as implementing this protocol.

00:46:05.220 --> 00:46:10.520
And so when you set the delegate,
you know, your class-- let's back up.

00:46:10.520 --> 00:46:13.660
Your class implements UIActionSheetDelegate.

00:46:13.660 --> 00:46:18.730
And so you get type safety when
you do that setDelegate method.

00:46:18.730 --> 00:46:29.000
And inside UIKit, when it comes time to ask to present
that sheet, it goes respondsToSelector, you know,

00:46:29.000 --> 00:46:32.190
whatever that meant that was, willPresentActionSheet.

00:46:32.190 --> 00:46:35.610
And if your object implements it,
then it will go send that to you.

00:46:35.610 --> 00:46:40.440
Or in other time, it's going to say
didPresentActionSheet and it goes respondsToSelector

00:46:40.440 --> 00:46:44.960
and you don't implement that, so
it says ah, don't bother, skip it.

00:46:44.960 --> 00:46:52.000
And so, respondsToSelector is a very powerful mechanism
to, you know, add optional behavior to things.

00:46:52.000 --> 00:46:57.640
And it simplifies your life because you could put a lot
of code in the delegate and not have to do subclassing

00:46:57.640 --> 00:46:59.780
and figure out how to do subclassing properly.

00:46:59.780 --> 00:47:01.910
So it's a pattern that we use a lot.

00:47:01.910 --> 00:47:05.490
Target action uses selectors all the time also.

00:47:05.490 --> 00:47:08.650
Let's talk about class clusters.

00:47:08.650 --> 00:47:20.410
A class cluster is sort of an abstract class, like NSString,
then that's all you want to know about strings is the things

00:47:20.410 --> 00:47:26.920
in NSString itself, even though under the covers what
we do is we actually have several implementations.

00:47:26.920 --> 00:47:31.540
They're concrete secret private
implementations and you don't care,

00:47:31.540 --> 00:47:34.040
except if you know how to build a string yourself,

00:47:34.040 --> 00:47:42.050
we tell you how to do that by implementing
sort of a key method in the abstract class.

00:47:42.050 --> 00:47:47.900
So, we don't typically subclass
NSString to add behavior to it.

00:47:47.900 --> 00:47:53.270
You know, you don't tell it to go do other
things too much, we use categories for that.

00:47:53.270 --> 00:47:58.940
So there're categories for, say, open this
string as a file rather than subclassing it,

00:47:58.940 --> 00:48:01.520
the sting to be a special file kind of thing.

00:48:01.520 --> 00:48:07.530
So categories let's you add behavior to things
like even NSString, and Apple does that.

00:48:07.530 --> 00:48:13.140
And you get to subclass primarily
for representational reasons.

00:48:14.270 --> 00:48:19.280
There is, and we hear about-- you see in the
documentation this thing called property lists.

00:48:19.280 --> 00:48:24.150
And property lists are value classes, including collections.

00:48:24.150 --> 00:48:32.850
So we have strings and data, we have
NSNumbers and we have dictionaries and dates.

00:48:32.850 --> 00:48:34.750
And so those are the property list classes.

00:48:34.750 --> 00:48:41.270
They are easily transcribed and onto disc or
into HTML or, you know, many different formats.

00:48:41.270 --> 00:48:43.540
And the key thing about them is they're immutable.

00:48:43.540 --> 00:48:44.680
They're a value class.

00:48:44.680 --> 00:48:51.780
You can use them freely across all those threads
that dispatch is offering you because, you know,

00:48:51.780 --> 00:48:55.220
there's not going to be no contention on them.

00:48:55.220 --> 00:48:59.910
Another pattern-- or this isn't really a
pattern, this is just part of the system.

00:48:59.910 --> 00:49:04.710
A pattern we have is sort of our mutable value pattern.

00:49:04.710 --> 00:49:13.930
Several of those classes, plus a couple of others and not
all of them, we have this abstract layer of immutability.

00:49:13.930 --> 00:49:16.840
Strings and arrays, you can't change.

00:49:16.840 --> 00:49:18.810
Data, you can't change.

00:49:18.810 --> 00:49:21.560
And so we have for each one of them an inheritance,

00:49:21.560 --> 00:49:27.010
and we have a mutable version of
them which you can change obviously.

00:49:27.010 --> 00:49:35.720
So when we designed these, we said we want to have a
mutableCopy method, and clearly a mutableCopy method

00:49:35.720 --> 00:49:40.600
when passed to a mutableString
should give you a mutableString back.

00:49:40.600 --> 00:49:48.620
And similarly, if you sent mutableCopy to an NSString,
you should get a mutable version back out of it.

00:49:48.620 --> 00:49:55.670
So, that led us to conclude that when
you send copy to an NSDictionary,

00:49:55.670 --> 00:49:58.900
you should get an immutable dictionary out of it.

00:49:58.900 --> 00:50:08.070
But surprisingly, when you send copy to a mutable
dictionary, you get an immutable value out of it.

00:50:08.070 --> 00:50:09.970
That's just the way we do things.

00:50:09.970 --> 00:50:13.350
It's a little surprising, you need to know this.

00:50:13.350 --> 00:50:16.890
We have protocols for both of those.

00:50:16.890 --> 00:50:19.130
And so you see the protocols adopted.

00:50:19.130 --> 00:50:25.000
NSObject for example does not implement the
copying protocol, so your objects do not have

00:50:25.000 --> 00:50:30.450
to implement copying although NSObject
does actually participate

00:50:30.450 --> 00:50:36.400
and actually does implement copy just
as a helper for those classes that do.

00:50:36.400 --> 00:50:40.610
So, I talked about the terminology for common concepts.

00:50:40.610 --> 00:50:47.180
I talked about our most important uncommon ideas,
you know, blocks and properties, categories.

00:50:47.180 --> 00:50:53.970
I touched on some of the other little-- little things
that are different about our language and how we use it.

00:50:53.970 --> 00:50:57.220
And finally, we talked about patterns a little bit.

00:50:57.220 --> 00:51:04.590
So, the related sessions of interest are Introducing
Blocks and Grand Central Dispatch where you learn how

00:51:04.590 --> 00:51:09.090
to move work off of your queue, that's later today at 11:30.

00:51:09.090 --> 00:51:16.280
API design for Cocoa and Cocoa Touch, we
have a review committee for APIs inside Apple

00:51:16.280 --> 00:51:19.950
to make sure they come out looking just right.

00:51:19.950 --> 00:51:23.010
And API design is hard.

00:51:23.010 --> 00:51:27.250
And so, Ali Ozer is going to give
this talk on Thursday at 4:30.

00:51:27.250 --> 00:51:28.730
I highly recommend it.

00:51:28.730 --> 00:51:32.460
Ali is just the best guy for this.

00:51:32.460 --> 00:51:36.580
Advanced Objective-C and Garbage
Collection Techniques is going to be given

00:51:36.580 --> 00:51:41.600
by my colleague, Greg Parker, on Friday at 11:30.

00:51:41.600 --> 00:51:49.080
We'll talk about how blocks really get copied to the
heap and, you know, some of the fun stuff that goes on.

00:51:49.080 --> 00:51:57.460
And for more information, you can contact your developer,
our developer tools evangelist, Michael Jurewitz.

00:51:57.460 --> 00:52:00.110
He calls me Blainecus
so I call him Michaelopolis.

