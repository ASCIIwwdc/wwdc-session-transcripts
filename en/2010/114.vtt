WEBVTT

00:00:06.840 --> 00:00:11.710
>> Aki Inoue: This is session 114,
Advanced Cocoa Text Tips and Tricks.

00:00:11.710 --> 00:00:16.960
This year, this session is all about the Cocoa text system.

00:00:16.960 --> 00:00:21.700
We're going to be diving deeper into
the core of the layer subsystem.

00:00:21.700 --> 00:00:28.110
By the end of this session, you should be able
to get better understanding of the layer process

00:00:28.110 --> 00:00:35.930
and get comfortable extending and customizing based
functionalities, the Cocoa text system provides.

00:00:35.930 --> 00:00:45.660
Some prerequisite information, this session expects some
degrees of experience working with the Cocoa text system.

00:00:45.660 --> 00:00:52.520
And for your code reading pleasure, we have
the simple project we're going to be using

00:00:52.520 --> 00:00:58.810
in this session downloadable from the attendee site.

00:00:58.810 --> 00:01:07.020
The technique du jour, we're going to be warming
up looking at multiple text view linking,

00:01:07.020 --> 00:01:15.410
learn how to customize ruler view, how to
fold lines without touching a content of text,

00:01:15.410 --> 00:01:24.270
and we're going to be embedding UIObjects inline,
and we're going to be covering text animation.

00:01:24.270 --> 00:01:30.120
These functionalities are features
commonly found in advanced text editors,

00:01:30.120 --> 00:01:36.850
but you should be able to use these
functionalities in any kind of applications.

00:01:36.850 --> 00:01:39.000
OK, let's get started.

00:01:39.000 --> 00:01:43.940
The Cocoa text system is an integral part of the framework.

00:01:43.940 --> 00:01:46.560
It's easy to access.

00:01:46.560 --> 00:01:57.820
The power can be accessed simply by drag dropping the text
UIObjects in Interface Builder and its design to scale.

00:01:57.820 --> 00:02:06.700
The same layout engine is used by various projects
from a single line text field to subsequent application

00:02:06.700 --> 00:02:10.510
with advanced text handling features like these.

00:02:10.510 --> 00:02:16.700
And advanced typography features
such as ligatures, kerning,

00:02:16.700 --> 00:02:22.950
contextual shaping are provided right out of the box.

00:02:22.950 --> 00:02:31.940
Just like any other part of the Cocoa framework, the text
system is based on a model-view-controller design pattern

00:02:31.940 --> 00:02:38.070
so that it gives you many customization points.

00:02:40.570 --> 00:02:44.590
These are the primary text system classes.

00:02:44.590 --> 00:02:52.350
The top, a view class, NSTextView provides
user interaction and area to display.

00:02:52.350 --> 00:03:04.460
At the bottom, we have model objects
NSTextStorage and TextContainer representing data.

00:03:04.460 --> 00:03:09.930
In the middle, NSLayoutManager acts as controller object.

00:03:09.930 --> 00:03:18.930
The primary text classes alone
provides very rich customization points.

00:03:18.930 --> 00:03:23.400
You can have flexible MVC configurations.

00:03:23.400 --> 00:03:30.070
We can do multipage, multicolor,
multipane so on and so forth.

00:03:30.070 --> 00:03:36.050
Each primary class provides a wealth
of delegation interface.

00:03:36.050 --> 00:03:47.170
So you can customize validation behaviors or provide
custom pasteboard type, override selection points.

00:03:47.170 --> 00:03:50.540
Well, even provide your own context menu.

00:03:50.540 --> 00:03:59.850
In addition to this, these classes
are ready to be subclassed.

00:03:59.850 --> 00:04:03.350
You can provide non-rectangular shape with text container

00:04:03.350 --> 00:04:10.510
or you can define your text attributes
that can affect layout and rendering.

00:04:10.510 --> 00:04:20.350
In addition to these primary classes, we're going
to be covering additional helpful classes this year.

00:04:20.350 --> 00:04:25.170
NSGlyphGenerator and NSTypeSetter
are the controller classes.

00:04:25.170 --> 00:04:29.980
Also, text attachment, it's a model class.

00:04:29.980 --> 00:04:35.820
At this point, I'm handing over to
my colleague Dan Schimpf who's going

00:04:35.820 --> 00:04:40.220
to be discussing cool functionalities
you can use with the primary classes.

00:04:40.220 --> 00:04:40.400
[ Applause ]

00:04:40.400 --> 00:04:45.620
>> Dan Schimpf: Good morning.

00:04:45.620 --> 00:04:49.700
My name is Dan Schimpf, and I'm going to cover
some of the-- the core classes that Aki mentioned.

00:04:49.700 --> 00:04:52.690
So NSTextStorage is your model.

00:04:52.690 --> 00:04:59.070
The model of the text, Cocoa text system, and it
is actually a subclass of MutableAttributedString.

00:04:59.070 --> 00:05:03.730
So it is the thing that actually stores
all of your characters and your data.

00:05:03.730 --> 00:05:08.060
Does restores the attributes like
font and bold and things like that.

00:05:08.060 --> 00:05:13.120
And it can be reused across many
views, like any good model should.

00:05:13.120 --> 00:05:17.510
And as layout manager, actually lays out the--

00:05:17.510 --> 00:05:49.100
[ Cut Audio ]

00:05:49.100 --> 00:05:50.710
-- click on something.

00:05:50.710 --> 00:05:55.970
It detects view as the
text container where you clicked.

00:05:55.970 --> 00:05:59.390
So NSTextView, NSTextView is the subclass of NSView.

00:05:59.390 --> 00:06:02.100
That's the thing that you drag out of Interface Builder.

00:06:02.100 --> 00:06:05.360
That's what you actually have in your view hierarchy.

00:06:05.360 --> 00:06:09.640
It has a layout manager that it
uses to draw a text in drawRect.

00:06:09.640 --> 00:06:12.310
It edits the text in the TextStorage.

00:06:12.310 --> 00:06:17.680
When you type something, that's the thing that
gets changed and it resizes the TextContainer

00:06:17.680 --> 00:06:21.970
as the view resizes to keep those two in sync.

00:06:21.970 --> 00:06:26.040
So here's the basic setup of how the
classes work when you just drag something

00:06:26.040 --> 00:06:28.950
out of the Interface Builder palette
into your window, this is what you get.

00:06:28.950 --> 00:06:35.440
You have a single text storage with a single layout manager
drawn into a single text container with the text view.

00:06:35.440 --> 00:06:42.990
So, now we're going to cover how can I use multiple text
views to show the same content in one single text storage.

00:06:42.990 --> 00:06:50.560
So, what we're going to do, we're going to have multiple
text views and they're all going to have layout managers

00:06:50.560 --> 00:06:53.950
but we're all going to tell them
to use the same text storage,

00:06:53.950 --> 00:06:57.760
and that's going to be using this call
replaceTextStorage on layoutManager.

00:06:57.760 --> 00:07:03.330
And so this can be done using the views
you've configured in Interface Builder.

00:07:03.330 --> 00:07:07.710
So, it minimizes the set up just down to that one call.

00:07:07.710 --> 00:07:09.440
So this is what it's going to turn into.

00:07:09.440 --> 00:07:14.280
A single text storage with two layout managers,
two text containers and two text views.

00:07:14.280 --> 00:07:19.400
So, I'm going to show you how that's going to work.

00:07:19.400 --> 00:07:21.420
So, here I've got a-- this is our demo app.

00:07:21.420 --> 00:07:24.260
It's a basic NSDocument based application.

00:07:24.260 --> 00:07:31.010
I can have several of them, and I can even open
documents, such as the release notes.

00:07:31.010 --> 00:07:36.900
And you can see it has rich text,
different font sizes, different fonts.

00:07:36.900 --> 00:07:40.090
And what I can do here is just create a split.

00:07:40.090 --> 00:07:48.490
Now this is something that you've seen in a lot of text
editors including Xcode and it's showing the same text,

00:07:48.490 --> 00:07:57.900
but if I go up here I can edit both views
at once and it shows up in both places now,

00:07:57.900 --> 00:08:05.360
and they each have separate text selections and
scroll positions but they both have the same content.

00:08:05.360 --> 00:08:08.520
So, how does this work?

00:08:08.520 --> 00:08:13.220
Let's go into Xcode, and the first
thing I'm going to show you is the NIB.

00:08:13.220 --> 00:08:16.820
So, I'm going to open up the document
NIB in Interface Builder.

00:08:16.820 --> 00:08:24.080
And here's our window, it looks pretty much like
it did when we're running and you can even see

00:08:24.080 --> 00:08:27.120
that there are two text views here in our split view.

00:08:27.120 --> 00:08:35.570
And I can configure those right here, and then what I
do in the document, this is our document class here,

00:08:35.570 --> 00:08:38.740
I create a single text storage that they all share.

00:08:38.740 --> 00:08:44.160
And that's the text storage that I can alter
in when I'm reading in the data from the file

00:08:44.160 --> 00:08:46.510
and that's what I used to write out the data.

00:08:46.510 --> 00:08:51.670
So, here's when I load the NIB I get-- I have
my two-I have outlets to my two text views,

00:08:51.670 --> 00:08:55.260
and what I do is I just call replaceTextStorage
on their layoutManager

00:08:55.260 --> 00:08:57.760
with the text storage that I have already created.

00:08:57.760 --> 00:09:03.230
And then at the bottom, I remove the
bottom scroll view from my split view.

00:09:03.230 --> 00:09:06.810
So later on, I can just add it back
in and that's all I need to do.

00:09:06.810 --> 00:09:12.100
And that's what I really need to do to get
multiple text views showing the same content.

00:09:12.100 --> 00:09:16.200
Alright, the next thing I'm going
to cover, and you may have seen

00:09:16.200 --> 00:09:19.900
in the demo there is how to add
line numbers to your text views.

00:09:19.900 --> 00:09:25.450
That's another thing you see in a lot of advanced text
editors, and it's not too hard, and I'll show you how.

00:09:25.450 --> 00:09:32.000
So text views, when you drag them out of an Interface
Builder palette, they're actually encased in an NSScrollView

00:09:32.000 --> 00:09:38.650
and what NSScrollView does is show one part of
your view and then allow you to scroll things.

00:09:38.650 --> 00:09:40.210
It also has a ruler.

00:09:40.210 --> 00:09:45.590
If you've seen-- if you open up Text Edit, you've
seen the ruler that's built in NSScrollView.

00:09:45.590 --> 00:09:51.820
But scroll view can also have custom rulers
using an instance of this class NSRulerView.

00:09:51.820 --> 00:09:55.690
So, what we're going to do here is we're going
to make a custom ruler view to show line numbers.

00:09:55.690 --> 00:09:59.470
And it's going to be entirely driven
by changes to the text storage.

00:09:59.470 --> 00:10:03.710
You don't need to have any sort of
hooks in your application to do this.

00:10:03.710 --> 00:10:08.050
It's already there in NSTextStorage
DidProcessEditingNotification.

00:10:08.050 --> 00:10:13.990
All you need to do is register for this notification on
the right text storage and you'll be off to the races.

00:10:13.990 --> 00:10:20.530
So, it's going to use the information from the
layoutManager to draw in the right spot using this call,

00:10:20.530 --> 00:10:24.420
rectArrayForCharacterRange, with some extra arguments.

00:10:24.420 --> 00:10:29.020
And I'm just going to show you how that's done.

00:10:29.020 --> 00:10:32.050
OK, so you may have seen some extra
code here that I skipped over before,

00:10:32.050 --> 00:10:34.610
and what this is going to do, it's
going to get the scroll view.

00:10:34.610 --> 00:10:39.290
It's going to turn off the horizontal
ruler and turn on the vertical ruler.

00:10:39.290 --> 00:10:44.250
And now-- then it's going to create
a subclass, a ruler view,

00:10:44.250 --> 00:10:46.830
tell it what text view we have and then just set it in.

00:10:46.830 --> 00:10:52.480
And that's really all it need-- all
the application code needs to do.

00:10:52.480 --> 00:10:59.050
Now, we can go into the ruler view here,
and we just set up some things here.

00:10:59.050 --> 00:11:03.200
We have to configure both font and
text color and background color.

00:11:03.200 --> 00:11:11.560
Here in set client view, here is where we register
for this notification, and here is where we get it.

00:11:11.560 --> 00:11:17.190
All we need to do is tell ourselves that
we need to refresh our line information

00:11:17.190 --> 00:11:21.540
and then we just tell the window that we need the display.

00:11:21.540 --> 00:11:25.950
And what happens is in Snow Leopard
there is a new call called viewWillDraw.

00:11:25.950 --> 00:11:32.560
And what this is, this is an opportunity for your view to
do extra setup and setup time before you're about to draw,

00:11:32.560 --> 00:11:36.840
but you can do extra things during
this time like change your frame

00:11:36.840 --> 00:11:41.300
or set extra areas needing display
that you couldn't do during display.

00:11:41.300 --> 00:11:47.440
So this is a good chance for us to update our
line information if that hasn't been done yet.

00:11:47.440 --> 00:11:57.560
So here we are, and there's another new call in Snow
Leopard for enumerating all the words or lines in a string.

00:11:57.560 --> 00:12:02.250
So this is what we're going to do, we're going to numerate
the substrings in a range passing-- just we want the lines.

00:12:02.250 --> 00:12:06.000
So it's going to give us the ranges of
all the lines in this string for us,

00:12:06.000 --> 00:12:08.940
and we're just going to save this off for later.

00:12:08.940 --> 00:12:15.920
And this is a set in the thickness
so this is us resizing the view.

00:12:15.920 --> 00:12:18.750
That's all we can only do it in viewWillDraw.

00:12:18.750 --> 00:12:22.860
So, when we want to draw, this is
draw hash marks and labels interact.

00:12:22.860 --> 00:12:25.950
This is NSRulerViews override point for drawing.

00:12:25.950 --> 00:12:27.820
This is what you want to use.

00:12:27.820 --> 00:12:34.080
So, we're going to draw the background
color and then here we're going to--

00:12:34.080 --> 00:12:36.520
now we're going to get into drawing the actual line numbers.

00:12:36.520 --> 00:12:42.200
And the interesting part is right here.

00:12:42.200 --> 00:12:47.470
So this is where we get direct array for our character
range 'cause-- and previously, in update line information,

00:12:47.470 --> 00:12:54.530
we got all of the indexes for the lines, so now we're
going to get the position of those lines on screen.

00:12:54.530 --> 00:12:59.560
And this is important 'cause it will handle things

00:12:59.560 --> 00:13:05.050
like line wrapping 'cause you'll see
right here that we skipped this line.

00:13:05.050 --> 00:13:10.590
It's not just a repeating pattern because we
asked the layout manager where is this line.

00:13:10.590 --> 00:13:14.150
It tells us and then we know where to draw it.

00:13:14.150 --> 00:13:15.520
And that's really all you need to do.

00:13:15.520 --> 00:13:18.010
It's-- you can check out the sample code.

00:13:18.010 --> 00:13:25.490
I encourage you to look it up and now I'm going to hand
it back to Aki, who is going to show you some more tips.

00:13:25.490 --> 00:13:29.320
[ Applause ]

00:13:29.320 --> 00:13:30.830
>> Aki Inoue: Thank you, Dan.

00:13:32.030 --> 00:13:37.660
OK, before going to details, let
me show you a demo first here.

00:13:37.660 --> 00:13:40.370
This is the application Dan showed earlier.

00:13:40.370 --> 00:13:45.290
I am opening a new document.

00:13:45.290 --> 00:13:57.190
You can select a range of text and
execute a menu item called fold lines,

00:13:57.190 --> 00:14:03.420
and it folds the lines into-- attach the UIObject.

00:14:05.150 --> 00:14:10.830
Clicking on them, we should-- it revealed a hidden text.

00:14:10.830 --> 00:14:19.120
So, this functionality hides the
part of the text from the users

00:14:19.120 --> 00:14:24.590
but actually it's not touching
the content of the text itself.

00:14:24.590 --> 00:14:32.590
By going into the other view, the
original content is still intact.

00:14:32.590 --> 00:14:46.740
In fact, if you go into the folded text, select
it and copy it, open a new document here, and paste.

00:14:46.740 --> 00:15:00.860
You can extract the original content because the
actual content is not touched by this functionality.

00:15:00.860 --> 00:15:08.440
I will be spending the rest of the session
explaining how you can do these kind of techniques.

00:15:08.440 --> 00:15:15.090
The first technique you're going to be learning is how
to customize control character handling in a text system.

00:15:15.090 --> 00:15:21.360
Since the layout process executes paragraph by paragraph,

00:15:21.360 --> 00:15:31.000
you need to concatenate all the paragraphs inside the
selected range in order to fold into a single line unit.

00:15:32.570 --> 00:15:40.140
The typesetter is the object that's
responsible for that action.

00:15:40.140 --> 00:15:44.030
NSTypesetter performs actual line layout operation.

00:15:44.030 --> 00:15:52.920
It determines the soft line break position,
calculates the line position inside the text container.

00:15:52.920 --> 00:16:01.490
And finally, it places each characters inside the line.

00:16:01.490 --> 00:16:10.510
NSTypesetter is an abstract class declaring
interface, communicating the rest of the layout system,

00:16:10.510 --> 00:16:14.890
the Cocoa text system via NSLayoutManager.

00:16:14.890 --> 00:16:22.660
It's abstract class so that actually you can subclass
and provide your own custom layout engine that works

00:16:22.660 --> 00:16:28.700
with Cocoa text system in harmony if desired.

00:16:28.700 --> 00:16:35.960
For most of the developers, we have the default
system-- we have the system-default complete subclass,

00:16:35.960 --> 00:16:47.900
NSATSTypesetter that encapsulates the
magic of the advanced typographic features.

00:16:47.900 --> 00:16:54.610
Finally, the method layoutParagraphAtPoint
is the core of the NSTypesetter.

00:16:54.610 --> 00:16:57.530
It performs the actual layout process.

00:16:57.530 --> 00:17:05.110
Let's take a look at the typesetting process in detail.

00:17:05.110 --> 00:17:15.680
Whenever text storage notifies layout manager about
modifications, it requests typesetter to produce layout

00:17:15.680 --> 00:17:23.410
by calling layoutCharactersInRange
forLayoutManager maximumNumberOfLineFragments.

00:17:23.410 --> 00:17:31.900
Inside in this method implementation, the
typesetter try to determine the next paragraph range

00:17:31.900 --> 00:17:37.580
by scanning the string contents
for paragraph separated characters.

00:17:37.580 --> 00:17:47.210
Once it finds the paragraph boundary, it calls
setParagraphGlyphRange separatorGlyphRange to self preparing

00:17:47.210 --> 00:17:54.090
to preparing in short its internal state
for the next paragraphs range processing,

00:17:57.700 --> 00:18:05.340
and it layouts by calling layoutParagraphAtPoint.

00:18:05.340 --> 00:18:09.040
Note the argument here, lineFragmentOrigin.

00:18:09.040 --> 00:18:12.540
It's a pointer to the NSPoint.

00:18:12.540 --> 00:18:21.750
It's the caller's responsibility to fill this
variable with the next lineFragmentOrigin.

00:18:21.750 --> 00:18:34.860
Upon return from this method, it is updated
to point to the next lineFragmentOrigin.

00:18:34.860 --> 00:18:46.590
Once finished in layouting the paragraph, it goes
back to the step 2 until it exhausts the text layout.

00:18:46.590 --> 00:18:52.190
So, you might already guessed in
order to concatenate the paragraph,

00:18:52.190 --> 00:18:59.480
the key is to control the paragraph
separated character behavior.

00:18:59.480 --> 00:19:08.930
There are many control characters in the Unicode
standard, a character set the Cocoa is based on.

00:19:08.930 --> 00:19:21.360
And right now, there are 5 paragraph separator
defined and recognized by the Cocoa text system.

00:19:21.360 --> 00:19:27.890
For many of these nonprinted characters,
they are classified as Tab, White Space,

00:19:27.890 --> 00:19:32.120
Line Break, Paragraph Break, and Container Break.

00:19:32.120 --> 00:19:38.490
Others are simply treated as nonadvancing action.

00:19:38.490 --> 00:19:43.340
That means the typesetting process ignores those characters.

00:19:43.340 --> 00:19:52.700
And the typesetter method actionForControlCharacterAtIndex
determines the action

00:19:52.700 --> 00:19:56.300
to be taken for the character at specified index.

00:19:56.300 --> 00:20:08.020
Note that this method could be invoked multiple
times during the course of layout process.

00:20:08.020 --> 00:20:14.280
One way of timing is when the typesetter is
trying to determine the paragraph boundary.

00:20:15.490 --> 00:20:24.140
It calls this method for each control
character it's scanning and trying to determine

00:20:24.140 --> 00:20:30.630
if the control character is supposed
to be treated as paragraph separator.

00:20:33.010 --> 00:20:40.640
So, with our subclass of NSTypesetter,
we define a custom attribute,

00:20:40.640 --> 00:20:45.220
lineFoldingAttributeName that's supposed to be NSNumber.

00:20:45.220 --> 00:20:54.320
Inside our overwrite of actionForControlCharacterAtIndex,
we query the attribute at the specified index.

00:20:54.320 --> 00:21:05.720
And if the value exists and returns true, we'll return
NSTypesetterZeroAdvancementAction, so that control character

00:21:05.720 --> 00:21:11.600
at that point is just a node from the text system.

00:21:11.600 --> 00:21:20.420
Otherwise, we're going to just call super to
let the text system handle the default behavior.

00:21:21.910 --> 00:21:27.950
We'll learn how to customize the control character behavior.

00:21:27.950 --> 00:21:30.970
Let's make the two texts disappear.

00:21:30.970 --> 00:21:40.720
By customizing glyph mapping, you can make text disappear.

00:21:40.720 --> 00:21:43.350
Let's take a look.

00:21:43.350 --> 00:21:45.680
What is a glyph then?

00:21:45.680 --> 00:21:50.230
A glyph is the index for a graphical
element inside the font.

00:21:50.230 --> 00:22:05.360
So for example, if you have a letter A, capital letter A
rendered by Chalkboard form that glyph ID, glyph index is 37.

00:22:05.360 --> 00:22:11.180
With another font, Zapfino, however, it's totally different.

00:22:11.180 --> 00:22:19.340
The glyph ID is 4 in this case and it is
possible the same letter can be mapped

00:22:19.340 --> 00:22:25.080
to multiple glyphs inside a single font.

00:22:25.080 --> 00:22:34.020
For example, there could be the normal version
of letter A glyph and small cap version

00:22:34.020 --> 00:22:42.080
of the letter A could be inside the font if the
font is advanced typographic font like Zapfino.

00:22:42.080 --> 00:22:51.620
So, the process for mapping Unicode characters
to glyph ID is called glyph generation.

00:22:51.620 --> 00:22:58.180
This is the first step in the typesetting process.

00:22:58.180 --> 00:23:09.510
And most of the advanced font architecture
such as industry standard open type structures,

00:23:09.510 --> 00:23:17.840
the information inside the font so that
it can be accessed through the glyph IDs.

00:23:17.840 --> 00:23:26.900
So by customizing glyph mapping at the first step,
you can influence the rest of the layered process.

00:23:26.900 --> 00:23:37.970
And as the name implies, NSGlyphGenerator is
the object that performs a glyph generation.

00:23:37.970 --> 00:23:47.990
So, you might think you can just subclass this method
and overwrite to customize a glyph generation process.

00:23:47.990 --> 00:24:00.580
Not quite, and this glyph generator is an abstract class for
a class cluster, and the glyph generation logic is increment

00:24:00.580 --> 00:24:04.490
in concrete subclass hidden inside a cluster.

00:24:04.490 --> 00:24:11.810
But you can access the instance of the complete
subclass using the NSGlyphGenerator factory

00:24:11.810 --> 00:24:16.210
method sharedGlyphGenerator.

00:24:16.210 --> 00:24:22.370
Once you get the shared instance,
you can request it to generate glyphs

00:24:22.370 --> 00:24:30.530
by calling generateGlyphsForGlyphRange,
desiredNumberOfCharacters, glyphIndex, characterIndex.

00:24:30.530 --> 00:24:34.100
Note that first item is glyph storage.

00:24:34.100 --> 00:24:37.710
It's an object-incrementing NSGlyphStorage protocol.

00:24:37.710 --> 00:24:51.510
And this layoutManager itself confirms this
protocol and pass self when invoking this method.

00:24:51.510 --> 00:24:59.350
In return, the result is sent back to the
originator using the NSGlyphStorage method.

00:24:59.350 --> 00:25:07.640
The core of this protocol is insertGlyphs,
lengths, forStartingGlyphAtIndex, characterIndex.

00:25:07.640 --> 00:25:13.990
So exactly how you customize the glyph generation now.

00:25:13.990 --> 00:25:23.490
You can actually have a subclass NSGlyphGenerator in
preventing, in conforming to the NSGlyphStorage protocol.

00:25:23.490 --> 00:25:29.990
OK, this is the standard configuration.

00:25:29.990 --> 00:25:33.440
You have layout manager and shared instance.

00:25:33.440 --> 00:25:44.100
The layout manager request glyph generation and in return
the result is sent back using NSGlyphStorage protocol.

00:25:44.100 --> 00:25:54.560
Your custom glyph generator can
be in between of those objects.

00:25:54.560 --> 00:26:01.220
And your object is implementing in NSGlyphStorage protocol.

00:26:01.220 --> 00:26:10.660
The lab manager asks you to generate glyphs and
you pass on the request to the shared instance.

00:26:10.660 --> 00:26:17.590
But in this case, you pass self as glyph storage argument.

00:26:17.590 --> 00:26:25.690
This short instance sends back the results and
you capture it at point and modify the result,

00:26:25.690 --> 00:26:31.680
forward it to the originator layout manager.

00:26:31.680 --> 00:26:37.250
So this is our subclass of glyph
generator, line folding glyph generator.

00:26:37.250 --> 00:26:47.270
It conforms with the NSGlyphStorage protocol and it has
an instance variable for holding back original requester.

00:26:47.270 --> 00:26:59.000
In the implementation of generateGlyphsForGlyphRange beside
the number of characters, glyph index character index

00:26:59.000 --> 00:27:03.430
that we have the glyph generate argument.

00:27:03.430 --> 00:27:07.730
Then we query the shared instance.

00:27:07.730 --> 00:27:16.940
We stash the glyph storage inside instance variable
and forward a request to the shared instance.

00:27:16.940 --> 00:27:27.650
In this case, we are sending self as a glyph storage.

00:27:27.650 --> 00:27:34.330
In our inside glyphs length for
certain glyph at index matter.

00:27:34.330 --> 00:27:44.230
We are customizing the code we receive from the
shared instance and forward the modified result back

00:27:44.230 --> 00:27:49.240
to their original requestor, NSLayoutManager here.

00:27:49.240 --> 00:27:53.280
What line folding glyph generater does?

00:27:53.280 --> 00:28:00.200
It maps the first character inside
the selected range into NSControlGlyph

00:28:00.200 --> 00:28:07.200
that tells the layout system to
treat a character as a control glyph.

00:28:07.200 --> 00:28:13.110
Remember, we learn how to use the action full control
character index because default implementation

00:28:13.110 --> 00:28:19.180
of this method doesn't do anything about characters.

00:28:19.180 --> 00:28:22.380
Not the control characters.

00:28:22.380 --> 00:28:31.790
It just use the default zero advancement action so
that for the types and purpose this glyph is ignored.

00:28:31.790 --> 00:28:36.740
The rest of the branch is mapped to NSNullGlyph.

00:28:36.740 --> 00:28:45.790
This is the indication that character at this
index is absorbed by the previous character.

00:28:45.790 --> 00:28:50.150
And so we're going to have a range of text.

00:28:50.150 --> 00:28:55.770
The attachment is only showing and
the rest are hidden from the users.

00:28:55.770 --> 00:28:59.610
We learn how to customize control characters.

00:28:59.610 --> 00:29:07.210
Since we hid the text from the users, we are supposed
to provide some kind of visual feedback to the users.

00:29:07.210 --> 00:29:14.140
So what we're going to do is try to embed UI widgets inline.

00:29:14.140 --> 00:29:19.160
Embedding arbitrary objects is
straightforward using text attachments.

00:29:19.160 --> 00:29:24.880
Let's take a look at how to embed
object inside a text system.

00:29:24.880 --> 00:29:29.280
As a text system image embedding is like built in.

00:29:29.280 --> 00:29:34.760
All you have to do is go into interface
builder and flip a switch.

00:29:34.760 --> 00:29:39.180
Attaching of files inside your document is also easy.

00:29:39.180 --> 00:29:49.130
All you have to do is implement an NSTextViewDelegate method
that returns or refrains to the file that's being attached.

00:29:49.130 --> 00:29:58.670
In fact the whole thing is designed so that you
can embed arbitrary object inside the text contents

00:29:58.670 --> 00:30:00.750
using NSTextAttachment.

00:30:00.750 --> 00:30:09.250
It's not just about punching holes inside the text
layer so that you can have a space to render images.

00:30:09.250 --> 00:30:17.330
Because of the image's design, we have title integration
between text attachment, text view, layout manager,

00:30:17.330 --> 00:30:24.900
and they can work in harmony to have
very generic text embedding architecture.

00:30:24.900 --> 00:30:33.110
So NSTextAttachment, it encapsulates both storage and icons.

00:30:33.110 --> 00:30:41.170
And by reference, NSFileWrapper, it can represent
storage for the document you are attaching.

00:30:41.170 --> 00:30:49.570
Also, it can reference NSTextAttachmentCell
that represents that user interaction.

00:30:49.570 --> 00:30:56.000
You can feel this is a complete
suite of API for object embedding.

00:30:56.000 --> 00:31:02.670
One example of this custom fixed attachment
is, probably you are familiar, NSTokenField,

00:31:02.670 --> 00:31:08.350
that all tokens are implemented as a custom text attachment.

00:31:08.350 --> 00:31:15.630
So we're using the text system building
block to provide a new functionality.

00:31:15.630 --> 00:31:22.600
Whereas, NSTextAttachmentCell, you can customize
the look and feel of your UI objects inline.

00:31:22.600 --> 00:31:32.650
For customize or rendering, you can override
drawWithFrame, inView, characterIndex, layoutManager.

00:31:32.650 --> 00:31:37.500
For affecting layout, you can overwrite
cellFrameForTextContainer,

00:31:37.500 --> 00:31:41.190
proposedLineFragment, glyphPosition, characterIndex.

00:31:41.190 --> 00:31:46.740
For interaction with the users, you can customize,

00:31:46.740 --> 00:31:54.510
you can overwrite wantsToTrackMouseForEvent,
inRect, ofView, atCharacterIndex.

00:31:54.510 --> 00:32:05.570
That provides a hit testing for you, and you once you
decided the mouse pointer is inside your attachment object,

00:32:05.570 --> 00:32:15.560
you can have-- you can handle the mouse event using
trackMouse, inRect, ofView, atCharacterIndex, untilMouseUp.

00:32:15.560 --> 00:32:19.370
You know how to customize the TextAttachmentCell now.

00:32:19.370 --> 00:32:26.970
But as you've seen, we don't want to patch the contents
of the text to show the text attachment, do we?

00:32:26.970 --> 00:32:35.310
If you modify text contents, the text attachment
might appear at an intimate place in your application.

00:32:35.310 --> 00:32:44.520
So what you want to do here is synthesize
the TextAttachmentAttribute on the fly.

00:32:44.520 --> 00:32:46.440
It's pretty easy.

00:32:46.440 --> 00:32:50.420
While subclassing NSTextStorage object itself,

00:32:50.420 --> 00:32:55.350
we have a subclass of NSTextStorage
called LineFoldingTextStorage

00:32:55.350 --> 00:32:59.220
that has a property lineFoldingEnabled.

00:32:59.220 --> 00:33:09.610
And whenever this property is on, we want to synthesize
the TextAttachmentAttribute and return to the caller.

00:33:09.610 --> 00:33:14.350
This is attributes at index FF2 range.

00:33:14.350 --> 00:33:22.180
This is one of the primary methods you want to
overwrite when you're subclassing NSAttributedString.

00:33:22.180 --> 00:33:28.390
You can go to the head of file on
NSAttributedString or NSTextStorage to learn how

00:33:28.390 --> 00:33:33.630
to subclass the NSTextStorage subclass class tenure.

00:33:33.630 --> 00:33:42.230
Inside that-- inside this method, we can
access our backing store, attributed string.

00:33:42.230 --> 00:33:49.490
This is the object that actually provides
the storage for string and attributes.

00:33:49.490 --> 00:33:57.760
You could use another NSTextStorage using the base
class or NSAttribute-- NSMutableAttributedString.

00:33:57.760 --> 00:34:09.370
Now, we're going to ask the attributes at index,
specify, if we have the line folding enabled.

00:34:09.370 --> 00:34:17.390
We're going to add custom text attachment attribute to
the return attributes and send it back to the caller.

00:34:17.390 --> 00:34:23.160
Of course, you want to control when you
want to synthesize these attributes.

00:34:23.160 --> 00:34:28.190
When the property is on, you want to
synthesize the attribute on a fly.

00:34:28.190 --> 00:34:40.650
When, only when the text system is rendering the glyphs on
the screen or into some other devices or it's laying out.

00:34:40.650 --> 00:34:53.480
Since you've learned how the layout system works so far, you
can determine to overwrite and enable this property easily.

00:34:53.480 --> 00:34:58.050
There are two places, two good places to overwrite.

00:34:58.050 --> 00:35:05.800
The one is a layout manager method,
drawGlyphsForGlyphRange:atPoint.

00:35:05.800 --> 00:35:15.220
This is when that layout system renders the glyphs
on screen or printer, or some other devices.

00:35:15.220 --> 00:35:23.120
Another method, NSATSTypestter, this is our
default concrete subclass over the NSTypesetter.

00:35:23.120 --> 00:35:26.180
We've seen layoutParagraphAtPoint.

00:35:26.180 --> 00:35:31.010
This is where the heart of the
typesetting process is executed.

00:35:31.010 --> 00:35:41.640
So, you can subclass NSATSTypesetter and overwrite this
method to enable the line folding enabled property.

00:35:41.640 --> 00:35:50.390
So, in between these setting, we can call
super to execute the layouting process

00:35:50.390 --> 00:35:55.260
or rendering process provided by the base classes.

00:35:55.260 --> 00:35:58.180
We've learned how to control characters.

00:35:58.180 --> 00:36:03.500
We learned how to customize glyph generation.

00:36:03.500 --> 00:36:07.490
And we've learned how to use the attachment and zipfile

00:36:07.490 --> 00:36:13.100
by the text attachment on the fly
by subclassing NSTextStorage.

00:36:13.100 --> 00:36:21.400
So, we've already learned how to
overwrite many text system primary classes,

00:36:21.400 --> 00:36:28.450
let's cover how to animate text with the text system.

00:36:28.450 --> 00:36:35.750
Since you've learned the details of a layout
process, now, you can apply the knowledge

00:36:35.750 --> 00:36:41.230
to manipulate a text just as a normal graphic elements.

00:36:41.230 --> 00:36:45.060
So, you know, text is nothing special.

00:36:45.060 --> 00:36:48.840
It's just bits on a screen.

00:36:48.840 --> 00:36:58.300
And since it's a graphical element just like
image, you can move it around, scale it, rotate it.

00:36:58.300 --> 00:37:01.520
There's nothing special about it.

00:37:01.520 --> 00:37:10.930
But there are something you need to remember when you want
to animate, move around the text inside your applications.

00:37:10.930 --> 00:37:19.940
First, you might get tempted to animate in smooth chance.

00:37:19.940 --> 00:37:27.080
You know, if your character flies
around, it might feel cool.

00:37:27.080 --> 00:37:32.290
But you have to consider the performance implications here.

00:37:32.290 --> 00:37:42.580
Since there are small units moving around inside
the application, that could be hidden over there.

00:37:42.580 --> 00:37:53.380
So often, it is effective enough to animate by work.

00:37:53.380 --> 00:37:59.390
Another important part is know when
to capture the animation frames.

00:37:59.390 --> 00:38:08.410
It's often critical to determine the
starting and endpoint in doing the animation.

00:38:08.410 --> 00:38:19.940
You might consider simply to just toggle once layout
property in NSTextView if you want to do text animation.

00:38:19.940 --> 00:38:24.450
We actually don't recommend to use this approach.

00:38:24.450 --> 00:38:34.480
Instead, you can attach your own overlay
view on top of the TextView on the fly.

00:38:34.480 --> 00:38:41.880
So, you know, you can have overlay
view with layer enabled that copies,

00:38:41.880 --> 00:38:47.800
the content of the text you're
animating can attach to the TextView.

00:38:47.800 --> 00:38:57.910
And note, you can use the visible rect to determine
what kind of size you want to animate here.

00:38:57.910 --> 00:39:02.170
There are some advantage using this technique.

00:39:02.170 --> 00:39:08.230
By using techniques, you can simplify your animation logic.

00:39:08.230 --> 00:39:15.680
Whenever using NSTextView on a screen,
you know, there are ordinary objects

00:39:15.680 --> 00:39:22.560
that already show NSView that's
attached to the NSTextView structure.

00:39:22.560 --> 00:39:34.180
There are often you can find NSScrollView, NSScroller,
NSClipView that's surrounding NSTextView object itself.

00:39:35.410 --> 00:39:42.820
And by using overlay technique, you don't
have to worry about the interactions

00:39:42.820 --> 00:39:46.630
with this ordinary object when animating.

00:39:46.630 --> 00:39:54.530
Also, since you are not modifying the
display contents of TextView while animating,

00:39:54.530 --> 00:40:00.710
it's much easier to determine when
to capture the animation frames.

00:40:00.710 --> 00:40:12.430
So, you know, you can safely use the layout manager attached
to the TextView to determine the rectangular boundingRect

00:40:12.430 --> 00:40:18.970
for your animation GlyphRange or you can let the
layoutManager to render into your overlay at will.

00:40:23.070 --> 00:40:34.960
And since you are ensuring to enable the layers only
to the overlay views that's visible to the users,

00:40:34.960 --> 00:40:45.810
you know that you are not enabling some hidden costs to
the ordinary objects, you can manage efficient animation

00:40:45.810 --> 00:40:55.610
without worrying about additional layer objects
enabled by flipping a single view once layer property.

00:40:55.610 --> 00:41:03.580
Also, since the layout background
was overlaid, it's under control.

00:41:03.580 --> 00:41:05.340
It's under your control.

00:41:05.340 --> 00:41:09.330
You can easily prevent the font smoothing issues.

00:41:09.330 --> 00:41:12.150
OK. What is a font smoothing issues?

00:41:12.150 --> 00:41:19.070
Probably you've seen these issues a lot
when you are trying to use CoreAnimation.

00:41:19.070 --> 00:41:26.550
Font smoothing, also known as subpixel
rendering, is taking advantage of the fact

00:41:26.550 --> 00:41:34.650
that the LCD display is outlining
the LGB pixels horizontally.

00:41:34.650 --> 00:41:42.980
And by controlling these individual glyphs
instead of treating as the LGB pixel

00:41:42.980 --> 00:41:49.700
as a single unit, you can increase the virtual resolution.

00:41:49.700 --> 00:41:51.660
This is a pretty new trick.

00:41:51.660 --> 00:41:59.550
And you can make the font really crisp and
readable and smooth as the name implies.

00:41:59.550 --> 00:42:08.300
But unfortunately, this technology does
not work with transfer and background.

00:42:08.300 --> 00:42:15.160
Well, you know, if you know how the font smoothing
technology works, it's pretty obvious because it has

00:42:15.160 --> 00:42:19.650
to control each color pixel to show the smooth edge.

00:42:19.650 --> 00:42:27.500
In order to choose the right color,
the font smoothing graphic system needs

00:42:27.500 --> 00:42:31.640
to know the final destination background color.

00:42:31.640 --> 00:42:42.040
So, if you are rendering into non-opaque
background layer, that force cannot determine

00:42:42.040 --> 00:42:45.650
which pixel to enable for font smoothing.

00:42:45.650 --> 00:42:54.770
So, to prevent that, the most obvious choice is to
use opaque layer background as much as possible.

00:42:54.770 --> 00:43:02.710
With our example, we are using the TextView's
background color while animating the text.

00:43:02.710 --> 00:43:12.440
And if it's not possible to use that opaque background,
it's OK to do smooth font smoothing while animating.

00:43:12.440 --> 00:43:21.560
The difference is subtle and not too legible
while the text is moving around on your screen.

00:43:21.560 --> 00:43:30.130
When you do that, you might want to fudge up the
edges by applying the shadow to the animating text,

00:43:30.130 --> 00:43:40.470
and try to provide smooth transition by dissolving
that non-smooth text into the final rendering.

00:43:40.470 --> 00:43:50.930
So, with our sample applications, we provide this overlay
that covers the entire visible rect of the TextView.

00:43:52.950 --> 00:43:58.540
And we have another subview of the
base overlay and animating overlay

00:43:58.540 --> 00:44:02.900
that captures the content of the current selected range.

00:44:02.900 --> 00:44:17.020
And by moving the overlay view using the standard
Cocoa Animation API, you can move the text.

00:44:17.020 --> 00:44:17.820
It's easy.

00:44:17.820 --> 00:44:20.740
So, this is our overlay object.

00:44:20.740 --> 00:44:30.260
It's an NSView subclass, and it defines a
property holding a-- rendering logic as a block.

00:44:30.260 --> 00:44:35.920
Inside your rect, it simply invokes this rendering block.

00:44:35.920 --> 00:44:41.670
So, how you want to cache the text into your layer?

00:44:41.670 --> 00:44:51.060
First, you have to determine the
boundingRect for the text you are animating.

00:44:51.060 --> 00:44:58.450
In this case, we're using layoutManager method
boundingRectForGlyphRange inTextContainer.

00:44:58.450 --> 00:45:07.980
In this case, the boundingRect return is
in the TextContainer coordinate system.

00:45:07.980 --> 00:45:13.070
So, it's inside a virtual text layout coordinate system.

00:45:13.070 --> 00:45:22.540
You want to translate the bounds so that
the glyph range is at the overlay origin.

00:45:22.540 --> 00:45:29.840
You can render the glyphs inside the layer
using the method we've seen before layoutManager

00:45:29.840 --> 00:45:32.950
drawGlyphsForGlyphRange atPoint.

00:45:32.950 --> 00:45:45.480
In order to ensure that the caching operation is executed
at the right moment, you can manually code this by method.

00:45:45.480 --> 00:45:52.920
This is one of the places, you know,
calling the display method is recommended.

00:45:52.920 --> 00:45:59.130
OK. Another way you can control how
you capture the animation frames.

00:45:59.130 --> 00:46:06.250
You can use the textStorage transaction
model to control the layout process.

00:46:06.250 --> 00:46:11.000
So, you are capturing the animation
frames at the right moment.

00:46:11.000 --> 00:46:17.910
There are textStorage method beginEditing and endEditing.

00:46:17.910 --> 00:46:21.630
In pair, it should provides and represents the transaction.

00:46:21.630 --> 00:46:34.450
So, inside this transaction, you can capture
animation state while modifying the text contents.

00:46:34.450 --> 00:46:43.610
Since the layer process is delayed until
endEditing is performed, unless you, you know,

00:46:43.610 --> 00:46:54.460
did drastic change like deleting text or inserting text,
you are OK here as long as the change affects the layout.

00:46:54.460 --> 00:47:05.400
This is convenient because you might be changing and
caching the layout frames and uncontinuous ranges like this.

00:47:05.400 --> 00:47:08.430
It uses selected multiple ranges.

00:47:08.430 --> 00:47:14.570
It's convenient to execute in one chunk
inside the block the enumerateObject method.

00:47:14.570 --> 00:47:25.860
OK. We'll learn how to use the primary classes to
provide flexible images configurations and learn how

00:47:25.860 --> 00:47:31.760
to use a layout view, and how to
subclass and customize the layout process.

00:47:31.760 --> 00:47:41.350
And we touched the text attachment [inaudible]
user interface, and cover the text animation.

00:47:41.350 --> 00:47:47.380
In summary, the Cocoa text system provides
virtually unlimited customizability.

00:47:47.380 --> 00:47:57.640
It is designed to serve very high-end applications
like word processor or page design tools.

00:47:57.640 --> 00:48:05.560
Its modular design based on NBC design panning
allows the customization at the right level.

00:48:05.560 --> 00:48:17.950
Finally, if you are trying to customize, try to find
the customization point where is the primary classes

00:48:17.950 --> 00:48:27.510
like TextView, there are many NSTextView delegate
method you can use to customize virtually all

00:48:27.510 --> 00:48:30.820
of the user interaction that text system provides.

00:48:30.820 --> 00:48:36.520
If we cannot find the right customization
point with the primary class,

00:48:36.520 --> 00:48:42.030
you can dug deeper to the helper classes we discussed today.

00:48:42.030 --> 00:48:44.500
We have sessions coming up.

00:48:44.500 --> 00:48:47.000
And you can attend.

00:48:47.000 --> 00:48:52.840
By attending the sessions, you can complement
your understanding of the text system.

00:48:52.840 --> 00:49:01.190
For more information, you can contact our
Evangelist Bill Dudney and we have fabulous set

00:49:01.190 --> 00:49:06.210
of technical documentation explaining the text architecture.

00:49:06.210 --> 00:49:13.850
You can go to this Cocoa Text Architecture Guide
and it points to other detailed documentation.

00:49:13.850 --> 00:49:18.860
And of course, Apple Developer Forum
is a good place to ask questions.

