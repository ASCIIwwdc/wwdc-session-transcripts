WEBVTT

00:00:08.610 --> 00:00:14.690
>> Andre Boule: Animations are one of the
defining features of iPhone, iPod touch, and iPad.

00:00:14.690 --> 00:00:22.070
From the moment you unlock the device, almost every
app has these beautiful animations all throughout.

00:00:22.070 --> 00:00:27.260
So, good morning, and welcome to
Building Animation Driven Interfaces.

00:00:27.260 --> 00:00:32.670
My name is Andre Boule, and I'm an iOS Software Engineer.

00:00:32.670 --> 00:00:38.610
And I'm proud to say that like many of you
in the audience, I am an app developer.

00:00:38.610 --> 00:00:42.120
I've contributed to many of the built-in apps on iPhone.

00:00:42.120 --> 00:00:45.140
And most recently, I worked on the YouTube app for iPad.

00:00:45.140 --> 00:00:52.530
I think that this background as an app developer
gives me a unique perspective on to the challenges

00:00:52.530 --> 00:00:56.500
that you guys face in bringing animation to your apps.

00:00:56.500 --> 00:00:58.610
I've been through it before.

00:00:58.610 --> 00:01:04.760
And today, we're going to go through it
together and we'll see how easy we can make it.

00:01:04.760 --> 00:01:12.070
Before I get into it, animated:Yes, if you
can do just this, I mean that's pretty easy,

00:01:12.070 --> 00:01:15.100
just animated:YES, you can get animation in your app.

00:01:15.100 --> 00:01:24.980
And it's because UIKit has a rich set of built-in
animations, this example UINavigationController.

00:01:24.980 --> 00:01:30.670
When you push and pop a controller, you
can do it in an animated fashion just

00:01:30.670 --> 00:01:33.220
by telling UIKit that you want animation.

00:01:33.220 --> 00:01:42.260
Another example, UITableView has very rich
editing for inserts, deletes, and reorders.

00:01:42.260 --> 00:01:48.020
Also, again, you can just tell the system you
would like these operations to be animated.

00:01:53.860 --> 00:01:59.230
So, why do we use these animations, why do
we provide you with built-in animations?

00:01:59.230 --> 00:02:02.150
Well, it's to provide context to the user.

00:02:02.150 --> 00:02:09.250
Animations are not just eye candy, they help explain
to the user what is going on in your application.

00:02:09.250 --> 00:02:15.520
Now, of course, you always want to design your interface
such that if the user is looking away from the screen,

00:02:15.520 --> 00:02:21.390
they're not completely lost, but because it's a touch
screen and you're using your fingers, most of the time,

00:02:21.390 --> 00:02:26.340
when you're interacting with the device, you're
actually using or you're looking right at the screen.

00:02:26.340 --> 00:02:31.430
So, animations help explain to the user
what's happening in your application.

00:02:31.430 --> 00:02:39.440
When you use the built-in UIKit animations, your app is
consistent with the rest of the apps on the platform.

00:02:39.440 --> 00:02:42.140
So, it makes your app easier to learn.

00:02:42.140 --> 00:02:47.930
Some have said that the mark of
a good programmer is being lazy.

00:02:47.930 --> 00:02:50.560
Well, I don't know about you guys, but if that's true,

00:02:50.560 --> 00:02:55.590
that makes me a pretty great programmer,
so, it's less work for you.

00:02:55.590 --> 00:02:59.680
Now, that said, that's not why we're here today, right?

00:02:59.680 --> 00:03:06.040
We want to go beyond what UIKit provides
and build our own custom animations.

00:03:06.040 --> 00:03:10.550
So, what are we going to cover today?

00:03:10.550 --> 00:03:14.840
The first thing I'm going to talk
about is UIView Animations.

00:03:14.840 --> 00:03:24.030
UIView Animations is the basic UIKit API that you're going
to use most of the time for building animations in your app.

00:03:24.030 --> 00:03:26.560
We're then going to talk about transitions.

00:03:26.560 --> 00:03:27.560
But what are transitions?

00:03:27.560 --> 00:03:31.210
Transitions are animations between states or different UIs.

00:03:31.210 --> 00:03:36.920
So, two good examples that I like to give are in the Notes
application when you're flipping from one page of text

00:03:36.920 --> 00:03:40.040
to another, that beautiful flip animation is the transition.

00:03:40.040 --> 00:03:45.560
And also, many of our apps have a frontView and a
backView like the Stocks and Weather applications.

00:03:45.560 --> 00:03:51.290
So, when you transition with the flip animation
to the backView, that's also a transition.

00:03:51.290 --> 00:03:55.930
Next, we're going to talk about supporting
window rotation animations in your app.

00:03:55.930 --> 00:03:59.830
It's very important that you support
both landscape and portrait in your apps,

00:03:59.830 --> 00:04:02.340
your users would really appreciate it if you did.

00:04:02.340 --> 00:04:05.400
So, we'll talk about how to do that.

00:04:06.970 --> 00:04:08.940
We're going to talk about performance.

00:04:08.940 --> 00:04:12.100
One of the things that makes the
device so magical is when the--

00:04:12.100 --> 00:04:16.500
animations have great performance, it almost looks magical.

00:04:16.500 --> 00:04:18.970
So, it's very important to have good performance.

00:04:18.970 --> 00:04:21.440
We'll talk about that.

00:04:21.440 --> 00:04:26.210
And finally, one of the questions that we
get a lot from developers like you guys,

00:04:26.210 --> 00:04:31.790
is when should I use UIKit to do my animations?

00:04:31.790 --> 00:04:36.440
And you know, you probably been to some other
CoreAnimation sessions or have read about it,

00:04:36.440 --> 00:04:39.500
when I should use CoreAnimation directly?

00:04:39.500 --> 00:04:44.690
Well, that's an interesting question, and
we'll talk about that at the end of the talk.

00:04:44.690 --> 00:04:50.450
So, we have a lot of content to get through, so I'm going
to go right into it and talk about UIView Animations.

00:04:50.450 --> 00:04:57.490
As I said, this is the basic API that you're going to use
in the vast majority of animations within in your app.

00:04:57.490 --> 00:05:03.650
So, if you've built animations before, you
may have done something like this in the past.

00:05:03.650 --> 00:05:07.400
I have a view here that's completely transparent.

00:05:07.400 --> 00:05:13.520
Its Alpha has been set to 0, and my goal
is to dissolve it to become visible.

00:05:13.520 --> 00:05:16.390
So, I'm going to animate the Alpha of the view.

00:05:16.390 --> 00:05:25.940
I've created a timer, and each time my timer callback fires,
I'm going to progressively change the Alpha of that view.

00:05:25.940 --> 00:05:27.510
Let's see what that looks like.

00:05:27.510 --> 00:05:33.550
[ Pause ]

00:05:33.550 --> 00:05:35.620
So, there are a couple of things you have to manage here.

00:05:35.620 --> 00:05:39.440
You have to manage, well, how fast
do I want my timer callback to fire?

00:05:39.440 --> 00:05:44.720
Every time my-- your timer callback fires, you have to
run some code to figure out what's the appropriate Alpha

00:05:44.720 --> 00:05:47.210
that I want to set it to, and actually set it.

00:05:47.210 --> 00:05:52.610
Really, all you care about when you're building
your animation is that last step, right?

00:05:52.610 --> 00:05:58.790
Your view is completely transparent, and you want it
to set it to Alpha:1.0, but you want that to happen

00:05:58.790 --> 00:06:03.370
in an animated fashion, why should you have
to worry about all those intermediate steps?

00:06:03.370 --> 00:06:09.580
Well, the good thing is, that's how UIView Animation
works, you don't have to worry about those steps.

00:06:09.580 --> 00:06:13.870
You create your animations, set it
up, and then once you fire it up,

00:06:13.870 --> 00:06:17.850
the system takes care of the rest and
actually does the animation for you.

00:06:17.850 --> 00:06:21.180
So, same example, but with UIVIew Animation this time.

00:06:21.180 --> 00:06:30.540
myView has an Alpha of 0, and I'm going to set it to
1, and let the system take care of animating it in.

00:06:30.540 --> 00:06:36.270
Nice. Now, one of the advantages
here, without you knowing it, this--

00:06:36.270 --> 00:06:41.280
without you knowing it, this actually
happened in a hardware-accelerated fashion.

00:06:41.280 --> 00:06:46.730
Many people believe that in order to
build a hardware-accelerated animated UI,

00:06:46.730 --> 00:06:50.800
you need to learn OpenGL or some other similar technology.

00:06:50.800 --> 00:06:56.100
With UIView Animations, that's just not true.

00:06:56.100 --> 00:06:59.350
Now, you may have noticed the logo that I used--

00:06:59.350 --> 00:07:03.650
that I'm using in my animation examples
here, it's the CoreAnimation logo.

00:07:03.650 --> 00:07:05.440
And that's no coincidence.

00:07:05.440 --> 00:07:14.100
Because although I'm using UIKit and UIVIew Animations as
an API to build these animations, UIKit is actually powered

00:07:14.100 --> 00:07:20.250
by CoreAnimation, so you're using
CoreAnimation without knowing it.

00:07:20.250 --> 00:07:25.840
So, let's look at the code that you can use to
build the animation that I just talked about.

00:07:25.840 --> 00:07:28.260
And for those app developers out
there who already have apps,

00:07:28.260 --> 00:07:31.170
you've seen this before, but we'll go through it quickly.

00:07:31.170 --> 00:07:36.450
We create an animation, tell the system
we want it to be a two-second animation,

00:07:36.450 --> 00:07:40.520
and then make a change to an animatable
property, in this case, the Alpha.

00:07:40.520 --> 00:07:48.010
Finally, we commit the animation and the
system runs it, it's just that simple.

00:07:48.010 --> 00:07:53.360
New in iOS 4.0, we have a new blocks-based
API for building animations.

00:07:53.360 --> 00:07:57.740
So, if you're not familiar with blocks, I encourage
you to go find out about those, but you should see here

00:07:57.740 --> 00:08:01.760
that this is an equivalent example using the Blocks API.

00:08:01.760 --> 00:08:09.450
So, with Blocks, you provide a block of code, and that code
does some settable properties, it will change some values,

00:08:09.450 --> 00:08:16.490
and you'll get the same animation, but you get all
the benefits of using Blocks, so it's pretty neat.

00:08:16.490 --> 00:08:19.310
Result on the screen is the same as you can see.

00:08:19.310 --> 00:08:21.260
Alright. So, I've been showing some Alpha animations.

00:08:21.260 --> 00:08:25.540
Of course, any property that's
animatable works just the same.

00:08:25.540 --> 00:08:29.930
In this case, I'm going to move the
view on screen using a frame animation.

00:08:29.930 --> 00:08:35.340
I could also animate the center property
of a view, and the result would be similar.

00:08:35.340 --> 00:08:42.380
If I want to rotate a view, I can
animate the transform of the view.

00:08:42.380 --> 00:08:45.560
You could set a scale transform,
for instance, for a similar result.

00:08:45.560 --> 00:08:47.910
So, there are many animatable properties.

00:08:47.910 --> 00:08:50.650
And the header files will tell
you which ones are animatable.

00:08:50.650 --> 00:08:59.570
And of course, I can combine multiple of these properties
into one animation, and get two animations at the same time.

00:08:59.570 --> 00:09:05.370
In this case a frame and the Alpha animation.

00:09:05.370 --> 00:09:07.350
What if I wanted to chain animations?

00:09:07.350 --> 00:09:14.120
Well, there's a more advance API that provides
for you a completion block that you can pass in.

00:09:14.120 --> 00:09:14.970
What's a completion block?

00:09:14.970 --> 00:09:20.140
Well, that's a second block of code
that's there in the blocks-based API.

00:09:20.140 --> 00:09:25.900
The difference is this completion block
only runs after the animation completes.

00:09:25.900 --> 00:09:32.350
So, any code that you put in that completion block
will be triggered once the animation is finished.

00:09:32.350 --> 00:09:33.320
What have I done here?

00:09:33.320 --> 00:09:37.320
Well, in my completion block, I've
created a second animation,

00:09:37.320 --> 00:09:42.330
so the result is after the first animation
completes, the second animation begins.

00:09:42.330 --> 00:09:47.040
Let's look at that.

00:09:47.040 --> 00:09:49.480
Alright. It's already you get the idea of it.

00:09:49.480 --> 00:09:52.130
Just with these basic things, you could do a lot in your UI.

00:09:52.130 --> 00:09:58.260
I want to caution you that not every
property on UIView is animatable.

00:09:58.260 --> 00:10:03.480
In particular, what would it mean
to interpolate between BOOLs.

00:10:03.480 --> 00:10:08.440
Half-yes, half-no, that doesn't really
make sense, so don't try to animate BOOLs.

00:10:09.770 --> 00:10:15.140
So, in conclusion, I mean I know we've only been here
a couple of minutes, but with what you've seen so far,

00:10:15.140 --> 00:10:18.860
I bet you, you can implement most animations in your app.

00:10:18.860 --> 00:10:20.860
The API is extremely simple.

00:10:20.860 --> 00:10:23.840
What I've shown you is just the single view, obviously.

00:10:23.840 --> 00:10:31.510
But if you have subviews within your view, it will
just work as expected and the subviews follow along.

00:10:31.510 --> 00:10:34.140
So, with just this, you're almost
90 percent of the way there.

00:10:34.140 --> 00:10:37.000
Of course, we want to go deeper.

00:10:37.000 --> 00:10:43.880
So now, let's go beyond the basics and look at
some of the more advanced things that you can do

00:10:43.880 --> 00:10:47.490
with animations, I know that's why you guys are here.

00:10:47.490 --> 00:10:52.400
So, if you want to cancel an animation,
that's halfway through, how do you do that?

00:10:52.400 --> 00:10:58.600
Well, you can look, but you won't find a
cancel method in UIView to cancel an animation.

00:10:58.600 --> 00:11:00.300
You don't need one.

00:11:00.300 --> 00:11:06.230
If you want to cancel an animation that's halfway
through, all you need to do is set that property

00:11:06.230 --> 00:11:09.700
that you're animating outside of an animation block.

00:11:09.700 --> 00:11:12.090
What happens?

00:11:12.090 --> 00:11:15.350
The property will just jump directly
to the value that you're setting,

00:11:15.350 --> 00:11:18.300
and the rest of the animation will just not occur.

00:11:18.300 --> 00:11:20.430
So, it's just that simple.

00:11:20.430 --> 00:11:24.010
There's also a finished parameter in the new Blocks API.

00:11:24.010 --> 00:11:30.830
And that value will be NO to let you
know that the animation didn't finish.

00:11:30.830 --> 00:11:33.220
Alright. Next, we'll talk about animation options.

00:11:33.220 --> 00:11:37.250
I'm going to cover five different
options, five concepts, really.

00:11:37.250 --> 00:11:44.570
I encourage you to go look at the header files to see how
to use these in the old API and the new blocks-based API.

00:11:44.570 --> 00:11:51.100
But really, what I want you to leave with today is
understand the concepts of how these things work.

00:11:51.100 --> 00:11:54.790
So, in the old API, there are setter methods.

00:11:54.790 --> 00:12:01.830
In the new blocks-based API, you can see these options
that you can pass in as a mask, these animation options.

00:12:01.830 --> 00:12:07.070
So, let's look at those five different things that
I want to talk about, that's the full API for you

00:12:07.070 --> 00:12:11.850
if you care to remember it, but remember options.

00:12:11.850 --> 00:12:18.820
First one very simple, if you want to repeat an
animation, you can use the repeat options to do this.

00:12:18.820 --> 00:12:23.960
You can either use repeat by itself, which will cause the
animation to start back at the beginning and then repeat.

00:12:23.960 --> 00:12:28.130
Or repeat in conjunction with autoreverse
which will cause your animation to go back

00:12:28.130 --> 00:12:32.030
to the beginning in the reverse order after it finishes.

00:12:32.030 --> 00:12:34.610
Pretty straightforward.

00:12:34.610 --> 00:12:36.010
Alright, Animation and Interaction.

00:12:36.010 --> 00:12:41.920
I want to make a note here about how
you should treat this in your app.

00:12:41.920 --> 00:12:51.220
You need to ask yourself the question, does it make sense
for my app to respond to touches during an animation?

00:12:51.220 --> 00:12:57.540
What you may find is that in many cases you're
transitioning, you know, an object to and from the screen,

00:12:57.540 --> 00:13:02.310
you don't want the user to be pushing on
buttons on that UI while it's animating.

00:13:02.310 --> 00:13:10.510
So, by default in the new blocks-based API., app-wide
interaction is disabled for the duration of the animation.

00:13:10.510 --> 00:13:13.540
So, you don't need to worry about disabling interaction.

00:13:13.540 --> 00:13:15.530
The system takes care of it for you.

00:13:15.530 --> 00:13:22.390
That's said, there are probably cases in which
you do want interaction during an animation.

00:13:22.390 --> 00:13:29.960
So, you can override this behavior
using the AllowUserInteraction option.

00:13:29.960 --> 00:13:36.150
This doesn't apply to the old API because the old API
did not get you this interaction disabling for free.

00:13:36.150 --> 00:13:41.430
Alright. Let's talk about animation curves.

00:13:41.430 --> 00:13:46.950
Animation curves are all about the timing of your animation.

00:13:46.950 --> 00:13:52.940
Now, we've looked at this frame animation, you know,
from left to right before, but let's look at it again.

00:13:52.940 --> 00:14:00.240
And this time, pay close attention to the way the object
moves at the beginning and the end of the animation.

00:14:00.240 --> 00:14:07.380
Specifically, look for an acceleration at the beginning
and a deceleration at the end of the animation.

00:14:07.380 --> 00:14:08.070
Alright. You're ready?

00:14:08.070 --> 00:14:16.180
Now, it might be more obvious if we look at
it without that acceleration or deceleration.

00:14:16.180 --> 00:14:20.120
You can turn off the curve using CurveLinear.

00:14:23.470 --> 00:14:29.440
In CurveLinear, the object defies the laws of physics
and accelerates at an indefinite rate to its final speed.

00:14:29.440 --> 00:14:33.240
And then at the end of the animation,
decelerates just as quickly.

00:14:33.240 --> 00:14:37.120
Let's look at them side by side, it'll be more obvious.

00:14:40.090 --> 00:14:40.600
Cool, right.

00:14:40.600 --> 00:14:46.120
There's two more CurveEaseIn and CurveEaseOut.

00:14:46.120 --> 00:14:50.110
Now, it's your homework for tonight to go try
those out yourself and see what they look like.

00:14:50.110 --> 00:14:54.310
Don't worry, it's a fun homework, you know,
animations, it doesn't get any better than that, right?

00:14:54.310 --> 00:15:00.250
Alright. So, number 4 of 5, Begin from Current State.

00:15:00.250 --> 00:15:06.610
Again, this one, this is-- it's easiest
to explain this by looking at an example.

00:15:06.610 --> 00:15:11.750
So, in my example here, my view is
going to first animate top to bottom,

00:15:11.750 --> 00:15:20.100
and after that animation finishes, left to right.

00:15:20.100 --> 00:15:22.670
OK. Simple enough, right?

00:15:22.670 --> 00:15:31.890
Now, imagine the same scenario except instead of animating
left to right after the first animation completes,

00:15:31.890 --> 00:15:39.670
what if that second animation starts midway through
the first animation, what would that look like?

00:15:39.670 --> 00:15:50.480
You may have a mental picture of what that would do,
but let's look at it in reality and see what happens.

00:15:50.480 --> 00:15:57.280
The view jumped from the midway point in the
first animation directly to the endpoint,

00:15:57.280 --> 00:16:00.740
and then animated left to right as you would expect.

00:16:00.740 --> 00:16:02.470
But why is that?

00:16:02.470 --> 00:16:09.300
The reason is that in your first animation,
you're not just animating the view top to bottom;

00:16:09.300 --> 00:16:14.090
you're actually setting the view's
position to that bottom position.

00:16:14.090 --> 00:16:20.990
So the result is when the second animation
begins, it's going to animate from that position

00:16:20.990 --> 00:16:26.050
and not where the view is currently
on screen, that's the default.

00:16:26.050 --> 00:16:31.900
If instead, you want the view to animate
from where it actually is on screen,

00:16:31.900 --> 00:16:36.320
you can do that with the option BeginFromCurrentState.

00:16:36.320 --> 00:16:41.920
So, this time, it's the same example, but I've turned
on BeginFromCurrentState for the second animation.

00:16:41.920 --> 00:16:44.310
Let's see what that looks like.

00:16:45.630 --> 00:16:46.490
That's great.

00:16:46.490 --> 00:16:50.440
The view animates directly from where
I want it and where it was on screen.

00:16:50.440 --> 00:16:57.440
But let's looks at it again, there's a slight pause right
there where the view is accelerating to its final speed,

00:16:57.440 --> 00:16:59.430
and that's because-- well, we talked about this, right?

00:16:59.430 --> 00:17:07.600
The curve provides for an acceleration when the
animation begins, we know how to turn that off, don't we?

00:17:07.600 --> 00:17:09.490
Yeah, you can use the curve option.

00:17:09.490 --> 00:17:13.360
So, same example this time, BeginFromCurrentState,
but I've turned down--

00:17:13.360 --> 00:17:17.920
I've turned on CurveEaseOut to disable that acceleration.

00:17:17.920 --> 00:17:24.200
Nice. The view just continues to
move down to its final position.

00:17:24.200 --> 00:17:25.530
So, I've shown this for a couple of reason,

00:17:25.530 --> 00:17:31.940
but one is to show that you can combine these
options together to get the effect that you want.

00:17:31.940 --> 00:17:37.310
Alright. Last but not least, Property Inheritance.

00:17:37.310 --> 00:17:40.770
This one again is specific to the new Blocks API.

00:17:40.770 --> 00:17:47.940
In this example, I've created an animation,
and I've specified a two-second duration.

00:17:47.940 --> 00:17:49.220
What does my animation do?

00:17:49.220 --> 00:17:55.930
Well, firstly, it sets the Alpha of my frame to
zero, but it also calls this shrinkFrame method.

00:17:55.930 --> 00:17:59.750
This is a method that I've implemented
on my UIView subclass.

00:17:59.750 --> 00:18:01.110
OK, that's interesting.

00:18:01.110 --> 00:18:02.120
Let's look at shrinkFrame.

00:18:02.120 --> 00:18:04.250
What does that do?

00:18:04.250 --> 00:18:08.480
Well, shrinkFrame can be called
from other places in my application.

00:18:08.480 --> 00:18:14.640
So, to make sure that shrinkFrame is animated,
shrinkFrame is also creating its own animation.

00:18:14.640 --> 00:18:16.080
But what's this?

00:18:16.080 --> 00:18:21.640
Its duration is 1.0 not 2.0 like the other one.

00:18:21.640 --> 00:18:26.630
Well, in your application, this might result
in out of sink applications or animations

00:18:26.630 --> 00:18:32.600
where two different animations are of a
different speed, not really what you want.

00:18:32.600 --> 00:18:34.850
Well, the system helps you out here again.

00:18:34.850 --> 00:18:39.210
And when you nest animation blocks one within another,

00:18:39.210 --> 00:18:43.550
the inner one will automatically
inherit the duration of the outer one.

00:18:43.550 --> 00:18:49.360
So, although you've specified one, it will
inherit that 2.0 from the outer animation

00:18:49.360 --> 00:18:53.030
and that is the duration that will actually be used.

00:18:53.030 --> 00:18:53.500
That's great.

00:18:53.500 --> 00:18:58.060
But what if you actually did mean 1.0?

00:18:58.060 --> 00:19:03.460
You can disable this inheritance
using OverrrideInheritedDuration.

00:19:03.460 --> 00:19:11.050
Alright. So, in this case, the 1.0 would actually be
used because I specified OverrrideInheritedDuration.

00:19:11.050 --> 00:19:15.500
The same concept applies directly to curves.

00:19:15.500 --> 00:19:19.890
If you have nested animation, curves are also inherited.

00:19:19.890 --> 00:19:26.140
You can disable this inheritance
using OverrideInheritedCurve.

00:19:26.140 --> 00:19:29.240
Alright. That's the five advanced
options that I wanted to talk

00:19:29.240 --> 00:19:34.750
about for the basic UIView animations
API, repeat autoreverse.

00:19:34.750 --> 00:19:36.960
Consider interaction.

00:19:36.960 --> 00:19:44.140
And whether it should be on or off during your
animations, the different timing curves that you can use,

00:19:44.140 --> 00:19:53.930
turning on BeginFromCurrentState when appropriate, and being
able to override the inheritance of animation properties.

00:19:53.930 --> 00:19:59.630
Moving on, let's talk about transitions.

00:19:59.630 --> 00:20:07.770
Now, again, as I mentioned in the beginning, some perfect
examples of transitions are this one in Notes application.

00:20:07.770 --> 00:20:15.560
What's interesting here is that the UI is actually identical
in both the before and the after of the transition.

00:20:15.560 --> 00:20:18.370
It's the same note view, the same
buttons, everything is the same.

00:20:18.370 --> 00:20:24.120
What changes is the text on the note.

00:20:24.120 --> 00:20:27.830
Contrast that with the Weather app.

00:20:27.830 --> 00:20:32.340
On the Weather app, we have two
different UIs, the front and the back.

00:20:32.340 --> 00:20:39.140
And the transition, in this case, a flip
is used to animate between those two views.

00:20:39.140 --> 00:20:48.930
So, two examples, you might have guessed it, we have two
APIs to make both of those examples very easy to write.

00:20:48.930 --> 00:20:52.130
The first one is called transitionWithView.

00:20:52.130 --> 00:20:57.620
And the API name implies that you're passing in one view.

00:20:57.620 --> 00:21:00.220
So, what do you do?

00:21:00.220 --> 00:21:05.820
Well, you make changes to your view,
and the system takes care of animating

00:21:05.820 --> 00:21:09.620
between the before and the after of your changes.

00:21:09.620 --> 00:21:14.800
So, well, just remember this, transitionWithView, and
then you pass in your view that you want the animation on.

00:21:14.800 --> 00:21:20.090
This is the full API, but transitionWithView
is the part to remember.

00:21:20.090 --> 00:21:25.480
Now, let's look at an example of using transitionWithView.

00:21:25.480 --> 00:21:34.180
This is the code flipToNextPage that could be behind the
pushing of the Next Page button in the notes example.

00:21:34.180 --> 00:21:42.360
So, when I push this, my notepadPages object is going
to give me the text as an NSString for the nextPage.

00:21:42.360 --> 00:21:53.810
I have a noteView which can display this note to the user,
and I'm going to set the nextPageText on the noteView.

00:21:53.810 --> 00:22:00.870
Finally, after I've made the changes to my view, I'm
going call tansitionWithView and pass in the noteView.

00:22:00.870 --> 00:22:05.280
You'll notice in the options here, I've said
I want to CurlUp animation, and that's it.

00:22:05.280 --> 00:22:10.190
That's all it takes to get that CurlUp and that
transition from one page of text to another.

00:22:10.190 --> 00:22:13.290
I want to make a special point here.

00:22:13.290 --> 00:22:13.760
What did I do?

00:22:13.760 --> 00:22:16.420
I just moved this set text line.

00:22:16.420 --> 00:22:21.520
It was before the transitionWithView, now it's after.

00:22:21.520 --> 00:22:23.280
What's the difference?

00:22:23.280 --> 00:22:24.940
Well, there is none.

00:22:24.940 --> 00:22:29.900
You should know that any changes that you make
during the current core animation transaction,

00:22:29.900 --> 00:22:35.520
we haven't talk about that yet, so unless you've created
one explicitly, that would be the current runloop.

00:22:35.520 --> 00:22:40.770
Any changes that you make in that transaction
would be reflected in the animation.

00:22:40.770 --> 00:22:46.020
The system is going to take a snapshot of what you're
view used to look like, and then you make all your changes

00:22:46.020 --> 00:22:48.920
and then you'll get that transition to the new state.

00:22:48.920 --> 00:22:55.850
So, it doesn't matter the order that you make your
changes in here, beautiful CurlUp animation nice.

00:22:55.850 --> 00:23:04.400
Alright. So, the second API for doing transitions,
transitionFromView: toView: As you can see by the name

00:23:04.400 --> 00:23:07.870
of the API, it takes two different views.

00:23:07.870 --> 00:23:12.310
You use this when you want to animate between the two views.

00:23:12.310 --> 00:23:17.420
The system will take care of removing
the first view from your view hierarchy

00:23:17.420 --> 00:23:20.990
and replacing it with the second view that you pass in.

00:23:20.990 --> 00:23:29.370
So, again, remember transitionFromView:toView:
Easy to see how this works in an example.

00:23:29.370 --> 00:23:31.980
This example is even simpler than the Notes one.

00:23:31.980 --> 00:23:35.160
This is my flipToWidgetBackside method which is invoked

00:23:35.160 --> 00:23:40.620
when the user presses the Info button
on the front of the Weather app.

00:23:40.620 --> 00:23:47.490
When this happens, I have a contentView, and
the contentView has the frontView as a child.

00:23:47.490 --> 00:23:52.520
All I need to do to get that flipped to
the backside is called transitonFromView:

00:23:52.520 --> 00:23:57.230
pass in the frontView, toView: pass in the backView.

00:23:57.230 --> 00:24:04.130
And then after that transition completes, not only will it
animate with that flip, but after that animation completes,

00:24:04.130 --> 00:24:10.930
the content view will contain the backView as a
child because the system automatically replaced it.

00:24:10.930 --> 00:24:12.270
What does that look like?

00:24:12.270 --> 00:24:14.280
Nice flip, alright.

00:24:14.280 --> 00:24:19.930
So, you can see transition very simple, two different
APIs, one that takes one view that you make changes to,

00:24:19.930 --> 00:24:27.670
and the second API where you provide both views and you get
a transition between both of those views, just that easy.

00:24:27.670 --> 00:24:30.160
Right, we've talked about a few things here.

00:24:30.160 --> 00:24:36.510
I'd like to invite my coworker Tyler Hawkins up to give you
a demo of what this could look like in your application.

00:24:36.510 --> 00:24:39.040
[ Applause ]

00:24:39.040 --> 00:24:41.470
>> Tyler Hawkins: Thanks so much.

00:24:41.470 --> 00:24:42.830
So, yeah, my name is Tyler Hawkins.

00:24:42.830 --> 00:24:44.890
I'm also an iOS Software Engineer.

00:24:44.890 --> 00:24:49.970
And I'm really excited to show you some
implementation of these great animations we've seen,

00:24:49.970 --> 00:24:54.140
and how you get your costumers really excited about this,
and get them to buy your apps and download your apps.

00:24:54.140 --> 00:24:59.300
A little bit about me, I love gardening, but you
know, we're all software engineers, we're busy, right?

00:24:59.300 --> 00:25:00.140
We're at work at lot.

00:25:00.140 --> 00:25:03.030
I don't always get to get home and water my plants.

00:25:03.030 --> 00:25:09.950
So, I've made this demo app, which I call iPlant which
helps me automate watering my plants even while I'm at work.

00:25:09.950 --> 00:25:13.930
And I will switch it so you can see it too.

00:25:13.930 --> 00:25:16.430
There you go.

00:25:16.430 --> 00:25:17.390
That's better.

00:25:17.390 --> 00:25:18.990
So yeah, this is iPlant.

00:25:18.990 --> 00:25:22.130
The way it works is we've got this vegetable spinner here,

00:25:22.130 --> 00:25:26.300
so I can click around on it, and
it's like my carrots or my sprouts.

00:25:26.300 --> 00:25:31.390
Click the middle drips button there, and my
robotic gardener at home will water them.

00:25:31.390 --> 00:25:37.740
And on the back of it, we've got a simple webcam where I
can see how, you know, the mint and stuff is growing there.

00:25:37.740 --> 00:25:39.950
Well, yeah, obviously, it's not animated.

00:25:39.950 --> 00:25:41.950
Let's fix that.

00:25:41.950 --> 00:25:47.090
When we click on the spinner, on these
different vegetables, if this method right here,

00:25:47.090 --> 00:25:51.010
selects or Set Selected Vegetable or Veg, that gets called.

00:25:51.010 --> 00:25:53.820
Wherein we Set the Selected Vegetable icon,

00:25:53.820 --> 00:25:58.650
which is this colorful icon right here
to be hit, we set its Alpha to zero.

00:25:58.650 --> 00:26:06.560
We then get the angle of the selected button on the
spinner, and we set that to the spinner itself to rotate it.

00:26:06.560 --> 00:26:13.480
Finally, we set the Alpha of the selected vegetable
to be 1 again to expose the newly selected vegetable.

00:26:13.480 --> 00:26:16.320
For this, you know, obviously, we're spinning something.

00:26:16.320 --> 00:26:17.480
We're doing a rotation already.

00:26:17.480 --> 00:26:19.840
Wouldn't that be cool if we could make that animate.

00:26:19.840 --> 00:26:21.020
It's really simple.

00:26:21.020 --> 00:26:21.830
So, let's go and do that.

00:26:21.830 --> 00:26:28.820
So, what I'm going to do is I'm just going to insert this
animations API with blocks, and the part that we want

00:26:28.820 --> 00:26:32.990
to have happen first here is hiding the selected vegetable.

00:26:32.990 --> 00:26:33.960
We don't even need to animate that.

00:26:33.960 --> 00:26:35.520
We can just hide it right away.

00:26:35.520 --> 00:26:40.870
Well, like I said, the part that'll look really cool
to animate is the rotation of the vegetable spinner.

00:26:40.870 --> 00:26:42.990
So, I'm just going to fix the indenting.

00:26:42.990 --> 00:26:45.990
I've moved that now within the animation block.

00:26:45.990 --> 00:26:49.050
So that's the part of the code that's
actually going to get animated.

00:26:49.050 --> 00:26:53.440
We have completion as well, and that's where
we want to put the exposing or the showing

00:26:53.440 --> 00:26:56.900
of the selected vegetable after everything is done.

00:26:56.900 --> 00:27:07.170
So, just that quickly, we get this cool effect where,
you know, we're hiding it, we're getting a rotation.

00:27:07.170 --> 00:27:12.290
You know, and if you did that on your own, you'd have to
work our crazy things like nature qualifications to probably

00:27:12.290 --> 00:27:15.200
to rotate it, but you know, we're doing it all for
free, so you might as well take advantage of it.

00:27:15.200 --> 00:27:16.780
It looks pretty cool.

00:27:16.780 --> 00:27:19.740
Next, let's get this watering procedure working right.

00:27:19.740 --> 00:27:23.130
You know, when water gets taken out of
a tank, it doesn't just drop instantly,

00:27:23.130 --> 00:27:26.450
it moves smoothly, and this number also changing.

00:27:26.450 --> 00:27:30.730
It doesn't look so great, it just kind of
blitz between, you know, 60 to 50 or whatever.

00:27:30.730 --> 00:27:33.720
So, let's make that animated.

00:27:33.720 --> 00:27:39.650
When we click on the Drips button, it's this method right
here which is startWateringProcedure that gets called.

00:27:39.650 --> 00:27:45.240
Here, we create a robo-gardener object which
gets in touch with my robot at my apartment,

00:27:45.240 --> 00:27:48.640
and then we tell him to water the plants.

00:27:48.640 --> 00:27:54.820
Then we get the new water level from him, because
he's given some water to the onions, in this case,

00:27:54.820 --> 00:28:01.930
and we want to set that to the volume label, which
is this white label here, and then also set the frame

00:28:01.930 --> 00:28:06.880
of the water view, which is the blue view, which
we can barely see to be the correct level as well.

00:28:06.880 --> 00:28:13.150
So, when I'm talking about animating, and also in the
same, you know, breath talking about changing a text label,

00:28:13.150 --> 00:28:19.240
a little red flag should go up for you because changing
text in a label really isn't something that's animated.

00:28:19.240 --> 00:28:22.430
But we can find a way to get around that here.

00:28:22.430 --> 00:28:28.570
What we can do, in this case, how about we hide
the label before we set the text 'cause otherwise,

00:28:28.570 --> 00:28:32.120
it is just going to blitz between them, which
you know, doesn't really look too great.

00:28:32.120 --> 00:28:36.260
So, first and foremost, we'll just do some
property changes before we get animated.

00:28:36.260 --> 00:28:39.790
We'll set the Alpha to 0 before we set the text.

00:28:39.790 --> 00:28:45.390
And then how about after we set the text, we show it again.

00:28:45.390 --> 00:28:52.950
And now, we do want stuff to animate here, so I'm going
to drop in another one of the blocks API with completion.

00:28:52.950 --> 00:28:57.130
We do want the volume label hiding this time to fade out.

00:28:57.130 --> 00:28:58.910
So, we'll drop that within our animation block.

00:28:58.910 --> 00:29:04.810
But when it completes, we still want everything else
like the water level changing to animate as well.

00:29:04.810 --> 00:29:15.830
So, we'll put in just a simple animation block
like that, and throw everything else within it.

00:29:15.830 --> 00:29:18.220
Build and run.

00:29:18.220 --> 00:29:21.930
You know, that quickly, we're getting something
really quite neat - we're fading out the text,

00:29:21.930 --> 00:29:28.340
changing it while the user can't see it, fading it back
in after that's done, and lowering the level of the water.

00:29:28.340 --> 00:29:30.900
I think it looks pretty good, and it's pretty simple.

00:29:30.900 --> 00:29:36.140
Something else to note, and if you look at blocks
and you look at how they work with closures,

00:29:36.140 --> 00:29:42.000
it's cool because this robot object that I
have here, it's autorelease, but the block--

00:29:42.000 --> 00:29:46.040
or the blocks architecture is taking care
of retaining a reference to it for me.

00:29:46.040 --> 00:29:51.840
So I don't have to worry about manually managing
that memory like you might have with the older API.

00:29:51.840 --> 00:29:56.360
There's one last thing that we still would love
to have animate, and that's this transition

00:29:56.360 --> 00:29:58.950
between the front and the back of the app.

00:29:58.950 --> 00:30:01.090
Let's do that too.

00:30:01.090 --> 00:30:06.940
When we click on the Info button, the little I on
the bottom, right, this method showBack gets called.

00:30:06.940 --> 00:30:11.270
Right now what we're doing is we're just removing
the frontView and then throwing in the backView.

00:30:11.270 --> 00:30:15.030
You know, that's OK, but it doesn't look super good.

00:30:15.030 --> 00:30:18.880
So, we can use the new transitionFromView:toView :API.

00:30:18.880 --> 00:30:25.210
In this case, we want to go from
the frontView to the backView.

00:30:25.210 --> 00:30:30.660
We could get rid of the stuff that was already there.

00:30:30.660 --> 00:30:36.400
It's already been prepopulated just from where we're copying
it from with some duration and the flipping from left,

00:30:36.400 --> 00:30:39.660
but it'll take care of now removing
those from their super view

00:30:39.660 --> 00:30:43.050
and some other stuff that we used to have to do on our own.

00:30:43.050 --> 00:30:47.080
So just like that, we get that cool quasi-3D
flipping over effect that you've seen everywhere.

00:30:47.080 --> 00:30:50.640
We still don't have it working on the
way back, so let's do that right now.

00:30:50.640 --> 00:30:55.690
When Done gets clicked or tapped, showFront gets called.

00:30:55.690 --> 00:30:58.990
And I just want to emphasize that when you're
doing this on your own, do it symmetrically.

00:30:58.990 --> 00:31:04.420
If you're going to one side with transitionFromView:toView:
you know use the same API on the way back.

00:31:04.420 --> 00:31:07.130
But here just to illustrate the transitionWithView,

00:31:07.130 --> 00:31:10.750
I'm going to be using that just to
give you an idea of how it looks.

00:31:10.750 --> 00:31:14.520
So, on the way back what we can do is we
just leave the code that we already had there

00:31:14.520 --> 00:31:17.490
for removing the views and adding in the new one.

00:31:17.490 --> 00:31:22.500
And instead, we'll pass the transitionWithView
API the containerView

00:31:22.500 --> 00:31:26.400
which in this case the UIViewController's view.

00:31:26.400 --> 00:31:31.290
And by doing that, we get the very same effect.

00:31:31.290 --> 00:31:36.430
And it's really this simple, there are lots of
really hot things you can do with this new API.

00:31:36.430 --> 00:31:41.360
And this is all available for you guys to take a
look at after we're done on the developer site.

00:31:41.360 --> 00:31:43.510
So thanks very much.

00:31:43.510 --> 00:31:48.400
[ Applause ]

00:31:48.400 --> 00:31:49.980
>> Andre Boule: Thanks Tyler.

00:31:49.980 --> 00:31:54.130
Alright, what are we going to talk about next?

00:31:54.130 --> 00:31:59.060
As I talked about in the beginning of the talk one
of the things that's really important to support

00:31:59.060 --> 00:32:03.770
in your app is support for different orientations.

00:32:03.770 --> 00:32:13.200
As you guys know in the first OS release, iPhone 1.0,
many of our built-in apps only supported portrait.

00:32:13.200 --> 00:32:18.170
We heard very loudly from users that
they wanted support for landscape.

00:32:18.170 --> 00:32:21.360
So, the same is probably true for your apps as well.

00:32:21.360 --> 00:32:25.540
How do we get that nice transition to and from portrait?

00:32:25.540 --> 00:32:28.120
We're going to talk about that now.

00:32:30.970 --> 00:32:35.920
And one of the reasons you may want to do it, by the
way, is because the keyboard is bigger in landscape,

00:32:35.920 --> 00:32:40.300
so it may be easier for some users to use it.

00:32:40.300 --> 00:32:42.010
But you should think about your UI.

00:32:42.010 --> 00:32:48.950
The screen has a different aspect ratio in portrait than
it is in landscape, so it may make more sense for you

00:32:48.950 --> 00:32:52.890
to have a different UI in one orientation or another.

00:32:52.890 --> 00:32:53.900
Let's look at an example.

00:32:53.900 --> 00:32:55.490
I picked this one at random, believe me.

00:32:55.490 --> 00:32:58.450
It's the YouTube app on iPad.

00:32:58.450 --> 00:33:06.610
And the goal when we created this app was to have a
nice widescreen viewing experience in both orientations.

00:33:06.610 --> 00:33:13.330
So, in portrait, the viewport for the video
covers the entire width of the display,

00:33:13.330 --> 00:33:19.150
and that leaves us room below the video for these
big beautiful thumbnails for the related videos.

00:33:19.150 --> 00:33:27.240
When the user rotates to landscape, again, we have a nice
widescreen viewing experience for the video, but now,

00:33:27.240 --> 00:33:34.380
we have some room for the thumbnails in a right bar on
the side of the screen and the info below the screen.

00:33:34.380 --> 00:33:38.470
So, during that animation, that
bar on the right needs to slide in.

00:33:38.470 --> 00:33:42.680
How do we do that?

00:33:42.680 --> 00:33:48.580
Well, if you're using ViewControllers,
your job is actually pretty easy.

00:33:48.580 --> 00:33:54.300
All you need to do is tell the system
which orientation your app supports.

00:33:54.300 --> 00:33:59.580
You do this by overriding
shouldAutorotateToInterfaceOrientation.

00:33:59.580 --> 00:34:07.110
The system will query you with different orientations, and
you just say yes if you support it and no if you don't.

00:34:07.110 --> 00:34:11.260
As a result of that, when the user rotates the device,

00:34:11.260 --> 00:34:15.540
the system will automatically manage
a bunch of different things.

00:34:15.540 --> 00:34:17.330
The first is the rotation transform.

00:34:17.330 --> 00:34:21.830
Obviously, the top-level view of your
ViewController needs to have a rotation applied

00:34:21.830 --> 00:34:25.890
such that the view is rotated and the user can read it.

00:34:25.890 --> 00:34:29.220
The view frame of your view will be
different in the new orientation.

00:34:29.220 --> 00:34:37.870
And this is again because in portrait the device is
tall and narrow, and in landscape, it's wide and short.

00:34:37.870 --> 00:34:40.770
So, you'll get a new view frame.

00:34:40.770 --> 00:34:46.560
Both of these things will happen in an animated
fashion because we don't want the view to just pop

00:34:46.560 --> 00:34:50.800
to the new rotation and size, we want that to animate.

00:34:50.800 --> 00:34:55.370
So, this system creates an animation for this.

00:34:55.370 --> 00:34:59.030
The Status bar also needs to follow your app's orientation.

00:34:59.030 --> 00:35:01.190
So, the system will change the Status bar.

00:35:01.190 --> 00:35:09.670
And finally, again, when you're creating animations
especially rotation ones it's probably the right thing

00:35:09.670 --> 00:35:12.940
to turn off user interaction during
the rotation animation itself.

00:35:12.940 --> 00:35:14.580
So, the system does that too.

00:35:14.580 --> 00:35:17.220
What do you have to do?

00:35:17.220 --> 00:35:23.390
Well your job is to layout your UI for
the appropriate way for the orientation.

00:35:23.390 --> 00:35:32.440
In this example, I have a UIView subclass from my
ViewController's view, and I've overridden layout subviews.

00:35:32.440 --> 00:35:37.880
In my layout subviews, I checked for the
interface orientation, and if it's landscape,

00:35:37.880 --> 00:35:43.040
I do one particular layout, and if
it's portrait, I do my portrait layout.

00:35:43.040 --> 00:35:51.350
Now the beautiful thing is that this will actually
be called within that window rotation animation.

00:35:51.350 --> 00:35:52.060
What's the result?

00:35:52.060 --> 00:35:58.190
Well, if you change some frames or set some Alphas or things
like that, any animatable property changes that you make

00:35:58.190 --> 00:36:05.030
within the layout subviews they will animate
automatically, you don't even have to create the animation.

00:36:05.030 --> 00:36:08.150
The system just does it for you.

00:36:08.150 --> 00:36:09.040
That's great.

00:36:09.040 --> 00:36:13.960
But of course, in the YouTube example,
you know, I have that bar on the right.

00:36:13.960 --> 00:36:17.670
It's only there in landscape, it's not there in portrait.

00:36:17.670 --> 00:36:22.480
And so, certainly, layout subviews is not
an appropriate place to be making changes

00:36:22.480 --> 00:36:25.460
to your view hierarchy, you know,
adding views or moving views.

00:36:25.460 --> 00:36:29.100
You definitely don't want to do that in layout subviews.

00:36:29.100 --> 00:36:30.600
So what do we do?

00:36:30.600 --> 00:36:33.640
Well there's a solution.

00:36:33.640 --> 00:36:38.620
You have some methods in your ViewController
that you can override,

00:36:38.620 --> 00:36:42.830
and they will be called before,
during, and after the animation.

00:36:42.830 --> 00:36:49.770
So, the first one is willRotate, and this
will be called on your ViewController,

00:36:49.770 --> 00:36:56.610
and when the user has changed the device orientation,
it's called just before that animation starts.

00:36:56.610 --> 00:37:04.750
So, willRotate is the perfect place to be putting in
views that will become visible in the new orientation.

00:37:04.750 --> 00:37:08.370
So, if I'm rotating from portrait to landscape in Youtube,

00:37:08.370 --> 00:37:12.470
that's when that right bar would
get added to the view hierarchy.

00:37:12.470 --> 00:37:17.620
willRotate will be followed by
a call to willAnimateRotation.

00:37:17.620 --> 00:37:24.070
This is just before the animation, but again,
the system has created an animation for us

00:37:24.070 --> 00:37:32.100
and willAnimateRotation is called within that animation,
which means that any animatable properties that you change

00:37:32.100 --> 00:37:37.300
within willAnimateRotation will be animated.

00:37:37.300 --> 00:37:42.840
So, if you make some frame changes in here or
Alpha changes and whatnot, those will be animated.

00:37:42.840 --> 00:37:49.530
Now a special note, if you do make frame changes and you
want those to trickle down to all of the layout subviews

00:37:49.530 --> 00:37:55.510
of the subviews, make those frame changes and
then at the very end, call layout if needed.

00:37:55.510 --> 00:38:01.190
And then all your layout subviews methods will be
called as well, and again, within that animation.

00:38:01.190 --> 00:38:05.390
So, they will be animated as well.

00:38:05.390 --> 00:38:10.620
Finally at the end of the rotation
animation, you'll get a call to didRotate.

00:38:10.620 --> 00:38:15.700
Perfect place to do some post animation cleanup.

00:38:15.700 --> 00:38:23.000
If I'm rotating in YouTube from a landscape to
portrait, well after the animation is complete,

00:38:23.000 --> 00:38:29.490
there's no more bar on the right side of the screen, so I
can go ahead and remove that view from the view hierarchy.

00:38:30.830 --> 00:38:34.050
These are the methods, the full method names.

00:38:34.050 --> 00:38:41.330
But notice I've highlighted in yellow the parts for you to
remember: willRotate, willAnimateRotation, and didRotate.

00:38:41.330 --> 00:38:47.830
So, if you are using ViewController, that's really all
it takes to get a good window rotations in your app.

00:38:47.830 --> 00:38:51.820
Now, some of you may not be using ViewControllers.

00:38:51.820 --> 00:38:54.670
How do you get rotation in your apps?

00:38:54.670 --> 00:39:00.900
Well, you need to listen for device
orientation changed notifications.

00:39:00.900 --> 00:39:04.090
And in response to that, there is a
bunch of work that you need to do.

00:39:04.090 --> 00:39:10.370
You need to change your rotation transform, your view
frame, the animation for both those things, the Status bar,

00:39:10.370 --> 00:39:13.130
disabling of User Interaction,
does that look familiar at all?

00:39:13.130 --> 00:39:17.490
I mean all of the things that we just talked
about that ViewController does for you, now,

00:39:17.490 --> 00:39:21.570
because you are not using ViewControllers,
you have to take care of that yourself.

00:39:21.570 --> 00:39:24.500
So, what's the message here?

00:39:24.500 --> 00:39:30.740
If all you use ViewControllers for is to get the
rotation support, it's worth it just for that.

00:39:30.740 --> 00:39:36.640
So, it's, you know, very easy to go in and just put
in a ViewController in your app that doesn't have one.

00:39:36.640 --> 00:39:39.950
And it will make your life a whole
lot simpler for rotations.

00:39:39.950 --> 00:39:41.680
So, I encourage you to do that.

00:39:41.680 --> 00:39:44.860
Let's talk about performance.

00:39:44.860 --> 00:39:50.430
The iPhone is truly magical with, you know,
when you are interacting with the thing,

00:39:50.430 --> 00:39:55.850
it looks like magic because everything is just
so smooth, it feels like a physical thing.

00:39:55.850 --> 00:39:59.250
That illusion is completely ruined
if your animations are choppy.

00:39:59.250 --> 00:40:03.000
So, it's critically important to
get great performance as you know.

00:40:03.000 --> 00:40:09.000
So, my first message for you here is it's
absolutely important to test on real devices.

00:40:09.000 --> 00:40:11.490
This simulator is great.

00:40:11.490 --> 00:40:14.310
I use it for almost all of my application development,

00:40:14.310 --> 00:40:18.470
but when it comes time to measuring
performance, it's just not appropriate to use.

00:40:18.470 --> 00:40:24.390
Its performance characteristics are completely
different than that of an iPhone, iPod touch or iPad.

00:40:24.390 --> 00:40:29.350
The different hardware generations have
different performance characteristics as well.

00:40:29.350 --> 00:40:34.740
So, I encourage you to test on multiple
devices of each of the different generations.

00:40:34.740 --> 00:40:39.590
You can use instruments to get a
precise measurement of your performance.

00:40:39.590 --> 00:40:45.840
Many times, performance is so bad that it's
extremely visible both to you and to your users.

00:40:45.840 --> 00:40:53.020
But once you've optimized it, and you're up to, you know,
40, 50, 55 frames per second, it gets pretty tough to tell

00:40:53.020 --> 00:40:56.990
if the change that you've made has
made performance worse or better.

00:40:56.990 --> 00:40:59.070
But instruments can measure it very precisely.

00:40:59.070 --> 00:41:05.450
So, you can use that and see if you're
making performance better or worse.

00:41:05.450 --> 00:41:08.420
So, how do we make performance better?

00:41:08.420 --> 00:41:12.970
A few of these go without saying,
but I'm going to say them anyway.

00:41:12.970 --> 00:41:19.120
During your animation is not the appropriate
time to calculate Pi to a million digits.

00:41:19.120 --> 00:41:25.300
Save that for after your animation, please,
if you want your animations to be smooth.

00:41:25.300 --> 00:41:31.620
If you have views in your app that are not visible
to the user, there's a cost to those views.

00:41:31.620 --> 00:41:36.900
So, if you can remove them from the view hierarchy,
they're not providing any benefit otherwise, right.

00:41:36.900 --> 00:41:41.100
Take non-visible views out of the
view hierarchy during your animations.

00:41:41.100 --> 00:41:43.820
It can definitely improve your animation performance.

00:41:43.820 --> 00:41:51.370
And finally, don't try to draw every
frame of the animation using drawRect.

00:41:51.370 --> 00:41:57.820
You're not taking advantage of the hardware acceleration
behind UIView and CoreAnimations when you do that.

00:41:57.820 --> 00:42:01.360
So, use the APIs that we provide you to get your animations.

00:42:01.360 --> 00:42:10.060
View hierarchy depth is another critical thing to consider
when you're measuring the performance of your app.

00:42:10.060 --> 00:42:12.010
Let's look at an example.

00:42:12.010 --> 00:42:14.230
This example is called iFruit.

00:42:14.230 --> 00:42:18.210
And this is one table cell from my iFruit app.

00:42:18.210 --> 00:42:18.770
What does it do?

00:42:18.770 --> 00:42:25.980
Well, it displays an image of my fruit, the name
of it, and a bunch of classification information.

00:42:25.980 --> 00:42:28.210
It looks harmless enough, right?

00:42:28.210 --> 00:42:30.580
In reality, of course, this isn't what my app looks like.

00:42:30.580 --> 00:42:32.730
My app looks more like this.

00:42:32.730 --> 00:42:35.010
There's a bunch of these table cells.

00:42:35.010 --> 00:42:36.350
Well, what's going on here?

00:42:36.350 --> 00:42:41.890
I mean when you look at this, each one of
those things in a dotted outline is a view.

00:42:41.890 --> 00:42:43.840
That's a lot of views.

00:42:43.840 --> 00:42:48.520
I have about 10 views for each table cell.

00:42:48.520 --> 00:42:53.790
So, that's a lot of compositing that the
system needs to do to animate this table

00:42:53.790 --> 00:42:57.140
when you're animating the scroller for instance.

00:42:57.140 --> 00:43:00.200
So, if you can reduce the depth of your view hierarchy,

00:43:00.200 --> 00:43:06.580
it will absolutely make the scrolling
faster in this app, a whole lot faster.

00:43:06.580 --> 00:43:08.610
What could you do?

00:43:08.610 --> 00:43:10.990
Well, in this case, they're just static labels.

00:43:10.990 --> 00:43:14.660
I've used UI labels in this case and UIImageView.

00:43:14.660 --> 00:43:23.740
If instead of doing that, I simply draw in the super
view which is the main contents view of this cell,

00:43:23.740 --> 00:43:31.300
I could reduce this example to one or two with
a separator, but almost of one view per cell.

00:43:31.300 --> 00:43:37.470
So, it would have a dramatic impact just by
converting from using UILabel to a drawRect.

00:43:37.470 --> 00:43:41.840
It's less for the system to composite if it's only one view.

00:43:41.840 --> 00:43:44.930
And in many cases, it'll use less memory too.

00:43:44.930 --> 00:43:46.790
So, I'm not telling you not to use UILabel.

00:43:46.790 --> 00:43:51.600
UILabel is really handy in a lot of
situations, but I want you to understand

00:43:51.600 --> 00:43:55.350
that there is a cost to every view that you put in your app.

00:43:55.350 --> 00:43:59.540
So, if you can reduce the number of
views, your performance will improve.

00:43:59.540 --> 00:44:06.240
Now, of course, you can't always use a drawRect solution.

00:44:06.240 --> 00:44:10.810
I just finished telling you that you
shouldn't draw every frame of your animation.

00:44:10.810 --> 00:44:13.600
Let the system animate things right?

00:44:13.600 --> 00:44:17.160
What if I want to animate the position
of these subelements within the cell?

00:44:17.160 --> 00:44:22.810
I can't use drawRect in that case.

00:44:22.810 --> 00:44:31.360
If I had UIControls, some buttons or sliders or whatnot
in the cell, also drawRect is not going to work there.

00:44:31.360 --> 00:44:38.280
If you have an otherwise complex view hierarchy that's just
not practical to draw, you can't use a drawRect solution.

00:44:38.280 --> 00:44:39.290
So, what do you do?

00:44:39.290 --> 00:44:44.290
Well, I'm going to talk about a solution that
you can use today called shouldRasterize.

00:44:45.640 --> 00:44:50.890
What shouldRasterize does is render an entire
view hierarchy, a view and all of its subviews.

00:44:50.890 --> 00:44:55.700
It renders that off-screen and caches
the result and uses that cached result.

00:44:55.700 --> 00:45:01.300
Now, I have to warn you that shouldRasterize
is like a very sharp knife.

00:45:01.300 --> 00:45:07.210
Sharp knives are great for chopping up
fruit, but you can cut yourself very easily.

00:45:07.210 --> 00:45:12.650
shouldRasterize can hurt performance
just as easily as it can improve it.

00:45:12.650 --> 00:45:16.790
But it's important to talk about it here
because it can have dramatic results.

00:45:16.790 --> 00:45:17.180
That's it.

00:45:17.180 --> 00:45:23.830
If you have animated subviews and that the
superview of those subviews has shouldRasterize,

00:45:23.830 --> 00:45:27.090
your performance will suffer because
you're rendering off-screen

00:45:27.090 --> 00:45:33.410
and caching this thing that's no longer
going to be valid when the subviews animate.

00:45:33.410 --> 00:45:38.130
There's a limited cache size that's
available for shouldRasterize.

00:45:38.130 --> 00:45:44.650
So, if you go and turn on shouldRasterize on every
view in your app, your performance will get worse.

00:45:44.650 --> 00:45:45.480
That's it.

00:45:45.480 --> 00:45:51.440
If you turn it on in those places where it's appropriate
and only those places, and only for the time during

00:45:51.440 --> 00:45:55.900
at which it's appropriate, you can
turn this on and off as you want.

00:45:55.900 --> 00:46:00.560
If you turn it on in just those right places,
it will dramatically improve your performance.

00:46:00.560 --> 00:46:05.530
So, in my iFruit example that I just showed you,
when the user is scrolling around on the tableView,

00:46:05.530 --> 00:46:08.540
I would turn on shouldRasterize on the cell itself.

00:46:08.540 --> 00:46:12.370
And then when I want to animate the
subviews, then I would turn it off.

00:46:12.370 --> 00:46:13.390
Here's how you do it.

00:46:13.390 --> 00:46:15.530
Use it as little as you can.

00:46:15.530 --> 00:46:17.370
I've warned you.

00:46:17.370 --> 00:46:22.170
_myView.layer.shouldRasterize = YES.

00:46:25.290 --> 00:46:31.720
OK. A couple of performance pitfalls, things
that are very expensive for the system to do.

00:46:31.720 --> 00:46:37.900
Any views that are non-opaque, transparent
views are very expensive in our systems.

00:46:37.900 --> 00:46:42.530
Any layers that require off-screen
rendering are very expensive.

00:46:42.530 --> 00:46:45.120
Now shouldRasterize layers off-screen, right?

00:46:45.120 --> 00:46:47.800
Yeah, but it caches, so it's a special case.

00:46:47.800 --> 00:46:50.780
Anything that renders off-screen
and doesn't cache is very expensive.

00:46:50.780 --> 00:46:52.460
Now, what is this exactly?

00:46:52.460 --> 00:46:55.770
I'm not going to go into detail
here because we don't have the time.

00:46:55.770 --> 00:47:00.950
But there are some performance sessions in
advanced CoreAnimation sessions that will describe

00:47:00.950 --> 00:47:03.070
to you exactly what these two things are.

00:47:03.070 --> 00:47:09.160
But what I want to highlight very quickly is in instruments
when you run with performance tool CoreAnimation.

00:47:09.160 --> 00:47:12.230
Well, as you saw, it gives me a
nice big 60 frames per second.

00:47:12.230 --> 00:47:18.560
Nice. And in the bottom left, there's this box
in which you can turn on different options.

00:47:18.560 --> 00:47:20.050
Let's blow that up.

00:47:20.050 --> 00:47:24.840
You can turn on color-blended layers,
and color off-screen rendered views.

00:47:24.840 --> 00:47:30.000
And those things that flash when you turn that
on, those are the things that are really expensive

00:47:30.000 --> 00:47:34.110
and that will hurt your performance, and
so you want to try to minimize those.

00:47:34.110 --> 00:47:42.700
If you want to know more about these two things, you can
go to the Advanced Performance Optimizations on iPhone talk

00:47:42.700 --> 00:47:46.450
or the CoreAnimation in Practice talk Part 2.

00:47:46.450 --> 00:47:51.270
Part 2 is given by one of the CoreAnimation gurus
who really knows the stuff, and he's going to explain

00:47:51.270 --> 00:47:56.180
in detail how it works, how it's
implemented, and why it's expensive.

00:47:56.180 --> 00:48:01.590
So, I would encourage you to go to those talks.

00:48:01.590 --> 00:48:03.380
Alright. Let's talk about CoreAnimation.

00:48:03.380 --> 00:48:09.300
Again, one question we've gotten from you
guys is when should I use UIViewAnimations?

00:48:09.300 --> 00:48:11.330
When should I use CoreAnimation?

00:48:11.330 --> 00:48:12.290
It's interesting.

00:48:12.290 --> 00:48:16.280
I mean they're kind of separate APIs, and
they both have their pros and cons, right?

00:48:16.280 --> 00:48:18.300
When should you use each of them?

00:48:18.300 --> 00:48:20.740
Well, here's my advice to you.

00:48:20.740 --> 00:48:24.060
Use UIViewAnimations whenever possible.

00:48:24.060 --> 00:48:29.580
The API is consistent with the rest of UIKit
and designed to work with the rest of UIKit.

00:48:29.580 --> 00:48:34.880
So, the vast majority of times,
you'll want to use UIViewAnimations.

00:48:34.880 --> 00:48:41.020
That said, CoreAnimation provides you with more power.

00:48:41.020 --> 00:48:44.100
If there's something that you can't
do with UIViewAnimations,

00:48:44.100 --> 00:48:49.360
it's possible that CoreAnimation does
enable you to do what you want to do.

00:48:49.360 --> 00:48:54.550
So, in those instances, you would dig down
into CoreAnimation and use it directly.

00:48:54.550 --> 00:48:58.550
Now, we talked about animatable properties.

00:48:58.550 --> 00:49:02.080
Well, the ones that I showed were
the frame, the Alpha, the transform.

00:49:02.080 --> 00:49:06.330
CoreAnimation exposes even more
animatable properties that you can use.

00:49:06.330 --> 00:49:11.110
So, if you need to use these, you
could go directly to CoreAnimation.

00:49:11.110 --> 00:49:15.220
We'll see an example of how to create
an animation with CoreAnimation.

00:49:15.220 --> 00:49:20.660
I want to talk very briefly about the different
types of animations within CoreAnimation.

00:49:20.660 --> 00:49:23.100
CoreAnimation works a little bit differently than UIKit.

00:49:23.100 --> 00:49:26.930
There's this thing called implicit animations.

00:49:26.930 --> 00:49:32.270
When you want to animate something
in UIKit, you create an animation,

00:49:32.270 --> 00:49:35.970
change your properties, and then commit the animations.

00:49:35.970 --> 00:49:42.530
If you don't have a layer delegate in CoreAnimation,
anytime you make a change to an animatable property,

00:49:42.530 --> 00:49:48.210
it will actually animate for you automatically without
having the need to create an explicit animation.

00:49:48.210 --> 00:49:51.790
So, it's something to keep in mind.

00:49:51.790 --> 00:49:56.900
You can also create explicit animations
using CABasicAnimation.

00:49:56.900 --> 00:49:59.710
That looks a little more similar to what we do in UIKit.

00:49:59.710 --> 00:50:07.090
So, I'm going to show you the same example opacity change
or the Alpha dissolve on my view as I did in the beginning

00:50:07.090 --> 00:50:12.680
of this session, except this time, we're going to
create that animation using CoreAnimation directly.

00:50:12.680 --> 00:50:16.810
So, it looks similar to what we did in UIView actually.

00:50:16.810 --> 00:50:23.490
I've created an animation using CABasicAnimation,
and I'm operating on the opacity property.

00:50:23.490 --> 00:50:26.900
That's CoreAnimation's word for Alpha in UIKit.

00:50:26.900 --> 00:50:32.790
I've set the toValue what I want to
animate to to one, duration 3 seconds,

00:50:32.790 --> 00:50:35.360
timing function that's kind of like curves in UIKit.

00:50:35.360 --> 00:50:39.190
You know, I've set it to ease in, ease out
to get that acceleration and deceleration.

00:50:39.190 --> 00:50:45.160
And finally, I add the animation to my
views layer myView.layer addAnimation.

00:50:45.160 --> 00:50:49.240
That's how you get to the CoreAnimation
layer from your view.

00:50:49.240 --> 00:50:50.520
What's the result?

00:50:50.520 --> 00:50:56.920
It looks exactly like it did in UIKit with one notable
exception, the view disappeared after my animation.

00:50:56.920 --> 00:50:58.520
Well, why is that?

00:50:58.520 --> 00:51:04.370
CoreAnimation, when you create animations, you're only
affecting that layer for the duration of the animation,

00:51:04.370 --> 00:51:09.120
you're not changing the property itself permanently.

00:51:09.120 --> 00:51:13.540
So, if you don't want your layer to
disappear at the end of the animation,

00:51:13.540 --> 00:51:17.490
you would just add this one line and explicitly set it to 1.

00:51:17.490 --> 00:51:25.300
And then not only will it animate like you expect,
but at the end of the animation, it will stay visible.

00:51:25.300 --> 00:51:30.820
So that's a key difference between UIViewAnimations
and CoreAnimation that I wanted to illustrate.

00:51:30.820 --> 00:51:37.410
So, what are some of those advanced
things that CoreAnimation enables you

00:51:37.410 --> 00:51:40.510
to do that you can't do directly with UIView?

00:51:40.510 --> 00:51:43.190
Well, motion along a path is one of them.

00:51:43.190 --> 00:51:46.160
When we animate with UIView and we
change the position of something,

00:51:46.160 --> 00:51:50.110
it animates directly in a straight
line from the From to the To.

00:51:50.110 --> 00:51:57.830
CoreAnimation allows us to pass in an
arbitrary CGPath to animate along that path.

00:51:57.830 --> 00:52:01.000
It's-- the easiest way to show this is with an example.

00:52:01.000 --> 00:52:03.510
So, let's invite Tyler back up for another demo.

00:52:03.510 --> 00:52:10.170
[ Applause ]

00:52:10.170 --> 00:52:10.260
>> Tyler Hawkins: OK.

00:52:10.260 --> 00:52:14.130
This isn't quite as coherent of
a demo, it's not a plant thing,

00:52:14.130 --> 00:52:17.460
it's just a picture-viewing app
that we've made, simple enough.

00:52:17.460 --> 00:52:20.450
We've got our picture of a cute
dog; we've got our trash can.

00:52:20.450 --> 00:52:24.930
And the idea of what we want to be
able to do here is dispose of a photo.

00:52:24.930 --> 00:52:29.940
So, if you've just been here for the first half of
the talk and you kind of just had UIKit on your mind,

00:52:29.940 --> 00:52:33.870
you probably think that that was
the way to go about animating this,

00:52:33.870 --> 00:52:36.510
kind of zooming the picture down into the trash can.

00:52:36.510 --> 00:52:41.170
Let's try doing that with UIKit and see how it looks.

00:52:41.170 --> 00:52:48.070
So, with the UIViewAnimation, what we can do is just
like everything we've seen before, set the center of it,

00:52:48.070 --> 00:52:51.780
we'll create an animation, set the center
of it to the middle of the garbage can,

00:52:51.780 --> 00:52:55.750
set the transform to shrink it down,
and set its Alpha to fade it out a bit.

00:52:55.750 --> 00:53:02.140
And this thumbnailPressed method gets called when
we click on the image, so we can make that happen.

00:53:02.140 --> 00:53:04.390
And, you know, that's alright.

00:53:04.390 --> 00:53:07.730
The dog zooms down to the garbage can, he shrinks.

00:53:07.730 --> 00:53:10.980
But something that's kind of funny is, you know,
when you throw something into the garbage can,

00:53:10.980 --> 00:53:15.370
it doesn't fly magically at it unless you're throwing
it really, really fast, and it also doesn't pass

00:53:15.370 --> 00:53:17.740
through the side of the garbage
can like we saw happen there.

00:53:17.740 --> 00:53:22.790
Now, we want something a bit more realistic, kind of
an arc, as the picture gets thrown into the trash.

00:53:22.790 --> 00:53:23.360
We can do better.

00:53:23.360 --> 00:53:26.680
Let's try doing that with CA, CoreAnimation.

00:53:26.680 --> 00:53:30.800
So, I'll just erase everything that we have there.

00:53:30.800 --> 00:53:31.700
And we know that path.

00:53:31.700 --> 00:53:35.720
Like I said, I've got this idea of kind
of an arc that I want the path to follow.

00:53:35.720 --> 00:53:39.530
Let's draw that 'cause it's the same type
of thing when we want it to follow the path.

00:53:39.530 --> 00:53:45.370
So, I'll create a CGPath and create it from the picture
to the trash, have a little bit of control point

00:53:45.370 --> 00:53:51.030
so we get a nice quadratic curve, and the
view above the setup to draw this path.

00:53:51.030 --> 00:53:55.170
So, when we click on the dog this time, you get the path.

00:53:55.170 --> 00:53:56.000
That looks pretty good.

00:53:56.000 --> 00:53:59.170
You know, maybe that's not perfect gravity
kind of drop-off, but you know, that's fine.

00:53:59.170 --> 00:54:01.720
That's what we want to do in this case.

00:54:01.720 --> 00:54:07.670
You don't need to be drawing that path, so I'll
overwrite that with our CAKeyFrameAnimation.

00:54:07.670 --> 00:54:13.160
The property that we're changing is the position
right there, and we'll actually just set the path

00:54:13.160 --> 00:54:16.400
to be the CGPath that we've created and made above.

00:54:16.400 --> 00:54:20.450
We'll then set the duration and
then add that animation to the layer

00:54:20.450 --> 00:54:24.210
of the thumbnail or the picture of the dog in this case.

00:54:24.210 --> 00:54:29.630
Alright. That's kind of it, isn't it?

00:54:29.630 --> 00:54:31.090
Something's kind of wrong using that still.

00:54:31.090 --> 00:54:32.330
We want it to shrink.

00:54:32.330 --> 00:54:38.560
So, let's do some more work to make it shrink and fade
out like we saw in the kind of the naive approach.

00:54:38.560 --> 00:54:42.960
So, first, another CABasicAnimation.

00:54:42.960 --> 00:54:47.850
As Andre said, CABasicAnimations work by
having sort of a From and a To property.

00:54:47.850 --> 00:54:51.110
Here, we're modifying the transform property.

00:54:51.110 --> 00:54:56.440
So, we can assume that the From is going to be
the identity transform, sort of the normal size,

00:54:56.440 --> 00:55:00.910
and we're going to be shrinking
it or passing it to a To-value

00:55:00.910 --> 00:55:07.700
of a CA transformed 3D scale of a tenth of the initial size.

00:55:07.700 --> 00:55:17.380
We then also want to fade it out, so we have another basic
animation where we set the To-value to be 50 percent or 0.5.

00:55:17.380 --> 00:55:19.890
Finally, to make all three of these happen together,

00:55:19.890 --> 00:55:27.460
we're going to need to use a CA Animation group wherein we
pass an array of these three animations that we've created

00:55:27.460 --> 00:55:32.370
above and then we have a tiny function we do in
this case just to make it look a little better.

00:55:32.370 --> 00:55:40.430
The same sort of this-- the CA version of the ease in and
out that we saw before in UIKit, and we set the duration.

00:55:40.430 --> 00:55:47.400
And then finally, just like before, we
add it to the layer of the thumbnail.

00:55:47.400 --> 00:55:52.340
So, just like that, we get this cool kind of swooping
down effect, have the image fade out and shrink down.

00:55:52.340 --> 00:55:57.020
We could do a bit more work to make the image disappear,
but I think this gets the point across for now.

00:55:57.020 --> 00:56:02.530
It's very similar to this that you could do really cool
things like this quasi 3D-like animations that you see

00:56:02.530 --> 00:56:05.730
in like CoverFlow and CA has a lot of power if you need it.

00:56:05.730 --> 00:56:06.480
It's really great.

00:56:06.480 --> 00:56:07.510
Thanks again.

00:56:07.510 --> 00:56:13.030
[ Applause ]

00:56:13.030 --> 00:56:14.790
>> Andre Boule: Thank you, Tyler.

00:56:14.790 --> 00:56:17.640
Alright, so you saw the CA group animation there.

00:56:17.640 --> 00:56:18.560
We didn't talk about that.

00:56:18.560 --> 00:56:22.090
And that's because there's two
more sessions on CoreAnimation.

00:56:22.090 --> 00:56:25.330
CoreAnimation in Practice, Part 1 and Part 2.

00:56:25.330 --> 00:56:29.940
Part 2 is that really advanced session I
encourage you to go to, and they are later today.

00:56:29.940 --> 00:56:33.900
So, what did we see today?

00:56:33.900 --> 00:56:36.210
We saw UIView Animations.

00:56:36.210 --> 00:56:40.960
New in iOS 4 is a blocks-based API for UIView Animations.

00:56:40.960 --> 00:56:42.210
I encourage you to go try that out.

00:56:42.210 --> 00:56:50.230
And I encourage you to dig deeper and get your
hands in CoreAnimation directly if you need to.

00:56:50.230 --> 00:56:54.740
For more information, you can contact Bill
Dudney our Application Frameworks Evangelist.

