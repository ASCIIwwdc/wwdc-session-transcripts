1
00:00:07,270 --> 00:00:08,120
>> Hi everyone.

2
00:00:08,120 --> 00:00:09,140
My name is Paul.

3
00:00:09,140 --> 00:00:13,770
And this is Adding Touch and Gesture
Detection to Web Pages on iPhone OS.

4
00:00:13,770 --> 00:00:16,570
I'm an engineer on Safari for iOS.

5
00:00:16,570 --> 00:00:18,810
Why are you here today?

6
00:00:18,810 --> 00:00:24,130
You're here because you have a website for
iPad, iPhone or you're thinking of building one.

7
00:00:24,130 --> 00:00:26,670
And you want it to feel great.

8
00:00:26,670 --> 00:00:28,330
iPad, iPhone, they're amazing.

9
00:00:28,330 --> 00:00:30,810
They let you hold the web in your hands.

10
00:00:30,810 --> 00:00:34,180
But maybe what's missing is you
can't touch your web content.

11
00:00:34,180 --> 00:00:39,390
Your users, your customers, and you want to be able to
build web content for fingers, things that you can move

12
00:00:39,390 --> 00:00:44,010
around the screen just by dragging them,
pinch to zoom or rotate with two fingers.

13
00:00:44,010 --> 00:00:48,480
We can do these things using just web
technologies, HTML, CSS, JavaScript.

14
00:00:48,480 --> 00:00:51,430
You don't need Objective-C, you don't a native application.

15
00:00:51,430 --> 00:00:52,800
We'll talk about how you can do that today.

16
00:00:52,800 --> 00:01:01,880
And we can build really amazing, rich web applications
for these platforms for iPhone, iPad, iPod touch.

17
00:01:01,880 --> 00:01:05,630
Things that when they're sitting on the
home screen of your customer's phones

18
00:01:05,630 --> 00:01:08,690
and devices, they feel just like native applications.

19
00:01:08,690 --> 00:01:12,500
We'll talk about some tips, techniques
and ways we can do that.

20
00:01:12,500 --> 00:01:14,420
So, we're going to cover three main things today.

21
00:01:14,420 --> 00:01:18,150
We're going to talk about the touch
event API and the touch event model.

22
00:01:18,150 --> 00:01:22,350
What touch events are, how they get delivered
to your application, how you use them.

23
00:01:22,350 --> 00:01:27,800
We're going to talk about building controls, reusable
interface widgets, a few really rich controllers

24
00:01:27,800 --> 00:01:31,660
that aren't part of the standard HTML5 repertoire.

25
00:01:31,660 --> 00:01:35,900
And along the way we're going to be using the
Document Object Model and some CSS transforms

26
00:01:35,900 --> 00:01:40,010
to build some really nice, complex, rich interfaces.

27
00:01:40,010 --> 00:01:44,520
So, hopefully everyone here is already
familiar with HTML, JavaScript, and CSS.

28
00:01:44,520 --> 00:01:48,890
This is going to be a very code heavy
presentation, but don't worry about trying

29
00:01:48,890 --> 00:01:51,420
to copy everything down in your notes, in your laptops.

30
00:01:51,420 --> 00:01:55,270
All the sample code that's presented here on
the slides today is attached to the session.

31
00:01:55,270 --> 00:01:57,610
You can get it from the WWDC Attendee site later.

32
00:01:57,610 --> 00:02:02,400
And hopefully you're familiar with the
basics of the Document Object Model.

33
00:02:02,400 --> 00:02:07,560
Now, you don't need to know the 15 parameters you need
to use in order to create a mouse event programmatically.

34
00:02:07,560 --> 00:02:16,190
Hopefully though you're able to use a document.get
ElementById to pull a DOM node out of a HTML document.

35
00:02:16,190 --> 00:02:18,620
So let's talk about touch events.

36
00:02:18,620 --> 00:02:20,250
The touch event API.

37
00:02:20,250 --> 00:02:22,170
Why do we even have these touch events?

38
00:02:22,170 --> 00:02:23,870
We already have mouse events.

39
00:02:23,870 --> 00:02:27,900
Why do we need a separate set of
events to describe your fingers?

40
00:02:27,900 --> 00:02:31,400
And the answer is your fingers are different from mice.

41
00:02:31,400 --> 00:02:33,220
There's a couple really big differences.

42
00:02:33,220 --> 00:02:35,900
First, you have more than one finger.

43
00:02:35,900 --> 00:02:38,240
Most computers only have one mouse.

44
00:02:38,240 --> 00:02:41,640
Second, you can remove your fingers
entirely from the equation.

45
00:02:41,640 --> 00:02:46,180
You can lift your fingers off the screen and put
them down in a completely different location.

46
00:02:46,180 --> 00:02:47,330
I'm talking too much.

47
00:02:47,330 --> 00:02:48,880
Let me show you what I'm talking about.

48
00:02:48,880 --> 00:02:50,680
And I have this really simple demo.

49
00:02:50,680 --> 00:02:53,920
It's got these three bubbles, mouse
down, mouse move, mouse up.

50
00:02:53,920 --> 00:02:58,290
And every time this page receives one of those
events from the browser, they're going to light up.

51
00:02:58,290 --> 00:03:02,960
So if I move the mouse around the screen,
we'll get a series of mouse-move events.

52
00:03:02,960 --> 00:03:08,530
And if I click, we'll get a mouse-down
event, followed by a mouse-up event.

53
00:03:08,530 --> 00:03:13,050
Now, on an iPad, iPhone or iPod touch
it works a little bit differently.

54
00:03:13,050 --> 00:03:17,600
Ok, I've got the exact same page loaded here on my iPad.

55
00:03:17,600 --> 00:03:18,610
Thank you.

56
00:03:18,610 --> 00:03:23,240
And I'm going to tap on the screen to click.

57
00:03:23,240 --> 00:03:26,360
And what happens is we get all
three of those events at once.

58
00:03:26,360 --> 00:03:31,410
We get a mouse move and a mouse down and
a mouse up all delivered at the same time.

59
00:03:31,410 --> 00:03:36,950
And in fact, if you notice, if I
tap there's a little bit of a delay.

60
00:03:36,950 --> 00:03:41,620
Safari for iOS needs just a brief second
to figure out what the user's trying to do.

61
00:03:41,620 --> 00:03:44,790
Is the user going to double tap to zoom in to an element?

62
00:03:44,790 --> 00:03:46,930
Is the user going to pan the page?

63
00:03:46,930 --> 00:03:51,070
It needs just that really brief delay to figure
out if we're trying to click on something

64
00:03:51,070 --> 00:03:54,650
or if we're using some other sort of gesture.

65
00:03:54,650 --> 00:03:57,870
So mouse events are different than touch events.

66
00:03:57,870 --> 00:04:01,610
Now I have another page right here with the touch events.

67
00:04:01,610 --> 00:04:03,750
Touch events are different than mouse events.

68
00:04:03,750 --> 00:04:07,570
Safari doesn't take any time to look at
the touches and figure out what's going on.

69
00:04:07,570 --> 00:04:09,350
It delivers them immediately.

70
00:04:09,350 --> 00:04:14,450
So if I place my finger down on the screen,
we'll immediately receive a touch startevent.

71
00:04:14,450 --> 00:04:19,480
And as I move my finger around the screen,
we'll receive a series of touchmove events.

72
00:04:19,480 --> 00:04:23,640
And when I lift my finger off the
screen, we'll receive a touchend event.

73
00:04:23,640 --> 00:04:26,400
These are dispatched to your web content first.

74
00:04:26,400 --> 00:04:29,220
You get a first crack at all of these input events.

75
00:04:29,220 --> 00:04:32,010
Now we have more than one finger,
I've mentioned this already.

76
00:04:32,010 --> 00:04:35,810
And we'll receive these events for each
finger and they might be interleaved.

77
00:04:35,810 --> 00:04:39,660
So if I put one finger down, I receive
a touchstart for that first finger.

78
00:04:39,660 --> 00:04:43,810
I put another finger down, I'll receive
a touchstart for that second finger.

79
00:04:43,810 --> 00:04:46,860
Then I'll receive touchmoves as
my fingers move on the screen.

80
00:04:46,860 --> 00:04:49,220
And touchend when I lift them.

81
00:04:49,220 --> 00:04:52,720
Now there's a fourth event on this
screen and it's called touchcancel.

82
00:04:52,720 --> 00:04:54,950
Touchcancel means something unusual kind of happened.

83
00:04:54,950 --> 00:04:56,620
Touches were interrupted.

84
00:04:56,620 --> 00:05:02,850
Maybe you got a phone call or you
hit the screen with your whole hand.

85
00:05:02,850 --> 00:05:04,990
Normally that works.

86
00:05:04,990 --> 00:05:07,520
Apparently I can't be unusual enough today.

87
00:05:07,520 --> 00:05:09,650
Touchcancel means something unusual happened.

88
00:05:09,650 --> 00:05:11,370
Your touches were interrupted.

89
00:05:11,370 --> 00:05:14,080
Basically all the touches are being reset.

90
00:05:14,080 --> 00:05:17,390
So if you're keeping track of any
state, you need to reset that.

91
00:05:17,390 --> 00:05:22,920
So I talked about four basic events in the touch event
model, four events that are delivered to your page.

92
00:05:22,920 --> 00:05:27,580
There's touchstart, that gets sent every time
a finger is placed on the screen; touchmove,

93
00:05:27,580 --> 00:05:34,650
gets sent every time a finger moves on the screen; touchend
when a finger is removed from the screen; and touchcancel,

94
00:05:34,650 --> 00:05:38,900
touches have been interrupted,
reset all of your state, start over.

95
00:05:40,690 --> 00:05:44,080
Using all of these things, we can build a button.

96
00:05:44,080 --> 00:05:48,940
"But wait," all of you are saying, "We have buttons.

97
00:05:48,940 --> 00:05:49,790
We have lots of buttons.

98
00:05:49,790 --> 00:05:55,030
We have input buttons and the button in element, why,
why do we need to build a button with touch events?"

99
00:05:55,030 --> 00:05:59,450
I can think of two reasons we might want to
build our own custom button with touch events.

100
00:05:59,450 --> 00:06:03,420
First, remember how there is that really
short delay while Safari is trying to figure

101
00:06:03,420 --> 00:06:06,970
out if you're trying to click on an element or pan around?

102
00:06:06,970 --> 00:06:09,610
If we use touch events, we get first crack at those events

103
00:06:09,610 --> 00:06:13,410
and we can build something that
responds immediately to user input.

104
00:06:13,410 --> 00:06:16,760
Second, all those mouse events come at once.

105
00:06:16,760 --> 00:06:20,240
If we want to build a button that say
looks depressed when you're pressing

106
00:06:20,240 --> 00:06:23,080
down on it, we'll need to use touch events for that.

107
00:06:23,080 --> 00:06:27,400
So, the markup for this is going to be really simple.

108
00:06:27,400 --> 00:06:29,270
We're going to build a button out of a div.

109
00:06:29,270 --> 00:06:33,030
You can use a button or an input element
if you'd like to be a little more semantic,

110
00:06:33,030 --> 00:06:35,470
but that brings with it some default browser style.

111
00:06:35,470 --> 00:06:39,280
For this example, we're just going to use a div element.

112
00:06:39,280 --> 00:06:43,720
And in the JavaScript side, we need a callback,
something that happens when that button is tapped.

113
00:06:43,720 --> 00:06:49,170
We could show or hide another part of the user
interface or take the user to a different page.

114
00:06:49,170 --> 00:06:53,910
Whatever happens when we tap that
button, that's our callback method.

115
00:06:53,910 --> 00:06:59,950
Then we'll use document.getElementById to find that
button on the DOM, hold onto a reference for the element

116
00:06:59,950 --> 00:07:04,500
and we'll add an event listener, touchstart
seems like a natural place to start.

117
00:07:04,500 --> 00:07:08,690
We'll pass in the callback so that when
we tap that button, we do something.

118
00:07:08,690 --> 00:07:10,460
Let's take a look at how this works.

119
00:07:10,460 --> 00:07:14,120
So this is a button, very simple,
it's a div with a touch start handler.

120
00:07:14,120 --> 00:07:18,460
And I'm going to place my finger
on it and the button was tapped.

121
00:07:18,460 --> 00:07:20,040
But that doesn't really feel right.

122
00:07:20,040 --> 00:07:23,040
The button is tapped as soon as I
put my finger down on the screen.

123
00:07:23,040 --> 00:07:27,100
Normally we want to put our finger down,
wait and then when we lift our finger,

124
00:07:27,100 --> 00:07:29,300
that's when we want the event to be dispatched.

125
00:07:29,300 --> 00:07:32,540
So we'll make a really quick modification to the code.

126
00:07:32,540 --> 00:07:39,020
Instead of registering on touchstart, let's listen
for a touchend event and see how that works instead.

127
00:07:39,020 --> 00:07:42,430
Modified button, I can place my finger down on the button

128
00:07:42,430 --> 00:07:46,020
and then when I lift my finger, we
get our callback function called.

129
00:07:46,020 --> 00:07:49,000
That feels a lot more natural.

130
00:07:49,000 --> 00:07:52,720
So far, there's nothing that complicated about this button.

131
00:07:52,720 --> 00:07:56,120
It doesn't really do much, it doesn't do any of
the really cool things that I said we could do,

132
00:07:56,120 --> 00:07:59,300
like make it look depressed when we're pressing down on it.

133
00:07:59,300 --> 00:08:01,930
And our code is already starting to get a little messy.

134
00:08:01,930 --> 00:08:06,670
We're pulling out elements individually, we're
registering these sort of floating methods.

135
00:08:06,670 --> 00:08:08,130
We want to keep our code clean.

136
00:08:08,130 --> 00:08:13,990
We want to keep it reusable, especially with touch
events where we have to keep track of a lot of details.

137
00:08:13,990 --> 00:08:16,000
So let's wrap it all up into a JavaScript class.

138
00:08:16,000 --> 00:08:22,700
I have a constructor, capital B button it takes
in 2 parameters, an elementID and a callback.

139
00:08:22,700 --> 00:08:28,650
We'll use the exact same getelementbyID to pull
the element out of the DOM, store it for later use.

140
00:08:28,650 --> 00:08:30,330
We'll keep the callback around for later use.

141
00:08:30,330 --> 00:08:35,070
And then we'll add our event listener
near a touchstart and touchend.

142
00:08:35,070 --> 00:08:38,770
There is something kind of unusual
about this form of addEventListener.

143
00:08:38,770 --> 00:08:41,170
Normally addEventListener takes three properties.

144
00:08:41,170 --> 00:08:45,850
It takes the name of the event, it takes
the callback method and then it takes

145
00:08:45,850 --> 00:08:49,160
in this false Boolean that we always pass in.

146
00:08:49,160 --> 00:08:50,910
But here I'm passing in an object.

147
00:08:50,910 --> 00:08:52,590
I'm passing in this.

148
00:08:52,590 --> 00:08:55,150
This is a somewhat unusual form of addEventListener.

149
00:08:55,150 --> 00:09:01,930
But what happens is if you register events
passing in an object, when that event occurs,

150
00:09:01,930 --> 00:09:05,980
the handleEvent method, it's a special name, handleEvent.

151
00:09:05,980 --> 00:09:08,920
That gets called on the object in question.

152
00:09:08,920 --> 00:09:13,740
So instead of having to keep around the
closure and store this and put it into self

153
00:09:13,740 --> 00:09:21,770
and create anonymous inline function so we can call on the
right object later, this is one way we can get around that.

154
00:09:21,770 --> 00:09:24,940
I want to do something kind of tricky
to keep our code a little simple.

155
00:09:24,940 --> 00:09:31,360
Event.type on a DOM event is the name of the
event, touchstart or touchend, something like that.

156
00:09:31,360 --> 00:09:39,060
I'm using subscript notation to look on this on our button
instance to find a property named touchstart or touchend.

157
00:09:39,060 --> 00:09:41,830
And then I'm going to make sure it's a function.

158
00:09:41,830 --> 00:09:45,090
And if it is, I'm going to call it.

159
00:09:45,090 --> 00:09:50,610
This is a bit unusual but what this means is we don't
have to sit around and register touchstart handler

160
00:09:50,610 --> 00:09:57,510
for touchstart events and touchend handler for touchend
events on our, on our button class, on our prototype,

161
00:09:57,510 --> 00:09:59,990
we just create methods called touchstart and touchend.

162
00:09:59,990 --> 00:10:03,410
And those get called when we get our events.

163
00:10:03,410 --> 00:10:07,120
In order to do our highlighted state,
I'm just going to set a classing,

164
00:10:07,120 --> 00:10:09,770
add a new class highlighted on the actual element.

165
00:10:09,770 --> 00:10:12,080
Then in CSS we can do whatever we need to do.

166
00:10:12,080 --> 00:10:18,650
We can change the background image or make it a
different color or make it explode into 1000 tiny pieces.

167
00:10:18,650 --> 00:10:21,660
And on touchend we also want to call our callback function.

168
00:10:21,660 --> 00:10:29,480
In the CSS, I'm using something kind
of neat to create this lozenge shape.

169
00:10:29,480 --> 00:10:35,160
If you set a height and then use a -border-radius to
round off those edges, you can get a lozenge shape

170
00:10:35,160 --> 00:10:37,430
without having to use any sort of images.

171
00:10:37,430 --> 00:10:43,840
And then the background I'm using webkit-gradient to
create that sort of really nice, light to dark effect.

172
00:10:43,840 --> 00:10:48,630
When the button is highlighted, you just reverse
the gradient so it looks depressed instead.

173
00:10:48,630 --> 00:10:54,670
It's really simple way to create a button that looks
really nice, looks very visual without using any images.

174
00:10:54,670 --> 00:10:59,730
So let's take a look at how this button works now.

175
00:10:59,730 --> 00:11:09,050
With our new event handlers and that extra CSS styling,
when I tap down on the button, it looks depressed.

176
00:11:09,050 --> 00:11:14,460
It responds immediately and when I remove my
finger, it pops back out, the callback gets called.

177
00:11:14,460 --> 00:11:18,380
It's a really nice way of keeping your code simple.

178
00:11:18,380 --> 00:11:23,710
Now, we've handled touchstart and touchend, but
there's that fourth mysterious touchcancel event.

179
00:11:23,710 --> 00:11:25,850
We need to make sure we handle this.

180
00:11:25,850 --> 00:11:28,500
Touchcancel can happen for a variety of reasons.

181
00:11:28,500 --> 00:11:32,240
A JavaScript alert pops up, you get a phone
call while you're using your web page.

182
00:11:32,240 --> 00:11:36,620
And it's important that you reset any state,
anything that you're doing with touch events.

183
00:11:36,620 --> 00:11:40,740
So in this case, on touchcancel,
we'll simply remove that extra class.

184
00:11:40,740 --> 00:11:44,790
Otherwise you might come back from a phone
call and your button is stuck depressed.

185
00:11:44,790 --> 00:11:51,410
And that's one way that we can build a button
that responds immediately to touch events.

186
00:11:51,410 --> 00:11:54,300
So we've talked about the four basic touch events.

187
00:11:54,300 --> 00:11:56,990
Touchstart, fingers placed on the screen.

188
00:11:56,990 --> 00:11:59,580
Touchmove, a finger on the screen moves.

189
00:11:59,580 --> 00:12:02,570
Touchend, a finger has been removed from the screen.

190
00:12:02,570 --> 00:12:07,140
And touchcancel, touches have been
interrupted, don't forget to handle this.

191
00:12:07,140 --> 00:12:11,510
For the rest of the examples I'm not going to
walk through explicitly what I do on touchcancel.

192
00:12:11,510 --> 00:12:14,860
But look at the sample code and
make sure you handle touchcancel.

193
00:12:14,860 --> 00:12:17,990
But that's just the start.

194
00:12:17,990 --> 00:12:20,810
It tells us when fingers on the screen, what they're doing,

195
00:12:20,810 --> 00:12:23,960
but it doesn't really give us information
about the fingers themselves.

196
00:12:23,960 --> 00:12:27,040
What if we need to know where a finger is on the screen?

197
00:12:27,040 --> 00:12:33,790
If we think back to mouse events and we look at
a mouse event object, it looks pretty familiar.

198
00:12:33,790 --> 00:12:39,080
We can immediately look at that object and figure out
what button is down, the left or the right mouse button,

199
00:12:39,080 --> 00:12:43,590
where on the screen the cursor is, whether
or not any modifier keys are being held down.

200
00:12:43,590 --> 00:12:47,640
But if we look at a touch event, it looks really small.

201
00:12:47,640 --> 00:12:48,680
There's not much there.

202
00:12:48,680 --> 00:12:50,580
What is this changedTtouches?

203
00:12:50,580 --> 00:12:52,570
Where are my screen coordinates?

204
00:12:52,570 --> 00:12:58,790
The important thing to remember is that a touch event,
because we have multiple fingers, is a list of touches.

205
00:12:58,790 --> 00:13:01,890
What you're given is actually a list of touches.

206
00:13:01,890 --> 00:13:04,100
There are three lists actually.

207
00:13:04,100 --> 00:13:05,790
There's the touches list.

208
00:13:05,790 --> 00:13:10,090
That's all the touches that are
currently active or down on the screen.

209
00:13:10,090 --> 00:13:15,140
So if I have five fingers on the screen, those
five finger will be in the touches array.

210
00:13:15,140 --> 00:13:16,980
There's changedTouches.

211
00:13:16,980 --> 00:13:21,190
These are the fingers that have
changed since the last event.

212
00:13:21,190 --> 00:13:26,090
If I have two fingers on the screen and I'm
moving one, and the other is staying still,

213
00:13:26,090 --> 00:13:29,170
changedTouches will contain only the finger that's moving.

214
00:13:29,170 --> 00:13:31,970
And touches will contain both of them.

215
00:13:31,970 --> 00:13:34,440
And lastly there's targetTouches.

216
00:13:34,440 --> 00:13:36,950
These are touches that are inside the target element.

217
00:13:36,950 --> 00:13:43,170
So if I'm tapping on an image for example,
then the fingers that are inside the bounds

218
00:13:43,170 --> 00:13:45,410
of that image are inside of targetTouches.

219
00:13:45,410 --> 00:13:50,640
Now these lists are more or less array
like, so they have a length property.

220
00:13:50,640 --> 00:13:57,120
So you could look at e.touches.length, event.touches.length
and that's the number of fingers currently on the screen.

221
00:13:57,120 --> 00:14:00,800
Or if we wanted to get the first
finger inside the target element,

222
00:14:00,800 --> 00:14:03,870
we can use subscript notation, loop over them with arrays.

223
00:14:03,870 --> 00:14:09,330
All those sorts of things we're familiar with,
with arrays, will work on these touch lists.

224
00:14:09,330 --> 00:14:14,440
So a touch event is a list of objects, is a list of touches.

225
00:14:14,440 --> 00:14:17,450
Let's look at the individual touch.

226
00:14:17,450 --> 00:14:20,630
The first property on a touch is an identifier.

227
00:14:20,630 --> 00:14:25,670
This is a unique number that you can use to keep
track of a single finger across multiple events.

228
00:14:25,670 --> 00:14:29,700
Don't hold onto a touch object itself, you'll
prevent it from being garbage collected.

229
00:14:29,700 --> 00:14:34,440
Hold on to this number instead if you need
to keep track of an individual finger.

230
00:14:34,440 --> 00:14:35,620
Then there's target.

231
00:14:35,620 --> 00:14:37,690
This is the DOM node that is the target.

232
00:14:37,690 --> 00:14:41,460
So if we're tapping on that image,
then this will be the image.

233
00:14:41,460 --> 00:14:46,530
And then there's two sets of coordinates,
screen coordinates and page coordinates.

234
00:14:46,530 --> 00:14:54,510
If we tap here on this iPhone 4, screen
coordinates are the position of the tap

235
00:14:54,510 --> 00:14:57,470
from the top right hand corner of the screen.

236
00:14:57,470 --> 00:15:03,890
And if we double tap to zoom in say and we tap in
the same location, page coordinates are the location

237
00:15:03,890 --> 00:15:07,840
of that tap relative from the top
right hand corner of the page.

238
00:15:07,840 --> 00:15:09,670
This is in CSS pixels.

239
00:15:09,670 --> 00:15:13,150
So if you're going to be moving an
element around to respond to a tap,

240
00:15:13,150 --> 00:15:15,730
this is probably the set of coordinates you want to use.

241
00:15:15,730 --> 00:15:20,060
If you're simply interested in whether or not the
user is tapping in the top half or the bottom half

242
00:15:20,060 --> 00:15:22,590
of the screen, that's what screen coordinates are for.

243
00:15:22,590 --> 00:15:27,040
With all this information we can go on and
build another really cool control, a slider.

244
00:15:27,040 --> 00:15:32,020
Something that has a track and a
knob and we can move it around.

245
00:15:32,020 --> 00:15:33,980
Mark up is going to be really simple.

246
00:15:33,980 --> 00:15:39,570
We're going to use a container div and then inside of
that two divs, one for our track, one for our knob.

247
00:15:39,570 --> 00:15:41,670
We'll have classes so we can get to those.

248
00:15:41,670 --> 00:15:44,300
And then there's the constructor.

249
00:15:44,300 --> 00:15:49,910
We're going to bundle this up to an object just
like we did on the button so we can reuse it.

250
00:15:49,910 --> 00:15:56,400
We'll pull the main parent, the container div
out of the documents tree with getElementById.

251
00:15:56,400 --> 00:16:00,760
Then we'll pull the knob out by getting
getElementsByClassname, because we want to have more

252
00:16:00,760 --> 00:16:05,330
than one slider on the page, we need to use class
names and not IDs in order to pull these out.

253
00:16:05,330 --> 00:16:11,610
Let's also look at the width of that knob, offsetWidth
is the actual width of that inside the rendered tree.

254
00:16:11,610 --> 00:16:17,270
We'll use this to do a little bit of math so we
don't drag the knob off the end of the track.

255
00:16:17,270 --> 00:16:23,610
And then we'll also grab the bar out with
getElementsByClassname and look at its width too.

256
00:16:23,610 --> 00:16:27,360
The touchstart handler is going to be really simple.

257
00:16:27,360 --> 00:16:31,380
At the start, we're going to look at the
event and look into that targetTouches array.

258
00:16:31,380 --> 00:16:36,090
Remember targetTouches is the list of
fingers that is inside the target element.

259
00:16:36,090 --> 00:16:44,740
We'll grab the first finger and grab its page X
coordinate, location in CSS pixels on the page.

260
00:16:44,740 --> 00:16:49,930
And we'll store that and then we'll
call this method, this.moveKnobTo.

261
00:16:49,930 --> 00:16:53,750
We'll get to this, but this is where
we're actually going to do all the work.

262
00:16:53,750 --> 00:17:01,170
Then on touchmove, we're just going to call moveKnobTo
and again we're going to look at the targetTouches array,

263
00:17:01,170 --> 00:17:04,950
pull the first finger out, get its page location.

264
00:17:04,950 --> 00:17:10,270
The moveKnobTo method is where
all the work is going to be done.

265
00:17:10,270 --> 00:17:13,240
First, we need to figure out how far the finger is moved.

266
00:17:13,240 --> 00:17:19,510
So we stored that start X at the beginning
when we, we got our first touchstart.

267
00:17:19,510 --> 00:17:23,380
And we're just going to figure out how
far the finger is from where it started.

268
00:17:23,380 --> 00:17:26,760
Then we're going to do a little bit of math to make sure

269
00:17:26,760 --> 00:17:29,680
that we clamp the position of the
knob to the ends of the track.

270
00:17:29,680 --> 00:17:33,030
We don't want to be able to drag the
knob all the way off to the right.

271
00:17:33,030 --> 00:17:37,940
And then we'll just set the left
style property inline of the knob.

272
00:17:37,940 --> 00:17:41,410
And that's going to position it along the track.

273
00:17:41,410 --> 00:17:46,500
We'll hold onto the starting position for the next time we
call it through this loop and then we'll notify our callback

274
00:17:46,500 --> 00:17:52,110
and say now that the slider has been moved,
here's where it is, do whatever you need to do.

275
00:17:52,110 --> 00:17:58,040
Now, for performance reasons, instead of
setting the left property on that, on that knob,

276
00:17:58,040 --> 00:18:01,560
we might want to use this instead, a webkitTransform.

277
00:18:01,560 --> 00:18:05,260
Left will work, but if we want
the best possible performance,

278
00:18:05,260 --> 00:18:08,730
this is really important for building
user interface widgets.

279
00:18:08,730 --> 00:18:13,070
Use webkitTransform instead with a translate3d property.

280
00:18:13,070 --> 00:18:19,850
We'll construct a string, set the X transform
to the X offset and then Y and Z offsets to 0.

281
00:18:19,850 --> 00:18:26,030
Under certain conditions this will actually
trigger hardware compositing, so we'll reload,

282
00:18:26,030 --> 00:18:29,100
we'll offload the positioning of this knob to the GPU.

283
00:18:29,100 --> 00:18:30,980
It'll work super fast.

284
00:18:30,980 --> 00:18:37,010
And that's the basics of building
something that will track your finger.

285
00:18:37,010 --> 00:18:38,390
I've been talking too much.

286
00:18:38,390 --> 00:18:42,500
So, instead of showing you this myself, I'd
like to invite up Greg Bolsinga, my coworker.

287
00:18:42,500 --> 00:18:46,270
And he's going to show you these controls and
a few others in a demo we've been working on.

288
00:18:46,270 --> 00:18:47,510
Greg?

289
00:18:47,510 --> 00:18:51,050
[ Applause ]

290
00:18:51,050 --> 00:19:00,180
>> Hello, I'm Greg Bolsinga, I work
on iPhone or iOS, WebKit, and Safari.

291
00:19:00,180 --> 00:19:07,790
So with all those parts that Paul put together
for us, I built this little scrapbook application.

292
00:19:07,790 --> 00:19:11,040
It's just a web page, we have an image here.

293
00:19:11,040 --> 00:19:20,720
And what you can do to this is play with your
image and move it around with single touches.

294
00:19:20,720 --> 00:19:27,660
And I created this only using HTML, JavaScript, and CSS.

295
00:19:27,660 --> 00:19:32,660
The only non-text, non-code portions are these images.

296
00:19:32,660 --> 00:19:38,960
So the first thing that I set up was
playing with some of the CSS properties.

297
00:19:38,960 --> 00:19:43,440
And what I can do is set the border width of the picture.

298
00:19:43,440 --> 00:19:45,850
These are all regular CSS properties.

299
00:19:45,850 --> 00:19:50,300
I can set the border radius, if
you can see that curving down here.

300
00:19:50,300 --> 00:19:56,170
Another thing you can do is I played with the box shadow.

301
00:19:56,170 --> 00:20:01,670
I have this little scroller here where we could
see more properties that I could set on here.

302
00:20:01,670 --> 00:20:07,250
And with the box shadow we could
pop it out either direction.

303
00:20:07,250 --> 00:20:09,300
We'll move it down here.

304
00:20:09,300 --> 00:20:14,620
Put a little blur on it so it looks
pretty, looks blurry up there.

305
00:20:14,620 --> 00:20:17,030
And so we have our image.

306
00:20:17,030 --> 00:20:22,980
The other thing that I did with this is with
the multitouch I could move these things around

307
00:20:22,980 --> 00:20:27,270
and I'm setting the CSS transforms that Paul mentioned.

308
00:20:27,270 --> 00:20:31,060
And I'm just translating it here,
but we also support gesture events.

309
00:20:31,060 --> 00:20:39,460
So as soon as you put more than one finger down, I could
start rotating this image as well as scaling it in.

310
00:20:39,460 --> 00:20:44,550
And what I'll play with now is I have these masks.

311
00:20:44,550 --> 00:20:50,160
These masks are all HTML canvases.

312
00:20:50,160 --> 00:20:51,680
So I drew all these masks.

313
00:20:51,680 --> 00:20:57,990
I'm going to be using the same canvas that
drew these buttons as I'll have on here.

314
00:20:57,990 --> 00:21:04,210
So for example, I can mask the image with just a circle.

315
00:21:04,210 --> 00:21:15,180
Or I can pick other fun shapes like the star
and I could still interact with the image here.

316
00:21:15,180 --> 00:21:21,480
Zoom in and rotate it, even through the mask.

317
00:21:21,480 --> 00:21:28,930
And I'm going to take the mask off so
we can see the other images that I have.

318
00:21:28,930 --> 00:21:29,150
[ Silence ]

319
00:21:29,150 --> 00:21:30,660
Re-translate this.

320
00:21:30,660 --> 00:21:40,900
And what I have here is another little scroller
inside of a scroller and you could pick new images.

321
00:21:40,900 --> 00:21:44,160
And do the same fun effects with it.

322
00:21:44,160 --> 00:21:49,290
This will all, the code and the pictures
for this will all be up on our website.

323
00:21:49,290 --> 00:21:59,510
So again, that's all HTML, JavaScript, and CSS using touch
events, gesture events and CSS effects and transforms.

324
00:21:59,510 --> 00:22:06,160
[ Applause ]

325
00:22:06,160 --> 00:22:07,000
>> Thanks Greg.

326
00:22:07,000 --> 00:22:11,980
Greg mentioned this, but the only images in
that demo are the four photos on the thumbnails.

327
00:22:11,980 --> 00:22:17,840
Everything else was canvas, CSS,
really cool tricks like that.

328
00:22:17,840 --> 00:22:24,070
So Greg introduced something that I've been kind of
talking about a lot and these are multitouch devices.

329
00:22:24,070 --> 00:22:27,330
You can have more than one finger,
but we haven't talked about that yet.

330
00:22:27,330 --> 00:22:31,360
We haven't talked about dealing with a second finger.

331
00:22:31,360 --> 00:22:35,860
There's a separate set of events that you receive
once a second finger comes into the picture.

332
00:22:35,860 --> 00:22:40,500
And this is very much like the earlier event
demos, the button, the bubbles just highlight

333
00:22:40,500 --> 00:22:42,240
when we receive one of these events on the page.

334
00:22:42,240 --> 00:22:44,900
And there's three gesture events.

335
00:22:44,900 --> 00:22:48,910
Gesture events start once a second
finger is placed on the screen.

336
00:22:48,910 --> 00:22:50,630
So I'll place one finger on the screen.

337
00:22:50,630 --> 00:22:55,680
And when I place the second finger on the
screen, we receive a gesturestart event.

338
00:22:55,680 --> 00:23:01,340
And so then I have two fingers on the screen and I move
them around and receive a series of gesturechange events.

339
00:23:01,340 --> 00:23:05,850
And then when I remove a second
finger, we get a gestureend event.

340
00:23:05,850 --> 00:23:08,590
Now these events are not exclusive from touch events.

341
00:23:08,590 --> 00:23:11,550
We'll receive both at the same time.

342
00:23:11,550 --> 00:23:19,000
So here both touch events and gesture event bubbles
first finger on the screen will send a touchstart.

343
00:23:19,000 --> 00:23:25,110
Second finger on the screen will send a
gesturestart and a touchstart for the second finger.

344
00:23:25,110 --> 00:23:30,470
We'll receive both touchmoves and
gesturechanges as I move my fingers.

345
00:23:30,470 --> 00:23:35,290
And we'll receive touchends and gestureends
for all of those as I remove them.

346
00:23:35,290 --> 00:23:40,530
One more time, touchstart, second finger
sends both touchstart and gesturestart.

347
00:23:40,530 --> 00:23:42,340
These events are all interleaved.

348
00:23:42,340 --> 00:23:47,720
And gestureend and touchends when I remove those fingers.

349
00:23:47,720 --> 00:23:51,280
So there are three events in the gesture event model.

350
00:23:51,280 --> 00:23:54,670
Gesturestart, second finger on the screen.

351
00:23:54,670 --> 00:23:58,080
Gesturechange, something is going
on with those multiple fingers.

352
00:23:58,080 --> 00:24:01,260
Gestureend, second finger removed from the screen.

353
00:24:01,260 --> 00:24:05,930
There's one thing missing here you might notice,
gesturecancel, there is no gesturecancel.

354
00:24:05,930 --> 00:24:11,930
But because you receive both touch events and gesture
events at the same time, you still need to handle it,

355
00:24:11,930 --> 00:24:17,400
listen for touchcancel even if all
you're doing is gesture handling events.

356
00:24:17,400 --> 00:24:22,490
The gesture event object is actually really
simple and looks a lot more familiar.

357
00:24:22,490 --> 00:24:24,660
First, there's scale.

358
00:24:24,660 --> 00:24:27,430
Scale is multiplier, it's a float.

359
00:24:27,430 --> 00:24:32,390
If I put two fingers on the screen and they're 100
pixels apart, and I move those two fingers apart

360
00:24:32,390 --> 00:24:37,570
so they're now 200 pixels apart, then
that scale property is going to be 2.0.

361
00:24:37,570 --> 00:24:41,350
My fingers are twice as far as
when I put them on the screen.

362
00:24:41,350 --> 00:24:44,770
If I put my fingers down at 100
pixels apart and bring them together

363
00:24:44,770 --> 00:24:49,170
so they're only 50 pixels apart,
that scale is going to be 0.5.

364
00:24:49,170 --> 00:24:52,860
My fingers are half as far apart as they used to be.

365
00:24:52,860 --> 00:24:54,800
Then there's rotation.

366
00:24:54,800 --> 00:24:57,350
Rotation is, are you ready for this?

367
00:24:57,350 --> 00:25:01,230
Degrees clockwise relative to the starting position.

368
00:25:01,230 --> 00:25:07,780
So if I have 2 fingers and I rotate my fingers
like this, that rotation is going to be 90,

369
00:25:07,780 --> 00:25:12,010
90 degrees clockwise relative from the starting position.

370
00:25:12,010 --> 00:25:14,400
And then there's page coordinates.

371
00:25:14,400 --> 00:25:21,190
Again these are coordinates from the top right hand corner
of the page, they're in CSS pixels and this is the center

372
00:25:21,190 --> 00:25:24,990
of the gesture or the center of where all your fingers are.

373
00:25:24,990 --> 00:25:30,970
So with all of that, we now have the information
we need to build the rest of the picture frame.

374
00:25:30,970 --> 00:25:34,950
We've already basically built the
translation, the panning of the picture.

375
00:25:34,950 --> 00:25:40,750
That's just tracking fingers in their X and Y
coordinates, but the multitouch part which is new.

376
00:25:40,750 --> 00:25:44,080
The picture frame is actually deceptively easy to build.

377
00:25:44,080 --> 00:25:46,520
It contains only two parts.

378
00:25:48,630 --> 00:25:51,490
The image is actually larger than the frame.

379
00:25:51,490 --> 00:25:55,930
We can use something like overflow: none
on the frame to crop the image down.

380
00:25:55,930 --> 00:26:00,530
But the frame is a separate element that contains the image.

381
00:26:00,530 --> 00:26:01,670
It's just a div.

382
00:26:01,670 --> 00:26:05,870
We give it a class pictureFrame and
then underneath it is the image.

383
00:26:05,870 --> 00:26:09,530
That's it, they're the only two parts
to building this frame, two elements.

384
00:26:09,530 --> 00:26:12,620
When we set overflow: none on that frame, we crop the image.

385
00:26:12,620 --> 00:26:16,630
And when we do all these panning
effects and these rotation effects,

386
00:26:16,630 --> 00:26:19,630
all we're doing is we're moving the image behind the frame.

387
00:26:19,630 --> 00:26:21,620
The frame stays in the same place.

388
00:26:21,620 --> 00:26:26,560
We're scaling the image, applying these webkitTransforms.

389
00:26:26,560 --> 00:26:34,950
And when overflow: none is in effect, we get
this really nice sort of in frame editing effect.

390
00:26:34,950 --> 00:26:42,370
So the mark up is super simple, container
div, image on the inside of that.

391
00:26:42,370 --> 00:26:47,720
Our constructor is going to take just one parameter
element, we don't really have a callback for this.

392
00:26:47,720 --> 00:26:50,900
And we're going to hold on to a little more state.

393
00:26:50,900 --> 00:26:57,390
Gesture events, the information they report, the scale and
the rotation, they're relative to the start of the gesture.

394
00:26:57,390 --> 00:27:02,270
So we'll hold on both to the current scale
and rotation of the picture and the scale

395
00:27:02,270 --> 00:27:05,510
and the rotation when the gesture starts.

396
00:27:05,510 --> 00:27:08,330
And then we pull the image out with getElementsByTagName.

397
00:27:08,330 --> 00:27:11,500
And then we listen for gesturechange events.

398
00:27:11,500 --> 00:27:14,500
Again this is just for the rotation and the scaling.

399
00:27:14,500 --> 00:27:18,130
The panning we want to use touch events.

400
00:27:18,130 --> 00:27:21,480
Gesturechange is going to be really straight forward.

401
00:27:21,480 --> 00:27:24,070
We look at the scale of when we started the gesture.

402
00:27:24,070 --> 00:27:27,420
And we multiply it by the gesture scale.

403
00:27:27,420 --> 00:27:35,590
So if the image starts out at 200% and we bring our fingers
together so that the scale on the gesture event is 0.5,

404
00:27:35,590 --> 00:27:40,360
we multiply them and we shrink our
image back down to original size.

405
00:27:40,360 --> 00:27:46,100
Then rotation, there are degrees relative from
the starting location, so we just add that.

406
00:27:46,100 --> 00:27:49,240
And then we call this mysterious transformImage method.

407
00:27:49,240 --> 00:27:53,460
TransformImage is where we're actually going
to apply the properties and do the work.

408
00:27:53,460 --> 00:27:55,250
It's a single line.

409
00:27:55,250 --> 00:28:00,300
We're going to set an inline webkitTransform
style and build up this string.

410
00:28:00,300 --> 00:28:01,960
First we're going to translate the image.

411
00:28:01,960 --> 00:28:09,850
If we're positioning it 100 pixels left, 100 pixels
up, we're going to set both X and Y transforms there.

412
00:28:09,850 --> 00:28:12,030
Then we're going to scale the image.

413
00:28:12,030 --> 00:28:16,390
WebkitTransform takes in the same sort of
units that the gesture event will report.

414
00:28:16,390 --> 00:28:18,970
So it's easy just to translate this over into CSS.

415
00:28:18,970 --> 00:28:24,490
And then the rotation, the unit
for rotation is degrees, deg.

416
00:28:24,490 --> 00:28:28,780
And we're going to build up this string, that
concatenation is really kind of ugly in code.

417
00:28:28,780 --> 00:28:31,170
But what we're building is a string that looks like this.

418
00:28:31,170 --> 00:28:36,700
Translate3d, X and Y coordinate, scale, and rotate.

419
00:28:36,700 --> 00:28:37,580
And that's it.

420
00:28:37,580 --> 00:28:40,370
That's all we need to do to build our picture.

421
00:28:40,370 --> 00:28:45,270
All we need to do to handle scaling and rotation.

422
00:28:45,270 --> 00:28:48,390
I want to step back and talk about the DOM Event Model.

423
00:28:48,390 --> 00:28:54,790
All of these events, mouse events, touch events, gesture
events, these all fall under the system called DOM events.

424
00:28:54,790 --> 00:28:56,400
Here we have a DOM tree.

425
00:28:56,400 --> 00:29:01,030
There's two of these picture frame
controllers in the same document.

426
00:29:01,030 --> 00:29:07,430
And we're going to send an event down to say
we tap on the second picture frame control.

427
00:29:07,430 --> 00:29:14,420
So we have an event and using hit testing or something
like that, we figure out where this event is going.

428
00:29:14,420 --> 00:29:17,050
It's going to that second image in the document.

429
00:29:17,050 --> 00:29:19,000
The event is going to start at the top.

430
00:29:19,000 --> 00:29:22,720
It's going to start at your Window object,
from the browser and it's going to work its way

431
00:29:22,720 --> 00:29:24,860
down to the specific event it's trying to get to.

432
00:29:24,860 --> 00:29:26,710
It's going to work its way down to the <img>.

433
00:29:26,710 --> 00:29:29,360
This is called the capture phase.

434
00:29:29,360 --> 00:29:35,260
This event is going to be dispatched to every one of these
elements all the way from Window to Document, <html>,

435
00:29:35,260 --> 00:29:40,290
<body>, then eventually our picture frame
control, the containing <div>, and then the <img>.

436
00:29:40,290 --> 00:29:47,320
And any one of these elements that have a capture
phase event listener we'll get to handle this event.

437
00:29:47,320 --> 00:29:52,880
The event will reach our target element, the image, and
then it's going to start working its way back the other way.

438
00:29:52,880 --> 00:29:54,620
This is called the bubbling phase.

439
00:29:54,620 --> 00:29:59,920
The event starts at the most specific element
and starts working its way back up to the top.

440
00:29:59,920 --> 00:30:04,370
Once it reaches the top, returns
to the browser from whence it came.

441
00:30:04,370 --> 00:30:08,200
Normally we only work in the bubbling phase.

442
00:30:08,200 --> 00:30:10,520
Remember how addEventListener has three properties.

443
00:30:10,520 --> 00:30:15,170
It takes in the name of the event,
the callback or object and then false.

444
00:30:15,170 --> 00:30:17,180
We always just put false in there.

445
00:30:17,180 --> 00:30:23,560
That third Boolean is whether or not we're adding our
event listener to the capture phase or the bubble phase.

446
00:30:23,560 --> 00:30:29,280
If it's false, it's in the bubble phase and if
it's true, we're listening in the capture phase.

447
00:30:29,280 --> 00:30:30,310
We normally don't want that.

448
00:30:30,310 --> 00:30:36,600
We normally want to start from the most specific element
and then let event bubble up to less specific elements.

449
00:30:36,600 --> 00:30:39,220
But occasionally capture events are a really useful thing.

450
00:30:39,220 --> 00:30:42,410
If you're having a problem with a web
page and you're trying to debug it,

451
00:30:42,410 --> 00:30:45,480
you might want to add a capture event listener on document.

452
00:30:45,480 --> 00:30:51,120
It'll see basically every event
that goes down into your page.

453
00:30:51,120 --> 00:30:54,250
So with this in mind, let's go back to
these really cool controls we're building

454
00:30:54,250 --> 00:30:57,550
and we'll talk about this single finger scrolling pane.

455
00:30:57,550 --> 00:31:03,570
Now on desktop, if we want this area where we
have content and we can scroll it and it stays

456
00:31:03,570 --> 00:31:09,470
within this nice little frame, one way we might do
that is by using a div with overflow set to auto.

457
00:31:09,470 --> 00:31:14,220
The child contents larger than the,
than the div, we'll get scroll bars,

458
00:31:14,220 --> 00:31:17,420
we can use scroll wheels, all that sort of stuff.

459
00:31:17,420 --> 00:31:21,090
This actually works on iPhone and iOS.

460
00:31:21,090 --> 00:31:24,820
But you have to use two fingers
at once to scroll that content.

461
00:31:24,820 --> 00:31:26,240
It's not really discoverable.

462
00:31:26,240 --> 00:31:28,300
A lot of people have trouble finding that.

463
00:31:28,300 --> 00:31:33,270
So instead we're going to build an area that we can
scroll using just one finger, using touch events.

464
00:31:33,270 --> 00:31:37,620
So the mark up or the actual implementation
for this is extremely simple.

465
00:31:37,620 --> 00:31:39,810
In fact we've basically already built it.

466
00:31:39,810 --> 00:31:41,100
It's got two parts.

467
00:31:41,100 --> 00:31:43,970
It has the content underneath.

468
00:31:43,970 --> 00:31:47,560
The child layer, the content layer I suppose we can call it.

469
00:31:47,560 --> 00:31:49,730
This contains whatever we need it to contain.

470
00:31:49,730 --> 00:31:56,340
It could be lists, it could be images, it could be other
scrolling panes because we're programs, we like recursion,

471
00:31:56,340 --> 00:31:59,190
we like putting things into things because we can.

472
00:31:59,190 --> 00:32:01,670
And then outside of that there's the panel container.

473
00:32:01,670 --> 00:32:07,240
This'll have overflow: none set, it'll stay fixed
on the page and when we receive touch events,

474
00:32:07,240 --> 00:32:13,170
we'll simply translate that content layer, we'll
move that content layer around using webkitTransform.

475
00:32:13,170 --> 00:32:17,130
And we'll get a really nice single finger scrolling area.

476
00:32:17,130 --> 00:32:19,430
The mark up we're going to use for this is really simple.

477
00:32:19,430 --> 00:32:22,910
There's an outer scrollable class,
this is the, this is the frame.

478
00:32:22,910 --> 00:32:25,740
And then inside of that is our content layer.

479
00:32:25,740 --> 00:32:29,240
It can contain whatever we want it to contain.

480
00:32:29,240 --> 00:32:30,620
So let's take a look at this.

481
00:32:30,620 --> 00:32:35,810
I have here one of these scrolling views,
these scroll panels, scroll containers.

482
00:32:35,810 --> 00:32:39,190
And inside of it, it's a list, it just counts from 1 to 8.

483
00:32:39,190 --> 00:32:48,520
And I'm going to use a single finger and start
scrolling and that doesn't work very well.

484
00:32:48,520 --> 00:32:54,550
As I'm scrolling, as I'm trying to scroll
this container, the page is panning too.

485
00:32:54,550 --> 00:32:55,700
What's going on here?

486
00:32:55,700 --> 00:33:00,420
It really helps if we go back to the DOM Event
Model, the DOM tree to understand what's going on.

487
00:33:00,420 --> 00:33:05,820
This is a DOM tree where we have two of these scrolling
containers and we're receiving a touchmove event.

488
00:33:05,820 --> 00:33:08,730
Touchmove is how we're panning that content.

489
00:33:08,730 --> 00:33:15,120
So the touchmove starts the Content, it moves to the
Container, we actually do something like scroll our content.

490
00:33:15,120 --> 00:33:16,520
And then the event keeps going.

491
00:33:16,520 --> 00:33:17,810
It keeps bubbling.

492
00:33:17,810 --> 00:33:21,780
It goes all the way back up to the
browser and the browser gets to handle it.

493
00:33:21,780 --> 00:33:23,690
Safari gets a crack at that event.

494
00:33:23,690 --> 00:33:29,390
Now Safari's default action, what Safari usually
does on a touchmove event is it pans the page.

495
00:33:29,390 --> 00:33:36,840
This isn't necessarily the case with say a desktop browser
where a mouse move pans, pans the page or scrolls the page.

496
00:33:36,840 --> 00:33:43,790
But these default actions always bubble up to the
browser and the browser does its default thing.

497
00:33:43,790 --> 00:33:49,000
Instead of letting that happen, what we really
want to do is after we handle the touchmove event,

498
00:33:49,000 --> 00:33:55,000
after we scroll out content, we want to let
Safari know that we've handled the event.

499
00:33:55,000 --> 00:33:56,150
We've taken care of it.

500
00:33:56,150 --> 00:33:58,270
Safari shouldn't do its default thing.

501
00:33:58,270 --> 00:33:59,960
And there's a method for that.

502
00:33:59,960 --> 00:34:01,790
It's called preventDefault.

503
00:34:01,790 --> 00:34:05,450
We call this on the event, the event gets canceled.

504
00:34:05,450 --> 00:34:08,050
It's marked as already having been handled.

505
00:34:08,050 --> 00:34:13,430
The event will still continue to propagate, it'll go all
the way back up to Safari, but once it reaches there,

506
00:34:13,430 --> 00:34:17,890
Safari will see the event has been handled
and it won't do its default action.

507
00:34:17,890 --> 00:34:26,330
So if we go back to our scroller and we add that
preventDefault call and we try sending touchmoves to scroll.

508
00:34:26,330 --> 00:34:28,010
Now it works great.

509
00:34:28,010 --> 00:34:30,680
We have this pane that we can scroll
with just a single finger.

510
00:34:30,680 --> 00:34:35,150
Now I said we can put anything we want in here.

511
00:34:35,150 --> 00:34:37,500
We can put another scroller perhaps.

512
00:34:37,500 --> 00:34:39,560
So let's try that.

513
00:34:39,560 --> 00:34:42,750
Here's another scroller, the individual
items are a little bit larger,

514
00:34:42,750 --> 00:34:45,780
but we still have these same numbers and we're counting up.

515
00:34:45,780 --> 00:34:52,500
And then I have this imbedded lists that counts
letters instead, you can count letters I suppose.

516
00:34:52,500 --> 00:34:56,120
And let's try scrolling, we're going to see that it works.

517
00:34:56,120 --> 00:35:00,220
Terribly. They're both scrolling.

518
00:35:00,220 --> 00:35:02,770
They're both scrolling at the same time.

519
00:35:02,770 --> 00:35:04,920
If I scroll on the outer one, it's fine.

520
00:35:04,920 --> 00:35:13,370
But as I'm trying to scroll this internal, this interior
letter list, both scrollers are trying to scroll.

521
00:35:13,370 --> 00:35:15,790
What's going on here?

522
00:35:15,790 --> 00:35:20,950
Again, it really helps if we go back to the DOM
Event Model, see what's going on with these events.

523
00:35:20,950 --> 00:35:26,320
Touchmove starts at the interior scroller, it
moves up to the Container and we cancel it.

524
00:35:26,320 --> 00:35:27,930
We mark it as handled.

525
00:35:27,930 --> 00:35:29,960
But then the event keeps propagating.

526
00:35:29,960 --> 00:35:35,480
It goes to the exterior container, the
exterior scroller and that also scrolls.

527
00:35:35,480 --> 00:35:37,130
Now we could do a couple of things here.

528
00:35:37,130 --> 00:35:42,710
We could say check to see if the event has been
canceled and not scroll our outer container,

529
00:35:42,710 --> 00:35:45,840
or we could do something a little bit different.

530
00:35:45,840 --> 00:35:49,520
Once we've handled the touchmove event,
we're done with that touchmove event.

531
00:35:49,520 --> 00:35:52,700
We really don't want anything else
to get that touchmove event.

532
00:35:52,700 --> 00:35:54,430
So we call this other method.

533
00:35:54,430 --> 00:35:56,110
StopPropagation.

534
00:35:56,110 --> 00:35:57,820
It does what it says on the box.

535
00:35:57,820 --> 00:35:59,480
It destroys the event.

536
00:35:59,480 --> 00:36:03,460
No other event handler will receive that touchmove event.

537
00:36:03,460 --> 00:36:06,550
We'll be the last bit of code to see that event.

538
00:36:06,550 --> 00:36:08,780
So the outer container never sees it.

539
00:36:08,780 --> 00:36:12,500
It never acknowledges that exists.

540
00:36:12,500 --> 00:36:15,290
We can give this a try.

541
00:36:15,290 --> 00:36:21,310
Instead of calling just preventDefault, let's call
stopPropagation on that interior scroller first.

542
00:36:21,310 --> 00:36:25,390
The outer one works and the inner one works too.

543
00:36:25,390 --> 00:36:28,540
So we can scroll our two lists independently of each other.

544
00:36:28,540 --> 00:36:34,050
[ Applause ]

545
00:36:34,050 --> 00:36:35,990
This is one of those things that you actually have to try.

546
00:36:35,990 --> 00:36:37,940
You actually have to feel.

547
00:36:37,940 --> 00:36:44,660
It's amazing how with CSS transforms and touch
events you can get this really responsive.

548
00:36:44,660 --> 00:36:46,550
And we've built our scrolling pane.

549
00:36:46,550 --> 00:36:52,920
We now have these areas that we can scroll
with just one finger in our web content.

550
00:36:54,050 --> 00:36:57,330
So we've talked about a ton of things today.

551
00:36:57,330 --> 00:36:59,800
And since I've got you all looking at
me and paying attention still, I hope,

552
00:36:59,800 --> 00:37:07,290
while I've got your attention I want to talk, just share
a couple of last minute totally super awesome tips.

553
00:37:07,290 --> 00:37:10,310
First, go try this.

554
00:37:10,310 --> 00:37:14,520
There's a lot of details that are always
inherent when you're building any kind

555
00:37:14,520 --> 00:37:16,900
of UI, especially any kind of really rich UI.

556
00:37:16,900 --> 00:37:17,880
Give it a try.

557
00:37:17,880 --> 00:37:19,200
Download the sample code.

558
00:37:19,200 --> 00:37:26,180
All of those event bubbles and that scrapbook demo,
they're both available from the WWDC attendee site.

559
00:37:26,180 --> 00:37:32,290
If you log in, find this session number 508 and
then click the More Info inside that grid view,

560
00:37:32,290 --> 00:37:36,050
you can download the sample code, check it out.

561
00:37:36,050 --> 00:37:40,500
We're doing a few other things, a few that
we kind of glossed over in this presentation.

562
00:37:40,500 --> 00:37:42,340
So give it a try.

563
00:37:42,340 --> 00:37:46,470
As you're experimenting, remember, multitouch.

564
00:37:46,470 --> 00:37:48,550
So the touch event that you get, the touch event

565
00:37:48,550 --> 00:37:54,450
that your event handler has delivered is a
list of touches and there's three of them.

566
00:37:54,450 --> 00:37:58,460
Second, I stopped doing this, I got
lazy part way through the presentation.

567
00:37:58,460 --> 00:37:59,970
Don't get lazy yourselves.

568
00:37:59,970 --> 00:38:01,350
Handle touchcancel.

569
00:38:01,350 --> 00:38:03,270
They're going to come when you least expect it.

570
00:38:03,270 --> 00:38:05,180
It means you have to reset state.

571
00:38:05,180 --> 00:38:11,040
So if you need to reset any variables that you're
holding onto or maybe reset some CSS styles,

572
00:38:11,040 --> 00:38:14,120
make sure you do that handle touchcancel.

573
00:38:14,120 --> 00:38:18,300
And lastly, actually test on your iPhone on your iPad.

574
00:38:18,300 --> 00:38:20,240
The simulator is an awesome tool.

575
00:38:20,240 --> 00:38:26,160
I love using it for development work, but nothing
really beats actually trying this stuff on hardware.

576
00:38:26,160 --> 00:38:28,950
You're going to find things that you didn't
realize when you're using the simulator

577
00:38:28,950 --> 00:38:32,180
like maybe your buttons are too small for your fingers.

578
00:38:32,180 --> 00:38:34,070
Or maybe your text needs to be bigger.

579
00:38:34,070 --> 00:38:37,720
Or maybe your hand obscures more of
the screen than you think it did.

580
00:38:37,720 --> 00:38:42,480
When we're building sites for desktop, we might
build a menu that pops underneath the mouse cursor.

581
00:38:42,480 --> 00:38:49,260
But if you think about how your hands work, if you tap
that menu, it's going to pop underneath your hands.

582
00:38:49,260 --> 00:38:50,980
That's not so good.

583
00:38:50,980 --> 00:38:54,590
Instead you might want to build a menu
that pops above where you're touching.

584
00:38:54,590 --> 00:38:57,120
So test on hardware.

585
00:38:57,120 --> 00:38:59,880
We've talked about a bunch of things today.

586
00:38:59,880 --> 00:39:03,070
We've talked about touch events and gesture events.

587
00:39:03,070 --> 00:39:10,660
The APIs, how they're delivered, what they look like, four
touch events, three gesture events, they come interleaved.

588
00:39:10,660 --> 00:39:14,130
We've talked about strategies for
building reusable interface components,

589
00:39:14,130 --> 00:39:17,860
how to keep your code organized with this sort of code.

590
00:39:17,860 --> 00:39:21,830
You try using an object as that
second parameter to addEventListener.

591
00:39:21,830 --> 00:39:25,770
You'd be surprised how much it can
really clean up your event handling code.

592
00:39:25,770 --> 00:39:31,870
And lastly, there is a ton of built in power
to CSS transforms and the DOM Event Model.

593
00:39:31,870 --> 00:39:37,350
Instead of reinventing the wheel and building
additional state handling information tracking events

594
00:39:37,350 --> 00:39:39,610
by hand, use what's already there.

595
00:39:39,610 --> 00:39:41,260
Use the power that's already there.

596
00:39:41,260 --> 00:39:42,810
Try this out.

597
00:39:42,810 --> 00:39:48,540
Really, there's, for touch events especially,
nothing beats actually writing code yourself.

598
00:39:48,540 --> 00:39:53,800
If you have additional questions, you can always contact
Vicky Murley, our Safari Technologies Evangelist.

599
00:39:53,800 --> 00:39:58,880
There's documentation on developer.apple.com/safari,
information about touch events

600
00:39:58,880 --> 00:40:02,470
and the touch event model and how they're delivered.

601
00:40:02,470 --> 00:40:06,140
If you're really interested in learning
more about DOM events and how they work,

602
00:40:06,140 --> 00:40:12,440
the DOM Level 3 Events Specification spells all of
this and all of it is regular specification gory.

603
00:40:12,440 --> 00:40:17,580
If you're really interested, try starting
with the DOM Level 2 Event Specification.

604
00:40:17,580 --> 00:40:20,880
It contains all the stuff we talked
about today like stopPropagation,

605
00:40:20,880 --> 00:40:24,030
preventDefault, but it's a bit easier to read.

606
00:40:24,030 --> 00:40:25,740
And there's the Developer Forums.

607
00:40:25,740 --> 00:40:26,710
You can ask questions in there.

608
00:40:26,710 --> 00:40:29,870
There's a forum specifically for
building web applications for iPhone.

