1
00:00:07,470 --> 00:00:08,500
>> All right.

2
00:00:08,500 --> 00:00:09,450
Good morning everyone.

3
00:00:09,450 --> 00:00:10,000
[ Applause ]

4
00:00:10,000 --> 00:00:13,700
Welcome to Customizing Maps with Overlays.

5
00:00:13,700 --> 00:00:14,560
Thank you.

6
00:00:14,560 --> 00:00:18,990
I'm James Howard, I'm a software engineer on
the Map Kit Team, and I'm going to show you

7
00:00:18,990 --> 00:00:26,020
in this presentation today how to display geographic
data that covers an area on top of your map.

8
00:00:28,910 --> 00:00:33,870
So we're going to start with just a quick review of Map Kit
so we see where we came from, and then we're going to go

9
00:00:33,870 --> 00:00:37,260
into what's new in Map Kit, which is, primarily, overlays.

10
00:00:37,260 --> 00:00:40,120
And for this session I've prepared five demos.

11
00:00:40,120 --> 00:00:46,780
At this time I'd like you to go to the session
website, so if you go into session list and follow it

12
00:00:46,780 --> 00:00:51,250
down to this session, you'll see there's
a list of the sample code on the bottom.

13
00:00:51,250 --> 00:00:56,310
If you can, and you have your laptop, I'd encourage you
to go download that sample code so you can follow along.

14
00:00:56,310 --> 00:00:59,420
And I think the sample codes is going to be
really useful to you in your development.

15
00:00:59,420 --> 00:01:04,320
So get a hold of that right now.

16
00:01:04,320 --> 00:01:07,090
So while you're downloading that, let's do a quick review.

17
00:01:07,090 --> 00:01:08,360
What is Map Kit?

18
00:01:08,360 --> 00:01:10,780
Originally, it came out in iPhone OS 3.0.

19
00:01:10,780 --> 00:01:13,240
It lets you put a map in your application.

20
00:01:13,240 --> 00:01:15,150
You can programmatically control that map.

21
00:01:15,150 --> 00:01:17,770
So have it pan around.

22
00:01:17,770 --> 00:01:23,380
The user can interact with it by pinching or
panning, double tapping, two finger tapping.

23
00:01:23,380 --> 00:01:25,170
You can annotate the map however you like.

24
00:01:25,170 --> 00:01:30,160
So you can put pins or other annotations,
custom views, on top of map.

25
00:01:30,160 --> 00:01:31,560
And finally, there's reverse geocoding.

26
00:01:31,560 --> 00:01:35,790
So reverse geocoding is, you have a
point, so a latitude and longitude,

27
00:01:35,790 --> 00:01:38,360
and you want to find out what is the
address that corresponds to that.

28
00:01:38,360 --> 00:01:40,050
So that's reverse geocoding.

29
00:01:40,050 --> 00:01:45,460
So I've put together a couple of
videos here illustrating these points.

30
00:01:45,460 --> 00:01:58,880
So there's pan and zoom; annotations; user locations, so
you get that blue gem representing the user's location

31
00:01:58,880 --> 00:02:01,400
so we integrate with Core Location to do that.

32
00:02:01,400 --> 00:02:07,000
And then there's reverse geocoding, so we
dropped pin at that point and then figured

33
00:02:07,000 --> 00:02:08,500
out what is the address that corresponds to it.

34
00:02:08,500 --> 00:02:10,400
So you can do that all last year.

35
00:02:10,400 --> 00:02:12,420
Let's move on to what you can do this year.

36
00:02:12,420 --> 00:02:16,710
Overlays. So this is -- you have an area
and you want to draw something in it.

37
00:02:16,710 --> 00:02:22,360
An example of this is like a transit map or a
traffic overlay or national park overlay or a state

38
00:02:22,360 --> 00:02:27,920
or local boundaries, any of those sorts of things weren't
really possible to do with Map Kit before, now they are.

39
00:02:27,920 --> 00:02:32,910
We also have draggable annotations, so it's much easier
to put a pin on the map and allow the user to press

40
00:02:32,910 --> 00:02:34,680
and hold and then drag that thing around.

41
00:02:34,680 --> 00:02:35,630
So that's really nice.

42
00:02:35,630 --> 00:02:41,010
We also have a handful of new delegate messages that
make it easier to keep track of the user location,

43
00:02:41,010 --> 00:02:44,000
as well as when your annotations
are selected and deselected.

44
00:02:44,000 --> 00:02:46,120
So that's what's new.

45
00:02:46,120 --> 00:02:48,760
So on to annotations and overlays.

46
00:02:48,760 --> 00:02:54,200
So if you're familiar with Map Kit, if you've
programmed with it before, you know about annotations.

47
00:02:54,200 --> 00:02:55,680
They represent a single point.

48
00:02:55,680 --> 00:02:57,910
So we have this pin here stuck in California.

49
00:02:57,910 --> 00:03:02,340
It corresponds to a single latitude and longitude.

50
00:03:02,340 --> 00:03:05,000
New in iOS 4 is overlays.

51
00:03:05,000 --> 00:03:09,510
So I've put an overlay here that represents
the state of California, so it's this --

52
00:03:09,510 --> 00:03:14,720
[ Applause ]

53
00:03:14,720 --> 00:03:15,520
Yeah, it's great.

54
00:03:15,520 --> 00:03:16,730
It's really great.

55
00:03:16,730 --> 00:03:19,450
It's even better when you see it in action,
which I'm going to get to in just a moment.

56
00:03:19,450 --> 00:03:25,240
So yeah, it's covering this area, so as you pinch
on the map, it tracks the map and sticks with it.

57
00:03:25,240 --> 00:03:27,680
So it's really a very seamless experience.

58
00:03:27,680 --> 00:03:29,650
So that's overlays.

59
00:03:29,650 --> 00:03:33,800
So we have a handful of built in
overlays, so let me just run through those.

60
00:03:33,800 --> 00:03:37,520
There's circles, so you have a center and a radius.

61
00:03:37,520 --> 00:03:39,180
This is good for drawing.

62
00:03:39,180 --> 00:03:43,330
You can draw things like you have an
accuracy or just any sort of radius

63
00:03:43,330 --> 00:03:46,720
that you want to draw about some center, so circles.

64
00:03:46,720 --> 00:03:53,260
There's polylines, so if you have a route or a
path, a list of points, you can draw a polyline.

65
00:03:53,260 --> 00:03:57,730
Polygons. I have the polygon outlining
the Presidio, in San Francisco here.

66
00:03:57,730 --> 00:04:01,300
We also support polygons that have
cutouts in them, so Arlington,

67
00:04:01,300 --> 00:04:05,100
Texas is an example of a place that a polygon has a cutout.

68
00:04:05,100 --> 00:04:06,680
So we do that as well.

69
00:04:06,680 --> 00:04:08,300
And then finally, there's custom overlays.

70
00:04:08,300 --> 00:04:12,050
So you can really draw whatever
geographic data you want on top of the map.

71
00:04:12,050 --> 00:04:18,950
So this is an example of earthquake danger in
the United States that I've drawn on the map.

72
00:04:18,950 --> 00:04:20,250
So layer ordering.

73
00:04:20,250 --> 00:04:24,500
So initially when you put an MKMapView in
your application, you have the base map.

74
00:04:24,500 --> 00:04:31,890
So this is base map imagery, and then above that go
any overlays that you add so they sit right on top

75
00:04:31,890 --> 00:04:35,260
of map, and then above that are any annotations.

76
00:04:35,260 --> 00:04:38,430
So the thing to take away from this
is your annotations are always on top

77
00:04:38,430 --> 00:04:41,990
of your overlays are always on top of the base map.

78
00:04:41,990 --> 00:04:44,500
So how do you add an overlay to the map?

79
00:04:44,500 --> 00:04:48,530
Just like with annotations, you must add in model objects.

80
00:04:48,530 --> 00:04:51,550
So we have model objects corresponding to all our overlays.

81
00:04:51,550 --> 00:04:53,690
We add those to the map initially using addOverlay.

82
00:04:53,690 --> 00:04:57,970
So in this example we have a circle, we set
it with a center coordinate and a radius,

83
00:04:57,970 --> 00:05:01,280
so this is describing where in the world this circle lives.

84
00:05:01,280 --> 00:05:02,700
We add that to the map.

85
00:05:02,700 --> 00:05:05,430
That doesn't necessarily put it on screen.

86
00:05:05,430 --> 00:05:10,410
It's only when the map decides, "OK, this thing is getting
close to being in view, or it's now going to be in view,"

87
00:05:10,410 --> 00:05:15,420
at that point, we're going to call back to you on your Map
Views delegate, and you're going to get viewForOverlay.

88
00:05:15,420 --> 00:05:20,460
So at that point we're going to create the corresponding
view, so because we put an MKCircle in there,

89
00:05:20,460 --> 00:05:26,830
we need an MKCircleView, customize how that
looks, so let's make it red, and return that.

90
00:05:26,830 --> 00:05:28,740
So let's do a demo.

91
00:05:28,740 --> 00:05:37,080
So with my first demo, I'm just going to show
you the very like most basic use of this.

92
00:05:37,080 --> 00:05:37,820
So let me build and run.

93
00:05:37,820 --> 00:05:39,780
All right.

94
00:05:42,710 --> 00:05:47,890
So I've got the Presidio there, and I've got
a little walking route actually from here

95
00:05:47,890 --> 00:05:49,710
at the Moscone Center over to Golden Gate Park.

96
00:05:49,710 --> 00:05:56,840
And what I want to show you is, as you use your pinches
on this and zooms in, you get very nice, seamless zooming.

97
00:05:56,840 --> 00:05:59,300
It's as though it's a part of the map.

98
00:05:59,300 --> 00:06:03,470
So it's not like it's removed and then redrawn, it's as
though it's part of it, and if you were to double tap

99
00:06:03,470 --> 00:06:07,510
and zoom in you get a seamless
cross fading with your overlays.

100
00:06:07,510 --> 00:06:12,550
[ Applause ]

101
00:06:12,550 --> 00:06:13,510
Yeah. It's nice, huh.

102
00:06:13,510 --> 00:06:15,550
[ Laughter ]

103
00:06:15,550 --> 00:06:19,490
And also, as you zoom in and pan
along these things, they reveal.

104
00:06:19,490 --> 00:06:21,600
So it's really as though it's a part of the map.

105
00:06:21,600 --> 00:06:23,530
It's a very seamless experience.

106
00:06:23,530 --> 00:06:25,590
So what's the code necessary to do this?

107
00:06:25,590 --> 00:06:28,560
Let's hop into the view controller here really quickly.

108
00:06:28,560 --> 00:06:32,590
Let's hide the implementation of viewForOverlay
for a moment, just look at adding overlays.

109
00:06:32,590 --> 00:06:35,390
So I have a list of points comprising that Presidio.

110
00:06:35,390 --> 00:06:41,070
So I create a polygon corresponding to those
points, and then I simply add it to the map.

111
00:06:41,070 --> 00:06:43,110
And I do the same thing for the walking lines.

112
00:06:43,110 --> 00:06:45,500
So I create a polyline for that, add that to the map.

113
00:06:45,500 --> 00:06:47,470
So now I'm registering these two overlays with the map.

114
00:06:47,470 --> 00:06:50,540
It doesn't mean they're going to be displayed
right away, just that the map is aware

115
00:06:50,540 --> 00:06:52,470
that they live in that part one of the world.

116
00:06:52,470 --> 00:06:57,840
And then, finally, I'm going to position the map so that
those two things are both visible, and at that point,

117
00:06:57,840 --> 00:07:00,740
since the map is being positioned so
they're visible, we're going to need views.

118
00:07:00,740 --> 00:07:04,560
So viewForOverlay is going to be called,
and then we're going to inspect, "OK,

119
00:07:04,560 --> 00:07:06,310
for each of these overlays, what kind is it?"

120
00:07:06,310 --> 00:07:09,090
If it's a polyline, then we need a polylineView.

121
00:07:09,090 --> 00:07:11,510
So we do that.

122
00:07:11,510 --> 00:07:13,010
Return the corresponding polylineView.

123
00:07:13,010 --> 00:07:18,680
And if it's a polygon, return the corresponding polygonView.

124
00:07:18,680 --> 00:07:21,680
So just one more time.

125
00:07:21,680 --> 00:07:23,450
Build and run.

126
00:07:26,500 --> 00:07:28,160
And there we have them.

127
00:07:28,160 --> 00:07:32,790
So I've got one more demo I want to show you before
we go back to the slides, and this is a CAML Viewer.

128
00:07:32,790 --> 00:07:37,620
So we don't have CAML viewing built into
Map Kit, but I have this nice little sample.

129
00:07:37,620 --> 00:07:39,230
And you can take this and use this in your program.

130
00:07:39,230 --> 00:07:40,460
So what is CAML?

131
00:07:40,460 --> 00:07:44,510
CAML is XML file format for describing
geographic information.

132
00:07:44,510 --> 00:07:46,200
I have a couple of CAML files here.

133
00:07:46,200 --> 00:07:48,370
Let me just pop one of them open,
you can see what it looks like.

134
00:07:48,370 --> 00:07:56,230
So this is a route between Apple's campus
and Antonio's Nut House in Palo Alto.

135
00:07:56,230 --> 00:07:59,730
It's a bicycling route that I actually
exported from Google's website.

136
00:07:59,730 --> 00:08:03,500
And this CAML view, let me just build and run it.

137
00:08:03,500 --> 00:08:07,450
[ Building code ]

138
00:08:07,450 --> 00:08:09,550
Oh, that's not the one I wanted to show.

139
00:08:09,550 --> 00:08:12,180
Let's just switch this route.

140
00:08:12,180 --> 00:08:18,240
So there we go.

141
00:08:18,240 --> 00:08:23,710
We're displaying CAML, and I've got the way points
along here, and the route that we're showing.

142
00:08:23,710 --> 00:08:28,820
So I think that's a pretty nice way to display CAML, and if
you've downloaded the sample code, you'll be able to use it

143
00:08:28,820 --> 00:08:31,670
to display CAML in your own programs as well.

144
00:08:31,670 --> 00:08:34,670
So just really quick, let's look at the interface for this.

145
00:08:34,670 --> 00:08:40,360
You can parse a CAML file at a URL or a path, and then
you're going to get a list back of all the overlays

146
00:08:40,360 --> 00:08:43,210
and all the points, or all the annotations in that.

147
00:08:43,210 --> 00:08:48,400
And so how we use this in the view controller
is, we parse that CAML file in our bundle,

148
00:08:48,400 --> 00:08:51,830
so you already saw me parsing a different
one, and I just switched over to this one.

149
00:08:51,830 --> 00:08:56,550
Parse that, then add all the overlays,
add all the annotations,

150
00:08:56,550 --> 00:09:04,600
fly the map to an area that covers all those points, and
then finally, when we need to get a view for an overlay

151
00:09:04,600 --> 00:09:08,410
or a view for an annotation, we just
proxy that over to the CAML parser.

152
00:09:08,410 --> 00:09:12,350
So this is a nice way to display some
basic CAML files in your applications.

153
00:09:12,350 --> 00:09:16,680
Let me just switch that back to the other one.

154
00:09:16,680 --> 00:09:21,140
This is -- this other CAML file
is a running route that I got

155
00:09:21,140 --> 00:09:24,720
from our Map Kit Evangelist Mark
Malone who's sitting over there.

156
00:09:24,720 --> 00:09:27,830
He did a run, and he has a little, like, runner's GPS,

157
00:09:27,830 --> 00:09:32,460
and so it exported this CAML file,
so this is a run around a park in Japan.

158
00:09:32,460 --> 00:09:34,350
So pretty neat.

159
00:09:37,000 --> 00:09:39,500
Yeah. So that's the CAML Viewer.

160
00:09:39,500 --> 00:09:45,720
[ Applause ]

161
00:09:45,720 --> 00:09:48,630
So just to summarize: What is the
process for adding overlays?

162
00:09:48,630 --> 00:09:54,320
We take the model object and we add it to the map, and then
when the map is ready, it's going to call us and ask us

163
00:09:54,320 --> 00:09:56,350
for a view, and we provide the corresponding view.

164
00:09:56,350 --> 00:09:59,110
So very similar to the process for adding annotations.

165
00:09:59,110 --> 00:10:00,820
All right.

166
00:10:00,820 --> 00:10:04,190
So let's move on to the meat of it: Custom overlays.

167
00:10:04,190 --> 00:10:09,960
So if you want to implement a custom overlay, you need to
have a model object that implements the MKOverlay protocol.

168
00:10:09,960 --> 00:10:13,800
And the property that you need to
implement for this is the boundingMapRect.

169
00:10:13,800 --> 00:10:17,250
So you need to tell Map Kit, what
is the bounds of this thing.

170
00:10:17,250 --> 00:10:18,430
Where does it live in the world?

171
00:10:18,430 --> 00:10:20,060
So you return a boundingMapRect.

172
00:10:20,060 --> 00:10:22,880
So this is a new type, MKMapRect.

173
00:10:22,880 --> 00:10:27,780
I'm going to describe what this type is, but
it's a new coordinate system for Map Kit in iOS 4

174
00:10:27,780 --> 00:10:32,140
and that's the Core Net system you're
going to use to return the boundingMapRect.

175
00:10:32,140 --> 00:10:36,890
And then for the view, you're going to draw just a part
of the view at a time, so Map Kit's going to say, "OK,

176
00:10:36,890 --> 00:10:40,580
draw -- draw this MapRect at this zoom scale."

177
00:10:40,580 --> 00:10:42,130
So you're not necessarily drawing the whole thing.

178
00:10:42,130 --> 00:10:48,440
If you think about -- think back to that example of
the state of California, the outline of California,

179
00:10:48,440 --> 00:10:50,800
if you zoomed all the way in, that thing would be enormous.

180
00:10:50,800 --> 00:10:54,950
It would be thousands perhaps millions of
screen points that it's really consuming

181
00:10:54,950 --> 00:10:56,250
if you were to scroll along the length of that.

182
00:10:56,250 --> 00:10:57,560
So we can't draw that all at once.

183
00:10:57,560 --> 00:10:59,610
You can't make a view that's that big.

184
00:10:59,610 --> 00:11:04,890
So we cut it up into tiles, and we draw it just
the tiles corresponding to the area that we need.

185
00:11:04,890 --> 00:11:07,170
So that's drawMapRect.

186
00:11:07,170 --> 00:11:08,360
And there's one thing you need to know.

187
00:11:08,360 --> 00:11:14,380
So when I said -- we're introducing MKMapPoint
and MKMapRect as a new coordinate system,

188
00:11:14,380 --> 00:11:16,670
you need to know about the map projection that we use.

189
00:11:16,670 --> 00:11:24,430
So in Map Kit we use the Mercator projection to
map the 3D sphere of the Earth onto a 2D map.

190
00:11:24,430 --> 00:11:31,990
And this has a property that, as you go towards the pole,
the map is stretched in the latitudinal or the y direction.

191
00:11:31,990 --> 00:11:36,130
So this image up here sort of illustrates that.

192
00:11:36,130 --> 00:11:42,770
These circles are all the same size; they're all 500
kilometers in diameter or 250 kilometers in radius.

193
00:11:42,770 --> 00:11:46,820
And they're all spaced equally;
they're all 16 degrees apart.

194
00:11:46,820 --> 00:11:48,230
So how do you take advantage of this?

195
00:11:48,230 --> 00:11:54,060
You need to use MKMapPoint and MKMapRect to convert your
latitudes and longitudes and your distances into map points,

196
00:11:54,060 --> 00:11:59,210
which you can then draw, so you get -- you'll get
a nice overlay that corresponds to the base map.

197
00:11:59,210 --> 00:12:00,550
Because that's really what you want to do.

198
00:12:00,550 --> 00:12:03,550
You don't want to just draw something that's
not going to line up with the base map.

199
00:12:03,550 --> 00:12:05,180
This is real geographical data.

200
00:12:05,180 --> 00:12:09,190
It corresponds to somewhere in the
world, and so it needs to line up.

201
00:12:09,190 --> 00:12:10,050
So how do you do this?

202
00:12:10,050 --> 00:12:11,630
You use MKMapPoint.

203
00:12:11,630 --> 00:12:14,660
So your overlays must be drawn using these.

204
00:12:14,660 --> 00:12:18,860
And they can represent any point on the map, and
they have a linear relationship with screen points.

205
00:12:18,860 --> 00:12:23,990
So whereas latitude and longitude don't have a linear
relationship with screen points, MKMapPoint does.

206
00:12:23,990 --> 00:12:30,290
And MKMapPoint is a double precision type, so it has
sufficient precision to represent anywhere in the world.

207
00:12:30,290 --> 00:12:33,850
And you just use MKMapPoint for coordinate
to convert your latitude and longitudes

208
00:12:33,850 --> 00:12:37,320
into map points which you can then go ahead and draw.

209
00:12:37,320 --> 00:12:41,020
So one thing else I want to talk about is gridded data.

210
00:12:41,020 --> 00:12:45,540
So I'm going to show a demo in just
a minute of earthquake hazard data.

211
00:12:45,540 --> 00:12:47,740
I showed that just as a screen shot earlier.

212
00:12:47,740 --> 00:12:53,680
And this comes from the U.S. Geological Survey in a
regular grid, so it's every .05 degrees of latitude

213
00:12:53,680 --> 00:12:58,570
and longitude they have a square, and say, what is
the earthquake hazard likelihood in that square.

214
00:12:58,570 --> 00:13:03,660
So if you think about that it looks something like
this, like, you know, you can see in the middle here,

215
00:13:03,660 --> 00:13:07,360
this is a high hazard area, and then around that it's not.

216
00:13:07,360 --> 00:13:10,950
So in this case these are 10 degree square.

217
00:13:10,950 --> 00:13:12,090
What does that look like on a sphere?

218
00:13:12,090 --> 00:13:16,740
So depending on what angle you're looking at the sphere
of the Earth at, it may even look like a trapezoid.

219
00:13:16,740 --> 00:13:20,640
So even though it was a square in terms of
thinking about it in latitude and longitude,

220
00:13:20,640 --> 00:13:23,910
it's not necessarily a square depending
on how you look at the Earth.

221
00:13:23,910 --> 00:13:29,850
And it's not drawn as a square on the map, it's actually
a rectangle, but by just converting the corner coordinates

222
00:13:29,850 --> 00:13:34,890
to map points and then creating a MapRect
out of that, you'll get the correct MapRect

223
00:13:34,890 --> 00:13:36,710
that corresponds to the area that you're trying to draw.

224
00:13:36,710 --> 00:13:38,500
So let me show you a demo of how this works.

225
00:13:38,500 --> 00:13:47,060
[ Searching for demo ]

226
00:13:47,060 --> 00:13:47,750
There it is.

227
00:13:47,750 --> 00:13:53,260
So let me just build and run this
so you can see what it looks like.

228
00:13:53,260 --> 00:14:02,130
So I downloaded this off of the U.S. Geological
Survey website, and it's that .05 degree grid,

229
00:14:02,130 --> 00:14:06,920
so you can see that in California here,
we have a high earthquake likelihood.

230
00:14:06,920 --> 00:14:10,230
This is -- this is the edge of the data,
it's just the continental United States,

231
00:14:10,230 --> 00:14:12,390
so you can see there's sort of a sharp line there.

232
00:14:12,390 --> 00:14:15,430
I assume that out in the Pacific Ocean they
also have a high earthquake likelihood,

233
00:14:15,430 --> 00:14:20,280
but the U.S. just doesn't sample that,
so this is what we're displaying.

234
00:14:20,280 --> 00:14:23,720
And this is made up of tiny little
squares of latitude and longitudes.

235
00:14:23,720 --> 00:14:27,570
Those things actually become rectangles
when they're MapRects.

236
00:14:27,570 --> 00:14:30,430
So let me just show you my model object.

237
00:14:30,430 --> 00:14:35,010
So this is my object that's implementing
MKOverlay, and there's a bunch of coding here.

238
00:14:35,010 --> 00:14:40,050
There's I think a little over 600,000 earthquake
samples in the data file that we're reading.

239
00:14:40,050 --> 00:14:46,240
But when we actually get down to an individual one, we're
going to have, basically, an upper left and a lower right

240
00:14:46,240 --> 00:14:50,450
in terms of coordinates, so these are CL
location coordinates 2D, latitude and longitude.

241
00:14:50,450 --> 00:14:55,680
And we just need to convert that into a MapRect, so we find
the upper left and the lower right in terms of map points,

242
00:14:55,680 --> 00:15:00,830
and we convert that into a MapRect, and so that's the
thing that we're actually going to be able to draw.

243
00:15:00,830 --> 00:15:07,240
So if we flip over to the implementation of
the view, we're going to call that method,

244
00:15:07,240 --> 00:15:08,950
and so this is the method that goes in there.

245
00:15:08,950 --> 00:15:12,940
There's a bit of code for doing a little nearest
neighbor sub-sampling, because when we're zoomed way out,

246
00:15:12,940 --> 00:15:17,740
we don't need to display all 600,000 samples, we
can display a little less and still look fine.

247
00:15:17,740 --> 00:15:20,410
But basically what it's doing is
the code I just highlighted.

248
00:15:20,410 --> 00:15:25,450
So we get that list of earthquake values and
their boundaries, and then for each of those,

249
00:15:25,450 --> 00:15:29,650
we can just loop over them, so we have a boundary,
and we have the color that we need to color that.

250
00:15:29,650 --> 00:15:34,260
And at that point, now that we have as a MapRect,
we can just convert it into local coordinates,

251
00:15:34,260 --> 00:15:41,210
so this is a linear relationship between our MapRect and
our local coordinates, it's just offset a little bit,

252
00:15:41,210 --> 00:15:44,940
and at that point, we have a CGRect
which we can finally draw.

253
00:15:44,940 --> 00:15:50,640
So that's how you would go from latitude and longitude
to map points to a Rect that you can finally draw.

254
00:15:50,640 --> 00:15:56,740
And just to show you in the view controller how this
is used, it's just like with the built in overlay.

255
00:15:56,740 --> 00:16:04,510
We create our hazard map which is a model class, we add
it to the map, and then provide the corresponding view.

256
00:16:04,510 --> 00:16:06,540
So let me just run this one more time.

257
00:16:06,540 --> 00:16:14,270
And this time what I want to do is I want to zoom in really
close in on this, so .05 degrees seems pretty accurate,

258
00:16:14,270 --> 00:16:19,820
but you can actually zoom in way farther than a .05
degree resolution map because you actually start to see --

259
00:16:19,820 --> 00:16:23,450
look, here's the actual rectangles
in that data they've sampled,

260
00:16:23,450 --> 00:16:26,230
and what you can see is they're
not precisely squares anymore,

261
00:16:26,230 --> 00:16:29,200
they've become rectangles when they're projected on the map.

262
00:16:29,200 --> 00:16:32,320
But the nice thing is because we're doing
this, we're converting the map points,

263
00:16:32,320 --> 00:16:36,880
we know that this area right here, this is really what they
meant when they said, this is the sample that corresponds

264
00:16:36,880 --> 00:16:41,220
to that, so our data that we got from
the USGS is lining up with our base map.

265
00:16:41,220 --> 00:16:43,140
So that is the earthquake hazard map demo.

266
00:16:43,140 --> 00:16:45,000
So we'll quit that.

267
00:16:45,000 --> 00:16:45,080
[ Applause ]

268
00:16:45,080 --> 00:16:47,170
Thank you.

269
00:16:47,170 --> 00:16:50,780
[ Applause ]

270
00:16:50,780 --> 00:16:52,340
Close this.

271
00:16:52,340 --> 00:16:56,870
And let me go back to the slides.

272
00:16:56,870 --> 00:17:01,830
So subclassing MKOverlayView, that's the
first subclass I showed of MKOverlayView.

273
00:17:01,830 --> 00:17:05,190
There's a few things to know about doing this.

274
00:17:05,190 --> 00:17:10,860
The most important of which is drawing is asynchronous,
so that drawMapRect method is coming in asynchronously.

275
00:17:10,860 --> 00:17:20,160
In that demo it was pretty simple because the data that
we loaded was -- it was fixed, it didn't change over time.

276
00:17:20,160 --> 00:17:23,570
So we loaded off of disk, had it
in memory, and it's not mutable.

277
00:17:23,570 --> 00:17:26,540
So that's nice, we don't need to
do any locking on that data.

278
00:17:26,540 --> 00:17:30,990
But if your data does change, you're going to need to
protect it with a lock because you drawing is asynchronous.

279
00:17:30,990 --> 00:17:35,430
There may be one thread calling drawMapRect, there
may be two threads, there may be multiple threads,

280
00:17:35,430 --> 00:17:38,540
but none of those are your main application
thread, they're a background thread created

281
00:17:38,540 --> 00:17:41,070
by Map Kit, so you need to be aware of that.

282
00:17:41,070 --> 00:17:46,600
I use the Core Graphics drawing methods as you saw in there
to draw, so you're given a CG context to draw that into.

283
00:17:46,600 --> 00:17:50,760
The UIKit graphic context is so
-- is not automatically available,

284
00:17:50,760 --> 00:17:53,270
so if you using any of the UIKit drawing functions,

285
00:17:53,270 --> 00:17:59,310
you need to push that graphics context using
the UIGraphics content -- UIGraphicsPushContext.

286
00:17:59,310 --> 00:18:04,460
I recommend just using the Core Graphics drawing API, but
if there's something in UIKit that you really want to use,

287
00:18:04,460 --> 00:18:09,450
and you know it's thread safe, go ahead
and use this to make that available.

288
00:18:09,450 --> 00:18:14,580
And then the other nice thing is, there is -- what you've
already drawn are cached, so as we zoomed in and panned

289
00:18:14,580 --> 00:18:20,380
around on that map, what we've drawn, so the list of
rectangles, colored rectangles that we'd already drawn,

290
00:18:20,380 --> 00:18:24,410
when we pan back to them, they don't have to be
drawn again, it's stored in the cache for you.

291
00:18:24,410 --> 00:18:29,480
You can invalidate that using setNeedsDisplayInMapRect,
but do so sparingly.

292
00:18:29,480 --> 00:18:34,770
If it hasn't changed, there's no point invalidating,
you want to keep that cache around as long as possible.

293
00:18:34,770 --> 00:18:36,580
So mutable overlays.

294
00:18:36,580 --> 00:18:40,460
I know a lot of people have asked on the
forums or in bug reports, "How do you do this?"

295
00:18:40,460 --> 00:18:44,470
Well, as you know, or I'm telling you now,

296
00:18:44,470 --> 00:18:48,630
all of the overlays in Map Kit are
immutable, they don't change with time.

297
00:18:48,630 --> 00:18:51,090
So once you've created one and add
it to the map, it doesn't change.

298
00:18:51,090 --> 00:18:52,250
But you want to do it.

299
00:18:52,250 --> 00:18:55,530
Right? Well, I know at least some of you want to do this.

300
00:18:55,530 --> 00:18:58,890
So to give mutability, you're going
need to build your own custom overlay.

301
00:18:58,890 --> 00:19:01,790
Fortunately I've got sample code of
available for this session that does it,

302
00:19:01,790 --> 00:19:04,360
and we're going to get into that in just a moment.

303
00:19:04,360 --> 00:19:06,910
And as I mentioned, we're only
going to want to update the part

304
00:19:06,910 --> 00:19:11,370
of the map that's changed when
we -- when we mutate the data.

305
00:19:11,370 --> 00:19:15,100
And finally, because drawing is asynchronous,
so drawMapRect comes in asynchronously,

306
00:19:15,100 --> 00:19:18,600
if you're updating from the main thread, you
need to protect your model data with a lock.

307
00:19:18,600 --> 00:19:21,500
So let me show you a demo of a mutable overlay.

308
00:19:21,500 --> 00:19:32,260
[ Loading demo ]

309
00:19:32,260 --> 00:19:34,430
So I call this the "Breadcrumb Sample."

310
00:19:34,430 --> 00:19:37,440
It's an app for Hansel and Gretel.

311
00:19:37,440 --> 00:19:45,260
And they're going to -- they've upgraded, they've got
iPhones now, so they don't use breadcrumbs anymore.

312
00:19:45,260 --> 00:19:49,710
And they've also upgraded -- they don't walk, they
have a BMW, and they're driving up the 280 here,

313
00:19:49,710 --> 00:19:51,910
and they're leaving a nice trail behind them.

314
00:19:51,910 --> 00:19:55,950
So this is accomplished by using a mutable overlay.

315
00:19:55,950 --> 00:19:58,800
And I've called that the "Crumb Path."

316
00:19:58,800 --> 00:20:00,890
So to show the implementation of this.

317
00:20:00,890 --> 00:20:06,230
This is my model object, it implements
MKOverlay, and it's storing a list of points

318
00:20:06,230 --> 00:20:09,940
which can be modified and is protected
with a read-write lock.

319
00:20:09,940 --> 00:20:15,560
So when we get our first location update, we're going
to create it about that center coordinate, and, then,

320
00:20:15,560 --> 00:20:19,720
for each subsequent location update,
we're going to add a coordinate.

321
00:20:19,720 --> 00:20:23,420
And so at that point we're going
to need to acquire the write lock.

322
00:20:23,420 --> 00:20:26,670
And then when we're drawing, we'll get the read lock.

323
00:20:26,670 --> 00:20:28,840
So we may have multiple drawing threads.

324
00:20:28,840 --> 00:20:32,360
They can all draw simultaneously as
long as they're holding the read lock,

325
00:20:32,360 --> 00:20:35,590
and so then that read lock protects this list of points.

326
00:20:35,590 --> 00:20:37,500
So let me show you just in the view here.

327
00:20:37,500 --> 00:20:42,600
[ View running ]

328
00:20:42,600 --> 00:20:45,600
We're going to acquire that read lock.

329
00:20:45,600 --> 00:20:49,860
We're going to create a path based on those
points, and then we're going to let go

330
00:20:49,860 --> 00:20:51,640
of the read lock, and go ahead and start that path.

331
00:20:51,640 --> 00:20:56,920
So there's one method in here -- this is nice helper method
that you'll be able to use in your own programs independent

332
00:20:56,920 --> 00:21:00,060
of this even, and this is this
Create Path for Points method.

333
00:21:00,060 --> 00:21:08,630
This guy -- given a list of points and a clipping of MapRect
and a map zoom scale, this will allow you to create a CGpath

334
00:21:08,630 --> 00:21:10,180
that is the fastest way to draw that path.

335
00:21:10,180 --> 00:21:11,910
So this is -- it's doing two things.

336
00:21:11,910 --> 00:21:13,360
One is it's clipping.

337
00:21:13,360 --> 00:21:18,430
So it's saying, "Look, if we have 5000 points that
we're trying draw, and there's only 3 points that are

338
00:21:18,430 --> 00:21:21,350
in this MapRect, we only need to draw those 3 points."

339
00:21:21,350 --> 00:21:23,140
And then it's also doing simplification.

340
00:21:23,140 --> 00:21:28,730
So if you have 5000 map points again, and you're trying
to draw them into an area that's 100 screen points --

341
00:21:28,730 --> 00:21:33,110
and we know that because we're given the zoom scale,
and we know the zoom scale has a linear relationship

342
00:21:33,110 --> 00:21:37,840
with screen points -- we can say, "Look, we don't
need to draw 5000 points into 100 point area.

343
00:21:37,840 --> 00:21:40,710
We can do some simplification, we can skip some points.

344
00:21:40,710 --> 00:21:44,450
And get something that looks just
as good but draws much quicker."

345
00:21:44,450 --> 00:21:48,550
So there's -- there's this nice method that you'll
be able to incorporate into your own programs.

346
00:21:48,550 --> 00:21:53,640
And, then, just to flip over to the implementation
of the view controller, so we're using --

347
00:21:53,640 --> 00:21:58,220
as I mentioned earlier, we have a new delegate
callback for when that blue dot updates.

348
00:21:58,220 --> 00:22:03,500
This is going to be getUpdateToUserLocation, and when
that comes in, we're going to look at the user location,

349
00:22:03,500 --> 00:22:07,790
and if it's the first one, we're going to
create our crumb path, so this is our MKOverlay

350
00:22:07,790 --> 00:22:10,190
of model object, and we're going to add that to the map.

351
00:22:10,190 --> 00:22:15,270
And we're also going to zoom the
map to show the user's location.

352
00:22:15,270 --> 00:22:18,290
And then on subsequent updates, we're not going to move
the map, but what we are going to do is we're going

353
00:22:18,290 --> 00:22:24,720
to add a coordinate to that crumb path, so this is going
to acquire that write lock, add it to the list of points,

354
00:22:24,720 --> 00:22:29,620
and then it's going to release the write lock when it's
done, and it's going to give us back an updateRect,

355
00:22:29,620 --> 00:22:32,600
so this is this is just had area that's changed.

356
00:22:32,600 --> 00:22:39,970
And if it's not null -- oops, if it's not null, then
what we can do -- here's another nice one liner.

357
00:22:39,970 --> 00:22:46,160
We can find the current zoom scale, figure out
how wide we draw that line at that zoom scale,

358
00:22:46,160 --> 00:22:51,340
and we can just outset our updateRect by that, and
then now let's just update that invalidated area.

359
00:22:51,340 --> 00:22:55,490
So if we're going to build and run this again...

360
00:22:58,060 --> 00:23:02,950
So what's nice is, this guy's moving along, and
it's exposing a little bit more of that line.

361
00:23:02,950 --> 00:23:05,500
We're only redrawing just a tiny little part of the screen.

362
00:23:05,500 --> 00:23:12,990
We don't have to redraw all of this every time that updates,
so it makes it much more efficient to do it this way.

363
00:23:14,640 --> 00:23:18,500
So that's how you do a mutable overlay using Map Kit.

364
00:23:18,500 --> 00:23:23,410
[ Applause ]

365
00:23:23,410 --> 00:23:25,300
So what did we learn in that demo?

366
00:23:25,300 --> 00:23:27,730
You can do a mutable polyline.

367
00:23:27,730 --> 00:23:33,080
And the thing to take away from this is, I used a single
custom overlay rather than adding and re-adding a polyline.

368
00:23:33,080 --> 00:23:35,900
I know, I'd seen some bug reports
and, like, some forum posts.

369
00:23:35,900 --> 00:23:39,140
People were, like, "Well, every second,
I'm going to create a new MKPolyline.

370
00:23:39,140 --> 00:23:41,460
I'm going to remove my old one, I'm going to add a new one."

371
00:23:41,460 --> 00:23:42,380
That's not very efficient.

372
00:23:42,380 --> 00:23:46,610
It's much more efficient to use the
scheme that I've shown in the sample.

373
00:23:46,610 --> 00:23:48,780
And the data has to be protected with a lock.

374
00:23:48,780 --> 00:23:52,820
I'm using read-write lock because it's
very convenient for this sort of data.

375
00:23:52,820 --> 00:23:57,350
DrawMapRect is asynchronous, so you
need to protect your data with a lock

376
00:23:57,350 --> 00:24:00,280
because you're updating it from the main thread.

377
00:24:00,280 --> 00:24:02,720
And finally, simplify and clip to your list of points.

378
00:24:02,720 --> 00:24:09,250
Core Graphics will do clipping for you, so when you're asked
drawMapRect, there is already a clipping boundary set up,

379
00:24:09,250 --> 00:24:16,200
but it's a lot faster if you just avoid
creating such a large path in the first place.

380
00:24:16,200 --> 00:24:18,370
Yes. Raster map overlays.

381
00:24:18,370 --> 00:24:20,280
So I know some people are interested in doing this.

382
00:24:20,280 --> 00:24:26,360
This is -- you have an image, and you want to display
it on top of the map, so it may be available as a PDF,

383
00:24:26,360 --> 00:24:29,650
or you have it as a GeoTIFF or just a big image.

384
00:24:29,650 --> 00:24:32,240
Perhaps it's on a piece of paper and you need to scan it in.

385
00:24:32,240 --> 00:24:37,050
But you want to display your own maps, so this may be your
college campus map or your national park map or something

386
00:24:37,050 --> 00:24:41,730
like that, and you want to overlay
that on top of your map view.

387
00:24:41,730 --> 00:24:45,850
So one thing to know about this is, your
map has to be in the Mercator projection.

388
00:24:45,850 --> 00:24:50,620
We only have the Mercator projection in Map Kit, so if your
map's not in the Mercator projection, it has to be warped.

389
00:24:50,620 --> 00:24:54,290
Fortunately, there's a nice tool that's
available that will let you do this.

390
00:24:54,290 --> 00:24:58,690
So you can warp your image if it's
not already in Mercator projection.

391
00:24:58,690 --> 00:25:01,410
And your image is going to be cut into tiles.

392
00:25:01,410 --> 00:25:06,100
So if you have an image -- and in my
example I'm going to show in just a minute,

393
00:25:06,100 --> 00:25:12,250
I have an image that's like 120 MB image -- you're not
going to load 120 MB image into memory on an iPhone.

394
00:25:12,250 --> 00:25:13,370
It's not going to fit.

395
00:25:13,370 --> 00:25:17,170
So it needs to be cut into tiles that
are small enough, little bite-sized tiles

396
00:25:17,170 --> 00:25:21,050
that we can just load those individually
and display just what we need.

397
00:25:21,050 --> 00:25:26,110
And finally, the tiles they can be loaded another from your
applications bundle or you get them off of the network.

398
00:25:26,110 --> 00:25:31,900
In the example I'm going to show, we're going to load them
from the applications bundle, but you can do it either way.

399
00:25:31,900 --> 00:25:35,280
So this is the map that I want to put on top of Map Kit.

400
00:25:35,280 --> 00:25:38,210
It is a nautical chart of the San Francisco Bay.

401
00:25:38,210 --> 00:25:41,850
I got it from the National Oceanic
and Atmospheric Administration.

402
00:25:41,850 --> 00:25:45,120
And -- nice nautical chart here.

403
00:25:45,120 --> 00:25:47,320
And this thing's going to need to be cut into tiles.

404
00:25:47,320 --> 00:25:51,480
So there's a utility that does this, and the output
that it creates looks a little bit like this.

405
00:25:51,480 --> 00:25:54,190
So it has -- it corresponds to zoom levels.

406
00:25:54,190 --> 00:25:57,330
So at zoom level 10, it's just a tiny little guy.

407
00:25:57,330 --> 00:26:00,090
Zoom in, it gets twice as big.

408
00:26:00,090 --> 00:26:02,100
Zoom in again, it gets twice as big again.

409
00:26:02,100 --> 00:26:05,050
So it's going by powers of two.

410
00:26:05,050 --> 00:26:10,080
And so what you want to do is, there's this great open
source project, Geospatial Data Abstraction Library.

411
00:26:10,080 --> 00:26:11,480
I encourage you to download that.

412
00:26:11,480 --> 00:26:16,830
It's in MacPorts, so you can just do "port install
gdal" if you use MacPorts, and get this thing installed.

413
00:26:16,830 --> 00:26:23,090
And it comes with a great utility that someone did, I
think as some Google Summer of Code project last year.

414
00:26:23,090 --> 00:26:29,520
It's called GDAL2Tiles, and you put your image in it, it
will warp it to the Mercator projection if it's not already

415
00:26:29,520 --> 00:26:31,960
in a Mercator projection, and cut it into tiles.

416
00:26:31,960 --> 00:26:36,990
And then finally, it's going to -- it's going to export
tiles in a directory structure, and you can use those things

417
00:26:36,990 --> 00:26:39,980
with -- if you're already using,
like, Google Maps JavaScript API

418
00:26:39,980 --> 00:26:41,880
on the web, you can use those tiles with that.

419
00:26:41,880 --> 00:26:45,630
If you're using Microsoft's Virtual Earth JavaScript
API on the web, you can use the tiles with that.

420
00:26:45,630 --> 00:26:49,410
And now you're going to be able to
use tiles with Map Kit on the iPhone.

421
00:26:49,410 --> 00:26:53,060
So this is a really great utility, I recommend using it.

422
00:26:53,060 --> 00:26:57,500
So let me show you demo of that
nautical chart on top of Map View.

423
00:26:57,500 --> 00:27:05,520
[ Demo running ]

424
00:27:05,520 --> 00:27:07,500
Tile, Map.

425
00:27:07,500 --> 00:27:13,200
[ Demo running ]

426
00:27:13,200 --> 00:27:17,430
So there's our nautical chart overlaid
on the map, and so it's semi-transparent.

427
00:27:17,430 --> 00:27:22,800
You can zoom in and see that the thing
increases its detail as you zoom in.

428
00:27:22,800 --> 00:27:28,160
You can pinch, and it tracks the
coastline precisely as you go.

429
00:27:28,160 --> 00:27:31,100
You can actually even see ships navigating this chart.

430
00:27:31,100 --> 00:27:35,970
They're a little bit blurry, but this is the
satellite photo, you can see there's ship there.

431
00:27:35,970 --> 00:27:38,000
It's pretty cool.

432
00:27:38,000 --> 00:27:43,810
Zoom out. So one of the neat things about this demo is you
can actually -- if you were to download this sample code,

433
00:27:43,810 --> 00:27:48,320
and you run GDAL2Tiles on your own program,
this tiles directory in the resource port --

434
00:27:48,320 --> 00:27:51,810
resources here, just delete that
and put your own tiles directory,

435
00:27:51,810 --> 00:27:54,720
and now you have your own raster map on top of map kits.

436
00:27:54,720 --> 00:27:56,500
So it's - no code to modify it.

437
00:27:56,500 --> 00:28:01,940
[ Applause ]

438
00:28:01,940 --> 00:28:03,420
Yeah. That's pretty neat.

439
00:28:03,420 --> 00:28:07,850
I just want to show you a little bit about how this
works, though, in case you do download this code

440
00:28:07,850 --> 00:28:10,050
and you want to extend it, go further with it.

441
00:28:10,050 --> 00:28:12,430
So let me just show you the model class.

442
00:28:12,430 --> 00:28:14,370
So this is a tile overlay model class.

443
00:28:14,370 --> 00:28:19,370
It scans a directory of tiles, so scans that
directory of tiles out of the resources directory;

444
00:28:19,370 --> 00:28:26,560
figures out what is the boundingMapRect for all of those
tiles; and then for the view, it's able to return a list

445
00:28:26,560 --> 00:28:30,490
of tiles for a given MapRect because we're going to
get drawMapRect, get the MapRect in the ZoomScale,

446
00:28:30,490 --> 00:28:33,150
we need to know what are the images that correspond to this.

447
00:28:33,150 --> 00:28:34,860
And so we're going to need to get those.

448
00:28:34,860 --> 00:28:39,180
And there's one really useful function in
here that I want to call your attention to.

449
00:28:39,180 --> 00:28:48,390
Most of it is just details with reading files and so
on, but there's -- let's see where did I put that thing?

450
00:28:48,390 --> 00:28:49,650
Ah, I put it right here.

451
00:28:49,650 --> 00:28:50,950
ZoomScale to the zoom level.

452
00:28:50,950 --> 00:28:55,890
So if you've used Google Maps JavaScript on the
web, or you've used Virtual Earth JavaScript API

453
00:28:55,890 --> 00:28:58,390
on the web, you're familiar with zoom levels.

454
00:28:58,390 --> 00:29:01,040
So we don't use zoom levels in Map Kit, we use ZoomScale.

455
00:29:01,040 --> 00:29:04,880
ZoomScale is nice because it does have
that linear relationship between map points

456
00:29:04,880 --> 00:29:06,410
and screen points, so that's why we use it.

457
00:29:06,410 --> 00:29:12,630
But if you have data that's using Zoom Level as these
raster tiles do, you can convert between Map Kit ZoomScale

458
00:29:12,630 --> 00:29:15,300
and the Google or Microsoft convention of zoom level.

459
00:29:15,300 --> 00:29:20,860
So this is a really nice little function that you can
use in our own programs to do that if you need to do so.

460
00:29:20,860 --> 00:29:27,440
And then in the overlay view, let me
show you what this guy looks like.

461
00:29:27,440 --> 00:29:34,310
So when you're asked to draw a MapRect, it may not exactly
correspond to one of your tiles, it may be a list of tiles.

462
00:29:34,310 --> 00:29:34,670
That's OK.

463
00:29:34,670 --> 00:29:40,200
We're getting back this list of tiles as an array,
and we're going to loop over all of those things,

464
00:29:40,200 --> 00:29:42,840
and then we're just going to find,
OK, what is the image for it,

465
00:29:42,840 --> 00:29:46,470
what is the Rect that bounds it,
and draw that image into that Rect.

466
00:29:46,470 --> 00:29:51,720
One thing I noticed was, on the sample code
that I initially uploaded, and, I think,

467
00:29:51,720 --> 00:29:56,600
which is available on the session site right now,
doesn't have this Image Release at the end here.

468
00:29:56,600 --> 00:30:00,790
You're going to want to add that,
otherwise there's going to be a leak.

469
00:30:00,790 --> 00:30:02,750
So I'm sorry about that but, yeah, add that.

470
00:30:02,750 --> 00:30:06,160
And then let me just show you the view controller here.

471
00:30:06,160 --> 00:30:07,770
It's pretty straight forward.

472
00:30:07,770 --> 00:30:14,800
We just initialize with our tile directory, create
our overlay model object, and add it to the map.

473
00:30:14,800 --> 00:30:17,560
And we'll zoom the map just so that the tiles are visible.

474
00:30:17,560 --> 00:30:22,630
I zoom in one zoom level past the one that just bounds it.

475
00:30:22,630 --> 00:30:26,970
And then we Create and Return to View and
View for Overlay, and I set the tile alpha,

476
00:30:26,970 --> 00:30:30,830
so this is really the only property on the
view is the tile alpha, so it's 60% opacity.

477
00:30:30,830 --> 00:30:36,310
You can make it fully opaque or semitransparent
if you like, whatever works for you.

478
00:30:36,310 --> 00:30:40,500
So that's -- that's the Tile Map demo.

479
00:30:40,500 --> 00:30:46,230
[ Applause ]

480
00:30:46,230 --> 00:30:47,270
Let me just run that one more time.

481
00:30:47,270 --> 00:30:48,500
It's cool.

482
00:30:48,500 --> 00:30:54,690
[ Laughter ]

483
00:30:54,690 --> 00:30:56,000
It's nice.

484
00:30:56,000 --> 00:30:58,000
[ Laughter ]

485
00:30:58,000 --> 00:31:05,560
[ Applause ]

486
00:31:05,560 --> 00:31:06,690
So back to the slides.

487
00:31:06,690 --> 00:31:10,040
What did we learn from this?

488
00:31:10,040 --> 00:31:19,150
The image has to be cut into tiles, use GDAL to do
that; you can convert your ZoomScales to zoom levels,

489
00:31:19,150 --> 00:31:25,170
so if you have zoom level and you need to get ZoomScale
or vice versa, you can set up a mapping between those two;

490
00:31:25,170 --> 00:31:32,800
and you don't necessarily need to have an image that is so
detailed that you cover every zoom level that Map Kit does.

491
00:31:32,800 --> 00:31:39,430
So my image, even at 120 MB, and I think about 20,000
pixels on a side, still isn't enough to zoom all the way in

492
00:31:39,430 --> 00:31:42,460
or zoom all the way out, but that's OK.

493
00:31:42,460 --> 00:31:49,060
It will just show up when the map is positioned in the
right region; and the Map Kit tile size is independent

494
00:31:49,060 --> 00:31:54,870
from your tile size, so you may be using 256 pixel
tiles, that's what the GDAL2Tiles program outputs.

495
00:31:54,870 --> 00:31:56,540
Map Kit might be using a different size, but that's OK,

496
00:31:56,540 --> 00:32:01,700
you just draw the according number of
images that you need into that space.

497
00:32:01,700 --> 00:32:03,150
So loading your tiles on demand.

498
00:32:03,150 --> 00:32:05,120
That sample doesn't load its tiles on demand.

499
00:32:05,120 --> 00:32:09,550
It loads them out of the applications mode, but you can load
them on demand, and, in fact, we've built in some facility

500
00:32:09,550 --> 00:32:16,050
to MKOverlayView to make this practical, so loading
network resources and then drawing them as needed.

501
00:32:16,050 --> 00:32:19,440
And the key thing to know about this is canDrawMapRect.

502
00:32:19,440 --> 00:32:24,970
So canDrawMapRect is a method that you
can over ride in your MKOverlayView class.

503
00:32:24,970 --> 00:32:28,390
And when you get this, this is
an indication to you that a tile

504
00:32:28,390 --> 00:32:30,680
or a list of tiles corresponding to that area is needed.

505
00:32:30,680 --> 00:32:36,180
It means Map Kit's interested, so you should go
off and go to your web server and fetch that data.

506
00:32:36,180 --> 00:32:37,710
And what you're going to is while you're fetching the data,

507
00:32:37,710 --> 00:32:40,650
you're going to return No, and
say, "I can't draw that right now."

508
00:32:40,650 --> 00:32:45,530
And so we're not going to bother calling
drawMapRect, we're just going to wait

509
00:32:45,530 --> 00:32:48,180
for you to go ahead and download that data.

510
00:32:48,180 --> 00:32:51,830
Then once you have the data, you're
going to call setNeedsDisplayInMapRect

511
00:32:51,830 --> 00:32:54,250
and that's going to indicate, OK, things have changed.

512
00:32:54,250 --> 00:32:55,610
We're going to reevaluate.

513
00:32:55,610 --> 00:32:58,830
You're going to get canDrawMapRect again,
and this time you're going to return Yes

514
00:32:58,830 --> 00:33:02,110
because you have the data cached locally,
and then you're going to get drawMapRect,

515
00:33:02,110 --> 00:33:04,650
and you're going to have a chance to draw your own data.

516
00:33:04,650 --> 00:33:07,560
So there's a couple of things to know about this.

517
00:33:07,560 --> 00:33:10,350
You want to coalesce your request to
your web server into a fixed size stack.

518
00:33:10,350 --> 00:33:16,120
If the user pans really quickly, they could pan from,
you know, San Francisco all the way over to Idaho,

519
00:33:16,120 --> 00:33:22,720
and there's a lot of intermediate tiles that were passed
by, but they were on screen for just a fraction of a second.

520
00:33:22,720 --> 00:33:25,190
You don't want make a request to your web server for those.

521
00:33:25,190 --> 00:33:29,450
So if you coalesce your tile request and go to fixed
size stack, and then fire those off to your web server

522
00:33:29,450 --> 00:33:34,430
on a short timer, say like 0.1, 0.2
second timer, you can avoid drawing things

523
00:33:34,430 --> 00:33:38,350
or requesting things that the user
didn't really want to see.

524
00:33:38,350 --> 00:33:42,650
The most recent request is the most
important, so use a stack not a queue, right.

525
00:33:42,650 --> 00:33:44,950
If they pan over to Idaho, they want to see tiles in Idaho,

526
00:33:44,950 --> 00:33:48,570
they don't want to see things on
the way in Oregon, for instance.

527
00:33:48,570 --> 00:33:51,140
And, yeah, the old request may no longer be visible.

528
00:33:51,140 --> 00:33:53,200
It's off screen, they don't care anymore.

529
00:33:53,200 --> 00:33:56,930
And your stack size should be roughly twice the size
of the number of tiles needed to cover the screen.

530
00:33:56,930 --> 00:33:58,180
Why twice the size?

531
00:33:58,180 --> 00:34:00,140
Well, in Map Kit you can pinch.

532
00:34:00,140 --> 00:34:02,720
We don't have tightly delineated zoom levels.

533
00:34:02,720 --> 00:34:06,150
You can pinch so that things are just sort of
scaled down, and if you're right at the boundary,

534
00:34:06,150 --> 00:34:09,290
then you're going to need about twice as
many as you would expect to cover the screen.

535
00:34:09,290 --> 00:34:11,370
So that's why you use 2X.

536
00:34:11,370 --> 00:34:16,530
And when a request falls off the back of the stack, so let's
say you decide, "Oh, my stack should be 50 items deep,"

537
00:34:16,530 --> 00:34:23,070
and you get to the 51st item, call
setNeedsDisplayInMapRect again, and when you do that,

538
00:34:23,070 --> 00:34:26,500
it doesn't necessarily mean you're
going to get a drawMapRect right away,

539
00:34:26,500 --> 00:34:32,120
it just means you want to get another canDrawMapRect,
and so the time the user does pan back to that area,

540
00:34:32,120 --> 00:34:34,070
we're going to reevaluate, and then at that point,

541
00:34:34,070 --> 00:34:37,890
we may consider actually downloading
and then finally displaying it.

542
00:34:37,890 --> 00:34:40,880
So that's what you need to do to load your tiles on demand,

543
00:34:40,880 --> 00:34:45,800
and that pretty much wraps what I have
to say about raster tile overlays.

544
00:34:45,800 --> 00:34:50,890
For more information, you should send an email
to Mark Malone, that's his email address there.

545
00:34:50,890 --> 00:34:52,200
We have great documentation.

546
00:34:52,200 --> 00:34:54,960
It's been fully updated for Map Kit on iOS 4.

547
00:34:54,960 --> 00:34:57,190
I encourage you to read that.

548
00:34:57,190 --> 00:35:01,040
And the Developer Forums, I've been hanging out on
there, the other Map Kit engineers have been hanging

549
00:35:01,040 --> 00:35:04,340
out on there, so pop in there and post your questions.

550
00:35:04,340 --> 00:35:06,410
So in summary: What can you do with Map Kit overlays?

551
00:35:06,410 --> 00:35:09,090
You can add your lines and shapes to the map.

552
00:35:09,090 --> 00:35:12,140
And with custom overlays you can
really draw anything you want.

553
00:35:12,140 --> 00:35:17,350
And so I really hope to see everyone who's been
using Map Kit and has wished that they had had this

554
00:35:17,350 --> 00:35:21,410
in their applications, I'd like to see you update your
applications to take advantage of overlays for iOS 4.

555
00:35:21,410 --> 00:35:22,500
Thank you very much.

556
00:35:22,500 --> 00:35:24,800
[ Applause ]

