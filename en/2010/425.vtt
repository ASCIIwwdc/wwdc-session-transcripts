WEBVTT

00:00:06.950 --> 00:00:12.570
>> John Harper: Welcome to Session 425,
Core Animation in Practice, Part 2.

00:00:12.570 --> 00:00:14.390
And my name is John Harper.

00:00:14.390 --> 00:00:21.140
I'm part of the Core Engineering team and mostly working
on Core Animation and everything relating to that.

00:00:21.140 --> 00:00:25.490
And this talk is kind of a continuation of the first talk.

00:00:25.490 --> 00:00:31.120
The idea is that the first talk was kind of setting
the scene, going over all the broad details.

00:00:31.120 --> 00:00:36.020
And this one, we want to just dive into
certain areas, not taking a broad slice,

00:00:36.020 --> 00:00:40.800
but just looking at things we thought you might find
interesting, to try and give you a better understanding

00:00:40.800 --> 00:00:44.350
of what's happening and some new things you can be using.

00:00:44.350 --> 00:00:48.750
So, things we're going to go over, we're basically
going to split the talk into three sections.

00:00:48.750 --> 00:00:53.210
The first section will be kind of a mixed
grab bag of different APIs, some new,

00:00:53.210 --> 00:00:56.250
some things we think you might find useful.

00:00:56.250 --> 00:01:01.510
And then we're going to spend quite a bit of time on
performance relating to Core Animation and basically try

00:01:01.510 --> 00:01:07.030
to give you an idea of how the GPU, the current
Core Animation, all these things fit together

00:01:07.030 --> 00:01:10.750
and affect the performance you see in your applications.

00:01:10.750 --> 00:01:16.870
Finally, we're just going to talk very quickly about
the new kind of High-DPI screen on the new iPhone

00:01:16.870 --> 00:01:22.600
and what that means to your graphics
rendering from a Core Animation perspective.

00:01:22.600 --> 00:01:24.440
So, let's get right into it.

00:01:24.440 --> 00:01:30.420
So, the first API I want to talk about, the
first kind of section, I guess, is drop shadows.

00:01:30.420 --> 00:01:37.020
And, obviously, shadows are a very important part of your
applications, in that they can often give a lot of depth

00:01:37.020 --> 00:01:42.950
to your visual display, and they
can really make something stand out.

00:01:42.950 --> 00:01:47.350
They just make things look a lot more natural, often.

00:01:47.350 --> 00:01:56.130
So, in the past, we've had a full set of shadow APIs on the
Mac platform, and you can set things like the shadow radius,

00:01:56.130 --> 00:02:02.200
and the shadow card, the path, all this kind of stuff, but
we've never actually supported them on the iPhone platforms,

00:02:02.200 --> 00:02:05.500
because, really, the performance just wasn't there.

00:02:05.500 --> 00:02:11.190
And so when we were doing the iPad, it really became
apparent that we really do need some kind of shadow support,

00:02:11.190 --> 00:02:17.300
so we brought all those APIs back onto the
iPhone OS, but we added some new features,

00:02:17.300 --> 00:02:22.830
just to make the performance a lot more acceptable on
these kind of lower end devices, compared to the Mac.

00:02:22.830 --> 00:02:30.280
So, the new API we added is this thing called the
shadowPath, and so the idea here is that, typically,

00:02:30.280 --> 00:02:34.990
if you say "Turn on shadows on your layer," what
that means is that we had to take the Alpha channel

00:02:34.990 --> 00:02:39.030
of the composite content, blur it to get
that nice kind of blown out shadow look,

00:02:39.030 --> 00:02:43.430
and then apply it underneath the layer, and that
blurring step in particular is a lot of work for the GPU,

00:02:43.430 --> 00:02:47.730
and doing it every frame really
doesn't work very well on certain GPUs.

00:02:47.730 --> 00:02:52.910
So, the idea of a shadowPath is that this is a
way you can tell us where your layer is opaque.

00:02:52.910 --> 00:03:00.100
And, obviously, once we know the opaque region, we
can use that to kind of cache the shadow as a bitmap.

00:03:00.100 --> 00:03:03.960
So, we can render it, blur it, and just keep it around.

00:03:03.960 --> 00:03:07.400
And then as long as you don't change the
path, the shadow will be there forever,

00:03:07.400 --> 00:03:10.090
and we can reuse it from frame to frame very cheaply.

00:03:10.090 --> 00:03:14.750
So, I just want to show a very quick demo of this,
to give you the idea of why you should be using it.

00:03:14.750 --> 00:03:22.340
So, we have this demo app, and you can
see that we have a number of layers,

00:03:22.340 --> 00:03:25.330
just colored rectangles bouncing around the screen.

00:03:25.330 --> 00:03:31.130
And so what I'm going to do, first of all,
is just turn on shadows in the old naive way,

00:03:31.130 --> 00:03:34.950
where we basically just set the shadow,
capacity of the layer to be non-0.

00:03:34.950 --> 00:03:37.520
And when we do that, you can see that we have nice shadows,

00:03:37.520 --> 00:03:42.460
but we have pretty horrible performance,
especially when I bring this up a bit.

00:03:42.460 --> 00:03:44.450
It's really nasty.

00:03:44.450 --> 00:03:46.050
So, very simple.

00:03:46.050 --> 00:03:49.190
All we had to do here is set the
shadowPath to be a rectangle

00:03:49.190 --> 00:03:51.570
in this case, because that's the shape of the layout.

00:03:51.570 --> 00:03:55.840
And as soon as we turn that on, everything
becomes way faster and much smoother.

00:03:55.840 --> 00:04:01.710
[applause] So, probably, that shows you
why you should be caring about this.

00:04:01.710 --> 00:04:05.080
And now let's just go through that
example in a little more detail.

00:04:05.080 --> 00:04:08.060
So, as I said, we have a number of layers.

00:04:08.060 --> 00:04:09.900
Each of them was created in this way.

00:04:09.900 --> 00:04:10.660
We created a layer.

00:04:10.660 --> 00:04:12.630
We set its rectangle.

00:04:12.630 --> 00:04:15.670
We set a background color with some random hue.

00:04:15.670 --> 00:04:21.650
And then the next, when we enabled shadows, we really
just set the shadowPath, we set the shadow radius,

00:04:21.650 --> 00:04:27.460
and set the shadow offset, move the shadow vertically
under the layer a little bit to make it look more natural.

00:04:27.460 --> 00:04:34.340
And then when we hit the final button to make
everything fast, all that was happening is this,

00:04:34.340 --> 00:04:39.840
and so you can see what we're doing here is we're
going into the UIBezierPath to create a path

00:04:39.840 --> 00:04:42.210
for the rectangle, which is the shape of the layer.

00:04:42.210 --> 00:04:46.830
And then UIBezierPath is a nice feature where
you can ask it for a CGPath, and, obviously,

00:04:46.830 --> 00:04:52.640
the CGPath will be the underlying representation
of that path, and then we can use that CGPath there

00:04:52.640 --> 00:04:58.410
to set the shadowPath of the layer, because, obviously
Core Animation is a lower level API than UIKit,

00:04:58.410 --> 00:05:01.630
so we really only deal in core graphics objects.

00:05:01.630 --> 00:05:02.740
And so, really, that's all you had to do.

00:05:02.740 --> 00:05:04.560
There's just one extra line or two extra lines.

00:05:04.560 --> 00:05:07.640
You just put them up like I did
here to get those faster shadows.

00:05:07.640 --> 00:05:11.390
And, obviously, this isn't restricted
only to rectangular things.

00:05:11.390 --> 00:05:16.190
Because it's a path, you can create
round recs, or complex shapes.

00:05:16.190 --> 00:05:23.370
Really, anything you can imagine can be put in that
path and used to create the outline for your shadow.

00:05:23.370 --> 00:05:25.870
The next topic, moving on from shadows, are shape layers.

00:05:25.870 --> 00:05:32.440
And, typically, when you're using Core Animation
layers or UI views, and you have some non--

00:05:32.440 --> 00:05:38.880
just a slab of color content, then what you're always using
is a bitmap, and you'll probably be drawing into the bitmap

00:05:38.880 --> 00:05:44.740
or providing a CG image ref, and that's fine,
in many cases, but there are problems with that,

00:05:44.740 --> 00:05:47.090
if you're trying to, for example, scale the layer.

00:05:47.090 --> 00:05:52.620
Then, obviously, since you have a bitmap, the resolution
of the bitmap are fixed, and when you scale it up or down,

00:05:52.620 --> 00:05:54.600
you get blurriness, or aliasing, or whatever.

00:05:54.600 --> 00:06:00.460
And, also, you can't really animate the contents of that
image, that bitmap, because, you know, again, it's fixed.

00:06:00.460 --> 00:06:03.870
So, in certain cases, shape layers
can be a way to avoid those problems.

00:06:03.870 --> 00:06:09.190
A shape layer is really just a layer which
draws a path with a filler or a stroke.

00:06:09.190 --> 00:06:17.260
And so, because the drawing of the path is deferred
until the composite time, when we know the resolution

00:06:17.260 --> 00:06:24.350
that the layer is being drawn at, the we really get a
nice scalable result, where the path will stay sharp,

00:06:24.350 --> 00:06:26.620
no matter what scale path you apply to it.

00:06:26.620 --> 00:06:33.560
Similarly, we have some support for animating
paths and separating between two path states.

00:06:33.560 --> 00:06:39.190
So, if you, for example, have to have a line, and you want
to have it a certain width, and then animate from point A

00:06:39.190 --> 00:06:45.040
to point B, then this is a really easy way to
do that without using any images or any bitmaps.

00:06:45.040 --> 00:06:51.160
So, we should talk a little bit about the performance
here, because it's not as obvious as just using an image.

00:06:51.160 --> 00:06:58.040
Firstly because we're really just storing the contents
as a path, then it really does use very little memory.

00:06:58.040 --> 00:07:04.070
I mean, if you have an image, the memory usage is fixed
in terms of width by height; whereas, if you have a path,

00:07:04.070 --> 00:07:09.650
then you could have a million by million path
shape, but it could only have four line segments,

00:07:09.650 --> 00:07:12.690
and there's probably only like 20 floats or something.

00:07:12.690 --> 00:07:18.450
On the other hand, because, like I said, we
deferred the rendering of the path a lot longer,

00:07:18.450 --> 00:07:23.810
so we can get these advantages, then we'd all be rendering
probably every frame, and so that can take more CPU

00:07:23.810 --> 00:07:30.410
if you're not careful, if you have a very complex path
or a thousand of these names or something like that.

00:07:30.410 --> 00:07:36.920
Finally, another plus, I guess, is the images you may have
heard us talk in the past about how you must avoid blending

00:07:36.920 --> 00:07:43.700
and all that kind of thing, the nice thing about
shapes is that since we know the shape ahead of time,

00:07:43.700 --> 00:07:48.410
because we know what the path is, when we draw it to
the screen, we can ignore all those transparent areas,

00:07:48.410 --> 00:07:52.200
so you really only pay the cost for the regions with color.

00:07:52.200 --> 00:07:56.720
And so, again, if you have, for example, a
diagonal line, then if you had that in an image,

00:07:56.720 --> 00:07:59.960
you would have to pay the cost of drawing
all those transparent pixels to the screen,

00:07:59.960 --> 00:08:04.910
because the GPU doesn't know what's transparent
and what isn't; whereas, with the shape layer,

00:08:04.910 --> 00:08:09.910
if you had that line stored as a path, we know exactly
where the color is, and we can just slam down those pixels

00:08:09.910 --> 00:08:12.110
that are colored and ignore everything else.

00:08:12.110 --> 00:08:15.730
And so, in summary, we really think
this can be really useful,

00:08:15.730 --> 00:08:17.970
but you have to be judicious about
where you actually use it.

00:08:17.970 --> 00:08:21.750
And, typically, you only need to really
use it when you want to take advantage

00:08:21.750 --> 00:08:25.100
of the features of this scalable/animatable content.

00:08:25.100 --> 00:08:29.270
And, typically, it's best in a few semi-large elements.

00:08:29.270 --> 00:08:33.240
Again, if you have thousands of these
things, you may run into issues.

00:08:33.240 --> 00:08:37.310
So, again, I want to run into a quick demo of this.

00:08:37.310 --> 00:08:44.310
So, really, what we have here, again, some number of layers
created, and we can up the number to whatever we want.

00:08:44.310 --> 00:08:49.770
And then each of these layers is a shape layer, and you
can see that it's animating between two arrow shapes.

00:08:49.770 --> 00:08:53.850
And so this is trying to show the first
of those or the second of those points,

00:08:53.850 --> 00:08:59.660
which is that shapes can be animating; whereas, you can see
that if you had an image, you really wouldn't have any way

00:08:59.660 --> 00:09:06.680
to do this without redrawing those arrows every frame;
whereas, now we can just have two paths representing arrows,

00:09:06.680 --> 00:09:10.420
and let Core Animation sublay between them as it can.

00:09:10.420 --> 00:09:15.560
And just to show you the second nice feature about
the shape layer, which is that it's scalable.

00:09:15.560 --> 00:09:21.750
If I apply a scale transform to the common container
of this layer-- oops, trying to get this to work.

00:09:21.750 --> 00:09:23.850
Here we go.

00:09:23.850 --> 00:09:28.140
Hopefully, you can see that, even though we
scaled in, we didn't lose any resolution.

00:09:28.140 --> 00:09:33.810
We're staying perfectly sharp on the arrow points, and
it's still animating at a fairly decent frame rate.

00:09:33.810 --> 00:09:37.460
And, obviously, we're only paying the cost
to render the bits you can actually see,

00:09:37.460 --> 00:09:43.390
so it really doesn't make a whole lot of difference
that we now have these things massively huge.

00:09:43.390 --> 00:09:45.740
So, again, I want to just go through the code quickly.

00:09:45.740 --> 00:09:49.290
So, first of all, we're going to
create the two paths for each layer.

00:09:49.290 --> 00:09:56.190
In this case, we have some function which just creates an
arrow of random shape, using a number of random numbers.

00:09:56.190 --> 00:10:02.220
Just for convenience, we're going to use, get the
bounding boxes of each path, and you need them together,

00:10:02.220 --> 00:10:08.800
so we have one rectangle which represents
the overall bounding rec of those paths.

00:10:08.800 --> 00:10:12.810
And then we're going to create a shape layer,
whose fill color is set to some random color,

00:10:12.810 --> 00:10:18.430
whose position is somewhere on the screen, and then
whose bounds is the bounding path rate that we computed.

00:10:18.430 --> 00:10:24.000
And then to set up the actual path, you can see
we didn't bother setting the layer path property

00:10:24.000 --> 00:10:25.740
at all, because we're going to animate that.

00:10:25.740 --> 00:10:32.360
So, we create a basic animation, which gives us that
from-to behavior and targeting the path property,

00:10:32.360 --> 00:10:37.360
and then we set the from and to values of the
animation to be these two paths we created.

00:10:37.360 --> 00:10:42.970
And, obviously, animations often work on numbers, but, in
general, they can be anything that can be interpolated,

00:10:42.970 --> 00:10:47.560
and we know that we can interpolate
between two CG path objects.

00:10:47.560 --> 00:10:50.910
And so once we have that, we just set some
common timing properties, give it a duration,

00:10:50.910 --> 00:10:54.690
give it some kind of these, set it
to pulse back and forth forever.

00:10:54.690 --> 00:10:57.370
And then finally we just add that to the sublayer.

00:10:57.370 --> 00:11:00.990
We're not going to specify a key, because
we don't ever want to reference this again,

00:11:00.990 --> 00:11:02.820
so we just let it sit on the layer forever.

00:11:02.820 --> 00:11:08.740
And so you can see we did that 20 times,
or whatever, and got those pulsing arrows.

00:11:08.740 --> 00:11:14.030
One of the things we found, when developing the iPad, in
particular, with its larger screen and more complex content,

00:11:14.030 --> 00:11:19.440
is that when you have a lot of things animating
around the screen at once, that puts a lot of strain

00:11:19.440 --> 00:11:27.320
on the compositing system, because if something is moving,
even if you have actually, where you're only moving one

00:11:27.320 --> 00:11:34.770
of those layers, but it has like 100 sublayers, like
some kind of view hierarchy of table view or whatever,

00:11:34.770 --> 00:11:36.790
then you don't just pay the cost for moving the one thing.

00:11:36.790 --> 00:11:40.680
Obviously, you have to rerender all of those
things, and it's a complex rendering tree.

00:11:40.680 --> 00:11:43.780
Then that can be an expensive task,
which can take enough time

00:11:43.780 --> 00:11:48.550
that you've dropped 60 frames per second,
from the nice smooth behavior we want.

00:11:48.550 --> 00:11:55.130
So, we've added a new feature for the iPhone OS 3.2,
for the iPad in later releases, where you can now ask us

00:11:55.130 --> 00:12:01.630
to basically take a subtree of a layer and all its
sublayers, and you can ask us to basically cache

00:12:01.630 --> 00:12:06.600
that in a bitmap on the render tree side.

00:12:06.600 --> 00:12:10.230
So, to do that, you really just
set this shouldRasterize property.

00:12:10.230 --> 00:12:13.390
And what this is telling us is
that you're asking us to convert

00:12:13.390 --> 00:12:18.610
that layer tree into an image every time we render it.

00:12:18.610 --> 00:12:20.350
And so that's kind of a flattening act.

00:12:20.350 --> 00:12:23.590
It's taking this tree and converting it to just one bitmap.

00:12:23.590 --> 00:12:31.630
And then the beneficiality of that-- if that's a word--
is that we can then reuse that bitmap whenever we can.

00:12:31.630 --> 00:12:38.350
So, we create this bitmap, and, ideally, the thing you asked
us to rasterize with a cache won't be changing from frame

00:12:38.350 --> 00:12:43.030
to frame to frame, so in that case, we rendered it a
previous time into a bitmap, and then we can just use

00:12:43.030 --> 00:12:46.350
that bitmap again and again to
stamp it into subsequent frames.

00:12:46.350 --> 00:12:52.330
Obviously, if we can do that, if we can get some
reuse, then we can avoid a lot of that extra rendering,

00:12:52.330 --> 00:12:55.740
where we can get much better animation performances.

00:12:55.740 --> 00:12:59.760
So, I wanted to show kind of a diagrammatic
example of what I'm talking about,

00:12:59.760 --> 00:13:01.650
because it may not be immediately obvious.

00:13:01.650 --> 00:13:04.730
So, if you think about a very simple
layer tree we have here,

00:13:04.730 --> 00:13:07.950
we have a background color, a layer with a background color.

00:13:07.950 --> 00:13:12.400
It has two sublayers, an image, and some text, and
then all of that is parented into another layer,

00:13:12.400 --> 00:13:15.720
which is setting some kind of 50 percent scaling matrix.

00:13:15.720 --> 00:13:21.850
So, if we don't have any of this caching stuff, and we add
that layer tree to our view, then what's going to happen

00:13:21.850 --> 00:13:23.420
when it renders is that each of those three layers

00:13:23.420 --> 00:13:25.830
that actually provide content are
going to render one after the other.

00:13:25.830 --> 00:13:30.740
So, they render into the frame buffer one,
first the color, then the image, then the text.

00:13:30.740 --> 00:13:33.040
Then you can see that-- well, you
can't see, but I'm going to tell you--

00:13:33.040 --> 00:13:36.120
they rate it at 50 percent resolution
here, because there is the scaling.

00:13:36.120 --> 00:13:39.620
So, they didn't render at 100 percent and scale.

00:13:39.620 --> 00:13:43.000
They just rendered directly into the screen.

00:13:43.000 --> 00:13:48.120
Now, if I set this middle layer to
say rasterize, then, implicitly,

00:13:48.120 --> 00:13:52.210
what you're asking us to do is create a second
buffer here, so we now have the frame buffer,

00:13:52.210 --> 00:13:56.980
and we have this caching buffer, which is going
to start to hold everything in that subtree.

00:13:56.980 --> 00:13:59.400
So, now you can imagine what's going
to happen when I render this again.

00:13:59.400 --> 00:14:03.680
Instead of rendering to the screen, we're going to
render those three things again into the caching buffer,

00:14:03.680 --> 00:14:08.040
but this time, hopefully, you can see they're a lot larger,
because they're actually rendering at the native resolution

00:14:08.040 --> 00:14:13.160
of the layer, instead of through that transfer
matrix, because we're just caching that subtree.

00:14:13.160 --> 00:14:16.800
And so, obviously, once we have
that cached, we then can use--

00:14:16.800 --> 00:14:20.680
the rendering system will take that and just
copy it to the screen through the actual matrix,

00:14:20.680 --> 00:14:23.480
and we end up the same place we were before.

00:14:23.480 --> 00:14:27.890
Of course, the nice thing is that we've done
that once, but if we need to render that again,

00:14:27.890 --> 00:14:29.940
then we don't have to go back to the layer tree.

00:14:29.940 --> 00:14:33.060
We can just take the cache buffer and
just copy it straight to the frame buffer.

00:14:33.060 --> 00:14:35.290
We don't have to render the layer tree.

00:14:35.290 --> 00:14:41.760
That's, obviously, in this case, only three items, but if
there was 3,000, we could get a huge performance win there,

00:14:41.760 --> 00:14:45.190
because we just skipped all of that work.

00:14:45.190 --> 00:14:51.820
And, again, another example of why this helps you is,
imagine that you change the scaling matrix from 50 percent

00:14:51.820 --> 00:14:55.900
to 25 percent, and probably we
would create an animation to animate

00:14:55.900 --> 00:14:59.560
that scale change, and so now we have this thing cached.

00:14:59.560 --> 00:15:05.440
Again, we can just go, and every frame of that animation can
be rendering out of the cache, and just take a single kind

00:15:05.440 --> 00:15:08.920
of imaging operation to take the
cache version to the screen.

00:15:08.920 --> 00:15:13.330
So, hopefully, you can see that this really
can make a big difference in certain cases.

00:15:13.330 --> 00:15:15.490
So, again, I'm going to show a demo of that now.

00:15:15.490 --> 00:15:18.190
What we have here is yet another shape layer.

00:15:18.190 --> 00:15:19.690
This one is much more complex.

00:15:19.690 --> 00:15:26.720
So, this is actually from an SVG, and
it has about 300 path segments, I think.

00:15:26.720 --> 00:15:32.010
So, you can see we can render one of these things
at approaching frame rate, but I'll add a few more,

00:15:32.010 --> 00:15:35.740
and the performance is getting pretty shoddy.

00:15:35.740 --> 00:15:38.620
Add a few more, and we're chunking along.

00:15:38.620 --> 00:15:42.190
And, obviously, I can prove that there's
still shape layers, because when I zoom in,

00:15:42.190 --> 00:15:45.870
you can see all the detail there, and there's no pixilation.

00:15:45.870 --> 00:15:51.440
So, go back to the zoom back state, and what I'm going to
do is I'm just going to set that shouldRasterize property

00:15:51.440 --> 00:15:58.080
on each of these shape layers, each of the
butterfly layers, and go-- oops, twice.

00:15:58.080 --> 00:16:01.140
So, you can see that when I do that, it just--

00:16:01.140 --> 00:16:04.310
the butterflies get cached in the bitmap
instead of rendering to the screen every time.

00:16:04.310 --> 00:16:08.020
We get this nice, beautifully smooth animation.

00:16:08.020 --> 00:16:14.470
Of course, the problem with this is that, although it's
nice and smooth, we've lost one of the good features

00:16:14.470 --> 00:16:17.860
of the shape layer, which is, now, when we
zoom in, I don't know if you can see that,

00:16:17.860 --> 00:16:20.590
but now everything is pixilated, because we asked the cache.

00:16:20.590 --> 00:16:25.700
And so now what we're doing is, instead of
rasterizing the shape, we're scaling the bitmap.

00:16:25.700 --> 00:16:27.300
There are ways to work around this.

00:16:27.300 --> 00:16:31.910
There's another property called rasterization scale,
where you can ask the cache version to be cache

00:16:31.910 --> 00:16:36.010
to the 7th scale factor, but for
now we're just going to ignore that.

00:16:36.010 --> 00:16:42.810
So, I just want to talk a little bit more
about why you shouldn't use this now.

00:16:42.810 --> 00:16:46.480
So, it looks great, and it can
be really useful, in some cases,

00:16:46.480 --> 00:16:49.710
but you have to be really careful with
this API we've been talking about.

00:16:49.710 --> 00:16:54.590
Firstly, a lot of these devices don't have a
huge amount of memory, so, thusly, any caching,

00:16:54.590 --> 00:16:57.650
any things you are caching are
taking memory from something else.

00:16:57.650 --> 00:17:00.940
Bitmaps can be large, especially on larger screen devices.

00:17:00.940 --> 00:17:06.690
Also, obviously, the caches are fixed size,
so, once you ask too many things to be cached,

00:17:06.690 --> 00:17:13.400
then some of those won't fit, and
you won't get the benefits.

00:17:13.400 --> 00:17:17.800
If you ask us to cache, but then are unable
to get the reuse, then that's actually worse

00:17:17.800 --> 00:17:20.400
than if you hadn't asked us to cache at all.

00:17:20.400 --> 00:17:25.760
And the reason for that is that the rasterize
properties, it's kind of an API contract.

00:17:25.760 --> 00:17:31.710
You're asking us to always convert it to a bitmap, because
that has some side effects, like these pixilation effects.

00:17:31.710 --> 00:17:37.080
And so we really need to always use the same
results, no matter what the other circumstances are.

00:17:37.080 --> 00:17:41.790
So, for example, if you ask us to cache 1,000 layers, and
then there are only ten of them that can be used from frame

00:17:41.790 --> 00:17:46.860
to frame, then the other 990 will be
rendered into a buffer and then rendered

00:17:46.860 --> 00:17:50.930
to the screen every frame, and that can be pretty expensive.

00:17:50.930 --> 00:17:55.880
Also, as we saw, rasterization locks the scale down.

00:17:55.880 --> 00:18:02.080
And one last point, which is a little
more esoteric, but people have run into it,

00:18:02.080 --> 00:18:06.050
which is the rasterization or the
caching happens at a very precise point

00:18:06.050 --> 00:18:09.120
in this kind of pipeline of rendering operations.

00:18:09.120 --> 00:18:14.450
Really, what we're doing is we're taking the
layer, and all its sublayers, and its contents,

00:18:14.450 --> 00:18:20.250
and copying that to an image, and then taking that
kind of thing and stamping it into its parent.

00:18:20.250 --> 00:18:23.200
And the act of compositing it into
its parent is another step

00:18:23.200 --> 00:18:26.210
in the rendering process, and that's where masking happens.

00:18:26.210 --> 00:18:31.210
So, if you have a mask layer applied to a
layer, it's going to put a nice shape around it.

00:18:31.210 --> 00:18:36.310
Then that is going to be working on the cache
version, and so the masking operation itself,

00:18:36.310 --> 00:18:40.410
which is also fairly expensive, will not get
any benefit from the caching, at that point.

00:18:40.410 --> 00:18:43.520
So, obviously, if you want to deal
with that, you can just turn on caching

00:18:43.520 --> 00:18:47.010
on the sublayer, and, hopefully, that'll solve it.

00:18:47.010 --> 00:18:54.470
Okay, so one UA guide for iPhone iOS 4, I should
say, is something to do with keyframe animation.

00:18:54.470 --> 00:18:56.880
So, let's talk about that.

00:18:56.880 --> 00:19:01.970
So, as you may have seen in the previous Core
Animation talk, keyframe animations are another type

00:19:01.970 --> 00:19:08.560
of animation object, which instead of just moving
between two points, they move value between endpoints.

00:19:08.560 --> 00:19:14.440
So, for example, in this case, we have four points,
and we're moving some point up, down, whatever.

00:19:14.440 --> 00:19:16.280
But you can see here the lines are very straight.

00:19:16.280 --> 00:19:19.560
There's no curves, so it might be okay
for what you want, but, typically,

00:19:19.560 --> 00:19:23.290
you want a more natural kind of animation movement.

00:19:23.290 --> 00:19:29.370
And you can do that with the previous set of APIs, but
it's fairly tricky in that you need to either create a set

00:19:29.370 --> 00:19:32.310
of timing functions to apply to
each segment, or use a Bezier path.

00:19:32.310 --> 00:19:37.650
And in both those cases, you have to be very careful
to preserve continuity through the transition points.

00:19:37.650 --> 00:19:42.390
You have to make sure the tangents of
each side line up and all that stuff.

00:19:42.390 --> 00:19:47.210
So, we've added a new feature, which is basically
what we call a new calculation mode for the animation,

00:19:47.210 --> 00:19:50.010
and a calculation mode is just how we do the interpolation.

00:19:50.010 --> 00:19:55.900
So, whereas, before we were using a linear
calculation mode, we've added a new one called Cubic.

00:19:55.900 --> 00:20:01.490
And most of you probably know, a Cubic interpolation is not
just looking at two points to get the interpolated point.

00:20:01.490 --> 00:20:03.770
It looks at the surrounding points, as well.

00:20:03.770 --> 00:20:07.260
Because of that, it preserves the
continuity through the points.

00:20:07.260 --> 00:20:13.160
So, when I set that, instead of having this
flat, angular curve, we get this fairly similar,

00:20:13.160 --> 00:20:16.790
but now we have the transitions are a lot smoother.

00:20:16.790 --> 00:20:24.210
And so this is actually using something called a Catmull-Rom
spline to fit those points, but there is a fair amount

00:20:24.210 --> 00:20:30.000
of customizability here, and there's three other properties
on the animation core, the tension, continuity, and bias,

00:20:30.000 --> 00:20:36.270
which just let you kind of yank the tangents a little
more, but without ever giving you the possibility

00:20:36.270 --> 00:20:41.970
that you're going to lose that continuity,
at least unless you really want to.

00:20:41.970 --> 00:20:45.950
So, it's a very quick thing, and,
hopefully, it's very easy to use.

00:20:45.950 --> 00:20:51.090
It should just-- if you need to use it,
hopefully, it'll make things a lot easier.

00:20:51.090 --> 00:20:57.510
So, another animation topic, which I guess Michael
touched on earlier, but I wanted to talk about, too,

00:20:57.510 --> 00:21:01.990
when you apply a rotation animation,
there are really two ways to do that.

00:21:01.990 --> 00:21:07.440
You can either use the transform property-- and,
obviously, in that case, you're interpolating matrices,

00:21:07.440 --> 00:21:15.070
which means that to represent angles, the angle is a
modulo one ton, because that's just what matrices do.

00:21:15.070 --> 00:21:21.590
Or you can use this other subproperty called
rotation.z and then interpolate that as a 1d value.

00:21:21.590 --> 00:21:28.590
That avoids this kind of modulation issue, modulo
issue, because you're going to animate your angles, say,

00:21:28.590 --> 00:21:37.780
from 0 to 720 degrees, but you have a whole other set of
issues to deal with, which are this Euler angle problem.

00:21:37.780 --> 00:21:41.790
And so what you're really asking us to do here
is take the matrix, the transform property,

00:21:41.790 --> 00:21:46.770
and extract the three Euler angles for
that matrix, and then interpolate those.

00:21:46.770 --> 00:21:52.730
And the problem with that is that it works fairly
well, if you're only animating one of them.

00:21:52.730 --> 00:21:57.510
But once you start touching multiple of these Euler
angles, like you want to do a y animation and a z,

00:21:57.510 --> 00:22:03.000
then you get into a whole world of pain, I guess,
because these things really don't concatenate nicely.

00:22:03.000 --> 00:22:06.950
You can get gimbal lock issues,
where they align to the same plane.

00:22:06.950 --> 00:22:14.230
And it can be a nasty issue, so what we've had
to, I guess, a couple of releases ago, now,

00:22:14.230 --> 00:22:20.380
is a new value function property, and the value
function is really just a way to apply a function

00:22:20.380 --> 00:22:23.220
to the interpolate to get the value we set on the property.

00:22:23.220 --> 00:22:28.060
And so, obviously, you know, the
interpolant is what we're interpolating,

00:22:28.060 --> 00:22:31.990
and so we want to think about that
for this rotation problem.

00:22:31.990 --> 00:22:35.160
Then what we're going to do is like
the Euler angle rotate animation.

00:22:35.160 --> 00:22:40.740
We're going to interpolate a 1d
value between 0 and 2 pi or 0 360.

00:22:40.740 --> 00:22:47.910
But we're going to set that to the transform property of
the layer, which, as you know, is a matrix, not a 1d value.

00:22:47.910 --> 00:22:53.540
So, we have to apply this makeRotationMatrix
function to turn that 1d value into the matrix.

00:22:53.540 --> 00:22:57.840
But, hopefully, you can see that by doing this we've
avoided all these problems with the previous two methods

00:22:57.840 --> 00:23:00.710
of doing this, which are we can represent any angles.

00:23:00.710 --> 00:23:05.070
We get complete control over how the
interpolation happens through those angles,

00:23:05.070 --> 00:23:08.470
and we don't have to worry about any of those Euler angles.

00:23:08.470 --> 00:23:15.150
So, if you have two animations, both setting the
transform property and with the additive mode set,

00:23:15.150 --> 00:23:19.650
then they will animate correctly, and
you should get exactly what you wanted.

00:23:19.650 --> 00:23:22.520
So, again, just a really quick
example of what this looks like.

00:23:22.520 --> 00:23:25.130
So, we create an animation for the transform.

00:23:25.130 --> 00:23:30.900
We set the two from and to values to be 0 2
pi, and then we just set the value function

00:23:30.900 --> 00:23:34.070
to be a instance of the CA/valueFunction class.

00:23:34.070 --> 00:23:38.590
And right now there's no way to create your own
functions, but we give you a bunch of useful ones.

00:23:38.590 --> 00:23:43.170
So, in this case, we want to have the function
which takes a single value and creates a matrix,

00:23:43.170 --> 00:23:48.120
which is a rotation of that z access,
which is normal to the rotation.

00:23:48.120 --> 00:23:53.410
So, when we get that, that's going to do what we saw on the
previous slide, and then finally we'll just set the duration

00:23:53.410 --> 00:23:57.530
at the animation of the layer, and off we go.

00:23:57.530 --> 00:24:07.040
So, one final animation point, which is, typically, you
often want to find when the animations have completed.

00:24:07.040 --> 00:24:11.730
You want to modify your layer tree at that
point, add new content, or remove them.

00:24:11.730 --> 00:24:14.000
You want to chain animations, in some cases.

00:24:14.000 --> 00:24:22.830
And then so previous to iOS 4 and Mac OS Snow Leopard, the
only way to do that was to create the animations explicitly,

00:24:22.830 --> 00:24:29.740
and then set the delegate property, and that works fine,
but often explicitly creating animations is more work

00:24:29.740 --> 00:24:33.310
than you have to do otherwise, because we
have all this implicit animation feature.

00:24:33.310 --> 00:24:42.330
So, we now have this other way of getting completion
callbacks, which are using the objective C block syntax.

00:24:42.330 --> 00:24:49.930
And so setting this transaction completion property
will tell us the runtime, that this is a block of code.

00:24:49.930 --> 00:24:54.790
And any animations I create from this point, I want you
to remember the block of code they're associated with.

00:24:54.790 --> 00:25:00.480
And then when all of those animations have completed, that's
when you fire off the block to run on the main thread,

00:25:00.480 --> 00:25:03.600
and it gets to do whatever completion work it needs to do.

00:25:03.600 --> 00:25:10.350
So, a lot less typing than creating explicit animation
subclasses, delegates, and all that kind of thing.

00:25:10.350 --> 00:25:18.240
So, again, in this example, we created a block, and then we
just set these two properties, capacity and position, and,

00:25:18.240 --> 00:25:21.630
obviously, what we're trying to do here
is we're ramping down the capacity to 0

00:25:21.630 --> 00:25:24.660
and moving this layer somewhere far over to the right.

00:25:24.660 --> 00:25:27.870
So, you can probably guess we're
trying to move this thing offscreen.

00:25:27.870 --> 00:25:30.890
So, then, when the block runs that we set up
earlier, it's just going to remove the layer

00:25:30.890 --> 00:25:33.920
and then, presumably, do some other cleanup work.

00:25:33.920 --> 00:25:40.570
And that's a nice way to animate some types of things,
where you don't need to do this work afterwards.

00:25:40.570 --> 00:25:46.460
But implicit animations are totally
enough for what you need to do.

00:25:46.460 --> 00:25:50.910
Okay. So, that's really all the API mixture.

00:25:50.910 --> 00:25:57.440
So, just in summary, I think the most important
point to this section, if you're going to do shadows

00:25:57.440 --> 00:26:04.430
on the embedded iPhone platform devices,
things, then you really must use the shadowPath.

00:26:04.430 --> 00:26:07.410
Just not setting that is really
not acceptable to performance.

00:26:07.410 --> 00:26:11.640
I would say putting 100 times that over 100
would never be good enough for what you want.

00:26:11.640 --> 00:26:15.200
So, you really do need to set the shadowPath.

00:26:15.200 --> 00:26:22.600
Secondly, CAShapeLayer, although not useful for everything,
in some cases, can really save you, because it works,

00:26:22.600 --> 00:26:27.850
gets around all these limitations of bitmaps, and
the performance is really good enough to have a few

00:26:27.850 --> 00:26:32.170
of these things running around, as we saw,
and getting you this nice rendering quality.

00:26:32.170 --> 00:26:39.180
And then, finally, think about if you're
coding up some kind of animated UI,

00:26:39.180 --> 00:26:44.970
and the performance really isn't good enough, then using the
shouldRasterize property to try and get some kind of caching

00:26:44.970 --> 00:26:49.340
out of it is often a really good way to improve performance.

00:26:49.340 --> 00:26:54.620
But I must stress, like I said, it's
really a last resort kind of feature

00:26:54.620 --> 00:26:57.720
in that you don't want to do it unless you really have to.

00:26:57.720 --> 00:27:03.110
Okay. So, the next thing I want
to talk about is performance.

00:27:03.110 --> 00:27:10.340
Specifically, I want to build up a
picture of how to think about performance

00:27:10.340 --> 00:27:13.080
of graphics rendering on the iPhone and the Mac.

00:27:13.080 --> 00:27:17.890
I'll mostly focus on the iPhone, although all of
this stuff is really applicable to both platforms.

00:27:17.890 --> 00:27:20.090
So, the first question you really
want to ask is we're going to build

00:27:20.090 --> 00:27:22.690
up from the bottom, up from the hardware through to the API.

00:27:22.690 --> 00:27:24.960
And so the question is what do GPUs do?

00:27:24.960 --> 00:27:28.320
A GP obviously being a graphics
card or a graphics processor.

00:27:28.320 --> 00:27:30.940
And so you may have seen this kind of diagram before.

00:27:30.940 --> 00:27:36.050
This is like one way we program the GPU, and
this is not really what I'm talking about.

00:27:36.050 --> 00:27:37.290
We really don't care about this.

00:27:37.290 --> 00:27:39.150
This is for open GL programmers.

00:27:39.150 --> 00:27:43.670
And we're really program at a much
different level than this.

00:27:43.670 --> 00:27:47.060
We don't deal with lots of vertices.

00:27:47.060 --> 00:27:50.200
So, we're really just thinking about triangles.

00:27:50.200 --> 00:27:55.560
So, let's get rid of that, and let's think about GPUs.

00:27:55.560 --> 00:28:00.800
In our eyes, the GPU is really just the
device to compare triangles to pixels.

00:28:00.800 --> 00:28:04.530
Obviously, the pixels live in a frame
buffer, a piece of memory somewhere.

00:28:04.530 --> 00:28:06.610
And so we have multiple types of triangles.

00:28:06.610 --> 00:28:09.730
Firstly, we can have a triangle with a color.

00:28:09.730 --> 00:28:10.280
You can see that.

00:28:10.280 --> 00:28:17.480
We can have triangles with an image, and
we can have triangles that aren't opaque,

00:28:17.480 --> 00:28:20.260
so they need to be composited with what's beneath them.

00:28:20.260 --> 00:28:25.970
The interesting point there, from a performance standpoint,
at least, is that the first two were both opaque,

00:28:25.970 --> 00:28:31.300
so they really don't care what's beneath them, and they
can just write that color directly into the frame of them;

00:28:31.300 --> 00:28:36.840
whereas, the second one, the non-opaque one really
needs to do some math to compute the final pixel.

00:28:36.840 --> 00:28:43.370
So, it's going to look at what's underneath it, do some
kind of plus, multiply thing, and then write that back in.

00:28:43.370 --> 00:28:48.550
So, already we can see that blended
triangles have more performance,

00:28:48.550 --> 00:28:52.380
more GPU cycles required for them than opaque triangles.

00:28:52.380 --> 00:28:55.200
So, that's very useful if you're
thinking about your UI, right?

00:28:55.200 --> 00:29:01.850
And then, finally, one other thing to think about is
that we're not just talking about one memory buffer.

00:29:01.850 --> 00:29:07.930
We can draw triangles into a piece of memory and then use
that as the source image to apply to another triangle.

00:29:07.930 --> 00:29:14.430
And so you can see here, I took the content I previously
rendered and mapped it across some other set of vertices.

00:29:14.430 --> 00:29:16.870
That's really all we can talk about for the GPU.

00:29:16.870 --> 00:29:22.020
So, the question then becomes how
do we take your view hierarchy,

00:29:22.020 --> 00:29:24.470
and how do we map that onto that set of primitives?

00:29:24.470 --> 00:29:29.090
The answer is really very simple, which is we
just take your layers and map them into triangles.

00:29:29.090 --> 00:29:34.660
So, this is an image I reused, so kind of
like triangles, but the idea is that each

00:29:34.660 --> 00:29:36.300
of these rectangles is really just two triangles.

00:29:36.300 --> 00:29:42.490
Obviously, you can split from one vertex,
split between opposite rectangle points

00:29:42.490 --> 00:29:45.580
and get two triangles out of each of these rectangles.

00:29:45.580 --> 00:29:48.350
So, specifically, your layer has a background color.

00:29:48.350 --> 00:29:50.550
Your view has a background color.

00:29:50.550 --> 00:29:55.380
Then we would draw two color triangles in that color
into the layer of the thing I was drawing it to.

00:29:55.380 --> 00:30:00.700
Similarly, if you have an image applied to the contents
of the layer, then we draw two triangles on an image, and,

00:30:00.700 --> 00:30:05.840
obviously, you can see, depending on the opacity of those
contents, we may have to turn blending on one of them.

00:30:05.840 --> 00:30:11.360
And then, again, more complex compositing effects will use
that other feature we talked about, which is render similar,

00:30:11.360 --> 00:30:16.260
render something similar, and then use that to
do some extra map, copy that back to the screen.

00:30:16.260 --> 00:30:17.650
And simply, we can do caching.

00:30:17.650 --> 00:30:22.870
We saw just before that when we cache something,
we render it into one buffer and then copy it back.

00:30:22.870 --> 00:30:26.500
And also things like masking filters, if you're on a Mac.

00:30:26.500 --> 00:30:28.030
All these things have to do extra work.

00:30:28.030 --> 00:30:30.220
They can't just render directly to the screen.

00:30:30.220 --> 00:30:36.580
It turns out that's a big deal for the GPU,
because it interrupts its flow of stream.

00:30:36.580 --> 00:30:40.790
You can think of the GPU like an oil tanker.

00:30:40.790 --> 00:30:43.610
It's moving along, and if you need to
stop it and point it somewhere else,

00:30:43.610 --> 00:30:48.260
it's a big operation that takes a lot of time.

00:30:48.260 --> 00:30:50.220
So, one more thing.

00:30:50.220 --> 00:30:55.600
Obviously, we, at the Core Animation
level, we don't even bother sending content

00:30:55.600 --> 00:30:58.300
to the screen that's colored by opaque regions, typically.

00:30:58.300 --> 00:31:02.540
Again, if you're thinking about performance, you
need to know that, because you really just need

00:31:02.540 --> 00:31:05.690
to look at the visible areas of your app.

00:31:05.690 --> 00:31:11.890
For example, your application on the iPhone is sitting
on top of Springboard icons, probably, the hump screen.

00:31:11.890 --> 00:31:16.300
And if we didn't do this, then that would
contribute to the performance of your application.

00:31:16.300 --> 00:31:20.650
But since we do, really, you can stop
thinking about what you have to care about,

00:31:20.650 --> 00:31:23.180
once you get down to that first opaque layer.

00:31:23.180 --> 00:31:27.560
Now we get to the interesting part, I guess, which
is, given that we know, roughly, what we're doing,

00:31:27.560 --> 00:31:33.510
at least to some very broad strokes, degree,
then what are the costs involved here?

00:31:33.510 --> 00:31:36.230
What are the expensive things we have to care about?

00:31:36.230 --> 00:31:38.510
So, we can break this down into three points.

00:31:38.510 --> 00:31:44.970
Basically, how many destination pixels are we going
to touch in the screen or the temporary frame buffer?

00:31:44.970 --> 00:31:48.160
How many pixels do we have to read to generate that content?

00:31:48.160 --> 00:31:50.910
So, obviously, we have triangles with images.

00:31:50.910 --> 00:31:56.390
We need to read so many triangles to generate
the destination pixel, so I read so many pixels.

00:31:56.390 --> 00:31:58.890
And then, finally, how many times do we switch buffers?

00:31:58.890 --> 00:32:01.960
And so we basically give these a name.

00:32:01.960 --> 00:32:05.110
We have write bandwidth, read bandwidth, which,
obviously, measures the memory bandwidth.

00:32:05.110 --> 00:32:08.320
We really just have to think of how many pixels, really.

00:32:08.320 --> 00:32:12.620
And then the big one is how many
times do we have to switch buffers?

00:32:12.620 --> 00:32:16.410
So, just a few quick examples of when you run into these.

00:32:16.410 --> 00:32:19.370
Firstly, we have too much non-opaque
content, then you probably will--

00:32:19.370 --> 00:32:25.290
your application will be limited by the amount of writing
the GPU has to do, the number of destination pixels it has

00:32:25.290 --> 00:32:33.770
to touch, because, obviously, translucent things have to be
drawn; whereas, the opaque things, they wouldn't have to be.

00:32:33.770 --> 00:32:37.410
Secondly, too many large images, then you're
probably going to be limited by the amount

00:32:37.410 --> 00:32:40.010
of data the GPU is having to read every frame.

00:32:40.010 --> 00:32:46.100
And then, again, if you have too many masking operations,
then the GPU will be switching between rendered targets,

00:32:46.100 --> 00:32:48.830
and the performance will get lost that way.

00:32:48.830 --> 00:32:55.060
Typically, what will happen is, at any one point, your
app will be bottlenecked behind one of these three points,

00:32:55.060 --> 00:32:59.180
and so you'll do some work, fix that, and when
your final is fast, but not quite fast enough,

00:32:59.180 --> 00:33:02.030
and then you have to switch and
look at one of these other points.

00:33:02.030 --> 00:33:08.640
So, at this point, I want to switch and try
and put some examples behind all this talk.

00:33:08.640 --> 00:33:13.960
And so what I have here is a sample application.

00:33:13.960 --> 00:33:18.010
This is available on the WWDC website.

00:33:18.010 --> 00:33:19.980
Hopefully, you'll be able to find it.

00:33:19.980 --> 00:33:23.770
It's called the Core Animation Image Browser.

00:33:23.770 --> 00:33:27.950
So, I'm just going to run it once,
so you can see what it does.

00:33:27.950 --> 00:33:34.490
I'm going to build it, compile it, and switch onto this, and
then we came up, and we had this kind of image browser app.

00:33:34.490 --> 00:33:39.430
And I could flick, and it scrolls slowly.

00:33:39.430 --> 00:33:40.850
The structure of this is pretty simple.

00:33:40.850 --> 00:33:42.440
We have a scroll view.

00:33:42.440 --> 00:33:49.920
We have view controller, and we have a subclass of the
scroll view, which kind of lays out these item layers,

00:33:49.920 --> 00:33:55.000
and each one of these is a view, but
it has a custom layer backing it.

00:33:55.000 --> 00:33:57.520
So, really, we're going to spend
a lot of time looking at how

00:33:57.520 --> 00:34:01.580
that item layer is implemented and
what we can do to make it faster.

00:34:01.580 --> 00:34:02.360
So, this is the app.

00:34:02.360 --> 00:34:06.460
I'm just going to give you a very quick run through.

00:34:06.460 --> 00:34:07.750
So, we have some code.

00:34:07.750 --> 00:34:09.590
We have a app delegate, a view controller.

00:34:09.590 --> 00:34:15.010
The view controller is really just taking
a bunch of URLs from the app bundle

00:34:15.010 --> 00:34:18.540
and then passing them on to the scroll view.

00:34:18.540 --> 00:34:29.880
The scroll view has a little bit of code to do this layout,
and so the layout method is really just, like I said,

00:34:29.880 --> 00:34:34.840
creating an item view for every image
that was given, image URL that was given,

00:34:34.840 --> 00:34:39.590
and then initializing the image
view, the item view, with the URL.

00:34:39.590 --> 00:34:41.850
And then it's going to add that to itself as a subview.

00:34:41.850 --> 00:34:45.190
There's some other stuff down here we'll talk about later.

00:34:45.190 --> 00:34:48.440
So, the item view is really simple.

00:34:48.440 --> 00:34:56.050
All that it does is it has an end method, but, more
importantly, it implements layer class to redirect the UIKit

00:34:56.050 --> 00:35:01.830
to be using another, our own layer
subclass as the backing of this view.

00:35:01.830 --> 00:35:03.190
We don't want to use CALayer.

00:35:03.190 --> 00:35:05.470
We want to use our own one with all its custom codes.

00:35:05.470 --> 00:35:09.530
We return our class from this method,
and that's what happens.

00:35:09.530 --> 00:35:12.540
And then when we initialize ourselves,
we just basically pass on the image URL

00:35:12.540 --> 00:35:16.410
into the layer that was created for us by UIKit.

00:35:16.410 --> 00:35:23.130
So, like I said, most of the code, in fact pretty
much all of it is in this image or item layer.

00:35:23.130 --> 00:35:27.430
And you can see it has a bunch of methods.

00:35:27.430 --> 00:35:30.450
And what do I want to talk about?

00:35:30.450 --> 00:35:36.120
Right. So, I guess the final point here is the-- obviously,
I don't have time to write code here, so I kind of cheated

00:35:36.120 --> 00:35:39.070
and added a header file with a bunch of
different options we can turn on or off.

00:35:39.070 --> 00:35:44.560
So, the first thing I want to do is I want to recompile
with this, using this thread option, enable it, because,

00:35:44.560 --> 00:35:48.260
as you saw, maybe this thing took
a really long time to start up,

00:35:48.260 --> 00:35:52.300
and we don't want to be waiting
for every time we test something.

00:35:52.300 --> 00:35:58.320
So, by setting this use image thread, all that's going
to do is we're going to create a background thread,

00:35:58.320 --> 00:36:02.520
and we're going to arrange for our images to be loaded
on the background thread and then set into the layer

00:36:02.520 --> 00:36:05.350
as they arrive, rather than just
doing it all at once ahead of time.

00:36:05.350 --> 00:36:11.420
And that's really not a Core Animation performance
thing, but it makes this a lot more usable.

00:36:11.420 --> 00:36:12.510
So, let's run it again.

00:36:12.510 --> 00:36:18.340
Okay, so now you can see that the images are
loading, as we go, and that's a lot better.

00:36:18.340 --> 00:36:22.960
But performance now is what we want to look
at, and performance here is really bad.

00:36:22.960 --> 00:36:30.690
So, the first thing we want to change here is
we want to look at how the shadows are drawn.

00:36:30.690 --> 00:36:37.110
You saw each of those items had a shadow, and I'm afraid
I did the thing I told you, you really shouldn't do,

00:36:37.110 --> 00:36:43.600
which is I basically just set up the shadow properties
in my init method, passed the radius offset,

00:36:43.600 --> 00:36:46.530
and then let it auto generate the shadows.

00:36:46.530 --> 00:36:48.620
That actually works pretty well in
the Simulator, but in the Simulator,

00:36:48.620 --> 00:36:50.950
we have a very fast CPU to do all that rendering for us.

00:36:50.950 --> 00:36:56.160
So, I'm going to go back to my options, and I'm going
to say, okay, let's use the shadowPath this time.

00:36:56.160 --> 00:37:07.760
And so, hopefully, when I rerun this, we'll see--
okay, so, see, we still have the same shadows, but,

00:37:07.760 --> 00:37:12.550
well, it's a little faster, not massively so.

00:37:12.550 --> 00:37:17.000
Okay, well, anyway, so we know we
still have work to do here, right?

00:37:17.000 --> 00:37:20.440
So, hopefully, you can see it's better.

00:37:20.440 --> 00:37:22.970
Now, the other thing I want to look at is the images.

00:37:22.970 --> 00:37:30.820
This is going to be really hard to make out, but the
other bad thing we did is we, when we loaded the images,

00:37:30.820 --> 00:37:35.310
we just took the CG image that UIKit
loaded for us, and we assigned it directly

00:37:35.310 --> 00:37:38.950
to the contents layer, because we can do that, and it works.

00:37:38.950 --> 00:37:41.530
And so here, what we have, nine images onscreen.

00:37:41.530 --> 00:37:46.620
These images are actually 1024 X 768, which is screen sized.

00:37:46.620 --> 00:37:52.380
So, you can imagine, when I composite this, I'm actually
asking the GPU to read nine times the screen size

00:37:52.380 --> 00:37:54.180
and the amount of image data which is quite a lot of memory.

00:37:54.180 --> 00:37:57.220
I guess this screen is roughly a megapixel.

00:37:57.220 --> 00:37:59.140
See, now that's nine million pixels.

00:37:59.140 --> 00:38:04.900
A really easy way to fix that, which is--
well, for me, I'm just going to turn on this,

00:38:04.900 --> 00:38:09.190
but [laughter] I'm going to tell
you what I actually did now.

00:38:09.190 --> 00:38:10.140
[laughter] So, right.

00:38:10.140 --> 00:38:17.890
So, instead of using the contents properties-- you can
see before what I was doing is getting the image up here,

00:38:17.890 --> 00:38:25.110
finish loading, and this is my didChangeValueForKey,
so when I set the image property, I want to pull that to the layer,

00:38:25.110 --> 00:38:30.160
so, in this case, before I was setting the contents
of the layer to be image that had been loaded,

00:38:30.160 --> 00:38:32.220
at this point, putting it on a backup thread.

00:38:32.220 --> 00:38:36.610
Then calling setNeedsLayout, just so I can update
the bounds and the shadow shape, basically.

00:38:36.610 --> 00:38:39.970
But, so, what I'm going to do is I'm not going
to set the layer contents to be the image,

00:38:39.970 --> 00:38:42.350
because that's how we get this nasty behavior,

00:38:42.350 --> 00:38:47.670
where we have all this image data being
downsampled on the fly of your frame.

00:38:47.670 --> 00:38:53.960
I'm going to tell it send this display, and at the same
time, I'm going to implement the drawer in context method.

00:38:53.960 --> 00:38:57.820
And so my draw in context is going to do a bit of work.

00:38:57.820 --> 00:39:01.230
First of all, I'm going to take advantage of
the fact that now that I'm actually drawing,

00:39:01.230 --> 00:39:07.990
I can get rid of the composited shadow entirely
by just asking core graphics to shut it for me.

00:39:07.990 --> 00:39:13.260
But, mainly, I'm going to fetch the image, and I'm going to
draw the image directly into the layer I've back in store.

00:39:13.260 --> 00:39:16.760
But, obviously, I'm going to draw it at
the size I want it, not the original size,

00:39:16.760 --> 00:39:21.590
so firstly I'm going to have Core Graphics do
that down sampling, which is going to get a much,

00:39:21.590 --> 00:39:28.560
much better result than having the GPU do it, because
this is kind of bread and butter for Core Graphics.

00:39:28.560 --> 00:39:35.900
And, secondly, obviously, when we come to draw, we
have prescaled content, which is not the right size,

00:39:35.900 --> 00:39:40.620
so we really, at that point, instead of
compositing 9 times the screen size of image data,

00:39:40.620 --> 00:39:43.740
which is going to have roughly screen size.

00:39:43.740 --> 00:39:47.350
So I think I flip that, so let's recompile again.

00:39:47.350 --> 00:39:53.120
Okay. So, firstly, if you're looking at this on
the actual device, you'd see it looks better,

00:39:53.120 --> 00:39:57.900
but immediately you see the performance
is way, way better now.

00:39:57.900 --> 00:40:02.880
And just by having the right amount of image data for the
right size screen, we can give the GPU the amount of work

00:40:02.880 --> 00:40:06.850
that it really likes to be doing, instead of way, way more.

00:40:06.850 --> 00:40:14.890
Okay. There's one more thing I think I should show you here.

00:40:14.890 --> 00:40:17.910
I need to restart this.

00:40:17.910 --> 00:40:20.560
So, I'm going to run-- I guess I should switch back.

00:40:20.560 --> 00:40:26.220
I'm going to run this, this time, using the same version of
the application, but I'm going to run it using instruments,

00:40:26.220 --> 00:40:30.440
specifically, the Core Animation instruments tool.

00:40:30.440 --> 00:40:32.500
So, this is messed up.

00:40:32.500 --> 00:40:35.150
Maybe I have to kill this.

00:40:35.150 --> 00:40:36.400
There we go.

00:40:36.400 --> 00:40:46.910
Right, so, you can see we have-- okay,
I have to-- I didn't rehearse this.

00:40:46.910 --> 00:40:53.090
So, anyway, what I wanted to turn on is this color
blended layer option, and I want to switch back.

00:40:53.090 --> 00:40:59.310
You can see that-- you can see I can't scroll for one thing.

00:40:59.310 --> 00:41:03.190
But, anyway, the point here is that
we're asking Core Animation to tell us

00:41:03.190 --> 00:41:06.480
where the opaque pixels, and where
are the non-opaque pixels?

00:41:06.480 --> 00:41:07.900
So, we can see this example.

00:41:07.900 --> 00:41:10.510
Obviously, the background is green, so that's good.

00:41:10.510 --> 00:41:11.550
That's opaque.

00:41:11.550 --> 00:41:14.660
But all these images are being
asked to composite every frame.

00:41:14.660 --> 00:41:17.530
And if you look at them, they're opaque, right?

00:41:17.530 --> 00:41:20.490
So, we really don't need to do that.

00:41:20.490 --> 00:41:25.820
We can just have them mark themselves as
opaque and get rid of the Alpha channel.

00:41:25.820 --> 00:41:28.180
In this case, they had a shadow,
as well, but we can cheat there.

00:41:28.180 --> 00:41:32.790
We can just draw white into the background of the
layer, because we know the background is white.

00:41:32.790 --> 00:41:37.740
So, I'm going to put that to the background.

00:41:37.740 --> 00:41:45.510
And so we have this other option, which is going to set
the-- I think it sets the-- I can't remember what it does,

00:41:45.510 --> 00:41:48.180
but it sets the opaque property of the layer.

00:41:48.180 --> 00:41:51.470
And you can see where it's saying here,
if our layer is opaque, when we draw it,

00:41:51.470 --> 00:41:55.770
we're just going to fill the background with white.

00:41:55.770 --> 00:42:03.790
And so I run this again, and, hopefully,
this time, it's going to be a lot greener.

00:42:03.790 --> 00:42:07.870
You probably won't see a difference in performance,
because we weren't really stressing that aspect of the GPU

00:42:07.870 --> 00:42:13.390
in this app, but this would be useful in
your other cases-- except I don't hit save.

00:42:13.390 --> 00:42:20.050
Okay. Okay, here we go.

00:42:20.050 --> 00:42:26.300
Okay, so now it's all green, and that basically
means that it's still scrolling really smoothly,

00:42:26.300 --> 00:42:31.030
and probably if I put a few more images in
here, it'll get smoother than it was before.

00:42:31.030 --> 00:42:34.830
And that's kind of what you want to look for, just
little tricks where you can minimize the amount

00:42:34.830 --> 00:42:39.610
of compositing that's going on
get the extra bit of performance.

00:42:39.610 --> 00:42:47.070
So, one last thing I wanted to show here is-- let's turn
off that color thing, first of all, while I remember.

00:42:47.070 --> 00:42:52.140
So, one final thing, which is a little similar,
but I wanted to show you another feature,

00:42:52.140 --> 00:42:58.650
another way of doing a common feature, which is after you
scroll, and you wanted to have a masked feathered edge

00:42:58.650 --> 00:43:04.100
in it, so I set this to 1, and then recompile.

00:43:04.100 --> 00:43:07.360
Then we'll see the app has changed a little
bit, which is near the top and bottom

00:43:07.360 --> 00:43:11.860
of the scroll layers, we have a feathered edge.

00:43:11.860 --> 00:43:16.930
Right. So, you can see it fading, right?

00:43:16.930 --> 00:43:20.280
I see this every now and then.

00:43:20.280 --> 00:43:22.800
And so you can also see where we
lost a bunch of performance now.

00:43:22.800 --> 00:43:23.890
It's back.

00:43:23.890 --> 00:43:31.910
It's not as bad as it was, but it's still, obviously,
chunky-ish, and so we want it to be as fast as it was,

00:43:31.910 --> 00:43:34.900
but let's, first of all, just look at what we did here.

00:43:34.900 --> 00:43:41.700
So, really, I turned on this stop edge layer, and this
is going to be added as the mask of the scroll view,

00:43:41.700 --> 00:43:49.750
because we want to take the user masking operation to
kind of just gradually clip out the edges of the scroll.

00:43:49.750 --> 00:43:54.810
And so what this does is, really, it's just
a layer, and it has a sublayers method,

00:43:54.810 --> 00:44:00.250
so that whenever its size changes,
it gets to reconfigure itself.

00:44:00.250 --> 00:44:05.900
And in this case, we're basically going to
create two layers-- I'm sorry, three layers.

00:44:05.900 --> 00:44:10.200
We're going to create two gradient layers, one
for each edge, so It's going to wrap from 0 to 1.

00:44:10.200 --> 00:44:12.260
And then we're just going to create
a solid line in the middle,

00:44:12.260 --> 00:44:16.510
and it'll just read a nice gradient,
which is going to ramp from 0 to 1.

00:44:16.510 --> 00:44:19.140
Sorry, 1 to-- 0 to 1, to 1, to 0.

00:44:19.140 --> 00:44:23.820
And you can see, when we set that as the mask
of the layer, we get the effect we wanted,

00:44:23.820 --> 00:44:29.860
because our mask kind of dissolves the
content and then applies it to the background.

00:44:29.860 --> 00:44:36.300
But as I was saying, the performance here wasn't
good enough, and that's because if I switch--

00:44:36.300 --> 00:44:41.530
let's see, if I switch on the color offscreen option,

00:44:41.530 --> 00:44:44.830
and then switch back to the app, you
can see the whole screen is yellow.

00:44:44.830 --> 00:44:51.200
And what that means is that we're basically
taking an extra offscreen rendering pass,

00:44:51.200 --> 00:44:56.410
which is that thing I showed you earlier, where
we draw a bunch of triangles into a buffer,

00:44:56.410 --> 00:44:58.770
and then use that as the source
for another drawing operation.

00:44:58.770 --> 00:45:05.590
And that's, you know, this whole kind of dependency chain
gets created, and it makes performance pretty nasty.

00:45:05.590 --> 00:45:09.420
So, another thing to look at, is you
want to get rid of this kind of thing.

00:45:09.420 --> 00:45:11.780
You want to basically eliminate all of this yellow.

00:45:11.780 --> 00:45:18.030
And just like before, with the shadows, I
could draw the shadows on a white background.

00:45:18.030 --> 00:45:23.580
Again, we know the scroller background here is white,
or at least it's static, and so I don't really need

00:45:23.580 --> 00:45:26.980
to be doing masking here, even though you
may think of this as a masking operation.

00:45:26.980 --> 00:45:31.600
I can turn this around and really just
composite a white gradent on the top and bottom

00:45:31.600 --> 00:45:33.920
of the scroller, and I get the same effect, right?

00:45:33.920 --> 00:45:41.130
So, I have another magic option,
which will-- oops-- do that for me.

00:45:42.780 --> 00:45:51.030
So, I switch this to 2, then what I'm going
to do now is-- if I find the right view--

00:45:51.030 --> 00:45:55.280
you can see I have this piece of code here,
which is setting up this subedge layer.

00:45:55.280 --> 00:46:00.180
So, if edges equals 1, I'm going to use the
mask, which is probably what we're doing.

00:46:00.180 --> 00:46:03.560
But, in this case, I'm just going to add this
as a sublayer of the top of the other thing,

00:46:03.560 --> 00:46:09.250
and then I have to make sure now that the gradient is
inverted, because before we wanted to mask off the edges.

00:46:09.250 --> 00:46:13.540
Now we want to cover them up, so we want the
opacity to be, basically, in the other places.

00:46:13.540 --> 00:46:18.630
So, whereas, before I was having
access to the gradient one way.

00:46:18.630 --> 00:46:23.160
I'm just going to flip it over and drop the layer
in the middle, because we no longer need it.

00:46:23.160 --> 00:46:26.670
So, let's run that.

00:46:28.440 --> 00:46:32.470
Yeah, I'm not going to make that mistake twice, maybe.

00:46:32.470 --> 00:46:38.320
So, I still have the color of the offscreen option
enabled, but you can see it's no longer firing,

00:46:38.320 --> 00:46:39.760
because we don't have any offscreen rendering.

00:46:39.760 --> 00:46:45.470
We just have two white gradients, one on the top, one
on the bottom, to cover up the pixels we want to hide.

00:46:45.470 --> 00:46:49.020
And, obviously, you can see the
performance is back where we want it to be.

00:46:49.020 --> 00:46:54.640
And just to prove, to maybe make it a little more obvious,
I'm going to turn back on the color blended layers option,

00:46:54.640 --> 00:46:56.780
and you can see exactly where these
gradients are now sitting.

00:46:56.780 --> 00:47:02.930
And, obviously, they have to be blended,
because they have an opacity ramp in them.

00:47:02.930 --> 00:47:09.310
Okay. [applause] Okay, so just
going to want to summarize this,

00:47:09.310 --> 00:47:15.260
go over these three things, talk
about what we were just saying.

00:47:15.260 --> 00:47:18.810
So, firstly, let's get rid of those blended layers.

00:47:18.810 --> 00:47:22.910
You need to minimize the number of alpha-blended
pixels to minimize the amount of write bandwidth.

00:47:22.910 --> 00:47:27.800
And there's two basic ways to-- first
of all, there's one way to see that,

00:47:27.800 --> 00:47:30.590
which is you turn on this color blended layer option.

00:47:30.590 --> 00:47:35.520
That's in instruments, and instruments
only works for the devices.

00:47:35.520 --> 00:47:41.220
And so if you're running on a Mac, or you're running on the
Simulator, you can't use instruments to turn these options

00:47:41.220 --> 00:47:44.670
on yet, so-- but what you can do
is you can set environ variables.

00:47:44.670 --> 00:47:49.650
And so, if you're running on the Mac, you can just
set this environ variable in your x code project

00:47:49.650 --> 00:47:52.440
and then run your application, and
you get exactly the same behavior.

00:47:52.440 --> 00:48:00.530
Or if you're running, say, the iPhone Simulator, then
you can set this environ when you run the Simulator.

00:48:00.530 --> 00:48:03.100
It's not particularly hard to do.

00:48:03.100 --> 00:48:07.190
You just have to make sure to run the Simulator
from the command line before you start x code,

00:48:07.190 --> 00:48:13.890
whatever environ variable set you want, and then when
your app comes up, it'll have all those things preset.

00:48:15.600 --> 00:48:22.190
So to get rid of the alpha channels, you need to make
sure that any image refs, which have opaque data,

00:48:22.190 --> 00:48:25.410
which include the ones we were looking at there, you
have to make sure they don't have an alpha channel,

00:48:25.410 --> 00:48:28.630
because the alpha channel is the way we are told to look at blending.

00:48:28.630 --> 00:48:31.800
We don't look at any properties of the layer.

00:48:31.800 --> 00:48:37.130
We just look at, does the contents
of the layer have an alpha channel?

00:48:37.130 --> 00:48:40.580
And so, if you're drawing into the layer,
obviously, you don't get to touch the CG image rep,

00:48:40.580 --> 00:48:45.720
because there problem isn't one, but you can set
this layer opaque property, which is going to tell us

00:48:45.720 --> 00:48:50.530
that when we create the bitmap here to draw
into, we don't create an alpha channel,

00:48:50.530 --> 00:48:56.520
and so it's kind of the same thing,
two ways of doing the same thing.

00:48:56.520 --> 00:49:04.040
And, finally, another point which is a little more
interesting is that, say you have an image, and it may have,

00:49:04.040 --> 00:49:08.180
say, a translucent border, but an opaque center.

00:49:08.180 --> 00:49:12.500
And what you'll probably do, to start with, is
have one image and just put it on the screen.

00:49:12.500 --> 00:49:17.960
But, obviously, since it has that non-opaque edge, you
have to have the whole thing have an alpha channel.

00:49:17.960 --> 00:49:21.520
And if the image is really large, compared to the border,

00:49:21.520 --> 00:49:25.370
then that can be pretty expensive,
in terms of compositing costs.

00:49:25.370 --> 00:49:30.320
So what you can do, in those cases, is you can
basically just cut up your artwork into multiple images.

00:49:30.320 --> 00:49:34.500
You could do strip at the top, strip
at the bottom, strip down each edge,

00:49:34.500 --> 00:49:38.640
and then you could have the center bit be
an opaque image, like a JPEG or something.

00:49:38.640 --> 00:49:44.050
And that will save you a lot of
performance, if your image is large.

00:49:44.050 --> 00:49:48.920
So, the read bandwidth is really, really
simple, which is just use images that,

00:49:48.920 --> 00:49:50.640
as much as possible, match the screen resolution.

00:49:50.640 --> 00:49:53.800
When I say images, I really mean bitmaps of any type.

00:49:53.800 --> 00:50:00.550
So, layers that draw exactly the same, when you draw
into them, they create a bitmap of the size of the layer,

00:50:00.550 --> 00:50:06.070
so you want to make sure you're drawing
them at the right size to match the screen.

00:50:06.070 --> 00:50:13.840
Yes, don't use megapixel images to create thumbnails,
because it doesn't look good, and it doesn't work well.

00:50:13.840 --> 00:50:18.400
And so, again, there is an option in
instruments for this, "Color Misaligned Images."

00:50:18.400 --> 00:50:21.960
This one is a little tricky to get to understand
correctly, because we've changed it recently.

00:50:21.960 --> 00:50:25.410
So, I'll try and explain what it does.

00:50:25.410 --> 00:50:28.280
If you are on iOS 4, then this will draw two colors.

00:50:28.280 --> 00:50:33.200
If you have an image which has just shifted a little bit,
maybe its edges aren't quite pixel lined, it'll draw pink.

00:50:33.200 --> 00:50:38.650
If you have an image which is scaled, which is really
what we're talking about here, then it'll draw yellow.

00:50:38.650 --> 00:50:43.170
On previous devices, I think there were
ways to draw pink for both those cases.

00:50:43.170 --> 00:50:50.100
So we really added that as one way to help you track down
low res content and a high DPI app, and things like that,

00:50:50.100 --> 00:50:54.770
so you can use it for find any general scale res.

00:50:54.770 --> 00:51:00.240
And then, again, rendering passes, this is really
often the most important thing to get right.

00:51:00.240 --> 00:51:05.320
And, typically, unless you're doing
very small offscreen things,

00:51:05.320 --> 00:51:09.060
you need to have only one rendering
pass per frame to get good performance.

00:51:09.060 --> 00:51:11.560
And so often, you really need to trick your way into that.

00:51:11.560 --> 00:51:15.950
You can't just set all this compositing
stuff up in the most obvious way.

00:51:15.950 --> 00:51:20.760
You really have to think about what you're doing and what
you really need, and just try and drive the number of passes

00:51:20.760 --> 00:51:27.560
down by turning on that thing--
that's not the bullet I was expecting.

00:51:27.560 --> 00:51:31.680
So, complex compositing, things like masking group opacity.

00:51:31.680 --> 00:51:33.400
In some cases, you have that enabled.

00:51:33.400 --> 00:51:36.360
And for those on the Mac, we'll all
require this offscreen rendering.

00:51:36.360 --> 00:51:40.510
And then I was about to say, use the
Color Offscreen Instruments option

00:51:40.510 --> 00:51:43.540
to basically show you wherever
you have this offscreen rendering.

00:51:43.540 --> 00:51:49.720
Obviously, this option controls the yellow tint
over your layers that are drawn over offscreen,

00:51:49.720 --> 00:51:53.290
and so you can see it gets-- if you have multiple
offscreen passes, it'll draw yellow, on top of yellow,

00:51:53.290 --> 00:51:55.490
on top of yellow, and so it gets darker and darker.

00:51:55.490 --> 00:52:00.160
So, that gives you a nice way just
to gauge exactly how bad it is.

00:52:00.160 --> 00:52:09.740
And then one final thing, the feature we talked about
earlier, this cached contents of layers and a bitmap,

00:52:09.740 --> 00:52:11.960
that is actually involving offscreen rendering itself.

00:52:11.960 --> 00:52:16.780
If you get it working correctly-- by which I mean you
actually get some cache reuse from frame to frame,

00:52:16.780 --> 00:52:24.080
because the contents of that cache subtree isn't
changing, there's not too much demand on the cache memory,

00:52:24.080 --> 00:52:27.050
then that can really hide those extra
rendering passes, because you can push them

00:52:27.050 --> 00:52:35.010
into that subtree that's been rendered once, and
then reuse just the image from frame to frame.

00:52:35.010 --> 00:52:39.490
Yes, but there is the caveat always, which you
really need to make sure it's working; otherwise,

00:52:39.490 --> 00:52:41.750
you could be making things worse for yourself.

00:52:41.750 --> 00:52:47.420
Okay, so one more slide on performance.

00:52:47.420 --> 00:52:50.940
So, to sum it all up, there's really a very
simple algorithm here to look for performance.

00:52:50.940 --> 00:52:54.630
Obviously, this involves all those color whatever options.

00:52:54.630 --> 00:52:58.930
But what you're really caring about, why
my frame rate isn't at 60 frames a second.

00:52:58.930 --> 00:53:06.470
Get rid of extra rendering passes, get rid of really large
images, and just get rid of extra non-opaque content.

00:53:06.470 --> 00:53:12.180
And you just have to keep cycling around and around and,
obviously, eliminating extra core graphic storing, as well,

00:53:12.180 --> 00:53:19.080
but at the end of the day, you just have to do the
hard work and get the performance where you want it.

00:53:19.080 --> 00:53:21.390
Okay, so that's enough about performance.

00:53:21.390 --> 00:53:25.110
The final section of the talk is going
to be just a little bit about high DPI.

00:53:25.110 --> 00:53:30.610
And, obviously, we all saw the new iPhone
with the massively high DPI screen.

00:53:30.610 --> 00:53:39.450
And so I don't know if you've been to any of the UIKit
lectures, talks about how that's going to be exposed

00:53:39.450 --> 00:53:41.770
as programming API, but I'm not going to talk about that.

00:53:41.770 --> 00:53:46.370
I just want to give you an idea of how you can
use this stuff on the Core Animation level.

00:53:46.370 --> 00:53:52.040
So, what's really happening here is when we have the
high DPI phone is that you give us the layer tree,

00:53:52.040 --> 00:53:55.350
or you give us a view tree, which
has a layer tree backing it.

00:53:55.350 --> 00:54:01.730
And it gets composited to the screen, so we have
this is a picture of a new iPhone, unfortunately,

00:54:01.730 --> 00:54:05.990
but if we had an old iPhone, then what we're going to have
is we're going to have a screen sized layout that's going

00:54:05.990 --> 00:54:11.350
to have a bitmap, which is 320 X 480 pixels large.

00:54:11.350 --> 00:54:19.910
And then if we were going to display that application on a
high DPI device, then your layer tree is exactly the same.

00:54:19.910 --> 00:54:23.550
But what happens is that when the UI window is created,

00:54:23.550 --> 00:54:27.690
it's going to add a scaling transform
onto the root of your layer tree.

00:54:27.690 --> 00:54:33.800
So, we now have this kind of 200 percent, 2X scaling
transform, which just blows everything up 2X.

00:54:33.800 --> 00:54:35.500
And I don't know if you can see this.

00:54:35.500 --> 00:54:36.570
Maybe you can, actually.

00:54:36.570 --> 00:54:42.960
But when we take a bitmap, and 320 X 480 bitmap,
and blow it up twice, then we get pixilation.

00:54:42.960 --> 00:54:50.670
And so, obviously, if you had that, you would get
very little, if any, benefit from the high DPI screen.

00:54:50.670 --> 00:54:54.570
So, we added some features in Core
Animation to work around this.

00:54:54.570 --> 00:54:59.270
Namely, we have a new property on the layer called
content scale, and what the content scale is,

00:54:59.270 --> 00:55:05.260
it's basically a way of telling us either that-- well,
it tells us the scale factor of the content of the layer,

00:55:05.260 --> 00:55:07.370
and the content is, obviously, the image.

00:55:07.370 --> 00:55:12.660
So, in this case, we're drawing text, so when I set
the content scale to be 2, which is the relationship

00:55:12.660 --> 00:55:20.130
between my layer geometry and the screen geometry, I
get scale by 2X, so I'm going to say content scale 2,

00:55:20.130 --> 00:55:23.780
and what that's going to do is it's
going to implicitly change the size

00:55:23.780 --> 00:55:29.330
of that bitmap context from 320
X 480 to twice that, 640 X 960.

00:55:29.330 --> 00:55:35.170
And then the nice thing, though, is that we'll just
hide this from you by just setting the matrices

00:55:35.170 --> 00:55:39.910
on the Core Graphics context so that you still think
you're drawing, because it's saying 320 X 480 buffer,

00:55:39.910 --> 00:55:44.740
but just Core Graphics will take care of the extra on
what's required to get the high resolution content.

00:55:44.740 --> 00:55:51.370
And so zooming in, this is just
to hammer this home one more time.

00:55:51.370 --> 00:55:55.570
We magnify the old content, and then
we set the content scale properly.

00:55:55.570 --> 00:56:00.250
The buffer changes size, and you get finer
grain, more pixels per inch or whatever.

00:56:00.250 --> 00:56:05.520
And it's going to, obviously, look great, because that's
going to match the natural resolution of the screen.

00:56:05.520 --> 00:56:08.470
You get the highest possible DPI.

00:56:08.470 --> 00:56:16.090
So, one final point is that even though
UIKit, they've chosen the way to expose us

00:56:16.090 --> 00:56:22.580
to apps is preserve compatibility, make
sure that your window is still 320 X 480.

00:56:22.580 --> 00:56:28.540
In some cases, you may want to think about, for example,
if you have graphics content, and you really want to get

00:56:28.540 --> 00:56:34.840
down to the native resolution of the display, you want to
have a 640 X 960 layer, just so you can position things

00:56:34.840 --> 00:56:40.090
in inches, exactly correctly for some reason, then
there's no reason you can't just undo that matrix.

00:56:40.090 --> 00:56:45.340
UI window has this text matrix, but anywhere in
your layer tree, you can apply an inverse to that,

00:56:45.340 --> 00:56:51.640
which are all CBS scale, half, 50 percent matrix, and that
will set things up correctly, and then your layer will be

00:56:51.640 --> 00:56:59.300
in the native, again, in the native coordinates,
native scaling space, and it will match right.

00:56:59.300 --> 00:57:02.080
Okay, so I'm really almost running out of time here.

00:57:02.080 --> 00:57:04.600
So, basically, you have a text scale factor.

00:57:04.600 --> 00:57:06.620
The geometry is the same.

00:57:06.620 --> 00:57:10.080
Content scale should be used for content.

00:57:10.080 --> 00:57:13.510
And like I said earlier, rasterization
scale for rasterizing,

00:57:13.510 --> 00:57:17.320
and you can undo the scale matrix when you need to.

00:57:17.320 --> 00:57:20.470
Okay, so one more slide.

00:57:20.470 --> 00:57:25.580
So, if you take anything out of this,
hopefully, it'll be maybe these three things.

00:57:25.580 --> 00:57:29.830
One, whenever you need to, use shadowPath, or rather,
whenever you're using shadows, use shadowPath.

00:57:29.830 --> 00:57:35.900
Two, whenever you don't have quite the right performance,
but it seems like this could help, use shouldRasterize.

00:57:35.900 --> 00:57:39.880
And three, really think about what your layers are meaning
to the graphics card, and try to think of them in terms

00:57:39.880 --> 00:57:46.770
of triangles and opacity, and what have you, and
just try to make some kind of mental calculations.

00:57:46.770 --> 00:57:50.260
And then now we're really done with five seconds to spare.

00:57:50.260 --> 00:57:51.820
[laughter] Okay, thank you very much.

00:57:51.820 --> 00:57:53.820
[applause]

