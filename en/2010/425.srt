1
00:00:06,950 --> 00:00:12,570
>> John Harper: Welcome to Session 425,
Core Animation in Practice, Part 2.

2
00:00:12,570 --> 00:00:14,390
And my name is John Harper.

3
00:00:14,390 --> 00:00:21,140
I'm part of the Core Engineering team and mostly working
on Core Animation and everything relating to that.

4
00:00:21,140 --> 00:00:25,490
And this talk is kind of a continuation of the first talk.

5
00:00:25,490 --> 00:00:31,120
The idea is that the first talk was kind of setting
the scene, going over all the broad details.

6
00:00:31,120 --> 00:00:36,020
And this one, we want to just dive into
certain areas, not taking a broad slice,

7
00:00:36,020 --> 00:00:40,800
but just looking at things we thought you might find
interesting, to try and give you a better understanding

8
00:00:40,800 --> 00:00:44,350
of what's happening and some new things you can be using.

9
00:00:44,350 --> 00:00:48,750
So, things we're going to go over, we're basically
going to split the talk into three sections.

10
00:00:48,750 --> 00:00:53,210
The first section will be kind of a mixed
grab bag of different APIs, some new,

11
00:00:53,210 --> 00:00:56,250
some things we think you might find useful.

12
00:00:56,250 --> 00:01:01,510
And then we're going to spend quite a bit of time on
performance relating to Core Animation and basically try

13
00:01:01,510 --> 00:01:07,030
to give you an idea of how the GPU, the current
Core Animation, all these things fit together

14
00:01:07,030 --> 00:01:10,750
and affect the performance you see in your applications.

15
00:01:10,750 --> 00:01:16,870
Finally, we're just going to talk very quickly about
the new kind of High-DPI screen on the new iPhone

16
00:01:16,870 --> 00:01:22,600
and what that means to your graphics
rendering from a Core Animation perspective.

17
00:01:22,600 --> 00:01:24,440
So, let's get right into it.

18
00:01:24,440 --> 00:01:30,420
So, the first API I want to talk about, the
first kind of section, I guess, is drop shadows.

19
00:01:30,420 --> 00:01:37,020
And, obviously, shadows are a very important part of your
applications, in that they can often give a lot of depth

20
00:01:37,020 --> 00:01:42,950
to your visual display, and they
can really make something stand out.

21
00:01:42,950 --> 00:01:47,350
They just make things look a lot more natural, often.

22
00:01:47,350 --> 00:01:56,130
So, in the past, we've had a full set of shadow APIs on the
Mac platform, and you can set things like the shadow radius,

23
00:01:56,130 --> 00:02:02,200
and the shadow card, the path, all this kind of stuff, but
we've never actually supported them on the iPhone platforms,

24
00:02:02,200 --> 00:02:05,500
because, really, the performance just wasn't there.

25
00:02:05,500 --> 00:02:11,190
And so when we were doing the iPad, it really became
apparent that we really do need some kind of shadow support,

26
00:02:11,190 --> 00:02:17,300
so we brought all those APIs back onto the
iPhone OS, but we added some new features,

27
00:02:17,300 --> 00:02:22,830
just to make the performance a lot more acceptable on
these kind of lower end devices, compared to the Mac.

28
00:02:22,830 --> 00:02:30,280
So, the new API we added is this thing called the
shadowPath, and so the idea here is that, typically,

29
00:02:30,280 --> 00:02:34,990
if you say "Turn on shadows on your layer," what
that means is that we had to take the Alpha channel

30
00:02:34,990 --> 00:02:39,030
of the composite content, blur it to get
that nice kind of blown out shadow look,

31
00:02:39,030 --> 00:02:43,430
and then apply it underneath the layer, and that
blurring step in particular is a lot of work for the GPU,

32
00:02:43,430 --> 00:02:47,730
and doing it every frame really
doesn't work very well on certain GPUs.

33
00:02:47,730 --> 00:02:52,910
So, the idea of a shadowPath is that this is a
way you can tell us where your layer is opaque.

34
00:02:52,910 --> 00:03:00,100
And, obviously, once we know the opaque region, we
can use that to kind of cache the shadow as a bitmap.

35
00:03:00,100 --> 00:03:03,960
So, we can render it, blur it, and just keep it around.

36
00:03:03,960 --> 00:03:07,400
And then as long as you don't change the
path, the shadow will be there forever,

37
00:03:07,400 --> 00:03:10,090
and we can reuse it from frame to frame very cheaply.

38
00:03:10,090 --> 00:03:14,750
So, I just want to show a very quick demo of this,
to give you the idea of why you should be using it.

39
00:03:14,750 --> 00:03:22,340
So, we have this demo app, and you can
see that we have a number of layers,

40
00:03:22,340 --> 00:03:25,330
just colored rectangles bouncing around the screen.

41
00:03:25,330 --> 00:03:31,130
And so what I'm going to do, first of all,
is just turn on shadows in the old naive way,

42
00:03:31,130 --> 00:03:34,950
where we basically just set the shadow,
capacity of the layer to be non-0.

43
00:03:34,950 --> 00:03:37,520
And when we do that, you can see that we have nice shadows,

44
00:03:37,520 --> 00:03:42,460
but we have pretty horrible performance,
especially when I bring this up a bit.

45
00:03:42,460 --> 00:03:44,450
It's really nasty.

46
00:03:44,450 --> 00:03:46,050
So, very simple.

47
00:03:46,050 --> 00:03:49,190
All we had to do here is set the
shadowPath to be a rectangle

48
00:03:49,190 --> 00:03:51,570
in this case, because that's the shape of the layout.

49
00:03:51,570 --> 00:03:55,840
And as soon as we turn that on, everything
becomes way faster and much smoother.

50
00:03:55,840 --> 00:04:01,710
[applause] So, probably, that shows you
why you should be caring about this.

51
00:04:01,710 --> 00:04:05,080
And now let's just go through that
example in a little more detail.

52
00:04:05,080 --> 00:04:08,060
So, as I said, we have a number of layers.

53
00:04:08,060 --> 00:04:09,900
Each of them was created in this way.

54
00:04:09,900 --> 00:04:10,660
We created a layer.

55
00:04:10,660 --> 00:04:12,630
We set its rectangle.

56
00:04:12,630 --> 00:04:15,670
We set a background color with some random hue.

57
00:04:15,670 --> 00:04:21,650
And then the next, when we enabled shadows, we really
just set the shadowPath, we set the shadow radius,

58
00:04:21,650 --> 00:04:27,460
and set the shadow offset, move the shadow vertically
under the layer a little bit to make it look more natural.

59
00:04:27,460 --> 00:04:34,340
And then when we hit the final button to make
everything fast, all that was happening is this,

60
00:04:34,340 --> 00:04:39,840
and so you can see what we're doing here is we're
going into the UIBezierPath to create a path

61
00:04:39,840 --> 00:04:42,210
for the rectangle, which is the shape of the layer.

62
00:04:42,210 --> 00:04:46,830
And then UIBezierPath is a nice feature where
you can ask it for a CGPath, and, obviously,

63
00:04:46,830 --> 00:04:52,640
the CGPath will be the underlying representation
of that path, and then we can use that CGPath there

64
00:04:52,640 --> 00:04:58,410
to set the shadowPath of the layer, because, obviously
Core Animation is a lower level API than UIKit,

65
00:04:58,410 --> 00:05:01,630
so we really only deal in core graphics objects.

66
00:05:01,630 --> 00:05:02,740
And so, really, that's all you had to do.

67
00:05:02,740 --> 00:05:04,560
There's just one extra line or two extra lines.

68
00:05:04,560 --> 00:05:07,640
You just put them up like I did
here to get those faster shadows.

69
00:05:07,640 --> 00:05:11,390
And, obviously, this isn't restricted
only to rectangular things.

70
00:05:11,390 --> 00:05:16,190
Because it's a path, you can create
round recs, or complex shapes.

71
00:05:16,190 --> 00:05:23,370
Really, anything you can imagine can be put in that
path and used to create the outline for your shadow.

72
00:05:23,370 --> 00:05:25,870
The next topic, moving on from shadows, are shape layers.

73
00:05:25,870 --> 00:05:32,440
And, typically, when you're using Core Animation
layers or UI views, and you have some non--

74
00:05:32,440 --> 00:05:38,880
just a slab of color content, then what you're always using
is a bitmap, and you'll probably be drawing into the bitmap

75
00:05:38,880 --> 00:05:44,740
or providing a CG image ref, and that's fine,
in many cases, but there are problems with that,

76
00:05:44,740 --> 00:05:47,090
if you're trying to, for example, scale the layer.

77
00:05:47,090 --> 00:05:52,620
Then, obviously, since you have a bitmap, the resolution
of the bitmap are fixed, and when you scale it up or down,

78
00:05:52,620 --> 00:05:54,600
you get blurriness, or aliasing, or whatever.

79
00:05:54,600 --> 00:06:00,460
And, also, you can't really animate the contents of that
image, that bitmap, because, you know, again, it's fixed.

80
00:06:00,460 --> 00:06:03,870
So, in certain cases, shape layers
can be a way to avoid those problems.

81
00:06:03,870 --> 00:06:09,190
A shape layer is really just a layer which
draws a path with a filler or a stroke.

82
00:06:09,190 --> 00:06:17,260
And so, because the drawing of the path is deferred
until the composite time, when we know the resolution

83
00:06:17,260 --> 00:06:24,350
that the layer is being drawn at, the we really get a
nice scalable result, where the path will stay sharp,

84
00:06:24,350 --> 00:06:26,620
no matter what scale path you apply to it.

85
00:06:26,620 --> 00:06:33,560
Similarly, we have some support for animating
paths and separating between two path states.

86
00:06:33,560 --> 00:06:39,190
So, if you, for example, have to have a line, and you want
to have it a certain width, and then animate from point A

87
00:06:39,190 --> 00:06:45,040
to point B, then this is a really easy way to
do that without using any images or any bitmaps.

88
00:06:45,040 --> 00:06:51,160
So, we should talk a little bit about the performance
here, because it's not as obvious as just using an image.

89
00:06:51,160 --> 00:06:58,040
Firstly because we're really just storing the contents
as a path, then it really does use very little memory.

90
00:06:58,040 --> 00:07:04,070
I mean, if you have an image, the memory usage is fixed
in terms of width by height; whereas, if you have a path,

91
00:07:04,070 --> 00:07:09,650
then you could have a million by million path
shape, but it could only have four line segments,

92
00:07:09,650 --> 00:07:12,690
and there's probably only like 20 floats or something.

93
00:07:12,690 --> 00:07:18,450
On the other hand, because, like I said, we
deferred the rendering of the path a lot longer,

94
00:07:18,450 --> 00:07:23,810
so we can get these advantages, then we'd all be rendering
probably every frame, and so that can take more CPU

95
00:07:23,810 --> 00:07:30,410
if you're not careful, if you have a very complex path
or a thousand of these names or something like that.

96
00:07:30,410 --> 00:07:36,920
Finally, another plus, I guess, is the images you may have
heard us talk in the past about how you must avoid blending

97
00:07:36,920 --> 00:07:43,700
and all that kind of thing, the nice thing about
shapes is that since we know the shape ahead of time,

98
00:07:43,700 --> 00:07:48,410
because we know what the path is, when we draw it to
the screen, we can ignore all those transparent areas,

99
00:07:48,410 --> 00:07:52,200
so you really only pay the cost for the regions with color.

100
00:07:52,200 --> 00:07:56,720
And so, again, if you have, for example, a
diagonal line, then if you had that in an image,

101
00:07:56,720 --> 00:07:59,960
you would have to pay the cost of drawing
all those transparent pixels to the screen,

102
00:07:59,960 --> 00:08:04,910
because the GPU doesn't know what's transparent
and what isn't; whereas, with the shape layer,

103
00:08:04,910 --> 00:08:09,910
if you had that line stored as a path, we know exactly
where the color is, and we can just slam down those pixels

104
00:08:09,910 --> 00:08:12,110
that are colored and ignore everything else.

105
00:08:12,110 --> 00:08:15,730
And so, in summary, we really think
this can be really useful,

106
00:08:15,730 --> 00:08:17,970
but you have to be judicious about
where you actually use it.

107
00:08:17,970 --> 00:08:21,750
And, typically, you only need to really
use it when you want to take advantage

108
00:08:21,750 --> 00:08:25,100
of the features of this scalable/animatable content.

109
00:08:25,100 --> 00:08:29,270
And, typically, it's best in a few semi-large elements.

110
00:08:29,270 --> 00:08:33,240
Again, if you have thousands of these
things, you may run into issues.

111
00:08:33,240 --> 00:08:37,310
So, again, I want to run into a quick demo of this.

112
00:08:37,310 --> 00:08:44,310
So, really, what we have here, again, some number of layers
created, and we can up the number to whatever we want.

113
00:08:44,310 --> 00:08:49,770
And then each of these layers is a shape layer, and you
can see that it's animating between two arrow shapes.

114
00:08:49,770 --> 00:08:53,850
And so this is trying to show the first
of those or the second of those points,

115
00:08:53,850 --> 00:08:59,660
which is that shapes can be animating; whereas, you can see
that if you had an image, you really wouldn't have any way

116
00:08:59,660 --> 00:09:06,680
to do this without redrawing those arrows every frame;
whereas, now we can just have two paths representing arrows,

117
00:09:06,680 --> 00:09:10,420
and let Core Animation sublay between them as it can.

118
00:09:10,420 --> 00:09:15,560
And just to show you the second nice feature about
the shape layer, which is that it's scalable.

119
00:09:15,560 --> 00:09:21,750
If I apply a scale transform to the common container
of this layer-- oops, trying to get this to work.

120
00:09:21,750 --> 00:09:23,850
Here we go.

121
00:09:23,850 --> 00:09:28,140
Hopefully, you can see that, even though we
scaled in, we didn't lose any resolution.

122
00:09:28,140 --> 00:09:33,810
We're staying perfectly sharp on the arrow points, and
it's still animating at a fairly decent frame rate.

123
00:09:33,810 --> 00:09:37,460
And, obviously, we're only paying the cost
to render the bits you can actually see,

124
00:09:37,460 --> 00:09:43,390
so it really doesn't make a whole lot of difference
that we now have these things massively huge.

125
00:09:43,390 --> 00:09:45,740
So, again, I want to just go through the code quickly.

126
00:09:45,740 --> 00:09:49,290
So, first of all, we're going to
create the two paths for each layer.

127
00:09:49,290 --> 00:09:56,190
In this case, we have some function which just creates an
arrow of random shape, using a number of random numbers.

128
00:09:56,190 --> 00:10:02,220
Just for convenience, we're going to use, get the
bounding boxes of each path, and you need them together,

129
00:10:02,220 --> 00:10:08,800
so we have one rectangle which represents
the overall bounding rec of those paths.

130
00:10:08,800 --> 00:10:12,810
And then we're going to create a shape layer,
whose fill color is set to some random color,

131
00:10:12,810 --> 00:10:18,430
whose position is somewhere on the screen, and then
whose bounds is the bounding path rate that we computed.

132
00:10:18,430 --> 00:10:24,000
And then to set up the actual path, you can see
we didn't bother setting the layer path property

133
00:10:24,000 --> 00:10:25,740
at all, because we're going to animate that.

134
00:10:25,740 --> 00:10:32,360
So, we create a basic animation, which gives us that
from-to behavior and targeting the path property,

135
00:10:32,360 --> 00:10:37,360
and then we set the from and to values of the
animation to be these two paths we created.

136
00:10:37,360 --> 00:10:42,970
And, obviously, animations often work on numbers, but, in
general, they can be anything that can be interpolated,

137
00:10:42,970 --> 00:10:47,560
and we know that we can interpolate
between two CG path objects.

138
00:10:47,560 --> 00:10:50,910
And so once we have that, we just set some
common timing properties, give it a duration,

139
00:10:50,910 --> 00:10:54,690
give it some kind of these, set it
to pulse back and forth forever.

140
00:10:54,690 --> 00:10:57,370
And then finally we just add that to the sublayer.

141
00:10:57,370 --> 00:11:00,990
We're not going to specify a key, because
we don't ever want to reference this again,

142
00:11:00,990 --> 00:11:02,820
so we just let it sit on the layer forever.

143
00:11:02,820 --> 00:11:08,740
And so you can see we did that 20 times,
or whatever, and got those pulsing arrows.

144
00:11:08,740 --> 00:11:14,030
One of the things we found, when developing the iPad, in
particular, with its larger screen and more complex content,

145
00:11:14,030 --> 00:11:19,440
is that when you have a lot of things animating
around the screen at once, that puts a lot of strain

146
00:11:19,440 --> 00:11:27,320
on the compositing system, because if something is moving,
even if you have actually, where you're only moving one

147
00:11:27,320 --> 00:11:34,770
of those layers, but it has like 100 sublayers, like
some kind of view hierarchy of table view or whatever,

148
00:11:34,770 --> 00:11:36,790
then you don't just pay the cost for moving the one thing.

149
00:11:36,790 --> 00:11:40,680
Obviously, you have to rerender all of those
things, and it's a complex rendering tree.

150
00:11:40,680 --> 00:11:43,780
Then that can be an expensive task,
which can take enough time

151
00:11:43,780 --> 00:11:48,550
that you've dropped 60 frames per second,
from the nice smooth behavior we want.

152
00:11:48,550 --> 00:11:55,130
So, we've added a new feature for the iPhone OS 3.2,
for the iPad in later releases, where you can now ask us

153
00:11:55,130 --> 00:12:01,630
to basically take a subtree of a layer and all its
sublayers, and you can ask us to basically cache

154
00:12:01,630 --> 00:12:06,600
that in a bitmap on the render tree side.

155
00:12:06,600 --> 00:12:10,230
So, to do that, you really just
set this shouldRasterize property.

156
00:12:10,230 --> 00:12:13,390
And what this is telling us is
that you're asking us to convert

157
00:12:13,390 --> 00:12:18,610
that layer tree into an image every time we render it.

158
00:12:18,610 --> 00:12:20,350
And so that's kind of a flattening act.

159
00:12:20,350 --> 00:12:23,590
It's taking this tree and converting it to just one bitmap.

160
00:12:23,590 --> 00:12:31,630
And then the beneficiality of that-- if that's a word--
is that we can then reuse that bitmap whenever we can.

161
00:12:31,630 --> 00:12:38,350
So, we create this bitmap, and, ideally, the thing you asked
us to rasterize with a cache won't be changing from frame

162
00:12:38,350 --> 00:12:43,030
to frame to frame, so in that case, we rendered it a
previous time into a bitmap, and then we can just use

163
00:12:43,030 --> 00:12:46,350
that bitmap again and again to
stamp it into subsequent frames.

164
00:12:46,350 --> 00:12:52,330
Obviously, if we can do that, if we can get some
reuse, then we can avoid a lot of that extra rendering,

165
00:12:52,330 --> 00:12:55,740
where we can get much better animation performances.

166
00:12:55,740 --> 00:12:59,760
So, I wanted to show kind of a diagrammatic
example of what I'm talking about,

167
00:12:59,760 --> 00:13:01,650
because it may not be immediately obvious.

168
00:13:01,650 --> 00:13:04,730
So, if you think about a very simple
layer tree we have here,

169
00:13:04,730 --> 00:13:07,950
we have a background color, a layer with a background color.

170
00:13:07,950 --> 00:13:12,400
It has two sublayers, an image, and some text, and
then all of that is parented into another layer,

171
00:13:12,400 --> 00:13:15,720
which is setting some kind of 50 percent scaling matrix.

172
00:13:15,720 --> 00:13:21,850
So, if we don't have any of this caching stuff, and we add
that layer tree to our view, then what's going to happen

173
00:13:21,850 --> 00:13:23,420
when it renders is that each of those three layers

174
00:13:23,420 --> 00:13:25,830
that actually provide content are
going to render one after the other.

175
00:13:25,830 --> 00:13:30,740
So, they render into the frame buffer one,
first the color, then the image, then the text.

176
00:13:30,740 --> 00:13:33,040
Then you can see that-- well, you
can't see, but I'm going to tell you--

177
00:13:33,040 --> 00:13:36,120
they rate it at 50 percent resolution
here, because there is the scaling.

178
00:13:36,120 --> 00:13:39,620
So, they didn't render at 100 percent and scale.

179
00:13:39,620 --> 00:13:43,000
They just rendered directly into the screen.

180
00:13:43,000 --> 00:13:48,120
Now, if I set this middle layer to
say rasterize, then, implicitly,

181
00:13:48,120 --> 00:13:52,210
what you're asking us to do is create a second
buffer here, so we now have the frame buffer,

182
00:13:52,210 --> 00:13:56,980
and we have this caching buffer, which is going
to start to hold everything in that subtree.

183
00:13:56,980 --> 00:13:59,400
So, now you can imagine what's going
to happen when I render this again.

184
00:13:59,400 --> 00:14:03,680
Instead of rendering to the screen, we're going to
render those three things again into the caching buffer,

185
00:14:03,680 --> 00:14:08,040
but this time, hopefully, you can see they're a lot larger,
because they're actually rendering at the native resolution

186
00:14:08,040 --> 00:14:13,160
of the layer, instead of through that transfer
matrix, because we're just caching that subtree.

187
00:14:13,160 --> 00:14:16,800
And so, obviously, once we have
that cached, we then can use--

188
00:14:16,800 --> 00:14:20,680
the rendering system will take that and just
copy it to the screen through the actual matrix,

189
00:14:20,680 --> 00:14:23,480
and we end up the same place we were before.

190
00:14:23,480 --> 00:14:27,890
Of course, the nice thing is that we've done
that once, but if we need to render that again,

191
00:14:27,890 --> 00:14:29,940
then we don't have to go back to the layer tree.

192
00:14:29,940 --> 00:14:33,060
We can just take the cache buffer and
just copy it straight to the frame buffer.

193
00:14:33,060 --> 00:14:35,290
We don't have to render the layer tree.

194
00:14:35,290 --> 00:14:41,760
That's, obviously, in this case, only three items, but if
there was 3,000, we could get a huge performance win there,

195
00:14:41,760 --> 00:14:45,190
because we just skipped all of that work.

196
00:14:45,190 --> 00:14:51,820
And, again, another example of why this helps you is,
imagine that you change the scaling matrix from 50 percent

197
00:14:51,820 --> 00:14:55,900
to 25 percent, and probably we
would create an animation to animate

198
00:14:55,900 --> 00:14:59,560
that scale change, and so now we have this thing cached.

199
00:14:59,560 --> 00:15:05,440
Again, we can just go, and every frame of that animation can
be rendering out of the cache, and just take a single kind

200
00:15:05,440 --> 00:15:08,920
of imaging operation to take the
cache version to the screen.

201
00:15:08,920 --> 00:15:13,330
So, hopefully, you can see that this really
can make a big difference in certain cases.

202
00:15:13,330 --> 00:15:15,490
So, again, I'm going to show a demo of that now.

203
00:15:15,490 --> 00:15:18,190
What we have here is yet another shape layer.

204
00:15:18,190 --> 00:15:19,690
This one is much more complex.

205
00:15:19,690 --> 00:15:26,720
So, this is actually from an SVG, and
it has about 300 path segments, I think.

206
00:15:26,720 --> 00:15:32,010
So, you can see we can render one of these things
at approaching frame rate, but I'll add a few more,

207
00:15:32,010 --> 00:15:35,740
and the performance is getting pretty shoddy.

208
00:15:35,740 --> 00:15:38,620
Add a few more, and we're chunking along.

209
00:15:38,620 --> 00:15:42,190
And, obviously, I can prove that there's
still shape layers, because when I zoom in,

210
00:15:42,190 --> 00:15:45,870
you can see all the detail there, and there's no pixilation.

211
00:15:45,870 --> 00:15:51,440
So, go back to the zoom back state, and what I'm going to
do is I'm just going to set that shouldRasterize property

212
00:15:51,440 --> 00:15:58,080
on each of these shape layers, each of the
butterfly layers, and go-- oops, twice.

213
00:15:58,080 --> 00:16:01,140
So, you can see that when I do that, it just--

214
00:16:01,140 --> 00:16:04,310
the butterflies get cached in the bitmap
instead of rendering to the screen every time.

215
00:16:04,310 --> 00:16:08,020
We get this nice, beautifully smooth animation.

216
00:16:08,020 --> 00:16:14,470
Of course, the problem with this is that, although it's
nice and smooth, we've lost one of the good features

217
00:16:14,470 --> 00:16:17,860
of the shape layer, which is, now, when we
zoom in, I don't know if you can see that,

218
00:16:17,860 --> 00:16:20,590
but now everything is pixilated, because we asked the cache.

219
00:16:20,590 --> 00:16:25,700
And so now what we're doing is, instead of
rasterizing the shape, we're scaling the bitmap.

220
00:16:25,700 --> 00:16:27,300
There are ways to work around this.

221
00:16:27,300 --> 00:16:31,910
There's another property called rasterization scale,
where you can ask the cache version to be cache

222
00:16:31,910 --> 00:16:36,010
to the 7th scale factor, but for
now we're just going to ignore that.

223
00:16:36,010 --> 00:16:42,810
So, I just want to talk a little bit more
about why you shouldn't use this now.

224
00:16:42,810 --> 00:16:46,480
So, it looks great, and it can
be really useful, in some cases,

225
00:16:46,480 --> 00:16:49,710
but you have to be really careful with
this API we've been talking about.

226
00:16:49,710 --> 00:16:54,590
Firstly, a lot of these devices don't have a
huge amount of memory, so, thusly, any caching,

227
00:16:54,590 --> 00:16:57,650
any things you are caching are
taking memory from something else.

228
00:16:57,650 --> 00:17:00,940
Bitmaps can be large, especially on larger screen devices.

229
00:17:00,940 --> 00:17:06,690
Also, obviously, the caches are fixed size,
so, once you ask too many things to be cached,

230
00:17:06,690 --> 00:17:13,400
then some of those won't fit, and
you won't get the benefits.

231
00:17:13,400 --> 00:17:17,800
If you ask us to cache, but then are unable
to get the reuse, then that's actually worse

232
00:17:17,800 --> 00:17:20,400
than if you hadn't asked us to cache at all.

233
00:17:20,400 --> 00:17:25,760
And the reason for that is that the rasterize
properties, it's kind of an API contract.

234
00:17:25,760 --> 00:17:31,710
You're asking us to always convert it to a bitmap, because
that has some side effects, like these pixilation effects.

235
00:17:31,710 --> 00:17:37,080
And so we really need to always use the same
results, no matter what the other circumstances are.

236
00:17:37,080 --> 00:17:41,790
So, for example, if you ask us to cache 1,000 layers, and
then there are only ten of them that can be used from frame

237
00:17:41,790 --> 00:17:46,860
to frame, then the other 990 will be
rendered into a buffer and then rendered

238
00:17:46,860 --> 00:17:50,930
to the screen every frame, and that can be pretty expensive.

239
00:17:50,930 --> 00:17:55,880
Also, as we saw, rasterization locks the scale down.

240
00:17:55,880 --> 00:18:02,080
And one last point, which is a little
more esoteric, but people have run into it,

241
00:18:02,080 --> 00:18:06,050
which is the rasterization or the
caching happens at a very precise point

242
00:18:06,050 --> 00:18:09,120
in this kind of pipeline of rendering operations.

243
00:18:09,120 --> 00:18:14,450
Really, what we're doing is we're taking the
layer, and all its sublayers, and its contents,

244
00:18:14,450 --> 00:18:20,250
and copying that to an image, and then taking that
kind of thing and stamping it into its parent.

245
00:18:20,250 --> 00:18:23,200
And the act of compositing it into
its parent is another step

246
00:18:23,200 --> 00:18:26,210
in the rendering process, and that's where masking happens.

247
00:18:26,210 --> 00:18:31,210
So, if you have a mask layer applied to a
layer, it's going to put a nice shape around it.

248
00:18:31,210 --> 00:18:36,310
Then that is going to be working on the cache
version, and so the masking operation itself,

249
00:18:36,310 --> 00:18:40,410
which is also fairly expensive, will not get
any benefit from the caching, at that point.

250
00:18:40,410 --> 00:18:43,520
So, obviously, if you want to deal
with that, you can just turn on caching

251
00:18:43,520 --> 00:18:47,010
on the sublayer, and, hopefully, that'll solve it.

252
00:18:47,010 --> 00:18:54,470
Okay, so one UA guide for iPhone iOS 4, I should
say, is something to do with keyframe animation.

253
00:18:54,470 --> 00:18:56,880
So, let's talk about that.

254
00:18:56,880 --> 00:19:01,970
So, as you may have seen in the previous Core
Animation talk, keyframe animations are another type

255
00:19:01,970 --> 00:19:08,560
of animation object, which instead of just moving
between two points, they move value between endpoints.

256
00:19:08,560 --> 00:19:14,440
So, for example, in this case, we have four points,
and we're moving some point up, down, whatever.

257
00:19:14,440 --> 00:19:16,280
But you can see here the lines are very straight.

258
00:19:16,280 --> 00:19:19,560
There's no curves, so it might be okay
for what you want, but, typically,

259
00:19:19,560 --> 00:19:23,290
you want a more natural kind of animation movement.

260
00:19:23,290 --> 00:19:29,370
And you can do that with the previous set of APIs, but
it's fairly tricky in that you need to either create a set

261
00:19:29,370 --> 00:19:32,310
of timing functions to apply to
each segment, or use a Bezier path.

262
00:19:32,310 --> 00:19:37,650
And in both those cases, you have to be very careful
to preserve continuity through the transition points.

263
00:19:37,650 --> 00:19:42,390
You have to make sure the tangents of
each side line up and all that stuff.

264
00:19:42,390 --> 00:19:47,210
So, we've added a new feature, which is basically
what we call a new calculation mode for the animation,

265
00:19:47,210 --> 00:19:50,010
and a calculation mode is just how we do the interpolation.

266
00:19:50,010 --> 00:19:55,900
So, whereas, before we were using a linear
calculation mode, we've added a new one called Cubic.

267
00:19:55,900 --> 00:20:01,490
And most of you probably know, a Cubic interpolation is not
just looking at two points to get the interpolated point.

268
00:20:01,490 --> 00:20:03,770
It looks at the surrounding points, as well.

269
00:20:03,770 --> 00:20:07,260
Because of that, it preserves the
continuity through the points.

270
00:20:07,260 --> 00:20:13,160
So, when I set that, instead of having this
flat, angular curve, we get this fairly similar,

271
00:20:13,160 --> 00:20:16,790
but now we have the transitions are a lot smoother.

272
00:20:16,790 --> 00:20:24,210
And so this is actually using something called a Catmull-Rom
spline to fit those points, but there is a fair amount

273
00:20:24,210 --> 00:20:30,000
of customizability here, and there's three other properties
on the animation core, the tension, continuity, and bias,

274
00:20:30,000 --> 00:20:36,270
which just let you kind of yank the tangents a little
more, but without ever giving you the possibility

275
00:20:36,270 --> 00:20:41,970
that you're going to lose that continuity,
at least unless you really want to.

276
00:20:41,970 --> 00:20:45,950
So, it's a very quick thing, and,
hopefully, it's very easy to use.

277
00:20:45,950 --> 00:20:51,090
It should just-- if you need to use it,
hopefully, it'll make things a lot easier.

278
00:20:51,090 --> 00:20:57,510
So, another animation topic, which I guess Michael
touched on earlier, but I wanted to talk about, too,

279
00:20:57,510 --> 00:21:01,990
when you apply a rotation animation,
there are really two ways to do that.

280
00:21:01,990 --> 00:21:07,440
You can either use the transform property-- and,
obviously, in that case, you're interpolating matrices,

281
00:21:07,440 --> 00:21:15,070
which means that to represent angles, the angle is a
modulo one ton, because that's just what matrices do.

282
00:21:15,070 --> 00:21:21,590
Or you can use this other subproperty called
rotation.z and then interpolate that as a 1d value.

283
00:21:21,590 --> 00:21:28,590
That avoids this kind of modulation issue, modulo
issue, because you're going to animate your angles, say,

284
00:21:28,590 --> 00:21:37,780
from 0 to 720 degrees, but you have a whole other set of
issues to deal with, which are this Euler angle problem.

285
00:21:37,780 --> 00:21:41,790
And so what you're really asking us to do here
is take the matrix, the transform property,

286
00:21:41,790 --> 00:21:46,770
and extract the three Euler angles for
that matrix, and then interpolate those.

287
00:21:46,770 --> 00:21:52,730
And the problem with that is that it works fairly
well, if you're only animating one of them.

288
00:21:52,730 --> 00:21:57,510
But once you start touching multiple of these Euler
angles, like you want to do a y animation and a z,

289
00:21:57,510 --> 00:22:03,000
then you get into a whole world of pain, I guess,
because these things really don't concatenate nicely.

290
00:22:03,000 --> 00:22:06,950
You can get gimbal lock issues,
where they align to the same plane.

291
00:22:06,950 --> 00:22:14,230
And it can be a nasty issue, so what we've had
to, I guess, a couple of releases ago, now,

292
00:22:14,230 --> 00:22:20,380
is a new value function property, and the value
function is really just a way to apply a function

293
00:22:20,380 --> 00:22:23,220
to the interpolate to get the value we set on the property.

294
00:22:23,220 --> 00:22:28,060
And so, obviously, you know, the
interpolant is what we're interpolating,

295
00:22:28,060 --> 00:22:31,990
and so we want to think about that
for this rotation problem.

296
00:22:31,990 --> 00:22:35,160
Then what we're going to do is like
the Euler angle rotate animation.

297
00:22:35,160 --> 00:22:40,740
We're going to interpolate a 1d
value between 0 and 2 pi or 0 360.

298
00:22:40,740 --> 00:22:47,910
But we're going to set that to the transform property of
the layer, which, as you know, is a matrix, not a 1d value.

299
00:22:47,910 --> 00:22:53,540
So, we have to apply this makeRotationMatrix
function to turn that 1d value into the matrix.

300
00:22:53,540 --> 00:22:57,840
But, hopefully, you can see that by doing this we've
avoided all these problems with the previous two methods

301
00:22:57,840 --> 00:23:00,710
of doing this, which are we can represent any angles.

302
00:23:00,710 --> 00:23:05,070
We get complete control over how the
interpolation happens through those angles,

303
00:23:05,070 --> 00:23:08,470
and we don't have to worry about any of those Euler angles.

304
00:23:08,470 --> 00:23:15,150
So, if you have two animations, both setting the
transform property and with the additive mode set,

305
00:23:15,150 --> 00:23:19,650
then they will animate correctly, and
you should get exactly what you wanted.

306
00:23:19,650 --> 00:23:22,520
So, again, just a really quick
example of what this looks like.

307
00:23:22,520 --> 00:23:25,130
So, we create an animation for the transform.

308
00:23:25,130 --> 00:23:30,900
We set the two from and to values to be 0 2
pi, and then we just set the value function

309
00:23:30,900 --> 00:23:34,070
to be a instance of the CA/valueFunction class.

310
00:23:34,070 --> 00:23:38,590
And right now there's no way to create your own
functions, but we give you a bunch of useful ones.

311
00:23:38,590 --> 00:23:43,170
So, in this case, we want to have the function
which takes a single value and creates a matrix,

312
00:23:43,170 --> 00:23:48,120
which is a rotation of that z access,
which is normal to the rotation.

313
00:23:48,120 --> 00:23:53,410
So, when we get that, that's going to do what we saw on the
previous slide, and then finally we'll just set the duration

314
00:23:53,410 --> 00:23:57,530
at the animation of the layer, and off we go.

315
00:23:57,530 --> 00:24:07,040
So, one final animation point, which is, typically, you
often want to find when the animations have completed.

316
00:24:07,040 --> 00:24:11,730
You want to modify your layer tree at that
point, add new content, or remove them.

317
00:24:11,730 --> 00:24:14,000
You want to chain animations, in some cases.

318
00:24:14,000 --> 00:24:22,830
And then so previous to iOS 4 and Mac OS Snow Leopard, the
only way to do that was to create the animations explicitly,

319
00:24:22,830 --> 00:24:29,740
and then set the delegate property, and that works fine,
but often explicitly creating animations is more work

320
00:24:29,740 --> 00:24:33,310
than you have to do otherwise, because we
have all this implicit animation feature.

321
00:24:33,310 --> 00:24:42,330
So, we now have this other way of getting completion
callbacks, which are using the objective C block syntax.

322
00:24:42,330 --> 00:24:49,930
And so setting this transaction completion property
will tell us the runtime, that this is a block of code.

323
00:24:49,930 --> 00:24:54,790
And any animations I create from this point, I want you
to remember the block of code they're associated with.

324
00:24:54,790 --> 00:25:00,480
And then when all of those animations have completed, that's
when you fire off the block to run on the main thread,

325
00:25:00,480 --> 00:25:03,600
and it gets to do whatever completion work it needs to do.

326
00:25:03,600 --> 00:25:10,350
So, a lot less typing than creating explicit animation
subclasses, delegates, and all that kind of thing.

327
00:25:10,350 --> 00:25:18,240
So, again, in this example, we created a block, and then we
just set these two properties, capacity and position, and,

328
00:25:18,240 --> 00:25:21,630
obviously, what we're trying to do here
is we're ramping down the capacity to 0

329
00:25:21,630 --> 00:25:24,660
and moving this layer somewhere far over to the right.

330
00:25:24,660 --> 00:25:27,870
So, you can probably guess we're
trying to move this thing offscreen.

331
00:25:27,870 --> 00:25:30,890
So, then, when the block runs that we set up
earlier, it's just going to remove the layer

332
00:25:30,890 --> 00:25:33,920
and then, presumably, do some other cleanup work.

333
00:25:33,920 --> 00:25:40,570
And that's a nice way to animate some types of things,
where you don't need to do this work afterwards.

334
00:25:40,570 --> 00:25:46,460
But implicit animations are totally
enough for what you need to do.

335
00:25:46,460 --> 00:25:50,910
Okay. So, that's really all the API mixture.

336
00:25:50,910 --> 00:25:57,440
So, just in summary, I think the most important
point to this section, if you're going to do shadows

337
00:25:57,440 --> 00:26:04,430
on the embedded iPhone platform devices,
things, then you really must use the shadowPath.

338
00:26:04,430 --> 00:26:07,410
Just not setting that is really
not acceptable to performance.

339
00:26:07,410 --> 00:26:11,640
I would say putting 100 times that over 100
would never be good enough for what you want.

340
00:26:11,640 --> 00:26:15,200
So, you really do need to set the shadowPath.

341
00:26:15,200 --> 00:26:22,600
Secondly, CAShapeLayer, although not useful for everything,
in some cases, can really save you, because it works,

342
00:26:22,600 --> 00:26:27,850
gets around all these limitations of bitmaps, and
the performance is really good enough to have a few

343
00:26:27,850 --> 00:26:32,170
of these things running around, as we saw,
and getting you this nice rendering quality.

344
00:26:32,170 --> 00:26:39,180
And then, finally, think about if you're
coding up some kind of animated UI,

345
00:26:39,180 --> 00:26:44,970
and the performance really isn't good enough, then using the
shouldRasterize property to try and get some kind of caching

346
00:26:44,970 --> 00:26:49,340
out of it is often a really good way to improve performance.

347
00:26:49,340 --> 00:26:54,620
But I must stress, like I said, it's
really a last resort kind of feature

348
00:26:54,620 --> 00:26:57,720
in that you don't want to do it unless you really have to.

349
00:26:57,720 --> 00:27:03,110
Okay. So, the next thing I want
to talk about is performance.

350
00:27:03,110 --> 00:27:10,340
Specifically, I want to build up a
picture of how to think about performance

351
00:27:10,340 --> 00:27:13,080
of graphics rendering on the iPhone and the Mac.

352
00:27:13,080 --> 00:27:17,890
I'll mostly focus on the iPhone, although all of
this stuff is really applicable to both platforms.

353
00:27:17,890 --> 00:27:20,090
So, the first question you really
want to ask is we're going to build

354
00:27:20,090 --> 00:27:22,690
up from the bottom, up from the hardware through to the API.

355
00:27:22,690 --> 00:27:24,960
And so the question is what do GPUs do?

356
00:27:24,960 --> 00:27:28,320
A GP obviously being a graphics
card or a graphics processor.

357
00:27:28,320 --> 00:27:30,940
And so you may have seen this kind of diagram before.

358
00:27:30,940 --> 00:27:36,050
This is like one way we program the GPU, and
this is not really what I'm talking about.

359
00:27:36,050 --> 00:27:37,290
We really don't care about this.

360
00:27:37,290 --> 00:27:39,150
This is for open GL programmers.

361
00:27:39,150 --> 00:27:43,670
And we're really program at a much
different level than this.

362
00:27:43,670 --> 00:27:47,060
We don't deal with lots of vertices.

363
00:27:47,060 --> 00:27:50,200
So, we're really just thinking about triangles.

364
00:27:50,200 --> 00:27:55,560
So, let's get rid of that, and let's think about GPUs.

365
00:27:55,560 --> 00:28:00,800
In our eyes, the GPU is really just the
device to compare triangles to pixels.

366
00:28:00,800 --> 00:28:04,530
Obviously, the pixels live in a frame
buffer, a piece of memory somewhere.

367
00:28:04,530 --> 00:28:06,610
And so we have multiple types of triangles.

368
00:28:06,610 --> 00:28:09,730
Firstly, we can have a triangle with a color.

369
00:28:09,730 --> 00:28:10,280
You can see that.

370
00:28:10,280 --> 00:28:17,480
We can have triangles with an image, and
we can have triangles that aren't opaque,

371
00:28:17,480 --> 00:28:20,260
so they need to be composited with what's beneath them.

372
00:28:20,260 --> 00:28:25,970
The interesting point there, from a performance standpoint,
at least, is that the first two were both opaque,

373
00:28:25,970 --> 00:28:31,300
so they really don't care what's beneath them, and they
can just write that color directly into the frame of them;

374
00:28:31,300 --> 00:28:36,840
whereas, the second one, the non-opaque one really
needs to do some math to compute the final pixel.

375
00:28:36,840 --> 00:28:43,370
So, it's going to look at what's underneath it, do some
kind of plus, multiply thing, and then write that back in.

376
00:28:43,370 --> 00:28:48,550
So, already we can see that blended
triangles have more performance,

377
00:28:48,550 --> 00:28:52,380
more GPU cycles required for them than opaque triangles.

378
00:28:52,380 --> 00:28:55,200
So, that's very useful if you're
thinking about your UI, right?

379
00:28:55,200 --> 00:29:01,850
And then, finally, one other thing to think about is
that we're not just talking about one memory buffer.

380
00:29:01,850 --> 00:29:07,930
We can draw triangles into a piece of memory and then use
that as the source image to apply to another triangle.

381
00:29:07,930 --> 00:29:14,430
And so you can see here, I took the content I previously
rendered and mapped it across some other set of vertices.

382
00:29:14,430 --> 00:29:16,870
That's really all we can talk about for the GPU.

383
00:29:16,870 --> 00:29:22,020
So, the question then becomes how
do we take your view hierarchy,

384
00:29:22,020 --> 00:29:24,470
and how do we map that onto that set of primitives?

385
00:29:24,470 --> 00:29:29,090
The answer is really very simple, which is we
just take your layers and map them into triangles.

386
00:29:29,090 --> 00:29:34,660
So, this is an image I reused, so kind of
like triangles, but the idea is that each

387
00:29:34,660 --> 00:29:36,300
of these rectangles is really just two triangles.

388
00:29:36,300 --> 00:29:42,490
Obviously, you can split from one vertex,
split between opposite rectangle points

389
00:29:42,490 --> 00:29:45,580
and get two triangles out of each of these rectangles.

390
00:29:45,580 --> 00:29:48,350
So, specifically, your layer has a background color.

391
00:29:48,350 --> 00:29:50,550
Your view has a background color.

392
00:29:50,550 --> 00:29:55,380
Then we would draw two color triangles in that color
into the layer of the thing I was drawing it to.

393
00:29:55,380 --> 00:30:00,700
Similarly, if you have an image applied to the contents
of the layer, then we draw two triangles on an image, and,

394
00:30:00,700 --> 00:30:05,840
obviously, you can see, depending on the opacity of those
contents, we may have to turn blending on one of them.

395
00:30:05,840 --> 00:30:11,360
And then, again, more complex compositing effects will use
that other feature we talked about, which is render similar,

396
00:30:11,360 --> 00:30:16,260
render something similar, and then use that to
do some extra map, copy that back to the screen.

397
00:30:16,260 --> 00:30:17,650
And simply, we can do caching.

398
00:30:17,650 --> 00:30:22,870
We saw just before that when we cache something,
we render it into one buffer and then copy it back.

399
00:30:22,870 --> 00:30:26,500
And also things like masking filters, if you're on a Mac.

400
00:30:26,500 --> 00:30:28,030
All these things have to do extra work.

401
00:30:28,030 --> 00:30:30,220
They can't just render directly to the screen.

402
00:30:30,220 --> 00:30:36,580
It turns out that's a big deal for the GPU,
because it interrupts its flow of stream.

403
00:30:36,580 --> 00:30:40,790
You can think of the GPU like an oil tanker.

404
00:30:40,790 --> 00:30:43,610
It's moving along, and if you need to
stop it and point it somewhere else,

405
00:30:43,610 --> 00:30:48,260
it's a big operation that takes a lot of time.

406
00:30:48,260 --> 00:30:50,220
So, one more thing.

407
00:30:50,220 --> 00:30:55,600
Obviously, we, at the Core Animation
level, we don't even bother sending content

408
00:30:55,600 --> 00:30:58,300
to the screen that's colored by opaque regions, typically.

409
00:30:58,300 --> 00:31:02,540
Again, if you're thinking about performance, you
need to know that, because you really just need

410
00:31:02,540 --> 00:31:05,690
to look at the visible areas of your app.

411
00:31:05,690 --> 00:31:11,890
For example, your application on the iPhone is sitting
on top of Springboard icons, probably, the hump screen.

412
00:31:11,890 --> 00:31:16,300
And if we didn't do this, then that would
contribute to the performance of your application.

413
00:31:16,300 --> 00:31:20,650
But since we do, really, you can stop
thinking about what you have to care about,

414
00:31:20,650 --> 00:31:23,180
once you get down to that first opaque layer.

415
00:31:23,180 --> 00:31:27,560
Now we get to the interesting part, I guess, which
is, given that we know, roughly, what we're doing,

416
00:31:27,560 --> 00:31:33,510
at least to some very broad strokes, degree,
then what are the costs involved here?

417
00:31:33,510 --> 00:31:36,230
What are the expensive things we have to care about?

418
00:31:36,230 --> 00:31:38,510
So, we can break this down into three points.

419
00:31:38,510 --> 00:31:44,970
Basically, how many destination pixels are we going
to touch in the screen or the temporary frame buffer?

420
00:31:44,970 --> 00:31:48,160
How many pixels do we have to read to generate that content?

421
00:31:48,160 --> 00:31:50,910
So, obviously, we have triangles with images.

422
00:31:50,910 --> 00:31:56,390
We need to read so many triangles to generate
the destination pixel, so I read so many pixels.

423
00:31:56,390 --> 00:31:58,890
And then, finally, how many times do we switch buffers?

424
00:31:58,890 --> 00:32:01,960
And so we basically give these a name.

425
00:32:01,960 --> 00:32:05,110
We have write bandwidth, read bandwidth, which,
obviously, measures the memory bandwidth.

426
00:32:05,110 --> 00:32:08,320
We really just have to think of how many pixels, really.

427
00:32:08,320 --> 00:32:12,620
And then the big one is how many
times do we have to switch buffers?

428
00:32:12,620 --> 00:32:16,410
So, just a few quick examples of when you run into these.

429
00:32:16,410 --> 00:32:19,370
Firstly, we have too much non-opaque
content, then you probably will--

430
00:32:19,370 --> 00:32:25,290
your application will be limited by the amount of writing
the GPU has to do, the number of destination pixels it has

431
00:32:25,290 --> 00:32:33,770
to touch, because, obviously, translucent things have to be
drawn; whereas, the opaque things, they wouldn't have to be.

432
00:32:33,770 --> 00:32:37,410
Secondly, too many large images, then you're
probably going to be limited by the amount

433
00:32:37,410 --> 00:32:40,010
of data the GPU is having to read every frame.

434
00:32:40,010 --> 00:32:46,100
And then, again, if you have too many masking operations,
then the GPU will be switching between rendered targets,

435
00:32:46,100 --> 00:32:48,830
and the performance will get lost that way.

436
00:32:48,830 --> 00:32:55,060
Typically, what will happen is, at any one point, your
app will be bottlenecked behind one of these three points,

437
00:32:55,060 --> 00:32:59,180
and so you'll do some work, fix that, and when
your final is fast, but not quite fast enough,

438
00:32:59,180 --> 00:33:02,030
and then you have to switch and
look at one of these other points.

439
00:33:02,030 --> 00:33:08,640
So, at this point, I want to switch and try
and put some examples behind all this talk.

440
00:33:08,640 --> 00:33:13,960
And so what I have here is a sample application.

441
00:33:13,960 --> 00:33:18,010
This is available on the WWDC website.

442
00:33:18,010 --> 00:33:19,980
Hopefully, you'll be able to find it.

443
00:33:19,980 --> 00:33:23,770
It's called the Core Animation Image Browser.

444
00:33:23,770 --> 00:33:27,950
So, I'm just going to run it once,
so you can see what it does.

445
00:33:27,950 --> 00:33:34,490
I'm going to build it, compile it, and switch onto this, and
then we came up, and we had this kind of image browser app.

446
00:33:34,490 --> 00:33:39,430
And I could flick, and it scrolls slowly.

447
00:33:39,430 --> 00:33:40,850
The structure of this is pretty simple.

448
00:33:40,850 --> 00:33:42,440
We have a scroll view.

449
00:33:42,440 --> 00:33:49,920
We have view controller, and we have a subclass of the
scroll view, which kind of lays out these item layers,

450
00:33:49,920 --> 00:33:55,000
and each one of these is a view, but
it has a custom layer backing it.

451
00:33:55,000 --> 00:33:57,520
So, really, we're going to spend
a lot of time looking at how

452
00:33:57,520 --> 00:34:01,580
that item layer is implemented and
what we can do to make it faster.

453
00:34:01,580 --> 00:34:02,360
So, this is the app.

454
00:34:02,360 --> 00:34:06,460
I'm just going to give you a very quick run through.

455
00:34:06,460 --> 00:34:07,750
So, we have some code.

456
00:34:07,750 --> 00:34:09,590
We have a app delegate, a view controller.

457
00:34:09,590 --> 00:34:15,010
The view controller is really just taking
a bunch of URLs from the app bundle

458
00:34:15,010 --> 00:34:18,540
and then passing them on to the scroll view.

459
00:34:18,540 --> 00:34:29,880
The scroll view has a little bit of code to do this layout,
and so the layout method is really just, like I said,

460
00:34:29,880 --> 00:34:34,840
creating an item view for every image
that was given, image URL that was given,

461
00:34:34,840 --> 00:34:39,590
and then initializing the image
view, the item view, with the URL.

462
00:34:39,590 --> 00:34:41,850
And then it's going to add that to itself as a subview.

463
00:34:41,850 --> 00:34:45,190
There's some other stuff down here we'll talk about later.

464
00:34:45,190 --> 00:34:48,440
So, the item view is really simple.

465
00:34:48,440 --> 00:34:56,050
All that it does is it has an end method, but, more
importantly, it implements layer class to redirect the UIKit

466
00:34:56,050 --> 00:35:01,830
to be using another, our own layer
subclass as the backing of this view.

467
00:35:01,830 --> 00:35:03,190
We don't want to use CALayer.

468
00:35:03,190 --> 00:35:05,470
We want to use our own one with all its custom codes.

469
00:35:05,470 --> 00:35:09,530
We return our class from this method,
and that's what happens.

470
00:35:09,530 --> 00:35:12,540
And then when we initialize ourselves,
we just basically pass on the image URL

471
00:35:12,540 --> 00:35:16,410
into the layer that was created for us by UIKit.

472
00:35:16,410 --> 00:35:23,130
So, like I said, most of the code, in fact pretty
much all of it is in this image or item layer.

473
00:35:23,130 --> 00:35:27,430
And you can see it has a bunch of methods.

474
00:35:27,430 --> 00:35:30,450
And what do I want to talk about?

475
00:35:30,450 --> 00:35:36,120
Right. So, I guess the final point here is the-- obviously,
I don't have time to write code here, so I kind of cheated

476
00:35:36,120 --> 00:35:39,070
and added a header file with a bunch of
different options we can turn on or off.

477
00:35:39,070 --> 00:35:44,560
So, the first thing I want to do is I want to recompile
with this, using this thread option, enable it, because,

478
00:35:44,560 --> 00:35:48,260
as you saw, maybe this thing took
a really long time to start up,

479
00:35:48,260 --> 00:35:52,300
and we don't want to be waiting
for every time we test something.

480
00:35:52,300 --> 00:35:58,320
So, by setting this use image thread, all that's going
to do is we're going to create a background thread,

481
00:35:58,320 --> 00:36:02,520
and we're going to arrange for our images to be loaded
on the background thread and then set into the layer

482
00:36:02,520 --> 00:36:05,350
as they arrive, rather than just
doing it all at once ahead of time.

483
00:36:05,350 --> 00:36:11,420
And that's really not a Core Animation performance
thing, but it makes this a lot more usable.

484
00:36:11,420 --> 00:36:12,510
So, let's run it again.

485
00:36:12,510 --> 00:36:18,340
Okay, so now you can see that the images are
loading, as we go, and that's a lot better.

486
00:36:18,340 --> 00:36:22,960
But performance now is what we want to look
at, and performance here is really bad.

487
00:36:22,960 --> 00:36:30,690
So, the first thing we want to change here is
we want to look at how the shadows are drawn.

488
00:36:30,690 --> 00:36:37,110
You saw each of those items had a shadow, and I'm afraid
I did the thing I told you, you really shouldn't do,

489
00:36:37,110 --> 00:36:43,600
which is I basically just set up the shadow properties
in my init method, passed the radius offset,

490
00:36:43,600 --> 00:36:46,530
and then let it auto generate the shadows.

491
00:36:46,530 --> 00:36:48,620
That actually works pretty well in
the Simulator, but in the Simulator,

492
00:36:48,620 --> 00:36:50,950
we have a very fast CPU to do all that rendering for us.

493
00:36:50,950 --> 00:36:56,160
So, I'm going to go back to my options, and I'm going
to say, okay, let's use the shadowPath this time.

494
00:36:56,160 --> 00:37:07,760
And so, hopefully, when I rerun this, we'll see--
okay, so, see, we still have the same shadows, but,

495
00:37:07,760 --> 00:37:12,550
well, it's a little faster, not massively so.

496
00:37:12,550 --> 00:37:17,000
Okay, well, anyway, so we know we
still have work to do here, right?

497
00:37:17,000 --> 00:37:20,440
So, hopefully, you can see it's better.

498
00:37:20,440 --> 00:37:22,970
Now, the other thing I want to look at is the images.

499
00:37:22,970 --> 00:37:30,820
This is going to be really hard to make out, but the
other bad thing we did is we, when we loaded the images,

500
00:37:30,820 --> 00:37:35,310
we just took the CG image that UIKit
loaded for us, and we assigned it directly

501
00:37:35,310 --> 00:37:38,950
to the contents layer, because we can do that, and it works.

502
00:37:38,950 --> 00:37:41,530
And so here, what we have, nine images onscreen.

503
00:37:41,530 --> 00:37:46,620
These images are actually 1024 X 768, which is screen sized.

504
00:37:46,620 --> 00:37:52,380
So, you can imagine, when I composite this, I'm actually
asking the GPU to read nine times the screen size

505
00:37:52,380 --> 00:37:54,180
and the amount of image data which is quite a lot of memory.

506
00:37:54,180 --> 00:37:57,220
I guess this screen is roughly a megapixel.

507
00:37:57,220 --> 00:37:59,140
See, now that's nine million pixels.

508
00:37:59,140 --> 00:38:04,900
A really easy way to fix that, which is--
well, for me, I'm just going to turn on this,

509
00:38:04,900 --> 00:38:09,190
but [laughter] I'm going to tell
you what I actually did now.

510
00:38:09,190 --> 00:38:10,140
[laughter] So, right.

511
00:38:10,140 --> 00:38:17,890
So, instead of using the contents properties-- you can
see before what I was doing is getting the image up here,

512
00:38:17,890 --> 00:38:25,110
finish loading, and this is my didChangeValueForKey,
so when I set the image property, I want to pull that to the layer,

513
00:38:25,110 --> 00:38:30,160
so, in this case, before I was setting the contents
of the layer to be image that had been loaded,

514
00:38:30,160 --> 00:38:32,220
at this point, putting it on a backup thread.

515
00:38:32,220 --> 00:38:36,610
Then calling setNeedsLayout, just so I can update
the bounds and the shadow shape, basically.

516
00:38:36,610 --> 00:38:39,970
But, so, what I'm going to do is I'm not going
to set the layer contents to be the image,

517
00:38:39,970 --> 00:38:42,350
because that's how we get this nasty behavior,

518
00:38:42,350 --> 00:38:47,670
where we have all this image data being
downsampled on the fly of your frame.

519
00:38:47,670 --> 00:38:53,960
I'm going to tell it send this display, and at the same
time, I'm going to implement the drawer in context method.

520
00:38:53,960 --> 00:38:57,820
And so my draw in context is going to do a bit of work.

521
00:38:57,820 --> 00:39:01,230
First of all, I'm going to take advantage of
the fact that now that I'm actually drawing,

522
00:39:01,230 --> 00:39:07,990
I can get rid of the composited shadow entirely
by just asking core graphics to shut it for me.

523
00:39:07,990 --> 00:39:13,260
But, mainly, I'm going to fetch the image, and I'm going to
draw the image directly into the layer I've back in store.

524
00:39:13,260 --> 00:39:16,760
But, obviously, I'm going to draw it at
the size I want it, not the original size,

525
00:39:16,760 --> 00:39:21,590
so firstly I'm going to have Core Graphics do
that down sampling, which is going to get a much,

526
00:39:21,590 --> 00:39:28,560
much better result than having the GPU do it, because
this is kind of bread and butter for Core Graphics.

527
00:39:28,560 --> 00:39:35,900
And, secondly, obviously, when we come to draw, we
have prescaled content, which is not the right size,

528
00:39:35,900 --> 00:39:40,620
so we really, at that point, instead of
compositing 9 times the screen size of image data,

529
00:39:40,620 --> 00:39:43,740
which is going to have roughly screen size.

530
00:39:43,740 --> 00:39:47,350
So I think I flip that, so let's recompile again.

531
00:39:47,350 --> 00:39:53,120
Okay. So, firstly, if you're looking at this on
the actual device, you'd see it looks better,

532
00:39:53,120 --> 00:39:57,900
but immediately you see the performance
is way, way better now.

533
00:39:57,900 --> 00:40:02,880
And just by having the right amount of image data for the
right size screen, we can give the GPU the amount of work

534
00:40:02,880 --> 00:40:06,850
that it really likes to be doing, instead of way, way more.

535
00:40:06,850 --> 00:40:14,890
Okay. There's one more thing I think I should show you here.

536
00:40:14,890 --> 00:40:17,910
I need to restart this.

537
00:40:17,910 --> 00:40:20,560
So, I'm going to run-- I guess I should switch back.

538
00:40:20,560 --> 00:40:26,220
I'm going to run this, this time, using the same version of
the application, but I'm going to run it using instruments,

539
00:40:26,220 --> 00:40:30,440
specifically, the Core Animation instruments tool.

540
00:40:30,440 --> 00:40:32,500
So, this is messed up.

541
00:40:32,500 --> 00:40:35,150
Maybe I have to kill this.

542
00:40:35,150 --> 00:40:36,400
There we go.

543
00:40:36,400 --> 00:40:46,910
Right, so, you can see we have-- okay,
I have to-- I didn't rehearse this.

544
00:40:46,910 --> 00:40:53,090
So, anyway, what I wanted to turn on is this color
blended layer option, and I want to switch back.

545
00:40:53,090 --> 00:40:59,310
You can see that-- you can see I can't scroll for one thing.

546
00:40:59,310 --> 00:41:03,190
But, anyway, the point here is that
we're asking Core Animation to tell us

547
00:41:03,190 --> 00:41:06,480
where the opaque pixels, and where
are the non-opaque pixels?

548
00:41:06,480 --> 00:41:07,900
So, we can see this example.

549
00:41:07,900 --> 00:41:10,510
Obviously, the background is green, so that's good.

550
00:41:10,510 --> 00:41:11,550
That's opaque.

551
00:41:11,550 --> 00:41:14,660
But all these images are being
asked to composite every frame.

552
00:41:14,660 --> 00:41:17,530
And if you look at them, they're opaque, right?

553
00:41:17,530 --> 00:41:20,490
So, we really don't need to do that.

554
00:41:20,490 --> 00:41:25,820
We can just have them mark themselves as
opaque and get rid of the Alpha channel.

555
00:41:25,820 --> 00:41:28,180
In this case, they had a shadow,
as well, but we can cheat there.

556
00:41:28,180 --> 00:41:32,790
We can just draw white into the background of the
layer, because we know the background is white.

557
00:41:32,790 --> 00:41:37,740
So, I'm going to put that to the background.

558
00:41:37,740 --> 00:41:45,510
And so we have this other option, which is going to set
the-- I think it sets the-- I can't remember what it does,

559
00:41:45,510 --> 00:41:48,180
but it sets the opaque property of the layer.

560
00:41:48,180 --> 00:41:51,470
And you can see where it's saying here,
if our layer is opaque, when we draw it,

561
00:41:51,470 --> 00:41:55,770
we're just going to fill the background with white.

562
00:41:55,770 --> 00:42:03,790
And so I run this again, and, hopefully,
this time, it's going to be a lot greener.

563
00:42:03,790 --> 00:42:07,870
You probably won't see a difference in performance,
because we weren't really stressing that aspect of the GPU

564
00:42:07,870 --> 00:42:13,390
in this app, but this would be useful in
your other cases-- except I don't hit save.

565
00:42:13,390 --> 00:42:20,050
Okay. Okay, here we go.

566
00:42:20,050 --> 00:42:26,300
Okay, so now it's all green, and that basically
means that it's still scrolling really smoothly,

567
00:42:26,300 --> 00:42:31,030
and probably if I put a few more images in
here, it'll get smoother than it was before.

568
00:42:31,030 --> 00:42:34,830
And that's kind of what you want to look for, just
little tricks where you can minimize the amount

569
00:42:34,830 --> 00:42:39,610
of compositing that's going on
get the extra bit of performance.

570
00:42:39,610 --> 00:42:47,070
So, one last thing I wanted to show here is-- let's turn
off that color thing, first of all, while I remember.

571
00:42:47,070 --> 00:42:52,140
So, one final thing, which is a little similar,
but I wanted to show you another feature,

572
00:42:52,140 --> 00:42:58,650
another way of doing a common feature, which is after you
scroll, and you wanted to have a masked feathered edge

573
00:42:58,650 --> 00:43:04,100
in it, so I set this to 1, and then recompile.

574
00:43:04,100 --> 00:43:07,360
Then we'll see the app has changed a little
bit, which is near the top and bottom

575
00:43:07,360 --> 00:43:11,860
of the scroll layers, we have a feathered edge.

576
00:43:11,860 --> 00:43:16,930
Right. So, you can see it fading, right?

577
00:43:16,930 --> 00:43:20,280
I see this every now and then.

578
00:43:20,280 --> 00:43:22,800
And so you can also see where we
lost a bunch of performance now.

579
00:43:22,800 --> 00:43:23,890
It's back.

580
00:43:23,890 --> 00:43:31,910
It's not as bad as it was, but it's still, obviously,
chunky-ish, and so we want it to be as fast as it was,

581
00:43:31,910 --> 00:43:34,900
but let's, first of all, just look at what we did here.

582
00:43:34,900 --> 00:43:41,700
So, really, I turned on this stop edge layer, and this
is going to be added as the mask of the scroll view,

583
00:43:41,700 --> 00:43:49,750
because we want to take the user masking operation to
kind of just gradually clip out the edges of the scroll.

584
00:43:49,750 --> 00:43:54,810
And so what this does is, really, it's just
a layer, and it has a sublayers method,

585
00:43:54,810 --> 00:44:00,250
so that whenever its size changes,
it gets to reconfigure itself.

586
00:44:00,250 --> 00:44:05,900
And in this case, we're basically going to
create two layers-- I'm sorry, three layers.

587
00:44:05,900 --> 00:44:10,200
We're going to create two gradient layers, one
for each edge, so It's going to wrap from 0 to 1.

588
00:44:10,200 --> 00:44:12,260
And then we're just going to create
a solid line in the middle,

589
00:44:12,260 --> 00:44:16,510
and it'll just read a nice gradient,
which is going to ramp from 0 to 1.

590
00:44:16,510 --> 00:44:19,140
Sorry, 1 to-- 0 to 1, to 1, to 0.

591
00:44:19,140 --> 00:44:23,820
And you can see, when we set that as the mask
of the layer, we get the effect we wanted,

592
00:44:23,820 --> 00:44:29,860
because our mask kind of dissolves the
content and then applies it to the background.

593
00:44:29,860 --> 00:44:36,300
But as I was saying, the performance here wasn't
good enough, and that's because if I switch--

594
00:44:36,300 --> 00:44:41,530
let's see, if I switch on the color offscreen option,

595
00:44:41,530 --> 00:44:44,830
and then switch back to the app, you
can see the whole screen is yellow.

596
00:44:44,830 --> 00:44:51,200
And what that means is that we're basically
taking an extra offscreen rendering pass,

597
00:44:51,200 --> 00:44:56,410
which is that thing I showed you earlier, where
we draw a bunch of triangles into a buffer,

598
00:44:56,410 --> 00:44:58,770
and then use that as the source
for another drawing operation.

599
00:44:58,770 --> 00:45:05,590
And that's, you know, this whole kind of dependency chain
gets created, and it makes performance pretty nasty.

600
00:45:05,590 --> 00:45:09,420
So, another thing to look at, is you
want to get rid of this kind of thing.

601
00:45:09,420 --> 00:45:11,780
You want to basically eliminate all of this yellow.

602
00:45:11,780 --> 00:45:18,030
And just like before, with the shadows, I
could draw the shadows on a white background.

603
00:45:18,030 --> 00:45:23,580
Again, we know the scroller background here is white,
or at least it's static, and so I don't really need

604
00:45:23,580 --> 00:45:26,980
to be doing masking here, even though you
may think of this as a masking operation.

605
00:45:26,980 --> 00:45:31,600
I can turn this around and really just
composite a white gradent on the top and bottom

606
00:45:31,600 --> 00:45:33,920
of the scroller, and I get the same effect, right?

607
00:45:33,920 --> 00:45:41,130
So, I have another magic option,
which will-- oops-- do that for me.

608
00:45:42,780 --> 00:45:51,030
So, I switch this to 2, then what I'm going
to do now is-- if I find the right view--

609
00:45:51,030 --> 00:45:55,280
you can see I have this piece of code here,
which is setting up this subedge layer.

610
00:45:55,280 --> 00:46:00,180
So, if edges equals 1, I'm going to use the
mask, which is probably what we're doing.

611
00:46:00,180 --> 00:46:03,560
But, in this case, I'm just going to add this
as a sublayer of the top of the other thing,

612
00:46:03,560 --> 00:46:09,250
and then I have to make sure now that the gradient is
inverted, because before we wanted to mask off the edges.

613
00:46:09,250 --> 00:46:13,540
Now we want to cover them up, so we want the
opacity to be, basically, in the other places.

614
00:46:13,540 --> 00:46:18,630
So, whereas, before I was having
access to the gradient one way.

615
00:46:18,630 --> 00:46:23,160
I'm just going to flip it over and drop the layer
in the middle, because we no longer need it.

616
00:46:23,160 --> 00:46:26,670
So, let's run that.

617
00:46:28,440 --> 00:46:32,470
Yeah, I'm not going to make that mistake twice, maybe.

618
00:46:32,470 --> 00:46:38,320
So, I still have the color of the offscreen option
enabled, but you can see it's no longer firing,

619
00:46:38,320 --> 00:46:39,760
because we don't have any offscreen rendering.

620
00:46:39,760 --> 00:46:45,470
We just have two white gradients, one on the top, one
on the bottom, to cover up the pixels we want to hide.

621
00:46:45,470 --> 00:46:49,020
And, obviously, you can see the
performance is back where we want it to be.

622
00:46:49,020 --> 00:46:54,640
And just to prove, to maybe make it a little more obvious,
I'm going to turn back on the color blended layers option,

623
00:46:54,640 --> 00:46:56,780
and you can see exactly where these
gradients are now sitting.

624
00:46:56,780 --> 00:47:02,930
And, obviously, they have to be blended,
because they have an opacity ramp in them.

625
00:47:02,930 --> 00:47:09,310
Okay. [applause] Okay, so just
going to want to summarize this,

626
00:47:09,310 --> 00:47:15,260
go over these three things, talk
about what we were just saying.

627
00:47:15,260 --> 00:47:18,810
So, firstly, let's get rid of those blended layers.

628
00:47:18,810 --> 00:47:22,910
You need to minimize the number of alpha-blended
pixels to minimize the amount of write bandwidth.

629
00:47:22,910 --> 00:47:27,800
And there's two basic ways to-- first
of all, there's one way to see that,

630
00:47:27,800 --> 00:47:30,590
which is you turn on this color blended layer option.

631
00:47:30,590 --> 00:47:35,520
That's in instruments, and instruments
only works for the devices.

632
00:47:35,520 --> 00:47:41,220
And so if you're running on a Mac, or you're running on the
Simulator, you can't use instruments to turn these options

633
00:47:41,220 --> 00:47:44,670
on yet, so-- but what you can do
is you can set environ variables.

634
00:47:44,670 --> 00:47:49,650
And so, if you're running on the Mac, you can just
set this environ variable in your x code project

635
00:47:49,650 --> 00:47:52,440
and then run your application, and
you get exactly the same behavior.

636
00:47:52,440 --> 00:48:00,530
Or if you're running, say, the iPhone Simulator, then
you can set this environ when you run the Simulator.

637
00:48:00,530 --> 00:48:03,100
It's not particularly hard to do.

638
00:48:03,100 --> 00:48:07,190
You just have to make sure to run the Simulator
from the command line before you start x code,

639
00:48:07,190 --> 00:48:13,890
whatever environ variable set you want, and then when
your app comes up, it'll have all those things preset.

640
00:48:15,600 --> 00:48:22,190
So to get rid of the alpha channels, you need to make
sure that any image refs, which have opaque data,

641
00:48:22,190 --> 00:48:25,410
which include the ones we were looking at there, you
have to make sure they don't have an alpha channel,

642
00:48:25,410 --> 00:48:28,630
because the alpha channel is the way we are told to look at blending.

643
00:48:28,630 --> 00:48:31,800
We don't look at any properties of the layer.

644
00:48:31,800 --> 00:48:37,130
We just look at, does the contents
of the layer have an alpha channel?

645
00:48:37,130 --> 00:48:40,580
And so, if you're drawing into the layer,
obviously, you don't get to touch the CG image rep,

646
00:48:40,580 --> 00:48:45,720
because there problem isn't one, but you can set
this layer opaque property, which is going to tell us

647
00:48:45,720 --> 00:48:50,530
that when we create the bitmap here to draw
into, we don't create an alpha channel,

648
00:48:50,530 --> 00:48:56,520
and so it's kind of the same thing,
two ways of doing the same thing.

649
00:48:56,520 --> 00:49:04,040
And, finally, another point which is a little more
interesting is that, say you have an image, and it may have,

650
00:49:04,040 --> 00:49:08,180
say, a translucent border, but an opaque center.

651
00:49:08,180 --> 00:49:12,500
And what you'll probably do, to start with, is
have one image and just put it on the screen.

652
00:49:12,500 --> 00:49:17,960
But, obviously, since it has that non-opaque edge, you
have to have the whole thing have an alpha channel.

653
00:49:17,960 --> 00:49:21,520
And if the image is really large, compared to the border,

654
00:49:21,520 --> 00:49:25,370
then that can be pretty expensive,
in terms of compositing costs.

655
00:49:25,370 --> 00:49:30,320
So what you can do, in those cases, is you can
basically just cut up your artwork into multiple images.

656
00:49:30,320 --> 00:49:34,500
You could do strip at the top, strip
at the bottom, strip down each edge,

657
00:49:34,500 --> 00:49:38,640
and then you could have the center bit be
an opaque image, like a JPEG or something.

658
00:49:38,640 --> 00:49:44,050
And that will save you a lot of
performance, if your image is large.

659
00:49:44,050 --> 00:49:48,920
So, the read bandwidth is really, really
simple, which is just use images that,

660
00:49:48,920 --> 00:49:50,640
as much as possible, match the screen resolution.

661
00:49:50,640 --> 00:49:53,800
When I say images, I really mean bitmaps of any type.

662
00:49:53,800 --> 00:50:00,550
So, layers that draw exactly the same, when you draw
into them, they create a bitmap of the size of the layer,

663
00:50:00,550 --> 00:50:06,070
so you want to make sure you're drawing
them at the right size to match the screen.

664
00:50:06,070 --> 00:50:13,840
Yes, don't use megapixel images to create thumbnails,
because it doesn't look good, and it doesn't work well.

665
00:50:13,840 --> 00:50:18,400
And so, again, there is an option in
instruments for this, "Color Misaligned Images."

666
00:50:18,400 --> 00:50:21,960
This one is a little tricky to get to understand
correctly, because we've changed it recently.

667
00:50:21,960 --> 00:50:25,410
So, I'll try and explain what it does.

668
00:50:25,410 --> 00:50:28,280
If you are on iOS 4, then this will draw two colors.

669
00:50:28,280 --> 00:50:33,200
If you have an image which has just shifted a little bit,
maybe its edges aren't quite pixel lined, it'll draw pink.

670
00:50:33,200 --> 00:50:38,650
If you have an image which is scaled, which is really
what we're talking about here, then it'll draw yellow.

671
00:50:38,650 --> 00:50:43,170
On previous devices, I think there were
ways to draw pink for both those cases.

672
00:50:43,170 --> 00:50:50,100
So we really added that as one way to help you track down
low res content and a high DPI app, and things like that,

673
00:50:50,100 --> 00:50:54,770
so you can use it for find any general scale res.

674
00:50:54,770 --> 00:51:00,240
And then, again, rendering passes, this is really
often the most important thing to get right.

675
00:51:00,240 --> 00:51:05,320
And, typically, unless you're doing
very small offscreen things,

676
00:51:05,320 --> 00:51:09,060
you need to have only one rendering
pass per frame to get good performance.

677
00:51:09,060 --> 00:51:11,560
And so often, you really need to trick your way into that.

678
00:51:11,560 --> 00:51:15,950
You can't just set all this compositing
stuff up in the most obvious way.

679
00:51:15,950 --> 00:51:20,760
You really have to think about what you're doing and what
you really need, and just try and drive the number of passes

680
00:51:20,760 --> 00:51:27,560
down by turning on that thing--
that's not the bullet I was expecting.

681
00:51:27,560 --> 00:51:31,680
So, complex compositing, things like masking group opacity.

682
00:51:31,680 --> 00:51:33,400
In some cases, you have that enabled.

683
00:51:33,400 --> 00:51:36,360
And for those on the Mac, we'll all
require this offscreen rendering.

684
00:51:36,360 --> 00:51:40,510
And then I was about to say, use the
Color Offscreen Instruments option

685
00:51:40,510 --> 00:51:43,540
to basically show you wherever
you have this offscreen rendering.

686
00:51:43,540 --> 00:51:49,720
Obviously, this option controls the yellow tint
over your layers that are drawn over offscreen,

687
00:51:49,720 --> 00:51:53,290
and so you can see it gets-- if you have multiple
offscreen passes, it'll draw yellow, on top of yellow,

688
00:51:53,290 --> 00:51:55,490
on top of yellow, and so it gets darker and darker.

689
00:51:55,490 --> 00:52:00,160
So, that gives you a nice way just
to gauge exactly how bad it is.

690
00:52:00,160 --> 00:52:09,740
And then one final thing, the feature we talked about
earlier, this cached contents of layers and a bitmap,

691
00:52:09,740 --> 00:52:11,960
that is actually involving offscreen rendering itself.

692
00:52:11,960 --> 00:52:16,780
If you get it working correctly-- by which I mean you
actually get some cache reuse from frame to frame,

693
00:52:16,780 --> 00:52:24,080
because the contents of that cache subtree isn't
changing, there's not too much demand on the cache memory,

694
00:52:24,080 --> 00:52:27,050
then that can really hide those extra
rendering passes, because you can push them

695
00:52:27,050 --> 00:52:35,010
into that subtree that's been rendered once, and
then reuse just the image from frame to frame.

696
00:52:35,010 --> 00:52:39,490
Yes, but there is the caveat always, which you
really need to make sure it's working; otherwise,

697
00:52:39,490 --> 00:52:41,750
you could be making things worse for yourself.

698
00:52:41,750 --> 00:52:47,420
Okay, so one more slide on performance.

699
00:52:47,420 --> 00:52:50,940
So, to sum it all up, there's really a very
simple algorithm here to look for performance.

700
00:52:50,940 --> 00:52:54,630
Obviously, this involves all those color whatever options.

701
00:52:54,630 --> 00:52:58,930
But what you're really caring about, why
my frame rate isn't at 60 frames a second.

702
00:52:58,930 --> 00:53:06,470
Get rid of extra rendering passes, get rid of really large
images, and just get rid of extra non-opaque content.

703
00:53:06,470 --> 00:53:12,180
And you just have to keep cycling around and around and,
obviously, eliminating extra core graphic storing, as well,

704
00:53:12,180 --> 00:53:19,080
but at the end of the day, you just have to do the
hard work and get the performance where you want it.

705
00:53:19,080 --> 00:53:21,390
Okay, so that's enough about performance.

706
00:53:21,390 --> 00:53:25,110
The final section of the talk is going
to be just a little bit about high DPI.

707
00:53:25,110 --> 00:53:30,610
And, obviously, we all saw the new iPhone
with the massively high DPI screen.

708
00:53:30,610 --> 00:53:39,450
And so I don't know if you've been to any of the UIKit
lectures, talks about how that's going to be exposed

709
00:53:39,450 --> 00:53:41,770
as programming API, but I'm not going to talk about that.

710
00:53:41,770 --> 00:53:46,370
I just want to give you an idea of how you can
use this stuff on the Core Animation level.

711
00:53:46,370 --> 00:53:52,040
So, what's really happening here is when we have the
high DPI phone is that you give us the layer tree,

712
00:53:52,040 --> 00:53:55,350
or you give us a view tree, which
has a layer tree backing it.

713
00:53:55,350 --> 00:54:01,730
And it gets composited to the screen, so we have
this is a picture of a new iPhone, unfortunately,

714
00:54:01,730 --> 00:54:05,990
but if we had an old iPhone, then what we're going to have
is we're going to have a screen sized layout that's going

715
00:54:05,990 --> 00:54:11,350
to have a bitmap, which is 320 X 480 pixels large.

716
00:54:11,350 --> 00:54:19,910
And then if we were going to display that application on a
high DPI device, then your layer tree is exactly the same.

717
00:54:19,910 --> 00:54:23,550
But what happens is that when the UI window is created,

718
00:54:23,550 --> 00:54:27,690
it's going to add a scaling transform
onto the root of your layer tree.

719
00:54:27,690 --> 00:54:33,800
So, we now have this kind of 200 percent, 2X scaling
transform, which just blows everything up 2X.

720
00:54:33,800 --> 00:54:35,500
And I don't know if you can see this.

721
00:54:35,500 --> 00:54:36,570
Maybe you can, actually.

722
00:54:36,570 --> 00:54:42,960
But when we take a bitmap, and 320 X 480 bitmap,
and blow it up twice, then we get pixilation.

723
00:54:42,960 --> 00:54:50,670
And so, obviously, if you had that, you would get
very little, if any, benefit from the high DPI screen.

724
00:54:50,670 --> 00:54:54,570
So, we added some features in Core
Animation to work around this.

725
00:54:54,570 --> 00:54:59,270
Namely, we have a new property on the layer called
content scale, and what the content scale is,

726
00:54:59,270 --> 00:55:05,260
it's basically a way of telling us either that-- well,
it tells us the scale factor of the content of the layer,

727
00:55:05,260 --> 00:55:07,370
and the content is, obviously, the image.

728
00:55:07,370 --> 00:55:12,660
So, in this case, we're drawing text, so when I set
the content scale to be 2, which is the relationship

729
00:55:12,660 --> 00:55:20,130
between my layer geometry and the screen geometry, I
get scale by 2X, so I'm going to say content scale 2,

730
00:55:20,130 --> 00:55:23,780
and what that's going to do is it's
going to implicitly change the size

731
00:55:23,780 --> 00:55:29,330
of that bitmap context from 320
X 480 to twice that, 640 X 960.

732
00:55:29,330 --> 00:55:35,170
And then the nice thing, though, is that we'll just
hide this from you by just setting the matrices

733
00:55:35,170 --> 00:55:39,910
on the Core Graphics context so that you still think
you're drawing, because it's saying 320 X 480 buffer,

734
00:55:39,910 --> 00:55:44,740
but just Core Graphics will take care of the extra on
what's required to get the high resolution content.

735
00:55:44,740 --> 00:55:51,370
And so zooming in, this is just
to hammer this home one more time.

736
00:55:51,370 --> 00:55:55,570
We magnify the old content, and then
we set the content scale properly.

737
00:55:55,570 --> 00:56:00,250
The buffer changes size, and you get finer
grain, more pixels per inch or whatever.

738
00:56:00,250 --> 00:56:05,520
And it's going to, obviously, look great, because that's
going to match the natural resolution of the screen.

739
00:56:05,520 --> 00:56:08,470
You get the highest possible DPI.

740
00:56:08,470 --> 00:56:16,090
So, one final point is that even though
UIKit, they've chosen the way to expose us

741
00:56:16,090 --> 00:56:22,580
to apps is preserve compatibility, make
sure that your window is still 320 X 480.

742
00:56:22,580 --> 00:56:28,540
In some cases, you may want to think about, for example,
if you have graphics content, and you really want to get

743
00:56:28,540 --> 00:56:34,840
down to the native resolution of the display, you want to
have a 640 X 960 layer, just so you can position things

744
00:56:34,840 --> 00:56:40,090
in inches, exactly correctly for some reason, then
there's no reason you can't just undo that matrix.

745
00:56:40,090 --> 00:56:45,340
UI window has this text matrix, but anywhere in
your layer tree, you can apply an inverse to that,

746
00:56:45,340 --> 00:56:51,640
which are all CBS scale, half, 50 percent matrix, and that
will set things up correctly, and then your layer will be

747
00:56:51,640 --> 00:56:59,300
in the native, again, in the native coordinates,
native scaling space, and it will match right.

748
00:56:59,300 --> 00:57:02,080
Okay, so I'm really almost running out of time here.

749
00:57:02,080 --> 00:57:04,600
So, basically, you have a text scale factor.

750
00:57:04,600 --> 00:57:06,620
The geometry is the same.

751
00:57:06,620 --> 00:57:10,080
Content scale should be used for content.

752
00:57:10,080 --> 00:57:13,510
And like I said earlier, rasterization
scale for rasterizing,

753
00:57:13,510 --> 00:57:17,320
and you can undo the scale matrix when you need to.

754
00:57:17,320 --> 00:57:20,470
Okay, so one more slide.

755
00:57:20,470 --> 00:57:25,580
So, if you take anything out of this,
hopefully, it'll be maybe these three things.

756
00:57:25,580 --> 00:57:29,830
One, whenever you need to, use shadowPath, or rather,
whenever you're using shadows, use shadowPath.

757
00:57:29,830 --> 00:57:35,900
Two, whenever you don't have quite the right performance,
but it seems like this could help, use shouldRasterize.

758
00:57:35,900 --> 00:57:39,880
And three, really think about what your layers are meaning
to the graphics card, and try to think of them in terms

759
00:57:39,880 --> 00:57:46,770
of triangles and opacity, and what have you, and
just try to make some kind of mental calculations.

760
00:57:46,770 --> 00:57:50,260
And then now we're really done with five seconds to spare.

761
00:57:50,260 --> 00:57:51,820
[laughter] Okay, thank you very much.

762
00:57:51,820 --> 00:57:53,820
[applause]

