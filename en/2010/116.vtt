WEBVTT

00:00:07.350 --> 00:00:08.010
>> Ken Kocienda: Hello!

00:00:08.010 --> 00:00:15.410
Welcome! [applause] How are you all doing?

00:00:15.410 --> 00:00:17.390
Are you enjoying the conference so far?

00:00:17.390 --> 00:00:20.570
[applause] Okay, good, good, good.

00:00:20.570 --> 00:00:21.200
Well, welcome.

00:00:21.200 --> 00:00:28.950
Today, we're going to be talking about Model-View-Controller
for iPhone OS, or iOS, as it's now called,

00:00:28.950 --> 00:00:33.830
writing Essential Design Pattern
for Making Flexible Software.

00:00:33.830 --> 00:00:37.600
And I'm Ken Kocienda, and I work on iPhone software.

00:00:37.600 --> 00:00:41.320
Well, today, as you might be able to
tell, from the name of the presentation,

00:00:41.320 --> 00:00:44.370
this talk is going to be about design patterns.

00:00:44.370 --> 00:00:45.720
Well, what are design patterns?

00:00:45.720 --> 00:00:48.620
Well, there's a number of them up there on the slide.

00:00:48.620 --> 00:00:53.070
These are good solutions for common
problems in software development.

00:00:53.070 --> 00:00:54.030
You're probably familiar with them.

00:00:54.030 --> 00:00:57.060
Well, I'm going to pick out one of
them today, Model-View-Controller,

00:00:57.060 --> 00:01:02.220
and that's going to be the main subject of the talk.

00:01:03.280 --> 00:01:04.910
So, why should you care?

00:01:04.910 --> 00:01:06.340
Right? Why is this a big deal?

00:01:06.340 --> 00:01:07.630
Why are you here?

00:01:07.630 --> 00:01:10.280
Well, I'm going to try to answer that question for you.

00:01:10.280 --> 00:01:14.910
Because, well, probably you want to make great apps, right?

00:01:14.910 --> 00:01:18.490
Yeah! Okay, so, now, how can this all help?

00:01:18.490 --> 00:01:25.340
Well, going back to the beginning of iPhone
development, right, you had a small screen.

00:01:25.340 --> 00:01:31.530
We have some great documentation in APIs and, you know,
things are a lot simpler than maybe they used to be,

00:01:31.530 --> 00:01:37.770
if you're familiar with Desktop application development, and
it was really pretty simple to come up with an organization

00:01:37.770 --> 00:01:41.200
to just manage your one screen of content at a time.

00:01:41.200 --> 00:01:46.170
Well, then, along comes the iPad,
where the screen is bigger.

00:01:46.170 --> 00:01:52.660
You can fit more widgetry on the screen, more
content presented to your users at one time.

00:01:52.660 --> 00:01:56.540
Things get a little bit more complex.

00:01:56.540 --> 00:02:02.880
And then maybe you want to come up with an application that
will work on both the iPhone and the iPad at the same time,

00:02:02.880 --> 00:02:05.610
and it can seem like you're serving
two masters at the same time.

00:02:05.610 --> 00:02:12.760
Well, and that can be a little bit complicated, and so what
this talk is about is how Model-View-Controller can help you

00:02:12.760 --> 00:02:18.240
to tackle that problem and come up with some good solutions.

00:02:18.240 --> 00:02:23.600
Okay, so, now, if we sort of look at things formally,
if some of you studied Computer Science in school,

00:02:23.600 --> 00:02:26.780
you're probably familiar with a drawing like this.

00:02:26.780 --> 00:02:29.340
Yeah, there'll be a test on Friday, right?

00:02:29.340 --> 00:02:30.130
So, study up.

00:02:30.130 --> 00:02:31.850
Maybe, right?

00:02:31.850 --> 00:02:38.970
And we're going to be talking about this diagram
quite a bit, as we go along, but, really,

00:02:38.970 --> 00:02:46.020
what I'm going to try to do is tie that diagram and sort
of the concepts there back to the real world, right?

00:02:46.020 --> 00:02:51.240
Because, again, what you want is to make great apps, and
you want your software to stay flexible, easy to change

00:02:51.240 --> 00:02:54.720
and whatever, so I'm really going to
try to tie this back to the real world.

00:02:54.720 --> 00:02:58.320
And so I was trying to think of, like,
well, how could I present this all to you?

00:02:58.320 --> 00:03:02.300
So, when I think about the real world, I think
of like maybe a supermarket tabloid, right?

00:03:02.300 --> 00:03:04.580
You go down there, and you see these things all the time.

00:03:04.580 --> 00:03:07.520
"The 10 Best Celebrity Weight Loss Tips Ever."

00:03:07.520 --> 00:03:11.410
Right? You see these kinds of things all the time.

00:03:11.410 --> 00:03:17.850
I agonized on the copy, so I'll leave it on the screen
there for a second, so maybe you can see that there, right?

00:03:17.850 --> 00:03:24.320
Okay, so, I figured what I would do is
try to talk about Model-View-Controller

00:03:24.320 --> 00:03:28.540
and give you "The 10 Best MVC Tips Ever."

00:03:28.540 --> 00:03:31.460
Okay? Again, tie this back to the real world.

00:03:31.460 --> 00:03:34.950
And, again, the goal here is to give you some tips

00:03:34.950 --> 00:03:40.770
that will help you make your software
flexible and keep it easy to change.

00:03:40.770 --> 00:03:45.260
And, again, the goal being for you to
develop great apps, as you have been.

00:03:45.260 --> 00:03:49.380
And, of course, we'd like to see more
and more great apps, as time goes by.

00:03:49.380 --> 00:03:51.390
Okay, so let's jump right in.

00:03:51.390 --> 00:03:58.580
So, #1, the #1 tip is to Learn
Model-View-Controller for iPhone OS, or iOS.

00:03:58.580 --> 00:04:01.340
Old habits are going to die hard, so forgive me for that.

00:04:01.340 --> 00:04:06.250
So, learn Model-View-Controller for iOS.

00:04:06.250 --> 00:04:15.620
And this is all about learning the common conventions, as
they are applied in iOS, and learn about how they're built

00:04:15.620 --> 00:04:21.420
up from other design patterns, which, again,
are very, very common throughout the OS.

00:04:21.420 --> 00:04:25.360
And so, first of all, I'd like to focus
on the connections between the objects.

00:04:25.360 --> 00:04:30.230
So, going back to this diagram, you'll see that,
right, you're going to focus just on those connections,

00:04:30.230 --> 00:04:36.380
how things move around, how the updates and changes
circulate around this Model-View-Controller system.

00:04:36.380 --> 00:04:40.640
Okay? And the conventions that are used in iOS for that.

00:04:40.640 --> 00:04:47.990
And there are several, but, primarily, I'm going to call out
three of them: Target-Action, Notification, and Delegation.

00:04:47.990 --> 00:04:49.050
Okay, so what are these?

00:04:49.050 --> 00:04:50.050
Target-Action.

00:04:50.050 --> 00:04:55.910
Now, a lot of these are to promote
loose coupling among software elements,

00:04:55.910 --> 00:05:02.680
to allow you to tap into the functionality made available
by the OS classes in the APIs or that subclassing.

00:05:02.680 --> 00:05:04.550
Here is a concrete example.

00:05:04.550 --> 00:05:07.260
So, if you have a button in your application, you don't need

00:05:07.260 --> 00:05:11.530
to subclass the button to get custom
button-clicking behavior.

00:05:11.530 --> 00:05:17.760
You can set a target that implements a method, and basically
that target tells it, "But, hey, when you're tapped,

00:05:17.760 --> 00:05:26.520
call on me, and I'll go and take care of that custom
button-clicking behavior action afterwards stuff."

00:05:26.520 --> 00:05:30.870
Okay? So, again target-action, something that's very common.

00:05:30.870 --> 00:05:34.620
Another thing that's common is the notification.

00:05:34.620 --> 00:05:35.610
This is using the keyboard.

00:05:35.610 --> 00:05:39.680
When the keyboard comes up onto the screen,
of course, you don't have control over that.

00:05:39.680 --> 00:05:46.420
That just happens when the system detects that text
entry is going to happen, and so the keyboard sends

00:05:46.420 --> 00:05:51.060
out this notification, so that you can do
things like, perhaps, resize some views

00:05:51.060 --> 00:05:56.810
or perhaps initialize some objects, which
might validate some text, things like that.

00:05:56.810 --> 00:06:04.870
And so notification is, again, kind of this one-to-many type
communication between objects in the system and your code,

00:06:04.870 --> 00:06:09.900
and, primarily, that's NSNotificationCenter
takes care of that.

00:06:09.900 --> 00:06:14.440
Okay, I'd like to spend a little bit
of extra time talking about delegation,

00:06:14.440 --> 00:06:17.440
because it's going to come out
many, many more times in the talk.

00:06:17.440 --> 00:06:23.440
So, let's talk about delegation, another common
pattern which is used throughout the system.

00:06:23.440 --> 00:06:29.480
So, when a user taps on the return key
in a text field, the text field goes over

00:06:29.480 --> 00:06:32.370
and asks the delegate, "Should I end editing?"

00:06:32.370 --> 00:06:37.610
Should I actually, right, take the insertion point
out of the text field and make the keyboard go away?

00:06:37.610 --> 00:06:40.410
And the delegate, in this case, says, "Yes."

00:06:40.410 --> 00:06:50.520
And this way to link your custom object up to a text
field in the system is done through a UITextFieldDelegate.

00:06:50.520 --> 00:06:58.000
Well, many, many classes in UIKit
implemented Delegate to do work of this kind.

00:06:58.000 --> 00:07:02.250
Okay? And there's a really good way that you
can detect, even when you're reading code.

00:07:02.250 --> 00:07:06.120
Maybe you've downloaded some sample code,
and you're trying to understand how it works,

00:07:06.120 --> 00:07:09.750
so that you can sort of implement some of
that same functionality in your program.

00:07:09.750 --> 00:07:18.380
These will/did/should methods are sure signs
that you're looking at some delegation going on.

00:07:18.380 --> 00:07:19.230
So, an example.

00:07:19.230 --> 00:07:27.220
In the UIApplicationDelegate, the application says,
"Oh, I'm about to resign," and it will call out to some

00:07:27.220 --> 00:07:31.580
of your custom code, if you implemented
applicationWillResignActive.

00:07:31.580 --> 00:07:33.720
Right? The next one is a scroll view.

00:07:33.720 --> 00:07:39.860
When it zooms, when you pinch onto a scroll view to
zoom, you'll get a call back on your code, if you wish,

00:07:39.860 --> 00:07:43.430
if you implemented this method, scrollViewDidZoom.

00:07:43.430 --> 00:07:50.970
And another example, you click on a clear button
in a text field, right, you'll get a call out just

00:07:50.970 --> 00:07:55.090
to determine whether or not the text
field should actually clear its contents.

00:07:55.090 --> 00:08:05.450
So, again, these will/did/should methods are used really,
really quite a bit throughout UIKit and the UIKit classes.

00:08:05.450 --> 00:08:10.300
And, again, the idea for this is to keep
your code flexible and easy to change.

00:08:10.300 --> 00:08:16.170
Keep things from getting all balled up into one big
class that does everything, but keep things parceled

00:08:16.170 --> 00:08:19.960
out among different classes, so
that you can keep your code flexible

00:08:19.960 --> 00:08:26.260
and easy to change This will be a theme I'll be
returning to several more times during the talk.

00:08:26.260 --> 00:08:35.090
So, okay. So, a little bit of a look at how these
classes link up with their updates and changes.

00:08:36.100 --> 00:08:41.580
Right. So, learn MVC for the iPhone OS.

00:08:41.580 --> 00:08:50.620
Of course, there's a lot of great documentation
about those subjects in the iPhone Dev Center online.

00:08:50.620 --> 00:08:56.600
So, if you want to learn more, that's the place to do it.

00:08:56.600 --> 00:09:02.880
Okay. So, #2, so now Use MVC to Divide Your Work Up.

00:09:02.880 --> 00:09:09.710
And so, you know, a lot of times, when you
have your application, you've got a big idea,

00:09:09.710 --> 00:09:13.820
and perhaps it's even too big for
you to work on by yourself.

00:09:13.820 --> 00:09:19.830
So, you have to sort of divide up the work
and figure out how to make manageable pieces

00:09:19.830 --> 00:09:23.340
that will all communicate together to
implement this big idea that you have.

00:09:23.340 --> 00:09:26.010
Well, how does MVC help you do this?

00:09:26.010 --> 00:09:29.300
And I like to think of it as it
gives you a set of useful buckets.

00:09:29.300 --> 00:09:36.250
Right? So, going back to this diagram, again, we'll focus
in on the big boxes, the actual Model-View-Controller.

00:09:36.250 --> 00:09:42.260
Right? So, a Model, I like to think of Model as being not
just about data, which is sort of the most traditional way

00:09:42.260 --> 00:09:46.940
of thinking about what a model is, but also
algorithms and perhaps also networking,

00:09:46.940 --> 00:09:51.540
things that are beneath the level of the user interface.

00:09:51.540 --> 00:09:54.160
I like to think of all of that as the Model.

00:09:54.160 --> 00:09:59.920
View is all about display event capture,
not event processing, but event capture--

00:09:59.920 --> 00:10:05.170
I'll return to that again later-- and also
visual appeal, making your application beautiful,

00:10:05.170 --> 00:10:08.640
so that people love to look at it, love to use it,

00:10:08.640 --> 00:10:12.410
and they'll tell their friends, and
they'll go download it, as well.

00:10:12.410 --> 00:10:17.610
So, that's what the View is really, primarily,
focused on doing, and then the Controller is, again,

00:10:17.610 --> 00:10:21.740
all about coordination, things like delegation and odd jobs.

00:10:21.740 --> 00:10:26.410
So, let's look at a bit of an example,
at sort of a concrete example

00:10:26.410 --> 00:10:29.530
of how these things might actually fit into a real program.

00:10:29.530 --> 00:10:34.840
Let's just say that I want to make a
codebreaking machine, take some ciphers in

00:10:34.840 --> 00:10:36.800
and try to figure out what the plaintext says.

00:10:36.800 --> 00:10:41.940
So, you might imagine that my model would
have features and functionality for dealing

00:10:41.940 --> 00:10:44.770
with ciphertext, with plaintext, and cryptography.

00:10:44.770 --> 00:10:51.300
And a lot of times, the custom work of your
application, the real app-specific stuff that's going

00:10:51.300 --> 00:10:56.450
to differentiate your app from other
applications, is focused in on the model.

00:10:56.450 --> 00:11:02.060
That's where a lot of your custom
wonderfulness is going to get added, right?

00:11:02.060 --> 00:11:07.000
Now, when you go to the view, you might, you know,
imagine that such an application might show you a bunch

00:11:07.000 --> 00:11:10.610
of ciphertexts in a view, might
give you progress indications,

00:11:10.610 --> 00:11:14.540
things like that, add and delete buttons, and what all.

00:11:14.540 --> 00:11:20.680
Now, in a lot of cases, you don't want to
necessarily focus a lot of your work here.

00:11:20.680 --> 00:11:27.110
Instead, what you want to do is lean on UIKit as
much as you can, particularly a program like this.

00:11:27.110 --> 00:11:34.890
You probably want to focus in more on that model,
on that crypto behavior and less on how things look.

00:11:34.890 --> 00:11:39.630
You probably want your application to
look standard, so people are familiar,

00:11:39.630 --> 00:11:41.700
by just looking at it, about how it might work.

00:11:41.700 --> 00:11:49.600
So, again, lean on UIKit as much as you
can for common view-related behaviors.

00:11:49.600 --> 00:11:55.950
And in your controller, well, your controller does, again,
several different jobs, thinks like startup and shutdown,

00:11:55.950 --> 00:12:00.630
if it's an iPhone application, managing the
navigation from one screen to the next, and,

00:12:00.630 --> 00:12:03.890
as we've already talked about,
mediating between models and views.

00:12:03.890 --> 00:12:12.710
And so your job here is to match the right controllers to
the right job, and I'll talk about that some more later.

00:12:12.710 --> 00:12:19.000
Okay. So, trying to think about your application, use
Model-View-Controller to think about your application,

00:12:19.000 --> 00:12:27.860
divide out the pieces, so that you can
just manage the big idea that you have.

00:12:27.860 --> 00:12:33.500
Okay. So, use MVC to divide your
work, to implement that big idea.

00:12:35.390 --> 00:12:39.220
Okay. #3, Don't Fight the Framework.

00:12:39.220 --> 00:12:41.870
So, color inside the lines.

00:12:41.870 --> 00:12:47.600
I was always bad at coloring inside the
lines, as a kid, even when I wanted to.

00:12:47.600 --> 00:12:51.460
But the idea is, you know, to make
the framework work for you.

00:12:51.460 --> 00:12:58.650
So much time and effort has gone into making these
frameworks, hopefully, easy to use and feature rich.

00:12:58.650 --> 00:13:01.390
So, really try to make that framework work for you.

00:13:01.390 --> 00:13:01.940
Leverage it.

00:13:01.940 --> 00:13:06.530
And so let's kind of start with the don'ts first, okay?

00:13:06.530 --> 00:13:07.970
Don't fight the framework.

00:13:07.970 --> 00:13:09.710
Don't misuse framework classes.

00:13:09.710 --> 00:13:13.250
Now, one of the most common patterns that you'll see

00:13:13.250 --> 00:13:18.430
in iPhone development is the use of
UIViewControllers to manage a screen.

00:13:18.430 --> 00:13:24.240
Well, that UIViewController manages
a view, so don't take that view out.

00:13:24.240 --> 00:13:28.190
Stick it someplace else in your application and
just sort of forget about the UIViewController.

00:13:28.190 --> 00:13:30.370
That's not the way that it's intended to be used.

00:13:30.370 --> 00:13:31.190
Keep these.

00:13:31.190 --> 00:13:36.040
Let the UIViewController help you
manage the lifecycle of that view.

00:13:36.040 --> 00:13:39.490
Right? Don't decouple these and
just use one and forget the other.

00:13:39.490 --> 00:13:41.600
Right? Don't misuse the framework classes.

00:13:41.600 --> 00:13:47.320
Try to learn how they can help you, and then let them.

00:13:47.320 --> 00:13:50.360
Right? Don't re-implement framework classes.

00:13:50.360 --> 00:13:54.760
If you need a split view, use UISplitViewController.

00:13:54.760 --> 00:13:57.830
If you need a scroll view, use UIScrollView.

00:13:57.830 --> 00:14:01.840
Some of these classes can be really,
really tricky to implement,

00:14:01.840 --> 00:14:04.050
and you don't want to be spending your time doing that.

00:14:04.050 --> 00:14:09.820
You should really be spending your time making your
application differentiated from everybody else's out there.

00:14:09.820 --> 00:14:10.520
Make it wonderful.

00:14:10.520 --> 00:14:15.340
Don't spend time doing work that we've already done.

00:14:15.340 --> 00:14:19.250
And this can sometimes be difficult when
you go and you download an application,

00:14:19.250 --> 00:14:24.940
and you see a feature that you like, and you're
not necessarily sure how it was implemented.

00:14:24.940 --> 00:14:31.600
If you find yourself spending a whole lot of time
implementing what seems like a core piece of user interface,

00:14:31.600 --> 00:14:39.300
a core widget, step back and ask yourself, "Boy, is there
some way that I can lean on UIKit to get this functionality

00:14:39.300 --> 00:14:42.570
without doing the work to make it happen?"

00:14:42.570 --> 00:14:48.330
So, don't re-implement framework classes,
and don't make trivial UIKit classes.

00:14:48.330 --> 00:14:53.390
Use delegates and notifications to try to
learn how you can couple up a piece, you know,

00:14:53.390 --> 00:14:58.810
to match up a piece of your custom
code to the classes already in UIKit.

00:14:58.810 --> 00:15:04.780
Yes, there are times when you need to
subclass a UIKit class to override a method,

00:15:04.780 --> 00:15:11.450
but be careful that you don't cut off the core
functionality by perhaps not calling super and just sort

00:15:11.450 --> 00:15:19.730
of taking the work onto yourself to really
make the class work, as it was intended.

00:15:19.730 --> 00:15:26.600
And so don't just, again, subclass to make
a trivial subclass, when you can avoid it.

00:15:26.600 --> 00:15:29.940
Okay. Again, the idea is to make the framework work for you.

00:15:29.940 --> 00:15:32.190
So, what are some positive examples of that?

00:15:32.190 --> 00:15:35.750
So, going back to this codebreaker
example, if you've got a model,

00:15:35.750 --> 00:15:39.020
and you need to deal with pieces
of text, well, use NSString.

00:15:39.020 --> 00:15:44.360
Right? That's what it's there-- I mean, it's
a completely full-featured string class.

00:15:44.360 --> 00:15:45.690
Don't re-implement your own.

00:15:45.690 --> 00:15:50.880
Don't try to go out and make some kind of special
implementation, because you think you need one.

00:15:50.880 --> 00:15:52.820
You probably don't.

00:15:52.820 --> 00:15:55.470
In terms of crypto, don't invent your own crypto!

00:15:55.470 --> 00:15:57.630
Right? Use the Security framework.

00:15:57.630 --> 00:16:03.520
Learn what the framework, learn what the
whole OS and the set of APIs give you, again,

00:16:03.520 --> 00:16:10.110
so that you're not spending a lot of time implementing
complicated functionality that already exists.

00:16:10.110 --> 00:16:17.620
In terms of the view, I mean, again, you can imagine
use table views to show lists, and use UIViewController,

00:16:17.620 --> 00:16:20.290
as the documentation suggests that you should.

00:16:20.290 --> 00:16:21.430
Again, don't re-implement.

00:16:21.430 --> 00:16:22.780
Don't make custom buttons.

00:16:22.780 --> 00:16:28.500
Try to use what the framework gives
you to do those common interface jobs.

00:16:28.500 --> 00:16:33.280
And in terms of controllers, for startup and shutdown,

00:16:33.280 --> 00:16:36.610
we kind of have this AppController
design pattern, you might say.

00:16:36.610 --> 00:16:41.030
I'll talk about that a little bit more later, in
terms of starting up and shutting down your app.

00:16:41.030 --> 00:16:44.760
Again, for navigations and transitions,
use NavigationController.

00:16:44.760 --> 00:16:51.450
And for mediating between a model and view, really try to
figure out how you can hook your custom controller behavior

00:16:51.450 --> 00:16:56.950
in at the right place, calling the right delegate
methods to really mediate between models and views.

00:16:56.950 --> 00:17:01.620
And, again, later, I'll talk about that a little bit more.

00:17:01.620 --> 00:17:03.730
Okay, so don't fight the framework.

00:17:03.730 --> 00:17:06.130
Really lean on it.

00:17:06.130 --> 00:17:13.170
Be aware, when you feel yourself starting to invest
a lot of time in a place that isn't really specific

00:17:13.170 --> 00:17:16.320
about what makes your application special.

00:17:16.320 --> 00:17:22.610
So, Don't Abuse Views, #4.

00:17:22.610 --> 00:17:26.230
Views don't own data.

00:17:26.230 --> 00:17:29.000
Views are about data display and event capture.

00:17:29.000 --> 00:17:34.070
So, this is the time in the talk that, if you're just
a little bit early, maybe you were out, you know,

00:17:34.070 --> 00:17:36.180
late last night, and your buddy's falling asleep.

00:17:36.180 --> 00:17:38.340
So, you know, give him an elbow.

00:17:38.340 --> 00:17:44.160
You know, wake him up, because if you remember one
thing about the talk, it's that views don't own data.

00:17:44.160 --> 00:17:51.560
I gave us the double Family Feud strikeout here, for those
of you who are old enough to remember what that might mean.

00:17:51.560 --> 00:17:54.380
I'm not going to be kissing anybody,
though, so don't worry about that.

00:17:54.380 --> 00:17:58.780
So, but, okay, so you say, okay, views don't own data.

00:17:58.780 --> 00:18:00.110
What do I mean by this?

00:18:00.110 --> 00:18:04.050
Well, what you might be thinking is that,
well, views display data, don't they?

00:18:04.050 --> 00:18:07.050
So, what is this point all about?

00:18:07.050 --> 00:18:12.110
Well, the point is that the views don't own the data.

00:18:12.110 --> 00:18:17.830
They're not the place that-- the views aren't the
objects that are really responsible, ultimately,

00:18:17.830 --> 00:18:20.140
for owning a piece of data in your system.

00:18:20.140 --> 00:18:23.690
And so here's the case against-- here's why not.

00:18:23.690 --> 00:18:26.240
So, I think it's a slippery slope.

00:18:26.240 --> 00:18:32.710
If you put views really in charge of owning a piece
of data, then you might be tempted to put a little bit

00:18:32.710 --> 00:18:36.960
of data change methods into that
view, and now you're really--

00:18:36.960 --> 00:18:40.160
now your view is also sort of acting
like a controller for that view.

00:18:40.160 --> 00:18:43.480
Maybe it's doing a little data
validation, and it's a slippery slope.

00:18:43.480 --> 00:18:47.050
I mean, you know, you'll wind up like a drunk on the street.

00:18:47.050 --> 00:18:48.170
You know, it's like, "Oh, poor guy.

00:18:48.170 --> 00:18:48.750
What happened to him?"

00:18:48.750 --> 00:18:53.740
"Well, he put data in his view, and
it was all downhill from there!"

00:18:53.740 --> 00:18:55.860
Right? [laughter] Okay.

00:18:55.860 --> 00:19:00.560
So, but, you know, the other thing that it does, one of
the things is it locks you into a view implementation.

00:19:00.560 --> 00:19:07.680
Sometimes, you might realize that the best way to take
your iPhone app, your iPhone and iPod touch app and move it

00:19:07.680 --> 00:19:12.530
to the iPad is to make a different
view that does a similar job.

00:19:12.530 --> 00:19:15.890
Well, what if you've got the data owned in this view?

00:19:15.890 --> 00:19:18.590
The iPad, do you make a copy of that data?

00:19:18.590 --> 00:19:20.960
How do you keep those copies in sync?

00:19:20.960 --> 00:19:27.860
It can really, really lock you in and force you to make
some difficult decisions that you don't want to make.

00:19:27.860 --> 00:19:33.530
So, keep that ownership of data out of the view,
because, again, it gives you this tight coupling

00:19:33.530 --> 00:19:36.290
between data and display, which you want to avoid.

00:19:36.290 --> 00:19:40.020
And, again, you want to have models and controllers really,

00:19:40.020 --> 00:19:43.500
really acting appropriately in
their roles in your applications.

00:19:43.500 --> 00:19:44.400
So, where do they fit in?

00:19:44.400 --> 00:19:51.400
Well, they don't fit in anywhere, if your
views are in charge of owning the data.

00:19:51.400 --> 00:19:56.930
Another great thing that you can do-- just,
you know, kind of giving some positive advice--

00:19:56.930 --> 00:20:03.520
if your views don't own the data, it becomes easier to
implement inspectors, which, of course, is now becoming,

00:20:03.520 --> 00:20:06.340
you know, common and really possible on the iPad.

00:20:06.340 --> 00:20:09.370
You'll see here that I've got a
piece of text selected and up.

00:20:09.370 --> 00:20:14.870
There's a Toolbar, which is telling me the style
of the text, and then there's also a popover view,

00:20:14.870 --> 00:20:18.210
an inspector showing me that same piece of information,

00:20:18.210 --> 00:20:22.270
the same piece of information three
different places in the application.

00:20:22.270 --> 00:20:26.060
This piece of information, this style
information is owned in a model object,

00:20:26.060 --> 00:20:32.110
and these views are just getting a little piece
of it to customize their display appropriately.

00:20:32.110 --> 00:20:36.510
And, again, you can vary the data
display much, much more easily,

00:20:36.510 --> 00:20:40.370
if you're just dealing with a common
reference of that data that lives elsewhere.

00:20:40.370 --> 00:20:44.270
You can also vary behavior when the state of a view changes.

00:20:44.270 --> 00:20:46.730
Okay, this really talks about this idea of event capture.

00:20:46.730 --> 00:20:53.370
When the state of your application changes,
your view captures the event in the same way,

00:20:53.370 --> 00:20:59.640
but then it might be passing off the processing of
those captured events to, say, like a GestureRecognizer

00:20:59.640 --> 00:21:03.710
to have different behavior when the
state of the view changes, in this case,

00:21:03.710 --> 00:21:09.360
from a read-only to an editing mode for a particular view.

00:21:09.360 --> 00:21:15.670
Event processing of the view doesn't change, but it's
just the way that the hooked-up GestureRecognizer changes

00:21:15.670 --> 00:21:17.840
when the state of the application changes.

00:21:17.840 --> 00:21:22.780
So, you can much more easily vary
behavior by just changing an object,

00:21:22.780 --> 00:21:27.900
and the view is none the wiser, and it promotes reusability.

00:21:27.900 --> 00:21:34.520
I mean, it would be sort of silly to have each one of
those text fields be some trivial, you know, subclass.

00:21:34.520 --> 00:21:37.420
Oh, I've got a first name text view, a last name text view.

00:21:37.420 --> 00:21:40.440
That's just not the way, really, to do it.

00:21:40.440 --> 00:21:47.270
So, it helps to promote reusability, if you
don't have this data hooked up in your view,

00:21:47.270 --> 00:21:49.320
when it comes time to maybe add another field.

00:21:49.320 --> 00:21:53.960
Because, you know, your marketing department or your
management says you need one, you don't need to then sort

00:21:53.960 --> 00:22:01.060
of loading up this view with all of these different pieces
of data that could possibly be represented in the view.

00:22:01.060 --> 00:22:05.790
Okay, so keeping the data out of your
view helps to promote reusability.

00:22:05.790 --> 00:22:09.020
Okay, so don't abuse views.

00:22:09.020 --> 00:22:15.150
It's really about data display and
event capture, not data ownership.

00:22:15.150 --> 00:22:21.300
So, #5, Plan for iPhone and iPad.

00:22:21.300 --> 00:22:31.090
So, this is about dividing your code out into modules,
and it's really taking kind of this MVC organization,

00:22:31.090 --> 00:22:34.230
MVC architecture and kind of kicking
it up to a higher level.

00:22:34.230 --> 00:22:36.220
I'll show you what I mean.

00:22:36.220 --> 00:22:39.870
Well, let's consider Mail on iPhone.

00:22:39.870 --> 00:22:44.780
Of course, this application shipped in
1.0, nice, full-featured Mail application.

00:22:44.780 --> 00:22:47.300
It's really, really, you know, great.

00:22:47.300 --> 00:22:51.780
Full-featured Mail application you carry around
with you all the time in your pocket, right?

00:22:51.780 --> 00:22:59.550
But what we realized pretty soon after we started developing
the system was that there would be other applications

00:22:59.550 --> 00:23:03.520
which we also wanted to be able to send mail.

00:23:03.520 --> 00:23:06.360
Notes and Photos are an example.

00:23:06.360 --> 00:23:14.040
So, each of them have a little button there, which
allows you to send the note or send the photo by email.

00:23:14.040 --> 00:23:14.800
So, how do we do this?

00:23:14.800 --> 00:23:20.020
Well, we factored out the common
pieces, and here's how we did it.

00:23:20.020 --> 00:23:23.910
We divided things up into three basic layers.

00:23:23.910 --> 00:23:30.750
Down at the bottom, we have a message framework, which is
all about things beneath the level of the user interface,

00:23:30.750 --> 00:23:37.320
beneath the UI, things about networking, and
protocols, and basic mail, objects like messages,

00:23:37.320 --> 00:23:40.740
and subjects, and "To:" and "From:," things like that.

00:23:40.740 --> 00:23:45.360
Okay? So, all the non-UI elements down at the bottom level.

00:23:45.360 --> 00:23:54.430
At the middle level, we have UI elements, things
like Compose, Views, and lists of messages,

00:23:54.430 --> 00:23:59.570
and controllers for mediating between
the views and the model objects.

00:23:59.570 --> 00:24:04.430
And then all the way up at the top, we've got
the Mail, full-featured Mail application itself.

00:24:04.430 --> 00:24:06.160
Now, so, I think you know where this is going.

00:24:06.160 --> 00:24:16.130
We could just then extend out those two bottom layers and
implement the Notes and the Photo application up at the top,

00:24:16.130 --> 00:24:22.260
right, just having the custom parts in that top
level, which are specific to those applications,

00:24:22.260 --> 00:24:29.100
sharing as much as we could at the bottom two levels.

00:24:29.100 --> 00:24:30.610
Along comes the iPad.

00:24:30.610 --> 00:24:32.730
So, what to do?

00:24:32.730 --> 00:24:38.570
Well, the decision was made to make great
new versions of these existing applications.

00:24:38.570 --> 00:24:47.590
They're really not re-implementations or sort of a
resizing of the versions that we have on the iPhone.

00:24:47.590 --> 00:24:55.450
We really rethought how these applications should
work and how they might work best, given the iPad

00:24:55.450 --> 00:24:59.110
and the iPad hardware, and the bigger screen.

00:24:59.110 --> 00:25:06.740
And so we also realized that there
were parts that we could really reuse.

00:25:06.740 --> 00:25:10.850
There were elements that we could pull out and reuse.

00:25:10.850 --> 00:25:17.670
This is, you know, a prime example of real world code
reuse, whereas, you know, you look at that Compose,

00:25:17.670 --> 00:25:21.570
and you can really see that it is
the same, only a little bit larger

00:25:21.570 --> 00:25:25.870
and shown in a popover, instead
of taking over the full screen.

00:25:25.870 --> 00:25:35.850
Okay. So, now, taking this iPhone architecture,
moving it to the iPad, well, what we did was this.

00:25:35.850 --> 00:25:37.970
All right, so I'll kind of do that again.

00:25:37.970 --> 00:25:39.030
So, we have the saints.

00:25:39.030 --> 00:25:41.990
Look at those two bottom layers.

00:25:41.990 --> 00:25:46.980
The bottom level, the message framework,
stays absolutely the same!

00:25:46.980 --> 00:25:50.730
It's not involved in anything that
would need to change for the iPad.

00:25:50.730 --> 00:25:53.270
Mail protocols don't change.

00:25:53.270 --> 00:25:58.760
Right? We still need mail messages, and
message bodies, and things like that.

00:25:58.760 --> 00:26:03.260
Stepping up to the second level, you'll see that,
yeah, there needed to be some iPad additions.

00:26:03.260 --> 00:26:08.020
We had a couple of new user interface elements,
a couple of different kinds of interactions.

00:26:08.020 --> 00:26:14.760
So, yeah, we did need to make some additions there
for the iPad, but most of it stayed the same.

00:26:14.760 --> 00:26:17.050
Again, like the Compose view is a great example of that.

00:26:17.050 --> 00:26:18.250
That didn't change.

00:26:18.250 --> 00:26:19.760
That class didn't need to change.

00:26:19.760 --> 00:26:23.210
It needed to be resized, but it didn't need to change.

00:26:23.210 --> 00:26:29.530
And then, of course, at the top, we re-implemented
full new versions of these applications for the iPad.

00:26:29.530 --> 00:26:33.280
And so, if you're thinking about doing this,
if you've got an iPhone application now,

00:26:33.280 --> 00:26:37.010
and you're trying to ask yourself,
"Well, how can I move this to the iPad?"

00:26:37.010 --> 00:26:43.200
or you're planning a new application, and you want to
target both of these form factors, iPhone and iPod touch

00:26:43.200 --> 00:26:49.110
and the iPad, this is a pretty good way to start
thinking about how you might structure your code.

00:26:49.110 --> 00:26:50.900
Again, this is real world advice.

00:26:50.900 --> 00:26:56.330
This is how we did it, and it took
some back and forth to really come

00:26:56.330 --> 00:27:02.530
up with this architecture, and it
really wound up working for us.

00:27:02.530 --> 00:27:04.890
So, now, you may be asking yourself, "Real world?

00:27:04.890 --> 00:27:06.630
I want to make a framework."

00:27:06.630 --> 00:27:09.370
Well, there are no third party frameworks.

00:27:09.370 --> 00:27:11.430
You can't make your own frameworks.

00:27:11.430 --> 00:27:19.660
Right? Well, there are still ways to sort of
implement this same model, this same concept,

00:27:19.660 --> 00:27:24.060
but you would just simply have to come up
with an implementation strategy that works--

00:27:24.060 --> 00:27:26.930
static libraries and some very simple code sharing.

00:27:26.930 --> 00:27:29.100
By code sharing, I don't really mean a copy.

00:27:29.100 --> 00:27:35.540
I mean, it's just really sort of an Xcode reference
to the same code file in two different targets.

00:27:35.540 --> 00:27:41.120
Okay? So, if that's total gibberish to you, I'll even just
say right now that I'm going be down in the lab session

00:27:41.120 --> 00:27:48.390
after this session ends, and we can talk about how
you might actually do this, if you're interested.

00:27:48.390 --> 00:27:57.880
Okay? All right, so, planning for iPhone and iPad, dividing
your code up and coming up with this higher-level design

00:27:57.880 --> 00:28:02.620
that will help you keep things parceled out in a good way.

00:28:02.620 --> 00:28:07.350
So, #6, Strive for Loose Coupling.

00:28:07.350 --> 00:28:15.050
And, again, this is all about keeping your code
flexible and minimizing mutual dependencies.

00:28:15.050 --> 00:28:19.240
In some way, you know, I'm kind of
standing up here now thinking about it.

00:28:19.240 --> 00:28:24.720
I mean, really, if I had to choose out what would be the
second most important thing, this really might be it.

00:28:24.720 --> 00:28:29.720
I'm constantly, constantly worried about
keeping the code flexible and easy to change.

00:28:29.720 --> 00:28:33.780
If I think of one thing I think about more
than anything else, when I'm writing code,

00:28:33.780 --> 00:28:39.550
it's how can I keep it flexible,
so that it remains easy to change?

00:28:39.550 --> 00:28:44.460
Okay, so now, what is this loose coupling all about?

00:28:44.460 --> 00:28:49.300
Okay, so if you look at this architecture, sort of
a little reimagining of the architecture diagram

00:28:49.300 --> 00:28:52.050
from before-- and, of course, this is in concept.

00:28:52.050 --> 00:28:56.680
Now, if we were to take, like, a real application,
and sketch out what all the pieces might look like,

00:28:56.680 --> 00:28:59.480
it would wind up looking somewhat more like this, right?

00:28:59.480 --> 00:29:01.820
It's pretty complicated, right?

00:29:01.820 --> 00:29:06.160
Now, just think about if you wanted to pick
out a box, pick out which box looks, you know,

00:29:06.160 --> 00:29:10.890
like the nicest one to you, and
think about changing that box.

00:29:10.890 --> 00:29:16.860
Every arrow that's going into or out of that box
might need to be looked at, if you're going to change

00:29:16.860 --> 00:29:20.600
that object to perhaps add a feature or fix a bug.

00:29:20.600 --> 00:29:21.820
There's lots of implications.

00:29:21.820 --> 00:29:27.400
The more arrows coming in and out of
the box, the more difficult that box,

00:29:27.400 --> 00:29:31.410
the object represented by that
box, is going to be to change.

00:29:31.410 --> 00:29:40.330
Okay, so here's some strategies for taming all
of those arrows, so, striving for loose coupling.

00:29:40.330 --> 00:29:42.760
First of all, don't skip layers.

00:29:42.760 --> 00:29:50.520
Use controllers to coordinate messages from models to views.

00:29:50.520 --> 00:29:56.420
Right? That's one way to tame things, one
way to keep things more manageable, again,

00:29:56.420 --> 00:29:59.620
using features like delegation, notifications, and so forth.

00:29:59.620 --> 00:30:03.360
Don't message directly from the
top level to the bottom level.

00:30:03.360 --> 00:30:05.670
Don't mix MVC roles in one object.

00:30:05.670 --> 00:30:09.050
Again, this is primarily about views don't own data.

00:30:09.050 --> 00:30:11.600
That's where you might be most sorely tempted to do it.

00:30:11.600 --> 00:30:14.400
Avoid gathering too much work in one place.

00:30:14.400 --> 00:30:20.450
I mean, in some ways, if you think about it, if the work
is inside of all one box, you wouldn't have any arrows!

00:30:20.450 --> 00:30:22.930
But that wouldn't be really a good idea either,

00:30:22.930 --> 00:30:27.110
because then changing that one object
becomes all that much more complicated.

00:30:27.110 --> 00:30:32.160
That's almost sort of like hidden complexity
that you would need to worry about.

00:30:32.160 --> 00:30:34.360
That doesn't show up on such a diagram.

00:30:34.360 --> 00:30:37.060
And, finally, you know, don't declare
model data in your view classes.

00:30:37.060 --> 00:30:40.190
I think, yeah, I think we've been over that, right?

00:30:40.190 --> 00:30:45.880
Okay. So, some strategies for taming this.

00:30:45.880 --> 00:30:47.630
Here's an idea I like to think about a lot.

00:30:47.630 --> 00:30:52.830
I mean, if we focus in just on sort of a piece of your
model that may need to communicate with another piece

00:30:52.830 --> 00:30:58.440
of your model, I like to avoid this bidirectional messaging.

00:30:58.440 --> 00:31:04.460
A lot of times, I try to think about
a model object as being the one sort

00:31:04.460 --> 00:31:07.760
of in charge of talking to another model object.

00:31:07.760 --> 00:31:10.660
So, this model object might push data over.

00:31:10.660 --> 00:31:17.660
It might call, this object might
call a set method on this one.

00:31:17.660 --> 00:31:21.080
And if data needs to get from this
object over to this object,

00:31:21.080 --> 00:31:26.540
I'll have this one call a get accessor and pull it over.

00:31:26.540 --> 00:31:31.300
Again, so now, if I want to change
this object, and put another one in,

00:31:31.300 --> 00:31:33.790
I sort of know where all the touch points are.

00:31:33.790 --> 00:31:37.470
I know that this object is going
to need to be the one to change.

00:31:37.470 --> 00:31:44.590
Right? If I want to then maybe change a different object,
I know that probably this one doesn't need to change,

00:31:44.590 --> 00:31:47.690
because it's just having methods called on it.

00:31:47.690 --> 00:31:50.230
I don't have to worry about it, if this one goes away.

00:31:50.230 --> 00:31:51.800
Does that make sense?

00:31:51.800 --> 00:31:54.690
I hope so.

00:31:54.690 --> 00:31:56.290
So, avoid bidirectional messaging.

00:31:56.290 --> 00:32:02.500
Something else you may need to
do is support multiple updates.

00:32:02.500 --> 00:32:10.170
Like, if you think back to that inspector example, right,
a single change to a piece of model data might need

00:32:10.170 --> 00:32:17.130
to be reflected in several places in the user interface,
and key-value observing (KVO) is a great way to do that.

00:32:17.130 --> 00:32:23.590
I could talk for a whole hour on KVO,
but, of course, there's not time for that.

00:32:23.590 --> 00:32:31.940
But, basically, what this does is it sort of breaks these
connections and makes a little transmitter and receiver.

00:32:31.940 --> 00:32:38.060
Again, so, now, this direct connection is
broken, and now you have a much looser coupling.

00:32:38.060 --> 00:32:43.240
Right? Where removing one won't
necessarily mean that you need to worry

00:32:43.240 --> 00:32:47.880
about that connection being fully broken for everybody.

00:32:47.880 --> 00:32:52.100
Next, look at view and controller.

00:32:52.100 --> 00:32:56.370
Lean on delegates and target-action,
as I've already talked about, right?

00:32:56.370 --> 00:33:01.960
A good example of this is that if you have a view
that's a control, you'll get a didChange method

00:33:01.960 --> 00:33:06.900
or perhaps a UIControlEventValueChanged notification.

00:33:06.900 --> 00:33:10.920
And, really, what that will help you to do-- I mean, this is
going to be kind of a small change to the slide, but that,

00:33:10.920 --> 00:33:17.350
really, that blue arrow from the view to
the controller really sort of goes away,

00:33:17.350 --> 00:33:21.750
because it really then becomes more sort of system managed.

00:33:21.750 --> 00:33:30.680
It's not a piece, not a kind of communication now that you
really need to worry about, kind of in a first class way;

00:33:30.680 --> 00:33:34.070
again, sort of lessening the burden that you have in trying

00:33:34.070 --> 00:33:39.270
to keep this entire message graph
managed and sort of in your head.

00:33:39.270 --> 00:33:51.630
Okay, and the last one in this little section is sort of
limiting the number of connections to and from controllers.

00:33:51.630 --> 00:33:58.570
Again, I'm urging you to use controllers to keep things
all managed, but you really kind of want to try, also,

00:33:58.570 --> 00:34:05.070
at the same time, to limit the number
of connections to a specific controller.

00:34:05.070 --> 00:34:09.660
And the big challenge here is to decompose
controller work into the right number of controllers

00:34:09.660 --> 00:34:14.530
and types of controllers, and I'll talk
to you about that a little bit later.

00:34:14.530 --> 00:34:20.190
So, now, if you employ some of these strategies
that I just talked about, you could take a graph,

00:34:20.190 --> 00:34:27.160
with all of these arrows flying around here, and make
it something like this, which is more manageable,

00:34:27.160 --> 00:34:32.560
easier to change, more flexible, more loosely coupled.

00:34:35.100 --> 00:34:37.940
So strive for loose coupling in your program.

00:34:37.940 --> 00:34:42.470
Lean on delegates, KVO, technologies like KVO.

00:34:42.470 --> 00:34:49.150
Avoid this bidirectional messaging, and try to limit
the number of mutual dependencies between objects.

00:34:49.150 --> 00:34:53.870
And so that's #6.

00:34:53.870 --> 00:34:56.270
#7, Choose the Right Data Model.

00:34:56.270 --> 00:35:06.590
And so the iPhone,OS, iOS, gives you many, many options,
and so your job is to really find the right fit.

00:35:06.590 --> 00:35:13.330
Find the right way to represent your data in your programs.

00:35:13.330 --> 00:35:18.090
And so I'll just give you a minute to read that over.

00:35:21.630 --> 00:35:25.140
That's a lot of text for a slide, isn't it?

00:35:25.140 --> 00:35:26.930
Okay, I mean, that's kind of important, right?

00:35:26.930 --> 00:35:33.250
I mean, if you're, certainly, if you're into the deep
data, but I mean, is it really sixth normal form?

00:35:33.250 --> 00:35:36.450
Really? I mean, is that something that
you're all going to be worried about?

00:35:36.450 --> 00:35:44.480
I mean, again, some part of the real world, you know, is
interested in modeling data and all of the theory behind it,

00:35:44.480 --> 00:35:52.410
but, really, mostly, I think, what you're going to be
worried about is taking your collection of objects,

00:35:52.410 --> 00:35:58.090
not really worrying about sixth normal form quite so much,
worrying, instead, about how you got this graph of objects

00:35:58.090 --> 00:36:04.390
at runtime, how you're going to get them saved out, and then
how you're going to get them back into your program later,

00:36:04.390 --> 00:36:10.980
if your user launches your program again,
or the device restarts, what have you.

00:36:10.980 --> 00:36:16.050
So, this is what you're really worried about, I think,
probably, in kind of the real world sort of way.

00:36:16.050 --> 00:36:20.930
So, let's talk about the different data model concerns,
the different things that you may need to think about,

00:36:20.930 --> 00:36:26.010
while you're trying to balance these
tradeoffs between the different kinds

00:36:26.010 --> 00:36:29.450
of the different choices that you
have for modeling your data.

00:36:29.450 --> 00:36:31.060
Well, there are lots of them!

00:36:31.060 --> 00:36:33.560
Things like, maybe, if are there modeling tools available?

00:36:33.560 --> 00:36:35.140
Am I going to be using SQL?

00:36:35.140 --> 00:36:40.110
Do I need transactions for complicated
model transformations?

00:36:40.110 --> 00:36:41.580
What about versioning?

00:36:41.580 --> 00:36:42.690
Maybe you already know.

00:36:42.690 --> 00:36:45.790
You're trying to maybe get an application
out there, a quick 1.0 version,

00:36:45.790 --> 00:36:49.420
but you already know what's going to be in the 2.0 version.

00:36:49.420 --> 00:36:52.960
So, think about how to transform that
data from one version to the next.

00:36:52.960 --> 00:36:56.410
Perhaps you're bringing a program
over from a different platform,

00:36:56.410 --> 00:37:01.260
so perhaps you might have a large
collection of legacy data already.

00:37:01.260 --> 00:37:06.360
And there's speed, and I/O, and
scaling, and all kinds of concerns.

00:37:06.360 --> 00:37:13.460
So, I'm going to try to help you, give you some
tips for sifting through the options that the APIs

00:37:13.460 --> 00:37:18.210
and the OS gives you to find the best choice for you.

00:37:18.210 --> 00:37:21.380
So, here are six different options.

00:37:21.380 --> 00:37:27.650
Property lists, archives, custom files,
using Server/Cloud, SQLite, and CoreData.

00:37:27.650 --> 00:37:34.280
These are all, depending on your situation, any one of
these or some combination might be the right choice.

00:37:34.280 --> 00:37:43.250
But I'll tell you what is not the right choice,
most times, is using defaults or preferences.

00:37:43.250 --> 00:37:45.520
It's almost always the wrong tool for the job.

00:37:45.520 --> 00:37:47.110
Well, when is it the right tool?

00:37:47.110 --> 00:37:54.950
Well, if you can think about it, say, look at the Settings
Panel test, if you've got a piece of data in your program

00:37:54.950 --> 00:38:04.240
that you think the best place to expose that piece of
data is in settings, if you have an advanced on/off,

00:38:04.240 --> 00:38:08.700
if you have some feature that might be
on or off, then probably user defaults

00:38:08.700 --> 00:38:11.570
and preferences is the right place for it.

00:38:11.570 --> 00:38:15.440
If you can't put that piece of data in
your settings panel, then user defaults

00:38:15.440 --> 00:38:20.800
and preferences is almost certainly the wrong choice.

00:38:20.800 --> 00:38:22.560
So, what are some of the right choices?

00:38:22.560 --> 00:38:24.080
Property lists.

00:38:24.080 --> 00:38:26.240
Property lists might be the right choice.

00:38:26.240 --> 00:38:35.060
One of their great virtues is that they're really,
really simple to use, particularly if you've got--

00:38:35.060 --> 00:38:42.960
if your data is expressed in strings, numbers,
arrays, dictionaries, the small number of core classes

00:38:42.960 --> 00:38:46.420
and data types that can be written
out directly to a property list.

00:38:46.420 --> 00:38:51.290
If this is what you have, then property
lists might be a great choice for you.

00:38:51.290 --> 00:38:56.680
I mean, just thinking, like, if you had a Twitter client,
for instance, sort of user name, you know, server,

00:38:56.680 --> 00:38:58.110
perhaps the people that you're following.

00:38:58.110 --> 00:39:04.770
Yeah, all of that data can be expressed pretty
directly using strings, numbers, arrays, dictionaries,

00:39:04.770 --> 00:39:09.440
so forth, and they're very, very simple to use.

00:39:09.440 --> 00:39:12.030
Archives are also very, very simple to use.

00:39:12.030 --> 00:39:17.400
Let's say you have a custom object,
and it's, maybe it's a collection.

00:39:17.400 --> 00:39:21.370
It's a composition of several different data types.

00:39:21.370 --> 00:39:24.170
Maybe some of them are custom.

00:39:24.170 --> 00:39:25.110
Some of them aren't.

00:39:25.110 --> 00:39:28.780
Perhaps it's your object is the head
of a more complicated object graph,

00:39:28.780 --> 00:39:31.270
and you just want to get that object written out to disc.

00:39:31.270 --> 00:39:32.820
Well, archives is a great way to do it.

00:39:32.820 --> 00:39:38.710
You implement these two methods, and you can
read that object out, and read it back in.

00:39:38.710 --> 00:39:44.660
One of the great advantages of using
archives is that it supports versioning.

00:39:44.660 --> 00:39:51.260
So, if you already know that you need to add a
feature later, you need to add a data element later,

00:39:51.260 --> 00:39:57.990
archives can help you support that and
have your data be sort of both forward

00:39:57.990 --> 00:40:02.640
and backwards compatible, and it
also supports transient data.

00:40:02.640 --> 00:40:10.170
So, if you have data in a particular object that doesn't
need to be saved out, you also have control over that.

00:40:10.170 --> 00:40:11.190
Custom files.

00:40:11.190 --> 00:40:16.930
Of course, writing applications for iOS,
you get a little slice of disc space

00:40:16.930 --> 00:40:22.210
where you can write your application
data, so you could just open up that file.

00:40:22.210 --> 00:40:27.340
And perhaps if you already have some legacy code
or data, again, if you're bringing an application

00:40:27.340 --> 00:40:31.520
over from another platform, you might have
already done most or all of this work.

00:40:31.520 --> 00:40:36.440
This is really probably-- custom files
are really almost best when that's true,

00:40:36.440 --> 00:40:40.060
when you're just going to be tapping
into work that you've already done.

00:40:40.060 --> 00:40:48.400
And so your job in bringing that code over to the iOS
is probably going to be building an NSObject-based graph

00:40:48.400 --> 00:40:57.400
out of those objects, which may, perhaps it might be
easier, if it's a Mac application that you're bringing over.

00:40:57.400 --> 00:41:04.000
But, if not, again, that's going to be your main
challenge there, building up that NSObject-based graph.

00:41:04.000 --> 00:41:07.750
So, you could also use the Server/Cloud.

00:41:07.750 --> 00:41:10.830
I think a really good example of this
is if you're implementing a game,

00:41:10.830 --> 00:41:13.930
and you've got a high score list that you want to save.

00:41:13.930 --> 00:41:22.300
A great example of using Server/Cloud--
we do give you some help to implement this

00:41:22.300 --> 00:41:26.390
with NSURL classes, other lower-level networking classes.

00:41:26.390 --> 00:41:27.750
Of course, the server is up to you.

00:41:27.750 --> 00:41:30.350
There's not going to be much we can do.

00:41:30.350 --> 00:41:37.310
Even if you come to the lab later, you can plead with me,
but I don't know how much we're going to be able to help,

00:41:37.310 --> 00:41:44.850
when it comes time to implement the
other side of this data model strategy.

00:41:44.850 --> 00:41:51.030
Okay, so, coming back onto the
platform fully, SQLite is a really,

00:41:51.030 --> 00:41:53.560
really great library that we've got available for you.

00:41:53.560 --> 00:41:57.810
And it's really great, if you're familiar
with SQL, you can just go in there

00:41:57.810 --> 00:42:01.160
and start using the features available in this engine.

00:42:01.160 --> 00:42:06.340
Your challenge almost certainly is going to be coming up
with a strategy for doing an object/relational mapping.

00:42:06.340 --> 00:42:09.240
Now, I'll have to admit, yes, my name
is Ken Kocienda, and I have a problem.

00:42:09.240 --> 00:42:14.090
I've implemented my own object/relational
mapping strategies.

00:42:14.090 --> 00:42:17.850
I've written languages to do it, and I've used-- right.

00:42:17.850 --> 00:42:19.010
I mean, I'm sorry.

00:42:19.010 --> 00:42:22.300
I mean, it's like the first step in the 12-step program.

00:42:22.300 --> 00:42:25.440
I don't know how many of you out there have done that, too.

00:42:25.440 --> 00:42:26.860
And this can be tricky.

00:42:26.860 --> 00:42:30.260
You can wind up spending a lot of time doing this.

00:42:30.260 --> 00:42:32.110
It can wind up working great.

00:42:32.110 --> 00:42:38.400
You can come up with custom caching
strategies, custom object fault strategies.

00:42:38.400 --> 00:42:45.260
You can do all sorts of really, really neat things, if you
invest the time and effort to write this mapping layer.

00:42:45.260 --> 00:42:47.920
Moving on to CoreData.

00:42:47.920 --> 00:42:59.240
CoreData is great, because it gives you this wealth of
features, and you can use SQLite as the backend data store

00:42:59.240 --> 00:43:08.470
for CoreData, and it really does solve this problem
of making an object/relational mapping strategy.

00:43:08.470 --> 00:43:10.560
The work is already done for you.

00:43:10.560 --> 00:43:17.770
Now, the thing about using CoreData is it's going to take a
little bit of investment to learn how to use it and to find

00:43:17.770 --> 00:43:20.200
out about all the great features that there are.

00:43:20.200 --> 00:43:27.780
But even so, I strongly consider that you invest this
time, particularly, perhaps, if you're already familiar

00:43:27.780 --> 00:43:32.850
with the platform and, perhaps, you're looking for a
way to maybe bring, you know, take your next application

00:43:32.850 --> 00:43:38.990
to the next level, or you already know that your
next application is going to be using a lot of data.

00:43:38.990 --> 00:43:43.170
I really, really strongly urge you to consider CoreData.

00:43:43.170 --> 00:43:46.490
So, why? What are some of these features?

00:43:46.490 --> 00:43:49.850
There's modeling tools and very,
very simple saving/restoring.

00:43:49.850 --> 00:43:55.900
You could query to get portions of
your object graph returned to you.

00:43:55.900 --> 00:43:59.540
There's support for undo, which is
really, really terrific to support.

00:43:59.540 --> 00:44:04.330
Again, for the partial object graphs,
reading in a portion of an object.

00:44:04.330 --> 00:44:07.440
Perhaps you had a blob object that refers to a large image.

00:44:07.440 --> 00:44:08.870
You want to show a list of images.

00:44:08.870 --> 00:44:12.350
Well, you don't need to read in all
of the large data for the image.

00:44:12.350 --> 00:44:23.150
You can just read in the image, metadata and only fault
in the large image, when it comes time to display it.

00:44:23.150 --> 00:44:31.210
So, there's many, many wonderful features
available in CoreData, if you learn how to use them.

00:44:31.210 --> 00:44:37.540
So, again, I hope that gave you some
idea about the choices available.

00:44:37.540 --> 00:44:43.800
And, again, if you have more questions, based on this, I'll
be in the lab afterward to answer any questions you may have

00:44:43.800 --> 00:44:48.390
about choosing the right data model and all of the options.

00:44:48.390 --> 00:44:55.870
Okay, so, #8, Decompose Controller Work.

00:44:55.870 --> 00:45:02.090
This is all about coming up with the right number of
controllers for your system and learning something

00:45:02.090 --> 00:45:07.520
about the special iPhone OS or iOS-- again,
old habits die hard-- iOS controllers.

00:45:07.520 --> 00:45:09.950
So, again, going back to this graphic.

00:45:09.950 --> 00:45:11.630
But now look at what's happening.

00:45:11.630 --> 00:45:22.700
So, now this really ties into that typical iPhone type
navigation from one screen to the next and then back again.

00:45:22.700 --> 00:45:29.270
Now, a lot of times, I mean, the easiest way to
implement that is having one UIViewController per screen.

00:45:29.270 --> 00:45:35.690
You have kind of like this little sandwich with a view
on the top that's being managed by a UIViewController,

00:45:35.690 --> 00:45:39.330
and then the model data to support the
data that's being shown in that view,

00:45:39.330 --> 00:45:41.290
and that you have one of those per screen.

00:45:41.290 --> 00:45:48.690
Now, if you think about taking that over to the iPad,
you might be tempted to make just one controller,

00:45:48.690 --> 00:45:53.180
because now all those views can
fit on the screen at the same time!

00:45:53.180 --> 00:45:56.780
And I think you know where I'm going with this.

00:45:56.780 --> 00:45:57.860
Don't do that!

00:45:57.860 --> 00:46:02.480
Avoid making an everything controller!

00:46:02.480 --> 00:46:04.320
Right? You know, super.

00:46:04.320 --> 00:46:06.360
You know it's like when you start thinking of a name.

00:46:06.360 --> 00:46:07.210
What am I going to call this?

00:46:07.210 --> 00:46:09.690
A super king daddy everything controller!

00:46:09.690 --> 00:46:10.930
No. [laughter] Right?

00:46:10.930 --> 00:46:12.520
That's a bad, bad idea.

00:46:12.520 --> 00:46:14.140
That's a sign.

00:46:14.140 --> 00:46:21.140
Right? When you can't think of a name for the thing,
and it starts getting into this manager, super manager,

00:46:21.140 --> 00:46:28.580
that's a sign that you're coupling things too tightly,
gathering too much functionality into one place.

00:46:28.580 --> 00:46:30.660
So, let's look at a concrete example.

00:46:30.660 --> 00:46:33.900
There's a real world implication
of what that might be to kind

00:46:33.900 --> 00:46:36.520
of start gathering all of this
work into a single controller.

00:46:36.520 --> 00:46:40.870
So, let's see, we've got these two views, and
they're both pointing to the same controller.

00:46:40.870 --> 00:46:46.520
So, now I'm going to change the views
to actually specific view types.

00:46:46.520 --> 00:46:50.060
One of them is the scroll view,
and one of them is a table view.

00:46:50.060 --> 00:46:52.520
Now, table view is a scroll view.

00:46:52.520 --> 00:47:00.910
Table view is a subclass of scroll view, so now,
if you had a scrollViewDidScroll method implemented

00:47:00.910 --> 00:47:07.450
in this one controller, you would probably
need to write a line of code like this.

00:47:07.450 --> 00:47:08.430
Okay, well, all right.

00:47:08.430 --> 00:47:13.480
So, if the scroll view is the table view, then I need
to do the table stuff, and if it's the scroll view,

00:47:13.480 --> 00:47:15.840
then I need to do the scroll stuff, scroll view stuff.

00:47:15.840 --> 00:47:19.240
Basically, I mean, I almost think that
we should, like, have a certain, like,

00:47:19.240 --> 00:47:22.690
a special feature of the OS, maybe a new Xcode feature.

00:47:22.690 --> 00:47:24.530
There's all these wonderful new features in Xcode.

00:47:24.530 --> 00:47:26.380
Maybe I'll write about for the next version.

00:47:26.380 --> 00:47:32.080
It's like when you type this kind of question, there'd be
like a little shock coming back from the keyboard, right?

00:47:32.080 --> 00:47:36.100
[laughter] This kind of class is
almost never the right choice, right?

00:47:36.100 --> 00:47:40.140
It should probably complete autocomplete
in red or something like that.

00:47:40.140 --> 00:47:41.200
I don't know.

00:47:41.200 --> 00:47:45.850
So, when you do this, don't have
class checks in your delegate methods.

00:47:45.850 --> 00:47:51.990
Another variation of this is that if you have two table
views, you might actually be checking the identity

00:47:51.990 --> 00:47:57.020
of the view that was passed in, while if
it's the foo view, do the, table view,

00:47:57.020 --> 00:47:59.470
do this; if it's the bar table view, do that.

00:47:59.470 --> 00:48:04.910
Again, that's perhaps too tight of a coupling.

00:48:04.910 --> 00:48:09.960
You might want to make two different
controllers, one per table view.

00:48:09.960 --> 00:48:14.910
And absolutely avoid class checks in your delegate methods.

00:48:14.910 --> 00:48:19.910
Obviously, if you were to add another table view,
this would probably fail, and you'd need another layer

00:48:19.910 --> 00:48:22.630
of "if" statements inside of that first block.

00:48:22.630 --> 00:48:26.890
Again, that's almost never the
right way to structure your code.

00:48:26.890 --> 00:48:31.020
Keep your work parceled out, again, like this, even on iPad,

00:48:31.020 --> 00:48:37.780
even if there's enough room on the
screen to fit all of your views.

00:48:37.780 --> 00:48:43.360
But now there's controllers play other roles in the system.

00:48:43.360 --> 00:48:47.900
I mean, kind of to show you, going back to this, I'm
talking a whole lot about how the controller sits

00:48:47.900 --> 00:48:52.700
between a view and a model and the relationships there.

00:48:52.700 --> 00:48:55.680
But, again, these controllers,
they also play different roles.

00:48:55.680 --> 00:48:56.510
So let's take a look here.

00:48:56.510 --> 00:48:58.490
This is my coolest slide, so watch this one.

00:48:58.490 --> 00:49:00.440
Isn't that cool?

00:49:00.440 --> 00:49:03.220
I want to do that again, because I like it.

00:49:03.220 --> 00:49:05.360
So, here's how you've got the application controller.

00:49:05.360 --> 00:49:11.480
So now focusing in, seriously, what's going on
here is if you create a new project in Xcode,

00:49:11.480 --> 00:49:21.710
and if you use one of the custom templates-- excuse me--
one of the default templates for an iPhone or iPad project,

00:49:21.710 --> 00:49:25.740
you're going to get, as part of
the template, one of these objects.

00:49:25.740 --> 00:49:33.790
The name of this project is Bugspray, so I get a
BugsprayAppDelegate class given to me by the template.

00:49:33.790 --> 00:49:35.780
And so this is the application controller.

00:49:35.780 --> 00:49:38.530
And so what is the job of this object?

00:49:38.530 --> 00:49:46.110
Well, it's the delegate of the UIApplication, because,
most likely, you don't need a subclass of UIApplication.

00:49:46.110 --> 00:49:54.070
You can tie into the delegate methods that UIApplication
will call on its delegate to do important work,

00:49:54.070 --> 00:49:56.700
like starting up and shutting down your application.

00:49:56.700 --> 00:50:03.190
You might also think about it as the app controller
is the root object in your entire object graph.

00:50:03.190 --> 00:50:10.250
If you were to follow the parent link, starting from
any object in your system and follow who's the parent,

00:50:10.250 --> 00:50:15.220
who's the parent, who's the parent, who's the
parent, most likely, you're going to get back

00:50:15.220 --> 00:50:19.790
to the application controller as
the root object in your system.

00:50:19.790 --> 00:50:26.720
And so its job is to basically get things kicked off
and to turn over control to the appropriate controller,

00:50:26.720 --> 00:50:31.560
perhaps like if you have a view on your iPhone
application, it's probably going to turn over control

00:50:31.560 --> 00:50:40.320
to a navigation controller and a UIViewController, something
like that, that's a very common pattern, very typical.

00:50:40.320 --> 00:50:44.800
So, again, this application controller
has this special role in your system.

00:50:44.800 --> 00:50:52.830
It's not really hooked up in a one-to-one way
to a single model and a single view, although,

00:50:52.830 --> 00:50:59.680
now here's one thing that it sort of might be hooked
up to through an object like NSManagedObjectContext.

00:50:59.680 --> 00:51:06.050
If you do decide to use CoreData, if you follow
my advice, if you already are using CoreData,

00:51:06.050 --> 00:51:14.430
you're familiar with this object, NSManagedObjectContext,
and it's responsible for saving objects out to storage

00:51:14.430 --> 00:51:18.760
to write fetches, to retrieve objects, and
create and delete objects, and so forth.

00:51:18.760 --> 00:51:23.790
And so, again, it's a controller
that really just manages a model.

00:51:23.790 --> 00:51:26.310
It doesn't have a connection to a view.

00:51:26.310 --> 00:51:32.330
I'll have to make a little digression here.

00:51:32.330 --> 00:51:34.620
I noticed there's a typo in the slide.

00:51:34.620 --> 00:51:39.510
The joke is that this a model for a nuclear
power plant, and I misspelled electricity.

00:51:39.510 --> 00:51:41.640
I hope that light doesn't cause a
meltdown or something like that.

00:51:41.640 --> 00:51:43.980
I tell you, I hope not.

00:51:46.000 --> 00:51:49.410
Probably want to keep me as far
away from nuclear power as possible.

00:51:49.410 --> 00:51:52.200
Okay. So, #8, Decompose Controller Work.

00:51:52.200 --> 00:51:54.710
Again, this is about coming up with
the right number of controllers.--

00:51:54.710 --> 00:52:02.310
don't gather too much work into too few controllers--
and to learn about these special iPhone OS controllers

00:52:02.310 --> 00:52:06.070
to help you tap into specialized functionality.

00:52:06.070 --> 00:52:14.580
Okay, #9, Taking Charge-- Take Charge of Your Object Graph.

00:52:14.580 --> 00:52:15.250
This one's real simple.

00:52:15.250 --> 00:52:19.830
It's about ownership and lifecycle of your objects.

00:52:19.830 --> 00:52:26.240
And so what I do, when I write
applications, is I come up with a set of rules

00:52:26.240 --> 00:52:30.200
that seem appropriate for the app that I'm writing.

00:52:30.200 --> 00:52:31.900
I'll give you an example of what a rule might be.

00:52:31.900 --> 00:52:36.860
Well, if an object creates another,
if this object creates this object,

00:52:36.860 --> 00:52:40.880
well then it's this object's responsibility to release it.

00:52:40.880 --> 00:52:43.890
Very simple rule.

00:52:43.890 --> 00:52:47.850
Another rule is children don't outlive their parents.

00:52:47.850 --> 00:52:52.070
Sort of odd, if you were to match that up to the real
world, but inside programs, it makes perfect sense, right?

00:52:52.070 --> 00:52:55.850
So, this object creates this one.

00:52:55.850 --> 00:53:01.180
This object isn't going to go away,
while this one is still around, right?

00:53:01.180 --> 00:53:02.080
This object is the parent.

00:53:02.080 --> 00:53:04.570
This one is the child.

00:53:04.570 --> 00:53:08.140
Right? This one is going to have
to go away at the same time.

00:53:08.140 --> 00:53:10.170
Factory objects transfer ownership.

00:53:10.170 --> 00:53:15.480
Sometimes you might have an object which is
responsible for building or creating objects, perhaps,

00:53:15.480 --> 00:53:18.610
as a result of maybe some networking
that's gone on or whatever.

00:53:18.610 --> 00:53:25.600
But it's probably a good idea to transfer the
ownership of those objects to a different one,

00:53:25.600 --> 00:53:30.800
which in some ways is an exception to the first rule
that I just said, or actually the first two rules.

00:53:30.800 --> 00:53:33.660
But, again, that's another rule that I might make.

00:53:33.660 --> 00:53:37.720
But for those Perl programmers out there--
how many Perl programmers out there?

00:53:37.720 --> 00:53:41.740
So, this should just give you a little
warm feeling in your heart, right?

00:53:41.740 --> 00:53:42.520
TMTOWTDI, right?

00:53:42.520 --> 00:53:43.780
There's more than one way to do it.

00:53:43.780 --> 00:53:49.600
My set of rules for my application may not be
the same that you would use in your application.

00:53:49.600 --> 00:53:55.180
Again, it's sort of part of your job is to understand
what makes sense for the app that you're writing.

00:53:55.180 --> 00:54:00.740
And so here's kind of a closer
look at one of those sample rules.

00:54:00.740 --> 00:54:08.310
Again, this idea that the model might create a
controller, and then the model owns that controller.

00:54:08.310 --> 00:54:14.650
And so then, if it comes time for the model to go away,
well then they both need to go away at the same time.

00:54:14.650 --> 00:54:19.860
That controller is not going to be around,
perhaps, with dangling pointers back to the model.

00:54:19.860 --> 00:54:20.800
All right?

00:54:20.800 --> 00:54:25.160
If the model is to go away, right, everything goes away.

00:54:26.380 --> 00:54:29.140
So now expanding out that rule a little bit further.

00:54:29.140 --> 00:54:31.220
So model creates a controller.

00:54:31.220 --> 00:54:32.750
The controller might make the view.

00:54:32.750 --> 00:54:35.350
The view might have some subviews.

00:54:35.350 --> 00:54:41.240
Another rule that I might have is that models never
own views directly, except through controllers,

00:54:41.240 --> 00:54:44.010
and that views never own model or controllers.

00:54:44.010 --> 00:54:50.340
It's always that direction which is going from the
model to the view, that sort of ownership direction goes

00:54:50.340 --> 00:54:53.020
from one side to the other and never back.

00:54:53.020 --> 00:54:57.160
And, again, that might make sense for my application.

00:54:57.160 --> 00:55:04.410
So, now, here's a kind of an interesting
question for a little bit of detail.

00:55:04.410 --> 00:55:06.180
Delegates are unretained.

00:55:06.180 --> 00:55:10.300
I mean, if you go and, particularly, if you're new to
the platform, and you discover this, and you see this,

00:55:10.300 --> 00:55:12.170
you might say, "Well, isn't this a problem?"

00:55:12.170 --> 00:55:15.960
I mean, maybe I'm going to have crashes in my system,

00:55:15.960 --> 00:55:21.710
when these unretained pointers get
used after the objects go away.

00:55:21.710 --> 00:55:23.590
Well, here's the strategy for dealing with that.

00:55:23.590 --> 00:55:25.480
Here's why that's not a problem.

00:55:25.480 --> 00:55:28.480
Because the owner is in charge.

00:55:28.480 --> 00:55:30.760
The owner object is in charge.

00:55:30.760 --> 00:55:36.850
So, now, if we go back to this object, and we say
that the controller is the delegate for that view,

00:55:36.850 --> 00:55:45.720
if the controller says, "I'm your delegate," so now
the view, its delegate points back to the controller.

00:55:45.720 --> 00:55:46.780
It's unretained.

00:55:46.780 --> 00:55:47.400
What did you just do?

00:55:47.400 --> 00:55:50.120
Well, you just avoided making a reference cycle, right?

00:55:50.120 --> 00:55:57.230
And this is not a problem, because that view is
not going to live longer than the controller.

00:55:57.230 --> 00:56:03.240
The controller is going to be around for the lifetime of
that view, so there's never going to be an opportunity

00:56:03.240 --> 00:56:07.260
for the view to use that delegate
pointer after its gone stale.

00:56:07.260 --> 00:56:11.630
Right? It's not a problem.

00:56:11.630 --> 00:56:15.500
If you come up with these set of rules,
then think through their implications.

00:56:15.500 --> 00:56:19.480
So, what if you have Nibs?

00:56:19.480 --> 00:56:21.780
Again, the advice here is don't fight the framework.

00:56:21.780 --> 00:56:25.280
So, some rules might UIView controllers own their views.

00:56:25.280 --> 00:56:33.980
Split views own their master and
detail controller, view controllers.

00:56:33.980 --> 00:56:36.710
Views own their subviews.

00:56:36.710 --> 00:56:39.340
And UITextViews do not own their text.

00:56:39.340 --> 00:56:45.200
I know that UITextView has a property on
it, but that's not where the text lives.

00:56:45.200 --> 00:56:49.820
Make sure that that text lives in some model
object somewhere and that the text view,

00:56:49.820 --> 00:56:54.020
when it's holding onto that text, is just displaying it.

00:56:54.020 --> 00:56:58.100
So, a set of rules for taking charge of your object graph.

00:56:58.100 --> 00:57:01.450
Again, you might need to think about sort of custom ways,

00:57:01.450 --> 00:57:08.380
custom rules that make the most
sense for how your application works.

00:57:08.380 --> 00:57:12.240
#10, Coordinate State Changes.

00:57:12.240 --> 00:57:17.850
So, this is all about updating model after user
actions and updating views after models change.

00:57:17.850 --> 00:57:21.250
Again, sort of, kind of going back through
this diagram that I referred to before.

00:57:21.250 --> 00:57:30.270
Oops. So, going back to this diagram and focusing in on
those arrows, how those updates and changes-- wait a minute.

00:57:30.270 --> 00:57:31.350
There we go.

00:57:31.350 --> 00:57:32.960
Oh, it's just jumping straight to the next one.

00:57:32.960 --> 00:57:36.180
Okay, well, focusing in on those arrows.

00:57:36.180 --> 00:57:38.370
Well, of course, now the thing that you don't want

00:57:38.370 --> 00:57:42.700
to do is have those arrows go directly
between the model and the view.

00:57:42.700 --> 00:57:44.420
That's the wrong way.

00:57:44.420 --> 00:57:47.210
Do not cut out the controller.

00:57:47.210 --> 00:57:49.400
Well, why not?

00:57:49.400 --> 00:57:52.930
Well, because your controller might
actually do some important work there.

00:57:52.930 --> 00:57:54.130
A change might come in.

00:57:54.130 --> 00:58:00.400
A user might interact with a view and create
a change that would go into your controller.

00:58:00.400 --> 00:58:08.150
The controller might have some code, custom code to
reject, or delay, or validate a particular change.

00:58:08.150 --> 00:58:09.060
Here's an example.

00:58:09.060 --> 00:58:13.620
If you look at the Stocks application, that
text view, I just typed Apple in there.

00:58:13.620 --> 00:58:19.680
The text view has no knowledge about what's going to
happen next, that there's going to be some network access,

00:58:19.680 --> 00:58:25.860
that a table is going to be populated with a set of multiple
choices, and that the user is going to choose one of them.

00:58:25.860 --> 00:58:31.890
That's going to be the responsibility of the
controller to then turn around and take that change

00:58:31.890 --> 00:58:34.690
and commit it back to the model, as shown here.

00:58:34.690 --> 00:58:40.110
It's the controller's job to take that change
and then go and tell the model about it,

00:58:40.110 --> 00:58:42.130
that the user has actually made a choice.

00:58:42.130 --> 00:58:46.030
So, that's handling changes the right way.

00:58:46.030 --> 00:58:47.370
So, now, going the other way.

00:58:47.370 --> 00:58:51.720
Let's say that-- let's go a different way.

00:58:51.720 --> 00:58:56.140
This is all about, now, handling multiple changes.

00:58:56.140 --> 00:59:02.570
Individual data element change, is there now maybe more
than one aspect of the user interface needs to be updated?

00:59:02.570 --> 00:59:07.250
Again, KVO is a great way to actually make this work.

00:59:07.250 --> 00:59:12.560
And KVC, key-value coding and key-value observing.

00:59:12.560 --> 00:59:18.520
If you have more questions about this, we'll find
people who can give you some answers and some pointers.

00:59:18.520 --> 00:59:26.240
Basically, this is all about using strings, rather
than direct method calls to go and change your model,

00:59:26.240 --> 00:59:32.100
and you can imagine how those strings can be
varied at runtime programmatically, right?

00:59:32.100 --> 00:59:34.340
That's sort of the basis of this technology.

00:59:34.340 --> 00:59:39.960
But now, kind of showing a real
example, going back to this complex view.

00:59:39.960 --> 00:59:41.690
So, I've got this Body 2, everywhere.

00:59:41.690 --> 00:59:48.080
Let's go and say that I change this to
Heading 2, and now those other two places,

00:59:48.080 --> 00:59:51.900
after that change, need to be updated appropriately.

00:59:51.900 --> 00:59:55.560
Again, so this might start in the
inspector, flow into one controller.

00:59:55.560 --> 00:59:57.460
That controller is going to tell the model.

00:59:57.460 --> 01:00:02.820
It's going to then percolate these changes around, and
that controller at the top is actually going to know,

01:00:02.820 --> 01:00:06.820
once the model told it, that it's going to change, it's
like, "No, no, I'm the one who originated the change,

01:00:06.820 --> 01:00:12.590
so I'm not going to actually now start this infinite loop
of changes going all around," which can be a problem.

01:00:12.590 --> 01:00:16.060
I mean, look, I've had bugs like that in my programs, too.

01:00:17.180 --> 01:00:25.060
So, this is a way to sort of master that and prevent
this unintended set of consequences from happening.

01:00:25.060 --> 01:00:31.070
So, MVC is the way to go to manage that.

01:00:31.070 --> 01:00:36.040
So, coordinate state changes, updating
things as changes occur.

01:00:36.040 --> 01:00:37.230
And so there we go.

01:00:37.230 --> 01:00:39.580
There are the 10 best tips ever.

01:00:39.580 --> 01:00:46.780
And so going over them again, learn MVC, use it to divide
your work, don't fight the framework, don't abuse views--

01:00:46.780 --> 01:00:56.280
I'll know, right-- and plan for iPhone and iPad,
loose coupling, choosing the right data model,

01:00:56.280 --> 01:00:59.150
controllers and object graphs, and state changes.

01:00:59.150 --> 01:01:05.910
And it's all about keeping your code flexible and easy
to change, because we want you to make great apps.

01:01:07.350 --> 01:01:10.790
So, here, there's a whole set of related sessions.

01:01:10.790 --> 01:01:15.650
Fortunately, only two of them would
require you to time travel at this point.

01:01:15.650 --> 01:01:23.840
So, which is nice, a couple of nice sessions on
CoreData and understanding Foundation later today.

01:01:23.840 --> 01:01:28.700
And this session will actually be repeated.

01:01:28.700 --> 01:01:33.630
If you liked it, or you want to tell your friends
about it, I'm going to be doing the same show again.

01:01:33.630 --> 01:01:40.870
My devil twin will be on hand to give the repeat
performance tomorrow at 2:00 p.m. in this room.

01:01:40.870 --> 01:01:41.080
That's all.

01:01:41.080 --> 01:01:41.750
Thank you all for coming.

01:01:41.750 --> 01:01:52.980
[applause]

