WEBVTT

00:00:07.860 --> 00:00:09.340
>> Steve Lewallen: Well good morning everyone.

00:00:09.340 --> 00:00:13.700
Thank you for coming to the What's
New with Instruments session.

00:00:13.700 --> 00:00:17.730
My name is Steve Lewallen, I'm
the manager of performance tools here at Apple

00:00:17.730 --> 00:00:20.950
and today we're going to learn
about all what's new in Instruments.

00:00:20.950 --> 00:00:22.270
So let's get started.

00:00:22.270 --> 00:00:26.070
So today we're going to learn about
a new, improved user interface.

00:00:26.070 --> 00:00:29.040
We're also going to talk about
significant recording techniques

00:00:29.040 --> 00:00:32.590
that I think will be very helpful for you all to know.

00:00:32.590 --> 00:00:36.000
And we're going to talk about advancements
to existing Instruments.

00:00:36.000 --> 00:00:41.030
And finally we're going to discuss more
about our significant new Instruments.

00:00:41.030 --> 00:00:44.080
So, let's talk about the UI.

00:00:44.080 --> 00:00:46.580
Front and center in the user interface is the Jump bar.

00:00:46.580 --> 00:00:49.010
This shows you where you are and how you got there.

00:00:49.010 --> 00:00:53.280
It's possibly the most important
UI control in the interface.

00:00:53.280 --> 00:00:59.730
You can use this to switch between Instruments and a
particular trace document and you can use it to switch

00:00:59.730 --> 00:01:02.840
between detail views of a particular instrument.

00:01:02.840 --> 00:01:08.190
And then let's say you focused in on some
important piece of data from one detail view,

00:01:08.190 --> 00:01:11.590
you want to get back to where you came
from, just click anywhere on the Jump bar.

00:01:11.590 --> 00:01:16.370
For example, the previous segment,
that'll take you right back.

00:01:16.370 --> 00:01:22.350
So we've also improved how you can access
the views and see the data in Instruments.

00:01:22.350 --> 00:01:25.280
So now you can collapse away just
about anything you don't want to see.

00:01:25.280 --> 00:01:30.710
Collapse away the track view, collapse away the
Instruments list and configuration panel on the left.

00:01:30.710 --> 00:01:32.380
Collapse away the extended detail view.

00:01:32.380 --> 00:01:36.580
And if that's not enough, you can go
full screen which now has the mini bar.

00:01:36.580 --> 00:01:40.270
If you move your mouse to the top of the screen
the mini bar appears, move it away it goes away.

00:01:40.270 --> 00:01:43.690
Same thing as the rest of the full screen Mac apps.

00:01:43.690 --> 00:01:46.090
And we've also made so many improvements in the call tree,

00:01:46.090 --> 00:01:50.630
I think we can declare it is the coolest call
tree in the universe, if that's possible.

00:01:50.630 --> 00:01:55.080
So to do that the first thing we did is
give you more room for that symbol tree.

00:01:55.080 --> 00:01:57.760
I think that's the most important part of that interface.

00:01:57.760 --> 00:02:05.800
We did that by combining several columns together
and affording more room for the symbol tree itself.

00:02:05.800 --> 00:02:11.600
We also enabled the call tree to
slide under the statistics view.

00:02:11.600 --> 00:02:17.140
So you always had the problem where when you had a node
far to the right and you scrolled and scrolled you got it

00:02:17.140 --> 00:02:21.780
into view and then the statistics scroll off the screen,
you couldn't see how much was attributed to that node.

00:02:21.780 --> 00:02:23.620
So now you can.

00:02:23.620 --> 00:02:31.020
Another problem that people would have in using any outline
view is that it's hard to understand what is a sibling

00:02:31.020 --> 00:02:33.710
of another node or what are the children of a node.

00:02:33.710 --> 00:02:36.320
So we added what we call sibling banding.

00:02:36.320 --> 00:02:40.770
So you select a node and you'll see this vertical band
appear and then you can scroll up and down as much

00:02:40.770 --> 00:02:44.290
as you want and rest assured that
anything to the right of that band is going

00:02:44.290 --> 00:02:47.250
to be a child node within the selected hierarchy.

00:02:47.250 --> 00:02:53.450
And of course, when you move your mouse over the nodes,
you also get a highlighting sibling band as well.

00:02:53.450 --> 00:02:58.110
We also added, as with Xcode 4,
backtrace compression filtering.

00:02:58.110 --> 00:03:00.250
This is really handy.

00:03:00.250 --> 00:03:05.750
Basically, this allows you to use the slider
you find at the bottom of the back trace,

00:03:05.750 --> 00:03:10.150
to collapse library boundaries down to just your own code.

00:03:10.150 --> 00:03:14.690
So you can see what called your code
and then focus on your frames itself.

00:03:14.690 --> 00:03:15.740
Very handy.

00:03:15.740 --> 00:03:21.600
And of course we have the source view, where we
have performance data in line with the source.

00:03:21.600 --> 00:03:26.250
What we've done with the latest release is allow
you to access this directly from other data views.

00:03:26.250 --> 00:03:33.360
So for example, in the picture before you, we're on the call
tree view, if we double-click on this Create New Game API,

00:03:33.360 --> 00:03:36.730
that will move into the Jump bar
and the source view will come in.

00:03:36.730 --> 00:03:40.030
To go back to the call tree, just
click one of the items in the Jump bar.

00:03:40.030 --> 00:03:41.500
Very simple.

00:03:41.500 --> 00:03:44.270
And of course, all the annotations are colored by severity.

00:03:44.270 --> 00:03:49.460
So you want to pay most attention, soonest,
to those things colored the darkest.

00:03:49.460 --> 00:03:53.860
And we also have full disassembly
view, both for Intel and ARM

00:03:53.860 --> 00:03:57.140
and we still include the performance
annotations in those views.

00:03:57.140 --> 00:04:00.550
You can see this by function or
you can see it per annotation.

00:04:00.550 --> 00:04:05.510
So if you want to see just the disassembly
for the line of annotation, you can do that.

00:04:05.510 --> 00:04:06.810
And we have timeline views.

00:04:06.810 --> 00:04:10.020
You can think of these as bookmarks for the trace document.

00:04:10.020 --> 00:04:11.650
You can add these manually yourself.

00:04:11.650 --> 00:04:15.050
So you see something important
happen, you want to remember it later.

00:04:15.050 --> 00:04:19.140
You Option-click in the ruler and add your own flag.

00:04:19.140 --> 00:04:26.280
We also had Instrument, last year the Zombie's instrument
which detects when over-released objects are messaged.

00:04:26.280 --> 00:04:30.710
We had that add its own timeline flag itself automatically.

00:04:30.710 --> 00:04:40.990
And now in the latest iPhone OS 4.0 SDK, we show
multistate app transitions in the ruler as well.

00:04:40.990 --> 00:04:45.550
So when your app goes from being running in the
foreground to transitioning to the background running

00:04:45.550 --> 00:04:50.480
and then suspended in the background, etcetera, you can
see flags for those and that will explain to you later

00:04:50.480 --> 00:04:56.570
when you look at this trace document, a week from then
you know, why CPU activity dropped off, for example.

00:04:56.570 --> 00:05:00.840
Well it's because it became suspended in the background.

00:05:00.840 --> 00:05:07.010
So now let's go and take a look at a demo of Instruments
and we'll just sort of learn our way around Instruments

00:05:07.010 --> 00:05:10.570
and solve a couple of problems using
a couple of very common instruments.

00:05:10.570 --> 00:05:12.900
So I'm going to go over to my computer here.

00:05:12.900 --> 00:05:15.160
Let me go to the demo machine.

00:05:15.160 --> 00:05:16.780
All right.

00:05:16.780 --> 00:05:24.230
So a colleague of mine has been writing a reader
app and I liked it so much I was using it,

00:05:24.230 --> 00:05:31.350
but I wanted it to remember the state that it had,
the book I was reading and the place within the book

00:05:31.350 --> 00:05:34.910
and restore that the next time I launched the app.

00:05:34.910 --> 00:05:38.300
So I went ahead and did that and let's
just see how that looks in the simulator.

00:05:38.300 --> 00:05:41.460
So here it is, it restored the state.

00:05:41.460 --> 00:05:49.030
If I go somewhere else, pick a different
book here, scroll up to the title.

00:05:49.030 --> 00:05:53.670
We'll quit that and I'll click it
again and it restores its state back.

00:05:53.670 --> 00:05:55.220
So this is great.

00:05:55.220 --> 00:05:56.040
This is awesome.

00:05:56.040 --> 00:06:01.680
I'm so excited, I'm just ready to
push this to the App Store right away.

00:06:01.680 --> 00:06:04.720
But I've only tested this on the simulator.

00:06:04.720 --> 00:06:09.250
What I really should do is test this on the device as
well, because the performance on the device is going

00:06:09.250 --> 00:06:12.970
to be different than the performance on a desktop computer.

00:06:12.970 --> 00:06:19.790
So let me quit the app and let's switch
to the iPhone in WolfVision here.

00:06:19.790 --> 00:06:29.580
I'll switch the device, build and run and it's compiling,
linking, installing the app and still there it is.

00:06:29.580 --> 00:06:31.800
And boy that's taking a long time.

00:06:31.800 --> 00:06:33.840
OK, there's my app.

00:06:33.840 --> 00:06:39.630
Well clearly the performance characteristics on start up was
very different on the device than it was in the simulator.

00:06:39.630 --> 00:06:43.840
So, back to the demo machine please.

00:06:43.840 --> 00:06:51.750
What I want to do is to use the Time Profiler, new in
iPhone 4.0 SDK and to see why that's taking so long.

00:06:51.750 --> 00:06:56.550
So let me go to Instruments and
by the way, don't get confused.

00:06:56.550 --> 00:06:57.800
There are two sets of tools here.

00:06:57.800 --> 00:07:03.040
One is the latest SDK tool set that shipped
and one is the Xcode for our preview.

00:07:03.040 --> 00:07:05.090
We'll be using both in this session.

00:07:05.090 --> 00:07:15.400
So let me open the shipping version of Instruments
here and I am going to time profile the reader app.

00:07:15.400 --> 00:07:20.240
So I will go up to my iPhone section
and double-click on Time Profiler

00:07:20.240 --> 00:07:24.940
and I will pick my little reader app and let's start it up.

00:07:24.940 --> 00:07:28.810
And when this, when the page displays
on the phone, I'm going to stop this.

00:07:28.810 --> 00:07:30.230
So there we go.

00:07:30.230 --> 00:07:35.210
So let's see what's taking so long in this code.

00:07:35.210 --> 00:07:39.150
So the first thing I want to do
is I want to focus in on my code.

00:07:39.150 --> 00:07:44.220
So what I like to do first is hide system
libraries and maybe hide any missing symbols I have.

00:07:44.220 --> 00:07:49.390
And then I will focus in on this
text view controller viewDidLoad,

00:07:49.390 --> 00:07:52.000
that seems to be taking up an enormous amount of time.

00:07:52.000 --> 00:07:55.390
And I can see, I come to main and the view is loading.

00:07:55.390 --> 00:08:03.000
Oh, this is where I'm actually restoring that state and
we come into viewDidLoad, let me double-click on that

00:08:03.000 --> 00:08:09.760
and move this over some, ah, so I'm taking the contents
of the book and I'm setting it on the text view.

00:08:09.760 --> 00:08:14.430
Hmmm, well there's nothing really I can do about that.

00:08:14.430 --> 00:08:17.910
I mean, I could, I could spend the time
during today, tomorrow and the next day,

00:08:17.910 --> 00:08:21.010
re-architecting my app, but we don't' have time for that.

00:08:21.010 --> 00:08:27.040
So what I'd really like to do and what's common when you
have an app that requires a lot of start up preparation,

00:08:27.040 --> 00:08:30.690
is it's a great thing to make it a background app.

00:08:30.690 --> 00:08:32.320
So let's go ahead and do that.

00:08:32.320 --> 00:08:34.530
I'm going to quit Instruments here.

00:08:34.530 --> 00:08:39.420
The first thing I need to do is go to my Info.plist
and I'm going to say that actually I do want this

00:08:39.420 --> 00:08:42.150
to run in the background and I'll save that.

00:08:42.150 --> 00:08:48.010
And then, in case I've switched to the background and
for whatever reason the system had to terminate my app,

00:08:48.010 --> 00:08:51.350
I want to make sure that I capture the
state that I currently have in there.

00:08:51.350 --> 00:08:54.280
What book I'm reading again and where I am in that book.

00:08:54.280 --> 00:09:00.600
So let me go to my delegate and just like I did earlier,
where I had already added save application state

00:09:00.600 --> 00:09:05.340
and application will terminate, I want to do
that when I'm doing it from the background.

00:09:05.340 --> 00:09:17.320
So let me say self save application state and save and
I'll build and run again and we can see how this works out.

00:09:17.320 --> 00:09:24.860
So let's go back to the device in WolfVision there and it's
running and of course we haven't solved the initial start

00:09:24.860 --> 00:09:28.510
up cost, but let's see how backgrounding works for us.

00:09:28.510 --> 00:09:31.020
OK, the app has started.

00:09:31.020 --> 00:09:36.950
So what I'm going to do now is click the Home button,
it's gone to the background and make it come back.

00:09:36.950 --> 00:09:37.370
Excellent.

00:09:37.370 --> 00:09:39.180
So it comes back very quickly.

00:09:39.180 --> 00:09:41.640
That's a much better user experience.

00:09:41.640 --> 00:09:44.560
So we can go back to the demo machine again.

00:09:44.560 --> 00:09:46.390
So now I'm ready to ship my app right?

00:09:46.390 --> 00:09:51.820
I mean, all I did was take an API used in one place and
just used it somewhere else that I never really intended it

00:09:51.820 --> 00:09:57.790
to be used for and this is going to run all the time
now in the background, but what could go wrong right.

00:09:57.790 --> 00:10:03.980
Well, if it's running in the background, I have a
responsibility to make sure I control my memory overhead.

00:10:03.980 --> 00:10:07.220
I don't want to be leaking any memory for example.

00:10:07.220 --> 00:10:11.620
So I doubt there's any leaks, but let's check anyway.

00:10:11.620 --> 00:10:16.230
So we'll just stay on the demo machine and
another way that you can run Instruments

00:10:16.230 --> 00:10:18.580
against your app, is actually from Xcode itself.

00:10:18.580 --> 00:10:21.560
So I go up to run with performance tool, down to leaks.

00:10:21.560 --> 00:10:29.200
And this will start up the app, start up Instruments on
the device, etcetera and we'll see if we have any leaks.

00:10:29.200 --> 00:10:32.290
So the first thing I'm going to do
is disable automatic leaks checking.

00:10:32.290 --> 00:10:37.130
Leaks is automatically set up to do this every
ten seconds or so, but I want to make this go back

00:10:37.130 --> 00:10:39.450
and forth on the phone a little bit before we do that.

00:10:39.450 --> 00:10:44.670
So I'm going to just keep you eye on the Mac here, but I'm
going to make that device, the app go to the background

00:10:44.670 --> 00:10:49.380
and bring it to foreground, maybe do that a couple of times.

00:10:49.380 --> 00:10:53.260
OK. And now let's check for leaks.

00:10:53.260 --> 00:11:00.430
It's analyzing the process here and that just takes a
little bit of time as it goes over, oh I do have a leak.

00:11:00.430 --> 00:11:02.020
Who would have thought?

00:11:02.020 --> 00:11:05.390
OK, well what I want to do now is stop the trace.

00:11:05.390 --> 00:11:08.040
I want to investigate these leaks.

00:11:08.040 --> 00:11:11.000
So what I can do is focus in on one of them.

00:11:11.000 --> 00:11:16.890
When you see one of these circles with an arrow in them, in
the table views and in ally views, those are Focus buttons.

00:11:16.890 --> 00:11:22.750
So if I click on one of those, I'm going to see that
the address I focused on is now added to the Jump bar.

00:11:22.750 --> 00:11:27.330
And so for example, if I wanted to go back to the
view I was at, I just go up to the Jump bar once,

00:11:27.330 --> 00:11:30.710
to this leaks blocks element, I click it and I'm back.

00:11:30.710 --> 00:11:31.930
Let's go and investigate that leak.

00:11:31.930 --> 00:11:37.070
So let's focus in again and let
me open the extended detail view.

00:11:37.070 --> 00:11:44.200
And now let me actually use a stack
compression to focus in on just my own code.

00:11:44.200 --> 00:11:47.280
Great. So now I can see really just my own code.

00:11:47.280 --> 00:11:51.650
If we zoom in here we can see,
oh the leak is actually coming

00:11:51.650 --> 00:11:54.310
from the saveapplicationstate [assumed spelling] call.

00:11:54.310 --> 00:11:57.030
Hum, well I better take a look at that.

00:11:57.030 --> 00:12:01.260
Let me double-click on it and I
put my extended detail view away.

00:12:01.260 --> 00:12:02.810
Let's focus in again.

00:12:02.810 --> 00:12:04.700
So what's going on here?

00:12:04.700 --> 00:12:09.010
Well, we're seeing where we have
different things that are being leaked

00:12:09.010 --> 00:12:12.500
and I have this top level object called
my restored data, what's going on there?

00:12:12.500 --> 00:12:15.860
Let me see, did I not release that.

00:12:15.860 --> 00:12:20.960
So there's another use of it, said object
from my restore data, set object again,

00:12:20.960 --> 00:12:23.150
set object, using it to register defaults.

00:12:23.150 --> 00:12:24.650
Oh, there's no release.

00:12:24.650 --> 00:12:27.290
OK, so now I need to go and I need to fix that.

00:12:27.290 --> 00:12:35.430
So let me hit the Xcode button here in Instruments
and go back to that code and I'm just going to go

00:12:35.430 --> 00:12:45.800
and add a quick my restore data release and I
will do a little trick here just to get it back

00:12:45.800 --> 00:12:50.070
on the device, build and install and run it here.

00:12:50.070 --> 00:12:51.790
And then we'll stop that.

00:12:51.790 --> 00:12:59.040
Now another way to obviously, we'll just wait
for it to completely terminate on the device.

00:12:59.040 --> 00:13:06.050
OK, so we'll go back to the run with
performance tools menu and we'll say leaks again.

00:13:06.050 --> 00:13:12.430
This will re-use the existing Instruments
document it was using for leaks and now I will go

00:13:12.430 --> 00:13:15.880
and do the background, foreground exercise again.

00:13:15.880 --> 00:13:19.870
Do it a couple times, few times there.

00:13:19.870 --> 00:13:23.220
And we will check for leaks again.

00:13:23.220 --> 00:13:26.100
Analyzing the process.

00:13:26.100 --> 00:13:27.820
Excellent, no leaks.

00:13:27.820 --> 00:13:32.550
So now I think that the app is in
better shape to go to the app store.

00:13:32.550 --> 00:13:36.840
I should still add a splash screen and continue
on with the refinements, but it's better.

00:13:36.840 --> 00:13:41.540
Now I do want to draw your attention
quickly to what is in the ruler bar.

00:13:41.540 --> 00:13:42.280
These icons here.

00:13:42.280 --> 00:13:45.390
These are those state transition flags I told you about.

00:13:45.390 --> 00:13:52.050
So if I click on one of these, I can see that it will
tell me that the reader switched to the background running

00:13:52.050 --> 00:13:58.700
and if I navigate over I can see when it came back to
the foreground and we see all of these state transitions.

00:13:58.700 --> 00:14:03.880
So that again, is very useful, especially when you go
back later and try to understand why you saw a change

00:14:03.880 --> 00:14:05.820
in performance data that you're gathering.

00:14:05.820 --> 00:14:10.460
You can say oh, it was in the background
and suspended and so that's why.

00:14:10.460 --> 00:14:15.460
OK? So that is a brief exercise.

00:14:15.460 --> 00:14:20.320
If we can switch back to the slides, in using
Instruments and how you get around in it.

00:14:20.320 --> 00:14:25.710
The major controls, the Jump bar, back trace
compression, using Instruments to target an app directly

00:14:25.710 --> 00:14:30.500
from Instruments itself, as well as from
the Xcode run with performance tools menu.

00:14:30.500 --> 00:14:35.510
And of course, two of the most important I think,
Instruments we have, the Time Profiler to see

00:14:35.510 --> 00:14:39.920
where you're spending your time and the leaks
instrument to see if you're leaking any data.

00:14:39.920 --> 00:14:42.440
So you should get to know both of those instruments.

00:14:42.440 --> 00:14:47.980
So moving on, I think that in this
latest release of Instruments,

00:14:47.980 --> 00:14:51.260
we have the greatest, the most efficient Instruments ever.

00:14:51.260 --> 00:14:56.580
And we provide you the greatest latitude
ever on how you do you recording.

00:14:56.580 --> 00:15:01.170
So first let's talk about what we
call immediate versus deferred.

00:15:01.170 --> 00:15:04.190
So immediate mode is this classic Instrument's mode.

00:15:04.190 --> 00:15:09.140
You hit the Recording button and instruments
processes and displays the data immediately.

00:15:09.140 --> 00:15:14.010
And what's great about this is that you can tinker with
your device, or you're in a game, you shoot off a missile,

00:15:14.010 --> 00:15:19.370
there's an explosion and you can see the CPU usage spike
immediately, you can see the frame rates change immediately.

00:15:19.370 --> 00:15:24.270
So you it gives you that immediate feedback and you
know in that data set, exactly what you want to look at.

00:15:24.270 --> 00:15:30.180
But the down side is that hey, Instruments is running on
the same computer and it's using some of the CPU, too.

00:15:30.180 --> 00:15:36.900
So sometimes, especially for sampling instruments, like
Time Profiling, you may and this is an exaggerated graph,

00:15:36.900 --> 00:15:39.460
but you may get gaps or valleys in your data collection.

00:15:39.460 --> 00:15:42.620
You data collection isn't as packed
tightly as you'd like it to be.

00:15:42.620 --> 00:15:45.950
So that's why we added a mode we call deferred mode.

00:15:45.950 --> 00:15:50.330
Deferred mode processes and displays
data after the recording is over.

00:15:50.330 --> 00:15:56.200
So the benefit is, Instruments stays off the
CPU, it's not doing anything until you hit Stop

00:15:56.200 --> 00:15:58.450
and then it consumes and displays all that data.

00:15:58.450 --> 00:16:04.810
The down side is of course that it's hard for you to
correlate that when you, you know, when you shot missile one

00:16:04.810 --> 00:16:09.670
versus drop bomb, which of those
corresponded to the big frame rate drop.

00:16:09.670 --> 00:16:11.900
So you have to judge what you're going to use.

00:16:11.900 --> 00:16:18.600
But with deferred mode you'll get more tightly packed
samples and data set and that can be very useful

00:16:18.600 --> 00:16:24.070
when you're looking at something
that's very, very time sensitive.

00:16:24.070 --> 00:16:30.080
So when you launch your apps, we've had various
options but we didn't have them in a very good place

00:16:30.080 --> 00:16:32.530
in the UI, so we've moved them to the targets user.

00:16:32.530 --> 00:16:36.080
One of the options is to choose where
you want your standard I/O to go.

00:16:36.080 --> 00:16:41.240
So you can have it go to the Instruments console
or the system console or you can just discard it.

00:16:41.240 --> 00:16:46.040
Maybe you have a very, very chatty app and
you don't want the system overloaded with all

00:16:46.040 --> 00:16:48.230
that I/O, so you can just discard it completely.

00:16:48.230 --> 00:16:56.750
And on the Mac, if you have a 32, 64 bit capable app,
you may want to run it in 64 bit mode and 32 bit mode,

00:16:56.750 --> 00:17:01.720
especially if it's using a lot of memory, a
large address space, to see how it performs.

00:17:01.720 --> 00:17:02.970
So you have those controls.

00:17:02.970 --> 00:17:05.070
In the simulator, you sort have similar control.

00:17:05.070 --> 00:17:10.540
So you can change where your console I/O goes, but you
can also say what kind of device you want the simulator

00:17:10.540 --> 00:17:13.770
to simulate and what kind of SDK you want it to use.

00:17:13.770 --> 00:17:16.940
So that's very helpful to know as well.

00:17:16.940 --> 00:17:20.080
Now if you're on Mac OS X and you're
developing launch agents, agents or daemons,

00:17:20.080 --> 00:17:27.110
which are little headless services that you can have on
the Mac, it's always been a problem to be able to analyze

00:17:27.110 --> 00:17:33.140
that primordial start up segment of time when
the daemon is first hooking up to everything.

00:17:33.140 --> 00:17:35.860
A lot of times that can be the
most interesting thing to look at.

00:17:35.860 --> 00:17:37.230
Does it leak any memory right there?

00:17:37.230 --> 00:17:39.660
You know, what's going on with CPU usage right there?

00:17:39.660 --> 00:17:46.090
So what we did was connate tightly with launchd,
so that Instruments can start analyzing the app

00:17:46.090 --> 00:17:48.390
as soon as it's created by launchd itself.

00:17:48.390 --> 00:17:54.380
This is exactly the same amount of data you'd collect if
you'd actually launched an app directly from Instruments.

00:17:54.380 --> 00:17:55.230
So how do you do this?

00:17:55.230 --> 00:17:58.930
Well you go to the targets user and
you pick the daemon or agent.plist.

00:17:58.930 --> 00:18:01.100
The plist, not the actual binary.

00:18:01.100 --> 00:18:05.910
Because Instruments needs to read
that plist and find out some things.

00:18:05.910 --> 00:18:09.240
Then you hit Record and you'll get
a dialog like this on the screen.

00:18:09.240 --> 00:18:14.560
Basically Instruments is saying, OK go do whatever it is
you have to do to tickle launchd to launch your daemon.

00:18:14.560 --> 00:18:19.310
Maybe it is connecting up a network or creating
a file somewhere or something of that sort.

00:18:19.310 --> 00:18:23.540
As soon as that happens, this dialog will go away
and Instruments will start recording right away.

00:18:23.540 --> 00:18:26.860
So you've gathered all that critical data.

00:18:26.860 --> 00:18:31.290
And let's also talk about wireless, for the phone.

00:18:31.290 --> 00:18:36.940
So it's possible for you to actually use
Instruments, to profile your apps running

00:18:36.940 --> 00:18:39.780
on the phone, without being connected to USB.

00:18:39.780 --> 00:18:41.890
So why would you want to do this?

00:18:41.890 --> 00:18:45.740
Well it frees up the USB port if
you're an accessory developer.

00:18:45.740 --> 00:18:51.590
Let's say you're developing something for an automobile
manufacturer, some docking station or something of that sort

00:18:51.590 --> 00:18:56.180
and you want to see the performance of the
app when you connect that accessory up.

00:18:56.180 --> 00:19:02.710
Or let's say that you're a game developer and
you're using that accelerometer and it's a real pain

00:19:02.710 --> 00:19:09.490
when you're testing your game aggressively and that cable
is slapping you in the head as you're moving it around and

00:19:09.490 --> 00:19:12.360
or it's in your way as you grab the
device and making it very awkward.

00:19:12.360 --> 00:19:13.590
You just go wireless.

00:19:13.590 --> 00:19:14.580
Disconnect it from USB.

00:19:14.580 --> 00:19:17.330
It's much easier to do.

00:19:17.330 --> 00:19:22.100
Now there's one thing that you need to remember when you
go home or go back to your workplace and you try this,

00:19:22.100 --> 00:19:24.670
if it doesn't work the first thing
you need to do is make sure

00:19:24.670 --> 00:19:28.350
that you have Bonjour multitask
enabled, on your Wi-Fi point.

00:19:28.350 --> 00:19:29.670
If you don't, it's not going to work.

00:19:29.670 --> 00:19:33.540
Now to find out how to do that, just refer
to the standard Bonjour documentation.

00:19:33.540 --> 00:19:37.460
There's isn't anything iPhone- or
Instrument-specific about that.

00:19:37.460 --> 00:19:39.760
So how do you enable this?

00:19:39.760 --> 00:19:45.080
Well, you hold down the Option key while you go to
the targets user and you'll see your device appear,

00:19:45.080 --> 00:19:48.020
but it'll have Enable Your Device Name Wireless.

00:19:48.020 --> 00:19:51.830
So you select that and then you'll see your
device appear but it will be kind of grayed out.

00:19:51.830 --> 00:19:58.710
Because it's handshaking with your machine and getting
everything set up and a second or two later it's ready

00:19:58.710 --> 00:20:04.260
and then at this point you have not one, but
two Instruments daemon's running on your device.

00:20:04.260 --> 00:20:07.500
You have one dedicated to USB and
you have one dedicated to wireless.

00:20:07.500 --> 00:20:10.290
See you don't want that because
they're both using resources.

00:20:10.290 --> 00:20:16.520
So you want to unplug your USB and when you do that
the USB-dedicated Instrument's daemon will go away,

00:20:16.520 --> 00:20:22.330
you'll see that item disable and now you can just go
completely wireless and you can do everything you can do

00:20:22.330 --> 00:20:26.040
with Instruments normally over USB, wirelessly.

00:20:26.040 --> 00:20:31.930
Of course your performance will vary based on
the performance of your Wi-Fi hotspot, etcetera.

00:20:31.930 --> 00:20:34.200
But it's a very handy thing to do.

00:20:34.200 --> 00:20:40.070
Now when you want to disable this,
because again, it is taking up you know,

00:20:40.070 --> 00:20:44.370
radio resources and it's not quite as fast as USB.

00:20:44.370 --> 00:20:47.280
Just hold down the Option key, go back to the target chooser

00:20:47.280 --> 00:20:50.930
and the menu item will change into
Disable Your Device Named Wireless.

00:20:50.930 --> 00:20:52.100
Select that and it will go away.

00:20:52.100 --> 00:20:57.120
At this point, the only way to get it back is
to connect up USB, so that you can re-enable it.

00:20:57.120 --> 00:21:02.550
Another way to disable it is actually
to just reboot your device.

00:21:02.550 --> 00:21:04.350
And so now we'll just do a wireless demo.

00:21:04.350 --> 00:21:06.990
I really don't think so.

00:21:06.990 --> 00:21:08.510
No wireless demo, not today.

00:21:08.510 --> 00:21:12.370
Actually I did have a slide for
that, but not today any longer.

00:21:12.370 --> 00:21:16.310
So let's move on to symbolication.

00:21:16.310 --> 00:21:18.740
Well Steve, wireless, Steve.

00:21:18.740 --> 00:21:25.660
So often when you take a trace,
it has to do with your own code.

00:21:25.660 --> 00:21:32.270
There are instruments actually in the app that don't have
anything to do with actual code, but most of them do.

00:21:32.270 --> 00:21:36.990
And what's very critical on that is to have
Instruments be able to switch those hex addresses

00:21:36.990 --> 00:21:39.600
into real symbol names, like a function name.

00:21:39.600 --> 00:21:44.700
In order to do that, Instruments will look
in SDK paths to find a symbol-rich data

00:21:44.700 --> 00:21:48.000
and it will also use Spotlight to look it up.

00:21:48.000 --> 00:21:54.290
In order for Spotlight to help us find your symbol-rich
binaries, you need to make sure you build your app,

00:21:54.290 --> 00:21:57.040
whether it's for the phone or for
the Mac, DWARF with dSym file.

00:21:57.040 --> 00:22:03.230
So just go to your debug settings and probably, it
might say DWARF, switch it to DWARF with dSym file.

00:22:03.230 --> 00:22:08.400
Now, if you do that, you need to still
make sure that it's visible to Spotlight.

00:22:08.400 --> 00:22:10.430
Spotlight won't look in any encrypted disk image

00:22:10.430 --> 00:22:13.810
and you might have Spotlight already
set to not look at certain volumes.

00:22:13.810 --> 00:22:17.460
So you need to make sure Spotlight
is looking in that location.

00:22:17.460 --> 00:22:24.320
Now if you don't have any symbols, maybe someone else took
a trace, they didn't have all the symbol-rich binaries

00:22:24.320 --> 00:22:31.490
and they handed it to you or you did find
yourself in a situation where, pardon me,

00:22:31.490 --> 00:22:34.300
where Spotlight could not find the binaries.

00:22:34.300 --> 00:22:36.340
You can always resymbolicate them after the fact.

00:22:36.340 --> 00:22:37.220
It's very simple to do.

00:22:37.220 --> 00:22:40.150
Go to the file menu, select resymbolicate document.

00:22:40.150 --> 00:22:41.560
You'll see a sheet pop down.

00:22:41.560 --> 00:22:47.840
You select the paths that point to the right symbol-rich
binaries or directories and we'll recursively look

00:22:47.840 --> 00:22:51.480
in all those and then you just click symbolicated.

00:22:51.480 --> 00:22:52.130
It's that easy.

00:22:52.130 --> 00:22:54.760
Oh and turn all the hex addresses into symbols.

00:22:54.760 --> 00:23:01.720
And then I'd like to make one note about
tracing, using Instruments against apps

00:23:01.720 --> 00:23:06.780
in the iPhone 4.0 SDK, just because it's hit us.

00:23:06.780 --> 00:23:10.780
We've all got accustomed to this, so
I hit the Home button, my app quits.

00:23:10.780 --> 00:23:13.070
Instruments stops if I was tracing with it.

00:23:13.070 --> 00:23:17.700
But now it may no longer terminate the app
right, the app may just go to the background

00:23:17.700 --> 00:23:20.540
and Instruments will dutifully keep tracing.

00:23:20.540 --> 00:23:25.700
So what you need to do is just get in the habit
of stopping the app from Instruments itself.

00:23:25.700 --> 00:23:27.750
Pressing that Stop button.

00:23:27.750 --> 00:23:33.210
If, another issue that you can run into is that you're
actually debugging your app and you hit the Home button

00:23:33.210 --> 00:23:37.260
and you forget you did that and you try to trace
with Instruments and Instruments is going to put

00:23:37.260 --> 00:23:40.430
up an error saying the debugger has control of this process.

00:23:40.430 --> 00:23:44.020
So what you need to do is also remember
that when you're using the debugger,

00:23:44.020 --> 00:23:49.380
to hit the Stop button as well before
you use Instruments against the same app.

00:23:50.810 --> 00:23:54.800
So we've made various improvements to our
existing instrumentation we've had for a while

00:23:54.800 --> 00:23:57.170
and I want to go over those improvements.

00:23:57.170 --> 00:23:59.510
So first is Time Profiler.

00:23:59.510 --> 00:24:06.690
This is for both platforms and it's the most
efficient time profiling mechanism by far that we have.

00:24:06.690 --> 00:24:09.340
It does everything from the kernel.

00:24:09.340 --> 00:24:12.690
Takes its samples in the kernel
and you can use it in two ways.

00:24:12.690 --> 00:24:15.470
By default, you're looking at running threads.

00:24:15.470 --> 00:24:17.430
So you're just looking for code that is running

00:24:17.430 --> 00:24:20.810
but it's not running very efficiently,
so you want to find those hotspots.

00:24:20.810 --> 00:24:24.810
But you can also use it to track
down and all thread states mode.

00:24:24.810 --> 00:24:28.290
You go to its inspector and click All Thread States.

00:24:28.290 --> 00:24:30.500
So it can find threads that are blocked.

00:24:30.500 --> 00:24:37.290
So maybe you have a choppy app or it's
deadlocking somewhere, you switch Time Profiler

00:24:37.290 --> 00:24:40.470
to All Thread States and you'll find those threads as well.

00:24:40.470 --> 00:24:45.300
And of course, it can also see all processes
on the system, not just a single process.

00:24:45.300 --> 00:24:49.960
So that's really nice when you want to see you
know, what in the world is going on in the system?

00:24:49.960 --> 00:24:51.120
Why is it so slow?

00:24:51.120 --> 00:24:56.530
You use all processes and you can
see who the guilty party is.

00:24:56.530 --> 00:25:03.900
So we've also added kernel frames to the
back tracing and call tree Time Profiler.

00:25:03.900 --> 00:25:05.440
And we did this in a really cool way.

00:25:05.440 --> 00:25:11.280
Because you can see, but logical way,
you can see the user space stack frames,

00:25:11.280 --> 00:25:14.830
but in a continuous line then you see the kernel space.

00:25:14.830 --> 00:25:20.310
So you see yourself transitioning all the way from user
space, into the kernel and maybe into some kernel extension.

00:25:20.310 --> 00:25:23.580
It's really kind of far out to see
it when we finally put that together.

00:25:23.580 --> 00:25:24.220
It's really awesome.

00:25:24.220 --> 00:25:29.340
If you're a kernel extension developer,
it'll be really important to you.

00:25:29.340 --> 00:25:36.760
And of course, Time Profiler, as we saw a moment
ago, is also available on the iPhone 4.0 SDK.

00:25:36.760 --> 00:25:43.950
And it's far more efficient than CPU sampler that you
were using before and it doesn't really seem intuitive,

00:25:43.950 --> 00:25:47.570
but deferred mode really matters
for tracing the device as well.

00:25:47.570 --> 00:25:53.100
Now of course, when you're in immediate mode
on the Mac, you have Instruments running

00:25:53.100 --> 00:25:56.910
and you have your target process running,
obviously they're fighting over the same CPU,

00:25:56.910 --> 00:26:01.000
but the reason that it matters even on the device,
when Instruments is still running on your Mac,

00:26:01.000 --> 00:26:06.610
is that if you're in immediate mode that Instruments
daemon on the device has to take that data

00:26:06.610 --> 00:26:09.530
out of the buffers we're collecting it in, package it up,

00:26:09.530 --> 00:26:12.850
send it over the wire, over wireless
and all that takes cycles.

00:26:12.850 --> 00:26:18.750
So it makes a big difference by putting your trace in
deferred mode before you take it for the phone as well

00:26:18.750 --> 00:26:24.160
and significantly proportionately more than it
actually makes on the Mac and that will hold

00:26:24.160 --> 00:26:30.100
on to those data buffers unless we fill them up, in which
case we want to get rid of them, get them onto the Mac,

00:26:30.100 --> 00:26:36.770
so we don't constrain the memory that your own
app needs or you hit Stop on the recording.

00:26:36.770 --> 00:26:41.380
So deferred mode really does matter,
even for device time profiling.

00:26:41.380 --> 00:26:45.510
So we've also added a new instrument
called HeapShots and HeapShots,

00:26:45.510 --> 00:26:48.800
well actually it's a feature of
Allocations Instruments, pardon me.

00:26:48.800 --> 00:26:53.210
HeapShots will actually allow you to
track down what we call abandoned memory.

00:26:53.210 --> 00:26:56.270
We call it abandoned because it's
not leaked, but you allocated it,

00:26:56.270 --> 00:26:59.680
maybe you used it once long ago
and you basically abandoned it.

00:26:59.680 --> 00:27:00.650
You forgot all about it.

00:27:00.650 --> 00:27:04.310
There it sits, still referenced, you
run leaks, you're not going to see it

00:27:04.310 --> 00:27:07.330
but it's taking up space until you quit your app.

00:27:07.330 --> 00:27:12.640
We find that this can be an even more serious
problem than leaked memory and if you have an app

00:27:12.640 --> 00:27:17.780
that maybe you didn't first develop or that's
several years old, this will start to build up.

00:27:17.780 --> 00:27:22.970
Because someone, somewhere, wrote some caching
routine for a feature that has since been removed,

00:27:22.970 --> 00:27:24.700
but no one knew about the caching routine.

00:27:24.700 --> 00:27:28.150
It's been dutifully caching away its
memory and not being used at all.

00:27:28.150 --> 00:27:29.380
So that's a waste.

00:27:29.380 --> 00:27:35.930
So you want to, you want to analyze your app using
the HeapShot technique, to find that abandoned memory.

00:27:35.930 --> 00:27:37.920
We also have VM tracker.

00:27:37.920 --> 00:27:42.450
This allows you to look at your VM usage
of your app on the Mac, in the phone.

00:27:42.450 --> 00:27:46.130
And again it's part of allocations
template, as a separate instrument.

00:27:46.130 --> 00:27:53.870
You can identify, it identifies reasons by tag and
you can look at things like resident and virtual size.

00:27:53.870 --> 00:27:59.250
And this is great to use against a Core Animation app
or something where you're loading images off a disk

00:27:59.250 --> 00:28:03.010
and you can associate how much memory
that's taking with the actual file on disk.

00:28:03.010 --> 00:28:05.140
So that's very cool.

00:28:05.140 --> 00:28:12.620
So now I'd like to demo, just a few advanced recording
techniques, take a look at immediate versus deferred mode

00:28:12.620 --> 00:28:15.850
as well and see why that matters for you now.

00:28:15.850 --> 00:28:18.010
So if we can switch to the demo machine please.

00:28:18.010 --> 00:28:23.110
This will be just a Mac demo.

00:28:23.110 --> 00:28:33.120
OK. So let's start up Instruments and we
will launch the Time Profiler instrument.

00:28:33.120 --> 00:28:35.260
I'll choose the Mac version there.

00:28:35.260 --> 00:28:49.330
And let's look at a little app that, that was
written a long time ago called the GL Mech app

00:28:49.330 --> 00:28:52.930
and we're going to first run this in immediate mode.

00:28:52.930 --> 00:29:03.370
We'll get this guy going here and let me bring up Terminal
and let's see how much CPU instruments is using right now.

00:29:03.370 --> 00:29:09.460
So Instruments is using, here it is, it's going to
bounce around between 4 and 7%, depending on what's going

00:29:09.460 --> 00:29:15.010
on as the GLUT Mech app runs.

00:29:15.010 --> 00:29:24.580
So 4 to 7%, so let's quit the GLUT Mech guy and let's
go up to the file menu and let's go to deferred mode.

00:29:24.580 --> 00:29:28.350
And let's run our little guy again.

00:29:28.350 --> 00:29:32.650
Now this darker appearance in Instruments is deferred mode.

00:29:32.650 --> 00:29:36.740
So when you see that, that's why.

00:29:36.740 --> 00:29:41.660
And let's go and look at top again
and let's look for Instruments.

00:29:41.660 --> 00:29:48.970
Now basically, other than a burp here or there, Instruments
will stay at 0% for long, extended periods of time.

00:29:48.970 --> 00:29:57.730
So this makes a significant difference as you're
analyzing some very CPU intensive application.

00:29:57.730 --> 00:30:00.680
So that is immediate versus deferred mode.

00:30:00.680 --> 00:30:07.880
That's an important question that people have had
about CPU usage and so we thought we'd answer it now.

00:30:07.880 --> 00:30:17.240
Another thing that people have wanted to do, they'll ask me,
how can I precisely time filter my data between two points.

00:30:17.240 --> 00:30:23.170
Say when call A was made and call B was made
or event A happened and event B happened?

00:30:23.170 --> 00:30:25.260
Well there's a couple of ways to do that.

00:30:25.260 --> 00:30:31.370
A sort of really poor man's way of doing
it is actually tagging it with a console.

00:30:31.370 --> 00:30:39.880
So let me run the GLUT Mech guy again and
we'll say, go and stop, go, stop, go, stop.

00:30:39.880 --> 00:30:44.460
So let's see how we could time
profile between a go and a stop.

00:30:44.460 --> 00:30:56.590
If I go down to my console here by using the Jump bar,
I'll select Console, we can see some console API output

00:30:56.590 --> 00:31:01.230
that I had added to that app, to just say
starting animation when you hit the Go button

00:31:01.230 --> 00:31:02.930
and stopping animation when you hit the Stop button.

00:31:02.930 --> 00:31:04.030
It's very simple.

00:31:04.030 --> 00:31:12.350
But what's interesting is that, the both
the console and its left hand margin

00:31:12.350 --> 00:31:16.030
and the timeline view, both have timeline inspectors.

00:31:16.030 --> 00:31:22.310
So if I zoom in on that and I take the inspection
head in a timeline, I can see that the inspection head

00:31:22.310 --> 00:31:25.600
in the console move around to where that actually happened.

00:31:25.600 --> 00:31:27.840
And if I move the console.

00:31:27.840 --> 00:31:28.660
[ applause ]

00:31:28.660 --> 00:31:32.220
I can drop it and it will move
to where that is in the timeline.

00:31:32.220 --> 00:31:37.970
So let's say on this second starting
animation, I want to begin a time filter here.

00:31:37.970 --> 00:31:41.580
Obviously this is something that you'd do after
the recording is stopped, otherwise you know,

00:31:41.580 --> 00:31:43.980
the data is going to be changing and driving you crazy.

00:31:43.980 --> 00:31:51.090
So I can use this inspection range tool bar item along
with that, so I precisely move to this point in time

00:31:51.090 --> 00:31:57.920
by selecting this location in the console and now I'm
going to click this left hand Inspection Range button.

00:31:57.920 --> 00:32:02.370
Now what that's going to do is say, begin a
time filter from this point on to the end.

00:32:02.370 --> 00:32:06.210
So I'll press that and now it's filtering
it from that point on to the end.

00:32:06.210 --> 00:32:16.610
And now that that initial event has been filtered out
as well in the console and so now I'll move to my,

00:32:16.610 --> 00:32:19.410
to my next stopping event and here it is.

00:32:19.410 --> 00:32:25.080
And now I can use this right hand side button in
inspection range and say OK now stop the time filter there.

00:32:25.080 --> 00:32:33.330
I'll do that and now I have a precise time filter
and I can go back to my sample list or my call tree

00:32:33.330 --> 00:32:35.770
and all this data is filtered within that time range.

00:32:35.770 --> 00:32:38.030
So it's pretty precise.

00:32:38.030 --> 00:32:47.680
But, on a system that's really loaded down, that I/O is
not really going to come out exactly when you emit it

00:32:47.680 --> 00:32:52.160
and so there's another better way to do this as well.

00:32:52.160 --> 00:32:56.710
So if I, I'll zoom out here, what I can do is I
can use dtrace and this will work for the Mac,

00:32:56.710 --> 00:32:59.210
both for Mac apps and for simulator apps.

00:32:59.210 --> 00:33:05.850
So if I go up to the Instruments menu and I say
trace symbol, it knows all the symbols it's seen,

00:33:05.850 --> 00:33:12.900
so I can say start animation and I'll add a probe point
for where start animation is really actually called.

00:33:12.900 --> 00:33:18.760
And remember, dtrace is managing all this from the kernel so
it's going to be really precise and I can do that as well.

00:33:18.760 --> 00:33:24.150
There's a command accelerator for that, so I can
just say command t and I can say, stop animation.

00:33:24.150 --> 00:33:28.750
So now I have dtrace probe points
for starting and stopping animation.

00:33:28.750 --> 00:33:36.460
So now let's go ahead and run the GLUT Mech
app again and let's have it do some things.

00:33:36.460 --> 00:33:39.620
Go, Stop, Go, Stop, Go, Stop.

00:33:39.620 --> 00:33:40.860
And let's quit.

00:33:40.860 --> 00:33:47.990
And now we see that in the other dtrace instruments, we
see these are basically representing how deep a stack was,

00:33:47.990 --> 00:33:53.160
but there are points and explicit events
where these events actually occurred

00:33:53.160 --> 00:33:55.470
where it actually started animation and stopped it.

00:33:55.470 --> 00:33:59.050
So now if I want to filter, I'll just click
on my start animation instrument first,

00:33:59.050 --> 00:34:04.200
I'm going to use the inspection range
again to select the first event here.

00:34:04.200 --> 00:34:09.620
Now we're right lined up and I'll start my time
filter there and then I'll go to stop animation

00:34:09.620 --> 00:34:13.710
and it's conveniently moved the
inspection head to the first location.

00:34:13.710 --> 00:34:19.730
Stop and I'll use the right side of the inspection range
there and now I have a really, really precise time filter.

00:34:19.730 --> 00:34:28.060
If I go back to my Time Profiler instrument and select
and have the call tree review or look at samples list.

00:34:28.060 --> 00:34:32.360
All this data is going to be precisely
filtered down to that time range.

00:34:32.360 --> 00:34:38.610
So those are very useful techniques for
how you trace data and how you look at it.

00:34:38.610 --> 00:34:41.850
Now this is, this is a pretty neat
little set up I have here.

00:34:41.850 --> 00:34:49.520
I have set the recording mode to deferred,
the default mode in Time Profiler is immediate

00:34:49.520 --> 00:34:53.780
and I have added these probe points for
starting and stopping the animation.

00:34:53.780 --> 00:34:58.380
So I'd like to reuse this and I can
by making this a trace template.

00:34:58.380 --> 00:35:05.210
So I can go over to the file menu and say Save as
Template, a sheet will pop down and this directory

00:35:05.210 --> 00:35:07.340
that it opens up to is in your user account.

00:35:07.340 --> 00:35:09.920
Library Applications for Instruments Templates.

00:35:09.920 --> 00:35:20.730
And I can say, call this you know, my cool template
and add a description, choose an icon or something.

00:35:20.730 --> 00:35:24.930
This is fine for me though and hit Save.

00:35:24.930 --> 00:35:30.470
And now both Xcode 3 and Xcode
4 are aware of that template.

00:35:30.470 --> 00:35:36.030
They'll look in that directory and Instruments
of course is aware of that template as well

00:35:36.030 --> 00:35:38.570
in its own user section of the template chooser.

00:35:38.570 --> 00:35:41.130
And now I can reuse that over and over again.

00:35:41.130 --> 00:35:46.440
So those are some techniques for doing a performance
analysis and the difference between immediate

00:35:46.440 --> 00:35:50.590
and deferred mode and I thought
you would just find that useful.

00:35:50.590 --> 00:35:52.980
So let's just go back to the slides.

00:35:52.980 --> 00:35:57.010
[ applause ]

00:35:57.010 --> 00:36:01.500
So we also have some new instrumentation in the latest SDK.

00:36:01.500 --> 00:36:05.560
One of the things we've added is the
Energy Diagnostics set of instrumentation.

00:36:05.560 --> 00:36:10.470
This is a large grained measuring
technique to look at energy consumption

00:36:10.470 --> 00:36:14.000
of your device, with or without your app running on it.

00:36:14.000 --> 00:36:17.560
It will measure battery power, the CPU usage of your app,

00:36:17.560 --> 00:36:21.710
as well as other important services
on the phone like media services.

00:36:21.710 --> 00:36:26.510
And it will track the on and off state
of vital devices that consume energy,

00:36:26.510 --> 00:36:33.420
the screen being a really big one
and Wi-Fi and Bluetooth, etcetera.

00:36:35.050 --> 00:36:39.770
We also have another really cool new
instrument called the Automation instrument.

00:36:39.770 --> 00:36:41.060
This is totally awesome.

00:36:41.060 --> 00:36:45.970
You can actually use it to automate and exercise your app.

00:36:45.970 --> 00:36:52.960
So you can simulate clicking on various controls
in your iPhone app and if you use it in conjunction

00:36:52.960 --> 00:36:57.360
with say another instrument, say
leaks and then you run, you have some,

00:36:57.360 --> 00:37:05.260
some set up where you run this before you make each
submission or an internal release or before your GM,

00:37:05.260 --> 00:37:12.040
you can check for pass/fail messages and other
results, via the JavaScript that you write

00:37:12.040 --> 00:37:15.040
with this instrument, use with this instrument.

00:37:15.040 --> 00:37:21.470
And then you can store those results away in some
separate database perhaps and you can just export them

00:37:21.470 --> 00:37:26.350
as comma separated values for example
and then refer to them later on

00:37:26.350 --> 00:37:31.700
and see how you've been progressing in your QA testing.

00:37:31.700 --> 00:37:36.460
There's also a really cool OpenGL ES Analyzer instrument.

00:37:36.460 --> 00:37:37.820
This is really amazing.

00:37:37.820 --> 00:37:45.590
It can actually, of course identify just bottlenecks
in your own code, but it can provide you actual advice,

00:37:45.590 --> 00:37:51.560
recommendations as to how you can improve the
performance of your GL app, which is just really cool.

00:37:51.560 --> 00:37:54.970
It just comes out in English and says hey, you're
doing this and you should be doing this other thing.

00:37:54.970 --> 00:37:58.460
So it's a little expert in a box for you.

00:37:58.460 --> 00:38:04.390
And finally, let's move on to our really new
instrumentation, the Xcode 4 developer preview.

00:38:04.390 --> 00:38:06.480
Namely system trace.

00:38:06.480 --> 00:38:14.700
So this provides you with comprehensive information
on the entire system with one or more processes,

00:38:14.700 --> 00:38:22.200
looking at thread scheduling, why they're
scheduled, how long they stay on a core.

00:38:22.200 --> 00:38:26.450
And you can look at system calls
and VM operations, etcetera.

00:38:26.450 --> 00:38:30.010
The system trace template is made
up of three individual instruments.

00:38:30.010 --> 00:38:36.610
The scheduling instrument, this tracks threads, contact
switches, the reasons why, the tenures, how long they're on.

00:38:36.610 --> 00:38:42.400
The system calls instrument, these are
calls into the kernel from user space.

00:38:42.400 --> 00:38:49.820
And the VM Operations instrument, so you can see page cache
hits and zero fills and all sorts of cool stuff there.

00:38:49.820 --> 00:38:55.400
And also, system trace is the first set of
instrumentation really that takes advantage of a new feature

00:38:55.400 --> 00:38:58.100
in Instruments, called the highlights view.

00:38:58.100 --> 00:39:04.300
So system trace especially, can just record a ton of
data, but we have other instruments that can do that too.

00:39:04.300 --> 00:39:12.020
And it's, it's a real labor sometimes to have to be able
to sift through all of that data, looking for the problems,

00:39:12.020 --> 00:39:16.570
especially when you have to correlate
a lot of data together.

00:39:16.570 --> 00:39:23.400
So with the highlights view, we take all the key
statistics, the very core statistics and we summarize them

00:39:23.400 --> 00:39:31.100
in little graphs that show you that the top five or so
extreme issues, such as processes or contact switches

00:39:31.100 --> 00:39:38.510
or something, and you can quickly key in on that by looking
at those graphs to see where you really want to dig in,

00:39:38.510 --> 00:39:41.100
rather than just in looking at
all the data then just you know,

00:39:41.100 --> 00:39:44.580
becoming bleary eyed at all, everything
that's presented to you.

00:39:44.580 --> 00:39:45.920
So I have one more demo.

00:39:45.920 --> 00:39:48.350
It's a pretty short and simple one.

00:39:48.350 --> 00:39:52.510
But let's go to the demo machine
and take a look at system trace.

00:39:52.510 --> 00:39:59.620
[ Pause ]

00:39:59.620 --> 00:40:05.110
So, as I said, I have the developer,
Xcode developer preview installed as well,

00:40:05.110 --> 00:40:10.240
so I'm going to launch that version of Instruments now.

00:40:10.240 --> 00:40:20.240
And I wanted to show you what system trace can tell you
about and visualize for you, as to why it seems so simple,

00:40:20.240 --> 00:40:25.540
but why an apps performance is degraded when
some other app is doing something intensive.

00:40:25.540 --> 00:40:29.970
So let's look at system trace and we're
going to look at all processes here

00:40:29.970 --> 00:40:32.970
and I'm going to open up a couple of apps here.

00:40:32.970 --> 00:40:42.570
A little app to scale down images to create
Mip maps and our little friend the robot here.

00:40:42.570 --> 00:40:45.600
Let me get these guys going.

00:40:45.600 --> 00:40:52.070
Now the previous version of that, that
robot we saw, actually put a sleep in it.

00:40:52.070 --> 00:40:56.290
Because it made me nauseous to see
how hyper this guy actually runs.

00:40:56.290 --> 00:41:02.810
Apple had this example a long time ago and it used to run
very smoothly because machines back then were a lot slower.

00:41:02.810 --> 00:41:07.220
Now machines are so fast it looks like
it had a bit too much caffeine today.

00:41:07.220 --> 00:41:13.570
So, but I want to show you now, that the change
in performance when I start my Mip maps app.

00:41:13.570 --> 00:41:18.460
So this is going to use a lot of
threads and be pretty intense.

00:41:18.460 --> 00:41:28.580
And it's slowed down dramatically and we can see the
reason why if we actually trace this with system trace.

00:41:28.580 --> 00:41:36.680
So I'll start that app in deferred mode here and I should
have actually started that before I hit that button there.

00:41:36.680 --> 00:41:44.730
So we'll take some data and that's enough
and, this is a MacBook Pro here.

00:41:44.730 --> 00:41:49.260
It's just a couple cores and it's gathered
just a ton of data so it takes a little while

00:41:49.260 --> 00:41:52.860
to process that, but luckily it's doing it deferred.

00:41:52.860 --> 00:42:02.620
So now let's quit our two apps here and
let's look at what we have real quick.

00:42:02.620 --> 00:42:12.390
So if we go to the highlights view, we can see and we'll
expand this, a chart of what's going on and we can look

00:42:12.390 --> 00:42:22.030
at the top here, at the Scheduling instrument and if we look
at process contact switches and what's going on up here,

00:42:22.030 --> 00:42:24.360
a great deal of threads are being switched on and off core.

00:42:24.360 --> 00:42:30.000
So there's far more threads that want time in this
scenario than there are cores to service them.

00:42:30.000 --> 00:42:35.590
And if we, if we click on one of these
charts, say process contact switches,

00:42:35.590 --> 00:42:42.870
we can see that the Mip map utility has
had a huge number of contact switches,

00:42:42.870 --> 00:42:49.580
but GLUT Mech which is a purely single
threaded app, has a lot of contact switches too

00:42:49.580 --> 00:42:54.940
and if we use the little Focus buttons again on GLUT
Mech, we look down and we go again to all thread states

00:42:54.940 --> 00:42:58.170
and now we can or all threads and we
can see how this Jump bar has developed.

00:42:58.170 --> 00:43:02.570
We were in summary view, process summary,
GLUT Mech threads and then thread tenures

00:43:02.570 --> 00:43:07.810
and we go over to this reason column, we
can see a lot of preemption and blocks.

00:43:07.810 --> 00:43:12.660
So this poor little robot was having
a hard time running on a system

00:43:12.660 --> 00:43:17.060
with so many other things going
on demanding time of the cores.

00:43:17.060 --> 00:43:25.360
So I just wanted to show you this example because
it demonstrates how you should use the system trace.

00:43:25.360 --> 00:43:34.540
You need to be aware of and we can go back to the
slides, aware of the system you're running on.

00:43:34.540 --> 00:43:41.420
It really is a system trace and so one of the good things
to do with it, when you've made sure that you have the state

00:43:41.420 --> 00:43:46.800
that you want to reproduce in the system, is to run
say a heavily multithreaded app on a two core machine

00:43:46.800 --> 00:43:53.450
and an eight core machine or a memory intensive app on a
machine that has very little memory and one that has a lot

00:43:53.450 --> 00:44:01.350
of memory to see how everything then works
together to give you or degrade your performance.

00:44:01.350 --> 00:44:03.500
So that is a demo of system trace.

00:44:03.500 --> 00:44:09.510
And so in closing, I'd like to just say that we strongly
believe you know, that Instruments is your go-to tool

00:44:09.510 --> 00:44:13.400
for performance analysis and it clearly
has more capabilities than ever.

00:44:13.400 --> 00:44:21.210
But I hope it's still in a way simpler to use and it does
provide more accurate insights than ever from what's going

00:44:21.210 --> 00:44:23.990
on in the kernel all the way up to user space.

00:44:23.990 --> 00:44:30.530
So, there are many sessions following this one
throughout the afternoon and the rest of the week

00:44:30.530 --> 00:44:35.930
that I strongly encourage you to attend, that
will be using Instruments in one way or another

00:44:35.930 --> 00:44:41.400
or demonstrating, specifically, how you use Instruments
for memory analysis, CPU analysis, etcetera.

00:44:41.400 --> 00:44:47.040
And if you have anymore information, please refer to Michael
Jurewitz and developer tools evangelist

00:44:47.040 --> 00:44:50.580
and the documentation online, as
well as the Apple Dev Forums.

