1
00:00:07,000 --> 00:00:08,160
>> Quinn "The Eskimo!": Greetings.

2
00:00:08,160 --> 00:00:11,170
My name is Quinn "The Eskimo!"

3
00:00:11,170 --> 00:00:17,010
I work for Apple Developer Technical Support,
answering questions from people like you, developers,

4
00:00:17,010 --> 00:00:21,780
about networking file systems, threads,
and other sort of Core OS little things.

5
00:00:21,780 --> 00:00:25,040
Welcome to Network Apps for iPhone OS Part Two.

6
00:00:25,040 --> 00:00:28,760
If you were at Part One, thank you for coming back.

7
00:00:28,760 --> 00:00:29,880
I admire your persistence.

8
00:00:29,880 --> 00:00:30,590
[ Laughter ]

9
00:00:30,590 --> 00:00:34,770
If you didn't make part one, that's probably okay.

10
00:00:34,770 --> 00:00:37,400
Most of this talk sort of stands alone.

11
00:00:37,400 --> 00:00:43,210
I'll make some references back to part one and you can
catch it on the videos, but mostly you should be fine.

12
00:00:43,210 --> 00:00:53,170
I'm going to start today -- well, not today
because I'm already an hour in -- with a quote.

13
00:00:53,170 --> 00:00:57,920
This is from my friend at DTS who was there when I joined.

14
00:00:57,920 --> 00:01:05,750
And he's since moved on to debug kernel panics for a
living, which sounds like fun to me but I'm going to --

15
00:01:05,750 --> 00:01:10,890
and it's relevant to this talk because the
previous talk was all about architecture.

16
00:01:10,890 --> 00:01:15,980
It was about problems and architecturing
your application to solve those problems.

17
00:01:15,980 --> 00:01:19,900
This talk is all about practical matters.

18
00:01:19,900 --> 00:01:26,670
And so the practical matters we're going to cover and the
number one, the big one -- asynchronous programming --

19
00:01:26,670 --> 00:01:32,150
and then shorter sections on debugging and common mistakes.

20
00:01:32,150 --> 00:01:36,760
I have certain religious objections to some
terminology, "anti-patents" is one of them,

21
00:01:36,760 --> 00:01:43,530
"Cloud" is another so we'll avoid that term.

22
00:01:43,530 --> 00:01:45,080
So to start.

23
00:01:45,080 --> 00:01:49,040
[ Applause ]

24
00:01:49,040 --> 00:01:52,130
As most of you know -- well, can tell
from my accent -- I'm Australian.

25
00:01:52,130 --> 00:01:54,240
And -- thank you.

26
00:01:54,240 --> 00:02:01,190
And I was looking for an icon for the practical
and I wanted sort of an image of filling developers

27
00:02:01,190 --> 00:02:02,950
up with knowledge or something like that.

28
00:02:02,950 --> 00:02:05,680
So I thought, "What's more practical than beer?"

29
00:02:05,680 --> 00:02:07,310
And the answer is: Nothing.

30
00:02:07,310 --> 00:02:07,370
[ Laughter ]

31
00:02:07,370 --> 00:02:13,240
So I took this and I turned it into
my cheesy graphic for the talk.

32
00:02:13,240 --> 00:02:18,050
And you know I'm a fan -- if you came to
Part 1, something you would have missed --

33
00:02:18,050 --> 00:02:23,460
you will know that I'm a fan of the cheesy graphics.

34
00:02:23,460 --> 00:02:29,040
And I also sort of wanted a filler bar so you
guys could tell your progress along the talk.

35
00:02:29,040 --> 00:02:31,850
And for me -- for you guys it's a
filler bar and for me it's a goal.

36
00:02:31,850 --> 00:02:39,250
When we get to the end, after two hours of talking
about networking, I'll be well-ready for a beer.

37
00:02:39,250 --> 00:02:46,040
So to start -- asynchronous programming: glass is empty.

38
00:02:46,040 --> 00:02:49,910
Bummer. Asynchronous programming is a big
topic so we're going to break it into three.

39
00:02:49,910 --> 00:02:51,640
There's the basics.

40
00:02:51,640 --> 00:02:56,810
There's a discussion of run loops and then
a short discussion of state management,

41
00:02:56,810 --> 00:03:02,320
which is how to connect the complicated
model -- state of your model objects --

42
00:03:02,320 --> 00:03:05,800
to the hopefully simple state of your front end objects.

43
00:03:05,800 --> 00:03:12,650
We're going to kick off with the basics
and what is more basic than a definition?

44
00:03:12,650 --> 00:03:15,160
Now, I had a hard time coming up
with a definition of asynchronous

45
00:03:15,160 --> 00:03:18,130
and synchronous programming in
words so I've defined it in code.

46
00:03:18,130 --> 00:03:23,200
People kept saying my slides were
short on code so I keep adding it.

47
00:03:23,200 --> 00:03:23,830
I was helped.

48
00:03:23,830 --> 00:03:31,020
So here you see on the left is a classic synchronous network
program: the start method runs; it runs the first request;

49
00:03:31,020 --> 00:03:34,980
gets the results from the first request,
processes them; runs the second request;

50
00:03:34,980 --> 00:03:37,090
gets the results, processes them; and so on.

51
00:03:37,090 --> 00:03:40,110
And it does all of that before
returning from the start method.

52
00:03:40,110 --> 00:03:42,320
This is called synchronous.

53
00:03:42,320 --> 00:03:49,500
On the right is an asynchronous program: the start requests
runs, it starts the first request; it starts method run;

54
00:03:49,500 --> 00:03:54,750
it starts the first request and then immediately
returns; and when the first request is done,

55
00:03:54,750 --> 00:04:00,670
another method is called -- request1Done it's called;
and that processes the results from the first request,

56
00:04:00,670 --> 00:04:06,830
starts the second request; and the
whole process continues on from there.

57
00:04:06,830 --> 00:04:09,180
Now, people often ask us "why?"

58
00:04:09,180 --> 00:04:10,810
If you've been to any network sessions this week,

59
00:04:10,810 --> 00:04:15,790
you'll hear constantly "program
asynchronously," and there's good reasons for that.

60
00:04:15,790 --> 00:04:24,980
First of all -- well, the obvious resistance to that is that
the synchronous programming on the left clearly is easier --

61
00:04:24,980 --> 00:04:32,290
there are fewer lines of code, there are fewer methods,
everything was shorter and simpler or it appeared to be.

62
00:04:32,290 --> 00:04:36,060
But yet we network programmers keep
nagging you about asynchronous.

63
00:04:36,060 --> 00:04:38,260
And why is that?

64
00:04:38,260 --> 00:04:43,580
And it's because really fundamentally, the network is
asynchronous; you can't control the order that things happen

65
00:04:43,580 --> 00:04:46,260
on the network, you just have to adapt to it.

66
00:04:46,260 --> 00:04:52,330
And if you do your network programming asynchronously,
what happens is that you have a mismatch between your code,

67
00:04:52,330 --> 00:04:58,120
which is running synchronously and the [inaudible 3,0]
underlying network code, which is running asynchronously.

68
00:04:58,120 --> 00:05:01,690
And that causes all sorts of problems.

69
00:05:01,690 --> 00:05:06,220
And in addition to that, what we find
is that synchronous programs are fine

70
00:05:06,220 --> 00:05:13,770
for when you're writing your third-year paper at university
and you want to write a simple test network program.

71
00:05:13,770 --> 00:05:21,250
But when it turns into writing a real program that works on
the real network where it has to deal with errors and it has

72
00:05:21,250 --> 00:05:26,900
to deal with latencies and it has to deal
with cancellation, then the balance tips

73
00:05:26,900 --> 00:05:28,970
and synchronous networking is no longer easier.

74
00:05:28,970 --> 00:05:31,630
Doing cancellation in synchronous networking is a nightmare.

75
00:05:31,630 --> 00:05:34,810
Doing cancellation in asynchronous networking is trivial.

76
00:05:34,810 --> 00:05:38,810
And so it turns out that asynchronous
networking becomes easier

77
00:05:38,810 --> 00:05:41,860
as you move along, as you deal with all the Edge cases.

78
00:05:41,860 --> 00:05:44,720
And that's why we recommend it.

79
00:05:44,720 --> 00:05:50,390
There's another critical equation
in iPhone OS, which is this thing.

80
00:05:50,390 --> 00:05:57,710
If you do synchronous networking programming on the
main thread, your application will eventually be killed.

81
00:05:57,710 --> 00:06:01,930
You will get crash reports from the user
saying that your application has died.

82
00:06:01,930 --> 00:06:04,120
No matter how you do your synchronous
networking, this is inevitable.

83
00:06:04,120 --> 00:06:08,110
And so you have to avoid this.

84
00:06:08,110 --> 00:06:14,370
And the reason why this happens is
because of this guy: this is the watchdog.

85
00:06:14,370 --> 00:06:17,930
The watchdog kills applications that have gone bad.

86
00:06:17,930 --> 00:06:22,210
And one definition of the application going bad
is it not responding to user interface events.

87
00:06:22,210 --> 00:06:28,430
If it doesn't respond to user interface events, the watchdog
gives it a certain period of time and then it shoots it.

88
00:06:28,430 --> 00:06:32,520
Now -- well, I guess it would chew off a limb
or something really, I'm mixing my metaphors.

89
00:06:32,520 --> 00:06:35,790
[ Laughter ]

90
00:06:35,790 --> 00:06:37,940
This is not just a network thing.

91
00:06:37,940 --> 00:06:42,150
If you take your main thread and you start calculating
Mandelbrot sets in your main thread and you do it

92
00:06:42,150 --> 00:06:44,890
for a minute, the watchdog will kill you as well.

93
00:06:44,890 --> 00:06:49,530
But it's especially bad for networking because
of these -- oh, actually before we get there.

94
00:06:49,530 --> 00:06:51,730
Oops, slide misordering here.

95
00:06:51,730 --> 00:06:54,300
When you do get killed by the watchdog,
this is what it looks like.

96
00:06:54,300 --> 00:06:55,420
You get this "ate bad food."

97
00:06:55,420 --> 00:07:05,080
If you look at the numbers there it says, "8badf00d."

98
00:07:05,080 --> 00:07:05,200
[ Laughter ]

99
00:07:05,200 --> 00:07:05,320
[ Applause ]

100
00:07:05,320 --> 00:07:07,120
Don't clap me, I didn't come up with that idea.

101
00:07:07,120 --> 00:07:07,890
[ Laughter ]

102
00:07:07,890 --> 00:07:12,190
Anyway, you can tell the crash reporting people on
Friday because there's a great cash reporting session.

103
00:07:12,190 --> 00:07:16,720
So if you want to know more about crash reports, it's
a fabulous session -- I highly recommend you go to it.

104
00:07:16,720 --> 00:07:21,320
But if you just want a quick summary,
you can get this from the tech note 2151.

105
00:07:21,320 --> 00:07:27,430
And it's an indication of how often we reference
this tech note by the fact that I know the number,

106
00:07:27,430 --> 00:07:30,050
because it has a good summary of
all these watchdog crash reports.

107
00:07:30,050 --> 00:07:32,500
And the watchdog crash report that says
"ate bad food" means that you were killed

108
00:07:32,500 --> 00:07:34,550
because you weren't responding to these rude events.

109
00:07:34,550 --> 00:07:42,400
And the reason why this is an issue is because of
this: The watchdog timeout is roughly about 20 seconds,

110
00:07:42,400 --> 00:07:46,420
that's not an API, that's a current implementation detail.

111
00:07:46,420 --> 00:07:49,580
And all the networking timeouts of
synchronous networking are all longer

112
00:07:49,580 --> 00:07:51,840
than that, in some cases much longer than that.

113
00:07:51,840 --> 00:07:56,420
So if you do a synchronous request and
the network drops out from underneath you,

114
00:07:56,420 --> 00:08:00,540
then you're stuck, waiting for the network to respond.

115
00:08:00,540 --> 00:08:02,370
You can't get out of that; you're just stuck there.

116
00:08:02,370 --> 00:08:06,690
And then at some point, 20 seconds later, the
watchdog comes along and kills your application.

117
00:08:06,690 --> 00:08:10,910
And the answer to this is not lower the timeouts.

118
00:08:10,910 --> 00:08:15,610
An application that's unresponsive for
5 seconds is still a broken application.

119
00:08:15,610 --> 00:08:20,930
You need the application to be responsive all the time
and that means the main thread can't be doing things

120
00:08:20,930 --> 00:08:23,750
that take long periods of time, and
especially can't be doing things

121
00:08:23,750 --> 00:08:26,100
that take unbounded periods of time like networking.

122
00:08:26,100 --> 00:08:34,950
So we return to this: Synchronous program
networking on the main thread is death.

123
00:08:34,950 --> 00:08:40,410
Now there's another "gotcha" here and that
relates to this: Hidden synchronous networking.

124
00:08:40,410 --> 00:08:45,470
There's a whole bunch of utility methods in the
operating system that do networking behind your back,

125
00:08:45,470 --> 00:08:48,580
things like the NSArray initWithContents0fURL.

126
00:08:48,580 --> 00:08:54,490
If you pass at a filesystem URL, it will read a plist off
the filesystem and that will be fast; it won't be a problem.

127
00:08:54,490 --> 00:08:57,560
But if you pass an http URL, it will go to the network.

128
00:08:57,560 --> 00:09:03,100
And if the network's not working properly, it can't
return because it hasn't got the whole results yet.

129
00:09:03,100 --> 00:09:06,850
It can't error because it's not got
to the point where it's timed out.

130
00:09:06,850 --> 00:09:10,390
It just sits there and waits and the watchdog kills you.

131
00:09:10,390 --> 00:09:12,970
And in addition to that there's the DNS.

132
00:09:12,970 --> 00:09:17,910
Lots of people make these traditional BSD
DNS calls -- gethostbyname and gethostbyaddr.

133
00:09:17,910 --> 00:09:22,950
Again, fully synchronous -- don't
call them ever on the main thread.

134
00:09:22,950 --> 00:09:28,840
And another one is this NSURL connection method
-- sendSynchronousRequest:returningResponseerror.

135
00:09:28,840 --> 00:09:32,260
Now that's not really hidden in the sense
that it's got "synchronous" in the name.

136
00:09:32,260 --> 00:09:37,390
But it is one common case where we see people tripping up.

137
00:09:37,390 --> 00:09:40,980
And finally, there's this notion of synthetic synchronous.

138
00:09:40,980 --> 00:09:45,730
And synthetic synchronous is where you call an API
asynchronously and then you wait for the results.

139
00:09:45,730 --> 00:09:48,480
So here's some pseudocode -- this guy.

140
00:09:48,480 --> 00:09:52,400
I get this from folks.

141
00:09:52,400 --> 00:09:55,580
They say, "But I called the API asynchronously."

142
00:09:55,580 --> 00:10:00,280
And it's like, "No, if you're waiting
for the results, it's synchronous."

143
00:10:00,280 --> 00:10:02,470
Now synthetic synchronous is a
good idea in some circumstances.

144
00:10:02,470 --> 00:10:05,910
I'm going to have some examples of where you might
use it later and where the operating system uses it.

145
00:10:05,910 --> 00:10:08,490
But it's not a miracle cure for this equation.

146
00:10:08,490 --> 00:10:11,870
Synchronous networking on the main thread will kill you.

147
00:10:11,870 --> 00:10:16,030
So how do we break this?

148
00:10:16,030 --> 00:10:17,950
How do we break that equation?

149
00:10:17,950 --> 00:10:23,910
And the first thing you might think is, "Well, if
synchronous networking is not in the main thread is bad,

150
00:10:23,910 --> 00:10:27,500
then I'll just put it on a secondary
thread and that will be good."

151
00:10:27,500 --> 00:10:29,350
And that's rarely the answer.

152
00:10:29,350 --> 00:10:34,200
Sometimes it's the answer in some circumstances
but for typical iPhone OS application,

153
00:10:34,200 --> 00:10:37,050
it's not the answer because threads are evil.

154
00:10:37,050 --> 00:10:40,510
Now that was a contentious statement a few years ago

155
00:10:40,510 --> 00:10:44,970
but now it's fairly well-understood
that threads are reasonably evil.

156
00:10:44,970 --> 00:10:49,210
And I'm going to talk about that
specifically in a slide or two.

157
00:10:49,210 --> 00:10:52,570
But for the moment, you just have to take my word for it.

158
00:10:52,570 --> 00:10:55,190
Now another option is Grand Central Dispatch.

159
00:10:55,190 --> 00:10:58,190
Grand Central Dispatch is all about
asynchronous programming.

160
00:10:58,190 --> 00:11:04,500
It's potentially the best thing coming to
networking ever in terms of programming model.

161
00:11:04,500 --> 00:11:11,550
Unfortunately, today it's not a great choice and this
ties back to something I had in my previous talk,

162
00:11:11,550 --> 00:11:14,620
which is this: here's the iPhone networking stack.

163
00:11:14,620 --> 00:11:17,820
We want people to be working at the Foundation layer.

164
00:11:17,820 --> 00:11:21,610
Now Foundation has been revved to
take advantage of GCD in some places

165
00:11:21,610 --> 00:11:24,740
but the networking part of Foundation hasn't been.

166
00:11:24,740 --> 00:11:30,300
And that means you have a choice: you can
either not use Foundation and use GCD,

167
00:11:30,300 --> 00:11:36,400
or you can use Foundation and not use GCD.

168
00:11:36,400 --> 00:11:41,080
And our recommendation is you stick with
Foundation; it gives you a lot of benefits above

169
00:11:41,080 --> 00:11:49,670
and beyond what you can get from just using
GCD directly, which means that for the moment,

170
00:11:49,670 --> 00:11:54,240
for a typical network programmer, GCD is the future.

171
00:11:54,240 --> 00:11:58,030
One day it will be great, but for
the moment we have to stick

172
00:11:58,030 --> 00:12:00,670
with the third option here, which is run loop programming.

173
00:12:00,670 --> 00:12:07,570
Now I'm going to talk about run loop in a lot
of depth in the next section but first I wanted

174
00:12:07,570 --> 00:12:11,060
to return back to this idea of threads being evil.

175
00:12:11,060 --> 00:12:12,760
Why are threads evil?

176
00:12:12,760 --> 00:12:17,700
The first point for why threads
are evil is this notion of locking.

177
00:12:17,700 --> 00:12:22,480
If you have multiple threads in the same program,
then they may share data and if they share data,

178
00:12:22,480 --> 00:12:25,080
you have to lock the data before you access it.

179
00:12:25,080 --> 00:12:30,400
And then you introduce this notion of accessing the data
outside of the lock, which causes random corruption.

180
00:12:30,400 --> 00:12:33,890
Or if you have more than one lock in
your program, you end up in deadlocks.

181
00:12:33,890 --> 00:12:39,350
And in general, that sort of thing is just
a mess and it's better to try and avoid it.

182
00:12:39,350 --> 00:12:42,370
In addition to that, this is this idea of cancellation.

183
00:12:42,370 --> 00:12:48,130
If you're doing synchronous networking on the main thread
and the network goes away, then you can be blocked.

184
00:12:48,130 --> 00:12:54,080
Or even if the network's just waiting for data, you
can be blocked inside the kernel waiting for the data.

185
00:12:54,080 --> 00:12:58,020
The problem here is if the user hits the cancel button,
how do you get out of the kernel to say you're done?

186
00:12:58,020 --> 00:12:59,870
And it turns out that's very hard to fix.

187
00:12:59,870 --> 00:13:00,760
You can fix it.

188
00:13:00,760 --> 00:13:06,710
You can use inter-thread signals and other crazy
things but the reality is it's very hard to get right.

189
00:13:06,710 --> 00:13:10,390
And it's one of these cases where
making a request asynchronously --

190
00:13:10,390 --> 00:13:15,470
it starts to be a big win because you have an asynchronous
request, then you're just waiting to be called back.

191
00:13:15,470 --> 00:13:20,410
And if you want to cancel, you just invalidate your own
loop sources and release everything and you're done.

192
00:13:20,410 --> 00:13:22,670
It's a big win for asynchronous.

193
00:13:22,670 --> 00:13:23,790
Timeouts are a similar issue.

194
00:13:23,790 --> 00:13:30,090
If you use synchronous programming, you're at the mercy of
the timeouts provided by the underlying API you're using.

195
00:13:30,090 --> 00:13:33,500
But if you use asynchronous programming,
you can time out just by using MS timer

196
00:13:33,500 --> 00:13:37,570
and when it fires, cancel the request and you're done.

197
00:13:37,570 --> 00:13:41,060
Also, bidirectionality -- TCP is inherently bidirectional.

198
00:13:41,060 --> 00:13:43,130
And if you use a protocol, it is bidirectional.

199
00:13:43,130 --> 00:13:45,340
It's a big win doing it that way.

200
00:13:45,340 --> 00:13:50,850
You get advantages on the wire but it doesn't
work well with synchronous networking on threads.

201
00:13:50,850 --> 00:13:53,770
If you're reading, waiting for data, you're stuck.

202
00:13:53,770 --> 00:13:56,490
You can't write data as well.

203
00:13:56,490 --> 00:13:57,920
Now, again, there are ways around that.

204
00:13:57,920 --> 00:14:01,120
You can simultaneously use two
different threads to read and write.

205
00:14:01,120 --> 00:14:06,410
But that sort of undermines the whole
benefit of using synchronous programming.

206
00:14:06,410 --> 00:14:08,240
And finally, there's this issue of resource use.

207
00:14:08,240 --> 00:14:14,870
If you have 10 threads, they each have 8K of
stack and they might be blocked in the kernel

208
00:14:14,870 --> 00:14:17,360
and they're consuming 24K of kernel stack.

209
00:14:17,360 --> 00:14:22,440
And on the iPhone, all of that memory is
wired down -- it's consumed permanently.

210
00:14:22,440 --> 00:14:26,920
So you're looking at large amounts of memory that can't
be reused for anything else and they're just stuck

211
00:14:26,920 --> 00:14:31,050
and they're literally doing nothing;
it's no benefit to user at all.

212
00:14:31,050 --> 00:14:36,350
In contrast, if you use asynchronous programming,
that really -- that's not an issue anymore.

213
00:14:36,350 --> 00:14:40,120
You don't have threads sitting there,
consuming memory doing nothing.

214
00:14:40,120 --> 00:14:43,640
So in my experience, threads are evil.

215
00:14:43,640 --> 00:14:46,240
But of course, there's a "but."

216
00:14:46,240 --> 00:14:52,480
There's always a "but," and that is if
you're doing CPU-intensive operations.

217
00:14:52,480 --> 00:14:58,440
Threads are evil for networking but for operations
that need the CPU, they're a really good thing --

218
00:14:58,440 --> 00:15:04,650
they're the best way to get the CPU to run concurrently
with the user interface or the CPU task you're trying to do

219
00:15:04,650 --> 00:15:06,780
to run concurrently with the user interface.

220
00:15:06,780 --> 00:15:15,220
They're also fine for doing I/O operations that are
both fast and reliable, like accessing the disk drive --

221
00:15:15,220 --> 00:15:18,640
at least on iPhone OS the disk
drive is both fast and reliable.

222
00:15:18,640 --> 00:15:20,930
And so it's fine to use threads for those things.

223
00:15:20,930 --> 00:15:23,960
And that raises the question of
how do you mix and match them?

224
00:15:23,960 --> 00:15:27,550
How do you do threads for one things
and run loops for the other?

225
00:15:27,550 --> 00:15:31,240
And my recommended way of doing that is with NSOperation.

226
00:15:31,240 --> 00:15:35,060
NSOperation is this abstraction for
dealing with asynchronous operations.

227
00:15:35,060 --> 00:15:39,510
It's like start the operation and when
it's done, you hear about it being done.

228
00:15:39,510 --> 00:15:48,280
And it turns out that you can use NSOperation -- what
we call standard NSOperations for CPU-bound tasks

229
00:15:48,280 --> 00:15:55,150
where the NSOperation queue starts a thread for you and
you run on a thread and that's good for CPU-bound tasks.

230
00:15:55,150 --> 00:16:00,390
And then for networking tasks, you can
use what's called a concurrent NSOperation

231
00:16:00,390 --> 00:16:04,390
where the operation queue doesn't start it
on a thread but instead organizes to run it

232
00:16:04,390 --> 00:16:07,670
and expects it to continue running by itself.

233
00:16:07,670 --> 00:16:16,470
So NSOperation is a really good way to model a mix of CPU
and network-bound intensive operations simultaneously.

234
00:16:16,470 --> 00:16:18,640
It's a very unique technique.

235
00:16:18,640 --> 00:16:23,870
The only issue with NSOperation is that doing the
concurrent NSOperations for networking is a bit tricky.

236
00:16:23,870 --> 00:16:26,700
There's a bit of fiddly things you've
got to do to get it work properly.

237
00:16:26,700 --> 00:16:31,570
So I've been working on a sample that shows how to do
this and it's called the LinkedImageFetcher sample.

238
00:16:31,570 --> 00:16:37,540
It's not quite ready for prime time -- I didn't really have
time to get it properly reviewed before the conference.

239
00:16:37,540 --> 00:16:41,400
But I've put it on the attendee site
so you can go and grab it from there.

240
00:16:41,400 --> 00:16:47,860
And it shows how to do this mix and match of
CPU and network operations in the same program.

241
00:16:47,860 --> 00:16:55,850
And I do intend -- I fully intend -- to get
that made public soon after the conference.

242
00:16:55,850 --> 00:17:00,000
Finally, before we leave the subject of
threads, this is the idea of hidden threads.

243
00:17:00,000 --> 00:17:02,900
NSOperation will start threads behind your back.

244
00:17:02,900 --> 00:17:06,360
Similarly, Grand Central Dispatch will do the same thing.

245
00:17:06,360 --> 00:17:09,130
And also this Cocao method,
performSelectorInBackground:withObject:,

246
00:17:09,130 --> 00:17:11,210
will also start threads behind you are back.

247
00:17:11,210 --> 00:17:14,540
And you if you mix and match threads and
run loops, you can fall into one big pitfall

248
00:17:14,540 --> 00:17:17,880
and I'll give a good example of that later in the talk.

249
00:17:17,880 --> 00:17:22,080
But just for the moment, the lesson here
is: Watch out for these hidden threads.

250
00:17:22,080 --> 00:17:24,770
And that wraps up for the basics.

251
00:17:24,770 --> 00:17:26,300
We're going to dive straight into run loops.

252
00:17:26,300 --> 00:17:30,560
And that's definitions to start off with.

253
00:17:30,560 --> 00:17:33,090
There's one run loop per thread, always.

254
00:17:33,090 --> 00:17:36,990
A run loop is an event dispatch mechanism --

255
00:17:36,990 --> 00:17:42,070
it monitors a set of event sources and each
event source has a callback associated with it.

256
00:17:42,070 --> 00:17:45,670
And when the event source fires, it calls the callback.

257
00:17:45,670 --> 00:17:50,000
Now, the run loop has to be explicitly run
by the thread that it's associated with.

258
00:17:50,000 --> 00:17:53,370
So the thread runs the run loop and
while it's running inside the run loop,

259
00:17:53,370 --> 00:17:56,730
it monitors these event sources and
calls the callbacks as they fire.

260
00:17:56,730 --> 00:18:00,910
And if no event sources fire, it
blocks, waiting for one of them to fire.

261
00:18:00,910 --> 00:18:03,620
In general, you must explicitly run your run loops.

262
00:18:03,620 --> 00:18:07,520
But as one special case, the user
interface frameworks like UIKit

263
00:18:07,520 --> 00:18:11,050
on iPhone OS will automatically
run the main thread's run loop.

264
00:18:11,050 --> 00:18:17,920
Now, to look at this graphically, I
have a series of less-cheesy diagrams.

265
00:18:17,920 --> 00:18:21,790
Here's a bunch of threads -- the main
thread and a couple of secondary threads

266
00:18:21,790 --> 00:18:24,320
and each of them has an associated run loop.

267
00:18:24,320 --> 00:18:25,730
The run loop sort of owns that thread.

268
00:18:25,730 --> 00:18:31,590
Now, if we focus on one of these
threads, we can zoom into it.

269
00:18:31,590 --> 00:18:36,510
And here we see the run loop and the run loop
is associated with all of the run loop sources.

270
00:18:36,510 --> 00:18:41,730
Now these run loop sources aren't abstract
notions, they're related to what you've done.

271
00:18:41,730 --> 00:18:48,620
So for example, here on the left, if you start a timer, we
create a timer event source that's attached to the run loop.

272
00:18:48,620 --> 00:18:55,410
And on the right there, we started an
NSURLConnection and it's created a connection source.

273
00:18:55,410 --> 00:18:57,130
So it's attached to the run loop.

274
00:18:57,130 --> 00:19:06,610
So these run loop sources don't come from out of just thin
air, they come because of operations that you've done.

275
00:19:06,610 --> 00:19:09,900
Here's an example of actually scheduling
something on the run loop.

276
00:19:09,900 --> 00:19:15,820
Here's -- we started with a net service, which is
a reference to a service that we found on Bonjour.

277
00:19:15,820 --> 00:19:18,280
We created an input stream for that service.

278
00:19:18,280 --> 00:19:23,430
Now that input stream by itself is not scheduled on
the run loop so we explicitly scheduled on the run loop

279
00:19:23,430 --> 00:19:26,200
with this scheduleInRunLoopforMode method.

280
00:19:26,200 --> 00:19:30,110
And you pass in the current run loop
and you pass in on the run loop mode.

281
00:19:30,110 --> 00:19:35,430
Now, run loop modes are a source of some confusion and
I'm going to cover those in detail in a few slides.

282
00:19:35,430 --> 00:19:39,370
But for the moment we're just going to ignore
it and choose the default run loop mode.

283
00:19:39,370 --> 00:19:44,110
Then the other thing you do is you set the delegate
and the delegate is effectively the callback.

284
00:19:44,110 --> 00:19:48,030
The real callback is internal to NSInputStream.

285
00:19:48,030 --> 00:19:52,650
But for the moment from your perspective
the callback is the delegate.

286
00:19:52,650 --> 00:19:58,030
And then once the source is set up on
the run loop, you kick off the open.

287
00:19:58,030 --> 00:20:00,980
And then the open proceeds asynchronously in the background.

288
00:20:00,980 --> 00:20:05,890
At some point in the future when the open is
complete, you'll start getting events to your delegate.

289
00:20:05,890 --> 00:20:08,840
And we'll call this method the
HandleEventMethod on your delegate.

290
00:20:08,840 --> 00:20:11,860
And the question is, "Well, what thread is that running on?"

291
00:20:11,860 --> 00:20:18,210
It's running on the thread associated with the run loop that
you passed in when you scheduled the stream on the run loop.

292
00:20:18,210 --> 00:20:24,220
Those two are tightly-bound together and this also
means that in order for this delegate callback

293
00:20:24,220 --> 00:20:26,840
to be called, you have to be running this run loop.

294
00:20:26,840 --> 00:20:30,150
Now, if you're in the main thread, that's
really easy -- the UIKit does it for you.

295
00:20:30,150 --> 00:20:34,670
But if you're in other threads, you have
to go out of your way to make sure it runs.

296
00:20:34,670 --> 00:20:40,130
Now this is explicit scheduling where you explicitly tell
the frameworks what run loop you want to schedule on.

297
00:20:40,130 --> 00:20:42,280
In addition to this, you get implicit scheduling.

298
00:20:42,280 --> 00:20:47,260
And here's an example of this, where the frameworks
sort of decide for themselves what to schedule on.

299
00:20:47,260 --> 00:20:51,590
And this is NSURLConnection, it's a utility
method called connectionWithRequest:reqdelegate.

300
00:20:51,590 --> 00:20:55,210
And that automatically schedules on the
current run loop in the default mode.

301
00:20:55,210 --> 00:20:59,190
And so that's the context that this callback will run in.

302
00:20:59,190 --> 00:21:03,810
Every time we have an implicit scheduling, we almost
always have an equivalent method that's explicit.

303
00:21:03,810 --> 00:21:07,360
So here's the explicit version.

304
00:21:07,360 --> 00:21:11,670
You allocate the connection with the request
and the callback, which is the delegate

305
00:21:11,670 --> 00:21:14,140
and you pass NO to this startImmediately prompter.

306
00:21:14,140 --> 00:21:18,630
So it doesn't start, it doesn't
schedule in the run loop automatically.

307
00:21:18,630 --> 00:21:21,170
Then in the next step, you schedule
it on the run loop that you want

308
00:21:21,170 --> 00:21:24,160
to schedule it on and then you call the start method.

309
00:21:24,160 --> 00:21:31,590
And from then on, at some point in the future, you'll get
this delegate callbacks associated with this operation.

310
00:21:31,590 --> 00:21:34,800
So that's pretty much how you schedule
things on the run loops.

311
00:21:34,800 --> 00:21:38,560
What about these run loop modes?

312
00:21:38,560 --> 00:21:43,700
Whenever you add an event source to a run loop mode -- to
a run loop -- you actually add it in a particular mode.

313
00:21:43,700 --> 00:21:48,000
And whenever a run loop runs, it always runs in that mode.

314
00:21:48,000 --> 00:21:53,100
And when it runs in that mode, it only runs -- it only
monitors the event sources associated with that mode.

315
00:21:53,100 --> 00:21:55,690
All the other event sources are ignored.

316
00:21:55,690 --> 00:21:58,250
So this is just the basic facts.

317
00:21:58,250 --> 00:22:01,320
Here it is graphically -- well, not quite yet.

318
00:22:01,320 --> 00:22:02,860
This is where we left off our run loop model.

319
00:22:02,860 --> 00:22:06,160
I'm going to insert the modes in there.

320
00:22:06,160 --> 00:22:12,120
So now we have two run loop modes in this blue layer:
the default run loop mode and a tracking run loop mode.

321
00:22:12,120 --> 00:22:14,720
Some of them have all the event
sources associated with them,

322
00:22:14,720 --> 00:22:18,210
the default mode, and the tracking mode only has a subset.

323
00:22:18,210 --> 00:22:23,420
So when you run the run loop in the default
mode, we monitor all of these event sources.

324
00:22:23,420 --> 00:22:28,480
In contrast, when you run the run loop in this tracking
mode, we only monitor a subset of the event sources.

325
00:22:28,480 --> 00:22:30,560
In this case, we ignore the timer.

326
00:22:30,560 --> 00:22:34,770
So if the timer fires, the callback
for that timer won't be called.

327
00:22:34,770 --> 00:22:38,580
And that's useful in a variety of circumstances.

328
00:22:38,580 --> 00:22:42,760
But the real question is: why do we
have this whole run loop mode mess?

329
00:22:42,760 --> 00:22:45,800
And it's associated with a recursion.

330
00:22:45,800 --> 00:22:49,980
Sometimes you're in a run loop callback
and you want to run the run loop again.

331
00:22:49,980 --> 00:22:55,500
You might want to call an API using this synthetic
synchronous model; sometimes it's important to do so.

332
00:22:55,500 --> 00:22:59,080
And an example of doing that is the user
interface tracking that's done by UIKit.

333
00:22:59,080 --> 00:23:01,510
And I'll talk about in a little more depth in a few slides.

334
00:23:01,510 --> 00:23:05,520
But I just want to give an example
of this synthetic synchronous model.

335
00:23:05,520 --> 00:23:12,470
You're in a run loop callback and you want
to run an async API, synthetic synchronous.

336
00:23:12,470 --> 00:23:17,380
So the way you do that is you set up the async
call and you schedule it in a custom run loop mode.

337
00:23:17,380 --> 00:23:20,100
Run loop modes are just strings;
you can pull them out of thin air.

338
00:23:20,100 --> 00:23:26,130
And generally we recommend that you use reverse DNS notation
just to keep away from other people's run loop modes.

339
00:23:26,130 --> 00:23:28,520
So you schedule your event source
in this custom run loop mode

340
00:23:28,520 --> 00:23:31,360
and then you run the run loop in that custom run loop mode.

341
00:23:31,360 --> 00:23:34,580
And what that means is only your event source will run.

342
00:23:34,580 --> 00:23:39,390
All other event sources are held off until
the run loop start returns to the other modes.

343
00:23:39,390 --> 00:23:42,250
So here's an example of this.

344
00:23:42,250 --> 00:23:46,060
Here's where we left our run loop
off with two run loop modes.

345
00:23:46,060 --> 00:23:51,860
What we do is we create a custom mode and
we run the run loop in that custom mode.

346
00:23:51,860 --> 00:23:56,790
And we add our file descriptor in the schedule -- we've
created a CF file descriptor just as an example --

347
00:23:56,790 --> 00:24:00,450
and we add that -- its event source --
to the run loop in that custom mode.

348
00:24:00,450 --> 00:24:03,960
And when we run the run loop in that custom mode,

349
00:24:03,960 --> 00:24:08,310
only that event source is looked at;
all other event sources are ignored.

350
00:24:08,310 --> 00:24:09,250
It's really useful.

351
00:24:09,250 --> 00:24:13,690
In this case, if you're doing it on the main thread,
this might be a bad idea because it's effectively

352
00:24:13,690 --> 00:24:16,810
If you block forever, you'll be killed by the watchdog.

353
00:24:16,810 --> 00:24:19,470
If you're doing it on a secondary
thread, it's perfectly reasonable.

354
00:24:19,470 --> 00:24:24,040
You can even do it on the main thread if you can limit the
amount of time that you'll spend if there's some upper bound

355
00:24:24,040 --> 00:24:27,810
to the amount of time you'll spend
running the run loop in the custom mode.

356
00:24:27,810 --> 00:24:33,330
Now example of where this is used in
practice is user interface tracking.

357
00:24:33,330 --> 00:24:37,830
If you have a scroll view on screen and the user
taps down on the scroll view and drags up and down,

358
00:24:37,830 --> 00:24:41,740
the UIScrollView class wants to run the run
loop in order to track the user's finger.

359
00:24:41,740 --> 00:24:46,740
And it doesn't want to return to the main run
loop in order to do that, to the top level,

360
00:24:46,740 --> 00:24:49,330
so it uses a form of synthetic synchronous.

361
00:24:49,330 --> 00:24:55,630
It gets all of the run loop sources -- event sources
-- that are associated with tracking touches,

362
00:24:55,630 --> 00:24:59,660
such as the input event sources and the compositing
sources required to composite out to the screen

363
00:24:59,660 --> 00:25:05,620
so you can see things and it adds those to a custom
run loop mode, which is UITrackingRunLoopMode.

364
00:25:05,620 --> 00:25:07,930
And then it runs the run loop in that mode.

365
00:25:07,930 --> 00:25:12,160
And so all of the event sources required
to track a run and other event sources,

366
00:25:12,160 --> 00:25:18,020
such as maybe one's OpenURL event sources or
ones related to push notifications don't run.

367
00:25:18,020 --> 00:25:19,890
This is a hugely important technique.

368
00:25:19,890 --> 00:25:27,940
Now, it's a "gotcha" for you guys because if you take
an object and you schedule it in the default mode,

369
00:25:27,940 --> 00:25:30,670
then the run loop isn't running in that mode at this point.

370
00:25:30,670 --> 00:25:35,120
So you might have created an NSURLConnection and
it's receiving data, the user puts their finger

371
00:25:35,120 --> 00:25:41,390
down on the scroll view, and it stops receiving
data because its event source isn't being monitored.

372
00:25:41,390 --> 00:25:43,870
And you might work around this
by scheduling the event source,

373
00:25:43,870 --> 00:25:46,590
not only in the default mode but
also in the UITrackingRunLoopMode.

374
00:25:46,590 --> 00:25:52,380
But there's actually a better solution to that, and
that is to schedule in this common modes object concept.

375
00:25:52,380 --> 00:25:54,150
The common modes are a meta-mode.

376
00:25:54,150 --> 00:25:59,520
You can't run the run loop in the common modes but
you can schedule event sources in the common mode.

377
00:25:59,520 --> 00:26:04,410
And when you do so, the run loop automatically
schedules those event sources in all the likely places

378
00:26:04,410 --> 00:26:08,570
that you'll need to be run, which
are these modes called common modes.

379
00:26:08,570 --> 00:26:13,530
Now on iPhone OS, the common modes consist of the
default run loop mode and the UI tracking run loop mode.

380
00:26:13,530 --> 00:26:16,000
But that could be extended.

381
00:26:16,000 --> 00:26:19,910
So for example in Mac OS X, there's a run
loop mode for tracking across the menu bar

382
00:26:19,910 --> 00:26:23,000
when the user puts the mouse down in the menu bar.

383
00:26:23,000 --> 00:26:26,530
And so the key thing about using the
common modes is that you run in all

384
00:26:26,530 --> 00:26:29,120
of these modes where you're likely to need to run.

385
00:26:29,120 --> 00:26:31,680
And it's a good abstraction layer
for getting your code running,

386
00:26:31,680 --> 00:26:35,160
even though the user's interacting with the user interface.

387
00:26:35,160 --> 00:26:41,000
The "gotcha" with using the common modes is that
if the run loop is running in the default mode,

388
00:26:41,000 --> 00:26:44,090
then you can do all sorts of things
-- you can do pretty much anything.

389
00:26:44,090 --> 00:26:48,430
If you get a network error and
you put up an alert, that's fine.

390
00:26:48,430 --> 00:26:55,610
But if the user is tracking their finger across the scroll
view and you're running on the UITrackingRunLoopMode,

391
00:26:55,610 --> 00:26:59,080
then if you get a network error -- because you're
running now because you scheduled in the common modes --

392
00:26:59,080 --> 00:27:03,150
if you get a network error and you put up an
error alert, that's going to do bad things.

393
00:27:03,150 --> 00:27:05,250
The user's going to be hopelessly confused.

394
00:27:05,250 --> 00:27:11,080
It may -- it probably won't crash the
frameworks but it's not going to look good.

395
00:27:11,080 --> 00:27:16,420
So if you use this common mode concept, make sure
you understand the context you're running in.

396
00:27:16,420 --> 00:27:21,750
And for example, you can use other mechanisms like a
short timer that's scheduled only in the default mode

397
00:27:21,750 --> 00:27:24,430
to defer these sorts of user interface operations.

398
00:27:24,430 --> 00:27:33,650
As you're using run loops, keep in mind the following:
There's never any need to create or destroy run loops.

399
00:27:33,650 --> 00:27:39,090
Run loops are created on demand per thread and
they're destroyed when the thread's destroyed,

400
00:27:39,090 --> 00:27:42,400
so you don't need to mess with the run loop itself.

401
00:27:42,400 --> 00:27:46,680
In contrast, run loop sources -- it's
vitally important that you invalidate them.

402
00:27:46,680 --> 00:27:51,320
If you think about those previous diagrams, they are massive
pointers with one object pointing to the next object,

403
00:27:51,320 --> 00:27:53,620
which is pointing back to the other object, and so on.

404
00:27:53,620 --> 00:27:57,830
And so it produces a massive amount of
retain loops between all these objects.

405
00:27:57,830 --> 00:28:00,660
And if you fail to invalidate your run loop sources,

406
00:28:00,660 --> 00:28:07,250
then what happens is those retain loops
are never broken and you just leak memory.

407
00:28:07,250 --> 00:28:11,780
Whenever you schedule an event source in a run loop,

408
00:28:11,780 --> 00:28:16,830
you typically sort of have an owning
object, which sort of owns that scheduling.

409
00:28:16,830 --> 00:28:18,760
And before it releases its last reference,

410
00:28:18,760 --> 00:28:22,720
it's vitally important that you invalidate the run
loop source before you release your last reference

411
00:28:22,720 --> 00:28:25,430
to it, otherwise you'll just leak.

412
00:28:25,430 --> 00:28:30,240
And in some cases -- I had a developer today
who was leaking sockets because he was failing

413
00:28:30,240 --> 00:28:34,080
to invalidate his socket run loop sources.

414
00:28:34,080 --> 00:28:40,770
Try to avoid scheduling cross-thread scheduling
where you're running on thread A and you're trying

415
00:28:40,770 --> 00:28:44,060
to schedule an event source on thread B's run loop.

416
00:28:44,060 --> 00:28:45,690
In general, it's meant to work.

417
00:28:45,690 --> 00:28:49,190
It works at least 99% of the time.

418
00:28:49,190 --> 00:28:52,280
So sometimes it just blows up.

419
00:28:52,280 --> 00:28:57,330
But worse than that, you know, we can fix those
bugs; we know about them, we are fixing them.

420
00:28:57,330 --> 00:29:01,840
But the real issue here is that inside your
own code you can get into these race conditions

421
00:29:01,840 --> 00:29:05,890
where the run loop sources are or aren't
scheduled and it just gets very confusing.

422
00:29:05,890 --> 00:29:09,000
So always try and schedule on the current thread's run loop.

423
00:29:09,000 --> 00:29:13,530
And if you need to, use performSelectoronThread
to get over to the thread that you want to be on

424
00:29:13,530 --> 00:29:17,150
and then schedule on the current run loop from there.

425
00:29:17,150 --> 00:29:22,110
Don't run the run loop recursively in
the default mode on the main thread.

426
00:29:22,110 --> 00:29:28,490
The UI frameworks have run loop sources that are only
meant to run in the default mode at the top level

427
00:29:28,490 --> 00:29:31,990
of the framework where you're nearest to main.

428
00:29:31,990 --> 00:29:38,130
If you run the main thread's run loop in the default
mode, those sources will fire in the wrong context

429
00:29:38,130 --> 00:29:45,100
and bad things will happen on both iPhone OS and Mac OS X.

430
00:29:45,100 --> 00:29:47,350
Run loops are a serialization mechanism.

431
00:29:47,350 --> 00:29:50,500
This is vitally useful in most cases.

432
00:29:50,500 --> 00:29:55,410
If you think about a run loop, it monitors
event sources and then calls the callback.

433
00:29:55,410 --> 00:29:59,380
And when the callback returns, it returns
to monitoring the next event source.

434
00:29:59,380 --> 00:30:03,930
So these callbacks are inherently serialized, which
makes your network programming very much easier --

435
00:30:03,930 --> 00:30:08,620
it radically reduces the amount of
race conditions you have to deal with.

436
00:30:08,620 --> 00:30:13,150
But the issue is, of course, that this
serialization can give you latency.

437
00:30:13,150 --> 00:30:18,440
If your main thread is off doing user interface
compositing somewhere or calculating Mandelbrot sets

438
00:30:18,440 --> 00:30:21,540
or whatever it's doing, then while it's doing that,

439
00:30:21,540 --> 00:30:26,030
your network event sources aren't firing
because it's in a run loop callback.

440
00:30:26,030 --> 00:30:31,570
And so you really want to either keep the main
thread doing very nonsynchronous operations, i.e.,

441
00:30:31,570 --> 00:30:36,970
always returning to the run loop quickly or in some cases
it's a good idea to create a single, secondary thread

442
00:30:36,970 --> 00:30:40,830
and put all of your network event sources on that thread.

443
00:30:40,830 --> 00:30:47,160
And so they will never be held off
due to latency on the main thread.

444
00:30:47,160 --> 00:30:50,380
And finally, there's this problem with hidden threads.

445
00:30:50,380 --> 00:30:53,610
I'm going to go into that in a little more detail.

446
00:30:53,610 --> 00:30:58,310
Here you see me doing performSelectorInBackground
to call the doStuff method.

447
00:30:58,310 --> 00:31:04,080
Now when the doStuff method runs, it's running
on a secondary thread -- that's the whole point.

448
00:31:04,080 --> 00:31:07,610
It does its stuff and then when it's
finished, it wants to schedule a timer

449
00:31:07,610 --> 00:31:11,400
to continue doing more stuff in about a second from now.

450
00:31:11,400 --> 00:31:17,120
Now the thing here is that that doMoreStuff method
that it's trying to call can never possibly execute.

451
00:31:17,120 --> 00:31:23,540
And the reason is the schedule timer with time
interval method always targets the current run loop,

452
00:31:23,540 --> 00:31:27,630
which is the run loop associated with the
current thread, which is a secondary thread

453
00:31:27,630 --> 00:31:31,930
because we ran doStuff using performSelector
in the background.

454
00:31:31,930 --> 00:31:38,150
Now when that secondary thread is created by performSelector
in background, it's created, it calls doStuff,

455
00:31:38,150 --> 00:31:40,520
and when doStuff returns, it's destroyed.

456
00:31:40,520 --> 00:31:45,890
And so any event source that you schedule on it will never
run because the secondary thread never runs the run loop.

457
00:31:45,890 --> 00:31:49,310
It's a real "gotcha" that confuses a lot
of people, so what watch out for this one.

458
00:31:49,310 --> 00:31:54,290
And this is why hidden threads are a danger if
you're mixing and matching threads and run loops.

459
00:31:54,290 --> 00:31:58,350
And that wraps it up for run loops.

460
00:31:58,350 --> 00:31:59,130
It's been a long haul.

461
00:31:59,130 --> 00:32:03,750
Glass is almost full to the fifth stage, which will be good.

462
00:32:03,750 --> 00:32:06,970
The last thing I wanted to deal with is state management.

463
00:32:06,970 --> 00:32:12,790
And this is the idea of how you connect the states of the
front end of your application -- the user visible states --

464
00:32:12,790 --> 00:32:17,190
to the states of the back end of your application,
the states associated with the networking.

465
00:32:17,190 --> 00:32:21,480
Doing operations on the networking typically requires
lots of states as you get this thing in posit

466
00:32:21,480 --> 00:32:24,080
and then deal with the results and so on.

467
00:32:24,080 --> 00:32:28,050
But the user interface hopefully has
very simple states because you don't need

468
00:32:28,050 --> 00:32:31,340
to display a lot of state information to the user.

469
00:32:31,340 --> 00:32:35,890
Now, a really easy example of this
is this placeholder mechanism.

470
00:32:35,890 --> 00:32:38,980
The only piece of state shared
between the user interface code

471
00:32:38,980 --> 00:32:44,500
and the model objects is whether
the placeholder has been got or not.

472
00:32:44,500 --> 00:32:47,990
That's one piece of state: Are we busy or what's the image?

473
00:32:47,990 --> 00:32:52,790
In fact, in many cases, if you follow the advice from my
previous talk, you don't really need to share state here

474
00:32:52,790 --> 00:32:56,240
at all; all you need to do is get
the object -- which is the image --

475
00:32:56,240 --> 00:33:00,630
and listen for notifications for changes to that object.

476
00:33:00,630 --> 00:33:07,540
In contrast, solicited operations, ones that the
user is expecting -- specifically requested --

477
00:33:07,540 --> 00:33:10,830
and they want progress on, is a little more state there.

478
00:33:10,830 --> 00:33:16,180
Obviously you need to know whether the back end is busy --
here's an example in Safari where if the back end is busy,

479
00:33:16,180 --> 00:33:19,770
we get a Stop button rather than a Refresh button.

480
00:33:19,770 --> 00:33:24,080
And similarly, if the back end is busy, you get
a progress bar, so that's two pieces of state.

481
00:33:24,080 --> 00:33:27,980
And if the back end fails, if the
model objects can't fetch the data,

482
00:33:27,980 --> 00:33:31,100
then you get another piece of state, which is the error.

483
00:33:31,100 --> 00:33:35,990
And in addition to that, there's one piece of
control flow that goes down, which is the cancel.

484
00:33:35,990 --> 00:33:40,290
But the reality is the state sharing is really small here.

485
00:33:40,290 --> 00:33:43,640
Safari is doing a lot of weird
things to get data off the network.

486
00:33:43,640 --> 00:33:50,610
It's going through probably hundreds of network states to
get the primary URL posit, get all these images, and so on.

487
00:33:50,610 --> 00:33:55,560
But the front end is seeing one state -- you know,
effectively one state -- which is: Are we busy or not?

488
00:33:55,560 --> 00:34:01,600
And so it's very relatively easy to map your
back end states to your front end states in a way

489
00:34:01,600 --> 00:34:06,620
that the user can understand and that's reasonably
easy to wrangle in terms of your user interface.

490
00:34:06,620 --> 00:34:08,480
Typically it involves: Are we busy?

491
00:34:08,480 --> 00:34:09,990
What's the progress?

492
00:34:09,990 --> 00:34:12,290
And was there an error?

493
00:34:12,290 --> 00:34:19,340
So the take-home message here is: Asynchronous
programming means you will have to do state management

494
00:34:19,340 --> 00:34:22,600
in your user interface; it's really that simple.

495
00:34:22,600 --> 00:34:23,940
But it's not as hard as you might think.

496
00:34:23,940 --> 00:34:27,370
It doesn't require a huge reworking of your user interface.

497
00:34:27,370 --> 00:34:29,560
In most cases, it requires a very simple rework.

498
00:34:29,560 --> 00:34:36,430
And the real trick is to hide all of the irrelevant states
down in the model so that the model goes through a bunch

499
00:34:36,430 --> 00:34:42,120
of complicated states and the front end only says
"busy" or "not busy," "error" or "not error."

500
00:34:42,120 --> 00:34:45,400
And then, of course, for the front end
to know about changes to the state,

501
00:34:45,400 --> 00:34:47,660
you have to have some sort of model notification.

502
00:34:47,660 --> 00:34:53,840
And that is something that I talked about in Part 1 of this
talk and something that's too complicated to recap here.

503
00:34:53,840 --> 00:34:58,450
So if you missed Part 1, you might want
to go back and look at it on the video.

504
00:34:58,450 --> 00:35:04,620
So that wraps up state management and it fills the first
part of the glass -- we're happy about that I think.

505
00:35:04,620 --> 00:35:06,500
Well done.

506
00:35:06,500 --> 00:35:12,030
[ Applause ]

507
00:35:12,030 --> 00:35:15,260
>> And I'm running really fast,
which is probably a good thing.

508
00:35:15,260 --> 00:35:18,460
Okay. Next point: debugging.

509
00:35:18,460 --> 00:35:21,660
Network debugging is traditionally hard.

510
00:35:21,660 --> 00:35:26,000
This is the guy with the network debugging program.

511
00:35:26,000 --> 00:35:27,980
Now why is it hard?

512
00:35:27,980 --> 00:35:32,300
It's hard because the network is asynchronous and
it's hard because network behavior is dependent

513
00:35:32,300 --> 00:35:38,820
on environmental factors that you can't control, such
as how many MiFi iPad stations there are out there.

514
00:35:38,820 --> 00:35:42,480
And so if you get these problems coming in
from the field, it's very hard to debug them.

515
00:35:42,480 --> 00:35:47,600
And similarly, you may encounter this problem that
only happens once in every 10,000 executions and

516
00:35:47,600 --> 00:35:51,600
yet it still crashes on a number of users and annoys them.

517
00:35:52,880 --> 00:35:55,910
My first tip here.

518
00:35:55,910 --> 00:35:57,100
[ Laughter ]

519
00:35:57,100 --> 00:36:02,520
Now, you're laughing because you think
it's a joke but it's not really a joke.

520
00:36:02,520 --> 00:36:08,020
There are lots of things you can do to
minimize the bug count in your program.

521
00:36:08,020 --> 00:36:11,970
The number one most important thing is design.

522
00:36:11,970 --> 00:36:18,180
If I'm writing a user interface application, I'll often sit
down and write a line of code, put up a table, view, run it,

523
00:36:18,180 --> 00:36:24,500
change the code, run it again, see whether it
works, get a bug, fix the bug, and so on --

524
00:36:24,500 --> 00:36:28,100
sort of this incremental implementation approach.

525
00:36:28,100 --> 00:36:33,360
That works fine for user interface code where
everything tends to run in a deterministic fashion;

526
00:36:33,360 --> 00:36:35,780
it's a real disaster for networking code.

527
00:36:35,780 --> 00:36:39,470
The networking code you have to plan in
advance, you have to understand the states

528
00:36:39,470 --> 00:36:43,180
that the network can be in, and how those states change.

529
00:36:43,180 --> 00:36:45,860
And you have to understand how
those states affect your model

530
00:36:45,860 --> 00:36:49,590
and how those states affect the
front end of your application.

531
00:36:49,590 --> 00:36:54,530
Plan that out in advance so that you're not
building it from scratch and keep changing it

532
00:36:54,530 --> 00:36:57,380
because if you change it, that will introduce bugs.

533
00:36:57,380 --> 00:37:00,540
So try and design it in advance and stick with it.

534
00:37:00,540 --> 00:37:05,340
And if you have to change it, think
very carefully about how you change it.

535
00:37:05,340 --> 00:37:08,990
My other tips are a little bit more prosaic.

536
00:37:08,990 --> 00:37:12,360
You know, I get projects from developers
and they're like, "This crashes."

537
00:37:12,360 --> 00:37:12,820
And you go, "Okay."

538
00:37:12,820 --> 00:37:16,160
And you build it and it's got compiler
warnings and it's like well, that's step one.

539
00:37:16,160 --> 00:37:20,480
And then you run a static analyzer
and it's got static analyzer warnings.

540
00:37:20,480 --> 00:37:24,590
It's like life is too short to debug network
problems and these other silly problems.

541
00:37:24,590 --> 00:37:28,150
You get the silly problems out of the
way and that makes compiler warnings,

542
00:37:28,150 --> 00:37:30,890
that makes the static analyzer, that
means adding asserts to your code.

543
00:37:30,890 --> 00:37:35,970
Asserts are really useful for tracking down bizarre
networking problems because if things happen

544
00:37:35,970 --> 00:37:41,520
in the wrong order and the program's not executing
the way you expect, your assert fires and instead

545
00:37:41,520 --> 00:37:45,260
of corrupting some vitally important
state, you end up straight in the debugger.

546
00:37:45,260 --> 00:37:47,930
So that's a huge win for network programmers.

547
00:37:47,930 --> 00:37:49,640
And similarly, memory management warnings.

548
00:37:49,640 --> 00:37:56,380
Memory management errors are very
indeterministic as well, just like network errors.

549
00:37:56,380 --> 00:37:59,960
So don't try and debug your memory management
problems and your network problems at the same time;

550
00:37:59,960 --> 00:38:04,200
use zombies to flush out the memory
management problems first.

551
00:38:04,200 --> 00:38:11,370
In terms of real network debugging, the
first point I want to talk about is logging.

552
00:38:11,370 --> 00:38:14,810
Now logging has a bad reputation in debugging circles.

553
00:38:14,810 --> 00:38:18,100
People disparagingly refer to it as "printf debugging."

554
00:38:18,100 --> 00:38:21,380
And it's considered sort of a 1970s technology.

555
00:38:21,380 --> 00:38:23,620
I love logging.

556
00:38:23,620 --> 00:38:27,390
Logging is the first thing I add to
my network programs and the reason is

557
00:38:27,390 --> 00:38:31,510
because in my opinion, logging is like a TARDIS.

558
00:38:31,510 --> 00:38:34,130
Okay, if you're not -- okay, we have some Dr.

559
00:38:34,130 --> 00:38:37,300
Who fans out here.

560
00:38:37,300 --> 00:38:37,360
[ Applause ]

561
00:38:37,360 --> 00:38:41,330
This TARDIS is about five minutes' walk away
from my flat in Glascow, it's pretty cool.

562
00:38:41,330 --> 00:38:44,610
So if you're not a Dr.

563
00:38:44,610 --> 00:38:51,110
Who fan, a TARDIS is a vehicle that can travel anywhere
in time and space and that's what logging does for you.

564
00:38:51,110 --> 00:38:54,830
These network bugs are indeterministic
and sometimes they happen in real time.

565
00:38:54,830 --> 00:38:57,950
If you stop in the debugger, then
the service stops sending you data

566
00:38:57,950 --> 00:39:01,220
and it eventually times out and gives up on the connection.

567
00:39:01,220 --> 00:39:02,410
And so you can't just stop on the debugger.

568
00:39:02,410 --> 00:39:09,910
But if you've got good logging in there, you can play the
thing out in real time or wait for the error to happen.

569
00:39:09,910 --> 00:39:15,100
And then when it does, go back through the logger
and replay time at a speed that you can understand.

570
00:39:15,100 --> 00:39:18,510
And that's a critical piece of network debugging technology.

571
00:39:18,510 --> 00:39:22,160
And as I say, it gets a bad rep but it's good stuff.

572
00:39:22,160 --> 00:39:25,770
In addition, logging lets you travel in space.

573
00:39:25,770 --> 00:39:33,750
You've got some user in Uzbekistan whose network always
reproduces this problem but you can't reproduce it ever.

574
00:39:33,750 --> 00:39:39,710
You've got an app reviewer that always refuses
this problem and you can't reproduce it ever.

575
00:39:39,710 --> 00:39:40,780
What do you do?

576
00:39:40,780 --> 00:39:45,330
You can't go to Uzbekistan or indeed, the
app review offices to debug the problem.

577
00:39:45,330 --> 00:39:45,860
So what do you do?

578
00:39:45,860 --> 00:39:50,180
And the answer is you have that user
turn on the logging and send you the log.

579
00:39:50,180 --> 00:39:52,940
So it's don't skimp on the logging
when you're writing a network problem,

580
00:39:52,940 --> 00:39:59,450
it's a critical part of making a network
problem that can be debugged in the real world.

581
00:39:59,450 --> 00:40:05,330
So when you do it -- many people
disable the logging when they're done.

582
00:40:05,330 --> 00:40:08,820
You know, in the release build they
remove the logging so it can't be enabled

583
00:40:08,820 --> 00:40:12,090
because they think it will slow
down their program or something.

584
00:40:12,090 --> 00:40:17,470
My experience is you want to leave it in there -- leave
it in there and leave it disabled and provide a way

585
00:40:17,470 --> 00:40:21,760
for the user to turn it on so that
they can get you in the field reports.

586
00:40:21,760 --> 00:40:23,040
Try to make the logging persistent.

587
00:40:23,040 --> 00:40:32,280
If the application crashes, having all the logging
information in memory is not going to help you; it's gone.

588
00:40:32,280 --> 00:40:39,230
And similarly, if the user has a problem and then quits
your application, launches mail, say, "I've got a problem."

589
00:40:39,230 --> 00:40:40,960
And you say, "Well, what did the log say?"

590
00:40:40,960 --> 00:40:42,260
That's not helping really, is it?

591
00:40:42,260 --> 00:40:43,960
Because it's gone.

592
00:40:43,960 --> 00:40:45,470
Also make it easy to retrieve.

593
00:40:45,470 --> 00:40:48,190
I really like the in-app email feature of iPhone OS 3

594
00:40:48,190 --> 00:40:52,480
because you can automatically create
an email and attach the log to it.

595
00:40:52,480 --> 00:40:57,750
It makes it very easy for the user to get the log to you.

596
00:40:57,750 --> 00:41:04,410
Packet traces are a way to log what's going on in the wire;
it's another form of logging but it's a very specialist form

597
00:41:04,410 --> 00:41:08,360
of logging -- it allows you to see all
the packets traveling over the network.

598
00:41:08,360 --> 00:41:12,020
Packet traces are another critical
network debugging technology.

599
00:41:12,020 --> 00:41:14,370
They allow you to do divide and conquer.

600
00:41:14,370 --> 00:41:18,290
You have a problem with a server and a
client and you can't never really tell,

601
00:41:18,290 --> 00:41:23,050
is it the client sending the wrong request
or the server responding incorrectly?

602
00:41:23,050 --> 00:41:24,040
Well, what do you do?

603
00:41:24,040 --> 00:41:28,560
You run a packet trace, see what went
over the wire, and then you know for sure.

604
00:41:28,560 --> 00:41:32,480
Similarly, you can use packet traces for comparison.

605
00:41:32,480 --> 00:41:37,580
If client A works and client B doesn't, you packet
trace both of them and see what's the difference

606
00:41:37,580 --> 00:41:40,680
between the requests that were sent and then fix that.

607
00:41:40,680 --> 00:41:42,500
It's also great for verification.

608
00:41:42,500 --> 00:41:48,320
Every now and again you run a packet trace over
your program and see what it's sending on the wire.

609
00:41:48,320 --> 00:41:50,490
I like to think of it as leaks for the network.

610
00:41:50,490 --> 00:41:52,860
Every now and again, you're sending
things you weren't expecting.

611
00:41:52,860 --> 00:41:56,660
You might have typed "http" instead of "https" by accident

612
00:41:56,660 --> 00:41:59,560
and now you're sending all the user's
confidential information in plain text.

613
00:41:59,560 --> 00:42:05,990
And the only people who are going to find out -- if
you're lucky -- are app review or the black hats.

614
00:42:05,990 --> 00:42:08,240
Similarly, you might have a game update timer.

615
00:42:08,240 --> 00:42:12,440
And so you're sending your game state every
tenth of a second and you forget to invalidate it

616
00:42:12,440 --> 00:42:18,500
and now you're sending your game state twice
to every 20th of a second and that's bad.

617
00:42:18,500 --> 00:42:25,190
So look at the packets on the wire with the packet
analyzer and see what's going on, just every now and again.

618
00:42:25,190 --> 00:42:29,500
Also, if you do this, make sure you have some
feature in your debug build to turn off your

619
00:42:29,500 --> 00:42:33,710
on the wire privacy features, typically TLS,
because the packet trace works a lot better

620
00:42:33,710 --> 00:42:36,980
if you can actually see inside the packets.

621
00:42:36,980 --> 00:42:40,930
Now there's a Q&A -- packet traces aren't
available in iPhone OS but if you go to Mac Handy,

622
00:42:40,930 --> 00:42:46,460
you can take a packet trace with
the tools referenced in this Q&A.

623
00:42:48,340 --> 00:42:51,740
And finally, there's the simulator.

624
00:42:51,740 --> 00:42:57,550
The simulator is a great tool, especially since iPhone
OS 3 for doing network debugging -- surprisingly so.

625
00:42:57,550 --> 00:43:02,960
The simulator and the iPhone behave quite similarly if
you're using typical application debugging technologies.

626
00:43:02,960 --> 00:43:05,880
So it's fine to do a lot of network
debugging in the simulator

627
00:43:05,880 --> 00:43:08,870
and if you do that, you get access to Mac OS X tools.

628
00:43:08,870 --> 00:43:14,980
And my favorite tool of all time is DTrace, it's
like super-logging that you don't have to write.

629
00:43:14,980 --> 00:43:19,170
Of course, if you're running on the simulator,
you're running on the Mac OS X kernel

630
00:43:19,170 --> 00:43:21,280
so nothing really behaves exactly the same as an iPhone.

631
00:43:21,280 --> 00:43:24,200
So you have to do your real testing on an iPhone.

632
00:43:24,200 --> 00:43:30,210
And that's my talk on debugging and network debugging.

633
00:43:30,210 --> 00:43:37,520
My next step is the common mistakes,
notably putting foam at the top

634
00:43:37,520 --> 00:43:43,170
of an empty beer glass apparently is a common
mistake, too -- I have to fix that one.

635
00:43:43,170 --> 00:43:46,740
Number one common mistake: main thread synchronous.

636
00:43:46,740 --> 00:43:47,760
We see it all the time.

637
00:43:47,760 --> 00:43:52,380
Some significant proportion of app review rejections
have occurred because people turn on airplane mode

638
00:43:52,380 --> 00:43:55,380
on the iPhone, they launch the app, it crashes.

639
00:43:55,380 --> 00:43:58,410
And we see millions of these -- probably not millions --

640
00:43:58,410 --> 00:44:02,760
but probably hundreds of thousands of these come
in every day through the crash reporting mechanism.

641
00:44:02,760 --> 00:44:06,320
Just don't do it.

642
00:44:06,320 --> 00:44:08,710
Number two: threads.

643
00:44:08,710 --> 00:44:14,040
As I like to say, "Networking is hard
enough without involving threads as well."

644
00:44:14,040 --> 00:44:16,440
I see applications like this all the time.

645
00:44:16,440 --> 00:44:18,620
They think, "Let's do something asynchronously."

646
00:44:18,620 --> 00:44:24,000
Of course, asynchronously means "threads" and they have
these threads running through all of their model objects,

647
00:44:24,000 --> 00:44:26,160
all through their view controllers, all through their views.

648
00:44:26,160 --> 00:44:32,360
And at some point, somewhere in that code, they call
UIKit on one of those threads and it doesn't blow up most

649
00:44:32,360 --> 00:44:34,730
of the time but every now and again it just goes boom.

650
00:44:34,730 --> 00:44:36,440
And they go, "How do I fix that?"

651
00:44:36,440 --> 00:44:40,510
And the answer is: get in your TARDIS and go back 6 months

652
00:44:40,510 --> 00:44:43,470
and design your applications properly
and then it won't happen.

653
00:44:43,470 --> 00:44:45,050
[ Laughter ]

654
00:44:45,050 --> 00:44:46,470
So be very careful with the threads.

655
00:44:46,470 --> 00:44:50,600
It's not the threads that are evil -- well, they are kind
of evil -- it's not that threads don't have their place,

656
00:44:50,600 --> 00:44:57,530
it's just their place is deep in
your model and very well-contained.

657
00:44:57,530 --> 00:45:03,330
The interface life cycle -- this can get
very confusing so I've put up a chart.

658
00:45:03,330 --> 00:45:09,500
There are a variety of interfaces on
iPhone OS: Bluetooth, cellular, Wi-Fi.

659
00:45:09,500 --> 00:45:12,360
They come and go on different life cycles.

660
00:45:12,360 --> 00:45:16,850
Bluetooth is easy -- when you resolve a Bonjour
service, the Bluetooth interface comes up.

661
00:45:16,850 --> 00:45:18,060
We talked about that earlier today.

662
00:45:18,060 --> 00:45:25,110
And so if you're confused by it, take a
look at the video for the Bonjour session.

663
00:45:25,110 --> 00:45:27,460
Bluetooth interfaces go down on idle.

664
00:45:27,460 --> 00:45:30,110
They don't go down when you disconnect; they go

665
00:45:30,110 --> 00:45:33,330
down when the interface hasn't had
many packets over it for a few minutes.

666
00:45:33,330 --> 00:45:38,990
So a few minutes after you stop talking on
the interface, that's when it goes down.

667
00:45:38,990 --> 00:45:44,390
The cellular interface often will be
pinned up by various services, for example,

668
00:45:44,390 --> 00:45:48,670
push notification will typically pin
the cellular interface up all the time.

669
00:45:48,670 --> 00:45:52,610
If the cellular interface isn't up,
then its life cycle isn't being held up,

670
00:45:52,610 --> 00:45:56,200
then its life cycle is controlled by the API as you call.

671
00:45:56,200 --> 00:46:00,970
It comes up when you connect to a network service
and that assumes you're using CF Socket stream

672
00:46:00,970 --> 00:46:04,670
or higher, which means CFNetwork or Foundation.

673
00:46:04,670 --> 00:46:09,210
If you use BSD sockets, the cellular interface
won't automatically come up based on connect.

674
00:46:09,210 --> 00:46:13,240
One day we'll fix that but today is not that day.

675
00:46:13,240 --> 00:46:17,880
The cellular interface goes down based on idleness.

676
00:46:17,880 --> 00:46:21,920
So again, if it's going to go down, it will go
down about two minutes after you stop using it --

677
00:46:21,920 --> 00:46:26,690
I think it's two minutes, some short
number of minutes after you stop using it.

678
00:46:26,690 --> 00:46:31,910
The Wi-Fi is substantially more complex, so another slide.

679
00:46:31,910 --> 00:46:34,450
The Wi-Fi comes up based on a number of criteria.

680
00:46:34,450 --> 00:46:38,440
The first one is if it sees a network that it's
seen before -- it's one of your known networks --

681
00:46:38,440 --> 00:46:40,510
then the Wi-Fi will come up automatically.

682
00:46:40,510 --> 00:46:44,990
In addition to that, there are these two
controls: there's a user-level control,

683
00:46:44,990 --> 00:46:48,140
which is asked to join networks and settings.

684
00:46:48,140 --> 00:46:55,760
And if that's on and there's a Wi-Fi app at the foreground,
then the Wi-Fi will put up the Wi-Fi chooser dialogue

685
00:46:55,760 --> 00:47:00,070
and let the user choose a Wi-Fi network and login to it.

686
00:47:00,070 --> 00:47:05,110
And a Wi-Fi app is one that has this
UIRequiresPersistentWiFi, in its plist.

687
00:47:05,110 --> 00:47:08,570
Wi-Fi going down is also somewhat complex.

688
00:47:08,570 --> 00:47:14,670
Wi-Fi goes down 30 minutes after the
last Wi-Fi app has left the foreground.

689
00:47:14,670 --> 00:47:17,110
Now the definition of "foreground"
is quite complicated there.

690
00:47:17,110 --> 00:47:21,450
If you ScreenLock your device, then that
pushes your Wi-Fi app to the background --

691
00:47:21,450 --> 00:47:25,110
not the background of the multitasking
sense, but it makes it inactive.

692
00:47:25,110 --> 00:47:27,630
And that means that the ScreenLock
is the front-most application.

693
00:47:27,630 --> 00:47:30,330
If you think like a Mac, it actually makes more sense here.

694
00:47:30,330 --> 00:47:33,370
So the ScreenLock becomes the front-most
application, which means --

695
00:47:33,370 --> 00:47:36,830
and the ScreenLock doesn't have
UIRequiresPersistentWiFi set.

696
00:47:36,830 --> 00:47:41,680
So if you ScreenLock, then your
UIRequiresPersistentWiFi setting is no longer relevant

697
00:47:41,680 --> 00:47:44,860
and the Wi-Fi will go down in about 30 minutes after that.

698
00:47:44,860 --> 00:47:50,280
But it's worse than that because if you're not running
on batteries, then when you ScreenLock the device,

699
00:47:50,280 --> 00:47:54,270
unless something else is keeping the
CPU awake, the CPU will shut down.

700
00:47:54,270 --> 00:47:56,880
So it will go to sleep like a Mac would go to sleep.

701
00:47:56,880 --> 00:47:59,970
And when that happens, then the Wi-Fi goes down as well.

702
00:47:59,970 --> 00:48:04,890
The whole story is also complicated
by this notion of captive networks.

703
00:48:04,890 --> 00:48:09,080
Now both -- I'm not quite sure if I talked
about captive networks, I know Brett did,

704
00:48:09,080 --> 00:48:10,840
I think Stritt did as well.

705
00:48:10,840 --> 00:48:17,040
Captive networks is a complicated topic and you'll have
to catch the information on those in the previous talks

706
00:48:17,040 --> 00:48:25,680
and also last year's iPhone networking talk
as well talks a lot about captive networks.

707
00:48:25,680 --> 00:48:27,320
Reachability.

708
00:48:27,320 --> 00:48:33,370
Now, you never thought that I would complain about
this but it's an API that people use too much.

709
00:48:33,370 --> 00:48:38,990
Don't use Reachability pre-flight -- we've had
that in all three sessions this week and it's true.

710
00:48:38,990 --> 00:48:45,030
Reachability is about user interface, it's
about telling the user what's gone wrong;

711
00:48:45,030 --> 00:48:47,970
it's not about telling you whether you can connect or not.

712
00:48:47,970 --> 00:48:52,310
So if you want to connect, connect -- it's just that simple.

713
00:48:52,310 --> 00:48:56,830
If it fails, you can then use Reachability
to get some idea of why it failed

714
00:48:56,830 --> 00:48:59,610
and maybe guide the user as to how to fix it.

715
00:48:59,610 --> 00:49:05,510
Or you could start a Reachability operation in parallel with
your connection operation so that you minimize the amount

716
00:49:05,510 --> 00:49:09,750
of time that you displayed imprecise state to the user.

717
00:49:09,750 --> 00:49:14,840
But don't use Reachability before
you connect, just try and connect.

718
00:49:14,840 --> 00:49:19,410
Similarly, don't use Reachability to determine
the interface type for the sake of speed.

719
00:49:19,410 --> 00:49:21,840
We're going to talk about that in the next slides.

720
00:49:21,840 --> 00:49:28,420
What you want to use Reachability for is to guide your user
interface, provide useful feedback to the user to say, "No,

721
00:49:28,420 --> 00:49:31,930
this is never going to work; you
need to fix your networking."

722
00:49:31,930 --> 00:49:34,220
It's also a good idea to trigger retries.

723
00:49:34,220 --> 00:49:39,600
If you've got a whole bunch of queued operations and they've
all failed and you've retried them once and they don't seem

724
00:49:39,600 --> 00:49:43,610
to be working, then you can queue them
all up behind a Reachability change.

725
00:49:43,610 --> 00:49:48,740
And when the Reachability changes, then
retry some of them and see whether they work.

726
00:49:48,740 --> 00:49:52,400
It's no point retrying them until Reachability
changes because chances are the reason

727
00:49:52,400 --> 00:49:57,380
for the failure was a problem with the local network stay.

728
00:49:57,380 --> 00:50:01,900
Another example of Reachability where it's
useful is interface-specific connectivity.

729
00:50:01,900 --> 00:50:06,660
I see developers who have licensed content that
can only be displayed if the application is running

730
00:50:06,660 --> 00:50:09,490
on cellular, you know, movie content and so on.

731
00:50:09,490 --> 00:50:14,020
And that's a good reason to using
Reachability to determine the interface type.

732
00:50:14,020 --> 00:50:18,380
A bad reason is to estimate the speed.

733
00:50:18,380 --> 00:50:22,630
In terms of using Reachability, use it asynchronously.

734
00:50:22,630 --> 00:50:25,560
It's like any other API: if you use it
synchronously, you will be killed --

735
00:50:25,560 --> 00:50:28,660
on the main thread at least --
you'll be killed by the watchdog.

736
00:50:28,660 --> 00:50:30,090
There's a Reachability sample.

737
00:50:30,090 --> 00:50:32,100
Make sure you get version 2.

738
00:50:32,100 --> 00:50:37,060
If you got a previous version of the sample, go
and make sure you update to the version two version

739
00:50:37,060 --> 00:50:41,840
because the previous version -- how best to put that?

740
00:50:41,840 --> 00:50:47,840
"Severely suboptimal," shall we say.

741
00:50:47,840 --> 00:50:49,000
Interface type.

742
00:50:49,000 --> 00:50:52,380
And this is interface type for this question.

743
00:50:52,380 --> 00:50:54,070
What type of interface am I on?

744
00:50:54,070 --> 00:51:01,050
Which really means -- and also what type of cellular am
I on, which really means: What speed is this network?

745
00:51:01,050 --> 00:51:05,530
This is a fundamentally broken question.

746
00:51:05,530 --> 00:51:11,970
The network speed is independent of the
link layer speed -- it's really that simple.

747
00:51:11,970 --> 00:51:20,850
If you're talking across a MiFi, which is going to
be my example for this talk, your back call is a 3G.

748
00:51:20,850 --> 00:51:27,080
So if you're talking to anything on the wider Internet,
knowing that you're connected by MiFi isn't going to help.

749
00:51:27,080 --> 00:51:32,950
If you're talking on 3G, on cellular on 3G in
this room, you're probably going slower than Edge

750
00:51:32,950 --> 00:51:35,990
because every other device in this room is talking on 3G.

751
00:51:35,990 --> 00:51:40,600
Whereas very few people still have first generation iPhones
in this room, so very few people will be using Edge.

752
00:51:40,600 --> 00:51:46,860
So if you need to know the speed of the
network, measure the speed of the network --

753
00:51:46,860 --> 00:51:49,950
get a small file, download it, see how fast it goes.

754
00:51:49,950 --> 00:51:53,270
And also adapt to changes because
the speed can change over time.

755
00:51:53,270 --> 00:51:55,280
So just be careful with this one.

756
00:51:55,280 --> 00:52:03,210
Don't ask me what sort of interface we're on
purely so you can get an estimate of the speed.

757
00:52:03,210 --> 00:52:09,370
Timeouts -- another thing that we see with common
questions and it's generally one of those flawed questions.

758
00:52:09,370 --> 00:52:19,150
The network timeouts are set to the default values for a
reason, specifically on cellular it can often take tens

759
00:52:19,150 --> 00:52:25,680
of seconds for the cellular network to come up, which means
that if you lower the network timeout to a few seconds,

760
00:52:25,680 --> 00:52:30,230
you may have connected to the network,
caused the cellular to start coming up,

761
00:52:30,230 --> 00:52:36,110
and then timed out before it's finished coming up, which
means you're wasting power and not getting connected.

762
00:52:36,110 --> 00:52:42,250
So make sure -- well, as a rule you want to
leave the timeouts set to their default values.

763
00:52:42,250 --> 00:52:45,540
Now, if you're worried about what
impact that has on your user interface,

764
00:52:45,540 --> 00:52:48,400
then solve that problem at the user interface level.

765
00:52:48,400 --> 00:52:54,380
If it's a solicited operation -- something that the user
specifically requested -- then put up a progress dialogue,

766
00:52:54,380 --> 00:52:58,920
put up a cancellation button, keep retrying until it works.

767
00:52:58,920 --> 00:53:02,210
And if the user can then walk in range
of their base station, it will all work.

768
00:53:02,210 --> 00:53:06,970
The last thing you really want -- I
see this all the time on my Mac --

769
00:53:06,970 --> 00:53:10,570
where I go open the lid and then
try and connect with my VPN.

770
00:53:10,570 --> 00:53:15,690
And my VPN software says "connection
failed," because my Wi-Fi hasn't yet --

771
00:53:15,690 --> 00:53:18,600
it took a second or two for my Wi-Fi to bind to the network.

772
00:53:18,600 --> 00:53:19,870
That's really annoying.

773
00:53:19,870 --> 00:53:24,730
If the VPN software had just kept retrying,
then when the Wi-Fi bound, it would have worked.

774
00:53:24,730 --> 00:53:28,700
Or if the Wi-Fi wasn't working, I would have walked
in range of my base station and then it would work.

775
00:53:28,700 --> 00:53:30,560
And then it would automatically connect.

776
00:53:30,560 --> 00:53:36,490
So don't just timeout for user interface
operations; let the user cancel and just keep trying.

777
00:53:36,490 --> 00:53:41,470
For unsolicited operations where there's no real
user interface, then yes, you will need timeouts

778
00:53:41,470 --> 00:53:46,930
but just use the default timeouts -- that's
fine, the user isn't waiting for them.

779
00:53:46,930 --> 00:53:55,800
That wraps up my common mistakes, which wraps
up my talk as a whole: two hours of networking.

780
00:53:55,800 --> 00:53:57,440
Sorry, guys.

781
00:53:57,440 --> 00:53:59,800
I need a beer, I don't know about you.

782
00:53:59,800 --> 00:54:03,390
But first, a summary.

783
00:54:03,390 --> 00:54:05,000
Networking is hard.

784
00:54:05,000 --> 00:54:07,120
We can't fix this at the API level.

785
00:54:07,120 --> 00:54:14,070
It's a fundamental issue of networking and the best
way to make it easy is to design your project properly.

786
00:54:14,070 --> 00:54:17,560
Good architecture is how to make it easy.

787
00:54:17,560 --> 00:54:22,270
In addition to that, what I talked about
in this talk is asynchronous programming,

788
00:54:22,270 --> 00:54:31,160
how using run loops is really your source of solving
the problem of doing the networking off the main thread,

789
00:54:31,160 --> 00:54:37,590
and how you can use NSOperation to structure your
high-level application into asynchronous operations

790
00:54:37,590 --> 00:54:40,990
so that the network details don't
leak out into your application.

791
00:54:40,990 --> 00:54:45,700
Plan for debugging -- adding logging
once you've got a bug is painful.

792
00:54:45,700 --> 00:54:53,980
You really want to add the logging in advance, then deploy
the users, then get the logs, not the other way around.

793
00:54:53,980 --> 00:54:56,770
And try to avoid the common mistakes.

794
00:54:56,770 --> 00:55:03,560
I have lots more common mistakes, I could have kept
going all day but those were the real tough ones.

795
00:55:03,560 --> 00:55:06,930
So for the moment that's it.

796
00:55:06,930 --> 00:55:08,280
I'm Quinn "The Eskimo!"

797
00:55:08,280 --> 00:55:09,770
That's my email address.

798
00:55:09,770 --> 00:55:13,420
Paul Danbold is doing our network evangelism at the moment.

799
00:55:13,420 --> 00:55:16,090
There's tons of documentation on our website.

800
00:55:16,090 --> 00:55:19,610
Apple developer forums, the Core
OS section is where I hangout.

801
00:55:19,610 --> 00:55:21,540
So feel free to come and ask us a question.

802
00:55:21,540 --> 00:55:25,930
You're more likely to get an answer on dev forums
than you are if you send me a personal email

803
00:55:25,930 --> 00:55:30,870
because if I answer you on dev
forums, everyone sees the answer.

804
00:55:30,870 --> 00:55:35,420
Sample code -- use the iPhone sample code but
don't be afraid to use the Mac OS X sample code.

805
00:55:35,420 --> 00:55:41,190
Mac OS X and iPhone -- the networking is architecturally
very similar and most samples work on both.

806
00:55:41,190 --> 00:55:47,840
In addition to WWDC attendees, as a special one-time offer,
you can get the Linked Image Fetcher sample which shows how

807
00:55:47,840 --> 00:55:53,990
to use NSOperation to do asynchronous
operations and use the networking.

808
00:55:53,990 --> 00:56:00,460
And last but not least -- well, actually
not quite last -- related sessions.

809
00:56:00,460 --> 00:56:04,950
Obviously my first session has already passed, so
you'll have to catch that on video if you missed it.

810
00:56:04,950 --> 00:56:08,010
All the other sessions have passed
except for Understanding Crash Reports.

811
00:56:08,010 --> 00:56:21,530
It's a really good session, I highly recommend it.

