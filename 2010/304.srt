1
00:00:07,860 --> 00:00:09,340
>> Steve Lewallen: Well good morning everyone.

2
00:00:09,340 --> 00:00:13,700
Thank you for coming to the What's
New with Instruments session.

3
00:00:13,700 --> 00:00:17,730
My name is Steve Lewallen, I'm
the manager of performance tools here at Apple

4
00:00:17,730 --> 00:00:20,950
and today we're going to learn
about all what's new in Instruments.

5
00:00:20,950 --> 00:00:22,270
So let's get started.

6
00:00:22,270 --> 00:00:26,070
So today we're going to learn about
a new, improved user interface.

7
00:00:26,070 --> 00:00:29,040
We're also going to talk about
significant recording techniques

8
00:00:29,040 --> 00:00:32,590
that I think will be very helpful for you all to know.

9
00:00:32,590 --> 00:00:36,000
And we're going to talk about advancements
to existing Instruments.

10
00:00:36,000 --> 00:00:41,030
And finally we're going to discuss more
about our significant new Instruments.

11
00:00:41,030 --> 00:00:44,080
So, let's talk about the UI.

12
00:00:44,080 --> 00:00:46,580
Front and center in the user interface is the Jump bar.

13
00:00:46,580 --> 00:00:49,010
This shows you where you are and how you got there.

14
00:00:49,010 --> 00:00:53,280
It's possibly the most important
UI control in the interface.

15
00:00:53,280 --> 00:00:59,730
You can use this to switch between Instruments and a
particular trace document and you can use it to switch

16
00:00:59,730 --> 00:01:02,840
between detail views of a particular instrument.

17
00:01:02,840 --> 00:01:08,190
And then let's say you focused in on some
important piece of data from one detail view,

18
00:01:08,190 --> 00:01:11,590
you want to get back to where you came
from, just click anywhere on the Jump bar.

19
00:01:11,590 --> 00:01:16,370
For example, the previous segment,
that'll take you right back.

20
00:01:16,370 --> 00:01:22,350
So we've also improved how you can access
the views and see the data in Instruments.

21
00:01:22,350 --> 00:01:25,280
So now you can collapse away just
about anything you don't want to see.

22
00:01:25,280 --> 00:01:30,710
Collapse away the track view, collapse away the
Instruments list and configuration panel on the left.

23
00:01:30,710 --> 00:01:32,380
Collapse away the extended detail view.

24
00:01:32,380 --> 00:01:36,580
And if that's not enough, you can go
full screen which now has the mini bar.

25
00:01:36,580 --> 00:01:40,270
If you move your mouse to the top of the screen
the mini bar appears, move it away it goes away.

26
00:01:40,270 --> 00:01:43,690
Same thing as the rest of the full screen Mac apps.

27
00:01:43,690 --> 00:01:46,090
And we've also made so many improvements in the call tree,

28
00:01:46,090 --> 00:01:50,630
I think we can declare it is the coolest call
tree in the universe, if that's possible.

29
00:01:50,630 --> 00:01:55,080
So to do that the first thing we did is
give you more room for that symbol tree.

30
00:01:55,080 --> 00:01:57,760
I think that's the most important part of that interface.

31
00:01:57,760 --> 00:02:05,800
We did that by combining several columns together
and affording more room for the symbol tree itself.

32
00:02:05,800 --> 00:02:11,600
We also enabled the call tree to
slide under the statistics view.

33
00:02:11,600 --> 00:02:17,140
So you always had the problem where when you had a node
far to the right and you scrolled and scrolled you got it

34
00:02:17,140 --> 00:02:21,780
into view and then the statistics scroll off the screen,
you couldn't see how much was attributed to that node.

35
00:02:21,780 --> 00:02:23,620
So now you can.

36
00:02:23,620 --> 00:02:31,020
Another problem that people would have in using any outline
view is that it's hard to understand what is a sibling

37
00:02:31,020 --> 00:02:33,710
of another node or what are the children of a node.

38
00:02:33,710 --> 00:02:36,320
So we added what we call sibling banding.

39
00:02:36,320 --> 00:02:40,770
So you select a node and you'll see this vertical band
appear and then you can scroll up and down as much

40
00:02:40,770 --> 00:02:44,290
as you want and rest assured that
anything to the right of that band is going

41
00:02:44,290 --> 00:02:47,250
to be a child node within the selected hierarchy.

42
00:02:47,250 --> 00:02:53,450
And of course, when you move your mouse over the nodes,
you also get a highlighting sibling band as well.

43
00:02:53,450 --> 00:02:58,110
We also added, as with Xcode 4,
backtrace compression filtering.

44
00:02:58,110 --> 00:03:00,250
This is really handy.

45
00:03:00,250 --> 00:03:05,750
Basically, this allows you to use the slider
you find at the bottom of the back trace,

46
00:03:05,750 --> 00:03:10,150
to collapse library boundaries down to just your own code.

47
00:03:10,150 --> 00:03:14,690
So you can see what called your code
and then focus on your frames itself.

48
00:03:14,690 --> 00:03:15,740
Very handy.

49
00:03:15,740 --> 00:03:21,600
And of course we have the source view, where we
have performance data in line with the source.

50
00:03:21,600 --> 00:03:26,250
What we've done with the latest release is allow
you to access this directly from other data views.

51
00:03:26,250 --> 00:03:33,360
So for example, in the picture before you, we're on the call
tree view, if we double-click on this Create New Game API,

52
00:03:33,360 --> 00:03:36,730
that will move into the Jump bar
and the source view will come in.

53
00:03:36,730 --> 00:03:40,030
To go back to the call tree, just
click one of the items in the Jump bar.

54
00:03:40,030 --> 00:03:41,500
Very simple.

55
00:03:41,500 --> 00:03:44,270
And of course, all the annotations are colored by severity.

56
00:03:44,270 --> 00:03:49,460
So you want to pay most attention, soonest,
to those things colored the darkest.

57
00:03:49,460 --> 00:03:53,860
And we also have full disassembly
view, both for Intel and ARM

58
00:03:53,860 --> 00:03:57,140
and we still include the performance
annotations in those views.

59
00:03:57,140 --> 00:04:00,550
You can see this by function or
you can see it per annotation.

60
00:04:00,550 --> 00:04:05,510
So if you want to see just the disassembly
for the line of annotation, you can do that.

61
00:04:05,510 --> 00:04:06,810
And we have timeline views.

62
00:04:06,810 --> 00:04:10,020
You can think of these as bookmarks for the trace document.

63
00:04:10,020 --> 00:04:11,650
You can add these manually yourself.

64
00:04:11,650 --> 00:04:15,050
So you see something important
happen, you want to remember it later.

65
00:04:15,050 --> 00:04:19,140
You Option-click in the ruler and add your own flag.

66
00:04:19,140 --> 00:04:26,280
We also had Instrument, last year the Zombie's instrument
which detects when over-released objects are messaged.

67
00:04:26,280 --> 00:04:30,710
We had that add its own timeline flag itself automatically.

68
00:04:30,710 --> 00:04:40,990
And now in the latest iPhone OS 4.0 SDK, we show
multistate app transitions in the ruler as well.

69
00:04:40,990 --> 00:04:45,550
So when your app goes from being running in the
foreground to transitioning to the background running

70
00:04:45,550 --> 00:04:50,480
and then suspended in the background, etcetera, you can
see flags for those and that will explain to you later

71
00:04:50,480 --> 00:04:56,570
when you look at this trace document, a week from then
you know, why CPU activity dropped off, for example.

72
00:04:56,570 --> 00:05:00,840
Well it's because it became suspended in the background.

73
00:05:00,840 --> 00:05:07,010
So now let's go and take a look at a demo of Instruments
and we'll just sort of learn our way around Instruments

74
00:05:07,010 --> 00:05:10,570
and solve a couple of problems using
a couple of very common instruments.

75
00:05:10,570 --> 00:05:12,900
So I'm going to go over to my computer here.

76
00:05:12,900 --> 00:05:15,160
Let me go to the demo machine.

77
00:05:15,160 --> 00:05:16,780
All right.

78
00:05:16,780 --> 00:05:24,230
So a colleague of mine has been writing a reader
app and I liked it so much I was using it,

79
00:05:24,230 --> 00:05:31,350
but I wanted it to remember the state that it had,
the book I was reading and the place within the book

80
00:05:31,350 --> 00:05:34,910
and restore that the next time I launched the app.

81
00:05:34,910 --> 00:05:38,300
So I went ahead and did that and let's
just see how that looks in the simulator.

82
00:05:38,300 --> 00:05:41,460
So here it is, it restored the state.

83
00:05:41,460 --> 00:05:49,030
If I go somewhere else, pick a different
book here, scroll up to the title.

84
00:05:49,030 --> 00:05:53,670
We'll quit that and I'll click it
again and it restores its state back.

85
00:05:53,670 --> 00:05:55,220
So this is great.

86
00:05:55,220 --> 00:05:56,040
This is awesome.

87
00:05:56,040 --> 00:06:01,680
I'm so excited, I'm just ready to
push this to the App Store right away.

88
00:06:01,680 --> 00:06:04,720
But I've only tested this on the simulator.

89
00:06:04,720 --> 00:06:09,250
What I really should do is test this on the device as
well, because the performance on the device is going

90
00:06:09,250 --> 00:06:12,970
to be different than the performance on a desktop computer.

91
00:06:12,970 --> 00:06:19,790
So let me quit the app and let's switch
to the iPhone in WolfVision here.

92
00:06:19,790 --> 00:06:29,580
I'll switch the device, build and run and it's compiling,
linking, installing the app and still there it is.

93
00:06:29,580 --> 00:06:31,800
And boy that's taking a long time.

94
00:06:31,800 --> 00:06:33,840
OK, there's my app.

95
00:06:33,840 --> 00:06:39,630
Well clearly the performance characteristics on start up was
very different on the device than it was in the simulator.

96
00:06:39,630 --> 00:06:43,840
So, back to the demo machine please.

97
00:06:43,840 --> 00:06:51,750
What I want to do is to use the Time Profiler, new in
iPhone 4.0 SDK and to see why that's taking so long.

98
00:06:51,750 --> 00:06:56,550
So let me go to Instruments and
by the way, don't get confused.

99
00:06:56,550 --> 00:06:57,800
There are two sets of tools here.

100
00:06:57,800 --> 00:07:03,040
One is the latest SDK tool set that shipped
and one is the Xcode for our preview.

101
00:07:03,040 --> 00:07:05,090
We'll be using both in this session.

102
00:07:05,090 --> 00:07:15,400
So let me open the shipping version of Instruments
here and I am going to time profile the reader app.

103
00:07:15,400 --> 00:07:20,240
So I will go up to my iPhone section
and double-click on Time Profiler

104
00:07:20,240 --> 00:07:24,940
and I will pick my little reader app and let's start it up.

105
00:07:24,940 --> 00:07:28,810
And when this, when the page displays
on the phone, I'm going to stop this.

106
00:07:28,810 --> 00:07:30,230
So there we go.

107
00:07:30,230 --> 00:07:35,210
So let's see what's taking so long in this code.

108
00:07:35,210 --> 00:07:39,150
So the first thing I want to do
is I want to focus in on my code.

109
00:07:39,150 --> 00:07:44,220
So what I like to do first is hide system
libraries and maybe hide any missing symbols I have.

110
00:07:44,220 --> 00:07:49,390
And then I will focus in on this
text view controller viewDidLoad,

111
00:07:49,390 --> 00:07:52,000
that seems to be taking up an enormous amount of time.

112
00:07:52,000 --> 00:07:55,390
And I can see, I come to main and the view is loading.

113
00:07:55,390 --> 00:08:03,000
Oh, this is where I'm actually restoring that state and
we come into viewDidLoad, let me double-click on that

114
00:08:03,000 --> 00:08:09,760
and move this over some, ah, so I'm taking the contents
of the book and I'm setting it on the text view.

115
00:08:09,760 --> 00:08:14,430
Hmmm, well there's nothing really I can do about that.

116
00:08:14,430 --> 00:08:17,910
I mean, I could, I could spend the time
during today, tomorrow and the next day,

117
00:08:17,910 --> 00:08:21,010
re-architecting my app, but we don't' have time for that.

118
00:08:21,010 --> 00:08:27,040
So what I'd really like to do and what's common when you
have an app that requires a lot of start up preparation,

119
00:08:27,040 --> 00:08:30,690
is it's a great thing to make it a background app.

120
00:08:30,690 --> 00:08:32,320
So let's go ahead and do that.

121
00:08:32,320 --> 00:08:34,530
I'm going to quit Instruments here.

122
00:08:34,530 --> 00:08:39,420
The first thing I need to do is go to my Info.plist
and I'm going to say that actually I do want this

123
00:08:39,420 --> 00:08:42,150
to run in the background and I'll save that.

124
00:08:42,150 --> 00:08:48,010
And then, in case I've switched to the background and
for whatever reason the system had to terminate my app,

125
00:08:48,010 --> 00:08:51,350
I want to make sure that I capture the
state that I currently have in there.

126
00:08:51,350 --> 00:08:54,280
What book I'm reading again and where I am in that book.

127
00:08:54,280 --> 00:09:00,600
So let me go to my delegate and just like I did earlier,
where I had already added save application state

128
00:09:00,600 --> 00:09:05,340
and application will terminate, I want to do
that when I'm doing it from the background.

129
00:09:05,340 --> 00:09:17,320
So let me say self save application state and save and
I'll build and run again and we can see how this works out.

130
00:09:17,320 --> 00:09:24,860
So let's go back to the device in WolfVision there and it's
running and of course we haven't solved the initial start

131
00:09:24,860 --> 00:09:28,510
up cost, but let's see how backgrounding works for us.

132
00:09:28,510 --> 00:09:31,020
OK, the app has started.

133
00:09:31,020 --> 00:09:36,950
So what I'm going to do now is click the Home button,
it's gone to the background and make it come back.

134
00:09:36,950 --> 00:09:37,370
Excellent.

135
00:09:37,370 --> 00:09:39,180
So it comes back very quickly.

136
00:09:39,180 --> 00:09:41,640
That's a much better user experience.

137
00:09:41,640 --> 00:09:44,560
So we can go back to the demo machine again.

138
00:09:44,560 --> 00:09:46,390
So now I'm ready to ship my app right?

139
00:09:46,390 --> 00:09:51,820
I mean, all I did was take an API used in one place and
just used it somewhere else that I never really intended it

140
00:09:51,820 --> 00:09:57,790
to be used for and this is going to run all the time
now in the background, but what could go wrong right.

141
00:09:57,790 --> 00:10:03,980
Well, if it's running in the background, I have a
responsibility to make sure I control my memory overhead.

142
00:10:03,980 --> 00:10:07,220
I don't want to be leaking any memory for example.

143
00:10:07,220 --> 00:10:11,620
So I doubt there's any leaks, but let's check anyway.

144
00:10:11,620 --> 00:10:16,230
So we'll just stay on the demo machine and
another way that you can run Instruments

145
00:10:16,230 --> 00:10:18,580
against your app, is actually from Xcode itself.

146
00:10:18,580 --> 00:10:21,560
So I go up to run with performance tool, down to leaks.

147
00:10:21,560 --> 00:10:29,200
And this will start up the app, start up Instruments on
the device, etcetera and we'll see if we have any leaks.

148
00:10:29,200 --> 00:10:32,290
So the first thing I'm going to do
is disable automatic leaks checking.

149
00:10:32,290 --> 00:10:37,130
Leaks is automatically set up to do this every
ten seconds or so, but I want to make this go back

150
00:10:37,130 --> 00:10:39,450
and forth on the phone a little bit before we do that.

151
00:10:39,450 --> 00:10:44,670
So I'm going to just keep you eye on the Mac here, but I'm
going to make that device, the app go to the background

152
00:10:44,670 --> 00:10:49,380
and bring it to foreground, maybe do that a couple of times.

153
00:10:49,380 --> 00:10:53,260
OK. And now let's check for leaks.

154
00:10:53,260 --> 00:11:00,430
It's analyzing the process here and that just takes a
little bit of time as it goes over, oh I do have a leak.

155
00:11:00,430 --> 00:11:02,020
Who would have thought?

156
00:11:02,020 --> 00:11:05,390
OK, well what I want to do now is stop the trace.

157
00:11:05,390 --> 00:11:08,040
I want to investigate these leaks.

158
00:11:08,040 --> 00:11:11,000
So what I can do is focus in on one of them.

159
00:11:11,000 --> 00:11:16,890
When you see one of these circles with an arrow in them, in
the table views and in ally views, those are Focus buttons.

160
00:11:16,890 --> 00:11:22,750
So if I click on one of those, I'm going to see that
the address I focused on is now added to the Jump bar.

161
00:11:22,750 --> 00:11:27,330
And so for example, if I wanted to go back to the
view I was at, I just go up to the Jump bar once,

162
00:11:27,330 --> 00:11:30,710
to this leaks blocks element, I click it and I'm back.

163
00:11:30,710 --> 00:11:31,930
Let's go and investigate that leak.

164
00:11:31,930 --> 00:11:37,070
So let's focus in again and let
me open the extended detail view.

165
00:11:37,070 --> 00:11:44,200
And now let me actually use a stack
compression to focus in on just my own code.

166
00:11:44,200 --> 00:11:47,280
Great. So now I can see really just my own code.

167
00:11:47,280 --> 00:11:51,650
If we zoom in here we can see,
oh the leak is actually coming

168
00:11:51,650 --> 00:11:54,310
from the saveapplicationstate [assumed spelling] call.

169
00:11:54,310 --> 00:11:57,030
Hum, well I better take a look at that.

170
00:11:57,030 --> 00:12:01,260
Let me double-click on it and I
put my extended detail view away.

171
00:12:01,260 --> 00:12:02,810
Let's focus in again.

172
00:12:02,810 --> 00:12:04,700
So what's going on here?

173
00:12:04,700 --> 00:12:09,010
Well, we're seeing where we have
different things that are being leaked

174
00:12:09,010 --> 00:12:12,500
and I have this top level object called
my restored data, what's going on there?

175
00:12:12,500 --> 00:12:15,860
Let me see, did I not release that.

176
00:12:15,860 --> 00:12:20,960
So there's another use of it, said object
from my restore data, set object again,

177
00:12:20,960 --> 00:12:23,150
set object, using it to register defaults.

178
00:12:23,150 --> 00:12:24,650
Oh, there's no release.

179
00:12:24,650 --> 00:12:27,290
OK, so now I need to go and I need to fix that.

180
00:12:27,290 --> 00:12:35,430
So let me hit the Xcode button here in Instruments
and go back to that code and I'm just going to go

181
00:12:35,430 --> 00:12:45,800
and add a quick my restore data release and I
will do a little trick here just to get it back

182
00:12:45,800 --> 00:12:50,070
on the device, build and install and run it here.

183
00:12:50,070 --> 00:12:51,790
And then we'll stop that.

184
00:12:51,790 --> 00:12:59,040
Now another way to obviously, we'll just wait
for it to completely terminate on the device.

185
00:12:59,040 --> 00:13:06,050
OK, so we'll go back to the run with
performance tools menu and we'll say leaks again.

186
00:13:06,050 --> 00:13:12,430
This will re-use the existing Instruments
document it was using for leaks and now I will go

187
00:13:12,430 --> 00:13:15,880
and do the background, foreground exercise again.

188
00:13:15,880 --> 00:13:19,870
Do it a couple times, few times there.

189
00:13:19,870 --> 00:13:23,220
And we will check for leaks again.

190
00:13:23,220 --> 00:13:26,100
Analyzing the process.

191
00:13:26,100 --> 00:13:27,820
Excellent, no leaks.

192
00:13:27,820 --> 00:13:32,550
So now I think that the app is in
better shape to go to the app store.

193
00:13:32,550 --> 00:13:36,840
I should still add a splash screen and continue
on with the refinements, but it's better.

194
00:13:36,840 --> 00:13:41,540
Now I do want to draw your attention
quickly to what is in the ruler bar.

195
00:13:41,540 --> 00:13:42,280
These icons here.

196
00:13:42,280 --> 00:13:45,390
These are those state transition flags I told you about.

197
00:13:45,390 --> 00:13:52,050
So if I click on one of these, I can see that it will
tell me that the reader switched to the background running

198
00:13:52,050 --> 00:13:58,700
and if I navigate over I can see when it came back to
the foreground and we see all of these state transitions.

199
00:13:58,700 --> 00:14:03,880
So that again, is very useful, especially when you go
back later and try to understand why you saw a change

200
00:14:03,880 --> 00:14:05,820
in performance data that you're gathering.

201
00:14:05,820 --> 00:14:10,460
You can say oh, it was in the background
and suspended and so that's why.

202
00:14:10,460 --> 00:14:15,460
OK? So that is a brief exercise.

203
00:14:15,460 --> 00:14:20,320
If we can switch back to the slides, in using
Instruments and how you get around in it.

204
00:14:20,320 --> 00:14:25,710
The major controls, the Jump bar, back trace
compression, using Instruments to target an app directly

205
00:14:25,710 --> 00:14:30,500
from Instruments itself, as well as from
the Xcode run with performance tools menu.

206
00:14:30,500 --> 00:14:35,510
And of course, two of the most important I think,
Instruments we have, the Time Profiler to see

207
00:14:35,510 --> 00:14:39,920
where you're spending your time and the leaks
instrument to see if you're leaking any data.

208
00:14:39,920 --> 00:14:42,440
So you should get to know both of those instruments.

209
00:14:42,440 --> 00:14:47,980
So moving on, I think that in this
latest release of Instruments,

210
00:14:47,980 --> 00:14:51,260
we have the greatest, the most efficient Instruments ever.

211
00:14:51,260 --> 00:14:56,580
And we provide you the greatest latitude
ever on how you do you recording.

212
00:14:56,580 --> 00:15:01,170
So first let's talk about what we
call immediate versus deferred.

213
00:15:01,170 --> 00:15:04,190
So immediate mode is this classic Instrument's mode.

214
00:15:04,190 --> 00:15:09,140
You hit the Recording button and instruments
processes and displays the data immediately.

215
00:15:09,140 --> 00:15:14,010
And what's great about this is that you can tinker with
your device, or you're in a game, you shoot off a missile,

216
00:15:14,010 --> 00:15:19,370
there's an explosion and you can see the CPU usage spike
immediately, you can see the frame rates change immediately.

217
00:15:19,370 --> 00:15:24,270
So you it gives you that immediate feedback and you
know in that data set, exactly what you want to look at.

218
00:15:24,270 --> 00:15:30,180
But the down side is that hey, Instruments is running on
the same computer and it's using some of the CPU, too.

219
00:15:30,180 --> 00:15:36,900
So sometimes, especially for sampling instruments, like
Time Profiling, you may and this is an exaggerated graph,

220
00:15:36,900 --> 00:15:39,460
but you may get gaps or valleys in your data collection.

221
00:15:39,460 --> 00:15:42,620
You data collection isn't as packed
tightly as you'd like it to be.

222
00:15:42,620 --> 00:15:45,950
So that's why we added a mode we call deferred mode.

223
00:15:45,950 --> 00:15:50,330
Deferred mode processes and displays
data after the recording is over.

224
00:15:50,330 --> 00:15:56,200
So the benefit is, Instruments stays off the
CPU, it's not doing anything until you hit Stop

225
00:15:56,200 --> 00:15:58,450
and then it consumes and displays all that data.

226
00:15:58,450 --> 00:16:04,810
The down side is of course that it's hard for you to
correlate that when you, you know, when you shot missile one

227
00:16:04,810 --> 00:16:09,670
versus drop bomb, which of those
corresponded to the big frame rate drop.

228
00:16:09,670 --> 00:16:11,900
So you have to judge what you're going to use.

229
00:16:11,900 --> 00:16:18,600
But with deferred mode you'll get more tightly packed
samples and data set and that can be very useful

230
00:16:18,600 --> 00:16:24,070
when you're looking at something
that's very, very time sensitive.

231
00:16:24,070 --> 00:16:30,080
So when you launch your apps, we've had various
options but we didn't have them in a very good place

232
00:16:30,080 --> 00:16:32,530
in the UI, so we've moved them to the targets user.

233
00:16:32,530 --> 00:16:36,080
One of the options is to choose where
you want your standard I/O to go.

234
00:16:36,080 --> 00:16:41,240
So you can have it go to the Instruments console
or the system console or you can just discard it.

235
00:16:41,240 --> 00:16:46,040
Maybe you have a very, very chatty app and
you don't want the system overloaded with all

236
00:16:46,040 --> 00:16:48,230
that I/O, so you can just discard it completely.

237
00:16:48,230 --> 00:16:56,750
And on the Mac, if you have a 32, 64 bit capable app,
you may want to run it in 64 bit mode and 32 bit mode,

238
00:16:56,750 --> 00:17:01,720
especially if it's using a lot of memory, a
large address space, to see how it performs.

239
00:17:01,720 --> 00:17:02,970
So you have those controls.

240
00:17:02,970 --> 00:17:05,070
In the simulator, you sort have similar control.

241
00:17:05,070 --> 00:17:10,540
So you can change where your console I/O goes, but you
can also say what kind of device you want the simulator

242
00:17:10,540 --> 00:17:13,770
to simulate and what kind of SDK you want it to use.

243
00:17:13,770 --> 00:17:16,940
So that's very helpful to know as well.

244
00:17:16,940 --> 00:17:20,080
Now if you're on Mac OS X and you're
developing launch agents, agents or daemons,

245
00:17:20,080 --> 00:17:27,110
which are little headless services that you can have on
the Mac, it's always been a problem to be able to analyze

246
00:17:27,110 --> 00:17:33,140
that primordial start up segment of time when
the daemon is first hooking up to everything.

247
00:17:33,140 --> 00:17:35,860
A lot of times that can be the
most interesting thing to look at.

248
00:17:35,860 --> 00:17:37,230
Does it leak any memory right there?

249
00:17:37,230 --> 00:17:39,660
You know, what's going on with CPU usage right there?

250
00:17:39,660 --> 00:17:46,090
So what we did was connate tightly with launchd,
so that Instruments can start analyzing the app

251
00:17:46,090 --> 00:17:48,390
as soon as it's created by launchd itself.

252
00:17:48,390 --> 00:17:54,380
This is exactly the same amount of data you'd collect if
you'd actually launched an app directly from Instruments.

253
00:17:54,380 --> 00:17:55,230
So how do you do this?

254
00:17:55,230 --> 00:17:58,930
Well you go to the targets user and
you pick the daemon or agent.plist.

255
00:17:58,930 --> 00:18:01,100
The plist, not the actual binary.

256
00:18:01,100 --> 00:18:05,910
Because Instruments needs to read
that plist and find out some things.

257
00:18:05,910 --> 00:18:09,240
Then you hit Record and you'll get
a dialog like this on the screen.

258
00:18:09,240 --> 00:18:14,560
Basically Instruments is saying, OK go do whatever it is
you have to do to tickle launchd to launch your daemon.

259
00:18:14,560 --> 00:18:19,310
Maybe it is connecting up a network or creating
a file somewhere or something of that sort.

260
00:18:19,310 --> 00:18:23,540
As soon as that happens, this dialog will go away
and Instruments will start recording right away.

261
00:18:23,540 --> 00:18:26,860
So you've gathered all that critical data.

262
00:18:26,860 --> 00:18:31,290
And let's also talk about wireless, for the phone.

263
00:18:31,290 --> 00:18:36,940
So it's possible for you to actually use
Instruments, to profile your apps running

264
00:18:36,940 --> 00:18:39,780
on the phone, without being connected to USB.

265
00:18:39,780 --> 00:18:41,890
So why would you want to do this?

266
00:18:41,890 --> 00:18:45,740
Well it frees up the USB port if
you're an accessory developer.

267
00:18:45,740 --> 00:18:51,590
Let's say you're developing something for an automobile
manufacturer, some docking station or something of that sort

268
00:18:51,590 --> 00:18:56,180
and you want to see the performance of the
app when you connect that accessory up.

269
00:18:56,180 --> 00:19:02,710
Or let's say that you're a game developer and
you're using that accelerometer and it's a real pain

270
00:19:02,710 --> 00:19:09,490
when you're testing your game aggressively and that cable
is slapping you in the head as you're moving it around and

271
00:19:09,490 --> 00:19:12,360
or it's in your way as you grab the
device and making it very awkward.

272
00:19:12,360 --> 00:19:13,590
You just go wireless.

273
00:19:13,590 --> 00:19:14,580
Disconnect it from USB.

274
00:19:14,580 --> 00:19:17,330
It's much easier to do.

275
00:19:17,330 --> 00:19:22,100
Now there's one thing that you need to remember when you
go home or go back to your workplace and you try this,

276
00:19:22,100 --> 00:19:24,670
if it doesn't work the first thing
you need to do is make sure

277
00:19:24,670 --> 00:19:28,350
that you have Bonjour multitask
enabled, on your Wi-Fi point.

278
00:19:28,350 --> 00:19:29,670
If you don't, it's not going to work.

279
00:19:29,670 --> 00:19:33,540
Now to find out how to do that, just refer
to the standard Bonjour documentation.

280
00:19:33,540 --> 00:19:37,460
There's isn't anything iPhone- or
Instrument-specific about that.

281
00:19:37,460 --> 00:19:39,760
So how do you enable this?

282
00:19:39,760 --> 00:19:45,080
Well, you hold down the Option key while you go to
the targets user and you'll see your device appear,

283
00:19:45,080 --> 00:19:48,020
but it'll have Enable Your Device Name Wireless.

284
00:19:48,020 --> 00:19:51,830
So you select that and then you'll see your
device appear but it will be kind of grayed out.

285
00:19:51,830 --> 00:19:58,710
Because it's handshaking with your machine and getting
everything set up and a second or two later it's ready

286
00:19:58,710 --> 00:20:04,260
and then at this point you have not one, but
two Instruments daemon's running on your device.

287
00:20:04,260 --> 00:20:07,500
You have one dedicated to USB and
you have one dedicated to wireless.

288
00:20:07,500 --> 00:20:10,290
See you don't want that because
they're both using resources.

289
00:20:10,290 --> 00:20:16,520
So you want to unplug your USB and when you do that
the USB-dedicated Instrument's daemon will go away,

290
00:20:16,520 --> 00:20:22,330
you'll see that item disable and now you can just go
completely wireless and you can do everything you can do

291
00:20:22,330 --> 00:20:26,040
with Instruments normally over USB, wirelessly.

292
00:20:26,040 --> 00:20:31,930
Of course your performance will vary based on
the performance of your Wi-Fi hotspot, etcetera.

293
00:20:31,930 --> 00:20:34,200
But it's a very handy thing to do.

294
00:20:34,200 --> 00:20:40,070
Now when you want to disable this,
because again, it is taking up you know,

295
00:20:40,070 --> 00:20:44,370
radio resources and it's not quite as fast as USB.

296
00:20:44,370 --> 00:20:47,280
Just hold down the Option key, go back to the target chooser

297
00:20:47,280 --> 00:20:50,930
and the menu item will change into
Disable Your Device Named Wireless.

298
00:20:50,930 --> 00:20:52,100
Select that and it will go away.

299
00:20:52,100 --> 00:20:57,120
At this point, the only way to get it back is
to connect up USB, so that you can re-enable it.

300
00:20:57,120 --> 00:21:02,550
Another way to disable it is actually
to just reboot your device.

301
00:21:02,550 --> 00:21:04,350
And so now we'll just do a wireless demo.

302
00:21:04,350 --> 00:21:06,990
I really don't think so.

303
00:21:06,990 --> 00:21:08,510
No wireless demo, not today.

304
00:21:08,510 --> 00:21:12,370
Actually I did have a slide for
that, but not today any longer.

305
00:21:12,370 --> 00:21:16,310
So let's move on to symbolication.

306
00:21:16,310 --> 00:21:18,740
Well Steve, wireless, Steve.

307
00:21:18,740 --> 00:21:25,660
So often when you take a trace,
it has to do with your own code.

308
00:21:25,660 --> 00:21:32,270
There are instruments actually in the app that don't have
anything to do with actual code, but most of them do.

309
00:21:32,270 --> 00:21:36,990
And what's very critical on that is to have
Instruments be able to switch those hex addresses

310
00:21:36,990 --> 00:21:39,600
into real symbol names, like a function name.

311
00:21:39,600 --> 00:21:44,700
In order to do that, Instruments will look
in SDK paths to find a symbol-rich data

312
00:21:44,700 --> 00:21:48,000
and it will also use Spotlight to look it up.

313
00:21:48,000 --> 00:21:54,290
In order for Spotlight to help us find your symbol-rich
binaries, you need to make sure you build your app,

314
00:21:54,290 --> 00:21:57,040
whether it's for the phone or for
the Mac, DWARF with dSym file.

315
00:21:57,040 --> 00:22:03,230
So just go to your debug settings and probably, it
might say DWARF, switch it to DWARF with dSym file.

316
00:22:03,230 --> 00:22:08,400
Now, if you do that, you need to still
make sure that it's visible to Spotlight.

317
00:22:08,400 --> 00:22:10,430
Spotlight won't look in any encrypted disk image

318
00:22:10,430 --> 00:22:13,810
and you might have Spotlight already
set to not look at certain volumes.

319
00:22:13,810 --> 00:22:17,460
So you need to make sure Spotlight
is looking in that location.

320
00:22:17,460 --> 00:22:24,320
Now if you don't have any symbols, maybe someone else took
a trace, they didn't have all the symbol-rich binaries

321
00:22:24,320 --> 00:22:31,490
and they handed it to you or you did find
yourself in a situation where, pardon me,

322
00:22:31,490 --> 00:22:34,300
where Spotlight could not find the binaries.

323
00:22:34,300 --> 00:22:36,340
You can always resymbolicate them after the fact.

324
00:22:36,340 --> 00:22:37,220
It's very simple to do.

325
00:22:37,220 --> 00:22:40,150
Go to the file menu, select resymbolicate document.

326
00:22:40,150 --> 00:22:41,560
You'll see a sheet pop down.

327
00:22:41,560 --> 00:22:47,840
You select the paths that point to the right symbol-rich
binaries or directories and we'll recursively look

328
00:22:47,840 --> 00:22:51,480
in all those and then you just click symbolicated.

329
00:22:51,480 --> 00:22:52,130
It's that easy.

330
00:22:52,130 --> 00:22:54,760
Oh and turn all the hex addresses into symbols.

331
00:22:54,760 --> 00:23:01,720
And then I'd like to make one note about
tracing, using Instruments against apps

332
00:23:01,720 --> 00:23:06,780
in the iPhone 4.0 SDK, just because it's hit us.

333
00:23:06,780 --> 00:23:10,780
We've all got accustomed to this, so
I hit the Home button, my app quits.

334
00:23:10,780 --> 00:23:13,070
Instruments stops if I was tracing with it.

335
00:23:13,070 --> 00:23:17,700
But now it may no longer terminate the app
right, the app may just go to the background

336
00:23:17,700 --> 00:23:20,540
and Instruments will dutifully keep tracing.

337
00:23:20,540 --> 00:23:25,700
So what you need to do is just get in the habit
of stopping the app from Instruments itself.

338
00:23:25,700 --> 00:23:27,750
Pressing that Stop button.

339
00:23:27,750 --> 00:23:33,210
If, another issue that you can run into is that you're
actually debugging your app and you hit the Home button

340
00:23:33,210 --> 00:23:37,260
and you forget you did that and you try to trace
with Instruments and Instruments is going to put

341
00:23:37,260 --> 00:23:40,430
up an error saying the debugger has control of this process.

342
00:23:40,430 --> 00:23:44,020
So what you need to do is also remember
that when you're using the debugger,

343
00:23:44,020 --> 00:23:49,380
to hit the Stop button as well before
you use Instruments against the same app.

344
00:23:50,810 --> 00:23:54,800
So we've made various improvements to our
existing instrumentation we've had for a while

345
00:23:54,800 --> 00:23:57,170
and I want to go over those improvements.

346
00:23:57,170 --> 00:23:59,510
So first is Time Profiler.

347
00:23:59,510 --> 00:24:06,690
This is for both platforms and it's the most
efficient time profiling mechanism by far that we have.

348
00:24:06,690 --> 00:24:09,340
It does everything from the kernel.

349
00:24:09,340 --> 00:24:12,690
Takes its samples in the kernel
and you can use it in two ways.

350
00:24:12,690 --> 00:24:15,470
By default, you're looking at running threads.

351
00:24:15,470 --> 00:24:17,430
So you're just looking for code that is running

352
00:24:17,430 --> 00:24:20,810
but it's not running very efficiently,
so you want to find those hotspots.

353
00:24:20,810 --> 00:24:24,810
But you can also use it to track
down and all thread states mode.

354
00:24:24,810 --> 00:24:28,290
You go to its inspector and click All Thread States.

355
00:24:28,290 --> 00:24:30,500
So it can find threads that are blocked.

356
00:24:30,500 --> 00:24:37,290
So maybe you have a choppy app or it's
deadlocking somewhere, you switch Time Profiler

357
00:24:37,290 --> 00:24:40,470
to All Thread States and you'll find those threads as well.

358
00:24:40,470 --> 00:24:45,300
And of course, it can also see all processes
on the system, not just a single process.

359
00:24:45,300 --> 00:24:49,960
So that's really nice when you want to see you
know, what in the world is going on in the system?

360
00:24:49,960 --> 00:24:51,120
Why is it so slow?

361
00:24:51,120 --> 00:24:56,530
You use all processes and you can
see who the guilty party is.

362
00:24:56,530 --> 00:25:03,900
So we've also added kernel frames to the
back tracing and call tree Time Profiler.

363
00:25:03,900 --> 00:25:05,440
And we did this in a really cool way.

364
00:25:05,440 --> 00:25:11,280
Because you can see, but logical way,
you can see the user space stack frames,

365
00:25:11,280 --> 00:25:14,830
but in a continuous line then you see the kernel space.

366
00:25:14,830 --> 00:25:20,310
So you see yourself transitioning all the way from user
space, into the kernel and maybe into some kernel extension.

367
00:25:20,310 --> 00:25:23,580
It's really kind of far out to see
it when we finally put that together.

368
00:25:23,580 --> 00:25:24,220
It's really awesome.

369
00:25:24,220 --> 00:25:29,340
If you're a kernel extension developer,
it'll be really important to you.

370
00:25:29,340 --> 00:25:36,760
And of course, Time Profiler, as we saw a moment
ago, is also available on the iPhone 4.0 SDK.

371
00:25:36,760 --> 00:25:43,950
And it's far more efficient than CPU sampler that you
were using before and it doesn't really seem intuitive,

372
00:25:43,950 --> 00:25:47,570
but deferred mode really matters
for tracing the device as well.

373
00:25:47,570 --> 00:25:53,100
Now of course, when you're in immediate mode
on the Mac, you have Instruments running

374
00:25:53,100 --> 00:25:56,910
and you have your target process running,
obviously they're fighting over the same CPU,

375
00:25:56,910 --> 00:26:01,000
but the reason that it matters even on the device,
when Instruments is still running on your Mac,

376
00:26:01,000 --> 00:26:06,610
is that if you're in immediate mode that Instruments
daemon on the device has to take that data

377
00:26:06,610 --> 00:26:09,530
out of the buffers we're collecting it in, package it up,

378
00:26:09,530 --> 00:26:12,850
send it over the wire, over wireless
and all that takes cycles.

379
00:26:12,850 --> 00:26:18,750
So it makes a big difference by putting your trace in
deferred mode before you take it for the phone as well

380
00:26:18,750 --> 00:26:24,160
and significantly proportionately more than it
actually makes on the Mac and that will hold

381
00:26:24,160 --> 00:26:30,100
on to those data buffers unless we fill them up, in which
case we want to get rid of them, get them onto the Mac,

382
00:26:30,100 --> 00:26:36,770
so we don't constrain the memory that your own
app needs or you hit Stop on the recording.

383
00:26:36,770 --> 00:26:41,380
So deferred mode really does matter,
even for device time profiling.

384
00:26:41,380 --> 00:26:45,510
So we've also added a new instrument
called HeapShots and HeapShots,

385
00:26:45,510 --> 00:26:48,800
well actually it's a feature of
Allocations Instruments, pardon me.

386
00:26:48,800 --> 00:26:53,210
HeapShots will actually allow you to
track down what we call abandoned memory.

387
00:26:53,210 --> 00:26:56,270
We call it abandoned because it's
not leaked, but you allocated it,

388
00:26:56,270 --> 00:26:59,680
maybe you used it once long ago
and you basically abandoned it.

389
00:26:59,680 --> 00:27:00,650
You forgot all about it.

390
00:27:00,650 --> 00:27:04,310
There it sits, still referenced, you
run leaks, you're not going to see it

391
00:27:04,310 --> 00:27:07,330
but it's taking up space until you quit your app.

392
00:27:07,330 --> 00:27:12,640
We find that this can be an even more serious
problem than leaked memory and if you have an app

393
00:27:12,640 --> 00:27:17,780
that maybe you didn't first develop or that's
several years old, this will start to build up.

394
00:27:17,780 --> 00:27:22,970
Because someone, somewhere, wrote some caching
routine for a feature that has since been removed,

395
00:27:22,970 --> 00:27:24,700
but no one knew about the caching routine.

396
00:27:24,700 --> 00:27:28,150
It's been dutifully caching away its
memory and not being used at all.

397
00:27:28,150 --> 00:27:29,380
So that's a waste.

398
00:27:29,380 --> 00:27:35,930
So you want to, you want to analyze your app using
the HeapShot technique, to find that abandoned memory.

399
00:27:35,930 --> 00:27:37,920
We also have VM tracker.

400
00:27:37,920 --> 00:27:42,450
This allows you to look at your VM usage
of your app on the Mac, in the phone.

401
00:27:42,450 --> 00:27:46,130
And again it's part of allocations
template, as a separate instrument.

402
00:27:46,130 --> 00:27:53,870
You can identify, it identifies reasons by tag and
you can look at things like resident and virtual size.

403
00:27:53,870 --> 00:27:59,250
And this is great to use against a Core Animation app
or something where you're loading images off a disk

404
00:27:59,250 --> 00:28:03,010
and you can associate how much memory
that's taking with the actual file on disk.

405
00:28:03,010 --> 00:28:05,140
So that's very cool.

406
00:28:05,140 --> 00:28:12,620
So now I'd like to demo, just a few advanced recording
techniques, take a look at immediate versus deferred mode

407
00:28:12,620 --> 00:28:15,850
as well and see why that matters for you now.

408
00:28:15,850 --> 00:28:18,010
So if we can switch to the demo machine please.

409
00:28:18,010 --> 00:28:23,110
This will be just a Mac demo.

410
00:28:23,110 --> 00:28:33,120
OK. So let's start up Instruments and we
will launch the Time Profiler instrument.

411
00:28:33,120 --> 00:28:35,260
I'll choose the Mac version there.

412
00:28:35,260 --> 00:28:49,330
And let's look at a little app that, that was
written a long time ago called the GL Mech app

413
00:28:49,330 --> 00:28:52,930
and we're going to first run this in immediate mode.

414
00:28:52,930 --> 00:29:03,370
We'll get this guy going here and let me bring up Terminal
and let's see how much CPU instruments is using right now.

415
00:29:03,370 --> 00:29:09,460
So Instruments is using, here it is, it's going to
bounce around between 4 and 7%, depending on what's going

416
00:29:09,460 --> 00:29:15,010
on as the GLUT Mech app runs.

417
00:29:15,010 --> 00:29:24,580
So 4 to 7%, so let's quit the GLUT Mech guy and let's
go up to the file menu and let's go to deferred mode.

418
00:29:24,580 --> 00:29:28,350
And let's run our little guy again.

419
00:29:28,350 --> 00:29:32,650
Now this darker appearance in Instruments is deferred mode.

420
00:29:32,650 --> 00:29:36,740
So when you see that, that's why.

421
00:29:36,740 --> 00:29:41,660
And let's go and look at top again
and let's look for Instruments.

422
00:29:41,660 --> 00:29:48,970
Now basically, other than a burp here or there, Instruments
will stay at 0% for long, extended periods of time.

423
00:29:48,970 --> 00:29:57,730
So this makes a significant difference as you're
analyzing some very CPU intensive application.

424
00:29:57,730 --> 00:30:00,680
So that is immediate versus deferred mode.

425
00:30:00,680 --> 00:30:07,880
That's an important question that people have had
about CPU usage and so we thought we'd answer it now.

426
00:30:07,880 --> 00:30:17,240
Another thing that people have wanted to do, they'll ask me,
how can I precisely time filter my data between two points.

427
00:30:17,240 --> 00:30:23,170
Say when call A was made and call B was made
or event A happened and event B happened?

428
00:30:23,170 --> 00:30:25,260
Well there's a couple of ways to do that.

429
00:30:25,260 --> 00:30:31,370
A sort of really poor man's way of doing
it is actually tagging it with a console.

430
00:30:31,370 --> 00:30:39,880
So let me run the GLUT Mech guy again and
we'll say, go and stop, go, stop, go, stop.

431
00:30:39,880 --> 00:30:44,460
So let's see how we could time
profile between a go and a stop.

432
00:30:44,460 --> 00:30:56,590
If I go down to my console here by using the Jump bar,
I'll select Console, we can see some console API output

433
00:30:56,590 --> 00:31:01,230
that I had added to that app, to just say
starting animation when you hit the Go button

434
00:31:01,230 --> 00:31:02,930
and stopping animation when you hit the Stop button.

435
00:31:02,930 --> 00:31:04,030
It's very simple.

436
00:31:04,030 --> 00:31:12,350
But what's interesting is that, the both
the console and its left hand margin

437
00:31:12,350 --> 00:31:16,030
and the timeline view, both have timeline inspectors.

438
00:31:16,030 --> 00:31:22,310
So if I zoom in on that and I take the inspection
head in a timeline, I can see that the inspection head

439
00:31:22,310 --> 00:31:25,600
in the console move around to where that actually happened.

440
00:31:25,600 --> 00:31:27,840
And if I move the console.

441
00:31:27,840 --> 00:31:28,660
[ applause ]

442
00:31:28,660 --> 00:31:32,220
I can drop it and it will move
to where that is in the timeline.

443
00:31:32,220 --> 00:31:37,970
So let's say on this second starting
animation, I want to begin a time filter here.

444
00:31:37,970 --> 00:31:41,580
Obviously this is something that you'd do after
the recording is stopped, otherwise you know,

445
00:31:41,580 --> 00:31:43,980
the data is going to be changing and driving you crazy.

446
00:31:43,980 --> 00:31:51,090
So I can use this inspection range tool bar item along
with that, so I precisely move to this point in time

447
00:31:51,090 --> 00:31:57,920
by selecting this location in the console and now I'm
going to click this left hand Inspection Range button.

448
00:31:57,920 --> 00:32:02,370
Now what that's going to do is say, begin a
time filter from this point on to the end.

449
00:32:02,370 --> 00:32:06,210
So I'll press that and now it's filtering
it from that point on to the end.

450
00:32:06,210 --> 00:32:16,610
And now that that initial event has been filtered out
as well in the console and so now I'll move to my,

451
00:32:16,610 --> 00:32:19,410
to my next stopping event and here it is.

452
00:32:19,410 --> 00:32:25,080
And now I can use this right hand side button in
inspection range and say OK now stop the time filter there.

453
00:32:25,080 --> 00:32:33,330
I'll do that and now I have a precise time filter
and I can go back to my sample list or my call tree

454
00:32:33,330 --> 00:32:35,770
and all this data is filtered within that time range.

455
00:32:35,770 --> 00:32:38,030
So it's pretty precise.

456
00:32:38,030 --> 00:32:47,680
But, on a system that's really loaded down, that I/O is
not really going to come out exactly when you emit it

457
00:32:47,680 --> 00:32:52,160
and so there's another better way to do this as well.

458
00:32:52,160 --> 00:32:56,710
So if I, I'll zoom out here, what I can do is I
can use dtrace and this will work for the Mac,

459
00:32:56,710 --> 00:32:59,210
both for Mac apps and for simulator apps.

460
00:32:59,210 --> 00:33:05,850
So if I go up to the Instruments menu and I say
trace symbol, it knows all the symbols it's seen,

461
00:33:05,850 --> 00:33:12,900
so I can say start animation and I'll add a probe point
for where start animation is really actually called.

462
00:33:12,900 --> 00:33:18,760
And remember, dtrace is managing all this from the kernel so
it's going to be really precise and I can do that as well.

463
00:33:18,760 --> 00:33:24,150
There's a command accelerator for that, so I can
just say command t and I can say, stop animation.

464
00:33:24,150 --> 00:33:28,750
So now I have dtrace probe points
for starting and stopping animation.

465
00:33:28,750 --> 00:33:36,460
So now let's go ahead and run the GLUT Mech
app again and let's have it do some things.

466
00:33:36,460 --> 00:33:39,620
Go, Stop, Go, Stop, Go, Stop.

467
00:33:39,620 --> 00:33:40,860
And let's quit.

468
00:33:40,860 --> 00:33:47,990
And now we see that in the other dtrace instruments, we
see these are basically representing how deep a stack was,

469
00:33:47,990 --> 00:33:53,160
but there are points and explicit events
where these events actually occurred

470
00:33:53,160 --> 00:33:55,470
where it actually started animation and stopped it.

471
00:33:55,470 --> 00:33:59,050
So now if I want to filter, I'll just click
on my start animation instrument first,

472
00:33:59,050 --> 00:34:04,200
I'm going to use the inspection range
again to select the first event here.

473
00:34:04,200 --> 00:34:09,620
Now we're right lined up and I'll start my time
filter there and then I'll go to stop animation

474
00:34:09,620 --> 00:34:13,710
and it's conveniently moved the
inspection head to the first location.

475
00:34:13,710 --> 00:34:19,730
Stop and I'll use the right side of the inspection range
there and now I have a really, really precise time filter.

476
00:34:19,730 --> 00:34:28,060
If I go back to my Time Profiler instrument and select
and have the call tree review or look at samples list.

477
00:34:28,060 --> 00:34:32,360
All this data is going to be precisely
filtered down to that time range.

478
00:34:32,360 --> 00:34:38,610
So those are very useful techniques for
how you trace data and how you look at it.

479
00:34:38,610 --> 00:34:41,850
Now this is, this is a pretty neat
little set up I have here.

480
00:34:41,850 --> 00:34:49,520
I have set the recording mode to deferred,
the default mode in Time Profiler is immediate

481
00:34:49,520 --> 00:34:53,780
and I have added these probe points for
starting and stopping the animation.

482
00:34:53,780 --> 00:34:58,380
So I'd like to reuse this and I can
by making this a trace template.

483
00:34:58,380 --> 00:35:05,210
So I can go over to the file menu and say Save as
Template, a sheet will pop down and this directory

484
00:35:05,210 --> 00:35:07,340
that it opens up to is in your user account.

485
00:35:07,340 --> 00:35:09,920
Library Applications for Instruments Templates.

486
00:35:09,920 --> 00:35:20,730
And I can say, call this you know, my cool template
and add a description, choose an icon or something.

487
00:35:20,730 --> 00:35:24,930
This is fine for me though and hit Save.

488
00:35:24,930 --> 00:35:30,470
And now both Xcode 3 and Xcode
4 are aware of that template.

489
00:35:30,470 --> 00:35:36,030
They'll look in that directory and Instruments
of course is aware of that template as well

490
00:35:36,030 --> 00:35:38,570
in its own user section of the template chooser.

491
00:35:38,570 --> 00:35:41,130
And now I can reuse that over and over again.

492
00:35:41,130 --> 00:35:46,440
So those are some techniques for doing a performance
analysis and the difference between immediate

493
00:35:46,440 --> 00:35:50,590
and deferred mode and I thought
you would just find that useful.

494
00:35:50,590 --> 00:35:52,980
So let's just go back to the slides.

495
00:35:52,980 --> 00:35:57,010
[ applause ]

496
00:35:57,010 --> 00:36:01,500
So we also have some new instrumentation in the latest SDK.

497
00:36:01,500 --> 00:36:05,560
One of the things we've added is the
Energy Diagnostics set of instrumentation.

498
00:36:05,560 --> 00:36:10,470
This is a large grained measuring
technique to look at energy consumption

499
00:36:10,470 --> 00:36:14,000
of your device, with or without your app running on it.

500
00:36:14,000 --> 00:36:17,560
It will measure battery power, the CPU usage of your app,

501
00:36:17,560 --> 00:36:21,710
as well as other important services
on the phone like media services.

502
00:36:21,710 --> 00:36:26,510
And it will track the on and off state
of vital devices that consume energy,

503
00:36:26,510 --> 00:36:33,420
the screen being a really big one
and Wi-Fi and Bluetooth, etcetera.

504
00:36:35,050 --> 00:36:39,770
We also have another really cool new
instrument called the Automation instrument.

505
00:36:39,770 --> 00:36:41,060
This is totally awesome.

506
00:36:41,060 --> 00:36:45,970
You can actually use it to automate and exercise your app.

507
00:36:45,970 --> 00:36:52,960
So you can simulate clicking on various controls
in your iPhone app and if you use it in conjunction

508
00:36:52,960 --> 00:36:57,360
with say another instrument, say
leaks and then you run, you have some,

509
00:36:57,360 --> 00:37:05,260
some set up where you run this before you make each
submission or an internal release or before your GM,

510
00:37:05,260 --> 00:37:12,040
you can check for pass/fail messages and other
results, via the JavaScript that you write

511
00:37:12,040 --> 00:37:15,040
with this instrument, use with this instrument.

512
00:37:15,040 --> 00:37:21,470
And then you can store those results away in some
separate database perhaps and you can just export them

513
00:37:21,470 --> 00:37:26,350
as comma separated values for example
and then refer to them later on

514
00:37:26,350 --> 00:37:31,700
and see how you've been progressing in your QA testing.

515
00:37:31,700 --> 00:37:36,460
There's also a really cool OpenGL ES Analyzer instrument.

516
00:37:36,460 --> 00:37:37,820
This is really amazing.

517
00:37:37,820 --> 00:37:45,590
It can actually, of course identify just bottlenecks
in your own code, but it can provide you actual advice,

518
00:37:45,590 --> 00:37:51,560
recommendations as to how you can improve the
performance of your GL app, which is just really cool.

519
00:37:51,560 --> 00:37:54,970
It just comes out in English and says hey, you're
doing this and you should be doing this other thing.

520
00:37:54,970 --> 00:37:58,460
So it's a little expert in a box for you.

521
00:37:58,460 --> 00:38:04,390
And finally, let's move on to our really new
instrumentation, the Xcode 4 developer preview.

522
00:38:04,390 --> 00:38:06,480
Namely system trace.

523
00:38:06,480 --> 00:38:14,700
So this provides you with comprehensive information
on the entire system with one or more processes,

524
00:38:14,700 --> 00:38:22,200
looking at thread scheduling, why they're
scheduled, how long they stay on a core.

525
00:38:22,200 --> 00:38:26,450
And you can look at system calls
and VM operations, etcetera.

526
00:38:26,450 --> 00:38:30,010
The system trace template is made
up of three individual instruments.

527
00:38:30,010 --> 00:38:36,610
The scheduling instrument, this tracks threads, contact
switches, the reasons why, the tenures, how long they're on.

528
00:38:36,610 --> 00:38:42,400
The system calls instrument, these are
calls into the kernel from user space.

529
00:38:42,400 --> 00:38:49,820
And the VM Operations instrument, so you can see page cache
hits and zero fills and all sorts of cool stuff there.

530
00:38:49,820 --> 00:38:55,400
And also, system trace is the first set of
instrumentation really that takes advantage of a new feature

531
00:38:55,400 --> 00:38:58,100
in Instruments, called the highlights view.

532
00:38:58,100 --> 00:39:04,300
So system trace especially, can just record a ton of
data, but we have other instruments that can do that too.

533
00:39:04,300 --> 00:39:12,020
And it's, it's a real labor sometimes to have to be able
to sift through all of that data, looking for the problems,

534
00:39:12,020 --> 00:39:16,570
especially when you have to correlate
a lot of data together.

535
00:39:16,570 --> 00:39:23,400
So with the highlights view, we take all the key
statistics, the very core statistics and we summarize them

536
00:39:23,400 --> 00:39:31,100
in little graphs that show you that the top five or so
extreme issues, such as processes or contact switches

537
00:39:31,100 --> 00:39:38,510
or something, and you can quickly key in on that by looking
at those graphs to see where you really want to dig in,

538
00:39:38,510 --> 00:39:41,100
rather than just in looking at
all the data then just you know,

539
00:39:41,100 --> 00:39:44,580
becoming bleary eyed at all, everything
that's presented to you.

540
00:39:44,580 --> 00:39:45,920
So I have one more demo.

541
00:39:45,920 --> 00:39:48,350
It's a pretty short and simple one.

542
00:39:48,350 --> 00:39:52,510
But let's go to the demo machine
and take a look at system trace.

543
00:39:52,510 --> 00:39:59,620
[ Pause ]

544
00:39:59,620 --> 00:40:05,110
So, as I said, I have the developer,
Xcode developer preview installed as well,

545
00:40:05,110 --> 00:40:10,240
so I'm going to launch that version of Instruments now.

546
00:40:10,240 --> 00:40:20,240
And I wanted to show you what system trace can tell you
about and visualize for you, as to why it seems so simple,

547
00:40:20,240 --> 00:40:25,540
but why an apps performance is degraded when
some other app is doing something intensive.

548
00:40:25,540 --> 00:40:29,970
So let's look at system trace and we're
going to look at all processes here

549
00:40:29,970 --> 00:40:32,970
and I'm going to open up a couple of apps here.

550
00:40:32,970 --> 00:40:42,570
A little app to scale down images to create
Mip maps and our little friend the robot here.

551
00:40:42,570 --> 00:40:45,600
Let me get these guys going.

552
00:40:45,600 --> 00:40:52,070
Now the previous version of that, that
robot we saw, actually put a sleep in it.

553
00:40:52,070 --> 00:40:56,290
Because it made me nauseous to see
how hyper this guy actually runs.

554
00:40:56,290 --> 00:41:02,810
Apple had this example a long time ago and it used to run
very smoothly because machines back then were a lot slower.

555
00:41:02,810 --> 00:41:07,220
Now machines are so fast it looks like
it had a bit too much caffeine today.

556
00:41:07,220 --> 00:41:13,570
So, but I want to show you now, that the change
in performance when I start my Mip maps app.

557
00:41:13,570 --> 00:41:18,460
So this is going to use a lot of
threads and be pretty intense.

558
00:41:18,460 --> 00:41:28,580
And it's slowed down dramatically and we can see the
reason why if we actually trace this with system trace.

559
00:41:28,580 --> 00:41:36,680
So I'll start that app in deferred mode here and I should
have actually started that before I hit that button there.

560
00:41:36,680 --> 00:41:44,730
So we'll take some data and that's enough
and, this is a MacBook Pro here.

561
00:41:44,730 --> 00:41:49,260
It's just a couple cores and it's gathered
just a ton of data so it takes a little while

562
00:41:49,260 --> 00:41:52,860
to process that, but luckily it's doing it deferred.

563
00:41:52,860 --> 00:42:02,620
So now let's quit our two apps here and
let's look at what we have real quick.

564
00:42:02,620 --> 00:42:12,390
So if we go to the highlights view, we can see and we'll
expand this, a chart of what's going on and we can look

565
00:42:12,390 --> 00:42:22,030
at the top here, at the Scheduling instrument and if we look
at process contact switches and what's going on up here,

566
00:42:22,030 --> 00:42:24,360
a great deal of threads are being switched on and off core.

567
00:42:24,360 --> 00:42:30,000
So there's far more threads that want time in this
scenario than there are cores to service them.

568
00:42:30,000 --> 00:42:35,590
And if we, if we click on one of these
charts, say process contact switches,

569
00:42:35,590 --> 00:42:42,870
we can see that the Mip map utility has
had a huge number of contact switches,

570
00:42:42,870 --> 00:42:49,580
but GLUT Mech which is a purely single
threaded app, has a lot of contact switches too

571
00:42:49,580 --> 00:42:54,940
and if we use the little Focus buttons again on GLUT
Mech, we look down and we go again to all thread states

572
00:42:54,940 --> 00:42:58,170
and now we can or all threads and we
can see how this Jump bar has developed.

573
00:42:58,170 --> 00:43:02,570
We were in summary view, process summary,
GLUT Mech threads and then thread tenures

574
00:43:02,570 --> 00:43:07,810
and we go over to this reason column, we
can see a lot of preemption and blocks.

575
00:43:07,810 --> 00:43:12,660
So this poor little robot was having
a hard time running on a system

576
00:43:12,660 --> 00:43:17,060
with so many other things going
on demanding time of the cores.

577
00:43:17,060 --> 00:43:25,360
So I just wanted to show you this example because
it demonstrates how you should use the system trace.

578
00:43:25,360 --> 00:43:34,540
You need to be aware of and we can go back to the
slides, aware of the system you're running on.

579
00:43:34,540 --> 00:43:41,420
It really is a system trace and so one of the good things
to do with it, when you've made sure that you have the state

580
00:43:41,420 --> 00:43:46,800
that you want to reproduce in the system, is to run
say a heavily multithreaded app on a two core machine

581
00:43:46,800 --> 00:43:53,450
and an eight core machine or a memory intensive app on a
machine that has very little memory and one that has a lot

582
00:43:53,450 --> 00:44:01,350
of memory to see how everything then works
together to give you or degrade your performance.

583
00:44:01,350 --> 00:44:03,500
So that is a demo of system trace.

584
00:44:03,500 --> 00:44:09,510
And so in closing, I'd like to just say that we strongly
believe you know, that Instruments is your go-to tool

585
00:44:09,510 --> 00:44:13,400
for performance analysis and it clearly
has more capabilities than ever.

586
00:44:13,400 --> 00:44:21,210
But I hope it's still in a way simpler to use and it does
provide more accurate insights than ever from what's going

587
00:44:21,210 --> 00:44:23,990
on in the kernel all the way up to user space.

588
00:44:23,990 --> 00:44:30,530
So, there are many sessions following this one
throughout the afternoon and the rest of the week

589
00:44:30,530 --> 00:44:35,930
that I strongly encourage you to attend, that
will be using Instruments in one way or another

590
00:44:35,930 --> 00:44:41,400
or demonstrating, specifically, how you use Instruments
for memory analysis, CPU analysis, etcetera.

591
00:44:41,400 --> 00:44:47,040
And if you have anymore information, please refer to Michael
Jurewitz and developer tools evangelist

592
00:44:47,040 --> 00:44:50,580
and the documentation online, as
well as the Apple Dev Forums.

