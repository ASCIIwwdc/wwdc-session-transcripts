1
00:00:06,430 --> 00:00:08,140
>> David Myszewski: Welcome to the multitasking talk.

2
00:00:08,140 --> 00:00:12,800
I'm David Myszewski and I manage
one of the iPhone performance teams.

3
00:00:12,800 --> 00:00:16,720
I've been working on performance for
about four years and we're going to talk

4
00:00:16,720 --> 00:00:20,100
to you all about multitasking in today's talk.

5
00:00:21,620 --> 00:00:26,290
Also joining me will be David Goodwin, who is an
engineer on my team and spent a lot of time thinking

6
00:00:26,290 --> 00:00:30,050
about multitasking for the last, last year or so.

7
00:00:30,050 --> 00:00:33,810
So, to give you a little, brief
introduction into multitasking,

8
00:00:33,810 --> 00:00:40,430
multitasking is of course a really,
really huge feature of iPhone, of iOS 4.

9
00:00:40,430 --> 00:00:45,510
It's one that we hope that all of you will
adopt in your applications and in fact,

10
00:00:45,510 --> 00:00:49,430
in order to best have the user experience on the iPhone,

11
00:00:49,430 --> 00:00:53,240
we expect really all the apps on the
App Store to adopt multitasking.

12
00:00:53,240 --> 00:01:00,300
And this is part one of a two part series and we'll
talk a little bit about what that means in a little bit.

13
00:01:00,300 --> 00:01:04,560
Now of course, multitasking dramatically
improves the user experience.

14
00:01:04,560 --> 00:01:09,010
Switching back and forth between apps
is really, really seamless on iOS 4.

15
00:01:09,010 --> 00:01:12,570
And applications that you have are just that much better.

16
00:01:12,570 --> 00:01:16,660
Because the user can return immediately to where
they were and they don't have to wait at all.

17
00:01:16,660 --> 00:01:20,720
So it's often the case that your application
will be just sitting around in the background

18
00:01:20,720 --> 00:01:24,250
and the user comes right back to your
application and it's right where you left it.

19
00:01:24,250 --> 00:01:27,440
So it makes existing apps just that much better.

20
00:01:27,440 --> 00:01:32,940
And in addition to that, we're enabling a whole new
category of applications that couldn't have been written

21
00:01:32,940 --> 00:01:38,490
on previous OSs and this will make the
overall user experience a lot better on iOS.

22
00:01:38,490 --> 00:01:43,180
And as I said, every single application
on the store should adopt multitasking.

23
00:01:43,180 --> 00:01:46,520
And today, in this particular talk,
we're going to focus on the features

24
00:01:46,520 --> 00:01:53,820
that we think everybody who's developing
applications for iOS 4, should take advantage of.

25
00:01:53,820 --> 00:01:55,330
So today you'll learn a few things.

26
00:01:55,330 --> 00:02:01,000
First of all, we'll give you an overview about what
multitasking means on iOS 4 and then of course,

27
00:02:01,000 --> 00:02:04,310
we'll describe to you how to enable
multitasking in your application.

28
00:02:04,310 --> 00:02:06,320
And that's going to be a combination of things.

29
00:02:06,320 --> 00:02:12,610
We have provided a bunch of fantastic APIs for you to
adopt and we'll talk to you about what the workflow

30
00:02:12,610 --> 00:02:18,720
of those APIs is, as well as how your application can
fit in really well with the rest of the operating system.

31
00:02:18,720 --> 00:02:22,060
So we'll have some responsibilities
and best practices that we'll discuss

32
00:02:22,060 --> 00:02:26,580
so that your application can be
that much better on the iPhone.

33
00:02:26,580 --> 00:02:31,070
And then finally, we'll describe to you a little
bit about some development tools that allow you

34
00:02:31,070 --> 00:02:37,430
to more easily adopt multitasking and
figure out what your application is doing.

35
00:02:37,430 --> 00:02:42,540
So, to start things off, David Goodwin is
going to give us a little bit of a demo.

36
00:02:47,950 --> 00:02:50,300
>> David Goodwin: Good morning everyone.

37
00:02:50,300 --> 00:02:50,570
[ applause ]

38
00:02:50,570 --> 00:02:53,730
So, here we have two iPhones, 3GSs.

39
00:02:53,730 --> 00:02:57,500
One has iOS 4 on it and one has iPhone OS 3.

40
00:02:57,500 --> 00:02:58,580
You can probably tell which is which.

41
00:02:58,580 --> 00:03:07,070
What we are going to show today, just a brief overview of
what multitasking can do for every single app out there.

42
00:03:07,070 --> 00:03:09,100
Every single app on the App Store.

43
00:03:09,100 --> 00:03:13,270
So first let's, what we have for a
demo here is a pretty simple app.

44
00:03:13,270 --> 00:03:17,330
It's just a little journaling app, that you can like
make little notes in and attach a little photo to

45
00:03:17,330 --> 00:03:19,280
and I'm going to launch that on each device.

46
00:03:19,280 --> 00:03:20,540
And here it launches up.

47
00:03:20,540 --> 00:03:25,970
You can see we have our entries for just a
few things that I've been journaling about.

48
00:03:25,970 --> 00:03:27,350
Then we can look into them.

49
00:03:27,350 --> 00:03:29,450
Like there's this little kayak trip.

50
00:03:29,450 --> 00:03:30,890
That was pretty nice.

51
00:03:30,890 --> 00:03:35,140
OK, oh I did notice back there
actually though, this Irwin's wedding.

52
00:03:35,140 --> 00:03:39,150
I was, I see that I'm thinking oh, I had
some other photos about Irwin's wedding.

53
00:03:39,150 --> 00:03:40,710
Wouldn't it be great, I want to
go check those out right now.

54
00:03:40,710 --> 00:03:42,020
That just reminded me.

55
00:03:42,020 --> 00:03:47,220
Well, iPhone OS 3 of course, we would
return to SpringBoard and we'd find photos

56
00:03:47,220 --> 00:03:50,690
and we'd launch it and go into the wedding.

57
00:03:50,690 --> 00:03:54,380
In iPhone OS4 of course, we have
the great, new multitasking UI.

58
00:03:54,380 --> 00:03:58,460
So I can just double-tap that.

59
00:03:58,460 --> 00:04:03,580
Photos, which it turns out, one thing you'll notice
here, not only did I switch quickly into photos,

60
00:04:03,580 --> 00:04:05,070
but I had been looking at photos earlier.

61
00:04:05,070 --> 00:04:07,110
Maybe a couple days ago, maybe even a week ago.

62
00:04:07,110 --> 00:04:07,520
I don't know.

63
00:04:07,520 --> 00:04:10,190
It could have been running in the
background for a long time.

64
00:04:10,190 --> 00:04:10,980
But right there it is.

65
00:04:10,980 --> 00:04:13,380
I can quickly get to that, my photo library.

66
00:04:13,380 --> 00:04:17,550
In this case I want to look at some of
Irwin and Jill's photos from that wedding.

67
00:04:17,550 --> 00:04:20,430
And now I want to, OK but I want to go back to my journal.

68
00:04:20,430 --> 00:04:26,990
Again, iPhone OS 3 you leave the photos app
and find journal here again and launch it,

69
00:04:26,990 --> 00:04:32,890
iPhone OS4 I'm going to use this great
multitasking UI and I'm going to go right back.

70
00:04:32,890 --> 00:04:37,800
Now one thing I noticed here is, I didn't do the best
job I could have writing this application, did I?

71
00:04:37,800 --> 00:04:42,100
Because when I returned on iPhone OS
3 and I relaunched the journal app,

72
00:04:42,100 --> 00:04:45,210
actually didn't bring the user
right back to where they were.

73
00:04:45,210 --> 00:04:46,760
Now that's my mistake as a developer.

74
00:04:46,760 --> 00:04:48,270
I could have done a better job.

75
00:04:48,270 --> 00:04:55,030
But on iOS 4, we help you out a little bit there
and we actually came right back to that same spot.

76
00:04:55,030 --> 00:05:00,720
Now, let's look, another interesting thing here, let's,
this hike at Lake Tahoe, it has a little, a URL in it.

77
00:05:00,720 --> 00:05:03,760
My journal app let's you put URLs in.

78
00:05:03,760 --> 00:05:07,780
And I can again, I can follow an URL link in each of these.

79
00:05:07,780 --> 00:05:13,170
And again, I switch right into Safari there, with the UI.

80
00:05:13,170 --> 00:05:15,570
Whoops, well I didn't go Wi-Fi.

81
00:05:15,570 --> 00:05:19,500
We don't have any Wi-Fi problems I hope.

82
00:05:19,500 --> 00:05:26,640
And again, once again, following URLs or switching
quickly between apps, it's much quicker, much easier,

83
00:05:26,640 --> 00:05:32,900
much better user experience for all your
applications in iOS 4, compared to iPhone OS 3.

84
00:05:32,900 --> 00:05:38,640
And so hopefully that demonstration there
helped you see why, how compelling it will be

85
00:05:38,640 --> 00:05:41,250
for you to adopt multitasking for your app.

86
00:05:41,250 --> 00:05:42,620
Now back to Dave.

87
00:05:42,620 --> 00:05:48,120
>> Dave Myszewski: So, we have a particular view
on multitasking for iOS 4 and in particular,

88
00:05:48,120 --> 00:05:52,970
we don't believe that general purpose
concurrency is the solution for mobile devices.

89
00:05:52,970 --> 00:05:55,340
Mobile devices have limited resources.

90
00:05:55,340 --> 00:06:03,090
They have limited CPU, they have limited RAM and so
we think that in the application that you just saw,

91
00:06:03,090 --> 00:06:08,810
that really the important thing for that application wasn't
that the app was actually doing something in the background,

92
00:06:08,810 --> 00:06:13,630
the really important thing was that when the
user returned to the app, the state was preserved

93
00:06:13,630 --> 00:06:16,690
and the user could immediately interact with the app.

94
00:06:16,690 --> 00:06:21,990
And for all of the applications on the App
Store, we believe that that will be true.

95
00:06:21,990 --> 00:06:28,290
That you really want to be able to quickly switch to
particular applications and return to exactly where you were

96
00:06:28,290 --> 00:06:31,110
and be able to immediately interact with the app.

97
00:06:32,270 --> 00:06:38,250
And so in fact, that's, if you look at a pie
chart, that would be our pie chart, 100%.

98
00:06:38,250 --> 00:06:43,550
But you know, there are obviously some applications
that boy, you really need to run in the background

99
00:06:43,550 --> 00:06:45,510
in order to accomplish the particular task.

100
00:06:45,510 --> 00:06:51,430
And so what we've done with multitasking is we've created
a little slice of the pie that applications that benefit

101
00:06:51,430 --> 00:06:56,010
from background execution and we
have enabled certain categories

102
00:06:56,010 --> 00:06:58,980
of applications to continue running into the background.

103
00:06:58,980 --> 00:07:02,770
And these ones will be described in great
detail in the second talk and in particular,

104
00:07:02,770 --> 00:07:07,130
the ability to finish some task that you
are in the middle of, play background audio

105
00:07:07,130 --> 00:07:10,130
and do some location in VoIP, also in the background.

106
00:07:10,130 --> 00:07:17,030
So, with multitasking we've provided a solution that works
very well for all developers, for quickly switching back

107
00:07:17,030 --> 00:07:23,430
and forth between applications and then also
enabled some new categories of applications.

108
00:07:23,430 --> 00:07:29,890
Now of course, we still have push notifications, which are
a fantastic way for the server to do all the heavy lifting

109
00:07:29,890 --> 00:07:34,400
and the processing and the pulling, the things that
would consume battery life and then send a notification

110
00:07:34,400 --> 00:07:39,520
to the device when some interesting data
that the user should know about, arrives.

111
00:07:39,520 --> 00:07:45,360
So push notifications still are a fantastic
tool to use, even in the multitasking world.

112
00:07:45,360 --> 00:07:51,460
Because we are pushing all of the heavy lifting
for CPU and battery life, onto the servers.

113
00:07:51,460 --> 00:07:57,930
So as you saw, we have a lot of benefits
for what we're calling fast app switching,

114
00:07:57,930 --> 00:08:03,490
which is that the application resumes really quickly,
all of the state was preserved exactly where you left it.

115
00:08:03,490 --> 00:08:08,790
We provide some great APIs to integrate really
well with the multitasking UI and of course,

116
00:08:08,790 --> 00:08:12,840
all of the apps on the App Store, we think
will update to this and so, you know,

117
00:08:12,840 --> 00:08:17,700
the whole OS just behaves better if
everybody has adopted multitasking.

118
00:08:17,700 --> 00:08:20,190
So I'll give you a brief overview of the services.

119
00:08:20,190 --> 00:08:24,480
The one that we're going to focus on for this
particular talk is what we call, fast app switching.

120
00:08:24,480 --> 00:08:29,460
The ability that you saw to resume
quickly and preserve state.

121
00:08:29,460 --> 00:08:34,640
Push notifications, of course, are still relevant
in the multitasking world, as I just described.

122
00:08:34,640 --> 00:08:40,770
Local notifications, which are a nice tool in which
you can provide the services of push notifications,

123
00:08:40,770 --> 00:08:49,100
so displaying an alert, badging your icon, playing a sound
at a predetermined time and then a few different services

124
00:08:49,100 --> 00:08:54,370
for which applications can take advantage of that
will be described in great detail in the second talk,

125
00:08:54,370 --> 00:09:01,410
which are background audio, so the ability to play audio
in the background, as you saw in the keynote yesterday.

126
00:09:01,410 --> 00:09:08,440
Task completion, which basically it recognizes that there
is a category of apps for which the user initiated a task

127
00:09:08,440 --> 00:09:14,100
in the foreground, like uploading a photo or downloading
some content and you really want that operation

128
00:09:14,100 --> 00:09:19,820
to complete before, without the user having
to keep the application in the background.

129
00:09:19,820 --> 00:09:25,690
So we're calling that task completion, the ability
to complete a specific task in the background.

130
00:09:25,690 --> 00:09:28,710
And we have a couple of location services.

131
00:09:28,710 --> 00:09:34,620
One that's focused on navigation, which allows
you to use GPS in the background and give very,

132
00:09:34,620 --> 00:09:43,250
very precise notifications of location changes and some new
services, which we're calling significant location changes

133
00:09:43,250 --> 00:09:52,790
and region monitoring, which are low power abilities to
figure out when the location changes in the background.

134
00:09:52,790 --> 00:09:59,830
And then the last one is Voice Over IP, which allows
you to both continue while on the call in the background

135
00:09:59,830 --> 00:10:02,940
and of course receive calls in the background.

136
00:10:02,940 --> 00:10:07,250
So together, all of these services
comprise our multitasking solution.

137
00:10:07,250 --> 00:10:11,740
And as I said, we're going to focus
on fast app switching in this talk.

138
00:10:11,740 --> 00:10:19,570
In the second talk, we'll go through all of those services
in that second slide that we were just looking at.

139
00:10:19,570 --> 00:10:22,940
So, if you're a developer, how do you enable multitasking?

140
00:10:22,940 --> 00:10:25,000
Well it's really simple.

141
00:10:25,000 --> 00:10:27,640
Just build with the iPhone SDK4.

142
00:10:27,640 --> 00:10:33,340
Fast app switching is enabled by default and
so we think that every app should adopt it

143
00:10:33,340 --> 00:10:38,930
and so we made it the default behavior
when you compile with iPhone SDK4.

144
00:10:38,930 --> 00:10:43,320
And of course, if you have some of the other
services like background audio, location and VoIP,

145
00:10:43,320 --> 00:10:49,550
then we require that you have an explicit
declaration in the apps Info.plist.

146
00:10:49,550 --> 00:10:56,270
So, your app lifecycle changes a lot with
multitasking, so to describe in very great detail

147
00:10:56,270 --> 00:11:00,110
about how the app lifecycle behaves
in this new multitasking world,

148
00:11:00,110 --> 00:11:03,760
David Goodwin is going to come back on
stage and describe how it all works.

149
00:11:03,760 --> 00:11:06,890
>> David Goodwin: So, iOS 4 give us
these great multitasking services.

150
00:11:06,890 --> 00:11:11,440
As Dave said, today we're going to focus mostly on
fast app switching, although a lot of what we'll talk

151
00:11:11,440 --> 00:11:13,200
about as well will be kind of general things.

152
00:11:13,200 --> 00:11:17,990
Responsibilities, best practices, that you need
to be aware of when you're writing your app.

153
00:11:17,990 --> 00:11:21,290
Before we go into those responsibilities and best practices,

154
00:11:21,290 --> 00:11:24,470
we're going to go into detailed
walk about how your app behaves.

155
00:11:24,470 --> 00:11:28,840
Now you might know this from your iPhone OS 3
development, in fact we're going to review that first

156
00:11:28,840 --> 00:11:31,650
and then go into the detail of the iOS 4.

157
00:11:31,650 --> 00:11:34,640
You know, how your application
acts, how the user interacts with it

158
00:11:34,640 --> 00:11:37,880
and how your application interacts with this lifecycle.

159
00:11:37,880 --> 00:11:40,210
So let's start again.

160
00:11:40,210 --> 00:11:43,760
We'll start with the review of iPhone OS 3.

161
00:11:43,760 --> 00:11:47,360
Now iPhone OS 3 basically has three
states that your application can be in.

162
00:11:47,360 --> 00:11:49,580
The not running state, which is pretty obvious.

163
00:11:49,580 --> 00:11:52,620
And then two running states, inactive and active.

164
00:11:52,620 --> 00:11:58,760
So let's review how when the user interacts with the device,
how your application transitions between these states.

165
00:11:58,760 --> 00:12:01,610
Again, initially your application
is in the not running state.

166
00:12:01,610 --> 00:12:03,270
User launches your application.

167
00:12:03,270 --> 00:12:06,330
As an example we'll use Maps in this case.

168
00:12:06,330 --> 00:12:07,840
Map starts running.

169
00:12:07,840 --> 00:12:14,110
Your application transitions through an inactive
state and then into the active running state.

170
00:12:14,110 --> 00:12:17,140
So this is the normal foreground running state.

171
00:12:17,140 --> 00:12:20,660
Your app's in the foreground, the user can interact with it.

172
00:12:20,660 --> 00:12:26,380
But what can also happen while your app is in the foreground
is for example, you can receive an SMS or some other alert,

173
00:12:26,380 --> 00:12:32,520
push notification, incoming phone call or the user
can lock the device over top of your application.

174
00:12:32,520 --> 00:12:38,070
In all those cases what happens is, your
application moves into the inactive state.

175
00:12:38,070 --> 00:12:41,930
Now your application is still running, it's still
in the foreground, but it's kind of obscured

176
00:12:41,930 --> 00:12:48,960
or there's something else on top of it,
that puts it into this inactive state.

177
00:12:48,960 --> 00:12:56,550
Now from the inactive state, the user can take some
action to move it either back into the active state

178
00:12:56,550 --> 00:12:58,490
or potentially into the not running state.

179
00:12:58,490 --> 00:13:03,430
For example with an SMS, if the user choose to
reply to the SMS, the SMS app is going to launch

180
00:13:03,430 --> 00:13:06,630
and your application would go into the not running state.

181
00:13:06,630 --> 00:13:11,490
In this case, let's assume the user pushes the Close
button, so he's not going to look at the SMS right now.

182
00:13:11,490 --> 00:13:16,570
That returns your application back into the active state.

183
00:13:16,570 --> 00:13:20,740
And of course, the last thing a user can do is to
leave your application by hitting the Home button.

184
00:13:20,740 --> 00:13:26,870
In that case, your application
transitions into the not running state.

185
00:13:26,870 --> 00:13:28,070
So again, this is very familiar.

186
00:13:28,070 --> 00:13:32,940
This is the way your applications have been
interacting with the user and

187
00:13:32,940 --> 00:13:39,090
with the application lifecycle in iPhone
OS 3 and so let's compare that with iOS 4.

188
00:13:39,090 --> 00:13:43,060
We'll start with the familiar states we just talked about

189
00:13:43,060 --> 00:13:46,870
and in fact the device mostly behaves
the same way with respect to those.

190
00:13:46,870 --> 00:13:49,670
So your application is not running.

191
00:13:49,670 --> 00:13:50,460
The user launches it.

192
00:13:50,460 --> 00:13:52,660
Again, we're using Maps.

193
00:13:52,660 --> 00:13:54,010
Moves into the active state.

194
00:13:54,010 --> 00:14:02,780
Now, as before there's an inactive state that your
app can enter and that's the same as in iPhone OS 3

195
00:14:02,780 --> 00:14:05,210
or an SMS, incoming phone call, et cetera.

196
00:14:05,210 --> 00:14:10,580
There's a new inactive, a new way to enter into the
inactive state and that's through the multitasking UI.

197
00:14:10,580 --> 00:14:16,590
So if the user brings up the multitasking UI, your
application will again enter the inactive state.

198
00:14:16,590 --> 00:14:22,760
If they dismiss the multitasking UI or any
of those other SMS, just like in iPhone OS 3,

199
00:14:22,760 --> 00:14:25,910
your application will return to the active state.

200
00:14:25,910 --> 00:14:32,990
Now, together, because your app is in the foreground,
you know it is running, we group together the active

201
00:14:32,990 --> 00:14:37,810
and the inactive states together,
as the foreground execution state.

202
00:14:37,810 --> 00:14:43,470
Of course, the exciting new thing, most exciting new thing
about this application lifecycle with regard to iOS 4,

203
00:14:43,470 --> 00:14:46,690
is that we're going to introduce two new background states.

204
00:14:46,690 --> 00:14:52,890
And these are, we're calling them the background
running and the background suspended states.

205
00:14:52,890 --> 00:14:57,930
The background running state, as you
can imagine, is when your application is

206
00:14:57,930 --> 00:15:00,660
in the background, but is allowed to continue running.

207
00:15:00,660 --> 00:15:06,210
Now as Dave mentioned, there's some services, some
categories of multitasking that where it's beneficial

208
00:15:06,210 --> 00:15:12,210
to allow your application to continue running and those
applications then would be in the background running state.

209
00:15:12,210 --> 00:15:18,280
This background suspended state, is the state that the
system uses, when it really wants to minimize the impact

210
00:15:18,280 --> 00:15:21,730
that your application has on the entire system as a whole.

211
00:15:21,730 --> 00:15:27,390
So your application is not terminated, it moves into
the suspended state where it reduces your system use,

212
00:15:27,390 --> 00:15:30,580
resource usage and remains in the background.

213
00:15:30,580 --> 00:15:36,610
And this is the one which we'll talk about a
lot more with regards to fast app switching.

214
00:15:36,610 --> 00:15:42,680
So, let's say the user there had
the Maps app was in the front

215
00:15:42,680 --> 00:15:46,370
and now they hit the Home button in iOS 4, to dismiss that.

216
00:15:46,370 --> 00:15:50,080
So unlike iOS 3, they're not terminating the
application anymore, what are they doing?

217
00:15:50,080 --> 00:15:54,660
Well instead the application moves into the background.

218
00:15:54,660 --> 00:16:00,640
Now all applications will be in the background running
state, even if it's temporary and we're going to talk

219
00:16:00,640 --> 00:16:06,760
about more of this in a minute, and from the background
running state the system may move your application

220
00:16:06,760 --> 00:16:12,000
into the background suspended state.

221
00:16:12,000 --> 00:16:17,500
Now, here's a difference, another
difference from the iPhone OS 3 lifecycle,

222
00:16:17,500 --> 00:16:21,060
whereas before when your application
would terminate from either the active

223
00:16:21,060 --> 00:16:23,800
or the inactive state and move into the not running state.

224
00:16:23,800 --> 00:16:28,580
In iOS 4, your application moves into the not running state,

225
00:16:28,580 --> 00:16:32,130
from either the background running
or the background suspended states.

226
00:16:32,130 --> 00:16:37,290
And we're going to talk in more detail
in just a minute about how that happens.

227
00:16:37,290 --> 00:16:43,360
OK, so what we just described is, the user is
interacting with the phone, they're launching,

228
00:16:43,360 --> 00:16:46,020
they're using multitasking UI,
they're returning to SpringBoard

229
00:16:46,020 --> 00:16:50,600
and we saw how those user actions effected your application.

230
00:16:50,600 --> 00:16:53,100
How it moved it through its lifecycle.

231
00:16:53,100 --> 00:16:57,920
Well, so but as the application developer, how are you
going to be aware of these lifecycle changes and respond

232
00:16:57,920 --> 00:17:01,080
to these lifecycle changes and take
the necessary actions that you need to?

233
00:17:01,080 --> 00:17:06,640
Well just like an iPhone OS 3, we have UI
application delegate callbacks and notifications,

234
00:17:06,640 --> 00:17:11,110
which are used to inform your application
of these transitions.

235
00:17:11,110 --> 00:17:14,280
So let's walk through them and
we'll start with the familiar ones.

236
00:17:14,280 --> 00:17:18,990
Again which are more or less identical
to what you have in iPhone OS 3.

237
00:17:18,990 --> 00:17:20,340
So you're in the not running state again.

238
00:17:20,340 --> 00:17:22,520
We're going to use Maps as our example again.

239
00:17:22,520 --> 00:17:25,480
The user launches it and what happens?

240
00:17:25,480 --> 00:17:32,850
Your application receives, the application did
finish launching with options, delegate callback,

241
00:17:32,850 --> 00:17:35,800
as an indication that the application is being launched.

242
00:17:35,800 --> 00:17:39,530
Transitions briefly into the inactive state.

243
00:17:39,530 --> 00:17:45,500
Continues the launching process, your application
will receive, application did become active.

244
00:17:45,500 --> 00:17:53,670
At which time now it is transitioned completely into
the active state of the foreground active running task.

245
00:17:53,670 --> 00:17:58,440
Let's say again that some interruption occurs like
the multitasking UI or something else that causes it

246
00:17:58,440 --> 00:18:03,030
to transition into the inactive state and of course
you'll receive, just like today, you'll receive,

247
00:18:03,030 --> 00:18:05,740
the application will resign active callback.

248
00:18:05,740 --> 00:18:10,680
OK, so that's all very familiar to
us, let's look at something new.

249
00:18:10,680 --> 00:18:17,090
So again, here's your application Maps that's
running in the foreground, user hits the Home button.

250
00:18:17,090 --> 00:18:22,980
So you're in the active state, they hit
the Home button, the application now moves

251
00:18:22,980 --> 00:18:25,470
through into the inactive state again temporarily.

252
00:18:25,470 --> 00:18:29,740
You get, your application will resign
active callback, followed by a new callback,

253
00:18:29,740 --> 00:18:34,470
new for iOS 4, called applicationDidEnterBackground.

254
00:18:34,470 --> 00:18:39,650
This is an important callback, as you
can see from our lifecycle diagram.

255
00:18:39,650 --> 00:18:44,720
This is the indication to your application that it's
moving from a foreground state into the background.

256
00:18:44,720 --> 00:18:49,870
Now we're going to talk, we're going to talk about
responsibilities and best practices here in a few minutes,

257
00:18:49,870 --> 00:18:53,970
you're going to see that this is a very
important point in your application's lifecycle.

258
00:18:53,970 --> 00:19:00,890
This is the point where you would save application state for
example, try to reduce your memory usage and other things,

259
00:19:00,890 --> 00:19:04,410
other responsibilities which we're
going to talk about later.

260
00:19:04,410 --> 00:19:11,130
So now, as I said, your application after it's moved
into the background running state and depending

261
00:19:11,130 --> 00:19:16,020
on which services your application benefits from,
it could remain in this background running state.

262
00:19:16,020 --> 00:19:22,180
However, for a fast app switching application, the
transition is going to continue and the system is going

263
00:19:22,180 --> 00:19:24,460
to move it into the background suspended state.

264
00:19:24,460 --> 00:19:26,630
Now this box is empty.

265
00:19:26,630 --> 00:19:31,600
This is a very important point of your application's
lifecycle is that your application and the user

266
00:19:31,600 --> 00:19:35,570
for that matter, is not going to have any
indication of when the application transitioned

267
00:19:35,570 --> 00:19:39,660
from the background running state
into the background suspended state.

268
00:19:39,660 --> 00:19:45,580
And the implications of this, there's going to be
implications of this about when you need to reduce memory,

269
00:19:45,580 --> 00:19:50,660
when you need to save your state, which again we're
going to talk about in the responsibilities section.

270
00:19:50,660 --> 00:19:52,070
So let's do the other way around here.

271
00:19:52,070 --> 00:19:56,460
If your application is, it's running,
so it was launched earlier.

272
00:19:56,460 --> 00:20:03,060
It's in the background in the suspended state and now
the user reselects the icon or selects it from the,

273
00:20:03,060 --> 00:20:07,920
from SpringBoard or from the multitasking
UI, basically launches it again, resumes it,

274
00:20:07,920 --> 00:20:11,440
we have kind of the reverse set of steps.

275
00:20:11,440 --> 00:20:16,160
Again, the system is going to first move your
application into the background running state.

276
00:20:16,160 --> 00:20:19,820
There's not going to be any indication to
you or to the user that this is happening.

277
00:20:19,820 --> 00:20:22,100
You as the application developer, your application.

278
00:20:22,100 --> 00:20:25,560
You're going to receive a new, another
new ApplicationDelegate callback,

279
00:20:25,560 --> 00:20:30,730
applicationWillEnterForeground, again a very important
callback, because this is the indication to your application

280
00:20:30,730 --> 00:20:35,940
that the, that the app itself is transitioning
from the background into the foreground.

281
00:20:35,940 --> 00:20:43,910
Briefly through the inactive state and then back into
the active state with applicationDidBecomeActive.

282
00:20:46,930 --> 00:20:51,540
So then we saw how we transitioned,
the normal transitions for launching.

283
00:20:51,540 --> 00:20:55,580
We saw the transitions into the
foreground, into the background.

284
00:20:55,580 --> 00:20:58,010
So what about termination?

285
00:20:58,010 --> 00:21:03,100
The user doesn't terminate your application every
time they hit the Home button anymore, obviously.

286
00:21:03,100 --> 00:21:08,580
So what, but there is still a not running state in iOS 4.

287
00:21:08,580 --> 00:21:10,810
Your applications don't run indefinitely.

288
00:21:10,810 --> 00:21:19,490
So, one way that the user or the way that the user can
move your application from the background running state

289
00:21:19,490 --> 00:21:24,110
into the suspended state or into the not
running state, is through the multitasking UI.

290
00:21:24,110 --> 00:21:28,700
So in this case let's assume that we have iPod
actually running and playing audio at this point.

291
00:21:28,700 --> 00:21:31,960
So it's actually in the background running state.

292
00:21:31,960 --> 00:21:34,780
Using the background audio service to play its audio.

293
00:21:34,780 --> 00:21:43,330
And the user uses the little minus
sign there to stop, to terminate iPod.

294
00:21:43,330 --> 00:21:49,400
Well the transition into the not running state
and this delegate callback you're familiar with,

295
00:21:49,400 --> 00:21:52,460
this is the applicationWillTerminateDelegate
callback that you had today,

296
00:21:52,460 --> 00:21:54,720
it's just occurring at a different point in the lifecycle.

297
00:21:54,720 --> 00:21:59,410
Well let's look at another background state.

298
00:21:59,410 --> 00:22:00,850
So we also have Maps down here.

299
00:22:00,850 --> 00:22:05,220
Now Maps, Maps does not have any benefit from running
in the background, so it actually is suspended

300
00:22:05,220 --> 00:22:07,380
by the system when it's in the background.

301
00:22:07,380 --> 00:22:09,390
So it's sitting there in the background suspended state.

302
00:22:09,390 --> 00:22:14,430
But what if the user you know,
closes it now with the minus sign?

303
00:22:14,430 --> 00:22:21,340
Well here's another case of that, the system will transition
Maps into the not running state, it will terminate Maps,

304
00:22:21,340 --> 00:22:25,790
but there's not going to be any indication
to Maps that it just got terminated.

305
00:22:25,790 --> 00:22:31,430
So again, this has implications in that once
your application enters the suspended state,

306
00:22:31,430 --> 00:22:37,000
it had better have done all the cleanup, all the
saving, all the bookkeeping that it needs to have done.

307
00:22:37,000 --> 00:22:41,130
Because once it's entered the suspended state,
it can be moved into the not running state,

308
00:22:41,130 --> 00:22:44,290
without ever getting the chance to execute any code again.

309
00:22:44,290 --> 00:22:48,380
So that's a very important principle that's going to
guide some of our best practices and responsibilities.

310
00:22:48,380 --> 00:22:52,890
Now as I mentioned, this is a little bit of an eye chart.

311
00:22:52,890 --> 00:22:58,330
But you have these UI applicationDelegate callbacks,
along with each one there's a corresponding notification

312
00:22:58,330 --> 00:23:04,170
and so for the two new delegate callbacks, we've
added two new notifications for the foreground

313
00:23:04,170 --> 00:23:07,540
and background transitions and you can
look these up in the documentation.

314
00:23:07,540 --> 00:23:12,330
The way that you use these notifications
is identical to how you did in iPhone OS 3.

315
00:23:12,330 --> 00:23:18,250
OK, so I've eluded a lot to responsibilities
and best practices and so,

316
00:23:18,250 --> 00:23:22,040
we're going to start talking about those now.

317
00:23:22,040 --> 00:23:26,860
It's important to keep in mind that a lot of these are
phrased, although we're focusing on fast app switching

318
00:23:26,860 --> 00:23:31,140
in this talk, with the lifecycle I just
talked about and all these responsibilities

319
00:23:31,140 --> 00:23:35,690
and best practices, apply to all multitasking applications.

320
00:23:35,690 --> 00:23:41,060
Now there might be slight variations that we'll talk
about, so if your background audio app or a VoIP app,

321
00:23:41,060 --> 00:23:46,040
that the second talk will cover any
exceptions or details that you need to know.

322
00:23:46,040 --> 00:23:51,870
But in general, what we're going to talk about here applies
to all multitasking apps, not just fast app switching.

323
00:23:51,870 --> 00:23:57,550
So, before we get to the details, let's talk
a little about system resource management.

324
00:23:57,550 --> 00:24:05,620
So, of course a big goal at Apple, with our
multitasking implementation and as Dave eluded to before,

325
00:24:05,620 --> 00:24:10,610
we think that a kind of general purpose
concurrency, general purpose background execution,

326
00:24:10,610 --> 00:24:15,760
that's not appropriate for these type of mobile devices.

327
00:24:15,760 --> 00:24:18,490
Because we really want to do two things.

328
00:24:18,490 --> 00:24:23,790
We want to preserve battery life, obviously and
you know, in the keynote there was a great quote

329
00:24:23,790 --> 00:24:29,300
from Sergei, I think, about how
just having these background tasks running wild,

330
00:24:29,300 --> 00:24:35,690
running free in the background, that's not
good for the battery and we agree 100%.

331
00:24:35,690 --> 00:24:41,370
The other big thing is those background, free running
kind of background tasks, Wild West background tasks,

332
00:24:41,370 --> 00:24:45,480
it's not good for the device's usability.

333
00:24:45,480 --> 00:24:46,310
Its responsiveness.

334
00:24:46,310 --> 00:24:53,570
And so those are our two goals with some of these
responsibilities and best practices and indeed,

335
00:24:53,570 --> 00:24:56,640
the general design of the multitasking as a whole.

336
00:24:56,640 --> 00:25:01,660
And of course the system resources are
shared by all the apps and that goes

337
00:25:01,660 --> 00:25:06,650
without saying and there are limited resources.

338
00:25:06,650 --> 00:25:11,400
And so, you should really try, when you're thinking
about your app that's running in the background

339
00:25:11,400 --> 00:25:18,280
or even if it's going to be suspended in the background,
you need to think about minimizing your resource usage.

340
00:25:18,280 --> 00:25:22,740
And we're going to give you some best practices and point
out some places where you can, you can help out with that.

341
00:25:22,740 --> 00:25:28,730
And this is not completely something that
oh, we want you to do this for the system.

342
00:25:28,730 --> 00:25:35,430
You'll see how that by doing these best practices and
adopting and taking these responsibilities seriously,

343
00:25:35,430 --> 00:25:40,620
you'll make your application work better
in this whole multitasking environment.

344
00:25:40,620 --> 00:25:45,930
You'll, it can be a differentiating factor when people
use your application, they'll notice that oh, when I come,

345
00:25:45,930 --> 00:25:50,270
his application whenever I go back
to it, it's right where I left it.

346
00:25:50,270 --> 00:25:53,740
And we'll see how you can do that.

347
00:25:53,740 --> 00:25:54,810
So here's an outline of the thing.

348
00:25:54,810 --> 00:25:57,260
So I've kind of grouped them into two categories.

349
00:25:57,260 --> 00:26:00,660
Some responsibilities and best practices
for when your application is making

350
00:26:00,660 --> 00:26:03,780
that transition from the foreground into the background.

351
00:26:03,780 --> 00:26:05,170
And we'll go through these in detail.

352
00:26:05,170 --> 00:26:11,720
And then there's a kind of corresponding set, shorter
but, when your application, it's been in the background

353
00:26:11,720 --> 00:26:13,460
and now the user is bringing it to the foreground again,

354
00:26:13,460 --> 00:26:16,320
there is some things that you need
to take care of and be aware of.

355
00:26:16,320 --> 00:26:17,050
So let's start here.

356
00:26:17,050 --> 00:26:22,340
We'll start with a big one, which
is saving application state.

357
00:26:23,790 --> 00:26:35,690
So, I mentioned earlier that it's important, that once
your application enters the background and it moves

358
00:26:35,690 --> 00:26:41,890
into the suspended state, your application
isn't necessarily going to get another chance

359
00:26:41,890 --> 00:26:44,780
to execute any code before it can be terminated.

360
00:26:44,780 --> 00:26:49,280
And so you know, a big implication of that is that
when your application goes through that transition

361
00:26:49,280 --> 00:26:55,760
into the background, as indicated by the callback or the
notification, you need to save your application state.

362
00:26:55,760 --> 00:27:00,030
Because if your application is terminated,
whatever you saved at that last transition there,

363
00:27:00,030 --> 00:27:04,370
that's what you're going to you know, your app's going to
have when it starts back up again, when it's relaunched.

364
00:27:04,370 --> 00:27:06,750
But that might not be sufficient.

365
00:27:06,750 --> 00:27:14,080
As with all these UI applicationDelegate callbacks and this
is true in iPhone OS 3 as well and it continues to be true

366
00:27:14,080 --> 00:27:19,590
in iOS 4, there's a limited amount of time that your
application can spend in those delegate callbacks.

367
00:27:19,590 --> 00:27:21,350
A few seconds.

368
00:27:21,350 --> 00:27:28,000
And so if you have such a large amount of application state
or other work that would need to be done on this transition

369
00:27:28,000 --> 00:27:32,090
into the background, you know you might not have
time to always save all your state in that time

370
00:27:32,090 --> 00:27:35,750
and that would be a lot of state, but it's something
you need to be aware of and so you might need

371
00:27:35,750 --> 00:27:38,280
to adopt some other state saving strategies as well.

372
00:27:38,280 --> 00:27:43,200
Save part of your state incrementally
or you know, as you go along.

373
00:27:43,200 --> 00:27:46,760
This makes a lot of sense, especially in
something like a turn-by-turn game for example.

374
00:27:46,760 --> 00:27:52,120
It's very natural to save your state
at check points or levels and what not.

375
00:27:52,120 --> 00:27:55,730
OK so that's one responsibility.

376
00:27:55,730 --> 00:27:59,510
Another one is reduced memory usage.

377
00:27:59,510 --> 00:28:01,780
This is also a very important one.

378
00:28:01,780 --> 00:28:02,620
Let's get into this.

379
00:28:02,620 --> 00:28:11,340
So system memory, it's a limited resource on these devices.

380
00:28:11,340 --> 00:28:18,200
And so as such, the system, when
it needs more system memory,

381
00:28:18,200 --> 00:28:23,720
the way it frees up more system memory
is by terminating an application.

382
00:28:23,720 --> 00:28:30,810
So as I showed in those lifecycle diagrams earlier
on, there were transitions from background running

383
00:28:30,810 --> 00:28:36,240
and background suspended into the not running state
and one way to get those transitions to occur is

384
00:28:36,240 --> 00:28:38,420
from the user's action as I showed in the multitasking UI.

385
00:28:38,420 --> 00:28:44,810
Of course another way those transitions can occur
is that the system needs to free up some memory.

386
00:28:44,810 --> 00:28:49,330
The user is launching a new app that they hadn't,
that hadn't been launched, memory is all used up.

387
00:28:49,330 --> 00:28:55,930
Well, you know, this new app's going to need some memory
and so the system it prioritizes how it goes about deciding

388
00:28:55,930 --> 00:29:03,490
which app will be terminated to free up the system
memory needed for by say this newly launched app.

389
00:29:03,490 --> 00:29:05,800
And roughly the prioritization goes something like this.

390
00:29:05,800 --> 00:29:10,670
We have, again we have some apps that are in the
background suspended and some in the background running.

391
00:29:10,670 --> 00:29:15,650
Let's roughly categorize those apps into ones that
are using a lot of memory, a lot of memory usage

392
00:29:15,650 --> 00:29:18,380
and some that are using you know, a small amount of memory.

393
00:29:18,380 --> 00:29:25,160
And the system is going to greatly prefer to
terminate the high memory using applications.

394
00:29:25,160 --> 00:29:32,050
The other point to make here is that this memory,
termination due to a low memory condition,

395
00:29:32,050 --> 00:29:36,720
this is the normal state of the device in iOS 4.

396
00:29:36,720 --> 00:29:40,350
When users leave an app and go into another app,
the app they just left, it's still there in memory.

397
00:29:40,350 --> 00:29:46,270
Now they go to the next app, the next, you know, four,
five, six, ten, all those apps are going to remain in memory

398
00:29:46,270 --> 00:29:52,390
until the system memory resource is exhausted
and the system is required to terminate one.

399
00:29:52,390 --> 00:29:56,330
So, it's an important point that it's a normal condition.

400
00:29:56,330 --> 00:30:02,160
So, now we see that, so your application can be
terminated because of this low memory condition.

401
00:30:02,160 --> 00:30:09,220
So of course, using less memory from a system point of view,
from a usability point of view, from a user happiness point

402
00:30:09,220 --> 00:30:14,590
of view, if all the apps together are doing their best
to use less memory, well the user is going to be able

403
00:30:14,590 --> 00:30:20,270
to have basically a greater working set of
apps that can stay resident on the device,

404
00:30:20,270 --> 00:30:23,990
before the system needs to do any of these terminations.

405
00:30:23,990 --> 00:30:30,420
So, you can think about in your own usage, what's
your working set of apps and wouldn't it be great

406
00:30:30,420 --> 00:30:35,210
if the large working set you know, when I
go back to it, it's right where I left it.

407
00:30:35,210 --> 00:30:38,850
It's been resident in memory you
know, for hours, for days, for weeks.

408
00:30:38,850 --> 00:30:46,570
Now here's the part though, this is again, it's not just
kind of a touchy feely kind of oh we whatever system thing,

409
00:30:46,570 --> 00:30:49,600
it's very important for your individual
app to do this as well.

410
00:30:49,600 --> 00:30:56,270
Because of that prioritization we saw about apps that
use a lot of memory are much more likely to be chosen

411
00:30:56,270 --> 00:31:03,510
for termination than the ones that use low memory, it's in
the interest of your app to reduce its memory usage as much

412
00:31:03,510 --> 00:31:08,210
as possible when it's in the background, so
that the system decides not to pick your app.

413
00:31:08,210 --> 00:31:13,720
And again this comes back to if your app is terminated,
the next time the user goes back to it, well it relaunches

414
00:31:13,720 --> 00:31:17,960
and depending on how good a job you've done about saving
state you know, maybe you just take them right back

415
00:31:17,960 --> 00:31:21,820
to the home screen, maybe you kind of navigate
them down to the appropriate point in the UI

416
00:31:21,820 --> 00:31:25,190
or back to the beginning of the
level they were on or whatever.

417
00:31:25,190 --> 00:31:27,360
But in any, it would still have to relaunch.

418
00:31:27,360 --> 00:31:30,740
And as opposed to an app that didn't get terminated,

419
00:31:30,740 --> 00:31:33,150
when they go back to it it's going
to be exactly where they left it.

420
00:31:33,150 --> 00:31:37,530
It's going to resume very quickly and it's
going to be exactly where the user left it.

421
00:31:37,530 --> 00:31:39,700
And so you want your app to be in that latter category.

422
00:31:39,700 --> 00:31:46,900
You want the you know, you want it to be the last app on
the system that gets terminated, when the system is looking

423
00:31:46,900 --> 00:31:55,140
for an app to terminate for a low memory condition,
you want your app to be the one it chooses last.

424
00:31:55,140 --> 00:32:01,770
And again, because as we saw in the
priorities, the prioritization is only for apps

425
00:32:01,770 --> 00:32:03,890
that are in the background will get terminated.

426
00:32:03,890 --> 00:32:07,200
You know, you need to take care of the stuff we're
going to talk about, about reducing your memory,

427
00:32:07,200 --> 00:32:10,170
you need to take care of that while your
application is entering the background,

428
00:32:10,170 --> 00:32:13,820
which is in the applicationDidEnterBackground callback.

429
00:32:13,820 --> 00:32:17,000
Now we have a great tool in Instruments.

430
00:32:17,000 --> 00:32:20,370
You might have used Instruments for many things before.

431
00:32:20,370 --> 00:32:25,100
It's a great tool for doing a lot of performance type work.

432
00:32:25,100 --> 00:32:28,250
And you can use it also, there's
this tool, this VM Tracker tool,

433
00:32:28,250 --> 00:32:34,210
which you can use to help you first off determine how
much memory you're using when you're in the background

434
00:32:34,210 --> 00:32:38,920
and then as you're working to reduce it, you can you
know, use this tool kind of to measure your progress.

435
00:32:38,920 --> 00:32:46,090
What you're interested in and I've circled
in yellow here, there's a row marked dirty,

436
00:32:46,090 --> 00:32:47,690
then over on the right there's a dirty size.

437
00:32:47,690 --> 00:32:55,190
In this case it's 6.04MB and that's the number, this
is the dirty memory, so this is basically the number

438
00:32:55,190 --> 00:32:59,640
that the system is going to use, when it's looking
at your app, this is the one that's going to say oh,

439
00:32:59,640 --> 00:33:03,750
he's using that much memory and that's what
it's going to use to prioritize your app.

440
00:33:03,750 --> 00:33:09,520
So, again your goal would be, when you're trying
to reduce your memory usage in the background,

441
00:33:09,520 --> 00:33:11,870
is to drive that number down as low as you can.

442
00:33:11,870 --> 00:33:14,050
But there are some trade-offs which
I'll talk about with that

443
00:33:14,050 --> 00:33:17,870
and let's talk a little bit more
generally first about app memory usage.

444
00:33:17,870 --> 00:33:20,140
This is to say, this is the journal
app which I showed earlier.

445
00:33:20,140 --> 00:33:21,670
It could be any application.

446
00:33:21,670 --> 00:33:25,560
Let's just talk generally about
you know, memory usage in an app.

447
00:33:25,560 --> 00:33:26,650
Well you have some App State.

448
00:33:26,650 --> 00:33:27,830
This is app specific state.

449
00:33:27,830 --> 00:33:32,430
You know in the journal it was
images that were those photos,

450
00:33:32,430 --> 00:33:35,630
the entries themselves, the text
and the titles and what not.

451
00:33:35,630 --> 00:33:43,130
You know and those are probably backed by some kind of
store on disk store, that could be, could be using SQLite

452
00:33:43,130 --> 00:33:49,710
or Core Data, you know there's cache or you might have
you know, flat, I'm just going to call it flat file.

453
00:33:49,710 --> 00:33:53,900
Your own custom file format that
you're using to save this data.

454
00:33:53,900 --> 00:33:56,070
Whatever it is, you have some kind of backing store.

455
00:33:56,070 --> 00:34:01,350
Now for your UI, you have views and
layers and those are backed by a store.

456
00:34:01,350 --> 00:34:04,990
The system in order to render those
graphic, render the UI correctly,

457
00:34:04,990 --> 00:34:08,690
it has its own backing store which
it maintains for your views.

458
00:34:08,690 --> 00:34:12,230
And finally you have some kind of controllers,
view controllers, maybe other kinds of controllers,

459
00:34:12,230 --> 00:34:15,670
which kind of ties it altogether,
ties your model together with your UI.

460
00:34:15,670 --> 00:34:20,420
So that's just kind of an abstract
look at memory usage by an application.

461
00:34:20,420 --> 00:34:24,970
Well, when your application is making
this transition into the background,

462
00:34:24,970 --> 00:34:27,280
the system is going to do some things for you.

463
00:34:27,280 --> 00:34:30,950
You know, because we want to really help you
out, again it's beneficial to the entire system,

464
00:34:30,950 --> 00:34:37,640
it's beneficial to your app, the usability of your app,
the happiness of our users, so the system is going to try

465
00:34:37,640 --> 00:34:40,840
to do what it can for you and it can do some things.

466
00:34:40,840 --> 00:34:45,890
So the system is kind of maintaining this backing graphic
store for you and once you move into the background,

467
00:34:45,890 --> 00:34:50,220
you're not going to have, your UI is not going to be
displayed anymore, so the system is going to go ahead

468
00:34:50,220 --> 00:34:53,970
and free that up for you and that
actually saves quite a bit of memory.

469
00:34:53,970 --> 00:35:00,140
If you have views that are not visible, off screen
or whatever, we're going to free those up as well.

470
00:35:00,140 --> 00:35:00,930
That'll save a little bit.

471
00:35:00,930 --> 00:35:10,680
And if you're using the image named cache, the APIs to
manage your images, we're going to flush that as well.

472
00:35:10,680 --> 00:35:14,630
Although there is still a responsibility, you
have to release those images that you are using

473
00:35:14,630 --> 00:35:17,130
from the image named cache, which
we'll talk about in a second.

474
00:35:17,130 --> 00:35:23,470
You know, if you're using SQLite or Core Data, NSCache,

475
00:35:23,470 --> 00:35:28,530
the way those frameworks are implemented
is efficient in its uses of memory.

476
00:35:28,530 --> 00:35:35,440
They have some caching and so as much as we
can, the system is going to flush those caches,

477
00:35:35,440 --> 00:35:40,440
move that data out of memory and
so free up as much as it can.

478
00:35:40,440 --> 00:35:45,910
That being said, so the system can do some
things for you, it can't do everything of course,

479
00:35:45,910 --> 00:35:50,190
so there's going to be some things that
your app is going to need to do for itself.

480
00:35:50,190 --> 00:35:51,530
As I mentioned earlier, release images.

481
00:35:51,530 --> 00:36:00,190
Whether you're using image named APIs or other
image APIs, images can take a large amount of memory

482
00:36:00,190 --> 00:36:03,900
and so it's important, in most cases, in almost all cases,

483
00:36:03,900 --> 00:36:06,560
for you to release your images when
you're going into the background.

484
00:36:06,560 --> 00:36:14,130
Now if you have your own caches, not necessarily the SQLite
or Core Data caches that are maintaining on your behalf,

485
00:36:14,130 --> 00:36:20,550
if you cache some stuff yourself, from your own
file, it's good to flush these caches and again,

486
00:36:20,550 --> 00:36:25,770
there's a little bit of a trade-off here in that you
know, if your caches are very expensive to create

487
00:36:25,770 --> 00:36:31,950
and the reason you have those caches is because they're
very expensive and you don't and if you flush them,

488
00:36:31,950 --> 00:36:36,530
then when the app comes back to the foreground,
you're going to have to regenerate them all again.

489
00:36:36,530 --> 00:36:37,790
Well so here's the trade-off you know.

490
00:36:37,790 --> 00:36:41,300
How much memory are you going to save versus
how long is it going to take on resume

491
00:36:41,300 --> 00:36:44,630
to regenerate this data and that's,
that's an app by app call.

492
00:36:44,630 --> 00:36:46,580
But it's something you should at least consider.

493
00:36:46,580 --> 00:36:52,340
And the other things is, for this flat
file, if your backing store is a flat file,

494
00:36:52,340 --> 00:36:58,460
not using some of these other technologies, you should
consider instead of saying f open it or opening it

495
00:36:58,460 --> 00:37:04,150
and reading the whole thing into your, into your
app's address space and using it and you know,

496
00:37:04,150 --> 00:37:07,340
when you modify things or save
state you write the whole thing out.

497
00:37:07,340 --> 00:37:15,510
That can be much less efficient than using some of the
memory mapping technologies through the mmap family of APIs.

498
00:37:15,510 --> 00:37:22,580
So especially if you're doing a lot of read
only access, but even if you're writing,

499
00:37:22,580 --> 00:37:27,790
the system can be much more intelligent about which
parts of your flat file are moved into memory,

500
00:37:27,790 --> 00:37:33,620
it can move some parts you know, back out of memory as
necessary, without requiring termination of your app.

501
00:37:33,620 --> 00:37:40,140
So again, something to consider if using a custom file
format as your backing store for your application state,

502
00:37:40,140 --> 00:37:44,330
you know to consider if memory
mapping would be appropriate for that.

503
00:37:44,330 --> 00:37:47,540
Because there are some benefits that
the system can provide for that.

504
00:37:47,540 --> 00:37:56,920
So I mentioned a couple times about
trade-offs and other, so there's trade-offs

505
00:37:56,920 --> 00:37:59,210
and there's other small memory usages in your application.

506
00:37:59,210 --> 00:38:02,430
So a trade-off, we haven't mentioned view controllers yet.

507
00:38:02,430 --> 00:38:05,290
Now view controllers are typically
not that large in memory usage.

508
00:38:05,290 --> 00:38:07,690
I mean often you hang a lot of
things off the view controller,

509
00:38:07,690 --> 00:38:10,770
some of your model data and some
other data that can be large.

510
00:38:10,770 --> 00:38:12,270
That we just talked about.

511
00:38:12,270 --> 00:38:14,810
View controllers themselves are typically not that large.

512
00:38:14,810 --> 00:38:17,070
So you typically don't want to
release your view controllers.

513
00:38:17,070 --> 00:38:22,250
If for no other reason than it can be kind of tricky
to maybe reconstruct them correctly and everything.

514
00:38:22,250 --> 00:38:24,530
So typically you wouldn't need to release those.

515
00:38:24,530 --> 00:38:31,130
And you might have some other state in your app, where
there's a trade-off versus, that I mentioned earlier

516
00:38:31,130 --> 00:38:33,500
about memory savings versus time to recreate.

517
00:38:33,500 --> 00:38:46,450
And for this trade-off, for those things,
unfortunately we can't give you a 100% correct answer

518
00:38:46,450 --> 00:38:51,360
of what you should do there, although we're going to have
some suggestions in just a few minutes for some technique

519
00:38:51,360 --> 00:38:53,810
that might work, that might help you in a few cases.

520
00:38:53,810 --> 00:38:57,530
But before we get to that, I wanted
to talk about preparing your UI.

521
00:38:57,530 --> 00:39:01,800
So this is another responsibility you
have when you're entering the background.

522
00:39:01,800 --> 00:39:07,990
So, so again, you're going into the background,
your UI is not going to visible anymore,

523
00:39:07,990 --> 00:39:10,970
so what things do you need to do to prepare your app?

524
00:39:10,970 --> 00:39:16,310
Well you might want to pause your app and even
today, you do this if you have a game especially.

525
00:39:16,310 --> 00:39:20,140
It makes sense if the SMS comes
in or an incoming call you know,

526
00:39:20,140 --> 00:39:24,780
it's very polite to the user, to pause your application.

527
00:39:24,780 --> 00:39:31,130
And you typically do this in the applicationDidResignActive
callback and this continues in IOS 4 you still want to,

528
00:39:31,130 --> 00:39:37,000
if you use alerts and action sheets in your app
and your app is and the user hits the Home button

529
00:39:37,000 --> 00:39:42,310
to send your application to the background,
if one of those action sheets or alerts is up,

530
00:39:42,310 --> 00:39:47,030
you need to think about whether it makes sense to
leave it up or to kind of cancel it and take it down.

531
00:39:47,030 --> 00:39:51,940
So say in my journal app, I had a way for you
to delete an entry and when you said Delete,

532
00:39:51,940 --> 00:39:57,430
I pop up an action sheet and you
know say, are you sure, yes, no.

533
00:39:57,430 --> 00:40:05,130
Well, if the user did that and then left the app, hit the
Home button and came back a week later and the app popped up

534
00:40:05,130 --> 00:40:10,470
and all he saw was this dialog which said are you sure,
yes, no and that wouldn't be the best user experience.

535
00:40:10,470 --> 00:40:15,030
I mean the worse case they could actually oh, yes I'm
sure and then they delete something they don't know.

536
00:40:15,030 --> 00:40:19,880
So in that case it would make sense probably for
that app to, when you're entering the background,

537
00:40:19,880 --> 00:40:23,080
to just dismiss that programmatically,
as if they had hit no.

538
00:40:23,080 --> 00:40:26,730
And when they come back to the app, if they
have to reselect the entry and hit Delete again,

539
00:40:26,730 --> 00:40:29,690
that's a much better user experience
than just having this alert box.

540
00:40:29,690 --> 00:40:31,570
So that's something to keep aware of.

541
00:40:31,570 --> 00:40:35,250
And finally, the system is going to
automatically take a screenshot of your app.

542
00:40:35,250 --> 00:40:41,390
When your application returns from
applicationDidEnterBackground,

543
00:40:41,390 --> 00:40:47,360
the system is going to take a screenshot and it's going to
use that screenshot when it's animating back into your app.

544
00:40:47,360 --> 00:40:52,040
And so if you have sensitive information on
there or some kind of animations or something,

545
00:40:52,040 --> 00:40:57,340
some kind of UI that you don't want to be visible
during that animation, then this is your chance

546
00:40:57,340 --> 00:41:03,280
and this is the time to update
your UI so it doesn't show that.

547
00:41:03,280 --> 00:41:10,790
OK, now there's three responsibilities which I have grouped
together, which we'll go through now about networking

548
00:41:10,790 --> 00:41:13,730
in Bonjour and some other system resources.

549
00:41:13,730 --> 00:41:19,110
So if you're using listening sockets in your app, so you're
opening up a listening socket system, external server

550
00:41:19,110 --> 00:41:25,020
or another device can connect to your application,
to get access maybe to some service you're providing,

551
00:41:25,020 --> 00:41:32,480
well you have to be aware that if your application is
you know, in the suspended state in the background,

552
00:41:32,480 --> 00:41:34,860
it's not going to be able to respond
to those connection attempts.

553
00:41:34,860 --> 00:41:38,320
So you know, this external server or whatever
might connect, might try to communicate

554
00:41:38,320 --> 00:41:41,230
with your application, well your app can't communicate.

555
00:41:41,230 --> 00:41:42,910
And so that's a bad user experience.

556
00:41:42,910 --> 00:41:48,330
Who knows what the server is going to do when
it gets to this situation and so it's best just

557
00:41:48,330 --> 00:41:53,970
to close those listening sockets as your
application, before your application is suspended.

558
00:41:53,970 --> 00:41:56,080
And if you're a fast app switching application,

559
00:41:56,080 --> 00:42:01,940
again your last chance before your application is
suspended is when you're entering the background.

560
00:42:01,940 --> 00:42:06,890
And of course, then if you, when the
user brings your application back

561
00:42:06,890 --> 00:42:11,330
to the foreground, you can restore that listening socket.

562
00:42:11,330 --> 00:42:13,360
Re-open it.

563
00:42:13,360 --> 00:42:19,690
Now Bonjour, if your application is using Bonjour,
to either advertise a service or to browse

564
00:42:19,690 --> 00:42:23,650
for a service, so there are two things with Bonjour.

565
00:42:23,650 --> 00:42:26,060
One is the first is similar to the listening sockets.

566
00:42:26,060 --> 00:42:32,800
If you're advertising a service and then your
app is suspended and someone, some you know,

567
00:42:32,800 --> 00:42:37,390
someone external sees oh, this device is
advertising a service, I'm going to connect to it

568
00:42:37,390 --> 00:42:39,430
and try to you know, connect to that service.

569
00:42:39,430 --> 00:42:45,260
Well, they make the connection, but they're not going
to be able to communicate with your application.

570
00:42:45,260 --> 00:42:51,130
And so that's a bad user experience and what's more,
especially in the case of browsing for a service,

571
00:42:51,130 --> 00:42:54,190
if you leave your application browsing
for a service when it's suspended,

572
00:42:54,190 --> 00:42:59,420
that's going to be using a lot of
power on the device, for no benefit.

573
00:42:59,420 --> 00:43:04,090
Because since your application is
suspended, even if it discovers some service

574
00:43:04,090 --> 00:43:05,880
out there, it can't take advantage of that.

575
00:43:05,880 --> 00:43:07,620
It's not allowed to execute any code.

576
00:43:07,620 --> 00:43:14,850
And so because of these two usability and battery
life problems with Bonjour and suspended apps,

577
00:43:14,850 --> 00:43:24,100
the system can choose to cancel those Bonjour, either
your publish or your browse, while the app is suspended.

578
00:43:24,100 --> 00:43:27,660
And so what does that mean for you if you're using Bonjour?

579
00:43:27,660 --> 00:43:32,560
Well, when your app resumes, you need
to be prepared for errors on Bonjour,

580
00:43:32,560 --> 00:43:37,640
because those operations might have been
canceled by the system while it was suspended.

581
00:43:37,640 --> 00:43:41,660
And that may mean you need to restart your
Bonjour, you might need to update the UI,

582
00:43:41,660 --> 00:43:47,970
if you were showing something Bonjour related in your UI,
now you might need to update that as part of your resume.

583
00:43:47,970 --> 00:43:48,810
You'll see there's a reference.

584
00:43:48,810 --> 00:43:54,030
There's a couple talks for networking in Bonjour, that
we have references to at the end of the presentation

585
00:43:54,030 --> 00:44:00,260
that they're going to talk more about these interactions
between multitasking and networking in Bonjour.

586
00:44:00,260 --> 00:44:04,820
OK, so another big one, another big thing you need to
be aware of when your application is in the background,

587
00:44:04,820 --> 00:44:09,190
either background running or background
suspended is, don't use the GPU.

588
00:44:09,190 --> 00:44:10,340
So it's off limits.

589
00:44:10,340 --> 00:44:16,960
So for instance, if you do something like create
an EAGL context or you just issue OpenGL commands,

590
00:44:16,960 --> 00:44:20,340
the system is going to be required to terminate.

591
00:44:20,340 --> 00:44:24,660
Is going to terminate your application.

592
00:44:24,660 --> 00:44:28,260
The GL, the GPU was reserved for the
use of the foreground application.

593
00:44:28,260 --> 00:44:32,180
Again this is something we did with multitasking to ensure

594
00:44:32,180 --> 00:44:39,310
that that front application remains
responsible, responsive and usable for the user.

595
00:44:39,310 --> 00:44:46,860
And again, it's enforced in the background running state
and again, the natural thing, the easiest way to do this

596
00:44:46,860 --> 00:44:49,360
and the way you should take care of this
is when you're entering the background,

597
00:44:49,360 --> 00:44:52,390
you're going to need to stop your GPU usage.

598
00:44:52,390 --> 00:44:56,200
And generally need to stop drawing
altogether, stop using OpenGL altogether.

599
00:44:56,200 --> 00:45:02,550
And the last of these kind or another of these
little responsibilities is shared system data.

600
00:45:02,550 --> 00:45:10,420
So this is another case where the system will unfortunately
be required to terminate your application when it's

601
00:45:10,420 --> 00:45:16,590
in the background, in this case when it's in background
suspended or when it enters background suspended,

602
00:45:16,590 --> 00:45:20,100
if it's holding exclusive access to some shared system data.

603
00:45:20,100 --> 00:45:24,020
So what do I mean by shared?

604
00:45:24,020 --> 00:45:25,190
What's shared system data?

605
00:45:25,190 --> 00:45:31,360
Well we have a number of APIs that allow you to access
Calendar, Address Book, music and media libraries.

606
00:45:31,360 --> 00:45:36,660
Those are all, all those APIs are basically
wrapping access to some shared system data.

607
00:45:36,660 --> 00:45:41,830
You know, your address book, your contacts are
shared, any app on the system can access those.

608
00:45:41,830 --> 00:45:47,620
And so the system can't allow a suspended app to hold
exclusive access to any of those or else you know,

609
00:45:47,620 --> 00:45:49,980
some other apps wouldn't be able to use that resource.

610
00:45:49,980 --> 00:45:55,250
And so it enforces this again, as your
application is entering the suspended state,

611
00:45:55,250 --> 00:45:57,680
it enforces this by terminating your application.

612
00:45:57,680 --> 00:45:59,520
And once again, our old friend,

613
00:45:59,520 --> 00:46:03,750
applicationDidEnterBackground is
the place to take care of this.

614
00:46:03,750 --> 00:46:06,240
OK, so now let's talk quickly about some on resume.

615
00:46:06,240 --> 00:46:09,440
When your app comes back to the foreground.

616
00:46:09,440 --> 00:46:12,010
Well it's kind of the converse of what we talked about.

617
00:46:12,010 --> 00:46:14,120
The system is going to take care of some things.

618
00:46:14,120 --> 00:46:18,580
The things that it kind of freed for you or flushed
for you, it's going to restore them for you.

619
00:46:18,580 --> 00:46:21,440
The backing store, you know, it's going to
recognize that your app is coming to the front,

620
00:46:21,440 --> 00:46:25,150
you're going to need to draw your UI, it's
going to restore that backing store for you.

621
00:46:25,150 --> 00:46:32,730
If you're using image named, that cache is going to
repopulate as you create images, as you request images.

622
00:46:32,730 --> 00:46:37,280
If you're using these other technologies, some of
these other technologies, SQLite, Core Data, NSCache,

623
00:46:37,280 --> 00:46:41,010
those are restored as needed, on demand,
as necessary the information will be pulled

624
00:46:41,010 --> 00:46:44,400
from your backing store into your application's memory.

625
00:46:44,400 --> 00:46:50,380
Same thing if you're using a flat file, but if you're
memory mapping it again, the system as you access that file,

626
00:46:50,380 --> 00:46:57,000
read and write it, it will move the, it will move the
data as necessary from the backing file into memory.

627
00:46:57,000 --> 00:46:59,250
So again, those are some things we give you for free.

628
00:46:59,250 --> 00:47:02,560
Some things you need to do on restore.

629
00:47:02,560 --> 00:47:06,840
Unfortunately, you know, we can't give you
just oh, here's the right way to do it.

630
00:47:06,840 --> 00:47:09,560
Always do x, y, z, you'll be fine restoring.

631
00:47:09,560 --> 00:47:14,040
It's very dependent upon what your application
data is, what your application state looks like.

632
00:47:14,040 --> 00:47:19,700
So again, it's this trade-off between the memory
size you'll save by freeing up your application state

633
00:47:19,700 --> 00:47:23,840
and the time it will take when your
application resumes to restore all that.

634
00:47:23,840 --> 00:47:30,770
But one quick thing we'll show you and many
of you, you know, will be familiar with this,

635
00:47:30,770 --> 00:47:34,010
is to do what the system was doing
for you in some of those cases.

636
00:47:34,010 --> 00:47:35,600
So basically, lazy.

637
00:47:35,600 --> 00:47:37,830
It's a lazy restore of your data.

638
00:47:37,830 --> 00:47:44,340
If you use a lazy kind of implementation for at least some
of your data, it might not make sense for all your data,

639
00:47:44,340 --> 00:47:48,560
but for some of your data, this will allow you to
basically release objects when you go into the background

640
00:47:48,560 --> 00:47:53,060
and free up that memory and then when you resume you
don't have to do anything explicit at resume time like oh,

641
00:47:53,060 --> 00:47:55,390
I need to regenerate this data and that data and that data.

642
00:47:55,390 --> 00:47:57,100
I hope I didn't forget anything.

643
00:47:57,100 --> 00:48:02,490
But just on demand, as that data is needed,
it'll be resumed, you can restore it.

644
00:48:02,490 --> 00:48:05,960
So here's a very simple example of lazy state restore.

645
00:48:05,960 --> 00:48:14,240
I have my application state, I'm just, it's an array of
these my data types and when I want to access one of these,

646
00:48:14,240 --> 00:48:19,520
instead of just indexing directly into the array saying
grabbing it, I use this simple accessor function which,

647
00:48:19,520 --> 00:48:24,110
first check to see whether it's been initialized,
if it hasn't it goes out to my backing store,

648
00:48:24,110 --> 00:48:27,660
which I have wrapped with that data
controller here and just initializes my

649
00:48:27,660 --> 00:48:31,270
in memory representation of that object and returns that.

650
00:48:31,270 --> 00:48:37,430
So that's done, so now when I want to access
some data, I don't' need to, I just access it.

651
00:48:37,430 --> 00:48:40,080
The first time I access it, it'll get restored.

652
00:48:40,080 --> 00:48:45,730
For instance, it's not there and so when I
go into the background, I just, I can release

653
00:48:45,730 --> 00:48:48,340
and free them all up and free up all that memory.

654
00:48:48,340 --> 00:48:53,710
And so again, for some of your applications state, this
will make sense and for some it won't and just on a case

655
00:48:53,710 --> 00:48:56,960
by case basis, it's just another
tool that you can potentially use.

656
00:48:56,960 --> 00:48:58,520
So system changes.

657
00:48:58,520 --> 00:49:06,210
So, so when your application is suspended
you know, the whole world doesn't stop.

658
00:49:06,210 --> 00:49:10,310
Things are going on all around your device.

659
00:49:10,310 --> 00:49:15,450
The networking is changing you
know, your locale might change,

660
00:49:15,450 --> 00:49:18,190
other changes might happen, the user might change settings.

661
00:49:18,190 --> 00:49:23,350
And so when your app, what the system does for you,
while your app is suspended, it's going to collect these,

662
00:49:23,350 --> 00:49:28,020
it's not going to throw them away so that you're like
unaware, but it's going to collect them and coalesce them.

663
00:49:28,020 --> 00:49:34,350
Your application is completely suspended so it can't, it
doesn't receive those notifications while it's suspended,

664
00:49:34,350 --> 00:49:37,200
but when your application resumes all those notifications,

665
00:49:37,200 --> 00:49:40,440
those system change notifications,
will be delivered to the application.

666
00:49:40,440 --> 00:49:46,720
And so your application must be prepared to
handle this burst of notifications coming in.

667
00:49:46,720 --> 00:49:50,330
And so you want to make sure that whatever code
you have that deals with these notifications,

668
00:49:50,330 --> 00:49:55,490
that it's not going to take too long to execute,
because that could delay the resuming of your app.

669
00:49:55,490 --> 00:49:57,700
It could make the app seem sluggish when it resumes.

670
00:49:57,700 --> 00:50:02,940
It can make your UI flash and rapidly update as
it responds to all these notification changes.

671
00:50:02,940 --> 00:50:08,910
And a great technology, I'm not sure if the talk has already
happened, if it has you can see it on video or check your,

672
00:50:08,910 --> 00:50:13,600
the schedule, is the Grand Central Dispatch and Blocks Talk.

673
00:50:13,600 --> 00:50:18,840
That's a great way to move work off the main thread
and it might help you in, to handle this situation.

674
00:50:18,840 --> 00:50:22,410
And so, this is a little bit of an eye
chart, but these are basically all,

675
00:50:22,410 --> 00:50:24,140
you can look in the documentation and see all these.

676
00:50:24,140 --> 00:50:25,310
These are all documents.

677
00:50:25,310 --> 00:50:28,830
These are basically all the types of
changes that can concur while your system,

678
00:50:28,830 --> 00:50:31,720
while your app is suspended and
that you'll need to deal with.

679
00:50:31,720 --> 00:50:35,580
So last I want to talk about, very
quickly, is network connections.

680
00:50:35,580 --> 00:50:39,600
Network connections while your app is suspended,
this is kind of like the system change notifications,

681
00:50:39,600 --> 00:50:42,200
you can lose your network connections for a lot of reasons.

682
00:50:42,200 --> 00:50:47,360
You know, the network conditions can change, your
location can change, all sorts of things can happen.

683
00:50:47,360 --> 00:50:54,750
So this could even happen today of course, with your app
when the say the device is locked and sleeping, when you're,

684
00:50:54,750 --> 00:50:57,400
but it's much more likely to happen
when your app is suspended.

685
00:50:57,400 --> 00:51:04,480
So when your app is resumed, you need to be ready, on all
your network connections, you need to be ready for errors.

686
00:51:04,480 --> 00:51:07,990
You know, because those connections could be lost
and you need to handle those errors correctly.

687
00:51:07,990 --> 00:51:10,360
Don't ignore the errors.

688
00:51:10,360 --> 00:51:11,990
And you know, you have to take the right action.

689
00:51:11,990 --> 00:51:18,900
Often it will just mean oh, you know, I lost my
connection to the server so I just need to you know,

690
00:51:18,900 --> 00:51:21,720
close that one down and just reestablish connection.

691
00:51:21,720 --> 00:51:22,550
It's often that easy.

692
00:51:22,550 --> 00:51:28,320
But it's definitely something you need to test for
and be aware of in this multitasking environment.

693
00:51:28,320 --> 00:51:29,460
Now here's a quick code example.

694
00:51:29,460 --> 00:51:33,950
This is not meant to be like a template which
for every application you would put in there

695
00:51:33,950 --> 00:51:37,280
and it would be the exact way that you would
want to do your applicationDidEnterBackground,

696
00:51:37,280 --> 00:51:39,840
where a lot of these responsibilities are implemented.

697
00:51:39,840 --> 00:51:44,580
It's just kind of give you the idea that you know,
you're going to have a lot of things that you need to do

698
00:51:44,580 --> 00:51:48,090
or several things that we talk about
that you need to do here, save state,

699
00:51:48,090 --> 00:51:52,770
reduce your memory usage, prepare your UI if appropriate.

700
00:51:52,770 --> 00:51:58,690
Maybe if you're using some listening sockets
or what not, you might want to close them down.

701
00:51:58,690 --> 00:52:01,730
And on the resume side there's
a shorter list because let's say

702
00:52:01,730 --> 00:52:07,880
for example we're using this lazy state restore technique
and so actually you don't need to do anything for state.

703
00:52:07,880 --> 00:52:12,530
Again that's not going to necessarily solve
everyone's problem but it's something to keep in mind.

704
00:52:12,530 --> 00:52:16,440
And again, in the earlier example, I closed
the listening socket when I was going

705
00:52:16,440 --> 00:52:19,120
to background, so I want to open it back up again.

706
00:52:19,120 --> 00:52:25,680
And so now that's kind of, that was the responsibilities and
best practices and now I'm going to turn it back to Dave,

707
00:52:25,680 --> 00:52:29,610
who's going to talk a little bit about the
multitasking and development tools that you can use

708
00:52:29,610 --> 00:52:31,540
to help with your multitasking development.

709
00:52:31,540 --> 00:52:32,370
>> David Myszewski: Thanks

710
00:52:32,370 --> 00:52:38,220
[ applause ]

711
00:52:38,220 --> 00:52:43,540
So as part of multitasking, we've enhanced some of
our development tools that will help you introspect

712
00:52:43,540 --> 00:52:49,910
to the feature, the states of your application and
figure out what's going on at any given point in time.

713
00:52:49,910 --> 00:52:55,810
One key tool that we provide is Instruments and Instruments
provides this nice timeline view, things like memory usage

714
00:52:55,810 --> 00:52:59,620
and CPU usage over time and one of the
great new features of Instruments is

715
00:52:59,620 --> 00:53:03,070
that your application lifecycle events are flagged.

716
00:53:03,070 --> 00:53:09,810
So if I am sitting here running stocks and I hit
the Home button, then Instruments will flag the fact

717
00:53:09,810 --> 00:53:15,240
that the application for a short period of time went
to the background running state and then it cleaned up,

718
00:53:15,240 --> 00:53:18,110
it saved state, paused UI, things like that.

719
00:53:18,110 --> 00:53:21,300
And then the application was suspended.

720
00:53:21,300 --> 00:53:26,270
Then maybe later on the user might hit your application icon

721
00:53:26,270 --> 00:53:30,180
and then Instruments will show that
your application is running again.

722
00:53:30,180 --> 00:53:33,830
The two states that are going to background
running and to background suspended,

723
00:53:33,830 --> 00:53:37,110
you may want to watch your memory
usage between those two states.

724
00:53:37,110 --> 00:53:42,210
Because that's where you'd be freeing up all your memory
and so you can use something like the object outlook tool

725
00:53:42,210 --> 00:53:45,070
to see just how much memory you
freed during that time period.

726
00:53:45,070 --> 00:53:50,140
So Instruments provides a nice want to integrate with your
apps so that you can see what it's doing in these states.

727
00:53:50,140 --> 00:53:54,860
You know, maybe you have a function call that
was too expensive or maybe you have some memory

728
00:53:54,860 --> 00:53:59,200
that you think we should really release, then
Instruments will allow you to see exactly what's going

729
00:53:59,200 --> 00:54:04,560
on in your application, as the user
transitions between states in your app.

730
00:54:04,560 --> 00:54:06,590
A few notes about the simulator.

731
00:54:06,590 --> 00:54:10,890
Much like we say in other talks, the simulator
is not a complete replacement for the device.

732
00:54:10,890 --> 00:54:15,560
It's always important when you write your applications,
to test them fully on the device because that's

733
00:54:15,560 --> 00:54:19,560
where everything will be exactly how the customer sees it.

734
00:54:19,560 --> 00:54:24,750
We integrate most of our multitasking, most of the
multitasking features that you as developers will need

735
00:54:24,750 --> 00:54:30,610
into the simulator, so fast app switching is fully
supported, task completion, local modifications

736
00:54:30,610 --> 00:54:36,150
and if you want to test any sort of integration with your
multitasking UI, you can all do that in the simulator.

737
00:54:36,150 --> 00:54:41,410
But there are a few things that we don't provide
for multitasking, in particular background audio,

738
00:54:41,410 --> 00:54:46,840
location and VoIP services and the significant
location changes, aren't provided in the simulator.

739
00:54:46,840 --> 00:54:51,950
Your Mac doesn't have a GPS chip, so can't
provide that and of course, push notifications,

740
00:54:51,950 --> 00:54:56,140
much like in iPhone OS 3, still
aren't supported in the simulator.

741
00:54:56,140 --> 00:55:00,850
But for most of the work that most of you will be
doing, the simulator is a great environment for testing

742
00:55:00,850 --> 00:55:04,060
out multitasking, just make sure
that you try it on the device.

743
00:55:04,060 --> 00:55:09,660
Then the debugger changes just a couple of
things about how your application behaves,

744
00:55:09,660 --> 00:55:14,830
so that you as developers, can
better debug your applications.

745
00:55:14,830 --> 00:55:19,860
So, it is important to test your app outside
of the debugger, not just in the debugger.

746
00:55:19,860 --> 00:55:21,220
So what are the changes?

747
00:55:21,220 --> 00:55:27,180
Well those new applicationDelegate callbacks, we only
have a few seconds to get through those callbacks

748
00:55:27,180 --> 00:55:31,710
and let's say you have a problem in one of those
callbacks, it may be a bug or maybe you want

749
00:55:31,710 --> 00:55:33,750
to see well why am I not freeing up memory.

750
00:55:33,750 --> 00:55:38,330
Well it would be really unfortunate if we
only gave you six seconds to debug your app.

751
00:55:38,330 --> 00:55:42,220
That's you know, I'm sure you're a fantastic
developer, so are we, but six seconds isn't long enough.

752
00:55:42,220 --> 00:55:46,160
So it's probably not long enough for anybody.

753
00:55:46,160 --> 00:55:50,500
So we don't enforce the time limits there and
in the test completion expiration handler,

754
00:55:50,500 --> 00:55:54,580
which you'll hear more about in the second
talk, we also don't have any sort of time limit.

755
00:55:54,580 --> 00:56:00,690
So the debugger resumes or allows you to
debug your apps a lot more effectively,

756
00:56:00,690 --> 00:56:03,470
but that means you need to test
things on the device as well.

757
00:56:03,470 --> 00:56:10,790
So to conclude, we went over a bunch of the best, the
behaviors that you want to implement for fast app switching,

758
00:56:10,790 --> 00:56:15,730
the API that you need to adopt and these are
APIs that every application should be adopting.

759
00:56:15,730 --> 00:56:20,020
You'll want to do it regardless of whether or not you're
the type of application that doesn't need to execute code

760
00:56:20,020 --> 00:56:23,870
in the background and just needs to be there
so that the user can quickly resume to it

761
00:56:23,870 --> 00:56:26,220
or if you're an application that runs in the background.

762
00:56:26,220 --> 00:56:30,780
You still want to do all of these things that we
mentioned in the talk, like reduce memory usage.

763
00:56:30,780 --> 00:56:36,920
All applications on the store can benefit from fast
app switching because you can resume really quickly,

764
00:56:36,920 --> 00:56:42,900
we can preserve your state and we have you know,
great integration with the multitasking UI.

765
00:56:42,900 --> 00:56:49,390
But we have those other services that allow you
to execute code in the background and do things

766
00:56:49,390 --> 00:56:52,710
that you couldn't have done before
and for that we have the second talk

767
00:56:52,710 --> 00:56:57,200
which will describe those services,
in a lot of detail, this afternoon.

768
00:56:57,200 --> 00:57:01,720
So that's in the Mission at 3:15.

769
00:57:01,720 --> 00:57:04,920
We also have a few other different
talks that might be interesting.

770
00:57:04,920 --> 00:57:09,390
Various tools, learning how to, what some
of the new features and instruments are

771
00:57:09,390 --> 00:57:12,300
so that you can intersect your app even more.

772
00:57:12,300 --> 00:57:17,690
Blocks and Grand Central Dispatch, which
David mentioned, to free up your UI.

773
00:57:17,690 --> 00:57:22,740
Simplifying networking and another networking
talk that will tell you a little bit more detail

774
00:57:22,740 --> 00:57:25,540
about how to handle various network conditions.

775
00:57:25,540 --> 00:57:30,850
So thanks for coming.

