1
00:00:07,390 --> 00:00:07,960
>> John Wright: Hello, everyone.

2
00:00:07,960 --> 00:00:09,920
My name is John Wright.

3
00:00:09,920 --> 00:00:13,920
I'm part of Platform Technologies in Core OS.

4
00:00:13,920 --> 00:00:18,850
We're responsible for a lot of the
security infrastructure in iOS.

5
00:00:18,850 --> 00:00:25,840
And today, we're going to talk about-- a
little bit about protecting data on the phone.

6
00:00:25,840 --> 00:00:28,160
So we're going to go over-- this is our agenda.

7
00:00:28,160 --> 00:00:32,750
So first, I'm going to talk a little bit about what data
protection is and what security mechanisms we have in place

8
00:00:32,750 --> 00:00:36,160
in iOS and kind of how they've
evolved over the different releases.

9
00:00:36,160 --> 00:00:43,620
And then we're going to kind of do a deep dive
into the design of our data protection mechanisms,

10
00:00:43,620 --> 00:00:46,080
and this is more for your security analysis.

11
00:00:46,080 --> 00:00:49,310
This is not something that you actually need to know.

12
00:00:49,310 --> 00:00:50,860
It's all done under the covers.

13
00:00:50,860 --> 00:00:59,060
But I think a lot of you that are kind of in the
trust-but-verify hats, really want to know this information.

14
00:00:59,060 --> 00:01:05,870
Then we're going to talk a little bit about enabling
data protection, both from a user standpoint

15
00:01:05,870 --> 00:01:10,230
and from an enterprised standpoint of managing a device.

16
00:01:10,230 --> 00:01:14,210
And then we're going to talk a
little bit about the API's that you--

17
00:01:14,210 --> 00:01:24,380
that we want you to adopt in your applications to be
in data protection and how to protect your user's data.

18
00:01:24,380 --> 00:01:32,320
So these devices that we have, these phones and iPads
and iPod touches, they're very personal devices,

19
00:01:32,320 --> 00:01:39,690
and they have a lot of-- more data on them than we've
ever had before ringing around people's pockets.

20
00:01:39,690 --> 00:01:44,860
And one of the things that is kind of
a challenge here is that them being

21
00:01:44,860 --> 00:01:49,150
so mobile also means they're more easily stolen by someone.

22
00:01:49,150 --> 00:01:51,120
And you have a lot of different data on here.

23
00:01:51,120 --> 00:01:57,790
You have all your messages from your messaging systems,
you have your accounts for those social networks,

24
00:01:57,790 --> 00:02:04,240
you might have accounts for financial information,
and you might have even enterprised apps

25
00:02:04,240 --> 00:02:08,460
that you're actually responsible for
protecting your company's information.

26
00:02:08,460 --> 00:02:16,360
So this has become very, very important, being able to
protect this data, especially in a mobile environment.

27
00:02:17,450 --> 00:02:26,730
So what we introduced last year on iPhone
3GS was all the data was encrypted in place.

28
00:02:26,730 --> 00:02:34,010
Now, we actually added special hardware to these
devices that would have no performance impact.

29
00:02:34,010 --> 00:02:38,340
Basically, it's you know, hardware encryption
engines in the hardware that would do it

30
00:02:38,340 --> 00:02:41,510
for no performance, no battery life impact whatsoever.

31
00:02:41,510 --> 00:02:49,390
Now, the big reason that we did this was we
want a really fast experience of Remote Wiping.

32
00:02:49,390 --> 00:02:54,880
So Remote Wipe is that you can send a signal to
the phone as long as that phone is still online

33
00:02:54,880 --> 00:02:57,030
that it will erase all that customer's data.

34
00:02:57,030 --> 00:03:00,120
So you can do this from, you know, if the device is lost.

35
00:03:00,120 --> 00:03:02,890
And we wanted that to be very, very fast.

36
00:03:02,890 --> 00:03:08,930
And if you encrypt all the data, you can
just throw away the keys, makes it very fast.

37
00:03:08,930 --> 00:03:14,200
Now, it also has this concept of
protecting the data at rest.

38
00:03:14,200 --> 00:03:20,590
Now, this is kind of a concept that evolved from desktops.

39
00:03:20,590 --> 00:03:28,340
And the idea on desktops is that a lot of desktops, you
can image your data and move it to somewhere else to try

40
00:03:28,340 --> 00:03:32,730
to compromise, or someone can steal a hard drive out of it.

41
00:03:32,730 --> 00:03:34,980
Now, this doesn't really apply
to a lot of these mobile devices.

42
00:03:34,980 --> 00:03:42,230
So it makes-- if you have that device, it makes
that device still very vulnerable to a local attack.

43
00:03:42,230 --> 00:03:49,610
Now, the other thing that we added
last year was encrypted backups.

44
00:03:49,610 --> 00:03:54,940
And this means that the data is protected when it is
off the device and being backed up to a host machine.

45
00:03:54,940 --> 00:04:00,630
So what we're introducing for iOS 4.

46
00:04:00,630 --> 00:04:03,860
We have this goal to keep the data
safe even if the device is compromised.

47
00:04:03,860 --> 00:04:10,240
So what we did is we added the ability to tie
the encrypted data to the user's passcode.

48
00:04:10,240 --> 00:04:15,250
So this means that it's actually something that
the user knows themselves that unlocks that data,

49
00:04:15,250 --> 00:04:20,520
so that data is only available when the device is unlocked.

50
00:04:20,520 --> 00:04:26,170
Now, we added API's in so you can choose data
availability, whether it's only available

51
00:04:26,170 --> 00:04:29,370
when the device is unlocked, or it's available all the time.

52
00:04:29,370 --> 00:04:34,470
And we went about adopting this in iOS 4 in
mail, which is by far, the most complicated app

53
00:04:34,470 --> 00:04:38,150
and does the most complicated background activity.

54
00:04:38,150 --> 00:04:45,890
And we're making those API's available for you to adopt in
your apps, so you can tie into the same security mechanism.

55
00:04:45,890 --> 00:04:53,160
And I want to emphasize here again, there's absolutely no
performance impact to this because we're doing this all

56
00:04:53,160 --> 00:04:55,820
in the hardware engine itself,
and it's all just streamlining

57
00:04:55,820 --> 00:04:58,090
with how the data reads and writes out of the hardware.

58
00:04:58,090 --> 00:05:02,130
Now, I also want to mention that we
still had to enable encrypted backups,

59
00:05:02,130 --> 00:05:05,560
and we actually had retool all
of our infrastructure to do this.

60
00:05:05,560 --> 00:05:08,290
But we got one big benefit.

61
00:05:08,290 --> 00:05:13,960
We now can allow the key chain to be migrated
between devices if they are in an encrypted backup.

62
00:05:13,960 --> 00:05:21,290
So this was kind the last kind of excuse not to use
the Keychain is that your credentials wouldn't move

63
00:05:21,290 --> 00:05:23,530
from device to device when your users upgrade.

64
00:05:23,530 --> 00:05:24,700
Well, now they do.

65
00:05:24,700 --> 00:05:28,000
In an encrypted back-up scheme, they just move right across.

66
00:05:28,000 --> 00:05:33,400
So passcodes, we are tying this to the passcodes.

67
00:05:33,400 --> 00:05:38,760
But I want to remind everyone that the passcode
is only as good as you make the passcode.

68
00:05:38,760 --> 00:05:40,580
And passcodes can be pretty forced.

69
00:05:40,580 --> 00:05:46,470
So if you choose one, two, three, four as
your passcode, it's not gonna be very strong.

70
00:05:46,470 --> 00:05:47,470
Someone is going to guess that.

71
00:05:47,470 --> 00:05:53,180
So we put a bunch of mitigations in place.

72
00:05:53,180 --> 00:05:59,310
Now, the first mitigation that we've always had in
place is that we have back off between failed attempts

73
00:05:59,310 --> 00:06:02,390
on using the UI to putting someone's passcode.

74
00:06:02,390 --> 00:06:06,000
So it's kind of incremental as you have failed attempts.

75
00:06:06,000 --> 00:06:10,270
But by the sixth failed attempt, it takes
like, 10 minutes for the UI to come back up

76
00:06:10,270 --> 00:06:12,300
and offer to you to put your passcode here.

77
00:06:12,300 --> 00:06:15,980
So this makes, you know, someone who's
stolen your device, if they are just trying

78
00:06:15,980 --> 00:06:19,420
to punch the numbers it makes it
pretty difficult for them to guess.

79
00:06:19,420 --> 00:06:22,070
It takes them a long time.

80
00:06:23,400 --> 00:06:28,470
Now, we've also had the ability to
force complex passcodes on the device.

81
00:06:28,470 --> 00:06:32,690
We've had this for a while with configuration profiles.

82
00:06:32,690 --> 00:06:39,070
Now, what's new for iOS 4 is we actually give
you a user-configurable setting in the settings--

83
00:06:39,070 --> 00:06:47,110
on the settings tab to actually force the
complex-- or to actually use a complex passcode.

84
00:06:47,110 --> 00:06:52,310
Also, we've had the ability to force
and erase of all the user's data

85
00:06:52,310 --> 00:06:54,840
after a failed numbers of attempts at the passcode.

86
00:06:54,840 --> 00:07:03,700
This is also something in iOS 4 that
we've made user-configurable in settings.

87
00:07:03,700 --> 00:07:10,320
Now, another thing that we did in tying
all the data to the passcode is we, not--

88
00:07:10,320 --> 00:07:16,690
didn't just tie it to the passcode itself, we also
tied it into a set of device keys in the hardware.

89
00:07:16,690 --> 00:07:24,420
And the reason that we did this is that it makes it--
it prevents people from taking the data off the device

90
00:07:24,420 --> 00:07:29,030
and trying to brute force passcodes
there, since it's actually encrypted also

91
00:07:29,030 --> 00:07:31,710
with a key that's only available in the hardware.

92
00:07:31,710 --> 00:07:36,990
That means that you actually have to-- someone would
actually have to do an attack on that hardware itself.

93
00:07:36,990 --> 00:07:40,680
And our hardware is fast, but it's not as fast as a botnet.

94
00:07:40,680 --> 00:07:45,550
So this actually limits the speed
of an attack on these passcodes.

95
00:07:48,410 --> 00:07:53,820
So I want to kind of just run through
what technologies we put in iOS

96
00:07:53,820 --> 00:07:59,510
and kind of why we put them there
over the generations of releases.

97
00:07:59,510 --> 00:08:04,100
So obviously, we have had, since
the first iPhone, a passcode.

98
00:08:04,100 --> 00:08:09,550
And this was really, you know, at that
time meant to prevent casual device access.

99
00:08:09,550 --> 00:08:12,090
It was meant to stop someone, kind of, at the door

100
00:08:12,090 --> 00:08:15,870
and make them know one number before
they could actually use that device.

101
00:08:15,870 --> 00:08:21,620
Now, even at that point in time, we had
some Privilege Separation and Sandboxing.

102
00:08:21,620 --> 00:08:28,350
And what Privilege Separation is, it means that
applications, either in the OS or third party applications,

103
00:08:28,350 --> 00:08:33,070
only have access to those services
that they have privileges for.

104
00:08:33,070 --> 00:08:42,140
And Sandboxing is that basically, they only have access
to those documents or API's that they have privileges for.

105
00:08:42,140 --> 00:08:49,820
Now, this has kind of evolved over time because obviously,
in the first release of iOS, there was no third party apps.

106
00:08:49,820 --> 00:08:57,350
And as we added third party apps, we added more
Sandboxing, we put those apps in the Sandbox.

107
00:08:57,350 --> 00:09:02,470
Now, for iOS 2, we also added Code Signing.

108
00:09:02,470 --> 00:09:06,020
And the reason that we did this
is that now, the user knows that--

109
00:09:06,020 --> 00:09:12,080
they know that there is known origins
for every piece of code on their device.

110
00:09:12,080 --> 00:09:17,970
This makes it much more difficult to spread around viruses
and the like because you can actually trace it back

111
00:09:17,970 --> 00:09:25,030
to whether it's an enterprise, inhouse app, or whether it's
an app from the App Store, or whether it's code from Apple.

112
00:09:25,030 --> 00:09:28,160
We also added Remote Wipe at that time.

113
00:09:28,160 --> 00:09:31,650
Now this would, you know, like I said
before, erases all the data in the phone,

114
00:09:31,650 --> 00:09:34,280
if that phone is still online, you can send it a signal.

115
00:09:34,280 --> 00:09:41,030
And obviously, at that time, what has to
happen is we actually had to overwrite the data

116
00:09:41,030 --> 00:09:43,960
with zeros essentially, to erase that data.

117
00:09:43,960 --> 00:09:50,110
And then actually, it was a pretty long process,
especially for the larger storage devices.

118
00:09:50,110 --> 00:09:52,830
So last year, we added encrypted storage.

119
00:09:52,830 --> 00:09:57,270
The main reason for that is to
make Remote Wipe very, very fast,

120
00:09:57,270 --> 00:10:04,210
and we added encrypted backups, which
protects the data off the device.

121
00:10:04,210 --> 00:10:07,040
And now, we're adding data protection.

122
00:10:07,040 --> 00:10:15,480
And this really means that even if a device is compromised
in some way, it's stolen and it's a compromised device,

123
00:10:15,480 --> 00:10:21,290
that user's data is still protected because it's
protected with something that only that user knows.

124
00:10:21,290 --> 00:10:25,530
So you can see where this is all going here.

125
00:10:25,530 --> 00:10:32,580
We want all the apps to adopt data protection, both
throughout the OS and throughout all of your apps.

126
00:10:32,580 --> 00:10:36,460
So we start it with Mail which is the most complex app,

127
00:10:36,460 --> 00:10:40,980
and we want you to go through your app
and choose how your data is protected.

128
00:10:40,980 --> 00:10:46,610
Now, the big thing here is that for app surges
in the foreground, when the device is locked

129
00:10:46,610 --> 00:10:52,230
and not doing anything, it's pretty easy to choose
they want their data protected by the passcode.

130
00:10:52,230 --> 00:10:56,920
If you are doing some kind of multitasking
app that has some kind of background task,

131
00:10:56,920 --> 00:10:58,730
you have to be a little bit more careful with your data,

132
00:10:58,730 --> 00:11:04,290
and you have to choose a few different
classes to figure out how to do that.

133
00:11:04,290 --> 00:11:09,130
But we want you to start adopting these
API's and these concepts into your apps

134
00:11:09,130 --> 00:11:15,020
because our real ultimate goal here is
that when the user puts on their passcode,

135
00:11:15,020 --> 00:11:18,540
they know all their data is protected no matter what.

136
00:11:18,540 --> 00:11:21,960
So I'd like to invite up Mitch Adler,
one of our Security Architects,

137
00:11:21,960 --> 00:11:25,160
to talk a little bit about-- more
about the mechanism behind us.

138
00:11:25,160 --> 00:11:25,730
[ Applause ]

139
00:11:25,730 --> 00:11:31,070
>> Mitch Adler: Thanks, John.

140
00:11:31,070 --> 00:11:36,250
As John said, I'm going to take you on a little deeper
dive into the mechanisms we put together in our system

141
00:11:36,250 --> 00:11:39,580
to help protect the user's data with their passcode.

142
00:11:39,580 --> 00:11:45,540
It-- the goal, as John said, is that when
the device is locked, the user should be able

143
00:11:45,540 --> 00:11:47,570
to be confident that their device is protected.

144
00:11:47,570 --> 00:11:53,490
And in iOS 3, we were relatively confident that if
I-- my device is locked and I hand it to somebody

145
00:11:53,490 --> 00:11:57,640
and I watch them not penetrate the defense of
the device, they're not going to be able to get

146
00:11:57,640 --> 00:12:02,750
through my passcode very easily because we limit the
tries and all of the mitigations that John talked about.

147
00:12:02,750 --> 00:12:08,150
But for iOS 4, we want to provide a mechanism that the user
can be confident that even if they've lost their device,

148
00:12:08,150 --> 00:12:12,180
if their passcode, if their device is
locked, that their data is actually protected

149
00:12:12,180 --> 00:12:15,060
with their passcode, the strength to their passcode.

150
00:12:15,060 --> 00:12:21,380
That requires that we actually encrypt their
data with some derivation of their passcode.

151
00:12:21,380 --> 00:12:24,690
And this is very useful, but we run into a problem.

152
00:12:24,690 --> 00:12:30,820
And that problem is that applications want to use
some of that data sometimes when the device is locked.

153
00:12:30,820 --> 00:12:37,040
So we needed to provide a mechanism for applications to
specify jar system how they want given data protected.

154
00:12:37,040 --> 00:12:41,150
That mechanism is data protection classes.

155
00:12:41,150 --> 00:12:46,920
There are three data protection classes that
we have established in our system in our API.

156
00:12:46,920 --> 00:12:50,110
The first class is available and unlocked.

157
00:12:50,110 --> 00:12:51,650
That's the most protecting class.

158
00:12:51,650 --> 00:12:56,760
The availability and the protection are kind of reverse
of each other, when something is available to the system

159
00:12:56,760 --> 00:13:00,150
than an attacker who manages to
get through our outer protections

160
00:13:00,150 --> 00:13:04,510
and get inside the system can masquerade
as an application and access that data.

161
00:13:04,510 --> 00:13:09,510
So if you set your data be able-- if you
set your protection class to one that to--

162
00:13:09,510 --> 00:13:14,650
WhenUnlocked, we'll protect the data
cryptographically when the system is locked,

163
00:13:14,650 --> 00:13:17,640
and we'll make it available to your app when it's unlocked.

164
00:13:17,640 --> 00:13:20,650
The second class is available after fist unlock.

165
00:13:20,650 --> 00:13:23,370
This is the kind of compromise class.

166
00:13:23,370 --> 00:13:28,490
We noted that many of the attacks on the device that
compromise devices and get access to running code

167
00:13:28,490 --> 00:13:30,570
on the device requires the device reboot.

168
00:13:30,570 --> 00:13:36,170
In the process of rebooting, we can
reset things that have been exposed.

169
00:13:36,170 --> 00:13:41,830
So we add the second class, so that if there is data that
you need to continue accessing while the device is locked,

170
00:13:41,830 --> 00:13:46,390
for example, credentials to reconnect to your server because
you've changed networks and now you need to reconnect

171
00:13:46,390 --> 00:13:53,210
and revalidate, you can protect those credentials
better than not at all, but still have them available

172
00:13:53,210 --> 00:13:56,700
when the device locks and unlocks, because after
the first unlock, it will be available for you.

173
00:13:56,700 --> 00:14:02,410
And then if somebody attacks the device and then
forces it to reboot, we'll reprotect that data.

174
00:14:02,410 --> 00:14:05,990
The last availability class is what we've
had traditionally on all of our storage

175
00:14:05,990 --> 00:14:09,820
up to this date, which is it's available always.

176
00:14:09,820 --> 00:14:14,090
It is no less protected than it has been in the past,
but it doesn't gain anything from data protection.

177
00:14:14,090 --> 00:14:18,900
But it's a way to express that need, if I
need my data to be exactly the same as it is.

178
00:14:18,900 --> 00:14:26,860
So the two major clients of these classes that present
them to you in the file system, which presents availability

179
00:14:26,860 --> 00:14:34,450
for WhenUnlock called ProtectionComplete and
that available always called ProtectionNone,

180
00:14:34,450 --> 00:14:42,900
under the Keychain which provides availability for
all three, WhenUnlocked, AfterFirstUnlock, and Always.

181
00:14:42,900 --> 00:14:52,770
So these two clients, there is some risk that if the
two clients were sharing all of their keys and classes,

182
00:14:52,770 --> 00:14:57,190
that if I were a client of one of the systems, I could
use it to attack data stored in the other system.

183
00:14:57,190 --> 00:15:00,840
So for that reason, we make these very much independent.

184
00:15:00,840 --> 00:15:03,370
They have very intentionally similar semantics.

185
00:15:03,370 --> 00:15:05,840
So when you're thinking about how you store your data,

186
00:15:05,840 --> 00:15:08,620
you can think about the problem
the same way for the two systems.

187
00:15:08,620 --> 00:15:13,050
But from the point of view of how the data is
protected, we use completely separate class keys

188
00:15:13,050 --> 00:15:15,880
to represent those classes, so we can isolate--

189
00:15:15,880 --> 00:15:20,010
the people can access the Keychain from the people
who are allowed to access the data on the file system.

190
00:15:20,010 --> 00:15:28,130
I'm going to run through a quick example to
demonstrate how we take some data that the user has

191
00:15:28,130 --> 00:15:33,410
and protect it through our new design system in iOS 4.

192
00:15:33,410 --> 00:15:41,190
So here's an example of a file, a mail that I happen
to compose on the device, and it needs to be protected.

193
00:15:41,190 --> 00:15:47,420
In iOS 4, every file in the file system or
how it's made is protected with a file key.

194
00:15:47,420 --> 00:15:51,840
This is slightly different than it was in iOS 3 and
that the whole file system is protected by a key.

195
00:15:51,840 --> 00:15:57,780
But in iOS 4, there's a randomly generated
new key for every file that gets created.

196
00:15:57,780 --> 00:16:01,160
That file key is stored in the files metadata.

197
00:16:01,160 --> 00:16:04,220
That file key is, in turn, protected by a class key.

198
00:16:04,220 --> 00:16:06,420
This is a class-- a key that was randomly generated

199
00:16:06,420 --> 00:16:10,860
at the time the class was established,
and it protects the file key.

200
00:16:10,860 --> 00:16:12,900
If you don't have the class key, can't see the file key.

201
00:16:12,900 --> 00:16:16,100
If you don't have the file key, you
can't see the contents of the file.

202
00:16:16,100 --> 00:16:21,960
Each class key is protected by an appropriate set
of keys in the system depending on its semantics.

203
00:16:21,960 --> 00:16:29,050
In this particular case, this is a-- protected with the
user pin key, it's protected by two keys, the device key,

204
00:16:29,050 --> 00:16:36,100
to make attacks off the device less practical,
and the user passcode key which is the tie

205
00:16:36,100 --> 00:16:39,850
that ties the protection of the file back to the passcode.

206
00:16:39,850 --> 00:16:43,810
The file is protected by the file key, the
file key is protected by the class key,

207
00:16:43,810 --> 00:16:47,170
the class key is protected by the user passcode key.

208
00:16:47,170 --> 00:16:51,420
There's one more thing that we needed
to support in this architecture,

209
00:16:51,420 --> 00:16:55,530
and that was the ability to do fast Remote Wipe.

210
00:16:55,530 --> 00:16:59,070
In the past we have thrown away the one
master file system key and it erased--

211
00:16:59,070 --> 00:17:01,430
cryptographically erased the entire file system.

212
00:17:01,430 --> 00:17:07,520
Now that we don't have exactly one master key, we had
to build one back in, and that's on all the metadata.

213
00:17:07,520 --> 00:17:12,030
The file metadata has file system
key, that key, when erased,

214
00:17:12,030 --> 00:17:14,980
makes it cryptographically impossible
to view the data on the file.

215
00:17:14,980 --> 00:17:24,940
So to take this particular example, and show you
how we take a collection of data and protect it,

216
00:17:24,940 --> 00:17:28,990
for an entire file system, we can have one
file, like we just showed you, protected,

217
00:17:28,990 --> 00:17:34,640
the file protected by it's file key, the file key protected
by it's class key, and the class key protected appropriately

218
00:17:34,640 --> 00:17:37,460
by a device key in our user passcode key.

219
00:17:37,460 --> 00:17:42,940
But since we've gone through this class key, we can
have as many files as we'd like protected in this class.

220
00:17:42,940 --> 00:17:48,480
So there's no limit, the class-- the-- each
file can specify it belongs to this class.

221
00:17:48,480 --> 00:17:51,570
We also don't have to limit ourselves
to how many classes we want.

222
00:17:51,570 --> 00:17:56,370
We can have a second class with exactly the same
protections and maybe some different semantics

223
00:17:56,370 --> 00:18:01,790
on how you get the class key, and we can store
it on the same data storage, same file system.

224
00:18:01,790 --> 00:18:03,630
We can have a third class with different semantics.

225
00:18:03,630 --> 00:18:06,400
In this particular example, this would be accessed always.

226
00:18:06,400 --> 00:18:09,980
There's no protection that extends from
the user passcode key to this class key.

227
00:18:09,980 --> 00:18:15,000
So this is how we store on our system things that are
always available that are protected by the device key,

228
00:18:15,000 --> 00:18:17,280
but they're not protected by the user passcode key.

229
00:18:17,280 --> 00:18:24,330
The collection of classes that protect
data on the system, we call a keybag.

230
00:18:24,330 --> 00:18:31,430
The-- that collection of class keys is an
important structure in our architecture.

231
00:18:31,430 --> 00:18:36,350
It's what embodies locking, unlocking,
and protection states.

232
00:18:36,350 --> 00:18:41,410
There are three kinds of keybags
we operate in our system with.

233
00:18:41,410 --> 00:18:46,020
There's the System Keybag, there's a Backup
Keybag, and there's an Escrow Keybag.

234
00:18:46,020 --> 00:18:49,670
The first two are relatively important
for everybody to understand.

235
00:18:49,670 --> 00:18:54,320
The last one is an interesting detail for anybody
who wants to do security analysis on their device.

236
00:18:55,850 --> 00:18:59,320
System keybags, these are the ones
you'd imagine, as I've just described,

237
00:18:59,320 --> 00:19:01,480
they're sitting on the system,
they're protecting your system.

238
00:19:01,480 --> 00:19:06,240
They hold the class keys for all
the data that's on your system.

239
00:19:06,240 --> 00:19:08,180
They have one tweak they do.

240
00:19:08,180 --> 00:19:13,500
They force all of the class keys, and
then to be protected with the device key

241
00:19:13,500 --> 00:19:18,090
that makes it hard to attack this keybag off the device.

242
00:19:18,090 --> 00:19:20,150
They're stored on the system.

243
00:19:20,150 --> 00:19:24,630
They're actually stored on the file system, which
is interesting, because the fact that they're stored

244
00:19:24,630 --> 00:19:31,790
in the file system means that if you use a weak
passcode that's trying to protect this keybag,

245
00:19:31,790 --> 00:19:38,410
and we leave that data on the file system, somebody later
can come and find it even if we've moved on to a new keybag

246
00:19:38,410 --> 00:19:41,700
and use that old keybag to try and steal your class keys.

247
00:19:41,700 --> 00:19:44,220
Because when passcodes change,
we don't change the class keys.

248
00:19:44,220 --> 00:19:49,000
That way, we don't have to scour the entire file
system trying to update it for this metadata.

249
00:19:49,000 --> 00:19:54,950
So in order to mitigate that attack, we
actually protect the storage of the keybag

250
00:19:54,950 --> 00:19:58,610
on the file system with a key that we can erase.

251
00:19:58,610 --> 00:20:03,380
Every time the user changes the
passcode, we destroy the old key,

252
00:20:03,380 --> 00:20:07,540
we write a new copy of the Keychain out of
the keybag out, and we write a new--

253
00:20:07,540 --> 00:20:10,040
we use a new key, and we randomly generate a key.

254
00:20:10,040 --> 00:20:15,060
So we've cryptographically erased the old
keybag so that it's older, maybe weaker,

255
00:20:15,060 --> 00:20:18,550
passcode protection is not exposing my device anymore.

256
00:20:18,550 --> 00:20:26,070
The system keybag is also responsible for
managing the lock and unlock state of the system.

257
00:20:26,070 --> 00:20:32,110
When the user enters their passcode, the system keybag
is asked to expose the class keys that should be exposed

258
00:20:32,110 --> 00:20:38,690
when the device unlocked, and when it's told the device is
locking, it discards those keys, forgets those class keys.

259
00:20:38,690 --> 00:20:44,840
So it's-- this is the center of the universe of the device
locking and unlocking and protecting the user's data.

260
00:20:44,840 --> 00:20:50,330
But in order for us to maintain our encrypted
backups and to maintain our protection

261
00:20:50,330 --> 00:20:53,950
through it, we also created backup keybags.

262
00:20:53,950 --> 00:20:57,650
Backup keybags are created new for every back up.

263
00:20:57,650 --> 00:21:03,840
Their class keys are generated randomly and are
different for every backup you've-you storeon your host.

264
00:21:03,840 --> 00:21:08,440
This holds the class keys that protects the data
while it sits in the backup on those machine.

265
00:21:08,440 --> 00:21:15,630
These class keys, instead of being protected by
the pin, are protected by the backup password.

266
00:21:15,630 --> 00:21:20,100
So when you have a protected backup, we-- everyone
who would have used the pin on the device are going

267
00:21:20,100 --> 00:21:24,120
to be using the backup password
in the protected backup keybag.

268
00:21:24,120 --> 00:21:30,560
We happened to use PBKDF2, for
those who care to generate the key.

269
00:21:30,560 --> 00:21:36,050
I don't remember the number of iterations off top of my
head, happy to look it up for you if you want to know.

270
00:21:36,050 --> 00:21:43,280
If you don't choose to have a backup password though, we do
one thing to protect credentials that are on the Keychain.

271
00:21:43,280 --> 00:21:50,260
If you don't choose to protect your backup, we protect
some of the Keychain class keys with the device key,

272
00:21:50,260 --> 00:21:53,310
and not the backup password key,
causing them not to be able to migrate,

273
00:21:53,310 --> 00:21:55,870
and we'll get into that in more detail later in Adoption.

274
00:21:55,870 --> 00:22:04,090
The last kind of keybag is a keybag
we created to enhance user experience.

275
00:22:04,090 --> 00:22:07,180
It was created for systems to be able to hold on to.

276
00:22:07,180 --> 00:22:08,510
It's called the Escrow Keybag.

277
00:22:08,510 --> 00:22:12,620
It was created for other systems to
hold on to improve user experience.

278
00:22:12,620 --> 00:22:18,700
The downside is that the improved user experience
we want is systems that sync with your device,

279
00:22:18,700 --> 00:22:21,680
can sync without you having to
enter the passcode on your device.

280
00:22:21,680 --> 00:22:27,420
And right there conceptually, is a security issue, in that
now there is data in the world that can unlock my device.

281
00:22:27,420 --> 00:22:29,720
So we did a few things to mitigate it.

282
00:22:29,720 --> 00:22:34,160
First, we considered that the system
that you're storing the Escrow Keybag

283
00:22:34,160 --> 00:22:36,660
on is a system you're already syncing you data to.

284
00:22:36,660 --> 00:22:41,760
So if somebody can compromise that system and
get your Escrow Keybag, additionally being able

285
00:22:41,760 --> 00:22:48,060
to compromise your device, if they can get their hands
on your device, is not a big leap in security weakness.

286
00:22:48,060 --> 00:22:52,870
It's a little-- it's irritating and annoying
but it's not of great loss, because most likely,

287
00:22:52,870 --> 00:22:56,150
all of your sync data is sitting
on that host that was compromised.

288
00:22:56,150 --> 00:23:00,540
Them getting your Escrow Keybag is a
potential future problem, but immediately,

289
00:23:00,540 --> 00:23:04,270
they've probably already taken all of your data.

290
00:23:04,270 --> 00:23:11,860
The other thing we do is that we keep a key on the
original device so we can invalidate the Escrow Keybag.

291
00:23:11,860 --> 00:23:15,370
It's part of the protection.

292
00:23:15,370 --> 00:23:22,040
The class keys in this keybag are protected with a device
key, so this keybag can't be brute force except with access

293
00:23:22,040 --> 00:23:27,630
to the device, and the key we generated when we
made the Escrow Keybag and stored on the device.

294
00:23:27,630 --> 00:23:30,720
So if we could throw that key away on the device,

295
00:23:30,720 --> 00:23:36,220
we can make that Escrow Keybag cryptographically
incapable of reading the data on the device.

296
00:23:36,220 --> 00:23:40,070
So anytime we decide that somebody's not worthy
of trust, we can throw away the key, of course,

297
00:23:40,070 --> 00:23:44,660
part of the Escrow Keybag, and
they can't access our data anymore.

298
00:23:44,660 --> 00:23:50,650
Something I didn't mention is the Escrow Keybag
does contain actual copies of the master class keys

299
00:23:50,650 --> 00:23:55,960
for the devices classes, which is why it can
unlock the device without the user's passcode.

300
00:23:55,960 --> 00:24:06,790
So to dive a little deeper into the filesystem
protection, all of the filesystem data is encrypted.

301
00:24:06,790 --> 00:24:07,980
Everything on the filesystem.

302
00:24:07,980 --> 00:24:10,460
It has been since iOS 3.

303
00:24:10,460 --> 00:24:14,580
We've changed how we encrypt out the data on the filesystem.

304
00:24:14,580 --> 00:24:17,570
The metadata uses the filesystem
key as I showed you in the diagram.

305
00:24:17,570 --> 00:24:25,650
That's what destroyed on Remote Wipe and breaks the chain
of cryptographic exposure, so we-- your data is not exposed.

306
00:24:25,650 --> 00:24:31,330
The files are encrypted to an individual
file key which is stored in the metadata.

307
00:24:31,330 --> 00:24:34,960
The default, when you're creating a
new file in iOS 4, is ProtectionNone.

308
00:24:34,960 --> 00:24:37,980
This is mostly for compatibility with applications,

309
00:24:37,980 --> 00:24:41,660
we don't want you to break all the
applications that do anything across lock.

310
00:24:41,660 --> 00:24:45,270
We want them to opt in and decide what
they-- how they want to protect it.

311
00:24:45,270 --> 00:24:47,480
And again, a reminder, there's no performance impact.

312
00:24:47,480 --> 00:24:49,990
We are already encrypting and decrypting.

313
00:24:49,990 --> 00:24:56,610
We've just changed what keys we're using in the process
of pushing stuff back and forth to the file system.

314
00:24:56,610 --> 00:25:07,770
The Keychain-- it's also protected by classes just for the
Keychain, as the concept of migratable and not migratable.

315
00:25:07,770 --> 00:25:13,540
That as-- that actually doubles the number of classes that
are available for the Keychain because you can put a piece

316
00:25:13,540 --> 00:25:17,570
of data into any of the three classes,
and either migratable or not migratable.

317
00:25:17,570 --> 00:25:23,010
The default on the Keychain will remove
data from back to a device by iOS 4,

318
00:25:23,010 --> 00:25:29,950
or if you create data without adopting data
protection, will be always as migratable.

319
00:25:29,950 --> 00:25:34,960
The three new classes that aren't
migratable have the suffix ThisDeviceOnly.

320
00:25:34,960 --> 00:25:41,860
So WhenUnlock, ThisDeviceOnly, WhenUnlock--
AfterFirstUnlock, ThisDeviceOnly, AlwaysThisDeviceOnly.

321
00:25:41,860 --> 00:25:47,060
So this is a change that is in significance to people who
want to protect data and don't want it to move form device

322
00:25:47,060 --> 00:25:51,910
to device, because our default now is going to
allow things to migrate through a protected backup.

323
00:25:51,910 --> 00:25:54,680
We thought that was the right compromise
for user experience.

324
00:25:54,680 --> 00:26:01,220
But if you have data that is really not supposed to migrate
off of this device ever, you'll need to update your use

325
00:26:01,220 --> 00:26:08,370
to annotate that data and say it's not supposed to migrate.

326
00:26:08,370 --> 00:26:10,640
Handling of the passcode.

327
00:26:10,640 --> 00:26:17,020
So one of the most critical things in trying to keep
the user secret a secret is how we handle the passcode,

328
00:26:17,020 --> 00:26:19,620
because we have given that secret,
and we have it for a while,

329
00:26:19,620 --> 00:26:21,580
and we really don't want to keep
it because it's the user secret.

330
00:26:21,580 --> 00:26:23,590
It's not our secret.

331
00:26:23,590 --> 00:26:27,740
So we do two things to try and
help protect that user secret.

332
00:26:27,740 --> 00:26:37,630
The first thing we do is try and make it difficult to
brute force attack the key that we derive from the passcode

333
00:26:37,630 --> 00:26:41,160
to avoid simple brute forcing the-- a user's passcode.

334
00:26:41,160 --> 00:26:45,960
And as John mentioned, we take a hardware key, something
that's actually embedded in hardware individual

335
00:26:45,960 --> 00:26:53,120
to a given device, we do a derivation with that
hardware key which resembles PBKDF2, but isn't exactly,

336
00:26:53,120 --> 00:27:03,220
and do a bunch of iterations to make you need to use
that device in order to be able to attack the passcode.

337
00:27:03,220 --> 00:27:08,500
This means that an attacker whose managed to get access
to your device, broken through our outer defenses,

338
00:27:08,500 --> 00:27:13,840
gotten to the point where he's got a copy of
your system keybag and wants to try to unlock it,

339
00:27:13,840 --> 00:27:17,130
and knows what it should look like-- what the
header it should look like if it's unlocked,

340
00:27:17,130 --> 00:27:21,490
actually has to keep trying on
that device to unlock that keybag.

341
00:27:21,490 --> 00:27:28,530
This helps us be able to control
the time it takes to attack once.

342
00:27:28,530 --> 00:27:33,840
For example on an iPhone 4, on a new
hardware, we use 50,000 hardware operations

343
00:27:33,840 --> 00:27:37,010
to drive the key from the original passcode.

344
00:27:37,010 --> 00:27:39,730
It takes about 50 milliseconds, give or take.

345
00:27:39,730 --> 00:27:44,180
And if you do the math from there, for a
reasonable passcode somebody's put on the device,

346
00:27:44,180 --> 00:27:48,420
it starts taking significant amounts of time,
cryptographically interesting amounts in time,

347
00:27:48,420 --> 00:27:51,970
for you to brute force somebody's passcode.

348
00:27:51,970 --> 00:27:59,090
The other thing we do is we handle the
passcode and the passcode key very carefully.

349
00:27:59,090 --> 00:28:04,890
When we've given the passcode, and we to return it into a
passcode key, we're careful to erase remnants to make sure

350
00:28:04,890 --> 00:28:07,180
that the user secrets stays the user secret.

351
00:28:07,180 --> 00:28:12,430
The thing we retain when the device
unlocks, are the exposed class keys.

352
00:28:12,430 --> 00:28:17,890
So when we move from state to state, class keys
come and go, and they're available and they're not.

353
00:28:17,890 --> 00:28:23,800
Example of this, a device boot, we start
out-- we don't know the user's passcode,

354
00:28:23,800 --> 00:28:26,470
he's never entered it, we're fresh and clean.

355
00:28:26,470 --> 00:28:34,960
The only class that is available is the always class,
ProtectionNone, AlwaysThisDeviceOnly are available,

356
00:28:34,960 --> 00:28:37,820
the first two protection classes
aren't available yet because we don't--

357
00:28:37,820 --> 00:28:40,380
we haven't been able to unwrap the class keys.

358
00:28:40,380 --> 00:28:45,640
When the user enters their passcode,
we unwrap the class keys, we--

359
00:28:45,640 --> 00:28:51,740
if we get their passcode and their passcode key that help
protect the class keys, but we keep this class keys around.

360
00:28:51,740 --> 00:28:54,070
So now, all of the classes are available.

361
00:28:54,070 --> 00:28:59,720
WhenUnlock, AfterFirstUnlock, they're all available,
the device operates, people do their normal operations.

362
00:28:59,720 --> 00:29:04,860
But at some point, the device gets
locked, either by idling to lock

363
00:29:04,860 --> 00:29:08,600
or by the user clicking the lock button
and wanting the device to lock itself.

364
00:29:08,600 --> 00:29:12,840
When that happens we forget the
class keys for the first class.

365
00:29:12,840 --> 00:29:17,390
So that things that are only available when unlocked
are no longer available, the device is locked.

366
00:29:17,390 --> 00:29:23,770
Note that the second class stays around as is defined
after FirstUnlock, it remains available until we reboot,

367
00:29:23,770 --> 00:29:27,860
then we'll get back into the initial
state, we've lost all the class keys.

368
00:29:27,860 --> 00:29:35,500
So in summary about our mechanism and how we put this
all together, our protection extends through a keybag,

369
00:29:35,500 --> 00:29:40,490
it comes from the user's secrets and device keys
to bind it to the device and bind it to the user,

370
00:29:40,490 --> 00:29:44,640
it goes to the filesystem in the Keychain
and the data stored in those places.

371
00:29:44,640 --> 00:29:51,720
The passcode key derivation has been made resistant to
brute force attack to help protect the user's passcode.

372
00:29:51,720 --> 00:29:56,300
And the Keychain contents have been made
migratable when we have protected backups.

373
00:29:56,300 --> 00:30:03,250
And with that, I'll hand it back to John
to talk some more about configuration.

374
00:30:03,250 --> 00:30:04,510
>> John Wright: Thanks, Mitch.

375
00:30:04,510 --> 00:30:11,040
[ Applause ]

376
00:30:11,040 --> 00:30:17,880
. So for user-enabled data protection,
actually on an iPhone 4, it's extremely simple.

377
00:30:17,880 --> 00:30:19,750
The formats already there in the device.

378
00:30:19,750 --> 00:30:26,270
All they have to do is set a passcode,
and data protection is enabled.

379
00:30:26,270 --> 00:30:35,110
Now, on our last generation of devices, including iPhone
3GS and the iPod touch, the 3rd generation iPod touch,

380
00:30:35,110 --> 00:30:43,200
it's a little bit more complicated and that we don't
have the right file system format on those devices,

381
00:30:43,200 --> 00:30:44,890
and you have to upgrade the file system format.

382
00:30:44,890 --> 00:30:47,460
And the way we do that is with an Erase Install.

383
00:30:47,460 --> 00:30:54,680
And so, the user has to backup their device, do a
full Erase Install, and then restore from that backup.

384
00:30:54,680 --> 00:31:04,160
And of course, the iPad is also capable of doing
this, and it will inherit this feature with iOS 4,

385
00:31:04,160 --> 00:31:09,020
and it will also require an Erase
Install to get that feature.

386
00:31:09,020 --> 00:31:16,180
Now, to check to see if Data Protection is enabled
if you go to Settings-> General-> Passcode Lock,

387
00:31:16,180 --> 00:31:25,950
and there is a picture right there, if you look at
that little string at the very bottom of that screen,

388
00:31:25,950 --> 00:31:27,940
it basically says Data Protection is enabled.

389
00:31:27,940 --> 00:31:29,650
So now, you know you have it on that device.

390
00:31:29,650 --> 00:31:35,010
Now, I want to point out a couple
of other things on this screen.

391
00:31:35,010 --> 00:31:43,440
So I told you before that users now can configure their
device to be able to Wipe if-- on 10 failed passcode events.

392
00:31:43,440 --> 00:31:45,520
That is that setting right there.

393
00:31:45,520 --> 00:31:54,110
And they're also able to set a arbitrary complex
passcode by turning off the simple passcode,

394
00:31:54,110 --> 00:31:58,790
and then the dialog that comes up to change
their passcode is a full alpha numeric keyboard,

395
00:31:58,790 --> 00:32:02,520
and they can choose what size length complexity they want.

396
00:32:06,400 --> 00:32:13,940
Now, for devices that are being managed and our system
to manage these devices is-- our Configuration Profiles.

397
00:32:13,940 --> 00:32:18,670
You can set this Configuration Profiles
to enforce certain security requirements,

398
00:32:18,670 --> 00:32:21,510
and I'd like to point a few of those out there.

399
00:32:21,510 --> 00:32:26,940
So, the first one is that you can require
data protection to be enabled on that device.

400
00:32:26,940 --> 00:32:34,370
You can also require a passcode be set, the link of
that passcode, and the complexity of that passcode.

401
00:32:34,370 --> 00:32:40,830
You can also require a minimum passcode grace
period, and the grace period is how long a user has

402
00:32:40,830 --> 00:32:48,320
from the time they turn off the screen to when they
turn on the screen again that it requires a passcode.

403
00:32:51,710 --> 00:32:58,710
And you can also inquire that all the backups
from that device are encrypted backups.

404
00:32:58,710 --> 00:33:07,670
Now, something else that we're introducing with
iOS 4 is a way to manage your mobile devices,

405
00:33:07,670 --> 00:33:14,150
a bunch of API's actually use these
Configuration Profiles with third party servers

406
00:33:14,150 --> 00:33:17,520
and third party device management systems.

407
00:33:17,520 --> 00:33:26,040
And these device management systems will be capable of
doing initial device configuration and automatic updates

408
00:33:26,040 --> 00:33:31,490
of these Configuration Profiles, and then also be
able to implement their own Remote Wipe capabilities.

409
00:33:31,490 --> 00:33:37,610
And there was a whole session on Tuesday
that went over how these API's work.

410
00:33:37,610 --> 00:33:44,410
And we've assumed that third parties will be
adopting these into their device management systems.

411
00:33:44,410 --> 00:33:51,430
So that really makes a very capable
management system for you guys to be able

412
00:33:51,430 --> 00:33:55,780
to implement these security type-- or
these security requirements as well.

413
00:33:58,870 --> 00:34:03,220
So the whole idea here is that we want
configurations to be dead-simple for any users.

414
00:34:03,220 --> 00:34:06,300
We really don't want them to think about
it other than they set their passcode.

415
00:34:06,300 --> 00:34:11,780
And we want these security requirements
to be fully manageable by enterprises.

416
00:34:11,780 --> 00:34:16,970
And that's really the whole configuration story there.

417
00:34:16,970 --> 00:34:23,090
So I'm going to turn it over to Mitch to talk a
little bit about adoption of these API's in your apps

418
00:34:25,770 --> 00:34:30,680
>> Mitch Adler: So I'm going to talk a bit about
how you adopt Data Protection in your application.

419
00:34:30,680 --> 00:34:36,740
To go back to what John was talking about a little
bit, we really want to protect your customer's data,

420
00:34:36,740 --> 00:34:41,980
we want to protect all of our mutual customer's data,
we want you to assume the data needs protection.

421
00:34:41,980 --> 00:34:46,170
You don't actually know what data users
are going to decide to put inside your app.

422
00:34:46,170 --> 00:34:49,190
If you're making a note-taking app, they might
put their credit card number in your app.

423
00:34:49,190 --> 00:34:53,860
It doesn't seem like a good idea
to me, but they might do it.

424
00:34:53,860 --> 00:34:57,150
We need you to help put the data into the right class.

425
00:34:57,150 --> 00:35:02,820
Since we don't automatically try and protect all your
data to preserve functionality of your application,

426
00:35:02,820 --> 00:35:05,360
we need help from you to know how
you want that data protected,

427
00:35:05,360 --> 00:35:08,720
so that we can do the best protection we can for the user.

428
00:35:08,720 --> 00:35:11,460
We recommend you find the most protected
class, and we'll get it to how you decide

429
00:35:11,460 --> 00:35:12,780
on what's the most protective class you can.

430
00:35:12,780 --> 00:35:14,380
It's here.

431
00:35:14,380 --> 00:35:19,530
We also want you to help put the user data back
into places that's protected because the file system

432
00:35:19,530 --> 00:35:22,690
and the Keychain are protected by Data Protection.

433
00:35:22,690 --> 00:35:26,510
RAM, you have your user's information and
it's not protected by Data Protection.

434
00:35:26,510 --> 00:35:32,000
So somebody can attack the device and get
into your process, which is not an easy feat.

435
00:35:32,000 --> 00:35:34,090
But if they can do it, they can steal data that's in RAM.

436
00:35:34,090 --> 00:35:39,240
So we recommend that you push the data out of RAM, push
it into the protected containers when the device locks.

437
00:35:39,240 --> 00:35:43,540
So one of the first things you're
going to have to do when you're going

438
00:35:43,540 --> 00:35:48,250
to adopt is analyze your data to
figure out what you need to protect.

439
00:35:48,250 --> 00:35:51,670
You pretty much need to answer these four
questions, and you can figure out what class

440
00:35:51,670 --> 00:35:54,650
and what location and how you want to protect that data.

441
00:35:54,650 --> 00:35:59,320
The questions are what data of the users do I
have, do I need it when it's locked, you know,

442
00:35:59,320 --> 00:36:05,070
does it belong in the Keychain, should it move from
device to device, and we'll get in to each one of these.

443
00:36:05,070 --> 00:36:07,460
So how do I answer what data of the users do I have.

444
00:36:07,460 --> 00:36:08,820
Well, it's everything they create.

445
00:36:08,820 --> 00:36:14,740
It's all the data users are entering, and it's the
credentials that they enter to connect to things,

446
00:36:14,740 --> 00:36:19,050
and it's credentials you create on their behalf, if you
make a connection and then wanted to create credentials

447
00:36:19,050 --> 00:36:23,410
to make a persisting connection,
or reestablishable connection,

448
00:36:23,410 --> 00:36:27,660
those credentials are data of the
users because it represents them.

449
00:36:28,850 --> 00:36:32,300
Do I need that data when the device is locked?

450
00:36:32,300 --> 00:36:34,420
Well, for most app writers, the answer is no.

451
00:36:34,420 --> 00:36:38,860
If the device locks, your app doesn't do much, it's
waiting for the user to come back and interact with it.

452
00:36:38,860 --> 00:36:40,300
So you don't.

453
00:36:40,300 --> 00:36:45,490
But some background-aware applications are going to
need things like credentials, and they're going to want

454
00:36:45,490 --> 00:36:51,090
to put those credentials in such a way that they
get protected, but they're still accessible.

455
00:36:51,090 --> 00:36:54,960
Which is why we have the compromise
of AccessibleAfterFirstUnlock,

456
00:36:54,960 --> 00:37:00,110
which is a good place to put things like credentials
you want to use and be able to reuse as users move

457
00:37:00,110 --> 00:37:07,090
around their networks but want to get some protection from
the classical kinds of compromises, which involve a reboot.

458
00:37:07,090 --> 00:37:08,970
Then you have to ask does it belong on the Keychain.

459
00:37:08,970 --> 00:37:11,870
This is a question we've talking about for a very long time.

460
00:37:11,870 --> 00:37:16,040
Credentials belong on the Keychain, particularly,
things that you want to migrate around.

461
00:37:16,040 --> 00:37:22,080
Things like passwords, keys, identities you've
establish for the user or imported for the user.

462
00:37:22,080 --> 00:37:27,750
Large bulk data doesn't really
belong on the Keychain itself.

463
00:37:27,750 --> 00:37:32,420
Should it move from device to device?

464
00:37:32,420 --> 00:37:34,180
Well, the simple answer is yes.

465
00:37:34,180 --> 00:37:36,950
The user wants their stuff to move from device to device.

466
00:37:36,950 --> 00:37:41,990
But the more complex answer is, well, unless you have
some compelling reason then it doesn't, and you'll--

467
00:37:41,990 --> 00:37:45,310
you in this room will probably aware of
why you would want that to be the case.

468
00:37:45,310 --> 00:37:55,960
We have an example on our system when you import VPN
configuration profile, and you set up a VPN identity,

469
00:37:55,960 --> 00:37:58,490
that's the identity of the device, not of the user.

470
00:37:58,490 --> 00:38:00,510
So those identities stay on the device.

471
00:38:00,510 --> 00:38:02,840
They are not permitted to migrate from device to device.

472
00:38:02,840 --> 00:38:07,120
But we have to make our system aware of the fact
that those might go away if I restore a backup.

473
00:38:07,120 --> 00:38:13,850
I'll get half the data back, but I won't get the migrated
VPN identity, and I'll have to deal with that state.

474
00:38:13,850 --> 00:38:19,230
So if you don't have a compelling reason to make
it non-migratable, make your data migratable.

475
00:38:19,230 --> 00:38:22,960
So we'll go through a few examples to help clarify this.

476
00:38:22,960 --> 00:38:26,290
The first example I have is a theoretical game.

477
00:38:26,290 --> 00:38:29,540
I have a game that has some online
play, it has some credentials it stores.

478
00:38:29,540 --> 00:38:31,460
It has some saved games it stores.

479
00:38:31,460 --> 00:38:33,650
That's pretty much all the data we have from the user.

480
00:38:33,650 --> 00:38:37,340
So for each one of these, I've gone through the questions.

481
00:38:37,340 --> 00:38:41,150
Do I need access to the credentials
when the device is locked?

482
00:38:41,150 --> 00:38:43,190
Well, no, my game has stopped and the device is locked.

483
00:38:43,190 --> 00:38:44,840
I don't need to connect to my server.

484
00:38:44,840 --> 00:38:47,420
It's-- we're done at that point.

485
00:38:47,420 --> 00:38:48,440
Do I need it to migrate?

486
00:38:48,440 --> 00:38:51,130
Well, it's credentials and the user would
like to be able to reconnect to our server

487
00:38:51,130 --> 00:38:53,930
if they migrate to a new piece of hardware.

488
00:38:53,930 --> 00:38:55,770
So, yeah, I'd like it to migrate.

489
00:38:55,770 --> 00:38:57,070
Does it belong in the Keychain?

490
00:38:57,070 --> 00:38:57,960
It's a credential.

491
00:38:57,960 --> 00:38:59,200
It belongs on the Keychain.

492
00:38:59,200 --> 00:39:01,210
So I'm going to put it on the Keychain and I'm going

493
00:39:01,210 --> 00:39:07,300
to give it the attribute AccessibleWhenUnlocked,
the best protection I can.

494
00:39:07,300 --> 00:39:10,190
I also have saved games which have similar attributes.

495
00:39:10,190 --> 00:39:16,340
Yes I-- actually, no, I do not need access to them
when they're locked, yes, I want them to migrate,

496
00:39:16,340 --> 00:39:18,500
but, no, they don't belong on the Keychain.

497
00:39:18,500 --> 00:39:22,020
So the protection class I give them is
ProtectionComplete, and I use their location

498
00:39:22,020 --> 00:39:24,000
on the file system to control their migration.

499
00:39:24,000 --> 00:39:28,430
I put them in my documents folder in my app, and those
automatically get me moved into my backup and moved back

500
00:39:28,430 --> 00:39:35,190
to my app, and they're accessible when
I won't migrate from device to device.

501
00:39:35,190 --> 00:39:38,430
Second example is an online service.

502
00:39:38,430 --> 00:39:41,190
So suppose I have an online service
that has decided to participate

503
00:39:41,190 --> 00:39:51,390
in a new background task completion multitasking type, and
it has some credentials, it has some data that is trying

504
00:39:51,390 --> 00:39:55,430
to push up to the server in the background, or it's trying
to not burden the user with failing to push my photo

505
00:39:55,430 --> 00:39:59,530
up to the server, and it has some
cash data it wants to display

506
00:39:59,530 --> 00:40:03,230
because it's got some stuff it's pulled
down from the server for fast access.

507
00:40:03,230 --> 00:40:06,080
And all of these are user data.

508
00:40:06,080 --> 00:40:07,820
So start with the service credentials.

509
00:40:07,820 --> 00:40:11,900
I have some service credentials that I do need
when it's locked because I'm participating

510
00:40:11,900 --> 00:40:15,390
in background task completion, and I might
change networks and need to reconnect

511
00:40:15,390 --> 00:40:19,180
to actually complete the operation I'm doing with my server.

512
00:40:19,180 --> 00:40:22,550
So next question is do I want to migrate this data?

513
00:40:22,550 --> 00:40:26,680
Well, it's credentials, they belong to a user, I'm-- I
pretty much want it to migrate so my service will work

514
00:40:26,680 --> 00:40:29,330
on the new device it get to right out the box.

515
00:40:29,330 --> 00:40:30,460
And does it belong in the Keychain?

516
00:40:30,460 --> 00:40:31,490
Well, yes, it's a credential.

517
00:40:31,490 --> 00:40:33,700
It belongs in the Keychain.

518
00:40:33,700 --> 00:40:39,600
So the protection I give it is AccessibleAfterFirstUnlocked.

519
00:40:39,600 --> 00:40:41,400
This is the second category of protection.

520
00:40:41,400 --> 00:40:45,460
It's not quite as good, as AlwaysIsProtectedWhenUnlocked,

521
00:40:45,460 --> 00:40:49,220
but it does give us some protection
against the task that require a reboot.

522
00:40:49,220 --> 00:40:52,930
So we choose the second best protection
because we want the user experience to be good.

523
00:40:52,930 --> 00:40:55,290
The second class of data we have
is a data that's being uploaded.

524
00:40:55,290 --> 00:40:58,500
So I have some data the users put in the background.

525
00:40:58,500 --> 00:41:00,830
Do I want this access to the data when it's locked?

526
00:41:00,830 --> 00:41:04,130
Yes. Do I want this data to migrate?

527
00:41:04,130 --> 00:41:05,680
No, this is an in-process operation.

528
00:41:05,680 --> 00:41:06,980
This data's going to go up to the server.

529
00:41:06,980 --> 00:41:08,610
I don't need this data to move.

530
00:41:08,610 --> 00:41:09,760
Does it belong on the Keychain?

531
00:41:09,760 --> 00:41:11,550
No it doesn't belong on the Keychain.

532
00:41:11,550 --> 00:41:13,380
It's bulk data, it's a big file.

533
00:41:13,380 --> 00:41:16,740
So I have to put it on the file
system, and I've put in ProtectionNone.

534
00:41:16,740 --> 00:41:23,190
We have to admit we did not provide file
system API's to get to the second class.

535
00:41:23,190 --> 00:41:26,150
We didn't think they were as valuable as they might be,

536
00:41:26,150 --> 00:41:30,540
and if you find reasons why they are
interesting to you, we'd love to hear them.

537
00:41:30,540 --> 00:41:36,700
This is a case where it might be interesting, but in
this case, we choose ProtectionNone and we put the file

538
00:41:36,700 --> 00:41:40,870
in a place it doesn't migrate, which would be the
cache's directory in your application, for example.

539
00:41:40,870 --> 00:41:46,800
Cash data, on the other hand, we don't need when the device
is locked, because it's for-- presenting data to the user.

540
00:41:46,800 --> 00:41:49,570
And when the device is locked, we
don't present anything to the user.

541
00:41:49,570 --> 00:41:54,380
We don't need this to migrate, it's caches.

542
00:41:54,380 --> 00:41:55,110
We might choose to.

543
00:41:55,110 --> 00:41:57,150
But in this case, we don't care to.

544
00:41:57,150 --> 00:41:59,230
Does not belong on the Keychain.

545
00:41:59,230 --> 00:42:01,000
It's large data.

546
00:42:01,000 --> 00:42:05,970
So we put it in ProtectionComplete which
protects it when the device is locked,

547
00:42:05,970 --> 00:42:09,450
and we put in it our caches directory so it doesn't migrate.

548
00:42:09,450 --> 00:42:13,260
The final example is a relative
simple example if I make a diary.

549
00:42:13,260 --> 00:42:17,280
It's a place somebody can record their
thoughts, whatever they want to put in there,

550
00:42:17,280 --> 00:42:20,710
their credit numbers because they are crazy.

551
00:42:20,710 --> 00:42:26,560
So I have this diary which is on the device, and we
don't need it when it's locked because it's for the user.

552
00:42:26,560 --> 00:42:31,880
We do want it to migrate, and we don't want another Keychain

553
00:42:31,880 --> 00:42:35,260
because its large unknown pictures,
whatever they use or want to enter.

554
00:42:35,260 --> 00:42:36,860
But we do want to protect it.

555
00:42:36,860 --> 00:42:39,520
So we put it in ProtectionComplete.

556
00:42:39,520 --> 00:42:43,850
This allows it to be protected with Data
Protection, and we put it in our documents folder

557
00:42:43,850 --> 00:42:47,570
for our app, probably the simplest example of all.

558
00:42:47,570 --> 00:42:52,000
So once you've made your protection choices, and you've put
your data into an appropriate class, there is one more thing

559
00:42:52,000 --> 00:42:55,980
that you want to do when you adopt,
particularly, if you are an app that's running

560
00:42:55,980 --> 00:42:57,840
on the background or running while the systems is locked.

561
00:42:57,840 --> 00:43:02,450
Your app does not really care with the systems is locked,
and just pretty much left this data on the file system

562
00:43:02,450 --> 00:43:06,750
and tries to quit if the system locks,
you'd-- there's not a lot you have to do here.

563
00:43:06,750 --> 00:43:10,640
But if you are a background app, or want to
operate while the system is heading towards lock,

564
00:43:10,640 --> 00:43:12,720
there are some stuff you need to do.

565
00:43:12,720 --> 00:43:14,390
There is a notification that comes through.

566
00:43:14,390 --> 00:43:18,500
There is actually a symmetric one for this also,
that says protection data will become unavailable.

567
00:43:18,500 --> 00:43:22,070
This is a symmetric one that says become
available, but it's less interesting.

568
00:43:22,070 --> 00:43:26,270
It's just telling you, you get your data back, and
then you can choose to access your data at that point.

569
00:43:26,270 --> 00:43:30,140
This one is relatively important
because it does give you a moment

570
00:43:30,140 --> 00:43:32,990
in which you can help enforce the security of the users' data.

571
00:43:32,990 --> 00:43:39,140
In response to this notification, we ask that you
purge the data in memory that is not necessarily--

572
00:43:39,140 --> 00:43:41,540
that is not necessary when the device is locked.

573
00:43:41,540 --> 00:43:46,120
Specifically, we want you to take the data that
needs protection, put it back into the containers

574
00:43:46,120 --> 00:43:49,700
that it's supposed to be protected
in, and close those containers.

575
00:43:49,700 --> 00:43:54,280
So you push it back in the file system, you push it back
on the Keychain, you get it out of your local address base,

576
00:43:54,280 --> 00:44:00,330
so that if somebody is clever enough to grovel
your memory, they won't get that data either.

577
00:44:00,330 --> 00:44:06,000
In order to make our system actually have a predictable
behavior about locking, we have to give an upper bound

578
00:44:06,000 --> 00:44:09,930
to how long an application can hold us off
from causing the system to actually lock.

579
00:44:09,930 --> 00:44:12,580
So you actually have-- only have 10
seconds to complete this notification.

580
00:44:12,580 --> 00:44:18,660
If you don't complete this operation in 10
seconds, we're going to lock the device behind you.

581
00:44:18,660 --> 00:44:21,840
The reason why that is interesting
is once the device is locked,

582
00:44:21,840 --> 00:44:26,510
you don't get access to the data
that's in the highest protection class.

583
00:44:26,510 --> 00:44:31,550
You will actually get errors trying to reach in the files
to get EPERM errors saying, no, can't read that data.

584
00:44:31,550 --> 00:44:37,630
We want you to be resilient to those kinds of failures,
not necessarily your app has to keep chugging along

585
00:44:37,630 --> 00:44:44,980
and doing great, but don't crash, don't do spectacularly
bad things for the user, considering that that might happen.

586
00:44:47,810 --> 00:44:50,530
To move on to some interfaces in the file system.

587
00:44:50,530 --> 00:44:53,850
So how do I create and set this attributes.

588
00:44:53,850 --> 00:44:56,460
I need to help the system know.

589
00:44:56,460 --> 00:45:00,940
There are two API's we've added to help
you communicate to the file system,

590
00:45:00,940 --> 00:45:03,330
what protection class, you want your data in.

591
00:45:03,330 --> 00:45:09,240
The first is in NSData writeToFile,
there are new options added.

592
00:45:09,240 --> 00:45:15,570
The file that is created will get the ProtectionComplete
or ProtectionNone, depending on the option you include.

593
00:45:15,570 --> 00:45:22,690
The second is NSFileManager, has an API to set an
attribute of the file, which is the protection key,

594
00:45:22,690 --> 00:45:26,300
which will then set the class of the
file, the protection class of the file.

595
00:45:26,300 --> 00:45:30,630
You can use this on any existing file on the file system.

596
00:45:30,630 --> 00:45:31,300
It's sticky.

597
00:45:31,300 --> 00:45:36,810
And then once you set the class for the file, it retains
that class in the file, you don't have to tell us again.

598
00:45:36,810 --> 00:45:42,930
And most importantly, you can use any other file system
access you want to, and then it will operate normally,

599
00:45:42,930 --> 00:45:47,640
except for the fact that if the device locks, and it's in
a locked class, we'll get errors when trying to access it.

600
00:45:47,640 --> 00:45:52,050
So if you are creating a file to hand
off to another subsystem on your device,

601
00:45:52,050 --> 00:45:54,500
you can set its class before you hand it off.

602
00:45:54,500 --> 00:46:01,860
If you know you've requested a file you created by
some other system, you can find it, set its class.

603
00:46:01,860 --> 00:46:07,180
The other thing we need to point out is that your
existing files that have been run long, your documents

604
00:46:07,180 --> 00:46:11,820
and your documents folder are not going to have
any protection classes except ProtectionAlways.

605
00:46:11,820 --> 00:46:17,770
So if you want to protect that data for the user, which
we hope you do, you need to actually find those documents

606
00:46:17,770 --> 00:46:22,430
and set the protection class on
the files in those documents.

607
00:46:22,430 --> 00:46:26,780
So choosing your protection on the file
system, this actually will be simple.

608
00:46:26,780 --> 00:46:30,420
Use ProtectionComplete, you know, protect the user's data.

609
00:46:30,420 --> 00:46:34,670
Right up until you find a good reason
that you can't protect their data.

610
00:46:34,670 --> 00:46:38,450
You need to use it when you are in the
background, this is probably the most popular.

611
00:46:38,450 --> 00:46:40,400
I really can't think of many other
reasons why you wouldn't want

612
00:46:40,400 --> 00:46:44,870
to protect the user's data, although
you might come up with some.

613
00:46:44,870 --> 00:46:50,050
The Keychain has new interfaces, now just
new attributes on its existing interfaces.

614
00:46:50,050 --> 00:46:57,330
SecItemAdd and SecItemUpdate have always taken
a query with the dictionary of parameters in it.

615
00:46:57,330 --> 00:47:03,200
There's a new attribute case like accessibility.

616
00:47:03,200 --> 00:47:10,010
You can give it one of these values, and that
will set the accessibility of your Keychain item.

617
00:47:10,010 --> 00:47:14,040
Just like the file system, the
Keychain needs update if you want

618
00:47:14,040 --> 00:47:18,620
to change the accessibility class of a given Keychain item.

619
00:47:18,620 --> 00:47:24,390
By default, when we move the Keychain back to the device
it came from because all backups that are currently

620
00:47:24,390 --> 00:47:28,880
out in the world, can only move back to the same device,
all the Keychains out there will go back to the same device.

621
00:47:28,880 --> 00:47:36,780
But when it returns to that device, we set all the data
to AccessibleAlways, which you should note is migratable.

622
00:47:36,780 --> 00:47:42,750
So if you really, don't want it to be migratable, you
should hit it with the hammer and tell it not to migrate.

623
00:47:42,750 --> 00:47:46,110
If you think it should be less protected because
you want to operate in the background now,

624
00:47:46,110 --> 00:47:48,830
your app's updating and wants to upgrade in the background.

625
00:47:48,830 --> 00:47:54,000
You may want to set its protection class
to be type to, AccessibleAfterFirstUnlock.

626
00:47:54,000 --> 00:48:02,050
If you don't need the data at all, except when you are
running unlocked, set it to AccessibleWhenUnlocked.

627
00:48:02,050 --> 00:48:04,920
So summarize that basic decision tree, the other direction.

628
00:48:04,920 --> 00:48:09,530
When you have data and you are trying to consider on
the Keychain, how am I going to protect this data?

629
00:48:09,530 --> 00:48:15,290
You should start with the most restrictive, but we
recommend migratable, which is AccessibleWhenUnlocked.

630
00:48:15,290 --> 00:48:18,880
That's probably the right class for the vast
majority of the data that is on the Keychain.

631
00:48:18,880 --> 00:48:25,770
But if you find reasons that you need to access a
credential when it's locked, the most obvious one I thought

632
00:48:25,770 --> 00:48:29,520
of is I need to get back to that server
because I was just told the network changed

633
00:48:29,520 --> 00:48:32,560
and I still have stuff to talk to that server about.

634
00:48:32,560 --> 00:48:37,600
Use AccessibleAfterFirstUnlock, that still
maintains some protection for the user's data,

635
00:48:37,600 --> 00:48:40,850
but let's you do the background operation.

636
00:48:40,850 --> 00:48:45,510
And if you really create data for this device
only, and really, if you create device--

637
00:48:45,510 --> 00:48:48,290
for this device only, be sure it's for this device only.

638
00:48:48,290 --> 00:48:55,380
And then you can make the user experience with that
data appropriate, and make it for this device only.

639
00:48:55,380 --> 00:48:59,910
But if you suddenly discover that that data was for the
user, when they go to a new device, they won't get it.

640
00:48:59,910 --> 00:49:03,110
So we recommended you think seriously
if you want it to stay on this device.

641
00:49:03,110 --> 00:49:03,720
But you will know.

642
00:49:03,720 --> 00:49:07,840
I mean, if you create a data that's for the device and
not for the user, that will be relatively obvious too.

643
00:49:07,840 --> 00:49:12,660
So a quick example of modifying the access a SecItemAdd,

644
00:49:12,660 --> 00:49:15,450
those of you who are using the
Keychain already will recognize this.

645
00:49:15,450 --> 00:49:21,580
You build the query, you called SecItemAdd
with that query as data to the Keychain.

646
00:49:21,580 --> 00:49:27,430
All you have to do is add one more set of attributes you put
in the query dictionary, kSecAttrAccessible, in this case,

647
00:49:27,430 --> 00:49:30,840
accessible and unlocked is the--
actually what we're requesting.

648
00:49:30,840 --> 00:49:32,460
And then you can use that SecItemAdd.

649
00:49:32,460 --> 00:49:34,860
You can also use the SecItemUpdate.

650
00:49:36,240 --> 00:49:41,550
So some way in our adoption, it's
relatively straightforward.

651
00:49:41,550 --> 00:49:47,970
We're asking you to protect your users' data, we're asking
you to choose the strongest protection class you can,

652
00:49:47,970 --> 00:49:53,620
and we're asking you to update the existing data
protection on the file system and on Keychain.

653
00:49:53,620 --> 00:49:55,790
We're also asking that you use the Keychain.

654
00:49:55,790 --> 00:49:57,700
It supports migration now.

655
00:49:57,700 --> 00:49:59,060
That was a big hindrance before.

656
00:49:59,060 --> 00:50:03,280
If people would put on the Keychain, they're-- you'd
migrate to a new device, your passwords would all be lost.

657
00:50:03,280 --> 00:50:04,460
It was really irritating for users.

658
00:50:04,460 --> 00:50:05,690
That's gone now.

659
00:50:05,690 --> 00:50:13,540
So we think we have all the reasons
or mood to now use the Keychain.

660
00:50:13,540 --> 00:50:20,050
So what we talked about today, John started talking
about why we want to help protect the user's data.

661
00:50:20,050 --> 00:50:28,190
These devices are all more mobile, they're much more
active, they actively do access in the background.

662
00:50:28,190 --> 00:50:31,130
The data on these devices are more
personal, and there's a lot more of it.

663
00:50:31,130 --> 00:50:34,940
So it has higher value, particularly to an appointed
attack, and it looks and says, hey, I want Mitch's data,

664
00:50:34,940 --> 00:50:39,500
I'm going to steal his phone, and get his data off of it.

665
00:50:39,500 --> 00:50:43,620
And we're willing to help deal with this,
we want to tie the data to a user's secret.

666
00:50:43,620 --> 00:50:50,170
That way, the user owns the secret, not us and not
our system, not penetrating the owner's system.

667
00:50:50,170 --> 00:50:55,030
The data protection model is to
protect the data with the passcode.

668
00:50:55,030 --> 00:51:00,500
So all the user data is supposed to protected with a
passcode to strengthen against devices that get compromised.

669
00:51:00,500 --> 00:51:04,160
So if somebody takes my device, they can break through
the front barriers that we think are pretty strong,

670
00:51:04,160 --> 00:51:07,330
but are not perfect, if they get through that,

671
00:51:07,330 --> 00:51:12,250
they still have to get through the
cryptographic protection with the user's passcode.

672
00:51:12,250 --> 00:51:20,580
We also protect the user passcode by tying its derivation to
a key to the hardware, so that brute force on that passcode,

673
00:51:20,580 --> 00:51:23,790
even if I have all the data inside the
device, if I've gotten into the device,

674
00:51:23,790 --> 00:51:26,660
requires I do operations on the device to attack it.

675
00:51:26,660 --> 00:51:32,450
I can't send it out to my botnet and get
a factor of a million on my attacks speed.

676
00:51:32,450 --> 00:51:35,040
We want data protection to always be on.

677
00:51:35,040 --> 00:51:40,070
It is always on when the user set his passcode.

678
00:51:40,070 --> 00:51:40,990
You can't have it off.

679
00:51:40,990 --> 00:51:44,430
You got a new passcode, data protection comes on.

680
00:51:44,430 --> 00:51:47,900
And to reiterate again, there is no performance impact.

681
00:51:47,900 --> 00:51:53,890
We're already encrypting and decrypting data as it goes
to and from the file system, and to and from the Keychain.

682
00:51:53,890 --> 00:51:58,040
All we've done in this update is change
the architecture of what keys we use

683
00:51:58,040 --> 00:52:02,520
when we push the data in and out of the storage systems.

684
00:52:02,520 --> 00:52:09,750
And lastly, we talked about was how you guys adopt
and help us make all the user's data protected.

685
00:52:09,750 --> 00:52:13,150
We're asking that all applications protect the user's data.

686
00:52:13,150 --> 00:52:17,790
Since user information is all over the place, any
application where I can have a text deal and enter data,

687
00:52:17,790 --> 00:52:19,900
I could put something that I want protected.

688
00:52:19,900 --> 00:52:21,600
We're adopting it.

689
00:52:21,600 --> 00:52:24,450
We're adopting it as quickly as we can.

690
00:52:24,450 --> 00:52:29,640
We chose mail first since it was one of our most
complicated ones to prove out that the technology worked.

691
00:52:29,640 --> 00:52:33,760
We're definitely going to be adding more apps.

692
00:52:33,760 --> 00:52:42,570
We're asking you to put your data into appropriate classes,
to update your existing data into the appropriate classes,

693
00:52:42,570 --> 00:52:45,450
and we really are trying to encourage
you to use the Keychain.

694
00:52:45,450 --> 00:52:49,420
We think there are no excuses left to
not use the Keychain for credentials.

695
00:52:49,420 --> 00:52:54,990
So if you are interested in any more
information about the presentation,

696
00:52:54,990 --> 00:52:58,410
you can contact our Evangelist
or you can check out the forms.

697
00:52:58,410 --> 00:53:02,830
There are few related sessions.

698
00:53:02,830 --> 00:53:09,900
The first ones of the Multitasking on iPhone have already
occurred, but there is rerun of them tomorrow morning.

699
00:53:09,900 --> 00:53:14,990
And, if you want to pay attention to
how you handle being a multitasking app,

700
00:53:14,990 --> 00:53:18,960
because those moments will be interesting
for you to decide about data protection.

701
00:53:18,960 --> 00:53:22,340
The Managing Mobile Devices session was last Tuesday.

702
00:53:22,340 --> 00:53:24,440
You can catch the replay when they are posted.

703
00:53:24,440 --> 00:53:26,850
It talks about how to configure
devices and manage them remotely.

