1
00:00:06,370 --> 00:00:07,500
>>David Chan: Good afternoon.

2
00:00:07,500 --> 00:00:08,860
My name is David Chan.

3
00:00:08,860 --> 00:00:16,080
I'm on the iOS Performance Team and I'll be joined by
colleague later Peter Handel whose on the iOS Power Team.

4
00:00:16,080 --> 00:00:22,930
So today, we're going to talk about Advanced
Performance Optimization on iPhone OS.

5
00:00:22,930 --> 00:00:25,260
And in particular this is Part 1 of two.

6
00:00:25,260 --> 00:00:31,670
We're going to be talking about animations,
scrolling, responsiveness, and battery life today.

7
00:00:32,730 --> 00:00:38,160
"The iPad is a far slower machine that a modern
MacBook in terms of raw hardware performance,

8
00:00:38,160 --> 00:00:41,440
but feels faster in many ways, because
you never have to wait for it."

9
00:00:41,440 --> 00:00:43,090
This is a great quote.

10
00:00:43,090 --> 00:00:46,900
Basically, what this is saying
is this is why you're here today.

11
00:00:46,900 --> 00:00:51,210
People love using the iPad, the iPhone and
iPod Touch because it's a magical experience.

12
00:00:51,210 --> 00:00:56,670
And a large part of that experience
is you never have to wait for it.

13
00:00:56,670 --> 00:01:02,460
So, great performance is all about
creating an outstanding user experience.

14
00:01:02,460 --> 00:01:08,660
So today, we're going to be covering the most
advanced topics, for our most advanced developers.

15
00:01:08,660 --> 00:01:11,490
We assumed that you've already
written an iPhone application,

16
00:01:11,490 --> 00:01:15,750
you've played with all the different aspects
of it, and you've seen the challenges.

17
00:01:15,750 --> 00:01:22,460
Today, we're going to be covering animation and
scrolling, responsiveness, and battery life.

18
00:01:22,460 --> 00:01:27,370
Tomorrow, we're going to be covering
memory, databases, and I/O.

19
00:01:27,370 --> 00:01:30,420
Be sure to show up for that one as well.

20
00:01:30,420 --> 00:01:35,350
So, across both of these talks, we're
going to be trying to give you a framework

21
00:01:35,350 --> 00:01:37,720
to solve your application performance challenges.

22
00:01:37,720 --> 00:01:39,030
Now what do we mean by that?

23
00:01:39,030 --> 00:01:42,060
First, we want you to learn as
much about the system as possible.

24
00:01:42,060 --> 00:01:45,990
You're going to use that knowledge as
a mental model so that when you come

25
00:01:45,990 --> 00:01:50,550
up with performance issues you can
think creatively about solving them.

26
00:01:51,710 --> 00:01:55,200
And finally, we want you to really measure progress.

27
00:01:55,200 --> 00:02:03,590
We built great tools into the iPhone SDK and we want you
to use them to see exactly what's happening on your system.

28
00:02:03,590 --> 00:02:09,460
Don't guess and be able to see that the changes
that you're making are making real progress.

29
00:02:09,460 --> 00:02:11,760
So let's jump in.

30
00:02:11,760 --> 00:02:14,660
Animation and scrolling is first up, so let's begin.

31
00:02:14,660 --> 00:02:22,620
So what we're going to be covering today is we're
going to go behind the scenes of the animation.

32
00:02:22,620 --> 00:02:25,160
Now you're all familiar on how to create an animation.

33
00:02:25,160 --> 00:02:28,150
We're going to see what happens
after you commit that animation.

34
00:02:28,150 --> 00:02:32,460
We're going to go into how to keep your
animations responsive, how to keep them smooth

35
00:02:32,460 --> 00:02:39,050
and how to keep all these nice scroll views
in your system very, very nice and smooth.

36
00:02:39,050 --> 00:02:42,970
So, here's a timeline diagram of a typical animation.

37
00:02:42,970 --> 00:02:47,190
Now it has three stages and we'll
walk through them one by one.

38
00:02:47,190 --> 00:02:49,660
First, you create your animation.

39
00:02:49,660 --> 00:02:51,170
Now this is pretty simple.

40
00:02:51,170 --> 00:02:52,630
You've probably seen this before.

41
00:02:52,630 --> 00:02:54,770
Use UIView, create animations.

42
00:02:54,770 --> 00:02:56,430
You changed some part of your view hierarchy.

43
00:02:56,430 --> 00:02:58,650
You maybe changed some properties.

44
00:02:58,650 --> 00:03:01,590
And then you commit it.

45
00:03:01,590 --> 00:03:03,880
So that's step two.

46
00:03:03,880 --> 00:03:09,660
Now this is where the system calls your
layoutSubviews, and drawRect calls.

47
00:03:09,660 --> 00:03:15,430
Now this is when the system is ready to take
your animation, ship it over the render server,

48
00:03:15,430 --> 00:03:17,860
and have that animation show up for the user.

49
00:03:17,860 --> 00:03:21,030
And that's the third process.

50
00:03:21,030 --> 00:03:25,940
Every single frame is rendered by the render
server for the length of your animation.

51
00:03:25,940 --> 00:03:28,760
So let's start with step one.

52
00:03:28,760 --> 00:03:33,810
So, this should be pretty simple code
for you guys, pretty familiar stuff.

53
00:03:33,810 --> 00:03:38,380
We're creating a view hierarchy
starting with that inside view.

54
00:03:38,380 --> 00:03:41,350
We're putting a little scale on to that.

55
00:03:41,350 --> 00:03:42,590
So that starts up very small.

56
00:03:42,590 --> 00:03:49,940
We're going to begin the animation and add that
new view hierarchy to our existing view hierarchy

57
00:03:49,940 --> 00:03:53,430
and then bring the transform up so it will become full size.

58
00:03:53,430 --> 00:03:58,040
So let's see what that looks like, great.

59
00:03:58,040 --> 00:04:01,280
So, this is what we just saw.

60
00:04:01,280 --> 00:04:06,830
We saw the existing view hierarchy there
and then we add a new part to that.

61
00:04:06,830 --> 00:04:09,630
So that's the card with image and that great label.

62
00:04:09,630 --> 00:04:12,980
So as you can see, they're not quite filled in yet.

63
00:04:12,980 --> 00:04:17,400
The next thing that happens in stage two is
that the animation is prepared for commit

64
00:04:17,400 --> 00:04:20,830
by calling layoutSubviews and drawRect
on each of those new views.

65
00:04:20,830 --> 00:04:26,230
So they just got filled in and now they're ready for commit.

66
00:04:26,230 --> 00:04:34,330
So, we have the new view hierarchy on the left here and what
render server thinks is going to be displayed on screen.

67
00:04:34,330 --> 00:04:38,350
And major part of commit is that this gets sent over.

68
00:04:38,350 --> 00:04:44,780
So now this towards syncs up and the transaction
of the animation is committed to the render server

69
00:04:44,780 --> 00:04:49,280
like you would commit a transaction to a database.

70
00:04:49,280 --> 00:04:51,490
So now we're on to stage three.

71
00:04:51,490 --> 00:04:53,670
Now for every single frame of your animation--

72
00:04:53,670 --> 00:04:59,210
the length of the animation, the render
server goes through these four steps.

73
00:04:59,210 --> 00:05:05,170
It takes the current time and looks over
the tree that it has for your application

74
00:05:05,170 --> 00:05:09,590
and sees what animations it needs
to update for the current time.

75
00:05:09,590 --> 00:05:15,970
So in our example, we have that scale starting
very, very small and coming up to full size.

76
00:05:15,970 --> 00:05:22,500
Now, every 160th of a second, that
scale gets interpolated to a new value

77
00:05:22,500 --> 00:05:26,220
so it gets just a little bit bigger,
a little bigger on every frame.

78
00:05:26,220 --> 00:05:34,840
So the second part is we calculate the
screen region that needs to be updated.

79
00:05:34,840 --> 00:05:40,040
This is important because our render server is
really, really great at figuring out, "Well,

80
00:05:40,040 --> 00:05:44,480
we don't need to update the whole screen, we
just need to update that things have changed.

81
00:05:44,480 --> 00:05:48,700
So it can walk over the tree and figure
this out in a very, very nice way.

82
00:05:48,700 --> 00:05:56,810
The third thing it does is it takes the whole view hierarchy
and constructs a scene using Quads and using the images

83
00:05:56,810 --> 00:06:03,400
that you draw-- that you drew into in your
image assets as textures and creates a series

84
00:06:03,400 --> 00:06:08,080
of graphic commands for the GPU to render this scene.

85
00:06:08,080 --> 00:06:14,770
Once it's handed off the GPU, it tells it to present the
rendered update to the display and this is a lot of stuff.

86
00:06:14,770 --> 00:06:18,050
And again, it happens on every single frame.

87
00:06:18,050 --> 00:06:20,830
Every 160th of a second, that's 16 milliseconds.

88
00:06:20,830 --> 00:06:23,060
Not a long time right?

89
00:06:23,060 --> 00:06:27,530
So that's behind the scenes of animations.

90
00:06:27,530 --> 00:06:31,860
Let's talk about what can go wrong in stage two.

91
00:06:31,860 --> 00:06:39,240
So, like I said before we create,
commit and render an animation.

92
00:06:39,240 --> 00:06:43,620
And when you create the animation,
you can often set a delay--

93
00:06:43,620 --> 00:06:48,910
or, I'm sorry, a duration, and when you
create that duration, you're basically saying,

94
00:06:48,910 --> 00:06:54,390
"I want the animation to start and
end within this amount of time."

95
00:06:54,390 --> 00:06:59,260
So as you can see, the start of that duration
starts as soon as you create the animation.

96
00:06:59,260 --> 00:07:05,830
Now if you spend too much time preparing and committing that
animation, you know, maybe you spent too many time drawing,

97
00:07:05,830 --> 00:07:13,640
you spent too much time laying out subviews, creating
views, that can end up with a pretty serious delay.

98
00:07:13,640 --> 00:07:16,050
So what can you do?

99
00:07:16,050 --> 00:07:22,570
Well, the first thing that we use-- that we'd say
you should do is to draw less when you're preparing.

100
00:07:22,570 --> 00:07:28,150
So it only invalidates views that need to be
updated, only call setNeedsDisplay on visible views,

101
00:07:28,150 --> 00:07:35,530
if you call on hidden views, they'll still get drawn,
and only implement drawRect when absolutely needed.

102
00:07:35,530 --> 00:07:37,480
Now if you're going to have an empty drawRect,

103
00:07:37,480 --> 00:07:42,720
this still matter because the system has
to allocate a backing store for this.

104
00:07:42,720 --> 00:07:46,120
Second, you should invalidate smaller
regions of large views.

105
00:07:46,120 --> 00:07:51,950
If you have large views and let's say you
implement something like a painting program,

106
00:07:51,950 --> 00:07:59,460
we have a great mechanism built into systems that you can
implement a smart drawRect and use setNeedsDisplayInRect

107
00:07:59,460 --> 00:08:06,170
so that you can, for example like in the painting
program, only invalidate the regions around touches.

108
00:08:06,170 --> 00:08:11,730
And finally, if that isn't your kind of program,
you know, you should think about taking large views

109
00:08:11,730 --> 00:08:16,260
and decomposing them into the parts that
stay the same and the parts that change.

110
00:08:16,260 --> 00:08:22,020
So the other part of preparing an
animation is if you use image assets.

111
00:08:22,020 --> 00:08:26,130
Your image assets are going to
get decompressed in stage two.

112
00:08:26,130 --> 00:08:33,600
So we often see big delays because people are
using, you know, very, very large images or formats

113
00:08:33,600 --> 00:08:35,390
that just aren't appropriate for the device.

114
00:08:35,390 --> 00:08:39,150
So try to decompress and rescale big images sparingly.

115
00:08:39,150 --> 00:08:43,300
This will, you know, keep your animations quite responsive.

116
00:08:43,300 --> 00:08:47,030
And try to use the, you know, formats
that are optimized for iPhone.

117
00:08:47,030 --> 00:08:52,040
Or iPhone-optimized PNGs, those that are
added, your Xcode projects are great,

118
00:08:52,040 --> 00:08:54,770
and JPEG and TIFFs have different tradeoffs.

119
00:08:54,770 --> 00:09:02,410
JPEGs are small in disk but have, you know,
perhaps lost equality, whereas TIFFs are very large

120
00:09:02,410 --> 00:09:07,720
and so they make a little bit more
time to read off of storage.

121
00:09:07,720 --> 00:09:16,890
Finally, if you create any custom CGImages, we highly
encourage you to use to UIGraphics convenience functions.

122
00:09:16,890 --> 00:09:20,120
This will take care of the all the nitty-gritty details.

123
00:09:20,120 --> 00:09:25,640
And the problem-- the reason I'm mentioning is that if
you get those details a little bit wrong it's possible

124
00:09:25,640 --> 00:09:29,700
that the system will have to copy those
images for you into the right format.

125
00:09:29,700 --> 00:09:32,230
So try to avoid those.

126
00:09:32,230 --> 00:09:39,900
And you can use the Color Copied Images debug
option in the Core Animation Instrument to see them.

127
00:09:39,900 --> 00:09:43,260
So this is a big topic.

128
00:09:43,260 --> 00:09:45,990
People want to know how to make their animation smoother.

129
00:09:45,990 --> 00:09:51,380
So we're going to go through and talk about
exactly what happens behind the scenes.

130
00:09:51,380 --> 00:09:58,180
We're going to talk about some specific examples of how
you can improve your animations and we're going to look

131
00:09:58,180 --> 00:10:07,860
at a new feature in iPad and iOS 4 that I called dynamic
flattening that can help you create smoother animations.

132
00:10:07,860 --> 00:10:09,280
So let's begin.

133
00:10:09,280 --> 00:10:15,870
So, your server tries to render each frame
your animation at 60 times per second.

134
00:10:15,870 --> 00:10:21,490
This again is not very, very much
time to do any form of rendering.

135
00:10:21,490 --> 00:10:25,500
So, fewer pixels to render, means smoother animations.

136
00:10:25,500 --> 00:10:27,540
That means fewer input pixels.

137
00:10:27,540 --> 00:10:34,070
So, if you have very, very large images for
small view, that's not going to be great.

138
00:10:34,070 --> 00:10:42,880
If you have a lot of blended views, you're
going to end up with a lot more output pixels.

139
00:10:42,880 --> 00:10:47,260
And finally, few rendering passes
also means better animation.

140
00:10:47,260 --> 00:10:55,760
So like I said in the beginning, we want to
get you guys to measure what's going on here.

141
00:10:55,760 --> 00:11:00,690
So we're going to be using the Core Animation
Instrument and this is really simple to use.

142
00:11:00,690 --> 00:11:02,940
I hope every one of you has tried using this.

143
00:11:02,940 --> 00:11:10,340
You just plug in your device, launch instruments,
and select your application and hit record

144
00:11:10,340 --> 00:11:15,820
and it'll show you the number of frames
that were rendered in the last second.

145
00:11:15,820 --> 00:11:20,680
It gives you on a second by second basis that count.

146
00:11:20,680 --> 00:11:25,420
Now, when you're measuring, you want to make sure
that you measure the base line as in what it looks

147
00:11:25,420 --> 00:11:28,120
like right now and any changes that you make.

148
00:11:28,120 --> 00:11:31,460
So you make sure that you're actually making improvements.

149
00:11:31,460 --> 00:11:34,200
So I said before that this is a count.

150
00:11:34,200 --> 00:11:40,650
Now, one thing to keep on mind is our animation
from before was only about 300 milliseconds or so.

151
00:11:40,650 --> 00:11:44,200
And when I mentioned this the first
time, I only saw that I got 18 frames

152
00:11:44,200 --> 00:11:46,860
and I was really disappointed I thought that was quite slow.

153
00:11:46,860 --> 00:11:51,480
But it turns out that's actually the max that
we're hitting-- that we're shooting for right?

154
00:11:51,480 --> 00:12:00,950
So, at 60 frames per second is our target rate and although
I only rendered 18 frames, that was the correct number.

155
00:12:00,950 --> 00:12:06,760
So you have to do that division if you're going
to be measuring stuff at subsecond levels.

156
00:12:06,760 --> 00:12:11,130
But one thing that you can do and it's really
neat trick that I actually really like a lot.

157
00:12:11,130 --> 00:12:14,890
You can link in the animation over a few
seconds for much, much better measurements.

158
00:12:14,890 --> 00:12:17,880
And this helps reduce measurement jitter.

159
00:12:17,880 --> 00:12:20,860
This allows you to get the timing just right.

160
00:12:20,860 --> 00:12:26,960
And here we actually see that when I do
that, I was really happy and surprised

161
00:12:26,960 --> 00:12:30,520
that I got 60 frames a second over
the course of that animation.

162
00:12:30,520 --> 00:12:35,140
So, fewer pixels to render mean smoother animation.

163
00:12:35,140 --> 00:12:40,530
Now I've mentioned that the render server actually
looks over the whole view hierarchy and tries to figure

164
00:12:40,530 --> 00:12:43,110
out exactly which screen regions need to be rendered.

165
00:12:43,110 --> 00:12:49,670
Now you can actually see, one, it figured out that I
needed a render using the Core Animation Instrument again.

166
00:12:49,670 --> 00:12:53,670
And we're going to be using the
flash updated regions check box.

167
00:12:53,670 --> 00:12:57,490
Now, what this will do is it will
cause parts of your application

168
00:12:57,490 --> 00:13:02,800
that are being updated by the renderer to flash yellow.

169
00:13:02,800 --> 00:13:06,280
Let's take a look of what that looks like.

170
00:13:06,280 --> 00:13:11,430
So, we're bringing in the card, it flashed
yellow, that's exactly what we want to see.

171
00:13:11,430 --> 00:13:17,930
So that gives you kind of a baseline to figure what
parts of the application I actually need to fiddle

172
00:13:17,930 --> 00:13:21,540
with for this animation that I care about.

173
00:13:21,540 --> 00:13:29,990
So, let's jump in to one specific way that you
can improve the smoothness of your animation.

174
00:13:29,990 --> 00:13:32,540
We said this before.

175
00:13:32,540 --> 00:13:38,530
You want to reduce the amount of you blending
in your animation and in your view hierarchy.

176
00:13:38,530 --> 00:13:42,760
So again, let's take a look at how you can see that.

177
00:13:42,760 --> 00:13:47,200
So Core Animation Instrument, we're going
to be checking color blended layers.

178
00:13:47,200 --> 00:13:50,470
And let's take a look at what that looks like.

179
00:13:50,470 --> 00:13:53,830
So, we have the same view from before except

180
00:13:53,830 --> 00:13:58,340
that now the opaque regions are shaded green
and the blended regions are shaded red.

181
00:13:58,340 --> 00:14:08,190
And as you can see towards the top, the regions
that are even deeper blended are darkened red.

182
00:14:08,190 --> 00:14:10,070
So, why does this matter?

183
00:14:10,070 --> 00:14:16,420
Well, the graphic system can form a certain number of
pixel operations per frame to maintain a smooth frame rate.

184
00:14:16,420 --> 00:14:20,140
And blending requires more operations per on-screen pixel.

185
00:14:20,140 --> 00:14:29,300
So if you're just putting down an opaque view onto screen,
you can just write each of those pixels out, right?

186
00:14:29,300 --> 00:14:38,050
If you have to blend, the graphic system has to read the
value there and then write the ending pixel because it needs

187
00:14:38,050 --> 00:14:41,830
to figure out what is actually blending to, right?

188
00:14:41,830 --> 00:14:48,290
So the second reason is, the graphic system
supports efficient hidden surface removal.

189
00:14:48,290 --> 00:14:52,140
That is if something is fully occluded
then we can get rid of it.

190
00:14:52,140 --> 00:14:54,060
And it doesn't even have to touch that surface.

191
00:14:54,060 --> 00:14:56,050
Never even gets rendered.

192
00:14:56,050 --> 00:15:01,830
So-- But it can only avoid views that
are completely occluded by opaque views.

193
00:15:01,830 --> 00:15:09,480
So by having all the views that should be opaque,
be opaque and you can help out the graphic system

194
00:15:09,480 --> 00:15:13,280
and it can render your animation very smoothly.

195
00:15:13,280 --> 00:15:20,780
So, I mentioned that the graphic system can perform
certain number of operations per frame and we're going

196
00:15:20,780 --> 00:15:25,060
to take a look at what that means for
opaque views and for blended views.

197
00:15:25,060 --> 00:15:32,860
So here on the left, we have that view of
my animation with color blended layers on

198
00:15:32,860 --> 00:15:36,500
and you can see the opaque ones
are green and the blended ones red.

199
00:15:36,500 --> 00:15:44,750
And on the right, we have a rectangle that represents the
approximate number of pixel operations per frame at 60 bits.

200
00:15:44,750 --> 00:15:51,420
So let's see what happens when we bring over the
opaque pixel, the opaque views when they get drawn.

201
00:15:51,420 --> 00:15:53,130
I'm sorry, when they get rendered.

202
00:15:53,130 --> 00:16:00,600
So as you can see they're overlapping over on the
actual view and they're overlapping here as well.

203
00:16:00,600 --> 00:16:02,380
Now why is that?

204
00:16:02,380 --> 00:16:07,120
That's because our graphic system supports
something called differed rendering.

205
00:16:07,120 --> 00:16:13,190
Basically, what allow us to do is figure out
what's overlapping what and we don't need

206
00:16:13,190 --> 00:16:20,700
to spend anymore time drawing things-- I'm sorry, rendering
things that are just going to be overlapped anyway.

207
00:16:20,700 --> 00:16:25,860
However, we can still have these blended views left.

208
00:16:25,860 --> 00:16:28,180
So let's see what happens when we bring those over.

209
00:16:28,180 --> 00:16:36,690
So as you can see, the number of pixel operations
that this blended views take up don't take advantage

210
00:16:36,690 --> 00:16:41,540
of this optimization and so the use up
even more pixel operations per frame.

211
00:16:41,540 --> 00:16:43,250
So what can you do about it?

212
00:16:43,250 --> 00:16:50,110
Well, first it's important to understand how
views get marked as needing to be blended.

213
00:16:50,110 --> 00:16:51,940
Contents determine the blendings.

214
00:16:51,940 --> 00:16:54,520
So there are three ways that happens.

215
00:16:54,520 --> 00:17:01,290
First, views that are drawn or by default part
is opaque and you have to actually set that--

216
00:17:01,290 --> 00:17:05,110
set the flag to no and implement drawRect.

217
00:17:05,110 --> 00:17:08,080
Once you do that, it's been blended.

218
00:17:08,080 --> 00:17:17,350
Second, the use image assets like PNGs,
they often can contained an alpha channel.

219
00:17:17,350 --> 00:17:23,240
If you look in your image assets with
preview and hit the Get Info button,

220
00:17:23,240 --> 00:17:26,970
you can actually see whether or not your PNGs have alpha.

221
00:17:26,970 --> 00:17:33,480
And if you didn't intend for that image asset to be
blended in your system, then you really should go

222
00:17:33,480 --> 00:17:38,500
in to your Image Editor, resave
that, and get rid of that alpha.

223
00:17:38,500 --> 00:17:46,200
The third way that views can become blended is by
creating opaque-- sorry, creating custom CGImages.

224
00:17:46,200 --> 00:17:53,850
And if you use the UIGraphics convenience functions,
we make it really easy to have you pass yes

225
00:17:53,850 --> 00:17:58,490
to opaque and then the image ends up being opaque.

226
00:17:58,490 --> 00:18:03,340
So these are the ways that contents
become blended or opaque.

227
00:18:03,340 --> 00:18:07,480
And the next question is, well, what
else can you do about it, right?

228
00:18:07,480 --> 00:18:14,760
Once you've fixed all the accidental blending in your
views, let's say you still have a lot of blending.

229
00:18:14,760 --> 00:18:21,030
Well, the next thing to remember is that it's the number
of pixels that are rendered and the number of pixels

230
00:18:21,030 --> 00:18:25,140
that are blended that impact the performance of this.

231
00:18:25,140 --> 00:18:30,010
And so, if you decompose a large blended
view into the parts that actually need

232
00:18:30,010 --> 00:18:33,480
to be blended and the parts that are still opaque.

233
00:18:33,480 --> 00:18:39,010
Even though that ends up being more views,
that still ends up with better performance.

234
00:18:39,010 --> 00:18:43,670
OK. So that's view blending.

235
00:18:43,670 --> 00:18:49,430
Now we're going to move on to talking
about Offscreen rendering.

236
00:18:49,430 --> 00:18:51,380
So what is Offscreen rendering?

237
00:18:51,380 --> 00:18:58,020
Well, to achieve certain effects on our system,
the compositor or the render server needs

238
00:18:58,020 --> 00:19:03,590
to use a temporary offscreen region
in order to achieve the final effect.

239
00:19:03,590 --> 00:19:12,870
And one way of thinking about this is how a painter will
use their color pallette and take two colors together

240
00:19:12,870 --> 00:19:18,340
and mix them before painting on their final canvas.

241
00:19:18,340 --> 00:19:22,710
So why is this slow?

242
00:19:22,710 --> 00:19:30,530
Well, besides the fact that you are rendering more pixels,
you're rendering to this offscreen context and then taking

243
00:19:30,530 --> 00:19:34,100
that and then rendering to the final display.

244
00:19:34,100 --> 00:19:37,880
You're also switching between this
main and offscreen context

245
00:19:37,880 --> 00:19:42,520
and they'll stall the graphics pipeline
and, you know, really hurt performance.

246
00:19:42,520 --> 00:19:46,740
So let's take a look at how you can
detect this into your own animations.

247
00:19:46,740 --> 00:19:51,400
So again, we're going to use the Core
Animation Instrument and we're going

248
00:19:51,400 --> 00:19:55,200
to be checking the Color Offscreen-Rendered Yellow flag.

249
00:19:55,200 --> 00:20:04,810
Now this shades yellow portions of your animation that had
to be rendered offscreen and then back to the main screen.

250
00:20:04,810 --> 00:20:09,110
So this isn't quite as easy as blended views.

251
00:20:09,110 --> 00:20:14,890
I can't just tell you to go find the blended views
that aren't supposed to be blended and get rid of them.

252
00:20:14,890 --> 00:20:20,930
Avoiding this kind of offscreen rendering
requires some creative solutions.

253
00:20:20,930 --> 00:20:28,690
So let's take a look at couple of examples
and some workarounds that we come up for you.

254
00:20:28,690 --> 00:20:39,200
So let's say I have an animation where I take an image with
a background color and I fade opacity from solid to blank.

255
00:20:39,200 --> 00:20:44,310
So it looks something like this
which have the image, we have--

256
00:20:44,310 --> 00:20:50,420
set the background color and we begin an
animation, set the alpha to 0 and it fades away.

257
00:20:50,420 --> 00:20:57,450
Now to composite correctly, the image
needs to be composited over the color

258
00:20:57,450 --> 00:21:03,170
at full opacity offscreen and then blended into the view.

259
00:21:03,170 --> 00:21:05,920
So let's take a look at that.

260
00:21:05,920 --> 00:21:15,400
So, you can see that the blue in the iTunes icon
and the greens in the face in the photos look right.

261
00:21:15,400 --> 00:21:16,660
They're faded over black.

262
00:21:16,660 --> 00:21:18,170
They're just dimmed a little bit.

263
00:21:18,170 --> 00:21:28,040
Now, what I mean correctly, one naive way of trying to avoid
this kind of offscreen rendering is just to say what happens

264
00:21:28,040 --> 00:21:37,460
if I just blend that orange color into the background
at the lower opacity and then blend in the image.

265
00:21:37,460 --> 00:21:40,780
So you basically break this out into two separate layers.

266
00:21:40,780 --> 00:21:43,540
Let's take a look at what that looks like.

267
00:21:43,540 --> 00:21:47,120
So as you can see, the image doesn't look quite right.

268
00:21:47,120 --> 00:21:54,530
You know, the-- the blue isn't quite right and, you
know, the face in the background gets this orange tint.

269
00:21:54,530 --> 00:22:00,430
So let's take a look at some other
ways that you might approach this.

270
00:22:00,430 --> 00:22:11,340
So one workaround is to composite the background
color and image in drawRect first just like that.

271
00:22:11,340 --> 00:22:17,110
And then when you faded out, so here we've actually
drawn it and then when it's actually faded out,

272
00:22:17,110 --> 00:22:22,090
when it's being rendered, it doesn't have to
go offscreen and just fades out very nicely.

273
00:22:22,090 --> 00:22:30,410
So this falls in the category of thinking about what
the graphic system needs to do to render that offscreen

274
00:22:30,410 --> 00:22:34,040
and do it ahead of time using Core Graphics in drawRect.

275
00:22:34,040 --> 00:22:36,670
So, one more workaround.

276
00:22:36,670 --> 00:22:41,890
So if we're fading over a static
background like here, this is great.

277
00:22:41,890 --> 00:22:43,330
We have a black background.

278
00:22:43,330 --> 00:22:45,890
You know, nothing is changing behind it.

279
00:22:45,890 --> 00:22:47,800
There are no patterns.

280
00:22:47,800 --> 00:22:54,390
You can try fading in a view that contains
the background over the view instead.

281
00:22:54,390 --> 00:22:55,970
So it might look something like this.

282
00:22:55,970 --> 00:23:00,230
We just create a new view with the bounds of our view.

283
00:23:00,230 --> 00:23:05,850
We set the background color to black
and then we fade in from 0 to 1 instead.

284
00:23:05,850 --> 00:23:07,740
So let's see what that looks like.

285
00:23:07,740 --> 00:23:11,000
It's great, it looks exactly the same.

286
00:23:11,000 --> 00:23:19,350
So the lesson to this is if you see a situation where
you have offscreen rendering, this often alternate ways

287
00:23:19,350 --> 00:23:24,240
of getting the same effect, visually
by using a different technique.

288
00:23:24,240 --> 00:23:29,760
Let's take a look at another example.

289
00:23:29,760 --> 00:23:39,990
So new on iPad and iOS 4, CALayers now support
this great property called cornerRadius.

290
00:23:39,990 --> 00:23:46,230
And this allows you to get these nice
rounded corners on your views really easy,

291
00:23:46,230 --> 00:23:50,110
you pop that layer-- you pop that property on.

292
00:23:50,110 --> 00:23:54,540
Now, animating a view with a rounded
corner mask, as you will find out,

293
00:23:54,540 --> 00:24:01,000
requires that the renderer would go
offscreen, render your image and then apply

294
00:24:01,000 --> 00:24:04,570
that mask that contains the rounded corner.

295
00:24:04,570 --> 00:24:09,640
Now, this actually applies to all
masking that's non-pixel aligned.

296
00:24:09,640 --> 00:24:16,200
So if you have an arbitrary mask layer that you
assign to a CALayer, you'll see this as well.

297
00:24:16,200 --> 00:24:24,230
Or if you're moving a view that has clips to
bounds set and it's moving on non-pixel boundaries.

298
00:24:24,230 --> 00:24:29,250
In any case, let's take a look
at the rounded corner example.

299
00:24:29,250 --> 00:24:31,220
So, what can we do about it?

300
00:24:31,220 --> 00:24:33,260
Well, again, we have two Workarounds.

301
00:24:33,260 --> 00:24:38,820
The first is to try to achieve the same
effect in Core Graphics ahead of time.

302
00:24:38,820 --> 00:24:46,790
New on iPad and iOS 4 is this great UIBezierPath API and
allows us to just to draw a path with that rounded rect

303
00:24:46,790 --> 00:24:55,790
with those great rounded corners and we set that as the
clipping region for whatever we draw into our background.

304
00:24:55,790 --> 00:24:59,140
So when we draw, the rounded corners come with it.

305
00:24:59,140 --> 00:25:03,630
Now of course, this only works if the
corners don't have to clip anything

306
00:25:03,630 --> 00:25:06,200
that actually goes outside of the rounded areas.

307
00:25:06,200 --> 00:25:09,960
But in our original situation, it works great.

308
00:25:09,960 --> 00:25:17,540
So the second workaround is to decompose
rounded corners into separate views.

309
00:25:17,540 --> 00:25:24,860
So basically, all that means is that you're creating
four small views that are positioned around your view

310
00:25:24,860 --> 00:25:27,690
that have a little black sliver drawn into it.

311
00:25:27,690 --> 00:25:31,020
And here are some codes for the top left corner.

312
00:25:31,020 --> 00:25:32,260
That's pretty simple.

313
00:25:32,260 --> 00:25:37,420
Again, this is one of those cases where
you can achieve the same visual effect just

314
00:25:37,420 --> 00:25:41,810
by using a different technique and
you can avoid offscreen rendering.

315
00:25:41,810 --> 00:25:48,500
OK, those are some ways that you
can avoid offscreen rendering.

316
00:25:48,500 --> 00:25:53,140
Remember fewer pixels to render means smoother animations.

317
00:25:53,140 --> 00:25:57,640
And that means fewer rendering passes
also means smoother animations.

318
00:25:57,640 --> 00:26:02,110
So let's talk about that new feature
I talked about, dynamic flattening.

319
00:26:02,110 --> 00:26:08,070
Now this is new in iOS 4 and on the iPad.

320
00:26:08,070 --> 00:26:17,120
And the reason we added this is that animating
changes to a complex view hierarchy can be choppy.

321
00:26:17,120 --> 00:26:29,020
So here we have the little subhierarchy that we added to
our existing hierarchy in our app for the Core Animation.

322
00:26:29,020 --> 00:26:31,700
Now why do I say this is slow?

323
00:26:31,700 --> 00:26:34,410
Well, it renders the hierarchy on every single frame.

324
00:26:34,410 --> 00:26:44,990
So as it's scaling in it works over that tree,
renders those subviews together and then scales it.

325
00:26:44,990 --> 00:26:48,940
So this animation would be smoother
with a flattened hierarchy, right?

326
00:26:48,940 --> 00:26:50,760
You do the work once.

327
00:26:50,760 --> 00:26:56,610
You draw it in drawRect and then just have
that scale it overtime, surely a lot faster.

328
00:26:56,610 --> 00:27:05,380
But as I'm sure you guys know it's kind of pain to change
your whole view hierarchy and then you lose the dynamism

329
00:27:05,380 --> 00:27:08,230
of being able to move views around it independently.

330
00:27:08,230 --> 00:27:13,540
So now you can flatten without changing
your view hierarchy using shouldRasterize.

331
00:27:13,540 --> 00:27:16,590
Let's see how you can use it.

332
00:27:16,590 --> 00:27:19,890
So like I said it's a CALayer property.

333
00:27:19,890 --> 00:27:26,380
Generally, the way you want to use it is you want to turn
it on before animations and turn it off after animations.

334
00:27:26,380 --> 00:27:29,010
Let's take a look at some code.

335
00:27:29,010 --> 00:27:32,890
So this is using the new animateWithDuration using blocks.

336
00:27:32,890 --> 00:27:37,100
So I'm just going to quickly walk through this example.

337
00:27:37,100 --> 00:27:39,250
So we created that scale before.

338
00:27:39,250 --> 00:27:43,270
Before the animation starts, we set shouldRasterize.

339
00:27:43,270 --> 00:27:49,920
And then during the animation, we just set the
Transformed to Identities so that brings it all the way up

340
00:27:49,920 --> 00:27:56,170
and then when the animation is done the
system will call my completion block here

341
00:27:56,170 --> 00:28:00,320
and all that it does is it sets
that shouldRasterize back to no.

342
00:28:00,320 --> 00:28:02,500
So let's see what that looks like.

343
00:28:02,500 --> 00:28:04,160
Let's see how it works.

344
00:28:04,160 --> 00:28:06,550
So here we have the subview hierarchy again.

345
00:28:06,550 --> 00:28:17,450
And we're going to hint the compositor that it should
render this view hierarchy offscreen and then cache.

346
00:28:17,450 --> 00:28:21,180
Now I just warned you a whole lot
about avoiding offscreen rendering.

347
00:28:21,180 --> 00:28:25,050
But I want to assure you this time,
this offscreen rendering for good.

348
00:28:25,050 --> 00:28:27,670
And this is how it's going to work.

349
00:28:27,670 --> 00:28:33,340
When we render for the first time, it's actually going to
render into this offscreen region and then it's cached.

350
00:28:33,340 --> 00:28:36,220
We're actually going to keep this around for frame to frame.

351
00:28:36,220 --> 00:28:43,630
And then on each step of the animation, it's
going to get rendered over just like that.

352
00:28:43,630 --> 00:28:50,520
So this is actually really, really nice
but it can hurt more than it can help.

353
00:28:50,520 --> 00:28:54,040
Don't turn on everywhere because
there's a limited cache size.

354
00:28:54,040 --> 00:29:01,210
And if you start setting lots of views with shouldRasterize,
you're going to overflow the cache and that ends

355
00:29:01,210 --> 00:29:06,670
up in a really, really bad situation,
ends up being much worse than before

356
00:29:06,670 --> 00:29:12,350
because essentially you're rendering every single view
that you set with shouldRasterize offscreen and the back

357
00:29:12,350 --> 00:29:14,640
on the screen and we just talked about how doing

358
00:29:14,640 --> 00:29:18,430
that in every frame can really, really
hurt your animation performance.

359
00:29:18,430 --> 00:29:25,050
And like any good cache, it throws away old results.

360
00:29:25,050 --> 00:29:29,690
So if you changed anything in your
view hierarchy during your animation.

361
00:29:29,690 --> 00:29:35,090
The render server actually has to throw away
that cached copy and then render a brand new one

362
00:29:35,090 --> 00:29:38,410
in order to actually show the proper results.

363
00:29:38,410 --> 00:29:43,850
So make sure you don't change anything during your
view hierarchy while you have shouldRasterize on,

364
00:29:43,850 --> 00:29:49,570
otherwise you ended up rendering
offscreen without great performance.

365
00:29:49,570 --> 00:29:52,030
So that's smooth animations.

366
00:29:52,030 --> 00:30:01,030
Remember, rendering fewer pixels means smoother animation
and that applies to blending, that's fewer output pixels

367
00:30:01,030 --> 00:30:06,260
that applies to rendering passes as well,
so reduce the amount of offscreen rendering.

368
00:30:06,260 --> 00:30:08,240
So let's talk about scrolling.

369
00:30:08,240 --> 00:30:11,970
Now, I talked a lot about animations first.

370
00:30:11,970 --> 00:30:16,540
But a lot of you probably care a little bit
more about scrolling now why did I do that?

371
00:30:16,540 --> 00:30:21,780
Well, it turns out that each frame
scrolling is a small animation.

372
00:30:21,780 --> 00:30:29,990
When you flick that scroll view every 160th
of a second is issued in brand new animation

373
00:30:29,990 --> 00:30:34,430
and that's calculating a new scroll
view and that's the implicit animation.

374
00:30:34,430 --> 00:30:36,540
It's going to prepare and commit that animation.

375
00:30:36,540 --> 00:30:39,130
So if you have a new cell coming on screen,

376
00:30:39,130 --> 00:30:44,260
your layout subviews gets called, your
self or rowAtIndexPath gets called.

377
00:30:44,260 --> 00:30:47,890
And the compositor has to render a brand new frame.

378
00:30:47,890 --> 00:30:52,080
So, the animation advice I gave earlier totally applies.

379
00:30:52,080 --> 00:30:55,340
Prepare yourself very quickly and then render very quickly.

380
00:30:55,340 --> 00:31:00,590
So here's another timeline diagram like I showed you before.

381
00:31:00,590 --> 00:31:07,310
As you can see these animations are squished together really
tight because they have to happen within 16 milliseconds

382
00:31:07,310 --> 00:31:10,490
in order to get that nice scrolling effect.

383
00:31:10,490 --> 00:31:16,590
So first thing that happens is that we create an
animation implicitly by calculating a new scroll position.

384
00:31:16,590 --> 00:31:19,530
We prepare and commit the animation.

385
00:31:19,530 --> 00:31:26,120
So this is what happens when your cell gets laid
out and this is where all the drawing happens.

386
00:31:26,120 --> 00:31:29,140
And finally the frame is rendered.

387
00:31:29,140 --> 00:31:33,740
Now, when I say the frame is rendered I really do
mean the whole table view gets rendered, right?

388
00:31:33,740 --> 00:31:38,580
Because every time you scroll, each of those
cells is moving in a different position.

389
00:31:38,580 --> 00:31:41,730
So, prepare cells quickly.

390
00:31:41,730 --> 00:31:45,710
Now, there are two major parts to preparation, right?

391
00:31:45,710 --> 00:31:48,730
There's layout and there's drawing.

392
00:31:48,730 --> 00:31:55,030
And on the layout side, that's when the table view gets
to tell you, "Well, you've adjusted the scroll position.

393
00:31:55,030 --> 00:32:00,080
Now give me your new cell if there's
a new cell appearing on screen.

394
00:32:00,080 --> 00:32:04,880
So you want to use the dequeueReusableCellWithIdentifier.

395
00:32:04,880 --> 00:32:06,490
We use those table cells.

396
00:32:06,490 --> 00:32:14,220
It's not necessary an advanced
tip but we do have to mention it.

397
00:32:14,220 --> 00:32:19,720
You will save a ton of time creating objects
and backing stores for each of those cells.

398
00:32:19,720 --> 00:32:24,390
And you know be sure to use unique
identifiers for similar cells.

399
00:32:24,390 --> 00:32:30,550
If you have lots of different kinds of cells in your table
view, don't spend the time to transform one to another.

400
00:32:30,550 --> 00:32:35,170
Use a little bit extra memory and
give them different identifiers.

401
00:32:35,170 --> 00:32:39,040
You can save time and you can get
those cells up really quickly.

402
00:32:39,040 --> 00:32:45,380
So the second part of preparation is drawing
and we've told a lot of you in the past

403
00:32:45,380 --> 00:32:48,060
to flatten a view hierarchy of your cells.

404
00:32:48,060 --> 00:32:49,810
And that's actually a really good idea.

405
00:32:49,810 --> 00:32:50,790
I like that.

406
00:32:50,790 --> 00:32:56,940
Because what it does is it reduces the amount of time
that it takes to render those cells in the table view.

407
00:32:56,940 --> 00:32:59,300
And so you end up with a nice scrolling effect, right?

408
00:32:59,300 --> 00:33:01,410
It's very, very smooth.

409
00:33:01,410 --> 00:33:07,420
However, I have seen some applications
where it scrolls nice and smoothly right

410
00:33:07,420 --> 00:33:11,730
up until you get a new cell and then it jumps.

411
00:33:11,730 --> 00:33:19,600
Now, what can happen here is too much cell
drawing, you can spend a lot of time drawing all

412
00:33:19,600 --> 00:33:25,210
of these views into the same cell and that isn't great.

413
00:33:25,210 --> 00:33:27,430
That's not a great experience.

414
00:33:27,430 --> 00:33:31,060
Your table view isn't scrolling very smoothly.

415
00:33:31,060 --> 00:33:37,160
So there's a nuance point and of course, you're going to
have to measure an experiment to see what works for you.

416
00:33:37,160 --> 00:33:42,810
But if you have that kind of scroll view in
your application where it scrolls very smoothly

417
00:33:42,810 --> 00:33:45,190
and then it jumps when you get a new cell.

418
00:33:45,190 --> 00:33:46,500
First measure it.

419
00:33:46,500 --> 00:33:52,220
But if you find that you spend a lot of
time drawing cells I have a tip for you.

420
00:33:52,220 --> 00:33:59,890
So elements that need to be rasterized
anyway, text labels, things with pads.

421
00:33:59,890 --> 00:34:02,120
Be sure to just flatten those together that make sense.

422
00:34:02,120 --> 00:34:03,950
Just flatten all those labels together.

423
00:34:03,950 --> 00:34:07,550
Those don't need to be composited by the render server.

424
00:34:07,550 --> 00:34:12,430
Do it once in Core Graphics, you'll be happy.

425
00:34:12,430 --> 00:34:19,590
But for elements that are just images, let's
say you would put them into an image view,

426
00:34:19,590 --> 00:34:25,810
you might consider letting the rasterizer handle--
sorry, the renderer handle a few of those.

427
00:34:25,810 --> 00:34:32,930
And basically, what you're doing is you're balancing the
time on the CPU spent when you're creating a new cell

428
00:34:32,930 --> 00:34:37,350
and the amount of time spent on
the GPU on every scroll change.

429
00:34:37,350 --> 00:34:45,950
So, like I said, there are two halves, you want
to prepare cells quickly and render quickly.

430
00:34:45,950 --> 00:34:50,850
Now, all of the lessons that we talked
about from smooth animations apply here.

431
00:34:50,850 --> 00:34:54,180
A few pixels to render means, smooth scrolling as well.

432
00:34:54,180 --> 00:34:56,420
So simplify the structure of your view hierarchies.

433
00:34:56,420 --> 00:35:00,750
If you have any unnecessary or
invisible views, just get rid of them.

434
00:35:00,750 --> 00:35:03,800
You want to reduce the amount of
view blending as much as possible.

435
00:35:03,800 --> 00:35:09,250
So, use color layers, color blended layers
to see what's going on in your table views,

436
00:35:09,250 --> 00:35:12,830
and reduce any offscreen rendering that you might have.

437
00:35:12,830 --> 00:35:16,460
That would actually really, really bad in the situation.

438
00:35:16,460 --> 00:35:23,410
And again, new to iPad and iOS 4, you can try to
use the dynamic flattening property in order to--

439
00:35:23,410 --> 00:35:30,360
you shouldRasterize property rather to flatten
your cell hierarchies if you haven't already.

440
00:35:30,360 --> 00:35:35,840
And this might be a nice way of making scrolling
performance just a little bit better for the cost.

441
00:35:35,840 --> 00:35:37,570
One caveat though.

442
00:35:37,570 --> 00:35:43,810
Your cell animations will not look
great if you keep this on all the time.

443
00:35:43,810 --> 00:35:49,540
So if you end up doing a rotation, you want to
turn this off just before the rotation starts.

444
00:35:49,540 --> 00:35:55,370
And for any edit animations, you want to turn
this off before the edit animation starts.

445
00:35:55,370 --> 00:36:03,090
So, we shipped a lot of devices
that run iPhone OS and iOS 4.

446
00:36:03,090 --> 00:36:09,040
Last year we shipped the iPhone 3GS
and the iPod Touch-- new iPod Touch.

447
00:36:09,040 --> 00:36:17,590
And these have twice the CPU power of the previous
generation, twice the RAM and the GPUs are way faster

448
00:36:17,590 --> 00:36:24,060
but what that means is, it is a big
gap between what you're developing

449
00:36:24,060 --> 00:36:28,560
on if you're using an iPhone 3GS and the iPhone 3G.

450
00:36:28,560 --> 00:36:33,550
And we have millions of customer who
have iPhone 3Gs and iPod Touches.

451
00:36:33,550 --> 00:36:36,330
And we want your apps to look great on them.

452
00:36:36,330 --> 00:36:43,310
So if you can, keep around one of these devices and
make sure to test on the devices you intend to target.

453
00:36:43,310 --> 00:36:50,250
iOS 4 runs on the 3G, the iPod Touch and iPhone 4.

454
00:36:50,250 --> 00:36:53,480
And we want everything to look great across those.

455
00:36:53,480 --> 00:36:55,550
Now, I want to talk about the iPad.

456
00:36:55,550 --> 00:37:00,820
We shipped this a couple of months
ago and we think it's great.

457
00:37:00,820 --> 00:37:04,880
It has even faster CPU with the A4.

458
00:37:04,880 --> 00:37:10,080
And even though it has 5 times as many pixels

459
00:37:10,080 --> 00:37:15,060
and about the same graphics capability,
we doubled the bandwidth of the BUS.

460
00:37:15,060 --> 00:37:19,200
And so we think that this has great
graphics performance as well.

461
00:37:19,200 --> 00:37:22,220
And finally, the brand new iPhone 4.

462
00:37:22,220 --> 00:37:30,380
Again, it has the A4 chip so the CPU is a lot faster
because, hey, now you have 4 times as many pixels to draw.

463
00:37:30,380 --> 00:37:39,860
And even though you have 4 times as many pixels, you're
really going to want to get your hands on one of these

464
00:37:39,860 --> 00:37:42,280
to make sure that all your animations look smooth.

465
00:37:42,280 --> 00:37:47,330
Because things are going to double and you
want to make sure that everything looks great.

466
00:37:48,690 --> 00:37:52,320
So that's animation scrolling.

467
00:37:52,320 --> 00:37:57,810
Let's talk a little bit about keeping
your applications snappy and responsive.

468
00:37:57,810 --> 00:38:05,340
So the key part of responsiveness is
simply, do not make your users wait.

469
00:38:05,340 --> 00:38:08,380
We're going to talk about how you
can measure some of these things.

470
00:38:08,380 --> 00:38:15,540
We're going to talk a little bit about launch, interaction
delays and just a couple of notes about CPU optimization.

471
00:38:15,540 --> 00:38:26,820
So Time Profiler Instrument, this is new
in iPhone SDK 4, not Xcode 4, iPhone SDK 4.

472
00:38:26,820 --> 00:38:33,010
And it's actually wonderful statistical
sampling profiling tool.

473
00:38:33,010 --> 00:38:40,740
And what that means is every millisecond you
can see what's happening in your program.

474
00:38:40,740 --> 00:38:49,250
It can take a look at, you know, the stacks of exactly
where things are using the CPU and if things are blocking.

475
00:38:49,250 --> 00:38:55,740
So, the way you should use this during your development
process is if you come up with a performance issue,

476
00:38:55,740 --> 00:38:59,650
use this to measure what's happening during that scenario.

477
00:38:59,650 --> 00:39:04,180
Measure first, and then as you drill down,
you can actually find some of the problems.

478
00:39:04,180 --> 00:39:08,970
You'll actually see the different landmarks
of your code and be able to see, wow,

479
00:39:08,970 --> 00:39:11,400
I didn't realize that that was going to take so long.

480
00:39:11,400 --> 00:39:15,550
So by default, this shows time spent on the CPU.

481
00:39:15,550 --> 00:39:20,730
If you want, you can use this great check box here.

482
00:39:20,730 --> 00:39:25,900
This was just hitting the information
button there called "All Thread States."

483
00:39:25,900 --> 00:39:28,620
It actually shows the time spent in blocking as well.

484
00:39:28,620 --> 00:39:34,300
Now, for stuff that's running on the
main thread, that's hugely important.

485
00:39:34,300 --> 00:39:39,740
You can use this tool to narrow down to exactly
what's happening in your program on the main thread.

486
00:39:39,740 --> 00:39:45,290
And if you see things blocking, that's
not kind of the normal, you know,

487
00:39:45,290 --> 00:39:51,460
blocking on new events, then you
want to chase down after those.

488
00:39:51,460 --> 00:39:59,090
So once you found your problem, you want to measure
exactly how long that particular section of code is taking.

489
00:39:59,090 --> 00:40:00,290
So you want to take a baseline.

490
00:40:00,290 --> 00:40:02,060
Again, what it looks like right now.

491
00:40:02,060 --> 00:40:07,000
And as you make changes, just try to make that
faster you want to actually see real changes.

492
00:40:07,000 --> 00:40:12,040
We recommend just simply timing the start
and end using CFAbsoluteTimeGetCurrent.

493
00:40:12,040 --> 00:40:18,460
Now for those of you that want to know, this
is wall clock time and it's user time, too.

494
00:40:18,460 --> 00:40:20,430
So simply use it like this.

495
00:40:20,430 --> 00:40:21,680
It's pretty easy to use.

496
00:40:21,680 --> 00:40:26,420
So I want to talk a little bit about launch.

497
00:40:26,420 --> 00:40:32,540
If you are at the performance optimization on
iPhone, talk a little bit about it there, too.

498
00:40:32,540 --> 00:40:37,070
Now, I encourage everybody to measure, right.

499
00:40:37,070 --> 00:40:43,130
But this is a little bit tricky to measure the total
number of time-- the total amount of time during launch.

500
00:40:43,130 --> 00:40:46,100
You can start by measuring the amount
of time between the start of name

501
00:40:46,100 --> 00:40:48,910
and the end of application did finish launching.

502
00:40:48,910 --> 00:40:51,390
That gives you a good sense of what's happening.

503
00:40:51,390 --> 00:40:56,350
But the other thing to do maybe is
to time launch using Time Profiler.

504
00:40:56,350 --> 00:41:00,990
Now you can use this as an absolute, measurement
because obviously there's sampling going on.

505
00:41:00,990 --> 00:41:05,520
But it's actually really, really useful tool for
relative measurement as you're making changes.

506
00:41:05,520 --> 00:41:13,450
And it helps you figure out what your
application is actually doing at launch.

507
00:41:13,450 --> 00:41:15,200
So what can you do?

508
00:41:15,200 --> 00:41:18,870
Well, deal only what's necessary on launch.

509
00:41:18,870 --> 00:41:23,680
Can you defer the work that you
see that your application is doing?

510
00:41:23,680 --> 00:41:25,990
Could you do it on demand?

511
00:41:25,990 --> 00:41:33,460
We have a philosophy in-- our application
development of being lazy.

512
00:41:33,460 --> 00:41:41,950
If you can be lazy and do it on demand, that's great,
because the user might not need network ever at all.

513
00:41:41,950 --> 00:41:46,340
The second point is, reduce the number of linked frameworks.

514
00:41:46,340 --> 00:41:52,130
I know when I'm developing I sometimes try
out the brand new frameworks and add them

515
00:41:52,130 --> 00:41:54,150
into my project to try out a brand new feature.

516
00:41:54,150 --> 00:41:57,070
That's great, you should experiment.

517
00:41:57,070 --> 00:42:00,290
But before you ship and build the final product,

518
00:42:00,290 --> 00:42:03,550
you should make sure to remove those
frameworks from your Xcode project.

519
00:42:03,550 --> 00:42:10,100
Because when you have those in there, the system will
actually try the load those at launch and you want to reduce

520
00:42:10,100 --> 00:42:14,080
that as much as possible because that can
cause I/O and cause initializers to run.

521
00:42:14,080 --> 00:42:16,510
You want to reduce that as much as possible.

522
00:42:16,510 --> 00:42:23,120
And if you're using third part libraries,
you want to look out for static initializers.

523
00:42:23,120 --> 00:42:29,430
Now these are usually C++ methods
that are called to initialize a class

524
00:42:29,430 --> 00:42:33,310
and you can detect these using these environment variables.

525
00:42:33,310 --> 00:42:37,880
The other thing that you want to
look out for is weak exports.

526
00:42:37,880 --> 00:42:41,570
These are somewhat rare but we've
actually seen them in the field.

527
00:42:41,570 --> 00:42:45,890
And you can quickly check for these using otool like this.

528
00:42:45,890 --> 00:42:51,070
This is how you set up environment variables to
run in Xcode if you haven't seen that before.

529
00:42:51,070 --> 00:42:57,120
And we have some sample output of what gets printed with
the print statistics and print initializers options.

530
00:42:57,120 --> 00:43:03,010
So interaction delays, the key thing
here, simply do not block the main thread.

531
00:43:03,010 --> 00:43:05,840
And by that I mean, not as blocking operations.

532
00:43:05,840 --> 00:43:09,910
But if you have any operation that's taking
longer than about few milliseconds or so,

533
00:43:09,910 --> 00:43:13,840
you really want to spin it off into the background.

534
00:43:13,840 --> 00:43:18,650
We have lots of scroll views on our system
and people love idly playing with them.

535
00:43:18,650 --> 00:43:21,450
And if you block for a few frames.

536
00:43:21,450 --> 00:43:23,180
It can be really disconcerting.

537
00:43:23,180 --> 00:43:26,370
So, long running task should be
spun off into the background.

538
00:43:26,370 --> 00:43:30,460
And you should try to factor these
into executable units of works

539
00:43:30,460 --> 00:43:34,700
that you can really show progress
to user if it's really long running.

540
00:43:34,700 --> 00:43:40,650
Remember to make UI updates back onto the
main thread once you actually do this.

541
00:43:40,650 --> 00:43:49,360
And in iOS 4 it's really easy to do
with NSOperationQueue and blocks.

542
00:43:49,360 --> 00:43:51,840
So here we have some sample code.

543
00:43:51,840 --> 00:43:56,790
And what is this doing is just
creating an image and we're going

544
00:43:56,790 --> 00:43:59,280
to do some custom drawing to that on the background thread.

545
00:43:59,280 --> 00:44:04,460
And when that's ready, we're going to post
it to the main thread with an image view.

546
00:44:04,460 --> 00:44:10,660
So the first thing we do is we just
create an operation with this block.

547
00:44:10,660 --> 00:44:15,340
And here, we're just creating image context with options.

548
00:44:15,340 --> 00:44:18,680
By the way this is now thread safe in iOS 4.

549
00:44:18,680 --> 00:44:20,200
You can totally use this on the background.

550
00:44:20,200 --> 00:44:21,530
It's great.

551
00:44:21,530 --> 00:44:26,220
And then grab the current-- grab
the image form that current context.

552
00:44:26,220 --> 00:44:32,550
Now, so our drawing is all done here and maybe that's
like 100 milliseconds to 200 milliseconds or so.

553
00:44:32,550 --> 00:44:33,910
Now we want to post that to the main thread.

554
00:44:33,910 --> 00:44:42,550
Now of course, you can't really modify stuff on the
main thread from background threads because a lot

555
00:44:42,550 --> 00:44:47,230
of the UIKit code isn't thread safe here.

556
00:44:47,230 --> 00:44:48,890
So what can we do about that?

557
00:44:48,890 --> 00:44:51,020
How do we get the image to the main thread?

558
00:44:51,020 --> 00:44:53,650
Well with blocks, it's really easy.

559
00:44:53,650 --> 00:44:59,310
All you do is create a new operation with this
block on the main queue, run on the main thread,

560
00:44:59,310 --> 00:45:03,190
and we just create a new UIImageView and use that image.

561
00:45:03,190 --> 00:45:06,370
Pretty simple, huh?

562
00:45:06,370 --> 00:45:13,370
So next if I have about responsiveness,
always make URL request asynchronous.

563
00:45:13,370 --> 00:45:19,710
So I've seen this code, it's really easy to
use sendSynchronousRequest, boom, it's done.

564
00:45:19,710 --> 00:45:26,280
Unfortunately, you don't know what the users are
going to have in terms of network connectivity, right.

565
00:45:26,280 --> 00:45:33,020
They could be somewhere where the network is a little
bit flaky and they start to make the connection that kind

566
00:45:33,020 --> 00:45:39,320
of goes through and, you know, it doesn't
take very long for people to get frustrated.

567
00:45:39,320 --> 00:45:42,730
So it's a little bit more code but it's worth it.

568
00:45:42,730 --> 00:45:48,590
Use connection with request, implement
the delegate of NSURLConnection and you--

569
00:45:48,590 --> 00:45:54,440
this all happen in the background and then your main
thread is nice and free for users to interact with.

570
00:45:54,440 --> 00:46:00,410
You'll get callbacks when you need to receive data
when things failed and when it's finished loading.

571
00:46:00,410 --> 00:46:06,320
One more note, spikes in memory usage can cause delays.

572
00:46:06,320 --> 00:46:07,900
And why is this?

573
00:46:07,900 --> 00:46:17,110
Well it turns out that to accommodate
higher memory usage, code is evicted.

574
00:46:17,110 --> 00:46:24,470
And what I mean by that is the code
that's on the system is usually at--

575
00:46:24,470 --> 00:46:28,860
is usually filling up the rest of the memory that's free.

576
00:46:28,860 --> 00:46:35,270
And if you spike memory usage like this, the system actually
has to kick out something in order to give you more memory.

577
00:46:35,270 --> 00:46:36,980
And what it usually kicks out is code.

578
00:46:36,980 --> 00:46:43,050
And so as you see, it will spike up there
with very little code left in the system.

579
00:46:43,050 --> 00:46:46,970
And when you bring memory back down,
it doesn't just magically fill in.

580
00:46:46,970 --> 00:46:52,370
As if you read back from the storage
proceed and that can take a long time.

581
00:46:52,370 --> 00:46:57,700
This is probably one of the most
common and unexplained delays

582
00:46:57,700 --> 00:47:03,540
that people will find whether-- when
their application is unresponsive.

583
00:47:03,540 --> 00:47:08,840
You'll do some operations, you'll sample it you say,
"Well, I'm not spending a whole lot of CPU time here.

584
00:47:08,840 --> 00:47:10,090
Where is the time going?"

585
00:47:10,090 --> 00:47:15,080
Often times, it's reading back the code
that your application needs to proceed,

586
00:47:15,080 --> 00:47:19,300
in this frame or code, your code, system libraries.

587
00:47:19,300 --> 00:47:26,840
So one final note about responsiveness, we have
some great tools and system including Time Profiler

588
00:47:26,840 --> 00:47:32,590
that allows you to actually find hot spots in your code.

589
00:47:32,590 --> 00:47:38,130
And as you could see it will actually give you
statistics about each individual line of code

590
00:47:38,130 --> 00:47:40,810
and even to the point of each individual instruction.

591
00:47:40,810 --> 00:47:42,650
It's pretty handy.

592
00:47:42,650 --> 00:47:50,860
So one tip we have about this besides, you know, of
course making sure that your algorithms are as optimized

593
00:47:50,860 --> 00:48:00,590
as possible is to use a feature that we have built
into our CPUs and its called "vector processing."

594
00:48:00,590 --> 00:48:07,180
And what vector processing is, it's the way that we
can use the chips to process many elements at once.

595
00:48:07,180 --> 00:48:10,190
So let's say about four elements
at a time in this situation.

596
00:48:10,190 --> 00:48:14,610
So let's say we have some sample code here which is
pretty simple, we're just walking along this array

597
00:48:14,610 --> 00:48:19,270
and we're summing up the total values into this foot.

598
00:48:19,270 --> 00:48:29,910
In iOS 4, we have a new framework called
"accelerate" and this is great stuff.

599
00:48:29,910 --> 00:48:34,740
This is all really, really highly optimized
code that you can just use out of the box

600
00:48:34,740 --> 00:48:40,810
that will give us this vector processing
to do lots of operations at once.

601
00:48:40,810 --> 00:48:46,020
So in this case, we're using the--
summing the vector elements.

602
00:48:46,020 --> 00:48:53,310
And it's one simple line of code and
operates on this vector four at a time.

603
00:48:53,310 --> 00:49:00,300
So again, don't make users wait,
measure the problem situations,

604
00:49:00,300 --> 00:49:07,190
look for situations where you can improve
the interaction time in your application.

605
00:49:07,190 --> 00:49:10,860
So with that I'm going to hand things
off to my colleague Peter Handel

606
00:49:10,860 --> 00:49:13,460
and he'll be talking about power and battery life.

607
00:49:13,460 --> 00:49:14,690
[Applause] Thank you.

608
00:49:14,690 --> 00:49:14,800
[ Applause ]

609
00:49:14,800 --> 00:49:19,830
>> Peter Handel: Hi, everyone.

610
00:49:19,830 --> 00:49:20,890
My name is Peter Handel.

611
00:49:20,890 --> 00:49:25,760
I'm an iOS Power Engineer and I've been
doing that for almost four years now.

612
00:49:25,760 --> 00:49:27,440
I'd like to share with you some tips and tricks

613
00:49:27,440 --> 00:49:31,480
and how you can improve the battery life
of your application in three key areas.

614
00:49:31,480 --> 00:49:36,640
When using the radio to send and receive data, when using
Core Location to figure out where your device is located.

615
00:49:36,640 --> 00:49:41,590
And when using the CPU and GPU to get
your work done and draw on the screen.

616
00:49:41,590 --> 00:49:48,320
First the network, transmitting data over 3G is
one of the most power intensive things you can do.

617
00:49:48,320 --> 00:49:52,490
This is exacerbated by the fact
that 3G networks keep the 3G radios

618
00:49:52,490 --> 00:49:56,410
in a high-power state for few seconds
after data transmission.

619
00:49:56,410 --> 00:50:01,110
Therefore, if you were to send and receive even
just a little bit of data, every few seconds,

620
00:50:01,110 --> 00:50:05,750
you'd keep those power-hungry 3G radios
in a high-power state the entire time.

621
00:50:05,750 --> 00:50:09,080
That's one of the quickest ways
I know how to drain your battery.

622
00:50:09,080 --> 00:50:15,890
So how can we enjoy the high speed and wide availability
of 3G while still maintaining excellent battery life?

623
00:50:15,890 --> 00:50:17,610
Here's a few tips.

624
00:50:17,610 --> 00:50:21,770
First off, use the Activity Monitor tool
which is part of Instruments to figure

625
00:50:21,770 --> 00:50:25,080
out how much networking your application is doing.

626
00:50:25,080 --> 00:50:30,890
Next, coalesce your data into large chunks
rather than transmitting a thin stream of data.

627
00:50:30,890 --> 00:50:36,510
If you notice that your application is transmitting a
thin stream of data, this may be because you're pulling

628
00:50:36,510 --> 00:50:39,940
across the network to check to see whether
an event has occurred on the server.

629
00:50:39,940 --> 00:50:41,590
Try to avoid this at all cost.

630
00:50:41,590 --> 00:50:42,510
Let me repeat that.

631
00:50:42,510 --> 00:50:45,870
Try to avoid pulling over the network at all costs.

632
00:50:45,870 --> 00:50:49,950
We came across application, a little
chat application which checked

633
00:50:49,950 --> 00:50:53,280
with the server every few seconds
to see whether a new chat come in.

634
00:50:53,280 --> 00:50:56,710
And as you can image, just chewed through the battery.

635
00:50:56,710 --> 00:51:01,170
Instead, try to use the Apple Push
Notification service if you can.

636
00:51:01,170 --> 00:51:03,970
Also, minimize the amount of data transmitted.

637
00:51:03,970 --> 00:51:08,820
Use a compact data format or maybe even
compress your data before you transmit it.

638
00:51:08,820 --> 00:51:12,730
And finally, be real careful when
you reuse legacy or third party code

639
00:51:12,730 --> 00:51:16,750
because oftentimes this code will
assume that it's just on Ethernet.

640
00:51:16,750 --> 00:51:20,740
So for the 3G radio chip, let that chip idle.

641
00:51:20,740 --> 00:51:25,680
From a power perspective, Wi-Fi
uses roughly half the power of 3G.

642
00:51:25,680 --> 00:51:29,990
Now this obviously depends on network
characteristics but it's kind of rule of thumb.

643
00:51:29,990 --> 00:51:33,650
Also, note that the Wi-Fi network
will allow the Wi-Fi radios

644
00:51:33,650 --> 00:51:37,160
to enter low power state immediately after transmission.

645
00:51:37,160 --> 00:51:43,380
Because of these 2 things, your application may want to know
when it's on Wi-Fi versus when it's on the cell network.

646
00:51:43,380 --> 00:51:48,110
To check this, use the kSCNetworkReachability FlagIsWWAN.

647
00:51:48,110 --> 00:51:51,510
Where does 2G fit into this mix?

648
00:51:51,510 --> 00:51:56,090
Well, from a power perspective, it fits
in roughly halfway between Wi-Fi and 3G.

649
00:51:56,090 --> 00:52:01,800
Also, like Wi-Fi, the 2G network will allow the
2G radio to enter the low power state immediately

650
00:52:01,800 --> 00:52:05,530
after data transmission, and that's the radios.

651
00:52:05,530 --> 00:52:08,070
Next, Core Location.

652
00:52:08,070 --> 00:52:13,630
Judging by the number of apps in the App Store that use Core
Location, you guys love it and your customers love it too.

653
00:52:13,630 --> 00:52:18,910
If you haven't used it, Core Location is an API that
with just a few lines of code which I have up here,

654
00:52:18,910 --> 00:52:23,500
will allow your device to figure out where
it's located to varying degrees of accuracy.

655
00:52:23,500 --> 00:52:26,820
However, be sure to only use the
least amount of accuracy you can

656
00:52:26,820 --> 00:52:29,790
because the higher level of accuracy uses more power.

657
00:52:29,790 --> 00:52:35,170
For example, if you have a coffee shop
finder application which can tell which--

658
00:52:35,170 --> 00:52:39,900
and Core Location can tell you that you're here at the
Moscone Center, that's probably good enough to know

659
00:52:39,900 --> 00:52:42,240
that there's coffee shop right across the street.

660
00:52:42,240 --> 00:52:47,090
So in this situation, you use the nearest--
I'm sorry, you use the 100 meters accuracy.

661
00:52:47,090 --> 00:52:50,470
Next, the distanceFilter.

662
00:52:50,470 --> 00:52:54,460
This dictates how often you receive
location changed updates.

663
00:52:54,460 --> 00:52:58,740
Be sure to set it appropriately because the
default is to receive every single notification.

664
00:52:58,740 --> 00:53:01,770
And as you can imagine, this would
lead to a lot of unnecessary events

665
00:53:01,770 --> 00:53:06,190
and higher CPU usage and worst battery life.

666
00:53:06,190 --> 00:53:12,430
Be sure to call stopUpdatingLocation as soon
as you reach your desired level of accuracy.

667
00:53:12,430 --> 00:53:16,770
Also, note that Core Location will
manage the GPS power for you.

668
00:53:16,770 --> 00:53:21,790
What this means is that for example in our coffee shop
finder application, if your user is looking at the map

669
00:53:21,790 --> 00:53:27,190
and they decided to go in the preferences part of your
application, call stopUpdatingLocation immediately.

670
00:53:27,190 --> 00:53:31,970
And then one or few seconds later, they go back to
the map, go ahead and call startUpdatingLocation

671
00:53:31,970 --> 00:53:34,770
and Core Location will pick up right where it left off.

672
00:53:34,770 --> 00:53:38,480
So for the GPS chip, let that chip idle.

673
00:53:38,480 --> 00:53:42,640
Note, the same is true for Core
Motion, which is the new iOS 4 API.

674
00:53:42,640 --> 00:53:48,590
After you call the start update functions, be
sure to call the matching stop update functions.

675
00:53:48,590 --> 00:53:55,620
Also, if your application goes in the background, be sure
to turn off the sensors when that happens if you like.

676
00:53:55,620 --> 00:54:02,360
Note that in-- if your application would like to be
notified of the significant location change or if you want

677
00:54:02,360 --> 00:54:07,490
to use region monitoring, instead of just
having Core Location running all the time,

678
00:54:07,490 --> 00:54:10,070
use the new iOS 4 API which lets you do this.

679
00:54:10,070 --> 00:54:11,960
And I have this-- that up here.

680
00:54:11,960 --> 00:54:16,880
And that's Core Location, finally, the CPU and GPU.

681
00:54:16,880 --> 00:54:20,800
You might be wondering why we're talking about
performance and power in the same presentation.

682
00:54:20,800 --> 00:54:27,030
Well, it turns out that if you optimize for performance,
you get better battery life thrown in for free.

683
00:54:27,030 --> 00:54:32,050
This is because fast code uses less
CPU time which uses less power.

684
00:54:32,050 --> 00:54:36,450
So for the CPU, let that chip idle.

685
00:54:36,450 --> 00:54:39,680
So as you know, the iOS 4 is an
event based operating system.

686
00:54:39,680 --> 00:54:44,750
Now as I mentioned earlier in the networking portion
of this talk, there are certain conditions when--

687
00:54:44,750 --> 00:54:48,010
there are certain situations where you
might want to uphold to check to see

688
00:54:48,010 --> 00:54:50,990
when an event has occurred or something has changed.

689
00:54:50,990 --> 00:54:53,990
Try to avoid this and instead subscribe to an event.

690
00:54:53,990 --> 00:54:59,180
But we don't have events for everything so
in some situations you may have to pull.

691
00:54:59,180 --> 00:55:01,030
Try to reduce the frequency with which you pull.

692
00:55:01,030 --> 00:55:06,110
For example if you pull every 30th of a second, try dropping
that down to every tenth of a second or even every second

693
00:55:06,110 --> 00:55:09,050
to see if there's any user-visible impact.

694
00:55:09,050 --> 00:55:14,010
For example, we see a lot of sample code on
the Internet which recommends that you figure

695
00:55:14,010 --> 00:55:19,060
out whether the device is being shaken like continuously
pulling and using your accelerometer to do that.

696
00:55:19,060 --> 00:55:19,650
Don't do this.

697
00:55:19,650 --> 00:55:23,700
Instead, use the Shake API to figure
out when your device is being shaken.

698
00:55:23,700 --> 00:55:25,980
Next, be bursty.

699
00:55:25,980 --> 00:55:29,960
Try to consolidate your CPU usage into short bursts.

700
00:55:29,960 --> 00:55:33,410
This will allow the CPU to enter
that idle state I've talking about.

701
00:55:33,410 --> 00:55:39,380
Note that this may require you to restructure your
code or possibly you can use a different algorithm.

702
00:55:39,380 --> 00:55:41,690
How do you know when your code is being nice and bursty?

703
00:55:41,690 --> 00:55:49,360
Well, use the Time Profiler tool as part-- which is part
of the instruments to check your CPU activity level.

704
00:55:49,360 --> 00:55:51,650
For example, we found that during audio playback.

705
00:55:51,650 --> 00:55:57,700
We were able to get much better battery life by
decompressing large chunks of audio at once rather

706
00:55:57,700 --> 00:56:00,320
than decompressing small pieces continually.

707
00:56:00,320 --> 00:56:04,690
Next, procrastination, because
who doesn't like to procrastinate?

708
00:56:04,690 --> 00:56:08,190
Because if you put it off long enough,
you just might not have to do it all.

709
00:56:08,190 --> 00:56:13,590
For example, we came across a game, which check
the-- which stayed at state every few seconds.

710
00:56:13,590 --> 00:56:15,790
You can imagine it's not really good for the CPU.

711
00:56:15,790 --> 00:56:17,750
It's not very good for battery life either.

712
00:56:17,750 --> 00:56:22,540
Instead, maybe you could save the state when
the user reaches a milestone or a checkpoint

713
00:56:22,540 --> 00:56:25,630
or maybe even the user quits the game, the time safety.

714
00:56:25,630 --> 00:56:28,540
When using the GPU, pick a fixed frame rate.

715
00:56:28,540 --> 00:56:37,680
We recommend about 30 frames per second and enforce
this using the CADisplayLink rather than using NSTimer.

716
00:56:37,680 --> 00:56:41,660
This will help you minimize the appearance of
dropped frames and also help you avoid the situation

717
00:56:41,660 --> 00:56:44,130
where your app is continuously drawing as quick as possible.

718
00:56:44,130 --> 00:56:50,170
On the other end of the spectrum, if a
frame has not changed, don't redraw it.

719
00:56:50,170 --> 00:56:54,160
For example, if you have a chess application
and your user is looking at the pieces,

720
00:56:54,160 --> 00:57:00,630
contemplating the next brilliant move, don't be updating
the screen every 30 frames a second if nothing has changed.

721
00:57:00,630 --> 00:57:05,080
Finally, be sure to check out the Energy
Diagnostics Tool which is part of instruments.

722
00:57:05,080 --> 00:57:09,540
And I was in the session this morning, session
309 which delved into this extensively.

723
00:57:09,540 --> 00:57:12,120
So be sure to check out the video once it's available.

724
00:57:12,120 --> 00:57:17,930
So to summarize, for the radios we learned
that data transmission is very expensive.

725
00:57:17,930 --> 00:57:21,220
So we coalesce and compress data as much as possible.

726
00:57:21,220 --> 00:57:24,890
With Core Location, we use the least
amount of accuracy we can get away with

727
00:57:24,890 --> 00:57:28,490
and we call stop obtaining location as soon as we can.

728
00:57:28,490 --> 00:57:33,520
And on the CPU and GPU, we optimize our
performance and get better battery life for free,

729
00:57:33,520 --> 00:57:36,190
with bursty we procrastinate as much as possible.

730
00:57:36,190 --> 00:57:42,350
And on the GPU, we used the fixed frame rate, 30 frames
per second and we don't unnecessarily redraw the screen.

731
00:57:42,350 --> 00:57:45,160
So to summarize, let those chips idle.

732
00:57:45,160 --> 00:57:45,680
Thank you.

733
00:57:45,680 --> 00:57:46,510
Dave.

734
00:57:46,510 --> 00:57:52,200
[ Applause ]

735
00:57:52,200 --> 00:57:53,710
>> David Chan: Thanks Peter.

736
00:57:53,710 --> 00:57:59,430
So in summary, use your knowledge about the
systems, come up with creative solutions.

737
00:57:59,430 --> 00:58:06,550
Always measure the baseline and the changes you make to
make sure that the changes you're making are improvements.

738
00:58:06,550 --> 00:58:11,030
About animations, fewer pixels to
render, means smooth animations.

739
00:58:11,030 --> 00:58:15,520
Make sure to prepare yourselves and
render very quickly for smooth scrolling.

740
00:58:15,520 --> 00:58:17,940
Don't block the main thread and let those chips idle.

741
00:58:17,940 --> 00:58:20,320
Thank you for coming to our talk.

742
00:58:20,320 --> 00:58:22,910
Here are some related sessions for more information.

743
00:58:22,910 --> 00:58:26,750
Be sure to come tomorrow to part 2 of this talk.

744
00:58:26,750 --> 00:58:34,430
We'll be covering memory, databases, how
to use the data APIs on our system and I/O.

745
00:58:34,430 --> 00:58:40,220
And right after this, there's an optimizing
core data performance on iPhone OS session

746
00:58:40,220 --> 00:58:43,230
that I highly recommend you go through if you use core data

747
00:58:43,230 --> 00:58:46,280
or you're planning using core data
in any of your applications.

748
00:58:46,280 --> 00:58:49,060
Here are some other session that have already happened

749
00:58:49,060 --> 00:58:52,270
that are great reference material for
some topics that we covered today.

750
00:58:52,270 --> 00:58:53,540
Thank you very much for coming.

