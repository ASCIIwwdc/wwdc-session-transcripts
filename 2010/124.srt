1
00:00:06,840 --> 00:00:12,140
>> My name is Tony Parker, and I'm an engineer on the
Cocoa Team at Apple, and this is Understanding Foundation.

2
00:00:12,140 --> 00:00:16,760
So first, let's go over what we're
going to talk about today.

3
00:00:16,760 --> 00:00:22,570
We'll start by going over what the Foundation framework is,
then we'll see how Foundation fits in with your application

4
00:00:22,570 --> 00:00:27,400
and the rest of the system, and then we're going
to spend most of the time of the talk today going

5
00:00:27,400 --> 00:00:29,600
over the most important Foundation features.

6
00:00:29,600 --> 00:00:34,520
We're going to see a high-level overview of many of the
Foundation classes, talk about the most important features

7
00:00:34,520 --> 00:00:37,070
on those classes, and see examples of how to use them.

8
00:00:37,070 --> 00:00:40,870
So, just a couple of prereqs.

9
00:00:40,870 --> 00:00:44,910
I'm going to assume that you've worked on an app or
you're working on an app for iPhone OS or Mac OS X

10
00:00:44,910 --> 00:00:52,090
and that you have familiarity with the basic
Foundation concepts like retain and release.

11
00:00:52,090 --> 00:00:54,790
So first, what is Foundation?

12
00:00:54,790 --> 00:00:57,510
Foundation provides building block classes.

13
00:00:57,510 --> 00:01:02,790
And these building block classes are the fundamental
types that are used by all applications on the system.

14
00:01:02,790 --> 00:01:08,790
They can be assembled by higher-level software,
other frameworks, and applications like yours.

15
00:01:08,790 --> 00:01:11,890
Foundation also introduces consisting conventions.

16
00:01:11,890 --> 00:01:17,810
One of those I just mentioned, that's retain and release,
but there are others and we'll a few examples of that today.

17
00:01:17,810 --> 00:01:21,510
And finally, Foundation is designed
to raise lower-level concepts.

18
00:01:21,510 --> 00:01:25,950
It can wrap up complex OS level tasks so
you can focus on your problem domain instead

19
00:01:25,950 --> 00:01:27,990
of nuts and bolts of how exactly to do things.

20
00:01:27,990 --> 00:01:29,900
So, where does Foundation fit in a system?

21
00:01:29,900 --> 00:01:35,100
If you look at the system as a stack with your
application on top and the Core OS pieces on the bottom,

22
00:01:35,100 --> 00:01:37,760
then in the middle, we have our frameworks.

23
00:01:37,760 --> 00:01:40,400
And Foundation is one of these frameworks.

24
00:01:40,400 --> 00:01:45,430
Now, Foundation relies on lower-level frameworks
itself, for example, the CFNetwork framework

25
00:01:45,430 --> 00:01:48,340
for networking support and Core Foundation.

26
00:01:48,340 --> 00:01:52,270
And there are higher level frameworks that
rely on the Foundation framework, on Mac OS X,

27
00:01:52,270 --> 00:01:55,510
there's the application kit, and iOS, there's the UI Kit.

28
00:01:55,510 --> 00:01:58,140
And generally, the dividing line between those frameworks

29
00:01:58,140 --> 00:02:01,120
and Foundation is how closely they
relate to the user interface.

30
00:02:01,120 --> 00:02:05,110
OK, let's move on to the majority of our
talk, and that's going over building blocks.

31
00:02:05,110 --> 00:02:14,320
So, first we'll talk about collections, then strings, dates,
times, formatters and locales, persistence and archiving,

32
00:02:14,320 --> 00:02:20,370
files and URLs, bundles, and we'll
wrap up by going over operation queues.

33
00:02:20,370 --> 00:02:22,940
So, first up is collections.

34
00:02:22,940 --> 00:02:24,220
So, what's a collection?

35
00:02:24,220 --> 00:02:26,340
It's just a place to put your stuff.

36
00:02:26,340 --> 00:02:29,710
And there are many features you use on collections.

37
00:02:29,710 --> 00:02:35,620
What we're going to talk about today is
iteration, sorting the contents of an array,

38
00:02:35,620 --> 00:02:38,530
and filtering the contents of a collection.

39
00:02:38,530 --> 00:02:41,540
Now, in the Foundation framework,
we have three major collections.

40
00:02:41,540 --> 00:02:43,460
The first is NSArray.

41
00:02:43,460 --> 00:02:48,310
NSArray's prime directive, if you will, is to preserve
the order of the objects that you put into it.

42
00:02:48,310 --> 00:02:53,150
An example of where you might use one is if
you're storing the results of a 50-meter dash.

43
00:02:53,150 --> 00:02:56,260
In that case, of course, it's very important
to remember who came first, second, and third.

44
00:02:56,260 --> 00:03:00,330
The second major collection is NSDictionary.

45
00:03:00,330 --> 00:03:03,590
NSDictionary maps key objects to value objects.

46
00:03:03,590 --> 00:03:05,850
You can think of it as an association table.

47
00:03:05,850 --> 00:03:11,050
An example of where you might use one is in a phone book
where you map a person's name to their phone number.

48
00:03:11,050 --> 00:03:14,630
And the third major collection is NSSet.

49
00:03:14,630 --> 00:03:18,590
NSSet maintains unique, unordered objects.

50
00:03:18,590 --> 00:03:20,710
An example might be a suggestion box.

51
00:03:20,710 --> 00:03:23,770
There, perhaps, you don't care about
how many copies of suggestion you get,

52
00:03:23,770 --> 00:03:26,750
and you also don't care about the
order they are received in.

53
00:03:26,750 --> 00:03:31,160
All three of these collections have mutable variants.

54
00:03:31,160 --> 00:03:35,210
And mutable means that it can be modified,
so objects can be added or removed

55
00:03:35,210 --> 00:03:36,940
from the mutable versions of these collections.

56
00:03:36,940 --> 00:03:40,300
Now, the first topic is iterating
over the contents of a collection.

57
00:03:40,300 --> 00:03:44,960
You've probably already used a for loop, but there
are others like NSEnumerator and a while loop.

58
00:03:44,960 --> 00:03:52,890
Fast enumeration using the for-in syntax, and new
in Snow Leopard and iOS 4 is the use of blocks.

59
00:03:52,890 --> 00:03:57,900
So when you're using a for loop, of course, you're going to
get the count first and then you iterate over every object

60
00:03:57,900 --> 00:04:04,340
in the array by incrementing that index and
retrieving the object from the array at that index.

61
00:04:04,340 --> 00:04:07,030
And your code goes inside that loop.

62
00:04:07,030 --> 00:04:09,290
You can also use this technique with a dictionary or a set,

63
00:04:09,290 --> 00:04:13,420
you just first get the allObjects array
and then follow the same technique.

64
00:04:13,420 --> 00:04:18,910
And this enumerator is a Foundation object that can
keep track of your location and iteration for you.

65
00:04:18,910 --> 00:04:20,760
Here, I'm going to get an object enumerator,

66
00:04:20,760 --> 00:04:26,050
that is an enumerator that iterates
over the objects in an array or a set.

67
00:04:26,050 --> 00:04:32,340
Then I set up a while loop and while next object returns
a non-nil value, I have another object to enumerate over.

68
00:04:32,340 --> 00:04:34,750
Now note, if you're using this technique with an NSArray,

69
00:04:34,750 --> 00:04:39,590
you'll need to keep track of the
index separately, if you need it.

70
00:04:39,590 --> 00:04:46,930
For a dictionary, you can enumerate over the keys using
a key enumerator and then get the object that corresponds

71
00:04:46,930 --> 00:04:50,300
with that key using NSDictionary's objectForKey method.

72
00:04:50,300 --> 00:04:53,830
Or if you just need the objects, you
can also use an object enumerator.

73
00:04:53,830 --> 00:05:00,480
If you're targeting Mac OS 10.5 Leopard or any version
of iPhone OS or iOS, then you can use Fast enumeration.

74
00:05:00,480 --> 00:05:02,420
And I think it's fast for two reasons.

75
00:05:02,420 --> 00:05:04,450
The first is that it actually performs faster.

76
00:05:04,450 --> 00:05:09,930
It uses some implementation details of how
these collections are created to retrieve groups

77
00:05:09,930 --> 00:05:13,050
of objects and actually have better performance.

78
00:05:13,050 --> 00:05:15,850
But I think it's also fast because
you have to write less code.

79
00:05:15,850 --> 00:05:17,750
So, here we're saying just for-in.

80
00:05:17,750 --> 00:05:19,980
Then we don't have to set up the enumerator ourselves.

81
00:05:19,980 --> 00:05:24,680
Here the object variable will be assigned to the
next object in an array or set until we're finished.

82
00:05:24,680 --> 00:05:30,060
And again, there's no easy access to the index, so if
you need it, you'll have to keep track of it yourself.

83
00:05:30,060 --> 00:05:34,100
When you fast enumerate over a dictionary,
the objects you're getting back are the keys.

84
00:05:34,100 --> 00:05:38,890
That means that if you need the objects, you should call
objectForKey and get the value that you need in your loop.

85
00:05:38,890 --> 00:05:42,560
So, new in Snow Leopard and iOS 4, as
I mentioned, is iteration using blocks.

86
00:05:42,560 --> 00:05:46,110
I'm not going to go into the details
of the block syntax here.

87
00:05:46,110 --> 00:05:51,640
The key parts, remember, is that this method,
enumerateObjectsUsingBlock, takes a block parameter.

88
00:05:51,640 --> 00:05:53,410
You can tell because there's a caret in front there.

89
00:05:53,410 --> 00:05:56,040
And this block is a snippet of code.

90
00:05:56,040 --> 00:05:58,440
And that code has some parameters.

91
00:05:58,440 --> 00:06:01,140
Here, we're going to get the object,
the index of that object,

92
00:06:01,140 --> 00:06:05,260
and we have the option to stop the
iteration early with that third parameter.

93
00:06:05,260 --> 00:06:07,810
And your code goes inside.

94
00:06:07,810 --> 00:06:13,680
For dictionaries, you get the keys and the objects together,
so you don't need an extra step to retrieve the object.

95
00:06:13,680 --> 00:06:16,100
And for sets, you get the objects.

96
00:06:16,100 --> 00:06:17,860
Now, these are the short versions of these methods.

97
00:06:17,860 --> 00:06:21,720
One of the benefits of using the block-based
iteration is that there is another method,

98
00:06:21,720 --> 00:06:27,250
another version which lets you specify things like
enumerating reverse or enumerating concurrently.

99
00:06:27,250 --> 00:06:29,800
So, how do you choose which of
these iteration methods to use?

100
00:06:29,800 --> 00:06:32,110
I recommend that you choose based on two things.

101
00:06:32,110 --> 00:06:35,440
The first is what version of the
operating system you're targeting.

102
00:06:35,440 --> 00:06:38,450
And the second is understanding what data you need.

103
00:06:38,450 --> 00:06:43,890
For example, do you need the index in an array
or do you need the objects in a dictionary?

104
00:06:43,890 --> 00:06:48,500
So, for any version of Mac OS X or iOS,
you can use a for loop or an NSEnumerator.

105
00:06:48,500 --> 00:06:55,930
If you're targeting Leopard or any version of iOS,
then you can use a for loop or Fast enumeration.

106
00:06:55,930 --> 00:07:05,010
And on Snow Leopard, or iOS 4 and later, then use Fast
enumeration or try our new block-based enumeration methods.

107
00:07:05,010 --> 00:07:08,110
Next is sorting an array.

108
00:07:08,110 --> 00:07:11,900
So there are several ways that you can tell
NSArray how to determine its sort order.

109
00:07:11,900 --> 00:07:17,860
You can use a C function, you can use an objective
C method, you can use an NSSort descriptor.

110
00:07:17,860 --> 00:07:24,020
This is a class that lets you specify which properties on
an array or an object in an array that you want to sort on.

111
00:07:24,020 --> 00:07:29,540
And on iOS 4 or Snow Leopard or later,
you can use a block-based method.

112
00:07:29,540 --> 00:07:32,230
Now, when you're sorting an immutable or immutable array,

113
00:07:32,230 --> 00:07:36,310
there's a sort method that returns a
new object, a new collection object.

114
00:07:36,310 --> 00:07:40,660
For mutable arrays only, there's a different
method you can call, which will sort it in place.

115
00:07:40,660 --> 00:07:44,230
So, let's see an example of sorting in place using blocks.

116
00:07:44,230 --> 00:07:49,040
Here, I have an array of names and I want to sort
these names by the length of the string, their strings.

117
00:07:49,040 --> 00:07:52,020
I want to sort these names by their length.

118
00:07:52,020 --> 00:07:58,320
So, I'm going to use this block-based
method, NSArray's sortUsingComparator.

119
00:07:58,320 --> 00:08:01,560
And you see the parameters of block, and
that block has a left and right object.

120
00:08:01,560 --> 00:08:06,500
NSArray will call this block as many times
as necessary with the appropriate objects

121
00:08:06,500 --> 00:08:10,590
to determine what the correct sort order
of the contents of your collection are.

122
00:08:10,590 --> 00:08:13,750
Our job is to return an NSComparison results.

123
00:08:13,750 --> 00:08:19,930
To determine what the answer is, I'm going to get the length
of the left and right strings and then do my comparison.

124
00:08:19,930 --> 00:08:24,760
If the left is less than the right,
I'm going to return OrderedAscending .

125
00:08:24,760 --> 00:08:27,240
If it's the opposite, it's OrderedDescending.

126
00:08:27,240 --> 00:08:30,110
And if the lengths are equal, NSOrderedSame.

127
00:08:30,110 --> 00:08:32,560
Now note that this does not mean that the objects are equal,

128
00:08:32,560 --> 00:08:36,750
just that they have the same length
and they should be sorted equally.

129
00:08:36,750 --> 00:08:40,400
And when this method returns, the
NSArray will be sorted in place.

130
00:08:40,400 --> 00:08:42,070
So, next is filtering.

131
00:08:42,070 --> 00:08:47,470
One thing that trips up people sometimes when
they're new to Foundation is that they attempt

132
00:08:47,470 --> 00:08:55,420
to mutate a collection while they're enumerating it using
a block-based method or NSEnumerator or Fast enumeration.

133
00:08:55,420 --> 00:08:57,190
And that causes an exception.

134
00:08:57,190 --> 00:09:03,510
So, the proper way to filter a collection
is to mutate a copy of the collection

135
00:09:03,510 --> 00:09:07,930
or to gather the changes on the
side and then apply them later.

136
00:09:07,930 --> 00:09:09,810
Let's see an example of the latter.

137
00:09:09,810 --> 00:09:11,830
Here, I have another immutable array of strings.

138
00:09:11,830 --> 00:09:14,320
This one contains strings with file names in them.

139
00:09:14,320 --> 00:09:19,250
And I want to filter out every file name that starts with
a dot, perhaps because I'm going to display it to a user.

140
00:09:19,250 --> 00:09:21,740
So, I'm going to create another collection.

141
00:09:21,740 --> 00:09:26,840
This is an NSIndexSet, which is like an
NSSet, but for indexes instead of objects.

142
00:09:26,840 --> 00:09:28,310
And it's called To Remove.

143
00:09:28,310 --> 00:09:32,420
The contents of this index set will the items
in that array that I want to filter out.

144
00:09:32,420 --> 00:09:38,940
And I create it by using one of our new block-based
methods, files, indexes of objects passing test, and then,

145
00:09:38,940 --> 00:09:42,700
inside this block is where I put my test.

146
00:09:42,700 --> 00:09:45,180
If that string starts with a dot, return Yes.

147
00:09:45,180 --> 00:09:49,950
That means put this index in that
index set, otherwise return No.

148
00:09:49,950 --> 00:09:56,540
And when it's finished, I call remove objects to indexes
with that index set and my array will be filtered.

149
00:09:56,540 --> 00:09:58,560
There are many more features on collections.

150
00:09:58,560 --> 00:10:00,460
You can search collections.

151
00:10:00,460 --> 00:10:02,120
You can apply a selector to each item.

152
00:10:02,120 --> 00:10:04,550
That's another way of getting the
same code run on every object.

153
00:10:04,550 --> 00:10:08,260
And this array has slicing and concatenation features.

154
00:10:08,260 --> 00:10:12,480
And NSSet has intersection, union
and set subtraction features.

155
00:10:14,300 --> 00:10:15,650
So next up is strings.

156
00:10:15,650 --> 00:10:21,670
So, strings, and Foundation's string
object is called NSString.

157
00:10:21,670 --> 00:10:27,880
NSString is the object container for almost all the
tests you see on the system, on iOS or Mac OS X.

158
00:10:27,880 --> 00:10:30,160
And conceptually, strings are actually very simple.

159
00:10:30,160 --> 00:10:32,660
They're just an array of Unicode characters.

160
00:10:32,660 --> 00:10:37,800
However, there are many complexities in dealing
with strings at the Unicode character level.

161
00:10:37,800 --> 00:10:41,660
So, what we really recommend is that
you treat strings as opaque containers.

162
00:10:41,660 --> 00:10:45,150
And to help you do that, NSString has a ton of methods on it

163
00:10:45,150 --> 00:10:49,330
that let you manipulate strings and
do other kinds of string operations.

164
00:10:49,330 --> 00:10:54,290
Some of the most common are comparing strings, searching
strings and converting the encoding of strings.

165
00:10:54,290 --> 00:10:57,690
So, first up is comparing.

166
00:10:57,690 --> 00:11:03,640
There's a simple way to do that, this method called Compare.

167
00:11:03,640 --> 00:11:06,610
The parameter is the string that
you're comparing the receiver to

168
00:11:06,610 --> 00:11:12,160
and the result is another NSComparison
result, the same type as we saw a minute ago.

169
00:11:12,160 --> 00:11:16,290
If you're comparing strings in a manner that
will eventually be displayed to the user,

170
00:11:16,290 --> 00:11:19,460
you need to sort them in a -- compare
them in a localized manner.

171
00:11:19,460 --> 00:11:22,080
And this method is for that, localizedCompare.

172
00:11:22,080 --> 00:11:26,000
You see, it takes a string parameter and
returns an NSComparison result s well.

173
00:11:26,000 --> 00:11:31,440
And furthermore, in Snow Leopard and iOS 4, we
added this method, localized Standard Compare.

174
00:11:31,440 --> 00:11:35,720
This encapsulates what we think are the best
practices for the options to compare strings

175
00:11:35,720 --> 00:11:39,540
with if you're going to display
them in a manner to the user.

176
00:11:39,540 --> 00:11:44,320
This will take into account the user's current
locale, all of their preferences and so on.

177
00:11:44,320 --> 00:11:51,160
And finally, if you need to specify more
options, there's compare:options:range:locale.

178
00:11:51,160 --> 00:11:54,080
An option you might specify is a case insensitive compare.

179
00:11:54,080 --> 00:11:57,700
Or you may want to specify only a
subset of the string to compare.

180
00:11:57,700 --> 00:11:58,900
Quick example.

181
00:11:58,900 --> 00:12:00,750
Here I have two strings, A and B.

182
00:12:00,750 --> 00:12:03,910
And when I compare them, the result
will be NSOrderAscending.

183
00:12:03,910 --> 00:12:05,600
String A comes before string B.

184
00:12:05,600 --> 00:12:09,020
I mentioned earlier that you can sort
an array based on an objective C method.

185
00:12:09,020 --> 00:12:09,960
Here's an example of that.

186
00:12:09,960 --> 00:12:13,000
I have an array with Larry, Curley, and Moe in it.

187
00:12:13,000 --> 00:12:16,000
And I want to sort this in a localized manner for my user.

188
00:12:16,000 --> 00:12:19,500
So, what I do is called the NSArray
method, sortedArrayUsingSelector.

189
00:12:19,500 --> 00:12:21,840
I pass in selectorLocalizeCompare.

190
00:12:21,840 --> 00:12:25,140
That localize compare message will be
sent to every object in that array,

191
00:12:25,140 --> 00:12:28,360
and NSArray will use it to determine the sort order.

192
00:12:28,360 --> 00:12:30,700
The result will be Curley, Larry, and Moe.

193
00:12:30,700 --> 00:12:34,390
For searching strings, there's a similar easy method.

194
00:12:34,390 --> 00:12:35,770
It's called rangeOfString.

195
00:12:35,770 --> 00:12:38,640
The parameters of the string you're
looking for in the receiver.

196
00:12:38,640 --> 00:12:42,020
And the result is an NSRange structure.

197
00:12:42,020 --> 00:12:43,260
There's a long form of this, too.

198
00:12:43,260 --> 00:12:45,940
It's called rangeOfString:options:range:locale.

199
00:12:45,940 --> 00:12:50,240
And you could specify some of the
same options like case insensitive.

200
00:12:50,240 --> 00:12:52,890
Now, some people ask, why do we return a range?

201
00:12:52,890 --> 00:12:56,170
If I passed in the string I'm looking
for, I already know the length of it.

202
00:12:56,170 --> 00:13:00,540
So why do I need the location and
length of the found string as well?

203
00:13:00,540 --> 00:13:03,890
Let me show you an example of why that's important.

204
00:13:03,890 --> 00:13:05,980
Here, I have a string that contains San Jose.

205
00:13:05,980 --> 00:13:09,320
San Jose is a city about 40 miles
south of here, where I live.

206
00:13:09,320 --> 00:13:14,690
And I'm going to search this string for the
second part, Jose, an easy range of string.

207
00:13:14,690 --> 00:13:20,440
And the result will be in NSRange, as I mentioned, with
the location of 4 pointing to the capital J at the start

208
00:13:20,440 --> 00:13:24,140
and the length of 4 to cover the
4 characters in that string.

209
00:13:24,140 --> 00:13:30,860
Now somebody might come along and say, you know that
San Jose, the E has an accent over it, like this.

210
00:13:30,860 --> 00:13:32,370
And I'd say, you're completely right.

211
00:13:32,370 --> 00:13:33,610
I'm sorry I made that mistake.

212
00:13:33,610 --> 00:13:38,290
And instead, I'll change my search string
to look for an E with an accent over it.

213
00:13:38,290 --> 00:13:43,310
And when I search for it, the result is a
range with a location of 4 and a length of 4.

214
00:13:43,310 --> 00:13:44,220
Same as before, right?

215
00:13:44,220 --> 00:13:49,790
Well, there's another completely valid way for this
string to be stored in memory, and that's like this,

216
00:13:49,790 --> 00:13:54,310
with the E and the accent separated
as two separate characters.

217
00:13:54,310 --> 00:13:55,980
My search string hasn't changed.

218
00:13:55,980 --> 00:14:00,070
But when I look for it, the location
is 4 and the length is 5.

219
00:14:00,070 --> 00:14:05,940
So this is why it's always important to honor
the length part of the returned NSRange.

220
00:14:05,940 --> 00:14:11,350
This is called a decomposed character, by the way.

221
00:14:11,350 --> 00:14:13,640
A couple other notes about searching strings.

222
00:14:13,640 --> 00:14:18,400
If you're looking for something that's
not there, you'll get a length of 0.

223
00:14:18,400 --> 00:14:24,560
And new in iPhone OS 3.2, we added
NSRegularExpressionSearch, a long-requested feature.

224
00:14:24,560 --> 00:14:27,420
Here, I'm searching for the word go, with lowercase g.

225
00:14:27,420 --> 00:14:31,040
And I'm going to find the first
going for this search expression.

226
00:14:31,040 --> 00:14:34,020
In iOS 4, we added a lot more regex support.

227
00:14:34,020 --> 00:14:39,160
And if you missed it, you should check out this
talk on video, Advanced Text Handling for iPhone OS,

228
00:14:39,160 --> 00:14:42,950
where we talked about all the different
regex options you have available to you now.

229
00:14:42,950 --> 00:14:47,580
Next is string encodings.

230
00:14:47,580 --> 00:14:52,610
So, sometimes when people are looking at the string
creation methods, they see this encoding parameter

231
00:14:52,610 --> 00:14:54,720
and they're a little confused about what it means.

232
00:14:54,720 --> 00:14:56,390
But, encodings are not that complicated.

233
00:14:56,390 --> 00:14:59,470
It's just a map of numbers to characters.

234
00:14:59,470 --> 00:15:01,580
One that you might know already is ASCII.

235
00:15:01,580 --> 00:15:09,640
In ASCII, which Foundation represents with NSASCIIStringEncoding, you might have values like 65, 97, and so forth.

236
00:15:09,640 --> 00:15:12,210
And those map to the characters of capital A, lowercase a,

237
00:15:12,210 --> 00:15:17,610
and you see special characters
like tilde also have a mapping.

238
00:15:17,610 --> 00:15:24,380
So, when you create a string from data, it's always
important to know what encoding that data is stored in.

239
00:15:24,380 --> 00:15:27,870
Here, I have some data from a file or a network or wherever.

240
00:15:27,870 --> 00:15:31,810
I'm going to create a string out of
that using initWithData encoding.

241
00:15:31,810 --> 00:15:36,290
I know in advance that the encoding is UTF8StringEncoding.

242
00:15:36,290 --> 00:15:42,020
If you guess about the encoding of your data, it's important
to provide your users with a way to override your guess,

243
00:15:42,020 --> 00:15:46,460
because if you guess wrong, the result can be
characters that look like complete gibberish.

244
00:15:48,390 --> 00:15:52,380
You can also create data in a specified encoding.

245
00:15:52,380 --> 00:15:57,080
Here, I've got a string that's going to go to
Windows, where UTF16 is a lot more prevalent.

246
00:15:57,080 --> 00:16:04,870
So, I call data used in encoding, and I pass an NSUTF16StringEncoding on that-- as a parameter to that method.

247
00:16:04,870 --> 00:16:07,360
And my data will be created in the correct form.

248
00:16:07,360 --> 00:16:13,320
One final note about encodings, if in the course of your
development you find that you need a char star to pass

249
00:16:13,320 --> 00:16:19,770
through a system call, like Open, you should use this
NSString convenience method: fileSystemRepresentation.

250
00:16:19,770 --> 00:16:25,020
This will get you a character pointer that points
to the data in the correct encoding for the system.

251
00:16:25,020 --> 00:16:30,310
And one thing to note about this is that the data
that's pointed to by that char star is autoreleased.

252
00:16:30,310 --> 00:16:33,150
NSString has many more features, as well.

253
00:16:33,150 --> 00:16:37,150
It's got printf-style formatting,
enumeration of substrings, lines and paragraphs.

254
00:16:37,150 --> 00:16:39,220
And it can do this in a language-independent way,

255
00:16:39,220 --> 00:16:45,060
which is a really powerful feature that's
hidden behind some very simple API in NSString.

256
00:16:45,060 --> 00:16:50,170
You can do replacement of substrings, path
completion, and there's a whole mutable class--

257
00:16:50,170 --> 00:16:54,480
a mutable subclass called NSMutableString,
that you can use when you need mutability.

258
00:16:54,480 --> 00:16:58,720
Next is dates and times.

259
00:16:58,720 --> 00:17:03,960
So, Foundation's date and time classes encapsulate
the complexity of date and time calculations.

260
00:17:03,960 --> 00:17:08,200
And I'm going to show you an example
of where that happens in a second.

261
00:17:08,200 --> 00:17:10,300
They automatically handle user preferences.

262
00:17:10,300 --> 00:17:14,810
That means their locale, their
language, their settings and so on.

263
00:17:14,810 --> 00:17:20,150
Most commonly, you're going to use these classes
if you need to represent a date in a calendar,

264
00:17:20,150 --> 00:17:26,360
if you need to find the amount of time between two dates,
and we have formatter classes that let you format a date

265
00:17:26,360 --> 00:17:31,310
or a number correctly for a user no matter where they live.

266
00:17:31,310 --> 00:17:32,910
So, why use these classes?

267
00:17:32,910 --> 00:17:34,490
You can do it yourself, right?

268
00:17:34,490 --> 00:17:35,840
No problem.

269
00:17:35,840 --> 00:17:37,580
Let's do an example.

270
00:17:37,580 --> 00:17:40,900
I've got an app which tells somebody how
long they need to bake their cake for.

271
00:17:40,900 --> 00:17:43,840
And I've got a really huge cake that takes 12 hours to bake.

272
00:17:43,840 --> 00:17:50,080
So, we're just going to display the time 12 hours
from now to let them know when to go get their cake.

273
00:17:50,080 --> 00:17:52,600
So, as I make my app, I test it.

274
00:17:52,600 --> 00:17:59,400
And the date will be November 5, 2006 at 10:00
p.m. I'm going to bake my cake over night.

275
00:17:59,400 --> 00:18:05,420
So I expect the answer to be 12 hours from
now, to be November 6, 2006 at 10:00 a.m.

276
00:18:05,420 --> 00:18:10,760
And the correct answer is the 6th
at 10:00 a.m. So, no difference.

277
00:18:10,760 --> 00:18:11,610
It worked.

278
00:18:11,610 --> 00:18:13,230
Chip it, right?

279
00:18:13,230 --> 00:18:18,750
Except that a year later, a user comes back to you
says, you know, I put my cake in on November 4,

280
00:18:18,750 --> 00:18:24,680
2007 at 10:00 p.m. to bake over
night, but it came out burnt.

281
00:18:24,680 --> 00:18:30,960
It should have been November 5, 2007 at 9:00 a.m. And
the reason is because Daylight Savings Time ended.

282
00:18:30,960 --> 00:18:34,070
And you say, no problem.

283
00:18:34,070 --> 00:18:36,360
I can encode those rules in my app.

284
00:18:36,360 --> 00:18:41,800
And actually, the laws about Daylight
Savings Time changed between 2006 and 2007.

285
00:18:41,800 --> 00:18:42,210
But no problem.

286
00:18:42,210 --> 00:18:47,050
I can put that in my app, and the next time that this
happens, I'm going to expect 9:00 a.m. as a result.

287
00:18:47,050 --> 00:18:50,500
And then the user comes and says, it didn't work.

288
00:18:50,500 --> 00:18:55,970
The correct answer should have been
November 5 at 10 a.m. And you might ask why.

289
00:18:55,970 --> 00:19:00,630
It's because that the user lives in Phoenix,
where Daylight Savings Time isn't used.

290
00:19:01,790 --> 00:19:05,340
So these are just a couple examples of the
hundreds or thousands of rules that make

291
00:19:05,340 --> 00:19:08,580
up the complexities of handling dates and times.

292
00:19:08,580 --> 00:19:12,200
And in Foundation, we have a few
classes that can do this for you.

293
00:19:12,200 --> 00:19:13,680
So, let's see what those are.

294
00:19:13,680 --> 00:19:15,850
The first is NSDate.

295
00:19:15,850 --> 00:19:19,610
NSDate represents an invariant point in time.

296
00:19:19,610 --> 00:19:20,980
This is really important.

297
00:19:20,980 --> 00:19:23,540
Dates are calendar and time zone independent.

298
00:19:23,540 --> 00:19:29,060
You can't present an NSDate to a user
without knowing a calendar and time zone.

299
00:19:29,060 --> 00:19:32,590
Dates measure their time in seconds,
so it's a reference point.

300
00:19:32,590 --> 00:19:35,670
The value is a double, so you can
represent fractional seconds.

301
00:19:35,670 --> 00:19:39,810
The next class is NSCalendar.

302
00:19:39,810 --> 00:19:43,550
NSCalendar is what defines the beginning,
length, divisions and end of a year.

303
00:19:43,550 --> 00:19:49,080
One that you're familiar with is the
Gregorian calendar, June 10, 2010, for example.

304
00:19:49,080 --> 00:19:51,220
There are others, like the Hebrew calendar.

305
00:19:51,220 --> 00:19:55,350
And finally, NSDateComponents.

306
00:19:55,350 --> 00:19:58,350
NSDateComponents is basically a simple object structure.

307
00:19:58,350 --> 00:20:03,230
It holds storage for years, months, days, minutes and so on.

308
00:20:03,230 --> 00:20:09,760
Again, the exact meaning of these
properties depends on the calendar.

309
00:20:09,760 --> 00:20:15,870
And in fact, the values in this day components object can
be relative or absolute, depending on how you use them.

310
00:20:15,870 --> 00:20:17,150
So let's see another example.

311
00:20:17,150 --> 00:20:24,980
I'm going to calculate the number of shopping days
between the U.S. Thanksgiving holiday and Christmas.

312
00:20:24,980 --> 00:20:28,360
Christmas, of course, is on the
same date every year, December 25.

313
00:20:28,360 --> 00:20:33,530
In the United States, Thanksgiving falls
on the fourth Thursday in November.

314
00:20:33,530 --> 00:20:37,760
And I'm going to define the shopping season
as starting on the day after Thanksgiving,

315
00:20:37,760 --> 00:20:42,750
also known as Black Friday, and ending on Christmas Eve.

316
00:20:42,750 --> 00:20:44,630
So, first let's find Christmas.

317
00:20:44,630 --> 00:20:45,690
I create a calendar.

318
00:20:45,690 --> 00:20:47,190
Remember, we need a calendar.

319
00:20:47,190 --> 00:20:50,690
This one is a Gregorian calendar, which is what's
used in the United States and we're talking

320
00:20:50,690 --> 00:20:53,530
about U.S. Thanksgiving, so it's appropriate.

321
00:20:53,530 --> 00:20:56,220
Now, I create one of those date components objects.

322
00:20:56,220 --> 00:20:58,110
I'm going to fill it out with some values.

323
00:20:58,110 --> 00:21:03,690
I set the year to this year, the month
to 12 for December and the day to 25.

324
00:21:03,690 --> 00:21:08,180
Then, I call NSCalendars method, dateFromComponents.

325
00:21:08,180 --> 00:21:14,000
I pass in my date components object and I get
an NSDate result in the current time zone.

326
00:21:14,000 --> 00:21:17,230
I could find Thanksgiving in a similar way.

327
00:21:17,230 --> 00:21:19,440
I create another date components object.

328
00:21:19,440 --> 00:21:25,800
I set the year, the month to 11 for November,
the weekday to 5, because 5 means Thursday

329
00:21:25,800 --> 00:21:29,730
in the NS Gregorian calendar, and the weekday ordinal to 4.

330
00:21:29,730 --> 00:21:34,360
That means find the fourth Thursday in November of 2010.

331
00:21:34,360 --> 00:21:38,960
I use the same method, dateFromComponents, to get a
date representing Thanksgiving in the current time zone.

332
00:21:38,960 --> 00:21:39,970
Now, I need to find Black Friday.

333
00:21:39,970 --> 00:21:43,150
And I can do that by adding a date component object.

334
00:21:43,150 --> 00:21:46,220
Here, you see I'm going to create
another one and set its day value to 1.

335
00:21:46,220 --> 00:21:51,610
So here, it's a relative value, not an absolute
value as we saw on some of the previous slides.

336
00:21:51,610 --> 00:21:55,600
Then I use the NSCalendar method,
dateByAddingComponents: toDate: options.

337
00:21:55,600 --> 00:21:59,560
I pass in Thanksgiving, and the date
components we're adding, the plus 1 day.

338
00:21:59,560 --> 00:22:02,440
And the result is a date representing Black Friday.

339
00:22:02,440 --> 00:22:09,060
And finally, I can get the answer I was looking
for, which is the amount of time between two dates.

340
00:22:09,060 --> 00:22:11,700
The result, here, is an NSDate components object.

341
00:22:11,700 --> 00:22:15,540
And I call NSCalendarsComponents:fromDate:toDate:options.

342
00:22:15,540 --> 00:22:21,360
The components parameter is not a date components object,
but a set of flags, which tells NSCalendar which values

343
00:22:21,360 --> 00:22:23,290
in the date components we want filled out.

344
00:22:23,290 --> 00:22:24,470
I'm interested in days.

345
00:22:24,470 --> 00:22:29,280
You can also specify years, minutes,
seconds or any combination of those.

346
00:22:29,280 --> 00:22:33,890
The from date is Black Friday, the to date is
Christmas, midnight on Christmas will be the end time.

347
00:22:33,890 --> 00:22:35,900
And no options.

348
00:22:35,900 --> 00:22:39,830
The result, in this case, is 29 days.

349
00:22:39,830 --> 00:22:43,100
There are many more features on dates and time classes.

350
00:22:43,100 --> 00:22:45,460
You can find the day of the week for a date.

351
00:22:45,460 --> 00:22:50,430
Your homework is to find the day of the
week that Christmas falls on this year.

352
00:22:50,430 --> 00:22:55,330
There are time zone calculation APIs and
methods to convert between calendars.

353
00:22:55,330 --> 00:22:57,400
Next is NSFormatter.

354
00:22:57,400 --> 00:23:02,290
Foundation has a class called NSFormatter that
is for converting values to and from strings.

355
00:23:02,290 --> 00:23:06,060
And there are two main NSFormatter
subclasses that I want to talk about today.

356
00:23:06,060 --> 00:23:10,480
The first is NSDateFormatter that
converts dates to or from strings.

357
00:23:10,480 --> 00:23:15,740
And the second is NSNumberFormatter,
which converts numbers to or from strings.

358
00:23:15,740 --> 00:23:19,630
Both of these have a set of predefined
styles, or you can use your own.

359
00:23:19,630 --> 00:23:23,330
But I recommend that you stick with
the predefined styles, and here's why.

360
00:23:23,330 --> 00:23:27,470
Here in the Language and Text Preferences on
Mac OS X, you can see I'm in the Formats tab.

361
00:23:27,470 --> 00:23:31,890
And my region is set to United States.

362
00:23:31,890 --> 00:23:35,190
These are the standard date formats in that region.

363
00:23:35,190 --> 00:23:37,660
There's a full, long, medium and short style.

364
00:23:37,660 --> 00:23:42,170
And those correspondents and constants
you can use with NSDateFormatter.

365
00:23:42,170 --> 00:23:45,170
Let's focus on the short style.

366
00:23:45,170 --> 00:23:49,430
In the United States, we put the month first,
then the day, and then a two-digit year.

367
00:23:49,430 --> 00:23:53,970
And if we look a little bit further
down on here, we see a number as well.

368
00:23:53,970 --> 00:24:00,170
In the United States, a comma is used as a
thousand separator and there's a decimal point.

369
00:24:00,170 --> 00:24:07,200
Now, if instead, your user lives in, say, South Africa,
in South Africa, the formats are completely different.

370
00:24:07,200 --> 00:24:10,620
The short style, the year, is 2010, there.

371
00:24:10,620 --> 00:24:12,670
It's four digits instead of two.

372
00:24:12,670 --> 00:24:17,060
The month is zero padded and then the day comes last.

373
00:24:17,060 --> 00:24:22,730
And in the numbers section, you see that there's
a space for the thousand separator instead

374
00:24:22,730 --> 00:24:26,230
of a comma, and a comma instead of a decimal point.

375
00:24:26,230 --> 00:24:31,090
So when you use the predefined styles for
date formatters and number formatters,

376
00:24:31,090 --> 00:24:34,990
your dates and numbers will look correct
for a user no matter where they live.

377
00:24:34,990 --> 00:24:37,060
And using them is actually really easy.

378
00:24:37,060 --> 00:24:39,510
Here, I'm going to create a date formatter object.

379
00:24:39,510 --> 00:24:43,070
I'm going to format the Thanksgiving
date that we found earlier.

380
00:24:43,070 --> 00:24:46,300
So, I don't care about the time
because Thanksgiving lasts all day.

381
00:24:46,300 --> 00:24:50,790
And I want to use the long style for the date part.

382
00:24:50,790 --> 00:24:56,400
Then I call stringFromDate, pass in Thanksgiving
and the result will be November 25, 2010.

383
00:24:56,400 --> 00:25:02,490
Now, here I used the current system time zone and calendar,
because I haven't specified them to the formatter.

384
00:25:02,490 --> 00:25:05,900
If instead, you're parsing a date, you
can use a formatter for that as well.

385
00:25:05,900 --> 00:25:10,290
I'm going to create the day formatter,
set its date format string.

386
00:25:10,290 --> 00:25:14,600
And the contents of this string describe to
the date formatter what values I'm looking

387
00:25:14,600 --> 00:25:18,460
for in my string that I'm going to pass in, in a second.

388
00:25:18,460 --> 00:25:25,010
Here, it's important, especially if you're
parsing a file, to use your own time zone.

389
00:25:25,010 --> 00:25:26,890
If you don't set it, it will use the system --

390
00:25:26,890 --> 00:25:31,100
the current system time zone and calendar,
which may not be what you're expecting.

391
00:25:31,100 --> 00:25:35,830
I know in advance that this is -- these dates
I'm parsing are from Los Angeles's time zone.

392
00:25:35,830 --> 00:25:38,790
And the calendar will be the Gregorian
calendar that we created earlier.

393
00:25:38,790 --> 00:25:41,340
Then I pass in a string.

394
00:25:41,340 --> 00:25:45,850
I pass in about now and I will have an NSDate result.

395
00:25:45,850 --> 00:25:53,380
I want to point out that the format
string uses this Unicode standard, TR35-6.

396
00:25:53,380 --> 00:25:59,810
Before you use a string in this method, make sure that
you know exactly what the characters in there mean.

397
00:25:59,810 --> 00:26:03,540
There are many subtle variations of strings
that mean completely different things.

398
00:26:03,540 --> 00:26:07,620
So, as a quick summary of dates and formatters,
I think this is very important to remember.

399
00:26:07,620 --> 00:26:11,490
NSDate and NSCalendar go together
when you're using time calculations.

400
00:26:11,490 --> 00:26:16,500
And remember to always use formatters when you're
displaying a date or any numbers to your user.

401
00:26:16,500 --> 00:26:18,660
That way, it will look correct no matter where they live.

402
00:26:18,660 --> 00:26:22,190
Next is persistence and archiving.

403
00:26:22,190 --> 00:26:28,700
Persistence is all about storing stuff on disk,
and presumable reading it back at a later time.

404
00:26:28,700 --> 00:26:31,460
In Foundation, we have many methods
to help you with persistence.

405
00:26:31,460 --> 00:26:33,530
The first is property lists.

406
00:26:33,530 --> 00:26:35,180
We also have user preferences.

407
00:26:35,180 --> 00:26:37,720
Those are kind of persisted data.

408
00:26:37,720 --> 00:26:39,610
Keyed archiving.

409
00:26:39,610 --> 00:26:43,230
And I also want to touch on large,
complex data structures as well.

410
00:26:43,230 --> 00:26:44,960
So first, property lists.

411
00:26:44,960 --> 00:26:51,070
In Foundation, the NSPropertyListSerialization is the
class you're going to use to interact with property lists.

412
00:26:51,070 --> 00:26:59,370
Property lists, or plists, for short, store a small amount
of structured data, the operative word there being small.

413
00:26:59,370 --> 00:27:05,050
Property lists have the benefit of being cross-platform
and human readable when you use the XML format.

414
00:27:05,050 --> 00:27:08,660
Plists also have a binary format that is better performing.

415
00:27:08,660 --> 00:27:12,590
So you can choose which format to use
depending on what your requirements are.

416
00:27:12,590 --> 00:27:17,680
There's a very strict set of types
that are allowed in a plist.

417
00:27:17,680 --> 00:27:21,940
For collections, you may use an NSArray or an NSDictionary.

418
00:27:21,940 --> 00:27:27,900
Strings, dates, numbers, in integer
floating point and Boolean forms and NSData.

419
00:27:27,900 --> 00:27:32,240
Now, the presence of NSData means that you can
stop anything in a data and put it in a plist.

420
00:27:32,240 --> 00:27:36,060
But again, I want to emphasize that plists
are designed for small amounts of data,

421
00:27:36,060 --> 00:27:41,510
so don't put huge files using NSData in property lists.

422
00:27:41,510 --> 00:27:44,090
Let's see a quick example.

423
00:27:44,090 --> 00:27:46,430
This morning, I decided I was going to learn Spanish.

424
00:27:46,430 --> 00:27:51,010
And so I've made some progress on mapping
Spanish color names to English color names.

425
00:27:51,010 --> 00:27:52,460
And I want to save that.

426
00:27:52,460 --> 00:27:58,570
So, I am going to serialize it to an NSData in XML format.

427
00:27:58,570 --> 00:28:04,010
I use NSPropertyListSerialization method,
dataWithPropertyList:format:options: error.

428
00:28:04,010 --> 00:28:07,290
You see my first parameter is the
colors dictionary that I'm saving.

429
00:28:07,290 --> 00:28:11,870
The second parameter is the format I
want this plist in, XML in this case.

430
00:28:11,870 --> 00:28:17,040
Now, this method, this exact form of this
method, is new in Snow Leopard and iOS 4.

431
00:28:17,040 --> 00:28:21,460
There are other versions of this method which are
very similar that go back to the start of Mac OS X.

432
00:28:21,460 --> 00:28:27,710
I chose this one because I want to highlight a pattern that
you see across all of Foundation and Cocoa and Cocoa Touch,

433
00:28:27,710 --> 00:28:30,440
and that is the use of the error parameter.

434
00:28:30,440 --> 00:28:34,940
You see, I passed in the address of an error
object, an address of an address of an error object.

435
00:28:34,940 --> 00:28:39,350
And I want to know if this method worked.

436
00:28:39,350 --> 00:28:42,320
The correct answer when dealing
with error parameters is always

437
00:28:42,320 --> 00:28:46,740
to check the return value of the method first, like this.

438
00:28:46,740 --> 00:28:50,060
If plist is nil, then the error
parameter has been filled out.

439
00:28:50,060 --> 00:28:52,790
And I can present it to the user like I do here.

440
00:28:52,790 --> 00:28:55,760
NSErrors are designed to be presented to the user.

441
00:28:55,760 --> 00:29:00,660
If plist is not nil, the error parameter that
you pass in will be completely untouched.

442
00:29:00,660 --> 00:29:03,490
Foundation will not modify it in any way.

443
00:29:03,490 --> 00:29:05,910
So don't assume that it will be
set to nil if there's no error.

444
00:29:05,910 --> 00:29:09,860
The proper way to do this is check
the result and then use the error.

445
00:29:09,860 --> 00:29:17,830
Now, to read that data out, I'm going to read it from a
file, perhaps, using data with contents of URL on NSData.

446
00:29:17,830 --> 00:29:20,160
And we'll, of course, talk about URLs later.

447
00:29:20,160 --> 00:29:24,530
But now I have my data and I'll pass it to
propertyListWithData: options: format: error.

448
00:29:24,530 --> 00:29:32,960
I pass in my read data, and the result is
the dictionary that we had persisted earlier.

449
00:29:32,960 --> 00:29:36,110
And again, make sure that you do the
right thing with the error parameter.

450
00:29:36,110 --> 00:29:38,570
So next is user defaults.

451
00:29:38,570 --> 00:29:44,750
User defaults are also for small values, but
small values that represent user preferences.

452
00:29:44,750 --> 00:29:47,470
We organize user defaults by what we call domains.

453
00:29:47,470 --> 00:29:49,790
A domain is just a group of defaults.

454
00:29:49,790 --> 00:29:56,090
When you read a default, we search
domains in a specific order.

455
00:29:56,090 --> 00:29:58,590
First is the arguments to the executable.

456
00:29:58,590 --> 00:30:00,960
This is what we all a volatile domain.

457
00:30:00,960 --> 00:30:05,750
Volatile means that the contents of
this domain are not persisted to disk.

458
00:30:05,750 --> 00:30:09,690
Next is the one that you'll probably see most
frequently, that's the application domain.

459
00:30:09,690 --> 00:30:12,650
These are stored in the user home directory.

460
00:30:12,650 --> 00:30:15,490
There's also a global domain, a language domain

461
00:30:15,490 --> 00:30:20,180
for locale-specific preferences,
and finally, a registration domain.

462
00:30:20,180 --> 00:30:24,240
The registration domain is for the
factory settings of your application.

463
00:30:24,240 --> 00:30:26,920
And let's see an example of how to use that first.

464
00:30:26,920 --> 00:30:32,270
So, we recommend that you set up those factory
settings early in the start up of your app.

465
00:30:32,270 --> 00:30:40,270
Here, in the plus initialize method of a class which uses
user defaults, I am going to create some default values.

466
00:30:40,270 --> 00:30:42,570
Here, I'm going to create a dictionary.

467
00:30:42,570 --> 00:30:44,170
My first value is a Boolean, FrogBlastVentCore.

468
00:30:44,170 --> 00:30:48,740
And next I have a string and also an integer value.

469
00:30:48,740 --> 00:30:56,150
Now, to interact with our user default system, you
call the NSUser defaults method, standardUserDefaults,

470
00:30:56,150 --> 00:30:59,420
to get the user default singleton object.

471
00:30:59,420 --> 00:31:02,430
Then, call the registerDefaults method on that object.

472
00:31:02,430 --> 00:31:07,380
Pass in your dictionary with your
default values and you're good to go.

473
00:31:07,380 --> 00:31:10,280
So, sometime later, we're going to read that value.

474
00:31:10,280 --> 00:31:14,610
Here, I'm going to use the NSUser
defaults convenience method, boolForKey.

475
00:31:14,610 --> 00:31:19,560
I pass in FrogBlastVentCore and the result will be
YES, because we searched through our domains

476
00:31:19,560 --> 00:31:21,850
and we ended up in the registration domain.

477
00:31:21,850 --> 00:31:25,550
And we read the value that we had just set up.

478
00:31:25,550 --> 00:31:30,840
I want to show you how the argument domain works,
because it's a really useful debugging tip.

479
00:31:30,840 --> 00:31:35,570
Here, I pass in ConferencName and WWDC.

480
00:31:35,570 --> 00:31:39,830
I can get that value by just calling
the user defaults method stringForKey.

481
00:31:39,830 --> 00:31:46,170
And it will check the first domain, which is the argument
domain, and get the value out of there, WWDC in this case.

482
00:31:46,170 --> 00:31:48,550
Setting user defaults is also very simple.

483
00:31:48,550 --> 00:31:53,880
Here, I'm going to change FrogBlastVentCore to
a value of NO by using setBool forKey.

484
00:31:53,880 --> 00:32:00,860
And then, sometime later, presumably after my application
has quit and restarted, or not, you can call boolForKey,

485
00:32:00,860 --> 00:32:04,790
pass in FrogBlastVentCore and the result will
be NO, because we found that default

486
00:32:04,790 --> 00:32:07,110
in the application domain where it was persisted.

487
00:32:07,110 --> 00:32:08,700
Keyed archiving is next.

488
00:32:08,700 --> 00:32:11,680
Keyed archiving is for storing
an arbitrary graph of objects.

489
00:32:11,680 --> 00:32:16,440
Keyed archiving's primary design purpose is to
enable easy backward and forward compatibility.

490
00:32:16,440 --> 00:32:22,150
That's because in a keyed archive, the way it works
is you associated keys with your object values.

491
00:32:22,150 --> 00:32:25,300
That means that you can add a key
in a future version of your app,

492
00:32:25,300 --> 00:32:30,390
and the past versions of your app don't
have to read that key, and vice versa.

493
00:32:30,390 --> 00:32:35,810
Keyed archiving also allows for substitutions
during encoding and decoding of objects,

494
00:32:35,810 --> 00:32:38,830
and it has the benefit that the objects
you store in a keyed archive don't need

495
00:32:38,830 --> 00:32:41,440
to be one of those set of property lists types.

496
00:32:41,440 --> 00:32:46,000
The way that the keyed archiver knows
how to encode and decode your objects is

497
00:32:46,000 --> 00:32:49,570
by the NSCoding protocol that your objects implement.

498
00:32:49,570 --> 00:32:51,610
So, let's see an example of how you do that.

499
00:32:51,610 --> 00:32:55,300
Here, I have a robot object, which
implements NSCoding, as you can see.

500
00:32:55,300 --> 00:32:59,890
And my robot has several properties, a name,
which is an NSString object, another robot,

501
00:32:59,890 --> 00:33:03,240
which is this robot's nemesis, and a model number.

502
00:33:03,240 --> 00:33:07,760
Now, to implement NSCoding, I need
to fill out just two methods.

503
00:33:07,760 --> 00:33:09,920
The first is encodeWithCoder.

504
00:33:09,920 --> 00:33:12,810
The parameter to this method will be the keyed archiver.

505
00:33:12,810 --> 00:33:19,310
To encode our object, we need to tell the keyed archiver
how to store the data that we have as our properties.

506
00:33:19,310 --> 00:33:25,430
We do that using methods like these: encodeObject:
forKey, encodeInteger: forKey, and so forth.

507
00:33:25,430 --> 00:33:31,470
You see them giving every object value in my
class a name, like name and nemesis and model.

508
00:33:31,470 --> 00:33:35,350
The other method you need to implement initWithCoder.

509
00:33:35,350 --> 00:33:40,130
In initWithCoder, the parameter
will be the keyed unarchiver.

510
00:33:40,130 --> 00:33:45,140
To init ourselves first, this is an init method, so
we need to call Super and return Self at the end.

511
00:33:45,140 --> 00:33:51,820
And one caveat here, if you're Super class implements
NSCoding, you should call nitiWithCoder and also,

512
00:33:51,820 --> 00:33:54,610
in encodeWithCoder, call your Super class as well.

513
00:33:54,610 --> 00:33:57,060
Here, my Super class is NSObjects, so this is fine.

514
00:33:57,060 --> 00:34:04,140
And I need to ask the keyed unarchiver for the data
that we had given it earlier, using methods like these:

515
00:34:04,140 --> 00:34:07,550
decodeObject:forKey, and decodeInteger:forKey.

516
00:34:07,550 --> 00:34:13,500
Now, remember that for the objects, you're going
to need to copy or retain them as appropriate.

517
00:34:13,500 --> 00:34:15,640
Integers, of course, don't need to be copied or retained.

518
00:34:15,640 --> 00:34:19,410
As a quick sample to see that this
works, I've got two robot objects.

519
00:34:19,410 --> 00:34:22,220
I'm going to set some values on those robot objects.

520
00:34:22,220 --> 00:34:25,660
And you notice that R1 and R2 are each other's nemesis.

521
00:34:25,660 --> 00:34:28,230
So there's a cycle there.

522
00:34:28,230 --> 00:34:30,190
But keyed archiver can handle that.

523
00:34:30,190 --> 00:34:34,740
I call ArchivedDataWithRootObject,
pass in R2 and the result is an NSData

524
00:34:34,740 --> 00:34:39,010
that holds all of the data in that object graph.

525
00:34:39,010 --> 00:34:47,400
To unarchive it, call unarchiveObjectWithData, pass in
our data, and the result will be our new robot R3 object.

526
00:34:47,400 --> 00:34:51,520
And to verify that it worked, I'm going
to check with R3's nemesis' name is

527
00:34:51,520 --> 00:34:54,620
and it is Bender, as we set up on our previous slide.

528
00:34:54,620 --> 00:34:57,680
I mentioned larger, more complex data structures.

529
00:34:57,680 --> 00:35:00,440
I want to point you towards the Core Data framework.

530
00:35:00,440 --> 00:35:02,090
Core Data is its own framework.

531
00:35:02,090 --> 00:35:04,980
We have support for it in Foundation as well.

532
00:35:04,980 --> 00:35:07,960
Core Data has many features.

533
00:35:07,960 --> 00:35:11,000
It supports keyed value coding and
keyed value observing directly.

534
00:35:11,000 --> 00:35:17,190
You can validate the values that your user inputs and
maintain consistency of the relationships between objects.

535
00:35:17,190 --> 00:35:22,400
It supports change tracking and undo,
sophisticated queries, and unlike the previous forms

536
00:35:22,400 --> 00:35:25,390
of persistence that we've seen, incremental editing.

537
00:35:25,390 --> 00:35:29,370
There was a session yesterday on Core Data, called
Mastering Core Data, that you could check out.

538
00:35:29,370 --> 00:35:32,130
And I believe they have another lab this week, as well.

539
00:35:32,130 --> 00:35:33,620
If not, check out the documentation online.

540
00:35:33,620 --> 00:35:36,860
Core Data is a really powerful framework.

541
00:35:37,950 --> 00:35:40,400
So, I showed you many methods of persistence.

542
00:35:40,400 --> 00:35:43,000
Again, how do you pick which one to use?

543
00:35:43,000 --> 00:35:47,090
So, if you're storing user preferences, use NSUserDefaults.

544
00:35:47,090 --> 00:35:52,070
If you have small files, and you
want to cross platform file format,

545
00:35:52,070 --> 00:35:56,290
you can consider NSPropertyListSerialization with XML format.

546
00:35:56,290 --> 00:36:02,930
If you have an object graph with cycles and non-property
lists types, you can consider using the NSKeyedArchiver.

547
00:36:02,930 --> 00:36:06,710
And a real-world example of where the
keyed archiver is used is nib files.

548
00:36:06,710 --> 00:36:08,980
All of your nib files are keyed archives.

549
00:36:08,980 --> 00:36:16,090
And if you have a large data set, or you need
database-like features, check out the Core Data framework.

550
00:36:16,090 --> 00:36:18,340
And there's one more option which I don't want to neglect.

551
00:36:18,340 --> 00:36:24,220
If you have a very complicated set of data, or a very
specific set of data, and you don't need the features

552
00:36:24,220 --> 00:36:32,050
that are provided by our Foundation classes,
you can use your own custom data format.

553
00:36:32,050 --> 00:36:35,010
You probably would be looking at the
NSData class to help you out with that.

554
00:36:35,010 --> 00:36:36,780
Next is Files and URLs.

555
00:36:36,780 --> 00:36:40,900
So, NSURL is our preferred way
to reference files and resources.

556
00:36:40,900 --> 00:36:47,320
And especially starting in Snow Leopard and iOS
4, you'll see a lot more URL taking methods.

557
00:36:47,320 --> 00:36:52,160
If you're working with a file URL, then
you will use our NSFileManager class.

558
00:36:52,160 --> 00:36:56,990
If you're working with a network URL,
you will use our URL loading classes.

559
00:36:56,990 --> 00:37:00,730
So, let's look at some NSURL examples,
and then we'll see the others.

560
00:37:00,730 --> 00:37:07,070
Here, I'm creating a file URL with a
path to a file in my home directory.

561
00:37:07,070 --> 00:37:12,160
NSURL has many methods to manipulate URLs, so you
don't need to poke with the characters yourself.

562
00:37:12,160 --> 00:37:17,680
This one will delete the last path component and
give me a URL that points to my home directory only.

563
00:37:17,680 --> 00:37:22,900
I can append a path component and get
another file in my home directory.

564
00:37:22,900 --> 00:37:33,550
And for network URLs, you can create them like this:
URLWithString, I pass in Apple.com, accessed over HTTP.

565
00:37:33,550 --> 00:37:36,920
The NSURL class itself has other features as well.

566
00:37:36,920 --> 00:37:39,460
There's a concept of file reference URLs.

567
00:37:39,460 --> 00:37:46,190
The primary purpose of these is to maintain your
tracking of a file independent of its location on disk.

568
00:37:46,190 --> 00:37:49,480
That is, you want a reference to
a file and the user moves it.

569
00:37:49,480 --> 00:37:51,440
File reference URLs can help in that scenario.

570
00:37:51,440 --> 00:37:56,990
On Mac OS X, we have a rich system
of file system resource properties.

571
00:37:56,990 --> 00:38:00,840
You use them like this: getResourceValue:forKey:error.

572
00:38:00,840 --> 00:38:07,620
Here, I'm passing in the URL effective icon key and the
result will be an NSImage that has the icon of that file.

573
00:38:07,620 --> 00:38:13,880
There are many more keys you can specify
to get localized name, file size, creation,

574
00:38:13,880 --> 00:38:18,720
access and modification dates,
and label color and many more.

575
00:38:18,720 --> 00:38:24,530
You should see the NSURL header on Mac OS X for a
full list of all the properties that we support.

576
00:38:24,530 --> 00:38:29,610
NSFileManager lets you copy, move, link or delete files.

577
00:38:29,610 --> 00:38:38,990
You use it like this: Create your file manager object, then
call methods like: copyItemAtURL: toURL:error, and so forth.

578
00:38:38,990 --> 00:38:43,960
NSFileManager also has the capability
to enumerate directory contents.

579
00:38:43,960 --> 00:38:46,640
This method, contentsOfDirectoryAtURL:

580
00:38:46,640 --> 00:38:50,700
includingPropertiesForKeys:options:error,
does a shallow enumeration.

581
00:38:50,700 --> 00:38:53,180
That is, it won't descend into subdirectories.

582
00:38:53,180 --> 00:38:56,510
Now, here you see the second parameter
is an array of properties.

583
00:38:56,510 --> 00:39:03,580
This is a really efficient way to get a set of properties
for a bunch of files in a directory, like all of the icons,

584
00:39:03,580 --> 00:39:08,710
all of the modification dates, all
of the file sizes and so forth.

585
00:39:08,710 --> 00:39:12,500
NSFileManager also has another method,
which lets you enumerate directories

586
00:39:12,500 --> 00:39:16,040
in a recursive subfashion, that
is, descending into subdirectories.

587
00:39:16,040 --> 00:39:19,910
That method returns an NSEnumerator
subclass, which you should remember

588
00:39:19,910 --> 00:39:22,690
from our first section, is pretty easy to use as well.

589
00:39:22,690 --> 00:39:29,830
It also supports finding system directories,
application directory of the Desktop and so forth.

590
00:39:29,830 --> 00:39:32,880
It has delegate methods for detail control.

591
00:39:32,880 --> 00:39:36,060
So you can set up a file manager
to call your delegate methods

592
00:39:36,060 --> 00:39:42,560
when you're moving files any time an error
occurs on any file and scenarios like that.

593
00:39:42,560 --> 00:39:46,090
And you can get and set permissions
and other attributes on files.

594
00:39:46,090 --> 00:39:50,130
So, if you have a network URL, you're
going to check out our URL loading system.

595
00:39:50,130 --> 00:39:53,220
The primary class there is NSURLConnection.

596
00:39:53,220 --> 00:39:55,070
This class performs the loading of a URL.

597
00:39:55,070 --> 00:39:57,230
And there are two modes of operation.

598
00:39:57,230 --> 00:40:01,470
The first is asynchronous, using
run loops and delegate callbacks.

599
00:40:01,470 --> 00:40:04,760
And the second method is synchronous for background threads.

600
00:40:04,760 --> 00:40:09,090
Never block your user interface,
your main thread, on network access.

601
00:40:09,090 --> 00:40:12,840
The other two classes are NSURLRequest and NSURLResponse.

602
00:40:12,840 --> 00:40:16,450
These are classes used to store
data used when you're loading.

603
00:40:16,450 --> 00:40:23,560
As an example, we are going to load the Apple Home
Page with the Apple URL that we created earlier.

604
00:40:23,560 --> 00:40:28,520
I create my URL request, and then
I create my URL connection object.

605
00:40:28,520 --> 00:40:31,950
I call initWithRequest:delegate:startImmediately.

606
00:40:31,950 --> 00:40:35,020
I pass in the request and I set ourselves as a delegate.

607
00:40:35,020 --> 00:40:36,770
And we'll see those methods in a second.

608
00:40:36,770 --> 00:40:38,730
And I tell it to start immediately.

609
00:40:38,730 --> 00:40:41,220
But this won't do anything until you run the run loop.

610
00:40:41,220 --> 00:40:44,250
So, if this is on your main thread, run the main run loop.

611
00:40:44,250 --> 00:40:48,590
And this is also how you avoid blocking your user interface.

612
00:40:49,820 --> 00:40:52,950
These delegate methods will be called
when something interesting happens.

613
00:40:52,950 --> 00:40:58,590
Before any data is received, you will receive
the connection:didReceiveResponse method.

614
00:40:58,590 --> 00:41:03,020
Here, I'm going to set up some data to
hold the received data that we have --

615
00:41:03,020 --> 00:41:04,410
we're going to receive on our connection.

616
00:41:04,410 --> 00:41:09,530
Next is the connection:didReceiveData.

617
00:41:09,530 --> 00:41:15,170
This is called one or more times with
the actual data that's been received.

618
00:41:15,170 --> 00:41:18,740
I'm just going to append it to our received data object.

619
00:41:21,310 --> 00:41:26,990
If something goes wrong, this method will
be called, connection:didFailWithError.

620
00:41:26,990 --> 00:41:30,630
You should do whatever error handling
is appropriate for your app here.

621
00:41:30,630 --> 00:41:35,210
And finally, if everything worked great, we're
going to get: connection:didFinishLoading.

622
00:41:35,210 --> 00:41:39,570
And there, you should use the received data.

623
00:41:39,570 --> 00:41:44,940
These classes support other features as
well: cache management, authentication,

624
00:41:44,940 --> 00:41:48,490
cookies and support for protocols other than HTTP.

625
00:41:48,490 --> 00:41:51,690
Next up is bundles.

626
00:41:51,690 --> 00:41:55,270
Bundles are for grouping code and resources.

627
00:41:55,270 --> 00:41:59,630
They allow you to include code for
different platforms and architectures.

628
00:41:59,630 --> 00:42:06,680
For example, on Mac OS X, you can have an app which
supports Power PC, Intel 32-bit and Intel 64 bit.

629
00:42:06,680 --> 00:42:10,260
Also bundles simplify the loading of localized resources.

630
00:42:10,260 --> 00:42:13,620
Let's see an example of that.

631
00:42:13,620 --> 00:42:17,050
So, here is an example bundle layout on Mac OS X.

632
00:42:17,050 --> 00:42:20,620
You see, it's for my application, which is a directory.

633
00:42:20,620 --> 00:42:22,670
And in the contents, I have an info plist.

634
00:42:22,670 --> 00:42:26,640
This is a property list which describes
the attributes of my application.

635
00:42:26,640 --> 00:42:29,060
Here is the actual executable code.

636
00:42:29,060 --> 00:42:33,090
And in the resources subdirectory
are non-localized resources.

637
00:42:33,090 --> 00:42:36,100
This is the icon for my application.

638
00:42:36,100 --> 00:42:41,770
There are also directories for all of the
languages that my application supports.

639
00:42:41,770 --> 00:42:44,140
I support English and French.

640
00:42:44,140 --> 00:42:48,320
And inside those directories, we have localized resources.

641
00:42:48,320 --> 00:42:55,180
Here is a localized image, a main menu, the entire
nim file is localized, and localized strings.

642
00:42:55,180 --> 00:43:00,360
Now, to load a localized resource, I'm
going to first get the application bundle.

643
00:43:00,360 --> 00:43:05,790
And I can do that with the NSBundles main bundle method.

644
00:43:05,790 --> 00:43:13,520
Then I call URL for resource with extension, pass in my
localized image name and extension, and if my user's running

645
00:43:13,520 --> 00:43:17,420
on an English system, they'll get
this wonderful image of a stop sign.

646
00:43:17,420 --> 00:43:22,470
If instead, they're running on a French
system, they will get this wonderful image

647
00:43:22,470 --> 00:43:25,530
of a stop sign, which is the same, but in French.

648
00:43:25,530 --> 00:43:29,560
And you notice that we didn't have
to change our code at all.

649
00:43:29,560 --> 00:43:38,090
This behavior is entirely driven by NSBundleCode and
the resources that you have in your application bundle.

650
00:43:38,090 --> 00:43:45,070
Now, sometimes it's easy to confuse what the
difference between a bundle and a package.

651
00:43:45,070 --> 00:43:48,650
Bundles, as we've mentioned, the primary class is NSBundle.

652
00:43:48,650 --> 00:43:50,540
Use it for code and resources.

653
00:43:50,540 --> 00:43:53,440
An example of a bundle is a framework,
like Foundation framework.

654
00:43:53,440 --> 00:43:53,850
If you open

655
00:43:53,850 --> 00:43:58,320
up System/Library/Frameworks/Foundation.framework,
it's a directory.

656
00:43:58,320 --> 00:44:01,600
You double-click on it in the finder,
you'll see the Foundation executable parts,

657
00:44:01,600 --> 00:44:04,680
the headers the resources and so forth.

658
00:44:04,680 --> 00:44:10,330
A file package, on the other hand,
the primary class is NSFileWrapper.

659
00:44:10,330 --> 00:44:16,980
NSFileWrapper is in Foundation on iOS
4 and the application kit on Mac OS X.

660
00:44:16,980 --> 00:44:19,250
File packages are used for user documents.

661
00:44:19,250 --> 00:44:23,170
An example might be a rich text
document with an image attachment.

662
00:44:23,170 --> 00:44:26,980
In that case, the example extension is rftd.

663
00:44:26,980 --> 00:44:33,340
The point here is to treat that directory that contains
all the appropriate resources and attachments to the text

664
00:44:33,340 --> 00:44:36,280
and so forth, as one document in the finder.

665
00:44:36,280 --> 00:44:39,640
So the user can't lose associated pieces of their documents.

666
00:44:39,640 --> 00:44:46,350
When they double-click on that rich text
document, it will open in the default editor.

667
00:44:46,350 --> 00:44:50,370
There are also things which are
both bundles and file packages.

668
00:44:50,370 --> 00:44:52,990
The most common example of this your application.

669
00:44:52,990 --> 00:44:58,390
As you see in its directory, you're still going to use
NSBundle, and it stores your application code and resources.

670
00:44:58,390 --> 00:45:01,140
But, if the user double-clicks on it in
the finder, it opens up the application.

671
00:45:01,140 --> 00:45:02,920
It doesn't open up like a directory.

672
00:45:02,920 --> 00:45:06,220
Bundle also supports the ability to load other bundles.

673
00:45:06,220 --> 00:45:09,180
This would be a plug in system.

674
00:45:09,180 --> 00:45:12,860
You can locate the various components of a
bundle, list all the resources of a type.

675
00:45:12,860 --> 00:45:16,390
Like I want all the sound files
in this specific subdirectory.

676
00:45:16,390 --> 00:45:23,380
And, of course, bundle is where you're going to
find support for all of your localized strings.

677
00:45:24,410 --> 00:45:28,590
Next up is operations and operation queues.

678
00:45:28,590 --> 00:45:34,060
These classes are an object-oriented way to describe work.

679
00:45:34,060 --> 00:45:38,960
We put them in there to simplify the
design of concurrent applications.

680
00:45:38,960 --> 00:45:40,180
There are two main classes.

681
00:45:40,180 --> 00:45:42,300
The first is NSOperation.

682
00:45:42,300 --> 00:45:45,760
This is a class which encapsulates your work unit.

683
00:45:45,760 --> 00:45:52,310
And you use it by subclassing and overriding
the main method to define what your work is.

684
00:45:52,310 --> 00:45:55,360
Or use one of our Foundation-provided subclasses.

685
00:45:55,360 --> 00:46:00,880
There's NSInvocationOperation, which
lets you specify a target and selector.

686
00:46:00,880 --> 00:46:08,650
And there's NSBlockOperation, which is new in Snow Leopard
and iOS 4, that lets you specify your work as a block.

687
00:46:08,650 --> 00:46:11,800
The other main class is NSOperationQueue.

688
00:46:11,800 --> 00:46:15,510
This class maintains the list of
operations that need to be performed.

689
00:46:15,510 --> 00:46:19,890
And you can think of it as the engine which
runs your operations concurrently or serially.

690
00:46:19,890 --> 00:46:27,040
As an example, I have an operation queue here
with a maximum concurrent operation count of 2.

691
00:46:27,040 --> 00:46:32,840
I've put five operations in this queue, and
you can see the first two are already running.

692
00:46:32,840 --> 00:46:38,560
Now, as those operations finish executing,
the other operations in this queue will begin.

693
00:46:38,560 --> 00:46:42,200
And operations can be added to this queue at any time.

694
00:46:42,200 --> 00:46:45,940
Those operations will run as well,
when there is space available.

695
00:46:45,940 --> 00:46:51,090
Let's see how you subclass NSOperation.

696
00:46:51,090 --> 00:46:52,950
This is the simplest possible.

697
00:46:52,950 --> 00:46:58,500
Class called MyOp and I override main and put my work there.

698
00:46:58,500 --> 00:47:01,720
Now, you may want to put initMethods
or GettersandSetters or other methods

699
00:47:01,720 --> 00:47:03,200
that you can do something more meaningful here.

700
00:47:03,200 --> 00:47:05,390
But this will also work.

701
00:47:05,390 --> 00:47:11,100
Then later, create your operation queue, create your
operation object and add it to the operation queue.

702
00:47:11,100 --> 00:47:13,220
And your operation will start running.

703
00:47:13,220 --> 00:47:20,790
So, you might wonder why to bother using
all of these complicated, is seems, classes.

704
00:47:20,790 --> 00:47:26,720
I can create threads, I can use run loops, but
operation queues let you take advantage of a lot

705
00:47:26,720 --> 00:47:29,690
of power by adding very minimal complexity.

706
00:47:29,690 --> 00:47:36,460
To demonstrate why, I made a sample app that loops
through all images, in this case, which is 20 images,

707
00:47:36,460 --> 00:47:39,010
and performs some image processing on each of them.

708
00:47:39,010 --> 00:47:44,180
Now, when I ran this on my MacBook Pro with two
cores, this one will run in a single-threaded fashion.

709
00:47:44,180 --> 00:47:47,770
And it took 2.22 seconds to run.

710
00:47:47,770 --> 00:47:54,000
To see if using operationQueue will provide me with a
benefit, I added a grand total of four lines of code,

711
00:47:54,000 --> 00:48:01,980
create the operation queue, add the middle part as a block
operation to my operation queue, close the block and,

712
00:48:01,980 --> 00:48:05,890
to simulate the single-threaded case, wait
until all those operations are finished.

713
00:48:05,890 --> 00:48:09,960
And the result was dramatic, 1.25 seconds.

714
00:48:09,960 --> 00:48:11,680
Almost a full second faster.

715
00:48:11,680 --> 00:48:14,010
And all I did was add four lines of code.

716
00:48:14,010 --> 00:48:19,510
So, not all problems are as easy to make
concurrent as this one is, of course.

717
00:48:19,510 --> 00:48:25,790
But, it's worth taking a look at your application, seeing
where you might be able to take advantage of the hardware

718
00:48:25,790 --> 00:48:33,640
that is in these kinds of computers and
add very minimal complexity to your code.

719
00:48:33,640 --> 00:48:35,820
Operation has a few more features.

720
00:48:35,820 --> 00:48:40,840
You can set up dependencies between operations
even if those operations are in different queues.

721
00:48:40,840 --> 00:48:44,840
You can set up priorities of operations within a queue.

722
00:48:44,840 --> 00:48:50,440
It has KVO-compatible properties, so you can find out
when it's running, when it's finished and so forth.

723
00:48:50,440 --> 00:48:54,570
There's new in iOS 4 and Snow Leopard, a completion block,

724
00:48:54,570 --> 00:48:57,260
so you can have a block run when
you're operation is finished.

725
00:48:57,260 --> 00:49:02,550
So, we looked at a lot of classes today.

726
00:49:02,550 --> 00:49:04,620
So I want to do a quick summary.

727
00:49:04,620 --> 00:49:07,750
We talked about collections and how
they are a place to store your stuff.

728
00:49:07,750 --> 00:49:10,400
We talked about iteration, filtering and sorting.

729
00:49:10,400 --> 00:49:16,710
Then we talked about strings and the methods that NSString
has to let you treat those strings as opaque containers.

730
00:49:16,710 --> 00:49:22,140
We talked about dates and times and the classes
you can use to avoid burning your users' cakes.

731
00:49:22,140 --> 00:49:27,360
Then we talked about persistence and archiving,
how you store things on disk and get them back.

732
00:49:27,360 --> 00:49:32,080
We went over the files and URLs that let you
efficiently perform file system operations.

733
00:49:32,080 --> 00:49:36,680
We looked at bundles and how they simplify
cross-platform development and localization.

734
00:49:36,680 --> 00:49:42,210
And we talked about operation queues that let you take
advantage of multi-core computers with minimal complexity.

