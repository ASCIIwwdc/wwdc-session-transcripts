1
00:00:06,280 --> 00:00:06,750
>> Troy Stephens: Well, thank you.

2
00:00:06,750 --> 00:00:07,720
My name is Troy Stephens.

3
00:00:07,720 --> 00:00:12,700
I'm a software engineer on the AppKit team where I work
on the NSView system implementation among other things.

4
00:00:12,700 --> 00:00:19,020
And as you know, right out of the box, AppKit and Mac
OS X's variety of other user interface frameworks things

5
00:00:19,020 --> 00:00:25,820
like ImageKit and WebKit and QTKit and PDFKit provide
you with a pretty wide variety of standard controls

6
00:00:25,820 --> 00:00:29,860
that you can often use as is or maybe
with a little bit of customization

7
00:00:29,860 --> 00:00:32,100
to assemble your application's user interfaces.

8
00:00:32,100 --> 00:00:36,430
A lot of the time, you can build an
entire app just out of standard parts.

9
00:00:36,430 --> 00:00:42,120
But every once in a while, you may find the need to invent
something completely new, an entirely new kind of view

10
00:00:42,120 --> 00:00:47,190
because you want to represent some data in a way that is
unique to your applications or you have a very unique kind

11
00:00:47,190 --> 00:00:51,430
of data that none of the standard
views really can possibly provide for.

12
00:00:51,430 --> 00:00:56,850
So, when you get into this situation-- and this is the
topic of our talk today really is starting from NSView,

13
00:00:56,850 --> 00:01:00,580
subclassing NSView directly, building an
entirely new kind of view from scratch.

14
00:01:00,580 --> 00:01:05,960
So when you find yourself in this kind of situation, how
do you go about making sure that you do a good job of it,

15
00:01:05,960 --> 00:01:11,510
that you take care of everything that you need to
do in your responsibilities as a view subclasser?

16
00:01:11,510 --> 00:01:15,500
Well, I've often wished for sort of a comprehensive
checklist that I could tick down and say, oh,

17
00:01:15,500 --> 00:01:19,580
did I remember to do this, did I remember to do
this, oh, I forgot that, okay check, did that.

18
00:01:19,580 --> 00:01:22,830
This talk aims to provide that checklist for you.

19
00:01:22,830 --> 00:01:25,200
We have a couple of party favors for you today.

20
00:01:25,200 --> 00:01:30,410
first is a custom view implementor's checklist,
and that accompanies a brand new code sample

21
00:01:30,410 --> 00:01:33,650
that we're introducing here that
I'll talk about in just a moment.

22
00:01:33,650 --> 00:01:38,740
But first to get us in a sort of the right frame of mind
to have lofty aspirations for our custom view building,

23
00:01:38,740 --> 00:01:41,830
I want to talk for a moment about the
essential elements of good craftsmanship.

24
00:01:41,830 --> 00:01:46,900
And to my mind, I thought of about six basic
characteristics that define good craftsmanship to me.

25
00:01:46,900 --> 00:01:51,440
The first and maybe most obvious is attention
to detail, to the fit and finish of an object.

26
00:01:51,440 --> 00:01:56,840
You know, it's a real pleasure to use a device
or tool that shows the designer really thought

27
00:01:56,840 --> 00:02:00,990
about every little last aspect of
how it's assembled and designed.

28
00:02:00,990 --> 00:02:05,010
And that kind of attention to detail
tends to stem from a philosophy of--

29
00:02:05,010 --> 00:02:11,420
that something worth taking the time to
do is worth bothering to do a good job of.

30
00:02:11,420 --> 00:02:14,930
Robustness is another aspect of good
craftsmanship that we tend to value.

31
00:02:14,930 --> 00:02:19,500
You know, if you're building a tool, you wanted
to stand up to the rigors of real world use.

32
00:02:19,500 --> 00:02:23,850
Otherwise, it's just sort of a pretty object
and not particularly good craftsmanship.

33
00:02:23,850 --> 00:02:28,740
Functional completeness, you want something to do
everything that you expect it to do, of course,

34
00:02:28,740 --> 00:02:32,030
but at the same time you want to balance
that with an appreciation for the fact

35
00:02:32,030 --> 00:02:35,300
that elegance is the marriage of simplicity and power.

36
00:02:35,300 --> 00:02:39,930
You want something especially in software to be only
just as complicated as you need it to be in order

37
00:02:39,930 --> 00:02:43,160
to do what you need it to do and
no more complicated than that.

38
00:02:43,160 --> 00:02:48,030
As we all probably know from experience,
any more complexity brings problems.

39
00:02:48,030 --> 00:02:50,020
And lastly, use appropriate design.

40
00:02:50,020 --> 00:02:54,190
You want something to fit in well in the real
world context where it's going to be used.

41
00:02:54,190 --> 00:02:58,710
It's nice to show that you put some thought
into how this view is actually going to fit

42
00:02:58,710 --> 00:03:01,980
into the context of an application or user's workflow.

43
00:03:01,980 --> 00:03:07,870
So with those sort of lofty aspirations in mind to give
us goals to work toward, how do we apply these kinds

44
00:03:07,870 --> 00:03:10,660
of principles of good craftsmanship to crafting views?

45
00:03:10,660 --> 00:03:12,830
What are the essentials for crafting views?

46
00:03:12,830 --> 00:03:16,270
The basics start with of course the presentation aspects.

47
00:03:16,270 --> 00:03:22,230
So, how you handle layout and drawing, you know,
figuring out what size your content is or how to fit it

48
00:03:22,230 --> 00:03:26,240
within the space that you're given, where is everything
going to go, and then of course how do you render

49
00:03:26,240 --> 00:03:28,910
that content so that the user can see it.

50
00:03:28,910 --> 00:03:32,880
The flip side of that presentation aspect is
the sort of input side and event handling.

51
00:03:32,880 --> 00:03:38,290
Of course, how you handle keyboard, mouse, trackpad, and
other events that will come into your view to provide ways

52
00:03:38,290 --> 00:03:42,740
for users to usefully interact with
your content that you're presenting.

53
00:03:42,740 --> 00:03:48,280
Accessibility is really something that I think
nowadays we should think of as an essential,

54
00:03:48,280 --> 00:03:54,260
as a part of the foundation, the basics of good
view craftsmanship by making your views accessible

55
00:03:54,260 --> 00:03:59,180
as it has been pointed out in other sessions or earlier
this week, including the Cocoa Tips and Tricks session.

56
00:03:59,180 --> 00:04:04,510
You really expand your application and
your view to a wider user audience,

57
00:04:04,510 --> 00:04:07,240
and there are other benefits as
well that I'll talk about later.

58
00:04:07,240 --> 00:04:10,720
Lastly, sort of an umbrella item,
supporting standard system features.

59
00:04:10,720 --> 00:04:13,680
You know, we have all these user interface
paradigms that nowadays we take for granted.

60
00:04:13,680 --> 00:04:19,720
Things like the ability to select content, cut, copy,
and paste, drag and drop, those sorts of UI paradigms

61
00:04:19,720 --> 00:04:22,890
that if you support them in your
views at sort of a very basic level,

62
00:04:22,890 --> 00:04:25,480
then of course that makes them more discoverable.

63
00:04:25,480 --> 00:04:27,150
Your design is more discoverable to users.

64
00:04:27,150 --> 00:04:30,100
They can intuit how to use your custom views.

65
00:04:30,100 --> 00:04:33,160
So once we've got the basics in
place, we can look at refinements,

66
00:04:33,160 --> 00:04:36,980
and those of course include tweaking the appearance
of your view, pushing every last pixel to get things

67
00:04:36,980 --> 00:04:40,130
to look exactly the way you want them to.

68
00:04:40,130 --> 00:04:43,000
Planning for animation, in a way this is a refinement.

69
00:04:43,000 --> 00:04:47,850
It's sort of the icing on a cake or the
fit and finish from the user's perspective.

70
00:04:47,850 --> 00:04:49,130
And that animates too.

71
00:04:49,130 --> 00:04:50,820
Gee, isn't that nice?

72
00:04:50,820 --> 00:04:52,030
You know, something that's kind of pleasing.

73
00:04:52,030 --> 00:04:55,430
But if you want to do this and do it well and
have the versatility you need to do it well,

74
00:04:55,430 --> 00:04:58,160
it helps to plan from it-- for it from the beginning.

75
00:04:58,160 --> 00:05:00,840
And so in a way, this sort of belongs
in the basics category.

76
00:05:00,840 --> 00:05:03,110
I'll talk about that in detail later.

77
00:05:03,110 --> 00:05:08,850
Lastly, sort of responsiveness and scalability, you
want your view to respond as immediately as possible

78
00:05:08,850 --> 00:05:11,320
when the user clicks in it or issues a keystroke.

79
00:05:11,320 --> 00:05:16,370
Any kind of lag in responsiveness tends
to make users get frustrated easily.

80
00:05:16,370 --> 00:05:20,310
And of course scalability, you want to think about
what's the maximum complexity of your view's content

81
00:05:20,310 --> 00:05:22,440
or number of objects you want to be able to handle.

82
00:05:22,440 --> 00:05:27,320
So, I mentioned we have a new code sample today,
and that is something that we call TreeView.

83
00:05:27,320 --> 00:05:31,560
And TreeView simply put is a view
for presenting and allowing the user

84
00:05:31,560 --> 00:05:33,950
to interact with tree graft node structure.

85
00:05:33,950 --> 00:05:38,190
So any -- we're familiar with these -- anything that
has, where you have a root node and then conceptually

86
00:05:38,190 --> 00:05:43,130
that root node may have children and those children may
in turn have children of their own and so on recursively.

87
00:05:43,130 --> 00:05:49,510
And to give us a concrete idea of what TreeView is
and does, we'll just start with a quick look at demo.

88
00:05:49,510 --> 00:05:56,540
[ Pause ]

89
00:05:56,540 --> 00:06:00,880
So, here we have TreeView running in a sample app,
and this code is available for download already.

90
00:06:00,880 --> 00:06:07,730
There is a 1.0 version that went up two days ago I think and
there should be a 1.1 version published very shortly today.

91
00:06:07,730 --> 00:06:13,040
So here we have a TreeView and what we're
looking at for example content is a portion

92
00:06:13,040 --> 00:06:18,210
of the Objective-C class hierarchy as discovered
through the runtime introspection facilities.

93
00:06:18,210 --> 00:06:24,210
So here we're looking at NSControl and all of its
descendant classes in a TreeView and, you know,

94
00:06:24,210 --> 00:06:26,490
we can-- here this TreeView is the document view.

95
00:06:26,490 --> 00:06:30,980
The scroll view so we could scroll around
if it's extremely large as it is right now.

96
00:06:30,980 --> 00:06:32,570
It can get even larger than that.

97
00:06:32,570 --> 00:06:35,700
And the basic API model here is to try to decouple.

98
00:06:35,700 --> 00:06:39,960
When you study the code, you'll notice that this
tries to decouple the model from the presentation.

99
00:06:39,960 --> 00:06:46,890
So the API model is-- we give the TreeView a root
model object that represents the NSControl class

100
00:06:46,890 --> 00:06:52,080
and then that model object is required to conform
to a very simple protocol that TreeView defines,

101
00:06:52,080 --> 00:06:56,940
which allows the TreeView to determine that
model node's parent and all of it's child nodes.

102
00:06:56,940 --> 00:07:01,480
And so, the TreeView can traverse the model
tree, figure out its extent and all of its parts.

103
00:07:01,480 --> 00:07:05,880
And then for each of the nodes it wants to represent
visually, TreeView does something very similar

104
00:07:05,880 --> 00:07:10,800
to what collection view does nowadays, which
is to load a nib file that contains a view,

105
00:07:10,800 --> 00:07:13,330
and really, a view subtree that represents a node.

106
00:07:13,330 --> 00:07:16,960
So here we have the NSControl class represented by a node

107
00:07:16,960 --> 00:07:20,370
that actually has a container view
that draws the rounded rectangle shape.

108
00:07:20,370 --> 00:07:23,270
There's an NSImageView in there, a couple of NSTextFields.

109
00:07:23,270 --> 00:07:29,330
We've got a button in there and these buttons enable
us to expand or collapse portions of the subtree.

110
00:07:29,330 --> 00:07:36,700
And as you may notice, that's all-- animation is built
into that so that was designed in from the beginning.

111
00:07:36,700 --> 00:07:41,550
We can click around and we can select nodes, so
TreeView supports the notion of selected nodes.

112
00:07:41,550 --> 00:07:42,460
So we can select nodes.

113
00:07:42,460 --> 00:07:45,620
We can-- I'm using the arrow keys now to navigate around.

114
00:07:45,620 --> 00:07:46,990
That's another thing you want to think about.

115
00:07:46,990 --> 00:07:51,480
Oftentimes, your users will want to be able to
just leave the mouse aside or the trackpad aside

116
00:07:51,480 --> 00:07:56,460
and can navigate very efficiently using keyboard
commands if you give them the ability to do that.

117
00:07:56,460 --> 00:08:02,630
I can hit Spacebar to toggle, expansion
or collapse of nodes and so on.

118
00:08:02,630 --> 00:08:08,250
And there's even a little bit of gesture support
in here if you have a multitouch trackpad.

119
00:08:08,250 --> 00:08:12,220
You can use a pinch gesture to vary the layout spacing.

120
00:08:12,220 --> 00:08:15,150
Here I have some controls where we
can do that explicitly with the mouse

121
00:08:15,150 --> 00:08:17,130
so we can vary the parent-child spacing horizontally.

122
00:08:17,130 --> 00:08:22,540
We can spread the tree out vertically if we want to, sort
of some basic appearance properties we can tune there

123
00:08:22,540 --> 00:08:25,550
and we can set a different background
color for the TreeView.

124
00:08:25,550 --> 00:08:27,870
Set a different connecting lines color.

125
00:08:27,870 --> 00:08:32,700
So there are appearance properties that are customizable,
and we can choose a different connecting line stye

126
00:08:32,700 --> 00:08:37,130
and vary the thickness of the connecting lines
if we want to, so the sort of things like that.

127
00:08:37,130 --> 00:08:41,660
And another thing to notice is that
TreeView operates layer back too.

128
00:08:41,660 --> 00:08:45,140
And when I click the switch, basically nothing happens.

129
00:08:45,140 --> 00:08:51,170
But there is a lot of interesting stuff going on behind
the scenes to optimize this TreeView for layer back mode.

130
00:08:51,170 --> 00:08:58,030
For one thing, the TreeView example is the first one, I
think, we've published that demonstrates how to do things

131
00:08:58,030 --> 00:09:01,180
like background fill and drawing stroked outlines.

132
00:09:01,180 --> 00:09:06,670
Using CALayers properties let the GPU do the stuff
problematically rather than allocating backing stores

133
00:09:06,670 --> 00:09:08,950
for all of the layers that constitute these various views.

134
00:09:08,950 --> 00:09:10,850
So that's kind of interesting.

135
00:09:10,850 --> 00:09:15,940
We can click this sort of debug feature here to show
the subtree frames, and this shows the structure

136
00:09:15,940 --> 00:09:19,640
of the TreeViews content which
I'll talk about in detail later.

137
00:09:19,640 --> 00:09:28,400
But basically each subtree, meaning a node and all of
its descendants has a green outline drawn around it.

138
00:09:28,400 --> 00:09:30,410
And those are the essentials of TreeView.

139
00:09:30,410 --> 00:09:37,640
So let's look at some aspects of how this is done.

140
00:09:37,640 --> 00:09:41,040
So, I want to have time to examine the code
in detail over the course of this talk,

141
00:09:41,040 --> 00:09:45,140
but we will refer to various aspects of TreeView's
design decisions over the course of the talk.

142
00:09:45,140 --> 00:09:49,980
And again, I encourage you to download the sample
code and study it in detail at your leisure.

143
00:09:49,980 --> 00:09:53,750
We'll look at four major topic areas
for crafting custom Cocoa views today.

144
00:09:53,750 --> 00:09:58,360
First, designing for animation, from the
beginning I mentioned the importance of doing that.

145
00:09:58,360 --> 00:10:02,160
Next, we'll talk about drawing and layout
which is related to drawing of course.

146
00:10:02,160 --> 00:10:07,040
Handling of state changes, things that may happen to your
view that you may want to respond to, how you can do that.

147
00:10:07,040 --> 00:10:11,350
And lastly we'll look at handling interaction or user input.

148
00:10:11,350 --> 00:10:14,460
So first let's look at Designing for Animation.

149
00:10:14,460 --> 00:10:19,190
What are the sorts of things that you want to think
about from the get go when you're designing a view

150
00:10:19,190 --> 00:10:21,780
and you might want to animate your content.

151
00:10:21,780 --> 00:10:26,660
Probably the most important top level items to think
about factoring your content in ways that enable you

152
00:10:26,660 --> 00:10:31,820
to minimize redraw and relayout activity and
computations when things are being animated.

153
00:10:31,820 --> 00:10:34,450
And this is especially important for layer-backed mode.

154
00:10:34,450 --> 00:10:39,110
And I think nowadays if you're designing custom
view, especially if you're designing it for sort

155
00:10:39,110 --> 00:10:41,880
of a generalized use by others you really want to make sure

156
00:10:41,880 --> 00:10:45,200
that it can operate well both in
layer-backed and window-backed mode.

157
00:10:45,200 --> 00:10:47,340
For one thing you may not have a choice about that.

158
00:10:47,340 --> 00:10:49,950
A view can always opt in to being layer-backed.

159
00:10:49,950 --> 00:10:54,860
If your view does set 1's layer yes on itself
it makes itself and all of its subtree--

160
00:10:54,860 --> 00:10:57,120
all of its descendant views layer-backed.

161
00:10:57,120 --> 00:11:02,110
So, you have control over that but you may get opted in by
someone else if your view is used in somebody else's window

162
00:11:02,110 --> 00:11:05,580
and they have 1's layer to yes
higher up in the tree, you know.

163
00:11:05,580 --> 00:11:08,560
Then everything from there on down is going
to be layer-backed and you're going to have

164
00:11:08,560 --> 00:11:10,650
to make sure that you can operate that way.

165
00:11:10,650 --> 00:11:13,610
Now oftentimes for most things if
you're designing simple controls

166
00:11:13,610 --> 00:11:15,680
and so on usually you don't have to worry about this.

167
00:11:15,680 --> 00:11:19,160
Things just sort of-- the layer-backed
stuff does its magic and things just work.

168
00:11:19,160 --> 00:11:22,250
But sometimes you're doing kind of fancy
stuff to take advantage of layer-backed mode.

169
00:11:22,250 --> 00:11:25,570
Maybe you're adding your own custom sublayers

170
00:11:25,570 --> 00:11:29,390
to the AppKit provided view-backing layer
or you're changing properties of layers.

171
00:11:29,390 --> 00:11:33,330
If you're doing things, fancy stuff like that
you'll want to make sure that you are robust

172
00:11:33,330 --> 00:11:35,270
to backing their tree construction and tear down.

173
00:11:35,270 --> 00:11:40,630
AppKit automatically constructs the layer tree for you
when you need it and will tear down those backing layers

174
00:11:40,630 --> 00:11:44,910
for example, when your view is removed for a window
or when we otherwise decide that we don't need them

175
00:11:44,910 --> 00:11:48,990
because the whole idea of the model
is that we can recreate them at will.

176
00:11:48,990 --> 00:11:54,220
So if you're doing stuff like that be robust to
backing layer tree construction and tear down.

177
00:11:54,220 --> 00:12:01,140
Another thing to point out is the
layerContentsRedrawPolicy, sort of a-- maybe a confusingly--

178
00:12:01,140 --> 00:12:05,260
I don't know, I wouldn't say it's confusing but it's
a method that's not necessarily self-explanatory.

179
00:12:05,260 --> 00:12:09,590
This is a new property on NSView that
we added in Snow Leopard and enables you

180
00:12:09,590 --> 00:12:11,980
to do something very powerful in layer-backed mode.

181
00:12:11,980 --> 00:12:20,240
Normally, when you tell us view animator set frame size
to animate the frame resize of a view we have to assume

182
00:12:20,240 --> 00:12:25,790
that at each incremental step along the way during that
animation we have to ask the view to redraw its content

183
00:12:25,790 --> 00:12:27,280
in its entirety because we don't know better.

184
00:12:27,280 --> 00:12:32,600
We don't know what's in your view and
we want to make sure most importantly

185
00:12:32,600 --> 00:12:35,170
that the drawing looks correct at each step along the way.

186
00:12:35,170 --> 00:12:38,410
But for animations often that's
overkill, and it's too much CPU load.

187
00:12:38,410 --> 00:12:40,130
You don't need to redraw at every point along the way.

188
00:12:40,130 --> 00:12:45,390
If you are doing a quick quarter second animation on the
view resize maybe it's sufficient to take the snap shot

189
00:12:45,390 --> 00:12:49,810
of the view's content that you already have in it's
backing layer or maybe redraw it at it's new size,

190
00:12:49,810 --> 00:12:52,930
usually you'll want to do that if
you're resizing to a larger size.

191
00:12:52,930 --> 00:12:56,630
You'll have it redrawn once at the start of
the animation and then you give us permission

192
00:12:56,630 --> 00:13:01,050
by setting the layerContentsRedrawPolicy
to just use that snap shot as an image

193
00:13:01,050 --> 00:13:03,190
and stretch it over the course of the animation.

194
00:13:03,190 --> 00:13:07,340
And you'll see places in TreeView's
example code where we do this.

195
00:13:07,340 --> 00:13:10,130
So, this is I think the first code
sample that demonstrates using that.

196
00:13:10,130 --> 00:13:16,760
Definitely something to look into, this can buy you a lot
of smoothness in animation when you're running layer-backed.

197
00:13:16,760 --> 00:13:21,240
One more sort of general item, share and
reuse repeated content efficiently if you can.

198
00:13:21,240 --> 00:13:26,950
If you have images and other resources
that are drawn over and over in your UI,

199
00:13:26,950 --> 00:13:30,070
think about referencing the same image
rather than copying it of course.

200
00:13:30,070 --> 00:13:33,630
And especially when you're dealing with your
own custom layers, you know if you're going

201
00:13:33,630 --> 00:13:39,130
to set several layers contents property to point to the same
CG image that's something really useful as an optimization.

202
00:13:39,130 --> 00:13:40,970
It saves a lot of space.

203
00:13:40,970 --> 00:13:42,840
And then again plan for scalability.

204
00:13:42,840 --> 00:13:47,130
Think about the maximum complexity of content
that you are realistically going to need to handle

205
00:13:47,130 --> 00:13:50,440
and make sure that your architecture supports that.

206
00:13:50,440 --> 00:13:54,220
So, thinking about scalability gives
a sort of a fundamental choice.

207
00:13:54,220 --> 00:13:59,220
One of the first decisions you get to make is if your
designing something that has complex content like TreeView,

208
00:13:59,220 --> 00:14:04,350
am I going to use views or non-view
objects to represent my content?

209
00:14:04,350 --> 00:14:10,330
And what I mean by non view objects is just really
anything that's not in NSView, you can subclass NSObject

210
00:14:10,330 --> 00:14:15,720
and define your own sorts of objects that have the
basic properties you need such as knowing it's rectangle

211
00:14:15,720 --> 00:14:19,480
within the view and knowing what it needs to draw and so on.

212
00:14:19,480 --> 00:14:21,910
It's a sort of fundamental decision you get to make upfront.

213
00:14:21,910 --> 00:14:27,470
And there are different performance implications for this,
for layer-backed operation versus window-backed operations.

214
00:14:27,470 --> 00:14:32,560
So you may want to consider whether you're
going to primarily be operating window-backed

215
00:14:32,560 --> 00:14:35,450
or layer-backed or whether you want to support both.

216
00:14:36,920 --> 00:14:43,190
Now veteran Cocoa developers will often tell you that
non-view objects can sometimes or often be more lightweight

217
00:14:43,190 --> 00:14:48,840
than NSViews in terms of both memory usage, NSView
really is a very general purpose class rather

218
00:14:48,840 --> 00:14:50,520
than having a very deep class hierarchy.

219
00:14:50,520 --> 00:14:56,020
We have NSView at the root for all of our views
and it encapsulates a lot of functionality

220
00:14:56,020 --> 00:15:02,760
and a lot of possibilities including arbitrary coordinate
transforms, ability to participate in responder chains,

221
00:15:02,760 --> 00:15:07,850
queue loops, and a lot of stuff that, you know if
you were to design your own very specialized object

222
00:15:07,850 --> 00:15:12,730
for representing say nodes in your TreeView or so
on, you might be able to design something that's--

223
00:15:12,730 --> 00:15:15,050
because you know all the assumptions that go into it.

224
00:15:15,050 --> 00:15:20,040
You can design something that's very small and
lightweight to represent your individual parts.

225
00:15:20,040 --> 00:15:26,130
CPU usage also, although to a lesser extent, you know
again, because NSView is a very general purpose class

226
00:15:26,130 --> 00:15:31,880
when we traverse the view tree to do various operations yes,
we do have to make a lot of decisions and branches based on,

227
00:15:31,880 --> 00:15:36,990
is this particular view instance using this feature
so I take this code path if not take this other one.

228
00:15:36,990 --> 00:15:41,600
So more in the sense of memory usage, that's
usually the more significant thing to people.

229
00:15:41,600 --> 00:15:46,110
And so people will sometimes go and build all their
content out of non-view objects and that's fine.

230
00:15:46,110 --> 00:15:49,780
It's a little more work but it's OK if
that's what you find you need to do.

231
00:15:49,780 --> 00:15:54,280
However, I would caution you that factoring
things as views has a lot of benefits especially

232
00:15:54,280 --> 00:15:56,240
for layer-backed mode that people tend to overlook.

233
00:15:56,240 --> 00:16:00,890
And now that we have this new concept of
layer-backed mode in the system as of 10.5 it sort

234
00:16:00,890 --> 00:16:03,250
of changes the game a bit in some important ways.

235
00:16:03,250 --> 00:16:09,070
And one of the most important benefits that you get when
you're layer-backed by factoring your content as views is

236
00:16:09,070 --> 00:16:11,310
that you get caching your content in separate parts.

237
00:16:11,310 --> 00:16:17,110
Each view gets its own backing layer, each layer
gets its own backing store, and so each view--

238
00:16:17,110 --> 00:16:19,910
for each view we have a snap shot
of what the view last drew.

239
00:16:19,910 --> 00:16:23,430
And this makes it very efficient to do animations.

240
00:16:23,430 --> 00:16:24,640
We can just slide things around.

241
00:16:24,640 --> 00:16:28,320
It's very cheap to recomposite bitmaps
or top each rather than having to go back

242
00:16:28,320 --> 00:16:32,800
to the Core's drawing commands
and redraw things from scratch.

243
00:16:32,800 --> 00:16:36,930
And also you get animation versatility
and convenience really from this,

244
00:16:36,930 --> 00:16:44,000
because you can use the view animator syntax to do
moving of views frame origins, frame sizes, and so on.

245
00:16:44,000 --> 00:16:49,420
If you're not using view objects you kind of end up
having to implement more of the animation stuff yourself

246
00:16:49,420 --> 00:16:55,780
so it's very convenient to be able to just say
view animators set frame origin fu and off you go.

247
00:16:55,780 --> 00:17:00,280
Views also provide important culling, event handling,
and accessibility benefits by culling I mean sort

248
00:17:00,280 --> 00:17:04,210
of a gross high level clipping that you
tend to do when you're figuring out, OK,

249
00:17:04,210 --> 00:17:07,110
what parts of my content do I need to draw?

250
00:17:07,110 --> 00:17:10,210
When you factor your content as views
AppKit takes care of all of that.

251
00:17:10,210 --> 00:17:11,190
It's built in.

252
00:17:11,190 --> 00:17:12,990
If you're using non-view objects you have to build

253
00:17:12,990 --> 00:17:17,610
that in yourself have your drawRect do intersection
testing against all your subobjects and so on.

254
00:17:17,610 --> 00:17:22,290
Likewise for event handling, you know there are a lot of
event handling benefits, things you just get for free,

255
00:17:22,290 --> 00:17:25,840
behaviors you get for free with NSViews and accessibility.

256
00:17:25,840 --> 00:17:30,480
Again it's much easier if you factor your content
as views and we'll talk about that again later.

257
00:17:30,480 --> 00:17:34,580
So, by now I guess it's probably obvious which
direction I leaned in designing TreeView.

258
00:17:34,580 --> 00:17:37,570
TreeView is composed as a set of Nested View Subtrees.

259
00:17:37,570 --> 00:17:42,400
So what I mean by that is at the root we
have the TreeView itself a single instance

260
00:17:42,400 --> 00:17:48,230
and that TreeView has a SubtreeView that-- is its
root SubtreeView that's sort of an invisible container

261
00:17:48,230 --> 00:17:52,590
that contains that entire subtree, in
this case the subtree is the whole tree.

262
00:17:52,590 --> 00:17:57,910
That SubtreeView has as a subview, the NodeView,
that represents the root node of the tree

263
00:17:57,910 --> 00:18:02,120
and then we have descendant SubtreeViews
that have their own NodeViews

264
00:18:02,120 --> 00:18:05,870
and those NodeViews have their own children and so on.

265
00:18:05,870 --> 00:18:08,880
Now we also want to draw up connecting lines
between the nodes and it turns out that

266
00:18:08,880 --> 00:18:13,710
for layer-backed mode it's very convenient to
encapsulate those in views and we group them

267
00:18:13,710 --> 00:18:19,390
so that the connecting lines from a given parent node
to all of it's children are drawn by a single view

268
00:18:19,390 --> 00:18:21,910
and that makes it very easy to just move those

269
00:18:21,910 --> 00:18:25,290
around when we're doing animations in
layer-backed mode very efficiently.

270
00:18:25,290 --> 00:18:28,640
So a few benefits that we get from this
design, it groups subtrees logically,

271
00:18:28,640 --> 00:18:33,640
obviously sort of the view structure tends to
mirror the recursive nature of the tree structure

272
00:18:33,640 --> 00:18:37,490
where you have this idea of subtrees
that contain subtrees and so on.

273
00:18:37,490 --> 00:18:40,680
And it also makes it very easy to
sort of move subtrees around if I want

274
00:18:40,680 --> 00:18:43,410
to move a subtree to make room for something else.

275
00:18:43,410 --> 00:18:47,070
I can just move the subtree view's frame
origin and the whole subtree moves.

276
00:18:47,070 --> 00:18:51,120
Whereas if we had chosen more of a flat
design here where maybe we could have made all

277
00:18:51,120 --> 00:18:56,730
of the NodeViews direct subviews of the
TreeView and all sibling views of each other.

278
00:18:56,730 --> 00:19:00,490
Well then if you want to move a subtree you've got
a whole lot of individual parts to move around.

279
00:19:00,490 --> 00:19:05,020
So this grouping kind of helps us, helps make it
easier to do certain things that we want to do.

280
00:19:05,020 --> 00:19:10,030
It simplifies relayout, it simplifies relayout
animation and it gives us the benefits

281
00:19:10,030 --> 00:19:14,550
of content caching when the view is layer-backed.

282
00:19:14,550 --> 00:19:16,280
What are some of the other things you can do?

283
00:19:16,280 --> 00:19:22,510
Some kind of more basic stuff, if your view has custom
properties that you might find interesting to animate

284
00:19:22,510 --> 00:19:26,740
such as colors, or metrics, that you want to
be able to interpolate from the previous value

285
00:19:26,740 --> 00:19:30,340
to a new value rather than just jumping to the new value.

286
00:19:30,340 --> 00:19:33,990
You can make those custom view's properties
first class animatable properties.

287
00:19:33,990 --> 00:19:40,750
If you want, you can override defaultAnimationForKey on your
view subclass and you can do something sort of like this.

288
00:19:40,750 --> 00:19:45,250
Let's say we have a view with a border
color and a border width property.

289
00:19:45,250 --> 00:19:51,120
You look for your property name as the incoming key
string so we say OK if the key is equal to border color

290
00:19:51,120 --> 00:19:56,210
or if it's equal to border width and either of those
cases we want to return a BasicAnimation app , OK,

291
00:19:56,210 --> 00:20:01,600
that BasicAnimation is just saying interpolate from
A to B with some default curve and for any case

292
00:20:01,600 --> 00:20:05,920
that you don't specifically handle always call up to super.

293
00:20:05,920 --> 00:20:10,800
And as I said what this enables you to do is use
the animator syntax with your custom property.

294
00:20:10,800 --> 00:20:15,060
So, it becomes really sort of a first class
animatable property in the system and you can do things

295
00:20:15,060 --> 00:20:21,820
like view animator or setBorderColor to blue color and
we will smoothly interpolate the color from A to B.

296
00:20:21,820 --> 00:20:27,150
Now an important thing that you need to do if you want
to make this work is make sure that your setter methods

297
00:20:27,150 --> 00:20:32,990
or the properties you want to animate perform the necessary
invalidation by which I mean setNeedsDisplay activity.

298
00:20:32,990 --> 00:20:37,510
Because what's going to happen, we'll get this
view animator setBorderColor and we will--

299
00:20:37,510 --> 00:20:44,860
AppKit will incrementally call invoke setBorderColor on
your object with various interpolated values until it gets

300
00:20:44,860 --> 00:20:48,200
to the final value for your border color.

301
00:20:48,200 --> 00:20:53,350
So you're going to get a series of setBorderColor messages
and each time you get one of those you need to make sure

302
00:20:53,350 --> 00:20:55,780
that the affected part of yourself gets redrawn.

303
00:20:55,780 --> 00:21:01,630
So, you want to do setNeedsDisplay in
your appearance related setter methods

304
00:21:01,630 --> 00:21:03,550
and that's all you need to make that work.

305
00:21:03,550 --> 00:21:06,420
So those are sort of the basics for preparing for animation.

306
00:21:06,420 --> 00:21:08,370
Now let's look at drawing and layout.

307
00:21:08,370 --> 00:21:12,710
And one of the most basic decisions that you get

308
00:21:12,710 --> 00:21:16,520
to make upfront is whether your view
is going to be flipped or unflipped.

309
00:21:16,520 --> 00:21:23,270
Where this is a fundamental choice that you have
with NSViews and it affects a lot of stuff in terms

310
00:21:23,270 --> 00:21:27,770
of the way you're going to write your code down
the line for doing your layout computations.

311
00:21:27,770 --> 00:21:31,060
So it's worth giving some thought to it upfront.

312
00:21:31,060 --> 00:21:34,830
isFlipped is the NSView method that determines
whether a view is flipped by default.

313
00:21:34,830 --> 00:21:37,800
If return's NO you may want to override it to return YES.

314
00:21:37,800 --> 00:21:42,710
And the most important thing this does is it determine
the origin of y-axis direction of your views bounds

315
00:21:42,710 --> 00:21:47,210
or it's interior coordinate system, the one
in which it actually draws and handles events.

316
00:21:47,210 --> 00:21:52,110
So if you have an unflipped view it's
origin or it's (0,0) point is going to be

317
00:21:52,110 --> 00:21:54,770
at it's lower left corner positive y-axis pointed upward.

318
00:21:54,770 --> 00:22:01,200
If you have a flipped view origin is at the top
left corner positive y-axis points downward.

319
00:22:01,200 --> 00:22:05,770
Another effect of deciding whether you're
flipped or not is it determines the meaning

320
00:22:05,770 --> 00:22:09,310
or the way the AppKit interprets
your subviews frame origin values.

321
00:22:09,310 --> 00:22:16,860
If you put a subview in an unflip view the subviews frame
origin determines where the subviews lower left corner goes.

322
00:22:16,860 --> 00:22:20,790
If you put a subview on a flip view it determines
where the subviews upper left corner goes.

323
00:22:20,790 --> 00:22:26,150
So, if you think about it this sort of makes sense if you
position a subview at (0,0) you want it to be in the corner

324
00:22:26,150 --> 00:22:30,940
of its parent view but that's something
that people sometimes find surprising.

325
00:22:30,940 --> 00:22:35,670
So it really affects-- you know, you can see how this
will affect if you're doing layout computations to figure

326
00:22:35,670 --> 00:22:38,500
out where your subviews go it matters
whether you're flipped or not.

327
00:22:38,500 --> 00:22:43,390
And if you just change your flipness setting to
the opposite setting you may need to change the way

328
00:22:43,390 --> 00:22:46,800
that your code is written that does your layout.

329
00:22:46,800 --> 00:22:51,170
If you've worked with the CALayer API directly
you may have noticed the geometryFlipped property

330
00:22:51,170 --> 00:22:54,410
which sounds really related but
it's actually distinct in meaning.

331
00:22:54,410 --> 00:22:55,810
It has sort of a recursive meaning.

332
00:22:55,810 --> 00:22:57,670
That's how you flip an entire layer subtree,

333
00:22:57,670 --> 00:23:01,230
so it's not really a direct mapping
to the concept of flipness for views.

334
00:23:01,230 --> 00:23:06,090
One of you declares it's flipped or not flipped that just
affects that immediate view and not any of its descendants.

335
00:23:06,090 --> 00:23:08,340
They each have their own flipness setting.

336
00:23:08,340 --> 00:23:10,970
So how do you decide whether to be flipped or not?

337
00:23:10,970 --> 00:23:15,600
Well in general you just want to think about the natural
growth direction for your content layer, adding new content,

338
00:23:15,600 --> 00:23:18,820
you know, is it like a text view
where you tend to add new stuff

339
00:23:18,820 --> 00:23:21,610
down at the bottom or you tend to add new stuff on top.

340
00:23:21,610 --> 00:23:23,920
And then choose according to that.

341
00:23:23,920 --> 00:23:27,250
It's mostly a matter of convenience and as I alluded to you,

342
00:23:27,250 --> 00:23:30,330
you just want to choose whichever
convention enables you to write simpler code.

343
00:23:30,330 --> 00:23:35,210
If you find yourself writing a lot view,
handling view resize code where you're having

344
00:23:35,210 --> 00:23:38,870
to move things numerically just to get them to
stay in the same place you might want to think

345
00:23:38,870 --> 00:23:42,450
about whether you should use the other flipness convention.

346
00:23:42,450 --> 00:23:46,730
Another minor side effect of this is that if your view is
going to be used as the document view of the scroll view

347
00:23:46,730 --> 00:23:52,860
as in the TreeView demo case this affects what we call
the pinning of the document view when resize happens.

348
00:23:52,860 --> 00:23:58,570
So, when the user resizes the window and resizes
the scroll view content area which portion

349
00:23:58,570 --> 00:24:01,000
of the document view is going to
appear stationary to the user

350
00:24:01,000 --> 00:24:05,330
and which part is going to expand to reveal new content?

351
00:24:05,330 --> 00:24:09,770
Some quick points about drawing, you've
seen a lot of this stuff hopefully before.

352
00:24:09,770 --> 00:24:12,990
Your most basic responsibility as a
custom view is to override drawRect.

353
00:24:12,990 --> 00:24:16,650
You draw whatever content you want and
NSView draws nothing by default so you need

354
00:24:16,650 --> 00:24:20,040
to tell us everything that you want us to draw.

355
00:24:20,040 --> 00:24:26,590
When you're doing this it's good to be sure for
performance reasons that you draw only what you need to.

356
00:24:26,590 --> 00:24:31,380
AppKit passes in an NSRect to the the
drawRect method that gives you bounding boxes

357
00:24:31,380 --> 00:24:33,050
as this is all we're really asking you to draw.

358
00:24:33,050 --> 00:24:37,970
Everything inside here you don't have to draw anything
outside here and in fact AppKit will clip it out.

359
00:24:37,970 --> 00:24:41,350
If you're content is really complicated
and expensive and this happens only

360
00:24:41,350 --> 00:24:44,480
in pretty rare cases, but this is useful to know.

361
00:24:44,480 --> 00:24:48,490
If you have really complex content, a lot
of objects to potentially draw you may want

362
00:24:48,490 --> 00:24:52,550
to use the needsToDrawRect method or
the getRectsBeingDrawn:count method,

363
00:24:52,550 --> 00:24:57,020
because potentially AppKit is really asking
your view to draw a series of rectangles.

364
00:24:57,020 --> 00:25:02,410
We keep track of complex up to date regions to try
to minimize the amount of redraw work that gets done.

365
00:25:02,410 --> 00:25:07,840
The drawRect NSRect parameter is really a
bounding box for that more complex set of rects.

366
00:25:07,840 --> 00:25:10,090
And it's a little bit of an over
simplification for something.

367
00:25:10,090 --> 00:25:14,990
So if you want to be really precise about not
asking things to draw that don't need drawing,

368
00:25:14,990 --> 00:25:17,600
look at the set of rects being asked to draw.

369
00:25:17,600 --> 00:25:20,130
The flip side of that is invalidate only what you need to.

370
00:25:20,130 --> 00:25:23,200
You know, when some state changes in
your viewer you get some new content.

371
00:25:23,200 --> 00:25:28,290
You know, you can always throw up your hands and say
set needs display YES which basically means, "Oh,

372
00:25:28,290 --> 00:25:32,040
I don't know I need to redraw all of myself for all I know."

373
00:25:32,040 --> 00:25:36,400
Sometimes you know that's good enough, that's the
best you can do, but whenever you can determine

374
00:25:36,400 --> 00:25:39,750
that just some part of your views content needs redraw.

375
00:25:39,750 --> 00:25:44,710
Send setNeedsDisplayInRect in preference to setNeedsDisplay,
you know, even if you have to send several of those messages

376
00:25:44,710 --> 00:25:49,170
because there are a few different rectangles you need to
redraw, try to tightly bound the area that you are asking

377
00:25:49,170 --> 00:25:55,440
to have redrawn especially if that drawing
is going to be expensive for you to do.

378
00:25:55,440 --> 00:25:59,940
And lastly, and this is sort of a subtle point that many
people miss when trying to get views to work correctly

379
00:25:59,940 --> 00:26:04,570
in layer-backed mode is be very careful about
which views you're messaging to be invalidated.

380
00:26:04,570 --> 00:26:09,200
This was something that you could, you could be sort of
sloppy about and get away with it in window-backed mode

381
00:26:09,200 --> 00:26:13,410
where everything is sort of sandwiched together and all
that really matters at the end of the day is which part

382
00:26:13,410 --> 00:26:18,270
of the window was asked to be redrawn, whatever part of
the window was marked as needing display we're going to go

383
00:26:18,270 --> 00:26:21,710
through and ask every view that makes a
contribution to that part of the window

384
00:26:21,710 --> 00:26:24,030
from back to front to redraw a part of itself.

385
00:26:24,030 --> 00:26:28,710
But in layer-backed mode again, every view
gets its own content snapshotted separately.

386
00:26:28,710 --> 00:26:34,300
So, you got to make sure that the view you invalidate is the
view that is actually drawing the content that needs redraw.

387
00:26:34,300 --> 00:26:39,540
Sounds simple but it's something that's easily overlooked
and it's something you may need to debug if you are working

388
00:26:39,540 --> 00:26:41,580
in window-backed mode and suddenly
you are going in layer-backed mode

389
00:26:41,580 --> 00:26:45,120
and hey things aren't redrawing when my state changes.

390
00:26:45,120 --> 00:26:49,960
For layout, I just want to point out a
convenience that people rarely take advantage of.

391
00:26:49,960 --> 00:26:52,090
We have a viewWillDraw method now.

392
00:26:52,090 --> 00:26:56,220
This message will get sent recursively
down your view tree before we recurs

393
00:26:56,220 --> 00:26:59,150
to sent drawRect to all of the views that need drawing.

394
00:26:59,150 --> 00:27:02,020
So every view that's going to get a drawRect message

395
00:27:02,020 --> 00:27:06,430
in a given recursive drawing pass
will first get a viewWillDraw message.

396
00:27:06,430 --> 00:27:09,320
And you could override this to do all kinds of stuff.

397
00:27:09,320 --> 00:27:13,570
It's permitted to actually resize your
viewer, resize your subviews at this point,

398
00:27:13,570 --> 00:27:15,740
to perform additional removal of subviews.

399
00:27:15,740 --> 00:27:20,460
This is a great point to do what people have
often wanted to do which is sort of do some work,

400
00:27:20,460 --> 00:27:23,480
just at the very last minute when you
know you're going to be asked to draw.

401
00:27:23,480 --> 00:27:25,420
OK, now I do my layout.

402
00:27:25,420 --> 00:27:29,200
This is very handy for things if you're doing something
whether you're fetching stuff over the network

403
00:27:29,200 --> 00:27:34,300
and you don't want to actually do your layout work until
you have all of the data that you need or until you know

404
00:27:34,300 --> 00:27:37,100
that you need to draw whatever you have at that point.

405
00:27:37,100 --> 00:27:42,780
If you do use viewWillDraw to perform layout
in this way make sure that you mark the view

406
00:27:42,780 --> 00:27:45,710
as needing display whenever layout work is needed.

407
00:27:45,710 --> 00:27:50,670
If the view isn't marked as needing display we're
never going to send you a drawRect or a viewWillDraw.

408
00:27:50,670 --> 00:27:55,630
And always call up to super viewWillDraw when you
override this because that is in fact the mechanism

409
00:27:55,630 --> 00:27:58,120
for continuing the recursion down to your descendant views.

410
00:27:58,120 --> 00:28:02,460
So you can invoke this before or after, or in
the middle of doing your work possibly depending

411
00:28:02,460 --> 00:28:05,990
on whether your descendants will require
you to have done your work first.

412
00:28:05,990 --> 00:28:09,530
So that's very handy for doing layout.

413
00:28:09,530 --> 00:28:15,560
The lowest hanging fruit in the world
of view optimization is opaqueness.

414
00:28:15,560 --> 00:28:18,750
This sense of whether a view is opaque or not.

415
00:28:18,750 --> 00:28:23,120
This is the easiest and most worthwhile
optimization you can do for a lot of views.

416
00:28:23,120 --> 00:28:25,630
By default a view reports itself as not opaque.

417
00:28:25,630 --> 00:28:29,570
A view draws nothing, right, so it doesn't cover anything.

418
00:28:29,570 --> 00:28:32,830
But if you know that your view is
going to cover its entire content area

419
00:28:32,830 --> 00:28:38,140
with 100 percent opaque fill what you can
do is override-- isOpaque to return YES.

420
00:28:38,140 --> 00:28:41,080
And this is very valuable to us
especially in window-backed mode.

421
00:28:41,080 --> 00:28:44,410
It tells AppKit basically don't
bother drawing anything behind me.

422
00:28:44,410 --> 00:28:47,310
Don't bother asking any views behind
me to draw in my rectangle

423
00:28:47,310 --> 00:28:49,640
because I'm going to paint over all of that anyway.

424
00:28:49,640 --> 00:28:53,510
So we can even get away with not drawing
the window background fill behind you

425
00:28:53,510 --> 00:28:57,820
which can be a significant savings especially
if your view covers a large window area.

426
00:28:57,820 --> 00:29:04,770
Now, if your view reports itself as opaque but it
has an overall alphaValue setting of less than 1.0,

427
00:29:04,770 --> 00:29:07,020
less than fully opaque AppKit still does the right thing.

428
00:29:07,020 --> 00:29:11,260
So you don't need to worry about taking into account
what your views alphaValue maybe that's the sort

429
00:29:11,260 --> 00:29:16,940
of overall opacity dial in for how your view is
composited in, it matters mostly in layer-backed mode.

430
00:29:16,940 --> 00:29:21,120
Just take into account your fill coverage and whether
you're filling with an opaque color and you'll see

431
00:29:21,120 --> 00:29:28,920
that TreeView reports itself as opaque for example depending
on whether its background color is an opaque color.

432
00:29:28,920 --> 00:29:35,610
For geometry calculations just some high level points,
always make sure you're using compatible units.

433
00:29:35,610 --> 00:29:37,690
You can get into a lot of trouble if you're not.

434
00:29:37,690 --> 00:29:44,270
Remember when you are using NSPoint values, NSSizes,
NSRects, these are all implicitly defined in terms

435
00:29:44,270 --> 00:29:49,840
of some coordinate system in which coordinate system is, it
usually it's the coordinate system of some particular view

436
00:29:49,840 --> 00:29:54,810
or some window that information isn't carried along
with those geometry values so you've got to be careful

437
00:29:54,810 --> 00:30:00,150
to make sure that your code treats those values
appropriately so if you're writing a mathematical expression

438
00:30:00,150 --> 00:30:02,830
where you're doing some layout
computation you have to make sure that all

439
00:30:02,830 --> 00:30:04,750
of the units that you are using are compatible.

440
00:30:04,750 --> 00:30:08,940
They are on the same views coordinate space, for example.

441
00:30:08,940 --> 00:30:15,110
And in order to get compatible units, you want to
do the necessary conversions between view spaces

442
00:30:15,110 --> 00:30:19,460
and these are the six canonical methods that we
provide on NSView for enabling you to do that,

443
00:30:19,460 --> 00:30:28,230
you can convertPoint values, NSSize values, NSRect values
and you can convert them from the receiver of the message,

444
00:30:28,230 --> 00:30:31,540
from a given view to the receiver
of the message or to a given view.

445
00:30:31,540 --> 00:30:33,900
So, there is a little bit of duplication here.

446
00:30:33,900 --> 00:30:36,520
You can use whatever syntax is more convenient for you.

447
00:30:36,520 --> 00:30:42,240
You can tell A convert point from view
B or tell B convert point to view A.

448
00:30:42,240 --> 00:30:47,170
So these are very useful for making
sure you have compatible units.

449
00:30:47,170 --> 00:30:51,550
There is a special meaning to passing
nil as your view parameter here.

450
00:30:51,550 --> 00:30:56,370
Nil denotes the windows coordinate space and
for window-backed rendering as you may know,

451
00:30:56,370 --> 00:31:00,280
this is a very good space to do any pixel
rounding calculations you need to do.

452
00:31:00,280 --> 00:31:05,650
If you want to wind things on exact pixel boundaries
which at times to produce crisper, sharper rendering,

453
00:31:05,650 --> 00:31:12,840
you often want to do your pixel alignment in window
space but what about when you are going layer-backed?

454
00:31:12,840 --> 00:31:16,260
When you're layer-backed, your backing
layer isn't necessarily aligned

455
00:31:16,260 --> 00:31:19,130
in the same way as your windows pixel coordinate space.

456
00:31:19,130 --> 00:31:24,710
So you want to perform, you're rounding in that
case in the layers interior pixel coordinate space.

457
00:31:24,710 --> 00:31:29,080
So rather than how do you have to worry about this,
we provided a set of new methods for converting to

458
00:31:29,080 --> 00:31:34,280
and from what we call a base space and base space
is implicitly sort of the appropriate space for you

459
00:31:34,280 --> 00:31:38,530
to do pixel rounding calculations whether
your window-backed or layer-backed.

460
00:31:38,530 --> 00:31:43,600
If you are window-backed, it is the same as converting
to and fromView nil, so you might take a point convert it

461
00:31:43,600 --> 00:31:49,000
to base and then do some floor, or round, or ceil
arithmetic on it and then convert it back from base

462
00:31:49,000 --> 00:31:51,970
to do whatever drawing or layout
you need to do in your view.

463
00:31:51,970 --> 00:31:52,940
So these are very handy.

464
00:31:52,940 --> 00:31:56,950
I encourage you to use these when you are doing
writing model pixel rounding code from scratch.

465
00:31:56,950 --> 00:32:01,120
It saves you a lot of work and makes you sort
of window-backed versus layer-backed agnostic.

466
00:32:01,120 --> 00:32:03,470
Your code can work both ways.

467
00:32:03,470 --> 00:32:07,820
Lastly, a quick item about handling
printing or PDF output specially.

468
00:32:07,820 --> 00:32:12,880
We sort of take for granted nowadays that we have this
unified imaging model where you write your drawing code once

469
00:32:12,880 --> 00:32:19,970
and the same ports drawing code can be used to produce
output that goes to your view and its window and also output

470
00:32:19,970 --> 00:32:23,040
to be saved to PDF file or to be sent to a printer.

471
00:32:23,040 --> 00:32:27,520
For most cases, you want to use the exact same code to
do that, but occasionally, you'll want to customize some

472
00:32:27,520 --> 00:32:32,150
of your drawing code for printing and the way to do
that is to look at your current graphics context.

473
00:32:32,150 --> 00:32:35,290
Your graphics context will tell you
whether it is drawing to the screen.

474
00:32:35,290 --> 00:32:38,060
If it says, no I'm not drawing
to the screen, you can assume OK,

475
00:32:38,060 --> 00:32:42,240
I'm being drawn either for, to say
PDF output or I'm being printed.

476
00:32:42,240 --> 00:32:45,360
And you can do things like for example, you
know, a web browser will give you the option,

477
00:32:45,360 --> 00:32:49,590
usually when you print a page, do you want
me to print the web page background or not?

478
00:32:49,590 --> 00:32:53,470
Usually, you want to leave that image
or color fill out 'cause why bother?

479
00:32:53,470 --> 00:32:55,300
So, here is an example of doing something like that.

480
00:32:55,300 --> 00:33:00,800
Only if we're drawing to screen in list view fill its
background, otherwise, the drawing code could be the same.

481
00:33:00,800 --> 00:33:03,560
So, just a quick tip there.

482
00:33:03,560 --> 00:33:08,310
So those are the essentials, sort of I think for drawing
and layout, now let us look at handling of state changes.

483
00:33:08,310 --> 00:33:15,950
You know, handling things that can happen to your view that
you might want to react to but might not have initiated.

484
00:33:15,950 --> 00:33:17,960
First, quickly entering and exiting layer-backed mode.

485
00:33:17,960 --> 00:33:19,480
Again, in most cases, this is magic.

486
00:33:19,480 --> 00:33:20,660
You do not need to worry about it.

487
00:33:20,660 --> 00:33:27,350
If you are doing fancy staff like hanging your additional
layers of our own off of the AppKit provided backing layer,

488
00:33:27,350 --> 00:33:32,770
setLayers is the override point for this because it's
invoked recursively when a view subtree becomes layer-backed

489
00:33:32,770 --> 00:33:37,400
or ceases to be layer-backed every view in the tree will
get either assigned a new layer or assigned layer nil

490
00:33:37,400 --> 00:33:39,620
if we're tearing down the backing layer tree.

491
00:33:39,620 --> 00:33:43,980
Set 1's layer isn't a good place to do this because
only the top level view on the subtree will get it

492
00:33:43,980 --> 00:33:49,500
and this was talked about in detail at the Leveraging
Cocoa's Layer-Backed Views talk back in WWC 2008,

493
00:33:49,500 --> 00:33:53,940
if you can find this on ADC on iTunes, I encourage
you to look at it because it deals with a lot

494
00:33:53,940 --> 00:33:59,340
of the important new ounces of writing
your code for a layer-backed mode.

495
00:33:59,340 --> 00:34:04,760
More mundane kind of everyday stuff and the course of its
life cycle your view will be added to a superview sometimes

496
00:34:04,760 --> 00:34:09,600
and removed from the superview and as part of that, it's
entering a new window or being removed from a window.

497
00:34:09,600 --> 00:34:16,080
So let's say, we have here a text field that has actually
a subview, that X button there at the right hand is meant

498
00:34:16,080 --> 00:34:18,010
to be seen as a subview of the text field.

499
00:34:18,010 --> 00:34:25,210
And let's say, we add the text field to some
view-- superview in the window, what will happen?

500
00:34:25,210 --> 00:34:29,670
The text field itself will get a viewWillMoveToSuperview
message notifying that you're about to be moved

501
00:34:29,670 --> 00:34:34,900
to a new superview and this is a great override point if you
want to be able to do something special when that happens.

502
00:34:34,900 --> 00:34:36,500
You'll get the new superview as a parameter.

503
00:34:36,500 --> 00:34:41,460
You can look at self superview to find out which superview
we were in previously because this is a will notification.

504
00:34:41,460 --> 00:34:45,600
This hasn't happened yet, it's telling
you that change is about to happen.

505
00:34:45,600 --> 00:34:51,750
Now in addition, every view in that subtree is
going to get a viewWillMoveToWindow message,

506
00:34:51,750 --> 00:34:54,810
because you're splicing a view into a new superview.

507
00:34:54,810 --> 00:34:58,400
Now all of the views in that subtree are going to
be in a new window that they weren't in before,

508
00:34:58,400 --> 00:35:01,090
maybe they were in window nil now,
they're moving to a new window.

509
00:35:01,090 --> 00:35:04,650
Again, you get the new window as a
parameter or you can ask for self window

510
00:35:04,650 --> 00:35:06,970
to find out which window you are moving from.

511
00:35:06,970 --> 00:35:11,690
So okay, you move the view in, the changes happen.

512
00:35:11,690 --> 00:35:17,150
Then viewDidMoveToWindow, gets done to every view on
the subtree but viewDidMoveToSuperview get sent only

513
00:35:17,150 --> 00:35:20,150
to the top level view, the text field in this case.

514
00:35:20,150 --> 00:35:25,260
So these can be very useful in particular for
subscribing for notifications related to the window,

515
00:35:25,260 --> 00:35:28,630
you want to know when you go into a new window,
OK, now I want to subscribe to notifications

516
00:35:28,630 --> 00:35:32,700
for certain things happening in this window and then when
you're pulled out of the window, you want to unsubscribe

517
00:35:32,700 --> 00:35:34,200
so you don't get those notifications anymore.

518
00:35:34,200 --> 00:35:36,230
That's a typical usage pattern.

519
00:35:36,230 --> 00:35:39,280
Being hidden or unhidden, usually
not something you need to react too

520
00:35:39,280 --> 00:35:42,300
but maybe some times you're doing
some processing that's expensive.

521
00:35:42,300 --> 00:35:48,740
You are decoding some animation and if your view is hidden,
and it's not displaying anything, why bother eating up CPU

522
00:35:48,740 --> 00:35:53,270
and resources so you might want to turn that stuff
off temporarily or pause it when you're hidden.

523
00:35:53,270 --> 00:35:59,960
So when a view becomes hidden, really hiding handles, hiding
effects an entire view subtree, so if we say set hidden Yes

524
00:35:59,960 --> 00:36:05,820
to the text field it and its button are going
to be hidden and both of those views are going

525
00:36:05,820 --> 00:36:11,460
to get viewDidHide messages and then for unhiding
there is a corresponding viewDidUnhide message.

526
00:36:11,460 --> 00:36:18,240
So again, you know, maybe not something you need to
respond to but if you need to, those are the hooks.

527
00:36:18,240 --> 00:36:20,250
Becoming/Resigning firstResponder.

528
00:36:20,250 --> 00:36:24,790
FirstResponder, for those familiar with other user interface
framework is sort of our concept of the focused view.

529
00:36:24,790 --> 00:36:29,520
It is the view in a window that will get any key
stroke events that go to the window, so in AppKit,

530
00:36:29,520 --> 00:36:33,830
we call that firstResponder and when your view
becomes a candidate to become firstResponder,

531
00:36:33,830 --> 00:36:40,470
maybe the user clicks on it to put the input
focus there or tabs to it if it is the key loop,

532
00:36:40,470 --> 00:36:42,240
you'll get an acceptsFirstResponder message.

533
00:36:42,240 --> 00:36:45,180
AppKit is asking you, hey, can
you become the firstResponder?

534
00:36:45,180 --> 00:36:51,240
If you answer Yes, you will becomeFirstResponder
message and a resignFirstResponder message.

535
00:36:51,240 --> 00:36:57,180
You may also be interested in whether your window is Key
because usually, the combination of being firstResponder

536
00:36:57,180 --> 00:37:01,790
and being in the Key window, being the
window in the application that's designated

537
00:37:01,790 --> 00:37:05,810
to receive Key events is what you used
to determine whether you want to draw,

538
00:37:05,810 --> 00:37:08,630
say a focused range so that you are
focused and actually receive input.

539
00:37:08,630 --> 00:37:10,610
And there are WindowDidBecomeKey

540
00:37:10,610 --> 00:37:15,840
and WindowDidResignKeyNotifications
that you want to look for, for that.

541
00:37:15,840 --> 00:37:19,860
Being resized, very basic thing, it happens to all views,

542
00:37:19,860 --> 00:37:23,540
setFrameSize is a perfectly fine
override point for finding out about that.

543
00:37:23,540 --> 00:37:27,720
If you do override it, always call up to
super and then do whatever layout positioning

544
00:37:27,720 --> 00:37:30,120
of your content or subviews, you need to do.

545
00:37:30,120 --> 00:37:35,220
You can also override resizeWithOldSuperviewSize
and or resizeSubviewsWithOldSize.

546
00:37:35,220 --> 00:37:37,060
However, if you do this, one of the things people get hung

547
00:37:37,060 --> 00:37:40,880
up on sometimes it'll override these methods
and they find they don't get invoked.

548
00:37:40,880 --> 00:37:45,210
What is very important is that you are view
instances have the autoresizesSubviews flag set

549
00:37:45,210 --> 00:37:48,010
to Yes in order for this messages to be sent.

550
00:37:48,010 --> 00:37:50,500
If autoresizesSubviews is off, since these are part

551
00:37:50,500 --> 00:37:55,780
of the autoresizing mechanism these
messages will not get sent to you.

552
00:37:55,780 --> 00:37:59,780
Again, it is always a good practice to call
up to super if you override these methods.

553
00:37:59,780 --> 00:38:04,790
So both of these are fine ways of doing it, a lot of
people like to override setFrameSize because it's reliable,

554
00:38:04,790 --> 00:38:09,870
you don't have to worry about the
autoresizesSubviews flag being set on instances.

555
00:38:09,870 --> 00:38:13,150
Another good thing to do is make sure that
your view can be archived and unarchived

556
00:38:13,150 --> 00:38:18,090
and one of the really exciting things that
this enables you to do is have the potential

557
00:38:18,090 --> 00:38:21,100
to create an Interface Builder
plug-in and inspector for your view

558
00:38:21,100 --> 00:38:25,640
and make it really a first class citizen
among the world of standard views.

559
00:38:25,640 --> 00:38:31,240
And the technique for this is pretty much the same thing you
do for any ordinary object that you want to make archivable,

560
00:38:31,240 --> 00:38:37,020
you override encodeWithCoder to write out your state after
calling up to super to have NSView and your ancestors write

561
00:38:37,020 --> 00:38:40,730
out their state and then you override
initWithCoder to read the state back,

562
00:38:40,730 --> 00:38:43,230
anything that you persisted, you read back in.

563
00:38:43,230 --> 00:38:47,320
And when implementing initWithCoder, you always
want to make sure to access your iBars directly.

564
00:38:47,320 --> 00:38:53,390
It's generally not good practice to invoke your setter
methods because then you may be sending messages

565
00:38:53,390 --> 00:38:57,440
to an object that's not completely
formed and that will confuse your code.

566
00:38:57,440 --> 00:39:01,510
So those are sort of the essentials for being prepared,
for handling stuff that can happen to your view,

567
00:39:01,510 --> 00:39:03,690
our last section for today is handling interaction.

568
00:39:03,690 --> 00:39:05,650
We're going talk about input for a bit and of course,

569
00:39:05,650 --> 00:39:09,300
there are a variety of input sources
that you can receive events from.

570
00:39:09,300 --> 00:39:15,800
Of course keyboard and mouse, the basics, a trackpad
acts for the most part like mouse that's what it is.

571
00:39:15,800 --> 00:39:18,900
But then, if you have a multitouch trackpad on your machine,

572
00:39:18,900 --> 00:39:22,620
it can also sense gestures and
even individual multitouch events.

573
00:39:22,620 --> 00:39:25,670
So, you may want to take advantage of those capabilities.

574
00:39:25,670 --> 00:39:31,000
Likewise, for a tablet, basically acts like mouse if
you want it to, but will also adds new capabilities

575
00:39:31,000 --> 00:39:34,440
that you can take advantage of such
as variable pressure sensitivity,

576
00:39:34,440 --> 00:39:39,800
the ability to sense whether the users are using
the writing tip or the erase tip and so on.

577
00:39:39,800 --> 00:39:43,750
And last but not least, accessibility which
I again, I consider something very essential.

578
00:39:43,750 --> 00:39:52,600
This is, as has been described in other sessions, another
way for the system and system components like VoiceOver,

579
00:39:52,600 --> 00:39:58,420
anybody who's using the accessibility APIs to discover
the structure view user interface and be able to drive it

580
00:39:58,420 --> 00:40:02,400
in various ways and because that is so important,
I want to talk about it first real quickly.

581
00:40:02,400 --> 00:40:09,170
As we all know, enabling accessibility support in your views
and your applications enable the assistive device access

582
00:40:09,170 --> 00:40:14,040
of course for users with visual
impairments and other such disabilities.

583
00:40:14,040 --> 00:40:19,250
But another under appreciated side benefit is that it
provides for the kind of automated user interface testing

584
00:40:19,250 --> 00:40:21,190
that a lot of us are wanting to do nowadays.

585
00:40:21,190 --> 00:40:26,020
We've been doing unit testing on our low level
code for long time and now people are wanting

586
00:40:26,020 --> 00:40:31,490
to automate their user interface testing to detect
regressions and just sort of performance test things.

587
00:40:31,490 --> 00:40:32,420
That's something that you can do.

588
00:40:32,420 --> 00:40:38,390
Once your interface is accessible, if you make your views
accessible, they can be driven not only by VoiceOver

589
00:40:38,390 --> 00:40:43,070
but by anything that you want to use the accessibility
APIs with, any code that you want to write,

590
00:40:43,070 --> 00:40:46,140
AppleScript, your user interface becomes scriptable.

591
00:40:46,140 --> 00:40:50,140
So the basics in making a costume view
accessible, something like TreeView that's complex,

592
00:40:50,140 --> 00:40:56,420
you want to expose both your view and its internal
substructure to accessibility and you'll see in the code

593
00:40:56,420 --> 00:41:01,880
that we specify appropriate accessibility roles for the
views, you return appropriate accessibility attributes

594
00:41:01,880 --> 00:41:05,130
for the roles that we have declared and you also need

595
00:41:05,130 --> 00:41:08,430
to support setting attribute values
and actions for the appropriate role.

596
00:41:08,430 --> 00:41:14,100
And the real take home point with a TreeView example is
again, because we've structured our content using views,

597
00:41:14,100 --> 00:41:18,620
we get a lot of stuff for free and there is, if you
look at it, there's very little accessibility code

598
00:41:18,620 --> 00:41:22,790
in this code sample and there would've been a
lot more work to do, a lot more of a headache

599
00:41:22,790 --> 00:41:28,280
if you had factored things using-- if go off
on your own and use your own non-view objects

600
00:41:28,280 --> 00:41:32,560
to structure things then those are completely
invisible to us and you really have to build up,

601
00:41:32,560 --> 00:41:35,720
do a lot to build up the accessibility capabilities.

602
00:41:35,720 --> 00:41:37,960
So views are your friends once again.

603
00:41:37,960 --> 00:41:41,810
Handling keyboard input, I won't go into this in
great detail because there is a great session right

604
00:41:41,810 --> 00:41:45,680
after this one, in this room at
11:30 about handling keyboard input

605
00:41:45,680 --> 00:41:49,450
and also dealing with menus and menu customization.

606
00:41:49,450 --> 00:41:54,270
But very briefly, if your view wants key events, lot of
people do not realize you have to ask to accept them,

607
00:41:54,270 --> 00:42:01,920
you need to override the acceptsFirstResponder method that
I mentioned earlier to return YES, by default it returns NO.

608
00:42:01,920 --> 00:42:06,360
And then once you've done that, you override
keyDown to receive key press notifications

609
00:42:06,360 --> 00:42:08,800
and keyUp if you want to know when keys are released.

610
00:42:08,800 --> 00:42:13,300
And the interesting event properties for key
events are the string of characters or the sting

611
00:42:13,300 --> 00:42:18,540
of characters that's composed ignoring the modifier
key state, you can get the bit field that tells you

612
00:42:18,540 --> 00:42:24,320
to stay the modifier keys, that being Shift,
Apple or Command, Control, and Option,

613
00:42:24,320 --> 00:42:28,570
and whether the event is an auto repeat event

614
00:42:28,570 --> 00:42:32,720
or whether this is a user initiated key
stroke that you're getting an event for.

615
00:42:32,720 --> 00:42:36,700
Any key events that you do not handle,
you should always pass up to super,

616
00:42:36,700 --> 00:42:39,290
you might also want to respond
to changes in modifier key state.

617
00:42:39,290 --> 00:42:43,990
You are not-- people sometimes expect to get a keyDown
event when somebody presses the Shift or Command key.

618
00:42:43,990 --> 00:42:44,730
It does not work that way.

619
00:42:44,730 --> 00:42:49,580
Those modifier keys are treated specially but there
is a flagsChanged method that you can override

620
00:42:49,580 --> 00:42:54,610
to get notifications of changes to the modifier key state
and again, you can look at the events modifier flags

621
00:42:54,610 --> 00:43:01,400
to figure out which of those modifier
keys are currently pressed or released.

622
00:43:01,400 --> 00:43:07,080
Lastly, I want encourage you to make the parts of your views
content keyboard navigable because a lot of users just want

623
00:43:07,080 --> 00:43:11,820
to have hands on the keyboard all the time and that's
really nice when you can use a view and access all

624
00:43:11,820 --> 00:43:17,170
of its functionality exclusively from the
keyboard when you feel like doing that.

625
00:43:17,170 --> 00:43:22,160
As part of that, you may want to indicate when your view
is focused to receive keystrokes that help the user know

626
00:43:22,160 --> 00:43:26,120
when I type, where is the typing going to go.

627
00:43:26,120 --> 00:43:30,640
I showed earlier how you can tell when you are the
firstResponder view in a window and when your window is key

628
00:43:30,640 --> 00:43:39,040
or not key, once you've determined that, you can use the
NSSetFocusRingStyle API and to clear the NSGraphics.h

629
00:43:39,040 --> 00:43:44,370
to setup a special drawing style that will surround
any subsequent drawing you do with the FocusRing shape,

630
00:43:44,370 --> 00:43:47,160
so might do to say in your drawRect method.

631
00:43:47,160 --> 00:43:49,130
Here, we are looking at, OK.

632
00:43:49,130 --> 00:43:51,600
Am I, my windows firstResponder?

633
00:43:51,600 --> 00:43:54,910
And is my window, the current key window of the application?

634
00:43:54,910 --> 00:44:00,460
And if so, I can-- I'll save graphic
state to isolate this state change

635
00:44:00,460 --> 00:44:03,460
and then set my FocusRingStyle and then do some drawing.

636
00:44:03,460 --> 00:44:07,810
Now when you do this, you want
to be careful about invalidation.

637
00:44:07,810 --> 00:44:11,440
There is a special method that you should
use when your view is showing a FocusRing,

638
00:44:11,440 --> 00:44:17,760
you should always use seKeyboardFocusRingNeedsDisplayInRect
instead of setNeedsDisplayInRect.

639
00:44:17,760 --> 00:44:19,600
Anywhere you would send the a setNeedsDisplayInRect.

640
00:44:19,600 --> 00:44:23,130
The reason for this is that FocusRing drawing
kind of breaks the conventional rules of drawing.

641
00:44:23,130 --> 00:44:26,200
It is not clipped in the same way
that conventional drawing is.

642
00:44:26,200 --> 00:44:30,390
This is what enables you to draw a FocusRing around
the perimeter of your view inside your drawRect

643
00:44:30,390 --> 00:44:34,190
where we would normally clip any
drawing to your view's interior.

644
00:44:34,190 --> 00:44:38,970
So what KeyboardFocusRingNeedsDisplayInRect does it
basically adds a little extra padding to make sure

645
00:44:38,970 --> 00:44:42,690
that the FocusRing spill over, gets erased.

646
00:44:42,690 --> 00:44:48,140
Now spot and events, when the user clicks the main mouse
button, you will get a mouseDown event followed by maybe one

647
00:44:48,140 --> 00:44:52,040
or more mouseDragged events and
then a mouseUp message at the end.

648
00:44:52,040 --> 00:44:59,010
What a lot of people like to do is override mouseDown
and then create what we call a modal event tracking loop

649
00:44:59,010 --> 00:45:04,320
where you'll go into a while loop and you'll pull
events off the application cue looking for mouse events

650
00:45:04,320 --> 00:45:08,090
and you'll eat them all up and handle them
until you see that mouseUp event come and then

651
00:45:08,090 --> 00:45:11,980
and only then does mouseDown return back up to the caller.

652
00:45:11,980 --> 00:45:15,220
We tend to discourage this practice
nowadays, I would strongly encourage you

653
00:45:15,220 --> 00:45:18,410
to use these individual methods as override points.

654
00:45:18,410 --> 00:45:23,120
The problem with creating your own modal tracking loop
is that you know, you are taking over the entire--

655
00:45:23,120 --> 00:45:28,320
what you are doing is you are blocking event
processing that the run loop might otherwise do

656
00:45:28,320 --> 00:45:30,610
and handling event loops sources and things.

657
00:45:30,610 --> 00:45:34,560
So, by using these individual methods,
decomposing your mouse event handling,

658
00:45:34,560 --> 00:45:39,280
you free the run loop to handle other
event sources and things like that.

659
00:45:39,280 --> 00:45:45,950
So that is a lot better, so you might have animations
if you do modal tracking loop approach, you know,

660
00:45:45,950 --> 00:45:49,260
you may have animations that are running on
timers, but oh your timers are not getting serviced

661
00:45:49,260 --> 00:45:51,570
because we are not getting back
to the run loop to service them.

662
00:45:51,570 --> 00:45:54,210
So that's a lot better approach nowadays.

663
00:45:54,210 --> 00:46:01,490
And for handling right mouse button, there are corresponding
rightMouseDown, rightMouseDragged, rightMouseUp messages

664
00:46:01,490 --> 00:46:06,750
and then for mice with more buttons than that, there
is otherMouseDown and otherMouseDragged, otherMouseUp.

665
00:46:06,750 --> 00:46:11,270
The main event properties of interest for mouse messages
buttonNumber of course, which button was pressed.

666
00:46:11,270 --> 00:46:16,390
This is especially important for otherMouseDown
since that's in for any other button.

667
00:46:16,390 --> 00:46:19,770
ClickCount, you know, maybe I'll
be too if it was a double click.

668
00:46:19,770 --> 00:46:24,190
The modifier flags, you also get the state of the
modifier keys at that time of the mouse event,

669
00:46:24,190 --> 00:46:29,840
and then locationInWindow which is the location
of the mouse cursor at the time of the event.

670
00:46:29,840 --> 00:46:33,680
And this is-- it's important to point out, this is provided
in window coordinates, as a lot of people do not realize,

671
00:46:33,680 --> 00:46:37,400
you need to convert this to your views interior
coordinates usually to do something useful with it.

672
00:46:37,400 --> 00:46:40,260
So here we have a mouseDown method.

673
00:46:40,260 --> 00:46:46,340
And we want to get the point in the view, we get the events
locationInWindow and use the convertPoint fromView method

674
00:46:46,340 --> 00:46:49,950
that I mentioned earlier to convert that
point from window space to view space.

675
00:46:49,950 --> 00:46:54,160
Now, it's in view space, now we know what to do
with it because all of our layout calculations

676
00:46:54,160 --> 00:47:00,170
and drawing calculations are presumably
done in our own interior coordinate space.

677
00:47:00,170 --> 00:47:05,610
You can also ask to receive mouseMoved messages if
you're interested in every little motion of the mouse.

678
00:47:05,610 --> 00:47:08,730
But because these are kind of expensive to
send out, we don't send them out by default.

679
00:47:08,730 --> 00:47:12,160
So one of the pitfalls people sometimes run
into, they'll override mouseMoved and say, hey,

680
00:47:12,160 --> 00:47:13,610
why aren't I getting mouseMoved messages.

681
00:47:13,610 --> 00:47:18,660
I'm moving the mouse, because they're expensive
to send out, we don't send them out by default,

682
00:47:18,660 --> 00:47:23,730
you need to send your window message, not the
view but the window saying setAcceptsMouseMoved:

683
00:47:23,730 --> 00:47:27,750
YES and then you'll open the floodgates
and then get the mouseMoved messages.

684
00:47:27,750 --> 00:47:33,640
However, if you can, if you can do what you need to
using one of these other facilities such as tool tips,

685
00:47:33,640 --> 00:47:38,510
if you just want to pop up a little text message, you know,
pop up when the user mouse is over a certain rectangle

686
00:47:38,510 --> 00:47:42,610
in your viewer, you want to change the cursor or actually
do any other kind of arbitrary thing, tracking rects--

687
00:47:42,610 --> 00:47:45,750
tracking areas rather as a more modern form--

688
00:47:45,750 --> 00:47:50,710
the most general form of this, use
these facilities whenever possible.

689
00:47:50,710 --> 00:47:54,040
They're made much more lightweight by the fact that
a lot of the work is done in the windows service

690
00:47:54,040 --> 00:47:59,140
and the app is only called on to do work when
something-- an interesting event actually happens.

691
00:47:59,140 --> 00:48:04,510
So, if you have to, ask for mouseMoved events but if
you don't really need them, if you can get by with this,

692
00:48:04,510 --> 00:48:08,820
these are much lighter weight facilities
for reacting the mouse movements.

693
00:48:08,820 --> 00:48:10,180
Gestures and touch events.

694
00:48:10,180 --> 00:48:14,680
You know, something obviously only users who have
multitouch trackpads are going to be able to use these.

695
00:48:14,680 --> 00:48:19,390
You don't ever want to tie any of your views
functionality exclusively to gestures or touch events

696
00:48:19,390 --> 00:48:24,780
but it provides a nice way to provide some extra polish and
another more natural way to interact with certain aspects

697
00:48:24,780 --> 00:48:29,520
of your view for users who do have multi-touch track pads.

698
00:48:29,520 --> 00:48:35,160
So gestures are the highest level form of this and the
easiest to implement, and gestures are sort of abstractions

699
00:48:35,160 --> 00:48:38,690
that are implemented by the device
layer, they're interpreted for you.

700
00:48:38,690 --> 00:48:40,370
You don't need to opt in the received gestures.

701
00:48:40,370 --> 00:48:47,080
You just override one or more of magnifyWithEvent,
rotateWithEvent, or swipeWithEvent and this will notify you

702
00:48:47,080 --> 00:48:50,970
when the user is making the sort of
familiar gestures that we've all learned now,

703
00:48:50,970 --> 00:48:53,590
magnify being sort of the pinch gesture, rotate, you know,

704
00:48:53,590 --> 00:48:56,980
gesture where you move your fingers
about a common center and swiping.

705
00:48:56,980 --> 00:49:01,520
When you're using either a three-finger swipe on a
trackpad or actually even on a magic mouse nowadays,

706
00:49:01,520 --> 00:49:04,800
you can do a two-finger swipe and
you will get swipeWithEvent.

707
00:49:04,800 --> 00:49:10,060
So, in the TreeView case, if you have a multitouch
trackpad and or a magic mouse and you swipe,

708
00:49:10,060 --> 00:49:16,070
you'll see that it collapses or expands the entire
tree in response to that, just a sort of a demo item.

709
00:49:16,070 --> 00:49:20,340
You might also be interested in
beginGestureWithEvent which tells you when you're--

710
00:49:20,340 --> 00:49:23,010
we're starting a series of gesture messages.

711
00:49:23,010 --> 00:49:28,360
Basically the user has touched the trackpad with one or
more fingers and we're starting to interpret gestures.

712
00:49:28,360 --> 00:49:33,400
So we get a beginGestureWithEvent at the beginning and
then you'll get one or more of these, magnifyWithEvent,

713
00:49:33,400 --> 00:49:36,780
rotateWithEvent, swipeWithEvent
messages, and then at the end

714
00:49:36,780 --> 00:49:39,890
when the user lets their fingers off the
trackpad, you will get an endGestureWithEvent.

715
00:49:39,890 --> 00:49:45,550
So if there is any processing you need to do at the
beginning or end of a series, those are the hooks to do it.

716
00:49:45,550 --> 00:49:50,160
If you want to get really fancy, you can
ask to receive individual touch events.

717
00:49:50,160 --> 00:49:52,590
This is new in Snow Leopard, there's API for this.

718
00:49:52,590 --> 00:49:54,190
You have to opt-in.

719
00:49:54,190 --> 00:49:58,100
This is obviously more complex because
then it is up to you to figure out how

720
00:49:58,100 --> 00:50:03,480
to interpret the touch events individually, but
it's arbitrarily powerful and that you basically get

721
00:50:03,480 --> 00:50:07,050
to define your own gestures, however you want to.

722
00:50:07,050 --> 00:50:10,020
You need to opt-in to receive these,
they are not sent by default.

723
00:50:10,020 --> 00:50:17,040
You need to send setAcceptsTouchEvents to your view,
and if you want resting touches, setWantsRestingTouches.

724
00:50:17,040 --> 00:50:21,040
And then once you've done one or both of those,
you need to override all of the following methods,

725
00:50:21,040 --> 00:50:27,180
touchesBeganWithEvent, touchesMovedWithEvent,
touchesEndedWithEvent, and touchesCancelledWithEvent

726
00:50:27,180 --> 00:50:34,400
and always, always in your implementations of these
call up to super to make everything work great.

727
00:50:34,400 --> 00:50:36,630
Lastly, quick note about tablet input.

728
00:50:36,630 --> 00:50:38,560
Some of your users may have tablets.

729
00:50:38,560 --> 00:50:42,190
This is a bit more specialized in
that, you know, if you want to--

730
00:50:42,190 --> 00:50:46,870
if your app or your view needs to use tablet
input, you probably know it already, you know,

731
00:50:46,870 --> 00:50:50,530
you're implementing a view for
sketching or something like that.

732
00:50:50,530 --> 00:50:53,870
But there are maybe cases where you want to do
clever stuff, we haven't thought of with this.

733
00:50:53,870 --> 00:50:59,730
The basics for handling tablet input, the first high level
item to be aware of is we have an inking system on Mac OS X.

734
00:50:59,730 --> 00:51:02,170
It's a handwriting recognition system, we call that inking.

735
00:51:02,170 --> 00:51:06,230
By default, when someone touches
the pen down over your view,

736
00:51:06,230 --> 00:51:09,570
the system will assume that the
user maybe wants to start inking.

737
00:51:09,570 --> 00:51:13,440
They want to start doing some handwriting that
is to be interpreted and converted to text.

738
00:51:13,440 --> 00:51:19,940
So if you want to handle pen events yourself, you need
to override, shouldBeTreatedAsInkEvent and return NO

739
00:51:19,940 --> 00:51:23,190
when you want to suppress inking
and get the pen events yourself.

740
00:51:23,190 --> 00:51:27,870
NSControl because usually when you got a tablet and you're
interacting with controls, you want to interact with them,

741
00:51:27,870 --> 00:51:33,680
you do not want to start inking when you touch the pen over
a pop-up button say, so NSControl by default returns NO

742
00:51:33,680 --> 00:51:37,040
but NSView if you're subclassing directly, returns YES.

743
00:51:37,040 --> 00:51:42,310
So, you need to override it.

744
00:51:42,310 --> 00:51:46,820
Tablets in addition to acting like mice
provide some special events for you.

745
00:51:46,820 --> 00:51:53,570
There's a tabletProximity event that gets sent when the
pen or stylus comes within sensor range of the tablet

746
00:51:53,570 --> 00:51:57,730
or leaves sensor range and there's also a tablet
point event that gets in as the user moves the pen

747
00:51:57,730 --> 00:52:00,230
around but it isn't necessarily clicking.

748
00:52:00,230 --> 00:52:02,870
So we got locationInWindow.

749
00:52:02,870 --> 00:52:08,100
You can get the absolute position of the pen on
the tablet so that the position that's not mapped

750
00:52:08,100 --> 00:52:11,690
into your screen space by just raw position.

751
00:52:11,690 --> 00:52:15,420
The pressure as I mentioned, which is number from 0 to 1.

752
00:52:15,420 --> 00:52:19,340
Mice only have one pressure for clicking which is 0 or 1.

753
00:52:19,340 --> 00:52:21,260
You know, your clicks always have a pressure of 1.

754
00:52:21,260 --> 00:52:22,840
But with the pen, you can get variable pressure.

755
00:52:22,840 --> 00:52:29,130
You can sense with some devices the rotation or tilt of the
stylus, tangentialPressure on some devices, the buttoMask,

756
00:52:29,130 --> 00:52:36,020
which buttons are pressed or released and whether the event
is a proximity event where the pen is coming into proximity.

757
00:52:36,020 --> 00:52:39,220
And then there are a whole bunch of vendor.

758
00:52:39,220 --> 00:52:43,210
Mostly the vendor defines things where it can
find out what type of device is being used.

759
00:52:43,210 --> 00:52:47,390
And that's pretty much it for input.

760
00:52:47,390 --> 00:52:53,340
So we looked at four major topic areas today, how to
design your views with animation in mind from the beginning

761
00:52:53,340 --> 00:52:58,350
so that you can have the most versatility in order to move
stuff around the way you want to, how do you do drawing

762
00:52:58,350 --> 00:53:03,360
and layout, handling of state changes, things that can
happen to your view that you might want to react to,

763
00:53:03,360 --> 00:53:06,400
and lastly handling of interaction or user input.

764
00:53:06,400 --> 00:53:11,420
The take home thoughts I want to leave you with, with
attention to detail and thought put into the design

765
00:53:11,420 --> 00:53:14,820
of your custom views, you can craft
robust and polished customs views

766
00:53:14,820 --> 00:53:18,070
that ideally will fit naturally
into the Aqua user interface.

767
00:53:18,070 --> 00:53:21,000
And the user of your app won't necessary realize that, oh,

768
00:53:21,000 --> 00:53:25,070
they're using something custom that's not just
something that Apple built right into the UI.

769
00:53:25,070 --> 00:53:28,880
I encourage you to download and
refer to the TreeView code sample.

770
00:53:28,880 --> 00:53:33,030
There's a lot of good stuff in there especially
the layer-backed mode optimization stuff, again,

771
00:53:33,030 --> 00:53:35,190
the first time that we've illustrated some of these things,

772
00:53:35,190 --> 00:53:40,180
and there's also the accompanying view implementor's
checklist, which I hope you'll find useful to go

773
00:53:40,180 --> 00:53:44,520
down as you're trying to look for reminders
when implementing your own custom views.

774
00:53:44,520 --> 00:53:50,020
There's a lot of good related documentation out
there for those who are implementing custom views.

775
00:53:50,020 --> 00:53:52,040
The Cocoa View Programming Guide of course.

776
00:53:52,040 --> 00:53:56,480
I encourage you to refer to the Cocoa Accessibility
Guide when making your views accessible.

777
00:53:56,480 --> 00:53:58,860
Cocoa Drawing Guide, Cocoa Event-Handling Guide.

778
00:53:58,860 --> 00:54:03,930
And again, right after this talk we've got a great
talk coming up on Key Event Handling and menus.

779
00:54:03,930 --> 00:54:06,490
I encourage you to stick around for that.

780
00:54:06,490 --> 00:54:11,970
Also, earlier this week, we had the Design Principles for
Accessibility talk, and also Cocoa Tips and Tricks talked

781
00:54:11,970 --> 00:54:15,780
about both accessibility, and somewhat
related to what TreeView does,

782
00:54:15,780 --> 00:54:21,550
it talked about how NSCollectionView
deals with loading views from nibs.

783
00:54:21,550 --> 00:54:24,260
It's very similar model that TreeView tries to use.

784
00:54:24,260 --> 00:54:29,090
Lastly, I hope you had the opportunity to attend the
API Design for Cocoa and Cocoa Touch talk yesterday.

785
00:54:29,090 --> 00:54:34,010
That was a great talk that really distilled a lot
of the fundamental design philosophy that we used

786
00:54:34,010 --> 00:54:40,170
when developing Cocoa APIs, especially if you're going to be
developing custom views for other people to potentially use.

787
00:54:40,170 --> 00:54:42,130
This talk provides a lot of great guidelines.

788
00:54:42,130 --> 00:54:48,320
So if you didn't get to go to it, I hope you
get a chance to review it on ADC for iTunes.

789
00:54:48,320 --> 00:54:50,530
For more information, you can contact our evangelist.

790
00:54:50,530 --> 00:54:54,790
We've also got developer forums where
you can ask questions and get answers.

791
00:54:54,790 --> 00:54:55,940
Thank you very much.

792
00:54:55,940 --> 00:54:57,610
I hope you enjoyed today's talk.

793
00:54:57,610 --> 00:55:00,810
[ Applause ]

