WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:11.516 A:middle
[ Silence ]

00:00:12.016 --> 00:00:20.000 A:middle
[ Applause ]

00:00:22.556 --> 00:00:26.286 A:middle
&gt;&gt; Hi. My name is John McCall.

00:00:26.286 --> 00:00:27.726 A:middle
I'm a compiler engineer

00:00:27.726 --> 00:00:30.976 A:middle
on the Swift project
and a horrible nerd.

00:00:31.876 --> 00:00:37.326 A:middle
And today I want to talk
to you about how, you know,

00:00:37.326 --> 00:00:39.206 A:middle
you can take advantage
of really,

00:00:39.206 --> 00:00:41.236 A:middle
all of the language tools
that we've built into Swift

00:00:41.236 --> 00:00:44.436 A:middle
to make your code so
much more expressive,

00:00:44.436 --> 00:00:46.226 A:middle
and powerful, and safe.

00:00:46.956 --> 00:00:49.086 A:middle
We're going to start
off by talking

00:00:49.086 --> 00:00:51.376 A:middle
about how you can take control

00:00:51.376 --> 00:00:54.946 A:middle
of really the basic
language and syntax of Swift.

00:00:54.946 --> 00:00:57.106 A:middle
We're going to follow
that up by talking

00:00:57.106 --> 00:01:01.616 A:middle
about a much more advanced
topic of generic programming,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:57.106 --> 00:01:01.616 A:middle
about a much more advanced
topic of generic programming,

00:01:01.616 --> 00:01:04.906 A:middle
and then we're going to finish
that up real quick by talking

00:01:04.906 --> 00:01:09.346 A:middle
about how Swift is implemented
and how it turns your code

00:01:09.346 --> 00:01:12.766 A:middle
into great machine code
that's finally executed.

00:01:14.236 --> 00:01:19.416 A:middle
So when we designed
Swift we wanted

00:01:19.416 --> 00:01:21.916 A:middle
to avoid hard coding too
much about the language.

00:01:22.886 --> 00:01:24.146 A:middle
We think it's really important

00:01:24.146 --> 00:01:26.456 A:middle
to provide a great
standard library

00:01:26.456 --> 00:01:31.686 A:middle
that lets you really get started
right away and making great apps

00:01:31.886 --> 00:01:36.686 A:middle
for your users and just
jump right in and be able

00:01:36.686 --> 00:01:37.786 A:middle
to do what you need to do.

00:01:38.506 --> 00:01:41.386 A:middle
But we didn't want to lock you

00:01:41.386 --> 00:01:43.256 A:middle
into just the tools
that we provided.

00:01:43.866 --> 00:01:47.346 A:middle
We wanted you to be able to
extend that basic language

00:01:47.406 --> 00:01:52.386 A:middle
with new idioms, new
abstractions, and not feel

00:01:52.386 --> 00:01:54.076 A:middle
like you're locking
yourself into that.

00:01:55.826 --> 00:01:58.426 A:middle
In order to show you what
I'm trying to get at here,

00:01:58.426 --> 00:01:59.976 A:middle
I want to work through
an example.

00:01:59.976 --> 00:02:03.216 A:middle
And since this is an
advanced talk I want to work


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.976 --> 00:02:03.216 A:middle
And since this is an
advanced talk I want to work

00:02:03.216 --> 00:02:05.866 A:middle
through an example that
really shows off the advanced

00:02:05.866 --> 00:02:10.056 A:middle
capabilities of our platforms.

00:02:10.106 --> 00:02:12.256 A:middle
If you've never seen a
text adventure before --

00:02:15.516 --> 00:02:18.886 A:middle
[ Applause ]

00:02:19.386 --> 00:02:21.136 A:middle
If you've never seen a
text adventure before,

00:02:21.136 --> 00:02:22.306 A:middle
the idea is pretty simple.

00:02:22.796 --> 00:02:26.186 A:middle
You as the player are wandering
around the world solving puzzles

00:02:26.186 --> 00:02:27.246 A:middle
and having adventures.

00:02:27.846 --> 00:02:31.676 A:middle
You interact with the
game by typing in commands

00:02:31.786 --> 00:02:36.126 A:middle
at a terminal prompt and the
game responds back to you

00:02:36.126 --> 00:02:39.376 A:middle
by interpreting those commands,
trying to carry them out

00:02:39.626 --> 00:02:40.846 A:middle
and then telling
you what happens.

00:02:41.986 --> 00:02:45.866 A:middle
So for example in
the game you're going

00:02:46.926 --> 00:02:50.346 A:middle
to be wandering around,
exploring a lot

00:02:50.346 --> 00:02:53.326 A:middle
of new locations, and finding
a bunch of new objects.

00:02:53.326 --> 00:02:55.666 A:middle
And when you find an object
you're going to be able to --

00:02:56.076 --> 00:02:58.636 A:middle
you want to be able to
look at it, and you know,

00:02:58.636 --> 00:03:01.466 A:middle
try to interact with
it, and maybe even sort


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.636 --> 00:03:01.466 A:middle
try to interact with
it, and maybe even sort

00:03:01.466 --> 00:03:03.646 A:middle
of tear things apart
and really get chaotic.

00:03:05.036 --> 00:03:09.316 A:middle
Now, in this scene we've got a
whole bunch of different objects

00:03:09.706 --> 00:03:11.066 A:middle
that in our game,
we're going to have

00:03:11.066 --> 00:03:13.386 A:middle
to like manually
model one-by-one.

00:03:13.916 --> 00:03:18.066 A:middle
It's going to be a lot of text.

00:03:18.066 --> 00:03:20.966 A:middle
All these objects are going

00:03:20.966 --> 00:03:24.446 A:middle
to be instances ultimately
of this Thing class.

00:03:24.936 --> 00:03:27.466 A:middle
A Thing is really simple
it's not anything more

00:03:27.466 --> 00:03:29.286 A:middle
than just a name
and a description

00:03:29.636 --> 00:03:31.416 A:middle
and a current location
of the object.

00:03:34.976 --> 00:03:39.736 A:middle
Here's a couple of really simple
objects that are nothing more

00:03:39.736 --> 00:03:41.676 A:middle
than just a name
and a description.

00:03:42.386 --> 00:03:44.326 A:middle
You can see, you know,

00:03:45.266 --> 00:03:47.686 A:middle
we're just calling the
initializer directly passing

00:03:47.686 --> 00:03:50.656 A:middle
in a couple literal values.

00:03:51.396 --> 00:03:53.336 A:middle
We're going to have a
ton of objects like this,

00:03:53.516 --> 00:03:56.046 A:middle
scenery objects, maybe
three or four of these

00:03:56.046 --> 00:03:57.676 A:middle
in every single place
in the game.

00:03:58.286 --> 00:04:00.476 A:middle
Added up over what could
be a very large game


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.286 --> 00:04:00.476 A:middle
Added up over what could
be a very large game

00:04:00.476 --> 00:04:03.286 A:middle
that means we're going
to have several hundreds

00:04:03.286 --> 00:04:04.756 A:middle
of these, maybe even thousands.

00:04:04.756 --> 00:04:06.886 A:middle
And it's going to be
really important to me

00:04:06.886 --> 00:04:09.836 A:middle
that this code end up
looking really compact.

00:04:10.116 --> 00:04:14.076 A:middle
That it be really
convenient to read and write.

00:04:14.196 --> 00:04:20.606 A:middle
Well it's already pretty compact
but these keyword arguments,

00:04:20.685 --> 00:04:23.766 A:middle
these argument names aren't
really doing a whole lot for me.

00:04:23.906 --> 00:04:27.396 A:middle
I can actually tell
straight off what each one

00:04:27.396 --> 00:04:30.286 A:middle
of these things are because
there's two different strings,

00:04:30.286 --> 00:04:31.536 A:middle
there's a name of an object.

00:04:31.586 --> 00:04:33.446 A:middle
The two strings, one of
them is really short,

00:04:33.446 --> 00:04:34.526 A:middle
one of them is really long.

00:04:35.376 --> 00:04:37.716 A:middle
It doesn't take much
for me to memorize this.

00:04:37.876 --> 00:04:40.146 A:middle
It would be really great since
I'm going to be writing this

00:04:40.146 --> 00:04:41.686 A:middle
over and over again,
if I didn't have

00:04:41.736 --> 00:04:43.056 A:middle
to have all this redundancy.

00:04:44.106 --> 00:04:48.626 A:middle
So how do we go about actually
changing argument names?

00:04:49.546 --> 00:04:53.486 A:middle
Well in Swift these
argument names come

00:04:54.046 --> 00:04:57.936 A:middle
from the declaration
of the initializer.

00:04:58.216 --> 00:05:01.896 A:middle
By default the parameter
names that we use


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:58.216 --> 00:05:01.896 A:middle
By default the parameter
names that we use

00:05:01.896 --> 00:05:04.546 A:middle
in initializer are also going
to be the argument names.

00:05:05.166 --> 00:05:07.766 A:middle
But that's just the default
we can expand this syntax

00:05:07.766 --> 00:05:08.796 A:middle
out like so.

00:05:09.386 --> 00:05:10.566 A:middle
It's exactly equivalent.

00:05:10.706 --> 00:05:14.076 A:middle
Now I've got the argument
names specifically right next

00:05:14.076 --> 00:05:15.726 A:middle
to the parameter name.

00:05:18.016 --> 00:05:20.676 A:middle
But how do we actually
make something anonymous?

00:05:21.786 --> 00:05:26.166 A:middle
Well Swift has a very consistent
syntax for doing this.

00:05:26.506 --> 00:05:30.126 A:middle
Instead of giving it a real
meaningful identifier you just

00:05:30.126 --> 00:05:31.176 A:middle
give it an underscore.

00:05:31.486 --> 00:05:33.026 A:middle
You can use this syntax in a lot

00:05:33.026 --> 00:05:34.656 A:middle
of different places
in the language.

00:05:35.026 --> 00:05:38.486 A:middle
For example, in this
small for loop,

00:05:38.486 --> 00:05:41.346 A:middle
I'm just iterating all the
entries in the dictionary.

00:05:41.756 --> 00:05:44.706 A:middle
But I don't actually care about
the values in the dictionary,

00:05:45.006 --> 00:05:46.586 A:middle
I just want to print
out all the keys.

00:05:47.396 --> 00:05:50.956 A:middle
I could give this, you
know, its own parameter --

00:05:51.006 --> 00:05:55.116 A:middle
its own local variable name, but
then if this were a larger loop,

00:05:55.216 --> 00:05:57.086 A:middle
you know, somebody coming along

00:05:57.086 --> 00:05:59.906 A:middle
and reading it later would
instinctively feel --


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:00.036 --> 00:06:03.786 A:middle
wonder, if I was actually using
the value somewhere in the loop

00:06:03.956 --> 00:06:05.076 A:middle
and then feel like they needed

00:06:05.076 --> 00:06:07.136 A:middle
to visually search
the entire loop.

00:06:07.516 --> 00:06:09.646 A:middle
So instead I can just
name it with an underscore

00:06:09.646 --> 00:06:13.286 A:middle
which isn't a real variable,
it just says ignore this value.

00:06:13.826 --> 00:06:17.036 A:middle
And that's not just
in initializations,

00:06:17.036 --> 00:06:19.686 A:middle
I can even assign it
as a sort of value sync

00:06:20.006 --> 00:06:22.146 A:middle
so if I have a color,
I can break it

00:06:22.146 --> 00:06:25.486 A:middle
down into its color components.

00:06:25.906 --> 00:06:27.736 A:middle
But in this case I
only care about the red

00:06:27.736 --> 00:06:30.096 A:middle
and blue components, not
the green and the alpha.

00:06:30.426 --> 00:06:34.276 A:middle
So I just assigned the green and
alpha components to underscore,

00:06:34.506 --> 00:06:37.586 A:middle
which just immediately
drops them.

00:06:37.796 --> 00:06:42.866 A:middle
Going back to our initializer,
I have all these argument names

00:06:43.146 --> 00:06:45.816 A:middle
and if I just removed
them I'd end up back

00:06:45.816 --> 00:06:46.966 A:middle
in that default state

00:06:46.966 --> 00:06:50.226 A:middle
where Swift was using
the parameter names

00:06:50.226 --> 00:06:51.756 A:middle
as the default argument names.

00:06:52.516 --> 00:06:55.856 A:middle
But if I want to drop them
completely, I need to tell Swift

00:06:55.856 --> 00:06:57.056 A:middle
that I don't want this.

00:06:57.056 --> 00:07:00.176 A:middle
And the way I do that is I
name it with an underscore.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.056 --> 00:07:00.176 A:middle
And the way I do that is I
name it with an underscore.

00:07:01.456 --> 00:07:03.916 A:middle
This is just a very simple way

00:07:03.916 --> 00:07:06.286 A:middle
of telling Swift I don't
want any argument names,

00:07:06.376 --> 00:07:09.846 A:middle
just let me call this
initializer positionally.

00:07:10.406 --> 00:07:15.676 A:middle
And so I get a much
more compact --

00:07:15.676 --> 00:07:17.306 A:middle
I get much more compact
definitions

00:07:17.306 --> 00:07:18.376 A:middle
of all of my objects.

00:07:18.756 --> 00:07:20.496 A:middle
This isn't something
you'd necessarily want

00:07:20.496 --> 00:07:22.136 A:middle
to do all over the place.

00:07:22.466 --> 00:07:24.486 A:middle
There's a lot of
value that I get

00:07:24.486 --> 00:07:26.736 A:middle
from keyword arguments,
from argument names.

00:07:27.856 --> 00:07:30.776 A:middle
Usually it provides a really
important semantic cue,

00:07:30.776 --> 00:07:34.256 A:middle
but in this case I've thought
about it very carefully

00:07:34.256 --> 00:07:36.546 A:middle
and decided that it's
not providing much value

00:07:36.546 --> 00:07:38.316 A:middle
and that I'd much rather
have the compactness.

00:07:38.476 --> 00:07:43.056 A:middle
All right those were a
couple simple objects.

00:07:43.446 --> 00:07:45.516 A:middle
In a more complicated
object I'm going to --

00:07:45.776 --> 00:07:49.116 A:middle
want to be able to give it a
-- maybe even additional state,

00:07:49.506 --> 00:07:53.256 A:middle
additional logic, maybe make
it respond to an action.

00:07:53.706 --> 00:07:56.466 A:middle
So for example going back to
that original scene I had up,

00:07:56.726 --> 00:07:59.356 A:middle
I had some boards that were
nailed up in front of the door.

00:07:59.676 --> 00:08:02.946 A:middle
I want these boards to be
pullable, so I'm going to end


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.676 --> 00:08:02.946 A:middle
I want these boards to be
pullable, so I'm going to end

00:08:02.946 --> 00:08:05.776 A:middle
up giving it its own
subclass of the Thing class.

00:08:08.566 --> 00:08:12.986 A:middle
Well how do I actually
make it pullable?

00:08:13.076 --> 00:08:19.466 A:middle
My game, when the user types in
pull boards, it's going to hand

00:08:19.466 --> 00:08:22.136 A:middle
that string off to the parser
which will break it down

00:08:22.406 --> 00:08:25.246 A:middle
and look -- find
out the verb pull,

00:08:25.246 --> 00:08:28.496 A:middle
and look around for an
object called boards.

00:08:29.276 --> 00:08:31.046 A:middle
Let's take over from that part.

00:08:31.306 --> 00:08:33.586 A:middle
We're going to implement
a function that takes

00:08:33.626 --> 00:08:35.385 A:middle
in a resolved object

00:08:35.596 --> 00:08:37.905 A:middle
and implements the
pull command on it.

00:08:38.496 --> 00:08:40.926 A:middle
Well how do we want that
to work at a high level?

00:08:41.546 --> 00:08:45.346 A:middle
If the object is
pullable, we want to pull it

00:08:45.346 --> 00:08:47.126 A:middle
and otherwise we're going
to print out some sort

00:08:47.126 --> 00:08:49.816 A:middle
of error message saying hey,
look you can't pull this thing.

00:08:51.466 --> 00:08:54.146 A:middle
Well that's a great
use of a protocol.

00:08:55.506 --> 00:08:58.236 A:middle
We've talked about protocols
a lot in other talks,

00:08:58.296 --> 00:09:01.566 A:middle
but I want to show you what
a protocol looks like now.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.296 --> 00:09:01.566 A:middle
but I want to show you what
a protocol looks like now.

00:09:01.996 --> 00:09:03.836 A:middle
You've probably seen
this in, you know,

00:09:04.066 --> 00:09:08.796 A:middle
reading the entire book, but
a protocol really just looks

00:09:08.796 --> 00:09:10.576 A:middle
like a sort of blueprint
for a type

00:09:10.826 --> 00:09:13.016 A:middle
where you aren't actually
implementing any of the things

00:09:13.016 --> 00:09:15.356 A:middle
in it, you're just describing
what requirements are

00:09:15.356 --> 00:09:16.126 A:middle
actually there.

00:09:16.126 --> 00:09:19.536 A:middle
A pullable protocol
is extremely simple.

00:09:19.536 --> 00:09:22.466 A:middle
It just has one method,
doesn't take any arguments,

00:09:22.466 --> 00:09:23.516 A:middle
doesn't return anything.

00:09:23.516 --> 00:09:29.166 A:middle
In order to adapt this
protocol, we just go back

00:09:29.236 --> 00:09:33.126 A:middle
to our boards class and either
extend it or add pullable

00:09:33.296 --> 00:09:36.486 A:middle
to the main definition of it.

00:09:37.096 --> 00:09:40.386 A:middle
In this case I've decided to
add it to the main definition.

00:09:41.196 --> 00:09:44.256 A:middle
The compiler warns
me straight off

00:09:44.356 --> 00:09:47.776 A:middle
that I haven't actually
fully implemented this,

00:09:48.326 --> 00:09:49.806 A:middle
so I need to go add
the pull method.

00:09:50.256 --> 00:09:52.576 A:middle
Which for my boards
is going to be --

00:09:52.726 --> 00:09:55.106 A:middle
is very straightforward
in its functionality.

00:09:55.406 --> 00:09:58.376 A:middle
You just check to see
whether the boards are still

00:09:58.376 --> 00:10:01.256 A:middle
on the wall, and if
they are you move them


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:58.376 --> 00:10:01.256 A:middle
on the wall, and if
they are you move them

00:10:01.256 --> 00:10:02.976 A:middle
to the ground and
print a message.

00:10:04.106 --> 00:10:05.696 A:middle
And then we'll just
print an error message

00:10:05.696 --> 00:10:08.716 A:middle
if they're not still on the
board so that the player knows

00:10:08.716 --> 00:10:11.616 A:middle
that they don't need to care
about these boards anymore,

00:10:11.616 --> 00:10:16.036 A:middle
they're not going to be useful
in the rest of the game.

00:10:16.266 --> 00:10:19.586 A:middle
Now let's go back to our
perform pull function.

00:10:20.326 --> 00:10:22.886 A:middle
How do we actually check
whether something is pullable?

00:10:23.436 --> 00:10:24.756 A:middle
Well that's very
straightforward.

00:10:24.756 --> 00:10:28.576 A:middle
We can just use a conditional
pass down to the protocol type.

00:10:29.376 --> 00:10:33.446 A:middle
This conditional pass will give
us a value of a pullable type,

00:10:33.906 --> 00:10:36.226 A:middle
which we can then actually
pull if it succeeds.

00:10:36.946 --> 00:10:39.546 A:middle
And if it doesn't
succeed we're just going

00:10:39.546 --> 00:10:40.706 A:middle
to print out an error message.

00:10:41.956 --> 00:10:42.706 A:middle
And that's it.

00:10:42.706 --> 00:10:43.916 A:middle
That's all we needed
to do in order

00:10:43.916 --> 00:10:45.166 A:middle
to implement the pull method.

00:10:46.526 --> 00:10:49.546 A:middle
Now how do we -- now I want
to take a little bit closer

00:10:49.546 --> 00:10:51.306 A:middle
of a look at this error message.

00:10:51.936 --> 00:10:55.256 A:middle
I'm going to have a lot of
text like this in my game,

00:10:55.256 --> 00:10:56.846 A:middle
a lot of messages
that need to work --

00:10:57.006 --> 00:10:58.806 A:middle
apply to an arbitrary object.

00:10:59.486 --> 00:11:00.836 A:middle
And this isn't bad.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:59.486 --> 00:11:00.836 A:middle
And this isn't bad.

00:11:01.366 --> 00:11:06.976 A:middle
This isn't awful syntax, but
it's less compact, less natural

00:11:06.976 --> 00:11:08.816 A:middle
than it needs to be
because of this .name.

00:11:09.336 --> 00:11:12.596 A:middle
Why can't I just put object
and string interpolation here?

00:11:13.456 --> 00:11:14.346 A:middle
Well I can.

00:11:15.016 --> 00:11:17.946 A:middle
Swift knows how to print
out an arbitrary object.

00:11:18.356 --> 00:11:21.836 A:middle
However, the rules that
Swift will use to print

00:11:21.836 --> 00:11:24.306 A:middle
out an arbitrary object
aren't necessarily the most

00:11:24.306 --> 00:11:25.096 A:middle
useful defaults.

00:11:27.006 --> 00:11:30.456 A:middle
How do I actually take
over this syntax and hook

00:11:30.456 --> 00:11:34.106 A:middle
into string interpolation
to actually do what I want?

00:11:34.876 --> 00:11:38.356 A:middle
In general the way that you hook
into a sort of language feature

00:11:38.356 --> 00:11:40.226 A:middle
like this in Swift
is that you're going

00:11:40.226 --> 00:11:41.476 A:middle
to implement a protocol.

00:11:41.746 --> 00:11:44.216 A:middle
A special protocol that the
compiler actually already

00:11:44.216 --> 00:11:44.796 A:middle
knows about.

00:11:46.166 --> 00:11:50.386 A:middle
For example, I can use
special built-in protocols

00:11:50.386 --> 00:11:53.426 A:middle
to make my type be usable
as a [inaudible] condition.

00:11:53.746 --> 00:11:57.356 A:middle
Or to allow the user to iterate
over it using a forward loop.

00:11:57.626 --> 00:12:00.656 A:middle
Or I could even take over one
of the basic literal syntaxes.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.626 --> 00:12:00.656 A:middle
Or I could even take over one
of the basic literal syntaxes.

00:12:01.126 --> 00:12:03.336 A:middle
But in this example what
I want is the second one.

00:12:03.616 --> 00:12:06.326 A:middle
I want to implement printable
so that I can actually --

00:12:06.596 --> 00:12:08.946 A:middle
which is how you take
over string interpolation.

00:12:10.116 --> 00:12:13.926 A:middle
Printable is again a
very simple protocol.

00:12:14.186 --> 00:12:17.276 A:middle
It just has one requirement,
which is a property.

00:12:17.476 --> 00:12:20.346 A:middle
And all I have to do for
that property is implement --

00:12:20.386 --> 00:12:21.646 A:middle
is provide a getter for it.

00:12:21.646 --> 00:12:23.506 A:middle
Could also provide a
setter, but I don't have

00:12:23.566 --> 00:12:25.906 A:middle
to because protocol
doesn't require it.

00:12:26.976 --> 00:12:29.626 A:middle
So in this case I'm going to
go back and add an extension

00:12:29.626 --> 00:12:31.376 A:middle
to thing that implements
printable.

00:12:31.776 --> 00:12:33.816 A:middle
I have to provide
description protocol

00:12:33.816 --> 00:12:35.616 A:middle
and I'll just have it
return the name property.

00:12:36.186 --> 00:12:37.866 A:middle
And that's it.

00:12:38.236 --> 00:12:39.196 A:middle
That's all I needed to do.

00:12:40.426 --> 00:12:43.696 A:middle
Well is this really going to
work for an arbitrary object?

00:12:45.116 --> 00:12:48.136 A:middle
I mean if I look at this text up
here, it doesn't even read right

00:12:48.166 --> 00:12:51.916 A:middle
to me as an English
speaker, because a object.

00:12:52.836 --> 00:12:53.816 A:middle
That's not grammatical.

00:12:54.406 --> 00:12:57.266 A:middle
When I come along and pull --

00:12:57.266 --> 00:13:01.286 A:middle
and try to pull something that
starts with a vowel sound,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:57.266 --> 00:13:01.286 A:middle
and try to pull something that
starts with a vowel sound,

00:13:01.656 --> 00:13:04.416 A:middle
or that's a plural, or
a mass noun in English,

00:13:04.786 --> 00:13:06.616 A:middle
you can't just put
A in front of it.

00:13:06.856 --> 00:13:09.576 A:middle
I need this to be able to
work for an arbitrary thing

00:13:09.576 --> 00:13:12.306 A:middle
which means I need -- and if
I want this to feel natural

00:13:12.306 --> 00:13:15.536 A:middle
to the user, so I don't take the
player out of their experience,

00:13:15.826 --> 00:13:17.886 A:middle
I want this to be
actually grammatical.

00:13:19.396 --> 00:13:22.506 A:middle
Well, how do I actually do that?

00:13:23.136 --> 00:13:29.486 A:middle
From a class design perspective,
I can just define a new property

00:13:30.036 --> 00:13:32.536 A:middle
on Thing that's going
to be name with article

00:13:32.536 --> 00:13:34.716 A:middle
that will throw the right word
in front of it, that's great.

00:13:34.796 --> 00:13:37.716 A:middle
This is a great class design,

00:13:37.716 --> 00:13:41.306 A:middle
but it's not actually very
usable for me if I'm going

00:13:41.366 --> 00:13:45.446 A:middle
to have a ton of text
printing out this thing.

00:13:45.636 --> 00:13:48.136 A:middle
This is actually worse
than just object .name was.

00:13:48.256 --> 00:13:50.016 A:middle
So how can I do better
than this?

00:13:50.156 --> 00:13:51.926 A:middle
Well I really want
to stick something

00:13:51.966 --> 00:13:55.006 A:middle
in the string interpolation
to sort of modify it.

00:13:55.946 --> 00:13:58.036 A:middle
It would be great if I
could just write this --

00:13:58.146 --> 00:13:59.776 A:middle
write an object right there.

00:13:59.776 --> 00:14:03.396 A:middle
But that's not actually
valid Swift syntax for a lot


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.776 --> 00:14:03.396 A:middle
But that's not actually
valid Swift syntax for a lot

00:14:03.396 --> 00:14:07.656 A:middle
of very good reasons, but I
can sort of slightly tweak this

00:14:07.796 --> 00:14:10.296 A:middle
in a way that still
feels very natural,

00:14:10.476 --> 00:14:11.596 A:middle
that's still very readable,

00:14:11.956 --> 00:14:14.396 A:middle
by instead of just putting
them next to each other,

00:14:15.066 --> 00:14:16.916 A:middle
separating them with
a binary operator.

00:14:18.056 --> 00:14:21.036 A:middle
This is a new binary operator
that's not currently defined

00:14:21.036 --> 00:14:21.766 A:middle
in language.

00:14:22.146 --> 00:14:25.666 A:middle
So how do I go about
actually adding it?

00:14:25.936 --> 00:14:29.576 A:middle
Well the way that you define
a new operator for, you know,

00:14:29.576 --> 00:14:31.716 A:middle
either taking an existing
operator and defining it

00:14:31.716 --> 00:14:32.766 A:middle
for a new set of types,

00:14:32.816 --> 00:14:36.546 A:middle
or actually adding a new
operator entirely is you're

00:14:36.546 --> 00:14:37.876 A:middle
going to need a global function.

00:14:38.486 --> 00:14:40.786 A:middle
And the global function
just takes

00:14:41.246 --> 00:14:43.786 A:middle
for a binary operator it's just
going to take two arguments,

00:14:43.856 --> 00:14:46.256 A:middle
one for the left hand side, and
one for the right hand side.

00:14:46.486 --> 00:14:49.156 A:middle
And it's just normal
global function

00:14:49.156 --> 00:14:50.176 A:middle
with a kind of funky name.

00:14:51.206 --> 00:14:53.996 A:middle
But Swift won't actually
let me do this

00:14:54.026 --> 00:14:56.006 A:middle
because it's actually
checking up on me.

00:14:56.496 --> 00:14:59.246 A:middle
Swift doesn't know how to
actually parse an expression

00:14:59.546 --> 00:15:01.496 A:middle
that uses this as
a binary operator.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.546 --> 00:15:01.496 A:middle
that uses this as
a binary operator.

00:15:01.496 --> 00:15:03.746 A:middle
I need to tell Swift
the basic rules

00:15:03.746 --> 00:15:06.066 A:middle
for this as a binary operator.

00:15:06.066 --> 00:15:10.796 A:middle
In order to do that I just need

00:15:10.796 --> 00:15:13.056 A:middle
to provide an operator
declaration somewhere

00:15:13.056 --> 00:15:13.816 A:middle
in my program.

00:15:14.636 --> 00:15:16.846 A:middle
I could throw a lot of
information up in here in order

00:15:16.846 --> 00:15:20.256 A:middle
to describe how to -- how
this operator associates

00:15:20.256 --> 00:15:22.576 A:middle
with other binary operators, but
in this case I'm not planning

00:15:22.576 --> 00:15:25.916 A:middle
on actually using it next to
any other binary operators.

00:15:25.916 --> 00:15:27.306 A:middle
So all of that is unnecessary.

00:15:27.306 --> 00:15:29.186 A:middle
I can just have a very
simple declaration.

00:15:31.296 --> 00:15:33.196 A:middle
Now let's go back to this
function declaration.

00:15:33.776 --> 00:15:36.926 A:middle
The right hand side of this,
we want it to be an object.

00:15:37.496 --> 00:15:39.096 A:middle
What do we want the
left hand side to be?

00:15:40.546 --> 00:15:42.406 A:middle
Remember that this is the syntax

00:15:42.406 --> 00:15:44.696 A:middle
that we actually want
to be able to write.

00:15:45.506 --> 00:15:48.316 A:middle
Object here is just an arbitrary
expression that's going

00:15:48.316 --> 00:15:50.706 A:middle
to be resolved in global scope.

00:15:51.386 --> 00:15:56.186 A:middle
And we need -- and it's also
going to be an identifier.

00:15:56.186 --> 00:15:59.306 A:middle
It needs to actually resolve
to something in scope.

00:15:59.926 --> 00:16:01.656 A:middle
But we want this to
be usable anywhere,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:59.926 --> 00:16:01.656 A:middle
But we want this to
be usable anywhere,

00:16:01.656 --> 00:16:03.626 A:middle
so this has to be something
that's actually defined

00:16:03.626 --> 00:16:04.526 A:middle
at global scope.

00:16:05.056 --> 00:16:07.186 A:middle
And the most natural thing
to put at global scope

00:16:07.186 --> 00:16:09.466 A:middle
in this case would
just be a function.

00:16:10.296 --> 00:16:14.166 A:middle
By using a function and having
it take the object that was

00:16:14.166 --> 00:16:15.326 A:middle
on the right hand side,

00:16:15.586 --> 00:16:18.906 A:middle
I can make this syntax very
naturally extend to any sort

00:16:18.906 --> 00:16:21.446 A:middle
of declarator that I want to
stick on the left hand side,

00:16:21.536 --> 00:16:25.586 A:middle
I just have to define a new
global function with that name.

00:16:25.586 --> 00:16:29.506 A:middle
The and function we're just
going to implement by using

00:16:29.506 --> 00:16:33.006 A:middle
that name with article property
that we already defined.

00:16:33.756 --> 00:16:38.156 A:middle
With all of that, I can go
back to my operator function

00:16:38.156 --> 00:16:40.556 A:middle
and the left hand side
of this is now going

00:16:40.556 --> 00:16:41.936 A:middle
to be a function value.

00:16:42.506 --> 00:16:43.556 A:middle
And the way that we're going

00:16:43.556 --> 00:16:47.136 A:middle
to implement this is we're just
going to call the function value

00:16:47.826 --> 00:16:50.486 A:middle
with the object that
we will provide it

00:16:50.486 --> 00:16:51.386 A:middle
on the right hand side.

00:16:51.386 --> 00:16:53.296 A:middle
And that's it.

00:16:53.296 --> 00:16:57.056 A:middle
That gives me great -- a great
new idiom for expressing a sort

00:16:57.056 --> 00:16:59.066 A:middle
of decorated interpolated
string.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:00.316 --> 00:17:02.186 A:middle
This isn't something that
you would necessarily want

00:17:02.186 --> 00:17:06.705 A:middle
to use casually, but in my
game it's valuable enough to me

00:17:06.986 --> 00:17:08.425 A:middle
to make this easy to write,

00:17:08.915 --> 00:17:12.925 A:middle
that it's worth forcing
everybody who's reading my code

00:17:12.925 --> 00:17:14.226 A:middle
to learn this new idiom.

00:17:14.746 --> 00:17:17.776 A:middle
I want to work through
one more example.

00:17:18.406 --> 00:17:23.175 A:middle
I talked a lot about
objects in the game,

00:17:23.175 --> 00:17:24.856 A:middle
but I haven't talked
about places.

00:17:25.415 --> 00:17:29.776 A:middle
In the game you're
going to be able

00:17:29.776 --> 00:17:32.206 A:middle
to walk around, visiting
new places.

00:17:32.556 --> 00:17:35.496 A:middle
And all those places are going
to be connected to other places,

00:17:35.586 --> 00:17:37.966 A:middle
by going east, by going
north, by going south.

00:17:39.386 --> 00:17:41.966 A:middle
In our class system, place
is just a special kind

00:17:41.966 --> 00:17:44.526 A:middle
of thing that's going to
also have a dictionary

00:17:44.526 --> 00:17:46.126 A:middle
that describes all
the exits out.

00:17:46.856 --> 00:17:50.466 A:middle
When I'm defining objects, this
is what that's going to look

00:17:50.466 --> 00:17:51.996 A:middle
like as the sort of first pass.

00:17:52.716 --> 00:17:54.786 A:middle
But this is kind of
syntactically heavyweight.

00:17:55.136 --> 00:17:57.746 A:middle
Again, I'm going to have
lots of places in my game.

00:17:57.746 --> 00:18:00.266 A:middle
I'd like this to look really
convenient and natural


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:57.746 --> 00:18:00.266 A:middle
I'd like this to look really
convenient and natural

00:18:00.266 --> 00:18:01.756 A:middle
and more compact than this.

00:18:02.476 --> 00:18:05.846 A:middle
Well, why do I have
to write .exits here?

00:18:06.606 --> 00:18:08.526 A:middle
Isn't the exits dictionary sort

00:18:08.526 --> 00:18:13.646 A:middle
of an implementation
detail of my place class?

00:18:15.296 --> 00:18:19.746 A:middle
Wouldn't it be more natural if
I could just directly subscript

00:18:19.746 --> 00:18:24.936 A:middle
into a place and specify where
a particular exit goes to?

00:18:25.606 --> 00:18:28.366 A:middle
The way that you do that is
with a subscript declaration.

00:18:29.646 --> 00:18:33.126 A:middle
A subscript declaration in Swift
feels a lot like a property.

00:18:33.126 --> 00:18:37.076 A:middle
You use the subscript keyword

00:18:37.076 --> 00:18:42.036 A:middle
and then you give it a parameter
clause, which is kind of like --

00:18:42.196 --> 00:18:43.886 A:middle
which is going to
be all the indexes

00:18:43.886 --> 00:18:46.276 A:middle
that are being used
to subscript in.

00:18:46.276 --> 00:18:51.056 A:middle
And then kind of like a
function you give it a return --

00:18:51.176 --> 00:18:55.046 A:middle
what feels like a return type,
that's the type of the element

00:18:55.676 --> 00:18:56.576 A:middle
that you subscript to.

00:18:58.446 --> 00:19:00.476 A:middle
But here's where it starts
feeling more like a property.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.446 --> 00:19:00.476 A:middle
But here's where it starts
feeling more like a property.

00:19:00.476 --> 00:19:06.426 A:middle
You just provide a get and a set
method like any other property.

00:19:06.976 --> 00:19:09.876 A:middle
So the get is just going
to delegate to exits.

00:19:10.286 --> 00:19:13.866 A:middle
And the set just
writes back into exits.

00:19:13.866 --> 00:19:20.586 A:middle
All I've done here is provide
a subscript directly on place

00:19:20.756 --> 00:19:24.396 A:middle
that just immediately delegates
down to the exits' property.

00:19:25.516 --> 00:19:28.646 A:middle
But that's going to let me write
this in a much more compact

00:19:28.646 --> 00:19:30.596 A:middle
and natural style
over, and over again.

00:19:31.196 --> 00:19:36.756 A:middle
I've been talking a lot about
the ways that you can hook

00:19:36.756 --> 00:19:39.886 A:middle
into the basic syntax of Swift.

00:19:40.066 --> 00:19:41.686 A:middle
I do want to talk a little bit

00:19:41.686 --> 00:19:46.296 A:middle
about when you should
actually do this.

00:19:46.516 --> 00:19:51.526 A:middle
Taking over a basic syntax like
this, developing new idioms,

00:19:51.526 --> 00:19:54.826 A:middle
developing things that don't
look exactly like other things

00:19:54.826 --> 00:19:57.366 A:middle
in Swift can be a
little bit dangerous.

00:19:57.696 --> 00:20:00.066 A:middle
Not in the sense of
being dynamically unsafe,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:57.696 --> 00:20:00.066 A:middle
Not in the sense of
being dynamically unsafe,

00:20:00.416 --> 00:20:02.976 A:middle
but in the sense of making your
code a lot harder to understand.

00:20:03.046 --> 00:20:07.226 A:middle
The key thing to doing this
well is to make it feel natural.

00:20:07.726 --> 00:20:09.526 A:middle
Think about how someone
coming along

00:20:09.526 --> 00:20:11.256 A:middle
and reading your
code later is going

00:20:11.256 --> 00:20:13.876 A:middle
to understand it
sort of intuitively.

00:20:14.606 --> 00:20:17.446 A:middle
Think about what your
syntax actually suggests

00:20:17.446 --> 00:20:20.396 A:middle
about what it's actually doing.

00:20:21.296 --> 00:20:25.786 A:middle
A major part of that means
not taking existing syntax

00:20:25.936 --> 00:20:28.266 A:middle
and making it do
something that doesn't feel

00:20:28.406 --> 00:20:31.046 A:middle
like what other instances
of that syntax are doing.

00:20:31.686 --> 00:20:36.956 A:middle
For example, my subscript is
just sort of providing a view

00:20:37.436 --> 00:20:39.536 A:middle
of an aspect of a place.

00:20:40.396 --> 00:20:41.606 A:middle
You wouldn't want a subscript

00:20:41.606 --> 00:20:43.266 A:middle
to do something completely
different.

00:20:43.666 --> 00:20:46.166 A:middle
You could syntactically,
of course,

00:20:46.216 --> 00:20:49.326 A:middle
the language would let you
use subscript operators

00:20:49.626 --> 00:20:51.166 A:middle
to do anything you want.

00:20:51.166 --> 00:20:54.296 A:middle
You can make it do calls,
you can make it take all

00:20:54.296 --> 00:20:57.286 A:middle
of your methods and implement
them using subscript methods,

00:20:57.526 --> 00:20:59.016 A:middle
but that wouldn't be natural.

00:20:59.436 --> 00:21:04.356 A:middle
It wouldn't feel like
you're really accessing part


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.436 --> 00:21:04.356 A:middle
It wouldn't feel like
you're really accessing part

00:21:04.356 --> 00:21:07.326 A:middle
of the object in a way that
a subscript operator does.

00:21:07.486 --> 00:21:09.526 A:middle
And that's going to
make it a major obstacle

00:21:09.526 --> 00:21:11.736 A:middle
to somebody trying to
actually understand your code.

00:21:13.466 --> 00:21:17.716 A:middle
And finally it's okay to add
new idioms that everybody

00:21:17.716 --> 00:21:19.866 A:middle
who reads your code is
going to have to learn.

00:21:21.256 --> 00:21:23.546 A:middle
People coming into
new code bases have

00:21:23.546 --> 00:21:25.116 A:middle
to learn new idioms anyway even

00:21:25.116 --> 00:21:27.676 A:middle
if they're just expressed
using properties and methods,

00:21:28.856 --> 00:21:33.816 A:middle
but when you're inventing new
idioms using basic syntax,

00:21:34.566 --> 00:21:36.646 A:middle
it has a sort of extra cost.

00:21:36.996 --> 00:21:39.476 A:middle
It's an extra, you
know, thing to learn,

00:21:39.636 --> 00:21:41.566 A:middle
that the programmer
needs to learn just

00:21:41.566 --> 00:21:45.486 A:middle
to understand even what
your code looks like.

00:21:47.326 --> 00:21:51.656 A:middle
That's okay to do -- that's
okay to expect someone to do

00:21:52.046 --> 00:21:53.806 A:middle
if it's actually worthwhile.

00:21:54.566 --> 00:21:57.326 A:middle
Make sure that the syntax
is paying for itself.

00:21:57.546 --> 00:22:00.856 A:middle
That it's worth somebody's time
to have actually learned it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:57.546 --> 00:22:00.856 A:middle
That it's worth somebody's time
to have actually learned it.

00:22:00.856 --> 00:22:02.576 A:middle
And that the value
that you're deriving

00:22:02.576 --> 00:22:07.666 A:middle
from it actually pays for it.

00:22:07.666 --> 00:22:10.866 A:middle
I've been talking a lot
about a bunch of very sort

00:22:11.696 --> 00:22:15.106 A:middle
of superficial ways that
you can extend the language.

00:22:15.106 --> 00:22:16.986 A:middle
I'd like to bring up
Dave Abrahams to bring

00:22:16.986 --> 00:22:20.356 A:middle
up a much deeper and
interesting topic,

00:22:20.766 --> 00:22:21.836 A:middle
which is generic programming .

00:22:22.056 --> 00:22:22.976 A:middle
&gt;&gt; Thanks John.

00:22:23.516 --> 00:22:27.546 A:middle
[ Applause ]

00:22:28.046 --> 00:22:30.386 A:middle
How's everybody doing?

00:22:30.386 --> 00:22:32.496 A:middle
Good? Because we were
a little concerned.

00:22:33.096 --> 00:22:37.736 A:middle
You know. We thought maybe after
three days of total immersion

00:22:37.736 --> 00:22:40.616 A:middle
in Swift you might be
feeling a little uneasy,

00:22:40.616 --> 00:22:42.736 A:middle
maybe a little jittery even,

00:22:43.216 --> 00:22:44.626 A:middle
because you haven't seen
one of these in a while.

00:22:46.666 --> 00:22:48.446 A:middle
So I'm just going to
give you a moment to sit

00:22:48.446 --> 00:22:49.776 A:middle
with it, okay [applause].

00:22:50.536 --> 00:22:51.186 A:middle
Drink it in.

00:22:52.436 --> 00:22:54.236 A:middle
Okay. Because you won't see
another one before the end

00:22:54.236 --> 00:22:54.706 A:middle
of the talk.

00:22:55.496 --> 00:22:59.896 A:middle
And we're going to go to our
first slide in three, two, one.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:02.446 --> 00:23:04.776 A:middle
Sorry semicolon lovers.

00:23:05.516 --> 00:23:08.966 A:middle
Okay so let me tell you a
story about my friend, Crusty.

00:23:10.186 --> 00:23:11.656 A:middle
Crusty is old school.

00:23:12.456 --> 00:23:15.986 A:middle
Programming in Swift is like
his one concession to modernity

00:23:17.036 --> 00:23:21.216 A:middle
and he doesn't trust modern
tools IDEs or debuggers,

00:23:21.616 --> 00:23:25.916 A:middle
no he likes to debug his Swift
code by logging to the console.

00:23:26.436 --> 00:23:29.106 A:middle
He was using a family of
logging functions like this.

00:23:30.196 --> 00:23:33.926 A:middle
Now when he needed to look

00:23:33.926 --> 00:23:36.646 A:middle
at an interesting string
value he would peek String.

00:23:37.586 --> 00:23:39.436 A:middle
And if he wanted to peek at
an interesting int value,

00:23:39.436 --> 00:23:42.306 A:middle
he would peek int and so on.

00:23:42.756 --> 00:23:44.586 A:middle
But it turns out every once

00:23:44.586 --> 00:23:47.566 A:middle
in a while even old Crusty
takes a step into the future.

00:23:48.756 --> 00:23:51.536 A:middle
And one day he strode into
my office and announced

00:23:51.536 --> 00:23:57.806 A:middle
that he had rewritten his
logging to use overloading.

00:23:59.046 --> 00:24:04.996 A:middle
He said to me, "Dave, well Swift
takes a look at the arguments


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.046 --> 00:24:04.996 A:middle
He said to me, "Dave, well Swift
takes a look at the arguments

00:24:04.996 --> 00:24:06.556 A:middle
that I'm actually
passing and figures

00:24:06.556 --> 00:24:08.636 A:middle
out which function
I want to call.

00:24:10.916 --> 00:24:13.886 A:middle
Now I just always write peek
and leave off the type name."

00:24:15.266 --> 00:24:18.916 A:middle
Now I had used overloading
before so, you know,

00:24:19.026 --> 00:24:21.776 A:middle
this wasn't a big deal for me,
but it is kind of a big day

00:24:21.776 --> 00:24:24.756 A:middle
when Crusty changes,
well anything.

00:24:25.656 --> 00:24:28.196 A:middle
So I didn't want to burst
his bubble, you know.

00:24:28.796 --> 00:24:33.366 A:middle
I was about to say something
encouraging when he looked

00:24:33.366 --> 00:24:35.806 A:middle
over my shoulder and said,
"What in tarnation is that?"

00:24:37.446 --> 00:24:38.596 A:middle
And "What," I said.

00:24:39.926 --> 00:24:40.686 A:middle
He said, "That."

00:24:41.706 --> 00:24:44.566 A:middle
Leaving a smudge on my
gorgeous retina display.

00:24:46.516 --> 00:24:50.126 A:middle
[ Applause ]

00:24:50.626 --> 00:24:56.326 A:middle
"Oh Any? Well any is the empty
protocol type," I told him.

00:24:56.326 --> 00:24:57.976 A:middle
"It's got no operations in it,

00:24:58.286 --> 00:25:00.316 A:middle
but it can hold literally
anything.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.286 --> 00:25:00.316 A:middle
but it can hold literally
anything.

00:25:01.366 --> 00:25:05.386 A:middle
And by the time I had
looked up Crusty was gone.

00:25:05.426 --> 00:25:06.696 A:middle
He had run back to his office

00:25:06.696 --> 00:25:10.736 A:middle
to re-implement his
logging functions like this.

00:25:10.916 --> 00:25:14.606 A:middle
Now this version of peek
worked great and it left room

00:25:14.646 --> 00:25:17.106 A:middle
for more code in the
80x24 terminal windows

00:25:17.106 --> 00:25:17.976 A:middle
that crusty favored [laughter].

00:25:21.016 --> 00:25:25.936 A:middle
Also since everything in Swift
can be printed, peek even worked

00:25:26.316 --> 00:25:30.906 A:middle
for some types that Crusty
had never peeked at before.

00:25:31.026 --> 00:25:34.146 A:middle
So all was right with the
world and Crusty was happy.

00:25:34.756 --> 00:25:37.936 A:middle
That is at least until
the doghouse showed

00:25:37.936 --> 00:25:38.986 A:middle
up in his window title.

00:25:40.196 --> 00:25:44.146 A:middle
Now this was a problem because
nothing gets old Crusty's dander

00:25:44.146 --> 00:25:47.166 A:middle
up like pesky emoji
in his window title.

00:25:47.776 --> 00:25:49.426 A:middle
So he said.

00:25:50.336 --> 00:25:53.506 A:middle
See he had written
this fancy extension

00:25:53.506 --> 00:25:55.966 A:middle
on string adding a
computed property

00:25:56.566 --> 00:25:58.536 A:middle
so he could eliminate
these emoji.

00:25:59.126 --> 00:26:02.666 A:middle
And he carefully
used this property


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:59.126 --> 00:26:02.666 A:middle
And he carefully
used this property

00:26:03.656 --> 00:26:06.086 A:middle
in his computation
of the window title.

00:26:07.196 --> 00:26:10.296 A:middle
Crusty scratched his head and
thought about his next moved.

00:26:10.856 --> 00:26:15.466 A:middle
He figured what I
really need to do is see

00:26:15.466 --> 00:26:18.586 A:middle
if the offending characters are
there in the original string.

00:26:19.326 --> 00:26:23.056 A:middle
So I'm going to peek at
that -- that sub expression.

00:26:26.396 --> 00:26:29.546 A:middle
Now normally he might have
rewritten his code like this,

00:26:30.126 --> 00:26:32.346 A:middle
so breaking out the
expression of interest

00:26:32.346 --> 00:26:37.326 A:middle
into a name constant, peeking
at that and then carrying

00:26:37.326 --> 00:26:38.406 A:middle
on with a computation.

00:26:39.986 --> 00:26:42.126 A:middle
But old Crusty had been
in a fix like this before.

00:26:42.776 --> 00:26:44.266 A:middle
He was sick and tired

00:26:44.266 --> 00:26:46.846 A:middle
of reformatting his code
every time he wanted

00:26:46.846 --> 00:26:47.976 A:middle
to do a little debugging work.

00:26:51.506 --> 00:26:53.936 A:middle
"Ah-ha," thought Crusty,
"I know what I'll do.

00:26:54.076 --> 00:26:56.356 A:middle
I'll return the interesting
value from peek

00:26:56.356 --> 00:26:58.906 A:middle
and then I'll be
able to insert a call

00:26:58.906 --> 00:27:00.216 A:middle
to it right in the expression."


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.906 --> 00:27:00.216 A:middle
to it right in the expression."

00:27:01.546 --> 00:27:06.306 A:middle
Which was an awesome idea,
except that doesn't work.

00:27:07.916 --> 00:27:12.286 A:middle
So, you see using Any
throws away the stringiness

00:27:12.476 --> 00:27:13.176 A:middle
of the argument.

00:27:13.726 --> 00:27:17.146 A:middle
So of course the compiler
doesn't know what's coming

00:27:17.146 --> 00:27:18.826 A:middle
out of that peek function.

00:27:20.166 --> 00:27:22.876 A:middle
It could be an NS document
controller delegate,

00:27:23.106 --> 00:27:24.846 A:middle
or it could be an int,
or it could be a string.

00:27:26.486 --> 00:27:30.526 A:middle
At the call site the complier
only sees that signature.

00:27:33.296 --> 00:27:37.866 A:middle
So Crusty knew that he could
always downcast to string

00:27:37.866 --> 00:27:40.756 A:middle
to get his string
back out of the Any.

00:27:41.816 --> 00:27:44.266 A:middle
But if there's one thing
I can say for Crusty,

00:27:44.266 --> 00:27:48.446 A:middle
the man's got taste, you know,
he cannot tolerate ugly code

00:27:48.446 --> 00:27:49.646 A:middle
and this was starting
to get ugly.

00:27:50.186 --> 00:27:54.896 A:middle
That's when Crusty dove into
the Swift language guide

00:27:55.256 --> 00:27:57.666 A:middle
and discovered that the
tiniest change could make all

00:27:57.666 --> 00:27:58.216 A:middle
the difference.

00:27:58.546 --> 00:28:03.606 A:middle
What he did here was turn
peek into a generic function.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:58.546 --> 00:28:03.606 A:middle
What he did here was turn
peek into a generic function.

00:28:04.726 --> 00:28:07.286 A:middle
Now a generic function
is declared

00:28:07.286 --> 00:28:10.836 A:middle
with a type parameter
list in angle brackets

00:28:11.196 --> 00:28:12.406 A:middle
after the base function name.

00:28:13.526 --> 00:28:17.476 A:middle
In this case, there's
just one T.

00:28:18.406 --> 00:28:21.506 A:middle
Now you can thing of T as
a placeholder for any type.

00:28:21.506 --> 00:28:24.276 A:middle
And when you write
a function this way,

00:28:24.456 --> 00:28:27.456 A:middle
Swift deduces what
T is from the type

00:28:27.566 --> 00:28:29.156 A:middle
of the actual argument you pass.

00:28:29.606 --> 00:28:31.276 A:middle
It's a lot like figuring
out which function

00:28:31.276 --> 00:28:32.466 A:middle
to call in an overload set.

00:28:33.366 --> 00:28:36.536 A:middle
In the case above we
passed a string to peek

00:28:36.536 --> 00:28:37.786 A:middle
so peek returns a string.

00:28:38.376 --> 00:28:40.926 A:middle
Not string wrapped in an
any, but good old string.

00:28:42.806 --> 00:28:44.996 A:middle
And it just worked.

00:28:46.506 --> 00:28:49.646 A:middle
Now we've seen two very
different ways to deal

00:28:49.756 --> 00:28:51.666 A:middle
with things of arbitrary type.

00:28:52.806 --> 00:28:56.326 A:middle
We could pass them as instances
of a protocol type like Any

00:28:56.326 --> 00:28:58.136 A:middle
or pullable that
John showed you,

00:28:59.676 --> 00:29:01.146 A:middle
which erases type information.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.676 --> 00:29:01.146 A:middle
which erases type information.

00:29:01.836 --> 00:29:04.956 A:middle
Or we could pass them
as generic parameters,

00:29:05.546 --> 00:29:09.576 A:middle
we could let their types bind
to the generic parameters

00:29:09.576 --> 00:29:12.676 A:middle
of generic functions and that
can serve as type information.

00:29:13.886 --> 00:29:17.336 A:middle
Now there's nothing wrong
with erasing type information

00:29:17.626 --> 00:29:19.796 A:middle
when what you want is
dynamic polymorphism.

00:29:20.216 --> 00:29:23.016 A:middle
So you want to make a
collection of objects

00:29:23.076 --> 00:29:26.336 A:middle
that are all different
types of objects.

00:29:26.936 --> 00:29:29.556 A:middle
And you know that has to
be dynamic at runtime.

00:29:30.446 --> 00:29:32.186 A:middle
Great. Use type eraser.

00:29:32.786 --> 00:29:34.846 A:middle
But when you don't need
dynamic polymorphism,

00:29:35.276 --> 00:29:36.956 A:middle
there's some pretty
compelling upsides

00:29:36.956 --> 00:29:38.326 A:middle
to conserving type information.

00:29:39.346 --> 00:29:42.116 A:middle
So first, when the
compiler keeps track

00:29:42.366 --> 00:29:45.236 A:middle
of what types you're actually
using, you don't have to resort

00:29:45.236 --> 00:29:48.676 A:middle
to unsafe downcasts like we
saw in the previous example.

00:29:49.416 --> 00:29:51.136 A:middle
And you don't have to
deal with the possibility

00:29:51.136 --> 00:29:52.336 A:middle
that those casts might fail.

00:29:52.886 --> 00:29:57.216 A:middle
And second, when the compiler
knows just what types you're

00:29:57.216 --> 00:29:59.986 A:middle
dealing with, it can
generate much better code,

00:29:59.986 --> 00:30:01.976 A:middle
it can generate code
just for those types.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.986 --> 00:30:01.976 A:middle
it can generate code
just for those types.

00:30:02.636 --> 00:30:05.556 A:middle
And John will be talking
more when he comes back

00:30:05.646 --> 00:30:09.546 A:middle
about how the internal
mechanisms work with that.

00:30:11.306 --> 00:30:14.766 A:middle
Another reason to like
conserving type information is

00:30:14.766 --> 00:30:18.616 A:middle
that it allows us to express
relationships among types.

00:30:19.956 --> 00:30:23.216 A:middle
Consider this function,
which comes with Swift.

00:30:23.786 --> 00:30:25.796 A:middle
It just exchanges
two arbitrary values.

00:30:26.796 --> 00:30:30.036 A:middle
Here, X and Y can
have any type at all,

00:30:30.036 --> 00:30:33.186 A:middle
as long as they have
the same type.

00:30:34.036 --> 00:30:38.906 A:middle
So for example student teacher
ratios being what they are,

00:30:38.906 --> 00:30:41.396 A:middle
it might make sense to
exchange the number of students

00:30:41.396 --> 00:30:44.656 A:middle
with the number or teachers,
but exchanging the name

00:30:44.656 --> 00:30:52.976 A:middle
of your school with the number
of students is nonsense.

00:30:53.866 --> 00:30:56.806 A:middle
I love the way Swift helps we
write correct code the first

00:30:56.806 --> 00:30:59.446 A:middle
time because it doesn't
tolerate this kind of stuff.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:00.616 --> 00:31:03.326 A:middle
Note that you can't do
anything like this with Any

00:31:03.326 --> 00:31:07.376 A:middle
or with your similar thing
in Objective-C like ID,

00:31:07.806 --> 00:31:10.296 A:middle
because converting to
these types throws away the

00:31:10.296 --> 00:31:11.066 A:middle
type information.

00:31:11.566 --> 00:31:12.766 A:middle
It takes real generics,

00:31:13.306 --> 00:31:16.006 A:middle
which conserve type
information to get this right.

00:31:17.366 --> 00:31:19.896 A:middle
Okay let's look at a
more interesting example.

00:31:21.976 --> 00:31:25.356 A:middle
Here's a simple function that
takes an array of strings,

00:31:25.356 --> 00:31:30.096 A:middle
iterates through the indices in
the array, looking for an index

00:31:30.096 --> 00:31:32.756 A:middle
where there's a string that
matches the one that you passed.

00:31:33.676 --> 00:31:35.796 A:middle
And if it finds it,
it returns the index,

00:31:36.316 --> 00:31:37.326 A:middle
otherwise it returns nil.

00:31:38.006 --> 00:31:41.686 A:middle
Right? It's returning
an optional.

00:31:41.816 --> 00:31:44.346 A:middle
Okay so let's generalize this.

00:31:45.616 --> 00:31:48.836 A:middle
First we just find the
concrete types that we want

00:31:48.836 --> 00:31:52.336 A:middle
to make variable, string
and we replace those

00:31:52.336 --> 00:31:53.316 A:middle
with generic parameters.

00:31:53.846 --> 00:31:59.636 A:middle
But it's not quite that simple.

00:31:59.756 --> 00:32:03.916 A:middle
Right, now that T is no longer
a known type like string.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:59.756 --> 00:32:03.916 A:middle
Right, now that T is no longer
a known type like string.

00:32:04.296 --> 00:32:06.076 A:middle
The compiler isn't entirely sure

00:32:06.076 --> 00:32:08.986 A:middle
that we can compare these
two things with equal equal.

00:32:09.996 --> 00:32:14.586 A:middle
So let's fix that by
constraining T to be equatable.

00:32:18.416 --> 00:32:21.736 A:middle
See, the function signature
already imposed one type

00:32:21.736 --> 00:32:23.266 A:middle
constraint, that the type

00:32:23.266 --> 00:32:28.386 A:middle
of value matched the
element type of the array.

00:32:28.386 --> 00:32:30.336 A:middle
Equatable adds another
kind of type constraint

00:32:30.896 --> 00:32:32.146 A:middle
for callers to find value.

00:32:32.516 --> 00:32:34.536 A:middle
And in exchange for
constraining callers,

00:32:34.976 --> 00:32:37.516 A:middle
now we have a new
capability inside of the body,

00:32:37.896 --> 00:32:39.706 A:middle
which is to compare
with equal equal.

00:32:40.276 --> 00:32:43.776 A:middle
All right let's see how
equatable is compared.

00:32:45.876 --> 00:32:47.626 A:middle
Of course equatable
is a protocol,

00:32:49.066 --> 00:32:52.266 A:middle
a blueprint for type
as John put it.

00:32:52.586 --> 00:32:54.496 A:middle
Now this one imposes
a single requirement

00:32:54.496 --> 00:32:55.916 A:middle
that there's an equal
equal operator.

00:32:56.476 --> 00:33:00.176 A:middle
If you're familiar with
protocols in Objective-C,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:56.476 --> 00:33:00.176 A:middle
If you're familiar with
protocols in Objective-C,

00:33:00.736 --> 00:33:04.116 A:middle
it may help to know that every
single Objective-C protocol is

00:33:04.116 --> 00:33:05.246 A:middle
also a Swift protocol.

00:33:06.496 --> 00:33:09.656 A:middle
However, Swift protocols
have some capabilities

00:33:09.656 --> 00:33:11.196 A:middle
that Objective-C
protocols don't,

00:33:11.606 --> 00:33:14.366 A:middle
which makes them especially
well-suited to generic program.

00:33:15.856 --> 00:33:20.136 A:middle
Case in point, because
Swift generics conserve type

00:33:20.136 --> 00:33:22.146 A:middle
information, they have access

00:33:22.146 --> 00:33:24.766 A:middle
to the full type
implementing Any protocol.

00:33:25.756 --> 00:33:28.476 A:middle
Here we're saying that there
must be an equality operator

00:33:28.476 --> 00:33:31.856 A:middle
that takes two instances of the
type implementing equatable.

00:33:32.366 --> 00:33:37.016 A:middle
Note that some popular languages
implement what they call

00:33:37.016 --> 00:33:41.596 A:middle
generics with type eraser,
essentially Any plus downcasts.

00:33:42.436 --> 00:33:45.226 A:middle
And because these languages
throw type information away,

00:33:45.686 --> 00:33:48.506 A:middle
they're unable to express
even something as fundamental

00:33:48.506 --> 00:33:50.826 A:middle
and basic as this in
their generic system.

00:33:51.146 --> 00:33:52.706 A:middle
But Swift handles
it beautifully.

00:33:52.706 --> 00:33:55.806 A:middle
All right now let's quickly --

00:33:56.296 --> 00:33:56.966 A:middle
Thank you very much.

00:33:57.516 --> 00:34:01.126 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:57.516 --> 00:34:01.126 A:middle
[ Applause ]

00:34:01.626 --> 00:34:04.926 A:middle
Now let's quickly make
an equatable type.

00:34:05.796 --> 00:34:11.056 A:middle
So temperature here is just a
little wrapper over and int.

00:34:11.056 --> 00:34:13.025 A:middle
And there's a couple
of things to notice.

00:34:13.025 --> 00:34:14.926 A:middle
First temperature is a struct.

00:34:15.616 --> 00:34:20.366 A:middle
Protocol adoption is available
to structs, enums, and classes.

00:34:20.366 --> 00:34:22.176 A:middle
Not just classes
as an Objective-C.

00:34:23.646 --> 00:34:28.056 A:middle
Second of all, we've satisfied
its operator requirement outside

00:34:28.056 --> 00:34:32.436 A:middle
the type body and
that's sort of specific

00:34:32.436 --> 00:34:34.126 A:middle
to operator requirements.

00:34:34.416 --> 00:34:37.196 A:middle
All other requirements you'll
find satisfied inside the type

00:34:37.226 --> 00:34:38.966 A:middle
body or inside an extension.

00:34:41.936 --> 00:34:47.096 A:middle
Okay. So you may be wondering,
well where's not equal.

00:34:48.246 --> 00:34:51.826 A:middle
Well it's not a requirement,
we didn't have to write it,

00:34:52.176 --> 00:34:53.636 A:middle
because Swift provides this one.

00:34:54.436 --> 00:35:00.256 A:middle
It's a generic not equal
that depends on equatable


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:54.436 --> 00:35:00.256 A:middle
It's a generic not equal
that depends on equatable

00:35:01.256 --> 00:35:04.246 A:middle
and uses the equal equal
operator to implement it.

00:35:04.976 --> 00:35:07.176 A:middle
So that works for
every equatable type,

00:35:07.346 --> 00:35:08.616 A:middle
which is pretty Swift indeed.

00:35:09.516 --> 00:35:14.886 A:middle
[ Applause ]

00:35:15.386 --> 00:35:18.096 A:middle
Okay let's look at an example

00:35:18.096 --> 00:35:20.016 A:middle
of how we can use what
we've seen so far.

00:35:20.686 --> 00:35:23.636 A:middle
Now I wanted to come up with
a really practical example.

00:35:23.956 --> 00:35:27.106 A:middle
Something that, you know, you
would use in your day to day

00:35:27.106 --> 00:35:28.056 A:middle
in your Cocoa programming.

00:35:28.476 --> 00:35:31.506 A:middle
So what we're going to be doing
is computing phi the Golden

00:35:31.506 --> 00:35:37.296 A:middle
Mean, which is the ratio of
consecutive Fibonacci numbers

00:35:37.296 --> 00:35:38.746 A:middle
as N approaches infinity.

00:35:40.126 --> 00:35:42.666 A:middle
The slide warned you that we
were horrible nerds right?

00:35:43.796 --> 00:35:50.126 A:middle
Okay. So first we need to
computer the N Fibonacci number.

00:35:50.706 --> 00:35:56.176 A:middle
So that's just the sum of the
previous two Fibonacci numbers

00:35:56.656 --> 00:35:59.216 A:middle
where the first two Fibonacci
numbers are zero and 1.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:00.436 --> 00:36:02.156 A:middle
Okay, this is not
the fastest way

00:36:02.156 --> 00:36:05.716 A:middle
to compute the Fibonacci
numbers, but it is really hard

00:36:05.716 --> 00:36:07.066 A:middle
to beat for its simplicity,

00:36:07.066 --> 00:36:08.886 A:middle
and mathematical
purity, and elegance.

00:36:09.436 --> 00:36:11.506 A:middle
It's really easy to verify

00:36:11.506 --> 00:36:13.086 A:middle
that this does exactly
the right thing.

00:36:15.876 --> 00:36:16.416 A:middle
And here's phi.

00:36:16.416 --> 00:36:21.296 A:middle
We need to go a few
iterations right up to about 45

00:36:21.296 --> 00:36:23.656 A:middle
so that we get enough
precision with our estimate.

00:36:25.116 --> 00:36:29.556 A:middle
Now running this part of our
program takes 11 seconds,

00:36:30.776 --> 00:36:33.316 A:middle
11 seconds on a fast machine.

00:36:34.416 --> 00:36:38.336 A:middle
Well it's easy to see why if
you look at the call graph.

00:36:39.096 --> 00:36:42.926 A:middle
So just looking at
Fibonacci at 5, that depends

00:36:42.926 --> 00:36:44.826 A:middle
on Fibonacci of 4 and 3.

00:36:45.696 --> 00:36:50.206 A:middle
And Fibonacci of 4 depends
on Fibonacci of 3 and 2.

00:36:50.206 --> 00:36:51.516 A:middle
And you can already start to see

00:36:51.516 --> 00:36:53.356 A:middle
that it repeated
computations in here.

00:36:53.816 --> 00:36:55.516 A:middle
And if you look at
the entire call graph,

00:36:55.946 --> 00:36:57.826 A:middle
well you can see there's
a lot of repetition.

00:36:58.706 --> 00:37:01.136 A:middle
Now expand this up 45 levels


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.706 --> 00:37:01.136 A:middle
Now expand this up 45 levels

00:37:01.796 --> 00:37:06.236 A:middle
and you've got a recipe
for a slow program.

00:37:07.636 --> 00:37:11.286 A:middle
However, if we could
just store our results

00:37:11.286 --> 00:37:13.416 A:middle
in a dictionary the first
time we compute them,

00:37:14.896 --> 00:37:19.146 A:middle
then we could turn all of these
calls into fast lookups, right.

00:37:19.936 --> 00:37:23.966 A:middle
And these calls well they
would just disappear entirely.

00:37:24.486 --> 00:37:28.206 A:middle
This technique is
called memoization.

00:37:28.626 --> 00:37:31.396 A:middle
And while Fibonacci makes
a great example for it

00:37:31.396 --> 00:37:33.906 A:middle
because it -- you know,
recalls the same function over,

00:37:33.906 --> 00:37:34.306 A:middle
and over.

00:37:34.626 --> 00:37:38.496 A:middle
You can apply it to speed
up any pure function

00:37:39.026 --> 00:37:40.666 A:middle
where you might be
calling it over,

00:37:40.666 --> 00:37:42.596 A:middle
and over with the same
sets of arguments.

00:37:45.326 --> 00:37:49.346 A:middle
Okay let's manually
memoize Fibonacci, okay.

00:37:49.836 --> 00:37:53.996 A:middle
First we need a dictionary.

00:37:54.036 --> 00:37:58.286 A:middle
Next we change the function body
so that it checks the dictionary

00:37:58.286 --> 00:38:01.686 A:middle
to see if it's got the result
and only computes the result


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.286 --> 00:38:01.686 A:middle
to see if it's got the result
and only computes the result

00:38:01.686 --> 00:38:05.036 A:middle
if it isn't found there.

00:38:05.256 --> 00:38:08.316 A:middle
Now how does our
function perform?

00:38:08.426 --> 00:38:11.246 A:middle
Okay 100x speedup,
that's pretty good.

00:38:11.246 --> 00:38:15.296 A:middle
It's 100 times more
Swift, okay [applause].

00:38:16.016 --> 00:38:17.956 A:middle
Please forgive me,
please forgive me.

00:38:19.856 --> 00:38:21.936 A:middle
Now this is awesome,
but we've kind

00:38:21.936 --> 00:38:23.596 A:middle
of destroyed the readability

00:38:23.786 --> 00:38:25.826 A:middle
and mathematical
purity of our function.

00:38:26.376 --> 00:38:29.056 A:middle
I mean, if you look in there
really hard you might be able

00:38:29.056 --> 00:38:33.346 A:middle
to find the original computation
among all of that boilerplate.

00:38:33.526 --> 00:38:35.896 A:middle
There it is.

00:38:35.896 --> 00:38:38.986 A:middle
It would be nice if we
could encapsulate all

00:38:38.986 --> 00:38:40.546 A:middle
of that road code transformation

00:38:40.986 --> 00:38:43.366 A:middle
so we could easily
memoize any function

00:38:43.986 --> 00:38:45.366 A:middle
without destroying
its readability.

00:38:45.876 --> 00:38:49.106 A:middle
Something like this.

00:38:49.326 --> 00:38:50.846 A:middle
Well in Swift, you can.

00:38:51.416 --> 00:38:55.416 A:middle
In fact memoize isn't
in the language,

00:38:56.596 --> 00:38:58.136 A:middle
it's just a generic
function I wrote.

00:38:58.646 --> 00:39:03.546 A:middle
And the code between the
curlies, well that's a closure


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.646 --> 00:39:03.546 A:middle
And the code between the
curlies, well that's a closure

00:39:03.846 --> 00:39:07.756 A:middle
or an anonymous function being
passed as an argument to memoize

00:39:08.056 --> 00:39:10.046 A:middle
with trailing closure syntax.

00:39:11.216 --> 00:39:14.296 A:middle
Memoize returns another closure

00:39:15.356 --> 00:39:18.826 A:middle
and that's what we're
storing in Fibonacci.

00:39:18.826 --> 00:39:20.956 A:middle
So Fibonacci's just
like a function.

00:39:20.956 --> 00:39:24.386 A:middle
You know a regular function
is just a constant bound

00:39:25.136 --> 00:39:26.266 A:middle
to a closure.

00:39:27.476 --> 00:39:29.956 A:middle
So in fact you don't even
need that type annotation

00:39:29.956 --> 00:39:33.786 A:middle
in this case because Swift type
inference can figure it all

00:39:33.786 --> 00:39:34.266 A:middle
out for you.

00:39:35.306 --> 00:39:37.306 A:middle
And now memoize is general.

00:39:38.076 --> 00:39:42.086 A:middle
So when I discover that my
app is bleeding CPU cycles

00:39:42.136 --> 00:39:45.976 A:middle
by parsing the same
property list strings over

00:39:45.976 --> 00:39:47.966 A:middle
and over again I can go back

00:39:47.966 --> 00:39:52.816 A:middle
and use memoize again,
just like this.

00:39:53.036 --> 00:39:54.876 A:middle
Okay let me show
you how this works.

00:39:55.446 --> 00:39:59.776 A:middle
So this is a first cut at
a memoization function.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:01.466 --> 00:40:02.176 A:middle
A simple version.

00:40:03.006 --> 00:40:05.236 A:middle
All right, yes I know it
doesn't look that simple,

00:40:05.296 --> 00:40:06.706 A:middle
but I'll take it apart for you.

00:40:07.466 --> 00:40:10.686 A:middle
So it takes one parameter
called body

00:40:11.406 --> 00:40:13.156 A:middle
which is the closure, right?

00:40:14.076 --> 00:40:16.626 A:middle
And the types, the
argument and return types

00:40:16.626 --> 00:40:18.936 A:middle
of that closure are
arbitrary except

00:40:18.936 --> 00:40:20.746 A:middle
that there's this constraint

00:40:21.526 --> 00:40:23.186 A:middle
on the argument type
that it be hashable.

00:40:24.416 --> 00:40:25.356 A:middle
Why do we need that?

00:40:25.516 --> 00:40:28.606 A:middle
Well so we can use the argument
type as a key in the dictionary.

00:40:30.526 --> 00:40:34.456 A:middle
Right? And it returns the same
type of closure that it gets.

00:40:37.166 --> 00:40:41.536 A:middle
Okay. Inside the body this is
actually pretty straightforward.

00:40:42.076 --> 00:40:44.726 A:middle
So first we create the
dictionary that we're going

00:40:44.726 --> 00:40:46.356 A:middle
to need to use to
memoize that function.

00:40:48.316 --> 00:40:51.796 A:middle
And then we return a
closure which is wrapped

00:40:51.796 --> 00:40:56.346 A:middle
around an invocation of the body
which is the actual computation,

00:40:56.616 --> 00:40:58.996 A:middle
right, and the usual
memoization dance.

00:40:59.526 --> 00:41:02.286 A:middle
Where we look in the dictionary
and return the value we found


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:59.526 --> 00:41:02.286 A:middle
Where we look in the dictionary
and return the value we found

00:41:02.286 --> 00:41:04.476 A:middle
if we found it, otherwise
compute

00:41:04.476 --> 00:41:05.776 A:middle
and put it in the dictionary.

00:41:07.366 --> 00:41:10.586 A:middle
Okay. Now this version
of memoize works great

00:41:11.246 --> 00:41:13.836 A:middle
for functions like
parse property list.

00:41:15.216 --> 00:41:17.376 A:middle
This just works,
which is awesome,

00:41:17.706 --> 00:41:21.056 A:middle
but for recursive
functions, like factorial,

00:41:21.366 --> 00:41:24.806 A:middle
or Fibonacci, well not so much.

00:41:25.696 --> 00:41:27.816 A:middle
You see Swift doesn't want us

00:41:27.846 --> 00:41:33.436 A:middle
to use a variable's only
value to initialize it.

00:41:33.676 --> 00:41:36.186 A:middle
Like initialize itself
in terms of itself.

00:41:36.186 --> 00:41:37.996 A:middle
That just doesn't
make sense, right,

00:41:38.326 --> 00:41:40.346 A:middle
it's usually a terrible
programming error.

00:41:41.016 --> 00:41:43.766 A:middle
So what can we do
to get out of this?

00:41:43.966 --> 00:41:47.016 A:middle
Well we could do this
two-phase initialization dance.

00:41:48.576 --> 00:41:52.376 A:middle
Here what we've done is we've
made factorial a variable.

00:41:52.956 --> 00:41:55.006 A:middle
And we've initialized it
with something throwaway

00:41:55.006 --> 00:41:57.216 A:middle
like the identity
function, right?

00:41:57.396 --> 00:42:00.176 A:middle
Dollar zero in braces just
returns the argument it gets.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:57.396 --> 00:42:00.176 A:middle
Dollar zero in braces just
returns the argument it gets.

00:42:01.316 --> 00:42:03.496 A:middle
And then we reassign
factorial to memoize.

00:42:04.016 --> 00:42:09.746 A:middle
Okay this works, but
it's got a few downsides.

00:42:09.746 --> 00:42:12.296 A:middle
First of all, it's ugly
so Crusty's not going

00:42:12.296 --> 00:42:13.896 A:middle
to be happy with us, right.

00:42:14.366 --> 00:42:16.286 A:middle
Second of all we had to write

00:42:16.286 --> 00:42:19.396 A:middle
out the explicit type
annotation, that Int arrow Int.

00:42:20.176 --> 00:42:22.266 A:middle
And that used to
be deduced for us.

00:42:22.716 --> 00:42:27.246 A:middle
But most importantly of all,
it makes factorial mutable,

00:42:27.536 --> 00:42:28.566 A:middle
which we didn't intend.

00:42:29.456 --> 00:42:32.606 A:middle
And keeping things immutable
as often as possible is a,

00:42:32.996 --> 00:42:36.596 A:middle
you know, is a great path toward
correctness and easy to reason

00:42:36.596 --> 00:42:40.006 A:middle
about programs and all kinds of
things, including thread safety.

00:42:41.426 --> 00:42:43.746 A:middle
So fortunately, there's
a better way.

00:42:45.836 --> 00:42:46.896 A:middle
Ready for take two?

00:42:47.526 --> 00:42:49.316 A:middle
I'm going to warn you in advance

00:42:49.636 --> 00:42:52.626 A:middle
that this is a little
bit mind blowing, okay?

00:42:52.626 --> 00:42:55.166 A:middle
If your mind's not
already blown.

00:42:56.216 --> 00:43:00.736 A:middle
So let's just have
memoize pass factorial


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:56.216 --> 00:43:00.736 A:middle
So let's just have
memoize pass factorial

00:43:01.186 --> 00:43:03.446 A:middle
as an argument to its own body.

00:43:04.706 --> 00:43:11.796 A:middle
Right? Okay but stick with
me you'll get it, okay.

00:43:12.396 --> 00:43:16.716 A:middle
So if we can pass factorial in
it as an argument to this body,

00:43:17.206 --> 00:43:18.956 A:middle
then that factorial
on the right,

00:43:18.956 --> 00:43:23.216 A:middle
well that refers just back
to the function parameter.

00:43:23.216 --> 00:43:26.996 A:middle
It's just like referring to X.

00:43:27.236 --> 00:43:31.956 A:middle
See now our closure has two
parameters, a function and X.

00:43:33.056 --> 00:43:37.976 A:middle
All right so what do we need
to do to make this happen?

00:43:38.166 --> 00:43:42.616 A:middle
Well first we need an additional
parameter to body right.

00:43:42.616 --> 00:43:44.746 A:middle
You can see body is
taking now a new parameter.

00:43:45.856 --> 00:43:47.476 A:middle
And that parameter
has the same type

00:43:47.476 --> 00:43:49.076 A:middle
as we're returning for memoize.

00:43:49.916 --> 00:43:53.616 A:middle
Whoa lots of arrow.

00:43:53.616 --> 00:43:55.506 A:middle
Everybody okay?

00:43:56.056 --> 00:43:57.546 A:middle
Okay. I'm sorry.

00:43:58.236 --> 00:44:01.286 A:middle
Next -- it will get easy again.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.236 --> 00:44:01.286 A:middle
Next -- it will get easy again.

00:44:02.266 --> 00:44:08.746 A:middle
Next, we do the two-phase
initialization dance.

00:44:08.906 --> 00:44:12.266 A:middle
So here we can't really get

00:44:12.266 --> 00:44:14.626 A:middle
out of the two-phase
initialization problem,

00:44:14.656 --> 00:44:17.296 A:middle
but at least we can hide
it inside of memoize.

00:44:18.256 --> 00:44:20.646 A:middle
And two-phase initialization
scenarios

00:44:20.646 --> 00:44:23.476 A:middle
like this one are
a great application

00:44:23.626 --> 00:44:25.236 A:middle
for implicitly unwrapped
optionals.

00:44:25.956 --> 00:44:28.886 A:middle
Because right, once you've
initialized the thing,

00:44:28.986 --> 00:44:30.586 A:middle
after that the thing
can never be nil.

00:44:30.586 --> 00:44:32.596 A:middle
So there's no point
in going through all

00:44:32.596 --> 00:44:34.896 A:middle
that syntactic baggage
of unwrapping it.

00:44:35.426 --> 00:44:39.486 A:middle
And in this case, the implicitly
unwrapped optional unwraps

00:44:39.486 --> 00:44:41.596 A:middle
when we return it as
a non-optional, right.

00:44:42.766 --> 00:44:44.996 A:middle
And because it dies at
the end of this scope,

00:44:45.606 --> 00:44:48.956 A:middle
well any scary possibilities of
it being nil die along with it.

00:44:49.876 --> 00:44:54.326 A:middle
So this is actually
pretty elegant.

00:44:54.406 --> 00:44:58.016 A:middle
Now all that remains is
to pass result to the body

00:44:58.376 --> 00:45:01.366 A:middle
when it's invoked and
there you have it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.376 --> 00:45:01.366 A:middle
when it's invoked and
there you have it.

00:45:02.996 --> 00:45:06.696 A:middle
A reusable tool that
elegantly memoizes even

00:45:06.696 --> 00:45:07.516 A:middle
recursive functions.

00:45:08.516 --> 00:45:14.876 A:middle
[ Applause ]

00:45:15.376 --> 00:45:17.796 A:middle
Now the point of course is not
that you're going to go out

00:45:17.796 --> 00:45:19.226 A:middle
and memoize all your functions,

00:45:19.676 --> 00:45:21.496 A:middle
but that you can do
stuff like this in Swift.

00:45:22.076 --> 00:45:24.866 A:middle
You can write your
own modifying,

00:45:25.046 --> 00:45:27.226 A:middle
crazy language extension-type
functions like this.

00:45:28.126 --> 00:45:28.896 A:middle
And it's pretty cool.

00:45:30.056 --> 00:45:34.336 A:middle
So being able to do this
relied on the synergy

00:45:34.336 --> 00:45:36.466 A:middle
of three powerful features.

00:45:37.376 --> 00:45:40.786 A:middle
First, type deduction
for concision,

00:45:40.936 --> 00:45:43.726 A:middle
so we would have contact
and readable code.

00:45:44.306 --> 00:45:47.906 A:middle
Next, trailing closure syntax,

00:45:48.776 --> 00:45:52.276 A:middle
which evokes control flow
while supporting functional

00:45:52.326 --> 00:45:53.706 A:middle
programming idioms.

00:45:54.446 --> 00:45:58.186 A:middle
And lastly, truly
generic functions

00:45:58.656 --> 00:46:03.266 A:middle
that are flexible,
safe, and fast.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:58.656 --> 00:46:03.266 A:middle
that are flexible,
safe, and fast.

00:46:04.656 --> 00:46:06.756 A:middle
Okay. Now I want to
bring it back down

00:46:06.836 --> 00:46:09.456 A:middle
and talk a little bit
about generic types.

00:46:10.916 --> 00:46:13.936 A:middle
So you've already seen a bunch
of generic types yourself.

00:46:14.516 --> 00:46:17.436 A:middle
Arrays in Swift are
just generic structs

00:46:17.746 --> 00:46:19.096 A:middle
and so are our dictionaries.

00:46:19.826 --> 00:46:21.736 A:middle
And optionals are
just generic enums.

00:46:22.136 --> 00:46:24.536 A:middle
And if you've watched
the other presentations,

00:46:24.536 --> 00:46:25.326 A:middle
I know that was covered.

00:46:26.496 --> 00:46:28.216 A:middle
You can also make
generic classes in Swift.

00:46:28.706 --> 00:46:31.066 A:middle
Let's make a generic struct.

00:46:32.716 --> 00:46:35.386 A:middle
So we'll start with a
simple concrete struct,

00:46:35.826 --> 00:46:37.706 A:middle
concrete stack of strings.

00:46:38.916 --> 00:46:40.286 A:middle
It's got push and pop methods

00:46:40.286 --> 00:46:42.496 A:middle
and it's just implemented
in terms of an array.

00:46:43.796 --> 00:46:45.466 A:middle
Now let's make this into
a stack of any type.

00:46:46.196 --> 00:46:50.226 A:middle
We just do what we did
with our generic functions.

00:46:50.296 --> 00:46:51.936 A:middle
When we made a concrete
function generic,

00:46:52.256 --> 00:46:53.966 A:middle
we took the concrete
types and replaced them

00:46:53.966 --> 00:46:57.406 A:middle
with a type parameter,
and there you have it.

00:46:58.076 --> 00:47:02.976 A:middle
Now I can make a stack
of Ints or a stack


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:58.076 --> 00:47:02.976 A:middle
Now I can make a stack
of Ints or a stack

00:47:02.976 --> 00:47:04.806 A:middle
of NSWindows if I like.

00:47:05.616 --> 00:47:08.686 A:middle
So notice that unlike
with generic functions,

00:47:09.016 --> 00:47:14.166 A:middle
when you use a generic type
you actually supply the type

00:47:14.436 --> 00:47:16.286 A:middle
arguments explicitly
most of the time.

00:47:17.116 --> 00:47:19.506 A:middle
With functions the type
arguments are always deduced.

00:47:20.026 --> 00:47:25.326 A:middle
Now Crusty probably wants
to be able to log our stack.

00:47:25.956 --> 00:47:29.466 A:middle
And he would probably write
his logging function like this.

00:47:30.736 --> 00:47:32.946 A:middle
But unfortunately
that's not going to work.

00:47:33.756 --> 00:47:36.556 A:middle
It's not going to work
because the for Int syntax

00:47:36.556 --> 00:47:39.786 A:middle
as John mentioned is governed
by this sequence protocol

00:47:39.786 --> 00:47:40.806 A:middle
and we haven't implemented it.

00:47:41.356 --> 00:47:42.846 A:middle
So let's take a look
under the hood

00:47:43.236 --> 00:47:45.576 A:middle
at how Swift does
for...in loops.

00:47:46.526 --> 00:47:48.486 A:middle
So when you write
a loop like this,

00:47:49.376 --> 00:47:53.026 A:middle
Swift internally rewrites
your code like this.

00:47:53.026 --> 00:47:55.696 A:middle
So what's happening here?

00:47:56.406 --> 00:47:59.336 A:middle
First it goes to your
sequence and it calls generate,

00:47:59.636 --> 00:48:00.616 A:middle
to get a generator out.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:47:59.636 --> 00:48:00.616 A:middle
to get a generator out.

00:48:01.066 --> 00:48:07.296 A:middle
Next, it repeatedly
calls the next function

00:48:07.296 --> 00:48:09.846 A:middle
on your generator
until it gets nil.

00:48:10.126 --> 00:48:11.876 A:middle
So next returns an optional.

00:48:12.326 --> 00:48:14.706 A:middle
And those optionals are
filled in with values

00:48:14.706 --> 00:48:15.856 A:middle
until the sequence runs out.

00:48:16.476 --> 00:48:18.976 A:middle
Okay so what is this
generator thing?

00:48:19.476 --> 00:48:20.426 A:middle
I'm sure you can guess.

00:48:21.276 --> 00:48:23.996 A:middle
It's a protocol, okay.

00:48:24.356 --> 00:48:25.756 A:middle
And the first thing you see

00:48:25.756 --> 00:48:28.316 A:middle
in this protocol
is this type alias.

00:48:29.576 --> 00:48:31.906 A:middle
Now when you see a type
alias in a protocol,

00:48:32.536 --> 00:48:35.076 A:middle
that's called an
associated type requirement.

00:48:37.476 --> 00:48:39.136 A:middle
Okay, it can be satisfied just

00:48:39.136 --> 00:48:43.426 A:middle
by writing any nested type
called element inside your

00:48:43.726 --> 00:48:46.276 A:middle
generator, but why
do we do this?

00:48:46.496 --> 00:48:49.586 A:middle
Well it's usually a type
that's involved in one

00:48:49.716 --> 00:48:51.626 A:middle
of the protocol other
requirements,

00:48:51.626 --> 00:48:52.906 A:middle
in this case, Next.

00:48:53.406 --> 00:48:55.656 A:middle
You have to express that,
you know, here's a name

00:48:55.726 --> 00:48:59.816 A:middle
for a type that's going
to come out of Next.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:00.706 --> 00:49:03.126 A:middle
So let's build a
generator for stack.

00:49:05.086 --> 00:49:05.856 A:middle
Here's the code.

00:49:07.376 --> 00:49:11.356 A:middle
So it's just another
generic struct, right.

00:49:11.446 --> 00:49:12.686 A:middle
It conforms to generator.

00:49:13.286 --> 00:49:17.556 A:middle
And you can see that it
implements all the necessary

00:49:17.556 --> 00:49:19.316 A:middle
parts of the blueprint here.

00:49:19.906 --> 00:49:24.366 A:middle
Now we've written a
little bit more here

00:49:24.366 --> 00:49:25.506 A:middle
than we actually had to.

00:49:26.256 --> 00:49:31.236 A:middle
See when the compiler matches
up that next requirement

00:49:31.676 --> 00:49:32.796 A:middle
with this Next function,

00:49:33.416 --> 00:49:38.046 A:middle
it can see that the
element type has to be T.

00:49:38.376 --> 00:49:40.716 A:middle
So that associated
type is deduced

00:49:40.716 --> 00:49:44.706 A:middle
and we can just leave it out.

00:49:44.986 --> 00:49:45.996 A:middle
That gets really convenient.

00:49:47.266 --> 00:49:48.996 A:middle
The next thing I
need to point out is

00:49:48.996 --> 00:49:50.396 A:middle
that we've used this Slice type.

00:49:50.936 --> 00:49:54.716 A:middle
So Slice is a lot like array, in
fact you make them from arrays

00:49:54.716 --> 00:49:57.296 A:middle
by slicing the array
using this syntax.

00:49:57.716 --> 00:49:59.736 A:middle
So you pass a range to
the subscript operator.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:00.346 --> 00:50:02.826 A:middle
And Slice differs from array

00:50:02.826 --> 00:50:05.186 A:middle
in that you can efficiently
drop things off the front

00:50:05.186 --> 00:50:07.466 A:middle
of the Slice in order one time.

00:50:08.046 --> 00:50:10.186 A:middle
So that's why we're using it
because we want to go forward

00:50:10.186 --> 00:50:10.976 A:middle
through this sequence.

00:50:12.006 --> 00:50:14.246 A:middle
So, what do we do?

00:50:14.246 --> 00:50:16.006 A:middle
First we check to see
if the Slice is empty,

00:50:16.306 --> 00:50:17.446 A:middle
if it is we return nil,

00:50:18.286 --> 00:50:20.086 A:middle
otherwise we get the
first item off the Slice.

00:50:20.846 --> 00:50:25.236 A:middle
Replace the Slice with the rest
of the elements and return.

00:50:26.686 --> 00:50:27.886 A:middle
And there's our complete
generator.

00:50:28.446 --> 00:50:32.966 A:middle
But we're not done yet because
we haven't implemented sequence.

00:50:33.766 --> 00:50:36.036 A:middle
Right, this is a
two-protocol, protocol.

00:50:38.046 --> 00:50:40.866 A:middle
So sequence has a very similar
structure to that of generator.

00:50:42.436 --> 00:50:44.006 A:middle
The most notable difference is

00:50:44.176 --> 00:50:47.186 A:middle
that its associated
type is constrained here

00:50:47.186 --> 00:50:50.306 A:middle
to be a generator and
that's how Swift knows

00:50:50.306 --> 00:50:53.946 A:middle
that it can call next on the
thing that gets out of generate.

00:50:54.536 --> 00:50:59.626 A:middle
Okay, so let's implement
sequence for our stack.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:01.496 --> 00:51:02.346 A:middle
Here it is.

00:51:03.336 --> 00:51:06.936 A:middle
Notice first that I've done the
entire implementation inside an

00:51:06.936 --> 00:51:09.606 A:middle
extension that's
dedicated to that protocol.

00:51:09.606 --> 00:51:11.776 A:middle
And this is a really slick way

00:51:11.776 --> 00:51:14.766 A:middle
to partition your code
especially if you have a lot

00:51:14.766 --> 00:51:15.966 A:middle
of protocol conformances.

00:51:16.386 --> 00:51:18.346 A:middle
And that's going to be
pretty common in Swift.

00:51:18.796 --> 00:51:25.256 A:middle
In a lot of ways Swift is
a protocol-based language.

00:51:25.256 --> 00:51:26.766 A:middle
Next, I want you to notice

00:51:26.766 --> 00:51:30.146 A:middle
that I haven't given the
associated type explicitly,

00:51:30.146 --> 00:51:30.396 A:middle
right.

00:51:30.686 --> 00:51:34.036 A:middle
It gets deduced from the
signature of this function,

00:51:34.916 --> 00:51:36.406 A:middle
which returns a stack generator,

00:51:36.406 --> 00:51:41.346 A:middle
which is the thing
we just created.

00:51:41.426 --> 00:51:45.176 A:middle
Lastly, I want to point out
there are some circumstances

00:51:45.176 --> 00:51:46.226 A:middle
where you don't even need

00:51:46.226 --> 00:51:48.796 A:middle
to write the type
parameters on a generic type.

00:51:49.386 --> 00:51:51.716 A:middle
In this case, I'm
returning stack generator

00:51:51.716 --> 00:51:54.526 A:middle
and I haven't written
the T in angled brackets.

00:51:54.896 --> 00:51:56.516 A:middle
That's because the type context,

00:51:56.566 --> 00:51:58.916 A:middle
the fact that we're
returning the stack generator

00:51:58.916 --> 00:52:05.256 A:middle
of T allows the compiler to
deduce what type that is.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:58.916 --> 00:52:05.256 A:middle
of T allows the compiler to
deduce what type that is.

00:52:05.466 --> 00:52:10.336 A:middle
Okay and now we can finally loop
over the elements of our stack

00:52:10.766 --> 00:52:11.986 A:middle
and Crusty is happy again.

00:52:12.596 --> 00:52:18.086 A:middle
Okay, there is a lot
more I could tell you

00:52:18.086 --> 00:52:19.156 A:middle
about generics and Swift.

00:52:19.536 --> 00:52:20.896 A:middle
And I know this was
pretty intense.

00:52:21.396 --> 00:52:22.846 A:middle
So we're going to stop here.

00:52:23.026 --> 00:52:26.116 A:middle
I wish we had time to cover
the collection protocols,

00:52:26.116 --> 00:52:28.986 A:middle
the index protocol,
protocol refinement.

00:52:29.406 --> 00:52:32.606 A:middle
How to build lazy functional
adapters like we have, like map,

00:52:32.756 --> 00:52:35.576 A:middle
filter, and reverse like we
have in the standard library,

00:52:35.956 --> 00:52:38.906 A:middle
but you know, you can find
all of that stuff if you dig

00:52:38.906 --> 00:52:40.316 A:middle
into the documentation.

00:52:41.086 --> 00:52:43.296 A:middle
If you remember only three
things about this part

00:52:43.296 --> 00:52:45.816 A:middle
of the talk, let it be these.

00:52:46.656 --> 00:52:48.446 A:middle
First, protocols are
what let you hook

00:52:48.446 --> 00:52:51.476 A:middle
into the basic core language
features like for Int,

00:52:51.476 --> 00:52:52.436 A:middle
and string interpolation.

00:52:53.656 --> 00:52:58.436 A:middle
Second, generics offer a
new dimension of speed,

00:52:58.656 --> 00:53:02.866 A:middle
expressivity, and safety for
people coming Objective-C.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.656 --> 00:53:02.866 A:middle
expressivity, and safety for
people coming Objective-C.

00:53:03.146 --> 00:53:05.616 A:middle
You can do really
totally new things.

00:53:06.686 --> 00:53:08.176 A:middle
And lastly, Swift is fun.

00:53:08.726 --> 00:53:12.266 A:middle
I encourage you to dig into
these capabilities and find

00:53:12.266 --> 00:53:13.276 A:middle
out as much as you can.

00:53:13.536 --> 00:53:14.266 A:middle
Experiment.

00:53:14.476 --> 00:53:15.056 A:middle
Play around.

00:53:15.696 --> 00:53:19.756 A:middle
Okay. Now I'm going to bring
up John to close the talk.

00:53:20.106 --> 00:53:22.926 A:middle
He's going to tell you a
bit about the Swift model.

00:53:23.516 --> 00:53:31.026 A:middle
[ Applause ]

00:53:31.526 --> 00:53:33.826 A:middle
&gt;&gt; We talked a lot about what
you can do in Swift and I want

00:53:33.826 --> 00:53:37.116 A:middle
to tie it up by talking about
how Swift actually works

00:53:37.296 --> 00:53:40.726 A:middle
in a couple of quick ways.

00:53:40.936 --> 00:53:43.466 A:middle
Like C, Objective-C, and C++,

00:53:43.946 --> 00:53:46.086 A:middle
Swift is a statically
compiled language

00:53:46.146 --> 00:53:47.976 A:middle
with relatively small
runtime requirements.

00:53:49.356 --> 00:53:51.286 A:middle
That's not a coincidence
and it's not

00:53:51.286 --> 00:53:53.136 A:middle
because we were forced
into it in anyway.

00:53:53.506 --> 00:53:56.316 A:middle
We actually believe very,
very strongly in this model

00:53:56.316 --> 00:53:58.616 A:middle
of programming languages
as a great model for you.

00:53:59.406 --> 00:54:00.766 A:middle
It's really flexible.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:59.406 --> 00:54:00.766 A:middle
It's really flexible.

00:54:01.396 --> 00:54:02.566 A:middle
It's really predictable.

00:54:02.846 --> 00:54:03.936 A:middle
And it's really efficient.

00:54:04.456 --> 00:54:09.186 A:middle
It's flexible because it allows
really simple interoperation.

00:54:09.556 --> 00:54:12.306 A:middle
You don't have to write
everything in Swift.

00:54:13.176 --> 00:54:15.936 A:middle
Our runtime requirements
are so small

00:54:15.936 --> 00:54:20.206 A:middle
that we can just transparently
interact with your existing C,

00:54:20.466 --> 00:54:25.306 A:middle
Objective-C, or Assembly
-- Ada so on.

00:54:26.626 --> 00:54:27.536 A:middle
Don't write your
code Ada [laughter].

00:54:30.106 --> 00:54:34.726 A:middle
And all of that makes it really
straightforward to deploy Swift

00:54:35.576 --> 00:54:36.896 A:middle
to versions of iOS and OS X

00:54:37.006 --> 00:54:40.246 A:middle
that don't even know
anything about the language.

00:54:40.246 --> 00:54:42.206 A:middle
That were developed
without Swift in mind.

00:54:42.646 --> 00:54:45.986 A:middle
Swift is a really
predictable model.

00:54:45.986 --> 00:54:48.126 A:middle
Because it leaves
you fully in charge

00:54:48.126 --> 00:54:49.566 A:middle
of the code that's
actually going to run

00:54:49.566 --> 00:54:51.306 A:middle
on your users' devices.

00:54:52.146 --> 00:54:55.056 A:middle
The compiler's going to weave
a lot of complicated magic,

00:54:55.056 --> 00:54:58.536 A:middle
making generics work, optimizing
this and that and so on.

00:54:58.536 --> 00:55:01.316 A:middle
But when all of that is
done, when all of it settles,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:58.536 --> 00:55:01.316 A:middle
But when all of that is
done, when all of it settles,

00:55:01.656 --> 00:55:05.346 A:middle
you see exactly what's left
and you can feel confident

00:55:05.346 --> 00:55:08.226 A:middle
that that -- in how
that's actually going

00:55:08.226 --> 00:55:09.726 A:middle
to run on a device.

00:55:10.736 --> 00:55:13.776 A:middle
There are no extra, just
in time compilation steps

00:55:13.776 --> 00:55:16.646 A:middle
where all the really interesting
optimizations are implemented.

00:55:17.116 --> 00:55:19.796 A:middle
There's no non-deterministic
places

00:55:20.096 --> 00:55:25.586 A:middle
where like a secondary thread is
pausing your entire application

00:55:25.586 --> 00:55:28.796 A:middle
to garbage-collect right in
the middle of a user operation.

00:55:29.706 --> 00:55:32.936 A:middle
You can understand your code
exactly how it was compiled,

00:55:33.136 --> 00:55:35.776 A:middle
and exactly the result
and feel confident

00:55:35.776 --> 00:55:38.856 A:middle
in exactly how it's
going to run.

00:55:39.226 --> 00:55:42.066 A:middle
And finally, it's
really efficient.

00:55:42.636 --> 00:55:44.746 A:middle
Swift generates native code.

00:55:45.016 --> 00:55:47.526 A:middle
Native code that's
ready to run as soon

00:55:47.526 --> 00:55:48.726 A:middle
as you put in on a device.

00:55:49.516 --> 00:55:51.276 A:middle
There are no recompilation

00:55:51.276 --> 00:55:54.396 A:middle
or warm-up delays while
your app launches.

00:55:55.046 --> 00:55:58.726 A:middle
You're free to organize all of
your high-level code in Swift

00:55:59.206 --> 00:56:02.706 A:middle
into clean and easy to maintain
abstractions using powerful


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:59.206 --> 00:56:02.706 A:middle
into clean and easy to maintain
abstractions using powerful

00:56:02.706 --> 00:56:05.646 A:middle
things like generics And because
it's all statically compiled

00:56:05.646 --> 00:56:09.676 A:middle
that abstraction disappears
immediately during compilation

00:56:09.926 --> 00:56:14.666 A:middle
not later when the jet actually
kicks in and lowers it all

00:56:14.666 --> 00:56:16.486 A:middle
down to nothing, hopefully.

00:56:17.786 --> 00:56:19.876 A:middle
And the predictability
of compilation means

00:56:19.876 --> 00:56:21.586 A:middle
that you can really
feel confident

00:56:21.586 --> 00:56:24.306 A:middle
in exactly what is going to
run after all this is done.

00:56:24.706 --> 00:56:28.116 A:middle
So you can feel confident that
you're really tight, efficient,

00:56:28.396 --> 00:56:34.976 A:middle
low-level code will always
do exactly what you expect.

00:56:35.086 --> 00:56:36.166 A:middle
I want to talk a little bit

00:56:36.166 --> 00:56:38.156 A:middle
about the Swift compiler
architecture.

00:56:39.116 --> 00:56:42.596 A:middle
The way that we accomplish
this is very, very similar

00:56:42.596 --> 00:56:45.736 A:middle
to how these [inaudible]
C compilers are structured

00:56:46.216 --> 00:56:48.536 A:middle
with one major modification.

00:56:49.076 --> 00:56:53.476 A:middle
We add an extra step an
extra phase of compilation

00:56:53.556 --> 00:56:55.986 A:middle
for high-level analysis
and optimization.

00:56:56.636 --> 00:56:59.136 A:middle
These are language-specific
analyses.

00:56:59.226 --> 00:57:02.606 A:middle
Things that we know specially
about Swift and its library


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:59.226 --> 00:57:02.606 A:middle
Things that we know specially
about Swift and its library

00:57:02.956 --> 00:57:05.686 A:middle
that allows us to do very
high-level manipulations

00:57:05.686 --> 00:57:07.776 A:middle
and produce really
great code straight off.

00:57:07.776 --> 00:57:11.356 A:middle
I want to talk about three
of those in particular.

00:57:11.956 --> 00:57:16.786 A:middle
The first one is I want to talk
about abstraction penalties.

00:57:17.746 --> 00:57:20.836 A:middle
Suppose that you're writing an
application, and it's got --

00:57:20.836 --> 00:57:23.626 A:middle
and it's talking to a
whole bunch of sensors

00:57:23.626 --> 00:57:25.646 A:middle
and a whole bunch of
different subsystems and some

00:57:25.696 --> 00:57:27.736 A:middle
of them are giving
you values, you know,

00:57:27.736 --> 00:57:30.576 A:middle
values back in one
kind of unit and some

00:57:30.576 --> 00:57:32.056 A:middle
of them are giving
you values back

00:57:32.056 --> 00:57:33.146 A:middle
in a different kind of unit.

00:57:33.356 --> 00:57:35.766 A:middle
And it's really important to
you that you're not app --

00:57:36.066 --> 00:57:39.876 A:middle
not burn up when it re-enters
the Martian atmosphere.

00:57:42.506 --> 00:57:44.836 A:middle
You can use the type
system in Swift to do this.

00:57:45.316 --> 00:57:49.206 A:middle
Structs have zero added
run time extraction costs,

00:57:49.206 --> 00:57:53.796 A:middle
which we've designed Swift from
ground-up to eliminate this kind

00:57:53.796 --> 00:57:55.526 A:middle
of abstraction cost
transparently.

00:57:56.996 --> 00:58:00.796 A:middle
In fact, in Swift even basic
fundamental library types


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:57:56.996 --> 00:58:00.796 A:middle
In fact, in Swift even basic
fundamental library types

00:58:00.796 --> 00:58:03.716 A:middle
like Int and Float are
actually implemented as Swift

00:58:03.926 --> 00:58:07.256 A:middle
as struct types that are
wrapping even more fundamental

00:58:07.256 --> 00:58:07.896 A:middle
LLVM types.

00:58:07.896 --> 00:58:10.896 A:middle
So you can feel very,
very confident

00:58:10.896 --> 00:58:13.726 A:middle
that we've done an extraordinary
amount of work to make sure

00:58:13.726 --> 00:58:16.646 A:middle
that these things don't
add any extra overhead.

00:58:17.176 --> 00:58:22.466 A:middle
The second thing I want to talk
about is generic specialization.

00:58:23.306 --> 00:58:25.266 A:middle
Some languages implement
generics

00:58:25.306 --> 00:58:30.476 A:middle
by immediately expanding out
your code whenever you use it

00:58:30.476 --> 00:58:32.296 A:middle
with a different set
of generic arguments.

00:58:32.636 --> 00:58:34.776 A:middle
Now that generates
very, very fast code

00:58:34.846 --> 00:58:38.796 A:middle
for this particular
expansion because it means

00:58:39.056 --> 00:58:42.556 A:middle
that like the code generator
never even sees the concept

00:58:42.836 --> 00:58:43.936 A:middle
of a generic function.

00:58:44.866 --> 00:58:49.146 A:middle
But unfortunately, there are
a couple downsides to this.

00:58:49.186 --> 00:58:52.396 A:middle
It's terrible for debug
build times and it ends

00:58:52.396 --> 00:58:55.526 A:middle
up generating a ton of code
that the compiler and the linker

00:58:55.526 --> 00:58:57.636 A:middle
and everything else need
to conspire together

00:58:57.636 --> 00:58:59.156 A:middle
to try to hid at run time.

00:58:59.846 --> 00:59:02.986 A:middle
And it also steals a lot of
flexibility from the compiler


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:58:59.846 --> 00:59:02.986 A:middle
And it also steals a lot of
flexibility from the compiler

00:59:02.986 --> 00:59:04.686 A:middle
to actually unify these things.

00:59:05.616 --> 00:59:08.236 A:middle
So in Swift, generic
specialization is

00:59:08.236 --> 00:59:09.406 A:middle
an optimization.

00:59:09.446 --> 00:59:13.196 A:middle
It's something that we can do,
but we also maintain the ability

00:59:13.196 --> 00:59:16.446 A:middle
to run generic code
as generic code.

00:59:18.216 --> 00:59:21.106 A:middle
The last thing I want to talk
about is de-virtualization.

00:59:21.636 --> 00:59:23.816 A:middle
De-virtualization is
an incredibly important

00:59:23.816 --> 00:59:25.676 A:middle
optimization in Swift,
because so much

00:59:25.676 --> 00:59:27.216 A:middle
of your code is written
around classes.

00:59:27.476 --> 00:59:31.636 A:middle
It's very important
for us to be able

00:59:31.636 --> 00:59:34.386 A:middle
to take something very
simple and very lightweight

00:59:34.386 --> 00:59:38.646 A:middle
like a getter and turn that into
direct manipulation of memory.

00:59:39.786 --> 00:59:42.126 A:middle
There's a lot of ways that
we can do de-virtualization

00:59:42.126 --> 00:59:42.996 A:middle
in Swift.

00:59:43.146 --> 00:59:45.736 A:middle
We can see where you're actually
constructing the object.

00:59:46.086 --> 00:59:48.096 A:middle
We can do hierarchy
analysis to see

00:59:48.096 --> 00:59:50.066 A:middle
that a class doesn't
have any sub-classes.

00:59:50.066 --> 00:59:54.476 A:middle
But you can also take control of
this manually by marking methods

00:59:54.476 --> 00:59:57.026 A:middle
and classes as final,
in order to tell Swift

00:59:57.026 --> 00:59:59.026 A:middle
that it doesn't have to
worry about the possibility

00:59:59.026 --> 01:00:00.366 A:middle
of it being overridden anywhere.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:59:59.026 --> 01:00:00.366 A:middle
of it being overridden anywhere.

01:00:00.906 --> 01:00:04.256 A:middle
There are a lot of other
high-level optimizations

01:00:04.256 --> 01:00:06.086 A:middle
that I really wish that I
had the time to talk to,

01:00:06.086 --> 01:00:07.976 A:middle
but I'm actually already
two minutes over time.

