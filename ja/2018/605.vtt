WEBVTT

00:00:07.107 --> 00:00:16.583 align:start position:43% line:-1
(音楽)

00:00:22.356 --> 00:00:28.996 align:start position:43% line:-1
(拍手)

00:00:29.530 --> 00:00:33.233 align:start position:14% line:-2
私はアレックス
Tools Foundation所属です

00:00:33.333 --> 00:00:38.872 align:start position:29% line:-2
OSなどの担当部署ですが
今年はゲームを作りました

00:00:38.972 --> 00:00:41.041 align:start position:27% line:-1
“SwiftShot”です

00:00:41.141 --> 00:00:45.245 align:start position:32% line:-2
既に階下で遊んだ方も
いるでしょう

00:00:45.846 --> 00:00:52.486 align:start position:21% line:-2
SwiftShotはARKitの
新機能を紹介しています

00:00:52.920 --> 00:00:57.291 align:start position:30% line:-2
ARKit 2は多くの
デバイスで利用可能です

00:00:57.391 --> 00:01:01.094 align:start position:34% line:-2
AR体験を生む
プラットフォームで

00:00:57.391 --> 00:01:01.094 align:start position:34% line:-2
AR体験を生む
プラットフォームで

00:01:01.195 --> 00:01:04.665 align:start position:27% line:-1
幅広いユーザに届けられます

00:01:04.965 --> 00:01:10.270 align:start position:27% line:-2
特別な設定はなく
デバイスのカメラを使うだけ

00:01:11.839 --> 00:01:14.308 align:start position:29% line:-1
iOSに統合されています

00:01:14.641 --> 00:01:18.045 align:start position:25% line:-2
SceneKitや
SpriteKitだけでなく

00:01:18.278 --> 00:01:24.184 align:start position:20% line:-2
他社のUnrealやUnityにも
完全に統合されています

00:01:28.622 --> 00:01:29.790 align:start position:38% line:-1
本日の予定です

00:01:29.890 --> 00:01:36.330 align:start position:25% line:-2
まずは今回の開発で学んだ
ARゲームの設計原則について

00:01:36.864 --> 00:01:39.766 align:start position:29% line:-1
次にゲームを掘り下げます

00:01:39.867 --> 00:01:44.171 align:start position:25% line:-2
ARKit 2の新機能である
World Mapの共有や

00:01:44.538 --> 00:01:48.141 align:start position:34% line:-2
ネットワーキングと
物理にも触れます

00:01:48.909 --> 00:01:52.379 align:start position:27% line:-1
まずゲームを観察しましょう

00:01:55.349 --> 00:02:05.359 align:start position:43% line:-1
(音楽)

00:01:55.349 --> 00:02:05.359 align:start position:43% line:-1
(音楽)

00:02:26.680 --> 00:02:29.683 align:start position:41% line:-1
“勝ち！”

00:02:34.254 --> 00:02:38.025 align:start position:34% line:-2
ARゲームの設計を
ご説明します

00:02:40.460 --> 00:02:43.430 align:start position:29% line:-1
ゲームプレイが最優先です

00:02:44.998 --> 00:02:46.900 align:start position:34% line:-1
自問してみましょう

00:02:47.000 --> 00:02:51.905 align:start position:27% line:-2
70年代のグラフィックスで
楽しめる内容か？

00:02:52.039 --> 00:02:55.876 align:start position:36% line:-2
灰色の立方体でも
楽しめるか？

00:02:56.343 --> 00:02:59.847 align:start position:30% line:-2
こうしたアートワークを
用いて

00:02:59.980 --> 00:03:02.082 align:start position:32% line:-1
レベルを下げてみます

00:02:59.980 --> 00:03:02.082 align:start position:32% line:-1
レベルを下げてみます

00:03:02.182 --> 00:03:07.754 align:start position:25% line:-2
それで楽しければ
画や音の改善でより楽しめます

00:03:08.922 --> 00:03:11.191 align:start position:36% line:-1
よく練りましょう

00:03:11.291 --> 00:03:14.928 align:start position:36% line:-2
多少の画質改善や
機能の追加で

00:03:15.028 --> 00:03:18.232 align:start position:29% line:-1
劇的に面白くはなりません

00:03:18.499 --> 00:03:22.769 align:start position:34% line:-2
こうした失敗例は
山ほどありますから

00:03:22.870 --> 00:03:25.305 align:start position:39% line:-1
自分に正直に

00:03:27.040 --> 00:03:28.609 align:start position:32% line:-1
まずゲームプレイです

00:03:31.445 --> 00:03:32.913 align:start position:41% line:-1
尺は短めに

00:03:34.047 --> 00:03:38.919 align:start position:34% line:-2
気軽に出入りできる
ゲームにしましょう

00:03:41.455 --> 00:03:44.992 align:start position:34% line:-2
多様なコンテンツを
用意しましょう

00:03:45.092 --> 00:03:49.496 align:start position:34% line:-2
繰り返しばかりだと
疲れてしまいます

00:03:52.332 --> 00:03:56.303 align:start position:36% line:-2
ゲームの観戦も
楽しまれています

00:03:56.503 --> 00:04:00.574 align:start position:32% line:-2
スポーツ観戦のような
感覚ですね

00:03:56.503 --> 00:04:00.574 align:start position:32% line:-2
スポーツ観戦のような
感覚ですね

00:04:01.008 --> 00:04:05.245 align:start position:34% line:-2
ですから その点も
考慮しましょう

00:04:07.648 --> 00:04:10.984 align:start position:27% line:-1
ゲームは重要な交流の形です

00:04:12.653 --> 00:04:16.423 align:start position:25% line:-1
ARはふれあいを演出できます

00:04:16.523 --> 00:04:21.894 align:start position:29% line:-2
親戚とカードゲームをした
経験があるでしょう

00:04:22.062 --> 00:04:25.966 align:start position:36% line:-2
技術を用いて
それに近づけます

00:04:29.036 --> 00:04:34.041 align:start position:30% line:-2
目の前に3Dゲームを
置くだけでは不十分です

00:04:34.374 --> 00:04:37.377 align:start position:29% line:-1
ARではデバイスの位置や

00:04:37.644 --> 00:04:40.814 align:start position:29% line:-1
ユーザの環境も分かります

00:04:40.948 --> 00:04:46.954 align:start position:25% line:-2
それを生かしてARならではの
体験にしましょう

00:04:52.159 --> 00:04:56.530 align:start position:27% line:-2
カメラでオブジェクト内部を
見られます

00:04:57.064 --> 00:05:02.102 align:start position:32% line:-2
この3Dパズルでは
割れた花瓶を直します

00:04:57.064 --> 00:05:02.102 align:start position:32% line:-2
この3Dパズルでは
割れた花瓶を直します

00:05:02.202 --> 00:05:06.974 align:start position:29% line:-2
周りを見ながら
はまるピースを探すんです

00:05:07.641 --> 00:05:09.910 align:start position:21% line:-1
SwiftShotもこんな概念で

00:05:10.043 --> 00:05:13.747 align:start position:34% line:-2
中心は机で
動きながら遊べます

00:05:13.981 --> 00:05:17.417 align:start position:29% line:-1
でも机は単なる面ではなく

00:05:17.518 --> 00:05:19.286 align:start position:36% line:-1
プレイの一部です

00:05:19.920 --> 00:05:22.489 align:start position:34% line:-1
机の高さは重要です

00:05:22.990 --> 00:05:28.929 align:start position:29% line:-2
ブロックの上のぱちんこの
高さはそれぞれ違います

00:05:29.062 --> 00:05:34.968 align:start position:29% line:-2
ユーザが狙いを定めたり
かわしたりできるからです

00:05:37.804 --> 00:05:41.775 align:start position:36% line:-2
カメラを使って
周囲も見られます

00:05:43.377 --> 00:05:44.578 align:start position:39% line:-1
この例では…

00:05:46.246 --> 00:05:50.918 align:start position:32% line:-2
ユニコーンを見つけて
写真を撮ります

00:05:53.420 --> 00:05:55.889 align:start position:36% line:-1
周辺を探すんです

00:06:00.027 --> 00:06:02.863 align:start position:30% line:-1
別の宇宙も見せられます

00:06:02.963 --> 00:06:05.632 align:start position:27% line:-1
実際の被写体と違う世界です

00:06:06.366 --> 00:06:07.968 align:start position:39% line:-1
環境を置換し

00:06:08.535 --> 00:06:14.041 align:start position:30% line:-2
物理法則を曲げたりして
楽しいゲームを作ります

00:06:14.208 --> 00:06:17.177 align:start position:30% line:-1
昼に星を見せていますね

00:06:21.315 --> 00:06:23.517 align:start position:29% line:-1
コントローラにもできます

00:06:25.986 --> 00:06:30.691 align:start position:29% line:-2
そうすることで仮想世界に
溶け込めます

00:06:30.924 --> 00:06:36.163 align:start position:30% line:-2
この例ではブロックを
持ち上げ はめ込みます

00:06:36.663 --> 00:06:38.732 align:start position:27% line:-1
こんなインタラクションです

00:06:39.733 --> 00:06:42.369 align:start position:36% line:-1
動きはゆっくりと

00:06:42.903 --> 00:06:47.474 align:start position:27% line:-2
ブレなくなりトラッキングの
精度も上がります

00:06:48.675 --> 00:06:54.615 align:start position:29% line:-2
いくらデバイスが小型でも
振り回せば腕が疲れます

00:06:54.715 --> 00:06:57.251 align:start position:30% line:-1
ゆっくり動かしましょう

00:06:59.753 --> 00:07:02.389 align:start position:30% line:-1
プレーヤーも動かします

00:06:59.753 --> 00:07:02.389 align:start position:30% line:-1
プレーヤーも動かします

00:07:02.556 --> 00:07:07.728 align:start position:29% line:-2
例えば敵のぱちんこの前に
ブロックがあります

00:07:07.961 --> 00:07:12.032 align:start position:30% line:-2
だから移動して障害物を
攻撃します

00:07:19.306 --> 00:07:21.508 align:start position:30% line:-2
操作のフィードバックも
重要です

00:07:22.910 --> 00:07:27.047 align:start position:27% line:-2
SwiftShotは聴覚と
触覚で没入感を高めます

00:07:27.648 --> 00:07:32.085 align:start position:34% line:-2
動きによって変わる
ゴムを伸ばす音と

00:07:32.386 --> 00:07:37.257 align:start position:30% line:-2
電話を持つ感覚で
リアルな体験になります

00:07:37.391 --> 00:07:40.460 align:start position:29% line:-1
音に関しては また後ほど

00:07:43.230 --> 00:07:47.701 align:start position:27% line:-2
SwiftShotの詳細は
デビッドが説明します

00:07:47.801 --> 00:07:48.535 align:start position:41% line:-1
ありがとう

00:07:49.069 --> 00:07:50.137 align:start position:43% line:-1
(拍手)

00:07:50.237 --> 00:07:50.938 align:start position:43% line:-1
デビッド

00:07:53.707 --> 00:07:56.543 align:start position:32% line:-2
ありがとうアレックス
皆さんこんにちは

00:07:56.944 --> 00:08:02.916 align:start position:20% line:-2
SwiftShotに関する皆さんの
反応はすばらしいです

00:07:56.944 --> 00:08:02.916 align:start position:20% line:-2
SwiftShotに関する皆さんの
反応はすばらしいです

00:08:03.016 --> 00:08:08.422 align:start position:29% line:-2
既にサンプルコードを
使っている方もいるそうで

00:08:08.522 --> 00:08:11.291 align:start position:30% line:-1
今後の展開が楽しみです

00:08:11.525 --> 00:08:16.430 align:start position:23% line:-2
さてSwiftShotに用いた
技術を紹介します

00:08:17.064 --> 00:08:18.999 align:start position:36% line:-1
まずはARKit

00:08:19.099 --> 00:08:24.805 align:start position:29% line:-2
コンテンツと現実世界の
融合を かなえてくれます

00:08:26.573 --> 00:08:31.578 align:start position:18% line:-2
SceneKitの3Dレンダリングと
物理演算で

00:08:31.678 --> 00:08:33.813 align:start position:36% line:-1
制御し描写します

00:08:35.115 --> 00:08:39.520 align:start position:23% line:-2
MetalではGPUデバイスの
力を利用します

00:08:39.620 --> 00:08:43.890 align:start position:20% line:-2
SceneKitのシェーディングや
レンダリング―

00:08:43.991 --> 00:08:47.427 align:start position:32% line:-2
旗シミュレーションに
関連しています

00:08:48.762 --> 00:08:52.666 align:start position:25% line:-2
“GameplayKit”で
オブジェクト間の

00:08:52.766 --> 00:08:56.103 align:start position:36% line:-2
振る舞いを簡単に
共有できます

00:08:57.571 --> 00:09:01.041 align:start position:5% line:-2
“Multipeer Connectivity”の
ネットワーキングレイヤで

00:08:57.571 --> 00:09:01.041 align:start position:5% line:-2
“Multipeer Connectivity”の
ネットワーキングレイヤで

00:09:01.141 --> 00:09:06.346 align:start position:30% line:-2
付近のデバイスを見つけ
同期し暗号化します

00:09:07.514 --> 00:09:12.953 align:start position:21% line:-2
“AV Foundation”で
音楽と効果音を制御し

00:09:13.053 --> 00:09:15.122 align:start position:36% line:-1
没入感を高めます

00:09:16.023 --> 00:09:19.226 align:start position:27% line:-2
そして“Swift”で
アプリケーションを作ります

00:09:19.326 --> 00:09:23.464 align:start position:27% line:-2
Swiftはタイプセーフで
高性能

00:09:24.031 --> 00:09:26.600 align:start position:32% line:-1
機能も充実しています

00:09:26.700 --> 00:09:28.235 align:start position:36% line:-1
プレイに集中でき

00:09:28.335 --> 00:09:32.506 align:start position:29% line:-2
クラッシュやミスマッチの
心配が減ります

00:09:35.275 --> 00:09:41.515 align:start position:27% line:-2
ではiOSの技術で機能を
実装した方法をお話しします

00:09:41.782 --> 00:09:44.384 align:start position:32% line:-1
共有の座標空間の設定

00:09:44.718 --> 00:09:45.819 align:start position:36% line:-1
ネットワーキング

00:09:46.053 --> 00:09:47.087 align:start position:46% line:-1
物理

00:09:47.588 --> 00:09:49.389 align:start position:38% line:-1
アセットの管理

00:09:49.590 --> 00:09:50.924 align:start position:34% line:-1
旗シミュレーション

00:09:51.024 --> 00:09:52.359 align:start position:30% line:-1
ダイナミックオーディオ

00:09:55.128 --> 00:09:58.432 align:start position:32% line:-2
まず共有の座標空間の
設定です

00:09:59.566 --> 00:10:04.705 align:start position:32% line:-2
２台でオブジェクトを
同じ場所に見せるため

00:09:59.566 --> 00:10:04.705 align:start position:32% line:-2
２台でオブジェクトを
同じ場所に見せるため

00:10:04.805 --> 00:10:07.641 align:start position:29% line:-1
共有の座標空間が必要です

00:10:07.941 --> 00:10:11.712 align:start position:32% line:-2
同じ物を見て
話せるようになります

00:10:13.614 --> 00:10:16.884 align:start position:25% line:-1
ARKitの機能で設定します

00:10:17.351 --> 00:10:20.787 align:start position:27% line:-2
iOS 11.3で導入した
イメージの認識で

00:10:20.888 --> 00:10:23.657 align:start position:30% line:-1
周りの世界を認識します

00:10:24.758 --> 00:10:28.395 align:start position:30% line:-2
iOS 12では技術を
２つ加えました

00:10:28.495 --> 00:10:29.796 align:start position:41% line:-1
物体検出と

00:10:29.997 --> 00:10:31.331 align:start position:29% line:-1
World Mapの共有

00:10:32.299 --> 00:10:37.805 align:start position:27% line:-2
検出機能で実世界に
コンテンツを加えられますが

00:10:37.905 --> 00:10:41.241 align:start position:32% line:-1
事前の録画が必要です

00:10:41.608 --> 00:10:46.413 align:start position:27% line:-2
LEGOデモでご覧のとおり
認識して追加します

00:10:47.915 --> 00:10:50.918 align:start position:27% line:-2
このゲームは
World Mapの共有で

00:10:51.018 --> 00:10:54.788 align:start position:36% line:-2
机さえあれば
どこでも遊べます

00:10:55.656 --> 00:11:01.929 align:start position:27% line:-2
この技術はゲームだけでなく
店舗や博物館でも使えます

00:10:55.656 --> 00:11:01.929 align:start position:27% line:-2
この技術はゲームだけでなく
店舗や博物館でも使えます

00:11:02.696 --> 00:11:08.035 align:start position:23% line:-2
階下のゲームルームでは
“iBeacon”でデバイスが

00:11:08.135 --> 00:11:12.039 align:start position:30% line:-2
配置を把握し
マップをロードしました

00:11:12.206 --> 00:11:14.208 align:start position:29% line:-1
すばらしい体験ができます

00:11:16.510 --> 00:11:19.646 align:start position:21% line:-1
SwiftShotの機能を使えば

00:11:19.746 --> 00:11:24.618 align:start position:27% line:-2
プレーヤーがゲームボードを
配置できます

00:11:24.852 --> 00:11:27.287 align:start position:30% line:-1
事前にマップを入れず―

00:11:27.387 --> 00:11:31.658 align:start position:32% line:-2
ボードを配置する例を
お見せしましょう

00:11:33.827 --> 00:11:35.362 align:start position:38% line:-1
手順はこうです

00:11:36.029 --> 00:11:41.168 align:start position:25% line:-2
まず面をスキャンし
ARKitがマップを作ります

00:11:42.569 --> 00:11:46.840 align:start position:32% line:-2
そのデータを
シリアライズして転送

00:11:47.941 --> 00:11:53.146 align:start position:27% line:-2
相手がマップをARKitへ
ロードし 同じ面を認識

00:11:53.280 --> 00:11:56.316 align:start position:29% line:-1
これで共有の基準点ができ

00:11:56.450 --> 00:12:00.654 align:start position:34% line:-2
ボードが同じ場所に
表示されます

00:11:56.450 --> 00:12:00.654 align:start position:34% line:-2
ボードが同じ場所に
表示されます

00:12:02.823 --> 00:12:07.594 align:start position:21% line:-2
まずWorld Mapを１台目の
ARSessionから取得

00:12:08.228 --> 00:12:13.133 align:start position:11% line:-2
iOS 12の新API
“getCurrentWorldMap”です

00:12:13.300 --> 00:12:18.038 align:start position:34% line:-2
把握した世界から
オブジェクトを作り

00:12:18.138 --> 00:12:20.641 align:start position:32% line:-2
非同期コールバックで
返します

00:12:20.874 --> 00:12:26.113 align:start position:12% line:-2
“NSKeyedArchiver”でデータ
オブジェクトへシリアライズ

00:12:26.313 --> 00:12:29.249 align:start position:29% line:-1
データを保存か送信します

00:12:31.518 --> 00:12:36.290 align:start position:34% line:-2
次に受信デバイスの
データ取得方法です

00:12:36.523 --> 00:12:39.293 align:start position:29% line:-1
アドホックゲームのように

00:12:39.393 --> 00:12:43.630 align:start position:20% line:-2
SwiftShotはピアツーピアを
使っています

00:12:44.498 --> 00:12:46.833 align:start position:34% line:-1
２台目が加わる前に

00:12:46.934 --> 00:12:50.404 align:start position:34% line:-2
１台目はマップを
シリアライズし送信

00:12:50.737 --> 00:12:56.443 align:start position:30% line:-2
面さえあれば どこでも
簡単に設定できます

00:12:58.745 --> 00:13:01.482 align:start position:30% line:-1
階下の方法は違いました

00:12:58.745 --> 00:13:01.482 align:start position:30% line:-1
階下の方法は違いました

00:13:01.615 --> 00:13:06.753 align:start position:25% line:-2
World Mapを机ごとに
録画し 複数の角度から

00:13:06.887 --> 00:13:10.824 align:start position:34% line:-2
共有の座標空間の
ローカライズを確認

00:13:11.124 --> 00:13:16.163 align:start position:27% line:-2
机には光の加減や位置などの
特徴があります

00:13:16.997 --> 00:13:20.033 align:start position:38% line:-2
そのファイルを
ローカルに保存

00:13:20.567 --> 00:13:25.339 align:start position:5% line:-2
Mobile Device Managementで
各デバイスを管理し

00:13:25.439 --> 00:13:31.211 align:start position:29% line:-2
各デバイス内のファイルが
同じだと確認しました

00:13:32.479 --> 00:13:36.583 align:start position:30% line:-2
iBeaconを置けば
より円滑にできます

00:13:36.683 --> 00:13:40.821 align:start position:25% line:-2
識別子とWorld Mapを
関連づければ

00:13:40.921 --> 00:13:44.958 align:start position:29% line:-2
各インスタンスがマップを
自動でロードします

00:13:45.592 --> 00:13:47.928 align:start position:32% line:-2
消費者向け
アプリケーションなら

00:13:48.228 --> 00:13:54.701 align:start position:29% line:-2
オンデマンドリソースや
ご自身のソリューションで

00:13:54.802 --> 00:13:56.970 align:start position:21% line:-1
World Mapを共有できます

00:13:57.104 --> 00:14:03.744 align:start position:25% line:-2
例えば ある店舗の正確な
World Mapを選べます

00:13:57.104 --> 00:14:03.744 align:start position:25% line:-2
例えば ある店舗の正確な
World Mapを選べます

00:14:04.278 --> 00:14:09.183 align:start position:32% line:-2
すばらしい体験を生む
可能性に満ちています

00:14:12.119 --> 00:14:16.023 align:start position:32% line:-2
では２台目がデータを
取得した後に

00:14:16.323 --> 00:14:19.493 align:start position:36% line:-2
ロードする方法を
ご紹介します

00:14:19.827 --> 00:14:23.297 align:start position:14% line:-1
“NSKeyedUnarchiver”で

00:14:23.897 --> 00:14:27.367 align:start position:34% line:-2
受信データを
ブローアップします

00:14:28.168 --> 00:14:32.105 align:start position:21% line:-2
“ARWorldTracking
Configuration”で

00:14:32.206 --> 00:14:35.676 align:start position:27% line:-2
World Mapを追加し
設定します

00:14:36.710 --> 00:14:40.681 align:start position:21% line:-1
最後にARSessionで実行し

00:14:40.814 --> 00:14:44.117 align:start position:29% line:-2
アンカーやトラッキングを
リセット

00:14:44.885 --> 00:14:48.755 align:start position:32% line:-2
２台目のARKitが
スキャンを始め

00:14:48.856 --> 00:14:53.994 align:start position:27% line:-2
マップの特徴点と現実世界を
関連づけます

00:14:54.094 --> 00:14:57.531 align:start position:36% line:-2
これで座標空間の
共有が完了

00:14:57.631 --> 00:15:01.502 align:start position:29% line:-2
２台とも実世界の同じ点に
000があります

00:14:57.631 --> 00:15:01.502 align:start position:29% line:-2
２台とも実世界の同じ点に
000があります

00:15:04.037 --> 00:15:06.540 align:start position:36% line:-2
プライバシーにも
触れましょう

00:15:06.740 --> 00:15:11.311 align:start position:20% line:-2
World Mapを録画する過程で
周りの環境や

00:15:11.411 --> 00:15:13.914 align:start position:32% line:-2
オブジェクトの配置を
把握します

00:15:14.948 --> 00:15:18.652 align:start position:30% line:-2
これは緯度と経度などの
情報です

00:15:18.752 --> 00:15:23.090 align:start position:29% line:-2
位置情報の許可を
求める必要はありませんが

00:15:23.790 --> 00:15:28.262 align:start position:34% line:-2
個人を特定できる
情報かもしれません

00:15:28.595 --> 00:15:35.102 align:start position:29% line:-2
他のプライベートデータと
同じ方法で扱いましょう

00:15:35.536 --> 00:15:40.140 align:start position:34% line:-2
保存されたデータと
通信中のデータの

00:15:40.507 --> 00:15:43.143 align:start position:36% line:-1
暗号化が必要です

00:15:43.610 --> 00:15:49.750 align:start position:29% line:-2
またWorld Mapを
長期間 保存する場合も

00:15:49.850 --> 00:15:52.152 align:start position:32% line:-1
ユーザに伝えましょう

00:15:53.220 --> 00:15:57.825 align:start position:30% line:-2
SwiftShotでは
保存されたデータを

00:15:57.991 --> 00:16:01.061 align:start position:30% line:-1
iOSで暗号化しました

00:15:57.991 --> 00:16:01.061 align:start position:30% line:-1
iOSで暗号化しました

00:16:01.328 --> 00:16:06.867 align:start position:27% line:-2
次にお話しするのは
通信中のデータの暗号化です

00:16:09.203 --> 00:16:13.207 align:start position:36% line:-2
共有の座標空間の
設定に加えて

00:16:13.307 --> 00:16:17.044 align:start position:38% line:-2
ゲームボードの
場所も伝えます

00:16:17.678 --> 00:16:19.613 align:start position:29% line:-1
使うのはARAnchor

00:16:20.247 --> 00:16:22.783 align:start position:34% line:-2
作成時に必要なのは
名前と

00:16:23.116 --> 00:16:27.287 align:start position:32% line:-2
４×４の行列という
位置と回転の情報です

00:16:28.655 --> 00:16:34.027 align:start position:20% line:-2
ARKitがARWorldMapに
アンカーを含みシリアライズ

00:16:34.128 --> 00:16:37.831 align:start position:32% line:-2
これでボードの情報を
転送できます

00:16:39.466 --> 00:16:44.037 align:start position:29% line:-2
ARAnchorクラスは
名前と方向を持っていて

00:16:44.138 --> 00:16:47.774 align:start position:36% line:-2
名前でアンカーを
調べられます

00:16:48.141 --> 00:16:52.646 align:start position:30% line:-2
しかし別のデバイス用に
情報を加えます

00:16:52.746 --> 00:16:56.016 align:start position:29% line:-1
ボードのサイズの情報です

00:16:56.250 --> 00:17:00.220 align:start position:36% line:-2
小さな机のサイズ
かもしれないし

00:16:56.250 --> 00:17:00.220 align:start position:36% line:-2
小さな机のサイズ
かもしれないし

00:17:00.320 --> 00:17:03.924 align:start position:29% line:-2
バスケットボールのコート
かもしれない

00:17:06.593 --> 00:17:12.532 align:start position:29% line:-2
ネットワークプロトコルに
含めようかとも思いました

00:17:13.367 --> 00:17:17.503 align:start position:21% line:-2
ですがサブクラスの
“BoardAnchor”を作り

00:17:17.804 --> 00:17:21.375 align:start position:29% line:-1
サイズの情報を加えました

00:17:22.175 --> 00:17:27.748 align:start position:29% line:-2
そしてNSCodingの
必須クラスを実装または

00:17:27.848 --> 00:17:33.020 align:start position:27% line:-2
オーバーライドしているかを
シリアライズ時に確認

00:17:33.320 --> 00:17:39.059 align:start position:27% line:-2
これでWorld Mapに
情報を含めて転送できます

00:17:39.159 --> 00:17:41.061 align:start position:36% line:-1
簡単になりました

00:17:42.029 --> 00:17:45.232 align:start position:30% line:-1
ひとつ注意点があります

00:17:45.432 --> 00:17:49.603 align:start position:27% line:-2
Swiftでのサブクラスの
シリアライズ時は

00:17:49.736 --> 00:17:55.676 align:start position:27% line:-2
クラス名にモジュールなどの
名前を含めてください

00:17:55.943 --> 00:18:00.881 align:start position:20% line:-2
アプリケーション間の
World Mapの移動に重要です

00:17:55.943 --> 00:18:00.881 align:start position:20% line:-2
アプリケーション間の
World Mapの移動に重要です

00:18:00.981 --> 00:18:03.584 align:start position:21% line:-2
NSKeyedArchiverで
対応できます

00:18:05.185 --> 00:18:08.956 align:start position:27% line:-2
これがiOS 12の新機能
World Mapの共有

00:18:09.056 --> 00:18:12.192 align:start position:34% line:-2
どう活用されるのか
楽しみです

00:18:14.461 --> 00:18:16.897 align:start position:34% line:-2
ネットワーキングに
使ったのは―

00:18:17.831 --> 00:18:24.037 align:start position:14% line:-2
iOS 7以来 搭載のMultipeer
ConnectivityのAPIです

00:18:24.605 --> 00:18:29.176 align:start position:29% line:-2
ローカルネットワークでの
ピアツーピア通信で

00:18:29.543 --> 00:18:33.981 align:start position:32% line:-2
専用サーバを介さずに
通信できます

00:18:34.448 --> 00:18:38.385 align:start position:34% line:-2
今回は１台を
サーバにしましたが

00:18:38.485 --> 00:18:41.889 align:start position:36% line:-2
プロトコルには
備わっていません

00:18:42.956 --> 00:18:46.426 align:start position:34% line:-2
暗号化と認証は
組み込まれています

00:18:46.793 --> 00:18:51.365 align:start position:27% line:-2
今回は出入りの速度を優先し
認証は使わず

00:18:51.465 --> 00:18:53.367 align:start position:32% line:-1
暗号化だけ使いました

00:18:53.700 --> 00:18:57.504 align:start position:36% line:-2
パフォーマンスは
不利にならず

00:18:57.604 --> 00:19:01.475 align:start position:32% line:-2
影響があったのは
データサイズなどです

00:18:57.604 --> 00:19:01.475 align:start position:32% line:-2
影響があったのは
データサイズなどです

00:19:01.575 --> 00:19:03.443 align:start position:36% line:-1
だから使いました

00:19:05.012 --> 00:19:09.650 align:start position:32% line:-2
アドバタイズと発見の
APIを使えば

00:19:10.184 --> 00:19:14.087 align:start position:27% line:-2
ゲームのブロードキャストが
可能です

00:19:15.189 --> 00:19:16.924 align:start position:38% line:-1
設定はこうです

00:19:17.458 --> 00:19:22.329 align:start position:32% line:-2
まずホストになる
デバイスを設定します

00:19:23.297 --> 00:19:26.333 align:start position:36% line:-2
周辺をスキャンし
ボードを置き

00:19:27.201 --> 00:19:31.438 align:start position:9% line:-2
Multipeer Connectivityの
セッションを開始

00:19:31.538 --> 00:19:34.608 align:start position:30% line:-2
ローカルネットワークで
アドバタイズします

00:19:36.009 --> 00:19:39.379 align:start position:38% line:-2
他のデバイスが
ゲームを見つけ

00:19:39.947 --> 00:19:44.084 align:start position:32% line:-2
セッションに
参加リクエストを送信

00:19:45.519 --> 00:19:50.891 align:start position:27% line:-2
承認されるとピアツーピアの
通信が設定され

00:19:51.024 --> 00:19:55.529 align:start position:32% line:-2
メッセージの送受信が
可能になります

00:19:55.896 --> 00:20:01.568 align:start position:29% line:-2
今回はセッションを始めた
１台が情報源ですが

00:19:55.896 --> 00:20:01.568 align:start position:29% line:-2
今回はセッションを始めた
１台が情報源ですが

00:20:01.668 --> 00:20:07.441 align:start position:5% line:-2
Multipeer Connectivity本来の
プロトコルではありません

00:20:10.043 --> 00:20:15.816 align:start position:30% line:-2
設定が済むと次の３つの
方法でデータを送れます

00:20:15.916 --> 00:20:17.518 align:start position:38% line:-1
データパケット

00:20:17.751 --> 00:20:20.921 align:start position:29% line:-2
ローカル上のURLという
リソース

00:20:21.021 --> 00:20:22.256 align:start position:41% line:-1
ストリーム

00:20:22.689 --> 00:20:25.893 align:start position:32% line:-2
データオブジェクトは
全ピアに送れますが

00:20:25.993 --> 00:20:29.162 align:start position:30% line:-2
リソースとストリームは
デバイス間です

00:20:29.696 --> 00:20:33.300 align:start position:30% line:-2
SwiftShotでは
データパケットで

00:20:33.400 --> 00:20:38.005 align:start position:27% line:-2
ゲームイベントと
物理ステートを共有しました

00:20:38.472 --> 00:20:41.542 align:start position:27% line:-2
リソースで
World Mapを転送し

00:20:42.142 --> 00:20:44.511 align:start position:34% line:-1
ストリームは不採用

00:20:46.013 --> 00:20:51.218 align:start position:30% line:-2
デバイス間の転送は
UDPに依存しています

00:20:51.318 --> 00:20:55.889 align:start position:32% line:-2
レイテンシが低く
ゲームに適しています

00:20:56.457 --> 00:21:01.929 align:start position:29% line:-2
UDPは本来デリバリーを
保証しないので

00:20:56.457 --> 00:21:01.929 align:start position:29% line:-2
UDPは本来デリバリーを
保証しないので

00:21:02.029 --> 00:21:07.000 align:start position:27% line:-2
こちらでデータパケットを
確実に送るかどうか決めます

00:21:07.568 --> 00:21:11.905 align:start position:9% line:-2
Multipeer Connectivityの
リトライに

00:21:12.005 --> 00:21:14.842 align:start position:32% line:-1
任せることもできます

00:21:15.742 --> 00:21:19.112 align:start position:29% line:-1
対象が全員でも大丈夫です

00:21:21.615 --> 00:21:25.919 align:start position:32% line:-2
次にアプリケーション
プロトコルの作成です

00:21:26.420 --> 00:21:30.090 align:start position:25% line:-2
SwiftEnumsを使えば
簡単です

00:21:30.691 --> 00:21:36.597 align:start position:27% line:-2
各ケースにデータ構造があり
タイプセーフを保証します

00:21:37.431 --> 00:21:39.700 align:start position:32% line:-1
具体例をご紹介します

00:21:39.833 --> 00:21:43.003 align:start position:23% line:-2
この“GameAction”が
含む情報は

00:21:43.103 --> 00:21:46.673 align:start position:30% line:-2
ぱちんこをつかむなどの
動きです

00:21:47.107 --> 00:21:52.079 align:start position:18% line:-2
“PhysicsSyncData”の
エンコードについては後ほど

00:21:53.580 --> 00:21:55.449 align:start position:30% line:-1
Swiftなら簡単です

00:21:55.549 --> 00:22:01.788 align:start position:20% line:-2
全メンバーが“Codable”なら
構造体をCodableでマークし

00:21:55.549 --> 00:22:01.788 align:start position:20% line:-2
全メンバーが“Codable”なら
構造体をCodableでマークし

00:22:01.889 --> 00:22:06.960 align:start position:30% line:-2
Swiftコンパイラに
後の対応を任せます

00:22:07.995 --> 00:22:12.332 align:start position:34% line:-2
列挙型は自分たちで
対応しました

00:22:12.432 --> 00:22:19.072 align:start position:25% line:-2
initを実装し メソッドを
コーディングして動かします

00:22:20.841 --> 00:22:22.609 align:start position:32% line:-1
シリアライズは簡単で

00:22:22.709 --> 00:22:26.547 align:start position:11% line:-2
“PropertyListEncoder”で
オブジェクトをエンコード

00:22:27.247 --> 00:22:31.218 align:start position:30% line:-2
これでデータパケットを
送れます

00:22:32.419 --> 00:22:37.491 align:start position:29% line:-2
サイズとパフォーマンスは
どうでしょうか？

00:22:38.525 --> 00:22:42.930 align:start position:29% line:-2
プロパティリストは小さく
エンコーダは速い

00:22:43.630 --> 00:22:49.169 align:start position:27% line:-2
しかしこうしたソフト実装は
最適化されていて

00:22:49.269 --> 00:22:52.172 align:start position:32% line:-1
開発の時間は貴重です

00:22:54.007 --> 00:22:59.546 align:start position:30% line:-2
次の新機能はこうした
制限にも関連しています

00:23:01.815 --> 00:23:04.685 align:start position:29% line:-1
物理シミュレーションです

00:23:04.918 --> 00:23:09.656 align:start position:30% line:-2
今回のようなゲームでは
リアルな物理表現が

00:23:09.756 --> 00:23:12.659 align:start position:34% line:-1
面白さを左右します

00:23:12.759 --> 00:23:18.932 align:start position:27% line:-2
ブロックや敵のぱちんこを
倒すという楽しい体験の肝は

00:23:19.633 --> 00:23:21.802 align:start position:29% line:-1
物理シミュレーションです

00:23:23.637 --> 00:23:27.541 align:start position:32% line:-2
SceneKitの
物理エンジンを使って

00:23:27.641 --> 00:23:30.744 align:start position:32% line:-2
オブジェクトの位置を
更新し

00:23:30.844 --> 00:23:33.514 align:start position:30% line:-1
コリジョンを通知します

00:23:34.548 --> 00:23:39.219 align:start position:30% line:-2
今回は１台のデバイスを
情報源または

00:23:39.319 --> 00:23:41.955 align:start position:36% line:-1
サーバとしました

00:23:42.222 --> 00:23:47.060 align:start position:9% line:-2
Multipeer Connectivityの
メソッドを使って

00:23:47.161 --> 00:23:51.231 align:start position:29% line:-2
物理ステートの定期更新を
共有しました

00:23:52.633 --> 00:23:57.337 align:start position:30% line:-2
別のデバイスも
シミュレーションします

00:23:57.671 --> 00:24:01.008 align:start position:36% line:-2
全オブジェクトの
情報ではなく

00:23:57.671 --> 00:24:01.008 align:start position:36% line:-2
全オブジェクトの
情報ではなく

00:24:01.108 --> 00:24:06.713 align:start position:29% line:-2
ブロックなどプレイ関連の
情報だけ共有するからです

00:24:06.980 --> 00:24:13.453 align:start position:29% line:-2
ロープやぱちんこなどの
揺れのシミュレーションは

00:24:13.954 --> 00:24:20.060 align:start position:30% line:-2
正確な位置が不要なので
各デバイスが行います

00:24:23.997 --> 00:24:27.768 align:start position:27% line:-1
オブジェクトの規模によって

00:24:27.868 --> 00:24:31.972 align:start position:32% line:-2
物理エンジンの反応が
異なります

00:24:32.172 --> 00:24:37.978 align:start position:29% line:-2
現実のサイズの約10倍の
シミュレーションが

00:24:38.212 --> 00:24:42.716 align:start position:29% line:-2
最高の体験と
パフォーマンスを生みます

00:24:43.116 --> 00:24:46.353 align:start position:30% line:-1
物理法則を曲げましたが

00:24:46.453 --> 00:24:51.792 align:start position:27% line:-2
見た目と感覚がしっくりきて
楽しければ正解です

00:24:53.794 --> 00:24:59.433 align:start position:29% line:-2
これを実現するために
４つの情報を共有しました

00:24:59.600 --> 00:25:00.701 align:start position:46% line:-1
位置

00:24:59.600 --> 00:25:00.701 align:start position:46% line:-1
位置

00:25:02.236 --> 00:25:03.370 align:start position:46% line:-1
速度

00:25:04.605 --> 00:25:06.240 align:start position:45% line:-1
角速度

00:25:06.573 --> 00:25:07.875 align:start position:43% line:-1
方向です

00:25:08.308 --> 00:25:11.011 align:start position:30% line:-1
膨大な情報量になるので

00:25:11.111 --> 00:25:14.414 align:start position:34% line:-2
ビット数を最小限に
抑えました

00:25:14.982 --> 00:25:17.718 align:start position:32% line:-1
具体例をお見せします

00:25:18.786 --> 00:25:22.790 align:start position:25% line:-2
SceneKitは浮動小数で
位置を表します

00:25:23.290 --> 00:25:28.395 align:start position:30% line:-2
計算の性能を最高にする
ネイティブ形式です

00:25:30.063 --> 00:25:34.668 align:start position:32% line:-2
しかし位置を知るには
ビット数が多すぎます

00:25:35.135 --> 00:25:39.640 align:start position:34% line:-2
８ビットの指数部と
23ビットの仮数部

00:25:39.740 --> 00:25:42.843 align:start position:32% line:-2
範囲はプラスマイナス
10の38乗メートル

00:25:43.010 --> 00:25:45.379 align:start position:34% line:-1
こんなに要りません

00:25:47.314 --> 00:25:51.685 align:start position:32% line:-2
シミュレーションでは
机は27メートル

00:25:51.985 --> 00:25:56.790 align:start position:32% line:-2
そこで80メートルで
十分だと判断しました

00:25:58.592 --> 00:26:00.260 align:start position:36% line:-1
コーディング時に

00:25:58.592 --> 00:26:00.260 align:start position:36% line:-1
コーディング時に

00:26:00.794 --> 00:26:06.500 align:start position:27% line:-2
０～80メートルで正規化し
符号部を外しました

00:26:06.600 --> 00:26:08.969 align:start position:32% line:-1
原点は机の中心ですが

00:26:09.369 --> 00:26:11.104 align:start position:36% line:-1
これで値は正です

00:26:12.139 --> 00:26:15.475 align:start position:29% line:-1
値を０～１の範囲にすれば

00:26:15.642 --> 00:26:20.948 align:start position:30% line:-2
プロトコルに備わる
指数部の情報は不要です

00:26:22.616 --> 00:26:26.920 align:start position:32% line:-2
最後に利用できる
ビット数に調整します

00:26:27.254 --> 00:26:33.227 align:start position:27% line:-2
全ての１は浮動小数点数１で
０は浮動小数点数０

00:26:34.061 --> 00:26:36.897 align:start position:30% line:-1
ミリ単位の正確さになり

00:26:37.097 --> 00:26:41.802 align:start position:32% line:-2
円滑に同期するのに
十分だと分かりました

00:26:43.337 --> 00:26:46.540 align:start position:29% line:-1
他の値についても同様です

00:26:46.640 --> 00:26:49.877 align:start position:34% line:-1
速度と角速度と方向

00:26:51.011 --> 00:26:57.751 align:start position:27% line:-2
範囲とビット数を減らして
転送データを最小限にします

00:26:57.951 --> 00:27:02.890 align:start position:27% line:-2
各オブジェクトのビット数は
半分以下になりました

00:26:57.951 --> 00:27:02.890 align:start position:27% line:-2
各オブジェクトのビット数は
半分以下になりました

00:27:04.591 --> 00:27:08.896 align:start position:32% line:-2
数字は圧縮しましたが
プロパティリストには

00:27:09.029 --> 00:27:14.167 align:start position:27% line:-2
膨大なオーバーヘッドがあり
名前でフィールドを送ります

00:27:14.735 --> 00:27:20.174 align:start position:27% line:-2
オブジェクトは把握しており
不要な情報でした

00:27:20.674 --> 00:27:27.648 align:start position:20% line:-2
そこで“BitStream”という
新方策でシリアライズします

00:27:28.315 --> 00:27:31.818 align:start position:34% line:-2
高速シリアライズと
デシリアライズで

00:27:31.919 --> 00:27:35.322 align:start position:36% line:-2
最小限のバイトに
情報を詰めます

00:27:35.789 --> 00:27:42.429 align:start position:27% line:-2
この実装はバイナリデータの
レイテンシを抑える目的です

00:27:42.830 --> 00:27:47.835 align:start position:30% line:-2
なので この方策は
永続性を要するデータや

00:27:47.935 --> 00:27:51.939 align:start position:30% line:-2
長期的に追うデータには
不向きです

00:27:52.473 --> 00:27:56.009 align:start position:32% line:-2
こうした短いものには
最適です

00:27:58.111 --> 00:28:01.048 align:start position:27% line:-1
プロトコルも２つ作りました

00:27:58.111 --> 00:28:01.048 align:start position:27% line:-1
プロトコルも２つ作りました

00:28:01.148 --> 00:28:04.184 align:start position:12% line:-2
“BitStreamEncodable”と
“BitStreamDecodable”

00:28:04.585 --> 00:28:06.753 align:start position:11% line:-1
合わせて“BitStreamCodable”

00:28:07.354 --> 00:28:11.959 align:start position:29% line:-2
これでシリアライズする
全オブジェクトをマークし

00:28:12.059 --> 00:28:13.660 align:start position:39% line:-1
実装しました

00:28:14.027 --> 00:28:17.798 align:start position:32% line:-2
データオブジェクトと
システム内の

00:28:17.898 --> 00:28:22.736 align:start position:30% line:-2
SIMDの浮動小数点
ベクトルなども含みます

00:28:25.172 --> 00:28:28.141 align:start position:36% line:-1
浮動小数の圧縮は

00:28:28.475 --> 00:28:33.580 align:start position:32% line:-2
最小および最大範囲と
指定のビット数で設定

00:28:35.082 --> 00:28:36.884 align:start position:38% line:-1
値をクランプし

00:28:36.984 --> 00:28:41.955 align:start position:27% line:-2
指定のビット数で
エンコード用の整数値に変換

00:28:42.790 --> 00:28:46.126 align:start position:36% line:-2
各オブジェクトに
これを適用します

00:28:46.560 --> 00:28:51.665 align:start position:30% line:-2
追加ビットを使って
動きの更新状況を把握し

00:28:51.999 --> 00:28:55.035 align:start position:36% line:-2
動きがなければ
情報は再送しない

00:28:57.204 --> 00:29:02.376 align:start position:23% line:-2
アクションの列挙型には
BitStreamを用いました

00:28:57.204 --> 00:29:02.376 align:start position:23% line:-2
アクションの列挙型には
BitStreamを用いました

00:29:03.811 --> 00:29:07.414 align:start position:36% line:-2
Codableの
シリアライズでは

00:29:07.514 --> 00:29:11.318 align:start position:23% line:-2
列挙型用の
“CodingKeys”を指定

00:29:12.119 --> 00:29:17.124 align:start position:30% line:-2
BitStreamでは
整数値を使いました

00:29:18.492 --> 00:29:23.130 align:start position:30% line:-2
エンコードのメソッドで
その値をアペンドし

00:29:23.297 --> 00:29:27.801 align:start position:32% line:-2
ケースに関連した
データ構造が続きます

00:29:28.402 --> 00:29:31.472 align:start position:29% line:-1
ここに落とし穴があります

00:29:31.738 --> 00:29:36.810 align:start position:30% line:-2
３つのケースがあり
エンコードに必要なのは

00:29:37.177 --> 00:29:39.513 align:start position:38% line:-1
２ビットですね

00:29:40.647 --> 00:29:45.619 align:start position:29% line:-2
ケースが１つ追加されても
問題ありません

00:29:45.719 --> 00:29:48.689 align:start position:32% line:-1
ケースが５つになると

00:29:48.789 --> 00:29:53.560 align:start position:29% line:-2
３ビット使用に
変更しなくてはなりません

00:29:54.027 --> 00:29:57.097 align:start position:27% line:-1
このコードは くどいですね

00:29:57.197 --> 00:30:02.770 align:start position:27% line:-2
それにうっかりして
ひどい結果になりかねません

00:29:57.197 --> 00:30:02.770 align:start position:27% line:-2
それにうっかりして
ひどい結果になりかねません

00:30:03.737 --> 00:30:08.976 align:start position:25% line:-2
そこでSwiftが手助けする
方法を考えました

00:30:11.044 --> 00:30:15.749 align:start position:21% line:-2
Swift 4.2の新機能
“CaseIterable”です

00:30:16.250 --> 00:30:22.089 align:start position:32% line:-2
このプロトコル準拠を
列挙型に追加しました

00:30:22.422 --> 00:30:27.828 align:start position:18% line:-2
追加される“allCases”という
静的メンバーは

00:30:27.928 --> 00:30:30.130 align:start position:34% line:-1
各ケースを含みます

00:30:30.597 --> 00:30:34.168 align:start position:36% line:-2
これでケース数を
自動取得します

00:30:34.935 --> 00:30:38.672 align:start position:14% line:-2
“RawRepresentable”にも
Extentionを追加

00:30:38.772 --> 00:30:44.344 align:start position:27% line:-2
全列挙型が準拠し
CaseIterableで

00:30:44.444 --> 00:30:46.613 align:start position:32% line:-1
整数値になっています

00:30:47.014 --> 00:30:50.017 align:start position:30% line:-1
ケース数を自動で取得し

00:30:50.117 --> 00:30:54.588 align:start position:32% line:-2
全ケースで必要な
ビット数を算出します

00:30:56.290 --> 00:31:01.061 align:start position:12% line:-2
“WritableBitStream”では
ジェネリックメソッドを加え

00:30:56.290 --> 00:31:01.061 align:start position:12% line:-2
“WritableBitStream”では
ジェネリックメソッドを加え

00:31:01.161 --> 00:31:02.930 align:start position:36% line:-1
エンコード可能に

00:31:03.363 --> 00:31:04.765 align:start position:41% line:-1
アペンドし

00:31:04.865 --> 00:31:09.770 align:start position:30% line:-2
新たな静的プロパティで
ビットを計算します

00:31:11.638 --> 00:31:13.807 align:start position:30% line:-1
シンプルになりましたね

00:31:14.141 --> 00:31:19.580 align:start position:7% line:-2
CodingKeysで“appendEnum”を
使えば後はお任せです

00:31:19.947 --> 00:31:23.817 align:start position:29% line:-2
ケースを加えると
ビットフィールドが拡張し

00:31:23.917 --> 00:31:27.955 align:start position:27% line:-1
削除すれば自動で縮小します

00:31:31.592 --> 00:31:34.528 align:start position:20% line:-2
BitStreamCodableの
実力とは？

00:31:34.962 --> 00:31:38.532 align:start position:27% line:-2
オブジェクトの動きに関する
メッセージで

00:31:38.632 --> 00:31:42.669 align:start position:29% line:-2
送信時のパフォーマンスを
検査しました

00:31:43.971 --> 00:31:47.741 align:start position:32% line:-2
サイズは10分の１
エンコード速度は２倍

00:31:47.841 --> 00:31:49.610 align:start position:32% line:-1
デコード速度は10倍

00:31:50.144 --> 00:31:54.548 align:start position:30% line:-2
75マイクロ秒が
６マイクロ秒になっても

00:31:54.648 --> 00:31:56.417 align:start position:41% line:-1
大差はない

00:31:56.884 --> 00:32:00.254 align:start position:32% line:-2
よく使うオブジェクト
200個なら

00:31:56.884 --> 00:32:00.254 align:start position:32% line:-2
よく使うオブジェクト
200個なら

00:32:00.354 --> 00:32:03.323 align:start position:29% line:-1
円滑なプレイを左右します

00:32:03.457 --> 00:32:04.925 align:start position:32% line:-1
このフォーマットなら

00:32:05.025 --> 00:32:08.562 align:start position:34% line:-2
60fpsで物理の
情報を更新し

00:32:08.695 --> 00:32:11.398 align:start position:32% line:-1
全員が円滑に遊べます

00:32:13.367 --> 00:32:18.605 align:start position:21% line:-2
さて使ったのはCodableと
BitStreamCodable

00:32:18.806 --> 00:32:22.142 align:start position:36% line:-2
異なる方法には
問題がつきもので

00:32:22.242 --> 00:32:25.345 align:start position:29% line:-1
コードパスも２つ必要です

00:32:26.079 --> 00:32:29.216 align:start position:34% line:-2
Swiftで
組み合わせましょう

00:32:30.083 --> 00:32:36.523 align:start position:18% line:-2
限定的な拡張を加えて
BitStreamCodable内の

00:32:36.623 --> 00:32:39.993 align:start position:18% line:-2
CodableにBitStreamの
エンコードを実装

00:32:40.394 --> 00:32:43.063 align:start position:32% line:-1
それからバイナリで…

00:32:44.598 --> 00:32:48.435 align:start position:25% line:-2
エンコードし
BitStreamに入れます

00:32:49.570 --> 00:32:54.541 align:start position:14% line:-2
Codableの構造体は
BitStreamCodableでマーク

00:32:54.842 --> 00:33:01.515 align:start position:16% line:-2
BitStreamCodableだけの
時ほど速く小さくないですが

00:32:54.842 --> 00:33:01.515 align:start position:16% line:-2
BitStreamCodableだけの
時ほど速く小さくないですが

00:33:01.815 --> 00:33:06.653 align:start position:32% line:-2
頻繁なメッセージへの
適用だけで十分でした

00:33:06.854 --> 00:33:10.891 align:start position:36% line:-2
ゲーム内の動きは
高速になりました

00:33:12.493 --> 00:33:14.027 align:start position:38% line:-1
物理はここまで

00:33:14.161 --> 00:33:17.030 align:start position:30% line:-1
次はアセットの対処です

00:33:17.130 --> 00:33:20.234 align:start position:29% line:-1
階下でも質問を受けました

00:33:21.168 --> 00:33:26.106 align:start position:25% line:-2
3Dモジュールやテクスチャや
アニメーションです

00:33:26.373 --> 00:33:31.311 align:start position:30% line:-2
今回は商業ツールで
ビジュアルを作りました

00:33:31.411 --> 00:33:33.714 align:start position:27% line:-1
ブロックやぱちんこなどです

00:33:34.014 --> 00:33:38.151 align:start position:34% line:-2
それをDAE形式で
エクスポート

00:33:38.252 --> 00:33:42.956 align:start position:30% line:-2
USDZをサポートする
ツールが待ち遠しいです

00:33:44.324 --> 00:33:46.693 align:start position:27% line:-2
Swiftで
コマンドラインツールを作り

00:33:46.793 --> 00:33:52.866 align:start position:20% line:-2
SceneKitのAPIでDAEを
SceneKitファイルに変換

00:33:53.100 --> 00:33:57.171 align:start position:29% line:-2
iOSとmacOS共通の
APIがあるからです

00:33:57.271 --> 00:34:01.175 align:start position:32% line:-2
macOSでツールを
使って作成し

00:33:57.271 --> 00:34:01.175 align:start position:32% line:-2
macOSでツールを
使って作成し

00:34:01.275 --> 00:34:05.145 align:start position:29% line:-2
そのファイルを
直接iOSに取り込めます

00:34:06.747 --> 00:34:11.685 align:start position:27% line:-2
構築データを各種ブロックの
ファイルにして

00:34:11.952 --> 00:34:14.788 align:start position:29% line:-1
各レベルで組み合わせます

00:34:15.422 --> 00:34:20.060 align:start position:32% line:-2
この外見と振る舞いを
各ブロックで反復し

00:34:20.226 --> 00:34:24.197 align:start position:30% line:-2
ゲームプレイの設計でも
反復します

00:34:24.297 --> 00:34:28.302 align:start position:29% line:-2
ソースコードの別レベルも
ご活用ください

00:34:30.270 --> 00:34:33.739 align:start position:36% line:-2
異なる距離を
さらに生かすには

00:34:33.841 --> 00:34:38.277 align:start position:25% line:-2
SceneKitでアセットに
変化をつけます

00:34:39.045 --> 00:34:42.049 align:start position:32% line:-2
近くのオブジェクトは
ポリゴンの数が多く

00:34:42.149 --> 00:34:45.786 align:start position:36% line:-2
遠くなら減らして
質感も変える

00:34:45.918 --> 00:34:48.621 align:start position:38% line:-2
レンダリングを
最適化できます

00:34:51.125 --> 00:34:54.328 align:start position:29% line:-1
しかし一貫性も大事なので

00:34:54.428 --> 00:34:57.130 align:start position:34% line:-2
物理ボディを別々に
指定しました

00:34:57.731 --> 00:35:02.903 align:start position:23% line:-2
SceneKitに組み込まれた
立方体などを使えば

00:34:57.731 --> 00:35:02.903 align:start position:23% line:-2
SceneKitに組み込まれた
立方体などを使えば

00:35:03.237 --> 00:35:06.206 align:start position:30% line:-2
最高のパフォーマンスを
発揮します

00:35:06.773 --> 00:35:11.445 align:start position:32% line:-2
指定しなければ自動で
凸包が作られます

00:35:11.578 --> 00:35:17.084 align:start position:30% line:-2
ただしパフォーマンスは
低下するかもしれません

00:35:17.184 --> 00:35:23.357 align:start position:27% line:-2
今回は既存のオブジェクトで
パフォーマンスを上げました

00:35:25.893 --> 00:35:28.762 align:start position:30% line:-1
具体例を見てみましょう

00:35:28.929 --> 00:35:34.201 align:start position:29% line:-2
まずはゲーム内の
木目調の円柱ブロックです

00:35:35.035 --> 00:35:37.538 align:start position:36% line:-1
次はぱちんこです

00:35:37.871 --> 00:35:43.677 align:start position:27% line:-2
シェーダを使って色を加え
アニメーションも作りました

00:35:44.812 --> 00:35:48.549 align:start position:34% line:-2
これはゲームでは
使いませんでしたが

00:35:48.649 --> 00:35:53.253 align:start position:34% line:-2
サンプルコードには
残しておきました

00:35:56.123 --> 00:35:59.560 align:start position:32% line:-2
旗シミュレーションも
楽しいですね

00:35:59.660 --> 00:36:02.095 align:start position:36% line:-1
没入感を高めます

00:35:59.660 --> 00:36:02.095 align:start position:36% line:-1
没入感を高めます

00:36:02.496 --> 00:36:04.932 align:start position:32% line:-1
リアルな風の動きです

00:36:05.065 --> 00:36:08.268 align:start position:27% line:-2
物理エンジンの
布シミュレーションではなく

00:36:09.503 --> 00:36:13.240 align:start position:32% line:-2
GPUとMetalで
やることにしました

00:36:15.242 --> 00:36:18.345 align:start position:29% line:-2
まずはSceneKitの
アセットです

00:36:18.445 --> 00:36:22.616 align:start position:27% line:-2
Appleロゴを乗せるため
テクスチャを貼りました

00:36:23.650 --> 00:36:26.587 align:start position:27% line:-1
次にSwiftクラスを作成

00:36:26.720 --> 00:36:29.056 align:start position:25% line:-2
Metalのコマンドキューを
作り

00:36:29.156 --> 00:36:33.427 align:start position:29% line:-2
風向きなどゲームの状態の
情報を挿入

00:36:34.495 --> 00:36:37.397 align:start position:30% line:-2
コンピュートシェーダを
実行します

00:36:37.764 --> 00:36:40.000 align:start position:27% line:-2
これはＣの
レガシーコードから来ていて

00:36:40.100 --> 00:36:45.138 align:start position:27% line:-2
MetalはモダンC++に
基づくため変換は簡単でした

00:36:45.772 --> 00:36:49.843 align:start position:30% line:-2
コンピュートシェーダで
法線を算出し

00:36:50.077 --> 00:36:54.848 align:start position:32% line:-2
ポリゴンの数を抑え
滑らかな旗を見せます

00:36:55.549 --> 00:36:57.551 align:start position:39% line:-1
上出来ですね

00:36:58.218 --> 00:37:02.956 align:start position:30% line:-2
各フレームでシェーダが
位置を更新します

00:36:58.218 --> 00:37:02.956 align:start position:30% line:-2
各フレームでシェーダが
位置を更新します

00:37:03.223 --> 00:37:05.559 align:start position:30% line:-1
GPUを効果的に活用し

00:37:05.659 --> 00:37:09.997 align:start position:36% line:-2
メインCPUには
影響を与えません

00:37:12.299 --> 00:37:16.069 align:start position:36% line:-2
最後は音声の
実装についてです

00:37:16.603 --> 00:37:20.040 align:start position:27% line:-1
音はゲームの魅力を高めます

00:37:20.674 --> 00:37:26.747 align:start position:27% line:-2
リアルな効果音をゲーム内に
適切に配置することで

00:37:26.847 --> 00:37:30.184 align:start position:27% line:-1
ユーザの没入感を高めました

00:37:30.818 --> 00:37:36.623 align:start position:29% line:-2
速度やアプリケーションの
サイズにも配慮が必要です

00:37:36.924 --> 00:37:39.593 align:start position:32% line:-1
そこで名案が出ました

00:37:40.260 --> 00:37:46.300 align:start position:27% line:-2
同僚の家庭から玩具を借りて
音のサンプルを録音し

00:37:46.833 --> 00:37:52.639 align:start position:20% line:-2
Audio Unitsのプリセット
ファイルと合わせたんです

00:37:52.740 --> 00:37:55.309 align:start position:32% line:-2
そしてMIDI
インストゥルメントを

00:37:55.409 --> 00:37:58.845 align:start position:25% line:-2
AV Foundationで
作りました

00:37:59.413 --> 00:38:04.818 align:start position:29% line:-2
これで展開に応じて
適切な音を簡単に出せます

00:37:59.413 --> 00:38:04.818 align:start position:29% line:-2
これで展開に応じて
適切な音を簡単に出せます

00:38:06.920 --> 00:38:08.956 align:start position:36% line:-1
微調整もしました

00:38:09.089 --> 00:38:14.461 align:start position:29% line:-2
ぱちんこを引く音には
バリエーションがあります

00:38:14.795 --> 00:38:18.832 align:start position:34% line:-2
引く距離に応じて
ピッチを変えました

00:38:19.366 --> 00:38:21.535 align:start position:41% line:-1
それから…

00:38:21.635 --> 00:38:24.671 align:start position:36% line:-2
速度に応じて
音量も変えました

00:38:24.771 --> 00:38:27.641 align:start position:30% line:-1
MIDIノートを選んで

00:38:27.741 --> 00:38:32.212 align:start position:29% line:-2
追加のMIDIコマンドで
修正します

00:38:32.312 --> 00:38:34.915 align:start position:32% line:-1
では聴いてみましょう

00:38:37.818 --> 00:38:47.828 align:start position:41% line:-1
(効果音)

00:38:53.667 --> 00:38:57.504 align:start position:36% line:-2
音声で判断できる
情報があります

00:38:57.604 --> 00:39:03.444 align:start position:32% line:-2
ユーザと ぱちんこの
距離感はどの程度かや

00:38:57.604 --> 00:39:03.444 align:start position:32% line:-2
ユーザと ぱちんこの
距離感はどの程度かや

00:39:03.544 --> 00:39:04.812 align:start position:36% line:-1
既につかんだのか

00:39:04.912 --> 00:39:07.081 align:start position:36% line:-1
最初にした音です

00:39:07.448 --> 00:39:10.083 align:start position:29% line:-1
UIフィードバックなので

00:39:10.184 --> 00:39:14.788 align:start position:27% line:-2
当該ユーザの
デバイスでだけで聞こえます

00:39:14.888 --> 00:39:17.458 align:start position:34% line:-1
ですが他の人たちが

00:39:17.558 --> 00:39:21.962 align:start position:32% line:-2
ぱちんこを使う様子も
音で共有します

00:39:22.062 --> 00:39:25.532 align:start position:29% line:-1
ポジショナルオーディオで

00:39:25.666 --> 00:39:30.170 align:start position:29% line:-2
他者の音を
自分の音より小さくします

00:39:30.404 --> 00:39:33.006 align:start position:27% line:-1
音量と配置を調整するんです

00:39:35.142 --> 00:39:38.845 align:start position:34% line:-2
ブロックの衝突音は
微妙に違います

00:39:39.046 --> 00:39:41.782 align:start position:29% line:-1
欲しかったのは耳障りな…

00:39:43.150 --> 00:39:43.984 align:start position:38% line:-1
エフェクトです

00:39:44.084 --> 00:39:46.854 align:start position:29% line:-1
ブロックは遠くにあるので

00:39:46.954 --> 00:39:51.225 align:start position:25% line:-2
SceneKitで音の位置を
調整しました

00:39:51.992 --> 00:39:56.663 align:start position:32% line:-2
各デバイスで音は違い
同期していません

00:39:56.763 --> 00:40:00.033 align:start position:27% line:-1
あえて耳障りにするためです

00:39:56.763 --> 00:40:00.033 align:start position:27% line:-1
あえて耳障りにするためです

00:40:00.400 --> 00:40:05.138 align:start position:25% line:-2
MIDIインストゥルメントで
少数の音を作りました

00:40:05.305 --> 00:40:11.278 align:start position:29% line:-2
衝突の衝撃の強さに応じて
アタックレートを変えます

00:40:13.414 --> 00:40:17.784 align:start position:27% line:-2
音は3D座標で
ローカライズされているため

00:40:17.885 --> 00:40:21.321 align:start position:27% line:-1
遠くの衝突は小さく聞こえる

00:40:21.555 --> 00:40:22.990 align:start position:39% line:-1
聴きましょう

00:40:26.326 --> 00:40:36.336 align:start position:41% line:-1
(効果音)

00:40:38.539 --> 00:40:39.640 align:start position:43% line:-1
もう一発

00:40:40.641 --> 00:40:41.508 align:start position:43% line:-1
そうです

00:40:42.409 --> 00:40:43.110 align:start position:46% line:-1
はい

00:40:46.246 --> 00:40:50.417 align:start position:30% line:-2
音の設定中に
他にも発見がありました

00:40:50.751 --> 00:40:55.289 align:start position:32% line:-2
プロパティリストで
ファイル名パス変換の

00:40:55.389 --> 00:40:59.226 align:start position:34% line:-2
スクリプトの実行が
必要でした

00:41:00.194 --> 00:41:04.965 align:start position:27% line:-2
Swiftでコマンドライン
ツールとして設定できます

00:41:05.499 --> 00:41:10.537 align:start position:27% line:-2
上にUnixのシバンらしき
部分がありますよね？

00:41:10.637 --> 00:41:14.608 align:start position:29% line:-2
これがSwiftを起動し
実行させます

00:41:15.442 --> 00:41:18.979 align:start position:27% line:-2
これでスクリプト言語として
扱えます

00:41:19.880 --> 00:41:26.220 align:start position:18% line:-2
Swift Playgroundsで
開発することもできます

00:41:26.887 --> 00:41:31.358 align:start position:32% line:-2
準備が整ったら保存し
上にシバンを追加

00:41:31.458 --> 00:41:34.595 align:start position:34% line:-2
ファイルシステムで
実行可能にします

00:41:35.195 --> 00:41:40.367 align:start position:29% line:-2
アプリケーションの外でも
Xcodeの中でも

00:41:40.467 --> 00:41:43.170 align:start position:30% line:-2
コマンドラインツールが
使えます

00:41:43.704 --> 00:41:48.108 align:start position:14% line:-2
全てのSystem frameworkに
アクセスできます

00:41:48.208 --> 00:41:54.781 align:start position:27% line:-2
今回はプロパティリストを
直接編集した便利な技術です

00:41:57.351 --> 00:42:02.990 align:start position:27% line:-2
本日はARがもたらす
体験についてお話ししました

00:41:57.351 --> 00:42:02.990 align:start position:27% line:-2
本日はARがもたらす
体験についてお話ししました

00:42:03.657 --> 00:42:06.326 align:start position:27% line:-1
ARで設計してみてください

00:42:06.427 --> 00:42:11.498 align:start position:29% line:-2
ゲームはプレイの楽しさが
肝心です

00:42:13.100 --> 00:42:19.373 align:start position:25% line:-2
SwiftShotのサンプル
コードをお使いください

00:42:19.473 --> 00:42:24.678 align:start position:29% line:-2
iOS 12リリース後に
随時更新する予定です

00:42:24.978 --> 00:42:31.151 align:start position:23% line:-2
ぜひ会場のSwiftShotで
遊んでみてくださいね

00:42:32.452 --> 00:42:37.558 align:start position:30% line:-2
この後ARKitラボと
懇親会を開催します

00:42:37.824 --> 00:42:40.928 align:start position:30% line:-1
さらにイベント情報です

00:42:41.028 --> 00:42:44.431 align:start position:27% line:-2
金曜にSwiftShotの
大会を開きます

00:42:44.531 --> 00:42:45.933 align:start position:34% line:-1
ぜひご参加ください

00:42:46.400 --> 00:42:47.334 align:start position:41% line:-1
ありがとう

00:42:47.434 --> 00:42:48.936 align:start position:43% line:-1
(拍手)
