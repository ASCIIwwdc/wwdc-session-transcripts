WEBVTT

00:00:07.107 --> 00:00:15.849 align:start position:43% line:-1
(音楽)

00:00:20.487 --> 00:00:27.327 align:start position:43% line:-1
(拍手)

00:00:27.427 --> 00:00:30.764 align:start position:23% line:-1
LLVMのセッションへようこそ

00:00:31.298 --> 00:00:33.834 align:start position:30% line:-1
ジム･グロスバッチです

00:00:33.934 --> 00:00:38.739 align:start position:25% line:-2
LLVMプロジェクトについて
少し触れたあと

00:00:38.839 --> 00:00:44.578 align:start position:29% line:-2
驚きの新機能について
技術面を詳しく紹介します

00:00:45.345 --> 00:00:49.950 align:start position:29% line:-2
LLVMは単なる
コンパイラではありません

00:00:50.217 --> 00:00:56.323 align:start position:20% line:-2
C系言語に対応する
Clangコンパイラの基盤でもあり

00:00:56.423 --> 00:01:02.229 align:start position:12% line:-2
スタティックアナライザ
Sanitizer LLDBデバッガを作動

00:00:56.423 --> 00:01:02.229 align:start position:12% line:-2
スタティックアナライザ
Sanitizer LLDBデバッガを作動

00:01:02.329 --> 00:01:07.801 align:start position:23% line:-2
また弊社の製品に適応する
GPUシェーダコンパイラを通じ

00:01:07.901 --> 00:01:11.438 align:start position:30% line:-1
最適コードを生成します

00:01:11.939 --> 00:01:14.408 align:start position:25% line:-1
そして皆さんも時々耳にする―

00:01:14.608 --> 00:01:19.880 align:start position:23% line:-2
Swiftというプロジェクトの
基盤も成しています

00:01:20.981 --> 00:01:25.219 align:start position:23% line:-2
Swift同様 LLVMは
オープンソースプロジェクトです

00:01:26.386 --> 00:01:30.724 align:start position:30% line:-2
このロゴのワイバーンが
私たちの監視役です

00:01:30.824 --> 00:01:35.829 align:start position:27% line:-2
ドラゴンと呼ぶと
機嫌を損ねてしまいますので

00:01:35.929 --> 00:01:38.498 align:start position:34% line:-1
注意してくださいね

00:01:39.466 --> 00:01:43.637 align:start position:27% line:-2
オープンソースのLLVMは
共同運営です

00:01:44.137 --> 00:01:49.409 align:start position:32% line:-2
私たちのパートナーも
多様性に富んでいます

00:01:49.510 --> 00:01:53.514 align:start position:32% line:-2
企業 学術関係者
研究員 趣味で扱う人

00:01:53.680 --> 00:01:56.517 align:start position:29% line:-1
誰でも自由に参加できます

00:01:56.617 --> 00:02:00.621 align:start position:29% line:-2
協力しながら
最高のツールを作ることで

00:01:56.617 --> 00:02:00.621 align:start position:29% line:-2
協力しながら
最高のツールを作ることで

00:02:00.721 --> 00:02:04.124 align:start position:25% line:-1
技術を前進させられるでしょう

00:02:04.791 --> 00:02:09.630 align:start position:29% line:-2
自分もコンパイラの改良に
協力したいと思う方は

00:02:09.729 --> 00:02:13.066 align:start position:23% line:-1
プロジェクトに参加してください

00:02:13.267 --> 00:02:16.436 align:start position:27% line:-2
詳細は
LLVMのウェブサイトか―

00:02:16.670 --> 00:02:20.974 align:start position:23% line:-2
セッション後にLLVMのラボに
お越しください

00:02:21.074 --> 00:02:25.412 align:start position:21% line:-1
弊社のコンパイラエンジニアたちが

00:02:25.512 --> 00:02:30.250 align:start position:32% line:-2
どんな質問に対しても
詳しく説明します

00:02:30.350 --> 00:02:32.119 align:start position:32% line:-1
何でも聞いてください

00:02:32.953 --> 00:02:37.491 align:start position:30% line:-2
それでは こちらが
今日ご紹介する内容です

00:02:37.591 --> 00:02:39.726 align:start position:27% line:-1
ARCのアップデートにより

00:02:39.826 --> 00:02:44.631 align:start position:29% line:-2
コンパイラのメモリ管理が
簡易化されました

00:02:44.731 --> 00:02:50.003 align:start position:20% line:-2
Xcode 10の新しい検出機能や
スタティックアナライザは

00:02:50.103 --> 00:02:54.141 align:start position:21% line:-1
ビルド時間の早い段階でバグを検出

00:02:54.241 --> 00:02:56.610 align:start position:29% line:-1
コードの質を向上させます

00:02:56.710 --> 00:03:02.115 align:start position:23% line:-2
またプラットフォームや
アプリケーションの安全性も向上

00:02:56.710 --> 00:03:02.115 align:start position:23% line:-2
またプラットフォームや
アプリケーションの安全性も向上

00:03:02.216 --> 00:03:05.352 align:start position:25% line:-2
さらに
ハードウェアアーキテクチャの

00:03:05.452 --> 00:03:09.389 align:start position:30% line:-2
新機能を活用する方法も
お伝えします

00:03:09.623 --> 00:03:14.261 align:start position:25% line:-2
誰もが望んだパフォーマンスを
得られます

00:03:14.695 --> 00:03:19.533 align:start position:30% line:-2
ではARCについて
アレックスが説明します

00:03:20.400 --> 00:03:21.068 align:start position:41% line:-1
アレックス

00:03:21.168 --> 00:03:27.074 align:start position:43% line:-1
(拍手)

00:03:27.908 --> 00:03:29.009 align:start position:36% line:-1
ありがとう　ジム

00:03:29.643 --> 00:03:34.748 align:start position:20% line:-2
ARCが導入されて以来
Objective-Cプログラムは

00:03:34.848 --> 00:03:37.518 align:start position:29% line:-1
かなり簡素化されています

00:03:37.985 --> 00:03:41.221 align:start position:29% line:-1
しかし いくつかの規制が

00:03:41.321 --> 00:03:45.225 align:start position:32% line:-2
ARCへの移行の
妨げとなっていました

00:03:45.492 --> 00:03:48.662 align:start position:27% line:-1
今回 その規制の１つが解消

00:03:49.029 --> 00:03:53.267 align:start position:25% line:-2
Xcode 10では
ARCオブジェクトポインタが

00:03:53.367 --> 00:03:55.002 align:start position:38% line:-1
C構造体に対応

00:03:55.302 --> 00:04:00.440 align:start position:43% line:-1
(拍手)

00:03:55.302 --> 00:04:00.440 align:start position:43% line:-1
(拍手)

00:04:00.541 --> 00:04:04.845 align:start position:29% line:-2
料理を注文する
アプリケーションを例とし

00:04:05.312 --> 00:04:09.383 align:start position:23% line:-1
メニューの構造体を作ってみます

00:04:10.684 --> 00:04:12.786 align:start position:25% line:-1
Xcode 9以前の旧版では

00:04:12.886 --> 00:04:18.858 align:start position:20% line:-2
通常 ARCオブジェクトポインタを
Cの構造体で使えません

00:04:18.959 --> 00:04:23.096 align:start position:23% line:-2
Objective-Cクラスの
作成が必須でした

00:04:24.231 --> 00:04:28.001 align:start position:25% line:-2
しかし Xcode 10では
そのまま―

00:04:28.101 --> 00:04:30.904 align:start position:29% line:-1
Cの構造体が作成できます

00:04:34.474 --> 00:04:37.845 align:start position:21% line:-1
アプリケーションを作っていきます

00:04:38.045 --> 00:04:41.481 align:start position:23% line:-1
まず無料で注文できる関数を用意

00:04:41.582 --> 00:04:47.287 align:start position:29% line:-2
メニューの変数アイテムは
価格を０にしておきます

00:04:48.388 --> 00:04:53.694 align:start position:29% line:-2
そして注文用の別の関数に
アイテムを移行します

00:04:54.761 --> 00:04:59.900 align:start position:23% line:-2
アイテムができると
コンパイラはretainを合成

00:05:00.000 --> 00:05:04.204 align:start position:25% line:-2
ARCオブジェクトポインタを
アイテム内で保持します

00:05:05.105 --> 00:05:10.744 align:start position:23% line:-2
このコメントは
コンパイラが合成するコードです

00:05:11.111 --> 00:05:15.048 align:start position:30% line:-2
このコードにより
アイテムが使われる前に

00:05:15.148 --> 00:05:19.086 align:start position:25% line:-1
料理名と価格は解放されません

00:05:21.288 --> 00:05:25.025 align:start position:21% line:-1
ここでアイテムがスコープ外となり

00:05:25.259 --> 00:05:27.294 align:start position:32% line:-1
スタックから外れます

00:05:27.394 --> 00:05:30.731 align:start position:30% line:-2
そこでコンパイラが
releaseを合成し

00:05:30.831 --> 00:05:34.868 align:start position:25% line:-2
ARCオブジェクトポインタを
解放します

00:05:35.602 --> 00:05:40.874 align:start position:25% line:-2
これでアイテムの解放時
料理名と価格はリークしません

00:05:42.876 --> 00:05:47.481 align:start position:21% line:-2
今まで Objective-Cの
オブジェクトポインタを

00:05:47.581 --> 00:05:50.517 align:start position:29% line:-1
MRRで管理していました

00:05:50.984 --> 00:05:54.755 align:start position:21% line:-1
コードの記述が手間だったのですが

00:05:55.122 --> 00:05:59.326 align:start position:30% line:-2
ARCならコンパイラが
助けてくれます

00:05:59.426 --> 00:06:03.030 align:start position:11% line:-1
自動でretainやreleaseを補います

00:05:59.426 --> 00:06:03.030 align:start position:11% line:-1
自動でretainやreleaseを補います

00:06:03.597 --> 00:06:06.600 align:start position:25% line:-1
とても使いやすいコンパイラで

00:06:06.900 --> 00:06:11.238 align:start position:27% line:-2
スタック上の変数のメモリを
適切に管理します

00:06:11.772 --> 00:06:14.775 align:start position:30% line:-1
また別の構造体の領域や

00:06:14.875 --> 00:06:18.879 align:start position:23% line:-2
Object-Cクラスの
インスタンス変数にも対応します

00:06:19.646 --> 00:06:23.684 align:start position:20% line:-2
しかしARCオブジェクトポインタを
適用するには

00:06:23.784 --> 00:06:26.920 align:start position:25% line:-1
多少 操作する場所があります

00:06:27.788 --> 00:06:29.790 align:start position:36% line:-1
それはヒープです

00:06:30.557 --> 00:06:32.025 align:start position:36% line:-1
構造体に戻ります

00:06:32.125 --> 00:06:36.430 align:start position:27% line:-2
ヒープにメニューアイテムを
割り当てます

00:06:36.763 --> 00:06:42.269 align:start position:18% line:-2
Objective-Cを適用するなら
NSArrayを使いますが

00:06:42.503 --> 00:06:45.639 align:start position:16% line:-1
今回はmallocとfreeを使います

00:06:46.139 --> 00:06:49.343 align:start position:29% line:-1
このコードの問題点は２つ

00:06:49.977 --> 00:06:54.748 align:start position:27% line:-2
１つ目はメモリの割り当て時
０に初期化されず

00:06:55.082 --> 00:06:58.385 align:start position:29% line:-1
ポインタが無効化されます

00:06:58.619 --> 00:07:03.590 align:start position:29% line:-2
そのためプログラム実行時
予想外の動作をします

00:06:58.619 --> 00:07:03.590 align:start position:29% line:-2
そのためプログラム実行時
予想外の動作をします

00:07:05.225 --> 00:07:07.361 align:start position:29% line:-1
２つ目はメモリ解放の前に

00:07:07.461 --> 00:07:12.299 align:start position:25% line:-2
ARCオブジェクトポインタが
クリアされません

00:07:12.533 --> 00:07:17.304 align:start position:29% line:-2
そのためプログラム実行時
メモリリークが起きます

00:07:19.139 --> 00:07:21.642 align:start position:29% line:-1
１つ目の問題を修正します

00:07:21.742 --> 00:07:25.245 align:start position:14% line:-1
mallocをcallocに置き換えます

00:07:25.746 --> 00:07:29.583 align:start position:25% line:-1
これでメモリは０に初期化され

00:07:30.050 --> 00:07:34.688 align:start position:32% line:-2
実行時の厄介な問題は
すべて解消されます

00:07:35.756 --> 00:07:42.062 align:start position:23% line:-2
２つ目はメモリに割り当てる前に
ループを書くことで

00:07:42.162 --> 00:07:45.599 align:start position:25% line:-2
ARCオブジェクトポインタを
クリアできます

00:07:46.266 --> 00:07:49.837 align:start position:25% line:-1
これでアイテムの名前と価格は

00:07:49.937 --> 00:07:52.606 align:start position:30% line:-1
解放時にリークしません

00:07:56.009 --> 00:07:58.712 align:start position:30% line:-1
ARCは非常に便利です

00:07:59.046 --> 00:08:01.315 align:start position:29% line:-1
このような機能がないため

00:07:59.046 --> 00:08:01.315 align:start position:29% line:-1
このような機能がないため

00:08:01.415 --> 00:08:06.987 align:start position:25% line:-2
ARCへの移行を
敬遠していた人もいるでしょう

00:08:07.087 --> 00:08:10.524 align:start position:16% line:-1
Xcode 10のサポート機能を受けて

00:08:10.891 --> 00:08:13.160 align:start position:27% line:-1
ARCを試してみてください

00:08:13.994 --> 00:08:19.733 align:start position:14% line:-2
では Objective-Cのポインタや
構造体を取り上げます

00:08:19.833 --> 00:08:23.504 align:start position:27% line:-2
Xcode 10で
異なる言語モードにおける―

00:08:23.604 --> 00:08:26.740 align:start position:29% line:-1
構造体の作成に注目します

00:08:27.808 --> 00:08:30.944 align:start position:18% line:-1
Xcode 10は異なる言語モードで

00:08:31.044 --> 00:08:36.383 align:start position:18% line:-2
Objective-Cのオブジェクト
ポインタを適用できます

00:08:36.482 --> 00:08:44.024 align:start position:0% line:-2
CやObjective-C Objective-C++でも
同じ構造体が使用できます

00:08:44.758 --> 00:08:49.463 align:start position:27% line:-2
ARCやMRRで
コードをコンパイルする時も

00:08:49.563 --> 00:08:52.900 align:start position:23% line:-1
適切に機能させることができます

00:08:54.067 --> 00:08:59.039 align:start position:18% line:-2
Xcode 10では
Objective-C++のABIを

00:08:59.239 --> 00:09:03.844 align:start position:30% line:-2
構造体を処理する関数の
呼び出し間で統一

00:08:59.239 --> 00:09:03.844 align:start position:30% line:-2
構造体を処理する関数の
呼び出し間で統一

00:09:03.977 --> 00:09:08.248 align:start position:27% line:-2
構造体はARCオブジェクト
ポインタを持ちます

00:09:08.682 --> 00:09:12.986 align:start position:14% line:-1
Xcode 10ではABIを変えることで

00:09:13.220 --> 00:09:17.491 align:start position:20% line:-2
Objective-C++の関数を
対応させています

00:09:17.825 --> 00:09:21.395 align:start position:25% line:-2
ARCオブジェクトポインタを
持つ構造体を

00:09:21.495 --> 00:09:24.198 align:start position:32% line:-1
値で処理する関数です

00:09:24.398 --> 00:09:28.702 align:start position:25% line:-2
コンストラクタや
デストラクタなどは対象外です

00:09:30.037 --> 00:09:33.774 align:start position:25% line:-1
この調整で対象となるコードが

00:09:33.874 --> 00:09:36.910 align:start position:27% line:-1
あいまいな人もいるでしょう

00:09:37.010 --> 00:09:39.813 align:start position:25% line:-1
Xcodeのリリースノートで

00:09:39.913 --> 00:09:45.352 align:start position:29% line:-2
ABIの調整による影響を
詳しく説明しています

00:09:48.956 --> 00:09:54.761 align:start position:21% line:-2
ARCオブジェクトポインタを持つ
C構造体の注意点として

00:09:55.629 --> 00:09:57.564 align:start position:29% line:-1
Swiftは対応しません

00:09:57.664 --> 00:10:02.803 align:start position:21% line:-2
SwiftではARCオブジェクト
ポインタを持つ構造体は

00:09:57.664 --> 00:10:02.803 align:start position:21% line:-2
SwiftではARCオブジェクト
ポインタを持つ構造体は

00:10:03.170 --> 00:10:07.241 align:start position:27% line:-2
判定されず
コンパイルエラーとなります

00:10:13.847 --> 00:10:19.319 align:start position:18% line:-2
Xcode 10はARCオブジェクト
ポインタのサポートに加え

00:10:19.453 --> 00:10:24.358 align:start position:27% line:-2
新しいコンパイラ検出機能を
いくつも備えています

00:10:24.791 --> 00:10:28.395 align:start position:29% line:-2
Xcode 10にある
100種類以上の警告から

00:10:28.695 --> 00:10:31.164 align:start position:34% line:-1
２つを取り上げます

00:10:31.932 --> 00:10:34.902 align:start position:11% line:-1
１つ目はSwiftとObjective-Cを

00:10:35.569 --> 00:10:39.339 align:start position:21% line:-1
組み合わせた人に興味深いでしょう

00:10:39.840 --> 00:10:44.778 align:start position:12% line:-2
Swiftのコードは
Objective-Cにインポート可能です

00:10:45.245 --> 00:10:50.083 align:start position:18% line:-2
Xcodeの場合
Objective-Cの宣言を使って

00:10:50.184 --> 00:10:54.888 align:start position:23% line:-2
Swiftのインターフェイスを
構成するヘッダファイルを作成

00:10:56.456 --> 00:11:00.260 align:start position:18% line:-2
このヘッダファイルを
Objective-Cにインポートし

00:10:56.456 --> 00:11:00.260 align:start position:18% line:-2
このヘッダファイルを
Objective-Cにインポートし

00:11:00.360 --> 00:11:04.131 align:start position:29% line:-2
基底のSwiftの宣言に
アクセスします

00:11:04.865 --> 00:11:06.300 align:start position:36% line:-1
詳細を説明します

00:11:06.400 --> 00:11:11.672 align:start position:27% line:-2
重要なのは Swiftでの
クロージャのパラメータです

00:11:12.139 --> 00:11:14.041 align:start position:32% line:-1
こちらをご覧ください

00:11:14.141 --> 00:11:18.178 align:start position:27% line:-2
Executorという
Swiftのプロトコルです

00:11:18.679 --> 00:11:22.783 align:start position:16% line:-2
performOperationという
メンバ関数を定義し

00:11:22.883 --> 00:11:26.320 align:start position:25% line:-2
クロージャにhandlerを
取り入れます

00:11:27.454 --> 00:11:31.358 align:start position:32% line:-2
今 このパラメータは
エスケープ不可です

00:11:31.458 --> 00:11:34.561 align:start position:30% line:-1
つまり関数が返した後に

00:11:34.661 --> 00:11:37.464 align:start position:27% line:-1
保持や呼び出しはできません

00:11:38.565 --> 00:11:43.737 align:start position:25% line:-2
Objective-Cで
このようなプロトコルに従う時

00:11:43.837 --> 00:11:47.674 align:start position:30% line:-2
プログラマは
この規定を忘れがちです

00:11:48.075 --> 00:11:51.378 align:start position:18% line:-1
例えば Objective-C言語で

00:11:51.478 --> 00:11:55.215 align:start position:21% line:-2
インターフェイスは
DispatchExecutor

00:11:55.315 --> 00:11:58.185 align:start position:18% line:-1
Executorプロトコルに従います

00:11:58.285 --> 00:12:01.221 align:start position:14% line:-1
performOperationを提供し

00:11:58.285 --> 00:12:01.221 align:start position:14% line:-1
performOperationを提供し

00:12:01.321 --> 00:12:07.194 align:start position:21% line:-2
クロージャのパラメータに対応する
ハンドラブロックを取り込みます

00:12:07.394 --> 00:12:10.731 align:start position:27% line:-1
しかしコードを見ただけでは

00:12:10.831 --> 00:12:15.002 align:start position:21% line:-2
handlerがエスケープ可能か
分かりません

00:12:16.003 --> 00:12:19.206 align:start position:20% line:-1
そこでXcode 10は警告を出し

00:12:19.306 --> 00:12:25.012 align:start position:23% line:-2
パラメータがエスケープ不可だと
知らせてくれます

00:12:27.414 --> 00:12:28.815 align:start position:39% line:-1
修正するには

00:12:28.916 --> 00:12:33.787 align:start position:16% line:-2
ブロックの値に
NS NOESCAPEと注釈を補います

00:12:34.555 --> 00:12:37.624 align:start position:14% line:-1
メソッドのimplementationか

00:12:38.158 --> 00:12:43.063 align:start position:29% line:-2
そのパラメータにも
注釈を補っておきましょう

00:12:44.131 --> 00:12:48.268 align:start position:27% line:-2
NS NOESCAPEが
明白なリマインダとなります

00:12:48.368 --> 00:12:52.773 align:start position:12% line:-1
performOperationが返した後

00:12:52.873 --> 00:12:57.477 align:start position:29% line:-2
ハンドラブロックの保存や
呼び出しはしません

00:12:58.979 --> 00:13:04.117 align:start position:14% line:-2
SwiftとObjective-Cの間で
規定があると

00:12:58.979 --> 00:13:04.117 align:start position:14% line:-2
SwiftとObjective-Cの間で
規定があると

00:13:04.218 --> 00:13:07.821 align:start position:23% line:-1
私たちに気付かせてくれるのです

00:13:10.057 --> 00:13:13.760 align:start position:23% line:-1
２つ目は低水準コードを扱う人や

00:13:14.161 --> 00:13:17.764 align:start position:27% line:-1
メモリ内の配置を気にする人

00:13:17.865 --> 00:13:21.034 align:start position:25% line:-1
そんな人の関心を引くでしょう

00:13:21.735 --> 00:13:23.637 align:start position:32% line:-1
こちらを見てください

00:13:23.737 --> 00:13:29.009 align:start position:30% line:-2
Cでは構造体の配置や
アライメントは厳格です

00:13:29.776 --> 00:13:36.116 align:start position:21% line:-2
スライドの構造体では
コンパイラが２行目と３行目の間に

00:13:36.216 --> 00:13:39.620 align:start position:21% line:-1
２バイトのパディングを挿入します

00:13:40.687 --> 00:13:43.991 align:start position:23% line:-1
気楽に組みたいと思う人のために

00:13:44.091 --> 00:13:48.629 align:start position:12% line:-2
コンパイラは
pragma packディレクティブを提供

00:13:48.729 --> 00:13:52.299 align:start position:32% line:-2
配置やアライメントを
調整してくれます

00:13:54.434 --> 00:13:59.473 align:start position:16% line:-2
この例では
push, 1ディレクティブを使います

00:13:59.673 --> 00:14:01.909 align:start position:30% line:-1
既定の配置が解除します

00:13:59.673 --> 00:14:01.909 align:start position:30% line:-1
既定の配置が解除します

00:14:02.176 --> 00:14:06.580 align:start position:32% line:-2
構造体を隙間なく
埋めることができます

00:14:07.347 --> 00:14:09.149 align:start position:36% line:-1
構造体の直列化や

00:14:09.316 --> 00:14:13.921 align:start position:30% line:-2
ネットワーク上を
移動させる時に便利です

00:14:14.721 --> 00:14:19.993 align:start position:25% line:-2
pragma packは通例
PushとPopを指示します

00:14:20.327 --> 00:14:25.799 align:start position:30% line:-2
しかし忘れがちなのが
Popのコード挿入です

00:14:27.201 --> 00:14:30.103 align:start position:23% line:-1
Xcode 10はコードを警告

00:14:30.404 --> 00:14:34.408 align:start position:21% line:-1
Popが対応していないと伝えます

00:14:34.908 --> 00:14:37.978 align:start position:25% line:-1
またPushの位置を示します

00:14:39.646 --> 00:14:44.952 align:start position:30% line:-2
この警告を修正するには
Pushの位置を確認し

00:14:45.285 --> 00:14:50.724 align:start position:23% line:-2
Popをコードの対応する位置に
挿入します

00:14:51.692 --> 00:14:56.163 align:start position:32% line:-2
コードを詰めた後でも
直接 挿入できます

00:14:57.064 --> 00:14:58.866 align:start position:34% line:-1
新たな配置の規則は

00:14:59.466 --> 00:15:03.604 align:start position:30% line:-2
その詰めた構造体にだけ
適用されます

00:14:59.466 --> 00:15:03.604 align:start position:30% line:-2
その詰めた構造体にだけ
適用されます

00:15:03.704 --> 00:15:08.075 align:start position:27% line:-2
プログラム内の
他の構造体には影響しません

00:15:11.845 --> 00:15:17.284 align:start position:21% line:-2
この２つの警告は
Xcode 10のデフォルトです

00:15:17.885 --> 00:15:22.956 align:start position:27% line:-2
より適切で安定したコードが
書けるでしょう

00:15:23.357 --> 00:15:29.163 align:start position:21% line:-2
さらに安定したコード作成に関して
このあとジョージより

00:15:29.263 --> 00:15:33.367 align:start position:21% line:-2
改善したスタティックアナライザを
ご紹介します

00:15:33.967 --> 00:15:34.635 align:start position:43% line:-1
ジョージ

00:15:34.735 --> 00:15:40.307 align:start position:43% line:-1
(拍手)

00:15:40.908 --> 00:15:42.643 align:start position:30% line:-1
ありがとう アレックス

00:15:42.910 --> 00:15:46.780 align:start position:20% line:-2
私からは
Clangスタティックアナライザの

00:15:46.880 --> 00:15:49.783 align:start position:32% line:-1
改善点をご紹介します

00:15:50.284 --> 00:15:51.785 align:start position:36% line:-1
このアナライザは

00:15:51.885 --> 00:15:56.723 align:start position:25% line:-2
潜在的で再現困難なバグ検出に
適しています

00:15:57.157 --> 00:16:00.060 align:start position:29% line:-1
バグを発見するだけでなく

00:15:57.157 --> 00:16:00.060 align:start position:29% line:-1
バグを発見するだけでなく

00:16:00.160 --> 00:16:05.265 align:start position:30% line:-2
バグの原因となるパスを
Xcodeで表示します

00:16:05.532 --> 00:16:10.871 align:start position:16% line:-2
この例はNSMutableArrayに
nilがあるためクラッシュします

00:16:11.038 --> 00:16:14.174 align:start position:29% line:-2
スタティックアナライザが
そのパスを表示

00:16:14.274 --> 00:16:16.810 align:start position:29% line:-1
修正の流れを確認できます

00:16:17.978 --> 00:16:22.482 align:start position:29% line:-2
では３つの新たな改善点を
紹介します

00:16:22.749 --> 00:16:28.288 align:start position:2% line:-2
１つ目にGrand Central Dispatchの
アンチパターンを解析

00:16:28.388 --> 00:16:31.992 align:start position:23% line:-1
パフォーマンスの劣化を探ります

00:16:32.326 --> 00:16:35.829 align:start position:27% line:-1
２つ目は自動解放プール内の

00:16:35.929 --> 00:16:39.299 align:start position:25% line:-1
変数の誤用を検出する機能です

00:16:39.399 --> 00:16:42.202 align:start position:16% line:-1
use-after-freeを防ぎます

00:16:42.936 --> 00:16:48.275 align:start position:27% line:-2
３つ目はアナライザの性能と
表示機能の向上です

00:16:49.376 --> 00:16:54.448 align:start position:25% line:-2
まずはGCDアンチパターンの
解析機能を紹介します

00:16:54.848 --> 00:16:59.052 align:start position:27% line:-2
プラットフォームのAPIは
大抵 非同期です

00:16:59.153 --> 00:17:04.724 align:start position:27% line:-2
しかし同期させて
使いたい状況もあるでしょう

00:16:59.153 --> 00:17:04.724 align:start position:27% line:-2
しかし同期させて
使いたい状況もあるでしょう

00:17:05.526 --> 00:17:09.229 align:start position:32% line:-2
バックグラウンドで
コードが実行中の時や

00:17:09.463 --> 00:17:14.201 align:start position:29% line:-2
必須の値が使えるまで
関数が機能しない場合など

00:17:14.701 --> 00:17:19.772 align:start position:25% line:-2
有効な解決策は
同期化を確保するセマフォです

00:17:20.440 --> 00:17:22.843 align:start position:29% line:-1
こちらの例をご覧ください

00:17:22.943 --> 00:17:27.681 align:start position:21% line:-2
NSXPCConnectionの
オブジェクトです

00:17:27.781 --> 00:17:31.785 align:start position:11% line:-2
プロパティの
remoteObjectProxyを呼び出し

00:17:31.885 --> 00:17:36.857 align:start position:16% line:-2
異なるプロセスから非同期で
CurrentTaskNameを得ます

00:17:37.491 --> 00:17:39.860 align:start position:29% line:-1
そしてセマフォを対応させ

00:17:39.960 --> 00:17:42.829 align:start position:25% line:-1
コールバックはsignalに

00:17:43.163 --> 00:17:49.369 align:start position:21% line:-2
これで関数が返す前に
taskNameが有効になります

00:17:49.703 --> 00:17:53.974 align:start position:27% line:-2
しかし この方法は
パフォーマンスに影響します

00:17:54.341 --> 00:18:00.547 align:start position:25% line:-2
非同期でセマフォを使う時
問題が生じる可能性があります

00:17:54.341 --> 00:18:00.547 align:start position:25% line:-2
非同期でセマフォを使う時
問題が生じる可能性があります

00:18:00.781 --> 00:18:04.985 align:start position:21% line:-1
優先順位の低いキューが実行されて

00:18:05.085 --> 00:18:09.590 align:start position:30% line:-2
パフォーマンスの劣化や
ハングを起こすのです

00:18:10.057 --> 00:18:13.794 align:start position:30% line:-2
他にもパフォーマンスを
下げる原因となる―

00:18:13.927 --> 00:18:17.731 align:start position:21% line:-1
無用なスレッドを作ってしまいます

00:18:18.932 --> 00:18:21.301 align:start position:30% line:-1
この問題を解決するため

00:18:21.401 --> 00:18:24.805 align:start position:29% line:-2
スタティックアナライザが
警告します

00:18:26.206 --> 00:18:29.476 align:start position:27% line:-1
問題が生じた場所を示します

00:18:31.512 --> 00:18:33.680 align:start position:36% line:-1
修正方法はこちら

00:18:33.981 --> 00:18:40.020 align:start position:21% line:-2
最良の例として
同期が可能なAPIを用意しました

00:18:40.154 --> 00:18:42.489 align:start position:20% line:-1
NSXPCConnectionには

00:18:42.589 --> 00:18:47.394 align:start position:14% line:-2
類似APIのsynchronous
RemoteObjectProxyを配置

00:18:47.661 --> 00:18:53.267 align:start position:30% line:-2
セマフォの必要性を消し
より高速に実行させます

00:18:55.102 --> 00:18:59.606 align:start position:32% line:-2
次は同期したAPIが
無い場合の方法です

00:18:59.706 --> 00:19:03.277 align:start position:21% line:-1
startメソッドに継続を使用し

00:18:59.706 --> 00:19:03.277 align:start position:21% line:-1
startメソッドに継続を使用し

00:19:03.377 --> 00:19:06.480 align:start position:29% line:-2
コールバックに
必須の関数を呼び出します

00:19:09.116 --> 00:19:14.188 align:start position:29% line:-2
この検出機能は
ビルド設定で使用可能です

00:19:14.288 --> 00:19:19.927 align:start position:23% line:-2
アプリケーションを保護し
可能な限り速い動作を実現します

00:19:21.261 --> 00:19:24.364 align:start position:29% line:-1
では２つ目の解析機能です

00:19:24.464 --> 00:19:28.869 align:start position:30% line:-2
対象は自動解放プールに
残った変数です

00:19:30.304 --> 00:19:35.309 align:start position:18% line:-2
autoreleasingの修飾子は
自動解放プールから

00:19:35.409 --> 00:19:38.312 align:start position:25% line:-1
値が解放されることを示します

00:19:38.479 --> 00:19:42.849 align:start position:30% line:-2
例ではエラー変数を
プールに登録しています

00:19:42.950 --> 00:19:47.087 align:start position:30% line:-2
変数の制御が
プールの範囲外になると

00:19:47.187 --> 00:19:50.891 align:start position:21% line:-1
変数は解放され その後消滅します

00:19:51.058 --> 00:19:55.262 align:start position:21% line:-2
自動解放プールは
Objective-Cの機能です

00:19:55.362 --> 00:20:01.635 align:start position:21% line:-2
大容量メモリのアプリケーションの
処理を手軽にしてくれます

00:19:55.362 --> 00:20:01.635 align:start position:21% line:-2
大容量メモリのアプリケーションの
処理を手軽にしてくれます

00:20:02.970 --> 00:20:06.540 align:start position:25% line:-2
しかし
予期せぬクラッシュも起きます

00:20:07.040 --> 00:20:09.543 align:start position:29% line:-1
全く想定できないでしょう

00:20:09.643 --> 00:20:14.848 align:start position:18% line:-2
autoreleasingの修飾子で
明示していないからです

00:20:15.015 --> 00:20:18.719 align:start position:18% line:-1
今回 妥当性関数にoutパラメータの

00:20:18.952 --> 00:20:21.989 align:start position:21% line:-1
NSErrorを組み込んでいます

00:20:22.256 --> 00:20:27.728 align:start position:25% line:-2
outパラメータは
ARCにより自動解放されます

00:20:28.028 --> 00:20:33.066 align:start position:25% line:-2
今回 自動解放プールに
outパラメータを登録します

00:20:35.269 --> 00:20:39.439 align:start position:32% line:-2
関数が終了した後
エラー変数の値が解放

00:20:39.807 --> 00:20:43.744 align:start position:30% line:-2
呼び出し元が
値を読み込もうとすると

00:20:43.844 --> 00:20:47.181 align:start position:9% line:-1
use-after-freeでクラッシュします

00:20:50.818 --> 00:20:53.821 align:start position:25% line:-1
先ほどは検出困難な例でしたが

00:20:53.954 --> 00:21:00.394 align:start position:21% line:-2
自動解放プールの管理を
少しでも怠るとより難しくなります

00:20:53.954 --> 00:21:00.394 align:start position:21% line:-2
自動解放プールの管理を
少しでも怠るとより難しくなります

00:21:00.661 --> 00:21:05.899 align:start position:21% line:-2
こちらの関数もoutパラメータの
エラーを起こします

00:21:06.133 --> 00:21:09.770 align:start position:2% line:-2
enumerateObjectsUsingBlockを
呼び出します

00:21:09.870 --> 00:21:12.639 align:start position:29% line:-1
基盤となる定番のAPIで

00:21:12.739 --> 00:21:15.976 align:start position:23% line:-1
各要素にブロックを呼び出します

00:21:16.410 --> 00:21:19.346 align:start position:2% line:-2
しかし実際
enumerateObjectsUsingBlockは

00:21:19.446 --> 00:21:23.817 align:start position:29% line:-2
戻り値の自動解放プールに
呼び出します

00:21:24.017 --> 00:21:26.220 align:start position:34% line:-1
同じ問題が生じます

00:21:26.320 --> 00:21:32.292 align:start position:23% line:-2
エラー変数を作り ブロック内の
値をoutパラメータに書くと

00:21:32.526 --> 00:21:38.465 align:start position:0% line:-2
enumerateObjectsUsingBlockから
制御が外れる前に解放されます

00:21:39.533 --> 00:21:42.669 align:start position:27% line:-1
呼び出し元が値を読み込む時

00:21:42.769 --> 00:21:45.672 align:start position:9% line:-1
use-after-freeでクラッシュします

00:21:47.941 --> 00:21:51.245 align:start position:21% line:-1
先ほど紹介したコンパイラの警告は

00:21:51.345 --> 00:21:56.717 align:start position:25% line:-2
自動解放の明示が無い
outパラメータに対応します

00:21:56.984 --> 00:22:01.555 align:start position:29% line:-2
そしてパラメータの
自動解放の明示を促します

00:21:56.984 --> 00:22:01.555 align:start position:29% line:-2
そしてパラメータの
自動解放の明示を促します

00:22:02.055 --> 00:22:05.192 align:start position:25% line:-1
このような問題に対処するため

00:22:05.492 --> 00:22:11.265 align:start position:12% line:-2
Xcode 10にはClangスタティック
アナライザを導入しました

00:22:11.832 --> 00:22:14.101 align:start position:32% line:-1
自動解放プールの中に

00:22:15.102 --> 00:22:20.407 align:start position:20% line:-2
ブロックを呼び出したAPIを判断し
警告を出します

00:22:23.544 --> 00:22:25.846 align:start position:30% line:-1
問題を修正していきます

00:22:26.180 --> 00:22:30.717 align:start position:27% line:-2
手順は強力なローカル変数を
導入するだけ

00:22:30.984 --> 00:22:33.554 align:start position:36% line:-1
ブロック内の値を

00:22:33.654 --> 00:22:37.324 align:start position:23% line:-1
そのローカル変数に書き込みます

00:22:37.624 --> 00:22:42.729 align:start position:27% line:-2
制御がブロックから外れると
outパラメータにコピー

00:22:42.829 --> 00:22:45.332 align:start position:25% line:-1
自動解放プール内ではないので

00:22:45.432 --> 00:22:48.469 align:start position:12% line:-1
autoreleasingの変数は安全です

00:22:53.140 --> 00:22:58.912 align:start position:30% line:-2
最後に向上した性能と
表示方法をお伝えします

00:22:59.546 --> 00:23:01.448 align:start position:32% line:-1
Xcode 10では

00:22:59.546 --> 00:23:01.448 align:start position:32% line:-1
Xcode 10では

00:23:01.648 --> 00:23:05.652 align:start position:29% line:-2
アナライザがプログラムを
より効率的な手段で解析

00:23:05.752 --> 00:23:11.325 align:start position:20% line:-2
同じ解析時間で
検出できるバグは15％増加しました

00:23:12.125 --> 00:23:14.528 align:start position:30% line:-1
また検出するだけでなく

00:23:14.728 --> 00:23:19.900 align:start position:27% line:-2
バグレポートも
より分かりやすくなりました

00:23:20.000 --> 00:23:23.937 align:start position:20% line:-1
旧版のXcodeではエラー表示の際

00:23:24.638 --> 00:23:30.911 align:start position:25% line:-2
多くのステップや矢印ばかりで
理解に時間がかかりました

00:23:31.345 --> 00:23:35.582 align:start position:16% line:-1
Xcode 10ではエラーの解析結果を

00:23:35.782 --> 00:23:39.720 align:start position:23% line:-1
より短く単純な内容で表示します

00:23:39.820 --> 00:23:41.989 align:start position:29% line:-1
問題を素早く把握できます

00:23:43.357 --> 00:23:47.227 align:start position:29% line:-2
スタティックアナライザを
使用するには

00:23:47.327 --> 00:23:50.497 align:start position:11% line:-1
ProductからAnalyzeを選択します

00:23:50.864 --> 00:23:53.801 align:start position:7% line:-1
Analyze During Buildからでも

00:23:53.901 --> 00:23:57.004 align:start position:23% line:-1
アナライザが確認できるでしょう

00:23:57.237 --> 00:24:02.676 align:start position:25% line:-2
これは事前にバグを検出できる
最高のツールなのです

00:23:57.237 --> 00:24:02.676 align:start position:25% line:-2
これは事前にバグを検出できる
最高のツールなのです

00:24:03.010 --> 00:24:07.281 align:start position:32% line:-2
では低水準の改善点を
アーメドが紹介します

00:24:07.815 --> 00:24:10.184 align:start position:43% line:-1
(拍手)

00:24:10.284 --> 00:24:11.151 align:start position:32% line:-1
ありがとう ジョージ

00:24:11.251 --> 00:24:14.321 align:start position:43% line:-1
(拍手)

00:24:14.488 --> 00:24:18.592 align:start position:29% line:-2
紹介したとおり
コンパイラは多種の警告や

00:24:18.692 --> 00:24:21.228 align:start position:29% line:-1
アナライザ検出が可能です

00:24:21.395 --> 00:24:26.934 align:start position:21% line:-2
Sanitizerも多くのバグを
検出する上で役立ちます

00:24:28.101 --> 00:24:31.438 align:start position:23% line:-1
皆さんもすでにバグ検出ツールで

00:24:31.538 --> 00:24:34.541 align:start position:27% line:-1
何度も検査したことでしょう

00:24:34.975 --> 00:24:37.878 align:start position:25% line:-1
しかし ある種の厄介なバグは

00:24:38.045 --> 00:24:44.084 align:start position:21% line:-2
検査を潜り抜け リリースビルドに
入り込むことがあります

00:24:45.085 --> 00:24:47.054 align:start position:27% line:-1
そのためリリースビルド内で

00:24:47.154 --> 00:24:51.525 align:start position:29% line:-2
常にバグを軽減する措置を
用意しました

00:24:52.559 --> 00:24:58.632 align:start position:23% line:-2
Xcode 10に備わった
新たなバグ軽減措置を紹介します

00:25:00.033 --> 00:25:03.070 align:start position:23% line:-1
まずスタックの機能を把握します

00:25:04.905 --> 00:25:08.976 align:start position:18% line:-1
ここにdlogというC関数があります

00:25:09.309 --> 00:25:13.380 align:start position:23% line:-1
デバッグの文字列を含んでいます

00:25:14.715 --> 00:25:17.651 align:start position:23% line:-1
今回 Helloを呼び出します

00:25:18.285 --> 00:25:24.358 align:start position:21% line:-2
この呼び出しを記録していくために
メモリを割り当てます

00:25:26.026 --> 00:25:29.196 align:start position:27% line:-1
割り当てる場所がスタックで

00:25:29.663 --> 00:25:33.834 align:start position:29% line:-2
領域はnullポインタか
０のアドレスまでです

00:25:35.903 --> 00:25:40.774 align:start position:25% line:-2
スタックフレームという単位に
Helloを割り当てます

00:25:41.375 --> 00:25:46.813 align:start position:27% line:-2
スタックフレームは
戻りアドレスなどを含みます

00:25:47.681 --> 00:25:51.018 align:start position:25% line:-1
他にはローカル変数もあります

00:25:51.652 --> 00:25:55.389 align:start position:21% line:-2
ローカル変数を
logfile pathにすると

00:25:56.023 --> 00:25:58.058 align:start position:27% line:-1
スタックフレームに入ります

00:26:00.227 --> 00:26:04.598 align:start position:29% line:-2
このdlogflileに
別の関数を呼び出すと

00:26:05.699 --> 00:26:08.202 align:start position:21% line:-1
独自のスタックフレームができます

00:26:09.336 --> 00:26:14.441 align:start position:25% line:-2
処理が済むとフレームから外れ
呼び出し元に戻ります

00:26:16.777 --> 00:26:20.147 align:start position:21% line:-1
スタックフレームを分析しましょう

00:26:21.515 --> 00:26:27.654 align:start position:25% line:-2
４バイトのローカルバッファを
持つ関数に変更します

00:26:29.723 --> 00:26:32.960 align:start position:23% line:-1
デバッグの文字列を用意するため

00:26:33.060 --> 00:26:36.964 align:start position:12% line:-1
bufferを含むstrcpyを配置します

00:26:38.499 --> 00:26:41.502 align:start position:23% line:-1
バイト単位で文字をコピーします

00:26:41.602 --> 00:26:44.905 align:start position:34% line:-1
“H　e　l　l”

00:26:46.006 --> 00:26:49.643 align:start position:21% line:-1
しかし４バイトを使い切ったことで

00:26:49.843 --> 00:26:53.614 align:start position:30% line:-2
バッファには
バイトが余っていません

00:26:54.515 --> 00:26:59.953 align:start position:16% line:-2
そうなるとstrcpyは戻りアドレスを
オーバーライドします

00:27:01.021 --> 00:27:02.656 align:start position:38% line:-1
これは危険です

00:27:02.856 --> 00:27:06.527 align:start position:34% line:-2
攻撃者はコピー中の
文字列と同様に―

00:27:06.627 --> 00:27:09.897 align:start position:27% line:-1
戻りアドレスも制御できます

00:27:10.164 --> 00:27:15.903 align:start position:21% line:-2
よって次の動作まで制御できるため
安全性を脅かします

00:27:18.739 --> 00:27:24.645 align:start position:11% line:-2
この問題を検出するため
Address Sanitizerを使います

00:27:24.845 --> 00:27:27.981 align:start position:29% line:-1
これで簡単に修正できます

00:27:28.382 --> 00:27:33.821 align:start position:23% line:-2
重要なのはサイズを
把握しているstrncpyです

00:27:33.921 --> 00:27:37.257 align:start position:21% line:-1
より高レベルなAPIも効果的です

00:27:38.959 --> 00:27:42.729 align:start position:27% line:-2
このバグはリリースビルドに
残る場合があり

00:27:43.030 --> 00:27:48.135 align:start position:14% line:-2
対策として
Stack Protectorを使います

00:27:49.736 --> 00:27:54.341 align:start position:25% line:-2
スタックフレームの順序を変え
カナリーを加えます

00:27:55.609 --> 00:27:57.644 align:start position:36% line:-1
コードを書く時に

00:27:58.378 --> 00:28:04.051 align:start position:27% line:-2
returnの上のコードで
カナリーが有効か確認します

00:27:58.378 --> 00:28:04.051 align:start position:27% line:-2
returnの上のコードで
カナリーが有効か確認します

00:28:06.120 --> 00:28:09.923 align:start position:32% line:-2
最初にカナリーを
オーバーライドします

00:28:11.391 --> 00:28:17.197 align:start position:21% line:-2
返す前にカナリーで確認が入るため
処理が停止します

00:28:17.564 --> 00:28:23.170 align:start position:23% line:-2
悪用できる脆弱性が
信頼性の高いクラッシュに変わり

00:28:23.337 --> 00:28:25.272 align:start position:34% line:-1
攻撃者には不利です

00:28:26.640 --> 00:28:28.842 align:start position:14% line:-1
これがStack Protectorです

00:28:32.780 --> 00:28:37.684 align:start position:27% line:-2
バッファのオーバーフローを
検出してくれます

00:28:38.418 --> 00:28:41.855 align:start position:29% line:-2
Xcodeはデフォルトで
実装しています

00:28:44.324 --> 00:28:49.229 align:start position:27% line:-2
次はさらに厄介なケースへの
軽減措置です

00:28:50.664 --> 00:28:54.535 align:start position:32% line:-2
関数は先ほどと同じ
dlogを使いますが

00:28:55.002 --> 00:28:58.205 align:start position:29% line:-1
可変長配列になっています

00:28:59.072 --> 00:29:01.842 align:start position:27% line:-1
パラメータにはlenを使用

00:28:59.072 --> 00:29:01.842 align:start position:27% line:-1
パラメータにはlenを使用

00:29:04.011 --> 00:29:10.117 align:start position:20% line:-2
特定の呼び出しで
１万5000バイトの容量を要します

00:29:10.918 --> 00:29:14.388 align:start position:23% line:-1
スタックフレームも同等の長さに

00:29:16.990 --> 00:29:19.993 align:start position:25% line:-1
しかし全メモリは即座に使えず

00:29:20.094 --> 00:29:25.999 align:start position:27% line:-2
ページに分かれることで
スタックが必要に応じて拡張

00:29:26.567 --> 00:29:30.771 align:start position:30% line:-2
１万バイトのバッファで
アクセスしても

00:29:30.871 --> 00:29:35.342 align:start position:34% line:-2
次ページにあるため
有効ではありません

00:29:35.442 --> 00:29:38.912 align:start position:25% line:-1
CPU内のページ不良に備えて

00:29:39.012 --> 00:29:44.351 align:start position:25% line:-2
OSがスタックを延長すべきか
判断しているのです

00:29:44.852 --> 00:29:46.854 align:start position:32% line:-1
システムが管理します

00:29:49.056 --> 00:29:52.292 align:start position:25% line:-1
しかし 攻撃者が長さを制御し

00:29:52.392 --> 00:29:56.396 align:start position:29% line:-2
ページを増やしてしまった
としましょう

00:29:57.798 --> 00:29:59.233 align:start position:38% line:-1
新たな問題です

00:29:59.800 --> 00:30:05.372 align:start position:27% line:-2
メモリは有限ですから
スタックに割り当て続ければ

00:29:59.800 --> 00:30:05.372 align:start position:27% line:-2
メモリは有限ですから
スタックに割り当て続ければ

00:30:05.472 --> 00:30:09.343 align:start position:32% line:-2
ヒープなどの別領域に
達してしまいます

00:30:10.777 --> 00:30:13.580 align:start position:25% line:-1
するとクラッシュを起こします

00:30:13.680 --> 00:30:17.618 align:start position:30% line:-2
mallocなどで
確保していても無駄です

00:30:20.521 --> 00:30:24.391 align:start position:16% line:-1
先ほどのstrcpyの例にならうように

00:30:24.491 --> 00:30:28.262 align:start position:23% line:-1
１バイトずつ書いていきましょう

00:30:30.030 --> 00:30:33.167 align:start position:38% line:-1
“H　e　l”

00:30:33.600 --> 00:30:38.839 align:start position:23% line:-2
CPU 生成したコード OSは
問題ないと判断します

00:30:39.006 --> 00:30:43.143 align:start position:32% line:-2
すでに有効なページを
使っているからです

00:30:44.778 --> 00:30:51.185 align:start position:21% line:-2
しかしローカルなスタックではない
ヒープ上では問題です

00:30:51.485 --> 00:30:54.988 align:start position:30% line:-2
コードを書く時
オーバーライドするのは

00:30:55.189 --> 00:30:59.626 align:start position:29% line:-2
Boolean値など
関連性のない情報にします

00:31:00.294 --> 00:31:03.130 align:start position:27% line:-1
これも危険な問題になります

00:31:06.967 --> 00:31:10.204 align:start position:27% line:-1
そこで新機能が役に立ちます

00:31:10.838 --> 00:31:16.176 align:start position:30% line:-2
関数の始まる部分に
新たなコードが入ります

00:31:16.877 --> 00:31:20.714 align:start position:27% line:-2
スタックフレームの有効性を
確認するものです

00:31:21.348 --> 00:31:24.718 align:start position:27% line:-1
スタックの最大容量を把握し

00:31:25.285 --> 00:31:29.723 align:start position:34% line:-2
容量を超えた場合
処理を停止させます

00:31:31.125 --> 00:31:35.229 align:start position:23% line:-1
こちらも悪用の恐れがあるバグを

00:31:35.329 --> 00:31:39.032 align:start position:21% line:-1
信頼性の高いクラッシュに変えます

00:31:41.068 --> 00:31:46.540 align:start position:12% line:-2
これがStack Clashを検出する
Stack Checkingという機能です

00:31:46.840 --> 00:31:49.109 align:start position:20% line:-1
Xcode 10ではデフォルトです

00:31:53.313 --> 00:31:57.651 align:start position:14% line:-1
次はXcode 10に追加された拡張機能

00:31:57.751 --> 00:32:01.088 align:start position:16% line:-1
Set Extensionを紹介します

00:31:57.751 --> 00:32:01.088 align:start position:16% line:-1
Set Extensionを紹介します

00:32:02.923 --> 00:32:06.360 align:start position:20% line:-1
Appleには様々な端末があります

00:32:06.727 --> 00:32:10.931 align:start position:27% line:-2
Xcodeでは
少しビルド設定を行うだけで

00:32:11.031 --> 00:32:13.667 align:start position:25% line:-1
各端末にコードを互換できます

00:32:15.135 --> 00:32:20.641 align:start position:16% line:-2
macOS iOS watchOSなど
システム内で微調整を行い

00:32:20.741 --> 00:32:26.313 align:start position:27% line:-2
特定のハードウェアで
使えるコードを各端末で共有

00:32:26.413 --> 00:32:29.783 align:start position:27% line:-1
性能を最大限に引き出せます

00:32:31.151 --> 00:32:35.355 align:start position:32% line:-2
高い性能を必要とする
アプリケーションでも

00:32:35.455 --> 00:32:37.825 align:start position:32% line:-1
求める機能が使えます

00:32:39.726 --> 00:32:41.995 align:start position:30% line:-1
取り上げる３つの特徴は

00:32:42.095 --> 00:32:45.732 align:start position:0% line:-2
iMac Pro iPhone 8 iPhone 8 Plus
iPhone Xのものです

00:32:47.034 --> 00:32:48.769 align:start position:25% line:-1
iMac Proから始めます

00:32:51.238 --> 00:32:54.508 align:start position:4% line:-1
iMac ProはCPUにIntel Xeonを搭載

00:32:56.009 --> 00:33:00.214 align:start position:21% line:-2
AVX-512という新たな特徴を
備えています

00:32:56.009 --> 00:33:00.214 align:start position:21% line:-2
AVX-512という新たな特徴を
備えています

00:33:02.015 --> 00:33:06.320 align:start position:30% line:-2
AVX-512は
新しいベクトル指示です

00:33:08.689 --> 00:33:13.627 align:start position:23% line:-2
X86-64を上回る処理能力が
期待できます

00:33:13.727 --> 00:33:17.431 align:start position:20% line:-1
X86-64で想定できる処理容量は

00:33:17.531 --> 00:33:20.000 align:start position:25% line:-1
128ビットベクトル以下です

00:33:20.100 --> 00:33:24.204 align:start position:21% line:-2
Intelの動力源を持つMacに
対応可能です

00:33:25.038 --> 00:33:28.475 align:start position:23% line:-1
しかし現在の新型Macは進化し

00:33:28.709 --> 00:33:33.146 align:start position:25% line:-2
iMac Proでは初となる
512ビットレジスタを実現

00:33:35.649 --> 00:33:39.953 align:start position:25% line:-2
そこでClangの
自動ベクトル化機能が生きます

00:33:40.420 --> 00:33:45.592 align:start position:27% line:-2
ベクトルはいくつもの要素を
構成しているからです

00:33:46.260 --> 00:33:48.729 align:start position:32% line:-1
処理能力が向上します

00:33:51.198 --> 00:33:53.500 align:start position:25% line:-1
さらにAVX-512の利点に

00:33:53.767 --> 00:33:59.640 align:start position:29% line:-2
ベクトルレジスタが
増えたことが挙げられます

00:33:59.873 --> 00:34:05.612 align:start position:25% line:-2
X86-64の16個を上回る
32個でデータを管理します

00:33:59.873 --> 00:34:05.612 align:start position:25% line:-2
X86-64の16個を上回る
32個でデータを管理します

00:34:07.214 --> 00:34:13.454 align:start position:23% line:-2
自動ベクトル化機能が
これらのベクトルを生かせずとも

00:34:13.554 --> 00:34:19.025 align:start position:14% line:-2
スカラレジスタは増えており
float型 double型も対応します

00:34:20.060 --> 00:34:22.663 align:start position:27% line:-1
他にも多くの利点があります

00:34:24.164 --> 00:34:29.969 align:start position:29% line:-2
計算に負担のかかる関数を
例に取り上げてみましょう

00:34:31.772 --> 00:34:35.742 align:start position:21% line:-1
まずは既存の関数を備えておきます

00:34:36.009 --> 00:34:40.047 align:start position:25% line:-2
どのMacも
フォールバックとして有効です

00:34:41.681 --> 00:34:44.051 align:start position:30% line:-1
次に関数を特殊化します

00:34:44.150 --> 00:34:47.321 align:start position:23% line:-1
方法は属性のターゲット指定です

00:34:49.156 --> 00:34:52.292 align:start position:16% line:-1
iMac Proのみですが この関数に

00:34:52.391 --> 00:34:55.762 align:start position:30% line:-2
AVX-512の適用を
コンパイラに伝えます

00:34:57.331 --> 00:35:02.135 align:start position:23% line:-2
128ビットベクトルの
simd float4を使えば

00:34:57.331 --> 00:35:02.135 align:start position:23% line:-2
128ビットベクトルの
simd float4を使えば

00:35:02.603 --> 00:35:07.041 align:start position:25% line:-2
AVX-512を上回る性能に
なるかもしれません

00:35:09.109 --> 00:35:13.447 align:start position:25% line:-2
さらに大きい容量の
simd float16なら

00:35:13.547 --> 00:35:19.653 align:start position:20% line:-2
512ビットベクトルがネイティブの
性能を大きく超えるでしょう

00:35:21.955 --> 00:35:24.792 align:start position:27% line:-1
X86のモデルをご使用なら

00:35:24.892 --> 00:35:30.030 align:start position:20% line:-2
m512データ型と共に
AVX-512遷移をお試しください

00:35:32.766 --> 00:35:37.471 align:start position:25% line:-2
より大きなユニットのコードも
特殊化できます

00:35:37.871 --> 00:35:40.607 align:start position:32% line:-2
ファイル ターゲット
ライブラリなどです

00:35:40.741 --> 00:35:46.647 align:start position:25% line:-2
ベクトル拡張のビルド設定から
AVX-512の値が使えます

00:35:49.383 --> 00:35:51.752 align:start position:23% line:-1
AVX-1やAVX-2と同様―

00:35:51.919 --> 00:35:56.990 align:start position:32% line:-2
使用する時の注意点が
いくつかあります

00:35:58.759 --> 00:36:02.896 align:start position:20% line:-1
256ビット以上のベクトルであれば

00:35:58.759 --> 00:36:02.896 align:start position:20% line:-1
256ビット以上のベクトルであれば

00:36:03.130 --> 00:36:05.432 align:start position:23% line:-1
AVX-512関数は対応します

00:36:05.532 --> 00:36:09.603 align:start position:34% line:-2
特殊化してABIに
差異が出るようなら

00:36:09.703 --> 00:36:11.839 align:start position:36% line:-1
遷移はできません

00:36:14.074 --> 00:36:17.177 align:start position:27% line:-1
またベクトルの容量が大きく

00:36:17.277 --> 00:36:22.916 align:start position:18% line:-2
自然なアライメントを
mallocなどでは確保し切れません

00:36:23.116 --> 00:36:25.953 align:start position:27% line:-1
スタック以外に割り当てる際

00:36:26.420 --> 00:36:28.122 align:start position:36% line:-1
注意してください

00:36:30.457 --> 00:36:33.026 align:start position:27% line:-1
これらの注意事項はすべて―

00:36:33.126 --> 00:36:36.196 align:start position:23% line:-1
OS上で解決することができます

00:36:36.430 --> 00:36:41.468 align:start position:12% line:-2
Accelerateフレームワークを使えば
簡単に扱えます

00:36:41.568 --> 00:36:46.240 align:start position:32% line:-2
全関数を細部まで
特殊化済みだからです

00:36:48.542 --> 00:36:50.344 align:start position:32% line:-1
AVX-512でした

00:36:51.511 --> 00:36:56.583 align:start position:7% line:-2
次にiPhone 8 iPhone 8 Plus
iPhone Xの新しい特徴です

00:36:59.253 --> 00:37:04.024 align:start position:20% line:-2
最初に紹介するのは
ARMv8.1 Atomicsです

00:36:59.253 --> 00:37:04.024 align:start position:20% line:-2
最初に紹介するのは
ARMv8.1 Atomicsです

00:37:04.958 --> 00:37:10.164 align:start position:23% line:-2
iPhone Xの特徴の１つを
生かしています

00:37:10.464 --> 00:37:12.699 align:start position:23% line:-1
A11 Bionicチップです

00:37:16.336 --> 00:37:18.539 align:start position:34% line:-1
A10と比較すると

00:37:18.672 --> 00:37:22.910 align:start position:32% line:-2
このチップには
新たな特徴があります

00:37:23.010 --> 00:37:25.546 align:start position:27% line:-1
A11はiOSで初となる―

00:37:25.646 --> 00:37:30.450 align:start position:34% line:-2
６つのコアによる
同時処理が可能です

00:37:32.386 --> 00:37:37.057 align:start position:29% line:-2
そのため処理できる
スレッドも増えそうですが

00:37:37.157 --> 00:37:41.729 align:start position:32% line:-2
スレッドが増えれば
同期化が求められます

00:37:42.663 --> 00:37:44.631 align:start position:29% line:-1
そこでAtomicsです

00:37:45.666 --> 00:37:49.703 align:start position:30% line:-2
A11は新たな
アトミックの指示を導入

00:37:49.803 --> 00:37:55.175 align:start position:27% line:-2
使い切れていなかったコアを
最大限に活用します

00:37:57.377 --> 00:37:58.712 align:start position:36% line:-1
詳しく解説します

00:38:00.614 --> 00:38:05.419 align:start position:27% line:-2
アトミックは一連のコードを
介して機能します

00:38:05.886 --> 00:38:09.990 align:start position:27% line:-2
スレッドからメインメモリに
アクセスしてみます

00:38:10.424 --> 00:38:13.527 align:start position:27% line:-1
アトミックな共有変数を持ち

00:38:13.694 --> 00:38:15.396 align:start position:32% line:-1
インクリメントします

00:38:17.431 --> 00:38:21.468 align:start position:30% line:-2
システム下で
一連のコードが生成され

00:38:21.969 --> 00:38:25.772 align:start position:34% line:-2
キャッシュラインに
独占的にアクセス

00:38:25.939 --> 00:38:31.245 align:start position:27% line:-2
アトミック変数のみの
小さなメモリ領域ができます

00:38:33.714 --> 00:38:37.184 align:start position:27% line:-1
その後 変数をロードします

00:38:37.284 --> 00:38:40.587 align:start position:30% line:-2
一時的にロードした値を
インクリメントし

00:38:40.754 --> 00:38:42.689 align:start position:38% line:-1
結果を返します

00:38:44.858 --> 00:38:47.561 align:start position:30% line:-1
独占的なアクセスなので

00:38:47.661 --> 00:38:52.633 align:start position:25% line:-2
値を変えるような
別のスレッドは受け付けません

00:38:53.934 --> 00:38:56.603 align:start position:25% line:-1
しかし同じキャッシュラインに

00:38:56.703 --> 00:39:00.340 align:start position:32% line:-2
別のスレッドが
アクセスしたとします

00:38:56.703 --> 00:39:00.340 align:start position:32% line:-2
別のスレッドが
アクセスしたとします

00:39:02.676 --> 00:39:07.047 align:start position:25% line:-2
両スレッドが
変数へのアクセスを試みますが

00:39:07.581 --> 00:39:10.784 align:start position:25% line:-1
独占的なアクセスになりません

00:39:12.152 --> 00:39:16.056 align:start position:27% line:-2
そのため
どちらもアクセス失敗となり

00:39:16.523 --> 00:39:19.693 align:start position:29% line:-1
成功するまで繰り返します

00:39:21.995 --> 00:39:24.131 align:start position:30% line:-1
これは性能に影響します

00:39:25.933 --> 00:39:31.271 align:start position:20% line:-2
A11のCPUアーキテクチャである
ARMv8.1なら

00:39:31.371 --> 00:39:34.074 align:start position:27% line:-1
１つのステップで処理します

00:39:34.341 --> 00:39:37.010 align:start position:29% line:-1
飛躍的な改善も見込めます

00:39:38.412 --> 00:39:41.348 align:start position:30% line:-1
これは各関数の特殊化や

00:39:41.448 --> 00:39:46.253 align:start position:29% line:-2
ターゲットを示すコードを
特殊化してくれます

00:39:47.154 --> 00:39:52.459 align:start position:14% line:-2
C11かC++11のAtomicsのみに
非常に有効です

00:39:52.993 --> 00:39:55.963 align:start position:21% line:-1
GCDやPThreadといった―

00:39:56.063 --> 00:39:59.833 align:start position:32% line:-2
高水準なライブラリが
手軽に使えます

00:40:00.834 --> 00:40:03.103 align:start position:21% line:-1
ARMv8.1用に調整済みですが

00:40:03.203 --> 00:40:07.174 align:start position:30% line:-2
OSと連動させて
より性能を引き出せます

00:40:11.111 --> 00:40:15.716 align:start position:29% line:-2
A11の別の特徴は
16ビット浮動小数点です

00:40:16.250 --> 00:40:21.255 align:start position:25% line:-2
２種類の標準的な浮動小数点は
よくご存知でしょう

00:40:21.355 --> 00:40:25.259 align:start position:29% line:-2
64ビットと32ビットの
浮動小数点です

00:40:26.093 --> 00:40:30.397 align:start position:25% line:-2
A11では
さらに16ビットが加わります

00:40:30.964 --> 00:40:34.735 align:start position:21% line:-1
これは桁数が少なく精度も低いため

00:40:34.902 --> 00:40:37.471 align:start position:32% line:-1
大抵 役に立ちません

00:40:38.072 --> 00:40:44.578 align:start position:20% line:-2
しかし機械学習やMetalを介した
GPUの使用などに適しています

00:40:45.412 --> 00:40:47.814 align:start position:29% line:-1
ベクトルの容量が同じなら

00:40:47.915 --> 00:40:51.051 align:start position:32% line:-1
より多く配置できます

00:40:53.354 --> 00:40:56.323 align:start position:23% line:-1
これもコードの特殊化が可能です

00:40:56.857 --> 00:41:02.596 align:start position:25% line:-2
これらの特徴は どの端末でも
使えるわけではありません

00:40:56.857 --> 00:41:02.596 align:start position:25% line:-2
これらの特徴は どの端末でも
使えるわけではありません

00:41:03.430 --> 00:41:07.568 align:start position:21% line:-1
実行中の端末で動的に対応できるか

00:41:07.668 --> 00:41:09.937 align:start position:34% line:-1
常に確認が必要です

00:41:10.404 --> 00:41:12.639 align:start position:18% line:-1
sysctlbynameを利用します

00:41:14.074 --> 00:41:19.213 align:start position:20% line:-2
System frameworkに
対応を委ねても構いません

00:41:21.782 --> 00:41:24.351 align:start position:30% line:-1
３つの特徴をまとめます

00:41:24.451 --> 00:41:27.521 align:start position:14% line:-1
iMac Proに備わったAVX-512

00:41:27.621 --> 00:41:31.125 align:start position:20% line:-2
各種iPhoneはAtomicsと
16ビット浮動小数点でした

00:41:33.727 --> 00:41:36.964 align:start position:25% line:-1
Xcodeの新機能は以上です

00:41:37.197 --> 00:41:39.933 align:start position:27% line:-1
本日 紹介した機能以外にも

00:41:40.033 --> 00:41:44.271 align:start position:29% line:-2
Xcode 10は
様々な機能を備えています

00:41:44.972 --> 00:41:48.142 align:start position:25% line:-1
100種類以上の新しい警告や

00:41:48.242 --> 00:41:54.014 align:start position:20% line:-2
C++17の標準的なライブラリなど
まだまだあります

00:41:55.749 --> 00:42:00.788 align:start position:29% line:-2
より詳しく知りたい人は
デベロッパWebサイトや

00:41:55.749 --> 00:42:00.788 align:start position:29% line:-2
より詳しく知りたい人は
デベロッパWebサイトや

00:42:01.088 --> 00:42:04.525 align:start position:29% line:-1
ラボにお立ち寄りください

00:42:05.092 --> 00:42:05.659 align:start position:30% line:-1
ありがとうございました

00:42:05.759 --> 00:42:12.266 align:start position:43% line:-1
(拍手)
