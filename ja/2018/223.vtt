WEBVTT

00:00:07.040 --> 00:00:16.550 align:start position:43% line:-1
(音楽)

00:00:16.683 --> 00:00:23.423 align:start position:43% line:-1
(拍手)

00:00:23.524 --> 00:00:26.827 align:start position:27% line:-1
ご来場ありがとうございます

00:00:27.194 --> 00:00:30.597 align:start position:25% line:-1
これから40分間 私デイブが

00:00:30.697 --> 00:00:36.136 align:start position:29% line:-2
私たちのプログラムが動く
仕組みをお話しします

00:00:36.670 --> 00:00:42.342 align:start position:29% line:-2
ただし 技術的なヒントや
特定のアルゴリズムが

00:00:42.442 --> 00:00:46.180 align:start position:27% line:-1
この話の主題ではありません

00:00:47.047 --> 00:00:51.451 align:start position:29% line:-2
目的は コードに内在する
根幹的なものを

00:00:51.552 --> 00:00:53.654 align:start position:32% line:-1
明らかにすることです

00:00:55.222 --> 00:00:59.693 align:start position:34% line:-2
プログラミングとの
新たな関係性を―

00:00:59.793 --> 00:01:01.428 align:start position:32% line:-1
提供できれば幸いです

00:00:59.793 --> 00:01:01.428 align:start position:32% line:-1
提供できれば幸いです

00:01:02.095 --> 00:01:04.798 align:start position:30% line:-1
このアプローチの発見で

00:01:04.897 --> 00:01:07.868 align:start position:23% line:-1
私のキャリアに転機が訪れました

00:01:08.335 --> 00:01:13.307 align:start position:25% line:-2
私がソフトウェアライブラリを
重視する理由であり

00:01:13.407 --> 00:01:19.780 align:start position:23% line:-2
コードの信頼性 保守性
パフォーマンスにもつながります

00:01:20.747 --> 00:01:24.785 align:start position:27% line:-2
本題の前に
友人を１人ご紹介しましょう

00:01:26.854 --> 00:01:29.423 align:start position:34% line:-1
“クラスティ”です

00:01:29.523 --> 00:01:31.925 align:start position:43% line:-1
(拍手)

00:01:32.025 --> 00:01:34.795 align:start position:30% line:-1
彼は古いタイプの人間で

00:01:34.895 --> 00:01:40.501 align:start position:23% line:-2
デバッガを信用せず
統合開発環境には目も向けません

00:01:40.701 --> 00:01:46.773 align:start position:25% line:-2
彼が好むのは80文字24行の
ターミナルウィンドウです

00:01:47.541 --> 00:01:51.378 align:start position:34% line:-2
現代の流れに逆らう
彼のような人物を

00:01:51.478 --> 00:01:55.482 align:start position:20% line:-1
21世紀に引きずり込むのは大変です

00:01:56.049 --> 00:01:57.985 align:start position:36% line:-1
考え方が違います

00:01:58.552 --> 00:02:02.389 align:start position:21% line:-1
ただ 学べる点もいくつかあります

00:01:58.552 --> 00:02:02.389 align:start position:21% line:-1
ただ 学べる点もいくつかあります

00:02:03.490 --> 00:02:06.660 align:start position:29% line:-1
例えば 彼はこう言います

00:02:06.894 --> 00:02:11.031 align:start position:34% line:-2
“プログラミングは
真実を解き明かす”

00:02:11.398 --> 00:02:15.736 align:start position:30% line:-2
これを理解するため
コードを書いてみました

00:02:17.404 --> 00:02:20.507 align:start position:18% line:-1
“Shapes”というプログラムです

00:02:21.575 --> 00:02:24.878 align:start position:25% line:-1
今は形状の配置機能だけですが

00:02:24.978 --> 00:02:29.249 align:start position:29% line:-2
将来的に描画機能の追加も
目指しています

00:02:30.317 --> 00:02:33.887 align:start position:30% line:-2
まず注目するのは
“選択を削除”コマンド

00:02:33.987 --> 00:02:38.659 align:start position:32% line:-2
この実装を通じて
私は多くを学びました

00:02:39.326 --> 00:02:42.095 align:start position:30% line:-1
配列からの削除を学ぶ際

00:02:42.196 --> 00:02:47.267 align:start position:27% line:-2
恐らく皆さんも
似た経験をしたことでしょう

00:02:47.701 --> 00:02:50.804 align:start position:27% line:-1
大抵は こんな風に始めます

00:02:53.807 --> 00:02:55.709 align:start position:38% line:-1
これが削除です

00:02:58.946 --> 00:03:00.914 align:start position:34% line:-1
ループで０から数え

00:02:58.946 --> 00:03:00.914 align:start position:34% line:-1
ループで０から数え

00:03:02.316 --> 00:03:05.752 align:start position:30% line:-2
目的の位置で
“削除”を呼び出します

00:03:06.086 --> 00:03:08.856 align:start position:30% line:-1
そしてループが続いて…

00:03:09.122 --> 00:03:10.157 align:start position:45% line:-1
おっと

00:03:10.791 --> 00:03:12.159 align:start position:39% line:-1
問題発生です

00:03:13.260 --> 00:03:17.431 align:start position:25% line:-2
反復回数より
配列が短くなってしまいました

00:03:17.798 --> 00:03:23.570 align:start position:27% line:-2
幸い Swiftのテストで
このバグは発見できます

00:03:23.837 --> 00:03:29.376 align:start position:25% line:-2
しかしＣ言語だと
そう簡単にはいかないでしょう

00:03:29.843 --> 00:03:35.549 align:start position:20% line:-2
これを修正する場合
forループをwhileループにし

00:03:35.649 --> 00:03:38.418 align:start position:27% line:-1
各反復でカウントを調べます

00:03:39.720 --> 00:03:43.090 align:start position:23% line:-1
しかし これにもバグはあります

00:03:43.857 --> 00:03:49.363 align:start position:27% line:-2
隣り合う２つの要素を選択し
１つ目を削除すると―

00:03:50.664 --> 00:03:53.033 align:start position:32% line:-1
続く要素が移動します

00:03:54.334 --> 00:03:57.371 align:start position:30% line:-1
このバグは少し厄介です

00:03:57.471 --> 00:04:01.308 align:start position:30% line:-2
テストを実行しない限り
見つかりません

00:03:57.471 --> 00:04:01.308 align:start position:30% line:-2
テストを実行しない限り
見つかりません

00:04:02.843 --> 00:04:05.279 align:start position:34% line:-1
運良く気付けた場合

00:04:05.412 --> 00:04:10.984 align:start position:21% line:-2
インクリメントを
elseブロックで囲み修正します

00:04:12.586 --> 00:04:16.857 align:start position:29% line:-2
これで本当に
うまくいったでしょうか？

00:04:17.591 --> 00:04:21.261 align:start position:27% line:-1
恐らく問題なく動くはずです

00:04:21.762 --> 00:04:25.532 align:start position:23% line:-1
これで試練を１つ乗り越えました

00:04:25.632 --> 00:04:29.269 align:start position:27% line:-1
この９行を頭にたたき込めば

00:04:29.369 --> 00:04:32.773 align:start position:25% line:-1
将来 削除をする時に使えます

00:04:33.974 --> 00:04:38.045 align:start position:21% line:-1
ただ 異論のある人もいるでしょう

00:04:38.145 --> 00:04:41.315 align:start position:23% line:-1
もっといい方法がありますからね

00:04:41.715 --> 00:04:44.885 align:start position:23% line:-1
いったん この方法を見つければ

00:04:44.985 --> 00:04:48.789 align:start position:23% line:-1
前の９行は もう必要ありません

00:04:49.556 --> 00:04:53.727 align:start position:29% line:-2
反復制限と次のアイテムの
インデックスは

00:04:53.827 --> 00:04:57.531 align:start position:18% line:-2
“remove(at: i)”により
常に変わります

00:04:57.631 --> 00:05:01.468 align:start position:30% line:-2
ｉのあとの配列の一部が
変わるからです

00:04:57.631 --> 00:05:01.468 align:start position:30% line:-2
ｉのあとの配列の一部が
変わるからです

00:05:03.904 --> 00:05:09.243 align:start position:25% line:-2
でも後ろ向きなら
未変更の配列の反復で済みます

00:05:09.943 --> 00:05:14.314 align:start position:30% line:-2
この方法なら
不具合も起こらないので

00:05:14.448 --> 00:05:17.251 align:start position:32% line:-1
私は愛用してきました

00:05:18.352 --> 00:05:19.887 align:start position:38% line:-1
でも数ヵ月前―

00:05:21.255 --> 00:05:25.626 align:start position:29% line:-2
アプリケーションを
いじっていた時のことです

00:05:25.726 --> 00:05:32.065 align:start position:23% line:-2
複雑なキャンバスから
図形の半分を削除しようとしたら

00:05:33.000 --> 00:05:36.703 align:start position:20% line:-1
iPadが３秒ほどフリーズしました

00:05:37.938 --> 00:05:42.910 align:start position:27% line:-2
私はサーマルカップに入れた
ラテを飲みながら

00:05:43.010 --> 00:05:46.346 align:start position:27% line:-1
取り得る選択肢を考えました

00:05:47.548 --> 00:05:51.485 align:start position:34% line:-2
コードはクリーンで
処理も単純なのに

00:05:51.585 --> 00:05:54.688 align:start position:27% line:-1
何が悪かったのでしょうか？

00:05:56.390 --> 00:05:59.760 align:start position:29% line:-2
調べると
ホットスポットはここです

00:06:00.494 --> 00:06:02.429 align:start position:38% line:-1
私は困りました

00:06:03.730 --> 00:06:08.468 align:start position:27% line:-2
その時 コーヒー豆を抱えた
クラスティが現れ

00:06:08.569 --> 00:06:11.939 align:start position:32% line:-1
こう聞いてきたんです

00:06:12.773 --> 00:06:14.842 align:start position:36% line:-1
“お手上げか？”

00:06:15.943 --> 00:06:19.513 align:start position:21% line:-1
私はうなずき 状況を説明しました

00:06:22.549 --> 00:06:26.086 align:start position:23% line:-2
“関連のドキュメンテーションは
見たのか？”

00:06:27.721 --> 00:06:33.227 align:start position:21% line:-2
私は“remove(at:)”の
クイックヘルプを見てみました

00:06:34.561 --> 00:06:36.530 align:start position:30% line:-1
“ほら 問題はそこだ”

00:06:37.865 --> 00:06:41.368 align:start position:32% line:-2
と言って 画面に
指紋を付けてきました

00:06:44.304 --> 00:06:48.976 align:start position:30% line:-2
私は その指紋を
クロスで拭き取りました

00:06:50.344 --> 00:06:53.747 align:start position:29% line:-1
“どうだ 分かったか？”

00:06:54.982 --> 00:06:56.350 align:start position:38% line:-1
私は答えました

00:06:56.617 --> 00:07:00.220 align:start position:30% line:-2
“配列の長さに比例した
ステップ数が―”

00:06:56.617 --> 00:07:00.220 align:start position:30% line:-2
“配列の長さに比例した
ステップ数が―”

00:07:00.320 --> 00:07:02.856 align:start position:29% line:-1
“要素の削除には必要だ”

00:07:03.357 --> 00:07:07.928 align:start position:32% line:-2
配列では後続の要素は
新たな位置に動くので

00:07:08.028 --> 00:07:09.663 align:start position:38% line:-1
理にかないます

00:07:11.231 --> 00:07:15.335 align:start position:27% line:-2
“そのことと
選択を削除との関連性は？”

00:07:16.069 --> 00:07:17.971 align:start position:39% line:-1
私は考えます

00:07:20.374 --> 00:07:24.444 align:start position:32% line:-2
彼はのど飴を取り出し
並べ始めました

00:07:24.678 --> 00:07:25.979 align:start position:38% line:-1
“試してみろ”

00:07:27.047 --> 00:07:30.717 align:start position:34% line:-2
“選択を削除”では
選択した要素ごとに

00:07:30.818 --> 00:07:33.587 align:start position:29% line:-1
O(n)の処理を行います

00:07:33.687 --> 00:07:37.057 align:start position:23% line:-1
選択できるのはｎ個までの要素で

00:07:37.157 --> 00:07:41.261 align:start position:29% line:-2
ステップ総数はｎの２乗に
比例します

00:07:42.496 --> 00:07:45.065 align:start position:29% line:-1
クラスティは付け加えます

00:07:45.165 --> 00:07:49.169 align:start position:30% line:-2
“順方向でも逆方向でも
それは二次式だ”

00:07:52.005 --> 00:07:56.944 align:start position:29% line:-2
要素の数が10から20の
小さなテストの場合

00:07:57.044 --> 00:07:59.780 align:start position:29% line:-1
ステップ数は数百のみです

00:07:59.880 --> 00:08:03.250 align:start position:30% line:-1
速さも申し分ありません

00:07:59.880 --> 00:08:03.250 align:start position:30% line:-1
速さも申し分ありません

00:08:04.051 --> 00:08:06.620 align:start position:30% line:-1
問題は数が増えた時です

00:08:07.788 --> 00:08:12.292 align:start position:32% line:-2
50の２乗は2500
100の２乗なら１万

00:08:13.627 --> 00:08:19.132 align:start position:23% line:-2
テストが左下の小さな範囲内なら
問題はないでしょう

00:08:19.233 --> 00:08:24.338 align:start position:29% line:-2
しかし 人々が管理する
データ量は増え続けており

00:08:24.438 --> 00:08:29.943 align:start position:29% line:-2
それに伴い デバイスの
メモリ容量も増えています

00:08:30.511 --> 00:08:35.682 align:start position:27% line:-2
予測されるニーズにとって
スケーラビリティは重要です

00:08:37.818 --> 00:08:43.123 align:start position:27% line:-2
問題は分かりましたが
どう対応すべきでしょうか？

00:08:43.222 --> 00:08:47.261 align:start position:27% line:-2
クラスティは
飴を口に入れながら言います

00:08:47.361 --> 00:08:51.131 align:start position:21% line:-1
“そのためのアルゴリズムがある”

00:08:53.267 --> 00:08:57.571 align:start position:25% line:-2
しかし私はアプリケーションの
デベロッパです

00:08:58.105 --> 00:09:03.043 align:start position:32% line:-2
アルゴリズムのことは
専門外になります

00:08:58.105 --> 00:09:03.043 align:start position:32% line:-2
アルゴリズムのことは
専門外になります

00:09:03.143 --> 00:09:06.180 align:start position:27% line:-1
アルゴリズムのデータ構造も

00:09:06.280 --> 00:09:11.151 align:start position:29% line:-2
仕事の面接対策で
勉強した程度にすぎません

00:09:11.251 --> 00:09:15.989 align:start position:30% line:-2
実際のプログラミングで
新人と一流を分けるのは

00:09:16.089 --> 00:09:21.195 align:start position:29% line:-2
コントローラなどをまとめ
システムを作る能力です

00:09:22.896 --> 00:09:26.033 align:start position:25% line:-1
“間抜けめ”と彼は言いました

00:09:27.401 --> 00:09:29.036 align:start position:27% line:-1
“コンピュータの仕事は？”

00:09:30.037 --> 00:09:30.871 align:start position:43% line:-1
計算です

00:09:31.672 --> 00:09:34.007 align:start position:29% line:-1
“どこに計算の方法が？”

00:09:35.576 --> 00:09:40.848 align:start position:25% line:-2
私のコードに
アルゴリズムは見当たりません

00:09:42.082 --> 00:09:43.617 align:start position:38% line:-1
彼は否定します

00:09:43.784 --> 00:09:49.356 align:start position:25% line:-2
“そんなことはない
この辞書で意味を調べてみろ”

00:09:51.158 --> 00:09:53.660 align:start position:34% line:-1
私は辞書を脇によけ

00:09:53.827 --> 00:10:00.167 align:start position:21% line:-2
“アルゴリズムの定義”と
Spotlightに入力しました

00:09:53.827 --> 00:10:00.167 align:start position:21% line:-2
“アルゴリズムの定義”と
Spotlightに入力しました

00:10:04.171 --> 00:10:10.944 align:start position:25% line:-2
“演算手続き･問題解決の
プロセスまたは一連のルール”

00:10:11.979 --> 00:10:17.317 align:start position:27% line:-2
確かにコードに似ていますが
確証は持てません

00:10:17.951 --> 00:10:21.889 align:start position:25% line:-2
“筆算だってアルゴリズムだ”
彼は言います

00:10:25.626 --> 00:10:30.097 align:start position:16% line:-2
再びSpotlightに入力しかかると
“紙に！”と言われ

00:10:30.197 --> 00:10:33.901 align:start position:21% line:-1
困って 話題をコードに戻しました

00:10:36.470 --> 00:10:37.504 align:start position:45% line:-1
では―

00:10:38.305 --> 00:10:43.177 align:start position:27% line:-2
どんなアルゴリズムが
私の問題を解決できますか？

00:10:44.044 --> 00:10:47.481 align:start position:32% line:-2
“手本を見せる
お前のマシンを貸せ”

00:10:47.581 --> 00:10:50.984 align:start position:21% line:-1
“トラックパッドをオフにして…”

00:10:51.084 --> 00:10:54.354 align:start position:23% line:-1
“まずは この役立たずを消す”

00:10:56.590 --> 00:11:02.563 align:start position:11% line:-2
“そしてshapes.removeAll…と
入力”

00:10:56.590 --> 00:11:02.563 align:start position:11% line:-2
“そしてshapes.removeAll…と
入力”

00:11:03.096 --> 00:11:05.599 align:start position:27% line:-1
“さあ これで試してみろ”

00:11:06.133 --> 00:11:09.503 align:start position:27% line:-1
クラスティは席を離れました

00:11:09.603 --> 00:11:13.540 align:start position:23% line:-1
私にコードを検証させるためです

00:11:14.875 --> 00:11:20.614 align:start position:25% line:-2
調べてみると コードの問題は
解決されていました

00:11:21.548 --> 00:11:25.419 align:start position:23% line:-1
次に 私はクイックヘルプを開き

00:11:25.519 --> 00:11:28.522 align:start position:14% line:-2
“removeAll(where:)”を
調べました

00:11:30.157 --> 00:11:35.662 align:start position:20% line:-2
“remove(at:)”のように
計算量はコレクションの長さに

00:11:35.762 --> 00:11:37.431 align:start position:36% line:-1
比例するようです

00:11:37.698 --> 00:11:40.634 align:start position:27% line:-1
でもループには入れないので

00:11:40.901 --> 00:11:43.704 align:start position:21% line:-1
これが すべての処理の計算量です

00:11:44.471 --> 00:11:49.042 align:start position:25% line:-2
これがもたらす
違いの一部をご紹介しましょう

00:11:50.444 --> 00:11:56.517 align:start position:25% line:-2
ｎが意味する アルゴリズムの
実行時間と問題のサイズは

00:11:56.617 --> 00:11:58.318 align:start position:38% line:-1
線形比例します

00:11:59.286 --> 00:12:02.456 align:start position:27% line:-1
オレンジはｎの２乗の線です

00:11:59.286 --> 00:12:02.456 align:start position:27% line:-1
オレンジはｎの２乗の線です

00:12:03.257 --> 00:12:07.494 align:start position:29% line:-2
一次のアルゴリズムは
小さな問題では効率が悪く

00:12:07.594 --> 00:12:10.898 align:start position:25% line:-1
徐々に二次よりも高くなります

00:12:11.798 --> 00:12:17.771 align:start position:25% line:-2
ちなみに一次のアルゴリズムの
コストがいくら高くても

00:12:18.205 --> 00:12:21.241 align:start position:29% line:-1
それは問題ではありません

00:12:22.142 --> 00:12:28.515 align:start position:21% line:-2
問題のサイズが大きくなれば
ある点以降 一次が常に上回ります

00:12:29.216 --> 00:12:33.420 align:start position:29% line:-2
なお これは
スケーラビリティの話です

00:12:36.356 --> 00:12:41.094 align:start position:23% line:-2
さて スケーラビリティの問題は
解決しましたが

00:12:41.195 --> 00:12:46.934 align:start position:20% line:-2
逆方向の削除に対して
標準ライブラリはどう改善するのか？

00:12:47.901 --> 00:12:51.471 align:start position:21% line:-1
Swiftはオープンソースなので

00:12:51.572 --> 00:12:55.609 align:start position:18% line:-1
GitHubからデータを引き出せます

00:12:59.146 --> 00:13:02.182 align:start position:23% line:-1
目に付くのはコメントの部分です

00:12:59.146 --> 00:13:02.182 align:start position:23% line:-1
目に付くのはコメントの部分です

00:13:02.549 --> 00:13:04.885 align:start position:29% line:-1
クイックヘルプのソースで

00:13:04.985 --> 00:13:09.556 align:start position:25% line:-2
アルゴリズムの動きと計算量を
記述しています

00:13:11.325 --> 00:13:17.264 align:start position:11% line:-2
次に“removeAll(where:)”は
単なるメソッドではありません

00:13:17.664 --> 00:13:19.500 align:start position:34% line:-1
汎用アルゴリズムで

00:13:19.600 --> 00:13:23.437 align:start position:23% line:-1
他のコレクションでも動作します

00:13:24.171 --> 00:13:26.206 align:start position:34% line:-1
主な機能は次の２つ

00:13:27.074 --> 00:13:30.777 align:start position:14% line:-2
要素を並べ替える
“MutableCollection”と

00:13:31.011 --> 00:13:38.085 align:start position:0% line:-2
長さと構造を変える
“RangeReplaceableCollection”

00:13:39.620 --> 00:13:43.590 align:start position:29% line:-2
ベースは複数の
O(n)アルゴリズムです

00:13:43.891 --> 00:13:46.994 align:start position:12% line:-2
１つ目は
“halfStablePartition”

00:13:47.094 --> 00:13:51.231 align:start position:30% line:-2
ある述語を満たす要素を
後ろに移動し―

00:13:52.900 --> 00:13:55.235 align:start position:30% line:-1
接尾辞の先頭を示します

00:13:56.036 --> 00:13:59.873 align:start position:27% line:-2
“halfStable”は
“半安定”という意味です

00:13:59.973 --> 00:14:04.144 align:start position:21% line:-1
動かない要素の順序は保持しますが

00:13:59.973 --> 00:14:04.144 align:start position:21% line:-1
動かない要素の順序は保持しますが

00:14:04.344 --> 00:14:07.748 align:start position:21% line:-1
後ろに移動する要素は入れ換えます

00:14:09.082 --> 00:14:15.489 align:start position:16% line:-2
次の“removeSubrange”は
場合により下位範囲を削除します

00:14:16.690 --> 00:14:19.092 align:start position:36% line:-1
部分範囲の表記は

00:14:20.093 --> 00:14:24.498 align:start position:25% line:-2
コレクションの終わりの範囲を
記すのに便利です

00:14:26.800 --> 00:14:32.239 align:start position:20% line:-2
“removeSubrange”は
パブリックAPIの一部ですが

00:14:32.339 --> 00:14:38.078 align:start position:11% line:-2
“halfStablePartition”は
実装の詳細になります

00:14:41.081 --> 00:14:45.519 align:start position:32% line:-2
ここでは 一部だけを
取り上げます

00:14:46.420 --> 00:14:51.692 align:start position:27% line:-2
まず 接尾辞の先頭の要素の
位置を検索する―

00:14:51.825 --> 00:14:56.296 align:start position:12% line:-2
“firstIndex(where:)”を
呼び出します

00:14:57.097 --> 00:14:59.333 align:start position:32% line:-1
ループ変数をｊに設定

00:14:59.433 --> 00:15:02.402 align:start position:30% line:-1
ループインデックスｊが

00:14:59.433 --> 00:15:02.402 align:start position:30% line:-1
ループインデックスｊが

00:15:02.970 --> 00:15:07.040 align:start position:23% line:-1
反復ごとに１つを前に動かします

00:15:07.541 --> 00:15:11.111 align:start position:21% line:-1
ｊが要素を１回 通過するわけです

00:15:12.679 --> 00:15:15.782 align:start position:27% line:-1
順序と計算量が見てとれます

00:15:20.420 --> 00:15:26.059 align:start position:21% line:-2
最後に このメソッドは
長さを変えず要素を再配置するため

00:15:26.159 --> 00:15:29.163 align:start position:34% line:-2
可変コレクションの
適合性に依存します

00:15:31.031 --> 00:15:33.100 align:start position:34% line:-1
これが私の学んだ―

00:15:33.534 --> 00:15:36.603 align:start position:23% line:-1
Swiftの標準ライブラリです

00:15:37.070 --> 00:15:39.506 align:start position:29% line:-1
性能特性が文書化された―

00:15:39.640 --> 00:15:42.676 align:start position:32% line:-2
一連のアルゴリズムが
含まれています

00:15:43.310 --> 00:15:46.213 align:start position:27% line:-1
実装についても触れましたが

00:15:46.847 --> 00:15:51.318 align:start position:30% line:-2
それなしでも使えるよう
設計されています

00:15:52.319 --> 00:15:58.392 align:start position:25% line:-2
ライブラリを効率的に使うには
公式ドキュメントが便利です

00:15:58.892 --> 00:16:01.261 align:start position:14% line:-1
“Playground”の解説もあります

00:15:58.892 --> 00:16:01.261 align:start position:14% line:-1
“Playground”の解説もあります

00:16:01.795 --> 00:16:05.799 align:start position:32% line:-2
内容が盛りだくさんで
大変に見えますが

00:16:06.066 --> 00:16:08.101 align:start position:29% line:-1
全部 覚えなくても大丈夫

00:16:08.569 --> 00:16:13.106 align:start position:30% line:-2
内容に触れて知るだけで
次につながります

00:16:14.608 --> 00:16:16.944 align:start position:29% line:-1
最後に クラスティによる

00:16:17.477 --> 00:16:20.647 align:start position:29% line:-1
別の教えも紹介しましょう

00:16:21.048 --> 00:16:24.117 align:start position:25% line:-1
左右どちらが簡潔明快ですか？

00:16:25.152 --> 00:16:29.490 align:start position:32% line:-2
左の場合 読んで
考える必要があります

00:16:29.957 --> 00:16:32.125 align:start position:30% line:-1
コメントも加えましょう

00:16:32.693 --> 00:16:37.698 align:start position:29% line:-2
ただ コメントを付けても
逆順の反復は厄介です

00:16:37.798 --> 00:16:42.836 align:start position:29% line:-2
他の人も触れるよう
さらに説明を加えましょう

00:16:45.105 --> 00:16:46.006 align:start position:43% line:-1
一方で―

00:16:46.106 --> 00:16:51.879 align:start position:25% line:-2
右のコードは末尾クロージャで
より明快です

00:16:53.547 --> 00:16:55.649 align:start position:30% line:-1
では 再びご覧ください

00:16:56.483 --> 00:16:58.819 align:start position:30% line:-1
どちらが正しいですか？

00:16:59.386 --> 00:17:02.723 align:start position:27% line:-1
左はコメントが付いていても

00:16:59.386 --> 00:17:02.723 align:start position:27% line:-1
左はコメントが付いていても

00:17:02.823 --> 00:17:07.361 align:start position:30% line:-2
比べると 右の方が
ずっと効率的に見えます

00:17:07.961 --> 00:17:11.298 align:start position:23% line:-1
アルゴリズムを使ったおかげです

00:17:13.599 --> 00:17:18.806 align:start position:27% line:-2
ショーン･ペアレントは
コードの指針を提案しました

00:17:19.506 --> 00:17:23.343 align:start position:27% line:-2
“ループは アルゴリズムの
呼び出しで置き換える”

00:17:23.743 --> 00:17:28.982 align:start position:21% line:-2
“ない場合は自作し
そのアルゴリズムにループを移す”

00:17:30.851 --> 00:17:33.821 align:start position:25% line:-1
その意味を理解いただけるよう

00:17:33.921 --> 00:17:37.291 align:start position:23% line:-1
さらに説明を続けたいと思います

00:17:37.925 --> 00:17:40.727 align:start position:25% line:-1
そこで 皆さんが最後に見た―

00:17:40.828 --> 00:17:43.931 align:start position:32% line:-2
スパゲッティコードを
思い出してください

00:17:45.265 --> 00:17:48.602 align:start position:27% line:-1
ループだらけ？　でしょうね

00:17:50.904 --> 00:17:52.272 align:start position:38% line:-1
では こちらを

00:17:52.372 --> 00:17:57.077 align:start position:27% line:-2
速度も簡潔さも勝るコードを
書いてみました

00:17:57.377 --> 00:18:01.148 align:start position:27% line:-1
私はクラスティに礼を言い―

00:17:57.377 --> 00:18:01.148 align:start position:27% line:-1
私はクラスティに礼を言い―

00:18:01.248 --> 00:18:06.019 align:start position:32% line:-2
仕事を切り上げて
帰り支度を始めました

00:18:06.120 --> 00:18:09.223 align:start position:23% line:-1
しかし 彼は疑念の目を向けます

00:18:09.323 --> 00:18:12.793 align:start position:23% line:-1
“とんでもないミスをしてるぞ”

00:18:14.027 --> 00:18:19.099 align:start position:25% line:-2
私は帰るのを諦め
コードのループを探し始めます

00:18:19.967 --> 00:18:22.536 align:start position:30% line:-1
ファイルのコマンドは―

00:18:24.304 --> 00:18:25.372 align:start position:39% line:-1
最前面に移動

00:18:27.107 --> 00:18:28.208 align:start position:39% line:-1
最背面に移動

00:18:29.810 --> 00:18:33.781 align:start position:25% line:-1
選択した図形を１つ前面に移動

00:18:34.715 --> 00:18:36.450 align:start position:36% line:-1
繰り返しましょう

00:18:38.252 --> 00:18:42.389 align:start position:25% line:-1
選択した図形を１つ背面に移動

00:18:43.690 --> 00:18:47.127 align:start position:23% line:-1
最後に 左のリスト内で直接移動

00:18:49.696 --> 00:18:53.634 align:start position:21% line:-1
操作自体はシンプルに見えますよね

00:18:54.101 --> 00:18:58.305 align:start position:32% line:-2
でも隣接しない図形を
複数 選んでも

00:18:58.405 --> 00:19:02.309 align:start position:23% line:-1
正しく動作させる必要があります

00:18:58.405 --> 00:19:02.309 align:start position:23% line:-1
正しく動作させる必要があります

00:19:05.512 --> 00:19:09.716 align:start position:30% line:-2
理にかなうのは
選択された複数の要素を

00:19:09.817 --> 00:19:12.519 align:start position:30% line:-1
隣接させることでしょう

00:19:13.020 --> 00:19:16.390 align:start position:21% line:-1
１番前の選択図形を前に出したあと

00:19:16.490 --> 00:19:20.260 align:start position:36% line:-2
残りの選択図形を
その下にまとめる

00:19:22.629 --> 00:19:24.565 align:start position:32% line:-1
背面に移動する時は―

00:19:24.665 --> 00:19:30.137 align:start position:29% line:-2
１番下の選択図形を移動し
残りを その上にまとめる

00:19:33.974 --> 00:19:38.645 align:start position:27% line:-2
話の全部を理解できなくても
大丈夫ですよ

00:19:38.745 --> 00:19:44.952 align:start position:27% line:-2
この詳細を説明できるような
コードを用意しました

00:19:46.453 --> 00:19:48.922 align:start position:16% line:-1
これは“bringToFront”です

00:19:50.424 --> 00:19:55.696 align:start position:16% line:-2
このコードを見ると
“shapes”にO(n)ループがあり

00:19:55.829 --> 00:20:01.168 align:start position:25% line:-2
removeとinsertの
２つのO(n)演算があります

00:19:55.829 --> 00:20:01.168 align:start position:25% line:-2
removeとinsertの
２つのO(n)演算があります

00:20:01.869 --> 00:20:05.239 align:start position:29% line:-1
つまりこれはｎの２乗です

00:20:06.240 --> 00:20:11.445 align:start position:30% line:-2
他の４つのコマンドにも
同じ問題が見られます

00:20:12.379 --> 00:20:17.584 align:start position:29% line:-2
これらは配列上をループし
挿入と削除を実行

00:20:17.684 --> 00:20:19.520 align:start position:36% line:-1
いずれも二次です

00:20:21.221 --> 00:20:23.891 align:start position:30% line:-1
この時点で私は心が折れ

00:20:23.991 --> 00:20:26.527 align:start position:25% line:-1
クラスティに助けを求めました

00:20:27.294 --> 00:20:32.166 align:start position:25% line:-2
“今夜は社交ダンスに行くので
時間がないが―”

00:20:32.266 --> 00:20:34.902 align:start position:32% line:-1
“とにかく始めよう”

00:20:35.202 --> 00:20:37.838 align:start position:30% line:-1
私はコードを見せました

00:20:39.273 --> 00:20:44.711 align:start position:30% line:-2
彼の最初の質問は
“この仕組みは？”です

00:20:45.712 --> 00:20:49.817 align:start position:30% line:-2
whileループがあり
ｊは挿入ポイント

00:20:49.917 --> 00:20:52.019 align:start position:32% line:-1
ｉは要素を追跡します

00:20:52.152 --> 00:20:55.022 align:start position:23% line:-1
“コードでなく言葉で説明を！”

00:20:55.589 --> 00:20:56.890 align:start position:38% line:-1
彼は言いました

00:20:58.325 --> 00:21:02.463 align:start position:25% line:-1
選択された図形を前面に移動し

00:20:58.325 --> 00:21:02.463 align:start position:25% line:-1
選択された図形を前面に移動し

00:21:02.563 --> 00:21:04.531 align:start position:36% line:-1
順序は維持します

00:21:05.766 --> 00:21:08.735 align:start position:23% line:-1
“コメントで記入し読み上げろ”

00:21:10.304 --> 00:21:12.773 align:start position:36% line:-1
入力は速いんです

00:21:15.442 --> 00:21:19.580 align:start position:30% line:-2
選択図形を前面に移動し
順序は維持

00:21:20.747 --> 00:21:23.183 align:start position:30% line:-1
“内容に聞き覚えは？”

00:21:23.951 --> 00:21:27.688 align:start position:9% line:-2
これはまるで
“halfStablePartition”です

00:21:28.455 --> 00:21:32.359 align:start position:29% line:-2
こちらは完全に
“stable”ですがね

00:21:32.459 --> 00:21:34.628 align:start position:34% line:-1
“これの名前は？”

00:21:34.728 --> 00:21:37.397 align:start position:18% line:-1
“stablePartition？”

00:21:38.432 --> 00:21:40.767 align:start position:36% line:-1
“そのとおりだ”

00:21:40.868 --> 00:21:45.239 align:start position:25% line:-2
“オープンソースのファイルが
実装の参考になる”

00:21:46.273 --> 00:21:48.809 align:start position:34% line:-1
私はファイルを入手

00:21:48.909 --> 00:21:55.482 align:start position:25% line:-2
コードにコメントは残したまま
コーディングを再開しました

00:21:57.151 --> 00:22:00.554 align:start position:30% line:-1
しかし問題が発生します

00:21:57.151 --> 00:22:00.554 align:start position:30% line:-1
しかし問題が発生します

00:22:01.588 --> 00:22:04.525 align:start position:18% line:-1
“stablePartition”は

00:22:04.625 --> 00:22:09.496 align:start position:27% line:-2
接尾辞への要素の移動を示す
述語を取ります

00:22:09.863 --> 00:22:14.501 align:start position:21% line:-2
“bringToFront”では
後方に動かす観点が必要です

00:22:15.302 --> 00:22:19.606 align:start position:25% line:-2
クラスティは
“思い描いてみろ”と言います

00:22:20.274 --> 00:22:25.345 align:start position:29% line:-2
私は未選択の図形が
後ろに集まる様子を想像し

00:22:25.445 --> 00:22:26.980 align:start position:38% line:-1
答えを得ました

00:22:29.583 --> 00:22:35.889 align:start position:14% line:-2
“sendToBack”では述語を逆にし
選択図形を後ろに送ります

00:22:38.258 --> 00:22:42.162 align:start position:23% line:-1
いよいよコーディングの時間です

00:22:42.262 --> 00:22:47.568 align:start position:27% line:-2
クラスティも夜のダンスへと
繰り出すと思ったのですが

00:22:47.668 --> 00:22:50.804 align:start position:21% line:-1
“ちょっと待て”と私を止めました

00:22:51.505 --> 00:22:56.210 align:start position:32% line:-2
“スケーラビリティを
チェックするんだ”

00:22:57.311 --> 00:22:58.412 align:start position:45% line:-1
確かに

00:22:59.046 --> 00:23:01.181 align:start position:29% line:-1
クイックヘルプを開きます

00:22:59.046 --> 00:23:01.181 align:start position:29% line:-1
クイックヘルプを開きます

00:23:03.083 --> 00:23:06.420 align:start position:27% line:-1
計算量は(n log n)

00:23:07.821 --> 00:23:11.859 align:start position:30% line:-2
これを考えるため
log nに注目します

00:23:13.660 --> 00:23:17.331 align:start position:21% line:-1
すぐに水平になり 大きくなるほど

00:23:17.431 --> 00:23:22.069 align:start position:30% line:-2
増加は鈍化し
一定に近づいていきます

00:23:22.436 --> 00:23:24.538 align:start position:34% line:-1
これにｎを掛けます

00:23:26.039 --> 00:23:29.676 align:start position:25% line:-1
O(n)ほど増加することなく

00:23:29.776 --> 00:23:33.347 align:start position:25% line:-1
徐々に線形に近づいていきます

00:23:34.147 --> 00:23:39.720 align:start position:21% line:-2
従ってO(n log n)は
O(n)と同じものとして扱えます

00:23:41.021 --> 00:23:45.125 align:start position:21% line:-1
この結果には非常に満足しています

00:23:46.627 --> 00:23:48.962 align:start position:32% line:-1
少し話を戻しましょう

00:23:49.329 --> 00:23:53.567 align:start position:20% line:-2
“bringForward()”は
一番前の選択図形を前に出して

00:23:53.667 --> 00:23:56.904 align:start position:25% line:-1
後ろに他の選択図形を集めます

00:23:57.804 --> 00:24:01.742 align:start position:34% line:-2
ただ クラスティは
この方法に反対です

00:23:57.804 --> 00:24:01.742 align:start position:34% line:-2
ただ クラスティは
この方法に反対です

00:24:02.009 --> 00:24:08.182 align:start position:23% line:-2
“あの図形は並んで
ダンスでも踊るつもりなのか？”

00:24:09.316 --> 00:24:12.586 align:start position:25% line:-1
そして再び のど飴を出すと―

00:24:13.854 --> 00:24:19.359 align:start position:9% line:-2
軽やかな手さばきで
“bringForward()”を実行しました

00:24:22.796 --> 00:24:24.498 align:start position:32% line:-1
“もう１回見せよう”

00:24:25.332 --> 00:24:28.936 align:start position:23% line:-1
ペテン師のカモになった気分です

00:24:34.141 --> 00:24:35.342 align:start position:38% line:-1
“見覚えは？”

00:24:36.210 --> 00:24:37.010 align:start position:45% line:-1
ないよ

00:24:37.678 --> 00:24:39.680 align:start position:34% line:-1
彼は数を減らします

00:24:42.516 --> 00:24:43.650 align:start position:34% line:-1
“これでどうだ？”

00:24:46.520 --> 00:24:50.557 align:start position:16% line:-2
なるほど
“stablePartition”です

00:24:51.225 --> 00:24:53.560 align:start position:32% line:-1
何となく分かりました

00:24:56.230 --> 00:24:59.266 align:start position:29% line:-1
選択された最前面の図形を

00:25:00.200 --> 00:25:02.870 align:start position:34% line:-1
その前に移動します

00:25:03.136 --> 00:25:07.908 align:start position:25% line:-2
そこから始まる
配列のセクションを分離すれば

00:25:08.275 --> 00:25:10.310 align:start position:34% line:-1
それを分割できます

00:25:12.446 --> 00:25:16.049 align:start position:27% line:-2
でも コレクションの
一部だけを修正する方法は？

00:25:16.750 --> 00:25:20.320 align:start position:25% line:-1
“スライスを知らないのか？”

00:25:23.023 --> 00:25:26.860 align:start position:20% line:-2
“predecessor”で始まる
“shapes”

00:25:27.861 --> 00:25:32.099 align:start position:23% line:-2
“これをアルゴリズムに取り込み
調整するんだ”

00:25:37.604 --> 00:25:38.405 align:start position:45% line:-1
さて…

00:25:40.040 --> 00:25:43.877 align:start position:29% line:-2
計算の効率性と正確性への
人類の探求は

00:25:43.977 --> 00:25:49.283 align:start position:25% line:-2
コンピュータに先んじ
古代エジプトから続いています

00:25:49.449 --> 00:25:54.154 align:start position:30% line:-2
コンピュータの発明以降
それは活発化しました

00:25:55.489 --> 00:26:00.160 align:start position:32% line:-2
標準ライブラリに
必要なものがなくても

00:25:55.489 --> 00:26:00.160 align:start position:32% line:-2
標準ライブラリに
必要なものがなくても

00:26:00.260 --> 00:26:05.165 align:start position:29% line:-2
テストや文書などが
利用できるかもしれません

00:26:05.632 --> 00:26:09.803 align:start position:30% line:-2
必要なものを検索できる
能力が問われます

00:26:12.606 --> 00:26:13.941 align:start position:32% line:-1
コードに戻りましょう

00:26:14.041 --> 00:26:16.210 align:start position:30% line:-1
先ほどのスライスですが

00:26:16.310 --> 00:26:20.547 align:start position:29% line:-2
型を調べると
配列ではありませんでした

00:26:21.615 --> 00:26:26.920 align:start position:11% line:-2
ここまで“stablePartition”を
配列などに使い

00:26:27.020 --> 00:26:29.723 align:start position:27% line:-1
配列スライスにも使えました

00:26:29.823 --> 00:26:32.860 align:start position:29% line:-1
汎用的なのかもしれません

00:26:33.694 --> 00:26:34.962 align:start position:38% line:-1
“もちろんだ”

00:26:35.062 --> 00:26:38.265 align:start position:18% line:-2
“stablePartition”と
配列の仕様の関係は？

00:26:39.066 --> 00:26:40.767 align:start position:38% line:-1
“関係はない”

00:26:41.235 --> 00:26:47.341 align:start position:12% line:-2
“bringForwardは 図形や選択と
どう関係してると思う？”

00:26:48.842 --> 00:26:53.814 align:start position:29% line:-2
図形に作用し
選択図形を前面に送ります

00:26:53.914 --> 00:26:55.449 align:start position:32% line:-1
“そうだ 関係ない”

00:26:55.549 --> 00:26:57.151 align:start position:36% line:-1
私の話は無視です

00:26:58.519 --> 00:27:01.221 align:start position:18% line:-2
“のど飴の列で
bringForwardできるか？”

00:26:58.519 --> 00:27:01.221 align:start position:18% line:-2
“のど飴の列で
bringForwardできるか？”

00:27:02.322 --> 00:27:03.490 align:start position:34% line:-1
“もちろんできる”

00:27:04.024 --> 00:27:06.093 align:start position:30% line:-1
つまり図形と関係はない

00:27:08.095 --> 00:27:12.366 align:start position:32% line:-2
ジェネリックにしろと
いうことですか？

00:27:12.633 --> 00:27:14.768 align:start position:32% line:-1
時期尚早の気もします

00:27:15.335 --> 00:27:19.773 align:start position:30% line:-2
私の質問に答えず
クラスティは質問します

00:27:20.474 --> 00:27:23.177 align:start position:21% line:-1
“このメソッドのテスト方法は？”

00:27:24.812 --> 00:27:28.949 align:start position:32% line:-2
キャンバスを作成し
ランダムに図形を追加

00:27:29.049 --> 00:27:32.085 align:start position:25% line:-1
その一部を選択して 最後に…

00:27:32.352 --> 00:27:36.590 align:start position:32% line:-2
でも マズい考えだと
分かっていました

00:27:36.990 --> 00:27:40.727 align:start position:34% line:-2
それを全部やっても
関数や初期化子の―

00:27:40.828 --> 00:27:44.731 align:start position:25% line:-1
テストになるかは分かりません

00:27:44.832 --> 00:27:50.037 align:start position:20% line:-2
IsSelectedプロパティや
AddShapeメソッドも同じです

00:27:50.838 --> 00:27:54.541 align:start position:29% line:-2
テストケースが必要ですが
そのコードには―

00:27:54.842 --> 00:27:58.212 align:start position:30% line:-2
テストの必要がないのが
理想でしょう

00:27:59.012 --> 00:28:01.381 align:start position:30% line:-1
のど飴を前に送る場合は

00:27:59.012 --> 00:28:01.381 align:start position:30% line:-1
のど飴を前に送る場合は

00:28:01.682 --> 00:28:05.752 align:start position:27% line:-2
“Playground”の
int型が使えそうです

00:28:05.853 --> 00:28:10.124 align:start position:27% line:-2
こんな感じで
３で割れる数を前に送ります

00:28:13.227 --> 00:28:16.763 align:start position:30% line:-2
その一方
ランダムに生成される―

00:28:16.864 --> 00:28:22.770 align:start position:21% line:-2
膨大なテストデータを投げ
アルゴリズムの拡張性を確認します

00:28:23.136 --> 00:28:28.342 align:start position:27% line:-2
しかし今のコードでは
どちらも簡単ではありません

00:28:29.142 --> 00:28:31.879 align:start position:25% line:-1
私はクラスティの正しさを認め

00:28:32.179 --> 00:28:37.484 align:start position:23% line:-2
“bringForward”を
ジェネリックに変え始めました

00:28:38.352 --> 00:28:42.022 align:start position:27% line:-2
最初に“Canvas”から
切り離します

00:28:43.524 --> 00:28:46.226 align:start position:21% line:-1
そして“Shape”の配列に移動

00:28:47.094 --> 00:28:51.932 align:start position:25% line:-2
これにより“shapes”を
“self”に変えます

00:28:53.734 --> 00:28:57.838 align:start position:30% line:-2
そして図形の動きを示す
述語を渡すことで

00:28:57.938 --> 00:29:01.175 align:start position:18% line:-1
“Selected”から切り離します

00:28:57.938 --> 00:29:01.175 align:start position:18% line:-1
“Selected”から切り離します

00:29:04.945 --> 00:29:07.748 align:start position:32% line:-2
コンパイルできました
すばらしい

00:29:08.182 --> 00:29:13.153 align:start position:25% line:-2
この時点で“shapes”に
依存関係はなくなりました

00:29:13.287 --> 00:29:15.889 align:start position:27% line:-1
where節を削除できます

00:29:17.157 --> 00:29:20.861 align:start position:30% line:-2
これで どんな配列でも
前に出せます

00:29:21.495 --> 00:29:26.633 align:start position:23% line:-2
ダンスの練習をしていた
クラスティの方に目をやりました

00:29:26.733 --> 00:29:29.336 align:start position:34% line:-1
彼は私に質問します

00:29:31.205 --> 00:29:34.808 align:start position:11% line:-1
“bringForwardと配列の関係は？”

00:29:37.277 --> 00:29:41.515 align:start position:27% line:-2
ありません
この依存関係も取り除きます

00:29:42.583 --> 00:29:45.252 align:start position:14% line:-1
この“stablePartition”は

00:29:45.352 --> 00:29:48.055 align:start position:27% line:-2
可変コレクションの適合性を
要求します

00:29:48.155 --> 00:29:50.591 align:start position:25% line:-1
このコレクションを移動します

00:29:52.893 --> 00:29:58.999 align:start position:29% line:-2
インデックス型が
int型と一致しませんね

00:29:59.366 --> 00:30:01.635 align:start position:38% line:-1
これを直します

00:29:59.366 --> 00:30:01.635 align:start position:38% line:-1
これを直します

00:30:04.104 --> 00:30:05.439 align:start position:34% line:-1
これをしたことは？

00:30:06.073 --> 00:30:07.274 align:start position:38% line:-1
お勧めしません

00:30:09.376 --> 00:30:13.914 align:start position:30% line:-2
これを見たクラスティは
踊るのをやめました

00:30:15.215 --> 00:30:16.517 align:start position:45% line:-1
何か？

00:30:16.850 --> 00:30:20.387 align:start position:27% line:-1
“それは新人のやることだ”

00:30:21.455 --> 00:30:26.427 align:start position:27% line:-2
“まず０と比較するが
配列スライスには適さない”

00:30:27.895 --> 00:30:32.599 align:start position:27% line:-2
このインデックスの始まりは
０じゃないんですね

00:30:33.267 --> 00:30:35.769 align:start position:29% line:-1
スライスのインデックスは

00:30:35.869 --> 00:30:40.040 align:start position:25% line:-2
元のコレクションの
インデックスに対応しています

00:30:41.041 --> 00:30:46.813 align:start position:32% line:-2
スライスを利用した
汎用アルゴリズムでは

00:30:47.080 --> 00:30:48.315 align:start position:34% line:-1
この関係は重要です

00:30:50.651 --> 00:30:54.955 align:start position:25% line:-2
この問題の解決には
開始インデックスを比較します

00:30:55.689 --> 00:31:00.494 align:start position:12% line:-2
“本当の問題は bringForwardが
どのように…”

00:30:55.689 --> 00:31:00.494 align:start position:12% line:-2
“本当の問題は bringForwardが
どのように…”

00:31:00.594 --> 00:31:04.765 align:start position:25% line:-2
整数インデックスに関係するか
ですよね？

00:31:05.132 --> 00:31:11.271 align:start position:29% line:-2
減算することで ｉの前に
インデックスを取得します

00:31:13.073 --> 00:31:16.243 align:start position:21% line:-1
クラスティは また飴を出しました

00:31:17.377 --> 00:31:20.747 align:start position:27% line:-1
そして 机に２本の指を置き

00:31:20.948 --> 00:31:27.654 align:start position:30% line:-2
右手が最初に緑色の飴を
指すまで 動かしました

00:31:30.157 --> 00:31:32.860 align:start position:27% line:-1
“後ろ向きの動きじゃない”

00:31:33.327 --> 00:31:37.931 align:start position:30% line:-2
これはアルゴリズムだと
私は気付きました

00:31:38.499 --> 00:31:41.468 align:start position:12% line:-2
“これをindexBeforeFirstと
名付けよう”

00:31:41.969 --> 00:31:47.341 align:start position:21% line:-2
“コードは他の人が書いたと思って
注意深く見るんだ”

00:31:47.708 --> 00:31:50.844 align:start position:23% line:-1
彼は不要な部分を消し始めました

00:31:50.944 --> 00:31:53.447 align:start position:38% line:-1
これに これも

00:31:56.817 --> 00:31:58.786 align:start position:23% line:-1
“predecessorは―”

00:31:58.886 --> 00:32:04.792 align:start position:25% line:-2
“述語が満たされる最初よりも
前のインデックスだ”

00:31:58.886 --> 00:32:04.792 align:start position:25% line:-2
“述語が満たされる最初よりも
前のインデックスだ”

00:32:05.225 --> 00:32:07.528 align:start position:29% line:-1
“いいコードができたぞ”

00:32:08.395 --> 00:32:12.065 align:start position:23% line:-1
確かに 彼の言葉は正しいですね

00:32:13.033 --> 00:32:19.306 align:start position:29% line:-2
図形 選択 配列 整数の
詳細を取り除いたことで

00:32:19.439 --> 00:32:21.475 align:start position:34% line:-1
クリアになりました

00:32:21.608 --> 00:32:24.711 align:start position:27% line:-1
本質のみが残りましたからね

00:32:26.480 --> 00:32:30.484 align:start position:18% line:-2
“indexBeforeFirstを
自分でコードで書けるか？”

00:32:31.818 --> 00:32:37.391 align:start position:29% line:-2
徐々に理解できているので
いけそうな気がします

00:32:39.459 --> 00:32:41.995 align:start position:30% line:-1
タイプは得意なんですよ

00:32:42.095 --> 00:32:48.969 align:start position:27% line:-2
“後続が述語と一致する
最初のインデックスを返す”

00:32:50.037 --> 00:32:52.773 align:start position:32% line:-1
この出来には満足です

00:32:53.307 --> 00:32:56.109 align:start position:29% line:-1
クラスティ 次の問題を！

00:32:57.344 --> 00:33:00.948 align:start position:30% line:-2
“何か忘れてないか？”
彼は言います

00:32:57.344 --> 00:33:00.948 align:start position:30% line:-2
“何か忘れてないか？”
彼は言います

00:33:01.381 --> 00:33:03.283 align:start position:34% line:-1
何のことでしょうか

00:33:03.383 --> 00:33:06.086 align:start position:32% line:-1
コードは簡潔明瞭です

00:33:06.887 --> 00:33:12.526 align:start position:25% line:-2
“セマンティクスだ
意味が分からないと使えない”

00:33:14.628 --> 00:33:16.663 align:start position:32% line:-1
その時 気付きました

00:33:16.763 --> 00:33:19.233 align:start position:27% line:-1
新しいアルゴリズムを使う時

00:33:19.333 --> 00:33:25.639 align:start position:25% line:-2
コードの意味や効率を知るため
ドキュメントを参照します

00:33:26.240 --> 00:33:31.612 align:start position:25% line:-2
アルゴリズムは流用改変が多く
参照ドキュメントは同じです

00:33:32.946 --> 00:33:38.385 align:start position:25% line:-2
私は最近 ある面接で
文書の役割について聞きました

00:33:38.485 --> 00:33:41.288 align:start position:30% line:-1
彼の言葉は印象的でした

00:33:41.855 --> 00:33:44.491 align:start position:29% line:-1
“本当に重要なものです”

00:33:45.559 --> 00:33:49.863 align:start position:30% line:-2
“文書は いわば
抽象化の塔と言えます”

00:33:49.963 --> 00:33:54.468 align:start position:29% line:-2
“私たちが下を気にせず
上に構築ができるのは―”

00:33:54.568 --> 00:33:57.571 align:start position:32% line:-2
“文書化された
基盤があるからです”

00:33:59.006 --> 00:34:01.208 align:start position:25% line:-1
アプリケーション開発者として

00:33:59.006 --> 00:34:01.208 align:start position:25% line:-1
アプリケーション開発者として

00:34:01.375 --> 00:34:06.680 align:start position:30% line:-2
あなたは 塔の最上階で
働いているとしましょう

00:34:06.780 --> 00:34:11.652 align:start position:27% line:-2
ハードウェア基盤から伸び
フレームワークを貫く塔です

00:34:12.686 --> 00:34:17.324 align:start position:27% line:-2
そうした中で
独自のメソッドを使う場合は

00:34:17.891 --> 00:34:19.393 align:start position:36% line:-1
文書化しましょう

00:34:20.460 --> 00:34:23.330 align:start position:21% line:-1
面接の彼は採用され そこにいます

00:34:26.500 --> 00:34:30.771 align:start position:27% line:-2
私は 新しいアルゴリズムを
文書化しました

00:34:31.804 --> 00:34:34.875 align:start position:23% line:-1
これで実装のことは忘れられます

00:34:36.076 --> 00:34:39.746 align:start position:25% line:-1
疑問点にはクイックヘルプです

00:34:41.148 --> 00:34:43.851 align:start position:16% line:-1
“bringForward”も文書化を

00:34:46.186 --> 00:34:46.987 align:start position:41% line:-1
いいですね

00:34:48.054 --> 00:34:51.324 align:start position:25% line:-1
問題はすべて解決できましたが

00:34:51.425 --> 00:34:56.996 align:start position:12% line:-2
ここで“stablePartition”の
中身を見たくなりました

00:34:57.698 --> 00:35:02.836 align:start position:27% line:-2
結果 美しく建設的な
アルゴリズムでひと安心です

00:34:57.698 --> 00:35:02.836 align:start position:27% line:-2
結果 美しく建設的な
アルゴリズムでひと安心です

00:35:03.670 --> 00:35:07.074 align:start position:30% line:-2
パブリックメソッドが
コレクションの数を取り

00:35:07.174 --> 00:35:08.408 align:start position:36% line:-1
ヘルパに渡します

00:35:09.710 --> 00:35:12.212 align:start position:30% line:-1
使うのは分割統治法です

00:35:13.013 --> 00:35:18.785 align:start position:30% line:-2
カウントが２未満の場合
基本ケースを処理し

00:35:18.885 --> 00:35:23.791 align:start position:29% line:-2
分割点が コレクションの
先頭か末尾かを判断します

00:35:25.993 --> 00:35:29.129 align:start position:32% line:-2
次に コレクションを
２つに分けます

00:35:31.331 --> 00:35:36.603 align:start position:23% line:-2
ここでは アルゴリズムの挙動を
信じなければなりません

00:35:36.703 --> 00:35:39.473 align:start position:14% line:-2
左半分に
“stablePartition”を実行

00:35:40.274 --> 00:35:41.842 align:start position:41% line:-1
右半分にも

00:35:45.746 --> 00:35:51.785 align:start position:23% line:-2
両端を見た時 すべてが
正しい位置にあるのが分かります

00:35:53.654 --> 00:35:57.691 align:start position:23% line:-1
でも中央の部分は交換が必要です

00:35:58.725 --> 00:36:03.964 align:start position:29% line:-2
なお この例のように
長さは一定とは限りません

00:35:58.725 --> 00:36:03.964 align:start position:29% line:-2
なお この例のように
長さは一定とは限りません

00:36:04.832 --> 00:36:08.135 align:start position:27% line:-2
交換にも
幸いアルゴリズムがあります

00:36:08.802 --> 00:36:11.004 align:start position:27% line:-1
それは“rotate”です

00:36:14.741 --> 00:36:18.512 align:start position:16% line:-1
“rotate”には詳しく触れませんが

00:36:18.612 --> 00:36:23.817 align:start position:18% line:-2
“stablePartition”と
同じファイルで 実装が見られます

00:36:25.819 --> 00:36:27.554 align:start position:36% line:-1
話を戻しましょう

00:36:28.088 --> 00:36:29.957 align:start position:41% line:-1
こちらは―

00:36:31.759 --> 00:36:36.096 align:start position:21% line:-1
図形リストへのドラッグの実装です

00:36:36.196 --> 00:36:39.833 align:start position:25% line:-1
複雑でバグも少なくありません

00:36:40.234 --> 00:36:43.637 align:start position:30% line:-2
戦略は 一時バッファを
割り当て―

00:36:44.771 --> 00:36:48.542 align:start position:23% line:-1
挿入点の前の図形をループします

00:36:48.642 --> 00:36:51.879 align:start position:30% line:-2
選択した図形を抽出して
挿入点を調整

00:36:52.379 --> 00:36:55.249 align:start position:27% line:-1
残りの図形を別々にループし

00:36:55.349 --> 00:36:58.986 align:start position:21% line:-1
その後 選択したものを抽出します

00:37:00.688 --> 00:37:03.123 align:start position:34% line:-1
最後に 再挿入です

00:37:06.793 --> 00:37:12.633 align:start position:23% line:-2
やっと正しいコードができたので
もう触りたくありません

00:37:12.933 --> 00:37:16.236 align:start position:27% line:-1
最後のバグは１週間前でした

00:37:19.406 --> 00:37:23.076 align:start position:32% line:-2
ただ このプロセスは
うまくいったので

00:37:23.177 --> 00:37:26.447 align:start position:21% line:-1
一度 可視化しようと思っています

00:37:28.982 --> 00:37:32.319 align:start position:21% line:-1
今の見覚えあるな　もう１回見よう

00:37:36.823 --> 00:37:41.862 align:start position:29% line:-2
まず これを行い
次にパーツを別々に扱う…

00:37:43.664 --> 00:37:48.702 align:start position:12% line:-2
そうか 逆の述語を持つ
２つの“stablePartition”だ

00:37:49.870 --> 00:37:53.874 align:start position:29% line:-2
汎用アルゴリズムは
２つにまで縮小されました

00:37:55.676 --> 00:37:58.078 align:start position:21% line:-1
これが“Canvas”の内容です

00:37:59.947 --> 00:38:02.082 align:start position:32% line:-1
古い方と並べてみます

00:37:59.947 --> 00:38:02.082 align:start position:32% line:-1
古い方と並べてみます

00:38:04.685 --> 00:38:05.819 align:start position:38% line:-1
悪くありません

00:38:07.054 --> 00:38:10.557 align:start position:25% line:-1
再利用可能で 文書化された―

00:38:10.657 --> 00:38:14.328 align:start position:23% line:-1
汎用アルゴリズムに変身しました

00:38:18.565 --> 00:38:20.901 align:start position:30% line:-1
ここまで見てきたのは―

00:38:21.635 --> 00:38:25.873 align:start position:27% line:-2
アプリケーションドメインに
固有の詳細

00:38:26.006 --> 00:38:28.342 align:start position:32% line:-1
コードの基本的な動作

00:38:28.442 --> 00:38:31.845 align:start position:30% line:-2
再利用可能な
汎用コードでの再現です

00:38:32.179 --> 00:38:34.181 align:start position:34% line:-1
練習を必要とします

00:38:34.815 --> 00:38:38.018 align:start position:30% line:-1
実用的な観点から言うと

00:38:38.352 --> 00:38:43.524 align:start position:27% line:-2
汎用アルゴリズムは
不必要な細部を切り離せます

00:38:43.624 --> 00:38:48.962 align:start position:30% line:-2
再利用可能で検証も簡単
それに より明確です

00:38:49.596 --> 00:38:54.735 align:start position:27% line:-2
また プログラミング好きに
やりがいを与えてくれます

00:38:55.502 --> 00:39:00.708 align:start position:23% line:-2
それから 実際にハードウェアの
制約の中で行う―

00:38:55.502 --> 00:39:00.708 align:start position:23% line:-2
それから 実際にハードウェアの
制約の中で行う―

00:39:00.808 --> 00:39:04.111 align:start position:27% line:-1
真実と美の探求でもあります

00:39:04.745 --> 00:39:09.016 align:start position:29% line:-2
まさに“プログラミングは
真実を解き明かす”です

00:39:10.184 --> 00:39:13.587 align:start position:25% line:-1
計算を一級市民と考えましょう

00:39:13.954 --> 00:39:20.094 align:start position:25% line:-2
権利と義務を背負って
型とアーキテクチャに向き合い

00:39:20.194 --> 00:39:27.434 align:start position:25% line:-2
識別し 名前を付け テストし
意味と性能を文書化しましょう

00:39:29.103 --> 00:39:34.575 align:start position:25% line:-2
最後にショーン･ペアレントの
言葉をご紹介します

00:39:35.976 --> 00:39:39.379 align:start position:23% line:-1
“コードの品質を上げたいなら”

00:39:39.479 --> 00:39:45.352 align:start position:14% line:-2
“コーディングの基準を
No Raw Loopsに置き換えよう”

00:39:46.386 --> 00:39:47.387 align:start position:43% line:-1
以上です

00:39:47.488 --> 00:39:53.594 align:start position:43% line:-1
(拍手)
