WEBVTT

00:00:07.074 --> 00:00:16.283 align:start position:43% line:-1
(音楽)

00:00:17.050 --> 00:00:22.689 align:start position:43% line:-1
(拍手)

00:00:23.790 --> 00:00:24.892 align:start position:41% line:-1
こんにちは

00:00:24.992 --> 00:00:29.997 align:start position:21% line:-2
Architectureチームの
カロル･ガシンスキーです

00:00:31.198 --> 00:00:34.201 align:start position:27% line:-1
今日はまず VRの観点から

00:00:34.301 --> 00:00:38.572 align:start position:27% line:-2
macOS Mojaveの
新機能を簡単に説明します

00:00:38.939 --> 00:00:41.241 align:start position:27% line:-1
次にMetal 2について

00:00:41.341 --> 00:00:45.812 align:start position:32% line:-2
特にVR向けの特徴を
詳しく説明します

00:00:46.680 --> 00:00:52.352 align:start position:21% line:-2
最後にVRアプリケーション開発の
高度な技を紹介します

00:00:53.820 --> 00:00:56.990 align:start position:27% line:-2
我々は最近 優れたGPUを
搭載した―

00:00:57.090 --> 00:00:59.226 align:start position:25% line:-2
iMacとiMac Proを
発表しました

00:00:59.526 --> 00:01:03.664 align:start position:21% line:-2
iMacは 今や
AMDのPolaris系GPUと

00:00:59.526 --> 00:01:03.664 align:start position:21% line:-2
iMacは 今や
AMDのPolaris系GPUと

00:01:03.764 --> 00:01:07.401 align:start position:30% line:-2
8GBのビデオメモリを
搭載しています

00:01:07.634 --> 00:01:13.106 align:start position:29% line:-2
一方 iMac Proは
更に高性能のGPUと

00:01:13.207 --> 00:01:15.976 align:start position:21% line:-1
最大16GBのビデオメモリを搭載

00:01:16.476 --> 00:01:19.980 align:start position:27% line:-1
これは かなりパワフルです

00:01:20.347 --> 00:01:23.851 align:start position:23% line:-1
しかも これだけではありません

00:01:24.518 --> 00:01:27.921 align:start position:29% line:-1
外付けGPUを利用すれば

00:01:28.088 --> 00:01:32.392 align:start position:25% line:-2
どのMacも高性能の
ワークステーションになります

00:01:33.260 --> 00:01:36.830 align:start position:27% line:-2
処理速度は
10テラフロップス以上です

00:01:37.064 --> 00:01:38.265 align:start position:39% line:-1
そして更に―

00:01:39.032 --> 00:01:44.872 align:start position:11% line:-2
HTC Viveヘッドマウントディスプレイの
プラグアンドプレイに対応します

00:01:45.205 --> 00:01:50.978 align:start position:16% line:-2
Vive Proは1440×1600の
２枚のパネルを備え

00:01:52.179 --> 00:01:55.182 align:start position:27% line:-1
画素密度は615ppiです

00:01:56.016 --> 00:01:59.319 align:start position:27% line:-2
旧製品に比べ
解像度は78パーセント向上

00:01:59.419 --> 00:02:04.024 align:start position:27% line:-2
画素密度は
37パーセント向上しました

00:01:59.419 --> 00:02:04.024 align:start position:27% line:-2
画素密度は
37パーセント向上しました

00:02:05.158 --> 00:02:08.362 align:start position:30% line:-1
パネルの性能向上に加え

00:02:08.461 --> 00:02:11.465 align:start position:25% line:-1
デュアルカメラを搭載しました

00:02:11.565 --> 00:02:17.938 align:start position:21% line:-2
このカメラを用いて Mac上で
パススルービデオの実験ができます

00:02:18.172 --> 00:02:22.309 align:start position:23% line:-2
最新のトラッキングシステムにも
対応しました

00:02:23.777 --> 00:02:28.582 align:start position:27% line:-2
ではVRアプリケーションを
どう開発すればよいか？

00:02:28.949 --> 00:02:32.052 align:start position:18% line:-2
HTC ViveとVive Proは
いずれも

00:02:32.152 --> 00:02:36.256 align:start position:14% line:-2
Valve社のSteamVRランタイムと
連動しており

00:02:36.456 --> 00:02:40.761 align:start position:23% line:-2
VR Compositorなど
多くのサービスが使えます

00:02:41.261 --> 00:02:44.865 align:start position:29% line:-2
オープンソースの
VRフレームワークもあり

00:02:44.965 --> 00:02:49.937 align:start position:29% line:-2
macOS上で
SteamVRを試せます

00:02:50.504 --> 00:02:54.308 align:start position:27% line:-2
Valve社やHTC社との
密接な連携で

00:02:54.408 --> 00:03:00.814 align:start position:21% line:-2
SteamVRのmacOS対応を
可能にしました

00:02:54.408 --> 00:03:00.814 align:start position:21% line:-2
SteamVRのmacOS対応を
可能にしました

00:03:02.883 --> 00:03:08.755 align:start position:21% line:-2
では Metalの新機能を用いて
masOS Mojaveで

00:03:08.856 --> 00:03:12.159 align:start position:30% line:-2
VRアプリケーションを
最適化する方法です

00:03:13.260 --> 00:03:16.530 align:start position:25% line:-2
アプリケーションと
VR Compositorの

00:03:16.630 --> 00:03:19.099 align:start position:29% line:-1
相互関係を見てみましょう

00:03:19.867 --> 00:03:23.937 align:start position:34% line:-2
まず 左右の画像が
レンダリングされ

00:03:24.037 --> 00:03:26.607 align:start position:23% line:-2
2Dマルチサンプルテクスチャと
なります

00:03:26.740 --> 00:03:31.645 align:start position:18% line:-2
そしてIOSurfaceテクスチャに
変換され

00:03:31.745 --> 00:03:34.915 align:start position:25% line:-2
VR Compositorに
渡されます

00:03:35.549 --> 00:03:40.187 align:start position:25% line:-2
VR Compositorが
最終処理として

00:03:40.287 --> 00:03:44.658 align:start position:29% line:-2
ゆがみ補正 色収差などの
操作を行います

00:03:44.858 --> 00:03:47.394 align:start position:25% line:-1
これを“Warp”と呼びます

00:03:48.328 --> 00:03:50.898 align:start position:27% line:-1
最終的な画像が生成されたら

00:03:50.998 --> 00:03:54.168 align:start position:34% line:-2
ヘッドセットに送り
表示します

00:03:55.202 --> 00:03:58.172 align:start position:30% line:-2
これでは
多数の処理が発生します

00:03:58.305 --> 00:04:01.208 align:start position:30% line:-1
対処法はないでしょうか

00:03:58.305 --> 00:04:01.208 align:start position:30% line:-1
対処法はないでしょうか

00:04:02.676 --> 00:04:07.047 align:start position:27% line:-2
アプリケーションに
MSAAを使用したい場合―

00:04:07.147 --> 00:04:10.784 align:start position:29% line:-2
両眼にそれぞれ
専用テクスチャが必要です

00:04:11.084 --> 00:04:13.520 align:start position:30% line:-1
１つを両眼で共有すると

00:04:13.620 --> 00:04:16.255 align:start position:29% line:-1
どちらも不完全になります

00:04:16.490 --> 00:04:22.029 align:start position:29% line:-2
専用テクスチャは 別々に
ドローコールが必要です

00:04:23.063 --> 00:04:26.333 align:start position:30% line:-2
一方
共有テクスチャの場合は

00:04:26.433 --> 00:04:29.436 align:start position:23% line:-1
レンダリングが１回で済みますが

00:04:30.204 --> 00:04:33.774 align:start position:27% line:-1
後処理効果で問題が生じます

00:04:34.975 --> 00:04:40.681 align:start position:27% line:-2
レイヤードテクスチャは
両方の利点を兼ね備えますが

00:04:41.148 --> 00:04:44.384 align:start position:30% line:-1
MSAAでは使えません

00:04:45.786 --> 00:04:50.057 align:start position:30% line:-2
このため MSAAを
用いるかどうかによって

00:04:50.157 --> 00:04:54.728 align:start position:34% line:-2
異なるレイアウトを
使わざるを得ません

00:04:54.862 --> 00:04:57.664 align:start position:36% line:-2
または周辺作業で
どうにかします

00:04:57.764 --> 00:05:00.467 align:start position:30% line:-1
これを最適化するには？

00:04:57.764 --> 00:05:00.467 align:start position:30% line:-1
これを最適化するには？

00:05:02.069 --> 00:05:04.771 align:start position:29% line:-2
そこで新たなテクスチャを
紹介します

00:05:04.905 --> 00:05:07.774 align:start position:30% line:-2
2Dマルチサンプル配列
テクスチャです

00:05:09.109 --> 00:05:13.580 align:start position:32% line:-2
これまで述べた
全ての利点を兼ね備え

00:05:13.680 --> 00:05:15.582 align:start position:36% line:-1
欠点もありません

00:05:16.550 --> 00:05:20.387 align:start position:30% line:-2
レンダリングスペースを
分けることができ

00:05:20.854 --> 00:05:25.392 align:start position:30% line:-2
それにより後処理効果を
単純化できます

00:05:26.460 --> 00:05:31.698 align:start position:27% line:-2
単一視点のレンダリングにも
容易に戻せます

00:05:33.167 --> 00:05:35.769 align:start position:29% line:-2
アンチエイリアスモードも
調節できます

00:05:36.703 --> 00:05:40.607 align:start position:30% line:-2
これにより 単一の
レンダリングファイルを

00:05:40.707 --> 00:05:44.811 align:start position:34% line:-2
あらゆる状況に
簡単に適用できます

00:05:44.912 --> 00:05:51.451 align:start position:21% line:-2
更にドローやレンダリングのパスが
１回で済む点も重要です

00:05:53.787 --> 00:05:59.626 align:start position:21% line:-2
このテクスチャを作成する
コードスニペットを見てみましょう

00:06:01.028 --> 00:06:03.063 align:start position:18% line:-1
sampleCountの設定は４です

00:06:03.163 --> 00:06:07.034 align:start position:30% line:-2
画質とパフォーマンスの
兼ね合いからです

00:06:07.134 --> 00:06:11.605 align:start position:21% line:-2
同時に arrayLengthは
２に設定しました

00:06:11.705 --> 00:06:17.544 align:start position:30% line:-2
両眼の画像を それぞれ
別に保存したいからです

00:06:18.912 --> 00:06:22.716 align:start position:32% line:-2
パイプラインは
どう変わるでしょうか

00:06:23.517 --> 00:06:26.887 align:start position:34% line:-2
2Dマルチサンプル
テクスチャを

00:06:27.154 --> 00:06:30.090 align:start position:30% line:-2
2Dマルチサンプル配列
テクスチャに替えました

00:06:33.026 --> 00:06:37.998 align:start position:30% line:-2
１つのパスで 両眼の
レンダリングが可能です

00:06:38.098 --> 00:06:43.170 align:start position:29% line:-2
インスタンシングを使えば
ドローコールも１回です

00:06:43.837 --> 00:06:47.541 align:start position:32% line:-2
しかし まだ
改善の余地があります

00:06:47.641 --> 00:06:50.978 align:start position:30% line:-2
2Dマルチサンプル配列
テクスチャを

00:06:51.078 --> 00:06:56.116 align:start position:27% line:-2
別々にIOSurfaceに
変換しなくてはなりません

00:06:57.484 --> 00:07:02.322 align:start position:20% line:-2
テクスチャをCompositorと
共有するには

00:06:57.484 --> 00:07:02.322 align:start position:20% line:-2
テクスチャをCompositorと
共有するには

00:07:02.723 --> 00:07:06.260 align:start position:27% line:-2
IOSurfaceを使えば
可能です

00:07:06.760 --> 00:07:12.366 align:start position:27% line:-2
異なるプロセスやGPU間で
テクスチャを共有できます

00:07:12.666 --> 00:07:15.836 align:start position:32% line:-1
しかし欠点もあります

00:07:16.436 --> 00:07:21.675 align:start position:20% line:-2
IOSurfaceで共有できるのは
単純な2Dテクスチャだけです

00:07:21.775 --> 00:07:26.613 align:start position:29% line:-2
そのためマルチサンプルを
用いる場合は

00:07:26.713 --> 00:07:28.081 align:start position:38% line:-1
共有できません

00:07:28.949 --> 00:07:32.486 align:start position:23% line:-2
そこで 共有可能な
Metalテクスチャの紹介です

00:07:32.586 --> 00:07:38.926 align:start position:23% line:-2
どのタイプのテクスチャも
プロセス間で共有可能になります

00:07:39.026 --> 00:07:43.430 align:start position:30% line:-2
ただし１つのGPU内の
テクスチャに限ります

00:07:45.332 --> 00:07:49.469 align:start position:32% line:-2
高度なVRへの
利用が可能になります

00:07:49.570 --> 00:07:54.274 align:start position:18% line:-2
例えば VR Compositorと
深度を共有できます

00:07:54.374 --> 00:07:56.944 align:start position:30% line:-1
それだけではありません

00:07:57.211 --> 00:08:00.547 align:start position:32% line:-2
テクスチャの作り方を
見てみましょう

00:07:57.211 --> 00:08:00.547 align:start position:32% line:-2
テクスチャの作り方を
見てみましょう

00:08:02.549 --> 00:08:08.055 align:start position:27% line:-2
複雑なテクスチャも
共有できるようになったので

00:08:08.155 --> 00:08:13.260 align:start position:21% line:-2
VR Compositorに渡す
2D配列テクスチャを作ります

00:08:14.194 --> 00:08:19.733 align:start position:29% line:-2
これには ご覧のような
新たなメソッドを用います

00:08:20.767 --> 00:08:25.906 align:start position:20% line:-2
storageModeは 忘れずに
Privateにしましょう

00:08:26.006 --> 00:08:31.178 align:start position:23% line:-2
テクスチャを作成したGPUのみ
アクセス可能です

00:08:33.780 --> 00:08:37.683 align:start position:30% line:-2
このコードスニペットを
見てください

00:08:37.784 --> 00:08:43.490 align:start position:20% line:-2
以前は このように
IOSurfaceを送っていました

00:08:44.091 --> 00:08:49.129 align:start position:25% line:-2
Metalテクスチャの使用に
切り替えるためには

00:08:50.030 --> 00:08:53.867 align:start position:32% line:-2
どんな変更を加えるか
見ていきます

00:08:54.868 --> 00:08:57.871 align:start position:27% line:-2
２つのIOSurfaceは
もう不要です

00:08:58.739 --> 00:09:01.475 align:start position:29% line:-2
IOSurface対応の
テクスチャは

00:08:58.739 --> 00:09:01.475 align:start position:29% line:-2
IOSurface対応の
テクスチャは

00:09:01.575 --> 00:09:05.779 align:start position:25% line:-2
１つのMetalテクスチャに
置き換えます

00:09:05.879 --> 00:09:07.915 align:start position:38% line:-1
2D配列型です

00:09:09.449 --> 00:09:14.454 align:start position:12% line:-2
２つのtextureDescriptorに
これを割り当てます

00:09:14.855 --> 00:09:17.124 align:start position:36% line:-2
オープンソースの
VR SDKです

00:09:17.624 --> 00:09:21.795 align:start position:23% line:-1
タイプをMetalに変更します

00:09:22.462 --> 00:09:25.432 align:start position:27% line:-1
いくつかの変更を加えました

00:09:25.732 --> 00:09:32.005 align:start position:20% line:-2
これで左右の眼の画像を
Compositorに提出できます

00:09:32.239 --> 00:09:34.841 align:start position:21% line:-1
これによりCompositorは

00:09:34.942 --> 00:09:39.413 align:start position:30% line:-2
Metalテクスチャを
渡されたと理解します

00:09:39.813 --> 00:09:45.018 align:start position:32% line:-2
テクスチャのタイプを
チェックしてみると

00:09:45.152 --> 00:09:48.989 align:start position:16% line:-1
Compositorが自動で判断します

00:09:49.089 --> 00:09:52.759 align:start position:32% line:-2
左眼の画像は
スライス０に保管され

00:09:52.860 --> 00:09:56.230 align:start position:34% line:-2
右眼はスライス１に
保管されています

00:09:56.463 --> 00:09:59.700 align:start position:30% line:-2
アプリケーションは
何もしなくてよいのです

00:10:01.301 --> 00:10:05.672 align:start position:21% line:-2
アプリケーションと
Compositorの共有だけが

00:10:05.772 --> 00:10:09.109 align:start position:30% line:-2
Metalテクスチャの
特徴ではありません

00:10:09.343 --> 00:10:15.282 align:start position:29% line:-2
プロセス間でテクスチャを
渡す例を見てみましょう

00:10:16.083 --> 00:10:20.220 align:start position:23% line:-2
最初は同じように
Metalテクスチャを作ります

00:10:20.621 --> 00:10:26.860 align:start position:25% line:-2
今回は このテクスチャから
テクスチャハンドルを作ります

00:10:26.960 --> 00:10:32.799 align:start position:23% line:-2
XPC接続により プロセス間で
渡すことができます

00:10:33.133 --> 00:10:37.271 align:start position:32% line:-2
もう一方のプロセスに
ハンドルを渡せば

00:10:37.838 --> 00:10:41.875 align:start position:27% line:-2
これを用いてオブジェクトを
再形成できます

00:10:42.242 --> 00:10:44.211 align:start position:30% line:-1
ここで注意点があります

00:10:44.444 --> 00:10:48.115 align:start position:29% line:-2
テクスチャオブジェクトの
再形成は

00:10:48.215 --> 00:10:53.687 align:start position:25% line:-2
それが作られたのと
同じデバイス上で行いましょう

00:10:53.787 --> 00:10:58.025 align:start position:32% line:-2
GPUの適用範囲を
超えられないためです

00:11:00.494 --> 00:11:03.597 align:start position:32% line:-2
では パイプラインに
戻りましょう

00:11:04.331 --> 00:11:05.966 align:start position:32% line:-1
どう変わるでしょう？

00:11:06.233 --> 00:11:10.103 align:start position:27% line:-2
アプリケーションでは
２つのIOSurfaceが

00:11:10.204 --> 00:11:14.675 align:start position:27% line:-2
１つの2D配列テクスチャに
入れ替わりました

00:11:15.275 --> 00:11:17.811 align:start position:27% line:-1
これで大幅に最適化できます

00:11:17.911 --> 00:11:22.182 align:start position:34% line:-2
2Dマルチサンプル
配列テクスチャは

00:11:22.282 --> 00:11:27.254 align:start position:27% line:-2
ワンパスで共有テクスチャに
変換されます

00:11:27.588 --> 00:11:31.124 align:start position:14% line:-1
Compositorに注目してみましょう

00:11:32.159 --> 00:11:35.762 align:start position:32% line:-2
アプリケーション側の
簡便化により

00:11:35.863 --> 00:11:40.901 align:start position:21% line:-2
Compositor側も新機能を
存分に活用できます

00:11:41.201 --> 00:11:47.474 align:start position:25% line:-2
Compositorは
渡された2D配列テクスチャを

00:11:47.574 --> 00:11:51.945 align:start position:29% line:-2
１回のレンダリングパスで
両眼に使えます

00:11:53.247 --> 00:11:56.817 align:start position:34% line:-2
パイプライン全体が
簡略化されました

00:11:57.684 --> 00:12:00.120 align:start position:34% line:-1
おさらいしましょう

00:11:57.684 --> 00:12:00.120 align:start position:34% line:-1
おさらいしましょう

00:12:01.655 --> 00:12:04.424 align:start position:29% line:-1
Metalの新機能は２つ

00:12:04.525 --> 00:12:07.394 align:start position:21% line:-1
共有可能なMetalテクスチャと

00:12:07.494 --> 00:12:10.063 align:start position:30% line:-2
2Dマルチサンプル配列
テクスチャです

00:12:10.564 --> 00:12:15.102 align:start position:32% line:-2
パイプライン最適化の
方法も話しました

00:12:15.969 --> 00:12:20.440 align:start position:27% line:-2
SteamVRランタイムの
アップデートで対応します

00:12:22.576 --> 00:12:25.846 align:start position:29% line:-2
次は アプリケーションで
CPUとGPUを

00:12:25.946 --> 00:12:28.815 align:start position:29% line:-1
最大限に活用する方法です

00:12:30.083 --> 00:12:33.520 align:start position:23% line:-1
２つに分けて お話ししましょう

00:12:33.620 --> 00:12:36.957 align:start position:27% line:-2
高度なフレームペーシングと
フィルレートの軽減です

00:12:38.759 --> 00:12:40.727 align:start position:25% line:-1
まず フレームペーシングです

00:12:41.562 --> 00:12:45.299 align:start position:27% line:-2
アプリケーションの
フレームペーシングを分析し

00:12:45.399 --> 00:12:47.901 align:start position:25% line:-1
最適化する方法をお話しします

00:12:48.202 --> 00:12:54.775 align:start position:25% line:-2
全てを連続的に実行する
シンプルな例で説明しましょう

00:12:55.375 --> 00:13:00.247 align:start position:14% line:-2
まず WaitGetPosesを呼び出し
フレームを開始します

00:12:55.375 --> 00:13:00.247 align:start position:14% line:-2
まず WaitGetPosesを呼び出し
フレームを開始します

00:13:00.781 --> 00:13:02.482 align:start position:34% line:-1
Poseを受け取り

00:13:02.916 --> 00:13:07.554 align:start position:23% line:-2
ヘッドセットのフレームレートに
同期して実行します

00:13:09.022 --> 00:13:14.094 align:start position:23% line:-2
Viveも Vive Proも
リフレッシュレートは90です

00:13:14.328 --> 00:13:19.633 align:start position:25% line:-2
１フレームの処理時間は
11.1ミリ秒ということです

00:13:20.067 --> 00:13:25.038 align:start position:29% line:-2
ちなみに瞬き１回の時間は
300ミリ秒です

00:13:25.539 --> 00:13:28.976 align:start position:32% line:-2
この間に50フレーム
描画します

00:13:30.277 --> 00:13:34.414 align:start position:32% line:-2
アプリケーションが
Poseを受け取ると

00:13:34.515 --> 00:13:38.051 align:start position:34% line:-2
シミュレーションを
開始できます

00:13:38.685 --> 00:13:42.890 align:start position:29% line:-2
完了し 全オブジェクトの
状態が分かれば

00:13:42.990 --> 00:13:47.361 align:start position:29% line:-2
コマンドバッファの
エンコードを継続できます

00:13:47.461 --> 00:13:50.631 align:start position:32% line:-2
これがGPUに送られ
実行されます

00:13:51.798 --> 00:13:56.770 align:start position:29% line:-2
GPUで実行され
両眼の画像が描画されると

00:13:56.870 --> 00:14:03.010 align:start position:20% line:-2
VR Compositorに送られ
最終的な後処理が行われます

00:13:56.870 --> 00:14:03.010 align:start position:20% line:-2
VR Compositorに送られ
最終的な後処理が行われます

00:14:05.012 --> 00:14:09.983 align:start position:25% line:-2
その後 フレームが
ヘッドセットへ読み込まれます

00:14:10.517 --> 00:14:16.156 align:start position:27% line:-2
画像を表示する前に
全ピクセルが更新されるため

00:14:16.256 --> 00:14:18.425 align:start position:30% line:-1
もう１フレーム必要です

00:14:19.226 --> 00:14:21.795 align:start position:30% line:-1
ピクセルが更新されると

00:14:22.262 --> 00:14:26.400 align:start position:29% line:-2
パネルから光子が放出され
フレームが見られます

00:14:27.234 --> 00:14:30.637 align:start position:29% line:-2
アプリケーションが
Poseを受け取ってから

00:14:30.804 --> 00:14:36.343 align:start position:27% line:-2
画像が出るまでに要するのは
約25ミリ秒です

00:14:37.110 --> 00:14:40.280 align:start position:27% line:-1
そのためアプリケーションは

00:14:40.380 --> 00:14:43.350 align:start position:30% line:-2
先を予測したPoseを
受け取ります

00:14:43.450 --> 00:14:45.919 align:start position:30% line:-1
光子放出の瞬間を予測し

00:14:46.019 --> 00:14:50.357 align:start position:32% line:-2
描画される画像が
合致するようにします

00:14:52.226 --> 00:14:57.030 align:start position:27% line:-2
この流れは前後のフレームと
重なり合い

00:14:57.130 --> 00:14:59.833 align:start position:38% line:-2
ダイアグラムを
形成しています

00:15:00.567 --> 00:15:04.037 align:start position:29% line:-2
このような
シングルスレッドの例では

00:15:04.471 --> 00:15:06.707 align:start position:30% line:-2
GPUのアイドル状態が
長いです

00:15:07.741 --> 00:15:10.043 align:start position:29% line:-1
これをどうにかしましょう

00:15:12.146 --> 00:15:15.516 align:start position:36% line:-2
マルチスレッドに
切り替えます

00:15:15.616 --> 00:15:19.853 align:start position:34% line:-2
視覚環境の
シミュレーションと

00:15:19.953 --> 00:15:23.056 align:start position:29% line:-2
GPU操作のエンコードを
分けました

00:15:23.390 --> 00:15:27.661 align:start position:27% line:-2
エンコードは別のスレッドで
発生します

00:15:28.695 --> 00:15:31.698 align:start position:29% line:-1
こうして分けたことにより

00:15:31.798 --> 00:15:35.269 align:start position:27% line:-1
シミュレーションと並行して

00:15:36.036 --> 00:15:39.740 align:start position:21% line:-1
前フレームのエンコードができます

00:15:40.574 --> 00:15:44.945 align:start position:32% line:-2
つまり エンコードの
開始時期が変わり

00:15:45.045 --> 00:15:49.016 align:start position:32% line:-2
Poseを受け取って
すぐに開始されます

00:15:49.116 --> 00:15:54.221 align:start position:25% line:-2
アプリケーションが
エンコードに使える時間が増え

00:15:54.321 --> 00:15:57.658 align:start position:27% line:-1
GPUの処理時間も増えます

00:15:57.758 --> 00:16:01.461 align:start position:25% line:-1
その結果 見た目が向上します

00:15:57.758 --> 00:16:01.461 align:start position:25% line:-1
その結果 見た目が向上します

00:16:02.763 --> 00:16:04.665 align:start position:30% line:-1
ただし注意点があります

00:16:05.332 --> 00:16:09.636 align:start position:29% line:-2
シミュレーションが
１フレーム前に起こるため

00:16:10.037 --> 00:16:13.740 align:start position:21% line:-1
予測されたPoseも別途必要です

00:16:14.041 --> 00:16:18.645 align:start position:32% line:-2
このセットでは
56ミリ秒先を予測し

00:16:18.745 --> 00:16:22.249 align:start position:30% line:-2
レンダリングスレッドの
予測セットを

00:16:22.349 --> 00:16:25.552 align:start position:36% line:-2
光子放出の瞬間に
合致させています

00:16:27.054 --> 00:16:30.023 align:start position:32% line:-2
CPUに関しては
これで問題ありません

00:16:30.123 --> 00:16:35.729 align:start position:27% line:-2
アプリケーションが うまく
作業を分布させています

00:16:36.129 --> 00:16:37.898 align:start position:32% line:-1
GPUはどうでしょう

00:16:40.200 --> 00:16:44.838 align:start position:30% line:-2
このアプリケーションの
例を見てください

00:16:45.038 --> 00:16:48.642 align:start position:25% line:-1
フレーム全体のGPUの処理を

00:16:48.742 --> 00:16:52.045 align:start position:29% line:-2
１つのコマンドバッファに
エンコードしています

00:16:52.679 --> 00:16:57.651 align:start position:27% line:-2
コマンドバッファの完了まで
GPUはアイドル状態です

00:16:58.719 --> 00:17:03.757 align:start position:27% line:-2
しかしCPUがエンコードに
要する時間は

00:16:58.719 --> 00:17:03.757 align:start position:27% line:-2
しかしCPUがエンコードに
要する時間は

00:17:03.857 --> 00:17:08.494 align:start position:25% line:-2
GPUの操作にかかる時間より
はるかに短いのです

00:17:08.962 --> 00:17:10.931 align:start position:32% line:-1
この事実を利用します

00:17:11.265 --> 00:17:16.537 align:start position:27% line:-2
エンコードを いくつかの
コマンドバッファに分けます

00:17:16.637 --> 00:17:21.575 align:start position:27% line:-2
分かれたコマンドバッファは
迅速にエンコードされ

00:17:21.675 --> 00:17:24.711 align:start position:29% line:-1
すぐにGPUに渡されます

00:17:25.579 --> 00:17:26.780 align:start position:39% line:-1
こうすれば―

00:17:27.981 --> 00:17:34.922 align:start position:23% line:-2
エンコードと並行して
GPUがフレームを処理できます

00:17:35.022 --> 00:17:41.295 align:start position:27% line:-2
GPUが処理に使える時間も
増やすことができました

00:17:41.862 --> 00:17:47.034 align:start position:27% line:-2
１フレームあたりの処理量も
大幅に増やせます

00:17:48.068 --> 00:17:52.139 align:start position:29% line:-2
では ダイヤグラム全体を
見てみましょう

00:17:53.340 --> 00:17:58.278 align:start position:29% line:-2
CPUとGPUを
最大限に活用できています

00:17:58.712 --> 00:18:03.183 align:start position:30% line:-2
この時点で
かなり よい見本ですが

00:17:58.712 --> 00:18:03.183 align:start position:30% line:-2
この時点で
かなり よい見本ですが

00:18:03.484 --> 00:18:05.752 align:start position:34% line:-1
もっと改善できます

00:18:07.087 --> 00:18:11.291 align:start position:29% line:-2
レンダリングスレッドには
まだ待ち時間があります

00:18:11.391 --> 00:18:17.397 align:start position:23% line:-2
Poseを受け取るまで
エンコードを待っている状態です

00:18:17.498 --> 00:18:21.869 align:start position:27% line:-2
しかしPoseを
必要としない処理もあります

00:18:23.003 --> 00:18:26.507 align:start position:27% line:-1
もっと詳しく見てみましょう

00:18:28.408 --> 00:18:33.247 align:start position:30% line:-2
各フレームで実行される
処理のリストです

00:18:33.947 --> 00:18:36.383 align:start position:34% line:-2
一部はスクリーンで
発生します

00:18:36.483 --> 00:18:41.088 align:start position:29% line:-2
Poseの情報を
必要とするものもあります

00:18:41.388 --> 00:18:44.391 align:start position:21% line:-1
これをPose依存処理と呼びます

00:18:44.992 --> 00:18:48.362 align:start position:27% line:-1
一方で 一般的な処理もあり

00:18:48.462 --> 00:18:52.366 align:start position:32% line:-2
Poseの情報なしで
すぐ実行できます

00:18:53.000 --> 00:18:56.136 align:start position:29% line:-1
これを独立処理と呼びます

00:18:57.638 --> 00:19:03.343 align:start position:27% line:-2
先ほど アプリケーションは
Poseを待っていましたが

00:18:57.638 --> 00:19:03.343 align:start position:27% line:-2
先ほど アプリケーションは
Poseを待っていましたが

00:19:03.510 --> 00:19:06.280 align:start position:29% line:-1
この処理を半分に分けると

00:19:07.247 --> 00:19:10.918 align:start position:34% line:-2
独立処理を すぐ
エンコードできます

00:19:11.018 --> 00:19:15.455 align:start position:27% line:-2
その後 Pose依存処理の
エンコードを待ちます

00:19:17.491 --> 00:19:21.662 align:start position:32% line:-2
このスライドでは
独立処理と依存処理を

00:19:21.762 --> 00:19:23.630 align:start position:34% line:-1
すでに分けています

00:19:24.398 --> 00:19:28.268 align:start position:29% line:-2
独立処理をエンコードする
コマンドバッファは

00:19:28.368 --> 00:19:33.440 align:start position:30% line:-2
Pose依存処理よりも
濃い色で示しています

00:19:34.241 --> 00:19:38.011 align:start position:29% line:-2
独立処理は
すぐエンコードできるので

00:19:38.145 --> 00:19:43.617 align:start position:23% line:-2
このように 前フレームの直後に
エンコードします

00:19:44.651 --> 00:19:48.388 align:start position:32% line:-2
これでCPUの時間を
増やせます

00:19:48.589 --> 00:19:52.226 align:start position:25% line:-1
すでに このGPUの処理が―

00:19:52.326 --> 00:19:57.130 align:start position:30% line:-2
実行を待っていることが
重要な点です

00:19:57.698 --> 00:20:00.434 align:start position:27% line:-1
アイドルタイムはありません

00:19:57.698 --> 00:20:00.434 align:start position:27% line:-1
アイドルタイムはありません

00:20:00.534 --> 00:20:04.404 align:start position:30% line:-2
前フレームが終わり次第
次が開始します

00:20:06.907 --> 00:20:11.712 align:start position:25% line:-2
最後のテーマは
マルチGPUの処理の分散です

00:20:13.113 --> 00:20:16.750 align:start position:34% line:-2
複数のGPUに
処理を分けるのです

00:20:17.217 --> 00:20:19.953 align:start position:29% line:-2
MacBook Proは
GPUが２つあります

00:20:20.053 --> 00:20:25.692 align:start position:29% line:-2
２つの性能は異なりますが
使用に問題はありません

00:20:26.093 --> 00:20:30.130 align:start position:25% line:-2
同様に アプリケーションでも
両方を使えます

00:20:30.230 --> 00:20:34.434 align:start position:27% line:-2
MacのプライマリGPUで
負担を減らしながら

00:20:34.668 --> 00:20:36.303 align:start position:32% line:-1
レンダリングできます

00:20:39.039 --> 00:20:45.579 align:start position:27% line:-2
そこで 独立処理を分離して
第２のGPUに移行しました

00:20:45.679 --> 00:20:49.783 align:start position:32% line:-2
前のフレームで
エンコード済みなので

00:20:49.883 --> 00:20:52.786 align:start position:30% line:-1
この処理が可能なのです

00:20:52.886 --> 00:20:55.289 align:start position:30% line:-1
この独立処理と並行して

00:20:55.556 --> 00:20:59.993 align:start position:23% line:-2
前フレームのPose依存処理が
実行されます

00:21:00.094 --> 00:21:05.132 align:start position:29% line:-2
これで更に
GPUの時間を増やせます

00:21:07.634 --> 00:21:11.071 align:start position:30% line:-2
しかし
処理を分割するためには

00:21:11.705 --> 00:21:14.641 align:start position:32% line:-1
必要なことがあります

00:21:14.741 --> 00:21:17.778 align:start position:34% line:-2
処理を互いに
同期させることです

00:21:23.016 --> 00:21:28.288 align:start position:25% line:-2
ここで 新しい
同期プリミティブを紹介します

00:21:28.722 --> 00:21:32.893 align:start position:29% line:-2
MTLEventを使えば
１つのGPUの範囲内で

00:21:32.993 --> 00:21:36.730 align:start position:32% line:-2
異なるキューの処理を
同期できます

00:21:37.097 --> 00:21:41.068 align:start position:18% line:-1
更に MTLSharedEventは

00:21:41.168 --> 00:21:44.771 align:start position:32% line:-2
異なるGPUの処理を
同期できます

00:21:44.872 --> 00:21:47.174 align:start position:27% line:-1
異なるプロセス間も可能です

00:21:49.109 --> 00:21:52.779 align:start position:32% line:-2
では 単純なコードを
見てみましょう

00:21:53.447 --> 00:21:58.485 align:start position:23% line:-2
Thunderbolt 3で
MacにeGPUを接続しました

00:21:58.752 --> 00:22:02.956 align:start position:32% line:-2
ヘッドセットを動かす
プライマリGPUです

00:21:58.752 --> 00:22:02.956 align:start position:32% line:-2
ヘッドセットを動かす
プライマリGPUです

00:22:03.357 --> 00:22:09.429 align:start position:21% line:-2
すでにMacに入っているGPUは
補助として使います

00:22:10.397 --> 00:22:15.702 align:start position:27% line:-2
SharedEventで
両GPUの処理を同期します

00:22:19.106 --> 00:22:21.542 align:start position:25% line:-1
Eventの初期値は０なので

00:22:21.642 --> 00:22:25.812 align:start position:27% line:-2
同期カウンタは
１から始めることが重要です

00:22:26.113 --> 00:22:30.050 align:start position:30% line:-2
なぜなら 初期化された
Eventを待つ時

00:22:30.150 --> 00:22:36.256 align:start position:25% line:-2
カウンタが０だと戻ってしまい
同期されないからです

00:22:37.758 --> 00:22:40.494 align:start position:25% line:-1
補助GPUのエンコード処理は

00:22:40.594 --> 00:22:44.198 align:start position:30% line:-2
レンダリングスレッドで
すぐ開始されます

00:22:44.431 --> 00:22:50.370 align:start position:29% line:-2
補助GPU上で発生する
独立処理のエンコードです

00:22:50.470 --> 00:22:52.506 align:start position:32% line:-1
この処理が完了すると

00:22:53.106 --> 00:22:56.477 align:start position:25% line:-1
ローカルメモリに保存されます

00:22:56.777 --> 00:23:00.948 align:start position:27% line:-2
そのため 続けて
短い操作をエンコードします

00:22:56.777 --> 00:23:00.948 align:start position:27% line:-2
そのため 続けて
短い操作をエンコードします

00:23:01.048 --> 00:23:03.383 align:start position:30% line:-1
両GPUから見えるよう

00:23:03.517 --> 00:23:07.120 align:start position:30% line:-2
結果をシステムメモリに
転送するのです

00:23:07.354 --> 00:23:09.790 align:start position:36% line:-1
転送が完了すれば

00:23:10.524 --> 00:23:15.562 align:start position:18% line:-2
補助GPUがSharedEventに
信号を送り

00:23:15.796 --> 00:23:20.634 align:start position:29% line:-2
結果を安全に取得できると
eGPUに知らせます

00:23:22.035 --> 00:23:25.772 align:start position:25% line:-2
レンダリングスレッドが
コマンドバッファをコミットし

00:23:25.873 --> 00:23:29.676 align:start position:29% line:-2
補助GPUは
すでに処理を始めています

00:23:29.943 --> 00:23:33.714 align:start position:29% line:-2
同時にプライマリGPUの
コマンドバッファの

00:23:33.814 --> 00:23:36.783 align:start position:29% line:-1
エンコードを開始できます

00:23:37.584 --> 00:23:42.022 align:start position:23% line:-2
まず SharedEventが
システムメモリのデータを

00:23:42.122 --> 00:23:44.758 align:start position:32% line:-1
確認するのを待ちます

00:23:44.858 --> 00:23:48.428 align:start position:20% line:-2
確認でき SharedEventが
信号を送れば

00:23:48.629 --> 00:23:54.101 align:start position:21% line:-1
eGPUにデータを転送する操作を

00:23:54.201 --> 00:23:56.803 align:start position:30% line:-1
実行することができます

00:23:57.337 --> 00:24:02.509 align:start position:21% line:-2
転送が済めば Pose依存処理が
安全に行えます

00:23:57.337 --> 00:24:02.509 align:start position:21% line:-2
転送が済めば Pose依存処理が
安全に行えます

00:24:02.943 --> 00:24:07.681 align:start position:29% line:-2
第２のコマンドバッファが
信号を送り

00:24:07.815 --> 00:24:11.919 align:start position:32% line:-2
Pose依存処理が
実行可能と知らせます

00:24:12.252 --> 00:24:16.190 align:start position:29% line:-2
２つのコマンドバッファの
提出が済みました

00:24:16.290 --> 00:24:18.892 align:start position:23% line:-1
レンダリングスレッドは引き続き

00:24:18.992 --> 00:24:23.163 align:start position:34% line:-2
Pose依存処理を
エンコードできます

00:24:26.166 --> 00:24:32.105 align:start position:27% line:-2
このように 異なるGPUの
処理を同期できましたが

00:24:33.907 --> 00:24:38.145 align:start position:34% line:-2
第２のGPUには
まだ余力があります

00:24:38.579 --> 00:24:44.151 align:start position:29% line:-2
なぜなら この例で
第２のGPUに課したのは

00:24:44.251 --> 00:24:50.124 align:start position:27% line:-2
Pose依存処理に依存する
独立処理だからです

00:24:50.724 --> 00:24:54.428 align:start position:32% line:-2
しかし 依存性のない
処理もあり

00:24:54.528 --> 00:24:59.132 align:start position:27% line:-1
比較的低い頻度で発生します

00:24:59.466 --> 00:25:02.603 align:start position:36% line:-2
このような処理の
一例を挙げると

00:24:59.466 --> 00:25:02.603 align:start position:36% line:-2
このような処理の
一例を挙げると

00:25:02.736 --> 00:25:07.541 align:start position:30% line:-2
物理ベースの
正確なシミュレーション

00:25:07.641 --> 00:25:11.745 align:start position:29% line:-2
その他 更新に
時間を要するものなどです

00:25:13.213 --> 00:25:16.717 align:start position:34% line:-2
このような処理は
バックグラウンドで

00:25:16.817 --> 00:25:21.355 align:start position:30% line:-2
フレームとは非同期的に
その都度 発生し

00:25:21.889 --> 00:25:24.858 align:start position:20% line:-1
結果はプライマリGPUに送られます

00:25:25.492 --> 00:25:31.331 align:start position:23% line:-2
特定のフレームと無関係の処理を
グレーで示しました

00:25:32.399 --> 00:25:37.704 align:start position:29% line:-2
もちろん性能特性の異なる
さまざまなGPUがあり

00:25:37.805 --> 00:25:40.641 align:start position:29% line:-1
接続の帯域幅も異なります

00:25:41.442 --> 00:25:45.546 align:start position:32% line:-2
アプリケーションでは
１フレームの中に

00:25:45.646 --> 00:25:48.182 align:start position:32% line:-2
さまざまに関連し合う
処理があります

00:25:48.882 --> 00:25:54.121 align:start position:29% line:-2
この処理をどう配分するか
考える必要があります

00:25:54.855 --> 00:25:57.591 align:start position:30% line:-1
そこで まず重要なのは

00:25:57.691 --> 00:26:00.928 align:start position:32% line:-2
GPUの処理の配分を
考えることです

00:25:57.691 --> 00:26:00.928 align:start position:32% line:-2
GPUの処理の配分を
考えることです

00:26:01.028 --> 00:26:06.366 align:start position:25% line:-2
AppleではマルチGPUが
一般的になりつつあります

00:26:08.569 --> 00:26:12.072 align:start position:25% line:-1
では ここまでのおさらいです

00:26:12.406 --> 00:26:17.778 align:start position:25% line:-2
マルチスレッドで
CPUコードを最大限に活用し

00:26:18.846 --> 00:26:23.050 align:start position:29% line:-2
コマンドバッファを分割し
GPUの無駄をなくします

00:26:23.650 --> 00:26:25.953 align:start position:34% line:-1
その際に できれば

00:26:26.053 --> 00:26:30.090 align:start position:30% line:-2
Pose依存処理と
独立処理を分けましょう

00:26:30.657 --> 00:26:33.994 align:start position:30% line:-2
なるべく迅速に
エンコードするためです

00:26:34.461 --> 00:26:39.066 align:start position:30% line:-2
そして 更新頻度により
処理を分けます

00:26:39.800 --> 00:26:43.504 align:start position:25% line:-2
マルチGPUで
アプリケーションを実行する時

00:26:43.604 --> 00:26:47.841 align:start position:30% line:-2
簡単に 各GPUに
割り振ることができます

00:26:48.175 --> 00:26:49.510 align:start position:41% line:-1
その時には

00:26:49.943 --> 00:26:55.048 align:start position:27% line:-2
別のレンダリングスレッドで
各GPUを動かしましょう

00:26:55.382 --> 00:26:58.519 align:start position:29% line:-1
非同期に実行するためです

00:26:59.019 --> 00:27:01.422 align:start position:29% line:-1
次はフィルレートの話です

00:26:59.019 --> 00:27:01.422 align:start position:29% line:-1
次はフィルレートの話です

00:27:03.190 --> 00:27:07.861 align:start position:27% line:-2
Vive Proがもたらす
新たな課題です

00:27:07.961 --> 00:27:13.066 align:start position:30% line:-2
この問題を理解するため
比較してみましょう

00:27:14.201 --> 00:27:16.637 align:start position:34% line:-2
アプリケーションの
レンダリングでは

00:27:16.803 --> 00:27:20.874 align:start position:18% line:-1
Viveヘッドセットの場合 既定値で

00:27:21.275 --> 00:27:25.546 align:start position:27% line:-2
フィルレートは
毎秒436メガピクセルです

00:27:27.381 --> 00:27:31.418 align:start position:29% line:-2
最先端の
4KウルトラHD TVの

00:27:32.019 --> 00:27:36.290 align:start position:34% line:-2
フィルレートと
比較してみましょう

00:27:36.390 --> 00:27:40.460 align:start position:27% line:-1
毎秒475メガピクセルです

00:27:40.828 --> 00:27:43.931 align:start position:27% line:-1
これだけでも すでに大きく

00:27:44.031 --> 00:27:47.835 align:start position:27% line:-2
開発者はフィルレート軽減に
苦労します

00:27:48.135 --> 00:27:51.538 align:start position:27% line:-2
しかし Vive Proは
どうでしょう

00:27:53.006 --> 00:27:58.946 align:start position:27% line:-2
フィルレートは 通常でも
毎秒775メガピクセルです

00:27:59.046 --> 00:28:03.016 align:start position:20% line:-1
更に4xMSAAなどを追加するなら

00:27:59.046 --> 00:28:03.016 align:start position:20% line:-1
更に4xMSAAなどを追加するなら

00:28:03.116 --> 00:28:06.820 align:start position:23% line:-1
この数字は より大きくなります

00:28:08.055 --> 00:28:11.525 align:start position:32% line:-2
フィルレートの軽減が
重要なのです

00:28:12.025 --> 00:28:16.096 align:start position:32% line:-2
さまざまな技が 日々
生み出されています

00:28:16.196 --> 00:28:19.666 align:start position:38% line:-2
全て試すことを
お勧めしますが

00:28:20.234 --> 00:28:23.670 align:start position:34% line:-2
今日は いくつかに
焦点を当てます

00:28:23.904 --> 00:28:30.144 align:start position:29% line:-2
簡単に実行することができ
優れた結果が得られます

00:28:30.444 --> 00:28:33.413 align:start position:36% line:-2
まず ピクセルの
クリッピングです

00:28:34.481 --> 00:28:37.484 align:start position:30% line:-1
これは左眼用の画像です

00:28:38.452 --> 00:28:41.755 align:start position:27% line:-1
しかし レンズの性質により

00:28:42.589 --> 00:28:46.493 align:start position:25% line:-2
約20パーセントのピクセルは
失われます

00:28:46.593 --> 00:28:50.464 align:start position:27% line:-2
Compositorによる
ゆがみ補正のあと―

00:28:50.697 --> 00:28:54.968 align:start position:29% line:-2
右の画像がヘッドセットの
パネルに表示されます

00:28:55.068 --> 00:28:57.137 align:start position:29% line:-1
その後 レンズを通ります

00:28:58.639 --> 00:29:01.942 align:start position:32% line:-2
簡単にフィルレートを
減らすには

00:28:58.639 --> 00:29:01.942 align:start position:32% line:-2
簡単にフィルレートを
減らすには

00:29:02.342 --> 00:29:07.848 align:start position:27% line:-2
最終的に見えないピクセルは
描画しないことです

00:29:07.948 --> 00:29:12.653 align:start position:20% line:-2
SteamVRのステンシルマスクで
簡単にできます

00:29:15.255 --> 00:29:21.195 align:start position:27% line:-2
この方法で フィルレートを
20パーセント軽減でき

00:29:21.295 --> 00:29:26.433 align:start position:23% line:-2
Vive Proの場合で
620メガピクセルに減りました

00:29:29.269 --> 00:29:30.104 align:start position:45% line:-1
さて―

00:29:30.504 --> 00:29:35.709 align:start position:30% line:-2
レンズの ゆがみ補正を
更に詳しく分析します

00:29:37.544 --> 00:29:38.846 align:start position:38% line:-1
視野を分割して

00:29:39.746 --> 00:29:43.317 align:start position:27% line:-1
９つのセクションに分けます

00:29:43.851 --> 00:29:48.222 align:start position:36% line:-2
中央の視野角は
水平方向に80度

00:29:48.322 --> 00:29:50.591 align:start position:32% line:-1
垂直方向に80度です

00:29:50.891 --> 00:29:54.795 align:start position:34% line:-2
その周囲に辺と角の
領域があります

00:29:55.195 --> 00:29:57.064 align:start position:34% line:-1
この部分に色をつけ

00:29:57.297 --> 00:30:01.001 align:start position:36% line:-2
最終像との関係を
可視化しました

00:29:57.297 --> 00:30:01.001 align:start position:36% line:-2
最終像との関係を
可視化しました

00:30:02.836 --> 00:30:07.341 align:start position:32% line:-2
このように
角は ほぼ見えません

00:30:07.441 --> 00:30:11.178 align:start position:34% line:-1
そして辺の部分も―

00:30:11.278 --> 00:30:15.082 align:start position:32% line:-2
元の画像より
はるかに狭くなります

00:30:15.382 --> 00:30:19.019 align:start position:27% line:-1
実は ヘッドセットで見る時

00:30:19.153 --> 00:30:23.724 align:start position:29% line:-2
赤の部分を
直接見ることはできません

00:30:24.091 --> 00:30:27.761 align:start position:25% line:-1
周辺視野として見えるだけです

00:30:28.829 --> 00:30:31.999 align:start position:25% line:-1
これが大きなヒントとなります

00:30:33.200 --> 00:30:38.572 align:start position:27% line:-2
この辺と角のフィルレートは
減らすことが可能です

00:30:39.106 --> 00:30:41.375 align:start position:32% line:-1
ほぼ見えないからです

00:30:42.142 --> 00:30:46.246 align:start position:29% line:-2
中央は これまでどおりに
描画します

00:30:47.247 --> 00:30:51.251 align:start position:36% line:-2
左右の辺の部分は
幅を半分にし

00:30:51.552 --> 00:30:54.988 align:start position:34% line:-2
上下の辺は
高さを半分にします

00:30:55.455 --> 00:31:01.462 align:start position:29% line:-2
そして角の部分の描画は
解像度を４分の１にします

00:30:55.455 --> 00:31:01.462 align:start position:29% line:-2
そして角の部分の描画は
解像度を４分の１にします

00:31:02.996 --> 00:31:09.369 align:start position:23% line:-2
レンダリングパスが完了したあと
アップスケーリングします

00:31:09.469 --> 00:31:15.642 align:start position:30% line:-2
辺縁の領域を伸ばして
元の解像度に戻すのです

00:31:16.610 --> 00:31:19.746 align:start position:27% line:-1
どのくらいの効果があるか？

00:31:21.548 --> 00:31:26.320 align:start position:25% line:-2
中央領域が上下左右80度なら
フィルレートは

00:31:26.420 --> 00:31:30.891 align:start position:27% line:-2
毎秒491メガピクセルまで
減らせます

00:31:31.658 --> 00:31:35.629 align:start position:34% line:-2
見えないピクセルを
切り取る技を

00:31:35.729 --> 00:31:38.365 align:start position:29% line:-1
これと併用してみましょう

00:31:39.933 --> 00:31:43.737 align:start position:29% line:-2
ピクセルのクリッピングと
合わせると

00:31:43.837 --> 00:31:49.543 align:start position:21% line:-2
フィルレートは更に減り
毎秒456メガピクセルになります

00:31:49.643 --> 00:31:51.445 align:start position:36% line:-1
実は この数字は

00:31:51.578 --> 00:31:56.116 align:start position:30% line:-2
Viveヘッドセットの
既定値なのです

00:31:56.583 --> 00:31:59.820 align:start position:25% line:-1
つまり この２つの技を使えば

00:31:59.920 --> 00:32:04.658 align:start position:30% line:-2
Viveの時と
同じGPUを用いながら

00:31:59.920 --> 00:32:04.658 align:start position:30% line:-2
Viveの時と
同じGPUを用いながら

00:32:04.758 --> 00:32:10.097 align:start position:23% line:-2
はるかに解像度の高い
Vive Proに描画できます

00:32:10.697 --> 00:32:14.501 align:start position:30% line:-2
もちろん Viveにも
この技が使えます

00:32:14.601 --> 00:32:18.539 align:start position:27% line:-2
それによって
アプリケーションの見た目が

00:32:18.639 --> 00:32:21.041 align:start position:36% line:-1
大きく向上します

00:32:23.410 --> 00:32:25.512 align:start position:30% line:-1
ただし注意点があります

00:32:25.612 --> 00:32:29.516 align:start position:27% line:-2
多重解像度シェーディングは
レンダリングパスが少なく

00:32:30.050 --> 00:32:35.656 align:start position:29% line:-2
ジオメトリパイプラインの
処理が増大します

00:32:36.089 --> 00:32:42.129 align:start position:25% line:-2
これを緩和するには
中央の視野角を少し減らします

00:32:42.463 --> 00:32:46.300 align:start position:21% line:-1
このように10度 減らすだけでも

00:32:46.400 --> 00:32:51.038 align:start position:27% line:-2
毎秒382メガピクセルまで
軽減できます

00:32:51.438 --> 00:32:54.875 align:start position:29% line:-1
処理量が極めて大きい場合

00:32:55.342 --> 00:32:59.313 align:start position:32% line:-2
もっと領域を狭くして
試してみましょう

00:32:59.413 --> 00:33:04.384 align:start position:32% line:-2
更にフィルレートを
下げることができます

00:32:59.413 --> 00:33:04.384 align:start position:32% line:-2
更にフィルレートを
下げることができます

00:33:04.751 --> 00:33:08.489 align:start position:32% line:-2
中央領域が
上下左右55度の場合

00:33:08.622 --> 00:33:14.561 align:start position:25% line:-2
視線の動きの80パーセントが
この領域内に収まります

00:33:15.262 --> 00:33:18.432 align:start position:30% line:-2
しかし フィルレートは
半分以上減り

00:33:18.532 --> 00:33:21.802 align:start position:29% line:-2
毎秒360メガピクセルに
なります

00:33:23.570 --> 00:33:27.875 align:start position:30% line:-2
もちろん 他にも方法は
いろいろあります

00:33:29.009 --> 00:33:34.114 align:start position:29% line:-2
それにより得られる効果も
さまざまでしょう

00:33:34.681 --> 00:33:39.853 align:start position:27% line:-2
どれが最適か
いろいろ試してみてください

00:33:41.422 --> 00:33:44.758 align:start position:29% line:-2
では 今回のセッションの
まとめです

00:33:46.994 --> 00:33:51.298 align:start position:29% line:-2
まず Vive Proの
プラグアンドプレイ対応

00:33:51.765 --> 00:33:55.802 align:start position:25% line:-2
そして よりよい
VRアプリケーションのための

00:33:55.903 --> 00:33:59.073 align:start position:29% line:-2
Metal 2の新機能を
紹介しました

00:33:59.606 --> 00:34:04.378 align:start position:32% line:-2
マルチGPUの活用も
ぜひ試してください

00:33:59.606 --> 00:34:04.378 align:start position:32% line:-2
マルチGPUの活用も
ぜひ試してください

00:34:04.478 --> 00:34:07.815 align:start position:30% line:-2
Appleでは一般的に
なりつつあります

00:34:10.083 --> 00:34:13.587 align:start position:34% line:-2
更に詳しい情報が
リンク先にあります

00:34:13.754 --> 00:34:18.592 align:start position:29% line:-2
テクノロジーラボで
本日12時から実施予定の

00:34:18.692 --> 00:34:24.831 align:start position:25% line:-2
Metal 4 VRラボにも
ぜひ ご参加ください

00:34:26.132 --> 00:34:26.867 align:start position:30% line:-1
ありがとうございました

00:34:27.234 --> 00:34:31.638 align:start position:43% line:-1
(拍手)
