WEBVTT

00:00:07.107 --> 00:00:15.516 align:start position:43% line:-1
(音楽)

00:00:20.721 --> 00:00:26.159 align:start position:43% line:-1
(拍手)

00:00:26.894 --> 00:00:27.928 align:start position:45% line:-1
どうも

00:00:28.529 --> 00:00:31.164 align:start position:23% line:-1
昨年 Metal 2を紹介して

00:00:31.265 --> 00:00:35.235 align:start position:27% line:-2
レンダリングパイプラインの
新しい手法を提案しました

00:00:35.936 --> 00:00:39.673 align:start position:32% line:-2
今年は ゲーム開発の
課題を解決する―

00:00:39.773 --> 00:00:42.442 align:start position:34% line:-2
より画期的な機能を
紹介します

00:00:43.010 --> 00:00:47.281 align:start position:30% line:-2
私 ブライアン･ロスと
同僚のマイケルが

00:00:47.381 --> 00:00:53.520 align:start position:27% line:-2
アプリケーションを改善する
新しい方法を探ります

00:00:54.988 --> 00:00:59.960 align:start position:29% line:-2
まず 私が解決したい
課題についてお話しします

00:01:00.761 --> 00:01:06.166 align:start position:29% line:-2
ゲーム開発は 膨大な数の
オブジェクトを使用します

00:01:06.967 --> 00:01:11.505 align:start position:30% line:-2
「INSIDE」では
多くの特殊効果を用いて

00:01:11.605 --> 00:01:14.608 align:start position:38% line:-2
独特の雰囲気を
演出しています

00:01:16.210 --> 00:01:19.446 align:start position:29% line:-1
こうしたゲームを作るには

00:01:19.546 --> 00:01:23.550 align:start position:32% line:-2
GPUをフル活用する
必要があります

00:01:25.085 --> 00:01:30.724 align:start position:27% line:-2
臨場感あるゲームには
高い処理速度が求められます

00:01:30.924 --> 00:01:37.831 align:start position:29% line:-2
「トゥームレイダー」の
美しく精細な背景の裏では

00:01:38.432 --> 00:01:43.403 align:start position:29% line:-2
複雑なシミュレーションを
AIが行っています

00:01:44.004 --> 00:01:48.108 align:start position:32% line:-2
高速なレンダリングが
求められます

00:01:49.977 --> 00:01:56.583 align:start position:25% line:-2
「フォートナイト」のような
AAAタイトルの開発者たちは

00:01:56.683 --> 00:02:02.723 align:start position:25% line:-2
家庭用ゲームをiOSに移植し
手元で遊べるようにしました

00:01:56.683 --> 00:02:02.723 align:start position:25% line:-2
家庭用ゲームをiOSに移植し
手元で遊べるようにしました

00:02:02.890 --> 00:02:05.225 align:start position:34% line:-1
すばらしい功績です

00:02:05.392 --> 00:02:08.428 align:start position:30% line:-2
しかし
課題は多く残っています

00:02:08.662 --> 00:02:12.666 align:start position:27% line:-2
例えば バッテリー消費との
兼ね合いです

00:02:13.200 --> 00:02:17.304 align:start position:32% line:-2
Metalが
この問題を解決します

00:02:19.373 --> 00:02:22.509 align:start position:23% line:-1
CPUとGPUの並列処理による

00:02:22.609 --> 00:02:27.181 align:start position:29% line:-2
複雑な描画を行う仕組みを
お見せします

00:02:29.416 --> 00:02:32.819 align:start position:30% line:-2
また パフォーマンスを
改善するための

00:02:32.920 --> 00:02:37.324 align:start position:30% line:-2
明示的な制御についても
お話しします

00:02:39.993 --> 00:02:45.098 align:start position:29% line:-2
さらに 新機能である
２種類のバッファを用いた

00:02:45.199 --> 00:02:48.135 align:start position:27% line:-2
GPUパイプラインの構築も
紹介します

00:02:48.268 --> 00:02:50.938 align:start position:27% line:-1
こうしたAPIの改善に加え

00:02:51.305 --> 00:02:55.375 align:start position:30% line:-2
ハードウェアの動作を
理解することも重要です

00:02:55.742 --> 00:02:58.812 align:start position:27% line:-1
そこで 次のセクションでは

00:02:58.912 --> 00:03:04.651 align:start position:27% line:-2
アプリケーションをA11に
最適化する方法を示します

00:02:58.912 --> 00:03:04.651 align:start position:27% line:-2
アプリケーションをA11に
最適化する方法を示します

00:03:05.552 --> 00:03:12.793 align:start position:25% line:-2
最後は エピック･ゲームズの
ニック･ペンワーデン氏に

00:03:12.893 --> 00:03:18.699 align:start position:27% line:-2
Metalで家庭用ゲームを
移植した方法を伺います

00:03:19.333 --> 00:03:20.734 align:start position:38% line:-1
では 始めます

00:03:23.170 --> 00:03:26.240 align:start position:27% line:-1
CPUとGPUの並列処理は

00:03:26.340 --> 00:03:30.644 align:start position:27% line:-2
最も重要かつ
簡単にできる最適化でしょう

00:03:32.045 --> 00:03:35.816 align:start position:27% line:-2
シングルスレッドでの
コマンド処理は時代遅れです

00:03:36.183 --> 00:03:38.385 align:start position:27% line:-1
最新のiPhoneは６コア

00:03:38.485 --> 00:03:40.721 align:start position:20% line:-1
iMac Proは最大18コアです

00:03:41.088 --> 00:03:44.558 align:start position:32% line:-2
高いパフォーマンスを
得るためには

00:03:45.325 --> 00:03:48.095 align:start position:32% line:-2
マルチスレッド構造が
カギです

00:03:50.030 --> 00:03:52.165 align:start position:30% line:-2
Metalは
マルチスレッド対応です

00:03:52.266 --> 00:03:55.569 align:start position:34% line:-2
CPUを並列化する
２つの方法と

00:03:55.802 --> 00:04:01.708 align:start position:29% line:-2
MetalによるGPUの
自動並列化を紹介します

00:03:55.802 --> 00:04:01.708 align:start position:29% line:-2
MetalによるGPUの
自動並列化を紹介します

00:04:02.976 --> 00:04:06.113 align:start position:32% line:-2
ゲームの描画の流れを
見てみましょう

00:04:06.713 --> 00:04:09.283 align:start position:30% line:-2
シングルスレッドによる
レンダリングでは

00:04:09.750 --> 00:04:15.789 align:start position:25% line:-2
１つのコマンドバッファに
GPUへの実行命令を入れます

00:04:16.356 --> 00:04:20.560 align:start position:29% line:-2
通常は それをフレームの
一部に収めます

00:04:21.128 --> 00:04:26.800 align:start position:27% line:-2
GPUがバッファを使うには
符号化する必要があるため

00:04:26.900 --> 00:04:29.169 align:start position:30% line:-1
遅延時間が長くなります

00:04:29.369 --> 00:04:31.572 align:start position:32% line:-1
改善の余地があります

00:04:31.672 --> 00:04:36.877 align:start position:27% line:-2
そこで提案するのが
CPUを用いた並列処理です

00:04:39.980 --> 00:04:44.484 align:start position:30% line:-2
Metalの基本要素は
描画とパス計算です

00:04:44.952 --> 00:04:48.188 align:start position:29% line:-2
複数のコマンドバッファを
用意して

00:04:48.388 --> 00:04:52.159 align:start position:34% line:-2
別々のスレッドで
符号化するだけです

00:04:53.961 --> 00:04:56.063 align:start position:32% line:-1
処理の順序は自由です

00:04:56.163 --> 00:05:00.501 align:start position:32% line:-2
最後に追加した命令は
最後に実行されます

00:04:56.163 --> 00:05:00.501 align:start position:32% line:-2
最後に追加した命令は
最後に実行されます

00:05:01.468 --> 00:05:04.605 align:start position:27% line:-1
コードも極めてシンプルです

00:05:07.541 --> 00:05:09.910 align:start position:27% line:-1
ご覧の通り 短いコードです

00:05:10.010 --> 00:05:15.449 align:start position:27% line:-2
最初に コマンドバッファを
キューから取り出します

00:05:16.250 --> 00:05:23.156 align:start position:29% line:-2
次に GPUの実行命令を
キューに入れて定義します

00:05:23.257 --> 00:05:29.163 align:start position:27% line:-2
コマンドバッファの符号化を
待つ必要はありません

00:05:30.330 --> 00:05:35.802 align:start position:27% line:-2
最後に 各スレッドと
呼び出し元関数を作成します

00:05:35.903 --> 00:05:38.372 align:start position:34% line:-1
これだけで完了です

00:05:38.472 --> 00:05:41.642 align:start position:27% line:-1
非常に高速かつシンプルです

00:05:42.209 --> 00:05:46.180 align:start position:34% line:-2
先ほどの図で
別の例を見てみます

00:05:48.148 --> 00:05:52.719 align:start position:29% line:-2
CPUを用いた並列処理は
効果的でしたが

00:05:53.387 --> 00:05:57.124 align:start position:29% line:-2
長いレンダリングパスが
ある場合はどうでしょうか

00:05:58.692 --> 00:06:03.897 align:start position:21% line:-2
Metalは この場合に特化した
並列符号化により

00:05:58.692 --> 00:06:03.897 align:start position:21% line:-2
Metalは この場合に特化した
並列符号化により

00:06:04.331 --> 00:06:10.337 align:start position:27% line:-2
コマンドバッファも使用して
複数のスレッドで処理します

00:06:11.004 --> 00:06:13.473 align:start position:29% line:-1
こちらもコードは簡単です

00:06:15.309 --> 00:06:17.411 align:start position:30% line:-1
大きな変化はありません

00:06:17.678 --> 00:06:21.381 align:start position:29% line:-2
まず 複数のエンコーダを
準備します

00:06:21.782 --> 00:06:25.519 align:start position:29% line:-2
ここで下位のエンコーダを
多数 作成します

00:06:25.619 --> 00:06:30.324 align:start position:27% line:-2
GPUの実行命令を定義する
場所になります

00:06:32.292 --> 00:06:36.663 align:start position:30% line:-2
次に 別々のスレッドを
作成してから

00:06:36.763 --> 00:06:40.767 align:start position:32% line:-2
Ｇバッファを
それぞれ符号化します

00:06:41.902 --> 00:06:47.674 align:start position:29% line:-2
スレッドが終了したら
通知が出るように設定して

00:06:48.141 --> 00:06:51.011 align:start position:32% line:-2
エンコーダの
符号化を終わらせます

00:06:51.111 --> 00:06:54.281 align:start position:27% line:-2
これで レンダリングパスの
並列化が実現します

00:06:54.381 --> 00:06:56.550 align:start position:32% line:-1
高速かつシンプルです

00:06:57.084 --> 00:07:00.220 align:start position:29% line:-1
CPUの並列化は以上です

00:06:57.084 --> 00:07:00.220 align:start position:29% line:-1
CPUの並列化は以上です

00:07:00.721 --> 00:07:04.691 align:start position:30% line:-2
次に紹介するのは
GPUの自動並列化です

00:07:06.293 --> 00:07:08.762 align:start position:30% line:-1
最初の図に戻りましょう

00:07:09.897 --> 00:07:12.633 align:start position:34% line:-2
GPUはどう処理を
実行するのか

00:07:13.200 --> 00:07:18.071 align:start position:23% line:-2
Metalは 開発環境に応じて
データの従属性を分析し

00:07:18.172 --> 00:07:21.375 align:start position:29% line:-1
自動的に並列化を行います

00:07:21.475 --> 00:07:23.944 align:start position:30% line:-1
例を２つ見てみましょう

00:07:24.578 --> 00:07:27.915 align:start position:30% line:-2
粒子シミュレーションで
データを描画する例です

00:07:28.015 --> 00:07:31.752 align:start position:34% line:-2
このデータを使って
粒子を描きます

00:07:33.020 --> 00:07:37.291 align:start position:29% line:-2
同様に Ｇバッファパスで
ジオメトリを生成し

00:07:37.391 --> 00:07:41.428 align:start position:30% line:-2
物質の陰影を描くために
使用します

00:07:43.430 --> 00:07:49.636 align:start position:23% line:-2
Metalは この情報をもとに
自動的に全体のパスを特定し

00:07:49.736 --> 00:07:52.773 align:start position:30% line:-2
非同期演算などを用いて
描画します

00:07:56.276 --> 00:08:01.081 align:start position:25% line:-2
GPUの並列化と非同期演算が
手軽に実現できます

00:07:56.276 --> 00:08:01.081 align:start position:25% line:-2
GPUの並列化と非同期演算が
手軽に実現できます

00:08:01.181 --> 00:08:04.818 align:start position:32% line:-2
開発者側の
特別な操作は不要です

00:08:05.586 --> 00:08:09.423 align:start position:32% line:-2
手軽なGPU最適化は
誰もが望みますが

00:08:09.623 --> 00:08:14.394 align:start position:27% line:-2
開発者の皆さんは
深い部分も気になるでしょう

00:08:15.229 --> 00:08:20.934 align:start position:30% line:-2
コードの重要な部分でも
Metalは貢献します

00:08:21.435 --> 00:08:27.674 align:start position:29% line:-2
参照カウントを手動化して
CPUの負担を減らせます

00:08:28.809 --> 00:08:33.746 align:start position:25% line:-2
アロケーションの制御には
Metalのヒープが有用です

00:08:35.148 --> 00:08:38.684 align:start position:32% line:-2
フェンスとイベントで
補完されています

00:08:38.784 --> 00:08:42.756 align:start position:32% line:-2
GPUの並列処理の
明示的制御が可能です

00:08:45.125 --> 00:08:49.229 align:start position:29% line:-2
昨今のゲームは
大量のリソースを使います

00:08:49.763 --> 00:08:52.533 align:start position:32% line:-2
アロケーションの際は
OSを往復して

00:08:52.633 --> 00:08:56.603 align:start position:29% line:-2
毎回 メモリを初期化する
必要があります

00:08:56.803 --> 00:08:59.206 align:start position:32% line:-2
レンダーターゲットが
一時的なものだと

00:08:59.306 --> 00:09:03.110 align:start position:29% line:-2
この動作による
処理落ちの恐れもあります

00:08:59.306 --> 00:09:03.110 align:start position:29% line:-2
この動作による
処理落ちの恐れもあります

00:09:03.577 --> 00:09:06.680 align:start position:34% line:-2
これを解消するのが
ヒープです

00:09:07.414 --> 00:09:12.286 align:start position:27% line:-2
あらかじめ 一部のメモリを
割り当てておき

00:09:12.386 --> 00:09:18.025 align:start position:27% line:-2
テクスチャやバッファを
あとで追加する際に使います

00:09:19.359 --> 00:09:23.297 align:start position:34% line:-2
３つのテクスチャを
処理する場合

00:09:23.764 --> 00:09:27.201 align:start position:34% line:-2
Metalでは
３つに割り振ります

00:09:27.668 --> 00:09:30.771 align:start position:30% line:-2
これらを
１つのヒープで処理して

00:09:30.871 --> 00:09:35.475 align:start position:27% line:-2
ヒープ作成時に
メモリ割り当てを実行します

00:09:35.576 --> 00:09:39.646 align:start position:30% line:-2
結果 テクスチャ作成の
コストが激減します

00:09:40.514 --> 00:09:43.851 align:start position:32% line:-2
さらに
隣接する領域を使えば

00:09:43.951 --> 00:09:47.688 align:start position:32% line:-2
メモリの有効利用にも
効果的です

00:09:48.856 --> 00:09:54.761 align:start position:27% line:-2
従来は割り当てを解除すると
メモリが一度OSに返され

00:09:54.862 --> 00:09:59.299 align:start position:29% line:-2
再度 テクスチャを使うと
一から割り当てます

00:09:59.399 --> 00:10:05.973 align:start position:25% line:-2
ヒープなら OSを往復せずに
再割り当てが可能になります

00:09:59.399 --> 00:10:05.973 align:start position:25% line:-2
ヒープなら OSを往復せずに
再割り当てが可能になります

00:10:08.408 --> 00:10:12.713 align:start position:30% line:-2
また 各メモリ領域に
別名を割り当てられます

00:10:14.047 --> 00:10:18.519 align:start position:32% line:-2
レンダーターゲットが
多いときに有用です

00:10:18.619 --> 00:10:22.055 align:start position:32% line:-2
メモリの無用な占有を
防ぐことで

00:10:22.156 --> 00:10:25.826 align:start position:36% line:-2
数百メガバイトを
節約できます

00:10:26.994 --> 00:10:29.730 align:start position:30% line:-2
高速なアロケーションは
利点ですが

00:10:29.830 --> 00:10:33.300 align:start position:36% line:-2
従属性の把握には
計算が必要です

00:10:33.400 --> 00:10:36.670 align:start position:34% line:-2
フレームを見ながら
説明します

00:10:38.672 --> 00:10:43.410 align:start position:23% line:-2
Metalは 個々のリソースを
把握しません

00:10:43.510 --> 00:10:47.014 align:start position:29% line:-2
よって Ｇバッファなどの
パス間の従属性を

00:10:47.114 --> 00:10:50.317 align:start position:29% line:-1
自動で読み書きできません

00:10:51.552 --> 00:10:56.356 align:start position:29% line:-2
そこで フェンスを用いて
データを生成するパスと

00:10:56.456 --> 00:10:58.692 align:start position:29% line:-1
消費するパスを明示します

00:10:58.792 --> 00:11:03.997 align:start position:29% line:-2
この例では Ｇバッファと
遅延シェーディングです

00:10:58.792 --> 00:11:03.997 align:start position:29% line:-2
この例では Ｇバッファと
遅延シェーディングです

00:11:04.565 --> 00:11:06.200 align:start position:38% line:-1
では ここで―

00:11:07.868 --> 00:11:10.737 align:start position:38% line:-2
実際のコードを
見てみましょう

00:11:14.241 --> 00:11:18.979 align:start position:30% line:-2
まず フェンスの概念を
このコードに導入します

00:11:19.880 --> 00:11:23.617 align:start position:27% line:-2
まず レンダーターゲットを
ヒープから割り当てます

00:11:23.717 --> 00:11:27.521 align:start position:29% line:-2
テクスチャの割り当てでは
一般的な作法です

00:11:28.755 --> 00:11:32.593 align:start position:27% line:-2
次に レンダーターゲットを
描画します

00:11:33.227 --> 00:11:38.198 align:start position:29% line:-2
フラグメント処理の完了後
フェンスを更新します

00:11:38.298 --> 00:11:43.337 align:start position:30% line:-2
次のパスに使われる前に
全データを出力できます

00:11:44.171 --> 00:11:47.708 align:start position:27% line:-2
今度は遅延シェーディングに
注目します

00:11:48.041 --> 00:11:52.946 align:start position:27% line:-2
レンダーターゲットを使って
物質の陰影を描きます

00:11:55.048 --> 00:11:59.853 align:start position:29% line:-2
フェンスが生成されるまで
待機します

00:12:00.487 --> 00:12:05.959 align:start position:27% line:-2
このフェンスは 他の処理に
再利用が可能なので

00:12:06.059 --> 00:12:08.095 align:start position:32% line:-1
メモリを節約できます

00:12:08.829 --> 00:12:14.034 align:start position:30% line:-2
並列処理による最適化の
方法をお話ししました

00:12:15.102 --> 00:12:19.873 align:start position:30% line:-2
しかし GPUをもっと
活用する方法があります

00:12:21.008 --> 00:12:23.844 align:start position:30% line:-1
GPUパイプラインです

00:12:25.546 --> 00:12:30.117 align:start position:27% line:-2
昨今のゲームは
複雑なロジックで動作します

00:12:31.652 --> 00:12:37.958 align:start position:29% line:-2
大量のオブジェクトを扱う
場合はなおさらです

00:12:38.926 --> 00:12:42.963 align:start position:30% line:-2
Metal 2では
新しい重要な一歩として

00:12:43.063 --> 00:12:45.732 align:start position:32% line:-2
GPUパイプラインに
着目しました

00:12:46.099 --> 00:12:49.369 align:start position:25% line:-2
昨年 紹介した
間接アーギュメントバッファは

00:12:49.469 --> 00:12:55.509 align:start position:29% line:-2
CPUの使用率を下げ
GPUの負担も軽減します

00:12:55.943 --> 00:13:00.180 align:start position:29% line:-2
今年 紹介するのは
間接コマンドバッファです

00:12:55.943 --> 00:13:00.180 align:start position:29% line:-2
今年 紹介するのは
間接コマンドバッファです

00:13:01.582 --> 00:13:05.853 align:start position:30% line:-2
レンダリング全体を
GPU上で処理できます

00:13:07.221 --> 00:13:10.591 align:start position:29% line:-2
アーギュメントバッファの
要点をまとめます

00:13:11.358 --> 00:13:14.862 align:start position:29% line:-1
構造は極めてシンプルです

00:13:15.729 --> 00:13:16.730 align:start position:43% line:-1
この通り

00:13:17.664 --> 00:13:23.337 align:start position:29% line:-2
定数に加え テクスチャと
サンプラーを使用します

00:13:23.537 --> 00:13:27.007 align:start position:27% line:-1
従来はシェーダが必要でした

00:13:28.642 --> 00:13:33.247 align:start position:27% line:-2
この構造なら Metalの
シェーディング言語を

00:13:33.347 --> 00:13:36.016 align:start position:38% line:-2
柔軟かつ簡単に
利用できます

00:13:36.116 --> 00:13:39.186 align:start position:29% line:-1
下部構造や配列だけでなく

00:13:39.286 --> 00:13:42.122 align:start position:29% line:-2
アーギュメントバッファの
ポインタも追加できます

00:13:43.023 --> 00:13:45.492 align:start position:30% line:-2
テクスチャと
サンプラーを編集すれば

00:13:45.592 --> 00:13:49.863 align:start position:27% line:-2
CPUを介さず GPU上に
マテリアルを生成できます

00:13:50.697 --> 00:13:56.270 align:start position:29% line:-2
配列と単一インスタンスの
ドローコールを利用した

00:13:56.670 --> 00:13:59.273 align:start position:34% line:-2
複数オブジェクトの
描画も可能です

00:14:00.340 --> 00:14:04.878 align:start position:32% line:-2
マテリアル管理を
GPUに委ねることで

00:14:05.078 --> 00:14:08.715 align:start position:30% line:-2
貴重なCPUリソースを
節約できます

00:14:08.815 --> 00:14:12.619 align:start position:34% line:-2
今年は もう少し
機能を拡張しました

00:14:13.820 --> 00:14:16.823 align:start position:27% line:-2
まず ２種類の
アーギュメントを加えました

00:14:17.491 --> 00:14:20.494 align:start position:32% line:-2
パイプライン状態と
コマンドバッファです

00:14:20.928 --> 00:14:25.165 align:start position:30% line:-2
間接コマンドバッファを
支えるものです

00:14:26.667 --> 00:14:31.338 align:start position:29% line:-2
これにより シーン全体を
GPU上で符号化できます

00:14:31.438 --> 00:14:34.675 align:start position:36% line:-2
スレッドの少ない
CPUとは違って

00:14:34.775 --> 00:14:40.647 align:start position:25% line:-2
GPUには 同時に利用できる
大量のスレッドがあります

00:14:41.615 --> 00:14:46.286 align:start position:27% line:-2
新機能はこの超並列の性質を
フル活用できます

00:14:47.487 --> 00:14:50.991 align:start position:30% line:-2
間接コマンドバッファは
再利用も可能です

00:14:51.091 --> 00:14:55.562 align:start position:32% line:-2
一度符号化を行えば
繰り返し使用できます

00:14:55.829 --> 00:15:01.902 align:start position:27% line:-2
直接アクセスできるので
いつでも内容を編集できます

00:14:55.829 --> 00:15:01.902 align:start position:27% line:-2
直接アクセスできるので
いつでも内容を編集できます

00:15:02.002 --> 00:15:07.007 align:start position:29% line:-2
例えば シェーダの種類や
カメラ行列です

00:15:07.274 --> 00:15:10.811 align:start position:25% line:-2
もちろん
GPUでレンダリングを行えば

00:15:10.911 --> 00:15:17.518 align:start position:21% line:-2
CPUとGPUの同期が不要になり
コストを大幅に減らせます

00:15:18.252 --> 00:15:20.087 align:start position:38% line:-1
例を紹介します

00:15:21.488 --> 00:15:23.457 align:start position:34% line:-1
典型的なゲームでは

00:15:23.557 --> 00:15:26.760 align:start position:30% line:-2
レンダリングに
共通する部分があります

00:15:26.960 --> 00:15:31.832 align:start position:27% line:-2
まずシーングラフを調査して
描画するオブジェクトを決定

00:15:33.066 --> 00:15:37.638 align:start position:27% line:-2
視すい台カリングで
視界に入る物体を判定します

00:15:37.805 --> 00:15:42.543 align:start position:30% line:-2
もっと複雑な手法を使う
開発者もいるでしょう

00:15:42.843 --> 00:15:47.281 align:start position:32% line:-2
詳細度の設定も
この時点で行われます

00:15:47.514 --> 00:15:52.452 align:start position:29% line:-2
コマンドバッファを送ると
GPUがそれを消費します

00:15:55.722 --> 00:16:00.861 align:start position:25% line:-2
可視オブジェクトの判定を
GPUで行うゲームは多いです

00:15:55.722 --> 00:16:00.861 align:start position:25% line:-2
可視オブジェクトの判定を
GPUで行うゲームは多いです

00:16:01.428 --> 00:16:06.099 align:start position:25% line:-2
GPUは複雑なシーンの処理に
向いているのです

00:16:06.900 --> 00:16:11.205 align:start position:32% line:-2
ただし この処理では
同期点が生じます

00:16:12.873 --> 00:16:18.245 align:start position:25% line:-2
GPUがデータを生成するまで
CPUは描画できません

00:16:18.345 --> 00:16:20.581 align:start position:34% line:-1
これを調整するには

00:16:20.681 --> 00:16:24.985 align:start position:30% line:-2
同期に使用時間を
浪費するしかありません

00:16:25.619 --> 00:16:28.522 align:start position:30% line:-2
その点
新機能の効果は絶大です

00:16:28.622 --> 00:16:32.459 align:start position:32% line:-2
最終ビットを
GPUに委ねることで

00:16:32.559 --> 00:16:36.029 align:start position:34% line:-2
データ移動に使う
同期点をなくします

00:16:36.129 --> 00:16:39.399 align:start position:30% line:-2
結果 CPUとGPUの
使用率が改善します

00:16:39.766 --> 00:16:44.304 align:start position:23% line:-2
また CPUのオーバーヘッドを
一定量減らせます

00:16:45.739 --> 00:16:48.475 align:start position:29% line:-1
符号化の詳細を見てみます

00:16:50.277 --> 00:16:53.080 align:start position:29% line:-1
まずは 前の例を応用して

00:16:53.180 --> 00:16:57.584 align:start position:27% line:-2
GPUが持つ超並列の性質に
注目しましょう

00:16:58.185 --> 00:17:03.423 align:start position:27% line:-2
最初に 可視オブジェクトと
詳細度をリスト化します

00:16:58.185 --> 00:17:03.423 align:start position:27% line:-2
最初に 可視オブジェクトと
詳細度をリスト化します

00:17:03.857 --> 00:17:07.426 align:start position:29% line:-2
アーギュメントバッファの
機能をここで活用します

00:17:07.761 --> 00:17:13.200 align:start position:27% line:-2
各エレメントはプロパティを
参照しているので

00:17:13.300 --> 00:17:16.236 align:start position:36% line:-2
複数のバッファを
兼用できます

00:17:18.505 --> 00:17:21.942 align:start position:27% line:-2
メモリを節約し
パフォーマンスを改善します

00:17:22.041 --> 00:17:25.479 align:start position:32% line:-2
構築する情報リストが
小さいためです

00:17:25.779 --> 00:17:30.250 align:start position:30% line:-2
数段階の詳細度で
ジオメトリを保管します

00:17:30.851 --> 00:17:36.957 align:start position:27% line:-2
ジオメトリは 配置情報や
頂点バッファなどを含みます

00:17:37.424 --> 00:17:41.595 align:start position:27% line:-2
オブジェクトごとに詳細度を
１つ選んで描画します

00:17:43.130 --> 00:17:46.233 align:start position:29% line:-1
カーネルで符号化を実行し

00:17:46.333 --> 00:17:49.069 align:start position:30% line:-2
間接コマンドバッファに
格納します

00:17:49.736 --> 00:17:54.107 align:start position:29% line:-2
１つのドローコールを
各スレッドで符号化します

00:17:54.474 --> 00:17:57.311 align:start position:30% line:-2
プロパティと一緒に
オブジェクトを読み込み

00:17:58.011 --> 00:18:00.247 align:start position:34% line:-1
符号化を実行します

00:17:58.011 --> 00:18:00.247 align:start position:34% line:-1
符号化を実行します

00:18:01.915 --> 00:18:04.117 align:start position:30% line:-1
間接コマンドバッファは

00:18:04.251 --> 00:18:07.588 align:start position:30% line:-2
描画コマンドの配列だと
考えられます

00:18:07.688 --> 00:18:13.760 align:start position:27% line:-2
シェーダやドローコールで
構成されたパイプラインです

00:18:14.628 --> 00:18:17.464 align:start position:27% line:-1
また 並列処理が可能なため

00:18:17.564 --> 00:18:20.567 align:start position:32% line:-2
符号化は
同時進行で行われます

00:18:21.001 --> 00:18:23.971 align:start position:27% line:-1
Metalはシンプルなので

00:18:24.071 --> 00:18:27.174 align:start position:30% line:-2
CPUで処理するような
軽快さです

00:18:28.342 --> 00:18:32.646 align:start position:27% line:-2
加えて 各コマンドは
個別のプロパティを持てます

00:18:32.880 --> 00:18:36.316 align:start position:32% line:-1
これは大きな前進です

00:18:36.416 --> 00:18:40.154 align:start position:34% line:-2
間接レンダリングが
再現できるのです

00:18:40.888 --> 00:18:43.357 align:start position:30% line:-1
コードを見てみましょう

00:18:44.825 --> 00:18:47.828 align:start position:30% line:-2
ドローコールの符号化は
簡単です

00:18:48.362 --> 00:18:53.433 align:start position:25% line:-2
まず スレッドIDを取得して
描画コマンドを選びます

00:18:55.402 --> 00:18:57.404 align:start position:27% line:-1
次にプロパティを設定します

00:18:57.504 --> 00:19:00.908 align:start position:34% line:-2
この例では
シェーダを設けます

00:18:57.504 --> 00:19:00.908 align:start position:34% line:-2
この例では
シェーダを設けます

00:19:02.142 --> 00:19:05.345 align:start position:29% line:-2
ジオメトリ用のバッファも
用意しました

00:19:06.113 --> 00:19:08.849 align:start position:32% line:-2
最後がドローコールの
符号化です

00:19:08.949 --> 00:19:13.520 align:start position:29% line:-2
シェーディング言語により
符号化は簡単になります

00:19:13.821 --> 00:19:19.293 align:start position:27% line:-2
GPUでの符号化ですが
CPUのようにシンプルです

00:19:20.094 --> 00:19:21.962 align:start position:36% line:-1
もう１つの例です

00:19:22.996 --> 00:19:29.203 align:start position:27% line:-2
間接コマンドバッファを
生成し 実行するコードです

00:19:29.837 --> 00:19:32.839 align:start position:27% line:-1
まず 記述子に値を入れます

00:19:33.140 --> 00:19:35.309 align:start position:32% line:-1
記述子に含まれるのは

00:19:35.676 --> 00:19:40.447 align:start position:30% line:-2
継承されたプロパティや
ドロータイプなどです

00:19:40.547 --> 00:19:43.884 align:start position:27% line:-1
バッファの挙動を記述します

00:19:46.353 --> 00:19:48.088 align:start position:39% line:-1
符号化の際は

00:19:48.188 --> 00:19:52.626 align:start position:30% line:-2
エンコーダを作成して
リソースを割り当てます

00:19:53.927 --> 00:19:58.298 align:start position:32% line:-2
符号化が終わると
最適化が実行できます

00:19:58.398 --> 00:20:01.235 align:start position:27% line:-1
すると冗長コードが削除され

00:19:58.398 --> 00:20:01.235 align:start position:27% line:-1
すると冗長コードが削除され

00:20:01.335 --> 00:20:05.472 align:start position:29% line:-2
無駄のない
GPUコマンドが残ります

00:20:06.373 --> 00:20:11.645 align:start position:27% line:-2
符号化と最適化が済んだら
バッファの実行を予約します

00:20:11.879 --> 00:20:16.717 align:start position:29% line:-2
実行するコマンドの範囲を
指定することも可能です

00:20:17.251 --> 00:20:22.856 align:start position:27% line:-2
この例では 間接バッファを
GPUで符号化しています

00:20:25.459 --> 00:20:29.596 align:start position:34% line:-2
一度 符号化すれば
再利用できるので

00:20:29.696 --> 00:20:32.499 align:start position:36% line:-2
オーバーヘッドは
無視できます

00:20:32.766 --> 00:20:37.638 align:start position:29% line:-2
実際の挙動が分かる
サンプルをご用意しました

00:20:39.439 --> 00:20:43.110 align:start position:34% line:-2
複数台のバスが
街に停車しています

00:20:43.944 --> 00:20:50.617 align:start position:23% line:-2
それぞれ50万枚のポリゴンと
2000個のパーツから成ります

00:20:51.785 --> 00:20:54.121 align:start position:36% line:-1
各パーツに対して

00:20:54.221 --> 00:20:58.025 align:start position:30% line:-2
ドローコールや
各種バッファが必要です

00:20:58.792 --> 00:21:02.629 align:start position:32% line:-2
大量のAPIコールが
生じますが

00:20:58.792 --> 00:21:02.629 align:start position:32% line:-2
大量のAPIコールが
生じますが

00:21:02.729 --> 00:21:07.701 align:start position:27% line:-2
間接コマンドバッファなら
すべてGPUで処理できます

00:21:09.736 --> 00:21:15.008 align:start position:32% line:-2
最適な詳細度を選べば
負担を増やさずに

00:21:15.109 --> 00:21:19.479 align:start position:32% line:-2
複数のオブジェクトを
描画できます

00:21:19.613 --> 00:21:22.749 align:start position:30% line:-1
左は通常のカメラの映像

00:21:22.849 --> 00:21:25.252 align:start position:30% line:-1
右はバスの拡大表示です

00:21:25.352 --> 00:21:28.288 align:start position:29% line:-1
詳細度が変化していきます

00:21:29.690 --> 00:21:34.127 align:start position:29% line:-2
この他にも
驚くべき最適化を行います

00:21:35.796 --> 00:21:39.500 align:start position:30% line:-2
ポリゴンを数百枚ごとに
チャンクに分割し

00:21:39.600 --> 00:21:42.503 align:start position:27% line:-1
個別のカーネルで分析します

00:21:43.270 --> 00:21:46.006 align:start position:36% line:-2
各チャンクを
色分けしています

00:21:47.007 --> 00:21:51.111 align:start position:30% line:-2
各スレッドが
カメラに映らない部分や

00:21:51.211 --> 00:21:55.249 align:start position:27% line:-2
オブジェクトで隠れる部分を
判断します

00:21:55.682 --> 00:22:00.254 align:start position:27% line:-2
ポリゴンではなく
チャンクごとに計算するので

00:21:55.682 --> 00:22:00.254 align:start position:27% line:-2
ポリゴンではなく
チャンクごとに計算するので

00:22:00.354 --> 00:22:02.723 align:start position:32% line:-1
処理は非常に高速です

00:22:03.490 --> 00:22:07.761 align:start position:32% line:-2
見えるチャンクだけを
GPUに描画させます

00:22:10.631 --> 00:22:13.233 align:start position:29% line:-1
次はこちらの比較映像です

00:22:13.333 --> 00:22:17.905 align:start position:27% line:-2
左はカメラの視点
右は別角度から見たバスです

00:22:18.438 --> 00:22:21.175 align:start position:30% line:-1
赤色やピンク色の部分は

00:22:21.275 --> 00:22:24.645 align:start position:34% line:-2
見えないと
判断された部分です

00:22:26.046 --> 00:22:28.448 align:start position:27% line:-1
GPUの処理が生じないため

00:22:28.549 --> 00:22:32.953 align:start position:29% line:-2
ジオメトリの描画コストは
半分以下になります

00:22:36.590 --> 00:22:41.028 align:start position:29% line:-2
この映像を見れば
効果の大きさが分かります

00:22:41.728 --> 00:22:46.333 align:start position:32% line:-2
多くのバスや救急車は
視界の外にあります

00:22:50.771 --> 00:22:53.240 align:start position:36% line:-1
画期的な技術です

00:22:53.507 --> 00:22:56.276 align:start position:32% line:-2
ぜひ一度
コードをご覧ください

00:22:56.376 --> 00:23:00.147 align:start position:34% line:-2
近い将来 皆さんが
この技術を導入して

00:22:56.376 --> 00:23:00.147 align:start position:34% line:-2
近い将来 皆さんが
この技術を導入して

00:23:00.280 --> 00:23:04.785 align:start position:27% line:-2
新時代のゲームを
開発することを願っています

00:23:05.252 --> 00:23:08.422 align:start position:27% line:-1
続いては 同僚のマイケルが

00:23:08.522 --> 00:23:13.260 align:start position:29% line:-2
A11に最適化する方法を
お伝えします

00:23:13.360 --> 00:23:14.695 align:start position:41% line:-1
ありがとう

00:23:14.795 --> 00:23:20.267 align:start position:43% line:-1
(拍手)

00:23:20.601 --> 00:23:21.568 align:start position:45% line:-1
どうも

00:23:22.269 --> 00:23:27.608 align:start position:16% line:-2
彼が紹介した技術は
iOS tvOS macOSで使えます

00:23:28.242 --> 00:23:33.514 align:start position:21% line:-2
次はAppleの最新GPU
A11 Bionicを紹介します

00:23:33.614 --> 00:23:37.351 align:start position:27% line:-2
メモリのバンド幅を減らして
消費電力を抑え

00:23:37.451 --> 00:23:41.054 align:start position:29% line:-2
ゲームのパフォーマンスを
向上させます

00:23:45.192 --> 00:23:48.695 align:start position:20% line:-2
Apple製GPUはタイルベースの
遅延レンダリングで

00:23:48.796 --> 00:23:51.865 align:start position:32% line:-2
高性能と低消費電力を
実現します

00:23:52.266 --> 00:23:56.837 align:start position:30% line:-2
高帯域かつ低遅延の
タイルメモリを活用して

00:23:56.937 --> 00:24:00.240 align:start position:34% line:-2
オーバードローを
排除しているのです

00:23:56.937 --> 00:24:00.240 align:start position:34% line:-2
オーバードローを
排除しているのです

00:24:02.509 --> 00:24:08.115 align:start position:27% line:-2
Metalはこの機能を
各レンダリングパスに適用し

00:24:08.315 --> 00:24:13.620 align:start position:30% line:-2
アクションやアタッチの
読み書きを行います

00:24:16.290 --> 00:24:20.060 align:start position:32% line:-2
A11はこの構造が
さらに強化されました

00:24:20.327 --> 00:24:25.232 align:start position:29% line:-2
新機能が追加され
プログラム制御も可能です

00:24:25.732 --> 00:24:30.270 align:start position:27% line:-2
高度なレンダリング技術への
最適化が可能です

00:24:30.370 --> 00:24:33.907 align:start position:29% line:-2
遅延シェーディングや
順番に依存しない透明処理

00:24:34.007 --> 00:24:36.777 align:start position:29% line:-1
粒子レンダリングなどです

00:24:37.611 --> 00:24:41.181 align:start position:29% line:-2
では 最初に
この構造を見てみましょう

00:24:44.051 --> 00:24:47.988 align:start position:30% line:-2
このブロック図の左側が
A11 Bionicで

00:24:48.088 --> 00:24:49.990 align:start position:30% line:-1
右がシステムメモリです

00:24:51.725 --> 00:24:56.997 align:start position:25% line:-2
頂点のレンダリング時に
A11が全ジオメトリを処理し

00:24:57.097 --> 00:25:02.169 align:start position:29% line:-2
タイル化された
頂点バッファに変換します

00:24:57.097 --> 00:25:02.169 align:start position:29% line:-2
タイル化された
頂点バッファに変換します

00:25:02.536 --> 00:25:05.305 align:start position:29% line:-2
これらはシステムメモリに
保存されます

00:25:07.508 --> 00:25:12.846 align:start position:25% line:-2
次に A11でフラグメントの
一部として処理されます

00:25:13.547 --> 00:25:18.218 align:start position:30% line:-2
この構造は ２つの面で
ゲームを最適化できます

00:25:19.987 --> 00:25:22.856 align:start position:32% line:-2
まず タイル化された
プリミティブが

00:25:22.956 --> 00:25:26.593 align:start position:30% line:-2
陰影処理の前に
ラスタライズされること

00:25:26.760 --> 00:25:31.098 align:start position:27% line:-2
これにより
オーバードローをなくせます

00:25:32.933 --> 00:25:38.071 align:start position:27% line:-2
次に 柔軟なタイルメモリに
フラグメントを保存すること

00:25:38.272 --> 00:25:43.177 align:start position:27% line:-2
シェーダが近いので
データのやりとりが高速です

00:25:44.978 --> 00:25:50.784 align:start position:27% line:-2
タイルメモリは陰影処理後に
一度書き込まれるだけなので

00:25:51.151 --> 00:25:55.556 align:start position:32% line:-2
バンド幅が小さくなり
消費電力も減ります

00:25:56.723 --> 00:26:00.227 align:start position:32% line:-2
Metalを導入した
iOSさえあれば

00:25:56.723 --> 00:26:00.227 align:start position:32% line:-2
Metalを導入した
iOSさえあれば

00:26:00.360 --> 00:26:02.663 align:start position:34% line:-1
これらが実現します

00:26:03.197 --> 00:26:08.969 align:start position:27% line:-2
メモリの明示的制御により
レンダリングも最適化します

00:26:11.071 --> 00:26:13.240 align:start position:30% line:-1
A11の開発にあたって

00:26:13.340 --> 00:26:18.178 align:start position:27% line:-2
我々は レンダリング技術の
分析を重ねました

00:26:18.645 --> 00:26:21.448 align:start position:29% line:-1
その結果 多くの共通点と

00:26:21.548 --> 00:26:25.119 align:start position:27% line:-2
タイルメモリの明示的制御の
有効性に気付きます

00:26:26.987 --> 00:26:31.792 align:start position:27% line:-2
そこで明示的制御に着目した
新機能を開発しました

00:26:32.559 --> 00:26:34.261 align:start position:39% line:-1
ご紹介します

00:26:41.535 --> 00:26:45.372 align:start position:23% line:-2
プログラマブルブレンディングは
シェーダのカスタム調整や

00:26:45.505 --> 00:26:51.111 align:start position:27% line:-2
レンダリングパスの統合を
iOSのGPUで実現します

00:26:52.346 --> 00:26:56.049 align:start position:27% line:-2
イメージブロックは
ピクセル配置を直接制御して

00:26:56.150 --> 00:26:59.353 align:start position:36% line:-2
タイルメモリを
無駄なく使います

00:27:01.188 --> 00:27:06.860 align:start position:27% line:-2
タイルシェーディングは
合成と演算処理の新技術です

00:27:08.428 --> 00:27:11.932 align:start position:29% line:-2
パーシステント･
スレッドグループメモリは

00:27:12.032 --> 00:27:14.868 align:start position:30% line:-2
ドローとディスパッチの
通信を可能にします

00:27:16.770 --> 00:27:18.872 align:start position:29% line:-2
マルチサンプル･カラー
カバレッジコントロールは

00:27:18.972 --> 00:27:23.811 align:start position:27% line:-2
予備の操作をタイルメモリで
直接 実行します

00:27:24.912 --> 00:27:28.682 align:start position:23% line:-2
プログラマブルブレンディングを
最初に紹介します

00:27:31.752 --> 00:27:36.190 align:start position:29% line:-2
これを使うと シェーダが
ピクセルに読み書きして

00:27:36.390 --> 00:27:39.026 align:start position:30% line:-2
ブレンディングの
カスタム操作が可能です

00:27:40.861 --> 00:27:44.164 align:start position:27% line:-2
また 複数の
レンダリングパスをまとめて

00:27:44.264 --> 00:27:48.168 align:start position:30% line:-2
システムメモリの
バンド幅を小さくします

00:27:49.837 --> 00:27:54.741 align:start position:27% line:-2
遅延シェーディングは
この機能と相性がいいのです

00:27:58.412 --> 00:28:02.816 align:start position:27% line:-2
従来の遅延シェーディングは
２パスを使います

00:27:58.412 --> 00:28:02.816 align:start position:27% line:-2
従来の遅延シェーディングは
２パスを使います

00:28:02.983 --> 00:28:08.455 align:start position:27% line:-2
１パス目は アタッチに
ジオメトリ属性を入力します

00:28:08.555 --> 00:28:11.658 align:start position:30% line:-2
例えば
法線やアルベドなどです

00:28:12.292 --> 00:28:16.230 align:start position:27% line:-2
２パス目は フラグメントの
陰影処理をします

00:28:18.999 --> 00:28:23.537 align:start position:27% line:-2
システムメモリに
Ｇバッファが保存されるので

00:28:23.704 --> 00:28:28.175 align:start position:30% line:-2
タイルメモリとの往復で
ゲームが重くなります

00:28:28.275 --> 00:28:31.345 align:start position:30% line:-2
Ｇバッファは
バンド幅が広いからです

00:28:32.412 --> 00:28:36.016 align:start position:21% line:-2
プログラマブルブレンディングなら
メモリ間の往復を省けます

00:28:36.116 --> 00:28:39.353 align:start position:27% line:-2
ピクセルをタイルメモリから
読み込むからです

00:28:42.489 --> 00:28:44.825 align:start position:30% line:-1
もう２パスは使いません

00:28:44.925 --> 00:28:50.597 align:start position:29% line:-2
１つのレンダリングパスで
陰影処理が実行できます

00:28:51.465 --> 00:28:56.270 align:start position:27% line:-2
システムメモリへの
Ｇバッファの複製も不要です

00:28:57.838 --> 00:29:03.410 align:start position:27% line:-2
無記憶レンダーターゲットは
簡単にメモリを節約できます

00:28:57.838 --> 00:29:03.410 align:start position:27% line:-2
無記憶レンダーターゲットは
簡単にメモリを節約できます

00:29:03.510 --> 00:29:06.180 align:start position:30% line:-2
テクスチャに
フラグを設定するだけで

00:29:06.280 --> 00:29:10.517 align:start position:30% line:-2
アクションを参照せずに
アタッチを使えます

00:29:12.453 --> 00:29:15.956 align:start position:32% line:-2
この機能をシェーダに
導入するのは簡単です

00:29:19.293 --> 00:29:23.730 align:start position:30% line:-2
フラグメントシェーダの
典型的なコードです

00:29:24.431 --> 00:29:27.901 align:start position:23% line:-2
プログラマブルブレンディングは
読み書き時に使用可能です

00:29:28.001 --> 00:29:33.240 align:start position:27% line:-2
この例では Ｇバッファを
入力と出力に指定しています

00:29:35.475 --> 00:29:38.479 align:start position:29% line:-1
最初に 陰影を計算します

00:29:38.779 --> 00:29:42.750 align:start position:32% line:-2
サンプリングはせず
Ｇバッファを用います

00:29:44.651 --> 00:29:50.524 align:start position:30% line:-2
次に 蓄えた計算結果を
Ｇバッファに返します

00:29:52.326 --> 00:29:54.261 align:start position:38% line:-1
これで終了です

00:29:54.361 --> 00:29:59.733 align:start position:27% line:-2
同一のアタッチを参照する
複数のパスの処理に有効です

00:30:01.468 --> 00:30:03.637 align:start position:29% line:-1
イメージブロックを使えば

00:30:03.737 --> 00:30:07.007 align:start position:32% line:-2
複数のレンダーパスを
統合できます

00:30:12.346 --> 00:30:15.415 align:start position:29% line:-2
データは
タイルメモリで処理します

00:30:15.582 --> 00:30:16.884 align:start position:38% line:-1
Metalでは

00:30:16.984 --> 00:30:21.021 align:start position:27% line:-2
レンダーパスの配列としての
画素を使いません

00:30:21.321 --> 00:30:26.126 align:start position:27% line:-2
直接 シェーディング言語に
置き換えられます

00:30:27.861 --> 00:30:30.464 align:start position:29% line:-2
使用しているテクスチャの
圧縮フォーマットに合わせ

00:30:30.564 --> 00:30:32.499 align:start position:32% line:-2
シェーディング言語に
書き換えます

00:30:32.733 --> 00:30:37.004 align:start position:29% line:-2
シェーダにアクセスすると
圧縮や解凍されるのです

00:30:37.604 --> 00:30:42.709 align:start position:29% line:-2
頂点バッファと
定数バッファもこの方法で

00:30:42.810 --> 00:30:44.812 align:start position:32% line:-1
データを圧縮できます

00:30:46.947 --> 00:30:50.951 align:start position:30% line:-2
より複雑な画像データも
描画できます

00:30:51.051 --> 00:30:56.256 align:start position:32% line:-2
配列や構造体のネスト
または両方を使えます

00:30:58.959 --> 00:31:01.395 align:start position:29% line:-1
ピクセル配列を変更すれば

00:30:58.959 --> 00:31:01.395 align:start position:29% line:-1
ピクセル配列を変更すれば

00:31:01.495 --> 00:31:04.498 align:start position:32% line:-2
パス上のレイアウトも
変わります

00:31:04.865 --> 00:31:07.935 align:start position:30% line:-2
レンダーパスを統合して
バンド幅を減らす方法は

00:31:08.035 --> 00:31:11.038 align:start position:25% line:-2
プログラマブルブレンディング
だけでは不可能でした

00:31:11.538 --> 00:31:13.040 align:start position:38% line:-1
例を見ましょう

00:31:15.609 --> 00:31:18.145 align:start position:30% line:-2
先ほどはプログラマブル
ブレンディングで

00:31:18.245 --> 00:31:20.414 align:start position:32% line:-2
遅延シェーディングを
１パスで実行しました

00:31:20.714 --> 00:31:24.184 align:start position:29% line:-2
これをイメージブロックを
使用して行います

00:31:25.319 --> 00:31:29.223 align:start position:32% line:-2
イメージブロックには
リソースがありません

00:31:29.923 --> 00:31:32.693 align:start position:34% line:-2
アルゴリズムを
そのまま書ける上に

00:31:32.826 --> 00:31:38.098 align:start position:27% line:-2
Ｇバッファを反映したタイル
メモリを再利用できます

00:31:38.699 --> 00:31:44.304 align:start position:30% line:-2
タイルメモリを再利用し
透明処理技術を加えます

00:31:44.404 --> 00:31:46.440 align:start position:27% line:-2
マルチレイヤー
アルファブレンディングです

00:31:51.311 --> 00:31:53.781 align:start position:25% line:-1
この方法はMLABとも呼ばれ

00:31:54.148 --> 00:31:58.218 align:start position:30% line:-2
画素ごとの固定長配列で
透過を行います

00:31:58.519 --> 00:32:01.655 align:start position:27% line:-2
フラグメントは配列の深度で
ソートされます

00:31:58.519 --> 00:32:01.655 align:start position:27% line:-2
フラグメントは配列の深度で
ソートされます

00:32:02.389 --> 00:32:05.325 align:start position:29% line:-2
フラグメント深度が最後の
配列より深ければ

00:32:05.425 --> 00:32:09.563 align:start position:29% line:-2
エレメントは
統合されることになります

00:32:11.565 --> 00:32:15.035 align:start position:23% line:-2
MLABではタイルメモリを使い
高速でソートをします

00:32:15.702 --> 00:32:20.641 align:start position:30% line:-2
同じことをオフチップで
すると費用がかさみます

00:32:23.210 --> 00:32:28.015 align:start position:30% line:-2
A11では高度な
ピクセル処理を行えます

00:32:29.183 --> 00:32:32.019 align:start position:29% line:-2
しかし Ｇバッファと
MLABのデータ構造を―

00:32:32.119 --> 00:32:34.888 align:start position:32% line:-2
同時に処理することは
できないのです

00:32:35.522 --> 00:32:38.492 align:start position:29% line:-2
ただ この２つを同時に
処理する必要はありません

00:32:38.826 --> 00:32:43.697 align:start position:27% line:-2
イメージブロックで
ピクセル配列を変更できます

00:32:45.732 --> 00:32:48.135 align:start position:38% line:-2
ピクセル配列の
変更に必要な―

00:32:48.235 --> 00:32:50.537 align:start position:30% line:-2
タイルシェーディングの
説明をします

00:32:56.743 --> 00:32:59.313 align:start position:27% line:-2
タイルシェーディングは
新しいプログラム工程であり

00:32:59.413 --> 00:33:02.316 align:start position:32% line:-2
レンダーパスに対し
処理能力を発揮します

00:32:59.413 --> 00:33:02.316 align:start position:32% line:-2
レンダーパスに対し
処理能力を発揮します

00:33:02.583 --> 00:33:03.784 align:start position:39% line:-1
この工程で―

00:33:03.884 --> 00:33:06.520 align:start position:32% line:-2
タイルごとのスレッド
グループを実行します

00:33:06.720 --> 00:33:09.189 align:start position:32% line:-2
１スレッドを
タイル単位で使っても

00:33:09.289 --> 00:33:11.191 align:start position:30% line:-2
ピクセル単位で使っても
いいのです

00:33:14.194 --> 00:33:16.296 align:start position:34% line:-2
ドローコールと
スレッドグループを

00:33:16.396 --> 00:33:19.466 align:start position:30% line:-1
インターリーブできます

00:33:19.666 --> 00:33:22.202 align:start position:29% line:-2
タイルシェーダはタイル
メモリにアクセスするので

00:33:22.302 --> 00:33:24.838 align:start position:27% line:-2
イメージブロックの
ピクセルを読み書きできます

00:33:26.406 --> 00:33:29.243 align:start position:32% line:-2
タイル単位の
前方シェーディングを

00:33:29.343 --> 00:33:31.645 align:start position:36% line:-2
最適化する過程を
見てみましょう

00:33:34.915 --> 00:33:38.285 align:start position:27% line:-2
前方シェーディングの技術も
レイヤー化されています

00:33:38.519 --> 00:33:42.489 align:start position:32% line:-2
MSAやマテリアルが
必要な時に使われます

00:33:42.689 --> 00:33:45.893 align:start position:27% line:-2
透過や不透過のジオメトリに
同じような効果があります

00:33:47.494 --> 00:33:50.731 align:start position:29% line:-2
前方シェーディングは
３つのパスで構成されます

00:33:51.231 --> 00:33:54.601 align:start position:30% line:-2
シーンの深度バッファを
出力するレンダーパス

00:33:55.002 --> 00:33:59.606 align:start position:27% line:-2
その深度バッファを使い
タイルごとの深度バウンドや

00:33:59.706 --> 00:34:02.776 align:start position:29% line:-2
ライトリストを
計算するコンピュートパス

00:33:59.706 --> 00:34:02.776 align:start position:29% line:-2
ライトリストを
計算するコンピュートパス

00:34:03.277 --> 00:34:08.415 align:start position:27% line:-2
そして シャドウを投影する
別のレンダーパスです

00:34:11.618 --> 00:34:15.589 align:start position:30% line:-2
これらのレンダーは
組み合わせて使われます

00:34:15.688 --> 00:34:19.560 align:start position:27% line:-2
パス同士のやりとりには
システムメモリを使いますが

00:34:20.060 --> 00:34:24.398 align:start position:27% line:-2
計算を同時に行うことで
レンダーパスを統合できます

00:34:26.967 --> 00:34:28.569 align:start position:36% line:-2
タイルシェーダで
深度バウンドと

00:34:28.668 --> 00:34:32.873 align:start position:27% line:-2
ライトカリングを行い
シングルパスに統合できます

00:34:33.373 --> 00:34:38.679 align:start position:29% line:-2
深度はパスのどの地点
からでもアクセス可能です

00:34:42.783 --> 00:34:46.587 align:start position:27% line:-2
つまり情報量を減らすことが
可能なのです

00:34:46.820 --> 00:34:49.889 align:start position:29% line:-2
タイルシェーダの出力先は
システムメモリです

00:34:50.757 --> 00:34:54.561 align:start position:32% line:-2
ディスパッチは描画と
同時に進行できますが

00:34:54.661 --> 00:34:57.464 align:start position:34% line:-2
次の機能を使えば
操作性が向上します

00:34:57.564 --> 00:34:59.133 align:start position:27% line:-1
スレッドグループメモリです

00:35:05.406 --> 00:35:08.575 align:start position:29% line:-2
Metalの機能としても
知られていますが

00:35:08.809 --> 00:35:12.946 align:start position:27% line:-2
スレッドが高速なオンチップ
メモリでデータを共有します

00:35:13.680 --> 00:35:17.718 align:start position:29% line:-2
スレッドグループメモリは
レンダーパスから使えます

00:35:18.552 --> 00:35:23.023 align:start position:27% line:-2
その際に 今までとは異なる
２つの特性があります

00:35:23.557 --> 00:35:25.092 align:start position:30% line:-1
フラグメントシェーダが

00:35:25.192 --> 00:35:27.828 align:start position:27% line:-2
同一のスレッドグループ
メモリにアクセスすることと

00:35:28.095 --> 00:35:30.564 align:start position:29% line:-2
スレッドグループメモリの
コンテンツが

00:35:30.664 --> 00:35:32.432 align:start position:36% line:-2
タイルと共に
持続することです

00:35:33.834 --> 00:35:36.670 align:start position:30% line:-2
描画と演算の
データを共有するための

00:35:36.770 --> 00:35:39.606 align:start position:29% line:-1
強力なツールになるのです

00:35:40.407 --> 00:35:45.979 align:start position:29% line:-2
以前は倍の容量のスレッド
グループメモリでした

00:35:46.079 --> 00:35:48.649 align:start position:34% line:-2
多くの中間データを
保存するためです

00:35:50.651 --> 00:35:52.820 align:start position:32% line:-2
スレッドグループの
パーシステンスを使い

00:35:52.920 --> 00:35:55.422 align:start position:32% line:-2
前方シェーディングを
最適化します

00:35:58.158 --> 00:36:03.197 align:start position:27% line:-2
パーシステンスを用いて
タイルシェーディング段階の

00:35:58.158 --> 00:36:03.197 align:start position:27% line:-2
パーシステンスを用いて
タイルシェーディング段階の

00:36:03.297 --> 00:36:07.468 align:start position:27% line:-2
描画データをスレッド
グループメモリに記述します

00:36:08.902 --> 00:36:11.638 align:start position:34% line:-2
中間データは
GPUに残りません

00:36:11.772 --> 00:36:15.509 align:start position:27% line:-2
最終イメージのみがシステム
メモリに保存されます

00:36:16.410 --> 00:36:22.049 align:start position:27% line:-2
情報量を最小化することで
パフォーマンスが向上します

00:36:23.684 --> 00:36:27.821 align:start position:27% line:-2
シェーディング言語で
パーシステンスを利用します

00:36:31.558 --> 00:36:35.729 align:start position:29% line:-2
上側の関数は
ライトカリングの命令です

00:36:35.829 --> 00:36:40.634 align:start position:29% line:-2
タイルごとの視すい台で
ライトマスクを計算します

00:36:42.069 --> 00:36:45.506 align:start position:27% line:-2
下側は前方シェーディングの
関数です

00:36:45.806 --> 00:36:49.610 align:start position:27% line:-2
タイルを横切るライトのみに
シェーディングします

00:36:51.879 --> 00:36:53.714 align:start position:30% line:-1
このような機能を用いて

00:36:53.814 --> 00:36:56.183 align:start position:29% line:-2
スレッドグループメモリを
共有します

00:36:56.283 --> 00:36:59.453 align:start position:29% line:-2
各ポイントの
シェーダを利用するのです

00:37:00.187 --> 00:37:03.156 align:start position:30% line:-2
これがパーシステンスを
使用する利点です

00:37:06.026 --> 00:37:09.062 align:start position:27% line:-1
それでは次の話題に移ります

00:37:09.163 --> 00:37:12.166 align:start position:38% line:-2
透明処理の例を
見てみましょう

00:37:14.101 --> 00:37:18.472 align:start position:21% line:-2
イメージブロックには
タイルシェーディングが関係します

00:37:19.039 --> 00:37:21.942 align:start position:30% line:-2
タイルシェーディングの
同期によって

00:37:22.042 --> 00:37:24.478 align:start position:34% line:-2
安全にレイアウトを
変更します

00:37:25.345 --> 00:37:29.416 align:start position:25% line:-2
ライティングとMLABの間に
タイルシェードが必要です

00:37:33.086 --> 00:37:39.159 align:start position:23% line:-2
ＧバッファからMLABへの移行
前にライティングをします

00:37:39.526 --> 00:37:45.098 align:start position:29% line:-2
ライティングバリューは
MLABへと持ち越せます

00:37:49.002 --> 00:37:53.173 align:start position:29% line:-2
それでは
次のテーマに移りましょう

00:37:53.273 --> 00:37:59.012 align:start position:27% line:-2
アンチエイリアスと
カバレッジコントロールです

00:38:03.150 --> 00:38:06.687 align:start position:30% line:-2
アンチエイリアスにより
画像の品質が向上します

00:38:06.787 --> 00:38:09.323 align:start position:27% line:-2
深度 ステンシル
ブレンディングを変更します

00:38:09.423 --> 00:38:11.425 align:start position:29% line:-2
シェードはピクセルにつき
一度です

00:38:11.792 --> 00:38:16.163 align:start position:27% line:-2
マルチサンプルを
アベレージングし仕上げます

00:38:18.031 --> 00:38:21.235 align:start position:32% line:-2
AシリーズのGPUで
効果を発揮します

00:38:21.335 --> 00:38:23.637 align:start position:30% line:-2
サンプルが
タイルメモリに保存され

00:38:23.737 --> 00:38:27.307 align:start position:30% line:-2
素早いアクセスを可能に
するからです

00:38:29.710 --> 00:38:33.046 align:start position:29% line:-2
A11のGPUでは
より早く最適化を行います

00:38:33.146 --> 00:38:35.716 align:start position:30% line:-2
画素ごとに色彩を
トラッキングするのです

00:38:36.149 --> 00:38:41.054 align:start position:29% line:-2
色ごとに
ブレンディングができます

00:38:41.555 --> 00:38:46.727 align:start position:29% line:-2
トライアングルの内部は
１色なので手間が省けます

00:38:49.129 --> 00:38:54.134 align:start position:32% line:-2
カラーカバレッジ
コントロールと呼ばれ

00:38:54.234 --> 00:38:55.903 align:start position:27% line:-1
GPUによって実行されます

00:38:56.437 --> 00:38:59.773 align:start position:27% line:-2
しかし色の読み込みや設定は
タイルシェーダが行います

00:39:00.741 --> 00:39:03.076 align:start position:29% line:-2
この機能はタイルメモリの
所定の位置に対し

00:39:03.177 --> 00:39:05.779 align:start position:30% line:-2
設定を選んで使うことが
できます

00:39:06.113 --> 00:39:08.348 align:start position:30% line:-1
マルチサンプリングされ

00:39:08.448 --> 00:39:11.485 align:start position:27% line:-2
粒子状にレンダリングされた
シーンを見てみます

00:39:14.388 --> 00:39:17.091 align:start position:27% line:-2
シーンジオメトリを不透過に
レンダリングしたあと

00:39:17.191 --> 00:39:18.959 align:start position:30% line:-1
粒子は透過表示されます

00:39:19.493 --> 00:39:24.031 align:start position:30% line:-2
マルチサンプリングでは
メリットがありません

00:39:24.731 --> 00:39:30.571 align:start position:29% line:-2
余計なコストを避けるため
レンダーに２パス使います

00:39:30.871 --> 00:39:36.076 align:start position:29% line:-2
１つ目のパスでは不透過の
シーンジオメトリを生成し

00:39:36.543 --> 00:39:39.479 align:start position:27% line:-2
色彩と深度を
システムメモリに解像します

00:39:39.580 --> 00:39:43.183 align:start position:34% line:-2
粒子データは後から
付け足せます

00:39:43.917 --> 00:39:47.221 align:start position:29% line:-2
２つ目のパスでは
マルチサンプリングなしで

00:39:47.321 --> 00:39:49.890 align:start position:29% line:-1
粒子をレンダリングします

00:39:51.425 --> 00:39:53.026 align:start position:32% line:-1
もうお分かりでしょう

00:39:53.126 --> 00:39:55.696 align:start position:32% line:-2
中間メモリの通信量を
減らすため

00:39:55.796 --> 00:39:58.365 align:start position:27% line:-2
２パスを使いタイル
シェーディングをしたのです

00:40:01.001 --> 00:40:02.803 align:start position:30% line:-1
それだけでは不十分です

00:40:02.903 --> 00:40:04.538 align:start position:34% line:-2
カラーカバレッジ
コントロールにより

00:40:04.638 --> 00:40:06.940 align:start position:27% line:-2
マルチサンプリングレートを
変更します

00:40:07.474 --> 00:40:11.311 align:start position:29% line:-1
効果的で 操作も簡単です

00:40:11.411 --> 00:40:12.813 align:start position:32% line:-1
シェーダを見てみます

00:40:16.150 --> 00:40:20.087 align:start position:32% line:-2
画素ごとのサンプルの
平均化が目的です

00:40:20.187 --> 00:40:24.491 align:start position:27% line:-2
結果のピクセル値はイメージ
ブロックに再保存します

00:40:26.093 --> 00:40:29.663 align:start position:30% line:-2
それぞれのサンプルから
色を使い回すのではなく

00:40:29.763 --> 00:40:32.833 align:start position:29% line:-2
A11のカラーレート
ケイパビリティを使います

00:40:32.933 --> 00:40:35.202 align:start position:29% line:-1
固有の色を設定するのです

00:40:37.204 --> 00:40:39.139 align:start position:34% line:-1
適正な平均化のため

00:40:39.239 --> 00:40:42.442 align:start position:30% line:-2
関連するサンプルの数で
色彩を計測します

00:40:42.542 --> 00:40:47.581 align:start position:29% line:-2
カラーカバレッジマスクの
ビット数も計算します

00:40:49.149 --> 00:40:52.519 align:start position:29% line:-2
更に サンプルの合計数で
平均値を出します

00:40:54.021 --> 00:40:56.990 align:start position:27% line:-2
最後に イメージブロックに
その結果を書き出します

00:40:57.091 --> 00:41:01.495 align:start position:29% line:-2
出力したサンプルマスクで
Metalが結果を適用し

00:40:57.091 --> 00:41:01.495 align:start position:29% line:-2
出力したサンプルマスクで
Metalが結果を適用し

00:41:01.962 --> 00:41:04.932 align:start position:34% line:-2
すべてのサンプルが
同じ値になります

00:41:05.032 --> 00:41:08.969 align:start position:27% line:-2
サンプルごとではなく
ピクセルごとに描画をします

00:41:11.305 --> 00:41:13.374 align:start position:27% line:-1
それでは次の話題に移ります

00:41:15.943 --> 00:41:18.912 align:start position:25% line:-2
Apple GPUの最適化は
重要で―

00:41:19.012 --> 00:41:22.750 align:start position:29% line:-2
パフォーマンスを最大化し
プレイ時間を伸ばします

00:41:22.950 --> 00:41:26.253 align:start position:25% line:-2
タイルをiOSに搭載するには
更にすることがあります

00:41:26.353 --> 00:41:29.323 align:start position:29% line:-2
元々はコンピュータ用に
設計されたものだからです

00:41:29.523 --> 00:41:33.060 align:start position:27% line:-2
ここまで話したことを
具体的に説明してもらいます

00:41:33.160 --> 00:41:35.929 align:start position:32% line:-2
エピック･ゲームズの
ニックを呼びましょう

00:41:36.030 --> 00:41:36.697 align:start position:45% line:-1
ニック

00:41:37.464 --> 00:41:40.534 align:start position:43% line:-1
(拍手)

00:41:40.968 --> 00:41:42.069 align:start position:32% line:-1
ありがとう マイケル

00:41:43.003 --> 00:41:48.709 align:start position:29% line:-2
コンピュータ用に設計した
ゲームを

00:41:49.476 --> 00:41:53.647 align:start position:25% line:-2
Metalを使いiOS向けに
移植する話をします

00:41:55.382 --> 00:41:57.584 align:start position:32% line:-2
技術的に難しいことが
いくつもありました

00:41:57.684 --> 00:42:00.254 align:start position:32% line:-2
「バトルロイヤル」の
マップは１つで

00:41:57.684 --> 00:42:00.254 align:start position:32% line:-2
「バトルロイヤル」の
マップは１つで

00:42:00.420 --> 00:42:02.156 align:start position:30% line:-2
６平方キロメートル以上
ありました

00:42:02.823 --> 00:42:06.193 align:start position:29% line:-2
メモリに
収まりきらなかったのです

00:42:06.360 --> 00:42:09.062 align:start position:27% line:-1
時間経過や破壊もありました

00:42:09.163 --> 00:42:11.965 align:start position:29% line:-2
プレイヤーはほぼすべての
物を壊せます

00:42:12.399 --> 00:42:14.601 align:start position:27% line:-1
建物を建てることもできます

00:42:14.701 --> 00:42:18.172 align:start position:30% line:-2
地図は動的なものとなり
前もって計算できません

00:42:19.006 --> 00:42:21.175 align:start position:32% line:-2
マップには100人の
プレイヤーがいて

00:42:21.275 --> 00:42:26.914 align:start position:32% line:-2
５万以上の登場人物が
サーバー上にいました

00:42:27.014 --> 00:42:28.815 align:start position:34% line:-2
クライアントへも
複製されていました

00:42:29.750 --> 00:42:32.052 align:start position:34% line:-2
クロスプレイを
実現したかったので

00:42:32.152 --> 00:42:35.823 align:start position:27% line:-2
モバイル端末もサポートする
必要がありました

00:42:36.056 --> 00:42:41.328 align:start position:32% line:-2
それを実現するには
ゲームの容量を減らし

00:42:41.795 --> 00:42:46.867 align:start position:27% line:-2
端末ごとに制限される
パフォーマンスに合わせます

00:42:46.967 --> 00:42:50.504 align:start position:29% line:-2
しかし プレイを
制限することはできません

00:42:50.604 --> 00:42:53.740 align:start position:32% line:-2
遠くにある
小さなオブジェクトは

00:42:53.841 --> 00:42:56.477 align:start position:29% line:-1
通常なら消してしまいます

00:42:56.577 --> 00:42:59.713 align:start position:27% line:-2
しかし プレイヤーがそこに
隠れる場合に備え

00:42:59.813 --> 00:43:01.215 align:start position:32% line:-1
残す必要がありました

00:42:59.813 --> 00:43:01.215 align:start position:32% line:-1
残す必要がありました

00:43:02.783 --> 00:43:05.786 align:start position:25% line:-1
ここでMetalの話をします

00:43:05.886 --> 00:43:08.889 align:start position:30% line:-2
できるだけ早くゲームを
リリースするために

00:43:08.989 --> 00:43:11.592 align:start position:23% line:-1
Metalが重要になってきます

00:43:11.692 --> 00:43:14.161 align:start position:29% line:-1
クオリティの面からもです

00:43:14.361 --> 00:43:19.500 align:start position:27% line:-2
複雑なシーンを描くため
ドローコールの性能は重要で

00:43:20.467 --> 00:43:24.438 align:start position:27% line:-2
Metalはレンダリングの
機能も十分です

00:43:24.571 --> 00:43:26.340 align:start position:30% line:-2
更にプログラマブル
ブレンディングのような

00:43:26.440 --> 00:43:28.408 align:start position:29% line:-2
ハードウェア上の機能にも
アクセスできます

00:43:28.509 --> 00:43:32.079 align:start position:29% line:-2
GPUのパフォーマンスも
最大化できます

00:43:32.179 --> 00:43:34.681 align:start position:27% line:-2
「フォートナイト」を
iOS向けに構成する際にも

00:43:34.781 --> 00:43:37.251 align:start position:30% line:-2
レンダリング技術を活用
できる機能があります

00:43:38.719 --> 00:43:40.454 align:start position:34% line:-1
レンダリングの際に

00:43:40.554 --> 00:43:44.024 align:start position:27% line:-2
カスケードシャドウマップで
指向性ライトを動かせます

00:43:44.124 --> 00:43:47.327 align:start position:30% line:-2
時間の変化で太陽や空の
光を変化させるのです

00:43:47.961 --> 00:43:51.131 align:start position:30% line:-2
物理ベースマテリアルを
扱う際に―

00:43:51.331 --> 00:43:54.701 align:start position:30% line:-2
HDRでレンダリングし
トーンマッピングします

00:43:55.569 --> 00:43:57.871 align:start position:29% line:-2
粒子法シミュレーションも
GPUで実行できますし

00:43:57.971 --> 00:44:01.208 align:start position:27% line:-2
アーティストが作成した
マテリアルもサポートします

00:43:57.971 --> 00:44:01.208 align:start position:27% line:-2
アーティストが作成した
マテリアルもサポートします

00:44:01.575 --> 00:44:03.877 align:start position:32% line:-1
これが重要な理由は―

00:44:03.977 --> 00:44:08.148 align:start position:32% line:-2
マテリアルの一部が
複雑なことにあります

00:44:08.248 --> 00:44:10.417 align:start position:29% line:-2
ディスタンス
エフィシエンシーにおいて

00:44:10.517 --> 00:44:13.153 align:start position:30% line:-2
レンダーツリーに使う
インポスターがあります

00:44:13.253 --> 00:44:16.090 align:start position:32% line:-2
弊社のテクニカル
アーティストによって

00:44:16.190 --> 00:44:21.061 align:start position:29% line:-2
設計図とシェーダグラフを
組み合わせ 創作されます

00:44:22.863 --> 00:44:26.867 align:start position:32% line:-2
「フォートナイト」の
Mac上での画面です

00:44:26.967 --> 00:44:29.203 align:start position:30% line:-2
ハイスケーラビリティの
設定です

00:44:29.903 --> 00:44:34.141 align:start position:32% line:-2
これはミディアム
スケーラビリティ設定

00:44:34.708 --> 00:44:37.111 align:start position:18% line:-1
これはiPhone 8 Plusです

00:44:37.411 --> 00:44:39.146 align:start position:29% line:-1
iPhone上での表示は

00:44:39.279 --> 00:44:44.852 align:start position:27% line:-2
ミディアム設定のMacと
同程度の品質を実現しました

00:44:46.753 --> 00:44:49.156 align:start position:29% line:-2
スケーラビリティについて
お話しします

00:44:49.389 --> 00:44:51.458 align:start position:38% line:-2
クロスプラット
フォームと―

00:44:51.558 --> 00:44:53.927 align:start position:30% line:-2
エコシステムの観点から
説明します

00:44:54.094 --> 00:44:58.732 align:start position:29% line:-2
クロスプラットフォームに
必要なことがあります

00:44:59.233 --> 00:45:04.104 align:start position:29% line:-2
表示されないようLODを
メッシュから省いたり

00:44:59.233 --> 00:45:04.104 align:start position:29% line:-2
表示されないようLODを
メッシュから省いたり

00:45:04.204 --> 00:45:08.509 align:start position:30% line:-2
登場人物の数を
減らしたりすることです

00:45:08.809 --> 00:45:12.045 align:start position:25% line:-2
特定レベルでの
CPUコストを減らすためです

00:45:12.679 --> 00:45:15.382 align:start position:30% line:-2
iOSでは
スケーラビリティのため

00:45:15.482 --> 00:45:18.152 align:start position:27% line:-2
ロー ミッド ハイの
３バケットを定義しています

00:45:18.252 --> 00:45:22.556 align:start position:21% line:-2
これは他の世代のiPhoneにも
当てはまります

00:45:22.656 --> 00:45:26.693 align:start position:21% line:-2
iPhone 6sはロー
iPhone 7はミッドレンジで

00:45:26.793 --> 00:45:29.196 align:start position:18% line:-2
iPhone 8とiPhone Xは
ハイエンドです

00:45:31.198 --> 00:45:34.601 align:start position:34% line:-2
解像度は
単純かつ効果的な―

00:45:34.701 --> 00:45:37.571 align:start position:34% line:-2
スケーラビリティの
選択肢です

00:45:37.671 --> 00:45:39.439 align:start position:30% line:-1
端末ごとに調整できます

00:45:39.740 --> 00:45:44.111 align:start position:29% line:-2
私たちは可能な限り
バックバッファを使います

00:45:44.645 --> 00:45:49.016 align:start position:27% line:-2
余計なアップサンプリングの
コストがかからないからです

00:45:49.116 --> 00:45:53.454 align:start position:29% line:-2
３Ｄ画像を低解像度で
生成するサポートもします

00:45:53.554 --> 00:45:56.790 align:start position:30% line:-2
クリスプなUIを
作成する時にも行います

00:45:56.890 --> 00:46:00.394 align:start position:27% line:-2
例えばiPhone 6では
3D解像度を低く生成し

00:45:56.890 --> 00:46:00.394 align:start position:27% line:-2
例えばiPhone 6では
3D解像度を低く生成し

00:46:00.494 --> 00:46:04.832 align:start position:29% line:-2
パフォーマンスの目標に
合わせる必要がありました

00:46:06.366 --> 00:46:09.603 align:start position:34% line:-2
シャドウも
重要なポイントです

00:46:09.703 --> 00:46:12.740 align:start position:30% line:-2
CPUとGPUの両方に
影響があるからです

00:46:12.940 --> 00:46:16.410 align:start position:30% line:-2
ローエンド端末では
シャドウを生成しません

00:46:16.510 --> 00:46:18.912 align:start position:25% line:-2
ミッドレンジでは
1024x1024テクセルの

00:46:19.012 --> 00:46:21.281 align:start position:29% line:-1
１カスケード表示をします

00:46:21.381 --> 00:46:25.219 align:start position:32% line:-2
建物のサイズに合わせ
距離を設定しますが

00:46:25.319 --> 00:46:28.455 align:start position:29% line:-2
構造物の中に入っても
外から入る光はありません

00:46:28.622 --> 00:46:31.925 align:start position:29% line:-2
ハイエンドにはもう１つ
カスケードが加えられます

00:46:32.025 --> 00:46:34.828 align:start position:27% line:-2
人物にクリスプなシャドウと
距離のあるシャドウを―

00:46:34.928 --> 00:46:36.330 align:start position:32% line:-1
加えることができます

00:46:37.331 --> 00:46:39.733 align:start position:29% line:-2
草木も
スケーラビリティの軸です

00:46:39.833 --> 00:46:42.536 align:start position:34% line:-2
ローエンドでは
草木を生成しません

00:46:42.636 --> 00:46:46.673 align:start position:27% line:-2
ミッドレンジでは出力可能な
30％の密度で生成します

00:46:46.773 --> 00:46:51.612 align:start position:29% line:-2
ハイエンドでは100％の
密度で生成します

00:46:54.147 --> 00:46:56.683 align:start position:27% line:-2
スケーラビリティでは
メモリは面白い動きをします

00:46:56.783 --> 00:46:59.253 align:start position:32% line:-2
パフォーマンスと
相関関係がありません

00:46:59.353 --> 00:47:02.156 align:start position:21% line:-2
iPhone 8は
iPhone 7 Plusよりも

00:46:59.353 --> 00:47:02.156 align:start position:21% line:-2
iPhone 8は
iPhone 7 Plusよりも

00:47:02.256 --> 00:47:04.157 align:start position:32% line:-1
メモリが小さいのです

00:47:04.358 --> 00:47:06.193 align:start position:27% line:-2
アカウントの
スケーラビリティの観点では

00:47:06.293 --> 00:47:08.162 align:start position:29% line:-1
メモリの扱いが変わります

00:47:08.262 --> 00:47:11.932 align:start position:36% line:-2
直交座標系として
扱うのです

00:47:12.099 --> 00:47:15.569 align:start position:27% line:-2
メモリの２つのバケットが
ローメモリとハイメモリです

00:47:15.936 --> 00:47:19.206 align:start position:29% line:-2
ローメモリではシャドウや
草木を作れません

00:47:19.306 --> 00:47:21.475 align:start position:32% line:-2
メモリプールの領域も
減らします

00:47:21.575 --> 00:47:25.612 align:start position:25% line:-2
GPUの粒子を１万6000に
制限し

00:47:25.712 --> 00:47:29.583 align:start position:27% line:-2
装飾やテクスチャメモリ用の
プールを減らしました

00:47:31.418 --> 00:47:36.123 align:start position:30% line:-2
端末に合わせ
メモリの最適化もします

00:47:36.223 --> 00:47:38.692 align:start position:30% line:-2
一番重要なのが
レベルストリーミングで

00:47:38.792 --> 00:47:41.895 align:start position:29% line:-2
プレイヤーの周囲以外の
情報をメモリから消します

00:47:42.663 --> 00:47:46.200 align:start position:23% line:-1
ASTCのテクスチャ圧縮を使い

00:47:46.300 --> 00:47:50.671 align:start position:29% line:-2
クオリティよりもサイズを
優先する場合が多いです

00:47:50.771 --> 00:47:54.441 align:start position:32% line:-2
クリエイターに
多くのツールを提供し

00:47:54.908 --> 00:47:58.445 align:start position:32% line:-2
不必要なLODを
使わないようにします

00:47:58.545 --> 00:48:02.683 align:start position:30% line:-2
プラットフォームごとの
音響の変化も減らします

00:47:58.545 --> 00:48:02.683 align:start position:30% line:-2
プラットフォームごとの
音響の変化も減らします

00:48:04.852 --> 00:48:06.920 align:start position:27% line:-2
フレームレートターゲットの
話をします

00:48:07.021 --> 00:48:11.959 align:start position:27% line:-2
iOSで目指す30fpsは
最高レベルの再現性ですが

00:48:12.059 --> 00:48:17.531 align:start position:21% line:-2
それぞれの端末でCPUやGPUを
限界までは使えません

00:48:17.998 --> 00:48:20.300 align:start position:25% line:-1
OSがダウンクロックを起こし

00:48:20.400 --> 00:48:22.803 align:start position:36% line:-2
フレームレートが
出なくなります

00:48:23.504 --> 00:48:25.239 align:start position:29% line:-1
バッテリー消費も問題です

00:48:25.339 --> 00:48:28.942 align:start position:27% line:-2
利用者が短時間にいくつもの
ゲームをプレイする場合

00:48:29.309 --> 00:48:33.347 align:start position:32% line:-2
端末への負担を考慮
しなければなりません

00:48:34.448 --> 00:48:39.119 align:start position:30% line:-2
その結果 60fpsを
目指すことにしました

00:48:39.219 --> 00:48:40.954 align:start position:21% line:-1
しかしVSYNCは30fpsです

00:48:41.054 --> 00:48:43.957 align:start position:32% line:-2
「フォートナイト」の
マップ内にいる間

00:48:44.057 --> 00:48:46.994 align:start position:21% line:-2
iPhoneがリソースを使う量は
半分に抑えられます

00:48:47.094 --> 00:48:50.297 align:start position:32% line:-2
バッテリーへの負担を
減らせます

00:48:52.666 --> 00:48:57.204 align:start position:29% line:-2
毎日パフォーマンスの
動きを見て軌道修正します

00:48:57.304 --> 00:49:00.774 align:start position:34% line:-2
追跡用のシステムで
動きが見られます

00:48:57.304 --> 00:49:00.774 align:start position:34% line:-2
追跡用のシステムで
動きが見られます

00:49:00.874 --> 00:49:05.879 align:start position:30% line:-2
マップの中でカギとなる
場所の動きを見ます

00:49:05.979 --> 00:49:10.417 align:start position:27% line:-2
ティルテッド･タワーなどの
特定のポイントです

00:49:10.517 --> 00:49:13.120 align:start position:32% line:-2
「バトルロイヤル」で
おなじみですね

00:49:13.220 --> 00:49:14.688 align:start position:30% line:-1
バジェットを超えると―

00:49:14.788 --> 00:49:18.759 align:start position:29% line:-2
パフォーマンスを見て
最適化する場所を探します

00:49:18.859 --> 00:49:21.395 align:start position:32% line:-2
１日に100人の
プレイヤーに試遊させ

00:49:21.495 --> 00:49:24.998 align:start position:27% line:-2
プレイ中のパフォーマンスの
変化も調べます

00:49:25.098 --> 00:49:28.802 align:start position:32% line:-2
対戦時の動きも
しっかりと追跡します

00:49:28.902 --> 00:49:33.173 align:start position:30% line:-2
後から記録を見て
パフォーマンスを確認し

00:49:33.507 --> 00:49:36.110 align:start position:29% line:-1
障害などがないか探します

00:49:36.210 --> 00:49:40.614 align:start position:34% line:-2
何か見つかれば
端末から機器を外し

00:49:40.714 --> 00:49:44.485 align:start position:27% line:-1
最適化できる箇所を探します

00:49:44.952 --> 00:49:46.020 align:start position:27% line:-1
Unrealの特徴である―

00:49:46.120 --> 00:49:48.555 align:start position:29% line:-2
リプレイ機能のサポートも
行っています

00:49:48.755 --> 00:49:51.759 align:start position:27% line:-2
クライアントの視点に合わせ
リプレイする機能です

00:49:51.859 --> 00:49:54.828 align:start position:27% line:-2
何度も繰り返しプレイを行い
分析をします

00:49:54.928 --> 00:50:00.534 align:start position:27% line:-2
更に 既に行われた最適化の
影響も調べます

00:49:54.928 --> 00:50:00.534 align:start position:27% line:-2
更に 既に行われた最適化の
影響も調べます

00:50:02.636 --> 00:50:05.572 align:start position:29% line:-2
Metalの特性について
お話しします

00:50:06.140 --> 00:50:10.210 align:start position:29% line:-2
ほとんどの端末には
２つのコアが入っています

00:50:10.544 --> 00:50:14.014 align:start position:30% line:-1
そのコアを活用するのが

00:50:14.114 --> 00:50:16.350 align:start position:29% line:-2
ゲームスレッドと
レンダリングスレッドです

00:50:16.450 --> 00:50:17.451 align:start position:32% line:-1
ゲームスレッドでは―

00:50:17.551 --> 00:50:21.054 align:start position:29% line:-2
通信 シミュレーションや
物理的な動きを扱います

00:50:21.221 --> 00:50:24.057 align:start position:30% line:-2
レンダリングスレッドで
扱うのは

00:50:24.157 --> 00:50:26.427 align:start position:29% line:-2
場面の計算に関わる
カリングやMetalなど

00:50:26.527 --> 00:50:31.598 align:start position:27% line:-2
Asyncスレッドでは主に
ストリーミングを扱います

00:50:31.698 --> 00:50:34.701 align:start position:27% line:-2
テクスチャストリーミングや
レベルストリーミングです

00:50:35.903 --> 00:50:37.971 align:start position:32% line:-2
最新機種は
２つの高性能コアと―

00:50:38.072 --> 00:50:39.640 align:start position:34% line:-2
４つの高効率コアを
搭載しています

00:50:39.740 --> 00:50:41.975 align:start position:30% line:-2
３つのタスクスレッドを
追加し

00:50:42.075 --> 00:50:44.511 align:start position:34% line:-2
並列アルゴリズムも
可能にしました

00:50:44.611 --> 00:50:49.083 align:start position:27% line:-2
アニメーションを
マルチフレームで表示します

00:50:49.183 --> 00:50:52.119 align:start position:30% line:-2
CPUを使った粒子法や
物理演算も行います

00:50:52.920 --> 00:50:55.355 align:start position:27% line:-2
シーンのカリングやその他の
タスクもです

00:50:57.558 --> 00:50:59.059 align:start position:27% line:-1
ドローコールの話に戻ります

00:50:59.159 --> 00:51:02.029 align:start position:30% line:-2
ドローコールは動作の
障害になる主な要因です

00:50:59.159 --> 00:51:02.029 align:start position:30% line:-2
ドローコールは動作の
障害になる主な要因です

00:51:02.129 --> 00:51:04.798 align:start position:32% line:-2
これに対抗できるのが
Metalなのです

00:51:05.399 --> 00:51:08.936 align:start position:23% line:-2
MetalはOpenGLよりも
３倍ほど早く―

00:51:09.036 --> 00:51:11.471 align:start position:29% line:-1
パフォーマンスを行います

00:51:12.105 --> 00:51:15.976 align:start position:27% line:-2
無理にドローコールを減らす
必要がなくなりました

00:51:16.076 --> 00:51:21.281 align:start position:30% line:-2
装飾オブジェクトに対し
距離のカリングをしたり

00:51:21.515 --> 00:51:25.552 align:start position:27% line:-2
詳細システムの階層レベルを
活用しなくていいのです

00:51:27.888 --> 00:51:31.959 align:start position:27% line:-2
これは時間をかけて追跡した
POIの１つです

00:51:32.059 --> 00:51:33.994 align:start position:30% line:-2
ゲームをご存知の方には
お分かりの通り

00:51:34.094 --> 00:51:36.230 align:start position:27% line:-2
ティルテッド･タワーからの
眺めです

00:51:36.563 --> 00:51:41.168 align:start position:29% line:-2
マップの中でもドロー
コールが集中する場所です

00:51:41.268 --> 00:51:44.972 align:start position:23% line:-2
ドローコールの数は1300にも
及びます

00:51:45.105 --> 00:51:50.978 align:start position:27% line:-2
メインパスのみでシャドウや
UIは含まれていません

00:51:51.078 --> 00:51:53.313 align:start position:21% line:-2
Metalであれば
iPhone 8 Plusでも―

00:51:53.414 --> 00:51:56.683 align:start position:32% line:-2
５ミリセカンド未満で
表示できます

00:51:58.652 --> 00:52:01.722 align:start position:25% line:-2
HLODはUnrealの持つ
機能です

00:51:58.652 --> 00:52:01.722 align:start position:25% line:-2
HLODはUnrealの持つ
機能です

00:52:01.822 --> 00:52:04.291 align:start position:27% line:-1
複数のドローコールをまとめ

00:52:04.391 --> 00:52:07.194 align:start position:30% line:-2
簡略化されたメッシュを
生成します

00:52:07.294 --> 00:52:11.865 align:start position:29% line:-2
同時にマテリアルを生成し
描写をレンダリングします

00:52:11.999 --> 00:52:15.269 align:start position:29% line:-2
１つのドローコールで
このエリアをまかないます

00:52:15.369 --> 00:52:17.838 align:start position:27% line:-1
この機能はPOIにも使われ

00:52:17.938 --> 00:52:21.909 align:start position:30% line:-2
遠くの描写を簡略化し
生成することができます

00:52:22.009 --> 00:52:24.912 align:start position:29% line:-2
スカイダイビングの際には
マップ全体が見えます

00:52:25.012 --> 00:52:29.950 align:start position:30% line:-2
マップ上の崖の上からや
自分の建てた塔の上から

00:52:30.050 --> 00:52:33.954 align:start position:34% line:-2
２キロメートル先が
見えるのです

00:52:36.123 --> 00:52:39.093 align:start position:34% line:-2
Metalについて
更に説明するため

00:52:39.193 --> 00:52:42.429 align:start position:29% line:-2
パイプラインステート
オブジェクトの話をします

00:52:42.529 --> 00:52:45.265 align:start position:25% line:-2
「フォートナイト」にPSOを
実装するには―

00:52:45.365 --> 00:52:46.467 align:start position:34% line:-1
時間がかかりました

00:52:46.667 --> 00:52:52.406 align:start position:27% line:-2
ゲーム中に作られるPSOの
数は少なくしたいところです

00:52:52.506 --> 00:52:57.010 align:start position:29% line:-2
多すぎればゲームの進行に
支障が出ることになります

00:52:57.111 --> 00:52:59.646 align:start position:36% line:-1
解決法があります

00:52:59.747 --> 00:53:02.883 align:start position:34% line:-2
オフラインで関数を
コンパイルし

00:52:59.747 --> 00:53:02.883 align:start position:34% line:-2
オフラインで関数を
コンパイルし

00:53:02.983 --> 00:53:05.686 align:start position:29% line:-2
すべての関数を１つの
ライブラリに収めるのです

00:53:05.786 --> 00:53:09.490 align:start position:25% line:-2
ロード時間中にすべての
PSOを作成したいところです

00:53:09.990 --> 00:53:11.558 align:start position:29% line:-2
できない場合はどうすれば
いいのでしょう？

00:53:11.658 --> 00:53:14.027 align:start position:29% line:-1
置換行列などは行いません

00:53:14.127 --> 00:53:17.397 align:start position:36% line:-2
現実的な方法は
たくさんあります

00:53:17.931 --> 00:53:22.603 align:start position:30% line:-2
アーティストが作成した
数千のシェーダ

00:53:22.703 --> 00:53:25.772 align:start position:30% line:-2
シャドウのカスケードの
数に基づく―

00:53:25.873 --> 00:53:28.408 align:start position:27% line:-1
複数のライティングシナリオ

00:53:28.509 --> 00:53:31.812 align:start position:23% line:-2
違うレンダーターゲット
フォーマットやMSAAなどです

00:53:32.646 --> 00:53:35.549 align:start position:32% line:-2
配列を最小化するのも
効果があります

00:53:35.649 --> 00:53:40.354 align:start position:30% line:-2
静的配列を作成するより
動的配列が効果的です

00:53:41.321 --> 00:53:42.656 align:start position:30% line:-2
しかし うまくいかない
こともあります

00:53:42.856 --> 00:53:46.360 align:start position:34% line:-2
必要と思われる
サブセットの中から

00:53:46.460 --> 00:53:49.329 align:start position:30% line:-2
共通の変数をロード中に
特定することにしました

00:53:49.429 --> 00:53:51.098 align:start position:32% line:-1
すべてではありません

00:53:51.198 --> 00:53:56.336 align:start position:29% line:-2
そのため カメラを飛ばす
自動化パスを作成しました

00:53:56.437 --> 00:54:00.073 align:start position:27% line:-2
環境を生成するために必要な
PSOを記録するためです

00:53:56.437 --> 00:54:00.073 align:start position:27% line:-2
環境を生成するために必要な
PSOを記録するためです

00:54:00.174 --> 00:54:04.111 align:start position:25% line:-2
毎日のプレイテストで
PSOのデータが集まりました

00:54:04.211 --> 00:54:07.781 align:start position:27% line:-2
自動化パスでは集められない
データでした

00:54:07.881 --> 00:54:11.852 align:start position:29% line:-2
自動化パスでは装飾などの
データも集められました

00:54:12.786 --> 00:54:15.389 align:start position:29% line:-1
武器の使用効果などもです

00:54:16.423 --> 00:54:20.627 align:start position:27% line:-2
自動化パスとプレイテストの
データは集計され

00:54:20.728 --> 00:54:24.765 align:start position:29% line:-2
それを参考にロード時間を
ゲームに組み込みました

00:54:24.865 --> 00:54:28.135 align:start position:29% line:-2
その結果 ランタイム時に
作成したPSOの数字は

00:54:28.235 --> 00:54:31.305 align:start position:32% line:-2
どんなプレイの時でも
平均して１桁以内です

00:54:31.405 --> 00:54:35.175 align:start position:30% line:-2
PSOで作成しても
プレイに障害は出ません

00:54:37.511 --> 00:54:40.013 align:start position:34% line:-2
リソース割り当ての
話をします

00:54:40.280 --> 00:54:44.952 align:start position:27% line:-2
通常 リソースを作成したり
消去したりすると―

00:54:45.185 --> 00:54:47.688 align:start position:34% line:-1
コストがかかります

00:54:47.788 --> 00:54:49.923 align:start position:29% line:-2
そこで考えるのが
フレームごとに作成した―

00:54:50.023 --> 00:54:53.227 align:start position:23% line:-2
MallocとFreeの関数を
減らすことです

00:54:53.327 --> 00:54:56.697 align:start position:27% line:-2
何度もリソースを作成したり
手放すのは面倒です

00:54:56.797 --> 00:54:59.833 align:start position:30% line:-2
コンテンツに
動的にアクセスする時に

00:54:59.933 --> 00:55:03.570 align:start position:29% line:-2
移動できるオブジェクトが
多くある場合もあります

00:54:59.933 --> 00:55:03.570 align:start position:29% line:-2
移動できるオブジェクトが
多くある場合もあります

00:55:03.670 --> 00:55:05.339 align:start position:29% line:-1
その時は仕方がありません

00:55:05.506 --> 00:55:11.078 align:start position:32% line:-2
そこでバッファの
細分割り当てをします

00:55:11.178 --> 00:55:13.146 align:start position:30% line:-1
割り当て戦略の変更です

00:55:13.247 --> 00:55:16.183 align:start position:27% line:-2
前もって バッファの領域を
多く割り当てておき

00:55:16.283 --> 00:55:18.919 align:start position:27% line:-2
それを細分化してエンジンに
割り当てます

00:55:19.019 --> 00:55:22.256 align:start position:25% line:-2
毎回 Metalにバッファの
リクエストをしないためです

00:55:22.923 --> 00:55:24.758 align:start position:41% line:-1
効率的です

00:55:26.160 --> 00:55:29.129 align:start position:30% line:-2
プログラマブル
ブレンディングを利用し

00:55:29.229 --> 00:55:34.167 align:start position:25% line:-2
リゾルブ リストア コストを
減らすことができます

00:55:34.435 --> 00:55:39.973 align:start position:27% line:-2
特に深度にアクセスする際に
有用です

00:55:40.073 --> 00:55:43.610 align:start position:30% line:-2
ソフトパーティクルの
ブレンディングなどです

00:55:43.844 --> 00:55:46.080 align:start position:29% line:-2
前方パスで
アルファチャンネルに対し

00:55:46.180 --> 00:55:47.781 align:start position:29% line:-1
リニア深度を書き込みます

00:55:47.881 --> 00:55:50.951 align:start position:29% line:-2
転写と透過パスでするのが
アルファチャンネルを

00:55:51.051 --> 00:55:54.087 align:start position:27% line:-2
再び読み込むプログラマブル
ブレンディングです

00:55:54.188 --> 00:55:57.157 align:start position:32% line:-2
メインメモリに対する
深度バッファを

00:55:57.257 --> 00:56:00.460 align:start position:30% line:-2
分割したことがなくても
深度を利用できます

00:55:57.257 --> 00:56:00.460 align:start position:30% line:-2
分割したことがなくても
深度を利用できます

00:56:01.795 --> 00:56:04.598 align:start position:25% line:-2
MSAAのクオリティ向上にも
利用できます

00:56:04.698 --> 00:56:09.803 align:start position:27% line:-2
HDRレンダリングを行い
MSAAの処理もすることで

00:56:09.903 --> 00:56:12.306 align:start position:30% line:-1
線がギザギザになります

00:56:12.406 --> 00:56:16.910 align:start position:32% line:-2
明るい空や暗い前景に
影響します

00:56:17.010 --> 00:56:21.615 align:start position:29% line:-2
ボックスフィルター処理を
することで

00:56:21.715 --> 00:56:26.820 align:start position:27% line:-2
明るかったり暗かったりする
サブサンプルに対し

00:56:26.920 --> 00:56:31.291 align:start position:32% line:-2
白に近い非常に明るい
ピクセルを返します

00:56:31.391 --> 00:56:34.094 align:start position:29% line:-1
大きく変わってしまいます

00:56:34.695 --> 00:56:40.500 align:start position:25% line:-2
そこでMSAAサンプルに対し
プレトーンマップをします

00:56:41.001 --> 00:56:43.237 align:start position:23% line:-1
それから通常のMSAA処理をし

00:56:43.337 --> 00:56:47.007 align:start position:29% line:-2
ポストプロセス処理をして
プレトーンマップをします

00:56:47.374 --> 00:56:50.477 align:start position:29% line:-2
ここでプログラマブル
ブレンディングを使います

00:56:50.677 --> 00:56:55.048 align:start position:30% line:-2
記録したMSAAカラー
バッファも読み込めます

00:56:55.249 --> 00:56:57.117 align:start position:32% line:-1
負担に応じて選べます

00:56:58.886 --> 00:57:04.324 align:start position:23% line:-2
今後 Metalで行いたいのが
並列レンダリングです

00:56:58.886 --> 00:57:04.324 align:start position:23% line:-2
今後 Metalで行いたいのが
並列レンダリングです

00:57:04.425 --> 00:57:07.194 align:start position:30% line:-1
macOSでは並列でも

00:57:07.294 --> 00:57:09.530 align:start position:34% line:-2
コマンドバッファを
サポートしています

00:57:09.630 --> 00:57:15.002 align:start position:27% line:-2
並列コマンドのエンコーダを
iOSで扱うのが目標です

00:57:15.102 --> 00:57:17.938 align:start position:29% line:-2
メインフォワードパスで
描画されることが多いです

00:57:18.038 --> 00:57:21.842 align:start position:29% line:-1
並列化することは重要です

00:57:22.075 --> 00:57:27.247 align:start position:29% line:-2
並列レンダリングを
ソートできてもいいですね

00:57:27.881 --> 00:57:30.651 align:start position:30% line:-1
強くて速いコアに対し―

00:57:30.751 --> 00:57:35.722 align:start position:29% line:-2
最新機種の高効率なコアで
どんな命令を出せるか

00:57:35.823 --> 00:57:39.193 align:start position:32% line:-2
バッテリー使用量にも
違いがありそうです

00:57:40.861 --> 00:57:42.129 align:start position:30% line:-1
Metalのヒープです

00:57:42.229 --> 00:57:45.032 align:start position:29% line:-2
バッファの細分割り当ては
Metalが行うでしょう

00:57:45.499 --> 00:57:47.167 align:start position:36% line:-1
理由はコードと―

00:57:47.267 --> 00:57:50.137 align:start position:27% line:-2
Metalはテクスチャにも
使えるからです

00:57:50.237 --> 00:57:54.174 align:start position:27% line:-2
テクスチャストリーミングが
原因で

00:57:54.274 --> 00:57:57.911 align:start position:29% line:-2
プレイ中に
問題が起こるのを避けます

00:57:58.045 --> 00:58:01.782 align:start position:30% line:-2
ヒープはゲームの障害を
なくしてくれます

00:57:58.045 --> 00:58:01.782 align:start position:30% line:-2
ヒープはゲームの障害を
なくしてくれます

00:58:01.882 --> 00:58:06.987 align:start position:38% line:-2
我々の会社でも
実現したいのは

00:58:07.087 --> 00:58:10.724 align:start position:27% line:-2
パスの間に適切な
フェンスを設定することです

00:58:10.824 --> 00:58:13.627 align:start position:29% line:-2
知らなければならないのは
リソースが頂点シェーダや

00:58:13.727 --> 00:58:18.065 align:start position:29% line:-2
ピクセルシェーダによって
読み書きされるかどうか

00:58:18.165 --> 00:58:22.736 align:start position:30% line:-2
そのためにはいくつもの
修正が必要です

00:58:23.837 --> 00:58:27.241 align:start position:25% line:-2
iOSの高品質グラフィックも
追求します

00:58:27.341 --> 00:58:30.510 align:start position:29% line:-2
去年 コンピュータ向けの
レンダラーが

00:58:30.611 --> 00:58:34.781 align:start position:29% line:-2
ハイエンドのiOS端末で
できることを披露しました

00:58:34.882 --> 00:58:37.818 align:start position:38% line:-1
方向性は変えず

00:58:37.918 --> 00:58:42.256 align:start position:29% line:-2
コンピュータ向け機能を
iOSで実現していきます

00:58:45.592 --> 00:58:47.628 align:start position:36% line:-2
コンピュータ向け
レンダラーを

00:58:47.728 --> 00:58:51.832 align:start position:27% line:-2
iOSレンダラーと統一する
ことを目指します

00:58:53.634 --> 00:58:56.170 align:start position:32% line:-2
ここからは
マイケルに代わります

00:58:56.270 --> 00:58:59.940 align:start position:43% line:-1
(拍手)

00:59:00.073 --> 00:59:02.643 align:start position:30% line:-2
Metalは
ローオーバーヘッドです

00:59:02.876 --> 00:59:04.378 align:start position:30% line:-2
しかし オブジェクトを
効率的に生成するには

00:59:04.478 --> 00:59:06.046 align:start position:29% line:-1
マルチスレッドが必要です

00:59:06.146 --> 00:59:10.718 align:start position:18% line:-2
MetalはGPUとCPUを最大限に
活用するため生まれました

00:59:11.652 --> 00:59:14.555 align:start position:29% line:-2
しかし
高機能のレンダリングには

00:59:14.655 --> 00:59:16.423 align:start position:38% line:-2
しっかりとした
制御が必要です

00:59:16.757 --> 00:59:21.595 align:start position:21% line:-2
Metaはメモリの扱いやGPUの
並列処理を制御します

00:59:22.529 --> 00:59:26.000 align:start position:29% line:-2
新しい機能である
間接コマンドバッファでは

00:59:26.100 --> 00:59:28.602 align:start position:29% line:-2
GPUで全てのコマンドを
作成できます

00:59:28.702 --> 00:59:30.671 align:start position:30% line:-2
CPUでは他のタスクを
実行します

00:59:31.205 --> 00:59:36.510 align:start position:27% line:-2
GPU主導のパイプラインを
構成できるのです

00:59:37.511 --> 00:59:41.949 align:start position:25% line:-2
MetalはA11 GPUの
先進アーキテクチャです

00:59:42.049 --> 00:59:44.151 align:start position:27% line:-1
レンダリング技術を最適化し

00:59:44.251 --> 00:59:47.154 align:start position:27% line:-2
最大のパフォーマンスと
長いプレイ時間を実現します

00:59:49.690 --> 00:59:54.528 align:start position:27% line:-2
詳細については
ホームページをご覧ください

00:59:55.095 --> 00:59:55.796 align:start position:41% line:-1
ありがとう

00:59:56.497 --> 00:59:58.699 align:start position:43% line:-1
(拍手)
