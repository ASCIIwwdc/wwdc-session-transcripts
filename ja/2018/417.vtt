WEBVTT

00:00:07.140 --> 00:00:16.650 align:start position:43% line:-1
(音楽)

00:00:24.591 --> 00:00:31.865 align:start position:43% line:-1
(拍手)

00:00:32.366 --> 00:00:35.469 align:start position:30% line:-2
こんにちは
当セッションへようこそ

00:00:36.069 --> 00:00:37.871 align:start position:38% line:-1
ブライアンです

00:00:38.272 --> 00:00:41.008 align:start position:29% line:-1
同僚のスチュアートと私が

00:00:41.108 --> 00:00:44.811 align:start position:32% line:-2
テストのテクニックを
ご紹介します

00:00:47.848 --> 00:00:52.452 align:start position:21% line:-2
WWDC開催にあたり 会場周辺の
見どころを検索できる―

00:00:52.553 --> 00:00:56.757 align:start position:27% line:-2
アプリケーションがあったら
便利だと我々は考えました

00:00:57.724 --> 00:01:03.730 align:start position:30% line:-2
このアプリケーションで
周辺のスポットを探すと

00:00:57.724 --> 00:01:03.730 align:start position:30% line:-2
このアプリケーションで
周辺のスポットを探すと

00:01:03.830 --> 00:01:06.033 align:start position:29% line:-1
現在地からの距離が出ます

00:01:07.568 --> 00:01:12.005 align:start position:29% line:-2
もちろん
テストスイートが必要です

00:01:12.339 --> 00:01:17.311 align:start position:27% line:-2
開発中のどの時点であっても
コードが正しく動くと―

00:01:17.411 --> 00:01:19.179 align:start position:36% line:-1
確認するためです

00:01:21.849 --> 00:01:26.787 align:start position:32% line:-2
テストを記述する際に
役立つテクニックを

00:01:26.887 --> 00:01:28.789 align:start position:34% line:-1
４つ ご紹介します

00:01:30.224 --> 00:01:33.760 align:start position:27% line:-1
ネットワークコードのテスト

00:01:34.862 --> 00:01:39.032 align:start position:29% line:-2
Foundation
通知オブジェクトのテスト

00:01:40.334 --> 00:01:44.872 align:start position:30% line:-2
プロトコルで
モックを作成するテスト

00:01:45.606 --> 00:01:49.009 align:start position:30% line:-2
テストスピードを
高速で維持する方法です

00:01:52.379 --> 00:01:54.481 align:start position:30% line:-1
最初はネットワークです

00:01:55.782 --> 00:01:57.885 align:start position:29% line:-1
動的コンテンツ更新のため

00:01:57.985 --> 00:02:01.788 align:start position:29% line:-2
リモートウェブサーバから
データを読み込ませます

00:01:57.985 --> 00:02:01.788 align:start position:29% line:-2
リモートウェブサーバから
データを読み込ませます

00:02:02.723 --> 00:02:06.894 align:start position:27% line:-2
そこでネットワークコードの
テストのコツです

00:02:08.729 --> 00:02:11.899 align:start position:27% line:-1
まず昨年を振り返りましょう

00:02:12.299 --> 00:02:16.770 align:start position:0% line:-2
WWDC 2017の
“Engineering for Testability”

00:02:17.004 --> 00:02:21.708 align:start position:27% line:-2
徹底度と理解性 実行速度の
バランスを保った―

00:02:21.875 --> 00:02:26.547 align:start position:29% line:-2
テストスイート作成を
ピラミッドで説明しました

00:02:28.615 --> 00:02:34.454 align:start position:29% line:-2
理想的なテストスイートは
ユニットテストを中心とし

00:02:34.555 --> 00:02:38.258 align:start position:32% line:-2
各クラスやメソッドを
対象とします

00:02:39.626 --> 00:02:42.529 align:start position:29% line:-1
その特徴は 読みやすく―

00:02:42.896 --> 00:02:46.366 align:start position:29% line:-2
不合格時に
はっきり表示することです

00:02:46.967 --> 00:02:48.669 align:start position:32% line:-1
また実行速度が速く―

00:02:48.769 --> 00:02:52.306 align:start position:30% line:-2
毎分 何千ものテストを
実行します

00:02:54.675 --> 00:02:59.546 align:start position:25% line:-2
それを補完するのが
インテグレーションテストです

00:03:00.113 --> 00:03:04.318 align:start position:29% line:-2
個別サブシステムや
クラスクラスタを対象とし

00:03:04.852 --> 00:03:09.523 align:start position:32% line:-2
それらの連携を
数秒以内に確認します

00:03:11.758 --> 00:03:15.362 align:start position:27% line:-2
最上部はエンドツーエンドの
システムテストです

00:03:15.462 --> 00:03:18.198 align:start position:30% line:-2
多くは
UIテストの形を取り―

00:03:18.365 --> 00:03:23.537 align:start position:29% line:-2
エンドユーザと同じように
デバイス上で動かします

00:03:24.438 --> 00:03:26.940 align:start position:34% line:-1
各部の接続状況と―

00:03:27.040 --> 00:03:31.912 align:start position:30% line:-2
OSや外部リソースとの
相互作用を確認します

00:03:33.680 --> 00:03:35.916 align:start position:34% line:-2
このモデルの
テストスイートで―

00:03:36.016 --> 00:03:39.920 align:start position:27% line:-2
コードベースが全体で
いかに機能するか分かります

00:03:43.724 --> 00:03:48.829 align:start position:23% line:-2
ネットワークスタックのテストに
このモデルを使い

00:03:48.929 --> 00:03:51.965 align:start position:32% line:-2
テストスイート作成の
指針としました

00:03:53.267 --> 00:03:57.671 align:start position:23% line:-2
これがネットワークリクエストと
データフィード時の―

00:03:57.771 --> 00:03:59.940 align:start position:25% line:-1
上位レベルのデータフローです

00:04:02.276 --> 00:04:04.278 align:start position:30% line:-1
初期のプロトタイプでは

00:04:04.478 --> 00:04:08.815 align:start position:21% line:-2
View Controllerの
１メソッドで行っていました

00:04:09.049 --> 00:04:10.584 align:start position:38% line:-1
このようにです

00:04:12.586 --> 00:04:15.656 align:start position:32% line:-2
ユーザの位置で
パラメータを取ります

00:04:17.357 --> 00:04:19.091 align:start position:27% line:-1
位置をクエリパラメータとし

00:04:19.192 --> 00:04:23.630 align:start position:23% line:-2
サービスAPIエンドポイントの
URLを生成

00:04:26.066 --> 00:04:29.169 align:start position:25% line:-2
そしてFoundationの
URLSessionを使い

00:04:29.269 --> 00:04:32.873 align:start position:23% line:-2
URLのGETリクエストのため
データタスクを作成

00:04:34.875 --> 00:04:38.278 align:start position:34% line:-2
サーバが応答して
データをアンラップ

00:04:39.413 --> 00:04:42.616 align:start position:9% line:-2
FoundationのJSONDecoderで
デコードし

00:04:42.883 --> 00:04:45.419 align:start position:14% line:-1
PointOfInterest値の配列へ

00:04:45.519 --> 00:04:50.057 align:start position:27% line:-2
これは他で宣言した構造体で
プロトコルに準拠します

00:04:51.792 --> 00:04:57.564 align:start position:29% line:-2
それをプロパティに保存し
テーブルビューで表示

00:05:00.267 --> 00:05:05.572 align:start position:30% line:-2
たった15行のコードで
以上のことができました

00:05:05.739 --> 00:05:08.408 align:start position:20% line:-2
SwiftとFoundationの
おかげです

00:05:09.443 --> 00:05:12.079 align:start position:29% line:-2
しかし
１つのメソッドにすると―

00:05:12.179 --> 00:05:16.984 align:start position:29% line:-2
コードのテストしやすさと
保守性が問題になります

00:05:20.888 --> 00:05:23.390 align:start position:27% line:-1
ピラミッドの最下部を見ると

00:05:23.490 --> 00:05:28.996 align:start position:27% line:-2
各フローのユニットテストを
記述することが重要です

00:05:30.831 --> 00:05:35.269 align:start position:30% line:-2
まずリクエスト準備と
応答の解析についてです

00:05:38.739 --> 00:05:41.375 align:start position:30% line:-2
テストしやすいコードに
するために―

00:05:41.842 --> 00:05:44.478 align:start position:20% line:-2
View Controllerから
取り出して

00:05:45.512 --> 00:05:49.583 align:start position:5% line:-2
PointsOfInterestRequest型に
２つのメソッドを作成

00:05:50.517 --> 00:05:56.056 align:start position:29% line:-2
２つの分離メソッドが
それぞれ 値を入力として

00:05:56.223 --> 00:06:00.394 align:start position:30% line:-2
副作用なしで
出力値に変換するのです

00:05:56.223 --> 00:06:00.394 align:start position:30% line:-2
副作用なしで
出力値に変換するのです

00:06:03.330 --> 00:06:08.135 align:start position:29% line:-2
コードのユニットテストを
記述しやすくなります

00:06:09.469 --> 00:06:11.772 align:start position:21% line:-2
makeRequestメソッドの
テストでは

00:06:11.972 --> 00:06:16.009 align:start position:36% line:-2
サンプルを作って
メソッドに渡し

00:06:16.176 --> 00:06:19.213 align:start position:34% line:-2
戻り値について
アサーションを作成

00:06:22.082 --> 00:06:26.220 align:start position:30% line:-2
応答の解析のテストでも
モックJSONを渡し―

00:06:26.320 --> 00:06:28.922 align:start position:34% line:-2
解析結果について
アサーションを作成

00:06:31.458 --> 00:06:34.261 align:start position:30% line:-2
もう１つ
注目すべき点があります

00:06:34.361 --> 00:06:39.299 align:start position:23% line:-2
throwsのテストメソッドに
XCTestサポートを活用し

00:06:39.399 --> 00:06:45.105 align:start position:21% line:-2
do-catchブロックは不要で
tryを使えるのです

00:06:49.209 --> 00:06:52.412 align:start position:18% line:-1
次はURLSessionとの関係です

00:06:54.548 --> 00:06:57.184 align:start position:16% line:-2
再びView Controllerから
取り出し

00:06:57.951 --> 00:07:04.591 align:start position:18% line:-2
シグネチャが合うメソッドと
APIRequestプロトコルを作成

00:06:57.951 --> 00:07:04.591 align:start position:18% line:-2
シグネチャが合うメソッドと
APIRequestプロトコルを作成

00:07:05.459 --> 00:07:08.629 align:start position:14% line:-2
使用している
APIRequestLoaderクラスは

00:07:09.530 --> 00:07:14.268 align:start position:18% line:-2
リクエスト型とURLSessionで
初期化されています

00:07:17.437 --> 00:07:20.507 align:start position:16% line:-2
ここの
loadAPIRequestメソッドは

00:07:20.607 --> 00:07:24.878 align:start position:29% line:-2
APIRequest値で
URLリクエストを作成

00:07:25.345 --> 00:07:27.614 align:start position:21% line:-1
URLSessionにフィードし

00:07:28.382 --> 00:07:31.451 align:start position:21% line:-1
APIRequestで応答を解析

00:07:34.822 --> 00:07:37.791 align:start position:30% line:-2
ユニットテストの記述を
続けられますが―

00:07:37.891 --> 00:07:40.394 align:start position:27% line:-1
ピラミッドの上部へ移ります

00:07:40.494 --> 00:07:45.065 align:start position:25% line:-2
データフローをカバーする
インテグレーションテストです

00:07:46.934 --> 00:07:51.839 align:start position:29% line:-2
テストスイートの
この層でテストしたいのは

00:07:51.939 --> 00:07:55.609 align:start position:21% line:-1
URLSessionとの連携です

00:07:56.977 --> 00:07:59.746 align:start position:25% line:-2
Foundationの
URLローディングシステムが

00:07:59.847 --> 00:08:02.015 align:start position:30% line:-1
フックを提供しています

00:07:59.847 --> 00:08:02.015 align:start position:30% line:-1
フックを提供しています

00:08:04.151 --> 00:08:09.456 align:start position:25% line:-2
ネットワークリクエストに使う
上位レベルのAPIを提供し

00:08:10.424 --> 00:08:14.828 align:start position:7% line:-2
インフライト要求を代表する
URLSessionDataTaskを生成します

00:08:15.796 --> 00:08:21.034 align:start position:21% line:-2
背後には下位レベルAPIの
URLProtocolがあります

00:08:21.301 --> 00:08:24.638 align:start position:25% line:-1
ネットワーク接続をオープンし

00:08:24.738 --> 00:08:28.008 align:start position:29% line:-2
リクエストを記述し
応答をリードバックします

00:08:29.743 --> 00:08:32.412 align:start position:29% line:-2
URLProtocolは
サブクラス化され

00:08:32.513 --> 00:08:36.250 align:start position:25% line:-2
URLローディングシステムの
拡張性を高めます

00:08:39.153 --> 00:08:45.192 align:start position:14% line:-2
FoundationはHTTPSのような
ビルトインプロトコルを提供

00:08:45.592 --> 00:08:49.630 align:start position:25% line:-2
テストではモックプロトコルで
オーバーライドできます

00:08:49.863 --> 00:08:53.300 align:start position:32% line:-2
リクエストについての
アサーションを作成し

00:08:53.967 --> 00:08:55.936 align:start position:32% line:-1
モック応答を返せます

00:08:59.740 --> 00:09:02.543 align:start position:18% line:-1
URLProtocolはプログレスを

00:08:59.740 --> 00:09:02.543 align:start position:18% line:-1
URLProtocolはプログレスを

00:09:02.643 --> 00:09:05.579 align:start position:14% line:-2
URLProtocolClientを通じ
システムに伝達

00:09:07.948 --> 00:09:10.083 align:start position:34% line:-1
このように使えます

00:09:10.951 --> 00:09:14.221 align:start position:18% line:-2
テストバンドルに
MockURLProtocolを作成

00:09:14.755 --> 00:09:17.357 align:start position:27% line:-2
canInitリクエストを
オーバーライドし

00:09:17.457 --> 00:09:21.562 align:start position:32% line:-2
あらゆるリクエストに
興味があると示します

00:09:23.730 --> 00:09:26.366 align:start position:20% line:-2
canonicalRequestを
実装しますが

00:09:26.466 --> 00:09:30.337 align:start position:25% line:-2
startLoadingと
stopLoadingも実装

00:09:34.741 --> 00:09:37.911 align:start position:25% line:-2
このURLProtocolに
フックするため―

00:09:38.011 --> 00:09:42.282 align:start position:23% line:-2
requestHandlerを
テストに提供します

00:09:44.852 --> 00:09:47.054 align:start position:18% line:-1
URLSessionタスクが始まると

00:09:47.154 --> 00:09:50.424 align:start position:20% line:-2
URLProtocolサブクラスを
インスタンス化

00:09:50.524 --> 00:09:55.729 align:start position:9% line:-2
URLRequest値とURLProtocol
クライアントインスタンスを提供

00:09:57.197 --> 00:09:59.533 align:start position:20% line:-2
そして
startLoadingを呼び出し

00:09:59.633 --> 00:10:03.136 align:start position:20% line:-2
テストサブセットに
requestHandlerを提供

00:09:59.633 --> 00:10:03.136 align:start position:20% line:-2
テストサブセットに
requestHandlerを提供

00:10:03.403 --> 00:10:06.306 align:start position:18% line:-2
URLRequestをパラメータとし
呼び出します

00:10:07.474 --> 00:10:10.644 align:start position:34% line:-2
戻ってきたものを
システムに渡します

00:10:10.878 --> 00:10:13.780 align:start position:34% line:-2
URLレスポンスと
データの場合も

00:10:14.681 --> 00:10:16.049 align:start position:30% line:-1
エラーの場合もあります

00:10:18.552 --> 00:10:20.787 align:start position:34% line:-2
テストリクエストの
キャンセルは

00:10:20.888 --> 00:10:24.925 align:start position:23% line:-2
stopLoadingの実装と
同様です

00:10:28.829 --> 00:10:32.199 align:start position:29% line:-2
スタブプロトコルがあれば
テストを記述できます

00:10:33.400 --> 00:10:36.503 align:start position:16% line:-1
APIRequestLoaderを作成

00:10:36.603 --> 00:10:38.705 align:start position:36% line:-2
構成内容は
リクエスト型と―

00:10:39.072 --> 00:10:43.143 align:start position:20% line:-2
URLProtocolのため
設定されたURLSessionです

00:10:46.246 --> 00:10:51.084 align:start position:11% line:-2
テストベースにrequestHandlerを
MockURLProtocolで設定

00:10:51.718 --> 00:10:54.955 align:start position:32% line:-2
リクエストについて
アサーションを作成し

00:10:55.789 --> 00:10:57.925 align:start position:30% line:-1
スタブ応答を提供します

00:10:59.726 --> 00:11:02.196 align:start position:18% line:-2
そしてloadAPIRequestを
呼び出します

00:10:59.726 --> 00:11:02.196 align:start position:18% line:-2
そしてloadAPIRequestを
呼び出します

00:11:02.996 --> 00:11:05.365 align:start position:38% line:-2
完了ブロックの
呼び出しを待ち

00:11:06.099 --> 00:11:08.702 align:start position:32% line:-2
解析した応答について
アサーションを作成

00:11:10.938 --> 00:11:16.310 align:start position:27% line:-2
この層のテストの実行により
コードの連携と―

00:11:16.410 --> 00:11:19.479 align:start position:34% line:-2
システムとの統合が
確認できます

00:11:19.713 --> 00:11:22.916 align:start position:29% line:-2
データタスクで
レジュームを呼び忘れると

00:11:23.016 --> 00:11:26.286 align:start position:36% line:-2
このテストは
不合格となります

00:11:26.520 --> 00:11:28.956 align:start position:27% line:-1
皆さんも経験があるでしょう

00:11:33.260 --> 00:11:38.966 align:start position:27% line:-2
最後に エンドツーエンドの
システムテストが重要です

00:11:39.766 --> 00:11:43.103 align:start position:27% line:-1
UIテストが効果的でしょう

00:11:44.371 --> 00:11:46.173 align:start position:32% line:-1
UIテストについては

00:11:46.273 --> 00:11:51.144 align:start position:7% line:-2
WWDC 2015の“UI Testing in
Xcode”をご参照ください

00:11:54.014 --> 00:11:59.686 align:start position:27% line:-2
エンドツーエンドのテストを
記述する際に問題があります

00:12:00.120 --> 00:12:02.422 align:start position:30% line:-1
不合格となった場合に―

00:12:02.523 --> 00:12:06.660 align:start position:30% line:-2
どこから原因を探るかと
いうことです

00:12:07.961 --> 00:12:11.131 align:start position:29% line:-2
我々は
この問題への対策として―

00:12:11.231 --> 00:12:14.168 align:start position:27% line:-2
モックサーバの
ローカルインスタンスを設定

00:12:14.268 --> 00:12:19.173 align:start position:25% line:-2
UIテストを中断し モックに
リクエストさせました

00:12:19.640 --> 00:12:22.242 align:start position:29% line:-1
データをコントロールでき

00:12:22.342 --> 00:12:25.779 align:start position:32% line:-2
UIテストの信頼性が
高まりました

00:12:28.582 --> 00:12:32.085 align:start position:30% line:-2
この点でモックサーバは
役に立ちますが―

00:12:32.186 --> 00:12:36.290 align:start position:23% line:-2
本物のサーバに
リクエストするテストも有益です

00:12:38.959 --> 00:12:43.330 align:start position:23% line:-2
そこでユニットテストバンドルで
テストをします

00:12:43.430 --> 00:12:46.633 align:start position:30% line:-2
アプリケーションに対し
直接 呼び出すテストで

00:12:46.900 --> 00:12:50.170 align:start position:30% line:-2
本物のサーバに直接
リクエストさせるのです

00:12:51.004 --> 00:12:53.607 align:start position:29% line:-2
するとアプリケーションと
同じように―

00:12:53.707 --> 00:12:57.044 align:start position:30% line:-2
サーバもリクエストを
受け取るか確認できます

00:12:57.477 --> 00:13:01.715 align:start position:29% line:-2
また同時にUIを
テストする際の問題もなく

00:12:57.477 --> 00:13:01.715 align:start position:29% line:-2
また同時にUIを
テストする際の問題もなく

00:13:01.815 --> 00:13:04.918 align:start position:27% line:-2
サーバの応答を解析できるか
確認できます

00:13:10.290 --> 00:13:12.025 align:start position:38% line:-1
まとめましょう

00:13:12.125 --> 00:13:14.161 align:start position:32% line:-1
コードを小さく分割し

00:13:14.261 --> 00:13:18.165 align:start position:32% line:-2
ユニットテストを
実行しやすくしました

00:13:19.500 --> 00:13:22.836 align:start position:29% line:-2
ネットワークリクエストの
モックに

00:13:22.936 --> 00:13:25.038 align:start position:18% line:-1
URLProtocolを使用しました

00:13:26.306 --> 00:13:31.612 align:start position:30% line:-2
また バランスのいい
テストスイートの作成を

00:13:31.712 --> 00:13:34.148 align:start position:34% line:-2
ピラミッドモデルで
説明しました

00:13:35.549 --> 00:13:39.520 align:start position:29% line:-2
この後はスチュアートが
テクニックをお教えします

00:13:40.087 --> 00:13:43.090 align:start position:43% line:-1
(拍手)

00:13:43.190 --> 00:13:44.324 align:start position:41% line:-1
ありがとう

00:13:46.493 --> 00:13:47.895 align:start position:30% line:-1
ありがとう　ブライアン

00:13:48.061 --> 00:13:53.066 align:start position:21% line:-2
まず 通知のテストについての
ベストプラクティスをお教えします

00:13:54.668 --> 00:14:00.174 align:start position:20% line:-2
ここで“通知”というのは
Foundationレベルの通知で

00:13:54.668 --> 00:14:00.174 align:start position:20% line:-2
ここで“通知”というのは
Foundationレベルの通知で

00:14:00.274 --> 00:14:02.876 align:start position:23% line:-2
NSNotificationと
Objective-Cです

00:14:03.243 --> 00:14:07.114 align:start position:30% line:-2
通知の監視を
テストすることもあれば

00:14:07.214 --> 00:14:11.018 align:start position:29% line:-2
通知の送信を
テストする場合もあります

00:14:11.418 --> 00:14:14.621 align:start position:30% line:-2
通知は１対多数の
コミュニケーションです

00:14:14.721 --> 00:14:20.761 align:start position:27% line:-2
つまり１つの通知の受け手は
アプリケーション全体や―

00:14:20.861 --> 00:14:24.198 align:start position:29% line:-2
フレームワークコード内に
複数います

00:14:24.298 --> 00:14:29.603 align:start position:30% line:-2
そこで通知のテストでは
分離することが重要です

00:14:29.703 --> 00:14:33.440 align:start position:30% line:-1
意図しない副作用を避け

00:14:33.540 --> 00:14:37.311 align:start position:34% line:-2
信頼性を損なうのを
防ぐためです

00:14:37.511 --> 00:14:40.681 align:start position:30% line:-2
この問題のあるコードを
見ましょう

00:14:41.248 --> 00:14:45.819 align:start position:12% line:-2
PointsOfInterest
TableViewControllerです

00:14:46.086 --> 00:14:49.356 align:start position:30% line:-2
近くのスポットを
テーブルビューで表示し

00:14:49.656 --> 00:14:54.461 align:start position:29% line:-2
位置承認に変更があると
データを再読み込みします

00:14:54.628 --> 00:14:57.331 align:start position:20% line:-1
authChangedという通知を

00:14:57.431 --> 00:15:00.467 align:start position:9% line:-2
CurrentLocationProvider
クラスから監視します

00:14:57.431 --> 00:15:00.467 align:start position:9% line:-2
CurrentLocationProvider
クラスから監視します

00:15:00.667 --> 00:15:04.338 align:start position:30% line:-2
通知を監視する時
必要なら 再読み込みし

00:15:04.438 --> 00:15:07.908 align:start position:34% line:-2
目的のため
フラグを設定します

00:15:08.242 --> 00:15:13.981 align:start position:27% line:-2
通知を受け取ったかを
フラグでチェックするのです

00:15:14.481 --> 00:15:19.019 align:start position:27% line:-2
デフォルトの通知センターで
オブザーバを追加しています

00:15:19.786 --> 00:15:23.023 align:start position:34% line:-2
ユニットテストは
どうなるでしょうか

00:15:23.757 --> 00:15:29.163 align:start position:7% line:-2
authChangedNotificationを
ポストしてシミュレートし

00:15:29.263 --> 00:15:33.433 align:start position:11% line:-2
そしてデフォルトの
NotificationCenterにポスト

00:15:33.967 --> 00:15:39.206 align:start position:27% line:-2
このテストは機能しても
未知の副作用が出る可能性も

00:15:39.373 --> 00:15:41.975 align:start position:27% line:-1
システム通知に多いですが―

00:15:42.075 --> 00:15:48.682 align:start position:29% line:-2
多くのレイヤに監視され
未知の副作用があり得ます

00:15:48.815 --> 00:15:51.418 align:start position:29% line:-1
テスト速度が落ちることも

00:15:51.518 --> 00:15:55.055 align:start position:30% line:-2
そこでコードを分離して
テストするのです

00:15:56.623 --> 00:16:00.127 align:start position:34% line:-2
あるテクニックで
うまく分離できます

00:15:56.623 --> 00:16:00.127 align:start position:34% line:-2
あるテクニックで
うまく分離できます

00:16:00.227 --> 00:16:04.932 align:start position:25% line:-2
通知センターは
複数のインスタンスがあります

00:16:05.432 --> 00:16:10.070 align:start position:27% line:-2
デフォルトのインスタンスが
ありますが―

00:16:10.170 --> 00:16:13.273 align:start position:29% line:-2
必要に応じ
インスタンスを生成します

00:16:13.373 --> 00:16:16.009 align:start position:25% line:-1
これが分離のカギとなるのです

00:16:16.343 --> 00:16:20.714 align:start position:11% line:-2
新しいNotificationCenterを
作成し

00:16:20.814 --> 00:16:24.885 align:start position:27% line:-2
デフォルトのインスタンスの
代わりに使うのです

00:16:25.486 --> 00:16:28.088 align:start position:27% line:-1
依存性の注入とも呼ばれます

00:16:28.422 --> 00:16:31.124 align:start position:21% line:-2
View Controllerで
使ってみましょう

00:16:31.825 --> 00:16:35.696 align:start position:5% line:-2
デフォルトのNotificationCenterを
使った元のコードを

00:16:35.796 --> 00:16:38.499 align:start position:36% line:-1
修正したものです

00:16:39.399 --> 00:16:44.338 align:start position:27% line:-2
パラメータとプロパティを
イニシャライザに加えました

00:16:44.738 --> 00:16:49.810 align:start position:27% line:-2
オブザーバを加えず
新しいプロパティを使います

00:16:51.912 --> 00:16:56.216 align:start position:20% line:-2
また.defaultのデフォルトの
パラメータ値を加え

00:16:56.316 --> 00:16:59.153 align:start position:27% line:-1
既存コードの破壊を避けます

00:16:59.253 --> 00:17:04.124 align:start position:27% line:-2
新しいパラメータを渡すのは
ユニットテストだけです

00:16:59.253 --> 00:17:04.124 align:start position:27% line:-2
新しいパラメータを渡すのは
ユニットテストだけです

00:17:05.893 --> 00:17:08.194 align:start position:30% line:-1
ではテストを更新します

00:17:08.796 --> 00:17:10.597 align:start position:32% line:-1
元のテストコードです

00:17:10.931 --> 00:17:14.768 align:start position:9% line:-2
修正して 分離した
NotificationCenterを使います

00:17:18.070 --> 00:17:21.575 align:start position:30% line:-2
このように通知の監視を
テストしますが―

00:17:21.675 --> 00:17:24.645 align:start position:30% line:-1
通知の送信のテストは？

00:17:25.479 --> 00:17:29.082 align:start position:9% line:-2
分離したNotificationCenterを
使いますが―

00:17:29.182 --> 00:17:34.354 align:start position:12% line:-2
ビルトインExpectation APIを
活用します

00:17:35.522 --> 00:17:40.227 align:start position:5% line:-2
我々のアプリケーションの
CurrentLocationProviderです

00:17:40.460 --> 00:17:42.896 align:start position:27% line:-1
このクラスは後で話しますが

00:17:42.996 --> 00:17:46.667 align:start position:25% line:-2
アプリケーションの位置承認の
変更を―

00:17:46.767 --> 00:17:51.071 align:start position:29% line:-2
他のクラスに
通知を送信して知らせます

00:17:51.905 --> 00:17:54.474 align:start position:16% line:-2
デフォルトの
NotificationCenterを

00:17:54.575 --> 00:17:56.577 align:start position:30% line:-1
ハードコードしています

00:17:58.512 --> 00:18:00.881 align:start position:32% line:-2
このユニットテストを
記述しました

00:17:58.512 --> 00:18:00.881 align:start position:32% line:-2
このユニットテストを
記述しました

00:18:00.981 --> 00:18:02.950 align:start position:11% line:-2
notifyAuthChangedメソッドが
呼ばれたら―

00:18:03.050 --> 00:18:05.953 align:start position:27% line:-1
通知を送信するか確認します

00:18:06.887 --> 00:18:08.522 align:start position:21% line:-2
ここでは
addObserverメソッドで

00:18:08.622 --> 00:18:12.793 align:start position:34% line:-2
ブロックベースの
オブザーバを作成し

00:18:12.893 --> 00:18:15.362 align:start position:36% line:-2
ブロックの中に
移動させています

00:18:16.063 --> 00:18:22.402 align:start position:9% line:-2
ビルトインのXCTNSNotification
Expectation APIを使い

00:18:22.503 --> 00:18:26.640 align:start position:18% line:-2
NotificationCenter
オブザーバを作成できます

00:18:27.508 --> 00:18:32.045 align:start position:30% line:-2
コードの行数を減らせる
いい改善です

00:18:32.679 --> 00:18:37.317 align:start position:11% line:-2
しかしデフォルトの
NotificationCenterの使用は

00:18:37.417 --> 00:18:38.852 align:start position:34% line:-1
再考すべきでしょう

00:18:40.087 --> 00:18:41.655 align:start position:38% line:-1
元のコードです

00:18:42.523 --> 00:18:47.761 align:start position:12% line:-2
イニシャライザに 分離した
NotificationCenterを入れ

00:18:47.861 --> 00:18:50.998 align:start position:32% line:-2
デフォルトの代わりに
使いましょう

00:18:53.667 --> 00:18:55.636 align:start position:34% line:-1
テストコードに戻り

00:18:56.136 --> 00:18:59.840 align:start position:11% line:-2
新しいNotificationCenterを
対象に渡すため修正

00:19:00.274 --> 00:19:02.709 align:start position:23% line:-2
しかしExpectationに
ご注目を

00:19:03.343 --> 00:19:07.514 align:start position:32% line:-2
Centerで
通知を受け取るなら―

00:19:07.614 --> 00:19:09.950 align:start position:18% line:-2
NotificationCenter
パラメータを

00:19:10.050 --> 00:19:12.186 align:start position:29% line:-2
Expectationの
イニシャライザに渡せます

00:19:13.687 --> 00:19:18.826 align:start position:25% line:-2
またExpectationの
タイムアウトが“０”なのは

00:19:18.926 --> 00:19:23.330 align:start position:29% line:-2
待つ前に実行されることを
期待しているからです

00:19:23.831 --> 00:19:26.400 align:start position:20% line:-2
notifyAuthChanged
メソッドが戻る前に―

00:19:26.500 --> 00:19:29.770 align:start position:29% line:-2
通知は
送信されるべきだからです

00:19:30.671 --> 00:19:33.941 align:start position:29% line:-2
この２つの
テストテクニックを使って

00:19:34.041 --> 00:19:36.844 align:start position:29% line:-1
テストを分離させられます

00:19:36.944 --> 00:19:40.747 align:start position:27% line:-2
デフォルトのパラメータ値を
指定したので―

00:19:40.848 --> 00:19:43.817 align:start position:34% line:-2
既存のコードを
修正せずに済みます

00:19:47.788 --> 00:19:51.658 align:start position:30% line:-2
ユニットテスト記述に
伴う問題をお話しします

00:19:51.758 --> 00:19:54.194 align:start position:27% line:-1
外部クラスとのやり取りです

00:19:55.863 --> 00:19:59.099 align:start position:27% line:-2
アプリケーションの開発中に
クラスが―

00:19:59.199 --> 00:20:05.472 align:start position:25% line:-2
アプリケーション内やSDKの
別のクラスとやり取りします

00:19:59.199 --> 00:20:05.472 align:start position:25% line:-2
アプリケーション内やSDKの
別のクラスとやり取りします

00:20:05.572 --> 00:20:08.575 align:start position:29% line:-2
外部クラスを作成するのは
難しいため―

00:20:08.675 --> 00:20:12.513 align:start position:30% line:-2
テストの記述も困難だと
分かりますね

00:20:12.846 --> 00:20:17.618 align:start position:25% line:-2
直接 作成されないAPIだと
特によく起こります

00:20:17.718 --> 00:20:21.989 align:start position:27% line:-2
デリゲートメソッドがあれば
さらに困難です

00:20:22.823 --> 00:20:25.826 align:start position:34% line:-2
プロトコルを使って
解決しましょう

00:20:25.926 --> 00:20:28.829 align:start position:29% line:-2
外部クラスとのやり取りを
モックし

00:20:28.929 --> 00:20:32.332 align:start position:36% line:-2
テストの信頼性は
損ないません

00:20:34.067 --> 00:20:39.172 align:start position:2% line:-2
CurrentLocationProviderクラスで
CoreLocationを使っています

00:20:39.807 --> 00:20:43.710 align:start position:18% line:-2
CLLocationManagerを
イニシャライザに構成し

00:20:43.811 --> 00:20:47.915 align:start position:34% line:-2
自身をデリゲートと
設定しています

00:20:49.983 --> 00:20:53.954 align:start position:9% line:-2
checkCurrentLocationという
メソッドです

00:20:54.087 --> 00:20:56.990 align:start position:32% line:-2
現在地をリクエストし
完了ブロックで―

00:20:57.090 --> 00:20:59.960 align:start position:29% line:-1
スポットかどうか返します

00:21:00.794 --> 00:21:05.332 align:start position:14% line:-2
requestLocationメソッドを
呼び出しています

00:21:05.833 --> 00:21:09.169 align:start position:27% line:-1
すると現在地の取得を試みて

00:21:09.269 --> 00:21:11.939 align:start position:27% line:-2
最後にデリゲートメソッドを
呼びます

00:21:12.039 --> 00:21:14.007 align:start position:38% line:-1
見てみましょう

00:21:15.275 --> 00:21:16.176 align:start position:29% line:-1
extensionを使い

00:21:16.276 --> 00:21:19.646 align:start position:5% line:-2
CLLocationManagerDelegate
プロトコルに準拠

00:21:19.746 --> 00:21:21.949 align:start position:29% line:-2
保存された完了ブロックを
呼びます

00:21:22.349 --> 00:21:25.586 align:start position:32% line:-2
ではユニットテストを
書きましょう

00:21:26.720 --> 00:21:29.389 align:start position:32% line:-1
全体を読んでみると―

00:21:29.490 --> 00:21:33.393 align:start position:4% line:-2
まずCurrentLocationProviderを
作成して

00:21:33.494 --> 00:21:37.297 align:start position:27% line:-2
目標精度とデリゲート設定を
確認します

00:21:37.397 --> 00:21:38.799 align:start position:41% line:-1
順調ですね

00:21:39.099 --> 00:21:40.934 align:start position:34% line:-1
ここから ご注意を

00:21:41.235 --> 00:21:46.039 align:start position:5% line:-2
checkCurrentLocationメソッドを
確認したいですが―

00:21:46.140 --> 00:21:48.008 align:start position:38% line:-1
問題があります

00:21:48.108 --> 00:21:51.812 align:start position:21% line:-2
requestLocationが
いつ呼ばれるか分かりません

00:21:51.912 --> 00:21:56.283 align:start position:16% line:-2
CLLocationManager上の
メソッドだからです

00:21:57.451 --> 00:22:00.154 align:start position:32% line:-1
もう１つ問題なのは―

00:21:57.451 --> 00:22:00.154 align:start position:32% line:-1
もう１つ問題なのは―

00:22:00.254 --> 00:22:03.557 align:start position:27% line:-2
CoreLocationが
ユーザ認証を求めることです

00:22:03.657 --> 00:22:07.794 align:start position:25% line:-2
認証していないと
許可ダイアログが表示されます

00:22:08.295 --> 00:22:10.864 align:start position:29% line:-1
デバイスの状態に左右され

00:22:10.964 --> 00:22:14.535 align:start position:34% line:-2
テストが不合格に
なりやすくなります

00:22:16.236 --> 00:22:21.475 align:start position:27% line:-2
この問題に対処するには
外部クラスのサブクラス化と

00:22:21.575 --> 00:22:24.578 align:start position:34% line:-2
メソッドの
オーバーライドです

00:22:24.778 --> 00:22:25.679 align:start position:43% line:-1
例えば―

00:22:25.779 --> 00:22:28.982 align:start position:18% line:-2
CLLocationManagerの
サブクラス化と

00:22:29.082 --> 00:22:31.785 align:start position:14% line:-2
requestLocationメソッドの
オーバーライドです

00:22:32.052 --> 00:22:35.022 align:start position:23% line:-1
最初はよくてもリスクが高いです

00:22:35.522 --> 00:22:40.160 align:start position:27% line:-2
SDKからのクラスの一部は
サブクラス化に向いておらず

00:22:40.594 --> 00:22:45.799 align:start position:21% line:-2
スーパークラスのイニシャライザを
呼ぶ必要もあります

00:22:46.166 --> 00:22:47.668 align:start position:32% line:-1
しかし主要な問題は―

00:22:47.768 --> 00:22:52.039 align:start position:30% line:-2
メソッド呼び出しのため
コードを修正した時で

00:22:52.139 --> 00:22:56.543 align:start position:29% line:-2
そのメソッドの
オーバーライドが必要です

00:22:57.010 --> 00:23:02.416 align:start position:27% line:-2
別のメソッドを呼び出したと
コンパイラが通知せず―

00:22:57.010 --> 00:23:02.416 align:start position:27% line:-2
別のメソッドを呼び出したと
コンパイラが通知せず―

00:23:02.516 --> 00:23:04.985 align:start position:34% line:-2
つい忘れて
テストが失敗します

00:23:05.452 --> 00:23:07.287 align:start position:27% line:-1
この方法は お勧めしません

00:23:07.387 --> 00:23:11.291 align:start position:30% line:-2
プロトコルで外部の型を
モックするのがいい

00:23:11.391 --> 00:23:13.160 align:start position:32% line:-1
その方法を説明します

00:23:14.461 --> 00:23:16.130 align:start position:38% line:-1
元のコードです

00:23:16.230 --> 00:23:19.333 align:start position:29% line:-2
まず 新しいプロトコルを
定義します

00:23:20.234 --> 00:23:22.803 align:start position:21% line:-2
LocationFetcherと
名づけました

00:23:22.903 --> 00:23:28.342 align:start position:12% line:-2
CLLocationManagerから使う
メソッドとプロパティを含みます

00:23:28.942 --> 00:23:31.979 align:start position:27% line:-1
メンバーの名前と型が一致し

00:23:32.079 --> 00:23:37.284 align:start position:18% line:-2
CLLocationManagerに
extensionを作成できます

00:23:37.384 --> 00:23:39.620 align:start position:32% line:-1
要件を満たすからです

00:23:41.255 --> 00:23:44.925 align:start position:12% line:-2
locationManagerプロパティを
locationFetcherと名を変え

00:23:45.025 --> 00:23:48.128 align:start position:12% line:-2
locationFetcherプロトコルに
型を変えます

00:23:49.596 --> 00:23:53.700 align:start position:23% line:-2
イニシャライザに
デフォルトのパラメータ値を与え

00:23:53.801 --> 00:23:56.370 align:start position:27% line:-1
既存コードの破壊を避けます

00:23:58.372 --> 00:24:03.777 align:start position:5% line:-2
checkCurrentLocationメソッドに
１カ所 変更が必要です

00:23:58.372 --> 00:24:03.777 align:start position:5% line:-2
checkCurrentLocationメソッドに
１カ所 変更が必要です

00:24:05.379 --> 00:24:07.848 align:start position:30% line:-2
最後に
デリゲートメソッドです

00:24:08.115 --> 00:24:12.653 align:start position:27% line:-2
少し問題なのはデリゲートが
マネージャパラメータを―

00:24:12.753 --> 00:24:16.924 align:start position:12% line:-2
本物のCLLocationManagerと
考えるからです

00:24:17.491 --> 00:24:20.594 align:start position:30% line:-2
デリゲートでは
少し複雑になりますが―

00:24:20.694 --> 00:24:22.930 align:start position:29% line:-1
プロトコルを適用できます

00:24:23.030 --> 00:24:24.631 align:start position:38% line:-1
確認しましょう

00:24:26.300 --> 00:24:30.003 align:start position:23% line:-2
LocationFetcher
プロトコルに戻り

00:24:30.270 --> 00:24:34.474 align:start position:7% line:-2
デリゲートプロパティ名を
LocationFetcherDelegateへ

00:24:34.575 --> 00:24:36.643 align:start position:29% line:-1
そして型は新プロトコルへ

00:24:36.743 --> 00:24:40.681 align:start position:4% line:-2
CLLocationManagerDelegateと
ほぼ同じインターフェイスです

00:24:40.781 --> 00:24:42.449 align:start position:30% line:-1
しかしメソッド名を変え

00:24:42.549 --> 00:24:45.986 align:start position:21% line:-2
最初のパラメータ型を
LocationFetcherへ

00:24:49.289 --> 00:24:53.393 align:start position:9% line:-2
LocationFetcherDelegate
プロパティを実装しましょう

00:24:53.494 --> 00:24:56.430 align:start position:34% line:-2
もはや要件を
満たさないからです

00:24:56.897 --> 00:24:59.800 align:start position:29% line:-2
ゲッタとセッタを実装し
フォースキャストを用い―

00:24:59.900 --> 00:25:03.270 align:start position:20% line:-2
CLLocationManager
Delegateとの間で変換

00:24:59.900 --> 00:25:03.270 align:start position:20% line:-2
CLLocationManager
Delegateとの間で変換

00:25:03.537 --> 00:25:06.507 align:start position:34% line:-2
フォースキャストを
使う理由は 後ほど

00:25:08.308 --> 00:25:13.180 align:start position:7% line:-2
デリゲートプロパティは
locationFetcherDelegateへ

00:25:14.848 --> 00:25:17.651 align:start position:23% line:-1
最後に元のextensionを

00:25:17.751 --> 00:25:21.622 align:start position:29% line:-2
新モックデリゲート
プロトコルに準拠させます

00:25:21.722 --> 00:25:25.959 align:start position:21% line:-2
プロトコルとメソッドシグネチャを
置き換えるだけです

00:25:26.527 --> 00:25:32.166 align:start position:11% line:-2
しかし前のCLLocationManager
Delegateプロトコルにも準拠

00:25:32.499 --> 00:25:34.668 align:start position:16% line:-2
本物の
CLLocationManagerが―

00:25:34.768 --> 00:25:37.337 align:start position:25% line:-2
モックデリゲートプロトコルを
知らないからです

00:25:38.172 --> 00:25:43.010 align:start position:20% line:-2
本物に準拠したextensionを
戻すのがコツで

00:25:43.110 --> 00:25:46.780 align:start position:16% line:-2
上の同じlocationFetcher
デリゲートメソッドを呼ばせます

00:25:47.915 --> 00:25:51.952 align:start position:27% line:-2
デリゲートゲッタとセッタで
フォースキャストを使うのは

00:25:52.319 --> 00:25:57.991 align:start position:27% line:-2
クラスを両方のプロトコルに
準拠させるためです

00:26:01.528 --> 00:26:06.700 align:start position:21% line:-2
ユニットテストではテストクラスで
入れ子になった構造体を定義

00:26:06.800 --> 00:26:10.838 align:start position:12% line:-2
locationFetcherプロトコルに
準拠し 要求を満たします

00:26:11.438 --> 00:26:14.241 align:start position:12% line:-2
requestLocationメソッドでは
ブロックを呼び

00:26:14.341 --> 00:26:17.945 align:start position:32% line:-2
カスタマイズできる
偽の位置を取得します

00:26:18.178 --> 00:26:21.949 align:start position:27% line:-2
デリゲートメソッドを起動し
偽の位置を渡します

00:26:24.484 --> 00:26:27.588 align:start position:34% line:-2
材料がそろったので
テストの記述です

00:26:27.921 --> 00:26:30.023 align:start position:16% line:-2
MockLocationFetcher
構造体を作成

00:26:30.124 --> 00:26:32.493 align:start position:12% line:-2
handleRequestLocation
ブロックを設定し

00:26:32.593 --> 00:26:34.495 align:start position:32% line:-1
偽の位置を提供します

00:26:35.195 --> 00:26:37.531 align:start position:20% line:-2
次にCurrentLocation
Providerを作成し

00:26:37.631 --> 00:26:39.900 align:start position:14% line:-2
MockLocationFetcherに
渡します

00:26:40.200 --> 00:26:43.971 align:start position:5% line:-2
最後に完了ブロックで
checkCurrentLocationを呼びます

00:26:44.204 --> 00:26:45.505 align:start position:36% line:-1
完了ブロックでは

00:26:45.606 --> 00:26:49.343 align:start position:29% line:-2
位置がスポットなのかを
アサーションが確認します

00:26:51.078 --> 00:26:54.882 align:start position:12% line:-2
これで クラスによる
CLLocationManagerの使用を

00:26:54.982 --> 00:26:57.117 align:start position:30% line:-1
うまくモックしましたね

00:26:58.118 --> 00:27:02.523 align:start position:27% line:-2
プロトコルを使って
やり取りをモックする方法を

00:26:58.118 --> 00:27:02.523 align:start position:27% line:-2
プロトコルを使って
やり取りをモックする方法を

00:27:02.623 --> 00:27:03.991 align:start position:38% line:-1
ご説明しました

00:27:04.191 --> 00:27:06.927 align:start position:34% line:-1
おさらいしましょう

00:27:08.829 --> 00:27:13.901 align:start position:27% line:-2
最初に 新しいプロトコルを
定義しました

00:27:14.234 --> 00:27:19.406 align:start position:27% line:-2
外部クラスに使うメソッドや
プロパティがすべて―

00:27:19.506 --> 00:27:22.609 align:start position:27% line:-1
このプロトコルに含まれます

00:27:23.744 --> 00:27:27.080 align:start position:29% line:-2
次に 元の外部クラスに
extensionを作成

00:27:27.181 --> 00:27:29.383 align:start position:32% line:-2
プロトコルへの準拠を
宣言します

00:27:30.384 --> 00:27:34.521 align:start position:29% line:-2
そして外部クラスの利用を
新プロトコルと置き換えて

00:27:34.788 --> 00:27:39.159 align:start position:23% line:-2
型を設定できるように
イニシャライザパラメータを追加

00:27:40.928 --> 00:27:46.233 align:start position:21% line:-2
またSDKで一般的なプロトコルの
モック法の説明です

00:27:46.867 --> 00:27:50.070 align:start position:32% line:-2
我々は
このようにやりました

00:27:50.938 --> 00:27:53.440 align:start position:32% line:-2
まずモックデリゲート
プロトコルを―

00:27:53.540 --> 00:27:56.844 align:start position:29% line:-2
同じメソッドシグネチャで
定義しました

00:27:57.044 --> 00:28:00.814 align:start position:23% line:-2
本物の型はモックプロトコル型と
置き換えました

00:27:57.044 --> 00:28:00.814 align:start position:23% line:-2
本物の型はモックプロトコル型と
置き換えました

00:28:01.982 --> 00:28:05.819 align:start position:27% line:-2
元のモックプロトコルで
デリゲートプロパティを改名

00:28:05.919 --> 00:28:08.722 align:start position:21% line:-2
そのプロパティを
extensionで実装しました

00:28:09.790 --> 00:28:15.329 align:start position:27% line:-2
サブクラス化などと比べると
多くのコードが必要ですが

00:28:15.562 --> 00:28:19.900 align:start position:25% line:-2
信頼性は高く
コードが破たんしにくいのです

00:28:20.100 --> 00:28:24.972 align:start position:27% line:-2
なぜなら
呼び出したメソッドはすべて

00:28:25.072 --> 00:28:27.407 align:start position:36% line:-2
新プロトコルに
含まれるからです

00:28:31.879 --> 00:28:35.983 align:start position:29% line:-2
最後にテスト速度について
お話しします

00:28:38.018 --> 00:28:42.589 align:start position:30% line:-2
テストに時間がかかれば
開発中の実行を避け

00:28:42.689 --> 00:28:45.559 align:start position:34% line:-2
長いテストを
飛ばすかもしれない

00:28:46.160 --> 00:28:50.631 align:start position:29% line:-2
我々のテストスイートでは
素早く簡単にできます

00:28:50.731 --> 00:28:54.101 align:start position:36% line:-2
そのテスト速度を
維持したいのです

00:28:54.902 --> 00:28:59.773 align:start position:27% line:-2
テストで わざと待機や
スリープ状態にした経験は？

00:28:59.873 --> 00:29:03.777 align:start position:30% line:-2
原因はコードの非同期や
タイマーの使用でしょう

00:28:59.873 --> 00:29:03.777 align:start position:30% line:-2
原因はコードの非同期や
タイマーの使用でしょう

00:29:04.411 --> 00:29:08.081 align:start position:30% line:-2
遅延したアクションには
注意が要りますし

00:29:08.182 --> 00:29:11.385 align:start position:38% line:-2
すべての速度が
落ちかねません

00:29:11.752 --> 00:29:17.624 align:start position:29% line:-2
必要ではない遅延を
避ける方法をご紹介します

00:29:19.159 --> 00:29:23.130 align:start position:30% line:-2
例えば我々がビルド中の
アプリケーションでは

00:29:23.230 --> 00:29:27.434 align:start position:34% line:-2
メインUIの下部に
注目地点を表示

00:29:27.534 --> 00:29:33.073 align:start position:25% line:-2
10秒ごとに入れ替わりながら
近くの上位地点を表示します

00:29:33.474 --> 00:29:39.112 align:start position:25% line:-2
いくつかの選択肢の中から
Timer APIを使います

00:29:40.881 --> 00:29:43.617 align:start position:34% line:-2
このクラスの
ユニットテストです

00:29:44.017 --> 00:29:46.420 align:start position:12% line:-2
FeaturedPlaceManagerを
生成し

00:29:46.520 --> 00:29:51.125 align:start position:11% line:-2
scheduleNextPlaceメソッドを
呼び出すまで 現在地を保存

00:29:51.492 --> 00:29:56.763 align:start position:30% line:-2
実行ループは11秒間で
１秒は猶予時間です

00:29:57.331 --> 00:30:00.467 align:start position:18% line:-2
最後に
currentPlaceの変化を確認

00:29:57.331 --> 00:30:00.467 align:start position:18% line:-2
最後に
currentPlaceの変化を確認

00:30:00.968 --> 00:30:04.438 align:start position:32% line:-2
これでは実行に
かなり時間が要ります

00:30:04.938 --> 00:30:08.141 align:start position:34% line:-2
そこでコードに
プロパティを公開し

00:30:08.242 --> 00:30:12.479 align:start position:29% line:-2
タイムアウトを１秒程度に
カスタマイズします

00:30:12.880 --> 00:30:16.450 align:start position:34% line:-2
このようにコードを
変えるのです

00:30:20.687 --> 00:30:24.758 align:start position:36% line:-2
この方法で遅延を
１秒に減らせます

00:30:25.325 --> 00:30:30.197 align:start position:29% line:-2
先ほどより改善して
実行が速くなりましたが―

00:30:30.297 --> 00:30:32.232 align:start position:34% line:-1
まだ理想的ではない

00:30:32.332 --> 00:30:35.302 align:start position:27% line:-1
短くなっても遅延はあります

00:30:35.669 --> 00:30:39.640 align:start position:32% line:-2
問題は このコードが
時間依存的なことで―

00:30:39.740 --> 00:30:45.179 align:start position:27% line:-2
遅延を短くするほど
信頼性が損なわれ得るのです

00:30:45.279 --> 00:30:48.582 align:start position:29% line:-2
スケジュール予測が
CPUに依存するからです

00:30:48.682 --> 00:30:52.219 align:start position:34% line:-2
特に非同期コードは
そうとは限りません

00:30:52.820 --> 00:30:55.155 align:start position:29% line:-1
よりよい方法を見ましょう

00:30:56.490 --> 00:31:00.027 align:start position:34% line:-2
まず遅延の仕組みを
特定すべきです

00:30:56.490 --> 00:31:00.027 align:start position:34% line:-2
まず遅延の仕組みを
特定すべきです

00:31:00.127 --> 00:31:01.929 align:start position:32% line:-1
私の例ではタイマーで

00:31:02.029 --> 00:31:06.133 align:start position:11% line:-2
DispatchQueueからの
asyncAfter APIの場合もあります

00:31:06.833 --> 00:31:09.136 align:start position:30% line:-1
この仕組みをモックして

00:31:09.236 --> 00:31:13.040 align:start position:25% line:-2
直ちに遅延アクションを実行し
遅れをバイパスします

00:31:15.943 --> 00:31:17.678 align:start position:34% line:-1
再び元のコードです

00:31:17.778 --> 00:31:21.849 align:start position:16% line:-2
scheduledTimerメソッドの
動きを確認しましょう

00:31:22.516 --> 00:31:26.086 align:start position:27% line:-2
このメソッドは２つのことを
行います

00:31:26.253 --> 00:31:27.821 align:start position:34% line:-1
タイマーの生成と―

00:31:27.921 --> 00:31:30.591 align:start position:32% line:-2
現在の実行ループへの
追加です

00:31:31.125 --> 00:31:34.595 align:start position:32% line:-2
タイマーの生成に
便利なAPIですが―

00:31:34.695 --> 00:31:38.966 align:start position:27% line:-2
２つを分ければ
よりテストしやすくなります

00:31:40.500 --> 00:31:44.037 align:start position:20% line:-2
scheduledTimerを使う
先ほどのコードを変更し

00:31:44.138 --> 00:31:46.206 align:start position:34% line:-1
まずタイマーを作成

00:31:46.306 --> 00:31:50.544 align:start position:27% line:-2
次に新プロパティに保存した
runLoopを追加

00:31:51.512 --> 00:31:54.081 align:start position:32% line:-1
コードは前と同等です

00:31:54.181 --> 00:31:56.450 align:start position:34% line:-2
２つを分ければ
runLoopは―

00:31:56.550 --> 00:32:01.121 align:start position:29% line:-2
このクラスがやり取りする
外部クラスの１つです

00:31:56.550 --> 00:32:01.121 align:start position:29% line:-2
このクラスがやり取りする
外部クラスの１つです

00:32:01.288 --> 00:32:05.459 align:start position:29% line:-2
プロトコルのテクニックで
モックするのです

00:32:06.126 --> 00:32:10.731 align:start position:21% line:-2
addTimerメソッドを含んだ
小プロトコルを作り

00:32:12.032 --> 00:32:14.535 align:start position:23% line:-2
TimerSchedulerと
名づけました

00:32:14.635 --> 00:32:17.070 align:start position:25% line:-1
addTimerメソッドは―

00:32:17.171 --> 00:32:20.340 align:start position:29% line:-2
runLoop APIの
シグネチャと適合します

00:32:22.176 --> 00:32:27.181 align:start position:21% line:-2
このプロトコルをrunLoopと
置き換えましょう

00:32:29.650 --> 00:32:33.654 align:start position:30% line:-2
本物のrunLoopを
使いたくないので

00:32:33.754 --> 00:32:38.292 align:start position:25% line:-2
タイマーを渡す
モックスケジューラを作ります

00:32:39.560 --> 00:32:43.030 align:start position:25% line:-2
TimerScheduler
プロトコルに準拠する―

00:32:43.130 --> 00:32:47.267 align:start position:12% line:-2
MockTimerSchedulerという
新しい構造体を作成

00:32:47.835 --> 00:32:51.705 align:start position:27% line:-2
タイマーの追加時に呼ばれる
ブロックを含みます

00:32:53.841 --> 00:32:57.277 align:start position:29% line:-2
では最終ユニットテストを
記述します

00:32:57.778 --> 00:33:00.414 align:start position:12% line:-2
まず
MockTimerSchedulerを作り

00:32:57.778 --> 00:33:00.414 align:start position:12% line:-2
まず
MockTimerSchedulerを作り

00:33:00.514 --> 00:33:02.816 align:start position:25% line:-2
handleAddTimer
ブロックを設定

00:33:03.383 --> 00:33:08.622 align:start position:27% line:-2
スケジューラに加えられると
タイマーの遅延を記録し

00:33:08.722 --> 00:33:12.192 align:start position:34% line:-2
タイマーを発動して
遅れをバイパスし

00:33:12.292 --> 00:33:13.794 align:start position:32% line:-1
ブロックを起動します

00:33:14.928 --> 00:33:19.099 align:start position:7% line:-2
FeaturedPlaceManagerを生成し
MockTimerSchedulerを提供

00:33:19.867 --> 00:33:23.337 align:start position:12% line:-2
最後にscheduleNextPlaceを
呼んで テストを開始

00:33:23.871 --> 00:33:26.874 align:start position:34% line:-2
遅延のないテストの
完成です

00:33:26.974 --> 00:33:31.645 align:start position:30% line:-2
高速で 時間に依存せず
信頼性が増しました

00:33:32.312 --> 00:33:37.918 align:start position:27% line:-2
さらに アサーションを使い
時間の遅れを確認できます

00:33:38.018 --> 00:33:40.654 align:start position:27% line:-1
前のテストでは不可能でした

00:33:42.790 --> 00:33:47.561 align:start position:29% line:-2
このテクニックで
遅延は完全に取り除けます

00:33:47.995 --> 00:33:51.632 align:start position:27% line:-2
遅延を含むコードのテストに
適します

00:33:51.732 --> 00:33:54.802 align:start position:34% line:-2
しかしテスト全体の
速度向上には―

00:33:54.902 --> 00:33:58.438 align:start position:27% line:-2
テストの大部分を直接構造に
すべきです

00:33:58.539 --> 00:34:01.041 align:start position:29% line:-1
遅延のモックは要りません

00:33:58.539 --> 00:34:01.041 align:start position:29% line:-1
遅延のモックは要りません

00:34:01.909 --> 00:34:03.544 align:start position:30% line:-2
我々の
アプリケーションだと―

00:34:03.644 --> 00:34:07.614 align:start position:32% line:-2
遅延が次の注目地点に
変換されます

00:34:07.714 --> 00:34:13.053 align:start position:29% line:-2
１～２つのテストで
タイマーの遅れを正せます

00:34:13.152 --> 00:34:16.989 align:start position:11% line:-2
scheduleNextPlaceメソッドを
直接 呼び出し

00:34:17.091 --> 00:34:19.793 align:start position:30% line:-1
モックは必要ありません

00:34:22.496 --> 00:34:26.900 align:start position:29% line:-2
テストの実行速度について
あと２つ コツがあります

00:34:27.601 --> 00:34:31.538 align:start position:9% line:-2
NSPredicateExpectationの
使用に関しては―

00:34:31.772 --> 00:34:36.176 align:start position:16% line:-2
他のExpectationクラスほどの
性能はありません

00:34:36.275 --> 00:34:40.179 align:start position:27% line:-2
直接的な
コールバックでないからです

00:34:40.514 --> 00:34:46.219 align:start position:23% line:-2
条件の評価が別のプロセスである
UIテストに主に用いられます

00:34:46.320 --> 00:34:50.257 align:start position:29% line:-2
ユニットテストには
直接的な方法がお勧めです

00:34:50.357 --> 00:34:53.793 align:start position:5% line:-2
XCTestExpectationや
NSNotificationExpectation

00:34:53.893 --> 00:34:55.795 align:start position:18% line:-1
KVOExpectationなどです

00:34:57.931 --> 00:34:59.533 align:start position:34% line:-1
もう１つのコツは―

00:34:59.633 --> 00:35:02.770 align:start position:29% line:-2
アプリケーションの起動を
速めることです

00:34:59.633 --> 00:35:02.770 align:start position:29% line:-2
アプリケーションの起動を
速めることです

00:35:03.237 --> 00:35:06.673 align:start position:30% line:-2
ほとんどは起動時に
セットアップを行います

00:35:06.773 --> 00:35:10.177 align:start position:36% line:-2
通常の起動には
欠かせませんが―

00:35:10.277 --> 00:35:14.982 align:start position:29% line:-2
テスト実行の際には
その多くが不要になります

00:35:15.249 --> 00:35:19.119 align:start position:12% line:-2
View Controllerの読み込みや
ネットワークリクエストの開始

00:35:19.219 --> 00:35:21.521 align:start position:36% line:-2
分析パッケージの
設定などです

00:35:21.622 --> 00:35:25.826 align:start position:27% line:-2
これらはユニットテストでも
不要です

00:35:26.994 --> 00:35:32.933 align:start position:25% line:-2
XCTestは デリゲートが
起動終了を伝えるのを待ちます

00:35:33.066 --> 00:35:37.671 align:start position:29% line:-2
テスト時に
起動に時間がかかるなら―

00:35:38.072 --> 00:35:42.409 align:start position:29% line:-2
テスト実行だと検出させて
回避させるのも手です

00:35:44.011 --> 00:35:45.178 align:start position:38% line:-1
１つの方法は―

00:35:45.279 --> 00:35:49.316 align:start position:34% line:-2
カスタム環境変数や
起動引数の特定です

00:35:49.783 --> 00:35:55.289 align:start position:11% line:-2
スキームエディタの左側の
“Test”から“Arguments”を開き

00:35:55.389 --> 00:35:58.592 align:start position:32% line:-2
環境変数か起動引数を
追加しましょう

00:35:59.226 --> 00:36:04.598 align:start position:9% line:-2
このスクリーンショットでは
IS UNIT TESTINGを１にしています

00:35:59.226 --> 00:36:04.598 align:start position:9% line:-2
このスクリーンショットでは
IS UNIT TESTINGを１にしています

00:36:06.266 --> 00:36:09.703 align:start position:11% line:-2
デリゲートの
didFinishLaunchingコードを

00:36:09.803 --> 00:36:12.973 align:start position:34% line:-2
このようなコードに
変えてください

00:36:13.640 --> 00:36:17.478 align:start position:29% line:-2
スキップしたコードは
ユニットテストに不要と―

00:36:17.578 --> 00:36:19.546 align:start position:32% line:-1
必ず確認してください

00:36:23.016 --> 00:36:24.518 align:start position:39% line:-1
おさらいです

00:36:25.853 --> 00:36:32.125 align:start position:27% line:-2
ブライアンが
バランスのいいテスト作成と

00:36:32.226 --> 00:36:36.196 align:start position:29% line:-2
ネットワークテストの
テクニックを紹介しました

00:36:36.830 --> 00:36:40.601 align:start position:20% line:-2
私は
Foundation通知の分離と―

00:36:40.701 --> 00:36:42.569 align:start position:29% line:-1
依存性の注入を話しました

00:36:43.370 --> 00:36:47.274 align:start position:32% line:-2
また 外部クラスとの
やり取りという―

00:36:47.374 --> 00:36:51.612 align:start position:29% line:-2
テストを書く際の課題への
解決策を提示

00:36:52.279 --> 00:36:57.151 align:start position:23% line:-2
テスト速度を高め
遅延を避けるコツにも触れました

00:36:57.718 --> 00:37:02.556 align:start position:34% line:-2
テストを書く際に
ぜひご活用ください

00:36:57.718 --> 00:37:02.556 align:start position:34% line:-2
テストを書く際に
ぜひご活用ください

00:37:04.558 --> 00:37:07.761 align:start position:32% line:-1
詳細はウェブサイトヘ

00:37:07.861 --> 00:37:13.000 align:start position:23% line:-2
水曜のセッションを見逃した方は
ビデオをご覧ください

00:37:13.667 --> 00:37:16.336 align:start position:30% line:-1
ありがとうございました

00:37:16.437 --> 00:37:20.140 align:start position:43% line:-1
(拍手)
