WEBVTT

00:00:07.074 --> 00:00:16.517 align:start position:43% line:-1
(音楽)

00:00:27.127 --> 00:00:34.468 align:start position:43% line:-1
(拍手)

00:00:34.601 --> 00:00:35.469 align:start position:41% line:-1
こんにちは

00:00:36.403 --> 00:00:38.605 align:start position:25% line:-1
標準ライブラリ担当のベンです

00:00:38.805 --> 00:00:41.074 align:start position:29% line:-1
後ほど ダグも紹介します

00:00:41.175 --> 00:00:43.477 align:start position:18% line:-1
ではSwiftのジェネリクスについて

00:00:45.078 --> 00:00:48.415 align:start position:34% line:-2
最近のリリースで
追加した新機能は―

00:00:48.715 --> 00:00:52.853 align:start position:30% line:-2
条件付き準拠や再帰的な
プロトコル制約などです

00:00:53.854 --> 00:00:59.660 align:start position:23% line:-2
Swiftで力を入れてきたのは
ジェネリクスの表現力向上です

00:01:00.427 --> 00:01:03.530 align:start position:25% line:-1
4.2のリリースは大転換です

00:01:04.164 --> 00:01:10.838 align:start position:27% line:-2
描いてきた標準ライブラリを
やっと完全に実装できました

00:01:11.004 --> 00:01:15.442 align:start position:25% line:-2
これはAPIの安定性の実現に
必須でした

00:01:17.110 --> 00:01:23.116 align:start position:25% line:-2
では 改めて客観的視点から
ジェネリクスを見てみましょう

00:01:23.417 --> 00:01:25.485 align:start position:34% line:-1
本日のトピックです

00:01:25.586 --> 00:01:31.425 align:start position:25% line:-2
新旧のジェネリクス機能を含め
全体像を理解してください

00:01:32.693 --> 00:01:35.762 align:start position:21% line:-1
まずジェネリクスの動機に触れます

00:01:36.964 --> 00:01:43.237 align:start position:23% line:-2
次に標準ライブラリの型を例に
プロトコル設計について話します

00:01:44.505 --> 00:01:51.411 align:start position:23% line:-2
そしてプロトコル継承を振り返り
条件付き準拠との対話を見ます

00:01:51.912 --> 00:01:56.416 align:start position:23% line:-2
最後は クラスとジェネリクスで
締めくくります

00:01:58.452 --> 00:02:01.021 align:start position:23% line:-1
まず ジェネリクスの重要性です

00:01:58.452 --> 00:02:01.021 align:start position:23% line:-1
まず ジェネリクスの重要性です

00:02:01.722 --> 00:02:06.960 align:start position:23% line:-2
インパクトを見る方法の１つは
型といったコレクション設計です

00:02:08.161 --> 00:02:12.132 align:start position:32% line:-2
バッファと呼びますが
配列型に似ています

00:02:12.733 --> 00:02:16.503 align:start position:23% line:-1
バッファ読み込みのAPIには―

00:02:16.603 --> 00:02:21.808 align:start position:21% line:-2
要素のカウントや
ポジションへのフェッチがあります

00:02:22.009 --> 00:02:24.444 align:start position:29% line:-1
では その返り値の型は？

00:02:25.112 --> 00:02:31.818 align:start position:21% line:-2
もしジェネリクスがなければ
何らかの型の作成が必要になります

00:02:32.019 --> 00:02:35.322 align:start position:23% line:-1
id型やVoid Starです

00:02:35.422 --> 00:02:41.595 align:start position:25% line:-2
Swiftでは Anyが
あらゆる型の代わりとなります

00:02:43.897 --> 00:02:47.901 align:start position:20% line:-1
バッファの処理も返り値はAnyです

00:02:48.001 --> 00:02:51.972 align:start position:25% line:-2
しかし
不愉快なユーザ体験となります

00:02:52.072 --> 00:02:58.245 align:start position:23% line:-2
使うためにはボックスから
その型を取り出さねばなりません

00:03:00.814 --> 00:03:04.651 align:start position:25% line:-1
エラーも起こりやすくなります

00:03:04.751 --> 00:03:10.724 align:start position:29% line:-2
文字列バッファのコードに
整数を入れてしまったら？

00:03:12.259 --> 00:03:19.233 align:start position:21% line:-2
使いやすさだけでなく メモリ内の
値の表し方も解決したいですね

00:03:21.201 --> 00:03:24.671 align:start position:23% line:-1
文字列バッファの理想的な表現は

00:03:24.771 --> 00:03:29.977 align:start position:27% line:-2
要素が１列に並ぶ
連続したメモリブロックです

00:03:31.311 --> 00:03:34.615 align:start position:21% line:-1
でも 型なしではうまくいきません

00:03:34.715 --> 00:03:38.752 align:start position:29% line:-2
対応する型が バッファに
分からないからです

00:03:38.852 --> 00:03:43.090 align:start position:30% line:-2
それで Anyのような
万能な型を使いますが―

00:03:43.423 --> 00:03:48.195 align:start position:29% line:-2
型のボックス化などで
オーバーヘッドが生じます

00:03:50.531 --> 00:03:56.637 align:start position:25% line:-2
整数バッファが欲しいだけでも
コンパイラに示せません

00:03:56.737 --> 00:04:00.240 align:start position:23% line:-1
やむを得ず柔軟性を代償にします

00:03:56.737 --> 00:04:00.240 align:start position:23% line:-1
やむを得ず柔軟性を代償にします

00:04:01.542 --> 00:04:05.279 align:start position:32% line:-2
更に Anyは
あらゆる型になるので

00:04:05.379 --> 00:04:12.152 align:start position:23% line:-2
内部メモリにとって大きい場合は
インダイレクションも必要です

00:04:12.252 --> 00:04:16.990 align:start position:30% line:-2
メモリ中にある値に
ポインタ保持も必要です

00:04:17.824 --> 00:04:23.797 align:start position:25% line:-2
この問題の解決は
パフォーマンスにも関わります

00:04:24.698 --> 00:04:26.500 align:start position:34% line:-1
そこで使う技術が―

00:04:26.733 --> 00:04:29.169 align:start position:34% line:-1
パラメータ多相です

00:04:29.269 --> 00:04:33.373 align:start position:18% line:-1
これが Swiftのジェネリクスです

00:04:35.142 --> 00:04:40.848 align:start position:23% line:-2
バッファにより多くの情報を与え
対応する型を表せます

00:04:41.648 --> 00:04:43.250 align:start position:30% line:-1
これを要素型と呼びます

00:04:44.117 --> 00:04:49.223 align:start position:29% line:-2
要素型は汎用パラメータで
故に パラメータ多相です

00:04:49.690 --> 00:04:54.728 align:start position:21% line:-2
バッファに型を教える
コンパイル時引数のようなものです

00:04:55.629 --> 00:05:00.767 align:start position:25% line:-2
これでバッファはAnyを使い
要素型に参照できます

00:04:55.629 --> 00:05:00.767 align:start position:25% line:-2
これでバッファはAnyを使い
要素型に参照できます

00:05:03.203 --> 00:05:07.074 align:start position:30% line:-2
しかも 型を取り出す際
変換不要で―

00:05:07.341 --> 00:05:13.947 align:start position:25% line:-2
誤った型を代入してしまっても
コンパイラが教えてくれます

00:05:15.115 --> 00:05:20.454 align:start position:25% line:-2
これで すべてのバッファ型に
要素型が付きました

00:05:20.821 --> 00:05:24.691 align:start position:27% line:-2
付いていない型の宣言は
コンパイルエラーになります

00:05:26.059 --> 00:05:32.799 align:start position:23% line:-2
要素型なしのバッファも
宣言できると思うかもしれません

00:05:33.133 --> 00:05:38.338 align:start position:30% line:-2
その場合はコンパイラが
型推測しているだけです

00:05:38.438 --> 00:05:41.108 align:start position:25% line:-1
ここでは右のリテラルからです

00:05:41.909 --> 00:05:44.912 align:start position:27% line:-1
要素は暗黙で存在しています

00:05:46.246 --> 00:05:51.251 align:start position:32% line:-2
バッファのような型が
対応する型の情報は

00:05:51.351 --> 00:05:55.255 align:start position:29% line:-2
コンパイルとランタイムに
伝えられます

00:05:56.456 --> 00:06:00.294 align:start position:32% line:-2
つまり 全要素を
オーバーヘッドなしで

00:05:56.456 --> 00:06:00.294 align:start position:32% line:-2
つまり 全要素を
オーバーヘッドなしで

00:06:00.394 --> 00:06:03.263 align:start position:29% line:-2
連続したメモリブロックに
保持できるのです

00:06:03.864 --> 00:06:06.934 align:start position:29% line:-1
型が任意に大きくてもです

00:06:08.168 --> 00:06:10.204 align:start position:34% line:-1
コンパイラは常に―

00:06:10.771 --> 00:06:15.742 align:start position:27% line:-2
バッファが対応する要素型を
直接知っています

00:06:15.843 --> 00:06:20.047 align:start position:21% line:-1
それで最適化の機会を持てるのです

00:06:20.480 --> 00:06:23.684 align:start position:29% line:-2
ここでは 整数バッファを
宣言していて―

00:06:24.284 --> 00:06:29.623 align:start position:23% line:-2
ループの高効率なCPU命令への
コンパイルが必要です

00:06:31.825 --> 00:06:33.660 align:start position:32% line:-1
このようなループを―

00:06:35.028 --> 00:06:41.268 align:start position:27% line:-2
定期的に書くならメソッドに
抽出するのもいいでしょう

00:06:41.368 --> 00:06:47.140 align:start position:21% line:-2
バッファの拡張でユニットテストや
読み込みも楽になります

00:06:48.242 --> 00:06:52.012 align:start position:21% line:-1
しかしコンパイルの問題が起きます

00:06:52.412 --> 00:06:56.550 align:start position:32% line:-2
すべての要素型が
要約されないからです

00:06:57.518 --> 00:07:03.190 align:start position:25% line:-2
要素に必要なケイパビリティを
コンパイラに伝えないと―

00:06:57.518 --> 00:07:03.190 align:start position:25% line:-2
要素に必要なケイパビリティを
コンパイラに伝えないと―

00:07:03.290 --> 00:07:06.326 align:start position:29% line:-1
このメソッドが使えません

00:07:07.361 --> 00:07:14.201 align:start position:20% line:-2
簡単な方法は 要素型を
Intのような型に制約することです

00:07:16.803 --> 00:07:21.975 align:start position:25% line:-2
そのように拡張すれば
あとで汎用化するのも簡単です

00:07:22.075 --> 00:07:26.079 align:start position:18% line:-2
DoubleやFloatのバッファが
必要になれば―

00:07:26.847 --> 00:07:29.550 align:start position:29% line:-1
制約した型を見てください

00:07:29.983 --> 00:07:32.519 align:start position:30% line:-1
プロトコル準拠を見て―

00:07:32.619 --> 00:07:37.024 align:start position:29% line:-2
最も汎用的なプロトコルを
探してください

00:07:37.558 --> 00:07:43.430 align:start position:18% line:-2
ここでは Numericプロトコルで
ゼロ値の要素を作成し

00:07:44.064 --> 00:07:51.038 align:start position:27% line:-2
それに要素を追加するという
２つの機能が果たせます

00:07:53.574 --> 00:07:58.478 align:start position:29% line:-2
では プロトコル抽出の
プロセスについて話します

00:08:00.214 --> 00:08:04.952 align:start position:27% line:-2
バッファ型の汎用化について
お話ししましたが

00:08:05.052 --> 00:08:08.922 align:start position:32% line:-2
他の汎用的な
コードを書く場合は？

00:08:09.122 --> 00:08:12.059 align:start position:30% line:-2
あらゆるコレクションで
使えるコードは？

00:08:13.060 --> 00:08:16.463 align:start position:23% line:-1
例えば バッファに似た配列型や

00:08:16.830 --> 00:08:21.935 align:start position:32% line:-2
対のキー値からなる
ディクショナリ型です

00:08:23.136 --> 00:08:30.043 align:start position:21% line:-2
また 汎用的でない
データ型や文字列型などもあります

00:08:31.812 --> 00:08:36.416 align:start position:23% line:-2
これらに共通のケイパビリティを
キャプチャする―

00:08:37.049 --> 00:08:42.489 align:start position:29% line:-2
コレクションプロトコルの
簡易版を作成しましょう

00:08:45.025 --> 00:08:50.130 align:start position:27% line:-2
まず これらの具体的な型を
見てきました

00:08:50.230 --> 00:08:54.268 align:start position:27% line:-2
今から これらを１つにする
プロトコルを考えます

00:08:54.701 --> 00:08:57.204 align:start position:32% line:-1
この考え方は重要です

00:08:57.304 --> 00:09:02.142 align:start position:30% line:-2
具体的な型を考えてから
プロトコルで統一します

00:08:57.304 --> 00:09:02.142 align:start position:30% line:-2
具体的な型を考えてから
プロトコルで統一します

00:09:03.243 --> 00:09:06.847 align:start position:25% line:-1
これらの型に共通することは？

00:09:07.681 --> 00:09:12.152 align:start position:34% line:-2
プロトコル設計は
いわば契約交渉です

00:09:13.253 --> 00:09:17.457 align:start position:27% line:-2
準拠型と
柔軟性を重視する型との間で

00:09:17.691 --> 00:09:21.728 align:start position:36% line:-2
自然と駆け引きが
生まれるからです

00:09:22.563 --> 00:09:24.398 align:start position:32% line:-1
プロトコルのユーザは

00:09:24.498 --> 00:09:29.670 align:start position:23% line:-2
拡張のために
シンプルなプロトコルを望みます

00:09:30.737 --> 00:09:35.676 align:start position:27% line:-2
ですから プロトコル設計で
重要なのは―

00:09:35.809 --> 00:09:40.013 align:start position:30% line:-2
あらゆる準拠型と
様々なユースケースです

00:09:40.180 --> 00:09:41.815 align:start position:36% line:-1
要はバランスです

00:09:44.218 --> 00:09:48.822 align:start position:23% line:-2
では コレクションプロトコルの
要素型からです

00:09:48.922 --> 00:09:52.025 align:start position:25% line:-1
これには関連型を使っています

00:09:52.860 --> 00:09:56.864 align:start position:34% line:-2
準拠型で必要な
正しい要素の設定は

00:09:57.297 --> 00:10:03.003 align:start position:16% line:-2
バッファや配列の場合
Swift 4.2では自動で行われます

00:09:57.297 --> 00:10:03.003 align:start position:16% line:-2
バッファや配列の場合
Swift 4.2では自動で行われます

00:10:03.170 --> 00:10:06.740 align:start position:34% line:-2
汎用パラメータも
要素としたからです

00:10:07.674 --> 00:10:14.615 align:start position:21% line:-2
汎用的な引数に 共通の規則に従う
意味ある命名をする利点です

00:10:15.649 --> 00:10:20.487 align:start position:25% line:-2
“T”などと適当に命名すると
別の提示が必要です

00:10:22.022 --> 00:10:24.758 align:start position:25% line:-1
他のデータ型には具体性が要り

00:10:24.858 --> 00:10:29.663 align:start position:25% line:-2
ディクショナリなら 要素型を
キーと値のペアにします

00:10:32.032 --> 00:10:35.002 align:start position:32% line:-2
次はサブスクリプトの
追加についてです

00:10:35.769 --> 00:10:39.173 align:start position:30% line:-2
もし配列型のような型の
プロトコルなら―

00:10:39.273 --> 00:10:43.544 align:start position:27% line:-2
サブスクリプトの引数に
Intを望むかもしれません

00:10:45.212 --> 00:10:50.017 align:start position:30% line:-2
しかし Intを取れば
強い関係が生じます

00:10:50.851 --> 00:10:57.791 align:start position:21% line:-2
準拠型は 整数の表すポジションを
フェッチしなければなりません

00:10:58.392 --> 00:11:01.094 align:start position:27% line:-1
配列型などにはうまくいき―

00:10:58.392 --> 00:11:01.094 align:start position:27% line:-1
配列型などにはうまくいき―

00:11:01.495 --> 00:11:05.499 align:start position:32% line:-2
プロトコルユーザにも
理解が簡単です

00:11:06.066 --> 00:11:09.903 align:start position:27% line:-2
でも やや複雑な
ディクショナリについては？

00:11:11.705 --> 00:11:18.479 align:start position:23% line:-2
ディクショナリは 大抵
次の要素を見るロジックを含む―

00:11:18.579 --> 00:11:22.216 align:start position:23% line:-1
複雑な内部データ構造を含みます

00:11:22.783 --> 00:11:26.520 align:start position:21% line:-1
例えば 何らかの内部バッファです

00:11:26.620 --> 00:11:31.792 align:start position:27% line:-2
オフセットを格納した
インデックス型を使用したり

00:11:31.892 --> 00:11:37.731 align:start position:21% line:-2
サブスクリプト引数を取り
要素をフェッチしたりするものです

00:11:38.398 --> 00:11:42.236 align:start position:29% line:-2
しかし ディクショナリの
インデックス型は―

00:11:42.336 --> 00:11:44.638 align:start position:27% line:-1
不透明型でないといけません

00:11:45.105 --> 00:11:50.878 align:start position:30% line:-2
オフセットに１を足すと
すぐ次の要素にではなく

00:11:50.978 --> 00:11:56.049 align:start position:27% line:-2
非初期化部分へ
移動してしまっては困ります

00:11:56.984 --> 00:11:59.419 align:start position:30% line:-1
インデックスどおりに―

00:12:00.020 --> 00:12:03.657 align:start position:27% line:-1
コントロールされるべきです

00:12:04.158 --> 00:12:06.326 align:start position:27% line:-1
それには メソッドを追加し

00:12:06.860 --> 00:12:11.198 align:start position:30% line:-2
次のポジションを示す
インデックスを与えます

00:12:12.366 --> 00:12:14.168 align:start position:36% line:-1
次のステップは―

00:12:14.268 --> 00:12:18.038 align:start position:27% line:-2
開始及び終了インデックスの
プロパティです

00:12:18.138 --> 00:12:22.276 align:start position:29% line:-2
カウントだけでは
終了が分からないからです

00:12:22.576 --> 00:12:25.212 align:start position:30% line:-1
Intは使わないので―

00:12:26.547 --> 00:12:28.849 align:start position:29% line:-2
コレクションプロトコルに
戻しましょう

00:12:30.083 --> 00:12:35.389 align:start position:25% line:-2
これは インデックス型を取る
サブスクリプトと―

00:12:35.489 --> 00:12:38.325 align:start position:27% line:-1
ポジションを進める方法です

00:12:38.959 --> 00:12:43.597 align:start position:30% line:-2
インデックス用の型を
提供する型も必要ですが

00:12:43.697 --> 00:12:46.266 align:start position:32% line:-1
別の関連型を使います

00:12:47.768 --> 00:12:49.837 align:start position:34% line:-1
準拠型は適切なので

00:12:49.937 --> 00:12:54.875 align:start position:21% line:-2
配列やデータは
インデックス型にIntを与えます

00:12:55.108 --> 00:13:00.147 align:start position:30% line:-2
一方 ディクショナリは
カスタム実装を与えます

00:12:55.108 --> 00:13:00.147 align:start position:30% line:-2
一方 ディクショナリは
カスタム実装を与えます

00:13:04.251 --> 00:13:09.356 align:start position:21% line:-2
では インデックスの汎用化のため
カウントに戻りましょう

00:13:09.456 --> 00:13:16.230 align:start position:21% line:-2
この便利なプロパティを
コレクションの拡張として戻します

00:13:16.630 --> 00:13:21.034 align:start position:30% line:-2
コレクションをまたいで
インデックスを進め―

00:13:21.134 --> 00:13:24.104 align:start position:21% line:-1
カウンタをインクリメントさせます

00:13:26.440 --> 00:13:29.776 align:start position:30% line:-2
でもこの実装に
足りない要件があります

00:13:30.577 --> 00:13:33.213 align:start position:29% line:-1
Intを移動させたので―

00:13:33.313 --> 00:13:36.950 align:start position:21% line:-2
インデックス型はもう
Equatableではありません

00:13:37.417 --> 00:13:44.324 align:start position:21% line:-2
しかし終了に達したことを知るには
Equatableが必要です

00:13:45.492 --> 00:13:49.129 align:start position:34% line:-2
これを解決するには
前と同じく―

00:13:49.229 --> 00:13:53.834 align:start position:16% line:-2
Equatableの時だけ適用するよう
拡張を制約します

00:13:54.635 --> 00:13:56.336 align:start position:32% line:-1
でもしっくりきません

00:13:57.538 --> 00:14:00.440 align:start position:21% line:-1
使いやすいプロトコルが欲しいのに

00:13:57.538 --> 00:14:00.440 align:start position:21% line:-1
使いやすいプロトコルが欲しいのに

00:14:00.541 --> 00:14:04.945 align:start position:29% line:-2
拡張を書く度に
制約を入れるのは面倒です

00:14:05.712 --> 00:14:09.716 align:start position:30% line:-2
インデックス比較が
常に必要になるからです

00:14:10.184 --> 00:14:14.555 align:start position:25% line:-2
プロトコル要件として表す方が
いいでしょう

00:14:16.023 --> 00:14:19.426 align:start position:32% line:-2
インデックス関連型の
制約としてです

00:14:20.294 --> 00:14:21.995 align:start position:32% line:-1
プロトコル制約を行い

00:14:22.095 --> 00:14:27.334 align:start position:20% line:-2
プロトコル準拠の型すべてに
Equatable型を提供させます

00:14:28.502 --> 00:14:32.406 align:start position:32% line:-2
これで拡張の度に
特定しなくて済みます

00:14:34.575 --> 00:14:37.778 align:start position:32% line:-2
これもプロトコルとの
取り決めの例です

00:14:38.712 --> 00:14:44.284 align:start position:25% line:-2
プロトコルユーザには
インデックス比較の必要があり

00:14:44.718 --> 00:14:49.957 align:start position:25% line:-2
準拠型は 柔軟性を多く失わず
対応できるかでした

00:14:50.991 --> 00:14:52.893 align:start position:34% line:-1
どちらもかないます

00:14:53.427 --> 00:14:56.497 align:start position:27% line:-2
Intやデータ 配列は
既にEquatableです

00:14:56.597 --> 00:15:00.501 align:start position:20% line:-2
Swift 4.2の新しい
Equatable準拠自動合成で―

00:14:56.597 --> 00:15:00.501 align:start position:20% line:-2
Swift 4.2の新しい
Equatable準拠自動合成で―

00:15:01.235 --> 00:15:04.271 align:start position:25% line:-2
インデックス型を
Equatableにできます

00:15:07.241 --> 00:15:12.646 align:start position:27% line:-2
次はカスタムポイントを含む
カウントの最適化です

00:15:14.381 --> 00:15:17.251 align:start position:23% line:-1
今書いたカウントのバージョンは

00:15:17.351 --> 00:15:22.189 align:start position:29% line:-2
全コレクションをまたいで
要素数を計算します

00:15:22.289 --> 00:15:26.126 align:start position:25% line:-2
しかし 多くのコレクションは
もっと速くできます

00:15:26.593 --> 00:15:32.866 align:start position:21% line:-2
例えば ディクショナリが
要素数のカウントを保持していれば

00:15:33.400 --> 00:15:37.838 align:start position:32% line:-2
自身のカウント実装に
使うことができます

00:15:38.572 --> 00:15:44.011 align:start position:27% line:-2
ディクショナリのカウントを
呼び出すと得られるのは

00:15:44.111 --> 00:15:48.549 align:start position:32% line:-2
元の線形時間ではなく
速い定数時間です

00:15:49.817 --> 00:15:53.921 align:start position:32% line:-2
ただ 最適化の追加に
留意点があります

00:15:54.021 --> 00:16:00.427 align:start position:25% line:-2
プロトコル要件の実行と
オーバーロード追加の違いです

00:15:54.021 --> 00:16:00.427 align:start position:25% line:-2
プロトコル要件の実行と
オーバーロード追加の違いです

00:16:01.028 --> 00:16:06.099 align:start position:23% line:-2
今のところ この新バージョンは
単にオーバーロードです

00:16:06.567 --> 00:16:12.873 align:start position:25% line:-2
つまり ディクショナリには
改良されたカウントがあります

00:16:13.440 --> 00:16:16.276 align:start position:27% line:-2
では 汎用アルゴリズム内の
呼び出しは？

00:16:18.512 --> 00:16:22.883 align:start position:29% line:-2
例えば 標準ライブラリの
マップを書くとします

00:16:23.016 --> 00:16:26.487 align:start position:32% line:-2
ご存じない場合
これはとても便利です

00:16:26.587 --> 00:16:31.892 align:start position:23% line:-2
要素を変形して
新しい配列に戻してくれるのです

00:16:33.160 --> 00:16:34.828 align:start position:34% line:-1
実装はシンプルです

00:16:34.928 --> 00:16:38.799 align:start position:32% line:-2
新しい配列を作成して
コレクションに動かし

00:16:38.932 --> 00:16:41.935 align:start position:25% line:-1
要素を変形して配列に加えます

00:16:42.970 --> 00:16:48.175 align:start position:25% line:-2
要素を配列に加える際
配列は自動的に大きくなります

00:16:48.542 --> 00:16:49.810 align:start position:39% line:-1
それに伴い―

00:16:49.910 --> 00:16:55.883 align:start position:29% line:-2
内部メモリの再割り当てが
必要になる場合もあります

00:16:56.450 --> 00:17:00.954 align:start position:27% line:-2
大きくなる度合いによっては
数回必要になり―

00:16:56.450 --> 00:17:00.954 align:start position:27% line:-2
大きくなる度合いによっては
数回必要になり―

00:17:01.421 --> 00:17:02.890 align:start position:36% line:-1
時間もかかります

00:17:02.990 --> 00:17:05.659 align:start position:23% line:-1
メモリの割り当ては負担ですが―

00:17:06.693 --> 00:17:10.130 align:start position:25% line:-1
ここで最適化のコツがあります

00:17:10.531 --> 00:17:14.334 align:start position:29% line:-1
最終的な配列の大きさは―

00:17:14.434 --> 00:17:17.804 align:start position:30% line:-2
元のコレクションと
まったく同じサイズです

00:17:18.605 --> 00:17:23.443 align:start position:30% line:-2
配列に加える前に
その分を取っておけば―

00:17:23.544 --> 00:17:27.181 align:start position:29% line:-1
スピードアップを図れます

00:17:27.513 --> 00:17:29.950 align:start position:32% line:-2
これには カウントを
呼び出します

00:17:30.951 --> 00:17:35.689 align:start position:30% line:-2
ここでは 汎用的な
コンテキストとしてです

00:17:35.789 --> 00:17:40.661 align:start position:29% line:-2
つまり コレクション型は
完全に汎用的なので―

00:17:40.761 --> 00:17:44.064 align:start position:32% line:-2
配列やディクショナリ
何でもあり得ます

00:17:44.631 --> 00:17:48.869 align:start position:27% line:-2
コードをコンパイルする際の
カウントが―

00:17:48.969 --> 00:17:52.372 align:start position:25% line:-1
より良いものかは分かりません

00:17:52.906 --> 00:17:59.112 align:start position:27% line:-2
この場合 呼び出されるのは
汎用バージョンで

00:17:59.213 --> 00:18:03.116 align:start position:21% line:-1
全コレクションに働き 反復します

00:17:59.213 --> 00:18:03.116 align:start position:21% line:-1
全コレクションに働き 反復します

00:18:03.584 --> 00:18:05.619 align:start position:32% line:-2
ディクショナリで
マップを呼び出しても

00:18:05.719 --> 00:18:08.989 align:start position:25% line:-1
良いバージョンではありません

00:18:11.058 --> 00:18:13.994 align:start position:30% line:-2
カスタマイズされた
メソッドやプロパティを

00:18:14.094 --> 00:18:18.398 align:start position:30% line:-2
汎用的なコンテキストで
呼び出すには―

00:18:18.565 --> 00:18:22.269 align:start position:32% line:-2
プロトコル要件として
宣言すればいいのです

00:18:23.470 --> 00:18:24.538 align:start position:36% line:-1
コレクションは―

00:18:24.638 --> 00:18:29.409 align:start position:34% line:-2
最適なカウントを
提供できるわけです

00:18:29.510 --> 00:18:33.447 align:start position:30% line:-2
プロトコル要件として
追加することも納得です

00:18:34.348 --> 00:18:38.385 align:start position:23% line:-1
ただ たとえそれを要件にしても

00:18:39.753 --> 00:18:42.756 align:start position:27% line:-1
各コレクションでは不要です

00:18:42.856 --> 00:18:47.127 align:start position:29% line:-2
拡張を通して
既に１つ提供したからです

00:18:48.629 --> 00:18:55.035 align:start position:21% line:-2
プロトコルに要件を加え
拡張を通しデフォルト実装すること

00:18:55.135 --> 00:18:58.372 align:start position:23% line:-1
これがカスタマイズポイントです

00:19:00.140 --> 00:19:05.412 align:start position:30% line:-2
メソッドやプロパティの
実装が良くなる可能性を

00:19:05.512 --> 00:19:07.214 align:start position:30% line:-1
コンパイラに知らせます

00:19:07.314 --> 00:19:09.650 align:start position:29% line:-1
それで汎用コンテキストで

00:19:09.750 --> 00:19:14.288 align:start position:30% line:-2
プロトコルを通して
動的に実装を行うのです

00:19:15.422 --> 00:19:18.192 align:start position:32% line:-2
今 ディクショナリで
マップを呼び出せば

00:19:18.292 --> 00:19:22.829 align:start position:27% line:-2
汎用的な機能でも
カウント実装が良くなります

00:19:24.498 --> 00:19:29.570 align:start position:21% line:-2
このようなカスタマイズポイントの
追加で―

00:19:30.270 --> 00:19:33.240 align:start position:27% line:-1
パワフルに恩恵が得られます

00:19:33.340 --> 00:19:37.945 align:start position:27% line:-2
クラスや実装継承
メソッドの上書きと同様です

00:19:38.278 --> 00:19:42.649 align:start position:21% line:-1
また 構造体や列挙型にも使えます

00:19:45.285 --> 00:19:48.655 align:start position:32% line:-2
ただ 最適化できない
メソッドもあります

00:19:49.122 --> 00:19:52.960 align:start position:30% line:-2
カスタマイズポイントは
バイナリサイズや―

00:19:53.060 --> 00:19:56.196 align:start position:36% line:-2
ランタイム動作に
少しは影響します

00:19:56.296 --> 00:19:59.032 align:start position:25% line:-2
ですから
カスタマイズポイントの追加は

00:19:59.132 --> 00:20:01.635 align:start position:27% line:-1
最適化が適する時に限ります

00:19:59.132 --> 00:20:01.635 align:start position:27% line:-1
最適化が適する時に限ります

00:20:02.503 --> 00:20:05.272 align:start position:25% line:-1
例えば 先程のマップ操作です

00:20:05.372 --> 00:20:11.778 align:start position:23% line:-2
あらゆるコレクションに
実装を良くできる方法がないので

00:20:11.945 --> 00:20:15.048 align:start position:30% line:-1
追加の意味はありません

00:20:15.149 --> 00:20:17.317 align:start position:32% line:-1
拡張のままで結構です

00:20:18.752 --> 00:20:23.357 align:start position:23% line:-2
さて 作成したコレクション型は
十分な機能を備え―

00:20:23.624 --> 00:20:28.095 align:start position:25% line:-2
多くの準拠型と
便利なアルゴリズムがあります

00:20:28.529 --> 00:20:33.901 align:start position:23% line:-2
しかし型の分類には
時に複数のプロトコルが必要です

00:20:34.535 --> 00:20:36.570 align:start position:34% line:-1
プロトコル継承です

00:20:36.904 --> 00:20:39.373 align:start position:30% line:-1
では ダグに代わります

00:20:40.340 --> 00:20:45.879 align:start position:43% line:-1
(拍手)

00:20:45.979 --> 00:20:47.114 align:start position:36% line:-1
ありがとう ベン

00:20:48.515 --> 00:20:51.685 align:start position:25% line:-2
プロトコル継承は
初期のSwiftからあります

00:20:52.252 --> 00:20:54.822 align:start position:25% line:-1
どこでプロトコル継承が必要か

00:20:54.922 --> 00:20:57.958 align:start position:25% line:-2
このコレクションプロトコルで
考えましょう

00:20:58.192 --> 00:21:02.863 align:start position:30% line:-2
良い設計のプロトコルで
一連の準拠型を記述し

00:20:58.192 --> 00:21:02.863 align:start position:30% line:-2
良い設計のプロトコルで
一連の準拠型を記述し

00:21:02.963 --> 00:21:06.567 align:start position:27% line:-2
興味深い汎用アルゴリズムが
書けます

00:21:06.667 --> 00:21:12.105 align:start position:23% line:-2
しかし コレクションプロトコル
として実装できない―

00:21:12.206 --> 00:21:14.908 align:start position:29% line:-1
アルゴリズムならあります

00:21:15.242 --> 00:21:20.614 align:start position:21% line:-2
例えば プレディケートに合致する
最後の要素を探すには

00:21:20.714 --> 00:21:24.785 align:start position:32% line:-2
後ろから前へ進むのが
最良の方法です

00:21:25.052 --> 00:21:26.987 align:start position:29% line:-2
コレクションプロトコルは
それを許しません

00:21:27.821 --> 00:21:32.693 align:start position:25% line:-2
また コレクション内の要素を
シャッフルしたくても

00:21:32.793 --> 00:21:35.562 align:start position:25% line:-2
変化が必要で
コレクションはそれをしません

00:21:35.662 --> 00:21:38.766 align:start position:29% line:-2
コレクションプロトコルが
悪いのでなく―

00:21:39.766 --> 00:21:44.471 align:start position:29% line:-2
汎用アルゴリズムの追加に
もっと何か必要なのです

00:21:44.571 --> 00:21:47.174 align:start position:29% line:-1
それがプロトコル継承です

00:21:47.274 --> 00:21:53.313 align:start position:2% line:-2
これは BidirectionalCollection
プロトコルです

00:21:53.614 --> 00:21:58.318 align:start position:34% line:-2
このプロトコルに
準拠する型はすべて

00:21:58.418 --> 00:22:01.755 align:start position:30% line:-2
コレクションにも準拠し
アルゴリズムを使えます

00:21:58.418 --> 00:22:01.755 align:start position:30% line:-2
コレクションにも準拠し
アルゴリズムを使えます

00:22:02.022 --> 00:22:08.195 align:start position:2% line:-2
しかしBidirectionalCollectionは
後退する要件を追加します

00:22:08.695 --> 00:22:13.801 align:start position:27% line:-2
ただ この要件を実装できる
コレクションは限られます

00:22:13.901 --> 00:22:20.007 align:start position:14% line:-2
例えばSinglyLinkedListは
次に飛ぶだけですよね

00:22:20.107 --> 00:22:22.776 align:start position:29% line:-1
後退は効率的ではないので

00:22:22.876 --> 00:22:25.679 align:start position:7% line:-2
BidirectionalCollectionは
あり得ません

00:22:25.779 --> 00:22:29.650 align:start position:34% line:-2
つまり継承の導入は
準拠型を制限します

00:22:30.117 --> 00:22:34.054 align:start position:27% line:-2
しかし より興味深い
アルゴリズムを実装できます

00:22:34.154 --> 00:22:39.092 align:start position:30% line:-2
最後のインデックス後の
コードはこうです

00:22:39.193 --> 00:22:44.965 align:start position:7% line:-2
BidirectionalCollectionの
新要件を使って後退させるだけです

00:22:46.500 --> 00:22:50.404 align:start position:27% line:-2
次は 更に興味深い
シャッフルアルゴリズムです

00:22:50.504 --> 00:22:55.008 align:start position:20% line:-2
Swift 4.2のコレクションに
導入されています

00:22:55.109 --> 00:22:59.079 align:start position:30% line:-2
このアルゴリズムを見て
導入された要件を確認し

00:22:59.179 --> 00:23:02.883 align:start position:29% line:-2
プロトコルを
意味のあるよう分類します

00:22:59.179 --> 00:23:02.883 align:start position:29% line:-2
プロトコルを
意味のあるよう分類します

00:23:03.317 --> 00:23:07.354 align:start position:21% line:-2
Fisher-Yatesは古くて
シンプルです

00:23:07.454 --> 00:23:11.024 align:start position:32% line:-2
最初の要素から
インデックスを開始し

00:23:11.492 --> 00:23:17.531 align:start position:23% line:-2
次に 別の要素をランダムに選び
この２つを入れ替えます

00:23:18.432 --> 00:23:22.970 align:start position:27% line:-2
次の反復で
左のインデックスを１つ進め

00:23:23.370 --> 00:23:26.740 align:start position:27% line:-1
また１つ選んで入れ替えます

00:23:26.840 --> 00:23:28.776 align:start position:34% line:-1
とてもシンプルです

00:23:28.876 --> 00:23:34.515 align:start position:27% line:-2
ランダムに選んだ別の要素を
入れ替えて進むだけです

00:23:34.615 --> 00:23:38.752 align:start position:34% line:-2
最終的に うまく
シャッフルされます

00:23:39.620 --> 00:23:43.457 align:start position:29% line:-2
コードは 少し複雑ですが
大丈夫です

00:23:43.557 --> 00:23:46.693 align:start position:32% line:-2
何かのコレクションに
実装してみましょう

00:23:46.793 --> 00:23:48.662 align:start position:32% line:-1
このコア演算が例です

00:23:48.762 --> 00:23:51.198 align:start position:29% line:-1
最初に コレクションの―

00:23:51.298 --> 00:23:56.270 align:start position:30% line:-2
今の位置から最後までで
ランダムな数を選びます

00:23:56.370 --> 00:24:00.340 align:start position:27% line:-2
でもこれは整数で
必要なのはインデックスです

00:23:56.370 --> 00:24:00.340 align:start position:27% line:-2
でもこれは整数で
必要なのはインデックスです

00:24:00.440 --> 00:24:04.311 align:start position:14% line:-1
そこでoffsetByインデックスを使い

00:24:04.411 --> 00:24:09.149 align:start position:25% line:-2
開始インデックスから
選んだ位置までジャンプします

00:24:09.983 --> 00:24:14.154 align:start position:29% line:-2
次に必要な操作は
２つの要素の入れ替えです

00:24:14.822 --> 00:24:20.494 align:start position:30% line:-2
シャッフル実装に必要な
２つの操作があるので―

00:24:20.594 --> 00:24:24.031 align:start position:14% line:-2
新しいShuffleCollection
プロトコルです

00:24:26.600 --> 00:24:27.868 align:start position:34% line:-1
でもやめてください

00:24:27.968 --> 00:24:30.237 align:start position:34% line:-1
アンチパターンです

00:24:30.571 --> 00:24:33.073 align:start position:25% line:-1
あるのはアルゴリズム１つです

00:24:33.173 --> 00:24:36.844 align:start position:27% line:-2
要件を見つけ
プロトコルに包括しましたが

00:24:36.944 --> 00:24:40.914 align:start position:21% line:-1
記述したのはアルゴリズム１つです

00:24:41.014 --> 00:24:44.885 align:start position:30% line:-2
これを行えば
プロトコルが山ほどでき

00:24:44.985 --> 00:24:48.789 align:start position:29% line:-2
そこには大した意味もなく
何も学べません

00:24:49.022 --> 00:24:54.228 align:start position:29% line:-2
ここで気付くべきは
明瞭なケイパビリティです

00:24:54.328 --> 00:24:57.765 align:start position:27% line:-1
ランダムアクセスと変化は―

00:24:57.865 --> 00:25:01.735 align:start position:23% line:-1
別々のプロトコルに分類できます

00:24:57.865 --> 00:25:01.735 align:start position:23% line:-1
別々のプロトコルに分類できます

00:25:01.935 --> 00:25:04.805 align:start position:11% line:-2
RandomAccessCollection
プロトコルは―

00:25:04.905 --> 00:25:10.077 align:start position:27% line:-2
素早くインデックスを動かし
ジャンプを可能にします

00:25:10.377 --> 00:25:14.147 align:start position:11% line:-2
またUnsafeBufferPointerは
ランダムアクセスを可能にしても

00:25:14.248 --> 00:25:16.583 align:start position:36% line:-1
変化はさせません

00:25:16.683 --> 00:25:18.418 align:start position:25% line:-1
それは別のケイパビリティです

00:25:18.919 --> 00:25:21.855 align:start position:14% line:-2
ここにMutableCollection
プロトコルもあります

00:25:22.289 --> 00:25:28.161 align:start position:21% line:-2
変化は可能ですが
ランダムアクセスは不可能な型です

00:25:28.495 --> 00:25:32.299 align:start position:23% line:-1
さて 継承階層が分割されますね

00:25:33.133 --> 00:25:36.403 align:start position:12% line:-1
RandomAccessなどのアクセス側と

00:25:36.503 --> 00:25:38.539 align:start position:39% line:-1
変化の側です

00:25:38.639 --> 00:25:45.279 align:start position:21% line:-2
クライアントは複数のプロトコルを
実装できるので問題ありません

00:25:45.579 --> 00:25:48.982 align:start position:23% line:-2
シャッフルアルゴリズムに戻ると
これは―

00:25:49.249 --> 00:25:52.586 align:start position:2% line:-2
自分型でRandomAccessCollectionの
拡張として書けます

00:25:52.686 --> 00:25:58.525 align:start position:2% line:-2
この型はRandomAccessCollectionと
MutableCollectionにも準拠します

00:25:58.625 --> 00:26:01.195 align:start position:27% line:-2
この両方のケイパビリティを
合わせました

00:25:58.625 --> 00:26:01.195 align:start position:27% line:-2
この両方のケイパビリティを
合わせました

00:26:02.396 --> 00:26:07.201 align:start position:27% line:-2
準拠型と汎用アルゴリズムが
複数ずつある場合―

00:26:07.301 --> 00:26:10.537 align:start position:23% line:-1
プロトコル階層を成形しがちです

00:26:10.637 --> 00:26:15.309 align:start position:29% line:-2
これらの階層は大きすぎず
細かすぎないことです

00:26:15.876 --> 00:26:21.782 align:start position:21% line:-2
要るのはドメイン内の型を記述する
少数のプロトコルです

00:26:22.616 --> 00:26:26.420 align:start position:25% line:-1
プロトコル階層のビルドでは―

00:26:26.520 --> 00:26:32.125 align:start position:21% line:-2
上に行くにつれプロトコルの要件が
少なくなります

00:26:32.226 --> 00:26:36.930 align:start position:29% line:-2
それで 要件を実装できる
準拠型が増えます

00:26:37.464 --> 00:26:43.403 align:start position:25% line:-2
一方で 階層を下りながら
様々なプロトコルを結合すると

00:26:43.537 --> 00:26:46.607 align:start position:29% line:-2
より複雑なアルゴリズムが
実装できます

00:26:46.707 --> 00:26:51.178 align:start position:25% line:-2
高いケイパビリティが要り
対応する準拠型は減りますがね

00:26:55.549 --> 00:27:00.020 align:start position:29% line:-2
では Swiftの新機能
条件付き準拠に進みます

00:26:55.549 --> 00:27:00.020 align:start position:29% line:-2
では Swiftの新機能
条件付き準拠に進みます

00:27:00.554 --> 00:27:03.290 align:start position:30% line:-1
Sliceから始めます

00:27:03.423 --> 00:27:07.995 align:start position:27% line:-2
一連のインデックスに
サブスクリプトを定義すれば

00:27:08.095 --> 00:27:13.133 align:start position:29% line:-2
コレクションに
Sliceを形成できます

00:27:13.233 --> 00:27:17.171 align:start position:27% line:-2
Sliceは本質的に
コレクションの部分表示です

00:27:17.905 --> 00:27:22.042 align:start position:27% line:-2
これらはコレクションを
スライスしたデフォルト型で

00:27:22.142 --> 00:27:24.077 align:start position:30% line:-1
Sliceと呼ばれます

00:27:24.411 --> 00:27:26.713 align:start position:27% line:-2
Sliceは
ジェネリックアダプタ型です

00:27:27.281 --> 00:27:31.118 align:start position:32% line:-2
基本コレクション型で
パラメータ化でき―

00:27:31.485 --> 00:27:33.587 align:start position:27% line:-1
それ自体がコレクションです

00:27:33.887 --> 00:27:39.993 align:start position:21% line:-2
土台のコレクションにできることが
Sliceにもできると―

00:27:40.094 --> 00:27:41.628 align:start position:38% line:-1
予想しますよね

00:27:41.895 --> 00:27:48.335 align:start position:18% line:-2
“(where:”などで順方向検索し
プレディケートやコレクションに

00:27:48.435 --> 00:27:51.038 align:start position:29% line:-1
対応するものを見つけます

00:27:51.472 --> 00:27:55.709 align:start position:30% line:-2
しかし 逆方向検索では
問題に遭遇します

00:27:55.809 --> 00:27:58.846 align:start position:5% line:-2
バッファが
BidirectionalCollectionでも

00:27:59.379 --> 00:28:02.416 align:start position:21% line:-1
Sliceもそうだとは限りません

00:27:59.379 --> 00:28:02.416 align:start position:21% line:-1
Sliceもそうだとは限りません

00:28:04.651 --> 00:28:05.752 align:start position:38% line:-1
問題ありません

00:28:05.853 --> 00:28:09.957 align:start position:30% line:-2
Sliceを拡張し
それに準拠させましょう

00:28:10.457 --> 00:28:16.530 align:start position:21% line:-2
演算の前に 土台となる
基本コレクションに実装できますが

00:28:17.097 --> 00:28:19.066 align:start position:29% line:-1
コンパイラが承知しません

00:28:19.633 --> 00:28:23.537 align:start position:29% line:-2
基本コレクションは
コレクションというだけで

00:28:23.637 --> 00:28:26.640 align:start position:29% line:-2
演算の前のインデックスは
ありません

00:28:27.775 --> 00:28:29.309 align:start position:39% line:-1
修正できます

00:28:29.409 --> 00:28:31.645 align:start position:34% line:-1
要件を拡張に導入し

00:28:31.745 --> 00:28:35.382 align:start position:7% line:-2
BidirectionalCollectionが
基本型でなければと伝えます

00:28:35.749 --> 00:28:37.451 align:start position:29% line:-1
これが 条件付き準拠です

00:28:38.051 --> 00:28:42.589 align:start position:32% line:-2
プロトコルへの準拠を
宣言する拡張と―

00:28:42.689 --> 00:28:46.393 align:start position:25% line:-1
その準拠が妥当である制約です

00:28:47.027 --> 00:28:51.665 align:start position:23% line:-2
条件付き準拠はプロトコル階層に
うまく重ねられます

00:28:51.765 --> 00:28:55.903 align:start position:7% line:-2
土台の基本型が
RandomAccessCollectionなら

00:28:56.003 --> 00:28:59.640 align:start position:0% line:-2
SliceもRandomAccessCollectionと
表現できるのです

00:29:00.407 --> 00:29:03.177 align:start position:30% line:-1
今書いた２つの拡張は―

00:29:03.710 --> 00:29:05.879 align:start position:25% line:-1
良いSwiftのスタイルです

00:29:05.979 --> 00:29:11.251 align:start position:23% line:-2
拡張してプロトコル準拠させれば
その意味が分かります

00:29:11.351 --> 00:29:16.123 align:start position:27% line:-2
これは条件付き準拠にとって
特に重要です

00:29:16.223 --> 00:29:19.960 align:start position:23% line:-1
拡張に様々な要件があるからです

00:29:21.261 --> 00:29:22.729 align:start position:36% line:-1
構成の幅も広がり

00:29:22.830 --> 00:29:27.668 align:start position:18% line:-2
Slice型は土台の基本コレクション
と同じことができます

00:29:30.470 --> 00:29:35.342 align:start position:25% line:-2
次は 条件付き準拠の
別のアプリケーションについて

00:29:35.442 --> 00:29:37.478 align:start position:23% line:-1
RangeはSwiftの常連で

00:29:37.578 --> 00:29:41.181 align:start position:30% line:-2
例えば“..<”演算で
範囲を形成します

00:29:41.348 --> 00:29:45.752 align:start position:32% line:-2
ダブルや整数の範囲も
形成できます

00:29:45.853 --> 00:29:48.222 align:start position:25% line:-1
もっとパワフルなRangeは

00:29:48.322 --> 00:29:52.593 align:start position:34% line:-2
整数の範囲内の
要素に反復できます

00:29:52.960 --> 00:29:57.130 align:start position:21% line:-2
intRangeはコレクションに
準拠するからです

00:29:58.198 --> 00:30:02.135 align:start position:23% line:-1
“..<”演算子で作られた型は

00:29:58.198 --> 00:30:02.135 align:start position:23% line:-1
“..<”演算子で作られた型は

00:30:02.236 --> 00:30:05.005 align:start position:23% line:-1
Range型と命名されています

00:30:05.239 --> 00:30:07.941 align:start position:27% line:-1
土台のバウンド型に汎用的で

00:30:08.041 --> 00:30:12.513 align:start position:25% line:-2
ダブルのRangeに
上限と下限だけ格納しています

00:30:12.613 --> 00:30:13.847 align:start position:39% line:-1
シンプルです

00:30:14.214 --> 00:30:16.150 align:start position:25% line:-1
Swift 4.2より前は―

00:30:16.583 --> 00:30:20.254 align:start position:23% line:-2
IntegerRangeという
違う型から得ていました

00:30:20.354 --> 00:30:22.523 align:start position:20% line:-1
CountableRange型です

00:30:23.056 --> 00:30:25.959 align:start position:23% line:-1
構造的にはRange型と同じで

00:30:26.059 --> 00:30:29.096 align:start position:25% line:-2
型パラメータ１つと
上限下限のバウンドがあります

00:30:29.296 --> 00:30:33.066 align:start position:27% line:-2
しかしこれは バウンド型に
要件を追加します

00:30:33.167 --> 00:30:37.671 align:start position:21% line:-2
バウンドがStrideableで
全要素を列挙する要件です

00:30:37.771 --> 00:30:42.810 align:start position:9% line:-2
RandomAccessCollectionに
CountableRangeを準拠させ―

00:30:43.744 --> 00:30:47.114 align:start position:23% line:-1
反復ループを可能にさせるのです

00:30:47.981 --> 00:30:51.084 align:start position:32% line:-2
条件付き準拠なら
もっとうまくいきます

00:30:51.418 --> 00:30:56.457 align:start position:25% line:-2
では 基本的なRange型を
コレクションに変えます

00:30:56.823 --> 00:31:01.195 align:start position:18% line:-2
バウンド型には
Strideableの要件があります

00:30:56.823 --> 00:31:01.195 align:start position:18% line:-2
バウンド型には
Strideableの要件があります

00:31:01.662 --> 00:31:03.964 align:start position:27% line:-1
シンプルな準拠の適用ですが

00:31:04.064 --> 00:31:09.603 align:start position:25% line:-2
良い型パラメータと合わせると
パワフルになります

00:31:10.737 --> 00:31:15.209 align:start position:5% line:-2
今 RandomAccessCollectionに
準拠しようとしていますが

00:31:15.375 --> 00:31:19.646 align:start position:5% line:-2
BidirectionalCollectionにも
コレクションにも触れていません

00:31:20.247 --> 00:31:22.616 align:start position:25% line:-1
無条件準拠ならこれでOKです

00:31:22.950 --> 00:31:25.619 align:start position:7% line:-2
RandomAccessCollectionへの
準拠の宣言は―

00:31:25.719 --> 00:31:29.423 align:start position:21% line:-2
それが継承する
全プロトコルへの準拠を暗示します

00:31:29.523 --> 00:31:32.292 align:start position:5% line:-2
この場合 コレクションと
BidirectionalCollectionです

00:31:32.659 --> 00:31:35.929 align:start position:23% line:-1
でも条件付き準拠ならエラーです

00:31:36.530 --> 00:31:38.499 align:start position:27% line:-1
Sliceの例を思い出せば

00:31:38.599 --> 00:31:44.605 align:start position:30% line:-2
様々な階層に対して
異なる制約が必要でした

00:31:44.705 --> 00:31:47.508 align:start position:27% line:-1
各コレクションに対してです

00:31:47.674 --> 00:31:49.643 align:start position:32% line:-1
それでコンパイラは―

00:31:49.743 --> 00:31:55.115 align:start position:29% line:-2
条件付き準拠に合う制約を
強制しているのです

00:31:55.816 --> 00:31:59.453 align:start position:30% line:-2
今回は 全階層にわたり
同じ制約です

00:31:59.553 --> 00:32:03.090 align:start position:4% line:-2
明示的に コレクションと
BidirectionalCollectionと書け

00:31:59.553 --> 00:32:03.090 align:start position:4% line:-2
明示的に コレクションと
BidirectionalCollectionと書け

00:32:03.290 --> 00:32:06.326 align:start position:32% line:-2
ここに全準拠があると
アサートできます

00:32:06.427 --> 00:32:10.898 align:start position:29% line:-2
または文体を考慮し
異なる準拠を分けられます

00:32:12.399 --> 00:32:17.137 align:start position:16% line:-2
今 Range型はパワフルで
CountableRangeと同等です

00:32:17.237 --> 00:32:20.374 align:start position:23% line:-2
CountableRangeは
消せますが―

00:32:20.607 --> 00:32:25.846 align:start position:18% line:-2
実際 CountableRangeを
使うコードは多いです

00:32:25.946 --> 00:32:29.850 align:start position:29% line:-2
汎用的型エイリアスとして
残しましょう

00:32:30.918 --> 00:32:32.319 align:start position:39% line:-1
良い解決です

00:32:32.419 --> 00:32:37.858 align:start position:23% line:-2
これで 要件を加え
Rangeを可算可能にできます

00:32:37.958 --> 00:32:41.828 align:start position:30% line:-2
コレクションへの変更に
必要な要件ですが

00:32:41.929 --> 00:32:45.099 align:start position:21% line:-1
単に土台のRange型の別名です

00:32:46.733 --> 00:32:50.904 align:start position:27% line:-2
繰り返しますが
ソース互換性に良い解決です

00:32:51.004 --> 00:32:55.475 align:start position:5% line:-2
RandomAccessCollectionとして
追加機能を持つRangeに

00:32:55.576 --> 00:32:59.546 align:start position:25% line:-1
命名することも 良いことです

00:32:59.813 --> 00:33:02.883 align:start position:29% line:-2
実際 他コードの
クリーンアップに使えます

00:32:59.813 --> 00:33:02.883 align:start position:29% line:-2
実際 他コードの
クリーンアップに使えます

00:33:02.983 --> 00:33:04.685 align:start position:23% line:-1
CountableRangeは

00:33:04.785 --> 00:33:10.691 align:start position:25% line:-2
Stride機能を持つ
Rangeなので拡張できます

00:33:10.791 --> 00:33:15.262 align:start position:9% line:-2
RandomAccessCollectionに
準拠の場合です

00:33:16.363 --> 00:33:20.968 align:start position:21% line:-2
Swift 4.2に導入したのは
扱う型をシンプルにし―

00:33:21.068 --> 00:33:25.672 align:start position:27% line:-2
既存のコア型の構成可能性と
柔軟性を高めるためです

00:33:27.641 --> 00:33:33.080 align:start position:29% line:-2
再帰的制約はプロトコルと
関連型の関係を記述します

00:33:33.247 --> 00:33:37.217 align:start position:21% line:-1
WWDCでは取り上げていませんが

00:33:37.451 --> 00:33:41.989 align:start position:27% line:-2
Swiftのジェネリクスで
重要な部分です

00:33:42.122 --> 00:33:43.290 align:start position:38% line:-1
見てみましょう

00:33:44.057 --> 00:33:50.664 align:start position:21% line:-2
再帰的制約は同じプロトコルを示す
プロトコル内の制約です

00:33:50.964 --> 00:33:57.438 align:start position:14% line:-2
このSubSequenceという関連型は
これ自体コレクションですが

00:33:57.638 --> 00:33:59.106 align:start position:39% line:-1
なぜ必要か？

00:33:59.239 --> 00:34:02.810 align:start position:21% line:-1
汎用アルゴリズムを見てみましょう

00:33:59.239 --> 00:34:02.810 align:start position:21% line:-1
汎用アルゴリズムを見てみましょう

00:34:03.644 --> 00:34:06.213 align:start position:25% line:-1
コレクションはソート済みです

00:34:06.313 --> 00:34:12.119 align:start position:29% line:-2
ここに新しい値を挿入する
インデックスを探します

00:34:12.351 --> 00:34:15.922 align:start position:5% line:-2
値“11”の
sortedInsertionPointを探します

00:34:16.255 --> 00:34:21.762 align:start position:25% line:-2
ここに“11”を挿入しても
ソート済み配列はそのままです

00:34:21.929 --> 00:34:27.134 align:start position:27% line:-2
これは 二分探索の観点から
実装される機能です

00:34:27.434 --> 00:34:30.871 align:start position:29% line:-2
二分探索は
分割統治アルゴリズムで―

00:34:30.971 --> 00:34:37.110 align:start position:27% line:-2
各段階で 問題サイズを
大幅に減らす決定を行います

00:34:37.210 --> 00:34:39.146 align:start position:36% line:-1
次のステップです

00:34:39.413 --> 00:34:43.516 align:start position:29% line:-2
二分探索のために
まず中央要素“８”を見て

00:34:43.750 --> 00:34:46.887 align:start position:21% line:-1
挿入したい値“11”と比較します

00:34:47.187 --> 00:34:49.422 align:start position:25% line:-1
“11”は“８”より上なので

00:34:49.523 --> 00:34:55.429 align:start position:25% line:-2
“８”の後ろのコレクションに
挿入すると分かります

00:34:55.529 --> 00:34:58.065 align:start position:29% line:-1
探索範囲が二分されました

00:34:58.999 --> 00:35:04.571 align:start position:23% line:-2
さらに後半の中央要素“14”と
“11”と比較します

00:34:58.999 --> 00:35:04.571 align:start position:23% line:-2
さらに後半の中央要素“14”と
“11”と比較します

00:35:05.072 --> 00:35:11.044 align:start position:23% line:-2
“11”は“14”より下なので
挿入位置は中央より前です

00:35:11.145 --> 00:35:14.014 align:start position:27% line:-1
これで残りも二分されました

00:35:14.481 --> 00:35:21.288 align:start position:25% line:-2
正しい挿入位置に当たるまで
コレクションを二分し続けます

00:35:22.456 --> 00:35:27.594 align:start position:30% line:-2
分割統治アルゴリズムは
高速なのが特長です

00:35:27.694 --> 00:35:30.631 align:start position:25% line:-1
二分探索は対数時間を取ります

00:35:30.731 --> 00:35:37.204 align:start position:21% line:-2
つまり インプットが倍になっても
速度は半減しません

00:35:37.304 --> 00:35:43.010 align:start position:30% line:-2
この対数アルゴリズムは
１ステップの追加だけで

00:35:43.110 --> 00:35:45.646 align:start position:29% line:-1
問題サイズを半減できます

00:35:45.779 --> 00:35:48.015 align:start position:30% line:-1
コードにしてみましょう

00:35:48.115 --> 00:35:52.519 align:start position:25% line:-2
中央要素のインデックス探しに
使うのは―

00:35:52.619 --> 00:35:57.057 align:start position:7% line:-2
関数でオフセットした
RandomAccessCollectionです

00:35:57.524 --> 00:36:01.762 align:start position:32% line:-2
次に 値が中央要素の
前に来るかを確認し

00:35:57.524 --> 00:36:01.762 align:start position:32% line:-2
次に 値が中央要素の
前に来るかを確認し

00:36:01.862 --> 00:36:05.833 align:start position:29% line:-2
挿入位置が
前半か後半かを見極めます

00:36:06.433 --> 00:36:10.470 align:start position:29% line:-2
この例では
値は中央要素より上なので

00:36:10.571 --> 00:36:16.310 align:start position:23% line:-2
中央より後ろのインデックスから
Sliceを取っていきます

00:36:16.443 --> 00:36:20.514 align:start position:4% line:-2
次にsortedInsertionPoint（ofを
再帰的に呼びます

00:36:20.614 --> 00:36:26.320 align:start position:29% line:-2
これが 範囲を絞っていく
分割統治アルゴリズムです

00:36:26.687 --> 00:36:32.626 align:start position:27% line:-2
さて これを使うには
スライシング構文が必要です

00:36:32.993 --> 00:36:35.062 align:start position:27% line:-1
全コレクションに可能なので

00:36:35.162 --> 00:36:42.102 align:start position:18% line:-2
インデックスを整え Sliceを生む
汎用操作を導入してください

00:36:42.870 --> 00:36:47.941 align:start position:30% line:-2
Sliceアダプタは
全コレクションに働き―

00:36:48.042 --> 00:36:54.281 align:start position:27% line:-2
土台のコレクションの要素を
表示するとお話ししましたね

00:36:54.481 --> 00:36:58.018 align:start position:29% line:-2
それで
このアルゴリズムが使え―

00:36:58.118 --> 00:37:02.456 align:start position:34% line:-2
スライシング構文も
提供できるのです

00:36:58.118 --> 00:37:02.456 align:start position:34% line:-2
スライシング構文も
提供できるのです

00:37:02.689 --> 00:37:05.092 align:start position:29% line:-1
ただ １つ問題があります

00:37:05.392 --> 00:37:09.096 align:start position:30% line:-2
このSlice型を嫌う
コレクションです

00:37:09.196 --> 00:37:14.368 align:start position:30% line:-2
それらは独自の操作で
異なる型を生み出します

00:37:14.501 --> 00:37:16.937 align:start position:30% line:-1
文字列は最も良い例です

00:37:17.037 --> 00:37:20.708 align:start position:30% line:-2
スライスすれば
部分文字列が返されます

00:37:21.441 --> 00:37:25.479 align:start position:23% line:-2
文字列に分割統治アルゴリズムを
使うなら―

00:37:25.579 --> 00:37:30.350 align:start position:30% line:-2
それらを部分文字列にも
適用したいですね

00:37:30.751 --> 00:37:33.287 align:start position:29% line:-1
Rangeも面白い例です

00:37:33.387 --> 00:37:38.825 align:start position:23% line:-2
スライス操作で返されるのは
まったく同じRange型ですが

00:37:38.926 --> 00:37:40.928 align:start position:30% line:-1
新しいバウンド付きです

00:37:41.228 --> 00:37:46.199 align:start position:32% line:-2
そこで 様々な型を
キャプチャするために

00:37:46.300 --> 00:37:51.805 align:start position:25% line:-2
コレクションプロトコルに
スライス用の要件を導入します

00:37:52.306 --> 00:37:58.645 align:start position:25% line:-2
スライスするサブスクリプトを
要件として引き入れると―

00:37:59.046 --> 00:38:05.786 align:start position:18% line:-2
結果の型が 新たな関連型
SubSequenceで記述されます

00:37:59.046 --> 00:38:05.786 align:start position:18% line:-2
結果の型が 新たな関連型
SubSequenceで記述されます

00:38:06.787 --> 00:38:11.658 align:start position:27% line:-2
これで文字列もRangeも
新しい要件を満たします

00:38:11.892 --> 00:38:15.596 align:start position:20% line:-2
文字列のSubSequence型は
部分文字列で―

00:38:16.530 --> 00:38:20.500 align:start position:16% line:-2
RangeのSubSequence型は
Rangeです

00:38:21.368 --> 00:38:23.604 align:start position:30% line:-1
でも この２つ以外の―

00:38:23.704 --> 00:38:29.143 align:start position:27% line:-2
SubSequence型の
カスタマイズを嫌う型には？

00:38:29.243 --> 00:38:32.045 align:start position:25% line:-1
スライスのデフォルト制限で―

00:38:32.312 --> 00:38:37.818 align:start position:21% line:-2
これらの型の作者は
コレクション準拠の手間が省けます

00:38:37.918 --> 00:38:40.487 align:start position:30% line:-1
スライス動作は無償です

00:38:41.021 --> 00:38:43.524 align:start position:14% line:-1
では SubSequenceから始めます

00:38:43.924 --> 00:38:47.961 align:start position:30% line:-2
関連型は 自身で
デフォルト値を持てます

00:38:48.095 --> 00:38:50.330 align:start position:25% line:-1
“=”のあとに書かれています

00:38:50.631 --> 00:38:57.204 align:start position:12% line:-2
SubSequenceにとって Slice
アダプタ型は完全なデフォルトです

00:38:57.371 --> 00:39:03.344 align:start position:14% line:-2
自身のSubSequence型を持たない
すべての準拠型に使えます

00:38:57.371 --> 00:39:03.344 align:start position:14% line:-2
自身のSubSequence型を持たない
すべての準拠型に使えます

00:39:03.977 --> 00:39:09.383 align:start position:25% line:-2
スライスするサブスクリプトの
実装とも良い相性です

00:39:09.483 --> 00:39:12.586 align:start position:14% line:-1
“extension”中に書かれています

00:39:12.686 --> 00:39:19.459 align:start position:21% line:-2
スライスするサブスクリプト操作で
デフォルト実装もできます

00:39:19.793 --> 00:39:26.300 align:start position:21% line:-2
一歩進んで そのデフォルト実装の
適用制限を行えば―

00:39:26.400 --> 00:39:30.704 align:start position:16% line:-2
デフォルトのSubSequence型を
選べます

00:39:30.904 --> 00:39:36.176 align:start position:16% line:-2
つまり 文字列など
独自のSubSequenceを持つ型で

00:39:36.276 --> 00:39:41.582 align:start position:25% line:-2
デフォルト実装の
オーバーロードを防げるのです

00:39:41.782 --> 00:39:47.821 align:start position:25% line:-2
スライスを無償で使うのも
カスタマイズするのも自由です

00:39:48.522 --> 00:39:50.157 align:start position:39% line:-1
しかし目的は

00:39:50.257 --> 00:39:54.828 align:start position:30% line:-2
分割統治アルゴリズムを
書くことでしたね

00:39:54.928 --> 00:39:58.499 align:start position:23% line:-1
ここで 重要な疑問が出てきます

00:39:58.599 --> 00:40:00.934 align:start position:21% line:-1
SubSequenceの役割です

00:39:58.599 --> 00:40:00.934 align:start position:21% line:-1
SubSequenceの役割です

00:40:01.168 --> 00:40:06.940 align:start position:21% line:-2
スライスするサブスクリプト操作の
結果の型というだけでは

00:40:07.041 --> 00:40:09.076 align:start position:36% line:-1
実際に使えません

00:40:09.176 --> 00:40:15.582 align:start position:16% line:-2
では SubSequenceの観点から
このアルゴリズムを見ましょう

00:40:15.682 --> 00:40:17.985 align:start position:34% line:-1
これは再帰的であり

00:40:18.085 --> 00:40:22.589 align:start position:18% line:-2
SubSequence型の値となった
Sliceを形成します

00:40:22.723 --> 00:40:27.728 align:start position:9% line:-2
次にsortedInsertionPointを
再帰的に呼びますが

00:40:27.828 --> 00:40:34.034 align:start position:20% line:-2
返されたSubSequence型は
コレクションでなければなりません

00:40:34.334 --> 00:40:39.473 align:start position:27% line:-2
呼び出し時 コレクションの
要素型の値を渡しますが

00:40:39.573 --> 00:40:45.546 align:start position:16% line:-2
再帰的呼び出しで期待されるのは
このSubSequenceの要素型の値

00:40:45.746 --> 00:40:51.785 align:start position:27% line:-2
理にかなう唯一の方法は
要素型が同一であることです

00:40:52.186 --> 00:40:57.424 align:start position:27% line:-2
インデックスが返される時も
同じ問題が起こります

00:40:57.558 --> 00:41:00.527 align:start position:14% line:-1
SubSequence側から出されますが

00:40:57.558 --> 00:41:00.527 align:start position:14% line:-1
SubSequence側から出されますが

00:41:00.627 --> 00:41:06.600 align:start position:29% line:-2
返されるインデックスも
有効でなければなりません

00:41:06.700 --> 00:41:11.805 align:start position:27% line:-2
コレクションプロトコルの
全要件はキャプチャできます

00:41:11.972 --> 00:41:17.844 align:start position:14% line:-2
第１に コレクションの
SubSequenceはコレクションです

00:41:17.945 --> 00:41:20.247 align:start position:30% line:-1
いわゆる再帰的制約です

00:41:20.347 --> 00:41:24.518 align:start position:27% line:-2
関連型は そのプロトコルに
準拠するので―

00:41:24.918 --> 00:41:31.058 align:start position:16% line:-2
SubSequenceのさらなる制約に
関連型“where句”を使えます

00:41:31.258 --> 00:41:32.960 align:start position:38% line:-1
その要素型は―

00:41:33.160 --> 00:41:39.133 align:start position:27% line:-2
元のコレクションの要素型と
同じでなければなりません

00:41:39.266 --> 00:41:44.538 align:start position:9% line:-2
故に SubSequence.Elementは
Elementと同じ制約です

00:41:44.938 --> 00:41:47.741 align:start position:21% line:-1
インデックス型もまったく同じです

00:41:48.142 --> 00:41:51.378 align:start position:9% line:-2
sortedInsertionPoint（of
の実装で―

00:41:51.478 --> 00:41:56.083 align:start position:27% line:-2
これまで見た全プロパティを
カバーできます

00:41:56.984 --> 00:42:01.955 align:start position:23% line:-2
では SubSequenceは
スライスできますか？

00:41:56.984 --> 00:42:01.955 align:start position:23% line:-2
では SubSequenceは
スライスできますか？

00:42:02.322 --> 00:42:04.591 align:start position:16% line:-1
SubSequenceはコレクションで

00:42:04.691 --> 00:42:09.897 align:start position:21% line:-2
コレクションはスライス可能なので
当然できます

00:42:09.997 --> 00:42:14.468 align:start position:21% line:-2
結果は SubSequenceの
SubSequenceです

00:42:15.068 --> 00:42:21.542 align:start position:7% line:-2
再度行えば SubSequenceの
SubSequenceのSubSequence…

00:42:21.642 --> 00:42:23.710 align:start position:34% line:-1
ずっと続けられます

00:42:24.678 --> 00:42:27.981 align:start position:27% line:-1
各段階で真新しい型が作られ

00:42:28.082 --> 00:42:31.685 align:start position:23% line:-1
型の“果てしない塔”ができます

00:42:31.785 --> 00:42:33.554 align:start position:38% line:-1
問題ありません

00:42:33.787 --> 00:42:39.326 align:start position:23% line:-2
再帰の各段階でも
新しい型ができるかもしれません

00:42:39.560 --> 00:42:41.962 align:start position:27% line:-1
基礎は現コレクション型です

00:42:42.062 --> 00:42:46.900 align:start position:23% line:-2
再帰がランタイムで終了する限り
問題ありません

00:42:47.201 --> 00:42:50.537 align:start position:29% line:-1
しかし 非再帰的にすれば

00:42:50.637 --> 00:42:54.775 align:start position:27% line:-2
分割統治アルゴリズム実装は
より効率的です

00:42:55.843 --> 00:43:01.815 align:start position:5% line:-2
sortedInsertionPoint（of の
非再帰的な実装を見てください

00:42:55.843 --> 00:43:01.815 align:start position:5% line:-2
sortedInsertionPoint（of の
非再帰的な実装を見てください

00:43:02.216 --> 00:43:05.319 align:start position:25% line:-1
コアアルゴリズムは同じですが

00:43:05.419 --> 00:43:10.190 align:start position:29% line:-2
再帰的ではなく
反復的に表現されています

00:43:10.490 --> 00:43:14.862 align:start position:29% line:-2
まず コレクション全体の
Sliceを取ります

00:43:15.195 --> 00:43:21.501 align:start position:23% line:-2
このSlice変数は 各反復の
コレクションの一部を表します

00:43:21.935 --> 00:43:25.072 align:start position:21% line:-1
見慣れた分割統治アルゴリズムです

00:43:25.172 --> 00:43:27.141 align:start position:30% line:-1
Sliceの中央を探し

00:43:27.241 --> 00:43:32.112 align:start position:30% line:-2
その中央要素に対して
挿入する値を比較します

00:43:32.613 --> 00:43:38.352 align:start position:23% line:-2
そして Sliceをスライスし
探索範囲を絞ります

00:43:39.186 --> 00:43:41.421 align:start position:30% line:-1
ここで問題に遭遇します

00:43:41.521 --> 00:43:47.327 align:start position:12% line:-2
SubSequence型のSlice変数に
代入していますが

00:43:47.761 --> 00:43:51.165 align:start position:14% line:-1
一方 右部分はSliceのSliceです

00:43:51.265 --> 00:43:57.404 align:start position:7% line:-2
SubSequenceのSubSequenceで
まったく異なる型かもしれません

00:43:57.538 --> 00:44:02.242 align:start position:27% line:-2
型の相違が考慮され
コンパイラエラーになります

00:43:57.538 --> 00:44:02.242 align:start position:27% line:-2
型の相違が考慮され
コンパイラエラーになります

00:44:02.442 --> 00:44:07.581 align:start position:27% line:-2
非再帰的アルゴリズムが
書けなくなるので不便ですし

00:44:07.714 --> 00:44:11.719 align:start position:25% line:-2
特定のコレクション型の動作も
反映されません

00:44:11.819 --> 00:44:16.256 align:start position:27% line:-2
例えば 文字列のスライスは
部分文字列ですが

00:44:16.356 --> 00:44:20.928 align:start position:25% line:-2
そのスライスは
部分部分文字列ではありません

00:44:21.161 --> 00:44:24.731 align:start position:21% line:-1
部分文字列型の別インスタンスです

00:44:25.098 --> 00:44:30.170 align:start position:23% line:-2
このSliceアダプタの動きを
振り返ってみましょう

00:44:30.304 --> 00:44:34.975 align:start position:20% line:-2
コレクションSelfを
“i”から“j”までスライスすると

00:44:35.442 --> 00:44:38.545 align:start position:18% line:-1
Slice<Self>の型ができます

00:44:38.645 --> 00:44:42.449 align:start position:25% line:-2
これは土台のSelfの表示に
過ぎません

00:44:42.583 --> 00:44:47.654 align:start position:16% line:-2
さらにスライスすると
Slice<Slice<Self>>で

00:44:47.754 --> 00:44:53.594 align:start position:21% line:-2
同じ土台のコレクションSelfの
表示の表示です

00:44:53.827 --> 00:44:57.164 align:start position:21% line:-1
これが“果てしない塔”の実例です

00:44:57.297 --> 00:44:59.833 align:start position:27% line:-1
しかし 他の方法もあります

00:44:59.967 --> 00:45:05.839 align:start position:18% line:-2
Slice型は 土台のコレクションと
同じインデックスを使いましたね

00:44:59.967 --> 00:45:05.839 align:start position:18% line:-2
Slice型は 土台のコレクションと
同じインデックスを使いましたね

00:45:05.939 --> 00:45:09.176 align:start position:32% line:-2
土台のコレクションは
分かっているので―

00:45:09.276 --> 00:45:14.748 align:start position:25% line:-2
スライス時に新インデックス
“i２”と“j２”が取れます

00:45:14.848 --> 00:45:20.320 align:start position:23% line:-2
それらを元に戻せば
新しいSliceが形成されます

00:45:20.621 --> 00:45:26.160 align:start position:21% line:-2
Sliceをスライスすれば
同じSlice型を得られるのです

00:45:26.260 --> 00:45:29.697 align:start position:27% line:-1
再帰を効率的に一括できます

00:45:29.797 --> 00:45:33.167 align:start position:25% line:-1
先程の部分文字列でも同じです

00:45:33.267 --> 00:45:38.839 align:start position:20% line:-2
すべてのSubSequence型に
同じことが期待できます

00:45:38.939 --> 00:45:44.044 align:start position:25% line:-2
では 要件の明示的部分として
モデルを作りましょう

00:45:44.344 --> 00:45:50.851 align:start position:7% line:-2
SubSequenceのSubSequenceは
SubSequenceと同じ型です

00:45:50.951 --> 00:45:55.656 align:start position:27% line:-2
Sliceをスライスすれば
同じSliceが返るので―

00:45:56.223 --> 00:46:02.463 align:start position:21% line:-2
非再帰的な分割統治アルゴリズムが
可能になります

00:45:56.223 --> 00:46:02.463 align:start position:21% line:-2
非再帰的な分割統治アルゴリズムが
可能になります

00:46:02.563 --> 00:46:06.533 align:start position:30% line:-2
型の“果てしない塔”は
もう不要です

00:46:06.900 --> 00:46:10.504 align:start position:29% line:-1
ただ 最後の問題として―

00:46:10.604 --> 00:46:16.243 align:start position:9% line:-2
SubSequence型は Random
AccessCollectionであるべきです

00:46:16.543 --> 00:46:19.980 align:start position:20% line:-2
offsetByインデックス操作の
ためです

00:46:20.714 --> 00:46:24.651 align:start position:18% line:-1
この記述には where句が使えます

00:46:24.751 --> 00:46:28.288 align:start position:7% line:-2
BidirectionalCollectionを
継承すると―

00:46:28.388 --> 00:46:35.162 align:start position:14% line:-2
それに準拠するという制約が
SubSequenceに新たに加わります

00:46:35.262 --> 00:46:40.768 align:start position:25% line:-2
これも再帰的制約ですが
このプロトコル上に表されます

00:46:40.868 --> 00:46:44.738 align:start position:7% line:-2
RandomAccessCollectionでも
まったく同じです

00:46:44.838 --> 00:46:50.477 align:start position:4% line:-2
これのSubSequenceは
RandomAccessCollection準拠です

00:46:50.611 --> 00:46:55.282 align:start position:23% line:-2
SubSequenceの制約が
そのプロトコルに従うのは

00:46:55.382 --> 00:46:58.152 align:start position:25% line:-1
聞き覚えがあるかもしれません

00:46:58.485 --> 00:47:04.258 align:start position:27% line:-2
再帰的制約も条件付き準拠も
プロトコル階層を追跡します

00:46:58.485 --> 00:47:04.258 align:start position:27% line:-2
再帰的制約も条件付き準拠も
プロトコル階層を追跡します

00:47:04.358 --> 00:47:10.964 align:start position:14% line:-2
この機能で SubSequenceに対し
関連型のデフォルトが得られ―

00:47:11.064 --> 00:47:17.704 align:start position:12% line:-2
SelfのSliceは コレクション階層の
どのレベルでも働くのです

00:47:18.005 --> 00:47:21.208 align:start position:2% line:-1
BidirectionalCollectionを作れば

00:47:21.308 --> 00:47:26.480 align:start position:14% line:-2
これに準拠するSubSequence型が
必要となります

00:47:26.880 --> 00:47:30.284 align:start position:20% line:-1
Sliceアダプタの条件付き準拠で

00:47:30.384 --> 00:47:34.555 align:start position:7% line:-2
BidirectionalCollectionと
なります

00:47:34.655 --> 00:47:36.690 align:start position:32% line:-1
その要件も満たします

00:47:36.890 --> 00:47:39.359 align:start position:9% line:-2
RandomAccessCollectionも
同様です

00:47:39.727 --> 00:47:43.030 align:start position:14% line:-1
SubSequenceはその要件を取得し

00:47:43.130 --> 00:47:48.035 align:start position:27% line:-2
Sliceの条件付き準拠で
その要件を満たします

00:47:48.135 --> 00:47:51.538 align:start position:7% line:-2
それ自体が
RandomAccessCollectionです

00:47:51.638 --> 00:47:57.311 align:start position:23% line:-2
関連型のデフォルトが
階層内の全プロトコルに働くのは

00:47:57.411 --> 00:48:00.280 align:start position:29% line:-1
凝集設計の好例と言えます

00:47:57.411 --> 00:48:00.280 align:start position:29% line:-1
凝集設計の好例と言えます

00:48:00.614 --> 00:48:05.953 align:start position:21% line:-2
コレクション階層で
様々な関連型のデフォルトが要ると

00:48:06.120 --> 00:48:08.021 align:start position:29% line:-1
設計は困難かもしれません

00:48:08.222 --> 00:48:13.594 align:start position:23% line:-2
再帰的制約はパワフルで
関連型とwhere句に使えます

00:48:13.694 --> 00:48:15.996 align:start position:27% line:-1
必要なプロトコル要件が書け

00:48:16.096 --> 00:48:20.467 align:start position:30% line:-2
分割統治アルゴリズムを
汎用コードで表せます

00:48:20.567 --> 00:48:23.971 align:start position:23% line:-1
では WWDCの最終パートです

00:48:24.905 --> 00:48:28.208 align:start position:20% line:-1
Swiftはマルチパラダイム言語で

00:48:28.308 --> 00:48:32.946 align:start position:21% line:-2
オブジェクト指向プログラミングも
サポートしています

00:48:33.614 --> 00:48:36.350 align:start position:30% line:-1
そこで ２つの機能が―

00:48:36.450 --> 00:48:40.888 align:start position:21% line:-2
Swift言語でどう対話するかを
お話しします

00:48:41.188 --> 00:48:44.958 align:start position:29% line:-2
まず クラス継承の働きは
ご存じですね

00:48:45.058 --> 00:48:46.160 align:start position:39% line:-1
シンプルです

00:48:46.260 --> 00:48:48.295 align:start position:21% line:-1
スーパークラスのVehicleや

00:48:48.395 --> 00:48:53.133 align:start position:12% line:-2
継承したサブクラスの
TaxiやPoliceCarが宣言できます

00:48:53.467 --> 00:48:56.703 align:start position:23% line:-1
オブジェクト指向階層ができたら

00:48:56.803 --> 00:49:00.741 align:start position:30% line:-2
サブクラスが
どこで使えるか考えます

00:48:56.803 --> 00:49:00.741 align:start position:30% line:-2
サブクラスが
どこで使えるか考えます

00:49:00.841 --> 00:49:05.279 align:start position:30% line:-2
Vehicleを動かす
メソッドを使えば

00:49:05.379 --> 00:49:10.417 align:start position:29% line:-2
サブクラスのTaxiでも
呼び出せると考えます

00:49:11.385 --> 00:49:15.522 align:start position:21% line:-2
オブジェクト指向プログラミングの
基本です

00:49:15.622 --> 00:49:20.327 align:start position:30% line:-2
バーバラ･リスコフが
80年代に述べて以来―

00:49:20.694 --> 00:49:24.298 align:start position:29% line:-2
“リスコフの置換原則”と
呼ばれています

00:49:24.398 --> 00:49:26.533 align:start position:32% line:-1
シンプルな考え方です

00:49:26.767 --> 00:49:30.571 align:start position:29% line:-2
プログラム内でスーパー型
つまり―

00:49:30.671 --> 00:49:35.142 align:start position:16% line:-2
Vehicleのようなスーパークラスを
参照するとします

00:49:35.843 --> 00:49:40.214 align:start position:12% line:-2
するとTaxiやPoliceCarのような
サブ型 つまり―

00:49:40.748 --> 00:49:44.685 align:start position:27% line:-2
サブクラスのインスタンスが
取れるはずです

00:49:44.785 --> 00:49:48.288 align:start position:34% line:-2
型チェックと動作は
正常に継続します

00:49:48.589 --> 00:49:54.495 align:start position:25% line:-2
ここでの置換は サブクラスと
スーパークラス間です

00:49:55.295 --> 00:50:00.334 align:start position:23% line:-2
シンプルな原理で
取り込み済みですがパワフルです

00:49:55.295 --> 00:50:00.334 align:start position:23% line:-2
シンプルな原理で
取り込み済みですがパワフルです

00:50:00.434 --> 00:50:01.802 align:start position:34% line:-1
考えてみてください

00:50:01.902 --> 00:50:07.908 align:start position:21% line:-2
考えもしなかった違うサブクラスを
得たらどうなるかをね

00:50:08.942 --> 00:50:11.979 align:start position:25% line:-1
では ジェネリクスに戻ります

00:50:12.846 --> 00:50:18.752 align:start position:25% line:-2
置換原則を汎用システムに
適用すると 何ができますか？

00:50:18.852 --> 00:50:25.292 align:start position:14% line:-2
例えばDrivableプロトコルを追加し
Vehicleを拡張できます

00:50:25.392 --> 00:50:27.895 align:start position:32% line:-1
ここで期待するのは―

00:50:27.995 --> 00:50:33.934 align:start position:21% line:-2
そのプロトコル準拠を
サブクラスにも使用できることです

00:50:34.468 --> 00:50:40.174 align:start position:14% line:-2
汎用アルゴリズムをDrivableに
追加し sundayDriveに行くなら

00:50:40.274 --> 00:50:44.711 align:start position:20% line:-2
そのAPIをPoliceCarでも
使えるはずです

00:50:44.812 --> 00:50:47.047 align:start position:30% line:-1
良い考えかはともかくね

00:50:48.215 --> 00:50:54.054 align:start position:29% line:-2
ここで プロトコル準拠は
サブクラスにも継承され―

00:50:54.755 --> 00:50:56.590 align:start position:36% line:-1
制約が課されます

00:50:56.690 --> 00:51:01.061 align:start position:11% line:-2
VehicleをDrivableにする準拠を
１つ書けば―

00:50:56.690 --> 00:51:01.061 align:start position:11% line:-2
VehicleをDrivableにする準拠を
１つ書けば―

00:51:01.161 --> 00:51:07.134 align:start position:16% line:-2
あとから足すものも含め
Vehicleの全サブクラスに働きます

00:51:07.734 --> 00:51:10.537 align:start position:27% line:-1
大抵の場合 うまくいきます

00:51:11.171 --> 00:51:16.343 align:start position:27% line:-2
しかし サブクラスに
要件を加える場合もあります

00:51:16.610 --> 00:51:21.181 align:start position:23% line:-2
よくあるのは イニシャライザの
要件を扱う場合です

00:51:22.082 --> 00:51:28.155 align:start position:16% line:-2
例えば Decodableプロトコルの
要件はイニシャライザで―

00:51:28.255 --> 00:51:32.926 align:start position:29% line:-2
デコーダから 準拠型の
インスタンスを作成します

00:51:34.228 --> 00:51:38.465 align:start position:27% line:-2
使うには このプロトコルに
便宜メソッドを加えます

00:51:38.565 --> 00:51:45.038 align:start position:21% line:-2
これは静的メソッドdecodeで
新しいインスタンスを作成します

00:51:45.873 --> 00:51:50.711 align:start position:23% line:-2
このメソッドの興味深い点は２つ
第１に―

00:51:50.811 --> 00:51:53.247 align:start position:25% line:-1
大文字SのSelfを返すこと

00:51:53.347 --> 00:51:58.852 align:start position:29% line:-2
準拠型で 静的メソッドを
呼び出すのと同じ型です

00:52:00.087 --> 00:52:03.590 align:start position:21% line:-1
第２に どのように実装するかです

00:52:03.690 --> 00:52:06.393 align:start position:29% line:-1
上のイニシャライザを呼び

00:52:06.493 --> 00:52:13.200 align:start position:16% line:-2
適当なDecodable型の 真っ新の
インスタンスを作成して返します

00:52:14.701 --> 00:52:15.669 align:start position:39% line:-1
いいでしょう

00:52:16.003 --> 00:52:18.772 align:start position:25% line:-2
これでVehicle型を
Decodableにできます

00:52:19.439 --> 00:52:23.177 align:start position:32% line:-2
そして置換原則を
適用する際の期待は―

00:52:23.277 --> 00:52:29.583 align:start position:23% line:-2
Vehicleのサブクラスでも
新規APIが使用できることです

00:52:29.683 --> 00:52:33.120 align:start position:29% line:-2
つまり Taxiで
ｄecodeを呼び出すと

00:52:33.354 --> 00:52:39.426 align:start position:21% line:-2
VehicleのでなくTaxiの
インスタンスが返されるのです

00:52:40.661 --> 00:52:42.262 align:start position:38% line:-1
その仕組みは？

00:52:43.030 --> 00:52:47.701 align:start position:21% line:-2
TaxiのHourlyRateを
見てみましょう

00:52:47.801 --> 00:52:50.504 align:start position:14% line:-2
“Taxi.decode(from:”を
呼び出すと

00:52:51.038 --> 00:52:54.942 align:start position:30% line:-2
イニシャライザの要件を
確認します

00:52:55.042 --> 00:52:57.644 align:start position:32% line:-1
実際に呼び出せるのは

00:52:57.744 --> 00:53:03.684 align:start position:20% line:-2
Vehicleクラス内で宣言された
イニシャライザだけです

00:52:57.744 --> 00:53:03.684 align:start position:20% line:-2
Vehicleクラス内で宣言された
イニシャライザだけです

00:53:03.784 --> 00:53:05.285 align:start position:34% line:-1
スーパークラスです

00:53:06.420 --> 00:53:10.958 align:start position:25% line:-2
Vehicleのデコード法は
知っていますが

00:53:11.058 --> 00:53:13.694 align:start position:18% line:-1
Taxiサブクラスについては無知です

00:53:14.261 --> 00:53:20.567 align:start position:18% line:-2
このイニシャライザを直接使うと
HourlyRateは初期化されず―

00:53:20.667 --> 00:53:24.671 align:start position:32% line:-2
請求書を受け取る際に
誤解が生じ得ます

00:53:26.240 --> 00:53:27.407 align:start position:39% line:-1
対処方法は？

00:53:27.541 --> 00:53:30.844 align:start position:18% line:-1
Swiftならこの問題は起こりません

00:53:31.278 --> 00:53:36.617 align:start position:23% line:-2
Decodableプロトコルに
準拠させる時点で診断し

00:53:36.717 --> 00:53:41.288 align:start position:18% line:-1
Requiredとマークするからです

00:53:42.823 --> 00:53:47.294 align:start position:27% line:-2
このイニシャライザは
全サブクラスで実装されます

00:53:47.394 --> 00:53:50.230 align:start position:27% line:-1
直下のサブクラスに限らず―

00:53:50.330 --> 00:53:54.802 align:start position:30% line:-2
それらのサブクラスや
将来のサブクラスもです

00:53:55.736 --> 00:54:00.941 align:start position:16% line:-2
この要件の追加により
TaxiにVehicleを継承した際―

00:53:55.736 --> 00:54:00.941 align:start position:16% line:-2
この要件の追加により
TaxiにVehicleを継承した際―

00:54:01.041 --> 00:54:06.080 align:start position:21% line:-2
同じ名前のイニシャライザの導入も
必要です

00:54:06.480 --> 00:54:10.150 align:start position:20% line:-2
このイニシャライザは
HourlyRateをデコードし―

00:54:10.250 --> 00:54:16.590 align:start position:21% line:-2
スーパークラスにつなげ
Vehicle型もデコードします

00:54:20.194 --> 00:54:26.300 align:start position:14% line:-2
ところで スライドの
“non-final”に気付きましたか？

00:54:26.700 --> 00:54:30.771 align:start position:25% line:-2
定義では ファイナルクラスは
サブクラスを持たず―

00:54:30.871 --> 00:54:34.174 align:start position:21% line:-1
あとで置換されることはありません

00:54:36.043 --> 00:54:40.848 align:start position:21% line:-2
Requiredイニシャライザも
不要です

00:54:40.948 --> 00:54:47.287 align:start position:18% line:-2
Decodableなどの要件の扱いも
少し楽になります

00:54:47.387 --> 00:54:50.958 align:start position:21% line:-2
Requiredイニシャライザが
不要ですからね

00:54:51.859 --> 00:54:55.095 align:start position:23% line:-1
参照の意味でクラスを使う場合―

00:54:55.929 --> 00:55:02.069 align:start position:23% line:-2
クラスのカスタマイズが不要なら
ファイナルを使いましょう

00:54:55.929 --> 00:55:02.069 align:start position:23% line:-2
クラスのカスタマイズが不要なら
ファイナルを使いましょう

00:55:02.169 --> 00:55:07.374 align:start position:30% line:-2
後ほど 拡張して
カスタマイズは可能です

00:55:07.474 --> 00:55:13.981 align:start position:23% line:-2
構造体や列挙型と同じく拡張でき
準拠も追加できます

00:55:14.882 --> 00:55:17.551 align:start position:30% line:-2
ただ 汎用システムとの
対話を簡略化し

00:55:17.651 --> 00:55:21.121 align:start position:29% line:-2
コンパイラもランタイムで
最適化しやすくなります

00:55:24.224 --> 00:55:28.062 align:start position:27% line:-2
Swiftのジェネリクスの
背景にある考えは―

00:55:28.162 --> 00:55:32.966 align:start position:29% line:-2
静的な型情報を保持しつつ
コード再利用することです

00:55:33.066 --> 00:55:39.239 align:start position:25% line:-2
それで正しいプログラムが書け
実行も効率良くなります

00:55:39.606 --> 00:55:43.310 align:start position:25% line:-1
プロトコル設計は駆け引きです

00:55:43.410 --> 00:55:47.748 align:start position:34% line:-2
汎用アルゴリズムと
準拠型のバランスで

00:55:47.848 --> 00:55:52.719 align:start position:34% line:-2
意味のある抽象化を
行っていきましょう

00:55:53.520 --> 00:55:59.993 align:start position:23% line:-2
新しい汎用アルゴリズムの実装に
特別なケイパビリティが必要なら

00:56:00.094 --> 00:56:03.997 align:start position:21% line:-1
プロトコル継承を導入してください

00:56:04.598 --> 00:56:08.435 align:start position:30% line:-2
汎用型を書く際は
条件付き準拠の導入です

00:56:08.535 --> 00:56:13.841 align:start position:27% line:-2
プロトコル階層と動く場合に
特にうまく構成できます

00:56:14.308 --> 00:56:20.414 align:start position:25% line:-2
クラス継承と汎用システム間の
複雑な対話を考える際は―

00:56:20.514 --> 00:56:24.751 align:start position:27% line:-2
リスコフの置換原則に戻って
考えてください

00:56:24.852 --> 00:56:30.657 align:start position:21% line:-2
スーパークラスでなくサブクラスを
導入したらどうなるかと

00:56:33.894 --> 00:56:34.628 align:start position:43% line:-1
以上です

00:56:34.728 --> 00:56:39.767 align:start position:30% line:-2
アルゴリズムを活用して
コード構築に役立てたり

00:56:39.867 --> 00:56:44.438 align:start position:23% line:-2
Swiftのコレクションを
有効に使うセッションもあります

00:56:44.905 --> 00:56:45.606 align:start position:41% line:-1
ありがとう

00:56:45.739 --> 00:56:48.142 align:start position:43% line:-1
(拍手)
