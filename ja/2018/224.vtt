WEBVTT

00:00:07.074 --> 00:00:16.717 align:start position:43% line:-1
(音楽)

00:00:21.522 --> 00:00:22.756 align:start position:41% line:-1
こんにちは

00:00:22.856 --> 00:00:27.694 align:start position:43% line:-1
(拍手)

00:00:27.794 --> 00:00:29.730 align:start position:25% line:-2
Core Data Best
Practicesへようこそ

00:00:29.830 --> 00:00:35.202 align:start position:16% line:-2
Core Dataのスコット･ペリーと
ニック･ジレットがお届けします

00:00:36.436 --> 00:00:37.604 align:start position:41% line:-1
まず初めに

00:00:38.739 --> 00:00:43.510 align:start position:16% line:-2
進化し続けるCore Dataについて
簡単にご紹介します

00:00:43.911 --> 00:00:47.548 align:start position:27% line:-2
次に 永続コンテナにおける
拡張ポイントを活用し

00:00:47.648 --> 00:00:51.185 align:start position:29% line:-2
アプリケーションを
より簡単に進化させる方法

00:00:52.519 --> 00:00:55.889 align:start position:29% line:-2
アプリケーションの要求や
データ量に応じて

00:00:55.989 --> 00:00:57.524 align:start position:30% line:-1
モデルを進化させる方法

00:00:58.992 --> 00:01:02.829 align:start position:25% line:-2
規模に関わらず
パフォーマンスを維持する方法

00:00:58.992 --> 00:01:02.829 align:start position:25% line:-2
規模に関わらず
パフォーマンスを維持する方法

00:01:02.930 --> 00:01:05.465 align:start position:25% line:-1
こちらはニックがお話しします

00:01:06.700 --> 00:01:11.271 align:start position:27% line:-2
トランスフォーマやデバッグ
テストにも触れます

00:01:12.906 --> 00:01:15.108 align:start position:34% line:-2
アプリケーションを
作ってみましょう

00:01:15.843 --> 00:01:20.314 align:start position:21% line:-2
投稿した写真にコメントが付くのは
うれしいものです

00:01:20.414 --> 00:01:24.451 align:start position:29% line:-2
たとえニックからの
仕事関係のコメントでもね

00:01:27.254 --> 00:01:30.624 align:start position:27% line:-2
データの保存先は
オンライン上でもいいですが

00:01:30.724 --> 00:01:34.962 align:start position:25% line:-2
旅行先だと
通信が不安定なこともあります

00:01:35.262 --> 00:01:38.065 align:start position:23% line:-1
ローカルへの保存が賢明でしょう

00:01:40.934 --> 00:01:42.369 align:start position:32% line:-1
オブジェクトグラフが

00:01:42.469 --> 00:01:46.840 align:start position:23% line:-2
インスタンスや
その間の関係により形成されます

00:01:46.940 --> 00:01:50.978 align:start position:32% line:-2
これらをディスク上に
保存するわけですが

00:01:51.578 --> 00:01:53.447 align:start position:20% line:-1
そこでCore Dataの出番です

00:01:55.883 --> 00:01:59.953 align:start position:27% line:-2
これを使って まずモックを
ストアが読み込める―

00:02:00.053 --> 00:02:02.923 align:start position:29% line:-2
管理オブジェクトモデルに
変換します

00:02:03.524 --> 00:02:04.791 align:start position:32% line:-1
フィールドが必要です

00:02:04.892 --> 00:02:08.895 align:start position:34% line:-2
属性は画像データや
投稿時間などです

00:02:08.996 --> 00:02:12.499 align:start position:32% line:-1
関係も必要になります

00:02:13.000 --> 00:02:18.472 align:start position:21% line:-2
ディスク上でのデータの長期保存は
簡単ではありません

00:02:18.939 --> 00:02:22.910 align:start position:27% line:-2
Core Dataによる
永続ストアコーディネータは

00:02:23.010 --> 00:02:27.514 align:start position:25% line:-2
アプリケーションのモデルを
ストアのバージョンと比較して

00:02:27.614 --> 00:02:30.584 align:start position:27% line:-1
移行を自動で行ってくれます

00:02:30.951 --> 00:02:34.087 align:start position:23% line:-2
管理オブジェクトコンテキストは
安全かつ高速で

00:02:34.188 --> 00:02:36.290 align:start position:21% line:-1
予測可能なアクセスを可能にします

00:02:36.523 --> 00:02:40.527 align:start position:23% line:-2
クエリジェネレーションや
コネクションプーリングなどの―

00:02:40.627 --> 00:02:42.663 align:start position:30% line:-1
処理中でも対応できます

00:02:44.865 --> 00:02:47.935 align:start position:32% line:-2
ここでモデルを見つけ
それを読み込み

00:02:48.035 --> 00:02:50.003 align:start position:29% line:-1
ストアの場所を決めますが

00:02:50.337 --> 00:02:54.474 align:start position:27% line:-2
App配信後のエラーパスは
ほぼエラーにならないので

00:02:54.575 --> 00:02:56.410 align:start position:14% line:-1
Core Dataによるコンテナタイプで

00:02:56.510 --> 00:03:00.214 align:start position:34% line:-2
ボイラープレートは
大幅に省略できます

00:02:56.510 --> 00:03:00.214 align:start position:34% line:-2
ボイラープレートは
大幅に省略できます

00:03:00.314 --> 00:03:04.651 align:start position:21% line:-2
永続コンテナがメインバンドルから
モデルを読み込み

00:03:04.751 --> 00:03:07.054 align:start position:27% line:-1
一定の場所に保存するのです

00:03:09.089 --> 00:03:12.926 align:start position:25% line:-2
スタック全体がカプセル化され
共有されたメインキューの―

00:03:13.026 --> 00:03:15.596 align:start position:23% line:-1
ビューコンテキストにも有用です

00:03:15.696 --> 00:03:19.466 align:start position:25% line:-2
バックグラウンドの
パフォーマンスを上げるための

00:03:19.566 --> 00:03:22.002 align:start position:21% line:-1
ファクトリメソッドにも役立ちます

00:03:22.336 --> 00:03:25.739 align:start position:21% line:-2
アプリケーションが大きくなっても
対応できます

00:03:25.839 --> 00:03:26.773 align:start position:36% line:-1
モデルレイヤーを

00:03:26.874 --> 00:03:30.310 align:start position:30% line:-2
独自のフレームワークに
組み入れたい時でも

00:03:30.777 --> 00:03:35.649 align:start position:16% line:-2
新しいフレームワークターゲットを
Xcodeで作り コードを移すだけです

00:03:35.749 --> 00:03:37.951 align:start position:29% line:-2
しかしモデルを
新しいターゲットへ移す時

00:03:38.051 --> 00:03:41.889 align:start position:21% line:-2
ターゲットは
新しいフレームワークへ移動します

00:03:42.155 --> 00:03:43.524 align:start position:36% line:-1
正しい動きですが

00:03:43.624 --> 00:03:47.261 align:start position:11% line:-2
NSPersistentContainerが
モデルを捜せなくなります

00:03:47.361 --> 00:03:51.398 align:start position:21% line:-2
デフォルトでは チェックの対象は
メインバンドルだけです

00:03:51.698 --> 00:03:56.103 align:start position:25% line:-2
スタックを回転させるたびに
全てのバンドルを調べていては

00:03:56.203 --> 00:03:59.173 align:start position:30% line:-1
動作が遅くなるからです

00:04:00.607 --> 00:04:01.808 align:start position:41% line:-1
対処法は？

00:04:02.576 --> 00:04:06.146 align:start position:27% line:-2
フレームワークバンドルから
モデルを再び取り出し

00:04:06.246 --> 00:04:11.218 align:start position:23% line:-2
コンテナの他のイニシャライザを
使う手もありますが

00:04:11.652 --> 00:04:16.322 align:start position:9% line:-2
NSPersistentContainerなら
検索対象のバンドルを変更できます

00:04:17.757 --> 00:04:21.128 align:start position:11% line:-2
NSPersistentContainerは
モデルを捜す際に

00:04:21.228 --> 00:04:24.965 align:start position:32% line:-2
サブクラスの型を
ヒントとして使います

00:04:25.299 --> 00:04:28.502 align:start position:30% line:-2
サブクラスを作成すれば
これを利用できます

00:04:28.669 --> 00:04:30.871 align:start position:25% line:-1
中に何か書く必要はありません

00:04:31.839 --> 00:04:36.543 align:start position:21% line:-2
モデルを使うコンテナの
コード設定にサブクラスが採用され

00:04:36.643 --> 00:04:40.914 align:start position:25% line:-2
永続コンテナが バンドルから
モデルを見つけ出します

00:04:43.183 --> 00:04:47.321 align:start position:27% line:-2
ディスク上のデータの編成も
改善されていたら

00:04:47.421 --> 00:04:50.791 align:start position:23% line:-1
一層すばらしいと思いませんか？

00:04:51.992 --> 00:04:55.929 align:start position:20% line:-2
新しい永続コンテナは
自動移行するSQLiteストアの―

00:04:56.029 --> 00:05:00.267 align:start position:27% line:-2
ストアディスクリプションが
デフォルトで備わっています

00:04:56.029 --> 00:05:00.267 align:start position:27% line:-2
ストアディスクリプションが
デフォルトで備わっています

00:05:01.034 --> 00:05:03.804 align:start position:29% line:-2
それは結構ですが
新しいフレームワークと―

00:05:03.904 --> 00:05:07.508 align:start position:23% line:-2
アプリケーションの融合し過ぎは
避けたいですね

00:05:08.275 --> 00:05:12.346 align:start position:32% line:-2
モデルを見つけるのが
容易になったところで

00:05:12.446 --> 00:05:14.414 align:start position:27% line:-1
この点も改善してみましょう

00:05:17.050 --> 00:05:19.686 align:start position:21% line:-1
ストアの場所を強制的に変えるには

00:05:19.786 --> 00:05:21.788 align:start position:0% line:-2
persistentStoreDescriptionsの
中のURLを

00:05:21.889 --> 00:05:24.925 align:start position:23% line:-1
直接 書き換えればいいでしょう

00:05:25.459 --> 00:05:29.596 align:start position:11% line:-2
ただし今回は
NSPersistentContainerが

00:05:29.696 --> 00:05:32.966 align:start position:21% line:-2
永続ストアのディスクリプションを
作成する際に

00:05:33.066 --> 00:05:37.337 align:start position:7% line:-2
defaultDirectoryURLメソッドを
呼び出します

00:05:37.437 --> 00:05:38.972 align:start position:29% line:-1
オーバーライドもされます

00:05:39.373 --> 00:05:41.575 align:start position:9% line:-2
appendingPathComponentも
有効です

00:05:41.675 --> 00:05:45.345 align:start position:32% line:-2
ストアを別々の場所に
とどめておくための

00:05:45.445 --> 00:05:50.050 align:start position:23% line:-2
キャッシュやスタック用に
コンテナを構成する手もあります

00:05:51.985 --> 00:05:55.322 align:start position:16% line:-2
ここで アプリケーションや
View Controllerについて

00:05:55.422 --> 00:05:58.025 align:start position:30% line:-1
実際に見ていきましょう

00:05:59.059 --> 00:06:01.929 align:start position:20% line:-2
あることに特化した
View Controllerです

00:05:59.059 --> 00:06:01.929 align:start position:20% line:-2
あることに特化した
View Controllerです

00:06:02.196 --> 00:06:07.034 align:start position:25% line:-2
左は私のポスト
右は全ての作成者のポストです

00:06:07.134 --> 00:06:12.005 align:start position:27% line:-2
重複しているので
半分のコードで済みそうです

00:06:13.974 --> 00:06:17.544 align:start position:23% line:-1
片方では複数のポストを表示させ

00:06:17.644 --> 00:06:20.180 align:start position:25% line:-1
片方では１つだけ表示させます

00:06:20.547 --> 00:06:25.185 align:start position:11% line:-2
モデルオブジェクトを取る
２つのView Controllerの境界を

00:06:25.285 --> 00:06:28.088 align:start position:29% line:-1
うまく設定すれば可能です

00:06:29.156 --> 00:06:31.992 align:start position:20% line:-2
各View Controllerは
モデルパラメータにより構成され

00:06:32.459 --> 00:06:37.698 align:start position:21% line:-2
表示するポストによって ビューを
細かくカスタマイズできます

00:06:39.766 --> 00:06:41.768 align:start position:30% line:-2
リストビューには
フェッチ要求を取得させ

00:06:41.869 --> 00:06:46.373 align:start position:23% line:-2
ディテールビューには
管理オブジェクトを取得させます

00:06:47.407 --> 00:06:49.943 align:start position:23% line:-2
管理オブジェクトコンテキストも
必要です

00:06:50.043 --> 00:06:54.248 align:start position:25% line:-2
ビューコンテキストか 他の
メインキューコンテキストです

00:06:54.615 --> 00:06:57.417 align:start position:14% line:-2
View Controllerを汎化する
この方法は

00:06:57.518 --> 00:07:01.155 align:start position:25% line:-2
ユーティリティのデータ型にも
非常に有効です

00:06:57.518 --> 00:07:01.155 align:start position:25% line:-2
ユーティリティのデータ型にも
非常に有効です

00:07:01.722 --> 00:07:04.391 align:start position:21% line:-1
URLやシリアル化されたデータを

00:07:04.491 --> 00:07:09.229 align:start position:29% line:-2
バックグラウンドワークの
コントローラに渡します

00:07:09.329 --> 00:07:12.366 align:start position:32% line:-2
バックグラウンドの
コンテキストを使って

00:07:12.466 --> 00:07:16.770 align:start position:21% line:-2
更新済みの
管理オブジェクトに変換するのです

00:07:17.905 --> 00:07:21.808 align:start position:23% line:-2
私たちは独自のイニシャライザを
持っているため

00:07:21.909 --> 00:07:25.078 align:start position:23% line:-2
コントローラの生成を
パラメータに要求するだけですが

00:07:25.212 --> 00:07:28.348 align:start position:20% line:-2
View Controllerへの
境界変数の組み入れ方は？

00:07:30.350 --> 00:07:33.587 align:start position:23% line:-2
prepareメソッドは
セグエでオーバーライドできます

00:07:34.521 --> 00:07:38.559 align:start position:2% line:-2
destinationViewControllerへの
参照も取得できます

00:07:39.326 --> 00:07:41.061 align:start position:20% line:-1
ストーリーボードかNIBがあるなら

00:07:41.161 --> 00:07:45.065 align:start position:2% line:-2
destinationViewController用の
コードはできているので

00:07:45.165 --> 00:07:49.236 align:start position:27% line:-2
表示する前に プロパティを
設定すればいいだけです

00:07:49.403 --> 00:07:53.607 align:start position:27% line:-2
手動で行うなら
境界条件を明確に定義する―

00:07:53.707 --> 00:07:56.009 align:start position:32% line:-2
イニシャライザを
書いてもいいでしょう

00:07:57.344 --> 00:08:02.015 align:start position:25% line:-2
これで フェッチ要求と
コンテキストが準備できました

00:07:57.344 --> 00:08:02.015 align:start position:25% line:-2
これで フェッチ要求と
コンテキストが準備できました

00:08:02.149 --> 00:08:06.553 align:start position:30% line:-2
しかし フェッチ要求に
もう少し手を加えて

00:08:06.653 --> 00:08:09.456 align:start position:27% line:-2
より優れたパフォーマンスを
発揮させましょう

00:08:10.724 --> 00:08:13.026 align:start position:25% line:-1
今回は全データを見せたいので

00:08:13.126 --> 00:08:17.331 align:start position:27% line:-2
フェッチリミットの設定より
バッチ処理のほうが有効です

00:08:17.931 --> 00:08:22.035 align:start position:14% line:-2
私たちはView Controllerの
キャパシティを知っています

00:08:23.237 --> 00:08:24.872 align:start position:36% line:-1
フェッチ要求には

00:08:24.972 --> 00:08:29.576 align:start position:27% line:-2
こうした選択肢を
１つは用意しておくべきです

00:08:30.944 --> 00:08:36.015 align:start position:27% line:-2
これでフェッチ要求を
リストビューに変換できます

00:08:36.517 --> 00:08:40.654 align:start position:29% line:-2
では UIを常に
最新の状態に保つ方法は？

00:08:41.554 --> 00:08:44.525 align:start position:25% line:-2
役立つのが
フェッチ結果コントローラです

00:08:44.625 --> 00:08:46.994 align:start position:27% line:-2
あらゆるプラットフォームで
利用でき

00:08:47.094 --> 00:08:50.063 align:start position:25% line:-2
デリゲートプロトコルと
ビューの間にアダプタを書けば

00:08:50.164 --> 00:08:52.833 align:start position:30% line:-1
導入することができます

00:08:53.100 --> 00:08:56.103 align:start position:29% line:-2
必要なのはフェッチ要求と
コンテキストだけです

00:08:57.070 --> 00:09:02.276 align:start position:27% line:-2
より進化したリストビューの
コンセプトにも有用です

00:08:57.070 --> 00:09:02.276 align:start position:27% line:-2
より進化したリストビューの
コンセプトにも有用です

00:09:03.577 --> 00:09:06.747 align:start position:32% line:-2
ポストは 日を基準に
グループ分けできます

00:09:06.847 --> 00:09:10.350 align:start position:21% line:-2
計算済みプロパティでXcodeが
生成したポストタイプを拡張し

00:09:10.450 --> 00:09:13.053 align:start position:27% line:-2
フェッチ結果コントローラの
イニシャライザに

00:09:13.153 --> 00:09:15.355 align:start position:36% line:-1
名前を渡すのです

00:09:16.256 --> 00:09:17.591 align:start position:36% line:-1
有効な手段ですが

00:09:17.958 --> 00:09:21.595 align:start position:21% line:-2
View Controllerが
もっと複雑だったら？

00:09:21.695 --> 00:09:26.300 align:start position:23% line:-2
日ごとのポストを
グラフ化して表示したい場合は？

00:09:27.467 --> 00:09:31.471 align:start position:32% line:-2
フェッチ要求の実力を
侮ってはいけません

00:09:31.705 --> 00:09:37.244 align:start position:23% line:-2
私は先月 １日に40枚の写真を
ポストしましたが

00:09:37.611 --> 00:09:42.850 align:start position:25% line:-2
ストアから瞬時に取り出すには
十分すぎる量でした

00:09:44.218 --> 00:09:48.422 align:start position:21% line:-2
定義しておいたdayプロパティが
エンティティの一部であれば

00:09:48.522 --> 00:09:53.193 align:start position:23% line:-2
フェッチ要求で 日を基準に
ポストをカウントできるでしょう

00:09:53.694 --> 00:09:55.429 align:start position:34% line:-1
段階は３つあります

00:09:55.529 --> 00:09:59.600 align:start position:21% line:-1
まず 範囲を30日間に設定します

00:10:01.034 --> 00:10:06.039 align:start position:23% line:-2
次に 同じ値のday属性を持つ
全ての結果をグループ化します

00:10:06.173 --> 00:10:09.042 align:start position:27% line:-2
フェッチしているのは
オブジェクトの集合体なので

00:10:09.143 --> 00:10:13.380 align:start position:29% line:-2
結果の型を
ディクショナリに変えます

00:10:14.648 --> 00:10:17.751 align:start position:29% line:-2
最後に 各グループの
オブジェクトの数を表す―

00:10:17.851 --> 00:10:20.287 align:start position:36% line:-1
計算式を定義して

00:10:20.387 --> 00:10:23.757 align:start position:21% line:-1
フェッチ要求にその数を返させます

00:10:24.825 --> 00:10:30.063 align:start position:29% line:-2
返される30の結果が
グラフ上で点で表されます

00:10:33.267 --> 00:10:37.404 align:start position:20% line:-2
これはCore Dataが生成する
SQLiteクエリです

00:10:37.504 --> 00:10:40.307 align:start position:29% line:-2
皆さんがクエリを書く時と
同じですね

00:10:40.774 --> 00:10:42.342 align:start position:20% line:-1
Core Dataは多くの関数式を

00:10:42.442 --> 00:10:45.579 align:start position:27% line:-2
最適なデータベースクエリに
変換できます

00:10:45.679 --> 00:10:49.416 align:start position:29% line:-2
クエリによるグループは
集計関数を使うことができ

00:10:49.516 --> 00:10:53.987 align:start position:27% line:-2
スカラークエリは
通常のフェッチ要求のように

00:10:54.087 --> 00:10:57.257 align:start position:34% line:-2
ABS関数などの
日付関数が使えます

00:10:58.725 --> 00:11:03.163 align:start position:16% line:-2
NSExpressionでできることを
もっと知りたい方は

00:10:58.725 --> 00:11:03.163 align:start position:16% line:-2
NSExpressionでできることを
もっと知りたい方は

00:11:03.263 --> 00:11:06.033 align:start position:32% line:-2
使える関数のリストを
ご確認ください

00:11:08.268 --> 00:11:13.474 align:start position:23% line:-2
フェッチ要求は
関数式を使うことで活躍しますが

00:11:13.574 --> 00:11:18.879 align:start position:20% line:-2
依然 SQLiteはメモリを通して
全てのポストを読み込みます

00:11:19.713 --> 00:11:24.885 align:start position:27% line:-2
もし 対象となるポストが
１か月分だけならいいですが

00:11:24.985 --> 00:11:26.987 align:start position:29% line:-1
範囲がもっと広い場合は？

00:11:27.554 --> 00:11:29.656 align:start position:29% line:-1
１年分ならどうでしょう？

00:11:29.756 --> 00:11:33.760 align:start position:29% line:-2
データ量が
ケタ違いだったとしたら？

00:11:34.595 --> 00:11:39.700 align:start position:21% line:-2
この例では フェッチ要求は
５万件のポストを１件ずつ数えます

00:11:40.200 --> 00:11:42.302 align:start position:30% line:-1
それでは間に合いません

00:11:42.669 --> 00:11:47.875 align:start position:21% line:-2
ビューとモデル間のミスマッチには
非正規化が必要です

00:11:50.410 --> 00:11:54.047 align:start position:32% line:-2
冗長データを追加する
非正規化により

00:11:54.148 --> 00:11:57.818 align:start position:29% line:-2
読み込みパフォーマンスを
改善できます

00:11:58.352 --> 00:12:00.787 align:start position:27% line:-2
データベースインデックスが
いい例です

00:11:58.352 --> 00:12:00.787 align:start position:27% line:-2
データベースインデックスが
いい例です

00:12:01.421 --> 00:12:03.457 align:start position:32% line:-2
カウントメタデータを
ストアに加えれば

00:12:03.557 --> 00:12:08.228 align:start position:25% line:-2
グラフのパフォーマンスを
再び向上させることができます

00:12:09.129 --> 00:12:13.066 align:start position:32% line:-2
今回のモデルについて
見ていきましょう

00:12:14.034 --> 00:12:18.672 align:start position:23% line:-2
２つの属性を持つエンティティと
メンテナンスが必要です

00:12:19.106 --> 00:12:25.546 align:start position:21% line:-2
フェッチ要求を改善し
何年分ものデータをカバーできます

00:12:25.646 --> 00:12:28.482 align:start position:21% line:-1
この程度の非正規化で十分なのです

00:12:29.183 --> 00:12:31.852 align:start position:16% line:-2
View Controllerに渡した
フェッチ要求？

00:12:32.619 --> 00:12:33.754 align:start position:34% line:-1
すごくシンプルです

00:12:34.321 --> 00:12:38.725 align:start position:27% line:-2
他のリストビューに渡した
フェッチ要求とそう変わらず

00:12:38.826 --> 00:12:42.462 align:start position:34% line:-2
グラフのビューと
ほぼ同じに見えます

00:12:44.031 --> 00:12:45.666 align:start position:34% line:-1
メンテナンスとは？

00:12:46.533 --> 00:12:51.205 align:start position:27% line:-2
ポスト時のインクリメントと
削除時のデクリメントです

00:12:51.471 --> 00:12:55.108 align:start position:27% line:-2
確実な解決法は
コンテキストの退避に応じて

00:12:55.209 --> 00:12:59.146 align:start position:23% line:-1
計算をアップデートすることです

00:13:02.583 --> 00:13:07.955 align:start position:18% line:-2
管理オブジェクトの
contextWillSave通知と

00:13:08.055 --> 00:13:11.492 align:start position:25% line:-2
全てのポストに影響する関数を
登録して

00:13:11.592 --> 00:13:14.828 align:start position:23% line:-2
カウントをインクリメントしても
いいでしょう

00:13:14.995 --> 00:13:19.299 align:start position:23% line:-2
別のループには 投稿日に応じて
カウントをデクリメントさせます

00:13:19.633 --> 00:13:24.838 align:start position:23% line:-2
コンテキストは データベースに
作用する前に影響を受け

00:13:24.938 --> 00:13:26.840 align:start position:30% line:-1
機能が向上していきます

00:13:26.974 --> 00:13:29.877 align:start position:27% line:-2
Core Dataがあれば
小さなアプリケーションでも

00:13:29.977 --> 00:13:34.314 align:start position:25% line:-2
夢のような物に
進化させることができるのです

00:13:34.715 --> 00:13:35.349 align:start position:45% line:-1
ニック

00:13:35.449 --> 00:13:37.384 align:start position:43% line:-1
(拍手)

00:13:37.484 --> 00:13:38.352 align:start position:41% line:-1
ありがとう

00:13:38.452 --> 00:13:40.621 align:start position:43% line:-1
(拍手)

00:13:40.721 --> 00:13:41.755 align:start position:34% line:-1
アプリケーションは

00:13:41.855 --> 00:13:46.059 align:start position:30% line:-2
規模が大きくなるにつれ
複雑になっていきます

00:13:46.159 --> 00:13:50.063 align:start position:25% line:-2
しかし 規模を大きくするのは
重要なことです

00:13:50.264 --> 00:13:55.202 align:start position:29% line:-2
規模を大きくしていく中で
いかに機能性を上げ

00:13:55.302 --> 00:13:59.973 align:start position:27% line:-2
付加価値を高められるかが
私たちの存在意義だからです

00:14:01.675 --> 00:14:05.078 align:start position:23% line:-2
しかしアプリケーションによって
その過程は異なり

00:14:05.312 --> 00:14:11.151 align:start position:27% line:-2
顧客体験や作り手の意図とも
密接に関わってきます

00:14:11.952 --> 00:14:15.088 align:start position:29% line:-2
アプリケーションの構造が
複雑になるほど

00:14:15.189 --> 00:14:18.826 align:start position:21% line:-1
カオスを招く危険性が高くなります

00:14:19.259 --> 00:14:25.199 align:start position:20% line:-2
Core Dataで このカオスを
うまくコントロールしましょう

00:14:25.432 --> 00:14:28.101 align:start position:30% line:-1
予測可能な動作を設定し

00:14:28.469 --> 00:14:33.507 align:start position:27% line:-2
顧客体験に応じた
柔軟なコンテナを作るのです

00:14:36.443 --> 00:14:37.644 align:start position:39% line:-1
具体的には？

00:14:38.145 --> 00:14:43.183 align:start position:23% line:-2
メトリクスに関しては
いくつかの切り口が考えられます

00:14:43.283 --> 00:14:46.019 align:start position:27% line:-2
１つ目は
顧客に応じたものであること

00:14:46.253 --> 00:14:49.389 align:start position:27% line:-2
通常は顧客が体験することを
指します

00:14:49.490 --> 00:14:54.128 align:start position:23% line:-2
一貫したインターフェイスや
レスポンシブなスクロールビュー

00:14:56.029 --> 00:14:58.265 align:start position:32% line:-1
楽しさとも関係します

00:14:59.833 --> 00:15:02.803 align:start position:30% line:-2
これらはエンジニアには
捉えにくいため―

00:14:59.833 --> 00:15:02.803 align:start position:30% line:-2
これらはエンジニアには
捉えにくいため―

00:15:03.136 --> 00:15:05.405 align:start position:25% line:-2
エンジニアリングメトリクスに
落とし込みます

00:15:05.506 --> 00:15:10.577 align:start position:23% line:-2
ピーク時のメモリ消費量や
タスク実行時のバッテリーの消耗

00:15:10.677 --> 00:15:14.047 align:start position:18% line:-1
CPU時間は どれぐらいかかっていて

00:15:14.248 --> 00:15:18.285 align:start position:20% line:-1
I/Oは どのくらい行われているか

00:15:18.719 --> 00:15:21.955 align:start position:23% line:-1
より具体的に ご説明しましょう

00:15:22.189 --> 00:15:27.094 align:start position:23% line:-2
昨年ご紹介した
デモ用のアプリケーションですが

00:15:27.194 --> 00:15:29.997 align:start position:25% line:-1
今回用に修正を加えてあります

00:15:30.430 --> 00:15:34.802 align:start position:32% line:-2
顧客が取る行動は
いくつか考えられます

00:15:34.935 --> 00:15:40.073 align:start position:25% line:-2
まず＋ボタンで ポストを１件
データベースに加えること

00:15:40.707 --> 00:15:45.712 align:start position:23% line:-2
待機中のデータを サーバから
ダウンロードすることもできます

00:15:50.951 --> 00:15:55.956 align:start position:23% line:-2
新規で全てアップロード
する場合はPost Allです

00:15:56.490 --> 00:16:01.895 align:start position:23% line:-2
インタラクションの組み合わせは
かなり小規模なものですが

00:15:56.490 --> 00:16:01.895 align:start position:23% line:-2
インタラクションの組み合わせは
かなり小規模なものですが

00:16:02.062 --> 00:16:05.232 align:start position:30% line:-1
これが一斉に起こると―

00:16:06.066 --> 00:16:07.835 align:start position:36% line:-1
カオスになります

00:16:10.204 --> 00:16:13.373 align:start position:32% line:-2
たとえ小さな動作でも
一斉に起こると

00:16:13.474 --> 00:16:17.778 align:start position:29% line:-2
アプリケーションの状態に
様々な影響を及ぼします

00:16:17.878 --> 00:16:22.149 align:start position:29% line:-2
最悪の場合 ユーザ体験は
このようになります

00:16:22.583 --> 00:16:28.455 align:start position:21% line:-2
エンジニアにすら理解できないほど
不完全な状態です

00:16:29.723 --> 00:16:32.926 align:start position:27% line:-2
そこで有用なのが
クエリジェネレーションです

00:16:33.026 --> 00:16:37.931 align:start position:21% line:-2
これは2016年のセッションでも
ご紹介しました

00:16:38.031 --> 00:16:43.704 align:start position:27% line:-2
詳しく知りたい方は
ぜひ そちらもご覧ください

00:16:43.904 --> 00:16:49.176 align:start position:21% line:-2
これにはWALジャーナルモードと
SQLiteが欠かせません

00:16:49.810 --> 00:16:55.148 align:start position:23% line:-2
管理オブジェクトコンテキストを
競合する動作から切り離します

00:16:55.249 --> 00:16:57.284 align:start position:25% line:-1
ユーザが行うであろうものの―

00:16:57.384 --> 00:17:03.290 align:start position:21% line:-2
まだ準備できていないアクションに
役立つものです

00:16:57.384 --> 00:17:03.290 align:start position:21% line:-2
まだ準備できていないアクションに
役立つものです

00:17:03.924 --> 00:17:07.961 align:start position:21% line:-2
クエリジェネレーションが提供する
データベースのビューは

00:17:08.060 --> 00:17:10.230 align:start position:36% line:-1
フェッチする際に

00:17:10.329 --> 00:17:14.434 align:start position:27% line:-2
他のコンテキストに関わらず
同じ結果を返します

00:17:18.438 --> 00:17:21.175 align:start position:27% line:-1
必要なコードは１行だけです

00:17:21.608 --> 00:17:24.444 align:start position:25% line:-2
テーブルビューのリロード時は
このように

00:17:24.545 --> 00:17:26.180 align:start position:25% line:-1
クエリジェネレーションと共に

00:17:26.280 --> 00:17:30.150 align:start position:2% line:-2
NSManagedObjectContext
setQueryGenerationFromトークンの

00:17:30.250 --> 00:17:32.252 align:start position:32% line:-1
呼び出しを挿入します

00:17:33.353 --> 00:17:35.255 align:start position:32% line:-1
アップデートする際は

00:17:36.290 --> 00:17:40.994 align:start position:2% line:-2
通常どおりNSManagedObjectContext
DidSave通知を使います

00:17:42.729 --> 00:17:48.502 align:start position:21% line:-2
これにより 然るべきタイミングで
変更を加えることができます

00:17:52.306 --> 00:17:55.475 align:start position:20% line:-1
データがUIと関連していない時は？

00:17:55.576 --> 00:17:58.846 align:start position:23% line:-2
コメントを
ダウンロードするような場合です

00:17:59.513 --> 00:18:00.547 align:start position:34% line:-1
そうしたデータには

00:17:59.513 --> 00:18:00.547 align:start position:34% line:-1
そうしたデータには

00:18:01.181 --> 00:18:04.351 align:start position:30% line:-2
インターフェイスに
現れてほしくありません

00:18:04.451 --> 00:18:08.088 align:start position:23% line:-2
ユーザに分からないような変更も
困ります

00:18:08.422 --> 00:18:12.326 align:start position:23% line:-2
そこでヒストリートラッキングで
アップデートをフィルタします

00:18:12.859 --> 00:18:15.796 align:start position:16% line:-2
永続ヒストリートラッキングは
iOS 11とmacOS 10.13で

00:18:15.896 --> 00:18:17.798 align:start position:32% line:-1
新しく導入されました

00:18:18.065 --> 00:18:22.703 align:start position:32% line:-2
昨年のセッションでも
ご紹介していますので

00:18:22.903 --> 00:18:26.006 align:start position:27% line:-1
基本的な特徴を知りたい方は

00:18:26.106 --> 00:18:29.977 align:start position:21% line:-1
そちらをご覧になってみてください

00:18:31.879 --> 00:18:34.214 align:start position:25% line:-1
永続ヒストリートラッキングは

00:18:34.314 --> 00:18:38.552 align:start position:23% line:-2
各トランザクションの
永続レコードを得る上で有効です

00:18:38.652 --> 00:18:41.588 align:start position:29% line:-1
理由は いくつかあります

00:18:41.688 --> 00:18:44.124 align:start position:30% line:-2
ただ このセッションで
考えたいのは

00:18:44.591 --> 00:18:47.494 align:start position:2% line:-1
NSPersistentHistoryChangeです

00:18:47.661 --> 00:18:52.833 align:start position:11% line:-2
これはchangedObjectIDと
updatedPropertiesを与えます

00:18:52.933 --> 00:18:55.369 align:start position:11% line:-2
また NSPersistentHistory
Transactionもです

00:18:55.569 --> 00:18:59.439 align:start position:5% line:-2
これはchangesと
objectIDNotificationを与えます

00:19:03.710 --> 00:19:06.380 align:start position:21% line:-1
changesを見ていきましょう

00:19:06.680 --> 00:19:10.384 align:start position:29% line:-2
これらはデータベースに
挿入されているポストです

00:19:10.918 --> 00:19:12.619 align:start position:27% line:-1
このテーブルビューを見ると

00:19:12.719 --> 00:19:16.023 align:start position:34% line:-2
UIをリフレッシュ
したくなるでしょう

00:19:16.690 --> 00:19:20.094 align:start position:12% line:-2
objectIDNotificationで
それができます

00:19:20.194 --> 00:19:23.964 align:start position:4% line:-2
これらはNSManagedObjectContext
DidSave通知に類似し

00:19:24.064 --> 00:19:27.267 align:start position:21% line:-1
同じAPIを使ってマージされます

00:19:29.970 --> 00:19:33.207 align:start position:27% line:-2
ユーザアップデートに
現れてほしくないコメントを

00:19:33.307 --> 00:19:35.742 align:start position:23% line:-1
ダウンロードしてしまった場合は

00:19:36.910 --> 00:19:38.245 align:start position:36% line:-1
フィルタできます

00:19:40.047 --> 00:19:43.750 align:start position:23% line:-2
与えられたトランザクションから
changesをフィルタし

00:19:43.851 --> 00:19:46.753 align:start position:25% line:-2
ポストエンティティとの関連を
判断します

00:19:49.089 --> 00:19:51.725 align:start position:34% line:-2
これでUIの
リフレッシュを避け

00:19:51.859 --> 00:19:55.562 align:start position:30% line:-2
ユーザへの不要な負担を
回避できます

00:19:56.130 --> 00:20:00.767 align:start position:27% line:-2
ここではポストコンテンツを
少し使っているだけです

00:19:56.130 --> 00:20:00.767 align:start position:27% line:-2
ここではポストコンテンツを
少し使っているだけです

00:20:01.135 --> 00:20:04.238 align:start position:27% line:-2
具体的には
たった２つのプロパティです

00:20:04.338 --> 00:20:06.206 align:start position:27% line:-1
imageとtitleです

00:20:07.307 --> 00:20:10.244 align:start position:32% line:-2
エンティティによる
フィルタにとどまらず

00:20:10.344 --> 00:20:14.815 align:start position:9% line:-2
ヒストリーの変更を使い
updatedPropertiesでもフィルタ

00:20:14.915 --> 00:20:19.286 align:start position:29% line:-2
ユーザからも視認できて
ユーザ体験に的を絞った―

00:20:19.386 --> 00:20:22.256 align:start position:23% line:-1
アップデートを実現できるのです

00:20:25.759 --> 00:20:30.797 align:start position:23% line:-2
新たなインタラクションにも
Core Dataは役立ちます

00:20:31.231 --> 00:20:34.735 align:start position:30% line:-2
編集作業の中には
データ量が増えるほどに

00:20:34.835 --> 00:20:37.738 align:start position:32% line:-2
より多くのコストが
かかるものもあります

00:20:38.071 --> 00:20:40.807 align:start position:27% line:-2
シンプルなフォトブラウザを
例に取ります

00:20:41.108 --> 00:20:43.710 align:start position:29% line:-2
アプリケーションの規模が
大きくなるにつれ

00:20:43.811 --> 00:20:48.382 align:start position:23% line:-2
繰り返しのタスクを
より簡単に行いたくなるものです

00:20:48.482 --> 00:20:50.417 align:start position:30% line:-1
例えば複数選択などです

00:20:51.685 --> 00:20:55.189 align:start position:21% line:-2
Core Dataはバッチ処理で
これをサポートできます

00:20:55.889 --> 00:21:02.463 align:start position:23% line:-2
ほんの数行のコードで
写真を選別できるようになります

00:20:55.889 --> 00:21:02.463 align:start position:23% line:-2
ほんの数行のコードで
写真を選別できるようになります

00:21:03.831 --> 00:21:05.866 align:start position:29% line:-1
また コードを１行書けば

00:21:05.966 --> 00:21:09.937 align:start position:27% line:-2
データベースのレコードを
パージもしくは削除できます

00:21:10.571 --> 00:21:13.340 align:start position:29% line:-2
オブジェクトをメモリ上で
フォールトするよりも

00:21:13.440 --> 00:21:15.442 align:start position:27% line:-1
はるかにうまくいく処理です

00:21:15.809 --> 00:21:17.844 align:start position:36% line:-1
例えば削除する際

00:21:17.945 --> 00:21:21.315 align:start position:2% line:-2
NSManagedObject.deleteを呼び出す
従来の方法は

00:21:21.415 --> 00:21:24.718 align:start position:25% line:-2
データベースのレコードの
サイズに合わせて用いられます

00:21:24.818 --> 00:21:28.288 align:start position:27% line:-2
オブジェクトを削除し
メモリがフォールトされると

00:21:28.388 --> 00:21:32.392 align:start position:25% line:-2
コストは増え データベースも
大きくなっていきます

00:21:32.626 --> 00:21:35.929 align:start position:30% line:-2
しかし バッチ処理なら
わずかなメモリの中で

00:21:36.029 --> 00:21:38.065 align:start position:30% line:-1
同じ変化をもたらせます

00:21:38.265 --> 00:21:42.402 align:start position:29% line:-2
そしてデータが増加する時
望む曲線が得られます

00:21:42.503 --> 00:21:46.240 align:start position:29% line:-2
データが大きくなるほど
メモリは少なく済むのです

00:21:46.340 --> 00:21:51.378 align:start position:25% line:-2
1000万行で 従来の
削除時のメモリの７％程度です

00:21:52.446 --> 00:21:56.717 align:start position:30% line:-2
これはリソースの節約に
非常に役立つ手段です

00:21:58.185 --> 00:22:01.321 align:start position:25% line:-1
しかし バッチ処理の問題点は

00:21:58.185 --> 00:22:01.321 align:start position:25% line:-1
しかし バッチ処理の問題点は

00:22:01.488 --> 00:22:05.926 align:start position:25% line:-2
保存通知を作らないため
扱うのが難しいということです

00:22:06.293 --> 00:22:08.529 align:start position:25% line:-2
再びヒストリートラッキングの
出番です

00:22:08.929 --> 00:22:13.100 align:start position:23% line:-2
永続ヒストリートラッキングでは
バッチ処理を行う際に

00:22:13.200 --> 00:22:16.803 align:start position:21% line:-2
トランザクションを
データベースからフェッチできます

00:22:16.904 --> 00:22:19.239 align:start position:9% line:-1
objectIDNotificationを使い

00:22:19.339 --> 00:22:23.177 align:start position:16% line:-2
保存通知と同機能の
Notificationを生成できます

00:22:23.277 --> 00:22:27.915 align:start position:23% line:-2
こうして アプリケーション内の
フェッチ結果コントローラなどは

00:22:28.115 --> 00:22:30.984 align:start position:27% line:-2
それらの通知を
徐々にアップデートできます

00:22:33.620 --> 00:22:37.925 align:start position:23% line:-2
以上がCore Dataによる
増加するデータの管理方法です

00:22:38.759 --> 00:22:40.761 align:start position:27% line:-1
では実際のワークフローは？

00:22:40.861 --> 00:22:44.932 align:start position:23% line:-2
アプリケーションをビルドしたり
テストしたりする上で

00:22:45.032 --> 00:22:48.001 align:start position:30% line:-2
Core Dataは
どう役立つのでしょう？

00:22:49.136 --> 00:22:52.639 align:start position:30% line:-2
必ず今日から
あなたの助けになります

00:22:53.740 --> 00:22:56.643 align:start position:9% line:-1
NSKeyedArchiverは変化しています

00:22:56.944 --> 00:23:00.914 align:start position:23% line:-2
セキュアコーディングは
プラットフォーム全体に導入され

00:22:56.944 --> 00:23:00.914 align:start position:23% line:-2
セキュアコーディングは
プラットフォーム全体に導入され

00:23:01.014 --> 00:23:03.183 align:start position:14% line:-2
それをサポートする
NSKeyedArchiver APIも

00:23:03.283 --> 00:23:05.752 align:start position:23% line:-1
今年 劇的な変化を遂げています

00:23:06.386 --> 00:23:09.356 align:start position:23% line:-1
これは値変換の変化を意味します

00:23:09.456 --> 00:23:13.827 align:start position:21% line:-2
もし管理オブジェクトモデルの中に
変換可能なプロパティを持ち

00:23:13.927 --> 00:23:16.530 align:start position:25% line:-1
まだ値変換を送っていないなら

00:23:16.630 --> 00:23:20.033 align:start position:14% line:-2
値変換はNSKeyedUnarchive
FromDataTransformerが

00:23:20.134 --> 00:23:22.569 align:start position:29% line:-1
デフォルトになっています

00:23:22.803 --> 00:23:27.307 align:start position:7% line:-2
今後はNSSecureUnarchive
FromDataTransformerになります

00:23:27.474 --> 00:23:31.945 align:start position:21% line:-2
実装されるセキュアコーディングは
ぜひ導入すべきです

00:23:32.146 --> 00:23:36.583 align:start position:32% line:-2
これに関する講演が
今朝 実施されました

00:23:36.884 --> 00:23:38.452 align:start position:11% line:-1
“Data You Can Trust”です

00:23:38.552 --> 00:23:42.756 align:start position:29% line:-2
アプリケーションを
より障害に強くするために

00:23:42.856 --> 00:23:45.526 align:start position:27% line:-1
視聴することをお勧めします

00:23:48.161 --> 00:23:51.899 align:start position:25% line:-2
モデルエディタの中で
これを指定することもできます

00:23:52.733 --> 00:23:55.102 align:start position:12% line:-2
使うのはValue Transformer
Nameのフィールドです

00:23:55.602 --> 00:23:59.973 align:start position:23% line:-2
今は皆さん自身で
これを実装してほしいと思います

00:24:00.073 --> 00:24:02.609 align:start position:29% line:-2
これは将来
デフォルトになるでしょう

00:24:02.709 --> 00:24:05.579 align:start position:9% line:-2
また デフォルトのValue
Transformer Nameを使っていれば

00:24:05.679 --> 00:24:08.982 align:start position:27% line:-2
Xcodeで
警告が出るようにもなります

00:24:09.917 --> 00:24:11.852 align:start position:23% line:-1
コードでモデルをビルドするなら

00:24:11.952 --> 00:24:14.721 align:start position:4% line:-1
valueTransformerNameプロパティを

00:24:14.822 --> 00:24:16.723 align:start position:7% line:-2
NSAttributeDescription上で
使ってください

00:24:17.691 --> 00:24:20.160 align:start position:29% line:-2
カスタムクラスを
エンコードしていなければ

00:24:20.260 --> 00:24:22.062 align:start position:27% line:-1
これは透過的になるはずです

00:24:22.162 --> 00:24:24.565 align:start position:14% line:-1
plistタイプにとってはNOP命令です

00:24:24.665 --> 00:24:26.567 align:start position:4% line:-2
単純にValue Transformer Nameを
変えれば

00:24:26.667 --> 00:24:29.069 align:start position:25% line:-2
新しいセキュアコーディングの
動作を得られるでしょう

00:24:29.169 --> 00:24:31.672 align:start position:25% line:-2
しかし もしカスタムクラスを
実装しているなら

00:24:31.772 --> 00:24:34.174 align:start position:23% line:-2
それらのクラスには
セキュアコーディングが必要です

00:24:34.274 --> 00:24:37.277 align:start position:30% line:-2
ラボに来ていただければ
力になります

00:24:38.245 --> 00:24:40.848 align:start position:27% line:-1
さらに有用なことがあります

00:24:41.181 --> 00:24:42.916 align:start position:29% line:-1
私たちが注力してきたのは

00:24:43.016 --> 00:24:46.620 align:start position:21% line:-2
スタック下で何が起きているのかを
理解するのに役立つ―

00:24:46.720 --> 00:24:48.589 align:start position:29% line:-1
デバッグツールの開発です

00:24:48.922 --> 00:24:52.659 align:start position:23% line:-1
こちらはスキーム設定の画像です

00:24:52.759 --> 00:24:55.529 align:start position:25% line:-2
SQLiteのデバッグ情報が
増えるよう

00:24:55.629 --> 00:24:59.066 align:start position:34% line:-2
プロセスについて
議論を重ねています

00:24:59.166 --> 00:25:01.001 align:start position:30% line:-1
ここで非常に大事なのが

00:24:59.166 --> 00:25:01.001 align:start position:30% line:-1
ここで非常に大事なのが

00:25:01.101 --> 00:25:04.404 align:start position:16% line:-2
com.apple.CoreData.
ConcurrencyDebugです

00:25:04.505 --> 00:25:07.641 align:start position:23% line:-2
これはアプリケーションにおける
キューの例外を捉えます

00:25:07.741 --> 00:25:10.611 align:start position:27% line:-2
メインとバックグラウンドの
キューコンテキスト間で

00:25:10.711 --> 00:25:12.880 align:start position:23% line:-1
オブジェクトを移動させるエリア

00:25:12.980 --> 00:25:14.982 align:start position:27% line:-2
あるいは管理オブジェクトの
実際のコンテキストに

00:25:15.082 --> 00:25:17.618 align:start position:30% line:-1
従わないエリアなどです

00:25:18.619 --> 00:25:21.989 align:start position:18% line:-2
またSQLiteは興味深い環境変数を
多く有します

00:25:22.089 --> 00:25:24.057 align:start position:21% line:-1
それらのスレッドやアサーションは

00:25:24.157 --> 00:25:28.262 align:start position:27% line:-2
API周辺などにおける
アプリケーションの正確性に

00:25:28.362 --> 00:25:30.030 align:start position:32% line:-1
非常に役立つものです

00:25:30.430 --> 00:25:34.067 align:start position:21% line:-2
自動トレースはバックグラウンドの
動作を把握するための

00:25:34.167 --> 00:25:36.336 align:start position:29% line:-1
デバッグログ上の手段です

00:25:36.737 --> 00:25:39.139 align:start position:14% line:-2
com.apple.Core Data.
SQLDebugには

00:25:39.239 --> 00:25:40.908 align:start position:32% line:-1
４つの段階があります

00:25:41.008 --> 00:25:42.743 align:start position:32% line:-1
１つ目は最も興味深く

00:25:42.843 --> 00:25:45.712 align:start position:30% line:-2
パフォーマンスヒットは
最も小さくなります

00:25:45.812 --> 00:25:49.683 align:start position:32% line:-2
４つ目の段階は
最も詳細な状態ですが

00:25:49.783 --> 00:25:51.885 align:start position:30% line:-2
パフォーマンスヒットを
非常に大きくします

00:25:53.921 --> 00:25:57.524 align:start position:21% line:-2
SQLデバッグやマルチスレッドの
アサーションを有効にすると

00:25:57.624 --> 00:25:59.960 align:start position:29% line:-2
コンソール内に
ログを見ることができます

00:26:00.060 --> 00:26:03.630 align:start position:23% line:-2
これはアサーションが正常に
機能していることを示すものです

00:26:04.531 --> 00:26:06.934 align:start position:25% line:-1
SQLデバッグを有効にすると

00:26:07.034 --> 00:26:09.403 align:start position:21% line:-1
フェッチ要求のためのセレクト文や

00:26:09.503 --> 00:26:11.205 align:start position:32% line:-1
所要時間が見られます

00:26:11.605 --> 00:26:14.842 align:start position:23% line:-2
４つ目の段階では
“EXPLAIN”が得られます

00:26:14.942 --> 00:26:17.244 align:start position:34% line:-2
それは与えられた
セレクト文のための

00:26:17.344 --> 00:26:19.379 align:start position:30% line:-1
クエリプランを示します

00:26:19.479 --> 00:26:24.384 align:start position:21% line:-2
ここではテーブルスキャンを通して
テーブルビューが選択されています

00:26:24.484 --> 00:26:27.054 align:start position:32% line:-2
タイムスタンプ上の
ORDER BY用に

00:26:27.154 --> 00:26:29.990 align:start position:21% line:-2
メモリ内の一時的なB-treeを
使っています

00:26:30.424 --> 00:26:32.593 align:start position:29% line:-2
これは潜在的な
パフォーマンスの問題です

00:26:32.693 --> 00:26:36.430 align:start position:25% line:-2
アプリケーションを動かす際は
こうしたメッセージを利用して

00:26:36.530 --> 00:26:39.500 align:start position:25% line:-1
ムダのある箇所を確認できます

00:26:40.267 --> 00:26:41.802 align:start position:38% line:-1
修正の方法は？

00:26:42.870 --> 00:26:43.604 align:start position:45% line:-1
答えは

00:26:44.471 --> 00:26:47.040 align:start position:27% line:-1
SQLite 3にあります

00:26:47.407 --> 00:26:51.612 align:start position:20% line:-2
データベースを開き SQLログから
セレクトクエリを渡せば

00:26:51.879 --> 00:26:53.914 align:start position:32% line:-2
エキスパートモードを
有効にできます

00:26:54.214 --> 00:26:57.718 align:start position:25% line:-2
これはクエリを分析して
カバリングインデックスを作り

00:26:57.818 --> 00:27:00.621 align:start position:30% line:-2
最適なソリューションを
与えてくれます

00:26:57.818 --> 00:27:00.621 align:start position:30% line:-2
最適なソリューションを
与えてくれます

00:27:01.255 --> 00:27:03.323 align:start position:25% line:-1
モデルエディタの中で行うには

00:27:03.757 --> 00:27:06.727 align:start position:23% line:-2
ポストエンティティに
フェッチインデックスを加えます

00:27:07.094 --> 00:27:10.764 align:start position:30% line:-2
タイムスタンプ上で
実行できるように設定し

00:27:11.064 --> 00:27:12.199 align:start position:38% line:-1
降順にフェッチ

00:27:12.299 --> 00:27:15.836 align:start position:23% line:-2
一番最近のポストを テーブルの
トップに表示しているからです

00:27:17.905 --> 00:27:21.375 align:start position:21% line:-2
アプリケーションを再び実行すると
同じセレクトログが見られます

00:27:24.645 --> 00:27:26.079 align:start position:30% line:-1
今回はセレクトクエリが

00:27:26.180 --> 00:27:29.917 align:start position:25% line:-2
カバリングインデックスを
クエリの際にヒットしています

00:27:30.017 --> 00:27:34.721 align:start position:21% line:-2
クエリはORDER BY用に
カバリングインデックスを使います

00:27:38.458 --> 00:27:40.527 align:start position:16% line:-1
R-treeを使う複合インデックスなど

00:27:40.627 --> 00:27:43.764 align:start position:29% line:-2
様々な型のインデックスを
サポートしています

00:27:43.864 --> 00:27:44.998 align:start position:29% line:-1
様々なクエリを生成したり

00:27:45.099 --> 00:27:50.037 align:start position:21% line:-2
セレクト文内で境界ボックスを使う
クエリを最適化したりする上で

00:27:50.137 --> 00:27:51.805 align:start position:30% line:-1
これらは非常に有効です

00:27:52.072 --> 00:27:54.074 align:start position:21% line:-1
通常 ロケーションに応じて行われ

00:27:54.174 --> 00:27:58.111 align:start position:25% line:-2
他のインデックスを
ポストエンティティに加え設定

00:27:58.212 --> 00:28:02.883 align:start position:12% line:-2
latitudeやlongitudeの中で
機能するインデックスです

00:27:58.212 --> 00:28:02.883 align:start position:12% line:-2
latitudeやlongitudeの中で
機能するインデックスです

00:28:04.718 --> 00:28:08.589 align:start position:23% line:-2
R-treeを選択して
ボックス内のクエリタイプを変更

00:28:09.823 --> 00:28:12.860 align:start position:27% line:-2
するとフェッチ要求上に
述語を加えることができます

00:28:13.126 --> 00:28:16.897 align:start position:30% line:-2
“中国大陸内で起こる
全てのポストを得よ”と

00:28:18.332 --> 00:28:22.336 align:start position:25% line:-2
この述語は セレクト文の中で
関数を使っているため

00:28:22.436 --> 00:28:25.272 align:start position:25% line:-1
少し高度なものになっています

00:28:25.372 --> 00:28:28.976 align:start position:21% line:-2
管理オブジェクトモデル内の
インデックスをヒットするためです

00:28:31.778 --> 00:28:36.016 align:start position:21% line:-2
この述語やインデックスなしに
アプリケーションを実行する場合も

00:28:36.116 --> 00:28:38.519 align:start position:25% line:-1
同じ結果を見ることができます

00:28:38.619 --> 00:28:42.089 align:start position:21% line:-2
そこではタイムスタンプの
インデックスだけがヒットされます

00:28:43.423 --> 00:28:46.527 align:start position:21% line:-2
一方 実行に
新しいインデックスと述語を使う時

00:28:46.627 --> 00:28:49.730 align:start position:16% line:-2
SQLiteは そのインデックスを使い
間にあるコードに対し

00:28:49.830 --> 00:28:53.267 align:start position:29% line:-1
より速い結果を生成します

00:28:54.902 --> 00:28:57.604 align:start position:30% line:-2
ただ タイムスタンプの
インデックスは

00:28:57.704 --> 00:28:59.773 align:start position:34% line:-2
境界を作る述語を
１つも持たないため

00:28:59.873 --> 00:29:02.242 align:start position:32% line:-2
SQLiteはそれを
ソートに使えません

00:28:59.873 --> 00:29:02.242 align:start position:32% line:-2
SQLiteはそれを
ソートに使えません

00:29:03.510 --> 00:29:06.313 align:start position:27% line:-2
そこで選んだ最適化の方法は
複合インデックスを使い

00:29:06.413 --> 00:29:10.884 align:start position:21% line:-2
まず結果セットを
小さなオブジェクトのセットに変え

00:29:10.984 --> 00:29:14.121 align:start position:21% line:-2
ORDER BY用にインメモリで
B-treeをソートすることです

00:29:16.223 --> 00:29:18.559 align:start position:21% line:-1
ご覧のように このインデックスは

00:29:18.659 --> 00:29:22.529 align:start position:27% line:-2
フェッチのパフォーマンスを
約25％向上させます

00:29:23.864 --> 00:29:28.635 align:start position:21% line:-2
このケースでは性能テストを
10万行以上にわたり行ったところ

00:29:28.735 --> 00:29:33.307 align:start position:20% line:-2
フェッチだけで
約130ミリ秒の改善が見られました

00:29:34.608 --> 00:29:37.811 align:start position:27% line:-2
ここでCore Dataの
テストの話に移りましょう

00:29:38.545 --> 00:29:42.783 align:start position:27% line:-2
ご存じかもしれませんが
私たちはテストが大好きです

00:29:42.883 --> 00:29:44.384 align:start position:30% line:-1
Core Dataでは

00:29:44.484 --> 00:29:48.722 align:start position:25% line:-2
正確性と学習性の両方の観点で
テストを行います

00:29:48.822 --> 00:29:54.595 align:start position:20% line:-2
Core Dataの機能や
APIの動作を確認する上で重要です

00:29:55.229 --> 00:30:00.234 align:start position:18% line:-2
また Core Dataの機能に関し
仮説を検証する上でも有効です

00:29:55.229 --> 00:30:00.234 align:start position:18% line:-2
また Core Dataの機能に関し
仮説を検証する上でも有効です

00:30:00.334 --> 00:30:03.971 align:start position:29% line:-2
よりよい顧客体験のための
手助けとなるのです

00:30:04.271 --> 00:30:08.642 align:start position:16% line:-2
R-treeインデックスは たとえ
インメモリでB-treeをソートしても

00:30:08.742 --> 00:30:12.446 align:start position:34% line:-2
パフォーマンスに
恩恵をもたらします

00:30:14.481 --> 00:30:18.652 align:start position:30% line:-2
テストは動作環境を
把握する上でも大切です

00:30:18.752 --> 00:30:22.589 align:start position:27% line:-2
皆さんが何を求めているかが
分かるからです

00:30:22.689 --> 00:30:26.460 align:start position:25% line:-2
皆さんが顧客のために
どんな動作を望んでいるのかは

00:30:26.560 --> 00:30:28.862 align:start position:29% line:-1
テストで明らかにできます

00:30:29.596 --> 00:30:33.233 align:start position:25% line:-2
これを自力で簡単に行うために
重要なものがあります

00:30:33.700 --> 00:30:37.571 align:start position:25% line:-2
例えば永続コンテナを生成する
ベースクラスなどです

00:30:38.338 --> 00:30:39.706 align:start position:30% line:-1
こちらのベースクラスは

00:30:39.807 --> 00:30:44.044 align:start position:14% line:-2
たまたま永続ストア用の
/dev/nullのURLを使っています

00:30:44.144 --> 00:30:48.015 align:start position:25% line:-2
これによりテストは 小さな
管理オブジェクトのセット上で

00:30:48.115 --> 00:30:50.017 align:start position:30% line:-1
非常に素早く行われます

00:30:50.117 --> 00:30:52.386 align:start position:36% line:-2
全てメモリの中で
行われるからです

00:30:52.653 --> 00:30:57.057 align:start position:23% line:-2
この時 SQLiteは
インメモリストアを実現させます

00:30:57.157 --> 00:30:59.927 align:start position:34% line:-2
非常に効率的ですが
インメモリなので

00:31:00.027 --> 00:31:03.831 align:start position:21% line:-2
データ量次第ではテストスイートの
メモリを増大させてしまいます

00:31:07.835 --> 00:31:10.938 align:start position:25% line:-2
ストアファイルをディスク上に
具現化するテストは

00:31:11.038 --> 00:31:13.841 align:start position:23% line:-1
少なくとも１回は実行すべきです

00:31:14.274 --> 00:31:17.344 align:start position:27% line:-2
皆さんがテストスイート用の
ストアを開けない場合

00:31:17.444 --> 00:31:19.746 align:start position:25% line:-2
顧客もそれを開けない可能性が
高いからです

00:31:20.948 --> 00:31:23.851 align:start position:23% line:-2
アプリケーションデリゲート内に
永続コンテナがあるのなら

00:31:23.951 --> 00:31:26.553 align:start position:25% line:-2
コンテナを取り上げ ストアに
直接書き込める―

00:31:26.653 --> 00:31:28.789 align:start position:25% line:-1
テストベースクラスを持てます

00:31:29.189 --> 00:31:32.559 align:start position:23% line:-2
しかしその場合 皆さんが
書き込んでいるストアファイルは

00:31:32.659 --> 00:31:36.797 align:start position:21% line:-2
アプリケーションによって
使用されているため注意が必要です

00:31:36.897 --> 00:31:39.466 align:start position:30% line:-2
もし 個人のデバイスで
テストを実行するなら

00:31:39.566 --> 00:31:43.437 align:start position:23% line:-2
次にアプリケーションを開いた時
その効果が分かるでしょう

00:31:47.441 --> 00:31:51.545 align:start position:20% line:-2
10万件のレコードを７行のコードで
挿入できるとしたら？

00:31:53.747 --> 00:31:57.684 align:start position:23% line:-2
これは練習問題として
あとに取っておくつもりでしたが

00:31:57.785 --> 00:32:00.854 align:start position:21% line:-2
こうしたスキャフォールディングが
可能にするのは

00:31:57.785 --> 00:32:00.854 align:start position:21% line:-2
こうしたスキャフォールディングが
可能にするのは

00:32:00.954 --> 00:32:04.358 align:start position:25% line:-2
データ回りの不変性を評価する
テストスイートの構築です

00:32:04.958 --> 00:32:08.095 align:start position:25% line:-2
これらのメソッドを
前もってビルドしておくことで

00:32:08.195 --> 00:32:12.966 align:start position:27% line:-2
例えばデータが変化した際も
繰り返し使うことができます

00:32:13.066 --> 00:32:16.470 align:start position:21% line:-2
オブジェクトグラフ用の仕組みや
新しいエッジクラスをビルドしたり

00:32:16.570 --> 00:32:20.174 align:start position:23% line:-2
パフォーマンスなど
バックグラウンドの特定の動作を

00:32:20.607 --> 00:32:22.142 align:start position:30% line:-1
評価したりするためです

00:32:23.710 --> 00:32:28.749 align:start position:16% line:-2
R-treeクエリの性能テストで使った
単体テストのスキャフォールドです

00:32:29.083 --> 00:32:30.651 align:start position:27% line:-1
フェッチのパフォーマンスは

00:32:30.751 --> 00:32:34.188 align:start position:32% line:-2
数行のコードで
確実なものにできます

00:32:34.721 --> 00:32:38.759 align:start position:20% line:-2
Core Dataの特徴や機能間の
トレードオフを評価する上で

00:32:38.859 --> 00:32:41.795 align:start position:21% line:-1
こうしたテストは非常に役立ちます

00:32:45.232 --> 00:32:48.302 align:start position:23% line:-2
この３行のコードが生成するのは
テストで使うための

00:32:48.402 --> 00:32:51.205 align:start position:25% line:-2
新しい管理オブジェクト
コンテキストと コンテナです

00:32:51.638 --> 00:32:54.041 align:start position:32% line:-1
これは極めて重要です

00:32:54.141 --> 00:32:56.910 align:start position:25% line:-2
テストにおけるセットアップと
テアダウンのロジックは

00:32:57.010 --> 00:32:59.413 align:start position:29% line:-2
時にそのパフォーマンスに
影響を及ぼすからです

00:32:59.580 --> 00:33:02.449 align:start position:25% line:-1
自分が今 テストしているのは

00:32:59.580 --> 00:33:02.449 align:start position:25% line:-1
自分が今 テストしているのは

00:33:02.549 --> 00:33:06.019 align:start position:23% line:-2
テアダウンのパフォーマンスか
セットアップのパフォーマンスか

00:33:06.120 --> 00:33:09.423 align:start position:29% line:-2
クエリのランタイムかなど
分析しましょう

00:33:10.424 --> 00:33:14.361 align:start position:34% line:-2
テストが終わると
バグを報告できます

00:33:15.429 --> 00:33:16.630 align:start position:36% line:-1
バグは大歓迎です

00:33:16.730 --> 00:33:20.934 align:start position:21% line:-2
よりよいアプリケーションのために
必要なものですからね

00:33:21.101 --> 00:33:23.504 align:start position:27% line:-1
しかし バグの報告にあたり

00:33:23.604 --> 00:33:27.274 align:start position:23% line:-2
テストやサンプルAppがないと
対処が非常に困難です

00:33:27.374 --> 00:33:31.879 align:start position:29% line:-2
先ほど話したように
皆さんの動作環境や要望は

00:33:31.979 --> 00:33:34.748 align:start position:29% line:-2
緻密なテストによってこそ
正確に把握できます

00:33:35.249 --> 00:33:39.119 align:start position:25% line:-2
実際 テストスイートを有する
アプリケーションや

00:33:39.219 --> 00:33:43.657 align:start position:29% line:-2
皆さんの懸念事項が明確な
サンプルがあるだけで

00:33:43.991 --> 00:33:47.861 align:start position:27% line:-2
私たちは
いち早くレスポンスできます

00:33:47.961 --> 00:33:52.933 align:start position:25% line:-2
そして対処法を
お伝えすることができるのです

00:33:53.500 --> 00:33:56.837 align:start position:25% line:-2
またテストは 修復の正確性の
検証にも役立ちます

00:33:56.937 --> 00:34:01.942 align:start position:23% line:-2
バグ報告の際は まずはテストを
書くようにしてください

00:33:56.937 --> 00:34:01.942 align:start position:23% line:-2
バグ報告の際は まずはテストを
書くようにしてください

00:34:04.545 --> 00:34:05.846 align:start position:38% line:-1
本日は以上です

00:34:06.880 --> 00:34:12.319 align:start position:12% line:-2
明日はTechnology Lab 7にて
１時半からお待ちしています

00:34:12.418 --> 00:34:17.891 align:start position:5% line:-2
明日のTesting Tips & Tricksも
ぜひご覧ください

00:34:19.226 --> 00:34:19.960 align:start position:41% line:-1
ありがとう

00:34:20.060 --> 00:34:22.562 align:start position:43% line:-1
(拍手)
