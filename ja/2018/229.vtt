WEBVTT

00:00:07.074 --> 00:00:16.015 align:start position:43% line:-1
(音楽)

00:00:17.050 --> 00:00:21.221 align:start position:43% line:-1
(拍手)

00:00:21.922 --> 00:00:22.890 align:start position:45% line:-1
どうも

00:00:23.957 --> 00:00:27.961 align:start position:23% line:-2
私はコレクションの開発チームの
マイケルです

00:00:28.962 --> 00:00:32.131 align:start position:30% line:-2
今日はSwiftで
コレクションを使う際に

00:00:32.232 --> 00:00:35.936 align:start position:29% line:-2
知っておくべきポイントを
お話しします

00:00:37.070 --> 00:00:39.239 align:start position:21% line:-1
Swiftで使えるコレクションの

00:00:39.339 --> 00:00:43.644 align:start position:34% line:-2
いろいろな側面を
詳しく見ていきます

00:00:43.777 --> 00:00:47.948 align:start position:34% line:-2
よくある落とし穴や
その防ぎ方も紹介し

00:00:48.048 --> 00:00:52.886 align:start position:29% line:-2
コレクションを使う際の
特別なアドバイスもします

00:00:53.187 --> 00:00:53.887 align:start position:39% line:-1
始めましょう

00:00:54.988 --> 00:00:59.793 align:start position:29% line:-2
コレクションのない世界を
想像してください

00:01:01.795 --> 00:01:05.833 align:start position:30% line:-2
配列も存在しませんが
クマのbearはいます

00:01:07.067 --> 00:01:08.902 align:start position:30% line:-1
しかしbearごとに―

00:01:09.770 --> 00:01:15.375 align:start position:29% line:-2
自分で新しい変数を
定義しなければなりません

00:01:16.210 --> 00:01:17.511 align:start position:39% line:-1
大変ですね？

00:01:18.478 --> 00:01:21.748 align:start position:30% line:-1
さらに辞書もありません

00:01:22.416 --> 00:01:26.553 align:start position:36% line:-2
しかし関数を
回避策に使えます

00:01:26.787 --> 00:01:30.057 align:start position:25% line:-1
１回ずつ定義すればいいのです

00:01:30.657 --> 00:01:33.460 align:start position:29% line:-1
機能は辞書とほぼ同じです

00:01:33.560 --> 00:01:38.265 align:start position:32% line:-2
可変性はありませんが
可変状態は嫌ですよね

00:01:38.866 --> 00:01:41.602 align:start position:30% line:-1
しかし 現実は違います

00:01:42.302 --> 00:01:47.774 align:start position:23% line:-2
bearとコレクションが存在し
シンタックスもあります

00:01:49.543 --> 00:01:56.216 align:start position:21% line:-2
APIを使い 要素の反復や取得で
作業の繰り返しを避けられます

00:01:57.551 --> 00:02:01.488 align:start position:23% line:-2
コレクションは
Swiftの共通のプロトコルに

00:01:57.551 --> 00:02:01.488 align:start position:23% line:-2
コレクションは
Swiftの共通のプロトコルに

00:02:01.588 --> 00:02:03.857 align:start position:32% line:-1
すべて適合しています

00:02:04.992 --> 00:02:07.294 align:start position:32% line:-1
その名もコレクション

00:02:08.127 --> 00:02:12.266 align:start position:29% line:-2
要素が複数回 走査できる
シーケンスで

00:02:12.366 --> 00:02:16.036 align:start position:30% line:-2
サブスクリプトによって
アクセスできます

00:02:17.771 --> 00:02:21.942 align:start position:27% line:-2
どのように使うか
イメージで見ていきましょう

00:02:22.943 --> 00:02:27.948 align:start position:27% line:-2
これを ハッシュテーブルや
赤黒木などで定義された―

00:02:28.782 --> 00:02:31.118 align:start position:36% line:-1
配列としましょう

00:02:31.418 --> 00:02:35.856 align:start position:29% line:-2
これは開始インデックスの
サポートをします

00:02:36.757 --> 00:02:40.027 align:start position:27% line:-1
最初の要素にアクセスします

00:02:40.494 --> 00:02:43.630 align:start position:30% line:-2
終わりを示す
終了インデックスがあり

00:02:44.131 --> 00:02:48.602 align:start position:29% line:-2
最初から最後までの
反復機能をサポートします

00:02:49.403 --> 00:02:51.338 align:start position:34% line:-1
何度も使えるのです

00:02:51.438 --> 00:02:56.276 align:start position:29% line:-2
コレクションの要素を
検索するのにも役立ちます

00:02:57.411 --> 00:02:58.812 align:start position:30% line:-1
コードを見てみましょう

00:02:59.680 --> 00:03:04.117 align:start position:30% line:-2
要素のシーケンスとして
宣言されています

00:02:59.680 --> 00:03:04.117 align:start position:30% line:-2
要素のシーケンスとして
宣言されています

00:03:04.785 --> 00:03:09.256 align:start position:27% line:-2
また追加の関連型が
インデックスとされています

00:03:10.457 --> 00:03:14.361 align:start position:30% line:-2
これでサブスクリプトが
要素を読み出せ

00:03:14.661 --> 00:03:18.799 align:start position:27% line:-2
開始と終了のインデックスを
定義できます

00:03:18.899 --> 00:03:25.005 align:start position:18% line:-2
最後に index(after:)で
他のインデックスへ移動できます

00:03:25.539 --> 00:03:27.741 align:start position:34% line:-1
この機能は重要です

00:03:27.841 --> 00:03:30.244 align:start position:36% line:-1
標準ライブラリが

00:03:30.344 --> 00:03:35.315 align:start position:25% line:-2
プロトコル拡張を伴う 有用な
デフォルト動作を定義できます

00:03:35.415 --> 00:03:36.750 align:start position:36% line:-1
例をお見せします

00:03:38.385 --> 00:03:42.523 align:start position:29% line:-2
コレクションに適合すると
機能が増えます

00:03:42.623 --> 00:03:46.226 align:start position:25% line:-1
最初と最後の要素が得られたり

00:03:46.326 --> 00:03:50.097 align:start position:30% line:-2
カウントや空かどうかの
確認ができます

00:03:50.397 --> 00:03:54.635 align:start position:25% line:-2
4nシンタックスで反復できる
APIも使えます

00:03:55.302 --> 00:03:58.605 align:start position:20% line:-2
mapやfilter
reduceも使えるようになります

00:03:59.139 --> 00:04:02.809 align:start position:21% line:-2
では 独自のExtensionで
よりパワフルにしましょう

00:03:59.139 --> 00:04:02.809 align:start position:21% line:-2
では 独自のExtensionで
よりパワフルにしましょう

00:04:03.944 --> 00:04:06.647 align:start position:30% line:-2
コレクションで
要素の反復ができますが

00:04:06.747 --> 00:04:12.753 align:start position:23% line:-2
いくつかの要素をスキップして
１つおきに反復させたいとします

00:04:13.453 --> 00:04:15.889 align:start position:25% line:-1
これは拡張することで可能です

00:04:15.989 --> 00:04:17.658 align:start position:30% line:-1
メソッドシグネチャです

00:04:18.125 --> 00:04:23.530 align:start position:29% line:-2
１つおきに関数を呼び
要素をクロージャとします

00:04:24.064 --> 00:04:27.901 align:start position:34% line:-2
反復の範囲を決め
他の変数を求めます

00:04:28.001 --> 00:04:31.205 align:start position:23% line:-1
これを“start”で始めます

00:04:32.105 --> 00:04:35.509 align:start position:25% line:-1
現在の要素のクロージャを呼び

00:04:35.742 --> 00:04:37.811 align:start position:27% line:-1
次のインデックスへ進みます

00:04:37.911 --> 00:04:43.150 align:start position:29% line:-2
この時点でインデックスが
無効になっているか確認し

00:04:43.250 --> 00:04:46.220 align:start position:23% line:-1
もう一度インデックスを進めると

00:04:46.353 --> 00:04:48.255 align:start position:36% line:-1
要素を飛ばせます

00:04:48.355 --> 00:04:51.959 align:start position:20% line:-1
１から10までのレンジで実行すると

00:04:52.059 --> 00:04:54.495 align:start position:32% line:-1
飛ばしたのは偶数です

00:04:55.896 --> 00:04:59.433 align:start position:32% line:-2
これがコレクションの
すばらしい機能ですが

00:05:00.133 --> 00:05:03.871 align:start position:29% line:-2
我々には
別のプロトコルもあります

00:05:03.971 --> 00:05:07.574 align:start position:18% line:-1
Swiftでは様々なプロトコルが使え

00:05:07.674 --> 00:05:11.378 align:start position:25% line:-1
それぞれが進化を遂げています

00:05:11.678 --> 00:05:13.514 align:start position:30% line:-1
いくつか紹介しましょう

00:05:14.648 --> 00:05:18.685 align:start position:32% line:-2
インデックスを進める
コレクション以外に

00:05:19.586 --> 00:05:23.257 align:start position:21% line:-1
二方向性のコレクションがあります

00:05:24.825 --> 00:05:27.895 align:start position:29% line:-2
二方向性も
コレクションではあるので

00:05:27.995 --> 00:05:30.063 align:start position:38% line:-1
反復はできます

00:05:31.532 --> 00:05:35.269 align:start position:30% line:-2
無作為アクセスの
コレクションもあります

00:05:35.369 --> 00:05:40.007 align:start position:30% line:-2
これは 一定時間で
インデックス間の計算や

00:05:40.107 --> 00:05:44.244 align:start position:34% line:-2
その距離を計算する
要件を追加します

00:05:44.378 --> 00:05:50.083 align:start position:21% line:-2
コンパイラはこれを実行しないので
無作為アクセスに適合する時は

00:05:50.484 --> 00:05:52.686 align:start position:36% line:-1
自分で対応します

00:05:52.786 --> 00:05:57.558 align:start position:27% line:-2
どのインデックスにも
一定時間でアクセスできます

00:05:57.958 --> 00:06:00.294 align:start position:25% line:-1
もちろん無作為アクセスは残り

00:05:57.958 --> 00:06:00.294 align:start position:25% line:-1
もちろん無作為アクセスは残り

00:06:00.394 --> 00:06:02.963 align:start position:34% line:-1
前後に反復できます

00:06:04.298 --> 00:06:08.769 align:start position:21% line:-2
これらのプロトコルに適合した
便利なコレクションが多数あります

00:06:10.170 --> 00:06:12.439 align:start position:32% line:-1
配列や集合 辞書です

00:06:13.974 --> 00:06:17.044 align:start position:32% line:-2
この多目的な
プロトコルのおかげで

00:06:17.144 --> 00:06:21.815 align:start position:29% line:-2
データやレンジ
文字列などにも適合します

00:06:22.850 --> 00:06:26.520 align:start position:25% line:-1
コレクションに適合するだけで

00:06:26.620 --> 00:06:29.256 align:start position:29% line:-1
豊富な機能が使えるのです

00:06:29.356 --> 00:06:36.230 align:start position:23% line:-2
１つの型の使い方が分かったら
他の型にも当てはめられるのです

00:06:37.164 --> 00:06:40.801 align:start position:23% line:-1
では 型をコレクションに適合し

00:06:40.901 --> 00:06:44.538 align:start position:23% line:-1
インデックス化する方法について

00:06:46.340 --> 00:06:48.675 align:start position:23% line:-1
各コレクションのインデックスは

00:06:49.810 --> 00:06:51.645 align:start position:27% line:-2
Comparableである
必要があります

00:06:52.212 --> 00:06:56.517 align:start position:32% line:-2
配列のような場合は
整数の形を取りますが

00:06:56.617 --> 00:07:00.754 align:start position:21% line:-1
整数のように扱う必要はありません

00:06:56.617 --> 00:07:00.754 align:start position:21% line:-1
整数のように扱う必要はありません

00:07:01.355 --> 00:07:04.725 align:start position:32% line:-2
驚きの事実を
いくつか教えましょう

00:07:05.058 --> 00:07:07.528 align:start position:25% line:-1
まずは 配列の最初の要素です

00:07:08.562 --> 00:07:12.766 align:start position:30% line:-2
列をサブゼロにする人が
多いと思います

00:07:12.900 --> 00:07:14.568 align:start position:29% line:-1
インデックスはIntです

00:07:14.668 --> 00:07:19.506 align:start position:32% line:-2
この方法は使えますが
ベストではありません

00:07:19.640 --> 00:07:23.544 align:start position:23% line:-2
同じことを
違うコレクションでやりましょう

00:07:25.078 --> 00:07:26.713 align:start position:32% line:-1
集合の最初の要素は？

00:07:26.914 --> 00:07:30.684 align:start position:29% line:-2
変な質問ですね
集合に順番はないからです

00:07:30.951 --> 00:07:34.288 align:start position:34% line:-2
同時に 反復可能な
コレクションで

00:07:34.388 --> 00:07:37.591 align:start position:30% line:-2
反復する際は
１つの要素から始めます

00:07:37.691 --> 00:07:39.927 align:start position:32% line:-1
つまり質問はこうです

00:07:40.828 --> 00:07:42.362 align:start position:30% line:-1
サブゼロは使えますか？

00:07:42.963 --> 00:07:48.535 align:start position:25% line:-2
インデックス型はIntなので
コンパイラには却下され

00:07:48.902 --> 00:07:51.772 align:start position:30% line:-1
正しい型を要求されます

00:07:52.906 --> 00:07:54.608 align:start position:30% line:-1
すでにコレクションでの

00:07:54.708 --> 00:07:57.678 align:start position:27% line:-2
開始インデックスの付け方は
ご存知ですね

00:07:57.778 --> 00:08:01.315 align:start position:23% line:-2
これは すべてのコレクションで
使えます

00:07:57.778 --> 00:08:01.315 align:start position:23% line:-2
これは すべてのコレクションで
使えます

00:08:01.415 --> 00:08:06.720 align:start position:21% line:-2
開始インデックスは
反復の際に 最初に現れる要素です

00:08:06.920 --> 00:08:11.658 align:start position:27% line:-2
しかし これを利用する際の
注意点があります

00:08:12.926 --> 00:08:15.429 align:start position:30% line:-1
クラッシュの危険性です

00:08:16.063 --> 00:08:19.399 align:start position:25% line:-1
コレクションに中身がなければ

00:08:19.500 --> 00:08:22.736 align:start position:30% line:-2
インデックスを付けても
中は空です

00:08:23.504 --> 00:08:29.510 align:start position:29% line:-2
最初の要素に行くのは
もっといい方法があります

00:08:30.978 --> 00:08:32.513 align:start position:29% line:-1
firstを呼ぶだけです

00:08:32.846 --> 00:08:37.116 align:start position:36% line:-2
戻り型が任意で
この方が安全です

00:08:37.217 --> 00:08:40.320 align:start position:23% line:-1
最初の要素がない場合も使えます

00:08:42.389 --> 00:08:43.724 align:start position:39% line:-1
別の質問です

00:08:44.591 --> 00:08:46.293 align:start position:36% line:-1
２番目の要素は？

00:08:46.393 --> 00:08:48.095 align:start position:36% line:-1
今話しているのは

00:08:48.195 --> 00:08:52.032 align:start position:25% line:-2
配列でも集合でも
どのコレクションでもいいです

00:08:52.833 --> 00:08:56.770 align:start position:30% line:-2
拡張のプロパティを加え
secondとします

00:08:56.870 --> 00:09:01.275 align:start position:16% line:-1
firstの場合と同様 戻りは任意です

00:08:56.870 --> 00:09:01.275 align:start position:16% line:-1
firstの場合と同様 戻りは任意です

00:09:02.109 --> 00:09:06.613 align:start position:23% line:-2
では サブスクリプトの“１”と
しましょう

00:09:06.713 --> 00:09:12.352 align:start position:25% line:-2
しかし ０オリジンでは使えず
コンパイラに注意されます

00:09:13.820 --> 00:09:18.458 align:start position:29% line:-2
すべてのコレクションで
このコードを使いたければ

00:09:18.926 --> 00:09:20.627 align:start position:34% line:-1
別のやり方をします

00:09:21.161 --> 00:09:24.198 align:start position:20% line:-1
startIndex + 1ですが

00:09:25.599 --> 00:09:28.235 align:start position:27% line:-1
コンパイラに引っかかります

00:09:29.036 --> 00:09:34.408 align:start position:30% line:-2
不透明のインデックスに
“１”は付けられません

00:09:35.576 --> 00:09:40.280 align:start position:21% line:-1
APIを使ってこれを可能にします

00:09:40.380 --> 00:09:41.748 align:start position:36% line:-1
やってみましょう

00:09:42.616 --> 00:09:47.020 align:start position:30% line:-2
２番目の要素を
見つける指示をしました

00:09:47.154 --> 00:09:50.591 align:start position:27% line:-2
まずはコレクションが空かを
確認します

00:09:51.024 --> 00:09:54.695 align:start position:29% line:-2
開始と終了インデックスが
等しい時は空です

00:09:54.795 --> 00:09:56.997 align:start position:30% line:-1
そしてnilを返します

00:09:57.397 --> 00:10:01.268 align:start position:27% line:-1
２番目の要素がないからです

00:09:57.397 --> 00:10:01.268 align:start position:27% line:-1
２番目の要素がないからです

00:10:03.103 --> 00:10:06.473 align:start position:29% line:-2
このコレクションには
要素が１つしかありません

00:10:07.774 --> 00:10:11.445 align:start position:30% line:-2
２つ目の要素があれば
インデックスが使えます

00:10:11.545 --> 00:10:15.115 align:start position:32% line:-2
インデックスが有効か
確認すべきです

00:10:15.215 --> 00:10:19.720 align:start position:29% line:-2
しかし要素が１つの場合
無効なインデックスになり

00:10:19.820 --> 00:10:23.457 align:start position:29% line:-2
前のように
致命的なエラーになります

00:10:23.557 --> 00:10:26.093 align:start position:29% line:-1
そのため 有効にする前に

00:10:26.193 --> 00:10:30.430 align:start position:32% line:-2
前と同じ手順で確認し
nilを返します

00:10:30.531 --> 00:10:35.502 align:start position:27% line:-2
要素が１つのコレクションは
２番目の要素がないからです

00:10:35.969 --> 00:10:40.274 align:start position:30% line:-2
コレクションに
２つ以上の要素があれば

00:10:40.374 --> 00:10:43.143 align:start position:21% line:-1
安全にこのインデックスが使えます

00:10:43.844 --> 00:10:45.646 align:start position:30% line:-1
そして値も取得できます

00:10:47.147 --> 00:10:50.017 align:start position:30% line:-1
長いコードのようですが

00:10:50.117 --> 00:10:54.188 align:start position:23% line:-2
これは すべてのコレクションで
使えます

00:10:54.288 --> 00:10:58.492 align:start position:29% line:-2
しかし Swiftでは
もっといい方法があります

00:10:58.826 --> 00:11:00.494 align:start position:34% line:-1
それがスライスです

00:10:58.826 --> 00:11:00.494 align:start position:34% line:-1
それがスライスです

00:11:00.594 --> 00:11:05.532 align:start position:25% line:-2
まずは それがどういうものか
説明します

00:11:08.168 --> 00:11:12.306 align:start position:23% line:-2
スライスはコレクションの一部を
切り取る型です

00:11:13.173 --> 00:11:16.810 align:start position:25% line:-1
開始と終了インデックスがあり

00:11:17.077 --> 00:11:21.281 align:start position:32% line:-2
元のコレクションとは
別個に存在します

00:11:21.448 --> 00:11:27.020 align:start position:27% line:-2
スライスは容量を取らない
元のコレクションの参照です

00:11:27.754 --> 00:11:31.992 align:start position:29% line:-2
スライスは元のバッファを
読み込みます

00:11:32.759 --> 00:11:37.364 align:start position:21% line:-2
コレクションと同じインデックスを
使っているからです

00:11:37.464 --> 00:11:40.000 align:start position:30% line:-1
機能の仕方を見ましょう

00:11:40.100 --> 00:11:46.640 align:start position:21% line:-2
まず 最初の要素を落とし
要素が１つ少ないスライスにします

00:11:47.107 --> 00:11:51.645 align:start position:30% line:-2
開始インデックスの
次に進むよう指示すると

00:11:51.745 --> 00:11:55.382 align:start position:30% line:-2
それが２番目の
インデックスになります

00:11:55.482 --> 00:11:57.117 align:start position:36% line:-1
確かに同じですね

00:11:58.452 --> 00:12:03.156 align:start position:27% line:-2
dropFirstで簡単に
２番目の要素に行けます

00:11:58.452 --> 00:12:03.156 align:start position:27% line:-2
dropFirstで簡単に
２番目の要素に行けます

00:12:03.690 --> 00:12:07.461 align:start position:23% line:-2
では スライスがどれほど便利か
見てみましょう

00:12:08.629 --> 00:12:11.865 align:start position:21% line:-1
かつては複雑なコードが必要でした

00:12:12.766 --> 00:12:17.671 align:start position:18% line:-2
長いインデックスを
dropFirstで置き換えられます

00:12:17.938 --> 00:12:20.040 align:start position:30% line:-1
最初の戻りは任意なので

00:12:20.874 --> 00:12:24.745 align:start position:21% line:-2
空や１つの要素のコレクションでも
使えます

00:12:25.045 --> 00:12:26.713 align:start position:32% line:-1
結果を見てみましょう

00:12:27.614 --> 00:12:31.485 align:start position:34% line:-2
配列の最初の要素を
切り落としました

00:12:32.352 --> 00:12:35.189 align:start position:29% line:-1
そしてスライス内に記述し

00:12:35.622 --> 00:12:39.793 align:start position:32% line:-2
コレクションから
要素を取り出しました

00:12:39.893 --> 00:12:42.796 align:start position:30% line:-1
断然この方が楽ですよね

00:12:44.865 --> 00:12:48.402 align:start position:32% line:-2
スライスは 型ごとに
定義付けられます

00:12:48.602 --> 00:12:50.270 align:start position:36% line:-1
例えば 配列では

00:12:50.370 --> 00:12:54.775 align:start position:21% line:-2
最も一般的な
ArraySliceを定義します

00:12:54.875 --> 00:12:58.712 align:start position:36% line:-1
文字列も同様に―

00:12:58.946 --> 00:13:02.649 align:start position:20% line:-1
最も一般的なSubstringです

00:12:58.946 --> 00:13:02.649 align:start position:20% line:-1
最も一般的なSubstringです

00:13:03.283 --> 00:13:05.552 align:start position:34% line:-1
集合のような型では

00:13:05.953 --> 00:13:09.189 align:start position:23% line:-1
一般的なスライスの型を使います

00:13:09.289 --> 00:13:11.658 align:start position:27% line:-1
集合には順番がないからです

00:13:11.758 --> 00:13:16.163 align:start position:21% line:-2
基本的に開始と終了インデックスが
必要です

00:13:16.830 --> 00:13:20.133 align:start position:32% line:-2
データやレンジには
独自のスライスがあり

00:13:20.267 --> 00:13:22.636 align:start position:36% line:-1
選択肢は様々です

00:13:22.903 --> 00:13:26.173 align:start position:27% line:-1
スライスについて もう１つ

00:13:27.674 --> 00:13:32.446 align:start position:30% line:-2
何千もの要素がある
巨大なコレクションから

00:13:33.113 --> 00:13:35.749 align:start position:21% line:-1
いくつかをスライスで切り出します

00:13:36.583 --> 00:13:43.457 align:start position:23% line:-2
ただし スライスをしても
元のコレクションは生きています

00:13:43.557 --> 00:13:46.693 align:start position:29% line:-1
そのために問題も起きます

00:13:48.061 --> 00:13:51.431 align:start position:20% line:-1
例えば dropLastを使った―

00:13:51.532 --> 00:13:55.502 align:start position:21% line:-2
配列の前半を戻す
Extensionがあるとします

00:13:55.836 --> 00:14:00.841 align:start position:16% line:-2
８つの数字の配列があり
Extensionを呼びスライスします

00:13:55.836 --> 00:14:00.841 align:start position:16% line:-2
８つの数字の配列があり
Extensionを呼びスライスします

00:14:00.941 --> 00:14:04.011 align:start position:29% line:-2
そして元の
８つのストレージを消して

00:14:04.111 --> 00:14:06.380 align:start position:32% line:-1
この配列を空にします

00:14:07.481 --> 00:14:13.120 align:start position:30% line:-2
最初の要素を求めると
興味深いことが起きます

00:14:13.487 --> 00:14:17.424 align:start position:30% line:-2
元のストレージを
空にしたにもかかわらず

00:14:17.524 --> 00:14:19.393 align:start position:36% line:-1
１を返せるのです

00:14:19.493 --> 00:14:22.629 align:start position:29% line:-1
コピーされたのでしょうか

00:14:23.230 --> 00:14:30.070 align:start position:23% line:-2
バッファを消去したかったのに
残っていたとしたら 魔法ですね

00:14:30.170 --> 00:14:35.375 align:start position:23% line:-2
完全に消去するには
スライスから配列をコピーします

00:14:35.809 --> 00:14:40.614 align:start position:29% line:-2
そのスライスを空にしても
コピーは成立します

00:14:41.381 --> 00:14:42.482 align:start position:38% line:-1
見てみましょう

00:14:43.183 --> 00:14:47.588 align:start position:32% line:-2
まずは配列の
前半をスライスします

00:14:49.823 --> 00:14:53.760 align:start position:21% line:-1
コピーをした上で配列を空にします

00:14:53.861 --> 00:14:56.730 align:start position:27% line:-1
そしてスライスも空にします

00:14:57.731 --> 00:14:59.466 align:start position:27% line:-1
元のストレージが消えました

00:15:01.134 --> 00:15:04.104 align:start position:30% line:-1
遅延コピーと似ています

00:15:04.204 --> 00:15:07.741 align:start position:32% line:-2
コピーのタイミングを
指定できるのです

00:15:08.242 --> 00:15:14.414 align:start position:27% line:-2
このように遅延であることが
別のところで役立ちます

00:15:15.482 --> 00:15:17.818 align:start position:29% line:-1
例えば関数の呼び出しです

00:15:18.719 --> 00:15:21.622 align:start position:25% line:-1
Swiftでは先行となります

00:15:21.989 --> 00:15:26.393 align:start position:30% line:-2
出入力があると
すぐに処理されるのです

00:15:27.227 --> 00:15:30.531 align:start position:20% line:-2
この例では
１から4000のレンジから始めます

00:15:30.631 --> 00:15:33.734 align:start position:25% line:-1
非常に簡潔な数字の表示方法で

00:15:33.834 --> 00:15:37.004 align:start position:25% line:-1
最初と最後を指定するだけです

00:15:37.237 --> 00:15:39.640 align:start position:34% line:-2
各要素に２を掛けて
マッピングすると

00:15:39.740 --> 00:15:42.609 align:start position:21% line:-1
4000の要素に割り当てられます

00:15:42.709 --> 00:15:45.913 align:start position:25% line:-1
各要素がマッピングされました

00:15:46.346 --> 00:15:48.415 align:start position:27% line:-1
４つの要素にフィルタします

00:15:48.782 --> 00:15:52.753 align:start position:25% line:-2
4004が
割り当てられたことになります

00:15:53.187 --> 00:15:55.255 align:start position:23% line:-1
4004の要素分の容量ですが―

00:15:56.123 --> 00:15:58.025 align:start position:30% line:-1
必要なのは４つだけです

00:16:00.394 --> 00:16:04.331 align:start position:23% line:-1
これには面倒な計算が介在します

00:16:04.698 --> 00:16:08.602 align:start position:29% line:-2
必要最低限に抑えられれば
一番いいですね

00:16:10.270 --> 00:16:13.440 align:start position:21% line:-1
Swiftではlazyを使います

00:16:14.708 --> 00:16:19.780 align:start position:27% line:-2
先ほどのようにレンジを選び
lazyにします

00:16:19.880 --> 00:16:25.786 align:start position:21% line:-2
lazyのコレクションで
元のコレクションをラップしました

00:16:25.919 --> 00:16:30.791 align:start position:29% line:-2
そして 演算を実行すると
またラップするのです

00:16:30.891 --> 00:16:34.228 align:start position:23% line:-1
これをマップしても できません

00:16:34.328 --> 00:16:38.031 align:start position:34% line:-2
このクロージャは
手を加えられません

00:16:38.465 --> 00:16:43.704 align:start position:23% line:-2
lazyのマップコレクションは
フィルタしてもラップされるだけ

00:16:43.804 --> 00:16:46.740 align:start position:36% line:-2
あとで 要求時に
フィルタされます

00:16:47.774 --> 00:16:51.778 align:start position:9% line:-2
このLazyFilterCollectionの
要素は？

00:16:55.482 --> 00:17:00.387 align:start position:7% line:-2
まず LazyFilterCollectionに
最初の要素を要求します

00:16:55.482 --> 00:17:00.387 align:start position:7% line:-2
まず LazyFilterCollectionに
最初の要素を要求します

00:17:00.654 --> 00:17:02.456 align:start position:34% line:-1
しかし認識しません

00:17:02.890 --> 00:17:06.460 align:start position:12% line:-2
そこでLazyMapCollectionに
同じ要求をしますが

00:17:06.560 --> 00:17:10.030 align:start position:23% line:-1
これも最初の要素を認識しません

00:17:10.130 --> 00:17:14.134 align:start position:25% line:-2
しかしコレクションのラップで
レンジが認識します

00:17:14.835 --> 00:17:17.404 align:start position:27% line:-1
最初の要素である値“１”を

00:17:17.503 --> 00:17:19.573 align:start position:11% line:-1
LazyMapCollectionに返します

00:17:19.673 --> 00:17:25.279 align:start position:23% line:-2
クロージャを実行し
値“２”が計算できるようになり

00:17:25.378 --> 00:17:29.082 align:start position:12% line:-2
LazyFilterCollectionに
最初の要素を返せます

00:17:29.249 --> 00:17:32.286 align:start position:30% line:-2
幸いなことに
２は10より小さいので

00:17:32.386 --> 00:17:35.889 align:start position:23% line:-1
最初の要素を見つけられるのです

00:17:36.223 --> 00:17:37.758 align:start position:30% line:-1
これを発信元に戻します

00:17:38.959 --> 00:17:40.961 align:start position:36% line:-1
計算だらけですね

00:17:41.395 --> 00:17:45.766 align:start position:30% line:-2
lazyは要求時にのみ
計算しますが

00:17:45.966 --> 00:17:48.969 align:start position:25% line:-1
中間ストレージを作成しません

00:17:49.369 --> 00:17:50.904 align:start position:36% line:-1
例を見せましょう

00:17:52.306 --> 00:17:54.741 align:start position:29% line:-1
様々なクマがいる配列です

00:17:55.242 --> 00:17:59.046 align:start position:27% line:-1
中にはクマが重複しています

00:17:59.379 --> 00:18:02.349 align:start position:21% line:-1
クマだと繰り返す必要はありません

00:17:59.379 --> 00:18:02.349 align:start position:21% line:-1
クマだと繰り返す必要はありません

00:18:03.283 --> 00:18:09.723 align:start position:23% line:-2
重複したクマ見つけるため
lazy.filterを使うと

00:18:10.791 --> 00:18:16.430 align:start position:5% line:-2
文字列をラップする
lazyFilterCollectionができます

00:18:16.663 --> 00:18:22.169 align:start position:29% line:-2
反復させたいクマを出力し
条件を確認します

00:18:22.269 --> 00:18:26.206 align:start position:20% line:-1
firstというフィルタを使います

00:18:26.306 --> 00:18:29.176 align:start position:5% line:-2
この際 lazyFilterCollectionに
従います

00:18:30.144 --> 00:18:34.882 align:start position:12% line:-2
lazyFilterCollectionは
元のストレージに従い

00:18:36.383 --> 00:18:38.151 align:start position:23% line:-1
“Grizzly”を出力します

00:18:40.587 --> 00:18:46.393 align:start position:12% line:-2
“Grizzly”に“bear”は含まれず
falseなので

00:18:47.261 --> 00:18:48.428 align:start position:29% line:-1
“Panda”に進みます

00:18:50.764 --> 00:18:53.233 align:start position:30% line:-1
“Panda”を出力し

00:18:53.834 --> 00:18:57.237 align:start position:20% line:-2
“bear”を含むか確認し
“Spectacled”に進みます

00:18:57.938 --> 00:19:03.043 align:start position:18% line:-2
“Spectacled”もないので
“Gummy Bears”に進みます

00:18:57.938 --> 00:19:03.043 align:start position:18% line:-2
“Spectacled”もないので
“Gummy Bears”に進みます

00:19:03.544 --> 00:19:05.979 align:start position:30% line:-1
これは含まれていました

00:19:06.613 --> 00:19:10.951 align:start position:12% line:-2
lazyFilterCollectionは
発信元に返します

00:19:11.952 --> 00:19:14.154 align:start position:27% line:-1
firstをまた呼んだら？

00:19:15.189 --> 00:19:15.889 align:start position:43% line:-1
すると―

00:19:17.558 --> 00:19:20.460 align:start position:12% line:-2
同様に
lazyFilterCollectionが

00:19:20.561 --> 00:19:26.166 align:start position:29% line:-2
元のコレクションに従って
計算を繰り返します

00:19:27.935 --> 00:19:34.208 align:start position:25% line:-2
このように 計算を
繰り返させる必要がある場合は

00:19:34.508 --> 00:19:36.743 align:start position:32% line:-1
反復を１度にできます

00:19:37.844 --> 00:19:43.951 align:start position:18% line:-2
nonlazyのコレクションを作れば
反復は１度になります

00:19:44.351 --> 00:19:47.554 align:start position:23% line:-2
同じくlazyのコレクションに
従いますが

00:19:47.654 --> 00:19:52.059 align:start position:25% line:-2
反復は元のコレクション全体で
行われます

00:19:53.727 --> 00:19:57.598 align:start position:21% line:-1
そしてnonlazy版ができます

00:19:57.931 --> 00:20:01.068 align:start position:21% line:-2
“Gummy Bears”を含む
配列に行き

00:19:57.931 --> 00:20:01.068 align:start position:21% line:-2
“Gummy Bears”を含む
配列に行き

00:20:01.468 --> 00:20:03.470 align:start position:32% line:-1
最初の要素を選びます

00:20:03.570 --> 00:20:06.073 align:start position:25% line:-1
クロージャを参照しなくてよく

00:20:06.173 --> 00:20:09.643 align:start position:32% line:-2
遅延ではなく
先行の配列となります

00:20:11.845 --> 00:20:13.313 align:start position:34% line:-1
では遅延の利点は？

00:20:14.081 --> 00:20:18.485 align:start position:25% line:-2
マップやフィルタの
オーバーヘッドを避けられます

00:20:18.585 --> 00:20:22.656 align:start position:29% line:-2
コレクションの計算の
一部が欲しい時に便利です

00:20:23.257 --> 00:20:27.060 align:start position:36% line:-2
クロージャに
影響がある場合は

00:20:27.161 --> 00:20:29.296 align:start position:32% line:-1
使うのは避けましょう

00:20:29.797 --> 00:20:31.732 align:start position:29% line:-1
APIの範囲をまたぐ時は

00:20:31.832 --> 00:20:35.903 align:start position:30% line:-2
標準的なコレクションに
落とし込みましょう

00:20:36.103 --> 00:20:38.405 align:start position:25% line:-1
lazyは実装の詳細なのです

00:20:39.973 --> 00:20:43.877 align:start position:29% line:-2
可変コレクションで
様々なことが可能でしたが

00:20:44.945 --> 00:20:47.948 align:start position:25% line:-2
Swiftは
コレクションも可変的にします

00:20:49.049 --> 00:20:52.152 align:start position:29% line:-2
さらに２種類の
コレクションを紹介します

00:20:53.120 --> 00:20:55.289 align:start position:30% line:-1
まずは可変コレクション

00:20:55.956 --> 00:21:00.260 align:start position:29% line:-2
セッターを加えると
長さを変えず 一定時間で

00:20:55.956 --> 00:21:00.260 align:start position:29% line:-2
セッターを加えると
長さを変えず 一定時間で

00:21:00.360 --> 00:21:02.396 align:start position:34% line:-1
中身を変えられます

00:21:05.566 --> 00:21:10.404 align:start position:23% line:-1
次はレンジ交換可能コレクション

00:21:10.504 --> 00:21:14.541 align:start position:32% line:-2
要素を外したり
挿入する際に使います

00:21:16.043 --> 00:21:18.946 align:start position:25% line:-1
いつも聞かれる質問があります

00:21:20.347 --> 00:21:23.083 align:start position:29% line:-2
完璧なコードが
なぜクラッシュするのか？

00:21:23.784 --> 00:21:27.521 align:start position:25% line:-1
いい問いには 質問で返します

00:21:28.322 --> 00:21:30.991 align:start position:27% line:-1
“何をしようとしたのか？”

00:21:31.792 --> 00:21:34.962 align:start position:34% line:-2
“コレクションを
どう使ったのか？”

00:21:35.062 --> 00:21:38.766 align:start position:29% line:-2
“複数のスレッドから
アクセスしなかったか？”

00:21:38.966 --> 00:21:41.668 align:start position:30% line:-1
これらの質問の回答が―

00:21:42.402 --> 00:21:45.239 align:start position:27% line:-1
問題の根につながっています

00:21:45.973 --> 00:21:50.744 align:start position:21% line:-2
まず スレッドが原因でない場合を
検討しましょう

00:21:52.079 --> 00:21:53.680 align:start position:36% line:-1
ここに配列があり

00:21:53.781 --> 00:21:58.452 align:start position:30% line:-2
要素“E”の
インデックスがあります

00:21:58.652 --> 00:22:01.488 align:start position:29% line:-2
最初の要素を取り
コレクションを変更します

00:21:58.652 --> 00:22:01.488 align:start position:29% line:-2
最初の要素を取り
コレクションを変更します

00:22:02.623 --> 00:22:05.859 align:start position:29% line:-1
関連する要素を出力します

00:22:06.260 --> 00:22:10.397 align:start position:21% line:-1
これは 致命的なエラーになります

00:22:11.999 --> 00:22:13.133 align:start position:38% line:-1
インデックスは

00:22:13.233 --> 00:22:17.304 align:start position:25% line:-2
コレクションを変更した時点で
無効になります

00:22:18.906 --> 00:22:22.176 align:start position:21% line:-1
最初にコレクションを変更してから

00:22:22.276 --> 00:22:24.745 align:start position:27% line:-1
インデックスをするべきです

00:22:26.513 --> 00:22:30.684 align:start position:32% line:-2
変更でインデックスが
無効になるからです

00:22:31.051 --> 00:22:34.221 align:start position:25% line:-1
辞書ではどうなるか見ましょう

00:22:34.955 --> 00:22:38.325 align:start position:23% line:-1
クマの好物の辞書があるとします

00:22:39.092 --> 00:22:44.164 align:start position:23% line:-2
好きな食べ物を出力し
魚のsalmonだと確認します

00:22:45.199 --> 00:22:50.771 align:start position:27% line:-2
さらに好物を加えても
salmonのままとします

00:22:51.138 --> 00:22:55.542 align:start position:12% line:-2
しかし 冬眠の
hybernationになってしまいました

00:22:57.077 --> 00:23:00.848 align:start position:21% line:-1
インデックスが無効になったのです

00:22:57.077 --> 00:23:00.848 align:start position:21% line:-1
インデックスが無効になったのです

00:23:01.381 --> 00:23:04.218 align:start position:29% line:-1
コードがクラッシュします

00:23:05.085 --> 00:23:06.720 align:start position:36% line:-1
では修正方法は？

00:23:07.654 --> 00:23:13.627 align:start position:23% line:-2
配列と同じで 変更のあと
インデックスを計算し直すのです

00:23:14.194 --> 00:23:18.766 align:start position:30% line:-2
注意すべきは 再計算は
時に高くつくことです

00:23:18.866 --> 00:23:22.002 align:start position:30% line:-2
インデックスによって
サーチは線形時間なので

00:23:22.336 --> 00:23:25.205 align:start position:21% line:-1
必要な箇所のみをサーチしましょう

00:23:26.807 --> 00:23:30.177 align:start position:23% line:-1
そこで 私からのアドバイスです

00:23:30.377 --> 00:23:33.814 align:start position:25% line:-1
“変更でインデックスが無効”

00:23:33.914 --> 00:23:40.087 align:start position:25% line:-2
これを鉄則として覚えておけば
落ち着いて対応できます

00:23:40.854 --> 00:23:43.490 align:start position:38% line:-2
またスライスは
変更があっても

00:23:43.590 --> 00:23:46.793 align:start position:23% line:-1
元のコレクションを引き継ぎます

00:23:46.894 --> 00:23:52.866 align:start position:29% line:-2
可変コレクションの際は
くれぐれも注意しましょう

00:23:53.767 --> 00:23:58.138 align:start position:29% line:-2
またインデックスの計算は
時に時間がかかるので

00:23:59.139 --> 00:24:01.708 align:start position:27% line:-1
必要な箇所だけにしましょう

00:23:59.139 --> 00:24:01.708 align:start position:27% line:-1
必要な箇所だけにしましょう

00:24:02.976 --> 00:24:05.579 align:start position:32% line:-1
次にスレッドの話です

00:24:05.746 --> 00:24:10.617 align:start position:23% line:-2
あなたのスレッドは
複数のスレッドから見えますか？

00:24:11.652 --> 00:24:16.657 align:start position:23% line:-2
我々のコレクションは
１つのスレッドを想定しています

00:24:17.591 --> 00:24:20.260 align:start position:21% line:-1
パフォーマンス面で有利だからです

00:24:20.627 --> 00:24:23.864 align:start position:36% line:-2
単独スレッドなら
ロックなどの―

00:24:23.964 --> 00:24:29.403 align:start position:29% line:-2
排他制御による負担を
心配することはありません

00:24:30.204 --> 00:24:35.375 align:start position:23% line:-2
コレクションのデベロッパのみが
ロックや直列キューで

00:24:35.475 --> 00:24:36.910 align:start position:30% line:-1
スレッドを制御できます

00:24:37.010 --> 00:24:41.248 align:start position:30% line:-2
フレームワークより
高い抽象化レベルでです

00:24:42.616 --> 00:24:44.685 align:start position:29% line:-1
この問題を見てみましょう

00:24:45.452 --> 00:24:48.689 align:start position:20% line:-2
sleepingBearsで配列を
埋めるとします

00:24:49.256 --> 00:24:55.362 align:start position:12% line:-2
各クマを独自のクマとし
DispatchQueueにアクセスします

00:24:56.196 --> 00:24:58.298 align:start position:29% line:-1
クマに寝るよう指示します

00:24:58.899 --> 00:25:03.771 align:start position:21% line:-2
並列なのでコードが
同時に走ってるとイメージできます

00:24:58.899 --> 00:25:03.771 align:start position:21% line:-2
並列なのでコードが
同時に走ってるとイメージできます

00:25:03.871 --> 00:25:06.306 align:start position:25% line:-1
横に並べてシミュレートします

00:25:07.107 --> 00:25:10.144 align:start position:32% line:-2
アプリケーションで
クマを確認しましょう

00:25:11.211 --> 00:25:14.781 align:start position:21% line:-1
みんなが眠ってるかもしれませんし

00:25:15.048 --> 00:25:18.886 align:start position:30% line:-2
Grandpaより
Cubが先に寝るのかも

00:25:19.386 --> 00:25:22.523 align:start position:32% line:-2
Grandpaだけが
寝てる時もあります

00:25:23.791 --> 00:25:25.792 align:start position:36% line:-1
Cubだけの時も

00:25:26.560 --> 00:25:30.597 align:start position:34% line:-2
クラッシュした時は
誰も寝ていません

00:25:32.132 --> 00:25:35.002 align:start position:21% line:-1
これは競合状態がある可能性を示し

00:25:35.102 --> 00:25:40.507 align:start position:27% line:-2
関係あるすべてのスレッドが
関わっているようです

00:25:41.074 --> 00:25:45.445 align:start position:20% line:-2
確かめるには
XcodeにあるTSanが使えます

00:25:45.612 --> 00:25:49.216 align:start position:21% line:-1
アウトプットはこのようになります

00:25:49.750 --> 00:25:56.857 align:start position:21% line:-2
TSanが競合を割り出し
関連するスレッドを教えてくれます

00:25:57.558 --> 00:26:01.528 align:start position:25% line:-2
どの列から手をつければいいか
教えます

00:25:57.558 --> 00:26:01.528 align:start position:25% line:-2
どの列から手をつければいいか
教えます

00:26:02.329 --> 00:26:06.800 align:start position:34% line:-2
バグを見つけるのに
とても便利です

00:26:06.900 --> 00:26:11.538 align:start position:27% line:-2
バグの箇所に関して
TSanはウソをつきません

00:26:12.639 --> 00:26:16.743 align:start position:23% line:-1
クマが同時に寝る条件を消すのを

00:26:16.844 --> 00:26:18.912 align:start position:21% line:-1
直列ディスパッチキューで行います

00:26:19.746 --> 00:26:21.748 align:start position:27% line:-1
順番に寝るようになりました

00:26:21.949 --> 00:26:27.187 align:start position:16% line:-2
キューの並びに注意しながら
sleepingBearsを見にいくと

00:26:27.955 --> 00:26:32.426 align:start position:30% line:-2
GranpaとCubが
仲良く寝ています

00:26:34.161 --> 00:26:40.234 align:start position:21% line:-2
単独のスレッドからだけ見えるよう
データを隔離しましょう

00:26:40.467 --> 00:26:44.571 align:start position:32% line:-2
それができない場合は
排他制御をしましょう

00:26:44.671 --> 00:26:47.074 align:start position:29% line:-2
直列ディスパッチキューや
ロックです

00:26:47.741 --> 00:26:50.644 align:start position:20% line:-1
そしてTSanで二重チェックします

00:26:50.744 --> 00:26:54.548 align:start position:32% line:-2
バグは リリース前に
発見すべきですよね

00:26:55.782 --> 00:26:58.385 align:start position:25% line:-1
さらに可変コレクションの話を

00:26:59.753 --> 00:27:03.791 align:start position:25% line:-2
できれば
可変状態の使用を避けましょう

00:26:59.753 --> 00:27:03.791 align:start position:25% line:-2
できれば
可変状態の使用を避けましょう

00:27:04.358 --> 00:27:08.729 align:start position:30% line:-2
今までお話しした面倒を
避けるためです

00:27:08.829 --> 00:27:13.400 align:start position:23% line:-2
可変コレクションを避けることで
まず回避できます

00:27:13.834 --> 00:27:18.405 align:start position:29% line:-2
スライスや
lazyのラップを使えば

00:27:18.639 --> 00:27:23.277 align:start position:27% line:-2
データを変更したかのように
処理できます

00:27:24.177 --> 00:27:30.484 align:start position:25% line:-2
可変状態になっている場合には
コンパイラが教えてくれます

00:27:32.686 --> 00:27:37.691 align:start position:32% line:-2
可変状態を使う際の
アドバイスをもう１つ

00:27:38.826 --> 00:27:40.427 align:start position:29% line:-1
新規のコレクション作成で

00:27:40.527 --> 00:27:44.231 align:start position:32% line:-2
先に 要素の正確な数
または―

00:27:44.565 --> 00:27:47.601 align:start position:36% line:-2
おおよその数が
分かれば便利です

00:27:47.701 --> 00:27:51.038 align:start position:23% line:-1
APIの多くはそのヒントをくれ

00:27:51.138 --> 00:27:54.274 align:start position:21% line:-1
正確なサイズを教えてくれるのです

00:27:54.374 --> 00:27:57.611 align:start position:29% line:-1
他にも同様のツールがあり

00:27:58.011 --> 00:27:59.580 align:start position:30% line:-1
様々なケースで使えます

00:27:59.680 --> 00:28:05.552 align:start position:25% line:-2
要素を追加したい時
容量を超えることがありますが

00:27:59.680 --> 00:28:05.552 align:start position:25% line:-2
要素を追加したい時
容量を超えることがありますが

00:28:06.120 --> 00:28:09.356 align:start position:23% line:-1
多めに見積もらなくても済みます

00:28:09.456 --> 00:28:13.660 align:start position:29% line:-2
いつ容量を増やすべきかが
分かるからです

00:28:14.995 --> 00:28:17.731 align:start position:29% line:-1
今日最後の話題に移ります

00:28:18.832 --> 00:28:25.472 align:start position:18% line:-2
広範囲なコレクションが
Foundationで可能になります

00:28:27.274 --> 00:28:30.144 align:start position:16% line:-1
Foundationをインポートすれば

00:28:30.244 --> 00:28:35.349 align:start position:18% line:-2
従来からあるObjective-Cの
参照型が使えるようになります

00:28:36.316 --> 00:28:38.652 align:start position:29% line:-1
多くはSwiftに適応し

00:28:38.752 --> 00:28:41.989 align:start position:34% line:-2
他のコレクションと
同様に機能します

00:28:42.256 --> 00:28:44.691 align:start position:29% line:-1
いくつか注意点があります

00:28:45.993 --> 00:28:50.430 align:start position:32% line:-2
まずは これらが
参照型であることです

00:28:50.531 --> 00:28:53.000 align:start position:36% line:-1
例を挙げましょう

00:28:53.600 --> 00:28:57.871 align:start position:30% line:-2
値型と参照型を決め
両方で同じことをします

00:28:58.305 --> 00:29:01.775 align:start position:23% line:-1
この値型“x”は文字列の配列で

00:28:58.305 --> 00:29:01.775 align:start position:23% line:-1
この値型“x”は文字列の配列で

00:29:02.409 --> 00:29:04.845 align:start position:29% line:-1
空の配列“x”となります

00:29:04.945 --> 00:29:08.916 align:start position:30% line:-2
参照型では “x”が
空の配列を指しています

00:29:09.950 --> 00:29:14.488 align:start position:30% line:-2
次に インラインで
配列を値型に変更します

00:29:14.721 --> 00:29:18.091 align:start position:25% line:-1
参照型でも 参照される配列が

00:29:18.192 --> 00:29:20.861 align:start position:29% line:-1
インラインで変更されます

00:29:21.295 --> 00:29:25.365 align:start position:30% line:-2
別の変数を足すと
値型で何かが起こります

00:29:25.465 --> 00:29:27.234 align:start position:39% line:-1
コピーせずに

00:29:27.334 --> 00:29:31.805 align:start position:25% line:-2
このストレージが
“x”に属すと分かったのです

00:29:32.539 --> 00:29:36.243 align:start position:32% line:-2
参照型でも同じことが
起きるのでしょうか？

00:29:36.610 --> 00:29:41.949 align:start position:23% line:-2
参照型では違って
“y”は同じ配列を示すだけです

00:29:42.983 --> 00:29:46.019 align:start position:23% line:-1
次に“y”を違うクマに変えます

00:29:46.120 --> 00:29:52.092 align:start position:23% line:-2
値型では“y”に書き込むために
まずはコピーして―

00:29:53.227 --> 00:29:54.828 align:start position:32% line:-1
違うクマを挿入します

00:29:56.296 --> 00:30:01.301 align:start position:21% line:-2
参照型では 単純に配列を１つにし
パンダを入れます

00:29:56.296 --> 00:30:01.301 align:start position:21% line:-2
参照型では 単純に配列を１つにし
パンダを入れます

00:30:03.303 --> 00:30:09.042 align:start position:12% line:-2
FoundationをSwiftで使う際の
２つ目の注意点は

00:30:09.476 --> 00:30:14.915 align:start position:21% line:-2
Objective-CのAPIは
値型として現れることです

00:30:15.015 --> 00:30:20.454 align:start position:29% line:-2
おかげで両方の言語で
コードがうまく機能します

00:30:20.954 --> 00:30:25.292 align:start position:29% line:-2
実装方法が異なる
２言語間で機能できるのは

00:30:26.393 --> 00:30:29.163 align:start position:27% line:-1
ブリッジ機能があるからです

00:30:29.496 --> 00:30:33.033 align:start position:25% line:-2
２つの異なるランタイム表現を
変換します

00:30:33.133 --> 00:30:35.969 align:start position:14% line:-1
SwiftとObjective-Cとでは

00:30:36.270 --> 00:30:41.542 align:start position:29% line:-2
コンパイラもランタイムも
異なりますからね

00:30:42.342 --> 00:30:46.346 align:start position:29% line:-2
ブリッジ変換は最適化され
高速ですが―

00:30:46.447 --> 00:30:49.750 align:start position:29% line:-1
必ず その代償があります

00:30:50.884 --> 00:30:52.386 align:start position:38% line:-1
見てみましょう

00:30:52.820 --> 00:30:56.523 align:start position:21% line:-1
まず同等のストレージを確保します

00:30:56.623 --> 00:31:00.961 align:start position:27% line:-2
１言語で“n”であれば
もう１つでも“n”にします

00:30:56.623 --> 00:31:00.961 align:start position:27% line:-2
１言語で“n”であれば
もう１つでも“n”にします

00:31:01.094 --> 00:31:03.931 align:start position:29% line:-1
次に要素ごとに変換します

00:31:04.298 --> 00:31:07.468 align:start position:32% line:-2
このブリッジは
再帰的な時もあります

00:31:07.568 --> 00:31:12.706 align:start position:21% line:-2
文字列の配列ですと
先に配列 次に文字列を変換します

00:31:13.907 --> 00:31:17.644 align:start position:30% line:-2
２言語の境界での変換は
先行ブリッジと呼ばれ

00:31:18.779 --> 00:31:23.851 align:start position:30% line:-2
要素の変換が必要な際に
先行して行われます

00:31:24.084 --> 00:31:27.588 align:start position:25% line:-1
これは辞書で頻繁に起こります

00:31:28.755 --> 00:31:31.525 align:start position:38% line:-2
先行でなければ
遅延と呼びます

00:31:31.692 --> 00:31:36.296 align:start position:32% line:-2
要素の型自体が
変換されない場合です

00:31:36.463 --> 00:31:41.001 align:start position:25% line:-2
コレクションが使用されるまで
保留されます

00:31:41.401 --> 00:31:42.970 align:start position:34% line:-1
例で説明しましょう

00:31:43.604 --> 00:31:47.307 align:start position:21% line:-2
Objective-CのAPIで
NSArrayを書きます

00:31:47.775 --> 00:31:51.912 align:start position:21% line:-2
NSArrayは配列に
NSDataは値型に変換されます

00:31:52.012 --> 00:31:54.715 align:start position:27% line:-1
これらの変換は先行されます

00:31:55.649 --> 00:32:00.487 align:start position:12% line:-1
NSViewはSwiftに変換されないため

00:31:55.649 --> 00:32:00.487 align:start position:12% line:-1
NSViewはSwiftに変換されないため

00:32:00.587 --> 00:32:04.191 align:start position:23% line:-2
NSViewのNSArrayは
遅延変換となります

00:32:04.324 --> 00:32:08.462 align:start position:30% line:-2
最初のアクセスまで
ブリッジ変換されません

00:32:10.731 --> 00:32:16.603 align:start position:21% line:-2
NSDictionaryのキーが
NSStringなら先行です

00:32:17.337 --> 00:32:21.608 align:start position:25% line:-2
文字列はSwiftで
値型として認識されるからです

00:32:22.242 --> 00:32:27.681 align:start position:23% line:-2
ブリッジ変換を理解したところで
最も重要なことは

00:32:28.015 --> 00:32:33.554 align:start position:25% line:-2
アプリケーションに悪影響が
ある際に使うべきという点です

00:32:35.856 --> 00:32:38.458 align:start position:16% line:-2
Instrumentsの
Time Profilerなどを使う時

00:32:38.559 --> 00:32:44.364 align:start position:21% line:-2
言語間のどこで
コードが交わるかに注意しましょう

00:32:44.898 --> 00:32:47.434 align:start position:25% line:-1
ブリッジがあっても大丈夫です

00:32:47.534 --> 00:32:51.939 align:start position:27% line:-2
問題は bridgeを含む
自分が書いていないコードで

00:32:52.039 --> 00:32:55.409 align:start position:23% line:-1
膨大な時間を要している場合です

00:32:56.443 --> 00:32:57.978 align:start position:38% line:-1
例で説明します

00:32:58.779 --> 00:33:01.448 align:start position:34% line:-1
童話の原稿があって

00:32:58.779 --> 00:33:01.448 align:start position:34% line:-1
童話の原稿があって

00:33:01.548 --> 00:33:06.186 align:start position:30% line:-2
長いので一部だけ表示し
ポップさせます

00:33:07.120 --> 00:33:11.792 align:start position:32% line:-2
単語のインスタンスを
全部 茶色にし―

00:33:12.092 --> 00:33:14.828 align:start position:23% line:-1
最初の単語だけハイライトします

00:33:16.330 --> 00:33:18.665 align:start position:0% line:-1
NSMutableAttributedStringを使い

00:33:18.766 --> 00:33:21.768 align:start position:20% line:-1
ここに“story”を入れ込みます

00:33:21.869 --> 00:33:27.407 align:start position:23% line:-2
ネイティブインデックス型の
レンジを作るよう その文字列で

00:33:27.508 --> 00:33:30.477 align:start position:29% line:-1
茶色のレンジを要求します

00:33:31.311 --> 00:33:36.083 align:start position:32% line:-2
去年発表した
簡易イニシャライザで

00:33:36.183 --> 00:33:38.752 align:start position:27% line:-1
NSRangeに変換します

00:33:38.852 --> 00:33:44.258 align:start position:16% line:-2
再びAttributedStringの
プロパティで変換し

00:33:44.358 --> 00:33:46.627 align:start position:29% line:-1
最初の単語を茶色にします

00:33:47.127 --> 00:33:49.863 align:start position:30% line:-1
コードの実行が遅いので

00:33:50.831 --> 00:33:53.133 align:start position:34% line:-1
プロファイルします

00:33:53.467 --> 00:33:56.270 align:start position:25% line:-1
茶色になるかと思っていたのに

00:33:56.370 --> 00:33:59.173 align:start position:32% line:-2
インデックスを
数えていただけでした

00:34:00.674 --> 00:34:04.411 align:start position:34% line:-2
文字列を複数回
変換していたのです

00:34:04.511 --> 00:34:08.014 align:start position:20% line:-2
AttributedStringは
Objective-Cのもので

00:34:08.114 --> 00:34:12.652 align:start position:27% line:-2
NSStringを文字列に
変換していたのです

00:34:13.719 --> 00:34:16.822 align:start position:27% line:-2
これを
最初のレンジを計算する時と

00:34:16.924 --> 00:34:19.525 align:start position:25% line:-2
NSRangeに変換する時の
２度やっています

00:34:20.694 --> 00:34:25.232 align:start position:29% line:-2
これをループしたら
かなりの時間を費やします

00:34:25.466 --> 00:34:27.301 align:start position:32% line:-1
なぜこれが起こるか？

00:34:27.501 --> 00:34:31.405 align:start position:16% line:-2
Swift側で
text.stringを呼び出しますが

00:34:31.705 --> 00:34:34.875 align:start position:4% line:-2
NSMutableAttributedStringの
実行はObjective-C側です

00:34:34.975 --> 00:34:39.478 align:start position:30% line:-2
オリジナルの実装を
確認しないといけません

00:34:40.681 --> 00:34:43.016 align:start position:20% line:-1
オリジナルがNSStringを返し

00:34:43.283 --> 00:34:47.187 align:start position:29% line:-2
これは参照型なので
ブリッジが必要になります

00:34:47.521 --> 00:34:52.059 align:start position:29% line:-2
クラスタごと 文字ごとに
変換します

00:34:52.793 --> 00:34:58.398 align:start position:29% line:-2
戻り型でもパラメータでも
ブリッジ変換が発生します

00:35:01.235 --> 00:35:06.273 align:start position:30% line:-2
事情が分かったところで
状況を改善させましょう

00:35:06.373 --> 00:35:07.908 align:start position:30% line:-1
もう１度ブリッジします

00:35:08.675 --> 00:35:13.580 align:start position:30% line:-2
コードを再計算すると
時間が半減されています

00:35:13.680 --> 00:35:16.116 align:start position:25% line:-1
今年はもう少し改善されました

00:35:16.617 --> 00:35:19.319 align:start position:30% line:-1
このブリッジもしません

00:35:19.419 --> 00:35:21.421 align:start position:32% line:-1
良くなっているんです

00:35:21.688 --> 00:35:27.494 align:start position:4% line:-2
text.string as NSStringとして
変数を得ると

00:35:27.594 --> 00:35:29.563 align:start position:30% line:-1
ブリッジは起こりません

00:35:30.564 --> 00:35:34.868 align:start position:30% line:-2
今後は そうすることで
NSStringに対し

00:35:34.968 --> 00:35:38.539 align:start position:27% line:-2
プロパティのレンジを呼ぶと
NSRangeが自動で出て

00:35:39.406 --> 00:35:43.444 align:start position:18% line:-2
Swiftのネイティブ型と
NSRangeの変換が不要になります

00:35:44.545 --> 00:35:46.480 align:start position:36% line:-1
とても便利ですね

00:35:46.580 --> 00:35:49.016 align:start position:27% line:-1
このコードを計算してみます

00:35:49.116 --> 00:35:54.488 align:start position:29% line:-2
先ほどの800ミリ秒より
かなり速くなりました

00:35:55.422 --> 00:36:00.728 align:start position:30% line:-2
しかし わずかですが
まだブリッジしています

00:35:55.422 --> 00:36:00.728 align:start position:30% line:-2
しかし わずかですが
まだブリッジしています

00:36:01.361 --> 00:36:04.264 align:start position:23% line:-1
この茶色はSwiftの値型です

00:36:04.965 --> 00:36:09.670 align:start position:29% line:-2
Objective-Cの
APIレンジを呼ぶたびに

00:36:09.770 --> 00:36:14.074 align:start position:20% line:-2
その文字列を
NSStringに再変換しています

00:36:14.875 --> 00:36:17.077 align:start position:29% line:-1
１度でいいので低負荷です

00:36:17.177 --> 00:36:21.348 align:start position:29% line:-2
しかしループでは
小規模でも何度も行います

00:36:21.849 --> 00:36:25.352 align:start position:32% line:-2
小さくてもブリッジは
避けて―

00:36:25.452 --> 00:36:28.489 align:start position:34% line:-2
最適化を行う前に
必ず計算しましょう

00:36:29.690 --> 00:36:34.528 align:start position:30% line:-2
ブリッジ変換の詳細を
理解した上での助言です

00:36:35.596 --> 00:36:39.833 align:start position:32% line:-2
参照セマンティクスに
明示的に使いましょう

00:36:40.500 --> 00:36:43.837 align:start position:34% line:-2
自分で書かなくても
多数そろっています

00:36:44.238 --> 00:36:46.874 align:start position:23% line:-1
また 参照型の時に使いましょう

00:36:46.974 --> 00:36:49.943 align:start position:14% line:-2
NSプロキシや
Core Data管理のオブジェクトです

00:36:51.078 --> 00:36:57.084 align:start position:21% line:-2
Objective-Cの
ラウンドトリップ時にもお勧めです

00:36:57.317 --> 00:37:02.289 align:start position:29% line:-2
ブリッジが原因で
遅くなっている場合はです

00:36:57.317 --> 00:37:02.289 align:start position:29% line:-2
ブリッジが原因で
遅くなっている場合はです

00:37:03.657 --> 00:37:09.263 align:start position:25% line:-2
Swiftのコレクションの
パワフルさが分かりましたか？

00:37:09.630 --> 00:37:13.867 align:start position:32% line:-2
ご自分の使い方を
見直してみてください

00:37:13.967 --> 00:37:18.672 align:start position:29% line:-2
インデックスやスライスで
コードを向上させましょう

00:37:18.872 --> 00:37:23.344 align:start position:29% line:-2
速さを測り
遅延やブリッジの調整を―

00:37:24.411 --> 00:37:26.179 align:start position:38% line:-1
検討しましょう

00:37:26.914 --> 00:37:30.050 align:start position:23% line:-1
TSanで可変状態の監視もです

00:37:30.517 --> 00:37:37.024 align:start position:16% line:-2
Playgroundやご自分のAppで
スキルを向上させましょう

00:37:37.791 --> 00:37:42.196 align:start position:32% line:-2
今後のラボにも
参加してみてください

00:37:42.596 --> 00:37:45.332 align:start position:23% line:-1
本日は ありがとうございました

00:37:45.432 --> 00:37:47.134 align:start position:43% line:-1
(拍手)
