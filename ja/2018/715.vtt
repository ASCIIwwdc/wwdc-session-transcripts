WEBVTT

00:00:07.074 --> 00:00:16.517 align:start position:43% line:-1
(音楽)

00:00:17.718 --> 00:00:20.654 align:start position:43% line:-1
(拍手)

00:00:20.754 --> 00:00:21.688 align:start position:34% line:-1
おはようございます

00:00:22.990 --> 00:00:24.157 align:start position:29% line:-1
ジョシュ･グレスリーです

00:00:24.258 --> 00:00:28.328 align:start position:12% line:-2
今日はNetwork.frameworkを
紹介します

00:00:30.531 --> 00:00:33.667 align:start position:18% line:-2
Network.frameworkは
ソケットの代替です

00:00:33.934 --> 00:00:37.471 align:start position:21% line:-2
これから トランスポートAPIの
話をします

00:00:37.571 --> 00:00:43.277 align:start position:18% line:-2
Network.frameworkの
システムへの組み込みと

00:00:43.377 --> 00:00:46.313 align:start position:29% line:-2
アプリケーションへの
適合性が分かると思います

00:00:47.247 --> 00:00:51.385 align:start position:30% line:-2
最初の接続を通し
このAPIを紹介します

00:00:52.152 --> 00:00:56.823 align:start position:34% line:-2
実際にデータ通信を
最適化する方法と

00:00:56.924 --> 00:01:00.394 align:start position:29% line:-2
驚異的なパフォーマンスを
お見せしましょう

00:00:56.924 --> 00:01:00.394 align:start position:29% line:-2
驚異的なパフォーマンスを
お見せしましょう

00:01:01.261 --> 00:01:05.299 align:start position:23% line:-2
このAPIがモビリティの課題を
どう処理するのか

00:01:05.399 --> 00:01:09.203 align:start position:25% line:-2
また このAPIの採用方法を
お話しします

00:01:10.304 --> 00:01:15.342 align:start position:21% line:-2
まずトランスポートAPIについて
説明します

00:01:15.642 --> 00:01:19.046 align:start position:34% line:-2
ネットワーク上の
エンドポイント間で

00:01:19.146 --> 00:01:23.617 align:start position:25% line:-2
任意のデータを
送受信できるAPIを指します

00:01:23.717 --> 00:01:28.388 align:start position:30% line:-2
このカテゴリに該当する
APIは多数あります

00:01:30.324 --> 00:01:35.295 align:start position:29% line:-2
ソケットは普及率が高く
30年以上前からあります

00:01:35.395 --> 00:01:40.968 align:start position:27% line:-2
ソケットの登場で
世界は一変したと言えますが

00:01:41.101 --> 00:01:46.974 align:start position:25% line:-2
今の時代のアプリケーションを
ソケットで書くのは困難です

00:01:47.307 --> 00:01:51.912 align:start position:30% line:-2
ソケットの使用が難しい
領域は３つあります

00:01:53.146 --> 00:01:55.349 align:start position:34% line:-1
１つ目は接続の確立

00:01:55.482 --> 00:02:01.154 align:start position:29% line:-2
ソケットでの接続が
難しい理由は多くあります

00:01:55.482 --> 00:02:01.154 align:start position:29% line:-2
ソケットでの接続が
難しい理由は多くあります

00:02:01.455 --> 00:02:06.927 align:start position:27% line:-2
アドレスに接続すると
大抵はホスト名しかないため

00:02:07.027 --> 00:02:09.763 align:start position:32% line:-2
ホスト名を
アドレスに解決します

00:02:10.531 --> 00:02:13.634 align:start position:30% line:-2
すると複数のアドレスが
出てくるのです

00:02:13.734 --> 00:02:17.638 align:start position:32% line:-2
IPv4アドレスや
IPv6アドレスです

00:02:18.105 --> 00:02:21.909 align:start position:27% line:-2
どの順番で
どのアドレスに接続するか？

00:02:22.009 --> 00:02:24.144 align:start position:29% line:-1
次の接続のタイミングは？

00:02:24.244 --> 00:02:28.348 align:start position:32% line:-2
答えを得るには
何年もかかるでしょう

00:02:30.150 --> 00:02:35.289 align:start position:23% line:-2
デュアルスタックのホストの後は
他の問題に直面します

00:02:35.389 --> 00:02:39.893 align:start position:34% line:-2
プロキシ自動設定や
PACもありますが

00:02:39.993 --> 00:02:45.032 align:start position:18% line:-2
これらにはJavaScriptがあり
URLを渡す必要があります

00:02:45.132 --> 00:02:50.003 align:start position:29% line:-2
JavaScriptは
直接行くことができるのか

00:02:50.103 --> 00:02:54.741 align:start position:20% line:-2
または SOCKSプロキシや
HTTPプロキシが必要か応答します

00:02:54.842 --> 00:02:59.112 align:start position:27% line:-2
アプリケーションがこれらを
サポートする必要があれば

00:02:59.213 --> 00:03:01.348 align:start position:34% line:-1
厄介かもしれません

00:02:59.213 --> 00:03:01.348 align:start position:34% line:-1
厄介かもしれません

00:03:01.915 --> 00:03:08.422 align:start position:27% line:-2
ネットワークのテストをせず
顧客から不具合の報告を受け

00:03:08.522 --> 00:03:11.959 align:start position:36% line:-2
不満を言われる
可能性もあります

00:03:12.059 --> 00:03:18.098 align:start position:23% line:-2
解決のためにコードを追加しても
それをテストできません

00:03:18.198 --> 00:03:24.037 align:start position:27% line:-2
顧客と同じ環境を
再現するのは本当に困難です

00:03:24.705 --> 00:03:27.241 align:start position:34% line:-1
１つ目は接続でした

00:03:28.542 --> 00:03:32.446 align:start position:32% line:-2
２つ目の難しい領域は
データ転送です

00:03:32.946 --> 00:03:36.817 align:start position:34% line:-2
これが難しい理由は
たくさんあります

00:03:37.885 --> 00:03:41.955 align:start position:32% line:-2
主な問題はソケットの
読み書きのモデルです

00:03:42.589 --> 00:03:46.927 align:start position:30% line:-2
並列処理のできない
ブロッキングソケットは

00:03:47.027 --> 00:03:51.632 align:start position:27% line:-2
データの読み書きの間
単一の処理は避けるべきです

00:03:52.099 --> 00:03:56.670 align:start position:30% line:-2
非ブロッキングにしても
別の課題に直面します

00:03:57.371 --> 00:04:00.641 align:start position:29% line:-2
カーネルに100バイトが
欲しいと言うと

00:03:57.371 --> 00:04:00.641 align:start position:29% line:-2
カーネルに100バイトが
欲しいと言うと

00:04:00.741 --> 00:04:04.811 align:start position:30% line:-2
“また後で”と
返されるかもしれません

00:04:04.912 --> 00:04:09.116 align:start position:29% line:-2
そして ステートマシンの
構築が必要になります

00:04:09.216 --> 00:04:13.253 align:start position:34% line:-2
これは大変な作業で
非常に困難です

00:04:14.521 --> 00:04:17.891 align:start position:30% line:-2
さらにTLSを
使用する必要があるため

00:04:17.991 --> 00:04:21.762 align:start position:30% line:-2
ソケットへの読み書きは
避けるべきです

00:04:24.097 --> 00:04:28.268 align:start position:32% line:-2
ソケットはTLSを
サポートしていません

00:04:28.368 --> 00:04:32.873 align:start position:30% line:-2
TLS対応の
ライブラリを使用するか

00:04:32.973 --> 00:04:35.943 align:start position:34% line:-2
グルーコードを
書くことになります

00:04:36.043 --> 00:04:40.347 align:start position:27% line:-2
そして膨大な接続ロジックで
動作方法を探るのです

00:04:41.515 --> 00:04:43.417 align:start position:39% line:-1
難しいですね

00:04:45.285 --> 00:04:49.890 align:start position:27% line:-2
最後の問題はモビリティです
理由は多くあります

00:04:51.225 --> 00:04:55.496 align:start position:30% line:-2
以前は１つのデバイスを
移動させるのに

00:04:55.963 --> 00:04:58.565 align:start position:32% line:-1
２人以上が必要でした

00:04:58.665 --> 00:05:03.937 align:start position:21% line:-2
１本のケーブルに静的IPアドレス
全てがシンプルでした

00:04:58.665 --> 00:05:03.937 align:start position:21% line:-2
１本のケーブルに静的IPアドレス
全てがシンプルでした

00:05:04.271 --> 00:05:09.776 align:start position:25% line:-2
現代ははるかに
パワフルなデバイスがあります

00:05:09.877 --> 00:05:14.381 align:start position:25% line:-2
複数の電波を放ち
ネットワーク間を移動するには

00:05:14.481 --> 00:05:19.920 align:start position:25% line:-2
アプリケーションが移行を
うまく処理する必要があります

00:05:22.589 --> 00:05:24.892 align:start position:32% line:-1
ソケットには無理です

00:05:24.992 --> 00:05:28.362 align:start position:29% line:-2
ルーティングソケットでも
難しいでしょう

00:05:28.462 --> 00:05:30.831 align:start position:23% line:-1
トランスポートAPIの出番です

00:05:32.165 --> 00:05:38.338 align:start position:20% line:-2
プラットフォームには
APIがURLセッションにあります

00:05:38.972 --> 00:05:42.576 align:start position:34% line:-2
これら全ての問題を
処理してくれます

00:05:43.076 --> 00:05:46.480 align:start position:32% line:-2
TCPとTLS接続へ
生でアクセス可能な―

00:05:46.580 --> 00:05:50.050 align:start position:27% line:-1
ストリームタスクもあります

00:05:51.118 --> 00:05:56.790 align:start position:27% line:-2
URLセッションが
自分と同じプリミティブ上に

00:05:56.890 --> 00:06:02.196 align:start position:34% line:-2
構築されていると
思うかもしれません

00:05:56.890 --> 00:06:02.196 align:start position:34% line:-2
構築されていると
思うかもしれません

00:06:03.263 --> 00:06:05.232 align:start position:36% line:-1
しかし 違います

00:06:05.899 --> 00:06:09.536 align:start position:14% line:-2
Network.frameworkの上に
構築されているのです

00:06:10.003 --> 00:06:13.740 align:start position:27% line:-2
HTTPに焦点を当て
多くのトランスポート機能を

00:06:13.841 --> 00:06:17.744 align:start position:18% line:-2
Network.frameworkに
降ろしました

00:06:20.948 --> 00:06:24.084 align:start position:18% line:-2
Network.frameworkに
長年取り組む我々は

00:06:24.184 --> 00:06:29.423 align:start position:29% line:-2
学んだ多くのことを
IETFに反映しています

00:06:29.523 --> 00:06:35.062 align:start position:25% line:-2
IETFへ参加して
他の企業のエンジニアと出会い

00:06:35.162 --> 00:06:38.899 align:start position:34% line:-2
多くのことを
話し合ってきました

00:06:38.999 --> 00:06:41.368 align:start position:32% line:-1
フィードバックを元に

00:06:41.468 --> 00:06:44.705 align:start position:18% line:-2
Network.frameworkを
改善したのです

00:06:45.439 --> 00:06:52.379 align:start position:21% line:-2
今年 皆さんのアプリケーションで
そのライブラリを利用できます

00:06:53.146 --> 00:06:58.452 align:start position:43% line:-1
(拍手)

00:06:58.552 --> 00:07:04.992 align:start position:25% line:-2
ソケットは全てにおいて
細かいコントロールが可能です

00:06:58.552 --> 00:07:04.992 align:start position:25% line:-2
ソケットは全てにおいて
細かいコントロールが可能です

00:07:05.092 --> 00:07:06.593 align:start position:38% line:-1
そこは利点です

00:07:07.294 --> 00:07:13.667 align:start position:14% line:-2
ソケットより優れた機能を持った
Network.frameworkですが

00:07:13.767 --> 00:07:17.504 align:start position:34% line:-2
“取っ手”は残し
調節可能にしました

00:07:17.704 --> 00:07:21.808 align:start position:21% line:-2
取っ手を回すほど
複雑なコントロールができるのです

00:07:21.909 --> 00:07:27.648 align:start position:27% line:-2
必要な力だけを得られるので
無駄な複雑さを避けられます

00:07:30.284 --> 00:07:34.421 align:start position:18% line:-2
Network.frameworkは
スマートな接続の確立が可能です

00:07:34.755 --> 00:07:38.692 align:start position:27% line:-2
デュアルスタックや
IPv6のみのネットワーク

00:07:38.792 --> 00:07:41.495 align:start position:23% line:-1
PAC プロキシを処理できます

00:07:41.595 --> 00:07:46.533 align:start position:23% line:-2
他では扱いにくい
ネットワークの接続に役立ちます

00:07:47.000 --> 00:07:50.103 align:start position:36% line:-2
最適化された
データ転送パスは

00:07:50.204 --> 00:07:55.075 align:start position:21% line:-2
ソケットの全ての
パフォーマンスを超えているのです

00:07:56.210 --> 00:08:01.248 align:start position:21% line:-2
セキュリティ機能に対応し
TLSとDTLSを標準でサポート

00:07:56.210 --> 00:08:01.248 align:start position:21% line:-2
セキュリティ機能に対応し
TLSとDTLSを標準でサポート

00:08:01.348 --> 00:08:03.183 align:start position:32% line:-1
本当に使いやすいです

00:08:04.117 --> 00:08:06.119 align:start position:34% line:-2
モビリティも
サポートしています

00:08:06.220 --> 00:08:12.159 align:start position:23% line:-2
また 接続に関する
ネットワークの変更を通知します

00:08:13.927 --> 00:08:17.764 align:start position:23% line:-2
iOS macOS tvOSで
利用できるため

00:08:17.865 --> 00:08:22.302 align:start position:27% line:-2
Objective-Cから
簡単に使用できるのです

00:08:22.402 --> 00:08:24.805 align:start position:21% line:-1
Swift APIも備えています

00:08:26.773 --> 00:08:31.111 align:start position:27% line:-2
ではここで
トミー･ポーリーの登場です

00:08:31.411 --> 00:08:32.078 align:start position:45% line:-1
どうも

00:08:32.179 --> 00:08:35.115 align:start position:43% line:-1
(拍手)

00:08:38.684 --> 00:08:39.919 align:start position:41% line:-1
こんにちは

00:08:40.020 --> 00:08:43.924 align:start position:29% line:-2
ネットワークチーム所属の
トミー･ポーリーです

00:08:44.625 --> 00:08:49.663 align:start position:18% line:-2
Network.frameworkを
アプリケーションへ

00:08:49.763 --> 00:08:52.399 align:start position:27% line:-1
採用する方法をお話しします

00:08:53.267 --> 00:08:58.105 align:start position:32% line:-2
最初の接続の確立から
始めましょう

00:08:58.505 --> 00:09:05.846 align:start position:21% line:-2
ローカルデバイスから
サーバやピアデバイスへ接続します

00:08:58.505 --> 00:09:05.846 align:start position:21% line:-2
ローカルデバイスから
サーバやピアデバイスへ接続します

00:09:07.047 --> 00:09:12.486 align:start position:18% line:-2
Network.frameworkに
適した接続とは？

00:09:12.586 --> 00:09:14.188 align:start position:36% line:-1
ユースケースは？

00:09:14.521 --> 00:09:20.360 align:start position:9% line:-2
ソケットをNetwork.frameworkに
替える利点は大きいです

00:09:20.460 --> 00:09:25.299 align:start position:25% line:-2
その恩恵を得られる
１つ目のシナリオを紹介します

00:09:26.867 --> 00:09:30.604 align:start position:32% line:-2
まずはゲームの
アプリケーションです

00:09:30.971 --> 00:09:33.674 align:start position:34% line:-1
大抵はUDPを使い

00:09:33.774 --> 00:09:38.779 align:start position:21% line:-2
デバイス間で
リアルタイムのデータを送信します

00:09:39.446 --> 00:09:45.219 align:start position:21% line:-2
通常はレイテンシを最適化し
ラグやデータの損失を抑えています

00:09:45.953 --> 00:09:52.759 align:start position:16% line:-2
Network.frameworkでは
UDPを最適化して

00:09:52.860 --> 00:09:58.866 align:start position:30% line:-2
送受信の時間を非常に
速くすることができます

00:10:00.934 --> 00:10:06.540 align:start position:16% line:-2
２つ目はLive Streamingの
アプリケーションです

00:10:06.640 --> 00:10:12.846 align:start position:20% line:-2
UDPとTCPを組み合わせることが
よくありますが

00:10:13.313 --> 00:10:17.651 align:start position:29% line:-2
重要なのはその場で
データを生成することです

00:10:17.818 --> 00:10:23.090 align:start position:23% line:-2
新しいビデオフレームや
オーディオフレームがある場合に

00:10:23.190 --> 00:10:27.761 align:start position:25% line:-2
多くのバッファリングがあると
うまくいきません

00:10:28.562 --> 00:10:31.865 align:start position:27% line:-1
読み書きの非同期のモデルは

00:10:31.965 --> 00:10:36.270 align:start position:27% line:-2
バッファリングを減らすのに
最適でしょう

00:10:38.205 --> 00:10:42.209 align:start position:23% line:-2
最後はメールとメッセージングの
アプリケーションです

00:10:42.943 --> 00:10:48.315 align:start position:27% line:-2
TLSという昔ながらの
プロトコルを使っていますが

00:10:48.882 --> 00:10:53.754 align:start position:29% line:-2
ネットワークの移行こそが
とても重要なのです

00:10:55.355 --> 00:10:58.959 align:start position:34% line:-2
メッセージングの
アプリケーションは

00:10:59.059 --> 00:11:03.330 align:start position:27% line:-2
多くの場合は
建物から出る時に使用します

00:10:59.059 --> 00:11:03.330 align:start position:27% line:-2
多くの場合は
建物から出る時に使用します

00:11:03.597 --> 00:11:09.970 align:start position:21% line:-2
建物のWi-Fiネットワークから
モバイルデータ通信に移行した時に

00:11:10.070 --> 00:11:14.107 align:start position:32% line:-2
メッセージを
早く届けたいでしょう

00:11:15.342 --> 00:11:20.681 align:start position:21% line:-2
これらは低レベルのネットワークを
利用する場合の例であり

00:11:21.448 --> 00:11:24.685 align:start position:27% line:-1
他のケースでも利用できます

00:11:24.785 --> 00:11:29.423 align:start position:30% line:-2
他のアプリケーションや
ユースケースで

00:11:29.590 --> 00:11:33.861 align:start position:32% line:-2
どんな恩恵を
得られるか説明します

00:11:34.828 --> 00:11:40.200 align:start position:30% line:-2
メールやメッセージング
アプリケーションの

00:11:40.467 --> 00:11:43.036 align:start position:30% line:-1
接続の方法を見ましょう

00:11:44.638 --> 00:11:47.074 align:start position:30% line:-1
メールの接続を例にとり

00:11:47.174 --> 00:11:52.846 align:start position:16% line:-2
セキュリティ機能を付けて
TLSを組み合わせたIMAPを使います

00:11:53.380 --> 00:11:56.783 align:start position:11% line:-2
ホスト名は
mail.example.comから始めます

00:11:57.217 --> 00:12:00.354 align:start position:30% line:-1
993番ポートに接続し

00:11:57.217 --> 00:12:00.354 align:start position:30% line:-1
993番ポートに接続し

00:12:00.654 --> 00:12:03.991 align:start position:29% line:-1
TLSとTCPを使います

00:12:05.058 --> 00:12:07.761 align:start position:32% line:-1
通常のソケットなら―

00:12:08.362 --> 00:12:10.197 align:start position:34% line:-1
こう始まるでしょう

00:12:10.397 --> 00:12:14.935 align:start position:20% line:-2
ホスト名を取得し DNS APIを
呼び出し ホスト名を解決

00:12:15.035 --> 00:12:16.870 align:start position:16% line:-1
例えばgetaddrinfoだとします

00:12:17.237 --> 00:12:21.875 align:start position:29% line:-2
１つ以上のアドレスから
どれに接続するか決めます

00:12:22.442 --> 00:12:25.679 align:start position:29% line:-2
最適なアドレスファミリで
ソケットを呼び

00:12:26.313 --> 00:12:28.916 align:start position:36% line:-1
オプションを設定

00:12:29.016 --> 00:12:33.253 align:start position:25% line:-2
ソケットを
非ブロッキングにする場合は―

00:12:34.555 --> 00:12:39.326 align:start position:21% line:-2
TCPを開始し
書き込み可能なイベントを待ちます

00:12:39.927 --> 00:12:44.698 align:start position:30% line:-2
以上はTLSを使う前で
多くの手間がかかります

00:12:46.366 --> 00:12:48.535 align:start position:18% line:-2
Network.frameworkの
場合は？

00:12:48.635 --> 00:12:53.307 align:start position:29% line:-2
もっとシンプルな使い方が
できるといいですね

00:12:53.674 --> 00:12:56.477 align:start position:29% line:-2
まずは接続オブジェクトの
生成です

00:12:56.577 --> 00:12:58.879 align:start position:27% line:-1
２つのことに基づいています

00:12:58.979 --> 00:13:02.449 align:start position:30% line:-2
１つ目は宛先を定義する
エンドポイント

00:12:58.979 --> 00:13:02.449 align:start position:30% line:-2
１つ目は宛先を定義する
エンドポイント

00:13:02.549 --> 00:13:06.086 align:start position:29% line:-2
これは以前のIPアドレス
かもしれませんが

00:13:06.186 --> 00:13:10.023 align:start position:36% line:-2
通常はホスト名と
ポートがあります

00:13:10.123 --> 00:13:13.260 align:start position:36% line:-2
エンドポイントは
この２つです

00:13:13.393 --> 00:13:16.263 align:start position:27% line:-2
Bonjourサービスへの
接続かもしれません

00:13:17.364 --> 00:13:19.366 align:start position:30% line:-1
２つ目はパラメータです

00:13:19.466 --> 00:13:25.072 align:start position:18% line:-2
TLS DTLS UDP TCPなど
どのプロトコルを使うか定義します

00:13:25.339 --> 00:13:28.108 align:start position:29% line:-1
プロトコルのオプションと

00:13:28.575 --> 00:13:35.048 align:start position:21% line:-2
接続をWi-Fiだけにするかなど
接続に使用するパスを定義します

00:13:36.183 --> 00:13:41.455 align:start position:23% line:-2
設定が終われば
startを呼び出し処理を開始

00:13:41.555 --> 00:13:44.591 align:start position:25% line:-1
readyになるのを待ちます

00:13:44.758 --> 00:13:48.228 align:start position:30% line:-2
TLS接続に必要なのは
これだけです

00:13:48.862 --> 00:13:51.532 align:start position:25% line:-1
Swiftではどうでしょう？

00:13:52.699 --> 00:13:56.436 align:start position:29% line:-2
ネットワークモジュールを
インポートし―

00:13:57.371 --> 00:14:00.541 align:start position:16% line:-2
NWConnectionオブジェクトを
生成します

00:13:57.371 --> 00:14:00.541 align:start position:16% line:-2
NWConnectionオブジェクトを
生成します

00:14:00.641 --> 00:14:04.411 align:start position:27% line:-2
これはSwiftでも
Objective-Cでも

00:14:04.511 --> 00:14:07.481 align:start position:30% line:-2
データの読み書きに
必要なオブジェクトです

00:14:08.382 --> 00:14:13.086 align:start position:29% line:-2
エンドポイントをホストで
初期設定できるため

00:14:13.187 --> 00:14:17.357 align:start position:9% line:-2
ホスト名をmail.example.comにし
ポートを指定します

00:14:17.457 --> 00:14:21.328 align:start position:23% line:-2
ポートは
よく知られているimapsです

00:14:21.428 --> 00:14:27.334 align:start position:27% line:-2
Swiftに簡単に入力でき
他の数値リテラルも入ります

00:14:28.569 --> 00:14:32.406 align:start position:21% line:-2
使用するプロトコルを定義するため
パラメータを渡します

00:14:32.673 --> 00:14:37.778 align:start position:25% line:-2
クライアント接続なので
標準のTLSとTCPのみです

00:14:38.078 --> 00:14:43.183 align:start position:27% line:-2
単純に.tlsと書くだけで
TLS接続ができました

00:14:45.118 --> 00:14:50.958 align:start position:11% line:-2
次に stateUpdateHandlerで
接続の移行を処理します

00:14:51.592 --> 00:14:55.629 align:start position:30% line:-2
ready状態の処理が
特に重要です

00:14:55.796 --> 00:15:01.668 align:start position:23% line:-2
readyはデータの読み書きが
できる状態を指します

00:14:55.796 --> 00:15:01.668 align:start position:23% line:-2
readyはデータの読み書きが
できる状態を指します

00:15:01.768 --> 00:15:06.707 align:start position:21% line:-2
TCPとTLSの場合は
ハンドシェイクの完了も意味します

00:15:08.308 --> 00:15:11.645 align:start position:32% line:-2
waiting状態の
説明をしましょう

00:15:11.745 --> 00:15:16.450 align:start position:7% line:-2
昨年 waitsForConnectivityを
紹介しましたが

00:15:16.550 --> 00:15:20.287 align:start position:9% line:-2
NWConnectionのwaiting状態は
それと同じものです

00:15:20.387 --> 00:15:22.656 align:start position:29% line:-1
標準でオンになっています

00:15:22.756 --> 00:15:26.693 align:start position:29% line:-2
接続を生成し始め
ネットワークがない場合は

00:15:26.793 --> 00:15:30.564 align:start position:34% line:-2
利用可能になるまで
待ってくれます

00:15:30.664 --> 00:15:33.133 align:start position:23% line:-1
reasonコードも使えますが

00:15:33.233 --> 00:15:37.037 align:start position:27% line:-2
ネットワークが移行するまで
待つだけです

00:15:37.404 --> 00:15:40.741 align:start position:29% line:-2
モビリティはこのAPIに
必要不可欠です

00:15:41.808 --> 00:15:43.977 align:start position:34% line:-1
エラーも通知します

00:15:44.077 --> 00:15:49.383 align:start position:27% line:-2
TLSの失敗などは失敗した
イベントとして通知されます

00:15:50.484 --> 00:15:53.620 align:start position:32% line:-2
セットアップ後
startを呼び出し

00:15:53.720 --> 00:15:58.692 align:start position:23% line:-2
コールバックを受け取るための
ディスパッチキューを指定します

00:16:00.360 --> 00:16:04.531 align:start position:27% line:-2
startを呼び出した時の
説明をしましょう

00:16:05.466 --> 00:16:09.503 align:start position:20% line:-2
これは簡単なステートマシン
NWConnectionの内部です

00:16:09.603 --> 00:16:12.239 align:start position:30% line:-2
セットアップの状態から
startを呼び出すと

00:16:12.339 --> 00:16:15.008 align:start position:32% line:-1
準備の状態に移ります

00:16:16.276 --> 00:16:18.545 align:start position:38% line:-1
準備の状態は―

00:16:18.645 --> 00:16:22.950 align:start position:27% line:-2
ただ接続を
呼び出す以上のことをします

00:16:23.584 --> 00:16:29.756 align:start position:25% line:-2
TCPソケットはサーバに
SYNパケットを送るだけです

00:16:30.757 --> 00:16:36.530 align:start position:7% line:-2
NWConnectionでstartを呼び出すと
多くの処理をします

00:16:37.497 --> 00:16:42.636 align:start position:25% line:-2
そして ネットワークを評価し
最速で接続するのです

00:16:42.736 --> 00:16:44.771 align:start position:30% line:-1
さらに掘り下げましょう

00:16:44.972 --> 00:16:48.709 align:start position:21% line:-2
Smart Connection
Establishmentです

00:16:49.910 --> 00:16:55.382 align:start position:27% line:-2
startを呼び出す時は
まずエンドポイントを取得し

00:16:55.749 --> 00:16:59.286 align:start position:29% line:-2
利用可能な
ネットワークを評価します

00:16:59.753 --> 00:17:02.656 align:start position:30% line:-2
この場合はWi-Fiと
モバイルデータ通信です

00:16:59.753 --> 00:17:02.656 align:start position:30% line:-2
この場合はWi-Fiと
モバイルデータ通信です

00:17:03.023 --> 00:17:07.560 align:start position:29% line:-2
コストが低く
人気の高いWi-Fiから

00:17:08.028 --> 00:17:09.762 align:start position:36% line:-1
見ていきましょう

00:17:10.964 --> 00:17:14.601 align:start position:29% line:-2
このネットワークの設定を
確認します

00:17:14.701 --> 00:17:18.539 align:start position:34% line:-2
VPNやプロキシの
有無を調べるのです

00:17:19.306 --> 00:17:25.378 align:start position:29% line:-2
今回は自動設定ファイルで
設定されたプロキシがあり

00:17:25.479 --> 00:17:30.417 align:start position:27% line:-2
接続が適合しない場合は
直接アクセスできるとします

00:17:30.517 --> 00:17:32.986 align:start position:34% line:-2
２つのオプションを
評価します

00:17:33.554 --> 00:17:39.092 align:start position:29% line:-2
プロキシが必要なら接続し
TCP接続を確立します

00:17:39.860 --> 00:17:45.065 align:start position:29% line:-2
不要なら皆さんの代わりに
DNSに問い合わせます

00:17:45.165 --> 00:17:48.569 align:start position:32% line:-2
全てのIPアドレスの
応答を得て

00:17:48.669 --> 00:17:53.240 align:start position:36% line:-2
１つずつ並行して
接続を試します

00:17:53.340 --> 00:17:56.743 align:start position:36% line:-2
競争させることで
最速で接続します

00:17:59.346 --> 00:18:01.348 align:start position:30% line:-1
Wi-Fiを使っていて

00:17:59.346 --> 00:18:01.348 align:start position:30% line:-1
Wi-Fiを使っていて

00:18:01.448 --> 00:18:05.953 align:start position:29% line:-2
建物から離れて
電波が弱くなった場合は？

00:18:07.221 --> 00:18:10.791 align:start position:30% line:-2
Wi-Fi アシストが
活用できます

00:18:10.891 --> 00:18:14.361 align:start position:32% line:-2
モバイルデータ通信に
フォールバックし

00:18:14.528 --> 00:18:19.766 align:start position:30% line:-2
DNSで解決して
１つずつ接続を試します

00:18:20.200 --> 00:18:26.206 align:start position:29% line:-2
これにより接続を回復させ
VPNやプロキシを処理し

00:18:26.306 --> 00:18:30.244 align:start position:36% line:-2
最適な接続を
提供できるのです

00:18:31.879 --> 00:18:35.382 align:start position:30% line:-2
オプションが
不要な方もいるでしょう

00:18:35.482 --> 00:18:38.886 align:start position:36% line:-2
接続の確立を
制限したい場合は

00:18:39.553 --> 00:18:42.589 align:start position:30% line:-2
取っ手や
コントロールがあります

00:18:42.689 --> 00:18:45.125 align:start position:34% line:-1
３つだけ紹介します

00:18:46.827 --> 00:18:51.431 align:start position:32% line:-2
高価なネットワークを
使用したくない場合で

00:18:51.532 --> 00:18:55.536 align:start position:30% line:-2
Wi-Fiのみの使用が
適切だとします

00:18:55.969 --> 00:18:58.672 align:start position:29% line:-1
接続のパラメータの中には

00:18:58.939 --> 00:19:02.843 align:start position:27% line:-2
インターフェイスを管理する
オプションがあります

00:18:58.939 --> 00:19:02.843 align:start position:27% line:-2
インターフェイスを管理する
オプションがあります

00:19:02.943 --> 00:19:05.312 align:start position:32% line:-2
モバイルデータ通信が
不要なら

00:19:05.412 --> 00:19:09.249 align:start position:5% line:-2
prohibitedInterfaceTypesに
.cellularを追加します

00:19:10.717 --> 00:19:15.122 align:start position:27% line:-2
高価なネットワークの禁止は
良いことです

00:19:15.222 --> 00:19:20.761 align:start position:25% line:-2
これは例えばMacの
インターネット共有を防ぎます

00:19:22.896 --> 00:19:25.833 align:start position:32% line:-2
接続の確立を制限する
他の方法は

00:19:25.933 --> 00:19:30.104 align:start position:30% line:-2
IPアドレスファミリの
選択の特定です

00:19:30.337 --> 00:19:36.977 align:start position:20% line:-2
とても速いIPv6を気に入っていて
IPv4は使わないとします

00:19:37.244 --> 00:19:42.749 align:start position:23% line:-2
その場合はパラメータの
IP固有のオプションが使えます

00:19:42.849 --> 00:19:48.188 align:start position:27% line:-2
ここには なじみ深い
ソケットのオプションがあり

00:19:48.288 --> 00:19:52.459 align:start position:34% line:-2
IPのバージョンを
定義できます

00:19:52.593 --> 00:19:56.363 align:start position:29% line:-2
これが接続と
DNSの解決に影響します

00:19:57.564 --> 00:20:01.201 align:start position:36% line:-2
最後はプロキシが
不要な場合です

00:19:57.564 --> 00:20:01.201 align:start position:36% line:-2
最後はプロキシが
不要な場合です

00:20:01.301 --> 00:20:05.472 align:start position:23% line:-2
SOCKSプロキシを通る接続が
不適切な時は

00:20:05.639 --> 00:20:09.409 align:start position:36% line:-2
プロキシの使用を
禁止できます

00:20:10.811 --> 00:20:13.747 align:start position:32% line:-1
これが準備の状態です

00:20:14.615 --> 00:20:20.053 align:start position:30% line:-2
設定時にネットワークが
ない場合もあるでしょう

00:20:20.320 --> 00:20:26.527 align:start position:23% line:-2
DNSエラー 良いオプションや
ネットワークがない場合

00:20:26.627 --> 00:20:30.864 align:start position:25% line:-2
機内モードの時は
waiting状態に移ります

00:20:31.365 --> 00:20:38.038 align:start position:27% line:-2
ネットワークの状態が変わり
接続できる状態になると

00:20:38.138 --> 00:20:40.407 align:start position:32% line:-1
再試行を繰り返します

00:20:40.507 --> 00:20:44.845 align:start position:30% line:-2
再試行の度に
ユーザに通知が届きます

00:20:46.413 --> 00:20:52.152 align:start position:27% line:-2
最終的に接続が確立されると
ready状態へ移ります

00:20:53.153 --> 00:20:57.724 align:start position:34% line:-2
これは接続が完全に
確立した状態です

00:20:57.824 --> 00:21:02.930 align:start position:29% line:-2
以上がTLSに至るまでの
全てのプロトコルです

00:20:57.824 --> 00:21:02.930 align:start position:29% line:-2
以上がTLSに至るまでの
全てのプロトコルです

00:21:03.430 --> 00:21:05.299 align:start position:34% line:-1
読み書きが可能です

00:21:05.766 --> 00:21:12.306 align:start position:27% line:-2
ここでネットワーク移行の
コールバックを受け取ります

00:21:12.406 --> 00:21:19.913 align:start position:25% line:-2
ネットワークを変更する場合に
円滑に移行する方法があります

00:21:20.080 --> 00:21:22.583 align:start position:30% line:-1
後ほどお話ししましょう

00:21:24.718 --> 00:21:28.255 align:start position:34% line:-2
接続に何かエラーが
生じた場合は

00:21:28.355 --> 00:21:32.059 align:start position:27% line:-2
確立失敗の状態であるという
通知がきます

00:21:32.793 --> 00:21:38.532 align:start position:25% line:-2
接続を終了したり 無効にして
完全に断ちたい場合には

00:21:38.632 --> 00:21:43.437 align:start position:30% line:-2
キャンセルを呼び出せば
中止の状態に移ります

00:21:43.537 --> 00:21:49.076 align:start position:29% line:-2
関連するメモリを
クリーンアップするための

00:21:49.176 --> 00:21:52.779 align:start position:27% line:-1
オブジェクトを得て終了です

00:21:53.814 --> 00:21:59.353 align:start position:29% line:-2
以上が接続オブジェクトの
基本的な流れです

00:21:59.453 --> 00:22:05.058 align:start position:32% line:-2
ではここでエリックを
ステージに迎えます

00:21:59.453 --> 00:22:05.058 align:start position:32% line:-2
ではここでエリックを
ステージに迎えます

00:22:05.659 --> 00:22:11.298 align:start position:43% line:-1
(拍手)

00:22:13.400 --> 00:22:14.434 align:start position:45% line:-1
どうも

00:22:14.535 --> 00:22:17.704 align:start position:32% line:-1
エリック･キニアです

00:22:17.804 --> 00:22:22.309 align:start position:29% line:-2
今からアプリケーションの
一例を構築します

00:22:22.943 --> 00:22:26.813 align:start position:20% line:-2
Live Streamingを例に
使いましょう

00:22:26.980 --> 00:22:30.851 align:start position:32% line:-2
あるデバイスから
ネットワークを通して

00:22:30.951 --> 00:22:34.621 align:start position:34% line:-2
別のデバイスに
映像を映し出します

00:22:35.255 --> 00:22:38.625 align:start position:29% line:-2
継続的にビデオフレームを
生成するため

00:22:38.826 --> 00:22:42.529 align:start position:30% line:-2
UDPでパケットを
ネットワークに送ります

00:22:43.063 --> 00:22:44.364 align:start position:39% line:-1
その方法は？

00:22:46.133 --> 00:22:49.136 align:start position:27% line:-1
カメラでセッションを保存し

00:22:49.236 --> 00:22:52.372 align:start position:25% line:-2
イメージセンサーから
ビデオフレームを受け取ります

00:22:53.006 --> 00:22:57.678 align:start position:29% line:-2
ビデオコーデックや
他の圧縮機能は使いません

00:22:57.778 --> 00:23:03.250 align:start position:27% line:-2
低バイトのデータを受け取り
別の画面に映し出します

00:22:57.778 --> 00:23:03.250 align:start position:27% line:-2
低バイトのデータを受け取り
別の画面に映し出します

00:23:04.351 --> 00:23:10.824 align:start position:27% line:-2
フレームを小さな塊に分割し
UDPパケットを送信

00:23:11.859 --> 00:23:15.529 align:start position:27% line:-1
当然 接続が必要になります

00:23:16.797 --> 00:23:18.499 align:start position:38% line:-1
接続を受け取り

00:23:18.599 --> 00:23:24.638 align:start position:29% line:-2
データパケットを読み取る
リスナーが必要です

00:23:25.005 --> 00:23:27.574 align:start position:36% line:-1
そして逆の手順で

00:23:27.674 --> 00:23:32.379 align:start position:29% line:-2
ビデオフレームを再構築し
ディスプレイへ送ります

00:23:33.947 --> 00:23:38.685 align:start position:27% line:-2
カメラとディスプレイ機能を
省くことで

00:23:38.786 --> 00:23:42.222 align:start position:18% line:-2
Network.frameworkを
使う部分に焦点を当てます

00:23:43.490 --> 00:23:48.061 align:start position:34% line:-2
隠していない部分は
リスナーです

00:23:50.230 --> 00:23:53.801 align:start position:20% line:-2
リスナー機能は
NWListnerで提供されており

00:23:53.901 --> 00:23:58.672 align:start position:14% line:-2
接続の設定と同じ
Parameterオブジェクトで作れます

00:23:59.706 --> 00:24:03.911 align:start position:21% line:-2
Bonjourサービスを
アドバタイズするリスナーの設定に

00:23:59.706 --> 00:24:03.911 align:start position:21% line:-2
Bonjourサービスを
アドバタイズするリスナーの設定に

00:24:04.011 --> 00:24:06.613 align:start position:16% line:-1
今回はcamera.udpを使用します

00:24:08.916 --> 00:24:11.485 align:start position:30% line:-1
新しい接続を受け取ると

00:24:11.585 --> 00:24:15.823 align:start position:9% line:-2
newConnectionHandlerとして
提供したブロックへ渡します

00:24:16.356 --> 00:24:20.828 align:start position:25% line:-1
接続中に選択した設定を実行し

00:24:20.928 --> 00:24:25.265 align:start position:29% line:-2
開始を知らせるため
startを呼び出します

00:24:26.733 --> 00:24:31.038 align:start position:32% line:-2
同様にリスナーも
startを呼び出し

00:24:31.138 --> 00:24:34.508 align:start position:32% line:-2
ディスパッチキューを
指定します

00:24:35.776 --> 00:24:36.877 align:start position:34% line:-1
これがリスナーです

00:24:36.977 --> 00:24:42.082 align:start position:25% line:-2
UDPソケット上にリッスンを
呼び出すのと同等の機能です

00:24:42.816 --> 00:24:46.120 align:start position:25% line:-2
ただし リッスンは
UDPソケットでは使えません

00:24:47.354 --> 00:24:49.723 align:start position:20% line:-1
XcodeでAppを構築しましょう

00:24:50.524 --> 00:24:52.392 align:start position:32% line:-1
こちらにAppがあり

00:24:52.493 --> 00:24:57.331 align:start position:27% line:-2
カメラとディスプレイ機能を
操作するファイルがあります

00:24:57.598 --> 00:25:02.469 align:start position:14% line:-2
UDPClientクラスと
UDPServerクラスに注目しましょう

00:24:57.598 --> 00:25:02.469 align:start position:14% line:-2
UDPClientクラスと
UDPServerクラスに注目しましょう

00:25:03.270 --> 00:25:09.443 align:start position:20% line:-2
UDPClientはフレームを送る
接続を作成します

00:25:10.144 --> 00:25:13.614 align:start position:29% line:-1
サーバはそれらを受け取り

00:25:13.747 --> 00:25:19.019 align:start position:27% line:-2
データを読み取り画面に送る
リスナーを作成します

00:25:19.620 --> 00:25:20.888 align:start position:29% line:-1
クライアントから始めます

00:25:22.422 --> 00:25:25.792 align:start position:32% line:-2
イニシャライザが
ネームを取り込みます

00:25:25.893 --> 00:25:30.130 align:start position:21% line:-2
ネームとはBonjour名を表す
文字列です

00:25:31.565 --> 00:25:35.636 align:start position:20% line:-2
NWConnectionを呼び出し
エンドポイントを通過させて

00:25:35.736 --> 00:25:37.671 align:start position:36% line:-1
接続を作成します

00:25:38.005 --> 00:25:42.342 align:start position:23% line:-2
名前と種類は
camera.udpを使います

00:25:43.644 --> 00:25:46.180 align:start position:34% line:-2
UDPパラメータも
通過しました

00:25:47.748 --> 00:25:50.884 align:start position:34% line:-2
ready状態か
確立失敗の状態か―

00:25:52.252 --> 00:25:55.355 align:start position:36% line:-2
ハンドラを使って
確認できます

00:25:55.956 --> 00:26:01.695 align:start position:12% line:-2
sendInitialFrameを呼び出し
１分以内に実行

00:25:55.956 --> 00:26:01.695 align:start position:12% line:-2
sendInitialFrameを呼び出し
１分以内に実行

00:26:02.596 --> 00:26:05.766 align:start position:32% line:-2
他のハンドシェイクは
ありません

00:26:05.866 --> 00:26:10.704 align:start position:29% line:-2
そのためビデオフレームを
ネットワークに落とす前に

00:26:10.804 --> 00:26:16.109 align:start position:30% line:-2
別のデバイスに送信し
エコーバックを待ちます

00:26:19.413 --> 00:26:24.651 align:start position:23% line:-2
そして自分の接続上で
startを呼び出してください

00:26:26.120 --> 00:26:27.955 align:start position:30% line:-1
最初のフレーム送信です

00:26:32.359 --> 00:26:37.264 align:start position:18% line:-2
ここは“hello”というリテラルで
データオブジェクトを作成

00:26:38.031 --> 00:26:41.835 align:start position:14% line:-2
connection.sendを呼び出し
データオブジェクトを

00:26:41.935 --> 00:26:44.872 align:start position:27% line:-1
コンテンツとして提供します

00:26:45.772 --> 00:26:51.278 align:start position:25% line:-2
提供される完了ハンドラで
送信中のエラーを確認できます

00:26:53.080 --> 00:26:55.749 align:start position:29% line:-1
エコーバックが欲しいので

00:26:55.849 --> 00:27:00.854 align:start position:5% line:-2
データを読み込むための
connection.receiveを呼び出します

00:26:55.849 --> 00:27:00.854 align:start position:5% line:-2
データを読み込むための
connection.receiveを呼び出します

00:27:01.422 --> 00:27:04.691 align:start position:30% line:-2
その完了ハンドラの中で
コンテンツを確認後

00:27:04.792 --> 00:27:08.462 align:start position:29% line:-2
残りのアプリケーションに
接続されます

00:27:08.562 --> 00:27:11.865 align:start position:25% line:-2
そしてカメラハードウェアから
フレームの生成を開始

00:27:13.901 --> 00:27:19.573 align:start position:21% line:-2
この時 残りのアプリケーションが
送信を呼び出します

00:27:22.676 --> 00:27:27.414 align:start position:25% line:-2
そしてそこに
データオブジェクトを渡します

00:27:28.982 --> 00:27:32.319 align:start position:34% line:-2
送信の操作を
早く完了させるため

00:27:32.419 --> 00:27:36.123 align:start position:14% line:-2
connection.batchを通った
ブロック内だけで実行しましょう

00:27:37.558 --> 00:27:42.529 align:start position:32% line:-2
このブロック内で
全てのフレームを調べ

00:27:42.629 --> 00:27:45.432 align:start position:14% line:-1
connection.sendへ渡します

00:27:45.732 --> 00:27:51.205 align:start position:27% line:-2
先ほどと同様に
完了ハンドラでエラーを確認

00:27:51.939 --> 00:27:55.909 align:start position:21% line:-2
これでUDPクライアントクラスが
完成しました

00:27:57.644 --> 00:27:58.879 align:start position:30% line:-1
サーバを見てみましょう

00:27:59.780 --> 00:28:04.017 align:start position:27% line:-2
サーバ側には接続を受け取る
リスナーが必要です

00:27:59.780 --> 00:28:04.017 align:start position:27% line:-2
サーバ側には接続を受け取る
リスナーが必要です

00:28:04.117 --> 00:28:07.154 align:start position:30% line:-2
先ほどの
ハンドシェイクに応答し

00:28:07.254 --> 00:28:10.858 align:start position:23% line:-2
データを読み取り
ディスプレイに到達させましょう

00:28:11.492 --> 00:28:12.793 align:start position:32% line:-1
リスナーから始めます

00:28:16.196 --> 00:28:19.933 align:start position:29% line:-2
まず UDPパラメータで
NWリスナーを作成します

00:28:21.135 --> 00:28:24.271 align:start position:29% line:-2
この時 ローカルポートを
リッスンするよう

00:28:24.371 --> 00:28:27.141 align:start position:32% line:-2
リスナーに
伝えることもできます

00:28:27.241 --> 00:28:30.210 align:start position:20% line:-2
今回はBonjourサービスのため
不要です

00:28:33.514 --> 00:28:37.417 align:start position:25% line:-2
次にサービスプロパティを
camera.udpタイプの

00:28:38.151 --> 00:28:40.821 align:start position:30% line:-2
サービスオブジェクトに
設定します

00:28:41.088 --> 00:28:46.627 align:start position:27% line:-2
デバイスネームを得るので
ネームの受け渡しはしません

00:28:47.661 --> 00:28:51.598 align:start position:11% line:-2
さらにserviceRegistration
UpdateHandlerにブロックを提供し

00:28:52.032 --> 00:28:57.471 align:start position:29% line:-2
エンドポイントをいつでも
呼び出すことができます

00:28:57.871 --> 00:29:00.841 align:start position:34% line:-2
エンドポイントが
加えられる場所は？

00:28:57.871 --> 00:29:00.841 align:start position:34% line:-2
エンドポイントが
加えられる場所は？

00:29:00.941 --> 00:29:04.711 align:start position:29% line:-2
サーバ型なら
残りのアプリケーションに

00:29:04.812 --> 00:29:09.049 align:start position:29% line:-2
初期設定の
デバイスネームを伝えます

00:29:09.149 --> 00:29:13.053 align:start position:27% line:-2
それをユーザに
別の場所で入力させるのです

00:29:19.927 --> 00:29:22.830 align:start position:27% line:-1
次は接続ハンドラの設定です

00:29:22.930 --> 00:29:26.366 align:start position:29% line:-2
これは接続を受け取る度に
呼び出されます

00:29:27.534 --> 00:29:34.174 align:start position:7% line:-2
そしてconnection.startを呼び出し
キューに送りましょう

00:29:36.343 --> 00:29:40.647 align:start position:23% line:-2
ここで残りのアプリケーションに
接続を伝えると

00:29:40.747 --> 00:29:45.385 align:start position:30% line:-2
ビデオフレームを
表示する準備が整います

00:29:46.286 --> 00:29:49.723 align:start position:23% line:-2
そしてreceiveを呼び出し
すぐに実行して

00:29:49.823 --> 00:29:53.694 align:start position:27% line:-2
データを読み取り
パイプラインに送り出します

00:29:55.562 --> 00:29:57.931 align:start position:29% line:-1
ここでも更新ハンドラで―

00:30:00.901 --> 00:30:05.372 align:start position:27% line:-2
ready状態か確立失敗か
確認します

00:30:07.441 --> 00:30:14.014 align:start position:12% line:-2
そしてlistner.startを呼び出し
キューに送ります

00:30:15.649 --> 00:30:20.954 align:start position:27% line:-2
次に ネットワークの情報を
読み取り 受信機能を実行

00:30:24.858 --> 00:30:29.296 align:start position:9% line:-2
そしてconnection.receiveから
完了ハンドラへ送ります

00:30:29.530 --> 00:30:33.567 align:start position:32% line:-2
データが入ってくる際
接続されていなければ

00:30:33.834 --> 00:30:38.806 align:start position:27% line:-2
クライアントが送信を始めた
ハンドシェイクでしょう

00:30:40.140 --> 00:30:45.145 align:start position:18% line:-2
単にconnection.sendで
同じコンテンツを送り戻せば

00:30:45.245 --> 00:30:47.181 align:start position:38% line:-2
クライアントに
エコーされます

00:30:47.548 --> 00:30:52.019 align:start position:34% line:-2
そして全ての後続の
コールバック上で

00:30:52.119 --> 00:30:56.523 align:start position:29% line:-2
残りのアプリケーションに
受信を伝えます

00:30:56.623 --> 00:31:00.360 align:start position:23% line:-2
フレームはパイプラインに送られ
画面で確認可能です

00:30:56.623 --> 00:31:00.360 align:start position:23% line:-2
フレームはパイプラインに送られ
画面で確認可能です

00:31:01.828 --> 00:31:05.132 align:start position:34% line:-2
後続するフレームも
受け取れたら

00:31:05.232 --> 00:31:11.805 align:start position:25% line:-2
それらがディスプレイに送られ
ビデオとして表示されます

00:31:13.240 --> 00:31:16.743 align:start position:29% line:-2
これでUDPクライアント
UDPサーバは完成です

00:31:16.844 --> 00:31:18.011 align:start position:38% line:-1
実演しましょう

00:31:20.447 --> 00:31:23.317 align:start position:34% line:-2
クライアントを
携帯電話上で起動し

00:31:23.417 --> 00:31:27.187 align:start position:27% line:-1
Macのサーバも起動します

00:31:28.255 --> 00:31:29.957 align:start position:30% line:-1
今 サーバが立ち上がり

00:31:30.290 --> 00:31:33.160 align:start position:36% line:-2
デモ版のMacと
表示されています

00:31:33.360 --> 00:31:37.397 align:start position:27% line:-2
システムにネームを送るよう
命じたからです

00:31:38.065 --> 00:31:40.434 align:start position:30% line:-1
これは私の携帯電話です

00:31:41.268 --> 00:31:47.207 align:start position:27% line:-2
接続をタップすると
ビデオフレームが見られます

00:31:48.075 --> 00:31:54.915 align:start position:43% line:-1
(拍手)

00:31:58.218 --> 00:32:01.555 align:start position:29% line:-2
Bonjourサービスに
接続可能な

00:31:58.218 --> 00:32:01.555 align:start position:29% line:-2
Bonjourサービスに
接続可能な

00:32:01.655 --> 00:32:05.025 align:start position:32% line:-2
UDPクライアントを
構築しました

00:32:05.759 --> 00:32:09.263 align:start position:27% line:-2
これでハンドシェイクの送信
待機ができます

00:32:09.830 --> 00:32:13.167 align:start position:23% line:-2
ビデオフレームをネットワークに
届けることも可能です

00:32:14.334 --> 00:32:18.906 align:start position:29% line:-2
サーバ側にできた
Bonjourリスナーは

00:32:19.006 --> 00:32:23.577 align:start position:25% line:-2
サービスを通知し 接続を受信
ハンドシェイクに応答

00:32:23.677 --> 00:32:26.480 align:start position:27% line:-1
これらは画面で確認できます

00:32:27.114 --> 00:32:32.786 align:start position:21% line:-2
次は データ移行の最適化について
トミーがお話しします

00:32:32.953 --> 00:32:38.492 align:start position:43% line:-1
(拍手)

00:32:38.826 --> 00:32:40.160 align:start position:45% line:-1
どうも

00:32:40.894 --> 00:32:43.864 align:start position:18% line:-2
Network.frameworkを
始めるのは簡単です

00:32:43.964 --> 00:32:45.332 align:start position:16% line:-1
Network.frameworkでの

00:32:45.432 --> 00:32:50.104 align:start position:30% line:-2
接続の構築と受け取りの
方法が分かりました

00:32:50.504 --> 00:32:55.809 align:start position:12% line:-2
Network.frameworkにおける
重要な点は

00:32:55.909 --> 00:33:00.480 align:start position:25% line:-2
ソケット以上に作業を
最適化する方法を持つことです

00:32:55.909 --> 00:33:00.480 align:start position:25% line:-2
ソケット以上に作業を
最適化する方法を持つことです

00:33:01.548 --> 00:33:05.752 align:start position:32% line:-2
アプリケーション内で
ネットワーク接続と―

00:33:05.853 --> 00:33:11.992 align:start position:23% line:-2
相互作用する基本的な
データの送受信を見てみましょう

00:33:12.659 --> 00:33:15.129 align:start position:29% line:-1
呼び出し方法は単純ですが

00:33:15.229 --> 00:33:20.567 align:start position:27% line:-2
送受信はアプリケーションの
反応速度に影響し

00:33:20.667 --> 00:33:26.640 align:start position:27% line:-2
バッファリングはデバイスと
ネットワークに依存します

00:33:27.775 --> 00:33:31.745 align:start position:27% line:-2
では アプリケーションで
データを送信してみましょう

00:33:31.845 --> 00:33:34.982 align:start position:27% line:-2
先ほどのアプリケーションに
似ていますが

00:33:35.082 --> 00:33:38.986 align:start position:30% line:-2
こちらはデータを忙しく
生成するものです

00:33:39.586 --> 00:33:43.657 align:start position:32% line:-2
今回使用する
TCPストリームには

00:33:43.757 --> 00:33:48.395 align:start position:36% line:-2
あるウインドウが
実装されています

00:33:48.495 --> 00:33:50.197 align:start position:36% line:-1
その操作方法は？

00:33:51.565 --> 00:33:54.234 align:start position:32% line:-2
これが単一フレームを
送る機能で

00:33:54.334 --> 00:33:58.172 align:start position:32% line:-2
これは生成した
データのフレームです

00:33:59.439 --> 00:34:05.045 align:start position:9% line:-2
まず connection.sendを呼び出し
データを受け渡します

00:33:59.439 --> 00:34:05.045 align:start position:9% line:-2
まず connection.sendを呼び出し
データを受け渡します

00:34:05.679 --> 00:34:12.920 align:start position:21% line:-2
ソケットでの送信に慣れているなら
ブロッキングソケットを使います

00:34:13.020 --> 00:34:17.091 align:start position:29% line:-2
大容量のデータがあったり
空き容量がない場合

00:34:17.190 --> 00:34:24.063 align:start position:27% line:-2
スレッドが遮断されるか
接続が消えるまで待機します

00:34:25.032 --> 00:34:27.967 align:start position:30% line:-1
非ブロッキングの場合は

00:34:28.835 --> 00:34:31.672 align:start position:34% line:-1
全データを送れずに

00:34:31.772 --> 00:34:36.143 align:start position:32% line:-2
50バイトずつ分けて
送る場合もあり得ます

00:34:36.409 --> 00:34:42.949 align:start position:29% line:-2
その場合は多くの状態を
操作しなければいけません

00:34:44.451 --> 00:34:50.090 align:start position:25% line:-2
ネットワーク接続なら一度に
全てのデータの送信が可能です

00:34:50.524 --> 00:34:52.192 align:start position:34% line:-1
並列処理ができます

00:34:52.993 --> 00:34:57.063 align:start position:29% line:-2
しかし バックアップ中の
事象には対処が必要です

00:34:57.164 --> 00:35:01.635 align:start position:30% line:-2
ライブ配信データの速い
やりとりのために

00:34:57.164 --> 00:35:01.635 align:start position:30% line:-2
ライブ配信データの速い
やりとりのために

00:35:01.735 --> 00:35:05.372 align:start position:29% line:-2
大量のデータを送ることは
避けたいからです

00:35:06.240 --> 00:35:09.877 align:start position:30% line:-2
ここで重要なのは
コールバックのブロック

00:35:10.210 --> 00:35:12.446 align:start position:18% line:-1
contentProcessedです

00:35:12.646 --> 00:35:17.451 align:start position:25% line:-2
ネットワーク･スタックが
データを消費すると起動します

00:35:17.551 --> 00:35:21.922 align:start position:29% line:-2
送信が完了または
認識されたとは限りません

00:35:22.022 --> 00:35:27.327 align:start position:25% line:-2
これはブロッキングソケット･
コールが戻る時間と

00:35:27.427 --> 00:35:32.032 align:start position:21% line:-2
非ブロッキングソケット･コールが
バイトを消費する時間と同じです

00:35:33.300 --> 00:35:36.837 align:start position:34% line:-2
完了ハンドラ上では
２つ確認できます

00:35:37.404 --> 00:35:39.773 align:start position:34% line:-1
１つ目はエラーです

00:35:39.873 --> 00:35:46.647 align:start position:21% line:-2
データ送信中の問題や
多くは全体の接続失敗を意味します

00:35:47.681 --> 00:35:49.750 align:start position:36% line:-1
エラーがなければ

00:35:49.850 --> 00:35:55.823 align:start position:27% line:-2
生成するデータが他にないか
確認するチャンスです

00:35:55.923 --> 00:35:59.193 align:start position:29% line:-2
ライブデータのフレームを
生成しているなら

00:35:59.593 --> 00:36:04.832 align:start position:23% line:-2
別のビデオストリームから
フレームをフェッチしてください

00:35:59.593 --> 00:36:04.832 align:start position:23% line:-2
別のビデオストリームから
フレームをフェッチしてください

00:36:04.932 --> 00:36:08.102 align:start position:32% line:-2
これでデータの速度を
調整できます

00:36:08.669 --> 00:36:14.141 align:start position:21% line:-2
そして非同期の送信コールバックで
接続からデータを抜き

00:36:14.241 --> 00:36:19.980 align:start position:32% line:-2
それを優雅に操作する
ループを形成しました

00:36:22.482 --> 00:36:26.720 align:start position:30% line:-2
もう１つ 送信について
注目したいのは

00:36:26.820 --> 00:36:32.893 align:start position:29% line:-2
UDPアプリケーションに
最適だということです

00:36:33.827 --> 00:36:39.333 align:start position:25% line:-2
多くの小さなデータや
個別のパケットを送信するなら

00:36:40.067 --> 00:36:43.404 align:start position:11% line:-2
connection.batchという機能を
使うことができます

00:36:43.504 --> 00:36:45.739 align:start position:30% line:-1
以前 UDPソケットは

00:36:45.839 --> 00:36:49.977 align:start position:25% line:-2
１つのパケットしか送信できず
非効率でした

00:36:50.077 --> 00:36:52.980 align:start position:29% line:-2
つまり 多くの
UDPパケットがある時は

00:36:53.080 --> 00:36:58.318 align:start position:21% line:-2
異なるシステムコールやコピー
コンテキストスイッチがありました

00:36:59.086 --> 00:37:02.156 align:start position:30% line:-2
しかし ブロックの中で
バッチを呼び出せば

00:36:59.086 --> 00:37:02.156 align:start position:30% line:-2
しかし ブロックの中で
バッチを呼び出せば

00:37:02.256 --> 00:37:05.759 align:start position:27% line:-1
好きなだけ送受信が可能です

00:37:05.859 --> 00:37:11.732 align:start position:25% line:-2
バッチをブロックし終えるまで
接続はデータ処理を阻止します

00:37:11.832 --> 00:37:14.601 align:start position:30% line:-2
そして データグラムを
一塊として

00:37:14.701 --> 00:37:17.471 align:start position:29% line:-1
システムに送信を試みます

00:37:17.571 --> 00:37:22.910 align:start position:25% line:-2
１回のコンテキストスイッチで
インターフェイスに送信

00:37:23.010 --> 00:37:25.646 align:start position:30% line:-1
これで効率が上がります

00:37:27.414 --> 00:37:28.515 align:start position:38% line:-1
以上が送信です

00:37:28.749 --> 00:37:32.252 align:start position:34% line:-2
受信も送信と同様に
非同期です

00:37:32.352 --> 00:37:36.657 align:start position:25% line:-2
非同期はバックプレッシャーを
与えてくれます

00:37:38.492 --> 00:37:42.663 align:start position:21% line:-2
今回はTCPベースのプロトコルを
持っています

00:37:42.763 --> 00:37:47.000 align:start position:25% line:-2
これはレコードフォーマットを
読み込むアプリケーションで―

00:37:47.101 --> 00:37:49.403 align:start position:27% line:-1
よく使われるプロトコルです

00:37:50.571 --> 00:37:54.575 align:start position:23% line:-2
プロトコルがデータの長さなどの
情報を伝える―

00:37:54.675 --> 00:37:59.713 align:start position:27% line:-2
10バイトの
ヘッダを持っているとします

00:38:00.514 --> 00:38:04.117 align:start position:29% line:-2
ヘッダ コンテンツの順に
読み込むとして

00:38:04.218 --> 00:38:08.055 align:start position:23% line:-2
コンテンツが
２～３メガバイトだとしましょう

00:38:08.956 --> 00:38:12.359 align:start position:27% line:-2
従来のソケットは
10バイトを読み込もうとし

00:38:12.593 --> 00:38:17.531 align:start position:29% line:-2
10バイトを受け取るまで
読み込み続けます

00:38:17.965 --> 00:38:21.769 align:start position:29% line:-2
その後２～３メガバイトを
読み込み

00:38:21.869 --> 00:38:26.807 align:start position:21% line:-2
アプリケーションとスタックの間で
行き来するでしょう

00:38:28.575 --> 00:38:31.945 align:start position:18% line:-2
しかし NWConnectionでは
receiveを呼び出す時

00:38:32.179 --> 00:38:37.084 align:start position:29% line:-2
受け取りたい最小と
最大のデータを提供します

00:38:37.551 --> 00:38:41.722 align:start position:27% line:-2
10バイトを受け取りたいと
明記できるのです

00:38:41.822 --> 00:38:47.027 align:start position:25% line:-2
最小でも最大でも10バイトと
言うことができます

00:38:47.161 --> 00:38:52.666 align:start position:23% line:-2
接続全体にエラーがあった場合や
10バイトを読み込んだ場合は

00:38:52.766 --> 00:38:55.269 align:start position:34% line:-1
呼び戻されるのです

00:38:55.469 --> 00:39:00.874 align:start position:25% line:-2
そして コンテンツを読み込み
データの長さを呼び出せます

00:38:55.469 --> 00:39:00.874 align:start position:25% line:-2
そして コンテンツを読み込み
データの長さを呼び出せます

00:39:01.208 --> 00:39:04.478 align:start position:34% line:-2
２～３メガバイトを
読み込む場合は

00:39:04.578 --> 00:39:07.481 align:start position:34% line:-2
ボディの読み込みと
同じことをします

00:39:07.781 --> 00:39:11.719 align:start position:32% line:-2
読み込む量の
指示を送るだけなので

00:39:11.819 --> 00:39:15.088 align:start position:25% line:-2
アプリケーションとスタックを
行き来せずに済みます

00:39:15.188 --> 00:39:18.358 align:start position:36% line:-2
コールバックを
一度するだけです

00:39:19.493 --> 00:39:23.230 align:start position:32% line:-2
相互作用を最適化する
素晴らしい方法です

00:39:24.565 --> 00:39:29.403 align:start position:23% line:-2
ネットワークパラメータの中でも
高度なオプションを紹介します

00:39:30.070 --> 00:39:34.942 align:start position:23% line:-2
送受信をする際の
ネットワークの反応を良くしたり

00:39:35.042 --> 00:39:40.414 align:start position:30% line:-2
起動時間の改善のために
接続を設定できます

00:39:41.115 --> 00:39:45.519 align:start position:27% line:-2
まずは WWDCで
何度も話しているECNです

00:39:45.619 --> 00:39:49.156 align:start position:23% line:-1
ふくそう情報通知機能のことです

00:39:49.957 --> 00:39:55.662 align:start position:23% line:-2
エンドホストにネットワーク上の
混雑状況を通知させ

00:39:55.762 --> 00:40:01.668 align:start position:30% line:-2
接続を円滑にし 速度を
うまく調整する方法です

00:39:55.762 --> 00:40:01.668 align:start position:30% line:-2
接続を円滑にし 速度を
うまく調整する方法です

00:40:02.536 --> 00:40:07.307 align:start position:29% line:-2
これは全てのTCP接続で
標準的に使用できます

00:40:07.407 --> 00:40:08.709 align:start position:38% line:-1
設定は不要です

00:40:09.309 --> 00:40:13.113 align:start position:32% line:-2
以前はUDPベースの
プロトコルを用いた―

00:40:13.213 --> 00:40:15.349 align:start position:29% line:-1
ECNの使用は困難でした

00:40:15.916 --> 00:40:18.185 align:start position:29% line:-1
ではECNの使用方法は？

00:40:19.653 --> 00:40:23.557 align:start position:20% line:-2
ipMetadataオブジェクトの
作成から始めましょう

00:40:23.657 --> 00:40:27.728 align:start position:23% line:-2
ECNはIPパケットのフラグに
管理されていて

00:40:27.995 --> 00:40:33.534 align:start position:25% line:-2
パケットごとに様々なフラグを
設定することができます

00:40:34.201 --> 00:40:37.071 align:start position:30% line:-2
それを１つに
まとめることも可能です

00:40:37.171 --> 00:40:42.743 align:start position:27% line:-2
コンテキストオブジェクトは
複数のプロトコルのための

00:40:42.943 --> 00:40:47.214 align:start position:29% line:-2
全オプションや優先事項を
類型化できます

00:40:48.082 --> 00:40:52.853 align:start position:29% line:-2
そしてこのコンテキストを
特別なパラメータとして

00:40:53.086 --> 00:40:55.522 align:start position:32% line:-1
送信コールへ送ります

00:40:55.889 --> 00:40:59.359 align:start position:32% line:-2
これを送信する時
生成されるパケットは

00:40:59.459 --> 00:41:03.096 align:start position:30% line:-2
マークしたかった
全てのフラグを持ちます

00:40:59.459 --> 00:41:03.096 align:start position:30% line:-2
マークしたかった
全てのフラグを持ちます

00:41:03.197 --> 00:41:04.431 align:start position:38% line:-1
とても簡単です

00:41:05.198 --> 00:41:09.369 align:start position:29% line:-2
そして受信する時も
同様のフラグを得られます

00:41:09.469 --> 00:41:12.639 align:start position:27% line:-2
受信に関連したコンテキスト
オブジェクトを持ち

00:41:12.740 --> 00:41:16.877 align:start position:29% line:-2
特定の低レベルのフラグを
読み取れます

00:41:19.213 --> 00:41:22.216 align:start position:29% line:-2
同様に
サービスクラスもあります

00:41:22.316 --> 00:41:27.054 align:start position:27% line:-2
これはURLセッションでも
有効なプロパティで

00:41:27.154 --> 00:41:31.225 align:start position:32% line:-2
トラフィックの
優先順位を定義します

00:41:31.391 --> 00:41:36.530 align:start position:23% line:-2
そして 送信時にトラフィックが
待ち行列に入る方法や

00:41:36.630 --> 00:41:40.267 align:start position:23% line:-2
Cisco ファストレーンでの
働きに影響します

00:41:41.401 --> 00:41:45.973 align:start position:25% line:-2
サービスクラスのパラメータを
使うことで

00:41:46.073 --> 00:41:50.978 align:start position:23% line:-2
接続全体で
サービスクラスをマークできます

00:41:51.345 --> 00:41:55.516 align:start position:25% line:-2
今回はバックグラウンド
サービスクラスを使いましょう

00:41:55.616 --> 00:42:00.020 align:start position:29% line:-2
接続の優先順位が
低いことをマークできます

00:41:55.616 --> 00:42:00.020 align:start position:29% line:-2
接続の優先順位が
低いことをマークできます

00:42:00.120 --> 00:42:03.824 align:start position:30% line:-2
ユーザの対話式データは
邪魔したくないため

00:42:03.924 --> 00:42:09.329 align:start position:27% line:-2
バックグラウンド
サービスクラスを推奨します

00:42:10.664 --> 00:42:16.470 align:start position:23% line:-2
パケットごとにサービスクラスを
マークすることもできます

00:42:16.870 --> 00:42:21.108 align:start position:29% line:-2
同じUDPフローの中に
声と信号を発するデータを

00:42:21.208 --> 00:42:24.011 align:start position:34% line:-2
両方持った
接続があるとします

00:42:24.878 --> 00:42:30.117 align:start position:23% line:-2
この場合はipMetadata
オブジェクトを作成できます

00:42:30.517 --> 00:42:36.356 align:start position:23% line:-2
今回はサービスクラスをマークし
コンテキストを添付して送信

00:42:36.457 --> 00:42:39.827 align:start position:29% line:-2
これでパケットごとに
優先順位をマークできます

00:42:43.063 --> 00:42:45.399 align:start position:36% line:-2
接続を最適化する
別の方法は

00:42:45.833 --> 00:42:49.570 align:start position:38% line:-2
往復する回数を
減らすことです

00:42:50.104 --> 00:42:52.573 align:start position:30% line:-1
２つの方法を紹介します

00:42:53.073 --> 00:42:56.477 align:start position:27% line:-2
１つ目はファストオープンを
有効にすることです

00:42:56.643 --> 00:43:04.618 align:start position:7% line:-2
TCP Fast OpenはSYNパケットの中に
初期データを送信してくれます

00:42:56.643 --> 00:43:04.618 align:start position:7% line:-2
TCP Fast OpenはSYNパケットの中に
初期データを送信してくれます

00:43:04.718 --> 00:43:09.123 align:start position:27% line:-2
そのため ハンドシェイクを
待つ必要がありません

00:43:10.357 --> 00:43:14.661 align:start position:27% line:-2
まずはアプリケーションから
接続に対し

00:43:14.761 --> 00:43:20.033 align:start position:27% line:-2
初期データを提供することを
取り決めておきます

00:43:20.601 --> 00:43:24.605 align:start position:23% line:-2
そのために ファストオープンの
許可をマークし

00:43:24.872 --> 00:43:26.740 align:start position:36% line:-1
接続を作成します

00:43:27.307 --> 00:43:34.014 align:start position:23% line:-2
するとstartを呼び出す前に
初期データを送受信できます

00:43:35.315 --> 00:43:41.555 align:start position:20% line:-2
データはIdempotentという
マーカーに置き換えられました

00:43:41.655 --> 00:43:47.661 align:start position:14% line:-2
Idempotentはデータを再送しても
安全であることを意味します

00:43:47.761 --> 00:43:50.898 align:start position:27% line:-2
初期データが再送されるため
影響がないのです

00:43:52.966 --> 00:43:59.006 align:start position:18% line:-2
startを呼び出して接続を立ち上げ
初期データを使って

00:43:59.106 --> 00:44:03.811 align:start position:23% line:-2
TCP Fast Open内に
送信できるか試します

00:43:59.106 --> 00:44:03.811 align:start position:23% line:-2
TCP Fast Open内に
送信できるか試します

00:44:05.145 --> 00:44:08.949 align:start position:14% line:-2
TCP Fast Openを使った方法を
もう１つ紹介します

00:44:09.049 --> 00:44:12.653 align:start position:23% line:-2
アプリケーションで
データを送る必要のない方法です

00:44:14.621 --> 00:44:17.558 align:start position:21% line:-1
TCPに加えてTLSを使う場合は

00:44:17.891 --> 00:44:21.061 align:start position:27% line:-2
TLSの最初のメッセージは
ClientHelloです

00:44:21.161 --> 00:44:25.299 align:start position:23% line:-2
これはTCPの初期データとして
使えます

00:44:25.833 --> 00:44:30.237 align:start position:20% line:-2
ご自身のFast Openデータを
提供したくない場合は

00:44:30.971 --> 00:44:36.710 align:start position:21% line:-2
TCPの詳細なオプションから
Fast Openを有効にします

00:44:37.010 --> 00:44:43.317 align:start position:20% line:-2
すると 自動的にTLSから取り込み
接続の確立中に送信します

00:44:47.021 --> 00:44:51.725 align:start position:27% line:-2
データの往復を
節約するものがまだあります

00:44:51.825 --> 00:44:55.429 align:start position:29% line:-2
スチュアートが
前のセッションで話した―

00:44:55.596 --> 00:44:58.298 align:start position:21% line:-1
Optimistic DNSです

00:44:58.599 --> 00:45:05.239 align:start position:23% line:-2
これは短い間しか存続せずに
失効したDNSの応答が使えます

00:44:58.599 --> 00:45:05.239 align:start position:23% line:-2
これは短い間しか存続せずに
失効したDNSの応答が使えます

00:45:06.440 --> 00:45:12.813 align:start position:25% line:-2
さらに新規DNSクエリを行い
それらとの接続を試みます

00:45:13.580 --> 00:45:20.521 align:start position:25% line:-2
もし 以前に受信して失効した
アドレスがまだ通用するなら

00:45:20.988 --> 00:45:24.491 align:start position:29% line:-2
そのDNSのビヘイビアが
許可されます

00:45:24.591 --> 00:45:27.895 align:start position:30% line:-2
まずこれらのアドレスと
接続を試みます

00:45:27.995 --> 00:45:31.298 align:start position:29% line:-2
これで新規DNSクエリの
終わりを待つことなく

00:45:31.398 --> 00:45:35.269 align:start position:34% line:-2
設定時間を
大幅に削減できます

00:45:35.736 --> 00:45:42.509 align:start position:21% line:-2
しかし アドレスが変わった場合は
複数の異なる接続を試すため

00:45:42.876 --> 00:45:48.315 align:start position:20% line:-2
接続が反応しなければ
新規DNSクエリが戻るのを待ちます

00:45:48.415 --> 00:45:50.784 align:start position:30% line:-2
そして そのアドレスを
試します

00:45:51.385 --> 00:45:55.923 align:start position:27% line:-2
サーバの設定に適していれば
単純な方法です

00:45:56.056 --> 00:45:58.926 align:start position:32% line:-1
早く接続が確立します

00:46:02.029 --> 00:46:03.764 align:start position:36% line:-1
次に話す分野では

00:46:03.864 --> 00:46:07.968 align:start position:21% line:-2
アプリケーション内で
あなたは何もする必要がありません

00:46:08.068 --> 00:46:14.808 align:start position:12% line:-2
それはURLセッションや
Network.framworkが無料の―

00:46:15.242 --> 00:46:17.311 align:start position:23% line:-1
ユーザ空間ネットワーキングです

00:46:17.611 --> 00:46:21.749 align:start position:23% line:-1
昨年 WWDCで発表したもので

00:46:22.149 --> 00:46:26.120 align:start position:23% line:-1
iOSとtvOSで使用できます

00:46:26.220 --> 00:46:31.992 align:start position:29% line:-2
これはソケットレイヤーを
完全に回避する場所です

00:46:32.426 --> 00:46:38.865 align:start position:25% line:-2
スタックの従来のモデルが
何かという話から始めましょう

00:46:40.067 --> 00:46:42.736 align:start position:27% line:-2
ネットワークを通して
パケットを受け取るとします

00:46:42.836 --> 00:46:44.538 align:start position:21% line:-1
Wi-Fiのインターフェイスです

00:46:44.771 --> 00:46:51.578 align:start position:21% line:-2
パケットはドライバに入り
TCP 受信バッファに送られます

00:46:52.713 --> 00:46:55.949 align:start position:32% line:-2
アプリケーションが
パケットを読み取る時

00:46:56.116 --> 00:47:00.754 align:start position:32% line:-2
カーネルから
データをコピーします

00:46:56.116 --> 00:47:00.754 align:start position:32% line:-2
カーネルから
データをコピーします

00:47:01.355 --> 00:47:06.360 align:start position:30% line:-2
TLSの場合は
データを暗号化するため

00:47:06.460 --> 00:47:08.996 align:start position:29% line:-1
もう１つ別の転換をします

00:47:10.264 --> 00:47:13.600 align:start position:27% line:-2
では ユーザ空間
ネットワーキングの場合は？

00:47:16.170 --> 00:47:22.776 align:start position:16% line:-2
TCPとUDPがアプリケーションの方へ
移動しました

00:47:22.876 --> 00:47:24.445 align:start position:32% line:-1
どうなるでしょうか？

00:47:24.945 --> 00:47:29.183 align:start position:29% line:-2
パケットは先ほどと同様に
ドライバに入ります

00:47:29.283 --> 00:47:34.188 align:start position:21% line:-1
しかし それを自動的に集めるよう

00:47:34.288 --> 00:47:36.790 align:start position:29% line:-2
メモリマップされた領域に
移動しました

00:47:36.890 --> 00:47:42.596 align:start position:29% line:-2
そして パケットは
自動的に処理され始めます

00:47:42.696 --> 00:47:48.135 align:start position:27% line:-2
唯一の転換はTLSのための
データの復号化だけです

00:47:49.369 --> 00:47:54.842 align:start position:29% line:-2
これでパケットの送受信の
CPUの時間を減らせます

00:47:54.975 --> 00:47:57.444 align:start position:34% line:-2
特にUDPのような
プロトコルでは

00:47:57.544 --> 00:48:01.982 align:start position:21% line:-2
アプリケーションから
パケットの送信を繰り返すでしょう

00:47:57.544 --> 00:48:01.982 align:start position:21% line:-2
アプリケーションから
パケットの送信を繰り返すでしょう

00:48:03.116 --> 00:48:07.321 align:start position:23% line:-1
ではここでビデオをお見せします

00:48:07.688 --> 00:48:12.659 align:start position:30% line:-2
ここでもUDPの実演で
エリックがお見せした―

00:48:12.760 --> 00:48:16.096 align:start position:34% line:-2
アプリケーションが
使われています

00:48:17.931 --> 00:48:21.435 align:start position:38% line:-2
２つのビデオを
同時に流します

00:48:22.970 --> 00:48:27.174 align:start position:21% line:-2
左のデバイスはソケットで書かれた
アプリケーションから

00:48:27.574 --> 00:48:31.278 align:start position:34% line:-2
ビデオストリームを
受け取ります

00:48:32.079 --> 00:48:36.216 align:start position:16% line:-2
右のデバイスは
Network.frameworkで―

00:48:37.184 --> 00:48:41.688 align:start position:25% line:-2
書かれたアプリケーションから
同じものを受け取ります

00:48:41.789 --> 00:48:45.259 align:start position:27% line:-2
ユーザ空間ネットワーキング
スタックを活用しましょう

00:48:46.894 --> 00:48:52.766 align:start position:23% line:-2
今回は低フレームで非圧縮の
ビデオをストリーミングしますが

00:48:52.866 --> 00:48:54.902 align:start position:36% line:-2
大量のパケットが
行き来します

00:48:55.669 --> 00:48:58.238 align:start position:25% line:-1
実演のために選んだビデオです

00:48:58.572 --> 00:49:04.411 align:start position:27% line:-2
送信速度が十分でなくても
ビデオのクオリティは下げず

00:48:58.572 --> 00:49:04.411 align:start position:27% line:-2
送信速度が十分でなくても
ビデオのクオリティは下げず

00:49:04.511 --> 00:49:07.948 align:start position:29% line:-2
何かをドロップすることは
しません

00:49:08.115 --> 00:49:12.820 align:start position:30% line:-2
２つのスタックの間の
パフォーマンスの違いが

00:49:12.953 --> 00:49:15.689 align:start position:32% line:-1
よく分かると思います

00:49:16.023 --> 00:49:17.257 align:start position:38% line:-1
見てみましょう

00:49:21.795 --> 00:49:23.831 align:start position:34% line:-1
全く同じフレームが

00:49:24.365 --> 00:49:29.336 align:start position:32% line:-2
ネットワークを通り
最速で送られています

00:49:31.638 --> 00:49:35.542 align:start position:34% line:-2
右は簡単に
左を追い越しました

00:49:37.044 --> 00:49:43.350 align:start position:23% line:-2
右はレシーバー側だけで
30％少ないオーバーヘッドです

00:49:44.351 --> 00:49:49.757 align:start position:21% line:-2
左右を比べると UDPパケットを
送受信するのに必要な―

00:49:49.857 --> 00:49:54.828 align:start position:30% line:-2
CPUの割合に
大きな違いがあるのです

00:49:55.062 --> 00:50:01.335 align:start position:25% line:-2
全てのアプリケーションで
同じ結果になるとは言えません

00:49:55.062 --> 00:50:01.335 align:start position:25% line:-2
全てのアプリケーションで
同じ結果になるとは言えません

00:50:01.435 --> 00:50:04.571 align:start position:29% line:-2
皆さんはすでに
何かを使っているでしょう

00:50:05.072 --> 00:50:11.712 align:start position:29% line:-2
大量のパケットの送受信に
UDPをお使いであれば

00:50:11.845 --> 00:50:17.384 align:start position:18% line:-2
Network.frameworkを
試してください

00:50:17.518 --> 00:50:22.923 align:start position:30% line:-2
CPUの使用率の違いを
計測してほしいのです

00:50:23.023 --> 00:50:25.092 align:start position:29% line:-1
満足してもらえるでしょう

00:50:30.564 --> 00:50:36.570 align:start position:25% line:-2
最後はネットワークの可動性に
関する問題の解決についてです

00:50:36.803 --> 00:50:41.909 align:start position:12% line:-2
これはNetwork.frameworkで
解決する重要な領域です

00:50:42.643 --> 00:50:48.082 align:start position:27% line:-2
まず接続が円滑に
スタートするかを確かめます

00:50:48.682 --> 00:50:51.251 align:start position:29% line:-1
もう一度 説明しましょう

00:50:51.719 --> 00:50:54.721 align:start position:32% line:-1
waiting状態は

00:50:54.822 --> 00:50:59.493 align:start position:29% line:-2
ネットワークの切り替えを
処理するために重要です

00:50:59.593 --> 00:51:01.962 align:start position:29% line:-1
接続性が不十分であったり

00:50:59.593 --> 00:51:01.962 align:start position:29% line:-1
接続性が不十分であったり

00:51:02.062 --> 00:51:06.633 align:start position:23% line:-2
DNSやTCPの最中に接続性が
変わったことを示します

00:51:07.501 --> 00:51:12.172 align:start position:32% line:-2
接続が確立する前に
ネットワークの状態を

00:51:12.272 --> 00:51:15.776 align:start position:30% line:-2
確認するようなAPIは
避けてください

00:51:16.176 --> 00:51:22.349 align:start position:25% line:-2
接続を急かし 正確な状態を
把握できない可能性があります

00:51:23.884 --> 00:51:28.822 align:start position:27% line:-2
モバイルデータ通信の接続を
確認する必要があっても

00:51:29.256 --> 00:51:35.028 align:start position:25% line:-2
接続が変わる可能性があるため
確認しないでください

00:51:35.362 --> 00:51:40.334 align:start position:20% line:-2
単にNWParameterを使って
インターフェイスを制限しましょう

00:51:41.335 --> 00:51:47.274 align:start position:23% line:-2
そして ready状態に入ると
ネットワークが切り替わった時

00:51:47.374 --> 00:51:50.277 align:start position:29% line:-1
一連のイベントがあります

00:51:51.545 --> 00:51:54.548 align:start position:29% line:-2
最初のイベントは
“接続の実行可能性”です

00:51:55.449 --> 00:52:00.754 align:start position:23% line:-2
これは接続が有効なルートを持つ
インターフェイスから

00:51:55.449 --> 00:52:00.754 align:start position:23% line:-2
これは接続が有効なルートを持つ
インターフェイスから

00:52:01.355 --> 00:52:03.857 align:start position:27% line:-1
送受信できることを示します

00:52:05.192 --> 00:52:07.361 align:start position:32% line:-1
それを実演するために

00:52:07.494 --> 00:52:12.499 align:start position:29% line:-2
Wi-Fiネットワークで
接続を開始したとします

00:52:13.667 --> 00:52:18.839 align:start position:23% line:-2
その後 ユーザがエレベーターで
電波を失った場合は

00:52:19.206 --> 00:52:25.279 align:start position:23% line:-2
接続が実行可能でないことを
知らせるイベントを生じさせます

00:52:25.846 --> 00:52:27.714 align:start position:32% line:-1
何をすべきでしょう？

00:52:29.016 --> 00:52:29.983 align:start position:39% line:-1
２つあります

00:52:30.350 --> 00:52:36.056 align:start position:25% line:-2
１つ目はユーザに接続を
失っていると通知することです

00:52:36.190 --> 00:52:40.027 align:start position:27% line:-2
未接続中は
データの送受信に失敗します

00:52:41.061 --> 00:52:44.064 align:start position:32% line:-2
しかし 接続を
切る必要はありません

00:52:44.698 --> 00:52:51.572 align:start position:20% line:-2
最初のWi-Fiインターフェイスが
戻ってくるかもしれません

00:52:51.839 --> 00:52:58.278 align:start position:20% line:-2
エレベーターから降りて
同じWi-Fiに戻れば再開できます

00:53:00.514 --> 00:53:04.551 align:start position:23% line:-2
２つ目は
より良いパスを知らせることです

00:53:05.819 --> 00:53:09.890 align:start position:29% line:-2
Wi-Fiネットワークと
接続中に

00:53:10.691 --> 00:53:17.097 align:start position:18% line:-2
建物を出るとWi-Fiは使えませんが
モバイルデータ通信は使えます

00:53:17.397 --> 00:53:19.566 align:start position:23% line:-1
２つのことを教えてくれるのです

00:53:19.967 --> 00:53:23.504 align:start position:27% line:-1
接続が実行可能でないことと

00:53:23.604 --> 00:53:27.307 align:start position:30% line:-2
より良いパスが
利用可能であることです

00:53:27.407 --> 00:53:31.311 align:start position:23% line:-2
この場合は
モバイルデータ通信が使えますね

00:53:32.413 --> 00:53:33.781 align:start position:36% line:-1
助言しておきます

00:53:34.515 --> 00:53:39.620 align:start position:27% line:-2
接続可能な新規接続があれば
そちらに乗り換え

00:53:39.720 --> 00:53:42.323 align:start position:36% line:-2
再開できるか
確認してください

00:53:43.991 --> 00:53:48.529 align:start position:29% line:-2
新規接続が準備できてから
元の接続を閉じます

00:53:48.629 --> 00:53:51.031 align:start position:29% line:-2
Wi-Fiネットワークが
回復するかもしれませんし

00:53:51.531 --> 00:53:54.501 align:start position:25% line:-2
モバイルデータ通信が
失敗するかもしれないからです

00:53:56.470 --> 00:53:58.238 align:start position:30% line:-1
では 最後のケースです

00:53:59.039 --> 00:54:02.376 align:start position:25% line:-1
モバイルデータ通信と接続中に

00:53:59.039 --> 00:54:02.376 align:start position:25% line:-1
モバイルデータ通信と接続中に

00:54:02.476 --> 00:54:06.580 align:start position:21% line:-2
建物に入り
Wi-Fiアクセスがある場合です

00:54:07.014 --> 00:54:11.285 align:start position:32% line:-2
モバイルデータ通信に
問題はありませんが

00:54:11.385 --> 00:54:14.021 align:start position:27% line:-1
より良いパスが利用可能です

00:54:15.656 --> 00:54:18.692 align:start position:25% line:-1
ここで接続を乗り換えるために

00:54:18.792 --> 00:54:24.198 align:start position:27% line:-2
新規接続の確立を試し
データを移すこともできます

00:54:24.498 --> 00:54:26.667 align:start position:34% line:-2
これはデータ料金の
節約になります

00:54:28.435 --> 00:54:33.607 align:start position:20% line:-2
しかし Wi-Fiに接続するまでは
元の接続を続けてください

00:54:34.341 --> 00:54:38.712 align:start position:30% line:-2
コードではどう見えるか
お見せしましょう

00:54:38.812 --> 00:54:43.384 align:start position:12% line:-2
これはBooleanを返す
viabilityUpdateハンドラです

00:54:43.984 --> 00:54:50.657 align:start position:16% line:-2
より良いパスを知らせるbetter
PathUpdateハンドラもあります

00:54:53.427 --> 00:55:00.033 align:start position:27% line:-2
ネットワークの可動性を
どう扱うかに対する解決策は

00:54:53.427 --> 00:55:00.033 align:start position:27% line:-2
ネットワークの可動性を
どう扱うかに対する解決策は

00:55:00.134 --> 00:55:03.704 align:start position:18% line:-2
マルチパスコネクションの
Multipath TCPにあります

00:55:04.104 --> 00:55:08.142 align:start position:9% line:-2
まずはパラメータに
multipathServiceTypeと打ち

00:55:08.642 --> 00:55:14.081 align:start position:16% line:-2
クライアント上で
Multipath TCPを起動します

00:55:14.281 --> 00:55:18.886 align:start position:23% line:-2
すると接続は自動的に
ネットワーク間を行き来できます

00:55:18.986 --> 00:55:24.024 align:start position:25% line:-2
アプリケーション内での作業は
何も必要ありません

00:55:24.858 --> 00:55:29.029 align:start position:27% line:-2
これはURLセッションでも
利用可能です

00:55:30.731 --> 00:55:35.002 align:start position:18% line:-2
Network.frameworkで
注目したいことがあります

00:55:35.569 --> 00:55:40.541 align:start position:23% line:-2
それはインターフェイスタイプを
制限すると

00:55:40.641 --> 00:55:42.743 align:start position:25% line:-2
Multipath TCPが
適用されることです

00:55:42.843 --> 00:55:47.548 align:start position:21% line:-2
つまり マルチパスコネクションで
モバイルデータ通信を避けたい時は

00:55:47.814 --> 00:55:52.653 align:start position:25% line:-2
別のWi-Fiネットワークへ
切り替えるのです

00:55:54.688 --> 00:55:58.325 align:start position:18% line:-1
そして Multipath TCPは

00:55:58.425 --> 00:56:00.627 align:start position:16% line:-2
ConnectionViability
ハンドラとは異なります

00:55:58.425 --> 00:56:00.627 align:start position:16% line:-2
ConnectionViability
ハンドラとは異なります

00:56:00.994 --> 00:56:04.431 align:start position:21% line:-2
こちらはネットワークが変わる度に
自動的に切り替え

00:56:04.798 --> 00:56:09.570 align:start position:27% line:-2
ネットワークがない時は
接続が実行できなくなります

00:56:13.273 --> 00:56:16.944 align:start position:32% line:-2
接続性や実行可能性
MPTCPを待つ間に

00:56:17.711 --> 00:56:20.881 align:start position:30% line:-1
期待することがあります

00:56:20.981 --> 00:56:24.985 align:start position:7% line:-2
ネットワークを手動で確認する
SCNetworkReachabilityなどは

00:56:25.085 --> 00:56:31.291 align:start position:29% line:-2
自動で確認できるツールに
置き換えてほしいのです

00:56:31.491 --> 00:56:35.062 align:start position:32% line:-2
しかし 利用可能な
ネットワークの種類や

00:56:35.229 --> 00:56:39.733 align:start position:27% line:-2
切り替えについて
知りたい場合もあるでしょう

00:56:40.667 --> 00:56:46.640 align:start position:14% line:-2
そこで NWPathMonitorという
新しいAPIが利用可能です

00:56:47.674 --> 00:56:54.248 align:start position:25% line:-2
NWPathMonitorは
インターフェイスの状態や

00:56:54.348 --> 00:57:00.020 align:start position:30% line:-2
切り替わるタイミングを
知らせてくれます

00:56:54.348 --> 00:57:00.020 align:start position:30% line:-2
切り替わるタイミングを
知らせてくれます

00:57:01.021 --> 00:57:05.659 align:start position:27% line:-2
インターフェイスそれぞれに
接続を作りたい場合は

00:57:05.759 --> 00:57:08.262 align:start position:32% line:-2
インターフェイスの
繰り返しを許可します

00:57:09.129 --> 00:57:12.499 align:start position:25% line:-2
ネットワークが切り替わる度に
通知するので

00:57:13.200 --> 00:57:19.073 align:start position:30% line:-2
接続したことをユーザに
知らせたい時に便利です

00:57:19.873 --> 00:57:26.613 align:start position:21% line:-2
長いフォームに何かを書き込んだり
多くの操作を実行した後で

00:57:26.713 --> 00:57:32.085 align:start position:23% line:-2
結局は接続がないと気付く事態は
避けたいでしょう

00:57:32.886 --> 00:57:39.626 align:start position:7% line:-2
すぐに次の接続を試したい場合は
NetworkPathMonitorがお勧めです

00:57:39.860 --> 00:57:43.230 align:start position:32% line:-1
かつてないほど円滑に

00:57:43.330 --> 00:57:48.635 align:start position:25% line:-2
ネットワークの切り替えを行う
様子を見ていただきたいです

00:57:50.771 --> 00:57:52.339 align:start position:34% line:-1
それではジョシュが

00:57:52.439 --> 00:57:56.677 align:start position:18% line:-2
Network.frameworkの
導入方法を紹介します

00:57:57.411 --> 00:58:02.416 align:start position:43% line:-1
(拍手)

00:57:57.411 --> 00:58:02.416 align:start position:43% line:-1
(拍手)

00:58:02.516 --> 00:58:03.417 align:start position:45% line:-1
どうも

00:58:03.784 --> 00:58:07.621 align:start position:32% line:-2
新しいAPIを皆様も
気に入ると思います

00:58:08.222 --> 00:58:11.024 align:start position:18% line:-2
Network.frameworkの
導入について

00:58:11.125 --> 00:58:14.528 align:start position:30% line:-2
まずは
禁止事項をお伝えします

00:58:14.628 --> 00:58:18.599 align:start position:30% line:-2
新しい技術を
最大限に生かすためです

00:58:19.733 --> 00:58:25.906 align:start position:4% line:-2
あなたがmacOSをお使いで
Network Kernel Extension内で

00:58:26.006 --> 00:58:29.943 align:start position:30% line:-2
不可能なことがあれば
我々は代替を提供します

00:58:30.043 --> 00:58:34.081 align:start position:25% line:-2
ユーザ空間ネットワーキングと
互換性がないものだからです

00:58:35.282 --> 00:58:37.718 align:start position:29% line:-2
URLセッションについて
注意喚起をします

00:58:38.519 --> 00:58:43.457 align:start position:14% line:-2
プロキシ自動設定について
FTPとFile URLはサポートされず

00:58:43.557 --> 00:58:48.295 align:start position:27% line:-2
HTTPとHTTPSだけが
サポートされるでしょう

00:58:49.463 --> 00:58:55.402 align:start position:14% line:-2
CoreFoundationレイヤーには
避けてほしいAPIが多くあり

00:58:55.502 --> 00:58:57.838 align:start position:29% line:-1
いずれ廃止されるでしょう

00:58:57.938 --> 00:59:01.008 align:start position:30% line:-1
さらにCFソケットや―

00:58:57.938 --> 00:59:01.008 align:start position:30% line:-1
さらにCFソケットや―

00:59:01.108 --> 00:59:04.111 align:start position:9% line:-2
CFStreamCreatePairWithも
避けていただきたいです

00:59:04.645 --> 00:59:10.317 align:start position:25% line:-2
これらは接続の確立や
ユーザ空間ネットワーキングを

00:59:10.651 --> 00:59:12.786 align:start position:32% line:-1
うまく活用できません

00:59:12.886 --> 00:59:18.225 align:start position:11% line:-2
しかし Network.frameworkと
URLセッションなら

00:59:18.325 --> 00:59:23.096 align:start position:29% line:-2
接続性とパフォーマンスを
向上させられます

00:59:24.331 --> 00:59:27.334 align:start position:16% line:-2
他にも避けてほしい
Foundation APIがあります

00:59:27.768 --> 00:59:33.240 align:start position:12% line:-2
NSStream NSNetService
NSSocketのいずれかを使用するより

00:59:33.340 --> 00:59:36.877 align:start position:20% line:-2
Network.framworkか
URLセッションへ移行してください

00:59:37.578 --> 00:59:39.947 align:start position:9% line:-1
SCNetworkReachabilityでは

00:59:40.480 --> 00:59:43.417 align:start position:11% line:-2
WaitforConnectivityの方が
良いモデルです

00:59:43.517 --> 00:59:45.752 align:start position:32% line:-1
こちらをお勧めします

00:59:46.053 --> 00:59:50.357 align:start position:5% line:-2
そして WaitforConnectivityより
良い解決策が

00:59:50.457 --> 00:59:52.426 align:start position:23% line:-1
NWPathMoniterです

00:59:53.360 --> 00:59:57.798 align:start position:30% line:-2
次は使ってほしいものに
焦点を当てます

00:59:58.632 --> 01:00:04.538 align:start position:16% line:-2
推奨するAPIはURLセッションと
Network.frameworkです

00:59:58.632 --> 01:00:04.538 align:start position:16% line:-2
推奨するAPIはURLセッションと
Network.frameworkです

01:00:04.638 --> 01:00:07.574 align:start position:29% line:-2
URLセッションの焦点は
HTTPですが

01:00:07.674 --> 01:00:13.013 align:start position:11% line:-2
Stream TaskはTCPやTLS接続へ
シンプルなアクセスを提供します

01:00:13.814 --> 01:00:15.582 align:start position:11% line:-1
さらに Network.frameworkは

01:00:15.682 --> 01:00:20.954 align:start position:20% line:-2
TCP TLS UDP DTLSを
サポートしています

01:00:21.054 --> 01:00:24.725 align:start position:25% line:-2
インバウンドとアウトバウンド
接続のリッスンを操作し

01:00:24.825 --> 01:00:27.928 align:start position:20% line:-2
可動性を操作する
Path Monitorもあります

01:00:29.496 --> 01:00:34.835 align:start position:9% line:-2
ぜひNetwork.frameworkを導入し
これらを体験してください

01:00:35.002 --> 01:00:37.938 align:start position:32% line:-2
皆さんの顧客は
向上した接続に満足し

01:00:38.138 --> 01:00:43.477 align:start position:25% line:-2
バッテリーが長持ちすることを
喜ぶでしょう

01:00:45.079 --> 01:00:51.785 align:start position:27% line:-2
送受信のパフォーマンスを
最適化する操作方法に注目し

01:00:52.052 --> 01:00:57.291 align:start position:29% line:-2
実行可能性やルート変更の
サポートを受けてください

01:00:57.391 --> 01:01:01.261 align:start position:29% line:-2
違いを
感じていただけるでしょう

01:00:57.391 --> 01:01:01.261 align:start position:29% line:-2
違いを
感じていただけるでしょう

01:01:02.830 --> 01:01:07.334 align:start position:18% line:-2
Network.frameworkが
まだサポートしていない

01:01:07.434 --> 01:01:11.538 align:start position:12% line:-2
UDP Multicastのユースケースが
あればお知らせください

01:01:12.606 --> 01:01:16.910 align:start position:29% line:-2
質問やリクエストがあれば
歓迎します

01:01:17.010 --> 01:01:19.613 align:start position:32% line:-1
サポートへ連絡するか

01:01:19.713 --> 01:01:24.585 align:start position:25% line:-2
午後２時からと明朝９時からの
ラボでお聞きします

01:01:25.853 --> 01:01:27.854 align:start position:34% line:-1
URLはこちらです

01:01:28.956 --> 01:01:31.759 align:start position:30% line:-1
ラボは昼食後と明朝です

01:01:31.859 --> 01:01:34.194 align:start position:30% line:-1
ありがとうございました

01:01:34.294 --> 01:01:36.997 align:start position:43% line:-1
(拍手)
