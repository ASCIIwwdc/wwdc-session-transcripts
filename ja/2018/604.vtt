WEBVTT

00:00:07.040 --> 00:00:16.650 align:start position:43% line:-1
（音楽）

00:00:20.487 --> 00:00:27.961 align:start position:43% line:-1
（拍手）

00:00:28.061 --> 00:00:29.096 align:start position:32% line:-1
ありがとうございます

00:00:29.196 --> 00:00:33.267 align:start position:23% line:-2
Metalエコシステムチームの
ダン･オマーチです

00:00:33.500 --> 00:00:36.970 align:start position:29% line:-2
Metalで最高の体験を
していただけるよう―

00:00:37.070 --> 00:00:39.006 align:start position:27% line:-1
デベロッパを支援しています

00:00:39.406 --> 00:00:42.276 align:start position:27% line:-1
AppleのOpenGLや

00:00:42.376 --> 00:00:44.945 align:start position:32% line:-2
OpenGL ESに
長年携わってきました

00:00:45.045 --> 00:00:46.413 align:start position:30% line:-1
Apple入社以前から

00:00:46.513 --> 00:00:49.316 align:start position:32% line:-2
OpenGLの開発に
関わっています

00:00:50.817 --> 00:00:54.621 align:start position:30% line:-2
これまでOpenGLで
成し遂げたことを

00:00:54.721 --> 00:00:57.024 align:start position:34% line:-1
誇りに思っています

00:00:57.457 --> 00:01:01.895 align:start position:30% line:-2
またMetalの新たな
方向性にわくわくします

00:00:57.457 --> 00:01:01.895 align:start position:30% line:-2
またMetalの新たな
方向性にわくわくします

00:01:03.096 --> 00:01:07.267 align:start position:29% line:-2
本日は同僚の
スカーニャ･スドゥーグと

00:01:07.367 --> 00:01:09.136 align:start position:25% line:-1
Metalを簡潔に紹介します

00:01:09.236 --> 00:01:11.939 align:start position:23% line:-2
OpenGLアプリケーションを
簡単に移植できるよう―

00:01:12.039 --> 00:01:14.107 align:start position:30% line:-1
ガイダンスを提供します

00:01:15.209 --> 00:01:17.911 align:start position:34% line:-1
今年は特に重要です

00:01:18.011 --> 00:01:21.615 align:start position:12% line:-2
“State of the Union”で
発表したとおり

00:01:21.715 --> 00:01:25.819 align:start position:7% line:-2
OpenGL OpenGL ES OpenCLは
非推奨化されます

00:01:26.153 --> 00:01:30.424 align:start position:29% line:-2
現行および近々発表される
アプリケーションは当面―

00:01:30.524 --> 00:01:34.394 align:start position:30% line:-2
OpenGL ESを
tvOSやiOS12で

00:01:34.494 --> 00:01:38.131 align:start position:20% line:-1
そしてOpenGLとOpenCLは

00:01:38.232 --> 00:01:41.502 align:start position:16% line:-2
macOS 10.14 Mojaveで
使えます

00:01:42.002 --> 00:01:46.173 align:start position:23% line:-2
ただ新規の
アプリケーションはMetalを

00:01:46.807 --> 00:01:50.744 align:start position:32% line:-1
前提にすべきでしょう

00:01:50.844 --> 00:01:54.515 align:start position:25% line:-2
Metalに馴染みがなければ
そろそろ準備しましょう

00:01:55.649 --> 00:01:58.785 align:start position:21% line:-2
OpenGLコードをMetalに
移植する前に

00:01:58.886 --> 00:02:00.721 align:start position:27% line:-1
いくつかの選択肢があります

00:01:58.886 --> 00:02:00.721 align:start position:27% line:-1
いくつかの選択肢があります

00:02:01.255 --> 00:02:05.192 align:start position:27% line:-2
Appleのレンダリング用
フレームワークは

00:02:05.292 --> 00:02:09.729 align:start position:27% line:-2
2D用SpriteKitや
3D用SceneKit

00:02:09.830 --> 00:02:12.399 align:start position:25% line:-2
エフェクト用
Core Imageなどです

00:02:13.333 --> 00:02:16.703 align:start position:27% line:-2
また大手サードパーティーの
ゲームエンジンに

00:02:16.803 --> 00:02:19.873 align:start position:23% line:-2
Metalが主要レンダラとして
既に使われていますが

00:02:20.607 --> 00:02:24.511 align:start position:30% line:-2
これらの方策はご希望と
異なるかもしれません

00:02:24.611 --> 00:02:29.216 align:start position:23% line:-2
本日は皆さんによるMetalの
活用について解説します

00:02:30.384 --> 00:02:32.319 align:start position:27% line:-1
ではMetalのデザインと

00:02:32.419 --> 00:02:34.421 align:start position:34% line:-2
基本コンセプトから
始めましょう

00:02:35.355 --> 00:02:39.626 align:start position:29% line:-2
25年前にデザインされた
OpenGLの中心には

00:02:39.726 --> 00:02:43.664 align:start position:29% line:-2
ハードウェア高速化3Dの
源流が反映されています

00:02:44.498 --> 00:02:47.267 align:start position:29% line:-2
新バージョンや
拡張によるアップデートは

00:02:47.367 --> 00:02:52.139 align:start position:29% line:-2
GPUの特性や性能技術を
浮き彫りにしました

00:02:52.606 --> 00:02:55.843 align:start position:29% line:-1
しかし基本のデザインには

00:02:55.943 --> 00:02:58.779 align:start position:29% line:-2
現在のハードウェアに
そぐわない部分があります

00:03:01.081 --> 00:03:04.017 align:start position:27% line:-2
完全な機能固定型だった
OpenGLパイプラインは

00:03:04.117 --> 00:03:08.288 align:start position:21% line:-2
現在プログラミング可能な
パイプラインをサポートしています

00:03:08.388 --> 00:03:11.725 align:start position:30% line:-2
しかし最新のGPUとは
なめらかに合致しません

00:03:12.860 --> 00:03:17.197 align:start position:27% line:-2
非同期処理はAPIの
中核的な特性ではありません

00:03:17.297 --> 00:03:19.867 align:start position:34% line:-2
GPU特性の大半は
見えない形で―

00:03:19.967 --> 00:03:22.970 align:start position:30% line:-2
アプリケーションと
並列的に機能しています

00:03:24.137 --> 00:03:26.773 align:start position:30% line:-1
25年前のマルチコアは

00:03:26.874 --> 00:03:29.343 align:start position:27% line:-2
高額なワークステーションや
サーバーにしか実装されず

00:03:29.443 --> 00:03:32.079 align:start position:34% line:-1
その効率的な設計も

00:03:32.179 --> 00:03:33.614 align:start position:30% line:-1
重要視されませんでした

00:03:34.848 --> 00:03:37.784 align:start position:21% line:-1
2014年 GPU用の新たな--

00:03:37.885 --> 00:03:41.121 align:start position:30% line:-2
インターフェイスが
必要なのは明らかでした

00:03:41.522 --> 00:03:45.826 align:start position:27% line:-2
GPUの力を存分に活用する
インターフェイスです

00:03:46.360 --> 00:03:50.864 align:start position:27% line:-2
まずGPUを妨げないよう
CPUを離す必要があります

00:03:51.965 --> 00:03:54.168 align:start position:29% line:-1
しかしアプリケーションは

00:03:54.268 --> 00:03:58.605 align:start position:30% line:-2
レンダリングに
CPUを全部使用します

00:03:59.706 --> 00:04:02.409 align:start position:30% line:-2
デベロッパが落とし穴に
落下するのを防ぐには

00:03:59.706 --> 00:04:02.409 align:start position:30% line:-2
デベロッパが落とし穴に
落下するのを防ぐには

00:04:02.509 --> 00:04:07.114 align:start position:30% line:-2
インターフェイスは
予測可能であるべきです

00:04:08.015 --> 00:04:10.684 align:start position:32% line:-2
すべてのコールは
明確な結果をもたらし

00:04:10.784 --> 00:04:14.254 align:start position:36% line:-2
隠れた動作は
少なくすべきです

00:04:15.189 --> 00:04:19.493 align:start position:36% line:-2
予測するには
リソースの配置と

00:04:19.593 --> 00:04:22.763 align:start position:29% line:-2
必要に応じた
同期の制御が求められます

00:04:24.431 --> 00:04:27.167 align:start position:29% line:-2
Appleはさらに要件を
加えました

00:04:27.734 --> 00:04:30.370 align:start position:36% line:-2
ローレベル制御と
理解度を踏まえ

00:04:30.571 --> 00:04:34.975 align:start position:29% line:-2
身近なインターフェイスを
目指しました

00:04:35.075 --> 00:04:37.611 align:start position:30% line:-1
より簡単に理解できれば

00:04:37.711 --> 00:04:40.981 align:start position:34% line:-2
より効果的に
使用できるからです

00:04:41.882 --> 00:04:47.254 align:start position:27% line:-2
Metalは最新のGPUに
適合するよう設計しました

00:04:47.688 --> 00:04:51.325 align:start position:32% line:-2
開発途中の
ハードウェアの性能を

00:04:51.425 --> 00:04:53.627 align:start position:27% line:-1
引き出すソフトが必要でした

00:04:53.727 --> 00:04:56.196 align:start position:25% line:-1
Appleが設計したGPUの

00:04:56.296 --> 00:04:58.232 align:start position:23% line:-1
A11 bionicもそうです

00:05:00.100 --> 00:05:01.935 align:start position:21% line:-1
OpenGLと比べMetalでは

00:05:02.035 --> 00:05:06.440 align:start position:30% line:-2
高価なオペレーションが
減少します

00:05:06.907 --> 00:05:10.410 align:start position:27% line:-2
APIステートは
オブジェクト作成時に移動し

00:05:10.511 --> 00:05:14.248 align:start position:32% line:-2
GPUコマンドとして
パッケージ化されます

00:05:15.549 --> 00:05:19.753 align:start position:27% line:-2
これによりレンダリングの際
コストが大幅に減ります

00:05:20.420 --> 00:05:24.958 align:start position:27% line:-2
シェーダにも最新のGPUが
反映されています

00:05:25.526 --> 00:05:30.297 align:start position:21% line:-2
APIのGPUコマンドへの変換は
より安価になるのです

00:05:31.031 --> 00:05:36.336 align:start position:30% line:-2
とはいえパイプラインが
異なるのではありません

00:05:36.737 --> 00:05:40.474 align:start position:27% line:-2
Metalはパイプラインの
各段階をまとめ

00:05:40.574 --> 00:05:42.676 align:start position:30% line:-1
処理が効率的になります

00:05:42.776 --> 00:05:45.846 align:start position:27% line:-1
パイプライン自体は同じです

00:05:46.947 --> 00:05:51.084 align:start position:30% line:-2
マルチスレッド処理の
明確なモデルもあります

00:05:51.318 --> 00:05:54.621 align:start position:27% line:-1
アプリケーションはGPUを

00:05:54.721 --> 00:05:56.790 align:start position:34% line:-2
異なるスレッドから
駆動させます

00:05:56.890 --> 00:06:00.327 align:start position:34% line:-2
しかし方法は明確で
制約はないです

00:05:56.890 --> 00:06:00.327 align:start position:34% line:-2
しかし方法は明確で
制約はないです

00:06:00.894 --> 00:06:05.098 align:start position:27% line:-2
テクスチャ バッファ
シェーダなどもスレッド間で

00:06:05.199 --> 00:06:08.302 align:start position:27% line:-1
安全に効率的に使用できます

00:06:08.402 --> 00:06:12.372 align:start position:27% line:-2
またMetalは無効状態を
回避するための

00:06:12.472 --> 00:06:15.876 align:start position:30% line:-2
高価な内部ロック構成を
必要としません

00:06:17.678 --> 00:06:23.016 align:start position:25% line:-2
処理モデルがソフトと
GPUの関係を反映しています

00:06:23.116 --> 00:06:26.019 align:start position:27% line:-1
OpenGLの隠れた動作は

00:06:26.119 --> 00:06:29.523 align:start position:23% line:-1
Metalでは明示的になります

00:06:30.791 --> 00:06:34.728 align:start position:25% line:-1
これによりGPU活用に関して

00:06:34.828 --> 00:06:36.363 align:start position:32% line:-1
懸命な判断が下せます

00:06:36.797 --> 00:06:40.901 align:start position:25% line:-2
アプリケーションとGPU間の
ソフトも減ります

00:06:41.068 --> 00:06:44.171 align:start position:25% line:-2
Metalコールを直接受ける
GPUドライバですが

00:06:44.271 --> 00:06:48.408 align:start position:25% line:-2
APIコールの
GPUコマンドへの変換処理も

00:06:48.509 --> 00:06:49.843 align:start position:34% line:-1
少ない方がよいです

00:06:51.011 --> 00:06:53.146 align:start position:38% line:-1
順に見ましょう

00:06:54.081 --> 00:06:57.651 align:start position:20% line:-1
GLコールはすべてOpenGLです

00:06:57.751 --> 00:07:00.254 align:start position:30% line:-1
コンテキストで実行され

00:06:57.751 --> 00:07:00.254 align:start position:30% line:-1
コンテキストで実行され

00:07:00.354 --> 00:07:04.258 align:start position:18% line:-2
APIステートの追跡や
OpenGLオブジェクトのメモリ管理

00:07:04.358 --> 00:07:07.094 align:start position:27% line:-2
GPUコマンドの変換などを
担います

00:07:07.194 --> 00:07:10.063 align:start position:27% line:-1
Metalはこれらをさらに

00:07:10.164 --> 00:07:12.733 align:start position:32% line:-2
小さなオブジェクトに
分けます

00:07:14.401 --> 00:07:17.771 align:start position:32% line:-2
最初のオブジェクトは
Metalデバイスで

00:07:17.938 --> 00:07:22.075 align:start position:32% line:-2
物理GPUの
抽象的表示となります

00:07:23.243 --> 00:07:26.780 align:start position:32% line:-2
テクスチャやバッファ
またシェーダを含む―

00:07:26.880 --> 00:07:30.284 align:start position:27% line:-2
パイプラインオブジェクトを
作成します

00:07:30.818 --> 00:07:35.022 align:start position:23% line:-2
Metalコマンドキューという
オブジェクトも作成されます

00:07:36.190 --> 00:07:38.792 align:start position:34% line:-2
コマンドキューは
コマンドバッファの

00:07:38.892 --> 00:07:41.495 align:start position:30% line:-1
シーケンスを作成します

00:07:41.795 --> 00:07:43.831 align:start position:32% line:-1
コマンドバッファとは

00:07:43.931 --> 00:07:47.601 align:start position:29% line:-2
GPUに送信される
GPUコマンドのリストで

00:07:47.734 --> 00:07:50.537 align:start position:30% line:-2
アプリケーションにより
満たされます

00:07:50.971 --> 00:07:53.473 align:start position:34% line:-2
アプリケーションは
フレームあたり

00:07:53.574 --> 00:07:57.377 align:start position:30% line:-2
これを1つ作成しますが
２つ以上作成した方が

00:07:57.477 --> 00:07:59.947 align:start position:29% line:-1
理にかなう場合もあります

00:08:00.814 --> 00:08:03.884 align:start position:29% line:-2
直接コマンドバッファに
コマンドを書くのではなく

00:08:03.984 --> 00:08:06.987 align:start position:23% line:-2
Metalコマンドエンコーダが
作成されます

00:08:07.721 --> 00:08:11.658 align:start position:27% line:-2
エンコーダはAPIコールを
GPU指示命令へと変換し

00:08:11.758 --> 00:08:13.727 align:start position:34% line:-2
コマンドバッファに
書き込みます

00:08:14.194 --> 00:08:16.497 align:start position:34% line:-2
エンコーディングが
終了すると

00:08:16.597 --> 00:08:19.833 align:start position:30% line:-2
アプリケーションは
オブジェクトを放ちます

00:08:20.667 --> 00:08:23.904 align:start position:30% line:-2
また新しいエンコーダが
作成されることによって

00:08:24.004 --> 00:08:27.241 align:start position:27% line:-2
さらに多くのコマンドの
エンコードが可能になります

00:08:30.644 --> 00:08:32.145 align:start position:41% line:-1
重要なのは

00:08:32.246 --> 00:08:36.750 align:start position:34% line:-2
これまでGPUは
働いていない点です

00:08:36.917 --> 00:08:39.720 align:start position:32% line:-2
オブジェクトも
コマンドエンコードも

00:08:39.820 --> 00:08:41.554 align:start position:25% line:-1
すべてCPUで作成しています

00:08:41.688 --> 00:08:44.725 align:start position:30% line:-1
エンコーディングなどが

00:08:45.025 --> 00:08:46.693 align:start position:38% line:-1
終了してから―

00:08:47.227 --> 00:08:51.198 align:start position:30% line:-2
GPUはコマンド処理を
開始するのです

00:08:52.933 --> 00:08:55.702 align:start position:34% line:-1
複数のバッファへの

00:08:55.802 --> 00:08:58.238 align:start position:29% line:-1
並列エンコードも可能です

00:09:00.674 --> 00:09:05.412 align:start position:27% line:-2
コマンドキューはバッファの
シーケンスを―

00:09:06.013 --> 00:09:09.716 align:start position:30% line:-2
コマンドバッファは
エンコーダを作成します

00:09:10.017 --> 00:09:14.888 align:start position:32% line:-2
書き込み用エンコーダ
オブジェクトは

00:09:15.522 --> 00:09:17.524 align:start position:30% line:-1
３つのタイプがあります

00:09:17.925 --> 00:09:19.426 align:start position:27% line:-1
レンダコマンドエンコーダは

00:09:19.526 --> 00:09:22.129 align:start position:38% line:-2
オブジェクトを
設定し束ね―

00:09:22.229 --> 00:09:25.833 align:start position:29% line:-1
ドローコールを発行します

00:09:26.433 --> 00:09:29.336 align:start position:29% line:-2
ブリットコマンド
エンコーダはテクスチャや

00:09:29.436 --> 00:09:31.338 align:start position:36% line:-2
バッファコピーの
動作を発行し

00:09:31.438 --> 00:09:35.609 align:start position:32% line:-2
テクスチャ用
ミップマップの生成や

00:09:35.709 --> 00:09:40.647 align:start position:25% line:-2
バッファからピクセルデータの
移動にも使えます

00:09:42.249 --> 00:09:45.252 align:start position:32% line:-2
コンピュートコマンド
エンコーダは

00:09:45.352 --> 00:09:48.322 align:start position:30% line:-2
コンピュートカーネルを
発送します

00:09:49.490 --> 00:09:52.926 align:start position:27% line:-2
レンダコマンドが一番身近な
エンコーダになるでしょう

00:09:53.026 --> 00:09:55.796 align:start position:30% line:-1
画像アプリケーションの

00:09:55.896 --> 00:09:58.499 align:start position:29% line:-1
大半の動作を担うからです

00:09:59.133 --> 00:10:01.668 align:start position:30% line:-2
ここにエンコードされた
コマンドは

00:09:59.133 --> 00:10:01.668 align:start position:30% line:-2
ここにエンコードされた
コマンドは

00:10:01.768 --> 00:10:04.638 align:start position:30% line:-1
レンダパスと称されます

00:10:05.239 --> 00:10:08.976 align:start position:32% line:-2
レンダオブジェクトを
セットアップしたり

00:10:09.076 --> 00:10:11.945 align:start position:29% line:-1
描画コマンドを発行します

00:10:12.045 --> 00:10:15.315 align:start position:20% line:-2
これにはglDrawArraysや
glDrawElementsなど

00:10:15.482 --> 00:10:19.987 align:start position:23% line:-2
他のOpenGL描画コマンドに
似た操作が含まれます

00:10:20.821 --> 00:10:22.289 align:start position:34% line:-1
各レンダコマンダは

00:10:22.389 --> 00:10:25.626 align:start position:29% line:-2
レンダターゲットセットと
強く結びついています

00:10:26.827 --> 00:10:30.597 align:start position:30% line:-2
レンダターゲットは
描画できるテクスチャで

00:10:30.697 --> 00:10:35.669 align:start position:27% line:-2
色 深度 ステンシル
テクスチャなどが含まれます

00:10:36.270 --> 00:10:39.673 align:start position:23% line:-2
レンダコマンド
エンコーダ作成時にバッファより

00:10:39.773 --> 00:10:41.475 align:start position:30% line:-1
ターゲットを指定します

00:10:42.342 --> 00:10:45.245 align:start position:30% line:-1
描画コマンドはこれらの

00:10:45.345 --> 00:10:47.481 align:start position:29% line:-1
ターゲットに向けられます

00:10:48.315 --> 00:10:52.886 align:start position:29% line:-2
新たなターゲットセットに
コマンドを向けるには

00:10:52.986 --> 00:10:56.623 align:start position:29% line:-2
現行エンコーダを終了し
新エンコーダを作成します

00:10:57.057 --> 00:10:59.827 align:start position:25% line:-2
これにより異なるターゲットに
向けられた

00:10:59.927 --> 00:11:03.997 align:start position:32% line:-2
コマンド間の線引きが
明確になります

00:10:59.927 --> 00:11:03.997 align:start position:32% line:-2
コマンド間の線引きが
明確になります

00:11:05.132 --> 00:11:08.635 align:start position:29% line:-2
レンダリングで使用される
オブジェクトをみましょう

00:11:09.236 --> 00:11:11.672 align:start position:20% line:-1
MetalにはOpenGLに似た―

00:11:11.772 --> 00:11:16.210 align:start position:18% line:-1
テクスチャ バッファ sampler

00:11:16.810 --> 00:11:18.145 align:start position:32% line:-2
パイプラインステート
オブジェクトなどの

00:11:18.245 --> 00:11:20.981 align:start position:30% line:-1
オブジェクトがあります

00:11:21.114 --> 00:11:24.885 align:start position:21% line:-2
またOpenGLにコンテナとして
存在している―

00:11:24.985 --> 00:11:29.756 align:start position:30% line:-2
深度ステンシルステート
オブジェクトもあります

00:11:31.325 --> 00:11:35.596 align:start position:16% line:-2
OpenGLとMetalオブジェクトの
最大の違いは

00:11:35.696 --> 00:11:38.298 align:start position:34% line:-2
作成過程と
管理方法にあります

00:11:38.999 --> 00:11:41.468 align:start position:25% line:-2
オブジェクトはすべて
デバイスオブジェクトから成り

00:11:41.568 --> 00:11:43.971 align:start position:25% line:-1
1つのGPUに関連しています

00:11:44.538 --> 00:11:47.241 align:start position:23% line:-1
オブジェクトステートは作成時に

00:11:47.341 --> 00:11:51.111 align:start position:23% line:-2
ディスクリプタ内のプロパティを
指定しながら設定します

00:11:51.745 --> 00:11:54.748 align:start position:32% line:-2
オブジェクト作成時の
ステートは固定され

00:11:54.848 --> 00:11:55.983 align:start position:38% line:-1
変更できません

00:11:56.783 --> 00:12:00.854 align:start position:30% line:-2
テクスチャとバッファは
固定されていますが

00:11:56.783 --> 00:12:00.854 align:start position:30% line:-2
テクスチャとバッファは
固定されていますが

00:12:00.954 --> 00:12:04.358 align:start position:30% line:-2
これらオブジェクト内の
データは変更できます

00:12:05.893 --> 00:12:08.195 align:start position:32% line:-2
Metalは
オブジェクト作成時に

00:12:08.295 --> 00:12:09.897 align:start position:32% line:-2
高価なセットアップを
すべて実行できます

00:12:10.230 --> 00:12:13.100 align:start position:23% line:-1
OpenGLは可変モデルなので

00:12:13.200 --> 00:12:16.169 align:start position:34% line:-2
アプリケーションが
ステートに触れると

00:12:16.670 --> 00:12:19.740 align:start position:27% line:-2
オブジェクト再コンパイルが
生じるかもしれません

00:12:19.840 --> 00:12:22.976 align:start position:27% line:-2
またOpenGLは描画前に
ステート確認のため

00:12:23.076 --> 00:12:27.748 align:start position:34% line:-2
フラグ階層の
チェックが必要です

00:12:27.948 --> 00:12:31.785 align:start position:30% line:-2
変更不可のMetalは
ステート変更を

00:12:31.885 --> 00:12:35.756 align:start position:25% line:-2
チェックする必要がなく
ドローコールが速くなるのです

00:12:37.391 --> 00:12:41.261 align:start position:27% line:-2
オブジェクトはスレッド間で
効率的に使用できます

00:12:41.361 --> 00:12:44.998 align:start position:27% line:-2
他のスレッド内の変更による
無効化を防ぐために

00:12:45.098 --> 00:12:47.034 align:start position:27% line:-2
オブジェクトを
ロックする必要もありません

00:12:51.138 --> 00:12:53.240 align:start position:32% line:-1
次は移植についてです

00:12:54.508 --> 00:12:58.212 align:start position:34% line:-2
レンダリング
アプリケーションの

00:12:58.312 --> 00:13:00.614 align:start position:32% line:-1
典型的なフェーズです

00:12:58.312 --> 00:13:00.614 align:start position:32% line:-1
典型的なフェーズです

00:13:00.881 --> 00:13:04.318 align:start position:29% line:-2
ソースをコンパイルし
アセットをバンドルします

00:13:04.518 --> 00:13:07.454 align:start position:32% line:-2
起動 初期化
アセットの読み込み―

00:13:07.554 --> 00:13:12.392 align:start position:27% line:-2
アプリケーションに恒常的な
オブジェクトの初期化―

00:13:13.060 --> 00:13:15.128 align:start position:25% line:-1
そしてレンダを繰り返しながら

00:13:15.229 --> 00:13:17.831 align:start position:27% line:-1
ステート設定やドローコール

00:13:17.931 --> 00:13:20.534 align:start position:27% line:-1
フレームを提示していきます

00:13:22.269 --> 00:13:24.071 align:start position:30% line:-1
まずはMetal向けの

00:13:24.171 --> 00:13:27.141 align:start position:32% line:-2
アプリケーション稼動
初期段階についてです

00:13:28.442 --> 00:13:32.579 align:start position:27% line:-2
シェーダのオフライン構築や
オブジェクト初期化の生成―

00:13:33.046 --> 00:13:37.017 align:start position:23% line:-2
さらにスカーニャがレンダリング
コード移植を解説します

00:13:38.452 --> 00:13:41.154 align:start position:34% line:-2
まずはシェーダが
コンパイルされる―

00:13:41.255 --> 00:13:44.358 align:start position:32% line:-2
アプリケーション
ビルドタイムからです

00:13:44.758 --> 00:13:47.394 align:start position:27% line:-1
まずシェーディング言語です

00:13:47.694 --> 00:13:50.664 align:start position:21% line:-1
MetalではC++に基づきます

00:13:50.764 --> 00:13:55.369 align:start position:29% line:-2
クラス テンプレート
ストラクチャ enumや

00:13:55.469 --> 00:13:57.805 align:start position:30% line:-2
名前空間の
定義づけなどができます

00:13:58.272 --> 00:14:02.109 align:start position:27% line:-2
組み込み型
ベクタ マトリクスタイプや

00:13:58.272 --> 00:14:02.109 align:start position:27% line:-2
組み込み型
ベクタ マトリクスタイプや

00:14:02.543 --> 00:14:06.813 align:start position:27% line:-2
グラフィックスに汎用される
機能や動作があります

00:14:07.681 --> 00:14:12.085 align:start position:25% line:-2
samplerやテクスチャを
特定するクラスもあります

00:14:12.786 --> 00:14:15.122 align:start position:34% line:-1
言語はこうなります

00:14:15.222 --> 00:14:18.258 align:start position:29% line:-2
頂点と
フラグメントシェーダです

00:14:19.159 --> 00:14:20.494 align:start position:34% line:-1
上部のキーワードが

00:14:20.594 --> 00:14:24.798 align:start position:29% line:-2
機能は頂点シェーダである
と提示し

00:14:24.898 --> 00:14:28.669 align:start position:27% line:-2
下部にはフラグメント機能の
キーワードがあります

00:14:29.536 --> 00:14:34.474 align:start position:23% line:-2
カスタム名が付与されている点に
ご注意ください

00:14:34.575 --> 00:14:38.946 align:start position:29% line:-2
多数のシェーダを作成し
その機能を識別するために

00:14:39.046 --> 00:14:41.849 align:start position:34% line:-1
名前を付けられます

00:14:42.883 --> 00:14:45.786 align:start position:32% line:-2
アプリケーションから
移されるものすべてが

00:14:45.886 --> 00:14:47.487 align:start position:27% line:-1
シェーダには引数となります

00:14:47.754 --> 00:14:51.692 align:start position:29% line:-2
GLSLのような機能外の
緩い変数はありません

00:14:52.259 --> 00:14:55.796 align:start position:27% line:-2
各パラメータの隣に
名称が括弧内に入っています

00:14:56.063 --> 00:14:58.031 align:start position:32% line:-1
これらは属性指定子で

00:14:58.131 --> 00:15:02.569 align:start position:27% line:-2
特別な変数を示し
C++から延長したものです

00:14:58.131 --> 00:15:02.569 align:start position:27% line:-2
特別な変数を示し
C++から延長したものです

00:15:03.237 --> 00:15:07.708 align:start position:23% line:-1
このVID属性は頂点処理の際―

00:15:07.808 --> 00:15:13.146 align:start position:27% line:-2
現行の頂点インデックスを
含ませることを示しています

00:15:13.814 --> 00:15:18.118 align:start position:30% line:-2
この２か所でも
頂点が配列されています

00:15:19.386 --> 00:15:22.389 align:start position:27% line:-2
バッファ属性指定子のついた
これらのパラメータは

00:15:22.489 --> 00:15:28.161 align:start position:25% line:-2
変数がMetalAPI内の
バッファオブジェクトによって

00:15:28.362 --> 00:15:31.965 align:start position:32% line:-2
満たされていることを
示しています

00:15:32.099 --> 00:15:35.502 align:start position:30% line:-2
まずここでの
使用タイプを見ましょう

00:15:35.903 --> 00:15:39.740 align:start position:34% line:-2
ご自身で定義する
カスタムタイプです

00:15:40.240 --> 00:15:44.178 align:start position:30% line:-2
この頂点パラメータは
頂点タイプのポインタで

00:15:44.311 --> 00:15:46.313 align:start position:32% line:-1
その定義はこちらです

00:15:46.513 --> 00:15:48.482 align:start position:39% line:-1
モデル位置と

00:15:48.582 --> 00:15:52.085 align:start position:29% line:-2
テクスチャ座標の
２つのメンバからなります

00:15:52.252 --> 00:15:56.223 align:start position:30% line:-2
頂点配列における配置や
メモリを定義し

00:15:56.323 --> 00:15:58.559 align:start position:29% line:-1
頂点シェーダへ移行します

00:15:59.626 --> 00:16:03.497 align:start position:27% line:-2
頂点シェーダから返送された
頂点出力タイプを見ましょう

00:15:59.626 --> 00:16:03.497 align:start position:27% line:-2
頂点シェーダから返送された
頂点出力タイプを見ましょう

00:16:04.798 --> 00:16:07.267 align:start position:30% line:-1
ラスタライズとその後の

00:16:07.367 --> 00:16:11.071 align:start position:27% line:-2
フラグメントプログラムに
流れるものを定義しています

00:16:13.073 --> 00:16:16.143 align:start position:30% line:-2
浮動小数点メンバである
clipPosの隣に

00:16:16.243 --> 00:16:19.012 align:start position:29% line:-1
座標属性指定子があります

00:16:19.112 --> 00:16:24.117 align:start position:29% line:-2
頂点シェーダの出力座標を
担うことを示しています

00:16:24.852 --> 00:16:28.288 align:start position:20% line:-1
属性指定子のないtexCoordは

00:16:28.388 --> 00:16:31.258 align:start position:27% line:-2
ラスタライズされた三角形を
定義する―

00:16:31.358 --> 00:16:34.661 align:start position:34% line:-2
他の頂点の
テクスチャ座標値で

00:16:34.761 --> 00:16:40.367 align:start position:32% line:-2
補間された変数が
デフォルトとなります

00:16:41.401 --> 00:16:44.438 align:start position:30% line:-2
フラグメントシェーダの
パラメータを見ましょう

00:16:44.938 --> 00:16:48.375 align:start position:20% line:-1
先ほどのvertexOutputは

00:16:48.609 --> 00:16:52.045 align:start position:29% line:-2
フラグメントシェーダへの
入力として使用します

00:16:52.146 --> 00:16:57.751 align:start position:27% line:-2
頂点シェーダで構築した―
補間されたテクスチャ座標を

00:16:58.318 --> 00:17:01.355 align:start position:23% line:-2
テクスチャからのサンプル操作に
使用しています

00:16:58.318 --> 00:17:01.355 align:start position:23% line:-2
テクスチャからのサンプル操作に
使用しています

00:17:02.890 --> 00:17:05.659 align:start position:27% line:-2
オブジェクトをシェーダ
パラメータへマップする場合

00:17:05.759 --> 00:17:10.597 align:start position:21% line:-2
レンダコマンドエンコーダを
アプリケーションコードに使います

00:17:13.066 --> 00:17:16.703 align:start position:25% line:-2
各コールのインデックス引数は
OpenGL属性や

00:17:16.803 --> 00:17:20.907 align:start position:23% line:-2
頂点属性インデックスや
テクスチャユニットに似ています

00:17:21.141 --> 00:17:26.246 align:start position:27% line:-2
シェーダパラメータに向かう
インデックスを特定します

00:17:26.780 --> 00:17:31.652 align:start position:25% line:-2
インデックス３でエンコーダを
コールした結果―

00:17:31.752 --> 00:17:34.721 align:start position:32% line:-2
ユニフォームバッファ
オブジェクトが

00:17:34.855 --> 00:17:39.459 align:start position:25% line:-2
シェーダのユニフォーム
パラメータへマップされました

00:17:40.794 --> 00:17:43.397 align:start position:18% line:-2
テクスチャや
samplerオブジェクトの設定でも

00:17:43.664 --> 00:17:45.299 align:start position:29% line:-1
同様のコールを作成します

00:17:50.204 --> 00:17:52.706 align:start position:29% line:-1
シェーダ開発に特に有用な

00:17:52.806 --> 00:17:55.442 align:start position:34% line:-2
ライブラリについて
お話します

00:17:57.411 --> 00:17:58.946 align:start position:39% line:-1
SIMDです

00:17:59.079 --> 00:18:02.082 align:start position:32% line:-2
Metalから離れた
ライブラリですが

00:17:59.079 --> 00:18:02.082 align:start position:32% line:-2
Metalから離れた
ライブラリですが

00:18:02.182 --> 00:18:05.485 align:start position:27% line:-2
多数の直交フレームワークで
使用されています

00:18:05.853 --> 00:18:08.121 align:start position:29% line:-2
しかしMetalを念頭に
作成されました

00:18:08.722 --> 00:18:11.058 align:start position:27% line:-2
SIMDはグラフィック
アルゴリズムの適用に使う―

00:18:11.158 --> 00:18:14.461 align:start position:32% line:-2
ベクタやマトリクスを
定義します

00:18:14.561 --> 00:18:17.231 align:start position:29% line:-1
３および４成分のベクタや

00:18:17.331 --> 00:18:20.467 align:start position:27% line:-2
３×３ ４×４マトリクスが
含まれます

00:18:23.504 --> 00:18:29.476 align:start position:29% line:-2
このライブラリを使って
アプリケーションコードと

00:18:30.077 --> 00:18:34.715 align:start position:27% line:-2
シェーディング言語コードを
共有できるのです

00:18:35.716 --> 00:18:40.654 align:start position:23% line:-2
これを使いアプリケーションから
シェーダへのデータの―

00:18:40.754 --> 00:18:43.824 align:start position:29% line:-1
レイアウトを定義できます

00:18:43.924 --> 00:18:45.192 align:start position:36% line:-1
こういうことです

00:18:45.826 --> 00:18:48.362 align:start position:32% line:-2
アプリケーションから
シェーダに流す―

00:18:48.462 --> 00:18:50.597 align:start position:27% line:-1
データ入り構造体を作ります

00:18:50.697 --> 00:18:53.600 align:start position:30% line:-1
モデルビュー射影行列と

00:18:53.700 --> 00:18:57.538 align:start position:27% line:-2
一次光源の位置を伝える場合
SIMDタイプを

00:18:57.638 --> 00:19:00.541 align:start position:30% line:-2
ストラクチャに
使用することができます

00:18:57.638 --> 00:19:00.541 align:start position:30% line:-2
ストラクチャに
使用することができます

00:19:01.742 --> 00:19:04.244 align:start position:29% line:-2
アプリケーションコードと
Metalファイルの

00:19:04.778 --> 00:19:08.749 align:start position:27% line:-2
両方にストラクチャの定義を
ヘッダー内に設定します

00:19:08.849 --> 00:19:11.852 align:start position:27% line:-2
同じタイプを使っているので
シェーダが使う―

00:19:11.985 --> 00:19:15.756 align:start position:34% line:-2
データレイアウトと
コードが合致します

00:19:16.490 --> 00:19:20.494 align:start position:23% line:-2
レイアウトの不一致によるバグが
ずっと少なくなります

00:19:23.730 --> 00:19:27.301 align:start position:29% line:-1
Metalが効果的なのは

00:19:27.401 --> 00:19:30.804 align:start position:30% line:-2
作業を速めに
少なく実行するからです

00:19:31.171 --> 00:19:34.341 align:start position:25% line:-2
Metalシェーダファイルの
コンパイルには

00:19:34.441 --> 00:19:36.243 align:start position:32% line:-1
Xcodeを使います

00:19:36.810 --> 00:19:38.912 align:start position:30% line:-2
これで前端コンパイルが
実行され

00:19:39.012 --> 00:19:43.684 align:start position:27% line:-2
構文解析 シェーダ解析や
基本的な最適化が行われます

00:19:43.784 --> 00:19:47.454 align:start position:27% line:-2
コードはバイナリ中間表示へ
変換され

00:19:47.554 --> 00:19:49.957 align:start position:30% line:-2
あらゆるハードウェアで
使用できます

00:19:50.224 --> 00:19:55.195 align:start position:20% line:-2
アプリケーションが動くまで
実際のGPUコードは作られませんが

00:19:55.295 --> 00:19:59.900 align:start position:27% line:-2
アプリケーションが動く際の
コンパイル時間が半減します

00:20:01.502 --> 00:20:04.671 align:start position:34% line:-2
作成された
中間表示バイナリは

00:20:04.771 --> 00:20:08.308 align:start position:23% line:-2
Metalライブラリファイルに
保存されます

00:20:08.442 --> 00:20:13.213 align:start position:20% line:-2
Xcodeは
Metalシェーダソースファイルを

00:20:13.313 --> 00:20:15.782 align:start position:25% line:-2
変換して
Metalライブラリに入れて

00:20:15.883 --> 00:20:17.784 align:start position:27% line:-1
アプリケーションに収めます

00:20:19.186 --> 00:20:21.622 align:start position:23% line:-2
シェーダは
Xcodeで作ることもできれば

00:20:21.722 --> 00:20:25.025 align:start position:27% line:-2
アプリケーション稼働中でも
構築できます

00:20:25.893 --> 00:20:29.329 align:start position:29% line:-2
文字列の連結や
コード生成系などによって

00:20:29.429 --> 00:20:31.899 align:start position:16% line:-2
シェーダを構築する
OpenGLアプリケーションがあります

00:20:32.432 --> 00:20:36.270 align:start position:32% line:-2
稼動時に全シェーダを
集めるのは大変です

00:20:36.637 --> 00:20:39.807 align:start position:30% line:-2
アプリケーションによる
編集が無理でも

00:20:39.907 --> 00:20:41.542 align:start position:21% line:-1
OpenGLと同様にMetalは

00:20:41.642 --> 00:20:46.280 align:start position:27% line:-2
稼動時ソースからシェーダを
編集することができます

00:20:47.614 --> 00:20:51.552 align:start position:27% line:-2
ただしユーザーシステムから
この作業を切り離すことで

00:20:51.652 --> 00:20:55.355 align:start position:27% line:-2
性能の倹約を
あきらめなければなりません

00:20:55.989 --> 00:20:58.192 align:start position:29% line:-1
編集エラーは見えないので

00:20:58.292 --> 00:21:01.395 align:start position:29% line:-2
アプリケーション実行まで
判明しません

00:20:58.292 --> 00:21:01.395 align:start position:29% line:-2
アプリケーション実行まで
判明しません

00:21:01.728 --> 00:21:05.799 align:start position:27% line:-2
また稼動時はヘッダを
シェーダに含められないので

00:21:05.899 --> 00:21:10.003 align:start position:21% line:-2
アプリケーションコードと
シェーダ間でタイプは共有不可です

00:21:11.405 --> 00:21:15.209 align:start position:32% line:-2
シェア型の稼動編集を
使用するのであれば

00:21:15.309 --> 00:21:20.314 align:start position:25% line:-2
Xcodeでのシェーダ構築に
時間をかけることを勧めます

00:21:20.414 --> 00:21:23.417 align:start position:32% line:-1
実効性能の倹約により

00:21:23.517 --> 00:21:26.520 align:start position:36% line:-2
開発上の利便性を
享受できます

00:21:27.621 --> 00:21:31.925 align:start position:29% line:-2
次はMetalレンダラの
初期化についてです

00:21:32.025 --> 00:21:34.495 align:start position:32% line:-2
オブジェクトの作成も
関係しています

00:21:34.595 --> 00:21:38.198 align:start position:30% line:-2
まずはデバイスや
コマンドキューについて

00:21:38.298 --> 00:21:43.837 align:start position:25% line:-2
次にアセットのための
オブジェクト作成を解説します

00:21:44.838 --> 00:21:46.406 align:start position:29% line:-1
まずデバイスやキューです

00:21:47.541 --> 00:21:50.410 align:start position:29% line:-2
これらは最初に
作成するオブジェクトです

00:21:52.012 --> 00:21:55.249 align:start position:34% line:-2
デバイスはGPUの
抽象的表示なのです

00:21:56.016 --> 00:21:58.452 align:start position:27% line:-1
パイプラインオブジェクトや

00:21:58.552 --> 00:22:01.722 align:start position:27% line:-2
テクスチャ バッファなどの
オブジェクト作成を担います

00:21:58.552 --> 00:22:01.722 align:start position:27% line:-2
テクスチャ バッファなどの
オブジェクト作成を担います

00:22:02.589 --> 00:22:07.528 align:start position:29% line:-2
iOSはGPU１個で
デバイスも1つ限りですが

00:22:07.628 --> 00:22:11.131 align:start position:27% line:-2
macOSでは
内臓GPUと独立型GPU―

00:22:11.231 --> 00:22:16.370 align:start position:25% line:-2
マルチeGPUまで考慮すると
マルチデバイスも可能です

00:22:17.037 --> 00:22:18.806 align:start position:30% line:-1
通常既定デバイスだけで

00:22:18.906 --> 00:22:21.575 align:start position:29% line:-2
大半のアプリケーションは
間に合います

00:22:21.675 --> 00:22:24.545 align:start position:29% line:-2
あるシステムを
コールするだけで簡単です

00:22:24.645 --> 00:22:28.115 align:start position:23% line:-2
MTLCreateSystem
DefaultDeviceです

00:22:29.817 --> 00:22:34.421 align:start position:29% line:-2
デバイスではまず
コマンドキューを作ります

00:22:35.789 --> 00:22:38.325 align:start position:32% line:-2
コマンドバッファを
入手するためキューは

00:22:38.425 --> 00:22:40.460 align:start position:27% line:-2
アプリケーション
レンダループで使われますが

00:22:40.561 --> 00:22:44.231 align:start position:30% line:-2
コマンドキューは
初期化時に作りましょう

00:22:44.832 --> 00:22:47.968 align:start position:34% line:-2
通常キューは
ひとつで十分ですが

00:22:48.068 --> 00:22:52.539 align:start position:29% line:-2
並列タスクを実行する場合
マルチキューが必要です

00:22:53.040 --> 00:22:55.075 align:start position:30% line:-2
作成したデバイスによる
キューの作成も簡単で

00:22:55.175 --> 00:22:58.278 align:start position:21% line:-2
newCommandQueueを
コールするだけです

00:22:58.612 --> 00:23:02.716 align:start position:29% line:-2
これでコマンドバッファを
入手できるようになります

00:22:58.612 --> 00:23:02.716 align:start position:29% line:-2
これでコマンドバッファを
入手できるようになります

00:23:04.351 --> 00:23:08.121 align:start position:27% line:-2
レンダオブジェクトの作成を
見てみましょう

00:23:09.323 --> 00:23:12.459 align:start position:30% line:-2
レンダリングで使用する
３つのオブジェクト

00:23:12.559 --> 00:23:14.795 align:start position:32% line:-2
テクスチャ バッファ
パイプラインです

00:23:15.295 --> 00:23:16.697 align:start position:32% line:-1
まずはテクスチャです

00:23:17.898 --> 00:23:21.435 align:start position:29% line:-2
デバイスオブジェクトから
作りますが

00:23:22.236 --> 00:23:25.139 align:start position:30% line:-2
ディスクリプタ
オブジェクトを使います

00:23:25.372 --> 00:23:29.009 align:start position:36% line:-2
非常にシンプルな
オブジェクトです

00:23:29.109 --> 00:23:32.279 align:start position:27% line:-2
オブジェクトセットアップの
プロパティのみです

00:23:32.946 --> 00:23:36.650 align:start position:27% line:-2
テクスチャの作成には
ディスクリプタを使用します

00:23:36.884 --> 00:23:39.920 align:start position:30% line:-2
作成するテクスチャの
プロパティを指定します

00:23:40.020 --> 00:23:43.724 align:start position:25% line:-2
テクスチャタイプ
2D 3D キューブマップや

00:23:43.924 --> 00:23:46.960 align:start position:21% line:-1
ディメンション Mipmap数―

00:23:47.060 --> 00:23:50.497 align:start position:25% line:-2
データの
ピクセルフォーマットなどです

00:23:51.498 --> 00:23:55.002 align:start position:29% line:-2
プロパティの各値の設定後
メソッドをコールして

00:23:55.102 --> 00:23:59.172 align:start position:21% line:-2
使用可能な
テクスチャオブジェクトを作ります

00:24:00.941 --> 00:24:05.212 align:start position:29% line:-2
テクスチャイメージ用の
メモリが割り当てられます

00:24:05.879 --> 00:24:10.617 align:start position:29% line:-2
オブジェクト作成後
ディスクリプタは不要です

00:24:11.084 --> 00:24:14.822 align:start position:23% line:-2
ディスクリプタ内のプロパティは
ロックされ変えられません

00:24:15.556 --> 00:24:19.159 align:start position:29% line:-2
テクスチャイメージ内容は
変更できます

00:24:20.360 --> 00:24:23.530 align:start position:27% line:-2
テクスチャディスクリプタに
設定する次のプロパティは

00:24:23.630 --> 00:24:26.333 align:start position:34% line:-2
バッファ作成時にも
使います

00:24:26.433 --> 00:24:28.435 align:start position:32% line:-1
ストレージモードです

00:24:29.102 --> 00:24:33.807 align:start position:23% line:-2
Metalはオブジェクト作成時
メモリを割り当てます

00:24:33.907 --> 00:24:37.811 align:start position:23% line:-2
ストレージモードはMetalに
割り当てプールを指示します

00:24:38.378 --> 00:24:41.215 align:start position:30% line:-1
共有ストレージモードは

00:24:41.315 --> 00:24:44.318 align:start position:29% line:-2
CPU GPUの両方から
アクセスできます

00:24:44.418 --> 00:24:48.622 align:start position:21% line:-2
バッファはオブジェクトに使われる
メモリへのポインタを得ます

00:24:48.856 --> 00:24:54.528 align:start position:27% line:-2
プロテクタはテクスチャへの
データ検索を簡便にできます

00:24:55.562 --> 00:24:59.633 align:start position:25% line:-2
GPUアクセスのみの
プライベートモードもあります

00:24:59.733 --> 00:25:04.071 align:start position:27% line:-1
CPUが干渉しない最適化が

00:24:59.733 --> 00:25:04.071 align:start position:27% line:-1
CPUが干渉しない最適化が

00:25:04.171 --> 00:25:06.607 align:start position:38% line:-1
可能になります

00:25:06.707 --> 00:25:11.445 align:start position:25% line:-2
このタイプのテクスチャは
GPUだけが内容を満たせます

00:25:12.412 --> 00:25:17.785 align:start position:25% line:-2
ブリットエンコーダで
CPUから書き込みもできます

00:25:17.885 --> 00:25:21.388 align:start position:25% line:-2
共有ストレージを使った
中間リソースからコピーします

00:25:22.256 --> 00:25:24.291 align:start position:27% line:-1
専用ビデオメモリがある場合

00:25:24.391 --> 00:25:28.862 align:start position:23% line:-2
ストレージ設定でリソースは
ビデオメモリに割り当てられます

00:25:30.397 --> 00:25:35.068 align:start position:14% line:-2
macOSでは３つ目のストレージ
managed storageが使えます

00:25:35.502 --> 00:25:39.473 align:start position:30% line:-2
GPU CPU双方から
データアクセスできます

00:25:39.573 --> 00:25:41.608 align:start position:30% line:-1
専用ビデオメモリの場合

00:25:41.708 --> 00:25:47.047 align:start position:20% line:-2
Metalはミラードメモリを作成し
アクセスを効率化します

00:25:47.714 --> 00:25:51.818 align:start position:29% line:-2
GPU CPUのデータが
確実にシンクロするように

00:25:51.919 --> 00:25:54.521 align:start position:32% line:-2
コールははっきりして
いなければなりません

00:25:57.758 --> 00:26:00.828 align:start position:30% line:-1
テクスチャ作成の例です

00:25:57.758 --> 00:26:00.828 align:start position:30% line:-1
テクスチャ作成の例です

00:26:02.963 --> 00:26:05.332 align:start position:27% line:-2
テクスチャディスクリプタを
作成し

00:26:05.432 --> 00:26:09.036 align:start position:30% line:-2
ストレージモードなど
プロパティを設定します

00:26:10.637 --> 00:26:14.975 align:start position:30% line:-2
次にデバイスで
テクスチャを作成します

00:26:15.742 --> 00:26:19.479 align:start position:29% line:-2
イメージデータは
行単位でバイト数を計算し

00:26:19.680 --> 00:26:23.917 align:start position:25% line:-2
GLText同様にロード先の
リージョンを指定します

00:26:26.019 --> 00:26:29.523 align:start position:12% line:-2
次にreplace regionメソッドを
コールして

00:26:29.623 --> 00:26:33.927 align:start position:27% line:-2
ポインタからデータコピーし
テクスチャに収めます

00:26:36.830 --> 00:26:40.634 align:start position:29% line:-2
テクスチャオブジェクトは
いくつかの点で異なります

00:26:40.734 --> 00:26:44.104 align:start position:25% line:-2
OpenGLのsampler
オブジェクトは選択型ですが

00:26:44.204 --> 00:26:48.008 align:start position:29% line:-2
ラップモードやフィルタを
その中に設定できます

00:26:48.108 --> 00:26:50.878 align:start position:20% line:-2
Metalでは別途
samplerオブジェクトを作るか

00:26:50.978 --> 00:26:54.114 align:start position:29% line:-2
シェーダにsampler
パラメータ設定が必要です

00:26:55.582 --> 00:26:58.185 align:start position:23% line:-2
Metalではイメージデータは
反転しません

00:26:58.285 --> 00:27:02.923 align:start position:23% line:-2
OpenGLは左下原点で
Metalは左上原点を使います

00:26:58.285 --> 00:27:02.923 align:start position:23% line:-2
OpenGLは左下原点で
Metalは左上原点を使います

00:27:03.023 --> 00:27:06.660 align:start position:32% line:-2
テクスチャロード時に
注意が必要です

00:27:07.628 --> 00:27:11.432 align:start position:25% line:-2
デスクトップ型OpenGLは
内部フォーマットとは

00:27:11.532 --> 00:27:15.435 align:start position:27% line:-2
異なるデータを供給されると
変換を実施します

00:27:16.270 --> 00:27:19.506 align:start position:27% line:-2
Metalは変換しないので
アセットのフォーマットの

00:27:19.606 --> 00:27:22.843 align:start position:32% line:-1
適合性を確認するか―

00:27:22.943 --> 00:27:26.013 align:start position:32% line:-1
変換パスを導入します

00:27:28.882 --> 00:27:30.517 align:start position:34% line:-1
バッファに移ります

00:27:32.252 --> 00:27:35.789 align:start position:25% line:-2
Metalは非構造化データの
すべてにバッファを使います

00:27:41.261 --> 00:27:45.599 align:start position:21% line:-2
OpenGLの頂点 エレメント
ユニフォームバッファと似ています

00:27:45.699 --> 00:27:50.470 align:start position:30% line:-2
これらを使っているなら
移植は容易です

00:27:51.305 --> 00:27:55.309 align:start position:7% line:-2
デバイスで
newBufferWithLengthをコールし

00:27:55.409 --> 00:27:57.444 align:start position:34% line:-2
サイズを指定すると
バッファができます

00:27:57.644 --> 00:28:00.013 align:start position:34% line:-2
ストレージモードも
指定します

00:27:57.644 --> 00:28:00.013 align:start position:34% line:-2
ストレージモードも
指定します

00:28:00.814 --> 00:28:06.553 align:start position:27% line:-2
コンテンツプロパティを通じ
バッファをロードします

00:28:07.087 --> 00:28:10.657 align:start position:29% line:-2
Metalには
非構造化データであるため

00:28:10.757 --> 00:28:14.795 align:start position:25% line:-2
レイアウトもコードのシェアも
あなた次第です

00:28:14.895 --> 00:28:17.898 align:start position:30% line:-2
ここでSIMDタイプを
使うストラクチャに

00:28:17.998 --> 00:28:21.535 align:start position:32% line:-2
コンテンツポインタを
キャストしています

00:28:22.736 --> 00:28:25.806 align:start position:30% line:-2
バッファデータを満たす
ストラクチャのメンバを

00:28:25.906 --> 00:28:30.177 align:start position:23% line:-2
レイアウトかアプリケーションの
定義に従い設定します

00:28:31.111 --> 00:28:34.715 align:start position:34% line:-2
ストラクチャ定義は
アプリケーションと

00:28:34.815 --> 00:28:39.286 align:start position:23% line:-2
シェアコードで共有でき
レイアウトの一致は確約されます

00:28:41.655 --> 00:28:43.257 align:start position:29% line:-1
よく起きる間違いである―

00:28:43.524 --> 00:28:47.427 align:start position:27% line:-2
バッファデータとシェーダの
解釈の不一致は

00:28:47.528 --> 00:28:51.565 align:start position:32% line:-2
アライメントに関する
想定によるものです

00:28:51.999 --> 00:28:54.568 align:start position:27% line:-1
例えばシェーディング言語の

00:28:54.668 --> 00:28:57.971 align:start position:30% line:-2
float型３を
12バイトと想定します

00:28:58.071 --> 00:29:01.475 align:start position:29% line:-2
４バイトコンポーネントが
３つで12バイトです

00:28:58.071 --> 00:29:01.475 align:start position:29% line:-2
４バイトコンポーネントが
３つで12バイトです

00:29:01.775 --> 00:29:05.078 align:start position:27% line:-2
しかしシェーディング言語は
float型３が

00:29:05.179 --> 00:29:10.050 align:start position:27% line:-2
16バイト消費すると解釈し
問題が発生します

00:29:10.150 --> 00:29:14.454 align:start position:25% line:-2
これはCPU GPUの使用を
最適化するために

00:29:14.555 --> 00:29:17.157 align:start position:29% line:-2
より厳密なアライメントが
採用されているためです

00:29:17.791 --> 00:29:21.562 align:start position:29% line:-2
３×３のマトリクスでも
よく同様の問題が生じます

00:29:22.129 --> 00:29:27.034 align:start position:32% line:-2
隙のないデータを
パックするのであれば

00:29:27.768 --> 00:29:30.971 align:start position:23% line:-2
Metalシェーディング言語に
パックタイプがあります

00:29:31.071 --> 00:29:35.175 align:start position:23% line:-1
パックデータをバッファ内へ移し

00:29:35.275 --> 00:29:39.813 align:start position:25% line:-2
データ遂行前にパックデータを
レギュラーベクタへ―

00:29:39.913 --> 00:29:42.649 align:start position:30% line:-1
渡さなければなりません

00:29:43.517 --> 00:29:46.420 align:start position:27% line:-1
アプリケーション構築時には

00:29:46.720 --> 00:29:50.724 align:start position:25% line:-2
最も便利なストレージモードを
勧めます

00:29:51.225 --> 00:29:56.263 align:start position:32% line:-2
リソースへより簡単に
アクセスできます

00:29:56.830 --> 00:30:01.502 align:start position:9% line:-2
iOSではStorageModeSharedで
テクスチャとバッファを作ります

00:29:56.830 --> 00:30:01.502 align:start position:9% line:-2
iOSではStorageModeSharedで
テクスチャとバッファを作ります

00:30:02.135 --> 00:30:05.305 align:start position:7% line:-2
macOSではテクスチャに
StorageModeSharedは使えませんが

00:30:05.405 --> 00:30:08.675 align:start position:12% line:-2
StorageModeManagedにより
画像データへのアクセスが容易に

00:30:08.776 --> 00:30:11.311 align:start position:32% line:-2
ただプライベート
ストレージが最適です

00:30:15.349 --> 00:30:20.254 align:start position:23% line:-2
macOSでバッファに使う場合
注意が必要です

00:30:20.354 --> 00:30:22.289 align:start position:30% line:-1
CPU GPUの両方―

00:30:22.389 --> 00:30:28.161 align:start position:23% line:-2
またはGPUのみがアクセスする
データが混在していると

00:30:28.262 --> 00:30:34.368 align:start position:23% line:-2
別々のメモリプールに分けるのが
困難になるかもしれません

00:30:36.470 --> 00:30:40.040 align:start position:30% line:-2
テクスチャとバッファを
直接作成する方法に続き

00:30:40.140 --> 00:30:44.111 align:start position:12% line:-2
common file formatsから
簡単にテクスチャやバッファを

00:30:44.211 --> 00:30:46.880 align:start position:25% line:-2
作成できるMetalKitを
解説します

00:30:46.980 --> 00:30:50.784 align:start position:23% line:-2
テクスチャロードクラスや
Model I/Oでロードした

00:30:50.884 --> 00:30:54.288 align:start position:23% line:-2
Metalバッファを裏付けた
メッシュ作成機能などがあります

00:30:57.624 --> 00:31:01.662 align:start position:23% line:-2
まずこれらを含む
レンダパイプラインオブジェクト

00:30:57.624 --> 00:31:01.662 align:start position:23% line:-2
まずこれらを含む
レンダパイプラインオブジェクト

00:31:02.596 --> 00:31:04.565 align:start position:27% line:-1
パイプラインオブジェクトは

00:31:04.665 --> 00:31:07.601 align:start position:29% line:-2
レンダディスクリプタ
オブジェクトで作成します

00:31:08.268 --> 00:31:11.538 align:start position:29% line:-2
フラグメントシェーダと
頂点がペアで入っています

00:31:12.272 --> 00:31:16.009 align:start position:27% line:-2
頂点シェーダに供給する
頂点レイアウトも指定します

00:31:17.244 --> 00:31:20.447 align:start position:30% line:-2
またレンダターゲットの
ステートと

00:31:20.547 --> 00:31:24.518 align:start position:30% line:-2
ピクセルフォーマットを
混合します

00:31:25.452 --> 00:31:28.956 align:start position:27% line:-2
変更不可のレンダステート
パイプラインオブジェクトの

00:31:29.056 --> 00:31:32.726 align:start position:30% line:-2
作成デバイスに
メソッドをコールします

00:31:33.494 --> 00:31:37.931 align:start position:30% line:-2
ディスクリプターだけで
オブジェクトができます

00:31:39.066 --> 00:31:42.536 align:start position:27% line:-2
パイプラインステート
オブジェクト作成コードです

00:31:43.370 --> 00:31:45.105 align:start position:32% line:-1
パイプライン作成前に

00:31:45.205 --> 00:31:48.976 align:start position:29% line:-2
Metalライブラリから
シェーダを引き出します

00:31:49.076 --> 00:31:53.514 align:start position:20% line:-2
この行はXcodeで構築した
デフォルトMetalライブラリです

00:31:54.515 --> 00:31:58.852 align:start position:34% line:-2
機能名を活用し
ライブラリ用頂点と

00:31:58.952 --> 00:32:01.155 align:start position:30% line:-2
フラグメントシェーダを
入手できます

00:31:58.952 --> 00:32:01.155 align:start position:30% line:-2
フラグメントシェーダを
入手できます

00:32:01.755 --> 00:32:04.424 align:start position:29% line:-1
シェーディング機能設定や

00:32:04.525 --> 00:32:07.694 align:start position:23% line:-2
レンダターゲット
ピクセルフォーマットを指定する

00:32:07.795 --> 00:32:09.763 align:start position:27% line:-2
レンダパイプライン
ディスクリプタを作成します

00:32:10.097 --> 00:32:13.934 align:start position:27% line:-2
最後にパイプラインステート
オブジェクトを作成する―

00:32:14.034 --> 00:32:16.737 align:start position:25% line:-2
ディスクリプタオブジェクトと
共にデバイスを使用します

00:32:18.272 --> 00:32:22.643 align:start position:18% line:-2
OpenGLとMetalグラフィック
パイプラインの顕著な違いです

00:32:22.743 --> 00:32:24.545 align:start position:30% line:-2
OpenGLプログラム
オブジェクトは

00:32:24.645 --> 00:32:29.383 align:start position:25% line:-2
頂点とフラグメントシェーダの
ペアのみを含みます

00:32:29.483 --> 00:32:32.519 align:start position:21% line:-2
一方Metalは頂点レイアウトや
ブレンドステート

00:32:32.619 --> 00:32:35.255 align:start position:27% line:-2
レンダターゲットピクセル
フォーマットも含んでいます

00:32:35.355 --> 00:32:38.625 align:start position:32% line:-2
パイプライン構築前に
把握しましょう

00:32:39.860 --> 00:32:43.430 align:start position:30% line:-2
パイプラインステートが
より多くあるため

00:32:43.530 --> 00:32:47.835 align:start position:21% line:-2
MetalはGPUマシンコードに
シェーダを十分変換できます

00:32:47.935 --> 00:32:51.238 align:start position:27% line:-2
OpenGLのプログラム
オブジェクトではできません

00:32:51.505 --> 00:32:54.775 align:start position:23% line:-2
次にアプリケーション初期化時に
パイプライン作成を―

00:32:54.875 --> 00:32:56.677 align:start position:32% line:-2
可能にするシステムを
構築します

00:32:57.077 --> 00:32:59.446 align:start position:29% line:-2
カノニカル頂点レイアウト
または―

00:32:59.546 --> 00:33:01.882 align:start position:34% line:-2
レンダターゲットを
限定的に選択すれば

00:32:59.546 --> 00:33:01.882 align:start position:34% line:-2
レンダターゲットを
限定的に選択すれば

00:33:01.982 --> 00:33:04.118 align:start position:27% line:-2
アプリが使用するステートの
組み合わせや

00:33:04.218 --> 00:33:07.421 align:start position:27% line:-2
パイプラインオブジェクトを
減らせます

00:33:09.123 --> 00:33:12.960 align:start position:29% line:-2
どのパイプラインが必要か
分からない場合

00:33:13.060 --> 00:33:15.462 align:start position:30% line:-1
Metalへの移植では

00:33:15.562 --> 00:33:18.766 align:start position:27% line:-2
まず作成済みパイプラインの
辞書を設けます

00:33:19.099 --> 00:33:21.602 align:start position:34% line:-2
ステートの
新しい組み合わせは

00:33:21.702 --> 00:33:25.772 align:start position:21% line:-2
ディスクリプタをキーとして
パイプラインを構築し保存できます

00:33:26.440 --> 00:33:29.776 align:start position:30% line:-2
ある意味
改変のような操作なので

00:33:30.043 --> 00:33:32.112 align:start position:34% line:-2
付加したままの
出荷は避けましょう

00:33:32.212 --> 00:33:35.816 align:start position:30% line:-2
これらのオブジェクトの
作成が高価だからです

00:33:36.150 --> 00:33:37.618 align:start position:32% line:-2
パイプライン
オブジェクトを作ると

00:33:37.718 --> 00:33:41.054 align:start position:27% line:-2
GPUコンパイラが
シェーダバイナリ中間表示を

00:33:41.155 --> 00:33:44.992 align:start position:32% line:-2
マシンコードに変換し
最適化します

00:33:45.192 --> 00:33:49.496 align:start position:23% line:-2
レンダループ実行時にこれらを
アプリケーションが作成する場合

00:33:49.596 --> 00:33:54.334 align:start position:23% line:-2
フレームレートの低下が生じたり
一時停止状態になるでしょう

00:33:55.802 --> 00:33:59.740 align:start position:23% line:-2
テクスチャやバッファへの
メモリの割り当て作業も高価です

00:33:59.840 --> 00:34:04.111 align:start position:29% line:-2
リソースにデータを満たす
プロセシングもです

00:33:59.840 --> 00:34:04.111 align:start position:29% line:-2
リソースにデータを満たす
プロセシングもです

00:34:04.778 --> 00:34:08.649 align:start position:23% line:-2
しかし作成されたオブジェクトは
レンダループで使うと

00:34:08.748 --> 00:34:12.786 align:start position:30% line:-2
事前作業のおかげで
必要なCPUは減ります

00:34:14.321 --> 00:34:18.092 align:start position:23% line:-2
ではスカーニャがレンダループの
移植を解説します

00:34:18.192 --> 00:34:22.362 align:start position:43% line:-1
（拍手）

00:34:22.496 --> 00:34:27.167 align:start position:25% line:-2
GPUソフトウェアエンジニア
スカーニャ･スドゥーグです

00:34:27.601 --> 00:34:31.871 align:start position:25% line:-2
皆さんと移行作業を共有できて
うれしい限りです

00:34:31.972 --> 00:34:33.806 align:start position:30% line:-1
では移植を続けましょう

00:34:35.676 --> 00:34:38.411 align:start position:25% line:-2
先に解説したアプリケーション
セットアップにより

00:34:38.512 --> 00:34:41.380 align:start position:27% line:-1
すべてのシェーダが構築され

00:34:41.481 --> 00:34:43.150 align:start position:32% line:-1
フレーム生成のための

00:34:43.250 --> 00:34:46.620 align:start position:30% line:-2
オブジェクトが
作成されているはずです

00:34:47.021 --> 00:34:50.357 align:start position:27% line:-1
次は各フレームに動作する―

00:34:50.456 --> 00:34:53.293 align:start position:34% line:-2
アプリケーションの
レンダループです

00:34:53.960 --> 00:34:56.163 align:start position:27% line:-1
MetalではGPU処理の

00:34:56.263 --> 00:35:00.601 align:start position:25% line:-2
非同期的特性をレンダループで
明示的に管理します

00:34:56.263 --> 00:35:00.601 align:start position:25% line:-2
非同期的特性をレンダループで
明示的に管理します

00:35:00.701 --> 00:35:04.405 align:start position:25% line:-2
またコマンドバッファを取得し
GPUコマンドリストと共に

00:35:04.505 --> 00:35:07.407 align:start position:29% line:-1
それをGPUに供給します

00:35:08.108 --> 00:35:10.811 align:start position:32% line:-2
このようにリソースを
アップデートすれば

00:35:10.911 --> 00:35:14.281 align:start position:25% line:-1
GPUはレンダループの記述を

00:35:14.381 --> 00:35:16.517 align:start position:30% line:-1
非同期的に読み取ります

00:35:17.417 --> 00:35:19.787 align:start position:34% line:-2
またレンダコマンド
エンコーダを作り

00:35:19.887 --> 00:35:21.789 align:start position:30% line:-1
レンダパスを変換します

00:35:22.823 --> 00:35:26.226 align:start position:29% line:-2
そしてフレームを
ディスプレイに提示します

00:35:27.528 --> 00:35:30.731 align:start position:32% line:-2
さてコマンドバッファ
オブジェクトです

00:35:32.166 --> 00:35:35.369 align:start position:25% line:-1
OpenGLからの主な変更は

00:35:35.469 --> 00:35:38.906 align:start position:23% line:-2
Metalはコマンドバッファを
明示的に制御できるようになり

00:35:39.006 --> 00:35:41.475 align:start position:29% line:-1
コマンドバッファを作成し

00:35:41.575 --> 00:35:46.813 align:start position:25% line:-2
GPUによる処理を自分で
決められるようになった点です

00:35:47.514 --> 00:35:50.117 align:start position:34% line:-2
まずフレーム全体を
レンダリングする―

00:35:50.217 --> 00:35:53.487 align:start position:34% line:-2
コマンドバッファを
１つ作成します

00:35:53.787 --> 00:35:56.590 align:start position:29% line:-1
アプリケーション起動後―

00:35:56.690 --> 00:36:00.094 align:start position:30% line:-2
GPUにアイドル状態が
認められた場合

00:35:56.690 --> 00:36:00.094 align:start position:30% line:-2
GPUにアイドル状態が
認められた場合

00:36:00.260 --> 00:36:05.098 align:start position:27% line:-2
複数のコマンドバッファに
フレームを分けるといいです

00:36:05.566 --> 00:36:09.770 align:start position:21% line:-2
GPUが１つのコマンドバッファを
処理している間

00:36:09.937 --> 00:36:12.472 align:start position:30% line:-2
CPUは他を
エンコーディングします

00:36:13.273 --> 00:36:17.678 align:start position:27% line:-2
フレームエンコーディングを
複数のスレッドに分ける場合

00:36:17.778 --> 00:36:21.281 align:start position:25% line:-2
スレッドごとに
コマンドバッファを作成します

00:36:21.582 --> 00:36:27.121 align:start position:25% line:-2
しかし各コマンドバッファには
追加CPUコストが関わります

00:36:27.221 --> 00:36:30.390 align:start position:30% line:-2
可能な限り
少なくしたいところです

00:36:31.992 --> 00:36:36.630 align:start position:23% line:-2
Metalは完了コールバックを
登録するAPIを提供し

00:36:36.964 --> 00:36:41.535 align:start position:21% line:-2
GPUがコマンドバッファの処理を
完了した時に関与します

00:36:41.835 --> 00:36:45.072 align:start position:36% line:-2
稼動するAPIを
見てみましょう

00:36:46.740 --> 00:36:51.111 align:start position:23% line:-2
初期化メソッド内に
コマンドキューを作成しています

00:36:51.211 --> 00:36:54.348 align:start position:18% line:-2
これを用いて
commandBufferメソッドを

00:36:54.448 --> 00:36:57.718 align:start position:25% line:-2
コールして
コマンドバッファを入手します

00:36:58.752 --> 00:37:01.555 align:start position:34% line:-2
この中にコマンドを
エンコードします

00:36:58.752 --> 00:37:01.555 align:start position:34% line:-2
この中にコマンドを
エンコードします

00:37:01.655 --> 00:37:04.958 align:start position:36% line:-2
これについては
のちほど触れます

00:37:05.759 --> 00:37:10.264 align:start position:23% line:-2
エンコーディングの終了後
commitメソッドをコールし

00:37:10.464 --> 00:37:14.668 align:start position:27% line:-2
コマンドバッファは
GPUに送られ処理されます

00:37:15.903 --> 00:37:19.106 align:start position:30% line:-2
このコマンドバッファが
GPU処理されている間

00:37:19.206 --> 00:37:21.875 align:start position:30% line:-1
２つの選択肢があります

00:37:23.410 --> 00:37:27.414 align:start position:9% line:-2
OpenGLのglFinishに似た
waitUntilCompletedメソッドを

00:37:27.514 --> 00:37:30.184 align:start position:30% line:-1
コールして待機できます

00:37:30.784 --> 00:37:34.988 align:start position:23% line:-2
この同期的に待機するメソッドは
コマンドバッファの

00:37:35.088 --> 00:37:39.093 align:start position:23% line:-2
すべてのコマンドが
GPU処理されるまで戻りません

00:37:41.061 --> 00:37:46.667 align:start position:27% line:-2
またこのコマンドバッファを
GPUにゆだねる前に

00:37:46.767 --> 00:37:50.337 align:start position:23% line:-2
完了ハンドラを加えることができ
これはコマンドバッファの

00:37:50.504 --> 00:37:53.540 align:start position:30% line:-2
GPU処理が終了すると
呼び出されます

00:37:53.807 --> 00:37:58.011 align:start position:25% line:-2
これによってCPUとGPUの
並列処理が可能になります

00:37:58.312 --> 00:38:02.816 align:start position:23% line:-2
また毎フレームデータが変化する
共有リソースをトラックして

00:37:58.312 --> 00:38:02.816 align:start position:23% line:-2
また毎フレームデータが変化する
共有リソースをトラックして

00:38:02.916 --> 00:38:05.452 align:start position:23% line:-1
効率的なアップデートができます

00:38:06.820 --> 00:38:11.058 align:start position:29% line:-2
この完了ハンドラを用いた
リソースアップデートの―

00:38:11.158 --> 00:38:15.062 align:start position:30% line:-1
効率化を見てみましょう

00:38:16.630 --> 00:38:18.565 align:start position:32% line:-2
ほとんどの
アプリケーションは―

00:38:18.665 --> 00:38:21.702 align:start position:32% line:-2
新データを毎フレーム
GPUに押し出します

00:38:21.969 --> 00:38:25.939 align:start position:25% line:-2
例えばアニメーションに必要な
シェーダユニフォームなど

00:38:26.106 --> 00:38:30.944 align:start position:18% line:-2
MetalではGPUがアクセス中でも
CPUは同じメモリの―

00:38:31.044 --> 00:38:36.550 align:start position:30% line:-2
共有リソースに
書き込むことができます

00:38:37.184 --> 00:38:40.821 align:start position:29% line:-2
Metalはこのような
データ競合を保護しません

00:38:41.121 --> 00:38:46.493 align:start position:18% line:-2
OpenGLはGPUのワークロードが
終了するのを待つか

00:38:46.660 --> 00:38:52.399 align:start position:23% line:-2
追加コピーを取ってデフォルトで
データ競合を防止しますが

00:38:52.633 --> 00:38:55.736 align:start position:32% line:-2
アプリケーションには
最適ではないでしょう

00:38:56.069 --> 00:38:59.606 align:start position:21% line:-2
Metalではアプリケーションに
最も適合する―

00:38:59.707 --> 00:39:03.544 align:start position:38% line:-2
最適同期戦略を
採用できます

00:38:59.707 --> 00:39:03.544 align:start position:38% line:-2
最適同期戦略を
採用できます

00:39:04.077 --> 00:39:06.847 align:start position:38% line:-2
多くの場合
一番いい方法は

00:39:06.947 --> 00:39:11.752 align:start position:18% line:-2
CPUとGPUが同時に同じバッファに
アクセスしないよう―

00:39:11.852 --> 00:39:15.522 align:start position:23% line:-2
共有リソースにマルチバッファを
活用することです

00:39:17.624 --> 00:39:21.628 align:start position:16% line:-2
ここではOpenGLアプリケーションを
Metalに移植したところで

00:39:21.729 --> 00:39:28.202 align:start position:23% line:-2
これら動的データアップデートに
シングルバッファを用いています

00:39:28.535 --> 00:39:32.372 align:start position:21% line:-2
まだ同期メソッドを
アプリケーションに適用しておらず

00:39:32.472 --> 00:39:35.342 align:start position:29% line:-1
次のようなことが起きます

00:39:36.677 --> 00:39:41.381 align:start position:21% line:-2
アプリケーションは最初の
フレームのコマンドを生成しながら

00:39:41.481 --> 00:39:44.318 align:start position:29% line:-2
バッファに書き込み
これをGPUに送信します

00:39:45.152 --> 00:39:50.190 align:start position:23% line:-2
GPUはこのコマンドバッファを
読んで処理を進めます

00:39:51.959 --> 00:39:55.429 align:start position:30% line:-2
次のフレームのために
バッファを更新する一方

00:39:55.529 --> 00:39:58.732 align:start position:25% line:-2
GPUは まだそのバッファを
読んでいる状態です

00:39:59.767 --> 00:40:04.238 align:start position:27% line:-2
これは明らかに競合状態で
結果がどうなるか不明確です

00:39:59.767 --> 00:40:04.238 align:start position:27% line:-2
これは明らかに競合状態で
結果がどうなるか不明確です

00:40:05.172 --> 00:40:10.144 align:start position:23% line:-2
アプリケーションを
修整する方法がいくつかあります

00:40:11.511 --> 00:40:14.281 align:start position:32% line:-2
最も簡単な方法として
コマンドバッファの

00:40:14.381 --> 00:40:17.618 align:start position:9% line:-2
waitUntilCompletedメソッドを
各フレームの後にコールします

00:40:19.753 --> 00:40:23.490 align:start position:25% line:-2
しかし次のフレームのために
このバッファに上書きする前に

00:40:23.590 --> 00:40:28.395 align:start position:25% line:-2
GPUの読み込みが終わるまで
待たなければなりません

00:40:28.962 --> 00:40:34.468 align:start position:27% line:-2
このようにCPUとGPUの
使用効率が非常に悪く

00:40:34.568 --> 00:40:38.539 align:start position:34% line:-2
出荷コードでは
避けたいところです

00:40:38.772 --> 00:40:43.110 align:start position:21% line:-2
ただMetalアプリケーションを
起動しておくと非常に便利です

00:40:43.577 --> 00:40:50.050 align:start position:27% line:-2
このようなデータ競合を
検出することもできるのです

00:40:51.885 --> 00:40:57.191 align:start position:23% line:-2
リソースアップデートの同期は
マルチバッファで効率化できます

00:40:57.357 --> 00:41:02.429 align:start position:29% line:-2
動的データアップデートを
３つのバッファで行います

00:40:57.357 --> 00:41:02.429 align:start position:29% line:-2
動的データアップデートを
３つのバッファで行います

00:41:02.629 --> 00:41:07.901 align:start position:23% line:-2
まずフレーム１でバッファに書き
それをGPUが読みます

00:41:08.035 --> 00:41:12.906 align:start position:23% line:-2
フレーム２は別のバッファに書き
競合状態を回避します

00:41:13.140 --> 00:41:16.710 align:start position:27% line:-2
同様にフレーム３で３つ目の
バッファに書き込みます

00:41:18.178 --> 00:41:22.783 align:start position:25% line:-2
これで３つとも使い果たし
バッファプールが枯渇しました

00:41:23.350 --> 00:41:29.056 align:start position:23% line:-2
GPUがフレーム１を終えるまで
フレーム４に再利用できません

00:41:31.625 --> 00:41:34.595 align:start position:32% line:-2
ここで完了ハンドラの
出番となります

00:41:34.695 --> 00:41:38.699 align:start position:25% line:-2
GPUのフレーム処理の終了を
教えてくれます

00:41:38.932 --> 00:41:43.270 align:start position:23% line:-2
フレーム１が終わればバッファを
フレーム４に再利用できます

00:41:44.571 --> 00:41:45.772 align:start position:39% line:-1
以下同様です

00:41:47.107 --> 00:41:49.109 align:start position:34% line:-1
例を見てみましょう

00:41:50.911 --> 00:41:54.781 align:start position:29% line:-2
レンダリングループ外の
トリプルバッファ適用では

00:41:54.882 --> 00:41:58.152 align:start position:23% line:-2
３つのバッファに対し
まずFIFOキューを作成します

00:41:59.853 --> 00:42:04.825 align:start position:5% line:-2
またframeBoundarySemaphoreの
初期スタート値を３に設定します

00:41:59.853 --> 00:42:04.825 align:start position:5% line:-2
またframeBoundarySemaphoreの
初期スタート値を３に設定します

00:42:04.925 --> 00:42:09.329 align:start position:23% line:-2
これは各フレーム境界線で
セマフォが発信されることを表し

00:42:09.429 --> 00:42:12.833 align:start position:25% line:-2
それはGPUがフレーム処理を
終えたことを意味します

00:42:13.033 --> 00:42:15.936 align:start position:29% line:-2
CPUのバッファ再利用が
可能となるのです

00:42:17.337 --> 00:42:19.506 align:start position:27% line:-1
またバッファインデックスを

00:42:19.606 --> 00:42:22.743 align:start position:25% line:-2
カレントフレームのバッファに
ポイントするよう設定します

00:42:23.677 --> 00:42:29.083 align:start position:25% line:-2
レンダリングループにおいては
バッファの書き込み前に

00:42:29.183 --> 00:42:34.087 align:start position:23% line:-2
対応するフレームの
GPU処理終了の確認が必要です

00:42:34.188 --> 00:42:35.923 align:start position:34% line:-1
フレームの先頭で―

00:42:36.056 --> 00:42:38.992 align:start position:9% line:-2
frameBoundarySemaphoreを
待ちます

00:42:39.493 --> 00:42:42.162 align:start position:34% line:-2
カレントフレームが
GPU処理を―

00:42:42.262 --> 00:42:45.933 align:start position:29% line:-2
終えたことを知らせる
セマフォが発信されると…

00:42:47.634 --> 00:42:52.139 align:start position:25% line:-2
安全にバッファをつかみ
新しいデータに再利用できます

00:42:53.774 --> 00:42:58.145 align:start position:30% line:-2
このバッファをGPUに
関連付けるために

00:42:58.745 --> 00:43:02.583 align:start position:32% line:-2
いくつかのコマンドを
エンコードします

00:42:58.745 --> 00:43:02.583 align:start position:32% line:-2
いくつかのコマンドを
エンコードします

00:43:02.683 --> 00:43:07.087 align:start position:21% line:-2
またフレームのコマンドバッファに
完了ハンドラを加えます

00:43:08.088 --> 00:43:12.259 align:start position:29% line:-2
そしてコマンドバッファを
GPUにゆだねます

00:43:12.760 --> 00:43:19.133 align:start position:21% line:-2
フレームのGPU処理が終了すると
完了ハンドラが発動され

00:43:19.233 --> 00:43:22.502 align:start position:34% line:-2
フレームセマフォに
信号を送ります

00:43:23.637 --> 00:43:28.342 align:start position:25% line:-2
これでCPUはエンコード用に
バッファを再利用できます

00:43:28.575 --> 00:43:31.511 align:start position:27% line:-1
このトリプルバッファ用法は

00:43:31.678 --> 00:43:36.250 align:start position:25% line:-2
あらゆる動的データリソースの
更新に活用できます

00:43:37.784 --> 00:43:43.056 align:start position:25% line:-2
さてコマンドバッファと
リソースアップデートに続いて

00:43:43.490 --> 00:43:46.393 align:start position:27% line:-2
ドローコードのエンコードに
使用する―

00:43:46.493 --> 00:43:50.130 align:start position:25% line:-2
レンダパスエンコーダについて
解説します

00:43:51.598 --> 00:43:56.870 align:start position:29% line:-2
先にダンが説明したように
コマンドエンコーダは

00:43:56.970 --> 00:44:00.274 align:start position:21% line:-2
コマンドバッファでAPIコールを
GPUコマンドに変換します

00:43:56.970 --> 00:44:00.274 align:start position:21% line:-2
コマンドバッファでAPIコールを
GPUコマンドに変換します

00:44:00.674 --> 00:44:04.478 align:start position:25% line:-2
典型的な画像APIを供給する
レンダコマンドバッファや

00:44:04.578 --> 00:44:08.982 align:start position:21% line:-2
パイプライン テクスチャバッファ
オブジェクトなどの設定―

00:44:09.083 --> 00:44:12.619 align:start position:29% line:-2
ドローコードの操作などを
お話しましょう

00:44:14.288 --> 00:44:19.159 align:start position:25% line:-2
エンコーダ作成に先立ち
レンダターゲットを設定します

00:44:19.259 --> 00:44:23.797 align:start position:29% line:-2
レンダターゲットを設定し
新しいエンコーダの作成を

00:44:23.897 --> 00:44:29.002 align:start position:25% line:-2
コマンドバッファに要請する
レンダパスディスクリプタです

00:44:29.236 --> 00:44:33.740 align:start position:23% line:-2
このエンコーダをドローコードの
エンコードに使用できます

00:44:34.942 --> 00:44:39.113 align:start position:23% line:-2
OpenGLとの大きな違いは
Metalではエンコーダ作成後

00:44:39.379 --> 00:44:43.984 align:start position:29% line:-2
レンダターゲットを
変更することはできません

00:44:44.084 --> 00:44:48.822 align:start position:25% line:-2
GPUは同じレンダターゲット
セットとレンダしている--

00:44:48.922 --> 00:44:53.460 align:start position:25% line:-2
最大のドローコールを見ると
働きがずっとよくなるからです

00:44:53.894 --> 00:44:58.932 align:start position:21% line:-2
Metal APIはレンダパスに
スタート エンドを明示して

00:44:59.032 --> 00:45:01.034 align:start position:32% line:-1
これを反映しています

00:44:59.032 --> 00:45:01.034 align:start position:32% line:-1
これを反映しています

00:45:01.135 --> 00:45:03.971 align:start position:36% line:-2
このエンコーダが
発行するドローは

00:45:04.071 --> 00:45:07.341 align:start position:29% line:-2
これらレンダターゲットに
レンダリングを行います

00:45:08.408 --> 00:45:11.378 align:start position:23% line:-2
別のレンダターゲットセットへの
ドローは―

00:45:11.478 --> 00:45:14.548 align:start position:30% line:-2
このレンダパスを終了し
新しいパスを開始します

00:45:17.084 --> 00:45:21.955 align:start position:27% line:-2
レンダパスディスクリプタや
色 深度アタッチメントが

00:45:22.055 --> 00:45:24.024 align:start position:32% line:-1
作成されたところです

00:45:24.992 --> 00:45:30.097 align:start position:21% line:-2
これでレンダコマンドエンコーダを
このディスクリプタで作れます

00:45:30.297 --> 00:45:32.699 align:start position:29% line:-2
このエンコーダが発行する
ドローは

00:45:32.800 --> 00:45:35.869 align:start position:32% line:-2
これらのターゲットに
レンダされます

00:45:37.371 --> 00:45:42.209 align:start position:25% line:-2
MetalではGPU帯域幅の
任意使用のために

00:45:42.309 --> 00:45:46.547 align:start position:25% line:-2
ロードやストア アクションを
供給することもできます

00:45:48.048 --> 00:45:52.753 align:start position:23% line:-2
これらのアクションは
テクスチャをレンダパスの前後で

00:45:52.886 --> 00:45:56.256 align:start position:27% line:-1
どのように扱うか制御します

00:45:56.490 --> 00:46:00.661 align:start position:29% line:-2
レンダパス用の色と深度の
アタッチメントです

00:45:56.490 --> 00:46:00.661 align:start position:29% line:-2
レンダパス用の色と深度の
アタッチメントです

00:46:01.895 --> 00:46:04.832 align:start position:27% line:-2
ロードアクションがクリアに
指定された場合

00:46:04.932 --> 00:46:10.237 align:start position:21% line:-2
GPUはまず両レンダターゲットの
コンテンツをクリアします

00:46:11.338 --> 00:46:16.577 align:start position:21% line:-2
次にGPUはレンダターゲットへの
コマンドを処理します

00:46:17.911 --> 00:46:22.316 align:start position:25% line:-2
レンダパスの最後に
ストアアクションを指定します

00:46:22.416 --> 00:46:26.854 align:start position:23% line:-2
ここでは色バッファへの
ストアアクション指示はストアで

00:46:26.954 --> 00:46:31.291 align:start position:29% line:-2
レンダパスの最後に
コンテンツは保存されます

00:46:31.391 --> 00:46:35.963 align:start position:23% line:-2
一方深度アタッチメントへの
ストアアクションはドントケアで

00:46:36.063 --> 00:46:38.132 align:start position:29% line:-1
コンテンツは廃棄されます

00:46:38.865 --> 00:46:44.538 align:start position:23% line:-2
ロード ストアはメモリ帯域幅を
消費する高価なGPU動作です

00:46:44.805 --> 00:46:48.709 align:start position:29% line:-2
クリア ドントケアを
可能な限り指定しましょう

00:46:50.177 --> 00:46:52.246 align:start position:29% line:-1
アクションの設定方法です

00:46:52.346 --> 00:46:58.318 align:start position:23% line:-2
ロードアクションをクリアにして
クリアカラーを設定しています

00:46:59.119 --> 00:47:01.588 align:start position:27% line:-2
ストアアクションはストアに
設定しています

00:46:59.119 --> 00:47:01.588 align:start position:27% line:-2
ストアアクションはストアに
設定しています

00:47:01.688 --> 00:47:06.226 align:start position:25% line:-2
ロード ストアアクションは
レンダパスディスクリプタ内の

00:47:06.326 --> 00:47:08.695 align:start position:34% line:-2
レンダターゲットに
指定できます

00:47:08.795 --> 00:47:13.233 align:start position:30% line:-2
レンダターゲットを
以上のように構成します

00:47:14.668 --> 00:47:18.338 align:start position:30% line:-2
このディスクリプタから
エンコーダを作成して―

00:47:18.438 --> 00:47:20.974 align:start position:36% line:-2
ドローコールを
エンコードします

00:47:21.708 --> 00:47:25.279 align:start position:23% line:-1
その前にOpenGLコマンドと

00:47:25.379 --> 00:47:28.549 align:start position:25% line:-2
それに相当するMetal版を
紹介します

00:47:29.950 --> 00:47:32.953 align:start position:21% line:-2
典型的な
OpenGLドローシーケンスです

00:47:33.987 --> 00:47:37.491 align:start position:25% line:-2
まず すべての
レンダターゲットを設定する―

00:47:37.691 --> 00:47:40.194 align:start position:34% line:-2
フレームバッファを
バインドします

00:47:41.261 --> 00:47:45.432 align:start position:30% line:-2
頂点シェーダなどを含む
プログラムをバインドし

00:47:46.400 --> 00:47:50.070 align:start position:25% line:-2
そして頂点データを含む
頂点バッファをバインドします

00:47:51.438 --> 00:47:55.075 align:start position:23% line:-2
さらにすべてのユニフォーム
を含むバッファをバインドします

00:47:56.010 --> 00:47:58.946 align:start position:34% line:-2
またサンプルする
テクスチャを設定し

00:47:59.613 --> 00:48:01.348 align:start position:34% line:-1
最後にドローします

00:47:59.613 --> 00:48:01.348 align:start position:34% line:-1
最後にドローします

00:48:02.316 --> 00:48:05.853 align:start position:30% line:-2
こちらのMetal版は
より明示的であるため

00:48:05.953 --> 00:48:10.124 align:start position:25% line:-2
コード列が増えますが
OpenGLとよく似ています

00:48:10.724 --> 00:48:13.994 align:start position:27% line:-2
まずレンダターゲットを含む
パスディスクリプターで

00:48:14.094 --> 00:48:16.663 align:start position:27% line:-2
レンダコマンドエンコーダを
作成します

00:48:17.531 --> 00:48:21.001 align:start position:27% line:-2
シェーダを含むパイプライン
オブジェクトを設定します

00:48:22.002 --> 00:48:26.406 align:start position:23% line:-2
次は頂点シェーダにアクセスする
バッファの設定ですが

00:48:26.507 --> 00:48:29.476 align:start position:34% line:-2
ドローに使う頂点が
入っています

00:48:30.277 --> 00:48:33.213 align:start position:21% line:-2
Metalは頂点かユニフォームか
中身でバッファを区別しません

00:48:33.313 --> 00:48:37.484 align:start position:21% line:-2
Metalは頂点かユニフォームか
中身でバッファを区別しません

00:48:37.618 --> 00:48:41.789 align:start position:25% line:-2
なのでユニフォームバッファの
設定に同じAPIを使います

00:48:42.356 --> 00:48:45.759 align:start position:25% line:-2
最初のコールで頂点シェーダが
バッファアクセスをして

00:48:45.859 --> 00:48:49.096 align:start position:27% line:-2
次はフラグメントシェーダが
アクセスします

00:48:50.230 --> 00:48:54.268 align:start position:23% line:-2
さらにサンプルするフラグメント
シェーダのテクスチャを決めます

00:48:55.569 --> 00:48:56.937 align:start position:34% line:-1
そしてドローします

00:48:58.105 --> 00:49:01.542 align:start position:14% line:-2
最後にendEncodingをエンコーダ
オブジェクトにコールして

00:48:58.105 --> 00:49:01.542 align:start position:14% line:-2
最後にendEncodingをエンコーダ
オブジェクトにコールして

00:49:01.675 --> 00:49:05.679 align:start position:27% line:-2
エンコードコマンドの終了を
Metalに明示します

00:49:06.013 --> 00:49:09.717 align:start position:25% line:-2
簡単なMetalレンダパスの
一例でした

00:49:11.518 --> 00:49:14.254 align:start position:34% line:-2
完全なレンダパスを
手に入れたところで

00:49:14.388 --> 00:49:17.224 align:start position:25% line:-2
これらレンダリングの
ディスプレイ表示をしましょう

00:49:18.992 --> 00:49:23.163 align:start position:18% line:-2
OpenGLではレンダしたフレームを
スクリーン表示しますが

00:49:23.263 --> 00:49:27.134 align:start position:27% line:-2
ドローアブルと呼ばれる
システムのレンダバッファを

00:49:27.468 --> 00:49:29.503 align:start position:30% line:-2
明確に管理するわけでは
ありません

00:49:30.170 --> 00:49:34.608 align:start position:25% line:-2
Metalでコンテンツを
ディスプレイ表示するためには

00:49:34.708 --> 00:49:39.413 align:start position:25% line:-2
システムから特殊テクスチャの
ドローアブルをまず入手します

00:49:39.513 --> 00:49:43.650 align:start position:25% line:-2
MTKViewが各フレームの
ドローアブルテクスチャを

00:49:43.750 --> 00:49:45.118 align:start position:41% line:-1
供給します

00:49:45.219 --> 00:49:49.823 align:start position:27% line:-2
ドローアブルを入手すると
レンダパスをエンコードして

00:49:49.923 --> 00:49:54.862 align:start position:25% line:-2
他のテクスチャと同様に
ドローアブルにレンダできます

00:49:54.962 --> 00:50:00.667 align:start position:23% line:-2
ただ他のテクスチャと異なり
ドローアブルはビューへ示せます

00:49:54.962 --> 00:50:00.667 align:start position:23% line:-2
ただ他のテクスチャと異なり
ドローアブルはビューへ示せます

00:50:01.101 --> 00:50:03.303 align:start position:36% line:-1
コードの一例です

00:50:04.738 --> 00:50:09.943 align:start position:23% line:-2
ドローアブルは限定的な
シェードシステムリソースなので

00:50:10.043 --> 00:50:13.847 align:start position:30% line:-2
その保持は極力
短時間に留めるべきです

00:50:14.181 --> 00:50:18.619 align:start position:27% line:-2
そこでドローアブル取得前に
オフスクリーンレンダパスを

00:50:18.719 --> 00:50:20.954 align:start position:32% line:-1
エンコードしましょう

00:50:22.022 --> 00:50:26.260 align:start position:27% line:-2
MTKViewを作成し
このようにエンコーダ作成に

00:50:26.360 --> 00:50:31.431 align:start position:23% line:-2
直接使える完全実装のレンダパス
ディスクリプタを設定したり

00:50:31.531 --> 00:50:34.768 align:start position:7% line:-1
view.currentDrawableを使って

00:50:34.868 --> 00:50:40.174 align:start position:30% line:-2
特定のテクスチャを
要請することもできます

00:50:40.708 --> 00:50:44.812 align:start position:27% line:-2
レンダパスディスクリプタも
この周囲に構築できます

00:50:47.247 --> 00:50:49.516 align:start position:27% line:-1
フレームのエンコード終了後

00:50:49.616 --> 00:50:54.087 align:start position:16% line:-2
コマンドバッファの
drawableメソッドをコールすると

00:50:54.188 --> 00:50:58.458 align:start position:23% line:-2
GPUのコマンドバッファ処理後
ドローアブルが表示されます

00:50:58.826 --> 00:51:04.431 align:start position:23% line:-2
GPUのフレーム処理が終わると
フレームが表示されます

00:50:58.826 --> 00:51:04.431 align:start position:23% line:-2
GPUのフレーム処理が終わると
フレームが表示されます

00:51:05.532 --> 00:51:08.535 align:start position:27% line:-2
Metalでレンダリングを
ディスプレイ表示する方法を

00:51:08.635 --> 00:51:10.904 align:start position:34% line:-1
足早に紹介しました

00:51:12.373 --> 00:51:14.541 align:start position:25% line:-1
他にもいくつかコツがあります

00:51:15.208 --> 00:51:20.214 align:start position:23% line:-2
Metaにレンダパスを１つずつ
移植することは可能です

00:51:20.647 --> 00:51:24.284 align:start position:21% line:-2
IOSurfaceと
CVPixelBufferを使い

00:51:24.751 --> 00:51:29.490 align:start position:18% line:-2
OpenGLとMetalで共有できる
テクスチャが作成できます

00:51:30.190 --> 00:51:35.996 align:start position:18% line:-2
これによりOpenGLでテクスチャに
レンダしてそれをMetalで読む―

00:51:36.096 --> 00:51:37.598 align:start position:27% line:-1
またその逆が可能となります

00:51:38.198 --> 00:51:43.504 align:start position:21% line:-2
これを移植の増強や
OpenGL系プラグインの移植に

00:51:43.604 --> 00:51:46.773 align:start position:27% line:-2
活用できる
アプリケーションもあります

00:51:47.774 --> 00:51:50.477 align:start position:32% line:-2
この方法の参考として
サンプルコードが

00:51:50.577 --> 00:51:53.113 align:start position:34% line:-2
当セッションに
リンクされています

00:51:55.582 --> 00:52:00.354 align:start position:20% line:-2
Metalアプリケーションがあれば
その特性がすべて活用できます

00:51:55.582 --> 00:52:00.354 align:start position:20% line:-2
Metalアプリケーションがあれば
その特性がすべて活用できます

00:52:00.921 --> 00:52:04.525 align:start position:20% line:-2
CPU制約のあるアプリケーションは
エンコーディング動作を

00:52:04.625 --> 00:52:07.327 align:start position:30% line:-2
マルチスレッドにすると
効果的です

00:52:07.561 --> 00:52:10.898 align:start position:29% line:-2
別のスレッドに同時に
マルチコマンドバッファを

00:52:10.998 --> 00:52:12.533 align:start position:34% line:-1
エンコードできます

00:52:12.800 --> 00:52:17.104 align:start position:23% line:-2
並列レンダコマンドエンコーダを
使い 単一バッファコマンドを

00:52:17.237 --> 00:52:19.907 align:start position:32% line:-2
マルチスレッドに
分けることもできます

00:52:24.511 --> 00:52:28.615 align:start position:21% line:-2
また計画的API処理による
GPUコンピュートがMetalに

00:52:28.716 --> 00:52:30.484 align:start position:34% line:-1
組み込まれています

00:52:30.584 --> 00:52:33.754 align:start position:25% line:-2
GPUをまったく新しい方法で
活用できます

00:52:33.854 --> 00:52:37.758 align:start position:21% line:-2
CPUの代わりに
グラフィックGPUデータの生成に

00:52:37.858 --> 00:52:41.061 align:start position:27% line:-2
コンピュートパイプラインを
活用できます

00:52:41.195 --> 00:52:44.398 align:start position:32% line:-2
GPUが自ら
データを生成するので

00:52:44.498 --> 00:52:49.136 align:start position:27% line:-2
CPU使用と同期ポイントが
軽減されるだけでなく

00:52:49.236 --> 00:52:52.506 align:start position:30% line:-2
GPUにデータ帯域幅を
開放できます

00:52:53.006 --> 00:52:56.310 align:start position:27% line:-1
この高度帯域幅プロセッサで

00:52:56.410 --> 00:52:59.813 align:start position:29% line:-2
より複雑なアルゴリズムを
たくさん適用できます

00:53:03.183 --> 00:53:06.020 align:start position:23% line:-2
Metalはアプリケーションの
性能を向上させる―

00:53:06.120 --> 00:53:10.023 align:start position:30% line:-2
たくさんの優れた機能を
サポートしています

00:53:12.025 --> 00:53:16.463 align:start position:27% line:-2
さらに移植過程の一環として
Xcodeに統合された―

00:53:16.563 --> 00:53:20.667 align:start position:25% line:-2
Metalの強力なデバッグと
最適化ツールを

00:53:20.768 --> 00:53:23.737 align:start position:27% line:-1
使用するよう強く推奨します

00:53:24.204 --> 00:53:27.508 align:start position:32% line:-2
Metalには
優れたレイヤーがあり

00:53:27.608 --> 00:53:32.379 align:start position:25% line:-2
APIの不適切な使用に関する
詳しい情報をプリントしたり

00:53:32.479 --> 00:53:35.215 align:start position:36% line:-2
潜在的な修整を
示唆してくれます

00:53:36.783 --> 00:53:40.087 align:start position:30% line:-2
これはGPUデバッガで
Metalコールや

00:53:40.187 --> 00:53:46.160 align:start position:27% line:-2
フレームのレンダ状態を
ステップごとに確認できます

00:53:46.493 --> 00:53:50.531 align:start position:32% line:-2
フレームに関連した
リソースも見られます

00:53:50.698 --> 00:53:55.402 align:start position:25% line:-2
またリソースの使用に基づいて
専門的な助言も提供します

00:53:56.437 --> 00:54:00.607 align:start position:23% line:-2
今年は他の機能と同じように
シェーダ機能のバグを除去する―

00:53:56.437 --> 00:54:00.607 align:start position:23% line:-2
今年は他の機能と同じように
シェーダ機能のバグを除去する―

00:54:00.774 --> 00:54:04.244 align:start position:30% line:-2
シェーダデバッグ機能を
付加しました

00:54:05.712 --> 00:54:10.017 align:start position:25% line:-2
またシェーダに関連する多様な
性能メトリクスを提示する―

00:54:10.117 --> 00:54:12.419 align:start position:30% line:-2
シェーダプロファイラも
加えました

00:54:13.787 --> 00:54:17.524 align:start position:32% line:-2
さらにレンダパス間の
依存度を評価し

00:54:17.658 --> 00:54:22.596 align:start position:29% line:-2
アプリケーションの性能を
向上させるために

00:54:22.696 --> 00:54:28.368 align:start position:25% line:-2
重複するレンダパスを統合する
依存ビューアもあります

00:54:30.003 --> 00:54:32.806 align:start position:20% line:-2
最後に
Metalシステムトレースツールは

00:54:32.906 --> 00:54:35.742 align:start position:29% line:-2
デバイスにおける
アプリケーション動作や―

00:54:35.843 --> 00:54:39.179 align:start position:36% line:-2
性能をすべて
表示してくれます

00:54:39.346 --> 00:54:44.017 align:start position:27% line:-2
移植作業を軽減するためにも
これらのツールを推奨します

00:54:45.419 --> 00:54:49.923 align:start position:25% line:-2
OpenGLとOpenCLは
非推奨化されます

00:54:50.023 --> 00:54:54.528 align:start position:29% line:-2
まだ存在していますが
将来の使用には否定的です

00:54:54.628 --> 00:54:56.864 align:start position:27% line:-1
Metalを採用しましょう

00:54:57.064 --> 00:55:01.969 align:start position:23% line:-2
豊富な開発者ツールと経験により
我々は多くのチームを支援し

00:54:57.064 --> 00:55:01.969 align:start position:23% line:-2
豊富な開発者ツールと経験により
我々は多くのチームを支援し

00:55:02.069 --> 00:55:07.307 align:start position:30% line:-2
大幅な改善がもたらされ
成功を収めてきました

00:55:07.574 --> 00:55:12.813 align:start position:23% line:-2
本日の情報共有で 移植が
滞りなくできるよう願っています

00:55:13.881 --> 00:55:16.950 align:start position:23% line:-2
Metalとアプリケーションの
動作について―

00:55:17.051 --> 00:55:19.753 align:start position:32% line:-1
お話ができて光栄です

00:55:19.853 --> 00:55:24.525 align:start position:12% line:-2
明日“OpenGL to Metal
Porting Lab”でお会いしましょう

00:55:24.658 --> 00:55:27.728 align:start position:25% line:-2
Metal関連のセッションが
多数あります

00:55:27.828 --> 00:55:31.165 align:start position:23% line:-2
Metalとアプリケーションの
デバッグや―

00:55:31.265 --> 00:55:34.768 align:start position:27% line:-2
最適化に関するセッションに
ぜひご参加ください

00:55:35.903 --> 00:55:38.438 align:start position:30% line:-2
ご参加いただき
ありがとうございました

00:55:38.539 --> 00:55:41.108 align:start position:36% line:-2
よいお時間を
お過ごしください

00:55:41.241 --> 00:55:45.145 align:start position:43% line:-1
（拍手）
