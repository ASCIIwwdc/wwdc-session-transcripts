WEBVTT

00:00:07.516 --> 00:00:26.516 A:middle
[ Music ]

00:00:27.516 --> 00:00:34.116 A:middle
[ Applause ]

00:00:34.616 --> 00:00:35.116 A:middle
&gt;&gt; Hi, everybody.

00:00:36.476 --> 00:00:36.876 A:middle
I'm Ben.

00:00:37.016 --> 00:00:37.986 A:middle
I work on the Swift standard

00:00:37.986 --> 00:00:38.306 A:middle
library.

00:00:38.386 --> 00:00:39.686 A:middle
And, together with my colleague

00:00:39.686 --> 00:00:40.816 A:middle
Doug, from the compiler team,

00:00:40.946 --> 00:00:42.326 A:middle
we're going to talk to you about

00:00:42.326 --> 00:00:43.136 A:middle
Swift generics.

00:00:43.696 --> 00:00:46.456 A:middle
So, the recent releases of Swift

00:00:46.456 --> 00:00:47.536 A:middle
have added some important new

00:00:47.536 --> 00:00:49.916 A:middle
features, including conditional

00:00:49.916 --> 00:00:51.516 A:middle
conformance, and recursive

00:00:51.516 --> 00:00:52.446 A:middle
protocol constraints.

00:00:53.536 --> 00:00:55.186 A:middle
And, in fact, with every release

00:00:55.186 --> 00:00:56.876 A:middle
of Swift, we've been refining

00:00:56.876 --> 00:00:58.496 A:middle
the generic system, making it

00:00:58.496 --> 00:00:59.276 A:middle
more expressive.


00:01:00.166 --> 00:01:01.616 A:middle
And, we feel that the 4.2

00:01:01.616 --> 00:01:02.896 A:middle
release marks an important

00:01:02.896 --> 00:01:03.166 A:middle
point.

00:01:04.296 --> 00:01:05.756 A:middle
It's the point where we can

00:01:05.756 --> 00:01:07.996 A:middle
finally fully implement a number

00:01:07.996 --> 00:01:09.226 A:middle
of designs that have always been

00:01:09.226 --> 00:01:10.096 A:middle
envisioned for the standard

00:01:10.096 --> 00:01:10.626 A:middle
library.

00:01:10.936 --> 00:01:12.196 A:middle
Something that's critical for us

00:01:12.626 --> 00:01:14.036 A:middle
in achieving our goal of API

00:01:14.156 --> 00:01:15.166 A:middle
stability for Swift.

00:01:16.696 --> 00:01:18.226 A:middle
So, we've given a lot of talks

00:01:18.226 --> 00:01:19.406 A:middle
about generics in the past, but

00:01:19.406 --> 00:01:20.506 A:middle
we haven't taken a step back,

00:01:20.556 --> 00:01:22.016 A:middle
and talked about generics as a

00:01:22.016 --> 00:01:22.756 A:middle
whole for a while.

00:01:23.196 --> 00:01:24.686 A:middle
So, today, we're going to take

00:01:24.686 --> 00:01:26.306 A:middle
you through a few different

00:01:26.306 --> 00:01:27.436 A:middle
features of the generics system,

00:01:27.436 --> 00:01:29.626 A:middle
both new and old, to help

00:01:29.626 --> 00:01:30.716 A:middle
understand how they fit

00:01:30.716 --> 00:01:31.026 A:middle
together.

00:01:31.026 --> 00:01:34.006 A:middle
I'm going to briefly recap the

00:01:34.006 --> 00:01:35.426 A:middle
motivation for generics.

00:01:35.976 --> 00:01:37.916 A:middle
We're going to talk about

00:01:38.166 --> 00:01:39.356 A:middle
designing protocols, giving a

00:01:39.356 --> 00:01:41.106 A:middle
number of concrete types, using

00:01:41.106 --> 00:01:42.576 A:middle
examples taken from the standard

00:01:42.576 --> 00:01:43.236 A:middle
library.

00:01:43.596 --> 00:01:45.526 A:middle
We're going to review protocol

00:01:45.526 --> 00:01:47.146 A:middle
inheritance, and talk about the

00:01:47.146 --> 00:01:48.626 A:middle
new feature of conditional

00:01:48.626 --> 00:01:49.586 A:middle
conformance, and how it

00:01:49.586 --> 00:01:50.576 A:middle
interacts with protocol

00:01:50.576 --> 00:01:51.176 A:middle
inheritance.

00:01:51.996 --> 00:01:53.356 A:middle
And finally, we're going to wrap

00:01:53.356 --> 00:01:55.486 A:middle
up with a discussion of classes

00:01:55.486 --> 00:01:56.206 A:middle
and generics.

00:01:58.556 --> 00:01:59.796 A:middle
So, why are generics such an

00:01:59.796 --> 00:02:01.026 A:middle
important part of Swift?


00:01:59.796 --> 00:02:01.026 A:middle
important part of Swift?

00:02:01.836 --> 00:02:03.236 A:middle
Well, one way of seeing the

00:02:03.236 --> 00:02:05.486 A:middle
impact is by designing a simple

00:02:05.486 --> 00:02:06.606 A:middle
collection, like type.

00:02:08.205 --> 00:02:09.666 A:middle
We'll call it buffer, and it's

00:02:09.666 --> 00:02:10.536 A:middle
going to be similar to the

00:02:10.536 --> 00:02:12.556 A:middle
standard library's array type.

00:02:12.876 --> 00:02:14.586 A:middle
Now, the simplest possible API

00:02:14.586 --> 00:02:15.856 A:middle
for the reading part of a buffer

00:02:15.856 --> 00:02:17.276 A:middle
might include a count of the

00:02:17.276 --> 00:02:19.136 A:middle
number of elements, and a way to

00:02:19.136 --> 00:02:20.386 A:middle
fetch each element to the given

00:02:20.386 --> 00:02:21.516 A:middle
position in the index.

00:02:22.086 --> 00:02:23.756 A:middle
But, what do we make that return

00:02:23.756 --> 00:02:24.016 A:middle
type?

00:02:24.916 --> 00:02:26.336 A:middle
Now, if we didn't have generics,

00:02:26.336 --> 00:02:28.136 A:middle
we'd have to make it some kind

00:02:28.136 --> 00:02:29.126 A:middle
of type that could represent

00:02:29.126 --> 00:02:30.556 A:middle
anything that we'd want to put

00:02:30.556 --> 00:02:31.376 A:middle
inside the buffer.

00:02:32.096 --> 00:02:33.986 A:middle
You can call that type ID, or

00:02:33.986 --> 00:02:35.226 A:middle
check, or void star.

00:02:35.506 --> 00:02:38.006 A:middle
In Swift we call it Any, which

00:02:38.006 --> 00:02:39.566 A:middle
is a type that can stand in for

00:02:39.566 --> 00:02:40.936 A:middle
any different kind of type in

00:02:40.936 --> 00:02:42.006 A:middle
Swift.

00:02:43.656 --> 00:02:45.116 A:middle
So, if you wanted to handle

00:02:45.116 --> 00:02:45.996 A:middle
anything in the buffer, you

00:02:45.996 --> 00:02:47.356 A:middle
could have subscript return an

00:02:47.356 --> 00:02:47.706 A:middle
Any.

00:02:48.086 --> 00:02:49.496 A:middle
But, of course, you probably

00:02:49.496 --> 00:02:50.466 A:middle
know that that leads to a really

00:02:50.466 --> 00:02:51.886 A:middle
unpleasant user experience.

00:02:52.136 --> 00:02:53.186 A:middle
At some point, you've got to get

00:02:53.186 --> 00:02:55.086 A:middle
out that type from inside the

00:02:55.086 --> 00:02:57.946 A:middle
box, in order to actually use

00:02:58.616 --> 00:02:58.686 A:middle
it.


00:03:00.526 --> 00:03:03.106 A:middle
And, this isn't just annoying,

00:03:03.106 --> 00:03:04.406 A:middle
it's also error-prone.

00:03:04.826 --> 00:03:05.856 A:middle
What if somewhere in your code,

00:03:05.856 --> 00:03:07.806 A:middle
maybe by accident, you put an

00:03:07.806 --> 00:03:09.226 A:middle
integer into what was supposed

00:03:09.226 --> 00:03:10.286 A:middle
to be a buffer of strings?

00:03:11.546 --> 00:03:13.926 A:middle
But, it's not just about ease of

00:03:13.926 --> 00:03:15.246 A:middle
use, we also want to solve some

00:03:15.246 --> 00:03:16.856 A:middle
problems relating to how these

00:03:16.856 --> 00:03:18.506 A:middle
values are represented in

00:03:18.506 --> 00:03:18.876 A:middle
memory.

00:03:19.566 --> 00:03:23.106 A:middle
Now, the ideal representation

00:03:23.326 --> 00:03:24.986 A:middle
for a buffer of strings, would

00:03:24.986 --> 00:03:26.716 A:middle
be a contiguous block of memory,

00:03:27.146 --> 00:03:28.936 A:middle
with every element held in line

00:03:28.936 --> 00:03:29.626 A:middle
next to each other.

00:03:30.626 --> 00:03:32.566 A:middle
But, with an untyped approach,

00:03:33.016 --> 00:03:34.076 A:middle
this doesn't work out quite so

00:03:34.076 --> 00:03:35.416 A:middle
well, because the buffer doesn't

00:03:35.416 --> 00:03:37.556 A:middle
know in advance what kind of

00:03:37.556 --> 00:03:38.766 A:middle
type it's going to contain.

00:03:38.766 --> 00:03:40.166 A:middle
And so, it has to use a type

00:03:40.496 --> 00:03:41.756 A:middle
like Any, that can account for

00:03:41.816 --> 00:03:42.936 A:middle
any of the possibilities.

00:03:43.256 --> 00:03:44.536 A:middle
And, there's a lot of overhead

00:03:44.776 --> 00:03:46.086 A:middle
in tracking, boxing, and

00:03:46.086 --> 00:03:50.456 A:middle
unboxing the types in that Any.

00:03:50.626 --> 00:03:52.436 A:middle
Here, I might have just wanted a

00:03:52.436 --> 00:03:54.246 A:middle
buffer of integers, but I have

00:03:54.246 --> 00:03:55.686 A:middle
no way of expressing that to the

00:03:55.686 --> 00:03:56.626 A:middle
compiler.

00:03:56.626 --> 00:03:57.616 A:middle
And so, I'm paying for

00:03:57.616 --> 00:03:59.176 A:middle
flexibility, even though I'm not

00:03:59.176 --> 00:04:01.216 A:middle
interested in it.


00:03:59.176 --> 00:04:01.216 A:middle
interested in it.

00:04:01.586 --> 00:04:02.976 A:middle
What's more, because Any has to

00:04:02.976 --> 00:04:04.526 A:middle
account for any different kind

00:04:04.526 --> 00:04:06.146 A:middle
of type, including types that

00:04:06.146 --> 00:04:08.466 A:middle
are too large to fit inside its

00:04:08.466 --> 00:04:10.666 A:middle
own internal storage, it has to

00:04:10.666 --> 00:04:11.866 A:middle
sometimes use indirection.

00:04:11.866 --> 00:04:13.456 A:middle
It has to hold a pointer to the

00:04:13.456 --> 00:04:14.886 A:middle
values, and that value could be

00:04:14.886 --> 00:04:16.555 A:middle
located all over memory.

00:04:17.896 --> 00:04:18.875 A:middle
And so, we really want to solve

00:04:18.875 --> 00:04:20.136 A:middle
these problems, not just for

00:04:20.136 --> 00:04:21.526 A:middle
ease of use and correctness, but

00:04:21.526 --> 00:04:23.556 A:middle
also for performance reasons.

00:04:24.496 --> 00:04:26.136 A:middle
And, we do it using a technique

00:04:26.816 --> 00:04:28.556 A:middle
called parametric polymorphism,

00:04:29.376 --> 00:04:30.606 A:middle
which is just another term for

00:04:30.606 --> 00:04:32.776 A:middle
what we in Swift refer to as

00:04:32.776 --> 00:04:33.446 A:middle
generics.

00:04:33.966 --> 00:04:36.466 A:middle
With a generic approach, we put

00:04:36.466 --> 00:04:38.336 A:middle
more information on the buffer,

00:04:38.336 --> 00:04:39.466 A:middle
to represent the type that the

00:04:39.466 --> 00:04:40.596 A:middle
buffer is going to contain.

00:04:41.746 --> 00:04:42.836 A:middle
We'll call that type Element.

00:04:44.196 --> 00:04:45.826 A:middle
Element is a generic parameter

00:04:45.826 --> 00:04:47.436 A:middle
of the type, hence the term of

00:04:47.436 --> 00:04:48.896 A:middle
parametric polymorphism.

00:04:49.436 --> 00:04:50.716 A:middle
You can think of it kind of like

00:04:50.716 --> 00:04:52.626 A:middle
a compile-time argument, that

00:04:52.626 --> 00:04:53.926 A:middle
tells the buffer what it's going

00:04:53.926 --> 00:04:54.396 A:middle
to contain.

00:04:55.706 --> 00:04:56.946 A:middle
Now it has a way of referring to

00:04:56.946 --> 00:04:57.706 A:middle
that element type.

00:04:57.976 --> 00:04:59.106 A:middle
It can use it wherever it was

00:04:59.146 --> 00:05:00.316 A:middle
previously using Any.


00:04:59.146 --> 00:05:00.316 A:middle
previously using Any.

00:05:00.906 --> 00:05:04.216 A:middle
And, that means that there's no

00:05:04.216 --> 00:05:05.476 A:middle
need to do conversions when

00:05:05.476 --> 00:05:06.416 A:middle
you're getting a type out of the

00:05:06.416 --> 00:05:06.696 A:middle
buffer.

00:05:07.016 --> 00:05:09.106 A:middle
And, if you make an accidental

00:05:09.296 --> 00:05:10.456 A:middle
assignment of the wrong kind of

00:05:10.456 --> 00:05:12.086 A:middle
type, or some issue similar to

00:05:12.086 --> 00:05:13.426 A:middle
that, the compiler will catch

00:05:13.426 --> 00:05:13.566 A:middle
you.

00:05:15.216 --> 00:05:17.136 A:middle
Now, now there's no such type as

00:05:17.136 --> 00:05:19.406 A:middle
buffer without an associated

00:05:19.406 --> 00:05:20.116 A:middle
element type.

00:05:20.836 --> 00:05:22.216 A:middle
If you try to declare a type

00:05:22.216 --> 00:05:23.636 A:middle
like that, you'll get a

00:05:23.636 --> 00:05:24.326 A:middle
compilation error.

00:05:25.456 --> 00:05:26.956 A:middle
You might find that slightly

00:05:26.956 --> 00:05:28.636 A:middle
surprising, because sometimes

00:05:28.636 --> 00:05:29.896 A:middle
you'll see that you can declare

00:05:29.896 --> 00:05:31.776 A:middle
types like buffer without any

00:05:31.776 --> 00:05:32.386 A:middle
element type.

00:05:33.206 --> 00:05:33.926 A:middle
But, that's just because the

00:05:33.926 --> 00:05:35.716 A:middle
compiler is able to infer what

00:05:35.716 --> 00:05:36.896 A:middle
the element type ought to be

00:05:37.206 --> 00:05:38.126 A:middle
from the context.

00:05:38.546 --> 00:05:39.716 A:middle
In this case, from the literals

00:05:39.716 --> 00:05:40.676 A:middle
on the right-hand side here.

00:05:41.686 --> 00:05:43.846 A:middle
The element is still there, it's

00:05:43.846 --> 00:05:44.566 A:middle
just implicit.

00:05:46.356 --> 00:05:48.046 A:middle
This knowledge of exactly what

00:05:48.126 --> 00:05:51.126 A:middle
type a type like buffer contains

00:05:51.446 --> 00:05:52.776 A:middle
is carried all the way through

00:05:52.776 --> 00:05:54.886 A:middle
both compile and runtime.

00:05:55.516 --> 00:05:57.926 A:middle
And, this means that we can

00:05:58.076 --> 00:05:59.576 A:middle
achieve our goal of holding all

00:05:59.576 --> 00:06:01.266 A:middle
of the elements in a contiguous


00:05:59.576 --> 00:06:01.266 A:middle
of the elements in a contiguous

00:06:01.306 --> 00:06:02.416 A:middle
block of memory, with no

00:06:02.416 --> 00:06:05.086 A:middle
overhead, even if those types

00:06:05.286 --> 00:06:06.526 A:middle
are arbitrarily large.

00:06:07.166 --> 00:06:09.866 A:middle
And, because the compiler has

00:06:10.816 --> 00:06:12.426 A:middle
direct knowledge at all times of

00:06:12.426 --> 00:06:14.546 A:middle
exactly what element type the

00:06:14.546 --> 00:06:16.206 A:middle
buffer contains, it has

00:06:16.206 --> 00:06:17.636 A:middle
optimization opportunities

00:06:17.726 --> 00:06:18.946 A:middle
available to it that it wouldn't

00:06:18.946 --> 00:06:19.646 A:middle
otherwise have.

00:06:20.296 --> 00:06:21.796 A:middle
So, in the case here, where I've

00:06:21.796 --> 00:06:24.496 A:middle
declared a buffer of integers, a

00:06:24.496 --> 00:06:25.686 A:middle
loop like this ought to be

00:06:25.686 --> 00:06:27.366 A:middle
compiled down to just a handful

00:06:27.366 --> 00:06:28.766 A:middle
of very efficient CPU

00:06:28.766 --> 00:06:29.436 A:middle
instructions.

00:06:29.656 --> 00:06:32.876 A:middle
Now, if you were writing a loop

00:06:32.876 --> 00:06:36.186 A:middle
like this, on a regular basis,

00:06:36.546 --> 00:06:37.826 A:middle
to sum up a buffer of integers,

00:06:38.006 --> 00:06:39.336 A:middle
it might make sense to extract

00:06:39.336 --> 00:06:40.776 A:middle
it out into a method.

00:06:41.456 --> 00:06:44.086 A:middle
An extension on buffer that's

00:06:44.086 --> 00:06:45.526 A:middle
more unit-testable, and more

00:06:45.526 --> 00:06:46.966 A:middle
readable when you actually call

00:06:47.026 --> 00:06:47.206 A:middle
it.

00:06:48.356 --> 00:06:49.326 A:middle
But, you probably know that if

00:06:49.326 --> 00:06:50.396 A:middle
you've written code like this,

00:06:50.706 --> 00:06:52.026 A:middle
you'll get a compilation issue,

00:06:52.516 --> 00:06:54.436 A:middle
because not all element types

00:06:55.186 --> 00:06:57.366 A:middle
can be summed up like this.

00:06:57.666 --> 00:06:58.916 A:middle
We need to tell the compiler

00:06:59.126 --> 00:07:01.506 A:middle
more about the capabilities the


00:06:59.126 --> 00:07:01.506 A:middle
more about the capabilities the

00:07:01.506 --> 00:07:03.646 A:middle
element needs to have, in order

00:07:03.646 --> 00:07:05.546 A:middle
to make this method available on

00:07:05.546 --> 00:07:05.886 A:middle
a buffer.

00:07:06.006 --> 00:07:08.816 A:middle
Now, the easiest way to do that

00:07:08.816 --> 00:07:10.626 A:middle
is by constraining the element

00:07:10.626 --> 00:07:12.456 A:middle
type to be a specific type like

00:07:12.456 --> 00:07:13.856 A:middle
the int from our original loop.

00:07:14.496 --> 00:07:18.366 A:middle
If you take this easy approach

00:07:18.366 --> 00:07:19.396 A:middle
to get up and running with your

00:07:19.396 --> 00:07:20.656 A:middle
extension, it's easy to

00:07:20.656 --> 00:07:22.346 A:middle
generalize it later, when you

00:07:22.346 --> 00:07:23.336 A:middle
find you need to do something

00:07:23.336 --> 00:07:24.796 A:middle
different, like sum up a buffer

00:07:24.796 --> 00:07:25.906 A:middle
of doubles, or floats.

00:07:26.966 --> 00:07:27.926 A:middle
Just look at the type that

00:07:28.246 --> 00:07:29.226 A:middle
you've constrained to.

00:07:29.226 --> 00:07:31.006 A:middle
Look at the protocols it

00:07:31.006 --> 00:07:32.636 A:middle
conforms to, and follow them up

00:07:32.696 --> 00:07:33.786 A:middle
until you get the most general

00:07:33.786 --> 00:07:35.126 A:middle
protocol that gives you

00:07:35.126 --> 00:07:36.166 A:middle
everything that you need to do

00:07:36.166 --> 00:07:36.626 A:middle
your work.

00:07:37.686 --> 00:07:39.206 A:middle
In this case, the numeric

00:07:39.206 --> 00:07:40.646 A:middle
protocol, which gives us the two

00:07:40.646 --> 00:07:41.756 A:middle
things we're relying on here,

00:07:42.486 --> 00:07:44.876 A:middle
the ability to create a new

00:07:44.876 --> 00:07:46.806 A:middle
element with a value of 0, and

00:07:46.806 --> 00:07:48.306 A:middle
the ability to add elements to

00:07:48.306 --> 00:07:49.876 A:middle
it, which come as part of the

00:07:49.876 --> 00:07:50.676 A:middle
numeric protocol.

00:07:50.936 --> 00:07:54.776 A:middle
Now, let's talk about that

00:07:54.776 --> 00:07:56.156 A:middle
process of factoring out

00:07:56.246 --> 00:07:58.496 A:middle
protocols from various types.

00:07:59.776 --> 00:08:01.076 A:middle
So, we've been talking about


00:07:59.776 --> 00:08:01.076 A:middle
So, we've been talking about

00:08:01.076 --> 00:08:03.016 A:middle
this buffer type, and we can

00:08:03.016 --> 00:08:04.366 A:middle
make it generic across different

00:08:04.366 --> 00:08:05.816 A:middle
elements, but what about writing

00:08:05.816 --> 00:08:07.816 A:middle
generic code that's generic in a

00:08:07.816 --> 00:08:08.596 A:middle
different direction?

00:08:09.196 --> 00:08:10.356 A:middle
Of writing code that works on

00:08:10.356 --> 00:08:11.236 A:middle
any different kind of

00:08:11.236 --> 00:08:11.716 A:middle
collection?

00:08:13.236 --> 00:08:14.946 A:middle
Such as an array that's very

00:08:14.946 --> 00:08:16.996 A:middle
similar to our buffer type, but

00:08:16.996 --> 00:08:18.966 A:middle
also more varied types, like a

00:08:18.966 --> 00:08:20.506 A:middle
dictionary that's a collection

00:08:20.506 --> 00:08:24.166 A:middle
of key value pairs, or maybe

00:08:24.166 --> 00:08:25.116 A:middle
types that aren't generic

00:08:25.116 --> 00:08:25.766 A:middle
[inaudible] the different

00:08:25.766 --> 00:08:27.656 A:middle
element types, like data or

00:08:27.656 --> 00:08:29.086 A:middle
string that returns specific

00:08:29.086 --> 00:08:29.746 A:middle
element types.

00:08:30.276 --> 00:08:33.256 A:middle
We want to create a protocol

00:08:33.256 --> 00:08:34.756 A:middle
that captures all of their

00:08:34.796 --> 00:08:36.025 A:middle
common capabilities.

00:08:37.106 --> 00:08:38.496 A:middle
We're going to create a cut

00:08:38.525 --> 00:08:40.236 A:middle
down, simplified version of the

00:08:40.236 --> 00:08:41.236 A:middle
standard library's own

00:08:41.236 --> 00:08:42.196 A:middle
collection protocol.

00:08:42.806 --> 00:08:46.926 A:middle
So, notice that we considered a

00:08:46.926 --> 00:08:49.256 A:middle
varied number of concrete types

00:08:49.256 --> 00:08:49.906 A:middle
first.

00:08:49.906 --> 00:08:51.806 A:middle
And now, we're thinking about a

00:08:51.806 --> 00:08:53.546 A:middle
kind of protocol that could join

00:08:53.546 --> 00:08:54.076 A:middle
them all together.

00:08:54.196 --> 00:08:55.656 A:middle
And, it's important to think of

00:08:55.656 --> 00:08:56.966 A:middle
things as this way around.

00:08:57.226 --> 00:08:58.726 A:middle
To start with some concrete

00:08:58.726 --> 00:09:00.566 A:middle
types, and then try and unify


00:08:58.726 --> 00:09:00.566 A:middle
types, and then try and unify

00:09:00.566 --> 00:09:01.816 A:middle
them with a protocol.

00:09:03.336 --> 00:09:04.176 A:middle
What do those types have in

00:09:04.176 --> 00:09:04.566 A:middle
common?

00:09:05.186 --> 00:09:06.456 A:middle
What don't they have in common?

00:09:07.356 --> 00:09:08.706 A:middle
When you're designing a protocol

00:09:08.706 --> 00:09:09.886 A:middle
like this, you can think of it

00:09:09.886 --> 00:09:11.246 A:middle
kind of like a contract

00:09:11.246 --> 00:09:11.966 A:middle
negotiation.

00:09:13.316 --> 00:09:14.666 A:middle
There's a natural push and pull

00:09:14.666 --> 00:09:16.426 A:middle
here, between conforming types

00:09:16.426 --> 00:09:18.106 A:middle
on the one hand, that want as

00:09:18.106 --> 00:09:20.266 A:middle
much flexibility as possible in

00:09:20.266 --> 00:09:22.896 A:middle
fulfilling that contract, and

00:09:23.326 --> 00:09:24.846 A:middle
users of the protocol, that want

00:09:24.846 --> 00:09:26.536 A:middle
a really nice, tight, simple

00:09:26.536 --> 00:09:28.716 A:middle
protocol in order to do their

00:09:28.716 --> 00:09:29.246 A:middle
extensions.

00:09:30.546 --> 00:09:32.196 A:middle
That's why it's really important

00:09:32.226 --> 00:09:33.776 A:middle
to have both a variety of

00:09:33.776 --> 00:09:35.006 A:middle
different possible conforming

00:09:35.006 --> 00:09:37.016 A:middle
types, and a number of different

00:09:37.016 --> 00:09:38.616 A:middle
use cases in mind when you're

00:09:38.616 --> 00:09:39.626 A:middle
designing your protocol.

00:09:40.276 --> 00:09:42.166 A:middle
Because it's a balancing act.

00:09:43.976 --> 00:09:45.716 A:middle
So, let's start to flesh out the

00:09:45.716 --> 00:09:46.546 A:middle
collection protocol.

00:09:46.726 --> 00:09:47.896 A:middle
So, first we need to represent

00:09:47.896 --> 00:09:48.616 A:middle
the element type.

00:09:49.036 --> 00:09:50.236 A:middle
Now, in protocols, we use an

00:09:50.236 --> 00:09:51.666 A:middle
associated type for that.

00:09:52.956 --> 00:09:54.356 A:middle
Each conforming type needs to

00:09:54.356 --> 00:09:55.906 A:middle
set element to be something

00:09:55.906 --> 00:09:56.476 A:middle
appropriate.

00:09:56.936 --> 00:09:59.096 A:middle
In the case of buffer, or array,

00:09:59.586 --> 00:10:01.606 A:middle
as of Swift 4.2, this happens


00:09:59.586 --> 00:10:01.606 A:middle
as of Swift 4.2, this happens

00:10:01.606 --> 00:10:01.976 A:middle
automatically.

00:10:02.256 --> 00:10:04.416 A:middle
Because we also named their

00:10:04.416 --> 00:10:06.016 A:middle
generic parameters to be element

00:10:06.016 --> 00:10:06.416 A:middle
as well.

00:10:07.436 --> 00:10:09.136 A:middle
This is a nice side benefit of

00:10:09.136 --> 00:10:10.356 A:middle
giving your generic arguments

00:10:10.466 --> 00:10:11.856 A:middle
meaningful names that follow

00:10:11.856 --> 00:10:13.816 A:middle
common conventions like the word

00:10:13.816 --> 00:10:16.406 A:middle
element, rather than giving them

00:10:16.406 --> 00:10:17.856 A:middle
something arbitrary like T that

00:10:17.856 --> 00:10:19.246 A:middle
you'd have to separately state

00:10:19.246 --> 00:10:20.686 A:middle
was the element type.

00:10:21.776 --> 00:10:23.296 A:middle
For other data types, you might

00:10:23.296 --> 00:10:24.186 A:middle
need to do something slightly

00:10:24.186 --> 00:10:25.386 A:middle
more specific, for example, a

00:10:25.386 --> 00:10:26.526 A:middle
dictionary needs to set the

00:10:26.526 --> 00:10:28.126 A:middle
element type to be the pair of

00:10:28.126 --> 00:10:29.276 A:middle
its key and value type.

00:10:29.726 --> 00:10:33.486 A:middle
Next, let's talk about adding

00:10:33.486 --> 00:10:34.646 A:middle
the subscript operation.

00:10:35.896 --> 00:10:37.026 A:middle
Now, if we were talking about

00:10:37.156 --> 00:10:38.566 A:middle
just a protocol for types like

00:10:38.626 --> 00:10:40.266 A:middle
array, we might be tempted to

00:10:40.366 --> 00:10:42.576 A:middle
have subscripts take an int as

00:10:42.576 --> 00:10:43.146 A:middle
its argument.

00:10:43.786 --> 00:10:46.736 A:middle
But, making subscript take an

00:10:46.736 --> 00:10:49.006 A:middle
int would imply a very strong

00:10:49.006 --> 00:10:49.556 A:middle
contract.

00:10:50.936 --> 00:10:52.466 A:middle
Every conforming type would have

00:10:52.586 --> 00:10:54.536 A:middle
to supply the ability to fetch

00:10:54.536 --> 00:10:55.756 A:middle
an element's given position that

00:10:55.756 --> 00:10:57.396 A:middle
was represented by an integer.

00:10:58.046 --> 00:10:59.836 A:middle
And, that works great for types


00:11:00.086 --> 00:11:00.716 A:middle
like array.

00:11:01.596 --> 00:11:03.526 A:middle
It's also definitely easy for

00:11:03.526 --> 00:11:05.116 A:middle
users of protocol to understand.

00:11:06.186 --> 00:11:07.296 A:middle
But, is it flexible enough for a

00:11:07.296 --> 00:11:08.526 A:middle
slightly more complicated type,

00:11:08.626 --> 00:11:09.496 A:middle
like a dictionary?

00:11:11.156 --> 00:11:13.636 A:middle
Now, no matter how you model it,

00:11:13.866 --> 00:11:15.256 A:middle
a dictionary's probably going to

00:11:15.256 --> 00:11:16.386 A:middle
be backed by some fairly

00:11:16.386 --> 00:11:17.746 A:middle
complicated internal data

00:11:17.746 --> 00:11:19.426 A:middle
structure that has specific

00:11:19.426 --> 00:11:20.506 A:middle
logic for moving from one

00:11:20.506 --> 00:11:21.916 A:middle
element to the next.

00:11:22.586 --> 00:11:24.146 A:middle
For example, it could be backed

00:11:24.276 --> 00:11:26.046 A:middle
by an internal buffer of some

00:11:26.046 --> 00:11:29.096 A:middle
kind, and it could use an index

00:11:29.096 --> 00:11:30.736 A:middle
type that stored an offset into

00:11:30.736 --> 00:11:32.476 A:middle
that buffer, that it could then

00:11:32.476 --> 00:11:33.746 A:middle
take as the argument to

00:11:33.746 --> 00:11:34.986 A:middle
subscript in order to fetch an

00:11:34.986 --> 00:11:36.896 A:middle
element to position, using that

00:11:36.896 --> 00:11:37.336 A:middle
offset.

00:11:38.166 --> 00:11:39.746 A:middle
But, it would be critical that

00:11:39.746 --> 00:11:41.496 A:middle
the dictionary's index type be

00:11:41.496 --> 00:11:43.116 A:middle
an opaque type that only the

00:11:43.116 --> 00:11:44.416 A:middle
dictionary can control.

00:11:44.876 --> 00:11:45.866 A:middle
You wouldn't want somebody

00:11:45.866 --> 00:11:47.506 A:middle
necessarily just adding 1 to

00:11:47.506 --> 00:11:48.036 A:middle
your offset.

00:11:48.306 --> 00:11:49.176 A:middle
That wouldn't necessarily move

00:11:49.176 --> 00:11:50.076 A:middle
to the next element in the

00:11:50.076 --> 00:11:50.576 A:middle
dictionary.

00:11:51.056 --> 00:11:52.466 A:middle
It could move some arbitrary,

00:11:52.466 --> 00:11:54.206 A:middle
maybe uninitialized part of the

00:11:54.206 --> 00:11:55.706 A:middle
dictionary's internal storage.

00:11:56.826 --> 00:11:57.936 A:middle
So, instead we want the

00:11:57.936 --> 00:12:00.496 A:middle
dictionary to control moving


00:11:57.936 --> 00:12:00.496 A:middle
dictionary to control moving

00:12:00.496 --> 00:12:02.126 A:middle
forward through the collection

00:12:02.126 --> 00:12:03.346 A:middle
by advancing the index.

00:12:04.096 --> 00:12:05.356 A:middle
And so, to do that we add

00:12:05.356 --> 00:12:07.396 A:middle
another method that given an

00:12:07.396 --> 00:12:09.286 A:middle
index, gives you the index that

00:12:09.286 --> 00:12:12.256 A:middle
marks the position after it.

00:12:12.506 --> 00:12:13.386 A:middle
Once you take this step, you

00:12:13.386 --> 00:12:14.376 A:middle
need a couple more things.

00:12:14.376 --> 00:12:15.806 A:middle
You need a start index property,

00:12:16.126 --> 00:12:17.706 A:middle
and an end index property.

00:12:18.226 --> 00:12:19.356 A:middle
Because a simple count isn't

00:12:19.356 --> 00:12:20.356 A:middle
going to work anymore in order

00:12:20.356 --> 00:12:21.346 A:middle
to tell us that we've reached

00:12:21.346 --> 00:12:21.766 A:middle
the end.

00:12:21.896 --> 00:12:24.056 A:middle
Now that we're not using ints as

00:12:24.056 --> 00:12:25.486 A:middle
our index type.

00:12:26.036 --> 00:12:27.466 A:middle
So, let's bring those back to

00:12:27.466 --> 00:12:28.466 A:middle
the collection protocol.

00:12:30.086 --> 00:12:31.606 A:middle
So, we've got a subscript that

00:12:31.606 --> 00:12:33.136 A:middle
takes some index type to

00:12:33.136 --> 00:12:34.396 A:middle
represent a position, and gives

00:12:34.396 --> 00:12:35.046 A:middle
you an element there.

00:12:35.636 --> 00:12:36.966 A:middle
And, we've got a way of moving

00:12:36.966 --> 00:12:37.916 A:middle
that position forward.

00:12:38.406 --> 00:12:40.686 A:middle
But, we also need types to

00:12:40.686 --> 00:12:42.086 A:middle
supply what kind of type they're

00:12:42.086 --> 00:12:43.586 A:middle
going to use for their index.

00:12:43.816 --> 00:12:44.946 A:middle
We do that with another

00:12:44.946 --> 00:12:46.526 A:middle
associated type.

00:12:47.576 --> 00:12:49.436 A:middle
Conforming types would supply

00:12:50.046 --> 00:12:51.156 A:middle
the appropriate types, so an

00:12:51.156 --> 00:12:53.316 A:middle
array or a data would give an

00:12:53.316 --> 00:12:55.416 A:middle
int as their index type, whereas

00:12:55.416 --> 00:12:56.856 A:middle
a dictionary would give its own

00:12:56.976 --> 00:12:58.096 A:middle
custom implementation that

00:12:58.096 --> 00:12:58.966 A:middle
handles its own internal logic.


00:13:04.306 --> 00:13:05.956 A:middle
So, let's go back to count that

00:13:05.956 --> 00:13:07.456 A:middle
we dropped a minute ago in order

00:13:07.456 --> 00:13:09.106 A:middle
to generalize our indexing

00:13:09.106 --> 00:13:09.386 A:middle
model.

00:13:09.536 --> 00:13:10.636 A:middle
It's still a really useful

00:13:10.636 --> 00:13:11.396 A:middle
property to have.

00:13:11.396 --> 00:13:12.916 A:middle
So, we probably want to add it

00:13:12.916 --> 00:13:15.396 A:middle
back as an extension on

00:13:15.396 --> 00:13:15.856 A:middle
collection.

00:13:16.656 --> 00:13:18.816 A:middle
Something that walks over the

00:13:18.816 --> 00:13:20.316 A:middle
collection, moving the index

00:13:20.316 --> 00:13:22.246 A:middle
forward, incrementing a counter

00:13:22.806 --> 00:13:23.376 A:middle
that it then returns.

00:13:23.376 --> 00:13:27.426 A:middle
Now, if we try and implement

00:13:27.426 --> 00:13:28.886 A:middle
this, we had another missing

00:13:28.886 --> 00:13:29.406 A:middle
requirement.

00:13:30.346 --> 00:13:31.886 A:middle
Since we moved off of int to a

00:13:31.886 --> 00:13:33.746 A:middle
general index type, we can no

00:13:33.746 --> 00:13:35.626 A:middle
longer assume that the index

00:13:35.626 --> 00:13:36.596 A:middle
type was equatable.

00:13:37.526 --> 00:13:39.326 A:middle
Ints are, but arbitrary index

00:13:39.326 --> 00:13:40.306 A:middle
types aren't necessarily.

00:13:40.386 --> 00:13:42.646 A:middle
And, we need that in order to

00:13:42.646 --> 00:13:43.936 A:middle
know that we've reached the end.

00:13:45.226 --> 00:13:47.216 A:middle
Now, we could solve this in the

00:13:47.216 --> 00:13:48.856 A:middle
same way that we did earlier, of

00:13:49.316 --> 00:13:50.636 A:middle
constraining our extension,

00:13:50.706 --> 00:13:52.036 A:middle
saying that it only works when

00:13:52.036 --> 00:13:53.486 A:middle
the index type is equatable.

00:13:54.706 --> 00:13:55.956 A:middle
But, that doesn't feel right.

00:13:57.456 --> 00:13:59.006 A:middle
We want a protocol to be easy to

00:13:59.006 --> 00:14:01.156 A:middle
use, and it's going to get


00:13:59.006 --> 00:14:01.156 A:middle
use, and it's going to get

00:14:01.156 --> 00:14:02.736 A:middle
really irritating, if we have to

00:14:02.736 --> 00:14:04.276 A:middle
always, on every extension we

00:14:04.276 --> 00:14:06.696 A:middle
write, put this constraint on

00:14:06.696 --> 00:14:06.886 A:middle
there.

00:14:06.886 --> 00:14:07.666 A:middle
Because we're nearly always

00:14:07.666 --> 00:14:08.396 A:middle
going to need to be able to

00:14:08.396 --> 00:14:09.396 A:middle
compare two indexes.

00:14:10.016 --> 00:14:11.296 A:middle
Instead, it's probably better

00:14:11.296 --> 00:14:13.556 A:middle
expressed as a requirement of

00:14:13.556 --> 00:14:17.676 A:middle
the protocol, as a constraint on

00:14:17.676 --> 00:14:19.016 A:middle
our index associated type.

00:14:20.136 --> 00:14:21.406 A:middle
Putting this constraint on the

00:14:21.406 --> 00:14:23.246 A:middle
protocol means that all types

00:14:23.246 --> 00:14:24.226 A:middle
that conform to the protocol

00:14:24.226 --> 00:14:26.266 A:middle
need to supply an equatable type

00:14:26.266 --> 00:14:27.036 A:middle
for their index.

00:14:28.626 --> 00:14:30.026 A:middle
That way you don't have to

00:14:30.076 --> 00:14:31.426 A:middle
specify it every time you write

00:14:31.426 --> 00:14:32.026 A:middle
the extension.

00:14:33.476 --> 00:14:35.806 A:middle
This is another example of

00:14:35.806 --> 00:14:36.936 A:middle
negotiating the protocol

00:14:36.936 --> 00:14:37.386 A:middle
contract.

00:14:38.806 --> 00:14:39.946 A:middle
Users of the protocol had a

00:14:39.946 --> 00:14:41.306 A:middle
requirement that they really

00:14:41.306 --> 00:14:42.406 A:middle
needed to be able to compare

00:14:42.406 --> 00:14:42.936 A:middle
indexes.

00:14:43.666 --> 00:14:45.876 A:middle
And, conforming types, they did

00:14:45.876 --> 00:14:47.226 A:middle
a check that they can reasonably

00:14:47.226 --> 00:14:48.186 A:middle
accommodate that without giving

00:14:48.186 --> 00:14:49.566 A:middle
up too much flexibility.

00:14:50.726 --> 00:14:52.116 A:middle
In this case, they definitely

00:14:52.116 --> 00:14:52.516 A:middle
can.

00:14:53.446 --> 00:14:54.976 A:middle
Ints, the data, and array are

00:14:54.976 --> 00:14:56.236 A:middle
using are already equatable.

00:14:56.316 --> 00:14:57.986 A:middle
And, with Swift 4.2's new

00:14:57.986 --> 00:14:59.646 A:middle
automatic synthesis of equatable

00:14:59.646 --> 00:15:01.826 A:middle
conformance, it's easy for


00:14:59.646 --> 00:15:01.826 A:middle
conformance, it's easy for

00:15:01.826 --> 00:15:02.926 A:middle
dictionary to make its index

00:15:02.956 --> 00:15:06.806 A:middle
type equatable as well.

00:15:07.346 --> 00:15:08.096 A:middle
Next, let's talk about

00:15:08.226 --> 00:15:10.246 A:middle
optimizing this count operation

00:15:10.426 --> 00:15:14.216 A:middle
with a customization point.

00:15:14.416 --> 00:15:16.456 A:middle
So, we've written a version of

00:15:16.456 --> 00:15:19.126 A:middle
count, that calculates the

00:15:19.126 --> 00:15:19.886 A:middle
number of elements in the

00:15:19.886 --> 00:15:21.446 A:middle
collection by walking over the

00:15:21.446 --> 00:15:22.356 A:middle
entire collection.

00:15:22.356 --> 00:15:23.186 A:middle
But, obviously a lot of

00:15:23.186 --> 00:15:24.846 A:middle
collections can probably do that

00:15:24.846 --> 00:15:25.476 A:middle
a lot faster.

00:15:25.476 --> 00:15:27.586 A:middle
For example, supposing a

00:15:27.586 --> 00:15:29.736 A:middle
dictionary kept internally a

00:15:29.736 --> 00:15:30.946 A:middle
count of the number of elements

00:15:30.946 --> 00:15:32.516 A:middle
it held, for its own purposes.

00:15:33.256 --> 00:15:34.946 A:middle
If it has this information, it

00:15:34.946 --> 00:15:36.376 A:middle
can just serve it up in its own

00:15:36.376 --> 00:15:37.416 A:middle
implementation of count.

00:15:38.666 --> 00:15:40.396 A:middle
That means that when people call

00:15:40.396 --> 00:15:41.706 A:middle
count on a dictionary, they're

00:15:42.036 --> 00:15:43.676 A:middle
getting fast constant time,

00:15:44.106 --> 00:15:45.416 A:middle
instead of the linear time that

00:15:45.416 --> 00:15:47.106 A:middle
our original version that works

00:15:47.106 --> 00:15:48.256 A:middle
with any collection takes.

00:15:49.116 --> 00:15:51.296 A:middle
But, when adding optimizations

00:15:51.296 --> 00:15:52.196 A:middle
like this, there's something you

00:15:52.196 --> 00:15:53.166 A:middle
need to be aware of, which is

00:15:53.166 --> 00:15:54.386 A:middle
the difference between

00:15:54.386 --> 00:15:55.476 A:middle
fulfilling protocol

00:15:55.476 --> 00:15:57.496 A:middle
requirements, and just adding

00:15:57.496 --> 00:15:59.526 A:middle
lots of overloads onto specific

00:15:59.526 --> 00:16:00.076 A:middle
types.


00:15:59.526 --> 00:16:00.076 A:middle
types.

00:16:00.866 --> 00:16:03.526 A:middle
Up until now, this new version

00:16:03.526 --> 00:16:04.966 A:middle
of count on dictionary is just

00:16:05.076 --> 00:16:05.716 A:middle
an overload.

00:16:05.796 --> 00:16:07.626 A:middle
That means that when you have a

00:16:07.626 --> 00:16:09.436 A:middle
dictionary, and you know it's a

00:16:09.436 --> 00:16:11.096 A:middle
dictionary, you'll get the

00:16:11.096 --> 00:16:12.446 A:middle
newer, better version of count.

00:16:13.226 --> 00:16:14.326 A:middle
But, what about calling it

00:16:14.326 --> 00:16:15.886 A:middle
inside a generic algorithm?

00:16:17.816 --> 00:16:19.806 A:middle
So, supposing we wanted, for

00:16:19.806 --> 00:16:21.206 A:middle
example, to write a version of

00:16:21.206 --> 00:16:22.466 A:middle
the standard library's map?

00:16:23.116 --> 00:16:24.086 A:middle
If you're not already familiar

00:16:24.086 --> 00:16:25.666 A:middle
with it, it's a really useful

00:16:25.666 --> 00:16:28.186 A:middle
operation that transforms each

00:16:28.226 --> 00:16:29.786 A:middle
element in the collection, and

00:16:29.786 --> 00:16:31.246 A:middle
gives it back to you as a new

00:16:31.246 --> 00:16:31.516 A:middle
array.

00:16:32.196 --> 00:16:34.216 A:middle
The implementation's pretty

00:16:34.216 --> 00:16:34.576 A:middle
simple.

00:16:35.036 --> 00:16:36.686 A:middle
It just creates a new array,

00:16:37.486 --> 00:16:38.466 A:middle
moves over the collection,

00:16:39.056 --> 00:16:40.506 A:middle
transforms each element, and

00:16:40.506 --> 00:16:41.536 A:middle
then appends it to the array.

00:16:42.906 --> 00:16:44.566 A:middle
Now, as you append elements to

00:16:44.566 --> 00:16:46.606 A:middle
an array like this, the array

00:16:46.606 --> 00:16:47.856 A:middle
automatically grows.

00:16:48.626 --> 00:16:50.476 A:middle
And, as it grows it needs

00:16:50.476 --> 00:16:52.196 A:middle
sometimes to reallocate its

00:16:52.196 --> 00:16:53.556 A:middle
internal storage in order to

00:16:53.556 --> 00:16:54.906 A:middle
make more room to accommodate

00:16:54.906 --> 00:16:55.576 A:middle
the new elements.

00:16:56.256 --> 00:16:57.586 A:middle
In a loop like this, it might

00:16:57.586 --> 00:16:59.276 A:middle
have to do that multiple times

00:16:59.276 --> 00:17:00.356 A:middle
over, depending on how big it


00:16:59.276 --> 00:17:00.356 A:middle
over, depending on how big it

00:17:00.356 --> 00:17:00.606 A:middle
gets.

00:17:01.336 --> 00:17:02.696 A:middle
And, doing that takes time.

00:17:03.006 --> 00:17:04.715 A:middle
Allocating memory can be fairly

00:17:04.715 --> 00:17:05.256 A:middle
expensive.

00:17:06.396 --> 00:17:07.996 A:middle
There's a nice optimization

00:17:07.996 --> 00:17:09.106 A:middle
trick we can do with this

00:17:09.106 --> 00:17:09.766 A:middle
implementation.

00:17:10.606 --> 00:17:12.346 A:middle
We already know exactly how big

00:17:12.636 --> 00:17:13.986 A:middle
the final array it going to be.

00:17:14.016 --> 00:17:15.396 A:middle
It's going to be exactly the

00:17:15.396 --> 00:17:16.945 A:middle
same size as our original

00:17:16.945 --> 00:17:17.425 A:middle
collection.

00:17:18.445 --> 00:17:20.836 A:middle
So, we could reserve exactly the

00:17:20.836 --> 00:17:22.866 A:middle
right amount of space in the

00:17:22.866 --> 00:17:24.486 A:middle
array up front, before we start

00:17:24.486 --> 00:17:26.435 A:middle
appending to it, which is a nice

00:17:26.435 --> 00:17:26.806 A:middle
speed-up.

00:17:26.996 --> 00:17:29.106 A:middle
And, to do this, we're calling

00:17:29.196 --> 00:17:29.576 A:middle
count.

00:17:30.726 --> 00:17:32.466 A:middle
But, we're calling count here,

00:17:32.466 --> 00:17:34.226 A:middle
in what's referred to as a

00:17:34.226 --> 00:17:35.466 A:middle
generic context.

00:17:35.886 --> 00:17:37.976 A:middle
That is, a context where the

00:17:37.976 --> 00:17:39.256 A:middle
collection type is completely

00:17:39.256 --> 00:17:40.626 A:middle
generic, not specific.

00:17:40.626 --> 00:17:41.816 A:middle
It could be an array, or a

00:17:41.816 --> 00:17:42.756 A:middle
dictionary, or a [inaudible]

00:17:42.756 --> 00:17:43.686 A:middle
list, or anything.

00:17:44.486 --> 00:17:46.276 A:middle
So, we can't know that it

00:17:46.276 --> 00:17:48.156 A:middle
necessarily has a better

00:17:48.156 --> 00:17:49.396 A:middle
implementation of count

00:17:49.396 --> 00:17:50.536 A:middle
available to it, when the

00:17:50.536 --> 00:17:51.976 A:middle
compiler compiles this code.

00:17:52.726 --> 00:17:55.316 A:middle
And so, in this case, the

00:17:55.316 --> 00:17:56.376 A:middle
version of count that's going to

00:17:56.376 --> 00:17:57.966 A:middle
be called is actually the

00:17:57.966 --> 00:17:59.346 A:middle
general version of count, that

00:17:59.346 --> 00:18:01.086 A:middle
works on any collection and


00:17:59.346 --> 00:18:01.086 A:middle
works on any collection and

00:18:01.086 --> 00:18:02.256 A:middle
iterates over the entire

00:18:02.256 --> 00:18:02.726 A:middle
collection.

00:18:03.466 --> 00:18:04.536 A:middle
If you called map on a

00:18:04.536 --> 00:18:06.496 A:middle
dictionary, it wouldn't call the

00:18:06.496 --> 00:18:07.436 A:middle
better version of count that

00:18:07.436 --> 00:18:09.306 A:middle
we've just written yet.

00:18:09.896 --> 00:18:13.316 A:middle
In order for customized method

00:18:13.316 --> 00:18:15.386 A:middle
or property like this to be

00:18:15.386 --> 00:18:18.536 A:middle
called in a generic context, it

00:18:18.646 --> 00:18:19.886 A:middle
needs to be declared as a

00:18:19.886 --> 00:18:21.436 A:middle
requirement on the protocol

00:18:21.436 --> 00:18:22.026 A:middle
itself.

00:18:22.516 --> 00:18:24.256 A:middle
We've established that there's

00:18:24.256 --> 00:18:26.166 A:middle
definitely a way in which

00:18:26.166 --> 00:18:27.576 A:middle
certain collections could

00:18:27.576 --> 00:18:28.826 A:middle
provide an optimized version of

00:18:28.826 --> 00:18:30.806 A:middle
count, so it makes sense to add

00:18:30.806 --> 00:18:32.566 A:middle
it as a requirement on the

00:18:32.566 --> 00:18:33.086 A:middle
protocol.

00:18:34.446 --> 00:18:36.386 A:middle
Now, even though we've made it a

00:18:36.386 --> 00:18:40.036 A:middle
requirement to implement it, all

00:18:40.036 --> 00:18:41.346 A:middle
collections don't have to

00:18:41.346 --> 00:18:42.066 A:middle
provide their own

00:18:42.066 --> 00:18:43.246 A:middle
implementation, because we've

00:18:43.246 --> 00:18:45.246 A:middle
already provided one via our

00:18:45.246 --> 00:18:46.576 A:middle
extension that will work on any

00:18:46.576 --> 00:18:47.066 A:middle
collection.

00:18:48.306 --> 00:18:49.776 A:middle
Adding a requirement to the

00:18:49.776 --> 00:18:51.856 A:middle
protocol, and alongside it

00:18:51.856 --> 00:18:53.516 A:middle
adding a default implementation

00:18:53.736 --> 00:18:55.576 A:middle
via an extension is what we

00:18:55.576 --> 00:18:57.696 A:middle
refer to as a customization

00:18:57.696 --> 00:18:57.996 A:middle
point.

00:18:58.586 --> 00:19:01.456 A:middle
With a customization point, the


00:18:58.586 --> 00:19:01.456 A:middle
With a customization point, the

00:19:01.456 --> 00:19:03.126 A:middle
compiler can know that there's

00:19:03.126 --> 00:19:04.286 A:middle
potentially a better

00:19:04.286 --> 00:19:06.026 A:middle
implementation of a method or

00:19:06.026 --> 00:19:07.516 A:middle
property available to it, and

00:19:07.516 --> 00:19:09.956 A:middle
so, in a generic context, it

00:19:09.956 --> 00:19:11.896 A:middle
dynamically dispatches to that

00:19:11.896 --> 00:19:13.416 A:middle
implementation through the

00:19:13.416 --> 00:19:13.896 A:middle
protocol.

00:19:15.336 --> 00:19:17.406 A:middle
So now, if you call map on a

00:19:17.406 --> 00:19:18.856 A:middle
dictionary, even though it's a

00:19:18.856 --> 00:19:20.706 A:middle
completely generic function, you

00:19:20.706 --> 00:19:21.406 A:middle
will get the better

00:19:21.406 --> 00:19:22.456 A:middle
implementation of count.

00:19:23.726 --> 00:19:26.086 A:middle
Adding customization points like

00:19:26.086 --> 00:19:27.736 A:middle
this, alongside default

00:19:27.736 --> 00:19:28.756 A:middle
implementations through

00:19:28.756 --> 00:19:31.266 A:middle
extensions is a really powerful

00:19:31.266 --> 00:19:32.476 A:middle
way of getting the same kind of

00:19:32.476 --> 00:19:34.236 A:middle
benefit that you can also get

00:19:34.236 --> 00:19:35.976 A:middle
with classes, implementation

00:19:35.976 --> 00:19:37.086 A:middle
inheritance, and method

00:19:37.086 --> 00:19:37.626 A:middle
overwriting.

00:19:38.366 --> 00:19:39.686 A:middle
But, this technique works on

00:19:39.686 --> 00:19:41.916 A:middle
structs and enums, as well as

00:19:41.916 --> 00:19:42.326 A:middle
classes.

00:19:45.356 --> 00:19:47.386 A:middle
Now, not every method can be

00:19:47.386 --> 00:19:48.476 A:middle
optimized like this.

00:19:49.026 --> 00:19:51.016 A:middle
And, customization points have a

00:19:51.016 --> 00:19:53.146 A:middle
small but non-zero impact on

00:19:53.146 --> 00:19:55.006 A:middle
your binary size, your compiler

00:19:55.056 --> 00:19:55.986 A:middle
runtime performance.

00:19:56.206 --> 00:19:57.656 A:middle
So, it only makes sense to add

00:19:57.656 --> 00:19:59.506 A:middle
customization points when

00:19:59.506 --> 00:20:00.036 A:middle
there's definitely an


00:19:59.506 --> 00:20:00.036 A:middle
there's definitely an

00:20:00.036 --> 00:20:00.976 A:middle
opportunity for customization.

00:20:02.256 --> 00:20:03.596 A:middle
For example, in the map

00:20:03.596 --> 00:20:05.006 A:middle
operation that we just wrote,

00:20:05.446 --> 00:20:06.826 A:middle
there's no reasonable way in

00:20:06.826 --> 00:20:08.026 A:middle
which any different kind of

00:20:08.026 --> 00:20:09.496 A:middle
collection could actually

00:20:09.496 --> 00:20:11.436 A:middle
provide a better implementation.

00:20:11.956 --> 00:20:13.116 A:middle
And so, it doesn't make sense to

00:20:13.116 --> 00:20:14.636 A:middle
add it as a customization point.

00:20:15.056 --> 00:20:16.256 A:middle
It can just stay as an

00:20:16.286 --> 00:20:16.926 A:middle
extension.

00:20:18.396 --> 00:20:19.756 A:middle
So, we've created this

00:20:19.756 --> 00:20:20.976 A:middle
collection type, and it's

00:20:20.976 --> 00:20:21.976 A:middle
actually pretty fully-featured

00:20:21.976 --> 00:20:22.166 A:middle
now.

00:20:22.166 --> 00:20:23.016 A:middle
It has lots of different

00:20:23.696 --> 00:20:25.426 A:middle
conforming types possible, and

00:20:25.426 --> 00:20:26.456 A:middle
various different useful

00:20:26.456 --> 00:20:28.406 A:middle
algorithms you can write for it.

00:20:28.616 --> 00:20:30.016 A:middle
But, sometimes you need more

00:20:30.016 --> 00:20:31.696 A:middle
than just a single protocol in

00:20:31.696 --> 00:20:33.116 A:middle
order to categorize your family

00:20:33.116 --> 00:20:33.696 A:middle
of types.

00:20:34.646 --> 00:20:36.356 A:middle
You need protocol inheritance.

00:20:36.656 --> 00:20:37.726 A:middle
And, to talk to you more about

00:20:37.726 --> 00:20:38.936 A:middle
that, here's Doug.

00:20:39.516 --> 00:20:45.586 A:middle
[ Applause ]

00:20:46.086 --> 00:20:46.706 A:middle
Thank you, Ben.

00:20:47.936 --> 00:20:49.846 A:middle
So, protocol inheritance has

00:20:49.896 --> 00:20:50.976 A:middle
been around since the beginning

00:20:50.976 --> 00:20:51.416 A:middle
of Swift.

00:20:52.336 --> 00:20:53.766 A:middle
And, to think about where we

00:20:53.766 --> 00:20:55.256 A:middle
need protocol inheritance, let's

00:20:55.256 --> 00:20:56.446 A:middle
go look at this collection

00:20:56.446 --> 00:20:57.206 A:middle
protocol that we've been

00:20:57.206 --> 00:20:57.596 A:middle
building.

00:20:58.276 --> 00:20:59.126 A:middle
It's a nice protocol.

00:20:59.126 --> 00:20:59.906 A:middle
It's well-designed.


00:21:00.576 --> 00:21:02.146 A:middle
It describes a set of conforming

00:21:02.146 --> 00:21:03.966 A:middle
types, and gives you the ability

00:21:03.966 --> 00:21:05.136 A:middle
to write interesting generic

00:21:05.136 --> 00:21:05.996 A:middle
algorithms on them.

00:21:06.736 --> 00:21:07.756 A:middle
But, we don't have to reach very

00:21:07.756 --> 00:21:09.316 A:middle
far to find other

00:21:09.316 --> 00:21:10.906 A:middle
collection-like algorithms that

00:21:10.906 --> 00:21:12.896 A:middle
we cannot implement in terms of

00:21:12.896 --> 00:21:14.186 A:middle
the collection protocol thus

00:21:14.186 --> 00:21:14.556 A:middle
far.

00:21:15.226 --> 00:21:16.466 A:middle
For example, if we want to find

00:21:16.466 --> 00:21:18.416 A:middle
the index of the last element in

00:21:18.416 --> 00:21:20.026 A:middle
a collection, that matches some

00:21:20.026 --> 00:21:21.696 A:middle
predicate, the best way to do

00:21:21.696 --> 00:21:22.746 A:middle
that would be to start at the

00:21:22.746 --> 00:21:24.426 A:middle
end, and walk backwards.

00:21:25.096 --> 00:21:26.086 A:middle
Collection protocol doesn't let

00:21:26.086 --> 00:21:26.636 A:middle
us do that.

00:21:27.916 --> 00:21:29.256 A:middle
Or, say we want to build a

00:21:29.256 --> 00:21:30.616 A:middle
shuffle operation to randomly

00:21:30.616 --> 00:21:31.716 A:middle
shuffle around the elements in a

00:21:31.716 --> 00:21:32.246 A:middle
collection.

00:21:32.856 --> 00:21:34.146 A:middle
Well, that requires mutation,

00:21:34.146 --> 00:21:35.316 A:middle
and collection doesn't do that.

00:21:35.696 --> 00:21:37.016 A:middle
Now it's not that the collection

00:21:37.016 --> 00:21:40.246 A:middle
protocol is wrong, but it's that

00:21:40.246 --> 00:21:41.856 A:middle
we need something more to

00:21:41.856 --> 00:21:42.936 A:middle
describe these additional

00:21:42.936 --> 00:21:45.166 A:middle
generic algorithms, and that is

00:21:45.196 --> 00:21:46.286 A:middle
the point of protocol

00:21:46.286 --> 00:21:46.956 A:middle
inheritance.

00:21:47.376 --> 00:21:47.806 A:middle
So, here the

00:21:47.806 --> 00:21:49.816 A:middle
bidirectionalCollection protocol

00:21:50.056 --> 00:21:51.856 A:middle
inherits from, or is a

00:21:52.386 --> 00:21:52.876 A:middle
collection.

00:21:53.726 --> 00:21:55.026 A:middle
What that means is that any type

00:21:55.066 --> 00:21:56.236 A:middle
that conforms to the

00:21:56.236 --> 00:21:57.866 A:middle
bidirectionalCollection protocol

00:21:58.376 --> 00:21:59.816 A:middle
also conforms to collection, and

00:21:59.816 --> 00:22:00.776 A:middle
you can use those collection


00:21:59.816 --> 00:22:00.776 A:middle
you can use those collection

00:22:00.776 --> 00:22:01.426 A:middle
algorithms.

00:22:02.186 --> 00:22:03.306 A:middle
But, bidirectionalCollection

00:22:03.306 --> 00:22:04.306 A:middle
adds this additional

00:22:04.306 --> 00:22:05.486 A:middle
requirement, of being able to

00:22:05.486 --> 00:22:07.286 A:middle
step backwards in the

00:22:07.286 --> 00:22:07.776 A:middle
collection.

00:22:07.776 --> 00:22:09.866 A:middle
An important thing to note is

00:22:10.006 --> 00:22:11.216 A:middle
not every collection can

00:22:11.216 --> 00:22:12.386 A:middle
actually implement this

00:22:12.436 --> 00:22:13.636 A:middle
particular requirement.

00:22:13.976 --> 00:22:15.476 A:middle
Think of a singlyLinkedList,

00:22:15.476 --> 00:22:16.936 A:middle
where you only have these

00:22:17.496 --> 00:22:18.826 A:middle
pointers hopping from one

00:22:18.826 --> 00:22:19.866 A:middle
location to the next.

00:22:20.156 --> 00:22:21.406 A:middle
There's no efficient way to walk

00:22:21.536 --> 00:22:22.786 A:middle
backward through this sequence,

00:22:22.926 --> 00:22:24.346 A:middle
so it cannot be a

00:22:24.346 --> 00:22:25.406 A:middle
bidirectionalCollection.

00:22:25.776 --> 00:22:26.566 A:middle
So, once we've introduced

00:22:26.566 --> 00:22:28.046 A:middle
inheritance, you've restricted

00:22:28.046 --> 00:22:30.396 A:middle
the set of conforming types, but

00:22:31.096 --> 00:22:32.096 A:middle
you've allowed yourself to

00:22:32.306 --> 00:22:33.346 A:middle
implement more interesting

00:22:33.346 --> 00:22:34.006 A:middle
algorithms.

00:22:34.246 --> 00:22:35.456 A:middle
So, here's the code behind this

00:22:35.566 --> 00:22:37.136 A:middle
last index(where operation.

00:22:37.356 --> 00:22:37.976 A:middle
It's fairly simple.

00:22:37.976 --> 00:22:39.876 A:middle
We're just walking backwards

00:22:39.876 --> 00:22:41.496 A:middle
through the collection, using

00:22:41.496 --> 00:22:43.366 A:middle
this new requirement from the

00:22:43.366 --> 00:22:44.166 A:middle
bidirectionalCollection

00:22:44.166 --> 00:22:44.576 A:middle
protocol.

00:22:46.606 --> 00:22:48.006 A:middle
Let's look at a more interesting

00:22:48.006 --> 00:22:48.516 A:middle
algorithm.

00:22:48.826 --> 00:22:50.346 A:middle
So, here's a shuffle operation.

00:22:50.526 --> 00:22:51.526 A:middle
So, it was introduced for

00:22:51.686 --> 00:22:53.526 A:middle
collections in Swift 4.2.

00:22:53.666 --> 00:22:54.506 A:middle
You don't have to implement it

00:22:54.506 --> 00:22:55.646 A:middle
yourself, but we're going to

00:22:55.646 --> 00:22:56.816 A:middle
look at the algorithm itself to

00:22:56.816 --> 00:22:58.306 A:middle
see what kinds of requirements

00:22:58.306 --> 00:23:00.136 A:middle
it introduces to figure out how


00:22:58.306 --> 00:23:00.136 A:middle
it introduces to figure out how

00:23:00.136 --> 00:23:01.566 A:middle
to categorize those into

00:23:01.566 --> 00:23:02.656 A:middle
protocols meaningfully.

00:23:03.396 --> 00:23:04.446 A:middle
So, the Fisher-Yates shuffle

00:23:04.446 --> 00:23:05.276 A:middle
algorithm's a pretty old

00:23:05.276 --> 00:23:05.696 A:middle
algorithm.

00:23:06.196 --> 00:23:07.216 A:middle
It's also fairly simple.

00:23:07.546 --> 00:23:09.256 A:middle
You start with an index to the

00:23:09.256 --> 00:23:10.666 A:middle
first element in the collection.

00:23:11.586 --> 00:23:13.836 A:middle
And then, you select randomly

00:23:14.186 --> 00:23:15.376 A:middle
some other element in the

00:23:15.376 --> 00:23:17.196 A:middle
collection, and swap those two.

00:23:18.556 --> 00:23:20.666 A:middle
In the next iteration, you move

00:23:21.016 --> 00:23:22.596 A:middle
the left index forward one,

00:23:23.476 --> 00:23:24.716 A:middle
randomly select between there

00:23:24.716 --> 00:23:25.996 A:middle
and the end, swap those

00:23:25.996 --> 00:23:26.556 A:middle
elements.

00:23:26.916 --> 00:23:28.196 A:middle
And so, the algorithm is pretty

00:23:28.196 --> 00:23:28.466 A:middle
simple.

00:23:28.466 --> 00:23:29.886 A:middle
It's just this linear march

00:23:30.156 --> 00:23:32.446 A:middle
through the collection, randomly

00:23:32.446 --> 00:23:33.636 A:middle
selecting another element to

00:23:33.636 --> 00:23:34.196 A:middle
swap with.

00:23:34.576 --> 00:23:36.206 A:middle
And, at the end of this, you end

00:23:36.206 --> 00:23:37.516 A:middle
up with a nicely shuffled

00:23:37.886 --> 00:23:38.406 A:middle
collection.

00:23:39.326 --> 00:23:40.676 A:middle
So, we can actually look at the

00:23:40.676 --> 00:23:41.116 A:middle
code here.

00:23:41.356 --> 00:23:42.446 A:middle
It's a little bit involved.

00:23:42.446 --> 00:23:43.236 A:middle
Don't worry about that.

00:23:43.626 --> 00:23:44.996 A:middle
And, we're going to implement it

00:23:44.996 --> 00:23:46.366 A:middle
on some kind of collection.

00:23:46.906 --> 00:23:47.646 A:middle
So, we'll look at the core

00:23:47.646 --> 00:23:48.576 A:middle
operations in here.

00:23:48.906 --> 00:23:49.966 A:middle
So, first we need to be able to

00:23:49.966 --> 00:23:51.896 A:middle
grab a random number between

00:23:51.896 --> 00:23:53.156 A:middle
where we are in the collection

00:23:53.156 --> 00:23:54.206 A:middle
and the end of the collection,

00:23:54.396 --> 00:23:56.086 A:middle
using this random facility.

00:23:56.446 --> 00:23:57.206 A:middle
But, that's an integer.

00:23:57.366 --> 00:23:58.596 A:middle
And, what we need is an index

00:23:58.596 --> 00:23:59.316 A:middle
into the collection.

00:23:59.316 --> 00:24:00.226 A:middle
We know those are different.


00:23:59.316 --> 00:24:00.226 A:middle
We know those are different.

00:24:00.526 --> 00:24:02.066 A:middle
So, we need some operation--

00:24:02.116 --> 00:24:03.706 A:middle
let's call it index offsetBy--

00:24:04.506 --> 00:24:06.106 A:middle
to jump from the start index

00:24:06.516 --> 00:24:07.606 A:middle
quickly over to whatever

00:24:07.606 --> 00:24:08.816 A:middle
position we've selected.

00:24:10.106 --> 00:24:11.926 A:middle
The other operation we need is

00:24:11.926 --> 00:24:13.276 A:middle
the ability to swap two

00:24:13.276 --> 00:24:13.816 A:middle
elements.

00:24:14.916 --> 00:24:17.116 A:middle
Great. We have two operations

00:24:17.116 --> 00:24:18.076 A:middle
that we need to add to the

00:24:18.076 --> 00:24:19.596 A:middle
notion of a collection to be

00:24:19.596 --> 00:24:21.026 A:middle
able to implement shuffle,

00:24:21.336 --> 00:24:22.456 A:middle
therefore, we have a new

00:24:22.456 --> 00:24:23.686 A:middle
shuffleCollection protocol.

00:24:26.416 --> 00:24:27.606 A:middle
Please don't do this.

00:24:28.096 --> 00:24:29.396 A:middle
So, this is an anti-pattern that

00:24:29.396 --> 00:24:29.836 A:middle
we see.

00:24:30.466 --> 00:24:32.106 A:middle
And, the anti-pattern here is we

00:24:32.106 --> 00:24:33.096 A:middle
had one algorithm.

00:24:33.276 --> 00:24:34.956 A:middle
We found its requirements, and

00:24:34.956 --> 00:24:36.236 A:middle
then we packaged it up into a

00:24:36.236 --> 00:24:38.366 A:middle
protocol that is just that one--

00:24:39.316 --> 00:24:40.296 A:middle
just describes that one

00:24:40.296 --> 00:24:40.846 A:middle
algorithm.

00:24:41.116 --> 00:24:42.556 A:middle
If you do this, you have lots

00:24:42.626 --> 00:24:44.236 A:middle
and lots and lots of protocols

00:24:44.236 --> 00:24:45.756 A:middle
around that don't have any

00:24:45.756 --> 00:24:46.526 A:middle
interesting meaning.

00:24:46.526 --> 00:24:47.646 A:middle
You're not learning anything

00:24:47.646 --> 00:24:48.526 A:middle
from those protocols.

00:24:49.026 --> 00:24:51.486 A:middle
So, what you should do is notice

00:24:51.486 --> 00:24:52.956 A:middle
that we actually have distinct

00:24:52.956 --> 00:24:53.956 A:middle
capabilities here.

00:24:54.446 --> 00:24:55.536 A:middle
So, shuffle is using random

00:24:55.536 --> 00:24:57.496 A:middle
access, and it's using mutation.

00:24:57.966 --> 00:24:59.486 A:middle
But, these are separate, and we

00:24:59.486 --> 00:25:00.806 A:middle
can categorize them in separate


00:24:59.486 --> 00:25:00.806 A:middle
can categorize them in separate

00:25:00.926 --> 00:25:01.546 A:middle
protocols.

00:25:02.056 --> 00:25:02.946 A:middle
So, for example, the

00:25:02.946 --> 00:25:04.586 A:middle
randomAccessCollection protocol

00:25:04.976 --> 00:25:06.686 A:middle
is something where it allows us

00:25:06.686 --> 00:25:08.516 A:middle
to jump around the collection,

00:25:08.596 --> 00:25:09.756 A:middle
moving indices quickly.

00:25:10.466 --> 00:25:11.476 A:middle
And, there are types like

00:25:11.476 --> 00:25:12.886 A:middle
unsafeBufferPointer that can

00:25:12.886 --> 00:25:13.976 A:middle
give you random access.

00:25:14.326 --> 00:25:16.616 A:middle
But, do not allow any mutation.

00:25:16.736 --> 00:25:18.096 A:middle
That's a separate capability.

00:25:19.036 --> 00:25:19.826 A:middle
So, we also have the

00:25:19.826 --> 00:25:21.436 A:middle
mutableCollection protocol here.

00:25:22.366 --> 00:25:23.536 A:middle
And, we can think of types here

00:25:23.536 --> 00:25:24.976 A:middle
that allow mutation, but not

00:25:24.976 --> 00:25:25.896 A:middle
random access, like the

00:25:25.896 --> 00:25:27.186 A:middle
singlyLinkedList that we talked

00:25:27.186 --> 00:25:27.826 A:middle
about earlier.

00:25:28.556 --> 00:25:29.436 A:middle
Now, you notice that we've

00:25:29.436 --> 00:25:30.686 A:middle
essentially split the

00:25:30.686 --> 00:25:31.946 A:middle
inheritance hierarchy here.

00:25:33.246 --> 00:25:34.616 A:middle
We've got the access side for

00:25:34.616 --> 00:25:35.846 A:middle
random access, bidirectional,

00:25:35.846 --> 00:25:36.356 A:middle
and so on.

00:25:36.616 --> 00:25:37.446 A:middle
And then, we've got this

00:25:37.446 --> 00:25:38.266 A:middle
mutation side.

00:25:38.746 --> 00:25:39.816 A:middle
That's perfectly fine, because

00:25:39.816 --> 00:25:41.396 A:middle
clients themselves can compose

00:25:41.396 --> 00:25:43.736 A:middle
multiple protocols to implement

00:25:43.736 --> 00:25:44.776 A:middle
whatever generic algorithm

00:25:44.776 --> 00:25:45.246 A:middle
they're doing.

00:25:45.666 --> 00:25:46.876 A:middle
So, we go back to our shuffle

00:25:46.876 --> 00:25:47.246 A:middle
algorithm.

00:25:47.246 --> 00:25:49.466 A:middle
And, it can be written as an

00:25:49.466 --> 00:25:50.396 A:middle
extension on

00:25:50.396 --> 00:25:52.056 A:middle
randomAccessCollection, with a

00:25:52.056 --> 00:25:52.666 A:middle
self-type.

00:25:52.746 --> 00:25:54.186 A:middle
This is the type that conforms

00:25:54.186 --> 00:25:56.096 A:middle
to randomAccessCollection also

00:25:56.096 --> 00:25:56.746 A:middle
conforms to the

00:25:56.746 --> 00:25:58.096 A:middle
mutableCollection protocol.

00:25:58.546 --> 00:25:59.516 A:middle
And now, we've pulled together

00:25:59.516 --> 00:26:00.556 A:middle
the capabilities of both of


00:25:59.516 --> 00:26:00.556 A:middle
the capabilities of both of

00:26:00.556 --> 00:26:00.886 A:middle
these.

00:26:02.426 --> 00:26:04.556 A:middle
Now, when you have a bunch of

00:26:04.556 --> 00:26:06.216 A:middle
conforming types, and a bunch of

00:26:06.216 --> 00:26:07.986 A:middle
generic algorithms, you tend to

00:26:07.986 --> 00:26:09.806 A:middle
get protocol hierarchies

00:26:09.806 --> 00:26:10.196 A:middle
forming.

00:26:10.676 --> 00:26:12.156 A:middle
Now, these hierarchies, they

00:26:12.156 --> 00:26:13.046 A:middle
shouldn't be too big.

00:26:13.176 --> 00:26:14.026 A:middle
They should not be too

00:26:14.026 --> 00:26:14.956 A:middle
fine-grained.

00:26:15.926 --> 00:26:17.046 A:middle
Because you really want a small

00:26:17.046 --> 00:26:18.066 A:middle
number of protocols that really

00:26:18.066 --> 00:26:19.776 A:middle
describe the kinds of types that

00:26:19.776 --> 00:26:21.466 A:middle
show up in the domain, right?

00:26:22.656 --> 00:26:23.916 A:middle
And now, there's things that you

00:26:23.916 --> 00:26:25.436 A:middle
notice when you do build these

00:26:25.486 --> 00:26:26.446 A:middle
protocol hierarchies.

00:26:26.626 --> 00:26:27.826 A:middle
So, as you go from the bottom of

00:26:27.826 --> 00:26:29.646 A:middle
the hierarchy to the top, you're

00:26:29.646 --> 00:26:30.956 A:middle
going to protocols that have

00:26:30.956 --> 00:26:32.466 A:middle
fewer requirements, and

00:26:32.466 --> 00:26:33.576 A:middle
therefore, there're more

00:26:33.576 --> 00:26:35.306 A:middle
conforming types that can

00:26:35.306 --> 00:26:36.626 A:middle
implement those requirements.

00:26:37.566 --> 00:26:38.336 A:middle
Now, on the other hand, as

00:26:38.336 --> 00:26:39.416 A:middle
you're moving down the

00:26:39.466 --> 00:26:41.666 A:middle
hierarchy, and combining

00:26:41.666 --> 00:26:42.646 A:middle
different protocols from the

00:26:42.696 --> 00:26:44.326 A:middle
hierarchy, you get to implement

00:26:44.326 --> 00:26:46.076 A:middle
more intricate, more specialized

00:26:46.076 --> 00:26:47.676 A:middle
algorithms that require more

00:26:47.676 --> 00:26:48.996 A:middle
advanced capabilities, but

00:26:48.996 --> 00:26:50.006 A:middle
naturally work with fewer

00:26:50.006 --> 00:26:50.836 A:middle
conforming types.

00:26:51.396 --> 00:26:51.496 A:middle
OK.

00:26:55.336 --> 00:26:56.676 A:middle
So, let's talk about conditional

00:26:56.676 --> 00:26:57.246 A:middle
conformance.

00:26:57.306 --> 00:26:58.376 A:middle
This is, of course, a newer

00:26:58.376 --> 00:26:59.776 A:middle
feature in Swift.


00:27:00.646 --> 00:27:02.216 A:middle
And, let's start by looking at

00:27:02.216 --> 00:27:02.946 A:middle
slices again.

00:27:03.526 --> 00:27:04.796 A:middle
So, for any collection that you

00:27:04.796 --> 00:27:07.276 A:middle
have, you can form a slice of

00:27:07.276 --> 00:27:09.136 A:middle
that collection by subscripting

00:27:09.356 --> 00:27:12.236 A:middle
with a particular range of

00:27:12.236 --> 00:27:12.856 A:middle
indices.

00:27:13.326 --> 00:27:14.696 A:middle
And, that slice is essentially a

00:27:14.696 --> 00:27:16.246 A:middle
view into some part of the

00:27:16.246 --> 00:27:16.796 A:middle
collection.

00:27:17.986 --> 00:27:20.366 A:middle
Now, these are default type that

00:27:20.366 --> 00:27:21.366 A:middle
you get from slicing a

00:27:21.366 --> 00:27:23.696 A:middle
collection, is called slice.

00:27:24.486 --> 00:27:26.146 A:middle
And, slice is a generic adaptor

00:27:26.146 --> 00:27:26.376 A:middle
type.

00:27:27.366 --> 00:27:29.666 A:middle
So, it is parameterized on a

00:27:29.666 --> 00:27:32.036 A:middle
base collection type, and it is

00:27:32.036 --> 00:27:33.216 A:middle
itself a collection.

00:27:33.956 --> 00:27:36.276 A:middle
So, our expectation on a slice

00:27:36.326 --> 00:27:37.636 A:middle
is that you can do anything to a

00:27:37.636 --> 00:27:38.676 A:middle
slice that you can do to the

00:27:38.676 --> 00:27:39.826 A:middle
underlying collection.

00:27:40.146 --> 00:27:41.266 A:middle
It's a reasonable thing to want.

00:27:41.876 --> 00:27:43.636 A:middle
And so, certainly we can go and

00:27:43.636 --> 00:27:44.496 A:middle
use the forward search

00:27:44.496 --> 00:27:46.376 A:middle
operations like index(where to

00:27:46.376 --> 00:27:47.406 A:middle
go find something matching a

00:27:47.406 --> 00:27:48.726 A:middle
predicate, and that works on the

00:27:48.726 --> 00:27:50.226 A:middle
collection and any slice of that

00:27:50.226 --> 00:27:50.696 A:middle
collection.

00:27:51.576 --> 00:27:52.676 A:middle
So, we'd like to do the same

00:27:52.676 --> 00:27:54.506 A:middle
thing with backwards search, but

00:27:54.506 --> 00:27:55.456 A:middle
here we're going to run into a

00:27:55.456 --> 00:27:55.886 A:middle
problem.

00:27:55.886 --> 00:27:57.096 A:middle
So, even if the buffer is a

00:27:57.276 --> 00:27:59.766 A:middle
bidirectionalCollection, nothing

00:27:59.766 --> 00:28:00.946 A:middle
has said that the slice is a


00:27:59.766 --> 00:28:00.946 A:middle
has said that the slice is a

00:28:00.946 --> 00:28:02.026 A:middle
bidirectionalCollection.

00:28:02.596 --> 00:28:05.596 A:middle
We can fix that.

00:28:05.936 --> 00:28:07.606 A:middle
Let's extend slice to make it

00:28:07.606 --> 00:28:08.156 A:middle
conform to the

00:28:08.156 --> 00:28:09.156 A:middle
bidirectionalCollection

00:28:09.156 --> 00:28:09.596 A:middle
protocol.

00:28:10.536 --> 00:28:11.676 A:middle
We need to implement this index

00:28:11.676 --> 00:28:13.026 A:middle
before operation, which we can

00:28:13.026 --> 00:28:14.486 A:middle
implement in terms of the

00:28:14.486 --> 00:28:16.176 A:middle
underlying base collection.

00:28:17.146 --> 00:28:18.086 A:middle
Except the compiler's going to

00:28:18.086 --> 00:28:18.666 A:middle
complain here.

00:28:19.736 --> 00:28:21.016 A:middle
The only thing we knew about

00:28:21.016 --> 00:28:22.676 A:middle
that base collection is that

00:28:22.676 --> 00:28:23.516 A:middle
it's a collection.

00:28:23.696 --> 00:28:25.366 A:middle
It doesn't have an index before

00:28:25.366 --> 00:28:26.286 A:middle
operation on it.

00:28:27.806 --> 00:28:28.966 A:middle
We know how to fix this.

00:28:29.516 --> 00:28:31.176 A:middle
All we need to do is introduce a

00:28:31.176 --> 00:28:32.646 A:middle
requirement into this extension

00:28:32.646 --> 00:28:33.766 A:middle
to say that well, base needs to

00:28:33.766 --> 00:28:35.016 A:middle
be a bidirectionalCollection.

00:28:35.786 --> 00:28:37.176 A:middle
This is conditional conformance.

00:28:38.146 --> 00:28:40.216 A:middle
All it is, is extensions that

00:28:40.216 --> 00:28:41.836 A:middle
declare conformance to a

00:28:41.836 --> 00:28:43.286 A:middle
protocol, and then the

00:28:43.286 --> 00:28:44.506 A:middle
constraints under which that

00:28:44.506 --> 00:28:45.706 A:middle
conformance actually makes

00:28:45.706 --> 00:28:46.076 A:middle
sense.

00:28:46.966 --> 00:28:48.006 A:middle
And, the wonderful thing about

00:28:48.006 --> 00:28:49.146 A:middle
conditional conformance, is it

00:28:49.146 --> 00:28:50.326 A:middle
stacks nicely when you have

00:28:50.326 --> 00:28:51.966 A:middle
these protocol hierarchies, so

00:28:51.966 --> 00:28:54.216 A:middle
we can also state that slice is

00:28:54.216 --> 00:28:56.176 A:middle
a randomAccessCollection, when

00:28:56.176 --> 00:28:58.086 A:middle
its underlying base type is a

00:28:58.086 --> 00:28:59.286 A:middle
randomAccessCollection.


00:29:00.486 --> 00:29:01.456 A:middle
Now, notice that I've written

00:29:01.556 --> 00:29:02.806 A:middle
two different extensions here.

00:29:03.806 --> 00:29:05.086 A:middle
Now, it's generally good Swift

00:29:05.086 --> 00:29:05.546 A:middle
style.

00:29:06.086 --> 00:29:07.026 A:middle
Write an extension, have it

00:29:07.026 --> 00:29:08.616 A:middle
conform to one protocol, so you

00:29:08.616 --> 00:29:10.066 A:middle
know what that extension is for,

00:29:10.066 --> 00:29:10.966 A:middle
you know its meaning.

00:29:11.466 --> 00:29:13.586 A:middle
It's particularly important with

00:29:13.796 --> 00:29:15.106 A:middle
conditional requirements--

00:29:15.456 --> 00:29:17.536 A:middle
conformances, because you have

00:29:17.586 --> 00:29:19.006 A:middle
different requirements on these

00:29:19.006 --> 00:29:19.796 A:middle
extensions.

00:29:20.286 --> 00:29:22.026 A:middle
And, this allows for

00:29:22.026 --> 00:29:22.836 A:middle
composability.

00:29:22.886 --> 00:29:24.426 A:middle
Whatever the underlying base

00:29:24.466 --> 00:29:26.306 A:middle
collection can do, the slice

00:29:26.356 --> 00:29:28.036 A:middle
type can also do.

00:29:28.856 --> 00:29:31.346 A:middle
So, let's look at another

00:29:31.346 --> 00:29:32.326 A:middle
application of conditional

00:29:32.326 --> 00:29:33.556 A:middle
conformance, also in the

00:29:33.556 --> 00:29:34.866 A:middle
standard library, and these are

00:29:34.866 --> 00:29:35.366 A:middle
ranges.

00:29:35.526 --> 00:29:36.646 A:middle
So, ranges have been around

00:29:36.856 --> 00:29:37.666 A:middle
forever in Swift.

00:29:37.666 --> 00:29:38.806 A:middle
And, you can form a range with,

00:29:38.886 --> 00:29:40.256 A:middle
for example, these ..less than

00:29:40.256 --> 00:29:40.926 A:middle
operations.

00:29:41.436 --> 00:29:43.096 A:middle
And so, you can form ranges of

00:29:43.096 --> 00:29:44.516 A:middle
doubles, you can form ranges of

00:29:44.596 --> 00:29:45.336 A:middle
integers.

00:29:45.946 --> 00:29:47.086 A:middle
But, some ranges are more

00:29:47.086 --> 00:29:48.156 A:middle
powerful than others.

00:29:48.416 --> 00:29:49.786 A:middle
So, you can iterate over the

00:29:49.786 --> 00:29:52.296 A:middle
elements in a range of integers.

00:29:52.976 --> 00:29:53.876 A:middle
Well, why can you do that?

00:29:53.876 --> 00:29:55.066 A:middle
It was because an intRange

00:29:55.576 --> 00:29:56.806 A:middle
conforms to collection.

00:29:58.266 --> 00:29:59.276 A:middle
Now, if you're actually look at

00:29:59.276 --> 00:30:00.916 A:middle
the type, it's produced by that


00:29:59.276 --> 00:30:00.916 A:middle
the type, it's produced by that

00:30:01.036 --> 00:30:01.976 A:middle
..less than operator.

00:30:02.346 --> 00:30:04.306 A:middle
It is aptly named the range

00:30:04.306 --> 00:30:04.556 A:middle
type.

00:30:05.346 --> 00:30:07.096 A:middle
Again, it's generic over the

00:30:07.096 --> 00:30:08.126 A:middle
underlying bound type.

00:30:08.126 --> 00:30:08.966 A:middle
So, in this case, we have a

00:30:08.966 --> 00:30:10.676 A:middle
range of doubles, and it merely

00:30:10.676 --> 00:30:11.916 A:middle
stores the upper and lower

00:30:11.916 --> 00:30:12.456 A:middle
bounds.

00:30:12.646 --> 00:30:13.456 A:middle
That's fairly simple.

00:30:14.286 --> 00:30:16.806 A:middle
But, prior to Swift 4.2, you

00:30:16.806 --> 00:30:18.816 A:middle
would get from an integer range,

00:30:18.876 --> 00:30:20.036 A:middle
an actually different type.

00:30:20.466 --> 00:30:22.176 A:middle
This is the countableRange type.

00:30:23.126 --> 00:30:24.466 A:middle
Now, notice it's structurally

00:30:24.466 --> 00:30:26.056 A:middle
the same as the range type.

00:30:26.056 --> 00:30:27.236 A:middle
It has one type parameter.

00:30:27.236 --> 00:30:29.956 A:middle
It has lower and upperBound, but

00:30:29.956 --> 00:30:31.126 A:middle
it adds a couple additional

00:30:31.126 --> 00:30:32.686 A:middle
requirements onto that bound

00:30:32.686 --> 00:30:32.886 A:middle
type.

00:30:33.286 --> 00:30:34.876 A:middle
That the bound be stridable,

00:30:35.286 --> 00:30:35.376 A:middle
right?

00:30:35.376 --> 00:30:36.446 A:middle
Meaning you can walk through and

00:30:36.446 --> 00:30:37.436 A:middle
enumerate all the elements.

00:30:37.866 --> 00:30:39.306 A:middle
Now, that's the ability you need

00:30:39.446 --> 00:30:40.056 A:middle
so that you can make

00:30:40.056 --> 00:30:41.316 A:middle
countableRange conform to

00:30:41.316 --> 00:30:42.456 A:middle
randomAccessCollection.

00:30:43.676 --> 00:30:44.876 A:middle
That enables the .forEach

00:30:45.006 --> 00:30:46.366 A:middle
iteration loop, and other

00:30:46.366 --> 00:30:46.826 A:middle
things.

00:30:48.076 --> 00:30:48.706 A:middle
But, with conditional

00:30:48.706 --> 00:30:49.986 A:middle
conformance, of course, we can

00:30:49.986 --> 00:30:50.736 A:middle
do better.

00:30:51.516 --> 00:30:53.836 A:middle
So, let's turn the basic range

00:30:53.836 --> 00:30:57.306 A:middle
type into a collection, when the

00:30:57.306 --> 00:30:59.086 A:middle
bound type conforms this-- has

00:30:59.086 --> 00:31:00.616 A:middle
these extra stridable


00:30:59.086 --> 00:31:00.616 A:middle
these extra stridable

00:31:00.616 --> 00:31:01.376 A:middle
requirements on it.

00:31:01.736 --> 00:31:02.746 A:middle
It's a simple application of

00:31:02.746 --> 00:31:04.396 A:middle
conditional conformance, but it

00:31:04.396 --> 00:31:05.746 A:middle
makes the range type more

00:31:05.816 --> 00:31:08.186 A:middle
powerful when used with better

00:31:08.256 --> 00:31:09.266 A:middle
type parameters.

00:31:10.806 --> 00:31:13.206 A:middle
Now, notice that I'm just

00:31:13.206 --> 00:31:13.696 A:middle
conforming to

00:31:13.696 --> 00:31:14.876 A:middle
randomAccessCollection.

00:31:15.496 --> 00:31:17.676 A:middle
I have not actually mentioned

00:31:17.746 --> 00:31:18.226 A:middle
collection or

00:31:18.226 --> 00:31:19.326 A:middle
bidirectionalCollection.

00:31:20.366 --> 00:31:21.866 A:middle
With unconditional conformances,

00:31:21.866 --> 00:31:22.546 A:middle
this is OK.

00:31:23.036 --> 00:31:24.356 A:middle
Declaring conformance to

00:31:24.356 --> 00:31:26.446 A:middle
randomAccessCollection implies

00:31:26.446 --> 00:31:28.226 A:middle
conformances to any protocols

00:31:28.276 --> 00:31:29.526 A:middle
that it inherits.

00:31:29.606 --> 00:31:30.286 A:middle
In this case,

00:31:30.366 --> 00:31:31.416 A:middle
bidirectionalCollection and

00:31:31.416 --> 00:31:31.946 A:middle
collection.

00:31:32.626 --> 00:31:34.016 A:middle
However, with conditional

00:31:34.016 --> 00:31:35.326 A:middle
conformance, this is actually an

00:31:35.326 --> 00:31:35.586 A:middle
error.

00:31:36.576 --> 00:31:37.636 A:middle
Now, if you think back to the

00:31:37.636 --> 00:31:39.666 A:middle
slice example, we needed to have

00:31:39.776 --> 00:31:41.696 A:middle
different constraints for those

00:31:42.016 --> 00:31:43.266 A:middle
different levels of the

00:31:43.316 --> 00:31:44.766 A:middle
hierarchy for collection versus

00:31:44.806 --> 00:31:46.046 A:middle
bidirectionalCollection versus

00:31:46.046 --> 00:31:47.176 A:middle
randomAccessCollection.

00:31:47.756 --> 00:31:49.416 A:middle
And so, compiler's enforcing

00:31:49.416 --> 00:31:50.636 A:middle
that you've thought about this,

00:31:50.636 --> 00:31:52.106 A:middle
and made sure that you have the

00:31:52.236 --> 00:31:53.426 A:middle
right set of constraints for

00:31:53.736 --> 00:31:54.776 A:middle
conditional conformance.

00:31:55.906 --> 00:31:57.406 A:middle
In this case, the constraints

00:31:57.406 --> 00:31:58.586 A:middle
across the entire hierarchy are

00:31:58.586 --> 00:31:59.086 A:middle
the same.

00:31:59.416 --> 00:32:00.516 A:middle
So, we can just write out


00:31:59.416 --> 00:32:00.516 A:middle
So, we can just write out

00:32:00.516 --> 00:32:01.636 A:middle
explicitly collection and

00:32:01.636 --> 00:32:03.516 A:middle
bidirectionalCollection to

00:32:03.516 --> 00:32:05.066 A:middle
assert that this is where all

00:32:05.066 --> 00:32:07.016 A:middle
these conformances are, or we

00:32:07.016 --> 00:32:08.206 A:middle
can do the stylistically better

00:32:08.206 --> 00:32:09.616 A:middle
thing, and split out the

00:32:09.616 --> 00:32:10.556 A:middle
different conformances.

00:32:12.486 --> 00:32:13.726 A:middle
Now, at this point, our range

00:32:13.726 --> 00:32:15.346 A:middle
type is pretty powerful.

00:32:15.346 --> 00:32:15.946 A:middle
It does everything the

00:32:15.946 --> 00:32:17.016 A:middle
countableRange does.

00:32:17.296 --> 00:32:17.986 A:middle
So, what should we do with

00:32:17.986 --> 00:32:18.686 A:middle
countableRange?

00:32:19.536 --> 00:32:20.206 A:middle
We could throw it away.

00:32:20.726 --> 00:32:21.496 A:middle
In this case we're talking about

00:32:21.496 --> 00:32:23.066 A:middle
the standard library, and

00:32:23.066 --> 00:32:23.936 A:middle
there's a lot of code that

00:32:23.936 --> 00:32:26.346 A:middle
actually uses countableRange, so

00:32:26.346 --> 00:32:28.176 A:middle
we can keep it around as a

00:32:28.176 --> 00:32:29.586 A:middle
generic type alias.

00:32:30.896 --> 00:32:32.476 A:middle
This is a really nice solution.

00:32:32.476 --> 00:32:34.476 A:middle
So, the generic type alias adds

00:32:34.546 --> 00:32:35.886 A:middle
all of those extra requirements

00:32:35.886 --> 00:32:37.296 A:middle
you need to make the range

00:32:37.346 --> 00:32:37.806 A:middle
countable.

00:32:38.066 --> 00:32:39.276 A:middle
The requirements you need to

00:32:39.276 --> 00:32:41.726 A:middle
turn it into a collection, but

00:32:42.026 --> 00:32:43.366 A:middle
it's just an alternate name for

00:32:43.366 --> 00:32:44.696 A:middle
the underlying range type.

00:32:45.176 --> 00:32:47.806 A:middle
Again, this is great for source

00:32:47.806 --> 00:32:49.166 A:middle
compatibility, because code can

00:32:49.166 --> 00:32:50.846 A:middle
still use countableRange.

00:32:51.116 --> 00:32:52.416 A:middle
On the other hand, it's also

00:32:52.466 --> 00:32:54.456 A:middle
really nice to give a name to

00:32:54.456 --> 00:32:56.046 A:middle
those ranges that have

00:32:56.046 --> 00:32:57.856 A:middle
additional capabilities of being

00:32:57.856 --> 00:32:59.286 A:middle
a randomAccessCollection.

00:32:59.916 --> 00:33:01.276 A:middle
In fact, we can use this to


00:32:59.916 --> 00:33:01.276 A:middle
In fact, we can use this to

00:33:01.276 --> 00:33:02.206 A:middle
clean up other code.

00:33:02.206 --> 00:33:03.466 A:middle
To say, well, we know what a

00:33:03.466 --> 00:33:04.476 A:middle
countableRange is.

00:33:04.876 --> 00:33:06.876 A:middle
It's a range with this extra

00:33:06.876 --> 00:33:09.106 A:middle
striding capability, so we can

00:33:09.106 --> 00:33:11.176 A:middle
go extend countableRanges, and

00:33:11.176 --> 00:33:12.906 A:middle
that is a case in which we have

00:33:13.456 --> 00:33:14.466 A:middle
randomAccessCollection

00:33:14.466 --> 00:33:14.996 A:middle
conformance.

00:33:16.456 --> 00:33:17.426 A:middle
So, we've introduced this in

00:33:17.426 --> 00:33:19.866 A:middle
Swift 4.2 to help simplify the

00:33:19.866 --> 00:33:20.906 A:middle
set of types that we're dealing

00:33:20.906 --> 00:33:22.376 A:middle
with, and make the existing core

00:33:22.376 --> 00:33:24.496 A:middle
types like range more composable

00:33:24.496 --> 00:33:25.336 A:middle
and more flexible.

00:33:25.936 --> 00:33:26.036 A:middle
OK.

00:33:27.416 --> 00:33:30.286 A:middle
One last topic.

00:33:31.476 --> 00:33:32.946 A:middle
So, Swift is a multi-paradigm

00:33:32.946 --> 00:33:33.346 A:middle
language.

00:33:33.476 --> 00:33:34.816 A:middle
We've been talking exclusively

00:33:34.856 --> 00:33:36.076 A:middle
about generics right now.

00:33:36.076 --> 00:33:37.316 A:middle
But, of course, Swift also

00:33:37.316 --> 00:33:38.576 A:middle
supports object-oriented

00:33:38.576 --> 00:33:39.166 A:middle
programming.

00:33:40.196 --> 00:33:41.306 A:middle
And so, I'd like to take a few

00:33:41.306 --> 00:33:42.346 A:middle
moments to talk about the

00:33:42.346 --> 00:33:44.136 A:middle
interaction between those two

00:33:44.136 --> 00:33:45.886 A:middle
features, how they work together

00:33:46.056 --> 00:33:47.076 A:middle
in the Swift language.

00:33:47.606 --> 00:33:50.136 A:middle
So, with class inheritance, we

00:33:50.136 --> 00:33:50.986 A:middle
know how class inheritance

00:33:51.016 --> 00:33:51.346 A:middle
works.

00:33:51.536 --> 00:33:52.306 A:middle
It's fairly simple.

00:33:52.826 --> 00:33:54.156 A:middle
You can declare a superclass,

00:33:54.156 --> 00:33:54.826 A:middle
like Vehicle.

00:33:54.976 --> 00:33:56.606 A:middle
You can declare some subclasses,

00:33:56.606 --> 00:33:57.936 A:middle
like Taxi and PoliceCar.

00:33:57.936 --> 00:33:59.226 A:middle
They both inherit from Vehicle.


00:34:00.046 --> 00:34:01.566 A:middle
And, once you do this, you have

00:34:01.566 --> 00:34:02.906 A:middle
this object-oriented hierarchy.

00:34:03.396 --> 00:34:04.946 A:middle
You have some expectations about

00:34:04.946 --> 00:34:06.086 A:middle
where you can use those

00:34:06.086 --> 00:34:06.956 A:middle
subclasses.

00:34:07.426 --> 00:34:09.366 A:middle
So, if I were to extend Vehicle

00:34:09.366 --> 00:34:10.676 A:middle
with a new method, to go

00:34:10.676 --> 00:34:12.456 A:middle
[inaudible] Drive, I fully

00:34:12.456 --> 00:34:14.076 A:middle
expect that I can call that

00:34:14.076 --> 00:34:15.956 A:middle
method on one of my subclasses,

00:34:16.056 --> 00:34:16.525 A:middle
Taxi.

00:34:17.976 --> 00:34:20.116 A:middle
So, this is a fundamental aspect

00:34:20.255 --> 00:34:21.866 A:middle
of object-oriented programming.

00:34:22.196 --> 00:34:23.735 A:middle
And, Barbara Liskov, she

00:34:23.735 --> 00:34:25.275 A:middle
described this really well in a

00:34:25.275 --> 00:34:26.446 A:middle
lecture back in the '80's.

00:34:27.286 --> 00:34:28.166 A:middle
Since then, we've referred to

00:34:28.166 --> 00:34:30.096 A:middle
this as the Liskov substitution

00:34:30.096 --> 00:34:30.596 A:middle
principle.

00:34:30.956 --> 00:34:32.295 A:middle
And, the idea's actually fairly

00:34:32.295 --> 00:34:32.726 A:middle
simple.

00:34:33.326 --> 00:34:35.426 A:middle
So, if you have someplace in

00:34:35.426 --> 00:34:37.346 A:middle
your program that refers to a

00:34:37.346 --> 00:34:40.686 A:middle
supertype, or superclass, like

00:34:40.826 --> 00:34:43.366 A:middle
Vehicle, you should be able to

00:34:43.366 --> 00:34:44.826 A:middle
take an instance of any of its

00:34:44.946 --> 00:34:47.696 A:middle
subtypes, or subclasses, like

00:34:47.766 --> 00:34:50.196 A:middle
Taxi or PoliceCar, and use that

00:34:50.196 --> 00:34:50.786 A:middle
instead.

00:34:51.246 --> 00:34:52.406 A:middle
And, the program should still

00:34:52.406 --> 00:34:53.896 A:middle
continue to type check, and run

00:34:53.936 --> 00:34:54.426 A:middle
correctly.

00:34:55.186 --> 00:34:56.496 A:middle
So, the substitution here is an

00:34:56.496 --> 00:34:57.616 A:middle
instance of a subclass, should

00:34:57.616 --> 00:34:58.796 A:middle
be able to go anywhere that the

00:34:58.796 --> 00:35:00.196 A:middle
superclass was expected and


00:34:58.796 --> 00:35:00.196 A:middle
superclass was expected and

00:35:00.196 --> 00:35:00.676 A:middle
tested.

00:35:01.706 --> 00:35:02.916 A:middle
And, this is a really simple

00:35:02.916 --> 00:35:03.336 A:middle
principle.

00:35:03.336 --> 00:35:04.886 A:middle
We've all internalized it, but

00:35:04.886 --> 00:35:06.476 A:middle
it's also really powerful.

00:35:07.036 --> 00:35:08.086 A:middle
If you think about it.

00:35:08.466 --> 00:35:09.496 A:middle
And, at any point in your

00:35:09.496 --> 00:35:10.806 A:middle
program think well, what happens

00:35:10.806 --> 00:35:12.156 A:middle
if I get a different subclass,

00:35:12.156 --> 00:35:13.246 A:middle
maybe a subclass I haven't

00:35:13.326 --> 00:35:14.056 A:middle
thought about here.

00:35:15.526 --> 00:35:18.226 A:middle
So, getting back to generics,

00:35:19.206 --> 00:35:20.826 A:middle
what are our expectations when

00:35:20.826 --> 00:35:22.346 A:middle
applying Liskov substitution

00:35:22.346 --> 00:35:24.766 A:middle
principle to the generic system?

00:35:25.416 --> 00:35:26.436 A:middle
Well, maybe we add a new

00:35:26.506 --> 00:35:27.566 A:middle
protocol, Drivable.

00:35:27.866 --> 00:35:30.736 A:middle
Whatever. And, extend Vehicle to

00:35:30.736 --> 00:35:31.586 A:middle
make it Drivable.

00:35:31.936 --> 00:35:33.226 A:middle
What do we expect to happen?

00:35:33.226 --> 00:35:35.506 A:middle
Well, we expect that you can use

00:35:35.506 --> 00:35:36.726 A:middle
that protocol, conformance of

00:35:36.726 --> 00:35:38.876 A:middle
Vehicle to Drivable, for some of

00:35:38.876 --> 00:35:40.066 A:middle
its subclasses as well.

00:35:41.056 --> 00:35:43.306 A:middle
Say, you add simple generic

00:35:43.306 --> 00:35:44.756 A:middle
algorithm to the Drivable

00:35:44.756 --> 00:35:45.616 A:middle
protocol to go for a

00:35:45.616 --> 00:35:46.406 A:middle
sundayDrive.

00:35:46.826 --> 00:35:48.086 A:middle
Well, now you should be able to

00:35:48.086 --> 00:35:50.916 A:middle
use that API on a PoliceCar,

00:35:51.396 --> 00:35:52.556 A:middle
even if that might not be the

00:35:52.556 --> 00:35:53.156 A:middle
best idea.

00:35:54.786 --> 00:35:57.076 A:middle
So, the protocol conformance

00:35:57.076 --> 00:35:58.536 A:middle
here is effectively being

00:35:58.746 --> 00:36:00.286 A:middle
inherited by subclasses.


00:35:58.746 --> 00:36:00.286 A:middle
inherited by subclasses.

00:36:01.316 --> 00:36:02.346 A:middle
And, this puts a constraint on

00:36:02.346 --> 00:36:03.006 A:middle
the conformance.

00:36:03.266 --> 00:36:04.646 A:middle
The one conformance that you

00:36:04.646 --> 00:36:05.876 A:middle
write, the thing that makes

00:36:06.306 --> 00:36:08.446 A:middle
Vehicle Drivable, has to work

00:36:08.686 --> 00:36:10.216 A:middle
for all of the subclasses of

00:36:10.216 --> 00:36:12.076 A:middle
Vehicle now and anyone that

00:36:12.076 --> 00:36:13.206 A:middle
comes up with it later.

00:36:14.326 --> 00:36:16.356 A:middle
Most of the time, that just

00:36:16.356 --> 00:36:16.716 A:middle
works.

00:36:17.706 --> 00:36:19.026 A:middle
However, there are some cases

00:36:19.026 --> 00:36:20.416 A:middle
where this actually adds new

00:36:20.416 --> 00:36:22.526 A:middle
requirements on the subclasses.

00:36:23.166 --> 00:36:25.536 A:middle
The most common one is when

00:36:25.536 --> 00:36:26.706 A:middle
dealing with initializer

00:36:26.706 --> 00:36:27.436 A:middle
requirements.

00:36:28.656 --> 00:36:29.326 A:middle
So, if you've looked at the

00:36:29.326 --> 00:36:31.756 A:middle
decodable protocol, it has one

00:36:31.756 --> 00:36:32.916 A:middle
interesting requirement, which

00:36:32.916 --> 00:36:34.496 A:middle
is the initializer requirement

00:36:34.806 --> 00:36:36.696 A:middle
to create a new instance of the

00:36:36.696 --> 00:36:39.046 A:middle
conforming type from a decoder.

00:36:39.626 --> 00:36:41.596 A:middle
How do we use this?

00:36:41.946 --> 00:36:43.196 A:middle
Well, let's go add a convenience

00:36:43.196 --> 00:36:44.186 A:middle
method to the decodable

00:36:44.186 --> 00:36:44.686 A:middle
protocol.

00:36:45.126 --> 00:36:46.806 A:middle
It's a static method decode that

00:36:46.956 --> 00:36:48.086 A:middle
creates a new instance from a

00:36:48.086 --> 00:36:49.666 A:middle
decoder, essential a wrapper for

00:36:49.666 --> 00:36:50.596 A:middle
the initializer, making it

00:36:50.596 --> 00:36:51.206 A:middle
easier to use.

00:36:52.426 --> 00:36:54.046 A:middle
And, there's two interesting

00:36:54.046 --> 00:36:55.816 A:middle
things to notice about this

00:36:55.816 --> 00:36:56.956 A:middle
particular method.

00:36:57.296 --> 00:36:59.216 A:middle
First, is it returns Self with a

00:36:59.216 --> 00:36:59.896 A:middle
capital S.

00:36:59.896 --> 00:37:01.176 A:middle
Remember this is the conforming


00:36:59.896 --> 00:37:01.176 A:middle
Remember this is the conforming

00:37:01.216 --> 00:37:01.476 A:middle
type.

00:37:01.876 --> 00:37:03.296 A:middle
It's the same type that you're

00:37:03.296 --> 00:37:04.966 A:middle
calling the static method on.

00:37:06.576 --> 00:37:07.616 A:middle
Now, the second interesting

00:37:07.616 --> 00:37:09.446 A:middle
thing is, how are we

00:37:09.446 --> 00:37:10.186 A:middle
implementing this?

00:37:10.246 --> 00:37:11.396 A:middle
Well, we're calling to that

00:37:11.396 --> 00:37:13.636 A:middle
initializer above to create a

00:37:13.636 --> 00:37:16.586 A:middle
brand new instance of whatever

00:37:16.586 --> 00:37:18.956 A:middle
decodable type we have, and then

00:37:18.956 --> 00:37:20.006 A:middle
return it.

00:37:20.916 --> 00:37:21.766 A:middle
Fair enough.

00:37:22.586 --> 00:37:23.696 A:middle
We can go ahead and make our

00:37:23.696 --> 00:37:24.906 A:middle
Vehicle type Decodable.

00:37:25.866 --> 00:37:28.026 A:middle
And then, what we expect, when

00:37:28.026 --> 00:37:29.216 A:middle
applying the Liskov substitution

00:37:29.216 --> 00:37:31.026 A:middle
principle, is we can use any

00:37:31.026 --> 00:37:34.006 A:middle
subclass of Vehicle with these

00:37:34.006 --> 00:37:34.986 A:middle
new API's that we've built

00:37:34.986 --> 00:37:35.616 A:middle
through the protocol

00:37:35.616 --> 00:37:36.156 A:middle
conformance.

00:37:36.256 --> 00:37:39.246 A:middle
So, we can call Decode on Taxi,

00:37:39.926 --> 00:37:41.166 A:middle
and what we get back is not a

00:37:41.166 --> 00:37:42.496 A:middle
Vehicle not [inaudible] Vehicle

00:37:42.496 --> 00:37:44.126 A:middle
instance, but the Taxi, an

00:37:44.206 --> 00:37:45.526 A:middle
instance of Taxi.

00:37:46.066 --> 00:37:48.286 A:middle
This is great, but how does it

00:37:48.286 --> 00:37:48.456 A:middle
work?

00:37:49.596 --> 00:37:51.936 A:middle
So, let's take a look at what

00:37:51.936 --> 00:37:52.706 A:middle
Taxi might have.

00:37:52.706 --> 00:37:53.736 A:middle
Maybe there's an hourly rate

00:37:53.796 --> 00:37:55.076 A:middle
here, and when we call

00:37:55.076 --> 00:37:57.936 A:middle
Taxi.decode from, we're going

00:37:57.936 --> 00:37:58.946 A:middle
through the protocol, going

00:37:58.946 --> 00:38:00.296 A:middle
through the protocol initializer


00:37:58.946 --> 00:38:00.296 A:middle
through the protocol initializer

00:38:00.296 --> 00:38:02.186 A:middle
requirement, there's only one

00:38:02.186 --> 00:38:03.616 A:middle
initializer this can actually

00:38:03.616 --> 00:38:05.986 A:middle
call, and that's the initializer

00:38:05.986 --> 00:38:08.186 A:middle
that's declared inside the

00:38:08.186 --> 00:38:11.246 A:middle
Vehicle class, in the superclass

00:38:11.246 --> 00:38:11.396 A:middle
here.

00:38:12.926 --> 00:38:14.746 A:middle
So, that initializer, it knows

00:38:14.746 --> 00:38:16.186 A:middle
how to decode all of the state

00:38:16.316 --> 00:38:17.076 A:middle
of a Vehicle.

00:38:17.626 --> 00:38:18.806 A:middle
But, it knows nothing about the

00:38:18.806 --> 00:38:19.876 A:middle
Taxi subclass.

00:38:20.836 --> 00:38:22.076 A:middle
And so, if we were to use this

00:38:22.076 --> 00:38:23.226 A:middle
initializer directly, we would

00:38:23.226 --> 00:38:24.566 A:middle
actually have a problem that the

00:38:24.566 --> 00:38:26.096 A:middle
hourlyRate would be completely

00:38:26.096 --> 00:38:27.556 A:middle
uninitialized, which could lead

00:38:27.556 --> 00:38:28.736 A:middle
to some rather unfortunate

00:38:28.736 --> 00:38:29.996 A:middle
misunderstandings when you get

00:38:29.996 --> 00:38:30.756 A:middle
your bill at the end.

00:38:32.786 --> 00:38:33.916 A:middle
So, how do we address this?

00:38:34.066 --> 00:38:35.036 A:middle
Well, it turns out that Swift

00:38:35.106 --> 00:38:36.606 A:middle
doesn't let you get into this

00:38:36.656 --> 00:38:37.066 A:middle
problem.

00:38:37.856 --> 00:38:39.446 A:middle
It's going to diagnose at the

00:38:39.536 --> 00:38:40.866 A:middle
point where you try to make

00:38:40.866 --> 00:38:42.456 A:middle
Vehicle conform to the decodable

00:38:42.456 --> 00:38:43.906 A:middle
protocol that there's actually a

00:38:43.906 --> 00:38:45.216 A:middle
problem with this initializer.

00:38:45.306 --> 00:38:47.446 A:middle
It needs to be marked required.

00:38:48.126 --> 00:38:51.406 A:middle
Now, a required initializer has

00:38:51.406 --> 00:38:52.746 A:middle
to be implemented in all

00:38:52.746 --> 00:38:53.666 A:middle
subclasses.

00:38:53.956 --> 00:38:55.746 A:middle
Not just the direct subclasses,

00:38:55.996 --> 00:38:58.716 A:middle
but any subclasses of those, any

00:38:58.716 --> 00:39:00.356 A:middle
future subclasses you don't know


00:38:58.716 --> 00:39:00.356 A:middle
future subclasses you don't know

00:39:00.356 --> 00:39:00.866 A:middle
about now.

00:39:02.286 --> 00:39:03.656 A:middle
Now, by adding that requirement,

00:39:03.956 --> 00:39:06.376 A:middle
it means that when Taxi inherits

00:39:06.436 --> 00:39:08.646 A:middle
from Vehicle, it also needs to

00:39:08.646 --> 00:39:11.526 A:middle
introduce an initializer with

00:39:11.526 --> 00:39:12.246 A:middle
the same name.

00:39:13.056 --> 00:39:14.406 A:middle
Now, this is important because

00:39:14.406 --> 00:39:16.006 A:middle
this initializer's responsible

00:39:16.226 --> 00:39:18.406 A:middle
for decoding the hourlyRate, and

00:39:18.406 --> 00:39:19.136 A:middle
then chaining up to the

00:39:19.136 --> 00:39:21.296 A:middle
superclass initializer to decode

00:39:21.486 --> 00:39:23.326 A:middle
the rest of the Vehicle type.

00:39:25.226 --> 00:39:25.336 A:middle
OK.

00:39:26.666 --> 00:39:27.866 A:middle
Now, if you're reading those red

00:39:27.866 --> 00:39:29.606 A:middle
boxes really quickly, you may

00:39:29.606 --> 00:39:30.776 A:middle
have noticed the subphrase

00:39:31.406 --> 00:39:32.446 A:middle
non-final.

00:39:33.276 --> 00:39:35.326 A:middle
So, by definition, final classes

00:39:35.496 --> 00:39:36.946 A:middle
have no subclasses.

00:39:37.396 --> 00:39:38.546 A:middle
So, it essentially exempts them

00:39:38.546 --> 00:39:40.306 A:middle
from being substituted later on.

00:39:41.416 --> 00:39:43.926 A:middle
That means that there's no sense

00:39:43.926 --> 00:39:45.496 A:middle
in having a required initializer

00:39:45.496 --> 00:39:46.576 A:middle
because you know there are no

00:39:46.576 --> 00:39:47.326 A:middle
subclasses.

00:39:47.486 --> 00:39:48.606 A:middle
And so, final classes, they're

00:39:48.836 --> 00:39:50.006 A:middle
in a sense a little easier to

00:39:50.006 --> 00:39:51.016 A:middle
work with when dealing with

00:39:51.016 --> 00:39:52.246 A:middle
things like decodable or other

00:39:52.246 --> 00:39:53.576 A:middle
initializer requirements,

00:39:53.926 --> 00:39:54.886 A:middle
because they're exempt from

00:39:54.886 --> 00:39:56.216 A:middle
these rules of having required

00:39:56.216 --> 00:39:57.106 A:middle
initializers.

00:39:57.846 --> 00:40:00.216 A:middle
So, when you're using classes,


00:39:57.846 --> 00:40:00.216 A:middle
So, when you're using classes,

00:40:00.216 --> 00:40:01.266 A:middle
for reference semantics,

00:40:02.466 --> 00:40:04.376 A:middle
consider using final when you no

00:40:04.376 --> 00:40:05.756 A:middle
longer need to customize your

00:40:05.756 --> 00:40:07.676 A:middle
class through the inheritance

00:40:07.676 --> 00:40:07.976 A:middle
mechanism.

00:40:08.706 --> 00:40:10.306 A:middle
Now, this doesn't mean that you

00:40:10.686 --> 00:40:11.776 A:middle
can't customize your class

00:40:11.776 --> 00:40:12.066 A:middle
later.

00:40:12.296 --> 00:40:13.496 A:middle
You can still write an extension

00:40:13.496 --> 00:40:13.756 A:middle
on it.

00:40:14.066 --> 00:40:15.236 A:middle
The same way you can extend a

00:40:15.236 --> 00:40:16.216 A:middle
struct or an enum.

00:40:17.066 --> 00:40:18.426 A:middle
You can also add conformances to

00:40:18.426 --> 00:40:19.506 A:middle
it, to get more dynamic

00:40:19.506 --> 00:40:20.056 A:middle
dispatch.

00:40:21.436 --> 00:40:22.666 A:middle
But, final can simplify the

00:40:22.666 --> 00:40:23.596 A:middle
interaction with the generic

00:40:23.596 --> 00:40:25.016 A:middle
system, and also unlock

00:40:25.016 --> 00:40:26.326 A:middle
optimization opportunities for

00:40:26.326 --> 00:40:27.276 A:middle
the compiler in runtime.

00:40:27.866 --> 00:40:31.726 A:middle
So, we've talked a bit about

00:40:31.726 --> 00:40:32.636 A:middle
Swift generics today.

00:40:32.926 --> 00:40:34.406 A:middle
The idea behind Swift generics

00:40:34.406 --> 00:40:36.146 A:middle
is to provide the ability to

00:40:36.146 --> 00:40:38.046 A:middle
reuse code while maintaining

00:40:38.046 --> 00:40:39.896 A:middle
static type information, to make

00:40:39.896 --> 00:40:40.946 A:middle
it easier to write correct

00:40:40.946 --> 00:40:42.696 A:middle
programs, and compile those

00:40:42.696 --> 00:40:44.556 A:middle
down, into efficiently executing

00:40:44.896 --> 00:40:45.416 A:middle
programs.

00:40:46.166 --> 00:40:47.706 A:middle
When you're designing protocols,

00:40:48.106 --> 00:40:50.266 A:middle
let this push and pull between

00:40:50.266 --> 00:40:51.476 A:middle
the generic algorithms you want

00:40:51.476 --> 00:40:52.776 A:middle
to write against a protocol, and

00:40:53.116 --> 00:40:54.676 A:middle
the conforming types that need

00:40:54.676 --> 00:40:56.486 A:middle
to implement that protocol guide

00:40:56.486 --> 00:40:58.016 A:middle
your design to meaningful

00:40:58.016 --> 00:40:58.946 A:middle
extractions.


00:41:00.076 --> 00:41:01.716 A:middle
Introduce protocol inheritance

00:41:01.956 --> 00:41:03.146 A:middle
when you need some more

00:41:03.146 --> 00:41:04.696 A:middle
specialized capabilities to

00:41:04.696 --> 00:41:06.436 A:middle
implement new generic algorithms

00:41:06.656 --> 00:41:08.426 A:middle
that are only supportable on a

00:41:08.426 --> 00:41:10.036 A:middle
subset of the conforming types.

00:41:11.166 --> 00:41:12.556 A:middle
And, conditional conformance

00:41:12.886 --> 00:41:14.156 A:middle
when you're writing generic

00:41:14.266 --> 00:41:17.486 A:middle
types, so that they can compose

00:41:17.486 --> 00:41:19.016 A:middle
nicely, especially when working

00:41:19.016 --> 00:41:20.136 A:middle
with protocol hierarchies.

00:41:20.896 --> 00:41:21.726 A:middle
And finally, when you're

00:41:21.776 --> 00:41:23.096 A:middle
reasoning about the tricky

00:41:23.096 --> 00:41:24.566 A:middle
interaction between class

00:41:24.566 --> 00:41:25.946 A:middle
inheritance and the generic

00:41:25.946 --> 00:41:28.226 A:middle
system, go back to the Liskov

00:41:28.226 --> 00:41:29.746 A:middle
substitution principle, and

00:41:29.746 --> 00:41:32.476 A:middle
think about what happens here if

00:41:32.476 --> 00:41:34.296 A:middle
I introduce a subclass rather

00:41:34.296 --> 00:41:35.986 A:middle
than a superclass at which I

00:41:35.986 --> 00:41:36.846 A:middle
wrote the conformance.

00:41:39.256 --> 00:41:41.076 A:middle
Well, thank you very much.

00:41:41.306 --> 00:41:42.216 A:middle
There's a couple of related

00:41:42.216 --> 00:41:43.976 A:middle
sessions on embracing algorithms

00:41:43.976 --> 00:41:45.036 A:middle
and understanding how they can

00:41:45.036 --> 00:41:46.566 A:middle
help you build better code, as

00:41:46.566 --> 00:41:48.296 A:middle
well as using Swift collections

00:41:48.596 --> 00:41:50.046 A:middle
effectively in your everyday

00:41:50.046 --> 00:41:50.566 A:middle
programming.

00:41:50.566 --> 00:41:50.786 A:middle
Thank you.

00:41:51.516 --> 00:41:54.500 A:middle
[ Applause ]
