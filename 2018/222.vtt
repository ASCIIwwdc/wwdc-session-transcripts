WEBVTT

00:00:07.516 --> 00:00:14.500 A:middle
[ Music ]

00:00:22.516 --> 00:00:27.876 A:middle
[ Applause ]

00:00:28.376 --> 00:00:29.146 A:middle
&gt;&gt; Good morning, everyone.

00:00:30.056 --> 00:00:30.976 A:middle
Thank you all for joining me,

00:00:31.116 --> 00:00:32.256 A:middle
even before the coffee's kicked

00:00:32.256 --> 00:00:32.466 A:middle
in.

00:00:33.286 --> 00:00:34.696 A:middle
My name is Itai and I work on

00:00:34.696 --> 00:00:35.456 A:middle
the foundation team.

00:00:36.676 --> 00:00:37.556 A:middle
In this session, I'd like to

00:00:37.556 --> 00:00:39.106 A:middle
talk to you about how the data

00:00:39.106 --> 00:00:40.246 A:middle
that flows through your app can

00:00:40.246 --> 00:00:41.916 A:middle
affect it, and how you can

00:00:41.916 --> 00:00:43.336 A:middle
better protect your customers by

00:00:43.336 --> 00:00:44.806 A:middle
building trust in that data.

00:00:45.926 --> 00:00:46.526 A:middle
Let's get started.

00:00:47.116 --> 00:00:49.696 A:middle
Apps don't live in a vacuum.

00:00:50.536 --> 00:00:51.546 A:middle
In order for your apps to do

00:00:51.546 --> 00:00:52.946 A:middle
something useful, they have to

00:00:52.946 --> 00:00:54.286 A:middle
draw in data from external

00:00:54.286 --> 00:00:55.686 A:middle
sources, like the disc, or the

00:00:55.686 --> 00:00:56.846 A:middle
network, or your customers

00:00:56.846 --> 00:00:57.416 A:middle
themselves.

00:00:57.956 --> 00:00:59.156 A:middle
And then do something meaningful

00:00:59.156 --> 00:01:00.656 A:middle
with that data, and then present


00:00:59.156 --> 00:01:00.656 A:middle
with that data, and then present

00:01:00.656 --> 00:01:01.466 A:middle
it to your customers.

00:01:02.886 --> 00:01:04.006 A:middle
In order for that data to be

00:01:04.226 --> 00:01:05.856 A:middle
consumable, it has to come in

00:01:05.856 --> 00:01:07.416 A:middle
some known format or structure.

00:01:08.756 --> 00:01:11.796 A:middle
What happens when it doesn't?

00:01:11.886 --> 00:01:13.776 A:middle
Usually, this means the data is

00:01:13.776 --> 00:01:15.326 A:middle
corrupted, or invalid in some

00:01:15.326 --> 00:01:16.196 A:middle
way and can be ignored.

00:01:17.566 --> 00:01:19.486 A:middle
But sometimes, this data can

00:01:19.856 --> 00:01:21.296 A:middle
invalidate assumptions that your

00:01:21.296 --> 00:01:23.346 A:middle
app makes, and it can cause your

00:01:23.346 --> 00:01:25.326 A:middle
app to misbehave, or maybe even

00:01:25.326 --> 00:01:25.746 A:middle
crash.

00:01:26.386 --> 00:01:29.126 A:middle
This can be a bad experience for

00:01:29.126 --> 00:01:30.506 A:middle
your customers who might have to

00:01:30.506 --> 00:01:32.056 A:middle
wait for your app to get updated

00:01:32.056 --> 00:01:32.706 A:middle
in the app store.

00:01:33.566 --> 00:01:34.556 A:middle
And it's an even worse

00:01:34.556 --> 00:01:36.076 A:middle
experience if it's a crash on

00:01:36.076 --> 00:01:37.436 A:middle
launch, because they can't even

00:01:37.436 --> 00:01:38.076 A:middle
use the app.

00:01:38.666 --> 00:01:39.896 A:middle
And, in the meantime, while

00:01:39.896 --> 00:01:41.176 A:middle
you're waiting, you'll get a

00:01:41.176 --> 00:01:42.386 A:middle
wave of one-star reviews.

00:01:43.126 --> 00:01:43.996 A:middle
It's a bad experience for

00:01:43.996 --> 00:01:44.306 A:middle
everyone.

00:01:46.136 --> 00:01:47.386 A:middle
This is something to be even

00:01:47.386 --> 00:01:48.736 A:middle
more cognizant of, if you're a

00:01:48.736 --> 00:01:49.486 A:middle
framework author.

00:01:50.056 --> 00:01:51.356 A:middle
Because it's not just one app

00:01:51.486 --> 00:01:52.706 A:middle
that could possibly be affected,

00:01:53.026 --> 00:01:54.776 A:middle
but maybe many apps.

00:01:56.416 --> 00:01:57.626 A:middle
Today, we're going to be talking

00:01:57.626 --> 00:01:58.276 A:middle
about trust.

00:01:59.186 --> 00:02:00.236 A:middle
And specifically, we're going to


00:01:59.186 --> 00:02:00.236 A:middle
And specifically, we're going to

00:02:00.236 --> 00:02:02.026 A:middle
be talking about how to build

00:02:02.026 --> 00:02:03.886 A:middle
trust in data, by making sure of

00:02:03.886 --> 00:02:04.406 A:middle
two things.

00:02:05.796 --> 00:02:07.026 A:middle
One, that the data that we're

00:02:07.026 --> 00:02:08.166 A:middle
going to be using, hasn't been

00:02:08.166 --> 00:02:10.726 A:middle
modified from underneath us, and

00:02:10.726 --> 00:02:12.266 A:middle
two that it contains what we

00:02:12.266 --> 00:02:14.236 A:middle
expect it to in the format and

00:02:14.236 --> 00:02:15.066 A:middle
structure that we want.

00:02:16.676 --> 00:02:19.266 A:middle
So, we'll do just that by taking

00:02:19.266 --> 00:02:20.816 A:middle
a look at the lifecycle of our

00:02:20.816 --> 00:02:22.786 A:middle
data, and what we can validate

00:02:22.786 --> 00:02:24.526 A:middle
about that data at every stage

00:02:24.526 --> 00:02:25.146 A:middle
in the lifecycle.

00:02:26.726 --> 00:02:28.836 A:middle
Then, we'll see what sort of

00:02:28.836 --> 00:02:30.286 A:middle
type-level validation we can

00:02:30.286 --> 00:02:31.606 A:middle
apply with the NS Secure coding

00:02:31.606 --> 00:02:32.016 A:middle
protocol.

00:02:32.096 --> 00:02:33.986 A:middle
And then apply those same

00:02:33.986 --> 00:02:35.626 A:middle
concepts to codable types.

00:02:37.116 --> 00:02:40.256 A:middle
Let's get started.

00:02:40.366 --> 00:02:41.536 A:middle
In order to talk about data,

00:02:41.656 --> 00:02:42.576 A:middle
we're going to want to build a

00:02:42.576 --> 00:02:44.426 A:middle
mental model of the forms that

00:02:44.426 --> 00:02:46.426 A:middle
data can take within our app.

00:02:47.566 --> 00:02:49.626 A:middle
At the most basic level, data

00:02:49.626 --> 00:02:51.786 A:middle
makes its way into our app as a

00:02:51.786 --> 00:02:52.756 A:middle
stream of bites.

00:02:54.336 --> 00:02:55.396 A:middle
There's not much we can tell

00:02:55.396 --> 00:02:56.426 A:middle
about this data at this stage

00:02:56.426 --> 00:02:58.156 A:middle
without looking at it, but this

00:02:58.156 --> 00:03:00.976 A:middle
we'll call raw data.


00:02:58.156 --> 00:03:00.976 A:middle
we'll call raw data.

00:03:01.646 --> 00:03:03.416 A:middle
Now, to get working with that

00:03:03.416 --> 00:03:04.466 A:middle
data, we need to make sure it

00:03:04.536 --> 00:03:06.276 A:middle
conforms to that known format or

00:03:06.276 --> 00:03:06.756 A:middle
structure.

00:03:07.406 --> 00:03:08.946 A:middle
And in this case, each of those

00:03:08.946 --> 00:03:10.906 A:middle
code points correspond into a

00:03:11.006 --> 00:03:13.426 A:middle
UTF code point, and sorry, one

00:03:13.426 --> 00:03:14.186 A:middle
moment, let me make that a

00:03:14.186 --> 00:03:14.876 A:middle
little bit more readable.

00:03:15.416 --> 00:03:16.496 A:middle
It looks like this is JSON.

00:03:17.036 --> 00:03:18.946 A:middle
And so, once we've made sure

00:03:18.946 --> 00:03:20.336 A:middle
that that data conforms to some

00:03:20.336 --> 00:03:21.266 A:middle
format that we want to work

00:03:21.266 --> 00:03:23.106 A:middle
with, we'll call this formatted

00:03:24.506 --> 00:03:24.626 A:middle
data.

00:03:24.976 --> 00:03:26.536 A:middle
Now, formatted data, on its own

00:03:26.896 --> 00:03:28.176 A:middle
doesn't mean much, until we

00:03:28.286 --> 00:03:29.836 A:middle
create primitive values out of

00:03:29.836 --> 00:03:31.366 A:middle
it, strings, and arrays, and

00:03:31.366 --> 00:03:32.676 A:middle
dictionaries that we can then

00:03:32.676 --> 00:03:34.246 A:middle
use as building blocks for

00:03:34.246 --> 00:03:35.036 A:middle
further algorithms.

00:03:35.556 --> 00:03:36.816 A:middle
So, this we'll call our

00:03:36.816 --> 00:03:38.076 A:middle
primitive data.

00:03:39.086 --> 00:03:40.696 A:middle
Now, there's building blocks we

00:03:40.696 --> 00:03:41.876 A:middle
most often want to work with,

00:03:41.946 --> 00:03:43.566 A:middle
not as just primitive values,

00:03:43.936 --> 00:03:45.296 A:middle
but as our own model types.

00:03:46.546 --> 00:03:47.996 A:middle
So, once we do that, we'll make

00:03:48.056 --> 00:03:49.456 A:middle
use of this as we're going to

00:03:49.456 --> 00:03:51.376 A:middle
call, structure data.

00:03:52.016 --> 00:03:54.166 A:middle
Now, these forms of data in our

00:03:54.316 --> 00:03:56.876 A:middle
apps, form an abstraction

00:03:57.346 --> 00:03:57.826 A:middle
timeline.

00:03:59.076 --> 00:04:00.826 A:middle
Raw data is the least abstract


00:03:59.076 --> 00:04:00.826 A:middle
Raw data is the least abstract

00:04:00.826 --> 00:04:01.846 A:middle
data that we're going to work

00:04:01.846 --> 00:04:03.306 A:middle
with, and our own structured

00:04:03.306 --> 00:04:04.386 A:middle
model types are the most

00:04:04.386 --> 00:04:04.916 A:middle
abstract.

00:04:05.476 --> 00:04:07.266 A:middle
So, our goal for today is to

00:04:07.266 --> 00:04:08.736 A:middle
take that data as far along the

00:04:08.736 --> 00:04:09.916 A:middle
spectrum as we can.

00:04:10.546 --> 00:04:12.096 A:middle
Now, our apps can stop at any

00:04:12.096 --> 00:04:13.256 A:middle
point, make use of the data,

00:04:13.296 --> 00:04:14.156 A:middle
however, we see fit.

00:04:14.256 --> 00:04:15.566 A:middle
But we really want to work with

00:04:15.566 --> 00:04:16.846 A:middle
our own model types wherever

00:04:16.846 --> 00:04:17.286 A:middle
possible.

00:04:18.356 --> 00:04:19.995 A:middle
Now, the goal for today is to

00:04:19.995 --> 00:04:21.696 A:middle
not just go as far along the

00:04:21.696 --> 00:04:23.076 A:middle
abstraction spectrum as we can,

00:04:23.316 --> 00:04:25.546 A:middle
but to build trust as we do so.

00:04:26.466 --> 00:04:27.516 A:middle
At every stage, the data is

00:04:27.516 --> 00:04:28.716 A:middle
going to get more complicated,

00:04:28.786 --> 00:04:30.216 A:middle
and there's going to be more

00:04:30.216 --> 00:04:31.346 A:middle
that we need to validate about

00:04:31.346 --> 00:04:31.413 A:middle
it.

00:04:31.413 --> 00:04:32.966 A:middle
But once we do that, there's

00:04:32.966 --> 00:04:33.836 A:middle
also going to be more that we

00:04:33.836 --> 00:04:35.696 A:middle
can trust about it.

00:04:36.116 --> 00:04:37.686 A:middle
Now, for our use case today,

00:04:37.686 --> 00:04:38.596 A:middle
we're not really going to be

00:04:38.596 --> 00:04:39.696 A:middle
talking about formatted data.

00:04:40.046 --> 00:04:41.626 A:middle
Very often it's just a stepping

00:04:41.626 --> 00:04:42.956 A:middle
stone between raw and primitive

00:04:42.956 --> 00:04:43.916 A:middle
data, and you don't work with it

00:04:43.916 --> 00:04:44.326 A:middle
directly.

00:04:45.256 --> 00:04:47.606 A:middle
For instance, given raw data,

00:04:47.746 --> 00:04:49.256 A:middle
foundations JSON serialization

00:04:49.256 --> 00:04:50.256 A:middle
will give you primitive data

00:04:50.256 --> 00:04:50.516 A:middle
back.

00:04:50.876 --> 00:04:52.276 A:middle
You don't see just the formatted

00:04:52.276 --> 00:04:53.206 A:middle
date directly, and you won't

00:04:53.206 --> 00:04:54.766 A:middle
make use of it.

00:04:54.976 --> 00:04:56.066 A:middle
So, today we'll just be talking

00:04:56.066 --> 00:04:57.676 A:middle
about raw, primitive, and

00:04:57.676 --> 00:04:58.256 A:middle
structured data.


00:05:00.186 --> 00:05:01.186 A:middle
Now, let's start by talking

00:05:01.186 --> 00:05:01.776 A:middle
about raw data.

00:05:02.836 --> 00:05:04.996 A:middle
Again, as we mentioned, raw data

00:05:04.996 --> 00:05:06.486 A:middle
is just a stream of bytes that's

00:05:06.486 --> 00:05:08.496 A:middle
made its way into your app.

00:05:08.496 --> 00:05:10.296 A:middle
Until you inspect that data and

00:05:10.296 --> 00:05:11.586 A:middle
you give it meaning, there's not

00:05:11.586 --> 00:05:13.266 A:middle
much you can do with it.

00:05:13.766 --> 00:05:15.686 A:middle
Now, we might care to know what

00:05:15.716 --> 00:05:17.316 A:middle
we can take a look at about that

00:05:17.316 --> 00:05:18.296 A:middle
data before we start

00:05:18.296 --> 00:05:18.906 A:middle
interpreting it.

00:05:19.366 --> 00:05:20.466 A:middle
Is it even safe to do that?

00:05:22.016 --> 00:05:23.106 A:middle
One thing we can validate about

00:05:23.106 --> 00:05:24.476 A:middle
this data before making use of

00:05:24.476 --> 00:05:25.146 A:middle
it is its length.

00:05:26.306 --> 00:05:27.776 A:middle
Say your app expects to load a

00:05:27.776 --> 00:05:29.396 A:middle
1-kilobyte file from disc, but

00:05:29.396 --> 00:05:31.096 A:middle
finds a 1-gigabyte file in disc.

00:05:32.226 --> 00:05:33.376 A:middle
Does it make sense to even load

00:05:33.376 --> 00:05:34.436 A:middle
that data in the first place,

00:05:34.436 --> 00:05:35.176 A:middle
and start reading it?

00:05:36.016 --> 00:05:38.366 A:middle
Almost certainly not.

00:05:38.666 --> 00:05:39.736 A:middle
Now, sometimes we might not be

00:05:39.736 --> 00:05:41.216 A:middle
able to have length expectations

00:05:41.216 --> 00:05:41.796 A:middle
about the data.

00:05:42.286 --> 00:05:43.476 A:middle
Maybe it's external data we

00:05:43.476 --> 00:05:43.956 A:middle
don't own.

00:05:43.956 --> 00:05:44.906 A:middle
We don't' know how much data

00:05:44.906 --> 00:05:45.426 A:middle
there could be.

00:05:46.366 --> 00:05:48.336 A:middle
But in some cases, we might also

00:05:48.336 --> 00:05:49.966 A:middle
be able to verify a checksum, or

00:05:49.966 --> 00:05:51.436 A:middle
a cryptographic signature that

00:05:51.716 --> 00:05:53.336 A:middle
represents what the data might

00:05:53.336 --> 00:05:54.346 A:middle
look like, even if we don't know

00:05:54.346 --> 00:05:54.956 A:middle
what's inside.

00:05:56.046 --> 00:05:57.516 A:middle
Checksum is built by hashing all

00:05:57.516 --> 00:05:57.956 A:middle
of the data.

00:05:58.056 --> 00:05:59.836 A:middle
And if any bit in the data

00:05:59.836 --> 00:06:01.196 A:middle
changes, either due to a


00:05:59.836 --> 00:06:01.196 A:middle
changes, either due to a

00:06:01.196 --> 00:06:02.726 A:middle
potential malicious third party,

00:06:03.166 --> 00:06:04.796 A:middle
or just regular data corruption,

00:06:04.796 --> 00:06:06.196 A:middle
bad blocks on disc, a bad

00:06:06.196 --> 00:06:06.946 A:middle
network connection.

00:06:07.306 --> 00:06:08.996 A:middle
If any one of the bits flips in

00:06:08.996 --> 00:06:10.906 A:middle
that data, it will invalidate

00:06:10.906 --> 00:06:12.216 A:middle
the checksum, or the signature.

00:06:12.556 --> 00:06:13.516 A:middle
And we'll know before even

00:06:13.516 --> 00:06:15.016 A:middle
reading any of those bytes, that

00:06:15.016 --> 00:06:16.456 A:middle
the data is incorrect, and you

00:06:16.456 --> 00:06:18.746 A:middle
shouldn't trust it.

00:06:19.396 --> 00:06:21.106 A:middle
Now, we also don't always have a

00:06:21.106 --> 00:06:21.576 A:middle
checksum.

00:06:21.576 --> 00:06:22.706 A:middle
Maybe it's data we don't own,

00:06:22.706 --> 00:06:23.606 A:middle
where you can't get that ahead

00:06:23.606 --> 00:06:23.986 A:middle
of time.

00:06:23.986 --> 00:06:25.706 A:middle
So, at this stage, there isn't

00:06:25.706 --> 00:06:27.146 A:middle
much we can do with this data,

00:06:27.826 --> 00:06:29.186 A:middle
besides read it and inspect it.

00:06:29.186 --> 00:06:32.346 A:middle
And so, once we do that, we can

00:06:32.346 --> 00:06:34.376 A:middle
get primitive data out.

00:06:34.736 --> 00:06:36.286 A:middle
Now, as we've mentioned, we can

00:06:36.286 --> 00:06:38.036 A:middle
take that raw data and pass it

00:06:38.036 --> 00:06:39.576 A:middle
through, usually deserialize it,

00:06:39.636 --> 00:06:40.616 A:middle
like foundations JSON

00:06:40.616 --> 00:06:41.316 A:middle
serialization.

00:06:42.856 --> 00:06:44.156 A:middle
When we do that, we'll get inert

00:06:44.156 --> 00:06:45.556 A:middle
strings and dictionaries and

00:06:45.556 --> 00:06:46.846 A:middle
arrays of numbers back out that

00:06:46.846 --> 00:06:47.456 A:middle
we can use.

00:06:47.666 --> 00:06:49.406 A:middle
And if this process exceeds, we

00:06:49.406 --> 00:06:50.596 A:middle
know two things about that data.

00:06:52.316 --> 00:06:53.716 A:middle
One, that the data was indeed in

00:06:53.716 --> 00:06:54.656 A:middle
the correct format that we

00:06:54.656 --> 00:06:55.126 A:middle
expected.

00:06:55.306 --> 00:06:56.696 A:middle
For instance, XML data won't

00:06:56.696 --> 00:06:58.096 A:middle
pass through JSON serialization.

00:06:58.736 --> 00:07:00.936 A:middle
And two, if we trust the


00:06:58.736 --> 00:07:00.936 A:middle
And two, if we trust the

00:07:00.936 --> 00:07:03.386 A:middle
deserializer, we know that the

00:07:03.386 --> 00:07:04.966 A:middle
run-time objects we get back out

00:07:04.966 --> 00:07:05.806 A:middle
are going to be valid.

00:07:06.476 --> 00:07:07.746 A:middle
Again, foundations JSON

00:07:07.746 --> 00:07:08.906 A:middle
serialization will always give

00:07:08.906 --> 00:07:09.976 A:middle
you strings and numbers and

00:07:09.976 --> 00:07:11.186 A:middle
arrays that you can actually

00:07:11.186 --> 00:07:11.436 A:middle
work with.

00:07:12.156 --> 00:07:13.586 A:middle
It's individual values that we

00:07:13.586 --> 00:07:14.076 A:middle
can trust.

00:07:14.596 --> 00:07:16.746 A:middle
But at this stage, we might

00:07:16.746 --> 00:07:18.796 A:middle
wonder okay how can we make use

00:07:18.796 --> 00:07:19.826 A:middle
of this data, or what can we

00:07:19.826 --> 00:07:21.106 A:middle
trust about it, and what

00:07:21.106 --> 00:07:22.416 A:middle
validation do we still need to

00:07:23.746 --> 00:07:23.813 A:middle
do?

00:07:24.736 --> 00:07:26.376 A:middle
Well, we don't actually know

00:07:26.646 --> 00:07:28.006 A:middle
much about the contents of this

00:07:28.006 --> 00:07:29.486 A:middle
data yet until we start looking

00:07:29.486 --> 00:07:29.696 A:middle
at it.

00:07:29.696 --> 00:07:31.506 A:middle
And in fact, we might not know

00:07:31.506 --> 00:07:32.706 A:middle
anything about the structure of

00:07:32.706 --> 00:07:33.966 A:middle
the data until we start

00:07:33.966 --> 00:07:34.556 A:middle
inspecting it.

00:07:34.956 --> 00:07:36.066 A:middle
If you've ever worked with

00:07:36.066 --> 00:07:37.496 A:middle
dynamic deserialization in this

00:07:37.496 --> 00:07:38.216 A:middle
way, you'll know that there's a

00:07:38.216 --> 00:07:39.666 A:middle
lot of downcasting from anys.

00:07:40.466 --> 00:07:41.946 A:middle
There's no upfront expectation

00:07:41.946 --> 00:07:42.866 A:middle
what the data can be because

00:07:42.866 --> 00:07:43.796 A:middle
it's very generalized.

00:07:44.326 --> 00:07:45.396 A:middle
And so, we'll want to check to

00:07:45.396 --> 00:07:47.256 A:middle
see what the data contains and

00:07:47.256 --> 00:07:47.906 A:middle
how we can work with it.

00:07:49.166 --> 00:07:50.586 A:middle
So, let's motivate this with an

00:07:50.586 --> 00:07:50.966 A:middle
example.

00:07:51.896 --> 00:07:52.896 A:middle
I've been working with an app

00:07:52.896 --> 00:07:54.406 A:middle
lately called Sell My Old Junk,

00:07:54.826 --> 00:07:56.686 A:middle
which allows me to sell my old

00:07:56.686 --> 00:07:57.946 A:middle
junk to some friends and family.

00:07:58.396 --> 00:07:59.986 A:middle
And when one of them opens up my


00:08:00.106 --> 00:08:02.716 A:middle
app, my app makes a request to

00:08:02.716 --> 00:08:03.256 A:middle
my server.

00:08:03.966 --> 00:08:05.876 A:middle
Which requests a list of

00:08:05.926 --> 00:08:06.986 A:middle
products that are currently

00:08:06.986 --> 00:08:08.166 A:middle
available for sale to my friends

00:08:08.166 --> 00:08:08.546 A:middle
and family.

00:08:09.646 --> 00:08:11.156 A:middle
When the server receives this

00:08:11.156 --> 00:08:12.636 A:middle
request, it responses with JSON,

00:08:13.026 --> 00:08:13.986 A:middle
that indicates here are the

00:08:13.986 --> 00:08:16.576 A:middle
products available to sell.

00:08:17.296 --> 00:08:18.956 A:middle
Now, this is what an API

00:08:18.956 --> 00:08:20.186 A:middle
response from my server might

00:08:20.186 --> 00:08:20.576 A:middle
look like.

00:08:21.576 --> 00:08:22.606 A:middle
It's an array of product

00:08:22.606 --> 00:08:23.836 A:middle
listings, which have some

00:08:23.836 --> 00:08:24.716 A:middle
interesting fields that you

00:08:24.716 --> 00:08:25.516 A:middle
might care to look at.

00:08:26.766 --> 00:08:29.116 A:middle
For instance, each listing has a

00:08:29.366 --> 00:08:29.986 A:middle
product ID.

00:08:30.166 --> 00:08:31.776 A:middle
A positive integer that uniquely

00:08:31.776 --> 00:08:32.686 A:middle
identifies the product.

00:08:33.076 --> 00:08:34.275 A:middle
And in my case, these are

00:08:34.275 --> 00:08:35.986 A:middle
sequential integer IDs.

00:08:37.346 --> 00:08:38.905 A:middle
Every listing also has a name

00:08:38.905 --> 00:08:39.706 A:middle
and a description which are

00:08:39.706 --> 00:08:40.196 A:middle
strings.

00:08:40.196 --> 00:08:41.306 A:middle
And there are a few other type

00:08:41.306 --> 00:08:42.366 A:middle
fields here that we might care

00:08:42.366 --> 00:08:42.756 A:middle
to look at.

00:08:43.846 --> 00:08:45.216 A:middle
For instance, there's a field

00:08:45.386 --> 00:08:46.506 A:middle
that's a Boolean that indicates

00:08:46.506 --> 00:08:47.586 A:middle
whether or not this listing has

00:08:47.586 --> 00:08:48.236 A:middle
already been sold.

00:08:48.796 --> 00:08:50.716 A:middle
And there's some internal

00:08:50.716 --> 00:08:51.386 A:middle
structure here.

00:08:51.476 --> 00:08:52.626 A:middle
This list of tags, which are

00:08:52.626 --> 00:08:53.726 A:middle
strings, which we might care to

00:08:53.726 --> 00:08:54.066 A:middle
use.

00:08:55.496 --> 00:08:57.216 A:middle
There are also a few fields

00:08:57.216 --> 00:08:58.256 A:middle
here, which come to us as

00:08:58.256 --> 00:08:59.736 A:middle
strings, but really represent

00:08:59.806 --> 00:09:01.026 A:middle
other forms of data that we


00:08:59.806 --> 00:09:01.026 A:middle
other forms of data that we

00:09:01.026 --> 00:09:01.676 A:middle
might care to look at.

00:09:02.136 --> 00:09:04.376 A:middle
For instance, URLs and dates.

00:09:05.116 --> 00:09:06.736 A:middle
So, let's make use of this data.

00:09:07.856 --> 00:09:09.876 A:middle
In my app, I can fetch that data

00:09:09.876 --> 00:09:11.156 A:middle
from the network say with URL

00:09:11.156 --> 00:09:12.776 A:middle
session, and wherever possible

00:09:12.776 --> 00:09:13.716 A:middle
I'll validate the length.

00:09:13.716 --> 00:09:15.026 A:middle
Maybe my server can produce a

00:09:15.056 --> 00:09:16.136 A:middle
checksum that I can validate.

00:09:16.196 --> 00:09:17.416 A:middle
Or a cryptographic signature.

00:09:17.986 --> 00:09:21.236 A:middle
Once I've done that, I can take

00:09:21.266 --> 00:09:22.906 A:middle
the data and pass it off JSON

00:09:22.906 --> 00:09:23.586 A:middle
serialization.

00:09:24.626 --> 00:09:26.286 A:middle
If deserializing the data fails,

00:09:26.546 --> 00:09:27.816 A:middle
JSON serialization will throw an

00:09:27.816 --> 00:09:28.086 A:middle
error.

00:09:28.196 --> 00:09:29.316 A:middle
Will check and then catch and

00:09:29.316 --> 00:09:29.616 A:middle
handle.

00:09:30.026 --> 00:09:31.216 A:middle
May display dialogue to my

00:09:31.216 --> 00:09:31.726 A:middle
customers.

00:09:32.936 --> 00:09:34.876 A:middle
Again, in our purlins of the

00:09:34.876 --> 00:09:36.536 A:middle
day, we've just taken raw data

00:09:37.076 --> 00:09:38.116 A:middle
and carried along it the

00:09:38.116 --> 00:09:39.486 A:middle
abstraction spectrum to

00:09:39.486 --> 00:09:40.056 A:middle
primitive data.

00:09:40.746 --> 00:09:41.786 A:middle
And if anything went wrong, we

00:09:41.786 --> 00:09:42.696 A:middle
can handle that failure.

00:09:44.016 --> 00:09:45.576 A:middle
So, now we need to make use of

00:09:45.576 --> 00:09:45.936 A:middle
this data.

00:09:46.106 --> 00:09:47.026 A:middle
How can we consume it?

00:09:47.786 --> 00:09:49.856 A:middle
Well, JSON is an any variable

00:09:49.856 --> 00:09:51.246 A:middle
that contains the actual values.

00:09:52.006 --> 00:09:53.586 A:middle
So, I can downcast it to the

00:09:53.586 --> 00:09:54.566 A:middle
array of dictionaries that I

00:09:54.566 --> 00:09:55.306 A:middle
expect it to be.

00:09:56.556 --> 00:09:57.866 A:middle
Now, this part of my app cares

00:09:57.866 --> 00:09:58.956 A:middle
only about product listings that

00:09:58.956 --> 00:09:59.706 A:middle
are related to music.


00:10:00.446 --> 00:10:02.126 A:middle
So, will filter out any products

00:10:02.126 --> 00:10:03.246 A:middle
that don't contain the music

00:10:03.246 --> 00:10:03.546 A:middle
tag.

00:10:03.546 --> 00:10:04.676 A:middle
And here, I have that

00:10:04.676 --> 00:10:05.316 A:middle
substructure.

00:10:05.316 --> 00:10:06.416 A:middle
That list of tags, which will

00:10:06.416 --> 00:10:08.256 A:middle
downcast an array of strings and

00:10:08.256 --> 00:10:11.386 A:middle
make use of it, right.

00:10:11.596 --> 00:10:14.696 A:middle
Whoops. Each of those forced

00:10:14.696 --> 00:10:16.176 A:middle
downcasts, actually contains a

00:10:16.176 --> 00:10:17.146 A:middle
hidden fatal error.

00:10:18.236 --> 00:10:19.736 A:middle
If either of those casts fails

00:10:20.046 --> 00:10:21.996 A:middle
because the API changed or the

00:10:21.996 --> 00:10:23.326 A:middle
data changed along the way

00:10:23.326 --> 00:10:24.506 A:middle
before it made into my app,

00:10:24.586 --> 00:10:26.266 A:middle
again due to data corruption or

00:10:26.266 --> 00:10:28.496 A:middle
malicious changing, those

00:10:28.496 --> 00:10:29.486 A:middle
downcasts will fail.

00:10:29.516 --> 00:10:31.566 A:middle
And when they do fail, they'll

00:10:31.876 --> 00:10:33.136 A:middle
abort, and they'll crash my app.

00:10:33.206 --> 00:10:34.006 A:middle
And again, that's a bad

00:10:34.006 --> 00:10:35.226 A:middle
experience for my customers.

00:10:35.656 --> 00:10:37.526 A:middle
Let's take a look at how this

00:10:37.526 --> 00:10:37.976 A:middle
could happen.

00:10:38.986 --> 00:10:40.266 A:middle
So, here again is that sample

00:10:40.476 --> 00:10:41.336 A:middle
API response.

00:10:42.166 --> 00:10:43.466 A:middle
And we'll take a look at the

00:10:43.466 --> 00:10:44.466 A:middle
list of tags here.

00:10:45.216 --> 00:10:47.616 A:middle
And say that second tag in there

00:10:48.146 --> 00:10:48.806 A:middle
is modified.

00:10:49.506 --> 00:10:50.966 A:middle
Instead of a string, we have a

00:10:50.966 --> 00:10:51.346 A:middle
number.

00:10:51.636 --> 00:10:52.796 A:middle
It's maliciously changed by a

00:10:52.796 --> 00:10:54.146 A:middle
third-party, or maybe again due

00:10:54.146 --> 00:10:55.206 A:middle
to regular data corruption.

00:10:55.206 --> 00:10:57.666 A:middle
We can't always tell.

00:10:57.876 --> 00:10:59.836 A:middle
Downcasting this list of tags


00:11:00.126 --> 00:11:01.646 A:middle
will fail because they're not

00:11:01.646 --> 00:11:03.246 A:middle
strings and we never checked to

00:11:03.376 --> 00:11:04.516 A:middle
make sure they work before we

00:11:04.516 --> 00:11:04.846 A:middle
cast.

00:11:06.706 --> 00:11:08.206 A:middle
So, to avoid this, our main

00:11:08.206 --> 00:11:09.476 A:middle
tenant for the day will always

00:11:09.476 --> 00:11:11.616 A:middle
be validate first, execute

00:11:11.616 --> 00:11:11.886 A:middle
later.

00:11:13.186 --> 00:11:14.216 A:middle
Instead of asserting that you

00:11:14.216 --> 00:11:15.206 A:middle
know what the structure of the

00:11:15.206 --> 00:11:16.776 A:middle
data is, check first.

00:11:17.436 --> 00:11:18.436 A:middle
Don't blindly assume.

00:11:19.426 --> 00:11:20.246 A:middle
So, let's see how we can do

00:11:20.246 --> 00:11:21.316 A:middle
that.

00:11:21.646 --> 00:11:22.926 A:middle
So, here again is that first

00:11:22.926 --> 00:11:23.926 A:middle
forced downcast.

00:11:24.266 --> 00:11:25.376 A:middle
And instead of forcibly

00:11:25.376 --> 00:11:27.646 A:middle
downcasting these values, I can

00:11:27.646 --> 00:11:29.466 A:middle
conditionally downcast.

00:11:32.336 --> 00:11:35.756 A:middle
This allows me to validate that

00:11:35.756 --> 00:11:37.366 A:middle
the data actually contains what

00:11:37.366 --> 00:11:39.696 A:middle
I want and if that cast fails,

00:11:40.716 --> 00:11:41.936 A:middle
well I can handle that error

00:11:41.936 --> 00:11:42.966 A:middle
instead of fatally erroring.

00:11:44.486 --> 00:11:45.666 A:middle
Now, similarly, later

00:11:46.306 --> 00:11:47.476 A:middle
downcasting that list of

00:11:47.476 --> 00:11:49.136 A:middle
strings, instead of forcibly

00:11:49.136 --> 00:11:50.766 A:middle
downcasting, again I can

00:11:50.766 --> 00:11:52.106 A:middle
conditionally downcast.

00:11:52.536 --> 00:11:53.596 A:middle
And in this case, instead of

00:11:53.666 --> 00:11:55.396 A:middle
throwing an error, I can give a

00:11:55.396 --> 00:11:56.606 A:middle
default value that allows

00:11:56.606 --> 00:11:57.696 A:middle
execution to continue.

00:11:57.846 --> 00:11:59.526 A:middle
In this case, I'll simply ignore

00:11:59.526 --> 00:12:01.046 A:middle
any product listings that don't


00:11:59.526 --> 00:12:01.046 A:middle
any product listings that don't

00:12:01.046 --> 00:12:02.416 A:middle
have a valid list of tags.

00:12:03.226 --> 00:12:04.336 A:middle
I could throw an error, but in

00:12:04.336 --> 00:12:07.356 A:middle
this case, I chose not to.

00:12:07.876 --> 00:12:09.456 A:middle
Now, type validation isn't the

00:12:09.456 --> 00:12:10.986 A:middle
only form of validation that you

00:12:10.986 --> 00:12:12.546 A:middle
want to perform at this stage.

00:12:13.106 --> 00:12:14.986 A:middle
For instance, if that had been

00:12:14.986 --> 00:12:16.266 A:middle
replaced by null, which is

00:12:16.266 --> 00:12:18.856 A:middle
totally valid in JSON, I

00:12:19.096 --> 00:12:20.556 A:middle
would've seen a similar crash.

00:12:21.876 --> 00:12:23.876 A:middle
In Swift strong static type

00:12:23.876 --> 00:12:25.176 A:middle
system nullability is part of

00:12:25.176 --> 00:12:25.556 A:middle
the type.

00:12:25.556 --> 00:12:27.346 A:middle
And indeed, you can't downcast

00:12:27.346 --> 00:12:28.166 A:middle
null to a string.

00:12:28.616 --> 00:12:30.416 A:middle
And so, again, this cast would

00:12:30.806 --> 00:12:32.356 A:middle
have failed.

00:12:32.896 --> 00:12:34.696 A:middle
Now, even if all of these values

00:12:34.696 --> 00:12:35.746 A:middle
are of the correct type and

00:12:35.746 --> 00:12:37.186 A:middle
nullability, there's other forms

00:12:37.186 --> 00:12:38.136 A:middle
of validations that we should

00:12:38.136 --> 00:12:38.786 A:middle
care about here.

00:12:39.626 --> 00:12:41.236 A:middle
For instance, I said that each

00:12:41.296 --> 00:12:42.666 A:middle
product listing has a positive

00:12:42.666 --> 00:12:43.196 A:middle
integer ID.

00:12:43.196 --> 00:12:44.246 A:middle
In my case, they're all

00:12:44.246 --> 00:12:45.296 A:middle
sequential integers.

00:12:45.966 --> 00:12:47.076 A:middle
Does it make sense for one of

00:12:47.076 --> 00:12:48.216 A:middle
these IDs to be negative?

00:12:49.206 --> 00:12:49.926 A:middle
No, it doesn't.

00:12:49.926 --> 00:12:51.366 A:middle
But even if it is always

00:12:51.366 --> 00:12:53.026 A:middle
positive, does it make sense for

00:12:53.026 --> 00:12:54.486 A:middle
it to be such a large positive

00:12:54.486 --> 00:12:55.176 A:middle
integer value?

00:12:55.976 --> 00:12:57.406 A:middle
I'm not selling that many

00:12:57.406 --> 00:12:57.776 A:middle
things.

00:12:58.036 --> 00:12:58.786 A:middle
So, no it doesn't.

00:12:58.786 --> 00:12:59.886 A:middle
and in this case, this might be

00:12:59.886 --> 00:13:01.376 A:middle
due to somebody trying to cause


00:12:59.886 --> 00:13:01.376 A:middle
due to somebody trying to cause

00:13:01.376 --> 00:13:02.986 A:middle
overflow in my app.

00:13:03.586 --> 00:13:04.426 A:middle
This is something you need to

00:13:04.426 --> 00:13:05.066 A:middle
watch out for.

00:13:07.026 --> 00:13:08.526 A:middle
Now similar to range validation

00:13:08.526 --> 00:13:09.486 A:middle
is length validation.

00:13:10.146 --> 00:13:12.176 A:middle
Again, every product listing has

00:13:12.176 --> 00:13:12.786 A:middle
a description.

00:13:12.786 --> 00:13:14.466 A:middle
Does it make sense for that

00:13:14.466 --> 00:13:15.496 A:middle
description to be empty?

00:13:16.876 --> 00:13:18.096 A:middle
Well, in my case, I know that

00:13:18.096 --> 00:13:19.456 A:middle
anytime I upload a product

00:13:19.456 --> 00:13:21.456 A:middle
listing, I'm always going to put

00:13:21.456 --> 00:13:22.206 A:middle
a description in there.

00:13:22.206 --> 00:13:23.456 A:middle
So, in my case, no it doesn't

00:13:23.456 --> 00:13:26.266 A:middle
make sense for it to be empty.

00:13:26.326 --> 00:13:27.556 A:middle
But even if it's not empty, does

00:13:27.556 --> 00:13:28.496 A:middle
it make sense for it to be the

00:13:28.496 --> 00:13:29.706 A:middle
full length and contents of

00:13:29.706 --> 00:13:30.516 A:middle
"Romeo and Juliet?"

00:13:31.286 --> 00:13:32.786 A:middle
Also no, it doesn't make sense.

00:13:32.786 --> 00:13:34.326 A:middle
Something here's gone wrong and

00:13:34.326 --> 00:13:37.596 A:middle
I need to look for that.

00:13:38.056 --> 00:13:39.166 A:middle
Now, there's additional forms of

00:13:39.166 --> 00:13:40.166 A:middle
validation that we really do

00:13:40.166 --> 00:13:40.806 A:middle
care about here.

00:13:40.966 --> 00:13:42.286 A:middle
Even if all of these fields are

00:13:42.286 --> 00:13:44.366 A:middle
right type, nullability, and fit

00:13:44.366 --> 00:13:45.286 A:middle
within the range and length that

00:13:45.286 --> 00:13:47.266 A:middle
we expect, their values and

00:13:47.266 --> 00:13:48.596 A:middle
contents are also equally

00:13:48.596 --> 00:13:48.986 A:middle
important.

00:13:50.136 --> 00:13:51.836 A:middle
Every product listing has a URL

00:13:51.836 --> 00:13:53.096 A:middle
that I can send a customer to

00:13:53.096 --> 00:13:54.346 A:middle
see more information about that

00:13:54.346 --> 00:13:54.986 A:middle
product listing.

00:13:56.036 --> 00:13:57.306 A:middle
This comes to me as a string,

00:13:57.866 --> 00:13:59.376 A:middle
but it actually has to contain a

00:13:59.376 --> 00:13:59.596 A:middle
URL.

00:13:59.596 --> 00:14:00.966 A:middle
Does it make sense for it to be


00:13:59.596 --> 00:14:00.966 A:middle
Does it make sense for it to be

00:14:01.356 --> 00:14:02.406 A:middle
any arbitrary string?

00:14:02.896 --> 00:14:04.916 A:middle
No, and in my case, I want to

00:14:04.916 --> 00:14:05.876 A:middle
make sure that it actually

00:14:05.876 --> 00:14:06.706 A:middle
represents a URL.

00:14:07.646 --> 00:14:09.366 A:middle
But more importantly, just

00:14:09.366 --> 00:14:10.646 A:middle
because it looks like a URL,

00:14:10.646 --> 00:14:11.956 A:middle
doesn't mean it will point to my

00:14:11.956 --> 00:14:12.426 A:middle
domain.

00:14:12.916 --> 00:14:13.916 A:middle
And this is something I care

00:14:13.916 --> 00:14:14.866 A:middle
very deeply about.

00:14:14.866 --> 00:14:16.976 A:middle
I really, really want to keep my

00:14:16.976 --> 00:14:17.736 A:middle
customers safe.

00:14:17.736 --> 00:14:19.466 A:middle
I don't want to possibly send

00:14:19.466 --> 00:14:21.266 A:middle
them to a phishing domain, which

00:14:21.266 --> 00:14:23.056 A:middle
could look like mine, but not

00:14:23.056 --> 00:14:23.936 A:middle
really be my site.

00:14:25.426 --> 00:14:26.476 A:middle
So, this is something that I

00:14:26.476 --> 00:14:29.046 A:middle
care about watching out for.

00:14:29.546 --> 00:14:30.986 A:middle
Now, lastly, even if each of

00:14:30.986 --> 00:14:32.656 A:middle
these fields is valid on its

00:14:32.656 --> 00:14:34.126 A:middle
own, sometimes the relationships

00:14:34.126 --> 00:14:35.376 A:middle
between fields that matters.

00:14:36.956 --> 00:14:38.026 A:middle
For instance, each product

00:14:38.026 --> 00:14:39.186 A:middle
listing has a date when it was

00:14:39.186 --> 00:14:40.446 A:middle
created, and a date when it was

00:14:40.446 --> 00:14:41.126 A:middle
last updated.

00:14:42.226 --> 00:14:43.276 A:middle
Each of these can be valid on

00:14:43.276 --> 00:14:44.486 A:middle
their own, but does it make

00:14:44.486 --> 00:14:45.566 A:middle
sense for the date that it was

00:14:45.566 --> 00:14:47.256 A:middle
last updated to come before when

00:14:47.256 --> 00:14:47.936 A:middle
it was created?

00:14:49.106 --> 00:14:50.716 A:middle
No. And in my case, this might

00:14:50.716 --> 00:14:51.636 A:middle
not open a security

00:14:51.636 --> 00:14:52.406 A:middle
vulnerability in my app.

00:14:52.406 --> 00:14:54.436 A:middle
But this is something that maybe

00:14:54.436 --> 00:14:55.536 A:middle
you watch out for because it's a

00:14:55.536 --> 00:14:56.946 A:middle
good indicator that something's

00:14:56.946 --> 00:14:57.946 A:middle
gone wrong, and maybe I

00:14:57.946 --> 00:14:58.966 A:middle
shouldn't trust this data.

00:14:58.966 --> 00:15:01.736 A:middle
So, let's take a look at how we


00:14:58.966 --> 00:15:01.736 A:middle
So, let's take a look at how we

00:15:01.736 --> 00:15:03.216 A:middle
can start doing that.

00:15:03.656 --> 00:15:04.726 A:middle
Here, I've started writing a

00:15:04.726 --> 00:15:05.836 A:middle
function which will take one

00:15:05.836 --> 00:15:07.106 A:middle
such listing and start

00:15:07.106 --> 00:15:08.366 A:middle
validating all of the contents.

00:15:09.476 --> 00:15:10.836 A:middle
So, I'll take a listing, and

00:15:10.836 --> 00:15:12.056 A:middle
I'll start pulling out the

00:15:12.056 --> 00:15:12.666 A:middle
product ID.

00:15:13.386 --> 00:15:15.436 A:middle
And we've learned here not to

00:15:15.436 --> 00:15:17.136 A:middle
forcibly downcast this ID to an

00:15:17.166 --> 00:15:18.836 A:middle
Int, but conditionally downcast.

00:15:19.166 --> 00:15:20.766 A:middle
And if the cast fails the guard

00:15:20.766 --> 00:15:21.876 A:middle
will fail and will throw an

00:15:21.876 --> 00:15:22.126 A:middle
error.

00:15:22.216 --> 00:15:24.676 A:middle
Now I don't want to stop there,

00:15:24.676 --> 00:15:25.746 A:middle
I want to perform the range

00:15:25.746 --> 00:15:27.266 A:middle
validation that ensures that

00:15:27.266 --> 00:15:28.626 A:middle
product ID is also valid.

00:15:28.626 --> 00:15:30.066 A:middle
That it's positive and not too

00:15:30.066 --> 00:15:30.466 A:middle
large.

00:15:30.606 --> 00:15:31.616 A:middle
And again, if something goes

00:15:31.616 --> 00:15:36.386 A:middle
wrong, I'll throw an error.

00:15:37.006 --> 00:15:38.636 A:middle
Now, later on I might care to

00:15:38.636 --> 00:15:39.706 A:middle
check out that URL.

00:15:39.766 --> 00:15:41.466 A:middle
And again, I'll downcast it to a

00:15:41.466 --> 00:15:42.916 A:middle
string, instead of forcibly

00:15:42.916 --> 00:15:43.466 A:middle
downcast.

00:15:44.236 --> 00:15:45.436 A:middle
And here, I can check the link.

00:15:45.626 --> 00:15:46.836 A:middle
In this case, I know my server

00:15:46.836 --> 00:15:48.276 A:middle
will never produce URLs that are

00:15:48.276 --> 00:15:48.806 A:middle
too long.

00:15:49.156 --> 00:15:50.966 A:middle
So, if I find a really long URL,

00:15:50.966 --> 00:15:52.296 A:middle
I'll know that it's invalid.

00:15:54.096 --> 00:15:55.726 A:middle
Once I've validated that, I can

00:15:55.726 --> 00:15:57.206 A:middle
send it off to the URL type to

00:15:57.206 --> 00:15:58.376 A:middle
perform that domain-specific

00:15:58.376 --> 00:15:59.276 A:middle
validation to make sure it

00:15:59.276 --> 00:16:00.816 A:middle
actually is a URL, and not just


00:15:59.276 --> 00:16:00.816 A:middle
actually is a URL, and not just

00:16:00.816 --> 00:16:01.486 A:middle
a garbage string.

00:16:01.786 --> 00:16:02.846 A:middle
And again, if anything goes

00:16:02.916 --> 00:16:04.006 A:middle
wrong, I'll throw an error.

00:16:04.586 --> 00:16:06.806 A:middle
But, again, I don't want to stop

00:16:06.806 --> 00:16:08.456 A:middle
there, once I have an actual

00:16:08.456 --> 00:16:09.926 A:middle
URL, I want to make sure it

00:16:09.926 --> 00:16:11.376 A:middle
points to my domain and not a

00:16:11.376 --> 00:16:13.016 A:middle
phishing domain, so I'll keep

00:16:13.016 --> 00:16:15.206 A:middle
working with that.

00:16:15.406 --> 00:16:16.736 A:middle
Now, at this point, I can apply

00:16:16.736 --> 00:16:17.886 A:middle
the same types of validation to

00:16:17.886 --> 00:16:18.716 A:middle
the other fields here.

00:16:18.966 --> 00:16:20.096 A:middle
And again, if anything goes

00:16:20.096 --> 00:16:20.936 A:middle
wrong, I'll throw an error.

00:16:21.466 --> 00:16:22.936 A:middle
But once I have this function, I

00:16:22.936 --> 00:16:24.686 A:middle
can apply it to all the product

00:16:24.686 --> 00:16:25.866 A:middle
listings that I've loaded from

00:16:25.866 --> 00:16:26.256 A:middle
the payload.

00:16:26.466 --> 00:16:29.436 A:middle
And again, I'll stop executing

00:16:29.886 --> 00:16:33.716 A:middle
if anything goes wrong.

00:16:33.916 --> 00:16:35.426 A:middle
Now, this is how we can work to

00:16:35.426 --> 00:16:36.476 A:middle
validate primitive data.

00:16:37.256 --> 00:16:38.256 A:middle
But as we just saw, primitive

00:16:38.256 --> 00:16:39.306 A:middle
data can be very general.

00:16:40.706 --> 00:16:43.906 A:middle
A string can be a string, but it

00:16:43.906 --> 00:16:45.416 A:middle
can also be a date.

00:16:45.756 --> 00:16:48.376 A:middle
And it can also be a URL.

00:16:50.236 --> 00:16:52.086 A:middle
Sometimes we care to work with

00:16:52.126 --> 00:16:53.466 A:middle
data with the semantics that

00:16:53.556 --> 00:16:54.356 A:middle
matter to us.

00:16:54.796 --> 00:16:55.986 A:middle
We wanted to make sure that the

00:16:55.986 --> 00:16:57.866 A:middle
host of that URL was our domain,

00:16:57.866 --> 00:16:59.116 A:middle
and we can't do that with just a

00:16:59.116 --> 00:16:59.796 A:middle
regular string.


00:17:01.536 --> 00:17:03.026 A:middle
Similarly, a dictionary can

00:17:03.026 --> 00:17:04.846 A:middle
represent a model like a listing

00:17:04.846 --> 00:17:06.616 A:middle
here, or it can represent

00:17:06.616 --> 00:17:07.976 A:middle
arbitrary customer data that we

00:17:07.976 --> 00:17:08.746 A:middle
know nothing about.

00:17:10.136 --> 00:17:11.366 A:middle
Instead of performing the same

00:17:11.366 --> 00:17:12.726 A:middle
validations everywhere to make

00:17:12.726 --> 00:17:13.896 A:middle
sure all the fields that we care

00:17:13.896 --> 00:17:15.665 A:middle
about are there, isn't it nicer

00:17:15.665 --> 00:17:16.476 A:middle
to work with our own model

00:17:16.476 --> 00:17:18.386 A:middle
types, where that guarantee is

00:17:18.386 --> 00:17:19.016 A:middle
always present?

00:17:19.556 --> 00:17:23.326 A:middle
It is. And in our case, we want

00:17:23.326 --> 00:17:24.665 A:middle
to work with structured data

00:17:24.705 --> 00:17:25.776 A:middle
wherever possible.

00:17:25.876 --> 00:17:27.165 A:middle
We can use primitive date as a

00:17:27.165 --> 00:17:28.356 A:middle
building block to get there.

00:17:28.356 --> 00:17:29.516 A:middle
But we want to work with that

00:17:29.516 --> 00:17:30.046 A:middle
form of data.

00:17:31.286 --> 00:17:32.116 A:middle
So, let's take a look at how we

00:17:32.116 --> 00:17:35.506 A:middle
can do that.

00:17:35.506 --> 00:17:37.366 A:middle
Elsewhere in my app, I have a

00:17:37.366 --> 00:17:38.836 A:middle
purchase type, which does just

00:17:38.836 --> 00:17:39.166 A:middle
this.

00:17:40.556 --> 00:17:41.436 A:middle
When a customer makes a

00:17:41.436 --> 00:17:43.416 A:middle
purchase, I store that data to

00:17:43.416 --> 00:17:44.866 A:middle
disc, so that later, when they

00:17:44.866 --> 00:17:46.016 A:middle
open the app, even if they're

00:17:46.016 --> 00:17:47.176 A:middle
not connected to the network,

00:17:47.496 --> 00:17:48.426 A:middle
they can view their purchase

00:17:48.426 --> 00:17:48.796 A:middle
history.

00:17:50.096 --> 00:17:51.576 A:middle
Each purchase keeps track of the

00:17:51.576 --> 00:17:52.446 A:middle
product listing it was

00:17:52.446 --> 00:17:54.846 A:middle
associated with, and when the

00:17:54.846 --> 00:17:55.946 A:middle
purchase was made, and a

00:17:55.946 --> 00:17:56.386 A:middle
receipt.

00:17:57.366 --> 00:17:59.476 A:middle
I can save it to disc in this

00:17:59.476 --> 00:18:01.496 A:middle
way using NS coding and NS key


00:17:59.476 --> 00:18:01.496 A:middle
way using NS coding and NS key

00:18:01.496 --> 00:18:02.076 A:middle
to archiver.

00:18:02.106 --> 00:18:03.026 A:middle
And I'll archive it.

00:18:04.076 --> 00:18:05.876 A:middle
But as we saw, when we unarchive

00:18:05.876 --> 00:18:07.506 A:middle
data, and we handle raw and

00:18:07.506 --> 00:18:09.106 A:middle
primitive data, we want to

00:18:09.106 --> 00:18:09.566 A:middle
validate it.

00:18:10.746 --> 00:18:12.036 A:middle
So, let's do that by taking a

00:18:12.036 --> 00:18:13.186 A:middle
look at how doing it with coder

00:18:13.246 --> 00:18:13.756 A:middle
here could work.

00:18:14.276 --> 00:18:15.416 A:middle
If you've ever written in a note

00:18:15.416 --> 00:18:16.306 A:middle
with coder, this might look

00:18:16.306 --> 00:18:16.956 A:middle
familiar to you.

00:18:17.746 --> 00:18:19.396 A:middle
We'll start by decoding the

00:18:19.396 --> 00:18:20.206 A:middle
product listing.

00:18:20.426 --> 00:18:21.296 A:middle
And again, we've learned to

00:18:21.296 --> 00:18:23.086 A:middle
conditionally downcast, instead

00:18:23.086 --> 00:18:24.216 A:middle
of forcibly downcasting.

00:18:25.106 --> 00:18:26.346 A:middle
And if something goes wrong,

00:18:26.396 --> 00:18:27.446 A:middle
well this is a fail-able

00:18:27.446 --> 00:18:28.746 A:middle
initializer, we'll simply return

00:18:28.746 --> 00:18:29.306 A:middle
nil, right?

00:18:30.686 --> 00:18:32.526 A:middle
if decoding succeeds, I'll

00:18:32.526 --> 00:18:33.996 A:middle
assign this to my property, and

00:18:34.246 --> 00:18:34.836 A:middle
I'll keep going.

00:18:35.686 --> 00:18:36.766 A:middle
I'll do the same thing with the

00:18:36.766 --> 00:18:37.696 A:middle
purchase data, and again,

00:18:37.746 --> 00:18:38.886 A:middle
conditionally downcast to a

00:18:38.886 --> 00:18:39.176 A:middle
date.

00:18:39.286 --> 00:18:40.456 A:middle
If something goes wrong, I'll

00:18:40.516 --> 00:18:41.776 A:middle
fail, and so on.

00:18:41.776 --> 00:18:43.216 A:middle
And repeat this for each of the

00:18:43.216 --> 00:18:44.546 A:middle
fields in my type.

00:18:45.396 --> 00:18:47.056 A:middle
When I want to save one of these

00:18:47.096 --> 00:18:49.116 A:middle
purchases to the history, well I

00:18:49.116 --> 00:18:50.136 A:middle
have a function, which does

00:18:50.136 --> 00:18:50.516 A:middle
this.

00:18:50.906 --> 00:18:53.806 A:middle
It archives a purchase to binary

00:18:53.806 --> 00:18:54.086 A:middle
data.

00:18:54.226 --> 00:18:56.556 A:middle
And then, I can save it out to

00:18:56.556 --> 00:18:57.956 A:middle
disc, or shrill that data off

00:18:57.956 --> 00:18:59.106 A:middle
into database or similar.

00:18:59.226 --> 00:19:02.176 A:middle
When I want to load that data


00:18:59.226 --> 00:19:02.176 A:middle
When I want to load that data

00:19:02.176 --> 00:19:03.736 A:middle
back, well I can do the same

00:19:03.736 --> 00:19:03.996 A:middle
thing.

00:19:03.996 --> 00:19:06.226 A:middle
I can get that raw data and then

00:19:06.226 --> 00:19:06.976 A:middle
pass it along to

00:19:06.976 --> 00:19:08.476 A:middle
KeyedUnarchiver, to get an

00:19:08.476 --> 00:19:10.786 A:middle
object back out.

00:19:11.436 --> 00:19:12.506 A:middle
Now, as we've said, at every

00:19:12.586 --> 00:19:14.046 A:middle
point here, the data is getting

00:19:14.046 --> 00:19:14.856 A:middle
more complicated.

00:19:15.346 --> 00:19:16.426 A:middle
There might be more to validate

00:19:16.426 --> 00:19:17.756 A:middle
about it before we can trust it,

00:19:17.866 --> 00:19:18.466 A:middle
just as well.

00:19:18.466 --> 00:19:20.466 A:middle
So, you might wonder, okay,

00:19:20.466 --> 00:19:21.226 A:middle
what's the catch here?

00:19:21.776 --> 00:19:22.596 A:middle
What else is there left to

00:19:22.596 --> 00:19:22.986 A:middle
validate?

00:19:22.986 --> 00:19:25.486 A:middle
And this downcast, here is a

00:19:25.486 --> 00:19:25.986 A:middle
good hint.

00:19:26.646 --> 00:19:29.436 A:middle
Note that this downcast happens

00:19:29.686 --> 00:19:31.166 A:middle
after we've unarchived an

00:19:31.166 --> 00:19:31.566 A:middle
object.

00:19:32.636 --> 00:19:33.866 A:middle
How could this ever fail?

00:19:35.196 --> 00:19:36.076 A:middle
It's a good indicator that

00:19:36.076 --> 00:19:37.206 A:middle
something else might be going on

00:19:37.206 --> 00:19:37.326 A:middle
here.

00:19:37.676 --> 00:19:40.696 A:middle
So, let's take a look at that.

00:19:40.696 --> 00:19:41.726 A:middle
This is an abstract

00:19:41.726 --> 00:19:42.776 A:middle
representation of what these

00:19:42.776 --> 00:19:44.336 A:middle
model objects might look like in

00:19:44.336 --> 00:19:44.866 A:middle
my archive.

00:19:46.246 --> 00:19:47.706 A:middle
Here we have all the fields that

00:19:47.706 --> 00:19:48.666 A:middle
we cared about in coding.

00:19:49.106 --> 00:19:50.216 A:middle
And each of them contains their

00:19:50.216 --> 00:19:51.636 A:middle
own structure, and substructure,

00:19:51.636 --> 00:19:53.256 A:middle
and contents, and so on.

00:19:53.796 --> 00:19:55.846 A:middle
But, interestingly here this

00:19:55.846 --> 00:19:57.766 A:middle
representation also contains the

00:19:57.766 --> 00:19:59.576 A:middle
name of the class of this

00:19:59.576 --> 00:19:59.976 A:middle
object.


00:20:01.136 --> 00:20:02.156 A:middle
Let's take a look at how

00:20:02.156 --> 00:20:03.546 A:middle
KeyedUnarchiver can make use of

00:20:03.546 --> 00:20:04.216 A:middle
this information.

00:20:05.346 --> 00:20:07.136 A:middle
So, we have a decode call we're

00:20:07.136 --> 00:20:07.876 A:middle
currently making.

00:20:08.486 --> 00:20:09.876 A:middle
And this under the hood creates

00:20:09.876 --> 00:20:11.126 A:middle
a KeyedUnarchiver, and decodes

00:20:11.126 --> 00:20:13.346 A:middle
an object for the object key.

00:20:14.196 --> 00:20:15.666 A:middle
When you perform this in

00:20:15.666 --> 00:20:17.086 A:middle
KeyedUnarchiver, KeyedUnarchiver

00:20:17.086 --> 00:20:18.596 A:middle
finds that class name in the

00:20:18.596 --> 00:20:20.636 A:middle
object in the archive and pulls

00:20:20.636 --> 00:20:20.926 A:middle
it out.

00:20:21.666 --> 00:20:23.396 A:middle
And dynamically finds a class

00:20:23.396 --> 00:20:25.506 A:middle
with that same name in your app.

00:20:26.046 --> 00:20:28.896 A:middle
It then allocates an instance of

00:20:28.896 --> 00:20:30.756 A:middle
that class and then initializes

00:20:30.756 --> 00:20:32.726 A:middle
it to allow it to decode its own

00:20:32.726 --> 00:20:33.236 A:middle
contents.

00:20:34.416 --> 00:20:36.026 A:middle
Afterwards, it awakens the

00:20:36.026 --> 00:20:37.186 A:middle
object to give it a chance to

00:20:37.186 --> 00:20:38.746 A:middle
finalize its state.

00:20:40.336 --> 00:20:42.336 A:middle
Now, this works great for our

00:20:42.336 --> 00:20:42.906 A:middle
objects.

00:20:43.336 --> 00:20:45.096 A:middle
But now, we might wonder what

00:20:45.096 --> 00:20:46.176 A:middle
happens if the data is

00:20:46.176 --> 00:20:47.776 A:middle
maliciously changed to contain

00:20:47.776 --> 00:20:50.226 A:middle
an object of a class that we

00:20:50.956 --> 00:20:51.486 A:middle
didn't expect?

00:20:51.486 --> 00:20:52.656 A:middle
Well, this whole process that we

00:20:52.656 --> 00:20:54.656 A:middle
just performed happened on a

00:20:54.656 --> 00:20:55.256 A:middle
different type.

00:20:56.486 --> 00:20:58.616 A:middle
We just allocated, initialized

00:20:58.616 --> 00:21:00.746 A:middle
and awoke an object of a class


00:20:58.616 --> 00:21:00.746 A:middle
and awoke an object of a class

00:21:00.746 --> 00:21:01.546 A:middle
that we didn't expect.

00:21:02.896 --> 00:21:03.906 A:middle
What kind of effect can this

00:21:03.906 --> 00:21:05.826 A:middle
have in our app?

00:21:06.106 --> 00:21:07.326 A:middle
Well, as we saw before, the

00:21:07.326 --> 00:21:08.626 A:middle
conditional downcast here,

00:21:08.896 --> 00:21:10.006 A:middle
prevents us from accidentally

00:21:10.086 --> 00:21:11.216 A:middle
using an object of this

00:21:11.216 --> 00:21:12.246 A:middle
unexpected class.

00:21:12.696 --> 00:21:13.796 A:middle
We're only going to work with

00:21:13.796 --> 00:21:15.146 A:middle
objects of the types that we did

00:21:15.146 --> 00:21:15.566 A:middle
expect.

00:21:15.976 --> 00:21:17.636 A:middle
The downcast fails, well we'll

00:21:17.636 --> 00:21:17.936 A:middle
fail.

00:21:20.476 --> 00:21:22.516 A:middle
But decoding one such object can

00:21:22.516 --> 00:21:23.846 A:middle
have a lasting impact in our

00:21:24.136 --> 00:21:24.476 A:middle
app.

00:21:24.686 --> 00:21:27.036 A:middle
Say that class has an alloc

00:21:27.036 --> 00:21:28.306 A:middle
method, which changes global

00:21:28.306 --> 00:21:28.626 A:middle
state.

00:21:28.696 --> 00:21:30.146 A:middle
Maybe it allocates a singleton

00:21:30.146 --> 00:21:33.306 A:middle
or changes some global data.

00:21:33.476 --> 00:21:34.796 A:middle
Even though we throw the object

00:21:34.796 --> 00:21:36.346 A:middle
away, if this fails, this can

00:21:36.346 --> 00:21:37.686 A:middle
have a lasting impact in our

00:21:37.936 --> 00:21:38.006 A:middle
app.

00:21:38.006 --> 00:21:39.716 A:middle
And can cause differing behavior

00:21:39.846 --> 00:21:41.196 A:middle
somewhere else and an archive

00:21:41.196 --> 00:21:43.076 A:middle
can be maliciously constructed

00:21:43.076 --> 00:21:44.506 A:middle
in this way to cause this to

00:21:44.506 --> 00:21:45.416 A:middle
happen in our apps.

00:21:46.246 --> 00:21:47.806 A:middle
So, how can we validate the data

00:21:47.806 --> 00:21:48.796 A:middle
to prevent this from happening?

00:21:49.946 --> 00:21:51.196 A:middle
This is exactly where the

00:21:51.196 --> 00:21:52.416 A:middle
NSSecureCoding protocol comes

00:21:52.416 --> 00:21:52.516 A:middle
in.

00:21:53.886 --> 00:21:55.566 A:middle
NSSecureCoding is a protocol

00:21:55.966 --> 00:21:58.126 A:middle
inheriting from NSCoding, whose

00:21:58.126 --> 00:22:00.536 A:middle
goal is to prevent exactly this


00:21:58.126 --> 00:22:00.536 A:middle
goal is to prevent exactly this

00:22:00.536 --> 00:22:02.256 A:middle
sort of attack.

00:22:02.966 --> 00:22:04.756 A:middle
By allowing you to pass in type

00:22:04.756 --> 00:22:07.546 A:middle
information upfront, it prevents

00:22:07.546 --> 00:22:08.926 A:middle
arbitrary code execution by

00:22:08.926 --> 00:22:10.296 A:middle
validating the contents of the

00:22:10.296 --> 00:22:11.966 A:middle
archive to make sure it only

00:22:11.966 --> 00:22:13.246 A:middle
contains the types that you

00:22:13.926 --> 00:22:14.166 A:middle
expect.

00:22:15.356 --> 00:22:17.126 A:middle
The hallmark introduction of

00:22:17.126 --> 00:22:18.666 A:middle
NSSecureCoding were two

00:22:18.666 --> 00:22:20.136 A:middle
alternative methods to decode

00:22:20.136 --> 00:22:22.016 A:middle
object for key, which allow you

00:22:22.016 --> 00:22:23.356 A:middle
to pass that type information

00:22:23.356 --> 00:22:23.786 A:middle
upfront.

00:22:24.586 --> 00:22:26.056 A:middle
And using that type information,

00:22:26.056 --> 00:22:27.276 A:middle
NSKeyedUnarchiver can keep you

00:22:27.276 --> 00:22:27.636 A:middle
safe.

00:22:29.016 --> 00:22:29.806 A:middle
So, let's take a look at the

00:22:29.806 --> 00:22:31.016 A:middle
current decode object for key

00:22:31.016 --> 00:22:31.666 A:middle
call that we have.

00:22:32.136 --> 00:22:34.506 A:middle
This top level decode.

00:22:34.756 --> 00:22:36.176 A:middle
Now, here, if instead we use the

00:22:36.176 --> 00:22:37.806 A:middle
variant that allows us to pass

00:22:37.806 --> 00:22:39.136 A:middle
in the class upfront, in this

00:22:39.136 --> 00:22:39.986 A:middle
case, we want to decode a

00:22:39.986 --> 00:22:42.566 A:middle
purchase, instead of performing

00:22:42.566 --> 00:22:43.716 A:middle
this whole process and whatever

00:22:43.796 --> 00:22:46.256 A:middle
is in the archive, you can first

00:22:46.336 --> 00:22:47.666 A:middle
gate it on a class check.

00:22:49.196 --> 00:22:50.276 A:middle
Let's examine this class check

00:22:50.276 --> 00:22:50.746 A:middle
for a moment.

00:22:51.236 --> 00:22:54.506 A:middle
At every stage in decoding, if

00:22:54.506 --> 00:22:55.466 A:middle
secure coding is on,

00:22:55.736 --> 00:22:57.106 A:middle
NSKeyedUnarchiver maintains a

00:22:57.106 --> 00:22:58.676 A:middle
list of classes, which are valid

00:22:58.676 --> 00:22:59.206 A:middle
to decode.

00:22:59.786 --> 00:23:02.246 A:middle
When we make such a call,


00:22:59.786 --> 00:23:02.246 A:middle
When we make such a call,

00:23:02.636 --> 00:23:04.456 A:middle
NSKeyedUnarchiver, takes the

00:23:04.456 --> 00:23:06.606 A:middle
object that we used, this class,

00:23:07.056 --> 00:23:08.516 A:middle
and constructs an allowed class

00:23:08.516 --> 00:23:09.706 A:middle
list from it.

00:23:10.296 --> 00:23:12.626 A:middle
When we go ahead and decode an

00:23:12.626 --> 00:23:14.306 A:middle
object from an archive, it's

00:23:14.306 --> 00:23:16.016 A:middle
class is first checked against

00:23:16.016 --> 00:23:16.936 A:middle
the allowed class list.

00:23:17.286 --> 00:23:19.626 A:middle
And if it isn't present, the

00:23:19.626 --> 00:23:20.886 A:middle
decode call will be rejected.

00:23:21.556 --> 00:23:24.436 A:middle
Now, if the class of the object

00:23:24.436 --> 00:23:25.906 A:middle
that we find in the archive is

00:23:25.906 --> 00:23:26.966 A:middle
in the allowed class list,

00:23:27.556 --> 00:23:28.566 A:middle
there's a few checks that we

00:23:28.566 --> 00:23:29.196 A:middle
need to perform.

00:23:30.246 --> 00:23:31.726 A:middle
Specifically, we'll need to make

00:23:31.726 --> 00:23:33.276 A:middle
sure that this class itself also

00:23:33.276 --> 00:23:34.596 A:middle
conforms to NSSecureCoding.

00:23:35.906 --> 00:23:37.666 A:middle
If it doesn't, we can't be sure

00:23:37.666 --> 00:23:38.896 A:middle
that it itself will be able to

00:23:38.896 --> 00:23:40.546 A:middle
further securely decode its own

00:23:40.546 --> 00:23:41.146 A:middle
contents.

00:23:41.496 --> 00:23:43.086 A:middle
And so, we can't safely decode

00:23:43.086 --> 00:23:43.996 A:middle
one of these objects.

00:23:44.996 --> 00:23:46.256 A:middle
In our case, the purchase class

00:23:46.316 --> 00:23:46.506 A:middle
will.

00:23:46.776 --> 00:23:47.976 A:middle
And so, it's safe to decode and

00:23:47.976 --> 00:23:48.706 A:middle
keep track of it.

00:23:49.746 --> 00:23:51.086 A:middle
Now, there's two other checks

00:23:51.086 --> 00:23:51.716 A:middle
that are related to

00:23:51.716 --> 00:23:52.856 A:middle
superclass-subclass

00:23:53.256 --> 00:23:54.006 A:middle
relationships.

00:23:54.576 --> 00:23:56.906 A:middle
If you have two classes, one of

00:23:56.906 --> 00:23:58.226 A:middle
which is a subclass of another,

00:23:58.586 --> 00:24:00.636 A:middle
both conforming to NSCoding, and


00:23:58.586 --> 00:24:00.636 A:middle
both conforming to NSCoding, and

00:24:00.636 --> 00:24:01.846 A:middle
the superclass adopts

00:24:01.846 --> 00:24:04.066 A:middle
NSSecureCoding conformance, the

00:24:04.066 --> 00:24:05.516 A:middle
subclass will inherit that

00:24:05.516 --> 00:24:06.176 A:middle
conformance.

00:24:06.786 --> 00:24:09.436 A:middle
Now, the subclass may never have

00:24:09.436 --> 00:24:11.406 A:middle
had a chance to rewrite its init

00:24:11.406 --> 00:24:12.656 A:middle
with coder to do the secure

00:24:12.656 --> 00:24:12.986 A:middle
thing.

00:24:13.756 --> 00:24:14.956 A:middle
And so, we have an escape hatch

00:24:15.586 --> 00:24:15.676 A:middle
here.

00:24:16.816 --> 00:24:18.126 A:middle
The support secure coding

00:24:18.126 --> 00:24:19.386 A:middle
method, allows you to say,

00:24:19.386 --> 00:24:21.226 A:middle
actually I don't really support

00:24:21.226 --> 00:24:22.936 A:middle
secure coding, and you can turn

00:24:22.936 --> 00:24:25.136 A:middle
this off to say, I'm not ready

00:24:26.456 --> 00:24:26.566 A:middle
yet.

00:24:26.776 --> 00:24:28.826 A:middle
Alternatively, if you still say

00:24:28.826 --> 00:24:30.466 A:middle
yes, we have to make sure that

00:24:30.466 --> 00:24:32.736 A:middle
you either inherited the full

00:24:32.736 --> 00:24:34.276 A:middle
conformance to NSSecureCoding

00:24:34.276 --> 00:24:36.256 A:middle
from the superclass, or that you

00:24:36.256 --> 00:24:38.086 A:middle
overrode both of the methods to

00:24:38.086 --> 00:24:40.126 A:middle
indicate yes I really do support

00:24:40.126 --> 00:24:40.796 A:middle
secure coding.

00:24:40.986 --> 00:24:43.696 A:middle
There isn't a mismatch here.

00:24:44.166 --> 00:24:45.716 A:middle
In our case, purchase meets both

00:24:45.716 --> 00:24:47.106 A:middle
of these requirements and so we

00:24:47.106 --> 00:24:49.186 A:middle
can safely decode it from the

00:24:49.756 --> 00:24:49.986 A:middle
archive.

00:24:50.946 --> 00:24:52.826 A:middle
Now, we go ahead and decode a

00:24:52.886 --> 00:24:54.976 A:middle
purchase, it itself decodes a

00:24:54.976 --> 00:24:55.416 A:middle
listing.

00:24:55.416 --> 00:24:56.806 A:middle
And it can make use of the same

00:24:56.806 --> 00:24:58.206 A:middle
type of call to indicate that it

00:24:58.206 --> 00:24:58.906 A:middle
wants a listing.

00:24:59.486 --> 00:25:01.786 A:middle
When it does that


00:24:59.486 --> 00:25:01.786 A:middle
When it does that

00:25:02.076 --> 00:25:03.536 A:middle
NSKeyedUnarchiver uses that

00:25:03.536 --> 00:25:05.146 A:middle
class to build a new allowed

00:25:05.146 --> 00:25:05.826 A:middle
class list.

00:25:06.236 --> 00:25:07.226 A:middle
And everything is checked

00:25:07.226 --> 00:25:08.286 A:middle
against this new version of the

00:25:08.286 --> 00:25:08.606 A:middle
list.

00:25:09.916 --> 00:25:10.946 A:middle
We go ahead and decode an

00:25:10.946 --> 00:25:12.316 A:middle
object, the same checks are

00:25:12.316 --> 00:25:13.476 A:middle
performed and in this case a

00:25:13.476 --> 00:25:14.876 A:middle
listing is still valid to

00:25:15.426 --> 00:25:15.586 A:middle
decode.

00:25:17.236 --> 00:25:19.816 A:middle
But again, if we try to decode

00:25:19.816 --> 00:25:21.506 A:middle
an object of an unexpected class

00:25:21.566 --> 00:25:22.656 A:middle
that's not in the list, it will

00:25:22.656 --> 00:25:23.226 A:middle
be rejected.

00:25:23.796 --> 00:25:27.186 A:middle
Let's take a look at what that

00:25:27.186 --> 00:25:28.286 A:middle
rejection might look like.

00:25:28.506 --> 00:25:30.256 A:middle
And this is called decoding

00:25:30.256 --> 00:25:31.046 A:middle
failure and there are a few

00:25:31.046 --> 00:25:32.356 A:middle
other types of failures that we

00:25:32.356 --> 00:25:33.576 A:middle
might care to look at.

00:25:33.746 --> 00:25:35.176 A:middle
So, when secure coding is on, we

00:25:35.176 --> 00:25:36.276 A:middle
might be able to see secure

00:25:36.276 --> 00:25:37.726 A:middle
coding violations in cases like

00:25:37.726 --> 00:25:37.986 A:middle
this.

00:25:37.986 --> 00:25:39.016 A:middle
But there's other forms of

00:25:39.016 --> 00:25:39.716 A:middle
failure here, too.

00:25:40.916 --> 00:25:42.956 A:middle
For example, a type mismatch can

00:25:42.956 --> 00:25:44.556 A:middle
happen if you try to decode an

00:25:44.556 --> 00:25:45.696 A:middle
object and instead there's a

00:25:45.696 --> 00:25:47.066 A:middle
primitive value, like an integer

00:25:47.066 --> 00:25:48.466 A:middle
in the archive at that location.

00:25:49.116 --> 00:25:50.356 A:middle
Or, you try to decode a

00:25:50.356 --> 00:25:52.396 A:middle
primitive, like an integer, and

00:25:52.396 --> 00:25:54.146 A:middle
instead we find an object or a

00:25:54.146 --> 00:25:55.376 A:middle
primitive of an incompatible

00:25:55.476 --> 00:25:56.126 A:middle
type like double.

00:25:57.026 --> 00:25:58.006 A:middle
These can cause decoding

00:25:58.006 --> 00:25:58.456 A:middle
failures.

00:25:59.996 --> 00:26:01.936 A:middle
There's another form of failure


00:25:59.996 --> 00:26:01.936 A:middle
There's another form of failure

00:26:01.936 --> 00:26:02.606 A:middle
that can happen here.

00:26:02.956 --> 00:26:04.106 A:middle
And that's archive corruption.

00:26:04.106 --> 00:26:05.436 A:middle
If the archive itself is too

00:26:05.436 --> 00:26:07.356 A:middle
corrupted and doesn't follow the

00:26:07.356 --> 00:26:08.336 A:middle
expected format for

00:26:08.336 --> 00:26:09.866 A:middle
NSKeyedUnarchiver, well we won't

00:26:09.866 --> 00:26:11.256 A:middle
be able to decode anything, and

00:26:11.256 --> 00:26:13.246 A:middle
so you'll get that same sort of

00:26:13.976 --> 00:26:14.166 A:middle
failure.

00:26:14.906 --> 00:26:17.166 A:middle
Now, what happens on failure is

00:26:17.166 --> 00:26:18.666 A:middle
decided by the decoding failure

00:26:18.666 --> 00:26:20.286 A:middle
policy on the Unarchiver.

00:26:20.786 --> 00:26:21.606 A:middle
There's two options here.

00:26:22.886 --> 00:26:23.946 A:middle
On failure, we can either raise

00:26:23.946 --> 00:26:26.586 A:middle
an exception or store

00:26:26.586 --> 00:26:27.836 A:middle
information about what happened

00:26:27.836 --> 00:26:28.976 A:middle
and continue execution.

00:26:29.926 --> 00:26:31.456 A:middle
Raising exceptions is currently

00:26:31.456 --> 00:26:31.916 A:middle
the default.

00:26:32.466 --> 00:26:35.766 A:middle
So, if we have a call, again

00:26:35.766 --> 00:26:36.776 A:middle
this is our call from earlier,

00:26:36.776 --> 00:26:37.846 A:middle
trying to decode a listing.

00:26:38.116 --> 00:26:39.826 A:middle
And we find an object of an

00:26:39.826 --> 00:26:41.296 A:middle
unexpected class in the archive,

00:26:42.146 --> 00:26:43.256 A:middle
under the hood this calls the

00:26:43.256 --> 00:26:44.816 A:middle
failWithError method, on the

00:26:44.816 --> 00:26:47.036 A:middle
Unarchiver and passes in an

00:26:47.036 --> 00:26:48.466 A:middle
error that indicates what went

00:26:48.466 --> 00:26:49.046 A:middle
wrong and where.

00:26:50.246 --> 00:26:51.146 A:middle
Now, under the hood,

00:26:51.146 --> 00:26:52.946 A:middle
failWithError has a decision to

00:26:52.946 --> 00:26:53.136 A:middle
make.

00:26:54.056 --> 00:26:55.566 A:middle
If the decoding failure policy

00:26:55.566 --> 00:26:57.256 A:middle
is to raise exceptions, it will

00:26:57.706 --> 00:26:58.476 A:middle
raise exceptions.

00:26:59.336 --> 00:27:00.326 A:middle
If you're writing a Swift app,


00:26:59.336 --> 00:27:00.326 A:middle
If you're writing a Swift app,

00:27:00.326 --> 00:27:01.156 A:middle
this is something you have to be

00:27:01.156 --> 00:27:01.656 A:middle
mindful of.

00:27:02.406 --> 00:27:03.956 A:middle
Swift can't catch Objective-C or

00:27:03.956 --> 00:27:06.046 A:middle
C++ exceptions, and so this can

00:27:06.046 --> 00:27:07.146 A:middle
lead to a fatal error in your

00:27:07.146 --> 00:27:07.296 A:middle
app.

00:27:07.296 --> 00:27:08.946 A:middle
Now again, this can lead to a

00:27:08.946 --> 00:27:10.936 A:middle
crash and a bad experience our

00:27:10.936 --> 00:27:11.426 A:middle
customers.

00:27:11.976 --> 00:27:14.946 A:middle
If the decoding failure policy

00:27:14.946 --> 00:27:16.526 A:middle
to set error and return, the

00:27:16.526 --> 00:27:17.596 A:middle
error will be assigned to the

00:27:17.596 --> 00:27:18.886 A:middle
Unarchiver's error property.

00:27:19.436 --> 00:27:20.906 A:middle
And execution has to continue.

00:27:21.556 --> 00:27:22.666 A:middle
And in this case, because

00:27:22.666 --> 00:27:24.296 A:middle
execution does continue, the

00:27:24.296 --> 00:27:25.526 A:middle
decode call has to return

00:27:25.966 --> 00:27:27.376 A:middle
something, and so it will return

00:27:27.376 --> 00:27:29.086 A:middle
nil to indicate that nothing

00:27:29.086 --> 00:27:29.726 A:middle
could be decoded.

00:27:30.096 --> 00:27:32.666 A:middle
And as mentioned, if you're

00:27:32.666 --> 00:27:33.996 A:middle
decoding a primitive type, here

00:27:33.996 --> 00:27:35.876 A:middle
and we find an object or a

00:27:35.876 --> 00:27:36.896 A:middle
primitive type that's

00:27:36.896 --> 00:27:38.996 A:middle
incompatible, the same series of

00:27:38.996 --> 00:27:39.966 A:middle
steps has to happened.

00:27:39.966 --> 00:27:41.006 A:middle
And in this case, instead of

00:27:41.006 --> 00:27:42.356 A:middle
returning nil, we'll simply

00:27:42.356 --> 00:27:43.606 A:middle
return 0.

00:27:44.236 --> 00:27:49.116 A:middle
Now failWithError is API on

00:27:49.146 --> 00:27:50.716 A:middle
NSKeyedUnarchiver, and we urge

00:27:50.716 --> 00:27:52.296 A:middle
you to use in your own code to

00:27:52.296 --> 00:27:53.616 A:middle
indicate when failures happen

00:27:53.726 --> 00:27:54.806 A:middle
and what went wrong.

00:27:55.636 --> 00:27:56.966 A:middle
Instead of simply returning nil,

00:27:57.216 --> 00:27:58.976 A:middle
failWithError first to record

00:27:58.976 --> 00:27:59.686 A:middle
that information.


00:28:00.256 --> 00:28:02.156 A:middle
If you do, there are a few

00:28:02.156 --> 00:28:03.066 A:middle
things to keep in mind.

00:28:04.466 --> 00:28:05.716 A:middle
If the decoding failure policy

00:28:05.716 --> 00:28:07.166 A:middle
is to set an error, and return,

00:28:07.536 --> 00:28:08.546 A:middle
you have to keep in mind, that

00:28:08.546 --> 00:28:09.826 A:middle
once an error is set on

00:28:09.826 --> 00:28:11.186 A:middle
Unarchiver, it won't later be

00:28:11.186 --> 00:28:11.596 A:middle
reset.

00:28:11.746 --> 00:28:14.616 A:middle
And that's because one decoding

00:28:14.616 --> 00:28:16.366 A:middle
failure often leads to a cascade

00:28:16.366 --> 00:28:17.306 A:middle
of decoding failures.

00:28:17.406 --> 00:28:18.516 A:middle
And we don't want to lose sight

00:28:18.516 --> 00:28:21.796 A:middle
of what originally went wrong.

00:28:22.356 --> 00:28:24.226 A:middle
Second, keep in mind that any

00:28:24.226 --> 00:28:25.776 A:middle
given failWithError call, can

00:28:25.776 --> 00:28:26.976 A:middle
either throw an exception or

00:28:26.976 --> 00:28:29.026 A:middle
continue execution, so you have

00:28:29.026 --> 00:28:30.276 A:middle
to keep both of those options in

00:28:30.276 --> 00:28:30.526 A:middle
mind.

00:28:30.686 --> 00:28:31.666 A:middle
Especially if you're working

00:28:31.666 --> 00:28:32.286 A:middle
Objective-C.

00:28:32.286 --> 00:28:33.206 A:middle
Maybe you can catch the

00:28:33.206 --> 00:28:33.656 A:middle
exception.

00:28:34.266 --> 00:28:35.146 A:middle
So, there's things to handle

00:28:35.146 --> 00:28:35.266 A:middle
there.

00:28:35.886 --> 00:28:38.206 A:middle
And lastly, keeping an eye out

00:28:38.326 --> 00:28:40.176 A:middle
for nil, or 0 return values.

00:28:40.456 --> 00:28:41.806 A:middle
This could either happen because

00:28:41.806 --> 00:28:43.106 A:middle
of a decoding failure, if the

00:28:43.226 --> 00:28:44.406 A:middle
decoding failure policy is to

00:28:44.406 --> 00:28:45.486 A:middle
set an error and return.

00:28:46.006 --> 00:28:47.276 A:middle
Or, the data could have just

00:28:47.276 --> 00:28:47.806 A:middle
been missing.

00:28:48.166 --> 00:28:50.266 A:middle
Or, even encoded as nil or 0.

00:28:51.056 --> 00:28:52.566 A:middle
So, to disambiguate between

00:28:52.566 --> 00:28:53.706 A:middle
these cases, check the error

00:28:53.706 --> 00:28:54.786 A:middle
property on the Unarchiver.

00:28:54.856 --> 00:28:58.636 A:middle
All right, so that was a lot of

00:28:58.636 --> 00:28:59.196 A:middle
information.

00:28:59.926 --> 00:29:01.116 A:middle
Let's distill this down into a


00:28:59.926 --> 00:29:01.116 A:middle
Let's distill this down into a

00:29:01.116 --> 00:29:02.326 A:middle
checklist to see how we can

00:29:02.326 --> 00:29:03.826 A:middle
adopt NSSecureCoding on our own

00:29:03.826 --> 00:29:04.206 A:middle
types.

00:29:05.406 --> 00:29:06.726 A:middle
We'll start by converting all

00:29:06.726 --> 00:29:08.516 A:middle
decode object for key calls to

00:29:08.516 --> 00:29:09.466 A:middle
the variant which allows us to

00:29:09.466 --> 00:29:10.906 A:middle
pass in that type information up

00:29:10.906 --> 00:29:11.196 A:middle
front.

00:29:11.196 --> 00:29:13.516 A:middle
And then, if something goes

00:29:13.516 --> 00:29:14.846 A:middle
wrong instead of just returning

00:29:14.846 --> 00:29:16.176 A:middle
nil, let's failWithError to

00:29:16.176 --> 00:29:17.006 A:middle
indicate what happened.

00:29:17.736 --> 00:29:19.466 A:middle
And lastly, this is a great

00:29:19.466 --> 00:29:21.006 A:middle
opportunity to audit for further

00:29:21.006 --> 00:29:22.356 A:middle
points of failure, where we

00:29:22.356 --> 00:29:23.576 A:middle
weren't performing validation

00:29:23.576 --> 00:29:23.916 A:middle
before.

00:29:24.826 --> 00:29:26.506 A:middle
So, let's do just that.

00:29:27.036 --> 00:29:29.076 A:middle
So, here again is a decode call

00:29:29.186 --> 00:29:30.026 A:middle
to decode a listing.

00:29:30.426 --> 00:29:31.366 A:middle
And you'll notice that if we

00:29:31.426 --> 00:29:32.946 A:middle
pass in that type information up

00:29:32.946 --> 00:29:34.746 A:middle
front, the conditional downcast

00:29:34.746 --> 00:29:35.496 A:middle
later can go away.

00:29:36.926 --> 00:29:38.056 A:middle
There's a generic overload of

00:29:38.056 --> 00:29:39.626 A:middle
this method, which when given

00:29:39.626 --> 00:29:40.946 A:middle
the type information statically

00:29:41.176 --> 00:29:42.776 A:middle
causes you to not have to

00:29:42.776 --> 00:29:44.066 A:middle
conditionally downcast anymore.

00:29:44.146 --> 00:29:45.376 A:middle
You'll always get an object of

00:29:45.376 --> 00:29:47.316 A:middle
that class.

00:29:47.586 --> 00:29:49.416 A:middle
Now, again, as we said, instead

00:29:49.416 --> 00:29:50.756 A:middle
of returning nil on failure, we

00:29:50.756 --> 00:29:51.986 A:middle
want to fail meaningfully.

00:29:52.536 --> 00:29:53.876 A:middle
So, here we can fail with an

00:29:53.876 --> 00:29:55.536 A:middle
error to indicate what went

00:29:55.536 --> 00:29:56.086 A:middle
wrong and where.

00:29:56.086 --> 00:29:58.656 A:middle
And in this case, we can use one

00:29:58.656 --> 00:29:59.676 A:middle
of the conveniences on

00:29:59.676 --> 00:30:01.126 A:middle
CocoaError to return a


00:29:59.676 --> 00:30:01.126 A:middle
CocoaError to return a

00:30:01.126 --> 00:30:02.346 A:middle
meaningful error that has a good

00:30:02.346 --> 00:30:03.496 A:middle
localized description for our

00:30:03.496 --> 00:30:04.566 A:middle
customers and that indicates

00:30:04.566 --> 00:30:06.976 A:middle
what went wrong.

00:30:07.046 --> 00:30:07.766 A:middle
We can always add a debug

00:30:07.766 --> 00:30:09.406 A:middle
description for ourselves, to

00:30:09.406 --> 00:30:10.646 A:middle
later log if we care to.

00:30:10.766 --> 00:30:11.846 A:middle
But this is the core.

00:30:12.126 --> 00:30:13.606 A:middle
We want to failWithError before

00:30:13.606 --> 00:30:14.136 A:middle
returning nil.

00:30:14.676 --> 00:30:18.526 A:middle
And then, later on, again, we

00:30:18.526 --> 00:30:19.826 A:middle
were decoding the purchase date.

00:30:20.306 --> 00:30:22.206 A:middle
And here, there is a great

00:30:22.206 --> 00:30:23.726 A:middle
opportunity to add further

00:30:23.726 --> 00:30:24.826 A:middle
validation where we weren't

00:30:24.826 --> 00:30:25.216 A:middle
before.

00:30:26.616 --> 00:30:28.056 A:middle
Here, if we can decode a date,

00:30:28.056 --> 00:30:29.276 A:middle
well, I was simply storing the

00:30:29.276 --> 00:30:29.756 A:middle
property.

00:30:30.516 --> 00:30:31.806 A:middle
But instead, I want to make sure

00:30:31.806 --> 00:30:32.926 A:middle
that that date is valid.

00:30:33.406 --> 00:30:34.356 A:middle
For instance, a purchase

00:30:34.356 --> 00:30:35.686 A:middle
couldn't possibly had been made

00:30:35.736 --> 00:30:37.026 A:middle
before my app went live on the

00:30:37.026 --> 00:30:37.516 A:middle
app store.

00:30:37.516 --> 00:30:38.676 A:middle
So, this is something you could

00:30:38.676 --> 00:30:38.936 A:middle
check.

00:30:39.286 --> 00:30:40.266 A:middle
And again, if something goes

00:30:40.266 --> 00:30:42.286 A:middle
wrong here, we want to fail with

00:30:42.286 --> 00:30:43.096 A:middle
a meaningful error.

00:30:44.236 --> 00:30:45.256 A:middle
In this case, it wasn't that the

00:30:45.256 --> 00:30:46.656 A:middle
data was missing, it was that

00:30:46.656 --> 00:30:47.786 A:middle
the data was corrupted or

00:30:47.786 --> 00:30:48.656 A:middle
invalid in some way.

00:30:48.656 --> 00:30:49.736 A:middle
And so, we'll indicate just

00:30:49.736 --> 00:30:49.926 A:middle
that.

00:30:49.966 --> 00:30:54.786 A:middle
Now, that we've gone ahead and

00:30:54.786 --> 00:30:56.136 A:middle
done exactly this on our type,

00:30:56.796 --> 00:30:58.716 A:middle
we can go ahead and claim that

00:30:58.716 --> 00:30:59.836 A:middle
it supports secure coding.


00:31:00.576 --> 00:31:02.266 A:middle
And lastly, conform to the

00:31:02.266 --> 00:31:03.976 A:middle
NSSecureCoding protocol instead

00:31:03.976 --> 00:31:05.536 A:middle
to indicate to the runtime that

00:31:05.536 --> 00:31:06.506 A:middle
this is what we intended.

00:31:06.506 --> 00:31:07.846 A:middle
It really does support secure

00:31:07.846 --> 00:31:08.126 A:middle
coding.

00:31:08.836 --> 00:31:11.526 A:middle
And after that, well,

00:31:12.146 --> 00:31:13.006 A:middle
congratulations.

00:31:13.006 --> 00:31:14.366 A:middle
We've earned our NSSecureCoding

00:31:14.366 --> 00:31:14.666 A:middle
badge.

00:31:15.026 --> 00:31:15.876 A:middle
Physical badge is sold

00:31:15.876 --> 00:31:16.276 A:middle
separately.

00:31:18.046 --> 00:31:20.606 A:middle
Now, we think it's so important

00:31:20.606 --> 00:31:21.856 A:middle
for you to earn your own

00:31:21.856 --> 00:31:23.276 A:middle
NSSecureCoding badges and use

00:31:23.276 --> 00:31:25.036 A:middle
them that this year, we've added

00:31:25.086 --> 00:31:26.776 A:middle
new API and NSKeyedUnarchiver to

00:31:26.776 --> 00:31:28.426 A:middle
make sure that NSSecureCoding is

00:31:28.426 --> 00:31:29.506 A:middle
done wherever possible.

00:31:31.276 --> 00:31:32.456 A:middle
This new initializer and

00:31:32.456 --> 00:31:33.936 A:middle
convenience methods, turns on

00:31:33.936 --> 00:31:35.746 A:middle
secure coding by default and

00:31:35.746 --> 00:31:37.126 A:middle
sets the default decoding

00:31:37.126 --> 00:31:38.516 A:middle
failure policy to set error in

00:31:38.516 --> 00:31:38.866 A:middle
return.

00:31:39.346 --> 00:31:40.236 A:middle
So, unless you change the

00:31:40.236 --> 00:31:41.536 A:middle
decoding failure policy on your

00:31:41.536 --> 00:31:42.576 A:middle
own, you don't have to worry

00:31:42.576 --> 00:31:43.736 A:middle
about exceptions in Swift.

00:31:43.736 --> 00:31:47.316 A:middle
And indeed, the old initializer

00:31:47.316 --> 00:31:48.776 A:middle
and convenience methods are

00:31:48.776 --> 00:31:50.186 A:middle
deprecated in favor of these

00:31:50.186 --> 00:31:50.736 A:middle
versions.

00:31:50.956 --> 00:31:51.996 A:middle
So, we really want you to use

00:31:51.996 --> 00:31:52.146 A:middle
them.

00:31:53.726 --> 00:31:55.106 A:middle
And similarly, we've introduced

00:31:55.106 --> 00:31:56.066 A:middle
the same APIs on

00:31:56.096 --> 00:31:58.066 A:middle
NSKeyedUnarchiver, to make it

00:31:58.066 --> 00:31:58.996 A:middle
easier for you to turn

00:31:58.996 --> 00:32:00.426 A:middle
SecureCoding on when archiving.


00:31:58.996 --> 00:32:00.426 A:middle
SecureCoding on when archiving.

00:32:00.426 --> 00:32:01.636 A:middle
And this is equally important

00:32:02.116 --> 00:32:03.386 A:middle
because it makes sure you can't

00:32:03.386 --> 00:32:05.026 A:middle
accidentally archive an object

00:32:05.336 --> 00:32:06.336 A:middle
which doesn't conform to

00:32:06.336 --> 00:32:07.136 A:middle
NSSecureCoding.

00:32:07.406 --> 00:32:08.616 A:middle
And you wouldn't later able to

00:32:08.616 --> 00:32:09.096 A:middle
decode it.

00:32:10.096 --> 00:32:11.786 A:middle
And again, the old initializer

00:32:11.786 --> 00:32:12.816 A:middle
and convenience methods are

00:32:12.816 --> 00:32:13.386 A:middle
deprecated.

00:32:13.896 --> 00:32:14.856 A:middle
And so, this means that if you

00:32:14.856 --> 00:32:15.996 A:middle
have old code that looks like

00:32:16.036 --> 00:32:19.026 A:middle
this, well turn on SecureCoding

00:32:19.026 --> 00:32:19.716 A:middle
when archiving.

00:32:20.446 --> 00:32:21.716 A:middle
And switch to the convenience

00:32:21.716 --> 00:32:22.986 A:middle
methods that allow you to pass

00:32:22.986 --> 00:32:23.946 A:middle
in that type information

00:32:23.946 --> 00:32:24.346 A:middle
upfront.

00:32:25.606 --> 00:32:26.826 A:middle
This way, you can actually make

00:32:26.826 --> 00:32:28.166 A:middle
use of your SecureCoding badge.

00:32:28.676 --> 00:32:29.486 A:middle
Make sure you've earned it.

00:32:31.116 --> 00:32:32.636 A:middle
Now, if you can't yet support

00:32:32.636 --> 00:32:33.956 A:middle
SecureCoding, because your types

00:32:33.956 --> 00:32:35.876 A:middle
can't conform, or they,

00:32:35.876 --> 00:32:37.226 A:middle
themselves depend on types which

00:32:37.226 --> 00:32:38.596 A:middle
don't yet conform, that's okay.

00:32:38.706 --> 00:32:39.996 A:middle
You can still use these methods.

00:32:40.756 --> 00:32:42.666 A:middle
On nCode, simply turn off the

00:32:42.666 --> 00:32:43.756 A:middle
secure coding requirement.

00:32:44.226 --> 00:32:45.396 A:middle
And on decode, these

00:32:45.396 --> 00:32:46.666 A:middle
conveniences always have

00:32:46.666 --> 00:32:47.586 A:middle
SecureCoding enabled.

00:32:48.836 --> 00:32:50.096 A:middle
So, instead use the new

00:32:50.096 --> 00:32:51.196 A:middle
initializer to create a

00:32:51.196 --> 00:32:52.816 A:middle
KeyedUnarchiver, and then turn

00:32:52.816 --> 00:32:54.476 A:middle
SecureCoding off, manually.

00:32:55.776 --> 00:32:56.536 A:middle
This also gives you the

00:32:56.536 --> 00:32:58.026 A:middle
opportunity to reset the

00:32:58.026 --> 00:32:59.456 A:middle
decoding failure policy back to

00:32:59.456 --> 00:33:01.586 A:middle
the old default in case you need


00:32:59.456 --> 00:33:01.586 A:middle
the old default in case you need

00:33:02.386 --> 00:33:02.466 A:middle
it.

00:33:02.966 --> 00:33:03.806 A:middle
Once you have such an

00:33:03.806 --> 00:33:05.416 A:middle
Unarchiver, well you can decode

00:33:05.416 --> 00:33:06.026 A:middle
as usual.

00:33:06.686 --> 00:33:09.916 A:middle
Now, if you're working on a

00:33:09.916 --> 00:33:11.976 A:middle
Swift app, NSSecureCoding isn't

00:33:11.976 --> 00:33:13.306 A:middle
the only way for you to convert

00:33:13.306 --> 00:33:14.836 A:middle
your own model types to external

00:33:14.836 --> 00:33:17.016 A:middle
representations and back.

00:33:17.726 --> 00:33:18.906 A:middle
Last year with Swift 4, we

00:33:18.906 --> 00:33:20.246 A:middle
introduced the Codable protocols

00:33:20.246 --> 00:33:21.636 A:middle
which make it easier to do just

00:33:21.636 --> 00:33:21.836 A:middle
that.

00:33:21.836 --> 00:33:24.696 A:middle
And importantly, all the design

00:33:24.696 --> 00:33:26.026 A:middle
decisions that made their way

00:33:26.186 --> 00:33:28.126 A:middle
into NSSecureCoding were also

00:33:28.126 --> 00:33:29.646 A:middle
present in Codable from day one.

00:33:30.796 --> 00:33:32.956 A:middle
Specifically, Codable never

00:33:32.956 --> 00:33:34.166 A:middle
writes type information into

00:33:34.166 --> 00:33:34.806 A:middle
archives.

00:33:35.096 --> 00:33:36.146 A:middle
So, there's nothing to trust

00:33:36.146 --> 00:33:36.576 A:middle
later on.

00:33:36.576 --> 00:33:38.796 A:middle
By requiring you to pass in

00:33:38.796 --> 00:33:40.446 A:middle
static type information upfront

00:33:40.446 --> 00:33:41.976 A:middle
about what you expect to decode,

00:33:42.376 --> 00:33:43.696 A:middle
you can prevent exactly this

00:33:43.696 --> 00:33:44.966 A:middle
sort of attack.

00:33:45.776 --> 00:33:47.396 A:middle
Now, Codable also comes with

00:33:47.426 --> 00:33:48.196 A:middle
conveniences.

00:33:48.196 --> 00:33:49.626 A:middle
If you have a type whose fields

00:33:49.626 --> 00:33:51.366 A:middle
are all themselves codable, well

00:33:51.366 --> 00:33:52.406 A:middle
you'll get a synthesized

00:33:52.406 --> 00:33:53.706 A:middle
implementation of the init from

00:33:53.706 --> 00:33:54.886 A:middle
and encode to requirements.

00:33:55.806 --> 00:33:56.716 A:middle
And the synthesized

00:33:56.716 --> 00:33:58.086 A:middle
implementation gives you type

00:33:58.086 --> 00:33:59.236 A:middle
and nullability checking for

00:33:59.236 --> 00:33:59.546 A:middle
free.


00:34:00.236 --> 00:34:01.696 A:middle
But as we saw, most types

00:34:01.696 --> 00:34:03.276 A:middle
require additional validation if

00:34:03.276 --> 00:34:04.596 A:middle
they come from external sources,

00:34:04.626 --> 00:34:05.446 A:middle
just like ours do.

00:34:06.586 --> 00:34:07.896 A:middle
So, we need to further validate

00:34:07.896 --> 00:34:08.156 A:middle
those.

00:34:09.366 --> 00:34:11.585 A:middle
So, we can do that for our own

00:34:11.585 --> 00:34:12.856 A:middle
types by overwriting in it with

00:34:13.085 --> 00:34:13.916 A:middle
init from decoder.

00:34:13.996 --> 00:34:15.985 A:middle
And in this case, again, here's

00:34:15.985 --> 00:34:17.466 A:middle
that JSON response from earlier.

00:34:17.656 --> 00:34:18.996 A:middle
And I can trivially turn it into

00:34:18.996 --> 00:34:20.386 A:middle
a Codable type by simply

00:34:20.386 --> 00:34:21.376 A:middle
creating a type with all the

00:34:21.376 --> 00:34:22.366 A:middle
same name fields.

00:34:23.726 --> 00:34:24.606 A:middle
Because all these fields are

00:34:24.606 --> 00:34:26.216 A:middle
codable, I get that free

00:34:26.216 --> 00:34:27.545 A:middle
implementation of init from and

00:34:27.545 --> 00:34:27.996 A:middle
encode to.

00:34:28.886 --> 00:34:30.005 A:middle
But, I want to override init

00:34:30.005 --> 00:34:31.436 A:middle
from to make sure I'm performing

00:34:31.436 --> 00:34:32.596 A:middle
the same validation that I was

00:34:32.596 --> 00:34:33.516 A:middle
before with the primitive

00:34:33.516 --> 00:34:33.936 A:middle
values.

00:34:34.676 --> 00:34:36.716 A:middle
So, I can do that here, the same

00:34:36.716 --> 00:34:36.886 A:middle
way.

00:34:38.536 --> 00:34:40.926 A:middle
Where my old code decoded the ID

00:34:41.016 --> 00:34:42.866 A:middle
from the payload by downcasting

00:34:42.866 --> 00:34:44.846 A:middle
to an int, I can do similarly

00:34:44.896 --> 00:34:46.646 A:middle
here by decoding an int from the

00:34:46.646 --> 00:34:47.025 A:middle
decoder.

00:34:48.496 --> 00:34:50.366 A:middle
If the type found in the payload

00:34:50.676 --> 00:34:52.226 A:middle
is of a different type or is

00:34:52.226 --> 00:34:53.315 A:middle
missing, this will throw an

00:34:53.315 --> 00:34:54.295 A:middle
error that indicates what

00:34:54.295 --> 00:34:54.656 A:middle
happened.

00:34:55.246 --> 00:34:58.866 A:middle
Now, more important than that is

00:34:58.866 --> 00:35:00.166 A:middle
my own validation that I added


00:34:58.866 --> 00:35:00.166 A:middle
my own validation that I added

00:35:00.166 --> 00:35:01.186 A:middle
in that validate method.

00:35:01.926 --> 00:35:03.406 A:middle
Here, I want to make sure I keep

00:35:03.406 --> 00:35:04.816 A:middle
performing that same validation

00:35:04.816 --> 00:35:06.336 A:middle
to make sure the ID is valid.

00:35:06.546 --> 00:35:07.336 A:middle
And here, I can use a

00:35:07.336 --> 00:35:08.616 A:middle
convenience method to throw a

00:35:08.616 --> 00:35:10.096 A:middle
meaningful error that indicates

00:35:10.976 --> 00:35:12.946 A:middle
what happened.

00:35:13.476 --> 00:35:14.866 A:middle
Now, later in that validate

00:35:14.866 --> 00:35:16.316 A:middle
function I might've pulled that

00:35:16.316 --> 00:35:18.026 A:middle
creation date out as a string

00:35:18.026 --> 00:35:19.616 A:middle
and then had to pass it along to

00:35:19.616 --> 00:35:22.586 A:middle
a date formatter to get a valid

00:35:22.586 --> 00:35:25.186 A:middle
date back out.

00:35:25.396 --> 00:35:26.836 A:middle
Here, because we can use JSON

00:35:26.836 --> 00:35:29.156 A:middle
decoder, we can simply decode a

00:35:29.156 --> 00:35:30.336 A:middle
date directly, we don't have to

00:35:30.336 --> 00:35:31.416 A:middle
worry about that type

00:35:31.446 --> 00:35:31.926 A:middle
conversion.

00:35:32.766 --> 00:35:34.266 A:middle
We can use JSON decoders date

00:35:34.296 --> 00:35:36.556 A:middle
decoding policy to indicate what

00:35:36.556 --> 00:35:37.816 A:middle
sort of conversion can happen

00:35:37.816 --> 00:35:37.936 A:middle
here.

00:35:38.186 --> 00:35:40.386 A:middle
And this is nice because this

00:35:40.386 --> 00:35:41.636 A:middle
conversion became a one-liner.

00:35:42.796 --> 00:35:44.626 A:middle
And, the other decode call is

00:35:44.626 --> 00:35:46.156 A:middle
also a one-liner, which makes it

00:35:46.156 --> 00:35:47.496 A:middle
easy for me to focus on the

00:35:47.496 --> 00:35:48.946 A:middle
types of validation that I care

00:35:49.536 --> 00:35:49.726 A:middle
about.

00:35:51.056 --> 00:35:52.706 A:middle
Now, later on in the validate

00:35:52.706 --> 00:35:53.786 A:middle
function, I might have also

00:35:53.786 --> 00:35:55.316 A:middle
pulled out that substructure of

00:35:55.316 --> 00:35:57.126 A:middle
tags out as an array of strings,

00:35:57.336 --> 00:35:58.876 A:middle
and later had to map those

00:35:58.876 --> 00:36:00.496 A:middle
strings to my own type, maybe


00:35:58.876 --> 00:36:00.496 A:middle
strings to my own type, maybe

00:36:00.586 --> 00:36:02.026 A:middle
for further validation later on.

00:36:04.026 --> 00:36:05.736 A:middle
Here, again with Codable, I have

00:36:05.736 --> 00:36:07.286 A:middle
the benefit of tag conforming to

00:36:07.286 --> 00:36:08.126 A:middle
Codable itself.

00:36:08.126 --> 00:36:09.806 A:middle
And so, I can just decode an

00:36:09.806 --> 00:36:10.816 A:middle
array of tags directly.

00:36:11.726 --> 00:36:12.846 A:middle
This happens automatically.

00:36:12.846 --> 00:36:14.356 A:middle
And instead of focusing on the

00:36:14.356 --> 00:36:15.456 A:middle
type conversion, allows me to

00:36:15.456 --> 00:36:16.776 A:middle
focus on the validation that

00:36:16.776 --> 00:36:17.386 A:middle
matters to me.

00:36:18.236 --> 00:36:19.416 A:middle
This lets me make sure that this

00:36:19.466 --> 00:36:20.686 A:middle
data is data I can trust.

00:36:24.156 --> 00:36:25.966 A:middle
We talked about a lot today.

00:36:27.196 --> 00:36:28.636 A:middle
We started with raw data and

00:36:28.636 --> 00:36:30.326 A:middle
carried it all away across the

00:36:30.326 --> 00:36:31.776 A:middle
abstraction spectrum to our own

00:36:31.776 --> 00:36:32.476 A:middle
model types.

00:36:32.716 --> 00:36:34.486 A:middle
And along the way we saw how to

00:36:34.486 --> 00:36:38.456 A:middle
build trust into that data by

00:36:38.676 --> 00:36:40.496 A:middle
validating a checksum, or the

00:36:40.496 --> 00:36:42.056 A:middle
length on that raw data, we made

00:36:42.056 --> 00:36:43.366 A:middle
sure that it was valid to work

00:36:43.366 --> 00:36:45.226 A:middle
with an inspect, and even check

00:36:45.716 --> 00:36:46.666 A:middle
whether it conforms to some

00:36:46.666 --> 00:36:47.046 A:middle
format.

00:36:47.356 --> 00:36:48.556 A:middle
Once we've made sure that it

00:36:48.556 --> 00:36:50.746 A:middle
conforms to a known format, we

00:36:50.746 --> 00:36:52.636 A:middle
knew that that formatted data

00:36:52.636 --> 00:36:54.376 A:middle
was valid to work with and pull

00:36:54.446 --> 00:36:55.466 A:middle
primitive values out of.

00:36:57.196 --> 00:36:59.106 A:middle
By validating the contents and

00:36:59.106 --> 00:37:00.476 A:middle
structure of those primitive


00:36:59.106 --> 00:37:00.476 A:middle
structure of those primitive

00:37:00.476 --> 00:37:02.006 A:middle
values, we made sure that it was

00:37:02.006 --> 00:37:03.346 A:middle
valid to work with them to turn

00:37:03.346 --> 00:37:05.026 A:middle
them into our own model types.

00:37:06.476 --> 00:37:07.966 A:middle
By validating the semantics and

00:37:07.966 --> 00:37:09.216 A:middle
relationships between those

00:37:09.216 --> 00:37:10.846 A:middle
model types, we made sure that

00:37:10.846 --> 00:37:12.166 A:middle
they were valid to work with and

00:37:12.166 --> 00:37:13.076 A:middle
that they were data we could

00:37:13.766 --> 00:37:13.946 A:middle
trust.

00:37:15.216 --> 00:37:16.746 A:middle
So, where to go from here?

00:37:18.116 --> 00:37:19.136 A:middle
Well, now that you know all of

00:37:19.136 --> 00:37:20.346 A:middle
this, I encourage you to go and

00:37:20.346 --> 00:37:21.926 A:middle
look at your code and do just

00:37:21.926 --> 00:37:22.286 A:middle
this.

00:37:23.386 --> 00:37:26.426 A:middle
Validate data at every stage in

00:37:26.426 --> 00:37:27.476 A:middle
the lifecycle of that data.

00:37:28.046 --> 00:37:29.406 A:middle
Check for types and nullability.

00:37:29.646 --> 00:37:30.916 A:middle
But more importantly, range, and

00:37:30.916 --> 00:37:32.186 A:middle
length, and domain-specific

00:37:32.186 --> 00:37:32.926 A:middle
applications.

00:37:33.516 --> 00:37:35.956 A:middle
If you have NSCoding types,

00:37:36.246 --> 00:37:37.736 A:middle
audit those types and earn your

00:37:37.796 --> 00:37:38.816 A:middle
NSSecureCoding badge.

00:37:38.936 --> 00:37:40.186 A:middle
And don't just earn it, use it.

00:37:40.286 --> 00:37:41.786 A:middle
Turn on secure coding wherever

00:37:41.786 --> 00:37:42.146 A:middle
you can.

00:37:43.656 --> 00:37:45.596 A:middle
And lastly, for new data types,

00:37:45.666 --> 00:37:47.556 A:middle
adopt Codable where possible and

00:37:47.556 --> 00:37:48.826 A:middle
make sure to perform that

00:37:48.826 --> 00:37:49.456 A:middle
validation.

00:37:50.246 --> 00:37:51.556 A:middle
Make sure you're only ever

00:37:51.556 --> 00:37:53.826 A:middle
working with data you can trust.

00:37:54.936 --> 00:37:56.026 A:middle
For more information about

00:37:56.026 --> 00:37:57.926 A:middle
Codable, specifically, see last

00:37:57.926 --> 00:37:58.976 A:middle
year's talk about What's New in

00:37:58.976 --> 00:37:59.486 A:middle
Foundation.

00:37:59.716 --> 00:38:01.076 A:middle
But if you have more questions


00:37:59.716 --> 00:38:01.076 A:middle
But if you have more questions

00:38:01.076 --> 00:38:02.346 A:middle
about this topic or want to come

00:38:02.346 --> 00:38:04.136 A:middle
to us for help on how to apply

00:38:04.136 --> 00:38:05.626 A:middle
this in your own apps, come to

00:38:05.626 --> 00:38:06.766 A:middle
our lab later today, we have a

00:38:06.766 --> 00:38:07.816 A:middle
foundation lab, where we can

00:38:07.816 --> 00:38:09.446 A:middle
help you do just that.

00:38:10.096 --> 00:38:11.636 A:middle
With that, I'd like to say thank

00:38:11.636 --> 00:38:12.066 A:middle
you very much.

00:38:13.266 --> 00:38:13.716 A:middle
Have a great day.

00:38:14.516 --> 00:38:17.500 A:middle
[ Applause ]
