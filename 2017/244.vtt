WEBVTT

00:00:20.516 --> 00:00:24.086 A:middle
[ Applause ]

00:00:24.586 --> 00:00:25.246 A:middle
&gt;&gt; Good afternoon.

00:00:25.356 --> 00:00:26.606 A:middle
My name is Phillipe Hausler, and

00:00:26.606 --> 00:00:27.726 A:middle
I'm here today, with my

00:00:27.726 --> 00:00:28.686 A:middle
colleague, Donna Tom.

00:00:28.726 --> 00:00:29.816 A:middle
And we're going to talk about

00:00:29.816 --> 00:00:30.996 A:middle
Efficient Interaction with

00:00:31.066 --> 00:00:31.686 A:middle
Frameworks.

00:00:32.566 --> 00:00:34.566 A:middle
Now, we all care very deeply

00:00:34.566 --> 00:00:35.776 A:middle
about performance.

00:00:35.896 --> 00:00:37.596 A:middle
We want our laptops to be fast.

00:00:37.596 --> 00:00:39.376 A:middle
We want our phones and tablets

00:00:39.376 --> 00:00:41.126 A:middle
to have all day battery life.

00:00:41.176 --> 00:00:42.816 A:middle
And we want to do amazing things

00:00:42.816 --> 00:00:43.776 A:middle
with our desktops.

00:00:43.966 --> 00:00:45.476 A:middle
As a matter of fact, all of

00:00:45.476 --> 00:00:46.886 A:middle
these devices should have great

00:00:46.926 --> 00:00:47.636 A:middle
performance.

00:00:48.066 --> 00:00:49.826 A:middle
And it's our jobs to be able to

00:00:49.826 --> 00:00:50.656 A:middle
make that happen.

00:00:52.236 --> 00:00:53.376 A:middle
Now, performance has many

00:00:53.376 --> 00:00:54.066 A:middle
dimensions.

00:00:54.256 --> 00:00:56.396 A:middle
How fast code can run, how much

00:00:56.396 --> 00:00:57.446 A:middle
power it takes.

00:00:57.666 --> 00:00:59.166 A:middle
Or what the memory footprint of

00:00:59.166 --> 00:00:59.776 A:middle
that is.

00:01:00.106 --> 00:01:01.156 A:middle
Since, there are multiple

00:01:01.156 --> 00:01:02.886 A:middle
dimensions, how can we visualize

00:01:02.946 --> 00:01:03.766 A:middle
this a little bit better?

00:01:04.686 --> 00:01:06.296 A:middle
To give you a framework, no pun

00:01:06.296 --> 00:01:08.356 A:middle
intended, for visualizing this.

00:01:08.356 --> 00:01:09.786 A:middle
You can think of it as a graph

00:01:09.916 --> 00:01:11.276 A:middle
with the size of the data that

00:01:11.276 --> 00:01:12.766 A:middle
you're working with on one axis

00:01:13.136 --> 00:01:14.716 A:middle
and the frequency on another.

00:01:15.456 --> 00:01:17.196 A:middle
If you're looking at a lot of

00:01:17.196 --> 00:01:18.896 A:middle
data and code that runs very

00:01:18.896 --> 00:01:20.516 A:middle
frequently, you're going to be

00:01:20.516 --> 00:01:22.356 A:middle
up there in that first quadrant.

00:01:22.646 --> 00:01:24.146 A:middle
And these are going to be things

00:01:24.146 --> 00:01:25.126 A:middle
that are going to be likely to

00:01:25.126 --> 00:01:26.646 A:middle
be able to make a notable impact

00:01:26.646 --> 00:01:27.486 A:middle
upon performance.

00:01:27.886 --> 00:01:29.006 A:middle
And you're going to want to

00:01:29.006 --> 00:01:30.936 A:middle
spend time optimizing these

00:01:30.936 --> 00:01:31.576 A:middle
cases.

00:01:32.486 --> 00:01:33.716 A:middle
But if you're looking at

00:01:33.826 --> 00:01:35.166 A:middle
something that works with just a

00:01:35.166 --> 00:01:36.746 A:middle
little bit of data and runs just

00:01:36.746 --> 00:01:37.536 A:middle
a few times.

00:01:37.536 --> 00:01:38.436 A:middle
You're going to be down there in

00:01:38.436 --> 00:01:39.466 A:middle
that third quadrant.

00:01:39.766 --> 00:01:41.626 A:middle
And to be honest, you really

00:01:41.626 --> 00:01:42.656 A:middle
don't want to spend a whole lot

00:01:42.656 --> 00:01:44.146 A:middle
of time worrying about them, too

00:01:44.146 --> 00:01:44.616 A:middle
much.

00:01:45.546 --> 00:01:47.636 A:middle
It's that second and fourth

00:01:47.636 --> 00:01:48.776 A:middle
quadrant that are a bit

00:01:48.776 --> 00:01:49.316 A:middle
trickier.

00:01:49.726 --> 00:01:51.346 A:middle
These are gray areas that are

00:01:51.346 --> 00:01:52.476 A:middle
highly dependent upon the

00:01:52.476 --> 00:01:53.336 A:middle
situation.

00:01:53.426 --> 00:01:54.766 A:middle
And in these cases, you'll most

00:01:54.766 --> 00:01:55.896 A:middle
certainly want to be able to

00:01:55.896 --> 00:01:57.056 A:middle
measure the performance in a

00:01:57.056 --> 00:01:59.216 A:middle
scenario that reflects actual

00:01:59.216 --> 00:01:59.876 A:middle
usage.

00:02:00.266 --> 00:02:01.806 A:middle
And then, use that information

00:02:01.806 --> 00:02:03.156 A:middle
to be able to evaluate whether

00:02:03.156 --> 00:02:04.446 A:middle
it's worth your time to be able

00:02:04.446 --> 00:02:05.466 A:middle
to make changes.

00:02:06.036 --> 00:02:09.096 A:middle
In this release, we took a deep

00:02:09.156 --> 00:02:10.856 A:middle
look to be able to understand

00:02:10.856 --> 00:02:11.806 A:middle
how we could make performance

00:02:11.806 --> 00:02:12.946 A:middle
better across the operating

00:02:12.946 --> 00:02:13.406 A:middle
system.

00:02:13.686 --> 00:02:15.116 A:middle
But for your apps, as well.

00:02:15.886 --> 00:02:17.466 A:middle
We will go over a few really

00:02:17.466 --> 00:02:18.716 A:middle
awesome changes that we made in

00:02:18.716 --> 00:02:19.356 A:middle
Foundation.

00:02:20.276 --> 00:02:21.526 A:middle
And of course, Swift has been a

00:02:21.666 --> 00:02:23.716 A:middle
big part of this release, as we

00:02:23.716 --> 00:02:25.376 A:middle
took a long hard look at how

00:02:25.376 --> 00:02:26.866 A:middle
bridging works for some of the

00:02:26.866 --> 00:02:27.786 A:middle
Foundation types.

00:02:28.026 --> 00:02:30.296 A:middle
To be able to make them faster

00:02:30.296 --> 00:02:31.346 A:middle
and work better in your

00:02:31.346 --> 00:02:32.226 A:middle
applications.

00:02:33.676 --> 00:02:35.146 A:middle
Now, strings are, of course, are

00:02:35.146 --> 00:02:36.986 A:middle
a huge part of many apps.

00:02:37.086 --> 00:02:38.896 A:middle
They're used as tokens, human

00:02:38.896 --> 00:02:40.466 A:middle
readable data formats, and

00:02:40.466 --> 00:02:41.636 A:middle
displaying to the screen.

00:02:42.066 --> 00:02:44.056 A:middle
And efficient string handling

00:02:44.296 --> 00:02:45.856 A:middle
makes a big impact on many

00:02:45.856 --> 00:02:46.596 A:middle
applications.

00:02:46.686 --> 00:02:48.486 A:middle
And often is a huge part of the

00:02:48.486 --> 00:02:50.326 A:middle
critical content being displayed

00:02:50.326 --> 00:02:51.036 A:middle
to users.

00:02:52.136 --> 00:02:53.086 A:middle
But of course, the reason why

00:02:53.176 --> 00:02:54.986 A:middle
you are here, is you want to

00:02:54.986 --> 00:02:56.586 A:middle
make your app run faster.

00:02:56.746 --> 00:02:58.126 A:middle
You want to use less energy.

00:02:58.436 --> 00:02:59.736 A:middle
You want to get more things done

00:02:59.766 --> 00:03:00.486 A:middle
with less RAM.

00:03:00.526 --> 00:03:02.456 A:middle
And don't worry, we'll get to

00:03:02.456 --> 00:03:03.996 A:middle
that on each of the sections

00:03:03.996 --> 00:03:05.396 A:middle
that we're going to be talking,

00:03:05.396 --> 00:03:06.016 A:middle
today, about.

00:03:06.356 --> 00:03:07.486 A:middle
To give you things to keep in

00:03:07.486 --> 00:03:08.756 A:middle
mind when optimizing for

00:03:08.996 --> 00:03:10.366 A:middle
performance.

00:03:11.596 --> 00:03:13.826 A:middle
Now, as I said, we made a number

00:03:13.826 --> 00:03:14.816 A:middle
of performance improvements

00:03:14.816 --> 00:03:16.216 A:middle
across the operating system.

00:03:16.556 --> 00:03:18.126 A:middle
And in Foundation, we made some

00:03:18.126 --> 00:03:19.276 A:middle
pretty nice changes.

00:03:19.416 --> 00:03:20.736 A:middle
These are just a few of the

00:03:20.736 --> 00:03:21.546 A:middle
highlights.

00:03:22.366 --> 00:03:24.186 A:middle
We overhauled NSCalendar for

00:03:24.186 --> 00:03:25.916 A:middle
date enumeration, not only to

00:03:25.916 --> 00:03:28.116 A:middle
use less memory, but also, it's

00:03:28.116 --> 00:03:29.236 A:middle
much faster, too.

00:03:29.806 --> 00:03:31.126 A:middle
And trust me when I say,

00:03:31.126 --> 00:03:33.206 A:middle
calendrical calculations are

00:03:33.406 --> 00:03:34.686 A:middle
really tricky to get right.

00:03:35.186 --> 00:03:37.696 A:middle
And then, this update, the

00:03:37.696 --> 00:03:39.716 A:middle
NSCalendar implementation is not

00:03:39.716 --> 00:03:41.646 A:middle
only faster, but also, corrects

00:03:41.646 --> 00:03:43.166 A:middle
some outstanding Edge cases that

00:03:43.166 --> 00:03:44.196 A:middle
have been lurking around for a

00:03:44.196 --> 00:03:44.776 A:middle
while, now.

00:03:46.106 --> 00:03:48.306 A:middle
But when making changes, you

00:03:48.306 --> 00:03:49.706 A:middle
have to consider the scale at

00:03:49.706 --> 00:03:50.856 A:middle
which that change will impact.

00:03:51.456 --> 00:03:52.766 A:middle
And in Foundation and Core

00:03:52.766 --> 00:03:54.526 A:middle
Foundation, we took a number of

00:03:54.526 --> 00:03:56.306 A:middle
places where the small things

00:03:56.306 --> 00:03:57.016 A:middle
that would add up.

00:03:57.466 --> 00:03:59.036 A:middle
And we looked at a deep dive of

00:03:59.036 --> 00:04:00.496 A:middle
how thread-safe operations in

00:04:00.496 --> 00:04:01.466 A:middle
Foundation work.

00:04:01.676 --> 00:04:03.186 A:middle
And decided to migrate to using

00:04:03.186 --> 00:04:04.906 A:middle
Atomics and OS and Fairlock,

00:04:05.226 --> 00:04:06.636 A:middle
which in the end, ends up

00:04:06.636 --> 00:04:07.726 A:middle
playing a lot better with

00:04:07.726 --> 00:04:08.866 A:middle
quality of service.

00:04:10.056 --> 00:04:11.966 A:middle
Now, speaking of quality of

00:04:11.966 --> 00:04:13.836 A:middle
service, NSOperation and

00:04:13.836 --> 00:04:15.576 A:middle
OperationQueue have been also

00:04:15.576 --> 00:04:17.716 A:middle
overhauled to have more correct

00:04:17.716 --> 00:04:18.796 A:middle
implementation, whenever it

00:04:18.796 --> 00:04:19.796 A:middle
comes to their quality of

00:04:19.796 --> 00:04:20.386 A:middle
service.

00:04:20.886 --> 00:04:22.016 A:middle
You'll see some pretty neat

00:04:22.016 --> 00:04:23.326 A:middle
performance improvements, as

00:04:23.326 --> 00:04:23.686 A:middle
well.

00:04:24.046 --> 00:04:26.016 A:middle
And in heavy cases, we've seen

00:04:26.016 --> 00:04:28.326 A:middle
up to 25% improvement on

00:04:28.326 --> 00:04:30.116 A:middle
queueing operations, just to

00:04:30.116 --> 00:04:31.346 A:middle
point out one highlight.

00:04:31.896 --> 00:04:34.836 A:middle
And after working for a while,

00:04:34.836 --> 00:04:37.486 A:middle
now, in Swift, we realized that

00:04:37.486 --> 00:04:39.176 A:middle
copy on write is pretty

00:04:39.176 --> 00:04:40.066 A:middle
fantastic.

00:04:40.546 --> 00:04:42.746 A:middle
And in Foundation, a number of

00:04:42.746 --> 00:04:44.786 A:middle
the collection types will now

00:04:44.786 --> 00:04:46.196 A:middle
use copy on write as their

00:04:46.196 --> 00:04:47.246 A:middle
backing storage.

00:04:48.606 --> 00:04:50.486 A:middle
So, what's this whole copy on

00:04:50.486 --> 00:04:51.066 A:middle
write thing?

00:04:51.666 --> 00:04:54.026 A:middle
Copy on write is a mechanism, or

00:04:54.316 --> 00:04:57.426 A:middle
COW for short, where two items

00:04:57.426 --> 00:04:58.726 A:middle
can point to a shared backing

00:04:58.726 --> 00:05:01.016 A:middle
store until a mutation occurs.

00:05:01.656 --> 00:05:03.436 A:middle
And when that mutation happens,

00:05:03.616 --> 00:05:05.646 A:middle
the mutating party copies that

00:05:05.646 --> 00:05:06.946 A:middle
backing storage to be able to

00:05:06.946 --> 00:05:08.406 A:middle
allow for the write to happen.

00:05:08.946 --> 00:05:11.316 A:middle
So, in short, copying isn't

00:05:11.316 --> 00:05:12.436 A:middle
costly, anymore.

00:05:12.926 --> 00:05:14.126 A:middle
This means that whenever you

00:05:14.126 --> 00:05:15.726 A:middle
defensively copy a mutable

00:05:15.726 --> 00:05:17.976 A:middle
container, it's almost free.

00:05:19.056 --> 00:05:20.936 A:middle
And before, copies of

00:05:20.936 --> 00:05:23.066 A:middle
collections were at best, linear

00:05:23.066 --> 00:05:24.096 A:middle
execution time.

00:05:24.556 --> 00:05:26.346 A:middle
And now, whenever you copy them,

00:05:26.506 --> 00:05:28.716 A:middle
they're constant until a shared

00:05:28.716 --> 00:05:29.306 A:middle
mutation.

00:05:30.076 --> 00:05:31.376 A:middle
So, let's pull that apart a

00:05:31.376 --> 00:05:33.376 A:middle
little bit and understand how

00:05:33.376 --> 00:05:34.556 A:middle
it's working, under the hood.

00:05:34.556 --> 00:05:37.466 A:middle
So, in this particular example,

00:05:37.466 --> 00:05:38.866 A:middle
we're creating a new mutable

00:05:38.866 --> 00:05:39.126 A:middle
array.

00:05:39.726 --> 00:05:42.376 A:middle
And when this happens, we

00:05:42.376 --> 00:05:44.026 A:middle
initially have a COW backing

00:05:44.026 --> 00:05:46.006 A:middle
store that holds zero items.

00:05:47.036 --> 00:05:49.476 A:middle
So, we do some extra work and in

00:05:49.666 --> 00:05:51.526 A:middle
our application, we then call

00:05:51.526 --> 00:05:51.946 A:middle
copy.

00:05:52.646 --> 00:05:53.766 A:middle
In this particular case, we're

00:05:53.766 --> 00:05:55.996 A:middle
assigning B as a copy of A.

00:05:56.666 --> 00:05:58.486 A:middle
And whenever that copy has

00:05:58.486 --> 00:06:00.216 A:middle
occurred, the only price that

00:06:00.216 --> 00:06:02.316 A:middle
you pay in your application is

00:06:02.316 --> 00:06:04.276 A:middle
the allocation of the new

00:06:04.276 --> 00:06:04.926 A:middle
collection.

00:06:05.276 --> 00:06:06.696 A:middle
You don't have to actually copy

00:06:06.696 --> 00:06:07.566 A:middle
any of the items.

00:06:07.836 --> 00:06:09.116 A:middle
So, in this case, we're still

00:06:09.116 --> 00:06:10.626 A:middle
pointing to the same backing

00:06:10.626 --> 00:06:13.346 A:middle
store that holds zero items.

00:06:13.856 --> 00:06:16.486 A:middle
So, later on, if we were to make

00:06:16.486 --> 00:06:18.756 A:middle
a mutation, then what will

00:06:18.756 --> 00:06:21.616 A:middle
happen is that the copying party

00:06:21.966 --> 00:06:24.226 A:middle
initially has a reference to

00:06:24.226 --> 00:06:25.886 A:middle
that shared backing store.

00:06:26.246 --> 00:06:27.886 A:middle
So, in order to make a mutation,

00:06:28.056 --> 00:06:29.696 A:middle
it has to copy from that backing

00:06:29.696 --> 00:06:31.256 A:middle
store to be able to make sure

00:06:31.256 --> 00:06:33.106 A:middle
that the mutation is in safe.

00:06:34.346 --> 00:06:35.606 A:middle
But you have to take in

00:06:35.606 --> 00:06:37.086 A:middle
consideration that most

00:06:37.086 --> 00:06:38.536 A:middle
applications are going to be

00:06:38.596 --> 00:06:40.066 A:middle
ending at that point, right

00:06:40.116 --> 00:06:41.776 A:middle
there, whenever you don't have

00:06:41.776 --> 00:06:43.166 A:middle
any further mutations.

00:06:43.636 --> 00:06:46.096 A:middle
So, as you can see, you can end

00:06:46.096 --> 00:06:47.666 A:middle
up having a vast performance

00:06:47.666 --> 00:06:50.666 A:middle
improvement by leveraging this

00:06:50.966 --> 00:06:51.376 A:middle
feature.

00:06:52.286 --> 00:06:53.786 A:middle
Now, let's see how you can

00:06:53.786 --> 00:06:55.076 A:middle
actually use this in your

00:06:55.076 --> 00:06:55.846 A:middle
application.

00:06:56.556 --> 00:06:58.376 A:middle
Now, I'm as guilty as the next

00:06:58.376 --> 00:06:58.906 A:middle
developer.

00:06:59.336 --> 00:07:01.096 A:middle
I've written code like this with

00:07:01.096 --> 00:07:03.556 A:middle
comments, with the hopes that my

00:07:03.556 --> 00:07:04.836 A:middle
colleagues are going to follow

00:07:04.836 --> 00:07:06.656 A:middle
my suggestion, all in the name

00:07:06.656 --> 00:07:07.666 A:middle
of performance.

00:07:08.306 --> 00:07:09.846 A:middle
But there's a little pitfall,

00:07:09.846 --> 00:07:12.146 A:middle
here that if a mutable array

00:07:12.146 --> 00:07:14.836 A:middle
were to have snuck in, then we

00:07:14.836 --> 00:07:15.906 A:middle
would end up sharing mutable

00:07:15.906 --> 00:07:16.436 A:middle
state.

00:07:16.576 --> 00:07:17.626 A:middle
Which means we are going to be

00:07:17.626 --> 00:07:18.646 A:middle
sharing bugs.

00:07:18.986 --> 00:07:19.866 A:middle
Nobody wants that.

00:07:20.776 --> 00:07:22.466 A:middle
But since copies are nearly

00:07:22.466 --> 00:07:24.326 A:middle
free, now, we can do the same

00:07:24.326 --> 00:07:26.346 A:middle
thing every single time and not

00:07:26.416 --> 00:07:27.186 A:middle
have to worry about the

00:07:27.186 --> 00:07:27.976 A:middle
performance hit.

00:07:27.976 --> 00:07:29.246 A:middle
It's pretty great.

00:07:30.476 --> 00:07:31.556 A:middle
But it isn't just the copy

00:07:31.556 --> 00:07:32.786 A:middle
nature of properties.

00:07:33.226 --> 00:07:34.776 A:middle
Many times, mutable containers

00:07:34.776 --> 00:07:35.956 A:middle
are used to build things up.

00:07:36.546 --> 00:07:38.556 A:middle
And in this sample, the author

00:07:38.556 --> 00:07:40.526 A:middle
knew that NSMutableArray is a

00:07:40.526 --> 00:07:41.876 A:middle
subclass of an NSArray.

00:07:42.466 --> 00:07:44.466 A:middle
And the advertised return value

00:07:44.466 --> 00:07:45.486 A:middle
is an NSArray.

00:07:45.716 --> 00:07:47.996 A:middle
So, it's mostly safe, right?

00:07:48.726 --> 00:07:50.426 A:middle
Well, unfortunately, there's

00:07:50.426 --> 00:07:52.286 A:middle
some other consequences that can

00:07:52.286 --> 00:07:52.956 A:middle
happen, here.

00:07:53.356 --> 00:07:54.736 A:middle
If somebody checks the actual

00:07:54.736 --> 00:07:56.936 A:middle
class of the return type, well,

00:07:56.936 --> 00:07:57.506 A:middle
oops.

00:07:57.556 --> 00:07:58.706 A:middle
They could end up having a

00:07:58.706 --> 00:08:00.326 A:middle
mutation of shared state, again.

00:08:00.906 --> 00:08:03.176 A:middle
So instead, you can defensively

00:08:03.176 --> 00:08:05.466 A:middle
copy return values so that it

00:08:05.466 --> 00:08:06.986 A:middle
does the right thing without

00:08:07.046 --> 00:08:08.026 A:middle
having to worry about the

00:08:08.026 --> 00:08:09.186 A:middle
performance costs.

00:08:10.396 --> 00:08:12.266 A:middle
There's actually another case

00:08:12.416 --> 00:08:14.626 A:middle
that's a little bit more hidden.

00:08:14.846 --> 00:08:17.356 A:middle
In the case of Swift, whenever

00:08:17.526 --> 00:08:19.186 A:middle
either of these two APIs were

00:08:19.286 --> 00:08:22.096 A:middle
exported, we have to make a copy

00:08:22.286 --> 00:08:23.806 A:middle
to be able to preserve value

00:08:23.806 --> 00:08:24.446 A:middle
types.

00:08:24.866 --> 00:08:27.226 A:middle
And so, if you cast to an array

00:08:27.226 --> 00:08:29.006 A:middle
of any, from the NSArray for

00:08:29.046 --> 00:08:30.806 A:middle
either of these two APIs, the

00:08:30.806 --> 00:08:32.506 A:middle
previous implementation would

00:08:33.006 --> 00:08:35.406 A:middle
have to spend a linear execution

00:08:35.406 --> 00:08:36.526 A:middle
time to be able to make that

00:08:36.526 --> 00:08:36.926 A:middle
copy.

00:08:37.356 --> 00:08:39.506 A:middle
If you defensively do so, the

00:08:39.506 --> 00:08:41.086 A:middle
copy then, doesn't end up

00:08:41.136 --> 00:08:42.676 A:middle
attributing to some other place

00:08:42.736 --> 00:08:44.096 A:middle
that is unknown performance

00:08:45.246 --> 00:08:45.396 A:middle
costs.

00:08:47.396 --> 00:08:49.956 A:middle
In Swift 3, we introduced a

00:08:49.956 --> 00:08:51.996 A:middle
number of structural types for

00:08:51.996 --> 00:08:52.656 A:middle
Foundation.

00:08:53.256 --> 00:08:54.856 A:middle
One that made a whole lot of

00:08:54.856 --> 00:08:56.886 A:middle
sense was NSData being bridged

00:08:56.886 --> 00:08:58.386 A:middle
to the structural type data.

00:08:59.426 --> 00:09:01.746 A:middle
And we took a long look at data

00:09:01.746 --> 00:09:03.696 A:middle
to be able to understand common

00:09:03.696 --> 00:09:05.386 A:middle
use cases and places that we

00:09:05.386 --> 00:09:06.986 A:middle
could improve data to be able to

00:09:06.986 --> 00:09:08.176 A:middle
make it work better in our

00:09:08.176 --> 00:09:09.066 A:middle
applications.

00:09:09.906 --> 00:09:11.986 A:middle
And in this release, we've got

00:09:12.206 --> 00:09:14.736 A:middle
now data is its own slice type.

00:09:14.786 --> 00:09:15.846 A:middle
And we've looked at the

00:09:15.846 --> 00:09:17.166 A:middle
performance for being able to do

00:09:17.166 --> 00:09:18.816 A:middle
common tasks like for example,

00:09:19.086 --> 00:09:20.446 A:middle
getting the Count of the data.

00:09:20.666 --> 00:09:22.566 A:middle
Or indexing to a specific byte

00:09:22.566 --> 00:09:23.546 A:middle
at an offset.

00:09:24.636 --> 00:09:25.566 A:middle
And some of these

00:09:25.566 --> 00:09:28.026 A:middle
implementations are kind of

00:09:28.026 --> 00:09:28.566 A:middle
extreme.

00:09:28.806 --> 00:09:30.046 A:middle
Normally a few machine

00:09:30.046 --> 00:09:31.556 A:middle
instructions wouldn't move the

00:09:31.556 --> 00:09:32.486 A:middle
needle, at all.

00:09:32.916 --> 00:09:33.766 A:middle
But what it comes to

00:09:33.766 --> 00:09:36.546 A:middle
representing a byte buffer, even

00:09:36.546 --> 00:09:39.016 A:middle
20 versus four instructions can

00:09:39.146 --> 00:09:41.896 A:middle
actually make a difference.

00:09:41.986 --> 00:09:43.856 A:middle
So, this code looks pretty

00:09:43.856 --> 00:09:44.146 A:middle
simple.

00:09:44.446 --> 00:09:47.576 A:middle
But if has a few interesting

00:09:47.576 --> 00:09:49.526 A:middle
characteristics that reveal some

00:09:49.526 --> 00:09:50.906 A:middle
insight on how we could make

00:09:50.906 --> 00:09:51.796 A:middle
data faster.

00:09:52.606 --> 00:09:54.446 A:middle
First off, data is a collection,

00:09:54.656 --> 00:09:55.596 A:middle
just like array.

00:09:55.926 --> 00:09:57.456 A:middle
It can be subscripted, but both

00:09:57.456 --> 00:09:58.986 A:middle
indexes and ranges.

00:09:59.626 --> 00:10:01.576 A:middle
So, this means that the start

00:10:01.576 --> 00:10:03.846 A:middle
index of the data, is not always

00:10:03.846 --> 00:10:03.976 A:middle
zero.

00:10:04.136 --> 00:10:06.536 A:middle
Because the index is similar to

00:10:06.606 --> 00:10:07.576 A:middle
iterators in the other

00:10:07.576 --> 00:10:08.466 A:middle
languages.

00:10:09.026 --> 00:10:10.016 A:middle
And for the record, this code

00:10:10.016 --> 00:10:11.376 A:middle
has nothing wrong with it.

00:10:11.376 --> 00:10:13.606 A:middle
We just used it to be able to

00:10:13.606 --> 00:10:15.116 A:middle
understand what parts of data

00:10:15.116 --> 00:10:16.076 A:middle
should be refined.

00:10:16.786 --> 00:10:19.096 A:middle
So, the two questions, here, are

00:10:19.446 --> 00:10:20.646 A:middle
how big is the data that we're

00:10:20.646 --> 00:10:21.176 A:middle
dealing with?

00:10:21.476 --> 00:10:23.516 A:middle
And how many times it's called?

00:10:23.946 --> 00:10:25.436 A:middle
Where is it on that chart?

00:10:26.206 --> 00:10:28.226 A:middle
And the answer truly is that it

00:10:28.226 --> 00:10:29.966 A:middle
could fall on almost any of

00:10:30.036 --> 00:10:30.326 A:middle
them.

00:10:30.786 --> 00:10:32.556 A:middle
And most likely, it's in that

00:10:32.556 --> 00:10:33.576 A:middle
place where it needs to be

00:10:33.576 --> 00:10:34.016 A:middle
measured.

00:10:34.946 --> 00:10:36.896 A:middle
So, we did exactly that.

00:10:36.896 --> 00:10:40.656 A:middle
And on the top in the blue, is

00:10:40.656 --> 00:10:42.106 A:middle
the initial Swift 3 version of

00:10:42.106 --> 00:10:42.466 A:middle
Data.

00:10:43.046 --> 00:10:46.296 A:middle
And when subscripting, it took

00:10:46.416 --> 00:10:48.316 A:middle
about 16 nanoseconds on the

00:10:48.316 --> 00:10:49.926 A:middle
machine that I was using to be

00:10:49.926 --> 00:10:52.126 A:middle
able to profile it.

00:10:52.126 --> 00:10:54.346 A:middle
And since data is a common

00:10:54.346 --> 00:10:56.126 A:middle
currency of dealing with a

00:10:56.126 --> 00:10:58.096 A:middle
collection of bytes, this should

00:10:58.096 --> 00:11:01.046 A:middle
be really, really fast.

00:11:01.046 --> 00:11:02.806 A:middle
After tuning, we got it just

00:11:02.806 --> 00:11:04.706 A:middle
down to four nanoseconds.

00:11:04.856 --> 00:11:05.676 A:middle
It's pretty impressive.

00:11:06.446 --> 00:11:08.116 A:middle
And if you were using Data,

00:11:08.116 --> 00:11:10.716 A:middle
before, you get this advantage

00:11:10.816 --> 00:11:11.486 A:middle
for free.

00:11:12.176 --> 00:11:14.006 A:middle
And it will also be able to

00:11:14.056 --> 00:11:15.816 A:middle
interoperate with all the rest

00:11:15.816 --> 00:11:17.766 A:middle
of the APIs that take and use

00:11:18.406 --> 00:11:18.556 A:middle
data.

00:11:19.576 --> 00:11:20.196 A:middle
Thanks.

00:11:21.416 --> 00:11:23.416 A:middle
[ Applause ]

00:11:23.816 --> 00:11:26.356 A:middle
Now again, preface, here for

00:11:26.356 --> 00:11:28.236 A:middle
you, none of these examples are

00:11:28.236 --> 00:11:29.906 A:middle
clearly wrong or harmful.

00:11:30.266 --> 00:11:31.636 A:middle
But they do have things to be

00:11:31.636 --> 00:11:33.536 A:middle
able to consider versus their

00:11:33.536 --> 00:11:34.546 A:middle
counterparts.

00:11:35.716 --> 00:11:37.606 A:middle
Oftentimes, it's viewed that a

00:11:37.606 --> 00:11:38.716 A:middle
collection of bytes can be

00:11:38.716 --> 00:11:39.726 A:middle
expressed in an array.

00:11:39.786 --> 00:11:42.436 A:middle
And in small cases, sure.

00:11:42.536 --> 00:11:43.626 A:middle
That works just fine.

00:11:44.106 --> 00:11:46.226 A:middle
However, there's a hidden cost,

00:11:46.226 --> 00:11:47.666 A:middle
here, from a cognitive sense

00:11:48.016 --> 00:11:49.596 A:middle
that when you try to write it to

00:11:49.596 --> 00:11:52.296 A:middle
a file, that' pretty tricky.

00:11:52.376 --> 00:11:53.566 A:middle
There's a lot of Edge cases,

00:11:53.566 --> 00:11:53.826 A:middle
there.

00:11:54.196 --> 00:11:55.796 A:middle
We take care of that for you.

00:11:56.046 --> 00:11:57.746 A:middle
Being able to interoperate with

00:11:57.746 --> 00:11:59.056 A:middle
things like writing to files,

00:11:59.056 --> 00:12:01.786 A:middle
converting to basic C4, Data is

00:12:01.786 --> 00:12:02.676 A:middle
a clear winner.

00:12:04.126 --> 00:12:06.686 A:middle
Now, sometimes we get nostalgic

00:12:06.756 --> 00:12:09.676 A:middle
and we fall back to old trusty

00:12:09.676 --> 00:12:10.226 A:middle
malloc.

00:12:10.866 --> 00:12:13.206 A:middle
And unfortunately, this can

00:12:13.206 --> 00:12:14.816 A:middle
sometimes skip out on other

00:12:14.816 --> 00:12:15.966 A:middle
optimizations.

00:12:16.236 --> 00:12:17.976 A:middle
Like for example, knowing proper

00:12:17.976 --> 00:12:20.036 A:middle
allocation sizes that work best

00:12:20.036 --> 00:12:21.106 A:middle
with rounding to the right

00:12:21.366 --> 00:12:23.666 A:middle
regions that malloc returns for

00:12:23.666 --> 00:12:24.306 A:middle
buffers.

00:12:25.166 --> 00:12:27.156 A:middle
Data deals with all of this, for

00:12:27.156 --> 00:12:27.336 A:middle
you.

00:12:27.336 --> 00:12:28.866 A:middle
So, you don't have to worry

00:12:28.866 --> 00:12:29.986 A:middle
about reallocation.

00:12:30.026 --> 00:12:31.466 A:middle
You don't have to worry about

00:12:31.466 --> 00:12:33.526 A:middle
understanding the Edge cases of

00:12:33.526 --> 00:12:35.816 A:middle
what sizes might be better for

00:12:35.816 --> 00:12:36.936 A:middle
malloc, than others.

00:12:36.936 --> 00:12:41.326 A:middle
Now, these two next lines are

00:12:41.576 --> 00:12:42.446 A:middle
really similar.

00:12:42.796 --> 00:12:44.496 A:middle
And they're worth noting,

00:12:44.786 --> 00:12:46.726 A:middle
because in certain cases, you

00:12:46.726 --> 00:12:48.056 A:middle
want to be able to work with a

00:12:48.056 --> 00:12:49.306 A:middle
large region of data.

00:12:49.786 --> 00:12:51.626 A:middle
And in other cases, you want to

00:12:51.626 --> 00:12:53.046 A:middle
be able to just hold around a

00:12:53.046 --> 00:12:54.386 A:middle
small little bit of it.

00:12:55.116 --> 00:12:56.886 A:middle
So, Data has two APIs.

00:12:57.016 --> 00:12:58.336 A:middle
One of which is subdata in

00:12:58.336 --> 00:12:58.876 A:middle
range.

00:12:59.166 --> 00:13:00.906 A:middle
And this will create a copy, so

00:13:00.906 --> 00:13:02.356 A:middle
that if you have a large file

00:13:02.356 --> 00:13:03.596 A:middle
that you're working with, but

00:13:03.596 --> 00:13:05.286 A:middle
only want to keep around a small

00:13:05.286 --> 00:13:05.766 A:middle
bit.

00:13:06.126 --> 00:13:08.066 A:middle
Subdata with range will make an

00:13:08.066 --> 00:13:09.546 A:middle
enforced copy, like that.

00:13:10.436 --> 00:13:12.606 A:middle
But we changed Data so that it's

00:13:12.606 --> 00:13:16.586 A:middle
its own subtype, or sub-slice of

00:13:16.586 --> 00:13:16.986 A:middle
a type.

00:13:17.336 --> 00:13:18.526 A:middle
So, that whenever you use the

00:13:18.526 --> 00:13:20.636 A:middle
range syntax, even for example,

00:13:20.636 --> 00:13:21.986 A:middle
this version of ranges.

00:13:22.556 --> 00:13:24.986 A:middle
You can use that as a window to

00:13:24.986 --> 00:13:26.536 A:middle
be able to peer into the data.

00:13:26.956 --> 00:13:28.466 A:middle
So, if you have a large file

00:13:28.466 --> 00:13:29.566 A:middle
that you're dealing with, that

00:13:29.566 --> 00:13:30.726 A:middle
you just need to be able to

00:13:30.726 --> 00:13:32.706 A:middle
parse it and the data itself

00:13:32.706 --> 00:13:34.106 A:middle
will only be transitory.

00:13:34.606 --> 00:13:36.476 A:middle
Then, using slices is an

00:13:36.476 --> 00:13:38.386 A:middle
incredibly efficient manner to

00:13:38.386 --> 00:13:39.986 A:middle
be able to access it, because it

00:13:39.986 --> 00:13:43.386 A:middle
causes no copy.

00:13:43.546 --> 00:13:45.346 A:middle
Now, we've talked a number of

00:13:45.346 --> 00:13:46.566 A:middle
times about bridges.

00:13:46.796 --> 00:13:48.496 A:middle
And there are two types of

00:13:48.496 --> 00:13:50.526 A:middle
bridges that are relevant, here.

00:13:51.456 --> 00:13:53.346 A:middle
And on the left we have

00:13:53.686 --> 00:13:54.976 A:middle
toll-free bridging.

00:13:55.666 --> 00:13:58.096 A:middle
And in these cases, they are

00:13:58.096 --> 00:13:59.686 A:middle
bridging from a Foundation type

00:13:59.896 --> 00:14:01.216 A:middle
to a Core Foundation type.

00:14:01.836 --> 00:14:03.376 A:middle
Or from a Foundation type to a

00:14:03.376 --> 00:14:04.356 A:middle
Core Foundation type.

00:14:05.226 --> 00:14:08.476 A:middle
And these are zero cost at the

00:14:08.846 --> 00:14:09.186 A:middle
cast.

00:14:09.386 --> 00:14:10.776 A:middle
So, whatever you actually have

00:14:10.776 --> 00:14:12.126 A:middle
in this particular case, the

00:14:12.406 --> 00:14:14.816 A:middle
NSArray being bridged to a

00:14:14.816 --> 00:14:16.776 A:middle
CFArray, it's just a

00:14:16.776 --> 00:14:18.526 A:middle
reinterpretation of a pointer.

00:14:19.356 --> 00:14:22.906 A:middle
But there is a slight cost to be

00:14:22.906 --> 00:14:25.266 A:middle
paid, whenever you pass that

00:14:25.326 --> 00:14:27.796 A:middle
object to CFArrayGetCount,

00:14:28.496 --> 00:14:29.956 A:middle
there's something that you have,

00:14:29.956 --> 00:14:30.186 A:middle
there.

00:14:30.536 --> 00:14:31.656 A:middle
We'll go over that, here in just

00:14:31.656 --> 00:14:32.186 A:middle
a little bit.

00:14:33.346 --> 00:14:35.156 A:middle
So, contrasting that to Swift

00:14:35.156 --> 00:14:38.146 A:middle
bridging, those are cases where

00:14:38.426 --> 00:14:39.756 A:middle
you're bridging from a reference

00:14:39.756 --> 00:14:41.386 A:middle
type to a structural type.

00:14:42.376 --> 00:14:45.206 A:middle
And contrarily so, bridging from

00:14:45.206 --> 00:14:47.146 A:middle
a structural type to a reference

00:14:47.146 --> 00:14:47.456 A:middle
type.

00:14:48.956 --> 00:14:49.916 A:middle
But the costs in these

00:14:49.946 --> 00:14:51.976 A:middle
particular cases are paid in

00:14:51.976 --> 00:14:52.726 A:middle
advance.

00:14:52.956 --> 00:14:54.386 A:middle
So, whenever you import from

00:14:54.386 --> 00:14:56.796 A:middle
Objective-C or if, in this case,

00:14:56.796 --> 00:14:58.876 A:middle
you use as question mark, to be

00:14:58.876 --> 00:15:00.486 A:middle
able to convert between the two,

00:15:00.766 --> 00:15:02.916 A:middle
you are paying that cost, there.

00:15:04.236 --> 00:15:06.786 A:middle
But the differential is that

00:15:06.786 --> 00:15:08.676 A:middle
these are then normal costs at

00:15:08.896 --> 00:15:09.846 A:middle
the usage.

00:15:10.956 --> 00:15:12.066 A:middle
So, let's dive in a little bit

00:15:12.066 --> 00:15:12.456 A:middle
more.

00:15:12.706 --> 00:15:14.076 A:middle
I know this looks scary.

00:15:14.636 --> 00:15:16.066 A:middle
Don't have a cow, actually, as a

00:15:16.066 --> 00:15:16.936 A:middle
matter of fact, this doesn't

00:15:17.016 --> 00:15:17.546 A:middle
actually.

00:15:17.586 --> 00:15:19.246 A:middle
CFArray doesn't implement copy

00:15:19.246 --> 00:15:19.676 A:middle
on write.

00:15:21.046 --> 00:15:23.206 A:middle
But whenever you pass an NSArray

00:15:23.456 --> 00:15:25.056 A:middle
or subclass into

00:15:25.056 --> 00:15:27.426 A:middle
CFArrayGetCount, it will

00:15:27.576 --> 00:15:29.276 A:middle
magically call out to this

00:15:29.276 --> 00:15:30.726 A:middle
Objective-C method count.

00:15:31.536 --> 00:15:32.656 A:middle
So, let's pick it apart a little

00:15:32.656 --> 00:15:34.426 A:middle
bit further and understand how

00:15:34.426 --> 00:15:35.636 A:middle
this is different than the Swift

00:15:35.736 --> 00:15:36.146 A:middle
bridge.

00:15:36.606 --> 00:15:39.856 A:middle
Here it is, a little bit more

00:15:39.856 --> 00:15:40.596 A:middle
simplified.

00:15:41.126 --> 00:15:43.296 A:middle
First, we tested the arrays and

00:15:43.296 --> 00:15:44.546 A:middle
Objective-C subclass.

00:15:44.926 --> 00:15:46.296 A:middle
And then, we see that invocation

00:15:46.296 --> 00:15:47.116 A:middle
to count, there.

00:15:47.646 --> 00:15:49.726 A:middle
If it wasn't, we know that the

00:15:49.726 --> 00:15:51.336 A:middle
structural layout of the object

00:15:51.616 --> 00:15:53.326 A:middle
can let us indirect to that

00:15:53.626 --> 00:15:55.526 A:middle
variable count.

00:15:56.236 --> 00:15:58.036 A:middle
So, expanding it a bit further.

00:15:58.916 --> 00:16:00.536 A:middle
It checks the internal layout of

00:16:00.536 --> 00:16:02.126 A:middle
the object against the expected

00:16:02.126 --> 00:16:02.866 A:middle
class table.

00:16:03.236 --> 00:16:05.746 A:middle
So, in truth it basically boils

00:16:05.746 --> 00:16:07.506 A:middle
down to costing two indirections

00:16:07.506 --> 00:16:08.946 A:middle
and a function call, to

00:16:08.946 --> 00:16:12.526 A:middle
determine if the Objective-C

00:16:12.526 --> 00:16:14.126 A:middle
method needs to actually be

00:16:14.126 --> 00:16:14.796 A:middle
invoked or not.

00:16:14.886 --> 00:16:17.526 A:middle
So, let's wrap it up for this

00:16:17.526 --> 00:16:17.796 A:middle
one.

00:16:18.116 --> 00:16:20.536 A:middle
Casting to an array or subclass

00:16:20.616 --> 00:16:23.336 A:middle
to a CFArray is just a

00:16:23.336 --> 00:16:25.146 A:middle
reinterpretation of the pointer.

00:16:25.816 --> 00:16:27.686 A:middle
It's the usage points that

00:16:27.836 --> 00:16:29.046 A:middle
actually have the cost.

00:16:29.816 --> 00:16:30.926 A:middle
So, this is usually an

00:16:30.926 --> 00:16:32.716 A:middle
exceedingly small impact.

00:16:33.006 --> 00:16:34.756 A:middle
But in rare cases, it could

00:16:34.756 --> 00:16:36.956 A:middle
often move the needle a little

00:16:37.296 --> 00:16:37.386 A:middle
bit.

00:16:37.386 --> 00:16:39.356 A:middle
So, on the graph, we're mostly

00:16:39.356 --> 00:16:40.876 A:middle
down there in that third

00:16:40.876 --> 00:16:42.586 A:middle
quadrant, maybe peeking up a

00:16:42.586 --> 00:16:44.696 A:middle
little bit.

00:16:44.916 --> 00:16:47.266 A:middle
Now, on the flipside, we have

00:16:47.266 --> 00:16:48.066 A:middle
Swift bridging.

00:16:48.626 --> 00:16:50.036 A:middle
Now, remember this is whenever

00:16:50.036 --> 00:16:52.496 A:middle
we call as question mark or

00:16:52.496 --> 00:16:54.656 A:middle
expose an API from Objective-C,

00:16:55.066 --> 00:16:56.306 A:middle
whenever we have a bridged

00:16:56.306 --> 00:16:57.166 A:middle
reference type.

00:16:57.926 --> 00:16:59.886 A:middle
The compiler will emit this

00:16:59.886 --> 00:17:01.536 A:middle
bridgeable family of functions,

00:17:01.856 --> 00:17:03.636 A:middle
in which will in turn in this

00:17:03.636 --> 00:17:05.076 A:middle
particular case, invoke the

00:17:05.076 --> 00:17:06.406 A:middle
referencing initializer for

00:17:06.406 --> 00:17:06.706 A:middle
Data.

00:17:08.256 --> 00:17:10.086 A:middle
And when Data is initialized

00:17:10.086 --> 00:17:12.346 A:middle
with a reference it will make a

00:17:12.346 --> 00:17:15.066 A:middle
copy to store into the backing

00:17:15.066 --> 00:17:15.876 A:middle
storage of the data.

00:17:16.306 --> 00:17:17.966 A:middle
Because we need to be able to

00:17:17.966 --> 00:17:19.696 A:middle
preserve, not only the value

00:17:19.696 --> 00:17:21.336 A:middle
type nature of the data.

00:17:21.626 --> 00:17:22.996 A:middle
But also, make sure that we

00:17:22.996 --> 00:17:24.306 A:middle
aren't holding onto a shared

00:17:24.306 --> 00:17:25.926 A:middle
mutable reference, causing of

00:17:25.956 --> 00:17:27.226 A:middle
course, bugs.

00:17:28.096 --> 00:17:30.016 A:middle
So, you can see that if this

00:17:30.016 --> 00:17:32.066 A:middle
were actually a mutable case or

00:17:32.066 --> 00:17:34.216 A:middle
a proxy or some other subclass,

00:17:34.806 --> 00:17:37.186 A:middle
it could be a potentially costly

00:17:37.216 --> 00:17:39.456 A:middle
point under the hood.

00:17:39.676 --> 00:17:41.356 A:middle
Now, bringing it all back

00:17:41.356 --> 00:17:43.926 A:middle
together, let's look at that

00:17:44.116 --> 00:17:45.816 A:middle
graph, again.

00:17:45.876 --> 00:17:47.796 A:middle
And in this time, the bridge is

00:17:47.796 --> 00:17:49.566 A:middle
not too often hit.

00:17:49.726 --> 00:17:52.846 A:middle
And whenever the common case,

00:17:53.206 --> 00:17:54.916 A:middle
the copy is optimized into a

00:17:54.916 --> 00:17:55.516 A:middle
retain.

00:17:55.816 --> 00:17:56.886 A:middle
So, we're going to, again, be

00:17:56.886 --> 00:17:57.956 A:middle
down there in that third

00:17:58.006 --> 00:17:58.526 A:middle
quadrant.

00:17:59.276 --> 00:18:00.666 A:middle
But in the cases of the

00:18:00.666 --> 00:18:03.036 A:middle
exceptions for subclasses, like

00:18:03.036 --> 00:18:04.916 A:middle
for example, mutable data, that

00:18:04.916 --> 00:18:07.096 A:middle
copy could potentially be in any

00:18:07.096 --> 00:18:08.166 A:middle
of those quadrants.

00:18:08.576 --> 00:18:10.386 A:middle
So, if you have subclasses that

00:18:10.386 --> 00:18:11.546 A:middle
you need to be able to deal

00:18:11.546 --> 00:18:13.636 A:middle
with, or you're passing mutable

00:18:13.776 --> 00:18:15.746 A:middle
versions back and forth across

00:18:15.746 --> 00:18:16.226 A:middle
the bridge.

00:18:16.766 --> 00:18:17.986 A:middle
You should probably be

00:18:18.126 --> 00:18:20.136 A:middle
understanding those with better

00:18:20.136 --> 00:18:22.326 A:middle
measurements with useful cases.

00:18:23.336 --> 00:18:25.696 A:middle
But this same pattern occurs for

00:18:25.696 --> 00:18:27.596 A:middle
not just data, but all of the

00:18:27.596 --> 00:18:29.966 A:middle
structural types within Swift.

00:18:29.966 --> 00:18:31.286 A:middle
Things like arrays and

00:18:31.286 --> 00:18:32.656 A:middle
dictionaries and strings.

00:18:33.386 --> 00:18:35.086 A:middle
Now, speaking of strings, I

00:18:35.186 --> 00:18:36.546 A:middle
heard they're kind of popular.

00:18:36.856 --> 00:18:38.406 A:middle
Here to guide you through the

00:18:38.406 --> 00:18:40.496 A:middle
wonderful world of strings,

00:18:40.496 --> 00:18:42.956 A:middle
ranges, and texts is Donna.

00:18:43.516 --> 00:18:47.986 A:middle
[ Applause ]

00:18:48.486 --> 00:18:49.036 A:middle
&gt;&gt; Thanks, Phillipe.

00:18:51.896 --> 00:18:53.126 A:middle
Now, strings are probably one of

00:18:53.126 --> 00:18:54.406 A:middle
the most frequently used data

00:18:54.406 --> 00:18:55.086 A:middle
types, ever.

00:18:55.626 --> 00:18:56.746 A:middle
If you're an app developer, your

00:18:56.746 --> 00:18:58.346 A:middle
app probably creates and mutates

00:18:58.346 --> 00:18:59.636 A:middle
hundreds, if not thousands, of

00:18:59.636 --> 00:19:01.006 A:middle
strings each time they're used.

00:19:01.056 --> 00:19:02.486 A:middle
And if you're a framework

00:19:02.486 --> 00:19:03.786 A:middle
developer, your framework's

00:19:03.786 --> 00:19:04.806 A:middle
probably create and mutate

00:19:04.806 --> 00:19:06.466 A:middle
strings each time someone calls

00:19:06.466 --> 00:19:07.326 A:middle
one of our APIs.

00:19:07.886 --> 00:19:08.896 A:middle
And those strings might then be

00:19:08.896 --> 00:19:10.336 A:middle
mutated farther beyond the

00:19:10.336 --> 00:19:11.276 A:middle
boundaries of your framework.

00:19:11.956 --> 00:19:13.466 A:middle
And strings, they're not used in

00:19:13.466 --> 00:19:13.866 A:middle
a vacuum.

00:19:14.196 --> 00:19:14.886 A:middle
You're interacting with

00:19:14.886 --> 00:19:16.076 A:middle
frameworks to do anything

00:19:16.076 --> 00:19:16.996 A:middle
interesting with strings.

00:19:17.226 --> 00:19:18.186 A:middle
Whether it's slicing them,

00:19:18.496 --> 00:19:20.256 A:middle
dicing them, smashing them

00:19:20.256 --> 00:19:20.686 A:middle
together.

00:19:20.716 --> 00:19:21.746 A:middle
Or even just rendering them on

00:19:21.746 --> 00:19:22.176 A:middle
the screen.

00:19:22.766 --> 00:19:24.686 A:middle
And so, you may be able to

00:19:24.686 --> 00:19:25.796 A:middle
improve your app or framework's

00:19:25.796 --> 00:19:27.356 A:middle
performance by understanding how

00:19:27.356 --> 00:19:29.416 A:middle
strings, ranges, and text

00:19:29.796 --> 00:19:30.766 A:middle
interact with frameworks.

00:19:30.946 --> 00:19:32.156 A:middle
And by making implementation

00:19:32.156 --> 00:19:33.076 A:middle
choices based on this

00:19:33.076 --> 00:19:33.606 A:middle
understanding.

00:19:34.706 --> 00:19:35.686 A:middle
But before we dive into the

00:19:35.686 --> 00:19:36.566 A:middle
nitty gritty details, I'm going

00:19:36.966 --> 00:19:38.586 A:middle
to kind of go back to rehash

00:19:38.586 --> 00:19:39.736 A:middle
some of what Phillipe talked

00:19:39.736 --> 00:19:41.336 A:middle
about and talk a little bit

00:19:41.336 --> 00:19:42.946 A:middle
about evaluating the impact of

00:19:42.976 --> 00:19:43.916 A:middle
performance improvements.

00:19:44.566 --> 00:19:47.366 A:middle
Now, it's really important not

00:19:47.366 --> 00:19:48.786 A:middle
to lose sight of the big picture

00:19:48.876 --> 00:19:49.746 A:middle
when you're looking to improve

00:19:49.746 --> 00:19:50.196 A:middle
performance.

00:19:51.326 --> 00:19:52.376 A:middle
It's really easy to get caught

00:19:52.376 --> 00:19:54.066 A:middle
up in the details and become

00:19:54.066 --> 00:19:55.456 A:middle
really focused on optimizing for

00:19:55.456 --> 00:19:57.066 A:middle
those very particular scenarios.

00:19:57.366 --> 00:19:59.356 A:middle
But it those scenarios don't

00:19:59.356 --> 00:20:00.696 A:middle
reflect the way users actually

00:20:00.696 --> 00:20:02.626 A:middle
use your app framework, then

00:20:02.626 --> 00:20:03.786 A:middle
it's not a very efficient use of

00:20:03.786 --> 00:20:04.966 A:middle
your time to optimize for them.

00:20:06.026 --> 00:20:08.126 A:middle
And so, once you've decided that

00:20:08.126 --> 00:20:09.226 A:middle
a scenario you're looking at

00:20:09.226 --> 00:20:10.776 A:middle
reflects actual usage, you might

00:20:10.776 --> 00:20:11.906 A:middle
then look at the performance of

00:20:11.906 --> 00:20:13.076 A:middle
a particular piece of code.

00:20:13.076 --> 00:20:14.476 A:middle
And when you do that, it's

00:20:14.476 --> 00:20:15.516 A:middle
important to keep in mind, these

00:20:15.516 --> 00:20:16.566 A:middle
concepts that we've discussed.

00:20:16.996 --> 00:20:18.566 A:middle
How big is the data I'm working

00:20:18.566 --> 00:20:18.836 A:middle
with?

00:20:18.836 --> 00:20:20.056 A:middle
And how often is that code

00:20:20.056 --> 00:20:20.316 A:middle
running?

00:20:20.886 --> 00:20:22.686 A:middle
And so, we're going to bring

00:20:22.686 --> 00:20:23.326 A:middle
back the graph.

00:20:23.816 --> 00:20:25.246 A:middle
But we're going to change the

00:20:25.246 --> 00:20:26.836 A:middle
axis labels a little bit for the

00:20:26.836 --> 00:20:28.036 A:middle
context of strings and text.

00:20:28.576 --> 00:20:29.836 A:middle
So, the general concept is the

00:20:29.836 --> 00:20:30.186 A:middle
same.

00:20:30.356 --> 00:20:31.446 A:middle
But for strings, we'll think of

00:20:31.446 --> 00:20:32.836 A:middle
it in terms of how long or how

00:20:32.836 --> 00:20:34.376 A:middle
short the string is and how

00:20:34.376 --> 00:20:35.656 A:middle
frequently that code is running.

00:20:36.226 --> 00:20:38.676 A:middle
So, let's keep these concepts of

00:20:38.716 --> 00:20:39.916 A:middle
scale and frequency in mind as

00:20:39.916 --> 00:20:40.846 A:middle
we cover these topics.

00:20:42.526 --> 00:20:43.526 A:middle
First, we're going to start with

00:20:43.526 --> 00:20:44.086 A:middle
string bridging.

00:20:44.086 --> 00:20:46.226 A:middle
And then next, we'll talk about

00:20:46.226 --> 00:20:47.676 A:middle
ranges and the nuances of string

00:20:47.676 --> 00:20:48.076 A:middle
index.

00:20:48.956 --> 00:20:50.056 A:middle
And finally, we'll share a few

00:20:50.056 --> 00:20:51.366 A:middle
tips for working efficiently

00:20:51.366 --> 00:20:52.436 A:middle
with text layout and rendering

00:20:52.436 --> 00:20:53.576 A:middle
in AVKit and UIKit.

00:20:54.616 --> 00:20:55.916 A:middle
So, let's get started with sting

00:20:55.916 --> 00:20:56.216 A:middle
bridging.

00:20:56.776 --> 00:20:59.316 A:middle
The first example we'll look at

00:20:59.316 --> 00:21:00.236 A:middle
works with UILabel.

00:21:00.236 --> 00:21:03.036 A:middle
So, let's say I have a label

00:21:03.036 --> 00:21:04.966 A:middle
like this, and I want to access

00:21:05.856 --> 00:21:07.116 A:middle
its text.

00:21:07.266 --> 00:21:08.406 A:middle
In Swift, I might start with

00:21:08.406 --> 00:21:08.986 A:middle
something like this.

00:21:10.116 --> 00:21:11.996 A:middle
But we asked the UIKit framework

00:21:12.176 --> 00:21:13.406 A:middle
to give us the label's text.

00:21:14.246 --> 00:21:15.776 A:middle
So, here's what the interface to

00:21:15.776 --> 00:21:16.886 A:middle
that looks like.

00:21:17.896 --> 00:21:19.416 A:middle
But remember, that this is just

00:21:19.416 --> 00:21:20.406 A:middle
a generated interface.

00:21:20.796 --> 00:21:22.346 A:middle
UILabel is implemented in

00:21:22.346 --> 00:21:23.016 A:middle
Objective-C.

00:21:24.676 --> 00:21:26.056 A:middle
And so, even though our variable

00:21:26.056 --> 00:21:27.846 A:middle
text is a Swift string, the

00:21:27.846 --> 00:21:29.306 A:middle
backing store is actually an

00:21:29.426 --> 00:21:30.886 A:middle
NSString and it's bridged from

00:21:30.886 --> 00:21:31.436 A:middle
Objective-C.

00:21:32.036 --> 00:21:34.656 A:middle
And so, now let's take a look at

00:21:34.656 --> 00:21:35.616 A:middle
what happens when we ask for

00:21:35.616 --> 00:21:36.886 A:middle
that label's text from Swift.

00:21:38.266 --> 00:21:39.406 A:middle
The NSString form the framework

00:21:39.406 --> 00:21:41.186 A:middle
is a reference type, while

00:21:41.246 --> 00:21:42.436 A:middle
Swift's string is a value type.

00:21:43.106 --> 00:21:44.296 A:middle
And so, when we ask the

00:21:44.346 --> 00:21:45.666 A:middle
framework for that NSString,

00:21:46.066 --> 00:21:47.156 A:middle
it's wrapped in the value type

00:21:47.296 --> 00:21:48.116 A:middle
when it crosses the Swift

00:21:48.146 --> 00:21:48.446 A:middle
bridge.

00:21:49.946 --> 00:21:50.766 A:middle
But we don't know what might

00:21:50.766 --> 00:21:52.366 A:middle
happen to that original NSString

00:21:52.546 --> 00:21:53.156 A:middle
after bridging.

00:21:53.656 --> 00:21:55.126 A:middle
And so, to preserve Swift value

00:21:55.186 --> 00:21:56.916 A:middle
semantics, the framework has to

00:21:56.916 --> 00:21:57.806 A:middle
make a copy of it.

00:21:58.906 --> 00:22:00.196 A:middle
Now luckily, in this case, the

00:22:00.196 --> 00:22:01.996 A:middle
original NSString is immutable.

00:22:02.346 --> 00:22:03.606 A:middle
And so, when the framework makes

00:22:03.606 --> 00:22:05.196 A:middle
that copy, it's optimized to

00:22:05.196 --> 00:22:06.576 A:middle
just retain, which is pretty

00:22:06.576 --> 00:22:06.816 A:middle
cheap.

00:22:06.816 --> 00:22:07.736 A:middle
Since, it's just incrementing

00:22:07.736 --> 00:22:08.826 A:middle
the ref count.

00:22:11.696 --> 00:22:13.116 A:middle
But even if we did make a full

00:22:13.116 --> 00:22:14.486 A:middle
copy of this string, let's go

00:22:14.486 --> 00:22:15.746 A:middle
back to our graph and evaluate

00:22:15.746 --> 00:22:16.056 A:middle
the impact.

00:22:16.056 --> 00:22:18.866 A:middle
Now in this case, the original

00:22:18.866 --> 00:22:20.336 A:middle
string consisted of seven ASCII

00:22:20.336 --> 00:22:20.796 A:middle
characters.

00:22:21.066 --> 00:22:22.846 A:middle
So, even if we made a full copy

00:22:23.846 --> 00:22:24.576 A:middle
the impact would be pretty

00:22:24.576 --> 00:22:24.786 A:middle
small.

00:22:25.996 --> 00:22:27.346 A:middle
Now, most of the time UILabels

00:22:27.346 --> 00:22:28.506 A:middle
are going to consist of short

00:22:28.506 --> 00:22:29.766 A:middle
strings that are used for UI

00:22:29.766 --> 00:22:30.566 A:middle
display purposes.

00:22:31.266 --> 00:22:32.736 A:middle
And so, you're probably not

00:22:32.736 --> 00:22:33.616 A:middle
going to be fetching their text

00:22:33.616 --> 00:22:34.336 A:middle
very frequently.

00:22:34.706 --> 00:22:36.156 A:middle
And in most cases, you'll end up

00:22:36.156 --> 00:22:37.236 A:middle
down her in quadrant three.

00:22:37.776 --> 00:22:39.426 A:middle
So, the bridging copies aren't

00:22:39.426 --> 00:22:42.346 A:middle
going to be a big deal.

00:22:43.116 --> 00:22:43.976 A:middle
But now, let's take a look at

00:22:43.976 --> 00:22:45.796 A:middle
what happens in a larger scale

00:22:45.796 --> 00:22:47.276 A:middle
example, like in NSText storage.

00:22:47.686 --> 00:22:49.456 A:middle
NSText storage is the

00:22:49.556 --> 00:22:51.266 A:middle
fundamental storage mechanism

00:22:51.266 --> 00:22:51.956 A:middle
behind TextKit.

00:22:52.496 --> 00:22:53.756 A:middle
It's used to power text views

00:22:53.756 --> 00:22:54.766 A:middle
like the one you see here, in

00:22:54.766 --> 00:22:56.016 A:middle
both Cocoa and Cocoa Touch.

00:22:57.136 --> 00:22:58.526 A:middle
And so, if you're working with

00:22:58.526 --> 00:22:59.746 A:middle
text views, you're going to want

00:22:59.746 --> 00:23:00.946 A:middle
to be able to access the text

00:23:00.946 --> 00:23:01.796 A:middle
inside that text storage.

00:23:01.796 --> 00:23:03.446 A:middle
And so, here's what that looks

00:23:03.446 --> 00:23:03.966 A:middle
like in Swift.

00:23:07.616 --> 00:23:09.016 A:middle
Here's the generated interface.

00:23:10.256 --> 00:23:13.216 A:middle
And here's the Objective-C

00:23:13.216 --> 00:23:13.596 A:middle
interface.

00:23:14.966 --> 00:23:16.676 A:middle
But notice here, the NSText

00:23:16.676 --> 00:23:17.946 A:middle
storage is a subclass of

00:23:18.046 --> 00:23:19.576 A:middle
NSMutableAttributedString.

00:23:20.246 --> 00:23:22.856 A:middle
Now, since NSText storage is

00:23:22.856 --> 00:23:23.996 A:middle
intended for working with text

00:23:23.996 --> 00:23:25.496 A:middle
editing, it's reasonable to

00:23:25.496 --> 00:23:27.346 A:middle
expect the contents of that text

00:23:27.346 --> 00:23:28.276 A:middle
storage to be mutated,

00:23:28.276 --> 00:23:28.666 A:middle
frequently.

00:23:29.976 --> 00:23:31.316 A:middle
And the contents of the text

00:23:31.316 --> 00:23:32.376 A:middle
storage could also be a very

00:23:32.376 --> 00:23:32.986 A:middle
long string.

00:23:32.986 --> 00:23:34.346 A:middle
It could be megabytes or even

00:23:34.346 --> 00:23:35.256 A:middle
gigabytes in size.

00:23:36.226 --> 00:23:37.486 A:middle
And so, for efficiency, the

00:23:37.486 --> 00:23:38.986 A:middle
framework only keeps the mutable

00:23:38.986 --> 00:23:39.496 A:middle
string around.

00:23:39.906 --> 00:23:41.006 A:middle
So, when you ask for that string

00:23:41.006 --> 00:23:42.486 A:middle
property on the text storage,

00:23:43.196 --> 00:23:44.286 A:middle
what you'll get is going to be

00:23:44.286 --> 00:23:45.716 A:middle
backed by an NSString that

00:23:45.716 --> 00:23:47.106 A:middle
refers to the mutable string.

00:23:47.586 --> 00:23:50.886 A:middle
And so now, once again, we'll

00:23:50.886 --> 00:23:51.876 A:middle
take a look at what happens when

00:23:51.876 --> 00:23:53.056 A:middle
we ask for that string property

00:23:53.056 --> 00:23:53.516 A:middle
from Swift.

00:23:54.036 --> 00:23:57.346 A:middle
Just as before, it'll be wrapped

00:23:57.346 --> 00:23:59.086 A:middle
in the value type when it

00:23:59.146 --> 00:24:00.226 A:middle
crosses the bridge, because it's

00:24:00.226 --> 00:24:00.786 A:middle
an NSString.

00:24:00.936 --> 00:24:02.266 A:middle
And the framework is going to

00:24:02.266 --> 00:24:02.836 A:middle
make a copy.

00:24:04.016 --> 00:24:05.446 A:middle
But unlike in the UILabel case,

00:24:05.656 --> 00:24:07.416 A:middle
here the underlying NSString is

00:24:07.416 --> 00:24:08.416 A:middle
actually mutable.

00:24:09.326 --> 00:24:10.136 A:middle
So, this copy could be

00:24:10.136 --> 00:24:10.646 A:middle
expensive.

00:24:11.826 --> 00:24:13.066 A:middle
And as we said previously, text

00:24:13.066 --> 00:24:14.526 A:middle
storage is much more likely to

00:24:14.526 --> 00:24:16.186 A:middle
contain long length strings.

00:24:16.826 --> 00:24:17.856 A:middle
It could be megabytes or even

00:24:17.856 --> 00:24:18.906 A:middle
gigabytes in size, so

00:24:18.906 --> 00:24:20.266 A:middle
potentially this copy could be

00:24:20.266 --> 00:24:21.076 A:middle
very expensive.

00:24:21.586 --> 00:24:24.416 A:middle
But now, let's take a look at

00:24:24.416 --> 00:24:25.526 A:middle
what happens when we ask for the

00:24:25.526 --> 00:24:26.596 A:middle
mutable string property.

00:24:28.256 --> 00:24:30.046 A:middle
NSMutableString is a reference

00:24:30.046 --> 00:24:31.006 A:middle
type that is not bridged.

00:24:32.136 --> 00:24:33.146 A:middle
And because it's not bridged,

00:24:33.376 --> 00:24:33.896 A:middle
there's no copy.

00:24:34.576 --> 00:24:35.486 A:middle
So, we avoid the cost of the

00:24:35.486 --> 00:24:35.946 A:middle
copy, here.

00:24:37.496 --> 00:24:38.986 A:middle
This situation results from a

00:24:38.986 --> 00:24:40.526 A:middle
mismatch between Swift's value

00:24:40.526 --> 00:24:42.066 A:middle
semantics and the design of

00:24:42.066 --> 00:24:43.686 A:middle
NSText storage, which needs to

00:24:43.686 --> 00:24:44.816 A:middle
use reference semantics for

00:24:44.816 --> 00:24:46.006 A:middle
performant management of large

00:24:46.006 --> 00:24:46.686 A:middle
amounts of text.

00:24:47.876 --> 00:24:48.966 A:middle
So, we're working on solving

00:24:48.966 --> 00:24:49.946 A:middle
this problem, here at Apple.

00:24:49.946 --> 00:24:51.156 A:middle
But we don't quite have the

00:24:51.156 --> 00:24:51.776 A:middle
solution, yet.

00:24:51.926 --> 00:24:52.826 A:middle
So, you should be aware that

00:24:52.826 --> 00:24:53.576 A:middle
this is something that can

00:24:53.576 --> 00:24:54.006 A:middle
happen.

00:24:54.406 --> 00:24:55.506 A:middle
And if you're working with very

00:24:55.506 --> 00:24:56.626 A:middle
large amounts of text and the

00:24:56.626 --> 00:24:58.316 A:middle
text storage, use MutableString

00:24:58.316 --> 00:24:59.906 A:middle
to access it, even if you don't

00:24:59.906 --> 00:25:01.286 A:middle
plan on mutating it.

00:25:02.796 --> 00:25:04.086 A:middle
But before you go bananas

00:25:04.146 --> 00:25:05.026 A:middle
changing all of your string

00:25:05.026 --> 00:25:06.326 A:middle
accesses to MutableString, let's

00:25:06.326 --> 00:25:07.296 A:middle
consider that graph, again.

00:25:08.196 --> 00:25:09.006 A:middle
Now, due to the nature of the

00:25:09.006 --> 00:25:09.876 A:middle
text storage API, you're

00:25:10.036 --> 00:25:11.276 A:middle
probably going to be up here on

00:25:11.276 --> 00:25:12.906 A:middle
the top half, in terms of

00:25:12.906 --> 00:25:13.386 A:middle
frequency.

00:25:13.726 --> 00:25:14.586 A:middle
So then, the real question

00:25:14.586 --> 00:25:16.686 A:middle
becomes, how much text do you

00:25:16.686 --> 00:25:18.426 A:middle
expect that storage to contain?

00:25:19.026 --> 00:25:20.626 A:middle
A kilobyte?

00:25:20.626 --> 00:25:22.686 A:middle
Might be in here, it's not too

00:25:22.686 --> 00:25:22.986 A:middle
bad.

00:25:22.986 --> 00:25:24.236 A:middle
If you use the string property,

00:25:24.236 --> 00:25:25.776 A:middle
that's probably fine.

00:25:26.696 --> 00:25:27.576 A:middle
One megabyte?

00:25:27.626 --> 00:25:29.386 A:middle
You're starting to move into

00:25:29.386 --> 00:25:30.506 A:middle
first quadrant territory, here.

00:25:30.506 --> 00:25:31.726 A:middle
And you may want to consider

00:25:31.726 --> 00:25:32.656 A:middle
using MutableString.

00:25:34.016 --> 00:25:34.706 A:middle
One gigabyte?

00:25:34.706 --> 00:25:36.366 A:middle
I really hope you're using

00:25:36.366 --> 00:25:36.936 A:middle
MutableString.

00:25:39.126 --> 00:25:40.356 A:middle
And as I said, we're working on

00:25:40.356 --> 00:25:41.406 A:middle
fixing this on our end, here.

00:25:41.726 --> 00:25:42.606 A:middle
So, keep an eye out for it in

00:25:42.606 --> 00:25:43.276 A:middle
future releases.

00:25:43.916 --> 00:25:46.066 A:middle
And so, now that we have a

00:25:46.066 --> 00:25:47.216 A:middle
better understanding of string

00:25:47.216 --> 00:25:48.766 A:middle
bridging, let's move on to

00:25:48.766 --> 00:25:48.976 A:middle
ranges.

00:25:52.536 --> 00:25:53.336 A:middle
Now, I don't know about the rest

00:25:53.336 --> 00:25:54.286 A:middle
of you, but this is certainly

00:25:54.286 --> 00:25:55.496 A:middle
how I feel when I have to work

00:25:55.496 --> 00:25:56.786 A:middle
with ranges and string index in

00:25:56.786 --> 00:25:57.146 A:middle
Swift.

00:25:57.616 --> 00:25:59.646 A:middle
And to see why, let's consider a

00:25:59.646 --> 00:26:01.806 A:middle
string containing the face palm

00:26:01.806 --> 00:26:03.206 A:middle
emoji, which coincidentally,

00:26:03.206 --> 00:26:04.236 A:middle
looks a little bit like me.

00:26:05.476 --> 00:26:07.436 A:middle
So, here's our string.

00:26:07.796 --> 00:26:09.046 A:middle
It's a length one in terms of

00:26:09.046 --> 00:26:09.796 A:middle
perceived characters.

00:26:10.776 --> 00:26:12.066 A:middle
But this one character consists

00:26:12.066 --> 00:26:13.216 A:middle
of three individual components.

00:26:13.676 --> 00:26:15.036 A:middle
We have this jaundice face palm,

00:26:15.946 --> 00:26:17.416 A:middle
a skin tone modifier, presumable

00:26:17.416 --> 00:26:18.986 A:middle
to get rid of the jaundice, and

00:26:19.146 --> 00:26:20.186 A:middle
a gender modifier.

00:26:21.246 --> 00:26:22.336 A:middle
But these visual components

00:26:22.336 --> 00:26:23.306 A:middle
don't tell the whole story,

00:26:23.406 --> 00:26:23.556 A:middle
either.

00:26:24.006 --> 00:26:25.016 A:middle
There are also, two control

00:26:25.016 --> 00:26:25.946 A:middle
characters in this string.

00:26:26.036 --> 00:26:27.556 A:middle
A zero width joiner and a

00:26:27.556 --> 00:26:28.466 A:middle
variation selector.

00:26:28.466 --> 00:26:30.206 A:middle
And to see this, we'll look at

00:26:30.206 --> 00:26:31.596 A:middle
the Unicode Scalar values that

00:26:31.596 --> 00:26:32.276 A:middle
make up the string.

00:26:32.476 --> 00:26:33.396 A:middle
Now, if you're not familiar with

00:26:33.396 --> 00:26:35.216 A:middle
the term, a Unicode Scalar value

00:26:35.216 --> 00:26:37.786 A:middle
is a 21-bit number that uniquely

00:26:37.786 --> 00:26:39.166 A:middle
represents a Unicode character.

00:26:39.916 --> 00:26:41.096 A:middle
And so, here are the Unicode

00:26:41.096 --> 00:26:42.136 A:middle
Scalar values that make up the

00:26:42.136 --> 00:26:43.786 A:middle
string, and the names that are

00:26:43.786 --> 00:26:45.306 A:middle
associated with those values.

00:26:45.406 --> 00:26:47.026 A:middle
So, if you look at the string

00:26:47.026 --> 00:26:48.186 A:middle
from a Unicode Scalar point of

00:26:48.186 --> 00:26:49.536 A:middle
view, it's actually made up of

00:26:49.536 --> 00:26:50.636 A:middle
five different values, and it

00:26:50.636 --> 00:26:51.526 A:middle
has length five.

00:26:52.106 --> 00:26:54.446 A:middle
Now, this is all fine and dandy

00:26:54.446 --> 00:26:55.486 A:middle
if you're working purely with

00:26:55.486 --> 00:26:56.086 A:middle
Swift's string API.

00:26:56.886 --> 00:26:57.706 A:middle
But if you're using

00:26:57.706 --> 00:26:59.786 A:middle
NSAttributedString, or any API

00:26:59.786 --> 00:27:02.236 A:middle
really, that uses NSRange, these

00:27:02.236 --> 00:27:03.896 A:middle
think in terms of UTF-16.

00:27:04.546 --> 00:27:05.426 A:middle
And so, if you look at the

00:27:05.426 --> 00:27:06.906 A:middle
UTF-16 view of this string, it

00:27:06.906 --> 00:27:08.056 A:middle
actually consists of seven

00:27:08.056 --> 00:27:08.966 A:middle
values and it's of length,

00:27:09.216 --> 00:27:09.546 A:middle
seven.

00:27:10.466 --> 00:27:11.226 A:middle
Now this can get really

00:27:11.226 --> 00:27:12.396 A:middle
confusing, and it makes working

00:27:12.396 --> 00:27:13.856 A:middle
with NSRange and range of string

00:27:13.856 --> 00:27:14.816 A:middle
index a little bit painful.

00:27:14.816 --> 00:27:17.806 A:middle
So, let's clear up some of this

00:27:17.806 --> 00:27:18.906 A:middle
confusion and talk about how to

00:27:18.906 --> 00:27:20.386 A:middle
work with NSAttributedString,

00:27:20.386 --> 00:27:21.246 A:middle
which makes heavy use of

00:27:21.366 --> 00:27:21.816 A:middle
NSRange.

00:27:22.266 --> 00:27:24.336 A:middle
So, let's say I have a string

00:27:24.336 --> 00:27:26.146 A:middle
like this.

00:27:26.146 --> 00:27:27.326 A:middle
And I want to create an

00:27:27.326 --> 00:27:28.606 A:middle
attributed string with it, and

00:27:28.606 --> 00:27:29.816 A:middle
change the background color of

00:27:29.816 --> 00:27:30.966 A:middle
one of the characters to green.

00:27:31.566 --> 00:27:35.386 A:middle
Now, this is complicated enough,

00:27:35.386 --> 00:27:36.916 A:middle
that even I forget how to do it,

00:27:36.916 --> 00:27:37.296 A:middle
sometimes.

00:27:37.366 --> 00:27:38.016 A:middle
But don't tell anyone.

00:27:38.456 --> 00:27:40.646 A:middle
So, I might have to look it up

00:27:40.646 --> 00:27:41.176 A:middle
on the internet.

00:27:41.176 --> 00:27:42.486 A:middle
And then, after I do that I

00:27:42.486 --> 00:27:43.486 A:middle
might end up with some code that

00:27:43.486 --> 00:27:44.006 A:middle
looks like this.

00:27:45.246 --> 00:27:46.216 A:middle
it's annoying, because I have to

00:27:46.216 --> 00:27:47.256 A:middle
keep flipping back and forth

00:27:47.256 --> 00:27:49.176 A:middle
between this string API and this

00:27:49.176 --> 00:27:50.826 A:middle
NSString API, right.

00:27:51.056 --> 00:27:52.206 A:middle
I have to take my original

00:27:52.206 --> 00:27:53.226 A:middle
string and then, create an

00:27:53.336 --> 00:27:54.376 A:middle
NSString from it, and then

00:27:54.376 --> 00:27:55.896 A:middle
calculate the NSRange using the

00:27:55.896 --> 00:27:56.336 A:middle
NSString.

00:27:56.746 --> 00:27:58.256 A:middle
But then, I have to go back and

00:27:58.296 --> 00:27:58.686 A:middle
create my

00:27:58.856 --> 00:28:00.276 A:middle
NSMutableAttributedString using

00:28:00.276 --> 00:28:01.246 A:middle
the original string, again.

00:28:01.856 --> 00:28:03.586 A:middle
Yuck. I don't like to do this.

00:28:04.326 --> 00:28:06.706 A:middle
Nobody likes to do this.

00:28:06.916 --> 00:28:07.896 A:middle
The good news is that you won't

00:28:07.896 --> 00:28:08.696 A:middle
have to do this, anymore,

00:28:09.086 --> 00:28:10.186 A:middle
because in Swift 4, we're

00:28:10.186 --> 00:28:11.606 A:middle
introducing new initializers for

00:28:11.776 --> 00:28:12.786 A:middle
NSRange and Range.

00:28:13.576 --> 00:28:14.646 A:middle
And so, when we use these new

00:28:14.646 --> 00:28:15.286 A:middle
initializers.

00:28:15.506 --> 00:28:16.826 A:middle
Thank you.

00:28:17.646 --> 00:28:20.386 A:middle
That same example trims down to

00:28:20.386 --> 00:28:21.836 A:middle
just this and it's a lot easier

00:28:21.836 --> 00:28:23.506 A:middle
to read, write, and remember.

00:28:24.086 --> 00:28:25.796 A:middle
So, the new NSRange initializer

00:28:25.896 --> 00:28:27.266 A:middle
that's being used here, it takes

00:28:27.266 --> 00:28:28.716 A:middle
a range and the Swift string and

00:28:28.716 --> 00:28:29.916 A:middle
it uses it to create the

00:28:29.916 --> 00:28:30.366 A:middle
NSRange.

00:28:30.366 --> 00:28:31.196 A:middle
And you can just pass that

00:28:31.196 --> 00:28:32.136 A:middle
directly into the

00:28:32.136 --> 00:28:33.756 A:middle
attributedString API.

00:28:35.176 --> 00:28:36.456 A:middle
But now, let's take a look at

00:28:36.456 --> 00:28:37.256 A:middle
the conversion in the other

00:28:37.256 --> 00:28:38.906 A:middle
direction from NSRange to Range

00:28:38.906 --> 00:28:39.416 A:middle
and string index.

00:28:39.546 --> 00:28:42.596 A:middle
To look at this simple example,

00:28:42.686 --> 00:28:43.936 A:middle
let's say we have some html like

00:28:43.936 --> 00:28:45.336 A:middle
this, and we want to print out

00:28:45.336 --> 00:28:45.966 A:middle
all the start tags.

00:28:46.946 --> 00:28:48.056 A:middle
And so, in order to do this,

00:28:48.826 --> 00:28:50.196 A:middle
we'll use NSRegularExpression to

00:28:50.196 --> 00:28:51.446 A:middle
find the tags we want, and then

00:28:51.446 --> 00:28:52.296 A:middle
append them to a string.

00:28:52.686 --> 00:28:54.836 A:middle
Sounds reasonable, right?

00:28:55.586 --> 00:28:57.196 A:middle
But the NSRegularExpression API

00:28:57.276 --> 00:28:58.766 A:middle
gives me NS ranges back from my

00:28:58.766 --> 00:28:59.246 A:middle
match groups.

00:28:59.466 --> 00:29:00.616 A:middle
And I need ranges of string

00:29:00.616 --> 00:29:02.066 A:middle
index to be able to append to my

00:29:02.066 --> 00:29:02.606 A:middle
Swift string.

00:29:03.156 --> 00:29:05.056 A:middle
And so, before these new

00:29:05.056 --> 00:29:06.946 A:middle
initializers were available, we

00:29:06.946 --> 00:29:07.846 A:middle
might have use something like

00:29:07.846 --> 00:29:09.366 A:middle
this to convert from NSRange to

00:29:09.366 --> 00:29:10.066 A:middle
range a string index.

00:29:11.156 --> 00:29:12.076 A:middle
And remember that face palm

00:29:12.076 --> 00:29:13.016 A:middle
emoji we talked about a few

00:29:13.016 --> 00:29:14.476 A:middle
minutes ago, and how it was of

00:29:14.476 --> 00:29:15.746 A:middle
length seven, in terms of

00:29:15.746 --> 00:29:16.386 A:middle
UTF-16?

00:29:16.496 --> 00:29:17.626 A:middle
And length five in terms of

00:29:17.626 --> 00:29:18.246 A:middle
Unicode Scalar?

00:29:18.656 --> 00:29:19.526 A:middle
Well, this code is a little bit

00:29:19.526 --> 00:29:21.476 A:middle
complicated, because it's doing

00:29:21.476 --> 00:29:23.846 A:middle
that conversion from UTF-16 to

00:29:23.846 --> 00:29:24.546 A:middle
Unicode Scalar.

00:29:25.086 --> 00:29:27.366 A:middle
But now, with these new array

00:29:27.396 --> 00:29:28.296 A:middle
initializers, you don't have to

00:29:28.296 --> 00:29:29.006 A:middle
do that anymore, either.

00:29:29.816 --> 00:29:30.976 A:middle
We can just take the NSRange we

00:29:30.976 --> 00:29:31.936 A:middle
get back from the match group

00:29:32.366 --> 00:29:34.126 A:middle
and use that to create our range

00:29:34.126 --> 00:29:35.346 A:middle
of string index, and append it

00:29:35.346 --> 00:29:36.116 A:middle
directly to our string.

00:29:36.846 --> 00:29:38.006 A:middle
This is a lot more convenient

00:29:38.146 --> 00:29:39.036 A:middle
and it's a lot easier to use.

00:29:39.926 --> 00:29:40.886 A:middle
So, these new initializers are

00:29:40.886 --> 00:29:42.486 A:middle
really great, and I hope that

00:29:42.486 --> 00:29:43.596 A:middle
you use them for all your Range

00:29:43.656 --> 00:29:44.616 A:middle
and NSRange conversions.

00:29:45.036 --> 00:29:47.036 A:middle
[ Applause ]

00:29:47.056 --> 00:29:47.726 A:middle
Thank you.

00:29:48.016 --> 00:29:49.916 A:middle
[ Applause ]

00:29:49.916 --> 00:29:51.236 A:middle
So, that wraps up ranges.

00:29:51.266 --> 00:29:52.516 A:middle
Let's move on to text layout and

00:29:52.516 --> 00:29:52.966 A:middle
rendering.

00:29:53.526 --> 00:29:55.526 A:middle
Text is hard.

00:29:56.586 --> 00:29:57.706 A:middle
It seems simple on the surface.

00:29:58.226 --> 00:29:59.366 A:middle
Because everyone knows what text

00:29:59.366 --> 00:29:59.566 A:middle
is.

00:30:00.106 --> 00:30:01.086 A:middle
Everyone encounters it on a

00:30:01.086 --> 00:30:01.736 A:middle
daily basis.

00:30:02.246 --> 00:30:04.066 A:middle
It's familiar and it's ordinary.

00:30:04.766 --> 00:30:06.066 A:middle
And as a result, there is a

00:30:06.066 --> 00:30:07.446 A:middle
tendency to implicitly assume

00:30:07.446 --> 00:30:07.996 A:middle
that it's easy.

00:30:09.256 --> 00:30:10.316 A:middle
But it's not easy.

00:30:10.986 --> 00:30:12.446 A:middle
Text poses some real performance

00:30:12.446 --> 00:30:13.446 A:middle
challenges, because of its

00:30:13.446 --> 00:30:14.336 A:middle
ubiquity in scale.

00:30:14.946 --> 00:30:17.386 A:middle
So, think about this.

00:30:17.656 --> 00:30:20.026 A:middle
We ship 40 localizations for

00:30:20.026 --> 00:30:24.386 A:middle
iOS, 35 for macOS, 39 for

00:30:24.386 --> 00:30:27.076 A:middle
watchOS, and 40 again for tvOS.

00:30:28.546 --> 00:30:29.756 A:middle
And for all of these platforms,

00:30:29.886 --> 00:30:31.246 A:middle
we support text input for more

00:30:31.246 --> 00:30:32.666 A:middle
than 300 other languages.

00:30:33.306 --> 00:30:35.786 A:middle
And each of these languages may

00:30:35.786 --> 00:30:36.956 A:middle
have different rules for things

00:30:36.956 --> 00:30:37.846 A:middle
like word breaking and

00:30:37.846 --> 00:30:38.306 A:middle
hyphenation.

00:30:38.306 --> 00:30:40.346 A:middle
And that's going to affect the

00:30:40.346 --> 00:30:41.836 A:middle
line breaking, which is going to

00:30:41.836 --> 00:30:43.436 A:middle
affect the text layout, which is

00:30:43.436 --> 00:30:44.296 A:middle
going to affect the text

00:30:44.296 --> 00:30:44.666 A:middle
rendering.

00:30:44.666 --> 00:30:46.316 A:middle
And our frameworks need to be

00:30:46.316 --> 00:30:47.296 A:middle
able to handle all of these

00:30:47.296 --> 00:30:48.116 A:middle
languages, correctly.

00:30:48.116 --> 00:30:51.476 A:middle
Now, if that wasn't enough, here

00:30:51.476 --> 00:30:52.366 A:middle
are just some of the other

00:30:52.366 --> 00:30:53.766 A:middle
factors that our frameworks take

00:30:53.766 --> 00:30:55.096 A:middle
into account when we perform

00:30:55.096 --> 00:30:55.976 A:middle
text layout and rendering.

00:30:56.586 --> 00:30:57.426 A:middle
So, we look at all of these

00:30:57.466 --> 00:30:58.576 A:middle
things and more to render your

00:30:58.576 --> 00:30:59.776 A:middle
text in a way that's both

00:30:59.776 --> 00:31:00.726 A:middle
correct and performant.

00:31:01.096 --> 00:31:02.436 A:middle
So, I encourage you to use the

00:31:02.486 --> 00:31:04.086 A:middle
standard label controls whenever

00:31:04.086 --> 00:31:04.486 A:middle
possible.

00:31:05.546 --> 00:31:06.876 A:middle
Now, with so many different

00:31:06.876 --> 00:31:08.216 A:middle
variables to consider, our

00:31:08.216 --> 00:31:09.146 A:middle
frameworks use multiple

00:31:09.146 --> 00:31:10.426 A:middle
optimization strategies, under

00:31:10.426 --> 00:31:10.756 A:middle
the hood.

00:31:11.486 --> 00:31:12.906 A:middle
Selection of any one particular

00:31:12.906 --> 00:31:14.476 A:middle
strategy is highly situational

00:31:14.586 --> 00:31:15.986 A:middle
and multiple criteria might have

00:31:16.036 --> 00:31:17.576 A:middle
to be met in order to apply one.

00:31:18.806 --> 00:31:20.056 A:middle
And so, I would warn you to be

00:31:20.056 --> 00:31:21.646 A:middle
careful when you're applying

00:31:21.646 --> 00:31:23.086 A:middle
your own optimizations on top of

00:31:23.086 --> 00:31:23.876 A:middle
the standard controls.

00:31:24.536 --> 00:31:25.516 A:middle
Because a change in rendering

00:31:25.516 --> 00:31:26.986 A:middle
conditions or input data could

00:31:26.986 --> 00:31:28.426 A:middle
nullify any performance gains

00:31:28.426 --> 00:31:29.356 A:middle
from your optimizations.

00:31:30.056 --> 00:31:32.136 A:middle
And to illustrate what I mean by

00:31:32.136 --> 00:31:33.466 A:middle
that, I'd like to share with you

00:31:33.466 --> 00:31:35.056 A:middle
a cautionary tale of two labels.

00:31:35.116 --> 00:31:39.286 A:middle
So, once upon a time, there was

00:31:39.286 --> 00:31:40.576 A:middle
a developer who needed to render

00:31:40.576 --> 00:31:41.466 A:middle
a lot of labels in her app.

00:31:42.606 --> 00:31:43.666 A:middle
And she required each label to

00:31:43.666 --> 00:31:44.946 A:middle
have a line of bold text,

00:31:45.316 --> 00:31:46.506 A:middle
followed by a line of normal

00:31:46.506 --> 00:31:46.936 A:middle
weight text.

00:31:48.156 --> 00:31:49.176 A:middle
And she needed to position her

00:31:49.176 --> 00:31:50.776 A:middle
labels by manually setting their

00:31:50.776 --> 00:31:52.446 A:middle
frames, because business

00:31:52.446 --> 00:31:52.736 A:middle
reasons.

00:31:54.886 --> 00:31:55.926 A:middle
So, she set up her labels with

00:31:55.926 --> 00:31:57.236 A:middle
attributed strings and off she

00:31:58.156 --> 00:31:58.286 A:middle
went.

00:31:59.196 --> 00:32:00.956 A:middle
But she noticed that the

00:32:00.956 --> 00:32:02.336 A:middle
scrolling performance in her app

00:32:02.336 --> 00:32:03.606 A:middle
was a little bit slower than she

00:32:03.606 --> 00:32:03.966 A:middle
would like.

00:32:04.896 --> 00:32:05.666 A:middle
So, she did a little bit of

00:32:05.666 --> 00:32:07.946 A:middle
profiling and she found that one

00:32:07.946 --> 00:32:08.986 A:middle
areas where a lot of time was

00:32:08.986 --> 00:32:10.256 A:middle
being spent was in laying out

00:32:10.256 --> 00:32:11.236 A:middle
and rendering the labels.

00:32:11.946 --> 00:32:13.756 A:middle
So, then she did some

00:32:13.756 --> 00:32:15.756 A:middle
experimentation and she noticed

00:32:16.216 --> 00:32:19.196 A:middle
that if she rendered each line

00:32:19.196 --> 00:32:20.496 A:middle
in a separate label, her app

00:32:20.546 --> 00:32:21.706 A:middle
scrolling performance improved.

00:32:22.256 --> 00:32:23.266 A:middle
''Well, this is fantastic'', she

00:32:23.266 --> 00:32:23.486 A:middle
thought.

00:32:23.896 --> 00:32:24.896 A:middle
So, she changed her app to use a

00:32:24.896 --> 00:32:26.016 A:middle
separate label for each line of

00:32:26.016 --> 00:32:26.336 A:middle
text.

00:32:26.556 --> 00:32:27.556 A:middle
And she lived happily ever

00:32:27.556 --> 00:32:30.226 A:middle
after, until her company wanted

00:32:30.226 --> 00:32:31.176 A:middle
to expand into the Chinese

00:32:31.176 --> 00:32:31.456 A:middle
market.

00:32:33.056 --> 00:32:34.676 A:middle
When she tested her app with

00:32:34.676 --> 00:32:36.376 A:middle
this Chinese text, she was

00:32:36.376 --> 00:32:38.086 A:middle
dismayed to discover that the

00:32:38.086 --> 00:32:39.456 A:middle
scrolling performance was even

00:32:39.556 --> 00:32:40.856 A:middle
slower than before.

00:32:42.266 --> 00:32:43.296 A:middle
So, what happened, here?

00:32:43.456 --> 00:32:46.656 A:middle
Well, our tragic heroine started

00:32:46.656 --> 00:32:47.726 A:middle
off with the right approach.

00:32:48.256 --> 00:32:49.346 A:middle
She was looking at frequent

00:32:49.346 --> 00:32:50.366 A:middle
rendering of lots of short

00:32:50.416 --> 00:32:52.386 A:middle
strings, which falls here, in

00:32:52.386 --> 00:32:52.986 A:middle
quadrant two.

00:32:54.496 --> 00:32:55.406 A:middle
And so, she took some

00:32:55.406 --> 00:32:56.906 A:middle
measurements, she determined an

00:32:56.906 --> 00:32:58.436 A:middle
area for improvement, and she

00:32:58.436 --> 00:32:59.366 A:middle
made an optimization.

00:33:00.436 --> 00:33:01.796 A:middle
But then, when the input data

00:33:01.796 --> 00:33:03.316 A:middle
changed to Chinese text, the

00:33:03.316 --> 00:33:04.766 A:middle
optimization was no longer an

00:33:04.766 --> 00:33:05.276 A:middle
improvement.

00:33:05.276 --> 00:33:07.426 A:middle
And to see why, let's do a

00:33:07.426 --> 00:33:07.956 A:middle
postmortem.

00:33:09.506 --> 00:33:11.106 A:middle
So, in this example, the initial

00:33:11.106 --> 00:33:12.116 A:middle
conditions qualified the

00:33:12.116 --> 00:33:13.516 A:middle
attributed strings for a faster

00:33:13.516 --> 00:33:14.416 A:middle
rendering path within the

00:33:14.416 --> 00:33:14.786 A:middle
framework.

00:33:15.586 --> 00:33:16.566 A:middle
And the optimization of

00:33:16.566 --> 00:33:17.686 A:middle
splitting each line into its own

00:33:17.686 --> 00:33:19.406 A:middle
label took advantage of the fact

00:33:19.406 --> 00:33:20.306 A:middle
that attributed strings

00:33:20.306 --> 00:33:21.446 A:middle
containing only one style of

00:33:21.446 --> 00:33:23.276 A:middle
text may qualify for faster

00:33:23.276 --> 00:33:23.646 A:middle
rendering.

00:33:24.186 --> 00:33:26.976 A:middle
But this isn't a sufficient

00:33:26.976 --> 00:33:28.176 A:middle
condition for faster rendering.

00:33:28.916 --> 00:33:30.406 A:middle
The faster rendering paths take

00:33:30.456 --> 00:33:31.616 A:middle
shortcuts that make certain

00:33:31.616 --> 00:33:33.166 A:middle
assumptions about the input data

00:33:33.166 --> 00:33:34.156 A:middle
and the rendering conditions.

00:33:34.606 --> 00:33:36.056 A:middle
And in this case, using Chinese

00:33:36.056 --> 00:33:37.516 A:middle
text requires font fallback, and

00:33:37.516 --> 00:33:38.546 A:middle
that forced the rendering down

00:33:38.546 --> 00:33:39.456 A:middle
the slower path within the

00:33:39.456 --> 00:33:40.236 A:middle
framework to maintain

00:33:40.236 --> 00:33:40.676 A:middle
correctness.

00:33:40.676 --> 00:33:43.336 A:middle
And on top of that, splitting

00:33:43.336 --> 00:33:44.326 A:middle
the two-line strings into

00:33:44.326 --> 00:33:45.216 A:middle
separate labels, meant that the

00:33:45.216 --> 00:33:46.576 A:middle
app was rendering twice as many

00:33:46.576 --> 00:33:48.336 A:middle
labels as it needed to.

00:33:49.786 --> 00:33:51.756 A:middle
And additionally, the app was

00:33:51.756 --> 00:33:53.116 A:middle
using older layout practices by

00:33:53.116 --> 00:33:54.236 A:middle
manually setting the frames,

00:33:54.396 --> 00:33:55.436 A:middle
instead of using auto layout.

00:33:56.266 --> 00:33:57.416 A:middle
So generally, we're going to pay

00:33:57.416 --> 00:33:58.356 A:middle
a lot of attention to

00:33:58.356 --> 00:33:59.476 A:middle
performance under conditions

00:33:59.516 --> 00:34:00.796 A:middle
that are using modern practices,

00:34:00.896 --> 00:34:01.546 A:middle
like auto layout.

00:34:01.626 --> 00:34:02.926 A:middle
Because that's what most apps

00:34:02.926 --> 00:34:04.096 A:middle
are using and that's where our

00:34:04.096 --> 00:34:05.086 A:middle
performance improvements will

00:34:05.086 --> 00:34:05.966 A:middle
make the largest impact.

00:34:07.056 --> 00:34:07.756 A:middle
So, with auto layout in

00:34:07.756 --> 00:34:08.976 A:middle
particular, that text system

00:34:08.976 --> 00:34:10.496 A:middle
caches some layout information.

00:34:10.856 --> 00:34:11.756 A:middle
And this can really improve

00:34:11.756 --> 00:34:12.236 A:middle
performance.

00:34:12.286 --> 00:34:13.476 A:middle
But since this app wasn't using

00:34:13.476 --> 00:34:15.166 A:middle
auto layout, it couldn't take

00:34:15.166 --> 00:34:16.996 A:middle
advantage of that.

00:34:17.186 --> 00:34:18.066 A:middle
And so, with that in mind,

00:34:18.556 --> 00:34:19.746 A:middle
here's some strategies and tips

00:34:19.876 --> 00:34:21.206 A:middle
that you can employ to improve

00:34:21.206 --> 00:34:22.266 A:middle
text layout and rendering

00:34:22.686 --> 00:34:23.636 A:middle
performance in your app.

00:34:23.636 --> 00:34:26.256 A:middle
Now, if you've been paying

00:34:26.256 --> 00:34:27.386 A:middle
attention, you already know what

00:34:27.386 --> 00:34:28.066 A:middle
I'm going to say the first

00:34:28.066 --> 00:34:28.536 A:middle
strategy is.

00:34:29.146 --> 00:34:31.276 A:middle
Use the standard labels for

00:34:31.276 --> 00:34:32.746 A:middle
rendering your text and let us

00:34:32.746 --> 00:34:33.766 A:middle
do the heavy lifting for you.

00:34:34.686 --> 00:34:35.646 A:middle
The framework is in a better

00:34:35.706 --> 00:34:36.486 A:middle
place to apply these

00:34:36.486 --> 00:34:37.896 A:middle
optimizations, because it has a

00:34:37.946 --> 00:34:38.796 A:middle
bigger picture view of the

00:34:38.836 --> 00:34:40.336 A:middle
situation and more information

00:34:40.336 --> 00:34:41.376 A:middle
about the rendering conditions.

00:34:42.516 --> 00:34:43.806 A:middle
And when we make performance

00:34:43.806 --> 00:34:44.596 A:middle
improvements, you'll

00:34:44.596 --> 00:34:45.556 A:middle
automatically get those

00:34:45.606 --> 00:34:45.966 A:middle
benefits.

00:34:46.886 --> 00:34:48.516 A:middle
So, as an example of that, in

00:34:48.516 --> 00:34:50.846 A:middle
macOS 10.13, NSTextField renders

00:34:50.846 --> 00:34:52.346 A:middle
text roughly three times faster,

00:34:52.346 --> 00:34:54.376 A:middle
at 5.7 milliseconds per frame

00:34:54.526 --> 00:34:55.406 A:middle
during live resize.

00:34:55.746 --> 00:34:58.336 A:middle
Down from 16.67 milliseconds per

00:34:58.336 --> 00:34:59.136 A:middle
frame in 10.12.

00:34:59.816 --> 00:35:00.956 A:middle
And you'll get this performance

00:35:00.956 --> 00:35:02.246 A:middle
boost for free if you're using

00:35:02.246 --> 00:35:03.296 A:middle
the standard framework controls.

00:35:03.876 --> 00:35:05.006 A:middle
So, it's really a good idea to

00:35:05.006 --> 00:35:06.076 A:middle
use the standard controls

00:35:06.146 --> 00:35:06.826 A:middle
whenever possible.

00:35:07.286 --> 00:35:11.506 A:middle
Second strategy, as we kind of

00:35:11.506 --> 00:35:13.096 A:middle
saw from out story, is to use

00:35:13.096 --> 00:35:14.316 A:middle
modern layout practices like

00:35:14.316 --> 00:35:14.816 A:middle
auto layout.

00:35:15.516 --> 00:35:16.526 A:middle
Now, text layout and rendering

00:35:16.526 --> 00:35:17.436 A:middle
performance with modern

00:35:17.436 --> 00:35:19.016 A:middle
practices is very heavily

00:35:19.016 --> 00:35:20.136 A:middle
scrutinized on our end.

00:35:20.866 --> 00:35:22.016 A:middle
And by adopting these modern

00:35:22.016 --> 00:35:23.426 A:middle
practices, you'll be less likely

00:35:23.426 --> 00:35:24.396 A:middle
to run into edge case

00:35:24.396 --> 00:35:25.536 A:middle
performance scenarios that we

00:35:25.536 --> 00:35:26.486 A:middle
haven't already seen and

00:35:26.486 --> 00:35:26.856 A:middle
improved.

00:35:30.536 --> 00:35:32.306 A:middle
Next up, is a lower level tip.

00:35:32.796 --> 00:35:33.456 A:middle
If you're working with

00:35:33.456 --> 00:35:35.276 A:middle
NSAttributedString, there are a

00:35:35.276 --> 00:35:36.346 A:middle
few attributes that are

00:35:36.346 --> 00:35:37.846 A:middle
absolutely necessary for layout

00:35:37.846 --> 00:35:38.296 A:middle
and rendering.

00:35:38.296 --> 00:35:40.406 A:middle
And if you don't supply these

00:35:40.406 --> 00:35:41.666 A:middle
attributes yourself, the text

00:35:41.666 --> 00:35:42.986 A:middle
system needs to resolve them in

00:35:42.986 --> 00:35:44.016 A:middle
order to be able to render.

00:35:44.536 --> 00:35:45.746 A:middle
And so, you can shave off a

00:35:45.746 --> 00:35:47.056 A:middle
little bit of time by supplying

00:35:47.056 --> 00:35:48.456 A:middle
these attributes yourself, when

00:35:48.456 --> 00:35:49.516 A:middle
rendering attributed strings.

00:35:50.176 --> 00:35:53.896 A:middle
In a similar vein, you might see

00:35:53.896 --> 00:35:54.916 A:middle
some small improvements from

00:35:54.916 --> 00:35:56.346 A:middle
explicitly specifying the

00:35:56.346 --> 00:35:57.546 A:middle
writing direction and alignment,

00:35:57.546 --> 00:35:58.566 A:middle
instead of using the natural

00:35:58.606 --> 00:35:58.926 A:middle
settings.

00:35:59.006 --> 00:36:00.876 A:middle
And this will save you a little

00:36:00.876 --> 00:36:01.956 A:middle
time, because the text system

00:36:01.956 --> 00:36:03.196 A:middle
can skip over any logic that

00:36:03.196 --> 00:36:04.256 A:middle
tries to figure out the writing

00:36:04.256 --> 00:36:05.236 A:middle
direction and the alignment.

00:36:06.486 --> 00:36:07.426 A:middle
But remember that you'll only

00:36:07.426 --> 00:36:08.316 A:middle
want to do this if you're

00:36:08.316 --> 00:36:09.956 A:middle
absolutely sure that your input

00:36:09.956 --> 00:36:11.536 A:middle
data won't contain mixed writing

00:36:11.536 --> 00:36:11.926 A:middle
directions.

00:36:11.926 --> 00:36:13.536 A:middle
Now, there's a balance between

00:36:13.536 --> 00:36:14.506 A:middle
performance and correctness.

00:36:14.506 --> 00:36:16.116 A:middle
And this is one optimization

00:36:16.116 --> 00:36:17.446 A:middle
that can tip the balance a

00:36:17.446 --> 00:36:18.396 A:middle
little too far away from

00:36:18.396 --> 00:36:19.516 A:middle
correctness if you're not sure

00:36:19.516 --> 00:36:19.976 A:middle
of your input.

00:36:23.266 --> 00:36:24.756 A:middle
And along those same lines of

00:36:24.756 --> 00:36:25.936 A:middle
performance versus correctness,

00:36:26.436 --> 00:36:27.726 A:middle
if you know that all your labels

00:36:27.726 --> 00:36:28.986 A:middle
are only going to consist of one

00:36:28.986 --> 00:36:30.626 A:middle
line, you can set the line break

00:36:30.626 --> 00:36:31.486 A:middle
mode to use clipping.

00:36:32.376 --> 00:36:34.156 A:middle
Now, by default, labels will use

00:36:34.156 --> 00:36:34.506 A:middle
word wrap.

00:36:34.796 --> 00:36:35.996 A:middle
And when you do this, the text

00:36:35.996 --> 00:36:37.126 A:middle
system needs to figure out where

00:36:37.126 --> 00:36:37.966 A:middle
to place the line breaks.

00:36:38.606 --> 00:36:39.546 A:middle
And so, if you use the clipping

00:36:39.546 --> 00:36:40.986 A:middle
line break mode, you can skip

00:36:41.176 --> 00:36:42.436 A:middle
this line breaking and

00:36:42.436 --> 00:36:43.616 A:middle
hyphenation logic, and your text

00:36:43.616 --> 00:36:44.666 A:middle
might run there just a little

00:36:44.836 --> 00:36:45.656 A:middle
bit faster.

00:36:48.066 --> 00:36:49.186 A:middle
So, in summary, we've looked at

00:36:49.186 --> 00:36:49.936 A:middle
a lot of different things,

00:36:49.986 --> 00:36:50.276 A:middle
today.

00:36:50.506 --> 00:36:51.476 A:middle
From performance improvements in

00:36:51.476 --> 00:36:53.276 A:middle
Foundation, to string bridging

00:36:53.486 --> 00:36:54.406 A:middle
and working with text.

00:36:55.176 --> 00:36:56.086 A:middle
Now, if you take just one thing

00:36:56.086 --> 00:36:57.576 A:middle
away from this talk, let it be

00:36:57.576 --> 00:36:58.086 A:middle
this graph.

00:36:58.686 --> 00:37:00.036 A:middle
Use the concepts of scale and

00:37:00.036 --> 00:37:01.726 A:middle
frequency to minimize the large

00:37:01.726 --> 00:37:02.946 A:middle
expense of operations in your

00:37:02.946 --> 00:37:03.256 A:middle
code.

00:37:03.726 --> 00:37:04.906 A:middle
Don't sweat the small infrequent

00:37:04.906 --> 00:37:06.636 A:middle
stuff, and always measure if you

00:37:06.636 --> 00:37:06.976 A:middle
aren't sure.

00:37:10.076 --> 00:37:11.306 A:middle
So, for more information, you

00:37:11.306 --> 00:37:13.116 A:middle
can visit our session URL, we

00:37:13.166 --> 00:37:16.046 A:middle
are Session 244.

00:37:16.046 --> 00:37:17.646 A:middle
And check out these related

00:37:17.646 --> 00:37:18.796 A:middle
sessions on video.

00:37:18.796 --> 00:37:19.296 A:middle
Pretty cool.

00:37:19.866 --> 00:37:21.546 A:middle
Unfortunately, most of them

00:37:21.546 --> 00:37:22.066 A:middle
already happened.

00:37:23.266 --> 00:37:24.376 A:middle
Thank you, and enjoy the rest of

00:37:24.376 --> 00:37:24.946 A:middle
the conference.

00:37:25.516 --> 00:37:28.500 A:middle
[ Applause ]