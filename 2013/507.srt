WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:00.506 --> 00:00:09.896 A:middle
[Silence]

00:00:10.396 --> 00:00:11.406 A:middle
&gt;&gt; [Applause] Welcome, hello.

00:00:15.056 --> 00:00:16.226 A:middle
So I'm Chris Niederauer.

00:00:16.346 --> 00:00:20.826 A:middle
I work on the GPU Software
Team and I'm here to talk today

00:00:20.826 --> 00:00:23.396 A:middle
about what's new
in OpenGL for OS X.

00:00:25.816 --> 00:00:28.866 A:middle
So during this talk I'm
going to go into some

00:00:28.866 --> 00:00:30.196 A:middle
of the feature support update.

00:00:30.196 --> 00:00:32.366 A:middle
What's new in OS X
Mavericks in particular.

00:00:33.226 --> 00:00:36.056 A:middle
And then after that I'm
going to go into a few

00:00:36.056 --> 00:00:38.926 A:middle
of the key features that we
think you're probably going

00:00:38.926 --> 00:00:40.686 A:middle
to want to be using
in your applications.

00:00:41.416 --> 00:00:44.686 A:middle
After that we're going to
talk about using Compute

00:00:44.686 --> 00:00:46.466 A:middle
with OpenGL using OpenCL.

00:00:47.216 --> 00:00:50.756 A:middle
And then finally towards the
end I'm going to do a quick run

00:00:50.756 --> 00:00:52.586 A:middle
through -- trying to
get your applications

00:00:53.166 --> 00:00:55.826 A:middle
into OpenGL Core Profile so
that you can take advantage

00:00:55.826 --> 00:00:58.246 A:middle
of all these new features.

00:00:59.676 --> 00:01:02.356 A:middle
So let's start with
the features.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.676 --> 00:01:02.356 A:middle
So let's start with
the features.

00:01:03.446 --> 00:01:08.086 A:middle
In OpenGL as of Lion we've
had support for Core Profile

00:01:08.446 --> 00:01:11.576 A:middle
and this has a bunch of features
that are pretty much guaranteed

00:01:11.576 --> 00:01:14.756 A:middle
if you ask for [inaudible] Core
Profile; frameBuffer Objects,

00:01:14.756 --> 00:01:16.586 A:middle
vertex array objects, the usual.

00:01:17.016 --> 00:01:22.066 A:middle
New in Mavericks; we've got a
whole bunch of new extensions

00:01:22.066 --> 00:01:26.846 A:middle
like texture swizzle, sampler
objects, texture storage

00:01:27.276 --> 00:01:31.276 A:middle
and then additionally on
modern GPUs we have support

00:01:31.276 --> 00:01:36.256 A:middle
for tessellation shaders and all
the other OpenGL 4.1 features

00:01:36.306 --> 00:01:37.516 A:middle
plus a little bit more.

00:01:38.436 --> 00:01:40.996 A:middle
So that's an update
on where we are.

00:01:40.996 --> 00:01:44.906 A:middle
And so these are some of the
features I'm going to go into.

00:01:45.416 --> 00:01:47.266 A:middle
Explain how you can
get your applications

00:01:47.326 --> 00:01:50.026 A:middle
to take advantage
of these features.

00:01:50.026 --> 00:01:56.376 A:middle
So let's start with probably
the big new feature on --

00:01:56.456 --> 00:01:58.346 A:middle
in Mavericks; tessellation
shaders.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:00.376 --> 00:02:05.046 A:middle
So what tessellation shaders do
is they allow you to use a GPU

00:02:05.046 --> 00:02:11.226 A:middle
in order to generate geometry
to a specific how course,

00:02:11.226 --> 00:02:13.906 A:middle
how fine you want your geometry
to be and you generate it

00:02:13.906 --> 00:02:17.036 A:middle
on the fly where you need
it to be, where you want

00:02:17.036 --> 00:02:18.086 A:middle
to spend your Vertices.

00:02:18.846 --> 00:02:20.066 A:middle
Let's see.

00:02:20.216 --> 00:02:24.256 A:middle
Define using shaders
and the benefits.

00:02:24.256 --> 00:02:27.876 A:middle
It allows you to dynamically
increase your polygon density.

00:02:28.276 --> 00:02:30.196 A:middle
So you're able to decrease
your vertex bandwidth

00:02:30.196 --> 00:02:32.056 A:middle
because you're only
uploading a course mesh.

00:02:32.566 --> 00:02:35.946 A:middle
And then you get to decide
how to refine that mesh.

00:02:36.726 --> 00:02:39.096 A:middle
And it's used often for
displacement mapping,

00:02:39.096 --> 00:02:42.556 A:middle
terrain rendering,
high-order surfaces like NERPS.

00:02:43.266 --> 00:02:45.706 A:middle
And it's available
on the modern GPUs,

00:02:45.736 --> 00:02:47.036 A:middle
so all the hardware
we ship today.

00:02:47.036 --> 00:02:51.386 A:middle
If you -- so you'll
need to make sure

00:02:51.386 --> 00:02:54.176 A:middle
to check the extension
stream using glGetStringi

00:02:54.976 --> 00:02:57.726 A:middle
for ARB underscore
tessellation underscore shader.

00:02:57.996 --> 00:03:00.746 A:middle
So we have here an
application that's been --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:57.996 --> 00:03:00.746 A:middle
So we have here an
application that's been --

00:03:00.826 --> 00:03:03.666 A:middle
is out on the Mac which
is called Unigine Heaven

00:03:04.406 --> 00:03:08.986 A:middle
and actually it's been updated
to be able to take advantage

00:03:08.986 --> 00:03:10.086 A:middle
of tessellation shaders.

00:03:10.796 --> 00:03:12.996 A:middle
So we sort of before and after.

00:03:13.696 --> 00:03:16.456 A:middle
We have the stairs are
just a flat polygon there

00:03:16.456 --> 00:03:18.386 A:middle
and then the dragon's neck.

00:03:19.086 --> 00:03:21.136 A:middle
There's little points where
there should be spikes

00:03:21.196 --> 00:03:22.346 A:middle
but there's no spikes there.

00:03:23.056 --> 00:03:27.666 A:middle
With tessellation shaders you
see how it generates geometry,

00:03:27.666 --> 00:03:30.796 A:middle
it uses displacement map, it
creates spikes on the dragon

00:03:30.796 --> 00:03:34.276 A:middle
and the stairs suddenly
become actually stair shaped.

00:03:35.046 --> 00:03:39.646 A:middle
So to get a little bit into --

00:03:39.646 --> 00:03:42.216 A:middle
I'm going to describe how
tessellation shaders work.

00:03:42.646 --> 00:03:44.796 A:middle
So I also want to give
this example screenshot

00:03:45.286 --> 00:03:49.106 A:middle
where you can see that the
application is choosing

00:03:49.106 --> 00:03:52.516 A:middle
to dynamically tessellate
this geometry based

00:03:52.516 --> 00:03:54.026 A:middle
on the distance to the camera.

00:03:54.476 --> 00:03:56.346 A:middle
So you're using the
vertex bandwidth only

00:03:56.346 --> 00:03:57.506 A:middle
where you need to, you know,

00:03:57.506 --> 00:03:59.546 A:middle
only where you think
this thing needs it.

00:03:59.546 --> 00:04:02.236 A:middle
So closer objects you'll
probably tessellate a lot more

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:59.546 --> 00:04:02.236 A:middle
So closer objects you'll
probably tessellate a lot more

00:04:02.236 --> 00:04:06.416 A:middle
than objects in the distance.

00:04:06.806 --> 00:04:11.476 A:middle
So we start with a new
type called a patch.

00:04:11.916 --> 00:04:13.346 A:middle
And we set up our patches --

00:04:13.346 --> 00:04:15.926 A:middle
we say how many vertices there
are going to be in each patch.

00:04:16.286 --> 00:04:19.666 A:middle
So in this case with a triangle
patch we have 3 vertices

00:04:20.586 --> 00:04:23.206 A:middle
and then when we draw
-- we call DrawArrays.

00:04:23.736 --> 00:04:27.586 A:middle
So in the shaders there's
two parts to the shader.

00:04:27.926 --> 00:04:30.266 A:middle
The first part of the
shader we're going

00:04:30.316 --> 00:04:32.816 A:middle
to control how tessellated
we want it to be.

00:04:33.206 --> 00:04:37.646 A:middle
So first in our control
shader we're going

00:04:37.646 --> 00:04:42.106 A:middle
to be setting the outer levels
and we get to pick per side

00:04:42.166 --> 00:04:45.196 A:middle
of this triangle how
tessellated we want it to be.

00:04:45.526 --> 00:04:46.596 A:middle
And so we see in the --

00:04:46.596 --> 00:04:49.366 A:middle
on the left side of the triangle
we did a little bit more

00:04:49.366 --> 00:04:51.966 A:middle
tessellation there than we did
on the bottom and the right.

00:04:52.736 --> 00:04:56.536 A:middle
Additionally you get to control
the inner levels tessellation.

00:04:57.666 --> 00:04:59.466 A:middle
So we're adding some
geometry there.

00:04:59.826 --> 00:05:06.726 A:middle
And then once we have these --
this data output it gets output

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:59.826 --> 00:05:06.726 A:middle
And then once we have these --
this data output it gets output

00:05:06.726 --> 00:05:12.436 A:middle
to an evaluation shader
and that shader gets a --

00:05:12.436 --> 00:05:14.996 A:middle
the control points that you
originally got and we evaluate

00:05:14.996 --> 00:05:16.556 A:middle
where those positions should be.

00:05:16.816 --> 00:05:19.536 A:middle
So we have test coordinates
and in this case

00:05:19.536 --> 00:05:24.996 A:middle
because we had a triangle we
have three different TessCoords

00:05:24.996 --> 00:05:27.986 A:middle
and you can see how it's
very centric and each

00:05:27.986 --> 00:05:32.326 A:middle
of those is weighted towards
the original control points.

00:05:33.406 --> 00:05:36.756 A:middle
And so using this is our
evaluation shader we can now

00:05:37.006 --> 00:05:39.456 A:middle
figure out where those
points should be and push it

00:05:39.456 --> 00:05:42.636 A:middle
out with displacement --
with a displacement map

00:05:42.636 --> 00:05:44.206 A:middle
or do whatever you
want at that point.

00:05:44.766 --> 00:05:50.346 A:middle
So the OpenGL 4 Pipeline;
you're probably aware

00:05:50.346 --> 00:05:52.416 A:middle
of what it looks like before.

00:05:52.416 --> 00:05:55.666 A:middle
We have vertex shaders on
the left, fragment shaders

00:05:55.666 --> 00:05:57.866 A:middle
on the right and
then tessellation

00:05:57.866 --> 00:05:59.816 A:middle
and geometry shaders
are both optional.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:00.096 --> 00:06:02.186 A:middle
So tessellation fits
right in the middle there

00:06:02.546 --> 00:06:07.656 A:middle
and it's actually made out
of two different shaders

00:06:07.816 --> 00:06:10.006 A:middle
that are -- that I will go into.

00:06:10.076 --> 00:06:12.466 A:middle
So as I was saying
there's a control shader

00:06:12.466 --> 00:06:13.926 A:middle
and an evaluation
shader so you get

00:06:13.926 --> 00:06:17.736 A:middle
to control how tessellated it is
and then you evaluate where each

00:06:17.776 --> 00:06:19.906 A:middle
of those vertices should be put.

00:06:20.646 --> 00:06:22.936 A:middle
So the control shader.

00:06:24.026 --> 00:06:29.566 A:middle
It takes as inputs the
control points from the patches

00:06:30.216 --> 00:06:34.826 A:middle
and then basically the
array of control points

00:06:34.906 --> 00:06:37.896 A:middle
and the original patches.

00:06:38.076 --> 00:06:43.066 A:middle
And the outputs is setting how
tessellated we should tessellate

00:06:43.066 --> 00:06:47.796 A:middle
each of the edges and then we
also have inner tessellation

00:06:47.796 --> 00:06:48.956 A:middle
levels, as well.

00:06:49.836 --> 00:06:52.806 A:middle
And a tip for when
you do have patches

00:06:52.806 --> 00:06:53.876 A:middle
that are touching each other.

00:06:54.136 --> 00:06:56.986 A:middle
You want to make sure that
you have the same amount

00:06:56.986 --> 00:06:59.896 A:middle
of tessellation on
those touching edges.

00:06:59.896 --> 00:07:05.136 A:middle
So let's get onto looking
at an actual control shader

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:59.896 --> 00:07:05.136 A:middle
So let's get onto looking
at an actual control shader

00:07:05.926 --> 00:07:07.586 A:middle
with this triangle example.

00:07:08.036 --> 00:07:11.576 A:middle
We have -- we set up the
layout with the vertices saying

00:07:11.576 --> 00:07:14.696 A:middle
that there's three
control points per patch,

00:07:15.296 --> 00:07:18.046 A:middle
and we're going to have
our input vertex position

00:07:18.686 --> 00:07:21.076 A:middle
from the original patch
points and we're going

00:07:21.076 --> 00:07:22.596 A:middle
to output control positions.

00:07:23.726 --> 00:07:26.656 A:middle
So first for every
input we're going

00:07:26.656 --> 00:07:29.746 A:middle
to copy the vertex position
to the control position.

00:07:30.386 --> 00:07:34.396 A:middle
And then additionally once
per patch this InvocationID --

00:07:35.126 --> 00:07:39.476 A:middle
once per patch we're checking
for only doing this once.

00:07:39.966 --> 00:07:43.016 A:middle
We're going to calculate what
those tessellation outer levels

00:07:43.016 --> 00:07:43.486 A:middle
should be.

00:07:43.486 --> 00:07:44.506 A:middle
What the TessCoords --

00:07:45.086 --> 00:07:47.266 A:middle
and it will generate
TessCoords from there.

00:07:48.016 --> 00:07:51.516 A:middle
And then the evaluation shader.

00:07:52.706 --> 00:07:56.156 A:middle
That takes and evaluates
where the output

00:07:56.276 --> 00:07:59.086 A:middle
from the control shader
should be within --

00:07:59.306 --> 00:08:02.786 A:middle
to pass on to the
geometry or fragment stage.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.306 --> 00:08:02.786 A:middle
to pass on to the
geometry or fragment stage.

00:08:03.576 --> 00:08:05.316 A:middle
So it takes the original patch

00:08:05.626 --> 00:08:07.946 A:middle
and the tessellation coordinates
sort of waning towards each

00:08:08.006 --> 00:08:10.596 A:middle
of those original
patch coordinates.

00:08:10.726 --> 00:08:15.006 A:middle
And then it outputs; your
position, your TexCoordinates

00:08:15.216 --> 00:08:17.586 A:middle
and any other attributes
that you may have.

00:08:18.756 --> 00:08:23.596 A:middle
So here is an example with a
triangle evaluation shader.

00:08:24.106 --> 00:08:29.606 A:middle
We're specifying how
the -- oops, let's see.

00:08:30.596 --> 00:08:34.376 A:middle
We've got the controls as input

00:08:34.376 --> 00:08:36.716 A:middle
and we've also got a model
view protection matrix.

00:08:37.166 --> 00:08:39.895 A:middle
And basically we're
treating the TessCoords --

00:08:39.895 --> 00:08:41.246 A:middle
we have three TessCoord inputs

00:08:41.546 --> 00:08:43.416 A:middle
which are barycentric
weights towards each

00:08:43.416 --> 00:08:44.886 A:middle
of those original
control points.

00:08:45.246 --> 00:08:46.446 A:middle
And so we're multiplying --

00:08:46.446 --> 00:08:51.346 A:middle
doing a barycentric multiply
here to get the output

00:08:51.346 --> 00:08:52.426 A:middle
of where those should be.

00:08:52.426 --> 00:08:56.196 A:middle
So doing just this simple
math here gets us the evenly

00:08:56.196 --> 00:08:59.286 A:middle
distributed points as we
specified in our control shader.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:00.116 --> 00:09:02.666 A:middle
And then after we've
done that we can --

00:09:02.666 --> 00:09:05.936 A:middle
here was have a model view
projection matrix multiplying

00:09:05.936 --> 00:09:09.186 A:middle
by our position that
we calculated passed

00:09:09.406 --> 00:09:12.456 A:middle
into a custom function which
is doing our displacement.

00:09:13.046 --> 00:09:16.826 A:middle
So we started with our
triangle patch just three

00:09:16.826 --> 00:09:17.606 A:middle
points originally.

00:09:18.396 --> 00:09:19.976 A:middle
We controlled how
tessellated it was,

00:09:20.056 --> 00:09:23.956 A:middle
and then we evaluated exactly
where those positions should be

00:09:24.326 --> 00:09:26.696 A:middle
to pass on to the
fragment shader.

00:09:27.896 --> 00:09:31.886 A:middle
The quad -- just as a further
example, with the quad --

00:09:32.476 --> 00:09:33.806 A:middle
the control shader
is very similar

00:09:33.806 --> 00:09:35.256 A:middle
to what the triangle except

00:09:35.256 --> 00:09:37.676 A:middle
for this time we're
specifying the vertices as four.

00:09:37.676 --> 00:09:40.876 A:middle
We also set patch
parameter I for the number

00:09:40.876 --> 00:09:42.236 A:middle
of control points to be four.

00:09:43.036 --> 00:09:44.926 A:middle
And then similarly we're passing

00:09:44.926 --> 00:09:47.276 A:middle
through the original
vertex position

00:09:47.276 --> 00:09:48.666 A:middle
for the new control positions

00:09:49.726 --> 00:09:53.676 A:middle
and then calculating
our tessellation levels.

00:09:53.786 --> 00:09:57.596 A:middle
And in this case we have more
inner levels and outer levels

00:09:57.596 --> 00:10:00.336 A:middle
to calculate because we
have four sides to the quad

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:57.596 --> 00:10:00.336 A:middle
to calculate because we
have four sides to the quad

00:10:00.746 --> 00:10:04.396 A:middle
and additionally for the inner
levels we're controlling how

00:10:04.396 --> 00:10:06.666 A:middle
split should it be
horizontally and vertically.

00:10:06.806 --> 00:10:12.216 A:middle
Then in the evaluation shader
taking the control points

00:10:12.216 --> 00:10:13.796 A:middle
in again, there's four
of them this time,

00:10:14.446 --> 00:10:17.536 A:middle
and because we have a
quad we're actually able

00:10:17.536 --> 00:10:19.016 A:middle
to treat those barycentric
weights

00:10:19.016 --> 00:10:22.796 A:middle
as just UV coordinates
basically within our quad.

00:10:23.496 --> 00:10:25.976 A:middle
So we just -- we're just doing
a simple mix here to figure

00:10:25.976 --> 00:10:28.566 A:middle
out what those positions should
be for each of the points.

00:10:28.866 --> 00:10:32.646 A:middle
And then again we pass
that calculated position

00:10:32.876 --> 00:10:38.686 A:middle
into the custom displacement
map to get our position out.

00:10:39.276 --> 00:10:43.766 A:middle
So with our quad we started
with just the four points.

00:10:44.286 --> 00:10:48.106 A:middle
We tessellated it and
then evaluated where each

00:10:48.106 --> 00:10:51.176 A:middle
of those places should be.

00:10:51.346 --> 00:10:55.306 A:middle
So in summary tessellation
shader allows you to add detail

00:10:55.306 --> 00:10:58.596 A:middle
where you need it in your
scene and you can start

00:10:58.596 --> 00:11:00.606 A:middle
with triangles, quads,
arbitrary geometry.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:58.596 --> 00:11:00.606 A:middle
with triangles, quads,
arbitrary geometry.

00:11:00.606 --> 00:11:02.016 A:middle
Even like isolines.

00:11:02.596 --> 00:11:05.726 A:middle
And generates this
data on the GPU instead

00:11:05.726 --> 00:11:06.846 A:middle
of you having to submit it.

00:11:06.846 --> 00:11:09.586 A:middle
So you have a low
resolution model potentially

00:11:09.586 --> 00:11:12.216 A:middle
that you are able
to only tessellate

00:11:12.256 --> 00:11:14.176 A:middle
as the model gets
closer to the camera,

00:11:14.886 --> 00:11:18.716 A:middle
or just too simply add
displacement or extra geometry

00:11:19.026 --> 00:11:22.026 A:middle
to make a character
realistic in your scenes.

00:11:22.386 --> 00:11:26.296 A:middle
And so again it's available on
modern hardware so you'll need

00:11:26.296 --> 00:11:29.066 A:middle
to check for the existence
of tessellation shader

00:11:29.636 --> 00:11:34.066 A:middle
with GetStringi, and be sure
to match your outer patches

00:11:34.066 --> 00:11:36.356 A:middle
because otherwise
you may have cracks

00:11:36.356 --> 00:11:41.716 A:middle
in between your touching
patches.

00:11:41.886 --> 00:11:45.146 A:middle
So also another feature I
want to go over is instancing.

00:11:46.376 --> 00:11:52.826 A:middle
And instancing is allowing
you to draw many instances

00:11:53.146 --> 00:11:56.276 A:middle
of an object with only
a single draw call.

00:11:56.806 --> 00:11:59.246 A:middle
And it's a big performance boost

00:11:59.246 --> 00:12:02.196 A:middle
because each draw call does
take a little bit of overhead

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.246 --> 00:12:02.196 A:middle
because each draw call does
take a little bit of overhead

00:12:02.716 --> 00:12:04.346 A:middle
in order to get that to the GPU.

00:12:04.346 --> 00:12:06.616 A:middle
So instead we're just
passing it all down at once

00:12:06.616 --> 00:12:13.076 A:middle
and allowing the GPU to do that
work as a single draw call.

00:12:13.706 --> 00:12:17.226 A:middle
And so each of these
instances can have their own

00:12:17.226 --> 00:12:18.436 A:middle
unique parameters.

00:12:19.186 --> 00:12:23.736 A:middle
So the offset of a one
instance from another, colors,

00:12:24.236 --> 00:12:28.186 A:middle
skeletal attributes and
you define all these

00:12:28.186 --> 00:12:29.156 A:middle
in external buffers.

00:12:30.226 --> 00:12:32.146 A:middle
And this is actually
-- when you ask

00:12:32.146 --> 00:12:35.376 A:middle
for a Core Profile
you're guaranteed on OS X

00:12:35.376 --> 00:12:38.816 A:middle
that you have support
for this extension.

00:12:39.426 --> 00:12:42.206 A:middle
And there's two forms
of instancing.

00:12:43.556 --> 00:12:46.696 A:middle
There's instanced arrays
using ARB underscore instanced

00:12:46.696 --> 00:12:48.256 A:middle
underscore arrays where
you get to have a divisor

00:12:48.256 --> 00:12:51.586 A:middle
that says how often your
attributes should be submitted

00:12:51.586 --> 00:12:52.186 A:middle
per vertex.

00:12:52.186 --> 00:12:55.426 A:middle
So as opposed to having
-- per instance, sorry.

00:12:55.936 --> 00:12:58.216 A:middle
So if you wanted to
submit an attribute

00:12:58.546 --> 00:13:01.296 A:middle
for every one instance you
would pass a vertex [inaudible]

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.546 --> 00:13:01.296 A:middle
for every one instance you
would pass a vertex [inaudible]

00:13:01.296 --> 00:13:02.346 A:middle
divisor of one.

00:13:02.506 --> 00:13:06.896 A:middle
If you wanted to have a
different attribute every two

00:13:06.896 --> 00:13:10.146 A:middle
instances, two and so forth.

00:13:10.146 --> 00:13:15.036 A:middle
Also draw instanced provides
a variable shader instance ID.

00:13:15.256 --> 00:13:18.096 A:middle
So in your draw call from
your vertex or fragment --

00:13:18.096 --> 00:13:22.256 A:middle
from your vertex shader you
can decide what you can see,

00:13:22.256 --> 00:13:23.656 A:middle
which instance ID you are in.

00:13:23.716 --> 00:13:27.646 A:middle
So you can tell -- do
an offset into a buffer

00:13:27.646 --> 00:13:29.566 A:middle
for instance based
in an instance ID.

00:13:30.096 --> 00:13:32.496 A:middle
And I'll go into a little bit --

00:13:32.496 --> 00:13:34.976 A:middle
some examples of doing
that in a short bit.

00:13:36.066 --> 00:13:38.946 A:middle
But I'm not actually going to go
into this too deeply right now

00:13:38.946 --> 00:13:42.426 A:middle
because we actually
announced support for both

00:13:42.426 --> 00:13:44.546 A:middle
of these features in iOS 7.

00:13:45.146 --> 00:13:48.556 A:middle
And Dan my colleague
gave a talk this morning;

00:13:49.236 --> 00:13:53.146 A:middle
Advanced is OpenGL ES where he
went into depth in instancing.

00:13:56.176 --> 00:13:58.606 A:middle
So that was instancing.

00:13:59.116 --> 00:14:01.556 A:middle
Let's go on to how
we pass up some data

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.116 --> 00:14:01.556 A:middle
Let's go on to how
we pass up some data

00:14:01.556 --> 00:14:04.006 A:middle
like uniform buffer
objects is one way

00:14:04.006 --> 00:14:06.386 A:middle
to get some data
up to the shaders.

00:14:07.296 --> 00:14:09.506 A:middle
And basically it's
a buffer object

00:14:09.506 --> 00:14:10.806 A:middle
to store your uniform data.

00:14:11.106 --> 00:14:13.836 A:middle
It's faster than
using glUniform.

00:14:14.696 --> 00:14:17.736 A:middle
You can share a single uniform
buffer object among different

00:14:17.736 --> 00:14:21.286 A:middle
GLSL shaders and you can
quickly switch between sets.

00:14:21.286 --> 00:14:24.946 A:middle
If you have some prebaked sets
you can just choose on the fly

00:14:24.946 --> 00:14:26.066 A:middle
which one you're using.

00:14:27.066 --> 00:14:30.176 A:middle
And additionally because
it's a buffer object

00:14:30.396 --> 00:14:33.866 A:middle
as all buffer objects you can
generate your data on the GPU

00:14:34.376 --> 00:14:39.756 A:middle
and use the output from that
in your UBO, in the shader

00:14:39.756 --> 00:14:40.996 A:middle
without having to
do a read back.

00:14:42.556 --> 00:14:46.256 A:middle
And it's used for skinning
character animation, instancing,

00:14:46.256 --> 00:14:48.656 A:middle
pretty much it's whatever
you want to use it for.

00:14:49.146 --> 00:14:52.836 A:middle
So we have a shader
example here.

00:14:53.296 --> 00:14:59.196 A:middle
And what a UBO is, is it's
basically a uniform buffer

00:14:59.196 --> 00:15:05.006 A:middle
object is a CSTRUCK like layout
defined interface where we're --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.196 --> 00:15:05.006 A:middle
object is a CSTRUCK like layout
defined interface where we're --

00:15:05.006 --> 00:15:07.926 A:middle
we have here of the
layout one standard 140

00:15:07.966 --> 00:15:12.886 A:middle
which is the defining --
which defines how our vectors

00:15:12.886 --> 00:15:15.876 A:middle
and variables are packed.

00:15:15.876 --> 00:15:18.366 A:middle
And we've called
this uniform MyUBO.

00:15:18.366 --> 00:15:24.166 A:middle
And so this MyUBO which we named
MyBlock underneath we're able

00:15:24.446 --> 00:15:27.916 A:middle
to access that from
our shader similar

00:15:27.916 --> 00:15:30.026 A:middle
to how the CSTRUCK would work.

00:15:31.356 --> 00:15:32.526 A:middle
Pretty straight forward.

00:15:33.876 --> 00:15:35.026 A:middle
And for setting that up

00:15:35.026 --> 00:15:38.896 A:middle
in the API we would have
just created a buffer object

00:15:38.896 --> 00:15:42.526 A:middle
of type uniform buffer,
set up the size of that

00:15:43.016 --> 00:15:45.126 A:middle
and then we have to
get the location.

00:15:45.126 --> 00:15:47.926 A:middle
Instead of the get uniform
location we're getting uniform

00:15:47.926 --> 00:15:51.866 A:middle
block index for this UBO
structure and of type MyUBO.

00:15:51.966 --> 00:15:55.066 A:middle
And then we just bind that
to one of our binding indexes

00:15:55.066 --> 00:16:00.296 A:middle
that we have for making -- for
knowing how to provide that data

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:55.066 --> 00:16:00.296 A:middle
that we have for making -- for
knowing how to provide that data

00:16:00.606 --> 00:16:04.776 A:middle
to the proper UBO in the shader.

00:16:05.016 --> 00:16:10.996 A:middle
So in summary you can upload all
of your uniform values at once.

00:16:11.096 --> 00:16:14.266 A:middle
The -- however you want to make
sure that you're making sure

00:16:14.636 --> 00:16:20.956 A:middle
that you're not modifying
your UBOs every single time.

00:16:20.956 --> 00:16:24.096 A:middle
So if you have for
instance some variables

00:16:24.096 --> 00:16:26.406 A:middle
that you're updating
a lot more often

00:16:26.406 --> 00:16:29.846 A:middle
than other variables you should
split those into two UBOs.

00:16:29.846 --> 00:16:31.396 A:middle
So one of your UBOs
may be static,

00:16:31.836 --> 00:16:33.816 A:middle
and another may be
updated once a frame.

00:16:34.466 --> 00:16:38.536 A:middle
And then additionally
if you are trying

00:16:38.536 --> 00:16:41.246 A:middle
to modify the data
even more often

00:16:41.246 --> 00:16:43.926 A:middle
than that you could
orphan your buffer objects

00:16:43.926 --> 00:16:45.556 A:middle
by calling buffer data
with a null pointer,

00:16:46.576 --> 00:16:47.896 A:middle
or you could just double buffer,

00:16:47.896 --> 00:16:50.826 A:middle
or triple buffer etcetera your
UBOs to ensure that you're able

00:16:50.826 --> 00:16:52.426 A:middle
to pass data to the GPU

00:16:52.706 --> 00:16:55.516 A:middle
and still modify something
one the CPU to pass

00:16:55.516 --> 00:16:58.426 A:middle
that for the next call
that the GPU will execute.

00:16:59.646 --> 00:17:03.896 A:middle
And one key point I want to
make note of is that each

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.646 --> 00:17:03.896 A:middle
And one key point I want to
make note of is that each

00:17:03.896 --> 00:17:08.806 A:middle
of the UBOs are limited
to a size of about 64KB.

00:17:10.925 --> 00:17:14.486 A:middle
So as an alternative to
UBOs there's also texture

00:17:14.486 --> 00:17:15.256 A:middle
buffer objects.

00:17:16.336 --> 00:17:20.406 A:middle
And texture buffer objects is
a buffer object that allows you

00:17:20.406 --> 00:17:24.336 A:middle
to store a 1D array
of data as texels.

00:17:25.296 --> 00:17:29.266 A:middle
And again like all buffer
objects it gives you

00:17:29.706 --> 00:17:36.536 A:middle
to GPU generated data and beyond
UBOs it also gives you access

00:17:36.656 --> 00:17:38.476 A:middle
to a large amount of
data within a shader.

00:17:38.986 --> 00:17:40.616 A:middle
So you can have a
very large UBO.

00:17:41.516 --> 00:17:43.836 A:middle
And additionally it uses --

00:17:43.836 --> 00:17:46.136 A:middle
it takes advantage of
the GPUs texture cache.

00:17:47.066 --> 00:17:51.676 A:middle
So just like TBOs -- just
like UBOs, TBOs are also used

00:17:51.676 --> 00:17:54.816 A:middle
for skinning, character
animation, instancing,

00:17:55.436 --> 00:17:57.696 A:middle
whatever you want to be
using it with really.

00:17:58.806 --> 00:18:01.396 A:middle
And here's an example
shader that's using TBO.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.806 --> 00:18:01.396 A:middle
And here's an example
shader that's using TBO.

00:18:01.506 --> 00:18:04.386 A:middle
So we basically have
a new sampler type.

00:18:04.786 --> 00:18:06.056 A:middle
Here we have samplerBuffer.

00:18:06.486 --> 00:18:09.166 A:middle
There's also like
isampleBuffer, usampleBuffer.

00:18:09.856 --> 00:18:13.086 A:middle
And we're naming our texture
buffer object reference myTBO.

00:18:14.086 --> 00:18:17.036 A:middle
And it's as simple as just
doing a texelFetch from it.

00:18:17.796 --> 00:18:20.456 A:middle
Passing our offset into there.

00:18:20.766 --> 00:18:25.526 A:middle
And since this really is just
raw data I modified the shader

00:18:25.526 --> 00:18:28.556 A:middle
now to read back four
values from texelFetch

00:18:28.976 --> 00:18:35.146 A:middle
and a result I'm able to with
a single texture sampler --

00:18:35.146 --> 00:18:37.386 A:middle
texture object I'm able

00:18:37.386 --> 00:18:38.846 A:middle
to actually read
back the equivalent

00:18:38.846 --> 00:18:40.046 A:middle
of what would have had to do

00:18:40.046 --> 00:18:41.686 A:middle
with four vertex
attributes before.

00:18:42.426 --> 00:18:46.286 A:middle
So in the API to set this

00:18:46.286 --> 00:18:48.826 A:middle
up we're just making again
a texture buffer object,

00:18:48.826 --> 00:18:51.546 A:middle
a buffer object as
you normally would.

00:18:52.506 --> 00:18:57.616 A:middle
And then setting it up similar
to a texture where we're going

00:18:57.686 --> 00:19:00.226 A:middle
to attach that buffer object

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.686 --> 00:19:00.226 A:middle
to attach that buffer object

00:19:00.376 --> 00:19:05.766 A:middle
to the texture object using Tex
buffer and we're specifying here

00:19:06.276 --> 00:19:08.026 A:middle
that it's a type RGBA32F.

00:19:08.886 --> 00:19:13.576 A:middle
But you can use whatever format
you want that's supported

00:19:13.576 --> 00:19:14.236 A:middle
by textures.

00:19:14.236 --> 00:19:17.266 A:middle
And then finally we do get
the uniform location for it

00:19:17.266 --> 00:19:21.866 A:middle
and send it just like a
texture sampler would be set up.

00:19:22.066 --> 00:19:24.466 A:middle
So it gives you access
to a lot more data

00:19:25.266 --> 00:19:30.826 A:middle
than you would have gotten
64MB or more with a UBO.

00:19:31.596 --> 00:19:35.446 A:middle
And it's very useful
for instancing

00:19:35.446 --> 00:19:37.336 A:middle
where you do have a lot of
data that you need to pass

00:19:37.396 --> 00:19:38.716 A:middle
down that you may
not have been able

00:19:38.846 --> 00:19:41.066 A:middle
to have enough vertex
attributes for

00:19:41.626 --> 00:19:45.446 A:middle
or any complicated
things like that.

00:19:45.506 --> 00:19:48.646 A:middle
And again just like
UBOs and buffer objects

00:19:48.646 --> 00:19:50.696 A:middle
in general try not to use --

00:19:51.006 --> 00:19:53.626 A:middle
try not to modify a TBO
while it's being used

00:19:53.626 --> 00:19:54.896 A:middle
to draw on the GPU.

00:19:55.226 --> 00:19:58.546 A:middle
So again double buffering,
orphaning that --

00:19:58.546 --> 00:20:02.796 A:middle
those TBOs will help you ensure
you're not stalling your CPU

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.546 --> 00:20:02.796 A:middle
those TBOs will help you ensure
you're not stalling your CPU

00:20:02.796 --> 00:20:04.476 A:middle
waiting for the GPU
to complete its work.

00:20:06.536 --> 00:20:11.286 A:middle
So another feature that's new
in Mavericks is draw indirect.

00:20:12.756 --> 00:20:16.026 A:middle
And draw indirect allows
you to specify the arguments

00:20:16.026 --> 00:20:18.896 A:middle
to your draw calls
from a buffer object.

00:20:19.396 --> 00:20:22.996 A:middle
So for instance normally a
draw raise will take a count

00:20:22.996 --> 00:20:24.846 A:middle
and then there's
draw raise instance

00:20:24.886 --> 00:20:26.296 A:middle
where you have an instanceCount.

00:20:26.816 --> 00:20:29.026 A:middle
And you also specify
first, baseVertex.

00:20:29.536 --> 00:20:31.116 A:middle
I'll show you an
example in a second.

00:20:31.966 --> 00:20:34.106 A:middle
So when you've generated
data for instance

00:20:34.156 --> 00:20:36.156 A:middle
with OpenCL no longer
do you need

00:20:36.156 --> 00:20:39.406 A:middle
to know how many vertices
you may have generated there.

00:20:39.766 --> 00:20:44.766 A:middle
So in those cases you'll be
able to find the buffer object

00:20:44.766 --> 00:20:48.366 A:middle
as a draw underscore indirect
buffer and avoid that round trip

00:20:48.956 --> 00:20:52.706 A:middle
of having to otherwise read back
what those variables should have

00:20:52.706 --> 00:20:55.686 A:middle
been that you were going to
pass into your draw call.

00:20:56.026 --> 00:20:58.426 A:middle
And this is similar to
tessellation shaders.

00:20:58.426 --> 00:21:03.166 A:middle
It's available on all
modern hardware and it's --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:58.426 --> 00:21:03.166 A:middle
It's available on all
modern hardware and it's --

00:21:03.166 --> 00:21:04.866 A:middle
so check for the
extension string

00:21:04.866 --> 00:21:08.246 A:middle
with glGetStringi using GL
underscore ARB underscore draw

00:21:08.246 --> 00:21:10.116 A:middle
underscore indirect.

00:21:10.546 --> 00:21:13.126 A:middle
So here's an example of
using DrawArrays Indirect.

00:21:14.096 --> 00:21:15.306 A:middle
First I've got a comment

00:21:15.306 --> 00:21:19.546 A:middle
at the top showing the general
structure of what I need

00:21:19.546 --> 00:21:22.496 A:middle
to be outputting into this
buffer object in order to ensure

00:21:22.496 --> 00:21:25.766 A:middle
that the GPU is able to know
what those arguments are.

00:21:26.076 --> 00:21:27.196 A:middle
So we're going to match this.

00:21:27.196 --> 00:21:30.016 A:middle
It's got a count, and
instanceCount and a first

00:21:30.016 --> 00:21:32.106 A:middle
because we're going to be
calling DrawArrays instance

00:21:32.696 --> 00:21:37.236 A:middle
and then finally a
reservedMustBeZero variable

00:21:37.326 --> 00:21:38.236 A:middle
after that.

00:21:39.096 --> 00:21:42.406 A:middle
So we would -- so first we
generate our data with OpenCL

00:21:42.566 --> 00:21:45.086 A:middle
and write into our
indirect buffer object.

00:21:45.486 --> 00:21:49.056 A:middle
And then in OpenGL
we're going to bind

00:21:49.056 --> 00:21:52.206 A:middle
to that indirect buffer object
and then we're always going

00:21:52.206 --> 00:21:55.326 A:middle
to setup all our vertex
attribute pointers and --

00:21:56.006 --> 00:21:58.766 A:middle
with our BindVertexArray call.

00:21:58.766 --> 00:22:01.766 A:middle
And then finally just
call draw indirect.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:58.766 --> 00:22:01.766 A:middle
And then finally just
call draw indirect.

00:22:01.766 --> 00:22:02.806 A:middle
And it still takes a mode

00:22:03.976 --> 00:22:07.476 A:middle
so you're still saying GL
underscore TRIANGLES, glPoints,

00:22:07.476 --> 00:22:09.036 A:middle
whatever you're using.

00:22:09.366 --> 00:22:11.906 A:middle
And then the indirect
offset -- you take --

00:22:11.906 --> 00:22:15.286 A:middle
you pass in an offset of
your indirect buffer object.

00:22:15.286 --> 00:22:17.306 A:middle
So where you put
that data, the count,

00:22:17.436 --> 00:22:21.496 A:middle
the instanceCount,
and the first.

00:22:21.926 --> 00:22:23.316 A:middle
DrawElements, very similar.

00:22:23.736 --> 00:22:25.466 A:middle
I've highlighted
what's different here.

00:22:25.466 --> 00:22:27.826 A:middle
We've got a firstIndex
instead of a first

00:22:27.826 --> 00:22:31.346 A:middle
and then additionally we have
a baseVertex offset for each

00:22:31.346 --> 00:22:34.116 A:middle
of the elements in
your element array.

00:22:34.776 --> 00:22:40.616 A:middle
And then -- so we've created our
data using OpenCL and OpenGL.

00:22:40.616 --> 00:22:42.286 A:middle
We then bind that --

00:22:42.286 --> 00:22:45.366 A:middle
the location of that
indirect buffer,

00:22:46.006 --> 00:22:49.036 A:middle
what buffer we were
writing into.

00:22:49.666 --> 00:22:51.426 A:middle
Again we bind the
vertex array objects

00:22:51.426 --> 00:22:53.296 A:middle
so we have all the
vertex attributes setup

00:22:53.636 --> 00:22:56.826 A:middle
and then we are additionally
going to have

00:22:56.976 --> 00:22:58.676 A:middle
to set our buffer point

00:22:58.966 --> 00:23:01.676 A:middle
for where the elements
are going to read out of.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.966 --> 00:23:01.676 A:middle
for where the elements
are going to read out of.

00:23:02.196 --> 00:23:03.656 A:middle
So we're also doing
that binding.

00:23:04.126 --> 00:23:09.076 A:middle
And then finally we call
DrawElementsIndirect and this --

00:23:09.246 --> 00:23:11.646 A:middle
instead of passing down
the node, the counts,

00:23:12.456 --> 00:23:15.836 A:middle
and the instanceCount
and the baseVertex

00:23:16.346 --> 00:23:18.156 A:middle
and firstIndex that's
all being read

00:23:18.156 --> 00:23:20.006 A:middle
out of your indirect
buffer object.

00:23:20.606 --> 00:23:22.606 A:middle
And instead we only have
to pass down the mode

00:23:22.606 --> 00:23:24.236 A:middle
like GL underscore
TRIANGLES again

00:23:24.736 --> 00:23:27.846 A:middle
and the element type
saying that our elements

00:23:28.206 --> 00:23:31.916 A:middle
in the element array buffer
are type unsigned int,

00:23:32.136 --> 00:23:35.856 A:middle
unsigned short, whatever you
may want to be using there.

00:23:36.526 --> 00:23:40.116 A:middle
So let's go over just
a few more extensions.

00:23:41.036 --> 00:23:43.896 A:middle
We've got some new
extensions here.

00:23:43.896 --> 00:23:46.636 A:middle
Separate shader objects
available

00:23:46.636 --> 00:23:48.216 A:middle
on all hardware on Mavericks.

00:23:48.596 --> 00:23:51.846 A:middle
It enables you to mix and
match your GLSL shaders.

00:23:52.196 --> 00:23:54.186 A:middle
So if you have one vertex
shader that you're using

00:23:54.186 --> 00:23:58.026 A:middle
with five fragment shaders no
longer do you have to recompile

00:23:58.026 --> 00:24:01.546 A:middle
that vertex shader five
times to be used with the --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.026 --> 00:24:01.546 A:middle
that vertex shader five
times to be used with the --

00:24:01.546 --> 00:24:06.616 A:middle
you don't have to link --
you can link really quickly.

00:24:06.616 --> 00:24:08.476 A:middle
You don't have to redo that work

00:24:08.476 --> 00:24:11.396 A:middle
for that vertex shader five
times in order to use it

00:24:11.396 --> 00:24:12.706 A:middle
with five fragment shaders.

00:24:12.706 --> 00:24:16.386 A:middle
Instead you just create that
program once and then link it

00:24:16.386 --> 00:24:18.576 A:middle
with all five of those
shaders pretty easily.

00:24:19.126 --> 00:24:22.476 A:middle
Additionally we've
got ES2 compatibility

00:24:22.886 --> 00:24:26.886 A:middle
and this is probably interesting
if you have an iOS application

00:24:26.886 --> 00:24:28.146 A:middle
that you're trying
to port to OS X.

00:24:28.886 --> 00:24:33.226 A:middle
It allows you to use version
100 of GLSL on the desktop.

00:24:33.726 --> 00:24:36.406 A:middle
So on OS X.

00:24:36.656 --> 00:24:38.956 A:middle
However, you are limited
to the functionality

00:24:38.956 --> 00:24:41.456 A:middle
that GLSL 100 specifies.

00:24:41.456 --> 00:24:43.936 A:middle
So you aren't able for
instance to take advantage

00:24:43.936 --> 00:24:45.216 A:middle
of tessellation shaders

00:24:45.556 --> 00:24:48.766 A:middle
if you'll be using
this version of GLSL.

00:24:50.306 --> 00:24:54.846 A:middle
Another nifty new extension in
Mavericks is NV Texture Barrier

00:24:55.206 --> 00:24:57.646 A:middle
and it allows you to
bind the same textures,

00:24:57.646 --> 00:25:00.166 A:middle
both the rendered target
and the texture source.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.646 --> 00:25:00.166 A:middle
both the rendered target
and the texture source.

00:25:00.616 --> 00:25:02.406 A:middle
So now if you have --

00:25:02.966 --> 00:25:06.436 A:middle
it's similar to Apple Frame
Buffer Shader Fetch --

00:25:06.796 --> 00:25:08.696 A:middle
Shader Frame Buffer Fetch on iOS

00:25:09.176 --> 00:25:10.726 A:middle
where you can do
programmable blending there.

00:25:10.996 --> 00:25:14.376 A:middle
However, this is limited to
cases where there is no overlap

00:25:14.416 --> 00:25:17.076 A:middle
between a single draw call
where your depth complexity

00:25:17.076 --> 00:25:18.016 A:middle
of your scenes is one.

00:25:18.576 --> 00:25:21.076 A:middle
So basically it saves
you a little bit of vRAM

00:25:21.716 --> 00:25:25.246 A:middle
and not having to create a copy
of your texture if you're trying

00:25:25.306 --> 00:25:28.456 A:middle
to do ping pong back and forth
between two buffer objects.

00:25:28.736 --> 00:25:31.006 A:middle
You might be able to
update your application

00:25:31.456 --> 00:25:33.256 A:middle
to just render right
back into itself

00:25:33.826 --> 00:25:37.426 A:middle
and use itself as
a texture source.

00:25:37.426 --> 00:25:39.516 A:middle
And then additionally
we actually added

00:25:39.516 --> 00:25:44.036 A:middle
in 10.8.3 our texture swizzle,
and this is a heavy extension

00:25:44.076 --> 00:25:47.926 A:middle
for supporting older
applications

00:25:47.926 --> 00:25:49.196 A:middle
which might have
been using a format

00:25:49.196 --> 00:25:50.286 A:middle
like GL underscore LUMINANCE.

00:25:50.776 --> 00:25:53.416 A:middle
And so instead of having to
modify all of your shaders

00:25:53.416 --> 00:25:55.666 A:middle
to be able to take in RGBA data

00:25:55.666 --> 00:25:58.896 A:middle
and LUMINANCE data you
can specify up front

00:25:58.896 --> 00:26:00.336 A:middle
that LUNINANCE should
be interpreted

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.896 --> 00:26:00.336 A:middle
that LUNINANCE should
be interpreted

00:26:00.336 --> 00:26:02.766 A:middle
as red, red, red one.

00:26:03.566 --> 00:26:06.396 A:middle
Or LUMINANCE Alpha would
be red, red, red, green;

00:26:06.446 --> 00:26:09.336 A:middle
a red green texture passing
out and trying to pretend

00:26:09.336 --> 00:26:10.376 A:middle
that it's LUMINANCE Alpha.

00:26:11.086 --> 00:26:15.956 A:middle
So those are the
features that --

00:26:15.956 --> 00:26:18.876 A:middle
some of the features in
Mavericks that I wanted to go

00:26:18.876 --> 00:26:23.456 A:middle
over and now I wanted
to go into using OpenCL

00:26:24.166 --> 00:26:30.116 A:middle
as a compute for with Open GL.

00:26:30.616 --> 00:26:35.596 A:middle
So OpenGL and OpenCL on our
platform were created together

00:26:35.596 --> 00:26:40.246 A:middle
and use the same infrastructure
in order to talk to the GPUs.

00:26:40.246 --> 00:26:44.336 A:middle
And as a result of that
cooperation you're able

00:26:44.336 --> 00:26:47.546 A:middle
to be able to share things
like buffers, objects,

00:26:47.916 --> 00:26:51.536 A:middle
textures between
OpenGL and OpenCL.

00:26:51.866 --> 00:26:55.166 A:middle
There's no need for any reading
back data and then put it back

00:26:55.166 --> 00:26:57.456 A:middle
up just to switch between APIs.

00:26:57.976 --> 00:27:00.356 A:middle
It's a very simple integration
into your render loop

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:57.976 --> 00:27:00.356 A:middle
It's a very simple integration
into your render loop

00:27:00.446 --> 00:27:04.786 A:middle
and I'm going to go
into that right now.

00:27:05.006 --> 00:27:08.096 A:middle
So some of the use
cases for Compute.

00:27:08.516 --> 00:27:12.146 A:middle
We may use OpenCL here,
for instance, to generate

00:27:12.146 --> 00:27:13.486 A:middle
or modify geometry data.

00:27:13.486 --> 00:27:17.986 A:middle
So I'm going to go into
generating a tea pot in OpenCL

00:27:17.986 --> 00:27:19.646 A:middle
and drawing that in OpenGL.

00:27:20.646 --> 00:27:24.826 A:middle
Also I got to go in after that
to post-processing an image

00:27:24.826 --> 00:27:29.406 A:middle
that you may have generated with
OpenGL and then displaying that.

00:27:31.386 --> 00:27:33.836 A:middle
So first starting out
with filling up the VBO

00:27:33.836 --> 00:27:36.236 A:middle
with vertex data using OpenCL,

00:27:36.636 --> 00:27:37.836 A:middle
and then rendering
that with OpenGL.

00:27:37.836 --> 00:27:43.136 A:middle
We're going to have our one time
setup of setting up our OpenGL

00:27:43.136 --> 00:27:45.376 A:middle
and OpenCL context to share.

00:27:45.876 --> 00:27:49.076 A:middle
And then we create that
vertex buffer object in OpenGL

00:27:49.626 --> 00:27:52.986 A:middle
and we'll specify that we can
share that object in OpenCL

00:27:52.986 --> 00:27:54.116 A:middle
in order to fill it in there.

00:27:54.266 --> 00:27:59.416 A:middle
And then every frame enqueue our
CL command in order to create

00:27:59.416 --> 00:28:02.456 A:middle
that -- the data that
goes into that VBO.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.416 --> 00:28:02.456 A:middle
that -- the data that
goes into that VBO.

00:28:02.806 --> 00:28:09.106 A:middle
Then after that we'll flush the
CL enqueued commands in order

00:28:09.106 --> 00:28:11.766 A:middle
to ensure that when we
use that data with OpenGL

00:28:11.766 --> 00:28:15.836 A:middle
that it's now been pushed
to the GPU to be filled

00:28:15.836 --> 00:28:18.536 A:middle
in so it won't -- so
you're not using your --

00:28:19.396 --> 00:28:21.556 A:middle
you're not using data that
has not yet been specified.

00:28:22.526 --> 00:28:24.966 A:middle
So after that's been done
you just draw it with OpenGL.

00:28:24.966 --> 00:28:29.946 A:middle
So let's start out looking
a little bit closer at that.

00:28:30.376 --> 00:28:33.186 A:middle
So first we're going to
create our OpenGL context

00:28:33.736 --> 00:28:38.726 A:middle
and we're setting up the
pixel format for NSOpenGL

00:28:39.606 --> 00:28:43.856 A:middle
and here we're adding a new
PFA, pixel format attribute

00:28:43.856 --> 00:28:47.396 A:middle
of
NSOpenGLPFAAcceleratedCompute.

00:28:47.466 --> 00:28:51.276 A:middle
And that specifies that I
want to have an OpenGL context

00:28:51.276 --> 00:28:57.046 A:middle
that is capable of accessing the
GPUs that have OpenCL support.

00:28:58.996 --> 00:29:00.786 A:middle
Then after I've created our --

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:58.996 --> 00:29:00.786 A:middle
Then after I've created our --

00:29:00.976 --> 00:29:04.916 A:middle
my context I'm going to get the
share group from that context

00:29:06.006 --> 00:29:09.376 A:middle
and with that share group I
can use the CL APIs in order

00:29:09.456 --> 00:29:16.256 A:middle
to get the -- in order to get
the matching CL device IDs

00:29:16.816 --> 00:29:20.956 A:middle
that will match up with my
OpenGL virtual screen list

00:29:21.436 --> 00:29:23.976 A:middle
and so I'll be able to share
between these two contexts.

00:29:25.086 --> 00:29:28.896 A:middle
And then I'll create my
context from that CL device list

00:29:30.036 --> 00:29:33.076 A:middle
and then back in OpenGL
we're going to be creating --

00:29:33.226 --> 00:29:36.776 A:middle
or creating a vertex buffer
object here to be able to fill

00:29:36.776 --> 00:29:42.826 A:middle
in and fill in with the tea pot.

00:29:42.826 --> 00:29:48.076 A:middle
Specify the size, we're going
to flush that to the GPU

00:29:49.006 --> 00:29:52.146 A:middle
and then we just use this API
[inaudible] from GL buffer,

00:29:52.466 --> 00:29:55.846 A:middle
and now we have a CL mem object
that points exactly to where

00:29:56.116 --> 00:29:58.486 A:middle
that VBO in OpenGL is.

00:29:59.176 --> 00:30:00.246 A:middle
So that's a onetime set up.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.176 --> 00:30:00.246 A:middle
So that's a onetime set up.

00:30:00.246 --> 00:30:04.746 A:middle
And then every time we're going
to be drawing you can check

00:30:04.746 --> 00:30:07.456 A:middle
for the CL/GL DEVICE underscore

00:30:07.456 --> 00:30:11.116 A:middle
FOR underscore CURRENT
underscore VS underscore APPLE,

00:30:11.116 --> 00:30:11.726 A:middle
didn't quite fit there.

00:30:11.726 --> 00:30:14.276 A:middle
So by using -- by looking
that up you can look

00:30:14.276 --> 00:30:17.696 A:middle
at what virtual screen
OpenGL is currently using

00:30:18.526 --> 00:30:20.236 A:middle
in order to do its rendering.

00:30:20.766 --> 00:30:24.206 A:middle
So if you do have say
multiple GPUs in your system

00:30:24.536 --> 00:30:29.186 A:middle
in this case I'm using this
query in order to check

00:30:29.496 --> 00:30:33.206 A:middle
which GPU OpenGL is on and
I'm having OpenCL follow it

00:30:33.756 --> 00:30:36.536 A:middle
so that it can do its
computations and not have

00:30:36.576 --> 00:30:40.216 A:middle
to copy back to the
other GPU any of the data

00:30:40.216 --> 00:30:41.276 A:middle
that I'm going to
be creating here.

00:30:41.976 --> 00:30:45.956 A:middle
so I've not picked the CL device
ID that I want to submit my data

00:30:45.956 --> 00:30:50.266 A:middle
to and I enqueue a OpenCL kernel

00:30:51.396 --> 00:30:54.566 A:middle
and this OpenCL kernel will
be generating our vertex data

00:30:54.566 --> 00:30:57.966 A:middle
that we're going to then
consume with OpenGL.

00:30:59.676 --> 00:31:03.976 A:middle
So after that's been done
we flush that to the GPU.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.676 --> 00:31:03.976 A:middle
So after that's been done
we flush that to the GPU.

00:31:04.046 --> 00:31:05.946 A:middle
The GPU starts creating
this data for us,

00:31:06.786 --> 00:31:09.106 A:middle
and I have a barrier
here just to say

00:31:09.106 --> 00:31:11.676 A:middle
that if you are doing some
more complicated things,

00:31:12.216 --> 00:31:16.846 A:middle
if you're doing some threading
and doing things in OpenGL

00:31:16.846 --> 00:31:19.586 A:middle
and OpenCL that may
not be interacting

00:31:19.586 --> 00:31:23.156 A:middle
with each other you can continue
doing some of that work in the

00:31:23.696 --> 00:31:26.386 A:middle
in between time but
you need to make sure

00:31:26.386 --> 00:31:29.436 A:middle
that this flush here
is done before we try

00:31:29.436 --> 00:31:30.546 A:middle
to use that data in OpenGL.

00:31:30.546 --> 00:31:34.486 A:middle
So we're using here the new
function GL DrawElements

00:31:34.486 --> 00:31:39.206 A:middle
and Direct and that allowed
us to draw this tea pot

00:31:39.626 --> 00:31:42.226 A:middle
without even knowing how
many vertices were in remodel

00:31:42.516 --> 00:31:46.416 A:middle
and so that's how you get
a vertex buffer object

00:31:46.616 --> 00:31:47.316 A:middle
from OpenCL.

00:31:48.946 --> 00:31:50.366 A:middle
So the opposite is also true --

00:31:50.366 --> 00:31:52.646 A:middle
or not the opposite
but the other side

00:31:52.706 --> 00:31:57.966 A:middle
of the pipeline you can do image
processing and well with OpenCL.

00:31:58.746 --> 00:32:03.606 A:middle
So for this case we have
similar onetime setup.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.746 --> 00:32:03.606 A:middle
So for this case we have
similar onetime setup.

00:32:03.606 --> 00:32:05.096 A:middle
We're going to setup
OpenGL and OpenCL

00:32:05.096 --> 00:32:06.476 A:middle
to share just like
we did before.

00:32:07.206 --> 00:32:09.746 A:middle
However this time, we're going
to create a texture object

00:32:09.746 --> 00:32:12.396 A:middle
and share that between
OpenGL and OpenCL.

00:32:13.546 --> 00:32:16.786 A:middle
And so every time --
every frame that we want

00:32:16.786 --> 00:32:20.176 A:middle
to do this post-processing will
draw that texture using OpenGL,

00:32:20.976 --> 00:32:23.536 A:middle
flush OpenGL's command buffer

00:32:23.916 --> 00:32:27.886 A:middle
to the GPU calling
glFlushRenderApple and then,

00:32:28.406 --> 00:32:31.276 A:middle
in OpenCL we can
enqueue the commands

00:32:31.406 --> 00:32:33.426 A:middle
to process that texture.

00:32:34.336 --> 00:32:36.916 A:middle
And then finally if you
want to display that back

00:32:36.916 --> 00:32:39.916 A:middle
on the screen you're going
to flush the OpenCL commands

00:32:40.596 --> 00:32:43.456 A:middle
and then you can blip or
swap back to the screen.

00:32:44.276 --> 00:32:50.856 A:middle
So here we're again, picking
a pixel format that has access

00:32:50.966 --> 00:32:54.746 A:middle
to the GPUs which have Compute
capabilities with OpenCL.

00:32:56.236 --> 00:32:58.836 A:middle
We get the share group
form which we're going

00:32:58.926 --> 00:33:03.576 A:middle
to get CL device IDs that match
up with the OpenGL context

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:58.926 --> 00:33:03.576 A:middle
to get CL device IDs that match
up with the OpenGL context

00:33:03.576 --> 00:33:07.326 A:middle
that we've created and
then we'll create a context

00:33:07.326 --> 00:33:07.716 A:middle
from that.

00:33:09.066 --> 00:33:11.776 A:middle
And this time we have a texture
that we're going to be sharing

00:33:12.206 --> 00:33:14.676 A:middle
with OpenCL so we'll
bind to that texture,

00:33:15.106 --> 00:33:17.926 A:middle
setup how big it is to
store using techImage 2D.

00:33:19.426 --> 00:33:21.476 A:middle
And then FlushRenderApple --

00:33:22.056 --> 00:33:25.966 A:middle
and after which you can
create a CL meme object

00:33:25.966 --> 00:33:27.096 A:middle
from that GL texture.

00:33:27.826 --> 00:33:32.256 A:middle
So now every frame
we're going to be doing

00:33:32.256 --> 00:33:33.606 A:middle
or normal drawing in OpenGL.

00:33:33.606 --> 00:33:36.616 A:middle
We'll render to the
texture say DrawElements

00:33:37.066 --> 00:33:39.096 A:middle
and other OpenGL draw calls.

00:33:40.366 --> 00:33:45.296 A:middle
We'll then flush that data to
the GPU to start processing it.

00:33:45.606 --> 00:33:46.906 A:middle
We happen to be drawing
the tea pot

00:33:46.906 --> 00:33:48.456 A:middle
that we've already
done with OpenCL here.

00:33:49.776 --> 00:33:51.146 A:middle
Again the barrier.

00:33:51.346 --> 00:33:54.286 A:middle
So after that FlushRenderApple
and only

00:33:54.286 --> 00:33:56.616 A:middle
after that FlushRenderApple
should you start doing your work

00:33:56.616 --> 00:34:00.816 A:middle
in OpenCL that depends on
the results of the draw calls

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:56.616 --> 00:34:00.816 A:middle
in OpenCL that depends on
the results of the draw calls

00:34:01.226 --> 00:34:03.246 A:middle
that were modifying that
texture that we're sharing.

00:34:04.196 --> 00:34:05.926 A:middle
So here again we're
going to check

00:34:06.306 --> 00:34:09.235 A:middle
which virtual screen
OpenGL is on,

00:34:09.235 --> 00:34:11.386 A:middle
and match the CL
device ID there.

00:34:11.386 --> 00:34:14.906 A:middle
So OpenCL is generating
the data on the same GPU

00:34:14.906 --> 00:34:19.376 A:middle
that OpenGL created
that data in.

00:34:20.096 --> 00:34:24.826 A:middle
And then we're going to enqueue
our post-process kernel there

00:34:25.196 --> 00:34:29.926 A:middle
and do our calculations such as
like edge detection or blurring.

00:34:30.826 --> 00:34:34.536 A:middle
And then finally if we
want to pass that data back

00:34:34.536 --> 00:34:37.826 A:middle
to GL we're going to flush
that results using CLFlush

00:34:38.966 --> 00:34:42.326 A:middle
and in OpenGL we'll then be able
to just bind to that texture

00:34:42.876 --> 00:34:46.085 A:middle
and blip it to the
screen if we want to.

00:34:47.315 --> 00:34:52.746 A:middle
So that's passing data back and
forth between OpenGL and OpenCL.

00:34:52.906 --> 00:34:55.126 A:middle
You get best of both worlds.

00:34:55.126 --> 00:34:59.036 A:middle
You a graphics API with
full Compute capabilities

00:34:59.336 --> 00:35:05.066 A:middle
and just sharing in between
with very little cost.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.336 --> 00:35:05.066 A:middle
and just sharing in between
with very little cost.

00:35:05.066 --> 00:35:08.536 A:middle
And it's -- additionally
wanted to reiterate

00:35:08.536 --> 00:35:11.016 A:middle
that if you are creating data
but you don't know how big it is

00:35:11.456 --> 00:35:14.966 A:middle
for vertex geometry then
it's great for using

00:35:14.966 --> 00:35:17.436 A:middle
with ARB underscore Draw
underscore Indirect.

00:35:18.456 --> 00:35:22.246 A:middle
And after this talk
we're going to be talking

00:35:22.246 --> 00:35:24.716 A:middle
about OpenCL actually
and how to use

00:35:24.716 --> 00:35:28.566 A:middle
that a little bit more
explicitly and even going

00:35:28.566 --> 00:35:31.166 A:middle
into some OpenGL/OpenCL
sharing there, as well.

00:35:31.676 --> 00:35:34.506 A:middle
So if you're not familiar with
OpenCL yet and you are hoping

00:35:34.506 --> 00:35:37.896 A:middle
to do Compute in your projects
I recommend you stay right

00:35:37.896 --> 00:35:40.386 A:middle
after for that talk.

00:35:40.986 --> 00:35:47.486 A:middle
So we've gone over Compute
so let's now talk about how

00:35:47.486 --> 00:35:51.486 A:middle
to get your context into
Core Profile in order

00:35:51.486 --> 00:35:53.326 A:middle
to take advantage of
all these new features

00:35:53.326 --> 00:35:57.876 A:middle
that we're supporting
in Mavericks.

00:35:57.996 --> 00:36:02.826 A:middle
So first to start out OpenGL
Core Profile is a profile

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:57.996 --> 00:36:02.826 A:middle
So first to start out OpenGL
Core Profile is a profile

00:36:02.826 --> 00:36:05.726 A:middle
that gives you access to
the latest GPU features.

00:36:06.366 --> 00:36:10.116 A:middle
The API -- I don't
know if you're familiar

00:36:10.406 --> 00:36:12.306 A:middle
with OpenGL ES2 versus
OpenGL ES1.

00:36:12.566 --> 00:36:16.246 A:middle
It's very akin to that
transition where the -- we --

00:36:16.246 --> 00:36:20.676 A:middle
the API was trimmed down to be
streamlined and high-performance

00:36:20.986 --> 00:36:25.186 A:middle
and it's more in tune with
how the GPU actually works.

00:36:25.326 --> 00:36:28.036 A:middle
So there's no matrix
math or things

00:36:28.036 --> 00:36:30.026 A:middle
that the GPU wouldn't
have actually been doing

00:36:30.026 --> 00:36:30.866 A:middle
in the first place.

00:36:31.496 --> 00:36:33.166 A:middle
And it gives you
the full control

00:36:33.166 --> 00:36:34.666 A:middle
over the rendering pipeline

00:36:34.776 --> 00:36:37.176 A:middle
so we're specifying
everything as shaders.

00:36:37.846 --> 00:36:42.596 A:middle
And similar -- I was saying it's
similar to OpenGL ES2 actually

00:36:42.596 --> 00:36:45.796 A:middle
so much so that it's pretty
easy to port back and forth

00:36:45.796 --> 00:36:49.166 A:middle
between OpenGL ES2 and
OpenGL Core Profile.

00:36:49.646 --> 00:36:54.986 A:middle
So let's go over conceptual
overview of what you're going

00:36:54.986 --> 00:36:57.266 A:middle
to need to do in your
applications in order

00:36:57.266 --> 00:37:00.076 A:middle
to get them working
with Core Profile.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.266 --> 00:37:00.076 A:middle
to get them working
with Core Profile.

00:37:00.256 --> 00:37:03.126 A:middle
And many of these are actually
things that you want to do

00:37:03.126 --> 00:37:06.026 A:middle
to your application even
if you're not trying

00:37:06.066 --> 00:37:07.646 A:middle
to get it in Core Profile.

00:37:07.696 --> 00:37:09.346 A:middle
If you're not doing it
for the reason of going

00:37:09.346 --> 00:37:12.116 A:middle
into Core Profile it's
at least an enhancement

00:37:12.116 --> 00:37:15.416 A:middle
to your application to take --
to switch over to these new ways

00:37:15.716 --> 00:37:19.026 A:middle
of doing your existing
applications.

00:37:19.346 --> 00:37:24.106 A:middle
So for instance a media mode
vertex drawing should be

00:37:24.106 --> 00:37:26.016 A:middle
replaced with using
vertex array objects

00:37:26.016 --> 00:37:27.226 A:middle
and vertex buffer objects.

00:37:27.226 --> 00:37:29.436 A:middle
And there's obvious
increase in performance

00:37:29.436 --> 00:37:31.576 A:middle
by just switching
your application

00:37:31.576 --> 00:37:34.786 A:middle
to use vertex buffer
objects instead of having

00:37:34.786 --> 00:37:37.606 A:middle
to provide the data each
frame, every single time

00:37:37.606 --> 00:37:39.796 A:middle
that you're drawing with it.

00:37:39.986 --> 00:37:44.106 A:middle
Fixed function state gets
replaced with GLSL shaders.

00:37:44.626 --> 00:37:48.406 A:middle
So you're going to have
to specify vertex shader

00:37:48.406 --> 00:37:50.396 A:middle
and a fragment shader,
and then optionally

00:37:50.396 --> 00:37:53.766 A:middle
as well the tessellation
shaders and geometry shaders.

00:37:54.206 --> 00:37:58.626 A:middle
And the matrix math is now
no longer part of OpenGL.

00:37:59.166 --> 00:38:01.456 A:middle
So you do have to provide
your own custom matrix math.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:59.166 --> 00:38:01.456 A:middle
So you do have to provide
your own custom matrix math.

00:38:02.646 --> 00:38:07.126 A:middle
And then older shaders which are
in say 110 or 120, version 110,

00:38:07.126 --> 00:38:11.276 A:middle
120 need to be updated
to version 150 or above.

00:38:11.826 --> 00:38:16.376 A:middle
However, on our platform

00:38:16.376 --> 00:38:19.666 A:middle
in Mountain Lion we also
introduced support for GL Kit,

00:38:20.206 --> 00:38:22.696 A:middle
and GL Kit actually
solves a couple

00:38:22.696 --> 00:38:24.656 A:middle
of these transition steps.

00:38:25.056 --> 00:38:27.026 A:middle
You're still going to have
to update your application

00:38:27.026 --> 00:38:29.106 A:middle
to take advantage of
vertex array objects

00:38:29.106 --> 00:38:30.426 A:middle
and vertex buffer objects.

00:38:30.906 --> 00:38:34.026 A:middle
But for your fixed function
state, for your application

00:38:34.026 --> 00:38:35.746 A:middle
that you made but are
just trying to get to work

00:38:35.746 --> 00:38:39.836 A:middle
in Core Profile you can
use GLKBaseEffect in order

00:38:39.836 --> 00:38:43.366 A:middle
to achieve the same affects that
you would have been trying to do

00:38:43.366 --> 00:38:45.926 A:middle
with your lighting and so forth.

00:38:45.926 --> 00:38:50.486 A:middle
And your Legacy OpenGL
application.

00:38:51.066 --> 00:38:55.076 A:middle
And then additionally the
matrix math that I said was gone

00:38:55.076 --> 00:38:59.056 A:middle
in OpenGL is now fully
replaced by math libraries

00:38:59.056 --> 00:39:00.356 A:middle
that GLK Math provides.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:59.056 --> 00:39:00.356 A:middle
that GLK Math provides.

00:39:00.356 --> 00:39:07.116 A:middle
So let's talk about creating
that Core Profile Context.

00:39:07.566 --> 00:39:10.226 A:middle
So all we do is in our
pixel format attribute lists

00:39:10.226 --> 00:39:15.036 A:middle
that we're going to use to
create our context from we pass

00:39:15.036 --> 00:39:18.986 A:middle
in an NSOpenGLPFA,
OpenGL profile.

00:39:19.316 --> 00:39:23.116 A:middle
And in this attribute
list we're passing

00:39:23.116 --> 00:39:25.696 A:middle
down NSOpenGLProfile3
underscore 2Core.

00:39:25.856 --> 00:39:30.116 A:middle
And this gets you access to all
the new features of OpenGL 4.1.

00:39:30.276 --> 00:39:33.756 A:middle
And OpenGL 4.1 is fully
backwards compatible

00:39:33.756 --> 00:39:35.536 A:middle
with OpenGL 3.2.

00:39:35.786 --> 00:39:38.826 A:middle
So that's how -- why
picking this enables you

00:39:38.826 --> 00:39:40.486 A:middle
to take advantage of
all those new features.

00:39:40.866 --> 00:39:45.376 A:middle
And so now that we've picked
that pixel format we're going

00:39:45.376 --> 00:39:49.746 A:middle
to create our context from that.

00:39:49.986 --> 00:39:55.996 A:middle
So to go over briefly how to get
your application switched over,

00:39:56.526 --> 00:39:58.846 A:middle
what you're looking for and
what you're replacing it

00:39:59.286 --> 00:39:59.386 A:middle
with [laughter].

00:39:59.646 --> 00:40:02.496 A:middle
Basically saying you need
to cash all your vertex data

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:59.646 --> 00:40:02.496 A:middle
Basically saying you need
to cash all your vertex data

00:40:02.946 --> 00:40:03.946 A:middle
in vertex buffer objects.

00:40:05.836 --> 00:40:09.166 A:middle
And additionally
you're going to need

00:40:09.366 --> 00:40:13.796 A:middle
to encapsulate those objects
into vertex array objects

00:40:13.796 --> 00:40:17.036 A:middle
that point where all the
attributes are coming

00:40:17.036 --> 00:40:18.066 A:middle
from for your shaders.

00:40:18.736 --> 00:40:20.726 A:middle
So we have code on the left

00:40:20.726 --> 00:40:22.416 A:middle
which is what would have
been in your application.

00:40:22.876 --> 00:40:27.126 A:middle
So glBegin, GL underscore
TRIANGLES, glEnd or glCallList

00:40:27.126 --> 00:40:29.296 A:middle
with display lists
and Core Profile

00:40:29.296 --> 00:40:33.146 A:middle
on the right we now can
change all those calls

00:40:33.146 --> 00:40:36.066 A:middle
to just two calls we
call glBindVertexArray,

00:40:36.066 --> 00:40:39.466 A:middle
and then glDrawArrays
or glDrawElements if you

00:40:39.466 --> 00:40:41.446 A:middle
so choose to use elements.

00:40:42.346 --> 00:40:47.256 A:middle
glBitmap, glDrawPixels are
subsumed by uploading a texture.

00:40:48.306 --> 00:40:51.536 A:middle
So glTexSubImage in this case
and then we can just draw

00:40:51.536 --> 00:40:54.446 A:middle
with that or call BitFramBuffer
to do something similar

00:40:54.446 --> 00:40:56.146 A:middle
to what it would have done --

00:40:56.146 --> 00:40:58.896 A:middle
what it would have been
doing anyways for you

00:40:58.896 --> 00:41:00.296 A:middle
in the Legacy profile.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.896 --> 00:41:00.296 A:middle
in the Legacy profile.

00:41:01.326 --> 00:41:06.546 A:middle
And additionally, the
pointers that used to exist

00:41:06.546 --> 00:41:08.876 A:middle
for VertexPointer,
TexCoordPointer,

00:41:08.926 --> 00:41:11.216 A:middle
ColorPointer those
are all subsumed

00:41:11.996 --> 00:41:14.206 A:middle
by generic VertexAtribPointers.

00:41:14.596 --> 00:41:16.896 A:middle
So instead we're going to
call VertexAtribPointer

00:41:17.336 --> 00:41:22.096 A:middle
and then we bind each of our
pointer -- attributes by name.

00:41:23.046 --> 00:41:27.016 A:middle
So we have like myVerts in this
example and myglShellShader.

00:41:27.016 --> 00:41:30.806 A:middle
I would have had to input
myVerts and I can bind

00:41:31.096 --> 00:41:34.286 A:middle
that attribute using
BindAttribLocation.

00:41:35.676 --> 00:41:38.546 A:middle
And then finally
glEnableClientState no longer

00:41:38.626 --> 00:41:43.296 A:middle
takes -- because we're no longer
dealing with those color arrays,

00:41:43.296 --> 00:41:44.546 A:middle
normal arrays and so forth.

00:41:44.946 --> 00:41:48.876 A:middle
Instead we're just enabling the
VertexAttribArray by the index

00:41:48.996 --> 00:41:52.046 A:middle
that it's being passed up
to the gl shell shader with.

00:41:53.526 --> 00:41:59.006 A:middle
For your math portions, for
matrix math just use GLKMath.

00:41:59.886 --> 00:42:04.886 A:middle
It's got the ability to replace
all the built in transformations

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:59.886 --> 00:42:04.886 A:middle
It's got the ability to replace
all the built in transformations

00:42:05.346 --> 00:42:08.596 A:middle
that OpenGL would
have provided for you.

00:42:08.596 --> 00:42:11.936 A:middle
And of course you can use
your own matrix math library

00:42:11.936 --> 00:42:12.656 A:middle
if you already have it

00:42:12.736 --> 00:42:15.186 A:middle
but if you don't this is
not a bad place to start.

00:42:16.096 --> 00:42:18.546 A:middle
So we've got for instance
our translate, rotate,

00:42:18.546 --> 00:42:20.336 A:middle
and scale functions
have been replaced

00:42:20.336 --> 00:42:27.106 A:middle
by GLKMatrix4MakeTranslate,
Rotate, Scale.

00:42:27.706 --> 00:42:31.726 A:middle
And the first function there
GLKMatrix4MakeTranslate is

00:42:31.726 --> 00:42:34.726 A:middle
actually equivalent to -- the
make there means it's equivalent

00:42:34.726 --> 00:42:38.106 A:middle
to calling glLoadIdentity
followed by glTranslate.

00:42:39.746 --> 00:42:45.076 A:middle
Additionally perspective we can
call GLKMatrix4MakePerspective.

00:42:45.076 --> 00:42:47.686 A:middle
Similarly that's a
glLoadIdentiy followed

00:42:47.686 --> 00:42:51.226 A:middle
by what gluPerspective
would have done.

00:42:51.696 --> 00:42:55.516 A:middle
And the GLKMath also
provides you with MatrixStacks

00:42:55.586 --> 00:42:57.196 A:middle
so you can push and
pop your stacks.

00:42:57.846 --> 00:43:00.466 A:middle
But when you've actually
finally gotten your value

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:57.846 --> 00:43:00.466 A:middle
But when you've actually
finally gotten your value

00:43:00.466 --> 00:43:03.726 A:middle
out of your matrix, no longer
are you going to use LoadMatrix

00:43:03.726 --> 00:43:07.916 A:middle
to pass your data up
to your GLSL shaders.

00:43:08.446 --> 00:43:11.176 A:middle
But you're going to upload
those as generic uniforms.

00:43:11.176 --> 00:43:16.526 A:middle
So you use glUniformMatrix4fv
in that case.

00:43:16.726 --> 00:43:19.796 A:middle
So here is a list of some
of the functions in GLKMath.

00:43:20.246 --> 00:43:21.736 A:middle
I hope you brought
your binoculars.

00:43:22.236 --> 00:43:25.836 A:middle
But it's basically -- I want
to say it provides everything

00:43:25.836 --> 00:43:29.306 A:middle
that you need for Core
Profile in order to do --

00:43:29.556 --> 00:43:31.976 A:middle
for all your OpenGL
Core Profile needs.

00:43:31.976 --> 00:43:34.146 A:middle
It even has support
for quatrains.

00:43:34.766 --> 00:43:40.166 A:middle
So now on to the next
part of your application

00:43:40.166 --> 00:43:41.056 A:middle
that you need to update.

00:43:41.336 --> 00:43:44.176 A:middle
The fixed-function state that
you may have in your app.

00:43:44.726 --> 00:43:47.936 A:middle
Let's talk about using
GLKBaseEffects and GL Kit

00:43:47.936 --> 00:43:49.746 A:middle
in order to update
your application

00:43:50.196 --> 00:43:51.486 A:middle
to work with Core Profile.

00:43:52.516 --> 00:43:54.686 A:middle
So you would have had
fixed-function in the lighting,

00:43:55.386 --> 00:43:58.566 A:middle
fixed-function materials,
fixed-function texturing.

00:43:59.036 --> 00:44:00.726 A:middle
That's no longer available.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:59.036 --> 00:44:00.726 A:middle
That's no longer available.

00:44:01.006 --> 00:44:03.306 A:middle
Instead we're passing
everything up as shaders

00:44:03.616 --> 00:44:06.176 A:middle
and then GLKEffect provides
you with base shaders

00:44:06.586 --> 00:44:10.446 A:middle
that you can treat similarly

00:44:10.446 --> 00:44:12.246 A:middle
to how your code
may have interacted

00:44:12.646 --> 00:44:15.006 A:middle
with your Legacy OpenGL context.

00:44:16.636 --> 00:44:20.156 A:middle
So here we have our lights that
we're passing up for instance.

00:44:20.156 --> 00:44:22.376 A:middle
We can pass up a
position, diffuse,

00:44:22.376 --> 00:44:24.996 A:middle
specular values for our lights.

00:44:25.576 --> 00:44:28.386 A:middle
Instead with the GLKBaseEffect
we're just setting the

00:44:28.386 --> 00:44:30.186 A:middle
light0.position, diffuse color

00:44:30.186 --> 00:44:32.296 A:middle
and specular color
as you would expect.

00:44:32.736 --> 00:44:33.646 A:middle
Pretty straight forward.

00:44:34.276 --> 00:44:37.506 A:middle
Additionally you can go
enable it with an enabled bit

00:44:38.056 --> 00:44:39.926 A:middle
and then we even have materials.

00:44:40.586 --> 00:44:42.796 A:middle
So it's a very close correlation

00:44:42.856 --> 00:44:50.436 A:middle
to how you would have been using
fixed-function state before.

00:44:50.796 --> 00:44:55.186 A:middle
So afterwards -- some of you
may already have some shaders

00:44:55.186 --> 00:44:58.956 A:middle
already written using
GLSL 110 and --

00:44:58.956 --> 00:45:02.006 A:middle
or 120 and there's some slight
differences in getting it

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.956 --> 00:45:02.006 A:middle
or 120 and there's some slight
differences in getting it

00:45:02.006 --> 00:45:08.486 A:middle
to work with 140,
150, 330 and 410.

00:45:09.796 --> 00:45:11.726 A:middle
So again, I was already saying

00:45:11.726 --> 00:45:17.146 A:middle
that we've got our client
state enables are now switched

00:45:17.186 --> 00:45:18.726 A:middle
to generic attributes.

00:45:19.026 --> 00:45:21.966 A:middle
So we're just going to be
enabling our index here

00:45:22.206 --> 00:45:24.036 A:middle
of our attributes
that we're passing in.

00:45:24.566 --> 00:45:28.356 A:middle
Matrices; we're no longer
loading those matrices

00:45:28.356 --> 00:45:29.776 A:middle
as a built in matrix

00:45:29.866 --> 00:45:36.236 A:middle
like glModelViewProjectionMatrix
and so forth.

00:45:36.386 --> 00:45:38.076 A:middle
They're instead going
to be generic uniforms

00:45:38.076 --> 00:45:40.556 A:middle
that we pass into our shaders.

00:45:40.556 --> 00:45:43.416 A:middle
And so we're going
to be uploading those

00:45:43.416 --> 00:45:44.926 A:middle
with glUniformMatrix4fv.

00:45:44.926 --> 00:45:49.126 A:middle
Additionally some of the current
state that you would have set

00:45:49.126 --> 00:45:55.686 A:middle
like glColor4fv you can set
those either using similarly

00:45:55.686 --> 00:46:01.626 A:middle
glVertexAttrib4fv for constant
values or glUniform4fv as well

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:45:55.686 --> 00:46:01.626 A:middle
glVertexAttrib4fv for constant
values or glUniform4fv as well

00:46:01.626 --> 00:46:05.346 A:middle
for values that are not
changing very often.

00:46:05.996 --> 00:46:10.186 A:middle
And then additionally all the
pointer calls get replaced

00:46:10.186 --> 00:46:14.246 A:middle
with a generic
VertexAttribPointer call.

00:46:14.446 --> 00:46:18.796 A:middle
So looking at the actually GLSL
language itself there's some

00:46:18.796 --> 00:46:22.596 A:middle
slight differences
here where the ins

00:46:22.596 --> 00:46:25.846 A:middle
and outs are now very
explicit in GLSL 150.

00:46:26.456 --> 00:46:28.376 A:middle
And then additionally
for the frag- --

00:46:28.586 --> 00:46:31.486 A:middle
similarly to how the
built-ins are removed

00:46:31.486 --> 00:46:34.196 A:middle
for like the fixed-functions
state

00:46:34.196 --> 00:46:39.936 A:middle
and so forth the frag data
output is replaced with an

00:46:39.936 --> 00:46:42.956 A:middle
out that will be where
we're going to be writing

00:46:42.956 --> 00:46:45.916 A:middle
to which tells us which
one of our draw buffers

00:46:45.916 --> 00:46:47.856 A:middle
to provide a result to.

00:46:48.446 --> 00:46:50.396 A:middle
So we have up here
the attributes

00:46:50.676 --> 00:46:53.016 A:middle
that would have been
attributes in GLSL 110.

00:46:53.366 --> 00:46:56.396 A:middle
In 150 those become in because
the attributes are going

00:46:56.396 --> 00:46:59.066 A:middle
into your vertex shader
so that we're just passing

00:46:59.066 --> 00:47:00.526 A:middle
in vec4 data here.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:46:59.066 --> 00:47:00.526 A:middle
in vec4 data here.

00:47:00.526 --> 00:47:03.516 A:middle
And then our varying's
that we would have produced

00:47:03.556 --> 00:47:06.296 A:middle
with our vertex shader
and then consumed

00:47:06.296 --> 00:47:09.286 A:middle
with our fragment shader are
no longer called varying's.

00:47:09.416 --> 00:47:13.536 A:middle
They're more explicitly named
out from the vertex shader

00:47:13.536 --> 00:47:15.356 A:middle
and in in the fragment shader.

00:47:15.776 --> 00:47:19.516 A:middle
So our texCoordinates for
instance we're outputting

00:47:19.516 --> 00:47:21.796 A:middle
that from the vertex shader here

00:47:21.796 --> 00:47:24.256 A:middle
and then inputting
it to the fragment.

00:47:24.806 --> 00:47:28.766 A:middle
And then finally as I was
mentioning just a moment again

00:47:29.026 --> 00:47:31.426 A:middle
-- ago, gl underscore
FragColor is replaced

00:47:32.266 --> 00:47:35.446 A:middle
with a binding of your choice.

00:47:35.776 --> 00:47:40.436 A:middle
So we've made an out to vec4
here called myColor and prior

00:47:40.526 --> 00:47:43.676 A:middle
to linking our GLSL
program I made sure

00:47:43.676 --> 00:47:46.626 A:middle
to BindFragDataLocation
for the --

00:47:46.876 --> 00:47:50.836 A:middle
for myColor so that I'm
specifying it to be writing

00:47:50.886 --> 00:47:53.236 A:middle
to the [inaudible]
for zero with myColor.

00:47:56.396 --> 00:47:59.426 A:middle
Some additional changes
we've got

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:00.376 --> 00:48:03.406 A:middle
in GLSL version 150 over 110.

00:48:03.646 --> 00:48:05.746 A:middle
Now the GLSL version
is also required.

00:48:05.796 --> 00:48:09.266 A:middle
So 110 would have been implicit
which version you were using.

00:48:09.626 --> 00:48:12.426 A:middle
However, in Core Profile you're
required to say version --

00:48:12.426 --> 00:48:16.986 A:middle
#version 150, 330 or 410
at the top of your shaders.

00:48:17.756 --> 00:48:20.526 A:middle
And then some examples
here of the built ins

00:48:20.526 --> 00:48:23.196 A:middle
that have been removed; gl
underscore Vertex, Normal,

00:48:23.226 --> 00:48:28.156 A:middle
MultiTexCoord are replaced
with your own generic uniforms

00:48:28.516 --> 00:48:30.336 A:middle
or vertex attributes here.

00:48:31.176 --> 00:48:35.226 A:middle
vertPos, inNormal, texCoord
that we've named ourselves

00:48:35.286 --> 00:48:37.706 A:middle
and upload as vertex attributes.

00:48:37.706 --> 00:48:42.046 A:middle
And then additionally some
of the uniform variables

00:48:42.046 --> 00:48:43.706 A:middle
like our
ModelViewProjectionMatrix

00:48:44.146 --> 00:48:47.956 A:middle
and the gl underscore
NormalMatrix we could --

00:48:48.136 --> 00:48:50.146 A:middle
we upload those as
glUniforms here.

00:48:50.786 --> 00:48:55.136 A:middle
And then finally small
change; texture2D,

00:48:55.136 --> 00:48:58.136 A:middle
texture3D are replaced by
just a simple texture call.

00:48:58.456 --> 00:49:00.416 A:middle
And the sampler type
overloads how

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:58.456 --> 00:49:00.416 A:middle
And the sampler type
overloads how

00:49:00.416 --> 00:49:04.986 A:middle
that texture call
should be sampled from.

00:49:04.986 --> 00:49:09.196 A:middle
So now that we've got our GLSL
shaders pretty much working

00:49:09.196 --> 00:49:12.046 A:middle
with Core Profile let's
go over a little bit more

00:49:12.046 --> 00:49:13.326 A:middle
of the other API
differences here.

00:49:13.566 --> 00:49:18.886 A:middle
We've got of course different
headers in OpenGL3 and so

00:49:18.886 --> 00:49:23.546 A:middle
if you can modify your
code to only include gl3.h

00:49:23.546 --> 00:49:28.046 A:middle
and gl3ext.h you can assure that
your code is building cleanly

00:49:28.496 --> 00:49:30.766 A:middle
and as a result that
you're not calling any calls

00:49:30.766 --> 00:49:34.196 A:middle
that may have been
removed from Core Profile.

00:49:34.536 --> 00:49:39.706 A:middle
And if you are for instance to
call glCallList in Core Profile

00:49:39.706 --> 00:49:41.026 A:middle
that would throw an invalid up.

00:49:41.586 --> 00:49:46.516 A:middle
And so instead of having
to figure out at runtime

00:49:46.516 --> 00:49:50.196 A:middle
where you may have errors
just getting rid of the gl.h

00:49:50.196 --> 00:49:52.676 A:middle
and glext.h in your
file can allow you

00:49:52.676 --> 00:49:54.196 A:middle
to at compile time know

00:49:54.196 --> 00:49:57.486 A:middle
which functionality is
-- needs to be replaced.

00:49:58.916 --> 00:50:02.736 A:middle
Additionally getting extension
strings is slightly different.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:58.916 --> 00:50:02.736 A:middle
Additionally getting extension
strings is slightly different.

00:50:03.326 --> 00:50:05.806 A:middle
Instead of getting one huge
string like you would have

00:50:05.806 --> 00:50:10.326 A:middle
in Legacy Profile it's now
split up into an index string

00:50:10.796 --> 00:50:13.876 A:middle
where you have to get the number
of extensions that are available

00:50:14.236 --> 00:50:17.786 A:middle
and you go through that
loop, and can get each

00:50:17.786 --> 00:50:19.216 A:middle
of the extensions one by one.

00:50:20.326 --> 00:50:26.556 A:middle
And then finally APPLEFence
is replaced by Sync objects.

00:50:26.906 --> 00:50:29.126 A:middle
So say that FenceAPPLE
becomes glFenceSync,

00:50:29.996 --> 00:50:34.816 A:middle
glTestFenceAPPLE gets replaces
with glWaitSync and then some

00:50:34.816 --> 00:50:36.766 A:middle
of the functionality --
some of the functions

00:50:37.126 --> 00:50:38.816 A:middle
like VertexArray
objects are replaced

00:50:38.816 --> 00:50:39.926 A:middle
by the Core equivalents.

00:50:39.956 --> 00:50:42.866 A:middle
So you'll call glVertexArrays
instead

00:50:42.866 --> 00:50:45.546 A:middle
of glGenVertexArraysAPPLE
and so forth.

00:50:47.316 --> 00:50:52.066 A:middle
So of course a lot of you
may have somewhat larger

00:50:52.066 --> 00:50:56.106 A:middle
applications where you can't
just go and switch immediately

00:50:56.106 --> 00:50:58.136 A:middle
from Legacy to Core
Profile context.

00:50:58.526 --> 00:51:02.446 A:middle
For you guys I'm suggesting
a more piecemeal approach.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:50:58.526 --> 00:51:02.446 A:middle
For you guys I'm suggesting
a more piecemeal approach.

00:51:03.156 --> 00:51:09.126 A:middle
So really you can do any of
these operations by themselves

00:51:09.126 --> 00:51:12.396 A:middle
and not affect the
rest of your code.

00:51:12.716 --> 00:51:15.836 A:middle
So while still staying on
Legacy Profile we're going

00:51:15.836 --> 00:51:19.216 A:middle
to switch our application
first to wherever we have some

00:51:19.216 --> 00:51:21.056 A:middle
of the older draw calls.

00:51:21.426 --> 00:51:24.736 A:middle
We can replace them with drawing
with vertex buffer objects

00:51:24.736 --> 00:51:25.856 A:middle
and vertex array objects.

00:51:26.256 --> 00:51:29.316 A:middle
And this can be done
to multiple pieces

00:51:29.516 --> 00:51:32.396 A:middle
of code at your own timing.

00:51:33.376 --> 00:51:35.656 A:middle
And you don't need to
switch to Core Profile

00:51:35.946 --> 00:51:39.646 A:middle
to start using vertex arrays
and vertex buffer objects.

00:51:40.696 --> 00:51:43.646 A:middle
Secondly replacing the math.

00:51:44.386 --> 00:51:50.856 A:middle
You can actually use GLKMath
with Legacy OpenGL context.

00:51:51.286 --> 00:51:54.586 A:middle
And it's because it
doesn't really have a --

00:51:54.586 --> 00:51:56.436 A:middle
its profile agnostic.

00:51:56.676 --> 00:51:58.076 A:middle
It just gives you back raw data.

00:51:58.756 --> 00:52:04.056 A:middle
So with that raw data instead
of calling gluPerspective

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:51:58.756 --> 00:52:04.056 A:middle
So with that raw data instead
of calling gluPerspective

00:52:04.056 --> 00:52:09.156 A:middle
for instance with the projection
matrix instead I would have my

00:52:09.156 --> 00:52:11.676 A:middle
projection matrix
as just a variable

00:52:11.796 --> 00:52:16.326 A:middle
that I've calculated
on using GLKMath.

00:52:17.396 --> 00:52:21.386 A:middle
And then for instance on
the CPU I may then multiply

00:52:21.386 --> 00:52:23.986 A:middle
that by the ModelViewMatrix
as well

00:52:24.066 --> 00:52:25.836 A:middle
to get my
ModelViewProjectionMatrix

00:52:26.266 --> 00:52:27.706 A:middle
and then once I have
that result --

00:52:27.706 --> 00:52:29.546 A:middle
because I don't need to do

00:52:29.546 --> 00:52:31.776 A:middle
that multiple every single
time in the vertex shader.

00:52:32.396 --> 00:52:36.626 A:middle
I would pass that result in
as a -- just using LoadMatrix.

00:52:37.726 --> 00:52:42.846 A:middle
And so using LoadMatrix
you can pass in those --

00:52:43.336 --> 00:52:44.726 A:middle
the original matrices.

00:52:44.726 --> 00:52:53.576 A:middle
Then for updating your existing
shaders; if you have 110,

00:52:54.306 --> 00:52:58.716 A:middle
150 you can already move your --

00:52:58.716 --> 00:53:02.906 A:middle
while staying in 110 you
can keep your attributes

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:58.716 --> 00:53:02.906 A:middle
while staying in 110 you
can keep your attributes

00:53:02.906 --> 00:53:06.836 A:middle
and replace them with generic
attributes, use uniforms for any

00:53:06.836 --> 00:53:10.816 A:middle
of the built-ins and
by doing so you --

00:53:10.816 --> 00:53:17.486 A:middle
you're getting rid of your
dependency on the built-ins

00:53:17.486 --> 00:53:18.926 A:middle
that were very specific.

00:53:19.186 --> 00:53:22.516 A:middle
Because you can use the
generic attributes with Legacy

00:53:22.516 --> 00:53:23.716 A:middle
and Core Profile alike.

00:53:23.916 --> 00:53:26.716 A:middle
And then additionally EXT
underscore gpu underscore

00:53:26.716 --> 00:53:28.536 A:middle
shader4 enables you
to have your outs --

00:53:28.896 --> 00:53:32.826 A:middle
your out color specified
usingBindFragDataLocation just

00:53:32.826 --> 00:53:33.776 A:middle
like in Core Profile.

00:53:34.296 --> 00:53:37.936 A:middle
So in doing this we can
create our shaders in a way

00:53:37.936 --> 00:53:40.886 A:middle
that even using say
#define to define

00:53:40.886 --> 00:53:47.286 A:middle
in the vertex shader attributes
to end and varying's to out.

00:53:47.286 --> 00:53:53.036 A:middle
And do those #defines such that
you could easily switch your

00:53:53.036 --> 00:53:55.916 A:middle
shaders from 110 to 150
when you do make the switch

00:53:55.916 --> 00:53:56.596 A:middle
to Core Profile.

00:53:57.156 --> 00:54:01.136 A:middle
And then finally for places

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:53:57.156 --> 00:54:01.136 A:middle
And then finally for places

00:54:01.136 --> 00:54:06.296 A:middle
where you may have
fixed-function use right now you

00:54:06.296 --> 00:54:12.256 A:middle
will have to make -- you can
make those into GLSL 110 shaders

00:54:12.816 --> 00:54:15.426 A:middle
and do similar things
to what you were doing

00:54:15.536 --> 00:54:17.776 A:middle
with your existing
shaders just before.

00:54:18.446 --> 00:54:22.176 A:middle
And GLKEffects unfortunately
depends on Core Profile.

00:54:22.476 --> 00:54:25.166 A:middle
So this -- to do this
piecemeal you will have

00:54:25.256 --> 00:54:28.656 A:middle
to be replacing your
fixed-function with shaders.

00:54:29.536 --> 00:54:34.226 A:middle
And so you can do any of these
steps above, but one at a time

00:54:34.276 --> 00:54:36.816 A:middle
and check that when
you touch this one file

00:54:36.816 --> 00:54:39.266 A:middle
and replace vertex buffer
objects and vertex array objects

00:54:39.266 --> 00:54:42.936 A:middle
that we're getting the expected
result just like we used to get.

00:54:42.936 --> 00:54:46.396 A:middle
And so we're able to debug our
application on a more piece

00:54:46.396 --> 00:54:53.196 A:middle
by piece basis and not doing
one big switch all at once.

00:54:53.196 --> 00:54:56.176 A:middle
So after you've made all
these changes you switch

00:54:56.176 --> 00:54:59.176 A:middle
to Core Profile by
specifying Core Profile

00:54:59.176 --> 00:55:00.436 A:middle
in your pixel format attribute

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:54:59.176 --> 00:55:00.436 A:middle
in your pixel format attribute

00:55:01.006 --> 00:55:04.016 A:middle
and then update your shader
versions ideally with --

00:55:04.016 --> 00:55:09.266 A:middle
by replacing those #defines
with in, outs and so forth.

00:55:09.856 --> 00:55:15.476 A:middle
And just a tip for large code
bases where you may have a bunch

00:55:15.476 --> 00:55:20.116 A:middle
of code that's using
Legacy, OpenGL context calls.

00:55:20.766 --> 00:55:25.786 A:middle
You do a Grep for some of the
streams and tokens that you have

00:55:25.836 --> 00:55:30.016 A:middle
that are referencing like
glBegin, glEnd, glLight

00:55:30.756 --> 00:55:34.916 A:middle
and using that Grep and just
doing a line count you can track

00:55:35.426 --> 00:55:38.336 A:middle
how many lines of code you have
left to switch to Core Profile

00:55:38.756 --> 00:55:42.236 A:middle
and track over time
that adoption.

00:55:42.966 --> 00:55:49.376 A:middle
So to summarize what we went
over today we went over a bunch

00:55:49.376 --> 00:55:53.726 A:middle
of new features in Mavericks and
just how to get access to those

00:55:53.726 --> 00:55:55.066 A:middle
by using the Core Profile.

00:55:55.066 --> 00:55:58.616 A:middle
I also wanted to throw
in a little mention

00:55:58.616 --> 00:56:00.236 A:middle
about OpenGL Profiler here.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:58.616 --> 00:56:00.236 A:middle
about OpenGL Profiler here.

00:56:00.736 --> 00:56:04.816 A:middle
It allows you to break on
OpenGL errors for instance

00:56:05.076 --> 00:56:07.456 A:middle
which is very useful for
when doing a transition

00:56:07.456 --> 00:56:08.306 A:middle
to Core Profile.

00:56:08.906 --> 00:56:12.186 A:middle
And so you no longer have to
take glGetError in your code

00:56:12.186 --> 00:56:14.386 A:middle
between every single
place to find out what

00:56:14.386 --> 00:56:15.596 A:middle
where that error's coming from.

00:56:16.076 --> 00:56:17.526 A:middle
And you should never
have glGetError

00:56:17.526 --> 00:56:21.126 A:middle
in shipping code
anyways for release mode.

00:56:21.486 --> 00:56:25.966 A:middle
So instead you can just use
OpenGL Profiler and break

00:56:25.966 --> 00:56:28.736 A:middle
on GL error as the
screenshot there shows.

00:56:29.656 --> 00:56:33.876 A:middle
And so finally we did go
over how to use OpenCl

00:56:34.296 --> 00:56:37.476 A:middle
and OpenGL together in
order to do computes

00:56:37.476 --> 00:56:39.016 A:middle
and solve your computes needs.

00:56:39.796 --> 00:56:47.316 A:middle
So if you have any questions
Alan Schafer our Graphics

00:56:47.316 --> 00:56:48.896 A:middle
and Games Technology Evangelist.

00:56:48.986 --> 00:56:51.196 A:middle
We've got some great
documentation

00:56:51.676 --> 00:56:54.996 A:middle
at developer.apple.com/opengl
and then

00:56:54.996 --> 00:56:56.606 A:middle
of course you can
interact with each other

00:56:56.986 --> 00:57:00.776 A:middle
at devforums.apple.com.

WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:56.986 --> 00:57:00.776 A:middle
at devforums.apple.com.

00:57:00.836 --> 00:57:04.806 A:middle
And so the related sessions to
this, we had again this morning.

00:57:05.406 --> 00:57:09.246 A:middle
Dan went over OpenGL ES and
some of the advances there

00:57:09.456 --> 00:57:13.006 A:middle
such as instancing which is
now available with iOS 7.

00:57:14.056 --> 00:57:18.276 A:middle
And then Working with OpenCL
as I mentioned earlier is right

00:57:18.276 --> 00:57:20.476 A:middle
after this talk so stay
put if you're interested

00:57:20.476 --> 00:57:21.986 A:middle
in learning about using OpenCL.

00:57:23.336 --> 00:57:24.416 A:middle
So thank you very much.

00:57:25.016 --> 00:57:27.016 A:middle
[Applause]

00:57:27.016 --> 00:57:32.386 A:middle
[Silence]

