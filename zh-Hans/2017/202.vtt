WEBVTT

00:00:20.516 --> 00:00:22.916 A:middle
[掌声]

00:00:23.416 --> 00:00:23.596 A:middle
&gt;&gt; 早上好

00:00:25.956 --> 00:00:28.146 A:middle
欢迎来听“TVMLKit  的新改进”

00:00:28.526 --> 00:00:29.146 A:middle
我叫 Trevor

00:00:29.146 --> 00:00:30.486 A:middle
是本地化部门的员工

00:00:30.486 --> 00:00:31.526 A:middle
我的同事  来自 tvOS 部门的

00:00:31.526 --> 00:00:32.936 A:middle
Parry 和 Jeremy 会在我

00:00:32.936 --> 00:00:33.866 A:middle
之后发言

00:00:34.366 --> 00:00:35.656 A:middle
今天   我们很高兴

00:00:35.656 --> 00:00:37.146 A:middle
能和大家分享我们对 TVMLKit

00:00:37.146 --> 00:00:39.586 A:middle
做出的三大新改进

00:00:39.586 --> 00:00:41.226 A:middle
TVMLKit 是一个开发者框架

00:00:41.226 --> 00:00:42.586 A:middle
用于为 Apple TV 开发

00:00:42.586 --> 00:00:45.246 A:middle
原生应用程序  该框架

00:00:45.466 --> 00:00:47.356 A:middle
可整合 JavaScript 和苹果自定义

00:00:47.356 --> 00:00:48.646 A:middle
标记语言 TVML

00:00:51.376 --> 00:00:52.716 A:middle
首先  演讲内容会谈到

00:00:52.716 --> 00:00:54.146 A:middle
对从右往左书写文字的支持

00:00:55.166 --> 00:00:56.866 A:middle
第二位演讲者 Parry 会给大家

00:00:56.866 --> 00:00:57.876 A:middle
展示如何应用模版中

00:00:57.876 --> 00:00:59.426 A:middle
一些新增的优化功能

00:00:59.696 --> 00:01:01.066 A:middle
来提升程序性能

00:00:59.696 --> 00:01:01.066 A:middle
来提升程序性能

00:01:02.016 --> 00:01:03.456 A:middle
最后  Jeremy 会

00:01:03.456 --> 00:01:04.995 A:middle
给大家展示 Web 审查器中

00:01:04.995 --> 00:01:06.376 A:middle
新增了哪些很棒的新功能

00:01:06.436 --> 00:01:07.286 A:middle
可帮你更便捷地

00:01:07.286 --> 00:01:08.826 A:middle
给你的程序调试排错

00:01:09.316 --> 00:01:10.636 A:middle
下面我们就开始  我先讲

00:01:10.636 --> 00:01:11.896 A:middle
对从右往左书写文字的支持

00:01:14.836 --> 00:01:16.456 A:middle
tvOS 11 中新增了

00:01:16.456 --> 00:01:17.996 A:middle
两个可选语言  分别是阿拉伯语

00:01:17.996 --> 00:01:18.946 A:middle
和希伯来语

00:01:20.206 --> 00:01:22.386 A:middle
两门语言全球有超过4亿人使用

00:01:22.386 --> 00:01:23.806 A:middle
如果你的 App

00:01:23.806 --> 00:01:25.436 A:middle
能够在这两门语言环境下运行

00:01:25.666 --> 00:01:27.106 A:middle
就可让各位开发的应用触及到更多的用户

00:01:28.416 --> 00:01:29.626 A:middle
要支持阿拉伯语和希伯来语

00:01:29.626 --> 00:01:30.846 A:middle
对比大家的应用程序目前

00:01:30.846 --> 00:01:31.986 A:middle
已经支持的其他语言

00:01:31.986 --> 00:01:33.556 A:middle
区别在于阿拉伯语和希伯来语

00:01:33.556 --> 00:01:35.156 A:middle
都是从右往左书写的

00:01:35.196 --> 00:01:35.646 A:middle
文字

00:01:36.686 --> 00:01:37.646 A:middle
我先给大家看几个例子  展示一下

00:01:37.646 --> 00:01:38.786 A:middle
支持从右往左书写语言后

00:01:38.786 --> 00:01:40.066 A:middle
大家的应用程序  看起来

00:01:40.066 --> 00:01:41.036 A:middle
大概什么样

00:01:45.056 --> 00:01:46.846 A:middle
现在显示的是一个

00:01:46.846 --> 00:01:47.926 A:middle
从左往右书写语言模式下

00:01:47.926 --> 00:01:50.126 A:middle
的产品模版  大部分人

00:01:50.126 --> 00:01:51.256 A:middle
可能已经很熟悉这个

00:01:51.256 --> 00:01:51.826 A:middle
界面了

00:01:51.916 --> 00:01:53.446 A:middle
文字左对齐

00:01:53.796 --> 00:01:55.226 A:middle
内容排布顺序

00:01:55.226 --> 00:01:56.376 A:middle
是从屏幕左边

00:01:56.376 --> 00:01:57.426 A:middle
排向屏幕右边

00:01:58.006 --> 00:01:59.126 A:middle
优先选中的第一个按钮

00:01:59.126 --> 00:02:00.186 A:middle
也是在屏幕的

00:01:59.126 --> 00:02:00.186 A:middle
也是在屏幕的

00:02:00.186 --> 00:02:00.966 A:middle
最左边

00:02:02.096 --> 00:02:03.446 A:middle
现在  如果我们选用这个模版

00:02:03.896 --> 00:02:04.846 A:middle
然后在从右往左

00:02:04.846 --> 00:02:06.376 A:middle
书写文字模式下加载

00:02:06.376 --> 00:02:08.406 A:middle
比如选择希伯来语  就可以看到

00:02:08.406 --> 00:02:09.466 A:middle
页面布局被左右翻转了

00:02:09.466 --> 00:02:11.606 A:middle
内容排布顺序会变成

00:02:11.606 --> 00:02:12.786 A:middle
从屏幕右边

00:02:12.786 --> 00:02:13.526 A:middle
排向屏幕左边

00:02:13.826 --> 00:02:15.146 A:middle
文字右对齐

00:02:15.646 --> 00:02:17.106 A:middle
优先选中的  还是第一个按钮

00:02:17.106 --> 00:02:18.326 A:middle
但现在这一项位于

00:02:18.326 --> 00:02:19.016 A:middle
屏幕右边了

00:02:19.506 --> 00:02:21.386 A:middle
我们再看一个例子

00:02:23.296 --> 00:02:24.976 A:middle
这是目录模版

00:02:24.976 --> 00:02:27.146 A:middle
和刚才一样  如果你常用的语言

00:02:27.146 --> 00:02:28.646 A:middle
是从左往右书写的

00:02:28.646 --> 00:02:29.986 A:middle
你可能会很熟悉这个界面

00:02:29.986 --> 00:02:30.536 A:middle
很自然

00:02:30.976 --> 00:02:32.026 A:middle
但如果我们把同一个模版

00:02:32.026 --> 00:02:33.396 A:middle
放到从右往左书写文字的

00:02:33.396 --> 00:02:35.126 A:middle
模式下  我们会发现

00:02:35.126 --> 00:02:36.676 A:middle
页面布局同样被翻转了

00:02:36.866 --> 00:02:38.196 A:middle
内容变成从右往左

00:02:38.196 --> 00:02:38.626 A:middle
排布

00:02:38.836 --> 00:02:40.016 A:middle
第一张图片依然是沙漠

00:02:40.016 --> 00:02:41.106 A:middle
但现在这张图片显示在

00:02:41.106 --> 00:02:41.876 A:middle
屏幕的另一边

00:02:42.876 --> 00:02:44.136 A:middle
从右往左书写文字的模式下

00:02:44.136 --> 00:02:46.056 A:middle
应用程序的界面看起来差不多就是这样

00:02:46.346 --> 00:02:47.276 A:middle
从刚刚的演示中也可看到

00:02:47.276 --> 00:02:48.416 A:middle
我们把对相应语言的支持

00:02:48.416 --> 00:02:49.896 A:middle
都整合到了 TVMLKit 内部了

00:02:50.416 --> 00:02:52.036 A:middle
所以  只要你使用的是默认模版

00:02:52.036 --> 00:02:53.306 A:middle
你们的应用程序就可免费获得

00:02:53.306 --> 00:02:55.836 A:middle
对从右往左书写文字的优化支持

00:02:56.006 --> 00:02:57.946 A:middle
而要让应用程序支持

00:02:57.946 --> 00:02:59.756 A:middle
从右往左书写文字的显示模式

00:02:59.756 --> 00:03:01.026 A:middle
设置方法  和配置其他支持语言

00:02:59.756 --> 00:03:01.026 A:middle
设置方法  和配置其他支持语言

00:03:01.026 --> 00:03:01.486 A:middle
方法一样

00:03:02.176 --> 00:03:03.816 A:middle
只需在 Xcode 中

00:03:03.816 --> 00:03:05.646 A:middle
进入 Project Setting 页面

00:03:05.646 --> 00:03:07.996 A:middle
可看到  在 localizations 下

00:03:07.996 --> 00:03:09.336 A:middle
目前新增了阿语和希语

00:03:09.336 --> 00:03:10.366 A:middle
我们按需添加即可

00:03:12.076 --> 00:03:13.946 A:middle
把两种语言整合到 TVMLKit 中很重要

00:03:13.946 --> 00:03:15.696 A:middle
这样可确保 TVMLKit 在运行时

00:03:15.696 --> 00:03:16.616 A:middle
能判断何时加载成

00:03:16.616 --> 00:03:17.786 A:middle
从右往左显示的界面

00:03:18.496 --> 00:03:19.846 A:middle
关于如何更好地

00:03:19.846 --> 00:03:20.866 A:middle
把应用程序本地化

00:03:20.866 --> 00:03:22.146 A:middle
和更多相关详细信息

00:03:22.146 --> 00:03:23.396 A:middle
包括内容本地化

00:03:23.396 --> 00:03:24.516 A:middle
和如何设置本地化的

00:03:24.516 --> 00:03:25.946 A:middle
时间日期格式  等等

00:03:26.306 --> 00:03:27.606 A:middle
我推荐大家去听一个

00:03:27.606 --> 00:03:29.266 A:middle
今年的演讲  叫“Localizing With X

00:03:29.266 --> 00:03:30.646 A:middle
Code 9” 那里会讲得

00:03:30.646 --> 00:03:33.086 A:middle
更详细一些

00:03:33.226 --> 00:03:35.036 A:middle
好了  刚说了使用默认模版自带的

00:03:35.036 --> 00:03:36.856 A:middle
设置一键配置本地化  但如果程序里

00:03:36.856 --> 00:03:38.526 A:middle
有自定义界面呢  如果你想

00:03:38.526 --> 00:03:39.946 A:middle
实现一些模版中没有提供的

00:03:39.946 --> 00:03:40.696 A:middle
显示效果呢

00:03:41.306 --> 00:03:42.666 A:middle
在 tvOS 11 里

00:03:42.666 --> 00:03:44.456 A:middle
我们新引入了三处可以

00:03:44.456 --> 00:03:46.956 A:middle
自定义的领域  分别是页面布局

00:03:47.536 --> 00:03:49.316 A:middle
文字对齐方式和图片显示

00:03:49.706 --> 00:03:51.356 A:middle
我们首先说页面布局

00:03:52.556 --> 00:03:54.296 A:middle
目前我们自定义页面布局

00:03:54.296 --> 00:03:56.456 A:middle
可能是靠分别设置

00:03:56.456 --> 00:03:57.476 A:middle
tv-align 为 left(左)

00:03:57.476 --> 00:03:59.446 A:middle
和设置 tv-position

00:03:59.446 --> 00:03:59.846 A:middle
为 right(右)

00:04:01.046 --> 00:04:01.946 A:middle
而对于从右往左书写

00:04:01.946 --> 00:04:03.836 A:middle
的文字  左是右

00:04:03.836 --> 00:04:05.516 A:middle
右是左  是颠倒的

00:04:05.516 --> 00:04:07.366 A:middle
这样我们再使用 left 和 right 就得格外小心

00:04:07.366 --> 00:04:10.076 A:middle
很容易设置错方向

00:04:10.266 --> 00:04:11.436 A:middle
为此  我们引入了两个新的属性

00:04:11.436 --> 00:04:12.446 A:middle
叫 leading 和 trailing

00:04:13.496 --> 00:04:14.496 A:middle
Leading 和 trailing

00:04:14.496 --> 00:04:15.796 A:middle
会在程序运行时

00:04:15.796 --> 00:04:17.336 A:middle
根据运行时的语言环境

00:04:17.336 --> 00:04:18.676 A:middle
自动解析出与之适应的 left

00:04:18.676 --> 00:04:19.486 A:middle
或者 right

00:04:19.486 --> 00:04:20.055 A:middle
值

00:04:20.886 --> 00:04:22.096 A:middle
比方说  如果我们

00:04:22.096 --> 00:04:23.156 A:middle
本来定义的样式里是

00:04:23.156 --> 00:04:24.806 A:middle
把 tv-position 设为 right

00:04:25.116 --> 00:04:26.946 A:middle
或者 tv-align 设为 left

00:04:26.946 --> 00:04:28.216 A:middle
现在  我们需要把后面的值

00:04:28.216 --> 00:04:29.246 A:middle
改为 leading 和 trailing

00:04:29.876 --> 00:04:31.336 A:middle
这样就可以确保

00:04:31.336 --> 00:04:32.506 A:middle
在从左往右语言模式下

00:04:32.506 --> 00:04:33.716 A:middle
页面显示效果还和原来一样

00:04:33.716 --> 00:04:35.596 A:middle
但用从右往左语言模式加载后

00:04:35.596 --> 00:04:37.016 A:middle
内容依然能正确排布

00:04:40.116 --> 00:04:41.726 A:middle
对于 margin 和 padding 的赋值

00:04:41.726 --> 00:04:43.166 A:middle
tvOS 11 引入了

00:04:43.166 --> 00:04:45.386 A:middle
一个全新的媒体查询属性

00:04:45.836 --> 00:04:47.336 A:middle
叫作 Layout Direction (布局方向)

00:04:48.056 --> 00:04:49.366 A:middle
大家可能已经

00:04:49.366 --> 00:04:51.166 A:middle
在通过使用媒体查询

00:04:51.166 --> 00:04:52.336 A:middle
来自定义调整页面明暗

00:04:52.976 --> 00:04:54.166 A:middle
这里也是一样的道理

00:04:54.606 --> 00:04:56.016 A:middle
在媒体查询内部

00:04:56.016 --> 00:04:57.906 A:middle
定义的样式  只在当前

00:04:57.906 --> 00:04:59.706 A:middle
媒体查询中有效

00:05:00.306 --> 00:05:02.336 A:middle
如何应用  我来举一个例子

00:05:02.506 --> 00:05:04.786 A:middle
这个媒体查询定义了两个样式

00:05:04.786 --> 00:05:06.406 A:middle
一个适用于从左往右(LTR)方向

00:05:06.406 --> 00:05:08.256 A:middle
另一个适用于从右往左(RTL)方向

00:05:09.356 --> 00:05:11.396 A:middle
这里设置 margin 时需要特意留心

00:05:11.396 --> 00:05:13.466 A:middle
依据语言书写方向

00:05:13.466 --> 00:05:15.106 A:middle
把水平向的左右外边距值

00:05:15.106 --> 00:05:16.016 A:middle
作相应对调

00:05:16.376 --> 00:05:17.556 A:middle
在这个例子中

00:05:17.556 --> 00:05:19.136 A:middle
我们给 margin 设置的值  12

00:05:19.186 --> 00:05:20.756 A:middle
就要写在正确的位置

00:05:21.216 --> 00:05:23.556 A:middle
页面布局就说到这里

00:05:23.556 --> 00:05:25.356 A:middle
那么文字对齐方向呢

00:05:26.216 --> 00:05:28.446 A:middle
我们通常习惯的是  统一设置

00:05:28.446 --> 00:05:30.436 A:middle
左对齐  居中  或者

00:05:30.436 --> 00:05:30.856 A:middle
右对齐

00:05:31.316 --> 00:05:32.526 A:middle
而我们看这个屏幕上的文字

00:05:32.526 --> 00:05:34.536 A:middle
其中分别有两种显示方式

00:05:34.536 --> 00:05:35.826 A:middle
看起来比其他的更自然

00:05:35.826 --> 00:05:37.676 A:middle
对于从左往右书写的文字

00:05:37.676 --> 00:05:39.086 A:middle
左对齐看起来自然

00:05:39.086 --> 00:05:40.776 A:middle
对于从右往左书写的文字

00:05:40.776 --> 00:05:42.066 A:middle
右对齐看起来自然

00:05:43.166 --> 00:05:45.216 A:middle
为此  我们专门

00:05:45.216 --> 00:05:46.436 A:middle
与市场团队碰头协商

00:05:46.436 --> 00:05:48.666 A:middle
思考了一下  究竟该如何

00:05:48.736 --> 00:05:50.256 A:middle
命名这种对齐方式

00:05:50.256 --> 00:05:51.596 A:middle
最终决定  采用一个新的值

00:05:51.596 --> 00:05:52.826 A:middle
叫作  自然对齐

00:05:53.716 --> 00:05:55.096 A:middle
自然对齐  效果和大家想象的

00:05:55.096 --> 00:05:55.936 A:middle
差不多

00:05:55.936 --> 00:05:57.616 A:middle
会根据大家应用程序的 UI 语言

00:05:57.616 --> 00:05:59.006 A:middle
对文字进行自然对齐

00:05:59.506 --> 00:05:59.956 A:middle
很简单

00:06:02.496 --> 00:06:04.156 A:middle
下面再说应用程序中的图片显示

00:06:04.156 --> 00:06:06.126 A:middle
大部分应用程序内采用的图片

00:06:06.126 --> 00:06:07.296 A:middle
都有一定普适性

00:06:07.386 --> 00:06:08.586 A:middle
不管页面如何布局  都可以

00:06:08.586 --> 00:06:09.566 A:middle
正常显示

00:06:10.146 --> 00:06:12.076 A:middle
但在个别情况下

00:06:12.076 --> 00:06:13.906 A:middle
某些图片会自带方向属性

00:06:13.906 --> 00:06:15.336 A:middle
比如这个表单项后面的

00:06:15.336 --> 00:06:15.956 A:middle
V 形标记

00:06:16.506 --> 00:06:17.636 A:middle
这种情况下

00:06:17.636 --> 00:06:18.706 A:middle
就需要确保 V 形箭头

00:06:18.706 --> 00:06:19.626 A:middle
指向正确的方向

00:06:19.626 --> 00:06:21.436 A:middle
不然整个列表页面就会

00:06:21.436 --> 00:06:22.896 A:middle
令人困惑  看起来也

00:06:22.896 --> 00:06:23.366 A:middle
很奇怪

00:06:24.226 --> 00:06:26.086 A:middle
要在应用程序中做到这种效果

00:06:26.086 --> 00:06:27.316 A:middle
有两种方法

00:06:27.626 --> 00:06:29.006 A:middle
一种是针对资源

00:06:29.006 --> 00:06:29.576 A:middle
图片

00:06:30.006 --> 00:06:31.186 A:middle
对于来自应用程序

00:06:31.186 --> 00:06:32.626 A:middle
捆绑包内部的图片

00:06:33.216 --> 00:06:35.916 A:middle
可通过图片资源目录 (Asset Catalogs)

00:06:35.916 --> 00:06:37.576 A:middle
来便捷地自定义

00:06:37.576 --> 00:06:39.706 A:middle
图片显示方向

00:06:39.706 --> 00:06:41.946 A:middle
可设置在所有布局下

00:06:41.946 --> 00:06:43.446 A:middle
图片显示固定不变

00:06:43.446 --> 00:06:45.066 A:middle
可像刚刚的 V 形标记

00:06:45.256 --> 00:06:46.946 A:middle
在运行时左右翻转显示

00:06:46.946 --> 00:06:48.486 A:middle
或是给每门语言都指定一张

00:06:48.486 --> 00:06:49.546 A:middle
单独的图片

00:06:51.526 --> 00:06:53.896 A:middle
对于来自于服务器上的图片

00:06:53.896 --> 00:06:56.916 A:middle
我们引入了一个全新的属性

00:06:56.916 --> 00:06:58.246 A:middle
可以用来定义图片元素

00:06:58.246 --> 00:06:59.396 A:middle
这个属性就叫作

00:06:59.396 --> 00:06:59.906 A:middle
Source Set

00:07:01.226 --> 00:07:02.376 A:middle
Source Set 可针对

00:07:02.376 --> 00:07:04.906 A:middle
某给定的布局方向设置一个

00:07:04.906 --> 00:07:05.706 A:middle
既定的图片 URL

00:07:06.596 --> 00:07:07.826 A:middle
Source Set 还有一个好处

00:07:07.826 --> 00:07:09.116 A:middle
就是  我们也可以通过

00:07:09.116 --> 00:07:10.706 A:middle
设置 Source Set 属性来调整

00:07:10.706 --> 00:07:11.336 A:middle
明暗度

00:07:12.006 --> 00:07:15.346 A:middle
在这个例子中  当布局方向是 LTR 时

00:07:15.486 --> 00:07:17.126 A:middle
就会载入 URL1 链接中的图片

00:07:17.896 --> 00:07:20.046 A:middle
而当布局方向是 RTL 时

00:07:20.046 --> 00:07:21.296 A:middle
就会载入 URL2 图片

00:07:21.296 --> 00:07:23.306 A:middle
通过这种方法

00:07:23.306 --> 00:07:24.856 A:middle
可以指定显示某张图片

00:07:24.856 --> 00:07:26.406 A:middle
运行时就会产出

00:07:26.406 --> 00:07:29.006 A:middle
正确的结果

00:07:29.096 --> 00:07:30.476 A:middle
好了  现在看我们

00:07:30.476 --> 00:07:31.846 A:middle
能不能综合以上谈到的所有点

00:07:31.846 --> 00:07:33.026 A:middle
糅合在一个小程序里

00:07:33.026 --> 00:07:33.706 A:middle
我做了一个样本给大家

00:07:33.706 --> 00:07:33.936 A:middle
看看

00:07:44.386 --> 00:07:45.876 A:middle
我之前一直在做一个应用程序

00:07:45.876 --> 00:07:48.186 A:middle
来展示去年 WWDC

00:07:48.186 --> 00:07:49.516 A:middle
会上的演讲

00:07:49.516 --> 00:07:51.096 A:middle
我现在跟大家分享一下

00:07:51.096 --> 00:07:51.506 A:middle
这个程序

00:08:02.316 --> 00:08:03.436 A:middle
这个页面里  我们可以看到

00:08:03.436 --> 00:08:05.346 A:middle
呈网格 (grid) 排列的往期演讲

00:08:05.346 --> 00:08:06.656 A:middle
顶端我设置了一个横幅

00:08:06.656 --> 00:08:07.976 A:middle
来进行置顶推荐

00:08:09.036 --> 00:08:11.026 A:middle
在正式让我的应用支持

00:08:11.026 --> 00:08:12.106 A:middle
从右往左书写语言之前

00:08:12.106 --> 00:08:14.116 A:middle
不去设置里添加本地化语言

00:08:14.116 --> 00:08:15.026 A:middle
也可以做一些此方面的

00:08:15.026 --> 00:08:15.786 A:middle
其他尝试

00:08:16.926 --> 00:08:21.056 A:middle
我们可以去 edit scheme 下

00:08:21.136 --> 00:08:22.966 A:middle
在 run option 的下拉菜单中

00:08:22.966 --> 00:08:24.826 A:middle
可以把应用程序

00:08:24.826 --> 00:08:25.966 A:middle
的系统语言

00:08:25.966 --> 00:08:27.286 A:middle
改为从右往左的伪码

00:08:27.836 --> 00:08:29.476 A:middle
设置后就可以模拟

00:08:29.476 --> 00:08:30.366 A:middle
程序在从右往左

00:08:30.366 --> 00:08:31.796 A:middle
语言环境中的效果

00:08:31.796 --> 00:08:32.996 A:middle
而项目本身不用做

00:08:32.996 --> 00:08:33.645 A:middle
任何改动

00:08:34.856 --> 00:08:36.466 A:middle
现在再编译并运行的话

00:08:36.946 --> 00:08:38.466 A:middle
就能看到  网格布局变成了

00:08:38.466 --> 00:08:39.395 A:middle
从右往左排布

00:08:39.816 --> 00:08:41.635 A:middle
又因为我们使用了网格布局

00:08:41.635 --> 00:08:42.976 A:middle
这些效果支持都是模版

00:08:42.976 --> 00:08:43.696 A:middle
免费自带的

00:08:44.126 --> 00:08:45.616 A:middle
但是因为我的横幅

00:08:45.616 --> 00:08:47.146 A:middle
是我自己自定义的样式

00:08:47.146 --> 00:08:48.816 A:middle
所以看起来这一部分还需要

00:08:48.816 --> 00:08:49.426 A:middle
我再去调试一下

00:08:49.936 --> 00:08:51.436 A:middle
现在就让我们尝试使用

00:08:51.436 --> 00:08:53.746 A:middle
tvOS 11 中的新 API 来调整

00:08:53.746 --> 00:08:54.196 A:middle
一下

00:08:55.836 --> 00:08:57.056 A:middle
首先我要做的一件事  就是

00:08:57.056 --> 00:08:59.126 A:middle
检查我 TVML 里定义的样式

00:08:59.126 --> 00:09:01.126 A:middle
然后把所有规定死的

00:08:59.126 --> 00:09:01.126 A:middle
然后把所有规定死的

00:09:01.226 --> 00:09:03.936 A:middle
left  都替换成 leading

00:09:03.936 --> 00:09:05.656 A:middle
在我所用的开发语言环境下

00:09:05.656 --> 00:09:07.036 A:middle
leading 也就是屏幕左侧 (left)

00:09:08.386 --> 00:09:09.836 A:middle
同样的  也把所有的

00:09:09.836 --> 00:09:11.776 A:middle
right 都替换成 trailing

00:09:14.156 --> 00:09:15.636 A:middle
现在我们再编译并运行应用程序

00:09:15.686 --> 00:09:17.176 A:middle
应该会看到改进后有什么

00:09:17.176 --> 00:09:17.816 A:middle
不同

00:09:19.696 --> 00:09:21.736 A:middle
很好  看起来文字布局

00:09:21.736 --> 00:09:22.676 A:middle
都翻到了屏幕另一边

00:09:22.676 --> 00:09:24.366 A:middle
页面上的播放按钮

00:09:24.366 --> 00:09:25.366 A:middle
也在正确的位置

00:09:25.676 --> 00:09:27.356 A:middle
但播放按钮看起来

00:09:27.356 --> 00:09:29.896 A:middle
离边框有点太近了

00:09:30.116 --> 00:09:31.996 A:middle
查看一下代码样式就发现

00:09:31.996 --> 00:09:33.626 A:middle
我为 bannerPlayButtonLockup 单独

00:09:33.626 --> 00:09:34.766 A:middle
设置了 margin  但定义的

00:09:34.766 --> 00:09:35.706 A:middle
是元素的右边距

00:09:36.016 --> 00:09:37.426 A:middle
我们需要对此进行调整

00:09:37.426 --> 00:09:38.656 A:middle
使得我们切换为从右往左语言模式后

00:09:38.656 --> 00:09:39.626 A:middle
margin 赋值也相应对调

00:09:41.096 --> 00:09:43.116 A:middle
为了节省时间  我这里插入

00:09:43.116 --> 00:09:44.686 A:middle
我预先写好的一个片段

00:09:44.686 --> 00:09:46.496 A:middle
这里为 bannerPlayButtonLockup 定义了

00:09:46.496 --> 00:09:48.686 A:middle
LTR 和 RTL  两个情况下的媒体查询

00:09:48.816 --> 00:09:51.576 A:middle
我只需把原先定义好的 margin

00:09:51.576 --> 00:09:54.646 A:middle
移动到 LTR 媒体查询下

00:09:55.436 --> 00:09:57.326 A:middle
然后在 RTL 的媒体查询里

00:09:57.326 --> 00:09:59.036 A:middle
把右边距60调换成左边距

00:09:59.416 --> 00:10:00.276 A:middle
就行了

00:09:59.416 --> 00:10:00.276 A:middle
就行了

00:10:02.916 --> 00:10:05.896 A:middle
现在我们再编译并运行一下

00:10:05.896 --> 00:10:07.076 A:middle
这下播放按钮的 padding 就看起来

00:10:07.076 --> 00:10:07.636 A:middle
正常多了

00:10:08.146 --> 00:10:09.876 A:middle
现在页面布局完成得差不多了

00:10:09.876 --> 00:10:11.356 A:middle
但再看一下这个界面

00:10:11.356 --> 00:10:12.766 A:middle
我们发现  当横幅文字被移到

00:10:12.766 --> 00:10:13.406 A:middle
右边后

00:10:13.406 --> 00:10:14.826 A:middle
背后正好和图片内容重合

00:10:14.826 --> 00:10:16.126 A:middle
这样文字就不太容易阅读

00:10:17.166 --> 00:10:18.426 A:middle
这时网页设计师给了我

00:10:18.426 --> 00:10:19.826 A:middle
一张左右翻转的图片

00:10:19.826 --> 00:10:21.176 A:middle
可以用在从右往左布局的页面里

00:10:21.486 --> 00:10:23.006 A:middle
我就可以用图片资源目录 (Asset Catalogs)

00:10:23.006 --> 00:10:24.756 A:middle
把这张图片加到项目里

00:10:25.556 --> 00:10:26.966 A:middle
在我的这个图片资源目录里

00:10:26.966 --> 00:10:28.436 A:middle
当前只为横幅指定了

00:10:28.436 --> 00:10:29.906 A:middle
一张图片

00:10:29.906 --> 00:10:31.796 A:middle
我可以在 Attribute Inspector 里

00:10:31.796 --> 00:10:33.416 A:middle
把布局方向从 fixed (固定) 改为

00:10:33.626 --> 00:10:34.106 A:middle
both (双向)

00:10:34.846 --> 00:10:36.346 A:middle
这样设置后  就会出现预留空位

00:10:36.346 --> 00:10:37.576 A:middle
把需要在从右往左布局中使用的

00:10:37.576 --> 00:10:38.696 A:middle
左右翻转的图片  拖拽到空位上

00:10:38.696 --> 00:10:39.146 A:middle
就可以了

00:10:40.656 --> 00:10:44.366 A:middle
现在我就拖拽过来

00:10:44.596 --> 00:10:46.036 A:middle
最后再编译并运行一下我的应用程序

00:10:50.436 --> 00:10:51.306 A:middle
这就是调试结果了

00:10:51.586 --> 00:10:52.996 A:middle
只需进行一些很小的改动

00:10:52.996 --> 00:10:54.536 A:middle
我们的应用程序就可以完美支持

00:10:54.536 --> 00:10:55.516 A:middle
从右往左布局了

00:10:55.516 --> 00:11:01.396 A:middle
[掌声]

00:10:55.516 --> 00:11:01.396 A:middle
[掌声]

00:11:01.896 --> 00:11:04.076 A:middle
总结一下  就像大家所见

00:11:04.076 --> 00:11:05.276 A:middle
只需对程序进行一些很小的改动

00:11:05.586 --> 00:11:06.866 A:middle
大部分工作都可以由默认模版中

00:11:06.866 --> 00:11:08.536 A:middle
自带的免费技术支持来完成

00:11:08.536 --> 00:11:09.956 A:middle
很轻松  就能让我们的程序

00:11:09.956 --> 00:11:10.916 A:middle
支持从右往左书写文字

00:11:10.916 --> 00:11:12.606 A:middle
我们需要做的编程改动

00:11:12.606 --> 00:11:13.386 A:middle
非常少

00:11:13.926 --> 00:11:15.356 A:middle
同时  从右往左的伪码也是一个

00:11:15.356 --> 00:11:16.366 A:middle
非常强大的工具

00:11:16.366 --> 00:11:17.626 A:middle
我们可以在不懂任何

00:11:17.626 --> 00:11:19.036 A:middle
从右往左书写语言的情况下

00:11:19.036 --> 00:11:20.566 A:middle
通过伪码模拟  查看程序

00:11:20.566 --> 00:11:21.806 A:middle
在从右往左布局下的

00:11:21.806 --> 00:11:22.286 A:middle
显示效果

00:11:23.196 --> 00:11:25.116 A:middle
还有再多说一点  如果你的应用

00:11:25.116 --> 00:11:26.356 A:middle
要使用自定义试图

00:11:26.356 --> 00:11:28.746 A:middle
我们的 AutoLayout Engine 里

00:11:28.746 --> 00:11:30.336 A:middle
还有一系列约束 (constraint)

00:11:30.336 --> 00:11:32.076 A:middle
这些约束  功能非常强大

00:11:32.076 --> 00:11:34.496 A:middle
可以帮助你们优化从右往左书写

00:11:34.496 --> 00:11:35.606 A:middle
语言模式下的布局

00:11:36.366 --> 00:11:38.066 A:middle
我们还有一个基于 API 的

00:11:38.066 --> 00:11:39.346 A:middle
布局方向属性  返回的结果

00:11:39.346 --> 00:11:40.686 A:middle
可以显示运行时

00:11:40.686 --> 00:11:42.186 A:middle
你是在一个从左往右

00:11:42.186 --> 00:11:43.446 A:middle
还是从右往左的布局

00:11:43.856 --> 00:11:45.396 A:middle
在做动画帧的屏幕

00:11:45.456 --> 00:11:46.986 A:middle
自适应运算时  这个功能

00:11:46.986 --> 00:11:47.486 A:middle
会很有用

00:11:48.486 --> 00:11:50.086 A:middle
了解从右往左书写语言的布局的

00:11:50.086 --> 00:11:52.016 A:middle
更多细节  或是

00:11:52.016 --> 00:11:52.926 A:middle
想要深入了解相关信息

00:11:52.926 --> 00:11:54.316 A:middle
我推荐大家去听去年的

00:11:54.316 --> 00:11:55.436 A:middle
两场相关演讲

00:11:55.656 --> 00:11:56.826 A:middle
Internationalization Best

00:11:56.826 --> 00:11:58.396 A:middle
Practices 和 What's New In

00:11:58.396 --> 00:11:59.846 A:middle
International User Interfaces

00:12:01.756 --> 00:12:03.756 A:middle
我迫不及待在今年秋天的时候

00:12:03.756 --> 00:12:04.706 A:middle
能看到你们的应用程序

00:12:04.706 --> 00:12:06.186 A:middle
开始支持从右往左的语言布局

00:12:06.696 --> 00:12:07.746 A:middle
下面有请 Parry

00:12:07.746 --> 00:12:08.826 A:middle
为大家介绍模版优化项目

00:12:09.026 --> 00:12:09.386 A:middle
谢谢大家

00:12:10.516 --> 00:12:12.546 A:middle
[掌声]

00:12:13.046 --> 00:12:14.896 A:middle
&gt;&gt; 谢谢 Trevor

00:12:14.896 --> 00:12:16.406 A:middle
大家好  我是 Parry

00:12:16.676 --> 00:12:17.676 A:middle
下面我将给大家介绍

00:12:17.676 --> 00:12:18.996 A:middle
我们对模版进行的一些改进

00:12:18.996 --> 00:12:20.496 A:middle
这些改进将会提高你们

00:12:20.496 --> 00:12:21.656 A:middle
应用程序的运行性能

00:12:21.696 --> 00:12:23.346 A:middle
既可以优化响应时间

00:12:23.466 --> 00:12:23.936 A:middle
又可以减少内存占用

00:12:24.836 --> 00:12:26.426 A:middle
如果你用 TVMLKit 做过应用程序

00:12:26.426 --> 00:12:28.166 A:middle
那么也许已经注意到

00:12:28.166 --> 00:12:29.656 A:middle
当我们试图往模版里

00:12:29.656 --> 00:12:31.676 A:middle
添加更多内容的时候

00:12:31.676 --> 00:12:33.406 A:middle
模版性能会逐渐降低

00:12:33.546 --> 00:12:34.396 A:middle
让我用一个例子给大家演示

00:12:34.396 --> 00:12:34.816 A:middle
一下

00:12:36.076 --> 00:12:37.756 A:middle
我和 Trevor 一起

00:12:37.756 --> 00:12:40.246 A:middle
在开发这个 WWDC 的样本程序

00:12:40.246 --> 00:12:43.066 A:middle
我希望这个应用程序能搭载

00:12:43.066 --> 00:12:44.156 A:middle
所有的往期演讲

00:12:44.156 --> 00:12:45.236 A:middle
而不是只有去年的

00:12:45.236 --> 00:12:45.586 A:middle
演讲

00:12:46.016 --> 00:12:47.506 A:middle
我们依然维持简洁的页面设计

00:12:48.236 --> 00:12:50.036 A:middle
用网格 (grid) 来展示所有

00:12:50.036 --> 00:12:50.606 A:middle
演讲

00:12:51.096 --> 00:12:52.606 A:middle
每个演讲都由一个 lockup 元素来代表

00:12:52.606 --> 00:12:55.686 A:middle
其中包括一张图片

00:12:55.906 --> 00:12:56.426 A:middle
和一个文字标题

00:12:56.426 --> 00:12:58.716 A:middle
大家可以想象  要展示的全部内容

00:12:58.716 --> 00:12:59.806 A:middle
会包括上千个像这样的

00:12:59.806 --> 00:13:00.506 A:middle
视频

00:12:59.806 --> 00:13:00.506 A:middle
视频

00:13:01.126 --> 00:13:02.426 A:middle
所以一般针对这种典型情况

00:13:02.426 --> 00:13:03.986 A:middle
我们不希望这个页面  一上来

00:13:03.986 --> 00:13:05.596 A:middle
就显示出所有内容

00:13:05.596 --> 00:13:07.026 A:middle
因为首先  一下全部显示出来

00:13:07.026 --> 00:13:09.196 A:middle
加载时间太长  而第二

00:13:09.196 --> 00:13:10.606 A:middle
很有可能根本无法一下全部显示

00:13:10.606 --> 00:13:11.876 A:middle
那还要看你的服务器是否能够

00:13:11.876 --> 00:13:12.316 A:middle
支持

00:13:13.066 --> 00:13:14.846 A:middle
所以我们就需要给数据进行分页 (paginate)

00:13:14.846 --> 00:13:15.396 A:middle
处理

00:13:15.856 --> 00:13:17.036 A:middle
可以先显示一小部分

00:13:17.036 --> 00:13:18.856 A:middle
比方说 500 个项目

00:13:18.856 --> 00:13:20.626 A:middle
然后等用户滚动到

00:13:20.626 --> 00:13:22.516 A:middle
接近内容末尾时

00:13:22.516 --> 00:13:23.826 A:middle
再不断加载下一部分内容

00:13:25.056 --> 00:13:26.916 A:middle
我们针对这种情形做了

00:13:26.916 --> 00:13:28.586 A:middle
一个性能分析

00:13:28.946 --> 00:13:30.076 A:middle
结果差不多如图

00:13:31.636 --> 00:13:33.766 A:middle
这张图上显示的是

00:13:33.766 --> 00:13:35.866 A:middle
编译一个含有一定数量

00:13:35.866 --> 00:13:36.996 A:middle
项目的模版  需要多长时间

00:13:36.996 --> 00:13:40.786 A:middle
我们可以看到  这张图里

00:13:40.786 --> 00:13:42.056 A:middle
位于 X 轴上的数值

00:13:42.056 --> 00:13:43.736 A:middle
代表着模版中项目的数量

00:13:43.736 --> 00:13:45.126 A:middle
而 Y 轴数值  代表显示出这么多项目

00:13:45.126 --> 00:13:45.796 A:middle
所需要的时间

00:13:46.506 --> 00:13:48.346 A:middle
我们从图中可以看出

00:13:48.346 --> 00:13:49.426 A:middle
花费时间呈指数增长

00:13:50.596 --> 00:13:51.926 A:middle
也就是说  随着模版

00:13:51.926 --> 00:13:53.586 A:middle
体量增大  要加载同样多

00:13:53.586 --> 00:13:55.526 A:middle
数量的项目  就需要花费

00:13:55.526 --> 00:13:56.306 A:middle
更多的时间

00:13:56.306 --> 00:13:58.726 A:middle
这又是为什么呢

00:13:59.476 --> 00:14:01.236 A:middle
一个很重要的影响因素

00:13:59.476 --> 00:14:01.236 A:middle
一个很重要的影响因素

00:14:01.496 --> 00:14:02.876 A:middle
就是这些模版里

00:14:02.876 --> 00:14:04.426 A:middle
文档对象模型 (DOM) 的

00:14:04.456 --> 00:14:04.936 A:middle
大小

00:14:05.416 --> 00:14:06.786 A:middle
这个问题有两方面

00:14:07.686 --> 00:14:08.946 A:middle
一方面是

00:14:08.946 --> 00:14:09.786 A:middle
存在多余的模板语法解析

00:14:10.086 --> 00:14:11.816 A:middle
首先  是在你的 JavaScript 里

00:14:11.816 --> 00:14:13.076 A:middle
要把数据解析到 DOM 树里

00:14:13.076 --> 00:14:15.016 A:middle
这样  当 DOM 树越来越大

00:14:15.016 --> 00:14:16.376 A:middle
要添加新的东西进去

00:14:16.376 --> 00:14:18.356 A:middle
就需要花更多的时间

00:14:18.356 --> 00:14:20.486 A:middle
然后  TVMLKit 还得解析 DOM

00:14:20.486 --> 00:14:21.616 A:middle
来计算出显示布局

00:14:21.616 --> 00:14:24.156 A:middle
所需信息  比如内容格大小

00:14:24.266 --> 00:14:26.156 A:middle
行距  甚至滚动

00:14:26.156 --> 00:14:26.616 A:middle
偏移量

00:14:27.106 --> 00:14:28.316 A:middle
上述这些参数   会让你们的

00:14:28.316 --> 00:14:29.976 A:middle
TVMLKit 程序界面看起来非常漂亮

00:14:30.966 --> 00:14:32.096 A:middle
但可以想象的是

00:14:32.096 --> 00:14:33.966 A:middle
DOM 树越大  完成这些

00:14:33.966 --> 00:14:35.346 A:middle
计算所需的时间

00:14:35.346 --> 00:14:35.826 A:middle
就越长

00:14:37.226 --> 00:14:39.886 A:middle
而另一方面  DOM 树越来越大

00:14:39.886 --> 00:14:41.626 A:middle
对内存的压力也会越来越大

00:14:41.626 --> 00:14:42.926 A:middle
这就会整体拖慢

00:14:42.926 --> 00:14:44.656 A:middle
你应用程序的响应

00:14:44.656 --> 00:14:44.976 A:middle
时间

00:14:47.186 --> 00:14:49.506 A:middle
为了解决响应时间和内存占用问题

00:14:49.506 --> 00:14:52.386 A:middle
在 tvOS 11 中  我们引入了一个全新的

00:14:52.386 --> 00:14:54.296 A:middle
模版定义范式

00:14:54.296 --> 00:14:56.446 A:middle
新方法采用原型 (Prototype)

00:14:56.626 --> 00:14:59.396 A:middle
加数据绑定 (Data Binding) 来构建模版

00:14:59.396 --> 00:15:00.976 A:middle
此方法可以显著降低 DOM 树大小

00:14:59.396 --> 00:15:00.976 A:middle
此方法可以显著降低 DOM 树大小

00:15:01.016 --> 00:15:02.786 A:middle
从而提高大家

00:15:02.786 --> 00:15:05.526 A:middle
应用程序的性能  除此之外

00:15:05.526 --> 00:15:07.386 A:middle
我们还增加了一些 API

00:15:07.386 --> 00:15:08.336 A:middle
来支持数据分页

00:15:09.286 --> 00:15:10.246 A:middle
下面我们详细讨论

00:15:10.246 --> 00:15:10.586 A:middle
一下

00:15:12.036 --> 00:15:13.996 A:middle
为了方便大家理解原型

00:15:13.996 --> 00:15:15.786 A:middle
到底是什么  我先给大家

00:15:15.786 --> 00:15:17.486 A:middle
讲一下  一个典型的模版

00:15:17.486 --> 00:15:18.336 A:middle
构建过程

00:15:18.916 --> 00:15:20.296 A:middle
最开始  在我们手上的

00:15:20.296 --> 00:15:22.776 A:middle
是你服务器上的数据  和一个模版

00:15:22.776 --> 00:15:23.336 A:middle
的空壳

00:15:23.336 --> 00:15:24.456 A:middle
针对我们这个程序  是个网格模版

00:15:24.456 --> 00:15:27.086 A:middle
然后根据 JavaScript

00:15:27.086 --> 00:15:27.886 A:middle
我们需要把

00:15:27.886 --> 00:15:30.936 A:middle
JavaScript 里的对象都逐一

00:15:30.936 --> 00:15:32.446 A:middle
翻译成相对应的 TVML

00:15:32.446 --> 00:15:33.096 A:middle
语言

00:15:33.496 --> 00:15:35.056 A:middle
在我们这个应用里  翻成 lockup

00:15:36.086 --> 00:15:37.866 A:middle
做完这一步之后

00:15:37.866 --> 00:15:40.736 A:middle
再把这些都转化成 DOM 树

00:15:40.736 --> 00:15:42.296 A:middle
然后 TVMLKit 就可以开始

00:15:42.296 --> 00:15:43.386 A:middle
生成 UI 了

00:15:44.056 --> 00:15:46.286 A:middle
但如果我们仔细研究一下代码

00:15:46.286 --> 00:15:47.826 A:middle
就会发现  这些 lockup 之间

00:15:47.826 --> 00:15:49.016 A:middle
相似度非常高

00:15:49.016 --> 00:15:51.736 A:middle
实际上这些 lockup 之间  唯一不同的

00:15:51.826 --> 00:15:52.856 A:middle
地方  就是它们各自

00:15:52.856 --> 00:15:53.846 A:middle
从数据中解析来的值

00:15:56.796 --> 00:15:58.606 A:middle
如果我们去除这些值

00:15:59.076 --> 00:16:00.806 A:middle
剩下的就是一些

00:15:59.076 --> 00:16:00.806 A:middle
剩下的就是一些

00:16:00.876 --> 00:16:03.756 A:middle
完全一样的 lockup

00:16:03.756 --> 00:16:05.326 A:middle
其中任何一个  所包含的信息

00:16:05.326 --> 00:16:07.386 A:middle
就已经足够 TVMLKit 预先计算出

00:16:07.386 --> 00:16:08.306 A:middle
如何布局页面了

00:16:09.216 --> 00:16:10.856 A:middle
所以  其实我们并不需要

00:16:10.856 --> 00:16:12.706 A:middle
写这么多个 lockup

00:16:12.706 --> 00:16:14.146 A:middle
写一个就够了

00:16:14.466 --> 00:16:15.896 A:middle
而提炼出的这个骨架  就是一个

00:16:15.896 --> 00:16:16.586 A:middle
原型了

00:16:17.596 --> 00:16:20.306 A:middle
所以简单说  原型就是个针对

00:16:20.306 --> 00:16:22.386 A:middle
数据对象的 TVML 语言纲要

00:16:22.386 --> 00:16:24.196 A:middle
TVMLKit 可利用这一纲要

00:16:24.196 --> 00:16:26.636 A:middle
预先计算布局  然后在

00:16:26.636 --> 00:16:28.116 A:middle
运行时  再和数据

00:16:28.116 --> 00:16:30.786 A:middle
进行结合  自动帮你创建 DOM 树

00:16:30.786 --> 00:16:32.266 A:middle
但只解析它所需要的那一部分

00:16:32.266 --> 00:16:34.056 A:middle
且只在需要的时候才解析

00:16:34.876 --> 00:16:36.616 A:middle
这样就可以控制 DOM 树较小

00:16:36.926 --> 00:16:38.476 A:middle
且大小独立  不随数据变多而增长

00:16:40.386 --> 00:16:42.836 A:middle
当然  如果一个模版里

00:16:42.836 --> 00:16:44.166 A:middle
只有原型  还不完整

00:16:44.166 --> 00:16:45.776 A:middle
我们还需要给模版

00:16:45.776 --> 00:16:46.546 A:middle
提供数据

00:16:47.696 --> 00:16:49.036 A:middle
但除了提供数据

00:16:49.036 --> 00:16:51.146 A:middle
我们还需要把模版

00:16:51.146 --> 00:16:52.936 A:middle
和数据关联起来

00:16:53.226 --> 00:16:54.826 A:middle
这样 TVMLKit 才能

00:16:54.936 --> 00:16:56.756 A:middle
解析你的数据

00:16:56.756 --> 00:16:58.016 A:middle
并且帮你完成模版构建

00:16:58.746 --> 00:17:01.736 A:middle
这一关联过程就要靠数据绑定

00:16:58.746 --> 00:17:01.736 A:middle
这一关联过程就要靠数据绑定

00:17:01.736 --> 00:17:02.176 A:middle
来完成

00:17:03.696 --> 00:17:05.976 A:middle
要在 tvOS 11 里

00:17:05.976 --> 00:17:07.746 A:middle
给模版绑定数据  一共有

00:17:08.056 --> 00:17:09.116 A:middle
三种方法

00:17:09.705 --> 00:17:12.546 A:middle
首先  可以给一个元素的来源

00:17:12.665 --> 00:17:13.806 A:middle
绑定属性

00:17:14.086 --> 00:17:15.425 A:middle
这个例子里  就给

00:17:15.425 --> 00:17:17.286 A:middle
图像元素的来源属性

00:17:17.665 --> 00:17:18.776 A:middle
绑定了数据中的

00:17:18.776 --> 00:17:19.646 A:middle
URL 属性

00:17:20.896 --> 00:17:22.665 A:middle
我们还可以对一个元素的文字内容

00:17:22.665 --> 00:17:23.955 A:middle
进行绑定

00:17:23.955 --> 00:17:25.856 A:middle
这个例子里  就给 title 元素的

00:17:26.146 --> 00:17:28.046 A:middle
文字内容 (textContent) 绑定了

00:17:28.046 --> 00:17:29.526 A:middle
数据中的 title 属性

00:17:30.646 --> 00:17:33.106 A:middle
最后  我们还可以把一个组件

00:17:33.106 --> 00:17:35.966 A:middle
中的某些项目绑定

00:17:35.966 --> 00:17:36.346 A:middle
对象

00:17:37.416 --> 00:17:38.906 A:middle
我们可以将组件中的

00:17:38.906 --> 00:17:40.156 A:middle
试验 DOM 元素

00:17:40.156 --> 00:17:41.356 A:middle
和一系列对象进行

00:17:41.356 --> 00:17:41.986 A:middle
绑定

00:17:44.546 --> 00:17:46.786 A:middle
所以简单说  数据绑定

00:17:46.786 --> 00:17:47.886 A:middle
就是一种链接  用来关联

00:17:47.936 --> 00:17:48.656 A:middle
TVML 属性和数据属性

00:17:48.926 --> 00:17:49.796 A:middle
这种关联  可以在 TVML 里

00:17:49.826 --> 00:17:50.606 A:middle
利用一个绑定属性

00:17:50.636 --> 00:17:51.086 A:middle
来直接指定

00:17:51.116 --> 00:17:51.896 A:middle
说到为 TVMLKit 提供数据

00:17:51.926 --> 00:17:52.796 A:middle
我们还可以在 JavaScript 里

00:17:52.826 --> 00:17:53.666 A:middle
用 DataItem 来实现这一点

00:17:53.696 --> 00:17:54.476 A:middle
这是我们对 DOM 元素

00:17:54.506 --> 00:17:55.286 A:middle
引入的一个新属性

00:17:55.316 --> 00:17:55.856 A:middle
我来举个例子

00:17:55.886 --> 00:17:56.516 A:middle
我们读取 JSON

00:17:56.546 --> 00:17:57.296 A:middle
将数据转换为 JavaScript 对象

00:17:57.326 --> 00:17:58.166 A:middle
然后再用 DataItem 属性

00:17:58.196 --> 00:17:58.976 A:middle
把该对象关联到组件元素上

00:18:01.456 --> 00:18:02.996 A:middle
好了  我们接下来说

00:18:02.996 --> 00:18:03.656 A:middle
分页

00:18:03.656 --> 00:18:06.046 A:middle
在 tvOS 11 里  我们引入了

00:18:06.686 --> 00:18:08.386 A:middle
一个新事件叫作 Needs More

00:18:08.386 --> 00:18:09.986 A:middle
用这个事件  我们可以很方便地

00:18:09.986 --> 00:18:10.986 A:middle
对数据进行分页

00:18:11.026 --> 00:18:13.666 A:middle
当用户滚动到

00:18:13.816 --> 00:18:15.586 A:middle
接近页面内容末尾时

00:18:15.586 --> 00:18:18.886 A:middle
就会触发这一事件  可应用范围

00:18:18.886 --> 00:18:20.676 A:middle
包括 list  shelf  grid

00:18:26.756 --> 00:18:28.416 A:middle
甚至 stackTemplate

00:18:29.246 --> 00:18:32.266 A:middle
用途广泛  且几乎可以应用到

00:18:32.266 --> 00:18:33.086 A:middle
任何模版上

00:18:33.356 --> 00:18:35.416 A:middle
但要注意的是

00:18:35.416 --> 00:18:37.696 A:middle
如果要在数据绑定模板中

00:18:37.696 --> 00:18:40.676 A:middle
进行分页  还需要给数据

00:18:40.676 --> 00:18:41.946 A:middle
创建可观察对象

00:18:42.766 --> 00:18:45.436 A:middle
这样 TVMLKit 才能观察监听到

00:18:45.616 --> 00:18:47.176 A:middle
你对数据做出的改动

00:18:47.176 --> 00:18:49.556 A:middle
并在发生变动后  主动更新

00:18:50.406 --> 00:18:51.916 A:middle
UI 界面

00:18:52.196 --> 00:18:54.286 A:middle
让我们看一个   如何创建

00:18:54.706 --> 00:18:57.976 A:middle
这些可观察对象的例子

00:18:57.976 --> 00:19:00.006 A:middle
开头的地方都一样

00:18:57.976 --> 00:19:00.006 A:middle
开头的地方都一样

00:19:00.146 --> 00:19:04.216 A:middle
解析 JSON 成为一个

00:19:04.216 --> 00:19:08.756 A:middle
JavaScript 对象  但接下来

00:19:08.756 --> 00:19:11.176 A:middle
要遍历每一个对象

00:19:11.176 --> 00:19:17.486 A:middle
把它们映射为一个

00:19:17.486 --> 00:19:19.176 A:middle
DataItem 类

00:19:19.316 --> 00:19:22.406 A:middle
这一项也是 tvOS 11

00:19:22.406 --> 00:19:25.416 A:middle
里介绍过的  本身

00:19:25.416 --> 00:19:27.046 A:middle
自带观察者模式

00:19:28.656 --> 00:19:30.096 A:middle
我们创建 dataItem 时

00:19:30.096 --> 00:19:31.686 A:middle
把它设置为可选类型

00:19:31.686 --> 00:19:32.876 A:middle
这样万一你希望模版中

00:19:32.876 --> 00:19:35.166 A:middle
有多个原型  也可以

00:19:35.166 --> 00:19:38.326 A:middle
还要规定识别码

00:19:38.326 --> 00:19:39.936 A:middle
TVMLKit 可以利用这个识别码

00:19:39.936 --> 00:19:41.906 A:middle
更高效地把更新推到

00:19:41.906 --> 00:19:42.516 A:middle
UI 上

00:19:43.846 --> 00:19:45.566 A:middle
映射完成后

00:19:45.566 --> 00:19:47.156 A:middle
还要把这个 DataItem 类

00:19:47.156 --> 00:19:48.596 A:middle
包在另一个 sectionDataItem 里

00:19:49.426 --> 00:19:51.946 A:middle
最终才是  把这个 sectionDataItem 关联到

00:19:52.736 --> 00:19:53.366 A:middle
元素上

00:19:53.806 --> 00:19:57.546 A:middle
我们举个例子来看看如何

00:19:57.546 --> 00:19:58.516 A:middle
处理 Needs More

00:19:59.636 --> 00:20:01.226 A:middle
Needs More 和其他事件

00:19:59.636 --> 00:20:01.226 A:middle
Needs More 和其他事件

00:20:01.226 --> 00:20:01.976 A:middle
一样

00:20:02.046 --> 00:20:03.806 A:middle
我们可以用

00:20:03.806 --> 00:20:05.776 A:middle
Add Event Listener 方法

00:20:05.776 --> 00:20:07.846 A:middle
来监听一个 DOM 元素

00:20:07.846 --> 00:20:10.516 A:middle
再提供一个函数

00:20:10.516 --> 00:20:11.976 A:middle
这个函数执行起来

00:20:11.976 --> 00:20:13.576 A:middle
和新构建一个模板

00:20:13.576 --> 00:20:13.986 A:middle
差不多

00:20:14.176 --> 00:20:16.216 A:middle
从数据库提取数据

00:20:16.216 --> 00:20:18.296 A:middle
映射为 DataItem 类

00:20:18.296 --> 00:20:21.376 A:middle
但最后一步

00:20:21.376 --> 00:20:23.066 A:middle
不是把这些 DataItem

00:20:23.066 --> 00:20:24.156 A:middle
直接关联到元素上

00:20:24.156 --> 00:20:26.006 A:middle
而是插入到已有元素的末尾

00:20:26.746 --> 00:20:28.266 A:middle
完成以上这些操作之后
And once you've done that, you

00:20:28.266 --> 00:20:30.196 A:middle
再对 DataItem 类调用

00:20:30.246 --> 00:20:32.216 A:middle
Touch Property Path Method

00:20:32.216 --> 00:20:33.466 A:middle
把你数据更新推到

00:20:33.466 --> 00:20:33.956 A:middle
UI 上

00:20:35.496 --> 00:20:37.036 A:middle
现在我们综合以上讲到的

00:20:37.036 --> 00:20:42.096 A:middle
用程序给大家示范一下

00:20:42.256 --> 00:20:44.166 A:middle
刚刚 Trevor 给大家演示的时候

00:20:44.166 --> 00:20:45.366 A:middle
我在他样本程序

00:20:45.366 --> 00:20:47.376 A:middle
的脚本里添加了代码  进行了

00:20:47.376 --> 00:20:47.966 A:middle
数据分页

00:20:48.556 --> 00:20:49.896 A:middle
不如就从这里开始讲吧

00:20:51.646 --> 00:20:53.836 A:middle
我们直接在代码中

00:20:53.836 --> 00:20:55.076 A:middle
找到相应的

00:20:55.076 --> 00:20:56.846 A:middle
构建 stackDocument 的部分

00:20:57.786 --> 00:20:59.816 A:middle
我要处理的事件  就关联

00:20:59.866 --> 00:21:01.536 A:middle
在 stackElement 元素

00:20:59.866 --> 00:21:01.536 A:middle
在 stackElement 元素

00:21:01.536 --> 00:21:01.986 A:middle
上

00:21:02.856 --> 00:21:04.266 A:middle
大家可以看到

00:21:04.266 --> 00:21:05.736 A:middle
这里我先抓取了下一批

00:21:05.736 --> 00:21:06.996 A:middle
想要推到模版上的数据

00:21:06.996 --> 00:21:08.906 A:middle
读取返回的 JSON

00:21:08.906 --> 00:21:10.696 A:middle
将数据转换为

00:21:10.696 --> 00:21:12.156 A:middle
JavaScript 对象

00:21:12.156 --> 00:21:15.226 A:middle
再调用 populateGrid 函数  把对象

00:21:15.256 --> 00:21:15.966 A:middle
加到模版里

00:21:16.426 --> 00:21:17.666 A:middle
populateGrid 这个函数是做什么的呢

00:21:18.276 --> 00:21:21.746 A:middle
目前我创建的模版

00:21:21.746 --> 00:21:23.356 A:middle
还没有使用新的原型

00:21:23.416 --> 00:21:24.666 A:middle
加数据绑定方法

00:21:24.666 --> 00:21:25.836 A:middle
所以可能大家看着代码觉得很

00:21:25.836 --> 00:21:26.386 A:middle
熟悉

00:21:26.816 --> 00:21:28.246 A:middle
大家看一眼  也许就知道这个函数

00:21:28.246 --> 00:21:29.116 A:middle
是要做什么

00:21:29.946 --> 00:21:34.586 A:middle
首先这里  我添加了一个空网格

00:21:34.766 --> 00:21:37.056 A:middle
然后遍历此批数据中的对象

00:21:37.056 --> 00:21:38.976 A:middle
把它们都用 TVML 标记语言表述

00:21:39.456 --> 00:21:40.666 A:middle
这个例子里用的是 lockup

00:21:41.456 --> 00:21:43.486 A:middle
最后把所有这些 lockup

00:21:43.486 --> 00:21:44.926 A:middle
都直接解析到 DOM 里

00:21:46.176 --> 00:21:47.386 A:middle
我稍后会用新方法

00:21:47.386 --> 00:21:49.796 A:middle
把这些转换成数据绑定模板

00:21:49.796 --> 00:21:51.506 A:middle
但在那之前  我们先运行一次

00:21:51.686 --> 00:21:52.696 A:middle
体验一下  在 TVMLKit 里

00:21:52.696 --> 00:21:53.746 A:middle
执行分页加载

00:21:53.746 --> 00:21:54.336 A:middle
是什么样

00:22:02.046 --> 00:22:03.066 A:middle
我们可以看到  刚打开时

00:22:03.096 --> 00:22:03.796 A:middle
没什么区别

00:22:04.266 --> 00:22:05.856 A:middle
但注意看  当我滚动到

00:22:05.896 --> 00:22:08.826 A:middle
接近这个网格末尾的时候

00:22:08.826 --> 00:22:10.086 A:middle
右侧的索引条

00:22:10.086 --> 00:22:12.506 A:middle
会向上跳回  这是因为

00:22:12.506 --> 00:22:14.146 A:middle
滚动接近末尾时  程序会自动

00:22:14.146 --> 00:22:15.276 A:middle
在网格末尾插入新的项目

00:22:16.016 --> 00:22:17.706 A:middle
好  现在分页实现了

00:22:18.646 --> 00:22:20.596 A:middle
让我们回过头  做完这个例子

00:22:20.596 --> 00:22:22.866 A:middle
再用新引入的原型加

00:22:22.866 --> 00:22:24.646 A:middle
数据绑定的方法  改写优化一下

00:22:24.646 --> 00:22:25.256 A:middle
这个模版

00:22:29.456 --> 00:22:30.946 A:middle
跟大家想的差不多

00:22:31.066 --> 00:22:32.346 A:middle
要把现有模版

00:22:32.346 --> 00:22:34.706 A:middle
转换成数据绑定模板

00:22:34.706 --> 00:22:36.346 A:middle
我所需要做的全部改动

00:22:36.346 --> 00:22:38.486 A:middle
都在 populateGrid 这一个函数里

00:22:39.156 --> 00:22:40.626 A:middle
我首先要做的就是

00:22:40.626 --> 00:22:44.566 A:middle
对比原来单纯地添加空网格

00:22:44.566 --> 00:22:47.336 A:middle
我需要添加一些原型

00:22:48.076 --> 00:22:49.936 A:middle
和一个绑定网格  就像这样

00:22:54.196 --> 00:22:56.076 A:middle
接下来的一步

00:22:56.076 --> 00:22:57.926 A:middle
我不需要逐一把这些对象

00:22:57.926 --> 00:23:00.436 A:middle
都映射到标记语言

00:22:57.926 --> 00:23:00.436 A:middle
都映射到标记语言

00:23:02.206 --> 00:23:04.216 A:middle
而是需要用 DataItem 类把它们

00:23:04.216 --> 00:23:05.746 A:middle
映射为可观察对象

00:23:06.326 --> 00:23:12.056 A:middle
像这样

00:23:12.056 --> 00:23:15.796 A:middle
最后一步  我也不需要

00:23:15.796 --> 00:23:19.136 A:middle
把这些标记语言都直接

00:23:19.136 --> 00:23:21.636 A:middle
读到 DOM 里  我只需把

00:23:21.636 --> 00:23:23.606 A:middle
新创建的 DataItem 插入到

00:23:23.606 --> 00:23:26.726 A:middle
已有 DataItem 的末尾

00:23:26.816 --> 00:23:32.486 A:middle
像这样  现在我们已经完成了

00:23:32.486 --> 00:23:34.166 A:middle
所有的优化改写  再运行一下

00:23:34.226 --> 00:23:34.976 A:middle
看看效果

00:23:43.556 --> 00:23:45.426 A:middle
应用程序一启动

00:23:45.426 --> 00:23:46.416 A:middle
我们就可以注意到

00:23:46.416 --> 00:23:47.936 A:middle
加载速度更快了  尽管

00:23:47.936 --> 00:23:49.746 A:middle
启动时只加载了

00:23:49.746 --> 00:23:51.506 A:middle
很少一部分内容

00:23:51.536 --> 00:23:52.696 A:middle
也能体会到速度增快

00:23:53.086 --> 00:23:54.446 A:middle
而当我向下滚动时

00:23:54.446 --> 00:23:57.316 A:middle
可看到程序性能

00:23:57.316 --> 00:24:00.056 A:middle
表现完美  滚动效果流畅

00:23:57.316 --> 00:24:00.056 A:middle
表现完美  滚动效果流畅

00:24:00.056 --> 00:24:00.496 A:middle
顺滑

00:24:01.296 --> 00:24:03.006 A:middle
滚起来还挺上瘾的

00:24:03.006 --> 00:24:04.106 A:middle
我能玩一天

00:24:06.516 --> 00:24:12.016 A:middle
[掌声]

00:24:12.516 --> 00:24:14.766 A:middle
让我们回顾一下

00:24:14.796 --> 00:24:15.356 A:middle
讲过的内容

00:24:18.656 --> 00:24:20.446 A:middle
我们刚刚讲了  如何运用原型

00:24:20.446 --> 00:24:22.456 A:middle
和数据绑定这一更优化的

00:24:22.716 --> 00:24:25.046 A:middle
模版定义范式来构建你的

00:24:25.046 --> 00:24:25.486 A:middle
模版

00:24:26.496 --> 00:24:27.926 A:middle
优化后可以降低 DOM 树

00:24:27.926 --> 00:24:29.076 A:middle
大小  提高应用程序

00:24:29.776 --> 00:24:32.106 A:middle
性能  我们还讲了如何利用

00:24:32.106 --> 00:24:33.766 A:middle
Needs More 事件  便捷地

00:24:33.766 --> 00:24:34.506 A:middle
对数据进行分页

00:24:35.826 --> 00:24:37.166 A:middle
在我结束前  还想给大家

00:24:37.166 --> 00:24:38.986 A:middle
重现一个测试结果

00:24:40.386 --> 00:24:41.516 A:middle
还记得我之前给大家

00:24:41.516 --> 00:24:43.086 A:middle
展示的这张图吗  显示了

00:24:43.086 --> 00:24:44.276 A:middle
构建一个含有一定数量

00:24:44.276 --> 00:24:45.536 A:middle
项目的模版  需要多长时间

00:24:46.946 --> 00:24:48.606 A:middle
我们如例子中演示的  用原型

00:24:48.606 --> 00:24:50.626 A:middle
加数据绑定的新方法  重新构建了模版

00:24:50.626 --> 00:24:52.676 A:middle
之后重做了一次性能分析

00:24:53.536 --> 00:24:55.956 A:middle
结果显示  采用新方法后

00:24:55.956 --> 00:24:58.406 A:middle
编译同样的模版所需的时间

00:24:58.406 --> 00:24:59.426 A:middle
比起原先  缩短了

00:24:59.486 --> 00:25:00.036 A:middle
超过50%

00:24:59.486 --> 00:25:00.036 A:middle
超过50%

00:25:00.486 --> 00:25:01.816 A:middle
这个结果让我们很满意

00:25:02.716 --> 00:25:04.706 A:middle
所以我鼓励大家都去看一下

00:25:04.706 --> 00:25:06.446 A:middle
这些 API  并且在你们的应用程序中

00:25:06.446 --> 00:25:08.596 A:middle
试验一下  看看你能从中

00:25:08.596 --> 00:25:09.296 A:middle
收获什么

00:25:09.356 --> 00:25:10.986 A:middle
我就说到这里  下面由

00:25:10.986 --> 00:25:12.396 A:middle
Jeremy 来给大家讲

00:25:12.666 --> 00:25:13.316 A:middle
Web 审查器 (Web Inspector)

00:25:13.436 --> 00:25:13.806 A:middle
谢谢大家

00:25:14.516 --> 00:25:20.546 A:middle
[掌声]

00:25:21.046 --> 00:25:21.666 A:middle
&gt;&gt; 谢谢 Parry

00:25:21.666 --> 00:25:23.366 A:middle
大家好  我的名字是 Jeremy

00:25:23.366 --> 00:25:24.866 A:middle
今天我想和大家讲讲

00:25:24.866 --> 00:25:26.276 A:middle
在 Web 审查器 (Web Inspector) 帮助下

00:25:26.406 --> 00:25:28.336 A:middle
进行 TVMLKit 开发时

00:25:28.336 --> 00:25:30.676 A:middle
如何在开发中获得幸福

00:25:31.976 --> 00:25:34.306 A:middle
我们已经看过 Parry 和 Trevor

00:25:34.306 --> 00:25:36.126 A:middle
尝试开发 WWDC 样本程序

00:25:36.126 --> 00:25:38.066 A:middle
的精彩示范

00:25:38.066 --> 00:25:39.986 A:middle
程序开发到这一步  已经

00:25:39.986 --> 00:25:40.786 A:middle
比较能干了

00:25:41.526 --> 00:25:43.236 A:middle
目前的程序可以支持 RTL  因此

00:25:43.236 --> 00:25:44.466 A:middle
可以一键本地化  设置成

00:25:44.466 --> 00:25:46.396 A:middle
从右往左书写语言模式

00:25:46.396 --> 00:25:48.176 A:middle
构建模版时还使用了数据绑定

00:25:48.176 --> 00:25:49.266 A:middle
加原型方法  所以可以流畅地

00:25:49.266 --> 00:25:50.976 A:middle
滚动  不会卡住等待加载

00:25:52.656 --> 00:25:56.406 A:middle
但好巧不巧  就在

00:25:56.406 --> 00:25:57.456 A:middle
我们准备上线的前几天

00:25:57.456 --> 00:25:59.406 A:middle
设计师突然跑过来

00:25:59.406 --> 00:26:00.926 A:middle
给了我们这么一个版面设计

00:25:59.406 --> 00:26:00.926 A:middle
给了我们这么一个版面设计

00:26:01.296 --> 00:26:02.466 A:middle
他竖起大拇指  跟你说

00:26:02.466 --> 00:26:03.916 A:middle
这个调整一下  应该很简单

00:26:05.096 --> 00:26:06.716 A:middle
我们都知道实际调整起来  没那么

00:26:06.716 --> 00:26:07.206 A:middle
简单

00:26:07.616 --> 00:26:08.946 A:middle
对此我可以说非常感同身受

00:26:08.946 --> 00:26:10.516 A:middle
你们心里的那些抱怨声

00:26:10.516 --> 00:26:12.056 A:middle
我也都能听见

00:26:13.016 --> 00:26:14.516 A:middle
让我们一起看一下开发周期

00:26:14.516 --> 00:26:16.336 A:middle
看看尤其针对这种 UI 调整

00:26:16.336 --> 00:26:17.346 A:middle
要做哪些具体步骤

00:26:17.346 --> 00:26:18.576 A:middle
借此试图细数一下

00:26:18.576 --> 00:26:19.786 A:middle
到底这哪些点非常恼人

00:26:20.216 --> 00:26:21.916 A:middle
这个 UI 调整  首先要做的

00:26:21.916 --> 00:26:24.066 A:middle
就是预估出来所有需要调整的

00:26:24.066 --> 00:26:26.176 A:middle
部分  还要猜测  为实现目标 UI

00:26:26.176 --> 00:26:27.996 A:middle
具体需要做哪些

00:26:27.996 --> 00:26:28.236 A:middle
改动

00:26:28.826 --> 00:26:30.016 A:middle
margin 是往右还是往左

00:26:30.016 --> 00:26:31.036 A:middle
移动一像素

00:26:31.036 --> 00:26:33.346 A:middle
等你预估完所有需要

00:26:33.346 --> 00:26:35.106 A:middle
调整的部位  还要

00:26:35.106 --> 00:26:36.436 A:middle
再反复编译并运行

00:26:36.436 --> 00:26:37.156 A:middle
来调试

00:26:37.326 --> 00:26:38.626 A:middle
我们需要在 Xcode 里编译并运行

00:26:38.786 --> 00:26:40.656 A:middle
等着应用启动  看一眼

00:26:40.656 --> 00:26:42.036 A:middle
改动后的效果  对不对

00:26:42.326 --> 00:26:43.576 A:middle
如果不对  还得

00:26:43.576 --> 00:26:45.136 A:middle
再一遍遍地重复这个过程

00:26:45.136 --> 00:26:45.926 A:middle
直到结果正确

00:26:47.166 --> 00:26:48.956 A:middle
然后因为这个冗长的过程

00:26:48.956 --> 00:26:51.076 A:middle
中间会丢失大量上下文

00:26:51.346 --> 00:26:52.866 A:middle
开发者很容易就会沉浸在细微末节里

00:26:52.866 --> 00:26:53.626 A:middle
而忘记最终想要的目标效果

00:26:53.626 --> 00:26:55.016 A:middle
因为在调试过程中

00:26:55.016 --> 00:26:56.506 A:middle
从你对代码做出改动

00:26:56.506 --> 00:26:57.906 A:middle
到看到屏幕上的运行效果

00:26:57.906 --> 00:26:58.546 A:middle
间隔时间实在太久

00:26:59.886 --> 00:27:02.006 A:middle
所以  如果有一样东西

00:26:59.886 --> 00:27:02.006 A:middle
所以  如果有一样东西

00:27:02.006 --> 00:27:02.966 A:middle
能帮我们解决这些问题

00:27:02.966 --> 00:27:04.806 A:middle
那该有多好

00:27:05.856 --> 00:27:07.056 A:middle
一些经验丰富的 Web 开发者

00:27:07.056 --> 00:27:08.686 A:middle
已经在使用 Web 审查器的

00:27:08.686 --> 00:27:10.206 A:middle
这些强大的功能了

00:27:10.416 --> 00:27:11.986 A:middle
包括可视化调试排错

00:27:12.486 --> 00:27:13.546 A:middle
对 LocalStorage

00:27:13.546 --> 00:27:15.056 A:middle
和 SessionStorage 的内省  甚至

00:27:15.056 --> 00:27:16.306 A:middle
对 JavaScript 进行性能分析

00:27:17.396 --> 00:27:20.156 A:middle
当前的 tvOS 在 TVMLKit 里

00:27:20.156 --> 00:27:22.596 A:middle
只支持这一小部分针对

00:27:22.596 --> 00:27:24.126 A:middle
Web 审查器的功能

00:27:25.186 --> 00:27:26.746 A:middle
今天  我很高兴能宣布

00:27:26.746 --> 00:27:29.186 A:middle
在 tvOS 11 中  我们会增加

00:27:29.186 --> 00:27:30.646 A:middle
对 Web 审查器其余

00:27:30.646 --> 00:27:32.116 A:middle
几项功能的支持

00:27:33.516 --> 00:27:36.556 A:middle
[掌声]

00:27:37.056 --> 00:27:38.356 A:middle
&gt;&gt; 我们首先讲一下

00:27:38.356 --> 00:27:39.396 A:middle
可视化调试排错 (Visual Debugging)

00:27:40.646 --> 00:27:42.656 A:middle
你的 TVML 应用  是一个

00:27:42.656 --> 00:27:44.816 A:middle
以 DOM 来代表的文件  为了

00:27:44.816 --> 00:27:46.156 A:middle
可视化这些 Web 审查器

00:27:46.156 --> 00:27:47.466 A:middle
设有 Elements 标签页

00:27:47.716 --> 00:27:49.616 A:middle
这里树状显示了全部节点

00:27:49.616 --> 00:27:51.936 A:middle
TVML 就用这些节点

00:27:51.936 --> 00:27:52.846 A:middle
来渲染 UI

00:27:53.536 --> 00:27:54.786 A:middle
我们首先做的一项工作

00:27:54.786 --> 00:27:56.906 A:middle
就是我们希望能完全避免

00:27:57.006 --> 00:27:58.256 A:middle
猜测  而直接定位到需要

00:27:58.256 --> 00:27:59.756 A:middle
调整的部分  要实现

00:27:59.756 --> 00:28:00.936 A:middle
这一点  就应用了

00:27:59.756 --> 00:28:00.936 A:middle
这一点  就应用了

00:28:00.936 --> 00:28:01.756 A:middle
可视化

00:28:01.806 --> 00:28:03.536 A:middle
如果将鼠标缓慢

00:28:03.536 --> 00:28:05.576 A:middle
移动到树中节点上方

00:28:05.726 --> 00:28:06.456 A:middle
Web 审查器会自动

00:28:06.456 --> 00:28:07.586 A:middle
在屏幕上高亮与节点对应的

00:28:07.586 --> 00:28:08.286 A:middle
UI 图形区域

00:28:08.736 --> 00:28:09.756 A:middle
甚至会提供

00:28:09.756 --> 00:28:11.756 A:middle
尺寸信息  和相关联

00:28:11.756 --> 00:28:13.116 A:middle
的都有哪些元素

00:28:14.956 --> 00:28:16.966 A:middle
现在我们准确定位了需要改动的

00:28:16.966 --> 00:28:18.326 A:middle
那个节点  就可以

00:28:18.326 --> 00:28:19.966 A:middle
针对这个节点

00:28:19.966 --> 00:28:21.836 A:middle
编辑它的 XML

00:28:22.506 --> 00:28:23.646 A:middle
期间你做出的任何改动

00:28:23.646 --> 00:28:25.616 A:middle
都会在渲染 UI 前生效

00:28:26.876 --> 00:28:27.926 A:middle
如果你不想改动

00:28:27.926 --> 00:28:29.126 A:middle
XML  而只是想

00:28:29.126 --> 00:28:30.886 A:middle
重新排列屏幕上的节点  这点

00:28:30.886 --> 00:28:31.886 A:middle
也可以做到

00:28:32.196 --> 00:28:33.826 A:middle
很简单  只需拖拽节点

00:28:33.826 --> 00:28:35.206 A:middle
拖动到你期望的目标位置

00:28:35.206 --> 00:28:36.756 A:middle
屏幕界面上会自动

00:28:36.756 --> 00:28:37.756 A:middle
显示出相应的更新

00:28:39.386 --> 00:28:40.916 A:middle
也有一些开发者  想在不同

00:28:40.916 --> 00:28:42.036 A:middle
明暗度下

00:28:42.036 --> 00:28:43.746 A:middle
查看 UI 效果  亮或者暗

00:28:44.026 --> 00:28:45.376 A:middle
这点可以在模版上直接

00:28:45.376 --> 00:28:46.076 A:middle
改动属性

00:28:46.076 --> 00:28:47.336 A:middle
实际上  全部节点的

00:28:47.336 --> 00:28:49.106 A:middle
所有属性  都可以修改

00:28:49.956 --> 00:28:51.626 A:middle
最后一点  我们做出的

00:28:51.626 --> 00:28:53.246 A:middle
所有这些改动  都可以

00:28:53.246 --> 00:28:55.116 A:middle
复制出来  然后随意粘贴进

00:28:55.116 --> 00:28:56.056 A:middle
任何文件

00:28:57.386 --> 00:28:58.646 A:middle
现在我们看过了如何

00:28:58.646 --> 00:29:00.136 A:middle
改变页面布局  我们再

00:28:58.646 --> 00:29:00.136 A:middle
改变页面布局  我们再

00:29:00.136 --> 00:29:01.696 A:middle
看一下屏幕上渲染 UI

00:29:01.696 --> 00:29:02.906 A:middle
所需要用到的属性

00:29:04.046 --> 00:29:06.026 A:middle
现在 Web 审查器可让我们

00:29:06.026 --> 00:29:07.266 A:middle
查看每一个节点

00:29:07.266 --> 00:29:08.446 A:middle
所关联的对应规则

00:29:08.446 --> 00:29:09.856 A:middle
所以现在我们可以查看

00:29:09.856 --> 00:29:11.586 A:middle
渲染全部节点所用的

00:29:11.586 --> 00:29:12.826 A:middle
每一条规则

00:29:14.156 --> 00:29:15.986 A:middle
这些都按照层叠顺序

00:29:15.986 --> 00:29:17.326 A:middle
来排序  权重最大的

00:29:17.326 --> 00:29:18.916 A:middle
那些规则  显示在最上面

00:29:18.916 --> 00:29:20.136 A:middle
它们覆盖的那些规则

00:29:20.136 --> 00:29:22.586 A:middle
被排在最底端

00:29:22.726 --> 00:29:24.446 A:middle
媒体查询也可以

00:29:24.446 --> 00:29:25.736 A:middle
被可视化  所以我们也可以

00:29:25.736 --> 00:29:27.466 A:middle
查看特定媒体查询

00:29:27.536 --> 00:29:28.926 A:middle
所对应的

00:29:28.926 --> 00:29:30.596 A:middle
特定规则  举个例子

00:29:30.596 --> 00:29:32.906 A:middle
若有针对 LTR 的规则  也可以

00:29:32.906 --> 00:29:35.246 A:middle
看到相应规则被归类显示

00:29:35.246 --> 00:29:35.446 A:middle
了

00:29:35.446 --> 00:29:37.696 A:middle
最后  Web 审查器

00:29:37.696 --> 00:29:38.866 A:middle
还可以让我们查看

00:29:38.866 --> 00:29:40.336 A:middle
框架本身自带的

00:29:40.336 --> 00:29:41.376 A:middle
默认规则

00:29:41.376 --> 00:29:43.106 A:middle
这样一来  要知道做出

00:29:43.106 --> 00:29:44.286 A:middle
一个完美漂亮的 UI 成品

00:29:44.286 --> 00:29:46.126 A:middle
还需要改动哪些默认规则

00:29:46.126 --> 00:29:47.566 A:middle
也完全不需要靠开发者自己

00:29:47.656 --> 00:29:50.216 A:middle
来猜测了

00:29:50.216 --> 00:29:51.576 A:middle
当然  显示出来

00:29:51.616 --> 00:29:53.576 A:middle
这么多的规则  我们

00:29:53.956 --> 00:29:55.476 A:middle
也会提供一个合并

00:29:55.476 --> 00:29:56.506 A:middle
的版本

00:29:56.506 --> 00:29:57.886 A:middle
屏幕上渲染 UI 时

00:29:57.886 --> 00:29:59.246 A:middle
用的就是这些

00:29:59.246 --> 00:29:59.886 A:middle
样式了

00:29:59.886 --> 00:30:04.106 A:middle
在 Web 审查器里  还有

00:29:59.886 --> 00:30:04.106 A:middle
在 Web 审查器里  还有

00:30:04.106 --> 00:30:05.686 A:middle
一个重新加载 (Reload) 按钮  现在

00:30:05.686 --> 00:30:06.666 A:middle
只要点击这个按钮

00:30:06.666 --> 00:30:08.326 A:middle
就可以重启整个

00:30:08.326 --> 00:30:10.036 A:middle
JavaScript 执行上下文  不需要

00:30:10.036 --> 00:30:11.336 A:middle
再通过反复编译并运行来调试

00:30:11.336 --> 00:30:11.916 A:middle
程序

00:30:12.536 --> 00:30:13.696 A:middle
讲完这些  我想用一个

00:30:13.696 --> 00:30:15.776 A:middle
演示实例  给大家展示一下

00:30:15.776 --> 00:30:16.526 A:middle
刚刚所说的功能

00:30:21.046 --> 00:30:23.496 A:middle
现在我已经事先准备

00:30:23.726 --> 00:30:25.316 A:middle
好了项目  也更新了 UI

00:30:25.316 --> 00:30:27.016 A:middle
最后要做的就是

00:30:27.016 --> 00:30:28.326 A:middle
检查程序是否可以

00:30:28.326 --> 00:30:28.856 A:middle
完美支持 RTL

00:30:28.856 --> 00:30:29.236 A:middle
好了

00:30:29.236 --> 00:30:35.126 A:middle
我们现在要再次应用

00:30:35.126 --> 00:30:36.496 A:middle
前面 Trevor 教给我们的方法

00:30:36.496 --> 00:30:37.966 A:middle
去 scheme 下

00:30:38.186 --> 00:30:39.566 A:middle
把应用程序的系统语言

00:30:39.566 --> 00:30:40.876 A:middle
改为从右往左的伪码

00:30:41.296 --> 00:30:42.976 A:middle
编译并运行一下

00:30:55.046 --> 00:30:55.216 A:middle
好了

00:30:55.216 --> 00:30:57.006 A:middle
如大家所见  整体看起来

00:30:57.076 --> 00:30:58.396 A:middle
还不错  除了页面上方的横幅

00:30:58.396 --> 00:30:59.826 A:middle
我们还没来得及为 RTL

00:30:59.826 --> 00:31:01.106 A:middle
做优化

00:30:59.826 --> 00:31:01.106 A:middle
做优化

00:31:01.726 --> 00:31:02.896 A:middle
那么接下来的调试  我们就不需要

00:31:02.896 --> 00:31:04.276 A:middle
像 Trevor 那样  反复编译并运行

00:31:04.276 --> 00:31:05.866 A:middle
而是试图通过

00:31:05.866 --> 00:31:06.536 A:middle
Web 审查器来做

00:31:06.916 --> 00:31:08.136 A:middle
讲下具体操作方法  我们先

00:31:08.136 --> 00:31:11.666 A:middle
打开 Safari   可以看到我已经

00:31:11.666 --> 00:31:13.016 A:middle
启用了开发者工具菜单

00:31:13.016 --> 00:31:14.576 A:middle
点进去  找到 Simulator

00:31:14.576 --> 00:31:16.756 A:middle
然后审查你想要调试的应用

00:31:16.756 --> 00:31:17.796 A:middle
程序

00:31:20.266 --> 00:31:23.026 A:middle
这就打开了 Web 审查器

00:31:23.026 --> 00:31:23.916 A:middle
可以开始调试了

00:31:24.566 --> 00:31:26.946 A:middle
现在我们想要改动

00:31:26.946 --> 00:31:28.116 A:middle
屏幕上的几个 UI 元素

00:31:28.116 --> 00:31:29.506 A:middle
我们可以看到  这里的

00:31:29.506 --> 00:31:30.646 A:middle
标题  副标题  和

00:31:30.646 --> 00:31:31.676 A:middle
按钮  都需要调整

00:31:31.676 --> 00:31:33.636 A:middle
用 Web 审查器  我们可以

00:31:33.636 --> 00:31:35.236 A:middle
轻松定位到这些元素

00:31:35.236 --> 00:31:37.006 A:middle
所对应的节点

00:31:37.006 --> 00:31:37.976 A:middle
只要移动鼠标  就可以看到

00:31:37.976 --> 00:31:39.076 A:middle
节点对应的元素被

00:31:39.076 --> 00:31:39.646 A:middle
高亮了

00:31:40.276 --> 00:31:41.626 A:middle
我们现在快速地找到标题

00:31:41.626 --> 00:31:41.976 A:middle
来进行调整

00:31:44.916 --> 00:31:46.706 A:middle
找到后  Web 审查器会显示出

00:31:46.706 --> 00:31:47.876 A:middle
这个节点所对应的

00:31:47.876 --> 00:31:49.506 A:middle
所有规则  我们现在只需

00:31:49.506 --> 00:31:51.396 A:middle
在规则中找到这个恼人的

00:31:51.396 --> 00:31:52.436 A:middle
bottom-left   把它改为

00:31:52.436 --> 00:31:53.186 A:middle
bottom-leading

00:31:53.516 --> 00:31:55.656 A:middle
大家注意看  我边打字

00:31:55.656 --> 00:31:57.126 A:middle
模拟屏幕上会产生什么

00:31:57.126 --> 00:31:57.526 A:middle
变化

00:31:59.316 --> 00:32:01.206 A:middle
你看  屏幕显示自动更新了

00:31:59.316 --> 00:32:01.206 A:middle
你看  屏幕显示自动更新了

00:32:01.206 --> 00:32:03.336 A:middle
不需要我们再去编译并运行

00:32:03.556 --> 00:32:05.946 A:middle
响应非常快  如果有人

00:32:05.946 --> 00:32:07.376 A:middle
没看到  我们再来

00:32:07.376 --> 00:32:08.406 A:middle
对副标题进行一下

00:32:08.406 --> 00:32:10.256 A:middle
改动  一样的步骤

00:32:10.546 --> 00:32:12.426 A:middle
定位到你想改动的元素

00:32:12.426 --> 00:32:14.066 A:middle
改动相关联的样式

00:32:16.186 --> 00:32:16.896 A:middle
好了

00:32:17.876 --> 00:32:19.466 A:middle
我们也把播放按钮

00:32:19.466 --> 00:32:20.536 A:middle
快速地修改一下  让它

00:32:20.536 --> 00:32:21.676 A:middle
显示在正确的位置

00:32:23.496 --> 00:32:24.916 A:middle
我们需要把所有的 right

00:32:24.916 --> 00:32:26.166 A:middle
都改为 trailing

00:32:27.866 --> 00:32:34.026 A:middle
拼一下 trailing  当然

00:32:34.026 --> 00:32:35.526 A:middle
就像 Trevor 之前做的  为了设置

00:32:35.526 --> 00:32:36.636 A:middle
正确的 margin  还需单独

00:32:36.636 --> 00:32:38.676 A:middle
创建媒体查询  因为 RTL 语言模式下

00:32:38.676 --> 00:32:40.106 A:middle
数据要写在不同位置

00:32:40.106 --> 00:32:41.666 A:middle
所以我来复制一下 margin

00:32:43.096 --> 00:32:43.846 A:middle
粘贴过去

00:32:45.106 --> 00:32:46.246 A:middle
这里再改一下

00:32:46.786 --> 00:32:47.806 A:middle
然后就好了

00:32:48.566 --> 00:32:49.786 A:middle
我们做的这些改动

00:32:49.786 --> 00:32:51.176 A:middle
都是在作者样式表上

00:32:51.176 --> 00:32:52.596 A:middle
而作者样式表是包含在

00:32:52.596 --> 00:32:54.876 A:middle
样式属性

00:32:54.876 --> 00:32:56.376 A:middle
样式标签下  我们把这些都复制

00:32:56.376 --> 00:32:57.016 A:middle
下来

00:32:58.216 --> 00:32:59.456 A:middle
为了核对  我们把这些

00:32:59.456 --> 00:33:00.786 A:middle
都粘贴到我们的 TVML

00:32:59.456 --> 00:33:00.786 A:middle
都粘贴到我们的 TVML

00:33:00.786 --> 00:33:01.286 A:middle
文档里

00:33:01.796 --> 00:33:05.046 A:middle
好了

00:33:05.126 --> 00:33:08.626 A:middle
然后这次不用编译并运行

00:33:08.626 --> 00:33:10.966 A:middle
我们可以直接点击

00:33:10.966 --> 00:33:11.396 A:middle
重新加载

00:33:12.246 --> 00:33:12.896 A:middle
就好了

00:33:12.896 --> 00:33:14.416 A:middle
一切运行正常

00:33:14.416 --> 00:33:14.886 A:middle
[掌声]

00:33:14.886 --> 00:33:16.296 A:middle
我们回到幻灯片

00:33:17.516 --> 00:33:19.776 A:middle
[掌声]

00:33:20.276 --> 00:33:21.496 A:middle
大家刚刚看到了  这种方法

00:33:21.496 --> 00:33:22.926 A:middle
可以快速定位 UI 中的问题

00:33:22.926 --> 00:33:24.286 A:middle
并对其进行调整

00:33:24.286 --> 00:33:26.266 A:middle
应用起来的具体步骤

00:33:26.266 --> 00:33:27.776 A:middle
是先找到具体

00:33:27.776 --> 00:33:29.916 A:middle
受影响的节点  对它们

00:33:29.916 --> 00:33:31.486 A:middle
进行实时编辑  最后

00:33:31.486 --> 00:33:32.936 A:middle
只需把 TVML 属性

00:33:33.246 --> 00:33:35.276 A:middle
复制出来并粘贴

00:33:35.446 --> 00:33:36.706 A:middle
然后直接重启整个 JavaScript

00:33:36.706 --> 00:33:38.706 A:middle
执行上下文即可  不再需要

00:33:38.706 --> 00:33:39.896 A:middle
一遍遍地编译并运行

00:33:40.946 --> 00:33:42.406 A:middle
以上这就是可视化调试排错

00:33:42.406 --> 00:33:43.916 A:middle
我下面开始介绍

00:33:43.916 --> 00:33:44.936 A:middle
网络分析 (Network Analysis)

00:33:46.036 --> 00:33:47.526 A:middle
Web 审查器现在支持

00:33:47.526 --> 00:33:49.336 A:middle
查看从 TVMLKit

00:33:49.336 --> 00:33:50.686 A:middle
应用发出的所有

00:33:50.686 --> 00:33:51.306 A:middle
网络请求

00:33:52.166 --> 00:33:53.846 A:middle
我们可以查看

00:33:53.846 --> 00:33:55.026 A:middle
单项请求的耗时信息

00:33:55.026 --> 00:33:56.996 A:middle
比如 DNS 查询花了多长时间

00:33:56.996 --> 00:33:58.396 A:middle
比如响应传输需要花费

00:33:58.396 --> 00:33:59.436 A:middle
多长时间

00:34:00.206 --> 00:34:01.846 A:middle
我们还可以审查

00:34:01.846 --> 00:34:03.246 A:middle
你给某一个请求单独

00:34:03.246 --> 00:34:04.626 A:middle
设置的审查属性

00:34:04.626 --> 00:34:06.336 A:middle
可用来确认发出去的信息

00:34:06.336 --> 00:34:07.326 A:middle
符合预期

00:34:07.326 --> 00:34:09.556 A:middle
最后  如果需要

00:34:09.556 --> 00:34:11.206 A:middle
我们还可以查看响应头

00:34:11.206 --> 00:34:13.996 A:middle
和请求头

00:34:14.056 --> 00:34:15.275 A:middle
可能你目前还写了脚本

00:34:15.275 --> 00:34:17.505 A:middle
来内省 LocalStorage

00:34:17.505 --> 00:34:18.806 A:middle
和 SessionStorage

00:34:19.206 --> 00:34:20.286 A:middle
以后这个工作也不需要做了

00:34:20.286 --> 00:34:21.426 A:middle
因为 Web 审查器也会

00:34:21.426 --> 00:34:23.126 A:middle
提供一个很好的 UI

00:34:23.406 --> 00:34:24.696 A:middle
让我们看到我们 LocalStorage

00:34:24.696 --> 00:34:26.815 A:middle
和 SessionStorage 里每一个

00:34:26.815 --> 00:34:28.936 A:middle
关键值路径

00:34:28.936 --> 00:34:30.456 A:middle
而能查看这些数据  也就意味着

00:34:30.456 --> 00:34:31.766 A:middle
我们可以进行修改

00:34:32.016 --> 00:34:33.775 A:middle
可以进行复制  删除

00:34:33.775 --> 00:34:34.766 A:middle
也可以随意移动

00:34:35.326 --> 00:34:38.516 A:middle
就这些  这就是 TVMLKit

00:34:38.516 --> 00:34:39.985 A:middle
如何支持 Web 审查器

00:34:39.985 --> 00:34:40.966 A:middle
这就是如何在开发中获得

00:34:40.966 --> 00:34:41.606 A:middle
幸福

00:34:42.516 --> 00:34:45.545 A:middle
[掌声]

00:34:46.045 --> 00:34:47.045 A:middle
总结下  我们今天讲了什么

00:34:47.775 --> 00:34:49.666 A:middle
首先 TVMLKit 自身  对于所有默认模版

00:34:49.666 --> 00:34:50.806 A:middle
都提供对从右往左书写语言

00:34:50.806 --> 00:34:51.356 A:middle
的支持

00:34:51.476 --> 00:34:52.616 A:middle
如果你的应用程序中有自定义样式

00:34:52.616 --> 00:34:54.436 A:middle
可能配置起来会复杂一点

00:34:54.436 --> 00:34:55.295 A:middle
但都很简单

00:34:56.005 --> 00:34:57.326 A:middle
像 Parry 讲的  如果你想要流畅

00:34:57.326 --> 00:34:58.286 A:middle
顺滑的滚动用户体验

00:34:58.286 --> 00:35:00.606 A:middle
请使用数据绑定和原型

00:34:58.286 --> 00:35:00.606 A:middle
请使用数据绑定和原型

00:35:00.736 --> 00:35:02.906 A:middle
最后  如果你希望在

00:35:02.906 --> 00:35:04.426 A:middle
开发应用程序时

00:35:04.426 --> 00:35:05.876 A:middle
减少调试排错的时间  请使用

00:35:05.876 --> 00:35:06.456 A:middle
Web 审查器

00:35:06.646 --> 00:35:08.386 A:middle
更多信息  请访问

00:35:08.386 --> 00:35:09.456 A:middle
屏幕上显示的网址

00:35:09.756 --> 00:35:10.656 A:middle
网站上有样本代码和

00:35:10.656 --> 00:35:11.646 A:middle
支持文件  都非常有用

00:35:11.646 --> 00:35:12.606 A:middle
值得一看

00:35:13.286 --> 00:35:15.026 A:middle
另外还有一些 其他很棒的演讲可以参加

00:35:15.026 --> 00:35:16.686 A:middle
尤其 What's New in

00:35:16.686 --> 00:35:18.116 A:middle
tvOS tomorrow

00:35:18.956 --> 00:35:21.486 A:middle
感谢大家参加 WWDC 2017

00:35:21.556 --> 00:35:22.456 A:middle
希望大家在大会剩下的时光

00:35:22.456 --> 00:35:22.946 A:middle
都过得愉快
