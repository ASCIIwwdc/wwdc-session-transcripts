WEBVTT

00:00:22.736 --> 00:00:23.106 A:middle
&gt;&gt;  好的

00:00:25.106 --> 00:00:27.386 A:middle
那么谢谢大家

00:00:27.546 --> 00:00:27.986 A:middle
欢迎大家

00:00:28.066 --> 00:00:29.446 A:middle
我叫 David Hayward

00:00:29.446 --> 00:00:30.736 A:middle
特别开心今天能来

00:00:30.736 --> 00:00:32.046 A:middle
为大家介绍我们为

00:00:32.046 --> 00:00:33.826 A:middle
iOS macOS tvOS 上的

00:00:33.826 --> 00:00:35.556 A:middle
Core Image 框架新添的

00:00:35.756 --> 00:00:37.786 A:middle
出色特性和功能

00:00:39.926 --> 00:00:41.936 A:middle
我们今天的内容很充实

00:00:42.036 --> 00:00:43.496 A:middle
我会带大家简要回顾一下

00:00:43.496 --> 00:00:45.546 A:middle
Core Image

00:00:45.546 --> 00:00:46.906 A:middle
概括一下我们今年

00:00:46.906 --> 00:00:47.586 A:middle
新加入的一些要点

00:00:48.376 --> 00:00:49.496 A:middle
然后我们会用

00:00:49.496 --> 00:00:51.266 A:middle
剩余时间深入了解

00:00:51.266 --> 00:00:53.286 A:middle
所有新 API 和

00:00:53.496 --> 00:00:54.096 A:middle
新特性的具体情况

00:00:54.986 --> 00:00:56.196 A:middle
那么按照这个大纲

00:00:56.466 --> 00:00:57.086 A:middle
让我们来进入正题

00:00:58.986 --> 00:01:00.336 A:middle
先是对 Core Image 的

00:00:58.986 --> 00:01:00.336 A:middle
先是对 Core Image 的

00:01:00.336 --> 00:01:00.666 A:middle
简要回顾

00:01:01.546 --> 00:01:02.886 A:middle
简单说 Core Image 框架

00:01:02.886 --> 00:01:03.966 A:middle
提供一种简单易用的

00:01:03.966 --> 00:01:05.926 A:middle
高性能 API 用来对图像

00:01:06.006 --> 00:01:06.986 A:middle
进行滤镜处理

00:01:07.436 --> 00:01:09.026 A:middle
这些图像可被用来

00:01:09.526 --> 00:01:10.906 A:middle
调整颜色调整几何属性

00:01:10.906 --> 00:01:12.916 A:middle
或者执行复杂的

00:01:12.996 --> 00:01:14.516 A:middle
切割或卷积

00:01:16.116 --> 00:01:18.406 A:middle
Core Image 会使用

00:01:18.546 --> 00:01:19.916 A:middle
几种小技巧来实现

00:01:19.956 --> 00:01:21.876 A:middle
这些操作的最佳效果

00:01:21.876 --> 00:01:24.696 A:middle
因为这些滤镜可以组合

00:01:24.696 --> 00:01:25.966 A:middle
要么是通过简单的叠加

00:01:25.966 --> 00:01:27.696 A:middle
就像上面这个例子

00:01:27.696 --> 00:01:28.176 A:middle
要么是复杂图形

00:01:28.716 --> 00:01:32.476 A:middle
Core Image 为了出色效果

00:01:32.556 --> 00:01:34.106 A:middle
使用的技巧之一

00:01:34.106 --> 00:01:36.186 A:middle
就是支持自动平铺

00:01:36.416 --> 00:01:38.646 A:middle
这让我们可以

00:01:38.646 --> 00:01:40.356 A:middle
如果图像尺寸过大

00:01:40.356 --> 00:01:41.136 A:middle
或者需要大量内存

00:01:41.136 --> 00:01:42.406 A:middle
来渲染图像

00:01:42.406 --> 00:01:44.556 A:middle
我们就可以降低

00:01:44.616 --> 00:01:44.976 A:middle
相应的内存占用

00:01:48.846 --> 00:01:50.326 A:middle
平铺功能的另一个特点

00:01:50.356 --> 00:01:51.976 A:middle
意味着如果我们只需

00:01:51.976 --> 00:01:53.336 A:middle
渲染图像的一部分

00:01:53.776 --> 00:01:54.996 A:middle
这样做的效率会很高

00:01:54.996 --> 00:01:56.926 A:middle
只需要加载我们需要的

00:01:56.926 --> 00:01:58.046 A:middle
图像的相应部分

00:01:58.946 --> 00:02:00.216 A:middle
以上这些出众的性能

00:01:58.946 --> 00:02:00.216 A:middle
以上这些出众的性能

00:02:00.216 --> 00:02:01.506 A:middle
大家都可以免费享受

00:02:01.506 --> 00:02:02.336 A:middle
只需要使用 Core Image

00:02:02.896 --> 00:02:03.866 A:middle
此外如果大家要在 Core Image 内

00:02:03.866 --> 00:02:06.286 A:middle
编写自己的内核

00:02:06.286 --> 00:02:08.086 A:middle
我们的语言扩展也能

00:02:08.086 --> 00:02:09.136 A:middle
让大家以最低的难度

00:02:09.136 --> 00:02:10.455 A:middle
免费实现

00:02:10.455 --> 00:02:12.146 A:middle
这项功能

00:02:12.646 --> 00:02:15.976 A:middle
还有一点也要记住

00:02:15.976 --> 00:02:17.136 A:middle
Core Image 中的

00:02:17.136 --> 00:02:19.566 A:middle
所有滤镜都基于

00:02:20.456 --> 00:02:21.546 A:middle
一个或多个内核

00:02:21.546 --> 00:02:22.826 A:middle
要么是内置内核

00:02:22.826 --> 00:02:23.326 A:middle
要么是自定义内核

00:02:23.956 --> 00:02:25.166 A:middle
Core Image 用来实现

00:02:25.166 --> 00:02:27.356 A:middle
出色性能的另一个技巧

00:02:27.356 --> 00:02:29.656 A:middle
就是将这些内核

00:02:29.686 --> 00:02:30.516 A:middle
全部并置到程序中

00:02:30.916 --> 00:02:32.316 A:middle
这能让 Core Image

00:02:32.356 --> 00:02:33.286 A:middle
减少中间缓存的

00:02:33.286 --> 00:02:35.066 A:middle
个数帮助我们

00:02:35.066 --> 00:02:36.526 A:middle
降低对内存的要求

00:02:36.526 --> 00:02:37.966 A:middle
同时提高图像质量

00:02:41.216 --> 00:02:42.426 A:middle
基于以上介绍

00:02:42.426 --> 00:02:43.826 A:middle
我要为大家简要

00:02:43.826 --> 00:02:45.106 A:middle
讲解一下我们今年

00:02:45.106 --> 00:02:46.366 A:middle
为 Core Image 添加的功能

00:02:46.626 --> 00:02:47.566 A:middle
这些功能可以分为

00:02:47.566 --> 00:02:48.216 A:middle
三大类别

00:02:48.626 --> 00:02:49.506 A:middle
首先当然就是

00:02:49.506 --> 00:02:50.096 A:middle
性能

00:02:50.146 --> 00:02:51.136 A:middle
在任何时候这一点

00:02:51.136 --> 00:02:52.116 A:middle
对于 Core Image 来说

00:02:52.116 --> 00:02:53.446 A:middle
都十分重要我们也在

00:02:53.576 --> 00:02:55.756 A:middle
这方面做了些加强

00:02:55.756 --> 00:02:57.086 A:middle
让大家能够获得

00:02:57.086 --> 00:02:57.626 A:middle
最佳的性能

00:02:58.196 --> 00:03:00.926 A:middle
我要提到的

00:02:58.196 --> 00:03:00.926 A:middle
我要提到的

00:03:00.926 --> 00:03:01.766 A:middle
第二点也是我们

00:03:01.766 --> 00:03:04.146 A:middle
今年花了很多时间

00:03:04.146 --> 00:03:06.976 A:middle
来加强的 Core Image 特性

00:03:06.976 --> 00:03:08.026 A:middle
好让各位开发者大家

00:03:08.026 --> 00:03:09.396 A:middle
更好地获知 Core Image

00:03:09.396 --> 00:03:10.636 A:middle
内部运行情况的信息

00:03:11.166 --> 00:03:13.086 A:middle
我在前面几页中

00:03:13.086 --> 00:03:14.336 A:middle
提到的我们所做的

00:03:14.336 --> 00:03:15.896 A:middle
所有这些优化

00:03:15.896 --> 00:03:17.996 A:middle
大家都可以看到

00:03:17.996 --> 00:03:18.306 A:middle
我们是如何做到的

00:03:20.156 --> 00:03:21.676 A:middle
第三点我们添加了

00:03:21.676 --> 00:03:23.186 A:middle
许多功能这是为了

00:03:23.186 --> 00:03:24.686 A:middle
能让大家的应用程序

00:03:24.856 --> 00:03:26.016 A:middle
以最轻松的方式利用

00:03:26.016 --> 00:03:27.116 A:middle
我们平台上的所有新特性

00:03:28.856 --> 00:03:30.386 A:middle
那么再来更详细地

00:03:30.386 --> 00:03:30.616 A:middle
解释一下这三点

00:03:30.616 --> 00:03:32.336 A:middle
在性能方面

00:03:32.336 --> 00:03:33.856 A:middle
Core Image 如今可让大家

00:03:33.966 --> 00:03:35.116 A:middle
直接使用 Metal 编写 CI 内核

00:03:35.116 --> 00:03:38.086 A:middle
我们还推出了一款新的 API

00:03:38.086 --> 00:03:39.696 A:middle
能让大家更好地

00:03:39.696 --> 00:03:40.516 A:middle
渲染目标 (destination)

00:03:40.596 --> 00:03:41.616 A:middle
我们稍后再来

00:03:41.616 --> 00:03:42.886 A:middle
具体讲解其中的

00:03:42.886 --> 00:03:43.566 A:middle
更多细节

00:03:44.596 --> 00:03:46.856 A:middle
信息方面

00:03:46.856 --> 00:03:48.086 A:middle
我们推出了一款新的 API

00:03:48.086 --> 00:03:50.116 A:middle
可让大家获知 Core Image

00:03:50.116 --> 00:03:51.196 A:middle
处理给定渲染程序

00:03:51.196 --> 00:03:51.556 A:middle
的相关信息

00:03:52.106 --> 00:03:53.556 A:middle
此外我们还新增了

00:03:53.556 --> 00:03:54.956 A:middle
对 Xcode Quick Look 的出色支持

00:03:54.956 --> 00:03:55.496 A:middle
稍后会展示给大家看

00:03:56.866 --> 00:03:57.606 A:middle
接下来是

00:03:57.606 --> 00:03:58.676 A:middle
功能方面我们也

00:03:58.676 --> 00:03:59.676 A:middle
新增了些出色的功能

00:03:59.676 --> 00:04:00.766 A:middle
我们新增了一套

00:03:59.676 --> 00:04:00.766 A:middle
我们新增了一套

00:04:00.816 --> 00:04:02.766 A:middle
滤镜条形码支持

00:04:03.066 --> 00:04:05.746 A:middle
还有对深度编辑的

00:04:05.746 --> 00:04:05.966 A:middle
支持

00:04:06.606 --> 00:04:08.576 A:middle
我想让大家回忆一下

00:04:08.576 --> 00:04:10.286 A:middle
今天在前面的一个讲座里

00:04:10.426 --> 00:04:11.496 A:middle
提到的支持深度的图像编辑

00:04:11.496 --> 00:04:12.886 A:middle
如果有人错过了

00:04:12.886 --> 00:04:14.006 A:middle
请务必回去看一看

00:04:14.006 --> 00:04:15.846 A:middle
里面十分详尽地讲解了

00:04:15.846 --> 00:04:16.856 A:middle
如何使用 Core Image

00:04:16.856 --> 00:04:16.976 A:middle
来编辑深度

00:04:20.726 --> 00:04:22.116 A:middle
现在让我再来

00:04:22.116 --> 00:04:23.306 A:middle
更详尽地讲解一下

00:04:23.306 --> 00:04:24.476 A:middle
我们此次添加的新滤镜

00:04:25.236 --> 00:04:27.686 A:middle
现在我们总共有 196 种

00:04:27.686 --> 00:04:30.456 A:middle
内置滤镜其中包括

00:04:30.456 --> 00:04:32.606 A:middle
一些非常出色的

00:04:32.606 --> 00:04:33.196 A:middle
新滤镜

00:04:33.626 --> 00:04:34.816 A:middle
比如说其中有几种

00:04:34.816 --> 00:04:36.586 A:middle
在你处理深度数据时

00:04:36.586 --> 00:04:37.256 A:middle
会变得非常有用

00:04:37.736 --> 00:04:39.036 A:middle
比如说我们为

00:04:39.036 --> 00:04:40.366 A:middle
深度与视差之间的转换

00:04:40.366 --> 00:04:41.356 A:middle
提供了一些实用滤镜

00:04:41.946 --> 00:04:43.366 A:middle
我们也提供了

00:04:43.366 --> 00:04:44.966 A:middle
形态学处理可让大家

00:04:45.306 --> 00:04:46.986 A:middle
对图像进行腐蚀和膨胀处理

00:04:46.986 --> 00:04:48.936 A:middle
这在操作深度掩码时

00:04:48.936 --> 00:04:49.606 A:middle
非常有用

00:04:50.266 --> 00:04:52.116 A:middle
我们还有一些实用滤镜

00:04:52.116 --> 00:04:53.376 A:middle
可以让大家

00:04:53.376 --> 00:04:54.806 A:middle
基于图像深度使用

00:04:54.806 --> 00:04:56.186 A:middle
两种不同的色彩立方体

00:04:56.186 --> 00:04:56.526 A:middle
来合成图像

00:04:58.036 --> 00:04:59.396 A:middle
我还想让大家回忆一下

00:04:59.396 --> 00:05:00.706 A:middle
我们早先提到的一个

00:04:59.396 --> 00:05:00.706 A:middle
我们早先提到的一个

00:05:00.706 --> 00:05:01.876 A:middle
很厉害的新滤镜

00:05:01.876 --> 00:05:03.166 A:middle
是在图像编辑那场里

00:05:03.166 --> 00:05:04.846 A:middle
叫作 CIDepthBlurEffect

00:05:04.846 --> 00:05:06.436 A:middle
作用是让你能使用

00:05:06.436 --> 00:05:08.516 A:middle
出色的深度模糊效果

00:05:08.566 --> 00:05:10.286 A:middle
就像我们在相机照片

00:05:10.286 --> 00:05:11.176 A:middle
应用中所用的那种

00:05:13.016 --> 00:05:14.976 A:middle
再说一次我还是要

00:05:14.976 --> 00:05:16.836 A:middle
强烈推荐大家去看看

00:05:16.836 --> 00:05:18.416 A:middle
今天早些时候录制的

00:05:18.416 --> 00:05:19.696 A:middle
图像编辑与深度讲座

00:05:21.336 --> 00:05:23.226 A:middle
我们也根据收到的

00:05:23.226 --> 00:05:24.736 A:middle
强烈要求加入了

00:05:24.736 --> 00:05:25.286 A:middle
另外几种新滤镜

00:05:25.506 --> 00:05:26.826 A:middle
有一个滤镜

00:05:26.826 --> 00:05:28.026 A:middle
可让大家用文本

00:05:28.026 --> 00:05:29.016 A:middle
生成图像很适合

00:05:29.016 --> 00:05:30.506 A:middle
在给视频添加水印

00:05:30.506 --> 00:05:32.446 A:middle
或其他文本覆层时

00:05:32.446 --> 00:05:32.906 A:middle
使用

00:05:33.546 --> 00:05:34.886 A:middle
还有一款滤镜

00:05:34.886 --> 00:05:36.136 A:middle
可让大家在 LabDeltaE 空间内

00:05:36.136 --> 00:05:37.946 A:middle
对比两幅图像很适合

00:05:38.006 --> 00:05:39.666 A:middle
用来查看编辑结果

00:05:39.666 --> 00:05:41.146 A:middle
是否符合预期

00:05:41.146 --> 00:05:42.486 A:middle
或者让用户获取

00:05:42.486 --> 00:05:43.536 A:middle
图像修改程度的信息

00:05:44.666 --> 00:05:47.576 A:middle
我们也添加了新的

00:05:47.576 --> 00:05:49.216 A:middle
双立方上采样下采样滤镜

00:05:49.646 --> 00:05:51.666 A:middle
非常适合多种

00:05:51.666 --> 00:05:52.196 A:middle
用途的使用

00:05:53.006 --> 00:05:54.126 A:middle
我们还推出了一种

00:05:54.126 --> 00:05:55.306 A:middle
新的条形码生成方法

00:05:55.306 --> 00:05:56.586 A:middle
我会在稍后

00:05:56.586 --> 00:05:57.336 A:middle
更加详细地讲解

00:05:59.416 --> 00:06:00.676 A:middle
最后滤镜方面

00:05:59.416 --> 00:06:00.676 A:middle
最后滤镜方面

00:06:00.676 --> 00:06:01.716 A:middle
这次有一些滤镜

00:06:02.196 --> 00:06:03.376 A:middle
相比上次发行

00:06:03.376 --> 00:06:03.696 A:middle
做了一些改进

00:06:03.696 --> 00:06:04.756 A:middle
这次有几款

00:06:04.876 --> 00:06:06.396 A:middle
混合模式滤镜

00:06:06.836 --> 00:06:07.946 A:middle
现在的效果更合乎期望

00:06:07.946 --> 00:06:10.166 A:middle
我们还大幅提高了

00:06:10.346 --> 00:06:11.876 A:middle
去马赛克滤镜和

00:06:11.876 --> 00:06:12.986 A:middle
降噪滤镜的质量

00:06:12.986 --> 00:06:14.276 A:middle
这些都隶属于 RAW 图像处理

00:06:14.686 --> 00:06:17.056 A:middle
我们推出新的相机

00:06:17.056 --> 00:06:17.926 A:middle
我们也将

00:06:17.926 --> 00:06:18.816 A:middle
为新款相机提供支持

00:06:18.816 --> 00:06:19.976 A:middle
届时大家将会看到这些改进

00:06:24.506 --> 00:06:26.446 A:middle
新滤镜的情况就是这样

00:06:26.516 --> 00:06:28.836 A:middle
现在我想请 Tony 上台

00:06:28.836 --> 00:06:29.976 A:middle
他将为大家详细讲解

00:06:29.976 --> 00:06:32.156 A:middle
如何直接使用 Metal

00:06:32.336 --> 00:06:33.456 A:middle
来编写内核

00:06:33.456 --> 00:06:33.976 A:middle
这也是个很棒的新特性

00:06:39.916 --> 00:06:40.246 A:middle
&gt;&gt;  好的

00:06:40.246 --> 00:06:41.506 A:middle
谢谢 David

00:06:42.036 --> 00:06:42.856 A:middle
大家下午好

00:06:43.006 --> 00:06:44.446 A:middle
我叫 Tony 真的很开心

00:06:44.446 --> 00:06:45.636 A:middle
能来为大家讲解

00:06:45.636 --> 00:06:46.936 A:middle
我们为 Core Image

00:06:46.936 --> 00:06:47.436 A:middle
添加的新特性

00:06:48.036 --> 00:06:49.426 A:middle
让我们直接进入正题

00:06:50.036 --> 00:06:51.176 A:middle
首先让我们先来

00:06:51.176 --> 00:06:52.316 A:middle
明确一下这个问题的语境

00:06:52.456 --> 00:06:54.006 A:middle
如果这里指的是

00:06:54.006 --> 00:06:55.106 A:middle
我们刚才看到过的

00:06:55.106 --> 00:06:55.556 A:middle
这张简单滤镜的图表

00:06:55.556 --> 00:06:57.226 A:middle
我们现在所讲的

00:06:57.226 --> 00:06:58.636 A:middle
就是这些内核大家可以

00:06:58.636 --> 00:07:00.356 A:middle
在底部这里看到

00:06:58.636 --> 00:07:00.356 A:middle
在底部这里看到

00:07:00.356 --> 00:07:01.566 A:middle
你可以用它来实现自己的

00:07:01.566 --> 00:07:03.116 A:middle
自定义代码代码内容

00:07:03.116 --> 00:07:04.536 A:middle
就是精确描述你想在

00:07:04.536 --> 00:07:06.006 A:middle
GPU 上执行的像素处理方式

00:07:06.606 --> 00:07:09.546 A:middle
在以前这些内核

00:07:09.546 --> 00:07:10.566 A:middle
都是使用 CIKernel 语言

00:07:10.566 --> 00:07:12.496 A:middle
编写这是一种

00:07:12.496 --> 00:07:14.946 A:middle
基于 GLSL 的着色语言

00:07:14.946 --> 00:07:16.586 A:middle
但它也提供一些扩展

00:07:16.906 --> 00:07:18.466 A:middle
能让 Core Image 支持

00:07:18.466 --> 00:07:20.206 A:middle
自动平铺和

00:07:20.206 --> 00:07:20.586 A:middle
分区域渲染

00:07:22.046 --> 00:07:23.176 A:middle
举个例子我们有一个函数

00:07:23.176 --> 00:07:24.286 A:middle
叫作 destCoord

00:07:24.286 --> 00:07:25.456 A:middle
能让你获得

00:07:25.526 --> 00:07:26.486 A:middle
你准备渲染的

00:07:26.486 --> 00:07:28.066 A:middle
目标坐标

00:07:28.066 --> 00:07:28.986 A:middle
无论你是要渲染

00:07:28.986 --> 00:07:30.486 A:middle
输出的一个区域

00:07:30.486 --> 00:07:31.566 A:middle
还是要平铺输出图像

00:07:33.026 --> 00:07:34.276 A:middle
我们还有两个函数

00:07:34.276 --> 00:07:34.866 A:middle
分别叫作

00:07:34.866 --> 00:07:37.196 A:middle
samplerTransform和sample

00:07:37.196 --> 00:07:38.346 A:middle
能让你对输入图像

00:07:38.346 --> 00:07:40.036 A:middle
进行采样无论

00:07:40.036 --> 00:07:41.066 A:middle
输入图像是否经过平铺处理

00:07:41.536 --> 00:07:43.436 A:middle
所以就像 David

00:07:43.436 --> 00:07:44.556 A:middle
之前提过的这能为

00:07:44.556 --> 00:07:46.086 A:middle
平铺操作提供妥善的抽象化

00:07:46.086 --> 00:07:46.926 A:middle
让你在编写你的

00:07:46.926 --> 00:07:48.346 A:middle
内核时不用为此烦心

00:07:50.696 --> 00:07:52.056 A:middle
当这些内核

00:07:52.056 --> 00:07:53.006 A:middle
编写完毕后它们会

00:07:53.006 --> 00:07:54.786 A:middle
接着经过转译

00:07:54.786 --> 00:07:55.946 A:middle
尽可能多地与其他内核

00:07:55.946 --> 00:07:57.476 A:middle
并置在一起然后

00:07:57.476 --> 00:07:59.216 A:middle
在运行时被编译成

00:07:59.216 --> 00:08:00.456 A:middle
Metal 或者 GLSL

00:07:59.216 --> 00:08:00.456 A:middle
Metal 或者 GLSL

00:08:01.686 --> 00:08:03.576 A:middle
对于 Metal 这样的

00:08:03.576 --> 00:08:05.786 A:middle
富语言编译阶段

00:08:05.786 --> 00:08:07.146 A:middle
在运行时可能会

00:08:07.146 --> 00:08:07.576 A:middle
耗费很长的一段时间

00:08:07.576 --> 00:08:09.356 A:middle
事实上在最坏情景下

00:08:09.356 --> 00:08:10.446 A:middle
如果你是要渲染

00:08:10.446 --> 00:08:12.086 A:middle
一幅很小的输入图像...抱歉

00:08:12.086 --> 00:08:13.456 A:middle
渲染一幅很小的图像

00:08:13.456 --> 00:08:14.546 A:middle
或者相对简单的滤镜图表

00:08:14.546 --> 00:08:16.236 A:middle
大部分的时间可能

00:08:16.236 --> 00:08:17.656 A:middle
都会花在编译上

00:08:17.656 --> 00:08:18.776 A:middle
而非实际的渲染上

00:08:19.386 --> 00:08:21.646 A:middle
为了给大家看个例子

00:08:21.646 --> 00:08:23.786 A:middle
这里有个案例

00:08:23.786 --> 00:08:25.206 A:middle
是在任何编译结果被写入

00:08:25.206 --> 00:08:26.606 A:middle
cache 前的第一次渲染时

00:08:27.146 --> 00:08:28.116 A:middle
大家可以看到有大量时间

00:08:28.116 --> 00:08:29.376 A:middle
都花费在编译

00:08:29.376 --> 00:08:29.796 A:middle
而非渲染上

00:08:29.946 --> 00:08:31.606 A:middle
所以如果我们逐句

00:08:32.155 --> 00:08:33.706 A:middle
调试下这些步骤第一步

00:08:33.706 --> 00:08:35.126 A:middle
是翻译这里蓝色显示的

00:08:35.126 --> 00:08:35.996 A:middle
CIKernel

00:08:36.535 --> 00:08:37.476 A:middle
第二个步骤是

00:08:37.476 --> 00:08:38.726 A:middle
并置这些 CIKernel

00:08:39.035 --> 00:08:40.796 A:middle
接下来这一步里

00:08:40.796 --> 00:08:42.346 A:middle
我们要把 CIKernel

00:08:42.346 --> 00:08:43.616 A:middle
编译成中间表示

00:08:43.756 --> 00:08:45.046 A:middle
这个过程是

00:08:45.046 --> 00:08:45.416 A:middle
独立于设备类型的

00:08:45.486 --> 00:08:47.026 A:middle
然后是最后一步

00:08:47.026 --> 00:08:50.956 A:middle
要把中间表示编译成

00:08:50.956 --> 00:08:53.386 A:middle
GPU 代码以便在

00:08:53.386 --> 00:08:53.906 A:middle
GPU 上执行

00:08:55.216 --> 00:08:56.646 A:middle
这里的问题在于

00:08:56.646 --> 00:08:59.246 A:middle
CIKernel 的并置

00:08:59.246 --> 00:09:00.276 A:middle
原本是在运行时

00:08:59.246 --> 00:09:00.276 A:middle
原本是在运行时

00:09:00.276 --> 00:09:04.366 A:middle
动态完成的如果我们

00:09:04.366 --> 00:09:06.166 A:middle
把这个过程放到编译后

00:09:06.166 --> 00:09:07.936 A:middle
再来完成会是什么结果呢

00:09:08.876 --> 00:09:10.686 A:middle
结果就是让我们能够

00:09:10.686 --> 00:09:12.076 A:middle
将成本非常高的

00:09:12.076 --> 00:09:14.196 A:middle
编译过程提到构建时完成

00:09:14.196 --> 00:09:15.676 A:middle
最后只留下那些

00:09:15.676 --> 00:09:17.136 A:middle
需要在运行时

00:09:17.486 --> 00:09:18.176 A:middle
完成的部分

00:09:18.806 --> 00:09:20.166 A:middle
大家可以看到

00:09:20.166 --> 00:09:21.666 A:middle
这样做对 CPU 的

00:09:21.666 --> 00:09:23.876 A:middle
利用要高效很多不用说

00:09:23.876 --> 00:09:24.426 A:middle
耗电量也会减少

00:09:24.996 --> 00:09:27.216 A:middle
所以我要很高兴地告诉大家

00:09:27.216 --> 00:09:29.256 A:middle
Core Image 现在也能这么做了

00:09:29.256 --> 00:09:30.536 A:middle
只要直接使用 Metal

00:09:30.536 --> 00:09:31.416 A:middle
编写 CIKernel 就好

00:09:31.916 --> 00:09:34.146 A:middle
为了实现这一点需要我们

00:09:34.146 --> 00:09:35.496 A:middle
与 Metal 框架的开发团队

00:09:35.496 --> 00:09:36.656 A:middle
和 Metal 编译器的开发团队

00:09:36.656 --> 00:09:37.866 A:middle
展开十分密切的

00:09:37.866 --> 00:09:38.026 A:middle
合作

00:09:38.026 --> 00:09:39.386 A:middle
我们认为这样做

00:09:39.386 --> 00:09:40.696 A:middle
将会打开新的大门

00:09:40.696 --> 00:09:41.716 A:middle
迎来令人兴奋的新机遇

00:09:43.326 --> 00:09:44.256 A:middle
首先我要特别讲几个

00:09:44.256 --> 00:09:45.546 A:middle
大家现在已经感受到的

00:09:45.546 --> 00:09:47.176 A:middle
主要优点

00:09:48.276 --> 00:09:51.056 A:middle
就像之前看到的

00:09:51.056 --> 00:09:52.466 A:middle
CIKernel 现在已支持

00:09:52.466 --> 00:09:54.526 A:middle
在构建时进行离线预编译

00:09:54.666 --> 00:09:55.956 A:middle
有了这项功能

00:09:55.956 --> 00:09:57.056 A:middle
你就能很方便地

00:09:57.056 --> 00:09:57.836 A:middle
进行出错诊断

00:09:58.156 --> 00:09:59.266 A:middle
如果你在编写内核时

00:09:59.266 --> 00:10:00.376 A:middle
拼错了单词或者出了什么错

00:09:59.266 --> 00:10:00.376 A:middle
拼错了单词或者出了什么错

00:10:00.376 --> 00:10:01.816 A:middle
都能直接在 Xcode 中看到

00:10:02.236 --> 00:10:03.636 A:middle
而不必等到运行时

00:10:03.636 --> 00:10:05.336 A:middle
才检测出问题

00:10:06.316 --> 00:10:08.236 A:middle
第二点则是添加了

00:10:08.236 --> 00:10:09.596 A:middle
更多的现代语言支持

00:10:09.596 --> 00:10:11.456 A:middle
因为 Metal 就是一种

00:10:11.456 --> 00:10:12.796 A:middle
近几年才问世的

00:10:12.796 --> 00:10:13.766 A:middle
基于 C++ 的语言

00:10:13.836 --> 00:10:17.536 A:middle
我还想强调一点

00:10:17.736 --> 00:10:19.106 A:middle
用 Metal 编写 CIKernel 时

00:10:19.316 --> 00:10:20.976 A:middle
大家照样能够享受

00:10:20.976 --> 00:10:22.496 A:middle
并置平铺这些优点

00:10:22.596 --> 00:10:23.646 A:middle
这也是多年来

00:10:23.646 --> 00:10:24.836 A:middle
我们为 Core Image 框架

00:10:24.836 --> 00:10:25.246 A:middle
做出的重大突破

00:10:25.586 --> 00:10:26.776 A:middle
所以改用现在的

00:10:26.776 --> 00:10:28.356 A:middle
新方法编写 CIKernel

00:10:28.356 --> 00:10:28.606 A:middle
不会带来任何损失

00:10:29.166 --> 00:10:31.346 A:middle
另外这些用 Metal

00:10:31.346 --> 00:10:33.796 A:middle
写成的新 CIKernel

00:10:33.796 --> 00:10:34.756 A:middle
也可以与旧版的

00:10:34.756 --> 00:10:35.386 A:middle
CIKernel 一起混用

00:10:35.686 --> 00:10:37.496 A:middle
所以在今后的图像中

00:10:37.496 --> 00:10:39.656 A:middle
既可以包含旧版的内核

00:10:39.656 --> 00:10:40.616 A:middle
也可以包含 Metal 写成的内核

00:10:40.876 --> 00:10:42.466 A:middle
这能让这项新特性

00:10:42.766 --> 00:10:45.436 A:middle
与大家现有的应用程序

00:10:45.566 --> 00:10:46.766 A:middle
实现最大兼容

00:10:47.336 --> 00:10:50.036 A:middle
大家可能也希望

00:10:50.196 --> 00:10:51.316 A:middle
这项特性能够得到

00:10:51.316 --> 00:10:52.896 A:middle
各类平台的广泛支持也就是

00:10:52.896 --> 00:10:56.066 A:middle
支持 A8 或更新版本的 iOS

00:10:56.066 --> 00:10:59.506 A:middle
还有 macOS 和 tvOS

00:10:59.686 --> 00:11:01.136 A:middle
现在我们来看一下

00:10:59.686 --> 00:11:01.136 A:middle
现在我们来看一下

00:11:01.136 --> 00:11:02.516 A:middle
到底要如何用 Metal

00:11:02.516 --> 00:11:03.136 A:middle
创建这些 CIKernel

00:11:03.656 --> 00:11:05.886 A:middle
第一步就是用 Metal 着色文件

00:11:05.886 --> 00:11:07.466 A:middle
来编写你的 CIKernel

00:11:09.316 --> 00:11:11.366 A:middle
接着在你完成这个 CIKernel 的

00:11:11.366 --> 00:11:12.946 A:middle
实现后第二步就是

00:11:12.976 --> 00:11:14.236 A:middle
编译和链接 Metal 着色文件

00:11:14.236 --> 00:11:16.296 A:middle
以便生成相应的 Metal 库

00:11:16.296 --> 00:11:17.616 A:middle
可在运行时

00:11:17.616 --> 00:11:18.656 A:middle
进行加载

00:11:19.236 --> 00:11:21.696 A:middle
接着最后一步就是

00:11:22.266 --> 00:11:23.996 A:middle
用 Metal 库内的任何函数

00:11:23.996 --> 00:11:25.066 A:middle
对 CIKernel 进行

00:11:25.066 --> 00:11:25.446 A:middle
初始化

00:11:25.446 --> 00:11:28.926 A:middle
那么我们来具体地

00:11:28.926 --> 00:11:29.916 A:middle
看下第一步

00:11:29.916 --> 00:11:32.466 A:middle
用 Metal 编写 CIKernel

00:11:33.216 --> 00:11:34.286 A:middle
对于这项任务我要向

00:11:34.286 --> 00:11:35.266 A:middle
大家介绍我们新推出的

00:11:35.266 --> 00:11:36.586 A:middle
CIKernal Metal 库

00:11:37.086 --> 00:11:38.346 A:middle
它基本上就是一个

00:11:38.346 --> 00:11:40.046 A:middle
头文件包含我们为

00:11:40.046 --> 00:11:41.806 A:middle
Metal 着色语言添加的

00:11:41.806 --> 00:11:42.616 A:middle
CIKernel 扩展

00:11:42.936 --> 00:11:44.876 A:middle
换句话说我们加入了一些

00:11:44.876 --> 00:11:47.536 A:middle
新的数据类型比如目标 (destination)

00:11:47.636 --> 00:11:48.906 A:middle
采样器 (sampler) 样本 (sample)

00:11:49.536 --> 00:11:51.216 A:middle
目标类型可让你获得

00:11:51.216 --> 00:11:52.386 A:middle
你需要的有关输出的

00:11:52.706 --> 00:11:54.506 A:middle
所有信息

00:11:55.046 --> 00:11:56.506 A:middle
采样器类型可让你获得

00:11:56.506 --> 00:11:57.846 A:middle
有关输入图像的

00:11:57.846 --> 00:11:58.556 A:middle
所有信息

00:11:59.136 --> 00:12:00.916 A:middle
样本类型则用来表示

00:11:59.136 --> 00:12:00.916 A:middle
样本类型则用来表示

00:12:00.916 --> 00:12:02.866 A:middle
输入图像中的某个

00:12:02.866 --> 00:12:03.476 A:middle
单色样本

00:12:04.766 --> 00:12:05.856 A:middle
除了这些数据类型外

00:12:05.856 --> 00:12:07.136 A:middle
我们也添加了一些

00:12:07.136 --> 00:12:08.336 A:middle
实用函数非常方便

00:12:08.336 --> 00:12:09.256 A:middle
图像处理使用

00:12:10.666 --> 00:12:11.776 A:middle
比如说你可以进行

00:12:11.776 --> 00:12:13.846 A:middle
预乘 (premulitply) 去预乘 (unpremultiply)

00:12:13.926 --> 00:12:14.986 A:middle
还可以进行不同

00:12:14.986 --> 00:12:16.316 A:middle
色彩空间之间的

00:12:16.466 --> 00:12:17.196 A:middle
一些色彩转换

00:12:17.616 --> 00:12:19.816 A:middle
所以这些新扩展的

00:12:20.196 --> 00:12:21.366 A:middle
语义与它们用在

00:12:21.366 --> 00:12:22.586 A:middle
CIKernel 语言中的时候

00:12:22.586 --> 00:12:23.056 A:middle
是一样的

00:12:23.536 --> 00:12:25.686 A:middle
只是在涉及目标和

00:12:25.876 --> 00:12:27.496 A:middle
采样器类型时稍微存在

00:12:27.496 --> 00:12:29.116 A:middle
一点语法上的差异

00:12:29.836 --> 00:12:30.566 A:middle
让我来给大家

00:12:30.566 --> 00:12:31.346 A:middle
看个更具体的例子

00:12:32.096 --> 00:12:34.426 A:middle
这里有一小段代码

00:12:34.556 --> 00:12:35.786 A:middle
我们的 CIKernel Metal 库

00:12:35.786 --> 00:12:35.976 A:middle
看起来就是这样

00:12:36.596 --> 00:12:38.706 A:middle
库的名字是 CIKernelMetalLib.h

00:12:39.276 --> 00:12:40.686 A:middle
我们所有的扩展

00:12:40.806 --> 00:12:42.316 A:middle
都在 CoreImage 这个

00:12:42.316 --> 00:12:43.906 A:middle
命名空间中加以声明

00:12:43.906 --> 00:12:44.746 A:middle
以免与 Metal 发生冲突

00:12:45.326 --> 00:12:47.386 A:middle
这里的第一步就是

00:12:47.386 --> 00:12:48.796 A:middle
定义一个目标

00:12:48.916 --> 00:12:50.196 A:middle
它包含一个函数

00:12:50.196 --> 00:12:51.456 A:middle
可让你用来读取

00:12:51.456 --> 00:12:52.106 A:middle
目标的坐标

00:12:53.076 --> 00:12:54.126 A:middle
在以前使用 CIKernel 语言

00:12:54.176 --> 00:12:55.676 A:middle
编写 CIKernel 内核的时候

00:12:55.676 --> 00:12:57.776 A:middle
只能通过一个叫作

00:12:57.776 --> 00:12:59.496 A:middle
destCoord 的全局函数

00:12:59.496 --> 00:13:00.276 A:middle
来完成

00:12:59.496 --> 00:13:00.276 A:middle
来完成

00:13:00.606 --> 00:13:01.346 A:middle
而现在使用 Metal 语言

00:13:01.346 --> 00:13:02.926 A:middle
编写内核的话

00:13:02.926 --> 00:13:04.616 A:middle
只需要将这个数据类型

00:13:04.616 --> 00:13:05.646 A:middle
声明为内核的实参

00:13:05.646 --> 00:13:06.506 A:middle
就能访问这个方法

00:13:07.046 --> 00:13:09.396 A:middle
接下来要定义的

00:13:09.396 --> 00:13:10.636 A:middle
第二种数据类型是 sampler

00:13:11.136 --> 00:13:12.226 A:middle
它所包含的方法就是以前

00:13:12.226 --> 00:13:13.866 A:middle
那些同名的全局函数

00:13:13.866 --> 00:13:15.326 A:middle
但它们现在被定义成了

00:13:15.326 --> 00:13:17.326 A:middle
sampler 类型的

00:13:17.326 --> 00:13:18.656 A:middle
成员函数

00:13:19.226 --> 00:13:22.436 A:middle
为了更好地概括

00:13:22.436 --> 00:13:23.986 A:middle
这些函数这里有个表格

00:13:23.986 --> 00:13:25.496 A:middle
能让大家看到过去在

00:13:25.496 --> 00:13:28.166 A:middle
CIKernel 语言里使用的语法

00:13:28.166 --> 00:13:29.796 A:middle
和如今在 Metal 里

00:13:29.796 --> 00:13:30.996 A:middle
使用的语法

00:13:31.596 --> 00:13:32.416 A:middle
大家还可以看到

00:13:32.416 --> 00:13:34.446 A:middle
在 CIKernel 语言中所有函数

00:13:34.446 --> 00:13:35.636 A:middle
全用全球函数的方式来实现

00:13:35.756 --> 00:13:37.176 A:middle
而现在在 Metal 中它们

00:13:37.176 --> 00:13:38.616 A:middle
全都会被定义为相应

00:13:38.616 --> 00:13:39.466 A:middle
数据类型的成员函数

00:13:40.046 --> 00:13:40.886 A:middle
所以我们认为

00:13:40.886 --> 00:13:41.846 A:middle
这种新语法将能让

00:13:41.846 --> 00:13:43.326 A:middle
大家把代码写得

00:13:43.476 --> 00:13:44.816 A:middle
更简明更易读

00:13:46.766 --> 00:13:47.996 A:middle
出于可移植性的考虑

00:13:47.996 --> 00:13:49.546 A:middle
我们也在头文件中

00:13:49.546 --> 00:13:51.336 A:middle
包含了 sampler 的全局函数

00:13:51.336 --> 00:13:52.886 A:middle
实质上就是把新语法

00:13:52.886 --> 00:13:53.506 A:middle
封装了一下

00:13:53.586 --> 00:13:54.746 A:middle
这样一来就能让大家

00:13:54.746 --> 00:13:55.856 A:middle
只需要修改最少的代码

00:13:55.856 --> 00:13:57.016 A:middle
就能将已有的内核

00:13:57.016 --> 00:13:58.326 A:middle
导入到 Metal 中

00:13:58.926 --> 00:14:01.786 A:middle
现在我们来看几个用 Metal

00:13:58.926 --> 00:14:01.786 A:middle
现在我们来看几个用 Metal

00:14:01.786 --> 00:14:03.226 A:middle
编写的 CIKernel 例子

00:14:03.316 --> 00:14:04.896 A:middle
我们看到的第一个例子

00:14:04.966 --> 00:14:06.456 A:middle
是一个 warp 内核

00:14:06.626 --> 00:14:08.456 A:middle
在编写任何 Metal 着色器时

00:14:08.456 --> 00:14:09.156 A:middle
需要引入的第一个库

00:14:09.156 --> 00:14:10.756 A:middle
就是 metal_stdlib

00:14:10.756 --> 00:14:12.776 A:middle
而在编写 CIKernel 时

00:14:12.776 --> 00:14:14.266 A:middle
还需要引入我们的 Metal

00:14:14.266 --> 00:14:15.896 A:middle
内核库具体方法

00:14:15.896 --> 00:14:17.046 A:middle
就是引入一个综合头文件

00:14:17.096 --> 00:14:20.166 A:middle
CoreImage.h 接下来

00:14:20.406 --> 00:14:22.686 A:middle
第二步是在

00:14:22.686 --> 00:14:25.076 A:middle
Extern “C" 这个部分中

00:14:25.076 --> 00:14:29.226 A:middle
实现你要的所有内核它的作用

00:14:29.226 --> 00:14:30.276 A:middle
是让这些内核可以在运行时

00:14:30.276 --> 00:14:31.886 A:middle
通过名称来访问

00:14:32.956 --> 00:14:35.326 A:middle
这里写的是一个简单的内核

00:14:35.326 --> 00:14:36.396 A:middle
叫作 myWarp

00:14:36.616 --> 00:14:37.966 A:middle
它只需要一个实参

00:14:37.966 --> 00:14:39.606 A:middle
数据类型为 destination

00:14:40.086 --> 00:14:41.246 A:middle
根据这个实参

00:14:41.246 --> 00:14:42.436 A:middle
你便可以获取

00:14:42.436 --> 00:14:43.936 A:middle
有待执行渲染

00:14:43.936 --> 00:14:45.206 A:middle
和实现你想看到的

00:14:45.206 --> 00:14:46.346 A:middle
各种几何变换的

00:14:46.346 --> 00:14:46.496 A:middle
相应坐标

00:14:46.756 --> 00:14:47.906 A:middle
然后返回执行的结果

00:14:47.906 --> 00:14:50.036 A:middle
作为对比

00:14:50.166 --> 00:14:51.456 A:middle
这里也有一个同样的

00:14:51.456 --> 00:14:52.586 A:middle
warp 内核不过是用

00:14:52.586 --> 00:14:53.546 A:middle
CIKernel 语言实现的

00:14:54.126 --> 00:14:56.276 A:middle
大家可以看到这两段代码

00:14:56.276 --> 00:14:58.166 A:middle
几乎完全相同只有一些

00:14:58.526 --> 00:14:59.506 A:middle
细微的语法差异

00:14:59.896 --> 00:15:00.886 A:middle
但它们的语义是

00:14:59.896 --> 00:15:00.886 A:middle
但它们的语义是

00:15:00.886 --> 00:15:02.306 A:middle
完全相同的到最后

00:15:02.306 --> 00:15:04.156 A:middle
也都会被编译成一模一样的

00:15:04.746 --> 00:15:04.846 A:middle
一段 GPU 代码

00:15:06.036 --> 00:15:07.586 A:middle
第二个例子是个

00:15:07.586 --> 00:15:08.246 A:middle
color 内核

00:15:08.696 --> 00:15:09.926 A:middle
它的大部分代码

00:15:09.926 --> 00:15:11.376 A:middle
看上去都差不多

00:15:11.376 --> 00:15:12.396 A:middle
唯一的区别就是换成了

00:15:12.396 --> 00:15:14.616 A:middle
一个叫作 myColor 的内核

00:15:14.616 --> 00:15:16.066 A:middle
它的输入只需要一个

00:15:16.066 --> 00:15:16.436 A:middle
sample 类型的实参

00:15:16.546 --> 00:15:18.406 A:middle
根据这个实参你可以应用

00:15:18.406 --> 00:15:19.836 A:middle
你想要看到的

00:15:19.836 --> 00:15:21.286 A:middle
各种色彩变换最后

00:15:21.286 --> 00:15:22.076 A:middle
同样是返回执行结果

00:15:23.616 --> 00:15:25.336 A:middle
那么这里同样是

00:15:25.336 --> 00:15:26.636 A:middle
用 CIKernel 语言实现的

00:15:26.696 --> 00:15:27.686 A:middle
同一个 color 内核

00:15:28.226 --> 00:15:31.146 A:middle
我想给大家看的

00:15:31.146 --> 00:15:32.916 A:middle
最后一个例子是个通用内核

00:15:33.466 --> 00:15:35.026 A:middle
可以在你的内核既不能用

00:15:35.026 --> 00:15:36.286 A:middle
warp 内核也不能用 color 内核

00:15:36.286 --> 00:15:37.246 A:middle
实现的时候使用

00:15:37.936 --> 00:15:39.096 A:middle
所以这里有这样一个内核

00:15:39.096 --> 00:15:39.906 A:middle
叫作 myKernel

00:15:39.906 --> 00:15:41.756 A:middle
它只需要一个输入参数

00:15:42.046 --> 00:15:44.006 A:middle
数据类型是 sampler

00:15:44.006 --> 00:15:44.996 A:middle
根据这个参数你就可以对

00:15:44.996 --> 00:15:46.516 A:middle
输入图像的任意部位采样

00:15:46.516 --> 00:15:48.176 A:middle
根据你的需要获取

00:15:48.176 --> 00:15:48.696 A:middle
足够数量的样本

00:15:49.256 --> 00:15:50.016 A:middle
同样在这里

00:15:50.016 --> 00:15:51.306 A:middle
执行一些操作

00:15:51.306 --> 00:15:51.776 A:middle
返回执行结果

00:15:52.946 --> 00:15:54.256 A:middle
同样这个是

00:15:54.296 --> 00:15:56.686 A:middle
用以前的 CIKernal 语言

00:15:56.686 --> 00:15:57.636 A:middle
写成的同一个 CIKernal 内核

00:15:58.226 --> 00:16:01.776 A:middle
现在你已经在 Metal 着色文件中

00:15:58.226 --> 00:16:01.776 A:middle
现在你已经在 Metal 着色文件中

00:16:01.776 --> 00:16:02.736 A:middle
完成了 CIKernal 的实现

00:16:02.736 --> 00:16:04.306 A:middle
下一步就是

00:16:04.306 --> 00:16:05.556 A:middle
编译和链接 Metal

00:16:05.556 --> 00:16:05.876 A:middle
着色文件

00:16:07.856 --> 00:16:08.726 A:middle
对于有过 Metal 着色器

00:16:08.726 --> 00:16:10.076 A:middle
编写经验的人来说

00:16:10.076 --> 00:16:11.416 A:middle
这套构建管道看起来

00:16:11.416 --> 00:16:13.296 A:middle
应该十分眼熟

00:16:13.726 --> 00:16:14.776 A:middle
基本上它分为

00:16:14.776 --> 00:16:15.206 A:middle
两个阶段

00:16:15.536 --> 00:16:17.646 A:middle
第一个阶段是

00:16:17.646 --> 00:16:20.086 A:middle
将.metal 编译成.air 文件

00:16:20.086 --> 00:16:21.796 A:middle
第二个阶段是

00:16:21.796 --> 00:16:23.446 A:middle
链接.air 文件然后把它

00:16:23.446 --> 00:16:24.486 A:middle
打包在.metallib 文件里

00:16:25.946 --> 00:16:27.506 A:middle
处理 CIKernel 时只需要

00:16:27.506 --> 00:16:29.086 A:middle
在这里多做一件事

00:16:29.086 --> 00:16:30.256 A:middle
就是设定几个新的选项

00:16:31.306 --> 00:16:32.626 A:middle
第一个需要设定的选项

00:16:32.626 --> 00:16:33.926 A:middle
是针对编译器的

00:16:34.116 --> 00:16:35.746 A:middle
叫作-fcikernel

00:16:35.776 --> 00:16:38.346 A:middle
第二个选项是

00:16:38.346 --> 00:16:39.796 A:middle
针对链接器的

00:16:40.366 --> 00:16:40.946 A:middle
叫作-cikernel

00:16:40.946 --> 00:16:42.496 A:middle
注意这个选项

00:16:42.496 --> 00:16:42.876 A:middle
就是少了个 f

00:16:43.736 --> 00:16:44.946 A:middle
你可以直接在 Xcode 里

00:16:44.986 --> 00:16:47.446 A:middle
完成这一步让我用

00:16:47.446 --> 00:16:48.836 A:middle
一段小视频给大家演示一下

00:16:48.836 --> 00:16:50.086 A:middle
这个步骤是如何

00:16:50.086 --> 00:16:50.346 A:middle
完成的

00:16:51.536 --> 00:16:53.876 A:middle
对于编译器选项

00:16:53.876 --> 00:16:54.886 A:middle
只需要查看 Metal 编译器的

00:16:54.886 --> 00:16:56.386 A:middle
Build Options 然后直接在

00:16:56.386 --> 00:16:59.656 A:middle
Other Metal Compiler Flags 中

00:16:59.656 --> 00:17:00.976 A:middle
写明-fcikernel 即可

00:16:59.656 --> 00:17:00.976 A:middle
写明-fcikernel 即可

00:17:01.556 --> 00:17:03.346 A:middle
由于链接器选项没有

00:17:03.346 --> 00:17:05.326 A:middle
这种界面来进行相关设置

00:17:05.326 --> 00:17:06.246 A:middle
必须使用

00:17:06.246 --> 00:17:07.336 A:middle
Add User-Defined Setting

00:17:08.036 --> 00:17:09.726 A:middle
然后为它设置一个键

00:17:09.776 --> 00:17:12.576 A:middle
命名为 MTLLINKER_FLAGS

00:17:12.576 --> 00:17:15.086 A:middle
然后将对应的值

00:17:15.086 --> 00:17:16.955 A:middle
设定为 -cikernel

00:17:17.036 --> 00:17:19.096 A:middle
你只需要为你的项目

00:17:19.096 --> 00:17:20.126 A:middle
设置一次

00:17:20.126 --> 00:17:21.306 A:middle
之后你在这里处理的

00:17:21.306 --> 00:17:22.536 A:middle
所有的 Metal 着色器都会

00:17:22.756 --> 00:17:23.906 A:middle
自动使用这些选项

00:17:23.906 --> 00:17:24.506 A:middle
进行编译

00:17:25.156 --> 00:17:27.226 A:middle
但如果你更喜欢使用

00:17:27.306 --> 00:17:28.256 A:middle
或者自定义脚本来处理

00:17:28.256 --> 00:17:30.196 A:middle
同样可以调用这两个

00:17:30.226 --> 00:17:32.696 A:middle
编译器和链接器工具

00:17:32.796 --> 00:17:32.956 A:middle
就像这样

00:17:36.496 --> 00:17:38.216 A:middle
那么最后一步大概也是

00:17:38.216 --> 00:17:40.246 A:middle
最简单的一步就是使用

00:17:40.326 --> 00:17:42.166 A:middle
Metal 库中的给定函数

00:17:42.166 --> 00:17:43.036 A:middle
对 CIKernel 进行初始化

00:17:43.596 --> 00:17:46.046 A:middle
为此我们为 CIKernel 类

00:17:46.046 --> 00:17:47.876 A:middle
加入了新的 API

00:17:48.006 --> 00:17:50.416 A:middle
可以让你使用通过函数名

00:17:50.416 --> 00:17:51.906 A:middle
调用的给定函数以及

00:17:51.906 --> 00:17:53.876 A:middle
可在运行时予以

00:17:53.876 --> 00:17:55.306 A:middle
加载的 Metal 库

00:17:55.526 --> 00:17:56.536 A:middle
来初始化 CIKernel

00:17:57.046 --> 00:17:58.156 A:middle
这个 API 还有一个变种

00:17:58.156 --> 00:17:59.826 A:middle
能让你为你的内核

00:17:59.826 --> 00:18:01.696 A:middle
指定一种

00:17:59.826 --> 00:18:01.696 A:middle
指定一种

00:18:01.696 --> 00:18:02.146 A:middle
输出像素格式

00:18:02.206 --> 00:18:04.146 A:middle
如果你的内核只是要

00:18:04.176 --> 00:18:05.566 A:middle
输出一些单一阴影数据

00:18:05.566 --> 00:18:07.296 A:middle
你完全可以为内核

00:18:07.296 --> 00:18:08.916 A:middle
指定一种单一阴影格式

00:18:09.646 --> 00:18:13.166 A:middle
这里有个例子来演示

00:18:13.166 --> 00:18:14.356 A:middle
CIKernel 的初始化

00:18:14.806 --> 00:18:15.786 A:middle
总共只需要

00:18:15.786 --> 00:18:16.406 A:middle
这么三行代码

00:18:17.396 --> 00:18:19.356 A:middle
前两行用来

00:18:19.356 --> 00:18:21.706 A:middle
加载库如果是

00:18:21.706 --> 00:18:22.736 A:middle
在 Xcode 内构建的

00:18:22.736 --> 00:18:23.776 A:middle
会默认调用

00:18:23.776 --> 00:18:24.646 A:middle
default.metallib

00:18:24.816 --> 00:18:26.796 A:middle
而在完成数据加载后

00:18:26.796 --> 00:18:28.116 A:middle
便可以用这个库中的

00:18:28.116 --> 00:18:30.566 A:middle
给定函数名来

00:18:30.566 --> 00:18:31.516 A:middle
初始化 CIKernel 了

00:18:33.336 --> 00:18:35.096 A:middle
同样 warp 和 color 内核

00:18:35.096 --> 00:18:36.756 A:middle
可以用同样的 API

00:18:36.756 --> 00:18:38.066 A:middle
来完成初始化

00:18:39.746 --> 00:18:40.816 A:middle
在完成内核初始化后

00:18:41.146 --> 00:18:42.466 A:middle
你就可以用自己喜欢的方式

00:18:42.466 --> 00:18:43.886 A:middle
应用这个内核生成

00:18:43.886 --> 00:18:45.156 A:middle
你想要的滤镜图像

00:18:46.246 --> 00:18:47.136 A:middle
以上就是使用 Metal

00:18:47.136 --> 00:18:49.326 A:middle
编写 CIKernel 的所有内容

00:18:49.326 --> 00:18:50.186 A:middle
我们认为这会为开发者

00:18:50.186 --> 00:18:51.226 A:middle
新建出很好的工作流

00:18:51.226 --> 00:18:53.876 A:middle
很期待大家能利用这些

00:18:54.396 --> 00:18:55.496 A:middle
新性能做出一些

00:18:55.496 --> 00:18:56.376 A:middle
令人惊艳的

00:18:56.376 --> 00:18:57.036 A:middle
产品来

00:18:59.296 --> 00:18:59.906 A:middle
好的

00:19:00.176 --> 00:19:01.346 A:middle
那么下一个主题

00:19:01.346 --> 00:19:03.496 A:middle
我想讲讲我们用来

00:19:03.496 --> 00:19:05.106 A:middle
渲染目标的一种

00:19:05.106 --> 00:19:05.786 A:middle
新的 API

00:19:06.456 --> 00:19:10.016 A:middle
这款新 API 应用在我们

00:19:10.286 --> 00:19:11.676 A:middle
支持的所有 destination 类型时

00:19:11.846 --> 00:19:12.876 A:middle
都能给出一致统一的

00:19:12.876 --> 00:19:13.336 A:middle
表现

00:19:13.856 --> 00:19:15.776 A:middle
它的名字叫 IOSurfaces

00:19:15.776 --> 00:19:17.306 A:middle
目前是 iOS 上的一款公共 API

00:19:18.226 --> 00:19:19.906 A:middle
我们还支持渲染至

00:19:19.906 --> 00:19:21.976 A:middle
CVPixelBuffer 以及 Metal 和

00:19:21.976 --> 00:19:22.926 A:middle
OpenGL 纹理

00:19:23.896 --> 00:19:25.066 A:middle
甚至是内存中的

00:19:25.066 --> 00:19:26.176 A:middle
某些原始位图数据

00:19:26.736 --> 00:19:29.136 A:middle
这款 API 时首先让你

00:19:29.136 --> 00:19:30.256 A:middle
注意到的一点是

00:19:30.676 --> 00:19:32.386 A:middle
如今它在检测到

00:19:32.386 --> 00:19:33.616 A:middle
渲染失败时会立即返回

00:19:33.616 --> 00:19:35.136 A:middle
并且回复给你

00:19:35.136 --> 00:19:36.626 A:middle
一条出错消息表明

00:19:36.626 --> 00:19:37.006 A:middle
失败原因

00:19:37.496 --> 00:19:39.156 A:middle
所以现在你可以通过程序

00:19:39.156 --> 00:19:40.236 A:middle
检测应用中的此类问题

00:19:40.236 --> 00:19:41.916 A:middle
并在检测到出错时

00:19:42.196 --> 00:19:43.386 A:middle
有所准备地失败

00:19:43.906 --> 00:19:47.706 A:middle
凭借这款 API 你还可以设定

00:19:47.766 --> 00:19:49.376 A:middle
destination 对象的一些

00:19:49.376 --> 00:19:51.426 A:middle
常见属性例如行为是

00:19:51.426 --> 00:19:52.776 A:middle
alpha 模式还是 clamping 模式

00:19:52.776 --> 00:19:54.736 A:middle
甚至可以是你想要用来

00:19:54.776 --> 00:19:55.656 A:middle
渲染输出的

00:19:55.656 --> 00:19:56.246 A:middle
色彩空间

00:19:57.266 --> 00:19:58.936 A:middle
以前在使用旧式的

00:19:58.936 --> 00:20:00.756 A:middle
API 时 alpha 模式和

00:19:58.936 --> 00:20:00.756 A:middle
API 时 alpha 模式和

00:20:00.756 --> 00:20:02.126 A:middle
clamping 模式

00:20:02.126 --> 00:20:03.686 A:middle
都是通过隐晦的方式设定

00:20:03.686 --> 00:20:05.076 A:middle
基于目标所用的格式

00:20:05.626 --> 00:20:06.866 A:middle
而如今你完全可以

00:20:06.866 --> 00:20:08.526 A:middle
明确地使用你想要的

00:20:08.526 --> 00:20:09.586 A:middle
行为进行重写

00:20:11.986 --> 00:20:12.956 A:middle
除了这些常见属性外

00:20:12.956 --> 00:20:14.226 A:middle
我们还添加了几种

00:20:14.226 --> 00:20:15.416 A:middle
新的高级属性

00:20:15.466 --> 00:20:16.976 A:middle
可供你设置目标时使用

00:20:17.036 --> 00:20:18.016 A:middle
例如抖动 (dithering) 和混合 (blending)

00:20:18.736 --> 00:20:19.866 A:middle
举个例子如果你有一个

00:20:19.866 --> 00:20:22.126 A:middle
8位的输出缓冲区

00:20:22.126 --> 00:20:23.476 A:middle
并且打算用来渲染

00:20:23.476 --> 00:20:25.176 A:middle
那你只需要开启抖动

00:20:25.336 --> 00:20:26.586 A:middle
来获得某种感知范围

00:20:26.586 --> 00:20:28.426 A:middle
更广的色彩深度以便减少

00:20:28.426 --> 00:20:30.806 A:middle
可能会在图像

00:20:30.806 --> 00:20:31.866 A:middle
局部区域出现的

00:20:31.866 --> 00:20:32.336 A:middle
一些色带瑕疵

00:20:32.866 --> 00:20:36.546 A:middle
这些属性有一点

00:20:36.546 --> 00:20:38.226 A:middle
很不错就是

00:20:38.336 --> 00:20:40.016 A:middle
能够有效地降低

00:20:40.016 --> 00:20:41.766 A:middle
被迫创建多个

00:20:41.766 --> 00:20:42.546 A:middle
CIContext 的需要

00:20:42.546 --> 00:20:44.746 A:middle
这是因为这些属性中

00:20:44.746 --> 00:20:46.546 A:middle
有的原本是 CIContext 的

00:20:46.546 --> 00:20:47.456 A:middle
附属属性

00:20:47.456 --> 00:20:48.566 A:middle
所以当你需要

00:20:48.566 --> 00:20:49.676 A:middle
配置多个不同的

00:20:49.676 --> 00:20:51.356 A:middle
目标时就必须

00:20:51.356 --> 00:20:52.946 A:middle
为每个目标单独

00:20:52.946 --> 00:20:53.486 A:middle
创建一个 CIContext

00:20:54.096 --> 00:20:55.346 A:middle
如今这些属性全都

00:20:55.346 --> 00:20:57.716 A:middle
很好地剥离了出来

00:20:57.716 --> 00:20:58.966 A:middle
在大部分时候你都可以

00:20:58.966 --> 00:21:00.876 A:middle
只用一个 CIContext 就能

00:20:58.966 --> 00:21:00.876 A:middle
只用一个 CIContext 就能

00:21:00.876 --> 00:21:02.336 A:middle
渲染出多个不同的目标

00:21:03.836 --> 00:21:06.096 A:middle
这款 API 不光提供了

00:21:06.166 --> 00:21:07.396 A:middle
前面提到的所有

00:21:07.396 --> 00:21:09.206 A:middle
这些功能还可以用它

00:21:09.206 --> 00:21:11.376 A:middle
实现一些

00:21:11.616 --> 00:21:13.296 A:middle
特别出色的

00:21:13.296 --> 00:21:13.686 A:middle
性能增强

00:21:14.946 --> 00:21:16.866 A:middle
比如说我们的 CIContext API

00:21:16.976 --> 00:21:18.816 A:middle
在用来渲染到 IOSurface 或者

00:21:18.816 --> 00:21:19.726 A:middle
CVPixelBuffer 时

00:21:20.426 --> 00:21:22.486 A:middle
以前它们会在 GPU

00:21:22.486 --> 00:21:24.656 A:middle
完成所有的渲染工作后

00:21:24.736 --> 00:21:25.286 A:middle
再返回执行结果

00:21:26.236 --> 00:21:28.866 A:middle
但现在使用新的 API

00:21:28.866 --> 00:21:30.746 A:middle
会在 CPU 将 GPU 的这些工作

00:21:30.746 --> 00:21:32.016 A:middle
指令全部发送完毕后

00:21:32.016 --> 00:21:33.026 A:middle
就立即返回结果

00:21:33.556 --> 00:21:34.886 A:middle
再也不用等到

00:21:34.886 --> 00:21:36.026 A:middle
GPU 结束所有工作后了

00:21:37.166 --> 00:21:38.666 A:middle
所以我们认为这种新增的

00:21:38.666 --> 00:21:40.406 A:middle
灵活性能让大家

00:21:40.466 --> 00:21:42.136 A:middle
更加高效地安排

00:21:42.136 --> 00:21:42.786 A:middle
CPU 和 GPU 的所有工作

00:21:44.116 --> 00:21:45.646 A:middle
现在让我来给

00:21:46.346 --> 00:21:46.906 A:middle
大家看个使用实例

00:21:47.736 --> 00:21:49.266 A:middle
这里是一个简单的

00:21:49.266 --> 00:21:52.236 A:middle
渲染子程序目的是

00:21:52.236 --> 00:21:53.866 A:middle
清理出一个目标面

00:21:53.866 --> 00:21:55.986 A:middle
然后在背景图像上层

00:21:55.986 --> 00:21:57.206 A:middle
渲染出前景图像

00:21:58.326 --> 00:21:59.856 A:middle
我们要做的第一件事

00:21:59.856 --> 00:22:01.936 A:middle
就是初始化一个 ioSurface 给定的

00:21:59.856 --> 00:22:01.936 A:middle
就是初始化一个 ioSurface 给定的

00:22:01.936 --> 00:22:03.816 A:middle
CIRenderDestination 对象

00:22:04.406 --> 00:22:07.076 A:middle
然后我们想要的第一个结果

00:22:07.496 --> 00:22:09.866 A:middle
则是获取一个 CIContext

00:22:09.866 --> 00:22:11.426 A:middle
启动渲染任务

00:22:11.426 --> 00:22:12.086 A:middle
清理目标

00:22:13.606 --> 00:22:15.466 A:middle
但在等候这项任务

00:22:15.466 --> 00:22:16.786 A:middle
实际完成前我们就可以

00:22:16.786 --> 00:22:18.756 A:middle
先启动另一项任务

00:22:18.756 --> 00:22:19.506 A:middle
在目标处渲染

00:22:19.506 --> 00:22:19.966 A:middle
背景图像

00:22:23.176 --> 00:22:24.806 A:middle
然后在我们启动

00:22:24.806 --> 00:22:26.136 A:middle
最后一项任务之前我们可以

00:22:26.136 --> 00:22:27.776 A:middle
为目标对象设定一个混合内核

00:22:27.776 --> 00:22:29.866 A:middle
可以从我们提供的 37 个内置的

00:22:29.866 --> 00:22:32.086 A:middle
混合内核中任选一个

00:22:32.606 --> 00:22:33.786 A:middle
在这个例子里我们选了一个

00:22:33.786 --> 00:22:34.686 A:middle
sourceOver 混合内核

00:22:35.196 --> 00:22:37.176 A:middle
但你还可以使用最新的

00:22:37.176 --> 00:22:39.066 A:middle
CIBlendKernel API 创建

00:22:39.066 --> 00:22:40.616 A:middle
一个自定义的混合内核

00:22:40.616 --> 00:22:44.376 A:middle
那么我们要的混合内核

00:22:44.526 --> 00:22:47.476 A:middle
也有了现在让我们来

00:22:47.476 --> 00:22:49.056 A:middle
调用 CIContext 启动最后的

00:22:49.056 --> 00:22:50.346 A:middle
渲染任务在目标处

00:22:50.346 --> 00:22:52.086 A:middle
已有的任何结果

00:22:52.406 --> 00:22:53.566 A:middle
上层叠加渲染

00:22:53.566 --> 00:22:54.216 A:middle
前景图像

00:22:54.936 --> 00:22:56.276 A:middle
只有这个时候你才需要

00:22:56.276 --> 00:22:58.456 A:middle
调用 waitUntilCompleted

00:22:58.456 --> 00:23:00.446 A:middle
用它来获取 CPU 上的

00:22:58.456 --> 00:23:00.446 A:middle
用它来获取 CPU 上的

00:23:00.446 --> 00:23:01.066 A:middle
内容

00:23:01.706 --> 00:23:03.506 A:middle
所以通过这种新设计

00:23:03.506 --> 00:23:05.266 A:middle
能将获取结果的延迟时间

00:23:05.266 --> 00:23:06.856 A:middle
缩到最短还不用

00:23:06.856 --> 00:23:08.746 A:middle
执行任何不必要的

00:23:08.746 --> 00:23:09.956 A:middle
GPU 同步指令

00:23:13.456 --> 00:23:14.696 A:middle
我要给大家看的

00:23:14.856 --> 00:23:16.716 A:middle
第二个用例会特别

00:23:17.256 --> 00:23:18.656 A:middle
演示一下性能方面的

00:23:18.656 --> 00:23:21.066 A:middle
细微优势但这点优势

00:23:21.066 --> 00:23:22.046 A:middle
却能为你的应用程序

00:23:22.046 --> 00:23:22.586 A:middle
带来巨大影响

00:23:22.636 --> 00:23:23.966 A:middle
那就是渲染到

00:23:23.966 --> 00:23:24.906 A:middle
Metal 可绘制纹理

00:23:25.156 --> 00:23:27.356 A:middle
这做起来很简单只要

00:23:27.356 --> 00:23:29.746 A:middle
获取一个 currentDrawable

00:23:29.746 --> 00:23:30.536 A:middle
就行比如说

00:23:30.616 --> 00:23:30.966 A:middle
从 Metal 视图中获取

00:23:31.226 --> 00:23:32.776 A:middle
接下来便可使用

00:23:32.776 --> 00:23:34.806 A:middle
可绘制视图中的纹理

00:23:35.196 --> 00:23:36.346 A:middle
完成一 个CIRenderDestination 的

00:23:36.346 --> 00:23:36.786 A:middle
初始化

00:23:36.786 --> 00:23:40.556 A:middle
这段程序就能达成我们的目的

00:23:40.626 --> 00:23:41.876 A:middle
但如果你是在每帧渲染循环中

00:23:41.876 --> 00:23:44.476 A:middle
执行这样的任务却有可能

00:23:44.866 --> 00:23:46.066 A:middle
遇到性能上的瓶颈

00:23:46.066 --> 00:23:47.236 A:middle
而表面上可能

00:23:47.236 --> 00:23:48.026 A:middle
并不明显

00:23:48.376 --> 00:23:51.036 A:middle
让我用一个时间轴图示

00:23:51.686 --> 00:23:52.896 A:middle
来更加详细地

00:23:52.896 --> 00:23:54.436 A:middle
描述解释一下

00:23:54.436 --> 00:23:54.706 A:middle
这个情况

00:23:55.646 --> 00:23:56.786 A:middle
还请大家耐心听

00:23:56.786 --> 00:23:58.316 A:middle
因为这里面会涉及到

00:23:58.316 --> 00:23:58.676 A:middle
非常多的步骤

00:23:59.376 --> 00:24:01.606 A:middle
我们在这条时间轴上

00:23:59.376 --> 00:24:01.606 A:middle
我们在这条时间轴上

00:24:01.606 --> 00:24:03.296 A:middle
追踪两个对象上面是

00:24:03.296 --> 00:24:04.736 A:middle
CPU 下面是 GPU

00:24:05.506 --> 00:24:06.466 A:middle
严格来说这个过程里

00:24:06.466 --> 00:24:07.346 A:middle
其实还存在一个第三方

00:24:07.346 --> 00:24:08.406 A:middle
也就是显示

00:24:08.406 --> 00:24:10.436 A:middle
但为了简明起见

00:24:10.686 --> 00:24:11.696 A:middle
姑且把它当作是

00:24:11.696 --> 00:24:12.096 A:middle
GPU 的一部分

00:24:12.756 --> 00:24:14.746 A:middle
那么在第一帧里

00:24:14.746 --> 00:24:16.496 A:middle
你的应用会试图从

00:24:16.496 --> 00:24:17.046 A:middle
视图中获取一个可绘制对象

00:24:17.576 --> 00:24:19.926 A:middle
根据这个对象又可以

00:24:19.926 --> 00:24:22.386 A:middle
获取一种纹理然后启动

00:24:22.386 --> 00:24:24.736 A:middle
渲染该纹理的

00:24:24.906 --> 00:24:25.386 A:middle
任务

00:24:26.796 --> 00:24:28.566 A:middle
在 CI 收到调用命令后

00:24:28.566 --> 00:24:29.656 A:middle
我们就要开始对

00:24:29.656 --> 00:24:32.336 A:middle
完成 GPU 任务所用的

00:24:32.336 --> 00:24:33.576 A:middle
CPU 命令进行编码

00:24:34.286 --> 00:24:35.616 A:middle
单以这个例子来说

00:24:35.616 --> 00:24:37.576 A:middle
我们描画的是一个滤镜图表

00:24:37.576 --> 00:24:38.866 A:middle
实际上由多次滤镜处理

00:24:38.866 --> 00:24:40.126 A:middle
组成分别是两次

00:24:40.126 --> 00:24:41.866 A:middle
中间处理和一次

00:24:41.866 --> 00:24:43.506 A:middle
最终处理

00:24:44.756 --> 00:24:45.796 A:middle
当 Core Image 完成所有任务的

00:24:45.796 --> 00:24:47.236 A:middle
编码工作后对 startTask 的

00:24:47.236 --> 00:24:48.326 A:middle
调用便会返回执行结果

00:24:48.756 --> 00:24:50.876 A:middle
从这个时点开始

00:24:50.876 --> 00:24:52.446 A:middle
GPU 会很高兴地将

00:24:52.446 --> 00:24:53.816 A:middle
待执行任务安排在

00:24:53.816 --> 00:24:55.966 A:middle
适当的时间段内

00:24:56.176 --> 00:24:58.756 A:middle
但是如果 GPU 的任务

00:24:58.756 --> 00:25:01.026 A:middle
需要很长的时间才能完成

00:24:58.756 --> 00:25:01.026 A:middle
需要很长的时间才能完成

00:25:01.026 --> 00:25:02.946 A:middle
你的应用可能会在上述任务

00:25:02.946 --> 00:25:05.666 A:middle
完成前就接到调用去渲染

00:25:05.666 --> 00:25:06.036 A:middle
另一帧

00:25:06.906 --> 00:25:08.136 A:middle
此时如果你试图获取

00:25:08.136 --> 00:25:10.596 A:middle
一个可绘制对象相应的

00:25:10.596 --> 00:25:12.746 A:middle
调用命令将会暂停直到它

00:25:12.746 --> 00:25:14.166 A:middle
可以被提供给你的应用时

00:25:14.166 --> 00:25:14.816 A:middle
才会执行

00:25:15.066 --> 00:25:18.096 A:middle
这个时候你才能

00:25:18.096 --> 00:25:19.756 A:middle
从它那里获取纹理

00:25:19.756 --> 00:25:21.796 A:middle
启动另一项任务去开始渲染

00:25:22.586 --> 00:25:24.176 A:middle
后续的所有帧也会

00:25:24.176 --> 00:25:24.506 A:middle
重复同一过程

00:25:24.506 --> 00:25:27.096 A:middle
所大家所见

00:25:27.096 --> 00:25:28.496 A:middle
这个过程对 CPU 和 GPU 的

00:25:28.496 --> 00:25:29.996 A:middle
利用效率并不高

00:25:29.996 --> 00:25:31.436 A:middle
两个处理器都存在着

00:25:31.436 --> 00:25:32.206 A:middle
大量的闲置时间

00:25:32.776 --> 00:25:35.286 A:middle
但如果你仔细看下这部分

00:25:35.286 --> 00:25:37.676 A:middle
我们要渲染的可绘制纹理

00:25:37.676 --> 00:25:39.456 A:middle
实际上在最后一步的

00:25:39.456 --> 00:25:41.336 A:middle
渲染处理之前

00:25:41.336 --> 00:25:41.956 A:middle
是用不到的

00:25:43.016 --> 00:25:44.276 A:middle
那我们来看看

00:25:44.276 --> 00:25:45.816 A:middle
可以如何改进这个情况

00:25:48.716 --> 00:25:49.646 A:middle
使用我们最新的

00:25:49.646 --> 00:25:52.346 A:middle
CIRenderDestination API

00:25:52.346 --> 00:25:54.416 A:middle
在初始化的时候

00:25:54.416 --> 00:25:56.936 A:middle
不必使用纹理本身

00:25:56.936 --> 00:25:58.306 A:middle
而是纹理的所有属性

00:25:58.536 --> 00:26:00.716 A:middle
比如纹理的宽高

00:25:58.536 --> 00:26:00.716 A:middle
比如纹理的宽高

00:26:00.716 --> 00:26:02.156 A:middle
像素格式

00:26:02.676 --> 00:26:04.666 A:middle
然后可以通过回调

00:26:04.666 --> 00:26:06.626 A:middle
提供该纹理而且会

00:26:06.626 --> 00:26:08.496 A:middle
等到最后的最后

00:26:08.496 --> 00:26:10.196 A:middle
确实要用到该纹理的时候

00:26:10.196 --> 00:26:11.726 A:middle
才会真正调用

00:26:12.356 --> 00:26:15.216 A:middle
于是现在你就能立刻

00:26:15.216 --> 00:26:17.126 A:middle
完成目标对象的初始化

00:26:17.126 --> 00:26:18.506 A:middle
可以提前很多时间来

00:26:18.506 --> 00:26:20.496 A:middle
启动任务和执行渲染

00:26:20.496 --> 00:26:22.006 A:middle
这也会有效地推迟

00:26:22.136 --> 00:26:23.316 A:middle
那个可能造成妨碍的

00:26:23.316 --> 00:26:24.866 A:middle
currentDrawable 调用让它在

00:26:24.866 --> 00:26:25.506 A:middle
更靠后的时点发生

00:26:25.546 --> 00:26:28.306 A:middle
我们仔细看一下

00:26:28.306 --> 00:26:32.096 A:middle
这个例子它能把CPU

00:26:32.096 --> 00:26:33.706 A:middle
和 GPU 的任务安排得

00:26:33.706 --> 00:26:34.346 A:middle
更加高效

00:26:35.476 --> 00:26:36.806 A:middle
所以如果你要渲染 Metal

00:26:36.806 --> 00:26:38.386 A:middle
可绘制纹理我们强烈

00:26:38.386 --> 00:26:39.696 A:middle
建议你使用这款

00:26:39.696 --> 00:26:39.876 A:middle
新出的 API

00:26:39.876 --> 00:26:41.726 A:middle
因为它能极大地

00:26:41.726 --> 00:26:43.056 A:middle
提高你的应用的

00:26:43.056 --> 00:26:43.586 A:middle
帧率

00:26:44.116 --> 00:26:45.336 A:middle
事实上我们看到过

00:26:45.336 --> 00:26:46.616 A:middle
一些案例在运用了

00:26:46.616 --> 00:26:48.426 A:middle
这项技巧后帧率真的

00:26:48.426 --> 00:26:48.996 A:middle
提高了一倍

00:26:48.996 --> 00:26:49.626 A:middle
好的

00:26:51.856 --> 00:26:55.676 A:middle
现在我要把讲台

00:26:55.676 --> 00:26:57.126 A:middle
交回给 David 他会为大家

00:26:57.126 --> 00:26:58.426 A:middle
讲解一些特别精彩的内容

00:26:58.426 --> 00:26:59.866 A:middle
让大家一窥 Core Image 框架的

00:26:59.866 --> 00:27:00.586 A:middle
个中奥妙

00:26:59.866 --> 00:27:00.586 A:middle
个中奥妙

00:27:00.796 --> 00:27:00.976 A:middle
谢谢大家

00:27:06.456 --> 00:27:07.396 A:middle
&gt;&gt; 谢谢 Tony

00:27:07.396 --> 00:27:08.206 A:middle
讲得很棒

00:27:09.376 --> 00:27:10.146 A:middle
就像我在介绍的部分中

00:27:10.146 --> 00:27:11.876 A:middle
提到的 Core Image 运用了

00:27:11.876 --> 00:27:13.286 A:middle
很多漂亮的技巧用来

00:27:13.286 --> 00:27:14.456 A:middle
实现最佳的性能表现

00:27:14.986 --> 00:27:16.286 A:middle
我们今年的一大目标

00:27:16.286 --> 00:27:17.576 A:middle
就是让各位开发者大家

00:27:17.576 --> 00:27:19.376 A:middle
更清晰地了解这些技巧

00:27:19.376 --> 00:27:20.616 A:middle
是如何发挥作用的好让大家

00:27:20.616 --> 00:27:22.686 A:middle
更好地理解应该

00:27:22.686 --> 00:27:23.716 A:middle
如何高效地使用

00:27:23.716 --> 00:27:24.256 A:middle
Core Image

00:27:25.546 --> 00:27:27.076 A:middle
在这方面我们采用了

00:27:27.076 --> 00:27:27.876 A:middle
两种有意思的方式

00:27:28.216 --> 00:27:29.766 A:middle
一种是利用我们新出的 API

00:27:29.866 --> 00:27:30.776 A:middle
我们设计了一些新方法

00:27:30.776 --> 00:27:32.606 A:middle
来返回你的

00:27:32.646 --> 00:27:33.076 A:middle
渲染器信息

00:27:34.216 --> 00:27:36.046 A:middle
在你对渲染器发出

00:27:36.046 --> 00:27:37.976 A:middle
任务指令后现在你可以...

00:27:37.976 --> 00:27:39.026 A:middle
在你等到任务完成后

00:27:39.026 --> 00:27:40.266 A:middle
该任务便会返回一个

00:27:40.266 --> 00:27:42.476 A:middle
CIRenderInfo 对象

00:27:42.856 --> 00:27:44.346 A:middle
这个对象又会为你

00:27:44.346 --> 00:27:45.276 A:middle
返回一个附带少量

00:27:45.276 --> 00:27:46.866 A:middle
属性的对象包括

00:27:46.866 --> 00:27:48.396 A:middle
Core Image 执行这个

00:27:48.616 --> 00:27:50.056 A:middle
渲染命令所需用到的

00:27:50.186 --> 00:27:50.576 A:middle
处理次数

00:27:50.916 --> 00:27:52.236 A:middle
以及在设备上

00:27:52.236 --> 00:27:54.016 A:middle
执行内核所耗费的

00:27:54.016 --> 00:27:55.706 A:middle
总时间还有处理到的

00:27:55.706 --> 00:27:57.086 A:middle
像素总数

00:27:57.426 --> 00:27:58.936 A:middle
所以你可以从

00:27:58.936 --> 00:28:00.076 A:middle
我们返回的信息中

00:27:58.936 --> 00:28:00.076 A:middle
我们返回的信息中

00:28:00.246 --> 00:28:01.536 A:middle
获得十分丰富的信息

00:28:02.766 --> 00:28:04.766 A:middle
但也许更厉害的

00:28:05.066 --> 00:28:06.716 A:middle
还是一些好用的新版本

00:28:06.716 --> 00:28:07.986 A:middle
我们现在可以让

00:28:07.986 --> 00:28:09.446 A:middle
Core Image 在 Xcode 中

00:28:09.506 --> 00:28:09.896 A:middle
提供更出色的 Quick Looks

00:28:11.856 --> 00:28:14.636 A:middle
特别是我们现在为 CIImage

00:28:14.766 --> 00:28:16.566 A:middle
提供了很棒的 Quick Look 支持

00:28:16.836 --> 00:28:17.946 A:middle
除了显示像素外

00:28:17.986 --> 00:28:19.216 A:middle
我们现在还能显示你在

00:28:19.246 --> 00:28:20.606 A:middle
生成图像的过程中

00:28:20.606 --> 00:28:21.536 A:middle
构建的图像图表

00:28:22.686 --> 00:28:23.766 A:middle
如果你对一个 CIRenderTask

00:28:23.766 --> 00:28:26.416 A:middle
执行 Quick Look 结果会显示出

00:28:26.416 --> 00:28:28.036 A:middle
Core Image 对你的图像图表

00:28:28.196 --> 00:28:29.626 A:middle
进行优化处理后的图表

00:28:30.516 --> 00:28:31.886 A:middle
此外如果你正在等候

00:28:31.886 --> 00:28:33.486 A:middle
渲染器信息的返回结果

00:28:33.486 --> 00:28:34.496 A:middle
此时对该进程执行 Quick Look 的话

00:28:34.776 --> 00:28:35.936 A:middle
结果将会显示

00:28:35.936 --> 00:28:37.536 A:middle
Core Image 内部发生的

00:28:37.536 --> 00:28:38.766 A:middle
所有并置时间点以及

00:28:38.766 --> 00:28:39.686 A:middle
缓存信息

00:28:40.056 --> 00:28:41.616 A:middle
为了帮助大家理解

00:28:41.616 --> 00:28:42.426 A:middle
让我们来用一种非常

00:28:42.426 --> 00:28:43.036 A:middle
直观的方式为大家说明

00:28:43.466 --> 00:28:44.206 A:middle
这里有一段代码

00:28:44.266 --> 00:28:45.476 A:middle
假装我们正在 Xcode 的

00:28:45.476 --> 00:28:46.366 A:middle
环境中逐步调试这段代码

00:28:47.116 --> 00:28:49.456 A:middle
这是一个例子

00:28:49.456 --> 00:28:50.116 A:middle
内容是我们准备构建的

00:28:50.116 --> 00:28:50.706 A:middle
图像图表

00:28:51.026 --> 00:28:52.106 A:middle
在这个例子里我们

00:28:52.106 --> 00:28:54.456 A:middle
在创建一个 CIImage

00:28:54.456 --> 00:28:55.236 A:middle
所用参数一个是 url

00:28:55.236 --> 00:28:57.346 A:middle
一个是我们为

00:28:57.346 --> 00:28:57.516 A:middle
该图像指定的新选项

00:28:57.696 --> 00:29:01.286 A:middle
kCIApplyImageOrientationProperty

00:28:57.696 --> 00:29:01.286 A:middle
kCIApplyImageOrientationProperty

00:29:02.256 --> 00:29:03.686 A:middle
且赋值为真

00:29:03.896 --> 00:29:05.266 A:middle
这段的作用是

00:29:05.266 --> 00:29:06.596 A:middle
让图像在你面前

00:29:06.596 --> 00:29:08.656 A:middle
自动直立起来这能

00:29:08.656 --> 00:29:09.176 A:middle
带来很多便利

00:29:10.066 --> 00:29:11.056 A:middle
接下来我们会看到的

00:29:11.056 --> 00:29:12.216 A:middle
是要为这个图像

00:29:12.216 --> 00:29:13.226 A:middle
另外增加一个

00:29:13.226 --> 00:29:14.616 A:middle
仿射变换将图像

00:29:14.616 --> 00:29:16.896 A:middle
缩小为五分之一

00:29:16.896 --> 00:29:18.606 A:middle
假设我们现在是在 Xcode 环境下

00:29:18.606 --> 00:29:20.186 A:middle
将我们的鼠标悬停在图像对象上

00:29:20.576 --> 00:29:22.346 A:middle
此时如果你点击这个

00:29:22.346 --> 00:29:24.516 A:middle
小小的眼睛图标它会显示出

00:29:24.516 --> 00:29:25.336 A:middle
一幅这样的图像

00:29:25.746 --> 00:29:27.046 A:middle
这幅图像不仅让你看到了

00:29:27.046 --> 00:29:28.116 A:middle
生成图像的观看效果

00:29:28.116 --> 00:29:29.486 A:middle
图像清晰直立端正

00:29:29.486 --> 00:29:31.426 A:middle
还能让你在它下方看到

00:29:31.426 --> 00:29:32.806 A:middle
这幅图像生成过程的图表

00:29:33.246 --> 00:29:35.346 A:middle
如果把镜头拉近我们可以

00:29:35.346 --> 00:29:36.086 A:middle
看到各种有意思的

00:29:36.086 --> 00:29:36.716 A:middle
信息

00:29:37.266 --> 00:29:39.426 A:middle
可以看到在图像图表的

00:29:39.426 --> 00:29:41.036 A:middle
输入端是我们的

00:29:41.036 --> 00:29:41.846 A:middle
IOSurface

00:29:41.976 --> 00:29:43.536 A:middle
仔细看一下会得知

00:29:43.536 --> 00:29:44.726 A:middle
它是一幅 YCC 图像

00:29:44.726 --> 00:29:45.706 A:middle
这说明它大概出自一个

00:29:45.706 --> 00:29:47.666 A:middle
JPEG 文件还可以看到

00:29:48.606 --> 00:29:51.366 A:middle
这个面的尺寸而且

00:29:51.366 --> 00:29:51.876 A:middle
是不透明的

00:29:52.476 --> 00:29:54.986 A:middle
然后可以在图表接下来

00:29:54.986 --> 00:29:56.586 A:middle
往上的第二步中看到

00:29:56.586 --> 00:29:57.846 A:middle
色彩匹配的操作

00:29:57.846 --> 00:29:59.066 A:middle
这让我们能够

00:29:59.066 --> 00:29:59.996 A:middle
自动确定输入图像的

00:30:00.226 --> 00:30:01.416 A:middle
使用的是哪种

00:30:01.416 --> 00:30:01.756 A:middle
色彩空间

00:30:02.026 --> 00:30:03.316 A:middle
然后我们将它插入

00:30:03.316 --> 00:30:05.266 A:middle
渲染图表及操作

00:30:05.466 --> 00:30:06.816 A:middle
从 P3 色彩空间显示

00:30:06.816 --> 00:30:08.256 A:middle
转换到 Core Image 的

00:30:08.256 --> 00:30:08.956 A:middle
工作空间

00:30:10.986 --> 00:30:12.896 A:middle
最后可以看到

00:30:12.896 --> 00:30:13.946 A:middle
三个仿射矩阵

00:30:14.076 --> 00:30:15.366 A:middle
从下往上数的

00:30:15.366 --> 00:30:16.886 A:middle
第一个矩阵是用来将

00:30:16.886 --> 00:30:17.856 A:middle
图像的坐标系

00:30:17.856 --> 00:30:18.976 A:middle
转换为 Core Image

00:30:18.976 --> 00:30:20.256 A:middle
所使用的

00:30:20.256 --> 00:30:21.086 A:middle
笛卡尔坐标系

00:30:21.946 --> 00:30:23.416 A:middle
接着是一个仿射

00:30:23.416 --> 00:30:24.826 A:middle
将图像放正

00:30:24.826 --> 00:30:27.116 A:middle
再接着是将图像

00:30:27.116 --> 00:30:27.706 A:middle
缩小为五分之一

00:30:28.466 --> 00:30:29.656 A:middle
所以如今能让大家

00:30:29.656 --> 00:30:30.706 A:middle
仔细审视图像了解

00:30:30.746 --> 00:30:33.486 A:middle
它接受过的所有操作了

00:30:33.766 --> 00:30:35.276 A:middle
现在我们再来做点

00:30:35.276 --> 00:30:35.986 A:middle
不太一样的事情

00:30:35.986 --> 00:30:37.716 A:middle
现在我们要请求获得

00:30:37.716 --> 00:30:38.686 A:middle
一幅图像不过这次是

00:30:38.686 --> 00:30:40.766 A:middle
一幅视差补偿

00:30:40.766 --> 00:30:41.126 A:middle
图像

00:30:41.266 --> 00:30:42.466 A:middle
这也是我们这次推出的

00:30:42.466 --> 00:30:44.396 A:middle
一个新选项如果你的

00:30:44.396 --> 00:30:46.176 A:middle
图像包含深度信息

00:30:46.176 --> 00:30:49.156 A:middle
它便会以单色图像的方式

00:30:49.156 --> 00:30:50.176 A:middle
返回该信息

00:30:51.816 --> 00:30:53.276 A:middle
在我们请求完毕后

00:30:53.666 --> 00:30:55.086 A:middle
我们要对它应用

00:30:55.086 --> 00:30:55.196 A:middle
一个滤镜

00:30:55.306 --> 00:30:56.266 A:middle
在这个例子里我们

00:30:56.266 --> 00:30:58.176 A:middle
要对它应用双三次缩放变换

00:30:58.456 --> 00:30:59.526 A:middle
来调整它的大小

00:31:01.206 --> 00:31:03.206 A:middle
在 Xcode 环境下调试时

00:31:03.206 --> 00:31:04.246 A:middle
如果我们把鼠标悬停在

00:31:04.246 --> 00:31:06.226 A:middle
这个对象上就能

00:31:06.736 --> 00:31:07.816 A:middle
得到这样一幅图像

00:31:08.246 --> 00:31:09.266 A:middle
大家可以明确地看到

00:31:09.266 --> 00:31:11.726 A:middle
这张视差图像的前景

00:31:11.726 --> 00:31:13.756 A:middle
是白的在背景方向上

00:31:14.146 --> 00:31:15.146 A:middle
越深颜色就越暗

00:31:15.456 --> 00:31:17.716 A:middle
但我们还能看到

00:31:17.716 --> 00:31:19.066 A:middle
这幅图像生成过程的图表

00:31:19.796 --> 00:31:21.596 A:middle
像这里可以看到

00:31:21.596 --> 00:31:23.926 A:middle
输入图像是一个 IOSurface

00:31:23.926 --> 00:31:25.576 A:middle
格式是亮度半浮点精度

00:31:25.576 --> 00:31:27.976 A:middle
还可以看到

00:31:27.976 --> 00:31:29.016 A:middle
图像的尺寸

00:31:29.016 --> 00:31:30.456 A:middle
要小于原始图像

00:31:31.916 --> 00:31:33.306 A:middle
在这张图表的最上方

00:31:33.306 --> 00:31:36.456 A:middle
还能看到我们刚才应用

00:31:36.456 --> 00:31:37.386 A:middle
的 cubicUpsample 滤镜

00:31:38.816 --> 00:31:40.016 A:middle
对于图表的显示用色

00:31:40.016 --> 00:31:41.286 A:middle
其实也是有规则可循的

00:31:41.556 --> 00:31:42.726 A:middle
首先你会注意到

00:31:42.726 --> 00:31:44.296 A:middle
该图表所有的输入框

00:31:44.336 --> 00:31:44.666 A:middle
都是紫色

00:31:45.256 --> 00:31:46.556 A:middle
任何会影响到图像

00:31:46.556 --> 00:31:48.646 A:middle
色彩的或者说 CIColorKernel

00:31:49.036 --> 00:31:49.536 A:middle
都是红色

00:31:49.626 --> 00:31:50.876 A:middle
任何会影响到图像

00:31:50.876 --> 00:31:52.176 A:middle
几何属性的或者说

00:31:52.176 --> 00:31:53.676 A:middle
CIWarpKernel 都是绿色

00:31:54.076 --> 00:31:55.646 A:middle
其余的内核

00:31:55.646 --> 00:31:56.976 A:middle
全都是蓝色

00:32:00.846 --> 00:32:02.586 A:middle
让我们再来做点

00:32:02.586 --> 00:32:03.026 A:middle
更好玩的事情

00:32:03.026 --> 00:32:04.786 A:middle
我们打算取用一幅

00:32:04.786 --> 00:32:05.796 A:middle
原始图像为它应用

00:32:05.796 --> 00:32:07.906 A:middle
两种不同的色彩立方体

00:32:08.256 --> 00:32:09.716 A:middle
然后分别取用得到的

00:32:09.716 --> 00:32:10.966 A:middle
两幅图像再用一个

00:32:10.966 --> 00:32:12.216 A:middle
CIBlendWithMask 滤镜

00:32:12.276 --> 00:32:13.766 A:middle
把它们合并成一幅图像

00:32:14.416 --> 00:32:16.476 A:middle
如果在 Quick Looks 里

00:32:16.476 --> 00:32:18.356 A:middle
查看这一串操作的结果

00:32:18.356 --> 00:32:19.796 A:middle
便能看到最后生成的图像

00:32:19.956 --> 00:32:21.206 A:middle
分别基于前景和背景

00:32:21.206 --> 00:32:22.276 A:middle
经过两种不同效果的

00:32:22.316 --> 00:32:23.246 A:middle
滤镜处理

00:32:23.536 --> 00:32:25.986 A:middle
同时我们还能看到

00:32:25.986 --> 00:32:27.516 A:middle
整个生成过程对应图表

00:32:27.516 --> 00:32:28.476 A:middle
的详细信息

00:32:29.286 --> 00:32:30.726 A:middle
大家可以看到

00:32:30.776 --> 00:32:32.286 A:middle
在最左侧我们取用

00:32:32.286 --> 00:32:33.656 A:middle
输入图像对应的

00:32:33.656 --> 00:32:36.346 A:middle
子图部分拿到了色彩立方体的

00:32:36.346 --> 00:32:40.056 A:middle
数据一个 32x1024 的图像

00:32:40.486 --> 00:32:41.906 A:middle
然后把这个色彩立方体

00:32:41.906 --> 00:32:42.186 A:middle
应用到了图像上

00:32:42.806 --> 00:32:44.986 A:middle
图表的中间部分

00:32:44.986 --> 00:32:45.786 A:middle
我们是在对背景

00:32:45.786 --> 00:32:46.666 A:middle
做一遍相同的事情

00:32:47.416 --> 00:32:49.076 A:middle
所有这些再加上遮罩图像

00:32:49.076 --> 00:32:50.556 A:middle
全部用 blendWithMask 内核

00:32:50.556 --> 00:32:51.586 A:middle
进行合并

00:32:52.186 --> 00:32:55.206 A:middle
希望这些讲解让大家

00:32:55.206 --> 00:32:57.196 A:middle
对于应用程序创建 CIImage 的

00:32:57.196 --> 00:32:58.806 A:middle
过程有了很好的理解

00:32:59.076 --> 00:33:00.406 A:middle
不过到了渲染这个环节

00:32:59.076 --> 00:33:00.406 A:middle
不过到了渲染这个环节

00:33:00.406 --> 00:33:00.946 A:middle
又会发生些什么呢？

00:33:00.946 --> 00:33:01.766 A:middle
这就是事情变得

00:33:01.766 --> 00:33:02.496 A:middle
有意思的地方了

00:33:03.296 --> 00:33:04.926 A:middle
在你告诉一个 CIContext

00:33:04.926 --> 00:33:06.566 A:middle
启动一项任务后这个过程

00:33:06.566 --> 00:33:07.916 A:middle
会返回一个 CIRenderedTask 对象

00:33:08.186 --> 00:33:10.066 A:middle
这里同样支持 Quick Looks

00:33:10.606 --> 00:33:12.156 A:middle
让我们来看一下

00:33:12.156 --> 00:33:13.286 A:middle
显然这个图表的内容

00:33:13.286 --> 00:33:13.676 A:middle
更加详尽

00:33:14.156 --> 00:33:16.996 A:middle
同样这里的配色规则

00:33:16.996 --> 00:33:18.596 A:middle
是一样的我们也能看到

00:33:18.596 --> 00:33:21.726 A:middle
一些前面出现过的操作

00:33:21.726 --> 00:33:23.126 A:middle
但是我们之前看到的

00:33:23.126 --> 00:33:24.466 A:middle
色彩匹配操作

00:33:24.466 --> 00:33:25.426 A:middle
被转换成了

00:33:25.426 --> 00:33:26.596 A:middle
执行色彩管理

00:33:26.596 --> 00:33:27.046 A:middle
所需要的基元

00:33:27.276 --> 00:33:28.416 A:middle
我们可以看到我们需要

00:33:28.416 --> 00:33:30.506 A:middle
应用这个 gamma 函数

00:33:30.506 --> 00:33:31.856 A:middle
和这个色彩矩阵以便

00:33:31.856 --> 00:33:33.566 A:middle
从 P3 转换到我们的工作空间

00:33:34.726 --> 00:33:35.936 A:middle
大家还能看到

00:33:35.936 --> 00:33:37.226 A:middle
虽然原始图像经过

00:33:37.226 --> 00:33:39.136 A:middle
三次仿射变换

00:33:39.136 --> 00:33:41.086 A:middle
但 Core Image 已将三次

00:33:41.086 --> 00:33:41.516 A:middle
全部并置成了一次

00:33:42.046 --> 00:33:45.636 A:middle
还有一点大家会注意到的

00:33:45.696 --> 00:33:47.376 A:middle
就是在图表要结束时

00:33:47.376 --> 00:33:48.456 A:middle
我们已经知道目标的

00:33:48.456 --> 00:33:49.286 A:middle
色彩空间是什么了

00:33:49.396 --> 00:33:50.986 A:middle
这些操作已经全部

00:33:50.986 --> 00:33:52.236 A:middle
应用在图像上

00:33:53.416 --> 00:33:57.236 A:middle
全都经过了色彩空间

00:33:57.236 --> 00:33:58.366 A:middle
和坐标系的转换

00:33:58.366 --> 00:33:59.396 A:middle
用以得出最后的

00:33:59.396 --> 00:33:59.976 A:middle
目标

00:33:59.976 --> 00:34:01.996 A:middle
大家还可以看到

00:33:59.976 --> 00:34:01.996 A:middle
大家还可以看到

00:34:01.996 --> 00:34:03.056 A:middle
所有这些对象或者说

00:34:03.056 --> 00:34:04.326 A:middle
渲染图表每一个环节所涉及到的

00:34:04.326 --> 00:34:05.506 A:middle
所有图像的所有尺寸

00:34:05.506 --> 00:34:09.206 A:middle
这里也全都有用到

00:34:09.275 --> 00:34:10.606 A:middle
现在等到你给定的

00:34:10.606 --> 00:34:12.456 A:middle
任务完成后这里又

00:34:12.456 --> 00:34:13.156 A:middle
出现了一个新对象

00:34:13.156 --> 00:34:14.746 A:middle
这个新对象会涉及到

00:34:15.835 --> 00:34:17.596 A:middle
Core Image 是如何

00:34:17.596 --> 00:34:18.906 A:middle
实现并置

00:34:18.906 --> 00:34:20.235 A:middle
以及渲染器性能的

00:34:20.235 --> 00:34:21.735 A:middle
详细信息

00:34:22.386 --> 00:34:23.286 A:middle
大家也看到了这里的

00:34:23.286 --> 00:34:25.025 A:middle
树形图上出现的对象比较少

00:34:25.025 --> 00:34:26.186 A:middle
就是因为执行了并置

00:34:26.525 --> 00:34:27.525 A:middle
如果我们来看一下靠近

00:34:27.525 --> 00:34:29.636 A:middle
下方的地方会发现这有一个

00:34:29.696 --> 00:34:31.676 A:middle
专门的 program 它就是

00:34:31.676 --> 00:34:33.565 A:middle
将几个步骤并置到

00:34:33.565 --> 00:34:36.815 A:middle
一段程序后得到的结果

00:34:36.815 --> 00:34:38.326 A:middle
我们还能看到它用到的

00:34:38.556 --> 00:34:39.496 A:middle
参数还有这段程序执行起来

00:34:39.496 --> 00:34:41.126 A:middle
所耗费的时间

00:34:41.126 --> 00:34:41.815 A:middle
单位是毫秒

00:34:42.556 --> 00:34:43.835 A:middle
Core Image 有个很好的功能是

00:34:43.835 --> 00:34:44.795 A:middle
如果你接着又将

00:34:44.795 --> 00:34:47.085 A:middle
这幅图像渲染了一遍

00:34:47.085 --> 00:34:48.545 A:middle
渲染的图像部位也完全相同

00:34:48.545 --> 00:34:50.516 A:middle
那么 Core Image 能从

00:34:50.516 --> 00:34:51.656 A:middle
缓存里调取上次的

00:34:51.656 --> 00:34:52.146 A:middle
处理结果

00:34:52.676 --> 00:34:54.016 A:middle
发生这种情况的时候你会发现

00:34:54.016 --> 00:34:55.266 A:middle
这里的所用时间

00:34:55.266 --> 00:34:55.735 A:middle
都变成了 0

00:34:56.216 --> 00:34:57.816 A:middle
这也从另一个侧面

00:34:57.816 --> 00:34:59.566 A:middle
让大家了解到

00:34:59.566 --> 00:35:00.906 A:middle
在给定的内存限制下

00:34:59.566 --> 00:35:00.906 A:middle
在给定的内存限制下

00:35:00.906 --> 00:35:02.776 A:middle
Core Image 是如何高效地

00:35:02.776 --> 00:35:05.416 A:middle
渲染和缓存结果的

00:35:05.986 --> 00:35:09.136 A:middle
希望这能帮助大家

00:35:09.136 --> 00:35:10.886 A:middle
更具体也更清晰地了解

00:35:10.886 --> 00:35:12.226 A:middle
Core Image 的内部机制

00:35:13.896 --> 00:35:14.846 A:middle
我今天要讲的

00:35:14.846 --> 00:35:17.006 A:middle
下一个主题

00:35:17.536 --> 00:35:18.926 A:middle
是条形码确切说

00:35:18.926 --> 00:35:20.446 A:middle
就是 CIBarcodeDescriptor 这个 API

00:35:21.696 --> 00:35:23.376 A:middle
我们的平台现在为条形码

00:35:23.416 --> 00:35:24.886 A:middle
提供很出色的广泛支持

00:35:25.336 --> 00:35:26.796 A:middle
不同类型的条形码

00:35:26.796 --> 00:35:29.006 A:middle
无论是 Aztec Code128

00:35:29.006 --> 00:35:31.036 A:middle
还是二维码  PDF417

00:35:32.466 --> 00:35:33.816 A:middle
我们还在多种不同的

00:35:33.816 --> 00:35:35.726 A:middle
框架内支持条形码

00:35:35.726 --> 00:35:37.406 A:middle
这些框架都对条形码

00:35:37.406 --> 00:35:38.596 A:middle
有着不同方式的

00:35:38.596 --> 00:35:39.976 A:middle
合理运用

00:35:40.596 --> 00:35:43.316 A:middle
比如说

00:35:43.316 --> 00:35:46.046 A:middle
AVFoundation 就是一种

00:35:46.046 --> 00:35:47.496 A:middle
在用摄影机拍摄

00:35:47.576 --> 00:35:49.046 A:middle
视频时帮你检测

00:35:49.296 --> 00:35:50.406 A:middle
条形码的框架

00:35:51.506 --> 00:35:53.636 A:middle
如果你想要从

00:35:53.896 --> 00:35:55.656 A:middle
静态图像或者

00:35:55.656 --> 00:35:57.756 A:middle
已摄视频中检测

00:35:57.756 --> 00:35:58.936 A:middle
条形码这个框架

00:35:59.036 --> 00:36:00.066 A:middle
会很好用

00:35:59.036 --> 00:36:00.066 A:middle
会很好用

00:36:00.256 --> 00:36:01.516 A:middle
最后大家可以使用

00:36:01.516 --> 00:36:04.176 A:middle
Core Image 将二维码

00:36:04.176 --> 00:36:05.256 A:middle
渲染成真正的图像文件

00:36:06.596 --> 00:36:08.116 A:middle
考虑到不同框架对二维码的

00:36:08.116 --> 00:36:09.816 A:middle
广泛支持我们便想加入

00:36:09.816 --> 00:36:11.216 A:middle
一种新的数据类型

00:36:11.826 --> 00:36:14.016 A:middle
能让条形码信息

00:36:14.016 --> 00:36:15.206 A:middle
在不同框架之间

00:36:15.246 --> 00:36:17.206 A:middle
无损传递

00:36:19.106 --> 00:36:21.136 A:middle
于是我们就有了新推出的

00:36:21.136 --> 00:36:23.786 A:middle
CIBarcodeDescription API

00:36:25.036 --> 00:36:27.546 A:middle
这个对象只有一个

00:36:27.546 --> 00:36:28.926 A:middle
重要属性就是

00:36:28.926 --> 00:36:30.096 A:middle
errorCorrectedPayload

00:36:30.856 --> 00:36:32.756 A:middle
它所包含的并不只是

00:36:32.756 --> 00:36:34.786 A:middle
一个条形码的文字信息

00:36:34.786 --> 00:36:36.036 A:middle
而是它的原始数据

00:36:36.346 --> 00:36:38.366 A:middle
因而能让你通过

00:36:38.366 --> 00:36:39.896 A:middle
单纯的文字信息以外的

00:36:40.096 --> 00:36:41.716 A:middle
方式使用条形码

00:36:41.716 --> 00:36:42.676 A:middle
从中获取信息

00:36:43.016 --> 00:36:45.046 A:middle
利用包含原始数据的

00:36:45.796 --> 00:36:47.246 A:middle
errorCorrectedPayload

00:36:47.246 --> 00:36:48.876 A:middle
加上对每种条形码

00:36:49.046 --> 00:36:50.416 A:middle
格式的了解可以让你

00:36:50.896 --> 00:36:53.036 A:middle
基于二维码做出

00:36:53.036 --> 00:36:53.806 A:middle
很有意思的功能打造出

00:36:53.806 --> 00:36:55.306 A:middle
有意思的垂直应用

00:36:56.296 --> 00:36:58.056 A:middle
此外每种条形码

00:36:58.056 --> 00:36:59.426 A:middle
也有一些自己独有的

00:36:59.426 --> 00:36:59.936 A:middle
属性

00:37:00.426 --> 00:37:01.746 A:middle
就拿 Aztec 条形码

00:37:01.746 --> 00:37:04.266 A:middle
来说你可以获知

00:37:04.536 --> 00:37:06.446 A:middle
一个条形码包含了

00:37:06.446 --> 00:37:06.896 A:middle
多少个层

00:37:07.296 --> 00:37:08.966 A:middle
再比如说二维码

00:37:09.216 --> 00:37:10.766 A:middle
就用到了所谓的

00:37:10.766 --> 00:37:11.756 A:middle
掩码图案

00:37:12.876 --> 00:37:14.926 A:middle
那么我来给大家举个例子

00:37:14.926 --> 00:37:16.606 A:middle
看看这个新的数据类型可以

00:37:16.646 --> 00:37:17.776 A:middle
如何在这三大框架下使用

00:37:18.236 --> 00:37:20.506 A:middle
首先要说的是

00:37:20.566 --> 00:37:23.426 A:middle
AVFoundation

00:37:23.666 --> 00:37:24.466 A:middle
你可以注册一个

00:37:24.466 --> 00:37:26.606 A:middle
metadataOutputObjectDelegate

00:37:26.916 --> 00:37:29.126 A:middle
它能看到输入视频中

00:37:29.126 --> 00:37:31.846 A:middle
出现的条形码

00:37:33.066 --> 00:37:35.446 A:middle
而你在代码中要做的

00:37:35.446 --> 00:37:36.446 A:middle
就是设置这个对象

00:37:36.746 --> 00:37:38.696 A:middle
在该对象检测到条形码时

00:37:38.696 --> 00:37:41.246 A:middle
你可以在响应部分

00:37:41.426 --> 00:37:44.106 A:middle
将该对象以

00:37:44.106 --> 00:37:45.816 A:middle
AVMetadataMachineReadableCodeObject的

00:37:45.816 --> 00:37:47.276 A:middle
名义调用

00:37:47.906 --> 00:37:49.366 A:middle
通过这个对象你可以

00:37:49.456 --> 00:37:51.006 A:middle
获得 descriptor 属性

00:37:51.006 --> 00:37:52.116 A:middle
这会返回其中的一个

00:37:52.116 --> 00:37:53.976 A:middle
CIBarcodeDescriptor 对象

00:37:57.156 --> 00:37:58.606 A:middle
其次如果你想使用

00:37:58.606 --> 00:37:59.776 A:middle
Vision 框架来检测

00:37:59.846 --> 00:38:00.996 A:middle
条形码所用的代码

00:37:59.846 --> 00:38:00.996 A:middle
条形码所用的代码

00:38:00.996 --> 00:38:01.766 A:middle
也十分简单

00:38:02.256 --> 00:38:03.346 A:middle
基本上我们会使用

00:38:03.346 --> 00:38:05.216 A:middle
Vision 创建请求处理器

00:38:05.216 --> 00:38:06.956 A:middle
也会直接把它用作为请求

00:38:07.626 --> 00:38:09.216 A:middle
接着我们要将这个请求

00:38:09.216 --> 00:38:10.836 A:middle
发送给处理器让它

00:38:10.886 --> 00:38:11.436 A:middle
去检测条形码

00:38:11.996 --> 00:38:13.936 A:middle
当我们收到返回的

00:38:13.936 --> 00:38:15.776 A:middle
请求结果后便可以

00:38:15.776 --> 00:38:17.456 A:middle
从结果中获取

00:38:17.456 --> 00:38:18.216 A:middle
barcodeDescriptor 对象

00:38:19.006 --> 00:38:19.556 A:middle
非常简单

00:38:20.666 --> 00:38:23.086 A:middle
最后也是最简单的就是

00:38:23.086 --> 00:38:24.526 A:middle
用 Core Image 根据 descriptor

00:38:24.526 --> 00:38:26.336 A:middle
生成条形码图像

00:38:26.976 --> 00:38:28.056 A:middle
这种情况实现起来

00:38:28.056 --> 00:38:28.426 A:middle
特别简单

00:38:28.426 --> 00:38:29.556 A:middle
我们只要创建一个

00:38:29.556 --> 00:38:31.416 A:middle
BarcodeGenerator 类型的

00:38:31.476 --> 00:38:32.386 A:middle
CIFilter 实例

00:38:33.166 --> 00:38:34.966 A:middle
然后为这个滤镜提供

00:38:34.966 --> 00:38:36.726 A:middle
descriptor 对象的输入

00:38:36.786 --> 00:38:38.466 A:middle
供 inputBarcodeDescriptor 使用

00:38:39.136 --> 00:38:40.146 A:middle
然后要求返回

00:38:40.146 --> 00:38:40.816 A:middle
输出图像

00:38:42.176 --> 00:38:43.946 A:middle
这些技巧结合在一起

00:38:43.946 --> 00:38:45.716 A:middle
就可以让我们利用

00:38:46.096 --> 00:38:47.636 A:middle
条形码的检测与生成

00:38:47.636 --> 00:38:48.226 A:middle
做出有意思的东西

00:38:48.626 --> 00:38:50.626 A:middle
这里有一段我们事先录制的

00:38:50.626 --> 00:38:52.056 A:middle
演示视频给大家看一个

00:38:52.056 --> 00:38:53.056 A:middle
我们编写的示例应用

00:38:53.816 --> 00:38:55.856 A:middle
它的功能就是检查

00:38:56.096 --> 00:38:57.626 A:middle
视频的每一帧从中

00:38:57.626 --> 00:38:59.306 A:middle
拉取条形码然后渲染出来

00:38:59.536 --> 00:39:01.076 A:middle
再覆盖在视频中的

00:38:59.536 --> 00:39:01.076 A:middle
再覆盖在视频中的

00:39:01.246 --> 00:39:03.976 A:middle
条形码上有点类似

00:39:03.976 --> 00:39:05.336 A:middle
某种增强图像

00:39:05.836 --> 00:39:06.696 A:middle
大家可以看到我们能够

00:39:06.696 --> 00:39:08.606 A:middle
完美地复制出

00:39:08.606 --> 00:39:10.116 A:middle
检测到的条形码并在它上方

00:39:10.116 --> 00:39:10.726 A:middle
重新渲染出来

00:39:11.206 --> 00:39:12.496 A:middle
如果我们再来快速地

00:39:12.496 --> 00:39:13.986 A:middle
看一遍还可以发现

00:39:13.986 --> 00:39:15.156 A:middle
这确实是渲染出来的

00:39:15.156 --> 00:39:17.526 A:middle
因为它直接覆盖在了

00:39:17.526 --> 00:39:18.016 A:middle
我的大拇指上

00:39:19.456 --> 00:39:19.746 A:middle
所以

00:39:26.356 --> 00:39:26.726 A:middle
好的

00:39:26.726 --> 00:39:28.596 A:middle
那么在今天这场讲座的

00:39:28.596 --> 00:39:30.416 A:middle
最后一个部分里我很开心地

00:39:30.416 --> 00:39:32.036 A:middle
要跟大家讲讲如何将

00:39:32.036 --> 00:39:33.466 A:middle
Core Image 和 Vision 结合使用

00:39:33.976 --> 00:39:35.416 A:middle
两者都是非常优秀的框架

00:39:35.596 --> 00:39:36.926 A:middle
Core Image 能让你

00:39:36.926 --> 00:39:38.196 A:middle
很轻松地使用框架

00:39:38.256 --> 00:39:39.366 A:middle
对图像应用图像处理

00:39:39.686 --> 00:39:41.296 A:middle
Vision 则能让你

00:39:41.486 --> 00:39:42.736 A:middle
非常方便地找到

00:39:42.736 --> 00:39:43.166 A:middle
图像的信息。

00:39:43.166 --> 00:39:44.926 A:middle
而这两者也可以通过

00:39:44.926 --> 00:39:46.616 A:middle
便利且创新的方式结合使用

00:39:48.346 --> 00:39:50.636 A:middle
比如说你可以将

00:39:50.636 --> 00:39:52.136 A:middle
Core Image 用作为

00:39:52.136 --> 00:39:53.866 A:middle
将图像提交给 Vision 之前的

00:39:53.866 --> 00:39:54.256 A:middle
预处理手段

00:39:54.746 --> 00:39:56.096 A:middle
再比如你或许

00:39:56.096 --> 00:39:57.626 A:middle
想把图像按你的喜好

00:39:57.626 --> 00:39:58.146 A:middle
进行裁切

00:39:58.146 --> 00:39:59.936 A:middle
或者将图像的角度

00:39:59.936 --> 00:40:00.466 A:middle
放端正

00:39:59.936 --> 00:40:00.466 A:middle
放端正

00:40:00.746 --> 00:40:02.326 A:middle
或者在提交给 Vision 前

00:40:02.356 --> 00:40:03.166 A:middle
转换为灰度图像

00:40:04.976 --> 00:40:06.396 A:middle
同样在你调用 Vision 后

00:40:06.666 --> 00:40:07.936 A:middle
在你获得图像信息后

00:40:07.936 --> 00:40:09.276 A:middle
你也能将其作为

00:40:09.276 --> 00:40:10.716 A:middle
调整图像

00:40:10.716 --> 00:40:12.446 A:middle
外观的

00:40:12.446 --> 00:40:12.976 A:middle
指导手段

00:40:13.256 --> 00:40:14.566 A:middle
比如说如果在图像中

00:40:14.566 --> 00:40:16.156 A:middle
检测到了某个特性

00:40:16.156 --> 00:40:17.896 A:middle
你就可以选择不同的

00:40:18.396 --> 00:40:19.636 A:middle
图像处理方式

00:40:20.986 --> 00:40:22.276 A:middle
这两者当然完全

00:40:22.276 --> 00:40:23.026 A:middle
可以结合在一起

00:40:23.906 --> 00:40:25.426 A:middle
但为了讲得

00:40:25.496 --> 00:40:26.526 A:middle
更具体些

00:40:26.526 --> 00:40:28.026 A:middle
我们有个有趣的演示程序

00:40:28.026 --> 00:40:29.756 A:middle
想跟大家探讨一下

00:40:29.756 --> 00:40:31.526 A:middle
我们会试着用

00:40:31.526 --> 00:40:34.066 A:middle
视频的几个帧

00:40:34.066 --> 00:40:34.516 A:middle
生成一张照片

00:40:34.786 --> 00:40:36.676 A:middle
并将多余的物体

00:40:36.676 --> 00:40:38.446 A:middle
从中删除

00:40:38.846 --> 00:40:39.896 A:middle
这段演示将会

00:40:39.896 --> 00:40:41.506 A:middle
涉及三种框架

00:40:41.506 --> 00:40:42.346 A:middle
四个步骤

00:40:42.826 --> 00:40:44.156 A:middle
第一个步骤会

00:40:44.156 --> 00:40:45.526 A:middle
使用 AVFoundation

00:40:45.526 --> 00:40:46.556 A:middle
提取视频的帧

00:40:47.506 --> 00:40:49.216 A:middle
这一步非常简单

00:40:50.056 --> 00:40:51.376 A:middle
接着我们要用 Vision

00:40:51.546 --> 00:40:53.206 A:middle
来确定需要哪些

00:40:53.206 --> 00:40:55.286 A:middle
单应矩阵来让每一帧

00:40:55.286 --> 00:40:57.026 A:middle
依据共用参照系

00:40:57.026 --> 00:40:57.546 A:middle
进行校准

00:40:58.666 --> 00:40:59.806 A:middle
一些相机抖动也是

00:40:59.806 --> 00:41:00.596 A:middle
在所难免所以一些

00:40:59.806 --> 00:41:00.596 A:middle
在所难免所以一些

00:41:00.596 --> 00:41:01.836 A:middle
校正处理也会大有益处

00:41:02.956 --> 00:41:04.446 A:middle
于是我们便能得到

00:41:04.446 --> 00:41:06.486 A:middle
这样一些单应矩阵

00:41:06.486 --> 00:41:07.486 A:middle
如屏幕所示画面的

00:41:07.696 --> 00:41:09.636 A:middle
每一帧里都有这些

00:41:09.636 --> 00:41:10.436 A:middle
位置会稍稍变化的箭头

00:41:11.896 --> 00:41:13.736 A:middle
第三步是用 Core Image

00:41:13.736 --> 00:41:15.486 A:middle
让所有这些帧

00:41:15.486 --> 00:41:15.966 A:middle
参照彼此进行校准

00:41:16.746 --> 00:41:17.936 A:middle
这一步也非常

00:41:17.936 --> 00:41:18.106 A:middle
简单

00:41:19.106 --> 00:41:20.796 A:middle
最后我们要用

00:41:20.796 --> 00:41:22.566 A:middle
求取中位数的办法

00:41:22.566 --> 00:41:24.496 A:middle
根据视频中的所有帧

00:41:24.496 --> 00:41:26.926 A:middle
创建一张照片

00:41:27.046 --> 00:41:29.106 A:middle
并且生成最佳的图像

00:41:29.886 --> 00:41:31.416 A:middle
这里的技巧在于

00:41:31.416 --> 00:41:33.166 A:middle
生成一幅输出图像

00:41:33.166 --> 00:41:34.316 A:middle
在图像中的每一个输出方位

00:41:34.496 --> 00:41:36.266 A:middle
我们都要在输入帧中

00:41:36.266 --> 00:41:37.066 A:middle
查看相应的方位

00:41:37.456 --> 00:41:38.776 A:middle
然后我们会使用

00:41:38.776 --> 00:41:41.236 A:middle
每个方位上的中位值

00:41:41.486 --> 00:41:42.856 A:middle
大家看一下这个例子

00:41:42.856 --> 00:41:44.966 A:middle
前四幅图像里

00:41:45.736 --> 00:41:47.496 A:middle
小圆点都出现在

00:41:47.496 --> 00:41:49.206 A:middle
水泥路上而在第五幅里

00:41:49.206 --> 00:41:52.046 A:middle
却出现在人腿上

00:41:52.666 --> 00:41:54.016 A:middle
如果我们对这五个值

00:41:54.126 --> 00:41:55.656 A:middle
求取中位数便可以

00:41:55.656 --> 00:41:56.726 A:middle
得到一个看上去像是

00:41:56.876 --> 00:41:57.676 A:middle
水泥路的值

00:41:58.236 --> 00:41:59.066 A:middle
如果我们对图像中的

00:41:59.066 --> 00:42:00.436 A:middle
另一处区域进行同样的操作

00:41:59.066 --> 00:42:00.436 A:middle
另一处区域进行同样的操作

00:42:00.626 --> 00:42:02.276 A:middle
得出的结果则是在

00:42:02.276 --> 00:42:02.706 A:middle
这棵树下

00:42:02.946 --> 00:42:04.876 A:middle
这五帧中有三帧

00:42:04.876 --> 00:42:05.216 A:middle
没问题

00:42:05.266 --> 00:42:07.716 A:middle
另外两帧就差一些

00:42:07.916 --> 00:42:08.926 A:middle
所以我们要对它们

00:42:08.926 --> 00:42:10.426 A:middle
求取中位数而在对图像的

00:42:10.426 --> 00:42:12.336 A:middle
每一个像素都如此处理后

00:42:12.516 --> 00:42:13.296 A:middle
便能得到一个很好的结果

00:42:13.296 --> 00:42:14.536 A:middle
所有在视频中

00:42:14.536 --> 00:42:16.176 A:middle
暂时出现的物体

00:42:16.176 --> 00:42:17.066 A:middle
全都被神奇地删除了

00:42:17.526 --> 00:42:20.006 A:middle
现在让我先来多说几句

00:42:20.006 --> 00:42:21.336 A:middle
这段代码我保证在最后

00:42:21.336 --> 00:42:22.226 A:middle
会让大家看到这段演示的

00:42:22.986 --> 00:42:24.576 A:middle
这里的第一步

00:42:24.576 --> 00:42:26.086 A:middle
我们要用 Vision

00:42:26.086 --> 00:42:27.866 A:middle
来确定每一帧的

00:42:27.866 --> 00:42:28.356 A:middle
单应配准

00:42:28.716 --> 00:42:29.906 A:middle
同样这也很简单

00:42:30.096 --> 00:42:31.066 A:middle
我们要用 Vision

00:42:31.066 --> 00:42:32.836 A:middle
创建请求和

00:42:32.836 --> 00:42:35.386 A:middle
请求处理器用来

00:42:35.386 --> 00:42:36.086 A:middle
生成这些信息

00:42:36.536 --> 00:42:38.226 A:middle
我们要告诉 Vision

00:42:38.226 --> 00:42:39.276 A:middle
执行这条请求

00:42:40.416 --> 00:42:41.826 A:middle
然后在获得结果后

00:42:41.826 --> 00:42:43.326 A:middle
我们要返回结果

00:42:43.696 --> 00:42:45.076 A:middle
并要确保返回的是

00:42:45.126 --> 00:42:47.836 A:middle
一个 VNImageHomographic 类型的

00:42:48.776 --> 00:42:49.896 A:middle
AlignmentObservation 对象

00:42:49.896 --> 00:42:50.606 A:middle
啊好拗口

00:42:51.046 --> 00:42:52.556 A:middle
于是我们就按要求返回

00:42:52.616 --> 00:42:54.906 A:middle
这个对象基本上就是

00:42:54.906 --> 00:42:55.616 A:middle
一个 3x3 的矩阵

00:42:56.136 --> 00:42:59.156 A:middle
返回结果后我们便可

00:42:59.156 --> 00:43:01.076 A:middle
接着使用 Core Image

00:42:59.156 --> 00:43:01.076 A:middle
接着使用 Core Image

00:43:01.076 --> 00:43:02.786 A:middle
依据这个 3x3 的矩阵

00:43:02.786 --> 00:43:03.276 A:middle
校准图像

00:43:03.586 --> 00:43:04.576 A:middle
这部分需要点技巧

00:43:04.576 --> 00:43:05.956 A:middle
但如果使用 Metal 写成的

00:43:06.216 --> 00:43:07.946 A:middle
自定义 Warp 内核实现起来

00:43:07.946 --> 00:43:08.576 A:middle
其实非常简单

00:43:09.866 --> 00:43:11.356 A:middle
大家可以在这个内核中看到

00:43:11.686 --> 00:43:13.026 A:middle
我们现在有个参数

00:43:13.026 --> 00:43:14.056 A:middle
是个 3x3 的浮点数据

00:43:14.056 --> 00:43:15.026 A:middle
这是今年新增到

00:43:15.026 --> 00:43:15.916 A:middle
Core Image 中的

00:43:16.656 --> 00:43:17.696 A:middle
我们要做的就是

00:43:17.696 --> 00:43:18.746 A:middle
获取 destCoord

00:43:18.966 --> 00:43:20.396 A:middle
将它转换成单应性的

00:43:20.396 --> 00:43:21.926 A:middle
destCoord  办法是

00:43:21.926 --> 00:43:22.096 A:middle
在末端加个 1

00:43:22.846 --> 00:43:24.096 A:middle
接着我们要用

00:43:24.096 --> 00:43:26.956 A:middle
这个矢量与矩阵相乘

00:43:26.956 --> 00:43:27.856 A:middle
这会给出我们想要的

00:43:27.856 --> 00:43:29.696 A:middle
homogenousSrcCoord

00:43:29.696 --> 00:43:31.246 A:middle
然后我们要进行一次

00:43:31.246 --> 00:43:33.326 A:middle
透视分割以便获取

00:43:33.326 --> 00:43:34.356 A:middle
源坐标供我们

00:43:34.356 --> 00:43:35.076 A:middle
采样用

00:43:35.986 --> 00:43:37.246 A:middle
这就是这部分的全部代码

00:43:39.086 --> 00:43:40.566 A:middle
第三步是要用

00:43:40.566 --> 00:43:41.936 A:middle
Core Image应用中位数滤镜

00:43:41.976 --> 00:43:43.896 A:middle
在现在这个例子里

00:43:43.896 --> 00:43:45.196 A:middle
给大家看的是一段用来

00:43:45.256 --> 00:43:47.406 A:middle
对5幅图像取中位数的代码

00:43:48.046 --> 00:43:49.446 A:middle
事实上有时候你要处理的图像

00:43:49.446 --> 00:43:50.516 A:middle
数量比这多得多我们会在

00:43:50.516 --> 00:43:51.126 A:middle
演示程序中再涉及这个问题

00:43:51.636 --> 00:43:52.636 A:middle
不过在现在这个例子里

00:43:52.636 --> 00:43:54.506 A:middle
我们会用一个排序网络

00:43:55.076 --> 00:43:56.716 A:middle
来求取五个像素样本的

00:43:56.716 --> 00:43:58.366 A:middle
中位值

00:43:59.166 --> 00:44:00.336 A:middle
同样大家留意一下这部分

00:43:59.166 --> 00:44:00.336 A:middle
同样大家留意一下这部分

00:44:00.336 --> 00:44:02.076 A:middle
这是一个用 Metal 编写

00:44:02.076 --> 00:44:03.616 A:middle
此类内核的绝佳示例

00:44:03.616 --> 00:44:05.596 A:middle
又便捷又简单

00:44:05.596 --> 00:44:07.116 A:middle
因为如今我们在

00:44:07.116 --> 00:44:08.526 A:middle
将这些值传递给

00:44:08.526 --> 00:44:11.076 A:middle
这个 swap 函数时

00:44:11.136 --> 00:44:11.856 A:middle
可以按引用而非按值传递

00:44:12.566 --> 00:44:15.016 A:middle
接下来这个有趣的部分

00:44:15.016 --> 00:44:16.956 A:middle
我要请 Sky

00:44:16.956 --> 00:44:17.416 A:middle
上台来

00:44:17.416 --> 00:44:18.326 A:middle
他会为大家讲解这个主题的

00:44:18.326 --> 00:44:19.826 A:middle
更多细节以及这款滤镜的

00:44:19.826 --> 00:44:19.966 A:middle
工作原理

00:44:27.466 --> 00:44:27.736 A:middle
&gt;&gt;  好的

00:44:27.736 --> 00:44:28.256 A:middle
谢谢 David

00:44:28.806 --> 00:44:30.566 A:middle
嗨我叫 Sky

00:44:30.566 --> 00:44:31.586 A:middle
很高兴今天能为

00:44:31.586 --> 00:44:33.356 A:middle
大家带来这段演示

00:44:33.356 --> 00:44:34.716 A:middle
就像大家看到的画面上半部

00:44:34.716 --> 00:44:36.276 A:middle
是我们的输入视频

00:44:36.476 --> 00:44:38.446 A:middle
我在滑条上来回刷动一下

00:44:38.446 --> 00:44:40.506 A:middle
我们可以看到

00:44:40.506 --> 00:44:41.686 A:middle
在这一整段视频中

00:44:41.686 --> 00:44:43.286 A:middle
没有任何一个时间点

00:44:43.286 --> 00:44:44.906 A:middle
能让我们为这块地标

00:44:44.906 --> 00:44:46.196 A:middle
提取出一个清晰的图像

00:44:46.766 --> 00:44:48.146 A:middle
所以就像这样

00:44:48.146 --> 00:44:49.376 A:middle
在一开始这里有

00:44:49.376 --> 00:44:50.466 A:middle
影子把我们挡住了

00:44:50.506 --> 00:44:52.026 A:middle
接着又有路人

00:44:52.026 --> 00:44:52.376 A:middle
来来往往

00:44:52.996 --> 00:44:54.186 A:middle
所以在整段视频中

00:44:54.186 --> 00:44:55.536 A:middle
完全没有一个时间点

00:44:55.536 --> 00:44:56.446 A:middle
能让我们获得清晰的影像

00:44:57.206 --> 00:45:00.576 A:middle
实际上如果我们将镜头

00:44:57.206 --> 00:45:00.576 A:middle
实际上如果我们将镜头

00:45:00.576 --> 00:45:01.836 A:middle
拉近到它的一角处

00:45:01.836 --> 00:45:03.056 A:middle
便会发现整个视频期间

00:45:03.286 --> 00:45:04.876 A:middle
画面都在不停变化

00:45:05.606 --> 00:45:06.806 A:middle
所以在我们运行 reduction 内核

00:45:06.806 --> 00:45:08.386 A:middle
之前需要先对这些帧

00:45:08.386 --> 00:45:09.136 A:middle
进行校准

00:45:09.246 --> 00:45:10.526 A:middle
我们的办法就是使用

00:45:10.526 --> 00:45:11.746 A:middle
Vision  像 David 提到的那样

00:45:12.546 --> 00:45:14.516 A:middle
现在 Vision可提供两个

00:45:14.546 --> 00:45:17.346 A:middle
配准 API 滑条这里有

00:45:17.346 --> 00:45:17.976 A:middle
显示

00:45:18.526 --> 00:45:20.736 A:middle
其中一行字是单应性 (homographic)

00:45:20.736 --> 00:45:21.666 A:middle
也是 David 刚才提到过的

00:45:21.666 --> 00:45:22.776 A:middle
不过 Vision 还提供了一种

00:45:22.776 --> 00:45:24.466 A:middle
平移校准

00:45:24.466 --> 00:45:25.556 A:middle
以我们这个例子而言

00:45:25.556 --> 00:45:26.366 A:middle
效果并不太好

00:45:26.366 --> 00:45:27.666 A:middle
因为我们的相机移动

00:45:27.666 --> 00:45:29.376 A:middle
并不是全部发生在一个

00:45:29.376 --> 00:45:30.446 A:middle
与图像所在平面相平行的

00:45:31.346 --> 00:45:31.736 A:middle
平面上

00:45:31.986 --> 00:45:33.356 A:middle
所以我们用来

00:45:33.356 --> 00:45:34.406 A:middle
稳定画面的办法

00:45:34.406 --> 00:45:35.896 A:middle
就是将视频的每一帧

00:45:35.896 --> 00:45:37.686 A:middle
都配准到中间帧上

00:45:38.076 --> 00:45:39.316 A:middle
如此处理时不难预见

00:45:39.316 --> 00:45:41.306 A:middle
第一帧和中间帧的

00:45:41.306 --> 00:45:42.566 A:middle
相机位置变化非常之大

00:45:42.566 --> 00:45:43.716 A:middle
所以在这种情况下

00:45:43.716 --> 00:45:45.226 A:middle
单应性配准

00:45:45.226 --> 00:45:46.156 A:middle
会给我们带来

00:45:46.156 --> 00:45:46.526 A:middle
更好的处理效果

00:45:46.526 --> 00:45:48.886 A:middle
所以我们就用它处理

00:45:48.886 --> 00:45:50.486 A:middle
把这个操作打开后如果再把镜头

00:45:50.486 --> 00:45:52.306 A:middle
拉近地标的这个角这里

00:45:52.306 --> 00:45:54.586 A:middle
然后在滑条上刷动

00:45:54.636 --> 00:45:56.396 A:middle
你会发现这个点在每一帧中

00:45:56.396 --> 00:45:58.806 A:middle
基本都没有移动过

00:45:59.496 --> 00:46:01.276 A:middle
如果我们在滑条上反着刷回去

00:45:59.496 --> 00:46:01.276 A:middle
如果我们在滑条上反着刷回去

00:46:01.276 --> 00:46:02.936 A:middle
整个视频的画面

00:46:02.936 --> 00:46:04.206 A:middle
也非常稳定

00:46:05.266 --> 00:46:06.716 A:middle
这倒是让我们想到

00:46:06.756 --> 00:46:08.376 A:middle
如果你打算写个

00:46:08.376 --> 00:46:10.856 A:middle
图像稳定应用

00:46:10.996 --> 00:46:12.136 A:middle
完全可以用 Core Image

00:46:12.136 --> 00:46:13.216 A:middle
和 Vision 轻松搞定

00:46:14.326 --> 00:46:15.786 A:middle
接下来让我跳到

00:46:15.786 --> 00:46:16.566 A:middle
还原的部分

00:46:17.146 --> 00:46:18.326 A:middle
这里我要指出的第一点

00:46:18.326 --> 00:46:20.566 A:middle
就是这里需要我们进行

00:46:20.566 --> 00:46:23.286 A:middle
中位数还原处理的帧

00:46:23.286 --> 00:46:24.866 A:middle
共有 148 帧

00:46:25.046 --> 00:46:26.316 A:middle
这么做比较不切实际

00:46:26.316 --> 00:46:27.416 A:middle
因为我们在对它们

00:46:27.416 --> 00:46:28.376 A:middle
进行排序时需要把

00:46:28.376 --> 00:46:29.116 A:middle
所有帧都保存在内存中

00:46:29.786 --> 00:46:31.306 A:middle
所以我们这里的做法其实是

00:46:31.306 --> 00:46:33.276 A:middle
求取中位数的中位数

00:46:33.276 --> 00:46:34.046 A:middle
作为一个近似值

00:46:34.466 --> 00:46:35.586 A:middle
我们要做的第一件事

00:46:35.586 --> 00:46:37.376 A:middle
就是将所有这些帧

00:46:37.516 --> 00:46:39.986 A:middle
148 帧划分为

00:46:39.986 --> 00:46:40.356 A:middle
几个组别

00:46:40.896 --> 00:46:41.806 A:middle
然后对其中的每一个

00:46:41.806 --> 00:46:43.386 A:middle
组别都计算出一个

00:46:43.386 --> 00:46:43.796 A:middle
局部的组别中位值

00:46:44.276 --> 00:46:45.626 A:middle
接着在第二道处理中

00:46:45.626 --> 00:46:46.936 A:middle
我们再对这些局部中位值

00:46:46.936 --> 00:46:48.306 A:middle
运行 reduction 内核

00:46:48.306 --> 00:46:50.196 A:middle
计算出最终的近似结果

00:46:50.696 --> 00:46:51.766 A:middle
于是我们在最下方这里

00:46:51.766 --> 00:46:53.986 A:middle
能看到这个控制条

00:46:54.236 --> 00:46:56.526 A:middle
还有这些按钮为你显示

00:46:56.526 --> 00:46:58.806 A:middle
这些帧的分组情况

00:46:59.526 --> 00:47:01.476 A:middle
所以如果我改变一下这里的

00:46:59.526 --> 00:47:01.476 A:middle
所以如果我改变一下这里的

00:47:01.476 --> 00:47:03.466 A:middle
组别总数我们可以看到

00:47:03.466 --> 00:47:04.486 A:middle
这些指示器也会跟着变化

00:47:04.486 --> 00:47:05.876 A:middle
那么如果我们将组别数

00:47:05.876 --> 00:47:07.136 A:middle
设为 3 意思就是我们将把

00:47:07.136 --> 00:47:08.306 A:middle
整段视频的所有帧划分为

00:47:08.306 --> 00:47:08.866 A:middle
3 个组别

00:47:09.416 --> 00:47:10.606 A:middle
对于每一个组别

00:47:10.606 --> 00:47:11.606 A:middle
我也可以更改每组容量

00:47:11.606 --> 00:47:14.236 A:middle
这个指标的意思是

00:47:14.236 --> 00:47:15.736 A:middle
我们会将所有帧平均

00:47:15.916 --> 00:47:17.716 A:middle
分配成一组多少帧

00:47:17.716 --> 00:47:18.426 A:middle
以供我们计算

00:47:18.426 --> 00:47:18.996 A:middle
组别中位数之用

00:47:19.826 --> 00:47:21.066 A:middle
那么依照这些规则

00:47:21.066 --> 00:47:23.376 A:middle
我们姑且将组别总数定为 5

00:47:23.616 --> 00:47:26.456 A:middle
每组容量定为7

00:47:26.606 --> 00:47:27.196 A:middle
先这样吧

00:47:28.166 --> 00:47:29.116 A:middle
让我们看看这会

00:47:29.116 --> 00:47:29.646 A:middle
给我们怎样的结果

00:47:30.176 --> 00:47:32.596 A:middle
等它运行完毕需要

00:47:32.596 --> 00:47:33.876 A:middle
一些时间因为 Vision

00:47:33.876 --> 00:47:35.206 A:middle
需要完成所有的配准

00:47:35.206 --> 00:47:37.056 A:middle
我们还需要扭曲这些图像

00:47:37.546 --> 00:47:39.226 A:middle
那么就像我们在输出

00:47:39.226 --> 00:47:41.256 A:middle
这里看到的我们最后的

00:47:41.256 --> 00:47:42.726 A:middle
还原图像中没有出现任何

00:47:42.726 --> 00:47:45.446 A:middle
移动的暂时性的物体

00:47:45.446 --> 00:47:47.326 A:middle
我们得到的地标照片

00:47:47.326 --> 00:47:48.946 A:middle
非常干净完全符合我们

00:47:48.946 --> 00:47:49.256 A:middle
想要的结果

00:47:49.726 --> 00:47:51.826 A:middle
如果我们在输入与

00:47:51.906 --> 00:47:53.816 A:middle
输出之间来回切换一下

00:47:53.816 --> 00:47:55.346 A:middle
会发现整个文字细节都

00:47:55.346 --> 00:47:57.146 A:middle
保留得非常完美

00:47:57.146 --> 00:47:58.656 A:middle
可以让你看到 Vision

00:47:58.656 --> 00:47:59.546 A:middle
强大的校准能力

00:48:00.176 --> 00:48:02.236 A:middle
希望这能给大家一些概念

00:48:02.236 --> 00:48:03.546 A:middle
知道你们可以在 Core Image

00:48:03.546 --> 00:48:04.806 A:middle
和 Vision 之间创造出

00:48:04.806 --> 00:48:06.056 A:middle
多么有意思的

00:48:06.056 --> 00:48:07.146 A:middle
协同效果

00:48:08.026 --> 00:48:09.666 A:middle
那么我要请

00:48:09.816 --> 00:48:11.516 A:middle
David 回到台上

00:48:11.516 --> 00:48:11.976 A:middle
为大家做个总结

00:48:18.676 --> 00:48:19.046 A:middle
&gt;&gt;  好的

00:48:19.046 --> 00:48:20.276 A:middle
非常感谢大家

00:48:20.806 --> 00:48:22.286 A:middle
让我来概括一下

00:48:22.286 --> 00:48:23.536 A:middle
我们今天所讲的内容

00:48:23.606 --> 00:48:25.046 A:middle
还是那句话我们这个新版本的

00:48:25.046 --> 00:48:26.446 A:middle
主要目标是为了让大家的应用

00:48:26.446 --> 00:48:27.936 A:middle
实现更好的性能

00:48:28.596 --> 00:48:29.776 A:middle
在 Core Image 的运行方面

00:48:29.826 --> 00:48:32.196 A:middle
获取更好的信息

00:48:32.196 --> 00:48:32.986 A:middle
还有提供出色的新功能

00:48:33.326 --> 00:48:34.626 A:middle
我们十分期待看到大家

00:48:34.626 --> 00:48:36.226 A:middle
应用利用这些新功能后

00:48:36.776 --> 00:48:39.196 A:middle
会在今年实现

00:48:39.426 --> 00:48:40.196 A:middle
怎样的成长

00:48:40.696 --> 00:48:43.266 A:middle
希望也能在我们的

00:48:43.516 --> 00:48:45.316 A:middle
相关讲座上见到各位

00:48:45.616 --> 00:48:46.986 A:middle
如果大家需要了解

00:48:46.986 --> 00:48:48.036 A:middle
更多信息请访问

00:48:48.036 --> 00:48:50.346 A:middle
网站 developer.apple.com

00:48:50.986 --> 00:48:52.246 A:middle
有一些相关内容的讲座

00:48:52.246 --> 00:48:53.326 A:middle
绝对值得大家

00:48:53.326 --> 00:48:53.776 A:middle
一看

00:48:53.776 --> 00:48:54.886 A:middle
今年早些时候也有一场讲座

00:48:54.886 --> 00:48:57.196 A:middle
主题是支持深度的图像编辑

00:48:57.276 --> 00:48:59.646 A:middle
还有几场介绍 Vision 框架的

00:48:59.646 --> 00:49:02.576 A:middle
几场介绍支持深度的

00:48:59.646 --> 00:49:02.576 A:middle
几场介绍支持深度的

00:49:02.576 --> 00:49:04.816 A:middle
数据捕捉的

00:49:05.026 --> 00:49:06.266 A:middle
感谢大家的参加

00:49:06.266 --> 00:49:07.716 A:middle
祝大家接下来也玩得开心

00:49:07.716 --> 00:49:07.966 A:middle
谢谢
