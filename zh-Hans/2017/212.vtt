WEBVTT

00:00:17.551 --> 00:00:21.688 align:middle line:10%
<c.magenta>（Foundation新特性）</c>

00:00:21.755 --> 00:00:22.589 align:middle line:10%
<c.magenta>大家好</c>

00:00:27.561 --> 00:00:28.428 align:middle line:90%,end
<c.magenta>欢迎到来</c>

00:00:28.562 --> 00:00:31.632 align:middle line:90%,end
<c.magenta>我的名字叫托尼·帕克</c>
<c.magenta>我是Apple Foundation团队的经理</c>

00:00:31.698 --> 00:00:34.368 align:middle line:90%,end
<c.magenta>我今天和我的同事迈克尔·乐修</c>
<c.magenta>还有毅太·费伯一起</c>

00:00:34.434 --> 00:00:36.370 align:middle line:90%,end
<c.magenta>告诉你们有关Foundation的新特性</c>

00:00:37.404 --> 00:00:38.705 align:middle line:90%,end
<c.magenta>我们今天有三个主题</c>

00:00:38.906 --> 00:00:42.276 align:middle line:90%,end
<c.magenta>首先我们要快速浏览一遍</c>
<c.magenta>一些新的API重点</c>

00:00:42.342 --> 00:00:44.144 align:middle line:90%,end
<c.magenta>来自于今年Foundation</c>
<c.magenta>的发布</c>

00:00:44.978 --> 00:00:48.081 align:middle line:90%,end
<c.magenta>在那之后 我们要进入</c>
<c.magenta>两个主要主题的第一个</c>

00:00:48.248 --> 00:00:51.185 align:middle line:90%,end
<c.magenta>键路径和键值观察API</c>

00:00:52.386 --> 00:00:56.056 align:middle line:90%,end
<c.magenta>在那之后 我们将讨论</c>
<c.magenta>新的编码和解码API</c>

00:00:56.924 --> 00:00:59.660 align:middle line:90%,end
<c.magenta>让我们从那些新的API重点开始吧</c>

00:01:02.563 --> 00:01:05.299 align:middle line:90%,end
<c.magenta>首先今年我们强化了</c>
<c.magenta>FileProvider API</c>

00:01:05.364 --> 00:01:07.467 align:middle line:90%,end
<c.magenta>去年我们作为iOS 10</c>
<c.magenta>的一部分所引入的</c>

00:01:08.302 --> 00:01:10.370 align:middle line:90%,end
<c.magenta>这增强了你交互的能力</c>

00:01:10.437 --> 00:01:14.074 align:middle line:90%,end
<c.magenta>在FileProvider扩展</c>
<c.magenta>与其他应用之间</c>

00:01:15.676 --> 00:01:18.545 align:middle line:90%,end
<c.magenta>我们已经改进了可用存储空间API</c>

00:01:18.712 --> 00:01:22.416 align:middle line:90%,end
<c.magenta>这是一个在MSURL上的新API</c>
<c.magenta>它让你不仅能了解</c>

00:01:22.482 --> 00:01:25.452 align:middle line:90%,end
<c.magenta>你用户的设备上有多少剩余空间可用</c>

00:01:25.519 --> 00:01:27.287 align:middle line:90%,end
<c.magenta>而且可以了解</c>
<c.magenta>有多少空间可以被利用</c>

00:01:27.354 --> 00:01:31.592 align:middle line:90%,end
<c.magenta>如果我们清除像是缓存或者旧数据</c>
<c.magenta>这些不必需的内容</c>

00:01:33.594 --> 00:01:37.464 align:middle line:90%,end
<c.magenta>我们在NS range和Swift range中</c>
<c.magenta>加入了新的API来帮助转换</c>

00:01:37.531 --> 00:01:40.367 align:middle line:90%,end
<c.magenta>NS range中NSString的使用</c>

00:01:40.434 --> 00:01:42.636 align:middle line:90%,end
<c.magenta>以及Swift range中</c>
<c.magenta>Swift string的使用</c>

00:01:43.036 --> 00:01:47.374 align:middle line:90%,end
<c.magenta>这对于像是AttributedString和</c>
<c.magenta>RegularExpression的类特别有用</c>

00:01:49.243 --> 00:01:53.680 align:middle line:90%,end
<c.magenta>在NSXPCConnection中 我们加入了</c>
<c.magenta>对于NSProgress更好的支持</c>

00:01:54.081 --> 00:01:56.250 align:middle line:90%,end
<c.magenta>实际上第一个东西真的很有趣</c>

00:01:56.316 --> 00:02:01.121 align:middle line:90%,end
<c.magenta>因为在扩展</c>
<c.magenta>和应用之间新增强的交流能力</c>

00:01:56.316 --> 00:02:01.121 align:middle line:90%,end
<c.magenta>因为在扩展</c>
<c.magenta>和应用之间新增强的交流能力</c>

00:02:01.188 --> 00:02:05.392 align:middle line:90%,end
<c.magenta>实际上是NSXPCConnection</c>
<c.magenta>这是今年首次在iOS上可用</c>

00:02:06.059 --> 00:02:08.929 align:middle line:90%,end
<c.magenta>NSURLSession也获得了对于</c>
<c.magenta>NSProgress的支持</c>

00:02:09.062 --> 00:02:10.931 align:middle line:90%,end
<c.magenta>因为我们希望你们可以使用</c>

00:02:10.997 --> 00:02:15.736 align:middle line:90%,end
<c.magenta>所有这些进程功能来使得从下载</c>

00:02:15.802 --> 00:02:19.339 align:middle line:90%,end
<c.magenta>到扩展 到应用</c>
<c.magenta>到显示给你的用户一气呵成</c>

00:02:21.175 --> 00:02:23.110 align:middle line:90%,end
<c.magenta>最后我们还引入了热通知</c>

00:02:23.177 --> 00:02:25.012 align:middle line:90%,end
<c.magenta>今年从Mac到iOS上</c>

00:02:26.246 --> 00:02:28.582 align:middle line:90%,end
<c.magenta>对于这些主题的更多内容</c>
<c.magenta>请参见Cocoa新特性</c>

00:02:28.649 --> 00:02:30.150 align:middle line:90%,end
<c.magenta>它是在今天早上</c>
<c.magenta>如果你错过了的话</c>

00:02:30.217 --> 00:02:33.554 align:middle line:90%,end
<c.magenta>在那场演讲上 我们有相当多</c>
<c.magenta>关于Foundation的内容</c>

00:02:35.656 --> 00:02:38.625 align:middle line:90%,end
<c.magenta>性能也是我们今年在Foundation上的</c>

00:02:38.692 --> 00:02:40.027 align:middle line:90%,end
<c.magenta>一个关键考虑因素</c>

00:02:40.260 --> 00:02:43.564 align:middle line:90%,end
<c.magenta>从一个有关NSArray的</c>
<c.magenta>新copy-on-write行为开始</c>

00:02:43.630 --> 00:02:46.767 align:middle line:90%,end
<c.magenta>以及它的词典 NSSet</c>
<c.magenta>还有它们易变的朋友</c>

00:02:47.568 --> 00:02:50.771 align:middle line:90%,end
<c.magenta>对于它一个很大的刺激因素是</c>
<c.magenta>将桥接引入到Swift</c>

00:02:51.104 --> 00:02:55.209 align:middle line:90%,end
<c.magenta>因此当Objective-C API</c>
<c.magenta>返回NSArray时</c>

00:02:55.275 --> 00:02:57.911 align:middle line:90%,end
<c.magenta>也许是在一个框架里</c>
<c.magenta>并且你在Swift中使用它</c>

00:02:57.978 --> 00:03:01.048 align:middle line:90%,end
<c.magenta>你接收到了Swift的值类型：</c>
<c.magenta>阵列、词典和套</c>

00:02:57.978 --> 00:03:01.048 align:middle line:90%,end
<c.magenta>你接收到了Swift的值类型：</c>
<c.magenta>阵列、词典和套</c>

00:03:01.448 --> 00:03:03.317 align:middle line:90%,end
<c.magenta>为了保留这些值语义</c>

00:03:03.383 --> 00:03:06.486 align:middle line:90%,end
<c.magenta>那些结构在引入类型上调用复制</c>

00:03:06.553 --> 00:03:07.821 align:middle line:90%,end
<c.magenta>当它们在做桥接的时候</c>

00:03:08.222 --> 00:03:10.858 align:middle line:90%,end
<c.magenta>如果结果恰好是共有子类的一个</c>

00:03:10.924 --> 00:03:12.793 align:middle line:90%,end
<c.magenta>那么复制会开销很大</c>

00:03:13.227 --> 00:03:17.030 align:middle line:90%,end
<c.magenta>现在我们可以延迟复制的花销</c>
<c.magenta>直到其真的改变了</c>

00:03:17.097 --> 00:03:18.365 align:middle line:90%,end
<c.magenta>如果真发生的话</c>

00:03:18.432 --> 00:03:20.868 align:middle line:90%,end
<c.magenta>这会导致相当大的改进</c>

00:03:20.934 --> 00:03:22.269 align:middle line:90%,end
<c.magenta>对于桥接时的性能来说</c>

00:03:23.904 --> 00:03:27.174 align:middle line:90%,end
<c.magenta>结构体数据作为</c>
<c.magenta>Swift Foundation的一部分</c>

00:03:27.241 --> 00:03:29.576 align:middle line:90%,end
<c.magenta>也获得很多性能增强</c>

00:03:29.743 --> 00:03:33.046 align:middle line:90%,end
<c.magenta>特别酷的是 我们可以直列</c>

00:03:33.113 --> 00:03:36.450 align:middle line:90%,end
<c.magenta>数据行为的关键部分到你的应用里</c>
<c.magenta>当你编译的时候</c>

00:03:36.850 --> 00:03:40.754 align:middle line:90%,end
<c.magenta>这包括像是在数据里挨个字节编序号</c>

00:03:40.821 --> 00:03:44.892 align:middle line:90%,end
<c.magenta>这同样获得相当大的性能改进</c>

00:03:46.093 --> 00:03:48.095 align:middle line:90%,end
<c.magenta>NSCalendar获得了</c>
<c.magenta>更好的性能表现</c>

00:03:48.161 --> 00:03:50.797 align:middle line:90%,end
<c.magenta>在CPU时间以及</c>
<c.magenta>更低的峰值内存方面</c>

00:03:50.864 --> 00:03:52.900 align:middle line:90%,end
<c.magenta>除此之外 我们还改进了结果</c>

00:03:52.966 --> 00:03:55.202 align:middle line:90%,end
<c.magenta>它所给你的 特别是在边界情况上</c>

00:03:56.670 --> 00:04:00.374 align:middle line:90%,end
<c.magenta>最后我们改进了桥接NSNumber</c>
<c.magenta>发往和来自于Swift的性能表现</c>

00:03:56.670 --> 00:04:00.374 align:middle line:90%,end
<c.magenta>最后我们改进了桥接NSNumber</c>
<c.magenta>发往和来自于Swift的性能表现</c>

00:04:00.440 --> 00:04:03.944 align:middle line:90%,end
<c.magenta>我们同样也改进了</c>
<c.magenta>其在边界情况的行为</c>

00:04:04.011 --> 00:04:07.347 align:middle line:90%,end
<c.magenta>来提供更好的安全性</c>
<c.magenta>当你在转换</c>

00:04:07.414 --> 00:04:10.517 align:middle line:90%,end
<c.magenta>从NSNumber到Swift数据类型时</c>
<c.magenta>像是整型、布尔这些</c>

00:04:11.351 --> 00:04:14.755 align:middle line:90%,end
<c.magenta>这种更快的桥接对于像是属性表解析</c>
<c.magenta>这类有着很大的影响</c>

00:04:15.522 --> 00:04:16.957 align:middle line:90%,end
<c.magenta>有关这些主题的更多内容</c>

00:04:17.024 --> 00:04:18.858 align:middle line:90%,end
<c.magenta>请观看“与框架高效互动”</c>

00:04:18.926 --> 00:04:20.427 align:middle line:90%,end
<c.magenta>那是在周五下午1：50</c>

00:04:21.228 --> 00:04:23.430 align:middle line:90%,end
<c.magenta>现在我将舞台交给我的同事迈克尔</c>

00:04:23.497 --> 00:04:25.699 align:middle line:90%,end
<c.magenta>来谈谈键路径和键值观察</c>

00:04:34.942 --> 00:04:35.876 align:middle line:90%,end
<c.magenta>谢谢 托尼</c>

00:04:36.376 --> 00:04:40.447 align:middle line:90%,end
<c.magenta>嗨 我是来自Foundation团队的迈克尔</c>
<c.magenta>我很兴奋可以共享一些改进</c>

00:04:40.514 --> 00:04:43.584 align:middle line:90%,end
<c.magenta>有关我们今年对于键路径</c>
<c.magenta>和键值观察所做的</c>

00:04:43.650 --> 00:04:47.487 align:middle line:90%,end
<c.magenta>我想要从Foundation团队中</c>
<c.magenta>有强烈感觉的一些东西谈起</c>

00:04:47.855 --> 00:04:48.956 align:middle line:90%,end
<c.magenta>就是键路径</c>

00:04:49.022 --> 00:04:51.291 align:middle line:90%,end
<c.magenta>在Cocoa开发中非常重要</c>

00:04:51.892 --> 00:04:54.628 align:middle line:90%,end
<c.magenta>因为它让我们推论出类型的结构</c>

00:04:54.695 --> 00:04:56.830 align:middle line:90%,end
<c.magenta>除了任何特定情况</c>

00:04:56.897 --> 00:04:59.266 align:middle line:90%,end
<c.magenta>以一种比起终结更具限制性的方式</c>

00:05:00.234 --> 00:05:02.836 align:middle line:90%,end
<c.magenta>我们觉得这非常重要</c>
<c.magenta>因为它们保证了</c>

00:05:02.903 --> 00:05:04.805 align:middle line:90%,end
<c.magenta>对于语言本身的特别处理</c>

00:05:08.108 --> 00:05:12.713 align:middle line:90%,end
<c.magenta>我们从去年将字符串键路径添加</c>
<c.magenta>到Swift 3就开始着手做这个了</c>

00:05:13.547 --> 00:05:18.051 align:middle line:90%,end
<c.magenta>其使得Swift获得了能力</c>
<c.magenta>在编译时间</c>

00:05:18.118 --> 00:05:20.521 align:middle line:90%,end
<c.magenta>保证了一个Objective-C</c>
<c.magenta>键路径的正确性</c>

00:05:21.154 --> 00:05:22.155 align:middle line:90%,end
<c.magenta>也就是我现在要说的</c>

00:05:22.556 --> 00:05:24.024 align:middle line:90%,end
<c.magenta>假设我们有个Kid类</c>

00:05:24.091 --> 00:05:25.926 align:middle line:90%,end
<c.magenta>它有一些键值可观察的属性</c>

00:05:25.993 --> 00:05:27.761 align:middle line:90%,end
<c.magenta>像是他们的昵称 年龄</c>

00:05:27.828 --> 00:05:30.130 align:middle line:90%,end
<c.magenta>当然了 还有他们现在最好的朋友</c>

00:05:30.197 --> 00:05:32.065 align:middle line:90%,end
<c.magenta>我们可以继续构造一个实例</c>

00:05:32.132 --> 00:05:34.168 align:middle line:90%,end
<c.magenta>在这里例子中 一个叫本基的小男孩</c>

00:05:35.235 --> 00:05:38.272 align:middle line:90%,end
<c.magenta>然后形成了一个到孩子昵称属性</c>
<c.magenta>的字符串键径</c>

00:05:38.505 --> 00:05:40.707 align:middle line:90%,end
<c.magenta>接着 Swift编译器会确认</c>

00:05:40.774 --> 00:05:42.910 align:middle line:90%,end
<c.magenta>这对我们来说是合理的</c>

00:05:43.810 --> 00:05:46.813 align:middle line:10%
<c.magenta>接着我们可以用键值或者键值编码</c>

00:05:46.880 --> 00:05:49.783 align:middle line:10%
<c.magenta>来读取或者将该变量写回到实例中</c>

00:05:51.518 --> 00:05:53.220 align:middle line:90%,end
<c.magenta>现在 我们通过字符串键径</c>

00:05:53.287 --> 00:05:56.456 align:middle line:90%,end
<c.magenta>而获得的当前编译时间检查</c>
<c.magenta>表达式非常棒</c>

00:05:56.823 --> 00:05:59.193 align:middle line:90%,end
<c.magenta>最终它还是会编译到一个字符串</c>

00:06:00.093 --> 00:06:03.630 align:middle line:90%,end
<c.magenta>为了让该字符串有用</c>
<c.magenta>我们需要使用Objective-C运行时间</c>

00:06:03.697 --> 00:06:07.201 align:middle line:90%,end
<c.magenta>之前我看的时候</c>
<c.magenta>对于Swift值类型还是不可用的</c>

00:06:07.267 --> 00:06:09.703 align:middle line:90%,end
<c.magenta>而且大概短时间内不可能变得可用</c>

00:06:10.771 --> 00:06:15.142 align:middle line:90%,end
<c.magenta>最后 字符串键径不携带类型信息</c>

00:06:15.209 --> 00:06:16.376 align:middle line:90%,end
<c.magenta>它就是一个字符串</c>

00:06:17.678 --> 00:06:20.414 align:middle line:90%,end
<c.magenta>因此所有使用字符串键径</c>
<c.magenta>的通用API</c>

00:06:20.480 --> 00:06:23.217 align:middle line:10%
<c.magenta>无论如何都需要被定义</c>

00:06:25.052 --> 00:06:27.821 align:middle line:10%
<c.magenta>但这是Swift</c>
<c.magenta>我们当然可以做得更好</c>

00:06:28.355 --> 00:06:30.257 align:middle line:10%
<c.magenta>因为我们考虑 什么可以</c>

00:06:30.324 --> 00:06:32.593 align:middle line:10%
<c.magenta>键径 它们在Swift中</c>
<c.magenta>应该是什么样呢？</c>

00:06:33.427 --> 00:06:35.195 align:middle line:90%,end
<c.magenta>首先我们想要能描述属性</c>

00:06:35.262 --> 00:06:36.597 align:middle line:90%,end
<c.magenta>这很必要</c>

00:06:36.663 --> 00:06:38.398 align:middle line:90%,end
<c.magenta>它们应该是静态类型安全的</c>

00:06:39.766 --> 00:06:40.934 align:middle line:90%,end
<c.magenta>它们同样也要很快</c>

00:06:41.301 --> 00:06:44.705 align:middle line:90%,end
<c.magenta>并且它们应该可以处理</c>
<c.magenta>我们在Swift中所能遇到的所有值</c>

00:06:46.340 --> 00:06:49.376 align:middle line:90%,end
<c.magenta>它们应该可以在</c>
<c.magenta>Swift所支持的所有平台工作</c>

00:06:49.977 --> 00:06:51.211 align:middle line:90%,end
<c.magenta>因此我们考虑了很长时间</c>

00:06:51.278 --> 00:06:54.014 align:middle line:90%,end
<c.magenta>如何使得所有这些键径梦想成真</c>

00:06:54.348 --> 00:06:56.283 align:middle line:90%,end
<c.magenta>最终跟世界分享我们的点子</c>

00:06:56.350 --> 00:06:58.418 align:middle line:90%,end
<c.magenta>通过开源Swift进化过程</c>

00:06:58.485 --> 00:07:02.322 align:middle line:90%,end
<c.magenta>还有一份名为</c>
<c.magenta>SE-0161智能键径的文档</c>

00:06:58.485 --> 00:07:02.322 align:middle line:90%,end
<c.magenta>还有一份名为</c>
<c.magenta>SE-0161智能键径的文档</c>

00:07:02.856 --> 00:07:05.692 align:middle line:90%,end
<c.magenta>这就是Swift 4中</c>
<c.magenta>新键径字面量看起来是什么样的</c>

00:07:07.227 --> 00:07:09.029 align:middle line:90%,end
<c.magenta>从反斜线符号开始</c>

00:07:10.597 --> 00:07:12.666 align:middle line:90%,end
<c.magenta>跟着基类型的名字</c>

00:07:13.166 --> 00:07:16.603 align:middle line:90%,end
<c.magenta>一个点表明我们是在该基类型里</c>
<c.magenta>要做些什么</c>

00:07:16.670 --> 00:07:18.172 align:middle line:90%,end
<c.magenta>然后就是属性的名字</c>

00:07:19.540 --> 00:07:21.508 align:middle line:90%,end
<c.magenta>这里的反斜线符号很重要</c>

00:07:21.575 --> 00:07:24.611 align:middle line:90%,end
<c.magenta>因为它帮助我们消除了</c>
<c.magenta>执行属性的歧义</c>

00:07:24.678 --> 00:07:27.247 align:middle line:90%,end
<c.magenta>还有属性的提及或者引用</c>

00:07:28.148 --> 00:07:33.487 align:middle line:90%,end
<c.magenta>当然了这是Swift</c>
<c.magenta>因此当我们推断基类型时</c>

00:07:33.554 --> 00:07:35.389 align:middle line:90%,end
<c.magenta>仅通过反斜线符号和点的部分</c>

00:07:37.257 --> 00:07:39.059 align:middle line:90%,end
<c.magenta>键径可以依次形成</c>

00:07:39.126 --> 00:07:41.862 align:middle line:90%,end
<c.magenta>就像是属性接着属性地调用</c>

00:07:42.663 --> 00:07:46.066 align:middle line:90%,end
<c.magenta>很快地 任选链接会像它</c>
<c.magenta>对于属性那样工作</c>

00:07:49.469 --> 00:07:52.105 align:middle line:90%,end
<c.magenta>我们很快会允许通过下标的间接使用</c>

00:07:55.409 --> 00:07:56.877 align:middle line:90%,end
<c.magenta>就像是这样 我也喜欢</c>

00:08:00.214 --> 00:08:02.249 align:middle line:90%,end
<c.magenta>键径也可以从一个下标直接开始</c>

00:08:02.316 --> 00:08:05.652 align:middle line:90%,end
<c.magenta>这里我们从数据的字节下标开始</c>

00:08:05.719 --> 00:08:08.222 align:middle line:90%,end
<c.magenta>这里我们用startIndex表示</c>

00:08:09.223 --> 00:08:11.692 align:middle line:90%,end
<c.magenta>当然了 这也可以被推断</c>

00:08:11.758 --> 00:08:14.828 align:middle line:90%,end
<c.magenta>通过反斜线符号与点剩余部分</c>
<c.magenta>来保持一致性</c>

00:08:15.896 --> 00:08:19.967 align:middle line:90%,end
<c.magenta>这些新键径表达式给所有</c>
<c.magenta>Swift类型提供了一致的语法</c>

00:08:20.033 --> 00:08:23.070 align:middle line:90%,end
<c.magenta>对于支持属性</c>
<c.magenta>无论是保存的还是计算的</c>

00:08:24.271 --> 00:08:27.808 align:middle line:90%,end
<c.magenta>当然了 生成键径是一回事</c>
<c.magenta>但我们如何使用它们呢？</c>

00:08:28.342 --> 00:08:30.143 align:middle line:90%,end
<c.magenta>假设我们有一个键径</c>

00:08:32.246 --> 00:08:33.780 align:middle line:90%,end
<c.magenta>这里是一个孩子的年龄</c>

00:08:34.280 --> 00:08:37.851 align:middle line:90%,end
<c.magenta>使用键径来读取一个属性</c>
<c.magenta>就像是调用下标一样简单</c>

00:08:40.053 --> 00:08:41.154 align:middle line:90%,end
<c.magenta>这开始像是代码</c>

00:08:41.221 --> 00:08:43.423 align:middle line:90%,end
<c.magenta>我现在会高亮句法</c>

00:08:44.558 --> 00:08:45.592 align:middle line:90%,end
<c.magenta>好了</c>

00:08:46.426 --> 00:08:47.895 align:middle line:90%,end
<c.magenta>这里发生了些什么 我想要谈谈</c>

00:08:47.961 --> 00:08:51.598 align:middle line:90%,end
<c.magenta>一些背景动机</c>
<c.magenta>为什么它看起来是这个样子</c>

00:08:51.798 --> 00:08:55.669 align:middle line:90%,end
<c.magenta>首先我们给键径下标参数一个标签</c>

00:08:55.936 --> 00:08:58.438 align:middle line:90%,end
<c.magenta>我们这样做是因为我们想让它</c>
<c.magenta>不会与其他下标产生歧义</c>

00:08:58.505 --> 00:09:00.007 align:middle line:90%,end
<c.magenta>对于其他类型可以存在的下标</c>

00:08:58.505 --> 00:09:00.007 align:middle line:90%,end
<c.magenta>对于其他类型可以存在的下标</c>

00:09:00.307 --> 00:09:02.376 align:middle line:90%,end
<c.magenta>接着 你正在使用的值类型</c>

00:09:02.442 --> 00:09:05.979 align:middle line:90%,end
<c.magenta>它在调用下标</c>
<c.magenta>需要与键径的基类型相匹配</c>

00:09:06.580 --> 00:09:08.549 align:middle line:90%,end
<c.magenta>如果它们匹配 这是合理的事</c>

00:09:08.615 --> 00:09:10.484 align:middle line:90%,end
<c.magenta>你的代码就会编译</c>

00:09:12.419 --> 00:09:16.623 align:middle line:90%,end
<c.magenta>你也可以用下标来变动一个特定的值</c>

00:09:17.257 --> 00:09:20.694 align:middle line:90%,end
<c.magenta>下标非常好 因为它们提供了</c>
<c.magenta>一个快速对称的句法</c>

00:09:20.761 --> 00:09:21.828 align:middle line:90%,end
<c.magenta>来读取和写入一个值</c>

00:09:21.895 --> 00:09:24.064 align:middle line:90%,end
<c.magenta>无论它们是一个值类型还是引用类型</c>

00:09:25.065 --> 00:09:27.501 align:middle line:90%,end
<c.magenta>我已经展示了引用类型的情况</c>

00:09:27.568 --> 00:09:30.404 align:middle line:90%,end
<c.magenta>现在我想要换成展示</c>
<c.magenta>它们如何跟值类型协同运作的</c>

00:09:30.637 --> 00:09:32.406 align:middle line:90%,end
<c.magenta>为了这个目的 我们会扩展例子</c>

00:09:32.472 --> 00:09:33.974 align:middle line:90%,end
<c.magenta>到我真正想谈的地方</c>

00:09:34.041 --> 00:09:35.709 align:middle line:90%,end
<c.magenta>也就是生日派对计划</c>

00:09:37.244 --> 00:09:38.879 align:middle line:90%,end
<c.magenta>让我们创建一个派对</c>

00:09:39.513 --> 00:09:42.850 align:middle line:90%,end
<c.magenta>看起来本基要举办一个</c>
<c.magenta>建造主题的生日派对</c>

00:09:42.916 --> 00:09:45.018 align:middle line:90%,end
<c.magenta>通过一个键径来读取值类型</c>

00:09:45.085 --> 00:09:48.522 align:middle line:90%,end
<c.magenta>使用了和我们之前看到的</c>
<c.magenta>引入类型相同的下标句法</c>

00:09:49.122 --> 00:09:53.393 align:middle line:90%,end
<c.magenta>类似地 改动一个派对</c>
<c.magenta>也是使用相同的下标句法</c>

00:09:53.460 --> 00:09:56.230 align:middle line:90%,end
<c.magenta>这是个常见的主题</c>
<c.magenta>句法真的是一致的</c>

00:09:56.897 --> 00:10:01.201 align:middle line:90%,end
<c.magenta>然而既然这是Swift</c>
<c.magenta>我们知道本的派对是一个生日派对</c>

00:09:56.897 --> 00:10:01.201 align:middle line:90%,end
<c.magenta>然而既然这是Swift</c>
<c.magenta>我们知道本的派对是一个生日派对</c>

00:10:01.268 --> 00:10:03.403 align:middle line:90%,end
<c.magenta>因此语言可以为我们推断这一点</c>

00:10:04.771 --> 00:10:07.875 align:middle line:90%,end
<c.magenta>我刚听说本</c>
<c.magenta>又想改他生日派对的主题了</c>

00:10:07.941 --> 00:10:09.510 align:middle line:90%,end
<c.magenta>那么我们就在这里改过来吧</c>

00:10:10.744 --> 00:10:12.713 align:middle line:90%,end
<c.magenta>这里我高亮了一下句法</c>

00:10:12.846 --> 00:10:15.249 align:middle line:90%,end
<c.magenta>像是这样的代码</c>
<c.magenta>你只会调用属性</c>

00:10:15.315 --> 00:10:19.086 align:middle line:90%,end
<c.magenta>所以让我们看看当你使用这些键径</c>
<c.magenta>表达式的时候实际发生了什么吧</c>

00:10:21.755 --> 00:10:24.558 align:middle line:90%,end
<c.magenta>键径表达式</c>
<c.magenta>实际上生成了真正的值</c>

00:10:24.625 --> 00:10:26.527 align:middle line:90%,end
<c.magenta>像是所有的值 它们能被保存</c>

00:10:28.095 --> 00:10:29.963 align:middle line:90%,end
<c.magenta>那么 这个变量的类型是什么呢？</c>

00:10:30.030 --> 00:10:33.834 align:middle line:90%,end
<c.magenta>让我们假设使用Option加X键</c>
<c.magenta>就像是我们在Xcode中所能做的那样</c>

00:10:33.901 --> 00:10:37.004 align:middle line:90%,end
<c.magenta>不出意外 我们得到了</c>
<c.magenta>一个强类型的键径</c>

00:10:37.571 --> 00:10:40.874 align:middle line:90%,end
<c.magenta>其基类型是Kid</c>
<c.magenta>属性类型是String</c>

00:10:40.941 --> 00:10:42.476 align:middle line:90%,end
<c.magenta>因为昵称是字符串</c>

00:10:44.077 --> 00:10:46.880 align:middle line:90%,end
<c.magenta>强类型键径也可以适用于复合键径</c>

00:10:46.947 --> 00:10:48.849 align:middle line:90%,end
<c.magenta>这里我们从生日派对开始</c>

00:10:48.916 --> 00:10:51.118 align:middle line:90%,end
<c.magenta>一直遍历到庆祝者的年龄</c>

00:10:51.418 --> 00:10:54.354 align:middle line:90%,end
<c.magenta>当然了年龄是double类型</c>
<c.magenta>因为如果你不认识一个小孩子</c>

00:10:54.421 --> 00:10:57.057 align:middle line:90%,end
<c.magenta>小数点后的数字是非常重要的</c>

00:10:58.992 --> 00:11:01.929 align:middle line:90%,end
<c.magenta>变量所保存的键径</c>
<c.magenta>可以像字面量那样用</c>

00:10:58.992 --> 00:11:01.929 align:middle line:90%,end
<c.magenta>变量所保存的键径</c>
<c.magenta>可以像字面量那样用</c>

00:11:06.066 --> 00:11:07.434 align:middle line:90%,end
<c.magenta>因为它们是强类型的</c>

00:11:07.501 --> 00:11:09.369 align:middle line:90%,end
<c.magenta>它们是静态被认知拥有正确类型的</c>

00:11:09.436 --> 00:11:11.171 align:middle line:90%,end
<c.magenta>这里是如我们所期望的double</c>

00:11:12.206 --> 00:11:14.675 align:middle line:90%,end
<c.magenta>假设我们要计划另一个生日派对</c>

00:11:14.741 --> 00:11:17.678 align:middle line:90%,end
<c.magenta>这次是米亚的</c>
<c.magenta>或者本的妹妹米亚</c>

00:11:18.612 --> 00:11:20.047 align:middle line:90%,end
<c.magenta>我们可以使用相同的键径变量</c>

00:11:20.113 --> 00:11:22.616 align:middle line:90%,end
<c.magenta>来找出她要庆祝的是哪个生日</c>

00:11:22.683 --> 00:11:26.653 align:middle line:90%,end
<c.magenta>通过这种方式 键径某种程度上</c>
<c.magenta>作为未执行属性调用来使用</c>

00:11:27.754 --> 00:11:30.390 align:middle line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我直接写入了庆祝者的年龄</c>

00:11:30.457 --> 00:11:32.492 align:middle line:90%,end
<c.magenta>但是让我们更进一步泛化一点</c>

00:11:33.126 --> 00:11:35.762 align:middle line:90%,end
<c.magenta>如果我想知道</c>
<c.magenta>任何跟一个派对有关的人的年龄呢？</c>

00:11:36.530 --> 00:11:38.532 align:middle line:90%,end
<c.magenta>我们要定义一个函数</c>

00:11:38.632 --> 00:11:41.168 align:middle line:90%,end
<c.magenta>把它叫做</c>
<c.magenta>partyPersonsAge函数</c>

00:11:41.235 --> 00:11:45.405 align:middle line:90%,end
<c.magenta>它们被给了一个派对和</c>
<c.magenta>参与者的键径并将返回他们的年龄</c>

00:11:45.672 --> 00:11:47.574 align:middle line:90%,end
<c.magenta>为了达成这个目的</c>
<c.magenta>我要展示另一个功能</c>

00:11:47.641 --> 00:11:49.810 align:middle line:90%,end
<c.magenta>这些类型安全的键径</c>

00:11:49.877 --> 00:11:53.547 align:middle line:90%,end
<c.magenta>可以动态地从其他键径生成新的键径</c>

00:11:53.881 --> 00:11:56.283 align:middle line:90%,end
<c.magenta>这里我会把两个键径连到一起</c>

00:11:56.350 --> 00:11:59.720 align:middle line:90%,end
<c.magenta>participantPath到孩子的年龄</c>
<c.magenta>同样 我们这里推断了是孩子</c>

00:11:59.786 --> 00:12:03.290 align:middle line:90%,end
<c.magenta>这就是为什么除了变量名</c>
<c.magenta>你都看不到“kid”这个词</c>

00:11:59.786 --> 00:12:03.290 align:middle line:90%,end
<c.magenta>这就是为什么除了变量名</c>
<c.magenta>你都看不到“kid”这个词</c>

00:12:03.824 --> 00:12:06.326 align:middle line:90%,end
<c.magenta>如你所料</c>
<c.magenta>你会获得一个强类型的键径</c>

00:12:06.393 --> 00:12:08.662 align:middle line:90%,end
<c.magenta>从BirthdayParty开始</c>
<c.magenta>以Double结尾</c>

00:12:09.463 --> 00:12:13.367 align:middle line:90%,end
<c.magenta>用这个键径和存在变量中的</c>
<c.magenta>其他键径一样</c>

00:12:13.700 --> 00:12:15.369 align:middle line:90%,end
<c.magenta>我们可以在庆祝者中</c>
<c.magenta>调用我们的函数</c>

00:12:15.435 --> 00:12:18.172 align:middle line:90%,end
<c.magenta>我们可以得到和之前所见</c>
<c.magenta>完全相同的结果</c>

00:12:19.106 --> 00:12:22.209 align:middle line:90%,end
<c.magenta>当支持下标的时候</c>
<c.magenta>我们现在也可以使用这个函数</c>

00:12:22.276 --> 00:12:25.012 align:middle line:90%,end
<c.magenta>来找到派对的第一个到场者的年龄</c>

00:12:27.080 --> 00:12:30.050 align:middle line:90%,end
<c.magenta>现在我想要谈一些</c>
<c.magenta>关于附加键径的规则</c>

00:12:30.617 --> 00:12:34.288 align:middle line:90%,end
<c.magenta>当我们把两个键径连到一起时</c>
<c.magenta>就像我们把它们加到了一起</c>

00:12:35.556 --> 00:12:37.524 align:middle line:90%,end
<c.magenta>为了让这个相加能讲得通</c>

00:12:37.591 --> 00:12:40.327 align:middle line:90%,end
<c.magenta>我们需要看看</c>
<c.magenta>所涉及的键径的类型</c>

00:12:41.028 --> 00:12:44.231 align:middle line:90%,end
<c.magenta>我们需要看每个基类型</c>
<c.magenta>和每个属性类型</c>

00:12:45.966 --> 00:12:48.202 align:middle line:90%,end
<c.magenta>内部类型需要匹配</c>

00:12:48.302 --> 00:12:51.004 align:middle line:90%,end
<c.magenta>如果是这种情况的话</c>
<c.magenta>我们可以生成一个键径</c>

00:12:51.071 --> 00:12:54.341 align:middle line:90%,end
<c.magenta>从初始基类型到最终属性类型</c>

00:12:56.476 --> 00:13:00.080 align:middle line:90%,end
<c.magenta>这样 键径不在乎它们是如何获得</c>

00:12:56.476 --> 00:13:00.080 align:middle line:90%,end
<c.magenta>这样 键径不在乎它们是如何获得</c>

00:13:00.147 --> 00:13:01.882 align:middle line:90%,end
<c.magenta>从它们的基类型到属性类型</c>

00:13:01.949 --> 00:13:04.618 align:middle line:90%,end
<c.magenta>它们能办到</c>
<c.magenta>而且编译器会为我们确保这一点</c>

00:13:06.019 --> 00:13:07.955 align:middle line:90%,end
<c.magenta>现在我想看看另一个例子</c>

00:13:08.021 --> 00:13:11.225 align:middle line:90%,end
<c.magenta>或者说Swift键径</c>
<c.magenta>所提供的类型安全性的另一个方面</c>

00:13:13.627 --> 00:13:14.995 align:middle line:90%,end
<c.magenta>以防你们还不是很清楚</c>

00:13:16.129 --> 00:13:18.398 align:middle line:90%,end
<c.magenta>假设我们想输出一个我们派对的概要</c>

00:13:18.532 --> 00:13:21.068 align:middle line:90%,end
<c.magenta>我们可以在键径中</c>
<c.magenta>生成一个label数组</c>

00:13:22.402 --> 00:13:25.539 align:middle line:90%,end
<c.magenta>但是我们会期望这个数组</c>
<c.magenta>partyPath什么呢</c>

00:13:25.606 --> 00:13:27.441 align:middle line:90%,end
<c.magenta>我们期望它的类型是什么呢？</c>

00:13:27.508 --> 00:13:29.109 align:middle line:90%,end
<c.magenta>毕竟主题是一个字符串</c>

00:13:29.476 --> 00:13:31.211 align:middle line:90%,end
<c.magenta>Attending是一个孩子的数组</c>

00:13:31.778 --> 00:13:34.081 align:middle line:90%,end
<c.magenta>celebrant</c>
<c.magenta>是对单独一个孩子的引用</c>

00:13:35.215 --> 00:13:36.717 align:middle line:90%,end
<c.magenta>这种情况下</c>
<c.magenta>我们获得了一个新类型</c>

00:13:36.783 --> 00:13:39.686 align:middle line:90%,end
<c.magenta>它是一个关于BirthdayParty的</c>
<c.magenta>PartialKeyPath数组</c>

00:13:40.220 --> 00:13:43.190 align:middle line:90%,end
<c.magenta>PartialKeyPath部分</c>
<c.magenta>是无类型键径</c>

00:13:43.557 --> 00:13:44.825 align:middle line:90%,end
<c.magenta>它们知道它们的基类型</c>

00:13:44.892 --> 00:13:50.597 align:middle line:90%,end
<c.magenta>但是它们可以指向任何对于</c>
<c.magenta>该基类型来说合法的键径</c>

00:13:50.664 --> 00:13:53.734 align:middle line:90%,end
<c.magenta>这样我们打印出报告</c>

00:13:54.368 --> 00:14:00.874 align:middle line:90%,end
<c.magenta>我们把titles和paths压缩到一起</c>
<c.magenta>使用partyPath来获取partyValue</c>

00:13:54.368 --> 00:14:00.874 align:middle line:90%,end
<c.magenta>我们把titles和paths压缩到一起</c>
<c.magenta>使用partyPath来获取partyValue</c>

00:14:00.941 --> 00:14:02.176 align:middle line:90%,end
<c.magenta>然后打印我们的报告</c>

00:14:02.576 --> 00:14:04.578 align:middle line:90%,end
<c.magenta>你可以看到米亚要举办</c>
<c.magenta>一个太空主题的</c>

00:14:04.645 --> 00:14:06.480 align:middle line:90%,end
<c.magenta>看起来是个家庭生日派对</c>

00:14:06.547 --> 00:14:08.682 align:middle line:90%,end
<c.magenta>不过它是太空主题的</c>
<c.magenta>应该挺有意思</c>

00:14:11.218 --> 00:14:13.487 align:middle line:90%,end
<c.magenta>现在我想往BirthdayParty中</c>
<c.magenta>添加一个扩展</c>

00:14:13.687 --> 00:14:14.755 align:middle line:90%,end
<c.magenta>我们要添加一个函数</c>

00:14:14.821 --> 00:14:16.590 align:middle line:90%,end
<c.magenta>来让孩子们吹灭他们的生日蜡烛</c>

00:14:16.657 --> 00:14:17.724 align:middle line:90%,end
<c.magenta>这会和我们之前所做的</c>

00:14:17.791 --> 00:14:19.326 align:middle line:90%,end
<c.magenta>有点不一样</c>

00:14:19.393 --> 00:14:21.161 align:middle line:90%,end
<c.magenta>因为到目前为止</c>
<c.magenta>我们一直在读取键径</c>

00:14:21.228 --> 00:14:23.997 align:middle line:90%,end
<c.magenta>现在我想要写入到一个键径</c>
<c.magenta>或者使用键径来写入到一个值</c>

00:14:25.265 --> 00:14:26.567 align:middle line:90%,end
<c.magenta>我们要加入我们的函数</c>

00:14:27.000 --> 00:14:29.236 align:middle line:90%,end
<c.magenta>我想要指出的是</c>
<c.magenta>ageKeyPath实际上是一个新的类型</c>

00:14:29.303 --> 00:14:32.940 align:middle line:90%,end
<c.magenta>它是一个可写的键径</c>
<c.magenta>从BirthdayParty开始 以Double结尾</c>

00:14:34.374 --> 00:14:37.544 align:middle line:90%,end
<c.magenta>我们可以像是一般键径</c>
<c.magenta>那样来使用可写键径</c>

00:14:37.611 --> 00:14:39.913 align:middle line:90%,end
<c.magenta>从我们的值中得到想要的值</c>

00:14:40.480 --> 00:14:42.549 align:middle line:90%,end
<c.magenta>我们也可以使用它们来变动我们的值</c>

00:14:43.183 --> 00:14:45.352 align:middle line:90%,end
<c.magenta>我们终于要吹灭蜡烛了</c>

00:14:45.619 --> 00:14:48.155 align:middle line:90%,end
<c.magenta>除了一个问题</c>
<c.magenta>这一切看起来都很好</c>

00:14:48.789 --> 00:14:49.723 align:middle line:90%,end
<c.magenta>它不编译</c>

00:14:50.290 --> 00:14:51.859 align:middle line:90%,end
<c.magenta>这是个生日灾难</c>

00:14:53.861 --> 00:14:56.296 align:middle line:90%,end
<c.magenta>让我们尝试一下</c>
<c.magenta>我会现场解决这个问题</c>

00:14:56.964 --> 00:14:57.798 align:middle line:90%,end
<c.magenta>排除障碍</c>

00:14:58.832 --> 00:15:00.467 align:middle line:90%,end
<c.magenta>编译器告诉我们</c>

00:14:58.832 --> 00:15:00.467 align:middle line:90%,end
<c.magenta>编译器告诉我们</c>

00:15:00.534 --> 00:15:03.237 align:middle line:90%,end
<c.magenta>“无法分配到不可改变的</c>
<c.magenta>表达类型Double”</c>

00:15:03.437 --> 00:15:05.372 align:middle line:90%,end
<c.magenta>这是非常Swift的风格</c>

00:15:06.173 --> 00:15:07.941 align:middle line:90%,end
<c.magenta>让我们看看能否知道到底是怎么回事</c>

00:15:08.041 --> 00:15:11.044 align:middle line:90%,end
<c.magenta>它说不可变的</c>
<c.magenta>但我们传的是一个可写的键径</c>

00:15:12.045 --> 00:15:13.981 align:middle line:90%,end
<c.magenta>我们确实传的是一个键径</c>

00:15:14.047 --> 00:15:17.050 align:middle line:90%,end
<c.magenta>让我们确定这个键径</c>
<c.magenta>实际上是个不可变的变量</c>

00:15:17.117 --> 00:15:19.586 align:middle line:90%,end
<c.magenta>有时候你应该用的是</c>
<c.magenta>var而你用的是let</c>

00:15:19.653 --> 00:15:21.255 align:middle line:90%,end
<c.magenta>让我们回到kid的声明</c>

00:15:21.321 --> 00:15:24.124 align:middle line:90%,end
<c.magenta>但我们看到的是var</c>
<c.magenta>我们的年龄的确是可变的</c>

00:15:24.391 --> 00:15:26.693 align:middle line:90%,end
<c.magenta>是var 所以没有问题</c>

00:15:27.528 --> 00:15:30.097 align:middle line:90%,end
<c.magenta>也许问题是写入本身</c>

00:15:30.163 --> 00:15:31.665 align:middle line:90%,end
<c.magenta>也就是我们用了subscript</c>

00:15:31.732 --> 00:15:33.667 align:middle line:90%,end
<c.magenta>我现在告诉你们</c>
<c.magenta>subscript是可以工作的</c>

00:15:33.734 --> 00:15:35.135 align:middle line:90%,end
<c.magenta>所以不是这个问题</c>

00:15:35.402 --> 00:15:37.504 align:middle line:90%,end
<c.magenta>肯定是self有什么问题</c>

00:15:38.472 --> 00:15:41.375 align:middle line:90%,end
<c.magenta>self是什么？</c>
<c.magenta>self是BirthdayParty的一个扩展</c>

00:15:41.441 --> 00:15:43.477 align:middle line:90%,end
<c.magenta>因此现在我们需要回到</c>
<c.magenta>BirthdayParty的声明</c>

00:15:43.544 --> 00:15:44.711 align:middle line:90%,end
<c.magenta>幸运的是 我们还有余地</c>

00:15:46.580 --> 00:15:48.949 align:middle line:90%,end
<c.magenta>我们会发现BirthdayParty</c>
<c.magenta>是一个结构体</c>

00:15:49.016 --> 00:15:50.417 align:middle line:90%,end
<c.magenta>而结构体是值类型的</c>

00:15:50.484 --> 00:15:52.452 align:middle line:90%,end
<c.magenta>因此这里编译器所做的是正确的</c>

00:15:52.519 --> 00:15:54.321 align:middle line:90%,end
<c.magenta>它不让我们变动BirthdayParty</c>

00:15:54.388 --> 00:15:57.724 align:middle line:90%,end
<c.magenta>因为我们的键径是</c>
<c.magenta>固定在BirthdayParty</c>

00:15:58.292 --> 00:15:59.526 align:middle line:90%,end
<c.magenta>我们能用的一个技巧就是</c>

00:15:59.593 --> 00:16:03.130 align:middle line:90%,end
<c.magenta>我们看看所知道的Swift的技巧</c>
<c.magenta>会发现</c>

00:15:59.593 --> 00:16:03.130 align:middle line:90%,end
<c.magenta>我们看看所知道的Swift的技巧</c>
<c.magenta>会发现</c>

00:16:03.197 --> 00:16:05.999 align:middle line:90%,end
<c.magenta>我们加上mutating就行了</c>
<c.magenta>一切都能正常运行了</c>

00:16:07.401 --> 00:16:09.203 align:middle line:90%,end
<c.magenta>但是当你这么做的时候</c>
<c.magenta>你会要停下来想想</c>

00:16:09.269 --> 00:16:11.004 align:middle line:90%,end
<c.magenta>这真的是正确的选择吗？</c>

00:16:11.238 --> 00:16:16.343 align:middle line:90%,end
<c.magenta>因为我们不想改动键</c>
<c.magenta>或者是BirthdayParty</c>

00:16:17.044 --> 00:16:18.111 align:middle line:90%,end
<c.magenta>我们要改动的是庆祝者</c>

00:16:18.178 --> 00:16:20.681 align:middle line:90%,end
<c.magenta>我刚检查过</c>
<c.magenta>BirthdayParty没有年龄</c>

00:16:21.081 --> 00:16:24.218 align:middle line:90%,end
<c.magenta>而庆祝者实际上是一个类</c>
<c.magenta>一个引用类型</c>

00:16:24.985 --> 00:16:27.321 align:middle line:90%,end
<c.magenta>对于这点 我们实际上有另一类键径</c>

00:16:27.387 --> 00:16:31.325 align:middle line:90%,end
<c.magenta>添加引入可变语义到变动中</c>

00:16:31.391 --> 00:16:33.527 align:middle line:90%,end
<c.magenta>它叫作引用可写键径</c>

00:16:34.695 --> 00:16:36.063 align:middle line:90%,end
<c.magenta>那么让我们使用它</c>

00:16:36.129 --> 00:16:37.431 align:middle line:90%,end
<c.magenta>这次编译通过了</c>

00:16:37.497 --> 00:16:39.466 align:middle line:90%,end
<c.magenta>我们可以最终声明我们的小男孩本基</c>

00:16:39.533 --> 00:16:42.236 align:middle line:90%,end
<c.magenta>大了一岁</c>
<c.magenta>尽管我觉得他现在叫本了</c>

00:16:43.270 --> 00:16:44.338 align:middle line:90%,end
<c.magenta>我们可以看看区别</c>

00:16:44.404 --> 00:16:46.874 align:middle line:90%,end
<c.magenta>在这两种变动键径的方法之间</c>

00:16:48.208 --> 00:16:49.977 align:middle line:90%,end
<c.magenta>我们有个</c>
<c.magenta>WritableKeyPath</c>

00:16:50.043 --> 00:16:53.547 align:middle line:90%,end
<c.magenta>WritableKeyPath</c>
<c.magenta>直接写入到它们的值类型base上</c>

00:16:53.881 --> 00:16:57.017 align:middle line:90%,end
<c.magenta>因此base或者链式的base</c>
<c.magenta>需要是可变动的</c>

00:16:58.719 --> 00:17:03.156 align:middle line:90%,end
<c.magenta>然而一个ReferenceWritableKeyPath</c>
<c.magenta>会在引用类型上调用一个属性setter</c>

00:16:58.719 --> 00:17:03.156 align:middle line:90%,end
<c.magenta>然而一个ReferenceWritableKeyPath</c>
<c.magenta>会在引用类型上调用一个属性setter</c>

00:17:03.557 --> 00:17:06.326 align:middle line:90%,end
<c.magenta>所有这些键径类型</c>
<c.magenta>生成了一个继承树</c>

00:17:07.794 --> 00:17:09.730 align:middle line:10%
<c.magenta>每个都比上一个更详细</c>

00:17:10.063 --> 00:17:11.565 align:middle line:10%
<c.magenta>这棵树最上面的根</c>

00:17:11.632 --> 00:17:13.666 align:middle line:10%
<c.magenta>是另一种我没有提到过的键径</c>

00:17:13.733 --> 00:17:16.837 align:middle line:10%
<c.magenta>叫作AnyKeyPath</c>
<c.magenta>这是一种完全无类型的键径</c>

00:17:17.003 --> 00:17:18.771 align:middle line:10%
<c.magenta>这对于你有键径时很有用</c>

00:17:18.839 --> 00:17:21.575 align:middle line:90%,end
<c.magenta>该键径是由多个base到</c>
<c.magenta>多个不同属性类型所组成</c>

00:17:21.642 --> 00:17:22.809 align:middle line:90%,end
<c.magenta>通常是一个集</c>

00:17:24.144 --> 00:17:26.380 align:middle line:90%,end
<c.magenta>如果这一切似乎有一点复杂</c>

00:17:26.445 --> 00:17:28.815 align:middle line:90%,end
<c.magenta>我向你保证</c>
<c.magenta>有关你想要的这种键径的规则</c>

00:17:28.882 --> 00:17:32.286 align:middle line:90%,end
<c.magenta>使用 还有获得</c>
<c.magenta>实际上很简单</c>

00:17:32.352 --> 00:17:34.421 align:middle line:90%,end
<c.magenta>还符合你已经熟悉的规则</c>

00:17:34.488 --> 00:17:37.524 align:middle line:90%,end
<c.magenta>关于Swift值类型和引用类型的</c>

00:17:38.725 --> 00:17:41.128 align:middle line:90%,end
<c.magenta>我们先解决一半问题</c>

00:17:41.328 --> 00:17:44.665 align:middle line:90%,end
<c.magenta>只读属性总会产生一个键径</c>

00:17:44.731 --> 00:17:46.466 align:middle line:90%,end
<c.magenta>（键径）</c>

00:17:46.767 --> 00:17:49.603 align:middle line:90%,end
<c.magenta>而可读写属性</c>
<c.magenta>事情就有些细微差别了</c>

00:17:50.938 --> 00:17:54.041 align:middle line:90%,end
<c.magenta>可变值类型base或者</c>
<c.magenta>链式可变值类型base</c>

00:17:54.107 --> 00:17:56.310 align:middle line:90%,end
<c.magenta>会生成一个</c>
<c.magenta>WritableKeyPath</c>

00:17:57.010 --> 00:18:01.515 align:middle line:90%,end
<c.magenta>WritableKeyPath</c>
<c.magenta>可以帮你更有效率地写入一个值类型</c>

00:17:57.010 --> 00:18:01.515 align:middle line:90%,end
<c.magenta>WritableKeyPath</c>
<c.magenta>可以帮你更有效率地写入一个值类型</c>

00:18:02.382 --> 00:18:04.418 align:middle line:90%,end
<c.magenta>然而如果其中一个值类型</c>

00:18:05.519 --> 00:18:07.754 align:middle line:90%,end
<c.magenta>是不可变的 就像是一个let语句</c>

00:18:08.655 --> 00:18:10.190 align:middle line:90%,end
<c.magenta>该属性的可变性就消失了</c>

00:18:10.257 --> 00:18:13.026 align:middle line:90%,end
<c.magenta>就好像你使用一般属性的时候</c>

00:18:13.227 --> 00:18:14.828 align:middle line:90%,end
<c.magenta>你就剩下了KeyPath</c>

00:18:15.796 --> 00:18:17.564 align:middle line:90%,end
<c.magenta>最后讲个最简单的例子</c>

00:18:17.631 --> 00:18:19.733 align:middle line:90%,end
<c.magenta>在引入类型base上的可读写属性</c>

00:18:19.800 --> 00:18:22.102 align:middle line:90%,end
<c.magenta>总是生成</c>
<c.magenta>ReferenceWritableKeyPath</c>

00:18:23.704 --> 00:18:27.074 align:middle line:90%,end
<c.magenta>现在我想分享下关于</c>
<c.magenta>键径行为的最后一个细节</c>

00:18:28.108 --> 00:18:30.210 align:middle line:90%,end
<c.magenta>当我们和subscript一起</c>
<c.magenta>使用键径的时候</c>

00:18:30.277 --> 00:18:33.547 align:middle line:90%,end
<c.magenta>知道它们的行为和终结</c>
<c.magenta>有什么区别很重要</c>

00:18:34.648 --> 00:18:36.183 align:middle line:90%,end
<c.magenta>思考下面的例子</c>

00:18:36.550 --> 00:18:37.684 align:middle line:90%,end
<c.magenta>这里我要生成一个键径</c>

00:18:37.751 --> 00:18:39.686 align:middle line:90%,end
<c.magenta>来自于生日派对的第一个到场者</c>

00:18:40.153 --> 00:18:41.622 align:middle line:90%,end
<c.magenta>并且使用它来识别他们的年龄</c>

00:18:41.688 --> 00:18:45.692 align:middle line:90%,end
<c.magenta>使用我们前面的partyPersonAge方法</c>
<c.magenta>来识别他们的年龄</c>

00:18:46.226 --> 00:18:49.029 align:middle line:90%,end
<c.magenta>不出所料 这里我们得到的键径</c>

00:18:49.096 --> 00:18:51.732 align:middle line:90%,end
<c.magenta>是我们attendees数组</c>
<c.magenta>的第0个元素</c>

00:18:53.133 --> 00:18:54.835 align:middle line:90%,end
<c.magenta>假设我把序号变成了1</c>

00:18:54.902 --> 00:18:58.205 align:middle line:90%,end
<c.magenta>出于某种原因</c>
<c.magenta>我也关心第二个到场者的年龄</c>

00:18:59.506 --> 00:19:01.175 align:middle line:90%,end
<c.magenta>你可能会感到惊讶</c>

00:18:59.506 --> 00:19:01.175 align:middle line:90%,end
<c.magenta>你可能会感到惊讶</c>

00:19:02.342 --> 00:19:04.978 align:middle line:90%,end
<c.magenta>结果键径没有变化</c>

00:19:05.045 --> 00:19:06.980 align:middle line:90%,end
<c.magenta>尽管我把序号改变了</c>

00:19:07.481 --> 00:19:10.450 align:middle line:90%,end
<c.magenta>通过这种方式</c>
<c.magenta>键径变得和终结不一样</c>

00:19:10.851 --> 00:19:12.286 align:middle line:90%,end
<c.magenta>它们由值所捕获</c>

00:19:12.452 --> 00:19:14.421 align:middle line:90%,end
<c.magenta>当这个功能变得可用时</c>

00:19:14.488 --> 00:19:16.957 align:middle line:90%,end
<c.magenta>我想要今天说以便你不会感到惊讶</c>

00:19:17.858 --> 00:19:18.825 align:middle line:90%,end
<c.magenta>我现在说了</c>

00:19:20.060 --> 00:19:24.698 align:middle line:90%,end
<c.magenta>到目前为止 我们已看了许多</c>
<c.magenta>关于这些类型安全键径的例子</c>

00:19:24.765 --> 00:19:29.670 align:middle line:90%,end
<c.magenta>满足了我们快速、类型安全以及</c>
<c.magenta>富于表现的属性遍历目标</c>

00:19:31.104 --> 00:19:32.906 align:middle line:90%,end
<c.magenta>我想要换个主题了</c>

00:19:32.973 --> 00:19:34.341 align:middle line:90%,end
<c.magenta>因为我想谈谈</c>
<c.magenta>这些键径是如何</c>

00:19:34.408 --> 00:19:37.010 align:middle line:90%,end
<c.magenta>被用来改进</c>
<c.magenta>目前Swift已存在的API的</c>

00:19:37.744 --> 00:19:39.446 align:middle line:90%,end
<c.magenta>特别是我想谈谈我们如何应用它们</c>

00:19:39.513 --> 00:19:40.781 align:middle line:90%,end
<c.magenta>到键值观察上</c>

00:19:42.349 --> 00:19:45.619 align:middle line:90%,end
<c.magenta>你们大概知道</c>
<c.magenta>KVO是Cocoa允许对象</c>

00:19:45.686 --> 00:19:49.022 align:middle line:90%,end
<c.magenta>建立状态变化通知关系的方式</c>

00:19:49.590 --> 00:19:52.292 align:middle line:90%,end
<c.magenta>如果你已经试着</c>
<c.magenta>用过目前Swift中的KVO</c>

00:19:52.359 --> 00:19:56.063 align:middle line:90%,end
<c.magenta>你大概知道它有点偏离预期了</c>

00:19:58.799 --> 00:20:00.868 align:middle line:90%,end
<c.magenta>假设我们有个引用</c>

00:19:58.799 --> 00:20:00.868 align:middle line:90%,end
<c.magenta>假设我们有个引用</c>

00:20:02.536 --> 00:20:04.004 align:middle line:90%,end
<c.magenta>先别鼓掌 过会儿再鼓</c>

00:20:05.572 --> 00:20:08.175 align:middle line:90%,end
<c.magenta>假设我们有个对于</c>
<c.magenta>Objective-C值的引用</c>

00:20:08.242 --> 00:20:10.410 align:middle line:90%,end
<c.magenta>从前面例子里的小孩米亚</c>

00:20:10.477 --> 00:20:13.180 align:middle line:90%,end
<c.magenta>我们关心这个孩子的年龄变化</c>

00:20:14.348 --> 00:20:18.185 align:middle line:90%,end
<c.magenta>我们认为形成一个观察</c>
<c.magenta>应该像这样简单</c>

00:20:18.252 --> 00:20:19.119 align:middle line:90%,end
<c.magenta>现在鼓掌吧</c>

00:20:25.092 --> 00:20:27.361 align:middle line:90%,end
<c.magenta>我想要说明这个形成过程的一些细节</c>

00:20:27.861 --> 00:20:31.164 align:middle line:90%,end
<c.magenta>我们要在值类型上</c>
<c.magenta>直接生成我们的observation</c>

00:20:31.431 --> 00:20:33.333 align:middle line:90%,end
<c.magenta>使用我们新的类型安全键径</c>

00:20:34.067 --> 00:20:35.302 align:middle line:90%,end
<c.magenta>我们得到的是一个类似于</c>

00:20:35.369 --> 00:20:38.505 align:middle line:90%,end
<c.magenta>我们Notification Center API的</c>
<c.magenta>observation token</c>

00:20:38.572 --> 00:20:40.941 align:middle line:90%,end
<c.magenta>这个observation token</c>
<c.magenta>做了两件事</c>

00:20:41.008 --> 00:20:44.778 align:middle line:90%,end
<c.magenta>第一 它省去了我们</c>
<c.magenta>要处理不安全裸指针的麻烦</c>

00:20:44.845 --> 00:20:47.648 align:middle line:90%,end
<c.magenta>有着独一无二识别我们</c>
<c.magenta>observation的上下文环境</c>

00:20:47.881 --> 00:20:51.785 align:middle line:90%,end
<c.magenta>我们的observation直接联系着</c>
<c.magenta>我们返回得到的observation</c>

00:20:51.985 --> 00:20:54.721 align:middle line:90%,end
<c.magenta>第二 它管理了我们observation</c>
<c.magenta>的生命周期</c>

00:20:55.022 --> 00:20:57.558 align:middle line:90%,end
<c.magenta>如果我…我不能将它设成nil…</c>

00:20:57.624 --> 00:21:00.561 align:middle line:90%,end
<c.magenta>但是如果我把它设成nil</c>
<c.magenta>observation就会毁坏</c>

00:20:57.624 --> 00:21:00.561 align:middle line:90%,end
<c.magenta>但是如果我把它设成nil</c>
<c.magenta>observation就会毁坏</c>

00:21:01.094 --> 00:21:03.430 align:middle line:90%,end
<c.magenta>这是个巨大的改进 而不是获得异常</c>

00:21:03.497 --> 00:21:06.700 align:middle line:90%,end
<c.magenta>当你忘了去除注册observation时</c>
<c.magenta>你的应用会崩溃</c>

00:21:07.968 --> 00:21:10.237 align:middle line:90%,end
<c.magenta>最后 这可能是最棒的部分</c>

00:21:10.304 --> 00:21:14.808 align:middle line:90%,end
<c.magenta>现在你可以利用终结来掌握</c>
<c.magenta>observation的反应</c>

00:21:15.108 --> 00:21:18.612 align:middle line:90%,end
<c.magenta>而不是嵌套if语句</c>
<c.magenta>来检查和比较字符串</c>

00:21:19.112 --> 00:21:22.149 align:middle line:90%,end
<c.magenta>让我们看看这个终结里面的参数</c>

00:21:23.050 --> 00:21:25.986 align:middle line:90%,end
<c.magenta>它有两个参数</c>
<c.magenta>第一个是被观察的对象本身</c>

00:21:26.153 --> 00:21:29.590 align:middle line:90%,end
<c.magenta>这个是相同的引用 米亚</c>
<c.magenta>但我们将它作为参数来提供</c>

00:21:30.357 --> 00:21:33.694 align:middle line:90%,end
<c.magenta>来帮助你避免意外创建了保持循环</c>

00:21:34.862 --> 00:21:37.631 align:middle line:90%,end
<c.magenta>第二个参数是一个change对象</c>

00:21:37.698 --> 00:21:40.868 align:middle line:90%,end
<c.magenta>这和现存的KVO API很类似</c>
<c.magenta>只不过</c>

00:21:40.934 --> 00:21:42.703 align:middle line:90%,end
<c.magenta>如果你用过 如果你熟悉那个API</c>

00:21:42.769 --> 00:21:44.571 align:middle line:90%,end
<c.magenta>你就会知道那是个松类型词典</c>

00:21:44.638 --> 00:21:46.773 align:middle line:90%,end
<c.magenta>而这里我们提供的是强类型结构体</c>

00:21:46.840 --> 00:21:49.109 align:middle line:90%,end
<c.magenta>因为键径 我们知道</c>
<c.magenta>observed是Kid 而且我们知道</c>

00:21:49.176 --> 00:21:52.212 align:middle line:90%,end
<c.magenta>因为键径 我们知道</c>
<c.magenta>变化的年龄是double类型</c>

00:21:52.479 --> 00:21:54.448 align:middle line:90%,end
<c.magenta>现在我想让这变得真实一点</c>

00:21:54.515 --> 00:21:55.582 align:middle line:90%,end
<c.magenta>我们会举个例子</c>

00:21:55.816 --> 00:21:58.552 align:middle line:90%,end
<c.magenta>假设我们有个控制器</c>
<c.magenta>检测孩子什么时候长大</c>

00:21:58.619 --> 00:22:00.287 align:middle line:90%,end
<c.magenta>叫做KindergartenController</c>

00:21:58.619 --> 00:22:00.287 align:middle line:90%,end
<c.magenta>叫做KindergartenController</c>

00:22:00.354 --> 00:22:03.223 align:middle line:90%,end
<c.magenta>它有一个键值 可观察属性</c>

00:22:03.390 --> 00:22:06.059 align:middle line:90%,end
<c.magenta>叫做representedKid</c>
<c.magenta>我们要生成一个observation</c>

00:22:06.126 --> 00:22:09.329 align:middle line:90%,end
<c.magenta>让我们添加一个var i</c>
<c.magenta>给我们的observation</c>

00:22:10.230 --> 00:22:12.099 align:middle line:90%,end
<c.magenta>接着我们现在就要生成</c>
<c.magenta>observation</c>

00:22:12.165 --> 00:22:14.434 align:middle line:90%,end
<c.magenta>给我们的控制器</c>
<c.magenta>representedKid.age</c>

00:22:14.501 --> 00:22:16.103 align:middle line:90%,end
<c.magenta>我们将其存在var i上</c>

00:22:17.037 --> 00:22:19.139 align:middle line:90%,end
<c.magenta>我们加入我们超秘密业务逻辑</c>

00:22:19.206 --> 00:22:21.441 align:middle line:90%,end
<c.magenta>如果你看着觉得是错误的</c>

00:22:21.508 --> 00:22:23.277 align:middle line:90%,end
<c.magenta>我向你们保证</c>
<c.magenta>一旦你准备好去幼儿园</c>

00:22:23.343 --> 00:22:26.280 align:middle line:90%,end
<c.magenta>你总是准备好去幼儿园</c>
<c.magenta>所以实际上是正确的</c>

00:22:27.214 --> 00:22:28.182 align:middle line:90%,end
<c.magenta>就是这样了</c>

00:22:28.448 --> 00:22:30.817 align:middle line:90%,end
<c.magenta>这就是我们控制器的整个声明过程</c>

00:22:31.818 --> 00:22:33.187 align:middle line:90%,end
<c.magenta>没有必要给一个dnit</c>

00:22:33.253 --> 00:22:35.656 align:middle line:90%,end
<c.magenta>我抛弃或者毁坏了我的</c>
<c.magenta>observation</c>

00:22:35.722 --> 00:22:38.091 align:middle line:90%,end
<c.magenta>因为它联系着observation token</c>
<c.magenta>的生命周期</c>

00:22:38.158 --> 00:22:39.626 align:middle line:90%,end
<c.magenta>当控制器消失的时候</c>

00:22:39.693 --> 00:22:43.330 align:middle line:90%,end
<c.magenta>observation token也会消失</c>
<c.magenta>在幻灯片上也合适</c>

00:22:43.830 --> 00:22:44.765 align:middle line:10%
<c.magenta>接下来让我们</c>

00:22:45.732 --> 00:22:47.601 align:middle line:10%
<c.magenta>接下来让我们创建控制器</c>

00:22:48.702 --> 00:22:50.404 align:middle line:10%
<c.magenta>这里我们指向米亚</c>

00:22:50.470 --> 00:22:53.674 align:middle line:10%
<c.magenta>通过我们之前定义的函数</c>
<c.magenta>我们让米亚吹灭蜡烛</c>

00:22:53.740 --> 00:22:56.276 align:middle line:10%
<c.magenta>最终我们见识到了这些</c>
<c.magenta>新类型安全键径的能力</c>

00:22:56.343 --> 00:22:58.145 align:middle line:10%
<c.magenta>我们的小女孩长大了一岁</c>

00:23:00.480 --> 00:23:03.183 align:middle line:90%,end
<c.magenta>目前为止</c>
<c.magenta>我已经展示所有想要展示的内容</c>

00:23:03.250 --> 00:23:06.486 align:middle line:90%,end
<c.magenta>但我想绕回来再讲一次</c>
<c.magenta>字符串键径</c>

00:23:07.621 --> 00:23:09.489 align:middle line:90%,end
<c.magenta>这些会一直存在</c>

00:23:09.556 --> 00:23:12.192 align:middle line:90%,end
<c.magenta>而且它们对于过期API来说</c>
<c.magenta>仍然有用</c>

00:23:13.093 --> 00:23:14.895 align:middle line:90%,end
<c.magenta>坚持使用字符串</c>

00:23:15.963 --> 00:23:17.698 align:middle line:90%,end
<c.magenta>然而 从Swift 4开始</c>

00:23:18.999 --> 00:23:22.436 align:middle line:90%,end
<c.magenta>你可以使用这些新的高性能</c>
<c.magenta>类型安全的键径</c>

00:23:22.970 --> 00:23:24.137 align:middle line:90%,end
<c.magenta>我们将其引入到语言中</c>

00:23:24.204 --> 00:23:26.707 align:middle line:90%,end
<c.magenta>因为我们觉得它非常重要</c>

00:23:27.541 --> 00:23:30.344 align:middle line:90%,end
<c.magenta>随着时间发展</c>
<c.magenta>它们只会变得更加重要</c>

00:23:31.478 --> 00:23:33.847 align:middle line:90%,end
<c.magenta>我想请托尼回到台上来讨论下</c>

00:23:33.914 --> 00:23:36.416 align:middle line:90%,end
<c.magenta>我们今年引入到</c>
<c.magenta>Swift的另一个重要语言功能</c>

00:23:36.483 --> 00:23:37.351 align:middle line:90%,end
<c.magenta>谢谢</c>

00:23:43.156 --> 00:23:44.491 align:middle line:90%,end
<c.magenta>谢谢 迈克尔</c>

00:23:44.825 --> 00:23:47.528 align:middle line:90%,end
<c.magenta>接下来 我们要谈谈编码和解码</c>

00:23:48.762 --> 00:23:51.198 align:middle line:90%,end
<c.magenta>总的来说 编码和解码</c>

00:23:51.265 --> 00:23:55.836 align:middle line:90%,end
<c.magenta>是关于你本地和定制</c>
<c.magenta>Swift数据结构之间的转换</c>

00:23:55.903 --> 00:23:58.772 align:middle line:90%,end
<c.magenta>还有压缩的格式 特别是JSON</c>

00:23:59.606 --> 00:24:02.676 align:middle line:90%,end
<c.magenta>你们很多人都告诉我们</c>
<c.magenta>关于错误匹配的问题</c>

00:23:59.606 --> 00:24:02.676 align:middle line:90%,end
<c.magenta>你们很多人都告诉我们</c>
<c.magenta>关于错误匹配的问题</c>

00:24:02.743 --> 00:24:05.979 align:middle line:90%,end
<c.magenta>在强类型语言Swift</c>

00:24:06.046 --> 00:24:09.516 align:middle line:90%,end
<c.magenta>和弱类型压缩数据类型</c>
<c.magenta>像是JSON之间</c>

00:24:10.517 --> 00:24:12.352 align:middle line:90%,end
<c.magenta>我们相信这个挑战的答案</c>

00:24:12.419 --> 00:24:15.255 align:middle line:90%,end
<c.magenta>是由语言本身开始</c>

00:24:15.556 --> 00:24:17.724 align:middle line:90%,end
<c.magenta>还利用了编译器</c>

00:24:17.791 --> 00:24:22.763 align:middle line:90%,end
<c.magenta>标准库 还有Foundation</c>
<c.magenta>来使得与JSON交互变得简单</c>

00:24:22.829 --> 00:24:26.266 align:middle line:90%,end
<c.magenta>而且给你提供了强大定制化的机会</c>

00:24:27.167 --> 00:24:29.436 align:middle line:90%,end
<c.magenta>让我们从一个例子开始</c>

00:24:30.904 --> 00:24:33.407 align:middle line:90%,end
<c.magenta>这里有一些来自我们最喜欢的网站之一</c>
<c.magenta>GitHub的JSON</c>

00:24:33.941 --> 00:24:35.576 align:middle line:90%,end
<c.magenta>这是请求信息的结果</c>

00:24:35.642 --> 00:24:37.945 align:middle line:90%,end
<c.magenta>关于一个档案的提交</c>

00:24:38.312 --> 00:24:39.680 align:middle line:90%,end
<c.magenta>这是相当标准的JSON</c>

00:24:40.080 --> 00:24:43.116 align:middle line:90%,end
<c.magenta>这是个JSON对象或者</c>
<c.magenta>我们叫它词典</c>

00:24:43.350 --> 00:24:45.752 align:middle line:90%,end
<c.magenta>它支持一个任意数字的键值对</c>

00:24:45.819 --> 00:24:48.589 align:middle line:90%,end
<c.magenta>在这里 名称 也就是一个字符串</c>

00:24:48.655 --> 00:24:52.326 align:middle line:90%,end
<c.magenta>邮件 也是个字符串</c>
<c.magenta>日期 是个字符串</c>

00:24:52.693 --> 00:24:55.863 align:middle line:90%,end
<c.magenta>原因当然是</c>
<c.magenta>JSON没有原生日期类型</c>

00:24:56.263 --> 00:25:01.268 align:middle line:90%,end
<c.magenta>但有很多种将日期编码成</c>
<c.magenta>JSON的转换方式</c>

00:24:56.263 --> 00:25:01.268 align:middle line:90%,end
<c.magenta>但有很多种将日期编码成</c>
<c.magenta>JSON的转换方式</c>

00:25:01.335 --> 00:25:03.804 align:middle line:90%,end
<c.magenta>这个显然是ISO8601</c>

00:25:04.738 --> 00:25:07.741 align:middle line:90%,end
<c.magenta>如果我们要在Swift中</c>
<c.magenta>表示这个JSON</c>

00:25:08.008 --> 00:25:09.443 align:middle line:90%,end
<c.magenta>它会看起来非常不一样</c>

00:25:10.444 --> 00:25:14.982 align:middle line:90%,end
<c.magenta>例如 我们为它创建一个强类型</c>
<c.magenta>可能是叫编写者的结构体</c>

00:25:15.849 --> 00:25:18.218 align:middle line:90%,end
<c.magenta>这个结构体有三个属性</c>

00:25:18.285 --> 00:25:20.787 align:middle line:90%,end
<c.magenta>名称和邮件还是字符串</c>

00:25:20.854 --> 00:25:24.591 align:middle line:90%,end
<c.magenta>但日期如你所见</c>
<c.magenta>使用了Foundation的日期类型</c>

00:25:25.425 --> 00:25:26.927 align:middle line:90%,end
<c.magenta>这个原因很重要是因为</c>

00:25:26.994 --> 00:25:30.631 align:middle line:90%,end
<c.magenta>随着你与其他Cocoa SDK</c>
<c.magenta>以及API交互</c>

00:25:30.697 --> 00:25:35.469 align:middle line:90%,end
<c.magenta>你会发现日期是一种用来</c>
<c.magenta>表示时间里一点的类型</c>

00:25:36.236 --> 00:25:38.839 align:middle line:90%,end
<c.magenta>这就是我们遇到的挑战 对吧</c>

00:25:39.306 --> 00:25:43.110 align:middle line:90%,end
<c.magenta>我们如何转换顶层弱类型JSON</c>

00:25:43.343 --> 00:25:45.679 align:middle line:90%,end
<c.magenta>到底层的强类型Swift类型？</c>

00:25:46.480 --> 00:25:49.049 align:middle line:90%,end
<c.magenta>我们认为应该像这样简单</c>

00:25:49.149 --> 00:25:51.852 align:middle line:90%,end
<c.magenta>在你的结构体上采用一个协议</c>

00:25:51.919 --> 00:25:55.088 align:middle line:90%,end
<c.magenta>让编译器 标准库</c>
<c.magenta>还有Foundation</c>

00:25:55.155 --> 00:25:57.257 align:middle line:90%,end
<c.magenta>来为你做大部分的工作</c>

00:25:59.459 --> 00:26:00.327 align:middle line:90%,end
<c.magenta>谢谢</c>

00:25:59.459 --> 00:26:00.327 align:middle line:90%,end
<c.magenta>谢谢</c>

00:26:04.097 --> 00:26:06.200 align:middle line:90%,end
<c.magenta>让我们把幻灯片转到实际代码</c>

00:26:06.767 --> 00:26:08.602 align:middle line:90%,end
<c.magenta>首先我要将</c>
<c.magenta>JSON转换为一个字符串</c>

00:26:08.669 --> 00:26:12.206 align:middle line:90%,end
<c.magenta>用Swift 4中很酷的新文本句法</c>
<c.magenta>三重双引号</c>

00:26:12.439 --> 00:26:15.042 align:middle line:90%,end
<c.magenta>接着利用UTF-8编码</c>
<c.magenta>将这个字符串转换成数据</c>

00:26:15.108 --> 00:26:16.743 align:middle line:90%,end
<c.magenta>这对于JSON来说很常见</c>

00:26:16.844 --> 00:26:18.779 align:middle line:90%,end
<c.magenta>当然了 结构体编写者保持不变</c>

00:26:19.279 --> 00:26:22.249 align:middle line:10%
<c.magenta>接下来 我们创建一个解码器</c>
<c.magenta>它实际上做了</c>

00:26:22.316 --> 00:26:25.719 align:middle line:10%
<c.magenta>JSON和Swift结构间的转换</c>

00:26:27.287 --> 00:26:31.191 align:middle line:10%
<c.magenta>我们告诉解码器这个转换</c>
<c.magenta>ISO8601日期</c>

00:26:31.425 --> 00:26:33.060 align:middle line:10%
<c.magenta>我们后面再说</c>

00:26:33.493 --> 00:26:36.663 align:middle line:10%
<c.magenta>最后我们请求解码器</c>
<c.magenta>来解码一个编写者</c>

00:26:36.997 --> 00:26:39.399 align:middle line:10%
<c.magenta>结果不是任意的</c>
<c.magenta>它不是一个词典</c>

00:26:39.466 --> 00:26:42.236 align:middle line:10%
<c.magenta>你不需要检查字符串或者键值</c>

00:26:42.436 --> 00:26:45.405 align:middle line:10%
<c.magenta>它已经是这种情况下</c>
<c.magenta>你想要用的类型了</c>

00:26:46.773 --> 00:26:47.908 align:middle line:90%,end
<c.magenta>这很简单</c>

00:26:48.175 --> 00:26:50.344 align:middle line:90%,end
<c.magenta>让我们把难度提升一点</c>

00:26:50.644 --> 00:26:53.013 align:middle line:90%,end
<c.magenta>这个JSON实际上</c>
<c.magenta>是更大JSON集合的一部分</c>

00:26:53.080 --> 00:26:57.384 align:middle line:90%,end
<c.magenta>伴随着这个请求的结果</c>
<c.magenta>包括像是URL</c>

00:26:57.451 --> 00:26:59.720 align:middle line:90%,end
<c.magenta>额外的字符串和整型值</c>

00:27:00.387 --> 00:27:03.190 align:middle line:90%,end
<c.magenta>Swift中 我们照着做就可以</c>

00:27:03.357 --> 00:27:06.793 align:middle line:90%,end
<c.magenta>我要将我的结构体编写者嵌套到</c>
<c.magenta>一个叫做Commit的新结构体</c>

00:27:06.860 --> 00:27:08.028 align:middle line:90%,end
<c.magenta>也是可编码性</c>

00:27:08.595 --> 00:27:11.331 align:middle line:90%,end
<c.magenta>你会发现我可以用</c>
<c.magenta>Foundation的URL类型</c>

00:27:11.732 --> 00:27:13.066 align:middle line:90%,end
<c.magenta>还有我们的结构体编写者</c>

00:27:13.133 --> 00:27:15.402 align:middle line:90%,end
<c.magenta>你会发现我们能递归地向下降类型</c>

00:27:15.469 --> 00:27:17.804 align:middle line:90%,end
<c.magenta>如果它们也遵从可编码的规则</c>
<c.magenta>来解码它们</c>

00:27:18.539 --> 00:27:21.108 align:middle line:90%,end
<c.magenta>信息这个字符串</c>

00:27:21.175 --> 00:27:22.643 align:middle line:90%,end
<c.magenta>还有我们的</c>
<c.magenta>comment_count属性</c>

00:27:23.310 --> 00:27:26.146 align:middle line:90%,end
<c.magenta>要解码这个 只需要一行代码</c>

00:27:26.213 --> 00:27:27.881 align:middle line:90%,end
<c.magenta>这次我们要解码一个提交</c>

00:27:28.215 --> 00:27:31.351 align:middle line:10%
<c.magenta>结果是：我们的强Swift类型</c>
<c.magenta>让我们使用</c>

00:27:31.418 --> 00:27:33.787 align:middle line:10%
<c.magenta>我们知道并且喜欢的</c>
<c.magenta>Swift语言功能</c>

00:27:33.854 --> 00:27:36.356 align:middle line:10%
<c.magenta>来从压缩数据中得到我们想要的值</c>

00:27:36.423 --> 00:27:38.358 align:middle line:10%
<c.magenta>在这里 就是属性访问</c>

00:27:39.893 --> 00:27:41.161 align:middle line:10%
<c.magenta>让我们看看发生了什么</c>

00:27:41.595 --> 00:27:45.132 align:middle line:90%,end
<c.magenta>首先 可编码协议</c>
<c.magenta>实际上不是一个协议 是两个</c>

00:27:45.599 --> 00:27:49.903 align:middle line:90%,end
<c.magenta>第一个叫作Encodable</c>
<c.magenta>有一个函数encode to encoder</c>

00:27:50.637 --> 00:27:54.942 align:middle line:90%,end
<c.magenta>这个函数的目的是</c>
<c.magenta>允许类型告诉编码器</c>

00:27:55.008 --> 00:27:56.510 align:middle line:90%,end
<c.magenta>它需要的所有信息</c>

00:27:56.577 --> 00:27:58.645 align:middle line:90%,end
<c.magenta>以便接下来可以重建自己</c>

00:27:59.546 --> 00:28:03.050 align:middle line:10%
<c.magenta>相应的协议 可解码性</c>
<c.magenta>有一个初始化</c>

00:27:59.546 --> 00:28:03.050 align:middle line:10%
<c.magenta>相应的协议 可解码性</c>
<c.magenta>有一个初始化</c>

00:28:03.684 --> 00:28:07.187 align:middle line:10%
<c.magenta>初始化的目的是</c>
<c.magenta>允许类型来获得其所需要的值</c>

00:28:07.254 --> 00:28:09.756 align:middle line:10%
<c.magenta>从解码器中 接着使用这些值</c>

00:28:09.823 --> 00:28:14.228 align:middle line:10%
<c.magenta>来创建一个可供随时使用的</c>
<c.magenta>其自身完全初始化的实例</c>

00:28:16.496 --> 00:28:18.599 align:middle line:90%,end
<c.magenta>这些API的主要设计点</c>

00:28:18.665 --> 00:28:22.336 align:middle line:90%,end
<c.magenta>是使用你可能已经熟悉的</c>
<c.magenta>Swift行为</c>

00:28:22.402 --> 00:28:24.538 align:middle line:90%,end
<c.magenta>这叫作协议扩展</c>

00:28:24.771 --> 00:28:31.144 align:middle line:90%,end
<c.magenta>Swift中 协议不仅可定义接口</c>
<c.magenta>还可以藉由扩展</c>

00:28:31.211 --> 00:28:34.882 align:middle line:90%,end
<c.magenta>它们可以为该接口</c>
<c.magenta>提供一个默认的实现</c>

00:28:35.983 --> 00:28:38.886 align:middle line:90%,end
<c.magenta>它们让你给两者之一写你自己的实现</c>

00:28:38.952 --> 00:28:41.955 align:middle line:90%,end
<c.magenta>或者给整个协议来定制行为</c>

00:28:42.656 --> 00:28:45.225 align:middle line:90%,end
<c.magenta>让我们回到提交看看这是如何运作的</c>

00:28:46.126 --> 00:28:47.861 align:middle line:90%,end
<c.magenta>当我采用可编码的协议时</c>

00:28:47.928 --> 00:28:51.665 align:middle line:90%,end
<c.magenta>编译器会生成encode to encoder</c>
<c.magenta>的一个实现</c>

00:28:51.732 --> 00:28:54.368 align:middle line:90%,end
<c.magenta>还有init from decoder完全免费</c>

00:28:55.202 --> 00:28:57.571 align:middle line:90%,end
<c.magenta>在这种情况下</c>
<c.magenta>我不需要定制关于它们的任何东西</c>

00:28:57.638 --> 00:29:00.574 align:middle line:90%,end
<c.magenta>因此我可以从类型中完全移除它们</c>

00:28:57.638 --> 00:29:00.574 align:middle line:90%,end
<c.magenta>因此我可以从类型中完全移除它们</c>

00:29:01.775 --> 00:29:04.178 align:middle line:90%,end
<c.magenta>不过有一个是我想要定制的</c>

00:29:04.244 --> 00:29:06.480 align:middle line:90%,end
<c.magenta>就是这个属性的名字</c>

00:29:06.813 --> 00:29:09.149 align:middle line:90%,end
<c.magenta>你可以注意到它使用了蛇型连字符</c>

00:29:09.216 --> 00:29:10.717 align:middle line:90%,end
<c.magenta>这在JSON中很常见</c>

00:29:10.784 --> 00:29:13.153 align:middle line:90%,end
<c.magenta>但是这不符合Swift的命名规范</c>

00:29:13.587 --> 00:29:15.622 align:middle line:90%,end
<c.magenta>让我给你们展示下如何修复这个问题</c>

00:29:15.822 --> 00:29:18.725 align:middle line:90%,end
<c.magenta>首先 编译器还为我们</c>
<c.magenta>生成了一个东西</c>

00:29:18.792 --> 00:29:21.662 align:middle line:90%,end
<c.magenta>就是这个叫CodingKeys</c>
<c.magenta>的私有枚举</c>

00:29:23.363 --> 00:29:27.100 align:middle line:90%,end
<c.magenta>这个枚举由字符串组成</c>
<c.magenta>采用了CodingKey协议</c>

00:29:27.167 --> 00:29:29.102 align:middle line:90%,end
<c.magenta>同样我们稍后再讲</c>

00:29:29.236 --> 00:29:33.040 align:middle line:90%,end
<c.magenta>有趣的是这个枚举</c>
<c.magenta>有四个case语句</c>

00:29:33.106 --> 00:29:35.709 align:middle line:90%,end
<c.magenta>匹配我的四个属性的名字</c>

00:29:36.243 --> 00:29:39.146 align:middle line:90%,end
<c.magenta>为了定制我的属性的名字</c>

00:29:39.213 --> 00:29:41.615 align:middle line:90%,end
<c.magenta>我只需要定制case语句的名字</c>

00:29:42.015 --> 00:29:43.083 align:middle line:90%,end
<c.magenta>为了实现这个</c>

00:29:43.150 --> 00:29:47.387 align:middle line:90%,end
<c.magenta>我要将这个comment_count</c>
<c.magenta>从蛇型换成骆驼型</c>

00:29:47.888 --> 00:29:52.492 align:middle line:90%,end
<c.magenta>但是如你所见</c>
<c.magenta>我仍然对所读的JSON是兼容的</c>

00:29:52.559 --> 00:29:54.494 align:middle line:90%,end
<c.magenta>通过将该case的字符串值设置成</c>

00:29:54.561 --> 00:29:57.631 align:middle line:90%,end
<c.magenta>我们预期在压缩数据中找到的值</c>

00:29:58.232 --> 00:30:03.003 align:middle line:90%,end
<c.magenta>如果这就是我们需要做的所有定制</c>
<c.magenta>那么就完成了</c>

00:29:58.232 --> 00:30:03.003 align:middle line:90%,end
<c.magenta>如果这就是我们需要做的所有定制</c>
<c.magenta>那么就完成了</c>

00:30:04.037 --> 00:30:08.408 align:middle line:90%,end
<c.magenta>你可以不再看了并且离开</c>
<c.magenta>但是在这个会议的结尾</c>

00:30:08.475 --> 00:30:10.210 align:middle line:90%,end
<c.magenta>我想给你们展示下我们能如何完成</c>

00:30:10.277 --> 00:30:12.779 align:middle line:90%,end
<c.magenta>对于这个提交的更多定制</c>

00:30:13.380 --> 00:30:15.682 align:middle line:90%,end
<c.magenta>现在我想把舞台交给同事毅太</c>

00:30:15.749 --> 00:30:17.784 align:middle line:90%,end
<c.magenta>来给我们实际演示一下这个东西</c>

00:30:28.028 --> 00:30:28.862 align:middle line:90%,end
<c.magenta>谢谢 托尼</c>

00:30:29.630 --> 00:30:33.567 align:middle line:90%,end
<c.magenta>托尼给你们展示了在你的类型中</c>
<c.magenta>采用可编码性是多么简单</c>

00:30:33.634 --> 00:30:35.669 align:middle line:90%,end
<c.magenta>不过让我们看看这会是什么样子</c>

00:30:35.736 --> 00:30:37.271 align:middle line:90%,end
<c.magenta>在许多你们的实践应用中</c>

00:30:38.438 --> 00:30:41.074 align:middle line:90%,end
<c.magenta>我这里有最近一直在做原型的小应用</c>

00:30:41.175 --> 00:30:42.776 align:middle line:90%,end
<c.magenta>因为我是Swift的大粉丝</c>

00:30:42.843 --> 00:30:44.745 align:middle line:90%,end
<c.magenta>我想要看有趣的git提交</c>

00:30:44.811 --> 00:30:46.780 align:middle line:90%,end
<c.magenta>出现在Swift的GitHub repo</c>

00:30:47.648 --> 00:30:51.518 align:middle line:90%,end
<c.magenta>这里我写了个小应用</c>
<c.magenta>与GitHub的JSON REST API交互</c>

00:30:51.585 --> 00:30:54.254 align:middle line:90%,end
<c.magenta>来解析这些提交</c>
<c.magenta>并通过一个表格视图来展示给我</c>

00:30:54.855 --> 00:30:57.758 align:middle line:90%,end
<c.magenta>让我们快看看把这个应用写完</c>
<c.magenta>是多么容易</c>

00:30:57.824 --> 00:30:59.326 align:middle line:90%,end
<c.magenta>使用新的可编码性API</c>

00:31:01.228 --> 00:31:03.463 align:middle line:90%,end
<c.magenta>如果我们切换到Xcode</c>
<c.magenta>你会注意到一些相同的模型</c>

00:31:03.530 --> 00:31:06.567 align:middle line:90%,end
<c.magenta>托尼在幻灯片上扩展了一点</c>

00:31:07.134 --> 00:31:10.337 align:middle line:90%,end
<c.magenta>我们有相同的提交信息 编写者信息</c>

00:31:10.871 --> 00:31:13.006 align:middle line:90%,end
<c.magenta>我们也做了同样的重命名</c>

00:31:13.774 --> 00:31:16.243 align:middle line:90%,end
<c.magenta>右侧是GitHub所提供的</c>
<c.magenta>JSON信息</c>

00:31:16.310 --> 00:31:18.545 align:middle line:90%,end
<c.magenta>不过有些不相关的部分被剪切掉了</c>

00:31:18.612 --> 00:31:20.314 align:middle line:10%
<c.magenta>如果你注意看右下角</c>

00:31:20.380 --> 00:31:23.884 align:middle line:10%
<c.magenta>在JSON代码中</c>
<c.magenta>有些是我们目前没有解码的信息</c>

00:31:24.451 --> 00:31:26.553 align:middle line:10%
<c.magenta>这没问题的 因为它会默认被忽略掉</c>

00:31:26.620 --> 00:31:28.222 align:middle line:10%
<c.magenta>我们接下来再处理它</c>

00:31:28.689 --> 00:31:31.959 align:middle line:90%,end
<c.magenta>让我们隐藏掉这个JSON代码</c>
<c.magenta>再深入看下我们的文件</c>

00:31:32.025 --> 00:31:34.127 align:middle line:90%,end
<c.magenta>来看看我们如何实际使用这些模型</c>

00:31:34.661 --> 00:31:37.197 align:middle line:90%,end
<c.magenta>这里我们有</c>
<c.magenta>CommitsViewController</c>

00:31:37.264 --> 00:31:41.001 align:middle line:90%,end
<c.magenta>这个是实际显示这些提交的</c>
<c.magenta>视图控制器在我们的表格视图中</c>

00:31:41.335 --> 00:31:43.871 align:middle line:90%,end
<c.magenta>这个视图控制器有我们的表格视图</c>

00:31:43.937 --> 00:31:45.572 align:middle line:90%,end
<c.magenta>还有这些提交的数组</c>

00:31:45.873 --> 00:31:49.176 align:middle line:90%,end
<c.magenta>注意这里是我们类型的一个数组</c>

00:31:49.409 --> 00:31:51.545 align:middle line:90%,end
<c.magenta>不是任何其他或者类似的数组</c>

00:31:53.013 --> 00:31:55.482 align:middle line:90%,end
<c.magenta>当我们要显示这个数据时</c>

00:31:55.549 --> 00:31:58.852 align:middle line:90%,end
<c.magenta>我们可以从GitHub获取数据</c>
<c.magenta>接着利用JSON解码器</c>

00:31:58.919 --> 00:32:00.320 align:middle line:90%,end
<c.magenta>就像托尼向你们演示的那样</c>

00:31:58.919 --> 00:32:00.320 align:middle line:90%,end
<c.magenta>就像托尼向你们演示的那样</c>

00:32:00.420 --> 00:32:03.924 align:middle line:90%,end
<c.magenta>我们可以请求将这些提交的数组</c>
<c.magenta>解码成我们的类型</c>

00:32:05.158 --> 00:32:08.462 align:middle line:10%
<c.magenta>一旦完成 我们可以重新加载</c>
<c.magenta>表格视图并显示它</c>

00:32:09.663 --> 00:32:12.566 align:middle line:10%
<c.magenta>如果出问题了 我们可以捕捉错误</c>

00:32:12.633 --> 00:32:14.735 align:middle line:10%
<c.magenta>并且显示一些本地信息给用户</c>

00:32:14.801 --> 00:32:16.870 align:middle line:10%
<c.magenta>高层面地告诉他们哪里出错了</c>

00:32:17.838 --> 00:32:19.706 align:middle line:10%
<c.magenta>这就是你如何将数据载入你的应用</c>

00:32:19.773 --> 00:32:21.942 align:middle line:10%
<c.magenta>让我们看看</c>
<c.magenta>它是怎么和我们的UI相关联的</c>

00:32:22.176 --> 00:32:24.144 align:middle line:10%
<c.magenta>往下一点看文件</c>

00:32:24.211 --> 00:32:26.847 align:middle line:10%
<c.magenta>我有一个辅助函数</c>
<c.magenta>来让我设置表格视图的单元格</c>

00:32:26.914 --> 00:32:29.049 align:middle line:10%
<c.magenta>在它们显示给用户之前</c>

00:32:29.116 --> 00:32:31.718 align:middle line:10%
<c.magenta>这里要设置我的定制表格视图单元格</c>

00:32:31.785 --> 00:32:34.454 align:middle line:10%
<c.magenta>我要从提交数组中抓取出一条提交</c>

00:32:34.688 --> 00:32:38.025 align:middle line:10%
<c.magenta>接着使用该条提交的强类型属性</c>

00:32:38.091 --> 00:32:39.560 align:middle line:10%
<c.magenta>我们就可以将其连接到UI</c>

00:32:39.660 --> 00:32:41.895 align:middle line:10%
<c.magenta>再次注意我们没有向下转换任何</c>

00:32:41.962 --> 00:32:44.131 align:middle line:10%
<c.magenta>而且没有通过数组或者词典配对</c>

00:32:44.198 --> 00:32:47.134 align:middle line:10%
<c.magenta>这就是我们写类型的方式</c>
<c.magenta>还有我们想要如何使用它</c>

00:32:48.669 --> 00:32:50.737 align:middle line:90%,end
<c.magenta>这都挺不错的</c>
<c.magenta>不过让我们回到我们的应用</c>

00:32:50.804 --> 00:32:53.607 align:middle line:90%,end
<c.magenta>你看这里就会发现</c>
<c.magenta>UI这里有一些空间</c>

00:32:53.674 --> 00:32:57.144 align:middle line:90%,end
<c.magenta>我留下来连接给</c>
<c.magenta>每个提交所对应的哈希值的</c>

00:32:57.211 --> 00:32:59.880 align:middle line:90%,end
<c.magenta>但它还没被连接上</c>
<c.magenta>让我们现在完成它</c>

00:33:02.049 --> 00:33:05.452 align:middle line:90%,end
<c.magenta>如果我们回到模型</c>
<c.magenta>重新打开JSON代码</c>

00:33:05.552 --> 00:33:10.023 align:middle line:90%,end
<c.magenta>我们会发现在JSON代码中</c>
<c.magenta>有个哈希属性</c>

00:33:10.090 --> 00:33:11.592 align:middle line:90%,end
<c.magenta>我们一直没有请求</c>

00:33:11.758 --> 00:33:13.660 align:middle line:90%,end
<c.magenta>让我们把它加到我们的类型里</c>

00:33:13.927 --> 00:33:17.497 align:middle line:90%,end
<c.magenta>接着 如果我构建项目来使用它</c>

00:33:17.564 --> 00:33:20.000 align:middle line:90%,end
<c.magenta>你会发现我得到一个构建失败</c>

00:33:20.234 --> 00:33:22.002 align:middle line:90%,end
<c.magenta>让我们看看为什么会这样</c>

00:33:23.203 --> 00:33:26.607 align:middle line:90%,end
<c.magenta>作为这个类型的一部分</c>
<c.magenta>我已创建了一个定制CodingKeys枚举</c>

00:33:26.807 --> 00:33:29.209 align:middle line:90%,end
<c.magenta>这个你放进类型里的</c>
<c.magenta>CodingKeys枚举</c>

00:33:29.276 --> 00:33:32.646 align:middle line:90%,end
<c.magenta>是用来控制编译器生成的强大工具</c>

00:33:32.713 --> 00:33:35.516 align:middle line:90%,end
<c.magenta>作为NNCode 2初始的一部分</c>

00:33:35.949 --> 00:33:38.118 align:middle line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我提供了一个CodingKeys枚举</c>

00:33:38.185 --> 00:33:42.623 align:middle line:90%,end
<c.magenta>来将我的提交信息属性重命名</c>
<c.magenta>以匹配JSON里的内容</c>

00:33:43.023 --> 00:33:45.659 align:middle line:90%,end
<c.magenta>但这里 我刚添加的哈希属性</c>

00:33:45.726 --> 00:33:47.194 align:middle line:90%,end
<c.magenta>在CodingKeys中找不到</c>

00:33:47.794 --> 00:33:49.596 align:middle line:90%,end
<c.magenta>编译器会试着做的是</c>

00:33:49.663 --> 00:33:52.966 align:middle line:90%,end
<c.magenta>如果你故意落下一个属性</c>
<c.magenta>没有写入CodingKeys枚举</c>

00:33:53.033 --> 00:33:57.037 align:middle line:90%,end
<c.magenta>它就会从编码和解码显示中移除出去</c>

00:33:57.237 --> 00:33:58.238 align:middle line:90%,end
<c.magenta>这里发生的是</c>

00:33:58.305 --> 00:34:01.842 align:middle line:90%,end
<c.magenta>因为这个哈希属性没有一个默认值</c>

00:33:58.305 --> 00:34:01.842 align:middle line:90%,end
<c.magenta>因为这个哈希属性没有一个默认值</c>

00:34:01.909 --> 00:34:05.279 align:middle line:90%,end
<c.magenta>如果编译器试图给我们生成</c>
<c.magenta>一个初始化</c>

00:34:05.345 --> 00:34:08.348 align:middle line:90%,end
<c.magenta>就不会有合理的值初始化给这个属性</c>

00:34:08.415 --> 00:34:11.051 align:middle line:90%,end
<c.magenta>因此编译器拒绝这么做</c>
<c.magenta>那么我们就会得到构建失败</c>

00:34:11.118 --> 00:34:14.021 align:middle line:90%,end
<c.magenta>因为我们的类型实际上</c>
<c.magenta>没有遵从可解码性</c>

00:34:14.721 --> 00:34:16.590 align:middle line:90%,end
<c.magenta>在这个例子中 我们实际上不想让</c>

00:34:16.657 --> 00:34:18.992 align:middle line:90%,end
<c.magenta>这个哈希属性</c>
<c.magenta>从我们的编码表示中落下</c>

00:34:19.059 --> 00:34:20.127 align:middle line:90%,end
<c.magenta>我们想要解码它</c>

00:34:20.226 --> 00:34:22.496 align:middle line:90%,end
<c.magenta>让我们镜像这个相同的属性</c>

00:34:22.629 --> 00:34:23.931 align:middle line:90%,end
<c.magenta>在我们的CodingKeys枚举中</c>

00:34:24.931 --> 00:34:27.801 align:middle line:90%,end
<c.magenta>让我们再次隐藏JSON代码</c>
<c.magenta>去连接这个属性</c>

00:34:27.868 --> 00:34:29.101 align:middle line:10%
<c.magenta>直接到我们的UI上</c>

00:34:29.436 --> 00:34:31.938 align:middle line:10%
<c.magenta>在这个单元格设置方法中</c>

00:34:32.005 --> 00:34:35.175 align:middle line:10%
<c.magenta>我们要加入另一行代码来抓取哈希值</c>

00:34:35.242 --> 00:34:38.212 align:middle line:10%
<c.magenta>我们将要把它变短一点</c>
<c.magenta>让它更加适合我们的UI</c>

00:34:38.277 --> 00:34:40.746 align:middle line:10%
<c.magenta>就像使用任何东西一样</c>
<c.magenta>使用强类型属性</c>

00:34:40.813 --> 00:34:42.616 align:middle line:10%
<c.magenta>我们可以将其直接连接到我们的UI</c>

00:34:43.016 --> 00:34:44.518 align:middle line:10%
<c.magenta>让我们回到我们的应用</c>

00:34:44.585 --> 00:34:47.387 align:middle line:10%
<c.magenta>看一下确保所有东西都连接正确了</c>

00:34:49.723 --> 00:34:51.757 align:middle line:90%,end
<c.magenta>这里我们已经重新运行了</c>

00:34:51.824 --> 00:34:54.161 align:middle line:90%,end
<c.magenta>我们可以看到所有东西</c>
<c.magenta>都连接到了我们的UI</c>

00:34:54.228 --> 00:34:57.130 align:middle line:90%,end
<c.magenta>我很高兴 因为这只用了四行代码</c>

00:34:57.197 --> 00:34:58.131 align:middle line:90%,end
<c.magenta>加到我们的应用中</c>

00:35:02.069 --> 00:35:02.903 align:middle line:90%,end
<c.magenta>谢谢</c>

00:35:06.473 --> 00:35:08.208 align:middle line:90%,end
<c.magenta>现在暂时回到代码中</c>

00:35:08.275 --> 00:35:11.912 align:middle line:90%,end
<c.magenta>让我们看看当应用出错时</c>
<c.magenta>我们都能干些什么</c>

00:35:13.013 --> 00:35:15.382 align:middle line:90%,end
<c.magenta>如果我们再一次打开JSON代码</c>

00:35:15.449 --> 00:35:16.917 align:middle line:90%,end
<c.magenta>你可能会注意到在右下角</c>

00:35:16.984 --> 00:35:19.386 align:middle line:90%,end
<c.magenta>我们还有最后一个</c>
<c.magenta>一直没有解码的属性</c>

00:35:19.453 --> 00:35:21.221 align:middle line:90%,end
<c.magenta>让我们现在完成它</c>

00:35:22.055 --> 00:35:24.658 align:middle line:90%,end
<c.magenta>我们要把URL属性加入到</c>
<c.magenta>我们的类型中</c>

00:35:24.725 --> 00:35:27.227 align:middle line:90%,end
<c.magenta>并且在CodingKeys枚举中</c>
<c.magenta>镜像它</c>

00:35:28.161 --> 00:35:31.231 align:middle line:90%,end
<c.magenta>这次让我们给CodingKey</c>
<c.magenta>一个值</c>

00:35:31.298 --> 00:35:34.368 align:middle line:90%,end
<c.magenta>明显在我们的JSON中是找不到的</c>

00:35:35.202 --> 00:35:37.738 align:middle line:90%,end
<c.magenta>当我们试图解码这个值的时候</c>

00:35:37.804 --> 00:35:41.341 align:middle line:90%,end
<c.magenta>它不会被找到</c>
<c.magenta>因此这会在解码时候变成一个错误</c>

00:35:42.109 --> 00:35:45.179 align:middle line:90%,end
<c.magenta>看看我们如何解决这个错误</c>
<c.magenta>让我们再把JSON代码隐藏起来</c>

00:35:45.245 --> 00:35:47.314 align:middle line:90%,end
<c.magenta>往下找到我们实现解码的地方</c>

00:35:48.615 --> 00:35:50.083 align:middle line:90%,end
<c.magenta>为了解决这个错误</c>

00:35:50.217 --> 00:35:53.620 align:middle line:90%,end
<c.magenta>我们可以捕捉一个解码错误</c>
<c.magenta>keyNotFound错误</c>

00:35:53.687 --> 00:35:56.823 align:middle line:90%,end
<c.magenta>这表明了我们试图访问</c>
<c.magenta>该键的某些内容</c>

00:35:56.890 --> 00:35:58.926 align:middle line:90%,end
<c.magenta>但它不能在加载内容的</c>
<c.magenta>任何地方被找到</c>

00:35:59.459 --> 00:36:01.595 align:middle line:90%,end
<c.magenta>除了这个</c>
<c.magenta>我们获得了一些上下文环境信息</c>

00:35:59.459 --> 00:36:01.595 align:middle line:90%,end
<c.magenta>除了这个</c>
<c.magenta>我们获得了一些上下文环境信息</c>

00:36:01.662 --> 00:36:03.163 align:middle line:90%,end
<c.magenta>关于什么以及哪里出了错</c>

00:36:03.697 --> 00:36:07.134 align:middle line:90%,end
<c.magenta>让我们在这设置一个断点</c>
<c.magenta>带着这个有错的键运行应用</c>

00:36:07.201 --> 00:36:09.336 align:middle line:90%,end
<c.magenta>看一下以确保我们可以捕捉到</c>
<c.magenta>这个错误</c>

00:36:09.403 --> 00:36:10.571 align:middle line:90%,end
<c.magenta>并且我们到达了断点</c>

00:36:11.805 --> 00:36:13.340 align:middle line:90%,end
<c.magenta>现在我们运行了这个应用</c>

00:36:13.407 --> 00:36:15.409 align:middle line:90%,end
<c.magenta>你会注意到我们确实到达了那个断点</c>

00:36:15.475 --> 00:36:18.278 align:middle line:90%,end
<c.magenta>如果我们打印这个键</c>
<c.magenta>你可以看到事实上</c>

00:36:18.345 --> 00:36:20.681 align:middle line:90%,end
<c.magenta>我们给了一个有错误数值的URL键</c>

00:36:20.747 --> 00:36:22.716 align:middle line:90%,end
<c.magenta>事实上 它在加载内容里找不到</c>

00:36:22.783 --> 00:36:24.051 align:middle line:90%,end
<c.magenta>因此我们得到了这个错误</c>

00:36:25.052 --> 00:36:26.820 align:middle line:90%,end
<c.magenta>这里我们如果看上下文环境信息</c>

00:36:26.887 --> 00:36:30.390 align:middle line:90%,end
<c.magenta>你可以看到两个有用的功能</c>
<c.magenta>来帮助你解决发生的问题</c>

00:36:31.091 --> 00:36:33.493 align:middle line:90%,end
<c.magenta>首先是一条排除故障描述</c>
<c.magenta>给作为开发者的你</c>

00:36:33.560 --> 00:36:36.930 align:middle line:90%,end
<c.magenta>来看看哪里出了问题 还有代码路径</c>

00:36:36.997 --> 00:36:40.367 align:middle line:90%,end
<c.magenta>其描述了在加载内容时哪里出了问题</c>
<c.magenta>导致这个地方出错</c>

00:36:41.602 --> 00:36:43.604 align:middle line:90%,end
<c.magenta>这些都很棒 不过事实上</c>

00:36:43.670 --> 00:36:47.040 align:middle line:90%,end
<c.magenta>如果我不是很关心URL</c>

00:36:47.107 --> 00:36:48.242 align:middle line:90%,end
<c.magenta>而且我可能不需要它</c>

00:36:48.308 --> 00:36:51.044 align:middle line:90%,end
<c.magenta>那么解决这个错误的一个方法</c>
<c.magenta>就是让你的URL变为可选</c>

00:36:52.312 --> 00:36:54.414 align:middle line:90%,end
<c.magenta>当你默认将这个属性设为可选时</c>

00:36:54.481 --> 00:36:56.583 align:middle line:90%,end
<c.magenta>如果键或值没有被找到</c>

00:36:56.650 --> 00:36:59.386 align:middle line:90%,end
<c.magenta>它会被初始化设为nil</c>

00:36:59.753 --> 00:37:01.788 align:middle line:90%,end
<c.magenta>让我们隐藏我们的UI</c>
<c.magenta>重新运行应用</c>

00:36:59.753 --> 00:37:01.788 align:middle line:90%,end
<c.magenta>让我们隐藏我们的UI</c>
<c.magenta>重新运行应用</c>

00:37:01.855 --> 00:37:03.857 align:middle line:90%,end
<c.magenta>来看看我们是不是还会达到断点</c>

00:37:05.058 --> 00:37:07.594 align:middle line:90%,end
<c.magenta>当我们重新运行时</c>
<c.magenta>我们不会再达到断点</c>

00:37:07.661 --> 00:37:10.864 align:middle line:90%,end
<c.magenta>因为该值被默认设成了nil</c>
<c.magenta>这是个不错的习惯</c>

00:37:11.865 --> 00:37:13.600 align:middle line:90%,end
<c.magenta>让我们回到代码并看一下</c>

00:37:13.667 --> 00:37:16.303 align:middle line:90%,end
<c.magenta>我们还可以捕捉哪些有用的错误</c>

00:37:17.137 --> 00:37:20.807 align:middle line:90%,end
<c.magenta>另一个错误像是</c>
<c.magenta>DecodingError.valueNotFound</c>

00:37:20.874 --> 00:37:23.844 align:middle line:90%,end
<c.magenta>其表明了我们试图解码</c>
<c.magenta>该类型的某些东西</c>

00:37:23.911 --> 00:37:25.145 align:middle line:90%,end
<c.magenta>但是实际上找到了nil</c>

00:37:25.979 --> 00:37:28.715 align:middle line:90%,end
<c.magenta>你还得到了相同的上下文环境信息</c>

00:37:28.782 --> 00:37:30.651 align:middle line:90%,end
<c.magenta>来告诉你什么以及哪里出了错</c>

00:37:32.386 --> 00:37:35.022 align:middle line:90%,end
<c.magenta>同时 你或许想捕捉类型不匹配</c>

00:37:35.255 --> 00:37:38.125 align:middle line:90%,end
<c.magenta>表明了你试图解码该类型的某些东西</c>

00:37:38.192 --> 00:37:40.160 align:middle line:90%,end
<c.magenta>但是在加载内容里找到的是别的类型</c>

00:37:40.227 --> 00:37:43.797 align:middle line:90%,end
<c.magenta>比如说 你试图解码一个字符串</c>
<c.magenta>而找到的是一个数字</c>

00:37:44.031 --> 00:37:47.100 align:middle line:90%,end
<c.magenta>同样 你会跟前面一样</c>
<c.magenta>得到相同的上下文环境信息</c>

00:37:48.101 --> 00:37:50.737 align:middle line:90%,end
<c.magenta>当你想排除故障时 这些错误很有用</c>

00:37:50.804 --> 00:37:53.073 align:middle line:90%,end
<c.magenta>当某些东西出错时 不过通常情况下</c>

00:37:53.140 --> 00:37:56.043 align:middle line:90%,end
<c.magenta>你不会想要在最高级别</c>
<c.magenta>就捕捉这些错误</c>

00:37:56.109 --> 00:37:57.744 align:middle line:90%,end
<c.magenta>取而代之 你只想要捕捉通用错误</c>

00:37:57.811 --> 00:38:00.247 align:middle line:90%,end
<c.magenta>并显示一些本地的信息</c>
<c.magenta>给用户以便他们可以想出</c>

00:37:57.811 --> 00:38:00.247 align:middle line:90%,end
<c.magenta>并显示一些本地的信息</c>
<c.magenta>给用户以便他们可以想出</c>

00:38:00.314 --> 00:38:02.316 align:middle line:90%,end
<c.magenta>什么出错了或者报告这个漏洞</c>

00:38:03.450 --> 00:38:05.552 align:middle line:90%,end
<c.magenta>这些实际上是非常强大的工具</c>

00:38:05.619 --> 00:38:07.187 align:middle line:90%,end
<c.magenta>来实现一些更高级的事情</c>

00:38:07.487 --> 00:38:10.057 align:middle line:90%,end
<c.magenta>如果你定制你的init from</c>
<c.magenta>或者encode to</c>

00:38:10.123 --> 00:38:13.160 align:middle line:90%,end
<c.magenta>你可以捕捉类型里的这些错误</c>
<c.magenta>来实现强大的功能</c>

00:38:13.227 --> 00:38:17.064 align:middle line:90%,end
<c.magenta>像是数据迁移 重命名属性等等</c>

00:38:17.331 --> 00:38:19.099 align:middle line:90%,end
<c.magenta>但在我们的应用中</c>
<c.magenta>其实无需这么做</c>

00:38:19.166 --> 00:38:21.568 align:middle line:90%,end
<c.magenta>因为我已经通过少量代码</c>
<c.magenta>得到了我想要的功能</c>

00:38:22.002 --> 00:38:24.438 align:middle line:90%,end
<c.magenta>我要将舞台交还给托尼</c>
<c.magenta>让他来谈谈</c>

00:38:24.505 --> 00:38:27.975 align:middle line:90%,end
<c.magenta>一些更高级的编码和解码主题 谢谢</c>

00:38:33.313 --> 00:38:34.147 align:middle line:90%,end
<c.magenta>谢谢 毅太</c>

00:38:35.682 --> 00:38:40.254 align:middle line:90%,end
<c.magenta>让我们继续谈谈一些更高级的主题吧</c>

00:38:40.320 --> 00:38:41.788 align:middle line:90%,end
<c.magenta>关于编码和解码的</c>

00:38:41.855 --> 00:38:44.324 align:middle line:90%,end
<c.magenta>我们要谈谈我称之为三个支柱的</c>

00:38:44.391 --> 00:38:46.493 align:middle line:90%,end
<c.magenta>可编码性API设计哲学</c>

00:38:46.827 --> 00:38:50.230 align:middle line:90%,end
<c.magenta>首先是我们真的想要内置错误解决</c>

00:38:50.297 --> 00:38:51.598 align:middle line:90%,end
<c.magenta>像是你在演示中所看到的</c>

00:38:52.566 --> 00:38:54.501 align:middle line:90%,end
<c.magenta>当你在处理压缩数据的时候</c>

00:38:54.568 --> 00:38:59.039 align:middle line:90%,end
<c.magenta>处理未预见的输入不是如果的问题</c>
<c.magenta>而是什么时候的问题</c>

00:38:59.773 --> 00:39:02.976 align:middle line:90%,end
<c.magenta>这可能是数据侵蚀</c>
<c.magenta>可能是未预见的API变化</c>

00:38:59.773 --> 00:39:02.976 align:middle line:90%,end
<c.magenta>这可能是数据侵蚀</c>
<c.magenta>可能是未预见的API变化</c>

00:39:03.043 --> 00:39:06.914 align:middle line:90%,end
<c.magenta>来自你接收数据的地方</c>
<c.magenta>或者甚至是恶意的输入</c>

00:39:06.980 --> 00:39:09.650 align:middle line:90%,end
<c.magenta>有些人试图探查到你应用的弱点</c>

00:39:09.750 --> 00:39:11.952 align:middle line:90%,end
<c.magenta>我们决定不应该有致命性的错误</c>

00:39:12.019 --> 00:39:13.987 align:middle line:90%,end
<c.magenta>作为解析不受信任数据的结果</c>

00:39:14.454 --> 00:39:17.658 align:middle line:90%,end
<c.magenta>然而我们确实在Swift中</c>
<c.magenta>使用致命性错误</c>

00:39:17.724 --> 00:39:20.194 align:middle line:90%,end
<c.magenta>若我们检测到这可能是开发者的错误</c>

00:39:20.394 --> 00:39:22.229 align:middle line:90%,end
<c.magenta>就会有一个含致命性错误的字符串</c>

00:39:22.296 --> 00:39:24.398 align:middle line:90%,end
<c.magenta>在告诉你哪里可能出错了</c>

00:39:24.998 --> 00:39:28.535 align:middle line:90%,end
<c.magenta>对于其他情况 我们使用</c>
<c.magenta>Swift内置的错误处理机制</c>

00:39:28.602 --> 00:39:32.072 align:middle line:90%,end
<c.magenta>这类错误在编码和解码时候</c>
<c.magenta>都有可能发生</c>

00:39:32.973 --> 00:39:34.374 align:middle line:90%,end
<c.magenta>让我们看看它们是什么样的</c>

00:39:35.108 --> 00:39:37.177 align:middle line:90%,end
<c.magenta>首先 编码</c>

00:39:37.411 --> 00:39:40.747 align:middle line:90%,end
<c.magenta>只有一种编码的错误 就是非法的值</c>

00:39:41.114 --> 00:39:43.650 align:middle line:90%,end
<c.magenta>对于某些像JSON这样的格式</c>

00:39:43.717 --> 00:39:47.921 align:middle line:90%,end
<c.magenta>我们想要给予它们灵活性来</c>
<c.magenta>处理它们可能没有预见到的输入</c>

00:39:47.988 --> 00:39:51.258 align:middle line:90%,end
<c.magenta>而不是报告一个致命性的错误</c>
<c.magenta>或是赋给某些默认值</c>

00:39:51.592 --> 00:39:55.829 align:middle line:90%,end
<c.magenta>例如在JSON中</c>
<c.magenta>非数或者无穷不是合法值</c>

00:39:56.063 --> 00:39:58.165 align:middle line:90%,end
<c.magenta>因此在这些情况下 它们能抛出错误</c>

00:39:58.232 --> 00:40:01.068 align:middle line:90%,end
<c.magenta>你可能从类型层面上做不了太多</c>

00:39:58.232 --> 00:40:01.068 align:middle line:90%,end
<c.magenta>你可能从类型层面上做不了太多</c>

00:40:01.134 --> 00:40:02.703 align:middle line:90%,end
<c.magenta>不过你仍然可以在上层捕捉它</c>

00:40:02.769 --> 00:40:05.439 align:middle line:90%,end
<c.magenta>并且呈献给你的用户一个错误</c>
<c.magenta>或者防止其他种类的错误</c>

00:40:05.506 --> 00:40:07.808 align:middle line:90%,end
<c.magenta>或是呈现某种其他类型的恢复机制</c>

00:40:08.675 --> 00:40:12.279 align:middle line:90%,end
<c.magenta>对于解码方面 有四种错误</c>
<c.magenta>我们在演示中已经看到过三种了</c>

00:40:12.346 --> 00:40:14.348 align:middle line:90%,end
<c.magenta>类型不匹配 找不到的键</c>
<c.magenta>找不到的值</c>

00:40:14.414 --> 00:40:17.417 align:middle line:90%,end
<c.magenta>你可以通过空中处理机制解决</c>

00:40:17.484 --> 00:40:19.887 align:middle line:90%,end
<c.magenta>如果它们确实是你类型所必需的部分</c>

00:40:19.953 --> 00:40:21.922 align:middle line:90%,end
<c.magenta>或是将这些属性设为可选的</c>

00:40:22.656 --> 00:40:24.458 align:middle line:90%,end
<c.magenta>最后我们有数据侵蚀</c>

00:40:24.658 --> 00:40:26.360 align:middle line:90%,end
<c.magenta>数据侵蚀就是我们的捕捉所有错误</c>

00:40:26.426 --> 00:40:29.263 align:middle line:90%,end
<c.magenta>对于解码过程所能发生的</c>
<c.magenta>所有其他错误</c>

00:40:29.630 --> 00:40:31.164 align:middle line:90%,end
<c.magenta>为了看看它何处可能会有用</c>

00:40:31.231 --> 00:40:34.168 align:middle line:90%,end
<c.magenta>让我们深入看看解码时发生了什么</c>

00:40:34.635 --> 00:40:37.171 align:middle line:90%,end
<c.magenta>首先开始的时候</c>
<c.magenta>我们所拥有的都是字节码</c>

00:40:37.571 --> 00:40:39.072 align:middle line:90%,end
<c.magenta>它可能来自于网络</c>

00:40:39.139 --> 00:40:42.176 align:middle line:90%,end
<c.magenta>可能来自于磁盘上的某个文件</c>
<c.magenta>或是你应用里的某处</c>

00:40:42.242 --> 00:40:45.512 align:middle line:90%,end
<c.magenta>无论从哪来的 在此时</c>
<c.magenta>我们真的对于它们什么都不知道</c>

00:40:45.579 --> 00:40:49.283 align:middle line:90%,end
<c.magenta>因此第一步就是</c>
<c.magenta>将这些字节码转换成结构化的字节码</c>

00:40:50.450 --> 00:40:52.186 align:middle line:90%,end
<c.magenta>例如 这个JSON解码器</c>

00:40:52.252 --> 00:40:55.389 align:middle line:90%,end
<c.magenta>要验证JSON代码的</c>
<c.magenta>特定需求被满足</c>

00:40:55.722 --> 00:40:58.091 align:middle line:90%,end
<c.magenta>在压缩数据的开始 个别的字节码</c>

00:40:58.158 --> 00:40:59.626 align:middle line:90%,end
<c.magenta>表明了字符串编码</c>

00:40:59.893 --> 00:41:05.465 align:middle line:90%,end
<c.magenta>特定的用于字符串分隔符的</c>
<c.magenta>字符 数值 数组 词典等等</c>

00:40:59.893 --> 00:41:05.465 align:middle line:90%,end
<c.magenta>特定的用于字符串分隔符的</c>
<c.magenta>字符 数值 数组 词典等等</c>

00:41:05.866 --> 00:41:07.267 align:middle line:90%,end
<c.magenta>若其中任何东西看上去有错</c>

00:41:07.334 --> 00:41:11.104 align:middle line:90%,end
<c.magenta>JSON解码器就能抛出一个错误</c>
<c.magenta>并马上停止解码器的运行</c>

00:41:12.506 --> 00:41:16.176 align:middle line:90%,end
<c.magenta>在那之后 我们想要从</c>
<c.magenta>JSON数组 词典</c>

00:41:16.243 --> 00:41:19.179 align:middle line:90%,end
<c.magenta>以及字符串转换到你的类型</c>
<c.magenta>提交和编写者</c>

00:41:19.246 --> 00:41:21.849 align:middle line:90%,end
<c.magenta>毕竟这个API就是为此而生的</c>

00:41:22.716 --> 00:41:24.685 align:middle line:90%,end
<c.magenta>不过我们还可以做到更多</c>

00:41:25.385 --> 00:41:27.588 align:middle line:90%,end
<c.magenta>我们称之为域相关合法性验证</c>

00:41:27.988 --> 00:41:31.158 align:middle line:90%,end
<c.magenta>例如 你有个包含整型属性的类型</c>

00:41:31.225 --> 00:41:34.628 align:middle line:90%,end
<c.magenta>但是合法的整数只有0到100之间</c>

00:41:35.195 --> 00:41:38.131 align:middle line:90%,end
<c.magenta>或者你的类型有两种布尔属性</c>

00:41:38.198 --> 00:41:41.268 align:middle line:90%,end
<c.magenta>但是它们有着互斥的关系</c>

00:41:41.635 --> 00:41:45.138 align:middle line:90%,end
<c.magenta>这类事情很难通过Swift</c>
<c.magenta>的类型系统来表达</c>

00:41:45.205 --> 00:41:48.208 align:middle line:90%,end
<c.magenta>但是我们认为</c>
<c.magenta>我们有个很棒的工具来处理这些</c>

00:41:48.275 --> 00:41:50.277 align:middle line:90%,end
<c.magenta>而这仅需多写点Swift代码</c>
<c.magenta>就能实现</c>

00:41:50.344 --> 00:41:53.347 align:middle line:90%,end
<c.magenta>我们想要确保提供给你机会来实现</c>

00:41:53.413 --> 00:41:55.315 align:middle line:90%,end
<c.magenta>如果你有这类需求的话</c>

00:41:56.149 --> 00:41:58.385 align:middle line:10%
<c.magenta>最后你还有图形级别合法性验证</c>

00:41:58.619 --> 00:41:59.720 align:middle line:10%
<c.magenta>这是有关</c>

00:41:59.786 --> 00:42:03.056 align:middle line:90%,end
<c.magenta>图中的对象彼此间的关系</c>
<c.magenta>或是你应用的另一个部分</c>

00:41:59.786 --> 00:42:03.056 align:middle line:90%,end
<c.magenta>图中的对象彼此间的关系</c>
<c.magenta>或是你应用的另一个部分</c>

00:42:04.424 --> 00:42:05.993 align:middle line:90%,end
<c.magenta>让我们将其应用到我们的提交中</c>

00:42:06.159 --> 00:42:09.296 align:middle line:90%,end
<c.magenta>此前我们看到了如何定制</c>
<c.magenta>commentCount属性</c>

00:42:09.363 --> 00:42:11.698 align:middle line:90%,end
<c.magenta>通过定制叫作</c>
<c.magenta>CodingKeys的枚举</c>

00:42:11.965 --> 00:42:14.067 align:middle line:90%,end
<c.magenta>现在我们将要定制可解码性</c>

00:42:14.134 --> 00:42:16.069 align:middle line:90%,end
<c.magenta>通过实现init from decoder</c>

00:42:16.870 --> 00:42:19.706 align:middle line:90%,end
<c.magenta>首先 我为解码器请求一个容器</c>

00:42:20.207 --> 00:42:22.876 align:middle line:90%,end
<c.magenta>容器就是用来匹配你的键</c>

00:42:22.943 --> 00:42:25.712 align:middle line:90%,end
<c.magenta>到你期望在压缩数据中所找到的值</c>

00:42:26.813 --> 00:42:30.517 align:middle line:90%,end
<c.magenta>一旦我们有了一个容器</c>
<c.magenta>我们就可以向它请求我们所需要的值</c>

00:42:30.617 --> 00:42:34.087 align:middle line:90%,end
<c.magenta>在这里 是一个URL</c>
<c.magenta>一个字符串 编写者</c>

00:42:34.154 --> 00:42:38.625 align:middle line:90%,end
<c.magenta>还有我们的递归降序</c>
<c.magenta>以及commentCount的整型数值</c>

00:42:39.626 --> 00:42:41.428 align:middle line:90%,end
<c.magenta>比如说现在我有一个额外需求</c>

00:42:41.495 --> 00:42:43.764 align:middle line:90%,end
<c.magenta>就是我需要作为技术规格</c>
<c.magenta>的一部分进行验证</c>

00:42:43.830 --> 00:42:47.067 align:middle line:90%,end
<c.magenta>所有的URL都必须是HTTPS</c>

00:42:47.467 --> 00:42:49.636 align:middle line:90%,end
<c.magenta>如果它们不是的话 就会有错误</c>

00:42:50.003 --> 00:42:53.574 align:middle line:10%
<c.magenta>让我们看看如果实现吧</c>
<c.magenta>首先 在幻灯片上腾出更多空间</c>

00:42:54.208 --> 00:42:57.711 align:middle line:10%
<c.magenta>然后 我会使用我们</c>
<c.magenta>已经知道怎么用的URL API</c>

00:42:57.778 --> 00:42:59.713 align:middle line:10%
<c.magenta>那就是scheme属性</c>

00:43:00.614 --> 00:43:03.817 align:middle line:10%
<c.magenta>这里我只检查是否等于HTTPS</c>
<c.magenta>如果它不相等</c>

00:43:03.951 --> 00:43:05.886 align:middle line:10%
<c.magenta>我就可以抛出一个解码错误</c>

00:43:05.953 --> 00:43:08.689 align:middle line:10%
<c.magenta>提供一个排除故障描述</c>
<c.magenta>以便你可在调试器里捕捉到它</c>

00:43:08.755 --> 00:43:10.357 align:middle line:10%
<c.magenta>就如同毅太在演示中所展示的那样</c>

00:43:10.657 --> 00:43:14.995 align:middle line:10%
<c.magenta>你没注意到的是 这个类型 提交</c>

00:43:15.062 --> 00:43:17.064 align:middle line:10%
<c.magenta>检查了URL的字符串值</c>

00:43:17.698 --> 00:43:19.633 align:middle line:10%
<c.magenta>我们可以允许URL解码自己</c>

00:43:20.167 --> 00:43:23.036 align:middle line:90%,end
<c.magenta>这也是这个设计如此之棒的部分原因</c>

00:43:23.337 --> 00:43:26.006 align:middle line:90%,end
<c.magenta>URL知道某个字符串是不是URL</c>

00:43:26.073 --> 00:43:29.109 align:middle line:90%,end
<c.magenta>如果不是的话 它就会抛出一个错误</c>
<c.magenta>甚至在我们到这步之前</c>

00:43:29.409 --> 00:43:31.612 align:middle line:90%,end
<c.magenta>由于Swift错误处理的设计</c>

00:43:31.678 --> 00:43:35.082 align:middle line:90%,end
<c.magenta>可以延迟这个类型到解码提交</c>

00:43:35.148 --> 00:43:36.416 align:middle line:90%,end
<c.magenta>或者甚至更高层级</c>

00:43:38.719 --> 00:43:40.521 align:middle line:90%,end
<c.magenta>让我们接着看第二个支柱</c>

00:43:40.587 --> 00:43:43.257 align:middle line:90%,end
<c.magenta>那就是编码细节的封装</c>

00:43:44.358 --> 00:43:48.128 align:middle line:90%,end
<c.magenta>我们觉得保证键和值非常重要</c>

00:43:48.195 --> 00:43:51.665 align:middle line:90%,end
<c.magenta>它们是一个类型选择私密的东西</c>
<c.magenta>放到压缩数据</c>

00:43:52.366 --> 00:43:53.734 align:middle line:90%,end
<c.magenta>原因很重要</c>

00:43:53.800 --> 00:43:56.470 align:middle line:90%,end
<c.magenta>因为这减少了我们的工作量</c>

00:43:56.537 --> 00:43:58.839 align:middle line:90%,end
<c.magenta>设计某些带有全局知识的</c>

00:43:58.906 --> 00:44:01.475 align:middle line:90%,end
<c.magenta>在压缩数据里可能会出现的东西</c>

00:43:58.906 --> 00:44:01.475 align:middle line:90%,end
<c.magenta>在压缩数据里可能会出现的东西</c>

00:44:02.109 --> 00:44:04.878 align:middle line:90%,end
<c.magenta>我们实现这种封装的主要机制</c>

00:44:04.945 --> 00:44:07.581 align:middle line:90%,end
<c.magenta>叫作容器 我们有三种</c>

00:44:08.115 --> 00:44:10.017 align:middle line:90%,end
<c.magenta>第一种叫作加密容器</c>

00:44:10.684 --> 00:44:14.021 align:middle line:90%,end
<c.magenta>加密容器是大多数情况下的优先选择</c>

00:44:14.188 --> 00:44:18.358 align:middle line:90%,end
<c.magenta>原因是因为</c>
<c.magenta>它们目前是向前向后最兼容的</c>

00:44:18.759 --> 00:44:22.196 align:middle line:90%,end
<c.magenta>如果你新版本的应用里</c>
<c.magenta>有新的或者变动的数据</c>

00:44:22.429 --> 00:44:23.897 align:middle line:90%,end
<c.magenta>你只需要用一个新的密钥</c>

00:44:24.498 --> 00:44:26.667 align:middle line:90%,end
<c.magenta>这使得应用的绝大多数版本</c>

00:44:26.733 --> 00:44:28.769 align:middle line:90%,end
<c.magenta>与你数据的绝大多数版本相兼容</c>

00:44:28.836 --> 00:44:31.104 align:middle line:90%,end
<c.magenta>这对于每个人都是最好的可能结果</c>

00:44:32.039 --> 00:44:34.041 align:middle line:90%,end
<c.magenta>让我们看看这些密钥实际上是什么</c>

00:44:34.107 --> 00:44:36.076 align:middle line:90%,end
<c.magenta>早些时候</c>
<c.magenta>我们谈了CodingKey协议</c>

00:44:36.143 --> 00:44:37.144 align:middle line:90%,end
<c.magenta>就是这个</c>

00:44:37.444 --> 00:44:41.248 align:middle line:90%,end
<c.magenta>它有两个协议</c>
<c.magenta>或者两个属性和两个初始化</c>

00:44:41.748 --> 00:44:43.517 align:middle line:90%,end
<c.magenta>属性就是stringValue</c>

00:44:43.584 --> 00:44:45.986 align:middle line:90%,end
<c.magenta>例如 你在用JSON时候就很方便</c>

00:44:46.053 --> 00:44:48.956 align:middle line:90%,end
<c.magenta>不过你也可以提供一个整型数值</c>
<c.magenta>这对于格式很有用</c>

00:44:49.022 --> 00:44:51.992 align:middle line:90%,end
<c.magenta>这或许提供了一个</c>
<c.magenta>更有效的编码二进制表现</c>

00:44:53.060 --> 00:44:56.396 align:middle line:90%,end
<c.magenta>而初始化</c>
<c.magenta>我想让你们注意的是它们是可选的</c>

00:44:56.463 --> 00:44:57.798 align:middle line:90%,end
<c.magenta>这就意味着解码器</c>

00:44:57.865 --> 00:45:01.235 align:middle line:90%,end
<c.magenta>拥有执行额外一层安全性检查的能力</c>

00:44:57.865 --> 00:45:01.235 align:middle line:90%,end
<c.magenta>拥有执行额外一层安全性检查的能力</c>

00:45:01.368 --> 00:45:03.871 align:middle line:90%,end
<c.magenta>它可以验证你的代码密钥</c>

00:45:03.937 --> 00:45:07.808 align:middle line:90%,end
<c.magenta>你在压缩数据中所找到的值</c>
<c.magenta>就是你想要的</c>

00:45:08.275 --> 00:45:11.345 align:middle line:90%,end
<c.magenta>通常你要在枚举上采用这个协议</c>

00:45:11.411 --> 00:45:12.946 align:middle line:90%,end
<c.magenta>就如同我们目前看到的这个</c>

00:45:13.280 --> 00:45:15.048 align:middle line:90%,end
<c.magenta>这里所发生的就是</c>

00:45:15.115 --> 00:45:16.583 align:middle line:90%,end
<c.magenta>标准库的编译器</c>

00:45:16.650 --> 00:45:19.086 align:middle line:90%,end
<c.magenta>提供一个所有这四种需求的实现</c>

00:45:19.152 --> 00:45:20.420 align:middle line:90%,end
<c.magenta>完全免费给我们</c>

00:45:20.888 --> 00:45:23.957 align:middle line:10%
<c.magenta>在这里 因为枚举是由字符串组成的</c>

00:45:24.458 --> 00:45:27.027 align:middle line:10%
<c.magenta>编译器使用case名</c>
<c.magenta>作为字符串的值</c>

00:45:27.094 --> 00:45:29.329 align:middle line:10%
<c.magenta>同时为了属性还有初始化</c>

00:45:29.696 --> 00:45:31.231 align:middle line:10%
<c.magenta>不过intValue还是nil</c>

00:45:31.298 --> 00:45:33.033 align:middle line:10%
<c.magenta>因为在这个枚举中没有足够的信息</c>

00:45:33.100 --> 00:45:35.102 align:middle line:10%
<c.magenta>来给它分配一个特定值</c>

00:45:36.003 --> 00:45:39.406 align:middle line:10%
<c.magenta>早前当我们定制case名的时候</c>
<c.magenta>你现在可以看到这是如何运作的</c>

00:45:39.473 --> 00:45:42.509 align:middle line:10%
<c.magenta>我们改变了case的名字</c>
<c.magenta>但是值仍然是一样的</c>

00:45:42.576 --> 00:45:45.812 align:middle line:10%
<c.magenta>因此stringValue仍和</c>
<c.magenta>GitHub API保持兼容</c>

00:45:47.147 --> 00:45:48.582 align:middle line:10%
<c.magenta>如果你在写库的代码</c>

00:45:48.649 --> 00:45:52.119 align:middle line:10%
<c.magenta>我会鼓励你考虑用整型</c>
<c.magenta>来写你的CodingKeys</c>

00:45:52.186 --> 00:45:56.323 align:middle line:10%
<c.magenta>如果你这么做</c>
<c.magenta>你仍会从编译器获得更多免费实现</c>

00:45:56.390 --> 00:46:00.060 align:middle line:10%
<c.magenta>在这个例子中</c>
<c.magenta>一个整型数值 这会对格式很有用</c>

00:45:56.390 --> 00:46:00.060 align:middle line:10%
<c.magenta>在这个例子中</c>
<c.magenta>一个整型数值 这会对格式很有用</c>

00:46:00.127 --> 00:46:01.728 align:middle line:10%
<c.magenta>其可能支持整型密钥</c>

00:46:03.697 --> 00:46:08.569 align:middle line:90%,end
<c.magenta>我们也支持未加密容器</c>
<c.magenta>这些依次编码和解码</c>

00:46:09.236 --> 00:46:12.806 align:middle line:90%,end
<c.magenta>对于有序或无边界的数据</c>
<c.magenta>使用这些容器 其原因就是</c>

00:46:12.873 --> 00:46:14.541 align:middle line:90%,end
<c.magenta>你不需要生成假的密钥</c>

00:46:14.608 --> 00:46:16.543 align:middle line:90%,end
<c.magenta>让你的数据进入压缩数据</c>

00:46:16.977 --> 00:46:19.213 align:middle line:90%,end
<c.magenta>我们也支持单一值容器</c>

00:46:19.279 --> 00:46:22.349 align:middle line:90%,end
<c.magenta>就如这个名字所指的</c>
<c.magenta>只保存一个项目</c>

00:46:22.883 --> 00:46:24.251 align:middle line:90%,end
<c.magenta>对于主类型使用这些容器</c>

00:46:24.318 --> 00:46:26.253 align:middle line:90%,end
<c.magenta>例如 以秒数保存的日期</c>

00:46:26.553 --> 00:46:28.155 align:middle line:90%,end
<c.magenta>由于是时间内的一个引用点</c>

00:46:28.889 --> 00:46:30.691 align:middle line:90%,end
<c.magenta>当你在其中选择的时候 你应该注意</c>

00:46:30.757 --> 00:46:34.728 align:middle line:90%,end
<c.magenta>这些是最不兼容的选择 一定要记住</c>

00:46:35.796 --> 00:46:37.898 align:middle line:90%,end
<c.magenta>让我们再一次回到我们的提交</c>

00:46:39.066 --> 00:46:41.335 align:middle line:90%,end
<c.magenta>我们可以看到</c>
<c.magenta>如何定制了commentCount</c>

00:46:41.401 --> 00:46:43.237 align:middle line:90%,end
<c.magenta>还有它的CodingKeys</c>

00:46:43.303 --> 00:46:45.539 align:middle line:90%,end
<c.magenta>通过改变init</c>
<c.magenta>from decoder来解码</c>

00:46:45.806 --> 00:46:49.476 align:middle line:90%,end
<c.magenta>现在让我们看看</c>
<c.magenta>encode to encoder的编码</c>

00:46:49.776 --> 00:46:52.145 align:middle line:90%,end
<c.magenta>实际上 我在这不需要定制任何东西</c>

00:46:52.212 --> 00:46:53.814 align:middle line:90%,end
<c.magenta>不过我仍然想给你们展示看看</c>
<c.magenta>它是什么样的</c>

00:46:53.881 --> 00:46:55.582 align:middle line:90%,end
<c.magenta>以便你们能理解它是如何运作的</c>

00:46:55.649 --> 00:46:59.586 align:middle line:90%,end
<c.magenta>首先 我们有一个容器</c>
<c.magenta>并且这个容器如你所见</c>

00:46:59.653 --> 00:47:02.756 align:middle line:90%,end
<c.magenta>藉由我们自己的私密</c>
<c.magenta>CodingKeys所编码</c>

00:46:59.653 --> 00:47:02.756 align:middle line:90%,end
<c.magenta>藉由我们自己的私密</c>
<c.magenta>CodingKeys所编码</c>

00:47:03.290 --> 00:47:06.193 align:middle line:90%,end
<c.magenta>这个容器就是我如何编码</c>

00:47:06.260 --> 00:47:08.562 align:middle line:90%,end
<c.magenta>我想要放入压缩数据的值</c>

00:47:08.629 --> 00:47:11.498 align:middle line:90%,end
<c.magenta>我们的URL信息 编写者</c>
<c.magenta>递归降序</c>

00:47:11.565 --> 00:47:12.666 align:middle line:90%,end
<c.magenta>还有commentCount</c>

00:47:13.500 --> 00:47:16.436 align:middle line:90%,end
<c.magenta>我想给你们展示一个如何选择的例子</c>
<c.magenta>选择不同种类的容器</c>

00:47:16.503 --> 00:47:18.805 align:middle line:90%,end
<c.magenta>比如说我们正在处理</c>
<c.magenta>GO JSON代码</c>

00:47:18.872 --> 00:47:20.874 align:middle line:90%,end
<c.magenta>其有一个点的概念</c>

00:47:21.275 --> 00:47:24.945 align:middle line:90%,end
<c.magenta>点有两个值 它应该在JSON中</c>
<c.magenta>是两个数值型元素的数组</c>

00:47:25.012 --> 00:47:28.315 align:middle line:90%,end
<c.magenta>为了使其能正常运作</c>
<c.magenta>我会采用可编码性</c>

00:47:28.382 --> 00:47:32.186 align:middle line:90%,end
<c.magenta>并且使用一个未加密容器</c>
<c.magenta>来实现encode to encoder</c>

00:47:32.252 --> 00:47:35.622 align:middle line:90%,end
<c.magenta>你会注意到这个容器中没有密钥</c>

00:47:35.689 --> 00:47:37.591 align:middle line:90%,end
<c.magenta>当我编码的时候 我没有用密钥</c>

00:47:37.658 --> 00:47:40.494 align:middle line:90%,end
<c.magenta>JSON中的结果就像是这样</c>

00:47:41.728 --> 00:47:43.630 align:middle line:90%,end
<c.magenta>我们也支持嵌套式的容器</c>

00:47:44.398 --> 00:47:46.900 align:middle line:90%,end
<c.magenta>比如说我的词典中的第二个项目</c>

00:47:46.967 --> 00:47:48.936 align:middle line:90%,end
<c.magenta>需要包含三个值的一个数组</c>

00:47:49.002 --> 00:47:53.207 align:middle line:90%,end
<c.magenta>因此 如你所见 我们支持嵌套</c>
<c.magenta>未加密容器和加密容器</c>

00:47:53.273 --> 00:47:56.276 align:middle line:90%,end
<c.magenta>或者其他任何加密</c>
<c.magenta>未加密和单一值的组合</c>

00:47:56.977 --> 00:48:00.080 align:middle line:90%,end
<c.magenta>嵌套式容器的主要用例就是类</c>

00:47:56.977 --> 00:48:00.080 align:middle line:90%,end
<c.magenta>嵌套式容器的主要用例就是类</c>

00:48:00.414 --> 00:48:03.250 align:middle line:90%,end
<c.magenta>到目前为止</c>
<c.magenta>我们谈了很多关于结构体的问题</c>

00:48:03.317 --> 00:48:06.220 align:middle line:90%,end
<c.magenta>但嵌套式容器给了我们一个自然机制</c>

00:48:06.286 --> 00:48:09.890 align:middle line:90%,end
<c.magenta>从我们作为子类的自己数据</c>
<c.magenta>用来封装超类数据</c>

00:48:09.957 --> 00:48:11.592 align:middle line:90%,end
<c.magenta>也就是一个来自于NSCoding的变化</c>

00:48:12.092 --> 00:48:13.126 align:middle line:90%,end
<c.magenta>我们来看一个例子</c>

00:48:13.360 --> 00:48:16.263 align:middle line:90%,end
<c.magenta>就是每个人都喜欢的</c>
<c.magenta>面向对象的例子 动物</c>

00:48:16.330 --> 00:48:18.799 align:middle line:90%,end
<c.magenta>很自然 动物有个legCount</c>

00:48:19.566 --> 00:48:21.235 align:middle line:90%,end
<c.magenta>还有它自己的CodingKeys</c>

00:48:21.301 --> 00:48:25.005 align:middle line:90%,end
<c.magenta>并且你看到在这个类中</c>
<c.magenta>当我实现init from decoder时</c>

00:48:25.072 --> 00:48:26.473 align:middle line:90%,end
<c.magenta>它是一个必需的初始化</c>

00:48:27.674 --> 00:48:29.176 align:middle line:90%,end
<c.magenta>这里我创建了一个加密容器</c>

00:48:29.243 --> 00:48:31.812 align:middle line:90%,end
<c.magenta>使用动物的CodingKeys</c>
<c.magenta>并且解码我的腿计数</c>

00:48:31.979 --> 00:48:33.780 align:middle line:90%,end
<c.magenta>跟我们目前为止所见过的很类似</c>

00:48:34.481 --> 00:48:35.782 align:middle line:90%,end
<c.magenta>让我们创建一个它的子类</c>

00:48:36.450 --> 00:48:38.585 align:middle line:90%,end
<c.magenta>狗是有最好朋友的一种动物</c>

00:48:38.652 --> 00:48:40.888 align:middle line:90%,end
<c.magenta>也就是我们早前生日派对里的小孩</c>

00:48:41.154 --> 00:48:45.192 align:middle line:90%,end
<c.magenta>你会注意到dog也有个叫作</c>
<c.magenta>CodingKeys的私有枚举</c>

00:48:45.259 --> 00:48:48.529 align:middle line:90%,end
<c.magenta>即使它有着与超类中相同的名字</c>

00:48:48.595 --> 00:48:52.900 align:middle line:90%,end
<c.magenta>因为它是私有的</c>
<c.magenta>它并不会与动物所使用的相冲突</c>

00:48:53.333 --> 00:48:55.836 align:middle line:90%,end
<c.magenta>因此 当我实现dog的</c>
<c.magenta>init from decoder时</c>

00:48:55.903 --> 00:48:58.672 align:middle line:90%,end
<c.magenta>并且使用它自己的CodingKeys</c>
<c.magenta>来获得一个容器</c>

00:48:58.739 --> 00:49:02.643 align:middle line:90%,end
<c.magenta>我可以利用对于它来说重要的密钥</c>
<c.magenta>以一种类型安全的方式解码</c>

00:48:58.739 --> 00:49:02.643 align:middle line:90%,end
<c.magenta>我可以利用对于它来说重要的密钥</c>
<c.magenta>以一种类型安全的方式解码</c>

00:49:02.709 --> 00:49:03.777 align:middle line:90%,end
<c.magenta>而不是对它的超类重要</c>

00:49:04.444 --> 00:49:06.213 align:middle line:90%,end
<c.magenta>现在 我们需要完成那个嵌套</c>

00:49:06.446 --> 00:49:08.248 align:middle line:90%,end
<c.magenta>我们可以调用超类</c>

00:49:08.315 --> 00:49:11.552 align:middle line:90%,end
<c.magenta>利用我们接收到的解码器</c>
<c.magenta>来实现超类的init from decoder</c>

00:49:11.919 --> 00:49:17.157 align:middle line:90%,end
<c.magenta>然而 这不会给容器机会</c>
<c.magenta>来嵌套该超类数据</c>

00:49:17.624 --> 00:49:20.894 align:middle line:10%
<c.magenta>因此 最简单的实现方法</c>
<c.magenta>就是使用这个方便的API</c>

00:49:20.961 --> 00:49:22.095 align:middle line:10%
<c.magenta>叫作superDecoder</c>

00:49:22.162 --> 00:49:25.098 align:middle line:10%
<c.magenta>它会获得一个新的</c>
<c.magenta>可以传到我们超类的解码器</c>

00:49:25.332 --> 00:49:30.537 align:middle line:10%
<c.magenta>通过调用super 我们满足了</c>
<c.magenta>Swift的规则来创建一个初始化</c>

00:49:30.604 --> 00:49:33.874 align:middle line:10%
<c.magenta>其实现了一个随时可用的</c>
<c.magenta>最终初始化了的类型</c>

00:49:36.910 --> 00:49:38.445 align:middle line:90%,end
<c.magenta>最后是我们的第三个支柱</c>

00:49:38.512 --> 00:49:42.382 align:middle line:90%,end
<c.magenta>那就是从这些类型中抽象出编码格式</c>

00:49:43.483 --> 00:49:45.452 align:middle line:90%,end
<c.magenta>我们觉得能够重用很重要</c>

00:49:45.519 --> 00:49:48.288 align:middle line:90%,end
<c.magenta>就是重用这些协议的实现</c>

00:49:49.022 --> 00:49:50.724 align:middle line:90%,end
<c.magenta>我们不想以这种局面结束</c>

00:49:50.791 --> 00:49:53.694 align:middle line:90%,end
<c.magenta>就是我们有很多几乎相同的实现</c>

00:49:53.760 --> 00:49:57.231 align:middle line:90%,end
<c.magenta>对于可编码性和可解码性</c>
<c.magenta>来支持新的格式</c>

00:49:57.865 --> 00:50:00.334 align:middle line:90%,end
<c.magenta>因此通过抽象格式</c>

00:49:57.865 --> 00:50:00.334 align:middle line:90%,end
<c.magenta>因此通过抽象格式</c>

00:50:00.400 --> 00:50:03.403 align:middle line:90%,end
<c.magenta>我们可以不改变任何库</c>
<c.magenta>就可以允许全新的格式</c>

00:50:03.537 --> 00:50:07.508 align:middle line:90%,end
<c.magenta>这些格式可以来自于我们或你们</c>
<c.magenta>甚至来自于Swift包</c>

00:50:07.574 --> 00:50:10.010 align:middle line:90%,end
<c.magenta>这些格式可以与这些类型一起运作</c>

00:50:10.077 --> 00:50:12.880 align:middle line:90%,end
<c.magenta>来自于我们的 来自于你们的</c>
<c.magenta>或者来自Swift包的</c>

00:50:13.714 --> 00:50:16.083 align:middle line:90%,end
<c.magenta>不过我们也理解 不同的格式</c>

00:50:16.149 --> 00:50:19.286 align:middle line:90%,end
<c.magenta>有着不同的基础类型和不同的规范</c>

00:50:19.820 --> 00:50:21.588 align:middle line:90%,end
<c.magenta>因为我们保证运作正常的机制</c>

00:50:21.655 --> 00:50:23.123 align:middle line:90%,end
<c.magenta>叫作编码战略</c>

00:50:23.624 --> 00:50:27.761 align:middle line:90%,end
<c.magenta>这是针对特定类型的</c>
<c.magenta>基于编码器和解码器的定制</c>

00:50:28.061 --> 00:50:30.564 align:middle line:90%,end
<c.magenta>例如 在JSON中</c>
<c.magenta>我们已经看到了关于日期的内容</c>

00:50:30.931 --> 00:50:34.935 align:middle line:90%,end
<c.magenta>在我们的GitHub例子中</c>
<c.magenta>日期被编码为ISO8601字符串</c>

00:50:35.402 --> 00:50:38.105 align:middle line:90%,end
<c.magenta>不过还有其他可能的规范</c>

00:50:38.172 --> 00:50:40.841 align:middle line:90%,end
<c.magenta>例如 作为引用日期的秒数</c>

00:50:40.908 --> 00:50:43.076 align:middle line:90%,end
<c.magenta>作为引用日期的毫秒数</c>

00:50:43.143 --> 00:50:45.746 align:middle line:90%,end
<c.magenta>或者你甚至可以声明</c>
<c.magenta>一个完全定制的日期格式器</c>

00:50:45.812 --> 00:50:48.015 align:middle line:90%,end
<c.magenta>如果你脑子里有些很专注的东西</c>

00:50:48.916 --> 00:50:51.785 align:middle line:90%,end
<c.magenta>JSON编码器和解码器</c>
<c.magenta>支持其他种类的战略</c>

00:50:51.852 --> 00:50:53.654 align:middle line:90%,end
<c.magenta>例如 对于数据</c>

00:50:53.854 --> 00:50:56.990 align:middle line:10%
<c.magenta>在JSON中 用Base64</c>
<c.magenta>编码数据是很常见的</c>

00:50:57.824 --> 00:51:01.061 align:middle line:10%
<c.magenta>不过我们也允许你通过选择战略</c>
<c.magenta>来定制这个</c>

00:50:57.824 --> 00:51:01.061 align:middle line:10%
<c.magenta>不过我们也允许你通过选择战略</c>
<c.magenta>来定制这个</c>

00:51:01.128 --> 00:51:03.564 align:middle line:10%
<c.magenta>也就是作为字节码的数组来编码它</c>

00:51:03.630 --> 00:51:06.200 align:middle line:10%
<c.magenta>或者你可以声明某些完全定制的东西</c>
<c.magenta>像是这个</c>

00:51:06.266 --> 00:51:09.136 align:middle line:10%
<c.magenta>把所有的零变成绵羊</c>
<c.magenta>把所有其他的变成狗</c>

00:51:09.403 --> 00:51:13.373 align:middle line:10%
<c.magenta>我不知道你为什么要这么做</c>
<c.magenta>但是这是可能的 就是这样</c>

00:51:13.907 --> 00:51:17.377 align:middle line:10%
<c.magenta>抽象也可以帮助我们利用不同的格式</c>

00:51:17.444 --> 00:51:19.479 align:middle line:10%
<c.magenta>如我们所见 今天谈论了</c>
<c.magenta>很多关于JSON的东西</c>

00:51:19.546 --> 00:51:23.016 align:middle line:10%
<c.magenta>但实际上 我们也引入了</c>
<c.magenta>属性表的编码器和解码器</c>

00:51:23.283 --> 00:51:27.721 align:middle line:10%
<c.magenta>而属性表 不像是JSON</c>
<c.magenta>有对于数据和日期的原生类型</c>

00:51:27.821 --> 00:51:29.756 align:middle line:10%
<c.magenta>因此当这些编码器和解码器</c>

00:51:30.090 --> 00:51:32.860 align:middle line:10%
<c.magenta>遇到这些对象</c>
<c.magenta>无论它正在编码的对象图里</c>

00:51:32.926 --> 00:51:34.995 align:middle line:10%
<c.magenta>还是在解压缩的数据里</c>

00:51:35.329 --> 00:51:38.565 align:middle line:10%
<c.magenta>我们都可以将它们转换成</c>
<c.magenta>对于该格式恰当正确的类型</c>

00:51:39.733 --> 00:51:42.503 align:middle line:10%
<c.magenta>由于这些抽象</c>
<c.magenta>我们可以采用可编码性协议</c>

00:51:42.569 --> 00:51:45.939 align:middle line:10%
<c.magenta>在许多Foundation类型中</c>
<c.magenta>包括所有你们在这看到的</c>

00:51:47.708 --> 00:51:49.543 align:middle line:10%
<c.magenta>我们已经谈论了许多关于</c>
<c.magenta>可编码性API的内容</c>

00:51:49.610 --> 00:51:51.845 align:middle line:10%
<c.magenta>我想要给你们一个清晰的概括</c>

00:51:51.912 --> 00:51:54.047 align:middle line:10%
<c.magenta>来帮助你们理解全局</c>

00:51:54.114 --> 00:51:56.450 align:middle line:90%,end
<c.magenta>当然了 我们从你的类型开始</c>

00:51:56.517 --> 00:52:00.754 align:middle line:90%,end
<c.magenta>你的类型采用两种协议</c>
<c.magenta>他们叫作可编码性和可解码性</c>

00:51:56.517 --> 00:52:00.754 align:middle line:90%,end
<c.magenta>你的类型采用两种协议</c>
<c.magenta>他们叫作可编码性和可解码性</c>

00:52:01.822 --> 00:52:03.924 align:middle line:90%,end
<c.magenta>它们有一个函数和一个初始化</c>

00:52:03.991 --> 00:52:07.160 align:middle line:90%,end
<c.magenta>其让你访问编码器和解码器</c>

00:52:08.161 --> 00:52:10.163 align:middle line:90%,end
<c.magenta>这些可供你访问容器</c>

00:52:10.230 --> 00:52:13.133 align:middle line:90%,end
<c.magenta>那也是在压缩数据中</c>
<c.magenta>实际保存值的地方</c>

00:52:13.200 --> 00:52:14.868 align:middle line:90%,end
<c.magenta>在加密容器的情况下</c>

00:52:14.935 --> 00:52:18.005 align:middle line:90%,end
<c.magenta>我们使用由你的类型</c>
<c.magenta>所定义的CodingKeys</c>

00:52:19.106 --> 00:52:21.475 align:middle line:90%,end
<c.magenta>最后 就是编码器和容器</c>

00:52:21.542 --> 00:52:26.079 align:middle line:90%,end
<c.magenta>提供了对于编码格式的抽象</c>
<c.magenta>像是JSON 属性表等等</c>

00:52:28.148 --> 00:52:31.351 align:middle line:90%,end
<c.magenta>我们今天开始时候</c>
<c.magenta>介绍了一些新的API</c>

00:52:31.418 --> 00:52:34.321 align:middle line:90%,end
<c.magenta>还有今年新发布的</c>
<c.magenta>Foundation所改进的性能表现</c>

00:52:34.388 --> 00:52:37.691 align:middle line:90%,end
<c.magenta>在那之后</c>
<c.magenta>我们看了Swift新的强类型键径</c>

00:52:37.758 --> 00:52:42.596 align:middle line:90%,end
<c.magenta>包括一个非常酷的用例 就是全新的</c>
<c.magenta>基于终结的KVO API</c>

00:52:43.063 --> 00:52:45.766 align:middle line:90%,end
<c.magenta>最后 我们介绍新的可编码性协议</c>

00:52:45.832 --> 00:52:48.836 align:middle line:90%,end
<c.magenta>其使得与其他格式的集成非常简单</c>
<c.magenta>像是JSON</c>

00:52:48.902 --> 00:52:52.306 align:middle line:90%,end
<c.magenta>而且也允许你进行强大的定制</c>

00:52:53.607 --> 00:52:55.542 align:middle line:90%,end
<c.magenta>有关更多信息 请查阅这个链接</c>

00:52:56.009 --> 00:52:58.879 align:middle line:90%,end
<c.magenta>我们有一些与所谈内容相关的演讲</c>

00:53:00.514 --> 00:53:01.448 align:middle line:90%,end
<c.magenta>非常感谢</c>
