WEBVTT

00:00:17.551 --> 00:00:21.154 align:middle line:10%
<c.magenta>（通过框架性能案例研究</c>
<c.magenta>实现高效率交互）</c>

00:00:24.591 --> 00:00:26.360 align:middle line:90%,end
<c.magenta>大家下午好</c>
<c.magenta>我是菲力浦豪斯勒</c>

00:00:26.426 --> 00:00:28.662 align:middle line:90%,end
<c.magenta>今天 我和我的同事</c>
<c.magenta>唐娜汤姆一起</c>

00:00:28.729 --> 00:00:31.865 align:middle line:90%,end
<c.magenta>和大家一起讨论</c>
<c.magenta>如何使用框架实现高效率交互</c>

00:00:32.566 --> 00:00:35.769 align:middle line:90%,end
<c.magenta>如今 我们所有人</c>
<c.magenta>都非常关心性能问题</c>

00:00:35.903 --> 00:00:37.538 align:middle line:90%,end
<c.magenta>我们希望笔记本电脑飞速运行</c>

00:00:37.604 --> 00:00:40.807 align:middle line:90%,end
<c.magenta>希望我们的手机和平板电脑</c>
<c.magenta>支持一整天的使用时间</c>

00:00:41.175 --> 00:00:43.777 align:middle line:90%,end
<c.magenta>期待我们的桌面电脑</c>
<c.magenta>具有强大的性能</c>

00:00:43.977 --> 00:00:44.945 align:middle line:90%,end
<c.magenta>事实上</c>

00:00:45.045 --> 00:00:47.648 align:middle line:90%,end
<c.magenta>所有这些设备</c>
<c.magenta>都应该具备良好的性能</c>

00:00:48.081 --> 00:00:50.651 align:middle line:90%,end
<c.magenta>我们的任务是</c>
<c.magenta>努力实现这个目标</c>

00:00:52.252 --> 00:00:54.188 align:middle line:90%,end
<c.magenta>我们需要从不同维度来评价性能</c>

00:00:54.254 --> 00:00:57.457 align:middle line:90%,end
<c.magenta>例如 代码的运行速度</c>
<c.magenta>程序耗用的电量</c>

00:00:57.658 --> 00:00:59.960 align:middle line:90%,end
<c.magenta>以及内存占用大小等</c>

00:01:00.394 --> 00:01:01.795 align:middle line:10%
<c.magenta>由于具有多个不同的维度</c>

00:01:01.862 --> 00:01:03.931 align:middle line:10%
<c.magenta>我们如何使用图形</c>
<c.magenta>来更好地进行描述呢？</c>

00:01:04.697 --> 00:01:06.967 align:middle line:90%,end
<c.magenta>这里有一个框架</c>

00:01:07.234 --> 00:01:09.670 align:middle line:90%,end
<c.magenta>进行形象化描述</c>
<c.magenta>你可以将它视为一个图表</c>

00:01:09.903 --> 00:01:12.906 align:middle line:90%,end
<c.magenta>其中的一个轴</c>
<c.magenta>表示你所处理的数据量</c>

00:01:13.140 --> 00:01:14.908 align:middle line:90%,end
<c.magenta>另一个轴表示处理频率</c>

00:01:16.009 --> 00:01:19.746 align:middle line:90%,end
<c.magenta>如果你需要处理大量的数据</c>
<c.magenta>而且代码运行非常频繁</c>

00:01:20.047 --> 00:01:22.516 align:middle line:90%,end
<c.magenta>那么其性能水平</c>
<c.magenta>将会位于第一象限</c>

00:01:22.649 --> 00:01:27.654 align:middle line:90%,end
<c.magenta>这样的话很有可能会</c>
<c.magenta>对性能造成很大的影响</c>

00:01:27.888 --> 00:01:31.758 align:middle line:90%,end
<c.magenta>你需要花费大量的时间</c>
<c.magenta>来进行优化</c>

00:01:32.492 --> 00:01:34.161 align:middle line:90%,end
<c.magenta>但是 如果你处理的</c>

00:01:34.228 --> 00:01:37.464 align:middle line:90%,end
<c.magenta>数据量比较小</c>
<c.magenta>而且代码运行次数较低</c>

00:01:37.531 --> 00:01:39.600 align:middle line:90%,end
<c.magenta>那么性能水平</c>
<c.magenta>将会位于第三象限</c>

00:01:39.766 --> 00:01:41.068 align:middle line:90%,end
<c.magenta>老实说</c>

00:01:41.335 --> 00:01:43.170 align:middle line:90%,end
<c.magenta>你并不希望</c>
<c.magenta>花费很多的时间</c>

00:01:43.237 --> 00:01:44.805 align:middle line:90%,end
<c.magenta>来优化性能</c>

00:01:45.539 --> 00:01:49.476 align:middle line:90%,end
<c.magenta>第二象限和第四象限</c>
<c.magenta>的情况有点复杂</c>

00:01:49.710 --> 00:01:51.078 align:middle line:90%,end
<c.magenta>它们的性能水平</c>

00:01:51.144 --> 00:01:53.347 align:middle line:90%,end
<c.magenta>在很大程度上</c>
<c.magenta>取决于具体的情况</c>

00:01:53.413 --> 00:01:54.348 align:middle line:90%,end
<c.magenta>在这些情况下</c>

00:01:54.414 --> 00:02:00.053 align:middle line:90%,end
<c.magenta>你希望能够结合实际应用</c>
<c.magenta>来评估性能水平</c>

00:01:54.414 --> 00:02:00.053 align:middle line:90%,end
<c.magenta>你希望能够结合实际应用</c>
<c.magenta>来评估性能水平</c>

00:02:00.254 --> 00:02:01.755 align:middle line:90%,end
<c.magenta>然后 根据性能指标</c>

00:02:01.822 --> 00:02:04.124 align:middle line:90%,end
<c.magenta>来确定是否值得花时间</c>

00:02:04.191 --> 00:02:05.626 align:middle line:90%,end
<c.magenta>进行修改</c>

00:02:07.694 --> 00:02:09.596 align:middle line:90%,end
<c.magenta>在本版本中 我们深入地研究</c>

00:02:09.663 --> 00:02:12.032 align:middle line:90%,end
<c.magenta>确保我们能够理解</c>
<c.magenta>该如何在整个操作系统中</c>

00:02:12.099 --> 00:02:13.534 align:middle line:90%,end
<c.magenta>优化性能</c>

00:02:13.700 --> 00:02:15.235 align:middle line:90%,end
<c.magenta>对于应用开发也是如此</c>

00:02:15.903 --> 00:02:18.005 align:middle line:90%,end
<c.magenta>我们对Foundation</c>
<c.magenta>进行了一些</c>

00:02:18.071 --> 00:02:19.540 align:middle line:90%,end
<c.magenta>非常重要的改变</c>

00:02:20.274 --> 00:02:23.177 align:middle line:90%,end
<c.magenta>当然</c>
<c.magenta>Swift也是本版本的主要部分</c>

00:02:23.343 --> 00:02:26.246 align:middle line:90%,end
<c.magenta>我们进行大量的工作</c>
<c.magenta>以保证一些Foundation类型</c>

00:02:26.313 --> 00:02:27.848 align:middle line:90%,end
<c.magenta>之间的桥接</c>

00:02:28.015 --> 00:02:32.219 align:middle line:90%,end
<c.magenta>以提升它们的运行速度</c>
<c.magenta>在你们的应用中更好地工作</c>

00:02:33.687 --> 00:02:37.024 align:middle line:90%,end
<c.magenta>现在 许多应用</c>
<c.magenta>大量使用字符串</c>

00:02:37.090 --> 00:02:40.027 align:middle line:90%,end
<c.magenta>它们被用作口令</c>
<c.magenta>作为易于识读的数据格式</c>

00:02:40.093 --> 00:02:41.728 align:middle line:90%,end
<c.magenta>显示在屏幕上</c>

00:02:42.062 --> 00:02:44.064 align:middle line:90%,end
<c.magenta>高效率的字符串处理</c>

00:02:44.298 --> 00:02:46.600 align:middle line:90%,end
<c.magenta>对于提升应用性能具有很大意义</c>

00:02:46.700 --> 00:02:49.503 align:middle line:90%,end
<c.magenta>作为关键性内容的</c>
<c.magenta>字符串占有很大的比例</c>

00:02:49.570 --> 00:02:51.205 align:middle line:90%,end
<c.magenta>显示给用户</c>

00:02:52.139 --> 00:02:54.208 align:middle line:90%,end
<c.magenta>当然</c>
<c.magenta>今天的演讲</c>

00:02:54.341 --> 00:02:56.643 align:middle line:90%,end
<c.magenta>是为了帮助你们提升应用运行速度</c>

00:02:56.743 --> 00:02:58.245 align:middle line:90%,end
<c.magenta>你们想要减少资源占用</c>

00:02:58.445 --> 00:03:00.447 align:middle line:90%,end
<c.magenta>使用更少的资源</c>
<c.magenta>来完成更多的工作</c>

00:02:58.445 --> 00:03:00.447 align:middle line:90%,end
<c.magenta>使用更少的资源</c>
<c.magenta>来完成更多的工作</c>

00:03:00.514 --> 00:03:03.984 align:middle line:90%,end
<c.magenta>不要着急</c>
<c.magenta>后面我们将会详细论述</c>

00:03:04.051 --> 00:03:06.019 align:middle line:90%,end
<c.magenta>今天 我们将会</c>
<c.magenta>进行讨论</c>

00:03:06.353 --> 00:03:10.357 align:middle line:90%,end
<c.magenta>并为你们介绍一些</c>
<c.magenta>性能优化技巧</c>

00:03:11.592 --> 00:03:14.761 align:middle line:90%,end
<c.magenta>前面我说过</c>
<c.magenta>我们在整个操作系统范围内</c>

00:03:14.828 --> 00:03:16.363 align:middle line:90%,end
<c.magenta>进行大量的性能优化</c>

00:03:16.563 --> 00:03:19.266 align:middle line:90%,end
<c.magenta>在Foundation中</c>
<c.magenta>我们进行一些不错的改变</c>

00:03:19.399 --> 00:03:21.668 align:middle line:90%,end
<c.magenta>让我们来看一些代表性例子</c>

00:03:22.369 --> 00:03:25.138 align:middle line:90%,end
<c.magenta>我们对NSCalendar日期枚举</c>
<c.magenta>进行重大更改</c>

00:03:25.272 --> 00:03:29.343 align:middle line:90%,end
<c.magenta>不仅减少内存占用</c>
<c.magenta>而且加快速度</c>

00:03:29.810 --> 00:03:31.044 align:middle line:90%,end
<c.magenta>在以前</c>

00:03:31.111 --> 00:03:34.882 align:middle line:90%,end
<c.magenta>很难进行</c>
<c.magenta>正确的日历计算</c>

00:03:35.182 --> 00:03:39.186 align:middle line:90%,end
<c.magenta>经过更新的</c>
<c.magenta>NSCalendar实现</c>

00:03:39.253 --> 00:03:42.890 align:middle line:90%,end
<c.magenta>不仅更快速 而且</c>
<c.magenta>更正了一些</c>

00:03:42.956 --> 00:03:44.791 align:middle line:90%,end
<c.magenta>长期以来没解决的</c>
<c.magenta>极端条件计算问题</c>

00:03:46.093 --> 00:03:47.594 align:middle line:90%,end
<c.magenta>但是 在我们进行更改时</c>

00:03:47.661 --> 00:03:51.031 align:middle line:90%,end
<c.magenta>必须考虑这些更改</c>
<c.magenta>的影响范围</c>

00:03:51.465 --> 00:03:53.534 align:middle line:90%,end
<c.magenta>在Foundation和Core Foundation中</c>

00:03:53.667 --> 00:03:57.004 align:middle line:90%,end
<c.magenta>我们在一些位置</c>
<c.magenta>将一些小项目进行整合</c>

00:03:57.471 --> 00:03:58.906 align:middle line:90%,end
<c.magenta>我们深入分析</c>

00:03:58.972 --> 00:04:01.508 align:middle line:90%,end
<c.magenta>Foundation 中的</c>
<c.magenta>线程安全运行机制</c>

00:03:58.972 --> 00:04:01.508 align:middle line:90%,end
<c.magenta>Foundation 中的</c>
<c.magenta>线程安全运行机制</c>

00:04:01.675 --> 00:04:05.012 align:middle line:90%,end
<c.magenta>决定转移到</c>
<c.magenta>使用Atomics和OS及Fairlock</c>

00:04:05.212 --> 00:04:08.882 align:middle line:90%,end
<c.magenta>这让服务质量</c>
<c.magenta>得到很大提升</c>

00:04:10.050 --> 00:04:12.519 align:middle line:90%,end
<c.magenta>在服务质量方面</c>

00:04:12.719 --> 00:04:16.156 align:middle line:90%,end
<c.magenta>NSOperation和OperationQueue</c>
<c.magenta>经过重大修改</c>

00:04:16.390 --> 00:04:18.257 align:middle line:90%,end
<c.magenta>以提升实现的正确水平</c>

00:04:18.325 --> 00:04:20.560 align:middle line:90%,end
<c.magenta>从而提高</c>
<c.magenta>它们的服务质量</c>

00:04:20.894 --> 00:04:23.697 align:middle line:90%,end
<c.magenta>你将会看到一些</c>
<c.magenta>非常灵巧的性能提升</c>

00:04:24.031 --> 00:04:27.935 align:middle line:90%,end
<c.magenta>在重负载应用中</c>
<c.magenta>队列操作的性能提升</c>

00:04:28.001 --> 00:04:31.338 align:middle line:90%,end
<c.magenta>最高可达25%</c>
<c.magenta>这只是其中一个代表性例子</c>

00:04:32.906 --> 00:04:35.809 align:middle line:90%,end
<c.magenta>在研究Swift</c>
<c.magenta>一段时间之后</c>

00:04:36.210 --> 00:04:40.080 align:middle line:90%,end
<c.magenta>我们发现</c>
<c.magenta>写时复制技术非常不错</c>

00:04:40.547 --> 00:04:42.216 align:middle line:90%,end
<c.magenta>在Foundation中</c>

00:04:42.282 --> 00:04:44.251 align:middle line:90%,end
<c.magenta>一些集合类型</c>

00:04:44.318 --> 00:04:47.354 align:middle line:90%,end
<c.magenta>现在将使用写时复制</c>
<c.magenta>作为辅助存储</c>

00:04:48.622 --> 00:04:51.058 align:middle line:10%
<c.magenta>那么 什么是写时复制？</c>

00:04:51.658 --> 00:04:55.429 align:middle line:10%
<c.magenta>写时复制是一种机制</c>
<c.magenta>简称COW</c>

00:04:55.762 --> 00:04:59.032 align:middle line:10%
<c.magenta>在这种机制中</c>
<c.magenta>两个项目可以指向共享后备存储</c>

00:04:59.099 --> 00:05:01.134 align:middle line:10%
<c.magenta>直到发生变更</c>

00:04:59.099 --> 00:05:01.134 align:middle line:10%
<c.magenta>直到发生变更</c>

00:05:01.668 --> 00:05:03.437 align:middle line:10%
<c.magenta>当发生变更时</c>

00:05:03.604 --> 00:05:06.507 align:middle line:10%
<c.magenta>突变方</c>
<c.magenta>复制后备存储</c>

00:05:06.573 --> 00:05:08.609 align:middle line:10%
<c.magenta>从而允许</c>
<c.magenta>进行写入</c>

00:05:08.942 --> 00:05:12.446 align:middle line:10%
<c.magenta>简而言之</c>
<c.magenta>复制操作不会占用过多资源</c>

00:05:12.913 --> 00:05:15.215 align:middle line:10%
<c.magenta>这意味着</c>
<c.magenta>当你保护性地复制</c>

00:05:15.282 --> 00:05:17.985 align:middle line:10%
<c.magenta>可变容器时 不会占用任何资源</c>

00:05:19.052 --> 00:05:22.556 align:middle line:10%
<c.magenta>在以前</c>
<c.magenta>复制集合至少也会</c>

00:05:22.689 --> 00:05:24.191 align:middle line:10%
<c.magenta>占用线性执行时间</c>

00:05:24.558 --> 00:05:26.360 align:middle line:10%
<c.magenta>现在 无论何时复制它们</c>

00:05:26.493 --> 00:05:29.530 align:middle line:10%
<c.magenta>资源耗用始终不变</c>

00:05:30.063 --> 00:05:31.965 align:middle line:90%,end
<c.magenta>让我们来看一个例子</c>

00:05:32.032 --> 00:05:34.668 align:middle line:90%,end
<c.magenta>以了解</c>
<c.magenta>其底层工作机制</c>

00:05:36.170 --> 00:05:37.404 align:middle line:90%,end
<c.magenta>在这个例子中</c>

00:05:37.471 --> 00:05:39.139 align:middle line:90%,end
<c.magenta>我们创建一个新可变数组</c>

00:05:39.740 --> 00:05:42.142 align:middle line:90%,end
<c.magenta>创建之后</c>

00:05:42.209 --> 00:05:46.246 align:middle line:90%,end
<c.magenta>我们得到一个COW后备存储</c>
<c.magenta>其存储项目数量为零</c>

00:05:47.047 --> 00:05:51.952 align:middle line:90%,end
<c.magenta>我们需要做一些工作</c>
<c.magenta>在应用中 我们进行复制</c>

00:05:52.653 --> 00:05:56.089 align:middle line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>我们分配B 作为A的副本</c>

00:05:56.657 --> 00:05:59.026 align:middle line:90%,end
<c.magenta>发生复制时</c>

00:05:59.126 --> 00:06:01.895 align:middle line:90%,end
<c.magenta>在应用中</c>
<c.magenta>只有付款价格</c>

00:05:59.126 --> 00:06:01.895 align:middle line:90%,end
<c.magenta>在应用中</c>
<c.magenta>只有付款价格</c>

00:06:02.129 --> 00:06:04.932 align:middle line:90%,end
<c.magenta>是分配新集合</c>

00:06:05.265 --> 00:06:07.568 align:middle line:90%,end
<c.magenta>实际上 你不必复制</c>
<c.magenta>任何项目</c>

00:06:07.835 --> 00:06:11.138 align:middle line:90%,end
<c.magenta>因此在本例中 我们仍然指向</c>
<c.magenta>相同的后备存储</c>

00:06:11.338 --> 00:06:13.473 align:middle line:90%,end
<c.magenta>存储项目数量为零</c>

00:06:14.241 --> 00:06:17.411 align:middle line:10%
<c.magenta>以后</c>
<c.magenta>如果我们想要进行变更</c>

00:06:17.711 --> 00:06:21.615 align:middle line:10%
<c.magenta>所发生的情况是</c>
<c.magenta>复制方</c>

00:06:21.982 --> 00:06:25.953 align:middle line:10%
<c.magenta>获得一个指向共享</c>
<c.magenta>后备存储的引用</c>

00:06:26.253 --> 00:06:27.821 align:middle line:10%
<c.magenta>为了进行变更</c>

00:06:27.888 --> 00:06:30.090 align:middle line:10%
<c.magenta>必须从后备存储进行复制</c>

00:06:30.324 --> 00:06:33.093 align:middle line:10%
<c.magenta>以确保</c>
<c.magenta>变更是安全的</c>

00:06:34.361 --> 00:06:36.396 align:middle line:90%,end
<c.magenta>但是你必须考虑</c>

00:06:36.463 --> 00:06:39.800 align:middle line:90%,end
<c.magenta>大多数应用</c>
<c.magenta>将会到此为止</c>

00:06:39.867 --> 00:06:43.170 align:middle line:90%,end
<c.magenta>而不再进行</c>
<c.magenta>进一步的变更</c>

00:06:43.637 --> 00:06:45.172 align:middle line:90%,end
<c.magenta>因此你可以看到</c>

00:06:45.239 --> 00:06:48.075 align:middle line:90%,end
<c.magenta>利用此功能</c>
<c.magenta>性能将会得到</c>

00:06:48.141 --> 00:06:51.445 align:middle line:90%,end
<c.magenta>大幅的提升</c>

00:06:52.279 --> 00:06:54.681 align:middle line:90%,end
<c.magenta>现在 让我们来看</c>
<c.magenta>如何在你的应用中</c>

00:06:54.748 --> 00:06:55.983 align:middle line:90%,end
<c.magenta>使用这项技术</c>

00:06:56.917 --> 00:06:59.019 align:middle line:90%,end
<c.magenta>假设我是一名开发者</c>

00:06:59.319 --> 00:07:01.822 align:middle line:90%,end
<c.magenta>我编写这样的代码 并附有注释</c>

00:06:59.319 --> 00:07:01.822 align:middle line:90%,end
<c.magenta>我编写这样的代码 并附有注释</c>

00:07:02.189 --> 00:07:05.759 align:middle line:90%,end
<c.magenta>希望我的同事</c>
<c.magenta>能够听从我的建议</c>

00:07:05.826 --> 00:07:07.828 align:middle line:90%,end
<c.magenta>以提升性能</c>

00:07:08.295 --> 00:07:10.397 align:middle line:90%,end
<c.magenta>但是这里有一个小陷阱</c>

00:07:10.664 --> 00:07:13.634 align:middle line:90%,end
<c.magenta>如果需要用到</c>
<c.magenta>可变数组</c>

00:07:13.901 --> 00:07:16.370 align:middle line:90%,end
<c.magenta>那么可能将会</c>
<c.magenta>共享可变状态</c>

00:07:16.436 --> 00:07:18.639 align:middle line:90%,end
<c.magenta>这意味着</c>
<c.magenta>将会共享漏洞</c>

00:07:18.972 --> 00:07:20.174 align:middle line:90%,end
<c.magenta>这不是我们想要的</c>

00:07:20.774 --> 00:07:23.343 align:middle line:90%,end
<c.magenta>由于现在复制不会占用资源</c>

00:07:23.577 --> 00:07:25.913 align:middle line:90%,end
<c.magenta>因此每次都可以进行同样的操作</c>

00:07:25.979 --> 00:07:27.981 align:middle line:90%,end
<c.magenta>而不必担心</c>
<c.magenta>性能降低</c>

00:07:28.715 --> 00:07:29.550 align:middle line:90%,end
<c.magenta>这非常不错</c>

00:07:30.484 --> 00:07:32.920 align:middle line:90%,end
<c.magenta>这不仅仅是资产的</c>
<c.magenta>复制性质</c>

00:07:33.220 --> 00:07:36.056 align:middle line:90%,end
<c.magenta>很多情况下 可变容器</c>
<c.magenta>用于构建工作</c>

00:07:36.557 --> 00:07:40.294 align:middle line:90%,end
<c.magenta>在这个例子中</c>
<c.magenta>开发者知道NSMutableArray是</c>

00:07:40.360 --> 00:07:41.995 align:middle line:90%,end
<c.magenta>NSArray的一个子类</c>

00:07:42.462 --> 00:07:45.632 align:middle line:90%,end
<c.magenta>其返回值是</c>
<c.magenta>一个NSArray</c>

00:07:45.732 --> 00:07:48.135 align:middle line:90%,end
<c.magenta>这应该很安全 是吧？</c>

00:07:48.735 --> 00:07:51.471 align:middle line:90%,end
<c.magenta>但不幸的是</c>
<c.magenta>这里也可能</c>

00:07:51.538 --> 00:07:53.073 align:middle line:90%,end
<c.magenta>存在一些后果</c>

00:07:53.340 --> 00:07:56.243 align:middle line:90%,end
<c.magenta>如果我们查看</c>
<c.magenta>返回类型的实际类</c>

00:07:56.543 --> 00:07:57.477 align:middle line:90%,end
<c.magenta>情况不妙</c>

00:07:57.544 --> 00:08:00.380 align:middle line:90%,end
<c.magenta>它们可能具有</c>
<c.magenta>共享的变更状态</c>

00:07:57.544 --> 00:08:00.380 align:middle line:90%,end
<c.magenta>它们可能具有</c>
<c.magenta>共享的变更状态</c>

00:08:00.914 --> 00:08:04.751 align:middle line:90%,end
<c.magenta>因此</c>
<c.magenta>你可以保护性地复制返回值</c>

00:08:04.985 --> 00:08:06.486 align:middle line:90%,end
<c.magenta>确保获得正确的结果</c>

00:08:06.553 --> 00:08:09.189 align:middle line:90%,end
<c.magenta>而不必担心</c>
<c.magenta>性能开销</c>

00:08:10.390 --> 00:08:14.628 align:middle line:90%,end
<c.magenta>还有另一个例子</c>
<c.magenta>看上去更隐蔽</c>

00:08:14.862 --> 00:08:15.929 align:middle line:90%,end
<c.magenta>在Swift中</c>

00:08:16.864 --> 00:08:20.133 align:middle line:90%,end
<c.magenta>无论何时</c>
<c.magenta>导出这两个API</c>

00:08:20.400 --> 00:08:24.438 align:middle line:90%,end
<c.magenta>都必须进行复制</c>
<c.magenta>以保留值类型</c>

00:08:24.905 --> 00:08:27.808 align:middle line:90%,end
<c.magenta>如果你将数据转换为</c>

00:08:27.875 --> 00:08:30.611 align:middle line:90%,end
<c.magenta>任何NSArray类型</c>
<c.magenta>以使用这两个API中的任意一个</c>

00:08:30.744 --> 00:08:32.312 align:middle line:90%,end
<c.magenta>以前的实现</c>

00:08:32.379 --> 00:08:35.582 align:middle line:90%,end
<c.magenta>必须花费</c>
<c.magenta>线性执行时间</c>

00:08:35.649 --> 00:08:37.017 align:middle line:90%,end
<c.magenta>才能够进行复制</c>

00:08:37.417 --> 00:08:39.119 align:middle line:90%,end
<c.magenta>如果使用保护性的方法</c>

00:08:39.520 --> 00:08:42.655 align:middle line:90%,end
<c.magenta>复制将不会</c>
<c.magenta>占用资源</c>

00:08:42.722 --> 00:08:45.392 align:middle line:90%,end
<c.magenta>因此不会降低性能</c>

00:08:47.661 --> 00:08:48.795 align:middle line:90%,end
<c.magenta>在Swift 3中</c>

00:08:49.296 --> 00:08:52.766 align:middle line:90%,end
<c.magenta>我们为Foundation</c>
<c.magenta>引入多个结构化的类型</c>

00:08:53.267 --> 00:08:55.602 align:middle line:90%,end
<c.magenta>这种做法</c>

00:08:55.669 --> 00:08:58.639 align:middle line:90%,end
<c.magenta>将NSData引导向</c>
<c.magenta>结构型数据</c>

00:08:59.439 --> 00:09:01.675 align:middle line:90%,end
<c.magenta>我们对数据进行大量研究</c>

00:08:59.439 --> 00:09:01.675 align:middle line:90%,end
<c.magenta>我们对数据进行大量研究</c>

00:09:01.742 --> 00:09:04.378 align:middle line:90%,end
<c.magenta>理解常见的用例</c>

00:09:04.444 --> 00:09:06.513 align:middle line:90%,end
<c.magenta>和情况并改进数据</c>

00:09:06.580 --> 00:09:09.249 align:middle line:90%,end
<c.magenta>让它能够</c>
<c.magenta>在你们的应用中更好地工作</c>

00:09:09.917 --> 00:09:14.721 align:middle line:90%,end
<c.magenta>在这个版本中</c>
<c.magenta>数据现在拥有自己的类型</c>

00:09:14.788 --> 00:09:16.323 align:middle line:90%,end
<c.magenta>我们研究</c>

00:09:16.390 --> 00:09:18.926 align:middle line:90%,end
<c.magenta>在执行常见任务时的</c>
<c.magenta>性能水平</c>

00:09:19.026 --> 00:09:20.561 align:middle line:90%,end
<c.magenta>比如获取数据计数</c>

00:09:20.661 --> 00:09:23.730 align:middle line:90%,end
<c.magenta>偏移位置的</c>
<c.magenta>特定字节索引等</c>

00:09:24.631 --> 00:09:28.569 align:middle line:90%,end
<c.magenta>一些实现的情况</c>
<c.magenta>比较极端</c>

00:09:28.802 --> 00:09:32.472 align:middle line:90%,end
<c.magenta>一般来说 几行机器指令</c>
<c.magenta>并不能起多大的作用</c>

00:09:32.906 --> 00:09:35.776 align:middle line:90%,end
<c.magenta>但是 当表示</c>
<c.magenta>字节缓冲时</c>

00:09:36.176 --> 00:09:38.679 align:middle line:90%,end
<c.magenta>少数几行指令</c>

00:09:38.946 --> 00:09:40.547 align:middle line:90%,end
<c.magenta>就可能带来很大的变化</c>

00:09:41.982 --> 00:09:44.284 align:middle line:90%,end
<c.magenta>这段代码看上去非常简单</c>

00:09:45.719 --> 00:09:48.488 align:middle line:90%,end
<c.magenta>但是它具有</c>
<c.magenta>一些有趣的特性</c>

00:09:48.555 --> 00:09:51.792 align:middle line:90%,end
<c.magenta>揭示我们可以</c>
<c.magenta>如何让数据变得更快</c>

00:09:52.593 --> 00:09:55.762 align:middle line:90%,end
<c.magenta>首先 数据是一个集合</c>
<c.magenta>如同数据一样</c>

00:09:55.929 --> 00:09:59.066 align:middle line:90%,end
<c.magenta>它可以具有标注</c>
<c.magenta>包括索引和范围</c>

00:09:59.633 --> 00:10:02.769 align:middle line:90%,end
<c.magenta>因此 这意味着</c>
<c.magenta>数据的起始索引</c>

00:09:59.633 --> 00:10:02.769 align:middle line:90%,end
<c.magenta>因此 这意味着</c>
<c.magenta>数据的起始索引</c>

00:10:03.003 --> 00:10:04.605 align:middle line:90%,end
<c.magenta>不一定是零</c>

00:10:04.872 --> 00:10:08.609 align:middle line:90%,end
<c.magenta>索引类似于</c>
<c.magenta>其它语言中的迭代器</c>

00:10:09.042 --> 00:10:11.545 align:middle line:90%,end
<c.magenta>这段代码</c>
<c.magenta>并没有什么问题</c>

00:10:12.312 --> 00:10:14.147 align:middle line:90%,end
<c.magenta>我们使用它来帮助理解</c>

00:10:14.214 --> 00:10:16.283 align:middle line:90%,end
<c.magenta>需要改进数据的哪些部分</c>

00:10:16.783 --> 00:10:19.086 align:middle line:90%,end
<c.magenta>这里的两个问题是</c>

00:10:19.453 --> 00:10:21.321 align:middle line:90%,end
<c.magenta>所要处理的数据量是多少</c>

00:10:21.488 --> 00:10:23.524 align:middle line:90%,end
<c.magenta>另外 调用次数是多少？</c>

00:10:23.957 --> 00:10:25.425 align:middle line:90%,end
<c.magenta>其性能水平位于哪个象限？</c>

00:10:26.193 --> 00:10:30.330 align:middle line:90%,end
<c.magenta>正确的答案是</c>
<c.magenta>性能水平可能会位于任意象限</c>

00:10:30.797 --> 00:10:34.334 align:middle line:90%,end
<c.magenta>最可能的情况是</c>
<c.magenta>我们需要分析性能水平</c>

00:10:34.935 --> 00:10:36.970 align:middle line:90%,end
<c.magenta>我们的确这样做了</c>

00:10:38.372 --> 00:10:40.207 align:middle line:90%,end
<c.magenta>上方的蓝色曲线</c>

00:10:40.274 --> 00:10:42.543 align:middle line:90%,end
<c.magenta>表示初始的Swift 3 Data版本</c>

00:10:43.043 --> 00:10:48.048 align:middle line:90%,end
<c.magenta>进行标注时</c>
<c.magenta>用时约为16纳秒</c>

00:10:48.115 --> 00:10:51.118 align:middle line:90%,end
<c.magenta>这是在我进行分析时</c>
<c.magenta>所使用的计算机上的结果</c>

00:10:51.919 --> 00:10:57.157 align:middle line:90%,end
<c.magenta>由于处理数据</c>
<c.magenta>实际上是处理字节集合</c>

00:10:57.491 --> 00:11:00.294 align:middle line:90%,end
<c.magenta>因此速度应该非常快</c>

00:10:57.491 --> 00:11:00.294 align:middle line:90%,end
<c.magenta>因此速度应该非常快</c>

00:11:00.961 --> 00:11:04.698 align:middle line:90%,end
<c.magenta>经过改进之后</c>
<c.magenta>用时降低为4纳秒</c>

00:11:04.865 --> 00:11:05.899 align:middle line:90%,end
<c.magenta>提升非常明显</c>

00:11:06.433 --> 00:11:08.902 align:middle line:90%,end
<c.magenta>如果你以前曾经使用Data</c>

00:11:09.236 --> 00:11:11.538 align:middle line:90%,end
<c.magenta>就可以知道其优点</c>

00:11:12.172 --> 00:11:14.808 align:middle line:90%,end
<c.magenta>它将能够与</c>

00:11:14.942 --> 00:11:18.111 align:middle line:90%,end
<c.magenta>获取和使用Data的</c>
<c.magenta>所有其余API进行互操作</c>

00:11:20.714 --> 00:11:21.548 align:middle line:90%,end
<c.magenta>谢谢</c>

00:11:23.817 --> 00:11:26.687 align:middle line:90%,end
<c.magenta>需要提醒你们的是</c>

00:11:26.753 --> 00:11:30.090 align:middle line:90%,end
<c.magenta>这些例子</c>
<c.magenta>都没有明显的错误或缺点</c>

00:11:30.257 --> 00:11:32.759 align:middle line:90%,end
<c.magenta>但是 它们确实</c>
<c.magenta>在某些方面</c>

00:11:32.993 --> 00:11:34.695 align:middle line:90%,end
<c.magenta>还需要改进</c>

00:11:35.729 --> 00:11:38.398 align:middle line:90%,end
<c.magenta>通常 我们认为</c>
<c.magenta>字节集合</c>

00:11:38.465 --> 00:11:39.766 align:middle line:90%,end
<c.magenta>可以用数组表示</c>

00:11:39.833 --> 00:11:42.436 align:middle line:90%,end
<c.magenta>对于少量数据 确实可以</c>

00:11:42.536 --> 00:11:43.704 align:middle line:90%,end
<c.magenta>工作也很正常</c>

00:11:44.104 --> 00:11:46.473 align:middle line:90%,end
<c.magenta>但是 从某种角度来说</c>

00:11:46.540 --> 00:11:50.344 align:middle line:90%,end
<c.magenta>这也存在隐藏的开销</c>
<c.magenta>比如当你写入文件时</c>

00:11:51.111 --> 00:11:52.312 align:middle line:90%,end
<c.magenta>会增加复杂性</c>

00:11:52.379 --> 00:11:54.047 align:middle line:90%,end
<c.magenta>有很多这样的边界例子</c>

00:11:54.181 --> 00:11:55.782 align:middle line:90%,end
<c.magenta>我们已经考虑到这一点</c>

00:11:56.049 --> 00:11:58.986 align:middle line:90%,end
<c.magenta>由于能够进行互操作</c>
<c.magenta>比如写文件</c>

00:11:59.052 --> 00:12:02.789 align:middle line:90%,end
<c.magenta>转换成为基本C4</c>
<c.magenta>Data具有明显的优势</c>

00:11:59.052 --> 00:12:02.789 align:middle line:90%,end
<c.magenta>转换成为基本C4</c>
<c.magenta>Data具有明显的优势</c>

00:12:04.124 --> 00:12:06.693 align:middle line:90%,end
<c.magenta>有时候我们更喜欢老做法</c>

00:12:06.760 --> 00:12:10.464 align:middle line:90%,end
<c.magenta>使用可靠的malloc方法</c>

00:12:10.864 --> 00:12:12.733 align:middle line:90%,end
<c.magenta>不幸的是</c>

00:12:12.833 --> 00:12:16.069 align:middle line:90%,end
<c.magenta>这可能会错失</c>
<c.magenta>其它一些优化机会</c>

00:12:16.236 --> 00:12:19.006 align:middle line:90%,end
<c.magenta>比如</c>
<c.magenta>可以自动分配合适的内存</c>

00:12:19.072 --> 00:12:21.708 align:middle line:90%,end
<c.magenta>而不需要</c>
<c.magenta>估算malloc 将多少内存</c>

00:12:21.775 --> 00:12:24.311 align:middle line:90%,end
<c.magenta>交回给缓冲区</c>

00:12:25.179 --> 00:12:27.281 align:middle line:90%,end
<c.magenta>Data为你完成所有这些工作</c>

00:12:27.347 --> 00:12:29.950 align:middle line:90%,end
<c.magenta>你不必担心</c>
<c.magenta>重分配问题</c>

00:12:30.017 --> 00:12:33.220 align:middle line:90%,end
<c.magenta>你不必担心</c>
<c.magenta>边界例子</c>

00:12:33.287 --> 00:12:36.924 align:middle line:90%,end
<c.magenta>比如</c>
<c.magenta>malloc应该分配多少内存</c>

00:12:39.159 --> 00:12:42.563 align:middle line:90%,end
<c.magenta>这两行代码</c>
<c.magenta>非常相似</c>

00:12:42.796 --> 00:12:44.598 align:middle line:90%,end
<c.magenta>但是它们用处不大</c>

00:12:44.798 --> 00:12:46.567 align:middle line:90%,end
<c.magenta>在某些情况</c>

00:12:46.633 --> 00:12:49.536 align:middle line:90%,end
<c.magenta>你需要能够处理</c>
<c.magenta>大型数据区域</c>

00:12:49.770 --> 00:12:51.071 align:middle line:90%,end
<c.magenta>另一些情况下</c>

00:12:51.138 --> 00:12:54.441 align:middle line:90%,end
<c.magenta>你想要能够</c>
<c.magenta>保留一部分数据</c>

00:12:55.108 --> 00:12:56.944 align:middle line:90%,end
<c.magenta>因此 Data有两个API</c>

00:12:57.010 --> 00:12:59.012 align:middle line:90%,end
<c.magenta>其中一个是Subdata</c>
<c.magenta>有范围参数</c>

00:12:59.146 --> 00:13:00.647 align:middle line:90%,end
<c.magenta>它创建一个副本</c>

00:12:59.146 --> 00:13:00.647 align:middle line:90%,end
<c.magenta>它创建一个副本</c>

00:13:00.714 --> 00:13:03.283 align:middle line:90%,end
<c.magenta>如果你需要</c>
<c.magenta>处理大文件</c>

00:13:03.450 --> 00:13:05.819 align:middle line:90%,end
<c.magenta>而只想保留其中一部分</c>

00:13:06.119 --> 00:13:09.656 align:middle line:90%,end
<c.magenta>带有范围参数的Subdata</c>
<c.magenta>将进行强制复制 像这样</c>

00:13:10.424 --> 00:13:13.894 align:middle line:90%,end
<c.magenta>我们已经更改Data</c>
<c.magenta>使它成为自己的子类型</c>

00:13:14.061 --> 00:13:16.997 align:middle line:90%,end
<c.magenta>或类型的子集</c>

00:13:17.331 --> 00:13:19.566 align:middle line:90%,end
<c.magenta>无论你是否使用范围语法</c>

00:13:19.633 --> 00:13:22.002 align:middle line:90%,end
<c.magenta>举例来说 即使有这样的范围</c>

00:13:22.803 --> 00:13:26.673 align:middle line:90%,end
<c.magenta>你也可以将它用作窗口</c>
<c.magenta>来了解你的数据量</c>

00:13:26.940 --> 00:13:29.309 align:middle line:90%,end
<c.magenta>如果你需要</c>
<c.magenta>处理大文件</c>

00:13:29.376 --> 00:13:31.378 align:middle line:90%,end
<c.magenta>只需要进行分析</c>

00:13:31.578 --> 00:13:34.214 align:middle line:90%,end
<c.magenta>而且数据本身</c>
<c.magenta>将是临时性的</c>

00:13:34.615 --> 00:13:38.318 align:middle line:90%,end
<c.magenta>然后 使用数据片段</c>
<c.magenta>是一种非常高效的方法</c>

00:13:38.385 --> 00:13:41.288 align:middle line:90%,end
<c.magenta>让你轻松地访问数据</c>
<c.magenta>因为它无需进行复制</c>

00:13:43.557 --> 00:13:46.560 align:middle line:90%,end
<c.magenta>我们多次</c>
<c.magenta>谈到桥接</c>

00:13:46.793 --> 00:13:50.631 align:middle line:90%,end
<c.magenta>这里我们需要</c>
<c.magenta>了解两种类型的桥接</c>

00:13:51.498 --> 00:13:55.135 align:middle line:90%,end
<c.magenta>在右侧</c>
<c.magenta>是无资源开销桥接</c>

00:13:55.669 --> 00:13:57.437 align:middle line:90%,end
<c.magenta>在这些例子中</c>

00:13:57.638 --> 00:13:59.806 align:middle line:90%,end
<c.magenta>它们将Foundation类型</c>

00:13:59.907 --> 00:14:01.308 align:middle line:90%,end
<c.magenta>桥接到Core Foundation类型</c>

00:13:59.907 --> 00:14:01.308 align:middle line:90%,end
<c.magenta>桥接到Core Foundation类型</c>

00:14:01.842 --> 00:14:04.511 align:middle line:90%,end
<c.magenta>或者从Foundation类型</c>
<c.magenta>桥接到Core Foundation类型</c>

00:14:05.212 --> 00:14:09.183 align:middle line:90%,end
<c.magenta>在转换过程中不会产生开销</c>

00:14:09.383 --> 00:14:11.818 align:middle line:90%,end
<c.magenta>因此 在这个例子中</c>
<c.magenta>所做的工作是</c>

00:14:11.885 --> 00:14:15.489 align:middle line:90%,end
<c.magenta>将NSArray桥接到CFArray</c>

00:14:16.123 --> 00:14:18.525 align:middle line:90%,end
<c.magenta>这只是重新解释指针</c>

00:14:19.359 --> 00:14:22.529 align:middle line:90%,end
<c.magenta>但是这里有少量的资源开销</c>

00:14:22.663 --> 00:14:27.801 align:middle line:90%,end
<c.magenta>当你传递对象</c>
<c.magenta>到CFArrayGetCount时</c>

00:14:28.502 --> 00:14:30.304 align:middle line:90%,end
<c.magenta>你会得到一些东西</c>

00:14:30.537 --> 00:14:32.306 align:middle line:90%,end
<c.magenta>我们将会</c>
<c.magenta>稍作了解</c>

00:14:33.340 --> 00:14:37.711 align:middle line:90%,end
<c.magenta>在Swift桥接中</c>
<c.magenta>有些情况下</c>

00:14:37.778 --> 00:14:40.013 align:middle line:90%,end
<c.magenta>你需要</c>
<c.magenta>将引用类型</c>

00:14:40.080 --> 00:14:41.415 align:middle line:90%,end
<c.magenta>桥接到结构类型</c>

00:14:42.382 --> 00:14:44.551 align:middle line:90%,end
<c.magenta>或者也可以</c>

00:14:44.685 --> 00:14:47.521 align:middle line:90%,end
<c.magenta>从结构类型</c>
<c.magenta>桥接到引用类型</c>

00:14:48.956 --> 00:14:52.793 align:middle line:90%,end
<c.magenta>但是这些例子中的</c>
<c.magenta>资源开销已经预先提供</c>

00:14:52.960 --> 00:14:55.229 align:middle line:90%,end
<c.magenta>因此 无论何时从Objective-C导入</c>

00:14:55.395 --> 00:14:58.365 align:middle line:90%,end
<c.magenta>或者 在本例中</c>
<c.magenta>使用as？</c>

00:14:58.599 --> 00:15:00.601 align:middle line:90%,end
<c.magenta>在二者之间进行转换</c>

00:14:58.599 --> 00:15:00.601 align:middle line:90%,end
<c.magenta>在二者之间进行转换</c>

00:15:00.767 --> 00:15:03.003 align:middle line:90%,end
<c.magenta>这时会产生开销</c>

00:15:04.538 --> 00:15:06.540 align:middle line:90%,end
<c.magenta>但是区别在于</c>

00:15:06.607 --> 00:15:09.943 align:middle line:90%,end
<c.magenta>这些开销</c>
<c.magenta>是正常的资源开销</c>

00:15:10.944 --> 00:15:12.513 align:middle line:90%,end
<c.magenta>让我们来深入了解</c>

00:15:12.779 --> 00:15:14.214 align:middle line:90%,end
<c.magenta>我知道这看上去有点吓人/b&gt;</c>

00:15:14.648 --> 00:15:16.383 align:middle line:90%,end
<c.magenta>如果不使用写时复制</c>
<c.magenta>事实上</c>

00:15:16.450 --> 00:15:17.518 align:middle line:90%,end
<c.magenta>这并不会…</c>

00:15:17.584 --> 00:15:19.853 align:middle line:90%,end
<c.magenta>CFArray 并不实现写时复制</c>

00:15:21.054 --> 00:15:24.791 align:middle line:90%,end
<c.magenta>但是当你传递</c>
<c.magenta>一个NSArray或子类</c>

00:15:24.858 --> 00:15:26.793 align:middle line:90%,end
<c.magenta>到CFArrayGetCount时</c>

00:15:27.127 --> 00:15:30.731 align:middle line:90%,end
<c.magenta>它将魔术般地</c>
<c.magenta>调出这个Objective-C 方法count</c>

00:15:31.532 --> 00:15:33.233 align:middle line:90%,end
<c.magenta>让我们来进一步</c>
<c.magenta>并进行分析</c>

00:15:33.300 --> 00:15:36.370 align:middle line:90%,end
<c.magenta>弄清楚这与</c>
<c.magenta>Swift桥接之间的区别</c>

00:15:38.906 --> 00:15:40.841 align:middle line:90%,end
<c.magenta>这里进行了简化</c>

00:15:41.141 --> 00:15:44.645 align:middle line:90%,end
<c.magenta>首先 我们使用数组</c>
<c.magenta>和Objective-C子类</c>

00:15:44.912 --> 00:15:47.247 align:middle line:90%,end
<c.magenta>我们发现</c>
<c.magenta>将执行计数方法</c>

00:15:47.648 --> 00:15:51.485 align:middle line:90%,end
<c.magenta>如果不是 我们会知道</c>
<c.magenta>对象的结构化部分</c>

00:15:51.618 --> 00:15:54.788 align:middle line:90%,end
<c.magenta>我们获得</c>
<c.magenta>可变数量</c>

00:15:56.523 --> 00:15:58.258 align:middle line:90%,end
<c.magenta>让我们更深入地分析</c>

00:15:58.926 --> 00:16:00.994 align:middle line:90%,end
<c.magenta>它检查</c>
<c.magenta>对象的内部布局</c>

00:15:58.926 --> 00:16:00.994 align:middle line:90%,end
<c.magenta>它检查</c>
<c.magenta>对象的内部布局</c>

00:16:01.061 --> 00:16:02.996 align:middle line:90%,end
<c.magenta>参照预期的类表</c>

00:16:03.230 --> 00:16:04.097 align:middle line:90%,end
<c.magenta>因此 事实上</c>

00:16:04.831 --> 00:16:07.467 align:middle line:90%,end
<c.magenta>它会进行</c>
<c.magenta>两次重导向</c>

00:16:07.534 --> 00:16:09.336 align:middle line:90%,end
<c.magenta>和一次函数调用 以确定</c>

00:16:09.403 --> 00:16:12.906 align:middle line:90%,end
<c.magenta>是否需调用</c>
<c.magenta>Objective-C子类方法</c>

00:16:12.973 --> 00:16:14.908 align:middle line:90%,end
<c.magenta>Objective-C方法</c>

00:16:16.343 --> 00:16:17.945 align:middle line:90%,end
<c.magenta>让我们进行总结</c>

00:16:18.111 --> 00:16:22.616 align:middle line:90%,end
<c.magenta>转换为数组</c>
<c.magenta>或 CFArray子类</c>

00:16:22.683 --> 00:16:25.185 align:middle line:90%,end
<c.magenta>仅仅是重新解释指针</c>

00:16:25.819 --> 00:16:28.922 align:middle line:90%,end
<c.magenta>其使用过程</c>
<c.magenta>会占用资源</c>

00:16:29.823 --> 00:16:32.726 align:middle line:90%,end
<c.magenta>但是这只会产生</c>
<c.magenta>较小的性能影响</c>

00:16:32.993 --> 00:16:37.030 align:middle line:90%,end
<c.magenta>但是在极少数情况</c>
<c.magenta>也可能产生较大影响</c>

00:16:37.397 --> 00:16:39.967 align:middle line:90%,end
<c.magenta>因此 性能水平可能</c>

00:16:40.033 --> 00:16:42.970 align:middle line:90%,end
<c.magenta>位于第三象限</c>
<c.magenta>可能位于比较向上的位置</c>

00:16:44.905 --> 00:16:48.242 align:middle line:90%,end
<c.magenta>现在 我们来看另一种做法</c>
<c.magenta>我们使用Swift桥接</c>

00:16:48.609 --> 00:16:52.112 align:middle line:90%,end
<c.magenta>请记住</c>
<c.magenta>无论何时调用as？</c>

00:16:52.312 --> 00:16:54.648 align:middle line:90%,end
<c.magenta>或者使用Objective-C API</c>

00:16:55.082 --> 00:16:57.284 align:middle line:90%,end
<c.magenta>无论何时使用桥接引用类型</c>

00:16:57.918 --> 00:17:01.655 align:middle line:90%,end
<c.magenta>编译器将会</c>
<c.magenta>使用可桥接函数族</c>

00:16:57.918 --> 00:17:01.655 align:middle line:90%,end
<c.magenta>编译器将会</c>
<c.magenta>使用可桥接函数族</c>

00:17:01.855 --> 00:17:04.458 align:middle line:90%,end
<c.magenta>反过来</c>
<c.magenta>在这个例子中</c>

00:17:04.525 --> 00:17:06.859 align:middle line:90%,end
<c.magenta>为Data调用</c>
<c.magenta>引用初始化函数</c>

00:17:08.262 --> 00:17:11.265 align:middle line:90%,end
<c.magenta>当Data初始化时</c>

00:17:11.464 --> 00:17:12.965 align:middle line:90%,end
<c.magenta>将会将存储数据</c>

00:17:13.099 --> 00:17:16.136 align:middle line:90%,end
<c.magenta>复制到数据的</c>
<c.magenta>后备存储</c>

00:17:16.270 --> 00:17:18.539 align:middle line:90%,end
<c.magenta>我们不仅需要保留</c>

00:17:18.605 --> 00:17:21.441 align:middle line:90%,end
<c.magenta>数据的</c>
<c.magenta>值类型属性</c>

00:17:21.642 --> 00:17:22.675 align:middle line:90%,end
<c.magenta>而且必须确保</c>

00:17:22.742 --> 00:17:25.412 align:middle line:90%,end
<c.magenta>我们不会使用</c>
<c.magenta>共享可变引用</c>

00:17:25.546 --> 00:17:27.214 align:middle line:90%,end
<c.magenta>因为这会产生漏洞</c>

00:17:28.080 --> 00:17:31.785 align:middle line:90%,end
<c.magenta>你可以看到</c>
<c.magenta>如果这是可变数据</c>

00:17:31.852 --> 00:17:34.354 align:middle line:90%,end
<c.magenta>或代理或其他子类</c>

00:17:34.821 --> 00:17:38.125 align:middle line:90%,end
<c.magenta>这可能是一个</c>
<c.magenta>隐藏的资源开销点</c>

00:17:39.660 --> 00:17:41.828 align:middle line:90%,end
<c.magenta>我们完成所有桥接</c>

00:17:41.895 --> 00:17:43.330 align:middle line:90%,end
<c.magenta>再来看性能图</c>

00:17:44.164 --> 00:17:46.733 align:middle line:90%,end
<c.magenta>这次</c>

00:17:46.800 --> 00:17:49.603 align:middle line:90%,end
<c.magenta>桥接并没有占用过多资源</c>

00:17:49.736 --> 00:17:52.840 align:middle line:90%,end
<c.magenta>通常情况下</c>

00:17:53.207 --> 00:17:55.509 align:middle line:90%,end
<c.magenta>仅复制限定的部分</c>

00:17:55.809 --> 00:17:58.645 align:middle line:90%,end
<c.magenta>因此 性能水平</c>
<c.magenta>可能仍然位于第三象限</c>

00:17:59.279 --> 00:18:02.749 align:middle line:90%,end
<c.magenta>但是 对于子类之外的</c>
<c.magenta>其他情况</c>

00:17:59.279 --> 00:18:02.749 align:middle line:90%,end
<c.magenta>但是 对于子类之外的</c>
<c.magenta>其他情况</c>

00:18:02.816 --> 00:18:04.484 align:middle line:90%,end
<c.magenta>比如可变数据</c>

00:18:04.551 --> 00:18:08.288 align:middle line:90%,end
<c.magenta>复制可能导致</c>
<c.magenta>性能水平位于任意象限</c>

00:18:08.589 --> 00:18:11.959 align:middle line:90%,end
<c.magenta>因此 如果你需要</c>
<c.magenta>处理子类</c>

00:18:12.226 --> 00:18:16.230 align:middle line:90%,end
<c.magenta>或者在桥接之间</c>
<c.magenta>来回传递可变数据</c>

00:18:16.763 --> 00:18:19.333 align:middle line:90%,end
<c.magenta>你应该结合这些有用的范例</c>

00:18:19.399 --> 00:18:22.336 align:middle line:90%,end
<c.magenta>利用更好的测量参数</c>
<c.magenta>理解性能水平</c>

00:18:23.337 --> 00:18:26.773 align:middle line:90%,end
<c.magenta>这种模式</c>
<c.magenta>不仅适用于Data</c>

00:18:26.874 --> 00:18:29.743 align:middle line:90%,end
<c.magenta>也适用于Swift中的</c>
<c.magenta>所有结构类型</c>

00:18:29.977 --> 00:18:32.946 align:middle line:90%,end
<c.magenta>比如数组</c>
<c.magenta>字典 字符串</c>

00:18:33.380 --> 00:18:36.650 align:middle line:90%,end
<c.magenta>说到字符串</c>
<c.magenta>我听说它们非常受欢迎</c>

00:18:37.317 --> 00:18:38.151 align:middle line:90%,end
<c.magenta>接下来</c>

00:18:38.218 --> 00:18:42.956 align:middle line:90%,end
<c.magenta>唐娜将会和大家一起</c>
<c.magenta>讨论字符串、范围和文本</c>

00:18:48.428 --> 00:18:49.263 align:middle line:90%,end
<c.magenta>谢谢 菲力浦</c>

00:18:51.899 --> 00:18:52.900 align:middle line:90%,end
<c.magenta>字符串</c>

00:18:52.966 --> 00:18:55.269 align:middle line:90%,end
<c.magenta>可能是使用频率最高的</c>
<c.magenta>数据类型之一</c>

00:18:55.636 --> 00:18:56.737 align:middle line:90%,end
<c.magenta>如果你是应用开发者</c>

00:18:56.837 --> 00:18:58.739 align:middle line:90%,end
<c.magenta>你的应用在使用时</c>
<c.magenta>可能会创建</c>

00:18:58.805 --> 00:19:01.208 align:middle line:90%,end
<c.magenta>成百上千的</c>
<c.magenta>各种类型的字符串</c>

00:18:58.805 --> 00:19:01.208 align:middle line:90%,end
<c.magenta>成百上千的</c>
<c.magenta>各种类型的字符串</c>

00:19:01.742 --> 00:19:03.143 align:middle line:90%,end
<c.magenta>如果你是框架开发者</c>

00:19:03.210 --> 00:19:05.279 align:middle line:90%,end
<c.magenta>每次用户</c>
<c.magenta>调用我们的API</c>

00:19:05.445 --> 00:19:07.481 align:middle line:90%,end
<c.magenta>框架可能产生和更改字符串</c>

00:19:07.881 --> 00:19:09.850 align:middle line:90%,end
<c.magenta>这些字符串</c>
<c.magenta>可能会在你的框架边界之外</c>

00:19:10.017 --> 00:19:11.485 align:middle line:90%,end
<c.magenta>发生变化</c>

00:19:11.952 --> 00:19:13.987 align:middle line:90%,end
<c.magenta>字符串并不会单独使用</c>

00:19:14.188 --> 00:19:15.489 align:middle line:90%,end
<c.magenta>你需要与框架交互</c>

00:19:15.556 --> 00:19:17.157 align:middle line:90%,end
<c.magenta>利用字符串完成一些工作</c>

00:19:17.224 --> 00:19:20.527 align:middle line:90%,end
<c.magenta>无论分割</c>
<c.magenta>分组和组合</c>

00:19:20.727 --> 00:19:22.362 align:middle line:90%,end
<c.magenta>或是简单地在屏幕上呈现</c>

00:19:22.763 --> 00:19:26.266 align:middle line:90%,end
<c.magenta>你可能需要改进</c>
<c.magenta>你的应用或框架的性能</c>

00:19:26.333 --> 00:19:30.871 align:middle line:90%,end
<c.magenta>理解字符串、范围、</c>
<c.magenta>文本与框架之间的交互方式</c>

00:19:30.938 --> 00:19:33.874 align:middle line:90%,end
<c.magenta>在此理解基础上</c>
<c.magenta>选择合适的实现方法</c>

00:19:34.708 --> 00:19:36.777 align:middle line:90%,end
<c.magenta>在我们讨论</c>
<c.magenta>技术细节之前</c>

00:19:36.977 --> 00:19:37.978 align:middle line:90%,end
<c.magenta>我想回过头来</c>

00:19:38.045 --> 00:19:40.180 align:middle line:90%,end
<c.magenta>重复菲力浦讲过的一些内容</c>

00:19:40.314 --> 00:19:41.281 align:middle line:90%,end
<c.magenta>简要讨论</c>

00:19:41.348 --> 00:19:44.184 align:middle line:90%,end
<c.magenta>如何评价</c>
<c.magenta>性能改进的影响</c>

00:19:46.186 --> 00:19:48.822 align:middle line:90%,end
<c.magenta>很重要的一点是</c>
<c.magenta>当你思考如何改进性能时</c>

00:19:48.889 --> 00:19:50.524 align:middle line:90%,end
<c.magenta>你必须</c>
<c.magenta>着眼于大局</c>

00:19:51.325 --> 00:19:53.393 align:middle line:90%,end
<c.magenta>我们很容易</c>
<c.magenta>拘泥于细节</c>

00:19:53.560 --> 00:19:57.197 align:middle line:90%,end
<c.magenta>专注于优化</c>
<c.magenta>特定的方案</c>

00:19:57.364 --> 00:19:59.666 align:middle line:90%,end
<c.magenta>但是 如果方案不能反映</c>

00:19:59.733 --> 00:20:01.969 align:middle line:90%,end
<c.magenta>用户如何</c>
<c.magenta>使用你的应用框架</c>

00:19:59.733 --> 00:20:01.969 align:middle line:90%,end
<c.magenta>用户如何</c>
<c.magenta>使用你的应用框架</c>

00:20:02.336 --> 00:20:04.071 align:middle line:90%,end
<c.magenta>那么优化它们</c>
<c.magenta>将不会产生</c>

00:20:04.137 --> 00:20:05.172 align:middle line:90%,end
<c.magenta>多么大的作用</c>

00:20:06.039 --> 00:20:07.407 align:middle line:90%,end
<c.magenta>因此 如果你</c>

00:20:07.641 --> 00:20:10.377 align:middle line:90%,end
<c.magenta>使用的方案反映</c>
<c.magenta>实际的框架使用情况</c>

00:20:10.444 --> 00:20:13.247 align:middle line:90%,end
<c.magenta>你可以分析</c>
<c.magenta>特定代码段的性能</c>

00:20:13.614 --> 00:20:16.750 align:middle line:90%,end
<c.magenta>在做这项工作时你应该回忆</c>
<c.magenta>前面我们讲过的一些概念</c>

00:20:16.984 --> 00:20:18.785 align:middle line:90%,end
<c.magenta>我处理的数据量有多大？</c>

00:20:18.852 --> 00:20:20.487 align:middle line:90%,end
<c.magenta>代码的运行频率如何？</c>

00:20:21.955 --> 00:20:23.357 align:middle line:90%,end
<c.magenta>另外我们要使用性能象限图</c>

00:20:23.824 --> 00:20:26.560 align:middle line:10%
<c.magenta>但我们需要</c>
<c.magenta>对轴标签进行一些更改</c>

00:20:26.693 --> 00:20:28.095 align:middle line:10%
<c.magenta>以适用于字符串和文本</c>

00:20:28.562 --> 00:20:30.197 align:middle line:90%,end
<c.magenta>总体思想是相同的</c>

00:20:30.364 --> 00:20:31.465 align:middle line:90%,end
<c.magenta>但是对于字符串</c>

00:20:31.532 --> 00:20:33.734 align:middle line:90%,end
<c.magenta>我们需要考虑</c>
<c.magenta>字符串的长短</c>

00:20:33.867 --> 00:20:35.802 align:middle line:90%,end
<c.magenta>和代码的运行频率</c>

00:20:37.471 --> 00:20:39.740 align:middle line:90%,end
<c.magenta>在我们回顾这些主题时</c>
<c.magenta>我们应该记住</c>

00:20:39.806 --> 00:20:41.108 align:middle line:90%,end
<c.magenta>这些规模和频率概念</c>

00:20:42.543 --> 00:20:44.278 align:middle line:90%,end
<c.magenta>首先 让我们来看</c>
<c.magenta>字符串桥接</c>

00:20:45.012 --> 00:20:46.647 align:middle line:90%,end
<c.magenta>我们会讨论范围</c>

00:20:46.713 --> 00:20:48.315 align:middle line:90%,end
<c.magenta>和字符串索引的精妙之处</c>

00:20:48.949 --> 00:20:51.285 align:middle line:90%,end
<c.magenta>最后 我们将会分享一些技术</c>
<c.magenta>帮助你高效率地处理</c>

00:20:51.351 --> 00:20:53.787 align:middle line:90%,end
<c.magenta>文本布局</c>
<c.magenta>和AVKit及UIKit中的显示</c>

00:20:54.922 --> 00:20:56.390 align:middle line:90%,end
<c.magenta>我们先来看</c>
<c.magenta>字符串桥接</c>

00:20:58.025 --> 00:21:00.427 align:middle line:90%,end
<c.magenta>我们的第一个例子</c>
<c.magenta>是UILabel</c>

00:20:58.025 --> 00:21:00.427 align:middle line:90%,end
<c.magenta>我们的第一个例子</c>
<c.magenta>是UILabel</c>

00:21:02.095 --> 00:21:03.630 align:middle line:90%,end
<c.magenta>假设我有一个这样的标签</c>

00:21:03.697 --> 00:21:05.265 align:middle line:90%,end
<c.magenta>我想要访问它的文本</c>

00:21:07.267 --> 00:21:09.169 align:middle line:90%,end
<c.magenta>在Swift中</c>
<c.magenta>我想启动这样的界面</c>

00:21:10.103 --> 00:21:13.407 align:middle line:90%,end
<c.magenta>我们要求UIKit框架</c>
<c.magenta>提供标签的文本</c>

00:21:14.241 --> 00:21:16.543 align:middle line:90%,end
<c.magenta>因此 界面看起来是这样的</c>

00:21:18.178 --> 00:21:20.647 align:middle line:90%,end
<c.magenta>但是 请注意</c>
<c.magenta>这只是生成的界面</c>

00:21:20.781 --> 00:21:23.116 align:middle line:90%,end
<c.magenta>UILabel在Objective-C中实现</c>

00:21:24.685 --> 00:21:27.487 align:middle line:90%,end
<c.magenta>因此 虽然我们的可变文本</c>
<c.magenta>是一个Swift字符串</c>

00:21:27.754 --> 00:21:29.823 align:middle line:10%
<c.magenta>后备存储实际上是一个NSString</c>

00:21:29.890 --> 00:21:31.625 align:middle line:10%
<c.magenta>是从Objective-C桥接过来的</c>

00:21:33.527 --> 00:21:35.095 align:middle line:90%,end
<c.magenta>让我们来看看</c>
<c.magenta>当我们在Swift中</c>

00:21:35.162 --> 00:21:36.897 align:middle line:90%,end
<c.magenta>请求获取标签的文本时</c>
<c.magenta>将会发生什么</c>

00:21:38.265 --> 00:21:40.300 align:middle line:90%,end
<c.magenta>框架中的NSString</c>
<c.magenta>是一个引用类型</c>

00:21:40.767 --> 00:21:42.536 align:middle line:90%,end
<c.magenta>Swift的字符串是一个值类型</c>

00:21:43.103 --> 00:21:45.772 align:middle line:90%,end
<c.magenta>因此 如果我们向框架</c>
<c.magenta>请求那个NSString</c>

00:21:46.073 --> 00:21:48.542 align:middle line:90%,end
<c.magenta>当进行Swift桥接时</c>
<c.magenta>它被封装为值类型</c>

00:21:49.943 --> 00:21:53.347 align:middle line:90%,end
<c.magenta>但是 我们并不知道在桥接之后</c>
<c.magenta>初始NSString将会发生什么</c>

00:21:53.647 --> 00:21:55.849 align:middle line:90%,end
<c.magenta>为了保留Swift值语义</c>

00:21:55.983 --> 00:21:57.951 align:middle line:90%,end
<c.magenta>框架必须复制它</c>

00:21:58.919 --> 00:22:02.122 align:middle line:90%,end
<c.magenta>幸运的是 在本例中</c>
<c.magenta>初始NSString是不可变的</c>

00:21:58.919 --> 00:22:02.122 align:middle line:90%,end
<c.magenta>幸运的是 在本例中</c>
<c.magenta>初始NSString是不可变的</c>

00:22:02.356 --> 00:22:04.224 align:middle line:90%,end
<c.magenta>因此 当框架进行复制时</c>

00:22:04.291 --> 00:22:06.760 align:middle line:90%,end
<c.magenta>将经过优化</c>
<c.magenta>这并不需要很多开销</c>

00:22:06.827 --> 00:22:08.829 align:middle line:90%,end
<c.magenta>因为这只是增大引用数量</c>

00:22:11.965 --> 00:22:14.034 align:middle line:90%,end
<c.magenta>但是 如果我们</c>
<c.magenta>完整复制这个字符串</c>

00:22:14.168 --> 00:22:16.436 align:middle line:90%,end
<c.magenta>我们回到图表</c>
<c.magenta>来评价性能影响</c>

00:22:17.905 --> 00:22:20.974 align:middle line:90%,end
<c.magenta>在本例中 初始字符串</c>
<c.magenta>包含7个ASCII字符</c>

00:22:21.074 --> 00:22:23.010 align:middle line:90%,end
<c.magenta>即使进行完整复制</c>

00:22:23.844 --> 00:22:24.945 align:middle line:90%,end
<c.magenta>影响也是非常小的</c>

00:22:26.013 --> 00:22:27.281 align:middle line:90%,end
<c.magenta>大多数情况下 UILabel</c>

00:22:27.347 --> 00:22:28.949 align:middle line:90%,end
<c.magenta>仅包含短字符串</c>

00:22:29.016 --> 00:22:30.717 align:middle line:90%,end
<c.magenta>这些字符串用于UI显示</c>

00:22:31.251 --> 00:22:34.321 align:middle line:90%,end
<c.magenta>因此 你可能不会</c>
<c.magenta>频繁地获取它们的文本</c>

00:22:34.721 --> 00:22:37.357 align:middle line:10%
<c.magenta>大多数情况下</c>
<c.magenta>性能水平位于这个象限</c>

00:22:37.691 --> 00:22:40.227 align:middle line:10%
<c.magenta>因此 桥接复制</c>
<c.magenta>并不会造成很大的影响</c>

00:22:43.096 --> 00:22:46.166 align:middle line:90%,end
<c.magenta>但是 让我们来看</c>
<c.magenta>对于大量数据 将会发生什么</c>

00:22:46.233 --> 00:22:47.334 align:middle line:90%,end
<c.magenta>比如在NSTextStorage中</c>

00:22:49.069 --> 00:22:49.903 align:middle line:90%,end
<c.magenta>NSTextStorage</c>

00:22:49.970 --> 00:22:52.039 align:middle line:90%,end
<c.magenta>是TextKit背后的</c>
<c.magenta>基本存储机制</c>

00:22:52.506 --> 00:22:54.608 align:middle line:90%,end
<c.magenta>它用于在Cocoa 和Cocoa Touch中</c>
<c.magenta>支持文本视图</c>

00:22:54.675 --> 00:22:56.076 align:middle line:90%,end
<c.magenta>比如你在这里所看到的</c>

00:22:57.144 --> 00:22:59.146 align:middle line:90%,end
<c.magenta>因此 如果你处理文本视图</c>

00:22:59.413 --> 00:23:00.848 align:middle line:90%,end
<c.magenta>你需要能够</c>
<c.magenta>访问文本存储中的</c>

00:22:59.413 --> 00:23:00.848 align:middle line:90%,end
<c.magenta>你需要能够</c>
<c.magenta>访问文本存储中的</c>

00:23:00.914 --> 00:23:02.182 align:middle line:90%,end
<c.magenta>文本</c>

00:23:03.217 --> 00:23:04.785 align:middle line:90%,end
<c.magenta>这是Swift中的内容</c>

00:23:07.921 --> 00:23:09.356 align:middle line:90%,end
<c.magenta>这是生成的界面</c>

00:23:10.257 --> 00:23:13.794 align:middle line:90%,end
<c.magenta>这是Objective-C界面</c>

00:23:14.962 --> 00:23:16.997 align:middle line:10%
<c.magenta>但是请注意 NSTextStorage</c>

00:23:17.064 --> 00:23:19.733 align:middle line:10%
<c.magenta>是NSMutableAttributedString的</c>
<c.magenta>子类</c>

00:23:21.435 --> 00:23:24.471 align:middle line:10%
<c.magenta>由于这里NSTextStorage</c>
<c.magenta>用于文本编辑</c>

00:23:24.671 --> 00:23:27.508 align:middle line:10%
<c.magenta>因此我们希望</c>
<c.magenta>文本存储的内容</c>

00:23:27.574 --> 00:23:28.809 align:middle line:10%
<c.magenta>频繁发生变化</c>

00:23:29.977 --> 00:23:32.946 align:middle line:10%
<c.magenta>文本存储的内容</c>
<c.magenta>也应该是很长的字符串</c>

00:23:33.013 --> 00:23:35.482 align:middle line:10%
<c.magenta>可能是MB</c>
<c.magenta>甚至GB级别</c>

00:23:36.216 --> 00:23:37.284 align:middle line:10%
<c.magenta>因此 为了确保效率</c>

00:23:37.351 --> 00:23:39.620 align:middle line:10%
<c.magenta>框架仅保留</c>
<c.magenta>可变字符串</c>

00:23:39.920 --> 00:23:42.656 align:middle line:10%
<c.magenta>当你请求文本存储中的</c>
<c.magenta>字符串资产时</c>

00:23:43.190 --> 00:23:45.459 align:middle line:10%
<c.magenta>将会得到</c>
<c.magenta>NSString提供的结果</c>

00:23:45.526 --> 00:23:47.227 align:middle line:10%
<c.magenta>它指向可变字符串</c>

00:23:49.730 --> 00:23:50.664 align:middle line:90%,end
<c.magenta>现在 让我们再来看一看</c>

00:23:50.731 --> 00:23:51.732 align:middle line:90%,end
<c.magenta>发生了什么</c>

00:23:51.798 --> 00:23:53.634 align:middle line:90%,end
<c.magenta>当我们从Swift中</c>
<c.magenta>请求字符串资产时</c>

00:23:55.769 --> 00:23:58.005 align:middle line:90%,end
<c.magenta>与前面一样</c>
<c.magenta>它封装为值类型</c>

00:23:58.071 --> 00:24:00.941 align:middle line:90%,end
<c.magenta>当进行桥接时</c>
<c.magenta>因为它是一个NSString</c>

00:23:58.071 --> 00:24:00.941 align:middle line:90%,end
<c.magenta>当进行桥接时</c>
<c.magenta>因为它是一个NSString</c>

00:24:01.441 --> 00:24:02.943 align:middle line:90%,end
<c.magenta>框架将会进行复制</c>

00:24:04.011 --> 00:24:05.579 align:middle line:90%,end
<c.magenta>但与UILabel例子不一样</c>

00:24:05.646 --> 00:24:08.515 align:middle line:90%,end
<c.magenta>在这里 底层NSString</c>
<c.magenta>实际上是不可变的</c>

00:24:09.316 --> 00:24:10.784 align:middle line:90%,end
<c.magenta>因此 此复制将会占用大量资源</c>

00:24:11.818 --> 00:24:12.819 align:middle line:90%,end
<c.magenta>如我们前面所述</c>

00:24:12.886 --> 00:24:16.423 align:middle line:90%,end
<c.magenta>textStorage更适合</c>
<c.magenta>包含很长的字符串</c>

00:24:16.823 --> 00:24:18.759 align:middle line:90%,end
<c.magenta>其大小可能是MB</c>
<c.magenta>甚至GB级别</c>

00:24:18.825 --> 00:24:21.195 align:middle line:90%,end
<c.magenta>因此 这种复制</c>
<c.magenta>会占量非常多的资源</c>

00:24:23.564 --> 00:24:24.865 align:middle line:90%,end
<c.magenta>现在 让我们看看</c>

00:24:24.932 --> 00:24:26.600 align:middle line:90%,end
<c.magenta>当我们请求</c>
<c.magenta>可变字符串资产时 会发生什么</c>

00:24:28.535 --> 00:24:31.104 align:middle line:90%,end
<c.magenta>NSMutableString是一个引用类型</c>
<c.magenta>没有进行桥接</c>

00:24:32.139 --> 00:24:34.007 align:middle line:90%,end
<c.magenta>因为没有进行桥接</c>
<c.magenta>因此不会进行复制</c>

00:24:34.575 --> 00:24:36.176 align:middle line:90%,end
<c.magenta>从而避免占用大量资源的复制操作</c>

00:24:37.511 --> 00:24:39.413 align:middle line:90%,end
<c.magenta>这种情况源自于</c>

00:24:39.479 --> 00:24:41.181 align:middle line:90%,end
<c.magenta>Swift的值语义与</c>

00:24:41.315 --> 00:24:42.816 align:middle line:90%,end
<c.magenta>NSTextStorage设计之间的不匹配</c>

00:24:42.950 --> 00:24:44.618 align:middle line:90%,end
<c.magenta>而需要使用引用语义</c>

00:24:44.685 --> 00:24:46.753 align:middle line:90%,end
<c.magenta>针对文本</c>
<c.magenta>进行性能管理</c>

00:24:47.754 --> 00:24:49.890 align:middle line:90%,end
<c.magenta>因此 现在Apple</c>
<c.magenta>致力于解决这个问题</c>

00:24:49.957 --> 00:24:51.792 align:middle line:90%,end
<c.magenta>但是我们还没有很好的解决方法</c>

00:24:51.925 --> 00:24:54.161 align:middle line:90%,end
<c.magenta>因此 你们应该认识到</c>
<c.magenta>这是可能会发生的情况</c>

00:24:54.394 --> 00:24:56.396 align:middle line:90%,end
<c.magenta>如果你要处理</c>
<c.magenta>大量的文本</c>

00:24:56.463 --> 00:24:59.066 align:middle line:90%,end
<c.magenta>并进行文本存储</c>
<c.magenta>使用MutableString访问文本</c>

00:24:59.299 --> 00:25:00.901 align:middle line:90%,end
<c.magenta>即使你不打算改变文本内容</c>

00:24:59.299 --> 00:25:00.901 align:middle line:90%,end
<c.magenta>即使你不打算改变文本内容</c>

00:25:03.070 --> 00:25:04.137 align:middle line:90%,end
<c.magenta>但是 当你</c>

00:25:04.204 --> 00:25:06.073 align:middle line:90%,end
<c.magenta>将所有字符串访问</c>
<c.magenta>更改为使用MutableString之前</c>

00:25:06.139 --> 00:25:07.441 align:middle line:90%,end
<c.magenta>让我们再次考虑性能象限图</c>

00:25:08.208 --> 00:25:10.043 align:middle line:90%,end
<c.magenta>由于TextStorage API /b&gt;</c>
<c.magenta>的性质</c>

00:25:10.210 --> 00:25:13.480 align:middle line:90%,end
<c.magenta>从频率的角度来看</c>
<c.magenta>性能水平可能会处于上方位置</c>

00:25:13.714 --> 00:25:15.182 align:middle line:90%,end
<c.magenta>因此 真正的问题是</c>

00:25:15.449 --> 00:25:18.652 align:middle line:90%,end
<c.magenta>你希望TextStorage</c>
<c.magenta>包含多少内容？</c>

00:25:20.120 --> 00:25:23.123 align:middle line:90%,end
<c.magenta>1 KB？</c>
<c.magenta>这也许比较合适</c>

00:25:23.323 --> 00:25:25.292 align:middle line:90%,end
<c.magenta>如果你使用字符串资产</c>
<c.magenta>这没有问题</c>

00:25:26.960 --> 00:25:29.162 align:middle line:90%,end
<c.magenta>如果是1MB</c>

00:25:29.229 --> 00:25:30.731 align:middle line:90%,end
<c.magenta>性能水平将位于第一象限</c>

00:25:30.864 --> 00:25:32.766 align:middle line:90%,end
<c.magenta>你可能想要</c>
<c.magenta>使用MutableString</c>

00:25:34.001 --> 00:25:37.004 align:middle line:90%,end
<c.magenta>如果是1GB 那我真的希望</c>
<c.magenta>你使用MutableString</c>

00:25:39.106 --> 00:25:41.542 align:middle line:90%,end
<c.magenta>前面我说过 我们正在</c>
<c.magenta>努力解决这个问题</c>

00:25:41.642 --> 00:25:43.544 align:middle line:90%,end
<c.magenta>请在未来的版本中</c>
<c.magenta>留意这一点</c>

00:25:45.412 --> 00:25:46.914 align:middle line:90%,end
<c.magenta>现在 我们对于</c>
<c.magenta>字符串桥接</c>

00:25:46.980 --> 00:25:49.283 align:middle line:90%,end
<c.magenta>具有更透彻的理解</c>
<c.magenta>现在来看范围</c>

00:25:52.553 --> 00:25:54.821 align:middle line:90%,end
<c.magenta>我不知道你们是怎么想的</c>
<c.magenta>但是 当我必须在Swift中</c>

00:25:54.888 --> 00:25:57.291 align:middle line:90%,end
<c.magenta>使用范围和字符串索引时</c>
<c.magenta>我就是这样的心情</c>

00:25:58.225 --> 00:26:00.127 align:middle line:90%,end
<c.magenta>为了弄清楚原因 让我们来看</c>

00:25:58.225 --> 00:26:00.127 align:middle line:90%,end
<c.magenta>为了弄清楚原因 让我们来看</c>

00:26:00.260 --> 00:26:02.162 align:middle line:90%,end
<c.magenta>一个字符串 它含有用手捂脸的表情</c>

00:26:02.229 --> 00:26:04.398 align:middle line:90%,end
<c.magenta>这有一点</c>
<c.magenta>像我本人</c>

00:26:06.600 --> 00:26:07.568 align:middle line:90%,end
<c.magenta>这是我们的字符串</c>

00:26:07.801 --> 00:26:10.003 align:middle line:90%,end
<c.magenta>是一个长字符串</c>
<c.magenta>里面有很多人物表情</c>

00:26:10.771 --> 00:26:13.440 align:middle line:90%,end
<c.magenta>这个角色</c>
<c.magenta>包含三个图形组成部分</c>

00:26:13.674 --> 00:26:15.209 align:middle line:90%,end
<c.magenta>有一个黄色的捂脸表情</c>

00:26:15.876 --> 00:26:18.645 align:middle line:90%,end
<c.magenta>一个肤色修改器</c>
<c.magenta>可以修改黄肤色</c>

00:26:19.146 --> 00:26:20.314 align:middle line:90%,end
<c.magenta>还有一个性别修改器</c>

00:26:21.415 --> 00:26:23.817 align:middle line:90%,end
<c.magenta>这些图形组成部分</c>
<c.magenta>还不是全部</c>

00:26:24.017 --> 00:26:25.953 align:middle line:90%,end
<c.magenta>字符串中还有</c>
<c.magenta>两个控制角色</c>

00:26:26.019 --> 00:26:28.655 align:middle line:90%,end
<c.magenta>一个零宽度连接器</c>
<c.magenta>和一个变体选择器</c>

00:26:29.289 --> 00:26:31.425 align:middle line:90%,end
<c.magenta>让我们来看</c>
<c.magenta>构成字符串的</c>

00:26:31.491 --> 00:26:32.392 align:middle line:90%,end
<c.magenta>Unicode Scalar值</c>

00:26:32.492 --> 00:26:33.961 align:middle line:90%,end
<c.magenta>你可能不熟悉这个名词</c>

00:26:34.094 --> 00:26:37.097 align:middle line:90%,end
<c.magenta>Unicode Scalar值是一个21位数字</c>

00:26:37.164 --> 00:26:39.299 align:middle line:90%,end
<c.magenta>唯一地表示</c>
<c.magenta>Unicode字符</c>

00:26:40.067 --> 00:26:42.669 align:middle line:90%,end
<c.magenta>这是构成字符串的</c>
<c.magenta>Unicode Scalar值</c>

00:26:42.836 --> 00:26:45.606 align:middle line:90%,end
<c.magenta>以及与这些值</c>
<c.magenta>相关联的名称</c>

00:26:46.106 --> 00:26:48.509 align:middle line:90%,end
<c.magenta>如果你从Unicode Scalar角度</c>
<c.magenta>分析这个字符串</c>

00:26:48.775 --> 00:26:50.310 align:middle line:90%,end
<c.magenta>就会发现 它实际上</c>
<c.magenta>由五个不同的值构成</c>

00:26:50.377 --> 00:26:51.645 align:middle line:90%,end
<c.magenta>其长度为5</c>

00:26:53.247 --> 00:26:54.381 align:middle line:90%,end
<c.magenta>目前一切正常</c>

00:26:54.448 --> 00:26:56.416 align:middle line:90%,end
<c.magenta>如果你使用</c>
<c.magenta>Swift的字符串API</c>

00:26:56.884 --> 00:26:58.852 align:middle line:90%,end
<c.magenta>但是如果你使用NSAttributedString</c>

00:26:59.186 --> 00:27:01.622 align:middle line:90%,end
<c.magenta>或任何使用NSRange</c>

00:26:59.186 --> 00:27:01.622 align:middle line:90%,end
<c.magenta>或任何使用NSRange</c>

00:27:01.989 --> 00:27:04.024 align:middle line:90%,end
<c.magenta>它们实际上使用UTF-16</c>

00:27:04.558 --> 00:27:06.760 align:middle line:90%,end
<c.magenta>因此 若你从UTF-16</c>
<c.magenta>的角度看待这个字符串</c>

00:27:06.827 --> 00:27:09.696 align:middle line:90%,end
<c.magenta>它实际上包含7个值</c>
<c.magenta>其长度是7</c>

00:27:10.464 --> 00:27:12.966 align:middle line:90%,end
<c.magenta>这很容易让人感到困惑</c>
<c.magenta>当我们使用NSRange</c>

00:27:13.033 --> 00:27:15.035 align:middle line:90%,end
<c.magenta>和字符串索引范围时</c>
<c.magenta>会变得困难重重</c>

00:27:16.904 --> 00:27:18.205 align:middle line:90%,end
<c.magenta>因此 让我们来消除这些困惑</c>

00:27:18.272 --> 00:27:20.307 align:middle line:90%,end
<c.magenta>我们来讨论</c>
<c.magenta>如何使用NSAttributedString</c>

00:27:20.374 --> 00:27:21.875 align:middle line:90%,end
<c.magenta>它大量使用NSRange</c>

00:27:23.677 --> 00:27:24.978 align:middle line:90%,end
<c.magenta>这里有一个字符串</c>

00:27:26.146 --> 00:27:28.282 align:middle line:90%,end
<c.magenta>我想使用它</c>
<c.magenta>创建一个属性化字符串</c>

00:27:28.348 --> 00:27:31.118 align:middle line:90%,end
<c.magenta>并且将一个表情的</c>
<c.magenta>背景更改为绿色</c>

00:27:34.154 --> 00:27:35.322 align:middle line:90%,end
<c.magenta>这个工作比较复杂</c>

00:27:35.389 --> 00:27:38.025 align:middle line:90%,end
<c.magenta>我自己都好几次</c>
<c.magenta>忘记怎么做了 但请不要告诉别人</c>

00:27:39.560 --> 00:27:41.128 align:middle line:90%,end
<c.magenta>我可能需要在网上查找</c>

00:27:41.195 --> 00:27:42.229 align:middle line:90%,end
<c.magenta>然后</c>

00:27:42.362 --> 00:27:44.264 align:middle line:90%,end
<c.magenta>我可能会编写</c>
<c.magenta>这样的代码</c>

00:27:45.232 --> 00:27:47.201 align:middle line:90%,end
<c.magenta>看上去并不合适</c>
<c.magenta>因为我必须</c>

00:27:47.267 --> 00:27:50.003 align:middle line:90%,end
<c.magenta>在这个字符串API</c>
<c.magenta>和这个NSString API之间转来转去</c>

00:27:51.071 --> 00:27:54.007 align:middle line:90%,end
<c.magenta>我必须获取我的初始字符串</c>
<c.magenta>然后使用它创建一个NSString</c>

00:27:54.074 --> 00:27:56.510 align:middle line:90%,end
<c.magenta>然后使用NSString</c>
<c.magenta>计算NSRange</c>

00:27:56.743 --> 00:27:57.778 align:middle line:90%,end
<c.magenta>然后 我必须回过头来</c>

00:27:58.078 --> 00:27:59.980 align:middle line:90%,end
<c.magenta>再次使用我的初始字符串</c>

00:28:00.047 --> 00:28:01.448 align:middle line:90%,end
<c.magenta>创建我的NSMutableAttributedString</c>

00:28:01.849 --> 00:28:03.784 align:middle line:90%,end
<c.magenta>哎 我可不喜欢这样做</c>

00:28:04.318 --> 00:28:05.485 align:middle line:90%,end
<c.magenta>没有人喜欢这样做</c>

00:28:06.920 --> 00:28:08.856 align:middle line:90%,end
<c.magenta>一个好消息是</c>
<c.magenta>你再也不用这样做了</c>

00:28:09.089 --> 00:28:11.425 align:middle line:90%,end
<c.magenta>因为在Swift 4中</c>
<c.magenta>我们为NSRange 和Range</c>

00:28:11.491 --> 00:28:12.926 align:middle line:90%,end
<c.magenta>引入新的初始化器</c>

00:28:13.560 --> 00:28:17.030 align:middle line:90%,end
<c.magenta>因此 当我们使用</c>
<c.magenta>这些新初始化器时——谢谢</c>

00:28:17.631 --> 00:28:20.901 align:middle line:90%,end
<c.magenta>同样的代码将会变得如此简短</c>

00:28:20.968 --> 00:28:23.704 align:middle line:90%,end
<c.magenta>从而更容易识读</c>
<c.magenta>编写和记住</c>

00:28:24.204 --> 00:28:26.773 align:middle line:90%,end
<c.magenta>这里使用的</c>
<c.magenta>新NSRange初始化器</c>

00:28:26.840 --> 00:28:28.542 align:middle line:90%,end
<c.magenta>获取范围和Swift字符串</c>

00:28:28.609 --> 00:28:30.310 align:middle line:90%,end
<c.magenta>并使用它创建NSRange</c>

00:28:30.377 --> 00:28:33.247 align:middle line:90%,end
<c.magenta>你可以将它直接</c>
<c.magenta>传递给AttributedString API</c>

00:28:35.649 --> 00:28:37.718 align:middle line:90%,end
<c.magenta>现在 让我们</c>
<c.magenta>从另一个方向来看待这种转换</c>

00:28:37.784 --> 00:28:39.553 align:middle line:90%,end
<c.magenta>也就是从NSRange</c>
<c.magenta>到Range 和String Index</c>

00:28:41.555 --> 00:28:42.523 align:middle line:90%,end
<c.magenta>请看这个简单的例子</c>

00:28:42.589 --> 00:28:44.291 align:middle line:90%,end
<c.magenta>假设我们有这样的html代码</c>

00:28:44.525 --> 00:28:46.260 align:middle line:90%,end
<c.magenta>我们想要</c>
<c.magenta>打印所有起始标记</c>

00:28:46.960 --> 00:28:48.295 align:middle line:90%,end
<c.magenta>为此</c>

00:28:48.829 --> 00:28:51.131 align:middle line:90%,end
<c.magenta>我们将使用NSRegularExpression</c>
<c.magenta>查找我们想要的标记</c>

00:28:51.198 --> 00:28:52.432 align:middle line:90%,end
<c.magenta>然后将它们追加到字符串</c>

00:28:52.699 --> 00:28:53.567 align:middle line:90%,end
<c.magenta>听上去很正确 是吧？</c>

00:28:55.602 --> 00:28:57.304 align:middle line:90%,end
<c.magenta>但是NSRegularExpression API</c>

00:28:57.404 --> 00:28:59.339 align:middle line:90%,end
<c.magenta>从我的匹配组中</c>
<c.magenta>为我返回NSRange</c>

00:28:59.473 --> 00:29:01.074 align:middle line:90%,end
<c.magenta>我需要字符串索引的范围</c>

00:28:59.473 --> 00:29:01.074 align:middle line:90%,end
<c.magenta>我需要字符串索引的范围</c>

00:29:01.141 --> 00:29:02.743 align:middle line:90%,end
<c.magenta>以便将内容追加到我的Swift字符串</c>

00:29:04.178 --> 00:29:06.446 align:middle line:90%,end
<c.magenta>在这些新初始化器</c>
<c.magenta>推出之前</c>

00:29:06.813 --> 00:29:08.048 align:middle line:90%,end
<c.magenta>我们可能会使用这样的代码</c>

00:29:08.115 --> 00:29:10.384 align:middle line:90%,end
<c.magenta>从NSRange</c>
<c.magenta>转换到范围字符串索引</c>

00:29:11.151 --> 00:29:12.319 align:middle line:90%,end
<c.magenta>请回忆几分钟前</c>

00:29:12.386 --> 00:29:15.055 align:middle line:90%,end
<c.magenta>我们讲过的捂脸表情</c>
<c.magenta>为什么说从UTF-16的角度来看</c>

00:29:15.122 --> 00:29:16.423 align:middle line:90%,end
<c.magenta>它的长度为7</c>

00:29:16.490 --> 00:29:18.392 align:middle line:90%,end
<c.magenta>而从Unicode Scalar 的角度来看</c>
<c.magenta>它的长度是5？</c>

00:29:18.659 --> 00:29:23.263 align:middle line:90%,end
<c.magenta>这段代码有一点复杂</c>
<c.magenta>因为它进行从UTF-16</c>

00:29:23.597 --> 00:29:24.698 align:middle line:90%,end
<c.magenta>到Unicode Scalar的转换工作</c>

00:29:26.433 --> 00:29:27.968 align:middle line:90%,end
<c.magenta>但是现在</c>
<c.magenta>利用这些新数组初始化器</c>

00:29:28.035 --> 00:29:29.269 align:middle line:90%,end
<c.magenta>你不必自己完成这些工作</c>

00:29:29.803 --> 00:29:32.072 align:middle line:90%,end
<c.magenta>我们可以获取NSRange</c>
<c.magenta>从匹配组中取回</c>

00:29:32.372 --> 00:29:34.708 align:middle line:90%,end
<c.magenta>然后用它创建</c>
<c.magenta>字符串索引范围</c>

00:29:34.775 --> 00:29:36.243 align:middle line:90%,end
<c.magenta>然后直接追加到字符串</c>

00:29:36.844 --> 00:29:39.213 align:middle line:90%,end
<c.magenta>这更加方便</c>
<c.magenta>更容易使用</c>

00:29:39.913 --> 00:29:41.281 align:middle line:90%,end
<c.magenta>这些新初始化器</c>
<c.magenta>真的很不错</c>

00:29:41.348 --> 00:29:42.850 align:middle line:90%,end
<c.magenta>我希望你们使用它们</c>

00:29:42.916 --> 00:29:44.918 align:middle line:90%,end
<c.magenta>进行所有的Range</c>
<c.magenta>和NSRange转换</c>

00:29:47.321 --> 00:29:48.155 align:middle line:90%,end
<c.magenta>谢谢</c>

00:29:49.923 --> 00:29:51.191 align:middle line:90%,end
<c.magenta>关于Range就是这些</c>

00:29:51.258 --> 00:29:53.126 align:middle line:90%,end
<c.magenta>让我们来讨论文本布局</c>
<c.magenta>和呈现</c>

00:29:54.962 --> 00:29:55.796 align:middle line:90%,end
<c.magenta>文本是硬内容</c>

00:29:56.597 --> 00:29:57.965 align:middle line:90%,end
<c.magenta>在界面上 它看上去比较简单</c>

00:29:58.432 --> 00:29:59.766 align:middle line:90%,end
<c.magenta>因为每个人都知道文本内容是什么</c>

00:30:00.100 --> 00:30:01.902 align:middle line:90%,end
<c.magenta>所有人每天都会看到它</c>

00:30:02.236 --> 00:30:04.238 align:middle line:90%,end
<c.magenta>文本常见而又普通</c>

00:30:04.771 --> 00:30:08.141 align:middle line:90%,end
<c.magenta>因此 人们认为</c>
<c.magenta>它很简单</c>

00:30:09.243 --> 00:30:10.410 align:middle line:90%,end
<c.magenta>其实并不简单</c>

00:30:10.978 --> 00:30:12.880 align:middle line:90%,end
<c.magenta>文本会带来</c>
<c.magenta>一些性能挑战</c>

00:30:12.946 --> 00:30:14.481 align:middle line:90%,end
<c.magenta>因为它的大小变化多样</c>

00:30:16.717 --> 00:30:17.584 align:middle line:90%,end
<c.magenta>请思考这样的例子</c>

00:30:17.651 --> 00:30:22.389 align:middle line:90%,end
<c.magenta>我们的iOS有40个本地化版本</c>
<c.magenta>macOS有35个版本</c>

00:30:23.690 --> 00:30:27.327 align:middle line:90%,end
<c.magenta>watchOS有39个</c>
<c.magenta>tvOS有40个</c>

00:30:28.562 --> 00:30:29.830 align:middle line:90%,end
<c.magenta>在所有这些平台上</c>

00:30:29.897 --> 00:30:32.799 align:middle line:10%
<c.magenta>我们支持300种其它语言的</c>
<c.magenta>文本输入</c>

00:30:34.468 --> 00:30:36.537 align:middle line:10%
<c.magenta>每种语言都有</c>
<c.magenta>不同的规则</c>

00:30:36.603 --> 00:30:38.438 align:middle line:10%
<c.magenta>比如</c>
<c.magenta>断词和连字符等</c>

00:30:38.839 --> 00:30:41.141 align:middle line:10%
<c.magenta>这些会影响到分行</c>

00:30:41.275 --> 00:30:42.943 align:middle line:10%
<c.magenta>从而影响文本布局</c>

00:30:43.143 --> 00:30:44.811 align:middle line:10%
<c.magenta>进而影响文本呈现</c>

00:30:45.345 --> 00:30:46.847 align:middle line:10%
<c.magenta>我们的框架</c>
<c.magenta>需要正确地</c>

00:30:46.914 --> 00:30:48.482 align:middle line:10%
<c.magenta>处理所有这些语言</c>

00:30:50.217 --> 00:30:51.118 align:middle line:90%,end
<c.magenta>如果这还不能说明问题</c>

00:30:51.185 --> 00:30:52.853 align:middle line:90%,end
<c.magenta>让我们来看</c>

00:30:52.986 --> 00:30:54.388 align:middle line:90%,end
<c.magenta>在执行文本和呈现时</c>

00:30:54.488 --> 00:30:56.123 align:middle line:90%,end
<c.magenta>框架需要考虑的其它一些因素</c>

00:30:56.590 --> 00:30:57.991 align:middle line:90%,end
<c.magenta>我们必须考虑所有这些因素</c>

00:30:58.058 --> 00:31:00.861 align:middle line:90%,end
<c.magenta>以正确、高性能地</c>
<c.magenta>呈现你的文本</c>

00:30:58.058 --> 00:31:00.861 align:middle line:90%,end
<c.magenta>以正确、高性能地</c>
<c.magenta>呈现你的文本</c>

00:31:01.094 --> 00:31:01.995 align:middle line:90%,end
<c.magenta>因此我建议你们</c>

00:31:02.062 --> 00:31:04.631 align:middle line:90%,end
<c.magenta>尽可能地</c>
<c.magenta>使用标准标签控件</c>

00:31:05.532 --> 00:31:08.702 align:middle line:90%,end
<c.magenta>由于要考虑许多不同的可变因素</c>
<c.magenta>我们的框架使用</c>

00:31:08.769 --> 00:31:10.838 align:middle line:90%,end
<c.magenta>多种底层</c>
<c.magenta>优化策略</c>

00:31:11.471 --> 00:31:14.408 align:middle line:90%,end
<c.magenta>必须根据具体的情况</c>
<c.magenta>选择合适的优化策略</c>

00:31:14.474 --> 00:31:16.476 align:middle line:90%,end
<c.magenta>而且必须满足多个条件</c>

00:31:16.610 --> 00:31:17.711 align:middle line:90%,end
<c.magenta>以正确地应用策略</c>

00:31:18.812 --> 00:31:20.614 align:middle line:90%,end
<c.magenta>我想要提醒你们</c>

00:31:20.681 --> 00:31:22.616 align:middle line:90%,end
<c.magenta>当你们在标准控件基础上</c>
<c.magenta>使用自己的优化策略时</c>

00:31:22.683 --> 00:31:24.017 align:middle line:90%,end
<c.magenta>必须非常小心</c>

00:31:24.551 --> 00:31:26.653 align:middle line:90%,end
<c.magenta>因为呈现条件或</c>
<c.magenta>输入数据的改变</c>

00:31:26.820 --> 00:31:29.489 align:middle line:90%,end
<c.magenta>可能会让你的优化失效</c>
<c.magenta>而无法获得性能提升</c>

00:31:31.124 --> 00:31:32.459 align:middle line:90%,end
<c.magenta>为了描述我的含义</c>

00:31:32.526 --> 00:31:35.362 align:middle line:90%,end
<c.magenta>让我们来看一个例子</c>
<c.magenta>一个含有两个标签的表格</c>

00:31:37.464 --> 00:31:38.565 align:middle line:90%,end
<c.magenta>曾经有一位开发者</c>

00:31:39.032 --> 00:31:41.668 align:middle line:90%,end
<c.magenta>想要在她的应用中</c>
<c.magenta>显示许多的标签</c>

00:31:42.603 --> 00:31:45.072 align:middle line:90%,end
<c.magenta>而且每个标签</c>
<c.magenta>都有一行粗体文本</c>

00:31:45.305 --> 00:31:47.107 align:middle line:90%,end
<c.magenta>后面是一行普通文本</c>

00:31:48.141 --> 00:31:51.211 align:middle line:90%,end
<c.magenta>她想要手动设置标准边框</c>
<c.magenta>来定位她的标签</c>

00:31:51.278 --> 00:31:52.946 align:middle line:90%,end
<c.magenta>这是出于商业原因</c>

00:31:54.882 --> 00:31:57.784 align:middle line:90%,end
<c.magenta>她使用属性字符串</c>
<c.magenta>设置标签 显示她的内容</c>

00:31:59.486 --> 00:32:02.256 align:middle line:90%,end
<c.magenta>但是她注意到</c>
<c.magenta>应用的滚动显示性能</c>

00:31:59.486 --> 00:32:02.256 align:middle line:90%,end
<c.magenta>但是她注意到</c>
<c.magenta>应用的滚动显示性能</c>

00:32:02.322 --> 00:32:04.091 align:middle line:90%,end
<c.magenta>低于她的预期</c>

00:32:04.892 --> 00:32:06.393 align:middle line:90%,end
<c.magenta>因此她进行分析</c>

00:32:06.793 --> 00:32:09.396 align:middle line:90%,end
<c.magenta>结果发现</c>
<c.magenta>标签的布局和呈现</c>

00:32:09.463 --> 00:32:11.398 align:middle line:90%,end
<c.magenta>花费了大量的时间</c>

00:32:13.066 --> 00:32:14.701 align:middle line:90%,end
<c.magenta>于是 她做了一些试验</c>

00:32:15.002 --> 00:32:19.973 align:middle line:90%,end
<c.magenta>然后注意到</c>
<c.magenta>如果每个行显示在单独的标签中</c>

00:32:20.207 --> 00:32:21.842 align:middle line:90%,end
<c.magenta>应用滚动显示性能将会得到提升</c>

00:32:22.242 --> 00:32:23.610 align:middle line:90%,end
<c.magenta>“这太神奇了” 她心里想到</c>

00:32:23.877 --> 00:32:24.711 align:middle line:90%,end
<c.magenta>于是她修改应用</c>

00:32:24.778 --> 00:32:26.346 align:middle line:90%,end
<c.magenta>每个行都使用单独的标签</c>

00:32:26.547 --> 00:32:27.948 align:middle line:90%,end
<c.magenta>然后她感到很高兴</c>

00:32:28.015 --> 00:32:31.618 align:middle line:90%,end
<c.magenta>直到有一天 她的公司</c>
<c.magenta>进入中国市场</c>

00:32:33.053 --> 00:32:35.489 align:middle line:90%,end
<c.magenta>于是她使用中文</c>
<c.magenta>测试她的应用</c>

00:32:36.056 --> 00:32:37.591 align:middle line:90%,end
<c.magenta>她吃惊地发现</c>

00:32:37.891 --> 00:32:41.028 align:middle line:90%,end
<c.magenta>滚动显示性能</c>
<c.magenta>比以前更低了</c>

00:32:42.262 --> 00:32:43.430 align:middle line:90%,end
<c.magenta>这到底是怎么了？</c>

00:32:44.998 --> 00:32:47.868 align:middle line:90%,end
<c.magenta>这位开发者</c>
<c.magenta>尝试找到正确的方法</c>

00:32:48.268 --> 00:32:50.938 align:middle line:90%,end
<c.magenta>她看到许多短字符串</c>
<c.magenta>频繁地进行显示</c>

00:32:51.305 --> 00:32:53.106 align:middle line:90%,end
<c.magenta>从而让性能水平落入第二象限</c>

00:32:54.508 --> 00:32:56.143 align:middle line:90%,end
<c.magenta>因此 她采取一些措施</c>

00:32:56.276 --> 00:32:57.744 align:middle line:90%,end
<c.magenta>找到改进突破口</c>

00:32:57.811 --> 00:32:59.513 align:middle line:90%,end
<c.magenta>于是进行优化</c>

00:33:00.447 --> 00:33:03.083 align:middle line:90%,end
<c.magenta>但是 当输入数据</c>
<c.magenta>变成中文时</c>

00:33:03.217 --> 00:33:05.385 align:middle line:90%,end
<c.magenta>优化无法</c>
<c.magenta>获得性能改进</c>

00:33:06.286 --> 00:33:08.088 align:middle line:90%,end
<c.magenta>为了弄清楚原因 我们进行事后分析</c>

00:33:09.489 --> 00:33:10.457 align:middle line:90%,end
<c.magenta>在这个例子中</c>

00:33:10.724 --> 00:33:12.926 align:middle line:90%,end
<c.magenta>初始条件</c>
<c.magenta>支持在框架内</c>

00:33:13.060 --> 00:33:14.928 align:middle line:90%,end
<c.magenta>更快速地显示</c>
<c.magenta>属性化字符串</c>

00:33:15.596 --> 00:33:18.265 align:middle line:90%,end
<c.magenta>优化方法</c>
<c.magenta>是将每个行放入单独的标签</c>

00:33:18.398 --> 00:33:20.267 align:middle line:90%,end
<c.magenta>利用这样一个特性</c>
<c.magenta>即仅包含一种文本样式的</c>

00:33:20.334 --> 00:33:23.770 align:middle line:90%,end
<c.magenta>属性化字符串</c>
<c.magenta>支持更快速的呈现</c>

00:33:25.472 --> 00:33:28.308 align:middle line:90%,end
<c.magenta>但是 要实现更快速的呈现</c>
<c.magenta>只有这个条件还不够</c>

00:33:28.909 --> 00:33:30.944 align:middle line:90%,end
<c.magenta>快速呈现方案会走捷径</c>

00:33:31.011 --> 00:33:33.080 align:middle line:90%,end
<c.magenta>对输入数据和</c>
<c.magenta>呈现条件</c>

00:33:33.146 --> 00:33:34.381 align:middle line:90%,end
<c.magenta>进行特定的预测</c>

00:33:34.615 --> 00:33:37.317 align:middle line:90%,end
<c.magenta>在本例中 使用中文文本</c>
<c.magenta>将需要字体回调</c>

00:33:37.384 --> 00:33:39.086 align:middle line:90%,end
<c.magenta>强制在框架内</c>
<c.magenta>使用慢速的</c>

00:33:39.152 --> 00:33:40.988 align:middle line:90%,end
<c.magenta>呈现路径</c>
<c.magenta>以保持正确性</c>

00:33:42.055 --> 00:33:42.923 align:middle line:90%,end
<c.magenta>在此基础上</c>

00:33:42.990 --> 00:33:44.791 align:middle line:90%,end
<c.magenta>将双行字符串</c>
<c.magenta>放入不同的标签</c>

00:33:44.858 --> 00:33:47.761 align:middle line:90%,end
<c.magenta>意味着将需要</c>
<c.magenta>对许多标签进行两次呈现</c>

00:33:50.097 --> 00:33:52.966 align:middle line:90%,end
<c.magenta>此外应用使用陈旧的布局方法</c>

00:33:53.033 --> 00:33:55.569 align:middle line:90%,end
<c.magenta>手动设置边框</c>
<c.magenta>而不是使用自动布局 也会降低性能</c>

00:33:56.270 --> 00:33:58.172 align:middle line:90%,end
<c.magenta>因此一般来说</c>
<c.magenta>在使用新技术时</c>

00:33:58.238 --> 00:34:00.807 align:middle line:90%,end
<c.magenta>比如自动布局</c>
<c.magenta>我们应该更加注意</c>

00:33:58.238 --> 00:34:00.807 align:middle line:90%,end
<c.magenta>比如自动布局</c>
<c.magenta>我们应该更加注意</c>

00:34:00.874 --> 00:34:01.708 align:middle line:90%,end
<c.magenta>特定条件下的性能问题</c>

00:34:01.775 --> 00:34:03.410 align:middle line:90%,end
<c.magenta>因为多数应用都会使用这些技术</c>

00:34:03.477 --> 00:34:04.912 align:middle line:90%,end
<c.magenta>且在这些方面</c>
<c.magenta>性能优化会带来</c>

00:34:04.978 --> 00:34:06.113 align:middle line:90%,end
<c.magenta>最大的影响</c>

00:34:07.047 --> 00:34:08.282 align:middle line:90%,end
<c.magenta>以自动布局为例</c>

00:34:08.348 --> 00:34:10.617 align:middle line:90%,end
<c.magenta>文本系统缓存</c>
<c.magenta>一些布局信息</c>

00:34:10.851 --> 00:34:12.219 align:middle line:90%,end
<c.magenta>这可以切实地提升性能</c>

00:34:12.286 --> 00:34:14.188 align:middle line:90%,end
<c.magenta>但是由于这个应用</c>
<c.magenta>未使用自动布局</c>

00:34:14.721 --> 00:34:15.856 align:middle line:90%,end
<c.magenta>因此无法利用这一优势</c>

00:34:17.190 --> 00:34:18.192 align:middle line:90%,end
<c.magenta>因此请记住</c>

00:34:18.559 --> 00:34:20.694 align:middle line:90%,end
<c.magenta>有一些策略和技巧</c>
<c.magenta>可以帮助你</c>

00:34:20.761 --> 00:34:23.797 align:middle line:90%,end
<c.magenta>改进应用中的文本布局</c>
<c.magenta>和呈现性能</c>

00:34:25.666 --> 00:34:26.733 align:middle line:90%,end
<c.magenta>若你一直在认真听讲</c>

00:34:26.800 --> 00:34:28.668 align:middle line:90%,end
<c.magenta>你可能已知道</c>
<c.magenta>我要说的第一个策略是</c>

00:34:30.237 --> 00:34:32.139 align:middle line:90%,end
<c.magenta>使用标准标签</c>
<c.magenta>来呈现你的文本</c>

00:34:32.306 --> 00:34:33.907 align:middle line:90%,end
<c.magenta>其它的幕后工作请交给我们</c>

00:34:34.675 --> 00:34:37.177 align:middle line:90%,end
<c.magenta>在框架中</c>
<c.magenta>可以很好地运用优化策略</c>

00:34:37.244 --> 00:34:39.413 align:middle line:90%,end
<c.magenta>因为它能够概览地</c>
<c.magenta>显示整个界面</c>

00:34:39.478 --> 00:34:41.547 align:middle line:90%,end
<c.magenta>并且提供关于</c>
<c.magenta>呈现条件的更多信息</c>

00:34:42.516 --> 00:34:44.384 align:middle line:90%,end
<c.magenta>当我们进行性能优化之后</c>

00:34:44.451 --> 00:34:46.286 align:middle line:90%,end
<c.magenta>你们将自动获得这些好处</c>

00:34:46.887 --> 00:34:48.054 align:middle line:90%,end
<c.magenta>来看一个例子</c>

00:34:48.422 --> 00:34:51.058 align:middle line:90%,end
<c.magenta>在macOS 10.13中 NSTextField的</c>

00:34:51.123 --> 00:34:54.360 align:middle line:90%,end
<c.magenta>文本呈现速度提高三倍</c>
<c.magenta>在实时大小调整时</c>

00:34:54.527 --> 00:34:55.529 align:middle line:90%,end
<c.magenta>速度达到5.7毫秒/帧</c>

00:34:55.762 --> 00:34:59.132 align:middle line:90%,end
<c.magenta>相比以前的</c>
<c.magenta>16.67毫秒/帧缩短10.12毫秒</c>

00:34:59.800 --> 00:35:01.735 align:middle line:90%,end
<c.magenta>你们将会免费</c>
<c.magenta>得到这种性能提升</c>

00:34:59.800 --> 00:35:01.735 align:middle line:90%,end
<c.magenta>你们将会免费</c>
<c.magenta>得到这种性能提升</c>

00:35:01.802 --> 00:35:03.437 align:middle line:90%,end
<c.magenta>如果你们使用</c>
<c.magenta>标准框架控件</c>

00:35:03.871 --> 00:35:04.872 align:middle line:90%,end
<c.magenta>因此 使用标准控制</c>

00:35:04.938 --> 00:35:07.007 align:middle line:90%,end
<c.magenta>确实是很好的做法</c>
<c.magenta>应该尽可能这样做</c>

00:35:10.444 --> 00:35:12.546 align:middle line:90%,end
<c.magenta>第二个策略</c>
<c.magenta>也就是刚才的故事中所讲到的</c>

00:35:13.080 --> 00:35:14.948 align:middle line:90%,end
<c.magenta>应该使用最新的布局方法</c>
<c.magenta>比如自动布局</c>

00:35:15.516 --> 00:35:16.917 align:middle line:90%,end
<c.magenta>我们认真地研究了</c>

00:35:16.984 --> 00:35:18.018 align:middle line:90%,end
<c.magenta>使用新技术</c>

00:35:18.085 --> 00:35:20.287 align:middle line:90%,end
<c.magenta>所获得的文本布局和呈现性能提升</c>

00:35:20.888 --> 00:35:22.623 align:middle line:90%,end
<c.magenta>通过采用这些新技术</c>

00:35:22.689 --> 00:35:25.158 align:middle line:90%,end
<c.magenta>将很少会遇到</c>
<c.magenta>我们还没见到和改进的</c>

00:35:25.225 --> 00:35:26.860 align:middle line:90%,end
<c.magenta>边界情况</c>

00:35:30.797 --> 00:35:32.432 align:middle line:90%,end
<c.magenta>接下来介绍一个基本技巧</c>

00:35:32.799 --> 00:35:34.668 align:middle line:90%,end
<c.magenta>如果你使用NSAttributedString</c>

00:35:34.968 --> 00:35:35.903 align:middle line:90%,end
<c.magenta>有一些属性</c>

00:35:35.969 --> 00:35:38.438 align:middle line:90%,end
<c.magenta>对于布局和呈现来说</c>
<c.magenta>十分必要</c>

00:35:39.339 --> 00:35:41.275 align:middle line:90%,end
<c.magenta>如果你没有</c>
<c.magenta>自己提供这些属性</c>

00:35:41.375 --> 00:35:44.178 align:middle line:90%,end
<c.magenta>文本系统将需要处理它们</c>
<c.magenta>才能进行呈现</c>

00:35:44.545 --> 00:35:46.446 align:middle line:90%,end
<c.magenta>因此 如果你自己提供</c>
<c.magenta>这些属性</c>

00:35:46.513 --> 00:35:48.115 align:middle line:90%,end
<c.magenta>在呈现属性化字符串时</c>

00:35:48.348 --> 00:35:49.650 align:middle line:90%,end
<c.magenta>可以节约一些时间</c>

00:35:52.186 --> 00:35:53.153 align:middle line:90%,end
<c.magenta>同样地</c>

00:35:53.453 --> 00:35:54.655 align:middle line:90%,end
<c.magenta>显式指定写入方向和对齐</c>

00:35:54.721 --> 00:35:57.491 align:middle line:90%,end
<c.magenta>而不是使用默认设置</c>
<c.magenta>也可以带来</c>

00:35:57.558 --> 00:35:59.059 align:middle line:90%,end
<c.magenta>少量的性能提升</c>

00:35:59.960 --> 00:36:01.061 align:middle line:90%,end
<c.magenta>这将帮助你节约一些时间</c>

00:35:59.960 --> 00:36:01.061 align:middle line:90%,end
<c.magenta>这将帮助你节约一些时间</c>

00:36:01.128 --> 00:36:02.996 align:middle line:90%,end
<c.magenta>因为文本系统</c>
<c.magenta>会跳过一些逻辑</c>

00:36:03.063 --> 00:36:05.399 align:middle line:90%,end
<c.magenta>无需花费时间来确定</c>
<c.magenta>写入方向和对齐</c>

00:36:06.500 --> 00:36:07.968 align:middle line:90%,end
<c.magenta>但是请记住</c>
<c.magenta>在这样做时</c>

00:36:08.035 --> 00:36:10.204 align:middle line:90%,end
<c.magenta>你必须绝对确定</c>
<c.magenta>你的输入数据</c>

00:36:10.270 --> 00:36:12.206 align:middle line:90%,end
<c.magenta>不会包含混合式写入方向</c>

00:36:12.539 --> 00:36:14.675 align:middle line:90%,end
<c.magenta>现在 我们已经在</c>
<c.magenta>性能与正确性之间取得平衡</c>

00:36:14.875 --> 00:36:17.311 align:middle line:90%,end
<c.magenta>一个优化方法是</c>
<c.magenta>如果你对输入不是很确定</c>

00:36:17.444 --> 00:36:20.147 align:middle line:90%,end
<c.magenta>可以让平衡点</c>
<c.magenta>偏离正确性远一点</c>

00:36:23.584 --> 00:36:26.086 align:middle line:90%,end
<c.magenta>这些代码描述如何</c>
<c.magenta>在性能与正确性之间进行取舍</c>

00:36:26.420 --> 00:36:29.389 align:middle line:90%,end
<c.magenta>如果你知道你的所有标签</c>
<c.magenta>都只会包含一行内容</c>

00:36:29.723 --> 00:36:31.658 align:middle line:90%,end
<c.magenta>你可以设置换行模式</c>
<c.magenta>以使用剪辑</c>

00:36:32.392 --> 00:36:34.628 align:middle line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>标签使用文字包裹</c>

00:36:34.795 --> 00:36:36.930 align:middle line:90%,end
<c.magenta>当你这样做时</c>
<c.magenta>文本系统需要确定</c>

00:36:36.997 --> 00:36:38.198 align:middle line:90%,end
<c.magenta>在哪些位置进行分行</c>

00:36:38.599 --> 00:36:40.367 align:middle line:90%,end
<c.magenta>如果你使用</c>
<c.magenta>剪辑分行模式</c>

00:36:40.467 --> 00:36:43.136 align:middle line:90%,end
<c.magenta>将会跳过这个分行</c>
<c.magenta>和连字逻辑</c>

00:36:43.203 --> 00:36:45.172 align:middle line:90%,end
<c.magenta>文本呈现速度</c>
<c.magenta>将会加快</c>

00:36:47.875 --> 00:36:50.410 align:middle line:90%,end
<c.magenta>最后进行总结</c>
<c.magenta>今天我们讨论了很多内容</c>

00:36:50.511 --> 00:36:52.312 align:middle line:90%,end
<c.magenta>从Foundation 中的</c>
<c.magenta>性能改进</c>

00:36:52.546 --> 00:36:54.548 align:middle line:90%,end
<c.magenta>到字符串桥接和文本处理</c>

00:36:55.182 --> 00:36:56.984 align:middle line:90%,end
<c.magenta>如果你只能记住本演讲中的</c>
<c.magenta>一项内容</c>

00:36:57.217 --> 00:36:58.085 align:middle line:90%,end
<c.magenta>那么应该是这个图表</c>

00:36:58.685 --> 00:37:00.654 align:middle line:90%,end
<c.magenta>请使用规模和频率概念</c>

00:36:58.685 --> 00:37:00.654 align:middle line:90%,end
<c.magenta>请使用规模和频率概念</c>

00:37:00.787 --> 00:37:03.390 align:middle line:90%,end
<c.magenta>最低限度减少代码中的</c>
<c.magenta>运行资源开支</c>

00:37:03.724 --> 00:37:05.259 align:middle line:90%,end
<c.magenta>不要专注于不常用的项目</c>

00:37:05.592 --> 00:37:07.261 align:middle line:90%,end
<c.magenta>在不确定时 应该进行评估</c>

00:37:10.063 --> 00:37:12.833 align:middle line:90%,end
<c.magenta>想了解更多内容</c>
<c.magenta>请访问我们的演讲URL</c>

00:37:12.933 --> 00:37:14.234 align:middle line:90%,end
<c.magenta>本演讲是244</c>

00:37:15.769 --> 00:37:19.406 align:middle line:90%,end
<c.magenta>另外请观看</c>
<c.magenta>这些相关的演讲视频</c>

00:37:19.840 --> 00:37:22.309 align:middle line:90%,end
<c.magenta>它们非常不错 遗憾的是</c>
<c.magenta>大多数演讲已经结束</c>

00:37:23.277 --> 00:37:24.945 align:middle line:90%,end
<c.magenta>谢谢</c>
<c.magenta>请关注本次大会的其它内容</c>
