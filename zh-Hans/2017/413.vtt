WEBVTT

00:00:16.917 --> 00:00:21.522 align:middle line:10%
<c.magenta>（应用启动时间：</c>
<c.magenta>过去、现在和未来）</c>

00:00:21.588 --> 00:00:22.723 align:middle line:10%
<c.magenta>大家好</c>

00:00:26.994 --> 00:00:28.629 align:middle line:90%,end
<c.magenta>欢迎参加演讲</c>

00:00:28.996 --> 00:00:31.598 align:middle line:90%,end
<c.magenta>我是Louis Gerbarg</c>
<c.magenta>是dyld团队成员</c>

00:00:31.798 --> 00:00:35.302 align:middle line:90%,end
<c.magenta>今天我们将会讨论</c>
<c.magenta>应用启动的过去、现在和未来</c>

00:00:36.436 --> 00:00:39.239 align:middle line:90%,end
<c.magenta>今天的内容很多</c>
<c.magenta>让我们开始吧</c>

00:00:39.806 --> 00:00:40.974 align:middle line:90%,end
<c.magenta>我想概要介绍</c>

00:00:41.041 --> 00:00:43.110 align:middle line:90%,end
<c.magenta>今天要讲的内容</c>

00:00:43.410 --> 00:00:48.682 align:middle line:90%,end
<c.magenta>首先我会回顾</c>
<c.magenta>去年我们给出的一些建议</c>

00:00:49.216 --> 00:00:51.852 align:middle line:90%,end
<c.magenta>然后讨论我们开发的一些新工具</c>

00:00:51.919 --> 00:00:56.156 align:middle line:90%,end
<c.magenta>这些工具可以更方便地</c>
<c.magenta>找到特定类型的程序启动时间问题</c>

00:00:56.757 --> 00:00:59.593 align:middle line:90%,end
<c.magenta>然后 我简要介绍</c>
<c.magenta>dyld在我们平台上的</c>

00:00:59.660 --> 00:01:01.962 align:middle line:90%,end
<c.magenta>应用历史</c>

00:00:59.660 --> 00:01:01.962 align:middle line:90%,end
<c.magenta>应用历史</c>

00:01:02.529 --> 00:01:06.667 align:middle line:90%,end
<c.magenta>接下来我想讨论我们将在</c>
<c.magenta>macOS High Sierra和iOS 11中</c>

00:01:06.733 --> 00:01:10.137 align:middle line:90%,end
<c.magenta>发布的全新dyld</c>

00:01:10.671 --> 00:01:14.641 align:middle line:90%,end
<c.magenta>最后我想讨论</c>
<c.magenta>这个全新dyld的最佳实践</c>

00:01:16.109 --> 00:01:20.414 align:middle line:90%,end
<c.magenta>首先我做一下记录</c>

00:01:21.882 --> 00:01:23.917 align:middle line:90%,end
<c.magenta>我们希望倾听你们的意见</c>

00:01:24.218 --> 00:01:28.488 align:middle line:90%,end
<c.magenta>如果你们遇到什么问题</c>
<c.magenta>可以将这些问题告诉我们</c>

00:01:28.555 --> 00:01:31.992 align:middle line:90%,end
<c.magenta>请将标题设为“DYLD USAGE”</c>
<c.magenta>我们将会解答这些问题</c>

00:01:34.428 --> 00:01:36.363 align:middle line:90%,end
<c.magenta>现在我想介绍</c>
<c.magenta>我们将会在本演讲中</c>

00:01:36.430 --> 00:01:37.598 align:middle line:90%,end
<c.magenta>使用的一些术语</c>

00:01:38.999 --> 00:01:42.769 align:middle line:90%,end
<c.magenta>首先 启动时间是什么意思？</c>

00:01:43.704 --> 00:01:46.874 align:middle line:90%,end
<c.magenta>在本演讲中</c>
<c.magenta>启动时间是指</c>

00:01:46.940 --> 00:01:49.443 align:middle line:90%,end
<c.magenta>main函数执行之前所用的时间</c>

00:01:49.743 --> 00:01:53.447 align:middle line:90%,end
<c.magenta>如果你编写一个应用</c>
<c.magenta>你需要做很多的事情</c>

00:01:53.514 --> 00:01:57.017 align:middle line:90%,end
<c.magenta>完成之后</c>
<c.magenta>需要加载nib文件和执行其它操作</c>

00:01:57.084 --> 00:01:59.419 align:middle line:90%,end
<c.magenta>需要运行</c>

00:02:00.387 --> 00:02:02.656 align:middle line:90%,end
<c.magenta>UI Application Delegates代码</c>

00:02:03.357 --> 00:02:07.194 align:middle line:90%,end
<c.magenta>这方面的知识有很多</c>
<c.magenta>很多演讲都曾经进行过讨论</c>

00:02:07.494 --> 00:02:10.130 align:middle line:90%,end
<c.magenta>今天我们讨论main执行之前</c>
<c.magenta>所发生的事情</c>

00:02:10.197 --> 00:02:11.899 align:middle line:90%,end
<c.magenta>以及你可以如何加速这个过程</c>

00:02:12.666 --> 00:02:17.571 align:middle line:90%,end
<c.magenta>此外 我还想要解释</c>
<c.magenta>启动收尾 这是一个新术语</c>

00:02:18.505 --> 00:02:21.975 align:middle line:10%
<c.magenta>启动收尾是指启动你的程序</c>

00:02:22.042 --> 00:02:23.343 align:middle line:10%
<c.magenta>所需要的全部信息</c>

00:02:23.577 --> 00:02:27.714 align:middle line:10%
<c.magenta>比如使用什么dylib</c>
<c.magenta>它们的哪些偏移位置用于不同的符号</c>

00:02:27.781 --> 00:02:29.550 align:middle line:10%
<c.magenta>代码签名是什么</c>

00:02:31.118 --> 00:02:34.721 align:middle line:90%,end
<c.magenta>让我们进入演讲的主题</c>

00:02:35.589 --> 00:02:39.226 align:middle line:90%,end
<c.magenta>去年我说过</c>

00:02:39.293 --> 00:02:42.062 align:middle line:90%,end
<c.magenta>我们应该减少代码</c>
<c.magenta>我仍然会强调这一点</c>

00:02:42.129 --> 00:02:45.532 align:middle line:90%,end
<c.magenta>因为代码越少 启动就越快</c>

00:02:45.799 --> 00:02:49.403 align:middle line:90%,end
<c.magenta>无论我们如何加速</c>
<c.magenta>代码越少</c>

00:02:49.469 --> 00:02:50.737 align:middle line:90%,end
<c.magenta>启动速度就越快</c>

00:02:51.672 --> 00:02:53.874 align:middle line:90%,end
<c.magenta>这个建议始终适用</c>

00:02:54.608 --> 00:02:59.713 align:middle line:90%,end
<c.magenta>你应该使用更少的dylib</c>
<c.magenta>减少嵌入的dylib</c>

00:02:59.780 --> 00:03:02.249 align:middle line:90%,end
<c.magenta>从时间的角度来看</c>

00:02:59.780 --> 00:03:02.249 align:middle line:90%,end
<c.magenta>从时间的角度来看</c>

00:03:02.583 --> 00:03:04.685 align:middle line:90%,end
<c.magenta>使用系统库效果更好</c>
<c.magenta>我们将会探讨这一点</c>

00:03:05.419 --> 00:03:08.388 align:middle line:90%,end
<c.magenta>应该声明较少的库和方法</c>

00:03:08.455 --> 00:03:11.558 align:middle line:90%,end
<c.magenta>减少初始化函数</c>

00:03:13.627 --> 00:03:16.396 align:middle line:90%,end
<c.magenta>最后我将会介绍一些事半功倍的方法</c>

00:03:16.463 --> 00:03:19.533 align:middle line:90%,end
<c.magenta>你可以使用更多的Swift代码</c>

00:03:19.600 --> 00:03:24.204 align:middle line:90%,end
<c.magenta>因为Swift从设计上</c>
<c.magenta>避免许多的陷阱</c>

00:03:24.271 --> 00:03:27.341 align:middle line:90%,end
<c.magenta>在使用C、C++ 和</c>
<c.magenta>Objective-C可能会遇到这些陷阱</c>

00:03:27.407 --> 00:03:29.443 align:middle line:90%,end
<c.magenta>Swift没有初始化器</c>

00:03:29.910 --> 00:03:32.513 align:middle line:90%,end
<c.magenta>Swift不允许特定类型的</c>
<c.magenta>未对齐数据结构</c>

00:03:32.579 --> 00:03:34.481 align:middle line:90%,end
<c.magenta>这样的结构会延长启动时间</c>

00:03:34.548 --> 00:03:36.617 align:middle line:90%,end
<c.magenta>总的来说 转向Swift</c>

00:03:36.683 --> 00:03:41.388 align:middle line:90%,end
<c.magenta>让你更容易获得快速的程序启动</c>

00:03:42.523 --> 00:03:45.993 align:middle line:90%,end
<c.magenta>Swift代码更精简</c>
<c.magenta>因此性能更好</c>

00:03:46.059 --> 00:03:48.762 align:middle line:90%,end
<c.magenta>因此请转移到</c>
<c.magenta>我们今年发布的新Swift</c>

00:03:48.829 --> 00:03:51.532 align:middle line:90%,end
<c.magenta>将会提供更多的好处</c>

00:03:51.965 --> 00:03:54.902 align:middle line:90%,end
<c.magenta>现在我们来看</c>

00:03:57.371 --> 00:04:01.175 align:middle line:90%,end
<c.magenta>iOS 11和</c>
<c.magenta>macOS High Sierra中的新工具</c>

00:03:57.371 --> 00:04:01.175 align:middle line:90%,end
<c.magenta>iOS 11和</c>
<c.magenta>macOS High Sierra中的新工具</c>

00:04:01.241 --> 00:04:05.012 align:middle line:90%,end
<c.magenta>我们在Instruments中</c>
<c.magenta>加入静态初始化器跟踪</c>

00:04:05.078 --> 00:04:06.413 align:middle line:90%,end
<c.magenta>缩短应用启动时间</c>

00:04:06.480 --> 00:04:09.983 align:middle line:90%,end
<c.magenta>这是非常不错的功能</c>
<c.magenta>因为初始化器是代码</c>

00:04:10.050 --> 00:04:13.453 align:middle line:90%,end
<c.magenta>它们在main函数之前运行</c>
<c.magenta>为你设置对象</c>

00:04:13.520 --> 00:04:16.557 align:middle line:90%,end
<c.magenta>你并不能透彻地</c>
<c.magenta>了解main执行之前的情况</c>

00:04:17.391 --> 00:04:19.625 align:middle line:90%,end
<c.magenta>现在Instruments</c>
<c.magenta>增加这个功能</c>

00:04:19.692 --> 00:04:22.596 align:middle line:90%,end
<c.magenta>提供每个静态初始化器的准确时间</c>

00:04:22.663 --> 00:04:25.432 align:middle line:90%,end
<c.magenta>现在我进行演示</c>

00:04:25.732 --> 00:04:31.438 align:middle line:90%,end
<c.magenta>这里有一个应用</c>
<c.magenta>与WWDC上的大多数应用一样</c>

00:04:31.505 --> 00:04:34.474 align:middle line:90%,end
<c.magenta>它也使用一些可爱的动物图片</c>

00:04:35.142 --> 00:04:36.410 align:middle line:90%,end
<c.magenta>让我启动它</c>

00:04:37.744 --> 00:04:41.248 align:middle line:90%,end
<c.magenta>这需要一定时间</c>

00:04:42.649 --> 00:04:45.152 align:middle line:90%,end
<c.magenta>还需要一点时间</c>

00:04:45.219 --> 00:04:48.755 align:middle line:10%
<c.magenta>启动后 我们看到几只灰鼠和猫</c>

00:04:50.791 --> 00:04:54.962 align:middle line:90%,end
<c.magenta>让我们来看为什么</c>
<c.magenta>需要这么长的启动时间</c>

00:04:55.596 --> 00:04:58.765 align:middle line:90%,end
<c.magenta>我会在Instruments中</c>
<c.magenta>进行分析</c>

00:04:58.832 --> 00:05:04.238 align:middle line:90%,end
<c.magenta>我停止执行这行代码</c>
<c.magenta>然后运行</c>

00:04:58.832 --> 00:05:04.238 align:middle line:90%,end
<c.magenta>我停止执行这行代码</c>
<c.magenta>然后运行</c>

00:05:05.973 --> 00:05:09.710 align:middle line:90%,end
<c.magenta>现在我启动一个空模板</c>

00:05:10.944 --> 00:05:13.480 align:middle line:90%,end
<c.magenta>添加新静态初始化器工具</c>

00:05:15.849 --> 00:05:17.551 align:middle line:90%,end
<c.magenta>就在这里</c>

00:05:17.618 --> 00:05:19.720 align:middle line:90%,end
<c.magenta>然后我添加一个</c>
<c.magenta>Time Profiler</c>

00:05:19.786 --> 00:05:22.422 align:middle line:90%,end
<c.magenta>这样就很容易看到运行情况</c>

00:05:28.295 --> 00:05:29.129 align:middle line:90%,end
<c.magenta>开始运行</c>

00:05:29.830 --> 00:05:33.433 align:middle line:90%,end
<c.magenta>设置好这些工具之后</c>
<c.magenta>我们开始运行程序</c>

00:05:35.235 --> 00:05:37.704 align:middle line:90%,end
<c.magenta>我们获得跟踪数据</c>

00:05:38.906 --> 00:05:41.008 align:middle line:90%,end
<c.magenta>还没有出现</c>

00:05:41.074 --> 00:05:44.378 align:middle line:90%,end
<c.magenta>现在出现了</c>
<c.magenta>在背景中可以看到</c>

00:05:45.646 --> 00:05:47.014 align:middle line:90%,end
<c.magenta>出现显示内容</c>

00:05:47.080 --> 00:05:49.683 align:middle line:90%,end
<c.magenta>我会放大</c>
<c.magenta>让你们看得更清楚</c>

00:05:50.350 --> 00:05:53.453 align:middle line:90%,end
<c.magenta>这里有一个函数名为</c>
<c.magenta>waitForNetworkDebugger</c>

00:05:53.520 --> 00:05:54.955 align:middle line:90%,end
<c.magenta>这是正确的</c>
<c.magenta>因为我正在从网站</c>

00:05:55.022 --> 00:05:58.125 align:middle line:90%,end
<c.magenta>加载数据源</c>

00:05:58.692 --> 00:06:00.561 align:middle line:90%,end
<c.magenta>我尝试进行调试</c>

00:05:58.692 --> 00:06:00.561 align:middle line:90%,end
<c.magenta>我尝试进行调试</c>

00:06:00.627 --> 00:06:04.898 align:middle line:90%,end
<c.magenta>让我们来看CPU Usage工具</c>

00:06:04.965 --> 00:06:10.771 align:middle line:90%,end
<c.magenta>可以看到初始化器运行时间</c>
<c.magenta>与CPU占用时间基本相同</c>

00:06:11.271 --> 00:06:14.107 align:middle line:90%,end
<c.magenta>在这里 可以看到dyld</c>

00:06:15.609 --> 00:06:20.614 align:middle line:10%
<c.magenta>如果我这样做</c>
<c.magenta>可以看到哪些处理占用时间</c>

00:06:21.148 --> 00:06:24.952 align:middle line:10%
<c.magenta>所用时间为9.5秒</c>

00:06:25.018 --> 00:06:29.823 align:middle line:10%
<c.magenta>初始化器占用9.5秒</c>
<c.magenta>我们展开很多层</c>

00:06:29.890 --> 00:06:33.160 align:middle line:10%
<c.magenta>通常你不用这样做</c>
<c.magenta>我是为了让你们看清楚运行情况</c>

00:06:34.728 --> 00:06:38.298 align:middle line:10%
<c.magenta>在这里我们可以看到</c>
<c.magenta>waitForNetworkDebugger</c>

00:06:38.365 --> 00:06:40.000 align:middle line:10%
<c.magenta>我们在初始化器调用中</c>
<c.magenta>见到过它</c>

00:06:40.067 --> 00:06:42.336 align:middle line:10%
<c.magenta>现在你很容易找到它</c>

00:06:42.703 --> 00:06:48.041 align:middle line:10%
<c.magenta>现在我返回Xcode</c>

00:06:48.509 --> 00:06:52.579 align:middle line:10%
<c.magenta>看到了</c>
<c.magenta>这是waitForNetworkDebugger调用</c>

00:06:52.646 --> 00:06:54.648 align:middle line:10%
<c.magenta>我使用C语言实现它</c>

00:06:54.715 --> 00:06:56.683 align:middle line:10%
<c.magenta>因为Swift不允许做这样的事情</c>

00:06:57.117 --> 00:07:01.088 align:middle line:10%
<c.magenta>我在这里创建构造函数</c>

00:06:57.117 --> 00:07:01.088 align:middle line:10%
<c.magenta>我在这里创建构造函数</c>

00:07:01.154 --> 00:07:03.190 align:middle line:90%,end
<c.magenta>如果我返回源代码</c>

00:07:05.926 --> 00:07:09.930 align:middle line:90%,end
<c.magenta>我可以删除这个函数</c>

00:07:10.931 --> 00:07:12.866 align:middle line:90%,end
<c.magenta>因为它仅用于调试目的</c>

00:07:13.534 --> 00:07:18.238 align:middle line:10%
<c.magenta>如果运行 程序将会立即启动</c>

00:07:18.906 --> 00:07:21.542 align:middle line:90%,end
<c.magenta>因此我们可以快速地发现</c>

00:07:21.608 --> 00:07:24.144 align:middle line:90%,end
<c.magenta>哪些堆栈初始化器</c>
<c.magenta>导致启动变慢</c>

00:07:24.211 --> 00:07:27.047 align:middle line:90%,end
<c.magenta>这涉及多个dylib</c>

00:07:27.114 --> 00:07:29.383 align:middle line:90%,end
<c.magenta>包括系统dylib</c>
<c.magenta>这些系统库会占用很长时间</c>

00:07:29.449 --> 00:07:32.853 align:middle line:90%,end
<c.magenta>这是你为它们提供的输入造成的</c>
<c.magenta>比如复杂的nib文件</c>

00:07:33.487 --> 00:07:39.760 align:middle line:90%,end
<c.magenta>这依赖于High Sierra</c>
<c.magenta>和iOS 11的内核</c>

00:07:39.826 --> 00:07:43.597 align:middle line:90%,end
<c.magenta>和dyld中的新基础结构</c>
<c.magenta>你需要新生成程序才能看到这些信息</c>

00:07:43.897 --> 00:07:46.867 align:middle line:90%,end
<c.magenta>现在可以捕获大多数初始化器</c>
<c.magenta>我们还在努力捕获</c>

00:07:46.934 --> 00:07:50.737 align:middle line:90%,end
<c.magenta>一些边界例子</c>
<c.magenta>但是目前你已经能够</c>

00:07:50.804 --> 00:07:54.608 align:middle line:90%,end
<c.magenta>快速地发现</c>
<c.magenta>是什么占用程序启动时间</c>

00:07:54.675 --> 00:07:57.711 align:middle line:90%,end
<c.magenta>让你能够解决问题</c>
<c.magenta>更快速地启动程序</c>

00:07:57.778 --> 00:07:59.279 align:middle line:90%,end
<c.magenta>提供更好的用户体验</c>

00:07:59.580 --> 00:08:00.447 align:middle line:90%,end
<c.magenta>谢谢</c>

00:07:59.580 --> 00:08:00.447 align:middle line:90%,end
<c.magenta>谢谢</c>

00:08:05.552 --> 00:08:09.022 align:middle line:90%,end
<c.magenta>前面我说过</c>
<c.magenta>我们会简要地回顾dyld的历史</c>

00:08:10.023 --> 00:08:12.526 align:middle line:90%,end
<c.magenta>跨世纪的动态链接技术</c>

00:08:12.893 --> 00:08:15.762 align:middle line:90%,end
<c.magenta>很早以前我们就已经推出dyld</c>

00:08:15.829 --> 00:08:19.199 align:middle line:90%,end
<c.magenta>它们没有版本号</c>

00:08:19.266 --> 00:08:23.770 align:middle line:90%,end
<c.magenta>这是dyld 1</c>
<c.magenta>包含在NeXTStep 3.3中</c>

00:08:24.972 --> 00:08:26.640 align:middle line:90%,end
<c.magenta>可以追溯到1996年</c>

00:08:26.707 --> 00:08:31.645 align:middle line:90%,end
<c.magenta>此前 NeXT使用静态二进制数据</c>

00:08:32.513 --> 00:08:38.552 align:middle line:90%,end
<c.magenta>作用并不是很大 其历史早于</c>
<c.magenta>标准化POSIX dlopen调用</c>

00:08:38.619 --> 00:08:40.854 align:middle line:90%,end
<c.magenta>现在dlopen还存在于</c>
<c.magenta>某些Unix之中</c>

00:08:40.921 --> 00:08:44.591 align:middle line:90%,end
<c.magenta>它们是一些专用扩展</c>
<c.magenta>被开发者所采用</c>

00:08:45.092 --> 00:08:48.061 align:middle line:90%,end
<c.magenta>NeXTStep</c>
<c.magenta>具有不同的专用扩展</c>

00:08:48.128 --> 00:08:52.399 align:middle line:90%,end
<c.magenta>因此开发者在macOS 10</c>
<c.magenta>的早期版本上编写第三方包装器</c>

00:08:52.466 --> 00:08:54.401 align:middle line:90%,end
<c.magenta>以支持标准Unix软件</c>

00:08:54.768 --> 00:08:58.005 align:middle line:90%,end
<c.magenta>问题是这些包装器</c>
<c.magenta>并不能完美地支持相同的语义</c>

00:08:58.071 --> 00:09:00.607 align:middle line:90%,end
<c.magenta>因此可能有一些边界例子</c>
<c.magenta>不能正常工作</c>

00:08:58.071 --> 00:09:00.607 align:middle line:90%,end
<c.magenta>因此可能有一些边界例子</c>
<c.magenta>不能正常工作</c>

00:09:00.674 --> 00:09:02.743 align:middle line:90%,end
<c.magenta>因此会造成运行缓慢</c>

00:09:03.143 --> 00:09:07.848 align:middle line:90%,end
<c.magenta>它是在大多数使用</c>
<c.magenta>C++ 动态库的系统之前编写的</c>

00:09:07.915 --> 00:09:09.149 align:middle line:90%,end
<c.magenta>这些知识很重要</c>

00:09:09.550 --> 00:09:13.520 align:middle line:90%,end
<c.magenta>C++ 有许多的特性</c>
<c.magenta>比如其初始化器排序方式等</c>

00:09:13.587 --> 00:09:17.791 align:middle line:90%,end
<c.magenta>它们在静态环境中工作良好</c>

00:09:17.858 --> 00:09:20.027 align:middle line:90%,end
<c.magenta>但是在动态环境中</c>

00:09:20.093 --> 00:09:22.930 align:middle line:90%,end
<c.magenta>可能会降低性能</c>

00:09:23.030 --> 00:09:24.631 align:middle line:90%,end
<c.magenta>因此大型C++代码库</c>

00:09:24.698 --> 00:09:29.636 align:middle line:90%,end
<c.magenta>导致动态链接器</c>
<c.magenta>需要完成大量的工作 速度变慢</c>

00:09:33.140 --> 00:09:38.579 align:middle line:90%,end
<c.magenta>在发布macOS 10.0和</c>
<c.magenta>Cheetah前 我们还增加另外一个特性</c>

00:09:38.645 --> 00:09:40.113 align:middle line:90%,end
<c.magenta>名称为预绑定</c>

00:09:40.581 --> 00:09:44.685 align:middle line:90%,end
<c.magenta>你们一些人知道预绑定技术</c>

00:09:46.220 --> 00:09:48.622 align:middle line:90%,end
<c.magenta>我知道你们会感到困惑</c>

00:09:48.689 --> 00:09:52.392 align:middle line:90%,end
<c.magenta>我们使用预绑定技术</c>
<c.magenta>为系统中的所有dylib和你的程序</c>

00:09:52.459 --> 00:09:56.330 align:middle line:90%,end
<c.magenta>找到固定地址</c>

00:09:56.630 --> 00:09:59.967 align:middle line:90%,end
<c.magenta>动态加载器将会</c>
<c.magenta>加载这些地址的所有内容</c>

00:10:00.033 --> 00:10:04.104 align:middle line:90%,end
<c.magenta>如果成功 将会编辑</c>
<c.magenta>所有这些二进制数据</c>

00:10:04.171 --> 00:10:07.241 align:middle line:90%,end
<c.magenta>以获得所有预计算地址</c>
<c.magenta>然后下次</c>

00:10:07.307 --> 00:10:10.878 align:middle line:90%,end
<c.magenta>当它将所有数据放入相同地址时</c>
<c.magenta>不必进行任何其它额外的工作</c>

00:10:11.144 --> 00:10:13.580 align:middle line:90%,end
<c.magenta>这会大幅提高速度</c>

00:10:14.248 --> 00:10:19.086 align:middle line:90%,end
<c.magenta>但是这也意味着</c>
<c.magenta>每次启动时会编辑你的二进制数据</c>

00:10:19.520 --> 00:10:22.256 align:middle line:90%,end
<c.magenta>这并不是很好的做法</c>

00:10:22.322 --> 00:10:23.991 align:middle line:90%,end
<c.magenta>至少从安全性来说是如此</c>

00:10:25.893 --> 00:10:29.530 align:middle line:90%,end
<c.magenta>后来我们推出dyld 2</c>
<c.magenta>它是macOS Tiger的组成部分</c>

00:10:30.264 --> 00:10:34.234 align:middle line:90%,end
<c.magenta>dyld 2是dyld的</c>
<c.magenta>完全重写版本</c>

00:10:36.069 --> 00:10:38.805 align:middle line:90%,end
<c.magenta>正确支持C++初始化器语义</c>

00:10:38.872 --> 00:10:44.511 align:middle line:90%,end
<c.magenta>我们扩展mach-o格式</c>
<c.magenta>并且更新dyld</c>

00:10:44.578 --> 00:10:47.347 align:middle line:90%,end
<c.magenta>从而获得高效率的C++库支持</c>

00:10:47.848 --> 00:10:51.251 align:middle line:90%,end
<c.magenta>它具有完整的本机dlopen</c>
<c.magenta>和dlsym实现</c>

00:10:51.318 --> 00:10:54.988 align:middle line:90%,end
<c.magenta>具有正确的语义</c>
<c.magenta>我们弃用旧版API</c>

00:10:55.055 --> 00:10:58.992 align:middle line:90%,end
<c.magenta>这些旧版API仍然位于macOS中</c>
<c.magenta>没有加入到我们的任何其它平台上</c>

00:11:00.827 --> 00:11:02.996 align:middle line:90%,end
<c.magenta>dyld的设计目标是提高速度</c>

00:11:03.463 --> 00:11:06.934 align:middle line:90%,end
<c.magenta>因此仅进行有限的健全性检查</c>

00:11:07.000 --> 00:11:10.237 align:middle line:90%,end
<c.magenta>以前 恶意程序并不多</c>

00:11:11.271 --> 00:11:15.142 align:middle line:10%
<c.magenta>由于它有一些安全问题</c>

00:11:15.209 --> 00:11:20.414 align:middle line:10%
<c.magenta>因此我们对一些功能进行改进</c>
<c.magenta>提高它在现在平台上的安全性</c>

00:11:21.215 --> 00:11:25.185 align:middle line:10%
<c.magenta>由于其速度大幅提升</c>
<c.magenta>因此我们可以减少预绑定工作量</c>

00:11:25.252 --> 00:11:30.524 align:middle line:10%
<c.magenta>不同于编辑你的程序数据</c>
<c.magenta>我们仅编辑系统库</c>

00:11:30.591 --> 00:11:33.927 align:middle line:10%
<c.magenta>可以仅在软件更新时</c>
<c.magenta>做这些事情</c>

00:11:33.994 --> 00:11:37.097 align:middle line:10%
<c.magenta>因此在软件安装过程中</c>

00:11:37.164 --> 00:11:41.735 align:middle line:10%
<c.magenta>你可能会看到</c>
<c.magenta>“优化系统性能”之类的文字</c>

00:11:41.802 --> 00:11:46.473 align:middle line:10%
<c.magenta>这时就是在更新预绑定</c>

00:11:46.540 --> 00:11:48.909 align:middle line:10%
<c.magenta>现在dyld用于所有优化</c>

00:11:48.976 --> 00:11:50.477 align:middle line:10%
<c.magenta>其用途就是优化</c>

00:11:51.745 --> 00:11:54.414 align:middle line:10%
<c.magenta>因此后来我们发布了dyld 2</c>

00:11:55.215 --> 00:11:59.386 align:middle line:90%,end
<c.magenta>在过去几年我们进行大量改进</c>
<c.magenta>性能显著提高</c>

00:11:59.453 --> 00:12:04.258 align:middle line:90%,end
<c.magenta>首先 我们增加了</c>
<c.magenta>大量的基础结构和平台</c>

00:11:59.453 --> 00:12:04.258 align:middle line:90%,end
<c.magenta>首先 我们增加了</c>
<c.magenta>大量的基础结构和平台</c>

00:12:05.158 --> 00:12:07.961 align:middle line:90%,end
<c.magenta>自从dyld 2</c>
<c.magenta>在PowerPC发布之后</c>

00:12:08.028 --> 00:12:13.033 align:middle line:90%,end
<c.magenta>我们增加了x86、 x86 64 arm</c>
<c.magenta>arm64和许多的衍生平台</c>

00:12:13.667 --> 00:12:16.170 align:middle line:90%,end
<c.magenta>我们还推出iOS、tvOS</c>
<c.magenta>和watchOS</c>

00:12:16.236 --> 00:12:18.939 align:middle line:90%,end
<c.magenta>它们全部都需要新dyld功能</c>

00:12:20.040 --> 00:12:23.177 align:middle line:90%,end
<c.magenta>我们通过多种方式增强安全性</c>

00:12:23.710 --> 00:12:26.980 align:middle line:90%,end
<c.magenta>增加代码签名和ASLR</c>

00:12:27.047 --> 00:12:30.384 align:middle line:90%,end
<c.magenta>也就是地址空间配置随机加载</c>

00:12:31.185 --> 00:12:33.253 align:middle line:90%,end
<c.magenta>这意味着每次你加载库</c>

00:12:33.320 --> 00:12:34.788 align:middle line:90%,end
<c.magenta>它可能位于不同的地址</c>

00:12:35.455 --> 00:12:38.759 align:middle line:90%,end
<c.magenta>如果想要了解更多详细信息</c>
<c.magenta>请观看去年的演讲</c>

00:12:38.825 --> 00:12:43.897 align:middle line:90%,end
<c.magenta>在此演讲中Nick详细介绍了</c>
<c.magenta>如何启动程序</c>

00:12:43.964 --> 00:12:46.066 align:middle line:90%,end
<c.magenta>最后 我们增加了</c>
<c.magenta>mach-o文件头中的项目</c>

00:12:46.133 --> 00:12:48.001 align:middle line:90%,end
<c.magenta>这是重要的边界检查功能</c>

00:12:48.068 --> 00:12:51.772 align:middle line:90%,end
<c.magenta>从而可以避免恶意二进制数据的加入</c>

00:12:52.906 --> 00:12:55.776 align:middle line:90%,end
<c.magenta>最后 我们增强了性能</c>

00:12:55.843 --> 00:12:59.580 align:middle line:10%
<c.magenta>因此我们可以消除预绑定</c>

00:12:59.646 --> 00:13:02.616 align:middle line:10%
<c.magenta>转而使用共享代码</c>

00:12:59.646 --> 00:13:02.616 align:middle line:10%
<c.magenta>转而使用共享代码</c>

00:13:03.150 --> 00:13:05.085 align:middle line:10%
<c.magenta>那么什么是共享代码？</c>

00:13:06.286 --> 00:13:10.958 align:middle line:90%,end
<c.magenta>共享代码最早被引入和iOS 3.1</c>
<c.magenta>和macOS Snow Leopard</c>

00:13:11.825 --> 00:13:14.161 align:middle line:90%,end
<c.magenta>并且完全取代预绑定</c>

00:13:14.895 --> 00:13:18.565 align:middle line:90%,end
<c.magenta>它是一个单文件</c>
<c.magenta>含有大多数系统dylib</c>

00:13:18.999 --> 00:13:20.734 align:middle line:90%,end
<c.magenta>由于合并成一个文件</c>

00:13:20.801 --> 00:13:22.736 align:middle line:90%,end
<c.magenta>因此可以进行优化</c>

00:13:22.970 --> 00:13:25.272 align:middle line:90%,end
<c.magenta>我们重新调整所有文本段</c>

00:13:25.339 --> 00:13:28.675 align:middle line:90%,end
<c.magenta>和所有数据段重写整个符号表</c>

00:13:28.742 --> 00:13:33.180 align:middle line:90%,end
<c.magenta>以减小大小</c>
<c.magenta>从而在每个进程中</c>

00:13:33.247 --> 00:13:34.781 align:middle line:90%,end
<c.magenta>仅挂载少量的区域</c>

00:13:35.315 --> 00:13:38.852 align:middle line:90%,end
<c.magenta>它允许我们打包二进制数据段</c>
<c.magenta>节省大量的RAM</c>

00:13:39.720 --> 00:13:42.823 align:middle line:90%,end
<c.magenta>它实际上是dylib预链接器</c>

00:13:43.423 --> 00:13:47.327 align:middle line:90%,end
<c.magenta>我并不会讨论特定的优化结果</c>

00:13:47.728 --> 00:13:50.898 align:middle line:90%,end
<c.magenta>但是它的RAM节约是显著的</c>
<c.magenta>在普通iOS系统上</c>

00:13:50.964 --> 00:13:55.836 align:middle line:90%,end
<c.magenta>运行时可以节约500M-1GB内存</c>

00:13:57.571 --> 00:14:01.208 align:middle line:90%,end
<c.magenta>它还预生成数据结构</c>
<c.magenta>供dyld和Ob-C</c>

00:13:57.571 --> 00:14:01.208 align:middle line:90%,end
<c.magenta>它还预生成数据结构</c>
<c.magenta>供dyld和Ob-C</c>

00:14:01.275 --> 00:14:03.911 align:middle line:90%,end
<c.magenta>在运行时使用</c>
<c.magenta>让我们不必在程序启动时做这些事情</c>

00:14:03.977 --> 00:14:06.513 align:middle line:90%,end
<c.magenta>这也会节约更多RAM和时间</c>

00:14:07.748 --> 00:14:12.186 align:middle line:10%
<c.magenta>共享代码在macOS上本地生成</c>
<c.magenta>运行dyld共享代码</c>

00:14:12.252 --> 00:14:14.688 align:middle line:10%
<c.magenta>将会大幅优化系统性能</c>

00:14:14.755 --> 00:14:16.623 align:middle line:10%
<c.magenta>并且带来其它好处</c>

00:14:16.890 --> 00:14:19.860 align:middle line:90%,end
<c.magenta>在我们的其它平台上</c>
<c.magenta>我们在Apple生成共享代码</c>

00:14:19.927 --> 00:14:21.061 align:middle line:90%,end
<c.magenta>然后提供给你</c>

00:14:22.629 --> 00:14:24.865 align:middle line:90%,end
<c.magenta>刚才我讨论了共享代码</c>

00:14:24.932 --> 00:14:27.768 align:middle line:90%,end
<c.magenta>接下来我介绍dyld 3</c>

00:14:28.735 --> 00:14:33.473 align:middle line:90%,end
<c.magenta>dyld 3是全新的动态链接器</c>
<c.magenta>今天我们宣布推出它</c>

00:14:34.641 --> 00:14:37.411 align:middle line:90%,end
<c.magenta>它完全改变动态链接概念</c>

00:14:38.445 --> 00:14:42.816 align:middle line:90%,end
<c.magenta>将成为大多数</c>

00:14:42.883 --> 00:14:44.484 align:middle line:90%,end
<c.magenta>macOS系统程序的默认设置</c>

00:14:45.719 --> 00:14:48.355 align:middle line:90%,end
<c.magenta>2017 Apple OS平台上的</c>
<c.magenta>所有系统程序</c>

00:14:48.422 --> 00:14:52.025 align:middle line:90%,end
<c.magenta>都会默认使用它</c>

00:14:53.660 --> 00:14:57.297 align:middle line:90%,end
<c.magenta>在未来的Apple OS平台</c>
<c.magenta>和第三方程序中</c>

00:14:57.364 --> 00:14:59.333 align:middle line:90%,end
<c.magenta>它将会全面取代dyld2</c>

00:15:00.300 --> 00:15:04.271 align:middle line:90%,end
<c.magenta>那么 我们为什么要再次使用</c>
<c.magenta>动态链接器呢？</c>

00:15:06.373 --> 00:15:08.675 align:middle line:90%,end
<c.magenta>首先是为了性能</c>

00:15:08.742 --> 00:15:10.511 align:middle line:90%,end
<c.magenta>性能是一个永恒的主题</c>

00:15:10.577 --> 00:15:13.647 align:middle line:90%,end
<c.magenta>我们想要尽量提高启动速度</c>

00:15:14.381 --> 00:15:17.184 align:middle line:90%,end
<c.magenta>我们认为 它可以帮助</c>

00:15:17.251 --> 00:15:19.219 align:middle line:90%,end
<c.magenta>我们获得最快的</c>

00:15:19.286 --> 00:15:22.723 align:middle line:90%,end
<c.magenta>程序启动和运行速度</c>

00:15:23.423 --> 00:15:29.329 align:middle line:90%,end
<c.magenta>其次是安全性 前面我说过</c>
<c.magenta>我们在dyld2中增加了些安全特性</c>

00:15:29.396 --> 00:15:32.366 align:middle line:90%,end
<c.magenta>但是很难跟随现实情形</c>
<c.magenta>增强安全性</c>

00:15:32.533 --> 00:15:35.335 align:middle line:90%,end
<c.magenta>过去几年我们做了很多的工作</c>

00:15:35.402 --> 00:15:38.839 align:middle line:90%,end
<c.magenta>但是难以实现这个目标</c>

00:15:39.740 --> 00:15:42.109 align:middle line:90%,end
<c.magenta>那么我们是否能够</c>
<c.magenta>进行更积极的安全检查</c>

00:15:42.176 --> 00:15:44.178 align:middle line:90%,end
<c.magenta>并且从设计上提高安全性？</c>

00:15:45.112 --> 00:15:48.148 align:middle line:90%,end
<c.magenta>最后是可测试性和可靠性</c>

00:15:48.482 --> 00:15:50.317 align:middle line:90%,end
<c.magenta>我们能否让dyld变得更容易测试？</c>

00:15:50.384 --> 00:15:53.921 align:middle line:90%,end
<c.magenta>为此Apple发布了很多不错的</c>
<c.magenta>测试框架 比如XCTest</c>

00:15:53.987 --> 00:15:56.690 align:middle line:90%,end
<c.magenta>我们应该使用它们</c>

00:15:56.757 --> 00:15:59.459 align:middle line:90%,end
<c.magenta>但是它们依赖于</c>
<c.magenta>动态链接器的底层功能</c>

00:15:59.526 --> 00:16:03.897 align:middle line:90%,end
<c.magenta>将它们的库插入进程</c>
<c.magenta>因此它们不能用于</c>

00:15:59.526 --> 00:16:03.897 align:middle line:90%,end
<c.magenta>将它们的库插入进程</c>
<c.magenta>因此它们不能用于</c>

00:16:03.964 --> 00:16:05.933 align:middle line:90%,end
<c.magenta>测试现有的dyld代码</c>

00:16:05.999 --> 00:16:09.703 align:middle line:90%,end
<c.magenta>这让我们难以测试安全性和性能水平</c>

00:16:10.938 --> 00:16:13.440 align:middle line:90%,end
<c.magenta>我们应该如何做呢？</c>

00:16:13.507 --> 00:16:17.177 align:middle line:90%,end
<c.magenta>我们将大多数dyld移出进程</c>

00:16:19.079 --> 00:16:21.882 align:middle line:90%,end
<c.magenta>现在它只是普通的后台程序</c>

00:16:21.949 --> 00:16:25.285 align:middle line:90%,end
<c.magenta>可以使用标准测试工具进行测试</c>

00:16:25.352 --> 00:16:26.186 align:middle line:90%,end
<c.magenta>这让我们以后</c>

00:16:26.253 --> 00:16:28.956 align:middle line:90%,end
<c.magenta>进一步提高速度和性能</c>

00:16:30.157 --> 00:16:35.095 align:middle line:90%,end
<c.magenta>另外也允许部分dyld</c>
<c.magenta>驻留在进程之中</c>

00:16:35.162 --> 00:16:40.367 align:middle line:90%,end
<c.magenta>但是驻留部分尽可小</c>
<c.magenta>从而减少程序的受攻击面积</c>

00:16:42.135 --> 00:16:45.772 align:middle line:90%,end
<c.magenta>由于代码速度提升</c>

00:16:45.839 --> 00:16:47.708 align:middle line:90%,end
<c.magenta>因此会提高启动速度</c>

00:16:48.542 --> 00:16:51.545 align:middle line:10%
<c.magenta>代码运行速度是前所未有的</c>

00:16:52.379 --> 00:16:53.780 align:middle line:10%
<c.magenta>为了让你知道我们是如何做到的</c>

00:16:53.847 --> 00:16:57.985 align:middle line:10%
<c.magenta>我将简要演示</c>
<c.magenta>dyld 2如何启动程序</c>

00:16:58.051 --> 00:17:01.855 align:middle line:10%
<c.magenta>在去年的“缩短程序启动时间”演讲中</c>

00:16:58.051 --> 00:17:01.855 align:middle line:10%
<c.magenta>在去年的“缩短程序启动时间”演讲中</c>

00:17:01.922 --> 00:17:04.458 align:middle line:90%,end
<c.magenta>我们更详细地讨论了这个主题</c>

00:17:04.525 --> 00:17:06.593 align:middle line:90%,end
<c.magenta>你可以观看那个演讲视频</c>

00:17:06.660 --> 00:17:08.095 align:middle line:90%,end
<c.magenta>这是一个不错的主意</c>

00:17:08.262 --> 00:17:11.865 align:middle line:90%,end
<c.magenta>当然你也可以听我的演讲</c>
<c.magenta>我会简要介绍</c>

00:17:12.699 --> 00:17:16.637 align:middle line:10%
<c.magenta>我们使用dyld 2</c>
<c.magenta>你的程序开始启动</c>

00:17:16.703 --> 00:17:19.006 align:middle line:10%
<c.magenta>我们需要分析你的mach-o文件</c>

00:17:19.306 --> 00:17:22.276 align:middle line:10%
<c.magenta>弄清楚你需要哪些库</c>

00:17:22.776 --> 00:17:27.247 align:middle line:10%
<c.magenta>它们可能需要其它库</c>
<c.magenta>我们进行递归分析</c>

00:17:27.314 --> 00:17:29.483 align:middle line:10%
<c.magenta>直到获得所有dylib的完整图</c>

00:17:29.550 --> 00:17:33.820 align:middle line:10%
<c.magenta>普通iOS程序</c>
<c.magenta>需要3-600个dylib</c>

00:17:33.887 --> 00:17:35.622 align:middle line:10%
<c.magenta>数据庞大 需要进行大量的处理</c>

00:17:36.924 --> 00:17:41.328 align:middle line:10%
<c.magenta>然后我们映射到所有mach-o文件</c>
<c.magenta>将它们放入地址空间</c>

00:17:42.462 --> 00:17:45.499 align:middle line:10%
<c.magenta>然后执行符号查找</c>

00:17:45.566 --> 00:17:47.167 align:middle line:10%
<c.magenta>若你的程序使用printf函数</c>

00:17:47.234 --> 00:17:50.003 align:middle line:10%
<c.magenta>将会查找printf是否在库系统中</c>

00:17:50.504 --> 00:17:51.872 align:middle line:10%
<c.magenta>然后我们找到它的地址</c>

00:17:51.939 --> 00:17:55.275 align:middle line:10%
<c.magenta>将它复制到你的程序中的函数指针</c>

00:17:56.577 --> 00:17:59.112 align:middle line:10%
<c.magenta>我们进行绑定和基址重置</c>

00:17:59.179 --> 00:18:03.283 align:middle line:10%
<c.magenta>复制这些指针</c>
<c.magenta>由于使用随机地址</c>

00:17:59.179 --> 00:18:03.283 align:middle line:10%
<c.magenta>复制这些指针</c>
<c.magenta>由于使用随机地址</c>

00:18:03.350 --> 00:18:06.486 align:middle line:10%
<c.magenta>所有指针必须使用基址</c>

00:18:07.454 --> 00:18:09.489 align:middle line:10%
<c.magenta>最后 我们可以运行</c>
<c.magenta>你的所有初始化器</c>

00:18:09.556 --> 00:18:11.558 align:middle line:10%
<c.magenta>因此前面我展示这个工具</c>

00:18:11.625 --> 00:18:13.827 align:middle line:10%
<c.magenta>这时 我们准备执行main函数</c>

00:18:13.894 --> 00:18:15.395 align:middle line:10%
<c.magenta>这里进行了大量的工作</c>

00:18:15.929 --> 00:18:19.266 align:middle line:10%
<c.magenta>我们如何加快其速度</c>
<c.magenta>将这些步骤移出进程呢？</c>

00:18:19.333 --> 00:18:23.837 align:middle line:90%,end
<c.magenta>首先我确定安全敏感性组件</c>

00:18:24.104 --> 00:18:26.773 align:middle line:90%,end
<c.magenta>从我们的角度来看</c>
<c.magenta>最大的安全隐患之一</c>

00:18:26.840 --> 00:18:29.943 align:middle line:90%,end
<c.magenta>分析mach-o文件头</c>
<c.magenta>和查找依赖关系</c>

00:18:30.010 --> 00:18:34.014 align:middle line:90%,end
<c.magenta>因此人们可以使用</c>
<c.magenta>撰改过的mach-o文件头进行攻击</c>

00:18:34.081 --> 00:18:39.152 align:middle line:90%,end
<c.magenta>而且你 的程序可能使用</c>
<c.magenta>@rpaths 它们是搜索路径</c>

00:18:39.219 --> 00:18:43.190 align:middle line:90%,end
<c.magenta>通过撰改这些路径</c>
<c.magenta>或者将库插到适当的位置</c>

00:18:43.257 --> 00:18:45.292 align:middle line:90%,end
<c.magenta>可以破坏程序</c>

00:18:45.459 --> 00:18:49.062 align:middle line:90%,end
<c.magenta>因此我们在后台程序的进程之外</c>
<c.magenta>完成所有这些工作</c>

00:18:49.630 --> 00:18:53.734 align:middle line:90%,end
<c.magenta>然后我们确定大量占用资源的部分</c>
<c.magenta>也就是占用缓冲的部分</c>

00:18:53.800 --> 00:18:56.937 align:middle line:90%,end
<c.magenta>它们是符号查找</c>
<c.magenta>因为在给定的库中</c>

00:18:57.004 --> 00:19:00.774 align:middle line:10%
<c.magenta>除非进行软件更新</c>
<c.magenta>或者在磁盘上更改库</c>

00:18:57.004 --> 00:19:00.774 align:middle line:10%
<c.magenta>除非进行软件更新</c>
<c.magenta>或者在磁盘上更改库</c>

00:19:00.841 --> 00:19:03.810 align:middle line:10%
<c.magenta>符号将始终位于库中的相同偏移位置</c>

00:19:04.311 --> 00:19:08.015 align:middle line:10%
<c.magenta>我们已经确定这些内容</c>
<c.magenta>我们来看它们在dyld3中是怎样的</c>

00:19:11.552 --> 00:19:15.923 align:middle line:10%
<c.magenta>我们将这些部分移到上层</c>
<c.magenta>然后向磁盘写入收尾处理</c>

00:19:15.989 --> 00:19:20.861 align:middle line:10%
<c.magenta>前面我说过 启动收尾处理</c>
<c.magenta>是启动程序的重要环节</c>

00:19:22.429 --> 00:19:29.303 align:middle line:10%
<c.magenta>稍后可以在进程中使用它</c>
<c.magenta>dyld 3包含这三个部分</c>

00:19:30.170 --> 00:19:33.407 align:middle line:10%
<c.magenta>它是一个进程外</c>
<c.magenta>mach-o分析器和编译器</c>

00:19:34.141 --> 00:19:37.678 align:middle line:10%
<c.magenta>也是一个进程内引擎</c>
<c.magenta>执行启动收尾处理</c>

00:19:38.779 --> 00:19:41.381 align:middle line:10%
<c.magenta>也是一个启动收尾缓存服务</c>

00:19:43.150 --> 00:19:45.786 align:middle line:10%
<c.magenta>大多数程序启动会使用缓存</c>

00:19:45.853 --> 00:19:48.555 align:middle line:10%
<c.magenta>但始终不需要调用进程外</c>
<c.magenta>mach-o分析器或编译器</c>

00:19:50.524 --> 00:19:53.760 align:middle line:10%
<c.magenta>启动收尾比mach-o更简单</c>

00:19:54.261 --> 00:19:57.731 align:middle line:10%
<c.magenta>它们是内存映射文件</c>
<c.magenta>不需要用复杂的方法进行分析</c>

00:19:57.798 --> 00:20:00.801 align:middle line:10%
<c.magenta>我们可以简单地验证它们</c>
<c.magenta>其作用是为了提高速度</c>

00:19:57.798 --> 00:20:00.801 align:middle line:10%
<c.magenta>我们可以简单地验证它们</c>
<c.magenta>其作用是为了提高速度</c>

00:20:03.470 --> 00:20:06.340 align:middle line:90%,end
<c.magenta>让我们来详细看每个部分</c>

00:20:06.406 --> 00:20:10.077 align:middle line:90%,end
<c.magenta>因此 dyld 3</c>
<c.magenta>是进程外mach-o分析器</c>

00:20:10.844 --> 00:20:14.014 align:middle line:90%,end
<c.magenta>它解析所有搜索路径</c>

00:20:14.248 --> 00:20:16.316 align:middle line:90%,end
<c.magenta>所有rpaths</c>
<c.magenta>所有环境变量</c>

00:20:16.383 --> 00:20:17.851 align:middle line:90%,end
<c.magenta>它们会影响你的启动</c>

00:20:18.352 --> 00:20:20.687 align:middle line:90%,end
<c.magenta>然后分析mach-o二进制数据</c>

00:20:21.188 --> 00:20:23.223 align:middle line:90%,end
<c.magenta>执行所有符号查找</c>

00:20:25.192 --> 00:20:27.561 align:middle line:10%
<c.magenta>利用这些结果创建收尾处理</c>

00:20:28.495 --> 00:20:29.796 align:middle line:10%
<c.magenta>它是普通的后台程序</c>

00:20:29.863 --> 00:20:32.766 align:middle line:10%
<c.magenta>让我们提高测试基础架构的性能</c>

00:20:34.801 --> 00:20:37.671 align:middle line:90%,end
<c.magenta>dyld也是一个小型进程内引擎</c>

00:20:37.738 --> 00:20:40.007 align:middle line:90%,end
<c.magenta>这部分驻留在进程中</c>

00:20:40.073 --> 00:20:41.909 align:middle line:90%,end
<c.magenta>是你通常会看到的部分</c>

00:20:42.442 --> 00:20:46.213 align:middle line:90%,end
<c.magenta>它所做的事情是</c>
<c.magenta>检查启动收尾处理是否正确</c>

00:20:47.114 --> 00:20:50.651 align:middle line:90%,end
<c.magenta>然后映射到dylib之中</c>
<c.magenta>再跳转到main函数</c>

00:20:50.717 --> 00:20:52.519 align:middle line:90%,end
<c.magenta>你可能会注意到</c>

00:20:52.953 --> 00:20:56.590 align:middle line:10%
<c.magenta>dyld3不需要分析mach-o</c>
<c.magenta>文件头或执行符号查找</c>

00:20:56.657 --> 00:20:59.326 align:middle line:10%
<c.magenta>不需要做这些事情</c>
<c.magenta>就可以启动你的应用</c>

00:20:59.393 --> 00:21:01.895 align:middle line:10%
<c.magenta>由于这些是花费时间的部分</c>

00:20:59.393 --> 00:21:01.895 align:middle line:10%
<c.magenta>由于这些是花费时间的部分</c>

00:21:02.296 --> 00:21:05.132 align:middle line:10%
<c.magenta>因此可以极大提高程序启动速度</c>

00:21:06.600 --> 00:21:11.371 align:middle line:90%,end
<c.magenta>最后 dyld 3</c>
<c.magenta>还是一个启动收尾缓存服务</c>

00:21:11.438 --> 00:21:14.241 align:middle line:90%,end
<c.magenta>这是什么意思呢？</c>

00:21:14.308 --> 00:21:18.946 align:middle line:90%,end
<c.magenta>我们将系统程序收尾</c>
<c.magenta>直接加入到共享缓存</c>

00:21:19.012 --> 00:21:22.449 align:middle line:90%,end
<c.magenta>我们已使用这个工具在系统中</c>
<c.magenta>运行和分析每个mach-o文件</c>

00:21:23.083 --> 00:21:26.320 align:middle line:90%,end
<c.magenta>我们可以直接将它们</c>
<c.magenta>放入共享缓存 使它映射到缓存中</c>

00:21:26.386 --> 00:21:30.357 align:middle line:90%,end
<c.magenta>所有dylib都使用它来启动</c>
<c.magenta>我们甚至不需要打开其它文件</c>

00:21:31.825 --> 00:21:37.397 align:middle line:90%,end
<c.magenta>对于第三方程序</c>
<c.magenta>我们在程序安装或系统更新</c>

00:21:37.464 --> 00:21:41.668 align:middle line:90%,end
<c.magenta>生成你的收尾处理</c>
<c.magenta>因为那时系统库已经发生更改</c>

00:21:41.768 --> 00:21:47.407 align:middle line:90%,end
<c.magenta>默认情况下 将在iOS、tvOS</c>
<c.magenta>和watchOS上生成收尾处理</c>

00:21:47.474 --> 00:21:48.909 align:middle line:90%,end
<c.magenta>甚至在程序运行之前</c>

00:21:49.843 --> 00:21:54.248 align:middle line:90%,end
<c.magenta>在macOS上 由于可以</c>
<c.magenta>侧向加载程序 如果需要</c>

00:21:54.314 --> 00:21:59.486 align:middle line:90%,end
<c.magenta>进程内引擎可以在首次启动时</c>
<c.magenta>RPC到后台程序</c>

00:22:00.521 --> 00:22:03.991 align:middle line:90%,end
<c.magenta>在此之后 能够使用缓存的收尾处理</c>

00:22:05.459 --> 00:22:09.696 align:middle line:90%,end
<c.magenta>正如前面我说的那样</c>
<c.magenta>在我们的其它平台上并不需要这样做</c>

00:22:10.664 --> 00:22:13.467 align:middle line:90%,end
<c.magenta>我介绍了今年我们将会用于系统程序的</c>

00:22:13.534 --> 00:22:16.303 align:middle line:90%,end
<c.magenta>这个新动态链接器</c>
<c.magenta>以后你们也会使用它</c>

00:22:16.436 --> 00:22:19.439 align:middle line:90%,end
<c.magenta>我想谈一谈可能会存在的问题</c>

00:22:19.506 --> 00:22:21.975 align:middle line:90%,end
<c.magenta>让你现在就可以开始更新你的程序</c>

00:22:22.709 --> 00:22:23.877 align:middle line:90%,end
<c.magenta>为DYLD 3而准备</c>

00:22:23.944 --> 00:22:27.881 align:middle line:90%,end
<c.magenta>首先它完全兼容dyld 2.x</c>

00:22:27.948 --> 00:22:31.518 align:middle line:90%,end
<c.magenta>因此一些现有API</c>

00:22:31.585 --> 00:22:35.989 align:middle line:90%,end
<c.magenta>会导致你的程序运行变慢</c>
<c.magenta>或者会在dyld 3中使用回退模式</c>

00:22:36.056 --> 00:22:39.226 align:middle line:90%,end
<c.magenta>我们希望你们避免这个问题</c>
<c.magenta>稍后我们再讨论这个问题</c>

00:22:39.293 --> 00:22:41.962 align:middle line:90%,end
<c.magenta>另外 你所做的一些优化</c>

00:22:42.029 --> 00:22:46.099 align:middle line:90%,end
<c.magenta>现在可能已经不再需要</c>

00:22:46.166 --> 00:22:49.403 align:middle line:90%,end
<c.magenta>因此不需要在这方面</c>
<c.magenta>花费过多力气</c>

00:22:49.603 --> 00:22:50.704 align:middle line:90%,end
<c.magenta>我想要说的另一件事情是</c>

00:22:50.771 --> 00:22:52.940 align:middle line:90%,end
<c.magenta>我们将会使用更严格的链接语义</c>

00:22:53.006 --> 00:22:53.907 align:middle line:90%,end
<c.magenta>这是什么意思？</c>

00:22:53.974 --> 00:22:59.780 align:middle line:90%,end
<c.magenta>很多的语义现在还无法使用</c>

00:22:59.847 --> 00:23:04.518 align:middle line:90%,end
<c.magenta>现在甚至是错误的</c>
<c.magenta>在加入新动态链接器时</c>

00:22:59.847 --> 00:23:04.518 align:middle line:90%,end
<c.magenta>现在甚至是错误的</c>
<c.magenta>在加入新动态链接器时</c>

00:23:04.585 --> 00:23:06.920 align:middle line:90%,end
<c.magenta>我们发现很多这样的情况</c>

00:23:06.987 --> 00:23:09.256 align:middle line:90%,end
<c.magenta>目的是为了发现所有的边界例子</c>

00:23:09.590 --> 00:23:13.427 align:middle line:90%,end
<c.magenta>我们所做的事情</c>
<c.magenta>放入一个工作区以支持旧二进制数据</c>

00:23:14.127 --> 00:23:16.363 align:middle line:90%,end
<c.magenta>但是我们并不想更进一步</c>

00:23:16.430 --> 00:23:19.466 align:middle line:90%,end
<c.magenta>我们将会进行链接或后续检查</c>
<c.magenta>查看你使用哪些SDK</c>

00:23:19.533 --> 00:23:23.203 align:middle line:90%,end
<c.magenta>然后我们将禁用新二进制数据的工作区</c>

00:23:23.270 --> 00:23:27.341 align:middle line:90%,end
<c.magenta>让你能够解决这些问题</c>

00:23:28.408 --> 00:23:30.611 align:middle line:90%,end
<c.magenta>新二进制数据将会造成链接器问题</c>

00:23:31.945 --> 00:23:36.149 align:middle line:90%,end
<c.magenta>接下来我想讨论</c>
<c.magenta>数据段中的未对齐指针</c>

00:23:36.216 --> 00:23:37.384 align:middle line:90%,end
<c.magenta>我说的是什么意思呢？</c>

00:23:37.451 --> 00:23:40.187 align:middle line:90%,end
<c.magenta>假设你有一个全局性结构</c>

00:23:40.254 --> 00:23:43.824 align:middle line:90%,end
<c.magenta>指向一个函数</c>
<c.magenta>或另外一个全局性函数</c>

00:23:43.891 --> 00:23:46.927 align:middle line:90%,end
<c.magenta>在你的程序启动之前</c>
<c.magenta>我们必须修复这个指针</c>

00:23:46.994 --> 00:23:51.899 align:middle line:90%,end
<c.magenta>在我们的系统上</c>
<c.magenta>指针必须自然对齐以获得最佳性能</c>

00:23:53.166 --> 00:23:57.337 align:middle line:90%,end
<c.magenta>修复未对齐指针非常复杂</c>

00:23:57.571 --> 00:24:01.041 align:middle line:90%,end
<c.magenta>它们可能覆盖多个内存页</c>
<c.magenta>造成更多的内存页错误</c>

00:23:57.571 --> 00:24:01.041 align:middle line:90%,end
<c.magenta>它们可能覆盖多个内存页</c>
<c.magenta>造成更多的内存页错误</c>

00:24:01.108 --> 00:24:03.744 align:middle line:90%,end
<c.magenta>和其它问题</c>
<c.magenta>这可能会产生与多处理器相关的</c>

00:24:04.378 --> 00:24:06.847 align:middle line:90%,end
<c.magenta>细微问题</c>

00:24:07.915 --> 00:24:10.851 align:middle line:90%,end
<c.magenta>静态链接器已经忽略这个警告</c>

00:24:12.252 --> 00:24:14.588 align:middle line:10%
<c.magenta>ld警告 指针地址未对齐</c>

00:24:14.655 --> 00:24:17.157 align:middle line:10%
<c.magenta>这是你的数据段所在的位置</c>

00:24:18.325 --> 00:24:19.860 align:middle line:10%
<c.magenta>如果你消除所有警告</c>

00:24:19.927 --> 00:24:22.596 align:middle line:10%
<c.magenta>那么问题已经得到解决</c>

00:24:23.030 --> 00:24:26.266 align:middle line:10%
<c.magenta>本周我们提供的源代码</c>
<c.magenta>存在一些Swift键径问题</c>

00:24:26.333 --> 00:24:28.669 align:middle line:10%
<c.magenta>但是它们将会被修复</c>
<c.magenta>你可以忽略这些问题</c>

00:24:28.735 --> 00:24:31.138 align:middle line:10%
<c.magenta>但是你们可以修复这些问题</c>

00:24:31.905 --> 00:24:34.374 align:middle line:10%
<c.magenta>如果你们想知道如何做</c>

00:24:34.441 --> 00:24:36.276 align:middle line:10%
<c.magenta>我将会展示给你们看</c>

00:24:36.343 --> 00:24:38.812 align:middle line:10%
<c.magenta>这需要大量的工作</c>

00:24:38.879 --> 00:24:41.782 align:middle line:90%,end
<c.magenta>但是你不能在Swift中做这些事情</c>

00:24:42.316 --> 00:24:45.519 align:middle line:90%,end
<c.magenta>请看这里的代码</c>

00:24:46.553 --> 00:24:51.058 align:middle line:90%,end
<c.magenta>这里有一些强制进行对齐的属性</c>

00:24:51.124 --> 00:24:54.127 align:middle line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>编译器将会为你进行正确的对齐</c>

00:24:54.194 --> 00:24:56.263 align:middle line:90%,end
<c.magenta>但是有些时候</c>
<c.magenta>你可能需要特殊的对齐</c>

00:24:56.330 --> 00:24:57.564 align:middle line:90%,end
<c.magenta>在本例中</c>

00:24:57.631 --> 00:25:00.133 align:middle line:90%,end
<c.magenta>默认对齐规则要求进行对齐</c>

00:24:57.631 --> 00:25:00.133 align:middle line:90%,end
<c.magenta>默认对齐规则要求进行对齐</c>

00:25:00.200 --> 00:25:03.270 align:middle line:90%,end
<c.magenta>我使用了两种方法</c>
<c.magenta>但是结果很糟糕</c>

00:25:03.337 --> 00:25:04.872 align:middle line:90%,end
<c.magenta>你必须进行修复</c>

00:25:05.772 --> 00:25:09.576 align:middle line:90%,end
<c.magenta>然后我构建一个全局变量</c>

00:25:09.643 --> 00:25:12.246 align:middle line:90%,end
<c.magenta>这个变量在结构中设置指针</c>

00:25:12.312 --> 00:25:13.747 align:middle line:90%,end
<c.magenta>这将会强制动态链接器</c>

00:25:13.814 --> 00:25:16.650 align:middle line:90%,end
<c.magenta>在程序启动时修复指针</c>

00:25:17.217 --> 00:25:21.421 align:middle line:90%,end
<c.magenta>如果你看到这样的代码</c>
<c.magenta>可以清除所有对齐</c>

00:25:21.788 --> 00:25:24.892 align:middle line:90%,end
<c.magenta>重新调整结构</c>
<c.magenta>将指针放在前面</c>

00:25:24.958 --> 00:25:26.894 align:middle line:90%,end
<c.magenta>由于这更有利于对齐</c>

00:25:27.094 --> 00:25:29.396 align:middle line:90%,end
<c.magenta>关于C结构对齐</c>
<c.magenta>网上有很多的资料</c>

00:25:29.463 --> 00:25:31.265 align:middle line:90%,end
<c.magenta>你可以查看</c>

00:25:31.331 --> 00:25:34.368 align:middle line:90%,end
<c.magenta>但是希望你不必进行这样的处理</c>

00:25:34.434 --> 00:25:37.037 align:middle line:90%,end
<c.magenta>如果你编写Swift代码</c>
<c.magenta>你肯定不必这样做</c>

00:25:38.772 --> 00:25:42.342 align:middle line:90%,end
<c.magenta>接下来 我们讨论符号解析</c>

00:25:42.576 --> 00:25:43.844 align:middle line:90%,end
<c.magenta>这里的含义是什么？</c>

00:25:44.211 --> 00:25:47.481 align:middle line:90%,end
<c.magenta>dyld 2执行懒符号解析</c>

00:25:48.015 --> 00:25:51.218 align:middle line:90%,end
<c.magenta>dyld必须加载所有符号</c>

00:25:51.285 --> 00:25:53.687 align:middle line:90%,end
<c.magenta>这需要占用大量资源</c>
<c.magenta>因此应该使用缓存</c>

00:25:53.754 --> 00:26:00.294 align:middle line:90%,end
<c.magenta>直接运行现有程序</c>
<c.magenta>确实会占用很多资源</c>

00:25:53.754 --> 00:26:00.294 align:middle line:90%,end
<c.magenta>直接运行现有程序</c>
<c.magenta>确实会占用很多资源</c>

00:26:00.360 --> 00:26:01.562 align:middle line:90%,end
<c.magenta>将会花费很长时间</c>

00:26:01.762 --> 00:26:05.866 align:middle line:90%,end
<c.magenta>为此我们使用一种机制</c>
<c.magenta>名称为懒符号解析</c>

00:26:05.933 --> 00:26:10.671 align:middle line:90%,end
<c.magenta>默认情况下 库中的函数指针</c>
<c.magenta>比如printf</c>

00:26:10.737 --> 00:26:12.105 align:middle line:90%,end
<c.magenta>并不指向printf</c>

00:26:12.439 --> 00:26:17.044 align:middle line:90%,end
<c.magenta>默认情况下</c>
<c.magenta>它指向dyld中的一个函数</c>

00:26:17.110 --> 00:26:19.580 align:middle line:90%,end
<c.magenta>此函数返回一个</c>
<c.magenta>指向printf的函数指针</c>

00:26:20.113 --> 00:26:24.651 align:middle line:90%,end
<c.magenta>因此启动时</c>
<c.magenta>调用printf将会进入dyld</c>

00:26:24.718 --> 00:26:28.388 align:middle line:90%,end
<c.magenta>返回printf进行首次调用</c>

00:26:28.455 --> 00:26:30.958 align:middle line:90%,end
<c.magenta>然后第二次</c>
<c.magenta>你直接调用printf</c>

00:26:31.925 --> 00:26:35.495 align:middle line:90%,end
<c.magenta>由于我们已经缓存并且计算所有符号</c>

00:26:35.562 --> 00:26:37.264 align:middle line:90%,end
<c.magenta>因此在程序启动时不会产生额外开销</c>

00:26:37.331 --> 00:26:40.901 align:middle line:90%,end
<c.magenta>来绑定它们 我们将会这样做</c>

00:26:42.035 --> 00:26:46.974 align:middle line:90%,end
<c.magenta>当你这样做时</c>
<c.magenta>缺失符号的行为将会有所不同</c>

00:26:47.307 --> 00:26:51.078 align:middle line:90%,end
<c.magenta>在现有懒符号机制中</c>
<c.magenta>如果缺失一个符号</c>

00:26:51.144 --> 00:26:53.380 align:middle line:90%,end
<c.magenta>首次调用 将会正确启动</c>

00:26:53.447 --> 00:26:55.983 align:middle line:90%,end
<c.magenta>首次调用该符号</c>
<c.magenta>程序将会崩溃</c>

00:26:56.350 --> 00:26:59.253 align:middle line:90%,end
<c.magenta>如果使用勤符号 将会立即崩溃</c>

00:27:00.053 --> 00:27:00.988 align:middle line:90%,end
<c.magenta>为此…</c>

00:27:03.657 --> 00:27:05.993 align:middle line:10%
<c.magenta>我们提供一个兼容模式</c>

00:27:06.059 --> 00:27:07.828 align:middle line:10%
<c.magenta>我们要做的是</c>

00:27:08.529 --> 00:27:14.835 align:middle line:10%
<c.magenta>我们将导致自动崩溃的符号</c>
<c.magenta>放入dyld 3</c>

00:27:14.902 --> 00:27:17.971 align:middle line:10%
<c.magenta>如果不能找到你的符号</c>
<c.magenta>我们将会绑定该符号</c>

00:27:18.038 --> 00:27:19.673 align:middle line:10%
<c.magenta>因此首次调用将会崩溃</c>

00:27:20.207 --> 00:27:22.809 align:middle line:10%
<c.magenta>这是现在的SDK的工作模式</c>

00:27:22.876 --> 00:27:27.014 align:middle line:10%
<c.magenta>在未来的SDK中 我们将强制</c>
<c.magenta>预先进行所有符号解析</c>

00:27:27.080 --> 00:27:29.149 align:middle line:10%
<c.magenta>如果你缺失一个符号</c>
<c.magenta>将会崩溃</c>

00:27:29.216 --> 00:27:32.819 align:middle line:10%
<c.magenta>在开发过程中</c>
<c.magenta>你应该能够发现这些崩溃现象</c>

00:27:32.886 --> 00:27:35.355 align:middle line:10%
<c.magenta>而不是用户在程序运行时发现它们</c>

00:27:36.557 --> 00:27:38.325 align:middle line:10%
<c.magenta>现在你可以模拟这些行为</c>

00:27:38.392 --> 00:27:43.497 align:middle line:10%
<c.magenta>有一个特殊的链接器标记</c>
<c.magenta>即bind at load</c>

00:27:43.564 --> 00:27:47.401 align:middle line:10%
<c.magenta>如果你将它添加到你的调试程序</c>
<c.magenta>将会变得很慢</c>

00:27:47.467 --> 00:27:49.169 align:middle line:10%
<c.magenta>因此只应该放入调试版本</c>

00:27:49.236 --> 00:27:50.337 align:middle line:10%
<c.magenta>但将它添加到调试版本</c>

00:27:50.404 --> 00:27:53.373 align:middle line:10%
<c.magenta>你将会获得更可靠的行为</c>

00:27:53.440 --> 00:27:56.476 align:middle line:10%
<c.magenta>这让你能够好使用dyld 3</c>

00:27:57.845 --> 00:27:59.580 align:middle line:10%
<c.magenta>另外只应该在测试版本中使用</c>

00:28:00.647 --> 00:28:03.917 align:middle line:90%,end
<c.magenta>Dlopen、dlsym</c>
<c.magenta>和dladdr</c>

00:28:03.984 --> 00:28:07.454 align:middle line:90%,end
<c.magenta>去年我讲过</c>
<c.magenta>仅应该在十分必要时才使用它们</c>

00:28:07.521 --> 00:28:08.856 align:middle line:90%,end
<c.magenta>但我们理解你可能要使用它们</c>

00:28:08.922 --> 00:28:11.525 align:middle line:90%,end
<c.magenta>今年我也会讲这个问题</c>

00:28:11.892 --> 00:28:13.961 align:middle line:90%,end
<c.magenta>它们具有一些容易出错的语义</c>

00:28:14.728 --> 00:28:16.930 align:middle line:90%,end
<c.magenta>但是在一些情况下</c>
<c.magenta>仍然需要使用它们</c>

00:28:16.997 --> 00:28:19.867 align:middle line:90%,end
<c.magenta>特别是使用dlsym找到的符号</c>
<c.magenta>我们需要在运行时找到它们</c>

00:28:19.933 --> 00:28:21.235 align:middle line:90%,end
<c.magenta>我们不会提前知道这些符号</c>

00:28:21.301 --> 00:28:24.171 align:middle line:90%,end
<c.magenta>不能使用prefetching</c>
<c.magenta>和presearching</c>

00:28:24.571 --> 00:28:27.774 align:middle line:90%,end
<c.magenta>当你使用dlopen或dlsym</c>
<c.magenta>我们会读入以前未接触过的</c>

00:28:27.841 --> 00:28:31.078 align:middle line:90%,end
<c.magenta>所有符号表页</c>

00:28:31.411 --> 00:28:33.380 align:middle line:90%,end
<c.magenta>这会占用大量资源</c>

00:28:33.447 --> 00:28:38.785 align:middle line:90%,end
<c.magenta>此外 我们可能必须RPC到后台程序</c>

00:28:38.852 --> 00:28:41.021 align:middle line:90%,end
<c.magenta>这取决于其复杂程度</c>

00:28:41.088 --> 00:28:43.390 align:middle line:90%,end
<c.magenta>我们正在开发一些更好的替代方法</c>

00:28:43.857 --> 00:28:45.425 align:middle line:90%,end
<c.magenta>目前还没有完成</c>

00:28:45.492 --> 00:28:47.995 align:middle line:90%,end
<c.magenta>我们还需了解你们的用例</c>
<c.magenta>以确保我们开发出的方案</c>

00:28:48.061 --> 00:28:50.464 align:middle line:90%,end
<c.magenta>适合你们的需求</c>

00:28:50.531 --> 00:28:53.267 align:middle line:10%
<c.magenta>这些方案即将会发布</c>

00:28:53.333 --> 00:28:55.936 align:middle line:10%
<c.magenta>我们希望获得你们的反馈意见</c>

00:28:57.571 --> 00:28:59.873 align:middle line:90%,end
<c.magenta>接下来我想特别谈谈dlclose</c>

00:28:59.940 --> 00:29:02.509 align:middle line:90%,end
<c.magenta>dlclose是一个误用词</c>

00:28:59.940 --> 00:29:02.509 align:middle line:90%,end
<c.magenta>dlclose是一个误用词</c>

00:29:02.576 --> 00:29:04.111 align:middle line:90%,end
<c.magenta>它是一个Unix API</c>

00:29:04.178 --> 00:29:05.646 align:middle line:90%,end
<c.magenta>如果在我们的系统上编写它</c>

00:29:05.712 --> 00:29:08.615 align:middle line:90%,end
<c.magenta>我们会将它命名为dlrelease</c>

00:29:08.682 --> 00:29:11.251 align:middle line:90%,end
<c.magenta>因为它实际上并不关闭dylib</c>

00:29:11.318 --> 00:29:14.855 align:middle line:90%,end
<c.magenta>它减少refcount计数</c>
<c.magenta>如果refcount变为0</c>

00:29:14.922 --> 00:29:16.123 align:middle line:90%,end
<c.magenta>将会关闭它</c>

00:29:16.190 --> 00:29:17.658 align:middle line:90%,end
<c.magenta>它的重要性是什么？</c>

00:29:18.091 --> 00:29:20.460 align:middle line:90%,end
<c.magenta>它并不利于资源管理</c>

00:29:20.527 --> 00:29:24.398 align:middle line:90%,end
<c.magenta>如果你有一个库用于特定硬件</c>

00:29:24.464 --> 00:29:27.968 align:middle line:90%,end
<c.magenta>你不应该关闭硬件</c>
<c.magenta>来响应dlclose</c>

00:29:28.035 --> 00:29:31.805 align:middle line:90%,end
<c.magenta>因为程序中的其它代码</c>
<c.magenta>可能会在后台打开硬件</c>

00:29:31.872 --> 00:29:33.407 align:middle line:90%,end
<c.magenta>因此你的硬件不会关闭</c>

00:29:33.473 --> 00:29:35.943 align:middle line:90%,end
<c.magenta>应该使用显式资源管理</c>

00:29:36.944 --> 00:29:39.213 align:middle line:90%,end
<c.magenta>我们的平台上还有很多特性</c>

00:29:39.279 --> 00:29:41.648 align:middle line:90%,end
<c.magenta>访止dylib被卸载</c>

00:29:41.715 --> 00:29:45.118 align:middle line:90%,end
<c.magenta>我想介绍几个例子</c>
<c.magenta>因为你们可能会这样做</c>

00:29:45.853 --> 00:29:47.754 align:middle line:90%,end
<c.magenta>你的dylib中可以</c>
<c.magenta>有Objective-C类</c>

00:29:47.821 --> 00:29:50.257 align:middle line:90%,end
<c.magenta>这将导致dylib不可卸载</c>

00:29:50.991 --> 00:29:54.228 align:middle line:90%,end
<c.magenta>你可以具有Swift类</c>
<c.magenta>这也会导致dylib不可卸载</c>

00:29:54.828 --> 00:29:58.232 align:middle line:10%
<c.magenta>你可以具有C底层线程</c>
<c.magenta>或C++ 线程本地变量</c>

00:29:58.298 --> 00:30:00.868 align:middle line:10%
<c.magenta>这些都会导致dylib不可卸载</c>

00:29:58.298 --> 00:30:00.868 align:middle line:10%
<c.magenta>这些都会导致dylib不可卸载</c>

00:30:01.535 --> 00:30:06.573 align:middle line:10%
<c.magenta>因此在具有一些</c>
<c.magenta>现成Unix程序的macOS上</c>

00:30:06.640 --> 00:30:10.644 align:middle line:10%
<c.magenta>我们会保持这个特性</c>
<c.magenta>但是由于我们所有其它平台上的</c>

00:30:10.711 --> 00:30:12.946 align:middle line:10%
<c.magenta>几乎每个dylib都会这样做</c>

00:30:13.013 --> 00:30:17.084 align:middle line:10%
<c.magenta>因此并不能在这些平台上</c>
<c.magenta>有效地工作</c>

00:30:17.384 --> 00:30:20.988 align:middle line:10%
<c.magenta>因此我们可以将它视为</c>
<c.magenta>无操作指令</c>

00:30:21.054 --> 00:30:23.290 align:middle line:10%
<c.magenta>不会在任何平台上进行操作</c>

00:30:23.857 --> 00:30:28.695 align:middle line:10%
<c.magenta>如果这会导致问题</c>
<c.magenta>请告诉我们</c>

00:30:30.097 --> 00:30:33.600 align:middle line:10%
<c.magenta>最后我想讨论</c>
<c.magenta>dyld all image infos</c>

00:30:34.134 --> 00:30:37.337 align:middle line:90%,end
<c.magenta>这是进程中的</c>
<c.magenta>内在dylib的接口</c>

00:30:37.404 --> 00:30:39.306 align:middle line:90%,end
<c.magenta>它来自于最初的dyld 1</c>

00:30:40.641 --> 00:30:45.779 align:middle line:90%,end
<c.magenta>但是它只是内存中的一个结构</c>
<c.magenta>而不是API</c>

00:30:45.846 --> 00:30:48.148 align:middle line:90%,end
<c.magenta>当我们有5或10个dylib时</c>
<c.magenta>并没有问题</c>

00:30:48.415 --> 00:30:52.252 align:middle line:90%,end
<c.magenta>但是如果有300、400</c>
<c.magenta>500个dylib 其设计方式</c>

00:30:52.319 --> 00:30:54.821 align:middle line:90%,end
<c.magenta>将导致浪费大量内存</c>
<c.magenta>我们需要回收那些内存</c>

00:30:54.922 --> 00:30:57.624 align:middle line:90%,end
<c.magenta>我们需要高性能</c>
<c.magenta>而且节省内存</c>

00:30:58.192 --> 00:31:00.861 align:middle line:90%,end
<c.magenta>在未来的版本中</c>
<c.magenta>我们将会取消它</c>

00:30:58.192 --> 00:31:00.861 align:middle line:90%,end
<c.magenta>在未来的版本中</c>
<c.magenta>我们将会取消它</c>

00:31:01.161 --> 00:31:04.598 align:middle line:90%,end
<c.magenta>但 是会提供一个替代性API</c>

00:31:04.898 --> 00:31:08.502 align:middle line:90%,end
<c.magenta>因此 它很少被用到</c>
<c.magenta>如果你要使用它</c>

00:31:08.569 --> 00:31:10.370 align:middle line:90%,end
<c.magenta>我希望你知道为什么要使用它</c>

00:31:10.437 --> 00:31:13.941 align:middle line:90%,end
<c.magenta>如何使用它</c>
<c.magenta>确保我们设计的API适合你的用例</c>

00:31:14.208 --> 00:31:16.877 align:middle line:90%,end
<c.magenta>有很多功能已经不再适用</c>

00:31:16.944 --> 00:31:20.480 align:middle line:90%,end
<c.magenta>不符合你的预期</c>
<c.magenta>如果你不需要它们</c>

00:31:20.547 --> 00:31:23.016 align:middle line:90%,end
<c.magenta>可以忽略它们</c>
<c.magenta>我们希望获得这方面的信息</c>

00:31:23.550 --> 00:31:25.385 align:middle line:90%,end
<c.magenta>请让我们知道你将如何使用它</c>

00:31:25.853 --> 00:31:28.021 align:middle line:90%,end
<c.magenta>最后我们讨论最佳实践</c>

00:31:28.455 --> 00:31:33.527 align:middle line:90%,end
<c.magenta>首先应确保将bind at load</c>
<c.magenta>添加到LD FLAGS</c>

00:31:33.594 --> 00:31:35.395 align:middle line:90%,end
<c.magenta>应该仅在调试版本中这样做</c>

00:31:36.630 --> 00:31:40.033 align:middle line:90%,end
<c.magenta>应修复数据段中的</c>
<c.magenta>任何未对齐指针</c>

00:31:40.100 --> 00:31:42.836 align:middle line:90%,end
<c.magenta>然后还有这个警告信息</c>

00:31:42.903 --> 00:31:45.038 align:middle line:90%,end
<c.magenta>应该使用新Swift键径功能</c>

00:31:45.672 --> 00:31:47.975 align:middle line:90%,end
<c.magenta>消除所有警告错误</c>

00:31:48.041 --> 00:31:50.077 align:middle line:90%,end
<c.magenta>你也可以忽略</c>
<c.magenta>因为我们将会解决这个问题</c>

00:31:51.311 --> 00:31:54.281 align:middle line:90%,end
<c.magenta>当你调用dlclose时应该确保</c>

00:31:54.882 --> 00:31:56.283 align:middle line:90%,end
<c.magenta>不依赖于任何正运行的终止函数</c>

00:31:58.085 --> 00:32:03.924 align:middle line:90%,end
<c.magenta>我们想知道你们为何使用dlopen</c>
<c.magenta>dlsym、dladdr</c>

00:31:58.085 --> 00:32:03.924 align:middle line:90%,end
<c.magenta>我们想知道你们为何使用dlopen</c>
<c.magenta>dlsym、dladdr</c>

00:32:03.991 --> 00:32:07.694 align:middle line:90%,end
<c.magenta>和all image info结构</c>
<c.magenta>以确保我们的替代性API</c>

00:32:07.761 --> 00:32:09.863 align:middle line:90%,end
<c.magenta>能够满足你们的需求</c>

00:32:09.930 --> 00:32:12.499 align:middle line:90%,end
<c.magenta>如果它们是POSIX的一部分</c>
<c.magenta>将会被保留</c>

00:32:12.566 --> 00:32:14.768 align:middle line:90%,end
<c.magenta>这只会造成性能降低</c>
<c.magenta>对于all image infos</c>

00:32:14.835 --> 00:32:17.404 align:middle line:90%,end
<c.magenta>它将会被取消以节省内存</c>

00:32:18.572 --> 00:32:22.409 align:middle line:10%
<c.magenta>请使用DYLD USAGE标题</c>
<c.magenta>向我们报告漏洞</c>

00:32:22.476 --> 00:32:24.444 align:middle line:90%,end
<c.magenta>让我们能够</c>

00:32:24.511 --> 00:32:25.979 align:middle line:90%,end
<c.magenta>支持你们的所有用例</c>

00:32:26.313 --> 00:32:29.283 align:middle line:90%,end
<c.magenta>更多信息请访问此URL</c>

00:32:30.517 --> 00:32:34.488 align:middle line:90%,end
<c.magenta>去年我们举行了一个相关的演讲</c>
<c.magenta>名称为“缩短应用启动时间”</c>

00:32:34.555 --> 00:32:38.058 align:middle line:90%,end
<c.magenta>你可以观看这个演讲</c>

00:32:38.125 --> 00:32:40.861 align:middle line:90%,end
<c.magenta>复习传统动态链接的工作原理</c>

00:32:41.228 --> 00:32:43.997 align:middle line:90%,end
<c.magenta>这个演讲更详细</c>

00:32:44.064 --> 00:32:45.999 align:middle line:90%,end
<c.magenta>因为今天我们讲的都是新内容</c>

00:32:46.366 --> 00:32:50.037 align:middle line:90%,end
<c.magenta>谢谢大家参加本演讲</c>
<c.magenta>我希望你们度过一个很棒的WWDC</c>
