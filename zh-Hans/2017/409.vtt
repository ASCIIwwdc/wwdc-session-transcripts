WEBVTT

00:00:20.516 --> 00:00:24.546 A:middle
[掌声]

00:00:25.046 --> 00:00:27.656 A:middle
&gt;&gt; 下午好 欢迎参加

00:00:27.656 --> 00:00:28.826 A:middle
“测试新内容”会议

00:00:29.656 --> 00:00:31.196 A:middle
我叫 Wil 从事

00:00:31.236 --> 00:00:33.066 A:middle
Xcode 和 XCTest 方面的工作

00:00:34.166 --> 00:00:36.456 A:middle
那么 有哪些关于测试的新内容呢

00:00:37.206 --> 00:00:38.376 A:middle
答案是有很多

00:00:38.956 --> 00:00:40.316 A:middle
实际上 由于数量太多 我们

00:00:40.316 --> 00:00:41.176 A:middle
没时间在今天

00:00:41.176 --> 00:00:44.076 A:middle
逐一介绍

00:00:44.076 --> 00:00:44.466 A:middle
那就开始吧

00:00:45.656 --> 00:00:47.656 A:middle
首先 我们对 Xcode 8.3

00:00:47.656 --> 00:00:50.066 A:middle
和 Xcode 9 都进行了一系列的

00:00:50.396 --> 00:00:51.446 A:middle
改进

00:00:51.646 --> 00:00:53.566 A:middle
我想先把这些改进列举出来

00:00:53.566 --> 00:00:54.646 A:middle
然后再让你

00:00:54.646 --> 00:00:56.036 A:middle
在 XCTest 的参考文档中

00:00:56.036 --> 00:00:58.196 A:middle
详细了解 这份文档

00:00:58.196 --> 00:00:59.456 A:middle
刚进行了大幅度

00:00:59.456 --> 00:00:59.916 A:middle
更新

00:01:01.016 --> 00:01:03.016 A:middle
之后我们会了解一下

00:01:03.096 --> 00:01:05.006 A:middle
用于异步测试的新 API

00:01:05.626 --> 00:01:08.126 A:middle
多 App 测试

00:01:09.296 --> 00:01:10.626 A:middle
以及 UI 测试的

00:01:10.626 --> 00:01:12.016 A:middle
重要性能改进

00:01:12.806 --> 00:01:15.056 A:middle
最后 我们会以一组

00:01:15.056 --> 00:01:16.326 A:middle
叫做 Activity 附件

00:01:16.326 --> 00:01:18.416 A:middle
和屏幕快照的技术

00:01:18.706 --> 00:01:19.586 A:middle
来收尾

00:01:21.076 --> 00:01:22.426 A:middle
让我们来看一看

00:01:22.426 --> 00:01:23.226 A:middle
这些改进

00:01:24.516 --> 00:01:27.826 A:middle
对于 Xcode 8.3 我们在针对 Siri 意图的

00:01:27.826 --> 00:01:30.066 A:middle
UI 测试中添加了

00:01:30.066 --> 00:01:32.566 A:middle
新的 XCUISiriService

00:01:33.366 --> 00:01:35.576 A:middle
同时 我们在 macOS

00:01:35.576 --> 00:01:38.216 A:middle
的 Touch Bar 中增加了

00:01:38.216 --> 00:01:38.946 A:middle
UI 测试支持

00:01:39.576 --> 00:01:44.526 A:middle
在 Xcode 9 的 XCTest 中 我们

00:01:44.556 --> 00:01:46.146 A:middle
改良了 Swift 接口框架

00:01:46.146 --> 00:01:47.946 A:middle
作为 Swift 4 的一部分

00:01:48.106 --> 00:01:50.356 A:middle
我们还增加了一个

00:01:50.356 --> 00:01:52.766 A:middle
新的基于块的 Teardown API

00:01:53.066 --> 00:01:55.266 A:middle
能够在测试方法中构建

00:01:55.266 --> 00:01:57.526 A:middle
上下文特定的 Teardown

00:01:57.526 --> 00:01:59.526 A:middle
而无需测试类别的

00:01:59.866 --> 00:02:01.176 A:middle
额外状态或

00:01:59.866 --> 00:02:01.176 A:middle
额外状态或

00:02:01.176 --> 00:02:01.726 A:middle
属性

00:02:03.136 --> 00:02:05.406 A:middle
在 UI 测试中 我们为 macOS

00:02:05.406 --> 00:02:07.426 A:middle
的菜单项推出了

00:02:07.456 --> 00:02:08.455 A:middle
新的元素类别

00:02:09.526 --> 00:02:11.266 A:middle
此外 XCUI 元素中

00:02:11.386 --> 00:02:13.676 A:middle
有新的针对

00:02:13.676 --> 00:02:15.706 A:middle
XCUIElement 的 API

00:02:15.706 --> 00:02:17.336 A:middle
从而减少对 sleep() 函数的需求或

00:02:17.336 --> 00:02:19.576 A:middle
测试中其他人工延迟

00:02:20.516 --> 00:02:24.546 A:middle
[掌声]

00:02:25.046 --> 00:02:27.296 A:middle
现在 xcodebuild 命令支持直接通过

00:02:27.296 --> 00:02:29.426 A:middle
CoreSimulator 启动测试

00:02:29.426 --> 00:02:30.276 A:middle
这样你在命令行

00:02:30.276 --> 00:02:31.726 A:middle
运行测试时 就不再会

00:02:31.726 --> 00:02:33.096 A:middle
看到模拟器 App

00:02:33.096 --> 00:02:33.296 A:middle
启动了

00:02:33.536 --> 00:02:35.646 A:middle
同时 我们也很高兴地

00:02:35.646 --> 00:02:37.586 A:middle
宣布 xcodebuild 命令现在支持

00:02:37.846 --> 00:02:39.566 A:middle
并行设备测试了

00:02:40.516 --> 00:02:44.546 A:middle
[掌声]

00:02:45.046 --> 00:02:46.426 A:middle
这意味着如果你传递

00:02:46.426 --> 00:02:48.126 A:middle
多个目标区分符到

00:02:48.126 --> 00:02:50.236 A:middle
xcodebuild 命令那么就可以使用一个平台

00:02:50.686 --> 00:02:52.266 A:middle
一次性创建

00:02:52.266 --> 00:02:54.466 A:middle
所有区分符 然后

00:02:54.466 --> 00:02:55.876 A:middle
为这些目标同时

00:02:55.876 --> 00:02:56.826 A:middle
运行测试

00:02:57.286 --> 00:02:58.676 A:middle
这会极大地提高

00:02:59.036 --> 00:03:00.586 A:middle
许多持续集成情景

00:02:59.036 --> 00:03:00.586 A:middle
许多持续集成情景

00:03:00.586 --> 00:03:01.316 A:middle
的速度

00:03:02.476 --> 00:03:05.106 A:middle
在本地化方面

00:03:05.106 --> 00:03:06.916 A:middle
你可以在 Xcode 9 中设定运行测试

00:03:06.916 --> 00:03:08.436 A:middle
所使用的语言

00:03:08.436 --> 00:03:08.686 A:middle
和区域

00:03:09.366 --> 00:03:11.256 A:middle
这个 Scheme 选项可以让你

00:03:11.256 --> 00:03:12.836 A:middle
轻松测试你项目的

00:03:12.836 --> 00:03:14.936 A:middle
各种本地化内容

00:03:16.176 --> 00:03:18.346 A:middle
我还想花些时间来

00:03:18.466 --> 00:03:19.686 A:middle
请大家看一看

00:03:19.946 --> 00:03:21.586 A:middle
Xcode Server 的改进

00:03:22.536 --> 00:03:25.386 A:middle
首先 有了 Xcode 9

00:03:25.386 --> 00:03:27.326 A:middle
就不再需要 macOS 服务器了

00:03:28.266 --> 00:03:30.346 A:middle
你的团队可以直接在 Xcode 的

00:03:30.346 --> 00:03:31.756 A:middle
全新偏好面板

00:03:31.756 --> 00:03:33.596 A:middle
拨一下开关

00:03:33.596 --> 00:03:35.296 A:middle
即可开启

00:03:35.326 --> 00:03:35.766 A:middle
Xcode Server

00:03:37.376 --> 00:03:39.176 A:middle
Xcode Server 也具有

00:03:39.176 --> 00:03:40.756 A:middle
经过优化的配置工作流

00:03:41.356 --> 00:03:43.106 A:middle
并在 CoreSimulator 和

00:03:43.106 --> 00:03:44.756 A:middle
并行测试中采用了

00:03:45.186 --> 00:03:46.116 A:middle
改进后的 xcodebuild 命令

00:03:46.826 --> 00:03:47.966 A:middle
同时 每个 Scheme 的

00:03:47.966 --> 00:03:49.116 A:middle
本地化支持

00:03:49.356 --> 00:03:50.946 A:middle
会自动覆盖到

00:03:50.946 --> 00:03:51.536 A:middle
你所有的机器人

00:03:52.086 --> 00:03:55.546 A:middle
那么以上就是我们最令人激动的

00:03:55.546 --> 00:03:56.516 A:middle
全新改进

00:03:56.516 --> 00:03:57.246 A:middle
的快速概览

00:03:57.576 --> 00:03:59.656 A:middle
现在 让我们放慢速度

00:03:59.656 --> 00:04:01.066 A:middle
来仔细看看

00:03:59.656 --> 00:04:01.066 A:middle
来仔细看看

00:04:01.186 --> 00:04:02.196 A:middle
异步测试

00:04:03.566 --> 00:04:05.836 A:middle
异步测试能够

00:04:05.836 --> 00:04:07.206 A:middle
验证没有

00:04:07.206 --> 00:04:09.206 A:middle
立即完成

00:04:09.546 --> 00:04:11.346 A:middle
但随后却回调

00:04:11.566 --> 00:04:13.136 A:middle
闭包 委托方法或其他

00:04:13.136 --> 00:04:14.266 A:middle
延迟完成的代码

00:04:15.126 --> 00:04:17.016 A:middle
这其中含有的任务包括打开文档

00:04:17.016 --> 00:04:18.815 A:middle
后台线程完成

00:04:18.815 --> 00:04:19.926 A:middle
的工作

00:04:20.366 --> 00:04:21.435 A:middle
以及与其他进程

00:04:21.435 --> 00:04:23.876 A:middle
网络 Activity

00:04:24.026 --> 00:04:26.246 A:middle
动画及一系列

00:04:26.246 --> 00:04:27.316 A:middle
UI 测试情景进行的通信

00:04:27.896 --> 00:04:31.056 A:middle
几年前 我们

00:04:31.056 --> 00:04:33.596 A:middle
在 Xcode 6 的异步测试中

00:04:33.596 --> 00:04:34.036 A:middle
推出了API

00:04:34.826 --> 00:04:36.986 A:middle
这些 XCTestCase 上的方法

00:04:36.986 --> 00:04:38.636 A:middle
可以让你定义

00:04:38.676 --> 00:04:40.726 A:middle
调用时的条件或期望

00:04:40.726 --> 00:04:41.916 A:middle
然后再让测试等待

00:04:41.916 --> 00:04:43.186 A:middle
这些条件或期望

00:04:43.186 --> 00:04:43.726 A:middle
完成或满足

00:04:45.356 --> 00:04:47.756 A:middle
这里是一个简单的例子

00:04:48.236 --> 00:04:50.226 A:middle
这个测试代码的片段

00:04:50.226 --> 00:04:51.606 A:middle
打开了文档 等着它

00:04:51.606 --> 00:04:53.336 A:middle
完成并假设它已经

00:04:53.336 --> 00:04:53.866 A:middle
成功了

00:04:54.586 --> 00:04:55.966 A:middle
期望对象

00:04:55.966 --> 00:04:57.596 A:middle
在文档打开之前就已经

00:04:57.596 --> 00:04:57.966 A:middle
创建了

00:04:58.566 --> 00:05:00.436 A:middle
测试等待该文档在

00:04:58.566 --> 00:05:00.436 A:middle
测试等待该文档在

00:05:00.436 --> 00:05:02.406 A:middle
调用下打开并

00:05:02.496 --> 00:05:04.546 A:middle
在闭包中完成 这使得

00:05:04.546 --> 00:05:06.186 A:middle
测试继续运行

00:05:06.186 --> 00:05:08.106 A:middle
并在等待调用后

00:05:08.106 --> 00:05:08.686 A:middle
执行测试代码

00:05:09.396 --> 00:05:10.736 A:middle
但这是我们在 Xcode 6 里

00:05:10.736 --> 00:05:12.416 A:middle
的初始 API

00:05:13.436 --> 00:05:14.686 A:middle
它的性能已经足够好了

00:05:14.686 --> 00:05:15.576 A:middle
但仍存在一些限制

00:05:16.286 --> 00:05:18.106 A:middle
首先 等待 Timeout String

00:05:18.106 --> 00:05:19.216 A:middle
总是被当成

00:05:19.216 --> 00:05:19.796 A:middle
测试失败来对待

00:05:20.346 --> 00:05:22.486 A:middle
其次 等待需要

00:05:22.486 --> 00:05:24.426 A:middle
测试对象本身

00:05:24.426 --> 00:05:26.096 A:middle
这让提取任何类别的

00:05:26.096 --> 00:05:27.876 A:middle
测试库或

00:05:27.916 --> 00:05:28.156 A:middle
支持代码变得很困难

00:05:29.186 --> 00:05:31.076 A:middle
我们所称的嵌套等待

00:05:31.076 --> 00:05:32.606 A:middle
在这个 API 中也同样不可能

00:05:33.076 --> 00:05:34.256 A:middle
嵌套等待涉及到

00:05:34.256 --> 00:05:35.256 A:middle
需要在外部权重

00:05:35.256 --> 00:05:37.526 A:middle
上下文内等待的

00:05:37.916 --> 00:05:39.966 A:middle
额外期望群组

00:05:40.776 --> 00:05:42.866 A:middle
为了解决这些问题 我们

00:05:42.866 --> 00:05:44.166 A:middle
推出了新一类

00:05:44.446 --> 00:05:45.426 A:middle
XCTWaiter

00:05:46.236 --> 00:05:48.126 A:middle
这一类提取了过去

00:05:48.126 --> 00:05:49.076 A:middle
XCTestCase 中含有的

00:05:49.076 --> 00:05:51.296 A:middle
等待逻辑

00:05:51.296 --> 00:05:53.156 A:middle
并允许你明确声明

00:05:53.156 --> 00:05:54.556 A:middle
正在等待的

00:05:54.556 --> 00:05:54.716 A:middle
期望

00:05:55.586 --> 00:05:57.536 A:middle
超时和其他事件可

00:05:57.606 --> 00:05:59.056 A:middle
通过一个委托 API 进行处理

00:05:59.056 --> 00:06:01.066 A:middle
并且会从等待 API 中

00:05:59.056 --> 00:06:01.066 A:middle
并且会从等待 API 中

00:06:01.066 --> 00:06:03.466 A:middle
作为结果值返回

00:06:04.456 --> 00:06:06.316 A:middle
这就为构建异步测试

00:06:06.316 --> 00:06:07.596 A:middle
提供了

00:06:07.596 --> 00:06:09.096 A:middle
更多的

00:06:09.096 --> 00:06:09.656 A:middle
灵活性

00:06:10.206 --> 00:06:12.726 A:middle
如果我们回到上一个

00:06:12.726 --> 00:06:14.526 A:middle
例子 让我们来看一看

00:06:14.526 --> 00:06:16.006 A:middle
现在等待有哪些

00:06:16.006 --> 00:06:16.406 A:middle
选项

00:06:17.766 --> 00:06:20.416 A:middle
在初始代码中 我们注意到

00:06:20.416 --> 00:06:22.076 A:middle
并未提到任何期望

00:06:22.446 --> 00:06:23.146 A:middle
这是因为

00:06:23.146 --> 00:06:25.386 A:middle
执行是隐式的

00:06:25.386 --> 00:06:27.706 A:middle
它等待着测试对象

00:06:27.736 --> 00:06:29.336 A:middle
创建的所有活跃期望

00:06:30.026 --> 00:06:32.846 A:middle
而现在 只需要稍微改变

00:06:32.846 --> 00:06:34.916 A:middle
测试便可实现对文档期望的

00:06:34.916 --> 00:06:36.396 A:middle
显式等待

00:06:37.426 --> 00:06:38.976 A:middle
构建这个的一个

00:06:38.976 --> 00:06:41.356 A:middle
等价的方式是创建

00:06:41.356 --> 00:06:43.496 A:middle
XCTWaiter 的一个实例

00:06:43.496 --> 00:06:45.066 A:middle
并将测试作为托管

00:06:46.376 --> 00:06:49.636 A:middle
还有另一个选择是

00:06:49.696 --> 00:06:51.486 A:middle
采用 XCTWaiter 类方法

00:06:51.486 --> 00:06:53.176 A:middle
进行等待 然后再处理

00:06:53.176 --> 00:06:53.916 A:middle
结果值

00:06:54.916 --> 00:06:56.726 A:middle
这一灵活性使得

00:06:56.726 --> 00:06:58.826 A:middle
在 Helper 方法 嵌套上下文

00:06:58.826 --> 00:07:01.516 A:middle
或在从测试用例中

00:06:58.826 --> 00:07:01.516 A:middle
或在从测试用例中

00:07:01.516 --> 00:07:02.776 A:middle
完全解耦的

00:07:02.776 --> 00:07:04.366 A:middle
测试库代码上使用 XCTWaiter

00:07:04.366 --> 00:07:05.216 A:middle
变得十分容易

00:07:06.676 --> 00:07:09.046 A:middle
除此之外 为了创建

00:07:09.046 --> 00:07:10.996 A:middle
XCTWaiter 我们同时也扩充了

00:07:10.996 --> 00:07:13.076 A:middle
XCTTestExpectation 的 API

00:07:13.586 --> 00:07:15.876 A:middle
目前 初始化程序

00:07:15.876 --> 00:07:17.886 A:middle
已经在公开的 API 中提供

00:07:17.886 --> 00:07:19.656 A:middle
它也从 XCTestCase 中解耦

00:07:19.706 --> 00:07:20.676 A:middle
期望的创建

00:07:21.486 --> 00:07:22.696 A:middle
我们还引入了

00:07:22.696 --> 00:07:24.456 A:middle
期望实现数

00:07:24.546 --> 00:07:25.846 A:middle
属性 在这一属性下

00:07:25.846 --> 00:07:27.296 A:middle
期望象征着

00:07:27.296 --> 00:07:29.206 A:middle
多次出现的

00:07:29.206 --> 00:07:29.716 A:middle
条件

00:07:30.706 --> 00:07:31.976 A:middle
对于那些根本不该出现的

00:07:31.976 --> 00:07:33.956 A:middle
条件 有一个

00:07:33.956 --> 00:07:36.806 A:middle
针对期望的倒置 API

00:07:37.116 --> 00:07:38.346 A:middle
这会让 XCTWaiter

00:07:38.346 --> 00:07:39.826 A:middle
只在超时崩溃前

00:07:39.826 --> 00:07:41.726 A:middle
就达到期望的时候

00:07:41.726 --> 00:07:43.026 A:middle
才报告错误

00:07:43.876 --> 00:07:46.596 A:middle
最后 XCTWaiter 可以

00:07:46.596 --> 00:07:48.206 A:middle
加强期望实现

00:07:48.206 --> 00:07:50.356 A:middle
的命令 这是通过利用

00:07:50.356 --> 00:07:52.706 A:middle
等待 API 的可选旗标

00:07:53.506 --> 00:07:53.706 A:middle
实现的

00:07:54.236 --> 00:07:56.596 A:middle
以上 便是异步测试

00:07:56.596 --> 00:07:59.176 A:middle
XCTWaiter 和我们用于管理期望

00:07:59.636 --> 00:08:01.456 A:middle
的新 API 的进展情况

00:07:59.636 --> 00:08:01.456 A:middle
的新 API 的进展情况

00:08:01.456 --> 00:08:03.566 A:middle
以及一系列

00:08:03.566 --> 00:08:04.856 A:middle
XCTest 期望的

00:08:04.856 --> 00:08:05.546 A:middle
改进情况

00:08:06.376 --> 00:08:08.036 A:middle
这些类均与 XCTestCase

00:08:08.036 --> 00:08:10.486 A:middle
完全解耦并提供了

00:08:10.486 --> 00:08:11.996 A:middle
一个更便捷和

00:08:12.086 --> 00:08:13.766 A:middle
更强大的系统供大家使用

00:08:14.326 --> 00:08:17.596 A:middle
下面 我想介绍一下 UI

00:08:17.596 --> 00:08:19.876 A:middle
测试 尤其是

00:08:19.876 --> 00:08:21.006 A:middle
使用多应用程序的

00:08:21.006 --> 00:08:21.876 A:middle
UI 测试

00:08:23.216 --> 00:08:25.056 A:middle
几乎所有 UI 测试

00:08:25.136 --> 00:08:26.916 A:middle
的起始点都是

00:08:27.016 --> 00:08:28.976 A:middle
XCUIApplication 实例

00:08:29.476 --> 00:08:32.035 A:middle
这一类别可以让你启动并

00:08:32.155 --> 00:08:33.066 A:middle
中断正在测试的 App

00:08:33.066 --> 00:08:34.736 A:middle
同时创建

00:08:34.736 --> 00:08:36.726 A:middle
查询命令以找到用户

00:08:36.726 --> 00:08:38.306 A:middle
接口元素 而后再通过

00:08:38.306 --> 00:08:39.645 A:middle
发送综合事件

00:08:39.645 --> 00:08:40.616 A:middle
使其自动化

00:08:42.176 --> 00:08:43.986 A:middle
UI 测试有一个目标

00:08:43.986 --> 00:08:46.066 A:middle
应用程序概念 也就是指

00:08:46.066 --> 00:08:47.376 A:middle
主要测试的那个

00:08:47.376 --> 00:08:48.526 A:middle
应用程序

00:08:48.526 --> 00:08:50.356 A:middle
在测试的工程设置中

00:08:50.356 --> 00:08:52.356 A:middle
你可以指定相同工程中的

00:08:52.406 --> 00:08:54.426 A:middle
一个应用程序作为

00:08:54.466 --> 00:08:55.666 A:middle
目标应用程序

00:08:56.506 --> 00:08:57.786 A:middle
这就让你可以调用

00:08:57.786 --> 00:08:59.336 A:middle
XCUIApplication 的

00:08:59.336 --> 00:09:01.776 A:middle
默认初始化程序并创建

00:08:59.336 --> 00:09:01.776 A:middle
默认初始化程序并创建

00:09:01.776 --> 00:09:02.616 A:middle
带有安装

00:09:02.616 --> 00:09:04.406 A:middle
启动和与该应用程序

00:09:04.566 --> 00:09:06.336 A:middle
交互等信息的

00:09:06.386 --> 00:09:07.376 A:middle
实例

00:09:08.866 --> 00:09:09.916 A:middle
这一机制十分

00:09:09.916 --> 00:09:11.196 A:middle
便捷 但却不能用于

00:09:11.196 --> 00:09:12.366 A:middle
测试其他的

00:09:12.366 --> 00:09:13.206 A:middle
应用程序

00:09:13.966 --> 00:09:15.306 A:middle
其他被我们称作

00:09:15.306 --> 00:09:17.476 A:middle
多应用程序情景的例子包括

00:09:17.476 --> 00:09:19.466 A:middle
App 群组 即一个工程中

00:09:19.466 --> 00:09:20.516 A:middle
存在不止一个应用程序

00:09:20.516 --> 00:09:21.906 A:middle
并且它们

00:09:21.906 --> 00:09:23.406 A:middle
进行交互并

00:09:23.406 --> 00:09:24.226 A:middle
传递数据

00:09:25.196 --> 00:09:26.366 A:middle
另一个例子则是

00:09:26.366 --> 00:09:28.166 A:middle
设置 如果你需要将应用程序

00:09:28.246 --> 00:09:30.116 A:middle
的设置自动化并

00:09:30.116 --> 00:09:31.636 A:middle
改变不同测试情景的

00:09:31.636 --> 00:09:32.516 A:middle
偏好

00:09:33.246 --> 00:09:34.856 A:middle
还有另一个例子 即应用程序

00:09:34.856 --> 00:09:35.696 A:middle
扩展

00:09:36.646 --> 00:09:39.036 A:middle
全部应用程序的扩展所需要的不止是

00:09:39.036 --> 00:09:40.716 A:middle
单一的目标应用程序

00:09:42.016 --> 00:09:43.766 A:middle
为了解决这一问题 我们在

00:09:43.766 --> 00:09:46.166 A:middle
XCUIApplication 中添加了新的 API

00:09:47.076 --> 00:09:48.836 A:middle
首先 我们有初始化程序

00:09:49.206 --> 00:09:50.686 A:middle
让你可以通过 Bundle ID

00:09:50.866 --> 00:09:52.766 A:middle
来指定 App 或

00:09:52.766 --> 00:09:54.916 A:middle
也可以在 macOS 中

00:09:54.916 --> 00:09:58.056 A:middle
利用文件 URL 来指定

00:09:58.056 --> 00:09:59.766 A:middle
磁盘中 App 的位置

00:10:00.626 --> 00:10:02.686 A:middle
其次 我们添加了一个 active() 方法

00:10:02.686 --> 00:10:04.156 A:middle
将应用程序

00:10:04.186 --> 00:10:05.256 A:middle
从后台拉到前台

00:10:05.256 --> 00:10:06.696 A:middle
前提是应用程序已经

00:10:06.696 --> 00:10:08.296 A:middle
在运行 如果没有运行 则将启动

00:10:08.296 --> 00:10:09.526 A:middle
新的实例

00:10:10.336 --> 00:10:12.226 A:middle
但启动 API 将首先中断

00:10:12.226 --> 00:10:14.556 A:middle
任何之前的运行实例

00:10:14.556 --> 00:10:16.306 A:middle
因此你在开始

00:10:16.386 --> 00:10:17.586 A:middle
测试时总是需要

00:10:17.586 --> 00:10:18.166 A:middle
从头开始

00:10:18.616 --> 00:10:20.026 A:middle
active() 方法很有用 尤其是

00:10:20.026 --> 00:10:21.576 A:middle
在那些你

00:10:21.576 --> 00:10:22.786 A:middle
没兴趣清除

00:10:22.786 --> 00:10:24.276 A:middle
此前的状态 但实际上

00:10:24.276 --> 00:10:26.056 A:middle
又想在测试的更早期

00:10:26.056 --> 00:10:26.986 A:middle
重新开始的情景中

00:10:28.086 --> 00:10:29.706 A:middle
最后 还有一个新的状态

00:10:29.706 --> 00:10:30.996 A:middle
属性可以用来

00:10:30.996 --> 00:10:32.416 A:middle
监控正在测试的

00:10:32.416 --> 00:10:33.666 A:middle
应用程序中的变化

00:10:34.586 --> 00:10:36.686 A:middle
那么下面就举几个使用这些 API 的

00:10:36.686 --> 00:10:37.466 A:middle
例子

00:10:38.166 --> 00:10:39.416 A:middle
这一代码使用 Bundle ID

00:10:39.416 --> 00:10:41.736 A:middle
创建了两个

00:10:41.776 --> 00:10:42.546 A:middle
XCUIApplication 实例

00:10:42.896 --> 00:10:44.916 A:middle
这可能是一个 App 群组里的

00:10:44.916 --> 00:10:45.796 A:middle
一对应用程序

00:10:46.576 --> 00:10:48.856 A:middle
在启动和交互

00:10:49.016 --> 00:10:51.126 A:middle
readerApp 后 测试接下来

00:10:51.126 --> 00:10:53.186 A:middle
启动了 writerApp

00:10:53.186 --> 00:10:54.116 A:middle
最后 在进行了更多的

00:10:54.116 --> 00:10:55.886 A:middle
交互后 应用程序使用 Activate

00:10:55.886 --> 00:10:58.286 A:middle
API 将 readerApp 拉回

00:10:58.286 --> 00:11:00.596 A:middle
前台而没有

00:10:58.286 --> 00:11:00.596 A:middle
前台而没有

00:11:00.596 --> 00:11:01.596 A:middle
在一开始就将之中断

00:11:02.176 --> 00:11:04.636 A:middle
下面我们来看一看实际操作

00:11:04.866 --> 00:11:06.736 A:middle
有请 Warren Ma 为我们进行

00:11:06.736 --> 00:11:07.976 A:middle
多应用程序 UI 测试的 Demo

00:11:08.516 --> 00:11:15.556 A:middle
[掌声]

00:11:16.056 --> 00:11:16.756 A:middle
谢谢你 Wil

00:11:16.996 --> 00:11:19.016 A:middle
正如威尔刚才描述的那样

00:11:19.016 --> 00:11:21.126 A:middle
现在在 Xcode 9 中 你可以编写

00:11:21.126 --> 00:11:21.946 A:middle
涉及多个应用程序的

00:11:21.946 --> 00:11:23.536 A:middle
UI 测试 我很高兴

00:11:23.536 --> 00:11:24.776 A:middle
向大家展示如何

00:11:24.776 --> 00:11:26.206 A:middle
将新的 API 纳入

00:11:26.206 --> 00:11:27.026 A:middle
自己的测试集中

00:11:27.866 --> 00:11:32.676 A:middle
那么 下面我想先给大家

00:11:32.676 --> 00:11:33.816 A:middle
展示一下我这里的

00:11:33.816 --> 00:11:34.666 A:middle
两个关联 App

00:11:35.436 --> 00:11:36.206 A:middle
我现在是在一个开发设备上

00:11:36.206 --> 00:11:37.576 A:middle
运行这些程序

00:11:37.576 --> 00:11:38.886 A:middle
我在使用 QuickTime 来向大家展示

00:11:38.886 --> 00:11:39.306 A:middle
屏幕上的内容

00:11:40.136 --> 00:11:41.816 A:middle
第一个是一个信息

00:11:41.816 --> 00:11:43.636 A:middle
发送 App  叫做 writerApp

00:11:44.946 --> 00:11:47.086 A:middle
这里我们有一个用户名 我们还有

00:11:47.086 --> 00:11:48.556 A:middle
一个可以输入的文本视图

00:11:48.556 --> 00:11:51.826 A:middle
我们可以输入一条测试

00:11:51.826 --> 00:11:54.996 A:middle
信息 点击键盘上的

00:11:54.996 --> 00:11:56.846 A:middle
Return 键 并通过“Send（发送）”按钮

00:11:56.846 --> 00:11:58.196 A:middle
将信息发布在

00:11:58.196 --> 00:11:58.546 A:middle
服务器上

00:11:59.736 --> 00:12:00.776 A:middle
很好 现在信息已经发布了

00:11:59.736 --> 00:12:00.776 A:middle
很好 现在信息已经发布了

00:12:01.436 --> 00:12:02.176 A:middle
那么现在我们要怎样来浏览这些

00:12:02.176 --> 00:12:02.646 A:middle
信息呢

00:12:03.466 --> 00:12:04.996 A:middle
这就是我们第二个 App

00:12:04.996 --> 00:12:06.336 A:middle
readerApp 的任务了

00:12:08.316 --> 00:12:10.086 A:middle
这里列出了所有

00:12:10.086 --> 00:12:10.986 A:middle
发布在服务器上的

00:12:10.986 --> 00:12:12.876 A:middle
信息 而最上面的一条

00:12:12.876 --> 00:12:14.736 A:middle
是最新发布的信息

00:12:14.736 --> 00:12:16.426 A:middle
也就是我刚刚发布的信息 我们可以

00:12:16.426 --> 00:12:17.926 A:middle
点击信息进行详细地

00:12:17.926 --> 00:12:18.356 A:middle
浏览

00:12:18.356 --> 00:12:20.406 A:middle
然后我们可以返回

00:12:20.406 --> 00:12:21.626 A:middle
信息列表 通过

00:12:21.706 --> 00:12:23.426 A:middle
左上角的“All Messages（所有信息）”

00:12:23.426 --> 00:12:23.836 A:middle
按钮来返回

00:12:24.776 --> 00:12:26.736 A:middle
我们假设你想测试一下

00:12:26.736 --> 00:12:28.536 A:middle
这个过程 即在

00:12:28.536 --> 00:12:29.746 A:middle
writerApp 中输入文本信息

00:12:30.146 --> 00:12:31.776 A:middle
发布在服务器上 然后再

00:12:31.776 --> 00:12:33.096 A:middle
从第二个应用程序中去

00:12:33.096 --> 00:12:34.546 A:middle
验证信息是否出现在信息列表的

00:12:34.546 --> 00:12:35.516 A:middle
第一条

00:12:36.076 --> 00:12:37.796 A:middle
在 Xcode 9 之前 你不得不

00:12:37.796 --> 00:12:39.206 A:middle
为每个应用程序编写

00:12:39.306 --> 00:12:41.026 A:middle
不同的 UI 测试

00:12:41.026 --> 00:12:42.446 A:middle
那时甚至没有真正的方法

00:12:42.446 --> 00:12:43.996 A:middle
来验证这两者之间的

00:12:43.996 --> 00:12:44.756 A:middle
行为

00:12:45.406 --> 00:12:47.186 A:middle
但现在 有了 Xcode 9 的多 App 测试

00:12:47.416 --> 00:12:49.556 A:middle
Xcode 9 的多 UI 测试

00:12:49.556 --> 00:12:51.526 A:middle
我们可以轻松测试

00:12:51.526 --> 00:12:53.096 A:middle
多个应用程序间的

00:12:53.096 --> 00:12:54.086 A:middle
现实世界情景

00:12:54.496 --> 00:12:56.356 A:middle
为了给大家展示 我们来

00:12:56.356 --> 00:12:58.256 A:middle
快速编写一个 UI 测试

00:12:58.456 --> 00:12:59.626 A:middle
将我刚刚演示的这个工作流

00:12:59.626 --> 00:13:00.176 A:middle
自动化

00:12:59.626 --> 00:13:00.176 A:middle
自动化

00:13:01.266 --> 00:13:05.046 A:middle
好了 那我们测试的

00:13:05.046 --> 00:13:08.946 A:middle
第一步就是启动我们的阅读

00:13:08.946 --> 00:13:09.536 A:middle
应用程序

00:13:10.506 --> 00:13:12.366 A:middle
为了启动这一程序 我们需要

00:13:12.366 --> 00:13:13.636 A:middle
使用它的 Bundle ID

00:13:13.676 --> 00:13:14.496 A:middle
进行初始化

00:13:15.516 --> 00:13:16.786 A:middle
这一步之后 我们就可以继续并

00:13:16.786 --> 00:13:20.116 A:middle
重新启动程序

00:13:20.306 --> 00:13:21.346 A:middle
一旦我们启动了 readerApp

00:13:21.346 --> 00:13:23.066 A:middle
我们就可以继续

00:13:23.066 --> 00:13:24.236 A:middle
在信息列表中

00:13:24.236 --> 00:13:25.226 A:middle
验证第一条

00:13:25.226 --> 00:13:25.726 A:middle
信息

00:13:26.456 --> 00:13:28.466 A:middle
要做到这一点 我们得点击

00:13:28.796 --> 00:13:31.266 A:middle
列表的第一条信息 我们

00:13:31.266 --> 00:13:32.656 A:middle
可以验证里面的内容

00:13:32.656 --> 00:13:34.996 A:middle
是否是我们想看的那条 最后

00:13:34.996 --> 00:13:36.186 A:middle
我们可以返回

00:13:36.186 --> 00:13:37.466 A:middle
信息列表 利用左上角的

00:13:37.466 --> 00:13:38.126 A:middle
按钮

00:13:39.596 --> 00:13:40.646 A:middle
一旦我们验证了

00:13:40.646 --> 00:13:42.036 A:middle
列表中的第一条信息 我们

00:13:42.036 --> 00:13:43.196 A:middle
就可以输入文本信息并

00:13:43.196 --> 00:13:44.326 A:middle
通过 writerApp 来将信息发布在

00:13:44.326 --> 00:13:44.766 A:middle
服务器上

00:13:45.616 --> 00:13:48.566 A:middle
要做到这一点 第一步

00:13:48.566 --> 00:13:50.616 A:middle
还是使用 Bundle ID

00:13:50.616 --> 00:13:52.456 A:middle
将 writerApp 初始化

00:13:52.456 --> 00:13:54.066 A:middle
在这个例子里 ID 是

00:13:54.066 --> 00:13:55.596 A:middle
com.mycompany.Writer

00:13:56.506 --> 00:13:58.116 A:middle
完成这些之后

00:13:58.116 --> 00:13:58.816 A:middle
仅须调用 active() 方法就可以了

00:13:59.396 --> 00:14:01.186 A:middle
现在 activate() 也要等待

00:13:59.396 --> 00:14:01.186 A:middle
现在 activate() 也要等待

00:14:01.186 --> 00:14:02.496 A:middle
应用程序状态在

00:14:02.496 --> 00:14:03.556 A:middle
返回之前成为在前台

00:14:03.556 --> 00:14:05.136 A:middle
运行 因此我们不需要

00:14:05.136 --> 00:14:07.276 A:middle
对应用程序的状态进行任何

00:14:07.276 --> 00:14:08.186 A:middle
手动等待

00:14:08.776 --> 00:14:10.236 A:middle
一旦 active() 返回了 我们就

00:14:10.236 --> 00:14:11.446 A:middle
知道测试进展良好

00:14:11.446 --> 00:14:11.856 A:middle
可以继续了

00:14:12.296 --> 00:14:15.006 A:middle
一旦 writerApp 在前台

00:14:15.006 --> 00:14:16.706 A:middle
运行 我们就可以继续

00:14:16.706 --> 00:14:18.206 A:middle
编写文本信息并

00:14:18.206 --> 00:14:19.016 A:middle
发布在服务器上

00:14:19.746 --> 00:14:21.616 A:middle
要做到这一点 我们要使用

00:14:21.616 --> 00:14:23.736 A:middle
文本框输入我们的

00:14:23.736 --> 00:14:26.116 A:middle
文本信息 然后点击

00:14:26.116 --> 00:14:27.536 A:middle
键盘上的 Return 按钮

00:14:28.356 --> 00:14:29.606 A:middle
再点击“Send（发送）”

00:14:29.606 --> 00:14:30.936 A:middle
将信息发布到服务器

00:14:32.826 --> 00:14:33.956 A:middle
现在 我们得确保信息

00:14:33.956 --> 00:14:35.236 A:middle
出现在了 readerApp

00:14:35.446 --> 00:14:36.416 A:middle
信息列表

00:14:36.416 --> 00:14:36.836 A:middle
的首条

00:14:38.006 --> 00:14:39.176 A:middle
之前 我们使用了 active() 在

00:14:39.176 --> 00:14:40.046 A:middle
两个应用程序间

00:14:40.046 --> 00:14:41.586 A:middle
转换 而在这个例子中

00:14:41.846 --> 00:14:43.086 A:middle
让我们使用 iOS 系统

00:14:43.086 --> 00:14:44.466 A:middle
创建的返回应用程序按钮

00:14:44.946 --> 00:14:45.946 A:middle
这个按钮位于屏幕的

00:14:45.946 --> 00:14:46.636 A:middle
左上角

00:14:47.246 --> 00:14:50.276 A:middle
要做到这一点 我们需要

00:14:50.276 --> 00:14:52.726 A:middle
点击返回应用程序按钮

00:14:52.966 --> 00:14:54.356 A:middle
但在这个例子中 由于

00:14:54.356 --> 00:14:55.826 A:middle
我们未使用 active()  因此我们

00:14:55.826 --> 00:14:58.036 A:middle
需要手动等待

00:14:58.106 --> 00:14:59.716 A:middle
应用程序状态在

00:14:59.716 --> 00:15:00.756 A:middle
前台运行 之后

00:14:59.716 --> 00:15:00.756 A:middle
前台运行 之后

00:15:00.756 --> 00:15:01.936 A:middle
才能继续测试

00:15:02.726 --> 00:15:04.016 A:middle
而要做到这一点 我们得利用

00:15:04.016 --> 00:15:05.146 A:middle
基于新 Predicate 的

00:15:05.146 --> 00:15:06.146 A:middle
期望 API

00:15:08.596 --> 00:15:10.866 A:middle
所以 我们得确保

00:15:10.866 --> 00:15:13.716 A:middle
readerApp 的状态在返回

00:15:13.716 --> 00:15:14.766 A:middle
之前在前台

00:15:14.766 --> 00:15:15.286 A:middle
运行

00:15:16.636 --> 00:15:18.066 A:middle
我们在定义了我们的

00:15:18.066 --> 00:15:20.186 A:middle
期望之后 可以继续下一步并

00:15:20.186 --> 00:15:21.416 A:middle
等待这个期望

00:15:21.416 --> 00:15:23.246 A:middle
在超时 10 秒后变为 True

00:15:23.246 --> 00:15:24.346 A:middle
这个时间应该是

00:15:24.346 --> 00:15:24.986 A:middle
绰绰有余的

00:15:25.456 --> 00:15:28.076 A:middle
一旦 readerApp 开始在前台

00:15:28.076 --> 00:15:30.056 A:middle
运行 我们就可以

00:15:30.056 --> 00:15:31.536 A:middle
继续完成

00:15:31.536 --> 00:15:33.386 A:middle
测试的最后一步 也就是

00:15:33.386 --> 00:15:34.666 A:middle
验证信息是否出现

00:15:34.666 --> 00:15:36.226 A:middle
在列表的顶部

00:15:36.686 --> 00:15:37.886 A:middle
同我们刚刚所做的类似

00:15:38.396 --> 00:15:39.236 A:middle
我们可以点击列表的

00:15:39.236 --> 00:15:41.246 A:middle
第一条信息 然后验证

00:15:41.246 --> 00:15:42.596 A:middle
信息的内容是否是

00:15:42.596 --> 00:15:45.056 A:middle
我们刚刚发布的内容

00:15:45.146 --> 00:15:46.306 A:middle
然后再返回到

00:15:46.306 --> 00:15:46.766 A:middle
信息列表

00:15:47.786 --> 00:15:48.966 A:middle
下面就让我们实际操作一下

00:15:48.966 --> 00:15:50.336 A:middle
看看真实的测试

00:15:50.886 --> 00:15:52.426 A:middle
首先 我要点击

00:15:52.426 --> 00:15:53.756 A:middle
左栏的

00:15:53.756 --> 00:15:53.976 A:middle
测试方块

00:15:59.046 --> 00:16:00.716 A:middle
这样 当一般情况下你运行

00:15:59.046 --> 00:16:00.716 A:middle
这样 当一般情况下你运行

00:16:00.716 --> 00:16:02.186 A:middle
UI 测试时 就需要安装

00:16:02.186 --> 00:16:03.366 A:middle
所谓的 UI 测试运行器并且

00:16:03.716 --> 00:16:04.986 A:middle
那是除了安装应用

00:16:04.986 --> 00:16:07.046 A:middle
程序外 UI 测试运行的

00:16:07.046 --> 00:16:07.646 A:middle
测试流程

00:16:07.866 --> 00:16:09.386 A:middle
所以 只需要一点点时间

00:16:09.386 --> 00:16:10.166 A:middle
就可以启动了

00:16:10.636 --> 00:16:13.256 A:middle
一旦启动后 测试

00:16:13.256 --> 00:16:14.466 A:middle
便可继续运行

00:16:16.836 --> 00:16:18.306 A:middle
因此同之前一样 测试的

00:16:18.306 --> 00:16:19.656 A:middle
第一步是启动

00:16:19.656 --> 00:16:21.806 A:middle
readerApp 并验证

00:16:21.806 --> 00:16:23.466 A:middle
信息列表中的第一条信息

00:16:25.296 --> 00:16:27.516 A:middle
接下来 我们使用 active() 方法来打开

00:16:27.516 --> 00:16:29.196 A:middle
writerApp 输入我们的测试

00:16:29.196 --> 00:16:30.936 A:middle
信息并发布在

00:16:30.936 --> 00:16:31.346 A:middle
服务器上

00:16:32.156 --> 00:16:33.106 A:middle
然后我们使用返回 App

00:16:33.106 --> 00:16:34.206 A:middle
按钮来转回到

00:16:34.206 --> 00:16:35.296 A:middle
readerApp 并验证

00:16:35.296 --> 00:16:36.426 A:middle
信息是否出现在了列表的

00:16:36.426 --> 00:16:36.846 A:middle
顶部

00:16:37.456 --> 00:16:39.336 A:middle
所以说 利用

00:16:39.336 --> 00:16:40.706 A:middle
这款适用于 Xcode 9 的

00:16:40.946 --> 00:16:43.006 A:middle
超棒多 UI 测试 API

00:16:43.006 --> 00:16:44.736 A:middle
来测试多个应用程序是

00:16:44.736 --> 00:16:45.356 A:middle
多么容易啊

00:16:45.626 --> 00:16:46.496 A:middle
那么下面我就把舞台

00:16:46.496 --> 00:16:46.936 A:middle
交回给 Wil

00:16:47.516 --> 00:16:51.546 A:middle
[掌声]

00:16:52.046 --> 00:16:53.546 A:middle
谢谢你 Warren 真是非常

00:16:53.546 --> 00:16:54.136 A:middle
精彩的介绍

00:16:54.746 --> 00:16:56.696 A:middle
仅仅是通过添加一些新功能

00:16:56.696 --> 00:16:57.796 A:middle
UI 测试这一领域

00:16:57.796 --> 00:16:59.186 A:middle
的可能性便得到了

00:16:59.316 --> 00:16:59.806 A:middle
极大的拓宽

00:17:00.606 --> 00:17:01.856 A:middle
这个新的初始化程序可以

00:17:01.856 --> 00:17:03.626 A:middle
测试任何应用程序 而且

00:17:03.626 --> 00:17:04.955 A:middle
Activate API 意味着你可以在

00:17:04.955 --> 00:17:06.086 A:middle
多应用程序间

00:17:06.086 --> 00:17:08.236 A:middle
切换而无需重启这些程序

00:17:08.236 --> 00:17:10.596 A:middle
实现多应用程序 UI 测试

00:17:11.616 --> 00:17:14.126 A:middle
下面 让我们转换一下思路

00:17:14.126 --> 00:17:16.226 A:middle
来谈谈 UI 测试的性能

00:17:17.656 --> 00:17:20.096 A:middle
UI 测试的核心是

00:17:20.096 --> 00:17:21.756 A:middle
你的测试希望

00:17:21.756 --> 00:17:23.195 A:middle
交互的用户接口

00:17:24.036 --> 00:17:24.296 A:middle
元素

00:17:24.296 --> 00:17:26.236 A:middle
这些元素包括按钮 标签

00:17:26.236 --> 00:17:27.346 A:middle
表格视图等等

00:17:27.935 --> 00:17:30.026 A:middle
UI 测试通过创建查询来

00:17:30.026 --> 00:17:32.206 A:middle
描述各元素是如何被发现的

00:17:32.816 --> 00:17:35.466 A:middle
例如 这个按钮元素

00:17:35.466 --> 00:17:37.126 A:middle
有一个

00:17:38.076 --> 00:17:40.696 A:middle
app.navigationBars.buttons 查询

00:17:40.696 --> 00:17:41.896 A:middle
注释为“Done”

00:17:42.646 --> 00:17:43.886 A:middle
这就意味着该元素具有

00:17:43.936 --> 00:17:46.506 A:middle
一个按钮的属性 标签

00:17:46.506 --> 00:17:48.556 A:middle
或 Done 的标题并且

00:17:48.556 --> 00:17:50.406 A:middle
能在导航栏中找到

00:17:51.206 --> 00:17:53.116 A:middle
那么这些查询是怎么工作的呢

00:17:54.486 --> 00:17:56.476 A:middle
查询利用辅助功能数据

00:17:56.946 --> 00:17:58.996 A:middle
这与 VoiceOver 技术

00:17:59.116 --> 00:18:00.876 A:middle
是一个意思

00:17:59.116 --> 00:18:00.876 A:middle
是一个意思

00:18:01.376 --> 00:18:02.446 A:middle
将之作为应用程序的

00:18:02.446 --> 00:18:03.916 A:middle
可被搜索的架构

00:18:05.136 --> 00:18:07.126 A:middle
为了评估一个查询 测试

00:18:07.166 --> 00:18:09.616 A:middle
进程请求对现有数据

00:18:09.616 --> 00:18:11.556 A:middle
进行所谓的快照

00:18:12.186 --> 00:18:14.086 A:middle
这一请求是从测试进程

00:18:14.086 --> 00:18:15.816 A:middle
发送至应用程序的

00:18:15.816 --> 00:18:17.466 A:middle
所以这些是单独的进程

00:18:17.466 --> 00:18:18.706 A:middle
在这里我们使用了

00:18:18.706 --> 00:18:19.536 A:middle
进程间通讯

00:18:20.676 --> 00:18:21.806 A:middle
这一请求是从测试进程

00:18:21.806 --> 00:18:23.356 A:middle
发送至应用程序

00:18:23.356 --> 00:18:25.036 A:middle
现在 应用程序捕捉了

00:18:25.036 --> 00:18:28.176 A:middle
快照数据 进行了排序并

00:18:28.176 --> 00:18:30.326 A:middle
将之传回到测试

00:18:30.376 --> 00:18:30.986 A:middle
进程

00:18:31.596 --> 00:18:32.856 A:middle
一旦测试进程

00:18:32.856 --> 00:18:34.606 A:middle
解包了数据 便能

00:18:34.606 --> 00:18:36.546 A:middle
通过在快照中搜寻

00:18:36.546 --> 00:18:37.576 A:middle
来评估查询

00:18:38.356 --> 00:18:40.386 A:middle
快照是有用的 正是因为

00:18:40.606 --> 00:18:42.526 A:middle
它的运行方式 快照可以

00:18:42.526 --> 00:18:45.026 A:middle
在一瞬间捕捉

00:18:45.026 --> 00:18:46.956 A:middle
UI 状态的原子表征

00:18:46.956 --> 00:18:48.906 A:middle
但这也带来了一些

00:18:48.906 --> 00:18:50.306 A:middle
性能方面的挑战

00:18:50.866 --> 00:18:52.616 A:middle
如果我们考虑性能的

00:18:52.616 --> 00:18:54.656 A:middle
两个坐标轴 一个是时间

00:18:54.656 --> 00:18:55.806 A:middle
另一个是内存

00:18:56.556 --> 00:18:58.496 A:middle
快照在这两方面都

00:18:58.496 --> 00:18:59.896 A:middle
存在潜在问题

00:19:00.836 --> 00:19:02.546 A:middle
对于有数个 UI 元素

00:19:02.546 --> 00:19:04.626 A:middle
的应用程序来说 快照花费的时间过长

00:19:04.626 --> 00:19:06.086 A:middle
例如 对于有着数千行和

00:19:06.086 --> 00:19:07.866 A:middle
大型集合视图的

00:19:07.866 --> 00:19:09.436 A:middle
表格而言 这会

00:19:09.436 --> 00:19:11.436 A:middle
导致超时并会

00:19:11.436 --> 00:19:12.586 A:middle
引发测试失败

00:19:13.396 --> 00:19:15.426 A:middle
如果快照数据太大

00:19:15.426 --> 00:19:16.986 A:middle
那么这对系统的内存压力

00:19:16.986 --> 00:19:19.386 A:middle
可能会导致

00:19:19.386 --> 00:19:20.836 A:middle
进程遭到中断

00:19:21.656 --> 00:19:23.056 A:middle
这些挑战让我们想到了下面这个

00:19:23.056 --> 00:19:25.076 A:middle
问题 即我们如何才能

00:19:25.076 --> 00:19:26.976 A:middle
改善快照的性能

00:19:27.466 --> 00:19:28.896 A:middle
我们总结出来了好几种

00:19:28.896 --> 00:19:29.426 A:middle
方式

00:19:30.636 --> 00:19:32.416 A:middle
首先 我们想要

00:19:32.416 --> 00:19:33.536 A:middle
降低传输各进程

00:19:33.606 --> 00:19:35.116 A:middle
间所有数据

00:19:35.116 --> 00:19:36.336 A:middle
的开销

00:19:37.006 --> 00:19:38.406 A:middle
要做到这一点 我们执行了

00:19:38.406 --> 00:19:40.156 A:middle
所谓的远程查询

00:19:40.836 --> 00:19:42.656 A:middle
有了远程查询

00:19:42.656 --> 00:19:44.596 A:middle
测试进程便不用请求

00:19:44.596 --> 00:19:47.076 A:middle
快照 实际上只用传送

00:19:47.106 --> 00:19:48.286 A:middle
查询本身 而这

00:19:48.286 --> 00:19:49.586 A:middle
只涉及非常少量的数据

00:19:50.466 --> 00:19:51.616 A:middle
应用程序仍会创建

00:19:51.616 --> 00:19:53.306 A:middle
快照 但将

00:19:53.306 --> 00:19:55.226 A:middle
不再把它传送到任意地方

00:19:55.256 --> 00:19:56.996 A:middle
而只是评估进程中的

00:19:56.996 --> 00:19:58.076 A:middle
查询

00:19:58.576 --> 00:20:00.146 A:middle
在最后 应用程序仅

00:19:58.576 --> 00:20:00.146 A:middle
在最后 应用程序仅

00:20:00.146 --> 00:20:02.376 A:middle
向测试进程传回结果

00:20:02.376 --> 00:20:04.966 A:middle
同样只涉及少量的数据

00:20:06.106 --> 00:20:09.516 A:middle
那么这一切的性能怎么样呢

00:20:09.516 --> 00:20:11.876 A:middle
经发现 远程查询的性能

00:20:11.876 --> 00:20:13.736 A:middle
可以将速度提高

00:20:13.736 --> 00:20:16.116 A:middle
20% 并将内存泄漏

00:20:16.116 --> 00:20:18.426 A:middle
减少 30%

00:20:18.936 --> 00:20:20.416 A:middle
这当然是一个良好的开端 但

00:20:20.526 --> 00:20:22.146 A:middle
还远未达到我们脑海中

00:20:22.146 --> 00:20:23.106 A:middle
想要实现的目标

00:20:23.106 --> 00:20:25.286 A:middle
那么这时候 就该我们的第二个

00:20:25.626 --> 00:20:27.116 A:middle
优化项出场了 即

00:20:27.116 --> 00:20:27.846 A:middle
查询分析

00:20:28.286 --> 00:20:30.306 A:middle
我们的目标是减少

00:20:30.306 --> 00:20:32.226 A:middle
快照自身的大小

00:20:32.226 --> 00:20:34.256 A:middle
收集更少的数据

00:20:35.256 --> 00:20:37.406 A:middle
快照使用了一套固定的

00:20:37.406 --> 00:20:39.366 A:middle
辅助功能属性 但我们认为通过

00:20:39.366 --> 00:20:41.046 A:middle
分析你的查询

00:20:41.046 --> 00:20:43.746 A:middle
我们可以识别出

00:20:43.746 --> 00:20:45.446 A:middle
一套数量最少的属性

00:20:45.736 --> 00:20:47.286 A:middle
几乎只占到了许多普通

00:20:47.286 --> 00:20:49.446 A:middle
查询的一半 这极大

00:20:49.446 --> 00:20:50.796 A:middle
减少了收集的

00:20:50.796 --> 00:20:51.366 A:middle
数据量

00:20:52.126 --> 00:20:53.746 A:middle
对于一些具体的元素

00:20:53.746 --> 00:20:56.106 A:middle
在后续的断言中可能会

00:20:56.146 --> 00:20:57.806 A:middle
需要的其他属性仍可以

00:20:57.806 --> 00:21:00.266 A:middle
按需获取 但

00:20:57.806 --> 00:21:00.266 A:middle
按需获取 但

00:21:00.266 --> 00:21:02.686 A:middle
快照自身将更加

00:21:02.686 --> 00:21:03.386 A:middle
轻便

00:21:04.686 --> 00:21:06.066 A:middle
所以结果发现 查询分析

00:21:06.066 --> 00:21:07.616 A:middle
是性能更加卓越的

00:21:07.676 --> 00:21:10.846 A:middle
优化项 在普通情况下

00:21:11.126 --> 00:21:12.836 A:middle
速度可提升 50% 并且

00:21:12.836 --> 00:21:15.896 A:middle
内存阈值可降低

00:21:15.986 --> 00:21:16.346 A:middle
约 35%

00:21:17.136 --> 00:21:18.996 A:middle
所以情况看起来相当

00:21:18.996 --> 00:21:21.016 A:middle
不错 但我们想后退一步

00:21:21.016 --> 00:21:22.936 A:middle
看一看如果

00:21:22.936 --> 00:21:24.876 A:middle
跳出固化的思维 我们是否能够

00:21:25.016 --> 00:21:26.726 A:middle
重新构建一个系统 并

00:21:26.726 --> 00:21:28.226 A:middle
带来事物的变革

00:21:28.536 --> 00:21:30.866 A:middle
这就让我们有了

00:21:30.866 --> 00:21:33.336 A:middle
将快照完全清除的这个想法

00:21:33.776 --> 00:21:35.196 A:middle
那么我们该怎么来做呢

00:21:35.246 --> 00:21:37.366 A:middle
快照给我们提供了

00:21:37.706 --> 00:21:39.916 A:middle
UI 状态的

00:21:39.916 --> 00:21:40.646 A:middle
原子表征

00:21:41.216 --> 00:21:42.956 A:middle
经发现 这得益于

00:21:42.956 --> 00:21:45.036 A:middle
远程查询基础结构 我们

00:21:45.036 --> 00:21:46.966 A:middle
现在具备这一功能仅仅是因为我们

00:21:46.966 --> 00:21:48.796 A:middle
已经在应用程序的

00:21:48.796 --> 00:21:49.786 A:middle
进程中运行

00:21:49.786 --> 00:21:50.456 A:middle
查询

00:21:51.146 --> 00:21:53.636 A:middle
所以 传统查询

00:21:53.636 --> 00:21:55.686 A:middle
通过仔细检查快照

00:21:55.686 --> 00:21:58.556 A:middle
数据来运转 我们

00:21:58.716 --> 00:22:01.006 A:middle
推出了一个叫做 First Match

00:21:58.716 --> 00:22:01.006 A:middle
推出了一个叫做 First Match

00:22:01.006 --> 00:22:03.526 A:middle
的 API 这个 API 会在你找到了

00:22:03.526 --> 00:22:05.536 A:middle
第一个匹配项之后立刻

00:22:05.536 --> 00:22:07.526 A:middle
停止查询 因为

00:22:07.526 --> 00:22:09.186 A:middle
很多时候 检索所有的

00:22:09.276 --> 00:22:10.886 A:middle
数据以便找到

00:22:10.886 --> 00:22:12.876 A:middle
所有可能的匹配项费时过多

00:22:12.876 --> 00:22:14.656 A:middle
你可以以一个能够

00:22:14.756 --> 00:22:17.236 A:middle
使不同元素独特的精准度来

00:22:17.236 --> 00:22:17.686 A:middle
加以区分

00:22:18.656 --> 00:22:21.796 A:middle
所以 First Match 导致查询

00:22:21.796 --> 00:22:23.836 A:middle
提早返回 并且你可以把它添加到

00:22:23.836 --> 00:22:25.196 A:middle
已有的任意

00:22:26.516 --> 00:22:26.606 A:middle
查询中

00:22:27.186 --> 00:22:28.336 A:middle
下面举个例子来看看 First Match

00:22:28.336 --> 00:22:29.786 A:middle
是怎么添加进我们刚刚

00:22:29.786 --> 00:22:30.646 A:middle
看过的这个查询中

00:22:31.456 --> 00:22:33.586 A:middle
如果设想一下我们

00:22:33.636 --> 00:22:35.536 A:middle
正在测试的应用程序是一个带有

00:22:35.536 --> 00:22:37.566 A:middle
导航栏 表格视图

00:22:37.936 --> 00:22:39.606 A:middle
和数千行表格

00:22:39.606 --> 00:22:41.846 A:middle
的程序 传统的

00:22:41.846 --> 00:22:43.496 A:middle
评估会依依检查

00:22:43.556 --> 00:22:45.166 A:middle
表格中的每一行

00:22:45.166 --> 00:22:46.046 A:middle
尽管我们要找的

00:22:46.046 --> 00:22:47.696 A:middle
是导航栏的一个按钮

00:22:48.166 --> 00:22:50.316 A:middle
但 First Match 则让我们可以

00:22:50.316 --> 00:22:51.846 A:middle
在找到那个按钮后立刻

00:22:51.846 --> 00:22:53.566 A:middle
停止 并且我们不需要检查

00:22:53.566 --> 00:22:56.576 A:middle
表格中的每一行

00:22:56.746 --> 00:22:59.156 A:middle
那么 First Match 的性能如何呢

00:22:59.916 --> 00:23:01.056 A:middle
可以说 First Match

00:22:59.916 --> 00:23:01.056 A:middle
可以说 First Match

00:23:01.056 --> 00:23:02.316 A:middle
改变了游戏规则

00:23:02.796 --> 00:23:04.306 A:middle
对于很多查询 几乎达到了

00:23:04.306 --> 00:23:06.306 A:middle
一个数量级的提速

00:23:06.776 --> 00:23:08.686 A:middle
并且还完全清除了内存

00:23:08.826 --> 00:23:09.606 A:middle
泄漏

00:23:10.516 --> 00:23:16.546 A:middle
[掌声]

00:23:17.046 --> 00:23:18.696 A:middle
如今 First Match 的

00:23:18.696 --> 00:23:20.396 A:middle
性能提升非常显著

00:23:20.396 --> 00:23:22.226 A:middle
但重要的是要注意到

00:23:22.226 --> 00:23:23.466 A:middle
传统查询之间的

00:23:23.466 --> 00:23:25.516 A:middle
差异 且不要

00:23:25.516 --> 00:23:27.766 A:middle
不加考虑便

00:23:27.766 --> 00:23:29.206 A:middle
将 First Match 胡乱运用于

00:23:29.206 --> 00:23:30.166 A:middle
整个代码中

00:23:30.906 --> 00:23:32.486 A:middle
传统的查询评估

00:23:32.486 --> 00:23:34.586 A:middle
会找出所有的匹配项 这能够

00:23:34.636 --> 00:23:37.106 A:middle
帮助检测模糊查询 因为

00:23:37.106 --> 00:23:38.526 A:middle
如果你尝试与存在

00:23:38.526 --> 00:23:39.716 A:middle
多个匹配项的元素进行交互

00:23:39.716 --> 00:23:41.376 A:middle
那么就会造成

00:23:41.376 --> 00:23:41.946 A:middle
失败

00:23:42.836 --> 00:23:44.286 A:middle
First Match 消除了

00:23:44.316 --> 00:23:45.756 A:middle
这一层保护 你的测试只会获得

00:23:45.756 --> 00:23:46.586 A:middle
第一个匹配项

00:23:47.146 --> 00:23:48.416 A:middle
如果应用程序的 UI

00:23:48.416 --> 00:23:50.916 A:middle
发生了变化 那么那个查询

00:23:50.916 --> 00:23:53.576 A:middle
实际上便不够

00:23:53.726 --> 00:23:55.646 A:middle
精确 结果则是

00:23:55.646 --> 00:23:58.506 A:middle
非唯一结果

00:23:58.676 --> 00:23:59.866 A:middle
First Match 便不会提供保护

00:23:59.866 --> 00:24:01.546 A:middle
并且结果会让人意外

00:23:59.866 --> 00:24:01.546 A:middle
并且结果会让人意外

00:24:02.096 --> 00:24:03.936 A:middle
下面让我们来看看一些

00:24:04.046 --> 00:24:05.526 A:middle
示例查询并思考

00:24:05.526 --> 00:24:07.086 A:middle
它们是否适合进行

00:24:07.086 --> 00:24:07.946 A:middle
First Match

00:24:08.726 --> 00:24:13.486 A:middle
app.buttons.firstMatch 不是一个

00:24:13.486 --> 00:24:15.626 A:middle
好的选择 这就像

00:24:15.626 --> 00:24:16.846 A:middle
走进一家杂货店 但只和老板说

00:24:16.846 --> 00:24:18.296 A:middle
“我想要买点吃的”

00:24:18.976 --> 00:24:20.726 A:middle
你可能买到冷冻的鸡肉

00:24:20.726 --> 00:24:21.816 A:middle
或是一块泡泡糖

00:24:21.816 --> 00:24:23.316 A:middle
又或是香蕉 这都说不准

00:24:23.816 --> 00:24:26.136 A:middle
所以 这一类的查询

00:24:26.136 --> 00:24:27.886 A:middle
对于 First Match 来说

00:24:27.886 --> 00:24:28.306 A:middle
还不够精准

00:24:29.306 --> 00:24:30.756 A:middle
现在则稍好了一点

00:24:30.756 --> 00:24:32.536 A:middle
因为我们在里面

00:24:32.536 --> 00:24:34.236 A:middle
添加了一个标识

00:24:34.236 --> 00:24:34.536 A:middle
字符串

00:24:34.536 --> 00:24:36.456 A:middle
有这么多的应用程序 可能

00:24:36.456 --> 00:24:37.536 A:middle
对目前来说是足够的

00:24:38.026 --> 00:24:40.936 A:middle
但如果再向进一步并且

00:24:41.146 --> 00:24:43.156 A:middle
为查询增加更多的精准度和

00:24:43.156 --> 00:24:44.526 A:middle
更多的细节

00:24:44.756 --> 00:24:46.156 A:middle
就使其能够更适合进行

00:24:46.156 --> 00:24:48.116 A:middle
First Match 并更有可能

00:24:48.116 --> 00:24:50.146 A:middle
在任何地方都保持稳定

00:24:50.146 --> 00:24:51.576 A:middle
同时仍然具备 First Match

00:24:51.576 --> 00:24:53.176 A:middle
带有的性能

00:24:53.176 --> 00:24:53.866 A:middle
提升

00:24:55.966 --> 00:24:58.266 A:middle
因此在谈论所有这些

00:24:58.266 --> 00:25:00.336 A:middle
优化项时 我们需要给大家

00:24:58.266 --> 00:25:00.336 A:middle
优化项时 我们需要给大家

00:25:00.336 --> 00:25:01.666 A:middle
稍微介绍一下

00:25:01.906 --> 00:25:03.876 A:middle
基于块的 NSPredicates 以及

00:25:03.876 --> 00:25:05.116 A:middle
如何在查询中进行使用

00:25:07.136 --> 00:25:09.306 A:middle
不幸的是 它们同这些

00:25:09.306 --> 00:25:11.956 A:middle
优化项并不兼容 它们

00:25:11.956 --> 00:25:13.476 A:middle
有效禁止了这些优化项

00:25:13.526 --> 00:25:15.136 A:middle
这是因为 首先

00:25:15.136 --> 00:25:16.866 A:middle
块无法被序列化

00:25:17.096 --> 00:25:18.356 A:middle
也无法在进程间传递

00:25:18.356 --> 00:25:21.136 A:middle
这就意味着不存在

00:25:21.136 --> 00:25:23.256 A:middle
远程查询和 First Match

00:25:23.966 --> 00:25:25.196 A:middle
另一个问题是我们

00:25:25.196 --> 00:25:26.856 A:middle
无法内省 我们无法在运行时

00:25:26.856 --> 00:25:29.386 A:middle
查看块并知道

00:25:29.516 --> 00:25:30.896 A:middle
查询实际需要的是

00:25:30.896 --> 00:25:31.896 A:middle
哪些属性

00:25:32.326 --> 00:25:33.576 A:middle
这就意味着当你正在使用

00:25:33.576 --> 00:25:34.856 A:middle
基于块的 NSPredicates 时

00:25:34.856 --> 00:25:36.396 A:middle
快照性能的

00:25:36.396 --> 00:25:38.116 A:middle
提升也同样

00:25:38.116 --> 00:25:39.656 A:middle
与此无关

00:25:40.346 --> 00:25:42.256 A:middle
幸运的是

00:25:42.256 --> 00:25:44.096 A:middle
测试查询中使用基于

00:25:44.096 --> 00:25:45.796 A:middle
块的 NSPredicates 相对

00:25:45.796 --> 00:25:48.066 A:middle
少见 并且几乎始终可以

00:25:48.066 --> 00:25:50.366 A:middle
与格式字符串或

00:25:50.366 --> 00:25:52.106 A:middle
基于 NSExpression 的

00:25:52.106 --> 00:25:52.616 A:middle
Predicate 互换

00:25:53.496 --> 00:25:55.366 A:middle
现在 如果你发现自己遇到

00:25:55.366 --> 00:25:57.566 A:middle
某个情况 即的确需要基于块的

00:25:57.566 --> 00:25:58.946 A:middle
Predicate 我的意思是

00:25:58.946 --> 00:25:59.936 A:middle
它们仍然得到支持 它们

00:25:59.936 --> 00:26:02.216 A:middle
仍在运转或甚至

00:25:59.936 --> 00:26:02.216 A:middle
仍在运转或甚至

00:26:02.216 --> 00:26:03.796 A:middle
使用其中之一会

00:26:03.796 --> 00:26:05.226 A:middle
更加便捷

00:26:05.386 --> 00:26:06.916 A:middle
我们想要去了解它 我们

00:26:06.916 --> 00:26:08.496 A:middle
希望你可以提交 Bug 这样

00:26:08.496 --> 00:26:11.196 A:middle
我们就可以给你提供一个

00:26:11.246 --> 00:26:13.466 A:middle
处理相同任务的 API 但其处理方式

00:26:13.466 --> 00:26:15.086 A:middle
能够与查询优化项

00:26:15.086 --> 00:26:15.826 A:middle
兼容

00:26:15.826 --> 00:26:17.216 A:middle
所以 如果你觉得

00:26:17.706 --> 00:26:19.596 A:middle
手头有某些情况需要基于块的

00:26:19.596 --> 00:26:20.826 A:middle
Predicate 我们很想听听你的

00:26:20.826 --> 00:26:21.196 A:middle
看法

00:26:21.706 --> 00:26:24.926 A:middle
以上就是我们对

00:26:24.926 --> 00:26:26.086 A:middle
UI 测试性能提升的

00:26:26.086 --> 00:26:26.756 A:middle
探讨

00:26:27.336 --> 00:26:29.236 A:middle
Xcode 9 中的查询整体来说

00:26:29.236 --> 00:26:30.766 A:middle
应该更快

00:26:31.266 --> 00:26:32.546 A:middle
其中一些提升项 例如

00:26:32.546 --> 00:26:35.126 A:middle
远程查询和 First Match

00:26:35.126 --> 00:26:36.996 A:middle
同样需要最新版的操作系统 比如

00:26:36.996 --> 00:26:39.326 A:middle
最新的 macOS iOS 以及 Apple TVOS

00:26:40.006 --> 00:26:42.686 A:middle
但查询分析的益处即使是在

00:26:42.686 --> 00:26:45.126 A:middle
旧版的操作系统上也可以体现

00:26:45.546 --> 00:26:47.076 A:middle
所以 在 UI 测试性能上 我们

00:26:47.076 --> 00:26:49.036 A:middle
做了很多工作并且我们

00:26:49.036 --> 00:26:50.416 A:middle
也期待看到大家的

00:26:50.416 --> 00:26:51.386 A:middle
测试运行地更加迅速

00:26:51.896 --> 00:26:54.146 A:middle
所以最后 我想再跟大家

00:26:54.146 --> 00:26:55.646 A:middle
分享一个新的

00:26:55.646 --> 00:26:57.816 A:middle
技术群组叫作

00:26:57.816 --> 00:26:59.636 A:middle
Activity 附件与屏幕快照

00:27:00.596 --> 00:27:01.976 A:middle
下面 让我们先来看看 Activity

00:27:01.976 --> 00:27:03.716 A:middle
这是创建附加结构

00:27:03.716 --> 00:27:05.666 A:middle
运行时间更长的 UI

00:27:05.666 --> 00:27:07.666 A:middle
以及集成测试的一种

00:27:07.666 --> 00:27:08.246 A:middle
新方式

00:27:09.166 --> 00:27:11.216 A:middle
有一个单独的 API 可以

00:27:11.216 --> 00:27:12.706 A:middle
把代码片段进行归类

00:27:12.736 --> 00:27:14.006 A:middle
通过把它们包装在

00:27:14.006 --> 00:27:16.156 A:middle
闭包中再传到新一类

00:27:16.456 --> 00:27:17.646 A:middle
XCTContext 中来实现

00:27:18.186 --> 00:27:20.696 A:middle
这是从 Warren 之前做的 Demo

00:27:20.696 --> 00:27:22.636 A:middle
中得出的一个测试报告

00:27:22.636 --> 00:27:23.636 A:middle
我们还没来得及

00:27:23.636 --> 00:27:25.196 A:middle
去查看 但现在报告已经在

00:27:25.196 --> 00:27:25.646 A:middle
这里

00:27:25.776 --> 00:27:26.996 A:middle
这个测试并没有

00:27:26.996 --> 00:27:28.966 A:middle
很长或很复杂

00:27:28.966 --> 00:27:30.416 A:middle
但大家可以看到这里面

00:27:30.416 --> 00:27:31.176 A:middle
却有很多的内容

00:27:31.766 --> 00:27:33.396 A:middle
那么来思考一下这 4 个行动

00:27:34.156 --> 00:27:35.376 A:middle
让我们来看看引导这些

00:27:35.376 --> 00:27:35.916 A:middle
行动的代码

00:27:37.146 --> 00:27:38.666 A:middle
我们用一个查询来找到

00:27:38.666 --> 00:27:40.406 A:middle
视图 我们可以点击视图 输入

00:27:40.406 --> 00:27:42.196 A:middle
一些文本并同几个按钮

00:27:42.196 --> 00:27:42.636 A:middle
进行交互

00:27:43.316 --> 00:27:44.966 A:middle
这个代码做了一个很好的逻辑

00:27:44.966 --> 00:27:46.176 A:middle
归类 这个代码

00:27:46.176 --> 00:27:48.276 A:middle
汇集了所有优质咖啡厅

00:27:48.276 --> 00:27:49.616 A:middle
的信息

00:27:50.076 --> 00:27:52.286 A:middle
所以 为这个代码创建一个

00:27:52.286 --> 00:27:54.166 A:middle
XCTActivity 是非常简单的

00:27:54.556 --> 00:27:56.486 A:middle
我们只需把它包装进这个运行

00:27:56.486 --> 00:27:58.456 A:middle
Activity 调用中 给它一个漂亮的

00:27:58.456 --> 00:27:59.776 A:middle
标签 因为这是我们将在测试

00:27:59.776 --> 00:28:01.236 A:middle
报告中所呈现的

00:27:59.776 --> 00:28:01.236 A:middle
报告中所呈现的

00:28:01.816 --> 00:28:02.846 A:middle
下面 让我们来看看这给

00:28:02.846 --> 00:28:03.956 A:middle
测试报告带来了什么改变

00:28:04.776 --> 00:28:06.436 A:middle
我们原本的 4 个 Activity

00:28:06.436 --> 00:28:08.576 A:middle
现在被包在了这个

00:28:08.576 --> 00:28:10.756 A:middle
由咖啡信息组成的新的

00:28:10.756 --> 00:28:12.596 A:middle
Activity 中 你仍然可以进行扩展

00:28:12.596 --> 00:28:14.406 A:middle
来看看初始的且更加

00:28:14.406 --> 00:28:16.236 A:middle
具体的细节

00:28:16.776 --> 00:28:18.566 A:middle
但对于高层的首次

00:28:18.566 --> 00:28:19.586 A:middle
通过 当你在浏览自己的

00:28:19.586 --> 00:28:21.366 A:middle
测试报告时 信息会变得

00:28:21.366 --> 00:28:22.946 A:middle
更加简洁并在语义上

00:28:22.946 --> 00:28:23.616 A:middle
更有意义

00:28:24.556 --> 00:28:26.056 A:middle
在整个更长的运行测试

00:28:26.056 --> 00:28:27.466 A:middle
和在 Helper 方法中使用

00:28:27.466 --> 00:28:29.266 A:middle
这个 API 会让

00:28:29.316 --> 00:28:31.086 A:middle
测试报告更易于

00:28:31.086 --> 00:28:31.586 A:middle
浏览

00:28:32.466 --> 00:28:35.206 A:middle
除了 Activity 我们还

00:28:35.206 --> 00:28:36.686 A:middle
推出了叫做附件的

00:28:36.866 --> 00:28:37.646 A:middle
新功能

00:28:38.086 --> 00:28:39.796 A:middle
长久以来 我们一直希望

00:28:39.796 --> 00:28:41.596 A:middle
能将更丰富的数据添加到

00:28:41.596 --> 00:28:43.096 A:middle
测试报告中

00:28:43.686 --> 00:28:45.526 A:middle
最主要的动机是为了

00:28:45.526 --> 00:28:46.876 A:middle
更容易地

00:28:46.876 --> 00:28:49.046 A:middle
用额外的日志或其他数据来

00:28:49.046 --> 00:28:50.506 A:middle
分流失败 这些数据能够在

00:28:50.626 --> 00:28:51.966 A:middle
失败时提供关于条件的

00:28:51.966 --> 00:28:52.436 A:middle
更多情况

00:28:53.496 --> 00:28:54.856 A:middle
除此之外 这也可以被用来

00:28:54.856 --> 00:28:55.876 A:middle
支持各类

00:28:55.936 --> 00:28:57.556 A:middle
后处理工作流程

00:28:57.596 --> 00:28:59.156 A:middle
比如同你的设计师

00:28:59.156 --> 00:29:00.346 A:middle
坐在一起来看看

00:28:59.156 --> 00:29:00.346 A:middle
坐在一起来看看

00:29:00.346 --> 00:29:01.406 A:middle
屏幕快照

00:29:02.846 --> 00:29:04.576 A:middle
现在附件可以通过便利 API

00:29:04.576 --> 00:29:07.096 A:middle
支持任何类型的二进制

00:29:07.096 --> 00:29:09.226 A:middle
数据 包括字符串

00:29:09.226 --> 00:29:11.996 A:middle
属性列表 可编码的对象 文件

00:29:12.586 --> 00:29:13.536 A:middle
和图像

00:29:14.106 --> 00:29:15.856 A:middle
这些类别中任何一类都可以

00:29:16.096 --> 00:29:17.806 A:middle
轻松添加到测试中 所以当

00:29:17.806 --> 00:29:18.866 A:middle
你阅读测试报告时

00:29:18.866 --> 00:29:19.966 A:middle
数据就在那里了

00:29:20.496 --> 00:29:22.206 A:middle
这就把我们带到了

00:29:22.206 --> 00:29:23.516 A:middle
技术群组的第三大

00:29:23.556 --> 00:29:24.766 A:middle
内容 即

00:29:24.766 --> 00:29:25.626 A:middle
屏幕快照

00:29:26.506 --> 00:29:27.916 A:middle
多年来 在座的很多人都

00:29:27.916 --> 00:29:29.716 A:middle
要求我们提供一个可以

00:29:29.716 --> 00:29:31.676 A:middle
按需显性捕捉

00:29:31.816 --> 00:29:32.626 A:middle
屏幕快照的 API

00:29:32.836 --> 00:29:34.406 A:middle
我们很高兴地告诉大家

00:29:34.406 --> 00:29:35.896 A:middle
现在我们做到了 希望大家会

00:29:35.896 --> 00:29:35.963 A:middle
喜欢

00:29:36.516 --> 00:29:41.876 A:middle
[掌声]

00:29:42.376 --> 00:29:44.416 A:middle
这个全新的可以提供

00:29:44.416 --> 00:29:45.596 A:middle
屏幕快照的 XCUI 协议

00:29:45.596 --> 00:29:48.196 A:middle
是由 XCUIElement 以及

00:29:48.576 --> 00:29:50.976 A:middle
新的 XCUIScreen 类来执行的

00:29:51.456 --> 00:29:52.966 A:middle
所以 当你使用一个元素并

00:29:52.966 --> 00:29:54.366 A:middle
捕捉一张屏幕快照时

00:29:54.366 --> 00:29:56.246 A:middle
会剪裁到只包含该元素的

00:29:56.246 --> 00:29:56.946 A:middle
图框

00:29:56.946 --> 00:29:58.136 A:middle
如果元素是按钮 你就只会看到按钮

00:29:58.136 --> 00:29:59.886 A:middle
如果元素是窗口 你就会看到

00:29:59.886 --> 00:30:00.976 A:middle
完整的窗口 以此类推

00:29:59.886 --> 00:30:00.976 A:middle
完整的窗口 以此类推

00:30:01.076 --> 00:30:03.176 A:middle
如果你使用屏幕 API

00:30:03.636 --> 00:30:04.686 A:middle
那么无论屏幕上

00:30:04.916 --> 00:30:06.386 A:middle
显示了什么应用程序

00:30:06.386 --> 00:30:08.216 A:middle
你都能看到

00:30:09.516 --> 00:30:09.596 A:middle
全屏

00:30:09.966 --> 00:30:11.496 A:middle
现在有了附件和

00:30:11.496 --> 00:30:13.396 A:middle
屏幕快照  在座一些人可能会

00:30:13.396 --> 00:30:16.096 A:middle
疑惑这得多快就

00:30:16.096 --> 00:30:17.476 A:middle
装满硬盘啦

00:30:18.996 --> 00:30:20.876 A:middle
对于附件以及在 UI

00:30:20.876 --> 00:30:22.186 A:middle
测试过程中

00:30:22.186 --> 00:30:23.686 A:middle
自动捕捉的

00:30:23.686 --> 00:30:25.406 A:middle
屏幕快照的默认策略是

00:30:25.846 --> 00:30:27.916 A:middle
如果测试通过了 那我们就

00:30:27.916 --> 00:30:28.926 A:middle
帮你把这些删除

00:30:29.546 --> 00:30:30.916 A:middle
这就假设了在一般情况下

00:30:30.916 --> 00:30:33.286 A:middle
根本不需要它们 但如果

00:30:33.286 --> 00:30:34.806 A:middle
测试失败了 它们才会显现

00:30:34.806 --> 00:30:35.196 A:middle
出来

00:30:35.966 --> 00:30:38.056 A:middle
现在 你可以在 Scheme 中

00:30:38.406 --> 00:30:39.196 A:middle
覆盖这个策略

00:30:39.196 --> 00:30:40.756 A:middle
在 UI 中存在本地化

00:30:40.756 --> 00:30:42.946 A:middle
控制的相同部分

00:30:43.026 --> 00:30:44.816 A:middle
你可以告诉我们是否

00:30:44.816 --> 00:30:46.976 A:middle
希望可以全自动捕捉

00:30:47.276 --> 00:30:48.936 A:middle
屏幕快照以及是否想要

00:30:48.936 --> 00:30:50.856 A:middle
把这些屏幕快照和附件删除

00:30:50.856 --> 00:30:52.376 A:middle
无论测试成功与否

00:30:53.156 --> 00:30:54.996 A:middle
在附件类也有

00:30:54.996 --> 00:30:57.066 A:middle
API 能够让你可以

00:30:57.066 --> 00:30:59.576 A:middle
根据具体的实例来

00:30:59.576 --> 00:31:01.066 A:middle
保留或者删除元素 及诸如

00:30:59.576 --> 00:31:01.066 A:middle
保留或者删除元素 及诸如

00:31:01.066 --> 00:31:01.596 A:middle
此类的事

00:31:02.186 --> 00:31:04.116 A:middle
接下来 大家可以在下一个

00:31:04.116 --> 00:31:06.576 A:middle
关于附件 Activity 和屏幕快照的 Demo 中

00:31:06.576 --> 00:31:08.156 A:middle
来看看实际的

00:31:08.156 --> 00:31:08.586 A:middle
场景

00:31:08.916 --> 00:31:10.796 A:middle
让我们欢迎 Honza Dvorsky

00:31:10.796 --> 00:31:10.976 A:middle
上台

00:31:11.516 --> 00:31:17.566 A:middle
[掌声]

00:31:18.066 --> 00:31:18.646 A:middle
&gt;&gt; 谢谢你 Wil

00:31:19.316 --> 00:31:21.616 A:middle
下午好 我叫 Honza

00:31:21.716 --> 00:31:23.546 A:middle
今天我将给大家展示

00:31:26.636 --> 00:31:29.836 A:middle
我们如何使用 Activity 来

00:31:29.836 --> 00:31:33.036 A:middle
组织测试 以及如何

00:31:33.036 --> 00:31:35.016 A:middle
利用新的屏幕快照 API 来

00:31:35.016 --> 00:31:37.696 A:middle
给你的 UI 进行屏幕快照 最后还会看看

00:31:37.696 --> 00:31:39.536 A:middle
如何将任意数据添加到

00:31:39.536 --> 00:31:40.286 A:middle
测试中

00:31:40.996 --> 00:31:42.656 A:middle
下面 我们首先来看看

00:31:43.156 --> 00:31:44.606 A:middle
Warren 做的测试的

00:31:44.606 --> 00:31:44.926 A:middle
测试报告

00:31:45.986 --> 00:31:46.816 A:middle
我们可以通过

00:31:46.816 --> 00:31:48.116 A:middle
按住 Control 键的同时单击

00:31:48.116 --> 00:31:49.796 A:middle
测试方块并选取

00:31:49.896 --> 00:31:50.696 A:middle
“Jump to Report（跳转到报告）”

00:31:53.636 --> 00:31:55.506 A:middle
当我们展开一项测试 我们

00:31:55.506 --> 00:31:56.946 A:middle
便可以看到测试脚本

00:31:57.486 --> 00:31:59.396 A:middle
测试脚本包含关于

00:31:59.396 --> 00:32:01.756 A:middle
测试的全部细节 但

00:31:59.396 --> 00:32:01.756 A:middle
测试的全部细节 但

00:32:01.756 --> 00:32:03.166 A:middle
当测试越久 就变得

00:32:03.166 --> 00:32:04.166 A:middle
越难导航

00:32:07.076 --> 00:32:08.826 A:middle
此外 我们在这儿看到的是

00:32:08.826 --> 00:32:10.726 A:middle
类似这些标签和滑动的

00:32:10.726 --> 00:32:12.596 A:middle
分级步骤 这会

00:32:12.596 --> 00:32:14.266 A:middle
帮助我们在这些高层

00:32:14.266 --> 00:32:15.776 A:middle
任务周围组织测试

00:32:15.776 --> 00:32:18.586 A:middle
例如 启动应用程序或是

00:32:18.586 --> 00:32:19.876 A:middle
编写发送一条新的信息

00:32:20.956 --> 00:32:23.356 A:middle
我们用 Activity 所做的

00:32:23.356 --> 00:32:25.436 A:middle
正是这个

00:32:27.096 --> 00:32:28.236 A:middle
下面我们要回到源代码

00:32:28.606 --> 00:32:30.366 A:middle
来寻找适合包装进第一项

00:32:30.366 --> 00:32:31.376 A:middle
Activity 的候选项

00:32:32.006 --> 00:32:33.366 A:middle
比如这一部分代码

00:32:33.606 --> 00:32:34.976 A:middle
编写和发送新的信息

00:32:35.326 --> 00:32:36.016 A:middle
可以通过它实现

00:32:36.406 --> 00:32:39.916 A:middle
那么 通过调用 XCTContext.runActivity

00:32:39.916 --> 00:32:42.316 A:middle
我们把它包装进一个 Activitiy

00:32:43.006 --> 00:32:44.356 A:middle
这需要两个参数

00:32:44.356 --> 00:32:45.406 A:middle
第一个是 Activity 的名称

00:32:45.406 --> 00:32:47.536 A:middle
在我们的这个例子里就是

00:32:47.536 --> 00:32:49.356 A:middle
编写和发送新信息 第二个参数

00:32:49.356 --> 00:32:51.246 A:middle
是块

00:32:51.246 --> 00:32:52.466 A:middle
块代表了 Activity 的

00:32:52.466 --> 00:32:52.906 A:middle
范围

00:32:53.786 --> 00:32:56.006 A:middle
我们在这里加个大括号

00:32:57.216 --> 00:32:59.036 A:middle
就是这样 以上就是在一个

00:32:59.036 --> 00:33:00.736 A:middle
Activity 中包装一段代码

00:32:59.036 --> 00:33:00.736 A:middle
Activity 中包装一段代码

00:33:00.736 --> 00:33:01.226 A:middle
所须要做的全部

00:33:02.776 --> 00:33:04.276 A:middle
下面 我再给这个

00:33:04.276 --> 00:33:09.066 A:middle
测试创建更多的 Activity

00:33:09.066 --> 00:33:10.826 A:middle
我们将重新运行这个测试来

00:33:10.826 --> 00:33:12.126 A:middle
看看测试报告将如何变动

00:33:12.736 --> 00:33:16.736 A:middle
你可以看到我包装了

00:33:16.736 --> 00:33:18.986 A:middle
readerApp 的启动

00:33:18.986 --> 00:33:20.006 A:middle
对首条信息的

00:33:20.006 --> 00:33:22.446 A:middle
验证 writerApp 的

00:33:22.446 --> 00:33:24.306 A:middle
激活以及新信息的

00:33:24.306 --> 00:33:25.886 A:middle
编写和发送等等

00:33:26.886 --> 00:33:29.066 A:middle
这是 Warren 之前编写

00:33:29.166 --> 00:33:31.446 A:middle
的那个文本

00:33:31.486 --> 00:33:33.246 A:middle
但这一次这些 Activity 和我们

00:33:33.246 --> 00:33:35.206 A:middle
起的名字将作为

00:33:35.206 --> 00:33:37.766 A:middle
最高级成员

00:33:37.766 --> 00:33:38.916 A:middle
包含在输出中

00:33:39.586 --> 00:33:43.936 A:middle
所以 我们发送了信息

00:33:43.936 --> 00:33:45.866 A:middle
验证了这是正确的信息

00:33:47.936 --> 00:33:48.816 A:middle
我们就完成了

00:33:49.016 --> 00:33:50.516 A:middle
下面 让我们回到测试

00:33:50.516 --> 00:33:50.976 A:middle
报告上

00:33:55.176 --> 00:33:56.876 A:middle
当我们展开脚本时

00:33:56.876 --> 00:33:58.566 A:middle
现在我们可以看到内容变得更短

00:33:59.086 --> 00:34:00.206 A:middle
并且除此之外 它更好地

00:33:59.086 --> 00:34:00.206 A:middle
并且除此之外 它更好地

00:34:00.206 --> 00:34:02.106 A:middle
描述了我们的测试所做的工作

00:34:02.466 --> 00:34:04.026 A:middle
它启动了 readerApp

00:34:04.536 --> 00:34:06.006 A:middle
验证了第一条信息

00:34:06.386 --> 00:34:07.656 A:middle
激活了 writerApp、

00:34:07.806 --> 00:34:09.306 A:middle
编写并发送了新的信息

00:34:09.306 --> 00:34:09.766 A:middle
等等

00:34:10.485 --> 00:34:11.656 A:middle
但如果你还是需要了解

00:34:11.656 --> 00:34:13.166 A:middle
关于这个 Activity 的所有细节信息

00:34:13.166 --> 00:34:15.156 A:middle
所有的子 Activity 都

00:34:15.226 --> 00:34:16.755 A:middle
隐藏在更深的一层

00:34:17.726 --> 00:34:19.556 A:middle
所以  Activity 是组织测试

00:34:19.556 --> 00:34:23.226 A:middle
的一种良好方式

00:34:23.275 --> 00:34:25.166 A:middle
下面让我们来稍微换换

00:34:25.536 --> 00:34:25.676 A:middle
思路

00:34:25.676 --> 00:34:27.926 A:middle
帮助我们设计应用程序的

00:34:27.926 --> 00:34:30.676 A:middle
设计师们想确定

00:34:30.676 --> 00:34:32.255 A:middle
我们的信息栏

00:34:32.746 --> 00:34:33.866 A:middle
完全遵守了他们

00:34:33.866 --> 00:34:35.216 A:middle
的规范

00:34:35.956 --> 00:34:37.565 A:middle
所以我们要做的就是编写一个

00:34:37.565 --> 00:34:39.795 A:middle
捕捉了应用程序视觉状态的

00:34:39.795 --> 00:34:42.315 A:middle
UI 测试 然后每个晚上

00:34:42.315 --> 00:34:44.076 A:middle
都在我们的机器人上运行这个

00:34:44.076 --> 00:34:44.456 A:middle
测试

00:34:44.906 --> 00:34:46.346 A:middle
通过这种方式 我们的设计师可以

00:34:46.346 --> 00:34:47.926 A:middle
在任何想来的时候来看看

00:34:47.956 --> 00:34:49.036 A:middle
应用程序的外观

00:34:49.696 --> 00:34:53.426 A:middle
所以这是新的类

00:34:53.426 --> 00:34:54.315 A:middle
VisualValidationTests

00:34:54.315 --> 00:34:56.806 A:middle
我已经有了代码可以

00:34:56.876 --> 00:34:58.186 A:middle
以我想要的方式启动

00:34:58.186 --> 00:35:00.196 A:middle
应用程序 同时我还有

00:34:58.186 --> 00:35:00.196 A:middle
应用程序 同时我还有

00:35:00.196 --> 00:35:01.376 A:middle
空的 Activity 叫做 “Gather Screenshots（获取屏幕快照）”

00:35:01.376 --> 00:35:03.156 A:middle
我们会把

00:35:03.156 --> 00:35:04.546 A:middle
我们的屏幕快照放在这里

00:35:05.386 --> 00:35:06.746 A:middle
我们会捕捉两个屏幕快照

00:35:06.746 --> 00:35:08.436 A:middle
第一个是应用程序的

00:35:08.436 --> 00:35:11.056 A:middle
全屏 而另一个则仅仅截取

00:35:11.056 --> 00:35:11.986 A:middle
第一个信息栏

00:35:12.516 --> 00:35:16.076 A:middle
那么 为了捕捉全屏

00:35:16.366 --> 00:35:18.566 A:middle
我们使用新的 XCUIScreen API 来

00:35:18.566 --> 00:35:20.416 A:middle
控制主屏幕

00:35:21.546 --> 00:35:23.456 A:middle
正如 Wil 所提到的那样 XCUIScreen

00:35:23.456 --> 00:35:25.336 A:middle
遵循 XCUIScreenshotProviding 协议

00:35:25.336 --> 00:35:27.216 A:middle
所以我们可以仅

00:35:27.216 --> 00:35:29.006 A:middle
要求它自我

00:35:29.006 --> 00:35:29.396 A:middle
屏幕快照

00:35:29.426 --> 00:35:32.676 A:middle
现在 我们的内存里有

00:35:32.676 --> 00:35:34.106 A:middle
屏幕快照 并且我们也想

00:35:34.186 --> 00:35:36.476 A:middle
在测试中继续保持

00:35:36.476 --> 00:35:37.726 A:middle
这时候附件就派上

00:35:37.726 --> 00:35:37.926 A:middle
用场了

00:35:38.256 --> 00:35:41.766 A:middle
附件可以保存任何数据

00:35:42.086 --> 00:35:43.666 A:middle
并且 XCTAttachment 为

00:35:43.666 --> 00:35:45.096 A:middle
便利初始化程序提供了

00:35:45.096 --> 00:35:46.846 A:middle
诸如字符串 文件

00:35:46.846 --> 00:35:48.056 A:middle
图像和屏幕快照等类别

00:35:48.446 --> 00:35:50.986 A:middle
那么我们要创建一个新的

00:35:50.986 --> 00:35:52.156 A:middle
附件来保存

00:35:52.156 --> 00:35:52.786 A:middle
屏幕快照

00:35:54.276 --> 00:35:56.936 A:middle
正如 Wil 提到的那样

00:35:56.936 --> 00:35:58.686 A:middle
一旦测试通过了 屏幕快照

00:35:58.686 --> 00:36:00.146 A:middle
就被删除了 这个一个默认

00:35:58.686 --> 00:36:00.146 A:middle
就被删除了 这个一个默认

00:36:00.146 --> 00:36:00.596 A:middle
行为

00:36:01.606 --> 00:36:02.946 A:middle
但在我们的例子中 我们希望

00:36:02.946 --> 00:36:04.266 A:middle
无论测试结果如何

00:36:04.316 --> 00:36:05.876 A:middle
都保留附件

00:36:06.416 --> 00:36:07.926 A:middle
我们可以创建一个单独的附件

00:36:08.396 --> 00:36:10.936 A:middle
然后自定义附件的生命期让它

00:36:10.936 --> 00:36:11.906 A:middle
始终保存

00:36:13.176 --> 00:36:14.496 A:middle
最后 我们把这个

00:36:14.496 --> 00:36:16.526 A:middle
附件加到 Activity 中 我们会把

00:36:16.526 --> 00:36:18.386 A:middle
它加到代表了

00:36:18.386 --> 00:36:19.366 A:middle
收集屏幕快照的

00:36:19.366 --> 00:36:19.976 A:middle
Activity 中

00:36:24.286 --> 00:36:25.676 A:middle
现在我们捕捉了全屏

00:36:25.676 --> 00:36:27.276 A:middle
我们还想捕捉

00:36:27.276 --> 00:36:28.416 A:middle
第一个信息栏

00:36:28.506 --> 00:36:31.586 A:middle
那么首先 我们使用现有的

00:36:31.936 --> 00:36:33.696 A:middle
UI 测试 API 来获取

00:36:33.696 --> 00:36:35.266 A:middle
信息栏的 XCUIElement

00:36:36.166 --> 00:36:38.036 A:middle
XCUIElement 同样遵守

00:36:38.036 --> 00:36:40.156 A:middle
XCUIScreenshotProviding 协议

00:36:40.156 --> 00:36:41.576 A:middle
所以我们只须照着同样的

00:36:41.576 --> 00:36:41.806 A:middle
步骤操作

00:36:42.306 --> 00:36:44.336 A:middle
我们命令信息栏对自身进行

00:36:44.336 --> 00:36:46.056 A:middle
屏幕快照 我们为它创建

00:36:46.056 --> 00:36:47.556 A:middle
一个附件 自定义它的

00:36:47.556 --> 00:36:49.426 A:middle
生命期并将附件添加到

00:36:49.426 --> 00:36:50.036 A:middle
Activity 中

00:36:51.416 --> 00:36:52.986 A:middle
那么现在 让我们来运行测试

00:36:52.986 --> 00:36:53.576 A:middle
看看会出现什么

00:36:59.046 --> 00:37:01.136 A:middle
这是一个简单的测试 只需要

00:36:59.046 --> 00:37:01.136 A:middle
这是一个简单的测试 只需要

00:37:01.136 --> 00:37:03.956 A:middle
启动应用程序 捕捉

00:37:03.956 --> 00:37:06.516 A:middle
两个屏幕快照 把这两个屏幕快照

00:37:06.516 --> 00:37:08.176 A:middle
作为附件添加

00:37:08.176 --> 00:37:08.976 A:middle
就完成了

00:37:14.186 --> 00:37:14.536 A:middle
就是这样

00:37:14.856 --> 00:37:16.636 A:middle
下面再来看看测试报告

00:37:17.176 --> 00:37:23.076 A:middle
当我们展开测试时 我们

00:37:23.076 --> 00:37:25.096 A:middle
看到了获取屏幕快照的

00:37:25.096 --> 00:37:28.246 A:middle
Activity 它含有两个

00:37:28.246 --> 00:37:29.086 A:middle
附加以及

00:37:29.086 --> 00:37:29.816 A:middle
子 Activity

00:37:30.226 --> 00:37:32.086 A:middle
那么这是代表了第一个

00:37:32.086 --> 00:37:34.416 A:middle
主屏幕屏幕快照的附件

00:37:34.416 --> 00:37:36.496 A:middle
而这个代表了

00:37:36.496 --> 00:37:37.616 A:middle
只有信息栏的

00:37:37.616 --> 00:37:38.196 A:middle
屏幕快照

00:37:38.986 --> 00:37:41.146 A:middle
我们可以使用快速预览图标

00:37:41.146 --> 00:37:43.226 A:middle
来获取预览窗口

00:37:43.226 --> 00:37:45.296 A:middle
但实际上 我想使用

00:37:45.296 --> 00:37:47.486 A:middle
这个“Assistant Editor（助理编辑器）”来

00:37:47.486 --> 00:37:47.766 A:middle
实现

00:37:52.046 --> 00:37:53.476 A:middle
我们只需选取正确的

00:37:53.736 --> 00:37:56.286 A:middle
屏幕快照 这就是我们的

00:37:56.386 --> 00:37:59.426 A:middle
全屏屏幕快照 这个是

00:37:59.426 --> 00:38:00.626 A:middle
只有第一个信息栏的

00:37:59.426 --> 00:38:00.626 A:middle
只有第一个信息栏的

00:38:00.626 --> 00:38:01.516 A:middle
屏幕快照

00:38:02.446 --> 00:38:04.226 A:middle
这样你就可以看到捕捉

00:38:04.226 --> 00:38:06.146 A:middle
是多么的简单容易了

00:38:06.146 --> 00:38:06.396 A:middle
对吧

00:38:07.516 --> 00:38:12.546 A:middle
[掌声]

00:38:13.046 --> 00:38:14.216 A:middle
现在你可以看到通过这个

00:38:14.216 --> 00:38:15.946 A:middle
新的屏幕快照 API 来真正捕捉

00:38:15.946 --> 00:38:17.036 A:middle
应用程序中的任何屏幕

00:38:17.526 --> 00:38:19.236 A:middle
或元素并且利用新的附件 API

00:38:19.616 --> 00:38:21.276 A:middle
来把屏幕快照添加到测试中

00:38:21.276 --> 00:38:22.376 A:middle
是多么容易了

00:38:22.376 --> 00:38:25.806 A:middle
我真心希望大家都能试一试

00:38:25.976 --> 00:38:27.516 A:middle
好了 那下面我再有请

00:38:27.516 --> 00:38:28.826 A:middle
Wil 回到台上

00:38:28.826 --> 00:38:29.536 A:middle
来进行总结

00:38:29.806 --> 00:38:29.976 A:middle
有请 Wil

00:38:30.516 --> 00:38:36.686 A:middle
[掌声]

00:38:37.186 --> 00:38:38.866 A:middle
谢谢你 Honza 简直

00:38:38.866 --> 00:38:40.396 A:middle
太精彩了 大家可以看到

00:38:40.396 --> 00:38:41.956 A:middle
Activity 在改进测试架构

00:38:41.956 --> 00:38:43.956 A:middle
方面是多么容易

00:38:43.956 --> 00:38:45.176 A:middle
使用附件来捕捉

00:38:45.176 --> 00:38:46.956 A:middle
丰富的数据将使修复测试失败

00:38:46.956 --> 00:38:48.346 A:middle
变得前所未有的容易

00:38:48.346 --> 00:38:50.596 A:middle
还有屏幕快照 难道还有人

00:38:50.596 --> 00:38:51.606 A:middle
不喜欢屏幕快照吗

00:38:52.216 --> 00:38:53.436 A:middle
这就是 Activity  附件和

00:38:53.436 --> 00:38:54.926 A:middle
屏幕快照 这是大家在测试中

00:38:54.926 --> 00:38:56.606 A:middle
可以使用的一全新的领先

00:38:56.606 --> 00:38:57.126 A:middle
技术

00:38:57.626 --> 00:39:00.346 A:middle
所以 今天我们以测试

00:38:57.626 --> 00:39:00.346 A:middle
所以 今天我们以测试

00:39:00.346 --> 00:39:01.636 A:middle
新发现作为开头 你也可以看出来

00:39:01.636 --> 00:39:02.396 A:middle
内容丰富多样

00:39:03.156 --> 00:39:04.996 A:middle
我们有很多新的 API 供大家

00:39:04.996 --> 00:39:06.476 A:middle
使用 今天甚至没来得及将它们

00:39:06.476 --> 00:39:07.416 A:middle
逐个介绍

00:39:08.236 --> 00:39:11.656 A:middle
我们有很多新的 API

00:39:12.086 --> 00:39:14.376 A:middle
我们也有新的工作流以及

00:39:14.376 --> 00:39:15.896 A:middle
Xcode 中的持续集成功能

00:39:15.986 --> 00:39:18.216 A:middle
还有 xcodebuild 命令和 Xcode Server

00:39:18.216 --> 00:39:20.346 A:middle
我们还

00:39:20.346 --> 00:39:21.986 A:middle
极大提升了 UI 测试的

00:39:21.986 --> 00:39:22.406 A:middle
性能

00:39:22.486 --> 00:39:25.676 A:middle
最后 感谢大家到场

00:39:26.066 --> 00:39:27.876 A:middle
通过上方的链接 可以找到

00:39:27.906 --> 00:39:30.346 A:middle
关于本次会议的所有

00:39:30.346 --> 00:39:31.746 A:middle
相关资料和

00:39:31.746 --> 00:39:33.076 A:middle
文件 你想看的全部

00:39:33.076 --> 00:39:33.626 A:middle
都在这里

00:39:34.376 --> 00:39:36.036 A:middle
当然 我们在过去举办了

00:39:36.036 --> 00:39:38.076 A:middle
很多场会议

00:39:38.076 --> 00:39:39.156 A:middle
明天还有一场希望大家可以

00:39:39.156 --> 00:39:39.686 A:middle
参加

00:39:40.286 --> 00:39:42.196 A:middle
前几年的会议中

00:39:42.196 --> 00:39:43.646 A:middle
确实有一些很有用的

00:39:43.646 --> 00:39:45.206 A:middle
信息是关于 Xcode 测试的

00:39:45.206 --> 00:39:47.426 A:middle
其他方面 都是我们在今天

00:39:47.426 --> 00:39:48.656 A:middle
没能仔细探讨的

00:39:48.746 --> 00:39:49.016 A:middle
内容

00:39:49.516 --> 00:39:49.846 A:middle
感谢大家
