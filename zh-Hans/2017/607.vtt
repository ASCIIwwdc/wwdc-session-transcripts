WEBVTT

00:00:07.516 --> 00:00:21.516 A:middle
谈话声

00:00:22.516 --> 00:00:27.556 A:middle
[掌声]

00:00:28.056 --> 00:00:29.076 A:middle
&gt;&gt; 大家下午好

00:00:29.076 --> 00:00:30.446 A:middle
欢迎来到

00:00:30.446 --> 00:00:31.796 A:middle
Metal 2 优化和调试

00:00:31.796 --> 00:00:34.716 A:middle
你们已经知道 我们今年

00:00:34.716 --> 00:00:35.856 A:middle
有很多关于 Metal 2 的内容

00:00:35.856 --> 00:00:37.116 A:middle
在一些平台上实现了

00:00:37.116 --> 00:00:39.106 A:middle
一些很好的提升

00:00:39.106 --> 00:00:40.966 A:middle
包括 GP 驱动渲染 机器学习加速

00:00:40.966 --> 00:00:43.936 A:middle
macOS VR 和

00:00:43.936 --> 00:00:45.716 A:middle
外部 GPU 支持

00:00:47.106 --> 00:00:48.466 A:middle
别忘了还有

00:00:48.466 --> 00:00:49.636 A:middle
高级优化工具

00:00:50.186 --> 00:00:52.886 A:middle
所以 今天下午我们

00:00:52.886 --> 00:00:54.536 A:middle
将会讨论一下当前的

00:00:54.666 --> 00:00:56.076 A:middle
Metal 工具

00:00:56.376 --> 00:00:57.906 A:middle
简要概括一下它们

00:00:57.906 --> 00:00:59.536 A:middle
并介绍一些很棒的

00:00:59.536 --> 00:01:01.356 A:middle
针对 Metal 帧调试工具的提升

00:00:59.536 --> 00:01:01.356 A:middle
针对 Metal 帧调试工具的提升

00:01:01.356 --> 00:01:03.136 A:middle
最后讨论一些

00:01:03.136 --> 00:01:04.016 A:middle
关于 GPU 配置的内容

00:01:04.676 --> 00:01:08.016 A:middle
首先 我们来看看 帧调试工具

00:01:10.226 --> 00:01:12.056 A:middle
我希望你们都

00:01:12.056 --> 00:01:12.776 A:middle
熟悉这个工具

00:01:14.076 --> 00:01:15.376 A:middle
帧调试工具集成在 Xcode 中

00:01:15.376 --> 00:01:17.246 A:middle
功能齐全

00:01:17.246 --> 00:01:20.106 A:middle
让你可以处理你的

00:01:20.106 --> 00:01:22.586 A:middle
Metal 2 作品

00:01:22.966 --> 00:01:24.126 A:middle
让它成为计算机图形

00:01:24.126 --> 00:01:25.086 A:middle
并且可以进一步检查

00:01:25.086 --> 00:01:27.086 A:middle
状态和资源

00:01:27.476 --> 00:01:28.186 A:middle
让你能够调试和优化

00:01:29.076 --> 00:01:33.216 A:middle
提升帧调试

00:01:33.216 --> 00:01:34.006 A:middle
工具的性能

00:01:34.006 --> 00:01:34.886 A:middle
是我们最近几年

00:01:34.886 --> 00:01:36.676 A:middle
的工作中心之一

00:01:36.676 --> 00:01:38.316 A:middle
我们尤其

00:01:38.316 --> 00:01:39.386 A:middle
注意提升

00:01:39.676 --> 00:01:40.346 A:middle
捕获速度

00:01:40.346 --> 00:01:43.096 A:middle
我很开心告诉大家

00:01:43.096 --> 00:01:46.436 A:middle
与 Xcode 8 相比

00:01:46.436 --> 00:01:48.586 A:middle
Xcode 9 现在的捕获速度

00:01:49.106 --> 00:01:50.116 A:middle
可以达到原来的 10 倍

00:01:50.116 --> 00:01:51.556 A:middle
让你从点按 Capture 按钮

00:01:51.556 --> 00:01:52.946 A:middle
到打开调试工具的时间

00:01:52.946 --> 00:01:53.256 A:middle
大大缩短

00:01:56.036 --> 00:01:58.466 A:middle
如你期待的那样

00:01:58.466 --> 00:02:00.036 A:middle
我们全面支持了 Metal 2 的 API

00:01:58.466 --> 00:02:00.036 A:middle
我们全面支持了 Metal 2 的 API

00:02:00.036 --> 00:02:02.006 A:middle
包括光栅顺序组

00:02:02.006 --> 00:02:04.346 A:middle
采样数组  Viewport 数组

00:02:04.346 --> 00:02:06.146 A:middle
以及全新的像素和

00:02:06.146 --> 00:02:07.356 A:middle
顶点数组格式

00:02:07.876 --> 00:02:10.856 A:middle
在 Metal 2 中

00:02:10.856 --> 00:02:12.406 A:middle
我们花了很大精力

00:02:12.406 --> 00:02:14.116 A:middle
来支持全新的

00:02:14.116 --> 00:02:15.296 A:middle
参数缓冲器

00:02:15.936 --> 00:02:17.376 A:middle
有了它 在缓冲查看器中

00:02:17.626 --> 00:02:19.386 A:middle
你可以看到所有的

00:02:19.386 --> 00:02:20.546 A:middle
参数 缓冲参数

00:02:20.646 --> 00:02:22.196 A:middle
都一行行显示出来

00:02:22.196 --> 00:02:23.856 A:middle
你可以点按它们选择是否要

00:02:23.856 --> 00:02:26.516 A:middle
附上你的采样器 缓冲器

00:02:26.516 --> 00:02:32.686 A:middle
或者其他参数缓冲器

00:02:32.686 --> 00:02:33.956 A:middle
此外 随着对 SteamVR 的自动支持

00:02:33.956 --> 00:02:35.196 A:middle
我们今年开始支持

00:02:35.196 --> 00:02:36.456 A:middle
VR 捕获

00:02:36.456 --> 00:02:38.316 A:middle
我们也为你们提供了

00:02:38.316 --> 00:02:40.216 A:middle
让你们可以以立体的形式

00:02:40.216 --> 00:02:40.966 A:middle
查看你们上传的界面的支持

00:02:41.446 --> 00:02:43.526 A:middle
当你们发送 提交

00:02:43.526 --> 00:02:44.576 A:middle
指令的时候 你将会向

00:02:44.576 --> 00:02:46.116 A:middle
VR 混合器发送你的界面

00:02:46.406 --> 00:02:47.786 A:middle
你会同时看到

00:02:47.786 --> 00:02:49.556 A:middle
左右眼的视图

00:02:49.556 --> 00:02:51.106 A:middle
可以帮助你发现其中的差异

00:02:51.676 --> 00:02:56.496 A:middle
今年的另一个工作重心是

00:02:56.716 --> 00:02:58.006 A:middle
为了要针对更复杂的计算任务

00:02:58.006 --> 00:02:59.456 A:middle
进行捕获

00:02:59.456 --> 00:03:00.416 A:middle
我们改进了捕获工作流

00:02:59.456 --> 00:03:00.416 A:middle
我们改进了捕获工作流

00:03:00.826 --> 00:03:01.836 A:middle
所以如果你现在

00:03:01.896 --> 00:03:04.036 A:middle
只在 Metal 里做纯计算任务

00:03:04.036 --> 00:03:05.396 A:middle
或者如果你同时有多个

00:03:05.396 --> 00:03:07.516 A:middle
Metal 命令队列  现在我们就可以

00:03:07.516 --> 00:03:08.846 A:middle
更轻松地  准确捕获到你想要

00:03:08.846 --> 00:03:09.396 A:middle
的那部分内容

00:03:10.446 --> 00:03:11.526 A:middle
我们还添加了轻便型

00:03:11.526 --> 00:03:13.576 A:middle
捕获 API  其中内置了一些新的 Metal

00:03:13.576 --> 00:03:15.406 A:middle
捕获作用域对象  我们可以在新建

00:03:15.406 --> 00:03:17.416 A:middle
项目时创建这些对象  然后后期在

00:03:17.416 --> 00:03:19.276 A:middle
每一帧都可以重复利用  可以用来

00:03:19.276 --> 00:03:20.136 A:middle
包裹住之后想捕获的部分

00:03:20.546 --> 00:03:21.656 A:middle
我们稍后会看到这项的演示

00:03:21.656 --> 00:03:22.746 A:middle
这给我们带来了新的可能性

00:03:22.746 --> 00:03:25.346 A:middle
比如说  现在可以把我们所有的

00:03:25.626 --> 00:03:28.006 A:middle
正常渲染任务都包在一个作用域里

00:03:28.006 --> 00:03:29.666 A:middle
把其他那些异步任务  比如说

00:03:29.916 --> 00:03:31.126 A:middle
重新生成我们的密铺因子缓冲区

00:03:31.126 --> 00:03:32.866 A:middle
这一类的任务  归到另一个

00:03:32.866 --> 00:03:33.956 A:middle
作用域里  这样等我们开始捕获的时候

00:03:33.956 --> 00:03:35.456 A:middle
就可以精准地制定区域  获得想要的

00:03:35.456 --> 00:03:35.866 A:middle
结果

00:03:37.416 --> 00:03:38.576 A:middle
我们现在还支持

00:03:38.576 --> 00:03:39.266 A:middle
在我们的应用程序中

00:03:39.266 --> 00:03:40.766 A:middle
用编程方式触发捕获过程

00:03:41.316 --> 00:03:43.026 A:middle
其实我们在自己的测试应用程序里

00:03:43.026 --> 00:03:44.256 A:middle
也经常使用这一功能  用上之后

00:03:44.256 --> 00:03:45.436 A:middle
比如我们可以立马在设备上做一个

00:03:45.436 --> 00:03:46.826 A:middle
什么手势  然后就可以自动触发

00:03:47.216 --> 00:03:48.476 A:middle
帧捕获  我们就不用再

00:03:48.476 --> 00:03:53.046 A:middle
费力切换回 Xcode 去实现这个功能了

00:03:53.546 --> 00:03:55.076 A:middle
今年要宣布的另一个新功能

00:03:55.076 --> 00:03:56.676 A:middle
是 Xcode 的快速预览(Quick Looks)

00:03:57.046 --> 00:03:57.606 A:middle
功能

00:03:58.826 --> 00:04:00.766 A:middle
现在在 CPU 调试工具里

00:03:58.826 --> 00:04:00.766 A:middle
现在在 CPU 调试工具里

00:04:00.766 --> 00:04:02.286 A:middle
有了新的轻便型 Metal

00:04:02.286 --> 00:04:02.856 A:middle
调试功能

00:04:03.116 --> 00:04:05.276 A:middle
假设我们现在再遇到断点

00:04:05.276 --> 00:04:07.316 A:middle
如果包含有 Metal 纹理

00:04:07.796 --> 00:04:09.206 A:middle
快速预览就会从 GPU 里

00:04:09.206 --> 00:04:11.426 A:middle
自动提取 Metal 纹理数据

00:04:11.426 --> 00:04:12.716 A:middle
然后给大家提供实时预览

00:04:12.916 --> 00:04:14.106 A:middle
同样的功能  也支持预览缓冲区

00:04:14.106 --> 00:04:14.586 A:middle
和采样器

00:04:15.486 --> 00:04:17.375 A:middle
对于有些不太方便

00:04:17.375 --> 00:04:19.796 A:middle
做完整帧捕获的项目  这个功能

00:04:19.796 --> 00:04:21.736 A:middle
非常有用  举个例子来说

00:04:21.736 --> 00:04:22.786 A:middle
如果我们要调试的是

00:04:22.786 --> 00:04:24.156 A:middle
资源载入  或者一些设置代码

00:04:24.156 --> 00:04:24.546 A:middle
这一类

00:04:24.546 --> 00:04:27.506 A:middle
另外  如果我们要调试一些

00:04:27.506 --> 00:04:28.916 A:middle
计算任务  用这个断点预览

00:04:28.916 --> 00:04:32.606 A:middle
也会非常方便

00:04:33.026 --> 00:04:35.156 A:middle
去年我们介绍了

00:04:35.416 --> 00:04:37.056 A:middle
在帧调试工具里

00:04:37.266 --> 00:04:38.606 A:middle
全局可用的  丰富的过滤功能

00:04:38.686 --> 00:04:41.526 A:middle
我们可以同时过滤

00:04:41.526 --> 00:04:42.946 A:middle
比如  资源属性  这一类东西

00:04:43.426 --> 00:04:44.356 A:middle
但同时  在帧

00:04:44.356 --> 00:04:47.156 A:middle
导航栏里  我们也可以依据

00:04:47.156 --> 00:04:49.606 A:middle
上下文数据进行过滤  这样如果

00:04:49.936 --> 00:04:51.146 A:middle
我们的过滤条件是一个特定绘制指令

00:04:51.146 --> 00:04:52.506 A:middle
所用的资源  过滤结果就会输出

00:04:52.506 --> 00:04:53.566 A:middle
那个特定的绘制指令

00:04:53.756 --> 00:04:55.196 A:middle
我们今年把这一功能进行了改进

00:04:55.196 --> 00:04:56.626 A:middle
能达到的功能更上一层楼了

00:04:56.626 --> 00:04:58.136 A:middle
现在我们还可以支持在整个

00:04:58.136 --> 00:04:59.476 A:middle
捕获帧内进行数据挖掘

00:05:00.156 --> 00:05:01.716 A:middle
所以现在我们一边输入  程序

00:05:01.716 --> 00:05:03.626 A:middle
就会一边自动返回上下文相关的

00:05:03.626 --> 00:05:04.866 A:middle
自动补全建议

00:05:05.706 --> 00:05:07.886 A:middle
而且我们现在还支持复合术语

00:05:08.326 --> 00:05:10.236 A:middle
所以如果现在先限定某个特定的

00:05:10.236 --> 00:05:12.506 A:middle
编码器  然后再限定某个

00:05:12.506 --> 00:05:14.696 A:middle
纹理  我们现在给你显示

00:05:14.696 --> 00:05:15.806 A:middle
出的的自动补全建议  就会是

00:05:15.806 --> 00:05:17.026 A:middle
那个特定编码器里

00:05:17.026 --> 00:05:22.346 A:middle
实际用到的纹理

00:05:22.946 --> 00:05:24.386 A:middle
这几年来  我们收到

00:05:24.386 --> 00:05:25.806 A:middle
请求最多的一项功能就是

00:05:25.806 --> 00:05:27.106 A:middle
像素审查 (Pixel Inspection) 功能

00:05:28.386 --> 00:05:29.496 A:middle
我们现在终于满足了这一需求

00:05:30.386 --> 00:05:32.186 A:middle
所以现在我们可以针对

00:05:32.186 --> 00:05:34.886 A:middle
每一个独立像素  做详细的审查

00:05:35.196 --> 00:05:36.706 A:middle
不管是在纹理  还是

00:05:36.706 --> 00:05:37.486 A:middle
在渲染目标中

00:05:38.046 --> 00:05:39.366 A:middle
而如果你的渲染

00:05:39.366 --> 00:05:40.196 A:middle
目标中  包含有多个附件

00:05:40.196 --> 00:05:41.606 A:middle
我们还会在同一时间

00:05:41.656 --> 00:05:43.366 A:middle
给你显示出每个

00:05:43.366 --> 00:05:45.206 A:middle
附件内部同等位置处的

00:05:45.206 --> 00:05:45.866 A:middle
像素值

00:05:45.976 --> 00:05:47.146 A:middle
所以如果我们要看着附件调试

00:05:47.146 --> 00:05:48.836 A:middle
颜色值啊  同时还要调试

00:05:48.836 --> 00:05:50.136 A:middle
模版啊之类的东西

00:05:50.136 --> 00:05:51.036 A:middle
就会非常方便

00:05:51.346 --> 00:05:52.916 A:middle
这个功能在调试计算任务

00:05:52.916 --> 00:05:54.516 A:middle
的时候  也非常有用

00:05:54.516 --> 00:05:55.746 A:middle
比如你正在处理图片

00:05:55.746 --> 00:05:56.996 A:middle
假设我们的

00:05:56.996 --> 00:05:58.236 A:middle
CNN 正做到一半  但是想测试一下

00:05:58.236 --> 00:05:59.686 A:middle
看看各个缓冲区里面的实际

00:05:59.686 --> 00:06:01.036 A:middle
数值都是多少  就可以用这个来

00:05:59.686 --> 00:06:01.036 A:middle
数值都是多少  就可以用这个来

00:06:01.036 --> 00:06:01.306 A:middle
审查

00:06:03.516 --> 00:06:07.546 A:middle
[掌声]

00:06:08.046 --> 00:06:09.026 A:middle
我们去年介绍的

00:06:09.026 --> 00:06:10.556 A:middle
另一个新功能  就是

00:06:10.556 --> 00:06:12.436 A:middle
顶点属性观察器  在这里

00:06:12.436 --> 00:06:14.336 A:middle
我们可以看到  所有在传入我们的

00:06:14.486 --> 00:06:16.376 A:middle
顶点着色引擎的顶点数据

00:06:16.376 --> 00:06:18.246 A:middle
数据按照每个顶点分开

00:06:18.246 --> 00:06:19.856 A:middle
显示

00:06:20.496 --> 00:06:21.446 A:middle
好了  今年  我们又添加

00:06:21.446 --> 00:06:23.626 A:middle
了新的功能  现在我们也可以看到

00:06:23.626 --> 00:06:25.556 A:middle
顶点着色引擎输出的顶点数据了

00:06:25.696 --> 00:06:27.766 A:middle
我们还会把这个内联

00:06:28.076 --> 00:06:29.776 A:middle
和之前支持的输入时的数据并列显示

00:06:30.146 --> 00:06:31.476 A:middle
所以在这个例子里  我们可以看到

00:06:31.476 --> 00:06:33.306 A:middle
输入的顶点位置数据  和输出的

00:06:33.306 --> 00:06:34.596 A:middle
顶点位置数据  同时显示在

00:06:34.596 --> 00:06:35.000 A:middle
一起

00:06:38.046 --> 00:06:38.866 A:middle
好了  现在该给大家实际

00:06:38.866 --> 00:06:40.076 A:middle
演示一下我说过的这些新功能了

00:06:40.076 --> 00:06:41.256 A:middle
请允许我邀请我的同事

00:06:41.486 --> 00:06:42.686 A:middle
Max 上台  他将会给大家

00:06:42.686 --> 00:06:44.106 A:middle
演示刚刚说过的这些精彩的

00:06:44.106 --> 00:06:45.076 A:middle
新功能

00:06:46.516 --> 00:06:49.556 A:middle
[掌声]

00:06:50.056 --> 00:06:51.956 A:middle
大家好  很高兴今天在这里见到

00:06:51.956 --> 00:06:52.386 A:middle
大家

00:06:52.526 --> 00:06:57.706 A:middle
我希望大家手头工作进展都不错

00:06:57.706 --> 00:06:59.776 A:middle
而你们都和我们一样  对 Metal 充满

00:06:59.776 --> 00:07:00.236 A:middle
激情

00:06:59.776 --> 00:07:00.236 A:middle
激情

00:07:00.636 --> 00:07:02.616 A:middle
Xcode 的 GPU 调试工具可以帮我们

00:07:02.616 --> 00:07:04.456 A:middle
调试我们的 GPU 和 Metal 占用

00:07:04.456 --> 00:07:05.146 A:middle
情况

00:07:05.616 --> 00:07:07.356 A:middle
我叫作 Max  今天我会帮大家

00:07:07.356 --> 00:07:08.496 A:middle
最优化 (maximize) 你们的调试

00:07:08.496 --> 00:07:09.886 A:middle
体验  给大家演示下新的

00:07:09.886 --> 00:07:10.246 A:middle
功能

00:07:11.516 --> 00:07:14.696 A:middle
[掌声]

00:07:15.196 --> 00:07:17.106 A:middle
让我运行一下我的示例程序

00:07:19.576 --> 00:07:21.676 A:middle
这里渲染出来的  是一幅美丽的

00:07:21.676 --> 00:07:24.056 A:middle
风景  显示出来  雪中

00:07:24.056 --> 00:07:26.266 A:middle
的山脉啦  在风中飘动

00:07:26.266 --> 00:07:27.936 A:middle
的草啦  然后为了让效果

00:07:27.936 --> 00:07:29.986 A:middle
看起来更好  我还添加了一些

00:07:29.986 --> 00:07:31.846 A:middle
颗粒  并让它们在空中闪闪

00:07:32.606 --> 00:07:33.176 A:middle
发光

00:07:33.216 --> 00:07:35.636 A:middle
但就像大家看到的那样

00:07:35.636 --> 00:07:37.826 A:middle
草上面的这些颗粒  看起来

00:07:37.826 --> 00:07:39.316 A:middle
渲染得有点问题

00:07:39.546 --> 00:07:41.196 A:middle
所以让我们看看怎么解决一下

00:07:41.756 --> 00:07:46.296 A:middle
作为调试的第一步  让我们先看看

00:07:46.296 --> 00:07:47.336 A:middle
纹理设置对了没有

00:07:47.906 --> 00:07:49.436 A:middle
我们在渲染循环里设置

00:07:49.436 --> 00:07:50.656 A:middle
一个断点  设置在正要

00:07:50.716 --> 00:07:52.116 A:middle
使用这个纹理的时候

00:07:53.216 --> 00:07:54.846 A:middle
把鼠标悬停在一个变量上

00:07:54.846 --> 00:07:57.226 A:middle
我们就可以看到 Xcode 的数据提示

00:07:57.566 --> 00:07:59.446 A:middle
可通过 Xcode 这个提示快速查看该变量的

00:07:59.446 --> 00:08:00.196 A:middle
纹理数据

00:07:59.446 --> 00:08:00.196 A:middle
纹理数据

00:08:00.726 --> 00:08:02.296 A:middle
这个纹理数据  是实时从 GPU

00:08:02.296 --> 00:08:03.996 A:middle
抓取的  可以帮助我们

00:08:03.996 --> 00:08:05.576 A:middle
快速确认  是否绑定上了正确

00:08:05.576 --> 00:08:07.466 A:middle
的资源  当然  这个功能对于

00:08:07.466 --> 00:08:09.136 A:middle
所有的 Metal 资源都可用

00:08:09.856 --> 00:08:12.196 A:middle
我们目前这个变量的纹理看起来

00:08:12.196 --> 00:08:12.916 A:middle
没有错

00:08:13.406 --> 00:08:20.006 A:middle
那么我们还有什么可以检查的

00:08:20.276 --> 00:08:21.786 A:middle
我们下一步  就可以开始捕获帧

00:08:21.786 --> 00:08:22.226 A:middle
了

00:08:22.686 --> 00:08:25.336 A:middle
只需点击调试栏里的这个

00:08:25.336 --> 00:08:27.366 A:middle
小照相机图标  我们就可以捕获

00:08:27.366 --> 00:08:29.866 A:middle
一帧  但如果我们长按这个图标

00:08:30.146 --> 00:08:31.556 A:middle
就会显示出菜单  可以选择捕获

00:08:31.556 --> 00:08:33.596 A:middle
作用域  或者命令队列

00:08:33.876 --> 00:08:36.106 A:middle
捕获作用域是通过渲染通道

00:08:36.306 --> 00:08:37.596 A:middle
完成

00:08:37.846 --> 00:08:39.035 A:middle
就像我的环境图  这个

00:08:39.035 --> 00:08:40.395 A:middle
我每几帧  才更新

00:08:40.395 --> 00:08:41.066 A:middle
一次

00:08:41.826 --> 00:08:43.366 A:middle
但这个例子里  我们想要

00:08:43.366 --> 00:08:44.596 A:middle
捕获的是渲染过程  因为这个

00:08:44.596 --> 00:08:45.636 A:middle
过程里才会真正开始绘制颗粒

00:08:46.866 --> 00:08:49.836 A:middle
所以我们点击  捕获一下

00:08:50.046 --> 00:08:50.946 A:middle
这就捕获好了

00:08:51.476 --> 00:08:54.096 A:middle
对于那些不太熟悉我们的工具

00:08:54.096 --> 00:08:55.956 A:middle
界面的人  我先给大家

00:08:55.956 --> 00:08:56.986 A:middle
快速讲解一下在这个

00:08:56.986 --> 00:08:58.186 A:middle
界面上  都有些什么东西

00:08:58.186 --> 00:09:01.726 A:middle
在界面左侧  我们可以看到

00:08:58.186 --> 00:09:01.726 A:middle
在界面左侧  我们可以看到

00:09:01.726 --> 00:09:02.716 A:middle
调试工具导航栏

00:09:03.186 --> 00:09:04.276 A:middle
在这里按等级

00:09:04.276 --> 00:09:06.396 A:middle
显示了我们的帧  为了更加

00:09:06.396 --> 00:09:08.016 A:middle
方便大家调试使用  自动

00:09:08.016 --> 00:09:10.316 A:middle
进行了分组  分开了命令缓冲区

00:09:10.316 --> 00:09:11.376 A:middle
和命令编码器

00:09:12.346 --> 00:09:13.926 A:middle
我们的调试组

00:09:13.926 --> 00:09:15.936 A:middle
也显示在这里了  让我们在

00:09:15.936 --> 00:09:17.566 A:middle
微小的层面上也可以掌控调整帧

00:09:17.906 --> 00:09:19.856 A:middle
我们可以选择绘制指令

00:09:19.856 --> 00:09:21.526 A:middle
或者任何其他的 Metal 指令  来审查

00:09:21.526 --> 00:09:22.346 A:middle
其更多细节

00:09:23.136 --> 00:09:27.406 A:middle
位于界面中央的编辑器

00:09:27.406 --> 00:09:29.106 A:middle
向我们展示了绑定的资源

00:09:29.496 --> 00:09:30.846 A:middle
展示了选中的 API 指令中

00:09:30.846 --> 00:09:32.986 A:middle
我们所用到的所有的 Metal 对象

00:09:33.986 --> 00:09:35.976 A:middle
在这里我们也可以看到  为我们的对象

00:09:35.976 --> 00:09:37.726 A:middle
添加标签  可以有效提高调试时的

00:09:37.726 --> 00:09:38.536 A:middle
可读性

00:09:38.926 --> 00:09:41.306 A:middle
我建议大家都养成这个习惯

00:09:42.956 --> 00:09:45.026 A:middle
界面右侧的编辑器

00:09:45.026 --> 00:09:46.556 A:middle
显示的是附件  是最近

00:09:46.556 --> 00:09:48.556 A:middle
一次绘制指令的输出结果

00:09:49.136 --> 00:09:50.066 A:middle
所以不管你什么时候

00:09:50.066 --> 00:09:51.416 A:middle
不管在帧的哪里

00:09:51.606 --> 00:09:53.106 A:middle
都可以马上看到自己在哪一步

00:09:53.936 --> 00:09:56.346 A:middle
在界面最下方  我们有

00:09:56.346 --> 00:09:58.166 A:middle
变量观察器  可以让我们

00:09:58.166 --> 00:10:00.156 A:middle
方便地查看每个 Metal 对象的

00:09:58.166 --> 00:10:00.156 A:middle
方便地查看每个 Metal 对象的

00:10:00.156 --> 00:10:01.026 A:middle
状态

00:10:01.506 --> 00:10:03.296 A:middle
好了  我们回到刚刚颗粒的

00:10:03.296 --> 00:10:04.366 A:middle
问题上

00:10:04.786 --> 00:10:06.216 A:middle
现在我们就可以试验一下超强的

00:10:06.216 --> 00:10:07.756 A:middle
过滤功能

00:10:08.496 --> 00:10:11.226 A:middle
好了  现在我知道  那些颗粒

00:10:11.226 --> 00:10:12.666 A:middle
是在正向渲染过程中某处绘制的

00:10:13.316 --> 00:10:15.556 A:middle
所以让我们试着过滤一下

00:10:15.866 --> 00:10:17.576 A:middle
如果对命令编码器进行过滤

00:10:17.976 --> 00:10:20.786 A:middle
那么结果只会显示这个命令编码器

00:10:20.786 --> 00:10:21.926 A:middle
里的 API 指令

00:10:21.926 --> 00:10:22.846 A:middle
比如像这样

00:10:23.446 --> 00:10:25.486 A:middle
但结果还是太多了

00:10:26.646 --> 00:10:28.386 A:middle
所以我们再添加一个额外的过滤

00:10:28.386 --> 00:10:28.736 A:middle
条件

00:10:29.086 --> 00:10:30.616 A:middle
我们知道会用到颗粒

00:10:30.616 --> 00:10:31.066 A:middle
纹理

00:10:34.556 --> 00:10:37.186 A:middle
如果对纹理进行过滤  那么结果

00:10:37.186 --> 00:10:39.476 A:middle
只会显示使用了此纹理的绘制

00:10:39.476 --> 00:10:39.896 A:middle
指令

00:10:40.576 --> 00:10:43.656 A:middle
这就好了  这两个过滤条件

00:10:43.656 --> 00:10:46.046 A:middle
叠加  就能过滤出唯一的 API 指令

00:10:46.046 --> 00:10:47.986 A:middle
而这一指令正是我们希望进一步研究的

00:10:48.726 --> 00:10:49.536 A:middle
我们来看一下

00:10:50.016 --> 00:10:53.296 A:middle
我们先看一下这个指令绑定的

00:10:53.296 --> 00:10:54.166 A:middle
资源

00:10:55.046 --> 00:10:57.026 A:middle
这里  顶点属性中包含了

00:10:57.026 --> 00:10:58.456 A:middle
输入顶点函数的数据  也包含了

00:10:58.456 --> 00:11:01.026 A:middle
离开顶点函数的数据

00:10:58.456 --> 00:11:01.026 A:middle
离开顶点函数的数据

00:11:01.296 --> 00:11:02.616 A:middle
也许我们就是在这里搞错了

00:11:02.616 --> 00:11:05.106 A:middle
一些几何特征的设定

00:11:05.106 --> 00:11:06.196 A:middle
所以我们看一下  双击

00:11:06.196 --> 00:11:06.616 A:middle
打开

00:11:07.626 --> 00:11:09.696 A:middle
让我们先把这边的附件

00:11:09.696 --> 00:11:10.406 A:middle
隐藏一下

00:11:11.626 --> 00:11:13.036 A:middle
去年  我们给大家展示了

00:11:13.036 --> 00:11:14.436 A:middle
缓冲区一种更好的布局

00:11:16.516 --> 00:11:17.836 A:middle
今年我们还新添加了一些别的东西

00:11:18.986 --> 00:11:20.316 A:middle
在界面眉头  我们可以看到

00:11:20.316 --> 00:11:21.746 A:middle
下方显示的数据是输入还是

00:11:21.746 --> 00:11:22.306 A:middle
输出

00:11:23.266 --> 00:11:28.336 A:middle
如果我们看一下  这边

00:11:28.336 --> 00:11:29.626 A:middle
就是输出的数据  是离开

00:11:29.626 --> 00:11:31.106 A:middle
顶点函数的数据

00:11:31.376 --> 00:11:32.966 A:middle
这些显示了全部颗粒顶点

00:11:33.106 --> 00:11:35.776 A:middle
输出时的位置  我们在这里

00:11:35.776 --> 00:11:37.336 A:middle
可以看到  没有

00:11:37.376 --> 00:11:39.286 A:middle
什么很明显的错误  比如哪个数据

00:11:39.286 --> 00:11:41.166 A:middle
数值过大之类的问题  所以我先

00:11:41.166 --> 00:11:42.706 A:middle
假设这些数据都是正确的

00:11:43.446 --> 00:11:45.336 A:middle
那么我们还可以检查哪里

00:11:46.036 --> 00:11:50.386 A:middle
调试工具导航栏现在还可以让

00:11:50.386 --> 00:11:51.836 A:middle
我们快速定位并进入到当前

00:11:51.836 --> 00:11:53.596 A:middle
绘制指令所相关的所有视图

00:11:53.926 --> 00:11:54.846 A:middle
让我们再切换回

00:11:54.846 --> 00:11:55.746 A:middle
附件看看

00:11:56.256 --> 00:12:01.306 A:middle
我们现在显示了

00:11:56.256 --> 00:12:01.306 A:middle
我们现在显示了

00:12:01.306 --> 00:12:01.506 A:middle
两种渲染目标

00:12:02.436 --> 00:12:04.566 A:middle
颜色  和深度

00:12:05.076 --> 00:12:06.796 A:middle
让我们再审查一些

00:12:06.796 --> 00:12:07.376 A:middle
像素值吧

00:12:07.876 --> 00:12:11.586 A:middle
我们可以使用位于界面右下方的

00:12:11.586 --> 00:12:13.156 A:middle
审查像素按钮  这就可以

00:12:13.226 --> 00:12:16.456 A:middle
唤出一个新工具

00:12:16.556 --> 00:12:20.386 A:middle
一个环形  这个圆环里显示的

00:12:20.386 --> 00:12:22.106 A:middle
数据  和片元函数输出的

00:12:22.106 --> 00:12:23.296 A:middle
数据完全一致

00:12:24.246 --> 00:12:26.256 A:middle
我们可以用鼠标在渲染目标上

00:12:26.256 --> 00:12:27.506 A:middle
随意移动这个圆环

00:12:28.386 --> 00:12:29.796 A:middle
但我们也可以通过方向键

00:12:29.796 --> 00:12:31.796 A:middle
进行精准到像素级别的控制移动

00:12:31.796 --> 00:12:33.186 A:middle
移动之前甚至都不用放大

00:12:34.396 --> 00:12:36.566 A:middle
我们还可以注意到  在所有的

00:12:36.566 --> 00:12:37.806 A:middle
渲染目标上  圆环的移动都是

00:12:37.806 --> 00:12:38.956 A:middle
完全同步的

00:12:39.246 --> 00:12:40.976 A:middle
可让我们同时查看两边的数值

00:12:41.256 --> 00:12:43.306 A:middle
我们现在就找一个

00:12:45.056 --> 00:12:45.136 A:middle
有趣的像素来看一下

00:12:45.356 --> 00:12:46.426 A:middle
我们长按  就可以

00:12:46.426 --> 00:12:47.666 A:middle
立即移动光标

00:12:48.286 --> 00:12:51.686 A:middle
在这个点上  我们可以看出有些

00:12:51.686 --> 00:12:52.576 A:middle
奇怪

00:12:53.466 --> 00:12:55.676 A:middle
这个颗粒的内部和外部

00:12:55.676 --> 00:12:57.586 A:middle
深度数值不一样

00:12:58.076 --> 00:12:59.796 A:middle
这很奇怪  正常情况下

00:12:59.796 --> 00:13:00.946 A:middle
我们的颗粒不应该写入

00:12:59.796 --> 00:13:00.946 A:middle
我们的颗粒不应该写入

00:13:00.946 --> 00:13:01.896 A:middle
深度缓冲区

00:13:02.526 --> 00:13:03.896 A:middle
把这里修好应该很简单

00:13:04.316 --> 00:13:05.976 A:middle
我相信  我们新的 GPU

00:13:05.976 --> 00:13:07.536 A:middle
调试工具也可以帮大家快速地

00:13:07.536 --> 00:13:08.886 A:middle
修好你们 GPU 里的问题

00:13:09.906 --> 00:13:11.346 A:middle
我希望明天早上可以在实验室里

00:13:11.346 --> 00:13:13.326 A:middle
或是在今天的晚些时候

00:13:13.326 --> 00:13:14.226 A:middle
再次看到大家

00:13:14.936 --> 00:13:16.296 A:middle
下面还有请我的同事 Seth

00:13:17.516 --> 00:13:23.256 A:middle
[掌声]

00:13:23.756 --> 00:13:26.276 A:middle
好了  下面我们讲 GPU 性能分析

00:13:27.896 --> 00:13:29.796 A:middle
我们都知道   对于游戏和其他

00:13:29.796 --> 00:13:30.896 A:middle
一些图形应用程序

00:13:30.896 --> 00:13:32.596 A:middle
运行性能至关重要

00:13:32.596 --> 00:13:33.966 A:middle
我们经常需要能够保持

00:13:33.966 --> 00:13:35.316 A:middle
持续稳定的高帧率

00:13:36.106 --> 00:13:37.216 A:middle
但另一方面  我们也

00:13:37.216 --> 00:13:38.616 A:middle
希望能充分利用 GPU

00:13:38.616 --> 00:13:40.066 A:middle
产出图形效果最好的游戏

00:13:40.066 --> 00:13:41.756 A:middle
而同时希望能够提高效率

00:13:41.756 --> 00:13:43.106 A:middle
延长高质量的游戏体验

00:13:43.106 --> 00:13:43.846 A:middle
时间

00:13:44.556 --> 00:13:45.726 A:middle
为了做到以上这些  我们就需要

00:13:45.726 --> 00:13:47.206 A:middle
使用 GPU 性能分析 (Profiling) 工具

00:13:47.656 --> 00:13:53.046 A:middle
我想讲的第一个工具叫作

00:13:53.046 --> 00:13:54.546 A:middle
Metal 系统跟踪 (Metal System Trace)

00:13:55.396 --> 00:13:56.236 A:middle
这个工具可以

00:13:56.236 --> 00:13:58.446 A:middle
用来审查计时问题

00:13:58.446 --> 00:14:00.136 A:middle
我的意思是说  可以审查一些场景

00:13:58.446 --> 00:14:00.136 A:middle
我的意思是说  可以审查一些场景

00:14:00.136 --> 00:14:02.446 A:middle
比如有时 CPU 和 GPU 可能

00:14:02.446 --> 00:14:04.656 A:middle
没有在并行运行

00:14:04.656 --> 00:14:06.286 A:middle
而是因为我们错误地

00:14:06.286 --> 00:14:07.836 A:middle
做了一些同步运行  使得

00:14:07.836 --> 00:14:08.726 A:middle
CPU GPU 被迫无法并行

00:14:08.726 --> 00:14:09.116 A:middle
转而连续运行

00:14:09.796 --> 00:14:10.586 A:middle
这个工具还可以

00:14:10.586 --> 00:14:12.166 A:middle
用来审查一些场景  比如

00:14:12.396 --> 00:14:13.586 A:middle
我们大部分的帧都是

00:14:13.586 --> 00:14:14.676 A:middle
我们想要的样子

00:14:14.676 --> 00:14:15.976 A:middle
但偶尔会有卡顿

00:14:16.246 --> 00:14:17.126 A:middle
然后我们需要去搞明白

00:14:17.126 --> 00:14:18.306 A:middle
好了  就在卡顿的那里底

00:14:18.306 --> 00:14:19.226 A:middle
到有什么问题

00:14:20.106 --> 00:14:21.676 A:middle
这个工具可以让我们

00:14:21.676 --> 00:14:22.966 A:middle
沿着系统跟踪 Metal 任务

00:14:23.046 --> 00:14:25.436 A:middle
从 CPU 到 GPU 到显示

00:14:27.436 --> 00:14:29.606 A:middle
今年  我们还增加了对 VR

00:14:29.606 --> 00:14:31.296 A:middle
应用程序的支持

00:14:31.296 --> 00:14:33.056 A:middle
包含具体的 VR 跟踪点

00:14:33.056 --> 00:14:35.836 A:middle
可针对的活动有比如  当我们向

00:14:35.836 --> 00:14:38.916 A:middle
虚拟现实头盔查询数据时

00:14:38.916 --> 00:14:40.516 A:middle
向 VR Compositor 提交面层

00:14:40.516 --> 00:14:43.086 A:middle
的时候  当 Compositor 进行

00:14:43.086 --> 00:14:45.196 A:middle
排版生成的时候  还有

00:14:45.196 --> 00:14:46.946 A:middle
最后显示在头戴设备的

00:14:47.106 --> 00:14:48.506 A:middle
屏幕上的时候

00:14:49.576 --> 00:14:51.406 A:middle
事实上  从运动到图像显示

00:14:51.406 --> 00:14:53.366 A:middle
整个过程我们都可以追踪

00:14:55.976 --> 00:14:58.266 A:middle
我们今年还添加了

00:14:58.266 --> 00:14:59.566 A:middle
对 ProMotion 显示

00:14:59.566 --> 00:15:02.076 A:middle
的支持  大家可以在新

00:14:59.566 --> 00:15:02.076 A:middle
的支持  大家可以在新

00:15:02.076 --> 00:15:04.096 A:middle
iPad 上找到  就是这周早些时候

00:15:04.096 --> 00:15:06.066 A:middle
发布的新 iPad Pro  我们还在

00:15:06.066 --> 00:15:08.046 A:middle
macOS 上新增了对外部 GPU 的

00:15:08.046 --> 00:15:08.666 A:middle
支持

00:15:09.476 --> 00:15:10.776 A:middle
另外值得注意的  还有

00:15:10.776 --> 00:15:11.906 A:middle
我们对工具集也新做了很多

00:15:11.906 --> 00:15:13.846 A:middle
很棒的改进  让我们可以更加

00:15:13.846 --> 00:15:15.616 A:middle
便捷地查看其他工具集

00:15:15.786 --> 00:15:17.646 A:middle
和 Metal 系统跟踪一起

00:15:17.646 --> 00:15:20.386 A:middle
比以前整合程度更高了

00:15:20.816 --> 00:15:22.776 A:middle
我们另一个性能分析的工具叫作

00:15:22.776 --> 00:15:23.806 A:middle
GPU 着色器分析器 (GPU Shader Profiler)

00:15:24.306 --> 00:15:25.726 A:middle
是分析着色器性能的

00:15:25.726 --> 00:15:26.326 A:middle
不二选择

00:15:27.076 --> 00:15:28.316 A:middle
我们把这个工具整合进了

00:15:28.316 --> 00:15:29.626 A:middle
帧调试工具里  可以让我们

00:15:29.626 --> 00:15:31.466 A:middle
针对每个绘制指令  每个管道

00:15:31.466 --> 00:15:33.116 A:middle
分别查看着色时间

00:15:33.686 --> 00:15:37.416 A:middle
而且  如果在 iOS 或者 Apple tvOS 上

00:15:37.416 --> 00:15:39.236 A:middle
这个工具还可以让我们分

00:15:39.236 --> 00:15:39.956 A:middle
条查看

00:15:41.696 --> 00:15:43.136 A:middle
我们今年第一个全新的工具

00:15:43.136 --> 00:15:44.816 A:middle
专门为了与 GPU 着色分析器

00:15:44.816 --> 00:15:46.006 A:middle
协同工作而

00:15:46.006 --> 00:15:46.496 A:middle
设计

00:15:48.636 --> 00:15:50.296 A:middle
我们管这个工具叫作 Metal 管道

00:15:50.296 --> 00:15:51.046 A:middle
统计工具 (Metal Pipeline Statistics)

00:15:53.036 --> 00:15:55.436 A:middle
Metal 管道统计工具让我们

00:15:55.436 --> 00:15:57.456 A:middle
可以直连 GPU 编译器

00:15:57.456 --> 00:15:59.306 A:middle
编译器根据我们的着色器

00:15:59.306 --> 00:16:00.916 A:middle
生成机器代码  而这个工具可以

00:15:59.306 --> 00:16:00.916 A:middle
生成机器代码  而这个工具可以

00:16:00.916 --> 00:16:02.946 A:middle
让我们查看这些机器代码的质量

00:16:03.016 --> 00:16:03.316 A:middle
优劣

00:16:04.066 --> 00:16:05.176 A:middle
这个工具会输出一系列

00:16:05.176 --> 00:16:06.606 A:middle
丰富的统计数据  比如

00:16:06.756 --> 00:16:08.366 A:middle
指令数啦  指令混合啦

00:16:08.366 --> 00:16:10.236 A:middle
也就是说  统计

00:16:10.236 --> 00:16:11.796 A:middle
像比如 ALU 内存  或者控制流

00:16:11.796 --> 00:16:13.396 A:middle
这类操作所占的相对比例

00:16:13.396 --> 00:16:15.826 A:middle
而在那些相关的

00:16:15.826 --> 00:16:17.216 A:middle
GPU 上  分析输出结果还会

00:16:17.216 --> 00:16:18.866 A:middle
显示寄存器使用和占用情况

00:16:19.306 --> 00:16:21.986 A:middle
对于这部分 GPU 这些

00:16:22.016 --> 00:16:23.436 A:middle
统计信息至关重要

00:16:23.436 --> 00:16:25.306 A:middle
可以帮助我们理解

00:16:25.306 --> 00:16:27.766 A:middle
同时多少个着色器工作的

00:16:27.766 --> 00:16:29.496 A:middle
限制条件都是什么

00:16:30.176 --> 00:16:32.486 A:middle
也就是说同时可以排

00:16:32.646 --> 00:16:33.646 A:middle
多少个着色场景

00:16:34.876 --> 00:16:37.976 A:middle
但更好用的  是新的

00:16:37.976 --> 00:16:39.066 A:middle
编译器评论功能

00:16:39.736 --> 00:16:41.636 A:middle
有个这个  GPU 编译器就可以

00:16:41.636 --> 00:16:43.446 A:middle
针对你着色器的运行性能

00:16:43.666 --> 00:16:44.786 A:middle
给你反馈出直接的  可操作

00:16:44.786 --> 00:16:46.506 A:middle
的指导  还可以告诉我们具体该改进

00:16:46.506 --> 00:16:48.556 A:middle
哪里  可以避免性能迟缓

00:16:48.556 --> 00:16:49.956 A:middle
从比如慢计算使用情况

00:16:50.256 --> 00:16:51.776 A:middle
寄存器溢出  和堆栈使用

00:16:51.776 --> 00:16:52.216 A:middle
情况

00:16:52.796 --> 00:16:56.906 A:middle
这就好像每个 Xcode 都自带了

00:16:56.906 --> 00:16:59.636 A:middle
一位 GPU 编译器工程师

00:17:00.736 --> 00:17:02.806 A:middle
对于每条评论  下面都会展开解释

00:17:02.946 --> 00:17:06.246 A:middle
到底什么意思  我们可以做什么来

00:17:06.316 --> 00:17:08.796 A:middle
提升性能  还会给我们提供一个链接

00:17:08.796 --> 00:17:11.006 A:middle
点击就可以直接定位到需要修改的

00:17:11.076 --> 00:17:11.536 A:middle
地方

00:17:12.695 --> 00:17:13.955 A:middle
好了  为了给大家演示这个新功能

00:17:13.955 --> 00:17:15.036 A:middle
我想请我的同事 Jose

00:17:15.256 --> 00:17:16.935 A:middle
上台  给大家演示一下

00:17:16.935 --> 00:17:18.465 A:middle
Metal 通道

00:17:18.465 --> 00:17:19.086 A:middle
统计工具

00:17:20.516 --> 00:17:22.546 A:middle
[掌声]

00:17:23.046 --> 00:17:23.536 A:middle
&gt;&gt; 大家好

00:17:23.685 --> 00:17:24.526 A:middle
我是 Jose Enrique

00:17:24.606 --> 00:17:26.006 A:middle
我要为大家展示一个新特性

00:17:26.006 --> 00:17:27.556 A:middle
那就是我们的对 GPU 友好的

00:17:27.556 --> 00:17:28.946 A:middle
调试器 它会助你

00:17:29.296 --> 00:17:30.466 A:middle
产出高质量的产品

00:17:30.836 --> 00:17:32.416 A:middle
大家可以看到 我们

00:17:32.526 --> 00:17:33.786 A:middle
正在重放一个在 iOS 上的

00:17:33.976 --> 00:17:35.166 A:middle
捕捉 Metal 的演示

00:17:35.996 --> 00:17:37.956 A:middle
我要做的第一件事

00:17:37.956 --> 00:17:39.286 A:middle
就是把调试导航视图

00:17:39.286 --> 00:17:41.196 A:middle
从按调用检视帧 (view frame

00:17:41.196 --> 00:17:42.766 A:middle
by call） 改成按性能检视帧 (view frame by

00:17:42.766 --> 00:17:43.496 A:middle
performance)

00:17:44.026 --> 00:17:46.916 A:middle
这会给出 这个视图

00:17:46.916 --> 00:17:50.216 A:middle
会给出你所捕捉的所有

00:17:50.216 --> 00:17:53.956 A:middle
通道 按时间分类的

00:17:54.146 --> 00:17:56.066 A:middle
记住 在 Metal 里

00:17:56.066 --> 00:17:57.156 A:middle
着色器永远连接到通道上

00:17:57.556 --> 00:17:59.556 A:middle
因此 这是一个列表

00:17:59.556 --> 00:18:00.656 A:middle
上面是所有

00:17:59.556 --> 00:18:00.656 A:middle
上面是所有

00:18:00.656 --> 00:18:01.126 A:middle
捕捉中可以得到的

00:18:01.126 --> 00:18:01.466 A:middle
发起程序组合

00:18:02.486 --> 00:18:04.506 A:middle
我要看一下

00:18:04.506 --> 00:18:05.296 A:middle
最昂贵的通道

00:18:05.296 --> 00:18:06.836 A:middle
去看看我们是否

00:18:06.836 --> 00:18:07.866 A:middle
能改进着色器

00:18:08.436 --> 00:18:12.726 A:middle
我们可以看到这个视图

00:18:12.726 --> 00:18:13.586 A:middle
有三个部分

00:18:13.956 --> 00:18:15.686 A:middle
最上面的是评价 (remarks)

00:18:16.296 --> 00:18:17.626 A:middle
评价是改进

00:18:17.626 --> 00:18:19.246 A:middle
编译器着色器质量的好办法

00:18:19.616 --> 00:18:21.576 A:middle
它会报告最终编译器

00:18:22.116 --> 00:18:23.486 A:middle
合成时产生的问题

00:18:24.646 --> 00:18:26.326 A:middle
要记住 GPU 会

00:18:26.326 --> 00:18:28.206 A:middle
在每一帧中运行着色器上百万次

00:18:28.206 --> 00:18:30.046 A:middle
因此

00:18:30.046 --> 00:18:31.446 A:middle
你合成的越好

00:18:31.446 --> 00:18:33.746 A:middle
它的性能就会越好

00:18:35.096 --> 00:18:36.406 A:middle
评价还按相关度分类

00:18:36.406 --> 00:18:38.766 A:middle
如果扩张了

00:18:38.766 --> 00:18:41.106 A:middle
它还会告诉你

00:18:41.106 --> 00:18:42.986 A:middle
为什么要上报

00:18:42.986 --> 00:18:44.556 A:middle
再给出建议 该如何预防这种情况

00:18:45.456 --> 00:18:45.523 A:middle
发生

00:18:46.226 --> 00:18:47.836 A:middle
在评价下面

00:18:47.836 --> 00:18:49.336 A:middle
是每个着色器的概况

00:18:49.336 --> 00:18:50.496 A:middle
你可以看到编译器是如何

00:18:50.576 --> 00:18:52.986 A:middle
最终组合

00:18:52.986 --> 00:18:54.096 A:middle
指令比 (instruction

00:18:54.166 --> 00:18:54.876 A:middle
ratio)

00:18:56.186 --> 00:18:58.046 A:middle
最后 我们还有

00:18:58.106 --> 00:18:59.306 A:middle
所用使用这个通道的调回的

00:18:59.306 --> 00:18:59.756 A:middle
列表

00:19:00.396 --> 00:19:01.626 A:middle
这会在我们

00:19:01.626 --> 00:19:02.776 A:middle
迭代我们的着色器时

00:19:02.776 --> 00:19:03.396 A:middle
非常方便

00:19:04.426 --> 00:19:06.946 A:middle
下面让我来展示一个例子

00:19:06.946 --> 00:19:08.506 A:middle
是关于工作流剖析数据的

00:19:09.376 --> 00:19:10.976 A:middle
我们来到最上面的评价部分

00:19:11.186 --> 00:19:13.036 A:middle
寄存器溢出 (Register Spill) 我们可以看到

00:19:13.036 --> 00:19:14.846 A:middle
编译器报告了一个很大的

00:19:14.846 --> 00:19:16.946 A:middle
溢出 有 1040 字节

00:19:17.786 --> 00:19:19.246 A:middle
溢出会导致 GPU

00:19:19.246 --> 00:19:21.546 A:middle
访问内存 这会拖延

00:19:21.546 --> 00:19:22.486 A:middle
你的着色执行

00:19:23.856 --> 00:19:24.806 A:middle
如果能够知道编译器

00:19:24.806 --> 00:19:26.326 A:middle
发生了溢出 并修复它

00:19:26.326 --> 00:19:27.376 A:middle
这会极大地提升你的着色器

00:19:27.376 --> 00:19:29.636 A:middle
性能 但是要找到

00:19:29.636 --> 00:19:30.886 A:middle
编译器在哪里发生溢出

00:19:31.296 --> 00:19:32.566 A:middle
及其原因 这是一个很耗费时间的

00:19:32.566 --> 00:19:32.876 A:middle
事情

00:19:33.936 --> 00:19:36.596 A:middle
但要注意的是第二个和第四个

00:19:36.596 --> 00:19:37.106 A:middle
评价

00:19:37.586 --> 00:19:39.156 A:middle
动态栈存储 (Dynamic Stack Store)

00:19:39.156 --> 00:19:39.766 A:middle
和动态栈读取

00:19:40.776 --> 00:19:43.056 A:middle
如果扩展了 它会给出原因

00:19:43.226 --> 00:19:45.046 A:middle
为什么一个昂贵的栈读取

00:19:45.046 --> 00:19:46.716 A:middle
在本地数组中被反射到

00:19:46.716 --> 00:19:47.416 A:middle
动态偏移上

00:19:48.256 --> 00:19:51.096 A:middle
同时还会给出建议

00:19:51.096 --> 00:19:52.256 A:middle
减少栈访问

00:19:52.336 --> 00:19:53.786 A:middle
消除对于本地数组的

00:19:53.786 --> 00:19:54.476 A:middle
动态访问

00:19:55.236 --> 00:19:57.026 A:middle
这等于在说

00:19:57.026 --> 00:19:58.586 A:middle
在我们的着色器代码中

00:19:58.586 --> 00:20:00.116 A:middle
有一个可变数组在

00:19:58.586 --> 00:20:00.116 A:middle
有一个可变数组在

00:20:00.116 --> 00:20:01.936 A:middle
储存栈 而且我们

00:20:01.936 --> 00:20:03.416 A:middle
在用一些别的可变索引访问它

00:20:04.296 --> 00:20:05.996 A:middle
这在支持 CPU 时

00:20:05.996 --> 00:20:07.816 A:middle
是一个非常常见的模式

00:20:07.816 --> 00:20:09.286 A:middle
但 GPU 不同 我们如果依赖栈的使用

00:20:09.286 --> 00:20:11.346 A:middle
就会造成 GPU 的负担

00:20:11.966 --> 00:20:14.726 A:middle
但要注意建议下面的

00:20:14.726 --> 00:20:15.376 A:middle
话

00:20:15.426 --> 00:20:16.916 A:middle
它有一个准确的行数

00:20:17.436 --> 00:20:18.676 A:middle
这意味着我们选择点击它

00:20:18.776 --> 00:20:22.086 A:middle
就会直接跳转到

00:20:22.086 --> 00:20:23.426 A:middle
着色器代码行

00:20:23.426 --> 00:20:25.146 A:middle
在这里编译器在从

00:20:25.146 --> 00:20:26.286 A:middle
栈数组中读取数据

00:20:26.776 --> 00:20:27.896 A:middle
我们找到编译器溢出了

00:20:29.366 --> 00:20:30.656 A:middle
同时这与我们的共享性能数据

00:20:30.656 --> 00:20:31.676 A:middle
协调得非常好

00:20:31.676 --> 00:20:33.116 A:middle
会让我们知道这一行的高代价

00:20:33.116 --> 00:20:34.986 A:middle
现在我们知道

00:20:34.986 --> 00:20:35.666 A:middle
到底为什么了

00:20:37.396 --> 00:20:40.326 A:middle
着色器执行了两个 pass

00:20:41.056 --> 00:20:42.836 A:middle
第一个 pass 是光线计算

00:20:44.166 --> 00:20:46.956 A:middle
第二个 pass 是

00:20:46.956 --> 00:20:47.776 A:middle
光线积累

00:20:48.766 --> 00:20:49.766 A:middle
这是从 GPU 的角度

00:20:49.766 --> 00:20:51.076 A:middle
与编译器共同工作

00:20:51.076 --> 00:20:52.186 A:middle
来解决问题

00:20:52.856 --> 00:20:55.056 A:middle
我要做的第一件事

00:20:55.176 --> 00:20:56.686 A:middle
是移除栈数组

00:20:56.686 --> 00:20:59.756 A:middle
我要移除它

00:20:59.756 --> 00:21:02.366 A:middle
然后我要

00:20:59.756 --> 00:21:02.366 A:middle
然后我要

00:21:02.366 --> 00:21:03.536 A:middle
第一个循环里

00:21:03.536 --> 00:21:04.896 A:middle
直接计算

00:21:04.896 --> 00:21:06.166 A:middle
光线积累

00:21:09.116 --> 00:21:10.736 A:middle
然后我要移除

00:21:10.736 --> 00:21:12.976 A:middle
第二个循环

00:21:13.996 --> 00:21:14.316 A:middle
不再这样做了

00:21:14.316 --> 00:21:15.916 A:middle
现在我要点击

00:21:15.916 --> 00:21:17.396 A:middle
更新着色器按键 然后

00:21:17.396 --> 00:21:17.916 A:middle
等待结果

00:21:18.516 --> 00:21:19.646 A:middle
这样做会

00:21:19.646 --> 00:21:20.966 A:middle
让编译器进行一次

00:21:20.966 --> 00:21:21.776 A:middle
完整的循环优化

00:21:21.776 --> 00:21:24.376 A:middle
并重新反复使用同样的

00:21:24.376 --> 00:21:26.636 A:middle
减速器而不是去

00:21:26.636 --> 00:21:27.596 A:middle
依赖那个栈

00:21:28.906 --> 00:21:30.356 A:middle
结果出来之后

00:21:30.356 --> 00:21:31.786 A:middle
我们就能看到

00:21:31.786 --> 00:21:33.356 A:middle
前后的合成中的指令比率

00:21:33.356 --> 00:21:35.416 A:middle
已经变小了

00:21:35.416 --> 00:21:36.486 A:middle
同时 这一更改

00:21:36.486 --> 00:21:38.006 A:middle
对通道中用到的每一个绘制调用

00:21:38.006 --> 00:21:39.726 A:middle
的影响也小了

00:21:39.726 --> 00:21:41.296 A:middle
给了我们整个空间性能

00:21:41.296 --> 00:21:41.896 A:middle
的改进

00:21:43.046 --> 00:21:44.226 A:middle
到这里 关于

00:21:44.226 --> 00:21:44.986 A:middle
这个示例

00:21:44.986 --> 00:21:46.246 A:middle
就结束了

00:21:46.466 --> 00:21:47.656 A:middle
交还给我的同事

00:21:47.656 --> 00:21:47.926 A:middle
Seth

00:21:49.516 --> 00:21:54.756 A:middle
[掌声]

00:21:55.256 --> 00:21:56.866 A:middle
&gt;&gt; 谢谢 Jose

00:21:56.966 --> 00:21:59.766 A:middle
下面讲我们今天要介绍的

00:21:59.766 --> 00:22:00.296 A:middle
最后一样工具

00:21:59.766 --> 00:22:00.296 A:middle
最后一样工具

00:22:00.726 --> 00:22:02.286 A:middle
GPU 计数分析 (GPU Counter Profiling)

00:22:02.806 --> 00:22:06.196 A:middle
大家知道 GPU 构建非常复杂

00:22:06.196 --> 00:22:08.056 A:middle
因为有由多个可编程

00:22:08.056 --> 00:22:08.986 A:middle
的固定功能块组成

00:22:08.986 --> 00:22:10.366 A:middle
的通道

00:22:10.366 --> 00:22:12.196 A:middle
在这个通道中

00:22:12.196 --> 00:22:13.396 A:middle
任何地方都可能出现瓶颈

00:22:14.216 --> 00:22:15.476 A:middle
而且常常是

00:22:15.546 --> 00:22:16.936 A:middle
多个地方同时发生

00:22:18.386 --> 00:22:20.986 A:middle
你们作为 Metal 程序员的任务

00:22:20.986 --> 00:22:23.026 A:middle
是让固定功能瓶颈最小化

00:22:23.026 --> 00:22:24.366 A:middle
同时还要有效地

00:22:24.366 --> 00:22:25.966 A:middle
利用可编程块

00:22:28.776 --> 00:22:30.586 A:middle
要实现这一点 我们的

00:22:30.586 --> 00:22:33.166 A:middle
新 GPU 计数分析是个好工具

00:22:33.546 --> 00:22:36.106 A:middle
它不会直接去到

00:22:36.106 --> 00:22:38.236 A:middle
GPU 帧调试器 而是给你

00:22:38.236 --> 00:22:40.286 A:middle
详细的 GPU 硬件

00:22:40.286 --> 00:22:42.866 A:middle
性能数据 在 macOS 上

00:22:42.866 --> 00:22:46.496 A:middle
以每个 draw call 的频率给出

00:22:46.496 --> 00:22:49.066 A:middle
在 iOS 和 Apple tvOS 上以每个编码器的频率给出

00:22:50.036 --> 00:22:51.986 A:middle
它不会给你

00:22:51.986 --> 00:22:54.336 A:middle
一个复杂的计数列表

00:22:54.336 --> 00:22:55.906 A:middle
这种列表为每个 GPU 发生变化

00:22:55.906 --> 00:22:57.676 A:middle
难以理解 常常无法

00:22:58.206 --> 00:22:59.216 A:middle
告诉你你想知道的事

00:22:59.216 --> 00:23:01.576 A:middle
我们定义了一系列

00:22:59.216 --> 00:23:01.576 A:middle
我们定义了一系列

00:23:01.576 --> 00:23:03.236 A:middle
高等级的字符

00:23:03.236 --> 00:23:04.936 A:middle
对每个 GPU 的意义都相同

00:23:05.286 --> 00:23:07.296 A:middle
所以你不需要针对每个 GPU 的

00:23:07.296 --> 00:23:08.666 A:middle
学习曲线了

00:23:10.156 --> 00:23:12.606 A:middle
这就是计数分析

00:23:13.146 --> 00:23:16.726 A:middle
在左边是图像视图

00:23:16.726 --> 00:23:19.506 A:middle
显示出详细的 GPU

00:23:19.546 --> 00:23:21.156 A:middle
计数图 在右边

00:23:21.156 --> 00:23:22.886 A:middle
是细节窗口

00:23:23.606 --> 00:23:25.246 A:middle
我们一样一样说

00:23:26.036 --> 00:23:29.866 A:middle
在图像视图中

00:23:30.276 --> 00:23:33.306 A:middle
显示了每一帧的计数

00:23:33.936 --> 00:23:35.706 A:middle
X 轴代表绘制调用

00:23:35.706 --> 00:23:37.836 A:middle
或者时间上的编码器

00:23:39.036 --> 00:23:40.506 A:middle
在最上面显示的是 GPU 时间

00:23:40.826 --> 00:23:43.206 A:middle
所有的 GPU 计数分析

00:23:43.206 --> 00:23:43.996 A:middle
都有这个

00:23:44.746 --> 00:23:45.886 A:middle
在它下面

00:23:45.886 --> 00:23:47.106 A:middle
是一系列顶级计数

00:23:47.106 --> 00:23:48.706 A:middle
对应 GPU 通道中的每个阶段

00:23:48.706 --> 00:23:50.986 A:middle
以及一些其他的

00:23:50.986 --> 00:23:52.386 A:middle
顶级计数

00:23:52.386 --> 00:23:53.996 A:middle
对应共享执行单元

00:23:53.996 --> 00:23:55.816 A:middle
比如着色器核心

00:23:55.816 --> 00:23:56.836 A:middle
和测试单元

00:23:58.616 --> 00:24:00.796 A:middle
你可以在每一组

00:23:58.616 --> 00:24:00.796 A:middle
你可以在每一组

00:24:00.796 --> 00:24:02.686 A:middle
深挖到更细节的计数

00:24:02.686 --> 00:24:04.726 A:middle
在每一个阶段中

00:24:04.726 --> 00:24:06.966 A:middle
探索更多数据

00:24:06.966 --> 00:24:08.926 A:middle
这对那些你认为

00:24:08.926 --> 00:24:10.616 A:middle
首当其冲可能是

00:24:10.616 --> 00:24:11.816 A:middle
性能发生问题的

00:24:11.976 --> 00:24:13.746 A:middle
工作流很有用 然后你可以看更多细节

00:24:13.746 --> 00:24:14.286 A:middle
从而发现问题

00:24:14.976 --> 00:24:19.586 A:middle
在细节视图中

00:24:19.586 --> 00:24:20.976 A:middle
我们会向你展示

00:24:20.976 --> 00:24:22.306 A:middle
和计数图像视图中一样的

00:24:22.306 --> 00:24:23.706 A:middle
计数 但是会展示全部的细节

00:24:23.706 --> 00:24:24.226 A:middle
以数值模拟的方式

00:24:25.096 --> 00:24:26.546 A:middle
为了给它一个背景

00:24:26.546 --> 00:24:28.656 A:middle
我们还会展示出

00:24:28.656 --> 00:24:29.996 A:middle
这一帧的中值 最大值

00:24:29.996 --> 00:24:30.786 A:middle
以及总数值

00:24:31.016 --> 00:24:34.546 A:middle
图像视图和

00:24:34.546 --> 00:24:35.856 A:middle
细节视图都支持

00:24:35.856 --> 00:24:38.136 A:middle
全面丰富的过滤选项

00:24:38.426 --> 00:24:40.036 A:middle
我们在帧调试器的其他地方也支持

00:24:40.036 --> 00:24:42.226 A:middle
这种选项 所以如果你想同时

00:24:42.226 --> 00:24:44.086 A:middle
查看某个像素数据

00:24:44.216 --> 00:24:45.426 A:middle
和某个内存数据

00:24:45.426 --> 00:24:47.336 A:middle
你可以把搜索项目合并

00:24:47.336 --> 00:24:48.776 A:middle
然后依次查看

00:24:48.776 --> 00:24:49.876 A:middle
你所需要的所有东西

00:24:51.406 --> 00:24:54.696 A:middle
但我要重点指出

00:24:54.696 --> 00:24:56.756 A:middle
GPU 计数分析是我们

00:24:56.756 --> 00:24:58.026 A:middle
对瓶颈分析的利器

00:24:59.016 --> 00:25:00.516 A:middle
我们用它找出

00:24:59.016 --> 00:25:00.516 A:middle
我们用它找出

00:25:00.516 --> 00:25:01.896 A:middle
在每一个绘制调用

00:25:01.896 --> 00:25:03.706 A:middle
或者每一个编码器中

00:25:03.706 --> 00:25:05.536 A:middle
用过的计数

00:25:05.536 --> 00:25:07.696 A:middle
对它进行全面分析

00:25:07.696 --> 00:25:10.446 A:middle
这种分析是跨平台基础上的

00:25:10.446 --> 00:25:12.716 A:middle
也是以每个 GPU 为基础的

00:25:12.716 --> 00:25:14.506 A:middle
从而找出每个调用中的潜在瓶颈

00:25:16.446 --> 00:25:19.546 A:middle
除了这个 我们还给你

00:25:19.546 --> 00:25:21.416 A:middle
很多数据 让你知道

00:25:21.416 --> 00:25:22.636 A:middle
发生了什么

00:25:23.006 --> 00:25:24.306 A:middle
什么导致的

00:25:24.306 --> 00:25:26.266 A:middle
然后是直接导航到

00:25:26.266 --> 00:25:28.716 A:middle
受影响地区的直观工作流

00:25:30.346 --> 00:25:32.136 A:middle
现在 所有的瓶颈

00:25:32.136 --> 00:25:34.356 A:middle
以及所有的计数

00:25:34.486 --> 00:25:36.606 A:middle
都会在 Xcode 文件里

00:25:36.866 --> 00:25:38.826 A:middle
有丰富的细节记录

00:25:39.166 --> 00:25:40.716 A:middle
详细解释每一个计数的意义

00:25:40.716 --> 00:25:43.276 A:middle
为什么它特别高

00:25:43.276 --> 00:25:44.636 A:middle
或者特别低

00:25:44.636 --> 00:25:46.626 A:middle
以及你能

00:25:46.626 --> 00:25:47.846 A:middle
做些什么

00:25:47.846 --> 00:25:49.306 A:middle
要展示这个

00:25:49.516 --> 00:25:51.086 A:middle
很棒的 GPU 计数分析特性

00:25:51.086 --> 00:25:52.556 A:middle
我想再次请上我的同事

00:25:52.556 --> 00:25:54.476 A:middle
Jose 来给大家做

00:25:54.476 --> 00:25:56.336 A:middle
实际应用的演示

00:25:57.516 --> 00:25:59.676 A:middle
[掌声]

00:26:00.176 --> 00:26:00.576 A:middle
&gt;&gt; 谢谢 Seth

00:26:01.176 --> 00:26:02.116 A:middle
我又来了

00:26:02.806 --> 00:26:06.066 A:middle
这次我要展示的是

00:26:06.426 --> 00:26:10.266 A:middle
GPU 计数器 这个工具

00:26:10.266 --> 00:26:11.396 A:middle
会帮助你分析

00:26:11.396 --> 00:26:11.996 A:middle
GPU 的性能

00:26:13.036 --> 00:26:14.066 A:middle
首先 我要再播放一遍

00:26:14.066 --> 00:26:15.286 A:middle
刚才放过的演示

00:26:15.286 --> 00:26:17.496 A:middle
但这次 我们要从性能角度

00:26:17.496 --> 00:26:18.636 A:middle
注意观看

00:26:19.766 --> 00:26:21.596 A:middle
要注意的第一件事是

00:26:21.596 --> 00:26:23.656 A:middle
新的 GPU 测量

00:26:23.656 --> 00:26:24.336 A:middle
就在 FPS 测量下面

00:26:25.366 --> 00:26:26.356 A:middle
点击它 我们就

00:26:26.356 --> 00:26:28.796 A:middle
来到了 GP 计数视图

00:26:29.436 --> 00:26:31.316 A:middle
我们可以看到

00:26:31.316 --> 00:26:32.486 A:middle
这里有很多数据

00:26:33.106 --> 00:26:34.306 A:middle
这在之前是没有过的

00:26:34.476 --> 00:26:36.286 A:middle
有了这个视图 你们就可以

00:26:36.356 --> 00:26:38.216 A:middle
传输文件 在任意捕捉帧中

00:26:38.216 --> 00:26:39.316 A:middle
你所遇到的任何问题

00:26:39.316 --> 00:26:40.296 A:middle
都可以

00:26:41.326 --> 00:26:42.796 A:middle
我来演示一下要怎么

00:26:42.796 --> 00:26:43.776 A:middle
发现性能问题

00:26:45.326 --> 00:26:46.696 A:middle
首先 我们来看图像

00:26:46.696 --> 00:26:47.016 A:middle
视图

00:26:50.206 --> 00:26:51.566 A:middle
我们看到

00:26:51.566 --> 00:26:53.076 A:middle
在一个捕捉的开始

00:26:53.076 --> 00:26:54.016 A:middle
有一个 GPU 时间的高峰

00:26:54.526 --> 00:26:56.356 A:middle
你要做的第一件事

00:26:56.356 --> 00:26:58.746 A:middle
就是放大去看单一的回调

00:26:58.826 --> 00:26:59.876 A:middle
有更多的

00:26:59.876 --> 00:27:00.436 A:middle
offender

00:26:59.876 --> 00:27:00.436 A:middle
offender

00:27:00.946 --> 00:27:01.926 A:middle
要做到这一点 我只需

00:27:01.926 --> 00:27:04.596 A:middle
捏合缩放 这样就

00:27:04.596 --> 00:27:04.846 A:middle
可以了

00:27:05.556 --> 00:27:07.216 A:middle
任何默认系统行为

00:27:07.216 --> 00:27:08.356 A:middle
都会按你的意愿

00:27:08.356 --> 00:27:08.696 A:middle
工作

00:27:09.406 --> 00:27:11.546 A:middle
现在我会看到这里有一个

00:27:11.546 --> 00:27:12.266 A:middle
高峰

00:27:12.456 --> 00:27:14.106 A:middle
你可以通过点击这个

00:27:14.106 --> 00:27:15.306 A:middle
绘制调用

00:27:15.436 --> 00:27:17.856 A:middle
在所有通道中标记这个高峰

00:27:17.856 --> 00:27:19.856 A:middle
在每一行上悬停会给我们

00:27:19.856 --> 00:27:21.396 A:middle
细节信息 让我们知道

00:27:21.396 --> 00:27:23.016 A:middle
它们分别与这个绘制调用

00:27:23.016 --> 00:27:23.936 A:middle
有多大相关

00:27:24.856 --> 00:27:26.896 A:middle
在这个示例中 Vertex Omission

00:27:27.026 --> 00:27:28.506 A:middle
Vertex Shader 和 Primitives

00:27:28.936 --> 00:27:30.546 A:middle
似乎都没有相关的

00:27:30.676 --> 00:27:30.876 A:middle
影响

00:27:31.406 --> 00:27:33.096 A:middle
与之相反 Fragment Shader

00:27:33.716 --> 00:27:35.236 A:middle
和 Pixels Stored 看起来

00:27:35.436 --> 00:27:36.316 A:middle
相当的高

00:27:37.106 --> 00:27:38.836 A:middle
我们先来看一下 Fragment

00:27:38.836 --> 00:27:39.436 A:middle
Shader

00:27:40.396 --> 00:27:42.326 A:middle
如果我们展开这个组

00:27:42.326 --> 00:27:43.796 A:middle
就能够访问大量的

00:27:43.796 --> 00:27:45.596 A:middle
计数数据 这能给我们

00:27:45.656 --> 00:27:47.336 A:middle
细节信息 让我们知道

00:27:47.336 --> 00:27:48.806 A:middle
着色器阶段发生了什么

00:27:49.636 --> 00:27:50.646 A:middle
最后被计数的

00:27:50.646 --> 00:27:52.366 A:middle
我们可以很快看到

00:27:52.616 --> 00:27:54.476 A:middle
延时时间高得出奇

00:27:54.476 --> 00:27:56.786 A:middle
超过了 76%

00:27:57.486 --> 00:27:58.936 A:middle
这意味着我们花在

00:27:58.936 --> 00:28:00.116 A:middle
Fragment Shader 上的

00:27:58.936 --> 00:28:00.116 A:middle
Fragment Shader 上的

00:28:00.116 --> 00:28:01.586 A:middle
大多数时间实际上是在等待

00:28:01.586 --> 00:28:03.366 A:middle
一些内存或者数据

00:28:04.526 --> 00:28:06.776 A:middle
这是因为你在

00:28:06.776 --> 00:28:08.176 A:middle
从一个缓冲器

00:28:08.176 --> 00:28:10.596 A:middle
或者从一个纹理中取用

00:28:10.596 --> 00:28:11.806 A:middle
但纹理捕捉应该在这个延迟里

00:28:12.406 --> 00:28:14.556 A:middle
所以让我们去到纹理单元 (Texture

00:28:14.556 --> 00:28:16.736 A:middle
Unit) 看看缓存率

00:28:16.736 --> 00:28:16.956 A:middle
是多少

00:28:18.746 --> 00:28:20.526 A:middle
我们可以立即看到

00:28:20.526 --> 00:28:22.256 A:middle
纹理缓存率也出奇的高

00:28:22.256 --> 00:28:24.586 A:middle
几乎到了 60%

00:28:25.326 --> 00:28:27.246 A:middle
这意味着超过一半的

00:28:27.246 --> 00:28:28.396 A:middle
纹理样本

00:28:28.396 --> 00:28:29.636 A:middle
都来自视频内存

00:28:29.636 --> 00:28:30.766 A:middle
而不是纹理缓存

00:28:31.966 --> 00:28:33.956 A:middle
现在我们对于当前的问题

00:28:33.956 --> 00:28:34.946 A:middle
有了更好的了解

00:28:34.946 --> 00:28:36.966 A:middle
就来看一看

00:28:36.966 --> 00:28:37.636 A:middle
辅助编辑器吧

00:28:38.196 --> 00:28:41.686 A:middle
我们可以看到

00:28:41.686 --> 00:28:43.406 A:middle
辅助编辑器提供了

00:28:43.506 --> 00:28:45.006 A:middle
和图像视图一样的

00:28:45.006 --> 00:28:46.156 A:middle
计数信息

00:28:46.356 --> 00:28:48.106 A:middle
这不过这次是以列表视图显示的

00:28:48.806 --> 00:28:51.376 A:middle
但更重要的是 看一下顶部

00:28:51.826 --> 00:28:53.286 A:middle
这是我们的瓶颈访问工具

00:28:53.566 --> 00:28:56.406 A:middle
它会指出我们在

00:28:56.406 --> 00:28:58.106 A:middle
选择的绘制调用内部

00:28:58.106 --> 00:29:00.276 A:middle
分析所有计数时

00:28:58.106 --> 00:29:00.276 A:middle
分析所有计数时

00:29:00.276 --> 00:29:01.736 A:middle
所考虑到的两个相关问题

00:29:01.736 --> 00:29:03.076 A:middle
并指出了我们认为

00:29:03.076 --> 00:29:04.976 A:middle
值得引起你们注意的

00:29:04.976 --> 00:29:05.926 A:middle
任何相关问题

00:29:06.266 --> 00:29:07.356 A:middle
在这个示例里

00:29:07.356 --> 00:29:09.446 A:middle
标记同样的问题

00:29:09.446 --> 00:29:12.776 A:middle
也就是我们刚才通过检查图表

00:29:12.776 --> 00:29:15.646 A:middle
手动发现的问题 纹理缓存失误率很高

00:29:15.876 --> 00:29:17.686 A:middle
展开之后 它还

00:29:17.686 --> 00:29:18.586 A:middle
给出了建议 告诉我们应该检查

00:29:18.586 --> 00:29:18.866 A:middle
什么

00:29:19.636 --> 00:29:21.436 A:middle
在这个示例里 检查

00:29:21.436 --> 00:29:23.446 A:middle
样本纹理是否有纹理映射

00:29:23.486 --> 00:29:25.406 A:middle
还有关于这个问题的

00:29:25.436 --> 00:29:26.786 A:middle
相关视图的快速导航名称

00:29:28.066 --> 00:29:29.656 A:middle
比如边界资源 (boundary sources)

00:29:30.006 --> 00:29:31.266 A:middle
我们可以立即看到

00:29:31.266 --> 00:29:32.886 A:middle
现在的问题是什么

00:29:32.886 --> 00:29:35.866 A:middle
我们正在获取一个 4 K 乘 4 K 的 RGBA32

00:29:35.926 --> 00:29:37.126 A:middle
浮点纹理

00:29:37.126 --> 00:29:38.576 A:middle
并且这个浮点纹理在 vertex

00:29:39.226 --> 00:29:40.126 A:middle
和 Fragment Shader 里都没有纹理映射

00:29:40.476 --> 00:29:43.336 A:middle
这是一个 256 MB 的纹理

00:29:43.336 --> 00:29:44.866 A:middle
在整个通道里被获取

00:29:45.846 --> 00:29:47.816 A:middle
难怪缓存都被浪费了

00:29:48.826 --> 00:29:50.156 A:middle
想一想我们刚才

00:29:50.156 --> 00:29:50.826 A:middle
做了什么

00:29:51.426 --> 00:29:52.486 A:middle
这是一个非常详细的

00:29:52.486 --> 00:29:54.656 A:middle
关于 GPU 内部工作的视图

00:29:55.616 --> 00:29:56.926 A:middle
你们终于有了能够证明

00:29:56.926 --> 00:29:58.216 A:middle
从纹理中获取

00:29:58.216 --> 00:29:59.746 A:middle
是昂贵的

00:29:59.746 --> 00:30:01.226 A:middle
这件事的数据

00:29:59.746 --> 00:30:01.226 A:middle
这件事的数据

00:30:01.226 --> 00:30:02.176 A:middle
但现在你知道为什么了

00:30:03.296 --> 00:30:05.076 A:middle
访问这个纹理

00:30:05.076 --> 00:30:06.216 A:middle
在 Fragment Shader 上是一个开始

00:30:06.216 --> 00:30:08.136 A:middle
因为它必须从

00:30:08.136 --> 00:30:09.196 A:middle
内置内存中获取数据

00:30:09.196 --> 00:30:11.426 A:middle
这些数据现在在缓存里

00:30:12.376 --> 00:30:12.576 A:middle
已经没有了

00:30:12.706 --> 00:30:13.656 A:middle
这种程度的细节

00:30:13.656 --> 00:30:14.716 A:middle
一般在咨询工具之外

00:30:14.716 --> 00:30:15.606 A:middle
很难见到

00:30:16.706 --> 00:30:17.896 A:middle
解决这个问题现在

00:30:17.896 --> 00:30:20.566 A:middle
取决于平衡 性能

00:30:21.006 --> 00:30:22.736 A:middle
质量和正确率

00:30:22.736 --> 00:30:23.926 A:middle
但你已经展示了

00:30:23.926 --> 00:30:25.036 A:middle
要如何运用 GPU 计数和

00:30:25.036 --> 00:30:27.376 A:middle
GPU 帧调试器 来帮助你

00:30:27.376 --> 00:30:30.196 A:middle
调查 分析

00:30:30.196 --> 00:30:32.016 A:middle
分辨任何的捕捉信息

00:30:32.016 --> 00:30:34.246 A:middle
任何在你的捕捉里的

00:30:34.246 --> 00:30:35.256 A:middle
性能信息

00:30:35.676 --> 00:30:37.056 A:middle
现在再请我的同事

00:30:37.056 --> 00:30:37.586 A:middle
Seth 回来

00:30:38.516 --> 00:30:43.500 A:middle
[掌声]

00:30:48.386 --> 00:30:48.976 A:middle
&gt;&gt; 谢谢 Jose

00:30:50.696 --> 00:30:52.756 A:middle
这就是 GPU 计数

00:30:52.756 --> 00:30:53.346 A:middle
分析

00:30:53.966 --> 00:30:54.926 A:middle
和我们今天说过的所有新

00:30:54.926 --> 00:30:56.456 A:middle
特性一样

00:30:56.456 --> 00:30:58.676 A:middle
它是 Xcode Beta 9 里的最大乐趣

00:30:59.166 --> 00:31:00.716 A:middle
它对所有可以使用 Metal 的

00:30:59.166 --> 00:31:00.716 A:middle
它对所有可以使用 Metal 的

00:31:00.716 --> 00:31:01.906 A:middle
GPU 都适用

00:31:02.656 --> 00:31:04.356 A:middle
你们会发现

00:31:04.356 --> 00:31:05.586 A:middle
越新的 GPU 就有越多的计数可用

00:31:05.586 --> 00:31:07.676 A:middle
因为 GPU 更加现代化了

00:31:07.986 --> 00:31:10.086 A:middle
但所有的 GPU

00:31:10.086 --> 00:31:11.976 A:middle
都会有丰富可用的

00:31:11.976 --> 00:31:13.616 A:middle
计数

00:31:14.026 --> 00:31:16.616 A:middle
尽管如此 我们还是非常

00:31:16.616 --> 00:31:17.936 A:middle
期待你们的反馈

00:31:17.936 --> 00:31:18.946 A:middle
如果你们觉得哪个计数

00:31:18.946 --> 00:31:19.696 A:middle
还没有 它又非常

00:31:19.696 --> 00:31:22.156 A:middle
有价值 那么就请

00:31:22.426 --> 00:31:24.606 A:middle
务必光临实验室

00:31:24.606 --> 00:31:26.046 A:middle
我们会很乐意

00:31:26.046 --> 00:31:26.956 A:middle
进行研究

00:31:27.386 --> 00:31:28.986 A:middle
我们今天说了

00:31:28.986 --> 00:31:29.226 A:middle
什么呢

00:31:29.486 --> 00:31:30.586 A:middle
我们讲到了

00:31:30.586 --> 00:31:31.906 A:middle
Metal 帧调试器的一些很好的改进

00:31:31.906 --> 00:31:33.676 A:middle
包括支持像素检查

00:31:33.676 --> 00:31:35.846 A:middle
检查 Vertex

00:31:36.246 --> 00:31:39.256 A:middle
Shader 输出 丰富的过滤

00:31:39.776 --> 00:31:42.186 A:middle
更好的捕捉支持

00:31:42.186 --> 00:31:44.196 A:middle
更好的捕捉性能

00:31:44.196 --> 00:31:45.696 A:middle
和 Xcode Metal Quick Look

00:31:46.216 --> 00:31:49.206 A:middle
我们还讲到了

00:31:49.206 --> 00:31:50.586 A:middle
对 Metal 托盘调试器中

00:31:50.586 --> 00:31:53.506 A:middle
VR 应用的调试和分析的支持

00:31:53.506 --> 00:31:54.876 A:middle
以及 Metal 系统托盘

00:31:57.356 --> 00:31:59.986 A:middle
我们讲到了 Metal

00:32:00.056 --> 00:32:01.726 A:middle
通道数据

00:32:01.726 --> 00:32:03.236 A:middle
让你们直接进入

00:32:03.236 --> 00:32:04.316 A:middle
GPU compiler

00:32:04.316 --> 00:32:04.916 A:middle
获取性能信息

00:32:06.696 --> 00:32:08.516 A:middle
我们还介绍了 GPU 计数分析

00:32:08.516 --> 00:32:11.586 A:middle
它让你们能够

00:32:11.586 --> 00:32:13.626 A:middle
访问 Metal 里的

00:32:13.626 --> 00:32:17.346 A:middle
GPU 性能计数数据

00:32:17.626 --> 00:32:19.866 A:middle
更多信息请访问

00:32:19.866 --> 00:32:20.486 A:middle
网站

00:32:22.166 --> 00:32:23.846 A:middle
编号是 607

00:32:23.846 --> 00:32:28.276 A:middle
我还想推荐

00:32:28.276 --> 00:32:29.956 A:middle
其他的一些演讲

00:32:30.316 --> 00:32:31.756 A:middle
如果你们没有赶上

00:32:31.756 --> 00:32:33.946 A:middle
Introducing Metal 2 或者 VR With

00:32:33.946 --> 00:32:35.716 A:middle
Metal 2 这两场本周早些时候的

00:32:35.716 --> 00:32:38.186 A:middle
演讲 它们非常值得

00:32:38.186 --> 00:32:39.896 A:middle
你通过视频来再次观看

00:32:39.896 --> 00:32:41.606 A:middle
就算你们已经去过

00:32:41.606 --> 00:32:42.736 A:middle
也请在视频中再次看看它们

00:32:43.066 --> 00:32:45.246 A:middle
今天下午晚些时候

00:32:45.246 --> 00:32:46.446 A:middle
还有一场很棒的演讲

00:32:46.446 --> 00:32:47.706 A:middle
关于使用 Metal 2 进行计算

00:32:47.706 --> 00:32:49.856 A:middle
在 A 大厅

00:32:49.926 --> 00:32:50.866 A:middle
4 点 10 分开始

00:32:51.386 --> 00:32:52.996 A:middle
就到这里

00:32:52.996 --> 00:32:54.216 A:middle
谢谢大家

00:32:54.556 --> 00:32:56.086 A:middle
祝你们接下来的

00:32:56.146 --> 00:32:58.436 A:middle
WWDC 17 有所收获

00:32:58.436 --> 00:32:58.776 A:middle
谢谢大家
